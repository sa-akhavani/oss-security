# ====================================================================
# FILE: setup.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-27 ---
     1| """Setup for the Acquisition egg package
     2| """
     3| import os
     4| from setuptools import setup, find_packages, Extension
     5| EXTENSIONCLASS_INCLUDEDIRS = ['include', 'src']
     6| params = dict(name='Zope2',
     7|     version='2.12.5',
     8|     url='http://www.zope.org',
     9|     license='ZPL 2.1',
    10|     description='Zope2 application server / web framework',
    11|     author='Zope Foundation and Contributors',
    12|     author_email='zope-dev@zope.org',
    13|     long_description=file("README.txt").read() + "\n" +
    14|                      file(os.path.join("doc", "CHANGES.rst")).read(),
    15|     packages=find_packages('src'),
    16|     namespace_packages=['Products'],
    17|     package_dir={'': 'src'},
    18|     ext_modules=[
    19|       Extension(
    20|             name='AccessControl.cAccessControl',
    21|             include_dirs=EXTENSIONCLASS_INCLUDEDIRS,
    22|             sources=['src/AccessControl/cAccessControl.c'],
    23|             depends=['include/ExtensionClass/ExtensionClass.h',
    24|                      'include/ExtensionClass/pickle/pickle.c',
    25|                      'include/Acquisition/Acquisition.h']),
    26|       Extension(
    27|             name='DocumentTemplate.cDocumentTemplate',


# ====================================================================
# FILE: src/OFS/SimpleItem.py
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-31 ---
     1| """This module implements a simple item mix-in for objects that have a
     2| very simple (e.g. one-screen) management interface, like documents,
     3| Aqueduct database adapters, etc.
     4| This module can also be used as a simple template for implementing new
     5| item types.
     6| $Id$
     7| """
     8| import marshal
     9| import re
    10| import sys
    11| import time
    12| from AccessControl.SecurityInfo import ClassSecurityInfo
    13| from AccessControl.SecurityManagement import getSecurityManager
    14| from AccessControl.Owned import Owned
    15| from AccessControl.Permissions import view as View
    16| from AccessControl.Role import RoleManager
    17| from AccessControl.unauthorized import Unauthorized
    18| from AccessControl.ZopeSecurityPolicy import getRoles
    19| from Acquisition import Acquired
    20| from Acquisition import aq_acquire
    21| from Acquisition import aq_base
    22| from Acquisition import aq_inner
    23| from Acquisition import aq_parent
    24| from Acquisition import Implicit
    25| from App.Management import Tabs
    26| from App.class_init import InitializeClass
    27| from App.special_dtml import HTML
    28| from App.special_dtml import DTMLFile
    29| from App.Undo import UndoSupport
    30| from ComputedAttribute import ComputedAttribute
    31| from DocumentTemplate.html_quote import html_quote

# --- HUNK 2: Lines 147-217 ---
   147|             if hasattr(self, '_v_eek'):
   148|                 raise error_type, error_value, tb
   149|             self._v_eek = 1
   150|             if error_name.lower() in ('redirect',):
   151|                 raise error_type, error_value, tb
   152|             if not error_message:
   153|                 try:
   154|                     s = ustr(error_value)
   155|                 except:
   156|                     s = error_value
   157|                 try:
   158|                     match = tagSearch(s)
   159|                 except TypeError:
   160|                     match = None
   161|                 if match is not None:
   162|                     error_message=error_value
   163|             if client is None:
   164|                 client = self
   165|             if not REQUEST:
   166|                 REQUEST = aq_acquire(self, 'REQUEST')
   167|             try:
   168|                 s = aq_acquire(client, 'standard_error_message')
   169|                 kwargs = {'error_type': error_name,
   170|                           'error_value': error_value,
   171|                           'error_tb': error_tb,
   172|                           'error_traceback': error_tb,
   173|                           'error_message': error_message,
   174|                           'error_log_url': error_log_url}
   175|                 if getattr(aq_base(s), 'isDocTemp', 0):
   176|                     v = s(client, REQUEST, **kwargs)
   177|                 elif callable(s):
   178|                     v = s(**kwargs)
   179|                 else:
   180|                     v = HTML.__call__(s, client, REQUEST, **kwargs)
   181|             except:
   182|                 logger.error(
   183|                     'Exception while rendering an error message',
   184|                     exc_info=True
   185|                     )
   186|                 try:
   187|                     strv = repr(error_value) # quotes tainted strings
   188|                 except:
   189|                     strv = ('<unprintable %s object>' % 
   190|                             str(type(error_value).__name__))
   191|                 v = strv + (
   192|                     (" (Also, the following error occurred while attempting "
   193|                      "to render the standard error message, please see the "
   194|                      "event log for full details: %s)")%(
   195|                     html_quote(sys.exc_info()[1]),
   196|                     ))
   197|             return error_type, v, tb
   198|         finally:
   199|             if hasattr(self, '_v_eek'): del self._v_eek
   200|             tb = None
   201|     def manage(self, URL1):
   202|         """
   203|         """
   204|         raise Redirect, "%s/manage_main" % URL1
   205|     def objectValues(self, spec=None):
   206|         return ()
   207|     objectIds=objectItems=objectValues
   208|     def manage_FTPstat(self,REQUEST):
   209|         """Psuedo stat, used by FTP for directory listings.
   210|         """
   211|         from AccessControl.User import nobody
   212|         mode=0100000
   213|         if (hasattr(aq_base(self),'manage_FTPget')):
   214|             try:
   215|                 if getSecurityManager().validate(
   216|                     None, self, 'manage_FTPget', self.manage_FTPget):
   217|                     mode=mode | 0440


# ====================================================================
# FILE: src/OFS/subscribers.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-64 ---
     1| """
     2| Subscriber definitions.
     3| """
     4| from logging import getLogger
     5| import OFS.interfaces
     6| from Acquisition import aq_base
     7| from App.config import getConfiguration
     8| from AccessControl import getSecurityManager
     9| from ZODB.POSException import ConflictError
    10| import zope.component
    11| import zope.interface
    12| import zope.location.interfaces
    13| from zope.container.contained import dispatchToSublocations
    14| from zope.lifecycleevent.interfaces import IObjectMovedEvent
    15| from zope.lifecycleevent.interfaces import IObjectCopiedEvent
    16| deprecatedManageAddDeleteClasses = []
    17| LOG = getLogger('OFS.subscribers')
    18| def compatibilityCall(method_name, *args):
    19|     """Call a method if events have not been setup yet.
    20|     This is the case for some unit tests that have not been converted to
    21|     use the component architecture.
    22|     """
    23|     if deprecatedManageAddDeleteClasses:
    24|         return
    25|     if method_name == 'manage_afterAdd':
    26|         callManageAfterAdd(*args)
    27|     elif method_name == 'manage_beforeDelete':
    28|         callManageBeforeDelete(*args)
    29|     else:
    30|         callManageAfterClone(*args)
    31| def maybeWarnDeprecated(ob, method_name):
    32|     """Send a warning if a method is deprecated.
    33|     """
    34|     if not deprecatedManageAddDeleteClasses:
    35|         return
    36|     for cls in deprecatedManageAddDeleteClasses:
    37|         if isinstance(ob, cls):
    38|             return
    39|     if getattr(getattr(ob, method_name), '__five_method__', False):
    40|         return
    41|     class_ = ob.__class__
    42|     LOG.debug(
    43|         "%s.%s.%s is discouraged. You should use event subscribers instead." %
    44|         (class_.__module__, class_.__name__, method_name))
    45| class ObjectManagerSublocations(object):
    46|     """Get the sublocations for an ObjectManager.
    47|     """
    48|     zope.component.adapts(OFS.interfaces.IObjectManager)
    49|     zope.interface.implements(zope.location.interfaces.ISublocations)
    50|     def __init__(self, container):
    51|         self.container = container
    52|     def sublocations(self):
    53|         for ob in self.container.objectValues():
    54|             yield ob
    55| @zope.component.adapter(OFS.interfaces.IItem,
    56|                         OFS.interfaces.IObjectWillBeMovedEvent)
    57| def dispatchObjectWillBeMovedEvent(ob, event):
    58|     """Multi-subscriber for IItem + IObjectWillBeMovedEvent.
    59|     """
    60|     if OFS.interfaces.IObjectManager.providedBy(ob):
    61|         dispatchToSublocations(ob, event)
    62|     callManageBeforeDelete(ob, event.object, event.oldParent)
    63| @zope.component.adapter(OFS.interfaces.IItem, IObjectMovedEvent)
    64| def dispatchObjectMovedEvent(ob, event):


# ====================================================================
# FILE: src/Products/Five/browser/resource.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-34 ---
     1| """Provide basic resource functionality
     2| $Id$
     3| """
     4| import os
     5| import urllib
     6| from zope.interface import implements
     7| from zope.component import getMultiAdapter
     8| from zope.traversing.browser import absoluteURL
     9| from zope.publisher.interfaces import NotFound
    10| from zope.publisher.interfaces.browser import IBrowserPublisher
    11| from zope.app.publisher.browser import fileresource, directoryresource
    12| from zope.app.publisher.fileresource import File, Image
    13| from zope.app.publisher.pagetemplateresource import PageTemplate
    14| from Acquisition import aq_base
    15| from Products.Five.browser import BrowserView
    16| _marker = object()
    17| class Resource(object):
    18|     """A mixin that changes the URL-rendering of resources (__call__).
    19|     In Zope 3, resource URLs are of the form
    20|     nearest_site/@@/resource_name.  Since Zope 2 didn't have support
    21|     for sites from the beginning of the Five integration, resource
    22|     URLs in Zope 2 are of the form context/++resource++resource_name.
    23|     TODO It would be good if that could be changed in the long term,
    24|     thus making this mixin (and probably the other classes in this
    25|     module) obsolete.
    26|     """
    27|     def __call__(self):
    28|         name = self.__name__
    29|         container = self.__parent__
    30|         url = urllib.unquote(absoluteURL(container, self.request))
    31|         if not isinstance(container, DirectoryResource):
    32|             name = '++resource++%s' % name
    33|         return "%s/%s" % (url, name)
    34| class PageTemplateResource(Resource, BrowserView):

# --- HUNK 2: Lines 90-115 ---
    90|         if not name.startswith('++resource++'):
    91|             name = '++resource++%s' % self.__name__
    92|         return name
    93|     def get(self, name, default=_marker):
    94|         path = self.context.path
    95|         filename = os.path.join(path, name)
    96|         isfile = os.path.isfile(filename)
    97|         isdir = os.path.isdir(filename)
    98|         if not (isfile or isdir):
    99|             if default is _marker:
   100|                 raise KeyError(name)
   101|             return default
   102|         if isfile:
   103|             ext = name.split('.')[-1]
   104|             factory = self.resource_factories.get(ext, self.default_factory)
   105|         else:
   106|             factory = DirectoryResourceFactory
   107|         resource = factory(name, filename)(self.request)
   108|         resource.__name__ = name
   109|         resource.__parent__ = self
   110|         if hasattr(aq_base(self), '__roles__'):
   111|             resource.__roles__ = self.__roles__
   112|         return resource
   113| class DirectoryResourceFactory(ResourceFactory):
   114|     factory = Directory
   115|     resource = DirectoryResource


# ====================================================================
# FILE: src/Products/PluginIndexes/PathIndex/PathIndex.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-210 ---
     1| """Path index.
     2| """
     3| from logging import getLogger
     4| from App.special_dtml import DTMLFile
     5| from OFS.SimpleItem import SimpleItem
     6| from BTrees.IIBTree import IITreeSet
     7| from BTrees.IIBTree import IISet
     8| from BTrees.IIBTree import intersection
     9| from BTrees.IIBTree import multiunion
    10| from BTrees.IIBTree import union
    11| from BTrees.IOBTree import IOBTree
    12| from BTrees.OOBTree import OOBTree
    13| from BTrees.Length import Length
    14| from Persistence import Persistent
    15| from zope.interface import implements
    16| from Products.PluginIndexes.common import safe_callable
    17| from Products.PluginIndexes.common.util import parseIndexRequest
    18| from Products.PluginIndexes.interfaces import IPathIndex
    19| from Products.PluginIndexes.interfaces import ISortIndex
    20| from Products.PluginIndexes.interfaces import IUniqueValueIndex
    21| LOG = getLogger('Zope.PathIndex')
    22| class PathIndex(Persistent, SimpleItem):
    23|     """Index for paths returned by getPhysicalPath.
    24|     A path index stores all path components of the physical path of an object.
    25|     Internal datastructure:
    26|     - a physical path of an object is split into its components
    27|     - every component is kept as a  key of a OOBTree in self._indexes
    28|     - the value is a mapping 'level of the path component' to
    29|       'all docids with this path component on this level'
    30|     """
    31|     implements(IPathIndex, IUniqueValueIndex, ISortIndex)
    32|     meta_type="PathIndex"
    33|     query_options = ('query', 'level', 'operator')
    34|     manage_options= (
    35|         {'label': 'Settings',
    36|          'action': 'manage_main',
    37|          'help': ('PathIndex','PathIndex_Settings.stx')},
    38|     )
    39|     def __init__(self,id,caller=None):
    40|         self.id = id
    41|         self.operators = ('or','and')
    42|         self.useOperator = 'or'
    43|         self.clear()
    44|     def __len__(self):
    45|         return self._length()
    46|     def getEntryForObject(self, docid, default=None):
    47|         """ See IPluggableIndex.
    48|         """
    49|         try:
    50|             return self._unindex[docid]
    51|         except KeyError:
    52|             return default
    53|     def getIndexSourceNames(self):
    54|         """ See IPluggableIndex.
    55|         """
    56|         return (self.id, 'getPhysicalPath', )
    57|     def index_object(self, docid, obj ,threshold=100):
    58|         """ See IPluggableIndex.
    59|         """
    60|         f = getattr(obj, self.id, None)
    61|         if f is not None:
    62|             if safe_callable(f):
    63|                 try:
    64|                     path = f()
    65|                 except AttributeError:
    66|                     return 0
    67|             else:
    68|                 path = f
    69|             if not isinstance(path, (str, tuple)):
    70|                 raise TypeError('path value must be string or tuple of strings')
    71|         else:
    72|             try:
    73|                 path = obj.getPhysicalPath()
    74|             except AttributeError:
    75|                 return 0
    76|         if isinstance(path, (list, tuple)):
    77|             path = '/'+ '/'.join(path[1:])
    78|         comps = filter(None, path.split('/'))
    79|         if not self._unindex.has_key(docid):
    80|             self._length.change(1)
    81|         for i in range(len(comps)):
    82|             self.insertEntry(comps[i], docid, i)
    83|         self._unindex[docid] = path
    84|         return 1
    85|     def unindex_object(self, docid):
    86|         """ See IPluggableIndex.
    87|         """
    88|         if docid not in self._unindex:
    89|             LOG.debug('Attempt to unindex nonexistent document with id %s'
    90|                       % docid)
    91|             return
    92|         comps =  self._unindex[docid].split('/')
    93|         for level in range(len(comps[1:])):
    94|             comp = comps[level+1]
    95|             try:
    96|                 self._index[comp][level].remove(docid)
    97|                 if not self._index[comp][level]:
    98|                     del self._index[comp][level]
    99|                 if not self._index[comp]:
   100|                     del self._index[comp]
   101|             except KeyError:
   102|                 LOG.debug('Attempt to unindex document with id %s failed'
   103|                           % docid)
   104|         self._length.change(-1)
   105|         del self._unindex[docid]
   106|     def _apply_index(self, request):
   107|         """ See IPluggableIndex.
   108|         o Unpacks args from catalog and mapps onto '_search'.
   109|         """
   110|         record = parseIndexRequest(request, self.id, self.query_options)
   111|         if record.keys is None:
   112|             return None
   113|         level = record.get("level", 0)
   114|         operator = record.get('operator', self.useOperator).lower()
   115|         if operator == "or":
   116|             set_func = union
   117|         else:
   118|             set_func = intersection
   119|         res = None
   120|         for k in record.keys:
   121|             rows = self._search(k,level)
   122|             res = set_func(res,rows)
   123|         if res:
   124|             return res, (self.id,)
   125|         else:
   126|             return IISet(), (self.id,)
   127|     def numObjects(self):
   128|         """ See IPluggableIndex.
   129|         """
   130|         return len(self._unindex)
   131|     def indexSize(self):
   132|         """ See IPluggableIndex.
   133|         """
   134|         return len(self)
   135|     def clear(self):
   136|         """ See IPluggableIndex.
   137|         """
   138|         self._depth = 0
   139|         self._index = OOBTree()
   140|         self._unindex = IOBTree()
   141|         self._length = Length(0)
   142|     def hasUniqueValuesFor(self, name):
   143|         """ See IUniqueValueIndex.
   144|         """
   145|         return name == self.id
   146|     def uniqueValues(self, name=None, withLength=0):
   147|         """  See IUniqueValueIndex.
   148|         """
   149|         if name in (None, self.id, 'getPhysicalPath'):
   150|             if withLength:
   151|                 for key in self._index:
   152|                     yield key, len(self._search(key, -1))
   153|             else:
   154|                 for key in self._index.keys():
   155|                     yield key
   156|     def keyForDocument(self, documentId):
   157|         """ See ISortIndex.
   158|         """
   159|         return self._unindex.get(documentId)
   160|     def documentToKeyMap(self):
   161|         """ See ISortIndex.
   162|         """
   163|         return self._unindex
   164|     def insertEntry(self, comp, id, level):
   165|         """ See IPathIndex
   166|         """
   167|         if not self._index.has_key(comp):
   168|             self._index[comp] = IOBTree()
   169|         if not self._index[comp].has_key(level):
   170|             self._index[comp][level] = IITreeSet()
   171|         self._index[comp][level].insert(id)
   172|         if level > self._depth:
   173|             self._depth = level
   174|     def _search(self, path, default_level=0):
   175|         """ Perform the actual search.
   176|         ``path``
   177|             a string representing a relative URL, or a part of a relative URL,
   178|             or a tuple ``(path, level)``.  In the first two cases, use
   179|             ``default_level`` as the level for the search.
   180|         ``default_level``
   181|             the level to use for non-tuple queries.
   182|         ``level >= 0`` =>  match ``path`` only at the given level.
   183|         ``level <  0`` =>  match ``path`` at *any* level
   184|         """
   185|         if isinstance(path, str):
   186|             level = default_level
   187|         else:
   188|             level = int(path[1])
   189|             path  = path[0]
   190|         if level < 0:
   191|             return multiunion(
   192|                 [self._search(path, level) 
   193|                  for level in xrange(self._depth + 1)])
   194|         comps = filter(None, path.split('/'))
   195|         if level + len(comps) - 1 > self._depth:
   196|             return IISet()
   197|         if len(comps) == 0:
   198|             return IISet(self._unindex.keys())
   199|         results = None
   200|         for i, comp in reversed(list(enumerate(comps))):
   201|             if not self._index.get(comp, {}).has_key(level+i): return IISet()
   202|             results = intersection(results, self._index[comp][level+i])
   203|         return results
   204|     manage = manage_main = DTMLFile('dtml/managePathIndex', globals())
   205|     manage_main._setName('manage_main')
   206| manage_addPathIndexForm = DTMLFile('dtml/addPathIndex', globals())
   207| def manage_addPathIndex(self, id, REQUEST=None, RESPONSE=None, URL3=None):
   208|     """Add a path index"""
   209|     return self.manage_addIndex(id, 'PathIndex', extra=None, \
   210|                 REQUEST=REQUEST, RESPONSE=RESPONSE, URL1=URL3)


# ====================================================================
# FILE: src/Products/PluginIndexes/__init__.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-74 ---
     1| def initialize(context):
     2|     from Products.PluginIndexes.FieldIndex.FieldIndex import FieldIndex
     3|     from Products.PluginIndexes.FieldIndex.FieldIndex \
     4|         import manage_addFieldIndex
     5|     from Products.PluginIndexes.FieldIndex.FieldIndex \
     6|         import manage_addFieldIndexForm
     7|     context.registerClass(FieldIndex,
     8|                           permission='Add Pluggable Index', 
     9|                           constructors=(manage_addFieldIndexForm,
    10|                                         manage_addFieldIndex),
    11|                           icon='www/index.gif',
    12|                           visibility=None,
    13|                          )
    14|     from Products.PluginIndexes.KeywordIndex.KeywordIndex import KeywordIndex
    15|     from Products.PluginIndexes.KeywordIndex.KeywordIndex \
    16|         import manage_addKeywordIndex
    17|     from Products.PluginIndexes.KeywordIndex.KeywordIndex \
    18|         import manage_addKeywordIndexForm
    19|     context.registerClass(KeywordIndex,
    20|                           permission='Add Pluggable Index', 
    21|                           constructors=(manage_addKeywordIndexForm,
    22|                                         manage_addKeywordIndex),
    23|                           icon='www/index.gif',
    24|                           visibility=None,
    25|                          )
    26|     from Products.PluginIndexes.TopicIndex.TopicIndex import TopicIndex
    27|     from Products.PluginIndexes.TopicIndex.TopicIndex \
    28|         import manage_addTopicIndex
    29|     from Products.PluginIndexes.TopicIndex.TopicIndex \
    30|         import manage_addTopicIndexForm
    31|     context.registerClass(TopicIndex,
    32|                           permission='Add Pluggable Index', 
    33|                           constructors=(manage_addTopicIndexForm,
    34|                                         manage_addTopicIndex),
    35|                           icon='www/index.gif',
    36|                           visibility=None,
    37|                          )
    38|     from Products.PluginIndexes.DateIndex.DateIndex import DateIndex
    39|     from Products.PluginIndexes.DateIndex.DateIndex \
    40|         import manage_addDateIndex
    41|     from Products.PluginIndexes.DateIndex.DateIndex \
    42|         import manage_addDateIndexForm
    43|     context.registerClass(DateIndex,
    44|                           permission='Add Pluggable Index', 
    45|                           constructors=(manage_addDateIndexForm,
    46|                                         manage_addDateIndex),
    47|                           icon='www/index.gif',
    48|                           visibility=None,
    49|                          )
    50|     from Products.PluginIndexes.DateRangeIndex.DateRangeIndex \
    51|         import DateRangeIndex
    52|     from Products.PluginIndexes.DateRangeIndex.DateRangeIndex \
    53|         import manage_addDateRangeIndex
    54|     from Products.PluginIndexes.DateRangeIndex.DateRangeIndex \
    55|         import manage_addDateRangeIndexForm
    56|     context.registerClass(DateRangeIndex,
    57|                           permission='Add Pluggable Index', 
    58|                           constructors=(manage_addDateRangeIndexForm,
    59|                                         manage_addDateRangeIndex),
    60|                           icon='www/index.gif',
    61|                           visibility=None,
    62|                          )
    63|     from Products.PluginIndexes.PathIndex.PathIndex import PathIndex
    64|     from Products.PluginIndexes.PathIndex.PathIndex \
    65|         import manage_addPathIndex
    66|     from Products.PluginIndexes.PathIndex.PathIndex \
    67|         import manage_addPathIndexForm
    68|     context.registerClass(PathIndex,
    69|                           permission='Add Pluggable Index', 
    70|                           constructors=(manage_addPathIndexForm,
    71|                                         manage_addPathIndex),
    72|                           icon='www/index.gif',
    73|                           visibility=None,
    74|                          )


# ====================================================================
# FILE: src/Products/PluginIndexes/interfaces.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 76-123 ---
    76|       end date);
    77|     - Objects which match until a given time (i.e., they returned None for the
    78|       start date);
    79|     - Objects which match only during a specific interval.
    80|     """
    81|     def getSinceField():
    82|         """Get the name of the attribute indexed as start date.
    83|         """
    84|     def getUntilField():
    85|         """Get the name of the attribute indexed as end date.
    86|         """
    87| class IPathIndex(Interface):
    88|     """Index for paths returned by getPhysicalPath.
    89|     A path index stores all path components of the physical path of an object.
    90|     Internal datastructure:
    91|     - a physical path of an object is split into its components
    92|     - every component is kept as a  key of a OOBTree in self._indexes
    93|     - the value is a mapping 'level of the path component' to
    94|       'all docids with this path component on this level'
    95|     """
    96|     def insertEntry(comp, id, level):
    97|         """ Insert an entry.
    98|         This method is intended for use by subclasses:  it is not
    99|         a normal API for the index.
   100|         'comp' is an individual path component
   101|         'id' is the docid
   102|         .level'is the level of the component inside the path
   103|         """
   104| class IFilteredSet(Interface):
   105|     """A pre-calculated result list based on an expression.
   106|     """
   107|     def getExpression():
   108|         """Get the expression.
   109|         """
   110|     def getIds():
   111|         """Get the IDs of all objects for which the expression is True.
   112|         """
   113|     def setExpression(expr):
   114|         """Set the expression.
   115|         """
   116| class ITopicIndex(Interface):
   117|     """A TopicIndex maintains a set of FilteredSet objects.
   118|     Every FilteredSet object consists of an expression and and IISet with all
   119|     Ids of indexed objects that eval with this expression to 1.
   120|     """
   121|     def addFilteredSet(filter_id, typeFilteredSet, expr):
   122|         """Add a FilteredSet object.
   123|         """


# ====================================================================
# FILE: src/Products/ZCTextIndex/ZCTextIndex.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 229-285 ---
   229|     meta_type = 'ZCTextIndex Lexicon'
   230|     manage_options = ({'label':'Overview', 'action':'manage_main'},
   231|                       {'label':'Query', 'action':'queryLexicon'},
   232|                      ) + SimpleItem.manage_options
   233|     security = ClassSecurityInfo()
   234|     security.declareObjectProtected(LexiconQueryPerm)
   235|     def __init__(self, id, title='', *pipeline):
   236|         self.id = str(id)
   237|         self.title = str(title)
   238|         PLexicon.inheritedAttribute('__init__')(self, *pipeline)
   239|     def getPipelineNames(self):
   240|         """Return list of names of pipeline element classes"""
   241|         return [element.__class__.__name__ for element in self._pipeline]
   242|     _queryLexicon = DTMLFile('dtml/queryLexicon', globals())
   243|     security.declareProtected(LexiconQueryPerm, 'queryLexicon')
   244|     def queryLexicon(self, REQUEST, words=None, page=0, rows=20, cols=4):
   245|         """Lexicon browser/query user interface
   246|         """
   247|         if words:
   248|             wids = []
   249|             for word in self.parseTerms(words):
   250|                 wids.extend(self.globToWordIds(word))
   251|             words = [self.get_word(wid) for wid in wids]
   252|         else:
   253|             words = self.words()
   254|         word_count = len(words)
   255|         rows = max(min(rows, 500), 1)
   256|         cols = max(min(cols, 12), 1)
   257|         page_count = word_count / (rows * cols) + \
   258|                      (word_count % (rows * cols) > 0)
   259|         page = max(min(page, page_count - 1), 0)
   260|         start = rows * cols * page
   261|         end = min(rows * cols * (page + 1), word_count)
   262|         if word_count:
   263|             words = list(words[start:end])
   264|         else:
   265|             words = []
   266|         columns = []
   267|         i = 0
   268|         while i < len(words):
   269|             columns.append(words[i:i + rows])
   270|             i += rows
   271|         info = dict(page=page,
   272|                     rows=rows,
   273|                     cols=cols,
   274|                     start_word=start+1,
   275|                     end_word=end,
   276|                     word_count=word_count,
   277|                     page_count=page_count,
   278|                     page_range=xrange(page_count),
   279|                     page_columns=columns)
   280|         if REQUEST is not None:
   281|             return self._queryLexicon(self, REQUEST, **info)
   282|         return info
   283|     security.declareProtected(LexiconMgmtPerm, 'manage_main')
   284|     manage_main = DTMLFile('dtml/manageLexicon', globals())
   285| InitializeClass(PLexicon)


# ====================================================================
# FILE: src/ZPublisher/HTTPRequest.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1192-1232 ---
  1192|         for m in methods:
  1193|             if hasattr(file,m):
  1194|                 d[m] = getattr(file,m)
  1195|         self.headers = aFieldStorage.headers
  1196|         self.filename = aFieldStorage.filename
  1197|         try:
  1198|             self.headers.__allow_access_to_unprotected_subobjects__ = 1
  1199|         except:
  1200|             pass
  1201|     def __nonzero__(self):
  1202|         """FileUpload objects are considered false if their
  1203|            filename is empty.
  1204|         """
  1205|         return not not self.filename
  1206|     def xreadlines(self):
  1207|         return self
  1208| parse_cookie_lock = allocate_lock()
  1209| QPARMRE= re.compile(
  1210|         '([\x00- ]*([^\x00- ;,="]+)="([^"]*)"([\x00- ]*[;,])?[\x00- ]*)')
  1211| PARMRE = re.compile(
  1212|         '([\x00- ]*([^\x00- ;,="]+)=([^;]*)([\x00- ]*[;,])?[\x00- ]*)')
  1213| PARAMLESSRE = re.compile(
  1214|         '([\x00- ]*([^\x00- ;,="]+)[\x00- ]*[;,][\x00- ]*)')
  1215| def parse_cookie(text,
  1216|                  result=None,
  1217|                  qparmre=QPARMRE,
  1218|                  parmre=PARMRE,
  1219|                  paramlessre=PARAMLESSRE,
  1220|                  acquire=parse_cookie_lock.acquire,
  1221|                  release=parse_cookie_lock.release,
  1222|                  ):
  1223|     if result is None:
  1224|         result = {}
  1225|     already_have = result.has_key
  1226|     acquire()
  1227|     try:
  1228|         mo_q = qparmre.match(text)
  1229|         if mo_q:
  1230|             l = len(mo_q.group(1))
  1231|             name = mo_q.group(2)
  1232|             value = mo_q.group(3)


# ====================================================================
# FILE: src/ZPublisher/HTTPResponse.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 594-637 ---
   594|                 self.setHeader('location', v.args[0])
   595|                 self.setBody('')
   596|                 tb = None
   597|                 return self
   598|             else:
   599|                 try:
   600|                     l, b = v
   601|                     if (isinstance(l, str)
   602|                         and absuri_match(l) is not None):
   603|                         if self.status == 300:
   604|                             self.setStatus(302)
   605|                         self.setHeader('location', l)
   606|                         self.setBody(b)
   607|                         tb = None # one more patch covered
   608|                         return self
   609|                 except:
   610|                     pass # tb is not cleared in this case
   611|         b = v
   612|         if isinstance(b, Exception):
   613|             try:
   614|                 try:
   615|                     b = str(b)
   616|                 except UnicodeEncodeError:
   617|                     b = self._encode_unicode(unicode(b))
   618|             except:
   619|                 b = '<unprintable %s object>' % type(b).__name__
   620|         if fatal and t is SystemExit and v.code == 0:
   621|             body = self.setBody(
   622|                 (str(t),
   623|                  'Zope has exited normally.<p>' + self._traceback(t, v, tb) + '</p>'),
   624|                 is_error=1)
   625|         else:
   626|             try:
   627|                 match = tag_search(b)
   628|             except TypeError:
   629|                 match = None
   630|             if match is None:
   631|                 body = self.setBody(
   632|                     (str(t),
   633|                      'Sorry, a site error occurred.<p>'
   634|                      + self._traceback(t, v, tb)
   635|                      + '</p>'),
   636|                     is_error=1)
   637|             elif self.isHTML(b):


# ====================================================================
# FILE: src/ZPublisher/Publish.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 82-122 ---
    82|                       request, bind=1)
    83|         if result is not response:
    84|             response.setBody(result)
    85|         notify(PubBeforeCommit(request))
    86|         if transactions_manager:
    87|             transactions_manager.commit()
    88|         endInteraction()
    89|         notify(PubSuccess(request))
    90|         return response
    91|     except:
    92|         exc_info = sys.exc_info()
    93|         sm = None
    94|         if response is not None:
    95|             sm = getattr(response, "setMessage", None)
    96|         if sm is not None:
    97|             from asyncore import compact_traceback
    98|             cl,val= sys.exc_info()[:2]
    99|             sm('%s: %s %s' % (
   100|                 getattr(cl,'__name__',cl), val,
   101|                 debug_mode and compact_traceback()[-1] or ''))
   102|         if not debug and err_hook is not None:
   103|             retry = False
   104|             if parents:
   105|                 parents=parents[0]
   106|             try:
   107|                 try:
   108|                     return err_hook(parents, request,
   109|                                     sys.exc_info()[0],
   110|                                     sys.exc_info()[1],
   111|                                     sys.exc_info()[2],
   112|                                     )
   113|                 except Retry:
   114|                     if not request.supports_retry():
   115|                         return err_hook(parents, request,
   116|                                         sys.exc_info()[0],
   117|                                         sys.exc_info()[1],
   118|                                         sys.exc_info()[2],
   119|                                         )
   120|                     retry = True
   121|             finally:
   122|                 try:                     

# --- HUNK 2: Lines 128-168 ---
   128|                 finally:
   129|                     endInteraction()
   130|                     notify(PubFailure(request, exc_info, retry))
   131|             newrequest=request.retry()
   132|             request.close()  # Free resources held by the request.
   133|             if ISkinnable.providedBy(newrequest):
   134|                 setDefaultSkin(newrequest)
   135|             try:
   136|                 return publish(newrequest, module_name, after_list, debug)
   137|             finally:
   138|                 newrequest.close()
   139|         else:
   140|             try:                     
   141|                 try:
   142|                     notify(PubBeforeAbort(request, exc_info, False))
   143|                 finally:
   144|                     if transactions_manager:
   145|                         transactions_manager.abort()
   146|             finally:
   147|                 endInteraction()
   148|                 notify(PubFailure(request, exc_info, False))
   149|             raise
   150| def publish_module_standard(module_name,
   151|                    stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
   152|                    environ=os.environ, debug=0, request=None, response=None):
   153|     must_die=0
   154|     status=200
   155|     after_list=[None]
   156|     try:
   157|         try:
   158|             if response is None:
   159|                 response=Response(stdout=stdout, stderr=stderr)
   160|             else:
   161|                 stdout=response.stdout
   162|             response.handle_errors = not debug
   163|             if request is None:
   164|                 request=Request(stdin, environ, response)
   165|             if ISkinnable.providedBy(request):
   166|                 setDefaultSkin(request)
   167|             response = publish(request, module_name, after_list, debug=debug)
   168|         except SystemExit, v:


# ====================================================================
# FILE: src/Zope2/App/startup.py
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| """Initialize the Zope2 Package and provide a published module
     2| """
     3| from zope.component import queryMultiAdapter
     4| from AccessControl.SecurityManagement import newSecurityManager
     5| from AccessControl.SecurityManagement import noSecurityManager
     6| from Acquisition import aq_acquire
     7| from Acquisition import aq_base
     8| from Acquisition import aq_inner
     9| from Acquisition import aq_parent
    10| from Acquisition.interfaces import IAcquirer
    11| from App.config import getConfiguration
    12| from time import asctime
    13| from zExceptions import upgradeException
    14| from zExceptions import Redirect
    15| from zExceptions import Unauthorized
    16| from ZODB.POSException import ConflictError
    17| import transaction
    18| import AccessControl.User
    19| import ExtensionClass
    20| import imp
    21| import logging
    22| import OFS.Application
    23| import sys
    24| import ZODB
    25| import App.ZApplication
    26| import Zope2
    27| import ZPublisher
    28| from zope.event import notify
    29| from zope.processlifetime import DatabaseOpened
    30| app = None
    31| startup_time = asctime()
    32| def startup():
    33|     from App.PersistentExtra import patchPersistent
    34|     import Globals  # to set / fetch data
    35|     patchPersistent()
    36|     global app
    37|     OFS.Application.import_products()
    38|     configuration = getConfiguration()

# --- HUNK 2: Lines 120-200 ---
   120|                 raise ZPublisher.Retry(t, v, traceback)
   121|             if t is ZPublisher.Retry:
   122|                 try:
   123|                     v.reraise()
   124|                 except:
   125|                     t, v, traceback = sys.exc_info()
   126|                 if issubclass(t, ConflictError):
   127|                     self.unresolved_conflict_errors += 1
   128|             try:
   129|                 log = aq_acquire(published, '__error_log__', containment=1)
   130|             except AttributeError:
   131|                 error_log_url = ''
   132|             else:
   133|                 error_log_url = log.raising((t, v, traceback))
   134|             if (REQUEST is None or 
   135|                 (getattr(REQUEST.get('RESPONSE', None), '_error_format', '')
   136|                  != 'text/html')):
   137|                 raise t, v, traceback
   138|             view = queryMultiAdapter((v, REQUEST), name=u'index.html')
   139|             if view is not None:
   140|                 if IAcquirer.providedBy(view) and IAcquirer.providedBy(published):
   141|                     view = view.__of__(published)
   142|                 else:
   143|                     view.__parent__ = published
   144|                 v = view()
   145|                 if issubclass(t, Unauthorized):
   146|                     raise t, v, traceback
   147|                 response = REQUEST.RESPONSE
   148|                 response.setStatus(t)
   149|                 response.setBody(v)
   150|                 return response
   151|             if (published is None or published is app or
   152|                 isinstance(published, list)):
   153|                 published=app.__bobo_traverse__(REQUEST).__of__(
   154|                     RequestContainer(REQUEST))
   155|             published = getattr(published, 'im_self', published)
   156|             while 1:
   157|                 f = getattr(published, self.raise_error_message, None)
   158|                 if f is None:
   159|                     published = aq_parent(published)
   160|                     if published is None:
   161|                         raise t, v, traceback
   162|                 else:
   163|                     break
   164|             client = published
   165|             while 1:
   166|                 if getattr(client, self.error_message, None) is not None:
   167|                     break
   168|                 client = aq_parent(client)
   169|                 if client is None or aq_base(client) is aq_base(published):
   170|                     raise t, v, traceback
   171|             if REQUEST.get('AUTHENTICATED_USER', None) is None:
   172|                 REQUEST['AUTHENTICATED_USER'] = AccessControl.User.nobody
   173|             try:
   174|                 result = f(client, REQUEST, t, v, 
   175|                            traceback, 
   176|                            error_log_url=error_log_url)
   177|                 if result is not None:
   178|                     t, v, traceback = result
   179|                     if issubclass(t, Unauthorized):
   180|                         raise t, v, traceback
   181|                     response = REQUEST.RESPONSE
   182|                     response.setStatus(t)
   183|                     response.setBody(v)
   184|                     return response
   185|             except TypeError:
   186|                 f(client, REQUEST, t, v, traceback)
   187|         finally:
   188|             traceback = None
   189| zpublisher_exception_hook = ZPublisherExceptionHook()
   190| ac_logger = logging.getLogger('event.AccessControl')
   191| class TransactionsManager:
   192|     def begin(self,
   193|               transaction=transaction):
   194|         transaction.begin()
   195|     def commit(self):
   196|         if hasattr(transaction, 'isDoomed') and transaction.isDoomed():
   197|             transaction.abort()
   198|         else:
   199|             transaction.commit()
   200|     def abort(self):


# ====================================================================
# FILE: src/Zope2/Startup/handlers.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 127-168 ---
   127|         if os.path.isdir(instanceprod):
   128|             config.products.append(instanceprod)
   129|     import Products
   130|     L = []
   131|     for d in config.products + Products.__path__:
   132|         if d not in L:
   133|             L.append(d)
   134|     Products.__path__[:] = L
   135|     if config.mime_types:
   136|         from zope.contenttype import add_files
   137|         add_files(config.mime_types)
   138|     if not config.servers:
   139|         config.servers = []
   140|     for factory in config.servers:
   141|         factory.prepare(config.ip_address or '',
   142|                         config.dns_resolver,
   143|                         "Zope2",
   144|                         config.cgi_environment,
   145|                         config.port_base)
   146|     if config.trusted_proxies:
   147|         from ZPublisher import HTTPRequest
   148|         mapped = []
   149|         for name in config.trusted_proxies: mapped.extend(_name2Ips(name))
   150|         HTTPRequest.trusted_proxies = tuple(mapped)
   151|     if config.max_conflict_retries:
   152|         from ZPublisher import HTTPRequest
   153|         HTTPRequest.retry_max_count = config.max_conflict_retries
   154| def handleConfig(config, multihandler):
   155|     handlers = {}
   156|     for name, value in globals().items():
   157|         if not name.startswith('_'):
   158|             handlers[name] = value
   159|     return multihandler(handlers)
   160| def _name2Ips(host, isIp_=compile(r'(\d+\.){3}').match):
   161|     """Map a name *host* to the sequence of its ip addresses.
   162|     use *host* itself (as sequence) if it already is an ip address.
   163|     Thus, if only a specific interface on a host is trusted,
   164|     identify it by its ip (and not the host name).
   165|     """
   166|     if isIp_(host):
   167|         return [host]
   168|     return gethostbyaddr(host)[2]


# ====================================================================
# FILE: src/zExceptions/unauthorized.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-57 ---
     1| """
     2| $Id$
     3| """
     4| from zope.interface import implements
     5| from zope.security.interfaces import IUnauthorized
     6| class Unauthorized(Exception):
     7|     """Some user wasn't allowed to access a resource
     8|     """
     9|     implements(IUnauthorized)
    10|     def _get_message(self):
    11|         return self._message
    12|     message = property(_get_message,)
    13|     def __init__(self, message=None, value=None, needed=None, name=None, **kw):
    14|         """Possible signatures:
    15|         Unauthorized()
    16|         Unauthorized(message) # Note that message includes a space
    17|         Unauthorized(name)
    18|         Unauthorized(name, value)
    19|         Unauthorized(name, value, needed)
    20|         Unauthorized(message, value, needed, name)
    21|         Where needed is a mapping objects with items representing requirements
    22|         (e.g. {'permission': 'add spam'}). Any extra keyword arguments
    23|         provides are added to needed.
    24|         """
    25|         if name is None and (
    26|             not isinstance(message, basestring) or len(message.split()) <= 1):
    27|             name=message
    28|             message=None
    29|         self.name=name
    30|         self._message=message
    31|         self.value=value
    32|         if kw:
    33|             if needed: needed.update(kw)
    34|             else: needed=kw
    35|         self.needed=needed
    36|     def __str__(self):
    37|         if self.message is not None:
    38|             return self.message
    39|         if self.name is not None:
    40|             return ("You are not allowed to access '%s' in this context"
    41|                     % self.name)
    42|         elif self.value is not None:
    43|             return ("You are not allowed to access '%s' in this context"
    44|                     % self.getValueName())
    45|         return repr(self)
    46|     def __unicode__(self):
    47|         result = self.__str__()
    48|         if isinstance(result, unicode):
    49|             return result
    50|         return unicode(result, 'ascii') # override sys.getdefaultencoding()
    51|     def getValueName(self):
    52|         v=self.value
    53|         vname=getattr(v, '__name__', None)
    54|         if vname: return vname
    55|         c = getattr(v, '__class__', type(v))
    56|         c = getattr(c, '__name__', 'object')
    57|         return "a particular %s" % c

