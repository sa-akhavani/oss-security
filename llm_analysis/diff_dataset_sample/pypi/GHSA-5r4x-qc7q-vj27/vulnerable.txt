# ====================================================================
# FILE: inst/generate_index.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-44 ---
     1| """
     2| Generate an index file based on the version.cfg file of Zope 2
     3| in order to provide a version specific index page generated to be used
     4| in combination with easy_install -i <some_url>
     5| """
     6| import os
     7| import sys
     8| import urlparse
     9| from xmlrpclib import Server
    10| from ConfigParser import RawConfigParser as ConfigParser
    11| class CasePreservingConfigParser(ConfigParser):
    12|     def optionxform(self, option):
    13|         return option  # don't flatten case!
    14| def write_index(package, version):
    15|     print >>sys.stderr, 'Package %s==%s' % (package, version)
    16|     dest_dir = os.path.join(dirname, package)
    17|     if not os.path.exists(dest_dir):
    18|         os.makedirs(dest_dir)
    19|     index_html = os.path.join(dest_dir, 'index.html')
    20|     fp = file(index_html, 'w')
    21|     print >>fp, '<html><body>'
    22|     lst = server.package_urls(package, version)
    23|     if lst:
    24|         for d in lst:
    25|             link = '<a href="%s">%s</a>' % (d['url'], d['filename'])
    26|             print >>fp, link
    27|             print >>fp, '<br/>'
    28|     else:
    29|         rel_data = server.release_data(package, version)
    30|         download_url = rel_data['download_url']
    31|         filename = os.path.basename(urlparse.urlparse(download_url)[2])
    32|         link = '<a href="%s">%s</a>' % (download_url, filename)
    33|         print >>fp, link
    34|     print >>fp, '</body></html>'
    35|     fp.close()
    36| CP = CasePreservingConfigParser()
    37| CP.read(['versions.cfg'])
    38| server = Server('http://pypi.python.org/pypi')
    39| links = list()
    40| dirname = sys.argv[1]
    41| write_index('Zope2', '2.12.3')
    42| for package in CP.options('versions'):
    43|     version = CP.get('versions', package)
    44|     write_index(package, version)


# ====================================================================
# FILE: setup.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-27 ---
     1| """Setup for the Acquisition egg package
     2| """
     3| import os
     4| from setuptools import setup, find_packages, Extension
     5| EXTENSIONCLASS_INCLUDEDIRS = ['include', 'src']
     6| params = dict(name='Zope2',
     7|     version='2.12.4',
     8|     url='http://www.zope.org',
     9|     license='ZPL 2.1',
    10|     description='Zope2 application server / web framework',
    11|     author='Zope Foundation and Contributors',
    12|     author_email='zope-dev@zope.org',
    13|     long_description=file("README.txt").read() + "\n" +
    14|                      file(os.path.join("doc", "CHANGES.rst")).read(),
    15|     packages=find_packages('src'),
    16|     namespace_packages=['Products'],
    17|     package_dir={'': 'src'},
    18|     ext_modules=[
    19|       Extension(
    20|             name='AccessControl.cAccessControl',
    21|             include_dirs=EXTENSIONCLASS_INCLUDEDIRS,
    22|             sources=['src/AccessControl/cAccessControl.c'],
    23|             depends=['include/ExtensionClass/ExtensionClass.h',
    24|                      'include/ExtensionClass/pickle/pickle.c',
    25|                      'include/Acquisition/Acquisition.h']),
    26|       Extension(
    27|             name='DocumentTemplate.cDocumentTemplate',


# ====================================================================
# FILE: src/OFS/SimpleItem.py
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-33 ---
     1| """This module implements a simple item mix-in for objects that have a
     2| very simple (e.g. one-screen) management interface, like documents,
     3| Aqueduct database adapters, etc.
     4| This module can also be used as a simple template for implementing new
     5| item types.
     6| $Id$
     7| """
     8| import inspect
     9| import marshal
    10| import re
    11| import sys
    12| import time
    13| import warnings
    14| from AccessControl.SecurityInfo import ClassSecurityInfo
    15| from AccessControl.SecurityManagement import getSecurityManager
    16| from AccessControl.Owned import Owned
    17| from AccessControl.Permissions import view as View
    18| from AccessControl.Role import RoleManager
    19| from AccessControl.unauthorized import Unauthorized
    20| from AccessControl.ZopeSecurityPolicy import getRoles
    21| from Acquisition import Acquired
    22| from Acquisition import aq_acquire
    23| from Acquisition import aq_base
    24| from Acquisition import aq_inner
    25| from Acquisition import aq_parent
    26| from Acquisition import Implicit
    27| from App.Management import Tabs
    28| from App.class_init import InitializeClass
    29| from App.special_dtml import HTML
    30| from App.special_dtml import DTMLFile
    31| from App.Undo import UndoSupport
    32| from ComputedAttribute import ComputedAttribute
    33| from DocumentTemplate.html_quote import html_quote

# --- HUNK 2: Lines 149-237 ---
   149|             if hasattr(self, '_v_eek'):
   150|                 raise error_type, error_value, tb
   151|             self._v_eek = 1
   152|             if error_name.lower() in ('redirect',):
   153|                 raise error_type, error_value, tb
   154|             if not error_message:
   155|                 try:
   156|                     s = ustr(error_value)
   157|                 except:
   158|                     s = error_value
   159|                 try:
   160|                     match = tagSearch(s)
   161|                 except TypeError:
   162|                     match = None
   163|                 if match is not None:
   164|                     error_message=error_value
   165|             if client is None:
   166|                 client = self
   167|             if not REQUEST:
   168|                 REQUEST = aq_acquire(self, 'REQUEST')
   169|             handle_errors = getattr(getattr(REQUEST, 'RESPONSE', None),
   170|                                     'handle_errors', False)
   171|             can_raise = False
   172|             ctor = getattr(error_type, '__init__', None)
   173|             if inspect.ismethoddescriptor(ctor):
   174|                 can_raise = True
   175|             else:
   176|                 if inspect.ismethod(ctor):
   177|                     ctor = getattr(ctor, 'im_func', None)
   178|                 if inspect.isbuiltin(ctor):
   179|                     can_raise = True
   180|                 elif ctor is not None and inspect.isfunction(ctor):
   181|                     can_raise = (
   182|                         len(inspect.getargspec(error_type.__init__)[0]) > 2)
   183|             if not (can_raise and handle_errors):
   184|                 raise error_type, error_value, tb
   185|             try:
   186|                 s = aq_acquire(client, 'standard_error_message')
   187|                 kwargs = {'error_type': error_name,
   188|                           'error_value': error_value,
   189|                           'error_tb': error_tb,
   190|                           'error_traceback': error_tb,
   191|                           'error_message': error_message,
   192|                           'error_log_url': error_log_url}
   193|                 if getattr(aq_base(s), 'isDocTemp', 0):
   194|                     v = s(client, REQUEST, **kwargs)
   195|                 elif callable(s):
   196|                     v = s(**kwargs)
   197|                 else:
   198|                     v = HTML.__call__(s, client, REQUEST, **kwargs)
   199|             except:
   200|                 logger.error(
   201|                     'Exception while rendering an error message',
   202|                     exc_info=True
   203|                     )
   204|                 try:
   205|                     strv = repr(error_value) # quotes tainted strings
   206|                 except:
   207|                     strv = ('<unprintable %s object>' % 
   208|                             str(type(error_value).__name__))
   209|                 v = strv + (
   210|                     (" (Also, the following error occurred while attempting "
   211|                      "to render the standard error message, please see the "
   212|                      "event log for full details: %s)")%(
   213|                     html_quote(sys.exc_info()[1]),
   214|                     ))
   215|             if handle_errors:
   216|                 return error_type, v, tb
   217|             raise error_type, v, tb
   218|         finally:
   219|             if hasattr(self, '_v_eek'): del self._v_eek
   220|             tb = None
   221|     def manage(self, URL1):
   222|         """
   223|         """
   224|         raise Redirect, "%s/manage_main" % URL1
   225|     def objectValues(self, spec=None):
   226|         return ()
   227|     objectIds=objectItems=objectValues
   228|     def manage_FTPstat(self,REQUEST):
   229|         """Psuedo stat, used by FTP for directory listings.
   230|         """
   231|         from AccessControl.User import nobody
   232|         mode=0100000
   233|         if (hasattr(aq_base(self),'manage_FTPget')):
   234|             try:
   235|                 if getSecurityManager().validate(
   236|                     None, self, 'manage_FTPget', self.manage_FTPget):
   237|                     mode=mode | 0440


# ====================================================================
# FILE: src/OFS/subscribers.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-67 ---
     1| """
     2| Five subscriber definitions.
     3| $Id$
     4| """
     5| import warnings
     6| from logging import getLogger
     7| import OFS.interfaces
     8| from Acquisition import aq_base
     9| from App.config import getConfiguration
    10| from AccessControl import getSecurityManager
    11| from ZODB.POSException import ConflictError
    12| import zope.component
    13| import zope.interface
    14| import zope.location.interfaces
    15| from zope.container.contained import dispatchToSublocations
    16| from zope.lifecycleevent.interfaces import IObjectMovedEvent
    17| from zope.lifecycleevent.interfaces import IObjectCopiedEvent
    18| deprecatedManageAddDeleteClasses = []
    19| LOG = getLogger('OFS.subscribers')
    20| def compatibilityCall(method_name, *args):
    21|     """Call a method if events have not been setup yet.
    22|     This is the case for some unit tests that have not been converted to
    23|     use the component architecture.
    24|     """
    25|     if deprecatedManageAddDeleteClasses:
    26|         return
    27|     if method_name == 'manage_afterAdd':
    28|         callManageAfterAdd(*args)
    29|     elif method_name == 'manage_beforeDelete':
    30|         callManageBeforeDelete(*args)
    31|     else:
    32|         callManageAfterClone(*args)
    33| def maybeWarnDeprecated(ob, method_name):
    34|     """Send a warning if a method is deprecated.
    35|     """
    36|     if not deprecatedManageAddDeleteClasses:
    37|         return
    38|     for cls in deprecatedManageAddDeleteClasses:
    39|         if isinstance(ob, cls):
    40|             return
    41|     if getattr(getattr(ob, method_name), '__five_method__', False):
    42|         return
    43|     class_ = ob.__class__
    44|     warnings.warn(
    45|         "%s.%s.%s is discouraged. You should use event subscribers instead." %
    46|         (class_.__module__, class_.__name__, method_name),
    47|         DeprecationWarning)
    48| class ObjectManagerSublocations(object):
    49|     """Get the sublocations for an ObjectManager.
    50|     """
    51|     zope.component.adapts(OFS.interfaces.IObjectManager)
    52|     zope.interface.implements(zope.location.interfaces.ISublocations)
    53|     def __init__(self, container):
    54|         self.container = container
    55|     def sublocations(self):
    56|         for ob in self.container.objectValues():
    57|             yield ob
    58| @zope.component.adapter(OFS.interfaces.IItem,
    59|                         OFS.interfaces.IObjectWillBeMovedEvent)
    60| def dispatchObjectWillBeMovedEvent(ob, event):
    61|     """Multi-subscriber for IItem + IObjectWillBeMovedEvent.
    62|     """
    63|     if OFS.interfaces.IObjectManager.providedBy(ob):
    64|         dispatchToSublocations(ob, event)
    65|     callManageBeforeDelete(ob, event.object, event.oldParent)
    66| @zope.component.adapter(OFS.interfaces.IItem, IObjectMovedEvent)
    67| def dispatchObjectMovedEvent(ob, event):


# ====================================================================
# FILE: src/Products/Five/browser/resource.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-33 ---
     1| """Provide basic resource functionality
     2| $Id$
     3| """
     4| import os
     5| import urllib
     6| from zope.interface import implements
     7| from zope.component import getMultiAdapter
     8| from zope.traversing.browser import absoluteURL
     9| from zope.publisher.interfaces import NotFound
    10| from zope.publisher.interfaces.browser import IBrowserPublisher
    11| from zope.app.publisher.browser import fileresource, directoryresource
    12| from zope.app.publisher.fileresource import File, Image
    13| from zope.app.publisher.pagetemplateresource import PageTemplate
    14| from Products.Five.browser import BrowserView
    15| _marker = object()
    16| class Resource(object):
    17|     """A mixin that changes the URL-rendering of resources (__call__).
    18|     In Zope 3, resource URLs are of the form
    19|     nearest_site/@@/resource_name.  Since Zope 2 didn't have support
    20|     for sites from the beginning of the Five integration, resource
    21|     URLs in Zope 2 are of the form context/++resource++resource_name.
    22|     TODO It would be good if that could be changed in the long term,
    23|     thus making this mixin (and probably the other classes in this
    24|     module) obsolete.
    25|     """
    26|     def __call__(self):
    27|         name = self.__name__
    28|         container = self.__parent__
    29|         url = urllib.unquote(absoluteURL(container, self.request))
    30|         if not isinstance(container, DirectoryResource):
    31|             name = '++resource++%s' % name
    32|         return "%s/%s" % (url, name)
    33| class PageTemplateResource(Resource, BrowserView):

# --- HUNK 2: Lines 89-113 ---
    89|         if not name.startswith('++resource++'):
    90|             name = '++resource++%s' % self.__name__
    91|         return name
    92|     def get(self, name, default=_marker):
    93|         path = self.context.path
    94|         filename = os.path.join(path, name)
    95|         isfile = os.path.isfile(filename)
    96|         isdir = os.path.isdir(filename)
    97|         if not (isfile or isdir):
    98|             if default is _marker:
    99|                 raise KeyError(name)
   100|             return default
   101|         if isfile:
   102|             ext = name.split('.')[-1]
   103|             factory = self.resource_factories.get(ext, self.default_factory)
   104|         else:
   105|             factory = DirectoryResourceFactory
   106|         resource = factory(name, filename)(self.request)
   107|         resource.__name__ = name
   108|         resource.__parent__ = self
   109|         resource.__roles__ = self.__roles__
   110|         return resource
   111| class DirectoryResourceFactory(ResourceFactory):
   112|     factory = Directory
   113|     resource = DirectoryResource


# ====================================================================
# FILE: src/Products/PluginIndexes/PathIndex/PathIndex.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-189 ---
     1| """Path index.
     2| $Id$
     3| """
     4| from logging import getLogger
     5| from App.special_dtml import DTMLFile
     6| from OFS.SimpleItem import SimpleItem
     7| from BTrees.IIBTree import IITreeSet
     8| from BTrees.IIBTree import IISet
     9| from BTrees.IIBTree import intersection
    10| from BTrees.IIBTree import multiunion
    11| from BTrees.IIBTree import union
    12| from BTrees.IOBTree import IOBTree
    13| from BTrees.OOBTree import OOBTree
    14| from BTrees.Length import Length
    15| from Persistence import Persistent
    16| from zope.interface import implements
    17| from Products.PluginIndexes.common import safe_callable
    18| from Products.PluginIndexes.common.util import parseIndexRequest
    19| from Products.PluginIndexes.interfaces import IPathIndex
    20| from Products.PluginIndexes.interfaces import IUniqueValueIndex
    21| _marker = []
    22| LOG = getLogger('Zope.PathIndex')
    23| class PathIndex(Persistent, SimpleItem):
    24|     """Index for paths returned by getPhysicalPath.
    25|     A path index stores all path components of the physical path of an object.
    26|     Internal datastructure:
    27|     - a physical path of an object is split into its components
    28|     - every component is kept as a  key of a OOBTree in self._indexes
    29|     - the value is a mapping 'level of the path component' to
    30|       'all docids with this path component on this level'
    31|     """
    32|     implements(IPathIndex, IUniqueValueIndex)
    33|     meta_type="PathIndex"
    34|     query_options = ('query', 'level', 'operator')
    35|     manage_options= (
    36|         {'label': 'Settings',
    37|          'action': 'manage_main',
    38|          'help': ('PathIndex','PathIndex_Settings.stx')},
    39|     )
    40|     def __init__(self,id,caller=None):
    41|         self.id = id
    42|         self.operators = ('or','and')
    43|         self.useOperator = 'or'
    44|         self.clear()
    45|     def clear(self):
    46|         self._depth = 0
    47|         self._index = OOBTree()
    48|         self._unindex = IOBTree()
    49|         self._length = Length(0)
    50|     def insertEntry(self, comp, id, level):
    51|         """Insert an entry.
    52|            comp is a path component
    53|            id is the docid
    54|            level is the level of the component inside the path
    55|         """
    56|         if not self._index.has_key(comp):
    57|             self._index[comp] = IOBTree()
    58|         if not self._index[comp].has_key(level):
    59|             self._index[comp][level] = IITreeSet()
    60|         self._index[comp][level].insert(id)
    61|         if level > self._depth:
    62|             self._depth = level
    63|     def index_object(self, docid, obj ,threshold=100):
    64|         """ hook for (Z)Catalog """
    65|         f = getattr(obj, self.id, None)
    66|         if f is not None:
    67|             if safe_callable(f):
    68|                 try:
    69|                     path = f()
    70|                 except AttributeError:
    71|                     return 0
    72|             else:
    73|                 path = f
    74|             if not isinstance(path, (str, tuple)):
    75|                 raise TypeError('path value must be string or tuple of strings')
    76|         else:
    77|             try:
    78|                 path = obj.getPhysicalPath()
    79|             except AttributeError:
    80|                 return 0
    81|         if isinstance(path, (list, tuple)):
    82|             path = '/'+ '/'.join(path[1:])
    83|         comps = filter(None, path.split('/'))
    84|         if not self._unindex.has_key(docid):
    85|             self._length.change(1)
    86|         for i in range(len(comps)):
    87|             self.insertEntry(comps[i], docid, i)
    88|         self._unindex[docid] = path
    89|         return 1
    90|     def unindex_object(self, docid):
    91|         """ hook for (Z)Catalog """
    92|         if not self._unindex.has_key(docid):
    93|             LOG.debug('Attempt to unindex nonexistent document with id %s'
    94|                       % docid)
    95|             return
    96|         comps =  self._unindex[docid].split('/')
    97|         for level in range(len(comps[1:])):
    98|             comp = comps[level+1]
    99|             try:
   100|                 self._index[comp][level].remove(docid)
   101|                 if not self._index[comp][level]:
   102|                     del self._index[comp][level]
   103|                 if not self._index[comp]:
   104|                     del self._index[comp]
   105|             except KeyError:
   106|                 LOG.debug('Attempt to unindex document with id %s failed'
   107|                           % docid)
   108|         self._length.change(-1)
   109|         del self._unindex[docid]
   110|     def search(self, path, default_level=0):
   111|         """
   112|         path is either a string representing a
   113|         relative URL or a part of a relative URL or
   114|         a tuple (path,level).
   115|         level >= 0  starts searching at the given level
   116|         level <  0  match at *any* level
   117|         """
   118|         if isinstance(path, str):
   119|             level = default_level
   120|         else:
   121|             level = int(path[1])
   122|             path  = path[0]
   123|         if level < 0:
   124|             return multiunion(
   125|                 [self.search(path, level) 
   126|                  for level in xrange(self._depth + 1)])
   127|         comps = filter(None, path.split('/'))
   128|         if level + len(comps) - 1 > self._depth:
   129|             return IISet()
   130|         if len(comps) == 0:
   131|             return IISet(self._unindex.keys())
   132|         results = None
   133|         for i, comp in reversed(list(enumerate(comps))):
   134|             if not self._index.get(comp, {}).has_key(level+i): return IISet()
   135|             results = intersection(results, self._index[comp][level+i])
   136|         return results
   137|     def numObjects(self):
   138|         """Return the number of indexed objects."""
   139|         return len(self._unindex)
   140|     def indexSize(self):
   141|         """Return the size of the index in terms of distinct values."""
   142|         return len(self)
   143|     def __len__(self):
   144|         return self._length()
   145|     def _apply_index(self, request):
   146|         """ hook for (Z)Catalog
   147|             'request' --  mapping type (usually {"path": "..." }
   148|              additionaly a parameter "path_level" might be passed
   149|              to specify the level (see search())
   150|         """
   151|         record = parseIndexRequest(request, self.id, self.query_options)
   152|         if record.keys is None:
   153|             return None
   154|         level    = record.get("level",0)
   155|         operator = record.get('operator',self.useOperator).lower()
   156|         if operator == "or":  set_func = union
   157|         else: set_func = intersection
   158|         res = None
   159|         for k in record.keys:
   160|             rows = self.search(k,level)
   161|             res = set_func(res,rows)
   162|         if res:
   163|             return res, (self.id,)
   164|         else:
   165|             return IISet(), (self.id,)
   166|     def hasUniqueValuesFor(self, name):
   167|         """has unique values for column name"""
   168|         return name == self.id
   169|     def uniqueValues(self, name=None, withLength=0):
   170|         """ needed to be consistent with the interface """
   171|         return self._index.keys()
   172|     def getIndexSourceNames(self):
   173|         """ return names of indexed attributes """
   174|         return ('getPhysicalPath', )
   175|     def getEntryForObject(self, docid, default=_marker):
   176|         """ Takes a document ID and returns all the information
   177|             we have on that specific object.
   178|         """
   179|         try:
   180|             return self._unindex[docid]
   181|         except KeyError:
   182|             return None
   183|     manage = manage_main = DTMLFile('dtml/managePathIndex', globals())
   184|     manage_main._setName('manage_main')
   185| manage_addPathIndexForm = DTMLFile('dtml/addPathIndex', globals())
   186| def manage_addPathIndex(self, id, REQUEST=None, RESPONSE=None, URL3=None):
   187|     """Add a path index"""
   188|     return self.manage_addIndex(id, 'PathIndex', extra=None, \
   189|                 REQUEST=REQUEST, RESPONSE=RESPONSE, URL1=URL3)


# ====================================================================
# FILE: src/Products/PluginIndexes/__init__.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| import PathIndex.PathIndex
     2| import FieldIndex.FieldIndex
     3| import KeywordIndex.KeywordIndex
     4| import TopicIndex.TopicIndex
     5| import DateIndex.DateIndex
     6| import DateRangeIndex.DateRangeIndex
     7| from Products.PluginIndexes.common import ResultList
     8| from Products.PluginIndexes.common import UnIndex
     9| _indexes =  ('KeywordIndex',
    10|              'FieldIndex',
    11|              'PathIndex',
    12|              'TopicIndex',
    13|              'DateIndex',
    14|              'DateRangeIndex',
    15|             )
    16| def initialize(context):
    17|     for idx in _indexes:
    18|         s = "context.registerClass( \
    19|             %s.%s.%s,\
    20|             permission='Add Pluggable Index', \
    21|             constructors=(manage_add%sForm,\
    22|                           manage_add%s),\
    23|             icon='www/index.gif',\
    24|             visibility=None\
    25|          )" % (idx,idx,idx,idx,idx)
    26|         exec(s)
    27| for idx in _indexes:
    28|     exec("manage_add%sForm = %s.%s.manage_add%sForm" % (idx,idx,idx,idx))
    29|     exec("manage_add%s     = %s.%s.manage_add%s" % (idx,idx,idx,idx))


# ====================================================================
# FILE: src/Products/PluginIndexes/interfaces.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 76-115 ---
    76|       end date);
    77|     - Objects which match until a given time (i.e., they returned None for the
    78|       start date);
    79|     - Objects which match only during a specific interval.
    80|     """
    81|     def getSinceField():
    82|         """Get the name of the attribute indexed as start date.
    83|         """
    84|     def getUntilField():
    85|         """Get the name of the attribute indexed as end date.
    86|         """
    87| class IPathIndex(Interface):
    88|     """Index for paths returned by getPhysicalPath.
    89|     A path index stores all path components of the physical path of an object.
    90|     Internal datastructure:
    91|     - a physical path of an object is split into its components
    92|     - every component is kept as a  key of a OOBTree in self._indexes
    93|     - the value is a mapping 'level of the path component' to
    94|       'all docids with this path component on this level'
    95|     """
    96| class IFilteredSet(Interface):
    97|     """A pre-calculated result list based on an expression.
    98|     """
    99|     def getExpression():
   100|         """Get the expression.
   101|         """
   102|     def getIds():
   103|         """Get the IDs of all objects for which the expression is True.
   104|         """
   105|     def setExpression(expr):
   106|         """Set the expression.
   107|         """
   108| class ITopicIndex(Interface):
   109|     """A TopicIndex maintains a set of FilteredSet objects.
   110|     Every FilteredSet object consists of an expression and and IISet with all
   111|     Ids of indexed objects that eval with this expression to 1.
   112|     """
   113|     def addFilteredSet(filter_id, typeFilteredSet, expr):
   114|         """Add a FilteredSet object.
   115|         """


# ====================================================================
# FILE: src/Products/ZCTextIndex/ZCTextIndex.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 229-283 ---
   229|     meta_type = 'ZCTextIndex Lexicon'
   230|     manage_options = ({'label':'Overview', 'action':'manage_main'},
   231|                       {'label':'Query', 'action':'queryLexicon'},
   232|                      ) + SimpleItem.manage_options
   233|     security = ClassSecurityInfo()
   234|     security.declareObjectProtected(LexiconQueryPerm)
   235|     def __init__(self, id, title='', *pipeline):
   236|         self.id = str(id)
   237|         self.title = str(title)
   238|         PLexicon.inheritedAttribute('__init__')(self, *pipeline)
   239|     def getPipelineNames(self):
   240|         """Return list of names of pipeline element classes"""
   241|         return [element.__class__.__name__ for element in self._pipeline]
   242|     _queryLexicon = DTMLFile('dtml/queryLexicon', globals())
   243|     security.declareProtected(LexiconQueryPerm, 'queryLexicon')
   244|     def queryLexicon(self, REQUEST, words=None, page=0, rows=20, cols=4):
   245|         """Lexicon browser/query user interface
   246|         """
   247|         if words:
   248|             wids = []
   249|             for word in words:
   250|                 wids.extend(self.globToWordIds(word))
   251|             words = [self.get_word(wid) for wid in wids]
   252|         else:
   253|             words = self.words()
   254|         word_count = len(words)
   255|         rows = max(min(rows, 500), 1)
   256|         cols = max(min(cols, 12), 1)
   257|         page_count = word_count / (rows * cols) + \
   258|                      (word_count % (rows * cols) > 0)
   259|         page = max(min(page, page_count - 1), 0)
   260|         start = rows * cols * page
   261|         end = min(rows * cols * (page + 1), word_count)
   262|         if word_count:
   263|             words = list(words[start:end])
   264|         else:
   265|             words = []
   266|         columns = []
   267|         i = 0
   268|         while i < len(words):
   269|             columns.append(words[i:i + rows])
   270|             i += rows
   271|         return self._queryLexicon(self, REQUEST,
   272|                                   page=page,
   273|                                   rows=rows,
   274|                                   cols=cols,
   275|                                   start_word=start+1,
   276|                                   end_word=end,
   277|                                   word_count=word_count,
   278|                                   page_count=page_count,
   279|                                   page_range=xrange(page_count),
   280|                                   page_columns=columns)
   281|     security.declareProtected(LexiconMgmtPerm, 'manage_main')
   282|     manage_main = DTMLFile('dtml/manageLexicon', globals())
   283| InitializeClass(PLexicon)


# ====================================================================
# FILE: src/ZPublisher/HTTPRequest.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1192-1232 ---
  1192|         for m in methods:
  1193|             if hasattr(file,m):
  1194|                 d[m] = getattr(file,m)
  1195|         self.headers = aFieldStorage.headers
  1196|         self.filename = aFieldStorage.filename
  1197|         try:
  1198|             self.headers.__allow_access_to_unprotected_subobjects__ = 1
  1199|         except:
  1200|             pass
  1201|     def __nonzero__(self):
  1202|         """FileUpload objects are considered false if their
  1203|            filename is empty.
  1204|         """
  1205|         return not not self.filename
  1206|     def xreadlines(self):
  1207|         return self
  1208| parse_cookie_lock = allocate_lock()
  1209| QPARMRE= re.compile(
  1210|         '([\x00- ]*([^\x00- ;,="]+)="([^"]*)"([\x00- ]*[;,])?[\x00- ]*)')
  1211| PARMRE = re.compile(
  1212|         '([\x00- ]*([^\x00- ;,="]+)=([^;,"]*)([\x00- ]*[;,])?[\x00- ]*)')
  1213| PARAMLESSRE = re.compile(
  1214|         '([\x00- ]*([^\x00- ;,="]+)[\x00- ]*[;,][\x00- ]*)')
  1215| def parse_cookie(text,
  1216|                  result=None,
  1217|                  qparmre=QPARMRE,
  1218|                  parmre=PARMRE,
  1219|                  paramlessre=PARAMLESSRE,
  1220|                  acquire=parse_cookie_lock.acquire,
  1221|                  release=parse_cookie_lock.release,
  1222|                  ):
  1223|     if result is None:
  1224|         result = {}
  1225|     already_have = result.has_key
  1226|     acquire()
  1227|     try:
  1228|         mo_q = qparmre.match(text)
  1229|         if mo_q:
  1230|             l = len(mo_q.group(1))
  1231|             name = mo_q.group(2)
  1232|             value = mo_q.group(3)


# ====================================================================
# FILE: src/ZPublisher/HTTPResponse.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 594-634 ---
   594|                 self.setHeader('location', v.args[0])
   595|                 self.setBody('')
   596|                 tb = None
   597|                 return self
   598|             else:
   599|                 try:
   600|                     l, b = v
   601|                     if (isinstance(l, str)
   602|                         and absuri_match(l) is not None):
   603|                         if self.status == 300:
   604|                             self.setStatus(302)
   605|                         self.setHeader('location', l)
   606|                         self.setBody(b)
   607|                         tb = None # one more patch covered
   608|                         return self
   609|                 except:
   610|                     pass # tb is not cleared in this case
   611|         b = v
   612|         if isinstance(b, Exception):
   613|             try:
   614|                 b = str(b)
   615|             except:
   616|                 b = '<unprintable %s object>' % type(b).__name__
   617|         if fatal and t is SystemExit and v.code == 0:
   618|             body = self.setBody(
   619|                 (str(t),
   620|                  'Zope has exited normally.<p>' + self._traceback(t, v, tb) + '</p>'),
   621|                 is_error=1)
   622|         else:
   623|             try:
   624|                 match = tag_search(b)
   625|             except TypeError:
   626|                 match = None
   627|             if match is None:
   628|                 body = self.setBody(
   629|                     (str(t),
   630|                      'Sorry, a site error occurred.<p>'
   631|                      + self._traceback(t, v, tb)
   632|                      + '</p>'),
   633|                     is_error=1)
   634|             elif self.isHTML(b):


# ====================================================================
# FILE: src/ZPublisher/Publish.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 82-122 ---
    82|                       request, bind=1)
    83|         if result is not response:
    84|             response.setBody(result)
    85|         notify(PubBeforeCommit(request))
    86|         if transactions_manager:
    87|             transactions_manager.commit()
    88|         endInteraction()
    89|         notify(PubSuccess(request))
    90|         return response
    91|     except:
    92|         exc_info = sys.exc_info()
    93|         sm = None
    94|         if response is not None:
    95|             sm = getattr(response, "setMessage", None)
    96|         if sm is not None:
    97|             from asyncore import compact_traceback
    98|             cl,val= sys.exc_info()[:2]
    99|             sm('%s: %s %s' % (
   100|                 getattr(cl,'__name__',cl), val,
   101|                 debug_mode and compact_traceback()[-1] or ''))
   102|         if err_hook is not None:
   103|             retry = False
   104|             if parents:
   105|                 parents=parents[0]
   106|             try:
   107|                 try:
   108|                     return err_hook(parents, request,
   109|                                     sys.exc_info()[0],
   110|                                     sys.exc_info()[1],
   111|                                     sys.exc_info()[2],
   112|                                     )
   113|                 except Retry:
   114|                     if not request.supports_retry():
   115|                         return err_hook(parents, request,
   116|                                         sys.exc_info()[0],
   117|                                         sys.exc_info()[1],
   118|                                         sys.exc_info()[2],
   119|                                         )
   120|                     retry = True
   121|             finally:
   122|                 try:                     

# --- HUNK 2: Lines 128-168 ---
   128|                 finally:
   129|                     endInteraction()
   130|                     notify(PubFailure(request, exc_info, retry))
   131|             newrequest=request.retry()
   132|             request.close()  # Free resources held by the request.
   133|             if ISkinnable.providedBy(newrequest):
   134|                 setDefaultSkin(newrequest)
   135|             try:
   136|                 return publish(newrequest, module_name, after_list, debug)
   137|             finally:
   138|                 newrequest.close()
   139|         else:
   140|             try:                     
   141|                 try:
   142|                     notify(PubBeforeAbort(request, exc_info, False))
   143|                 finally:
   144|                     if transactions_manager:
   145|                         transactions_manager.abort()
   146|             finally:
   147|                 endInteraction()
   148|                 notify(PubFailure(request, exc_info, retry))
   149|             raise
   150| def publish_module_standard(module_name,
   151|                    stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
   152|                    environ=os.environ, debug=0, request=None, response=None):
   153|     must_die=0
   154|     status=200
   155|     after_list=[None]
   156|     try:
   157|         try:
   158|             if response is None:
   159|                 response=Response(stdout=stdout, stderr=stderr)
   160|             else:
   161|                 stdout=response.stdout
   162|             response.handle_errors = not debug
   163|             if request is None:
   164|                 request=Request(stdin, environ, response)
   165|             if ISkinnable.providedBy(request):
   166|                 setDefaultSkin(request)
   167|             response = publish(request, module_name, after_list, debug=debug)
   168|         except SystemExit, v:


# ====================================================================
# FILE: src/Zope2/App/startup.py
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| """Initialize the Zope2 Package and provide a published module
     2| """
     3| from zope.component import queryMultiAdapter
     4| from AccessControl.SecurityManagement import newSecurityManager
     5| from AccessControl.SecurityManagement import noSecurityManager
     6| from Acquisition import aq_acquire
     7| from Acquisition import aq_base
     8| from Acquisition import aq_inner
     9| from Acquisition import aq_parent
    10| from App.config import getConfiguration
    11| from time import asctime
    12| from types import StringType, ListType
    13| from zExceptions import upgradeException
    14| from zExceptions import Redirect
    15| from zExceptions import Unauthorized
    16| from ZODB.POSException import ConflictError
    17| import transaction
    18| import AccessControl.User
    19| import App.FindHomes
    20| import ExtensionClass
    21| import imp
    22| import logging
    23| import OFS.Application
    24| import sys
    25| import ZODB
    26| import App.ZApplication
    27| import Zope2
    28| import ZPublisher
    29| from zope.event import notify
    30| from zope.processlifetime import DatabaseOpened
    31| app = None
    32| startup_time = asctime()
    33| def startup():
    34|     from App.PersistentExtra import patchPersistent
    35|     import Globals  # to set / fetch data
    36|     patchPersistent()
    37|     global app
    38|     OFS.Application.import_products()
    39|     configuration = getConfiguration()

# --- HUNK 2: Lines 121-193 ---
   121|                 raise ZPublisher.Retry(t, v, traceback)
   122|             if t is ZPublisher.Retry:
   123|                 try:
   124|                     v.reraise()
   125|                 except:
   126|                     t, v, traceback = sys.exc_info()
   127|                 if issubclass(t, ConflictError):
   128|                     self.unresolved_conflict_errors += 1
   129|             try:
   130|                 log = aq_acquire(published, '__error_log__', containment=1)
   131|             except AttributeError:
   132|                 error_log_url = ''
   133|             else:
   134|                 error_log_url = log.raising((t, v, traceback))
   135|             if (REQUEST is None or 
   136|                 (getattr(REQUEST.get('RESPONSE', None), '_error_format', '')
   137|                  != 'text/html')):
   138|                 raise t, v, traceback
   139|             view = queryMultiAdapter((v, REQUEST), name=u'index.html')
   140|             if view is not None:
   141|                 v = view()
   142|                 response = REQUEST.RESPONSE
   143|                 response.setStatus(t)
   144|                 response.setBody(v)
   145|                 return response
   146|             if (published is None or published is app or
   147|                 type(published) is ListType):
   148|                 published=app.__bobo_traverse__(REQUEST).__of__(
   149|                     RequestContainer(REQUEST))
   150|             published = getattr(published, 'im_self', published)
   151|             while 1:
   152|                 f = getattr(published, self.raise_error_message, None)
   153|                 if f is None:
   154|                     published = aq_parent(published)
   155|                     if published is None:
   156|                         raise t, v, traceback
   157|                 else:
   158|                     break
   159|             client = published
   160|             while 1:
   161|                 if getattr(client, self.error_message, None) is not None:
   162|                     break
   163|                 client = aq_parent(client)
   164|                 if client is None or aq_base(client) is aq_base(published):
   165|                     raise t, v, traceback
   166|             if REQUEST.get('AUTHENTICATED_USER', None) is None:
   167|                 REQUEST['AUTHENTICATED_USER'] = AccessControl.User.nobody
   168|             try:
   169|                 result = f(client, REQUEST, t, v, 
   170|                            traceback, 
   171|                            error_log_url=error_log_url)
   172|                 if result is not None:
   173|                     t, v, traceback = result
   174|                     response = REQUEST.RESPONSE
   175|                     response.setStatus(t)
   176|                     response.setBody(v)
   177|                     return response
   178|             except TypeError:
   179|                 f(client, REQUEST, t, v, traceback)
   180|         finally:
   181|             traceback = None
   182| zpublisher_exception_hook = ZPublisherExceptionHook()
   183| ac_logger = logging.getLogger('event.AccessControl')
   184| class TransactionsManager:
   185|     def begin(self,
   186|               transaction=transaction):
   187|         transaction.begin()
   188|     def commit(self):
   189|         if hasattr(transaction, 'isDoomed') and transaction.isDoomed():
   190|             transaction.abort()
   191|         else:
   192|             transaction.commit()
   193|     def abort(self):


# ====================================================================
# FILE: src/Zope2/Startup/handlers.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 127-165 ---
   127|         if os.path.isdir(instanceprod):
   128|             config.products.append(instanceprod)
   129|     import Products
   130|     L = []
   131|     for d in config.products + Products.__path__:
   132|         if d not in L:
   133|             L.append(d)
   134|     Products.__path__[:] = L
   135|     if config.mime_types:
   136|         from zope.contenttype import add_files
   137|         add_files(config.mime_types)
   138|     if not config.servers:
   139|         config.servers = []
   140|     for factory in config.servers:
   141|         factory.prepare(config.ip_address or '',
   142|                         config.dns_resolver,
   143|                         "Zope2",
   144|                         config.cgi_environment,
   145|                         config.port_base)
   146|     if config.trusted_proxies:
   147|         import ZPublisher.HTTPRequest
   148|         mapped = []
   149|         for name in config.trusted_proxies: mapped.extend(_name2Ips(name))
   150|         ZPublisher.HTTPRequest.trusted_proxies = tuple(mapped)
   151| def handleConfig(config, multihandler):
   152|     handlers = {}
   153|     for name, value in globals().items():
   154|         if not name.startswith('_'):
   155|             handlers[name] = value
   156|     return multihandler(handlers)
   157| def _name2Ips(host, isIp_=compile(r'(\d+\.){3}').match):
   158|     """Map a name *host* to the sequence of its ip addresses.
   159|     use *host* itself (as sequence) if it already is an ip address.
   160|     Thus, if only a specific interface on a host is trusted,
   161|     identify it by its ip (and not the host name).
   162|     """
   163|     if isIp_(host):
   164|         return [host]
   165|     return gethostbyaddr(host)[2]


# ====================================================================
# FILE: src/zExceptions/unauthorized.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-52 ---
     1| """
     2| $Id$
     3| """
     4| from types import StringType
     5| from zope.interface import implements
     6| from zope.security.interfaces import IUnauthorized
     7| class Unauthorized(Exception):
     8|     """Some user wasn't allowed to access a resource
     9|     """
    10|     implements(IUnauthorized)
    11|     def _get_message(self):
    12|         return self._message
    13|     message = property(_get_message,)
    14|     def __init__(self, message=None, value=None, needed=None, name=None, **kw):
    15|         """Possible signatures:
    16|         Unauthorized()
    17|         Unauthorized(message) # Note that message includes a space
    18|         Unauthorized(name)
    19|         Unauthorized(name, value)
    20|         Unauthorized(name, value, needed)
    21|         Unauthorized(message, value, needed, name)
    22|         Where needed is a mapping objects with items represnting requirements
    23|         (e.g. {'permission': 'add spam'}). Any extra keyword arguments
    24|         provides are added to needed.
    25|         """
    26|         if name is None and (
    27|             not isinstance(message, StringType) or len(message.split()) <= 1):
    28|             name=message
    29|             message=None
    30|         self.name=name
    31|         self._message=message
    32|         self.value=value
    33|         if kw:
    34|             if needed: needed.update(kw)
    35|             else: needed=kw
    36|         self.needed=needed
    37|     def __str__(self):
    38|         if self.message is not None: return self.message
    39|         if self.name is not None:
    40|             return ("You are not allowed to access '%s' in this context"
    41|                     % self.name)
    42|         elif self.value is not None:
    43|             return ("You are not allowed to access '%s' in this context"
    44|                     % self.getValueName())
    45|         return repr(self)
    46|     def getValueName(self):
    47|         v=self.value
    48|         vname=getattr(v, '__name__', None)
    49|         if vname: return vname
    50|         c = getattr(v, '__class__', type(v))
    51|         c = getattr(c, '__name__', 'object')
    52|         return "a particular %s" % c

