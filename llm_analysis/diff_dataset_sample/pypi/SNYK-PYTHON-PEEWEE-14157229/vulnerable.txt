# ====================================================================
# FILE: peewee.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 53-93 ---
    53| except ImportError:
    54|     psycopg2 = pg_errors = None
    55| try:
    56|     from psycopg2.extras import register_uuid as pg_register_uuid
    57|     pg_register_uuid()
    58| except Exception:
    59|     pass
    60| try:
    61|     from psycopg import errors as pg3_errors
    62| except ImportError:
    63|     pg3_errors = None
    64| mysql_passwd = False
    65| try:
    66|     import pymysql as mysql
    67| except ImportError:
    68|     try:
    69|         import MySQLdb as mysql
    70|         mysql_passwd = True
    71|     except ImportError:
    72|         mysql = None
    73| __version__ = '3.18.2'
    74| __all__ = [
    75|     'AnyField',
    76|     'AsIs',
    77|     'AutoField',
    78|     'BareField',
    79|     'BigAutoField',
    80|     'BigBitField',
    81|     'BigIntegerField',
    82|     'BinaryUUIDField',
    83|     'BitField',
    84|     'BlobField',
    85|     'BooleanField',
    86|     'Case',
    87|     'Cast',
    88|     'CharField',
    89|     'Check',
    90|     'chunked',
    91|     'Column',
    92|     'CompositeKey',
    93|     'Context',


# ====================================================================
# FILE: playhouse/postgres_ext.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 27-104 ---
    27| except:
    28|     Json = None
    29| logger = logging.getLogger('peewee')
    30| HCONTAINS_DICT = '@>'
    31| HCONTAINS_KEYS = '?&'
    32| HCONTAINS_KEY = '?'
    33| HCONTAINS_ANY_KEY = '?|'
    34| HKEY = '->'
    35| HUPDATE = '||'
    36| ACONTAINS = '@>'
    37| ACONTAINED_BY = '<@'
    38| ACONTAINS_ANY = '&&'
    39| TS_MATCH = '@@'
    40| JSONB_CONTAINS = '@>'
    41| JSONB_CONTAINED_BY = '<@'
    42| JSONB_CONTAINS_KEY = '?'
    43| JSONB_CONTAINS_ANY_KEY = '?|'
    44| JSONB_CONTAINS_ALL_KEYS = '?&'
    45| JSONB_EXISTS = '?'
    46| JSONB_REMOVE = '-'
    47| class _LookupNode(ColumnBase):
    48|     def __init__(self, node, parts):
    49|         self.node = node
    50|         self.parts = parts
    51|         super(_LookupNode, self).__init__()
    52|     def clone(self):
    53|         return type(self)(self.node, list(self.parts))
    54|     def __hash__(self):
    55|         return hash((self.__class__.__name__, id(self)))
    56| class _JsonLookupBase(_LookupNode):
    57|     def __init__(self, node, parts, as_json=False):
    58|         super(_JsonLookupBase, self).__init__(node, parts)
    59|         self._as_json = as_json
    60|     def clone(self):
    61|         return type(self)(self.node, list(self.parts), self._as_json)
    62|     @Node.copy
    63|     def as_json(self, as_json=True):
    64|         self._as_json = as_json
    65|     def concat(self, rhs):
    66|         if not isinstance(rhs, Node):
    67|             rhs = Json(rhs)
    68|         return Expression(self.as_json(True), OP.CONCAT, rhs)
    69|     def contains(self, other):
    70|         return Expression(self.as_json(True), JSONB_CONTAINS, Json(other))
    71|     def contained_by(self, other):
    72|         return Expression(self.as_json(True), JSONB_CONTAINED_BY, Json(other))
    73|     def contains_any(self, *keys):
    74|         return Expression(
    75|             self.as_json(True),
    76|             JSONB_CONTAINS_ANY_KEY,
    77|             Value(list(keys), unpack=False))
    78|     def contains_all(self, *keys):
    79|         return Expression(
    80|             self.as_json(True),
    81|             JSONB_CONTAINS_ALL_KEYS,
    82|             Value(list(keys), unpack=False))
    83|     def has_key(self, key):
    84|         return Expression(self.as_json(True), JSONB_CONTAINS_KEY, key)
    85| class JsonLookup(_JsonLookupBase):
    86|     def __getitem__(self, value):
    87|         return JsonLookup(self.node, self.parts + [value], self._as_json)
    88|     def __sql__(self, ctx):
    89|         ctx.sql(self.node)
    90|         for part in self.parts[:-1]:
    91|             ctx.literal('->').sql(part)
    92|         if self.parts:
    93|             (ctx
    94|              .literal('->' if self._as_json else '->>')
    95|              .sql(self.parts[-1]))
    96|         return ctx
    97| class JsonPath(_JsonLookupBase):
    98|     def __sql__(self, ctx):
    99|         return (ctx
   100|                 .sql(self.node)
   101|                 .literal('#>' if self._as_json else '#>>')
   102|                 .sql(Value('{%s}' % ','.join(map(str, self.parts)))))
   103| class ObjectSlice(_LookupNode):
   104|     @classmethod


# ====================================================================
# FILE: playhouse/shortcuts.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 48-96 ---
    48|                 continue
    49|             exclude.update((m2m, m2m.rel_model._meta.manytomany[m2m.backref]))
    50|             for fkf in m2m.through_model._meta.refs:
    51|                 exclude.add(fkf)
    52|             accum = []
    53|             for rel_obj in getattr(model, name):
    54|                 accum.append(model_to_dict(
    55|                     rel_obj,
    56|                     recurse=recurse,
    57|                     backrefs=backrefs,
    58|                     only=only,
    59|                     exclude=exclude,
    60|                     max_depth=max_depth - 1))
    61|             data[name] = accum
    62|     for field in model._meta.sorted_fields:
    63|         if should_skip(field):
    64|             continue
    65|         field_data = model.__data__.get(field.name)
    66|         if isinstance(field, ForeignKeyField) and recurse:
    67|             if field_data is not None:
    68|                 seen.add(field)
    69|                 rel_obj = getattr(model, field.name)
    70|                 field_data = model_to_dict(
    71|                     rel_obj,
    72|                     recurse=recurse,
    73|                     backrefs=backrefs,
    74|                     only=only,
    75|                     exclude=exclude,
    76|                     seen=seen,
    77|                     max_depth=max_depth - 1)
    78|             else:
    79|                 field_data = None
    80|         data[field.name] = field_data
    81|     if extra_attrs:
    82|         for attr_name in extra_attrs:
    83|             attr = getattr(model, attr_name)
    84|             if callable_(attr):
    85|                 data[attr_name] = attr()
    86|             else:
    87|                 data[attr_name] = attr
    88|     if backrefs and recurse:
    89|         for foreign_key, rel_model in model._meta.backrefs.items():
    90|             if foreign_key.backref == '+': continue
    91|             descriptor = getattr(model_class, foreign_key.backref)
    92|             if descriptor in exclude or foreign_key in exclude:
    93|                 continue
    94|             if only and (descriptor not in only) and (foreign_key not in only):
    95|                 continue
    96|             accum = []

# --- HUNK 2: Lines 183-225 ---
   183|     REALLY know what you are doing) and definitely has no business being used
   184|     with Sqlite. If you wish to use with Postgres, you will need to adapt the
   185|     `reconnect_errors` attribute to something appropriate for Postgres.
   186|     """
   187|     reconnect_errors = (
   188|         (OperationalError, '2006'),  # MySQL server has gone away.
   189|         (OperationalError, '2013'),  # Lost connection to MySQL server.
   190|         (OperationalError, '2014'),  # Commands out of sync.
   191|         (OperationalError, '4031'),  # Client interaction timeout.
   192|         (OperationalError, 'MySQL Connection not available.'),
   193|     )
   194|     def __init__(self, *args, **kwargs):
   195|         super(ReconnectMixin, self).__init__(*args, **kwargs)
   196|         self._reconnect_errors = {}
   197|         for exc_class, err_fragment in self.reconnect_errors:
   198|             self._reconnect_errors.setdefault(exc_class, [])
   199|             self._reconnect_errors[exc_class].append(err_fragment.lower())
   200|     def execute_sql(self, sql, params=None, commit=None):
   201|         if commit is not None:
   202|             __deprecated__('"commit" has been deprecated and is a no-op.')
   203|         return self._reconnect(super(ReconnectMixin, self).execute_sql, sql, params)
   204|     def begin(self):
   205|         return self._reconnect(super(ReconnectMixin, self).begin)
   206|     def _reconnect(self, func, *args, **kwargs):
   207|         try:
   208|             return func(*args, **kwargs)
   209|         except Exception as exc:
   210|             if self.in_transaction():
   211|                 raise exc
   212|             exc_class = type(exc)
   213|             if exc_class not in self._reconnect_errors:
   214|                 raise exc
   215|             exc_repr = str(exc).lower()
   216|             for err_fragment in self._reconnect_errors[exc_class]:
   217|                 if err_fragment in exc_repr:
   218|                     break
   219|             else:
   220|                 raise exc
   221|             if not self.is_closed():
   222|                 self.close()
   223|                 self.connect()
   224|             return func(*args, **kwargs)
   225| def resolve_multimodel_query(query, key='_model_identifier'):


# ====================================================================
# FILE: playhouse/sqlite_ext.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 416-456 ---
   416|             explicit_ordering)
   417|     @classmethod
   418|     def search_lucene(cls, term, weights=None, with_score=False,
   419|                       score_alias='score', explicit_ordering=False):
   420|         """Full-text search for selected `term` using BM25 algorithm."""
   421|         return cls._search(
   422|             term,
   423|             weights,
   424|             with_score,
   425|             score_alias,
   426|             cls.lucene,
   427|             explicit_ordering)
   428| _alphabet = 'abcdefghijklmnopqrstuvwxyz'
   429| _alphanum = (set('\t ,"(){}*:_+0123456789') |
   430|              set(_alphabet) |
   431|              set(_alphabet.upper()) |
   432|              set((chr(26),)))
   433| _invalid_ascii = set(chr(p) for p in range(128) if chr(p) not in _alphanum)
   434| del _alphabet
   435| del _alphanum
   436| _quote_re = re.compile(r'(?:[^\s"]|"(?:\\.|[^"])*")+')
   437| class FTS5Model(BaseFTSModel):
   438|     """
   439|     Requires SQLite >= 3.9.0.
   440|     Table options:
   441|     content: table name of external content, or empty string for "contentless"
   442|     content_rowid: column name of external content primary key
   443|     prefix: integer(s). Ex: '2' or '2 3 4'
   444|     tokenize: porter, unicode61, ascii. Ex: 'porter unicode61'
   445|     The unicode tokenizer supports the following parameters:
   446|     * remove_diacritics (1 or 0, default is 1)
   447|     * tokenchars (string of characters, e.g. '-_'
   448|     * separators (string of characters)
   449|     Parameters are passed as alternating parameter name and value, so:
   450|     {'tokenize': "unicode61 remove_diacritics 0 tokenchars '-_'"}
   451|     Content-less tables:
   452|     If you don't need the full-text content in it's original form, you can
   453|     specify a content-less table. Searches and auxiliary functions will work
   454|     as usual, but the only values returned when SELECT-ing can be rowid. Also
   455|     content-less tables do not support UPDATE or DELETE.
   456|     External content tables:

