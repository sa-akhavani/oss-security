# ====================================================================
# FILE: src/werkzeug/formparser.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 268-336 ---
   268|         return "utf-8"
   269|     def start_file_streaming(
   270|         self, event: File, total_content_length: int | None
   271|     ) -> t.IO[bytes]:
   272|         content_type = event.headers.get("content-type")
   273|         try:
   274|             content_length = _plain_int(event.headers["content-length"])
   275|         except (KeyError, ValueError):
   276|             content_length = 0
   277|         container = self.stream_factory(
   278|             total_content_length=total_content_length,
   279|             filename=event.filename,
   280|             content_type=content_type,
   281|             content_length=content_length,
   282|         )
   283|         return container
   284|     def parse(
   285|         self, stream: t.IO[bytes], boundary: bytes, content_length: int | None
   286|     ) -> tuple[MultiDict[str, str], MultiDict[str, FileStorage]]:
   287|         current_part: Field | File
   288|         field_size: int | None = None
   289|         container: t.IO[bytes] | list[bytes]
   290|         _write: t.Callable[[bytes], t.Any]
   291|         parser = MultipartDecoder(
   292|             boundary,
   293|             max_form_memory_size=self.max_form_memory_size,
   294|             max_parts=self.max_form_parts,
   295|         )
   296|         fields = []
   297|         files = []
   298|         for data in _chunk_iter(stream.read, self.buffer_size):
   299|             parser.receive_data(data)
   300|             event = parser.next_event()
   301|             while not isinstance(event, (Epilogue, NeedData)):
   302|                 if isinstance(event, Field):
   303|                     current_part = event
   304|                     field_size = 0
   305|                     container = []
   306|                     _write = container.append
   307|                 elif isinstance(event, File):
   308|                     current_part = event
   309|                     field_size = None
   310|                     container = self.start_file_streaming(event, content_length)
   311|                     _write = container.write
   312|                 elif isinstance(event, Data):
   313|                     if self.max_form_memory_size is not None and field_size is not None:
   314|                         field_size += len(event.data)
   315|                         if field_size > self.max_form_memory_size:
   316|                             raise RequestEntityTooLarge()
   317|                     _write(event.data)
   318|                     if not event.more_data:
   319|                         if isinstance(current_part, Field):
   320|                             value = b"".join(container).decode(
   321|                                 self.get_part_charset(current_part.headers), "replace"
   322|                             )
   323|                             fields.append((current_part.name, value))
   324|                         else:
   325|                             container = t.cast(t.IO[bytes], container)
   326|                             container.seek(0)
   327|                             files.append(
   328|                                 (
   329|                                     current_part.name,
   330|                                     FileStorage(
   331|                                         container,
   332|                                         current_part.filename,
   333|                                         current_part.name,
   334|                                         headers=current_part.headers,
   335|                                     ),
   336|                                 )


# ====================================================================
# FILE: src/werkzeug/security.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 99-125 ---
    99|     except ValueError:
   100|         return False
   101|     return hmac.compare_digest(_hash_internal(method, salt, password)[0], hashval)
   102| def safe_join(directory: str, *pathnames: str) -> str | None:
   103|     """Safely join zero or more untrusted path components to a base
   104|     directory to avoid escaping the base directory.
   105|     :param directory: The trusted base directory.
   106|     :param pathnames: The untrusted path components relative to the
   107|         base directory.
   108|     :return: A safe path, otherwise ``None``.
   109|     """
   110|     if not directory:
   111|         directory = "."
   112|     parts = [directory]
   113|     for filename in pathnames:
   114|         if filename != "":
   115|             filename = posixpath.normpath(filename)
   116|         if (
   117|             any(sep in filename for sep in _os_alt_seps)
   118|             or os.path.isabs(filename)
   119|             or filename.startswith("/")
   120|             or filename == ".."
   121|             or filename.startswith("../")
   122|         ):
   123|             return None
   124|         parts.append(filename)
   125|     return posixpath.join(*parts)

