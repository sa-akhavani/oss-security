# ====================================================================
# FILE: src/werkzeug/formparser.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 268-329 ---
   268|         return "utf-8"
   269|     def start_file_streaming(
   270|         self, event: File, total_content_length: int | None
   271|     ) -> t.IO[bytes]:
   272|         content_type = event.headers.get("content-type")
   273|         try:
   274|             content_length = _plain_int(event.headers["content-length"])
   275|         except (KeyError, ValueError):
   276|             content_length = 0
   277|         container = self.stream_factory(
   278|             total_content_length=total_content_length,
   279|             filename=event.filename,
   280|             content_type=content_type,
   281|             content_length=content_length,
   282|         )
   283|         return container
   284|     def parse(
   285|         self, stream: t.IO[bytes], boundary: bytes, content_length: int | None
   286|     ) -> tuple[MultiDict[str, str], MultiDict[str, FileStorage]]:
   287|         current_part: Field | File
   288|         container: t.IO[bytes] | list[bytes]
   289|         _write: t.Callable[[bytes], t.Any]
   290|         parser = MultipartDecoder(
   291|             boundary,
   292|             max_form_memory_size=self.max_form_memory_size,
   293|             max_parts=self.max_form_parts,
   294|         )
   295|         fields = []
   296|         files = []
   297|         for data in _chunk_iter(stream.read, self.buffer_size):
   298|             parser.receive_data(data)
   299|             event = parser.next_event()
   300|             while not isinstance(event, (Epilogue, NeedData)):
   301|                 if isinstance(event, Field):
   302|                     current_part = event
   303|                     container = []
   304|                     _write = container.append
   305|                 elif isinstance(event, File):
   306|                     current_part = event
   307|                     container = self.start_file_streaming(event, content_length)
   308|                     _write = container.write
   309|                 elif isinstance(event, Data):
   310|                     _write(event.data)
   311|                     if not event.more_data:
   312|                         if isinstance(current_part, Field):
   313|                             value = b"".join(container).decode(
   314|                                 self.get_part_charset(current_part.headers), "replace"
   315|                             )
   316|                             fields.append((current_part.name, value))
   317|                         else:
   318|                             container = t.cast(t.IO[bytes], container)
   319|                             container.seek(0)
   320|                             files.append(
   321|                                 (
   322|                                     current_part.name,
   323|                                     FileStorage(
   324|                                         container,
   325|                                         current_part.filename,
   326|                                         current_part.name,
   327|                                         headers=current_part.headers,
   328|                                     ),
   329|                                 )


# ====================================================================
# FILE: src/werkzeug/security.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 99-124 ---
    99|     except ValueError:
   100|         return False
   101|     return hmac.compare_digest(_hash_internal(method, salt, password)[0], hashval)
   102| def safe_join(directory: str, *pathnames: str) -> str | None:
   103|     """Safely join zero or more untrusted path components to a base
   104|     directory to avoid escaping the base directory.
   105|     :param directory: The trusted base directory.
   106|     :param pathnames: The untrusted path components relative to the
   107|         base directory.
   108|     :return: A safe path, otherwise ``None``.
   109|     """
   110|     if not directory:
   111|         directory = "."
   112|     parts = [directory]
   113|     for filename in pathnames:
   114|         if filename != "":
   115|             filename = posixpath.normpath(filename)
   116|         if (
   117|             any(sep in filename for sep in _os_alt_seps)
   118|             or os.path.isabs(filename)
   119|             or filename == ".."
   120|             or filename.startswith("../")
   121|         ):
   122|             return None
   123|         parts.append(filename)
   124|     return posixpath.join(*parts)

