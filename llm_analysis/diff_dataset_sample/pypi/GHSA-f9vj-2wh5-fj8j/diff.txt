--- a/src/werkzeug/formparser.py
+++ b/src/werkzeug/formparser.py
@@ -278,49 +278,42 @@
             total_content_length=total_content_length,
             filename=event.filename,
             content_type=content_type,
             content_length=content_length,
         )
         return container
     def parse(
         self, stream: t.IO[bytes], boundary: bytes, content_length: int | None
     ) -> tuple[MultiDict[str, str], MultiDict[str, FileStorage]]:
         current_part: Field | File
-        field_size: int | None = None
         container: t.IO[bytes] | list[bytes]
         _write: t.Callable[[bytes], t.Any]
         parser = MultipartDecoder(
             boundary,
             max_form_memory_size=self.max_form_memory_size,
             max_parts=self.max_form_parts,
         )
         fields = []
         files = []
         for data in _chunk_iter(stream.read, self.buffer_size):
             parser.receive_data(data)
             event = parser.next_event()
             while not isinstance(event, (Epilogue, NeedData)):
                 if isinstance(event, Field):
                     current_part = event
-                    field_size = 0
                     container = []
                     _write = container.append
                 elif isinstance(event, File):
                     current_part = event
-                    field_size = None
                     container = self.start_file_streaming(event, content_length)
                     _write = container.write
                 elif isinstance(event, Data):
-                    if self.max_form_memory_size is not None and field_size is not None:
-                        field_size += len(event.data)
-                        if field_size > self.max_form_memory_size:
-                            raise RequestEntityTooLarge()
                     _write(event.data)
                     if not event.more_data:
                         if isinstance(current_part, Field):
                             value = b"".join(container).decode(
                                 self.get_part_charset(current_part.headers), "replace"
                             )
                             fields.append((current_part.name, value))
                         else:
                             container = t.cast(t.IO[bytes], container)
                             container.seek(0)

--- a/src/werkzeug/security.py
+++ b/src/werkzeug/security.py
@@ -109,17 +109,16 @@
     """
     if not directory:
         directory = "."
     parts = [directory]
     for filename in pathnames:
         if filename != "":
             filename = posixpath.normpath(filename)
         if (
             any(sep in filename for sep in _os_alt_seps)
             or os.path.isabs(filename)
-            or filename.startswith("/")
             or filename == ".."
             or filename.startswith("../")
         ):
             return None
         parts.append(filename)
     return posixpath.join(*parts)
