# ====================================================================
# FILE: clients/admin-ui/src/features/datastore-connections/system_portal_config/forms/ConnectorParametersForm.tsx
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 1-163 ---
     1| import {
     2|   Button,
     3|   ButtonGroup,
     4|   CircleHelpIcon,
     5|   Flex,
     6|   FormControl,
     7|   FormErrorMessage,
     8|   FormLabel,
     9|   Input,
    10|   isNumeric,
    11|   NumberDecrementStepper,
    12|   NumberIncrementStepper,
    13|   NumberInput,
    14|   NumberInputField,
    15|   NumberInputStepper,
    16|   Textarea,
    17|   Tooltip,
    18|   VStack,
    19| } from "@fidesui/react";
    20| import { Option } from "common/form/inputs";
    21| import { useAPIHelper } from "common/hooks";
    22| import {
    23|   ConnectionTypeSecretSchemaProperty,
    24|   ConnectionTypeSecretSchemaReponse,
    25| } from "connection-type/types";
    26| import { useLazyGetDatastoreConnectionStatusQuery } from "datastore-connections/datastore-connection.slice";
    27| import DSRCustomizationModal from "datastore-connections/system_portal_config/forms/DSRCustomizationForm/DSRCustomizationModal";
    28| import { Field, FieldInputProps, Form, Formik, FormikProps } from "formik";
    29| import React, { useEffect, useRef } from "react";
    30| import DatasetConfigField from "~/features/datastore-connections/system_portal_config/forms/fields/DatasetConfigField/DatasetConfigField";
    31| import {
    32|   ConnectionConfigurationResponse,
    33|   ConnectionSystemTypeMap,
    34|   ConnectionType,
    35|   SystemType,
    36| } from "~/types/api";
    37| import DeleteConnectionModal from "../DeleteConnectionModal";
    38| import { ConnectionConfigFormValues } from "../types";
    39| import { fillInDefaults } from "./helpers";
    40| const FIDES_DATASET_REFERENCE = "#/definitions/FidesDatasetReference";
    41| type ConnectorParametersFormProps = {
    42|   secretsSchema?: ConnectionTypeSecretSchemaReponse;
    43|   defaultValues: ConnectionConfigFormValues;
    44|   isSubmitting: boolean;
    45|   /**
    46|    * Parent callback when Save is clicked
    47|    */
    48|   onSaveClick: (values: any, actions: any) => void;
    49|   /**
    50|    * Parent callback when Test Connection is clicked
    51|    */
    52|   onTestConnectionClick: (value: any) => void;
    53|   /**
    54|    * Text for the test button. Defaults to "Test connection"
    55|    */
    56|   testButtonLabel?: string;
    57|   connectionConfig?: ConnectionConfigurationResponse;
    58|   connectionOption: ConnectionSystemTypeMap;
    59|   isCreatingConnectionConfig: boolean;
    60|   datasetDropdownOptions: Option[];
    61|   onDelete: (id: string) => void;
    62|   deleteResult: any;
    63| };
    64| const ConnectorParametersForm: React.FC<ConnectorParametersFormProps> = ({
    65|   secretsSchema,
    66|   defaultValues,
    67|   isSubmitting = false,
    68|   onSaveClick,
    69|   onTestConnectionClick,
    70|   testButtonLabel = "Test connection",
    71|   connectionOption,
    72|   connectionConfig,
    73|   datasetDropdownOptions,
    74|   isCreatingConnectionConfig,
    75|   onDelete,
    76|   deleteResult,
    77| }) => {
    78|   const mounted = useRef(false);
    79|   const { handleError } = useAPIHelper();
    80|   const [trigger, result] = useLazyGetDatastoreConnectionStatusQuery();
    81|   const validateConnectionIdentifier = (value: string) => {
    82|     let error;
    83|     if (typeof value === "undefined" || value === "") {
    84|       error = "Connection Identifier is required";
    85|     }
    86|     if (value && isNumeric(value)) {
    87|       error = "Connection Identifier must be an alphanumeric value";
    88|     }
    89|     return error;
    90|   };
    91|   const validateField = (label: string, value: string, type?: string) => {
    92|     let error;
    93|     if (typeof value === "undefined" || value === "") {
    94|       error = `${label} is required`;
    95|     }
    96|     if (type === FIDES_DATASET_REFERENCE) {
    97|       if (!value.includes(".")) {
    98|         error = "Dataset reference must be dot delimited";
    99|       } else {
   100|         const parts = value.split(".");
   101|         if (parts.length < 3) {
   102|           error = "Dataset reference must include at least three parts";
   103|         }
   104|       }
   105|     }
   106|     return error;
   107|   };
   108|   const getFormLabel = (id: string, value: string): JSX.Element => (
   109|     <FormLabel
   110|       color="gray.900"
   111|       fontSize="14px"
   112|       fontWeight="semibold"
   113|       htmlFor={id}
   114|       minWidth="150px"
   115|     >
   116|       {value}
   117|     </FormLabel>
   118|   );
   119|   const getPlaceholder = (item: ConnectionTypeSecretSchemaProperty) => {
   120|     if (item.allOf?.[0].$ref === FIDES_DATASET_REFERENCE) {
   121|       return "Enter dataset.collection.field";
   122|     }
   123|     return undefined;
   124|   };
   125|   const getFormField = (
   126|     key: string,
   127|     item: ConnectionTypeSecretSchemaProperty
   128|   ): JSX.Element => (
   129|     <Field
   130|       id={key}
   131|       name={key}
   132|       key={key}
   133|       validate={
   134|         secretsSchema?.required?.includes(key) || item.type === "integer"
   135|           ? (value: string) =>
   136|               validateField(item.title, value, item.allOf?.[0].$ref)
   137|           : false
   138|       }
   139|     >
   140|       {({ field, form }: { field: FieldInputProps<string>; form: any }) => (
   141|         <FormControl
   142|           display="flex"
   143|           isRequired={secretsSchema?.required?.includes(key)}
   144|           isInvalid={form.errors[key] && form.touched[key]}
   145|         >
   146|           {getFormLabel(key, item.title)}
   147|           <VStack align="flex-start" w="inherit">
   148|             {item.type !== "integer" && (
   149|               <Input
   150|                 {...field}
   151|                 placeholder={getPlaceholder(item)}
   152|                 autoComplete="off"
   153|                 color="gray.700"
   154|                 size="sm"
   155|               />
   156|             )}
   157|             {item.type === "integer" && (
   158|               <NumberInput
   159|                 allowMouseWheel
   160|                 color="gray.700"
   161|                 defaultValue={0}
   162|                 min={0}
   163|                 size="sm"

# --- HUNK 2: Lines 205-398 ---
   205|   const handleSubmit = (values: any, actions: any) => {
   206|     const updatedValues = { ...values };
   207|     if (secretsSchema) {
   208|       Object.keys(secretsSchema.properties).forEach((key) => {
   209|         if (
   210|           secretsSchema.properties[key].allOf?.[0].$ref ===
   211|           FIDES_DATASET_REFERENCE
   212|         ) {
   213|           const referencePath = values[key].split(".");
   214|           updatedValues[key] = {
   215|             dataset: referencePath.shift(),
   216|             field: referencePath.join("."),
   217|             direction: "from",
   218|           };
   219|         }
   220|       });
   221|     }
   222|     onSaveClick(updatedValues, actions);
   223|   };
   224|   const handleTestConnectionClick = async () => {
   225|     try {
   226|       await trigger(connectionConfig!.key).unwrap();
   227|     } catch (error) {
   228|       handleError(error);
   229|     }
   230|   };
   231|   useEffect(() => {
   232|     mounted.current = true;
   233|     if (result.isSuccess) {
   234|       onTestConnectionClick(result);
   235|     }
   236|     return () => {
   237|       mounted.current = false;
   238|     };
   239|   }, [onTestConnectionClick, result]);
   240|   return (
   241|     <Formik
   242|       enableReinitialize
   243|       initialValues={getInitialValues()}
   244|       onSubmit={handleSubmit}
   245|       validateOnBlur={false}
   246|       validateOnChange={false}
   247|     >
   248|       {/* @ts-ignore */}
   249|       {(props: FormikProps<Values>) => (
   250|         <Form noValidate>
   251|           <VStack align="stretch" gap="16px">
   252|             <Field
   253|               id="name"
   254|               name="name"
   255|               validate={(value: string) => validateField("Name", value)}
   256|             >
   257|               {({ field }: { field: FieldInputProps<string> }) => (
   258|                 <FormControl
   259|                   display="flex"
   260|                   isRequired
   261|                   isInvalid={props.errors.name && props.touched.name}
   262|                 >
   263|                   {getFormLabel("name", "Name")}
   264|                   <VStack align="flex-start" w="inherit">
   265|                     <Input
   266|                       {...field}
   267|                       autoComplete="off"
   268|                       autoFocus
   269|                       color="gray.700"
   270|                       placeholder={`Enter a friendly name for your new ${
   271|                         connectionOption!.human_readable
   272|                       } connection`}
   273|                       size="sm"
   274|                       data-testid="input-name"
   275|                     />
   276|                     <FormErrorMessage>{props.errors.name}</FormErrorMessage>
   277|                   </VStack>
   278|                   <Flex alignItems="center" h="32px" visibility="hidden">
   279|                     <CircleHelpIcon marginLeft="8px" />
   280|                   </Flex>
   281|                 </FormControl>
   282|               )}
   283|             </Field>
   284|             {/* Description */}
   285|             <Field id="description" name="description">
   286|               {({ field }: { field: FieldInputProps<string> }) => (
   287|                 <FormControl display="flex">
   288|                   {getFormLabel("description", "Description")}
   289|                   <Textarea
   290|                     {...field}
   291|                     color="gray.700"
   292|                     placeholder={`Enter a description for your new ${
   293|                       connectionOption!.human_readable
   294|                     } connection`}
   295|                     resize="none"
   296|                     size="sm"
   297|                     value={field.value || ""}
   298|                   />
   299|                   <Flex alignItems="center" h="32px" visibility="hidden">
   300|                     <CircleHelpIcon marginLeft="8px" />
   301|                   </Flex>
   302|                 </FormControl>
   303|               )}
   304|             </Field>
   305|             {/* Connection Identifier */}
   306|             {connectionOption.type !== SystemType.MANUAL ? (
   307|               <Field
   308|                 id="instance_key"
   309|                 name="instance_key"
   310|                 validate={validateConnectionIdentifier}
   311|               >
   312|                 {({ field }: { field: FieldInputProps<string> }) => (
   313|                   <FormControl
   314|                     display="flex"
   315|                     isRequired
   316|                     isInvalid={
   317|                       props.errors.instance_key && props.touched.instance_key
   318|                     }
   319|                   >
   320|                     {getFormLabel("instance_key", "Connection Identifier")}
   321|                     <VStack align="flex-start" w="inherit">
   322|                       <Input
   323|                         {...field}
   324|                         autoComplete="off"
   325|                         color="gray.700"
   326|                         isDisabled={!!connectionConfig?.key}
   327|                         placeholder={`A unique identifier for your new ${
   328|                           connectionOption!.human_readable
   329|                         } connection`}
   330|                         size="sm"
   331|                       />
   332|                       <FormErrorMessage>
   333|                         {props.errors.instance_key}
   334|                       </FormErrorMessage>
   335|                     </VStack>
   336|                     <Tooltip
   337|                       aria-label="The fides_key will allow fidesops to associate dataset field references appropriately. Must be a unique alphanumeric value with no spaces (underscores allowed) to represent this connection."
   338|                       hasArrow
   339|                       label="The fides_key will allow fidesops to associate dataset field references appropriately. Must be a unique alphanumeric value with no spaces (underscores allowed) to represent this connection."
   340|                       placement="right-start"
   341|                       openDelay={500}
   342|                     >
   343|                       <Flex alignItems="center" h="32px">
   344|                         <CircleHelpIcon
   345|                           marginLeft="8px"
   346|                           _hover={{ cursor: "pointer" }}
   347|                         />
   348|                       </Flex>
   349|                     </Tooltip>
   350|                   </FormControl>
   351|                 )}
   352|               </Field>
   353|             ) : null}
   354|             {/* Dynamic connector secret fields */}
   355|             {connectionOption.type !== SystemType.MANUAL && secretsSchema
   356|               ? Object.entries(secretsSchema.properties).map(([key, item]) => {
   357|                   if (key === "advanced_settings") {
   358|                     return null;
   359|                   }
   360|                   return getFormField(key, item);
   361|                 })
   362|               : null}
   363|             {SystemType.DATABASE === connectionOption.type &&
   364|             !isCreatingConnectionConfig ? (
   365|               <DatasetConfigField
   366|                 dropdownOptions={datasetDropdownOptions}
   367|                 connectionConfig={connectionConfig}
   368|               />
   369|             ) : null}
   370|             <ButtonGroup size="sm" spacing="8px" variant="outline">
   371|               <Button
   372|                 colorScheme="gray.700"
   373|                 isDisabled={
   374|                   !connectionConfig?.key ||
   375|                   isSubmitting ||
   376|                   deleteResult.isLoading
   377|                 }
   378|                 isLoading={result.isLoading || result.isFetching}
   379|                 loadingText="Testing"
   380|                 onClick={handleTestConnectionClick}
   381|                 variant="outline"
   382|               >
   383|                 {testButtonLabel}
   384|               </Button>
   385|               {connectionOption.type === SystemType.MANUAL &&
   386|               connectionConfig ? (
   387|                 <DSRCustomizationModal connectionConfig={connectionConfig} />
   388|               ) : null}
   389|               <Button
   390|                 bg="primary.800"
   391|                 color="white"
   392|                 isDisabled={deleteResult.isLoading || isSubmitting}
   393|                 isLoading={isSubmitting}
   394|                 loadingText="Submitting"
   395|                 size="sm"
   396|                 variant="solid"
   397|                 type="submit"
   398|                 _active={{ bg: "primary.500" }}


# ====================================================================
# FILE: clients/admin-ui/src/features/datastore-connections/system_portal_config/forms/fields/DatasetConfigField/DatasetConfigField.tsx
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 225-259 ---
   225|     if (allDatasets && datasetDropdownOption.value) {
   226|       const matchingDataset = allDatasets.find(
   227|         (d) => d.fides_key === datasetDropdownOption.value
   228|       );
   229|       if (matchingDataset) {
   230|         setDatasetYaml(matchingDataset);
   231|       }
   232|     }
   233|   }, [allDatasets, datasetDropdownOption.value, setDatasetYaml]);
   234|   return (
   235|     <Flex flexDirection="row">
   236|       <DatasetSelect
   237|         label="Dataset"
   238|         labelProps={{
   239|           fontWeight: "semibold",
   240|           fontSize: "sm",
   241|           minWidth: "150px",
   242|         }}
   243|         name={fieldName}
   244|         options={dropdownOptions}
   245|         isRequired
   246|         onOpen={onOpen}
   247|         isLoading={isLoading}
   248|       />
   249|       <YamlEditorModal
   250|         isOpen={isOpen}
   251|         onClose={onClose}
   252|         onChange={setDatasetYaml}
   253|         isDatasetSelected={!!datasetDropdownOption.value}
   254|         dataset={datasetYaml.value}
   255|       />
   256|     </Flex>
   257|   );
   258| };
   259| export default DatasetConfigField;


# ====================================================================
# FILE: clients/admin-ui/src/features/system/system.slice.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 23-63 ---
    23|       providesTags: () => ["System"],
    24|     }),
    25|     getSystemByFidesKey: build.query<SystemResponse, string>({
    26|       query: (fides_key) => ({ url: `system/${fides_key}/` }),
    27|       providesTags: ["System"],
    28|     }),
    29|     createSystem: build.mutation<System, System | unknown>({
    30|       query: (body) => ({
    31|         url: `system/`,
    32|         method: "POST",
    33|         body,
    34|       }),
    35|       invalidatesTags: () => ["Datamap", "System", "Datastore Connection"],
    36|     }),
    37|     deleteSystem: build.mutation<SystemDeleteResponse, string>({
    38|       query: (key) => ({
    39|         url: `system/${key}`,
    40|         params: { resource_type: "system" },
    41|         method: "DELETE",
    42|       }),
    43|       invalidatesTags: ["System", "Datastore Connection"],
    44|     }),
    45|     upsertSystems: build.mutation<UpsertResponse, System[]>({
    46|       query: (systems) => ({
    47|         url: `/system/upsert`,
    48|         method: "POST",
    49|         body: systems,
    50|       }),
    51|       invalidatesTags: ["Datamap", "System", "Datastore Connection"],
    52|     }),
    53|     updateSystem: build.mutation<
    54|       SystemResponse,
    55|       Partial<System> & Pick<System, "fides_key">
    56|     >({
    57|       query: ({ ...patch }) => ({
    58|         url: `system/`,
    59|         params: { resource_type: "system" },
    60|         method: "PUT",
    61|         body: patch,
    62|       }),
    63|       invalidatesTags: [


# ====================================================================
# FILE: clients/fides-js/src/fides.ts
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 49-101 ---
    49| import { shopify } from "./integrations/shopify";
    50| import { getConsentContext } from "./lib/consent-context";
    51| import { initOverlay } from "./lib/consent";
    52| import {
    53|   CookieKeyConsent,
    54|   CookieIdentity,
    55|   CookieMeta,
    56|   getOrMakeFidesCookie,
    57|   makeConsentDefaultsLegacy,
    58|   buildCookieConsentForExperiences,
    59|   FidesCookie,
    60|   isNewFidesCookie,
    61| } from "./lib/cookie";
    62| import {
    63|   PrivacyExperience,
    64|   FidesConfig,
    65|   FidesOptions,
    66|   UserGeolocation,
    67|   ConsentMethod,
    68|   SaveConsentPreference,
    69| } from "./lib/consent-types";
    70| import {
    71|   constructFidesRegionString,
    72|   debugLog,
    73|   experienceIsValid,
    74|   transformConsentToFidesUserPreference,
    75|   validateOptions,
    76| } from "./lib/consent-utils";
    77| import { dispatchFidesEvent } from "./lib/events";
    78| import { fetchExperience } from "./services/fides/api";
    79| import { getGeolocation } from "./services/external/geolocation";
    80| import { OverlayProps } from "./components/Overlay";
    81| import { updateConsentPreferences } from "./lib/preferences";
    82| export type Fides = {
    83|   consent: CookieKeyConsent;
    84|   experience?: PrivacyExperience;
    85|   geolocation?: UserGeolocation;
    86|   options: FidesOptions;
    87|   fides_meta: CookieMeta;
    88|   gtm: typeof gtm;
    89|   identity: CookieIdentity;
    90|   init: typeof init;
    91|   initialized: boolean;
    92|   meta: typeof meta;
    93|   shopify: typeof shopify;
    94| };
    95| declare global {
    96|   interface Window {
    97|     Fides: Fides;
    98|   }
    99| }
   100| let _Fides: Fides;
   101| const retrieveEffectiveRegionString = async (

# --- HUNK 2: Lines 103-200 ---
   103|   options: FidesOptions
   104| ) => {
   105|   const fidesRegionString = constructFidesRegionString(geolocation);
   106|   if (!fidesRegionString) {
   107|     return constructFidesRegionString(
   108|       await getGeolocation(
   109|         options.isGeolocationEnabled,
   110|         options.geolocationApiUrl,
   111|         options.debug
   112|       )
   113|     );
   114|   }
   115|   return fidesRegionString;
   116| };
   117| const automaticallyApplyGPCPreferences = (
   118|   cookie: FidesCookie,
   119|   fidesRegionString: string | null,
   120|   fidesApiUrl: string,
   121|   effectiveExperience?: PrivacyExperience | null
   122| ) => {
   123|   if (!effectiveExperience) {
   124|     return;
   125|   }
   126|   if (!getConsentContext().globalPrivacyControl) {
   127|     return;
   128|   }
   129|   const consentPreferencesToSave: Array<SaveConsentPreference> = [];
   130|   effectiveExperience.privacy_notices?.forEach((notice) => {
   131|     if (notice.has_gpc_flag && !notice.current_preference) {
   132|       consentPreferencesToSave.push(
   133|         new SaveConsentPreference(
   134|           notice,
   135|           transformConsentToFidesUserPreference(false, notice.consent_mechanism)
   136|         )
   137|       );
   138|     }
   139|   });
   140|   if (consentPreferencesToSave.length > 0) {
   141|     updateConsentPreferences({
   142|       consentPreferencesToSave,
   143|       experienceId: effectiveExperience.id,
   144|       fidesApiUrl,
   145|       consentMethod: ConsentMethod.gpc,
   146|       userLocationString: fidesRegionString || undefined,
   147|       cookie,
   148|     });
   149|   }
   150| };
   151| /**
   152|  * Initialize the global Fides object with the given configuration values
   153|  */
   154| const init = async ({
   155|   consent,
   156|   experience,
   157|   geolocation,
   158|   options,
   159| }: FidesConfig) => {
   160|   const context = getConsentContext();
   161|   const consentDefaults = makeConsentDefaultsLegacy(
   162|     consent,
   163|     context,
   164|     options.debug
   165|   );
   166|   const cookie: FidesCookie = getOrMakeFidesCookie(
   167|     consentDefaults,
   168|     options.debug
   169|   );
   170|   const hasExistingCookie = !isNewFidesCookie(cookie);
   171|   if (hasExistingCookie) {
   172|     _Fides.consent = cookie.consent;
   173|     _Fides.fides_meta = cookie.fides_meta;
   174|     _Fides.identity = cookie.identity;
   175|     _Fides.experience = experience;
   176|     _Fides.geolocation = geolocation;
   177|     _Fides.options = options;
   178|     _Fides.initialized = true;
   179|     dispatchFidesEvent("FidesInitialized", cookie);
   180|     dispatchFidesEvent("FidesUpdated", cookie);
   181|   }
   182|   let shouldInitOverlay: boolean = options.isOverlayEnabled;
   183|   let effectiveExperience: PrivacyExperience | undefined | null = experience;
   184|   let fidesRegionString: string | null = null;
   185|   if (shouldInitOverlay) {
   186|     if (!validateOptions(options)) {
   187|       debugLog(
   188|         options.debug,
   189|         "Invalid overlay options. Skipping overlay initialization.",
   190|         options
   191|       );
   192|       shouldInitOverlay = false;
   193|     }
   194|     fidesRegionString = await retrieveEffectiveRegionString(
   195|       geolocation,
   196|       options
   197|     );
   198|     if (!fidesRegionString) {
   199|       debugLog(
   200|         options.debug,

# --- HUNK 3: Lines 211-269 ---
   211|     }
   212|     if (
   213|       effectiveExperience &&
   214|       experienceIsValid(effectiveExperience, options)
   215|     ) {
   216|       cookie.consent = buildCookieConsentForExperiences(
   217|         effectiveExperience,
   218|         context,
   219|         options.debug
   220|       );
   221|       if (shouldInitOverlay) {
   222|         await initOverlay(<OverlayProps>{
   223|           experience: effectiveExperience,
   224|           fidesRegionString,
   225|           cookie,
   226|           options,
   227|         }).catch(() => {});
   228|       }
   229|     }
   230|   }
   231|   _Fides.consent = cookie.consent;
   232|   _Fides.fides_meta = cookie.fides_meta;
   233|   _Fides.identity = cookie.identity;
   234|   _Fides.experience = experience;
   235|   _Fides.geolocation = geolocation;
   236|   _Fides.options = options;
   237|   _Fides.initialized = true;
   238|   if (!hasExistingCookie) {
   239|     dispatchFidesEvent("FidesInitialized", cookie);
   240|   }
   241|   dispatchFidesEvent("FidesUpdated", cookie);
   242|   if (shouldInitOverlay) {
   243|     automaticallyApplyGPCPreferences(
   244|       cookie,
   245|       fidesRegionString,
   246|       options.fidesApiUrl,
   247|       effectiveExperience
   248|     );
   249|   }
   250| };
   251| _Fides = {
   252|   consent: {},
   253|   experience: undefined,
   254|   geolocation: {},
   255|   options: {
   256|     debug: true,
   257|     isOverlayEnabled: false,
   258|     isGeolocationEnabled: false,
   259|     geolocationApiUrl: "",
   260|     overlayParentId: null,
   261|     modalLinkId: null,
   262|     privacyCenterUrl: "",
   263|     fidesApiUrl: "",
   264|   },
   265|   fides_meta: {},
   266|   identity: {},
   267|   gtm,
   268|   init,
   269|   initialized: false,


# ====================================================================
# FILE: clients/fides-js/src/lib/consent-types.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 132-171 ---
   132|   privacy_experience_id?: string;
   133|   user_geography?: string;
   134|   method?: ConsentMethod;
   135| };
   136| export type ConsentOptionCreate = {
   137|   privacy_notice_history_id: string;
   138|   preference: UserConsentPreference;
   139| };
   140| export type Identity = {
   141|   phone_number?: string;
   142|   email?: string;
   143|   ga_client_id?: string;
   144|   ljt_readerID?: string;
   145|   fides_user_device_id?: string;
   146| };
   147| export enum RequestOrigin {
   148|   privacy_center = "privacy_center",
   149|   overlay = "overlay",
   150|   api = "api",
   151| }
   152| export type ConditionalValue = {
   153|   value: boolean;
   154|   globalPrivacyControl: boolean;
   155| };
   156| /**
   157|  * A consent value can be a boolean:
   158|  *  - `true`: consent/opt-in
   159|  *  - `false`: revoke/opt-out
   160|  *
   161|  * A consent value can also be context-dependent, which means it will be decided based on
   162|  * information about the user's environment (browser). The `ConditionalValue` object maps the
   163|  * context conditions to the value that should be used:
   164|  *  - `value`: The default value if no context applies.
   165|  *  - `globalPrivacyControl`: The value to use if the user's browser has Global Privacy Control
   166|  *    enabled.
   167|  */
   168| export type ConsentValue = boolean | ConditionalValue;
   169| export type ConsentOption = {
   170|   cookieKeys: string[];
   171|   default?: ConsentValue;


# ====================================================================
# FILE: clients/fides-js/src/lib/preferences.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 56-77 ---
    56|   const privacyPreferenceCreate: PrivacyPreferencesRequest = {
    57|     browser_identity: cookie.identity,
    58|     preferences: fidesUserPreferences,
    59|     privacy_experience_id: experienceId,
    60|     user_geography: userLocationString,
    61|     method: consentMethod,
    62|   };
    63|   patchUserPreferenceToFidesServer(privacyPreferenceCreate, fidesApiUrl, debug);
    64|   debugLog(debug, "Updating window.Fides");
    65|   window.Fides.consent = cookie.consent;
    66|   debugLog(debug, "Saving preferences to cookie");
    67|   saveFidesCookie(cookie);
    68|   consentPreferencesToSave
    69|     .filter(
    70|       (preference) =>
    71|         preference.consentPreference === UserConsentPreference.OPT_OUT
    72|     )
    73|     .forEach((preference) => {
    74|       removeCookiesFromBrowser(preference.notice.cookies);
    75|     });
    76|   dispatchFidesEvent("FidesUpdated", cookie);
    77| };


# ====================================================================
# FILE: clients/fides-js/src/services/fides/api.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 8-54 ---
     8|   PRIVACY_EXPERIENCE = "/privacy-experience",
     9|   PRIVACY_PREFERENCES = "/privacy-preferences",
    10| }
    11| /**
    12|  * Fetch the relevant experience based on user location and user device id (if exists).
    13|  * Fetches both Privacy Center and Overlay components, because GPC needs to work regardless of component
    14|  */
    15| export const fetchExperience = async (
    16|   userLocationString: string,
    17|   fidesApiUrl: string,
    18|   fidesUserDeviceId: string,
    19|   debug: boolean
    20| ): Promise<PrivacyExperience | null> => {
    21|   debugLog(
    22|     debug,
    23|     `Fetching experience for userId: ${fidesUserDeviceId} in location: ${userLocationString}`
    24|   );
    25|   const fetchOptions: RequestInit = {
    26|     method: "GET",
    27|     mode: "cors",
    28|   };
    29|   const params = new URLSearchParams({
    30|     show_disabled: "false",
    31|     region: userLocationString,
    32|     component: ComponentType.OVERLAY,
    33|     has_notices: "true",
    34|     has_config: "true",
    35|     fides_user_device_id: fidesUserDeviceId,
    36|   });
    37|   const response = await fetch(
    38|     `${fidesApiUrl}${FidesEndpointPaths.PRIVACY_EXPERIENCE}?${params}`,
    39|     fetchOptions
    40|   );
    41|   if (!response.ok) {
    42|     debugLog(
    43|       debug,
    44|       "Error getting experience from Fides API, returning null. Response:",
    45|       response
    46|     );
    47|     return null;
    48|   }
    49|   try {
    50|     const body = await response.json();
    51|     const experience = body.items && body.items[0];
    52|     if (!experience) {
    53|       debugLog(
    54|         debug,


# ====================================================================
# FILE: clients/privacy-center/components/consent/NoticeDrivenConsent.tsx
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| import { Divider, Stack, useToast } from "@fidesui/react";
     2| import React, { useEffect, useMemo, useState } from "react";
     3| import {
     4|   ConsentContext,
     5|   CookieKeyConsent,
     6|   getConsentContext,
     7|   getOrMakeFidesCookie,
     8|   removeCookiesFromBrowser,
     9|   saveFidesCookie,
    10|   transformUserPreferenceToBoolean,
    11| } from "fides-js";
    12| import { useAppSelector } from "~/app/hooks";
    13| import {
    14|   selectCurrentConsentPreferences,
    15|   selectUserRegion,
    16|   selectPrivacyExperience,
    17|   useUpdatePrivacyPreferencesMutation,
    18| } from "~/features/consent/consent.slice";
    19| import { getGpcStatusFromNotice } from "~/features/consent/helpers";
    20| import {
    21|   ConsentMechanism,
    22|   ConsentMethod,
    23|   ConsentOptionCreate,
    24|   PrivacyNoticeResponseWithUserPreferences,
    25|   PrivacyPreferencesRequest,
    26|   UserConsentPreference,
    27| } from "~/types/api";
    28| import { useRouter } from "next/router";
    29| import { inspectForBrowserIdentities } from "~/common/browser-identities";
    30| import { NoticeHistoryIdToPreference } from "~/features/consent/types";
    31| import { ErrorToastOptions, SuccessToastOptions } from "~/common/toast-options";
    32| import { useLocalStorage } from "~/common/hooks";
    33| import ConsentItem from "./ConsentItem";
    34| import SaveCancel from "./SaveCancel";
    35| import PrivacyPolicyLink from "./PrivacyPolicyLink";
    36| const resolveConsentValue = (
    37|   notice: PrivacyNoticeResponseWithUserPreferences,
    38|   context: ConsentContext
    39| ) => {

# --- HUNK 2: Lines 74-114 ---
    74|     return newPreferences;
    75|   }, [serverPreferences, experience, consentContext]);
    76|   const [draftPreferences, setDraftPreferences] =
    77|     useState<NoticeHistoryIdToPreference>(initialDraftPreferences);
    78|   useEffect(() => {
    79|     setDraftPreferences(initialDraftPreferences);
    80|   }, [initialDraftPreferences]);
    81|   const items = useMemo(() => {
    82|     if (!experience) {
    83|       return [];
    84|     }
    85|     const { privacy_notices: notices } = experience;
    86|     if (!notices || notices.length === 0) {
    87|       return [];
    88|     }
    89|     return notices.map((notice) => {
    90|       const preference = draftPreferences[notice.privacy_notice_history_id];
    91|       const value = transformUserPreferenceToBoolean(preference);
    92|       const gpcStatus = getGpcStatusFromNotice({
    93|         value,
    94|         notice,
    95|         consentContext,
    96|       });
    97|       return {
    98|         name: notice.name || "",
    99|         description: notice.description || "",
   100|         id: notice.id,
   101|         historyId: notice.privacy_notice_history_id,
   102|         highlight: false,
   103|         url: undefined,
   104|         value,
   105|         gpcStatus,
   106|         disabled: notice.consent_mechanism === ConsentMechanism.NOTICE_ONLY,
   107|       };
   108|     });
   109|   }, [consentContext, experience, draftPreferences]);
   110|   const handleCancel = () => {
   111|     router.push("/");
   112|   };
   113|   /**
   114|    * When saving, we need to:


# ====================================================================
# FILE: clients/privacy-center/cypress/e2e/consent-banner.cy.ts
# Total hunks: 6
# ====================================================================
# --- HUNK 1: Lines 161-201 ---
   161|           {},
   162|           {}
   163|         );
   164|       });
   165|       it("sets Fides.consent object with default consent based on legacy consent", () => {
   166|         cy.window().its("Fides").its("consent").should("eql", {
   167|           data_sales: true,
   168|           tracking: false,
   169|         });
   170|       });
   171|       it("does not render banner", () => {
   172|         cy.get("div#fides-banner").should("not.exist");
   173|         cy.contains("button", "Accept Test").should("not.exist");
   174|       });
   175|       it("does not render modal link", () => {
   176|         cy.get("#fides-modal-link").should("not.be.visible");
   177|       });
   178|     });
   179|   });
   180|   describe("when user has no saved consent cookie", () => {
   181|     describe("when banner is not disabled", () => {
   182|       beforeEach(() => {
   183|         cy.getCookie(CONSENT_COOKIE_NAME).should("not.exist");
   184|         stubConfig({
   185|           options: {
   186|             isOverlayEnabled: true,
   187|           },
   188|         });
   189|       });
   190|       it("should render the expected HTML banner", () => {
   191|         cy.get("div#fides-banner").within(() => {
   192|           cy.get(
   193|             "div#fides-banner-description.fides-banner-description"
   194|           ).contains(
   195|             "This test website is overriding the banner description label."
   196|           );
   197|           cy.get("div#fides-button-group").within(() => {
   198|             cy.get(
   199|               "button#fides-banner-button-tertiary.fides-banner-button.fides-banner-button-tertiary"
   200|             ).contains("Manage preferences");
   201|             cy.get(

# --- HUNK 2: Lines 577-673 ---
   577|       it("stores consent in cookie", () => {
   578|         cy.waitUntilCookieExists(CONSENT_COOKIE_NAME).then(() => {
   579|           cy.getCookie(CONSENT_COOKIE_NAME).then((cookie) => {
   580|             const cookieKeyConsent: FidesCookie = JSON.parse(
   581|               decodeURIComponent(cookie!.value)
   582|             );
   583|             expect(cookieKeyConsent.consent)
   584|               .property(PRIVACY_NOTICE_KEY_1)
   585|               .is.eql(false);
   586|           });
   587|         });
   588|       });
   589|       it("updates Fides consent obj", () => {
   590|         cy.window()
   591|           .its("Fides")
   592|           .its("consent")
   593|           .should("eql", {
   594|             [PRIVACY_NOTICE_KEY_1]: false,
   595|           });
   596|       });
   597|     });
   598|     describe("when GPC flag is found, and no notices apply to GPC", () => {
   599|       beforeEach(() => {
   600|         cy.on("window:before:load", (win) => {
   601|           win.navigator.globalPrivacyControl = true;
   602|         });
   603|         stubConfig({
   604|           experience: {
   605|             privacy_notices: [
   606|               mockPrivacyNotice({
   607|                 name: "Test privacy notice with GPC disabled",
   608|                 has_gpc_flag: false,
   609|               }),
   610|             ],
   611|           },
   612|         });
   613|       });
   614|       it("does not set user consent preference automatically", () => {
   615|         cy.on("fail", (error) => {
   616|           if (error.message.indexOf("Timed out retrying") !== 0) {
   617|             throw error;
   618|           }
   619|         });
   620|         cy.wait("@patchPrivacyPreference", {
   621|           requestTimeout: 500,
   622|         }).then((xhr) => {
   623|           assert.isNull(xhr?.response?.body);
   624|         });
   625|         cy.window().its("Fides").its("consent").should("eql", {});
   626|         cy.getCookie(CONSENT_COOKIE_NAME).should("not.exist");
   627|       });
   628|     });
   629|     describe("when no GPC flag is found, and notices apply to GPC", () => {
   630|       beforeEach(() => {
   631|         cy.on("window:before:load", (win) => {
   632|           win.navigator.globalPrivacyControl = undefined;
   633|         });
   634|         cy.getCookie(CONSENT_COOKIE_NAME).should("not.exist");
   635|         stubConfig({
   636|           experience: {
   637|             privacy_notices: [mockPrivacyNotice({ has_gpc_flag: true })],
   638|           },
   639|         });
   640|       });
   641|       it("does not set user consent preference automatically", () => {
   642|         cy.on("fail", (error) => {
   643|           if (error.message.indexOf("Timed out retrying") !== 0) {
   644|             throw error;
   645|           }
   646|         });
   647|         cy.wait("@patchPrivacyPreference", {
   648|           requestTimeout: 500,
   649|         }).then((xhr) => {
   650|           assert.isNull(xhr?.response?.body);
   651|         });
   652|         cy.window().its("Fides").its("consent").should("eql", {});
   653|         cy.getCookie(CONSENT_COOKIE_NAME).should("not.exist");
   654|       });
   655|     });
   656|     describe("when experience component is not an overlay", () => {
   657|       beforeEach(() => {
   658|         stubConfig({
   659|           experience: {
   660|             component: ComponentType.PRIVACY_CENTER,
   661|           },
   662|         });
   663|       });
   664|       it("does not render banner", () => {
   665|         cy.get("div#fides-banner").should("not.exist");
   666|         cy.contains("button", "Accept Test").should("not.exist");
   667|       });
   668|       it("does not render modal link", () => {
   669|         cy.get("#fides-modal-link").should("not.be.visible");
   670|       });
   671|     });
   672|     describe("when experience is not provided, and valid geolocation is provided", () => {
   673|       beforeEach(() => {

# --- HUNK 3: Lines 876-915 ---
   876|         cy.waitUntilFidesInitialized().then(() => {
   877|           cy.get("div#fides-banner").should("not.exist");
   878|         });
   879|       });
   880|       it("renders modal link", () => {
   881|         cy.get("#fides-modal-link").should("be.visible");
   882|       });
   883|       it("does not set user consent preference automatically", () => {
   884|         cy.on("fail", (error) => {
   885|           if (error.message.indexOf("Timed out retrying") !== 0) {
   886|             throw error;
   887|           }
   888|         });
   889|         cy.wait("@patchPrivacyPreference", {
   890|           requestTimeout: 500,
   891|         }).then((xhr) => {
   892|           assert.isNull(xhr?.response?.body);
   893|         });
   894|         cy.window().its("Fides").its("consent").should("eql", {});
   895|         cy.getCookie(CONSENT_COOKIE_NAME).should("not.exist");
   896|       });
   897|     });
   898|     describe("when banner should not be shown but modal link element exists", () => {
   899|       beforeEach(() => {
   900|         stubConfig({
   901|           experience: {
   902|             show_banner: false,
   903|           },
   904|         });
   905|       });
   906|       it("does not render banner", () => {
   907|         cy.waitUntilFidesInitialized().then(() => {
   908|           cy.get("div#fides-banner").should("not.exist");
   909|         });
   910|       });
   911|       it("shows the modal link", () => {
   912|         cy.get("#fides-modal-link").should("be.visible");
   913|       });
   914|       describe("modal link click", () => {
   915|         it("should open modal", () => {

# --- HUNK 4: Lines 1312-1332 ---
  1312|           .its("firstCall.args.0.detail")
  1313|           .should("deep.equal", {
  1314|             consent: {
  1315|               data_sales: false,
  1316|               tracking: false,
  1317|               analytics: true,
  1318|             },
  1319|           });
  1320|         cy.get("@FidesUpdated")
  1321|           .its("secondCall.args.0.detail")
  1322|           .should("deep.equal", {
  1323|             consent: {
  1324|               data_sales: false,
  1325|               tracking: false,
  1326|               analytics: true,
  1327|             },
  1328|           });
  1329|       });
  1330|     });
  1331|   });
  1332| });


# ====================================================================
# FILE: clients/privacy-center/cypress/e2e/consent-notices.cy.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 91-134 ---
    91|         cy.waitUntilCookieExists(CONSENT_COOKIE_NAME).then(() => {
    92|           cy.getCookie(CONSENT_COOKIE_NAME).then((cookieJson) => {
    93|             const cookie = JSON.parse(
    94|               decodeURIComponent(cookieJson!.value)
    95|             ) as FidesCookie;
    96|             expect(body.browser_identity.fides_user_device_id).to.eql(
    97|               cookie.identity.fides_user_device_id
    98|             );
    99|             const expectedConsent = { data_sales: true, advertising: true };
   100|             const { consent } = cookie;
   101|             expect(consent).to.eql(expectedConsent);
   102|             cy.window().then((win) => {
   103|               expect(win.Fides.consent).to.eql(expectedConsent);
   104|             });
   105|           });
   106|         });
   107|       });
   108|     });
   109|     it("uses the device id found in an already existing cookie", () => {
   110|       const uuid = "4fbb6edf-34f6-4717-a6f1-541fd1e5d585";
   111|       const now = "2023-04-28T12:00:00.000Z";
   112|       const cookie = {
   113|         identity: { fides_user_device_id: uuid },
   114|         fides_meta: { version: "0.9.0", createdAt: now },
   115|         consent: {},
   116|       };
   117|       cy.setCookie(CONSENT_COOKIE_NAME, JSON.stringify(cookie));
   118|       cy.wait("@getExperience").then((interception) => {
   119|         const { url } = interception.request;
   120|         expect(url).contains(`fides_user_device_id=${uuid}`);
   121|       });
   122|       cy.getByTestId("save-btn").click();
   123|       cy.wait("@patchPrivacyPreference").then((interception) => {
   124|         const { body } = interception.request;
   125|         cy.getCookie(CONSENT_COOKIE_NAME).then((cookieJson) => {
   126|           const savedCookie = JSON.parse(
   127|             decodeURIComponent(cookieJson!.value)
   128|           ) as FidesCookie;
   129|           expect(body.browser_identity.fides_user_device_id).to.eql(
   130|             savedCookie.identity.fides_user_device_id
   131|           );
   132|         });
   133|       });
   134|     });


# ====================================================================
# FILE: src/fides/api/main.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-57 ---
     1| """
     2| Contains the code that sets up the API.
     3| """
     4| import os
     5| import sys
     6| from datetime import datetime, timezone
     7| from logging import WARNING
     8| from typing import Callable, Optional
     9| from urllib.parse import unquote
    10| from fastapi import HTTPException, Request, Response, status
    11| from fastapi.responses import FileResponse
    12| from fideslog.sdk.python.event import AnalyticsEvent
    13| from loguru import logger
    14| from starlette.background import BackgroundTask
    15| from uvicorn import Config, Server
    16| import fides
    17| from fides.api.api.v1.endpoints.utils import API_PREFIX
    18| from fides.api.app_setup import (
    19|     check_redis,
    20|     create_fides_app,
    21|     log_startup,
    22|     run_database_startup,
    23| )
    24| from fides.api.common_exceptions import MalisciousUrlException
    25| from fides.api.middleware import handle_audit_log_resource
    26| from fides.api.schemas.analytics import Event, ExtraData
    27| from fides.api.service.privacy_request.email_batch_service import (
    28|     initiate_scheduled_batch_email_send,
    29| )
    30| from fides.api.tasks.scheduled.scheduler import scheduler
    31| from fides.api.ui import (
    32|     get_admin_index_as_response,
    33|     get_path_to_admin_ui_file,
    34|     get_ui_file_map,
    35|     match_route,
    36|     path_is_in_ui_directory,
    37| )
    38| from fides.api.util.logger import _log_exception
    39| from fides.cli.utils import FIDES_ASCII_ART
    40| from fides.config import CONFIG, check_required_webserver_config_values
    41| IGNORED_AUDIT_LOG_RESOURCE_PATHS = {"/api/v1/login"}
    42| VERSION = fides.__version__
    43| app = create_fides_app()
    44| @app.middleware("http")
    45| async def dispatch_log_request(request: Request, call_next: Callable) -> Response:
    46|     """
    47|     HTTP Middleware that logs analytics events for each call to Fides endpoints.
    48|     :param request: Request to Fides api
    49|     :param call_next: Callable api endpoint
    50|     :return: Response
    51|     """
    52|     path = request.url.path
    53|     if (not path.startswith(API_PREFIX)) or (path.endswith("/health")):
    54|         return await call_next(request)
    55|     fides_source: Optional[str] = request.headers.get("X-Fides-Source")
    56|     now: datetime = datetime.now(tz=timezone.utc)
    57|     endpoint = f"{request.method}: {request.url}"

# --- HUNK 2: Lines 113-153 ---
   113|     handler_time = datetime.now() - start
   114|     logger.bind(
   115|         method=request.method,
   116|         status_code=response.status_code,
   117|         handler_time=f"{round(handler_time.microseconds * 0.001,3)}ms",
   118|         path=request.url.path,
   119|     ).info("Request received")
   120|     return response
   121| @app.get("/", tags=["Default"])
   122| def read_index() -> Response:
   123|     """
   124|     Return an index.html at the root path
   125|     """
   126|     return get_admin_index_as_response()
   127| def sanitise_url_path(path: str) -> str:
   128|     """Returns a URL path that does not contain any ../ or //"""
   129|     path = unquote(path)
   130|     path = os.path.normpath(path)
   131|     for token in path.split("/"):
   132|         if ".." in token:
   133|             logger.warning(f"Potentially dangerous use of URL hierarchy in path: {path}")
   134|             raise MalisciousUrlException()
   135|     return path
   136| @app.get("/{catchall:path}", response_class=Response, tags=["Default"])
   137| def read_other_paths(request: Request) -> Response:
   138|     """
   139|     Return related frontend files. Adapted from https://github.com/tiangolo/fastapi/issues/130
   140|     """
   141|     path = request.path_params["catchall"]
   142|     logger.debug(f"Catch all path detected: {path}")
   143|     try:
   144|         path = sanitise_url_path(path)
   145|     except MalisciousUrlException:
   146|         return get_admin_index_as_response()
   147|     ui_file = match_route(get_ui_file_map(), path)
   148|     if not ui_file:
   149|         ui_file = get_path_to_admin_ui_file(path)
   150|     if ui_file and ui_file.is_file():
   151|         if not path_is_in_ui_directory(ui_file):
   152|             raise HTTPException(
   153|                 status_code=status.HTTP_404_NOT_FOUND, detail="Item not found"


# ====================================================================
# FILE: src/fides/api/models/privacy_notice.py
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-131 ---
     1| from __future__ import annotations
     2| import re
     3| from collections import defaultdict
     4| from enum import Enum
     5| from typing import Any, Dict, Iterable, List, Optional, Tuple, Type, Union
     6| from fideslang.validation import FidesKey
     7| from sqlalchemy import Boolean, Column
     8| from sqlalchemy import Enum as EnumColumn
     9| from sqlalchemy import Float, ForeignKey, String, or_
    10| from sqlalchemy.dialects.postgresql import ARRAY
    11| from sqlalchemy.orm import Session, relationship
    12| from sqlalchemy.util import hybridproperty
    13| from fides.api.common_exceptions import ValidationError
    14| from fides.api.db.base_class import Base, FidesBase
    15| from fides.api.models.sql_models import (  # type: ignore[attr-defined]
    16|     Cookies,
    17|     PrivacyDeclaration,
    18|     System,
    19| )
    20| class UserConsentPreference(Enum):
    21|     opt_in = "opt_in"  # The user wants to opt in to the notice
    22|     opt_out = "opt_out"  # The user wants to opt out of the notice
    23|     acknowledge = "acknowledge"  # The user has acknowledged this notice
    24| class PrivacyNoticeRegion(Enum):
    25|     """
    26|     Enum is not formalized in the DB because it is subject to frequent change
    27|     """
    28|     us_al = "us_al"  # alabama
    29|     us_ak = "us_ak"  # alaska
    30|     us_az = "us_az"  # arizona
    31|     us_ar = "us_ar"  # arkansas
    32|     us_ca = "us_ca"  # california
    33|     us_co = "us_co"  # colorado
    34|     us_ct = "us_ct"  # connecticut
    35|     us_de = "us_de"  # delaware
    36|     us_fl = "us_fl"  # florida
    37|     us_ga = "us_ga"  # georgia
    38|     us_hi = "us_hi"  # hawaii
    39|     us_id = "us_id"  # idaho
    40|     us_il = "us_il"  # illinois
    41|     us_in = "us_in"  # indiana
    42|     us_ia = "us_ia"  # iowa
    43|     us_ks = "us_ks"  # kansas
    44|     us_ky = "us_ky"  # kentucky
    45|     us_la = "us_la"  # louisiana
    46|     us_me = "us_me"  # maine
    47|     us_md = "us_md"  # maryland
    48|     us_ma = "us_ma"  # massachusetts
    49|     us_mi = "us_mi"  # michigan
    50|     us_mn = "us_mn"  # minnesota
    51|     us_ms = "us_ms"  # mississippi
    52|     us_mo = "us_mo"  # missouri
    53|     us_mt = "us_mt"  # montana
    54|     us_ne = "us_ne"  # nebraska
    55|     us_nv = "us_nv"  # nevada
    56|     us_nh = "us_nh"  # new hampshire
    57|     us_nj = "us_nj"  # new jersey
    58|     us_nm = "us_nm"  # new mexico
    59|     us_ny = "us_ny"  # new york
    60|     us_nc = "us_nc"  # north carolina
    61|     us_nd = "us_nd"  # north dakota
    62|     us_oh = "us_oh"  # ohio
    63|     us_ok = "us_ok"  # oklahoma
    64|     us_or = "us_or"  # oregon
    65|     us_pa = "us_pa"  # pennsylvania
    66|     us_ri = "us_ri"  # rhode island
    67|     us_sc = "us_sc"  # south carolina
    68|     us_sd = "us_sd"  # south dakota
    69|     us_tn = "us_tn"  # tennessee
    70|     us_tx = "us_tx"  # texas
    71|     us_ut = "us_ut"  # utah
    72|     us_vt = "us_vt"  # vermont
    73|     us_va = "us_va"  # virginia
    74|     us_wa = "us_wa"  # washington
    75|     us_wv = "us_wv"  # west virginia
    76|     us_wi = "us_wi"  # wisconsin
    77|     us_wy = "us_wy"  # wyoming
    78|     eu_be = "eu_be"  # belgium
    79|     eu_bg = "eu_bg"  # bulgaria
    80|     eu_cz = "eu_cz"  # czechia
    81|     eu_dk = "eu_dk"  # denmark
    82|     eu_de = "eu_de"  # germany
    83|     eu_ee = "eu_ee"  # estonia
    84|     eu_ie = "eu_ie"  # ireland
    85|     eu_el = "eu_el"  # greece
    86|     eu_es = "eu_es"  # spain
    87|     eu_fr = "eu_fr"  # france
    88|     eu_hr = "eu_hr"  # croatia
    89|     eu_it = "eu_it"  # italy
    90|     eu_cy = "eu_cy"  # cyprus
    91|     eu_lv = "eu_lv"  # latvia
    92|     eu_lt = "eu_lt"  # lithuania
    93|     eu_lu = "eu_lu"  # luxembourg
    94|     eu_hu = "eu_hu"  # hungary
    95|     eu_mt = "eu_mt"  # malta
    96|     eu_nl = "eu_nl"  # netherlands
    97|     eu_at = "eu_at"  # austria
    98|     eu_pl = "eu_pl"  # poland
    99|     eu_pt = "eu_pt"  # portugal
   100|     eu_ro = "eu_ro"  # romania
   101|     eu_si = "eu_si"  # slovenia
   102|     eu_sk = "eu_sk"  # slovakia
   103|     eu_fi = "eu_fi"  # finland
   104|     eu_se = "eu_se"  # sweden
   105|     gb_eng = "gb_eng"  # england
   106|     gb_sct = "gb_sct"  # scotland
   107|     gb_wls = "gb_wls"  # wales
   108|     gb_nir = "gb_nir"  # northern ireland
   109|     isl = "isl"  # iceland, 3 letter country code
   110|     nor = "nor"  # norway, 3 letter country code
   111|     li = "li"  # liechtenstein
   112| class ConsentMechanism(Enum):
   113|     opt_in = "opt_in"
   114|     opt_out = "opt_out"
   115|     notice_only = "notice_only"
   116| class EnforcementLevel(Enum):
   117|     """
   118|     Enum is not formalized in the DB because it may be subject to frequent change
   119|     """
   120|     frontend = "frontend"
   121|     system_wide = "system_wide"
   122|     not_applicable = "not_applicable"
   123| class PrivacyNoticeBase:
   124|     """
   125|     This class contains the common fields between PrivacyNoticeTemplate, PrivacyNotice, and PrivacyNoticeHistory
   126|     """
   127|     name = Column(String, nullable=False)
   128|     description = Column(String)  # User-facing description
   129|     internal_description = Column(String)  # Visible to internal users only
   130|     regions = Column(
   131|         ARRAY(EnumColumn(PrivacyNoticeRegion, native_enum=False)),

# --- HUNK 2: Lines 241-316 ---
   241|         data: dict[str, Any],
   242|         check_name: bool = False,
   243|     ) -> PrivacyNotice:
   244|         created = super().create(db=db, data=data, check_name=check_name)
   245|         data.pop("id", None)
   246|         history_data = {**data, "privacy_notice_id": created.id}
   247|         PrivacyNoticeHistory.create(db, data=history_data, check_name=False)
   248|         return created
   249|     def update(self, db: Session, *, data: dict[str, Any]) -> PrivacyNotice:
   250|         """
   251|         Overrides the base update method to automatically bump the version of the
   252|         PrivacyNotice record and also create a new PrivacyNoticeHistory entry
   253|         """
   254|         resource, updated = update_if_modified(self, db=db, data=data)
   255|         if updated:
   256|             history_data = create_historical_data_from_record(resource)
   257|             history_data["privacy_notice_id"] = resource.id
   258|             PrivacyNoticeHistory.create(db, data=history_data, check_name=False)
   259|         return resource  # type: ignore[return-value]
   260| PRIVACY_NOTICE_TYPE = Union[PrivacyNotice, PrivacyNoticeTemplate]
   261| def check_conflicting_data_uses(
   262|     new_privacy_notices: Iterable[PRIVACY_NOTICE_TYPE],
   263|     existing_privacy_notices: Iterable[Union[PRIVACY_NOTICE_TYPE]],
   264|     ignore_disabled: bool = True,  # For PrivacyNoticeTemplates, set to False
   265| ) -> None:
   266|     """
   267|     Checks the provided lists of potential "new" (incoming) `PrivacyNotice` records
   268|     and existing `PrivacyNotice` records for conflicts (i.e. overlaps) in DataUse specifications
   269|     within `PrivacyNoticeRegion`s associated with the `PrivacyNotice` records.
   270|     Checks are effectively performed between the new records and the existing records, as well as
   271|     between the new records themselves.
   272|     A `DataUse` conflict is considered not only an exact match in `DataUse` strings, but also a
   273|     hierarchical overlap, e.g. `DataUse`s of `advertising` and `advertising.first_party` as well as
   274|     `advertising` and `advertising.first_party.contextual` would both be considered conflicts
   275|     if they occurred in `PrivacyNotice`s that are associated with the same `PrivacyNoticeRegion`.
   276|     For templates, we don't want to ignore disabled data uses.
   277|     """
   278|     uses_by_region: Dict[PrivacyNoticeRegion, List[Tuple[str, str]]] = defaultdict(list)
   279|     for privacy_notice in existing_privacy_notices:
   280|         if privacy_notice.disabled and ignore_disabled:
   281|             continue
   282|         for region in privacy_notice.regions:
   283|             for data_use in privacy_notice.data_uses:
   284|                 uses_by_region[PrivacyNoticeRegion(region)].append(
   285|                     (data_use, privacy_notice.name)
   286|                 )
   287|     for privacy_notice in new_privacy_notices:
   288|         if privacy_notice.disabled and ignore_disabled:
   289|             continue
   290|         for region in privacy_notice.regions:
   291|             region_uses = uses_by_region[PrivacyNoticeRegion(region)]
   292|             for data_use in privacy_notice.data_uses:
   293|                 for existing_use, notice_name in region_uses:
   294|                     if new_data_use_conflicts_with_existing_use(existing_use, data_use):
   295|                         raise ValidationError(
   296|                             message=f"Privacy Notice '{notice_name}' has already assigned data use '{existing_use}' to region '{region}'"
   297|                         )
   298|                 region_uses.append((data_use, privacy_notice.name))
   299| def new_data_use_conflicts_with_existing_use(existing_use: str, new_use: str) -> bool:
   300|     """Data use check that prevents grandparent/parent/child, but allows siblings, aunt/child, etc.
   301|     Check needs to happen in both directions.
   302|     This assumes the supplied uses are on notices in the same region.
   303|     """
   304|     return existing_use.startswith(new_use) or new_use.startswith(existing_use)
   305| class PrivacyNoticeHistory(PrivacyNoticeBase, Base):
   306|     """
   307|     An "audit table" tracking outdated versions of `PrivacyNotice` records whose
   308|     "current" versions are stored in the `PrivacyNotice` table/model
   309|     """
   310|     origin = Column(
   311|         String, ForeignKey(PrivacyNoticeTemplate.id_field_path), nullable=True
   312|     )  # pointer back to the PrivacyNoticeTemplate
   313|     version = Column(Float, nullable=False, default=1.0)
   314|     privacy_notice_id = Column(
   315|         String, ForeignKey(PrivacyNotice.id_field_path), nullable=False
   316|     )


# ====================================================================
# FILE: src/fides/api/task/graph_task.py
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 19-58 ---
    19|     TraversalError,
    20| )
    21| from fides.api.graph.analytics_events import (
    22|     fideslog_graph_rerun,
    23|     prepare_rerun_graph_analytics_event,
    24| )
    25| from fides.api.graph.config import (
    26|     ROOT_COLLECTION_ADDRESS,
    27|     TERMINATOR_ADDRESS,
    28|     CollectionAddress,
    29|     Field,
    30|     FieldAddress,
    31|     FieldPath,
    32| )
    33| from fides.api.graph.graph import DatasetGraph, Edge, Node
    34| from fides.api.graph.graph_differences import format_graph_for_caching
    35| from fides.api.graph.traversal import Traversal, TraversalNode
    36| from fides.api.models.connectionconfig import AccessLevel, ConnectionConfig
    37| from fides.api.models.policy import Policy
    38| from fides.api.models.privacy_request import ExecutionLogStatus, PrivacyRequest
    39| from fides.api.schemas.policy import ActionType
    40| from fides.api.service.connectors.base_connector import BaseConnector
    41| from fides.api.task.consolidate_query_matches import consolidate_query_matches
    42| from fides.api.task.filter_element_match import filter_element_match
    43| from fides.api.task.refine_target_path import FieldPathNodeInput
    44| from fides.api.task.task_resources import TaskResources
    45| from fides.api.util.cache import get_cache
    46| from fides.api.util.collection_util import (
    47|     NodeInput,
    48|     Row,
    49|     append,
    50|     extract_key_for_address,
    51|     partition,
    52| )
    53| from fides.api.util.consent_util import add_errored_system_status_for_consent_reporting
    54| from fides.api.util.logger import Pii
    55| from fides.api.util.saas_util import FIDESOPS_GROUPED_INPUTS
    56| from fides.config import CONFIG
    57| dask.config.set(scheduler="threads")
    58| COLLECTION_FIELD_PATH_MAP = Dict[CollectionAddress, List[Tuple[FieldPath, FieldPath]]]

# --- HUNK 2: Lines 142-181 ---
   142|             )
   143|             add_errored_system_status_for_consent_reporting(
   144|                 self.resources.session,
   145|                 self.resources.request,
   146|                 self.connector.configuration,
   147|             )
   148|             raise raised_ex  # type: ignore
   149|         return result
   150|     return decorator
   151| class GraphTask(ABC):  # pylint: disable=too-many-instance-attributes
   152|     """A task that operates on one traversal_node of a traversal"""
   153|     def __init__(
   154|         self, traversal_node: TraversalNode, resources: TaskResources
   155|     ):  # cache config, log config, db store config
   156|         super().__init__()
   157|         self.traversal_node = traversal_node
   158|         self.resources = resources
   159|         self.connector: BaseConnector = resources.get_connector(
   160|             self.traversal_node.node.dataset.connection_key  # ConnectionConfig.key
   161|         )
   162|         self.incoming_edges_by_collection: Dict[
   163|             CollectionAddress, List[Edge]
   164|         ] = partition(
   165|             self.traversal_node.incoming_edges(), lambda e: e.f1.collection_address()
   166|         )
   167|         self.input_keys: List[CollectionAddress] = sorted(
   168|             self.incoming_edges_by_collection.keys()
   169|         )
   170|         self.key = self.traversal_node.address
   171|         self.execution_log_id = None
   172|     def __repr__(self) -> str:
   173|         return f"{type(self)}:{self.key}"
   174|     @property
   175|     def grouped_fields(self) -> Set[str]:
   176|         """Convenience property - returns a set of fields that have been specified on the collection as dependent
   177|         upon one another
   178|         """
   179|         return self.traversal_node.node.collection.grouped_inputs or set()
   180|     @property
   181|     def dependent_identity_fields(self) -> bool:

# --- HUNK 3: Lines 541-580 ---
   541|         if not tn.is_root_node():
   542|             data[tn.address] = GraphTask(tn, resources).generate_dry_run_query()  # type: ignore
   543|     env: Dict[CollectionAddress, str] = {}
   544|     traversal.traverse(env, collect_queries_fn)
   545|     return env
   546| def update_mapping_from_cache(
   547|     dsk: Dict[CollectionAddress, Tuple[Any, ...]],
   548|     resources: TaskResources,
   549|     start_fn: Callable,
   550| ) -> None:
   551|     """When resuming a privacy request from a paused or failed state, update the `dsk` dictionary with results we've
   552|     already obtained from a previous run. Remove upstream dependencies for these nodes, and just return the data we've
   553|     already retrieved, rather than visiting them again.
   554|     If there's no cached data, the dsk dictionary won't change.
   555|     """
   556|     cached_results: Dict[str, Optional[List[Row]]] = resources.get_all_cached_objects()
   557|     for collection_name in cached_results:
   558|         dsk[CollectionAddress.from_string(collection_name)] = (
   559|             start_fn(cached_results[collection_name]),
   560|         )
   561| def start_function(seed: List[Dict[str, Any]]) -> Callable[[], List[Dict[str, Any]]]:
   562|     """Return a function for collections with no upstream dependencies, that just start
   563|     with seed data.
   564|     This is used for root nodes or previously-visited nodes on restart."""
   565|     def g() -> List[Dict[str, Any]]:
   566|         return seed
   567|     return g
   568| async def run_access_request(
   569|     privacy_request: PrivacyRequest,
   570|     policy: Policy,
   571|     graph: DatasetGraph,
   572|     connection_configs: List[ConnectionConfig],
   573|     identity: Dict[str, Any],
   574|     session: Session,
   575| ) -> Dict[str, List[Row]]:
   576|     """Run the access request"""
   577|     traversal: Traversal = Traversal(graph, identity)
   578|     with TaskResources(
   579|         privacy_request, policy, connection_configs, session
   580|     ) as resources:

# --- HUNK 4: Lines 588-627 ---
   588|             *dependent_values: List[Row],
   589|         ) -> Dict[str, Optional[List[Row]]]:
   590|             """A termination function that just returns its inputs mapped to their source addresses.
   591|             This needs to wait for all dependent keys because this is how dask is informed to wait for
   592|             all terminating addresses before calling this."""
   593|             return resources.get_all_cached_objects()
   594|         env: Dict[CollectionAddress, Any] = {}
   595|         end_nodes = traversal.traverse(env, collect_tasks_fn)
   596|         dsk: Dict[CollectionAddress, Tuple[Any, ...]] = {
   597|             k: (t.access_request, *t.input_keys) for k, t in env.items()
   598|         }
   599|         dsk[ROOT_COLLECTION_ADDRESS] = (start_function([traversal.seed_data]),)
   600|         dsk[TERMINATOR_ADDRESS] = (termination_fn, *end_nodes)
   601|         update_mapping_from_cache(dsk, resources, start_function)
   602|         await fideslog_graph_rerun(
   603|             prepare_rerun_graph_analytics_event(
   604|                 privacy_request, env, end_nodes, resources, ActionType.access
   605|             )
   606|         )
   607|         privacy_request.cache_access_graph(format_graph_for_caching(env, end_nodes))
   608|         v = delayed(get(dsk, TERMINATOR_ADDRESS, num_workers=1))
   609|         return v.compute()
   610| def get_cached_data_for_erasures(
   611|     privacy_request_id: str,
   612| ) -> Dict[str, Any]:
   613|     """
   614|     Fetches processed access request results to be used for erasures.
   615|     Processing may have added indicators to not mask certain elements in array data.
   616|     """
   617|     cache = get_cache()
   618|     value_dict = cache.get_encoded_objects_by_prefix(
   619|         f"PLACEHOLDER_RESULTS__{privacy_request_id}"
   620|     )
   621|     number_of_leading_strings_to_exclude = 3
   622|     return {
   623|         extract_key_for_address(k, number_of_leading_strings_to_exclude): v
   624|         for k, v in value_dict.items()
   625|     }
   626| def update_erasure_mapping_from_cache(
   627|     dsk: Dict[CollectionAddress, Union[Tuple[Any, ...], int]], resources: TaskResources

