--- a/clients/admin-ui/src/features/datastore-connections/system_portal_config/forms/ConnectorParametersForm.tsx
+++ b/clients/admin-ui/src/features/datastore-connections/system_portal_config/forms/ConnectorParametersForm.tsx
@@ -6,92 +6,94 @@
   FormControl,
   FormErrorMessage,
   FormLabel,
   Input,
   isNumeric,
   NumberDecrementStepper,
   NumberIncrementStepper,
   NumberInput,
   NumberInputField,
   NumberInputStepper,
-  Textarea,
   Tooltip,
   VStack,
 } from "@fidesui/react";
 import { Option } from "common/form/inputs";
-import { useAPIHelper } from "common/hooks";
 import {
   ConnectionTypeSecretSchemaProperty,
   ConnectionTypeSecretSchemaReponse,
 } from "connection-type/types";
 import { useLazyGetDatastoreConnectionStatusQuery } from "datastore-connections/datastore-connection.slice";
 import DSRCustomizationModal from "datastore-connections/system_portal_config/forms/DSRCustomizationForm/DSRCustomizationModal";
 import { Field, FieldInputProps, Form, Formik, FormikProps } from "formik";
-import React, { useEffect, useRef } from "react";
+import React from "react";
+import { DatastoreConnectionStatus } from "src/features/datastore-connections/types";
 import DatasetConfigField from "~/features/datastore-connections/system_portal_config/forms/fields/DatasetConfigField/DatasetConfigField";
 import {
   ConnectionConfigurationResponse,
   ConnectionSystemTypeMap,
   ConnectionType,
   SystemType,
 } from "~/types/api";
 import DeleteConnectionModal from "../DeleteConnectionModal";
 import { ConnectionConfigFormValues } from "../types";
 import { fillInDefaults } from "./helpers";
 const FIDES_DATASET_REFERENCE = "#/definitions/FidesDatasetReference";
+export interface TestConnectionResponse {
+  data?: DatastoreConnectionStatus;
+  fulfilledTimeStamp?: number;
+}
 type ConnectorParametersFormProps = {
   secretsSchema?: ConnectionTypeSecretSchemaReponse;
   defaultValues: ConnectionConfigFormValues;
   isSubmitting: boolean;
   /**
    * Parent callback when Save is clicked
    */
   onSaveClick: (values: any, actions: any) => void;
   /**
    * Parent callback when Test Connection is clicked
    */
-  onTestConnectionClick: (value: any) => void;
+  onTestConnectionClick: (value: TestConnectionResponse) => void;
   /**
    * Text for the test button. Defaults to "Test connection"
    */
   testButtonLabel?: string;
   connectionConfig?: ConnectionConfigurationResponse;
   connectionOption: ConnectionSystemTypeMap;
   isCreatingConnectionConfig: boolean;
   datasetDropdownOptions: Option[];
   onDelete: (id: string) => void;
   deleteResult: any;
 };
 const ConnectorParametersForm: React.FC<ConnectorParametersFormProps> = ({
   secretsSchema,
   defaultValues,
   isSubmitting = false,
   onSaveClick,
   onTestConnectionClick,
-  testButtonLabel = "Test connection",
+  testButtonLabel = "Test integration",
   connectionOption,
   connectionConfig,
   datasetDropdownOptions,
   isCreatingConnectionConfig,
   onDelete,
   deleteResult,
 }) => {
-  const mounted = useRef(false);
-  const { handleError } = useAPIHelper();
-  const [trigger, result] = useLazyGetDatastoreConnectionStatusQuery();
+  const [trigger, { isLoading, isFetching }] =
+    useLazyGetDatastoreConnectionStatusQuery();
   const validateConnectionIdentifier = (value: string) => {
     let error;
     if (typeof value === "undefined" || value === "") {
-      error = "Connection Identifier is required";
+      error = "Integration Identifier is required";
     }
     if (value && isNumeric(value)) {
-      error = "Connection Identifier must be an alphanumeric value";
+      error = "Integration Identifier must be an alphanumeric value";
     }
     return error;
   };
   const validateField = (label: string, value: string, type?: string) => {
     let error;
     if (typeof value === "undefined" || value === "") {
       error = `${label} is required`;
     }
     if (type === FIDES_DATASET_REFERENCE) {
       if (!value.includes(".")) {
@@ -115,39 +117,43 @@
     >
       {value}
     </FormLabel>
   );
   const getPlaceholder = (item: ConnectionTypeSecretSchemaProperty) => {
     if (item.allOf?.[0].$ref === FIDES_DATASET_REFERENCE) {
       return "Enter dataset.collection.field";
     }
     return undefined;
   };
+  const isRequiredSecretValue = (key: string): boolean =>
+    secretsSchema?.required?.includes(key) ||
+    (secretsSchema?.properties?.[key] !== undefined &&
+      "default" in secretsSchema.properties[key]);
   const getFormField = (
     key: string,
     item: ConnectionTypeSecretSchemaProperty
   ): JSX.Element => (
     <Field
       id={key}
       name={key}
       key={key}
       validate={
-        secretsSchema?.required?.includes(key) || item.type === "integer"
+        isRequiredSecretValue(key) || item.type === "integer"
           ? (value: string) =>
               validateField(item.title, value, item.allOf?.[0].$ref)
           : false
       }
     >
       {({ field, form }: { field: FieldInputProps<string>; form: any }) => (
         <FormControl
           display="flex"
-          isRequired={secretsSchema?.required?.includes(key)}
+          isRequired={isRequiredSecretValue(key)}
           isInvalid={form.errors[key] && form.touched[key]}
         >
           {getFormLabel(key, item.title)}
           <VStack align="flex-start" w="inherit">
             {item.type !== "integer" && (
               <Input
                 {...field}
                 placeholder={getPlaceholder(item)}
                 autoComplete="off"
                 color="gray.700"
@@ -215,135 +221,70 @@
             dataset: referencePath.shift(),
             field: referencePath.join("."),
             direction: "from",
           };
         }
       });
     }
     onSaveClick(updatedValues, actions);
   };
   const handleTestConnectionClick = async () => {
-    try {
-      await trigger(connectionConfig!.key).unwrap();
-    } catch (error) {
-      handleError(error);
-    }
-  };
-  useEffect(() => {
-    mounted.current = true;
-    if (result.isSuccess) {
-      onTestConnectionClick(result);
-    }
-    return () => {
-      mounted.current = false;
-    };
-  }, [onTestConnectionClick, result]);
+    const result = await trigger(connectionConfig!.key);
+    onTestConnectionClick(result);
+  };
   return (
     <Formik
       enableReinitialize
       initialValues={getInitialValues()}
       onSubmit={handleSubmit}
       validateOnBlur={false}
       validateOnChange={false}
     >
       {/* @ts-ignore */}
       {(props: FormikProps<Values>) => (
         <Form noValidate>
           <VStack align="stretch" gap="16px">
-            <Field
-              id="name"
-              name="name"
-              validate={(value: string) => validateField("Name", value)}
-            >
-              {({ field }: { field: FieldInputProps<string> }) => (
-                <FormControl
-                  display="flex"
-                  isRequired
-                  isInvalid={props.errors.name && props.touched.name}
-                >
-                  {getFormLabel("name", "Name")}
-                  <VStack align="flex-start" w="inherit">
-                    <Input
-                      {...field}
-                      autoComplete="off"
-                      autoFocus
-                      color="gray.700"
-                      placeholder={`Enter a friendly name for your new ${
-                        connectionOption!.human_readable
-                      } connection`}
-                      size="sm"
-                      data-testid="input-name"
-                    />
-                    <FormErrorMessage>{props.errors.name}</FormErrorMessage>
-                  </VStack>
-                  <Flex alignItems="center" h="32px" visibility="hidden">
-                    <CircleHelpIcon marginLeft="8px" />
-                  </Flex>
-                </FormControl>
-              )}
-            </Field>
-            {/* Description */}
-            <Field id="description" name="description">
-              {({ field }: { field: FieldInputProps<string> }) => (
-                <FormControl display="flex">
-                  {getFormLabel("description", "Description")}
-                  <Textarea
-                    {...field}
-                    color="gray.700"
-                    placeholder={`Enter a description for your new ${
-                      connectionOption!.human_readable
-                    } connection`}
-                    resize="none"
-                    size="sm"
-                    value={field.value || ""}
-                  />
-                  <Flex alignItems="center" h="32px" visibility="hidden">
-                    <CircleHelpIcon marginLeft="8px" />
-                  </Flex>
-                </FormControl>
-              )}
-            </Field>
             {/* Connection Identifier */}
             {connectionOption.type !== SystemType.MANUAL ? (
               <Field
                 id="instance_key"
                 name="instance_key"
                 validate={validateConnectionIdentifier}
               >
                 {({ field }: { field: FieldInputProps<string> }) => (
                   <FormControl
                     display="flex"
                     isRequired
                     isInvalid={
                       props.errors.instance_key && props.touched.instance_key
                     }
                   >
-                    {getFormLabel("instance_key", "Connection Identifier")}
+                    {getFormLabel("instance_key", "Integration Identifier")}
                     <VStack align="flex-start" w="inherit">
                       <Input
                         {...field}
                         autoComplete="off"
                         color="gray.700"
                         isDisabled={!!connectionConfig?.key}
                         placeholder={`A unique identifier for your new ${
                           connectionOption!.human_readable
-                        } connection`}
+                        } integration`}
                         size="sm"
                       />
                       <FormErrorMessage>
                         {props.errors.instance_key}
                       </FormErrorMessage>
                     </VStack>
                     <Tooltip
-                      aria-label="The fides_key will allow fidesops to associate dataset field references appropriately. Must be a unique alphanumeric value with no spaces (underscores allowed) to represent this connection."
+                      aria-label="The fides_key will allow fidesops to associate dataset field references appropriately. Must be a unique alphanumeric value with no spaces (underscores allowed) to represent this integration."
                       hasArrow
-                      label="The fides_key will allow fidesops to associate dataset field references appropriately. Must be a unique alphanumeric value with no spaces (underscores allowed) to represent this connection."
+                      label="The fides_key will allow fidesops to associate dataset field references appropriately. Must be a unique alphanumeric value with no spaces (underscores allowed) to represent this integration."
                       placement="right-start"
                       openDelay={500}
                     >
                       <Flex alignItems="center" h="32px">
                         <CircleHelpIcon
                           marginLeft="8px"
                           _hover={{ cursor: "pointer" }}
                         />
                       </Flex>
                     </Tooltip>
@@ -368,21 +309,21 @@
               />
             ) : null}
             <ButtonGroup size="sm" spacing="8px" variant="outline">
               <Button
                 colorScheme="gray.700"
                 isDisabled={
                   !connectionConfig?.key ||
                   isSubmitting ||
                   deleteResult.isLoading
                 }
-                isLoading={result.isLoading || result.isFetching}
+                isLoading={isLoading || isFetching}
                 loadingText="Testing"
                 onClick={handleTestConnectionClick}
                 variant="outline"
               >
                 {testButtonLabel}
               </Button>
               {connectionOption.type === SystemType.MANUAL &&
               connectionConfig ? (
                 <DSRCustomizationModal connectionConfig={connectionConfig} />
               ) : null}

--- a/clients/admin-ui/src/features/datastore-connections/system_portal_config/forms/fields/DatasetConfigField/DatasetConfigField.tsx
+++ b/clients/admin-ui/src/features/datastore-connections/system_portal_config/forms/fields/DatasetConfigField/DatasetConfigField.tsx
@@ -235,21 +235,20 @@
     <Flex flexDirection="row">
       <DatasetSelect
         label="Dataset"
         labelProps={{
           fontWeight: "semibold",
           fontSize: "sm",
           minWidth: "150px",
         }}
         name={fieldName}
         options={dropdownOptions}
-        isRequired
         onOpen={onOpen}
         isLoading={isLoading}
       />
       <YamlEditorModal
         isOpen={isOpen}
         onClose={onClose}
         onChange={setDatasetYaml}
         isDatasetSelected={!!datasetDropdownOption.value}
         dataset={datasetYaml.value}
       />

--- a/clients/admin-ui/src/features/system/system.slice.ts
+++ b/clients/admin-ui/src/features/system/system.slice.ts
@@ -33,21 +33,21 @@
         body,
       }),
       invalidatesTags: () => ["Datamap", "System", "Datastore Connection"],
     }),
     deleteSystem: build.mutation<SystemDeleteResponse, string>({
       query: (key) => ({
         url: `system/${key}`,
         params: { resource_type: "system" },
         method: "DELETE",
       }),
-      invalidatesTags: ["System", "Datastore Connection"],
+      invalidatesTags: ["System", "Datastore Connection", "Privacy Notices"],
     }),
     upsertSystems: build.mutation<UpsertResponse, System[]>({
       query: (systems) => ({
         url: `/system/upsert`,
         method: "POST",
         body: systems,
       }),
       invalidatesTags: ["Datamap", "System", "Datastore Connection"],
     }),
     updateSystem: build.mutation<

--- a/clients/fides-js/src/fides.ts
+++ b/clients/fides-js/src/fides.ts
@@ -59,33 +59,35 @@
   FidesCookie,
   isNewFidesCookie,
 } from "./lib/cookie";
 import {
   PrivacyExperience,
   FidesConfig,
   FidesOptions,
   UserGeolocation,
   ConsentMethod,
   SaveConsentPreference,
+  ConsentMechanism,
 } from "./lib/consent-types";
 import {
   constructFidesRegionString,
   debugLog,
   experienceIsValid,
   transformConsentToFidesUserPreference,
   validateOptions,
 } from "./lib/consent-utils";
 import { dispatchFidesEvent } from "./lib/events";
 import { fetchExperience } from "./services/fides/api";
 import { getGeolocation } from "./services/external/geolocation";
 import { OverlayProps } from "./components/Overlay";
 import { updateConsentPreferences } from "./lib/preferences";
+import { resolveConsentValue } from "./lib/consent-value";
 export type Fides = {
   consent: CookieKeyConsent;
   experience?: PrivacyExperience;
   geolocation?: UserGeolocation;
   options: FidesOptions;
   fides_meta: CookieMeta;
   gtm: typeof gtm;
   identity: CookieIdentity;
   init: typeof init;
   initialized: boolean;
@@ -113,38 +115,51 @@
     );
   }
   return fidesRegionString;
 };
 const automaticallyApplyGPCPreferences = (
   cookie: FidesCookie,
   fidesRegionString: string | null,
   fidesApiUrl: string,
   effectiveExperience?: PrivacyExperience | null
 ) => {
-  if (!effectiveExperience) {
+  if (!effectiveExperience || !effectiveExperience.privacy_notices) {
     return;
   }
-  if (!getConsentContext().globalPrivacyControl) {
+  const context = getConsentContext();
+  if (!context.globalPrivacyControl) {
     return;
   }
-  const consentPreferencesToSave: Array<SaveConsentPreference> = [];
-  effectiveExperience.privacy_notices?.forEach((notice) => {
-    if (notice.has_gpc_flag && !notice.current_preference) {
-      consentPreferencesToSave.push(
-        new SaveConsentPreference(
+  let gpcApplied = false;
+  const consentPreferencesToSave = effectiveExperience.privacy_notices.map(
+    (notice) => {
+      if (
+        notice.has_gpc_flag &&
+        !notice.current_preference &&
+        notice.consent_mechanism !== ConsentMechanism.NOTICE_ONLY
+      ) {
+        gpcApplied = true;
+        return new SaveConsentPreference(
           notice,
           transformConsentToFidesUserPreference(false, notice.consent_mechanism)
+        );
+      }
+      return new SaveConsentPreference(
+        notice,
+        transformConsentToFidesUserPreference(
+          resolveConsentValue(notice, context),
+          notice.consent_mechanism
         )
       );
     }
-  });
-  if (consentPreferencesToSave.length > 0) {
+  );
+  if (gpcApplied) {
     updateConsentPreferences({
       consentPreferencesToSave,
       experienceId: effectiveExperience.id,
       fidesApiUrl,
       consentMethod: ConsentMethod.gpc,
       userLocationString: fidesRegionString || undefined,
       cookie,
     });
   }
 };
@@ -169,22 +184,22 @@
   );
   const hasExistingCookie = !isNewFidesCookie(cookie);
   if (hasExistingCookie) {
     _Fides.consent = cookie.consent;
     _Fides.fides_meta = cookie.fides_meta;
     _Fides.identity = cookie.identity;
     _Fides.experience = experience;
     _Fides.geolocation = geolocation;
     _Fides.options = options;
     _Fides.initialized = true;
-    dispatchFidesEvent("FidesInitialized", cookie);
-    dispatchFidesEvent("FidesUpdated", cookie);
+    dispatchFidesEvent("FidesInitialized", cookie, options.debug);
+    dispatchFidesEvent("FidesUpdated", cookie, options.debug);
   }
   let shouldInitOverlay: boolean = options.isOverlayEnabled;
   let effectiveExperience: PrivacyExperience | undefined | null = experience;
   let fidesRegionString: string | null = null;
   if (shouldInitOverlay) {
     if (!validateOptions(options)) {
       debugLog(
         options.debug,
         "Invalid overlay options. Skipping overlay initialization.",
         options
@@ -221,39 +236,39 @@
       if (shouldInitOverlay) {
         await initOverlay(<OverlayProps>{
           experience: effectiveExperience,
           fidesRegionString,
           cookie,
           options,
         }).catch(() => {});
       }
     }
   }
+  if (shouldInitOverlay) {
+    automaticallyApplyGPCPreferences(
+      cookie,
+      fidesRegionString,
+      options.fidesApiUrl,
+      effectiveExperience
+    );
+  }
   _Fides.consent = cookie.consent;
   _Fides.fides_meta = cookie.fides_meta;
   _Fides.identity = cookie.identity;
   _Fides.experience = experience;
   _Fides.geolocation = geolocation;
   _Fides.options = options;
   _Fides.initialized = true;
   if (!hasExistingCookie) {
-    dispatchFidesEvent("FidesInitialized", cookie);
-  }
-  dispatchFidesEvent("FidesUpdated", cookie);
-  if (shouldInitOverlay) {
-    automaticallyApplyGPCPreferences(
-      cookie,
-      fidesRegionString,
-      options.fidesApiUrl,
-      effectiveExperience
-    );
-  }
+    dispatchFidesEvent("FidesInitialized", cookie, options.debug);
+  }
+  dispatchFidesEvent("FidesUpdated", cookie, options.debug);
 };
 _Fides = {
   consent: {},
   experience: undefined,
   geolocation: {},
   options: {
     debug: true,
     isOverlayEnabled: false,
     isGeolocationEnabled: false,
     geolocationApiUrl: "",

--- a/clients/fides-js/src/lib/consent-types.ts
+++ b/clients/fides-js/src/lib/consent-types.ts
@@ -142,20 +142,28 @@
   email?: string;
   ga_client_id?: string;
   ljt_readerID?: string;
   fides_user_device_id?: string;
 };
 export enum RequestOrigin {
   privacy_center = "privacy_center",
   overlay = "overlay",
   api = "api",
 }
+export enum GpcStatus {
+  /** GPC is not relevant for the consent option. */
+  NONE = "none",
+  /** GPC is enabled and consent matches the configured default. */
+  APPLIED = "applied",
+  /** GPC is enabled but consent has been set to override the configured default. */
+  OVERRIDDEN = "overridden",
+}
 export type ConditionalValue = {
   value: boolean;
   globalPrivacyControl: boolean;
 };
 /**
  * A consent value can be a boolean:
  *  - `true`: consent/opt-in
  *  - `false`: revoke/opt-out
  *
  * A consent value can also be context-dependent, which means it will be decided based on

--- a/clients/fides-js/src/lib/preferences.ts
+++ b/clients/fides-js/src/lib/preferences.ts
@@ -66,12 +66,12 @@
   debugLog(debug, "Saving preferences to cookie");
   saveFidesCookie(cookie);
   consentPreferencesToSave
     .filter(
       (preference) =>
         preference.consentPreference === UserConsentPreference.OPT_OUT
     )
     .forEach((preference) => {
       removeCookiesFromBrowser(preference.notice.cookies);
     });
-  dispatchFidesEvent("FidesUpdated", cookie);
+  dispatchFidesEvent("FidesUpdated", cookie, debug);
 };

--- a/clients/fides-js/src/services/fides/api.ts
+++ b/clients/fides-js/src/services/fides/api.ts
@@ -18,27 +18,29 @@
   fidesUserDeviceId: string,
   debug: boolean
 ): Promise<PrivacyExperience | null> => {
   debugLog(
     debug,
     `Fetching experience for userId: ${fidesUserDeviceId} in location: ${userLocationString}`
   );
   const fetchOptions: RequestInit = {
     method: "GET",
     mode: "cors",
+    headers: [["Unescape-Safestr", "true"]],
   };
   const params = new URLSearchParams({
     show_disabled: "false",
     region: userLocationString,
     component: ComponentType.OVERLAY,
     has_notices: "true",
     has_config: "true",
+    systems_applicable: "true",
     fides_user_device_id: fidesUserDeviceId,
   });
   const response = await fetch(
     `${fidesApiUrl}${FidesEndpointPaths.PRIVACY_EXPERIENCE}?${params}`,
     fetchOptions
   );
   if (!response.ok) {
     debugLog(
       debug,
       "Error getting experience from Fides API, returning null. Response:",

--- a/clients/privacy-center/components/consent/NoticeDrivenConsent.tsx
+++ b/clients/privacy-center/components/consent/NoticeDrivenConsent.tsx
@@ -1,29 +1,30 @@
 import { Divider, Stack, useToast } from "@fidesui/react";
 import React, { useEffect, useMemo, useState } from "react";
 import {
   ConsentContext,
   CookieKeyConsent,
   getConsentContext,
   getOrMakeFidesCookie,
   removeCookiesFromBrowser,
   saveFidesCookie,
   transformUserPreferenceToBoolean,
+  getGpcStatusFromNotice,
+  PrivacyNotice,
 } from "fides-js";
 import { useAppSelector } from "~/app/hooks";
 import {
   selectCurrentConsentPreferences,
   selectUserRegion,
   selectPrivacyExperience,
   useUpdatePrivacyPreferencesMutation,
 } from "~/features/consent/consent.slice";
-import { getGpcStatusFromNotice } from "~/features/consent/helpers";
 import {
   ConsentMechanism,
   ConsentMethod,
   ConsentOptionCreate,
   PrivacyNoticeResponseWithUserPreferences,
   PrivacyPreferencesRequest,
   UserConsentPreference,
 } from "~/types/api";
 import { useRouter } from "next/router";
 import { inspectForBrowserIdentities } from "~/common/browser-identities";
@@ -84,21 +85,21 @@
     }
     const { privacy_notices: notices } = experience;
     if (!notices || notices.length === 0) {
       return [];
     }
     return notices.map((notice) => {
       const preference = draftPreferences[notice.privacy_notice_history_id];
       const value = transformUserPreferenceToBoolean(preference);
       const gpcStatus = getGpcStatusFromNotice({
         value,
-        notice,
+        notice: notice as PrivacyNotice,
         consentContext,
       });
       return {
         name: notice.name || "",
         description: notice.description || "",
         id: notice.id,
         historyId: notice.privacy_notice_history_id,
         highlight: false,
         url: undefined,
         value,

--- a/clients/privacy-center/cypress/e2e/consent-banner.cy.ts
+++ b/clients/privacy-center/cypress/e2e/consent-banner.cy.ts
@@ -171,21 +171,21 @@
       it("does not render banner", () => {
         cy.get("div#fides-banner").should("not.exist");
         cy.contains("button", "Accept Test").should("not.exist");
       });
       it("does not render modal link", () => {
         cy.get("#fides-modal-link").should("not.be.visible");
       });
     });
   });
   describe("when user has no saved consent cookie", () => {
-    describe("when banner is not disabled", () => {
+    describe("when overlay is enabled", () => {
       beforeEach(() => {
         cy.getCookie(CONSENT_COOKIE_NAME).should("not.exist");
         stubConfig({
           options: {
             isOverlayEnabled: true,
           },
         });
       });
       it("should render the expected HTML banner", () => {
         cy.get("div#fides-banner").within(() => {
@@ -587,20 +587,34 @@
         });
       });
       it("updates Fides consent obj", () => {
         cy.window()
           .its("Fides")
           .its("consent")
           .should("eql", {
             [PRIVACY_NOTICE_KEY_1]: false,
           });
       });
+      it("shows indicators that GPC has been applied", () => {
+        cy.get("div#fides-banner").within(() => {
+          cy.get("span").contains("Global Privacy Control Signal detected");
+        });
+        cy.get("button").contains("Manage preferences").click();
+        cy.get("div.fides-gpc-banner").contains(
+          "Global Privacy Control detected"
+        );
+        cy.get("span")
+          .contains("Test privacy notice with gpc enabled")
+          .within(() => {
+            cy.get("span").contains("Global Privacy Control applied");
+          });
+      });
     });
     describe("when GPC flag is found, and no notices apply to GPC", () => {
       beforeEach(() => {
         cy.on("window:before:load", (win) => {
           win.navigator.globalPrivacyControl = true;
         });
         stubConfig({
           experience: {
             privacy_notices: [
               mockPrivacyNotice({
@@ -618,20 +632,28 @@
           }
         });
         cy.wait("@patchPrivacyPreference", {
           requestTimeout: 500,
         }).then((xhr) => {
           assert.isNull(xhr?.response?.body);
         });
         cy.window().its("Fides").its("consent").should("eql", {});
         cy.getCookie(CONSENT_COOKIE_NAME).should("not.exist");
       });
+      it("does not show gpc indicator but does show it was detected and the info banner", () => {
+        cy.get("div.fides-gpc-banner").contains(
+          "Global Privacy Control detected"
+        );
+        cy.get("button").contains("Manage preferences").click();
+        cy.get("div.fides-gpc-banner").should("be.visible");
+        cy.get("div.fides-gpc-badge").should("not.exist");
+      });
     });
     describe("when no GPC flag is found, and notices apply to GPC", () => {
       beforeEach(() => {
         cy.on("window:before:load", (win) => {
           win.navigator.globalPrivacyControl = undefined;
         });
         cy.getCookie(CONSENT_COOKIE_NAME).should("not.exist");
         stubConfig({
           experience: {
             privacy_notices: [mockPrivacyNotice({ has_gpc_flag: true })],
@@ -644,20 +666,28 @@
             throw error;
           }
         });
         cy.wait("@patchPrivacyPreference", {
           requestTimeout: 500,
         }).then((xhr) => {
           assert.isNull(xhr?.response?.body);
         });
         cy.window().its("Fides").its("consent").should("eql", {});
         cy.getCookie(CONSENT_COOKIE_NAME).should("not.exist");
+      });
+      it("does not show any gpc indicators", () => {
+        cy.get("div#fides-banner").within(() => {
+          cy.get("span.fides-gpc-badge").should("not.exist");
+        });
+        cy.get("button").contains("Manage preferences").click();
+        cy.get("div.fides-gpc-banner").should("not.exist");
+        cy.get("div.fides-gpc-badge").should("not.exist");
       });
     });
     describe("when experience component is not an overlay", () => {
       beforeEach(() => {
         stubConfig({
           experience: {
             component: ComponentType.PRIVACY_CENTER,
           },
         });
       });
@@ -886,20 +916,31 @@
             throw error;
           }
         });
         cy.wait("@patchPrivacyPreference", {
           requestTimeout: 500,
         }).then((xhr) => {
           assert.isNull(xhr?.response?.body);
         });
         cy.window().its("Fides").its("consent").should("eql", {});
         cy.getCookie(CONSENT_COOKIE_NAME).should("not.exist");
+      });
+      it("shows gpc indicators in modal", () => {
+        cy.get("#fides-modal-link").click();
+        cy.get("div.fides-gpc-banner").contains(
+          "Global Privacy Control detected"
+        );
+        cy.get("span")
+          .contains("Test privacy notice")
+          .within(() => {
+            cy.get("span").contains("Global Privacy Control overridden");
+          });
       });
     });
     describe("when banner should not be shown but modal link element exists", () => {
       beforeEach(() => {
         stubConfig({
           experience: {
             show_banner: false,
           },
         });
       });
@@ -1322,11 +1363,66 @@
           .should("deep.equal", {
             consent: {
               data_sales: false,
               tracking: false,
               analytics: true,
             },
           });
       });
     });
   });
+  describe("gpc indicators in the modal", () => {
+    beforeEach(() => {
+      cy.on("window:before:load", (win) => {
+        win.navigator.globalPrivacyControl = true;
+      });
+    });
+    it("renders the proper gpc indicator", () => {
+      stubConfig({
+        experience: {
+          privacy_notices: [
+            mockPrivacyNotice({
+              name: "Applied",
+              notice_key: "applied",
+              has_gpc_flag: true,
+              consent_mechanism: ConsentMechanism.OPT_OUT,
+              default_preference: UserConsentPreference.OPT_IN,
+              current_preference: undefined,
+            }),
+            mockPrivacyNotice({
+              name: "Notice only",
+              notice_key: "notice_only",
+              has_gpc_flag: true,
+              consent_mechanism: ConsentMechanism.NOTICE_ONLY,
+              default_preference: UserConsentPreference.ACKNOWLEDGE,
+              current_preference: UserConsentPreference.ACKNOWLEDGE,
+            }),
+            mockPrivacyNotice({
+              name: "Overridden",
+              notice_key: "overridden",
+              has_gpc_flag: true,
+              consent_mechanism: ConsentMechanism.OPT_OUT,
+              default_preference: UserConsentPreference.OPT_IN,
+              current_preference: UserConsentPreference.OPT_IN,
+            }),
+          ],
+        },
+      });
+      cy.get("#fides-modal-link").click();
+      cy.get(".fides-notice-toggle")
+        .contains("Applied")
+        .within(() => {
+          cy.get(".fides-gpc-label").contains("applied");
+        });
+      cy.get(".fides-notice-toggle")
+        .contains("Notice only")
+        .within(() => {
+          cy.get(".fides-gpc-label").should("not.exist");
+        });
+      cy.get(".fides-notice-toggle")
+        .contains("Overridden")
+        .within(() => {
+          cy.get(".fides-gpc-label").contains("overridden");
+        });
+    });
+  });
 });

--- a/clients/privacy-center/cypress/e2e/consent-notices.cy.ts
+++ b/clients/privacy-center/cypress/e2e/consent-notices.cy.ts
@@ -101,24 +101,25 @@
             expect(consent).to.eql(expectedConsent);
             cy.window().then((win) => {
               expect(win.Fides.consent).to.eql(expectedConsent);
             });
           });
         });
       });
     });
     it("uses the device id found in an already existing cookie", () => {
       const uuid = "4fbb6edf-34f6-4717-a6f1-541fd1e5d585";
-      const now = "2023-04-28T12:00:00.000Z";
+      const createdAt = "2023-04-28T12:00:00.000Z";
+      const updatedAt = "2023-04-29T12:00:00.000Z";
       const cookie = {
         identity: { fides_user_device_id: uuid },
-        fides_meta: { version: "0.9.0", createdAt: now },
+        fides_meta: { version: "0.9.0", createdAt, updatedAt },
         consent: {},
       };
       cy.setCookie(CONSENT_COOKIE_NAME, JSON.stringify(cookie));
       cy.wait("@getExperience").then((interception) => {
         const { url } = interception.request;
         expect(url).contains(`fides_user_device_id=${uuid}`);
       });
       cy.getByTestId("save-btn").click();
       cy.wait("@patchPrivacyPreference").then((interception) => {
         const { body } = interception.request;

--- a/src/fides/api/main.py
+++ b/src/fides/api/main.py
@@ -7,41 +7,41 @@
 from logging import WARNING
 from typing import Callable, Optional
 from urllib.parse import unquote
 from fastapi import HTTPException, Request, Response, status
 from fastapi.responses import FileResponse
 from fideslog.sdk.python.event import AnalyticsEvent
 from loguru import logger
 from starlette.background import BackgroundTask
 from uvicorn import Config, Server
 import fides
-from fides.api.api.v1.endpoints.utils import API_PREFIX
 from fides.api.app_setup import (
     check_redis,
     create_fides_app,
     log_startup,
     run_database_startup,
 )
 from fides.api.common_exceptions import MalisciousUrlException
 from fides.api.middleware import handle_audit_log_resource
 from fides.api.schemas.analytics import Event, ExtraData
 from fides.api.service.privacy_request.email_batch_service import (
     initiate_scheduled_batch_email_send,
 )
 from fides.api.tasks.scheduled.scheduler import scheduler
 from fides.api.ui import (
     get_admin_index_as_response,
     get_path_to_admin_ui_file,
     get_ui_file_map,
     match_route,
     path_is_in_ui_directory,
 )
+from fides.api.util.endpoint_utils import API_PREFIX
 from fides.api.util.logger import _log_exception
 from fides.cli.utils import FIDES_ASCII_ART
 from fides.config import CONFIG, check_required_webserver_config_values
 IGNORED_AUDIT_LOG_RESOURCE_PATHS = {"/api/v1/login"}
 VERSION = fides.__version__
 app = create_fides_app()
 @app.middleware("http")
 async def dispatch_log_request(request: Request, call_next: Callable) -> Response:
     """
     HTTP Middleware that logs analytics events for each call to Fides endpoints.
@@ -123,21 +123,23 @@
     """
     Return an index.html at the root path
     """
     return get_admin_index_as_response()
 def sanitise_url_path(path: str) -> str:
     """Returns a URL path that does not contain any ../ or //"""
     path = unquote(path)
     path = os.path.normpath(path)
     for token in path.split("/"):
         if ".." in token:
-            logger.warning(f"Potentially dangerous use of URL hierarchy in path: {path}")
+            logger.warning(
+                f"Potentially dangerous use of URL hierarchy in path: {path}"
+            )
             raise MalisciousUrlException()
     return path
 @app.get("/{catchall:path}", response_class=Response, tags=["Default"])
 def read_other_paths(request: Request) -> Response:
     """
     Return related frontend files. Adapted from https://github.com/tiangolo/fastapi/issues/130
     """
     path = request.path_params["catchall"]
     logger.debug(f"Catch all path detected: {path}")
     try:

--- a/src/fides/api/models/privacy_notice.py
+++ b/src/fides/api/models/privacy_notice.py
@@ -1,121 +1,123 @@
 from __future__ import annotations
 import re
 from collections import defaultdict
 from enum import Enum
+from html import unescape
 from typing import Any, Dict, Iterable, List, Optional, Tuple, Type, Union
 from fideslang.validation import FidesKey
 from sqlalchemy import Boolean, Column
 from sqlalchemy import Enum as EnumColumn
 from sqlalchemy import Float, ForeignKey, String, or_
 from sqlalchemy.dialects.postgresql import ARRAY
 from sqlalchemy.orm import Session, relationship
 from sqlalchemy.util import hybridproperty
 from fides.api.common_exceptions import ValidationError
 from fides.api.db.base_class import Base, FidesBase
 from fides.api.models.sql_models import (  # type: ignore[attr-defined]
     Cookies,
     PrivacyDeclaration,
     System,
 )
 class UserConsentPreference(Enum):
     opt_in = "opt_in"  # The user wants to opt in to the notice
     opt_out = "opt_out"  # The user wants to opt out of the notice
     acknowledge = "acknowledge"  # The user has acknowledged this notice
-class PrivacyNoticeRegion(Enum):
-    """
-    Enum is not formalized in the DB because it is subject to frequent change
-    """
-    us_al = "us_al"  # alabama
-    us_ak = "us_ak"  # alaska
-    us_az = "us_az"  # arizona
-    us_ar = "us_ar"  # arkansas
-    us_ca = "us_ca"  # california
-    us_co = "us_co"  # colorado
-    us_ct = "us_ct"  # connecticut
-    us_de = "us_de"  # delaware
-    us_fl = "us_fl"  # florida
-    us_ga = "us_ga"  # georgia
-    us_hi = "us_hi"  # hawaii
-    us_id = "us_id"  # idaho
-    us_il = "us_il"  # illinois
-    us_in = "us_in"  # indiana
-    us_ia = "us_ia"  # iowa
-    us_ks = "us_ks"  # kansas
-    us_ky = "us_ky"  # kentucky
-    us_la = "us_la"  # louisiana
-    us_me = "us_me"  # maine
-    us_md = "us_md"  # maryland
-    us_ma = "us_ma"  # massachusetts
-    us_mi = "us_mi"  # michigan
-    us_mn = "us_mn"  # minnesota
-    us_ms = "us_ms"  # mississippi
-    us_mo = "us_mo"  # missouri
-    us_mt = "us_mt"  # montana
-    us_ne = "us_ne"  # nebraska
-    us_nv = "us_nv"  # nevada
-    us_nh = "us_nh"  # new hampshire
-    us_nj = "us_nj"  # new jersey
-    us_nm = "us_nm"  # new mexico
-    us_ny = "us_ny"  # new york
-    us_nc = "us_nc"  # north carolina
-    us_nd = "us_nd"  # north dakota
-    us_oh = "us_oh"  # ohio
-    us_ok = "us_ok"  # oklahoma
-    us_or = "us_or"  # oregon
-    us_pa = "us_pa"  # pennsylvania
-    us_ri = "us_ri"  # rhode island
-    us_sc = "us_sc"  # south carolina
-    us_sd = "us_sd"  # south dakota
-    us_tn = "us_tn"  # tennessee
-    us_tx = "us_tx"  # texas
-    us_ut = "us_ut"  # utah
-    us_vt = "us_vt"  # vermont
-    us_va = "us_va"  # virginia
-    us_wa = "us_wa"  # washington
-    us_wv = "us_wv"  # west virginia
-    us_wi = "us_wi"  # wisconsin
-    us_wy = "us_wy"  # wyoming
-    eu_be = "eu_be"  # belgium
-    eu_bg = "eu_bg"  # bulgaria
-    eu_cz = "eu_cz"  # czechia
-    eu_dk = "eu_dk"  # denmark
-    eu_de = "eu_de"  # germany
-    eu_ee = "eu_ee"  # estonia
-    eu_ie = "eu_ie"  # ireland
-    eu_el = "eu_el"  # greece
-    eu_es = "eu_es"  # spain
-    eu_fr = "eu_fr"  # france
-    eu_hr = "eu_hr"  # croatia
-    eu_it = "eu_it"  # italy
-    eu_cy = "eu_cy"  # cyprus
-    eu_lv = "eu_lv"  # latvia
-    eu_lt = "eu_lt"  # lithuania
-    eu_lu = "eu_lu"  # luxembourg
-    eu_hu = "eu_hu"  # hungary
-    eu_mt = "eu_mt"  # malta
-    eu_nl = "eu_nl"  # netherlands
-    eu_at = "eu_at"  # austria
-    eu_pl = "eu_pl"  # poland
-    eu_pt = "eu_pt"  # portugal
-    eu_ro = "eu_ro"  # romania
-    eu_si = "eu_si"  # slovenia
-    eu_sk = "eu_sk"  # slovakia
-    eu_fi = "eu_fi"  # finland
-    eu_se = "eu_se"  # sweden
-    gb_eng = "gb_eng"  # england
-    gb_sct = "gb_sct"  # scotland
-    gb_wls = "gb_wls"  # wales
-    gb_nir = "gb_nir"  # northern ireland
-    isl = "isl"  # iceland, 3 letter country code
-    nor = "nor"  # norway, 3 letter country code
-    li = "li"  # liechtenstein
+PrivacyNoticeRegion = Enum(
+    "PrivacyNoticeRegion",
+    [
+        ("us_al", "us_al"),  # alabama
+        ("us_ak", "us_ak"),  # alaska
+        ("us_az", "us_az"),  # arizona
+        ("us_ar", "us_ar"),  # arkansas
+        ("us_ca", "us_ca"),  # california
+        ("us_co", "us_co"),  # colorado
+        ("us_ct", "us_ct"),  # connecticut
+        ("us_de", "us_de"),  # delaware
+        ("us_fl", "us_fl"),  # florida
+        ("us_ga", "us_ga"),  # georgia
+        ("us_hi", "us_hi"),  # hawaii
+        ("us_id", "us_id"),  # idaho
+        ("us_il", "us_il"),  # illinois
+        ("us_in", "us_in"),  # indiana
+        ("us_ia", "us_ia"),  # iowa
+        ("us_ks", "us_ks"),  # kansas
+        ("us_ky", "us_ky"),  # kentucky
+        ("us_la", "us_la"),  # louisiana
+        ("us_me", "us_me"),  # maine
+        ("us_md", "us_md"),  # maryland
+        ("us_ma", "us_ma"),  # massachusetts
+        ("us_mi", "us_mi"),  # michigan
+        ("us_mn", "us_mn"),  # minnesota
+        ("us_ms", "us_ms"),  # mississippi
+        ("us_mo", "us_mo"),  # missouri
+        ("us_mt", "us_mt"),  # montana
+        ("us_ne", "us_ne"),  # nebraska
+        ("us_nv", "us_nv"),  # nevada
+        ("us_nh", "us_nh"),  # new hampshire
+        ("us_nj", "us_nj"),  # new jersey
+        ("us_nm", "us_nm"),  # new mexico
+        ("us_ny", "us_ny"),  # new york
+        ("us_nc", "us_nc"),  # north carolina
+        ("us_nd", "us_nd"),  # north dakota
+        ("us_oh", "us_oh"),  # ohio
+        ("us_ok", "us_ok"),  # oklahoma
+        ("us_or", "us_or"),  # oregon
+        ("us_pa", "us_pa"),  # pennsylvania
+        ("us_ri", "us_ri"),  # rhode island
+        ("us_sc", "us_sc"),  # south carolina
+        ("us_sd", "us_sd"),  # south dakota
+        ("us_tn", "us_tn"),  # tennessee
+        ("us_tx", "us_tx"),  # texas
+        ("us_ut", "us_ut"),  # utah
+        ("us_vt", "us_vt"),  # vermont
+        ("us_va", "us_va"),  # virginia
+        ("us_wa", "us_wa"),  # washington
+        ("us_wv", "us_wv"),  # west virginia
+        ("us_wi", "us_wi"),  # wisconsin
+        ("us_wy", "us_wy"),  # wyoming
+        ("be", "be"),  # belgium
+        ("bg", "bg"),  # bulgaria
+        ("cz", "cz"),  # czechia
+        ("dk", "dk"),  # denmark
+        ("de", "de"),  # germany
+        ("ee", "ee"),  # estonia
+        ("ie", "ie"),  # ireland
+        ("gr", "gr"),  # greece
+        ("es", "es"),  # spain
+        ("fr", "fr"),  # france
+        ("hr", "hr"),  # croatia
+        ("it", "it"),  # italy
+        ("cy", "cy"),  # cyprus
+        ("lv", "lv"),  # latvia
+        ("lt", "lt"),  # lithuania
+        ("lu", "lu"),  # luxembourg
+        ("hu", "hu"),  # hungary
+        ("mt", "mt"),  # malta
+        ("nl", "nl"),  # netherlands
+        ("at", "at"),  # austria
+        ("pl", "pl"),  # poland
+        ("pt", "pt"),  # portugal
+        ("ro", "ro"),  # romania
+        ("si", "si"),  # slovenia
+        ("sk", "sk"),  # slovakia
+        ("fi", "fi"),  # finland
+        ("se", "se"),  # sweden
+        ("gb_eng", "gb_eng"),  # england
+        ("gb_sct", "gb_sct"),  # scotland
+        ("gb_wls", "gb_wls"),  # wales
+        ("gb_nir", "gb_nir"),  # northern ireland
+        ("is", "is"),  # iceland
+        ("no", "no"),  # norway
+        ("li", "li"),  # liechtenstein
+    ],
+)
 class ConsentMechanism(Enum):
     opt_in = "opt_in"
     opt_out = "opt_out"
     notice_only = "notice_only"
 class EnforcementLevel(Enum):
     """
     Enum is not formalized in the DB because it may be subject to frequent change
     """
     frontend = "frontend"
     system_wide = "system_wide"
@@ -251,20 +253,49 @@
         Overrides the base update method to automatically bump the version of the
         PrivacyNotice record and also create a new PrivacyNoticeHistory entry
         """
         resource, updated = update_if_modified(self, db=db, data=data)
         if updated:
             history_data = create_historical_data_from_record(resource)
             history_data["privacy_notice_id"] = resource.id
             PrivacyNoticeHistory.create(db, data=history_data, check_name=False)
         return resource  # type: ignore[return-value]
 PRIVACY_NOTICE_TYPE = Union[PrivacyNotice, PrivacyNoticeTemplate]
+def check_conflicting_notice_keys(
+    new_privacy_notices: Iterable[PRIVACY_NOTICE_TYPE],
+    existing_privacy_notices: Iterable[Union[PRIVACY_NOTICE_TYPE]],
+    ignore_disabled: bool = True,  # For PrivacyNoticeTemplates, set to False
+) -> None:
+    """
+    Checks to see if new notice keys will conflict with any existing notice keys for a specific region
+    """
+    notice_keys_by_region: Dict[
+        PrivacyNoticeRegion, List[Tuple[str, str]]
+    ] = defaultdict(list)
+    for privacy_notice in existing_privacy_notices:
+        if privacy_notice.disabled and ignore_disabled:
+            continue
+        for region in privacy_notice.regions:
+            notice_keys_by_region[PrivacyNoticeRegion(region)].append(
+                (privacy_notice.notice_key, privacy_notice.name)
+            )
+    for privacy_notice in new_privacy_notices:
+        if privacy_notice.disabled and ignore_disabled:
+            continue
+        for region in privacy_notice.regions:
+            region_notice_keys = notice_keys_by_region[PrivacyNoticeRegion(region)]
+            for notice_key, notice_name in region_notice_keys:
+                if notice_key == privacy_notice.notice_key:
+                    raise ValidationError(
+                        message=f"Privacy Notice '{unescape(notice_name)}' has already assigned notice key '{notice_key}' to region '{region}'"
+                    )
+            region_notice_keys.append((privacy_notice.notice_key, privacy_notice.name))
 def check_conflicting_data_uses(
     new_privacy_notices: Iterable[PRIVACY_NOTICE_TYPE],
     existing_privacy_notices: Iterable[Union[PRIVACY_NOTICE_TYPE]],
     ignore_disabled: bool = True,  # For PrivacyNoticeTemplates, set to False
 ) -> None:
     """
     Checks the provided lists of potential "new" (incoming) `PrivacyNotice` records
     and existing `PrivacyNotice` records for conflicts (i.e. overlaps) in DataUse specifications
     within `PrivacyNoticeRegion`s associated with the `PrivacyNotice` records.
     Checks are effectively performed between the new records and the existing records, as well as
@@ -286,21 +317,21 @@
                 )
     for privacy_notice in new_privacy_notices:
         if privacy_notice.disabled and ignore_disabled:
             continue
         for region in privacy_notice.regions:
             region_uses = uses_by_region[PrivacyNoticeRegion(region)]
             for data_use in privacy_notice.data_uses:
                 for existing_use, notice_name in region_uses:
                     if new_data_use_conflicts_with_existing_use(existing_use, data_use):
                         raise ValidationError(
-                            message=f"Privacy Notice '{notice_name}' has already assigned data use '{existing_use}' to region '{region}'"
+                            message=f"Privacy Notice '{unescape(notice_name)}' has already assigned data use '{existing_use}' to region '{region}'"
                         )
                 region_uses.append((data_use, privacy_notice.name))
 def new_data_use_conflicts_with_existing_use(existing_use: str, new_use: str) -> bool:
     """Data use check that prevents grandparent/parent/child, but allows siblings, aunt/child, etc.
     Check needs to happen in both directions.
     This assumes the supplied uses are on notices in the same region.
     """
     return existing_use.startswith(new_use) or new_use.startswith(existing_use)
 class PrivacyNoticeHistory(PrivacyNoticeBase, Base):
     """

--- a/src/fides/api/task/graph_task.py
+++ b/src/fides/api/task/graph_task.py
@@ -29,20 +29,21 @@
     Field,
     FieldAddress,
     FieldPath,
 )
 from fides.api.graph.graph import DatasetGraph, Edge, Node
 from fides.api.graph.graph_differences import format_graph_for_caching
 from fides.api.graph.traversal import Traversal, TraversalNode
 from fides.api.models.connectionconfig import AccessLevel, ConnectionConfig
 from fides.api.models.policy import Policy
 from fides.api.models.privacy_request import ExecutionLogStatus, PrivacyRequest
+from fides.api.models.sql_models import System  # type: ignore[attr-defined]
 from fides.api.schemas.policy import ActionType
 from fides.api.service.connectors.base_connector import BaseConnector
 from fides.api.task.consolidate_query_matches import consolidate_query_matches
 from fides.api.task.filter_element_match import filter_element_match
 from fides.api.task.refine_target_path import FieldPathNodeInput
 from fides.api.task.task_resources import TaskResources
 from fides.api.util.cache import get_cache
 from fides.api.util.collection_util import (
     NodeInput,
     Row,
@@ -152,20 +153,27 @@
     """A task that operates on one traversal_node of a traversal"""
     def __init__(
         self, traversal_node: TraversalNode, resources: TaskResources
     ):  # cache config, log config, db store config
         super().__init__()
         self.traversal_node = traversal_node
         self.resources = resources
         self.connector: BaseConnector = resources.get_connector(
             self.traversal_node.node.dataset.connection_key  # ConnectionConfig.key
         )
+        self.data_uses: Set[str] = (
+            System.get_data_uses(
+                [self.connector.configuration.system], include_parents=False
+            )
+            if self.connector.configuration.system
+            else {}
+        )
         self.incoming_edges_by_collection: Dict[
             CollectionAddress, List[Edge]
         ] = partition(
             self.traversal_node.incoming_edges(), lambda e: e.f1.collection_address()
         )
         self.input_keys: List[CollectionAddress] = sorted(
             self.incoming_edges_by_collection.keys()
         )
         self.key = self.traversal_node.address
         self.execution_log_id = None
@@ -551,20 +559,38 @@
     """When resuming a privacy request from a paused or failed state, update the `dsk` dictionary with results we've
     already obtained from a previous run. Remove upstream dependencies for these nodes, and just return the data we've
     already retrieved, rather than visiting them again.
     If there's no cached data, the dsk dictionary won't change.
     """
     cached_results: Dict[str, Optional[List[Row]]] = resources.get_all_cached_objects()
     for collection_name in cached_results:
         dsk[CollectionAddress.from_string(collection_name)] = (
             start_fn(cached_results[collection_name]),
         )
+def _format_data_use_map_for_caching(
+    env: Dict[CollectionAddress, "GraphTask"]
+) -> Dict[str, Set[str]]:
+    """
+    Create a map of `Collection`s mapped to their associated `DataUse`s
+    to be stored in the cache. This is done before request execution, so that we
+    maintain the _original_ state of the graph as it's used for request execution.
+    The graph is subject to change "from underneath" the request execution runtime,
+    but we want to avoid picking up those changes in our data use map.
+    `DataUse`s are associated with a `Collection` by means of the `System`
+    that's linked to a `Collection`'s `Connection` definition.
+    Example:
+    {
+       <collection1>: {"data_use_1", "data_use_2"},
+       <collection2>: {"data_use_1"},
+    }
+    """
+    return {collection.value: g_task.data_uses for collection, g_task in env.items()}
 def start_function(seed: List[Dict[str, Any]]) -> Callable[[], List[Dict[str, Any]]]:
     """Return a function for collections with no upstream dependencies, that just start
     with seed data.
     This is used for root nodes or previously-visited nodes on restart."""
     def g() -> List[Dict[str, Any]]:
         return seed
     return g
 async def run_access_request(
     privacy_request: PrivacyRequest,
     policy: Policy,
@@ -598,20 +624,21 @@
         }
         dsk[ROOT_COLLECTION_ADDRESS] = (start_function([traversal.seed_data]),)
         dsk[TERMINATOR_ADDRESS] = (termination_fn, *end_nodes)
         update_mapping_from_cache(dsk, resources, start_function)
         await fideslog_graph_rerun(
             prepare_rerun_graph_analytics_event(
                 privacy_request, env, end_nodes, resources, ActionType.access
             )
         )
         privacy_request.cache_access_graph(format_graph_for_caching(env, end_nodes))
+        privacy_request.cache_data_use_map(_format_data_use_map_for_caching(env))
         v = delayed(get(dsk, TERMINATOR_ADDRESS, num_workers=1))
         return v.compute()
 def get_cached_data_for_erasures(
     privacy_request_id: str,
 ) -> Dict[str, Any]:
     """
     Fetches processed access request results to be used for erasures.
     Processing may have added indicators to not mask certain elements in array data.
     """
     cache = get_cache()
