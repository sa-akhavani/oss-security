# ====================================================================
# FILE: client/src/api/admin.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-20 ---
     1| import { get } from '../api/client';
     2| import { ADMIN_API } from '../config/wagtailConfig';
     3| export const getPage = (id) => {
     4|   const url = `${ADMIN_API.PAGES}${id}/`;
     5|   return get(url);
     6| };
     7| export const getPageChildren = (id, options = {}) => {
     8|   let url = `${ADMIN_API.PAGES}?child_of=${id}&for_explorer=1`;
     9|   if (options.fields) {
    10|     url += `&fields=${global.encodeURIComponent(options.fields.join(','))}`;
    11|   }
    12|   if (options.onlyWithChildren) {
    13|     url += '&has_children=1';
    14|   }
    15|   if (options.offset) {
    16|     url += `&offset=${options.offset}`;
    17|   }
    18|   url += ADMIN_API.EXTRA_CHILDREN_PARAMETERS;
    19|   return get(url);
    20| };


# ====================================================================
# FILE: client/src/components/Draftail/Tooltip/Tooltip.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-50 ---
     1| import PropTypes from 'prop-types';
     2| import React from 'react';
     3| const TOP = 'top';
     4| const LEFT = 'left';
     5| const TOP_LEFT = 'top-left';
     6| const getTooltipStyles = (target, direction) => {
     7|   const top = window.pageYOffset + target.top;
     8|   const left = window.pageXOffset + target.left;
     9|   switch (direction) {
    10|   case TOP:
    11|     return {
    12|       top: top + target.height,
    13|       left: left + target.width / 2,
    14|     };
    15|   case LEFT:
    16|     return {
    17|       top: top + target.height / 2,
    18|       left: left + target.width,
    19|     };
    20|   case TOP_LEFT:
    21|   default:
    22|     return {
    23|       top: top + target.height,
    24|       left: left,
    25|     };
    26|   }
    27| };
    28| /**
    29|  * A tooltip, with arbitrary content.
    30|  */
    31| const Tooltip = ({ target, children, direction }) => (
    32|   <div
    33|     style={getTooltipStyles(target, direction)}
    34|     className={`Tooltip Tooltip--${direction}`}
    35|     role="tooltip"
    36|   >
    37|     {children}
    38|   </div>
    39| );
    40| Tooltip.propTypes = {
    41|   target: PropTypes.shape({
    42|     top: PropTypes.number.isRequired,
    43|     left: PropTypes.number.isRequired,
    44|     width: PropTypes.number.isRequired,
    45|     height: PropTypes.number.isRequired,
    46|   }).isRequired,
    47|   direction: PropTypes.oneOf([TOP, LEFT, TOP_LEFT]).isRequired,
    48|   children: PropTypes.node.isRequired,
    49| };
    50| export default Tooltip;


# ====================================================================
# FILE: client/src/components/Draftail/blocks/EmbedBlock.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-35 ---
     1| import PropTypes from 'prop-types';
     2| import React from 'react';
     3| import { STRINGS } from '../../../config/wagtailConfig';
     4| import MediaBlock from '../blocks/MediaBlock';
     5| /**
     6|  * Editor block to display media and edit content.
     7|  */
     8| const EmbedBlock = props => {
     9|   const { entity, onRemoveEntity } = props.blockProps;
    10|   const { url, title, thumbnail } = entity.getData();
    11|   return (
    12|     <MediaBlock {...props} src={thumbnail} alt="">
    13|       {url ? (
    14|         <a
    15|           className="Tooltip__link EmbedBlock__link"
    16|           href={url}
    17|           title={url}
    18|           target="_blank"
    19|           rel="noopener noreferrer"
    20|         >
    21|           {title}
    22|         </a>
    23|       ) : null}
    24|       <button className="button button-secondary no Tooltip__button" onClick={onRemoveEntity}>
    25|         {STRINGS.DELETE}
    26|       </button>
    27|     </MediaBlock>
    28|   );
    29| };
    30| EmbedBlock.propTypes = {
    31|   blockProps: PropTypes.shape({
    32|     entity: PropTypes.object,
    33|   }).isRequired,
    34| };
    35| export default EmbedBlock;


# ====================================================================
# FILE: client/src/components/Draftail/blocks/ImageBlock.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-45 ---
     1| import PropTypes from 'prop-types';
     2| import React, { Component } from 'react';
     3| import { DraftUtils } from 'draftail';
     4| import { STRINGS } from '../../../config/wagtailConfig';
     5| import MediaBlock from '../blocks/MediaBlock';
     6| /**
     7|  * Editor block to preview and edit images.
     8|  */
     9| class ImageBlock extends Component {
    10|   constructor(props) {
    11|     super(props);
    12|     this.changeAlt = this.changeAlt.bind(this);
    13|   }
    14|   changeAlt(e) {
    15|     const { block, blockProps } = this.props;
    16|     const { editorState, onChange } = blockProps;
    17|     const data = {
    18|       alt: e.target.value,
    19|     };
    20|     onChange(DraftUtils.updateBlockEntity(editorState, block, data));
    21|   }
    22|   render() {
    23|     const { blockProps } = this.props;
    24|     const { entity, onRemoveEntity } = blockProps;
    25|     const { src, alt } = entity.getData();
    26|     const altLabel = `${STRINGS.ALT_TEXT}: “${alt || ''}”`;
    27|     return (
    28|       <MediaBlock {...this.props} src={src} alt="">
    29|         <p className="ImageBlock__alt">{altLabel}</p>
    30|         <button className="button button-secondary no Tooltip__button" onClick={onRemoveEntity}>
    31|           {STRINGS.DELETE}
    32|         </button>
    33|       </MediaBlock>
    34|     );
    35|   }
    36| }
    37| ImageBlock.propTypes = {
    38|   block: PropTypes.object.isRequired,
    39|   blockProps: PropTypes.shape({
    40|     editorState: PropTypes.object.isRequired,
    41|     entity: PropTypes.object,
    42|     onChange: PropTypes.func.isRequired,
    43|   }).isRequired,
    44| };
    45| export default ImageBlock;


# ====================================================================
# FILE: client/src/components/Draftail/blocks/MediaBlock.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-95 ---
     1| import PropTypes from 'prop-types';
     2| import React, { Component } from 'react';
     3| import { Icon } from 'draftail';
     4| import Tooltip from '../Tooltip/Tooltip';
     5| import Portal from '../../Portal/Portal';
     6| const OPTIONS_MAX_WIDTH = 300;
     7| const OPTIONS_SPACING = 70;
     8| const TOOLTIP_MAX_WIDTH = OPTIONS_MAX_WIDTH + OPTIONS_SPACING;
     9| /**
    10|  * Editor block to preview and edit images.
    11|  */
    12| class MediaBlock extends Component {
    13|   constructor(props) {
    14|     super(props);
    15|     this.state = {
    16|       showTooltipAt: null,
    17|     };
    18|     this.openTooltip = this.openTooltip.bind(this);
    19|     this.closeTooltip = this.closeTooltip.bind(this);
    20|     this.renderTooltip = this.renderTooltip.bind(this);
    21|   }
    22|   openTooltip(e) {
    23|     const trigger = e.target.closest('[data-draftail-trigger]');
    24|     if (!trigger) {
    25|       return;
    26|     }
    27|     const container = trigger.closest('[data-draftail-editor-wrapper]');
    28|     const containerRect = container.getBoundingClientRect();
    29|     const rect = trigger.getBoundingClientRect();
    30|     const maxWidth = trigger.parentNode.offsetWidth - rect.width;
    31|     this.setState({
    32|       showTooltipAt: {
    33|         container: container,
    34|         top: rect.top - containerRect.top - (document.documentElement.scrollTop || document.body.scrollTop),
    35|         left: rect.left - containerRect.left - (document.documentElement.scrollLeft || document.body.scrollLeft),
    36|         width: rect.width,
    37|         height: rect.height,
    38|         direction: maxWidth >= TOOLTIP_MAX_WIDTH ? 'left' : 'top-left',
    39|       },
    40|     });
    41|   }
    42|   closeTooltip() {
    43|     this.setState({ showTooltipAt: null });
    44|   }
    45|   renderTooltip() {
    46|     const { children } = this.props;
    47|     const { showTooltipAt } = this.state;
    48|     return (
    49|       <Portal
    50|         node={showTooltipAt.container}
    51|         onClose={this.closeTooltip}
    52|         closeOnClick
    53|         closeOnType
    54|         closeOnResize
    55|       >
    56|         <Tooltip target={showTooltipAt} direction={showTooltipAt.direction}>
    57|           <div style={{ maxWidth: OPTIONS_MAX_WIDTH }}>{children}</div>
    58|         </Tooltip>
    59|       </Portal>
    60|     );
    61|   }
    62|   render() {
    63|     const { blockProps, src, alt } = this.props;
    64|     const { showTooltipAt } = this.state;
    65|     const { entityType } = blockProps;
    66|     return (
    67|       <button
    68|         type="button"
    69|         tabIndex={-1}
    70|         className="MediaBlock"
    71|         onClick={this.openTooltip}
    72|         data-draftail-trigger
    73|       >
    74|         <span className="MediaBlock__icon-wrapper" aria-hidden>
    75|           <Icon icon={entityType.icon} className="MediaBlock__icon" />
    76|         </span>
    77|         <img className="MediaBlock__img" src={src} alt={alt} width="256" />
    78|         {showTooltipAt && this.renderTooltip()}
    79|       </button>
    80|     );
    81|   }
    82| }
    83| MediaBlock.propTypes = {
    84|   blockProps: PropTypes.shape({
    85|     entityType: PropTypes.object.isRequired,
    86|   }).isRequired,
    87|   src: PropTypes.string,
    88|   alt: PropTypes.string,
    89|   children: PropTypes.node.isRequired,
    90| };
    91| MediaBlock.defaultProps = {
    92|   src: null,
    93|   alt: '',
    94| };
    95| export default MediaBlock;


# ====================================================================
# FILE: client/src/components/Draftail/decorators/Document.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-22 ---
     1| import PropTypes from 'prop-types';
     2| import React from 'react';
     3| import Icon from '../../Icon/Icon';
     4| import TooltipEntity from '../decorators/TooltipEntity';
     5| const documentIcon = <Icon name="doc-full" />;
     6| const Document = props => {
     7|   const { entityKey, contentState } = props;
     8|   const data = contentState.getEntity(entityKey).getData();
     9|   return (
    10|     <TooltipEntity
    11|       {...props}
    12|       icon={documentIcon}
    13|       label={data.filename || ''}
    14|       url={data.url || ''}
    15|     />
    16|   );
    17| };
    18| Document.propTypes = {
    19|   entityKey: PropTypes.string.isRequired,
    20|   contentState: PropTypes.object.isRequired,
    21| };
    22| export default Document;


# ====================================================================
# FILE: client/src/components/Draftail/decorators/Link.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-46 ---
     1| import PropTypes from 'prop-types';
     2| import React from 'react';
     3| import Icon from '../../Icon/Icon';
     4| import TooltipEntity from '../decorators/TooltipEntity';
     5| const LINK_ICON = <Icon name="link" />;
     6| const MAIL_ICON = <Icon name="mail" />;
     7| const getEmailAddress = mailto => mailto.replace('mailto:', '').split('?')[0];
     8| const getDomainName = url => url.replace(/(^\w+:|^)\/\//, '').split('/')[0];
     9| export const getLinkAttributes = (data) => {
    10|   const url = data.url || '';
    11|   let icon;
    12|   let label;
    13|   if (data.id) {
    14|     icon = LINK_ICON;
    15|     label = url;
    16|   } else if (url.startsWith('mailto:')) {
    17|     icon = MAIL_ICON;
    18|     label = getEmailAddress(url);
    19|   } else {
    20|     icon = LINK_ICON;
    21|     label = getDomainName(url);
    22|   }
    23|   return {
    24|     url,
    25|     icon,
    26|     label,
    27|   };
    28| };
    29| /**
    30|  * Represents a link within the editor's content.
    31|  */
    32| const Link = props => {
    33|   const { entityKey, contentState } = props;
    34|   const data = contentState.getEntity(entityKey).getData();
    35|   return (
    36|     <TooltipEntity
    37|       {...props}
    38|       {...getLinkAttributes(data)}
    39|     />
    40|   );
    41| };
    42| Link.propTypes = {
    43|   entityKey: PropTypes.string.isRequired,
    44|   contentState: PropTypes.object.isRequired,
    45| };
    46| export default Link;


# ====================================================================
# FILE: client/src/components/Draftail/decorators/TooltipEntity.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-126 ---
     1| import PropTypes from 'prop-types';
     2| import React, { Component } from 'react';
     3| import { Icon } from 'draftail';
     4| import Tooltip from '../Tooltip/Tooltip';
     5| import Portal from '../../Portal/Portal';
     6| const shortenLabel = (label) => {
     7|   let shortened = label;
     8|   if (shortened.length > 25) {
     9|     shortened = `${shortened.slice(0, 20)}…`;
    10|   }
    11|   return shortened;
    12| };
    13| class TooltipEntity extends Component {
    14|   constructor(props) {
    15|     super(props);
    16|     this.state = {
    17|       showTooltipAt: null,
    18|     };
    19|     this.onEdit = this.onEdit.bind(this);
    20|     this.onRemove = this.onRemove.bind(this);
    21|     this.openTooltip = this.openTooltip.bind(this);
    22|     this.closeTooltip = this.closeTooltip.bind(this);
    23|   }
    24|   onEdit(e) {
    25|     const { onEdit, entityKey } = this.props;
    26|     e.preventDefault();
    27|     e.stopPropagation();
    28|     onEdit(entityKey);
    29|   }
    30|   onRemove(e) {
    31|     const { onRemove, entityKey } = this.props;
    32|     e.preventDefault();
    33|     e.stopPropagation();
    34|     onRemove(entityKey);
    35|   }
    36|   openTooltip(e) {
    37|     const trigger = e.target.closest('[data-draftail-trigger]');
    38|     if (!trigger) {
    39|       return;
    40|     }
    41|     const container = trigger.closest('[data-draftail-editor-wrapper]');
    42|     const containerRect = container.getBoundingClientRect();
    43|     const rect = trigger.getBoundingClientRect();
    44|     this.setState({
    45|       showTooltipAt: {
    46|         container: container,
    47|         top: rect.top - containerRect.top - (document.documentElement.scrollTop || document.body.scrollTop),
    48|         left: rect.left - containerRect.left - (document.documentElement.scrollLeft || document.body.scrollLeft),
    49|         width: rect.width,
    50|         height: rect.height,
    51|       },
    52|     });
    53|   }
    54|   closeTooltip() {
    55|     this.setState({ showTooltipAt: null });
    56|   }
    57|   render() {
    58|     const {
    59|       children,
    60|       icon,
    61|       label,
    62|       url,
    63|     } = this.props;
    64|     const { showTooltipAt } = this.state;
    65|     /* eslint-disable springload/jsx-a11y/interactive-supports-focus */
    66|     return (
    67|       <a
    68|         role="button"
    69|         onMouseUp={this.openTooltip}
    70|         className="TooltipEntity"
    71|         data-draftail-trigger
    72|       >
    73|         <Icon icon={icon} className="TooltipEntity__icon" />
    74|         {children}
    75|         {showTooltipAt && (
    76|           <Portal
    77|             node={showTooltipAt.container}
    78|             onClose={this.closeTooltip}
    79|             closeOnClick
    80|             closeOnType
    81|             closeOnResize
    82|           >
    83|             <Tooltip target={showTooltipAt} direction="top">
    84|               {(
    85|                 <a
    86|                   href={url}
    87|                   title={url}
    88|                   target="_blank"
    89|                   rel="noopener noreferrer"
    90|                   className="Tooltip__link"
    91|                 >
    92|                   {shortenLabel(label)}
    93|                 </a>
    94|               )}
    95|               <button
    96|                 className="button Tooltip__button"
    97|                 onClick={this.onEdit}
    98|               >
    99|                 Edit
   100|               </button>
   101|               <button
   102|                 className="button button-secondary no Tooltip__button"
   103|                 onClick={this.onRemove}
   104|               >
   105|                 Remove
   106|               </button>
   107|             </Tooltip>
   108|           </Portal>
   109|         )}
   110|       </a>
   111|     );
   112|   }
   113| }
   114| TooltipEntity.propTypes = {
   115|   entityKey: PropTypes.string.isRequired,
   116|   children: PropTypes.node.isRequired,
   117|   onEdit: PropTypes.func.isRequired,
   118|   onRemove: PropTypes.func.isRequired,
   119|   icon: PropTypes.oneOfType([
   120|     PropTypes.string.isRequired,
   121|     PropTypes.object.isRequired,
   122|   ]).isRequired,
   123|   label: PropTypes.string.isRequired,
   124|   url: PropTypes.string.isRequired,
   125| };
   126| export default TooltipEntity;


# ====================================================================
# FILE: client/src/components/Draftail/index.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-87 ---
     1| import React from 'react';
     2| import ReactDOM from 'react-dom';
     3| import { DraftailEditor } from 'draftail';
     4| import { IS_IE11, STRINGS } from '../../config/wagtailConfig';
     5| import Icon from '../Icon/Icon';
     6| export { default as Link } from './decorators/Link';
     7| export { default as Document } from './decorators/Document';
     8| export { default as ImageBlock } from './blocks/ImageBlock';
     9| export { default as EmbedBlock } from './blocks/EmbedBlock';
    10| export { default as ModalWorkflowSource } from './sources/ModalWorkflowSource';
    11| const BR_ICON = 'M.436 633.471l296.897-296.898v241.823h616.586V94.117h109.517v593.796H297.333v242.456z';
    12| /**
    13|  * Registry for client-side code of Draftail plugins.
    14|  */
    15| const PLUGINS = {};
    16| const registerPlugin = (plugin) => {
    17|   PLUGINS[plugin.type] = plugin;
    18|   return PLUGINS;
    19| };
    20| /**
    21|  * Wraps a style/block/entity type’s icon with an icon font implementation,
    22|  * so Draftail can use icon fonts in its toolbar.
    23|  */
    24| export const wrapWagtailIcon = type => {
    25|   const isIconFont = type.icon && typeof type.icon === 'string';
    26|   if (isIconFont) {
    27|     return Object.assign(type, {
    28|       icon: <Icon name={type.icon} />,
    29|     });
    30|   }
    31|   return type;
    32| };
    33| /**
    34|  * Initialises the DraftailEditor for a given field.
    35|  * @param {string} selector
    36|  * @param {Object} options
    37|  * @param {Element} currentScript
    38|  */
    39| const initEditor = (selector, options, currentScript) => {
    40|   const context = currentScript ? currentScript.parentNode : document.body;
    41|   const field = context.querySelector(selector) || document.body.querySelector(selector);
    42|   const editorWrapper = document.createElement('div');
    43|   editorWrapper.className = 'Draftail-Editor__wrapper';
    44|   editorWrapper.setAttribute('data-draftail-editor-wrapper', true);
    45|   field.parentNode.appendChild(editorWrapper);
    46|   const serialiseInputValue = rawContentState => {
    47|     field.value = JSON.stringify(rawContentState);
    48|   };
    49|   const blockTypes = options.blockTypes || [];
    50|   const inlineStyles = options.inlineStyles || [];
    51|   let entityTypes = options.entityTypes || [];
    52|   entityTypes = entityTypes.map(wrapWagtailIcon).map((type) => {
    53|     const plugin = PLUGINS[type.type];
    54|     return Object.assign({}, plugin, type);
    55|   });
    56|   const enableHorizontalRule = options.enableHorizontalRule ? {
    57|     description: STRINGS.HORIZONTAL_LINE,
    58|   } : false;
    59|   const rawContentState = JSON.parse(field.value);
    60|   const editor = (
    61|     <DraftailEditor
    62|       rawContentState={rawContentState}
    63|       onSave={serialiseInputValue}
    64|       placeholder={STRINGS.WRITE_HERE}
    65|       spellCheck={true}
    66|       enableLineBreak={{
    67|         description: STRINGS.LINE_BREAK,
    68|         icon: BR_ICON,
    69|       }}
    70|       showUndoControl={{ description: STRINGS.UNDO }}
    71|       showRedoControl={{ description: STRINGS.REDO }}
    72|       maxListNesting={4}
    73|       stripPastedStyles={IS_IE11}
    74|       {...options}
    75|       blockTypes={blockTypes.map(wrapWagtailIcon)}
    76|       inlineStyles={inlineStyles.map(wrapWagtailIcon)}
    77|       entityTypes={entityTypes}
    78|       enableHorizontalRule={enableHorizontalRule}
    79|     />
    80|   );
    81|   const draftailEditor = ReactDOM.render(editor, editorWrapper);
    82|   field.draftailEditor = draftailEditor;
    83| };
    84| export default {
    85|   initEditor,
    86|   registerPlugin,
    87| };


# ====================================================================
# FILE: client/src/components/Draftail/sources/ModalWorkflowSource.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-163 ---
     1| import PropTypes from 'prop-types';
     2| import { Component } from 'react';
     3| import { AtomicBlockUtils, Modifier, RichUtils, EditorState } from 'draft-js';
     4| import { ENTITY_TYPE } from 'draftail';
     5| import { STRINGS } from '../../../config/wagtailConfig';
     6| const $ = global.jQuery;
     7| const EMBED = 'EMBED';
     8| const DOCUMENT = 'DOCUMENT';
     9| const MUTABILITY = {};
    10| MUTABILITY[ENTITY_TYPE.LINK] = 'MUTABLE';
    11| MUTABILITY[DOCUMENT] = 'MUTABLE';
    12| MUTABILITY[ENTITY_TYPE.IMAGE] = 'IMMUTABLE';
    13| MUTABILITY[EMBED] = 'IMMUTABLE';
    14| export const getChooserConfig = (entityType, entity) => {
    15|   const chooserURL = {};
    16|   chooserURL[ENTITY_TYPE.IMAGE] = `${global.chooserUrls.imageChooser}?select_format=true`;
    17|   chooserURL[EMBED] = global.chooserUrls.embedsChooser;
    18|   chooserURL[ENTITY_TYPE.LINK] = global.chooserUrls.pageChooser;
    19|   chooserURL[DOCUMENT] = global.chooserUrls.documentChooser;
    20|   let url = chooserURL[entityType.type];
    21|   let urlParams = {};
    22|   if (entityType.type === ENTITY_TYPE.LINK) {
    23|     urlParams = {
    24|       page_type: 'wagtailcore.page',
    25|       allow_external_link: true,
    26|       allow_email_link: true,
    27|       can_choose_root: 'false',
    28|       link_text: '',
    29|     };
    30|     if (entity) {
    31|       const data = entity.getData();
    32|       if (data.id) {
    33|         url = `${global.chooserUrls.pageChooser}${data.parentId}/`;
    34|       } else if (data.url.startsWith('mailto:')) {
    35|         url = global.chooserUrls.emailLinkChooser;
    36|         urlParams.link_url = data.url.replace('mailto:', '');
    37|       } else {
    38|         url = global.chooserUrls.externalLinkChooser;
    39|         urlParams.link_url = data.url;
    40|       }
    41|     }
    42|   }
    43|   return {
    44|     url,
    45|     urlParams,
    46|   };
    47| };
    48| export const filterEntityData = (entityType, data) => {
    49|   switch (entityType.type) {
    50|   case ENTITY_TYPE.IMAGE:
    51|     return {
    52|       id: data.id,
    53|       src: data.preview.url,
    54|       alt: data.alt,
    55|       format: data.format,
    56|     };
    57|   case EMBED:
    58|     return {
    59|       embedType: data.embedType,
    60|       url: data.url,
    61|       providerName: data.providerName,
    62|       authorName: data.authorName,
    63|       thumbnail: data.thumbnail,
    64|       title: data.title,
    65|     };
    66|   case ENTITY_TYPE.LINK:
    67|     if (data.id) {
    68|       return {
    69|         url: data.url,
    70|         id: data.id,
    71|         parentId: data.parentId,
    72|       };
    73|     }
    74|     return {
    75|       url: data.url,
    76|     };
    77|   case DOCUMENT:
    78|     return {
    79|       url: data.url,
    80|       filename: data.filename,
    81|       id: data.id,
    82|     };
    83|   default:
    84|     return {};
    85|   }
    86| };
    87| /**
    88|  * Interfaces with Wagtail's ModalWorkflow to open the chooser,
    89|  * and create new content in Draft.js based on the data.
    90|  */
    91| class ModalWorkflowSource extends Component {
    92|   constructor(props) {
    93|     super(props);
    94|     this.onChosen = this.onChosen.bind(this);
    95|     this.onClose = this.onClose.bind(this);
    96|   }
    97|   componentDidMount() {
    98|     const { onClose, entityType, entity } = this.props;
    99|     const { url, urlParams } = getChooserConfig(entityType, entity);
   100|     $(document.body).on('hidden.bs.modal', this.onClose);
   101|     this.workflow = global.ModalWorkflow({
   102|       url,
   103|       urlParams,
   104|       responses: {
   105|         imageChosen: this.onChosen,
   106|         embedChosen: (_, data) => this.onChosen(data),
   107|         documentChosen: this.onChosen,
   108|         pageChosen: this.onChosen,
   109|       },
   110|       onError: () => {
   111|         window.alert(STRINGS.SERVER_ERROR);
   112|         onClose();
   113|       },
   114|     });
   115|   }
   116|   componentWillUnmount() {
   117|     this.workflow = null;
   118|     $(document.body).off('hidden.bs.modal', this.onClose);
   119|   }
   120|   onChosen(data) {
   121|     const { editorState, entityType, onComplete } = this.props;
   122|     const content = editorState.getCurrentContent();
   123|     const selection = editorState.getSelection();
   124|     const entityData = filterEntityData(entityType, data);
   125|     const mutability = MUTABILITY[entityType.type];
   126|     const contentWithEntity = content.createEntity(entityType.type, mutability, entityData);
   127|     const entityKey = contentWithEntity.getLastCreatedEntityKey();
   128|     let nextState;
   129|     if (entityType.block) {
   130|       nextState = AtomicBlockUtils.insertAtomicBlock(editorState, entityKey, ' ');
   131|     } else {
   132|       const shouldReplaceText = data.prefer_this_title_as_link_text || selection.isCollapsed();
   133|       if (shouldReplaceText) {
   134|         const newText = data.title || data.url;
   135|         const newContent = Modifier.replaceText(content, selection, newText, null, entityKey);
   136|         nextState = EditorState.push(editorState, newContent, 'insert-characters');
   137|       } else {
   138|         nextState = RichUtils.toggleLink(editorState, selection, entityKey);
   139|       }
   140|     }
   141|     this.workflow.close();
   142|     onComplete(nextState);
   143|   }
   144|   onClose(e) {
   145|     const { onClose } = this.props;
   146|     e.preventDefault();
   147|     onClose();
   148|   }
   149|   render() {
   150|     return null;
   151|   }
   152| }
   153| ModalWorkflowSource.propTypes = {
   154|   editorState: PropTypes.object.isRequired,
   155|   entityType: PropTypes.object.isRequired,
   156|   entity: PropTypes.object,
   157|   onComplete: PropTypes.func.isRequired,
   158|   onClose: PropTypes.func.isRequired,
   159| };
   160| ModalWorkflowSource.defaultProps = {
   161|   entity: null,
   162| };
   163| export default ModalWorkflowSource;


# ====================================================================
# FILE: client/src/components/Portal/Portal.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-61 ---
     1| import PropTypes from 'prop-types';
     2| import { Component } from 'react';
     3| import { createPortal } from 'react-dom';
     4| /**
     5|  * A Portal component which automatically closes itself
     6|  * when certain events happen outside.
     7|  * See https://reactjs.org/docs/portals.html.
     8|  */
     9| class Portal extends Component {
    10|   constructor(props) {
    11|     super(props);
    12|     this.portal = document.createElement('div');
    13|     this.onCloseEvent = this.onCloseEvent.bind(this);
    14|   }
    15|   onCloseEvent(e) {
    16|     const { onClose } = this.props;
    17|     if (!this.portal.contains(e.target)) {
    18|       onClose();
    19|     }
    20|   }
    21|   componentDidMount() {
    22|     const { node, onClose, closeOnClick, closeOnType, closeOnResize } = this.props;
    23|     node.appendChild(this.portal);
    24|     if (closeOnClick) {
    25|       document.addEventListener('mouseup', this.onCloseEvent);
    26|     }
    27|     if (closeOnType) {
    28|       document.addEventListener('keyup', this.onCloseEvent);
    29|     }
    30|     if (closeOnResize) {
    31|       window.addEventListener('resize', onClose);
    32|     }
    33|   }
    34|   componentWillUnmount() {
    35|     const { node, onClose } = this.props;
    36|     node.removeChild(this.portal);
    37|     document.removeEventListener('mouseup', this.onCloseEvent);
    38|     document.removeEventListener('keyup', this.onCloseEvent);
    39|     window.removeEventListener('resize', onClose);
    40|   }
    41|   render() {
    42|     const { children } = this.props;
    43|     return createPortal(children, this.portal);
    44|   }
    45| }
    46| Portal.propTypes = {
    47|   onClose: PropTypes.func.isRequired,
    48|   node: PropTypes.instanceOf(Element),
    49|   children: PropTypes.node,
    50|   closeOnClick: PropTypes.bool,
    51|   closeOnType: PropTypes.bool,
    52|   closeOnResize: PropTypes.bool,
    53| };
    54| Portal.defaultProps = {
    55|   node: document.body,
    56|   children: null,
    57|   closeOnClick: false,
    58|   closeOnType: false,
    59|   closeOnResize: false,
    60| };
    61| export default Portal;


# ====================================================================
# FILE: client/src/config/wagtailConfig.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-5 ---
     1| export const ADMIN_API = global.wagtailConfig.ADMIN_API;
     2| export const STRINGS = global.wagtailConfig.STRINGS;
     3| export const ADMIN_URLS = global.wagtailConfig.ADMIN_URLS;
     4| export const MAX_EXPLORER_PAGES = 200;
     5| export const IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;


# ====================================================================
# FILE: client/src/utils/performance.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-27 ---
     1| /* eslint-disable import/no-mutable-exports */
     2| let perfMiddleware;
     3| if (process.env.NODE_ENV !== 'production') {
     4|   /**
     5|    * Performance middleware for use with a Redux store.
     6|    * Will log the time taken by every action across all
     7|    * of the reducers of the store.
     8|    */
     9|   perfMiddleware = () => {
    10|     /* eslint-disable no-console */
    11|     const middleware = (next) => (action) => {
    12|       let result;
    13|       if (!!console.time) {
    14|         console.time(action.type);
    15|         result = next(action);
    16|         console.timeEnd(action.type);
    17|       } else {
    18|         result = next(action);
    19|       }
    20|       return result;
    21|     };
    22|     return middleware;
    23|   };
    24| }
    25| export {
    26|   perfMiddleware,
    27| };


# ====================================================================
# FILE: client/src/utils/polyfills.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-6 ---
     1| /**
     2|  * Polyfills for Wagtail's admin.
     3|  */
     4| import 'core-js/shim';
     5| import 'whatwg-fetch';
     6| import 'element-closest';


# ====================================================================
# FILE: client/webpack/base.config.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-73 ---
     1| const path = require('path');
     2| const webpack = require('webpack');
     3| const getEntryPath = (app, filename) => path.resolve('wagtail', app, 'static_src', `wagtail${app}`, 'app', filename);
     4| const getOutputPath = (app, filename) => path.join('wagtail', app, 'static', `wagtail${app}`, 'js', filename);
     5| const exposedDependencies = {
     6|   'focus-trap-react': 'FocusTrapReact',
     7|   'react': 'React',
     8|   'react-dom': 'ReactDOM',
     9|   'react-transition-group/CSSTransitionGroup': 'CSSTransitionGroup',
    10|   'draft-js': 'DraftJS',
    11| };
    12| module.exports = function exports() {
    13|   const entry = {
    14|     vendor: [
    15|       './client/src/utils/polyfills.js',
    16|     ],
    17|   };
    18|   entry[getOutputPath('admin', 'wagtailadmin')] = getEntryPath('admin', 'wagtailadmin.entry.js');
    19|   entry[getOutputPath('admin', 'draftail')] = getEntryPath('admin', 'draftail.entry.js');
    20|   return {
    21|     entry: entry,
    22|     output: {
    23|       path: path.resolve('.'),
    24|       filename: '[name].js',
    25|       publicPath: '/static/js/'
    26|     },
    27|     plugins: [
    28|       new webpack.optimize.CommonsChunkPlugin({
    29|         name: 'vendor',
    30|         filename: getOutputPath('admin', '[name].js'),
    31|         minChunks: 2,
    32|       }),
    33|     ],
    34|     resolve: {
    35|       alias: {
    36|         'wagtail-client': path.resolve('.', 'client'),
    37|       },
    38|     },
    39|     module: {
    40|       rules: [
    41|         {
    42|           test: /\.js$/,
    43|           loader: 'babel-loader',
    44|           exclude: /node_modules/,
    45|         },
    46|       ].concat(Object.keys(exposedDependencies).map((name) => {
    47|         const globalName = exposedDependencies[name];
    48|         return {
    49|           test: require.resolve(name),
    50|           use: [
    51|             {
    52|               loader: 'expose-loader',
    53|               options: globalName,
    54|             },
    55|           ],
    56|         };
    57|       }))
    58|     },
    59|     stats: {
    60|       chunks: false,
    61|       hash: false,
    62|       colors: true,
    63|       reasons: false,
    64|       version: false,
    65|       maxModules: 0,
    66|     },
    67|     node: {
    68|       fs: 'empty',
    69|       net: 'empty',
    70|       tls: 'empty',
    71|     },
    72|   };
    73| };


# ====================================================================
# FILE: docs/conf.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-49 ---
     1| import sys
     2| import os
     3| on_rtd = os.environ.get('READTHEDOCS', None) == 'True'
     4| if not on_rtd:  # only import and set the theme if we're building docs locally
     5|     import sphinx_rtd_theme
     6|     html_theme = 'sphinx_rtd_theme'
     7|     html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]
     8| sys.path.insert(0, os.path.abspath('..'))
     9| os.environ['DJANGO_SETTINGS_MODULE'] = 'wagtail.tests.settings'
    10| import django
    11| django.setup()
    12| os.environ['DATABASE_ENGINE'] = 'django.db.backends.sqlite3'
    13| extensions = [
    14|     'sphinx.ext.autodoc',
    15| ]
    16| if not on_rtd:
    17|     extensions.append('sphinxcontrib.spelling')
    18| templates_path = ['_templates']
    19| source_suffix = '.rst'
    20| master_doc = 'index'
    21| project = u'Wagtail'
    22| copyright = u'2015, Torchbox'
    23| from wagtail import __version__, VERSION
    24| version = '{}.{}'.format(VERSION[0], VERSION[1])
    25| release = __version__
    26| exclude_patterns = ['_build']
    27| pygments_style = 'sphinx'
    28| spelling_lang = 'en_GB'
    29| spelling_word_list_filename='spelling_wordlist.txt'
    30| html_logo = 'logo.png'
    31| html_static_path = ['_static']
    32| htmlhelp_basename = 'Wagtaildoc'
    33| latex_elements = {
    34| }
    35| latex_documents = [
    36|   ('index', 'Wagtail.tex', u'Wagtail Documentation',
    37|    u'Torchbox', 'manual'),
    38| ]
    39| man_pages = [
    40|     ('index', 'wagtail', u'Wagtail Documentation',
    41|      [u'Torchbox'], 1)
    42| ]
    43| texinfo_documents = [
    44|   ('index', 'Wagtail', u'Wagtail Documentation',
    45|    u'Torchbox', 'Wagtail', 'One line description of project.',
    46|    'Miscellaneous'),
    47| ]
    48| def setup(app):
    49|     app.add_stylesheet('css/custom.css')


# ====================================================================
# FILE: gulpfile.js/config.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-33 ---
     1| var path = require('path');
     2| var srcDir = 'static_src';
     3| var destDir = 'static';
     4| var App = function(dir, options) {
     5|     this.dir = dir;
     6|     this.options = options || {};
     7|     this.appName = this.options.appName || path.basename(dir);
     8|     this.sourceFiles = path.join('.', this.dir, srcDir);
     9| };
    10| App.prototype = Object.create(null);
    11| App.prototype.scssIncludePaths = function() {
    12|     return [this.sourceFiles];
    13| };
    14| App.prototype.scssSources = function() {
    15|     return path.join(this.sourceFiles, this.appName, '/scss/**/*.scss')
    16| };
    17| var apps = [
    18|     new App('wagtail/admin', {'appName': 'wagtailadmin'}),
    19|     new App('wagtail/documents', {'appName': 'wagtaildocs'}),
    20|     new App('wagtail/embeds', {'appName': 'wagtailembeds'}),
    21|     new App('wagtail/images', {'appName': 'wagtailimages'}),
    22|     new App('wagtail/snippets', {'appName': 'wagtailsnippets'}),
    23|     new App('wagtail/users', {'appName': 'wagtailusers'}),
    24|     new App('wagtail/contrib/styleguide', {'appName': 'wagtailstyleguide'}),
    25|     new App('wagtail/contrib/settings', {'appName': 'wagtailsettings'}),
    26|     new App('wagtail/contrib/modeladmin', {'appName': 'wagtailmodeladmin'}),
    27| ];
    28| module.exports = {
    29|     apps: apps,
    30|     srcDir: srcDir,
    31|     destDir: destDir,
    32|     isProduction: process.env.NODE_ENV === 'production',
    33| };


# ====================================================================
# FILE: gulpfile.js/tasks/styles.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-74 ---
     1| var path = require('path');
     2| var gulp = require('gulp');
     3| var sass = require('gulp-sass');
     4| var cssnano = require('gulp-cssnano');
     5| var sourcemaps = require('gulp-sourcemaps');
     6| var size = require('gulp-size');
     7| var config = require('../config');
     8| var autoprefixer = require('gulp-autoprefixer');
     9| var simpleCopyTask = require('../lib/simplyCopy');
    10| var normalizePath = require('../lib/normalize-path');
    11| var renameSrcToDest = require('../lib/rename-src-to-dest');
    12| var gutil = require('gulp-util');
    13| var flatten = function(arrOfArr) {
    14|     return arrOfArr.reduce(function(flat, more) {
    15|         return flat.concat(more);
    16|     }, []);
    17| };
    18| var autoprefixerConfig = {
    19|     browsers: [
    20|       'Firefox ESR',
    21|       'ie 11',
    22|       'last 2 Chrome versions',
    23|       'last 2 ChromeAndroid versions',
    24|       'last 2 Edge versions',
    25|       'last 1 Firefox version',
    26|       'last 2 iOS versions',
    27|       'last 2 Safari versions',
    28|     ],
    29|     cascade: false,
    30| };
    31| var cssnanoConfig = {
    32|     discardUnused: {
    33|         fontFace: false,
    34|     },
    35|     zindex: false,
    36| };
    37| gulp.task('styles', ['styles:sass', 'styles:css', 'styles:assets']);
    38| gulp.task('styles:assets', simpleCopyTask('css/**/!(*.css)'));
    39| gulp.task('styles:css', function() {
    40|     var sources = config.apps.map(function(app) {
    41|         return path.join(app.sourceFiles, app.appName, 'css/**/*.css');
    42|     });
    43|     return gulp.src(sources, {base: '.'})
    44|         .pipe(cssnano(cssnanoConfig))
    45|         .pipe(autoprefixer(autoprefixerConfig))
    46|         .pipe(renameSrcToDest())
    47|         .pipe(size({ title: 'Vendor CSS' }))
    48|         .pipe(gulp.dest('.'))
    49|         .on('error', gutil.log);
    50| });
    51| gulp.task('styles:sass', function () {
    52|     var includePaths = flatten(config.apps.map(function(app) { return app.scssIncludePaths(); }));
    53|     var sources = flatten(config.apps.map(function(app) { return app.scssSources(); }));
    54|     return gulp.src(sources)
    55|         .pipe(config.isProduction ? gutil.noop() : sourcemaps.init())
    56|         .pipe(sass({
    57|             errLogToConsole: true,
    58|             includePaths: includePaths,
    59|             outputStyle: 'expanded'
    60|         }).on('error', sass.logError))
    61|         .pipe(cssnano(cssnanoConfig))
    62|         .pipe(autoprefixer(autoprefixerConfig))
    63|         .pipe(size({ title: 'Wagtail CSS' }))
    64|         .pipe(config.isProduction ? gutil.noop() : sourcemaps.write())
    65|         .pipe(gulp.dest(function (file) {
    66|             return normalizePath(file.base)
    67|                 .replace(
    68|                     '/' + config.srcDir + '/',
    69|                     '/' + config.destDir + '/'
    70|                 )
    71|                 .replace('/scss/', '/css/');
    72|         }))
    73|         .on('error', gutil.log);
    74| });


# ====================================================================
# FILE: scripts/get-translator-credits.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| import subprocess
     2| import re
     3| from collections import defaultdict
     4| from io import open
     5| from babel import Locale
     6| authors_by_locale = defaultdict(set)
     7| file_listing = subprocess.Popen('find ../wagtail -iname *.po', shell=True, stdout=subprocess.PIPE)
     8| for file_listing_line in file_listing.stdout:
     9|     filename = file_listing_line.strip()
    10|     locale = re.search(r'locale/(\w+)/LC_MESSAGES', str(filename)).group(1)
    11|     if locale == 'en':
    12|         continue
    13|     with open(filename, 'rt') as f:
    14|         has_found_translators_heading = False
    15|         for line in f:
    16|             line = line.strip()
    17|             if line.startswith('#'):
    18|                 if has_found_translators_heading:
    19|                     author = re.match(r'\# (.*), [\d\-]+', line).group(1)
    20|                     authors_by_locale[locale].add(author)
    21|                 elif line.startswith('# Translators:'):
    22|                     has_found_translators_heading = True
    23|             else:
    24|                 if has_found_translators_heading:
    25|                     break
    26|                 else:
    27|                     raise Exception("No 'Translators:' heading found in %s" % filename)
    28| language_names = [
    29|     (Locale.parse(locale_string).english_name, locale_string)
    30|     for locale_string in authors_by_locale.keys()
    31| ]
    32| language_names.sort()
    33| for (language_name, locale) in language_names:
    34|     print(("%s - %s" % (language_name, locale)))
    35|     print("-----")
    36|     for author in sorted(authors_by_locale[locale]):
    37|         print(author)
    38|     print('')


# ====================================================================
# FILE: setup.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-90 ---
     1| import sys
     2| from wagtail import __version__
     3| from wagtail.utils.setup import assets, sdist, check_bdist_egg
     4| try:
     5|     from setuptools import setup, find_packages
     6| except ImportError:
     7|     from distutils.core import setup
     8| try:
     9|     import multiprocessing
    10| except ImportError:
    11|     pass
    12| install_requires = [
    13|     "Django>=1.11,<2.1",
    14|     "django-modelcluster>=4.0,<5.0",
    15|     "django-taggit>=0.22.2,<1.0",
    16|     "django-treebeard>=4.2.0,<5.0",
    17|     "djangorestframework>=3.1.3,<4.0",
    18|     "draftjs_exporter>=2.0,<2.1",
    19|     "Pillow>=2.6.1,<5.0",
    20|     "beautifulsoup4>=4.5.1,<5.0",
    21|     "html5lib>=0.999,<1",
    22|     "Unidecode>=0.04.14,<1.0",
    23|     "Willow>=1.1,<1.2",
    24|     "requests>=2.11.1,<3.0",
    25| ]
    26| testing_extras = [
    27|     'mock>=1.0.0',
    28|     'python-dateutil>=2.2',
    29|     'pytz>=2014.7',
    30|     'Pillow>=2.7.0',
    31|     'elasticsearch>=1.0.0,<3.0',
    32|     'Jinja2>=2.8,<3.0',
    33|     'boto3>=1.4,<1.5',
    34|     'freezegun>=0.3.8',
    35|     'coverage>=3.7.0',
    36|     'flake8>=2.2.0',
    37|     'isort==4.2.5',
    38|     'flake8-blind-except==0.1.1',
    39|     'flake8-print==2.0.2',
    40| ]
    41| documentation_extras = [
    42|     'pyenchant==1.6.8',
    43|     'sphinxcontrib-spelling>=2.3.0',
    44|     'Sphinx>=1.5.2',
    45|     'sphinx-autobuild>=0.6.0',
    46|     'sphinx_rtd_theme>=0.1.9',
    47| ]
    48| setup(
    49|     name='wagtail',
    50|     version=__version__,
    51|     description='A Django content management system focused on flexibility and user experience',
    52|     author='Matthew Westcott',
    53|     author_email='matthew.westcott@torchbox.com',
    54|     url='http://wagtail.io/',
    55|     packages=find_packages(),
    56|     include_package_data=True,
    57|     license='BSD',
    58|     long_description=open('README.rst').read(),
    59|     classifiers=[
    60|         'Development Status :: 5 - Production/Stable',
    61|         'Environment :: Web Environment',
    62|         'Intended Audience :: Developers',
    63|         'License :: OSI Approved :: BSD License',
    64|         'Operating System :: OS Independent',
    65|         'Programming Language :: Python',
    66|         'Programming Language :: Python :: 3',
    67|         'Programming Language :: Python :: 3.4',
    68|         'Programming Language :: Python :: 3.5',
    69|         'Programming Language :: Python :: 3.6',
    70|         'Framework :: Django',
    71|         'Framework :: Django :: 1.11',
    72|         'Framework :: Django :: 2.0',
    73|         'Topic :: Internet :: WWW/HTTP :: Site Management',
    74|     ],
    75|     install_requires=install_requires,
    76|     extras_require={
    77|         'testing': testing_extras,
    78|         'docs': documentation_extras
    79|     },
    80|     entry_points="""
    81|             [console_scripts]
    82|             wagtail=wagtail.bin.wagtail:main
    83|     """,
    84|     zip_safe=False,
    85|     cmdclass={
    86|         'sdist': sdist,
    87|         'bdist_egg': check_bdist_egg,
    88|         'assets': assets,
    89|     },
    90| )


# ====================================================================
# FILE: wagtail/__init__.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-4 ---
     1| from wagtail.utils.version import get_semver_version, get_version
     2| VERSION = (2, 0, 0, 'final', 0)
     3| __version__ = get_version(VERSION)
     4| __semver__ = get_semver_version(VERSION)


# ====================================================================
# FILE: wagtail/admin/__init__.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1 ---
     1| default_app_config = 'wagtail.admin.apps.WagtailAdminAppConfig'


# ====================================================================
# FILE: wagtail/admin/api/endpoints.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-72 ---
     1| from collections import OrderedDict
     2| from wagtail.api.v2.endpoints import PagesAPIEndpoint
     3| from wagtail.api.v2.filters import (
     4|     ChildOfFilter, DescendantOfFilter, FieldsFilter, ForExplorerFilter, OrderingFilter,
     5|     SearchFilter)
     6| from wagtail.api.v2.utils import BadRequestError, filter_page_type, page_models_from_string
     7| from wagtail.core.models import Page
     8| from .filters import HasChildrenFilter
     9| from .serializers import AdminPageSerializer
    10| class PagesAdminAPIEndpoint(PagesAPIEndpoint):
    11|     base_serializer_class = AdminPageSerializer
    12|     filter_backends = [
    13|         FieldsFilter,
    14|         ChildOfFilter,
    15|         DescendantOfFilter,
    16|         ForExplorerFilter,
    17|         HasChildrenFilter,
    18|         OrderingFilter,
    19|         SearchFilter,
    20|     ]
    21|     meta_fields = PagesAPIEndpoint.meta_fields + [
    22|         'latest_revision_created_at',
    23|         'status',
    24|         'children',
    25|         'descendants',
    26|         'parent',
    27|     ]
    28|     body_fields = PagesAPIEndpoint.body_fields + [
    29|         'admin_display_title',
    30|     ]
    31|     listing_default_fields = PagesAPIEndpoint.listing_default_fields + [
    32|         'latest_revision_created_at',
    33|         'status',
    34|         'children',
    35|         'admin_display_title',
    36|     ]
    37|     detail_only_fields = []
    38|     known_query_parameters = PagesAPIEndpoint.known_query_parameters.union([
    39|         'for_explorer',
    40|         'has_children'
    41|     ])
    42|     def get_queryset(self):
    43|         request = self.request
    44|         try:
    45|             models = page_models_from_string(request.GET.get('type', 'wagtailcore.Page'))
    46|         except (LookupError, ValueError):
    47|             raise BadRequestError("type doesn't exist")
    48|         if not models:
    49|             models = [Page]
    50|         if len(models) == 1:
    51|             queryset = models[0].objects.all()
    52|         else:
    53|             queryset = Page.objects.all()
    54|             queryset = filter_page_type(queryset, models)
    55|         queryset = queryset.exclude(depth=1).specific()
    56|         return queryset
    57|     def get_type_info(self):
    58|         types = OrderedDict()
    59|         for name, model in self.seen_types.items():
    60|             types[name] = OrderedDict([
    61|                 ('verbose_name', model._meta.verbose_name),
    62|                 ('verbose_name_plural', model._meta.verbose_name_plural),
    63|             ])
    64|         return types
    65|     def listing_view(self, request):
    66|         response = super().listing_view(request)
    67|         response.data['__types'] = self.get_type_info()
    68|         return response
    69|     def detail_view(self, request, pk):
    70|         response = super().detail_view(request, pk)
    71|         response.data['__types'] = self.get_type_info()
    72|         return response


# ====================================================================
# FILE: wagtail/admin/api/filters.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-18 ---
     1| from rest_framework.filters import BaseFilterBackend
     2| from wagtail.api.v2.utils import BadRequestError, parse_boolean
     3| class HasChildrenFilter(BaseFilterBackend):
     4|     """
     5|     Filters the queryset by checking if the pages have children or not.
     6|     This is useful when you want to get just the branches or just the leaves.
     7|     """
     8|     def filter_queryset(self, request, queryset, view):
     9|         if 'has_children' in request.GET:
    10|             try:
    11|                 has_children_filter = parse_boolean(request.GET['has_children'])
    12|             except ValueError:
    13|                 raise BadRequestError("has_children must be 'true' or 'false'")
    14|             if has_children_filter is True:
    15|                 return queryset.filter(numchild__gt=0)
    16|             else:
    17|                 return queryset.filter(numchild=0)
    18|         return queryset


# ====================================================================
# FILE: wagtail/admin/api/serializers.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-64 ---
     1| from collections import OrderedDict
     2| from rest_framework.fields import Field, ReadOnlyField
     3| from wagtail.api.v2.serializers import PageSerializer
     4| from wagtail.api.v2.utils import get_full_url
     5| from wagtail.core.models import Page
     6| def get_model_listing_url(context, model):
     7|     url_path = context['router'].get_model_listing_urlpath(model)
     8|     if url_path:
     9|         return get_full_url(context['request'], url_path)
    10| class PageStatusField(Field):
    11|     """
    12|     Serializes the "status" field.
    13|     Example:
    14|     "status": {
    15|         "status": "live",
    16|         "live": true,
    17|         "has_unpublished_changes": false
    18|     },
    19|     """
    20|     def get_attribute(self, instance):
    21|         return instance
    22|     def to_representation(self, page):
    23|         return OrderedDict([
    24|             ('status', page.status_string),
    25|             ('live', page.live),
    26|             ('has_unpublished_changes', page.has_unpublished_changes),
    27|         ])
    28| class PageChildrenField(Field):
    29|     """
    30|     Serializes the "children" field.
    31|     Example:
    32|     "children": {
    33|         "count": 1,
    34|         "listing_url": "/api/v1/pages/?child_of=2"
    35|     }
    36|     """
    37|     def get_attribute(self, instance):
    38|         return instance
    39|     def to_representation(self, page):
    40|         return OrderedDict([
    41|             ('count', page.numchild),
    42|             ('listing_url', get_model_listing_url(self.context, Page) + '?child_of=' + str(page.id)),
    43|         ])
    44| class PageDescendantsField(Field):
    45|     """
    46|     Serializes the "descendants" field.
    47|     Example:
    48|     "descendants": {
    49|         "count": 10,
    50|         "listing_url": "/api/v1/pages/?descendant_of=2"
    51|     }
    52|     """
    53|     def get_attribute(self, instance):
    54|         return instance
    55|     def to_representation(self, page):
    56|         return OrderedDict([
    57|             ('count', page.get_descendants().count()),
    58|             ('listing_url', get_model_listing_url(self.context, Page) + '?descendant_of=' + str(page.id)),
    59|         ])
    60| class AdminPageSerializer(PageSerializer):
    61|     status = PageStatusField(read_only=True)
    62|     children = PageChildrenField(read_only=True)
    63|     descendants = PageDescendantsField(read_only=True)
    64|     admin_display_title = ReadOnlyField(source='get_admin_display_title')


# ====================================================================
# FILE: wagtail/admin/api/urls.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-11 ---
     1| from django.conf.urls import url
     2| from wagtail.api.v2.router import WagtailAPIRouter
     3| from wagtail.core import hooks
     4| from .endpoints import PagesAdminAPIEndpoint
     5| admin_api = WagtailAPIRouter('wagtailadmin_api_v1')
     6| admin_api.register_endpoint('pages', PagesAdminAPIEndpoint)
     7| for fn in hooks.get_hooks('construct_admin_api'):
     8|     fn(admin_api)
     9| urlpatterns = [
    10|     url(r'^v2beta/', admin_api.urls),
    11| ]


# ====================================================================
# FILE: wagtail/admin/apps.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-6 ---
     1| from django.apps import AppConfig
     2| from . import checks  # NOQA
     3| class WagtailAdminAppConfig(AppConfig):
     4|     name = 'wagtail.admin'
     5|     label = 'wagtailadmin'
     6|     verbose_name = "Wagtail admin"


# ====================================================================
# FILE: wagtail/admin/blocks.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-3 ---
     1| import warnings
     2| from wagtail.core.blocks import *  # noqa
     3| warnings.warn("wagtail.admin.blocks has moved to wagtail.core.blocks", UserWarning, stacklevel=2)


# ====================================================================
# FILE: wagtail/admin/checks.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-55 ---
     1| import os
     2| from django.core.checks import Error, Warning, register
     3| @register()
     4| def css_install_check(app_configs, **kwargs):
     5|     errors = []
     6|     css_path = os.path.join(
     7|         os.path.dirname(__file__), 'static', 'wagtailadmin', 'css', 'normalize.css'
     8|     )
     9|     if not os.path.isfile(css_path):
    10|         error_hint = """
    11|             Most likely you are running a development (non-packaged) copy of
    12|             Wagtail and have not built the static assets -
    13|             see http://docs.wagtail.io/en/latest/contributing/developing.html
    14|             File not found: %s
    15|         """ % css_path
    16|         errors.append(
    17|             Warning(
    18|                 "CSS for the Wagtail admin is missing",
    19|                 hint=error_hint,
    20|                 id='wagtailadmin.W001',
    21|             )
    22|         )
    23|     return errors
    24| @register()
    25| def base_form_class_check(app_configs, **kwargs):
    26|     from wagtail.admin.forms import WagtailAdminPageForm
    27|     from wagtail.core.models import get_page_models
    28|     errors = []
    29|     for cls in get_page_models():
    30|         if not issubclass(cls.base_form_class, WagtailAdminPageForm):
    31|             errors.append(Error(
    32|                 "{}.base_form_class does not extend WagtailAdminPageForm".format(
    33|                     cls.__name__),
    34|                 hint="Ensure that {}.{} extends WagtailAdminPageForm".format(
    35|                     cls.base_form_class.__module__,
    36|                     cls.base_form_class.__name__),
    37|                 obj=cls,
    38|                 id='wagtailadmin.E001'))
    39|     return errors
    40| @register()
    41| def get_form_class_check(app_configs, **kwargs):
    42|     from wagtail.admin.forms import WagtailAdminPageForm
    43|     from wagtail.core.models import get_page_models
    44|     errors = []
    45|     for cls in get_page_models():
    46|         edit_handler = cls.get_edit_handler()
    47|         if not issubclass(edit_handler.get_form_class(), WagtailAdminPageForm):
    48|             errors.append(Error(
    49|                 "{cls}.get_edit_handler().get_form_class() does not extend WagtailAdminPageForm".format(
    50|                     cls=cls.__name__),
    51|                 hint="Ensure that the EditHandler for {cls} creates a subclass of WagtailAdminPageForm".format(
    52|                     cls=cls.__name__),
    53|                 obj=cls,
    54|                 id='wagtailadmin.E002'))
    55|     return errors


# ====================================================================
# FILE: wagtail/admin/compare.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-372 ---
     1| import difflib
     2| from bs4 import BeautifulSoup
     3| from django.utils.encoding import force_text
     4| from django.utils.html import escape
     5| from django.utils.safestring import mark_safe
     6| from django.utils.text import capfirst
     7| from django.utils.translation import ugettext_lazy as _
     8| class FieldComparison:
     9|     is_field = True
    10|     is_child_relation = False
    11|     def __init__(self, field, obj_a, obj_b):
    12|         self.field = field
    13|         self.val_a = field.value_from_object(obj_a)
    14|         self.val_b = field.value_from_object(obj_b)
    15|     def field_label(self):
    16|         """
    17|         Returns a label for this field to be displayed to the user
    18|         """
    19|         verbose_name = getattr(self.field, 'verbose_name', None)
    20|         if verbose_name is None:
    21|             verbose_name = self.field.name.replace('_', ' ')
    22|         return capfirst(verbose_name)
    23|     def htmldiff(self):
    24|         if self.val_a != self.val_b:
    25|             return TextDiff([('deletion', self.val_a), ('addition', self.val_b)]).to_html()
    26|         else:
    27|             return escape(self.val_a)
    28|     def has_changed(self):
    29|         """
    30|         Returns True if the field has changed
    31|         """
    32|         return self.val_a != self.val_b
    33| class TextFieldComparison(FieldComparison):
    34|     def htmldiff(self):
    35|         return diff_text(self.val_a, self.val_b).to_html()
    36| class RichTextFieldComparison(TextFieldComparison):
    37|     def htmldiff(self):
    38|         return diff_text(
    39|             BeautifulSoup(force_text(self.val_a), 'html5lib').getText(),
    40|             BeautifulSoup(force_text(self.val_b), 'html5lib').getText()
    41|         ).to_html()
    42| class StreamFieldComparison(RichTextFieldComparison):
    43|     pass
    44| class ChoiceFieldComparison(FieldComparison):
    45|     def htmldiff(self):
    46|         val_a = force_text(dict(self.field.flatchoices).get(self.val_a, self.val_a), strings_only=True)
    47|         val_b = force_text(dict(self.field.flatchoices).get(self.val_b, self.val_b), strings_only=True)
    48|         if self.val_a != self.val_b:
    49|             return TextDiff([('deletion', val_a), ('addition', val_b)]).to_html()
    50|         else:
    51|             return escape(val_a)
    52| class M2MFieldComparison(FieldComparison):
    53|     def get_items(self):
    54|         return list(self.val_a), list(self.val_b)
    55|     def get_item_display(self, item):
    56|         return str(item)
    57|     def htmldiff(self):
    58|         items_a, items_b = self.get_items()
    59|         sm = difflib.SequenceMatcher(0, items_a, items_b)
    60|         changes = []
    61|         for op, i1, i2, j1, j2 in sm.get_opcodes():
    62|             if op == 'replace':
    63|                 for item in items_a[i1:i2]:
    64|                     changes.append(('deletion', self.get_item_display(item)))
    65|                 for item in items_b[j1:j2]:
    66|                     changes.append(('addition', self.get_item_display(item)))
    67|             elif op == 'delete':
    68|                 for item in items_a[i1:i2]:
    69|                     changes.append(('deletion', self.get_item_display(item)))
    70|             elif op == 'insert':
    71|                 for item in items_b[j1:j2]:
    72|                     changes.append(('addition', self.get_item_display(item)))
    73|             elif op == 'equal':
    74|                 for item in items_a[i1:i2]:
    75|                     changes.append(('equal', self.get_item_display(item)))
    76|         return TextDiff(changes, separator=", ").to_html()
    77|     def has_changed(self):
    78|         items_a, items_b = self.get_items()
    79|         return items_a != items_b
    80| class TagsFieldComparison(M2MFieldComparison):
    81|     def get_items(self):
    82|         tags_a = [
    83|             tag.tag
    84|             for tag in self.val_a
    85|         ]
    86|         tags_b = [
    87|             tag.tag
    88|             for tag in self.val_b
    89|         ]
    90|         return tags_a, tags_b
    91|     def get_item_display(self, tag):
    92|         return tag.slug
    93| class ForeignObjectComparison(FieldComparison):
    94|     def get_objects(self):
    95|         model = self.field.related_model
    96|         obj_a = model.objects.filter(id=self.val_a).first()
    97|         obj_b = model.objects.filter(id=self.val_b).first()
    98|         return obj_a, obj_b
    99|     def htmldiff(self):
   100|         obj_a, obj_b = self.get_objects()
   101|         if obj_a != obj_b:
   102|             if obj_a and obj_b:
   103|                 return TextDiff([('deletion', force_text(obj_a)), ('addition', force_text(obj_b))]).to_html()
   104|             elif obj_b:
   105|                 return TextDiff([('addition', force_text(obj_b))]).to_html()
   106|             elif obj_a:
   107|                 return TextDiff([('deletion', force_text(obj_a))]).to_html()
   108|         else:
   109|             if obj_a:
   110|                 return escape(force_text(obj_a))
   111|             else:
   112|                 return mark_safe(_("None"))
   113| class ChildRelationComparison:
   114|     is_field = False
   115|     is_child_relation = True
   116|     def __init__(self, field, field_comparisons, obj_a, obj_b):
   117|         self.field = field
   118|         self.field_comparisons = field_comparisons
   119|         self.val_a = getattr(obj_a, field.related_name)
   120|         self.val_b = getattr(obj_b, field.related_name)
   121|     def field_label(self):
   122|         """
   123|         Returns a label for this field to be displayed to the user
   124|         """
   125|         verbose_name = getattr(self.field, 'verbose_name', None)
   126|         if verbose_name is None:
   127|             verbose_name = self.field.name.replace('_', ' ')
   128|         return capfirst(verbose_name)
   129|     def get_mapping(self, objs_a, objs_b):
   130|         """
   131|         This bit of code attempts to match the objects in the A revision with
   132|         their counterpart in the B revision.
   133|         A match is firstly attempted by PK (where a matching ID indicates they're the same).
   134|         We compare remaining the objects by their field data; the objects with the fewest
   135|         fields changed are matched until there are no more possible matches left.
   136|         This returns 4 values:
   137|          - map_forwards => a mapping of object indexes from the B version to the A version
   138|          - map_backwards => a mapping of object indexes from the A version to the B version
   139|          - added => a list of indices for objects that didn't exist in the B version
   140|          - deleted => a list of indices for objects that didn't exist in the A version
   141|         Note the indices are 0-based array indices indicating the location of the object in either
   142|         the objs_a or objs_b arrays.
   143|         For example:
   144|         objs_a => A, B, C, D
   145|         objs_b => B, C, D, E
   146|         Will return the following:
   147|         map_forwards = {
   148|             1: 0,  # B (objs_a: objs_b)
   149|             2: 1,  # C (objs_a: objs_b)
   150|             3: 2,  # D (objs_a: objs_b)
   151|         }
   152|         map_backwards = {
   153|             0: 1,  # B (objs_b: objs_a)
   154|             1: 2,  # C (objs_b: objs_a)
   155|             2: 3,  # D (objs_b: objs_a)
   156|         }
   157|         added = [4]  # D in objs_b
   158|         deleted = [0]  # A in objs_a
   159|         """
   160|         map_forwards = {}
   161|         map_backwards = {}
   162|         added = []
   163|         deleted = []
   164|         for a_idx, a_child in enumerate(objs_a):
   165|             for b_idx, b_child in enumerate(objs_b):
   166|                 if b_idx in map_backwards:
   167|                     continue
   168|                 if a_child.pk is not None and b_child.pk is not None and a_child.pk == b_child.pk:
   169|                     map_forwards[a_idx] = b_idx
   170|                     map_backwards[b_idx] = a_idx
   171|         matches = []
   172|         for a_idx, a_child in enumerate(objs_a):
   173|             if a_idx not in map_forwards:
   174|                 for b_idx, b_child in enumerate(objs_b):
   175|                     if b_idx not in map_backwards:
   176|                         if a_child.pk and b_child.pk and a_child.pk != b_child.pk:
   177|                             continue
   178|                         comparison = self.get_child_comparison(objs_a[a_idx], objs_b[b_idx])
   179|                         num_differences = comparison.get_num_differences()
   180|                         matches.append((a_idx, b_idx, num_differences))
   181|         matches.sort(key=lambda match: match[2])
   182|         for a_idx, b_idx, num_differences in matches:
   183|             if a_idx in map_forwards or b_idx in map_backwards:
   184|                 continue
   185|             map_forwards[a_idx] = b_idx
   186|             map_backwards[b_idx] = a_idx
   187|         for a_idx, a_child in enumerate(objs_a):
   188|             if a_idx not in map_forwards:
   189|                 deleted.append(a_idx)
   190|         for b_idx, b_child in enumerate(objs_b):
   191|             if b_idx not in map_backwards:
   192|                 added.append(b_idx)
   193|         return map_forwards, map_backwards, added, deleted
   194|     def get_child_comparison(self, obj_a, obj_b):
   195|         return ChildObjectComparison(self.field.related_model, self.field_comparisons, obj_a, obj_b)
   196|     def get_child_comparisons(self):
   197|         """
   198|         Returns a list of ChildObjectComparison objects. Representing all child
   199|         objects that existed in either version.
   200|         They are returned in the order they appear in the B version with deletions
   201|         appended at the end.
   202|         All child objects are returned, regardless of whether they were actually changed.
   203|         """
   204|         objs_a = list(self.val_a.all())
   205|         objs_b = list(self.val_b.all())
   206|         map_forwards, map_backwards, added, deleted = self.get_mapping(objs_a, objs_b)
   207|         objs_a = dict(enumerate(objs_a))
   208|         objs_b = dict(enumerate(objs_b))
   209|         comparisons = []
   210|         for b_idx, b_child in objs_b.items():
   211|             if b_idx in added:
   212|                 comparisons.append(self.get_child_comparison(None, b_child))
   213|             else:
   214|                 comparisons.append(self.get_child_comparison(objs_a[map_backwards[b_idx]], b_child))
   215|         for a_idx, a_child in objs_a.items():
   216|             if a_idx in deleted:
   217|                 comparisons.append(self.get_child_comparison(a_child, None))
   218|         return comparisons
   219|     def has_changed(self):
   220|         """
   221|         Returns true if any changes were made to any of the child objects. This includes
   222|         adding, deleting and reordering.
   223|         """
   224|         objs_a = list(self.val_a.all())
   225|         objs_b = list(self.val_b.all())
   226|         map_forwards, map_backwards, added, deleted = self.get_mapping(objs_a, objs_b)
   227|         if added or deleted:
   228|             return True
   229|         for a_idx, b_idx in map_forwards.items():
   230|             comparison = self.get_child_comparison(objs_a[a_idx], objs_b[b_idx])
   231|             if comparison.has_changed():
   232|                 return True
   233|         return False
   234| class ChildObjectComparison:
   235|     def __init__(self, model, field_comparisons, obj_a, obj_b):
   236|         self.model = model
   237|         self.field_comparisons = field_comparisons
   238|         self.obj_a = obj_a
   239|         self.obj_b = obj_b
   240|     def is_addition(self):
   241|         """
   242|         Returns True if this child object was created since obj_a
   243|         """
   244|         return self.obj_b and not self.obj_a
   245|     def is_deletion(self):
   246|         """
   247|         Returns True if this child object was deleted in obj_b
   248|         """
   249|         return self.obj_a and not self.obj_b
   250|     def get_position_change(self):
   251|         """
   252|         Returns the change in position as an integer. Positive if the object
   253|         was moved down, negative if it moved up.
   254|         For example: '3' indicates the object moved down three spaces. '-1'
   255|         indicates the object moved up one space.
   256|         """
   257|         if not self.is_addition() and not self.is_deletion():
   258|             sort_a = getattr(self.obj_a, 'sort_order', 0) or 0
   259|             sort_b = getattr(self.obj_b, 'sort_order', 0) or 0
   260|             return sort_b - sort_a
   261|     def get_field_comparisons(self):
   262|         """
   263|         Returns a list of comparisons for all the fields in this object.
   264|         Fields that haven't changed are included as well.
   265|         """
   266|         comparisons = []
   267|         if self.is_addition() or self.is_deletion():
   268|             obj = self.obj_a or self.obj_b
   269|             for field_comparison in self.field_comparisons:
   270|                 comparisons.append(field_comparison(obj, obj))
   271|         else:
   272|             for field_comparison in self.field_comparisons:
   273|                 comparisons.append(field_comparison(self.obj_a, self.obj_b))
   274|         return comparisons
   275|     def has_changed(self):
   276|         for comparison in self.get_field_comparisons():
   277|             if comparison.has_changed():
   278|                 return True
   279|         return False
   280|     def get_num_differences(self):
   281|         """
   282|         Returns the number of fields that differ between the two
   283|         objects.
   284|         """
   285|         num_differences = 0
   286|         for comparison in self.get_field_comparisons():
   287|             if comparison.has_changed():
   288|                 num_differences += 1
   289|         return num_differences
   290| class TextDiff:
   291|     def __init__(self, changes, separator=""):
   292|         self.changes = changes
   293|         self.separator = separator
   294|     def to_html(self, tag='span', addition_class='addition', deletion_class='deletion'):
   295|         html = []
   296|         for change_type, value in self.changes:
   297|             if change_type == 'equal':
   298|                 html.append(escape(value))
   299|             elif change_type == 'addition':
   300|                 html.append('<{tag} class="{classname}">{value}</{tag}>'.format(
   301|                     tag=tag,
   302|                     classname=addition_class,
   303|                     value=escape(value)
   304|                 ))
   305|             elif change_type == 'deletion':
   306|                 html.append('<{tag} class="{classname}">{value}</{tag}>'.format(
   307|                     tag=tag,
   308|                     classname=deletion_class,
   309|                     value=escape(value)
   310|                 ))
   311|         return mark_safe(self.separator.join(html))
   312| def diff_text(a, b):
   313|     """
   314|     Performs a diffing algorithm on two pieces of text. Returns
   315|     a string of HTML containing the content of both texts with
   316|     <span> tags inserted indicating where the differences are.
   317|     """
   318|     def tokenise(text):
   319|         """
   320|         Tokenises a string by spliting it into individual characters
   321|         and grouping the alphanumeric ones together.
   322|         This means that punctuation, whitespace, CJK characters, etc
   323|         become separate tokens and words/numbers are merged together
   324|         to form bigger tokens.
   325|         This makes the output of the diff easier to read as words are
   326|         not broken up.
   327|         """
   328|         tokens = []
   329|         current_token = ""
   330|         for c in text:
   331|             if c.isalnum():
   332|                 current_token += c
   333|             else:
   334|                 if current_token:
   335|                     tokens.append(current_token)
   336|                     current_token = ""
   337|                 tokens.append(c)
   338|         if current_token:
   339|             tokens.append(current_token)
   340|         return tokens
   341|     a_tok = tokenise(a)
   342|     b_tok = tokenise(b)
   343|     sm = difflib.SequenceMatcher(lambda t: len(t) <= 4, a_tok, b_tok)
   344|     changes = []
   345|     for op, i1, i2, j1, j2 in sm.get_opcodes():
   346|         if op == 'replace':
   347|             for token in a_tok[i1:i2]:
   348|                 changes.append(('deletion', token))
   349|             for token in b_tok[j1:j2]:
   350|                 changes.append(('addition', token))
   351|         elif op == 'delete':
   352|             for token in a_tok[i1:i2]:
   353|                 changes.append(('deletion', token))
   354|         elif op == 'insert':
   355|             for token in b_tok[j1:j2]:
   356|                 changes.append(('addition', token))
   357|         elif op == 'equal':
   358|             for token in a_tok[i1:i2]:
   359|                 changes.append(('equal', token))
   360|     merged_changes = []
   361|     current_value = []
   362|     current_change_type = None
   363|     for change_type, value in changes:
   364|         if change_type != current_change_type:
   365|             if current_change_type is not None:
   366|                 merged_changes.append((current_change_type, ''.join(current_value)))
   367|                 current_value = []
   368|             current_change_type = change_type
   369|         current_value.append(value)
   370|     if current_value:
   371|         merged_changes.append((current_change_type, ''.join(current_value)))
   372|     return TextDiff(merged_changes)


# ====================================================================
# FILE: wagtail/admin/datetimepicker.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-32 ---
     1| def to_datetimepicker_format(python_format_string):
     2|     """
     3|     Given a python datetime format string, attempts to convert it to
     4|     the nearest PHP datetime format string possible.
     5|     """
     6|     python2PHP = {
     7|         "%a": "D",
     8|         "%A": "l",
     9|         "%b": "M",
    10|         "%B": "F",
    11|         "%c": "",
    12|         "%d": "d",
    13|         "%H": "H",
    14|         "%I": "h",
    15|         "%j": "z",
    16|         "%m": "m",
    17|         "%M": "i",
    18|         "%p": "A",
    19|         "%S": "s",
    20|         "%U": "",
    21|         "%w": "w",
    22|         "%W": "W",
    23|         "%x": "",
    24|         "%X": "",
    25|         "%y": "y",
    26|         "%Y": "Y",
    27|         "%Z": "e",
    28|     }
    29|     php_format_string = python_format_string
    30|     for py, php in python2PHP.items():
    31|         php_format_string = php_format_string.replace(py, php)
    32|     return php_format_string


# ====================================================================
# FILE: wagtail/admin/decorators.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-24 ---
     1| from django.contrib.auth.views import redirect_to_login as auth_redirect_to_login
     2| from django.core.exceptions import PermissionDenied
     3| from django.urls import reverse
     4| from django.utils.translation import activate as activate_lang
     5| from django.utils.translation import ugettext as _
     6| from wagtail.admin import messages
     7| def reject_request(request):
     8|     if request.is_ajax():
     9|         raise PermissionDenied
    10|     return auth_redirect_to_login(
    11|         request.get_full_path(), login_url=reverse('wagtailadmin_login'))
    12| def require_admin_access(view_func):
    13|     def decorated_view(request, *args, **kwargs):
    14|         user = request.user
    15|         if user.is_anonymous:
    16|             return reject_request(request)
    17|         if user.has_perms(['wagtailadmin.access_admin']):
    18|             if hasattr(user, 'wagtail_userprofile'):
    19|                 activate_lang(user.wagtail_userprofile.get_preferred_language())
    20|             return view_func(request, *args, **kwargs)
    21|         if not request.is_ajax():
    22|             messages.error(request, _('You do not have permission to access the admin'))
    23|         return reject_request(request)
    24|     return decorated_view


# ====================================================================
# FILE: wagtail/admin/edit_handlers.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-582 ---
     1| import re
     2| from django import forms
     3| from django.core.exceptions import ImproperlyConfigured
     4| from django.db.models.fields import FieldDoesNotExist
     5| from django.forms.models import fields_for_model
     6| from django.template.loader import render_to_string
     7| from django.utils.encoding import force_text
     8| from django.utils.functional import curry
     9| from django.utils.safestring import mark_safe
    10| from django.utils.translation import ugettext_lazy
    11| from taggit.managers import TaggableManager
    12| from wagtail.admin import compare, widgets
    13| from wagtail.core.fields import RichTextField
    14| from wagtail.core.models import Page
    15| from wagtail.core.utils import camelcase_to_underscore, resolve_model_string
    16| from wagtail.utils.decorators import cached_classmethod
    17| from .forms import (  # NOQA
    18|     DIRECT_FORM_FIELD_OVERRIDES, FORM_FIELD_OVERRIDES, WagtailAdminModelForm, WagtailAdminPageForm,
    19|     formfield_for_dbfield)
    20| def widget_with_script(widget, script):
    21|     return mark_safe('{0}<script>{1}</script>'.format(widget, script))
    22| def get_form_for_model(
    23|     model, form_class=WagtailAdminModelForm,
    24|     fields=None, exclude=None, formsets=None, exclude_formsets=None, widgets=None
    25| ):
    26|     attrs = {'model': model}
    27|     if fields is not None:
    28|         attrs['fields'] = fields
    29|     if exclude is not None:
    30|         attrs['exclude'] = exclude
    31|     if widgets is not None:
    32|         attrs['widgets'] = widgets
    33|     if formsets is not None:
    34|         attrs['formsets'] = formsets
    35|     if exclude_formsets is not None:
    36|         attrs['exclude_formsets'] = exclude_formsets
    37|     class_name = model.__name__ + str('Form')
    38|     bases = (object,)
    39|     if hasattr(form_class, 'Meta'):
    40|         bases = (form_class.Meta,) + bases
    41|     form_class_attrs = {
    42|         'Meta': type(str('Meta'), bases, attrs)
    43|     }
    44|     metaclass = type(form_class)
    45|     return metaclass(class_name, (form_class,), form_class_attrs)
    46| def extract_panel_definitions_from_model_class(model, exclude=None):
    47|     if hasattr(model, 'panels'):
    48|         return model.panels
    49|     panels = []
    50|     _exclude = []
    51|     if exclude:
    52|         _exclude.extend(exclude)
    53|     fields = fields_for_model(model, exclude=_exclude, formfield_callback=formfield_for_dbfield)
    54|     for field_name, field in fields.items():
    55|         try:
    56|             panel_class = field.widget.get_panel()
    57|         except AttributeError:
    58|             panel_class = FieldPanel
    59|         panel = panel_class(field_name)
    60|         panels.append(panel)
    61|     return panels
    62| class EditHandler:
    63|     """
    64|     Abstract class providing sensible default behaviours for objects implementing
    65|     the EditHandler API
    66|     """
    67|     def __init__(self, heading='', classname='', help_text=''):
    68|         self.heading = heading
    69|         self.classname = classname
    70|         self.help_text = help_text
    71|     def clone(self):
    72|         return self.__class__(
    73|             heading=self.heading,
    74|             classname=self.classname,
    75|             help_text=self.help_text,
    76|         )
    77|     def widget_overrides(self):
    78|         return {}
    79|     def required_fields(self):
    80|         return []
    81|     def required_formsets(self):
    82|         return {}
    83|     def html_declarations(self):
    84|         return ''
    85|     def bind_to_model(self, model):
    86|         new = self.clone()
    87|         new.model = model
    88|         new.on_model_bound()
    89|         return new
    90|     def on_model_bound(self):
    91|         pass
    92|     def bind_to_instance(self, instance=None, form=None):
    93|         new = self.bind_to_model(self.model)
    94|         if not instance:
    95|             raise ValueError("EditHandler did not receive an instance object")
    96|         new.instance = instance
    97|         if not form:
    98|             raise ValueError("EditHandler did not receive a form object")
    99|         new.form = form
   100|         new.on_instance_bound()
   101|         return new
   102|     def on_instance_bound(self):
   103|         pass
   104|     def __repr__(self):
   105|         class_name = self.__class__.__name__
   106|         try:
   107|             bound_to = force_text(getattr(self, 'instance',
   108|                                           getattr(self, 'model')))
   109|         except AttributeError:
   110|             return '<%s>' % class_name
   111|         return '<%s bound to %s>' % (class_name, bound_to)
   112|     def classes(self):
   113|         """
   114|         Additional CSS classnames to add to whatever kind of object this is at output.
   115|         Subclasses of EditHandler should override this, invoking super().classes() to
   116|         append more classes specific to the situation.
   117|         """
   118|         if self.classname:
   119|             return [self.classname]
   120|         return []
   121|     def field_type(self):
   122|         """
   123|         The kind of field it is e.g boolean_field. Useful for better semantic markup of field display based on type
   124|         """
   125|         return ""
   126|     def id_for_label(self):
   127|         """
   128|         The ID to be used as the 'for' attribute of any <label> elements that refer
   129|         to this object but are rendered outside of it. Leave blank if this object does not render
   130|         as a single input field.
   131|         """
   132|         return ""
   133|     def render_as_object(self):
   134|         """
   135|         Render this object as it should appear within an ObjectList. Should not
   136|         include the <h2> heading or help text - ObjectList will supply those
   137|         """
   138|         return self.render()
   139|     def render_as_field(self):
   140|         """
   141|         Render this object as it should appear within a <ul class="fields"> list item
   142|         """
   143|         return self.render()
   144|     def render_missing_fields(self):
   145|         """
   146|         Helper function: render all of the fields that are defined on the form but not "claimed" by
   147|         any panels via required_fields. These fields are most likely to be hidden fields introduced
   148|         by the forms framework itself, such as ORDER / DELETE fields on formset members.
   149|         (If they aren't actually hidden fields, then they will appear as ugly unstyled / label-less fields
   150|         outside of the panel furniture. But there's not much we can do about that.)
   151|         """
   152|         rendered_fields = self.required_fields()
   153|         missing_fields_html = [
   154|             str(self.form[field_name])
   155|             for field_name in self.form.fields
   156|             if field_name not in rendered_fields
   157|         ]
   158|         return mark_safe(''.join(missing_fields_html))
   159|     def render_form_content(self):
   160|         """
   161|         Render this as an 'object', ensuring that all fields necessary for a valid form
   162|         submission are included
   163|         """
   164|         return mark_safe(self.render_as_object() + self.render_missing_fields())
   165|     def get_comparison(self):
   166|         return []
   167| class BaseCompositeEditHandler(EditHandler):
   168|     """
   169|     Abstract class for EditHandlers that manage a set of sub-EditHandlers.
   170|     Concrete subclasses must attach a 'children' property
   171|     """
   172|     def __init__(self, children=(), *args, **kwargs):
   173|         super().__init__(*args, **kwargs)
   174|         self.children = children
   175|     def clone(self):
   176|         return self.__class__(
   177|             children=self.children,
   178|             heading=self.heading,
   179|             classname=self.classname,
   180|             help_text=self.help_text,
   181|         )
   182|     def widget_overrides(self):
   183|         widgets = {}
   184|         for handler_class in self.children:
   185|             widgets.update(handler_class.widget_overrides())
   186|         widget_overrides = widgets
   187|         return widget_overrides
   188|     def required_fields(self):
   189|         fields = []
   190|         for handler in self.children:
   191|             fields.extend(handler.required_fields())
   192|         return fields
   193|     def required_formsets(self):
   194|         formsets = {}
   195|         for handler_class in self.children:
   196|             formsets.update(handler_class.required_formsets())
   197|         return formsets
   198|     def html_declarations(self):
   199|         return mark_safe(''.join([c.html_declarations() for c in self.children]))
   200|     def on_model_bound(self):
   201|         self.children = [child.bind_to_model(self.model)
   202|                          for child in self.children]
   203|     def on_instance_bound(self):
   204|         children = []
   205|         for child in self.children:
   206|             if isinstance(child, FieldPanel):
   207|                 if self.form._meta.exclude:
   208|                     if child.field_name in self.form._meta.exclude:
   209|                         continue
   210|                 if self.form._meta.fields:
   211|                     if child.field_name not in self.form._meta.fields:
   212|                         continue
   213|             children.append(child.bind_to_instance(instance=self.instance,
   214|                                                    form=self.form))
   215|         self.children = children
   216|     def render(self):
   217|         return mark_safe(render_to_string(self.template, {
   218|             'self': self
   219|         }))
   220|     def get_comparison(self):
   221|         comparators = []
   222|         for child in self.children:
   223|             comparators.extend(child.get_comparison())
   224|         return comparators
   225| class BaseFormEditHandler(BaseCompositeEditHandler):
   226|     """
   227|     Base class for edit handlers that can construct a form class for all their
   228|     child edit handlers.
   229|     """
   230|     base_form_class = None
   231|     def get_form_class(self):
   232|         """
   233|         Construct a form class that has all the fields and formsets named in
   234|         the children of this edit handler.
   235|         """
   236|         if not hasattr(self, 'model'):
   237|             raise AttributeError(
   238|                 '%s is not bound to a model yet. Use `.bind_to_model(model)` '
   239|                 'before using this method.' % self.__class__.__name__)
   240|         model_form_class = getattr(self.model, 'base_form_class',
   241|                                    WagtailAdminModelForm)
   242|         base_form_class = self.base_form_class or model_form_class
   243|         return get_form_for_model(
   244|             self.model,
   245|             form_class=base_form_class,
   246|             fields=self.required_fields(),
   247|             formsets=self.required_formsets(),
   248|             widgets=self.widget_overrides())
   249| class TabbedInterface(BaseFormEditHandler):
   250|     template = "wagtailadmin/edit_handlers/tabbed_interface.html"
   251|     def __init__(self, *args, **kwargs):
   252|         self.base_form_class = kwargs.pop('base_form_class', None)
   253|         super().__init__(*args, **kwargs)
   254|     def clone(self):
   255|         new = super().clone()
   256|         new.base_form_class = self.base_form_class
   257|         return new
   258| class ObjectList(TabbedInterface):
   259|     template = "wagtailadmin/edit_handlers/object_list.html"
   260| class FieldRowPanel(BaseCompositeEditHandler):
   261|     template = "wagtailadmin/edit_handlers/field_row_panel.html"
   262|     def on_instance_bound(self):
   263|         super().on_instance_bound()
   264|         col_count = ' col%s' % (12 // len(self.children))
   265|         for child in self.children:
   266|             if not re.search(r'\bcol\d+\b', child.classname):
   267|                 child.classname += col_count
   268| class MultiFieldPanel(BaseCompositeEditHandler):
   269|     template = "wagtailadmin/edit_handlers/multi_field_panel.html"
   270|     def classes(self):
   271|         classes = super().classes()
   272|         classes.append("multi-field")
   273|         return classes
   274| class FieldPanel(EditHandler):
   275|     TEMPLATE_VAR = 'field_panel'
   276|     def __init__(self, field_name, *args, **kwargs):
   277|         widget = kwargs.pop('widget', None)
   278|         if widget is not None:
   279|             self.widget = widget
   280|         super().__init__(*args, **kwargs)
   281|         self.field_name = field_name
   282|     def clone(self):
   283|         return self.__class__(
   284|             field_name=self.field_name,
   285|             widget=self.widget if hasattr(self, 'widget') else None,
   286|             heading=self.heading,
   287|             classname=self.classname,
   288|             help_text=self.help_text
   289|         )
   290|     def widget_overrides(self):
   291|         """check if a specific widget has been defined for this field"""
   292|         if hasattr(self, 'widget'):
   293|             return {self.field_name: self.widget}
   294|         return {}
   295|     def classes(self):
   296|         classes = super().classes()
   297|         if self.bound_field.field.required:
   298|             classes.append("required")
   299|         if self.bound_field.errors:
   300|             classes.append("error")
   301|         classes.append(self.field_type())
   302|         return classes
   303|     def field_type(self):
   304|         return camelcase_to_underscore(self.bound_field.field.__class__.__name__)
   305|     def id_for_label(self):
   306|         return self.bound_field.id_for_label
   307|     object_template = "wagtailadmin/edit_handlers/single_field_panel.html"
   308|     def render_as_object(self):
   309|         return mark_safe(render_to_string(self.object_template, {
   310|             'self': self,
   311|             self.TEMPLATE_VAR: self,
   312|             'field': self.bound_field,
   313|         }))
   314|     field_template = "wagtailadmin/edit_handlers/field_panel_field.html"
   315|     def render_as_field(self):
   316|         return mark_safe(render_to_string(self.field_template, {
   317|             'field': self.bound_field,
   318|             'field_type': self.field_type(),
   319|         }))
   320|     def required_fields(self):
   321|         return [self.field_name]
   322|     def get_comparison_class(self):
   323|         widget_override = self.widget_overrides().get(self.field_name, None)
   324|         if widget_override and widget_override.is_hidden:
   325|             return
   326|         try:
   327|             field = self.db_field
   328|             if field.choices:
   329|                 return compare.ChoiceFieldComparison
   330|             if field.is_relation:
   331|                 if isinstance(field, TaggableManager):
   332|                     return compare.TagsFieldComparison
   333|                 elif field.many_to_many:
   334|                     return compare.M2MFieldComparison
   335|                 return compare.ForeignObjectComparison
   336|             if isinstance(field, RichTextField):
   337|                 return compare.RichTextFieldComparison
   338|         except FieldDoesNotExist:
   339|             pass
   340|         return compare.FieldComparison
   341|     def get_comparison(self):
   342|         comparator_class = self.get_comparison_class()
   343|         if comparator_class:
   344|             return [curry(comparator_class, self.db_field)]
   345|         return []
   346|     def on_model_bound(self):
   347|         self.db_field = self.model._meta.get_field(self.field_name)
   348|     def on_instance_bound(self):
   349|         self.bound_field = self.form[self.field_name]
   350|         self.heading = self.bound_field.label
   351|         self.help_text = self.bound_field.help_text
   352|     def __repr__(self):
   353|         class_name = self.__class__.__name__
   354|         try:
   355|             bound_to = force_text(getattr(self, 'instance',
   356|                                           getattr(self, 'model')))
   357|         except AttributeError:
   358|             return "<%s '%s'>" % (class_name, self.field_name)
   359|         return "<%s '%s' bound to %s>" % (class_name, self.field_name, bound_to)
   360| class RichTextFieldPanel(FieldPanel):
   361|     def get_comparison_class(self):
   362|         return compare.RichTextFieldComparison
   363| class BaseChooserPanel(FieldPanel):
   364|     """
   365|     Abstract superclass for panels that provide a modal interface for choosing (or creating)
   366|     a database object such as an image, resulting in an ID that is used to populate
   367|     a hidden foreign key input.
   368|     Subclasses provide:
   369|     * field_template (only required if the default template of field_panel_field.html is not usable)
   370|     * object_type_name - something like 'image' which will be used as the var name
   371|       for the object instance in the field_template
   372|     """
   373|     def get_chosen_item(self):
   374|         field = self.instance._meta.get_field(self.field_name)
   375|         related_model = field.remote_field.model
   376|         try:
   377|             return getattr(self.instance, self.field_name)
   378|         except related_model.DoesNotExist:
   379|             return
   380|     def render_as_field(self):
   381|         instance_obj = self.get_chosen_item()
   382|         context = {
   383|             'field': self.bound_field,
   384|             self.object_type_name: instance_obj,
   385|             'is_chosen': bool(instance_obj),  # DEPRECATED - passed to templates for backwards compatibility only
   386|         }
   387|         return mark_safe(render_to_string(self.field_template, context))
   388| class PageChooserPanel(BaseChooserPanel):
   389|     object_type_name = "page"
   390|     def __init__(self, field_name, page_type=None, can_choose_root=False):
   391|         super().__init__(field_name=field_name)
   392|         if page_type:
   393|             if not isinstance(page_type, (list, tuple)):
   394|                 page_type = [page_type]
   395|         else:
   396|             page_type = []
   397|         self.page_type = page_type
   398|         self.can_choose_root = can_choose_root
   399|     def clone(self):
   400|         return self.__class__(
   401|             field_name=self.field_name,
   402|             page_type=self.page_type,
   403|             can_choose_root=self.can_choose_root,
   404|         )
   405|     def widget_overrides(self):
   406|         return {self.field_name: widgets.AdminPageChooser(
   407|             target_models=self.target_models(),
   408|             can_choose_root=self.can_choose_root)}
   409|     def target_models(self):
   410|         if self.page_type:
   411|             target_models = []
   412|             for page_type in self.page_type:
   413|                 try:
   414|                     target_models.append(resolve_model_string(page_type))
   415|                 except LookupError:
   416|                     raise ImproperlyConfigured(
   417|                         "{0}.page_type must be of the form 'app_label.model_name', given {1!r}".format(
   418|                             self.__class__.__name__, page_type
   419|                         )
   420|                     )
   421|                 except ValueError:
   422|                     raise ImproperlyConfigured(
   423|                         "{0}.page_type refers to model {1!r} that has not been installed".format(
   424|                             self.__class__.__name__, page_type
   425|                         )
   426|                     )
   427|             return target_models
   428|         return [self.db_field.remote_field.model]
   429| class InlinePanel(EditHandler):
   430|     def __init__(self, relation_name, panels=None, heading='', label='',
   431|                  min_num=None, max_num=None, *args, **kwargs):
   432|         super().__init__(*args, **kwargs)
   433|         self.relation_name = relation_name
   434|         self.panels = panels
   435|         self.heading = heading or label
   436|         self.label = label
   437|         self.min_num = min_num
   438|         self.max_num = max_num
   439|     def clone(self):
   440|         return self.__class__(
   441|             relation_name=self.relation_name,
   442|             panels=self.panels,
   443|             heading=self.heading,
   444|             label=self.label,
   445|             help_text=self.help_text,
   446|             min_num=self.min_num,
   447|             max_num=self.max_num,
   448|             classname=self.classname,
   449|         )
   450|     def get_panel_definitions(self):
   451|         if self.panels is not None:
   452|             return self.panels
   453|         return extract_panel_definitions_from_model_class(
   454|             self.related.related_model,
   455|             exclude=[self.related.field.name]
   456|         )
   457|     def get_child_edit_handler(self):
   458|         panels = self.get_panel_definitions()
   459|         child_edit_handler = MultiFieldPanel(panels, heading=self.heading)
   460|         return child_edit_handler.bind_to_model(self.related.related_model)
   461|     def required_formsets(self):
   462|         child_edit_handler = self.get_child_edit_handler()
   463|         return {
   464|             self.relation_name: {
   465|                 'fields': child_edit_handler.required_fields(),
   466|                 'widgets': child_edit_handler.widget_overrides(),
   467|                 'min_num': self.min_num,
   468|                 'validate_min': self.min_num is not None,
   469|                 'max_num': self.max_num,
   470|                 'validate_max': self.max_num is not None
   471|             }
   472|         }
   473|     def html_declarations(self):
   474|         return self.get_child_edit_handler().html_declarations()
   475|     def get_comparison(self):
   476|         field_comparisons = []
   477|         for panel in self.get_panel_definitions():
   478|             field_comparisons.extend(
   479|                 panel.bind_to_model(self.related.related_model)
   480|                 .get_comparison())
   481|         return [curry(compare.ChildRelationComparison, self.db_field,
   482|                       field_comparisons)]
   483|     def on_model_bound(self):
   484|         self.db_field = self.model._meta.get_field(self.relation_name)
   485|         manager = getattr(self.model, self.relation_name)
   486|         self.related = manager.rel
   487|     def on_instance_bound(self):
   488|         self.formset = self.form.formsets[self.relation_name]
   489|         self.children = []
   490|         for subform in self.formset.forms:
   491|             subform.fields['DELETE'].widget = forms.HiddenInput()
   492|             if self.formset.can_order:
   493|                 subform.fields['ORDER'].widget = forms.HiddenInput()
   494|             child_edit_handler = self.get_child_edit_handler()
   495|             self.children.append(
   496|                 child_edit_handler.bind_to_instance(instance=subform.instance,
   497|                                                     form=subform))
   498|         if self.formset.can_order and self.formset.is_valid():
   499|             self.children = sorted(self.children, key=lambda x: x.form.cleaned_data['ORDER'])
   500|         empty_form = self.formset.empty_form
   501|         empty_form.fields['DELETE'].widget = forms.HiddenInput()
   502|         if self.formset.can_order:
   503|             empty_form.fields['ORDER'].widget = forms.HiddenInput()
   504|         self.empty_child = self.get_child_edit_handler()
   505|         self.empty_child = self.empty_child.bind_to_instance(
   506|             instance=empty_form.instance, form=empty_form)
   507|     template = "wagtailadmin/edit_handlers/inline_panel.html"
   508|     def render(self):
   509|         formset = render_to_string(self.template, {
   510|             'self': self,
   511|             'can_order': self.formset.can_order,
   512|         })
   513|         js = self.render_js_init()
   514|         return widget_with_script(formset, js)
   515|     js_template = "wagtailadmin/edit_handlers/inline_panel.js"
   516|     def render_js_init(self):
   517|         return mark_safe(render_to_string(self.js_template, {
   518|             'self': self,
   519|             'can_order': self.formset.can_order,
   520|         }))
   521| class PublishingPanel(MultiFieldPanel):
   522|     def __init__(self, **kwargs):
   523|         updated_kwargs = {
   524|             'children': [
   525|                 FieldRowPanel([
   526|                     FieldPanel('go_live_at'),
   527|                     FieldPanel('expire_at'),
   528|                 ], classname="label-above"),
   529|             ],
   530|             'heading': ugettext_lazy('Scheduled publishing'),
   531|             'classname': 'publishing',
   532|         }
   533|         updated_kwargs.update(kwargs)
   534|         super().__init__(**updated_kwargs)
   535| Page.content_panels = [
   536|     FieldPanel('title', classname="full title"),
   537| ]
   538| Page.promote_panels = [
   539|     MultiFieldPanel([
   540|         FieldPanel('slug'),
   541|         FieldPanel('seo_title'),
   542|         FieldPanel('show_in_menus'),
   543|         FieldPanel('search_description'),
   544|     ], ugettext_lazy('Common page configuration')),
   545| ]
   546| Page.settings_panels = [
   547|     PublishingPanel()
   548| ]
   549| Page.base_form_class = WagtailAdminPageForm
   550| @cached_classmethod
   551| def get_edit_handler(cls):
   552|     """
   553|     Get the EditHandler to use in the Wagtail admin when editing this page type.
   554|     """
   555|     if hasattr(cls, 'edit_handler'):
   556|         return cls.edit_handler.bind_to_model(cls)
   557|     tabs = []
   558|     if cls.content_panels:
   559|         tabs.append(ObjectList(cls.content_panels, heading=ugettext_lazy('Content')))
   560|     if cls.promote_panels:
   561|         tabs.append(ObjectList(cls.promote_panels, heading=ugettext_lazy('Promote')))
   562|     if cls.settings_panels:
   563|         tabs.append(ObjectList(cls.settings_panels, heading=ugettext_lazy('Settings'), classname="settings"))
   564|     edit_handler = TabbedInterface(tabs, base_form_class=cls.base_form_class)
   565|     return edit_handler.bind_to_model(cls)
   566| Page.get_edit_handler = get_edit_handler
   567| class StreamFieldPanel(FieldPanel):
   568|     def classes(self):
   569|         classes = super().classes()
   570|         classes.append("stream-field")
   571|         if 'error' in classes:
   572|             classes.remove("error")
   573|         return classes
   574|     def html_declarations(self):
   575|         return self.block_def.all_html_declarations()
   576|     def get_comparison_class(self):
   577|         return compare.StreamFieldComparison
   578|     def id_for_label(self):
   579|         return ""
   580|     def on_model_bound(self):
   581|         super().on_model_bound()
   582|         self.block_def = self.db_field.stream_block


# ====================================================================
# FILE: wagtail/admin/forms.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-396 ---
     1| import copy
     2| from itertools import groupby
     3| from django import forms
     4| from django.contrib.auth import get_user_model
     5| from django.contrib.auth.forms import AuthenticationForm, PasswordResetForm
     6| from django.contrib.auth.models import Group, Permission
     7| from django.core import validators
     8| from django.db import models, transaction
     9| from django.forms.widgets import TextInput
    10| from django.template.loader import render_to_string
    11| from django.utils import timezone
    12| from django.utils.translation import ugettext as _
    13| from django.utils.translation import ugettext_lazy, ungettext
    14| from modelcluster.forms import ClusterForm, ClusterFormMetaclass
    15| from taggit.managers import TaggableManager
    16| from wagtail.admin import widgets
    17| from wagtail.core.models import (
    18|     BaseViewRestriction, Collection, CollectionViewRestriction, GroupCollectionPermission, Page,
    19|     PageViewRestriction)
    20| class URLOrAbsolutePathValidator(validators.URLValidator):
    21|     @staticmethod
    22|     def is_absolute_path(value):
    23|         return value.startswith('/')
    24|     def __call__(self, value):
    25|         if URLOrAbsolutePathValidator.is_absolute_path(value):
    26|             return None
    27|         else:
    28|             return super().__call__(value)
    29| class URLOrAbsolutePathField(forms.URLField):
    30|     widget = TextInput
    31|     default_validators = [URLOrAbsolutePathValidator()]
    32|     def to_python(self, value):
    33|         if not URLOrAbsolutePathValidator.is_absolute_path(value):
    34|             value = super().to_python(value)
    35|         return value
    36| class SearchForm(forms.Form):
    37|     def __init__(self, *args, **kwargs):
    38|         placeholder = kwargs.pop('placeholder', _("Search"))
    39|         super().__init__(*args, **kwargs)
    40|         self.fields['q'].widget.attrs = {'placeholder': placeholder}
    41|     q = forms.CharField(label=ugettext_lazy("Search term"), widget=forms.TextInput())
    42| class ExternalLinkChooserForm(forms.Form):
    43|     url = URLOrAbsolutePathField(required=True, label=ugettext_lazy("URL"))
    44|     link_text = forms.CharField(required=False)
    45| class EmailLinkChooserForm(forms.Form):
    46|     email_address = forms.EmailField(required=True)
    47|     link_text = forms.CharField(required=False)
    48| class LoginForm(AuthenticationForm):
    49|     username = forms.CharField(
    50|         max_length=254, widget=forms.TextInput(attrs={'tabindex': '1'}))
    51|     password = forms.CharField(
    52|         widget=forms.PasswordInput(attrs={
    53|             'tabindex': '2',
    54|             'placeholder': ugettext_lazy("Enter password"),
    55|         }))
    56|     def __init__(self, request=None, *args, **kwargs):
    57|         super().__init__(request=request, *args, **kwargs)
    58|         self.fields['username'].widget.attrs['placeholder'] = (
    59|             ugettext_lazy("Enter your %s") % self.username_field.verbose_name)
    60|     @property
    61|     def extra_fields(self):
    62|         for field_name, field in self.fields.items():
    63|             if field_name not in ['username', 'password']:
    64|                 yield field_name, field
    65| class PasswordResetForm(PasswordResetForm):
    66|     email = forms.EmailField(label=ugettext_lazy("Enter your email address to reset your password"), max_length=254)
    67|     def clean(self):
    68|         cleaned_data = super().clean()
    69|         UserModel = get_user_model()
    70|         email = cleaned_data.get('email')
    71|         if not email:
    72|             raise forms.ValidationError(_("Please fill your email address."))
    73|         active_users = UserModel._default_manager.filter(email__iexact=email, is_active=True)
    74|         if active_users.exists():
    75|             found_non_ldap_user = False
    76|             for user in active_users:
    77|                 if user.has_usable_password():
    78|                     found_non_ldap_user = True
    79|                     break
    80|             if not found_non_ldap_user:
    81|                 raise forms.ValidationError(
    82|                     _("Sorry, you cannot reset your password here as your user account is managed by another server.")
    83|                 )
    84|         else:
    85|             raise forms.ValidationError(_("This email address is not recognised."))
    86|         return cleaned_data
    87| class CopyForm(forms.Form):
    88|     def __init__(self, *args, **kwargs):
    89|         self.page = kwargs.pop('page')
    90|         self.user = kwargs.pop('user', None)
    91|         can_publish = kwargs.pop('can_publish')
    92|         super().__init__(*args, **kwargs)
    93|         self.fields['new_title'] = forms.CharField(initial=self.page.title, label=_("New title"))
    94|         self.fields['new_slug'] = forms.SlugField(initial=self.page.slug, label=_("New slug"))
    95|         self.fields['new_parent_page'] = forms.ModelChoiceField(
    96|             initial=self.page.get_parent(),
    97|             queryset=Page.objects.all(),
    98|             widget=widgets.AdminPageChooser(can_choose_root=True, user_perms='copy_to'),
    99|             label=_("New parent page"),
   100|             help_text=_("This copy will be a child of this given parent page.")
   101|         )
   102|         pages_to_copy = self.page.get_descendants(inclusive=True)
   103|         subpage_count = pages_to_copy.count() - 1
   104|         if subpage_count > 0:
   105|             self.fields['copy_subpages'] = forms.BooleanField(
   106|                 required=False, initial=True, label=_("Copy subpages"),
   107|                 help_text=ungettext(
   108|                     "This will copy %(count)s subpage.",
   109|                     "This will copy %(count)s subpages.",
   110|                     subpage_count) % {'count': subpage_count})
   111|         if can_publish:
   112|             pages_to_publish_count = pages_to_copy.live().count()
   113|             if pages_to_publish_count > 0:
   114|                 if subpage_count == 0:
   115|                     label = _("Publish copied page")
   116|                     help_text = _("This page is live. Would you like to publish its copy as well?")
   117|                 else:
   118|                     label = _("Publish copies")
   119|                     help_text = ungettext(
   120|                         "%(count)s of the pages being copied is live. Would you like to publish its copy?",
   121|                         "%(count)s of the pages being copied are live. Would you like to publish their copies?",
   122|                         pages_to_publish_count) % {'count': pages_to_publish_count}
   123|                 self.fields['publish_copies'] = forms.BooleanField(
   124|                     required=False, initial=True, label=label, help_text=help_text
   125|                 )
   126|     def clean(self):
   127|         cleaned_data = super().clean()
   128|         slug = cleaned_data.get('new_slug')
   129|         parent_page = cleaned_data.get('new_parent_page') or self.page.get_parent()
   130|         if not parent_page.permissions_for_user(self.user).can_add_subpage():
   131|             self._errors['new_parent_page'] = self.error_class([
   132|                 _("You do not have permission to copy to page \"%(page_title)s\"") % {'page_title': parent_page.get_admin_display_title()}
   133|             ])
   134|         if slug and parent_page.get_children().filter(slug=slug).count():
   135|             self._errors['new_slug'] = self.error_class(
   136|                 [_("This slug is already in use within the context of its parent page \"%s\"" % parent_page)]
   137|             )
   138|             del cleaned_data['new_slug']
   139|         if cleaned_data.get('copy_subpages') and (self.page == parent_page or parent_page.is_descendant_of(self.page)):
   140|             self._errors['new_parent_page'] = self.error_class(
   141|                 [_("You cannot copy a page into itself when copying subpages")]
   142|             )
   143|         return cleaned_data
   144| class BaseViewRestrictionForm(forms.ModelForm):
   145|     restriction_type = forms.ChoiceField(
   146|         label=ugettext_lazy("Visibility"), choices=BaseViewRestriction.RESTRICTION_CHOICES,
   147|         widget=forms.RadioSelect)
   148|     def __init__(self, *args, **kwargs):
   149|         super().__init__(*args, **kwargs)
   150|         self.fields['groups'].widget = forms.CheckboxSelectMultiple()
   151|         self.fields['groups'].queryset = Group.objects.all()
   152|     def clean_password(self):
   153|         password = self.cleaned_data.get('password')
   154|         if self.cleaned_data.get('restriction_type') == BaseViewRestriction.PASSWORD and not password:
   155|             raise forms.ValidationError(_("This field is required."), code='invalid')
   156|         return password
   157|     def clean_groups(self):
   158|         groups = self.cleaned_data.get('groups')
   159|         if self.cleaned_data.get('restriction_type') == BaseViewRestriction.GROUPS and not groups:
   160|             raise forms.ValidationError(_("Please select at least one group."), code='invalid')
   161|         return groups
   162|     class Meta:
   163|         model = BaseViewRestriction
   164|         fields = ('restriction_type', 'password', 'groups')
   165| class CollectionViewRestrictionForm(BaseViewRestrictionForm):
   166|     class Meta:
   167|         model = CollectionViewRestriction
   168|         fields = ('restriction_type', 'password', 'groups')
   169| class PageViewRestrictionForm(BaseViewRestrictionForm):
   170|     class Meta:
   171|         model = PageViewRestriction
   172|         fields = ('restriction_type', 'password', 'groups')
   173| FORM_FIELD_OVERRIDES = {
   174|     models.DateField: {'widget': widgets.AdminDateInput},
   175|     models.TimeField: {'widget': widgets.AdminTimeInput},
   176|     models.DateTimeField: {'widget': widgets.AdminDateTimeInput},
   177|     TaggableManager: {'widget': widgets.AdminTagWidget},
   178| }
   179| DIRECT_FORM_FIELD_OVERRIDES = {
   180|     models.TextField: {'widget': widgets.AdminAutoHeightTextInput},
   181| }
   182| def formfield_for_dbfield(db_field, **kwargs):
   183|     overrides = None
   184|     if db_field.__class__ in DIRECT_FORM_FIELD_OVERRIDES:
   185|         overrides = DIRECT_FORM_FIELD_OVERRIDES[db_field.__class__]
   186|     else:
   187|         for klass in db_field.__class__.mro():
   188|             if klass in FORM_FIELD_OVERRIDES:
   189|                 overrides = FORM_FIELD_OVERRIDES[klass]
   190|                 break
   191|     if overrides:
   192|         kwargs = dict(copy.deepcopy(overrides), **kwargs)
   193|     return db_field.formfield(**kwargs)
   194| class WagtailAdminModelFormMetaclass(ClusterFormMetaclass):
   195|     extra_form_count = 0
   196|     def __new__(cls, name, bases, attrs):
   197|         if 'formfield_callback' not in attrs or attrs['formfield_callback'] is None:
   198|             attrs['formfield_callback'] = formfield_for_dbfield
   199|         new_class = super(WagtailAdminModelFormMetaclass, cls).__new__(cls, name, bases, attrs)
   200|         return new_class
   201| class WagtailAdminModelForm(ClusterForm, metaclass=WagtailAdminModelFormMetaclass):
   202|     @property
   203|     def media(self):
   204|         media = super().media
   205|         for formset in self.formsets.values():
   206|             media += formset.media
   207|         return media
   208| class WagtailAdminPageForm(WagtailAdminModelForm):
   209|     class Meta:
   210|         exclude = ['content_type', 'path', 'depth', 'numchild']
   211|     def __init__(self, data=None, files=None, parent_page=None, *args, **kwargs):
   212|         super().__init__(data, files, *args, **kwargs)
   213|         self.parent_page = parent_page
   214|     def clean(self):
   215|         cleaned_data = super().clean()
   216|         if 'slug' in self.cleaned_data:
   217|             if not Page._slug_is_available(
   218|                 cleaned_data['slug'], self.parent_page, self.instance
   219|             ):
   220|                 self.add_error('slug', forms.ValidationError(_("This slug is already in use")))
   221|         go_live_at = cleaned_data.get('go_live_at')
   222|         expire_at = cleaned_data.get('expire_at')
   223|         if go_live_at and expire_at:
   224|             if go_live_at > expire_at:
   225|                 msg = _('Go live date/time must be before expiry date/time')
   226|                 self.add_error('go_live_at', forms.ValidationError(msg))
   227|                 self.add_error('expire_at', forms.ValidationError(msg))
   228|         if expire_at and expire_at < timezone.now():
   229|             self.add_error('expire_at', forms.ValidationError(_('Expiry date/time must be in the future')))
   230|         if 'first_published_at' in cleaned_data and not cleaned_data['first_published_at']:
   231|             del cleaned_data['first_published_at']
   232|         return cleaned_data
   233| class CollectionForm(forms.ModelForm):
   234|     class Meta:
   235|         model = Collection
   236|         fields = ('name',)
   237| class BaseCollectionMemberForm(forms.ModelForm):
   238|     """
   239|     Abstract form handler for editing models that belong to a collection,
   240|     such as documents and images. These forms are (optionally) instantiated
   241|     with a 'user' kwarg, and take care of populating the 'collection' field's
   242|     choices with the collections the user has permission for, as well as
   243|     hiding the field when only one collection is available.
   244|     Subclasses must define a 'permission_policy' attribute.
   245|     """
   246|     def __init__(self, *args, **kwargs):
   247|         user = kwargs.pop('user', None)
   248|         super().__init__(*args, **kwargs)
   249|         if user is None:
   250|             self.collections = Collection.objects.all()
   251|         else:
   252|             self.collections = (
   253|                 self.permission_policy.collections_user_has_permission_for(user, 'add')
   254|             )
   255|         if self.instance.pk:
   256|             self.collections = (
   257|                 self.collections | Collection.objects.filter(id=self.instance.collection_id)
   258|             )
   259|         if len(self.collections) == 0:
   260|             raise Exception(
   261|                 "Cannot construct %s for a user with no collection permissions" % type(self)
   262|             )
   263|         elif len(self.collections) == 1:
   264|             del self.fields['collection']
   265|         else:
   266|             self.fields['collection'].queryset = self.collections
   267|     def save(self, commit=True):
   268|         if len(self.collections) == 1:
   269|             self.instance.collection = self.collections[0]
   270|         return super().save(commit=commit)
   271| class BaseGroupCollectionMemberPermissionFormSet(forms.BaseFormSet):
   272|     """
   273|     A base formset class for managing GroupCollectionPermissions for a
   274|     model with CollectionMember behaviour. Subclasses should provide attributes:
   275|     permission_types - a list of (codename, short_label, long_label) tuples for the permissions
   276|         being managed here
   277|     permission_queryset - a queryset of Permission objects for the above permissions
   278|     default_prefix - prefix to use on form fields if one is not specified in __init__
   279|     template = template filename
   280|     """
   281|     def __init__(self, data=None, files=None, instance=None, prefix=None):
   282|         if prefix is None:
   283|             prefix = self.default_prefix
   284|         if instance is None:
   285|             instance = Group()
   286|         self.instance = instance
   287|         initial_data = []
   288|         for collection, collection_permissions in groupby(
   289|             instance.collection_permissions.filter(
   290|                 permission__in=self.permission_queryset
   291|             ).select_related('permission__content_type', 'collection').order_by('collection'),
   292|             lambda cp: cp.collection
   293|         ):
   294|             initial_data.append({
   295|                 'collection': collection,
   296|                 'permissions': [cp.permission for cp in collection_permissions]
   297|             })
   298|         super().__init__(
   299|             data, files, initial=initial_data, prefix=prefix
   300|         )
   301|         for form in self.forms:
   302|             form.fields['DELETE'].widget = forms.HiddenInput()
   303|     @property
   304|     def empty_form(self):
   305|         empty_form = super().empty_form
   306|         empty_form.fields['DELETE'].widget = forms.HiddenInput()
   307|         return empty_form
   308|     def clean(self):
   309|         """Checks that no two forms refer to the same collection object"""
   310|         if any(self.errors):
   311|             return
   312|         collections = [
   313|             form.cleaned_data['collection']
   314|             for form in self.forms
   315|             if form not in self.deleted_forms and 'collection' in form.cleaned_data
   316|         ]
   317|         if len(set(collections)) != len(collections):
   318|             raise forms.ValidationError(
   319|                 _("You cannot have multiple permission records for the same collection.")
   320|             )
   321|     @transaction.atomic
   322|     def save(self):
   323|         if self.instance.pk is None:
   324|             raise Exception(
   325|                 "Cannot save a GroupCollectionMemberPermissionFormSet "
   326|                 "for an unsaved group instance"
   327|             )
   328|         forms_to_save = [
   329|             form for form in self.forms
   330|             if form not in self.deleted_forms and 'collection' in form.cleaned_data
   331|         ]
   332|         final_permission_records = set()
   333|         for form in forms_to_save:
   334|             for permission in form.cleaned_data['permissions']:
   335|                 final_permission_records.add((form.cleaned_data['collection'], permission))
   336|         permission_ids_to_delete = []
   337|         permission_records_to_keep = set()
   338|         for cp in self.instance.collection_permissions.filter(
   339|             permission__in=self.permission_queryset,
   340|         ):
   341|             if (cp.collection, cp.permission) in final_permission_records:
   342|                 permission_records_to_keep.add((cp.collection, cp.permission))
   343|             else:
   344|                 permission_ids_to_delete.append(cp.id)
   345|         self.instance.collection_permissions.filter(id__in=permission_ids_to_delete).delete()
   346|         permissions_to_add = final_permission_records - permission_records_to_keep
   347|         GroupCollectionPermission.objects.bulk_create([
   348|             GroupCollectionPermission(
   349|                 group=self.instance, collection=collection, permission=permission
   350|             )
   351|             for (collection, permission) in permissions_to_add
   352|         ])
   353|     def as_admin_panel(self):
   354|         return render_to_string(
   355|             self.template,
   356|             {'formset': self},
   357|         )
   358| def collection_member_permission_formset_factory(
   359|     model, permission_types, template, default_prefix=None
   360| ):
   361|     permission_queryset = Permission.objects.filter(
   362|         content_type__app_label=model._meta.app_label,
   363|         codename__in=[codename for codename, short_label, long_label in permission_types]
   364|     ).select_related('content_type')
   365|     if default_prefix is None:
   366|         default_prefix = '%s_permissions' % model._meta.model_name
   367|     class CollectionMemberPermissionsForm(forms.Form):
   368|         """
   369|         For a given model with CollectionMember behaviour,
   370|         defines the permissions that are assigned to an entity
   371|         (i.e. group or user) for a specific collection
   372|         """
   373|         collection = forms.ModelChoiceField(
   374|             queryset=Collection.objects.all().prefetch_related('group_permissions')
   375|         )
   376|         permissions = forms.ModelMultipleChoiceField(
   377|             queryset=permission_queryset,
   378|             required=False,
   379|             widget=forms.CheckboxSelectMultiple
   380|         )
   381|     GroupCollectionMemberPermissionFormSet = type(
   382|         str('GroupCollectionMemberPermissionFormSet'),
   383|         (BaseGroupCollectionMemberPermissionFormSet, ),
   384|         {
   385|             'permission_types': permission_types,
   386|             'permission_queryset': permission_queryset,
   387|             'default_prefix': default_prefix,
   388|             'template': template,
   389|         }
   390|     )
   391|     return forms.formset_factory(
   392|         CollectionMemberPermissionsForm,
   393|         formset=GroupCollectionMemberPermissionFormSet,
   394|         extra=0,
   395|         can_delete=True
   396|     )


# ====================================================================
# FILE: wagtail/admin/jinja2tags.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-10 ---
     1| import jinja2
     2| from jinja2.ext import Extension
     3| from .templatetags.wagtailuserbar import wagtailuserbar
     4| class WagtailUserbarExtension(Extension):
     5|     def __init__(self, environment):
     6|         super().__init__(environment)
     7|         self.environment.globals.update({
     8|             'wagtailuserbar': jinja2.contextfunction(wagtailuserbar),
     9|         })
    10| userbar = WagtailUserbarExtension


# ====================================================================
# FILE: wagtail/admin/menu.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-92 ---
     1| from django.contrib.staticfiles.templatetags.staticfiles import static
     2| from django.forms import Media, MediaDefiningClass
     3| from django.forms.utils import flatatt
     4| from django.template.loader import render_to_string
     5| from django.utils.safestring import mark_safe
     6| from django.utils.text import slugify
     7| from wagtail.core import hooks
     8| class MenuItem(metaclass=MediaDefiningClass):
     9|     template = 'wagtailadmin/shared/menu_item.html'
    10|     def __init__(self, label, url, name=None, classnames='', attrs=None, order=1000):
    11|         self.label = label
    12|         self.url = url
    13|         self.classnames = classnames
    14|         self.name = (name or slugify(str(label)))
    15|         self.order = order
    16|         if attrs:
    17|             self.attr_string = flatatt(attrs)
    18|         else:
    19|             self.attr_string = ""
    20|     def is_shown(self, request):
    21|         """
    22|         Whether this menu item should be shown for the given request; permission
    23|         checks etc should go here. By default, menu items are shown all the time
    24|         """
    25|         return True
    26|     def is_active(self, request):
    27|         return request.path.startswith(str(self.url))
    28|     def get_context(self, request):
    29|         """Defines context for the template, overridable to use more data"""
    30|         return {
    31|             'name': self.name,
    32|             'url': self.url,
    33|             'classnames': self.classnames,
    34|             'attr_string': self.attr_string,
    35|             'label': self.label,
    36|             'active': self.is_active(request)
    37|         }
    38|     def render_html(self, request):
    39|         context = self.get_context(request)
    40|         return render_to_string(self.template, context, request=request)
    41| class Menu:
    42|     def __init__(self, register_hook_name, construct_hook_name=None):
    43|         self.register_hook_name = register_hook_name
    44|         self.construct_hook_name = construct_hook_name
    45|         self._registered_menu_items = None
    46|     @property
    47|     def registered_menu_items(self):
    48|         if self._registered_menu_items is None:
    49|             self._registered_menu_items = [fn() for fn in hooks.get_hooks(self.register_hook_name)]
    50|         return self._registered_menu_items
    51|     def menu_items_for_request(self, request):
    52|         return [item for item in self.registered_menu_items if item.is_shown(request)]
    53|     def active_menu_items(self, request):
    54|         return [item for item in self.menu_items_for_request(request) if item.is_active(request)]
    55|     @property
    56|     def media(self):
    57|         media = Media()
    58|         for item in self.registered_menu_items:
    59|             media += item.media
    60|         return media
    61|     def render_html(self, request):
    62|         menu_items = self.menu_items_for_request(request)
    63|         if self.construct_hook_name:
    64|             for fn in hooks.get_hooks(self.construct_hook_name):
    65|                 fn(request, menu_items)
    66|         rendered_menu_items = []
    67|         for item in sorted(menu_items, key=lambda i: i.order):
    68|             try:
    69|                 rendered_menu_items.append(item.render_html(request))
    70|             except TypeError:
    71|                 rendered_menu_items.append(item.render_html(request))
    72|         return mark_safe(''.join(rendered_menu_items))
    73| class SubmenuMenuItem(MenuItem):
    74|     template = 'wagtailadmin/shared/menu_submenu_item.html'
    75|     """A MenuItem which wraps an inner Menu object"""
    76|     def __init__(self, label, menu, **kwargs):
    77|         self.menu = menu
    78|         super().__init__(label, '#', **kwargs)
    79|     @property
    80|     def media(self):
    81|         return Media(js=[static('wagtailadmin/js/submenu.js')]) + self.menu.media
    82|     def is_shown(self, request):
    83|         return bool(self.menu.menu_items_for_request(request))
    84|     def is_active(self, request):
    85|         return bool(self.menu.active_menu_items(request))
    86|     def get_context(self, request):
    87|         context = super().get_context(request)
    88|         context['menu_html'] = self.menu.render_html(request)
    89|         context['request'] = request
    90|         return context
    91| admin_menu = Menu(register_hook_name='register_admin_menu_item', construct_hook_name='construct_main_menu')
    92| settings_menu = Menu(register_hook_name='register_settings_menu_item')


# ====================================================================
# FILE: wagtail/admin/messages.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-43 ---
     1| from django.contrib import messages
     2| from django.core.exceptions import NON_FIELD_ERRORS
     3| from django.template.loader import render_to_string
     4| from django.utils.html import format_html, format_html_join
     5| def render(message, buttons, detail=''):
     6|     return render_to_string('wagtailadmin/shared/messages.html', {
     7|         'message': message,
     8|         'buttons': buttons,
     9|         'detail': detail,
    10|     })
    11| def debug(request, message, buttons=None):
    12|     return messages.debug(request, render(message, buttons))
    13| def info(request, message, buttons=None):
    14|     return messages.info(request, render(message, buttons))
    15| def success(request, message, buttons=None):
    16|     return messages.success(request, render(message, buttons))
    17| def warning(request, message, buttons=None):
    18|     return messages.warning(request, render(message, buttons))
    19| def error(request, message, buttons=None):
    20|     return messages.error(request, render(message, buttons))
    21| def validation_error(request, message, form, buttons=None):
    22|     if not form.non_field_errors():
    23|         detail = ''
    24|     else:
    25|         all_errors = []
    26|         for field_name, errors in form.errors.items():
    27|             if field_name == NON_FIELD_ERRORS:
    28|                 prefix = ''
    29|             else:
    30|                 try:
    31|                     field_label = form[field_name].label
    32|                 except KeyError:
    33|                     field_label = field_name
    34|                 prefix = "%s: " % field_label
    35|             for error in errors:
    36|                 all_errors.append(prefix + error)
    37|         errors_html = format_html_join('\n', '<li>{}</li>', ((e,) for e in all_errors))
    38|         detail = format_html("""<ul class="errorlist">{}</ul>""", errors_html)
    39|     return messages.error(request, render(message, buttons, detail=detail))
    40| def button(url, text, new_window=False):
    41|     if url is None:
    42|         raise ValueError("Button URLs must not be None")
    43|     return url, text, new_window


# ====================================================================
# FILE: wagtail/admin/migrations/0001_create_admin_access_permissions.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-35 ---
     1| from django.db import migrations
     2| def create_admin_access_permissions(apps, schema_editor):
     3|     ContentType = apps.get_model('contenttypes.ContentType')
     4|     Permission = apps.get_model('auth.Permission')
     5|     Group = apps.get_model('auth.Group')
     6|     wagtailadmin_content_type, created = ContentType.objects.get_or_create(
     7|         app_label='wagtailadmin',
     8|         model='admin'
     9|     )
    10|     admin_permission, created = Permission.objects.get_or_create(
    11|         content_type=wagtailadmin_content_type,
    12|         codename='access_admin',
    13|         name='Can access Wagtail admin'
    14|     )
    15|     for group in Group.objects.filter(name__in=['Editors', 'Moderators']):
    16|         group.permissions.add(admin_permission)
    17| def remove_admin_access_permissions(apps, schema_editor):
    18|     """Reverse the above additions of permissions."""
    19|     ContentType = apps.get_model('contenttypes.ContentType')
    20|     Permission = apps.get_model('auth.Permission')
    21|     wagtailadmin_content_type = ContentType.objects.get(
    22|         app_label='wagtailadmin',
    23|         model='admin',
    24|     )
    25|     Permission.objects.filter(
    26|         content_type=wagtailadmin_content_type,
    27|         codename='access_admin',
    28|     ).delete()
    29| class Migration(migrations.Migration):
    30|     dependencies = [
    31|         ('wagtailcore', '0026_group_collection_permission'),
    32|     ]
    33|     operations = [
    34|         migrations.RunPython(create_admin_access_permissions, remove_admin_access_permissions),
    35|     ]


# ====================================================================
# FILE: wagtail/admin/modal_workflow.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-17 ---
     1| import json
     2| from django.http import HttpResponse
     3| from django.template.loader import render_to_string
     4| def render_modal_workflow(request, html_template, js_template, template_vars=None):
     5|     """"
     6|     Render a response consisting of an HTML chunk and a JS onload chunk
     7|     in the format required by the modal-workflow framework.
     8|     """
     9|     response_keyvars = []
    10|     if html_template:
    11|         html = render_to_string(html_template, template_vars or {}, request=request)
    12|         response_keyvars.append("'html': %s" % json.dumps(html))
    13|     if js_template:
    14|         js = render_to_string(js_template, template_vars or {}, request=request)
    15|         response_keyvars.append("'onload': %s" % js)
    16|     response_text = "{%s}" % ','.join(response_keyvars)
    17|     return HttpResponse(response_text, content_type="text/javascript")


# ====================================================================
# FILE: wagtail/admin/models.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1 ---
     1| from wagtail.admin import edit_handlers  # NOQA


# ====================================================================
# FILE: wagtail/admin/navigation.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-17 ---
     1| from wagtail.core.models import Page
     2| def get_pages_with_direct_explore_permission(user):
     3|     if user.is_superuser:
     4|         return Page.objects.filter(depth=1)
     5|     else:
     6|         return Page.objects.filter(
     7|             group_permissions__group__in=user.groups.all(),
     8|             group_permissions__permission_type__in=['add', 'edit', 'publish', 'lock']
     9|         )
    10| def get_explorable_root_page(user):
    11|     pages = get_pages_with_direct_explore_permission(user)
    12|     if pages:
    13|         return pages.first_common_ancestor(
    14|             include_self=True,
    15|             strict=True)
    16|     else:
    17|         return None


# ====================================================================
# FILE: wagtail/admin/rich_text/__init__.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-24 ---
     1| from django.conf import settings
     2| from django.utils.module_loading import import_string
     3| from wagtail.admin.rich_text.editors.hallo import (  # NOQA
     4|     HalloFormatPlugin, HalloHeadingPlugin, HalloListPlugin, HalloPlugin, HalloRichTextArea
     5| )
     6| from wagtail.admin.rich_text.editors.draftail import DraftailRichTextArea  # NOQA
     7| DEFAULT_RICH_TEXT_EDITORS = {
     8|     'default': {
     9|         'WIDGET': 'wagtail.admin.rich_text.DraftailRichTextArea'
    10|     }
    11| }
    12| def get_rich_text_editor_widget(name='default', features=None):
    13|     editor_settings = getattr(settings, 'WAGTAILADMIN_RICH_TEXT_EDITORS', DEFAULT_RICH_TEXT_EDITORS)
    14|     editor = editor_settings[name]
    15|     options = editor.get('OPTIONS', None)
    16|     if features is None and options is not None:
    17|         features = options.get('features', None)
    18|     cls = import_string(editor['WIDGET'])
    19|     kwargs = {}
    20|     if options is not None:
    21|         kwargs['options'] = options
    22|     if getattr(cls, 'accepts_features', False):
    23|         kwargs['features'] = features
    24|     return cls(**kwargs)


# ====================================================================
# FILE: wagtail/admin/rich_text/converters/contentstate.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-69 ---
     1| import json
     2| import logging
     3| import re
     4| from draftjs_exporter.defaults import render_children
     5| from draftjs_exporter.dom import DOM
     6| from draftjs_exporter.html import HTML as HTMLExporter
     7| from wagtail.admin.rich_text.converters.html_to_contentstate import HtmlToContentStateHandler
     8| from wagtail.core.rich_text import features as feature_registry
     9| def link_entity(props):
    10|     """
    11|     <a linktype="page" id="1">internal page link</a>
    12|     """
    13|     id_ = props.get('id')
    14|     link_props = {}
    15|     if id_ is not None:
    16|         link_props['linktype'] = 'page'
    17|         link_props['id'] = id_
    18|     else:
    19|         link_props['href'] = props.get('url')
    20|     return DOM.create_element('a', link_props, props['children'])
    21| def br(props):
    22|     if props['block']['type'] == 'code-block':
    23|         return props['children']
    24|     return DOM.create_element('br')
    25| def block_fallback(props):
    26|     type_ = props['block']['type']
    27|     logging.error('Missing config for "%s". Deleting block.' % type_)
    28|     return None
    29| def entity_fallback(props):
    30|     type_ = props['entity']['type']
    31|     logging.warn('Missing config for "%s". Deleting entity' % type_)
    32|     return None
    33| class ContentstateConverter():
    34|     def __init__(self, features=None):
    35|         self.features = features
    36|         self.html_to_contentstate_handler = HtmlToContentStateHandler(features)
    37|         exporter_config = {
    38|             'block_map': {
    39|                 'unstyled': 'p',
    40|                 'atomic': render_children,
    41|                 'fallback': block_fallback,
    42|             },
    43|             'style_map': {},
    44|             'entity_decorators': {
    45|                 'FALLBACK': entity_fallback,
    46|             },
    47|             'composite_decorators': [
    48|                 {
    49|                     'strategy': re.compile(r'\n'),
    50|                     'component': br,
    51|                 },
    52|             ],
    53|             'engine': DOM.STRING,
    54|         }
    55|         for feature in self.features:
    56|             rule = feature_registry.get_converter_rule('contentstate', feature)
    57|             if rule is not None:
    58|                 feature_config = rule['to_database_format']
    59|                 exporter_config['block_map'].update(feature_config.get('block_map', {}))
    60|                 exporter_config['style_map'].update(feature_config.get('style_map', {}))
    61|                 exporter_config['entity_decorators'].update(feature_config.get('entity_decorators', {}))
    62|         self.exporter = HTMLExporter(exporter_config)
    63|     def from_database_format(self, html):
    64|         self.html_to_contentstate_handler.reset()
    65|         self.html_to_contentstate_handler.feed(html)
    66|         self.html_to_contentstate_handler.close()
    67|         return self.html_to_contentstate_handler.contentstate.as_json(indent=4, separators=(',', ': '))
    68|     def to_database_format(self, contentstate_json):
    69|         return self.exporter.render(json.loads(contentstate_json))


# ====================================================================
# FILE: wagtail/admin/rich_text/converters/contentstate_models.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-72 ---
     1| import json
     2| import random
     3| import string
     4| ALPHANUM = string.ascii_lowercase + string.digits
     5| class Block(object):
     6|     def __init__(self, typ, depth=0):
     7|         self.type = typ
     8|         self.depth = depth
     9|         self.text = ""
    10|         self.key = ''.join(random.choice(ALPHANUM) for _ in range(5))
    11|         self.inline_style_ranges = []
    12|         self.entity_ranges = []
    13|     def as_dict(self):
    14|         return {
    15|             'key': self.key,
    16|             'type': self.type,
    17|             'depth': self.depth,
    18|             'text': self.text,
    19|             'inlineStyleRanges': [isr.as_dict() for isr in self.inline_style_ranges],
    20|             'entityRanges': [er.as_dict() for er in self.entity_ranges],
    21|         }
    22| class InlineStyleRange(object):
    23|     def __init__(self, style):
    24|         self.style = style
    25|         self.offset = None
    26|         self.length = None
    27|     def as_dict(self):
    28|         return {
    29|             'offset': self.offset,
    30|             'length': self.length,
    31|             'style': self.style,
    32|         }
    33| class Entity(object):
    34|     def __init__(self, entity_type, mutability, data):
    35|         self.entity_type = entity_type
    36|         self.mutability = mutability
    37|         self.data = data
    38|     def as_dict(self):
    39|         return {
    40|             'mutability': self.mutability,
    41|             'type': self.entity_type,
    42|             'data': self.data,
    43|         }
    44| class EntityRange(object):
    45|     def __init__(self, key):
    46|         self.key = key
    47|         self.offset = None
    48|         self.length = None
    49|     def as_dict(self):
    50|         return {
    51|             'key': self.key,
    52|             'offset': self.offset,
    53|             'length': self.length,
    54|         }
    55| class ContentState(object):
    56|     """Pythonic representation of a draft.js contentState structure"""
    57|     def __init__(self):
    58|         self.blocks = []
    59|         self.entity_count = 0
    60|         self.entity_map = {}
    61|     def add_entity(self, entity):
    62|         key = self.entity_count
    63|         self.entity_map[key] = entity
    64|         self.entity_count += 1
    65|         return key
    66|     def as_dict(self):
    67|         return {
    68|             'blocks': [block.as_dict() for block in self.blocks],
    69|             'entityMap': {key: entity.as_dict() for (key, entity) in self.entity_map.items()},
    70|         }
    71|     def as_json(self, **kwargs):
    72|         return json.dumps(self.as_dict(), **kwargs)


# ====================================================================
# FILE: wagtail/admin/rich_text/converters/editor_html.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-124 ---
     1| import warnings
     2| from django.utils.functional import cached_property
     3| from wagtail.core import hooks
     4| from wagtail.core.rich_text import features as feature_registry
     5| from wagtail.core.rich_text.rewriters import EmbedRewriter, LinkRewriter, MultiRuleRewriter
     6| from wagtail.core.whitelist import Whitelister, allow_without_attributes
     7| from wagtail.utils.deprecation import RemovedInWagtail22Warning
     8| class WhitelistRule:
     9|     def __init__(self, element, handler):
    10|         self.element = element
    11|         self.handler = handler
    12| class EmbedTypeRule:
    13|     def __init__(self, embed_type, handler):
    14|         self.embed_type = embed_type
    15|         self.handler = handler
    16| class LinkTypeRule:
    17|     def __init__(self, link_type, handler):
    18|         self.link_type = link_type
    19|         self.handler = handler
    20| BASE_WHITELIST_RULES = {
    21|     '[document]': allow_without_attributes,
    22|     'p': allow_without_attributes,
    23|     'div': allow_without_attributes,
    24|     'br': allow_without_attributes,
    25| }
    26| class DbWhitelister(Whitelister):
    27|     """
    28|     A custom whitelisting engine to convert the HTML as returned by the rich text editor
    29|     into the pseudo-HTML format stored in the database (in which images, documents and other
    30|     linked objects are identified by ID rather than URL):
    31|     * implements a 'construct_whitelister_element_rules' hook so that other apps can modify
    32|       the whitelist ruleset (e.g. to permit additional HTML elements beyond those in the base
    33|       Whitelister module);
    34|     * replaces any element with a 'data-embedtype' attribute with an <embed> element, with
    35|       attributes supplied by the handler for that type as defined in embed_handlers;
    36|     * rewrites the attributes of any <a> element with a 'data-linktype' attribute, as
    37|       determined by the handler for that type defined in link_handlers, while keeping the
    38|       element content intact.
    39|     """
    40|     def __init__(self, converter_rules):
    41|         self.converter_rules = converter_rules
    42|         self.element_rules = BASE_WHITELIST_RULES.copy()
    43|         for rule in self.converter_rules:
    44|             if isinstance(rule, WhitelistRule):
    45|                 self.element_rules[rule.element] = rule.handler
    46|         construct_whitelist_hooks = hooks.get_hooks('construct_whitelister_element_rules')
    47|         if construct_whitelist_hooks:
    48|             warnings.warn(
    49|                 'The construct_whitelister_element_rules hook is deprecated and will be removed '
    50|                 'in Wagtail 2.2. Use register_rich_text_features instead',
    51|                 RemovedInWagtail22Warning
    52|             )
    53|             for fn in construct_whitelist_hooks:
    54|                 self.element_rules.update(fn())
    55|     @cached_property
    56|     def embed_handlers(self):
    57|         return {
    58|             rule.embed_type: rule.handler for rule in self.converter_rules
    59|             if isinstance(rule, EmbedTypeRule)
    60|         }
    61|     @cached_property
    62|     def link_handlers(self):
    63|         return {
    64|             rule.link_type: rule.handler for rule in self.converter_rules
    65|             if isinstance(rule, LinkTypeRule)
    66|         }
    67|     def clean_tag_node(self, doc, tag):
    68|         if 'data-embedtype' in tag.attrs:
    69|             embed_type = tag['data-embedtype']
    70|             try:
    71|                 embed_handler = self.embed_handlers[embed_type]
    72|             except KeyError:
    73|                 tag.decompose()
    74|                 return
    75|             embed_attrs = embed_handler.get_db_attributes(tag)
    76|             embed_attrs['embedtype'] = embed_type
    77|             embed_tag = doc.new_tag('embed', **embed_attrs)
    78|             embed_tag.can_be_empty_element = True
    79|             tag.replace_with(embed_tag)
    80|         elif tag.name == 'a' and 'data-linktype' in tag.attrs:
    81|             for child in tag.contents:
    82|                 self.clean_node(doc, child)
    83|             link_type = tag['data-linktype']
    84|             try:
    85|                 link_handler = self.link_handlers[link_type]
    86|             except KeyError:
    87|                 tag.unwrap()
    88|                 return
    89|             link_attrs = link_handler.get_db_attributes(tag)
    90|             link_attrs['linktype'] = link_type
    91|             tag.attrs.clear()
    92|             tag.attrs.update(**link_attrs)
    93|         else:
    94|             if tag.name == 'div':
    95|                 tag.name = 'p'
    96|             super(DbWhitelister, self).clean_tag_node(doc, tag)
    97| class EditorHTMLConverter:
    98|     def __init__(self, features=None):
    99|         if features is None:
   100|             features = feature_registry.get_default_features()
   101|         self.converter_rules = []
   102|         for feature in features:
   103|             rule = feature_registry.get_converter_rule('editorhtml', feature)
   104|             if rule is not None:
   105|                 self.converter_rules.extend(rule)
   106|     @cached_property
   107|     def whitelister(self):
   108|         return DbWhitelister(self.converter_rules)
   109|     def to_database_format(self, html):
   110|         return self.whitelister.clean(html)
   111|     @cached_property
   112|     def html_rewriter(self):
   113|         embed_rules = {}
   114|         link_rules = {}
   115|         for rule in self.converter_rules:
   116|             if isinstance(rule, EmbedTypeRule):
   117|                 embed_rules[rule.embed_type] = rule.handler.expand_db_attributes
   118|             elif isinstance(rule, LinkTypeRule):
   119|                 link_rules[rule.link_type] = rule.handler.expand_db_attributes
   120|         return MultiRuleRewriter([
   121|             LinkRewriter(link_rules), EmbedRewriter(embed_rules)
   122|         ])
   123|     def from_database_format(self, html):
   124|         return self.html_rewriter(html)


# ====================================================================
# FILE: wagtail/admin/rich_text/converters/html_ruleset.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-71 ---
     1| import re
     2| from collections import Mapping
     3| ELEMENT_SELECTOR = re.compile(r'^([\w-]+)$')
     4| ELEMENT_WITH_ATTR_SELECTOR = re.compile(r'^([\w-]+)\[([\w-]+)\]$')
     5| ELEMENT_WITH_ATTR_EXACT_SINGLE_QUOTE_SELECTOR = re.compile(r"^([\w-]+)\[([\w-]+)='(.*)'\]$")
     6| ELEMENT_WITH_ATTR_EXACT_DOUBLE_QUOTE_SELECTOR = re.compile(r'^([\w-]+)\[([\w-]+)="(.*)"\]$')
     7| ELEMENT_WITH_ATTR_EXACT_UNQUOTED_SELECTOR = re.compile(r"^([\w-]+)\[([\w-]+)=([\w-]+)\]$")
     8| class HTMLRuleset():
     9|     """
    10|     Maintains a set of rules for matching HTML elements.
    11|     Each rule defines a mapping from a CSS-like selector to an arbitrary result object.
    12|     The following forms of rule are currently supported:
    13|     'a' = matches any <a> element
    14|     'a[href]' = matches any <a> element with an 'href' attribute
    15|     'a[linktype="page"]' = matches any <a> element with a 'linktype' attribute equal to 'page'
    16|     """
    17|     def __init__(self, rules=None):
    18|         self.element_rules = {}
    19|         if rules:
    20|             self.add_rules(rules)
    21|     def add_rules(self, rules):
    22|         if isinstance(rules, Mapping):
    23|             rules = rules.items()
    24|         for selector, result in rules:
    25|             self.add_rule(selector, result)
    26|     def _add_element_rule(self, name, result):
    27|         self.element_rules.setdefault(name, []).append(
    28|             ((lambda attrs: True), result)
    29|         )
    30|     def _add_element_with_attr_rule(self, name, attr, result):
    31|         self.element_rules.setdefault(name, []).append(
    32|             ((lambda attrs: attr in attrs), result)
    33|         )
    34|     def _add_element_with_attr_exact_rule(self, name, attr, value, result):
    35|         self.element_rules.setdefault(name, []).append(
    36|             ((lambda attrs: attr in attrs and attrs[attr] == value), result)
    37|         )
    38|     def add_rule(self, selector, result):
    39|         match = ELEMENT_SELECTOR.match(selector)
    40|         if match:
    41|             name = match.group(1)
    42|             self._add_element_rule(name, result)
    43|             return
    44|         match = ELEMENT_WITH_ATTR_SELECTOR.match(selector)
    45|         if match:
    46|             name, attr = match.groups()
    47|             self._add_element_with_attr_rule(name, attr, result)
    48|             return
    49|         for regex in (
    50|             ELEMENT_WITH_ATTR_EXACT_SINGLE_QUOTE_SELECTOR,
    51|             ELEMENT_WITH_ATTR_EXACT_DOUBLE_QUOTE_SELECTOR,
    52|             ELEMENT_WITH_ATTR_EXACT_UNQUOTED_SELECTOR
    53|         ):
    54|             match = regex.match(selector)
    55|             if match:
    56|                 name, attr, value = match.groups()
    57|                 self._add_element_with_attr_exact_rule(name, attr, value, result)
    58|                 return
    59|     def match(self, name, attrs):
    60|         """
    61|         Look for a rule matching an HTML element with the given name and attribute dict,
    62|         and return the corresponding result object. If no rule matches, return None.
    63|         If multiple rules match, the one chosen is undetermined.
    64|         """
    65|         try:
    66|             rules_to_test = self.element_rules[name]
    67|         except KeyError:
    68|             return None
    69|         for attr_check, result in rules_to_test:
    70|             if attr_check(attrs):
    71|                 return result


# ====================================================================
# FILE: wagtail/admin/rich_text/converters/html_to_contentstate.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-233 ---
     1| import re
     2| from html.parser import HTMLParser
     3| from wagtail.admin.rich_text.converters.contentstate_models import (
     4|     Block, ContentState, Entity, EntityRange, InlineStyleRange)
     5| from wagtail.admin.rich_text.converters.html_ruleset import HTMLRuleset
     6| from wagtail.core.models import Page
     7| from wagtail.core.rich_text import features as feature_registry
     8| STRIP_WHITESPACE = 0
     9| KEEP_WHITESPACE = 1
    10| FORCE_WHITESPACE = 2
    11| WHITESPACE_RE = re.compile(r'\s+')
    12| class HandlerState:
    13|     def __init__(self):
    14|         self.current_block = None
    15|         self.current_inline_styles = []
    16|         self.current_entity_ranges = []
    17|         self.leading_whitespace = STRIP_WHITESPACE
    18|         self.list_depth = 0
    19|         self.list_item_type = None
    20|         self.has_preceding_nonatomic_block = False
    21|         self.pushed_states = []
    22|     def push(self):
    23|         self.pushed_states.append({
    24|             'current_block': self.current_block,
    25|             'current_inline_styles': self.current_inline_styles,
    26|             'current_entity_ranges': self.current_entity_ranges,
    27|             'leading_whitespace': self.leading_whitespace,
    28|             'list_depth': self.list_depth,
    29|             'list_item_type': self.list_item_type,
    30|         })
    31|     def pop(self):
    32|         last_state = self.pushed_states.pop()
    33|         self.current_block = last_state['current_block']
    34|         self.current_inline_styles = last_state['current_inline_styles']
    35|         self.current_entity_ranges = last_state['current_entity_ranges']
    36|         self.leading_whitespace = last_state['leading_whitespace']
    37|         self.list_depth = last_state['list_depth']
    38|         self.list_item_type = last_state['list_item_type']
    39| def add_paragraph_block(state, contentstate):
    40|     """
    41|     Utility function for adding an unstyled (paragraph) block to contentstate;
    42|     useful for element handlers that aren't paragraph elements themselves, but need
    43|     to insert paragraphs to ensure correctness
    44|     """
    45|     block = Block('unstyled', depth=state.list_depth)
    46|     contentstate.blocks.append(block)
    47|     state.current_block = block
    48|     state.leading_whitespace = STRIP_WHITESPACE
    49|     state.has_preceding_nonatomic_block = True
    50| class ListElementHandler:
    51|     """ Handler for <ul> / <ol> tags """
    52|     def __init__(self, list_item_type):
    53|         self.list_item_type = list_item_type
    54|     def handle_starttag(self, name, attrs, state, contentstate):
    55|         state.push()
    56|         if state.list_item_type is None:
    57|             pass
    58|         else:
    59|             state.list_depth += 1
    60|         state.list_item_type = self.list_item_type
    61|     def handle_endtag(self, name, state, contentstate):
    62|         state.pop()
    63| class BlockElementHandler:
    64|     def __init__(self, block_type):
    65|         self.block_type = block_type
    66|     def create_block(self, name, attrs, state, contentstate):
    67|         return Block(self.block_type, depth=state.list_depth)
    68|     def handle_starttag(self, name, attrs, state, contentstate):
    69|         attr_dict = dict(attrs)  # convert attrs from list of (name, value) tuples to a dict
    70|         block = self.create_block(name, attr_dict, state, contentstate)
    71|         contentstate.blocks.append(block)
    72|         state.current_block = block
    73|         state.leading_whitespace = STRIP_WHITESPACE
    74|         state.has_preceding_nonatomic_block = True
    75|     def handle_endtag(self, name, state, contentState):
    76|         assert not state.current_inline_styles, "End of block reached without closing inline style elements"
    77|         assert not state.current_entity_ranges, "End of block reached without closing entity elements"
    78|         state.current_block = None
    79| class ListItemElementHandler(BlockElementHandler):
    80|     """ Handler for <li> tag """
    81|     def __init__(self):
    82|         pass  # skip setting self.block_type
    83|     def create_block(self, name, attrs, state, contentstate):
    84|         assert state.list_item_type is not None, "%s element found outside of an enclosing list element" % name
    85|         return Block(state.list_item_type, depth=state.list_depth)
    86| class InlineStyleElementHandler:
    87|     def __init__(self, style):
    88|         self.style = style
    89|     def handle_starttag(self, name, attrs, state, contentstate):
    90|         if state.current_block is None:
    91|             add_paragraph_block(state, contentstate)
    92|         if state.leading_whitespace == FORCE_WHITESPACE:
    93|             state.current_block.text += ' '
    94|             state.leading_whitespace = STRIP_WHITESPACE
    95|         inline_style_range = InlineStyleRange(self.style)
    96|         inline_style_range.offset = len(state.current_block.text)
    97|         state.current_block.inline_style_ranges.append(inline_style_range)
    98|         state.current_inline_styles.append(inline_style_range)
    99|     def handle_endtag(self, name, state, contentstate):
   100|         inline_style_range = state.current_inline_styles.pop()
   101|         assert inline_style_range.style == self.style
   102|         inline_style_range.length = len(state.current_block.text) - inline_style_range.offset
   103| class InlineEntityElementHandler:
   104|     """
   105|     Abstract superclass for elements that will be represented as inline entities.
   106|     Subclasses should define a `mutability` property
   107|     """
   108|     def __init__(self, entity_type):
   109|         self.entity_type = entity_type
   110|     def handle_starttag(self, name, attrs, state, contentstate):
   111|         if state.current_block is None:
   112|             add_paragraph_block(state, contentstate)
   113|         if state.leading_whitespace == FORCE_WHITESPACE:
   114|             state.current_block.text += ' '
   115|             state.leading_whitespace = STRIP_WHITESPACE
   116|         attrs = dict(attrs)
   117|         entity = Entity(self.entity_type, self.mutability, self.get_attribute_data(attrs))
   118|         key = contentstate.add_entity(entity)
   119|         entity_range = EntityRange(key)
   120|         entity_range.offset = len(state.current_block.text)
   121|         state.current_block.entity_ranges.append(entity_range)
   122|         state.current_entity_ranges.append(entity_range)
   123|     def get_attribute_data(self, attrs):
   124|         """
   125|         Given a dict of attributes found on the source element, return the data dict
   126|         to be associated with the resulting entity
   127|         """
   128|         return {}
   129|     def handle_endtag(self, name, state, contentstate):
   130|         entity_range = state.current_entity_ranges.pop()
   131|         entity_range.length = len(state.current_block.text) - entity_range.offset
   132| class LinkElementHandler(InlineEntityElementHandler):
   133|     mutability = 'MUTABLE'
   134| class ExternalLinkElementHandler(LinkElementHandler):
   135|     def get_attribute_data(self, attrs):
   136|         return {'url': attrs['href']}
   137| class PageLinkElementHandler(LinkElementHandler):
   138|     def get_attribute_data(self, attrs):
   139|         try:
   140|             page = Page.objects.get(id=attrs['id']).specific
   141|         except Page.DoesNotExist:
   142|             return {}
   143|         return {
   144|             'id': page.id,
   145|             'url': page.url,
   146|             'parentId': page.get_parent().id,
   147|         }
   148| class AtomicBlockEntityElementHandler:
   149|     """
   150|     Handler for elements like <img> that exist as a single immutable item at the block level
   151|     """
   152|     def handle_starttag(self, name, attrs, state, contentstate):
   153|         state.current_block = None
   154|         if not state.has_preceding_nonatomic_block:
   155|             add_paragraph_block(state, contentstate)
   156|         attr_dict = dict(attrs)  # convert attrs from list of (name, value) tuples to a dict
   157|         entity = self.create_entity(name, attr_dict, state, contentstate)
   158|         key = contentstate.add_entity(entity)
   159|         block = Block('atomic', depth=state.list_depth)
   160|         contentstate.blocks.append(block)
   161|         block.text = ' '
   162|         entity_range = EntityRange(key)
   163|         entity_range.offset = 0
   164|         entity_range.length = 1
   165|         block.entity_ranges.append(entity_range)
   166|         state.has_preceding_nonatomic_block = False
   167|     def handle_endtag(self, name, state, contentstate):
   168|         pass
   169| class HorizontalRuleHandler(AtomicBlockEntityElementHandler):
   170|     def create_entity(self, name, attrs, state, contentstate):
   171|         return Entity('HORIZONTAL_RULE', 'IMMUTABLE', {})
   172| class LineBreakHandler:
   173|     def handle_starttag(self, name, attrs, state, contentstate):
   174|         if state.current_block is None:
   175|             return
   176|         state.current_block.text += '\n'
   177|     def handle_endtag(self, name, state, contentstate):
   178|         pass
   179| class HtmlToContentStateHandler(HTMLParser):
   180|     def __init__(self, features=()):
   181|         self.paragraph_handler = BlockElementHandler('unstyled')
   182|         self.element_handlers = HTMLRuleset({
   183|             'p': self.paragraph_handler,
   184|             'br': LineBreakHandler(),
   185|         })
   186|         for feature in features:
   187|             rule = feature_registry.get_converter_rule('contentstate', feature)
   188|             if rule is not None:
   189|                 self.element_handlers.add_rules(rule['from_database_format'])
   190|         super().__init__(convert_charrefs=True)
   191|     def reset(self):
   192|         self.state = HandlerState()
   193|         self.contentstate = ContentState()
   194|         self.open_elements = []
   195|         super().reset()
   196|     def handle_starttag(self, name, attrs):
   197|         attr_dict = dict(attrs)  # convert attrs from list of (name, value) tuples to a dict
   198|         element_handler = self.element_handlers.match(name, attr_dict)
   199|         if element_handler is None and not self.open_elements:
   200|             element_handler = self.paragraph_handler
   201|         self.open_elements.append((name, element_handler))
   202|         if element_handler:
   203|             element_handler.handle_starttag(name, attrs, self.state, self.contentstate)
   204|     def handle_endtag(self, name):
   205|         expected_name, element_handler = self.open_elements.pop()
   206|         assert name == expected_name, "Unmatched tags: expected %s, got %s" % (expected_name, name)
   207|         if element_handler:
   208|             element_handler.handle_endtag(name, self.state, self.contentstate)
   209|     def handle_data(self, content):
   210|         content = re.sub(WHITESPACE_RE, ' ', content)
   211|         if self.state.current_block is None:
   212|             if content == ' ':
   213|                 return
   214|             else:
   215|                 add_paragraph_block(self.state, self.contentstate)
   216|         if content == ' ':
   217|             if self.state.leading_whitespace != STRIP_WHITESPACE:
   218|                 self.state.leading_whitespace = FORCE_WHITESPACE
   219|         else:
   220|             if self.state.leading_whitespace == STRIP_WHITESPACE:
   221|                 content = content.lstrip()
   222|             elif self.state.leading_whitespace == FORCE_WHITESPACE and not content.startswith(' '):
   223|                 content = ' ' + content
   224|             if content.endswith(' '):
   225|                 content = content.rstrip()
   226|                 self.state.leading_whitespace = FORCE_WHITESPACE
   227|             else:
   228|                 self.state.leading_whitespace = KEEP_WHITESPACE
   229|             self.state.current_block.text += content
   230|     def close(self):
   231|         if not self.state.has_preceding_nonatomic_block:
   232|             add_paragraph_block(self.state, self.contentstate)
   233|         super().close()


# ====================================================================
# FILE: wagtail/admin/rich_text/editors/draftail/__init__.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-46 ---
     1| import json
     2| from django.forms import Media, widgets
     3| from wagtail.admin.edit_handlers import RichTextFieldPanel
     4| from wagtail.admin.rich_text.converters.contentstate import ContentstateConverter
     5| from wagtail.core.rich_text import features as feature_registry
     6| from wagtail.utils.widgets import WidgetWithScript
     7| class DraftailRichTextArea(WidgetWithScript, widgets.HiddenInput):
     8|     accepts_features = True
     9|     def get_panel(self):
    10|         return RichTextFieldPanel
    11|     def __init__(self, *args, **kwargs):
    12|         self.options = {}
    13|         self.features = kwargs.pop('features', None)
    14|         if self.features is None:
    15|             self.features = feature_registry.get_default_features()
    16|         for feature in self.features:
    17|             plugin = feature_registry.get_editor_plugin('draftail', feature)
    18|             if plugin:
    19|                 plugin.construct_options(self.options)
    20|         self.converter = ContentstateConverter(self.features)
    21|         super().__init__(*args, **kwargs)
    22|     def translate_value(self, value):
    23|         if value is None:
    24|             value = ''
    25|         return self.converter.from_database_format(value)
    26|     def render(self, name, value, attrs=None):
    27|         if attrs is None:
    28|             attrs = {}
    29|         attrs['data-draftail-input'] = True
    30|         translated_value = self.translate_value(value)
    31|         return super().render(name, translated_value, attrs)
    32|     def render_js_init(self, id_, name, value):
    33|         return "window.draftail.initEditor('#{id}', {opts}, document.currentScript)".format(
    34|             id=id_, opts=json.dumps(self.options))
    35|     def value_from_datadict(self, data, files, name):
    36|         original_value = super().value_from_datadict(data, files, name)
    37|         if original_value is None:
    38|             return None
    39|         return self.converter.to_database_format(original_value)
    40|     @property
    41|     def media(self):
    42|         return Media(js=[
    43|             'wagtailadmin/js/draftail.js',
    44|         ], css={
    45|             'all': ['wagtailadmin/css/panels/draftail.css']
    46|         })


# ====================================================================
# FILE: wagtail/admin/rich_text/editors/draftail/features.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| class BooleanFeature:
     2|     """
     3|     A feature which is enabled by a boolean flag at the top level of
     4|     the options dict
     5|     """
     6|     def __init__(self, option_name):
     7|         self.option_name = option_name
     8|     def construct_options(self, options):
     9|         options[self.option_name] = True
    10| class ListFeature:
    11|     """
    12|     Abstract class for features that are defined in a list within the options dict.
    13|     Subclasses must define option_name
    14|     """
    15|     def __init__(self, data):
    16|         self.data = data
    17|     def construct_options(self, options):
    18|         if self.option_name not in options:
    19|             options[self.option_name] = []
    20|         options[self.option_name].append(self.data)
    21| class EntityFeature(ListFeature):
    22|     """A feature which is listed in the entityTypes list of the options"""
    23|     option_name = 'entityTypes'
    24| class BlockFeature(ListFeature):
    25|     """A feature which is listed in the blockTypes list of the options"""
    26|     option_name = 'blockTypes'
    27| class InlineStyleFeature(ListFeature):
    28|     """A feature which is listed in the inlineStyles list of the options"""
    29|     option_name = 'inlineStyles'

