# ====================================================================
# FILE: setup.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-114 ---
     1| from wagtail import __version__
     2| from wagtail.utils.setup import assets, check_bdist_egg, sdist
     3| try:
     4|     from setuptools import find_packages, setup
     5| except ImportError:
     6|     from distutils.core import setup
     7| try:
     8|     import multiprocessing  # noqa: F401
     9| except ImportError:
    10|     pass
    11| install_requires = [
    12|     "Django>=3.2,<5.1",
    13|     "django-modelcluster>=6.1,<7.0",
    14|     "django-permissionedforms>=0.1,<1.0",
    15|     "django-taggit>=2.0,<5.0",
    16|     "django-treebeard>=4.5.1,<5.0",
    17|     "djangorestframework>=3.11.1,<4.0",
    18|     "django-filter>=23.3,<24",
    19|     "draftjs_exporter>=2.1.5,<3.0",
    20|     "Pillow>=9.1.0,<11.0.0",
    21|     "beautifulsoup4>=4.8,<4.12",
    22|     "html5lib>=0.999,<2",
    23|     "Willow[heif]>=1.6.2,<1.7",
    24|     "requests>=2.11.1,<3.0",
    25|     "l18n>=2018.5",
    26|     "openpyxl>=3.0.10,<4.0",
    27|     "anyascii>=0.1.5",
    28|     "telepath>=0.3.1,<1",
    29| ]
    30| testing_extras = [
    31|     "python-dateutil>=2.7",
    32|     "pytz>=2014.7",
    33|     "Jinja2>=3.0,<3.2",
    34|     "boto3>=1.28,<2",
    35|     "freezegun>=0.3.8",
    36|     "azure-mgmt-cdn>=12.0,<13.0",
    37|     "azure-mgmt-frontdoor>=1.0,<1.1",
    38|     "django-pattern-library>=0.7",
    39|     "coverage>=3.7.0",
    40|     "black==22.3.0",
    41|     "doc8==0.8.1",
    42|     "ruff==0.0.290",
    43|     "semgrep==1.40.0",
    44|     "curlylint==0.13.1",
    45|     "djhtml==1.5.2",
    46|     "polib>=1.1,<2.0",
    47|     "factory-boy>=3.2",
    48|     "tblib>=2.0,<3.0",
    49| ]
    50| documentation_extras = [
    51|     "pyenchant>=3.1.1,<4",
    52|     "sphinxcontrib-spelling>=5.4.0,<6",
    53|     "Sphinx>=1.5.2",
    54|     "sphinx-autobuild>=0.6.0",
    55|     "sphinx-wagtail-theme==6.1.1",
    56|     "myst_parser==0.18.1",
    57|     "sphinx_copybutton>=0.5,<1.0",
    58| ]
    59| setup(
    60|     name="wagtail",
    61|     version=__version__,
    62|     description="A Django content management system.",
    63|     author="Wagtail core team + contributors",
    64|     author_email="hello@wagtail.org",  # For support queries, please see https://docs.wagtail.org/en/stable/support.html
    65|     url="https://wagtail.org/",
    66|     project_urls={
    67|         "Changelog": "https://github.com/wagtail/wagtail/blob/main/CHANGELOG.txt",
    68|         "Documentation": "https://docs.wagtail.org",
    69|         "Source": "https://github.com/wagtail/wagtail",
    70|         "Tracker": "https://github.com/wagtail/wagtail/issues",
    71|     },
    72|     packages=find_packages(),
    73|     include_package_data=True,
    74|     license="BSD",
    75|     long_description="Wagtail is an open source content management \
    76| system built on Django, with a strong community and commercial support. \
    77| Itâ€™s focused on user experience, and offers precise control for \
    78| designers and developers.\n\n\
    79| For more details, see https://wagtail.org, https://docs.wagtail.org and \
    80| https://github.com/wagtail/wagtail/.",
    81|     classifiers=[
    82|         "Development Status :: 5 - Production/Stable",
    83|         "Environment :: Web Environment",
    84|         "Intended Audience :: Developers",
    85|         "License :: OSI Approved :: BSD License",
    86|         "Operating System :: OS Independent",
    87|         "Programming Language :: Python",
    88|         "Programming Language :: Python :: 3",
    89|         "Programming Language :: Python :: 3.8",
    90|         "Programming Language :: Python :: 3.9",
    91|         "Programming Language :: Python :: 3.10",
    92|         "Programming Language :: Python :: 3.11",
    93|         "Framework :: Django",
    94|         "Framework :: Django :: 3.2",
    95|         "Framework :: Django :: 4.1",
    96|         "Framework :: Django :: 4.2",
    97|         "Framework :: Django :: 5.0",
    98|         "Framework :: Wagtail",
    99|         "Topic :: Internet :: WWW/HTTP :: Site Management",
   100|     ],
   101|     python_requires=">=3.8",
   102|     install_requires=install_requires,
   103|     extras_require={"testing": testing_extras, "docs": documentation_extras},
   104|     entry_points="""
   105|             [console_scripts]
   106|             wagtail=wagtail.bin.wagtail:main
   107|     """,
   108|     zip_safe=False,
   109|     cmdclass={
   110|         "sdist": sdist,
   111|         "bdist_egg": check_bdist_egg,
   112|         "assets": assets,
   113|     },
   114| )


# ====================================================================
# FILE: wagtail/__init__.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-9 ---
     1| from wagtail.utils.version import get_semver_version, get_version
     2| VERSION = (5, 2, 6, "final", 1)
     3| __version__ = get_version(VERSION)
     4| __semver__ = get_semver_version(VERSION)
     5| def setup():
     6|     import warnings
     7|     from wagtail.utils.deprecation import removed_in_next_version_warning
     8|     warnings.simplefilter("default", removed_in_next_version_warning)
     9| setup()


# ====================================================================
# FILE: wagtail/images/views/images.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-343 ---
     1| import os
     2| from tempfile import SpooledTemporaryFile
     3| from django.conf import settings
     4| from django.core.exceptions import PermissionDenied
     5| from django.core.paginator import InvalidPage, Paginator
     6| from django.http import FileResponse, Http404, HttpResponse, JsonResponse
     7| from django.shortcuts import get_object_or_404, redirect
     8| from django.template.response import TemplateResponse
     9| from django.urls import reverse
    10| from django.urls.exceptions import NoReverseMatch
    11| from django.utils.decorators import method_decorator
    12| from django.utils.http import urlencode
    13| from django.utils.translation import gettext as _
    14| from django.utils.translation import gettext_lazy, ngettext
    15| from django.views.generic import TemplateView
    16| from wagtail.admin import messages
    17| from wagtail.admin.auth import PermissionPolicyChecker
    18| from wagtail.admin.forms.search import SearchForm
    19| from wagtail.admin.models import popular_tags_for_model
    20| from wagtail.admin.utils import get_valid_next_url_from_request
    21| from wagtail.admin.views import generic
    22| from wagtail.images import get_image_model
    23| from wagtail.images.exceptions import InvalidFilterSpecError
    24| from wagtail.images.forms import URLGeneratorForm, get_image_form
    25| from wagtail.images.models import Filter, SourceImageIOError
    26| from wagtail.images.permissions import permission_policy
    27| from wagtail.images.utils import generate_signature
    28| from wagtail.models import Collection, Site
    29| from wagtail.search.backends import get_search_backend
    30| permission_checker = PermissionPolicyChecker(permission_policy)
    31| INDEX_PAGE_SIZE = getattr(settings, "WAGTAILIMAGES_INDEX_PAGE_SIZE", 30)
    32| USAGE_PAGE_SIZE = getattr(settings, "WAGTAILIMAGES_USAGE_PAGE_SIZE", 20)
    33| class BaseListingView(TemplateView):
    34|     ENTRIES_PER_PAGE_CHOICES = sorted({10, 30, 60, 100, 250, INDEX_PAGE_SIZE})
    35|     ORDERING_OPTIONS = {
    36|         "-created_at": _("Newest"),
    37|         "created_at": _("Oldest"),
    38|         "title": _("Title: (A -> Z)"),
    39|         "-title": _("Title: (Z -> A)"),
    40|         "file_size": _("File size: (low to high)"),
    41|         "-file_size": _("File size: (high to low)"),
    42|     }
    43|     default_ordering = "-created_at"
    44|     @method_decorator(permission_checker.require_any("add", "change", "delete"))
    45|     def get(self, request):
    46|         return super().get(request)
    47|     def get_num_entries_per_page(self):
    48|         entries_per_page = self.request.GET.get("entries_per_page", INDEX_PAGE_SIZE)
    49|         try:
    50|             entries_per_page = int(entries_per_page)
    51|         except ValueError:
    52|             entries_per_page = INDEX_PAGE_SIZE
    53|         if entries_per_page not in self.ENTRIES_PER_PAGE_CHOICES:
    54|             entries_per_page = INDEX_PAGE_SIZE
    55|         return entries_per_page
    56|     def get_valid_orderings(self):
    57|         return self.ORDERING_OPTIONS
    58|     def get_ordering(self):
    59|         ordering = self.request.GET.get("ordering")
    60|         if ordering is None or ordering not in self.get_valid_orderings():
    61|             ordering = self.default_ordering
    62|         return ordering
    63|     def get_context_data(self, **kwargs):
    64|         context = super().get_context_data(**kwargs)
    65|         ordering = self.get_ordering()
    66|         images = (
    67|             permission_policy.instances_user_has_any_permission_for(
    68|                 self.request.user, ["change", "delete"]
    69|             )
    70|             .order_by(ordering)
    71|             .select_related("collection")
    72|             .prefetch_renditions("max-165x165")
    73|         )
    74|         self.current_collection = None
    75|         collection_id = self.request.GET.get("collection_id")
    76|         if collection_id:
    77|             try:
    78|                 self.current_collection = Collection.objects.get(id=collection_id)
    79|                 images = images.filter(collection=self.current_collection)
    80|             except (ValueError, Collection.DoesNotExist):
    81|                 pass
    82|         query_string = None
    83|         if "q" in self.request.GET:
    84|             self.form = SearchForm(self.request.GET, placeholder=_("Search images"))
    85|             if self.form.is_valid():
    86|                 query_string = self.form.cleaned_data["q"]
    87|                 if query_string:
    88|                     search_backend = get_search_backend()
    89|                     images = search_backend.autocomplete(query_string, images)
    90|         else:
    91|             self.form = SearchForm(placeholder=_("Search images"))
    92|         self.current_tag = self.request.GET.get("tag")
    93|         if self.current_tag:
    94|             try:
    95|                 images = images.filter(tags__name=self.current_tag)
    96|             except (AttributeError):
    97|                 self.current_tag = None
    98|         entries_per_page = self.get_num_entries_per_page()
    99|         paginator = Paginator(images, per_page=entries_per_page)
   100|         try:
   101|             images = paginator.page(self.request.GET.get("p", 1))
   102|         except InvalidPage:
   103|             raise Http404
   104|         next_url = reverse("wagtailimages:index")
   105|         request_query_string = self.request.META.get("QUERY_STRING")
   106|         if request_query_string:
   107|             next_url += "?" + request_query_string
   108|         context.update(
   109|             {
   110|                 "images": images,
   111|                 "query_string": query_string,
   112|                 "is_searching": bool(query_string),
   113|                 "next": next_url,
   114|                 "entries_per_page": entries_per_page,
   115|                 "ENTRIES_PER_PAGE_CHOICES": self.ENTRIES_PER_PAGE_CHOICES,
   116|                 "current_ordering": ordering,
   117|                 "ORDERING_OPTIONS": self.ORDERING_OPTIONS,
   118|             }
   119|         )
   120|         return context
   121| class IndexView(BaseListingView):
   122|     template_name = "wagtailimages/images/index.html"
   123|     def get_context_data(self, **kwargs):
   124|         context = super().get_context_data(**kwargs)
   125|         collections = permission_policy.collections_user_has_any_permission_for(
   126|             self.request.user, ["add", "change"]
   127|         )
   128|         if len(collections) < 2:
   129|             collections = None
   130|         Image = get_image_model()
   131|         context.update(
   132|             {
   133|                 "search_form": self.form,
   134|                 "popular_tags": popular_tags_for_model(get_image_model()),
   135|                 "current_tag": self.current_tag,
   136|                 "collections": collections,
   137|                 "current_collection": self.current_collection,
   138|                 "user_can_add": permission_policy.user_has_permission(
   139|                     self.request.user, "add"
   140|                 ),
   141|                 "app_label": Image._meta.app_label,
   142|                 "model_name": Image._meta.model_name,
   143|             }
   144|         )
   145|         return context
   146| class ListingResultsView(BaseListingView):
   147|     template_name = "wagtailimages/images/results.html"
   148| @permission_checker.require("change")
   149| def edit(request, image_id):
   150|     Image = get_image_model()
   151|     ImageForm = get_image_form(Image)
   152|     image = get_object_or_404(Image, id=image_id)
   153|     if not permission_policy.user_has_permission_for_instance(
   154|         request.user, "change", image
   155|     ):
   156|         raise PermissionDenied
   157|     next_url = get_valid_next_url_from_request(request)
   158|     if request.method == "POST":
   159|         form = ImageForm(request.POST, request.FILES, instance=image, user=request.user)
   160|         if form.is_valid():
   161|             form.save()
   162|             edit_url = reverse("wagtailimages:edit", args=(image.id,))
   163|             redirect_url = "wagtailimages:index"
   164|             if next_url:
   165|                 edit_url = f"{edit_url}?{urlencode({'next': next_url})}"
   166|                 redirect_url = next_url
   167|             messages.success(
   168|                 request,
   169|                 _("Image '%(image_title)s' updated.") % {"image_title": image.title},
   170|                 buttons=[messages.button(edit_url, _("Edit again"))],
   171|             )
   172|             return redirect(redirect_url)
   173|         else:
   174|             messages.error(request, _("The image could not be saved due to errors."))
   175|     else:
   176|         form = ImageForm(instance=image, user=request.user)
   177|     try:
   178|         reverse("wagtailimages_serve", args=("foo", "1", "bar"))
   179|         url_generator_enabled = True
   180|     except NoReverseMatch:
   181|         url_generator_enabled = False
   182|     if image.is_stored_locally():
   183|         if not os.path.isfile(image.file.path):
   184|             messages.error(
   185|                 request,
   186|                 _(
   187|                     "The source image file could not be found. Please change the source or delete the image."
   188|                 )
   189|                 % {"image_title": image.title},
   190|                 buttons=[
   191|                     messages.button(
   192|                         reverse("wagtailimages:delete", args=(image.id,)), _("Delete")
   193|                     )
   194|                 ],
   195|             )
   196|     try:
   197|         filesize = image.get_file_size()
   198|     except SourceImageIOError:
   199|         filesize = None
   200|     return TemplateResponse(
   201|         request,
   202|         "wagtailimages/images/edit.html",
   203|         {
   204|             "image": image,
   205|             "form": form,
   206|             "url_generator_enabled": url_generator_enabled,
   207|             "filesize": filesize,
   208|             "user_can_delete": permission_policy.user_has_permission_for_instance(
   209|                 request.user, "delete", image
   210|             ),
   211|             "next": next_url,
   212|         },
   213|     )
   214| def url_generator(request, image_id):
   215|     image = get_object_or_404(get_image_model(), id=image_id)
   216|     if not permission_policy.user_has_permission_for_instance(
   217|         request.user, "change", image
   218|     ):
   219|         raise PermissionDenied
   220|     form = URLGeneratorForm(
   221|         initial={
   222|             "filter_method": "original",
   223|             "width": image.width,
   224|             "height": image.height,
   225|         }
   226|     )
   227|     return TemplateResponse(
   228|         request,
   229|         "wagtailimages/images/url_generator.html",
   230|         {
   231|             "image": image,
   232|             "form": form,
   233|         },
   234|     )
   235| def generate_url(request, image_id, filter_spec):
   236|     Image = get_image_model()
   237|     try:
   238|         image = Image.objects.get(id=image_id)
   239|     except Image.DoesNotExist:
   240|         return JsonResponse({"error": "Cannot find image."}, status=404)
   241|     if not permission_policy.user_has_permission_for_instance(
   242|         request.user, "change", image
   243|     ):
   244|         return JsonResponse(
   245|             {"error": "You do not have permission to generate a URL for this image."},
   246|             status=403,
   247|         )
   248|     try:
   249|         Filter(spec=filter_spec).operations
   250|     except InvalidFilterSpecError:
   251|         return JsonResponse({"error": "Invalid filter spec."}, status=400)
   252|     signature = generate_signature(image_id, filter_spec)
   253|     url = reverse("wagtailimages_serve", args=(signature, image_id, filter_spec))
   254|     try:
   255|         site_root_url = Site.objects.get(is_default_site=True).root_url
   256|     except Site.DoesNotExist:
   257|         site_root_url = Site.objects.first().root_url
   258|     preview_url = reverse("wagtailimages:preview", args=(image_id, filter_spec))
   259|     return JsonResponse(
   260|         {"url": site_root_url + url, "preview_url": preview_url}, status=200
   261|     )
   262| def preview(request, image_id, filter_spec):
   263|     image = get_object_or_404(get_image_model(), id=image_id)
   264|     try:
   265|         temp_image = SpooledTemporaryFile(max_size=settings.FILE_UPLOAD_MAX_MEMORY_SIZE)
   266|         image = Filter(spec=filter_spec).run(image, temp_image)
   267|         temp_image.seek(0)
   268|         response = FileResponse(temp_image)
   269|         response["Content-Type"] = "image/" + image.format_name
   270|         return response
   271|     except InvalidFilterSpecError:
   272|         return HttpResponse(
   273|             "Invalid filter spec: " + filter_spec, content_type="text/plain", status=400
   274|         )
   275| class DeleteView(generic.DeleteView):
   276|     model = get_image_model()
   277|     pk_url_kwarg = "image_id"
   278|     permission_policy = permission_policy
   279|     permission_required = "delete"
   280|     header_icon = "image"
   281|     template_name = "wagtailimages/images/confirm_delete.html"
   282|     usage_url_name = "wagtailimages:image_usage"
   283|     delete_url_name = "wagtailimages:delete"
   284|     index_url_name = "wagtailimages:index"
   285|     page_title = gettext_lazy("Delete image")
   286|     def user_has_permission(self, permission):
   287|         return self.permission_policy.user_has_permission_for_instance(
   288|             self.request.user, permission, self.object
   289|         )
   290|     @property
   291|     def confirmation_message(self):
   292|         return ngettext(
   293|             "Are you sure you want to delete this image?",
   294|             "Are you sure you want to delete these images?",
   295|             1,
   296|         )
   297|     def get_success_message(self):
   298|         return _("Image '%(image_title)s' deleted.") % {
   299|             "image_title": self.object.title
   300|         }
   301| @permission_checker.require("add")
   302| def add(request):
   303|     ImageModel = get_image_model()
   304|     ImageForm = get_image_form(ImageModel)
   305|     if request.method == "POST":
   306|         image = ImageModel(uploaded_by_user=request.user)
   307|         form = ImageForm(request.POST, request.FILES, instance=image, user=request.user)
   308|         if form.is_valid():
   309|             form.save()
   310|             messages.success(
   311|                 request,
   312|                 _("Image '%(image_title)s' added.") % {"image_title": image.title},
   313|                 buttons=[
   314|                     messages.button(
   315|                         reverse("wagtailimages:edit", args=(image.id,)), _("Edit")
   316|                     )
   317|                 ],
   318|             )
   319|             return redirect("wagtailimages:index")
   320|         else:
   321|             messages.error(request, _("The image could not be created due to errors."))
   322|     else:
   323|         form = ImageForm(user=request.user)
   324|     return TemplateResponse(
   325|         request,
   326|         "wagtailimages/images/add.html",
   327|         {
   328|             "form": form,
   329|         },
   330|     )
   331| class UsageView(generic.UsageView):
   332|     model = get_image_model()
   333|     paginate_by = USAGE_PAGE_SIZE
   334|     pk_url_kwarg = "image_id"
   335|     permission_policy = permission_policy
   336|     permission_required = "change"
   337|     header_icon = "image"
   338|     def user_has_permission(self, permission):
   339|         return self.permission_policy.user_has_permission_for_instance(
   340|             self.request.user, permission, self.object
   341|         )
   342|     def get_page_subtitle(self):
   343|         return self.object.title


# ====================================================================
# FILE: wagtail/search/utils.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-142 ---
     1| import operator
     2| import re
     3| from functools import partial
     4| from django.apps import apps
     5| from django.db import connections
     6| from django.http import QueryDict
     7| from wagtail.search.index import RelatedFields, SearchField
     8| from .query import MATCH_NONE, Phrase, PlainText
     9| NOT_SET = object()
    10| def balanced_reduce(operator, seq, initializer=NOT_SET):
    11|     """
    12|     Has the same result as Python's reduce function, but performs the calculations in a different order.
    13|     This is important when the operator is constructing data structures such as search query classes.
    14|     This method will make the resulting data structures flatter, so operations that need to traverse
    15|     them don't end up crashing with recursion errors.
    16|     For example:
    17|     Python's builtin reduce() function will do the following calculation:
    18|     reduce(add, [1, 2, 3, 4, 5, 6, 7, 8])
    19|     (1 + (2 + (3 + (4 + (5 + (6 + (7 + 8)))))))
    20|     When using this with query classes, it would create a large data structure with a depth of 7
    21|     Whereas balanced_reduce will execute this like so:
    22|     balanced_reduce(add, [1, 2, 3, 4, 5, 6, 7, 8])
    23|     ((1 + 2) + (3 + 4)) + ((5 + 6) + (7 + 8))
    24|     Which only has a depth of 2
    25|     """
    26|     if not isinstance(seq, list):
    27|         seq = list(seq)
    28|     if initializer is not NOT_SET:
    29|         if len(seq) == 0:
    30|             return initializer
    31|         else:
    32|             return operator(initializer, balanced_reduce(operator, seq))
    33|     if len(seq) == 0:
    34|         raise TypeError("reduce() of empty sequence with no initial value")
    35|     elif len(seq) == 1:
    36|         return seq[0]
    37|     else:
    38|         break_point = len(seq) // 2
    39|         first_set = balanced_reduce(operator, seq[:break_point])
    40|         second_set = balanced_reduce(operator, seq[break_point:])
    41|         return operator(first_set, second_set)
    42| OR = partial(balanced_reduce, operator.or_)
    43| AND = partial(balanced_reduce, operator.and_)
    44| ADD = partial(balanced_reduce, operator.add)
    45| MUL = partial(balanced_reduce, operator.mul)
    46| MAX_QUERY_STRING_LENGTH = 255
    47| filters_regexp = re.compile(r'\b(\w+):(\w+|"[^"]+"|\'[^\']+\')')
    48| def normalise_query_string(query_string):
    49|     query_string = query_string[:MAX_QUERY_STRING_LENGTH]
    50|     query_string = query_string.lower()
    51|     query_string = re.sub(" +", " ", query_string).strip()
    52|     return query_string
    53| def separate_filters_from_query(query_string):
    54|     filters = QueryDict(mutable=True)
    55|     for match_object in filters_regexp.finditer(query_string):
    56|         key, value = match_object.groups()
    57|         filters.update({key: value.strip("\"'")})
    58|     query_string = filters_regexp.sub("", query_string).strip()
    59|     return filters, query_string
    60| def parse_query_string(query_string, operator=None, zero_terms=MATCH_NONE):
    61|     """
    62|     This takes a query string typed in by a user and extracts the following:
    63|      - Quoted terms (for phrase search)
    64|      - Filters
    65|     For example, the following query:
    66|       `hello "this is a phrase" live:true` would be parsed into:
    67|     filters: {'live': 'true'}
    68|     tokens: And([PlainText('hello'), Phrase('this is a phrase')])
    69|     """
    70|     filters, query_string = separate_filters_from_query(query_string)
    71|     is_phrase = False
    72|     tokens = []
    73|     if '"' in query_string:
    74|         parts = query_string.split('"')
    75|     else:
    76|         parts = query_string.split("'")
    77|     for part in parts:
    78|         part = part.strip()
    79|         if part:
    80|             if is_phrase:
    81|                 tokens.append(Phrase(part))
    82|             else:
    83|                 tokens.append(
    84|                     PlainText(part, operator=operator or PlainText.DEFAULT_OPERATOR)
    85|                 )
    86|         is_phrase = not is_phrase
    87|     if tokens:
    88|         if operator == "or":
    89|             search_query = OR(tokens)
    90|         else:
    91|             search_query = AND(tokens)
    92|     else:
    93|         search_query = zero_terms
    94|     return filters, search_query
    95| def get_descendant_models(model):
    96|     """
    97|     Returns all descendants of a model, including the model itself.
    98|     """
    99|     descendant_models = {
   100|         other_model
   101|         for other_model in apps.get_models()
   102|         if issubclass(other_model, model)
   103|     }
   104|     descendant_models.add(model)
   105|     return descendant_models
   106| def get_content_type_pk(model):
   107|     from django.contrib.contenttypes.models import ContentType
   108|     return ContentType.objects.get_for_model(model).pk
   109| def get_ancestors_content_types_pks(model):
   110|     """
   111|     Returns content types ids for the ancestors of this model, excluding it.
   112|     """
   113|     from django.contrib.contenttypes.models import ContentType
   114|     return [
   115|         ct.pk
   116|         for ct in ContentType.objects.get_for_models(
   117|             *model._meta.get_parent_list()
   118|         ).values()
   119|     ]
   120| def get_descendants_content_types_pks(model):
   121|     """
   122|     Returns content types ids for the descendants of this model, including it.
   123|     """
   124|     from django.contrib.contenttypes.models import ContentType
   125|     return [
   126|         ct.pk
   127|         for ct in ContentType.objects.get_for_models(
   128|             *get_descendant_models(model)
   129|         ).values()
   130|     ]
   131| def get_search_fields(search_fields):
   132|     for search_field in search_fields:
   133|         if isinstance(search_field, SearchField):
   134|             yield search_field
   135|         elif isinstance(search_field, RelatedFields):
   136|             yield from get_search_fields(search_field.fields)
   137| def get_postgresql_connections():
   138|     return [
   139|         connection
   140|         for connection in connections.all()
   141|         if connection.vendor == "postgresql"
   142|     ]

