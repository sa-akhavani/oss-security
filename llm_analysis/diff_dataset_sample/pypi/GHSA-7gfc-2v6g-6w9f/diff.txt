--- a/docs/conf.py
+++ b/docs/conf.py
@@ -1,16 +1,16 @@
 import sys
 extensions = ['sphinx.ext.autodoc']
 templates_path = ['_templates']
 source_suffix = '.txt'
 master_doc = 'index'
 project = 'Paste'
 copyright = '2008, Ian Bicking'
 version = '1.7'
-release = '1.7.4'
+release = '1.7.3.1'
 today_fmt = '%B %d, %Y'
 unused_docs = ['include/contact.txt', 'include/reference_header.txt']
 pygments_style = 'sphinx'
 html_style = 'default.css'
 html_static_path = ['_static']
 html_last_updated_fmt = '%b %d, %Y'
 htmlhelp_basename = 'Pastedoc'

--- a/paste/errordocument.py
+++ b/paste/errordocument.py
@@ -4,49 +4,49 @@
 specified status codes and internally forward the request to an appropriate
 URL where the content can be displayed to the user as an error document.
 """
 import warnings
 from urlparse import urlparse
 from paste.recursive import ForwardRequestException, RecursiveMiddleware
 from paste.util import converters
 from paste.response import replace_header
 def forward(app, codes):
     """
-    Intercepts a response with a particular status code and returns the
+    Intercepts a response with a particular status code and returns the 
     content from a specified URL instead.
     The arguments are:
     ``app``
         The WSGI application or middleware chain.
     ``codes``
         A dictionary of integer status codes and the URL to be displayed
         if the response uses that code.
-    For example, you might want to create a static file to display a
+    For example, you might want to create a static file to display a 
     "File Not Found" message at the URL ``/error404.html`` and then use
     ``forward`` middleware to catch all 404 status codes and display the page
-    you created. In this example ``app`` is your exisiting WSGI
+    you created. In this example ``app`` is your exisiting WSGI 
     applicaiton::
         from paste.errordocument import forward
         app = forward(app, codes={404:'/error404.html'})
     """
     for code in codes:
         if not isinstance(code, int):
             raise TypeError('All status codes should be type int. '
                 '%s is not valid'%repr(code))
     def error_codes_mapper(code, message, environ, global_conf, codes):
         if codes.has_key(code):
             return codes[code]
         else:
             return None
     return RecursiveMiddleware(
         StatusBasedForward(
-            app,
-            error_codes_mapper,
+            app, 
+            error_codes_mapper, 
             codes=codes,
         )
     )
 class StatusKeeper(object):
     def __init__(self, app, status, url, headers):
         self.app = app
         self.status = status
         self.url = url
         self.headers = headers
     def __call__(self, environ, start_response):
@@ -67,35 +67,35 @@
 class StatusBasedForward(object):
     """
     Middleware that lets you test a response against a custom mapper object to
     programatically determine whether to internally forward to another URL and
     if so, which URL to forward to.
     If you don't need the full power of this middleware you might choose to use
     the simpler ``forward`` middleware instead.
     The arguments are:
     ``app``
         The WSGI application or middleware chain.
-    ``mapper``
+    ``mapper`` 
         A callable that takes a status code as the
         first parameter, a message as the second, and accepts optional environ,
         global_conf and named argments afterwards. It should return a
         URL to forward to or ``None`` if the code is not to be intercepted.
     ``global_conf``
         Optional default configuration from your config file. If ``debug`` is
         set to ``true`` a message will be written to ``wsgi.errors`` on each
         internal forward stating the URL forwarded to.
-    ``**params``
-        Optional, any other configuration and extra arguments you wish to
+    ``**params`` 
+        Optional, any other configuration and extra arguments you wish to 
         pass which will in turn be passed back to the custom mapper object.
     Here is an example where a ``404 File Not Found`` status response would be
-    redirected to the URL ``/error?code=404&message=File%20Not%20Found``. This
-    could be useful for passing the status code and message into another
+    redirected to the URL ``/error?code=404&message=File%20Not%20Found``. This 
+    could be useful for passing the status code and message into another 
     application to display an error document:
     .. code-block:: python
         from paste.errordocument import StatusBasedForward
         from paste.recursive import RecursiveMiddleware
         from urllib import urlencode
         def error_mapper(code, message, environ, global_conf, kw)
             if code in [404, 500]:
                 params = urlencode({'message':message, 'code':code})
                 url = '/error?'%(params)
                 return url
@@ -122,24 +122,24 @@
             status_code = status.split(' ')
             try:
                 code = int(status_code[0])
             except (ValueError, TypeError):
                 raise Exception(
                     'StatusBasedForward middleware '
                     'received an invalid status code %s'%repr(status_code[0])
                 )
             message = ' '.join(status_code[1:])
             new_url = self.mapper(
-                code,
-                message,
-                environ,
-                self.global_conf,
+                code, 
+                message, 
+                environ, 
+                self.global_conf, 
                 **self.params
             )
             if not (new_url == None or isinstance(new_url, str)):
                 raise TypeError(
                     'Expected the url to internally '
                     'redirect to in the StatusBasedForward mapper'
                     'to be a string or None, not %s'%repr(new_url)
                 )
             if new_url:
                 url.append([new_url, status, headers])
@@ -150,21 +150,21 @@
             if hasattr(app_iter, 'close'):
                 app_iter.close()
             def factory(app):
                 return StatusKeeper(app, status=url[0][1], url=url[0][0],
                                     headers=url[0][2])
             raise ForwardRequestException(factory=factory)
         else:
             return app_iter
 def make_errordocument(app, global_conf, **kw):
     """
-    Paste Deploy entry point to create a error document wrapper.
+    Paste Deploy entry point to create a error document wrapper. 
     Use like::
         [filter-app:main]
         use = egg:Paste#errordocument
         next = real-app
         500 = /lib/msg/500.html
         404 = /lib/msg/404.html
     """
     map = {}
     for status, redir_loc in kw.items():
         try:
@@ -210,47 +210,47 @@
         self.fallback_template = """
             <html>
             <head>
             <title>Error %(code)s</title>
             </html>
             <body>
             <h1>Error %(code)s</h1>
             <p>%(message)s</p>
             <hr>
             <p>
-                Additionally an error occurred trying to produce an
+                Additionally an error occurred trying to produce an 
                 error document.  A description of the error was logged
                 to <tt>wsgi.errors</tt>.
             </p>
             </body>
-            </html>
+            </html>                
         """
     def __call__(self, environ, start_response):
         url = []
         code_message = []
         try:
             def change_response(status, headers, exc_info=None):
                 new_url = None
                 parts = status.split(' ')
                 try:
                     code = int(parts[0])
-                except (ValueError, TypeError):
+                except ValueError, TypeError:
                     raise Exception(
                         '_StatusBasedRedirect middleware '
                         'received an invalid status code %s'%repr(parts[0])
                     )
                 message = ' '.join(parts[1:])
                 new_url = self.mapper(
-                    code,
-                    message,
-                    environ,
-                    self.global_conf,
+                    code, 
+                    message, 
+                    environ, 
+                    self.global_conf, 
                     self.kw
                 )
                 if not (new_url == None or isinstance(new_url, str)):
                     raise TypeError(
                         'Expected the url to internally '
                         'redirect to in the _StatusBasedRedirect error_mapper'
                         'to be a string or None, not %s'%repr(new_url)
                     )
                 if new_url:
                     url.append(new_url)

--- a/paste/httpexceptions.py
+++ b/paste/httpexceptions.py
@@ -56,21 +56,21 @@
         * 504 - HTTPGatewayTimeout
         * 505 - HTTPVersionNotSupported
 References:
 .. [1] http://www.python.org/peps/pep-0333.html#error-handling
 .. [2] http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5
 """
 import types
 from paste.wsgilib import catch_errors_app
 from paste.response import has_header, header_value, replace_header
 from paste.request import resolve_relative_url
-from paste.util.quoting import strip_html, html_quote, no_quote, comment_quote
+from paste.util.quoting import strip_html, html_quote, no_quote
 SERVER_NAME = 'WSGI Server'
 TEMPLATE = """\
 <html>\r
   <head><title>%(title)s</title></head>\r
   <body>\r
     <h1>%(title)s</h1>\r
     <p>%(body)s</p>\r
     <hr noshade>\r
     <div align="right">%(server)s</div>\r
   </body>\r
@@ -167,25 +167,25 @@
                 args[k] = escfunc(v)
             if self.headers:
                 for (k, v) in self.headers:
                     args[k.lower()] = escfunc(v)
         for key, value in args.items():
             if isinstance(value, unicode):
                 args[key] = value.encode('utf8', 'xmlcharrefreplace')
         return template % args
     def plain(self, environ):
         """ text/plain representation of the exception """
-        body = self.make_body(environ, strip_html(self.template), comment_quote)
+        body = self.make_body(environ, strip_html(self.template), no_quote)
         return ('%s %s\r\n%s\r\n' % (self.code, self.title, body))
     def html(self, environ):
         """ text/html representation of the exception """
-        body = self.make_body(environ, self.template, html_quote, comment_quote)
+        body = self.make_body(environ, self.template, html_quote, no_quote)
         return TEMPLATE % {
                    'title': self.title,
                    'code': self.code,
                    'server': SERVER_NAME,
                    'body': body }
     def prepare_content(self, environ):
         if self.headers:
             headers = list(self.headers)
         else:
             headers = []
@@ -264,21 +264,21 @@
             detail = ''
             headers.append(('location', location))
         assert location, ("HTTPRedirection specified neither a "
                           "location in the headers nor did it "
                           "provide a detail argument.")
         HTTPRedirection.__init__(self, location, headers, comment)
         if detail is not None:
             self.detail = detail
     def relative_redirect(cls, dest_uri, environ, detail=None, headers=None, comment=None):
         """
-        Create a redirect object with the dest_uri, which may be relative,
+        Create a redirect object with the dest_uri, which may be relative, 
         considering it relative to the uri implied by the given environ.
         """
         location = resolve_relative_url(dest_uri, environ)
         headers = headers or []
         headers.append(('Location', location))
         return cls(detail=detail, headers=headers, comment=comment)
     relative_redirect = classmethod(relative_redirect)
     def location(self):
         for name, value in self.headers:
             if name.lower() == 'location':

--- a/paste/urlmap.py
+++ b/paste/urlmap.py
@@ -1,17 +1,16 @@
 """
 Map URL prefixes to WSGI applications.  See ``URLMap``
 """
 from UserDict import DictMixin
 import re
 import os
-import cgi
 from paste import httpexceptions
 __all__ = ['URLMap', 'PathProxyURLMap']
 def urlmap_factory(loader, global_conf, **local_conf):
     if 'not_found_app' in local_conf:
         not_found_app = local_conf.pop('not_found_app')
     else:
         not_found_app = global_conf.get('not_found_app')
     if not_found_app:
         not_found_app = loader.get_app(not_found_app, global_conf=global_conf)
     urlmap = URLMap(not_found_app=not_found_app)
@@ -86,28 +85,28 @@
             matches = [p for p, a in mapper.applications]
             extra = 'defined apps: %s' % (
                 ',\n  '.join(map(repr, matches)))
         else:
             extra = ''
         extra += '\nSCRIPT_NAME: %r' % environ.get('SCRIPT_NAME')
         extra += '\nPATH_INFO: %r' % environ.get('PATH_INFO')
         extra += '\nHTTP_HOST: %r' % environ.get('HTTP_HOST')
         app = httpexceptions.HTTPNotFound(
             environ['PATH_INFO'],
-            comment=cgi.escape(extra)).wsgi_application
+            comment=extra).wsgi_application
         return app(environ, start_response)
     def normalize_url(self, url, trim=True):
         if isinstance(url, (list, tuple)):
             domain = url[0]
             url = self.normalize_url(url[1])[1]
             return domain, url
-        assert (not url or url.startswith('/')
+        assert (not url or url.startswith('/') 
                 or self.domain_url_re.search(url)), (
             "URL fragments must start with / or http:// (you gave %r)" % url)
         match = self.domain_url_re.search(url)
         if match:
             url = url[match.end():]
             if '/' in url:
                 domain, url = url.split('/', 1)
                 url = '/' + url
             else:
                 domain, url = url, ''
@@ -141,21 +140,21 @@
         if dom_url in self:
             del self[dom_url]
         self.applications.append((dom_url, app))
         self.sort_apps()
     def __getitem__(self, url):
         dom_url = self.normalize_url(url)
         for app_url, app in self.applications:
             if app_url == dom_url:
                 return app
         raise KeyError(
-            "No application with the url %r (domain: %r; existing: %s)"
+            "No application with the url %r (domain: %r; existing: %s)" 
             % (url[1], url[0] or '*', self.applications))
     def __delitem__(self, url):
         url = self.normalize_url(url)
         for app_url, app in self.applications:
             if app_url == url:
                 self.applications.remove((app_url, app))
                 break
         else:
             raise KeyError(
                 "No application with the url %r" % (url,))
@@ -197,21 +196,21 @@
     def __init__(self, map, base_paste_url, base_path, builder):
         self.map = map
         self.base_paste_url = self.map.normalize_url(base_paste_url)
         self.base_path = base_path
         self.builder = builder
     def __setitem__(self, url, app):
         if isinstance(app, (str, unicode)):
             app_fn = os.path.join(self.base_path, app)
             app = self.builder(app_fn)
         url = self.map.normalize_url(url)
-        url = (url[0] or self.base_paste_url[0],
+        url = (url[0] or self.base_paste_url[0], 
                self.base_paste_url[1] + url[1])
         self.map[url] = app
     def __getattr__(self, attr):
         return getattr(self.map, attr)
     def not_found_application__get(self):
         return self.map.not_found_application
     def not_found_application__set(self, value):
         self.map.not_found_application = value
     not_found_application = property(not_found_application__get,
                                      not_found_application__set)

--- a/paste/util/mimeparse.py
+++ b/paste/util/mimeparse.py
@@ -1,21 +1,21 @@
 """MIME-Type Parser
 This module provides basic functions for handling mime-types. It can handle
-matching mime-types against a list of media-ranges. See section 14.1 of
+matching mime-types against a list of media-ranges. See section 14.1 of 
 the HTTP specification [RFC 2616] for a complete explanation.
    http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1
 Contents:
     - parse_mime_type():   Parses a mime-type into its component parts.
     - parse_media_range(): Media-ranges are mime-types with wild-cards and a 'q' quality parameter.
     - quality():           Determines the quality ('q') of a mime-type when compared against a list of media-ranges.
     - quality_parsed():    Just like quality() except the second parameter must be pre-parsed.
-    - best_match():        Choose the mime-type with the highest quality ('q') from a list of candidates.
+    - best_match():        Choose the mime-type with the highest quality ('q') from a list of candidates. 
 """
 __version__ = "0.1.2"
 __author__ = 'Joe Gregorio'
 __email__ = "joe@bitworking.org"
 __credits__ = ""
 def parse_mime_type(mime_type):
     """Carves up a mime-type and returns a tuple of the
        (type, subtype, params) where 'params' is a dictionary
        of all the parameters for the media range.
        For example, the media range 'application/xhtml;q=0.5' would
@@ -29,39 +29,39 @@
     if full_type == '*': full_type = '*/*'
     (type, subtype) = full_type.split("/")
     return (type.strip(), subtype.strip(), params)
 def parse_media_range(range):
     """Carves up a media range and returns a tuple of the
        (type, subtype, params) where 'params' is a dictionary
        of all the parameters for the media range.
        For example, the media range 'application/*;q=0.5' would
        get parsed into:
        ('application', '*', {'q', '0.5'})
-       In addition this function also guarantees that there
+       In addition this function also guarantees that there 
        is a value for 'q' in the params dictionary, filling it
        in with a proper default if necessary.
        """
     (type, subtype, params) = parse_mime_type(range)
     if not params.has_key('q') or not params['q'] or \
             not float(params['q']) or float(params['q']) > 1\
             or float(params['q']) < 0:
         params['q'] = '1'
     return (type, subtype, params)
 def fitness_and_quality_parsed(mime_type, parsed_ranges):
-    """Find the best match for a given mime-type against
-       a list of media_ranges that have already been
+    """Find the best match for a given mime-type against 
+       a list of media_ranges that have already been 
        parsed by parse_media_range(). Returns a tuple of
        the fitness value and the value of the 'q' quality
        parameter of the best match, or (-1, 0) if no match
        was found. Just as for quality_parsed(), 'parsed_ranges'
        must be a list of parsed media ranges. """
-    best_fitness = -1
+    best_fitness = -1 
     best_fit_q = 0
     (target_type, target_subtype, target_params) =\
             parse_media_range(mime_type)
     for (type, subtype, params) in parsed_ranges:
         if (type == target_type or type == '*' or target_type == '*') and \
                 (subtype == target_subtype or subtype == '*' or target_subtype == '*'):
             param_matches = reduce(lambda x, y: x+y, [1 for (key, value) in \
                     target_params.iteritems() if key != 'q' and \
                     params.has_key(key) and value == params[key]], 0)
             fitness = (type == target_type) and 100 or 0
@@ -78,47 +78,27 @@
     'q' quality parameter of the best match, 0 if no
     match was found. This function bahaves the same as quality()
     except that 'parsed_ranges' must be a list of
     parsed media ranges. """
     return fitness_and_quality_parsed(mime_type, parsed_ranges)[1]
 def quality(mime_type, ranges):
     """Returns the quality 'q' of a mime-type when compared
     against the media-ranges in ranges. For example:
     >>> quality('text/html','text/*;q=0.3, text/html;q=0.7, text/html;level=1, text/html;level=2;q=0.4, */*;q=0.5')
     0.7
-    """
+    """ 
     parsed_ranges = [parse_media_range(r) for r in ranges.split(",")]
     return quality_parsed(mime_type, parsed_ranges)
 def best_match(supported, header):
     """Takes a list of supported mime-types and finds the best
     match for all the media-ranges listed in header. The value of
-    header must be a string that conforms to the format of the
+    header must be a string that conforms to the format of the 
     HTTP Accept: header. The value of 'supported' is a list of
     mime-types.
     >>> best_match(['application/xbel+xml', 'text/xml'], 'text/*;q=0.5,*/*; q=0.1')
     'text/xml'
     """
     parsed_header = [parse_media_range(r) for r in header.split(",")]
     weighted_matches = [(fitness_and_quality_parsed(mime_type, parsed_header), mime_type)\
             for mime_type in supported]
     weighted_matches.sort()
     return weighted_matches[-1][0][1] and weighted_matches[-1][1] or ''
-def desired_matches(desired, header):
-    """Takes a list of desired mime-types in the order the server prefers to
-    send them regardless of the browsers preference.
-    Browsers (such as Firefox) technically want XML over HTML depending on how
-    one reads the specification. This function is provided for a server to
-    declare a set of desired mime-types it supports, and returns a subset of
-    the desired list in the same order should each one be Accepted by the
-    browser.
-    >>> sorted_match(['text/html', 'application/xml'], \
-    ...     'text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png')
-    ['text/html', 'application/xml']
-    >>> sorted_match(['text/html', 'application/xml'], 'application/xml,application/json')
-    ['application/xml']
-    """
-    matches = []
-    parsed_ranges = [parse_media_range(r) for r in header.split(",")]
-    for mimetype in desired:
-        if quality_parsed(mimetype, parsed_ranges):
-            matches.append(mimetype)
-    return matches

--- a/paste/util/quoting.py
+++ b/paste/util/quoting.py
@@ -53,21 +53,15 @@
     return _unquote_re.sub(_entity_subber, s)
 def strip_html(s):
     s = re.sub('<.*?>', '', s)
     s = html_unquote(s)
     return s
 def no_quote(s):
     """
     Quoting that doesn't do anything
     """
     return s
-_comment_quote_re = re.compile(r'\-\s*\>')
-def comment_quote(s):
-    """
-    Quote that makes sure text can't escape a comment
-    """
-    return _comment_quote_re.sub('-&gt', str(s))
 url_quote = urllib.quote
 url_unquote = urllib.unquote
 if __name__ == '__main__':
     import doctest
     doctest.testmod()

--- a/setup.py
+++ b/setup.py
@@ -1,12 +1,12 @@
 RELEASE = False
-__version__ = '1.7.4'
+__version__ = '1.7.3.1'
 from setuptools import setup, find_packages
 import sys, os
 sys.path.insert(0, os.path.join(os.path.dirname(__file__),
                                 'paste', 'util'))
 import finddata
 setup(name="Paste",
       version=__version__,
       description="Tools for using a Web Server Gateway Interface stack",
       long_description="""\
 These provide several pieces of "middleware" (or filters) that can be nested to build web applications.  Each
