# ====================================================================
# FILE: doc/_ext/vaultpolicylexer.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-21 ---
     1| from pygments.lexer import bygroups, inherit
     2| from pygments.lexers.configs import TerraformLexer
     3| from pygments.token import Keyword, Name, Punctuation, Whitespace
     4| class VaultPolicyLexer(TerraformLexer):
     5|     aliases = ["vaultpolicy"]
     6|     filenames = ["*.hcl"]
     7|     mimetypes = ["application/x-hcl-policy"]
     8|     tokens = {
     9|         "basic": [
    10|             inherit,
    11|             (
    12|                 r"(path)(\s+)(\".*\")(\s+)(\{)",
    13|                 bygroups(
    14|                     Keyword.Reserved, Whitespace, Name.Variable, Whitespace, Punctuation
    15|                 ),
    16|             ),
    17|         ],
    18|     }
    19| def setup(app):
    20|     app.add_lexer("vaultpolicy", VaultPolicyLexer)
    21|     return {"parallel_read_safe": True}


# ====================================================================
# FILE: doc/conf.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 105-145 ---
   105| spelling_show_suggestions = True
   106| language = "en"
   107| locale_dirs = [
   108|     "_locale",
   109| ]
   110| master_doc = "contents"
   111| templates_path = ["_templates"]
   112| exclude_patterns = ["_build", "_incl/*", "ref/cli/_includes/*.rst"]
   113| extensions = [
   114|     "saltdomain",  # Must come early
   115|     "sphinx.ext.autodoc",
   116|     "sphinx.ext.napoleon",
   117|     "sphinx.ext.autosummary",
   118|     "sphinx.ext.extlinks",
   119|     "sphinx.ext.imgconverter",
   120|     "sphinx.ext.intersphinx",
   121|     "sphinxcontrib.httpdomain",
   122|     "saltrepo",
   123|     "myst_parser",
   124|     "sphinxcontrib.spelling",
   125|     "vaultpolicylexer",
   126| ]
   127| modindex_common_prefix = ["salt."]
   128| autosummary_generate = True
   129| autosummary_generate_overwrite = False
   130| autodoc_mock_imports = []
   131| stripped_release = re.sub(r"-\d+-g[0-9a-f]+$", "", release)
   132| rst_prolog = """\
   133| .. |current_release_doc| replace:: :doc:`/topics/releases/{release}`
   134| .. |saltrepo| replace:: https://github.com/saltstack/salt
   135| .. _`salt-users`: https://groups.google.com/forum/#!forum/salt-users
   136| .. _`salt-announce`: https://groups.google.com/forum/#!forum/salt-announce
   137| .. _`salt-packagers`: https://groups.google.com/forum/#!forum/salt-packagers
   138| .. _`salt-slack`: https://via.vmw.com/salt-slack
   139| .. |windownload| raw:: html
   140|      <p>Python3 x86: <a
   141|      href="https://repo.saltproject.io/windows/Salt-Minion-{release}-Py3-x86-Setup.exe"><strong>Salt-Minion-{release}-x86-Setup.exe</strong></a>
   142|       | <a href="https://repo.saltproject.io/windows/Salt-Minion-{release}-Py3-x86-Setup.exe.md5"><strong>md5</strong></a></p>
   143|      <p>Python3 AMD64: <a
   144|      href="https://repo.saltproject.io/windows/Salt-Minion-{release}-Py3-AMD64-Setup.exe"><strong>Salt-Minion-{release}-AMD64-Setup.exe</strong></a>
   145|       | <a href="https://repo.saltproject.io/windows/Salt-Minion-{release}-Py3-AMD64-Setup.exe.md5"><strong>md5</strong></a></p>

# --- HUNK 2: Lines 233-272 ---
   233| """,
   234| }
   235| linkcheck_ignore = [
   236|     r"http://127.0.0.1",
   237|     r"http://salt:\d+",
   238|     r"http://local:\d+",
   239|     r"https://console.aws.amazon.com",
   240|     r"http://192.168.33.10",
   241|     r"http://domain:\d+",
   242|     r"http://123.456.789.012:\d+",
   243|     r"http://localhost",
   244|     r"https://groups.google.com/forum/#!forum/salt-users",
   245|     r"https://www.elastic.co/logstash/docs/latest/inputs/udp",
   246|     r"https://www.elastic.co/logstash/docs/latest/inputs/zeromq",
   247|     r"http://www.youtube.com/saltstack",
   248|     r"https://raven.readthedocs.io",
   249|     r"https://getsentry.com",
   250|     r"https://salt-cloud.readthedocs.io",
   251|     r"https://salt.readthedocs.io",
   252|     r"http://www.pip-installer.org/",
   253|     r"https://github.com/watching",
   254|     r"dash-feed://",
   255|     r"https://github.com/saltstack/salt/",
   256|     r"https://bootstrap.saltproject.io",
   257|     r"https://raw.githubusercontent.com/saltstack/salt-bootstrap/stable/bootstrap-salt.sh",
   258|     r"media.readthedocs.org/dash/salt/latest/salt.xml",
   259|     r"https://portal.aws.amazon.com/gp/aws/securityCredentials",
   260|     r"dash-feed://https%3A//media.readthedocs.org/dash/salt/latest/salt.xml",
   261|     r"(?i)dns:.*",
   262|     r"TCP:4506",
   263|     r"https?://",
   264|     r"https://cloud.github.com/downloads/saltstack/.*",
   265|     r"https://INFOBLOX/.*",
   266|     r"https://SOMESERVERIP:.*",
   267|     r"https://community.saltstack.com/.*",
   268|     r"https://github.com/[^/]$",
   269|     r"https://github.com/[^/]/salt$",
   270|     r"tag:key=value",
   271|     r"jdbc:mysql:.*",
   272|     r"http:post",


# ====================================================================
# FILE: noxfile.py
# Total hunks: 8
# ====================================================================
# --- HUNK 1: Lines 52-92 ---
    52|     PRINT_SYSTEM_INFO = PRINT_SYSTEM_INFO == "1"
    53| PRINT_SYSTEM_INFO_ONLY = os.environ.get("PRINT_SYSTEM_INFO_ONLY", "0") == "1"
    54| SKIP_REQUIREMENTS_INSTALL = os.environ.get("SKIP_REQUIREMENTS_INSTALL", "0") == "1"
    55| EXTRA_REQUIREMENTS_INSTALL = os.environ.get("EXTRA_REQUIREMENTS_INSTALL")
    56| COVERAGE_REQUIREMENT = os.environ.get("COVERAGE_REQUIREMENT")
    57| REPO_ROOT = pathlib.Path(os.path.dirname(__file__)).resolve()
    58| ARTIFACTS_DIR = REPO_ROOT / "artifacts"
    59| COVERAGE_OUTPUT_DIR = ARTIFACTS_DIR / "coverage"
    60| COVERAGE_FILE = os.environ.get("COVERAGE_FILE")
    61| if COVERAGE_FILE is None:
    62|     COVERAGE_FILE = str(COVERAGE_OUTPUT_DIR / ".coverage")
    63| IS_DARWIN = sys.platform.lower().startswith("darwin")
    64| IS_WINDOWS = sys.platform.lower().startswith("win")
    65| IS_FREEBSD = sys.platform.lower().startswith("freebsd")
    66| IS_LINUX = sys.platform.lower().startswith("linux")
    67| ONEDIR_ARTIFACT_PATH = ARTIFACTS_DIR / "salt"
    68| if IS_WINDOWS:
    69|     ONEDIR_PYTHON_PATH = ONEDIR_ARTIFACT_PATH / "Scripts" / "python.exe"
    70| else:
    71|     ONEDIR_PYTHON_PATH = ONEDIR_ARTIFACT_PATH / "bin" / "python3"
    72| _PYTHON_VERSIONS = ("3", "3.8", "3.9", "3.10", "3.11")
    73| nox.options.reuse_existing_virtualenvs = True
    74| os.chdir(str(REPO_ROOT))
    75| RUNTESTS_LOGFILE = ARTIFACTS_DIR.joinpath(
    76|     "logs",
    77|     "runtests-{}.log".format(datetime.datetime.now().strftime("%Y%m%d%H%M%S.%f")),
    78| )
    79| os.environ["PYTHONDONTWRITEBYTECODE"] = "1"
    80| def session_warn(session, message):
    81|     try:
    82|         session.warn(message)
    83|     except AttributeError:
    84|         session.log(f"WARNING: {message}")
    85| def session_run_always(session, *command, **kwargs):
    86|     """
    87|     Patch nox to allow running some commands which would be skipped if --install-only is passed.
    88|     """
    89|     try:
    90|         return session.run_always(*command, **kwargs)
    91|     except AttributeError:
    92|         old_install_only_value = session._runner.global_config.install_only

# --- HUNK 2: Lines 127-168 ---
   127|         version_info = session._runner._real_python_version_info
   128|     except AttributeError:
   129|         session_py_version = session_run_always(
   130|             session,
   131|             "python",
   132|             "-c",
   133|             'import sys; sys.stdout.write("{}.{}.{}".format(*sys.version_info))',
   134|             stderr=None,
   135|             silent=True,
   136|             log=False,
   137|         )
   138|         version_info = tuple(
   139|             int(part)
   140|             for part in session_py_version.strip().split(".")
   141|             if part.isdigit()
   142|         )
   143|         session._runner._real_python_version_info = version_info
   144|     return version_info
   145| def _get_pydir(session):
   146|     version_info = _get_session_python_version_info(session)
   147|     if version_info < (3, 8):
   148|         session.error("Only Python >= 3.8 is supported")
   149|     return "py{}.{}".format(*version_info)
   150| def _get_pip_requirements_file(session, crypto=None, requirements_type="ci"):
   151|     assert requirements_type in ("ci", "pkg")
   152|     pydir = _get_pydir(session)
   153|     if IS_WINDOWS:
   154|         if crypto is None:
   155|             _requirements_file = os.path.join(
   156|                 "requirements", "static", requirements_type, pydir, "windows.txt"
   157|             )
   158|             if os.path.exists(_requirements_file):
   159|                 return _requirements_file
   160|         _requirements_file = os.path.join(
   161|             "requirements", "static", requirements_type, pydir, "windows-crypto.txt"
   162|         )
   163|         if os.path.exists(_requirements_file):
   164|             return _requirements_file
   165|         session.error(f"Could not find a windows requirements file for {pydir}")
   166|     elif IS_DARWIN:
   167|         if crypto is None:
   168|             _requirements_file = os.path.join(

# --- HUNK 3: Lines 759-811 ---
   759|         session_name = session._runner.friendly_name
   760|     session_warn(
   761|         session,
   762|         "This nox session is deprecated, please call {!r} instead".format(
   763|             session_name.replace("pytest-", "test-")
   764|         ),
   765|     )
   766|     session.notify(session_name.replace("pytest-", "test-"))
   767| @nox.session(python=_PYTHON_VERSIONS, name="test-cloud")
   768| @nox.parametrize("coverage", [False, True])
   769| def test_cloud(session, coverage):
   770|     """
   771|     pytest cloud tests session
   772|     """
   773|     pydir = _get_pydir(session)
   774|     if pydir == "py3.5":
   775|         session.error(
   776|             "Due to conflicting and unsupported requirements the cloud tests only run on Py3.6+"
   777|         )
   778|     if _upgrade_pip_setuptools_and_wheel(session):
   779|         linux_requirements_file = os.path.join(
   780|             "requirements", "static", "ci", pydir, "linux.txt"
   781|         )
   782|         cloud_requirements_file = os.path.join(
   783|             "requirements", "static", "ci", pydir, "cloud.txt"
   784|         )
   785|         install_command = [
   786|             "--progress-bar=off",
   787|             "-r",
   788|             linux_requirements_file,
   789|             "-r",
   790|             cloud_requirements_file,
   791|         ]
   792|         session.install(*install_command, silent=PIP_INSTALL_SILENT)
   793|     cmd_args = [
   794|         "--run-expensive",
   795|         "-k",
   796|         "cloud",
   797|     ] + session.posargs
   798|     _pytest(session, coverage=coverage, cmd_args=cmd_args)
   799| @nox.session(python=_PYTHON_VERSIONS, name="pytest-cloud")
   800| @nox.parametrize("coverage", [False, True])
   801| def pytest_cloud(session, coverage):
   802|     """
   803|     pytest cloud tests session
   804|     """
   805|     try:
   806|         session_name = session.name
   807|     except AttributeError:
   808|         session_name = session._runner.friendly_name
   809|     session_warn(
   810|         session,
   811|         "This nox session is deprecated, please call {!r} instead".format(

# --- HUNK 4: Lines 1095-1145 ---
  1095|                     resolved_link_suffix = resolved_link.split(
  1096|                         f"artifacts{os.sep}salt{os.sep}"
  1097|                     )[-1]
  1098|                     fixed_link = REPO_ROOT.joinpath(
  1099|                         "artifacts", "salt", resolved_link_suffix
  1100|                     )
  1101|                     session.log(
  1102|                         "Fixing broken symlink in nox virtualenv %r, from %r to %r",
  1103|                         dirname.name,
  1104|                         resolved_link,
  1105|                         str(fixed_link.relative_to(REPO_ROOT)),
  1106|                     )
  1107|                     broken_link.unlink()
  1108|                     broken_link.symlink_to(fixed_link)
  1109|                 continue
  1110|             if not path.is_file():
  1111|                 continue
  1112|             if platform != "windows":
  1113|                 try:
  1114|                     fpath = pathlib.Path(path)
  1115|                     contents = fpath.read_text().splitlines()
  1116|                     if (
  1117|                         contents[0].startswith("#!")
  1118|                         and contents[0].endswith("python")
  1119|                         and contents[0] != fixed_shebang
  1120|                     ):
  1121|                         session.log(
  1122|                             "Fixing broken shebang in %r",
  1123|                             str(fpath.relative_to(REPO_ROOT)),
  1124|                         )
  1125|                         fpath.write_text("\n".join([fixed_shebang] + contents[1:]))
  1126|                 except UnicodeDecodeError:
  1127|                     pass
  1128| @nox.session(python=False, name="compress-dependencies")
  1129| def compress_dependencies(session):
  1130|     if not session.posargs:
  1131|         session.error(
  1132|             "The 'compress-dependencies' session target needs "
  1133|             "two arguments, '<platform> <arch>'."
  1134|         )
  1135|     try:
  1136|         platform = session.posargs.pop(0)
  1137|         arch = session.posargs.pop(0)
  1138|         if session.posargs:
  1139|             session.error(
  1140|                 "The 'compress-dependencies' session target only accepts "
  1141|                 "two arguments, '<platform> <arch>'."
  1142|             )
  1143|     except IndexError:
  1144|         session.error(
  1145|             "The 'compress-dependencies' session target needs "

# --- HUNK 5: Lines 1232-1484 ---
  1232|     python=str(ONEDIR_PYTHON_PATH),
  1233|     name="create-json-coverage-reports-onedir",
  1234|     venv_params=["--system-site-packages"],
  1235| )
  1236| def create_json_coverage_reports_onedir(session):
  1237|     _report_coverage(session, combine=True, cli_report=False, json_report=True)
  1238| class Tee:
  1239|     """
  1240|     Python class to mimic linux tee behaviour
  1241|     """
  1242|     def __init__(self, first, second):
  1243|         self._first = first
  1244|         self._second = second
  1245|     def write(self, b):
  1246|         wrote = self._first.write(b)
  1247|         self._first.flush()
  1248|         self._second.write(b)
  1249|         self._second.flush()
  1250|     def fileno(self):
  1251|         return self._first.fileno()
  1252| def _lint(
  1253|     session, rcfile, flags, paths, tee_output=True, upgrade_setuptools_and_pip=True
  1254| ):
  1255|     if _upgrade_pip_setuptools_and_wheel(session, upgrade=upgrade_setuptools_and_pip):
  1256|         linux_requirements_file = os.path.join(
  1257|             "requirements", "static", "ci", _get_pydir(session), "linux.txt"
  1258|         )
  1259|         lint_requirements_file = os.path.join(
  1260|             "requirements", "static", "ci", _get_pydir(session), "lint.txt"
  1261|         )
  1262|         install_command = [
  1263|             "--progress-bar=off",
  1264|             "-r",
  1265|             linux_requirements_file,
  1266|             "-r",
  1267|             lint_requirements_file,
  1268|         ]
  1269|         session.install(*install_command, silent=PIP_INSTALL_SILENT)
  1270|     if tee_output:
  1271|         session.run("pylint", "--version")
  1272|         pylint_report_path = os.environ.get("PYLINT_REPORT")
  1273|     cmd_args = ["pylint", f"--rcfile={rcfile}"] + list(flags) + list(paths)
  1274|     cmd_kwargs = {"env": {"PYTHONUNBUFFERED": "1"}}
  1275|     if tee_output:
  1276|         stdout = tempfile.TemporaryFile(mode="w+b")
  1277|         cmd_kwargs["stdout"] = Tee(stdout, sys.__stdout__)
  1278|     lint_failed = False
  1279|     try:
  1280|         session.run(*cmd_args, **cmd_kwargs)
  1281|     except CommandFailed:
  1282|         lint_failed = True
  1283|         raise
  1284|     finally:
  1285|         if tee_output:
  1286|             stdout.seek(0)
  1287|             contents = stdout.read()
  1288|             if contents:
  1289|                 contents = contents.decode("utf-8")
  1290|                 sys.stdout.write(contents)
  1291|                 sys.stdout.flush()
  1292|                 if pylint_report_path:
  1293|                     with open(pylint_report_path, "w") as wfh:
  1294|                         wfh.write(contents)
  1295|                     session.log("Report file written to %r", pylint_report_path)
  1296|             stdout.close()
  1297| def _lint_pre_commit(session, rcfile, flags, paths):
  1298|     if "VIRTUAL_ENV" not in os.environ:
  1299|         session.error(
  1300|             "This should be running from within a virtualenv and "
  1301|             "'VIRTUAL_ENV' was not found as an environment variable."
  1302|         )
  1303|     if "pre-commit" not in os.environ["VIRTUAL_ENV"]:
  1304|         session.error(
  1305|             "This should be running from within a pre-commit virtualenv and "
  1306|             "'VIRTUAL_ENV'({}) does not appear to be a pre-commit virtualenv.".format(
  1307|                 os.environ["VIRTUAL_ENV"]
  1308|             )
  1309|         )
  1310|     from nox.virtualenv import VirtualEnv
  1311|     try:
  1312|         session._runner.venv = VirtualEnv(  # pylint: disable=unexpected-keyword-arg
  1313|             os.environ["VIRTUAL_ENV"],
  1314|             interpreter=session._runner.func.python,
  1315|             reuse_existing=True,
  1316|             venv=True,
  1317|         )
  1318|     except TypeError:
  1319|         session._runner.venv = VirtualEnv(
  1320|             os.environ["VIRTUAL_ENV"],
  1321|             interpreter=session._runner.func.python,
  1322|             reuse_existing=True,
  1323|         )
  1324|     _lint(
  1325|         session,
  1326|         rcfile,
  1327|         flags,
  1328|         paths,
  1329|         tee_output=False,
  1330|         upgrade_setuptools_and_pip=False,
  1331|     )
  1332| @nox.session(python="3")
  1333| def lint(session):
  1334|     """
  1335|     Run PyLint against Salt and it's test suite. Set PYLINT_REPORT to a path to capture output.
  1336|     """
  1337|     session.notify(f"lint-salt-{session.python}")
  1338|     session.notify(f"lint-tests-{session.python}")
  1339| @nox.session(python="3", name="lint-salt")
  1340| def lint_salt(session):
  1341|     """
  1342|     Run PyLint against Salt. Set PYLINT_REPORT to a path to capture output.
  1343|     """
  1344|     flags = ["--disable=I"]
  1345|     if session.posargs:
  1346|         paths = session.posargs
  1347|     else:
  1348|         paths = ["setup.py", "noxfile.py", "salt/"]
  1349|     _lint(session, ".pylintrc", flags, paths)
  1350| @nox.session(python="3", name="lint-tests")
  1351| def lint_tests(session):
  1352|     """
  1353|     Run PyLint against Salt and it's test suite. Set PYLINT_REPORT to a path to capture output.
  1354|     """
  1355|     flags = ["--disable=I"]
  1356|     if session.posargs:
  1357|         paths = session.posargs
  1358|     else:
  1359|         paths = ["tests/"]
  1360|     _lint(session, ".pylintrc", flags, paths)
  1361| @nox.session(python=False, name="lint-salt-pre-commit")
  1362| def lint_salt_pre_commit(session):
  1363|     """
  1364|     Run PyLint against Salt. Set PYLINT_REPORT to a path to capture output.
  1365|     """
  1366|     flags = ["--disable=I"]
  1367|     if session.posargs:
  1368|         paths = session.posargs
  1369|     else:
  1370|         paths = ["setup.py", "noxfile.py", "salt/"]
  1371|     _lint_pre_commit(session, ".pylintrc", flags, paths)
  1372| @nox.session(python=False, name="lint-tests-pre-commit")
  1373| def lint_tests_pre_commit(session):
  1374|     """
  1375|     Run PyLint against Salt and it's test suite. Set PYLINT_REPORT to a path to capture output.
  1376|     """
  1377|     flags = ["--disable=I"]
  1378|     if session.posargs:
  1379|         paths = session.posargs
  1380|     else:
  1381|         paths = ["tests/"]
  1382|     _lint_pre_commit(session, ".pylintrc", flags, paths)
  1383| @nox.session(python="3")
  1384| @nox.parametrize("clean", [False, True])
  1385| @nox.parametrize("update", [False, True])
  1386| @nox.parametrize("compress", [False, True])
  1387| def docs(session, compress, update, clean):
  1388|     """
  1389|     Build Salt's Documentation
  1390|     """
  1391|     session.notify(f"docs-html-{session.python}(compress={compress})")
  1392|     session.notify(
  1393|         find_session_runner(
  1394|             session,
  1395|             "docs-man",
  1396|             session.python,
  1397|             compress=compress,
  1398|             update=update,
  1399|             clean=clean,
  1400|         )
  1401|     )
  1402| @nox.session(name="docs-html", python="3")
  1403| @nox.parametrize("clean", [False, True])
  1404| @nox.parametrize("compress", [False, True])
  1405| def docs_html(session, compress, clean):
  1406|     """
  1407|     Build Salt's HTML Documentation
  1408|     """
  1409|     if _upgrade_pip_setuptools_and_wheel(session):
  1410|         linux_requirements_file = os.path.join(
  1411|             "requirements", "static", "ci", _get_pydir(session), "linux.txt"
  1412|         )
  1413|         base_requirements_file = os.path.join("requirements", "base.txt")
  1414|         zeromq_requirements_file = os.path.join("requirements", "zeromq.txt")
  1415|         docs_requirements_file = os.path.join(
  1416|             "requirements", "static", "ci", _get_pydir(session), "docs.txt"
  1417|         )
  1418|         install_command = [
  1419|             "--progress-bar=off",
  1420|             "--constraint",
  1421|             linux_requirements_file,
  1422|             "-r",
  1423|             base_requirements_file,
  1424|             "-r",
  1425|             zeromq_requirements_file,
  1426|             "-r",
  1427|             docs_requirements_file,
  1428|         ]
  1429|         session.install(*install_command, silent=PIP_INSTALL_SILENT)
  1430|     os.chdir("doc/")
  1431|     if clean:
  1432|         session.run("make", "clean", external=True)
  1433|     session.run("make", "html", "SPHINXOPTS=-W", external=True)
  1434|     if compress:
  1435|         session.run("tar", "-cJvf", "html-archive.tar.xz", "_build/html", external=True)
  1436|     os.chdir("..")
  1437| @nox.session(name="docs-man", python="3")
  1438| @nox.parametrize("clean", [False, True])
  1439| @nox.parametrize("update", [False, True])
  1440| @nox.parametrize("compress", [False, True])
  1441| def docs_man(session, compress, update, clean):
  1442|     """
  1443|     Build Salt's Manpages Documentation
  1444|     """
  1445|     if _upgrade_pip_setuptools_and_wheel(session):
  1446|         linux_requirements_file = os.path.join(
  1447|             "requirements", "static", "ci", _get_pydir(session), "linux.txt"
  1448|         )
  1449|         base_requirements_file = os.path.join("requirements", "base.txt")
  1450|         zeromq_requirements_file = os.path.join("requirements", "zeromq.txt")
  1451|         docs_requirements_file = os.path.join(
  1452|             "requirements", "static", "ci", _get_pydir(session), "docs.txt"
  1453|         )
  1454|         install_command = [
  1455|             "--progress-bar=off",
  1456|             "--constraint",
  1457|             linux_requirements_file,
  1458|             "-r",
  1459|             base_requirements_file,
  1460|             "-r",
  1461|             zeromq_requirements_file,
  1462|             "-r",
  1463|             docs_requirements_file,
  1464|         ]
  1465|         session.install(*install_command, silent=PIP_INSTALL_SILENT)
  1466|     os.chdir("doc/")
  1467|     if clean:
  1468|         session.run("make", "clean", external=True)
  1469|     session.run("make", "man", "SPHINXOPTS=-W", external=True)
  1470|     if update:
  1471|         session.run("rm", "-rf", "man/", external=True)
  1472|         session.run("cp", "-Rp", "_build/man", "man/", external=True)
  1473|     if compress:
  1474|         session.run("tar", "-cJvf", "man-archive.tar.xz", "_build/man", external=True)
  1475|     os.chdir("..")
  1476| @nox.session(name="changelog", python="3")
  1477| @nox.parametrize("draft", [False, True])
  1478| @nox.parametrize("force", [False, True])
  1479| def changelog(session, draft, force):
  1480|     """
  1481|     Generate salt's changelog
  1482|     """
  1483|     session_warn(
  1484|         session,

# --- HUNK 6: Lines 1509-1549 ---
  1509|         tarinfo.uname = tarinfo.gname = "root"
  1510|         tarinfo.mtime = self.mtime
  1511|         if tarinfo.type == tarfile.DIRTYPE:
  1512|             tarinfo.mode = 0o755
  1513|         else:
  1514|             tarinfo.mode = 0o644
  1515|         if tarinfo.pax_headers:
  1516|             raise ValueError(tarinfo.name, tarinfo.pax_headers)
  1517|         return tarinfo
  1518|     def recompress(self, targz):
  1519|         """
  1520|         Re-compress the passed path.
  1521|         """
  1522|         tempd = pathlib.Path(tempfile.mkdtemp()).resolve()
  1523|         d_src = tempd.joinpath("src")
  1524|         d_src.mkdir()
  1525|         d_tar = tempd.joinpath(targz.stem)
  1526|         d_targz = tempd.joinpath(targz.name)
  1527|         with tarfile.open(d_tar, "w|") as wfile:
  1528|             with tarfile.open(targz, "r:gz") as rfile:
  1529|                 rfile.extractall(d_src)
  1530|                 extracted_dir = next(pathlib.Path(d_src).iterdir())
  1531|                 for name in sorted(extracted_dir.rglob("*")):
  1532|                     wfile.add(
  1533|                         str(name),
  1534|                         filter=self.tar_reset,
  1535|                         recursive=False,
  1536|                         arcname=str(name.relative_to(d_src)),
  1537|                     )
  1538|         with open(d_tar, "rb") as rfh:
  1539|             with gzip.GzipFile(
  1540|                 fileobj=open(d_targz, "wb"), mode="wb", filename="", mtime=self.mtime
  1541|             ) as gz:  # pylint: disable=invalid-name
  1542|                 while True:
  1543|                     chunk = rfh.read(1024)
  1544|                     if not chunk:
  1545|                         break
  1546|                     gz.write(chunk)
  1547|         targz.unlink()
  1548|         shutil.move(str(d_targz), str(targz))
  1549| @nox.session(python="3")

# --- HUNK 7: Lines 1608-1753 ---
  1608|         reuse_existing=True,
  1609|         venv=session._runner.venv.venv_or_virtualenv == "venv",
  1610|         venv_params=session._runner.venv.venv_params,
  1611|     )
  1612|     os.environ["VIRTUAL_ENV"] = session._runner.venv.location
  1613|     session._runner.venv.create()
  1614|     if not ONEDIR_ARTIFACT_PATH.exists():
  1615|         session.error(
  1616|             "The salt onedir artifact, expected to be in '{}', was not found".format(
  1617|                 ONEDIR_ARTIFACT_PATH.relative_to(REPO_ROOT)
  1618|             )
  1619|         )
  1620|     common_pytest_args = [
  1621|         "--color=yes",
  1622|         "--sys-stats",
  1623|         "--run-destructive",
  1624|         f"--output-columns={os.environ.get('OUTPUT_COLUMNS') or 120}",
  1625|         "--pkg-system-service",
  1626|     ]
  1627|     chunks = {
  1628|         "install": [
  1629|             "tests/pytests/pkg/",
  1630|         ],
  1631|         "upgrade": [
  1632|             "--upgrade",
  1633|             "--no-uninstall",
  1634|             "tests/pytests/pkg/upgrade/",
  1635|         ],
  1636|         "upgrade-classic": [
  1637|             "--upgrade",
  1638|             "--no-uninstall",
  1639|             "tests/pytests/pkg/upgrade/",
  1640|         ],
  1641|         "downgrade": [
  1642|             "--downgrade",
  1643|             "--no-uninstall",
  1644|             "tests/pytests/pkg/downgrade/",
  1645|         ],
  1646|         "downgrade-classic": [
  1647|             "--downgrade",
  1648|             "--no-uninstall",
  1649|             "tests/pytests/pkg/downgrade/",
  1650|         ],
  1651|         "download-pkgs": [
  1652|             "--download-pkgs",
  1653|             "tests/pytests/pkg/download/",
  1654|         ],
  1655|     }
  1656|     if not session.posargs or session.posargs[0] not in chunks:
  1657|         chunk = "install"
  1658|         session.log("Choosing default 'install' test type")
  1659|     else:
  1660|         chunk = session.posargs.pop(0)
  1661|     cmd_args = chunks[chunk]
  1662|     for arg in session.posargs:
  1663|         if arg.startswith("tests/pytests/pkg/"):
  1664|             cmd_args.pop()
  1665|             break
  1666|     if IS_LINUX:
  1667|         session_run_always(session, "python3", "-m", "relenv", "toolchain", "fetch")
  1668|     if _upgrade_pip_setuptools_and_wheel(session):
  1669|         _install_requirements(session, "pyzmq")
  1670|     env = {
  1671|         "ONEDIR_TESTRUN": "1",
  1672|         "PKG_TEST_TYPE": chunk,
  1673|     }
  1674|     if chunk in ("upgrade-classic", "downgrade-classic"):
  1675|         cmd_args.append("--classic")
  1676|     pytest_args = (
  1677|         common_pytest_args[:]
  1678|         + cmd_args[:]
  1679|         + [
  1680|             f"--junitxml=artifacts/xml-unittests-output/test-results-{chunk}.xml",
  1681|             f"--log-file=artifacts/logs/runtests-{chunk}.log",
  1682|         ]
  1683|         + session.posargs
  1684|     )
  1685|     try:
  1686|         _pytest(session, coverage=False, cmd_args=pytest_args, env=env)
  1687|     except CommandFailed:
  1688|         if os.environ.get("RERUN_FAILURES", "0") == "0":
  1689|             return
  1690|         global PRINT_TEST_SELECTION
  1691|         global PRINT_SYSTEM_INFO
  1692|         PRINT_TEST_SELECTION = False
  1693|         PRINT_SYSTEM_INFO = False
  1694|         pytest_args = (
  1695|             common_pytest_args[:]
  1696|             + cmd_args[:]
  1697|             + [
  1698|                 f"--junitxml=artifacts/xml-unittests-output/test-results-{chunk}-rerun.xml",
  1699|                 f"--log-file=artifacts/logs/runtests-{chunk}-rerun.log",
  1700|                 "--lf",
  1701|             ]
  1702|             + session.posargs
  1703|         )
  1704|         _pytest(
  1705|             session,
  1706|             coverage=False,
  1707|             cmd_args=pytest_args,
  1708|             env=env,
  1709|             on_rerun=True,
  1710|         )
  1711|     if chunk not in ("install", "download-pkgs"):
  1712|         cmd_args = chunks["install"]
  1713|         pytest_args = (
  1714|             common_pytest_args[:]
  1715|             + cmd_args[:]
  1716|             + [
  1717|                 "--no-install",
  1718|                 f"--junitxml=artifacts/xml-unittests-output/test-results-install.xml",
  1719|                 f"--log-file=artifacts/logs/runtests-install.log",
  1720|             ]
  1721|             + session.posargs
  1722|         )
  1723|         if "downgrade" in chunk:
  1724|             pytest_args.append("--use-prev-version")
  1725|         if chunk in ("upgrade-classic", "downgrade-classic"):
  1726|             pytest_args.append("--classic")
  1727|         try:
  1728|             _pytest(session, coverage=False, cmd_args=pytest_args, env=env)
  1729|         except CommandFailed:
  1730|             cmd_args = chunks["install"]
  1731|             pytest_args = (
  1732|                 common_pytest_args[:]
  1733|                 + cmd_args[:]
  1734|                 + [
  1735|                     "--no-install",
  1736|                     f"--junitxml=artifacts/xml-unittests-output/test-results-install-rerun.xml",
  1737|                     f"--log-file=artifacts/logs/runtests-install-rerun.log",
  1738|                     "--lf",
  1739|                 ]
  1740|                 + session.posargs
  1741|             )
  1742|             if "downgrade" in chunk:
  1743|                 pytest_args.append("--use-prev-version")
  1744|             if chunk in ("upgrade-classic", "downgrade-classic"):
  1745|                 pytest_args.append("--classic")
  1746|             _pytest(
  1747|                 session,
  1748|                 coverage=False,
  1749|                 cmd_args=pytest_args,
  1750|                 env=env,
  1751|                 on_rerun=True,
  1752|             )
  1753|     sys.exit(0)


# ====================================================================
# FILE: salt/__init__.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-70 ---
     1| """
     2| Salt package
     3| """
     4| import asyncio
     5| import importlib
     6| import locale
     7| import os
     8| import sys
     9| import warnings
    10| if sys.platform.startswith("win"):
    11|     asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
    12| if sys.version_info < (3,):  # pragma: no cover
    13|     sys.stderr.write(
    14|         "\n\nAfter the Sodium release, 3001, Salt no longer supports Python 2. Exiting.\n\n"
    15|     )
    16|     sys.stderr.flush()
    17| class NaclImporter:
    18|     """
    19|     Import hook to force PyNaCl to perform dlopen on libsodium with the
    20|     RTLD_DEEPBIND flag. This is to work around an issue where pyzmq does a dlopen
    21|     with RTLD_GLOBAL which then causes calls to libsodium to resolve to
    22|     tweetnacl when it's been bundled with pyzmq.
    23|     See:  https://github.com/zeromq/pyzmq/issues/1878
    24|     """
    25|     loading = False
    26|     def find_module(self, module_name, package_path=None):
    27|         if not NaclImporter.loading and module_name.startswith("nacl"):
    28|             NaclImporter.loading = True
    29|             return self
    30|         return None
    31|     def create_module(self, spec):
    32|         dlopen = hasattr(sys, "getdlopenflags")
    33|         if dlopen:
    34|             dlflags = sys.getdlopenflags()
    35|             if hasattr(os, "RTLD_DEEPBIND"):
    36|                 flags = os.RTLD_DEEPBIND | dlflags
    37|             else:
    38|                 flags = dlflags
    39|             sys.setdlopenflags(flags)
    40|         try:
    41|             mod = importlib.import_module(spec.name)
    42|         finally:
    43|             if dlopen:
    44|                 sys.setdlopenflags(dlflags)
    45|         NaclImporter.loading = False
    46|         sys.modules[spec.name] = mod
    47|         return mod
    48|     def exec_module(self, module):
    49|         return None
    50| sys.meta_path = [NaclImporter()] + sys.meta_path
    51| warnings.filterwarnings(
    52|     "once",  # Show once
    53|     "",  # No deprecation message match
    54|     DeprecationWarning,  # This filter is for DeprecationWarnings
    55|     r"^(salt|salt\.(.*))$",  # Match module(s) 'salt' and 'salt.<whatever>'
    56| )
    57| warnings.filterwarnings(
    58|     "ignore",
    59|     "^Module backports was already imported from (.*), but (.*) is being added to sys.path$",
    60|     UserWarning,
    61|     append=True,
    62| )
    63| warnings.filterwarnings(
    64|     "ignore",
    65|     message="Setuptools is replacing distutils.",
    66|     category=UserWarning,
    67|     module="_distutils_hack",
    68| )
    69| warnings.filterwarnings(
    70|     "ignore",


# ====================================================================
# FILE: salt/_logging/handlers.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 53-93 ---
    53|         while self.__messages:
    54|             record = self.__messages.popleft()
    55|             for handler in handlers:
    56|                 if handler is self:
    57|                     continue
    58|                 handler.handle(record)
    59| class FileHandler(ExcInfoOnLogLevelFormatMixin, logging.FileHandler):
    60|     """
    61|     File handler which properly handles exc_info on a per handler basis
    62|     """
    63| class SysLogHandler(ExcInfoOnLogLevelFormatMixin, logging.handlers.SysLogHandler):
    64|     """
    65|     Syslog handler which properly handles exc_info on a per handler basis
    66|     """
    67|     def handleError(self, record):
    68|         """
    69|         Override the default error handling mechanism for py3
    70|         Deal with syslog os errors when the log file does not exist
    71|         """
    72|         handled = False
    73|         if sys.stderr:
    74|             exc_type, exc, exc_traceback = sys.exc_info()
    75|             try:
    76|                 if exc_type.__name__ in "FileNotFoundError":
    77|                     sys.stderr.write(
    78|                         "[WARNING ] The log_file does not exist. Logging not "
    79|                         "setup correctly or syslog service not started.\n"
    80|                     )
    81|                     handled = True
    82|             finally:
    83|                 del exc_type, exc, exc_traceback
    84|         if not handled:
    85|             super().handleError(record)
    86| class RotatingFileHandler(
    87|     ExcInfoOnLogLevelFormatMixin, logging.handlers.RotatingFileHandler
    88| ):
    89|     """
    90|     Rotating file handler which properly handles exc_info on a per handler basis
    91|     """
    92|     def handleError(self, record):
    93|         """


# ====================================================================
# FILE: salt/_logging/impl.py
# Total hunks: 5
# ====================================================================
# --- HUNK 1: Lines 2-49 ---
     2|     salt._logging.impl
     3|     ~~~~~~~~~~~~~~~~~~
     4|     Salt's logging implementation classes/functionality
     5| """
     6| import atexit
     7| import logging
     8| import multiprocessing
     9| import os
    10| import pathlib
    11| import re
    12| import socket
    13| import sys
    14| import traceback
    15| import types
    16| import urllib.parse
    17| PROFILE = logging.PROFILE = 15
    18| TRACE = logging.TRACE = 5
    19| GARBAGE = logging.GARBAGE = 1
    20| QUIET = logging.QUIET = 1000
    21| import salt.defaults.exitcodes  # isort:skip  pylint: disable=unused-import
    22| import salt.utils.ctx
    23| from salt._logging.handlers import DeferredStreamHandler  # isort:skip
    24| from salt._logging.handlers import RotatingFileHandler  # isort:skip
    25| from salt._logging.handlers import StreamHandler  # isort:skip
    26| from salt._logging.handlers import SysLogHandler  # isort:skip
    27| from salt._logging.handlers import WatchedFileHandler  # isort:skip
    28| from salt._logging.mixins import LoggingMixinMeta  # isort:skip
    29| from salt.exceptions import LoggingRuntimeError  # isort:skip
    30| from salt.utils.immutabletypes import freeze, ImmutableDict  # isort:skip
    31| from salt.utils.textformat import TextFormat  # isort:skip
    32| LOG_LEVELS = {
    33|     "all": logging.NOTSET,
    34|     "debug": logging.DEBUG,
    35|     "error": logging.ERROR,
    36|     "critical": logging.CRITICAL,
    37|     "garbage": GARBAGE,
    38|     "info": logging.INFO,
    39|     "profile": PROFILE,
    40|     "quiet": QUIET,
    41|     "trace": TRACE,
    42|     "warning": logging.WARNING,
    43| }
    44| LOG_VALUES_TO_LEVELS = {v: k for (k, v) in LOG_LEVELS.items()}
    45| LOG_COLORS = {
    46|     "levels": {
    47|         "QUIET": TextFormat("reset"),
    48|         "CRITICAL": TextFormat("bold", "red"),
    49|         "ERROR": TextFormat("bold", "red"),

# --- HUNK 2: Lines 118-158 ---
   118|     except AttributeError:
   119|         return
   120| def set_log_record_factory(factory):
   121|     """
   122|     Set the logging  log record factory
   123|     """
   124|     get_log_record_factory.__factory__ = factory
   125|     logging.setLogRecordFactory(factory)
   126| set_log_record_factory(SaltLogRecord)
   127| LOGGING_LOGGER_CLASS = logging.getLoggerClass()
   128| class SaltLoggingClass(LOGGING_LOGGER_CLASS, metaclass=LoggingMixinMeta):
   129|     def __new__(cls, *args):
   130|         """
   131|         We override `__new__` in our logging logger class in order to provide
   132|         some additional features like expand the module name padding if length
   133|         is being used, and also some Unicode fixes.
   134|         This code overhead will only be executed when the class is
   135|         instantiated, i.e.:
   136|             logging.getLogger(__name__)
   137|         """
   138|         instance = super().__new__(cls)
   139|         try:
   140|             max_logger_length = len(
   141|                 max(list(logging.Logger.manager.loggerDict), key=len)
   142|             )
   143|             if max_logger_length > 80:
   144|                 max_logger_length = 80
   145|             for handler in logging.root.handlers:
   146|                 if handler is get_temp_handler():
   147|                     continue
   148|                 formatter = handler.formatter
   149|                 if not formatter:
   150|                     continue
   151|                 if not handler.lock:
   152|                     handler.createLock()
   153|                 handler.acquire()
   154|                 fmt = formatter._fmt.replace("%", "%%")
   155|                 match = MODNAME_PATTERN.search(fmt)
   156|                 if not match:
   157|                     handler.release()
   158|                     return instance

# --- HUNK 3: Lines 169-260 ---
   169|                         fmt % max_logger_length, datefmt=formatter.datefmt
   170|                     )
   171|                     handler.setFormatter(formatter)
   172|                 handler.release()
   173|         except ValueError:
   174|             pass
   175|         return instance
   176|     def _log(
   177|         self,
   178|         level,
   179|         msg,
   180|         args,
   181|         exc_info=None,
   182|         extra=None,  # pylint: disable=arguments-differ
   183|         stack_info=False,
   184|         stacklevel=1,
   185|         exc_info_on_loglevel=None,
   186|     ):
   187|         if extra is None:
   188|             extra = {}
   189|         current_jid = (
   190|             salt.utils.ctx.get_request_context().get("data", {}).get("jid", None)
   191|         )
   192|         log_fmt_jid = (
   193|             salt.utils.ctx.get_request_context()
   194|             .get("opts", {})
   195|             .get("log_fmt_jid", None)
   196|         )
   197|         if current_jid is not None:
   198|             extra["jid"] = current_jid
   199|         if log_fmt_jid is not None:
   200|             extra["log_fmt_jid"] = log_fmt_jid
   201|         if exc_info and exc_info_on_loglevel:
   202|             raise LoggingRuntimeError(
   203|                 "Only one of 'exc_info' and 'exc_info_on_loglevel' is permitted"
   204|             )
   205|         if exc_info_on_loglevel is not None:
   206|             if isinstance(exc_info_on_loglevel, str):
   207|                 exc_info_on_loglevel = LOG_LEVELS.get(
   208|                     exc_info_on_loglevel, logging.ERROR
   209|                 )
   210|             elif not isinstance(exc_info_on_loglevel, int):
   211|                 raise RuntimeError(
   212|                     "The value of 'exc_info_on_loglevel' needs to be a "
   213|                     "logging level or a logging level name, not '{}'".format(
   214|                         exc_info_on_loglevel
   215|                     )
   216|                 )
   217|         if extra is None:
   218|             extra = {"exc_info_on_loglevel": exc_info_on_loglevel}
   219|         else:
   220|             extra["exc_info_on_loglevel"] = exc_info_on_loglevel
   221|         try:
   222|             LOGGING_LOGGER_CLASS._log(
   223|                 self,
   224|                 level,
   225|                 msg,
   226|                 args,
   227|                 exc_info=exc_info,
   228|                 extra=extra,
   229|                 stack_info=stack_info,
   230|                 stacklevel=stacklevel,
   231|             )
   232|         except TypeError:
   233|             LOGGING_LOGGER_CLASS._log(
   234|                 self,
   235|                 level,
   236|                 msg,
   237|                 args,
   238|                 exc_info=exc_info,
   239|                 extra=extra,
   240|                 stack_info=stack_info,
   241|             )
   242|     def makeRecord(
   243|         self,
   244|         name,
   245|         level,
   246|         fn,
   247|         lno,
   248|         msg,
   249|         args,
   250|         exc_info,
   251|         func=None,
   252|         extra=None,
   253|         sinfo=None,
   254|     ):
   255|         exc_info_on_loglevel = extra.pop("exc_info_on_loglevel")
   256|         jid = extra.pop("jid", "")
   257|         if jid:
   258|             log_fmt_jid = extra.pop("log_fmt_jid")
   259|             jid = log_fmt_jid % {"jid": jid}
   260|         if not extra:

# --- HUNK 4: Lines 357-402 ---
   357|     """
   358|     Setup the temporary deferred stream handler
   359|     """
   360|     handler = get_temp_handler()
   361|     if handler is not None:
   362|         log_level = get_logging_level_from_string(log_level)
   363|         if handler.level != log_level:
   364|             handler.setLevel(log_level)
   365|         return
   366|     if log_level is None:
   367|         log_level = logging.WARNING
   368|     log_level = get_logging_level_from_string(log_level)
   369|     handler = None
   370|     for handler in logging.root.handlers:
   371|         if not hasattr(handler, "stream"):
   372|             continue
   373|         if handler.stream is sys.stderr:
   374|             break
   375|     else:
   376|         handler = DeferredStreamHandler(sys.stderr)
   377|         def tryflush():
   378|             try:
   379|                 handler.flush()
   380|             except ValueError:
   381|                 pass
   382|         atexit.register(tryflush)
   383|     handler.setLevel(log_level)
   384|     formatter = logging.Formatter(DFLT_LOG_FMT_CONSOLE, datefmt=DFLT_LOG_DATEFMT)
   385|     handler.setFormatter(formatter)
   386|     logging.root.addHandler(handler)
   387|     setup_temp_handler.__handler__ = handler
   388| def shutdown_temp_handler():
   389|     """
   390|     Shutdown the temporary deferred stream handler
   391|     """
   392|     temp_handler = get_temp_handler()
   393|     if temp_handler is not None:
   394|         for handler in logging.root.handlers[:]:
   395|             if handler is temp_handler:
   396|                 logging.root.handlers.remove(handler)
   397|                 handler.sync_with_handlers(logging.root.handlers)
   398|                 handler.close()
   399|                 break
   400|         setup_temp_handler.__handler__ = None
   401| if logging.getLoggerClass() is not SaltLoggingClass:
   402|     try:


# ====================================================================
# FILE: salt/auth/__init__.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 206-246 ---
   206|         tdata = {}
   207|         try:
   208|             tdata = self.tokens["{}.get_token".format(self.opts["eauth_tokens"])](
   209|                 self.opts, tok
   210|             )
   211|         except salt.exceptions.SaltDeserializationError:
   212|             log.warning("Failed to load token %r - removing broken/empty file.", tok)
   213|             rm_tok = True
   214|         else:
   215|             if not tdata:
   216|                 return {}
   217|             rm_tok = False
   218|         if tdata.get("expire", 0) < time.time():
   219|             rm_tok = True
   220|         if rm_tok:
   221|             self.rm_token(tok)
   222|             return {}
   223|         return tdata
   224|     def list_tokens(self):
   225|         """
   226|         List all tokens in eauth_tokens storage.
   227|         """
   228|         return self.tokens["{}.list_tokens".format(self.opts["eauth_tokens"])](
   229|             self.opts
   230|         )
   231|     def rm_token(self, tok):
   232|         """
   233|         Remove the given token from token storage.
   234|         """
   235|         self.tokens["{}.rm_token".format(self.opts["eauth_tokens"])](self.opts, tok)
   236|     def authenticate_token(self, load):
   237|         """
   238|         Authenticate a user by the token specified in load.
   239|         Return the token object or False if auth failed.
   240|         """
   241|         token = self.get_tok(load["token"])
   242|         if not token or token["eauth"] not in self.opts["external_auth"]:
   243|             log.warning('Authentication failure of type "token" occurred.')
   244|             return False
   245|         return token
   246|     def authenticate_eauth(self, load):

# --- HUNK 2: Lines 489-529 ---
   489|         """
   490|         load["cmd"] = "mk_token"
   491|         tdata = self._send_token_request(load)
   492|         return tdata
   493|     def get_token(self, token):
   494|         """
   495|         Request a token from the master
   496|         """
   497|         load = {}
   498|         load["token"] = token
   499|         load["cmd"] = "get_token"
   500|         tdata = self._send_token_request(load)
   501|         return tdata
   502| class AuthUser:
   503|     """
   504|     Represents a user requesting authentication to the salt master
   505|     """
   506|     def __init__(self, user):
   507|         """
   508|         Instantiate an AuthUser object.
   509|         Takes a user to represent, as a string.
   510|         """
   511|         self.user = user
   512|     def is_sudo(self):
   513|         """
   514|         Determines if the user is running with sudo
   515|         Returns True if the user is running with sudo and False if the
   516|         user is not running with sudo
   517|         """
   518|         return self.user.startswith("sudo_")
   519|     def is_running_user(self):
   520|         """
   521|         Determines if the user is the same user as the one running
   522|         this process
   523|         Returns True if the user is the same user as the one running
   524|         this process and False if not.
   525|         """
   526|         return self.user == salt.utils.user.get_user()
   527|     def sudo_name(self):
   528|         """
   529|         Returns the username of the sudoer, i.e. self.user without the


# ====================================================================
# FILE: salt/beacons/__init__.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 279-319 ---
   279|         return True
   280|     def add_beacon(self, name, beacon_data):
   281|         """
   282|         Add a beacon item
   283|         """
   284|         data = {}
   285|         data[name] = beacon_data
   286|         if name in self._get_beacons(include_opts=False):
   287|             comment = (
   288|                 "Cannot update beacon item {}, "
   289|                 "because it is configured in pillar.".format(name)
   290|             )
   291|             complete = False
   292|         else:
   293|             if name in self.opts["beacons"]:
   294|                 comment = f"Updating settings for beacon item: {name}"
   295|             else:
   296|                 comment = f"Added new beacon item: {name}"
   297|             complete = True
   298|             self.opts["beacons"].update(data)
   299|         with salt.utils.event.get_event("minion", opts=self.opts, listen=False) as evt:
   300|             evt.fire_event(
   301|                 {
   302|                     "complete": complete,
   303|                     "comment": comment,
   304|                     "beacons": self.opts["beacons"],
   305|                 },
   306|                 tag="/salt/minion/minion_beacon_add_complete",
   307|             )
   308|         return True
   309|     def modify_beacon(self, name, beacon_data):
   310|         """
   311|         Modify a beacon item
   312|         """
   313|         data = {}
   314|         data[name] = beacon_data
   315|         if name in self._get_beacons(include_opts=False):
   316|             comment = f"Cannot modify beacon item {name}, it is configured in pillar."
   317|             complete = False
   318|         else:
   319|             comment = f"Updating settings for beacon item: {name}"


# ====================================================================
# FILE: salt/beacons/twilio_txt_msg.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-32 ---
     1| """
     2| Beacon to emit Twilio text messages
     3| """
     4| import logging
     5| import salt.utils.beacons
     6| try:
     7|     import twilio
     8|     twilio_version = tuple(int(x) for x in twilio.__version_info__)
     9|     if twilio_version > (5,):
    10|         from twilio.rest import Client as TwilioRestClient
    11|     else:
    12|         from twilio.rest import TwilioRestClient  # pylint: disable=no-name-in-module
    13|     HAS_TWILIO = True
    14| except ImportError:
    15|     HAS_TWILIO = False
    16| log = logging.getLogger(__name__)
    17| __virtualname__ = "twilio_txt_msg"
    18| def __virtual__():
    19|     if HAS_TWILIO:
    20|         return __virtualname__
    21|     else:
    22|         err_msg = "twilio library is missing."
    23|         log.error("Unable to load %s beacon: %s", __virtualname__, err_msg)
    24|         return False, err_msg
    25| def validate(config):
    26|     """
    27|     Validate the beacon configuration
    28|     """
    29|     if not isinstance(config, list):
    30|         return False, "Configuration for twilio_txt_msg beacon must be a list."
    31|     else:
    32|         config = salt.utils.beacons.list_to_dict(config)


# ====================================================================
# FILE: salt/cache/mysql_cache.py
# Total hunks: 5
# ====================================================================
# --- HUNK 1: Lines 5-116 ---
     5| infrastructure. All is needed for this plugin is a working MySQL server.
     6| .. warning::
     7|     The mysql.database and mysql.table_name will be directly added into certain
     8|     queries. Salt treats these as trusted input.
     9| The module requires the database (default ``salt_cache``) to exist but creates
    10| its own table if needed. The keys are indexed using the ``bank`` and
    11| ``etcd_key`` columns.
    12| To enable this cache plugin, the master will need the python client for
    13| MySQL installed. This can be easily installed with pip:
    14| .. code-block:: bash
    15|     pip install pymysql
    16| Optionally, depending on the MySQL agent configuration, the following values
    17| could be set in the master config. These are the defaults:
    18| .. code-block:: yaml
    19|     mysql.host: 127.0.0.1
    20|     mysql.port: 2379
    21|     mysql.user: None
    22|     mysql.password: None
    23|     mysql.database: salt_cache
    24|     mysql.table_name: cache
    25|     mysql.fresh_connection: false
    26| Related docs can be found in the `python-mysql documentation`_.
    27| To use the mysql as a minion data cache backend, set the master ``cache`` config
    28| value to ``mysql``:
    29| .. code-block:: yaml
    30|     cache: mysql
    31| .. _`MySQL documentation`: https://github.com/coreos/mysql
    32| .. _`python-mysql documentation`: http://python-mysql.readthedocs.io/en/latest/
    33| """
    34| import copy
    35| import logging
    36| import time
    37| import salt.payload
    38| import salt.utils.stringutils
    39| from salt.exceptions import SaltCacheError
    40| try:
    41|     import MySQLdb
    42|     import MySQLdb.converters
    43|     import MySQLdb.cursors
    44|     from MySQLdb.connections import OperationalError
    45|     class InterfaceError(Exception):
    46|         pass
    47| except ImportError:
    48|     try:
    49|         import pymysql
    50|         from pymysql.err import InterfaceError
    51|         pymysql.install_as_MySQLdb()
    52|         import MySQLdb
    53|         import MySQLdb.converters
    54|         import MySQLdb.cursors
    55|         from MySQLdb.err import OperationalError
    56|     except ImportError:
    57|         MySQLdb = None
    58| _DEFAULT_DATABASE_NAME = "salt_cache"
    59| _DEFAULT_CACHE_TABLE_NAME = "cache"
    60| _RECONNECT_INTERVAL_SEC = 0.050
    61| log = logging.getLogger(__name__)
    62| __virtualname__ = "mysql"
    63| __func_alias__ = {"ls": "list"}
    64| def __virtual__():
    65|     """
    66|     Confirm that a python mysql client is installed.
    67|     """
    68|     return bool(MySQLdb), "No python mysql client installed." if MySQLdb is None else ""
    69| def force_reconnect():
    70|     """
    71|     Force a reconnection to the MySQL database, by removing the client from
    72|     Salt's __context__.
    73|     """
    74|     __context__.pop("mysql_client", None)
    75| def run_query(conn, query, args=None, retries=3):
    76|     """
    77|     Get a cursor and run a query. Reconnect up to ``retries`` times if
    78|     needed.
    79|     Returns: cursor, affected rows counter
    80|     Raises: SaltCacheError, AttributeError, OperationalError, InterfaceError
    81|     """
    82|     if __context__.get("mysql_fresh_connection"):
    83|         conn = MySQLdb.connect(**__context__["mysql_kwargs"])
    84|         __context__["mysql_client"] = conn
    85|     if conn is None:
    86|         conn = __context__.get("mysql_client")
    87|     try:
    88|         cur = conn.cursor()
    89|         if not args:
    90|             log.debug("Doing query: %s", query)
    91|             out = cur.execute(query)
    92|         else:
    93|             log.debug("Doing query: %s args: %s ", query, repr(args))
    94|             out = cur.execute(query, args)
    95|         return cur, out
    96|     except (AttributeError, OperationalError, InterfaceError) as e:
    97|         if retries == 0:
    98|             raise
    99|         time.sleep(_RECONNECT_INTERVAL_SEC)
   100|         if conn is None:
   101|             log.debug("mysql_cache: creating db connection")
   102|         else:
   103|             log.info("mysql_cache: recreating db connection due to: %r", e)
   104|         __context__["mysql_client"] = MySQLdb.connect(**__context__["mysql_kwargs"])
   105|         return run_query(
   106|             conn=__context__.get("mysql_client"),
   107|             query=query,
   108|             args=args,
   109|             retries=(retries - 1),
   110|         )
   111|     except Exception as e:  # pylint: disable=broad-except
   112|         if len(query) > 150:
   113|             query = query[:150] + "<...>"
   114|         raise SaltCacheError(
   115|             "Error running {}{}: {}".format(query, f"- args: {args}" if args else "", e)
   116|         )

# --- HUNK 2: Lines 172-212 ---
   172|     log.info("mysql_cache: creating table %s", __context__["mysql_table_name"])
   173|     cur, _ = run_query(__context__.get("mysql_client"), query)
   174|     cur.close()
   175| def _init_client():
   176|     """Initialize connection and create table if needed"""
   177|     if __context__.get("mysql_client") is not None:
   178|         return
   179|     opts = copy.deepcopy(__opts__)
   180|     mysql_kwargs = {
   181|         "autocommit": True,
   182|         "host": opts.pop("mysql.host", "127.0.0.1"),
   183|         "user": opts.pop("mysql.user", None),
   184|         "passwd": opts.pop("mysql.password", None),
   185|         "db": opts.pop("mysql.database", _DEFAULT_DATABASE_NAME),
   186|         "port": opts.pop("mysql.port", 3306),
   187|         "unix_socket": opts.pop("mysql.unix_socket", None),
   188|         "connect_timeout": opts.pop("mysql.connect_timeout", None),
   189|     }
   190|     mysql_kwargs["autocommit"] = True
   191|     __context__["mysql_table_name"] = opts.pop("mysql.table_name", "salt")
   192|     __context__["mysql_fresh_connection"] = opts.pop("mysql.fresh_connection", False)
   193|     for k in opts:
   194|         if k.startswith("mysql."):
   195|             _key = k.split(".")[1]
   196|             mysql_kwargs[_key] = opts.get(k)
   197|     for k, v in copy.deepcopy(mysql_kwargs).items():
   198|         if v is None:
   199|             mysql_kwargs.pop(k)
   200|     kwargs_copy = mysql_kwargs.copy()
   201|     kwargs_copy["passwd"] = "<hidden>"
   202|     log.info("mysql_cache: Setting up client with params: %r", kwargs_copy)
   203|     __context__["mysql_kwargs"] = mysql_kwargs
   204|     _create_table()
   205| def store(bank, key, data):
   206|     """
   207|     Store a key value.
   208|     """
   209|     _init_client()
   210|     data = salt.payload.dumps(data)
   211|     query = "REPLACE INTO {} (bank, etcd_key, data) values(%s,%s,%s)".format(
   212|         __context__["mysql_table_name"]

# --- HUNK 3: Lines 224-264 ---
   224|     query = "SELECT data FROM {} WHERE bank=%s AND etcd_key=%s".format(
   225|         __context__["mysql_table_name"]
   226|     )
   227|     cur, _ = run_query(__context__.get("mysql_client"), query, args=(bank, key))
   228|     r = cur.fetchone()
   229|     cur.close()
   230|     if r is None:
   231|         return {}
   232|     return salt.payload.loads(r[0])
   233| def flush(bank, key=None):
   234|     """
   235|     Remove the key from the cache bank with all the key content.
   236|     """
   237|     _init_client()
   238|     query = "DELETE FROM {} WHERE bank=%s".format(__context__["mysql_table_name"])
   239|     if key is None:
   240|         data = (bank,)
   241|     else:
   242|         data = (bank, key)
   243|         query += " AND etcd_key=%s"
   244|     cur, _ = run_query(__context__.get("mysql_client"), query, args=data)
   245|     cur.close()
   246| def ls(bank):
   247|     """
   248|     Return an iterable object containing all entries stored in the specified
   249|     bank.
   250|     """
   251|     _init_client()
   252|     query = "SELECT etcd_key FROM {} WHERE bank=%s".format(
   253|         __context__["mysql_table_name"]
   254|     )
   255|     cur, _ = run_query(__context__.get("mysql_client"), query, args=(bank,))
   256|     out = [row[0] for row in cur.fetchall()]
   257|     cur.close()
   258|     return out
   259| def contains(bank, key):
   260|     """
   261|     Checks if the specified bank contains the specified key.
   262|     """
   263|     _init_client()
   264|     if key is None:

# --- HUNK 4: Lines 269-292 ---
   269|     else:
   270|         data = (bank, key)
   271|         query = "SELECT COUNT(data) FROM {} WHERE bank=%s AND etcd_key=%s".format(
   272|             __context__["mysql_table_name"]
   273|         )
   274|     cur, _ = run_query(__context__.get("mysql_client"), query, args=data)
   275|     r = cur.fetchone()
   276|     cur.close()
   277|     return r[0] == 1
   278| def updated(bank, key):
   279|     """
   280|     Return the integer Unix epoch update timestamp of the specified bank and
   281|     key.
   282|     """
   283|     _init_client()
   284|     query = (
   285|         "SELECT UNIX_TIMESTAMP(last_update) FROM {} WHERE bank=%s "
   286|         "AND etcd_key=%s".format(__context__["mysql_table_name"])
   287|     )
   288|     data = (bank, key)
   289|     cur, _ = run_query(__context__.get("mysql_client"), query=query, args=data)
   290|     r = cur.fetchone()
   291|     cur.close()
   292|     return int(r[0]) if r else r


# ====================================================================
# FILE: salt/channel/client.py
# Total hunks: 8
# ====================================================================
# --- HUNK 1: Lines 1-53 ---
     1| """
     2| Encapsulate the different transports available to Salt.
     3| This includes client side transport, for the ReqServer and the Publisher
     4| """
     5| import logging
     6| import os
     7| import time
     8| import uuid
     9| import tornado.gen
    10| import tornado.ioloop
    11| import salt.crypt
    12| import salt.exceptions
    13| import salt.payload
    14| import salt.transport.frame
    15| import salt.utils.event
    16| import salt.utils.files
    17| import salt.utils.minions
    18| import salt.utils.stringutils
    19| import salt.utils.verify
    20| import salt.utils.versions
    21| from salt.utils.asynchronous import SyncWrapper
    22| try:
    23|     from M2Crypto import RSA
    24|     HAS_M2 = True
    25| except ImportError:
    26|     HAS_M2 = False
    27|     try:
    28|         from Cryptodome.Cipher import PKCS1_OAEP
    29|     except ImportError:
    30|         try:
    31|             from Crypto.Cipher import PKCS1_OAEP  # nosec
    32|         except ImportError:
    33|             pass
    34| log = logging.getLogger(__name__)
    35| REQUEST_CHANNEL_TIMEOUT = 60
    36| REQUEST_CHANNEL_TRIES = 3
    37| class ReqChannel:
    38|     """
    39|     Factory class to create a sychronous communication channels to the master's
    40|     ReqServer. ReqChannels use transports to connect to the ReqServer.
    41|     """
    42|     @staticmethod
    43|     def factory(opts, **kwargs):
    44|         return SyncWrapper(
    45|             AsyncReqChannel.factory,
    46|             (opts,),
    47|             kwargs,
    48|             loop_kwarg="io_loop",
    49|         )
    50| class PushChannel:
    51|     """
    52|     Factory class to create Sync channel for push side of push/pull IPC
    53|     """

# --- HUNK 2: Lines 80-451 ---
    80|         "crypted_transfer_decode_dictentry",
    81|         "_crypted_transfer",
    82|         "_uncrypted_transfer",
    83|         "send",
    84|         "connect",
    85|     ]
    86|     close_methods = [
    87|         "close",
    88|     ]
    89|     @classmethod
    90|     def factory(cls, opts, **kwargs):
    91|         ttype = "zeromq"
    92|         if "transport" in opts:
    93|             ttype = opts["transport"]
    94|         elif "transport" in opts.get("pillar", {}).get("master", {}):
    95|             ttype = opts["pillar"]["master"]["transport"]
    96|         if "master_uri" not in opts and "master_uri" in kwargs:
    97|             opts["master_uri"] = kwargs["master_uri"]
    98|         io_loop = kwargs.get("io_loop")
    99|         if io_loop is None:
   100|             io_loop = tornado.ioloop.IOLoop.current()
   101|         timeout = opts.get("request_channel_timeout", REQUEST_CHANNEL_TIMEOUT)
   102|         tries = opts.get("request_channel_tries", REQUEST_CHANNEL_TRIES)
   103|         crypt = kwargs.get("crypt", "aes")
   104|         if crypt != "clear":
   105|             auth = salt.crypt.AsyncAuth(opts, io_loop=io_loop)
   106|         else:
   107|             auth = None
   108|         transport = salt.transport.request_client(opts, io_loop=io_loop)
   109|         return cls(opts, transport, auth, tries=tries, timeout=timeout)
   110|     def __init__(
   111|         self,
   112|         opts,
   113|         transport,
   114|         auth,
   115|         timeout=REQUEST_CHANNEL_TIMEOUT,
   116|         tries=REQUEST_CHANNEL_TRIES,
   117|         **kwargs,
   118|     ):
   119|         self.opts = dict(opts)
   120|         self.transport = transport
   121|         self.auth = auth
   122|         self.master_pubkey_path = None
   123|         if self.auth:
   124|             self.master_pubkey_path = os.path.join(self.opts["pki_dir"], self.auth.mpub)
   125|         self._closing = False
   126|         self.timeout = timeout
   127|         self.tries = tries
   128|     @property
   129|     def crypt(self):
   130|         if self.auth:
   131|             return "aes"
   132|         return "clear"
   133|     @property
   134|     def ttype(self):
   135|         return self.transport.ttype
   136|     def _package_load(self, load):
   137|         return {
   138|             "enc": self.crypt,
   139|             "load": load,
   140|             "version": 2,
   141|         }
   142|     @tornado.gen.coroutine
   143|     def _send_with_retry(self, load, tries, timeout):
   144|         _try = 1
   145|         while True:
   146|             try:
   147|                 ret = yield self.transport.send(
   148|                     load,
   149|                     timeout=timeout,
   150|                 )
   151|                 break
   152|             except Exception as exc:  # pylint: disable=broad-except
   153|                 log.trace("Failed to send msg %r", exc)
   154|                 if _try >= tries:
   155|                     raise
   156|                 else:
   157|                     _try += 1
   158|                     continue
   159|         raise tornado.gen.Return(ret)
   160|     @tornado.gen.coroutine
   161|     def crypted_transfer_decode_dictentry(
   162|         self,
   163|         load,
   164|         dictkey=None,
   165|         timeout=None,
   166|         tries=None,
   167|     ):
   168|         if timeout is None:
   169|             timeout = self.timeout
   170|         if tries is None:
   171|             tries = self.tries
   172|         nonce = uuid.uuid4().hex
   173|         load["nonce"] = nonce
   174|         if not self.auth.authenticated:
   175|             yield self.auth.authenticate()
   176|         ret = yield self._send_with_retry(
   177|             self._package_load(self.auth.crypticle.dumps(load)),
   178|             tries,
   179|             timeout,
   180|         )
   181|         key = self.auth.get_keys()
   182|         if "key" not in ret:
   183|             yield self.auth.authenticate()
   184|             ret = yield self._send_with_retry(
   185|                 self._package_load(self.auth.crypticle.dumps(load)),
   186|                 tries,
   187|                 timeout,
   188|             )
   189|         if HAS_M2:
   190|             aes = key.private_decrypt(ret["key"], RSA.pkcs1_oaep_padding)
   191|         else:
   192|             cipher = PKCS1_OAEP.new(key)
   193|             aes = cipher.decrypt(ret["key"])
   194|         pcrypt = salt.crypt.Crypticle(self.opts, aes)
   195|         signed_msg = pcrypt.loads(ret[dictkey])
   196|         if not self.verify_signature(signed_msg["data"], signed_msg["sig"]):
   197|             raise salt.crypt.AuthenticationError(
   198|                 "Pillar payload signature failed to validate."
   199|             )
   200|         data = salt.payload.loads(signed_msg["data"])
   201|         if data["key"] != ret["key"]:
   202|             raise salt.crypt.AuthenticationError("Key verification failed.")
   203|         if data["nonce"] != nonce:
   204|             raise salt.crypt.AuthenticationError("Pillar nonce verification failed.")
   205|         raise tornado.gen.Return(data["pillar"])
   206|     def verify_signature(self, data, sig):
   207|         return salt.crypt.verify_signature(self.master_pubkey_path, data, sig)
   208|     @tornado.gen.coroutine
   209|     def _crypted_transfer(self, load, timeout, raw=False):
   210|         """
   211|         Send a load across the wire, with encryption
   212|         In case of authentication errors, try to renegotiate authentication
   213|         and retry the method.
   214|         Indeed, we can fail too early in case of a master restart during a
   215|         minion state execution call
   216|         :param dict load: A load to send across the wire
   217|         :param int timeout: The number of seconds on a response before failing
   218|         """
   219|         nonce = uuid.uuid4().hex
   220|         if load and isinstance(load, dict):
   221|             load["nonce"] = nonce
   222|         @tornado.gen.coroutine
   223|         def _do_transfer():
   224|             data = yield self.transport.send(
   225|                 self._package_load(self.auth.crypticle.dumps(load)),
   226|                 timeout=timeout,
   227|             )
   228|             if data:
   229|                 data = self.auth.crypticle.loads(data, raw, nonce=nonce)
   230|             if not raw or self.ttype == "tcp":  # XXX Why is this needed for tcp
   231|                 data = salt.transport.frame.decode_embedded_strs(data)
   232|             raise tornado.gen.Return(data)
   233|         if not self.auth.authenticated:
   234|             yield self.auth.authenticate()
   235|         try:
   236|             ret = yield _do_transfer()
   237|         except salt.crypt.AuthenticationError:
   238|             yield self.auth.authenticate()
   239|             ret = yield _do_transfer()
   240|         raise tornado.gen.Return(ret)
   241|     @tornado.gen.coroutine
   242|     def _uncrypted_transfer(self, load, timeout):
   243|         """
   244|         Send a load across the wire in cleartext
   245|         :param dict load: A load to send across the wire
   246|         :param int timeout: The number of seconds on a response before failing
   247|         """
   248|         ret = yield self.transport.send(
   249|             self._package_load(load),
   250|             timeout=timeout,
   251|         )
   252|         raise tornado.gen.Return(ret)
   253|     async def connect(self):
   254|         await self.transport.connect()
   255|     @tornado.gen.coroutine
   256|     def send(self, load, tries=None, timeout=None, raw=False):
   257|         """
   258|         Send a request, return a future which will complete when we send the message
   259|         :param dict load: A load to send across the wire
   260|         :param int tries: The number of times to make before failure
   261|         :param int timeout: The number of seconds on a response before failing
   262|         """
   263|         if timeout is None:
   264|             timeout = self.timeout
   265|         if tries is None:
   266|             tries = self.tries
   267|         _try = 1
   268|         while True:
   269|             try:
   270|                 if self.crypt == "clear":
   271|                     log.trace("ReqChannel send clear load=%r", load)
   272|                     ret = yield self._uncrypted_transfer(load, timeout=timeout)
   273|                 else:
   274|                     log.trace("ReqChannel send crypt load=%r", load)
   275|                     ret = yield self._crypted_transfer(load, timeout=timeout, raw=raw)
   276|                 break
   277|             except Exception as exc:  # pylint: disable=broad-except
   278|                 log.trace("Failed to send msg %r", exc)
   279|                 if _try >= tries:
   280|                     raise
   281|                 else:
   282|                     _try += 1
   283|                     continue
   284|         raise tornado.gen.Return(ret)
   285|     def close(self):
   286|         """
   287|         Since the message_client creates sockets and assigns them to the IOLoop we have to
   288|         specifically destroy them, since we aren't the only ones with references to the FDs
   289|         """
   290|         if self._closing:
   291|             return
   292|         log.debug("Closing %s instance", self.__class__.__name__)
   293|         self._closing = True
   294|         self.transport.close()
   295|     def __enter__(self):
   296|         return self
   297|     def __exit__(self, *args):
   298|         self.close()
   299|     async def __aenter__(self):
   300|         await self.transport.connect()
   301|         return self
   302|     async def __aexit__(self, *_):
   303|         self.close()
   304| class AsyncPubChannel:
   305|     """
   306|     Factory class to create subscription channels to the master's Publisher
   307|     """
   308|     async_methods = [
   309|         "connect",
   310|         "_decode_messages",
   311|     ]
   312|     close_methods = [
   313|         "close",
   314|     ]
   315|     @classmethod
   316|     def factory(cls, opts, **kwargs):
   317|         ttype = "zeromq"
   318|         if "transport" in opts:
   319|             ttype = opts["transport"]
   320|         elif "transport" in opts.get("pillar", {}).get("master", {}):
   321|             ttype = opts["pillar"]["master"]["transport"]
   322|         if "master_uri" not in opts and "master_uri" in kwargs:
   323|             opts["master_uri"] = kwargs["master_uri"]
   324|         if ttype == "detect":
   325|             opts["detect_mode"] = True
   326|             log.info("Transport is set to detect; using %s", ttype)
   327|         io_loop = kwargs.get("io_loop")
   328|         if io_loop is None:
   329|             io_loop = tornado.ioloop.IOLoop.current()
   330|         auth = salt.crypt.AsyncAuth(opts, io_loop=io_loop)
   331|         host = opts.get("master_ip", "127.0.0.1")
   332|         port = int(opts.get("publish_port", 4506))
   333|         transport = salt.transport.publish_client(opts, io_loop, host=host, port=port)
   334|         return cls(opts, transport, auth, io_loop)
   335|     def __init__(self, opts, transport, auth, io_loop=None):
   336|         self.opts = opts
   337|         self.io_loop = io_loop
   338|         self.auth = auth
   339|         self.token = self.auth.gen_token(b"salt")
   340|         self.transport = transport
   341|         self._closing = False
   342|         self._reconnected = False
   343|         self.event = salt.utils.event.get_event("minion", opts=self.opts, listen=False)
   344|         self.master_pubkey_path = os.path.join(self.opts["pki_dir"], self.auth.mpub)
   345|     @property
   346|     def crypt(self):
   347|         return "aes" if self.auth else "clear"
   348|     @tornado.gen.coroutine
   349|     def connect(self):
   350|         """
   351|         Return a future which completes when connected to the remote publisher
   352|         """
   353|         try:
   354|             if not self.auth.authenticated:
   355|                 yield self.auth.authenticate()
   356|             if int(self.opts.get("publish_port", 4506)) != 4506:
   357|                 publish_port = self.opts.get("publish_port")
   358|             else:
   359|                 publish_port = self.auth.creds["publish_port"]
   360|             yield self.transport.connect(
   361|                 publish_port, self.connect_callback, self.disconnect_callback
   362|             )
   363|         except KeyboardInterrupt:  # pylint: disable=try-except-raise
   364|             raise
   365|         except Exception as exc:  # pylint: disable=broad-except
   366|             if "-|RETRY|-" not in str(exc):
   367|                 raise salt.exceptions.SaltClientError(
   368|                     f"Unable to sign_in to master: {exc}"
   369|                 )  # TODO: better error message
   370|     def close(self):
   371|         """
   372|         Close the channel
   373|         """
   374|         self.transport.close()
   375|         if self.event is not None:
   376|             self.event.destroy()
   377|             self.event = None
   378|     def on_recv(self, callback=None):
   379|         """
   380|         When jobs are received pass them (decoded) to callback
   381|         """
   382|         if callback is None:
   383|             return self.transport.on_recv(None)
   384|         async def wrap_callback(messages):
   385|             payload = self.transport._decode_messages(messages)
   386|             decoded = await self._decode_payload(payload)
   387|             log.debug("PubChannel received: %r %r", decoded, callback)
   388|             if decoded is not None and callback is not None:
   389|                 await callback(decoded)
   390|         return self.transport.on_recv(wrap_callback)
   391|     def _package_load(self, load):
   392|         return {
   393|             "enc": self.crypt,
   394|             "load": load,
   395|             "version": 2,
   396|         }
   397|     @tornado.gen.coroutine
   398|     def send_id(self, tok, force_auth):
   399|         """
   400|         Send the minion id to the master so that the master may better
   401|         track the connection state of the minion.
   402|         In case of authentication errors, try to renegotiate authentication
   403|         and retry the method.
   404|         """
   405|         load = {"id": self.opts["id"], "tok": tok}
   406|         @tornado.gen.coroutine
   407|         def _do_transfer():
   408|             msg = self._package_load(self.auth.crypticle.dumps(load))
   409|             package = salt.transport.frame.frame_msg(msg, header=None)
   410|             yield self.transport.send(package)
   411|             raise tornado.gen.Return(True)
   412|         if force_auth or not self.auth.authenticated:
   413|             count = 0
   414|             while (
   415|                 count <= self.opts["tcp_authentication_retries"]
   416|                 or self.opts["tcp_authentication_retries"] < 0
   417|             ):
   418|                 try:
   419|                     yield self.auth.authenticate()
   420|                     break
   421|                 except salt.exceptions.SaltClientError as exc:
   422|                     log.debug(exc)
   423|                     count += 1
   424|         try:
   425|             ret = yield _do_transfer()
   426|             raise tornado.gen.Return(ret)
   427|         except salt.crypt.AuthenticationError:
   428|             yield self.auth.authenticate()
   429|             ret = yield _do_transfer()
   430|             raise tornado.gen.Return(ret)
   431|     @tornado.gen.coroutine
   432|     def connect_callback(self, result):
   433|         if self._closing:
   434|             return
   435|         try:
   436|             yield self.send_id(self.token, self._reconnected)
   437|             self.connected = True
   438|             self.event.fire_event({"master": self.opts["master"]}, "__master_connected")
   439|             if self._reconnected:
   440|                 if self.opts.get("__role") == "syndic":
   441|                     data = "Syndic {} started at {}".format(
   442|                         self.opts["id"], time.asctime()
   443|                     )
   444|                     tag = salt.utils.event.tagify([self.opts["id"], "start"], "syndic")
   445|                 else:
   446|                     data = "Minion {} started at {}".format(
   447|                         self.opts["id"], time.asctime()
   448|                     )
   449|                     tag = salt.utils.event.tagify([self.opts["id"], "start"], "minion")
   450|                 load = {
   451|                     "id": self.opts["id"],

# --- HUNK 3: Lines 466-548 ---
   466|                     except Exception:  # pylint: disable=broad-except
   467|                         log.info("fire_master failed", exc_info=True)
   468|             else:
   469|                 self._reconnected = True
   470|         except Exception as exc:  # pylint: disable=broad-except
   471|             log.error(
   472|                 "Caught exception in PubChannel connect callback %r", exc, exc_info=True
   473|             )
   474|     def disconnect_callback(self):
   475|         if self._closing:
   476|             return
   477|         self.connected = False
   478|         self.event.fire_event({"master": self.opts["master"]}, "__master_disconnected")
   479|     def _verify_master_signature(self, payload):
   480|         if self.opts.get("sign_pub_messages"):
   481|             if not payload.get("sig", False):
   482|                 raise salt.crypt.AuthenticationError(
   483|                     "Message signing is enabled but the payload has no signature."
   484|                 )
   485|             if not salt.crypt.verify_signature(
   486|                 self.master_pubkey_path, payload["load"], payload.get("sig")
   487|             ):
   488|                 raise salt.crypt.AuthenticationError(
   489|                     "Message signature failed to validate."
   490|                 )
   491|     @tornado.gen.coroutine
   492|     def _decode_payload(self, payload):
   493|         log.trace("Decoding payload: %s", payload)
   494|         reauth = False
   495|         if payload["enc"] == "aes":
   496|             self._verify_master_signature(payload)
   497|             try:
   498|                 payload["load"] = self.auth.crypticle.loads(payload["load"])
   499|             except salt.crypt.AuthenticationError:
   500|                 reauth = True
   501|             if reauth:
   502|                 try:
   503|                     yield self.auth.authenticate()
   504|                     payload["load"] = self.auth.crypticle.loads(payload["load"])
   505|                 except salt.crypt.AuthenticationError:
   506|                     log.error(
   507|                         "Payload decryption failed even after re-authenticating with master %s",
   508|                         self.opts["master_ip"],
   509|                     )
   510|         raise tornado.gen.Return(payload)
   511|     def __enter__(self):
   512|         return self
   513|     def __exit__(self, *args):
   514|         self.io_loop.spawn_callback(self.close)
   515|     async def __aenter__(self):
   516|         return self
   517|     async def __aexit__(self, *_):
   518|         await self.close()
   519| class AsyncPushChannel:
   520|     """
   521|     Factory class to create IPC Push channels
   522|     """
   523|     @staticmethod
   524|     def factory(opts, **kwargs):
   525|         """
   526|         If we have additional IPC transports other than UxD and TCP, add them here
   527|         """
   528|         salt.utils.versions.warn_until(
   529|             3009,
   530|             "AsyncPushChannel is deprecated. Use zeromq or tcp transport instead.",
   531|         )
   532|         import salt.transport.ipc
   533|         return salt.transport.ipc.IPCMessageClient(opts, **kwargs)
   534| class AsyncPullChannel:
   535|     """
   536|     Factory class to create IPC pull channels
   537|     """
   538|     @staticmethod
   539|     def factory(opts, **kwargs):
   540|         """
   541|         If we have additional IPC transports other than UXD and TCP, add them here
   542|         """
   543|         salt.utils.versions.warn_until(
   544|             3009,
   545|             "AsyncPullChannel is deprecated. Use zeromq or tcp transport instead.",
   546|         )
   547|         import salt.transport.ipc
   548|         return salt.transport.ipc.IPCMessageServer(opts, **kwargs)


# ====================================================================
# FILE: salt/channel/server.py
# Total hunks: 13
# ====================================================================
# --- HUNK 1: Lines 1-700 ---
     1| """
     2| Encapsulate the different transports available to Salt.
     3| This includes server side transport, for the ReqServer and the Publisher
     4| """
     5| import asyncio
     6| import binascii
     7| import collections
     8| import hashlib
     9| import logging
    10| import os
    11| import pathlib
    12| import shutil
    13| import tornado.gen
    14| import salt.crypt
    15| import salt.master
    16| import salt.payload
    17| import salt.transport.frame
    18| import salt.utils.channel
    19| import salt.utils.event
    20| import salt.utils.files
    21| import salt.utils.minions
    22| import salt.utils.platform
    23| import salt.utils.stringutils
    24| import salt.utils.verify
    25| from salt.exceptions import SaltDeserializationError
    26| from salt.utils.cache import CacheCli
    27| try:
    28|     from M2Crypto import RSA
    29|     HAS_M2 = True
    30| except ImportError:
    31|     HAS_M2 = False
    32|     try:
    33|         from Cryptodome.Cipher import PKCS1_OAEP
    34|     except ImportError:
    35|         from Crypto.Cipher import PKCS1_OAEP  # nosec
    36| log = logging.getLogger(__name__)
    37| class ReqServerChannel:
    38|     """
    39|     ReqServerChannel handles request/reply messages from ReqChannels.
    40|     """
    41|     @classmethod
    42|     def factory(cls, opts, **kwargs):
    43|         if "master_uri" not in opts and "master_uri" in kwargs:
    44|             opts["master_uri"] = kwargs["master_uri"]
    45|         transport = salt.transport.request_server(opts, **kwargs)
    46|         return cls(opts, transport)
    47|     @classmethod
    48|     def compare_keys(cls, key1, key2):
    49|         """
    50|         Normalize and compare two keys
    51|         Returns:
    52|             bool: ``True`` if the keys match, otherwise ``False``
    53|         """
    54|         return salt.crypt.clean_key(key1) == salt.crypt.clean_key(key2)
    55|     def __init__(self, opts, transport):
    56|         self.opts = opts
    57|         self.transport = transport
    58|         self.event = salt.utils.event.get_master_event(
    59|             self.opts, self.opts["sock_dir"], listen=False
    60|         )
    61|         self.master_key = salt.crypt.MasterKeys(self.opts)
    62|     @property
    63|     def aes_key(self):
    64|         if self.opts.get("cluster_id", None):
    65|             return salt.master.SMaster.secrets["cluster_aes"]["secret"].value
    66|         return salt.master.SMaster.secrets["aes"]["secret"].value
    67|     def pre_fork(self, process_manager):
    68|         """
    69|         Do anything necessary pre-fork. Since this is on the master side this will
    70|         primarily be bind and listen (or the equivalent for your network library)
    71|         """
    72|         if hasattr(self.transport, "pre_fork"):
    73|             self.transport.pre_fork(process_manager)
    74|     def post_fork(self, payload_handler, io_loop):
    75|         """
    76|         Do anything you need post-fork. This should handle all incoming payloads
    77|         and call payload_handler. You will also be passed io_loop, for all of your
    78|         asynchronous needs
    79|         """
    80|         import salt.master
    81|         if self.opts["pub_server_niceness"] and not salt.utils.platform.is_windows():
    82|             log.info(
    83|                 "setting Publish daemon niceness to %i",
    84|                 self.opts["pub_server_niceness"],
    85|             )
    86|             os.nice(self.opts["pub_server_niceness"])
    87|         self.io_loop = io_loop
    88|         self.crypticle = salt.crypt.Crypticle(self.opts, self.aes_key)
    89|         self.event = salt.utils.event.get_master_event(
    90|             self.opts, self.opts["sock_dir"], listen=False
    91|         )
    92|         self.auto_key = salt.daemons.masterapi.AutoKey(self.opts)
    93|         if self.opts["con_cache"]:
    94|             self.cache_cli = CacheCli(self.opts)
    95|         else:
    96|             self.cache_cli = False
    97|             self.ckminions = salt.utils.minions.CkMinions(self.opts)
    98|         self.master_key = salt.crypt.MasterKeys(self.opts)
    99|         self.payload_handler = payload_handler
   100|         if hasattr(self.transport, "post_fork"):
   101|             self.transport.post_fork(self.handle_message, io_loop)
   102|     @tornado.gen.coroutine
   103|     def handle_message(self, payload):
   104|         try:
   105|             payload = self._decode_payload(payload)
   106|         except Exception as exc:  # pylint: disable=broad-except
   107|             exc_type = type(exc).__name__
   108|             if exc_type == "AuthenticationError":
   109|                 log.debug(
   110|                     "Minion failed to auth to master. Since the payload is "
   111|                     "encrypted, it is not known which minion failed to "
   112|                     "authenticate. It is likely that this is a transient "
   113|                     "failure due to the master rotating its public key."
   114|                 )
   115|             else:
   116|                 log.error("Bad load from minion: %s: %s", exc_type, exc)
   117|             raise tornado.gen.Return("bad load")
   118|         if not isinstance(payload, dict) or not isinstance(payload.get("load"), dict):
   119|             log.error(
   120|                 "payload and load must be a dict. Payload was: %s and load was %s",
   121|                 payload,
   122|                 payload.get("load"),
   123|             )
   124|             raise tornado.gen.Return("payload and load must be a dict")
   125|         try:
   126|             id_ = payload["load"].get("id", "")
   127|             if "\0" in id_:
   128|                 log.error("Payload contains an id with a null byte: %s", payload)
   129|                 raise tornado.gen.Return("bad load: id contains a null byte")
   130|         except TypeError:
   131|             log.error("Payload contains non-string id: %s", payload)
   132|             raise tornado.gen.Return(f"bad load: id {id_} is not a string")
   133|         version = 0
   134|         if "version" in payload:
   135|             version = payload["version"]
   136|         sign_messages = False
   137|         if version > 1:
   138|             sign_messages = True
   139|         if payload["enc"] == "clear" and payload.get("load", {}).get("cmd") == "_auth":
   140|             raise tornado.gen.Return(self._auth(payload["load"], sign_messages))
   141|         nonce = None
   142|         if version > 1:
   143|             nonce = payload["load"].pop("nonce", None)
   144|         try:
   145|             ret, req_opts = yield self.payload_handler(payload)
   146|         except Exception as e:  # pylint: disable=broad-except
   147|             log.error("Some exception handling a payload from minion", exc_info=True)
   148|             raise tornado.gen.Return("Some exception handling minion payload")
   149|         req_fun = req_opts.get("fun", "send")
   150|         if req_fun == "send_clear":
   151|             raise tornado.gen.Return(ret)
   152|         elif req_fun == "send":
   153|             raise tornado.gen.Return(self.crypticle.dumps(ret, nonce))
   154|         elif req_fun == "send_private":
   155|             raise tornado.gen.Return(
   156|                 self._encrypt_private(
   157|                     ret,
   158|                     req_opts["key"],
   159|                     req_opts["tgt"],
   160|                     nonce,
   161|                     sign_messages,
   162|                 ),
   163|             )
   164|         log.error("Unknown req_fun %s", req_fun)
   165|         raise tornado.gen.Return("Server-side exception handling payload")
   166|     def _encrypt_private(self, ret, dictkey, target, nonce=None, sign_messages=True):
   167|         """
   168|         The server equivalent of ReqChannel.crypted_transfer_decode_dictentry
   169|         """
   170|         if self.master_key.cluster_key:
   171|             pubfn = os.path.join(self.opts["cluster_pki_dir"], "minions", target)
   172|         else:
   173|             pubfn = os.path.join(self.opts["pki_dir"], "minions", target)
   174|         key = salt.crypt.Crypticle.generate_key_string()
   175|         pcrypt = salt.crypt.Crypticle(self.opts, key)
   176|         try:
   177|             pub = salt.crypt.PublicKey(pubfn)
   178|         except (ValueError, IndexError, TypeError):
   179|             return self.crypticle.dumps({})
   180|         except OSError:
   181|             log.error("AES key not found")
   182|             return {"error": "AES key not found"}
   183|         pret = {}
   184|         pret["key"] = pub.encrypt(key)
   185|         if ret is False:
   186|             ret = {}
   187|         if sign_messages:
   188|             if nonce is None:
   189|                 return {"error": "Nonce not included in request"}
   190|             tosign = salt.payload.dumps(
   191|                 {"key": pret["key"], "pillar": ret, "nonce": nonce}
   192|             )
   193|             signed_msg = {
   194|                 "data": tosign,
   195|                 "sig": salt.crypt.PrivateKey(self.master_key.rsa_path).sign(tosign),
   196|             }
   197|             pret[dictkey] = pcrypt.dumps(signed_msg)
   198|         else:
   199|             pret[dictkey] = pcrypt.dumps(ret)
   200|         return pret
   201|     def _clear_signed(self, load):
   202|         tosign = salt.payload.dumps(load)
   203|         return {
   204|             "enc": "clear",
   205|             "load": tosign,
   206|             "sig": salt.crypt.sign_message(self.master_key.rsa_path, tosign),
   207|         }
   208|     def _update_aes(self):
   209|         """
   210|         Check to see if a fresh AES key is available and update the components
   211|         of the worker
   212|         """
   213|         import salt.master
   214|         key = "aes"
   215|         if self.opts.get("cluster_id", None):
   216|             key = "cluster_aes"
   217|         if (
   218|             salt.master.SMaster.secrets[key]["secret"].value
   219|             != self.crypticle.key_string
   220|         ):
   221|             self.crypticle = salt.crypt.Crypticle(
   222|                 self.opts, salt.master.SMaster.secrets[key]["secret"].value
   223|             )
   224|             return True
   225|         return False
   226|     def _decode_payload(self, payload):
   227|         if (
   228|             not isinstance(payload, dict)
   229|             or "enc" not in payload
   230|             or "load" not in payload
   231|         ):
   232|             raise SaltDeserializationError("bad load received on socket!")
   233|         if payload["enc"] == "aes":
   234|             try:
   235|                 payload["load"] = self.crypticle.loads(payload["load"])
   236|             except salt.crypt.AuthenticationError:
   237|                 if not self._update_aes():
   238|                     raise
   239|                 payload["load"] = self.crypticle.loads(payload["load"])
   240|         return payload
   241|     def _auth(self, load, sign_messages=False):
   242|         """
   243|         Authenticate the client, use the sent public key to encrypt the AES key
   244|         which was generated at start up.
   245|         This method fires an event over the master event manager. The event is
   246|         tagged "auth" and returns a dict with information about the auth
   247|         event
   248|             - Verify that the key we are receiving matches the stored key
   249|             - Store the key if it is not there
   250|             - Make an RSA key with the pub key
   251|             - Encrypt the AES key as an encrypted salt.payload
   252|             - Package the return and return it
   253|         """
   254|         import salt.master
   255|         if not salt.utils.verify.valid_id(self.opts, load["id"]):
   256|             log.info("Authentication request from invalid id %s", load["id"])
   257|             if sign_messages:
   258|                 return self._clear_signed({"ret": False, "nonce": load["nonce"]})
   259|             else:
   260|                 return {"enc": "clear", "load": {"ret": False}}
   261|         log.info("Authentication request from %s", load["id"])
   262|         if self.opts["max_minions"] > 0:
   263|             if self.cache_cli:
   264|                 minions = self.cache_cli.get_cached()
   265|             else:
   266|                 minions = self.ckminions.connected_ids()
   267|                 if len(minions) > 1000:
   268|                     log.info(
   269|                         "With large numbers of minions it is advised "
   270|                         "to enable the ConCache with 'con_cache: True' "
   271|                         "in the masters configuration file."
   272|                     )
   273|             if not len(minions) <= self.opts["max_minions"]:
   274|                 if load["id"] not in minions:
   275|                     log.info(
   276|                         "Too many minions connected (max_minions=%s). "
   277|                         "Rejecting connection from id %s",
   278|                         self.opts["max_minions"],
   279|                         load["id"],
   280|                     )
   281|                     eload = {
   282|                         "result": False,
   283|                         "act": "full",
   284|                         "id": load["id"],
   285|                         "pub": load["pub"],
   286|                     }
   287|                     if self.opts.get("auth_events") is True:
   288|                         self.event.fire_event(
   289|                             eload, salt.utils.event.tagify(prefix="auth")
   290|                         )
   291|                     if sign_messages:
   292|                         return self._clear_signed(
   293|                             {"ret": "full", "nonce": load["nonce"]}
   294|                         )
   295|                     else:
   296|                         return {"enc": "clear", "load": {"ret": "full"}}
   297|         pki_dir = self.opts["pki_dir"]
   298|         if self.opts["cluster_id"]:
   299|             if self.opts["cluster_pki_dir"]:
   300|                 pki_dir = self.opts["cluster_pki_dir"]
   301|         auto_reject = self.auto_key.check_autoreject(load["id"])
   302|         auto_sign = self.auto_key.check_autosign(
   303|             load["id"], load.get("autosign_grains", None)
   304|         )
   305|         pubfn = os.path.join(pki_dir, "minions", load["id"])
   306|         pubfn_pend = os.path.join(pki_dir, "minions_pre", load["id"])
   307|         pubfn_rejected = os.path.join(pki_dir, "minions_rejected", load["id"])
   308|         pubfn_denied = os.path.join(pki_dir, "minions_denied", load["id"])
   309|         if self.opts["open_mode"]:
   310|             pass
   311|         elif os.path.isfile(pubfn_rejected):
   312|             log.info(
   313|                 "Public key rejected for %s. Key is present in rejection key dir.",
   314|                 load["id"],
   315|             )
   316|             eload = {"result": False, "id": load["id"], "pub": load["pub"]}
   317|             if self.opts.get("auth_events") is True:
   318|                 self.event.fire_event(eload, salt.utils.event.tagify(prefix="auth"))
   319|             if sign_messages:
   320|                 return self._clear_signed({"ret": False, "nonce": load["nonce"]})
   321|             else:
   322|                 return {"enc": "clear", "load": {"ret": False}}
   323|         elif os.path.isfile(pubfn):
   324|             with salt.utils.files.fopen(pubfn, "r") as pubfn_handle:
   325|                 if not self.compare_keys(pubfn_handle.read(), load["pub"]):
   326|                     log.error(
   327|                         "Authentication attempt from %s failed, the public "
   328|                         "keys did not match. This may be an attempt to compromise "
   329|                         "the Salt cluster.",
   330|                         load["id"],
   331|                     )
   332|                     with salt.utils.files.fopen(pubfn_denied, "w+") as fp_:
   333|                         fp_.write(load["pub"])
   334|                     eload = {
   335|                         "result": False,
   336|                         "id": load["id"],
   337|                         "act": "denied",
   338|                         "pub": load["pub"],
   339|                     }
   340|                     if self.opts.get("auth_events") is True:
   341|                         self.event.fire_event(
   342|                             eload, salt.utils.event.tagify(prefix="auth")
   343|                         )
   344|                     if sign_messages:
   345|                         return self._clear_signed(
   346|                             {"ret": False, "nonce": load["nonce"]}
   347|                         )
   348|                     else:
   349|                         return {"enc": "clear", "load": {"ret": False}}
   350|         elif not os.path.isfile(pubfn_pend):
   351|             if os.path.isdir(pubfn_pend):
   352|                 log.info("New public key %s is a directory", load["id"])
   353|                 eload = {"result": False, "id": load["id"], "pub": load["pub"]}
   354|                 if self.opts.get("auth_events") is True:
   355|                     self.event.fire_event(eload, salt.utils.event.tagify(prefix="auth"))
   356|                 if sign_messages:
   357|                     return self._clear_signed({"ret": False, "nonce": load["nonce"]})
   358|                 else:
   359|                     return {"enc": "clear", "load": {"ret": False}}
   360|             if auto_reject:
   361|                 key_path = pubfn_rejected
   362|                 log.info(
   363|                     "New public key for %s rejected via autoreject_file", load["id"]
   364|                 )
   365|                 key_act = "reject"
   366|                 key_result = False
   367|             elif not auto_sign:
   368|                 key_path = pubfn_pend
   369|                 log.info("New public key for %s placed in pending", load["id"])
   370|                 key_act = "pend"
   371|                 key_result = True
   372|             else:
   373|                 key_path = None
   374|             if key_path is not None:
   375|                 with salt.utils.files.fopen(key_path, "w+") as fp_:
   376|                     fp_.write(load["pub"])
   377|                 eload = {
   378|                     "result": key_result,
   379|                     "act": key_act,
   380|                     "id": load["id"],
   381|                     "pub": load["pub"],
   382|                 }
   383|                 if self.opts.get("auth_events") is True:
   384|                     self.event.fire_event(eload, salt.utils.event.tagify(prefix="auth"))
   385|                 if sign_messages:
   386|                     return self._clear_signed(
   387|                         {"ret": key_result, "nonce": load["nonce"]}
   388|                     )
   389|                 else:
   390|                     return {"enc": "clear", "load": {"ret": key_result}}
   391|         elif os.path.isfile(pubfn_pend):
   392|             if auto_reject:
   393|                 try:
   394|                     shutil.move(pubfn_pend, pubfn_rejected)
   395|                 except OSError:
   396|                     pass
   397|                 log.info(
   398|                     "Pending public key for %s rejected via autoreject_file",
   399|                     load["id"],
   400|                 )
   401|                 eload = {
   402|                     "result": False,
   403|                     "act": "reject",
   404|                     "id": load["id"],
   405|                     "pub": load["pub"],
   406|                 }
   407|                 if self.opts.get("auth_events") is True:
   408|                     self.event.fire_event(eload, salt.utils.event.tagify(prefix="auth"))
   409|                 if sign_messages:
   410|                     return self._clear_signed({"ret": False, "nonce": load["nonce"]})
   411|                 else:
   412|                     return {"enc": "clear", "load": {"ret": False}}
   413|             elif not auto_sign:
   414|                 with salt.utils.files.fopen(pubfn_pend, "r") as pubfn_handle:
   415|                     if not self.compare_keys(pubfn_handle.read(), load["pub"]):
   416|                         log.error(
   417|                             "Authentication attempt from %s failed, the public "
   418|                             "key in pending did not match. This may be an "
   419|                             "attempt to compromise the Salt cluster.",
   420|                             load["id"],
   421|                         )
   422|                         with salt.utils.files.fopen(pubfn_denied, "w+") as fp_:
   423|                             fp_.write(load["pub"])
   424|                         eload = {
   425|                             "result": False,
   426|                             "id": load["id"],
   427|                             "act": "denied",
   428|                             "pub": load["pub"],
   429|                         }
   430|                         if self.opts.get("auth_events") is True:
   431|                             self.event.fire_event(
   432|                                 eload, salt.utils.event.tagify(prefix="auth")
   433|                             )
   434|                         if sign_messages:
   435|                             return self._clear_signed(
   436|                                 {"ret": False, "nonce": load["nonce"]}
   437|                             )
   438|                         else:
   439|                             return {"enc": "clear", "load": {"ret": False}}
   440|                     else:
   441|                         log.info(
   442|                             "Authentication failed from host %s, the key is in "
   443|                             "pending and needs to be accepted with salt-key "
   444|                             "-a %s",
   445|                             load["id"],
   446|                             load["id"],
   447|                         )
   448|                         eload = {
   449|                             "result": True,
   450|                             "act": "pend",
   451|                             "id": load["id"],
   452|                             "pub": load["pub"],
   453|                         }
   454|                         if self.opts.get("auth_events") is True:
   455|                             self.event.fire_event(
   456|                                 eload, salt.utils.event.tagify(prefix="auth")
   457|                             )
   458|                         if sign_messages:
   459|                             return self._clear_signed(
   460|                                 {"ret": True, "nonce": load["nonce"]}
   461|                             )
   462|                         else:
   463|                             return {"enc": "clear", "load": {"ret": True}}
   464|             else:
   465|                 with salt.utils.files.fopen(pubfn_pend, "r") as pubfn_handle:
   466|                     if not self.compare_keys(pubfn_handle.read(), load["pub"]):
   467|                         log.error(
   468|                             "Authentication attempt from %s failed, the public "
   469|                             "keys in pending did not match. This may be an "
   470|                             "attempt to compromise the Salt cluster.",
   471|                             load["id"],
   472|                         )
   473|                         with salt.utils.files.fopen(pubfn_denied, "w+") as fp_:
   474|                             fp_.write(load["pub"])
   475|                         eload = {"result": False, "id": load["id"], "pub": load["pub"]}
   476|                         if self.opts.get("auth_events") is True:
   477|                             self.event.fire_event(
   478|                                 eload, salt.utils.event.tagify(prefix="auth")
   479|                             )
   480|                         if sign_messages:
   481|                             return self._clear_signed(
   482|                                 {"ret": False, "nonce": load["nonce"]}
   483|                             )
   484|                         else:
   485|                             return {"enc": "clear", "load": {"ret": False}}
   486|                     else:
   487|                         os.remove(pubfn_pend)
   488|         else:
   489|             log.warning("Unaccounted for authentication failure")
   490|             eload = {"result": False, "id": load["id"], "pub": load["pub"]}
   491|             if self.opts.get("auth_events") is True:
   492|                 self.event.fire_event(eload, salt.utils.event.tagify(prefix="auth"))
   493|             if sign_messages:
   494|                 return self._clear_signed({"ret": False, "nonce": load["nonce"]})
   495|             else:
   496|                 return {"enc": "clear", "load": {"ret": False}}
   497|         log.info("Authentication accepted from %s", load["id"])
   498|         if not os.path.isfile(pubfn) and not self.opts["open_mode"]:
   499|             with salt.utils.files.fopen(pubfn, "w+") as fp_:
   500|                 fp_.write(load["pub"])
   501|         elif self.opts["open_mode"]:
   502|             disk_key = ""
   503|             if os.path.isfile(pubfn):
   504|                 with salt.utils.files.fopen(pubfn, "r") as fp_:
   505|                     disk_key = fp_.read()
   506|             if load["pub"] and load["pub"] != disk_key:
   507|                 log.debug("Host key change detected in open mode.")
   508|                 with salt.utils.files.fopen(pubfn, "w+") as fp_:
   509|                     fp_.write(load["pub"])
   510|             elif not load["pub"]:
   511|                 log.error("Public key is empty: %s", load["id"])
   512|                 if sign_messages:
   513|                     return self._clear_signed({"ret": False, "nonce": load["nonce"]})
   514|                 else:
   515|                     return {"enc": "clear", "load": {"ret": False}}
   516|         pub = None
   517|         if self.cache_cli:
   518|             self.cache_cli.put_cache([load["id"]])
   519|         try:
   520|             pub = salt.crypt.get_rsa_pub_key(pubfn)
   521|         except salt.crypt.InvalidKeyError as err:
   522|             log.error('Corrupt public key "%s": %s', pubfn, err)
   523|             if sign_messages:
   524|                 return self._clear_signed({"ret": False, "nonce": load["nonce"]})
   525|             else:
   526|                 return {"enc": "clear", "load": {"ret": False}}
   527|         if not HAS_M2:
   528|             cipher = PKCS1_OAEP.new(pub)
   529|         ret = {
   530|             "enc": "pub",
   531|             "pub_key": self.master_key.get_pub_str(),
   532|             "publish_port": self.opts["publish_port"],
   533|         }
   534|         if self.opts["master_sign_pubkey"]:
   535|             if self.master_key.pubkey_signature():
   536|                 log.debug("Adding pubkey signature to auth-reply")
   537|                 log.debug(self.master_key.pubkey_signature())
   538|                 ret.update({"pub_sig": self.master_key.pubkey_signature()})
   539|             else:
   540|                 key_pass = salt.utils.sdb.sdb_get(
   541|                     self.opts["signing_key_pass"], self.opts
   542|                 )
   543|                 log.debug("Signing master public key before sending")
   544|                 pub_sign = salt.crypt.sign_message(
   545|                     self.master_key.get_sign_paths()[1], ret["pub_key"], key_pass
   546|                 )
   547|                 ret.update({"pub_sig": binascii.b2a_base64(pub_sign)})
   548|         if not HAS_M2:
   549|             mcipher = PKCS1_OAEP.new(self.master_key.key)
   550|         if self.opts["auth_mode"] >= 2:
   551|             if "token" in load:
   552|                 try:
   553|                     if HAS_M2:
   554|                         mtoken = self.master_key.key.private_decrypt(
   555|                             load["token"], RSA.pkcs1_oaep_padding
   556|                         )
   557|                     else:
   558|                         mtoken = mcipher.decrypt(load["token"])
   559|                     aes = f"{self.aes_key}_|-{mtoken}"
   560|                 except Exception:  # pylint: disable=broad-except
   561|                     pass
   562|             else:
   563|                 aes = self.aes_key
   564|             if HAS_M2:
   565|                 ret["aes"] = pub.public_encrypt(aes, RSA.pkcs1_oaep_padding)
   566|             else:
   567|                 ret["aes"] = cipher.encrypt(aes)
   568|         else:
   569|             if "token" in load:
   570|                 try:
   571|                     if HAS_M2:
   572|                         mtoken = self.master_key.key.private_decrypt(
   573|                             load["token"], RSA.pkcs1_oaep_padding
   574|                         )
   575|                         ret["token"] = pub.public_encrypt(
   576|                             mtoken, RSA.pkcs1_oaep_padding
   577|                         )
   578|                     else:
   579|                         mtoken = mcipher.decrypt(load["token"])
   580|                         ret["token"] = cipher.encrypt(mtoken)
   581|                 except Exception:  # pylint: disable=broad-except
   582|                     pass
   583|             aes = self.aes_key
   584|             if HAS_M2:
   585|                 ret["aes"] = pub.public_encrypt(aes, RSA.pkcs1_oaep_padding)
   586|             else:
   587|                 ret["aes"] = cipher.encrypt(aes)
   588|         digest = salt.utils.stringutils.to_bytes(hashlib.sha256(aes).hexdigest())
   589|         ret["sig"] = salt.crypt.private_encrypt(self.master_key.key, digest)
   590|         eload = {"result": True, "act": "accept", "id": load["id"], "pub": load["pub"]}
   591|         if self.opts.get("auth_events") is True:
   592|             self.event.fire_event(eload, salt.utils.event.tagify(prefix="auth"))
   593|         if sign_messages:
   594|             ret["nonce"] = load["nonce"]
   595|             return self._clear_signed(ret)
   596|         return ret
   597|     def close(self):
   598|         self.transport.close()
   599|         if self.event is not None:
   600|             self.event.destroy()
   601| class PubServerChannel:
   602|     """
   603|     Factory class to create subscription channels to the master's Publisher
   604|     """
   605|     @classmethod
   606|     def factory(cls, opts, **kwargs):
   607|         if "master_uri" not in opts and "master_uri" in kwargs:
   608|             opts["master_uri"] = kwargs["master_uri"]
   609|         presence_events = False
   610|         if opts.get("presence_events", False):
   611|             tcp_only = True
   612|             for transport, _ in salt.utils.channel.iter_transport_opts(opts):
   613|                 if transport != "tcp":
   614|                     tcp_only = False
   615|             if tcp_only:
   616|                 presence_events = True
   617|         transport = salt.transport.publish_server(opts, **kwargs)
   618|         return cls(opts, transport, presence_events=presence_events)
   619|     def __init__(self, opts, transport, presence_events=False):
   620|         self.opts = opts
   621|         self.ckminions = salt.utils.minions.CkMinions(self.opts)
   622|         self.transport = transport
   623|         self.aes_funcs = salt.master.AESFuncs(self.opts)
   624|         self.present = {}
   625|         self.presence_events = presence_events
   626|         self.event = salt.utils.event.get_event("master", opts=self.opts, listen=False)
   627|     @property
   628|     def aes_key(self):
   629|         if self.opts.get("cluster_id", None):
   630|             return salt.master.SMaster.secrets["cluster_aes"]["secret"].value
   631|         return salt.master.SMaster.secrets["aes"]["secret"].value
   632|     def __getstate__(self):
   633|         return {
   634|             "opts": self.opts,
   635|             "transport": self.transport,
   636|             "presence_events": self.presence_events,
   637|         }
   638|     def __setstate__(self, state):
   639|         self.opts = state["opts"]
   640|         self.state = state["presence_events"]
   641|         self.transport = state["transport"]
   642|         self.event = salt.utils.event.get_event("master", opts=self.opts, listen=False)
   643|         self.ckminions = salt.utils.minions.CkMinions(self.opts)
   644|         self.present = {}
   645|         self.master_key = salt.crypt.MasterKeys(self.opts)
   646|     def close(self):
   647|         self.transport.close()
   648|         if self.event is not None:
   649|             self.event.destroy()
   650|             self.event = None
   651|         if self.aes_funcs is not None:
   652|             self.aes_funcs.destroy()
   653|             self.aes_funcs = None
   654|     def pre_fork(self, process_manager, kwargs=None):
   655|         """
   656|         Do anything necessary pre-fork. Since this is on the master side this will
   657|         primarily be used to create IPC channels and create our daemon process to
   658|         do the actual publishing
   659|         :param func process_manager: A ProcessManager, from salt.utils.process.ProcessManager
   660|         """
   661|         if hasattr(self.transport, "publish_daemon"):
   662|             process_manager.add_process(self._publish_daemon, kwargs=kwargs)
   663|     def _publish_daemon(self, **kwargs):
   664|         if self.opts["pub_server_niceness"] and not salt.utils.platform.is_windows():
   665|             log.debug(
   666|                 "setting Publish daemon niceness to %i",
   667|                 self.opts["pub_server_niceness"],
   668|             )
   669|             os.nice(self.opts["pub_server_niceness"])
   670|         secrets = kwargs.get("secrets", None)
   671|         if secrets is not None:
   672|             salt.master.SMaster.secrets = secrets
   673|         self.master_key = salt.crypt.MasterKeys(self.opts)
   674|         self.transport.publish_daemon(
   675|             self.publish_payload, self.presence_callback, self.remove_presence_callback
   676|         )
   677|     def presence_callback(self, subscriber, msg):
   678|         if msg["enc"] != "aes":
   679|             return
   680|         crypticle = salt.crypt.Crypticle(self.opts, self.aes_key)
   681|         load = crypticle.loads(msg["load"])
   682|         load = salt.transport.frame.decode_embedded_strs(load)
   683|         if not self.aes_funcs.verify_minion(load["id"], load["tok"]):
   684|             return
   685|         subscriber.id_ = load["id"]
   686|         self._add_client_present(subscriber)
   687|     def remove_presence_callback(self, subscriber):
   688|         self._remove_client_present(subscriber)
   689|     def _add_client_present(self, client):
   690|         id_ = client.id_
   691|         if id_ in self.present:
   692|             clients = self.present[id_]
   693|             clients.add(client)
   694|         else:
   695|             self.present[id_] = {client}
   696|             if self.presence_events:
   697|                 data = {"new": [id_], "lost": []}
   698|                 self.event.fire_event(
   699|                     data, salt.utils.event.tagify("change", "presence")
   700|                 )

# --- HUNK 2: Lines 704-1004 ---
   704|                 )
   705|     def _remove_client_present(self, client):
   706|         id_ = client.id_
   707|         if id_ is None or id_ not in self.present:
   708|             return
   709|         clients = self.present[id_]
   710|         if client not in clients:
   711|             return
   712|         clients.remove(client)
   713|         if len(clients) == 0:
   714|             del self.present[id_]
   715|             if self.presence_events:
   716|                 data = {"new": [], "lost": [id_]}
   717|                 self.event.fire_event(
   718|                     data, salt.utils.event.tagify("change", "presence")
   719|                 )
   720|                 data = {"present": list(self.present.keys())}
   721|                 self.event.fire_event(
   722|                     data, salt.utils.event.tagify("present", "presence")
   723|                 )
   724|     async def publish_payload(self, load, *args):
   725|         load = salt.payload.loads(load)
   726|         unpacked_package = self.wrap_payload(load)
   727|         try:
   728|             payload = salt.payload.loads(unpacked_package["payload"])
   729|         except KeyError:
   730|             log.error("Invalid package %r", unpacked_package)
   731|             raise
   732|         payload = salt.payload.dumps(payload)
   733|         if "topic_lst" in unpacked_package:
   734|             topic_list = unpacked_package["topic_lst"]
   735|             ret = await self.transport.publish_payload(payload, topic_list)
   736|         else:
   737|             ret = await self.transport.publish_payload(payload)
   738|         return ret
   739|     def wrap_payload(self, load):
   740|         payload = {"enc": "aes"}
   741|         if not self.opts.get("cluster_id", None):
   742|             load["serial"] = salt.master.SMaster.get_serial()
   743|         crypticle = salt.crypt.Crypticle(self.opts, self.aes_key)
   744|         payload["load"] = crypticle.dumps(load)
   745|         if self.opts["sign_pub_messages"]:
   746|             log.debug("Signing data packet")
   747|             payload["sig"] = salt.crypt.PrivateKey(
   748|                 self.master_key.rsa_path,
   749|             ).sign(payload["load"])
   750|         int_payload = {"payload": salt.payload.dumps(payload)}
   751|         match_targets = ["pcre", "glob", "list"]
   752|         if self.transport.topic_support and load["tgt_type"] in match_targets:
   753|             if load["tgt_type"] == "list":
   754|                 int_payload["topic_lst"] = load["tgt"]
   755|             if isinstance(load["tgt"], str):
   756|                 _res = self.ckminions.check_minions(
   757|                     load["tgt"], tgt_type=load["tgt_type"]
   758|                 )
   759|                 match_ids = _res["minions"]
   760|                 log.debug("Publish Side Match: %s", match_ids)
   761|                 int_payload["topic_lst"] = match_ids
   762|             else:
   763|                 int_payload["topic_lst"] = load["tgt"]
   764|         return int_payload
   765|     async def publish(self, load):
   766|         """
   767|         Publish "load" to minions
   768|         """
   769|         log.debug(
   770|             "Sending payload to publish daemon. jid=%s load=%s",
   771|             load.get("jid", None),
   772|             repr(load)[:40],
   773|         )
   774|         payload = salt.payload.dumps(load)
   775|         await self.transport.publish(payload)
   776| class MasterPubServerChannel:
   777|     """ """
   778|     @classmethod
   779|     def factory(cls, opts, **kwargs):
   780|         transport = salt.transport.ipc_publish_server("master", opts)
   781|         return cls(opts, transport)
   782|     def __init__(self, opts, transport, presence_events=False):
   783|         self.opts = opts
   784|         self.transport = transport
   785|         self.io_loop = tornado.ioloop.IOLoop.current()
   786|         self.master_key = salt.crypt.MasterKeys(self.opts)
   787|         self.peer_keys = {}
   788|     def send_aes_key_event(self):
   789|         data = {"peer_id": self.opts["id"], "peers": {}}
   790|         for peer in self.opts.get("cluster_peers", []):
   791|             peer_pub = (
   792|                 pathlib.Path(self.opts["cluster_pki_dir"]) / "peers" / f"{peer}.pub"
   793|             )
   794|             if peer_pub.exists():
   795|                 pub = salt.crypt.PublicKey(peer_pub)
   796|                 aes = salt.master.SMaster.secrets["aes"]["secret"].value
   797|                 digest = salt.utils.stringutils.to_bytes(
   798|                     hashlib.sha256(aes).hexdigest()
   799|                 )
   800|                 data["peers"][peer] = {
   801|                     "aes": pub.encrypt(aes),
   802|                     "sig": salt.crypt.private_encrypt(
   803|                         self.master_key.master_key, digest
   804|                     ),
   805|                 }
   806|             else:
   807|                 log.warning("Peer key missing %r", peer_pub)
   808|                 data["peers"][peer] = {}
   809|         with salt.utils.event.get_master_event(
   810|             self.opts, self.opts["sock_dir"], listen=False
   811|         ) as event:
   812|             success = event.fire_event(
   813|                 data,
   814|                 salt.utils.event.tagify(self.opts["id"], "peer", "cluster"),
   815|                 timeout=30000,  # 30 second timeout
   816|             )
   817|             if not success:
   818|                 log.error("Unable to send aes key event")
   819|     def __getstate__(self):
   820|         return {
   821|             "opts": self.opts,
   822|             "transport": self.transport,
   823|         }
   824|     def __setstate__(self, state):
   825|         self.opts = state["opts"]
   826|         self.transport = state["transport"]
   827|     def close(self):
   828|         self.transport.close()
   829|     def pre_fork(self, process_manager, kwargs=None):
   830|         """
   831|         Do anything necessary pre-fork. Since this is on the master side this will
   832|         primarily be used to create IPC channels and create our daemon process to
   833|         do the actual publishing
   834|         :param func process_manager: A ProcessManager, from salt.utils.process.ProcessManager
   835|         """
   836|         if hasattr(self.transport, "publish_daemon"):
   837|             process_manager.add_process(
   838|                 self._publish_daemon, kwargs=kwargs, name="EventPublisher"
   839|             )
   840|     def _publish_daemon(self, **kwargs):
   841|         if (
   842|             self.opts["event_publisher_niceness"]
   843|             and not salt.utils.platform.is_windows()
   844|         ):
   845|             log.info(
   846|                 "setting EventPublisher niceness to %i",
   847|                 self.opts["event_publisher_niceness"],
   848|             )
   849|             os.nice(self.opts["event_publisher_niceness"])
   850|         self.io_loop = tornado.ioloop.IOLoop.current()
   851|         tcp_master_pool_port = 4520
   852|         self.pushers = []
   853|         self.auth_errors = {}
   854|         for peer in self.opts.get("cluster_peers", []):
   855|             pusher = salt.transport.tcp.TCPPublishServer(
   856|                 self.opts,
   857|                 pull_host=peer,
   858|                 pull_port=tcp_master_pool_port,
   859|             )
   860|             self.auth_errors[peer] = collections.deque()
   861|             self.pushers.append(pusher)
   862|         if self.opts.get("cluster_id", None):
   863|             self.pool_puller = salt.transport.tcp.TCPPuller(
   864|                 host=self.opts["interface"],
   865|                 port=tcp_master_pool_port,
   866|                 io_loop=self.io_loop,
   867|                 payload_handler=self.handle_pool_publish,
   868|             )
   869|             self.pool_puller.start()
   870|         self.io_loop.add_callback(
   871|             self.transport.publisher,
   872|             self.publish_payload,
   873|             io_loop=self.io_loop,
   874|         )
   875|         try:
   876|             self.io_loop.start()
   877|         except (KeyboardInterrupt, SystemExit):
   878|             pass
   879|         finally:
   880|             self.close()
   881|     async def handle_pool_publish(self, payload, _):
   882|         """
   883|         Handle incomming events from cluster peer.
   884|         """
   885|         try:
   886|             tag, data = salt.utils.event.SaltEvent.unpack(payload)
   887|             if tag.startswith("cluster/peer"):
   888|                 peer = data["peer_id"]
   889|                 aes = data["peers"][self.opts["id"]]["aes"]
   890|                 sig = data["peers"][self.opts["id"]]["sig"]
   891|                 key_str = self.master_key.master_private_decrypt(aes)
   892|                 digest = salt.utils.stringutils.to_bytes(
   893|                     hashlib.sha256(key_str).hexdigest()
   894|                 )
   895|                 pub_path = (
   896|                     pathlib.Path(self.opts["cluster_pki_dir"]) / "peers" / f"{peer}.pub"
   897|                 )
   898|                 key = salt.crypt.PublicKey(pub_path)
   899|                 m_digest = key.decrypt(sig)
   900|                 if m_digest != digest:
   901|                     log.error("Invalid aes signature from peer: %s", peer)
   902|                     return
   903|                 log.error("Received new key from peer %s", peer)
   904|                 if peer in self.peer_keys:
   905|                     if self.peer_keys[peer] != key_str:
   906|                         self.peer_keys[peer] = key_str
   907|                         self.send_aes_key_event()
   908|                         while self.auth_errors[peer]:
   909|                             key, data = self.auth_errors[peer].popleft()
   910|                             peer_id, parsed_tag = self.parse_cluster_tag(tag)
   911|                             try:
   912|                                 event_data = self.extract_cluster_event(peer_id, data)
   913|                             except salt.exceptions.AuthenticationError:
   914|                                 log.error(
   915|                                     "Event from peer failed authentication: %s", peer_id
   916|                                 )
   917|                             else:
   918|                                 await self.transport.publish_payload(
   919|                                     salt.utils.event.SaltEvent.pack(
   920|                                         parsed_tag, event_data
   921|                                     )
   922|                                 )
   923|                 else:
   924|                     self.peer_keys[peer] = key_str
   925|                     self.send_aes_key_event()
   926|                     while self.auth_errors[peer]:
   927|                         key, data = self.auth_errors[peer].popleft()
   928|                         peer_id, parsed_tag = self.parse_cluster_tag(tag)
   929|                         try:
   930|                             event_data = self.extract_cluster_event(peer_id, data)
   931|                         except salt.exceptions.AuthenticationError:
   932|                             log.error(
   933|                                 "Event from peer failed authentication: %s", peer_id
   934|                             )
   935|                         else:
   936|                             await self.transport.publish_payload(
   937|                                 salt.utils.event.SaltEvent.pack(parsed_tag, event_data)
   938|                             )
   939|             elif tag.startswith("cluster/event"):
   940|                 peer_id, parsed_tag = self.parse_cluster_tag(tag)
   941|                 try:
   942|                     event_data = self.extract_cluster_event(peer_id, data)
   943|                 except salt.exceptions.AuthenticationError:
   944|                     self.auth_errors[peer_id].append((tag, data))
   945|                 else:
   946|                     await self.transport.publish_payload(
   947|                         salt.utils.event.SaltEvent.pack(parsed_tag, event_data)
   948|                     )
   949|             else:
   950|                 log.error("This cluster tag not valid %s", tag)
   951|         except Exception:  # pylint: disable=broad-except
   952|             log.critical("Unhandled error while polling master events", exc_info=True)
   953|             return None
   954|     def parse_cluster_tag(self, tag):
   955|         peer_id = tag.replace("cluster/event/", "").split("/")[0]
   956|         stripped_tag = tag.replace(f"cluster/event/{peer_id}/", "")
   957|         return peer_id, stripped_tag
   958|     def extract_cluster_event(self, peer_id, data):
   959|         if peer_id in self.peer_keys:
   960|             crypticle = salt.crypt.Crypticle(self.opts, self.peer_keys[peer_id])
   961|             event_data = crypticle.loads(data)["event_payload"]
   962|             event_data["__peer_id"] = peer_id
   963|             return event_data
   964|         raise salt.exceptions.AuthenticationError("Peer aes key not available")
   965|     async def publish_payload(self, load, *args):
   966|         tag, data = salt.utils.event.SaltEvent.unpack(load)
   967|         tasks = []
   968|         if not tag.startswith("cluster/peer"):
   969|             tasks = [
   970|                 asyncio.create_task(
   971|                     self.transport.publish_payload(load), name=self.opts["id"]
   972|                 )
   973|             ]
   974|         for pusher in self.pushers:
   975|             log.debug("Publish event to peer %s:%s", pusher.pull_host, pusher.pull_port)
   976|             if tag.startswith("cluster/peer"):
   977|                 tasks.append(
   978|                     asyncio.create_task(pusher.publish(load), name=pusher.pull_host)
   979|                 )
   980|                 continue
   981|             crypticle = salt.crypt.Crypticle(
   982|                 self.opts, salt.master.SMaster.secrets["aes"]["secret"].value
   983|             )
   984|             load = {"event_payload": data}
   985|             event_data = salt.utils.event.SaltEvent.pack(
   986|                 salt.utils.event.tagify(tag, self.opts["id"], "cluster/event"),
   987|                 crypticle.dumps(load),
   988|             )
   989|             tasks.append(asyncio.create_task(pusher.publish(event_data)))
   990|         await asyncio.gather(*tasks, return_exceptions=True)
   991|         for task in tasks:
   992|             try:
   993|                 task.result()
   994|             except tornado.iostream.StreamClosedError:
   995|                 if task.get_name() == self.opts["id"]:
   996|                     log.error("Unable to forward event to local ipc bus")
   997|                 else:
   998|                     log.warning(
   999|                         "Unable to forward event to cluster peer %s", task.get_name()
  1000|                     )
  1001|             except Exception as exc:  # pylint: disable=broad-except
  1002|                 log.error(
  1003|                     "Unhandled error sending task %s", task.get_name(), exc_info=True
  1004|                 )


# ====================================================================
# FILE: salt/cli/daemons.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 77-168 ---
    77|         Log environment failure for the daemon and exit with the error code.
    78|         :param error:
    79|         :return:
    80|         """
    81|         log.exception(
    82|             "Failed to create environment for %s: %s",
    83|             self.__class__.__name__,
    84|             get_error_message(error),
    85|         )
    86|         self.shutdown(error)
    87| class Master(
    88|     salt.utils.parsers.MasterOptionParser, DaemonsMixin
    89| ):  # pylint: disable=no-init
    90|     """
    91|     Creates a master server
    92|     """
    93|     def _handle_signals(self, signum, sigframe):
    94|         if hasattr(self.master, "process_manager"):
    95|             self.master.process_manager._handle_signals(signum, sigframe)
    96|         super()._handle_signals(signum, sigframe)
    97|     def verify_environment(self):
    98|         if not self.config["verify_env"]:
    99|             return
   100|         v_dirs = [
   101|             self.config["pki_dir"],
   102|             os.path.join(self.config["pki_dir"], "minions"),
   103|             os.path.join(self.config["pki_dir"], "minions_pre"),
   104|             os.path.join(self.config["pki_dir"], "minions_denied"),
   105|             os.path.join(self.config["pki_dir"], "minions_autosign"),
   106|             os.path.join(self.config["pki_dir"], "minions_rejected"),
   107|             self.config["cachedir"],
   108|             os.path.join(self.config["cachedir"], "jobs"),
   109|             os.path.join(self.config["cachedir"], "proc"),
   110|             self.config["sock_dir"],
   111|             self.config["token_dir"],
   112|             self.config["syndic_dir"],
   113|             self.config["sqlite_queue_dir"],
   114|         ]
   115|         pki_dir = self.config["pki_dir"]
   116|         if (
   117|             self.config["cluster_id"]
   118|             and self.config["cluster_pki_dir"]
   119|             and self.config["cluster_pki_dir"] != self.config["pki_dir"]
   120|         ):
   121|             v_dirs.extend(
   122|                 [
   123|                     self.config["cluster_pki_dir"],
   124|                     os.path.join(self.config["cluster_pki_dir"], "peers"),
   125|                     os.path.join(self.config["cluster_pki_dir"], "minions"),
   126|                     os.path.join(self.config["cluster_pki_dir"], "minions_pre"),
   127|                     os.path.join(self.config["cluster_pki_dir"], "minions_denied"),
   128|                     os.path.join(self.config["cluster_pki_dir"], "minions_autosign"),
   129|                     os.path.join(self.config["cluster_pki_dir"], "minions_rejected"),
   130|                 ]
   131|             )
   132|             pki_dir = [self.config["pki_dir"], self.config["cluster_pki_dir"]]
   133|         verify_env(
   134|             v_dirs,
   135|             self.config["user"],
   136|             permissive=self.config["permissive_pki_access"],
   137|             root_dir=self.config["root_dir"],
   138|             pki_dir=pki_dir,
   139|         )
   140|     def prepare(self):
   141|         """
   142|         Run the preparation sequence required to start a salt master server.
   143|         If sub-classed, don't **ever** forget to run:
   144|             super(YourSubClass, self).prepare()
   145|         """
   146|         super().prepare()
   147|         try:
   148|             self.verify_environment()
   149|         except OSError as error:
   150|             self.environment_failure(error)
   151|         self.action_log_info("Setting up")
   152|         if not verify_socket(
   153|             self.config["interface"],
   154|             self.config["publish_port"],
   155|             self.config["ret_port"],
   156|         ):
   157|             self.shutdown(4, "The ports are not available to bind")
   158|         self.config["interface"] = ip_bracket(self.config["interface"])
   159|         migrations.migrate_paths(self.config)
   160|         import salt.master
   161|         self.master = salt.master.Master(self.config)
   162|         self.daemonize_if_required()
   163|         self.set_pidfile()
   164|         salt.utils.process.notify_systemd()
   165|     def start(self):
   166|         """
   167|         Start the actual master.
   168|         If sub-classed, don't **ever** forget to run:


# ====================================================================
# FILE: salt/cli/salt.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 153-193 ---
   153|                         ret.update(full_ret)
   154|                     except KeyError:
   155|                         errors.append(full_ret)
   156|             if self.config["cli_summary"] is True:
   157|                 if self.config["fun"] != "sys.doc":
   158|                     if self.options.output is None:
   159|                         self._print_returns_summary(ret)
   160|                         self._print_errors_summary(errors)
   161|             if not all(
   162|                 exit_code == salt.defaults.exitcodes.EX_OK for exit_code in retcodes
   163|             ):
   164|                 sys.stderr.write("ERROR: Minions returned with non-zero exit code\n")
   165|                 sys.exit(salt.defaults.exitcodes.EX_GENERIC)
   166|         except (
   167|             AuthenticationError,
   168|             AuthorizationError,
   169|             SaltInvocationError,
   170|             EauthAuthenticationError,
   171|             SaltClientError,
   172|         ) as exc:
   173|             self._output_ret(str(exc), "", retcode=1)
   174|         finally:
   175|             self.local_client.destroy()
   176|     def _preview_target(self):
   177|         """
   178|         Return a list of minions from a given target
   179|         """
   180|         return self.local_client.gather_minions(
   181|             self.config["tgt"], self.selected_target_option or "glob"
   182|         )
   183|     def _run_batch(self):
   184|         import salt.cli.batch
   185|         eauth = {}
   186|         if "token" in self.config:
   187|             eauth["token"] = self.config["token"]
   188|         if "token" not in eauth and self.options.eauth:
   189|             import salt.auth
   190|             resolver = salt.auth.Resolver(self.config)
   191|             res = resolver.cli(self.options.eauth)
   192|             if self.options.mktoken and res:
   193|                 tok = resolver.token_cli(self.options.eauth, res)


# ====================================================================
# FILE: salt/client/__init__.py
# Total hunks: 6
# ====================================================================
# --- HUNK 1: Lines 1-40 ---
     1| """
     2| The client module is used to create a client connection to the publisher
     3| The data structure needs to be:
     4|     {'enc': 'clear',
     5|      'load': {'fun': '<mod.callable>',
     6|               'arg':, ('arg1', 'arg2', ...),
     7|               'tgt': '<glob or id>',
     8|               'key': '<read in the key file>'}
     9| """
    10| import logging
    11| import os
    12| import random
    13| import sys
    14| import time
    15| from datetime import datetime
    16| import tornado.gen
    17| import salt.cache
    18| import salt.channel.client
    19| import salt.config
    20| import salt.defaults.exitcodes
    21| import salt.loader
    22| import salt.payload
    23| import salt.syspaths as syspaths
    24| import salt.utils.args
    25| import salt.utils.event
    26| import salt.utils.files
    27| import salt.utils.jid
    28| import salt.utils.minions
    29| import salt.utils.network
    30| import salt.utils.platform
    31| import salt.utils.stringutils
    32| import salt.utils.user
    33| import salt.utils.verify
    34| from salt.exceptions import (
    35|     AuthenticationError,
    36|     AuthorizationError,
    37|     EauthAuthenticationError,
    38|     PublishError,
    39|     SaltClientError,
    40|     SaltInvocationError,

# --- HUNK 2: Lines 308-348 ---
   308|                 timeout=self._get_timeout(timeout),
   309|                 listen=listen,
   310|                 **kwargs,
   311|             )
   312|         except SaltClientError:
   313|             raise SaltClientError(
   314|                 "The salt master could not be contacted. Is master running?"
   315|             )
   316|         except AuthenticationError as err:
   317|             raise
   318|         except AuthorizationError as err:
   319|             raise
   320|         except Exception as general_exception:  # pylint: disable=broad-except
   321|             raise SaltClientError(general_exception)
   322|         return self._check_pub_data(pub_data, listen=listen)
   323|     def gather_minions(self, tgt, expr_form):
   324|         _res = salt.utils.minions.CkMinions(self.opts).check_minions(
   325|             tgt, tgt_type=expr_form
   326|         )
   327|         return _res["minions"]
   328|     @tornado.gen.coroutine
   329|     def run_job_async(
   330|         self,
   331|         tgt,
   332|         fun,
   333|         arg=(),
   334|         tgt_type="glob",
   335|         ret="",
   336|         timeout=None,
   337|         jid="",
   338|         kwarg=None,
   339|         listen=True,
   340|         io_loop=None,
   341|         **kwargs,
   342|     ):
   343|         """
   344|         Asynchronously send a command to connected minions
   345|         Prep the job directory and publish a command to any targeted minions.
   346|         :return: A dictionary of (validated) ``pub_data`` or an empty
   347|             dictionary on failure. The ``pub_data`` contains the job ID and a
   348|             list of all minions that are expected to return data.

# --- HUNK 3: Lines 357-397 ---
   357|                 fun,
   358|                 arg,
   359|                 tgt_type,
   360|                 ret,
   361|                 jid=jid,
   362|                 timeout=self._get_timeout(timeout),
   363|                 io_loop=io_loop,
   364|                 listen=listen,
   365|                 **kwargs,
   366|             )
   367|         except SaltClientError:
   368|             raise SaltClientError(
   369|                 "The salt master could not be contacted. Is master running?"
   370|             )
   371|         except AuthenticationError as err:
   372|             raise AuthenticationError(err)
   373|         except AuthorizationError as err:
   374|             raise AuthorizationError(err)
   375|         except Exception as general_exception:  # pylint: disable=broad-except
   376|             raise SaltClientError(general_exception)
   377|         raise tornado.gen.Return(self._check_pub_data(pub_data, listen=listen))
   378|     def cmd_async(
   379|         self, tgt, fun, arg=(), tgt_type="glob", ret="", jid="", kwarg=None, **kwargs
   380|     ):
   381|         """
   382|         Asynchronously send a command to connected minions
   383|         The function signature is the same as :py:meth:`cmd` with the
   384|         following exceptions.
   385|         :returns: A job ID or 0 on failure.
   386|         .. code-block:: python
   387|             >>> local.cmd_async('*', 'test.sleep', [300])
   388|             '20131219215921857715'
   389|         """
   390|         pub_data = self.run_job(
   391|             tgt, fun, arg, tgt_type, ret, jid=jid, kwarg=kwarg, listen=False, **kwargs
   392|         )
   393|         try:
   394|             return pub_data["jid"]
   395|         except KeyError:
   396|             return 0
   397|     def cmd_subset(

# --- HUNK 4: Lines 1032-1072 ---
  1032|                 if "jid" not in jinfo:
  1033|                     jinfo_iter = []
  1034|                 else:
  1035|                     jinfo_iter = self.get_returns_no_block(
  1036|                         "salt/job/{}".format(jinfo["jid"])
  1037|                     )
  1038|                 timeout_at = time.time() + gather_job_timeout
  1039|                 if self.opts["order_masters"]:
  1040|                     timeout_at += self.opts.get("syndic_wait", 1)
  1041|             for raw in jinfo_iter:
  1042|                 if raw is None:
  1043|                     break
  1044|                 try:
  1045|                     if raw["data"]["retcode"] > 0:
  1046|                         log.error(
  1047|                             "saltutil returning errors on minion %s", raw["data"]["id"]
  1048|                         )
  1049|                         minions.remove(raw["data"]["id"])
  1050|                         break
  1051|                 except KeyError as exc:
  1052|                     missing_key = exc.__str__().strip("'\"")
  1053|                     if missing_key == "retcode":
  1054|                         log.debug("retcode missing from client return")
  1055|                     else:
  1056|                         log.debug(
  1057|                             "Passing on saltutil error. Key '%s' missing "
  1058|                             "from client return. This may be an error in "
  1059|                             "the client.",
  1060|                             missing_key,
  1061|                         )
  1062|                 open_jids.add(jinfo["jid"])
  1063|                 if "minions" in raw.get("data", {}):
  1064|                     minions.update(raw["data"]["minions"])
  1065|                     continue
  1066|                 if "syndic" in raw.get("data", {}):
  1067|                     minions.update(raw["syndic"])
  1068|                     continue
  1069|                 if "return" not in raw.get("data", {}):
  1070|                     continue
  1071|                 if raw["data"]["return"] == {}:
  1072|                     continue

# --- HUNK 5: Lines 1554-1594 ---
  1554|             if not payload:
  1555|                 key = self.__read_master_key()
  1556|                 if key == self.key:
  1557|                     return payload
  1558|                 self.key = key
  1559|                 payload_kwargs["key"] = self.key
  1560|                 payload = channel.send(payload_kwargs)
  1561|             error = payload.pop("error", None)
  1562|             if error is not None:
  1563|                 if isinstance(error, dict):
  1564|                     err_name = error.get("name", "")
  1565|                     err_msg = error.get("message", "")
  1566|                     if err_name == "AuthenticationError":
  1567|                         raise AuthenticationError(err_msg)
  1568|                     elif err_name == "AuthorizationError":
  1569|                         raise AuthorizationError(err_msg)
  1570|                 raise PublishError(error)
  1571|             if not payload:
  1572|                 return payload
  1573|         return {"jid": payload["load"]["jid"], "minions": payload["load"]["minions"]}
  1574|     @tornado.gen.coroutine
  1575|     def pub_async(
  1576|         self,
  1577|         tgt,
  1578|         fun,
  1579|         arg=(),
  1580|         tgt_type="glob",
  1581|         ret="",
  1582|         jid="",
  1583|         timeout=5,
  1584|         io_loop=None,
  1585|         listen=True,
  1586|         **kwargs,
  1587|     ):
  1588|         """
  1589|         Take the required arguments and publish the given command.
  1590|         Arguments:
  1591|             tgt:
  1592|                 The tgt is a regex or a glob used to match up the ids on
  1593|                 the minions. Salt works by always publishing every command
  1594|                 to all of the minions and then the minions determine if

# --- HUNK 6: Lines 1626-1682 ---
  1626|         with salt.channel.client.AsyncReqChannel.factory(
  1627|             self.opts, io_loop=io_loop, crypt="clear", master_uri=master_uri
  1628|         ) as channel:
  1629|             try:
  1630|                 if listen and not self.event.connect_pub(timeout=timeout):
  1631|                     raise SaltReqTimeoutError()
  1632|                 payload = yield channel.send(payload_kwargs, timeout=timeout)
  1633|             except SaltReqTimeoutError:
  1634|                 raise SaltReqTimeoutError(
  1635|                     "Salt request timed out. The master is not responding. You "
  1636|                     "may need to run your command with `--async` in order to "
  1637|                     "bypass the congested event bus. With `--async`, the CLI tool "
  1638|                     "will print the job id (jid) and exit immediately without "
  1639|                     "listening for responses. You can then use "
  1640|                     "`salt-run jobs.lookup_jid` to look up the results of the job "
  1641|                     "in the job cache later."
  1642|                 )
  1643|             if not payload:
  1644|                 key = self.__read_master_key()
  1645|                 if key == self.key:
  1646|                     raise tornado.gen.Return(payload)
  1647|                 self.key = key
  1648|                 payload_kwargs["key"] = self.key
  1649|                 payload = yield channel.send(payload_kwargs)
  1650|             error = payload.pop("error", None)
  1651|             if error is not None:
  1652|                 if isinstance(error, dict):
  1653|                     err_name = error.get("name", "")
  1654|                     err_msg = error.get("message", "")
  1655|                     if err_name == "AuthenticationError":
  1656|                         raise AuthenticationError(err_msg)
  1657|                     elif err_name == "AuthorizationError":
  1658|                         raise AuthorizationError(err_msg)
  1659|                 raise PublishError(error)
  1660|             if not payload:
  1661|                 raise tornado.gen.Return(payload)
  1662|         raise tornado.gen.Return(
  1663|             {"jid": payload["load"]["jid"], "minions": payload["load"]["minions"]}
  1664|         )
  1665|     def __del__(self):
  1666|         self.destroy()
  1667|     def _clean_up_subscriptions(self, job_id):
  1668|         if self.opts.get("order_masters"):
  1669|             self.event.unsubscribe(f"syndic/.*/{job_id}", "regex")
  1670|         self.event.unsubscribe(f"salt/job/{job_id}")
  1671|     def destroy(self):
  1672|         if self.event is not None:
  1673|             self.event.destroy()
  1674|             self.event = None
  1675|     def __enter__(self):
  1676|         return self
  1677|     def __exit__(self, *args):
  1678|         self.destroy()
  1679| class FunctionWrapper(dict):
  1680|     """
  1681|     Create a function wrapper that looks like the functions dict on the minion
  1682|     but invoked commands on the minion via a LocalClient.


# ====================================================================
# FILE: salt/client/mixins.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-34 ---
     1| """
     2| A collection of mixins useful for the various *Client interfaces
     3| """
     4| import copy
     5| import fnmatch
     6| import logging
     7| import os
     8| import signal
     9| import traceback
    10| import weakref
    11| from collections.abc import Mapping, MutableMapping
    12| import salt._logging
    13| import salt.channel.client
    14| import salt.exceptions
    15| import salt.minion
    16| import salt.output
    17| import salt.utils.args
    18| import salt.utils.doc
    19| import salt.utils.error
    20| import salt.utils.event
    21| import salt.utils.jid
    22| import salt.utils.job
    23| import salt.utils.lazy
    24| import salt.utils.platform
    25| import salt.utils.process
    26| import salt.utils.state
    27| import salt.utils.user
    28| import salt.utils.versions
    29| log = logging.getLogger(__name__)
    30| CLIENT_INTERNAL_KEYWORDS = frozenset(
    31|     [
    32|         "client",
    33|         "cmd",
    34|         "eauth",

# --- HUNK 2: Lines 282-338 ---
   282|                         continue
   283|                     mod, _ = mod_name.split(".", 1)
   284|                     if mod in completed_funcs:
   285|                         continue
   286|                     completed_funcs.append(mod)
   287|                     for global_key, value in func_globals.items():
   288|                         self.functions[mod_name].__globals__[global_key] = value
   289|                 if "arg" in low and "kwarg" in low:
   290|                     args = low["arg"]
   291|                     kwargs = low["kwarg"]
   292|                 else:
   293|                     f_call = salt.utils.args.format_call(
   294|                         self.functions[fun],
   295|                         low,
   296|                         expected_extra_kws=CLIENT_INTERNAL_KEYWORDS,
   297|                     )
   298|                     args = f_call.get("args", ())
   299|                     kwargs = f_call.get("kwargs", {})
   300|                 data["fun_args"] = list(args) + ([kwargs] if kwargs else [])
   301|                 func_globals["__jid_event__"].fire_event(data, "new")
   302|                 func = self.functions[fun]
   303|                 try:
   304|                     data["return"] = func(*args, **kwargs)
   305|                 except TypeError as exc:
   306|                     data[
   307|                         "return"
   308|                     ] = "\nPassed invalid arguments: {}\n\nUsage:\n{}".format(
   309|                         exc, func.__doc__
   310|                     )
   311|                 try:
   312|                     data["success"] = self.context.get("retcode", 0) == 0
   313|                 except AttributeError:
   314|                     data["success"] = True
   315|                 if isinstance(data["return"], dict) and "data" in data["return"]:
   316|                     data["success"] = salt.utils.state.check_result(
   317|                         data["return"]["data"]
   318|                     )
   319|             except (Exception, SystemExit) as ex:  # pylint: disable=broad-except
   320|                 if isinstance(ex, salt.exceptions.NotImplemented):
   321|                     data["return"] = str(ex)
   322|                 else:
   323|                     data["return"] = "Exception occurred in {} {}: {}".format(
   324|                         self.client,
   325|                         fun,
   326|                         traceback.format_exc(),
   327|                     )
   328|                 data["success"] = False
   329|                 data["retcode"] = 1
   330|             if self.store_job:
   331|                 try:
   332|                     salt.utils.job.store_job(
   333|                         self.opts,
   334|                         {
   335|                             "id": self.opts["id"],
   336|                             "tgt": self.opts["id"],
   337|                             "jid": data["jid"],
   338|                             "return": data,


# ====================================================================
# FILE: salt/client/ssh/__init__.py
# Total hunks: 12
# ====================================================================
# --- HUNK 1: Lines 360-547 ---
   360|             "__master_opts__" in self.opts
   361|             and self.opts["__master_opts__"].get("ssh_use_home_key")
   362|             and os.path.isfile(os.path.expanduser("~/.ssh/id_rsa"))
   363|         ):
   364|             priv = os.path.expanduser("~/.ssh/id_rsa")
   365|         else:
   366|             priv = self.opts.get(
   367|                 "ssh_priv", os.path.join(self.opts["pki_dir"], "ssh", "salt-ssh.rsa")
   368|             )
   369|         pub = f"{priv}.pub"
   370|         with salt.utils.files.fopen(pub, "r") as fp_:
   371|             return f"{fp_.read().split()[1]} rsa root@master"
   372|     def key_deploy(self, host, ret):
   373|         """
   374|         Deploy the SSH key if the minions don't auth
   375|         """
   376|         if not isinstance(ret[host], dict) or self.opts.get("ssh_key_deploy"):
   377|             target = self.targets[host]
   378|             if target.get("passwd", False) or self.opts["ssh_passwd"]:
   379|                 self._key_deploy_run(host, target, False)
   380|             return ret, None
   381|         if "_error" in ret[host] and ret[host]["_error"] == "Permission denied":
   382|             target = self.targets[host]
   383|             print(
   384|                 "Permission denied for host {}, do you want to deploy "
   385|                 "the salt-ssh key? (password required):".format(host)
   386|             )
   387|             deploy = input("[Y/n] ")
   388|             if deploy.startswith(("n", "N")):
   389|                 return ret
   390|             target["passwd"] = getpass.getpass(
   391|                 "Password for {}@{}: ".format(target["user"], host)
   392|             )
   393|             return self._key_deploy_run(host, target, True)
   394|         return ret, None
   395|     def _key_deploy_run(self, host, target, re_run=True):
   396|         """
   397|         The ssh-copy-id routine
   398|         """
   399|         argv = [
   400|             "ssh.set_auth_key",
   401|             target.get("user", "root"),
   402|             self.get_pubkey(),
   403|         ]
   404|         single = Single(
   405|             self.opts,
   406|             argv,
   407|             host,
   408|             mods=self.mods,
   409|             fsclient=self.fsclient,
   410|             thin=self.thin,
   411|             **target,
   412|         )
   413|         if salt.utils.path.which("ssh-copy-id"):
   414|             stdout, stderr, retcode = single.shell.copy_id()
   415|         else:
   416|             stdout, stderr, retcode = single.run()
   417|         if re_run:
   418|             target.pop("passwd")
   419|             single = Single(
   420|                 self.opts,
   421|                 self.opts["argv"],
   422|                 host,
   423|                 mods=self.mods,
   424|                 fsclient=self.fsclient,
   425|                 thin=self.thin,
   426|                 **target,
   427|             )
   428|             stdout, stderr, retcode = single.cmd_block()
   429|             try:
   430|                 retcode = int(retcode)
   431|             except (TypeError, ValueError):
   432|                 log.warning(f"Got an invalid retcode for host '{host}': '{retcode}'")
   433|                 retcode = 1
   434|             try:
   435|                 ret = (
   436|                     salt.client.ssh.wrapper.parse_ret(stdout, stderr, retcode),
   437|                     salt.defaults.exitcodes.EX_OK,
   438|                 )
   439|             except (
   440|                 salt.client.ssh.wrapper.SSHPermissionDeniedError,
   441|                 salt.client.ssh.wrapper.SSHCommandExecutionError,
   442|             ) as err:
   443|                 ret = err.to_ret()
   444|                 retcode = max(retcode, err.retcode, 1)
   445|             except salt.client.ssh.wrapper.SSHException as err:
   446|                 ret = err.to_ret()
   447|                 if not self.opts.get("raw_shell"):
   448|                     retcode = max(retcode, err.retcode, 1)
   449|                 else:
   450|                     ret.pop("_error", None)
   451|             except Exception as err:  # pylint: disable=broad-except
   452|                 log.error(
   453|                     f"Error while parsing the command output: {err}",
   454|                     exc_info_on_loglevel=logging.DEBUG,
   455|                 )
   456|                 ret = {
   457|                     "_error": f"Internal error while parsing the command output: {err}",
   458|                     "stdout": stdout,
   459|                     "stderr": stderr,
   460|                     "retcode": retcode,
   461|                     "data": None,
   462|                 }
   463|                 retcode = max(retcode, 1)
   464|             return {host: ret}, retcode
   465|         if retcode != salt.defaults.exitcodes.EX_OK:
   466|             return {host: stderr}, retcode
   467|         return {host: stdout}, retcode
   468|     def handle_routine(self, que, opts, host, target, mine=False):
   469|         """
   470|         Run the routine in a "Thread", put a dict on the queue
   471|         """
   472|         opts = copy.deepcopy(opts)
   473|         single = Single(
   474|             opts,
   475|             opts["argv"],
   476|             host,
   477|             mods=self.mods,
   478|             fsclient=self.fsclient,
   479|             thin=self.thin,
   480|             mine=mine,
   481|             **target,
   482|         )
   483|         ret = {"id": single.id}
   484|         stdout = stderr = ""
   485|         retcode = salt.defaults.exitcodes.EX_OK
   486|         try:
   487|             stdout, stderr, retcode = single.run()
   488|             try:
   489|                 retcode = int(retcode)
   490|             except (TypeError, ValueError):
   491|                 log.warning(f"Got an invalid retcode for host '{host}': '{retcode}'")
   492|                 retcode = 1
   493|             ret["ret"] = salt.client.ssh.wrapper.parse_ret(stdout, stderr, retcode)
   494|         except (
   495|             salt.client.ssh.wrapper.SSHPermissionDeniedError,
   496|             salt.client.ssh.wrapper.SSHCommandExecutionError,
   497|         ) as err:
   498|             ret["ret"] = err.to_ret()
   499|             retcode = max(retcode, err.retcode, 1)
   500|         except salt.client.ssh.wrapper.SSHException as err:
   501|             ret["ret"] = err.to_ret()
   502|             if not self.opts.get("raw_shell"):
   503|                 retcode = max(retcode, err.retcode, 1)
   504|             else:
   505|                 ret["ret"].pop("_error", None)
   506|         except Exception as err:  # pylint: disable=broad-except
   507|             log.error(
   508|                 f"Error while parsing the command output: {err}",
   509|                 exc_info_on_loglevel=logging.DEBUG,
   510|             )
   511|             ret["ret"] = {
   512|                 "_error": f"Internal error while parsing the command output: {err}",
   513|                 "stdout": stdout,
   514|                 "stderr": stderr,
   515|                 "retcode": retcode,
   516|                 "data": None,
   517|             }
   518|             retcode = max(retcode, 1)
   519|         que.put((ret, retcode))
   520|     def handle_ssh(self, mine=False):
   521|         """
   522|         Spin up the needed threads or processes and execute the subsequent
   523|         routines
   524|         """
   525|         que = multiprocessing.Queue()
   526|         running = {}
   527|         target_iter = self.targets.__iter__()
   528|         returned = set()
   529|         rets = set()
   530|         init = False
   531|         while True:
   532|             if not self.targets:
   533|                 log.error("No matching targets found in roster.")
   534|                 break
   535|             if len(running) < self.opts.get("ssh_max_procs", 25) and not init:
   536|                 try:
   537|                     host = next(target_iter)
   538|                 except StopIteration:
   539|                     init = True
   540|                     continue
   541|                 for default in self.defaults:
   542|                     if default not in self.targets[host]:
   543|                         self.targets[host][default] = self.defaults[default]
   544|                 if "host" not in self.targets[host]:
   545|                     self.targets[host]["host"] = host
   546|                 if self.targets[host].get("winrm") and not HAS_WINSHELL:
   547|                     returned.add(host)

# --- HUNK 2: Lines 556-596 ---
   556|                         "jid": None,
   557|                         "return": log_msg,
   558|                         "retcode": 1,
   559|                         "fun": "",
   560|                         "id": host,
   561|                     }
   562|                     yield {host: no_ret}, 1
   563|                     continue
   564|                 args = (
   565|                     que,
   566|                     self.opts,
   567|                     host,
   568|                     self.targets[host],
   569|                     mine,
   570|                 )
   571|                 routine = Process(target=self.handle_routine, args=args)
   572|                 routine.start()
   573|                 running[host] = {"thread": routine}
   574|                 continue
   575|             ret = {}
   576|             retcode = salt.defaults.exitcodes.EX_OK
   577|             try:
   578|                 ret, retcode = que.get(False)
   579|                 if "id" in ret:
   580|                     returned.add(ret["id"])
   581|                     yield {ret["id"]: ret["ret"]}, retcode
   582|             except queue.Empty:
   583|                 pass
   584|             for host in running:
   585|                 if not running[host]["thread"].is_alive():
   586|                     if host not in returned:
   587|                         try:
   588|                             while True:
   589|                                 ret, retcode = que.get(False)
   590|                                 if "id" in ret:
   591|                                     returned.add(ret["id"])
   592|                                     yield {ret["id"]: ret["ret"]}, retcode
   593|                         except queue.Empty:
   594|                             pass
   595|                         if host not in returned:
   596|                             error = (

# --- HUNK 3: Lines 627-691 ---
   627|             args = argv
   628|         else:
   629|             fun = argv[0] if argv else ""
   630|             args = argv[1:]
   631|         job_load = {
   632|             "jid": jid,
   633|             "tgt_type": self.tgt_type,
   634|             "tgt": self.opts["tgt"],
   635|             "user": self.opts["user"],
   636|             "fun": fun,
   637|             "arg": args,
   638|         }
   639|         if self.opts["master_job_cache"] == "local_cache":
   640|             self.returners["{}.save_load".format(self.opts["master_job_cache"])](
   641|                 jid, job_load, minions=self.targets.keys()
   642|             )
   643|         else:
   644|             self.returners["{}.save_load".format(self.opts["master_job_cache"])](
   645|                 jid, job_load
   646|             )
   647|         for ret, retcode in self.handle_ssh(mine=mine):
   648|             host = next(iter(ret))
   649|             self.cache_job(jid, host, ret[host], fun)
   650|             if self.event:
   651|                 id_, data = next(iter(ret.items()))
   652|                 if not isinstance(data, dict):
   653|                     data = {"return": data}
   654|                 if "id" not in data:
   655|                     data["id"] = id_
   656|                 if "fun" not in data:
   657|                     data["fun"] = fun
   658|                 if "fun_args" not in data:
   659|                     data["fun_args"] = args
   660|                 if "retcode" not in data:
   661|                     data["retcode"] = retcode
   662|                 if "success" not in data:
   663|                     data["success"] = data["retcode"] == salt.defaults.exitcodes.EX_OK
   664|                 if "return" not in data:
   665|                     if data["success"]:
   666|                         data["return"] = data.get("stdout")
   667|                     else:
   668|                         data["return"] = data.get("stderr", data.get("stdout"))
   669|                 data[
   670|                     "jid"
   671|                 ] = jid  # make the jid in the payload the same as the jid in the tag
   672|                 self.event.fire_event(
   673|                     data, salt.utils.event.tagify([jid, "ret", host], "job")
   674|                 )
   675|             yield ret
   676|     def cache_job(self, jid, id_, ret, fun):
   677|         """
   678|         Cache the job information
   679|         """
   680|         self.returners["{}.returner".format(self.opts["master_job_cache"])](
   681|             {"jid": jid, "id": id_, "return": ret, "fun": fun}
   682|         )
   683|     def run(self, jid=None):
   684|         """
   685|         Execute the overall routine, print results via outputters
   686|         """
   687|         if self.opts.get("list_hosts"):
   688|             self._get_roster()
   689|             ret = {}
   690|             for roster_file in self.__parsed_rosters:
   691|                 if roster_file.startswith("#"):

# --- HUNK 4: Lines 721-818 ---
   721|                     jid, job_load, minions=self.targets.keys()
   722|                 )
   723|             else:
   724|                 self.returners["{}.save_load".format(self.opts["master_job_cache"])](
   725|                     jid, job_load
   726|                 )
   727|         except Exception as exc:  # pylint: disable=broad-except
   728|             log.error(
   729|                 "Could not save load with returner %s: %s",
   730|                 self.opts["master_job_cache"],
   731|                 exc,
   732|                 exc_info=True,
   733|             )
   734|         if self.opts.get("verbose"):
   735|             msg = f"Executing job with jid {jid}"
   736|             print(msg)
   737|             print("-" * len(msg) + "\n")
   738|             print("")
   739|         sret = {}
   740|         outputter = self.opts.get("output", "nested")
   741|         final_exit = salt.defaults.exitcodes.EX_OK
   742|         for ret, retcode in self.handle_ssh():
   743|             host = next(iter(ret))
   744|             if not isinstance(retcode, int):
   745|                 log.warning(f"Host '{host}' returned an invalid retcode: {retcode}")
   746|                 retcode = 1
   747|             final_exit = max(final_exit, retcode)
   748|             self.cache_job(jid, host, ret[host], fun)
   749|             ret, deploy_retcode = self.key_deploy(host, ret)
   750|             if deploy_retcode is not None:
   751|                 try:
   752|                     retcode = int(deploy_retcode)
   753|                 except (TypeError, ValueError):
   754|                     log.warning(
   755|                         f"Got an invalid deploy retcode for host '{host}': '{retcode}'"
   756|                     )
   757|                     retcode = 1
   758|             final_exit = max(final_exit, retcode)
   759|             if isinstance(ret[host], dict) and (
   760|                 ret[host].get("stderr") or ""
   761|             ).startswith("ssh:"):
   762|                 ret[host] = ret[host]["stderr"]
   763|             if not isinstance(ret[host], dict):
   764|                 p_data = {host: ret[host]}
   765|             elif "return" not in ret[host]:
   766|                 if ret[host].get("_error") == "Permission denied":
   767|                     p_data = {host: ret[host]["stderr"]}
   768|                 else:
   769|                     p_data = ret
   770|             else:
   771|                 outputter = ret[host].get("out", self.opts.get("output", "nested"))
   772|                 p_data = {host: ret[host].get("return", {})}
   773|             if self.opts.get("static"):
   774|                 sret.update(p_data)
   775|             else:
   776|                 salt.output.display_output(p_data, outputter, self.opts)
   777|             if self.event:
   778|                 id_, data = next(iter(ret.items()))
   779|                 if not isinstance(data, dict):
   780|                     data = {"return": data}
   781|                 if "id" not in data:
   782|                     data["id"] = id_
   783|                 if "fun" not in data:
   784|                     data["fun"] = fun
   785|                 if "fun_args" not in data:
   786|                     data["fun_args"] = args
   787|                 if "retcode" not in data:
   788|                     data["retcode"] = retcode
   789|                 if "success" not in data:
   790|                     data["success"] = data["retcode"] == salt.defaults.exitcodes.EX_OK
   791|                 if "return" not in data:
   792|                     if data["success"]:
   793|                         data["return"] = data.get("stdout")
   794|                     else:
   795|                         data["return"] = data.get("stderr", data.get("stdout"))
   796|                 data[
   797|                     "jid"
   798|                 ] = jid  # make the jid in the payload the same as the jid in the tag
   799|                 self.event.fire_event(
   800|                     data, salt.utils.event.tagify([jid, "ret", host], "job")
   801|                 )
   802|         if self.event is not None:
   803|             self.event.destroy()
   804|         if self.opts.get("static"):
   805|             salt.output.display_output(sret, outputter, self.opts)
   806|         if final_exit:
   807|             sys.exit(salt.defaults.exitcodes.EX_AGGREGATE)
   808| class Single:
   809|     """
   810|     Hold onto a single ssh execution
   811|     """
   812|     def __init__(
   813|         self,
   814|         opts,
   815|         argv,
   816|         id_,
   817|         host,
   818|         user=None,

# --- HUNK 5: Lines 928-968 ---
   928|         args = parsed[0]
   929|         kws = parsed[1]
   930|         return fun, args, kws
   931|     def _escape_arg(self, arg):
   932|         """
   933|         Properly escape argument to protect special characters from shell
   934|         interpretation.  This avoids having to do tricky argument quoting.
   935|         Effectively just escape all characters in the argument that are not
   936|         alphanumeric!
   937|         """
   938|         if self.winrm:
   939|             return arg
   940|         return "".join(["\\" + char if re.match(r"\W", char) else char for char in arg])
   941|     def run_ssh_pre_flight(self):
   942|         """
   943|         Run our pre_flight script before running any ssh commands
   944|         """
   945|         with tempfile.NamedTemporaryFile() as temp:
   946|             try:
   947|                 shutil.copyfile(self.ssh_pre_flight, temp.name)
   948|             except OSError:
   949|                 return (
   950|                     "",
   951|                     "Could not copy pre flight script to temporary path",
   952|                     1,
   953|                 )
   954|             target_script = f".{pathlib.Path(temp.name).name}"
   955|             log.trace("Copying the pre flight script to target")
   956|             stdout, stderr, retcode = self.shell.send(temp.name, target_script)
   957|             if retcode != 0:
   958|                 log.error("Could not copy the pre flight script to target")
   959|                 return stdout, stderr, retcode
   960|             log.trace("Executing the pre flight script on target")
   961|             return self.execute_script(
   962|                 target_script, script_args=self.ssh_pre_flight_args
   963|             )
   964|     def check_thin_dir(self):
   965|         """
   966|         check if the thindir exists on the remote machine
   967|         """
   968|         stdout, stderr, retcode = self.shell.exec_cmd(f"test -d {self.thin_dir}")

# --- HUNK 6: Lines 982-1036 ---
   982|     def deploy_ext(self):
   983|         """
   984|         Deploy the ext_mods tarball
   985|         """
   986|         if self.mods.get("file"):
   987|             self.shell.send(
   988|                 self.mods["file"],
   989|                 os.path.join(self.thin_dir, "salt-ext_mods.tgz"),
   990|             )
   991|         return True
   992|     def run(self, deploy_attempted=False):
   993|         """
   994|         Execute the routine, the routine can be either:
   995|         1. Execute a raw shell command
   996|         2. Execute a wrapper func
   997|         3. Execute a remote Salt command
   998|         If a (re)deploy is needed, then retry the operation after a deploy
   999|         attempt
  1000|         Returns tuple of (stdout, stderr, retcode)
  1001|         """
  1002|         stdout = stderr = ""
  1003|         retcode = salt.defaults.exitcodes.EX_OK
  1004|         if self.ssh_pre_flight:
  1005|             if not self.opts.get("ssh_run_pre_flight", False) and self.check_thin_dir():
  1006|                 log.info(
  1007|                     "%s thin dir already exists. Not running ssh_pre_flight script",
  1008|                     self.thin_dir,
  1009|                 )
  1010|             elif not os.path.exists(self.ssh_pre_flight):
  1011|                 log.error(
  1012|                     "The ssh_pre_flight script %s does not exist", self.ssh_pre_flight
  1013|                 )
  1014|             else:
  1015|                 stdout, stderr, retcode = self.run_ssh_pre_flight()
  1016|                 if retcode != salt.defaults.exitcodes.EX_OK:
  1017|                     log.error(
  1018|                         "Error running ssh_pre_flight script %s", self.ssh_pre_file
  1019|                     )
  1020|                     return stdout, stderr, retcode
  1021|                 log.info(
  1022|                     "Successfully ran the ssh_pre_flight script: %s", self.ssh_pre_file
  1023|                 )
  1024|         if self.opts.get("raw_shell", False):
  1025|             cmd_str = " ".join([self._escape_arg(arg) for arg in self.argv])
  1026|             stdout, stderr, retcode = self.shell.exec_cmd(cmd_str)
  1027|         elif self.fun in self.wfuncs or self.mine:
  1028|             stdout, retcode = self.run_wfunc()
  1029|         else:
  1030|             stdout, stderr, retcode = self.cmd_block()
  1031|         return stdout, stderr, retcode
  1032|     def run_wfunc(self):
  1033|         """
  1034|         Execute a wrapper function
  1035|         Returns tuple of (json_data, '')
  1036|         """

# --- HUNK 7: Lines 1046-1103 ---
  1046|         else:
  1047|             passed_time = (time.time() - os.stat(datap).st_mtime) / 60
  1048|             if passed_time > self.opts.get("cache_life", 60):
  1049|                 refresh = True
  1050|         if self.opts.get("refresh_cache"):
  1051|             refresh = True
  1052|         conf_grains = {}
  1053|         if "ssh_grains" in self.opts:
  1054|             conf_grains = self.opts["ssh_grains"]
  1055|         if not data_cache:
  1056|             refresh = True
  1057|         if refresh:
  1058|             pre_wrapper = salt.client.ssh.wrapper.FunctionWrapper(
  1059|                 self.opts,
  1060|                 self.id,
  1061|                 fsclient=self.fsclient,
  1062|                 minion_opts=self.minion_opts,
  1063|                 **self.target,
  1064|             )
  1065|             opts_pkg = pre_wrapper["test.opts_pkg"]()  # pylint: disable=E1102
  1066|             opts_pkg["file_roots"] = self.opts["file_roots"]
  1067|             opts_pkg["pillar_roots"] = self.opts["pillar_roots"]
  1068|             opts_pkg["ext_pillar"] = self.opts["ext_pillar"]
  1069|             opts_pkg["extension_modules"] = self.opts["extension_modules"]
  1070|             opts_pkg["module_dirs"] = self.opts["module_dirs"]
  1071|             opts_pkg["_ssh_version"] = self.opts["_ssh_version"]
  1072|             opts_pkg["thin_dir"] = self.opts["thin_dir"]
  1073|             opts_pkg["master_tops"] = self.opts["master_tops"]
  1074|             opts_pkg["extra_filerefs"] = self.opts.get("extra_filerefs", "")
  1075|             opts_pkg["__master_opts__"] = self.context["master_opts"]
  1076|             if "known_hosts_file" in self.opts:
  1077|                 opts_pkg["known_hosts_file"] = self.opts["known_hosts_file"]
  1078|             if "_caller_cachedir" in self.opts:
  1079|                 opts_pkg["_caller_cachedir"] = self.opts["_caller_cachedir"]
  1080|             else:
  1081|                 opts_pkg["_caller_cachedir"] = self.opts["cachedir"]
  1082|             opts_pkg["id"] = self.id
  1083|             retcode = salt.defaults.exitcodes.EX_OK
  1084|             for grain in conf_grains:
  1085|                 opts_pkg["grains"][grain] = conf_grains[grain]
  1086|             if "grains" in self.target:
  1087|                 for grain in self.target["grains"]:
  1088|                     opts_pkg["grains"][grain] = self.target["grains"][grain]
  1089|             popts = {}
  1090|             popts.update(opts_pkg)
  1091|             popts.update(opts_pkg["__master_opts__"])
  1092|             pillar = salt.pillar.Pillar(
  1093|                 popts,
  1094|                 opts_pkg["grains"],
  1095|                 opts_pkg["id"],
  1096|                 opts_pkg.get("saltenv", "base"),
  1097|             )
  1098|             pillar_data = pillar.compile_pillar()
  1099|             data = {
  1100|                 "opts": opts_pkg,
  1101|                 "grains": opts_pkg["grains"],
  1102|                 "pillar": pillar_data,
  1103|             }

# --- HUNK 8: Lines 1143-1207 ---
  1143|                 mine_args = mine_fun_data
  1144|             elif isinstance(mine_fun_data, list):
  1145|                 for item in mine_fun_data[:]:
  1146|                     if isinstance(item, dict) and "mine_function" in item:
  1147|                         mine_fun = item["mine_function"]
  1148|                         mine_fun_data.pop(mine_fun_data.index(item))
  1149|                 mine_args = mine_fun_data
  1150|             else:
  1151|                 mine_args = mine_fun_data
  1152|             if isinstance(mine_args, dict):
  1153|                 self.args = []
  1154|                 self.kwargs = mine_args
  1155|             elif isinstance(mine_args, list):
  1156|                 self.args = mine_args
  1157|                 self.kwargs = {}
  1158|         try:
  1159|             if self.mine:
  1160|                 result = wrapper[mine_fun](*self.args, **self.kwargs)
  1161|             else:
  1162|                 result = self.wfuncs[self.fun](*self.args, **self.kwargs)
  1163|         except salt.client.ssh.wrapper.SSHException:
  1164|             raise
  1165|         except TypeError as exc:
  1166|             result = {"local": f"TypeError encountered executing {self.fun}: {exc}"}
  1167|             log.error(result, exc_info_on_loglevel=logging.DEBUG)
  1168|             retcode = 1
  1169|         except Exception as exc:  # pylint: disable=broad-except
  1170|             result = {
  1171|                 "local": f"An Exception occurred while executing {self.fun}: {exc}"
  1172|             }
  1173|             log.error(result, exc_info_on_loglevel=logging.DEBUG)
  1174|             retcode = 1
  1175|         try:
  1176|             retcode = max(
  1177|                 retcode, self.context.get("retcode", salt.defaults.exitcodes.EX_OK)
  1178|             )
  1179|         except (TypeError, ValueError):
  1180|             log.warning(
  1181|                 f"Wrapper module set invalid value for retcode: '{self.context['retcode']}"
  1182|             )
  1183|             retcode = max(retcode, 1)
  1184|         if isinstance(result, dict) and "local" in result:
  1185|             ret = salt.utils.json.dumps({"local": result["local"]})
  1186|         elif self.context.get("retcode"):
  1187|             ret = salt.utils.json.dumps({"local": result})
  1188|         else:
  1189|             ret = salt.utils.json.dumps({"local": {"return": result}})
  1190|         return ret, retcode
  1191|     def _cmd_str(self):
  1192|         """
  1193|         Prepare the command string
  1194|         """
  1195|         if self.target.get("sudo"):
  1196|             sudo = (
  1197|                 f"sudo -p '{salt.client.ssh.shell.SUDO_PROMPT}'"
  1198|                 if self.target.get("passwd")
  1199|                 else "sudo"
  1200|             )
  1201|         else:
  1202|             sudo = ""
  1203|         sudo_user = self.target["sudo_user"]
  1204|         if "_caller_cachedir" in self.opts:
  1205|             cachedir = self.opts["_caller_cachedir"]
  1206|         else:
  1207|             cachedir = self.opts["cachedir"]

# --- HUNK 9: Lines 1272-1312 ---
  1272|                 ret = saltwinshell.call_python(self, script)
  1273|         if not self.winrm:
  1274|             self.shell.exec_cmd(f"rm '{pre_dir}{script}'")
  1275|         else:
  1276|             self.shell.exec_cmd(f"del {script}")
  1277|         return ret
  1278|     def shim_cmd(self, cmd_str, extension="py"):
  1279|         """
  1280|         Run a shim command.
  1281|         If tty is enabled, we must scp the shim to the target system and
  1282|         execute it there
  1283|         """
  1284|         if not self.tty and not self.winrm:
  1285|             return self.shell.exec_cmd(cmd_str)
  1286|         with tempfile.NamedTemporaryFile(mode="w+b", delete=False) as shim_tmp_file:
  1287|             shim_tmp_file.write(salt.utils.stringutils.to_bytes(cmd_str))
  1288|         target_shim_file = f".{pathlib.Path(shim_tmp_file.name).name}"
  1289|         if self.winrm:
  1290|             target_shim_file = saltwinshell.get_target_shim_file(self, target_shim_file)
  1291|         stdout, stderr, retcode = self.shell.send(
  1292|             shim_tmp_file.name, target_shim_file, makedirs=self.winrm
  1293|         )
  1294|         if retcode != 0:
  1295|             log.error("Could not copy the shim script to target")
  1296|             return stdout, stderr, retcode
  1297|         try:
  1298|             os.remove(shim_tmp_file.name)
  1299|         except OSError:
  1300|             pass
  1301|         ret = self.execute_script(script=target_shim_file, extension=extension)
  1302|         return ret
  1303|     def cmd_block(self, is_retry=False):
  1304|         """
  1305|         Prepare the pre-check command to send to the subsystem
  1306|         1. execute SHIM + command
  1307|         2. check if SHIM returns a master request or if it completed
  1308|         3. handle any master request
  1309|         4. re-execute SHIM + command
  1310|         5. split SHIM results from command results
  1311|         6. return command results
  1312|         """

# --- HUNK 10: Lines 1511-1551 ---
  1511|     ret = []
  1512|     if isinstance(data, str):
  1513|         if data.startswith(proto):
  1514|             return [data]
  1515|     if isinstance(data, list):
  1516|         for comp in data:
  1517|             if isinstance(comp, str):
  1518|                 if comp.startswith(proto):
  1519|                     ret.append(comp)
  1520|     return ret
  1521| def mod_data(fsclient):
  1522|     """
  1523|     Generate the module arguments for the shim data
  1524|     """
  1525|     sync_refs = [
  1526|         "modules",
  1527|         "states",
  1528|         "grains",
  1529|         "renderers",
  1530|         "returners",
  1531|         "utils",
  1532|     ]
  1533|     ret = {}
  1534|     with fsclient:
  1535|         envs = fsclient.envs()
  1536|         ver_base = ""
  1537|         for env in envs:
  1538|             files = fsclient.file_list(env)
  1539|             for ref in sync_refs:
  1540|                 mods_data = {}
  1541|                 pref = f"_{ref}"
  1542|                 for fn_ in sorted(files):
  1543|                     if fn_.startswith(pref):
  1544|                         if fn_.endswith((".py", ".so", ".pyx")):
  1545|                             full = salt.utils.url.create(fn_)
  1546|                             mod_path = fsclient.cache_file(full, env)
  1547|                             if not os.path.isfile(mod_path):
  1548|                                 continue
  1549|                             mods_data[os.path.basename(fn_)] = mod_path
  1550|                             chunk = salt.utils.hashutils.get_hash(mod_path)
  1551|                             ver_base += chunk

# --- HUNK 11: Lines 1563-1603 ---
  1563|         if os.path.isfile(ext_tar_path):
  1564|             return mods
  1565|         tfp = tarfile.open(ext_tar_path, "w:gz")
  1566|         verfile = os.path.join(fsclient.opts["cachedir"], "ext_mods.ver")
  1567|         with salt.utils.files.fopen(verfile, "w+") as fp_:
  1568|             fp_.write(ver)
  1569|         tfp.add(verfile, "ext_version")
  1570|         for ref in ret:
  1571|             for fn_ in ret[ref]:
  1572|                 tfp.add(ret[ref][fn_], os.path.join(ref, fn_))
  1573|         tfp.close()
  1574|         return mods
  1575| def ssh_version():
  1576|     """
  1577|     Returns the version of the installed ssh command
  1578|     """
  1579|     ret = subprocess.Popen(
  1580|         ["ssh", "-V"], stdout=subprocess.PIPE, stderr=subprocess.PIPE
  1581|     ).communicate()
  1582|     try:
  1583|         version_parts = ret[1].split(b",")[0].split(b"_")[1]
  1584|         parts = []
  1585|         for part in version_parts:
  1586|             try:
  1587|                 parts.append(int(part))
  1588|             except ValueError:
  1589|                 return tuple(parts)
  1590|         return tuple(parts)
  1591|     except IndexError:
  1592|         return (2, 0)
  1593| def _convert_args(args):
  1594|     """
  1595|     Take a list of args, and convert any dicts inside the list to keyword
  1596|     args in the form of `key=value`, ready to be passed to salt-ssh
  1597|     """
  1598|     converted = []
  1599|     for arg in args:
  1600|         if isinstance(arg, dict):
  1601|             for key in list(arg.keys()):
  1602|                 if key == "__kwarg__":
  1603|                     continue


# ====================================================================
# FILE: salt/client/ssh/shell.py
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-50 ---
     1| """
     2| Manage transport commands via ssh
     3| """
     4| import logging
     5| import os
     6| import re
     7| import shlex
     8| import subprocess
     9| import sys
    10| import time
    11| import salt.defaults.exitcodes
    12| import salt.utils.json
    13| import salt.utils.nb_popen
    14| import salt.utils.vt
    15| log = logging.getLogger(__name__)
    16| SSH_PASSWORD_PROMPT_RE = re.compile(r"(?:.*)[Pp]assword(?: for .*)?:\s*$", re.M)
    17| KEY_VALID_RE = re.compile(r".*\(yes\/no\).*")
    18| SSH_PRIVATE_KEY_PASSWORD_PROMPT_RE = re.compile(r"Enter passphrase for key", re.M)
    19| SUDO_PROMPT = "[salt:sudo:d11bd4221135c33324a6bdc09674146fbfdf519989847491e34a689369bbce23]passwd:"
    20| SUDO_PROMPT_RE = re.compile(
    21|     r"\[salt:sudo:d11bd4221135c33324a6bdc09674146fbfdf519989847491e34a689369bbce23\]passwd:",
    22|     re.M,
    23| )
    24| RSTR = "_edbc7885e4f9aac9b83b35999b68d015148caf467b78fa39c05f669c0ff89878"
    25| RSTR_RE = re.compile(r"(?:^|\r?\n)" + RSTR + r"(?:\r?\n|$)")
    26| def gen_key(path):
    27|     """
    28|     Generate a key for use with salt-ssh
    29|     """
    30|     cmd = ["ssh-keygen", "-P", "", "-f", path, "-t", "rsa", "-q"]
    31|     dirname = os.path.dirname(path)
    32|     if dirname and not os.path.isdir(dirname):
    33|         os.makedirs(os.path.dirname(path))
    34|     subprocess.call(cmd)
    35| def gen_shell(opts, **kwargs):
    36|     """
    37|     Return the correct shell interface for the target system
    38|     """
    39|     if kwargs["winrm"]:
    40|         try:
    41|             import saltwinshell
    42|             shell = saltwinshell.Shell(opts, **kwargs)
    43|         except ImportError:
    44|             log.error("The saltwinshell library is not available")
    45|             sys.exit(salt.defaults.exitcodes.EX_GENERIC)
    46|     else:
    47|         shell = Shell(opts, **kwargs)
    48|     return shell
    49| class Shell:
    50|     """

# --- HUNK 2: Lines 190-241 ---
   190|         """
   191|         if self.passwd:
   192|             return "{} {} {} -p {} {} {}@{}".format(
   193|                 "ssh-copy-id",
   194|                 f"-i {self.priv}.pub",
   195|                 self._passwd_opts(),
   196|                 self.port,
   197|                 self._ssh_opts(),
   198|                 self.user,
   199|                 self.host,
   200|             )
   201|         return None
   202|     def copy_id(self):
   203|         """
   204|         Execute ssh-copy-id to plant the id file on the target
   205|         """
   206|         stdout, stderr, retcode = self._run_cmd(self._copy_id_str_old())
   207|         if salt.defaults.exitcodes.EX_OK != retcode and "Usage" in stderr:
   208|             stdout, stderr, retcode = self._run_cmd(self._copy_id_str_new())
   209|         return stdout, stderr, retcode
   210|     def _cmd_str(self, cmd, ssh="ssh"):
   211|         """
   212|         Return the cmd string to execute
   213|         """
   214|         command = [ssh]
   215|         if ssh != "scp":
   216|             command.append(self.host)
   217|         if self.tty and ssh == "ssh":
   218|             command.append("-t -t")
   219|         if self.passwd or self.priv:
   220|             command.append(self.priv and self._key_opts() or self._passwd_opts())
   221|         if ssh != "scp" and self.remote_port_forwards:
   222|             command.append(
   223|                 " ".join(
   224|                     [f"-R {item}" for item in self.remote_port_forwards.split(",")]
   225|                 )
   226|             )
   227|         if self.ssh_options:
   228|             command.append(self._ssh_opts())
   229|         command.append(cmd)
   230|         return " ".join(command)
   231|     def _run_nb_cmd(self, cmd):
   232|         """
   233|         cmd iterator
   234|         """
   235|         try:
   236|             proc = salt.utils.nb_popen.NonBlockingPopen(
   237|                 self._split_cmd(cmd),
   238|                 stderr=subprocess.PIPE,
   239|                 stdout=subprocess.PIPE,
   240|             )
   241|             while True:

# --- HUNK 3: Lines 272-325 ---
   272|     def exec_cmd(self, cmd):
   273|         """
   274|         Execute a remote command
   275|         """
   276|         cmd = self._cmd_str(cmd)
   277|         logmsg = f"Executing command: {cmd}"
   278|         if self.passwd:
   279|             logmsg = logmsg.replace(self.passwd, ("*" * 6))
   280|         if 'decode("base64")' in logmsg or "base64.b64decode(" in logmsg:
   281|             log.debug("Executed SHIM command. Command logged to TRACE")
   282|             log.trace(logmsg)
   283|         else:
   284|             log.debug(logmsg)
   285|         ret = self._run_cmd(cmd)
   286|         return ret
   287|     def send(self, local, remote, makedirs=False):
   288|         """
   289|         scp a file or files to a remote system
   290|         """
   291|         if makedirs:
   292|             pardir = os.path.dirname(remote)
   293|             if not pardir:
   294|                 log.warning(
   295|                     f"Makedirs called on relative filename: '{remote}'. Skipping."
   296|                 )
   297|             else:
   298|                 ret = self.exec_cmd("mkdir -p " + shlex.quote(pardir))
   299|                 if ret[2]:
   300|                     return ret
   301|         host = self.host
   302|         if ":" in host:
   303|             host = f"[{host}]"
   304|         cmd = f"{local} {host}:{remote}"
   305|         cmd = self._cmd_str(cmd, ssh="scp")
   306|         logmsg = f"Executing command: {cmd}"
   307|         if self.passwd:
   308|             logmsg = logmsg.replace(self.passwd, ("*" * 6))
   309|         log.debug(logmsg)
   310|         return self._run_cmd(cmd)
   311|     def _split_cmd(self, cmd):
   312|         """
   313|         Split a command string so that it is suitable to pass to Popen without
   314|         shell=True. This prevents shell injection attacks in the options passed
   315|         to ssh or some other command.
   316|         """
   317|         try:
   318|             ssh_part, cmd_part = cmd.split("/bin/sh")
   319|         except ValueError:
   320|             cmd_lst = shlex.split(cmd)
   321|         else:
   322|             cmd_lst = shlex.split(ssh_part)
   323|             cmd_lst.append(f"/bin/sh {cmd_part}")
   324|         return cmd_lst
   325|     def _run_cmd(self, cmd, key_accept=False, passwd_retries=3):


# ====================================================================
# FILE: salt/client/ssh/state.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 82-135 ---
    82|     stack = []
    83|     def __init__(
    84|         self,
    85|         opts,
    86|         pillar_override=None,
    87|         wrapper=None,
    88|         fsclient=None,
    89|         context=None,
    90|         initial_pillar=None,
    91|     ):
    92|         self.client = fsclient
    93|         salt.state.BaseHighState.__init__(self, opts)
    94|         self.state = SSHState(
    95|             opts,
    96|             pillar_override,
    97|             wrapper,
    98|             context=context,
    99|             initial_pillar=initial_pillar,
   100|         )
   101|         self.matchers = salt.loader.matchers(self.opts)
   102|         self._pydsl_all_decls = {}
   103|         self._pydsl_render_stack = []
   104|     def push_active(self):
   105|         salt.state.HighState.stack.append(self)
   106|     def load_dynamic(self, matches):
   107|         """
   108|         Stub out load_dynamic
   109|         """
   110|         return
   111|     def _master_tops(self):
   112|         """
   113|         Evaluate master_tops locally
   114|         """
   115|         return self._local_master_tops()
   116|     def destroy(self):
   117|         if self.client:
   118|             self.client.destroy()
   119|     def __enter__(self):
   120|         return self
   121|     def __exit__(self, *_):
   122|         self.destroy()
   123| def lowstate_file_refs(chunks, extras=""):
   124|     """
   125|     Create a list of file ref objects to reconcile
   126|     """
   127|     refs = {}
   128|     for chunk in chunks:
   129|         if not isinstance(chunk, dict):
   130|             continue
   131|         saltenv = "base"
   132|         crefs = []
   133|         for state in chunk:
   134|             if state == "__env__":
   135|                 saltenv = chunk[state]


# ====================================================================
# FILE: salt/client/ssh/wrapper/__init__.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-110 ---
     1| """
     2| The ssh client wrapper system contains the routines that are used to alter
     3| how executions are run in the salt-ssh system, this allows for state routines
     4| to be easily rewritten to execute in a way that makes them do the same tasks
     5| as ZeroMQ salt, but via ssh.
     6| """
     7| import copy
     8| import logging
     9| import salt.client.ssh
    10| import salt.loader
    11| import salt.utils.data
    12| import salt.utils.json
    13| from salt.defaults import NOT_SET
    14| from salt.exceptions import CommandExecutionError, SaltException
    15| log = logging.getLogger(__name__)
    16| class SSHException(SaltException):
    17|     """
    18|     Indicates general command failure via salt-ssh.
    19|     """
    20|     _error = ""
    21|     def __init__(
    22|         self, stdout, stderr, retcode, result=NOT_SET, parsed=None, *args, **kwargs
    23|     ):
    24|         super().__init__(stderr, *args, **kwargs)
    25|         self.stdout = stdout
    26|         self.stderr = self._filter_stderr(stderr)
    27|         self.result = result
    28|         self.parsed = parsed
    29|         self.retcode = retcode
    30|         if args:
    31|             self._error = args.pop(0)
    32|         super().__init__(self._error)
    33|     def _filter_stderr(self, stderr):
    34|         stderr_lines = []
    35|         skip_next = False
    36|         for line in stderr.splitlines():
    37|             if skip_next:
    38|                 skip_next = False
    39|                 continue
    40|             parts = line.split(":")
    41|             if len(parts) > 2 and "DeprecationWarning" in parts[2]:
    42|                 skip_next = True
    43|                 continue
    44|             stderr_lines.append(line)
    45|         return "\n".join(stderr_lines)
    46|     def to_ret(self):
    47|         ret = {
    48|             "stdout": self.stdout,
    49|             "stderr": self.stderr,
    50|             "retcode": self.retcode,
    51|             "parsed": self.parsed,
    52|         }
    53|         if self._error:
    54|             ret["_error"] = self._error
    55|         if self.result is not NOT_SET:
    56|             ret["return"] = self.result
    57|         return ret
    58| class SSHCommandExecutionError(SSHException, CommandExecutionError):
    59|     """
    60|     Thrown whenever a non-zero exit code is returned.
    61|     This was introduced to make the salt-ssh FunctionWrapper behave
    62|     more like the usual one, in particular to force template rendering
    63|     to stop when a function call results in an exception.
    64|     """
    65|     _error = "The command resulted in a non-zero exit code"
    66|     def to_ret(self):
    67|         if self.parsed and "local" in self.parsed:
    68|             return self.parsed["local"]
    69|         return super().to_ret()
    70|     def __str__(self):
    71|         ret = self.to_ret()
    72|         if self.retcode > 0:
    73|             return f"{self._error}: {self.stderr or self.stdout}"
    74|         return self._error
    75| class SSHPermissionDeniedError(SSHException):
    76|     """
    77|     Thrown when "Permission denied" is found in stderr
    78|     """
    79|     _error = "Permission denied"
    80| class SSHReturnDecodeError(SSHException):
    81|     """
    82|     Thrown when JSON-decoding stdout fails and the retcode is 0 otherwise
    83|     """
    84|     _error = "Failed to return clean data"
    85| class SSHMalformedReturnError(SSHException):
    86|     """
    87|     Thrown when a decoded return dict is not formed as
    88|     {"local": {"return": ...}}
    89|     """
    90|     _error = "Return dict was malformed"
    91| class FunctionWrapper:
    92|     """
    93|     Create an object that acts like the salt function dict and makes function
    94|     calls remotely via the SSH shell system
    95|     """
    96|     def __init__(
    97|         self,
    98|         opts,
    99|         id_,
   100|         host,
   101|         wfuncs=None,
   102|         mods=None,
   103|         fsclient=None,
   104|         cmd_prefix=None,
   105|         aliases=None,
   106|         minion_opts=None,
   107|         **kwargs,
   108|     ):
   109|         super().__init__()
   110|         self.cmd_prefix = cmd_prefix

# --- HUNK 2: Lines 162-262 ---
   162|             argv = [cmd]
   163|             argv.extend([salt.utils.json.dumps(arg) for arg in args])
   164|             argv.extend(
   165|                 [
   166|                     "{}={}".format(
   167|                         salt.utils.stringutils.to_str(key), salt.utils.json.dumps(val)
   168|                     )
   169|                     for key, val in kwargs.items()
   170|                 ]
   171|             )
   172|             single = salt.client.ssh.Single(
   173|                 self.opts,
   174|                 argv,
   175|                 mods=self.mods,
   176|                 disable_wipe=True,
   177|                 fsclient=self.fsclient,
   178|                 minion_opts=self.minion_opts,
   179|                 **self.kwargs,
   180|             )
   181|             stdout, stderr, retcode = single.cmd_block()
   182|             return parse_ret(stdout, stderr, retcode, result_only=True)
   183|         return caller
   184|     def __setitem__(self, cmd, value):
   185|         """
   186|         Set aliases for functions
   187|         """
   188|         if "." not in cmd and not self.cmd_prefix:
   189|             raise KeyError(f"Cannot assign to module key {cmd} in the FunctionWrapper")
   190|         if self.cmd_prefix:
   191|             cmd = f"{self.cmd_prefix}.{cmd}"
   192|         if cmd in self.wfuncs:
   193|             self.wfuncs[cmd] = value
   194|         self.aliases[cmd] = value
   195|     def get(self, cmd, default):
   196|         """
   197|         Mirrors behavior of dict.get
   198|         """
   199|         if cmd in self:
   200|             return self[cmd]
   201|         else:
   202|             return default
   203| def parse_ret(stdout, stderr, retcode, result_only=False):
   204|     """
   205|     Parse the output of a remote or local command and return its
   206|     result. Raise exceptions if the command has a non-zero exitcode
   207|     or its output is not valid JSON or is not in the expected format,
   208|     usually ``{"local": {"return": value}}`` (+ optional keys in the "local" dict).
   209|     """
   210|     try:
   211|         retcode = int(retcode)
   212|     except (TypeError, ValueError):
   213|         log.warning(f"Got an invalid retcode for host: '{retcode}'")
   214|         retcode = 1
   215|     if "Permission denied" in stderr:
   216|         ignore_err = ["failed to upload file"]
   217|         check_err = [x for x in ignore_err if stderr.count(x)]
   218|         if not check_err:
   219|             raise SSHPermissionDeniedError(
   220|                 stdout=stdout, stderr=stderr, retcode=retcode
   221|             )
   222|     result = NOT_SET
   223|     error = None
   224|     data = None
   225|     try:
   226|         data = salt.utils.json.find_json(stdout)
   227|     except ValueError:
   228|         error = SSHReturnDecodeError
   229|     else:
   230|         if isinstance(data, dict) and len(data) < 2 and "local" in data:
   231|             result = data["local"]
   232|             try:
   233|                 remote_retcode = result["retcode"]
   234|             except (KeyError, TypeError):
   235|                 pass
   236|             else:
   237|                 try:
   238|                     retcode = max(retcode, remote_retcode)
   239|                 except (TypeError, ValueError):
   240|                     log.warning(f"Host reported an invalid retcode: '{remote_retcode}'")
   241|                     retcode = max(retcode, 1)
   242|             if not isinstance(result, dict):
   243|                 error = SSHCommandExecutionError
   244|             elif result_only:
   245|                 try:
   246|                     result = result["return"]
   247|                 except KeyError:
   248|                     error = SSHMalformedReturnError
   249|                     result = NOT_SET
   250|         else:
   251|             error = SSHMalformedReturnError
   252|     if retcode:
   253|         error = SSHCommandExecutionError
   254|     if error is not None:
   255|         raise error(
   256|             stdout=stdout,
   257|             stderr=stderr,
   258|             retcode=retcode,
   259|             result=result,
   260|             parsed=data,
   261|         )
   262|     return result


# ====================================================================
# FILE: salt/client/ssh/wrapper/cmdmod.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-418 ---
     1| """
     2| SSH wrapper module for the ``cmdmod`` execution module.
     3| .. note::
     4|     For consistency reasons, this wrapper currently does
     5|     not behave the same as the execution module regarding ``saltenv``.
     6|     The parameter defaults to ``base``, regardless of the current
     7|     value of the minion setting.
     8|     This is the same for the ``state`` and `cp`` wrappers.
     9| """
    10| import logging
    11| import os.path
    12| import shlex
    13| import salt.utils.url
    14| from salt.exceptions import CommandExecutionError, SaltInvocationError
    15| from salt.modules.cmdmod import _python_shell_default
    16| log = logging.getLogger(__name__)
    17| __virtualname__ = "cmd"
    18| def __virtual__():
    19|     return __virtualname__
    20| def script(
    21|     source,
    22|     args=None,
    23|     cwd=None,
    24|     stdin=None,
    25|     runas=None,
    26|     group=None,
    27|     shell=None,
    28|     python_shell=None,
    29|     env=None,
    30|     template=None,
    31|     umask=None,
    32|     output_encoding=None,
    33|     output_loglevel="debug",
    34|     log_callback=None,
    35|     hide_output=False,
    36|     timeout=None,
    37|     reset_system_locale=True,
    38|     saltenv="base",
    39|     use_vt=False,
    40|     bg=False,
    41|     password=None,
    42|     success_retcodes=None,
    43|     success_stdout=None,
    44|     success_stderr=None,
    45|     **kwargs
    46| ):
    47|     """
    48|     Download a script from a remote location and execute the script locally.
    49|     The script can be located on the salt master file server or on an HTTP/FTP
    50|     server.
    51|     The script will be executed directly, so it can be written in any available
    52|     programming language.
    53|     :param str source: The location of the script to download. If the file is
    54|         located on the master in the directory named spam, and is called eggs,
    55|         the source string is salt://spam/eggs
    56|     :param str args: String of command line args to pass to the script. Only
    57|         used if no args are specified as part of the `name` argument. To pass a
    58|         string containing spaces in YAML, you will need to doubly-quote it:
    59|         .. code-block:: bash
    60|             salt myminion cmd.script salt://foo.sh "arg1 'arg two' arg3"
    61|     :param str cwd: The directory from which to execute the command. Defaults
    62|         to the directory returned from Python's tempfile.mkstemp.
    63|     :param str stdin: A string of standard input can be specified for the
    64|         command to be run using the ``stdin`` parameter. This can be useful in
    65|         cases where sensitive information must be read from standard input.
    66|     :param str runas: Specify an alternate user to run the command. The default
    67|         behavior is to run as the user under which Salt is running. If running
    68|         on a Windows minion you must also use the ``password`` argument, and
    69|         the target user account must be in the Administrators group.
    70|         .. note::
    71|             For Window's users, specifically Server users, it may be necessary
    72|             to specify your runas user using the User Logon Name instead of the
    73|             legacy logon name. Traditionally, logons would be in the following
    74|             format.
    75|                 ``Domain/user``
    76|             In the event this causes issues when executing scripts, use the UPN
    77|             format which looks like the following.
    78|                 ``user@domain.local``
    79|             More information <https://github.com/saltstack/salt/issues/55080>
    80|     :param str password: Windows only. Required when specifying ``runas``. This
    81|         parameter will be ignored on non-Windows platforms.
    82|         .. versionadded:: 2016.3.0
    83|     :param str group: Group to run script as. Not currently supported
    84|       on Windows.
    85|     :param str shell: Specify an alternate shell. Defaults to the system's
    86|         default shell.
    87|     :param bool python_shell: If False, let python handle the positional
    88|         arguments. Set to True to use shell features, such as pipes or
    89|         redirection.
    90|     :param bool bg: If True, run script in background and do not await or
    91|         deliver its results
    92|     :param dict env: Environment variables to be set prior to execution.
    93|         .. note::
    94|             When passing environment variables on the CLI, they should be
    95|             passed as the string representation of a dictionary.
    96|             .. code-block:: bash
    97|                 salt myminion cmd.script 'some command' env='{"FOO": "bar"}'
    98|         .. note::
    99|             When using environment variables on Window's, case-sensitivity
   100|             matters, i.e. Window's uses `Path` as opposed to `PATH` for other
   101|             systems.
   102|     :param str template: If this setting is applied then the named templating
   103|         engine will be used to render the downloaded file. Currently jinja,
   104|         mako, and wempy are supported.
   105|     :param str umask: The umask (in octal) to use when running the command.
   106|     :param str output_encoding: Control the encoding used to decode the
   107|         command's output.
   108|         .. note::
   109|             This should not need to be used in most cases. By default, Salt
   110|             will try to use the encoding detected from the system locale, and
   111|             will fall back to UTF-8 if this fails. This should only need to be
   112|             used in cases where the output of the command is encoded in
   113|             something other than the system locale or UTF-8.
   114|             To see the encoding Salt has detected from the system locale, check
   115|             the `locale` line in the output of :py:func:`test.versions_report
   116|             <salt.modules.test.versions_report>`.
   117|         .. versionadded:: 2018.3.0
   118|     :param str output_loglevel: Control the loglevel at which the output from
   119|         the command is logged to the minion log.
   120|         .. note::
   121|             The command being run will still be logged at the ``debug``
   122|             loglevel regardless, unless ``quiet`` is used for this value.
   123|     :param bool ignore_retcode: If the exit code of the command is nonzero,
   124|         this is treated as an error condition, and the output from the command
   125|         will be logged to the minion log. However, there are some cases where
   126|         programs use the return code for signaling and a nonzero exit code
   127|         doesn't necessarily mean failure. Pass this argument as ``True`` to
   128|         skip logging the output if the command has a nonzero exit code.
   129|     :param bool hide_output: If ``True``, suppress stdout and stderr in the
   130|         return data.
   131|         .. note::
   132|             This is separate from ``output_loglevel``, which only handles how
   133|             Salt logs to the minion log.
   134|         .. versionadded:: 2018.3.0
   135|     :param int timeout: If the command has not terminated after timeout
   136|         seconds, send the subprocess sigterm, and if sigterm is ignored, follow
   137|         up with sigkill
   138|     :param bool use_vt: Not supported via salt-ssh.
   139|     :param list success_retcodes: This parameter will allow a list of
   140|         non-zero return codes that should be considered a success.  If the
   141|         return code returned from the run matches any in the provided list,
   142|         the return code will be overridden with zero.
   143|       .. versionadded:: 2019.2.0
   144|     :param list success_stdout: This parameter will allow a list of
   145|         strings that when found in standard out should be considered a success.
   146|         If stdout returned from the run matches any in the provided list,
   147|         the return code will be overridden with zero.
   148|       .. versionadded:: 3004
   149|     :param list success_stderr: This parameter will allow a list of
   150|         strings that when found in standard error should be considered a success.
   151|         If stderr returned from the run matches any in the provided list,
   152|         the return code will be overridden with zero.
   153|       .. versionadded:: 3004
   154|     :param bool stdin_raw_newlines: False
   155|         If ``True``, Salt will not automatically convert the characters ``\\n``
   156|         present in the ``stdin`` value to newlines.
   157|       .. versionadded:: 2019.2.0
   158|     CLI Example:
   159|     .. code-block:: bash
   160|         salt '*' cmd.script salt://scripts/runme.sh
   161|         salt '*' cmd.script salt://scripts/runme.sh 'arg1 arg2 "arg 3"'
   162|         salt '*' cmd.script salt://scripts/windows_task.ps1 args=' -Input c:\\tmp\\infile.txt' shell='powershell'
   163|     .. code-block:: bash
   164|         salt '*' cmd.script salt://scripts/runme.sh stdin='one\\ntwo\\nthree\\nfour\\nfive\\n'
   165|     """
   166|     def _cleanup_tempfile(path):
   167|         try:
   168|             __salt__["file.remove"](path)
   169|         except (SaltInvocationError, CommandExecutionError) as exc:
   170|             log.error(
   171|                 "cmd.script: Unable to clean tempfile '%s': %s",
   172|                 path,
   173|                 exc,
   174|                 exc_info_on_loglevel=logging.DEBUG,
   175|             )
   176|     if shell is None:
   177|         shell = __grains__.get("shell", "/bin/sh")
   178|     python_shell = _python_shell_default(python_shell, kwargs.get("__pub_jid", ""))
   179|     if "__env__" in kwargs:
   180|         kwargs.pop("__env__")
   181|     path = __salt__["temp.file"](
   182|         suffix=os.path.splitext(salt.utils.url.split_env(source)[0])[1], parent=cwd
   183|     )
   184|     try:
   185|         if template:
   186|             if "pillarenv" in kwargs or "pillar" in kwargs:
   187|                 pillarenv = kwargs.get("pillarenv", __opts__.get("pillarenv"))
   188|                 kwargs["pillar"] = _gather_pillar(pillarenv, kwargs.get("pillar"))
   189|             fn_ = __salt__["cp.get_template"](source, path, template, saltenv, **kwargs)
   190|             if not fn_:
   191|                 _cleanup_tempfile(path)
   192|                 return {
   193|                     "pid": 0,
   194|                     "retcode": 1,
   195|                     "stdout": "",
   196|                     "stderr": "",
   197|                     "cache_error": True,
   198|                 }
   199|         else:
   200|             fn_ = __salt__["cp.cache_file"](source, saltenv)
   201|             if not fn_:
   202|                 _cleanup_tempfile(path)
   203|                 return {
   204|                     "pid": 0,
   205|                     "retcode": 1,
   206|                     "stdout": "",
   207|                     "stderr": "",
   208|                     "cache_error": True,
   209|                 }
   210|             __salt__["file.copy"](fn_, path)
   211|         __salt__["file.set_mode"](path, "0500")
   212|         __salt__["file.chown"](path, runas, -1)
   213|         cmd_path = shlex.quote(path)
   214|         kwargs.pop("pillar", None)
   215|         return __salt__["cmd.run_all"](
   216|             cmd_path + " " + str(args) if args else cmd_path,
   217|             cwd=cwd,
   218|             stdin=stdin,
   219|             output_encoding=output_encoding,
   220|             output_loglevel=output_loglevel,
   221|             log_callback=log_callback,
   222|             runas=runas,
   223|             group=group,
   224|             shell=shell,
   225|             python_shell=python_shell,
   226|             env=env,
   227|             umask=umask,
   228|             timeout=timeout,
   229|             reset_system_locale=reset_system_locale,
   230|             saltenv=saltenv,
   231|             use_vt=False,
   232|             bg=bg,
   233|             password=password,
   234|             success_retcodes=success_retcodes,
   235|             success_stdout=success_stdout,
   236|             success_stderr=success_stderr,
   237|             hide_output=hide_output,
   238|             **kwargs
   239|         )
   240|     finally:
   241|         _cleanup_tempfile(path)
   242| def script_retcode(
   243|     source,
   244|     args=None,
   245|     cwd=None,
   246|     stdin=None,
   247|     runas=None,
   248|     group=None,
   249|     shell=None,
   250|     python_shell=None,
   251|     env=None,
   252|     template="jinja",
   253|     umask=None,
   254|     timeout=None,
   255|     reset_system_locale=True,
   256|     saltenv="base",
   257|     output_encoding=None,
   258|     output_loglevel="debug",
   259|     log_callback=None,
   260|     use_vt=False,
   261|     password=None,
   262|     success_retcodes=None,
   263|     success_stdout=None,
   264|     success_stderr=None,
   265|     **kwargs
   266| ):
   267|     """
   268|     Download a script from a remote location and execute the script locally.
   269|     The script can be located on the salt master file server or on an HTTP/FTP
   270|     server.
   271|     The script will be executed directly, so it can be written in any available
   272|     programming language.
   273|     The script can also be formatted as a template, the default is jinja.
   274|     Only evaluate the script return code and do not block for terminal output
   275|     :param str source: The location of the script to download. If the file is
   276|         located on the master in the directory named spam, and is called eggs,
   277|         the source string is salt://spam/eggs
   278|     :param str args: String of command line args to pass to the script. Only
   279|         used if no args are specified as part of the `name` argument. To pass a
   280|         string containing spaces in YAML, you will need to doubly-quote it:
   281|         "arg1 'arg two' arg3"
   282|     :param str cwd: The directory from which to execute the command. Defaults
   283|         to the home directory of the user specified by ``runas`` (or the user
   284|         under which Salt is running if ``runas`` is not specified).
   285|     :param str stdin: A string of standard input can be specified for the
   286|         command to be run using the ``stdin`` parameter. This can be useful in
   287|         cases where sensitive information must be read from standard input.
   288|     :param str runas: Specify an alternate user to run the command. The default
   289|         behavior is to run as the user under which Salt is running. If running
   290|         on a Windows minion you must also use the ``password`` argument, and
   291|         the target user account must be in the Administrators group.
   292|     :param str password: Windows only. Required when specifying ``runas``. This
   293|         parameter will be ignored on non-Windows platforms.
   294|         .. versionadded:: 2016.3.0
   295|     :param str group: Group to run script as. Not currently supported
   296|       on Windows.
   297|     :param str shell: Specify an alternate shell. Defaults to the system's
   298|         default shell.
   299|     :param bool python_shell: If False, let python handle the positional
   300|         arguments. Set to True to use shell features, such as pipes or
   301|         redirection.
   302|     :param dict env: Environment variables to be set prior to execution.
   303|         .. note::
   304|             When passing environment variables on the CLI, they should be
   305|             passed as the string representation of a dictionary.
   306|             .. code-block:: bash
   307|                 salt myminion cmd.script_retcode 'some command' env='{"FOO": "bar"}'
   308|         .. note::
   309|             When using environment variables on Window's, case-sensitivity
   310|             matters, i.e. Window's uses `Path` as opposed to `PATH` for other
   311|             systems.
   312|     :param str template: If this setting is applied then the named templating
   313|         engine will be used to render the downloaded file. Currently jinja,
   314|         mako, and wempy are supported.
   315|     :param str umask: The umask (in octal) to use when running the command.
   316|     :param str output_encoding: Control the encoding used to decode the
   317|         command's output.
   318|         .. note::
   319|             This should not need to be used in most cases. By default, Salt
   320|             will try to use the encoding detected from the system locale, and
   321|             will fall back to UTF-8 if this fails. This should only need to be
   322|             used in cases where the output of the command is encoded in
   323|             something other than the system locale or UTF-8.
   324|             To see the encoding Salt has detected from the system locale, check
   325|             the `locale` line in the output of :py:func:`test.versions_report
   326|             <salt.modules.test.versions_report>`.
   327|         .. versionadded:: 2018.3.0
   328|     :param str output_loglevel: Control the loglevel at which the output from
   329|         the command is logged to the minion log.
   330|         .. note::
   331|             The command being run will still be logged at the ``debug``
   332|             loglevel regardless, unless ``quiet`` is used for this value.
   333|     :param bool ignore_retcode: If the exit code of the command is nonzero,
   334|         this is treated as an error condition, and the output from the command
   335|         will be logged to the minion log. However, there are some cases where
   336|         programs use the return code for signaling and a nonzero exit code
   337|         doesn't necessarily mean failure. Pass this argument as ``True`` to
   338|         skip logging the output if the command has a nonzero exit code.
   339|     :param int timeout: If the command has not terminated after timeout
   340|         seconds, send the subprocess sigterm, and if sigterm is ignored, follow
   341|         up with sigkill
   342|     :param bool use_vt: Use VT utils (saltstack) to stream the command output
   343|         more interactively to the console and the logs. This is experimental.
   344|     :param list success_retcodes: This parameter will allow a list of
   345|         non-zero return codes that should be considered a success.  If the
   346|         return code returned from the run matches any in the provided list,
   347|         the return code will be overridden with zero.
   348|       .. versionadded:: 2019.2.0
   349|     :param list success_stdout: This parameter will allow a list of
   350|         strings that when found in standard out should be considered a success.
   351|         If stdout returned from the run matches any in the provided list,
   352|         the return code will be overridden with zero.
   353|       .. versionadded:: 3004
   354|     :param list success_stderr: This parameter will allow a list of
   355|         strings that when found in standard error should be considered a success.
   356|         If stderr returned from the run matches any in the provided list,
   357|         the return code will be overridden with zero.
   358|       .. versionadded:: 3004
   359|     :param bool stdin_raw_newlines: False
   360|         If ``True``, Salt will not automatically convert the characters ``\\n``
   361|         present in the ``stdin`` value to newlines.
   362|       .. versionadded:: 2019.2.0
   363|     CLI Example:
   364|     .. code-block:: bash
   365|         salt '*' cmd.script_retcode salt://scripts/runme.sh
   366|         salt '*' cmd.script_retcode salt://scripts/runme.sh 'arg1 arg2 "arg 3"'
   367|         salt '*' cmd.script_retcode salt://scripts/windows_task.ps1 args=' -Input c:\\tmp\\infile.txt' shell='powershell'
   368|     A string of standard input can be specified for the command to be run using
   369|     the ``stdin`` parameter. This can be useful in cases where sensitive
   370|     information must be read from standard input.
   371|     .. code-block:: bash
   372|         salt '*' cmd.script_retcode salt://scripts/runme.sh stdin='one\\ntwo\\nthree\\nfour\\nfive\\n'
   373|     """
   374|     if "__env__" in kwargs:
   375|         kwargs.pop("__env__")
   376|     return script(
   377|         source=source,
   378|         args=args,
   379|         cwd=cwd,
   380|         stdin=stdin,
   381|         runas=runas,
   382|         group=group,
   383|         shell=shell,
   384|         python_shell=python_shell,
   385|         env=env,
   386|         template=template,
   387|         umask=umask,
   388|         timeout=timeout,
   389|         reset_system_locale=reset_system_locale,
   390|         saltenv=saltenv,
   391|         output_encoding=output_encoding,
   392|         output_loglevel=output_loglevel,
   393|         log_callback=log_callback,
   394|         use_vt=use_vt,
   395|         password=password,
   396|         success_retcodes=success_retcodes,
   397|         success_stdout=success_stdout,
   398|         success_stderr=success_stderr,
   399|         **kwargs
   400|     )["retcode"]
   401| def _gather_pillar(pillarenv, pillar_override):
   402|     """
   403|     The opts used during pillar rendering should contain the master
   404|     opts in the root namespace. self.opts is the modified minion opts,
   405|     containing the original master opts in __master_opts__.
   406|     """
   407|     popts = {}
   408|     popts.update(__opts__)
   409|     popts.update(__opts__.get("__master_opts__", {}))
   410|     pillar = salt.pillar.get_pillar(
   411|         popts,
   412|         __grains__.value(),
   413|         __salt__.kwargs["id_"],
   414|         __opts__["saltenv"] or "base",
   415|         pillar_override=pillar_override,
   416|         pillarenv=pillarenv,
   417|     )
   418|     return pillar.compile_pillar()


# ====================================================================
# FILE: salt/client/ssh/wrapper/cp.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-909 ---
     1| """
     2| Wrap the ``cp`` module allowing for managed SSH file transfers.
     3| This module works by keeping a cachedir per SSH minion on the master.
     4| Requested files are first cached there and afterwards replicated to
     5| the minion using ``scp``. The returned paths will point to files in
     6| the remote cachedir. You can convert these paths to the local ones
     7| by calling ``cp.convert_cache_path``, which is a function unique
     8| to the wrapper.
     9| .. note::
    10|     This wrapper currently has several limitations:
    11|     * Replication will always be performed, even if the file exists
    12|       in the minion cache dir in the correct state (no hash checks).
    13|     * Even non-``salt://`` URIs will be fetched by the master node
    14|       first in order for other wrappers to be able to employ this
    15|       one for fetching remotes.
    16|     * When replicating directories, they are currently not sent as
    17|       a tar archive, but file per file, which is very inefficient.
    18|     * You cannot transfer files from the minion to the master-side
    19|       SSH minion cache, they will only be available on the remote.
    20| .. note::
    21|     For backwards-compatibility reasons, this wrapper currently does
    22|     not behave the same as the execution module regarding ``saltenv``.
    23|     The parameter defaults to ``base``, regardless of the current
    24|     value of the minion setting.
    25| """
    26| import logging
    27| import os
    28| import shlex
    29| import urllib.parse
    30| from pathlib import Path
    31| import salt.client.ssh
    32| import salt.fileclient
    33| import salt.utils.files
    34| import salt.utils.stringutils
    35| import salt.utils.templates
    36| from salt.exceptions import CommandExecutionError
    37| log = logging.getLogger(__name__)
    38| def _client():
    39|     ckey = "_cp_shell"
    40|     if ckey not in __context__:
    41|         single = salt.client.ssh.Single(__opts__, "", **__salt__.kwargs)
    42|         __context__[ckey] = single.shell
    43|     return SSHCpClient(
    44|         __context__["fileclient"].opts, __context__[ckey], __salt__.kwargs["id_"]
    45|     )
    46| def get_file(path, dest, saltenv="base", makedirs=False, template=None, **kwargs):
    47|     """
    48|     Send a file from the fileserver to the specified location.
    49|     CLI Example:
    50|     .. code-block:: bash
    51|         salt-ssh '*' cp.get_file salt://path/to/file /minion/dest
    52|     path
    53|         The path on the fileserver, like ``salt://foo/bar.conf``. It is possible
    54|         to specify the ``saltenv`` using the querystring syntax:
    55|         ``salt://foo/bar.conf?saltenv=config``
    56|     dest
    57|         The absolute path to transfer the file to on the minion. If empty,
    58|         the file will be cached in the minion's cache dir, under
    59|         ``files/<saltenv>/<path>``.
    60|     saltenv
    61|         Salt fileserver environment from which to retrieve the file.
    62|         Defaults to ``base``.
    63|     makedirs
    64|         Whether to create the parent directories for ``dest`` as needed.
    65|         Defaults to false.
    66|     template
    67|         If ``path`` and ``dest`` parameters should be interpreted as templates,
    68|         the name of the renderer to use.
    69|         Template rendering can be enabled on both ``path`` and
    70|         ``dest`` file paths like so:
    71|         .. code-block:: bash
    72|             salt-ssh '*' cp.get_file "salt://{{grains.os}}/vimrc" /etc/vimrc template=jinja
    73|     Additional keyword arguments are passed through to the renderer, otherwise discarded.
    74|     .. note::
    75|         It may be necessary to quote the URL when using the querystring method,
    76|         depending on the shell being used to run the command.
    77|     .. note::
    78|         gzip compression is not supported in the salt-ssh version of
    79|         ``cp.get_file``.
    80|     """
    81|     gzip = kwargs.pop("gzip", None)
    82|     if gzip is not None:
    83|         log.warning("The gzip argument to cp.get_file in salt-ssh is unsupported")
    84|     (path, dest) = _render_filenames(path, dest, saltenv, template, **kwargs)
    85|     path, senv = salt.utils.url.split_env(path)
    86|     if senv:
    87|         saltenv = senv
    88|     if not hash_file(path, saltenv):
    89|         return ""
    90|     else:
    91|         with _client() as client:
    92|             ret = client.get_file(path, dest, makedirs, saltenv)
    93|             if not ret:
    94|                 return ret
    95|             return client.target_map[ret]
    96| def envs():
    97|     """
    98|     List available fileserver environments.
    99|     CLI Example:
   100|     .. code-block:: bash
   101|         salt-ssh '*' cp.envs
   102|     """
   103|     return __context__["fileclient"].envs()
   104| def get_template(
   105|     path, dest, template="jinja", saltenv="base", makedirs=False, **kwargs
   106| ):
   107|     """
   108|     Render a file as a template before writing it.
   109|     CLI Example:
   110|     .. code-block:: bash
   111|         salt '*' cp.get_template salt://path/to/template /minion/dest
   112|     path
   113|         The path on the fileserver, like ``salt://foo/bar.conf``. It is possible
   114|         to specify the ``saltenv`` using the querystring syntax:
   115|         ``salt://foo/bar.conf?saltenv=config``
   116|     dest
   117|         The absolute path to transfer the file to on the minion. If empty,
   118|         the rendered template will be cached in the minion's cache dir,
   119|         under ``extrn_files/<saltenv>/<path>``.
   120|     template
   121|         The renderer to use for rendering the template. Defaults to ``jinja``.
   122|     saltenv
   123|         The saltenv the template should be pulled from. Defaults to ``base``.
   124|     makedirs
   125|         Whether to create the parent directories for ``dest`` as needed.
   126|         Defaults to false.
   127|     Additional keyword arguments are passed verbatim to the renderer.
   128|     """
   129|     if "salt" not in kwargs:
   130|         kwargs["salt"] = __salt__.value()
   131|     if "pillar" not in kwargs:
   132|         kwargs["pillar"] = __pillar__.value()
   133|     if "grains" not in kwargs:
   134|         kwargs["grains"] = __grains__.value()
   135|     if "opts" not in kwargs:
   136|         kwargs["opts"] = __opts__
   137|     with _client() as client:
   138|         ret = client.get_template(path, dest, template, makedirs, saltenv, **kwargs)
   139|         if not ret:
   140|             return ret
   141|         return client.target_map[ret]
   142| def get_dir(path, dest, saltenv="base", template=None, **kwargs):
   143|     """
   144|     Recursively transfer a directory from the fileserver to the minion.
   145|     .. note::
   146|         This can take a long time since each file is transferred separately
   147|         currently.
   148|     CLI Example:
   149|     .. code-block:: bash
   150|         salt-ssh '*' cp.get_dir salt://path/to/dir/ /minion/dest
   151|     path
   152|         The path on the fileserver, like ``salt://foo/bar/``. It is possible
   153|         to specify the ``saltenv`` using the querystring syntax:
   154|         ``salt://foo/bar?saltenv=config``
   155|     dest
   156|         The absolute path to transfer the directory to on the minion. If empty,
   157|         the directory will be cached in the minion's cache dir, under
   158|         ``files/<saltenv>/<path>``. Note that parent directories will
   159|         be created as required automatically.
   160|     saltenv
   161|         Salt fileserver environment from which to retrieve the directory.
   162|         Defaults to ``base``.
   163|     template
   164|         If ``path`` and ``dest`` parameters should be interpreted as templates,
   165|         the name of the renderer to use.
   166|     .. note::
   167|         gzip compression is not supported in the salt-ssh version of
   168|         cp.get_dir. The argument is only accepted for interface compatibility.
   169|     """
   170|     gzip = kwargs.pop("gzip", None)
   171|     if gzip is not None:
   172|         log.warning("The gzip argument to cp.get_dir in salt-ssh is unsupported")
   173|     (path, dest) = _render_filenames(path, dest, saltenv, template, **kwargs)
   174|     with _client() as client:
   175|         ret = client.get_dir(path, dest, saltenv, gzip)
   176|         if not ret:
   177|             return ret
   178|         return [client.target_map[x] for x in ret]
   179| def get_url(path, dest="", saltenv="base", makedirs=False, source_hash=None):
   180|     """
   181|     Retrieve a single file from a URL.
   182|     path
   183|         A URL to download a file from. Supported URL schemes are: ``salt://``,
   184|         ``http://``, ``https://``, ``ftp://``, ``s3://``, ``swift://`` and
   185|         ``file://`` (local filesystem). If no scheme was specified, this is
   186|         equivalent of using ``file://``.
   187|         If a ``file://`` URL is given, the function just returns absolute path
   188|         to that file on a local filesystem.
   189|         The function returns ``False`` if Salt was unable to fetch a file from
   190|         a ``salt://`` URL.
   191|         .. note::
   192|             The file:// scheme is currently only partially supported in salt-ssh.
   193|             It behaves the same as the unwrapped ``cp.get_url`` if dest is not
   194|             ``None``, but returning its contents will fail. Use ``get_file_str``
   195|             as a workaround for text files.
   196|     dest
   197|         The destination to write the cached file to. If empty, will cache the file
   198|         in the minion's cache dir under ``extrn_files/<saltenv>/<hostname>/<path>``.
   199|         Defaults to empty (i.e. caching the file).
   200|         .. note::
   201|             To simply return the file contents instead, set destination to
   202|             ``None``. This works with ``salt://``, ``http://`` and ``https://``
   203|             URLs. The files fetched by ``http://`` and ``https://`` will not
   204|             be cached.
   205|     saltenv
   206|         Salt fileserver environment from which to retrieve the file. Ignored if
   207|         ``path`` is not a ``salt://`` URL. Defaults to ``base``.
   208|     makedirs
   209|         Whether to create the parent directories for ``dest`` as needed.
   210|         Defaults to false.
   211|     source_hash
   212|         If ``path`` is an http(s) or ftp URL and the file exists in the
   213|         minion's file cache, this option can be passed to keep the minion from
   214|         re-downloading the file if the cached copy matches the specified hash.
   215|     """
   216|     with _client() as client:
   217|         if isinstance(dest, str):
   218|             result = client.get_url(
   219|                 path, dest, makedirs, saltenv, source_hash=source_hash
   220|             )
   221|         else:
   222|             result = client.get_url(
   223|                 path, None, makedirs, saltenv, no_cache=True, source_hash=source_hash
   224|             )
   225|         if not result:
   226|             log.error(
   227|                 "Unable to fetch file %s from saltenv %s.",
   228|                 salt.utils.url.redact_http_basic_auth(path),
   229|                 saltenv,
   230|             )
   231|             return result
   232|         if isinstance(dest, str):
   233|             result = client.target_map[result]
   234|         return salt.utils.stringutils.to_unicode(result)
   235| def get_file_str(path, saltenv="base"):
   236|     """
   237|     Download a file from a URL to the Minion cache directory and return the
   238|     contents of that file.
   239|     Returns ``False`` if Salt was unable to cache a file from a URL.
   240|     CLI Example:
   241|     .. code-block:: bash
   242|         salt-ssh '*' cp.get_file_str salt://my/file
   243|     path
   244|         The path on the fileserver, like ``salt://foo/bar/``. It is possible
   245|         to specify the ``saltenv`` using the querystring syntax:
   246|         ``salt://foo/bar?saltenv=config``
   247|     saltenv
   248|         Salt fileserver environment from which to retrieve the file.
   249|     """
   250|     fn_ = cache_file(path, saltenv)
   251|     if isinstance(fn_, str):
   252|         try:
   253|             with salt.utils.files.fopen(fn_, "r") as fp_:
   254|                 return salt.utils.stringutils.to_unicode(fp_.read())
   255|         except OSError:
   256|             return False
   257|     return fn_
   258| def cache_file(path, saltenv="base", source_hash=None, verify_ssl=True, use_etag=False):
   259|     """
   260|     Cache a single file on the Minion.
   261|     Returns the location of the new cached file on the Minion.
   262|     If the path being cached is a ``salt://`` URI, and the path does not exist,
   263|     then ``False`` will be returned.
   264|     If the path refers to a fileserver path (``salt://`` URI) and this is a state run,
   265|     the file will also be added to the package of files that's sent to the minion
   266|     for executing the state run (this behaves like ``extra_filerefs``).
   267|     CLI Example:
   268|     .. code-block:: bash
   269|         salt-ssh '*' cp.cache_file salt://path/to/file
   270|     path
   271|         The path on the fileserver, like ``salt://foo/bar/``. It is possible
   272|         to specify the ``saltenv`` using the querystring syntax:
   273|         ``salt://foo/bar?saltenv=config``
   274|     saltenv
   275|         Salt fileserver environment from which to retrieve the file. Ignored if
   276|         ``path`` is not a ``salt://`` URL. Defaults to ``base``.
   277|     source_hash
   278|         If ``name`` is an http(s) or ftp URL and the file exists in the
   279|         minion's file cache, this option can be passed to keep the minion from
   280|         re-downloading the file if the cached copy matches the specified hash.
   281|         .. versionadded:: 2018.3.0
   282|     verify_ssl
   283|         If ``False``, remote https file sources (``https://``) and source_hash
   284|         will not attempt to validate the servers certificate. Default is True.
   285|         .. versionadded:: 3002
   286|     use_etag
   287|         If ``True``, remote http/https file sources will attempt to use the
   288|         ETag header to determine if the remote file needs to be downloaded.
   289|         This provides a lightweight mechanism for promptly refreshing files
   290|         changed on a web server without requiring a full hash comparison via
   291|         the ``source_hash`` parameter.
   292|         .. versionadded:: 3005
   293|     .. note::
   294|         You can instrumentalize this function in your ``sls`` files to workaround a
   295|         limitation in how ``salt-ssh`` handles Jinja imports:
   296|         Imports in templates that will be rendered on the minion (usually during
   297|         ``file.managed`` calls) will fail since the corresponding file is not
   298|         sent to the minion by default.
   299|         By caching it explicitly in your states, you can ensure it will be included
   300|         in the filerefs that will be sent to the minion.
   301|         .. code-block:: jinja
   302|             {%- do salt["cp.cache_file"]("salt://my/map.jinja") %}
   303|             Serialize config:
   304|               file.managed:
   305|                 - name: /etc/my/config.conf
   306|                 - source: salt://my/files/config.conf.j2
   307|                 - template: jinja
   308|             {%- from "my/map.jinja" import mapdata with context %}
   309|             myconf = {{ mapdata["foo"] }}
   310|             {%- set mapdata = {"foo": "bar"} %}
   311|     """
   312|     path = salt.utils.data.decode(path)
   313|     saltenv = salt.utils.data.decode(saltenv)
   314|     url_data = urllib.parse.urlparse(path)
   315|     if url_data.scheme in ("file", ""):
   316|         return __salt__["cp.cache_file_ssh"](
   317|             path,
   318|             saltenv=saltenv,
   319|             source_hash=source_hash,
   320|             verify_ssl=verify_ssl,
   321|             use_etag=use_etag,
   322|         )
   323|     contextkey = "{}_|-{}_|-{}".format("cp.cache_file", path, saltenv)
   324|     filerefs_ckey = "_cp_extra_filerefs"
   325|     url_data = urllib.parse.urlparse(path)
   326|     path_is_remote = url_data.scheme in salt.utils.files.REMOTE_PROTOS
   327|     def _check_return(result):
   328|         if result and url_data.scheme == "salt":
   329|             if filerefs_ckey not in __context__:
   330|                 __context__[filerefs_ckey] = []
   331|             if path not in __context__[filerefs_ckey]:
   332|                 __context__[filerefs_ckey].append(path)
   333|         return result
   334|     with _client() as client:
   335|         try:
   336|             if path_is_remote and contextkey in __context__:
   337|                 if client._path_exists(__context__[contextkey]):
   338|                     return _check_return(__context__[contextkey])
   339|                 else:
   340|                     __context__.pop(contextkey)
   341|         except AttributeError:
   342|             pass
   343|         result = client.cache_file(
   344|             path,
   345|             saltenv,
   346|             source_hash=source_hash,
   347|             verify_ssl=verify_ssl,
   348|             use_etag=use_etag,
   349|         )
   350|         if not result and not use_etag:
   351|             log.error("Unable to cache file '%s' from saltenv '%s'.", path, saltenv)
   352|         if result:
   353|             result = client.target_map[result]
   354|         if path_is_remote:
   355|             __context__[contextkey] = result
   356|         return _check_return(result)
   357| def cache_files(paths, saltenv="base"):
   358|     """
   359|     Used to gather many files from the Master, the gathered files will be
   360|     saved in the minion cachedir reflective to the paths retrieved from the
   361|     Master.
   362|     .. note::
   363|         This can take a long time since each file is transferred separately.
   364|     CLI Example:
   365|     .. code-block:: bash
   366|         salt-ssh '*' cp.cache_files salt://pathto/file1,salt://pathto/file1
   367|     There are two ways of defining the fileserver environment (a.k.a.
   368|     ``saltenv``) from which to cache the files. One is to use the ``saltenv``
   369|     parameter, and the other is to use a querystring syntax in the ``salt://``
   370|     URL. The below two examples are equivalent:
   371|     .. code-block:: bash
   372|         salt '*' cp.cache_files salt://foo/bar.conf,salt://foo/baz.conf saltenv=config
   373|         salt '*' cp.cache_files salt://foo/bar.conf?saltenv=config,salt://foo/baz.conf?saltenv=config
   374|     The querystring method is less useful when all files are being cached from
   375|     the same environment, but is a good way of caching files from multiple
   376|     different environments in the same command. For example, the below command
   377|     will cache the first file from the ``config1`` environment, and the second
   378|     one from the ``config2`` environment.
   379|     .. code-block:: bash
   380|         salt '*' cp.cache_files salt://foo/bar.conf?saltenv=config1,salt://foo/bar.conf?saltenv=config2
   381|     .. note::
   382|         It may be necessary to quote the URL when using the querystring method,
   383|         depending on the shell being used to run the command.
   384|     """
   385|     ret = []
   386|     if isinstance(paths, str):
   387|         paths = paths.split(",")
   388|     for path in paths:
   389|         ret.append(cache_file(path, saltenv))
   390|     return ret
   391| def cache_dir(
   392|     path, saltenv="base", include_empty=False, include_pat=None, exclude_pat=None
   393| ):
   394|     """
   395|     Download and cache everything under a directory from the master.
   396|     .. note::
   397|         This can take a long time since each file is transferred separately.
   398|     CLI Example:
   399|     .. code-block:: bash
   400|         salt '*' cp.cache_dir salt://path/to/dir
   401|         salt '*' cp.cache_dir salt://path/to/dir include_pat='E@*.py$'
   402|     path
   403|         The path on the fileserver, like ``salt://foo/bar/``. It is possible
   404|         to specify the ``saltenv`` using the querystring syntax:
   405|         ``salt://foo/bar?saltenv=config``
   406|     saltenv
   407|         Salt fileserver environment from which to retrieve the directory.
   408|         Defaults to ``base``.
   409|     include_empty
   410|         Whether to cache empty directories as well. Defaults to false.
   411|     include_pat : None
   412|         Glob or regex to narrow down the files cached from the given path. If
   413|         matching with a regex, the regex must be prefixed with ``E@``,
   414|         otherwise the expression will be interpreted as a glob.
   415|         .. versionadded:: 2014.7.0
   416|     exclude_pat : None
   417|         Glob or regex to exclude certain files from being cached from the given
   418|         path. If matching with a regex, the regex must be prefixed with ``E@``,
   419|         otherwise the expression will be interpreted as a glob.
   420|         .. note::
   421|             If used with ``include_pat``, files matching this pattern will be
   422|             excluded from the subset of files defined by ``include_pat``.
   423|         .. versionadded:: 2014.7.0
   424|     """
   425|     with _client() as client:
   426|         ret = client.cache_dir(path, saltenv, include_empty, include_pat, exclude_pat)
   427|         if not ret:
   428|             return ret
   429|         return [client.target_map[x] for x in ret]
   430| def cache_master(saltenv="base"):
   431|     """
   432|     Retrieve all of the files on the master and cache them locally.
   433|     .. note::
   434|         This can take a long time since each file is transferred separately.
   435|     CLI Example:
   436|     .. code-block:: bash
   437|         salt-ssh '*' cp.cache_master
   438|     """
   439|     with _client() as client:
   440|         ret = client.cache_master(saltenv)
   441|         if not ret:
   442|             return ret
   443|         parsed = []
   444|         for file in ret:
   445|             try:
   446|                 parsed.append(client.target_map[file])
   447|             except KeyError:
   448|                 log.error("Failed transferring a file")
   449|         return parsed
   450| def list_states(saltenv="base"):
   451|     """
   452|     List all of the available state files in an environment.
   453|     CLI Example:
   454|     .. code-block:: bash
   455|         salt-ssh '*' cp.list_states
   456|     saltenv
   457|         Salt fileserver environment from which to list states.
   458|         Defaults to ``base``.
   459|     """
   460|     return __context__["fileclient"].list_states(saltenv)
   461| def list_master(saltenv="base", prefix=""):
   462|     """
   463|     List all of the files stored on the master.
   464|     CLI Example:
   465|     .. code-block:: bash
   466|         salt-ssh '*' cp.list_master
   467|     saltenv
   468|         Salt fileserver environment from which to list files.
   469|         Defaults to ``base``.
   470|     prefix
   471|         Only list files under this prefix. Defaults to empty.
   472|     """
   473|     return __context__["fileclient"].file_list(saltenv, prefix)
   474| def list_master_dirs(saltenv="base", prefix=""):
   475|     """
   476|     List all of the directories stored on the master.
   477|     CLI Example:
   478|     .. code-block:: bash
   479|         salt-ssh '*' cp.list_master_dirs
   480|     saltenv
   481|         Salt fileserver environment from which to list directories.
   482|         Defaults to ``base``.
   483|     prefix
   484|         Only list directories under this prefix. Defaults to empty.
   485|     """
   486|     return __context__["fileclient"].dir_list(saltenv, prefix)
   487| def list_master_symlinks(saltenv="base", prefix=""):
   488|     """
   489|     List all of the symlinks stored on the master.
   490|     Will return a mapping of symlink names to absolute paths.
   491|     CLI Example:
   492|     .. code-block:: bash
   493|         salt-ssh '*' cp.list_master_symlinks
   494|     saltenv
   495|         Salt fileserver environment from which to list symlinks.
   496|         Defaults to ``base``.
   497|     prefix
   498|         Only list symlinks under this prefix. Defaults to empty.
   499|     """
   500|     return __context__["fileclient"].symlink_list(saltenv, prefix)
   501| def is_cached(path, saltenv="base"):
   502|     """
   503|     Returns the full path to a file if it is cached locally on the minion
   504|     as well as the SSH master-minion, otherwise returns a blank string.
   505|     CLI Example:
   506|     .. code-block:: bash
   507|         salt-ssh '*' cp.is_cached salt://path/to/file
   508|     path
   509|         The path to check.
   510|     saltenv
   511|         Salt fileserver environment the file was cached from.
   512|         Defaults to ``base``.
   513|     """
   514|     with _client() as client:
   515|         ret = client.is_cached(path, saltenv)
   516|         if not ret:
   517|             return ret
   518|         return str(client.convert_path(ret))
   519| def hash_file(path, saltenv="base"):
   520|     """
   521|     Return the hash of a file. Supports ``salt://`` URIs and local files.
   522|     Local files should be specified with their absolute paths, without the
   523|     ``file://`` scheme.
   524|     CLI Example:
   525|     .. code-block:: bash
   526|         salt-ssh '*' cp.hash_file salt://path/to/file
   527|         salt-ssh '*' cp.hash_file /path/to/file
   528|     path
   529|         The path to return the hash for.
   530|     saltenv
   531|         Salt fileserver environment from which the file should be hashed.
   532|         Defaults to ``base``.
   533|     """
   534|     path, senv = salt.utils.url.split_env(path)
   535|     if senv:
   536|         saltenv = senv
   537|     url_data = urllib.parse.urlparse(path)
   538|     if url_data.scheme in ("file", ""):
   539|         return __salt__["cp.hash_file_ssh"](path, saltenv)
   540|     with _client() as client:
   541|         return client.hash_file(path, saltenv)
   542| def convert_cache_path(path, cachedir=None, master=True):
   543|     """
   544|     It converts a path received by caching a file to the minion cache to the
   545|     corresponding one in the local master cache (or the other way around).
   546|     .. note::
   547|         This function is exclusive to the SSH wrapper module and is mostly
   548|         intended for other wrapper modules to use, not on the CLI.
   549|     CLI Example:
   550|     .. code-block:: bash
   551|         salt-ssh '*' cp.convert_cache_path /var/tmp/.root_abc123_salt/running_data/var/cache/salt/minion/files/base/foo.txt
   552|     path
   553|         The path to convert. It has to be in one of the (remote or SSH master-minion)
   554|         cachedirs to be converted, otherwise will be returned verbatim.
   555|     cachedir
   556|         An optional cachedir override that was used when caching the file.
   557|     master
   558|         Whether to convert the path to the master-side path. Defaults
   559|         to true (since this module returns the minion paths otherwise).
   560|     """
   561|     with _client() as client:
   562|         return str(client.convert_path(path, cachedir, master))
   563| def _gather_pillar(pillarenv, pillar_override):
   564|     """
   565|     The opts used during pillar rendering should contain the master
   566|     opts in the root namespace. self.opts is the modified minion opts,
   567|     containing the original master opts in __master_opts__.
   568|     """
   569|     popts = {}
   570|     popts.update(__opts__)
   571|     popts.update(__opts__.get("__master_opts__", {}))
   572|     pillar = salt.pillar.get_pillar(
   573|         popts,
   574|         __grains__.value(),
   575|         __salt__.kwargs["id_"],
   576|         __opts__["saltenv"] or "base",
   577|         pillar_override=pillar_override,
   578|         pillarenv=pillarenv,
   579|     )
   580|     return pillar.compile_pillar()
   581| def _render_filenames(path, dest, saltenv, template, **kw):
   582|     """
   583|     Process markup in the :param:`path` and :param:`dest` variables (NOT the
   584|     files under the paths they ultimately point to) according to the markup
   585|     format provided by :param:`template`.
   586|     """
   587|     if not template:
   588|         return (path, dest)
   589|     if template not in salt.utils.templates.TEMPLATE_REGISTRY:
   590|         raise CommandExecutionError(
   591|             f"Attempted to render file paths with unavailable engine {template}"
   592|         )
   593|     kwargs = {}
   594|     kwargs["salt"] = __salt__.value()
   595|     if "pillarenv" in kw or "pillar" in kw:
   596|         pillarenv = kw.get("pillarenv", __opts__.get("pillarenv"))
   597|         kwargs["pillar"] = _gather_pillar(pillarenv, kw.get("pillar"))
   598|     else:
   599|         kwargs["pillar"] = __pillar__.value()
   600|     kwargs["grains"] = __grains__.value()
   601|     kwargs["opts"] = __opts__
   602|     kwargs["saltenv"] = saltenv
   603|     def _render(contents):
   604|         """
   605|         Render :param:`contents` into a literal pathname by writing it to a
   606|         temp file, rendering that file, and returning the result.
   607|         """
   608|         tmp_path_fn = salt.utils.files.mkstemp()
   609|         with salt.utils.files.fopen(tmp_path_fn, "w+") as fp_:
   610|             fp_.write(salt.utils.stringutils.to_str(contents))
   611|         data = salt.utils.templates.TEMPLATE_REGISTRY[template](
   612|             tmp_path_fn, to_str=True, **kwargs
   613|         )
   614|         salt.utils.files.safe_rm(tmp_path_fn)
   615|         if not data["result"]:
   616|             raise CommandExecutionError(
   617|                 "Failed to render file path with error: {}".format(data["data"])
   618|             )
   619|         else:
   620|             return data["data"]
   621|     path = _render(path)
   622|     dest = _render(dest)
   623|     return (path, dest)
   624| class SSHCpClient(salt.fileclient.FSClient):
   625|     """
   626|     A FileClient that replicates between SSH master-minion and remote minion caches
   627|     """
   628|     def __init__(self, opts, shell, tgt):  # pylint: disable=W0231
   629|         salt.fileclient.FSClient.__init__(self, opts)  # pylint: disable=W0233
   630|         self.shell = shell
   631|         self.tgt = tgt
   632|         self.target_map = {}
   633|     def _local_path_exists(self, path):
   634|         file = self.convert_path(path, master=True)
   635|         return file.exists()
   636|     def _remote_path_exists(self, path):
   637|         path = self.convert_path(path)
   638|         _, _, retcode = self.shell.exec_cmd("test -e " + shlex.quote(str(path)))
   639|         return not retcode
   640|     def _path_exists(self, path):
   641|         return self._local_path_exists(path) and self._remote_path_exists(path)
   642|     def cache_local_file(self, path, **kwargs):
   643|         raise CommandExecutionError("Cannot cache local files via salt-ssh")
   644|     def is_cached(self, path, saltenv="base", cachedir=None):
   645|         """
   646|         Returns the full path to a file if it is cached both locally on the
   647|         SSH master-minion and the minion, otherwise returns a blank string
   648|         """
   649|         if path.startswith("salt://"):
   650|             path, senv = salt.utils.url.parse(path)
   651|             if senv:
   652|                 saltenv = senv
   653|         escaped = True if salt.utils.url.is_escaped(path) else False
   654|         localsfilesdest = os.path.join(
   655|             self.opts["cachedir"], "localfiles", path.lstrip("|/")
   656|         )
   657|         filesdest = os.path.join(
   658|             self.opts["cachedir"], "files", saltenv, path.lstrip("|/")
   659|         )
   660|         extrndest = self._extrn_path(path, saltenv, cachedir=cachedir)
   661|         if self._path_exists(filesdest):
   662|             return salt.utils.url.escape(filesdest) if escaped else filesdest
   663|         if self._remote_path_exists(localsfilesdest):
   664|             return (
   665|                 salt.utils.url.escape(localsfilesdest) if escaped else localsfilesdest
   666|             )
   667|         if self._path_exists(extrndest):
   668|             return extrndest
   669|         return ""
   670|     def get_cachedir(
   671|         self, cachedir=None, master=True
   672|     ):  # pylint: disable=arguments-differ
   673|         prefix = []
   674|         if master:
   675|             prefix = ["salt-ssh", self.tgt]
   676|         if cachedir is None:
   677|             cachedir = os.path.join(self.opts["cachedir"], *prefix)
   678|         elif not os.path.isabs(cachedir):
   679|             cachedir = os.path.join(self.opts["cachedir"], *prefix, cachedir)
   680|         elif master:
   681|             cachedir = os.path.join(
   682|                 self.opts["cachedir"],
   683|                 *prefix,
   684|                 "absolute_root",
   685|                 str(Path(*cachedir.split(os.sep)[1:])),
   686|             )
   687|         return cachedir
   688|     def convert_path(self, path, cachedir=None, master=False):
   689|         """
   690|         Convert a cache path from master/minion to the other.
   691|         Both use the same cachedir in salt-ssh, but our fileclient
   692|         here caches to a subdir on the master. Remove/add it from/to
   693|         the path.
   694|         """
   695|         path = Path(path)
   696|         master_cachedir = Path(self.get_cachedir(cachedir, master=True))
   697|         minion_cachedir = Path(self.get_cachedir(cachedir, master=False))
   698|         if master:
   699|             if master_cachedir in path.parents:
   700|                 return path
   701|             return master_cachedir / path.relative_to(minion_cachedir)
   702|         if master_cachedir not in path.parents:
   703|             return path
   704|         return minion_cachedir / path.relative_to(master_cachedir)
   705|     def _send_file(self, src, dest, makedirs, cachedir):
   706|         def _error(stdout, stderr):
   707|             log.error(f"Failed sending file: {stderr or stdout}")
   708|             if Path(self.get_cachedir(cachedir)) in Path(src).parents:
   709|                 Path(src).unlink(missing_ok=True)
   710|             return False
   711|         for path in (src, dest):
   712|             if not Path(path).is_absolute():
   713|                 raise ValueError(
   714|                     f"Paths must be absolute, got '{path}' as {'src' if path == src else 'dest'}"
   715|                 )
   716|         src, dest = str(src), str(dest)  # ensure we're using strings
   717|         stdout, stderr, retcode = self.shell.send(src, dest, makedirs)
   718|         if retcode and makedirs and "Not a directory" in stderr:
   719|             minion_cachedir = Path(self.get_cachedir(cachedir, master=False))
   720|             dest = cur = Path(dest)
   721|             while minion_cachedir in cur.parents:
   722|                 if self._isfile(cur):
   723|                     if not self._rmpath(cur):
   724|                         return _error(stdout, stderr)
   725|                     dest = str(dest)
   726|                     break
   727|                 cur = cur.parent
   728|             else:
   729|                 return _error(stdout, stderr)
   730|             stdout, stderr, retcode = self.shell.send(src, dest, makedirs)
   731|         if retcode:
   732|             return _error(stdout, stderr)
   733|         self.target_map[src] = dest
   734|         return src
   735|     def _isdir(self, path):
   736|         _, _, retcode = self.shell.exec_cmd("test -d " + shlex.quote(str(path)))
   737|         return not retcode
   738|     def _isfile(self, path):
   739|         _, _, retcode = self.shell.exec_cmd("test -f " + shlex.quote(str(path)))
   740|         return not retcode
   741|     def _rmpath(self, path, cachedir=None):
   742|         path = Path(path)
   743|         if not path or not path.is_absolute() or str(path) == "/":
   744|             raise ValueError(
   745|                 f"Not deleting unspecified, relative or root path: '{path}'"
   746|             )
   747|         minion_cachedir = Path(self.get_cachedir(cachedir, master=False))
   748|         if minion_cachedir not in path.parents and path != minion_cachedir:
   749|             raise ValueError(
   750|                 f"Not recursively deleting a path outside of the cachedir. Path: '{path}'"
   751|             )
   752|         stdout, stderr, retcode = self.shell.exec_cmd(
   753|             "rm -rf " + shlex.quote(str(path))
   754|         )
   755|         if retcode:
   756|             log.error(f"Failed deleting path '{path}': {stderr or stdout}")
   757|         return not retcode
   758|     def get_url(
   759|         self,
   760|         url,
   761|         dest,
   762|         makedirs=False,
   763|         saltenv="base",
   764|         no_cache=False,
   765|         cachedir=None,
   766|         source_hash=None,
   767|         verify_ssl=True,
   768|         use_etag=False,
   769|     ):
   770|         url_data = urllib.parse.urlparse(url)
   771|         if url_data.scheme in ("file", ""):
   772|             log.error("The file:// scheme is not supported via the salt-ssh cp wrapper")
   773|             return False
   774|         if url_data.scheme == "salt":
   775|             result = self.get_file(url, dest, makedirs, saltenv, cachedir=cachedir)
   776|             if result and dest is None:
   777|                 with salt.utils.files.fopen(result, "rb") as fp_:
   778|                     data = fp_.read()
   779|                 return data
   780|             return result
   781|         cached = super().get_url(
   782|             url,
   783|             "",
   784|             makedirs=True,
   785|             saltenv=saltenv,
   786|             no_cache=no_cache,
   787|             cachedir=cachedir,
   788|             source_hash=source_hash,
   789|             verify_ssl=verify_ssl,
   790|             use_etag=use_etag,
   791|         )
   792|         if not cached:
   793|             return cached
   794|         if not isinstance(dest, str) and no_cache:
   795|             return cached
   796|         strict = False
   797|         if not dest:
   798|             makedirs = True
   799|             dest = str(self.convert_path(cached, cachedir))
   800|             strict = True
   801|         if dest.endswith("/") or self._isdir(dest):
   802|             if not dest.endswith("/"):
   803|                 if (
   804|                     strict
   805|                     or self.get_cachedir(cachedir, master=False) in Path(dest).parents
   806|                 ):
   807|                     strict = True
   808|                     if not self._rmpath(dest):
   809|                         Path(cached).unlink(missing_ok=True)
   810|                         return False
   811|             if not strict:
   812|                 if (
   813|                     url_data.query
   814|                     or len(url_data.path) > 1
   815|                     and not url_data.path.endswith("/")
   816|                 ):
   817|                     strpath = url.split("/")[-1]
   818|                 else:
   819|                     strpath = "index.html"
   820|                 dest = os.path.join(dest, strpath)
   821|         return self._send_file(cached, dest, makedirs, cachedir)
   822|     def get_file(
   823|         self, path, dest="", makedirs=False, saltenv="base", gzip=None, cachedir=None
   824|     ):
   825|         """
   826|         Get a single file from the salt-master
   827|         path must be a salt server location, aka, salt://path/to/file, if
   828|         dest is omitted, then the downloaded file will be placed in the minion
   829|         cache
   830|         """
   831|         src = super().get_file(
   832|             path,
   833|             "",
   834|             makedirs=True,
   835|             saltenv=saltenv,
   836|             cachedir=cachedir,
   837|         )
   838|         if not src:
   839|             return src
   840|         strict = False
   841|         if not dest:
   842|             makedirs = True
   843|             dest = str(self.convert_path(src, cachedir))
   844|             strict = True
   845|         if dest.endswith("/") or self._isdir(dest):
   846|             if not dest.endswith("/"):
   847|                 if (
   848|                     strict
   849|                     or self.get_cachedir(cachedir, master=False) in Path(dest).parents
   850|                 ):
   851|                     strict = True
   852|                     if not self._rmpath(dest):
   853|                         Path(src).unlink(missing_ok=True)
   854|                         return ""
   855|             if not strict:
   856|                 dest = os.path.join(dest, os.path.basename(src))
   857|         return self._send_file(src, dest, makedirs, cachedir)
   858|     def get_template(
   859|         self,
   860|         url,
   861|         dest,
   862|         template="jinja",
   863|         makedirs=False,
   864|         saltenv="base",
   865|         cachedir=None,
   866|         **kwargs,
   867|     ):
   868|         """
   869|         Cache a file then process it as a template
   870|         """
   871|         res = super().get_template(
   872|             url,
   873|             "",
   874|             template=template,
   875|             makedirs=makedirs,
   876|             saltenv=saltenv,
   877|             cachedir=cachedir,
   878|             **kwargs,
   879|         )
   880|         if not res:
   881|             return res
   882|         strict = False
   883|         if not dest:
   884|             makedirs = True
   885|             dest = str(self.convert_path(res, cachedir))
   886|             strict = True
   887|         if dest.endswith("/") or self._isdir(dest):
   888|             if not dest.endswith("/"):
   889|                 if (
   890|                     strict
   891|                     or self.get_cachedir(cachedir, master=False) in Path(dest).parents
   892|                 ):
   893|                     strict = True
   894|                     if not self._rmpath(dest):
   895|                         Path(res).unlink(missing_ok=True)
   896|                         return ""
   897|             if not strict:
   898|                 dest = os.path.join(dest, os.path.basename(res))
   899|         return self._send_file(res, dest, makedirs, cachedir)
   900|     def _extrn_path(self, url, saltenv, cachedir=None):
   901|         res = super()._extrn_path(url, saltenv, cachedir=cachedir)
   902|         return str(self.convert_path(res, cachedir, master=True))
   903|     def cache_dest(self, url, saltenv="base", cachedir=None):
   904|         """
   905|         Return the expected cache location for the specified URL and
   906|         environment.
   907|         """
   908|         res = super().cache_dest(url, saltenv=saltenv, cachedir=cachedir)
   909|         return str(self.convert_path(res, cachedir, master=True))


# ====================================================================
# FILE: salt/client/ssh/wrapper/grains.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-47 ---
     1| """
     2| Return/control aspects of the grains data
     3| """
     4| import math
     5| import salt.utils.data
     6| import salt.utils.dictupdate
     7| import salt.utils.json
     8| from salt.defaults import DEFAULT_TARGET_DELIM
     9| __grains__ = {}
    10| def _serial_sanitizer(instr):
    11|     """
    12|     Replaces the last 1/4 of a string with X's
    13|     """
    14|     length = len(instr)
    15|     index = int(math.floor(length * 0.75))
    16|     return "{}{}".format(instr[:index], "X" * (length - index))
    17| _FQDN_SANITIZER = lambda x: "MINION.DOMAINNAME"
    18| _HOSTNAME_SANITIZER = lambda x: "MINION"
    19| _DOMAINNAME_SANITIZER = lambda x: "DOMAINNAME"
    20| _SANITIZERS = {
    21|     "serialnumber": _serial_sanitizer,
    22|     "domain": _DOMAINNAME_SANITIZER,
    23|     "fqdn": _FQDN_SANITIZER,
    24|     "id": _FQDN_SANITIZER,
    25|     "host": _HOSTNAME_SANITIZER,
    26|     "localhost": _HOSTNAME_SANITIZER,
    27|     "nodename": _HOSTNAME_SANITIZER,
    28| }
    29| def get(key, default="", delimiter=DEFAULT_TARGET_DELIM, ordered=True):
    30|     """
    31|     Attempt to retrieve the named value from grains, if the named value is not
    32|     available return the passed default. The default return is an empty string.
    33|     The value can also represent a value in a nested dict using a ":" delimiter
    34|     for the dict. This means that if a dict in grains looks like this::
    35|         {'pkg': {'apache': 'httpd'}}
    36|     To retrieve the value associated with the apache key in the pkg dict this
    37|     key can be passed::
    38|         pkg:apache
    39|     CLI Example:
    40|     .. code-block:: bash
    41|         salt '*' grains.get pkg:apache
    42|     """
    43|     if ordered is True:
    44|         grains = __grains__.value()
    45|     else:
    46|         grains = salt.utils.json.loads(salt.utils.json.dumps(__grains__.value()))
    47|     return salt.utils.data.traverse_dict_and_list(grains, key, default, delimiter)


# ====================================================================
# FILE: salt/client/ssh/wrapper/mine.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-95 ---
     1| """
     2| Wrapper function for mine operations for salt-ssh
     3| .. versionadded:: 2015.5.0
     4| .. versionchanged:: 3007.0
     5|     In addition to mine returns from roster targets, this wrapper now supports
     6|     accessing the regular mine as well.
     7| """
     8| import copy
     9| import logging
    10| import salt.client.ssh
    11| import salt.daemons.masterapi
    12| log = logging.getLogger(__name__)
    13| def get(
    14|     tgt, fun, tgt_type="glob", roster="flat", ssh_minions=True, regular_minions=False
    15| ):
    16|     """
    17|     Get data from the mine based on the target, function and tgt_type
    18|     This will actually run the function on all targeted SSH minions (like
    19|     publish.publish), as salt-ssh clients can't update the mine themselves.
    20|     We will look for mine_functions in the roster, pillar, and master config,
    21|     in that order, looking for a match for the defined function.
    22|     Targets can be matched based on any standard matching system that can be
    23|     matched on the defined roster (in salt-ssh).
    24|     Regular mine data will be fetched as usual and can be targeted as usual.
    25|     CLI Example:
    26|     .. code-block:: bash
    27|         salt-ssh '*' mine.get '*' network.interfaces
    28|         salt-ssh '*' mine.get 'myminion' network.interfaces roster=flat
    29|         salt-ssh '*' mine.get '192.168.5.0' network.ipaddrs roster=scan
    30|         salt-ssh myminion mine.get '*' network.interfaces ssh_minions=False regular_minions=True
    31|         salt-ssh myminion mine.get '*' network.interfaces ssh_minions=True regular_minions=True
    32|     tgt
    33|         Target whose mine data to get.
    34|     fun
    35|         Function to get the mine data of. You can specify multiple functions
    36|         to retrieve using either a list or a comma-separated string of functions.
    37|     tgt_type
    38|         Target type to use with ``tgt``. Defaults to ``glob``.
    39|         See :ref:`targeting` for more information for regular minion targets, above
    40|         for SSH ones.
    41|     roster
    42|         The roster module to use. Defaults to ``flat``.
    43|     ssh_minions
    44|         .. versionadded:: 3007.0
    45|         Target minions from the roster. Defaults to true.
    46|     regular_minions
    47|         .. versionadded:: 3007.0
    48|         Target regular minions of the master running salt-ssh. Defaults to false.
    49|     """
    50|     rets = {}
    51|     if regular_minions:
    52|         masterapi = salt.daemons.masterapi.RemoteFuncs(__context__["master_opts"])
    53|         load = {
    54|             "id": __opts__["id"],
    55|             "fun": fun,
    56|             "tgt": tgt,
    57|             "tgt_type": tgt_type,
    58|         }
    59|         ret = masterapi._mine_get(load)
    60|         rets.update(ret)
    61|     if ssh_minions:
    62|         opts = copy.deepcopy(__context__["master_opts"])
    63|         minopts = copy.deepcopy(__opts__)
    64|         opts.update(minopts)
    65|         if roster:
    66|             opts["roster"] = roster
    67|         opts["argv"] = [fun]
    68|         opts["selected_target_option"] = tgt_type
    69|         opts["tgt"] = tgt
    70|         opts["arg"] = []
    71|         ssh = salt.client.ssh.SSH(opts)
    72|         mrets = {}
    73|         for ret in ssh.run_iter(mine=True):
    74|             mrets.update(ret)
    75|         for host, data in mrets.items():
    76|             if not isinstance(data, dict):
    77|                 log.error(
    78|                     f"Error executing mine func {fun} on {host}: {data}."
    79|                     " Excluding minion from mine."
    80|                 )
    81|             elif "_error" in data:
    82|                 log.error(
    83|                     f"Error executing mine func {fun} on {host}: {data['_error']}."
    84|                     " Excluding minion from mine. Full output in debug log."
    85|                 )
    86|                 log.debug(f"Return was: {salt.utils.json.dumps(data)}")
    87|             elif "return" not in data:
    88|                 log.error(
    89|                     f"Error executing mine func {fun} on {host}: No return was specified."
    90|                     " Excluding minion from mine. Full output in debug log."
    91|                 )
    92|                 log.debug(f"Return was: {salt.utils.json.dumps(data)}")
    93|             else:
    94|                 rets[host] = data["return"]
    95|     return rets


# ====================================================================
# FILE: salt/client/ssh/wrapper/publish.py
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 1-341 ---
     1| """
     2| .. versionadded:: 2015.5.0
     3| Salt-ssh wrapper functions for the publish module.
     4| Publish will never actually execute on the minions, so we just create new
     5| salt-ssh calls and return the data from them.
     6| No access control is needed because calls cannot originate from the minions.
     7| .. versionchanged:: 3007.0
     8|     In addition to SSH minions, this module can now also target regular ones.
     9| """
    10| import copy
    11| import logging
    12| import time
    13| import salt.client.ssh
    14| import salt.daemons.masterapi
    15| import salt.runner
    16| import salt.utils.args
    17| import salt.utils.json
    18| log = logging.getLogger(__name__)
    19| def _parse_args(arg):
    20|     """
    21|     yamlify `arg` and ensure its outermost datatype is a list
    22|     """
    23|     yaml_args = salt.utils.args.yamlify_arg(arg)
    24|     if yaml_args is None:
    25|         return []
    26|     elif not isinstance(yaml_args, list):
    27|         return [yaml_args]
    28|     else:
    29|         return yaml_args
    30| def _publish(
    31|     tgt,
    32|     fun,
    33|     arg=None,
    34|     tgt_type="glob",
    35|     returner="",
    36|     timeout=None,
    37|     form="clean",
    38|     roster=None,
    39| ):
    40|     """
    41|     Publish a command "from the minion out to other minions". In reality, the
    42|     minion does not execute this function, it is executed by the master. Thus,
    43|     no access control is enabled, as minions cannot initiate publishes
    44|     themselves.
    45|     Salt-ssh publishes will default to whichever roster was used for the
    46|     initiating salt-ssh call, and can be overridden using the ``roster``
    47|     argument
    48|     Returners are not currently supported
    49|     The arguments sent to the minion publish function are separated with
    50|     commas. This means that for a minion executing a command with multiple
    51|     args it will look like this::
    52|         salt-ssh system.example.com publish.publish '*' user.add 'foo,1020,1020'
    53|     CLI Example:
    54|     .. code-block:: bash
    55|         salt-ssh system.example.com publish.publish '*' cmd.run 'ls -la /tmp'
    56|     """
    57|     if fun.startswith("publish."):
    58|         log.info("Cannot publish publish calls. Returning {}")
    59|         return {}
    60|     if returner:
    61|         log.warning("Returners currently not supported in salt-ssh publish")
    62|     if arg is None:
    63|         arg = []
    64|     elif not isinstance(arg, list):
    65|         arg = [salt.utils.json.dumps(salt.utils.args.yamlify_arg(arg))]
    66|     else:
    67|         arg = [
    68|             salt.utils.json.dumps(y)
    69|             for y in (salt.utils.args.yamlify_arg(x) for x in arg)
    70|         ]
    71|     if len(arg) == 1 and arg[0] is None:
    72|         arg = []
    73|     opts = copy.deepcopy(__context__["master_opts"])
    74|     minopts = copy.deepcopy(__opts__)
    75|     opts.update(minopts)
    76|     if roster:
    77|         opts["roster"] = roster
    78|     if timeout:
    79|         opts["timeout"] = timeout
    80|     opts["argv"] = [fun] + arg
    81|     opts["selected_target_option"] = tgt_type
    82|     opts["tgt"] = tgt
    83|     opts["arg"] = arg
    84|     ssh = salt.client.ssh.SSH(opts)
    85|     rets = {}
    86|     for ret in ssh.run_iter():
    87|         rets.update(ret)
    88|     if form == "clean":
    89|         cret = {}
    90|         for host in rets:
    91|             if "return" in rets[host]:
    92|                 cret[host] = rets[host]["return"]
    93|             else:
    94|                 cret[host] = rets[host]
    95|         return cret
    96|     for host in rets:
    97|         if "return" in rets[host]:
    98|             rets[host]["ret"] = rets[host]["return"]
    99|     return rets
   100| def _publish_regular(
   101|     tgt,
   102|     fun,
   103|     arg=None,
   104|     tgt_type="glob",
   105|     returner="",
   106|     timeout=5,
   107|     form="clean",
   108|     wait=False,
   109| ):
   110|     if fun.startswith("publish."):
   111|         log.info("Cannot publish publish calls. Returning {}")
   112|         return {}
   113|     arg = _parse_args(arg)
   114|     masterapi = salt.daemons.masterapi.RemoteFuncs(__context__["master_opts"])
   115|     log.info("Publishing '%s'", fun)
   116|     load = {
   117|         "cmd": "minion_pub",
   118|         "fun": fun,
   119|         "arg": arg,
   120|         "tgt": tgt,
   121|         "tgt_type": tgt_type,
   122|         "ret": returner,
   123|         "tmo": timeout,
   124|         "form": form,
   125|         "id": __opts__["id"],
   126|         "no_parse": __opts__.get("no_parse", []),
   127|     }
   128|     peer_data = masterapi.minion_pub(load)
   129|     if not peer_data:
   130|         return {}
   131|     if wait:
   132|         loop_interval = 0.3
   133|         matched_minions = set(peer_data["minions"])
   134|         returned_minions = set()
   135|         loop_counter = 0
   136|         while returned_minions ^ matched_minions:
   137|             load = {
   138|                 "cmd": "pub_ret",
   139|                 "id": __opts__["id"],
   140|                 "jid": peer_data["jid"],
   141|             }
   142|             ret = masterapi.pub_ret(load)
   143|             returned_minions = set(ret.keys())
   144|             end_loop = False
   145|             if returned_minions >= matched_minions:
   146|                 end_loop = True
   147|             elif (loop_interval * loop_counter) > timeout:
   148|                 if not returned_minions:
   149|                     return {}
   150|                 end_loop = True
   151|             if end_loop:
   152|                 if form == "clean":
   153|                     cret = {}
   154|                     for host in ret:
   155|                         cret[host] = ret[host]["ret"]
   156|                     return cret
   157|                 else:
   158|                     return ret
   159|             loop_counter = loop_counter + 1
   160|             time.sleep(loop_interval)
   161|     else:
   162|         time.sleep(float(timeout))
   163|         load = {
   164|             "cmd": "pub_ret",
   165|             "id": __opts__["id"],
   166|             "jid": peer_data["jid"],
   167|         }
   168|         ret = masterapi.pub_ret(load)
   169|         if form == "clean":
   170|             cret = {}
   171|             for host in ret:
   172|                 cret[host] = ret[host]["ret"]
   173|             return cret
   174|         else:
   175|             return ret
   176|     return ret
   177| def publish(
   178|     tgt,
   179|     fun,
   180|     arg=None,
   181|     tgt_type="glob",
   182|     returner="",
   183|     timeout=5,
   184|     roster=None,
   185|     ssh_minions=True,
   186|     regular_minions=False,
   187| ):
   188|     """
   189|     Publish a command from the minion out to other minions. In reality, the
   190|     minion does not execute this function, it is executed by the master. Thus,
   191|     no access control is enabled, as minions cannot initiate publishes
   192|     themselves.
   193|     Salt-ssh publishes will default to whichever roster was used for the
   194|     initiating salt-ssh call, and can be overridden using the ``roster``
   195|     argument.
   196|     Returners are not currently supported
   197|     The tgt_type argument is used to pass a target other than a glob into
   198|     the execution, the available options for SSH minions are:
   199|     - glob
   200|     - pcre
   201|     - nodegroup
   202|     - range
   203|     Regular minions support all usual ones.
   204|     .. versionchanged:: 2017.7.0
   205|         The ``expr_form`` argument has been renamed to ``tgt_type``, earlier
   206|         releases must use ``expr_form``.
   207|     The arguments sent to the minion publish function are separated with
   208|     commas. This means that for a minion executing a command with multiple
   209|     args it will look like this:
   210|     .. code-block:: bash
   211|         salt-ssh system.example.com publish.publish '*' user.add 'foo,1020,1020'
   212|         salt-ssh system.example.com publish.publish '127.0.0.1' network.interfaces '' roster=scan
   213|     CLI Example:
   214|     .. code-block:: bash
   215|         salt-ssh system.example.com publish.publish '*' cmd.run 'ls -la /tmp'
   216|     .. admonition:: Attention
   217|         If you need to pass a value to a function argument and that value
   218|         contains an equal sign, you **must** include the argument name.
   219|         For example:
   220|         .. code-block:: bash
   221|             salt-ssh '*' publish.publish test.kwarg arg='cheese=spam'
   222|         Multiple keyword arguments should be passed as a list.
   223|         .. code-block:: bash
   224|             salt-ssh '*' publish.publish test.kwarg arg="['cheese=spam','spam=cheese']"
   225|     tgt
   226|         The target specification.
   227|     fun
   228|         The execution module to run.
   229|     arg
   230|         A list of arguments to pass to the module.
   231|     tgt_type
   232|         The matcher to use. Defaults to ``glob``.
   233|     returner
   234|         A returner to use.
   235|     timeout
   236|         Timeout in seconds. Defaults to 5.
   237|     roster
   238|         Override the roster for SSH minion targets. Defaults to the one
   239|         used for initiating the salt-ssh call.
   240|     ssh_minions
   241|         .. versionadded:: 3007.0
   242|         Include SSH minions in the possible targets. Defaults to true.
   243|     regular_minions
   244|         .. versionadded:: 3007.0
   245|         Include regular minions in the possible targets. Defaults to false.
   246|     """
   247|     rets = {}
   248|     if regular_minions:
   249|         rets.update(
   250|             _publish_regular(
   251|                 tgt,
   252|                 fun,
   253|                 arg=arg,
   254|                 tgt_type=tgt_type,
   255|                 returner=returner,
   256|                 timeout=timeout,
   257|                 form="clean",
   258|                 wait=True,
   259|             )
   260|         )
   261|     if ssh_minions:
   262|         rets.update(
   263|             _publish(
   264|                 tgt,
   265|                 fun,
   266|                 arg=arg,
   267|                 tgt_type=tgt_type,
   268|                 returner=returner,
   269|                 timeout=timeout,
   270|                 form="clean",
   271|                 roster=roster,
   272|             )
   273|         )
   274|     return rets
   275| def full_data(
   276|     tgt,
   277|     fun,
   278|     arg=None,
   279|     tgt_type="glob",
   280|     returner="",
   281|     timeout=5,
   282|     roster=None,
   283|     ssh_minions=True,
   284|     regular_minions=False,
   285| ):
   286|     """
   287|     Return the full data about the publication, this is invoked in the same
   288|     way as the publish function
   289|     CLI Example:
   290|     .. code-block:: bash
   291|         salt-ssh system.example.com publish.full_data '*' cmd.run 'ls -la /tmp'
   292|     .. admonition:: Attention
   293|         If you need to pass a value to a function argument and that value
   294|         contains an equal sign, you **must** include the argument name.
   295|         For example:
   296|         .. code-block:: bash
   297|             salt-ssh '*' publish.full_data test.kwarg arg='cheese=spam'
   298|     """
   299|     rets = {}
   300|     if regular_minions:
   301|         rets.update(
   302|             _publish_regular(
   303|                 tgt,
   304|                 fun,
   305|                 arg=arg,
   306|                 tgt_type=tgt_type,
   307|                 returner=returner,
   308|                 timeout=timeout,
   309|                 form="full",
   310|                 wait=True,
   311|             )
   312|         )
   313|     if ssh_minions:
   314|         rets.update(
   315|             _publish(
   316|                 tgt,
   317|                 fun,
   318|                 arg=arg,
   319|                 tgt_type=tgt_type,
   320|                 returner=returner,
   321|                 timeout=timeout,
   322|                 form="full",
   323|                 roster=roster,
   324|             )
   325|         )
   326|     return rets
   327| def runner(fun, arg=None, timeout=5):
   328|     """
   329|     Execute a runner on the master and return the data from the runner function
   330|     CLI Example:
   331|     .. code-block:: bash
   332|         salt-ssh '*' publish.runner jobs.lookup_jid 20140916125524463507
   333|     """
   334|     if not isinstance(arg, list):
   335|         arg = [salt.utils.args.yamlify_arg(arg)]
   336|     else:
   337|         arg = [salt.utils.args.yamlify_arg(x) for x in arg]
   338|     if len(arg) == 1 and arg[0] is None:
   339|         arg = []
   340|     runner = salt.runner.RunnerClient(__opts__["__master_opts__"])
   341|     return runner.cmd(fun, arg)


# ====================================================================
# FILE: salt/client/ssh/wrapper/state.py
# Total hunks: 15
# ====================================================================
# --- HUNK 1: Lines 13-82 ---
    13| import salt.state
    14| import salt.utils.args
    15| import salt.utils.data
    16| import salt.utils.files
    17| import salt.utils.hashutils
    18| import salt.utils.jid
    19| import salt.utils.json
    20| import salt.utils.platform
    21| import salt.utils.state
    22| import salt.utils.thin
    23| from salt.exceptions import SaltInvocationError
    24| __func_alias__ = {"apply_": "apply"}
    25| log = logging.getLogger(__name__)
    26| def _ssh_state(chunks, st_kwargs, kwargs, pillar, test=False):
    27|     """
    28|     Function to run a state with the given chunk via salt-ssh
    29|     """
    30|     file_refs = salt.client.ssh.state.lowstate_file_refs(
    31|         chunks,
    32|         _merge_extra_filerefs(
    33|             kwargs.get("extra_filerefs", ""),
    34|             __opts__.get("extra_filerefs", ""),
    35|             __context__.get("_cp_extra_filerefs", ""),
    36|         ),
    37|     )
    38|     trans_tar = salt.client.ssh.state.prep_trans_tar(
    39|         __context__["fileclient"],
    40|         chunks,
    41|         file_refs,
    42|         pillar,
    43|         st_kwargs["id_"],
    44|     )
    45|     trans_tar_sum = salt.utils.hashutils.get_hash(trans_tar, __opts__["hash_type"])
    46|     cmd = "state.pkg {}/salt_state.tgz test={} pkg_sum={} hash_type={}".format(
    47|         __opts__["thin_dir"], test, trans_tar_sum, __opts__["hash_type"]
    48|     )
    49|     single = salt.client.ssh.Single(
    50|         __opts__,
    51|         cmd,
    52|         fsclient=__context__["fileclient"],
    53|         minion_opts=__salt__.minion_opts,
    54|         **st_kwargs,
    55|     )
    56|     single.shell.send(trans_tar, "{}/salt_state.tgz".format(__opts__["thin_dir"]))
    57|     stdout, stderr, retcode = single.cmd_block()
    58|     try:
    59|         os.remove(trans_tar)
    60|     except OSError:
    61|         pass
    62|     return {"local": salt.client.ssh.wrapper.parse_ret(stdout, stderr, retcode)}
    63| def _check_pillar(kwargs, pillar=None):
    64|     """
    65|     Check the pillar for errors, refuse to run the state if there are errors
    66|     in the pillar and return the pillar errors
    67|     """
    68|     if kwargs.get("force"):
    69|         return True
    70|     pillar_dict = pillar if pillar is not None else __pillar__.value()
    71|     if "_errors" in pillar_dict:
    72|         return False
    73|     return True
    74| def _wait(jid):
    75|     """
    76|     Wait for all previously started state jobs to finish running
    77|     """
    78|     if jid is None:
    79|         jid = salt.utils.jid.gen_jid(__opts__)
    80|     states = _prior_running_states(jid)
    81|     while states:
    82|         time.sleep(1)

# --- HUNK 2: Lines 159-232 ---
   159|             if "__exclude__" in high_data:
   160|                 high_data["__exclude__"].extend(exclude)
   161|             else:
   162|                 high_data["__exclude__"] = exclude
   163|         high_data, ext_errors = st_.state.reconcile_extend(high_data)
   164|         errors += ext_errors
   165|         errors += st_.state.verify_high(high_data)
   166|         if errors:
   167|             __context__["retcode"] = salt.defaults.exitcodes.EX_STATE_COMPILER_ERROR
   168|             return errors
   169|         high_data, req_in_errors = st_.state.requisite_in(high_data)
   170|         errors += req_in_errors
   171|         high_data = st_.state.apply_exclude(high_data)
   172|         if errors:
   173|             __context__["retcode"] = salt.defaults.exitcodes.EX_STATE_COMPILER_ERROR
   174|             return errors
   175|         chunks = st_.state.compile_high_data(high_data)
   176|         file_refs = salt.client.ssh.state.lowstate_file_refs(
   177|             chunks,
   178|             _merge_extra_filerefs(
   179|                 kwargs.get("extra_filerefs", ""),
   180|                 opts.get("extra_filerefs", ""),
   181|                 __context__.get("_cp_extra_filerefs", ""),
   182|             ),
   183|         )
   184|         roster = salt.roster.Roster(opts, opts.get("roster", "flat"))
   185|         roster_grains = roster.opts["grains"]
   186|         _cleanup_slsmod_low_data(chunks)
   187|         trans_tar = salt.client.ssh.state.prep_trans_tar(
   188|             __context__["fileclient"],
   189|             chunks,
   190|             file_refs,
   191|             pillar,
   192|             st_kwargs["id_"],
   193|             roster_grains,
   194|         )
   195|         trans_tar_sum = salt.utils.hashutils.get_hash(trans_tar, opts["hash_type"])
   196|         cmd = "state.pkg {}/salt_state.tgz test={} pkg_sum={} hash_type={}".format(
   197|             opts["thin_dir"], test, trans_tar_sum, opts["hash_type"]
   198|         )
   199|         single = salt.client.ssh.Single(
   200|             opts,
   201|             cmd,
   202|             fsclient=__context__["fileclient"],
   203|             minion_opts=__salt__.minion_opts,
   204|             **st_kwargs,
   205|         )
   206|         single.shell.send(trans_tar, "{}/salt_state.tgz".format(opts["thin_dir"]))
   207|         stdout, stderr, retcode = single.cmd_block()
   208|         try:
   209|             os.remove(trans_tar)
   210|         except OSError:
   211|             pass
   212|         return {"local": salt.client.ssh.wrapper.parse_ret(stdout, stderr, retcode)}
   213| def running(concurrent=False):
   214|     """
   215|     Return a list of strings that contain state return data if a state function
   216|     is already running. This function is used to prevent multiple state calls
   217|     from being run at the same time.
   218|     CLI Example:
   219|     .. code-block:: bash
   220|         salt '*' state.running
   221|     """
   222|     ret = []
   223|     if concurrent:
   224|         return ret
   225|     active = __salt__["saltutil.is_running"]("state.*")
   226|     for data in active:
   227|         err = (
   228|             'The function "{}" is running as PID {} and was started at {} '
   229|             "with jid {}".format(
   230|                 data["fun"],
   231|                 data["pid"],
   232|                 salt.utils.jid.jid_to_time(data["jid"]),

# --- HUNK 3: Lines 276-348 ---
   276|     __opts__["grains"] = __grains__.value()
   277|     chunks = [data]
   278|     with salt.client.ssh.state.SSHHighState(
   279|         __opts__,
   280|         None,
   281|         __salt__.value(),
   282|         __context__["fileclient"],
   283|         context=__context__.value(),
   284|         initial_pillar=__pillar__.value(),
   285|     ) as st_:
   286|         for chunk in chunks:
   287|             chunk["__id__"] = (
   288|                 chunk["name"] if not chunk.get("__id__") else chunk["__id__"]
   289|             )
   290|         err = st_.state.verify_data(data)
   291|         if err:
   292|             return err
   293|         file_refs = salt.client.ssh.state.lowstate_file_refs(
   294|             chunks,
   295|             _merge_extra_filerefs(
   296|                 kwargs.get("extra_filerefs", ""),
   297|                 __opts__.get("extra_filerefs", ""),
   298|                 __context__.get("_cp_extra_filerefs", ""),
   299|             ),
   300|         )
   301|         roster = salt.roster.Roster(__opts__, __opts__.get("roster", "flat"))
   302|         roster_grains = roster.opts["grains"]
   303|         trans_tar = salt.client.ssh.state.prep_trans_tar(
   304|             __context__["fileclient"],
   305|             chunks,
   306|             file_refs,
   307|             __pillar__.value(),
   308|             st_kwargs["id_"],
   309|             roster_grains,
   310|         )
   311|         trans_tar_sum = salt.utils.hashutils.get_hash(trans_tar, __opts__["hash_type"])
   312|         cmd = "state.pkg {}/salt_state.tgz pkg_sum={} hash_type={}".format(
   313|             __opts__["thin_dir"], trans_tar_sum, __opts__["hash_type"]
   314|         )
   315|         single = salt.client.ssh.Single(
   316|             __opts__,
   317|             cmd,
   318|             fsclient=__context__["fileclient"],
   319|             minion_opts=__salt__.minion_opts,
   320|             **st_kwargs,
   321|         )
   322|         single.shell.send(trans_tar, "{}/salt_state.tgz".format(__opts__["thin_dir"]))
   323|         stdout, stderr, retcode = single.cmd_block()
   324|         try:
   325|             os.remove(trans_tar)
   326|         except OSError:
   327|             pass
   328|         return {"local": salt.client.ssh.wrapper.parse_ret(stdout, stderr, retcode)}
   329| def _get_test_value(test=None, **kwargs):
   330|     """
   331|     Determine the correct value for the test flag.
   332|     """
   333|     ret = True
   334|     if test is None:
   335|         if salt.utils.args.test_mode(test=test, **kwargs):
   336|             ret = True
   337|         else:
   338|             ret = __opts__.get("test", None)
   339|     else:
   340|         ret = test
   341|     return ret
   342| def high(data, **kwargs):
   343|     """
   344|     Execute the compound calls stored in a single set of high data
   345|     This function is mostly intended for testing the state system
   346|     CLI Example:
   347|     .. code-block:: bash
   348|         salt '*' state.high '{"vim": {"pkg": ["installed"]}}'

# --- HUNK 4: Lines 354-427 ---
   354|     initial_pillar = _get_initial_pillar(opts)
   355|     with salt.client.ssh.state.SSHHighState(
   356|         opts,
   357|         pillar_override,
   358|         __salt__.value(),
   359|         __context__["fileclient"],
   360|         context=__context__.value(),
   361|         initial_pillar=initial_pillar,
   362|     ) as st_:
   363|         try:
   364|             pillar = st_.opts["pillar"].value()
   365|         except AttributeError:
   366|             pillar = st_.opts["pillar"]
   367|         if pillar_override is not None or initial_pillar is None:
   368|             __pillar__.update(pillar)
   369|         st_.push_active()
   370|         chunks = st_.state.compile_high_data(data)
   371|         file_refs = salt.client.ssh.state.lowstate_file_refs(
   372|             chunks,
   373|             _merge_extra_filerefs(
   374|                 kwargs.get("extra_filerefs", ""),
   375|                 opts.get("extra_filerefs", ""),
   376|                 __context__.get("_cp_extra_filerefs", ""),
   377|             ),
   378|         )
   379|         roster = salt.roster.Roster(opts, opts.get("roster", "flat"))
   380|         roster_grains = roster.opts["grains"]
   381|         _cleanup_slsmod_low_data(chunks)
   382|         trans_tar = salt.client.ssh.state.prep_trans_tar(
   383|             __context__["fileclient"],
   384|             chunks,
   385|             file_refs,
   386|             pillar,
   387|             st_kwargs["id_"],
   388|             roster_grains,
   389|         )
   390|         trans_tar_sum = salt.utils.hashutils.get_hash(trans_tar, opts["hash_type"])
   391|         cmd = "state.pkg {}/salt_state.tgz pkg_sum={} hash_type={}".format(
   392|             opts["thin_dir"], trans_tar_sum, opts["hash_type"]
   393|         )
   394|         single = salt.client.ssh.Single(
   395|             opts,
   396|             cmd,
   397|             fsclient=__context__["fileclient"],
   398|             minion_opts=__salt__.minion_opts,
   399|             **st_kwargs,
   400|         )
   401|         single.shell.send(trans_tar, "{}/salt_state.tgz".format(opts["thin_dir"]))
   402|         stdout, stderr, retcode = single.cmd_block()
   403|         try:
   404|             os.remove(trans_tar)
   405|         except OSError:
   406|             pass
   407|         return {"local": salt.client.ssh.wrapper.parse_ret(stdout, stderr, retcode)}
   408| def apply_(mods=None, **kwargs):
   409|     """
   410|     .. versionadded:: 2015.5.3
   411|     Apply states! This function will call highstate or state.sls based on the
   412|     arguments passed in, state.apply is intended to be the main gateway for
   413|     all state executions.
   414|     CLI Example:
   415|     .. code-block:: bash
   416|         salt '*' state.apply
   417|         salt '*' state.apply test
   418|         salt '*' state.apply test,pkgs
   419|     """
   420|     if mods:
   421|         return sls(mods, **kwargs)
   422|     return highstate(**kwargs)
   423| def request(mods=None, **kwargs):
   424|     """
   425|     .. versionadded:: 2017.7.3
   426|     Request that the local admin execute a state run via
   427|     `salt-call state.run_request`

# --- HUNK 5: Lines 553-630 ---
   553|         __context__["fileclient"],
   554|         context=__context__.value(),
   555|         initial_pillar=initial_pillar,
   556|     ) as st_:
   557|         if not _check_pillar(kwargs, st_.opts["pillar"]):
   558|             __context__["retcode"] = salt.defaults.exitcodes.EX_PILLAR_FAILURE
   559|             err = ["Pillar failed to render with the following messages:"]
   560|             err += st_.opts["pillar"]["_errors"]
   561|             return err
   562|         try:
   563|             pillar = st_.opts["pillar"].value()
   564|         except AttributeError:
   565|             pillar = st_.opts["pillar"]
   566|         if pillar_override is not None or initial_pillar is None:
   567|             __pillar__.update(pillar)
   568|         st_.push_active()
   569|         chunks = st_.compile_low_chunks(context=__context__.value())
   570|         file_refs = salt.client.ssh.state.lowstate_file_refs(
   571|             chunks,
   572|             _merge_extra_filerefs(
   573|                 kwargs.get("extra_filerefs", ""),
   574|                 opts.get("extra_filerefs", ""),
   575|                 __context__.get("_cp_extra_filerefs", ""),
   576|             ),
   577|         )
   578|         for chunk in chunks:
   579|             if not isinstance(chunk, dict):
   580|                 __context__["retcode"] = salt.defaults.exitcodes.EX_STATE_COMPILER_ERROR
   581|                 return chunks
   582|         roster = salt.roster.Roster(opts, opts.get("roster", "flat"))
   583|         roster_grains = roster.opts["grains"]
   584|         _cleanup_slsmod_low_data(chunks)
   585|         trans_tar = salt.client.ssh.state.prep_trans_tar(
   586|             __context__["fileclient"],
   587|             chunks,
   588|             file_refs,
   589|             pillar,
   590|             st_kwargs["id_"],
   591|             roster_grains,
   592|         )
   593|         trans_tar_sum = salt.utils.hashutils.get_hash(trans_tar, opts["hash_type"])
   594|         cmd = "state.pkg {}/salt_state.tgz test={} pkg_sum={} hash_type={}".format(
   595|             opts["thin_dir"], test, trans_tar_sum, opts["hash_type"]
   596|         )
   597|         single = salt.client.ssh.Single(
   598|             opts,
   599|             cmd,
   600|             fsclient=__context__["fileclient"],
   601|             minion_opts=__salt__.minion_opts,
   602|             **st_kwargs,
   603|         )
   604|         single.shell.send(trans_tar, "{}/salt_state.tgz".format(opts["thin_dir"]))
   605|         stdout, stderr, retcode = single.cmd_block()
   606|         try:
   607|             os.remove(trans_tar)
   608|         except OSError:
   609|             pass
   610|         return {"local": salt.client.ssh.wrapper.parse_ret(stdout, stderr, retcode)}
   611| def top(topfn, test=None, **kwargs):
   612|     """
   613|     Execute a specific top file instead of the default
   614|     CLI Example:
   615|     .. code-block:: bash
   616|         salt '*' state.top reverse_top.sls
   617|         salt '*' state.top reverse_top.sls exclude=sls_to_exclude
   618|         salt '*' state.top reverse_top.sls exclude="[{'id': 'id_to_exclude'}, {'sls': 'sls_to_exclude'}]"
   619|     """
   620|     st_kwargs = __salt__.kwargs
   621|     __opts__["grains"] = __grains__.value()
   622|     opts = salt.utils.state.get_sls_opts(__opts__, **kwargs)
   623|     opts["test"] = _get_test_value(test, **kwargs)
   624|     pillar_override = kwargs.get("pillar")
   625|     initial_pillar = _get_initial_pillar(opts)
   626|     with salt.client.ssh.state.SSHHighState(
   627|         opts,
   628|         pillar_override,
   629|         __salt__.value(),
   630|         __context__["fileclient"],

# --- HUNK 6: Lines 635-708 ---
   635|             __context__["retcode"] = salt.defaults.exitcodes.EX_PILLAR_FAILURE
   636|             err = ["Pillar failed to render with the following messages:"]
   637|             err += st_.opts["pillar"]["_errors"]
   638|             return err
   639|         try:
   640|             pillar = st_.opts["pillar"].value()
   641|         except AttributeError:
   642|             pillar = st_.opts["pillar"]
   643|         if pillar_override is not None or initial_pillar is None:
   644|             __pillar__.update(pillar)
   645|         st_.opts["state_top"] = os.path.join("salt://", topfn)
   646|         st_.push_active()
   647|         chunks = st_.compile_low_chunks(context=__context__.value())
   648|         for chunk in chunks:
   649|             if not isinstance(chunk, dict):
   650|                 __context__["retcode"] = salt.defaults.exitcodes.EX_STATE_COMPILER_ERROR
   651|                 return chunks
   652|         file_refs = salt.client.ssh.state.lowstate_file_refs(
   653|             chunks,
   654|             _merge_extra_filerefs(
   655|                 kwargs.get("extra_filerefs", ""),
   656|                 opts.get("extra_filerefs", ""),
   657|                 __context__.get("_cp_extra_filerefs", ""),
   658|             ),
   659|         )
   660|         roster = salt.roster.Roster(opts, opts.get("roster", "flat"))
   661|         roster_grains = roster.opts["grains"]
   662|         _cleanup_slsmod_low_data(chunks)
   663|         trans_tar = salt.client.ssh.state.prep_trans_tar(
   664|             __context__["fileclient"],
   665|             chunks,
   666|             file_refs,
   667|             pillar,
   668|             st_kwargs["id_"],
   669|             roster_grains,
   670|         )
   671|         trans_tar_sum = salt.utils.hashutils.get_hash(trans_tar, opts["hash_type"])
   672|         cmd = "state.pkg {}/salt_state.tgz test={} pkg_sum={} hash_type={}".format(
   673|             opts["thin_dir"], test, trans_tar_sum, opts["hash_type"]
   674|         )
   675|         single = salt.client.ssh.Single(
   676|             opts,
   677|             cmd,
   678|             fsclient=__context__["fileclient"],
   679|             minion_opts=__salt__.minion_opts,
   680|             **st_kwargs,
   681|         )
   682|         single.shell.send(trans_tar, "{}/salt_state.tgz".format(opts["thin_dir"]))
   683|         stdout, stderr, retcode = single.cmd_block()
   684|         try:
   685|             os.remove(trans_tar)
   686|         except OSError:
   687|             pass
   688|         return {"local": salt.client.ssh.wrapper.parse_ret(stdout, stderr, retcode)}
   689| def show_highstate(**kwargs):
   690|     """
   691|     Retrieve the highstate data from the salt master and display it
   692|     CLI Example:
   693|     .. code-block:: bash
   694|         salt '*' state.show_highstate
   695|     """
   696|     __opts__["grains"] = __grains__.value()
   697|     opts = salt.utils.state.get_sls_opts(__opts__, **kwargs)
   698|     pillar_override = kwargs.get("pillar")
   699|     initial_pillar = _get_initial_pillar(opts)
   700|     with salt.client.ssh.state.SSHHighState(
   701|         opts,
   702|         pillar_override,
   703|         __salt__,
   704|         __context__["fileclient"],
   705|         context=__context__.value(),
   706|         initial_pillar=initial_pillar,
   707|     ) as st_:
   708|         if not _check_pillar(kwargs, st_.opts["pillar"]):

# --- HUNK 7: Lines 805-844 ---
   805|         st_.push_active()
   806|         high_, errors = st_.render_highstate(
   807|             {opts["saltenv"]: split_mods}, context=__context__.value()
   808|         )
   809|         errors += st_.state.verify_high(high_)
   810|         high_, req_in_errors = st_.state.requisite_in(high_)
   811|         if req_in_errors:
   812|             errors.extend(req_in_errors)
   813|         if errors:
   814|             __context__["retcode"] = salt.defaults.exitcodes.EX_STATE_COMPILER_ERROR
   815|             return errors
   816|         chunks = st_.state.compile_high_data(high_)
   817|         chunk = [x for x in chunks if x.get("__id__", "") == id_]
   818|         if not chunk:
   819|             raise SaltInvocationError(
   820|                 "No matches for ID '{}' found in SLS '{}' within saltenv '{}'".format(
   821|                     id_, mods, opts["saltenv"]
   822|                 )
   823|             )
   824|         ret = _ssh_state(chunk, st_kwargs, kwargs, pillar, test=test)
   825|         __opts__["test"] = orig_test
   826|         return ret
   827| def show_sls(mods, saltenv="base", test=None, **kwargs):
   828|     """
   829|     Display the state data from a specific sls or list of sls files on the
   830|     master
   831|     CLI Example:
   832|     .. code-block:: bash
   833|         salt '*' state.show_sls core,edit.vim dev
   834|     """
   835|     __opts__["grains"] = __grains__.value()
   836|     opts = salt.utils.state.get_sls_opts(__opts__, **kwargs)
   837|     opts["test"] = _get_test_value(test, **kwargs)
   838|     pillar_override = kwargs.get("pillar")
   839|     initial_pillar = _get_initial_pillar(opts)
   840|     with salt.client.ssh.state.SSHHighState(
   841|         opts,
   842|         pillar_override,
   843|         __salt__,
   844|         __context__["fileclient"],

# --- HUNK 8: Lines 974-1036 ---
   974|         return "Invalid function passed"
   975|     kwargs.update({"state": comps[0], "fun": comps[1], "__id__": name, "name": name})
   976|     opts = salt.utils.state.get_sls_opts(__opts__, **kwargs)
   977|     opts["test"] = _get_test_value(test, **kwargs)
   978|     pillar_override = kwargs.pop("pillar", None)
   979|     st_ = salt.client.ssh.state.SSHState(
   980|         opts, pillar_override, initial_pillar=_get_initial_pillar(opts)
   981|     )
   982|     try:
   983|         pillar = st_.opts["pillar"].value()
   984|     except AttributeError:
   985|         pillar = st_.opts["pillar"]
   986|     err = st_.verify_data(kwargs)
   987|     if err:
   988|         __context__["retcode"] = salt.defaults.exitcodes.EX_STATE_COMPILER_ERROR
   989|         return err
   990|     chunks = [kwargs]
   991|     file_refs = salt.client.ssh.state.lowstate_file_refs(
   992|         chunks,
   993|         _merge_extra_filerefs(
   994|             kwargs.get("extra_filerefs", ""),
   995|             opts.get("extra_filerefs", ""),
   996|             __context__.get("_cp_extra_filerefs", ""),
   997|         ),
   998|     )
   999|     roster = salt.roster.Roster(opts, opts.get("roster", "flat"))
  1000|     roster_grains = roster.opts["grains"]
  1001|     trans_tar = salt.client.ssh.state.prep_trans_tar(
  1002|         __context__["fileclient"],
  1003|         chunks,
  1004|         file_refs,
  1005|         pillar,
  1006|         st_kwargs["id_"],
  1007|         roster_grains,
  1008|     )
  1009|     trans_tar_sum = salt.utils.hashutils.get_hash(trans_tar, opts["hash_type"])
  1010|     cmd = "state.pkg {}/salt_state.tgz test={} pkg_sum={} hash_type={}".format(
  1011|         opts["thin_dir"], test, trans_tar_sum, opts["hash_type"]
  1012|     )
  1013|     single = salt.client.ssh.Single(
  1014|         opts,
  1015|         cmd,
  1016|         fsclient=__context__["fileclient"],
  1017|         minion_opts=__salt__.minion_opts,
  1018|         **st_kwargs,
  1019|     )
  1020|     single.shell.send(trans_tar, "{}/salt_state.tgz".format(opts["thin_dir"]))
  1021|     stdout, stderr, retcode = single.cmd_block()
  1022|     try:
  1023|         os.remove(trans_tar)
  1024|     except OSError:
  1025|         pass
  1026|     return {"local": salt.client.ssh.wrapper.parse_ret(stdout, stderr, retcode)}
  1027| def test(*args, **kwargs):
  1028|     """
  1029|     .. versionadded:: 3001
  1030|     Alias for `state.apply` with the kwarg `test` forced to `True`.
  1031|     This is a nicety to avoid the need to type out `test=True` and the possibility of
  1032|     a typo causing changes you do not intend.
  1033|     """
  1034|     kwargs["test"] = True
  1035|     ret = apply_(*args, **kwargs)
  1036|     return ret


# ====================================================================
# FILE: salt/cloud/__init__.py
# Total hunks: 5
# ====================================================================
# --- HUNK 1: Lines 15-61 ---
    15| import salt.config
    16| import salt.loader
    17| import salt.syspaths
    18| import salt.utils.args
    19| import salt.utils.cloud
    20| import salt.utils.context
    21| import salt.utils.crypt
    22| import salt.utils.data
    23| import salt.utils.dictupdate
    24| import salt.utils.files
    25| import salt.utils.user
    26| import salt.utils.verify
    27| import salt.utils.yaml
    28| from salt.exceptions import (
    29|     SaltCloudConfigError,
    30|     SaltCloudException,
    31|     SaltCloudNotFound,
    32|     SaltCloudSystemExit,
    33| )
    34| from salt.template import compile_template
    35| try:
    36|     import Cryptodome.Random
    37| except ImportError:
    38|     try:
    39|         import Crypto.Random  # nosec
    40|     except ImportError:
    41|         pass  # pycrypto < 2.1
    42| log = logging.getLogger(__name__)
    43| def communicator(func):
    44|     """Warning, this is a picklable decorator !"""
    45|     def _call(queue, args, kwargs):
    46|         """called with [queue, args, kwargs] as first optional arg"""
    47|         kwargs["queue"] = queue
    48|         ret = None
    49|         try:
    50|             ret = func(*args, **kwargs)
    51|             queue.put("END")
    52|         except KeyboardInterrupt as ex:
    53|             trace = traceback.format_exc()
    54|             queue.put("KEYBOARDINT")
    55|             queue.put("Keyboard interrupt")
    56|             queue.put(f"{ex}\n{trace}\n")
    57|         except Exception as ex:  # pylint: disable=broad-except
    58|             trace = traceback.format_exc()
    59|             queue.put("ERROR")
    60|             queue.put("Exception")
    61|             queue.put(f"{ex}\n{trace}\n")

# --- HUNK 2: Lines 1054-1099 ---
  1054|         except KeyError:
  1055|             opt_map = False
  1056|         if self.opts["parallel"] and self.opts["start_action"] and not opt_map:
  1057|             log.info("Running %s on %s", self.opts["start_action"], vm_["name"])
  1058|             with salt.client.get_local_client(mopts=self.opts) as client:
  1059|                 action_out = client.cmd(
  1060|                     vm_["name"],
  1061|                     self.opts["start_action"],
  1062|                     timeout=self.opts["timeout"] * 60,
  1063|                 )
  1064|             output["ret"] = action_out
  1065|         return output
  1066|     @staticmethod
  1067|     def vm_config(name, main, provider, profile, overrides):
  1068|         """
  1069|         Create vm config.
  1070|         :param str name: The name of the vm
  1071|         :param dict main: The main cloud config
  1072|         :param dict provider: The provider config
  1073|         :param dict profile: The profile config
  1074|         :param dict overrides: a special dict that carries per-node options overrides (see CloudConfig:profile() documentation)
  1075|         """
  1076|         vm = main.copy()
  1077|         vm = salt.utils.dictupdate.update(vm, provider)
  1078|         vm = salt.utils.dictupdate.update(vm, profile)
  1079|         vm = salt.utils.dictupdate.update(vm, overrides.get(name, {}))
  1080|         vm["name"] = name
  1081|         return vm
  1082|     def extras(self, extra_):
  1083|         """
  1084|         Extra actions
  1085|         """
  1086|         output = {}
  1087|         alias, driver = extra_["provider"].split(":")
  1088|         fun = "{}.{}".format(driver, extra_["action"])
  1089|         if fun not in self.clouds:
  1090|             log.error(
  1091|                 "Creating '%s' using '%s' as the provider "
  1092|                 "cannot complete since '%s' is not available",
  1093|                 extra_["name"],
  1094|                 extra_["provider"],
  1095|                 driver,
  1096|             )
  1097|             return
  1098|         try:
  1099|             with salt.utils.context.func_globals_inject(

# --- HUNK 3: Lines 1852-1943 ---
  1852|                             )
  1853|                         )
  1854|                 for obj in output_multip:
  1855|                     next(iter(obj.values()))["ret"] = out[next(iter(obj.keys()))]
  1856|                     output.update(obj)
  1857|             else:
  1858|                 for obj in output_multip:
  1859|                     output.update(obj)
  1860|         return output
  1861| def init_pool_worker():
  1862|     """
  1863|     Make every worker ignore KeyboarInterrup's since it will be handled by the
  1864|     parent process.
  1865|     """
  1866|     signal.signal(signal.SIGINT, signal.SIG_IGN)
  1867| def create_multiprocessing(parallel_data, queue=None):
  1868|     """
  1869|     This function will be called from another process when running a map in
  1870|     parallel mode. The result from the create is always a json object.
  1871|     """
  1872|     salt.utils.crypt.reinit_crypto()
  1873|     parallel_data["opts"]["output"] = "json"
  1874|     cloud = Cloud(parallel_data["opts"])
  1875|     try:
  1876|         output = cloud.create(
  1877|             parallel_data["profile"], local_master=parallel_data["local_master"]
  1878|         )
  1879|     except SaltCloudException as exc:
  1880|         log.error(
  1881|             "Failed to deploy '%s'. Error: %s",
  1882|             parallel_data["name"],
  1883|             exc,
  1884|             exc_info_on_loglevel=logging.DEBUG,
  1885|         )
  1886|         return {parallel_data["name"]: {"Error": str(exc)}}
  1887|     if parallel_data["opts"].get("show_deploy_args", False) is False and isinstance(
  1888|         output, dict
  1889|     ):
  1890|         output.pop("deploy_kwargs", None)
  1891|     return {parallel_data["name"]: salt.utils.data.simple_types_filter(output)}
  1892| def destroy_multiprocessing(parallel_data, queue=None):
  1893|     """
  1894|     This function will be called from another process when running a map in
  1895|     parallel mode. The result from the destroy is always a json object.
  1896|     """
  1897|     salt.utils.crypt.reinit_crypto()
  1898|     parallel_data["opts"]["output"] = "json"
  1899|     clouds = salt.loader.clouds(parallel_data["opts"])
  1900|     try:
  1901|         fun = clouds["{}.destroy".format(parallel_data["driver"])]
  1902|         with salt.utils.context.func_globals_inject(
  1903|             fun,
  1904|             __active_provider_name__=":".join(
  1905|                 [parallel_data["alias"], parallel_data["driver"]]
  1906|             ),
  1907|         ):
  1908|             output = fun(parallel_data["name"])
  1909|     except SaltCloudException as exc:
  1910|         log.error(
  1911|             "Failed to destroy %s. Error: %s",
  1912|             parallel_data["name"],
  1913|             exc,
  1914|             exc_info_on_loglevel=logging.DEBUG,
  1915|         )
  1916|         return {parallel_data["name"]: {"Error": str(exc)}}
  1917|     return {parallel_data["name"]: salt.utils.data.simple_types_filter(output)}
  1918| def run_parallel_map_providers_query(data, queue=None):
  1919|     """
  1920|     This function will be called from another process when building the
  1921|     providers map.
  1922|     """
  1923|     salt.utils.crypt.reinit_crypto()
  1924|     cloud = Cloud(data["opts"])
  1925|     try:
  1926|         with salt.utils.context.func_globals_inject(
  1927|             cloud.clouds[data["fun"]],
  1928|             __active_provider_name__=":".join([data["alias"], data["driver"]]),
  1929|         ):
  1930|             return (
  1931|                 data["alias"],
  1932|                 data["driver"],
  1933|                 salt.utils.data.simple_types_filter(cloud.clouds[data["fun"]]()),
  1934|             )
  1935|     except Exception as err:  # pylint: disable=broad-except
  1936|         log.debug(
  1937|             "Failed to execute '%s()' while querying for running nodes: %s",
  1938|             data["fun"],
  1939|             err,
  1940|             exc_info_on_loglevel=logging.DEBUG,
  1941|         )
  1942|         return data["alias"], data["driver"], ()
  1943| def _run_parallel_map_providers_query(*args, **kw):


# ====================================================================
# FILE: salt/cloud/clouds/clc.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 226-266 ---
   226| def avail_locations(call=None):
   227|     """
   228|     returns a list of locations available to you
   229|     """
   230|     creds = get_creds()
   231|     clc.v1.SetCredentials(creds["token"], creds["token_pass"])
   232|     locations = clc.v1.Account.GetLocations()
   233|     return locations
   234| def avail_sizes(call=None):
   235|     """
   236|     use templates for this
   237|     """
   238|     return {"Sizes": "Sizes are built into templates. Choose appropriate template"}
   239| def get_build_status(req_id, nodename):
   240|     """
   241|     get the build status from CLC to make sure we don't return to early
   242|     """
   243|     counter = 0
   244|     req_id = str(req_id)
   245|     while counter < 10:
   246|         queue = clc.v1.Blueprint.GetStatus(request_id=(req_id))
   247|         if queue["PercentComplete"] == 100:
   248|             server_name = queue["Servers"][0]
   249|             creds = get_creds()
   250|             clc.v2.SetCredentials(creds["user"], creds["password"])
   251|             ip_addresses = clc.v2.Server(server_name).ip_addresses
   252|             internal_ip_address = ip_addresses[0]["internal"]
   253|             return internal_ip_address
   254|         else:
   255|             counter = counter + 1
   256|             log.info(
   257|                 "Creating Cloud VM %s Time out in %s minutes",
   258|                 nodename,
   259|                 str(10 - counter),
   260|             )
   261|             time.sleep(60)
   262| def create(vm_):
   263|     """
   264|     get the system build going
   265|     """
   266|     creds = get_creds()


# ====================================================================
# FILE: salt/cloud/clouds/digitalocean.py
# Total hunks: 6
# ====================================================================
# --- HUNK 1: Lines 260-331 ---
   260|     if key_filename is not None and not os.path.isfile(key_filename):
   261|         raise SaltCloudConfigError(
   262|             f"The defined key_filename '{key_filename}' does not exist"
   263|         )
   264|     if not __opts__.get("ssh_agent", False) and key_filename is None:
   265|         raise SaltCloudConfigError(
   266|             "The DigitalOcean driver requires an ssh_key_file and an ssh_key_name "
   267|             "because it does not supply a root password upon building the server."
   268|         )
   269|     ssh_interface = config.get_cloud_config_value(
   270|         "ssh_interface", vm_, __opts__, search_global=False, default="public"
   271|     )
   272|     if ssh_interface in ["private", "public"]:
   273|         log.info("ssh_interface: Setting interface for ssh to %s", ssh_interface)
   274|         kwargs["ssh_interface"] = ssh_interface
   275|     else:
   276|         raise SaltCloudConfigError(
   277|             "The DigitalOcean driver requires ssh_interface to be defined as 'public'"
   278|             " or 'private'."
   279|         )
   280|     vpc_name = config.get_cloud_config_value(
   281|         "vpc_name",
   282|         vm_,
   283|         __opts__,
   284|         search_global=False,
   285|         default=None,
   286|     )
   287|     if vpc_name is not None:
   288|         vpc = _get_vpc_by_name(vpc_name)
   289|         if vpc is None:
   290|             raise SaltCloudConfigError("Invalid VPC name provided")
   291|         else:
   292|             kwargs["vpc_uuid"] = vpc[vpc_name]["id"]
   293|     else:
   294|         private_networking = config.get_cloud_config_value(
   295|             "private_networking",
   296|             vm_,
   297|             __opts__,
   298|             search_global=False,
   299|             default=None,
   300|         )
   301|         if private_networking is not None:
   302|             if not isinstance(private_networking, bool):
   303|                 raise SaltCloudConfigError(
   304|                     "'private_networking' should be a boolean value."
   305|                 )
   306|             kwargs["private_networking"] = private_networking
   307|         if not private_networking and ssh_interface == "private":
   308|             raise SaltCloudConfigError(
   309|                 "The DigitalOcean driver requires ssh_interface if defined as 'private' "
   310|                 "then private_networking should be set as 'True'."
   311|             )
   312|     backups_enabled = config.get_cloud_config_value(
   313|         "backups_enabled",
   314|         vm_,
   315|         __opts__,
   316|         search_global=False,
   317|         default=None,
   318|     )
   319|     if backups_enabled is not None:
   320|         if not isinstance(backups_enabled, bool):
   321|             raise SaltCloudConfigError("'backups_enabled' should be a boolean value.")
   322|         kwargs["backups"] = backups_enabled
   323|     ipv6 = config.get_cloud_config_value(
   324|         "ipv6",
   325|         vm_,
   326|         __opts__,
   327|         search_global=False,
   328|         default=None,
   329|     )
   330|     if ipv6 is not None:
   331|         if not isinstance(ipv6, bool):

# --- HUNK 2: Lines 380-422 ---
   380|         dns_hostname = config.get_cloud_config_value(
   381|             "dns_hostname",
   382|             vm_,
   383|             __opts__,
   384|             search_global=False,
   385|             default=default_dns_hostname,
   386|         )
   387|         dns_domain = config.get_cloud_config_value(
   388|             "dns_domain",
   389|             vm_,
   390|             __opts__,
   391|             search_global=False,
   392|             default=default_dns_domain,
   393|         )
   394|         if dns_hostname and dns_domain:
   395|             log.info(
   396|                 'create_dns_record: using dns_hostname="%s", dns_domain="%s"',
   397|                 dns_hostname,
   398|                 dns_domain,
   399|             )
   400|             __add_dns_addr__ = lambda t, d: post_dns_record(
   401|                 dns_domain=dns_domain, name=dns_hostname, record_type=t, record_data=d
   402|             )
   403|             log.debug("create_dns_record: %s", __add_dns_addr__)
   404|         else:
   405|             log.error(
   406|                 "create_dns_record: could not determine dns_hostname and/or dns_domain"
   407|             )
   408|             raise SaltCloudConfigError(
   409|                 "'create_dns_record' must be a dict specifying \"domain\" "
   410|                 'and "hostname" or the minion name must be an FQDN.'
   411|             )
   412|     __utils__["cloud.fire_event"](
   413|         "event",
   414|         "requesting instance",
   415|         "salt/cloud/{}/requesting".format(vm_["name"]),
   416|         args=__utils__["cloud.filter_event"]("requesting", kwargs, list(kwargs)),
   417|         sock_dir=__opts__["sock_dir"],
   418|         transport=__opts__["transport"],
   419|     )
   420|     try:
   421|         ret = create_node(kwargs)
   422|     except Exception as exc:  # pylint: disable=broad-except

# --- HUNK 3: Lines 497-561 ---
   497|         ),
   498|         sock_dir=__opts__["sock_dir"],
   499|         transport=__opts__["transport"],
   500|     )
   501|     return ret
   502| def query(
   503|     method="droplets", droplet_id=None, command=None, args=None, http_method="get"
   504| ):
   505|     """
   506|     Make a web call to DigitalOcean
   507|     """
   508|     base_path = str(
   509|         config.get_cloud_config_value(
   510|             "api_root",
   511|             get_configured_provider(),
   512|             __opts__,
   513|             search_global=False,
   514|             default="https://api.digitalocean.com/v2",
   515|         )
   516|     )
   517|     if method == "vpcs":
   518|         path = f"{base_path}/{method}"
   519|     else:
   520|         path = f"{base_path}/{method}/"
   521|     if droplet_id:
   522|         path += f"{droplet_id}/"
   523|     if command:
   524|         path += command
   525|     if not isinstance(args, dict):
   526|         args = {}
   527|     personal_access_token = config.get_cloud_config_value(
   528|         "personal_access_token",
   529|         get_configured_provider(),
   530|         __opts__,
   531|         search_global=False,
   532|     )
   533|     data = salt.utils.json.dumps(args)
   534|     requester = getattr(requests, http_method)
   535|     request = requester(
   536|         path,
   537|         data=data,
   538|         headers={
   539|             "Authorization": "Bearer " + personal_access_token,
   540|             "Content-Type": "application/json",
   541|         },
   542|     )
   543|     if request.status_code > 299:
   544|         raise SaltCloudSystemExit(
   545|             "An error occurred while querying DigitalOcean. HTTP Code: {}  "
   546|             "Error: '{}'".format(
   547|                 request.status_code,
   548|                 request.text,
   549|             )
   550|         )
   551|     log.debug(request.url)
   552|     if request.status_code == 204:
   553|         return True
   554|     content = request.text
   555|     result = salt.utils.json.loads(content)
   556|     if result.get("status", "").lower() == "error":
   557|         raise SaltCloudSystemExit(pprint.pformat(result.get("error_message", {})))
   558|     return result
   559| def script(vm_):
   560|     """
   561|     Return the script deployment object

# --- HUNK 4: Lines 773-813 ---
   773|                 "data": kwargs["record_data"],
   774|             },
   775|             http_method="post",
   776|         )
   777|         return result
   778|     return False
   779| def destroy_dns_records(fqdn):
   780|     """
   781|     Deletes DNS records for the given hostname if the domain is managed with DO.
   782|     """
   783|     domain = ".".join(fqdn.split(".")[-2:])
   784|     hostname = ".".join(fqdn.split(".")[:-2])
   785|     try:
   786|         response = query(method="domains", droplet_id=domain, command="records")
   787|     except SaltCloudSystemExit:
   788|         log.debug("Failed to find domains.")
   789|         return False
   790|     log.debug("found DNS records: %s", pprint.pformat(response))
   791|     records = response["domain_records"]
   792|     if records:
   793|         record_ids = [r["id"] for r in records if r["name"] == hostname]
   794|         log.debug("deleting DNS record IDs: %s", record_ids)
   795|         for id_ in record_ids:
   796|             try:
   797|                 log.info("deleting DNS record %s", id_)
   798|                 ret = query(
   799|                     method="domains",
   800|                     droplet_id=domain,
   801|                     command=f"records/{id_}",
   802|                     http_method="delete",
   803|                 )
   804|             except SaltCloudSystemExit:
   805|                 log.error(
   806|                     "failed to delete DNS domain %s record ID %s.", domain, hostname
   807|                 )
   808|             log.debug("DNS deletion REST call returned: %s", pprint.pformat(ret))
   809|     return False
   810| def show_pricing(kwargs=None, call=None):
   811|     """
   812|     Show pricing for a particular profile. This is only an estimate, based on
   813|     unofficial pricing sources.

# --- HUNK 5: Lines 971-1051 ---
   971|     .. code-block:: bash
   972|         salt-cloud -f unassign_floating_ip my-digitalocean-config floating_ip='45.55.96.47'
   973|     """
   974|     if call != "function":
   975|         log.error(
   976|             "The inassign_floating_ip function must be called with -f or --function."
   977|         )
   978|         return False
   979|     if not kwargs:
   980|         kwargs = {}
   981|     if "floating_ip" not in kwargs:
   982|         log.error("A floating IP is required.")
   983|         return False
   984|     result = query(
   985|         method="floating_ips",
   986|         command=kwargs["floating_ip"] + "/actions",
   987|         args={"type": "unassign"},
   988|         http_method="post",
   989|     )
   990|     return result
   991| def _get_vpc_by_name(name):
   992|     """
   993|     Helper function to format and parse vpc data. It's pretty expensive as it
   994|     retrieves a list of vpcs and iterates through them till it finds the correct
   995|     vpc by name.
   996|     """
   997|     fetch = True
   998|     page = 1
   999|     ret = {}
  1000|     log.debug("Matching vpc name with: %s", name)
  1001|     while fetch:
  1002|         items = query(method="vpcs", command=f"?page={str(page)}&per_page=200")
  1003|         for node in items["vpcs"]:
  1004|             log.debug("Node returned : %s", node["name"])
  1005|             if name == node["name"]:
  1006|                 log.debug("Matched VPC node")
  1007|                 ret[name] = {
  1008|                     "id": node["id"],
  1009|                     "urn": node["urn"],
  1010|                     "name": name,
  1011|                     "description": node["description"],
  1012|                     "region": node["region"],
  1013|                     "ip_range": node["ip_range"],
  1014|                     "default": node["default"],
  1015|                 }
  1016|                 return ret
  1017|         page += 1
  1018|         try:
  1019|             fetch = "next" in items["links"]["pages"]
  1020|         except KeyError:
  1021|             fetch = False
  1022|     return None
  1023| def _list_nodes(full=False, for_output=False):
  1024|     """
  1025|     Helper function to format and parse node data.
  1026|     """
  1027|     fetch = True
  1028|     page = 1
  1029|     ret = {}
  1030|     while fetch:
  1031|         items = query(method="droplets", command=f"?page={str(page)}&per_page=200")
  1032|         for node in items["droplets"]:
  1033|             name = node["name"]
  1034|             ret[name] = {}
  1035|             if full:
  1036|                 ret[name] = _get_full_output(node, for_output=for_output)
  1037|             else:
  1038|                 public_ips, private_ips = _get_ips(node["networks"])
  1039|                 ret[name] = {
  1040|                     "id": node["id"],
  1041|                     "image": node["image"]["name"],
  1042|                     "name": name,
  1043|                     "private_ips": private_ips,
  1044|                     "public_ips": public_ips,
  1045|                     "size": node["size_slug"],
  1046|                     "state": str(node["status"]),
  1047|                 }
  1048|         page += 1
  1049|         try:
  1050|             fetch = "next" in items["links"]["pages"]
  1051|         except KeyError:


# ====================================================================
# FILE: salt/cloud/clouds/linode.py
# Total hunks: 10
# ====================================================================
# --- HUNK 1: Lines 1-138 ---
     1| r"""
     2| The Linode Cloud Module
     3| =======================
     4| The Linode cloud module is used to interact with the Linode Cloud.
     5| Provider
     6| --------
     7| The following provider parameters are supported:
     8| - **apikey**: (required) The key to use to authenticate with the Linode API.
     9| - **password**: (required) The default password to set on new VMs. Must be 8 characters with at least one lowercase, uppercase, and numeric.
    10| - **poll_interval**: (optional) The rate of time in milliseconds to poll the Linode API for changes. Defaults to ``500``.
    11| - **ratelimit_sleep**: (optional) The time in seconds to wait before retrying after a ratelimit has been enforced. Defaults to ``0``.
    12| .. note::
    13|     APIv3 usage has been removed in favor of APIv4. To move to APIv4 now,
    14|     See the full migration guide
    15|     here https://docs.saltproject.io/en/latest/topics/cloud/linode.html#migrating-to-apiv4.
    16| Set up the provider configuration at ``/etc/salt/cloud.providers`` or ``/etc/salt/cloud.providers.d/linode.conf``:
    17| .. code-block:: yaml
    18|     my-linode-provider:
    19|         driver: linode
    20|         apikey: f4ZsmwtB1c7f85Jdu43RgXVDFlNjuJaeIYV8QMftTqKScEB2vSosFSr...
    21|         password: F00barbazverylongp@ssword
    22| Profile
    23| -------
    24| The following profile parameters are supported:
    25| - **size**: (required) The size of the VM. This should be a Linode instance type ID (i.e. ``g6-standard-2``). Run ``salt-cloud -f avail_sizes my-linode-provider`` for options.
    26| - **location**: (required) The location of the VM. This should be a Linode region (e.g. ``us-east``). Run ``salt-cloud -f avail_locations my-linode-provider`` for options.
    27| - **image**: (required) The image to deploy the boot disk from. This should be an image ID (e.g. ``linode/ubuntu22.04``); official images start with ``linode/``. Run ``salt-cloud -f avail_images my-linode-provider`` for more options.
    28| - **password**: (\*required) The default password for the VM. Must be provided at the profile or provider level.
    29| - **assign_private_ip**: (optional) Whether or not to assign a private IP to the VM. Defaults to ``False``.
    30| - **backups_enabled**: (optional) Whether or not to enable the backup for this VM. Backup can be configured in your Linode account Defaults to ``False``.
    31| - **ssh_interface**: (optional) The interface with which to connect over SSH. Valid options are ``private_ips`` or ``public_ips``. Defaults to ``public_ips``.
    32| - **ssh_pubkey**: (optional) The public key to authorize for SSH with the VM.
    33| - **swap**: (optional) The amount of disk space to allocate for the swap partition. Defaults to ``256``.
    34| - **clonefrom**: (optional) The name of the Linode to clone from.
    35| Set up a profile configuration in ``/etc/salt/cloud.profiles.d/``:
    36| .. code-block:: yaml
    37|     my-linode-profile:
    38|         provider: my-linode-provider
    39|         size: g6-standard-1
    40|         image: linode/ubuntu22.04
    41|         location: us-east
    42|     my-linode-profile-advanced:
    43|         provider: my-linode-provider
    44|         size: g6-standard-3
    45|         image: linode/ubuntu22.04
    46|         location: eu-west
    47|         password: bogus123X
    48|         assign_private_ip: true
    49|         ssh_interface: private_ips
    50|         ssh_pubkey: ssh-rsa AAAAB3NzaC1yc2EAAAADAQAB...
    51|         swap_size: 512
    52| Migrating to APIv4
    53| ------------------
    54| You will need to generate a new token for your account. See https://www.linode.com/docs/products/tools/api/get-started/#create-an-api-token
    55| There are a few changes to note:
    56| - There has been a general move from label references to ID references. The profile configuration parameters ``location``, ``size``, and ``image`` have moved from being label based references to IDs. See the profile section for more information. In addition to these inputs being changed, ``avail_sizes``, ``avail_locations``, and ``avail_images`` now output options sorted by ID instead of label.
    57| - The ``disk_size`` profile configuration parameter has been deprecated and will not be taken into account when creating new VMs while targeting APIv4.
    58| :maintainer: Linode Developer Tools and Experience Team <dev-dx@linode.com>
    59| :depends: requests
    60| """
    61| import datetime
    62| import json
    63| import logging
    64| import pprint
    65| import re
    66| import time
    67| from abc import ABC, abstractmethod
    68| from pathlib import Path
    69| import salt.config as config
    70| from salt._compat import ipaddress
    71| from salt.exceptions import SaltCloudException, SaltCloudNotFound, SaltCloudSystemExit
    72| try:
    73|     import requests
    74|     HAS_REQUESTS = True
    75| except ImportError:
    76|     HAS_REQUESTS = False
    77| log = logging.getLogger(__name__)
    78| LASTCALL = int(time.mktime(datetime.datetime.now().timetuple()))
    79| __virtualname__ = "linode"
    80| def __virtual__():
    81|     """
    82|     Check for Linode configs.
    83|     """
    84|     if get_configured_provider() is False:
    85|         return False
    86|     if _get_dependencies() is False:
    87|         return False
    88|     return __virtualname__
    89| def _get_active_provider_name():
    90|     try:
    91|         return __active_provider_name__.value()
    92|     except AttributeError:
    93|         return __active_provider_name__
    94| def _get_backup_enabled(vm_):
    95|     """
    96|     Return True if a backup is set to enabled
    97|     """
    98|     return config.get_cloud_config_value(
    99|         "backups_enabled",
   100|         vm_,
   101|         __opts__,
   102|         default=False,
   103|     )
   104| def get_configured_provider():
   105|     """
   106|     Return the first configured instance.
   107|     """
   108|     return config.is_provider_configured(
   109|         __opts__,
   110|         _get_active_provider_name() or __virtualname__,
   111|         ("apikey", "password"),
   112|     )
   113| def _get_dependencies():
   114|     """
   115|     Warn if dependencies aren't met.
   116|     """
   117|     deps = {"requests": HAS_REQUESTS}
   118|     return config.check_driver_dependencies(__virtualname__, deps)
   119| def _get_api_key():
   120|     """
   121|     Returned the configured Linode API key.
   122|     """
   123|     val = config.get_cloud_config_value(
   124|         "api_key",
   125|         get_configured_provider(),
   126|         __opts__,
   127|         search_global=False,
   128|         default=config.get_cloud_config_value(
   129|             "apikey", get_configured_provider(), __opts__, search_global=False
   130|         ),
   131|     )
   132|     return val
   133| def _get_ratelimit_sleep():
   134|     """
   135|     Return the configured time to wait before retrying after a ratelimit has been enforced.
   136|     """
   137|     return config.get_cloud_config_value(
   138|         "ratelimit_sleep",

# --- HUNK 2: Lines 149-188 ---
   149|         "poll_interval",
   150|         get_configured_provider(),
   151|         __opts__,
   152|         search_global=False,
   153|         default=500,
   154|     )
   155| def _get_password(vm_):
   156|     r"""
   157|     Return the password to use for a VM.
   158|     vm\_
   159|         The configuration to obtain the password from.
   160|     """
   161|     return config.get_cloud_config_value(
   162|         "password",
   163|         vm_,
   164|         __opts__,
   165|         default=config.get_cloud_config_value(
   166|             "passwd", vm_, __opts__, search_global=False
   167|         ),
   168|         search_global=False,
   169|     )
   170| def _get_private_ip(vm_):
   171|     """
   172|     Return True if a private ip address is requested
   173|     """
   174|     return config.get_cloud_config_value(
   175|         "assign_private_ip", vm_, __opts__, default=False
   176|     )
   177| def _get_ssh_key_files(vm_):
   178|     """
   179|     Return the configured file paths of the SSH keys.
   180|     """
   181|     return config.get_cloud_config_value(
   182|         "ssh_key_files", vm_, __opts__, search_global=False, default=[]
   183|     )
   184| def _get_ssh_key(vm_):
   185|     r"""
   186|     Return the SSH pubkey.
   187|     vm\_
   188|         The configuration to obtain the public key from.

# --- HUNK 3: Lines 225-365 ---
   225|     .. versionadded:: 2015.5.6
   226|     name
   227|         The VM name to validate
   228|     """
   229|     name = str(name)
   230|     name_length = len(name)
   231|     regex = re.compile(r"^[a-zA-Z0-9][A-Za-z0-9_-]*[a-zA-Z0-9]$")
   232|     if name_length < 3 or name_length > 48:
   233|         ret = False
   234|     elif not re.match(regex, name):
   235|         ret = False
   236|     else:
   237|         ret = True
   238|     if ret is False:
   239|         log.warning(
   240|             "A Linode label may only contain ASCII letters or numbers, dashes, and "
   241|             "underscores, must begin and end with letters or numbers, and be at least "
   242|             "three characters in length."
   243|         )
   244|     return ret
   245| class LinodeAPI(ABC):
   246|     @abstractmethod
   247|     def avail_images(self):
   248|         """avail_images implementation"""
   249|     @abstractmethod
   250|     def avail_locations(self):
   251|         """avail_locations implementation"""
   252|     @abstractmethod
   253|     def avail_sizes(self):
   254|         """avail_sizes implementation"""
   255|     @abstractmethod
   256|     def boot(self, name=None, kwargs=None):
   257|         """boot implementation"""
   258|     @abstractmethod
   259|     def clone(self, kwargs=None):
   260|         """clone implementation"""
   261|     @abstractmethod
   262|     def create_config(self, kwargs=None):
   263|         """create_config implementation"""
   264|     @abstractmethod
   265|     def create(self, vm_):
   266|         """create implementation"""
   267|     @abstractmethod
   268|     def destroy(self, name):
   269|         """destroy implementation"""
   270|     @abstractmethod
   271|     def get_config_id(self, kwargs=None):
   272|         """get_config_id implementation"""
   273|     @abstractmethod
   274|     def list_nodes(self):
   275|         """list_nodes implementation"""
   276|     @abstractmethod
   277|     def list_nodes_full(self):
   278|         """list_nodes_full implementation"""
   279|     @abstractmethod
   280|     def list_nodes_min(self):
   281|         """list_nodes_min implementation"""
   282|     @abstractmethod
   283|     def reboot(self, name):
   284|         """reboot implementation"""
   285|     @abstractmethod
   286|     def show_instance(self, name):
   287|         """show_instance implementation"""
   288|     @abstractmethod
   289|     def show_pricing(self, kwargs=None):
   290|         """show_pricing implementation"""
   291|     @abstractmethod
   292|     def start(self, name):
   293|         """start implementation"""
   294|     @abstractmethod
   295|     def stop(self, name):
   296|         """stop implementation"""
   297|     @abstractmethod
   298|     def _get_linode_by_name(self, name):
   299|         """_get_linode_by_name implementation"""
   300|     @abstractmethod
   301|     def _get_linode_by_id(self, linode_id):
   302|         """_get_linode_by_id implementation"""
   303|     def get_linode(self, kwargs=None):
   304|         name = kwargs.get("name", None)
   305|         linode_id = kwargs.get("linode_id", None)
   306|         if linode_id is not None:
   307|             return self._get_linode_by_id(linode_id)
   308|         elif name is not None:
   309|             return self._get_linode_by_name(name)
   310|         raise SaltCloudSystemExit(
   311|             "The get_linode function requires either a 'name' or a 'linode_id'."
   312|         )
   313|     def list_nodes_select(self, call):
   314|         return __utils__["cloud.list_nodes_select"](
   315|             self.list_nodes_full(),
   316|             __opts__["query.selection"],
   317|             call,
   318|         )
   319| class LinodeAPIv4(LinodeAPI):
   320|     @classmethod
   321|     def get_api_instance(cls):
   322|         if not hasattr(cls, "api_instance"):
   323|             cls.api_instance = cls()
   324|         return cls.api_instance
   325|     def _query(self, path, method="GET", data=None, headers=None):
   326|         """
   327|         Make a call to the Linode API.
   328|         """
   329|         api_key = _get_api_key()
   330|         ratelimit_sleep = _get_ratelimit_sleep()
   331|         if headers is None:
   332|             headers = {}
   333|         headers["Authorization"] = f"Bearer {api_key}"
   334|         headers["Content-Type"] = "application/json"
   335|         headers["User-Agent"] = "salt-cloud-linode"
   336|         url = f"https://api.linode.com/v4{path}"
   337|         decode = method != "DELETE"
   338|         result = None
   339|         log.debug("Linode API request: %s %s", method, url)
   340|         if data is not None:
   341|             log.trace("Linode API request body: %s", data)
   342|         attempt = 0
   343|         while True:
   344|             try:
   345|                 result = requests.request(method, url, json=data, headers=headers)
   346|                 log.debug("Linode API response status code: %d", result.status_code)
   347|                 log.trace("Linode API response body: %s", result.text)
   348|                 result.raise_for_status()
   349|                 break
   350|             except requests.exceptions.HTTPError as exc:
   351|                 err_response = exc.response
   352|                 err_data = self._get_response_json(err_response)
   353|                 status_code = err_response.status_code
   354|                 if status_code == 429:
   355|                     log.debug(
   356|                         "received rate limit; retrying in %d seconds", ratelimit_sleep
   357|                     )
   358|                     time.sleep(ratelimit_sleep)
   359|                     continue
   360|                 if err_data is not None:
   361|                     if "error" in err_data:
   362|                         raise SaltCloudSystemExit(
   363|                             "Linode API reported error: {}".format(err_data["error"])
   364|                         )
   365|                     elif "errors" in err_data:

# --- HUNK 4: Lines 384-463 ---
   384|             return self._get_response_json(result)
   385|         return result
   386|     def avail_images(self):
   387|         response = self._query(path="/images")
   388|         ret = {}
   389|         for image in response["data"]:
   390|             ret[image["id"]] = image
   391|         return ret
   392|     def avail_locations(self):
   393|         response = self._query(path="/regions")
   394|         ret = {}
   395|         for region in response["data"]:
   396|             ret[region["id"]] = region
   397|         return ret
   398|     def avail_sizes(self):
   399|         response = self._query(path="/linode/types")
   400|         ret = {}
   401|         for instance_type in response["data"]:
   402|             ret[instance_type["id"]] = instance_type
   403|         return ret
   404|     def set_backup_schedule(self, label, linode_id, day, window, auto_enable=False):
   405|         instance = self.get_linode(kwargs={"linode_id": linode_id, "name": label})
   406|         linode_id = instance.get("id", None)
   407|         if auto_enable:
   408|             backups = instance.get("backups")
   409|             if backups and not backups.get("enabled"):
   410|                 self._query(
   411|                     f"/linode/instances/{linode_id}/backups/enable",
   412|                     method="POST",
   413|                 )
   414|         self._query(
   415|             f"/linode/instances/{linode_id}",
   416|             method="PUT",
   417|             data={"backups": {"schedule": {"day": day, "window": window}}},
   418|         )
   419|     def boot(self, name=None, kwargs=None):
   420|         instance = self.get_linode(
   421|             kwargs={"linode_id": kwargs.get("linode_id", None), "name": name}
   422|         )
   423|         config_id = kwargs.get("config_id", None)
   424|         check_running = kwargs.get("check_running", True)
   425|         linode_id = instance.get("id", None)
   426|         name = instance.get("label", None)
   427|         if check_running:
   428|             if instance["status"] == "running":
   429|                 raise SaltCloudSystemExit(
   430|                     "Cannot boot Linode {0} ({1}). "
   431|                     "Linode {0} is already running.".format(name, linode_id)
   432|                 )
   433|         self._query(
   434|             f"/linode/instances/{linode_id}/boot",
   435|             method="POST",
   436|             data={"config_id": config_id},
   437|         )
   438|         self._wait_for_linode_status(linode_id, "running")
   439|         return True
   440|     def clone(self, kwargs=None):
   441|         linode_id = kwargs.get("linode_id", None)
   442|         location = kwargs.get("location", None)
   443|         size = kwargs.get("size", None)
   444|         for item in [linode_id, location, size]:
   445|             if item is None:
   446|                 raise SaltCloudSystemExit(
   447|                     "The clone function requires a 'linode_id', 'location',"
   448|                     "and 'size' to be provided."
   449|                 )
   450|         return self._query(
   451|             f"/linode/instances/{linode_id}/clone",
   452|             method="POST",
   453|             data={"region": location, "type": size},
   454|         )
   455|     def create_config(self, kwargs=None):
   456|         name = kwargs.get("name", None)
   457|         linode_id = kwargs.get("linode_id", None)
   458|         root_disk_id = kwargs.get("root_disk_id", None)
   459|         swap_disk_id = kwargs.get("swap_disk_id", None)
   460|         data_disk_id = kwargs.get("data_disk_id", None)
   461|         if not name and not linode_id:
   462|             raise SaltCloudSystemExit(
   463|                 "The create_config function requires either a 'name' or 'linode_id'"

# --- HUNK 5: Lines 484-549 ---
   484|         if not _validate_name(name):
   485|             return False
   486|         __utils__["cloud.fire_event"](
   487|             "event",
   488|             "starting create",
   489|             f"salt/cloud/{name}/creating",
   490|             args=__utils__["cloud.filter_event"](
   491|                 "creating", vm_, ["name", "profile", "provider", "driver"]
   492|             ),
   493|             sock_dir=__opts__["sock_dir"],
   494|             transport=__opts__["transport"],
   495|         )
   496|         log.info("Creating Cloud VM %s", name)
   497|         result = None
   498|         pub_ssh_keys = _get_ssh_keys(vm_)
   499|         ssh_interface = _get_ssh_interface(vm_)
   500|         use_private_ip = ssh_interface == "private_ips"
   501|         assign_private_ip = _get_private_ip(vm_) or use_private_ip
   502|         password = _get_password(vm_)
   503|         swap_size = _get_swap_size(vm_)
   504|         backups_enabled = _get_backup_enabled(vm_)
   505|         clonefrom_name = vm_.get("clonefrom", None)
   506|         instance_type = vm_.get("size", None)
   507|         image = vm_.get("image", None)
   508|         should_clone = True if clonefrom_name else False
   509|         if should_clone:
   510|             clone_linode = self.get_linode(kwargs={"name": clonefrom_name})
   511|             result = clone(
   512|                 {
   513|                     "linode_id": clone_linode["id"],
   514|                     "location": clone_linode["region"],
   515|                     "size": clone_linode["type"],
   516|                 }
   517|             )
   518|             if assign_private_ip:
   519|                 self._query(
   520|                     "/networking/ips",
   521|                     method="POST",
   522|                     data={"type": "ipv4", "public": False, "linode_id": result["id"]},
   523|                 )
   524|         else:
   525|             result = self._query(
   526|                 "/linode/instances",
   527|                 method="POST",
   528|                 data={
   529|                     "backups_enabled": backups_enabled,
   530|                     "label": name,
   531|                     "type": instance_type,
   532|                     "region": vm_.get("location", None),
   533|                     "private_ip": assign_private_ip,
   534|                     "booted": True,
   535|                     "root_pass": password,
   536|                     "authorized_keys": pub_ssh_keys,
   537|                     "image": image,
   538|                     "swap_size": swap_size,
   539|                 },
   540|             )
   541|         linode_id = result.get("id", None)
   542|         self._wait_for_event("linode_create", "linode", linode_id, "finished")
   543|         log.debug("linode '%s' has been created", name)
   544|         if should_clone:
   545|             self.boot(kwargs={"linode_id": linode_id})
   546|         self._wait_for_linode_status(linode_id, "running")
   547|         public_ips, private_ips = self._get_ips(linode_id)
   548|         data = {}
   549|         data["id"] = linode_id

# --- HUNK 6: Lines 781-1220 ---
   781|         status = event.get("status")
   782|         action = event.get("action")
   783|         entity = event.get("entity")
   784|         if status == "failed":
   785|             raise SaltCloudSystemExit(
   786|                 "event {} for {} (id={}) failed".format(
   787|                     action, entity["type"], entity["id"]
   788|                 )
   789|             )
   790|         return status == desired_status
   791|     def _wait_for_event(self, action, entity, entity_id, status, timeout=None):
   792|         event_filter = {
   793|             "+order_by": "created",
   794|             "+order": "desc",
   795|             "seen": False,
   796|             "action": action,
   797|             "entity.id": entity_id,
   798|             "entity.type": entity,
   799|         }
   800|         last_event = None
   801|         condition = lambda event: self._check_event_status(event, status)
   802|         while True:
   803|             if last_event is not None:
   804|                 event_filter["+gt"] = last_event
   805|             filter_json = json.dumps(event_filter, separators=(",", ":"))
   806|             result = self._query("/account/events", headers={"X-Filter": filter_json})
   807|             events = result.get("data", [])
   808|             if len(events) == 0:
   809|                 break
   810|             for event in events:
   811|                 event_id = event.get("id")
   812|                 event_entity = event.get("entity", None)
   813|                 last_event = event_id
   814|                 if not event_entity:
   815|                     continue
   816|                 if not (
   817|                     event_entity["type"] == entity
   818|                     and event_entity["id"] == entity_id
   819|                     and event.get("action") == action
   820|                 ):
   821|                     continue
   822|                 if condition(event):
   823|                     return True
   824|                 return self._poll(
   825|                     f"event {event_id} to be '{status}'",
   826|                     lambda: self._query(f"/account/events/{event_id}"),
   827|                     condition,
   828|                     timeout=timeout,
   829|                 )
   830|         return False
   831|     def _get_response_json(self, response):
   832|         json = None
   833|         try:
   834|             json = response.json()
   835|         except ValueError:
   836|             pass
   837|         return json
   838| def avail_images(call=None):
   839|     """
   840|     Return available Linode images.
   841|     CLI Example:
   842|     .. code-block:: bash
   843|         salt-cloud --list-images my-linode-config
   844|         salt-cloud -f avail_images my-linode-config
   845|     """
   846|     if call == "action":
   847|         raise SaltCloudException(
   848|             "The avail_images function must be called with -f or --function."
   849|         )
   850|     return LinodeAPIv4.get_api_instance().avail_images()
   851| def avail_locations(call=None):
   852|     """
   853|     Return available Linode datacenter locations.
   854|     CLI Example:
   855|     .. code-block:: bash
   856|         salt-cloud --list-locations my-linode-config
   857|         salt-cloud -f avail_locations my-linode-config
   858|     """
   859|     if call == "action":
   860|         raise SaltCloudException(
   861|             "The avail_locations function must be called with -f or --function."
   862|         )
   863|     return LinodeAPIv4.get_api_instance().avail_locations()
   864| def avail_sizes(call=None):
   865|     """
   866|     Return available Linode sizes.
   867|     CLI Example:
   868|     .. code-block:: bash
   869|         salt-cloud --list-sizes my-linode-config
   870|         salt-cloud -f avail_sizes my-linode-config
   871|     """
   872|     if call == "action":
   873|         raise SaltCloudException(
   874|             "The avail_locations function must be called with -f or --function."
   875|         )
   876|     return LinodeAPIv4.get_api_instance().avail_sizes()
   877| def set_backup_schedule(name=None, kwargs=None, call=None):
   878|     """
   879|     Set the backup schedule for a Linode.
   880|     name
   881|         The name (label) of the Linode. Can be used instead of
   882|         ``linode_id``.
   883|     linode_id
   884|         The ID of the Linode instance to set the backup schedule for.
   885|         If provided, will be used as an alternative to ``name`` and
   886|         reduces the number of API calls to Linode by one. Will be
   887|         preferred over ``name``.
   888|     auto_enable
   889|         If ``True``, automatically enable the backup feature for the Linode
   890|         if it wasn't already enabled. Optional parameter, default to ``False``.
   891|     day
   892|         Possible values:
   893|         ``Sunday``, ``Monday``, ``Tuesday``, ``Wednesday``,
   894|         ``Thursday``, ``Friday``, ``Saturday``
   895|         The day of the week that your Linode's weekly Backup is taken.
   896|         If not set manually, a day will be chosen for you. Backups are
   897|         taken every day, but backups taken on this day are preferred
   898|         when selecting backups to retain for a longer period.
   899|         If not set manually, then when backups are initially enabled,
   900|         this may come back as ``Scheduling`` until the day is automatically
   901|         selected.
   902|     window
   903|         Possible values:
   904|         ``W0``, ``W2``, ``W4``, ``W6``, ``W8``, ``W10``,
   905|         ``W12``, ``W14``, ``W16``, ``W18``, ``W20``, ``W22``
   906|         The window in which your backups will be taken, in UTC. A backups
   907|         window is a two-hour span of time in which the backup may occur.
   908|         For example, ``W10`` indicates that your backups should be taken
   909|         between 10:00 and 12:00. If you do not choose a backup window, one
   910|         will be selected for you automatically.
   911|         If not set manually, when backups are initially enabled this may come
   912|         back as ``Scheduling`` until the window is automatically selected.
   913|     Can be called as an action (which requires a name):
   914|     .. code-block:: bash
   915|         salt-cloud -a set_backup_schedule my-linode-instance day=Monday window=W20 auto_enable=True
   916|     ...or as a function (which requires either a name or linode_id):
   917|     .. code-block:: bash
   918|         salt-cloud -f set_backup_schedule my-linode-provider name=my-linode-instance day=Monday window=W20 auto_enable=True
   919|         salt-cloud -f set_backup_schedule my-linode-provider linode_id=1225876 day=Monday window=W20 auto_enable=True
   920|     """
   921|     if name is None and call == "action":
   922|         raise SaltCloudSystemExit(
   923|             "The set_backup_schedule backup schedule "
   924|             "action requires the name of the Linode.",
   925|         )
   926|     if kwargs is None:
   927|         kwargs = {}
   928|     if call == "function":
   929|         name = kwargs.get("name", None)
   930|     linode_id = kwargs.get("linode_id")
   931|     auto_enable = str(kwargs.get("auto_enable")).lower() == "true"
   932|     if name is None and linode_id is None:
   933|         raise SaltCloudSystemExit(
   934|             "The set_backup_schedule function requires "
   935|             "either a 'name' or a 'linode_id'."
   936|         )
   937|     return LinodeAPIv4.get_api_instance().set_backup_schedule(
   938|         day=kwargs.get("day"),
   939|         window=kwargs.get("window"),
   940|         label=name,
   941|         linode_id=linode_id,
   942|         auto_enable=auto_enable,
   943|     )
   944| def boot(name=None, kwargs=None, call=None):
   945|     """
   946|     Boot a Linode.
   947|     name
   948|         The name of the Linode to boot. Can be used instead of ``linode_id``.
   949|     linode_id
   950|         The ID of the Linode to boot. If provided, will be used as an
   951|         alternative to ``name`` and reduces the number of API calls to
   952|         Linode by one. Will be preferred over ``name``.
   953|     config_id
   954|         The ID of the Config to boot. Required.
   955|     check_running
   956|         Defaults to True. If set to False, overrides the call to check if
   957|         the VM is running before calling the linode.boot API call. Change
   958|         ``check_running`` to True is useful during the boot call in the
   959|         create function, since the new VM will not be running yet.
   960|     Can be called as an action (which requires a name):
   961|     .. code-block:: bash
   962|         salt-cloud -a boot my-instance config_id=10
   963|     ...or as a function (which requires either a name or linode_id):
   964|     .. code-block:: bash
   965|         salt-cloud -f boot my-linode-config name=my-instance config_id=10
   966|         salt-cloud -f boot my-linode-config linode_id=1225876 config_id=10
   967|     """
   968|     if name is None and call == "action":
   969|         raise SaltCloudSystemExit("The boot action requires a 'name'.")
   970|     linode_id = kwargs.get("linode_id", None)
   971|     config_id = kwargs.get("config_id", None)
   972|     if call == "function":
   973|         name = kwargs.get("name", None)
   974|     if name is None and linode_id is None:
   975|         raise SaltCloudSystemExit(
   976|             "The boot function requires either a 'name' or a 'linode_id'."
   977|         )
   978|     return LinodeAPIv4.get_api_instance().boot(name=name, kwargs=kwargs)
   979| def clone(kwargs=None, call=None):
   980|     """
   981|     Clone a Linode.
   982|     linode_id
   983|         The ID of the Linode to clone. Required.
   984|     location
   985|         The location of the new Linode. Required.
   986|     size
   987|         The size of the new Linode (must be greater than or equal to the clone source). Required.
   988|     CLI Example:
   989|     .. code-block:: bash
   990|         salt-cloud -f clone my-linode-config linode_id=1234567 location=us-central size=g6-standard-1
   991|     """
   992|     if call == "action":
   993|         raise SaltCloudSystemExit(
   994|             "The clone function must be called with -f or --function."
   995|         )
   996|     return LinodeAPIv4.get_api_instance().clone(kwargs=kwargs)
   997| def create(vm_):
   998|     """
   999|     Create a single Linode VM.
  1000|     """
  1001|     try:
  1002|         if (
  1003|             vm_["profile"]
  1004|             and config.is_profile_configured(
  1005|                 __opts__,
  1006|                 _get_active_provider_name() or "linode",
  1007|                 vm_["profile"],
  1008|                 vm_=vm_,
  1009|             )
  1010|         ) is False:
  1011|             return False
  1012|     except AttributeError:
  1013|         pass
  1014|     return LinodeAPIv4.get_api_instance().create(vm_)
  1015| def create_config(kwargs=None, call=None):
  1016|     """
  1017|     Creates a Linode Configuration Profile.
  1018|     name
  1019|         The name of the VM to create the config for.
  1020|     linode_id
  1021|         The ID of the Linode to create the configuration for.
  1022|     root_disk_id
  1023|         The Root Disk ID to be used for this config.
  1024|     swap_disk_id
  1025|         The Swap Disk ID to be used for this config.
  1026|     data_disk_id
  1027|         The Data Disk ID to be used for this config.
  1028|     .. versionadded:: 2016.3.0
  1029|     kernel_id
  1030|         The ID of the kernel to use for this configuration profile.
  1031|     """
  1032|     if call == "action":
  1033|         raise SaltCloudSystemExit(
  1034|             "The create_config function must be called with -f or --function."
  1035|         )
  1036|     return LinodeAPIv4.get_api_instance().create_config(kwargs=kwargs)
  1037| def destroy(name, call=None):
  1038|     """
  1039|     Destroys a Linode by name.
  1040|     name
  1041|         The name of VM to be be destroyed.
  1042|     CLI Example:
  1043|     .. code-block:: bash
  1044|         salt-cloud -d vm_name
  1045|     """
  1046|     if call == "function":
  1047|         raise SaltCloudException(
  1048|             "The destroy action must be called with -d, --destroy, -a or --action."
  1049|         )
  1050|     return LinodeAPIv4.get_api_instance().destroy(name)
  1051| def get_config_id(kwargs=None, call=None):
  1052|     """
  1053|     Returns a config_id for a given linode.
  1054|     .. versionadded:: 2015.8.0
  1055|     name
  1056|         The name of the Linode for which to get the config_id. Can be used instead
  1057|         of ``linode_id``.
  1058|     linode_id
  1059|         The ID of the Linode for which to get the config_id. Can be used instead
  1060|         of ``name``.
  1061|     CLI Example:
  1062|     .. code-block:: bash
  1063|         salt-cloud -f get_config_id my-linode-config name=my-linode
  1064|         salt-cloud -f get_config_id my-linode-config linode_id=1234567
  1065|     """
  1066|     if call == "action":
  1067|         raise SaltCloudException(
  1068|             "The get_config_id function must be called with -f or --function."
  1069|         )
  1070|     return LinodeAPIv4.get_api_instance().get_config_id(kwargs=kwargs)
  1071| def get_linode(kwargs=None, call=None):
  1072|     """
  1073|     Returns data for a single named Linode.
  1074|     name
  1075|         The name of the Linode for which to get data. Can be used instead
  1076|         ``linode_id``. Note this will induce an additional API call
  1077|         compared to using ``linode_id``.
  1078|     linode_id
  1079|         The ID of the Linode for which to get data. Can be used instead of
  1080|         ``name``.
  1081|     CLI Example:
  1082|     .. code-block:: bash
  1083|         salt-cloud -f get_linode my-linode-config name=my-instance
  1084|         salt-cloud -f get_linode my-linode-config linode_id=1234567
  1085|     """
  1086|     if call == "action":
  1087|         raise SaltCloudSystemExit(
  1088|             "The get_linode function must be called with -f or --function."
  1089|         )
  1090|     return LinodeAPIv4.get_api_instance().get_linode(kwargs=kwargs)
  1091| def list_nodes(call=None):
  1092|     """
  1093|     Returns a list of linodes, keeping only a brief listing.
  1094|     CLI Example:
  1095|     .. code-block:: bash
  1096|         salt-cloud -Q
  1097|         salt-cloud --query
  1098|         salt-cloud -f list_nodes my-linode-config
  1099|     .. note::
  1100|         The ``image`` label only displays information about the VM's distribution vendor,
  1101|         such as "Debian" or "RHEL" and does not display the actual image name. This is
  1102|         due to a limitation of the Linode API.
  1103|     """
  1104|     if call == "action":
  1105|         raise SaltCloudException(
  1106|             "The list_nodes function must be called with -f or --function."
  1107|         )
  1108|     return LinodeAPIv4.get_api_instance().list_nodes()
  1109| def list_nodes_full(call=None):
  1110|     """
  1111|     List linodes, with all available information.
  1112|     CLI Example:
  1113|     .. code-block:: bash
  1114|         salt-cloud -F
  1115|         salt-cloud --full-query
  1116|         salt-cloud -f list_nodes_full my-linode-config
  1117|     .. note::
  1118|         The ``image`` label only displays information about the VM's distribution vendor,
  1119|         such as "Debian" or "RHEL" and does not display the actual image name. This is
  1120|         due to a limitation of the Linode API.
  1121|     """
  1122|     if call == "action":
  1123|         raise SaltCloudException(
  1124|             "The list_nodes_full function must be called with -f or --function."
  1125|         )
  1126|     return LinodeAPIv4.get_api_instance().list_nodes_full()
  1127| def list_nodes_min(call=None):
  1128|     """
  1129|     Return a list of the VMs that are on the provider. Only a list of VM names and
  1130|     their state is returned. This is the minimum amount of information needed to
  1131|     check for existing VMs.
  1132|     .. versionadded:: 2015.8.0
  1133|     CLI Example:
  1134|     .. code-block:: bash
  1135|         salt-cloud -f list_nodes_min my-linode-config
  1136|         salt-cloud --function list_nodes_min my-linode-config
  1137|     """
  1138|     if call == "action":
  1139|         raise SaltCloudSystemExit(
  1140|             "The list_nodes_min function must be called with -f or --function."
  1141|         )
  1142|     return LinodeAPIv4.get_api_instance().list_nodes_min()
  1143| def list_nodes_select(call=None):
  1144|     """
  1145|     Return a list of the VMs that are on the provider, with select fields.
  1146|     """
  1147|     return LinodeAPIv4.get_api_instance().list_nodes_select(call)
  1148| def reboot(name, call=None):
  1149|     """
  1150|     Reboot a linode.
  1151|     .. versionadded:: 2015.8.0
  1152|     name
  1153|         The name of the VM to reboot.
  1154|     CLI Example:
  1155|     .. code-block:: bash
  1156|         salt-cloud -a reboot vm_name
  1157|     """
  1158|     if call != "action":
  1159|         raise SaltCloudException(
  1160|             "The show_instance action must be called with -a or --action."
  1161|         )
  1162|     return LinodeAPIv4.get_api_instance().reboot(name)
  1163| def show_instance(name, call=None):
  1164|     """
  1165|     Displays details about a particular Linode VM. Either a name or a linode_id must
  1166|     be provided.
  1167|     .. versionadded:: 2015.8.0
  1168|     name
  1169|         The name of the VM for which to display details.
  1170|     CLI Example:
  1171|     .. code-block:: bash
  1172|         salt-cloud -a show_instance vm_name
  1173|     .. note::
  1174|         The ``image`` label only displays information about the VM's distribution vendor,
  1175|         such as "Debian" or "RHEL" and does not display the actual image name. This is
  1176|         due to a limitation of the Linode API.
  1177|     """
  1178|     if call != "action":
  1179|         raise SaltCloudException(
  1180|             "The show_instance action must be called with -a or --action."
  1181|         )
  1182|     return LinodeAPIv4.get_api_instance().show_instance(name)
  1183| def show_pricing(kwargs=None, call=None):
  1184|     """
  1185|     Show pricing for a particular profile. This is only an estimate, based on
  1186|     unofficial pricing sources.
  1187|     .. versionadded:: 2015.8.0
  1188|     CLI Example:
  1189|     .. code-block:: bash
  1190|         salt-cloud -f show_pricing my-linode-config profile=my-linode-profile
  1191|     """
  1192|     if call != "function":
  1193|         raise SaltCloudException(
  1194|             "The show_instance action must be called with -f or --function."
  1195|         )
  1196|     return LinodeAPIv4.get_api_instance().show_pricing(kwargs=kwargs)
  1197| def start(name, call=None):
  1198|     """
  1199|     Start a VM in Linode.
  1200|     name
  1201|         The name of the VM to start.
  1202|     CLI Example:
  1203|     .. code-block:: bash
  1204|         salt-cloud -a stop vm_name
  1205|     """
  1206|     if call != "action":
  1207|         raise SaltCloudException("The start action must be called with -a or --action.")
  1208|     return LinodeAPIv4.get_api_instance().start(name)
  1209| def stop(name, call=None):
  1210|     """
  1211|     Stop a VM in Linode.
  1212|     name
  1213|         The name of the VM to stop.
  1214|     CLI Example:
  1215|     .. code-block:: bash
  1216|         salt-cloud -a stop vm_name
  1217|     """
  1218|     if call != "action":
  1219|         raise SaltCloudException("The stop action must be called with -a or --action.")
  1220|     return LinodeAPIv4.get_api_instance().stop(name)


# ====================================================================
# FILE: salt/cloud/clouds/proxmox.py
# Total hunks: 5
# ====================================================================
# --- HUNK 1: Lines 1-75 ---
     1| """
     2| Proxmox Cloud Module
     3| ======================
     4| .. versionadded:: 2014.7.0
     5| The Proxmox cloud module is used to control access to cloud providers using
     6| the Proxmox system (KVM / OpenVZ / LXC).
     7| Set up the cloud configuration at ``/etc/salt/cloud.providers`` or
     8|  ``/etc/salt/cloud.providers.d/proxmox.conf``:
     9| .. code-block:: yaml
    10|     my-proxmox-config:
    11|       user: myuser@pam or myuser@pve
    12|       password: mypassword
    13|       url: hypervisor.domain.tld
    14|       port: 8006
    15|       driver: proxmox
    16|       verify_ssl: True
    17| .. warning::
    18|     This cloud provider will be removed from Salt in version 3009.0 in favor of
    19|     the `saltext.proxmox Salt Extension
    20|     <https://github.com/salt-extensions/saltext-proxmox>`_
    21| :maintainer: Frank Klaassen <frank@cloudright.nl>
    22| :depends: requests >= 2.2.1
    23| :depends: IPy >= 0.81
    24| """
    25| import logging
    26| import pprint
    27| import re
    28| import socket
    29| import time
    30| import urllib
    31| import salt.config as config
    32| import salt.utils.cloud
    33| import salt.utils.json
    34| from salt.exceptions import (
    35|     SaltCloudExecutionFailure,
    36|     SaltCloudExecutionTimeout,
    37|     SaltCloudSystemExit,
    38| )
    39| try:
    40|     import requests
    41|     HAS_REQUESTS = True
    42| except ImportError:
    43|     HAS_REQUESTS = False
    44| try:
    45|     from IPy import IP
    46|     HAS_IPY = True
    47| except ImportError:
    48|     HAS_IPY = False
    49| log = logging.getLogger(__name__)
    50| __virtualname__ = "proxmox"
    51| __deprecated__ = (
    52|     3009,
    53|     "proxmox",
    54|     "https://github.com/salt-extensions/saltext-proxmox",
    55| )
    56| def __virtual__():
    57|     """
    58|     Check for PROXMOX configurations
    59|     """
    60|     if get_configured_provider() is False:
    61|         return False
    62|     if get_dependencies() is False:
    63|         return False
    64|     return __virtualname__
    65| def _get_active_provider_name():
    66|     try:
    67|         return __active_provider_name__.value()
    68|     except AttributeError:
    69|         return __active_provider_name__
    70| def get_configured_provider():
    71|     """
    72|     Return the first configured instance.
    73|     """
    74|     return config.is_provider_configured(
    75|         __opts__, _get_active_provider_name() or __virtualname__, ("user",)

# --- HUNK 2: Lines 97-184 ---
    97|     port = config.get_cloud_config_value(
    98|         "port", get_configured_provider(), __opts__, default=8006, search_global=False
    99|     )
   100|     username = (
   101|         config.get_cloud_config_value(
   102|             "user", get_configured_provider(), __opts__, search_global=False
   103|         ),
   104|     )
   105|     passwd = config.get_cloud_config_value(
   106|         "password", get_configured_provider(), __opts__, search_global=False
   107|     )
   108|     verify_ssl = config.get_cloud_config_value(
   109|         "verify_ssl",
   110|         get_configured_provider(),
   111|         __opts__,
   112|         default=True,
   113|         search_global=False,
   114|     )
   115|     connect_data = {"username": username, "password": passwd}
   116|     full_url = f"https://{url}:{port}/api2/json/access/ticket"
   117|     response = requests.post(full_url, verify=verify_ssl, data=connect_data)
   118|     response.raise_for_status()
   119|     returned_data = response.json()
   120|     ticket = {"PVEAuthCookie": returned_data["data"]["ticket"]}
   121|     csrf = str(returned_data["data"]["CSRFPreventionToken"])
   122| def query(conn_type, option, post_data=None):
   123|     """
   124|     Execute the HTTP request to the API
   125|     """
   126|     if ticket is None or csrf is None or url is None:
   127|         log.debug("Not authenticated yet, doing that now..")
   128|         _authenticate()
   129|     full_url = f"https://{url}:{port}/api2/json/{option}"
   130|     log.debug("%s: %s (%s)", conn_type, full_url, post_data)
   131|     httpheaders = {
   132|         "Accept": "application/json",
   133|         "Content-Type": "application/x-www-form-urlencoded",
   134|         "User-Agent": "salt-cloud-proxmox",
   135|     }
   136|     if conn_type == "post":
   137|         httpheaders["CSRFPreventionToken"] = csrf
   138|         response = requests.post(
   139|             full_url,
   140|             verify=verify_ssl,
   141|             data=post_data,
   142|             cookies=ticket,
   143|             headers=httpheaders,
   144|         )
   145|     elif conn_type == "put":
   146|         httpheaders["CSRFPreventionToken"] = csrf
   147|         response = requests.put(
   148|             full_url,
   149|             verify=verify_ssl,
   150|             data=post_data,
   151|             cookies=ticket,
   152|             headers=httpheaders,
   153|         )
   154|     elif conn_type == "delete":
   155|         httpheaders["CSRFPreventionToken"] = csrf
   156|         response = requests.delete(
   157|             full_url,
   158|             verify=verify_ssl,
   159|             data=post_data,
   160|             cookies=ticket,
   161|             headers=httpheaders,
   162|         )
   163|     elif conn_type == "get":
   164|         response = requests.get(full_url, verify=verify_ssl, cookies=ticket)
   165|     try:
   166|         response.raise_for_status()
   167|     except requests.exceptions.RequestException:
   168|         log.error("Error in %s query to %s:\n%s", conn_type, full_url, response.text)
   169|         raise
   170|     try:
   171|         returned_data = response.json()
   172|         if "data" not in returned_data:
   173|             raise SaltCloudExecutionFailure
   174|         return returned_data["data"]
   175|     except Exception:  # pylint: disable=broad-except
   176|         log.error("Error in trying to process JSON")
   177|         log.error(response)
   178| def _get_vm_by_name(name, allDetails=False):
   179|     """
   180|     Since Proxmox works based op id's rather than names as identifiers this
   181|     requires some filtering to retrieve the required information.
   182|     """
   183|     vms = get_resources_vms(includeConfig=allDetails)
   184|     if name in vms:

# --- HUNK 3: Lines 634-674 ---
   634|     for interface in interfaces["result"]:
   635|         if str(interface.get("hardware-address")) == "00:00:00:00:00:00":
   636|             continue
   637|         if "ip-addresses" not in interface:
   638|             continue
   639|         for if_addr in interface["ip-addresses"]:
   640|             ip_addr = if_addr.get("ip-address")
   641|             if ip_addr is not None:
   642|                 ips.append(str(ip_addr))
   643|     if len(ips) > 0:
   644|         return preferred_ip(vm_, ips)
   645|     raise SaltCloudExecutionFailure
   646| def _import_api():
   647|     """
   648|     Download https://<url>/pve-docs/api-viewer/apidoc.js
   649|     Extract content of pveapi var (json formatted)
   650|     Load this json content into global variable "api"
   651|     """
   652|     global api
   653|     full_url = f"https://{url}:{port}/pve-docs/api-viewer/apidoc.js"
   654|     returned_data = requests.get(full_url, verify=verify_ssl)
   655|     re_filter = re.compile(" (?:pveapi|apiSchema) = (.*)^;", re.DOTALL | re.MULTILINE)
   656|     api_json = re_filter.findall(returned_data.text)[0]
   657|     api = salt.utils.json.loads(api_json)
   658| def _get_properties(path="", method="GET", forced_params=None):
   659|     """
   660|     Return the parameter list from api for defined path and HTTP method
   661|     """
   662|     if api is None:
   663|         _import_api()
   664|     sub = api
   665|     path_levels = [level for level in path.split("/") if level != ""]
   666|     search_path = ""
   667|     props = []
   668|     parameters = set([] if forced_params is None else forced_params)
   669|     for elem in path_levels[:-1]:
   670|         search_path += "/" + elem
   671|         sub = next(item for item in sub if item["path"] == search_path)["children"]
   672|     search_path += "/" + path_levels[-1]
   673|     sub = next(item for item in sub if item["path"] == search_path)
   674|     try:


# ====================================================================
# FILE: salt/config/__init__.py
# Total hunks: 21
# ====================================================================
# --- HUNK 1: Lines 1-137 ---
     1| """
     2| All salt configuration loading and defaults should be in this module
     3| """
     4| import codecs
     5| import glob
     6| import logging
     7| import os
     8| import re
     9| import sys
    10| import time
    11| import types
    12| import urllib.parse
    13| from copy import deepcopy
    14| import salt.defaults.exitcodes
    15| import salt.exceptions
    16| import salt.features
    17| import salt.syspaths
    18| import salt.utils.data
    19| import salt.utils.dictupdate
    20| import salt.utils.files
    21| import salt.utils.immutabletypes as immutabletypes
    22| import salt.utils.network
    23| import salt.utils.path
    24| import salt.utils.platform
    25| import salt.utils.stringutils
    26| import salt.utils.user
    27| import salt.utils.validate.path
    28| import salt.utils.versions
    29| import salt.utils.xdg
    30| import salt.utils.yaml
    31| from salt._logging import (
    32|     DFLT_LOG_DATEFMT,
    33|     DFLT_LOG_DATEFMT_LOGFILE,
    34|     DFLT_LOG_FMT_CONSOLE,
    35|     DFLT_LOG_FMT_JID,
    36|     DFLT_LOG_FMT_LOGFILE,
    37| )
    38| try:
    39|     import psutil
    40|     if not hasattr(psutil, "virtual_memory"):
    41|         raise ImportError("Version of psutil too old.")
    42|     HAS_PSUTIL = True
    43| except ImportError:
    44|     HAS_PSUTIL = False
    45| log = logging.getLogger(__name__)
    46| _DFLT_REFSPECS = ["+refs/heads/*:refs/remotes/origin/*", "+refs/tags/*:refs/tags/*"]
    47| DEFAULT_INTERVAL = 60
    48| DEFAULT_HASH_TYPE = "sha256"
    49| if salt.utils.platform.is_windows():
    50|     _DFLT_IPC_MODE = "tcp"
    51|     _DFLT_FQDNS_GRAINS = False
    52|     _MASTER_TRIES = -1
    53|     _MASTER_USER = "SYSTEM"
    54| elif salt.utils.platform.is_proxy():
    55|     _DFLT_IPC_MODE = "ipc"
    56|     _DFLT_FQDNS_GRAINS = False
    57|     _MASTER_TRIES = 1
    58|     _MASTER_USER = salt.utils.user.get_user()
    59| elif salt.utils.platform.is_darwin():
    60|     _DFLT_IPC_MODE = "ipc"
    61|     _DFLT_FQDNS_GRAINS = False
    62|     _MASTER_TRIES = 1
    63|     _MASTER_USER = salt.utils.user.get_user()
    64| else:
    65|     _DFLT_IPC_MODE = "ipc"
    66|     _DFLT_FQDNS_GRAINS = False
    67|     _MASTER_TRIES = 1
    68|     _MASTER_USER = salt.utils.user.get_user()
    69| def _gather_buffer_space():
    70|     """
    71|     Gather some system data and then calculate
    72|     buffer space.
    73|     Result is in bytes.
    74|     """
    75|     if HAS_PSUTIL and psutil.version_info >= (0, 6, 0):
    76|         total_mem = psutil.virtual_memory().total
    77|     else:
    78|         import platform
    79|         import salt.grains.core
    80|         os_data = {"kernel": platform.system()}
    81|         grains = salt.grains.core._memdata(os_data)
    82|         total_mem = grains["mem_total"]
    83|     return max([total_mem * 0.05, 10 << 20])
    84| _DFLT_IPC_WBUFFER = int(_gather_buffer_space() * 0.5)
    85| _DFLT_IPC_RBUFFER = int(_gather_buffer_space() * 0.5)
    86| VALID_OPTS = immutabletypes.freeze(
    87|     {
    88|         "master": (str, list),
    89|         "master_port": (str, int),
    90|         "master_type": str,
    91|         "master_uri_format": str,
    92|         "source_interface_name": str,
    93|         "source_address": str,
    94|         "source_ret_port": (str, int),
    95|         "source_publish_port": (str, int),
    96|         "master_finger": str,
    97|         "master_shuffle": bool,
    98|         "master_alive_interval": int,
    99|         "master_failback": bool,
   100|         "master_failback_interval": int,
   101|         "master_sign_key_name": str,
   102|         "master_sign_pubkey": bool,
   103|         "verify_master_pubkey_sign": bool,
   104|         "always_verify_signature": bool,
   105|         "master_pubkey_signature": str,
   106|         "master_use_pubkey_signature": bool,
   107|         "master_stats": bool,
   108|         "master_stats_event_iter": int,
   109|         "syndic_finger": str,
   110|         "key_cache": str,
   111|         "user": str,
   112|         "root_dir": str,
   113|         "pki_dir": str,
   114|         "id": str,
   115|         "cluster_id": str,
   116|         "cluster_peers": list,
   117|         "cluster_pki_dir": str,
   118|         "id_function": (dict, str),
   119|         "cachedir": str,
   120|         "append_minionid_config_dirs": list,
   121|         "cache_jobs": bool,
   122|         "conf_file": str,
   123|         "sock_dir": str,
   124|         "sock_pool_size": int,
   125|         "backup_mode": str,
   126|         "renderer": str,
   127|         "renderer_whitelist": list,
   128|         "renderer_blacklist": list,
   129|         "failhard": bool,
   130|         "autoload_dynamic_modules": bool,
   131|         "saltenv": (type(None), str),
   132|         "lock_saltenv": bool,
   133|         "pillarenv": (type(None), str),
   134|         "pillarenv_from_saltenv": bool,
   135|         "state_top": str,
   136|         "state_top_saltenv": (type(None), str),
   137|         "startup_states": str,

# --- HUNK 2: Lines 199-239 ---
   199|         "show_timeout": bool,
   200|         "show_jid": bool,
   201|         "unique_jid": bool,
   202|         "state_queue": (bool, int),
   203|         "state_verbose": bool,
   204|         "state_output": str,
   205|         "state_output_diff": bool,
   206|         "state_output_profile": bool,
   207|         "state_output_pct": bool,
   208|         "state_compress_ids": bool,
   209|         "state_auto_order": bool,
   210|         "state_events": bool,
   211|         "acceptance_wait_time": float,
   212|         "acceptance_wait_time_max": float,
   213|         "rejected_retry": bool,
   214|         "loop_interval": float,
   215|         "verify_env": bool,
   216|         "grains": dict,
   217|         "permissive_pki_access": bool,
   218|         "key_pass": (type(None), str),
   219|         "cluster_key_pass": (type(None), str),
   220|         "signing_key_pass": (type(None), str),
   221|         "default_include": str,
   222|         "update_url": (bool, str),
   223|         "update_restart_services": list,
   224|         "retry_dns": float,
   225|         "retry_dns_count": (type(None), int),
   226|         "resolve_dns_fallback": bool,
   227|         "recon_max": float,
   228|         "recon_default": float,
   229|         "recon_randomize": bool,
   230|         "return_retry_timer": int,
   231|         "return_retry_timer_max": int,
   232|         "return_retry_tries": int,
   233|         "event_return": (list, str),
   234|         "event_return_queue": int,
   235|         "event_return_queue_max_seconds": int,
   236|         "event_return_whitelist": list,
   237|         "event_return_blacklist": list,
   238|         "event_match_type": str,
   239|         "pidfile": str,

# --- HUNK 3: Lines 255-294 ---
   255|         "mworker_niceness": (type(None), int),
   256|         "mworker_queue_niceness": (type(None), int),
   257|         "event_return_niceness": (type(None), int),
   258|         "event_publisher_niceness": (type(None), int),
   259|         "reactor_niceness": (type(None), int),
   260|         "worker_threads": int,
   261|         "ret_port": int,
   262|         "keep_jobs": int,
   263|         "keep_jobs_seconds": int,
   264|         "archive_jobs": bool,
   265|         "master_roots": dict,
   266|         "add_proxymodule_to_opts": bool,
   267|         "proxy_merge_pillar_in_opts": bool,
   268|         "proxy_deep_merge_pillar_in_opts": bool,
   269|         "proxy_merge_pillar_in_opts_strategy": str,
   270|         "proxy_mines_pillar": bool,
   271|         "proxy_always_alive": bool,
   272|         "proxy_keep_alive": bool,
   273|         "proxy_keep_alive_interval": int,
   274|         "roots_update_interval": int,
   275|         "gitfs_update_interval": int,
   276|         "git_pillar_update_interval": int,
   277|         "hgfs_update_interval": int,
   278|         "minionfs_update_interval": int,
   279|         "s3fs_update_interval": int,
   280|         "svnfs_update_interval": int,
   281|         "git_pillar_ssl_verify": bool,
   282|         "git_pillar_global_lock": bool,
   283|         "git_pillar_user": str,
   284|         "git_pillar_password": str,
   285|         "git_pillar_insecure_auth": bool,
   286|         "git_pillar_privkey": str,
   287|         "git_pillar_pubkey": str,
   288|         "git_pillar_passphrase": str,
   289|         "git_pillar_refspecs": list,
   290|         "git_pillar_includes": bool,
   291|         "git_pillar_verify_config": bool,
   292|         "gitfs_remotes": list,
   293|         "gitfs_insecure_auth": bool,
   294|         "gitfs_privkey": str,

# --- HUNK 4: Lines 500-539 ---
   500|         "minion_data_cache_events": bool,
   501|         "enable_ssh_minions": bool,
   502|         "thoriumenv": (type(None), str),
   503|         "thorium_top": str,
   504|         "netapi_allow_raw_shell": bool,
   505|         "netapi_enable_clients": list,
   506|         "disabled_requisites": (str, list),
   507|         "global_state_conditions": (type(None), dict),
   508|         "features": dict,
   509|         "fips_mode": bool,
   510|         "detect_remote_minions": bool,
   511|         "remote_minions_port": int,
   512|         "pass_variable_prefix": str,
   513|         "pass_strict_fetch": bool,
   514|         "pass_gnupghome": str,
   515|         "pass_dir": str,
   516|         "maintenance_interval": int,
   517|         "fileserver_interval": int,
   518|         "request_channel_timeout": int,
   519|         "request_channel_tries": int,
   520|     }
   521| )
   522| DEFAULT_MINION_OPTS = immutabletypes.freeze(
   523|     {
   524|         "interface": "0.0.0.0",
   525|         "master": "salt",
   526|         "master_type": "str",
   527|         "master_uri_format": "default",
   528|         "source_interface_name": "",
   529|         "source_address": "",
   530|         "source_ret_port": 0,
   531|         "source_publish_port": 0,
   532|         "master_port": 4506,
   533|         "master_finger": "",
   534|         "master_shuffle": False,
   535|         "master_alive_interval": 0,
   536|         "master_failback": False,
   537|         "master_failback_interval": 0,
   538|         "verify_master_pubkey_sign": False,
   539|         "sign_pub_messages": False,

# --- HUNK 5: Lines 596-637 ---
   596|             "base": [salt.syspaths.BASE_FILE_ROOTS_DIR, salt.syspaths.SPM_FORMULA_PATH]
   597|         },
   598|         "top_file_merging_strategy": "merge",
   599|         "env_order": [],
   600|         "default_top": "base",
   601|         "file_recv": False,
   602|         "file_recv_max_size": 100,
   603|         "file_ignore_regex": [],
   604|         "file_ignore_glob": [],
   605|         "fileserver_backend": ["roots"],
   606|         "fileserver_followsymlinks": True,
   607|         "fileserver_ignoresymlinks": False,
   608|         "pillar_roots": {
   609|             "base": [salt.syspaths.BASE_PILLAR_ROOTS_DIR, salt.syspaths.SPM_PILLAR_PATH]
   610|         },
   611|         "on_demand_ext_pillar": ["libvirt", "virtkey"],
   612|         "decrypt_pillar": [],
   613|         "decrypt_pillar_delimiter": ":",
   614|         "decrypt_pillar_default": "gpg",
   615|         "decrypt_pillar_renderers": ["gpg"],
   616|         "gpg_decrypt_must_succeed": True,
   617|         "roots_update_interval": DEFAULT_INTERVAL,
   618|         "gitfs_update_interval": DEFAULT_INTERVAL,
   619|         "git_pillar_update_interval": DEFAULT_INTERVAL,
   620|         "hgfs_update_interval": DEFAULT_INTERVAL,
   621|         "minionfs_update_interval": DEFAULT_INTERVAL,
   622|         "s3fs_update_interval": DEFAULT_INTERVAL,
   623|         "svnfs_update_interval": DEFAULT_INTERVAL,
   624|         "git_pillar_base": "master",
   625|         "git_pillar_branch": "master",
   626|         "git_pillar_env": "",
   627|         "git_pillar_fallback": "",
   628|         "git_pillar_root": "",
   629|         "git_pillar_ssl_verify": True,
   630|         "git_pillar_global_lock": True,
   631|         "git_pillar_user": "",
   632|         "git_pillar_password": "",
   633|         "git_pillar_insecure_auth": False,
   634|         "git_pillar_privkey": "",
   635|         "git_pillar_pubkey": "",
   636|         "git_pillar_passphrase": "",
   637|         "git_pillar_refspecs": _DFLT_REFSPECS,

# --- HUNK 6: Lines 801-888 ---
   801|         "proxy_password": "",
   802|         "proxy_port": 0,
   803|         "minion_jid_queue_hwm": 100,
   804|         "ssl": None,
   805|         "multifunc_ordered": False,
   806|         "beacons_before_connect": False,
   807|         "scheduler_before_connect": False,
   808|         "cache": "localfs",
   809|         "salt_cp_chunk_size": 65536,
   810|         "extmod_whitelist": {},
   811|         "extmod_blacklist": {},
   812|         "minion_sign_messages": False,
   813|         "discovery": False,
   814|         "schedule": {},
   815|         "ssh_merge_pillar": True,
   816|         "disabled_requisites": [],
   817|         "global_state_conditions": None,
   818|         "reactor_niceness": None,
   819|         "fips_mode": False,
   820|         "features": {},
   821|     }
   822| )
   823| DEFAULT_MASTER_OPTS = immutabletypes.freeze(
   824|     {
   825|         "interface": "0.0.0.0",
   826|         "publish_port": 4505,
   827|         "zmq_backlog": 1000,
   828|         "pub_hwm": 1000,
   829|         "auth_mode": 1,
   830|         "user": _MASTER_USER,
   831|         "worker_threads": 5,
   832|         "sock_dir": os.path.join(salt.syspaths.SOCK_DIR, "master"),
   833|         "sock_pool_size": 1,
   834|         "ret_port": 4506,
   835|         "timeout": 5,
   836|         "keep_jobs": 24,
   837|         "keep_jobs_seconds": 86400,
   838|         "archive_jobs": False,
   839|         "root_dir": salt.syspaths.ROOT_DIR,
   840|         "pki_dir": os.path.join(salt.syspaths.LIB_STATE_DIR, "pki", "master"),
   841|         "key_cache": "",
   842|         "cachedir": os.path.join(salt.syspaths.CACHE_DIR, "master"),
   843|         "file_roots": {
   844|             "base": [salt.syspaths.BASE_FILE_ROOTS_DIR, salt.syspaths.SPM_FORMULA_PATH]
   845|         },
   846|         "master_roots": {"base": [salt.syspaths.BASE_MASTER_ROOTS_DIR]},
   847|         "pillar_roots": {
   848|             "base": [salt.syspaths.BASE_PILLAR_ROOTS_DIR, salt.syspaths.SPM_PILLAR_PATH]
   849|         },
   850|         "on_demand_ext_pillar": ["libvirt", "virtkey"],
   851|         "decrypt_pillar": [],
   852|         "decrypt_pillar_delimiter": ":",
   853|         "decrypt_pillar_default": "gpg",
   854|         "decrypt_pillar_renderers": ["gpg"],
   855|         "gpg_decrypt_must_succeed": True,
   856|         "thoriumenv": None,
   857|         "thorium_top": "top.sls",
   858|         "thorium_interval": 0.5,
   859|         "thorium_roots": {"base": [salt.syspaths.BASE_THORIUM_ROOTS_DIR]},
   860|         "top_file_merging_strategy": "merge",
   861|         "env_order": [],
   862|         "saltenv": None,
   863|         "lock_saltenv": False,
   864|         "pillarenv": None,
   865|         "default_top": "base",
   866|         "file_client": "local",
   867|         "local": True,
   868|         "roots_update_interval": DEFAULT_INTERVAL,
   869|         "gitfs_update_interval": DEFAULT_INTERVAL,
   870|         "git_pillar_update_interval": DEFAULT_INTERVAL,
   871|         "hgfs_update_interval": DEFAULT_INTERVAL,
   872|         "minionfs_update_interval": DEFAULT_INTERVAL,
   873|         "s3fs_update_interval": DEFAULT_INTERVAL,
   874|         "svnfs_update_interval": DEFAULT_INTERVAL,
   875|         "git_pillar_base": "master",
   876|         "git_pillar_branch": "master",
   877|         "git_pillar_env": "",
   878|         "git_pillar_fallback": "",
   879|         "git_pillar_root": "",
   880|         "git_pillar_ssl_verify": True,
   881|         "git_pillar_global_lock": True,
   882|         "git_pillar_user": "",
   883|         "git_pillar_password": "",
   884|         "git_pillar_insecure_auth": False,
   885|         "git_pillar_privkey": "",
   886|         "git_pillar_pubkey": "",
   887|         "git_pillar_passphrase": "",
   888|         "git_pillar_refspecs": _DFLT_REFSPECS,

# --- HUNK 7: Lines 1043-1083 ---
  1043|         "serial": "msgpack",
  1044|         "test": False,
  1045|         "state_verbose": True,
  1046|         "state_output": "full",
  1047|         "state_output_diff": False,
  1048|         "state_output_profile": True,
  1049|         "state_auto_order": True,
  1050|         "state_events": False,
  1051|         "state_aggregate": False,
  1052|         "search": "",
  1053|         "loop_interval": 60,
  1054|         "nodegroups": {},
  1055|         "ssh_list_nodegroups": {},
  1056|         "ssh_use_home_key": False,
  1057|         "cython_enable": False,
  1058|         "enable_gpu_grains": False,
  1059|         "key_logfile": os.path.join(salt.syspaths.LOGS_DIR, "key"),
  1060|         "verify_env": True,
  1061|         "permissive_pki_access": False,
  1062|         "key_pass": None,
  1063|         "cluster_key_pass": None,
  1064|         "signing_key_pass": None,
  1065|         "default_include": "master.d/*.conf",
  1066|         "winrepo_dir": os.path.join(salt.syspaths.BASE_FILE_ROOTS_DIR, "win", "repo"),
  1067|         "winrepo_dir_ng": os.path.join(
  1068|             salt.syspaths.BASE_FILE_ROOTS_DIR, "win", "repo-ng"
  1069|         ),
  1070|         "winrepo_cachefile": "winrepo.p",
  1071|         "winrepo_remotes": ["https://github.com/saltstack/salt-winrepo.git"],
  1072|         "winrepo_remotes_ng": ["https://github.com/saltstack/salt-winrepo-ng.git"],
  1073|         "winrepo_branch": "master",
  1074|         "winrepo_fallback": "",
  1075|         "winrepo_ssl_verify": True,
  1076|         "winrepo_user": "",
  1077|         "winrepo_password": "",
  1078|         "winrepo_insecure_auth": False,
  1079|         "winrepo_privkey": "",
  1080|         "winrepo_pubkey": "",
  1081|         "winrepo_passphrase": "",
  1082|         "winrepo_refspecs": _DFLT_REFSPECS,
  1083|         "syndic_wait": 5,

# --- HUNK 8: Lines 1142-1185 ---
  1142|         "allow_minion_key_revoke": True,
  1143|         "salt_cp_chunk_size": 98304,
  1144|         "require_minion_sign_messages": False,
  1145|         "drop_messages_signature_fail": False,
  1146|         "discovery": False,
  1147|         "schedule": {},
  1148|         "auth_events": True,
  1149|         "minion_data_cache_events": True,
  1150|         "enable_ssh_minions": False,
  1151|         "netapi_allow_raw_shell": False,
  1152|         "fips_mode": False,
  1153|         "detect_remote_minions": False,
  1154|         "remote_minions_port": 22,
  1155|         "pass_variable_prefix": "",
  1156|         "pass_strict_fetch": False,
  1157|         "pass_gnupghome": "",
  1158|         "pass_dir": "",
  1159|         "netapi_enable_clients": [],
  1160|         "maintenance_interval": 3600,
  1161|         "fileserver_interval": 3600,
  1162|         "cluster_id": None,
  1163|         "cluster_peers": [],
  1164|         "cluster_pki_dir": None,
  1165|         "features": {},
  1166|     }
  1167| )
  1168| DEFAULT_PROXY_MINION_OPTS = immutabletypes.freeze(
  1169|     {
  1170|         "conf_file": os.path.join(salt.syspaths.CONFIG_DIR, "proxy"),
  1171|         "log_file": os.path.join(salt.syspaths.LOGS_DIR, "proxy"),
  1172|         "add_proxymodule_to_opts": False,
  1173|         "proxy_merge_grains_in_module": True,
  1174|         "extension_modules": os.path.join(salt.syspaths.CACHE_DIR, "proxy", "extmods"),
  1175|         "append_minionid_config_dirs": [
  1176|             "cachedir",
  1177|             "pidfile",
  1178|             "default_include",
  1179|             "extension_modules",
  1180|         ],
  1181|         "default_include": "proxy.d/*.conf",
  1182|         "proxy_merge_pillar_in_opts": False,
  1183|         "proxy_deep_merge_pillar_in_opts": False,
  1184|         "proxy_merge_pillar_in_opts_strategy": "smart",
  1185|         "proxy_mines_pillar": True,

# --- HUNK 9: Lines 1570-1609 ---
  1570|                     path,
  1571|                 )
  1572|         for fn_ in sorted(glob_matches):
  1573|             log.debug("Including configuration from '%s'", fn_)
  1574|             try:
  1575|                 opts = _read_conf_file(fn_)
  1576|             except salt.exceptions.SaltConfigurationError as error:
  1577|                 log.error(error)
  1578|                 if exit_on_config_errors:
  1579|                     sys.exit(salt.defaults.exitcodes.EX_GENERIC)
  1580|                 else:
  1581|                     opts = {}
  1582|             schedule = opts.get("schedule", {})
  1583|             if schedule and "schedule" in configuration:
  1584|                 configuration["schedule"].update(schedule)
  1585|             include = opts.get("include", [])
  1586|             if include:
  1587|                 opts.update(include_config(include, fn_, verbose))
  1588|             salt.utils.dictupdate.update(configuration, opts, True, True)
  1589|     return configuration
  1590| def prepend_root_dir(opts, path_options):
  1591|     """
  1592|     Prepends the options that represent filesystem paths with value of the
  1593|     'root_dir' option.
  1594|     """
  1595|     root_dir = os.path.abspath(opts["root_dir"])
  1596|     def_root_dir = salt.syspaths.ROOT_DIR.rstrip(os.sep)
  1597|     for path_option in path_options:
  1598|         if path_option in opts:
  1599|             path = opts[path_option]
  1600|             tmp_path_def_root_dir = None
  1601|             tmp_path_root_dir = None
  1602|             if path == def_root_dir or path.startswith(def_root_dir + os.sep):
  1603|                 tmp_path_def_root_dir = path[len(def_root_dir) :]
  1604|             if root_dir and (path == root_dir or path.startswith(root_dir + os.sep)):
  1605|                 tmp_path_root_dir = path[len(root_dir) :]
  1606|             if tmp_path_def_root_dir and not tmp_path_root_dir:
  1607|                 path = tmp_path_def_root_dir
  1608|             elif tmp_path_root_dir and not tmp_path_def_root_dir:
  1609|                 path = tmp_path_root_dir

# --- HUNK 10: Lines 1801-1841 ---
  1801|         "user": opts.get("syndic_user", opts["user"]),
  1802|         "sock_dir": os.path.join(
  1803|             opts["cachedir"], opts.get("syndic_sock_dir", opts["sock_dir"])
  1804|         ),
  1805|         "sock_pool_size": master_opts["sock_pool_size"],
  1806|         "cachedir": master_opts["cachedir"],
  1807|     }
  1808|     opts.update(syndic_opts)
  1809|     prepend_root_dirs = [
  1810|         "pki_dir",
  1811|         "cachedir",
  1812|         "pidfile",
  1813|         "sock_dir",
  1814|         "extension_modules",
  1815|         "autosign_file",
  1816|         "autoreject_file",
  1817|         "token_dir",
  1818|         "autosign_grains_dir",
  1819|     ]
  1820|     for config_key in ("log_file", "key_logfile", "syndic_log_file"):
  1821|         if urllib.parse.urlparse(opts.get(config_key, "")).scheme == "":
  1822|             prepend_root_dirs.append(config_key)
  1823|     prepend_root_dir(opts, prepend_root_dirs)
  1824|     salt.features.setup_features(opts)
  1825|     return opts
  1826| def apply_sdb(opts, sdb_opts=None):
  1827|     """
  1828|     Recurse for sdb:// links for opts
  1829|     """
  1830|     import salt.utils.sdb
  1831|     if sdb_opts is None:
  1832|         sdb_opts = opts
  1833|     if isinstance(sdb_opts, str) and sdb_opts.startswith("sdb://"):
  1834|         return salt.utils.sdb.sdb_get(sdb_opts, opts)
  1835|     elif isinstance(sdb_opts, dict):
  1836|         for key, value in sdb_opts.items():
  1837|             if value is None:
  1838|                 continue
  1839|             sdb_opts[key] = apply_sdb(opts, value)
  1840|     elif isinstance(sdb_opts, list):
  1841|         for key, value in enumerate(sdb_opts):

# --- HUNK 11: Lines 1964-2005 ---
  1964|                 os.path.dirname(providers_config_path), "cloud.providers.d", "*"
  1965|             )
  1966|             if os.path.isfile(providers_config_path) or glob.glob(providers_confd):
  1967|                 raise salt.exceptions.SaltCloudConfigError(
  1968|                     "Do not mix the old cloud providers configuration with "
  1969|                     "the new one. The providers configuration should now go "
  1970|                     "in the file `{0}` or a separate `*.conf` file within "
  1971|                     "`cloud.providers.d/` which is relative to `{0}`.".format(
  1972|                         os.path.join(salt.syspaths.CONFIG_DIR, "cloud.providers")
  1973|                     )
  1974|                 )
  1975|         providers_config = opts["providers"]
  1976|     elif providers_config_path is not None:
  1977|         providers_config = cloud_providers_config(providers_config_path)
  1978|     opts["providers"] = providers_config
  1979|     if profiles_config is None:
  1980|         profiles_config = vm_profiles_config(profiles_config_path, providers_config)
  1981|     opts["profiles"] = profiles_config
  1982|     apply_sdb(opts)
  1983|     prepend_root_dirs = ["cachedir"]
  1984|     if "log_file" in opts and urllib.parse.urlparse(opts["log_file"]).scheme == "":
  1985|         prepend_root_dirs.append(opts["log_file"])
  1986|     prepend_root_dir(opts, prepend_root_dirs)
  1987|     salt.features.setup_features(opts)
  1988|     return opts
  1989| def apply_cloud_config(overrides, defaults=None):
  1990|     """
  1991|     Return a cloud config
  1992|     """
  1993|     if defaults is None:
  1994|         defaults = DEFAULT_CLOUD_OPTS.copy()
  1995|     config = defaults.copy()
  1996|     if overrides:
  1997|         config.update(overrides)
  1998|     if "providers" in config:
  1999|         providers = config["providers"].copy()
  2000|         config["providers"] = {}
  2001|         for alias, details in providers.items():
  2002|             if isinstance(details, list):
  2003|                 for detail in details:
  2004|                     if "driver" not in detail:
  2005|                         raise salt.exceptions.SaltCloudConfigError(

# --- HUNK 12: Lines 2733-2775 ---
  2733|             log.warning(
  2734|                 "The 'saltenv' and 'environment' minion config options "
  2735|                 "cannot both be used. Ignoring 'environment' in favor of "
  2736|                 "'saltenv'."
  2737|             )
  2738|             opts["environment"] = opts["saltenv"]
  2739|         else:
  2740|             log.warning(
  2741|                 "The 'environment' minion config option has been renamed "
  2742|                 "to 'saltenv'. Using %s as the 'saltenv' config value.",
  2743|                 opts["environment"],
  2744|             )
  2745|             opts["saltenv"] = opts["environment"]
  2746|     for idx, val in enumerate(opts["fileserver_backend"]):
  2747|         if val in ("git", "hg", "svn", "minion"):
  2748|             new_val = val + "fs"
  2749|             log.debug(
  2750|                 "Changed %s to %s in minion opts' fileserver_backend list", val, new_val
  2751|             )
  2752|             opts["fileserver_backend"][idx] = new_val
  2753|     opts["__cli"] = salt.utils.stringutils.to_unicode(
  2754|         os.path.basename(salt.utils.path.expand(sys.argv[0]))
  2755|     )
  2756|     using_ip_for_id = False
  2757|     if not opts.get("id"):
  2758|         if minion_id:
  2759|             opts["id"] = minion_id
  2760|         else:
  2761|             opts["id"], using_ip_for_id = get_id(opts, cache_minion_id=cache_minion_id)
  2762|     if not using_ip_for_id and "append_domain" in opts:
  2763|         opts["id"] = _append_domain(opts)
  2764|     for directory in opts.get("append_minionid_config_dirs", []):
  2765|         if directory in ("pki_dir", "cachedir", "extension_modules"):
  2766|             newdirectory = os.path.join(opts[directory], opts["id"])
  2767|             opts[directory] = newdirectory
  2768|         elif directory == "default_include" and directory in opts:
  2769|             include_dir = os.path.dirname(opts[directory])
  2770|             new_include_dir = os.path.join(
  2771|                 include_dir, opts["id"], os.path.basename(opts[directory])
  2772|             )
  2773|             opts[directory] = new_include_dir
  2774|     if "pidfile" in opts.get("append_minionid_config_dirs", []):
  2775|         newpath_list = os.path.split(opts["pidfile"])

# --- HUNK 13: Lines 2779-2830 ---
  2779|     if len(opts["sock_dir"]) > len(opts["cachedir"]) + 10:
  2780|         opts["sock_dir"] = os.path.join(opts["cachedir"], ".salt-unix")
  2781|     opts["open_mode"] = opts["open_mode"] is True
  2782|     opts["file_roots"] = _validate_file_roots(opts["file_roots"])
  2783|     opts["pillar_roots"] = _validate_pillar_roots(opts["pillar_roots"])
  2784|     opts["extension_modules"] = opts.get("extension_modules") or os.path.join(
  2785|         opts["cachedir"], "extmods"
  2786|     )
  2787|     opts["utils_dirs"] = opts.get("utils_dirs") or [
  2788|         os.path.join(opts["extension_modules"], "utils")
  2789|     ]
  2790|     insert_system_path(opts, opts["utils_dirs"])
  2791|     prepend_root_dirs = [
  2792|         "pki_dir",
  2793|         "cachedir",
  2794|         "sock_dir",
  2795|         "extension_modules",
  2796|         "pidfile",
  2797|     ]
  2798|     for config_key in ("log_file", "key_logfile"):
  2799|         if urllib.parse.urlparse(opts.get(config_key, "")).scheme == "":
  2800|             prepend_root_dirs.append(config_key)
  2801|     prepend_root_dir(opts, prepend_root_dirs)
  2802|     if "beacons" not in opts:
  2803|         opts["beacons"] = {}
  2804|     if overrides.get("ipc_write_buffer", "") == "dynamic":
  2805|         opts["ipc_write_buffer"] = _DFLT_IPC_WBUFFER
  2806|     if "ipc_write_buffer" not in overrides:
  2807|         opts["ipc_write_buffer"] = 0
  2808|     opts["hash_type"] = opts["hash_type"].lower()
  2809|     _update_ssl_config(opts)
  2810|     _update_discovery_config(opts)
  2811|     return opts
  2812| def _update_discovery_config(opts):
  2813|     """
  2814|     Update discovery config for all instances.
  2815|     :param opts:
  2816|     :return:
  2817|     """
  2818|     if opts.get("discovery") not in (None, False):
  2819|         if opts["discovery"] is True:
  2820|             opts["discovery"] = {}
  2821|         discovery_config = {
  2822|             "attempts": 3,
  2823|             "pause": 5,
  2824|             "port": 4520,
  2825|             "match": "any",
  2826|             "mapping": {},
  2827|         }
  2828|         for key in opts["discovery"]:
  2829|             if key not in discovery_config:
  2830|                 raise salt.exceptions.SaltConfigurationError(

# --- HUNK 14: Lines 2883-2925 ---
  2883|     """
  2884|     Returns master configurations dict.
  2885|     """
  2886|     if defaults is None:
  2887|         defaults = DEFAULT_MASTER_OPTS.copy()
  2888|     if overrides is None:
  2889|         overrides = {}
  2890|     opts = defaults.copy()
  2891|     opts["__role"] = "master"
  2892|     opts["__fs_update"] = True
  2893|     _adjust_log_file_override(overrides, defaults["log_file"])
  2894|     if overrides:
  2895|         opts.update(overrides)
  2896|     if "rest" in opts.get("external_auth", {}):
  2897|         if opts["keep_acl_in_token"] is False:
  2898|             log.warning(
  2899|                 "The 'rest' external_auth backend requires 'keep_acl_in_token' to be True. "
  2900|                 "Setting 'keep_acl_in_token' to True."
  2901|             )
  2902|         opts["keep_acl_in_token"] = True
  2903|     opts["__cli"] = salt.utils.stringutils.to_unicode(
  2904|         os.path.basename(salt.utils.path.expand(sys.argv[0]))
  2905|     )
  2906|     if "environment" in opts:
  2907|         if opts["saltenv"] is not None:
  2908|             log.warning(
  2909|                 "The 'saltenv' and 'environment' master config options "
  2910|                 "cannot both be used. Ignoring 'environment' in favor of "
  2911|                 "'saltenv'."
  2912|             )
  2913|             opts["environment"] = opts["saltenv"]
  2914|         else:
  2915|             log.warning(
  2916|                 "The 'environment' master config option has been renamed "
  2917|                 "to 'saltenv'. Using %s as the 'saltenv' config value.",
  2918|                 opts["environment"],
  2919|             )
  2920|             opts["saltenv"] = opts["environment"]
  2921|     for idx, val in enumerate(opts["fileserver_backend"]):
  2922|         if val in ("git", "hg", "svn", "minion"):
  2923|             new_val = val + "fs"
  2924|             log.debug(
  2925|                 "Changed %s to %s in master opts' fileserver_backend list", val, new_val

# --- HUNK 15: Lines 2946-3039 ---
  2946|         opts["id"], using_ip_for_id = get_id(opts, cache_minion_id=None)
  2947|         append_master = True
  2948|     if not using_ip_for_id and "append_domain" in opts:
  2949|         opts["id"] = _append_domain(opts)
  2950|     if append_master:
  2951|         opts["id"] += "_master"
  2952|     prepend_root_dirs = [
  2953|         "pki_dir",
  2954|         "cachedir",
  2955|         "pidfile",
  2956|         "sock_dir",
  2957|         "extension_modules",
  2958|         "autosign_file",
  2959|         "autoreject_file",
  2960|         "token_dir",
  2961|         "syndic_dir",
  2962|         "sqlite_queue_dir",
  2963|         "autosign_grains_dir",
  2964|     ]
  2965|     for config_key in ("log_file", "key_logfile", "ssh_log_file"):
  2966|         log_setting = opts.get(config_key, "")
  2967|         if log_setting is None:
  2968|             continue
  2969|         if urllib.parse.urlparse(log_setting).scheme == "":
  2970|             prepend_root_dirs.append(config_key)
  2971|     prepend_root_dir(opts, prepend_root_dirs)
  2972|     if "cluster_id" not in opts:
  2973|         opts["cluster_id"] = None
  2974|     if opts["cluster_id"] is not None:
  2975|         if not opts.get("cluster_peers", None):
  2976|             log.warning("Cluster id defined without defining cluster peers")
  2977|             opts["cluster_peers"] = []
  2978|         if not opts.get("cluster_pki_dir", None):
  2979|             log.warning(
  2980|                 "Cluster id defined without defining cluster pki, falling back to pki_dir"
  2981|             )
  2982|             opts["cluster_pki_dir"] = opts["pki_dir"]
  2983|     else:
  2984|         if opts.get("cluster_peers", None):
  2985|             log.warning("Cluster peers defined without a cluster_id, ignoring.")
  2986|             opts["cluster_peers"] = []
  2987|         if opts.get("cluster_pki_dir", None):
  2988|             log.warning("Cluster pki defined without a cluster_id, ignoring.")
  2989|             opts["cluster_pki_dir"] = None
  2990|     opts["open_mode"] = opts["open_mode"] is True
  2991|     opts["auto_accept"] = opts["auto_accept"] is True
  2992|     opts["file_roots"] = _validate_file_roots(opts["file_roots"])
  2993|     opts["pillar_roots"] = _validate_file_roots(opts["pillar_roots"])
  2994|     if opts["file_ignore_regex"]:
  2995|         if isinstance(opts["file_ignore_regex"], str):
  2996|             ignore_regex = [opts["file_ignore_regex"]]
  2997|         elif isinstance(opts["file_ignore_regex"], list):
  2998|             ignore_regex = opts["file_ignore_regex"]
  2999|         opts["file_ignore_regex"] = []
  3000|         for regex in ignore_regex:
  3001|             try:
  3002|                 re.compile(regex)
  3003|                 opts["file_ignore_regex"].append(regex)
  3004|             except Exception:  # pylint: disable=broad-except
  3005|                 log.warning("Unable to parse file_ignore_regex. Skipping: %s", regex)
  3006|     if opts["file_ignore_glob"]:
  3007|         if isinstance(opts["file_ignore_glob"], str):
  3008|             opts["file_ignore_glob"] = [opts["file_ignore_glob"]]
  3009|     if opts["worker_threads"] < 3 and opts.get("peer", None):
  3010|         log.warning(
  3011|             "The 'worker_threads' setting in '%s' cannot be lower than "
  3012|             "3. Resetting it to the default value of 3.",
  3013|             opts["conf_file"],
  3014|         )
  3015|         opts["worker_threads"] = 3
  3016|     opts.setdefault("pillar_source_merging_strategy", "smart")
  3017|     opts["hash_type"] = opts["hash_type"].lower()
  3018|     _update_ssl_config(opts)
  3019|     _update_discovery_config(opts)
  3020|     return opts
  3021| def client_config(path, env_var="SALT_CLIENT_CONFIG", defaults=None):
  3022|     """
  3023|     Load Master configuration data
  3024|     Usage:
  3025|     .. code-block:: python
  3026|         import salt.config
  3027|         master_opts = salt.config.client_config('/etc/salt/master')
  3028|     Returns a dictionary of the Salt Master configuration file with necessary
  3029|     options needed to communicate with a locally-running Salt Master daemon.
  3030|     This function searches for client specific configurations and adds them to
  3031|     the data from the master configuration.
  3032|     This is useful for master-side operations like
  3033|     :py:class:`~salt.client.LocalClient`.
  3034|     """
  3035|     if defaults is None:
  3036|         defaults = DEFAULT_MASTER_OPTS.copy()
  3037|     xdg_dir = salt.utils.xdg.xdg_config_dir()
  3038|     if os.path.isdir(xdg_dir):
  3039|         client_config_dir = xdg_dir

# --- HUNK 16: Lines 3103-3129 ---
  3103|     defaults = apply_master_config(overrides, defaults)
  3104|     defaults = apply_spm_config(overrides, defaults)
  3105|     return client_config(path, env_var="SPM_CONFIG", defaults=defaults)
  3106| def apply_spm_config(overrides, defaults):
  3107|     """
  3108|     Returns the spm configurations dict.
  3109|     .. versionadded:: 2015.8.1
  3110|     """
  3111|     opts = defaults.copy()
  3112|     _adjust_log_file_override(overrides, defaults["log_file"])
  3113|     if overrides:
  3114|         opts.update(overrides)
  3115|     prepend_root_dirs = [
  3116|         "formula_path",
  3117|         "pillar_path",
  3118|         "reactor_path",
  3119|         "spm_cache_dir",
  3120|         "spm_build_dir",
  3121|     ]
  3122|     for config_key in ("spm_logfile",):
  3123|         log_setting = opts.get(config_key, "")
  3124|         if log_setting is None:
  3125|             continue
  3126|         if urllib.parse.urlparse(log_setting).scheme == "":
  3127|             prepend_root_dirs.append(config_key)
  3128|     prepend_root_dir(opts, prepend_root_dirs)
  3129|     return opts


# ====================================================================
# FILE: salt/crypt.py
# Total hunks: 15
# ====================================================================
# --- HUNK 1: Lines 1-434 ---
     1| """
     2| The crypt module manages all of the cryptography functions for minions and
     3| masters, encrypting and decrypting payloads, preparing messages, and
     4| authenticating peers
     5| """
     6| import base64
     7| import binascii
     8| import copy
     9| import getpass
    10| import hashlib
    11| import hmac
    12| import logging
    13| import os
    14| import pathlib
    15| import random
    16| import stat
    17| import sys
    18| import tempfile
    19| import time
    20| import traceback
    21| import uuid
    22| import weakref
    23| import tornado.gen
    24| import salt.channel.client
    25| import salt.defaults.exitcodes
    26| import salt.payload
    27| import salt.utils.crypt
    28| import salt.utils.decorators
    29| import salt.utils.event
    30| import salt.utils.files
    31| import salt.utils.rsax931
    32| import salt.utils.sdb
    33| import salt.utils.stringutils
    34| import salt.utils.user
    35| import salt.utils.verify
    36| import salt.version
    37| from salt.exceptions import (
    38|     AuthenticationError,
    39|     InvalidKeyError,
    40|     MasterExit,
    41|     SaltClientError,
    42|     SaltReqTimeoutError,
    43| )
    44| try:
    45|     from M2Crypto import BIO, EVP, RSA
    46|     HAS_M2 = True
    47| except ImportError:
    48|     HAS_M2 = False
    49| if not HAS_M2:
    50|     try:
    51|         from Cryptodome import Random
    52|         from Cryptodome.Cipher import AES, PKCS1_OAEP
    53|         from Cryptodome.Cipher import PKCS1_v1_5 as PKCS1_v1_5_CIPHER
    54|         from Cryptodome.Hash import SHA
    55|         from Cryptodome.PublicKey import RSA
    56|         from Cryptodome.Signature import PKCS1_v1_5
    57|         HAS_CRYPTO = True
    58|     except ImportError:
    59|         HAS_CRYPTO = False
    60| if not HAS_M2 and not HAS_CRYPTO:
    61|     try:
    62|         from Crypto import Random  # nosec
    63|         from Crypto.Cipher import AES, PKCS1_OAEP  # nosec
    64|         from Crypto.Cipher import PKCS1_v1_5 as PKCS1_v1_5_CIPHER  # nosec
    65|         from Crypto.Hash import SHA  # nosec
    66|         from Crypto.PublicKey import RSA  # nosec
    67|         from Crypto.Signature import PKCS1_v1_5  # nosec
    68|         HAS_CRYPTO = True
    69|     except ImportError:
    70|         HAS_CRYPTO = False
    71| log = logging.getLogger(__name__)
    72| def clean_key(key):
    73|     """
    74|     Clean the key so that it only has unix style line endings (\\n)
    75|     """
    76|     return "\n".join(key.strip().splitlines())
    77| def read_dropfile(cachedir):
    78|     dfn = os.path.join(cachedir, ".dfn")
    79|     try:
    80|         with salt.utils.files.fopen(dfn, "r") as fp:
    81|             return fp.read()
    82|     except FileNotFoundError:
    83|         pass
    84| def dropfile(cachedir, user=None, master_id=""):
    85|     """
    86|     Set an AES dropfile to request the master update the publish session key
    87|     """
    88|     dfn_next = os.path.join(cachedir, ".dfn-next")
    89|     dfn = os.path.join(cachedir, ".dfn")
    90|     with salt.utils.files.set_umask(0o277):
    91|         log.info("Rotating AES key")
    92|         if os.path.isfile(dfn):
    93|             log.info("AES key rotation already requested")
    94|             return
    95|         if os.path.isfile(dfn) and not os.access(dfn, os.W_OK):
    96|             os.chmod(dfn, stat.S_IRUSR | stat.S_IWUSR)
    97|         with salt.utils.files.fopen(dfn_next, "w+") as fp_:
    98|             fp_.write(master_id)
    99|         os.chmod(dfn_next, stat.S_IRUSR)
   100|         if user:
   101|             try:
   102|                 import pwd
   103|                 uid = pwd.getpwnam(user).pw_uid
   104|                 os.chown(dfn_next, uid, -1)
   105|             except (KeyError, ImportError, OSError):
   106|                 pass
   107|         os.rename(dfn_next, dfn)
   108| def gen_keys(keydir, keyname, keysize, user=None, passphrase=None):
   109|     """
   110|     Generate a RSA public keypair for use with salt
   111|     :param str keydir: The directory to write the keypair to
   112|     :param str keyname: The type of salt server for whom this key should be written. (i.e. 'master' or 'minion')
   113|     :param int keysize: The number of bits in the key
   114|     :param str user: The user on the system who should own this keypair
   115|     :param str passphrase: The passphrase which should be used to encrypt the private key
   116|     :rtype: str
   117|     :return: Path on the filesystem to the RSA private key
   118|     """
   119|     base = os.path.join(keydir, keyname)
   120|     priv = f"{base}.pem"
   121|     pub = f"{base}.pub"
   122|     if HAS_M2:
   123|         gen = RSA.gen_key(keysize, 65537, lambda: None)
   124|     else:
   125|         salt.utils.crypt.reinit_crypto()
   126|         gen = RSA.generate(bits=keysize, e=65537)
   127|     if os.path.isfile(priv):
   128|         return priv
   129|     if not os.access(keydir, os.W_OK):
   130|         raise OSError(
   131|             'Write access denied to "{}" for user "{}".'.format(
   132|                 os.path.abspath(keydir), getpass.getuser()
   133|             )
   134|         )
   135|     with salt.utils.files.set_umask(0o277):
   136|         if HAS_M2:
   137|             if not passphrase:
   138|                 gen.save_pem(priv, cipher=None)
   139|             else:
   140|                 gen.save_pem(
   141|                     priv,
   142|                     cipher="des_ede3_cbc",
   143|                     callback=lambda x: salt.utils.stringutils.to_bytes(passphrase),
   144|                 )
   145|         else:
   146|             with salt.utils.files.fopen(priv, "wb+") as f:
   147|                 f.write(gen.exportKey("PEM", passphrase))
   148|     if HAS_M2:
   149|         gen.save_pub_key(pub)
   150|     else:
   151|         with salt.utils.files.fopen(pub, "wb+") as f:
   152|             f.write(gen.publickey().exportKey("PEM"))
   153|     os.chmod(priv, 0o400)
   154|     if user:
   155|         try:
   156|             import pwd
   157|             uid = pwd.getpwnam(user).pw_uid
   158|             os.chown(priv, uid, -1)
   159|             os.chown(pub, uid, -1)
   160|         except (KeyError, ImportError, OSError):
   161|             pass
   162|     return priv
   163| class PrivateKey:
   164|     def __init__(self, path, passphrase=None):
   165|         if HAS_M2:
   166|             self.key = RSA.load_key(path, lambda x: bytes(passphrase))
   167|         else:
   168|             with salt.utils.files.fopen(path) as f:
   169|                 self.key = RSA.importKey(f.read(), passphrase)
   170|     def encrypt(self, data):
   171|         if HAS_M2:
   172|             return self.key.private_encrypt(data, salt.utils.rsax931.RSA_X931_PADDING)
   173|         else:
   174|             return salt.utils.rsax931.RSAX931Signer(self.key.exportKey("PEM")).sign(
   175|                 data
   176|             )
   177|     def sign(self, data):
   178|         if HAS_M2:
   179|             md = EVP.MessageDigest("sha1")
   180|             md.update(salt.utils.stringutils.to_bytes(data))
   181|             digest = md.final()
   182|             return self.key.sign(digest)
   183|         else:
   184|             signer = PKCS1_v1_5.new(self.key)
   185|             return signer.sign(SHA.new(salt.utils.stringutils.to_bytes(data)))
   186| class PublicKey:
   187|     def __init__(self, path, _HAS_M2=HAS_M2):
   188|         self._HAS_M2 = _HAS_M2
   189|         if self._HAS_M2:
   190|             with salt.utils.files.fopen(path, "rb") as f:
   191|                 data = f.read().replace(b"RSA ", b"")
   192|             bio = BIO.MemoryBuffer(data)
   193|             try:
   194|                 self.key = RSA.load_pub_key_bio(bio)
   195|             except RSA.RSAError:
   196|                 raise InvalidKeyError("Encountered bad RSA public key")
   197|         else:
   198|             with salt.utils.files.fopen(path) as f:
   199|                 try:
   200|                     self.key = RSA.importKey(f.read())
   201|                 except (ValueError, IndexError, TypeError):
   202|                     raise InvalidKeyError("Encountered bad RSA public key")
   203|     def encrypt(self, data):
   204|         bdata = salt.utils.stringutils.to_bytes(data)
   205|         if self._HAS_M2:
   206|             return self.key.public_encrypt(bdata, salt.crypt.RSA.pkcs1_oaep_padding)
   207|         else:
   208|             return salt.crypt.PKCS1_OAEP.new(self.key).encrypt(bdata)
   209|     def verify(self, data, signature):
   210|         if self._HAS_M2:
   211|             md = EVP.MessageDigest("sha1")
   212|             md.update(salt.utils.stringutils.to_bytes(data))
   213|             digest = md.final()
   214|             try:
   215|                 return self.key.verify(digest, signature)
   216|             except RSA.RSAError as exc:
   217|                 log.debug("Signature verification failed: %s", exc.args[0])
   218|                 return False
   219|         else:
   220|             verifier = PKCS1_v1_5.new(self.key)
   221|             return verifier.verify(
   222|                 SHA.new(salt.utils.stringutils.to_bytes(data)), signature
   223|             )
   224|     def decrypt(self, data):
   225|         data = salt.utils.stringutils.to_bytes(data)
   226|         if HAS_M2:
   227|             return self.key.public_decrypt(data, salt.utils.rsax931.RSA_X931_PADDING)
   228|         else:
   229|             verifier = salt.utils.rsax931.RSAX931Verifier(self.key.exportKey("PEM"))
   230|             return verifier.verify(data)
   231| @salt.utils.decorators.memoize
   232| def _get_key_with_evict(path, timestamp, passphrase):
   233|     """
   234|     Load a private key from disk.  `timestamp` above is intended to be the
   235|     timestamp of the file's last modification. This fn is memoized so if it is
   236|     called with the same path and timestamp (the file's last modified time) the
   237|     second time the result is returned from the memoization.  If the file gets
   238|     modified then the params are different and the key is loaded from disk.
   239|     """
   240|     log.debug("salt.crypt._get_key_with_evict: Loading private key")
   241|     if HAS_M2:
   242|         key = RSA.load_key(path, lambda x: bytes(passphrase))
   243|     else:
   244|         with salt.utils.files.fopen(path) as f:
   245|             key = RSA.importKey(f.read(), passphrase)
   246|     return key
   247| def get_rsa_key(path, passphrase):
   248|     """
   249|     Read a private key off the disk.  Poor man's simple cache in effect here,
   250|     we memoize the result of calling _get_rsa_with_evict.  This means the first
   251|     time _get_key_with_evict is called with a path and a timestamp the result
   252|     is cached.  If the file (the private key) does not change then its
   253|     timestamp will not change and the next time the result is returned from the
   254|     cache.  If the key DOES change the next time _get_rsa_with_evict is called
   255|     it is called with different parameters and the fn is run fully to retrieve
   256|     the key from disk.
   257|     """
   258|     log.debug("salt.crypt.get_rsa_key: Loading private key")
   259|     return _get_key_with_evict(path, str(os.path.getmtime(path)), passphrase)
   260| def get_rsa_pub_key(path):
   261|     """
   262|     Read a public key off the disk.
   263|     """
   264|     log.debug("salt.crypt.get_rsa_pub_key: Loading public key")
   265|     if HAS_M2:
   266|         with salt.utils.files.fopen(path, "rb") as f:
   267|             data = f.read().replace(b"RSA ", b"")
   268|         bio = BIO.MemoryBuffer(data)
   269|         try:
   270|             key = RSA.load_pub_key_bio(bio)
   271|         except RSA.RSAError:
   272|             raise InvalidKeyError("Encountered bad RSA public key")
   273|     else:
   274|         with salt.utils.files.fopen(path) as f:
   275|             try:
   276|                 key = RSA.importKey(f.read())
   277|             except (ValueError, IndexError, TypeError):
   278|                 raise InvalidKeyError("Encountered bad RSA public key")
   279|     return key
   280| def sign_message(privkey_path, message, passphrase=None):
   281|     """
   282|     Use Crypto.Signature.PKCS1_v1_5 to sign a message. Returns the signature.
   283|     """
   284|     key = get_rsa_key(privkey_path, passphrase)
   285|     log.debug("salt.crypt.sign_message: Signing message.")
   286|     if HAS_M2:
   287|         md = EVP.MessageDigest("sha1")
   288|         md.update(salt.utils.stringutils.to_bytes(message))
   289|         digest = md.final()
   290|         return key.sign(digest)
   291|     else:
   292|         signer = PKCS1_v1_5.new(key)
   293|         return signer.sign(SHA.new(salt.utils.stringutils.to_bytes(message)))
   294| def verify_signature(pubkey_path, message, signature):
   295|     """
   296|     Use Crypto.Signature.PKCS1_v1_5 to verify the signature on a message.
   297|     Returns True for valid signature.
   298|     """
   299|     log.debug("salt.crypt.verify_signature: Loading public key")
   300|     pubkey = get_rsa_pub_key(pubkey_path)
   301|     log.debug("salt.crypt.verify_signature: Verifying signature")
   302|     if HAS_M2:
   303|         md = EVP.MessageDigest("sha1")
   304|         md.update(salt.utils.stringutils.to_bytes(message))
   305|         digest = md.final()
   306|         try:
   307|             return pubkey.verify(digest, signature)
   308|         except RSA.RSAError as exc:
   309|             log.debug("Signature verification failed: %s", exc.args[0])
   310|             return False
   311|     else:
   312|         verifier = PKCS1_v1_5.new(pubkey)
   313|         return verifier.verify(
   314|             SHA.new(salt.utils.stringutils.to_bytes(message)), signature
   315|         )
   316| def gen_signature(priv_path, pub_path, sign_path, passphrase=None):
   317|     """
   318|     creates a signature for the given public-key with
   319|     the given private key and writes it to sign_path
   320|     """
   321|     with salt.utils.files.fopen(pub_path) as fp_:
   322|         mpub_64 = fp_.read()
   323|     mpub_sig = sign_message(priv_path, mpub_64, passphrase)
   324|     mpub_sig_64 = binascii.b2a_base64(mpub_sig)
   325|     if os.path.isfile(sign_path):
   326|         return False
   327|     log.trace(
   328|         "Calculating signature for %s with %s",
   329|         os.path.basename(pub_path),
   330|         os.path.basename(priv_path),
   331|     )
   332|     if os.path.isfile(sign_path):
   333|         log.trace(
   334|             "Signature file %s already exists, please remove it first and try again",
   335|             sign_path,
   336|         )
   337|     else:
   338|         with salt.utils.files.fopen(sign_path, "wb+") as sig_f:
   339|             sig_f.write(salt.utils.stringutils.to_bytes(mpub_sig_64))
   340|         log.trace("Wrote signature to %s", sign_path)
   341|     return True
   342| def private_encrypt(key, message):
   343|     """
   344|     Generate an M2Crypto-compatible signature
   345|     :param Crypto.PublicKey.RSA._RSAobj key: The RSA key object
   346|     :param str message: The message to sign
   347|     :rtype: str
   348|     :return: The signature, or an empty string if the signature operation failed
   349|     """
   350|     if HAS_M2:
   351|         return key.private_encrypt(message, salt.utils.rsax931.RSA_X931_PADDING)
   352|     else:
   353|         signer = salt.utils.rsax931.RSAX931Signer(key.exportKey("PEM"))
   354|         return signer.sign(message)
   355| def public_decrypt(pub, message):
   356|     """
   357|     Verify an M2Crypto-compatible signature
   358|     :param Crypto.PublicKey.RSA._RSAobj key: The RSA public key object
   359|     :param str message: The signed message to verify
   360|     :rtype: str
   361|     :return: The message (or digest) recovered from the signature, or an
   362|         empty string if the verification failed
   363|     """
   364|     if HAS_M2:
   365|         return pub.public_decrypt(message, salt.utils.rsax931.RSA_X931_PADDING)
   366|     else:
   367|         verifier = salt.utils.rsax931.RSAX931Verifier(pub.exportKey("PEM"))
   368|         return verifier.verify(message)
   369| def pwdata_decrypt(rsa_key, pwdata):
   370|     if HAS_M2:
   371|         key = RSA.load_key_string(salt.utils.stringutils.to_bytes(rsa_key, "ascii"))
   372|         password = key.private_decrypt(pwdata, RSA.pkcs1_padding)
   373|     else:
   374|         dsize = SHA.digest_size
   375|         sentinel = Random.new().read(15 + dsize)
   376|         key_obj = RSA.importKey(rsa_key)
   377|         key_obj = PKCS1_v1_5_CIPHER.new(key_obj)
   378|         password = key_obj.decrypt(pwdata, sentinel)
   379|     return salt.utils.stringutils.to_unicode(password)
   380| class MasterKeys(dict):
   381|     """
   382|     The Master Keys class is used to manage the RSA public key pair used for
   383|     authentication by the master.
   384|     It also generates a signing key-pair if enabled with master_sign_key_name.
   385|     """
   386|     def __init__(self, opts):
   387|         super().__init__()
   388|         self.opts = opts
   389|         self.master_pub_path = os.path.join(self.opts["pki_dir"], "master.pub")
   390|         self.master_rsa_path = os.path.join(self.opts["pki_dir"], "master.pem")
   391|         key_pass = salt.utils.sdb.sdb_get(self.opts["key_pass"], self.opts)
   392|         self.master_key = self.__get_keys(passphrase=key_pass)
   393|         self.cluster_pub_path = None
   394|         self.cluster_rsa_path = None
   395|         self.cluster_key = None
   396|         if self.opts["cluster_id"]:
   397|             self.cluster_pub_path = os.path.join(
   398|                 self.opts["cluster_pki_dir"], "cluster.pub"
   399|             )
   400|             self.cluster_rsa_path = os.path.join(
   401|                 self.opts["cluster_pki_dir"], "cluster.pem"
   402|             )
   403|             self.cluster_shared_path = os.path.join(
   404|                 self.opts["cluster_pki_dir"],
   405|                 "peers",
   406|                 f"{self.opts['id']}.pub",
   407|             )
   408|             self.check_master_shared_pub()
   409|             key_pass = salt.utils.sdb.sdb_get(self.opts["cluster_key_pass"], self.opts)
   410|             self.cluster_key = self.__get_keys(
   411|                 name="cluster",
   412|                 passphrase=key_pass,
   413|                 pki_dir=self.opts["cluster_pki_dir"],
   414|             )
   415|         self.pub_signature = None
   416|         if opts["master_sign_pubkey"]:
   417|             if opts["master_use_pubkey_signature"]:
   418|                 self.sig_path = os.path.join(
   419|                     self.opts["pki_dir"], opts["master_pubkey_signature"]
   420|                 )
   421|                 if os.path.isfile(self.sig_path):
   422|                     with salt.utils.files.fopen(self.sig_path) as fp_:
   423|                         self.pub_signature = clean_key(fp_.read())
   424|                     log.info(
   425|                         "Read %s's signature from %s",
   426|                         os.path.basename(self.pub_path),
   427|                         self.opts["master_pubkey_signature"],
   428|                     )
   429|                 else:
   430|                     log.error(
   431|                         "Signing the master.pub key with a signature is "
   432|                         "enabled but no signature file found at the defined "
   433|                         "location %s",
   434|                         self.sig_path,

# --- HUNK 2: Lines 436-687 ---
   436|                     log.error(
   437|                         "The signature-file may be either named differently "
   438|                         "or has to be created with 'salt-key --gen-signature'"
   439|                     )
   440|                     sys.exit(1)
   441|             else:
   442|                 key_pass = salt.utils.sdb.sdb_get(
   443|                     self.opts["signing_key_pass"], self.opts
   444|                 )
   445|                 self.pub_sign_path = os.path.join(
   446|                     self.opts["pki_dir"], opts["master_sign_key_name"] + ".pub"
   447|                 )
   448|                 self.rsa_sign_path = os.path.join(
   449|                     self.opts["pki_dir"], opts["master_sign_key_name"] + ".pem"
   450|                 )
   451|                 self.sign_key = self.__get_keys(name=opts["master_sign_key_name"])
   452|     def __setstate__(self, state):
   453|         self.__init__(state["opts"])
   454|     def __getstate__(self):
   455|         return {"opts": self.opts}
   456|     @property
   457|     def key(self):
   458|         if self.cluster_key:
   459|             return self.cluster_key
   460|         return self.master_key
   461|     @property
   462|     def pub_path(self):
   463|         if self.cluster_pub_path:
   464|             return self.cluster_pub_path
   465|         return self.master_pub_path
   466|     @property
   467|     def rsa_path(self):
   468|         if self.cluster_rsa_path:
   469|             return self.cluster_rsa_path
   470|         return self.master_rsa_path
   471|     def __key_exists(self, name="master", passphrase=None, pki_dir=None):
   472|         if pki_dir is None:
   473|             pki_dir = self.opts["pki_dir"]
   474|         path = os.path.join(pki_dir, name + ".pem")
   475|         return os.path.exists(path)
   476|     def __get_keys(self, name="master", passphrase=None, pki_dir=None):
   477|         """
   478|         Returns a key object for a key in the pki-dir
   479|         """
   480|         if pki_dir is None:
   481|             pki_dir = self.opts["pki_dir"]
   482|         path = os.path.join(pki_dir, name + ".pem")
   483|         if not self.__key_exists(name, passphrase, pki_dir):
   484|             log.info("Generating %s keys: %s", name, pki_dir)
   485|             gen_keys(
   486|                 pki_dir,
   487|                 name,
   488|                 self.opts["keysize"],
   489|                 self.opts.get("user"),
   490|                 passphrase,
   491|             )
   492|         if HAS_M2:
   493|             key_error = RSA.RSAError
   494|         else:
   495|             key_error = ValueError
   496|         try:
   497|             key = get_rsa_key(path, passphrase)
   498|         except key_error as e:
   499|             message = f"Unable to read key: {path}; passphrase may be incorrect"
   500|             log.error(message)
   501|             raise MasterExit(message)
   502|         log.debug("Loaded %s key: %s", name, path)
   503|         return key
   504|     def get_pub_str(self, name="master"):
   505|         """
   506|         Return the string representation of a public key
   507|         in the pki-directory
   508|         """
   509|         if self.cluster_pub_path:
   510|             path = self.cluster_pub_path
   511|         else:
   512|             path = self.master_pub_path
   513|         if not os.path.isfile(path):
   514|             key = self.__get_keys()
   515|             if HAS_M2:
   516|                 key.save_pub_key(path)
   517|             else:
   518|                 with salt.utils.files.fopen(path, "wb+") as wfh:
   519|                     wfh.write(key.publickey().exportKey("PEM"))
   520|         with salt.utils.files.fopen(path) as rfh:
   521|             return clean_key(rfh.read())
   522|     def get_ckey_paths(self):
   523|         return self.cluster_pub_path, self.cluster_rsa_path
   524|     def get_mkey_paths(self):
   525|         return self.pub_path, self.rsa_path
   526|     def get_sign_paths(self):
   527|         return self.pub_sign_path, self.rsa_sign_path
   528|     def pubkey_signature(self):
   529|         """
   530|         returns the base64 encoded signature from the signature file
   531|         or None if the master has its own signing keys
   532|         """
   533|         return self.pub_signature
   534|     def check_master_shared_pub(self):
   535|         """
   536|         Check the status of the master's shared public key.
   537|         If the shared master key does not exist, write this master's public key
   538|         to the shared location. Otherwise validate the shared key matches our
   539|         key. Failed validation raises MasterExit
   540|         """
   541|         shared_pub = pathlib.Path(self.cluster_shared_path)
   542|         master_pub = pathlib.Path(self.master_pub_path)
   543|         if shared_pub.exists():
   544|             if shared_pub.read_bytes() != master_pub.read_bytes():
   545|                 message = (
   546|                     f"Shared key does not match, remove it to continue: {shared_pub}"
   547|                 )
   548|                 log.error(message)
   549|                 raise MasterExit(message)
   550|         else:
   551|             log.debug("Writing shared key %s", shared_pub)
   552|             shared_pub.write_bytes(master_pub.read_bytes())
   553|     def master_private_decrypt(self, data):
   554|         if HAS_M2:
   555|             return self.master_key.private_decrypt(data, RSA.pkcs1_oaep_padding)
   556|         else:
   557|             cipher = PKCS1_OAEP.new(self.master_key)
   558|             return cipher.decrypt(data)
   559| class AsyncAuth:
   560|     """
   561|     Set up an Async object to maintain authentication with the salt master
   562|     """
   563|     instance_map = weakref.WeakKeyDictionary()
   564|     creds_map = {}
   565|     def __new__(cls, opts, io_loop=None):
   566|         """
   567|         Only create one instance of AsyncAuth per __key()
   568|         """
   569|         io_loop = io_loop or tornado.ioloop.IOLoop.current()
   570|         if io_loop not in AsyncAuth.instance_map:
   571|             AsyncAuth.instance_map[io_loop] = weakref.WeakValueDictionary()
   572|         loop_instance_map = AsyncAuth.instance_map[io_loop]
   573|         key = cls.__key(opts)
   574|         auth = loop_instance_map.get(key)
   575|         if auth is None:
   576|             log.debug("Initializing new AsyncAuth for %s", key)
   577|             auth = object.__new__(cls)
   578|             auth.__singleton_init__(opts, io_loop=io_loop)
   579|             loop_instance_map[key] = auth
   580|         else:
   581|             log.debug("Re-using AsyncAuth for %s", key)
   582|         return auth
   583|     @classmethod
   584|     def __key(cls, opts, io_loop=None):
   585|         return (
   586|             opts["pki_dir"],  # where the keys are stored
   587|             opts["id"],  # minion ID
   588|             opts["master_uri"],  # master ID
   589|         )
   590|     def __init__(self, opts, io_loop=None):
   591|         pass
   592|     def __singleton_init__(self, opts, io_loop=None):
   593|         """
   594|         Init an Auth instance
   595|         :param dict opts: Options for this server
   596|         :return: Auth instance
   597|         :rtype: Auth
   598|         """
   599|         self.opts = opts
   600|         self.token = salt.utils.stringutils.to_bytes(Crypticle.generate_key_string())
   601|         self.pub_path = os.path.join(self.opts["pki_dir"], "minion.pub")
   602|         self.rsa_path = os.path.join(self.opts["pki_dir"], "minion.pem")
   603|         if self.opts["__role"] == "syndic":
   604|             self.mpub = "syndic_master.pub"
   605|         else:
   606|             self.mpub = "minion_master.pub"
   607|         if not os.path.isfile(self.pub_path):
   608|             self.get_keys()
   609|         self.io_loop = io_loop or tornado.ioloop.IOLoop.current()
   610|         salt.utils.crypt.reinit_crypto()
   611|         key = self.__key(self.opts)
   612|         if key in AsyncAuth.creds_map:
   613|             creds = AsyncAuth.creds_map[key]
   614|             self._creds = creds
   615|             self._crypticle = Crypticle(self.opts, creds["aes"])
   616|             self._authenticate_future = tornado.concurrent.Future()
   617|             self._authenticate_future.set_result(True)
   618|     def __deepcopy__(self, memo):
   619|         cls = self.__class__
   620|         result = cls.__new__(cls, copy.deepcopy(self.opts, memo))
   621|         memo[id(self)] = result
   622|         for key in self.__dict__:
   623|             if key in ("io_loop",):
   624|                 continue
   625|             setattr(result, key, copy.deepcopy(self.__dict__[key], memo))
   626|         return result
   627|     @property
   628|     def creds(self):
   629|         return self._creds
   630|     @property
   631|     def crypticle(self):
   632|         return self._crypticle
   633|     @property
   634|     def authenticated(self):
   635|         return (
   636|             hasattr(self, "_authenticate_future")
   637|             and self._authenticate_future.done()
   638|             and self._authenticate_future.exception() is None
   639|         )
   640|     def invalidate(self):
   641|         if self.authenticated:
   642|             del self._authenticate_future
   643|             key = self.__key(self.opts)
   644|             if key in AsyncAuth.creds_map:
   645|                 del AsyncAuth.creds_map[key]
   646|     def authenticate(self, callback=None):
   647|         """
   648|         Ask for this client to reconnect to the origin
   649|         This function will de-dupe all calls here and return a *single* future
   650|         for the sign-in-- whis way callers can all assume there aren't others
   651|         """
   652|         if (
   653|             hasattr(self, "_authenticate_future")
   654|             and not self._authenticate_future.done()
   655|         ):
   656|             future = self._authenticate_future
   657|         else:
   658|             future = tornado.concurrent.Future()
   659|             self._authenticate_future = future
   660|             self.io_loop.add_callback(self._authenticate)
   661|         if callback is not None:
   662|             def handle_future(future):
   663|                 response = future.result()
   664|                 self.io_loop.add_callback(callback, response)
   665|             future.add_done_callback(handle_future)
   666|         return future
   667|     @tornado.gen.coroutine
   668|     def _authenticate(self):
   669|         """
   670|         Authenticate with the master, this method breaks the functional
   671|         paradigm, it will update the master information from a fresh sign
   672|         in, signing in can occur as often as needed to keep up with the
   673|         revolving master AES key.
   674|         :rtype: Crypticle
   675|         :returns: A crypticle used for encryption operations
   676|         """
   677|         acceptance_wait_time = self.opts["acceptance_wait_time"]
   678|         acceptance_wait_time_max = self.opts["acceptance_wait_time_max"]
   679|         if not acceptance_wait_time_max:
   680|             acceptance_wait_time_max = acceptance_wait_time
   681|         creds = None
   682|         with salt.channel.client.AsyncReqChannel.factory(
   683|             self.opts, crypt="clear", io_loop=self.io_loop
   684|         ) as channel:
   685|             error = None
   686|             while True:
   687|                 try:

# --- HUNK 3: Lines 694-854 ---
   694|                         error = SaltClientError("Detect mode is on")
   695|                         break
   696|                     if self.opts.get("caller"):
   697|                         if self.opts.get("local_masters", None):
   698|                             error = SaltClientError(
   699|                                 "Minion failed to authenticate"
   700|                                 " with the master, has the "
   701|                                 "minion key been accepted?"
   702|                             )
   703|                             break
   704|                         else:
   705|                             print(
   706|                                 "Minion failed to authenticate with the master, "
   707|                                 "has the minion key been accepted?"
   708|                             )
   709|                             sys.exit(2)
   710|                     if acceptance_wait_time:
   711|                         log.info(
   712|                             "Waiting %s seconds before retry.", acceptance_wait_time
   713|                         )
   714|                         yield tornado.gen.sleep(acceptance_wait_time)
   715|                     if acceptance_wait_time < acceptance_wait_time_max:
   716|                         acceptance_wait_time += acceptance_wait_time
   717|                         log.debug(
   718|                             "Authentication wait time is %s", acceptance_wait_time
   719|                         )
   720|                     continue
   721|                 break
   722|             if not isinstance(creds, dict) or "aes" not in creds:
   723|                 if self.opts.get("detect_mode") is True:
   724|                     error = SaltClientError("-|RETRY|-")
   725|                 try:
   726|                     del AsyncAuth.creds_map[self.__key(self.opts)]
   727|                 except KeyError:
   728|                     pass
   729|                 if not error:
   730|                     error = SaltClientError(
   731|                         "Attempt to authenticate with the salt master failed"
   732|                     )
   733|                 self._authenticate_future.set_exception(error)
   734|             else:
   735|                 key = self.__key(self.opts)
   736|                 if key not in AsyncAuth.creds_map:
   737|                     log.debug("%s Got new master aes key.", self)
   738|                     AsyncAuth.creds_map[key] = creds
   739|                     self._creds = creds
   740|                     self._crypticle = Crypticle(self.opts, creds["aes"])
   741|                 elif self._creds["aes"] != creds["aes"]:
   742|                     log.debug("%s The master's aes key has changed.", self)
   743|                     AsyncAuth.creds_map[key] = creds
   744|                     self._creds = creds
   745|                     self._crypticle = Crypticle(self.opts, creds["aes"])
   746|                 self._authenticate_future.set_result(
   747|                     True
   748|                 )  # mark the sign-in as complete
   749|                 if self.opts.get("auth_events") is True:
   750|                     with salt.utils.event.get_event(
   751|                         self.opts.get("__role"), opts=self.opts, listen=False
   752|                     ) as event:
   753|                         event.fire_event(
   754|                             {"key": key, "creds": creds},
   755|                             salt.utils.event.tagify(prefix="auth", suffix="creds"),
   756|                         )
   757|     @tornado.gen.coroutine
   758|     def sign_in(self, timeout=60, safe=True, tries=1, channel=None):
   759|         """
   760|         Send a sign in request to the master, sets the key information and
   761|         returns a dict containing the master publish interface to bind to
   762|         and the decrypted aes key for transport decryption.
   763|         :param int timeout: Number of seconds to wait before timing out the sign-in request
   764|         :param bool safe: If True, do not raise an exception on timeout. Retry instead.
   765|         :param int tries: The number of times to try to authenticate before giving up.
   766|         :raises SaltReqTimeoutError: If the sign-in request has timed out and :param safe: is not set
   767|         :return: Return a string on failure indicating the reason for failure. On success, return a dictionary
   768|         with the publication port and the shared AES key.
   769|         """
   770|         auth_timeout = self.opts.get("auth_timeout", None)
   771|         if auth_timeout is not None:
   772|             timeout = auth_timeout
   773|         auth_safemode = self.opts.get("auth_safemode", None)
   774|         if auth_safemode is not None:
   775|             safe = auth_safemode
   776|         auth_tries = self.opts.get("auth_tries", None)
   777|         if auth_tries is not None:
   778|             tries = auth_tries
   779|         close_channel = False
   780|         if not channel:
   781|             close_channel = True
   782|             channel = salt.channel.client.AsyncReqChannel.factory(
   783|                 self.opts, crypt="clear", io_loop=self.io_loop
   784|             )
   785|         sign_in_payload = self.minion_sign_in_payload()
   786|         try:
   787|             payload = yield channel.send(sign_in_payload, tries=tries, timeout=timeout)
   788|         except SaltReqTimeoutError as e:
   789|             if safe:
   790|                 log.warning("SaltReqTimeoutError: %s", e)
   791|                 raise tornado.gen.Return("retry")
   792|             if self.opts.get("detect_mode") is True:
   793|                 raise tornado.gen.Return("retry")
   794|             else:
   795|                 raise SaltClientError(
   796|                     "Attempt to authenticate with the salt master failed with timeout"
   797|                     " error"
   798|                 )
   799|         finally:
   800|             if close_channel:
   801|                 channel.close()
   802|         ret = self.handle_signin_response(sign_in_payload, payload)
   803|         raise tornado.gen.Return(ret)
   804|     def handle_signin_response(self, sign_in_payload, payload):
   805|         auth = {}
   806|         m_pub_fn = os.path.join(self.opts["pki_dir"], self.mpub)
   807|         auth["master_uri"] = self.opts["master_uri"]
   808|         if not isinstance(payload, dict) or "load" not in payload:
   809|             log.error("Sign-in attempt failed: %s", payload)
   810|             return False
   811|         clear_signed_data = payload["load"]
   812|         clear_signature = payload["sig"]
   813|         payload = salt.payload.loads(clear_signed_data)
   814|         if "pub_key" in payload:
   815|             auth["aes"] = self.verify_master(
   816|                 payload, master_pub="token" in sign_in_payload
   817|             )
   818|             if not auth["aes"]:
   819|                 log.critical(
   820|                     "The Salt Master server's public key did not authenticate!\n"
   821|                     "The master may need to be updated if it is a version of Salt "
   822|                     "lower than %s, or\n"
   823|                     "If you are confident that you are connecting to a valid Salt "
   824|                     "Master, then remove the master public key and restart the "
   825|                     "Salt Minion.\nThe master public key can be found "
   826|                     "at:\n%s",
   827|                     salt.version.__version__,
   828|                     m_pub_fn,
   829|                 )
   830|                 raise SaltClientError("Invalid master key")
   831|         master_pubkey_path = os.path.join(self.opts["pki_dir"], self.mpub)
   832|         if os.path.exists(master_pubkey_path) and not PublicKey(
   833|             master_pubkey_path
   834|         ).verify(clear_signed_data, clear_signature):
   835|             log.critical("The payload signature did not validate.")
   836|             raise SaltClientError("Invalid signature")
   837|         if payload["nonce"] != sign_in_payload["nonce"]:
   838|             log.critical("The payload nonce did not validate.")
   839|             raise SaltClientError("Invalid nonce")
   840|         if "ret" in payload:
   841|             if not payload["ret"]:
   842|                 if self.opts["rejected_retry"]:
   843|                     log.error(
   844|                         "The Salt Master has rejected this minion's public "
   845|                         "key.\nTo repair this issue, delete the public key "
   846|                         "for this minion on the Salt Master.\nThe Salt "
   847|                         "Minion will attempt to re-authenicate."
   848|                     )
   849|                     return "retry"
   850|                 else:
   851|                     log.critical(
   852|                         "The Salt Master has rejected this minion's public "
   853|                         "key!\nTo repair this issue, delete the public key "
   854|                         "for this minion on the Salt Master and restart this "

# --- HUNK 4: Lines 889-1046 ---
   889|                 ):
   890|                     self._finger_fail(self.opts["master_finger"], m_pub_fn)
   891|         auth["publish_port"] = payload["publish_port"]
   892|         return auth
   893|     def get_keys(self):
   894|         """
   895|         Return keypair object for the minion.
   896|         :rtype: Crypto.PublicKey.RSA._RSAobj
   897|         :return: The RSA keypair
   898|         """
   899|         user = self.opts.get("user", "root")
   900|         salt.utils.verify.check_path_traversal(self.opts["pki_dir"], user)
   901|         if not os.path.exists(self.rsa_path):
   902|             log.info("Generating keys: %s", self.opts["pki_dir"])
   903|             gen_keys(
   904|                 self.opts["pki_dir"],
   905|                 "minion",
   906|                 self.opts["keysize"],
   907|                 self.opts.get("user"),
   908|             )
   909|         key = get_rsa_key(self.rsa_path, None)
   910|         log.debug("Loaded minion key: %s", self.rsa_path)
   911|         return key
   912|     def gen_token(self, clear_tok):
   913|         """
   914|         Encrypt a string with the minion private key to verify identity
   915|         with the master.
   916|         :param str clear_tok: A plaintext token to encrypt
   917|         :return: Encrypted token
   918|         :rtype: str
   919|         """
   920|         return private_encrypt(self.get_keys(), clear_tok)
   921|     def minion_sign_in_payload(self):
   922|         """
   923|         Generates the payload used to authenticate with the master
   924|         server. This payload consists of the passed in id_ and the ssh
   925|         public key to encrypt the AES key sent back from the master.
   926|         :return: Payload dictionary
   927|         :rtype: dict
   928|         """
   929|         payload = {}
   930|         payload["cmd"] = "_auth"
   931|         payload["id"] = self.opts["id"]
   932|         payload["nonce"] = uuid.uuid4().hex
   933|         if "autosign_grains" in self.opts:
   934|             autosign_grains = {}
   935|             for grain in self.opts["autosign_grains"]:
   936|                 autosign_grains[grain] = self.opts["grains"].get(grain, None)
   937|             payload["autosign_grains"] = autosign_grains
   938|         try:
   939|             pubkey_path = os.path.join(self.opts["pki_dir"], self.mpub)
   940|             pub = get_rsa_pub_key(pubkey_path)
   941|             if HAS_M2:
   942|                 payload["token"] = pub.public_encrypt(
   943|                     self.token, RSA.pkcs1_oaep_padding
   944|                 )
   945|             else:
   946|                 cipher = PKCS1_OAEP.new(pub)
   947|                 payload["token"] = cipher.encrypt(self.token)
   948|         except Exception:  # pylint: disable=broad-except
   949|             pass
   950|         with salt.utils.files.fopen(self.pub_path) as f:
   951|             payload["pub"] = clean_key(f.read())
   952|         return payload
   953|     def decrypt_aes(self, payload, master_pub=True):
   954|         """
   955|         This function is used to decrypt the AES seed phrase returned from
   956|         the master server. The seed phrase is decrypted with the SSH RSA
   957|         host key.
   958|         Pass in the encrypted AES key.
   959|         Returns the decrypted AES seed key, a string
   960|         :param dict payload: The incoming payload. This is a dictionary which may have the following keys:
   961|             'aes': The shared AES key
   962|             'enc': The format of the message. ('clear', 'pub', etc)
   963|             'sig': The message signature
   964|             'publish_port': The TCP port which published the message
   965|             'token': The encrypted token used to verify the message.
   966|             'pub_key': The public key of the sender.
   967|         :rtype: str
   968|         :return: The decrypted token that was provided, with padding.
   969|         :rtype: str
   970|         :return: The decrypted AES seed key
   971|         """
   972|         if self.opts.get("auth_trb", False):
   973|             log.warning("Auth Called: %s", "".join(traceback.format_stack()))
   974|         else:
   975|             log.debug("Decrypting the current master AES key")
   976|         key = self.get_keys()
   977|         if HAS_M2:
   978|             key_str = key.private_decrypt(payload["aes"], RSA.pkcs1_oaep_padding)
   979|         else:
   980|             cipher = PKCS1_OAEP.new(key)
   981|             key_str = cipher.decrypt(payload["aes"])
   982|         if "sig" in payload:
   983|             m_path = os.path.join(self.opts["pki_dir"], self.mpub)
   984|             if os.path.exists(m_path):
   985|                 try:
   986|                     mkey = get_rsa_pub_key(m_path)
   987|                 except Exception:  # pylint: disable=broad-except
   988|                     return "", ""
   989|                 digest = hashlib.sha256(key_str).hexdigest()
   990|                 digest = salt.utils.stringutils.to_bytes(digest)
   991|                 if HAS_M2:
   992|                     m_digest = public_decrypt(mkey, payload["sig"])
   993|                 else:
   994|                     m_digest = public_decrypt(mkey.publickey(), payload["sig"])
   995|                 if m_digest != digest:
   996|                     return "", ""
   997|         else:
   998|             return "", ""
   999|         key_str = salt.utils.stringutils.to_str(key_str)
  1000|         if "_|-" in key_str:
  1001|             return key_str.split("_|-")
  1002|         else:
  1003|             if "token" in payload:
  1004|                 if HAS_M2:
  1005|                     token = key.private_decrypt(
  1006|                         payload["token"], RSA.pkcs1_oaep_padding
  1007|                     )
  1008|                 else:
  1009|                     token = cipher.decrypt(payload["token"])
  1010|                 return key_str, token
  1011|             elif not master_pub:
  1012|                 return key_str, ""
  1013|         return "", ""
  1014|     def verify_pubkey_sig(self, message, sig):
  1015|         """
  1016|         Wraps the verify_signature method so we have
  1017|         additional checks.
  1018|         :rtype: bool
  1019|         :return: Success or failure of public key verification
  1020|         """
  1021|         if self.opts["master_sign_key_name"]:
  1022|             path = os.path.join(
  1023|                 self.opts["pki_dir"], self.opts["master_sign_key_name"] + ".pub"
  1024|             )
  1025|             if os.path.isfile(path):
  1026|                 res = verify_signature(path, message, binascii.a2b_base64(sig))
  1027|             else:
  1028|                 log.error(
  1029|                     "Verification public key %s does not exist. You need to "
  1030|                     "copy it from the master to the minions pki directory",
  1031|                     os.path.basename(path),
  1032|                 )
  1033|                 return False
  1034|             if res:
  1035|                 log.debug(
  1036|                     "Successfully verified signature of master public key "
  1037|                     "with verification public key %s",
  1038|                     self.opts["master_sign_key_name"] + ".pub",
  1039|                 )
  1040|                 return True
  1041|             else:
  1042|                 log.debug("Failed to verify signature of public key")
  1043|                 return False
  1044|         else:
  1045|             log.error(
  1046|                 "Failed to verify the signature of the message because the "

# --- HUNK 5: Lines 1353-1487 ---
  1353|             )
  1354|         finally:
  1355|             if close_channel:
  1356|                 channel.close()
  1357|         return self.handle_signin_response(sign_in_payload, payload)
  1358| class Crypticle:
  1359|     """
  1360|     Authenticated encryption class
  1361|     Encryption algorithm: AES-CBC
  1362|     Signing algorithm: HMAC-SHA256
  1363|     """
  1364|     PICKLE_PAD = b"pickle::"
  1365|     AES_BLOCK_SIZE = 16
  1366|     SIG_SIZE = hashlib.sha256().digest_size
  1367|     def __init__(self, opts, key_string, key_size=192, serial=0):
  1368|         self.key_string = key_string
  1369|         self.keys = self.extract_keys(self.key_string, key_size)
  1370|         self.key_size = key_size
  1371|         self.serial = serial
  1372|     @classmethod
  1373|     def generate_key_string(cls, key_size=192, **kwargs):
  1374|         key = os.urandom(key_size // 8 + cls.SIG_SIZE)
  1375|         b64key = base64.b64encode(key)
  1376|         b64key = b64key.decode("utf-8")
  1377|         return b64key.replace("\n", "")
  1378|     @classmethod
  1379|     def write_key(cls, path, key_size=192):
  1380|         directory = pathlib.Path(path).parent
  1381|         with salt.utils.files.set_umask(0o177):
  1382|             fd, tmp = tempfile.mkstemp(dir=directory, prefix="aes")
  1383|             os.close(fd)
  1384|             with salt.utils.files.fopen(tmp, "w") as fp:
  1385|                 fp.write(cls.generate_key_string(key_size))
  1386|             os.rename(tmp, path)
  1387|     @classmethod
  1388|     def read_key(cls, path):
  1389|         try:
  1390|             with salt.utils.files.fopen(path, "r") as fp:
  1391|                 return fp.read()
  1392|         except FileNotFoundError:
  1393|             pass
  1394|     @classmethod
  1395|     def extract_keys(cls, key_string, key_size):
  1396|         key = salt.utils.stringutils.to_bytes(base64.b64decode(key_string))
  1397|         assert len(key) == key_size / 8 + cls.SIG_SIZE, "invalid key"
  1398|         return key[: -cls.SIG_SIZE], key[-cls.SIG_SIZE :]
  1399|     def encrypt(self, data):
  1400|         """
  1401|         encrypt data with AES-CBC and sign it with HMAC-SHA256
  1402|         """
  1403|         aes_key, hmac_key = self.keys
  1404|         pad = self.AES_BLOCK_SIZE - len(data) % self.AES_BLOCK_SIZE
  1405|         data = data + salt.utils.stringutils.to_bytes(pad * chr(pad))
  1406|         iv_bytes = os.urandom(self.AES_BLOCK_SIZE)
  1407|         if HAS_M2:
  1408|             cypher = EVP.Cipher(
  1409|                 alg="aes_192_cbc", key=aes_key, iv=iv_bytes, op=1, padding=False
  1410|             )
  1411|             encr = cypher.update(data)
  1412|             encr += cypher.final()
  1413|         else:
  1414|             cypher = AES.new(aes_key, AES.MODE_CBC, iv_bytes)
  1415|             encr = cypher.encrypt(data)
  1416|         data = iv_bytes + encr
  1417|         sig = hmac.new(hmac_key, data, hashlib.sha256).digest()
  1418|         return data + sig
  1419|     def decrypt(self, data):
  1420|         """
  1421|         verify HMAC-SHA256 signature and decrypt data with AES-CBC
  1422|         """
  1423|         aes_key, hmac_key = self.keys
  1424|         sig = data[-self.SIG_SIZE :]
  1425|         data = data[: -self.SIG_SIZE]
  1426|         if not isinstance(data, bytes):
  1427|             data = salt.utils.stringutils.to_bytes(data)
  1428|         mac_bytes = hmac.new(hmac_key, data, hashlib.sha256).digest()
  1429|         if len(mac_bytes) != len(sig):
  1430|             log.debug("Failed to authenticate message")
  1431|             raise AuthenticationError("message authentication failed")
  1432|         result = 0
  1433|         for zipped_x, zipped_y in zip(mac_bytes, sig):
  1434|             result |= zipped_x ^ zipped_y
  1435|         if result != 0:
  1436|             log.debug("Failed to authenticate message")
  1437|             raise AuthenticationError("message authentication failed")
  1438|         iv_bytes = data[: self.AES_BLOCK_SIZE]
  1439|         data = data[self.AES_BLOCK_SIZE :]
  1440|         if HAS_M2:
  1441|             cypher = EVP.Cipher(
  1442|                 alg="aes_192_cbc", key=aes_key, iv=iv_bytes, op=0, padding=False
  1443|             )
  1444|             encr = cypher.update(data)
  1445|             data = encr + cypher.final()
  1446|         else:
  1447|             cypher = AES.new(aes_key, AES.MODE_CBC, iv_bytes)
  1448|             data = cypher.decrypt(data)
  1449|         return data[: -data[-1]]
  1450|     def dumps(self, obj, nonce=None):
  1451|         """
  1452|         Serialize and encrypt a python object
  1453|         """
  1454|         if nonce:
  1455|             toencrypt = self.PICKLE_PAD + nonce.encode() + salt.payload.dumps(obj)
  1456|         else:
  1457|             toencrypt = self.PICKLE_PAD + salt.payload.dumps(obj)
  1458|         return self.encrypt(toencrypt)
  1459|     def loads(self, data, raw=False, nonce=None):
  1460|         """
  1461|         Decrypt and un-serialize a python object
  1462|         """
  1463|         data = self.decrypt(data)
  1464|         if not data.startswith(self.PICKLE_PAD):
  1465|             return {}
  1466|         data = data[len(self.PICKLE_PAD) :]
  1467|         if nonce:
  1468|             ret_nonce = data[:32].decode()
  1469|             data = data[32:]
  1470|             if ret_nonce != nonce:
  1471|                 raise SaltClientError(f"Nonce verification error {ret_nonce} {nonce}")
  1472|         payload = salt.payload.loads(data, raw=raw)
  1473|         if isinstance(payload, dict):
  1474|             if "serial" in payload:
  1475|                 serial = payload.pop("serial")
  1476|                 if serial <= self.serial:
  1477|                     log.critical(
  1478|                         "A message with an invalid serial was received.\n"
  1479|                         "this serial: %d\n"
  1480|                         "last serial: %d\n"
  1481|                         "The minion will not honor this request.",
  1482|                         serial,
  1483|                         self.serial,
  1484|                     )
  1485|                     return {}
  1486|                 self.serial = serial
  1487|         return payload


# ====================================================================
# FILE: salt/daemons/masterapi.py
# Total hunks: 5
# ====================================================================
# --- HUNK 1: Lines 96-136 ---
    96|                     os.remove(cache_file)
    97|                 except OSError as exc:
    98|                     log.critical(
    99|                         "Unable to file_lists cache file %s: %s", cache_file, exc
   100|                     )
   101| def clean_expired_tokens(opts):
   102|     """
   103|     Clean expired tokens from the master
   104|     """
   105|     loadauth = salt.auth.LoadAuth(opts)
   106|     for tok in loadauth.list_tokens():
   107|         token_data = loadauth.get_tok(tok)
   108|         if "expire" not in token_data or token_data.get("expire", 0) < time.time():
   109|             loadauth.rm_token(tok)
   110| def clean_pub_auth(opts):
   111|     try:
   112|         auth_cache = os.path.join(opts["cachedir"], "publish_auth")
   113|         if not os.path.exists(auth_cache):
   114|             return
   115|         else:
   116|             for (dirpath, dirnames, filenames) in salt.utils.path.os_walk(auth_cache):
   117|                 for auth_file in filenames:
   118|                     auth_file_path = os.path.join(dirpath, auth_file)
   119|                     if not os.path.isfile(auth_file_path):
   120|                         continue
   121|                     if time.time() - os.path.getmtime(auth_file_path) > (
   122|                         salt.utils.job.get_keep_jobs_seconds(opts)
   123|                     ):
   124|                         os.remove(auth_file_path)
   125|     except OSError:
   126|         log.error("Unable to delete pub auth file")
   127| def clean_old_jobs(opts):
   128|     """
   129|     Clean out the old jobs from the job cache
   130|     """
   131|     mminion = salt.minion.MasterMinion(
   132|         opts,
   133|         states=False,
   134|         rend=False,
   135|     )
   136|     fstr = "{}.clean_old_jobs".format(opts["master_job_cache"])

# --- HUNK 2: Lines 162-221 ---
   162|     os.chmod(keyfile, 0o600)
   163|     if HAS_PWD and uid is not None:
   164|         try:
   165|             os.chown(keyfile, uid, -1)
   166|         except OSError:
   167|             pass
   168|     return key
   169| def access_keys(opts):
   170|     """
   171|     A key needs to be placed in the filesystem with permissions 0400 so
   172|     clients are required to run as root.
   173|     """
   174|     keys = {}
   175|     publisher_acl = opts["publisher_acl"]
   176|     acl_users = set(publisher_acl.keys())
   177|     if opts.get("user"):
   178|         acl_users.add(opts["user"])
   179|     acl_users.add(salt.utils.user.get_user())
   180|     for user in acl_users:
   181|         log.info("Preparing the %s key for local communication", user)
   182|         keyfile = os.path.join(opts["cachedir"], f".{user}_key")
   183|         if os.path.exists(keyfile):
   184|             with salt.utils.files.fopen(keyfile, "r") as fp:
   185|                 key = salt.utils.stringutils.to_unicode(fp.read())
   186|         else:
   187|             key = mk_key(opts, user)
   188|         if key is not None:
   189|             keys[user] = key
   190|     if opts["client_acl_verify"] and HAS_PWD:
   191|         log.profile("Beginning pwd.getpwall() call in masterapi access_keys function")
   192|         for user in pwd.getpwall():
   193|             user = user.pw_name
   194|             if user not in keys and salt.utils.stringutils.check_whitelist_blacklist(
   195|                 user, whitelist=acl_users
   196|             ):
   197|                 if os.path.exists(keyfile):
   198|                     with salt.utils.files.fopen(keyfile, "r") as fp:
   199|                         keys[user] = salt.utils.stringutils.to_unicode(fp.read())
   200|                 else:
   201|                     keys[user] = mk_key(opts, user)
   202|         log.profile("End pwd.getpwall() call in masterapi access_keys function")
   203|     return keys
   204| def fileserver_update(fileserver):
   205|     """
   206|     Update the fileserver backends, requires that a salt.fileserver.Fileserver
   207|     object be passed in
   208|     """
   209|     try:
   210|         if not fileserver.servers:
   211|             log.error(
   212|                 "No fileservers loaded, the master will not be able to "
   213|                 "serve files to minions"
   214|             )
   215|             raise salt.exceptions.SaltMasterError("No fileserver backends available")
   216|         fileserver.update()
   217|     except Exception as exc:  # pylint: disable=broad-except
   218|         log.error(
   219|             "Exception %s occurred in file server update",
   220|             exc,
   221|             exc_info_on_loglevel=logging.DEBUG,

# --- HUNK 3: Lines 252-333 ---
   252|         if not self.check_permissions(signing_file):
   253|             log.warning("Wrong permissions for %s, ignoring content", signing_file)
   254|             return False
   255|         mtime = os.path.getmtime(signing_file)
   256|         if self.signing_files.get(signing_file, {}).get("mtime") != mtime:
   257|             self.signing_files.setdefault(signing_file, {})["mtime"] = mtime
   258|             with salt.utils.files.fopen(signing_file, "r") as fp_:
   259|                 self.signing_files[signing_file]["data"] = [
   260|                     entry
   261|                     for entry in [line.strip() for line in fp_]
   262|                     if not entry.strip().startswith("#")
   263|                 ]
   264|         return any(
   265|             salt.utils.stringutils.expr_match(keyid, line)
   266|             for line in self.signing_files[signing_file].get("data", [])
   267|         )
   268|     def check_autosign_dir(self, keyid):
   269|         """
   270|         Check a keyid for membership in a autosign directory.
   271|         """
   272|         if self.opts["cluster_id"]:
   273|             pki_dir = self.opts["cluster_pki_dir"]
   274|         else:
   275|             pki_dir = self.opts["pki_dir"]
   276|         autosign_dir = os.path.join(pki_dir, "minions_autosign")
   277|         expire_minutes = self.opts.get("autosign_timeout", 120)
   278|         if expire_minutes > 0:
   279|             min_time = time.time() - (60 * int(expire_minutes))
   280|             for root, dirs, filenames in salt.utils.path.os_walk(autosign_dir):
   281|                 for f in filenames:
   282|                     stub_file = os.path.join(autosign_dir, f)
   283|                     mtime = os.path.getmtime(stub_file)
   284|                     if mtime < min_time:
   285|                         log.warning("Autosign keyid expired %s", stub_file)
   286|                         os.remove(stub_file)
   287|         stub_file = os.path.join(autosign_dir, keyid)
   288|         if not os.path.exists(stub_file):
   289|             return False
   290|         os.remove(stub_file)
   291|         return True
   292|     def check_autosign_grains(self, autosign_grains):
   293|         """
   294|         Check for matching grains in the autosign_grains_dir.
   295|         """
   296|         if not autosign_grains or "autosign_grains_dir" not in self.opts:
   297|             return False
   298|         autosign_grains_dir = self.opts["autosign_grains_dir"]
   299|         for root, dirs, filenames in os.walk(autosign_grains_dir):
   300|             for grain in filenames:
   301|                 if grain in autosign_grains:
   302|                     grain_file = os.path.join(autosign_grains_dir, grain)
   303|                     if not self.check_permissions(grain_file):
   304|                         log.warning(
   305|                             "Wrong permissions for %s, ignoring content", grain_file
   306|                         )
   307|                         continue
   308|                     with salt.utils.files.fopen(grain_file, "r") as f:
   309|                         for line in f:
   310|                             line = salt.utils.stringutils.to_unicode(line).strip()
   311|                             if line.startswith("#"):
   312|                                 continue
   313|                             if str(autosign_grains[grain]) == line:
   314|                                 return True
   315|         return False
   316|     def check_autoreject(self, keyid):
   317|         """
   318|         Checks if the specified keyid should automatically be rejected.
   319|         """
   320|         return self.check_signing_file(keyid, self.opts.get("autoreject_file", None))
   321|     def check_autosign(self, keyid, autosign_grains=None):
   322|         """
   323|         Checks if the specified keyid should automatically be signed.
   324|         """
   325|         if self.opts["auto_accept"]:
   326|             return True
   327|         if self.check_signing_file(keyid, self.opts.get("autosign_file", None)):
   328|             return True
   329|         if self.check_autosign_dir(keyid):
   330|             return True
   331|         if self.check_autosign_grains(autosign_grains):
   332|             return True
   333|         return False

# --- HUNK 4: Lines 606-646 ---
   606|         if "loc" in load and load["loc"] < 0:
   607|             log.error("Invalid file pointer: load[loc] < 0")
   608|             return False
   609|         if load.get("size", 0) > file_recv_max_size:
   610|             log.error("Exceeding file_recv_max_size limit: %s", file_recv_max_size)
   611|             return False
   612|         if len(load["data"]) + load.get("loc", 0) > file_recv_max_size:
   613|             log.error("Exceeding file_recv_max_size limit: %s", file_recv_max_size)
   614|             return False
   615|         normpath = load["path"]
   616|         if ":" in normpath:
   617|             normpath = normpath.replace("\\", "/")
   618|             normpath = os.path.normpath(normpath)
   619|         cpath = os.path.join(
   620|             self.opts["cachedir"], "minions", load["id"], "files", normpath
   621|         )
   622|         cdir = os.path.dirname(cpath)
   623|         if not os.path.isdir(cdir):
   624|             try:
   625|                 os.makedirs(cdir)
   626|             except os.error:
   627|                 pass
   628|         if os.path.isfile(cpath) and load["loc"] != 0:
   629|             mode = "ab"
   630|         else:
   631|             mode = "wb"
   632|         with salt.utils.files.fopen(cpath, mode) as fp_:
   633|             if load["loc"]:
   634|                 fp_.seek(load["loc"])
   635|             fp_.write(salt.utils.stringutils.to_str(load["data"]))
   636|         return True
   637|     def _pillar(self, load):
   638|         """
   639|         Return the pillar data for the minion
   640|         """
   641|         if any(key not in load for key in ("id", "grains")):
   642|             return False
   643|         log.debug("Master _pillar using ext: %s", load.get("ext"))
   644|         pillar = salt.pillar.get_pillar(
   645|             self.opts,
   646|             load["grains"],


# ====================================================================
# FILE: salt/engines/docker_events.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-42 ---
     1| """
     2| Send events from Docker events
     3| :Depends:   Docker API >= 1.22
     4| """
     5| import logging
     6| import traceback
     7| import salt.utils.event
     8| import salt.utils.json
     9| try:
    10|     import docker  # pylint: disable=import-error,no-name-in-module
    11|     import docker.utils  # pylint: disable=import-error,no-name-in-module
    12|     HAS_DOCKER_PY = True
    13| except ImportError:
    14|     HAS_DOCKER_PY = False
    15| log = logging.getLogger(__name__)  # pylint: disable=invalid-name
    16| CLIENT_TIMEOUT = 60
    17| __virtualname__ = "docker_events"
    18| __deprecated__ = (
    19|     3009,
    20|     "docker",
    21|     "https://github.com/saltstack/saltext-docker",
    22| )
    23| def __virtual__():
    24|     """
    25|     Only load if docker libs are present
    26|     """
    27|     if not HAS_DOCKER_PY:
    28|         return (False, "Docker_events engine could not be imported")
    29|     return True
    30| def start(
    31|     docker_url="unix://var/run/docker.sock",
    32|     timeout=CLIENT_TIMEOUT,
    33|     tag="salt/engines/docker_events",
    34|     filters=None,
    35| ):
    36|     """
    37|     Scan for Docker events and fire events
    38|     Example Config
    39|     .. code-block:: yaml
    40|         engines:
    41|           - docker_events:
    42|               docker_url: unix://var/run/docker.sock


# ====================================================================
# FILE: salt/engines/ircbot.py
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 28-111 ---
    28| event <tag> [<extra>, <data>]
    29|     fire event on the master or minion event stream with the tag `salt/engines/ircbot/<tag>` and a data object with a
    30|     list of everything else sent in the message
    31| Example of usage
    32| .. code-block:: text
    33|     08:33:57 @gtmanfred > !ping
    34|     08:33:57   gtmanbot > gtmanfred: pong
    35|     08:34:02 @gtmanfred > !echo ping
    36|     08:34:02   gtmanbot > ping
    37|     08:34:17 @gtmanfred > !event test/tag/ircbot irc is useful
    38|     08:34:17   gtmanbot > gtmanfred: TaDa!
    39| .. code-block:: text
    40|     [DEBUG   ] Sending event: tag = salt/engines/ircbot/test/tag/ircbot; data = {'_stamp': '2016-11-28T14:34:16.633623', 'data': ['irc', 'is', 'useful']}
    41| """
    42| import base64
    43| import logging
    44| import re
    45| import socket
    46| import ssl
    47| from collections import namedtuple
    48| import tornado.ioloop
    49| import tornado.iostream
    50| import salt.utils.event
    51| log = logging.getLogger(__name__)
    52| Event = namedtuple("Event", "source code line")
    53| PrivEvent = namedtuple("PrivEvent", "source nick user host code channel command line")
    54| class IRCClient:
    55|     def __init__(
    56|         self,
    57|         nick,
    58|         host,
    59|         port=6667,
    60|         username=None,
    61|         password=None,
    62|         channels=None,
    63|         use_ssl=False,
    64|         use_sasl=False,
    65|         char="!",
    66|         allow_hosts=False,
    67|         allow_nicks=False,
    68|         disable_query=True,
    69|     ):
    70|         self.nick = nick
    71|         self.host = host
    72|         self.port = port
    73|         self.username = username or nick
    74|         self.password = password
    75|         self.channels = channels or []
    76|         self.ssl = use_ssl
    77|         self.sasl = use_sasl
    78|         self.char = char
    79|         self.allow_hosts = allow_hosts
    80|         self.allow_nicks = allow_nicks
    81|         self.disable_query = disable_query
    82|         self.io_loop = tornado.ioloop.IOLoop()
    83|         self._connect()
    84|     def _connect(self):
    85|         _sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
    86|         if self.ssl is True:
    87|             self._stream = tornado.iostream.SSLIOStream(
    88|                 _sock, ssl_options={"cert_reqs": ssl.CERT_NONE}
    89|             )
    90|         else:
    91|             self._stream = tornado.iostream.IOStream(_sock)
    92|         self._stream.set_close_callback(self.on_closed)
    93|         self._stream.connect((self.host, self.port), self.on_connect)
    94|     def read_messages(self):
    95|         self._stream.read_until("\r\n", self._message)
    96|     @staticmethod
    97|     def _event(line):
    98|         log.debug("Received: %s", line)
    99|         search = re.match(
   100|             "^(?:(?P<source>:[^ ]+) )?(?P<code>[^ ]+)(?: (?P<line>.*))?$", line
   101|         )
   102|         source, code, line = (
   103|             search.group("source"),
   104|             search.group("code"),
   105|             search.group("line"),
   106|         )
   107|         return Event(source, code, line)
   108|     def _allow_host(self, host):
   109|         if isinstance(self.allow_hosts, bool):
   110|             return self.allow_hosts
   111|         else:

# --- HUNK 2: Lines 127-226 ---
   127|         search = re.match(
   128|             "^(?P<channel>[^ ]+) :(?:{}(?P<command>[^ ]+)(?: (?P<line>.*))?)?$".format(
   129|                 self.char
   130|             ),
   131|             event.line,
   132|         )
   133|         if search:
   134|             channel, command, line = (
   135|                 search.group("channel"),
   136|                 search.group("command"),
   137|                 search.group("line"),
   138|             )
   139|             if self.disable_query is True and not channel.startswith("#"):
   140|                 return
   141|             if channel == self.nick:
   142|                 channel = nick
   143|             privevent = PrivEvent(
   144|                 event.source, nick, user, host, event.code, channel, command, line
   145|             )
   146|             if (self._allow_nick(nick) or self._allow_host(host)) and hasattr(
   147|                 self, "_command_{}".format(command)
   148|             ):
   149|                 getattr(self, "_command_{}".format(command))(privevent)
   150|     def _command_echo(self, event):
   151|         message = "PRIVMSG {} :{}".format(event.channel, event.line)
   152|         self.send_message(message)
   153|     def _command_ping(self, event):
   154|         message = "PRIVMSG {} :{}: pong".format(event.channel, event.nick)
   155|         self.send_message(message)
   156|     def _command_event(self, event):
   157|         if __opts__.get("__role") == "master":
   158|             fire_master = salt.utils.event.get_master_event(
   159|                 __opts__, __opts__["sock_dir"]
   160|             ).fire_event
   161|         else:
   162|             fire_master = None
   163|         def fire(tag, msg):
   164|             """
   165|             How to fire the event
   166|             """
   167|             if fire_master:
   168|                 fire_master(msg, tag)
   169|             else:
   170|                 __salt__["event.send"](tag, msg)
   171|         args = event.line.split(" ")
   172|         tag = args[0]
   173|         if len(args) > 1:
   174|             payload = {"data": args[1:]}
   175|         else:
   176|             payload = {"data": []}
   177|         fire("salt/engines/ircbot/" + tag, payload)
   178|         message = "PRIVMSG {} :{}: TaDa!".format(event.channel, event.nick)
   179|         self.send_message(message)
   180|     def _message(self, raw):
   181|         raw = raw.rstrip(b"\r\n").decode("utf-8")
   182|         event = self._event(raw)
   183|         if event.code == "PING":
   184|             tornado.ioloop.IOLoop.current().spawn_callback(
   185|                 self.send_message, "PONG {}".format(event.line)
   186|             )
   187|         elif event.code == "PRIVMSG":
   188|             tornado.ioloop.IOLoop.current().spawn_callback(self._privmsg, event)
   189|         self.read_messages()
   190|     def join_channel(self, channel):
   191|         if not channel.startswith("#"):
   192|             channel = "#" + channel
   193|         self.send_message("JOIN {}".format(channel))
   194|     def on_connect(self):
   195|         logging.info("on_connect")
   196|         if self.sasl is True:
   197|             self.send_message("CAP REQ :sasl")
   198|         self.send_message("NICK {}".format(self.nick))
   199|         self.send_message("USER saltstack 0 * :saltstack")
   200|         if self.password:
   201|             if self.sasl is True:
   202|                 authstring = base64.b64encode(
   203|                     "{0}\x00{0}\x00{1}".format(self.username, self.password).encode()
   204|                 )
   205|                 self.send_message("AUTHENTICATE PLAIN")
   206|                 self.send_message("AUTHENTICATE {}".format(authstring))
   207|                 self.send_message("CAP END")
   208|             else:
   209|                 self.send_message(
   210|                     "PRIVMSG NickServ :IDENTIFY {} {}".format(
   211|                         self.username, self.password
   212|                     )
   213|                 )
   214|         for channel in self.channels:
   215|             self.join_channel(channel)
   216|         self.read_messages()
   217|     def on_closed(self):
   218|         logging.info("on_closed")
   219|     def send_message(self, line):
   220|         if isinstance(line, str):
   221|             line = line.encode("utf-8")
   222|         log.debug("Sending:  %s", line)
   223|         self._stream.write(line + b"\r\n")
   224| def start(
   225|     nick,
   226|     host,


# ====================================================================
# FILE: salt/engines/slack.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 642-684 ---
   642|                 if count > 10:
   643|                     log.warning(
   644|                         "Breaking in getting messages because count is exceeded"
   645|                     )
   646|                     break
   647|                 if not msg:
   648|                     count += 1
   649|                     log.warning("Skipping an empty message.")
   650|                     continue  # This one is a dud, get the next message
   651|                 if msg.get("done"):
   652|                     log.trace("msg is done")
   653|                     break
   654|                 if fire_all:
   655|                     log.debug("Firing message to the bus with tag: %s", tag)
   656|                     log.debug("%s %s", tag, msg)
   657|                     self.fire("{}/{}".format(tag, msg["message_data"].get("type")), msg)
   658|                 if control and (len(msg) > 1) and msg.get("cmdline"):
   659|                     channel = self.sc.server.channels.find(msg["channel"])
   660|                     jid = self.run_command_async(msg)
   661|                     log.debug("Submitted a job and got jid: %s", jid)
   662|                     outstanding[
   663|                         jid
   664|                     ] = msg  # record so we can return messages to the caller
   665|                     channel.send_message(
   666|                         "@{}'s job is submitted as salt jid {}".format(
   667|                             msg["user_name"], jid
   668|                         )
   669|                     )
   670|                 count += 1
   671|             start_time = time.time()
   672|             job_status = self.get_jobs_from_runner(
   673|                 outstanding.keys()
   674|             )  # dict of job_ids:results are returned
   675|             log.trace(
   676|                 "Getting %s jobs status took %s seconds",
   677|                 len(job_status),
   678|                 time.time() - start_time,
   679|             )
   680|             for jid in job_status:
   681|                 result = job_status[jid]["data"]
   682|                 function = job_status[jid]["function"]
   683|                 if result:
   684|                     log.debug("ret to send back is %s", result)

# --- HUNK 2: Lines 746-783 ---
   746|                     cmd,
   747|                     arg=args,
   748|                     kwarg=kwargs,
   749|                     tgt_type=str(tgt_type),
   750|                 )
   751|             log.info("ret from local.cmd_async is %s", job_id)
   752|         return job_id
   753| def start(
   754|     token,
   755|     control=False,
   756|     trigger="!",
   757|     groups=None,
   758|     groups_pillar_name=None,
   759|     fire_all=False,
   760|     tag="salt/engines/slack",
   761| ):
   762|     """
   763|     Listen to slack events and forward them to salt, new version
   764|     """
   765|     salt.utils.versions.warn_until(
   766|         3008,
   767|         "This 'slack' engine will be deprecated and "
   768|         "will be replace by the slack_bolt engine. This new "
   769|         "engine will use the new Bolt library from Slack and requires "
   770|         "a Slack app and a Slack bot account.",
   771|     )
   772|     if (not token) or (not token.startswith("xoxb")):
   773|         time.sleep(2)  # don't respawn too quickly
   774|         log.error("Slack bot token not found, bailing...")
   775|         raise UserWarning("Slack Engine bot token not configured")
   776|     try:
   777|         client = SlackClient(token=token)
   778|         message_generator = client.generate_triggered_messages(
   779|             token, trigger, groups, groups_pillar_name
   780|         )
   781|         client.run_commands_from_slack_async(message_generator, fire_all, tag, control)
   782|     except Exception:  # pylint: disable=broad-except
   783|         raise Exception(f"{traceback.format_exc()}")


# ====================================================================
# FILE: salt/engines/webhook.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| """
     2| Send events from webhook api
     3| """
     4| import tornado.httpserver
     5| import tornado.ioloop
     6| import tornado.web
     7| import salt.utils.event
     8| def start(address=None, port=5000, ssl_crt=None, ssl_key=None):
     9|     """
    10|     Api to listen for webhooks to send to the reactor.
    11|     Implement the webhook behavior in an engine.
    12|     :py:class:`rest_cherrypy Webhook docs <salt.netapi.rest_cherrypy.app.Webhook>`
    13|     Unlike the rest_cherrypy Webhook, this is only an unauthenticated webhook
    14|     endpoint.  If an authenticated webhook endpoint is needed, use the salt-api
    15|     webhook which runs on the master and authenticates through eauth.
    16|     .. note: This is really meant to be used on the minion, because salt-api
    17|              needs to be run on the master for use with eauth.
    18|     .. warning:: Unauthenticated endpoint
    19|         This engine sends webhook calls to the event stream.  If the engine is
    20|         running on a minion with `file_client: local` the event is sent to the
    21|         minion event stream.  Otherwise it is sent to the master event stream.
    22|     Example Config
    23|     .. code-block:: yaml
    24|         engines:
    25|           - webhook: {}
    26|     .. code-block:: yaml

# --- HUNK 2: Lines 30-66 ---
    30|               address: 10.128.1.145
    31|               ssl_crt: /etc/pki/tls/certs/localhost.crt
    32|               ssl_key: /etc/pki/tls/certs/localhost.key
    33|     .. note: For making an unsigned key, use the following command
    34|              `salt-call --local tls.create_self_signed_cert`
    35|     """
    36|     if __opts__.get("__role") == "master":
    37|         fire_master = salt.utils.event.get_master_event(
    38|             __opts__, __opts__["sock_dir"]
    39|         ).fire_event
    40|     else:
    41|         fire_master = None
    42|     def fire(tag, msg):
    43|         """
    44|         How to fire the event
    45|         """
    46|         if fire_master:
    47|             fire_master(msg, tag)
    48|         else:
    49|             __salt__["event.send"](tag, msg)
    50|     class WebHook(tornado.web.RequestHandler):  # pylint: disable=abstract-method
    51|         def post(self, tag):  # pylint: disable=arguments-differ
    52|             body = self.request.body
    53|             headers = self.request.headers
    54|             payload = {
    55|                 "headers": headers if isinstance(headers, dict) else dict(headers),
    56|                 "body": body,
    57|             }
    58|             fire("salt/engines/hook/" + tag, payload)
    59|     application = tornado.web.Application([(r"/(.*)", WebHook)])
    60|     ssl_options = None
    61|     if all([ssl_crt, ssl_key]):
    62|         ssl_options = {"certfile": ssl_crt, "keyfile": ssl_key}
    63|     io_loop = tornado.ioloop.IOLoop()
    64|     http_server = tornado.httpserver.HTTPServer(application, ssl_options=ssl_options)
    65|     http_server.listen(port, address=address)
    66|     io_loop.start()


# ====================================================================
# FILE: salt/executors/docker.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-36 ---
     1| """
     2| Docker executor module
     3| .. versionadded:: 2019.2.0
     4| Used with the docker proxy minion.
     5| """
     6| __virtualname__ = "docker"
     7| DOCKER_MOD_MAP = {
     8|     "state.sls": "docker.sls",
     9|     "state.apply": "docker.apply",
    10|     "state.highstate": "docker.highstate",
    11| }
    12| __deprecated__ = (
    13|     3009,
    14|     "docker",
    15|     "https://github.com/saltstack/saltext-docker",
    16| )
    17| def __virtual__():
    18|     if "proxy" not in __opts__:
    19|         return (
    20|             False,
    21|             "Docker executor is only meant to be used with Docker Proxy Minions",
    22|         )
    23|     if __opts__.get("proxy", {}).get("proxytype") != __virtualname__:
    24|         return False, f"Proxytype does not match: {__virtualname__}"
    25|     return True
    26| def execute(opts, data, func, args, kwargs):
    27|     """
    28|     Directly calls the given function with arguments
    29|     """
    30|     if data["fun"] == "saltutil.find_job":
    31|         return __executors__["direct_call.execute"](opts, data, func, args, kwargs)
    32|     if data["fun"] in DOCKER_MOD_MAP:
    33|         return __executors__["direct_call.execute"](
    34|             opts,
    35|             data,
    36|             __salt__[DOCKER_MOD_MAP[data["fun"]]],

