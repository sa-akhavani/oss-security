--- a/clients/admin-ui/src/features/system/SystemInformationForm.tsx
+++ b/clients/admin-ui/src/features/system/SystemInformationForm.tsx
@@ -402,21 +402,21 @@
                   label="This system refreshes cookies"
                   tooltip="Does this system automatically refresh cookies?"
                 />
                 <DictSuggestionSwitch
                   name="uses_non_cookie_access"
                   label="This system uses non-cookie trackers"
                   tooltip="Does this system use other types of trackers?"
                 />
                 <DictSuggestionNumberInput
                   name="cookie_max_age_seconds"
-                  label="Maximum duration"
+                  label="Maximum duration (seconds)"
                   tooltip="What is the maximum amount of time a cookie will live?"
                 />
               </SystemFormInputGroup>
               <SystemFormInputGroup heading="Administrative properties">
                 <CustomTextInput
                   label="Data stewards"
                   name="data_stewards"
                   tooltip="Who are the stewards assigned to the system?"
                   variant="stacked"
                   disabled

--- a/clients/admin-ui/src/types/api/index.ts
+++ b/clients/admin-ui/src/types/api/index.ts
@@ -114,20 +114,21 @@
 export type { DrpDataRightsResponse } from "./models/DrpDataRightsResponse";
 export type { DrpMeta } from "./models/DrpMeta";
 export type { DrpPrivacyRequestCreate } from "./models/DrpPrivacyRequestCreate";
 export { DrpRegime } from "./models/DrpRegime";
 export type { DrpRevokeRequest } from "./models/DrpRevokeRequest";
 export type { DryRunDatasetResponse } from "./models/DryRunDatasetResponse";
 export type { DynamoDBDocsSchema } from "./models/DynamoDBDocsSchema";
 export { EdgeDirection } from "./models/EdgeDirection";
 export type { EmailDocsSchema } from "./models/EmailDocsSchema";
 export type { EmbeddedLineItem } from "./models/EmbeddedLineItem";
+export type { EmbeddedPurpose } from "./models/EmbeddedPurpose";
 export type { EmbeddedVendor } from "./models/EmbeddedVendor";
 export type { Endpoint } from "./models/Endpoint";
 export { EnforcementLevel } from "./models/EnforcementLevel";
 export type { Evaluation } from "./models/Evaluation";
 export type { ExecutionAndAuditLogResponse } from "./models/ExecutionAndAuditLogResponse";
 export type { ExecutionApplicationConfig } from "./models/ExecutionApplicationConfig";
 export type { ExecutionLogDetailResponse } from "./models/ExecutionLogDetailResponse";
 export { ExecutionLogStatus } from "./models/ExecutionLogStatus";
 export type { ExperienceConfigCreate } from "./models/ExperienceConfigCreate";
 export type { ExperienceConfigCreateOrUpdateResponse } from "./models/ExperienceConfigCreateOrUpdateResponse";

--- a/clients/admin-ui/src/types/api/models/PrivacyPreferencesRequest.ts
+++ b/clients/admin-ui/src/types/api/models/PrivacyPreferencesRequest.ts
@@ -19,23 +19,23 @@
  */
 export type PrivacyPreferencesRequest = {
   purpose_consent_preferences?: Array<TCFPurposeSave>;
   purpose_legitimate_interests_preferences?: Array<TCFPurposeSave>;
   vendor_consent_preferences?: Array<TCFVendorSave>;
   vendor_legitimate_interests_preferences?: Array<TCFVendorSave>;
   special_feature_preferences?: Array<TCFSpecialFeatureSave>;
   browser_identity: Identity;
   code?: string;
   /**
-   * If supplied, TC string is decoded and preferences saved for purpose_consent, purpose_legitimate_interests, vendor_consent, vendor_legitimate_interests, and special_features
+   * If supplied, TC strings and AC strings are decoded and preferences saved for purpose_consent, purpose_legitimate_interests, vendor_consent, vendor_legitimate_interests, and special_features
    */
-  tc_string?: string;
+  fides_string?: string;
   preferences?: Array<ConsentOptionCreate>;
   special_purpose_preferences?: Array<TCFSpecialPurposeSave>;
   feature_preferences?: Array<TCFFeatureSave>;
   system_consent_preferences?: Array<TCFVendorSave>;
   system_legitimate_interests_preferences?: Array<TCFVendorSave>;
   policy_key?: string;
   privacy_experience_id?: string;
   user_geography?: string;
   method?: ConsentMethod;
 };

--- a/clients/admin-ui/src/types/api/models/SavePrivacyPreferencesResponse.ts
+++ b/clients/admin-ui/src/types/api/models/SavePrivacyPreferencesResponse.ts
@@ -10,12 +10,12 @@
   preferences?: Array<CurrentPrivacyPreferenceSchema>;
   purpose_consent_preferences?: Array<CurrentPrivacyPreferenceSchema>;
   purpose_legitimate_interests_preferences?: Array<CurrentPrivacyPreferenceSchema>;
   special_purpose_preferences?: Array<CurrentPrivacyPreferenceSchema>;
   vendor_consent_preferences?: Array<CurrentPrivacyPreferenceSchema>;
   vendor_legitimate_interests_preferences?: Array<CurrentPrivacyPreferenceSchema>;
   feature_preferences?: Array<CurrentPrivacyPreferenceSchema>;
   special_feature_preferences?: Array<CurrentPrivacyPreferenceSchema>;
   system_consent_preferences?: Array<CurrentPrivacyPreferenceSchema>;
   system_legitimate_interests_preferences?: Array<CurrentPrivacyPreferenceSchema>;
-  tc_mobile_data?: TCMobileData;
+  fides_mobile_data?: TCMobileData;
 };

--- a/clients/admin-ui/src/types/api/models/TCDecode.ts
+++ b/clients/admin-ui/src/types/api/models/TCDecode.ts
@@ -1,10 +1,10 @@
 /* istanbul ignore file */
 /* tslint:disable */
 /* eslint-disable */
 import type { TCMobileData } from "./TCMobileData";
 /**
  * Decode response schema for returning TC Mobile Data
  */
 export type TCDecode = {
-  tc_mobile_data: TCMobileData;
+  fides_mobile_data: TCMobileData;
 };

--- a/clients/admin-ui/src/types/api/models/TCFVendorConsentRecord.ts
+++ b/clients/admin-ui/src/types/api/models/TCFVendorConsentRecord.ts
@@ -1,25 +1,20 @@
 /* istanbul ignore file */
 /* tslint:disable */
 /* eslint-disable */
-import type { EmbeddedLineItem } from "./EmbeddedLineItem";
+import type { EmbeddedPurpose } from "./EmbeddedPurpose";
 import type { UserConsentPreference } from "./UserConsentPreference";
 /**
  * Schema for a TCF Vendor with Consent legal basis
  */
 export type TCFVendorConsentRecord = {
   id: string;
   has_vendor_id?: boolean;
   name?: string;
   description?: string;
-  cookie_max_age_seconds?: number;
-  uses_cookies?: boolean;
-  cookie_refresh?: boolean;
-  uses_non_cookie_access?: boolean;
-  legitimate_interest_disclosure_url?: string;
   default_preference?: UserConsentPreference;
   current_preference?: UserConsentPreference;
   outdated_preference?: UserConsentPreference;
   current_served?: boolean;
   outdated_served?: boolean;
-  purpose_consents?: Array<EmbeddedLineItem>;
+  purpose_consents?: Array<EmbeddedPurpose>;
 };

--- a/clients/admin-ui/src/types/api/models/TCFVendorLegitimateInterestsRecord.ts
+++ b/clients/admin-ui/src/types/api/models/TCFVendorLegitimateInterestsRecord.ts
@@ -1,25 +1,20 @@
 /* istanbul ignore file */
 /* tslint:disable */
 /* eslint-disable */
-import type { EmbeddedLineItem } from "./EmbeddedLineItem";
+import type { EmbeddedPurpose } from "./EmbeddedPurpose";
 import type { UserConsentPreference } from "./UserConsentPreference";
 /**
  * Schema for a TCF Vendor with Legitimate interests legal basis
  */
 export type TCFVendorLegitimateInterestsRecord = {
   id: string;
   has_vendor_id?: boolean;
   name?: string;
   description?: string;
-  cookie_max_age_seconds?: number;
-  uses_cookies?: boolean;
-  cookie_refresh?: boolean;
-  uses_non_cookie_access?: boolean;
-  legitimate_interest_disclosure_url?: string;
   default_preference?: UserConsentPreference;
   current_preference?: UserConsentPreference;
   outdated_preference?: UserConsentPreference;
   current_served?: boolean;
   outdated_served?: boolean;
-  purpose_legitimate_interests?: Array<EmbeddedLineItem>;
+  purpose_legitimate_interests?: Array<EmbeddedPurpose>;
 };

--- a/clients/admin-ui/src/types/api/models/TCFVendorRelationships.ts
+++ b/clients/admin-ui/src/types/api/models/TCFVendorRelationships.ts
@@ -1,21 +1,23 @@
 /* istanbul ignore file */
 /* tslint:disable */
 /* eslint-disable */
 import type { EmbeddedLineItem } from "./EmbeddedLineItem";
+import type { EmbeddedPurpose } from "./EmbeddedPurpose";
 /**
  * Collects the other relationships for a given vendor - no preferences are saved here
  */
 export type TCFVendorRelationships = {
   id: string;
   has_vendor_id?: boolean;
   name?: string;
   description?: string;
+  special_purposes?: Array<EmbeddedPurpose>;
+  features?: Array<EmbeddedLineItem>;
+  special_features?: Array<EmbeddedLineItem>;
   cookie_max_age_seconds?: number;
   uses_cookies?: boolean;
   cookie_refresh?: boolean;
   uses_non_cookie_access?: boolean;
   legitimate_interest_disclosure_url?: string;
-  special_purposes?: Array<EmbeddedLineItem>;
-  features?: Array<EmbeddedLineItem>;
-  special_features?: Array<EmbeddedLineItem>;
+  privacy_policy_url?: string;
 };

--- a/clients/admin-ui/src/types/dictionary-api/models/Cookie.ts
+++ b/clients/admin-ui/src/types/dictionary-api/models/Cookie.ts
@@ -1,16 +1,16 @@
 /* istanbul ignore file */
 /* tslint:disable */
 /* eslint-disable */
 import type { CookieType } from "./CookieType";
 /**
- * The Cookies resource model
+ * A Compass cookie record, extending a fideslang `Cookie`
  */
 export type Cookie = {
   name: string;
   path?: string;
   domain?: string;
   type: CookieType;
   /**
    * Whether the cookie is refreshed after being initially set.
    */
   cookie_refresh?: boolean;
@@ -43,11 +43,15 @@
    */
   vendor_id: string;
   /**
    * The name of the vendor that the record belongs to
    */
   vendor_name: string;
   /**
    * The version of GVL from which the record is derived
    */
   gvl_version?: string;
+  /**
+   * A unique identifier for a Cookie record to be used in the Compass data store. Combines other fields that form uniqueness criteria for a Cookie record.
+   */
+  unique_id?: string;
 };

--- a/clients/admin-ui/src/types/dictionary-api/models/DataUseDeclaration.ts
+++ b/clients/admin-ui/src/types/dictionary-api/models/DataUseDeclaration.ts
@@ -1,21 +1,18 @@
 /* istanbul ignore file */
 /* tslint:disable */
 /* eslint-disable */
 import type { Cookie } from "./Cookie";
 import type { LegalBasisForProcessingEnum } from "./LegalBasisForProcessingEnum";
 import type { SpecialCategoryLegalBasisEnum } from "./SpecialCategoryLegalBasisEnum";
 /**
- * The PrivacyDeclaration resource model.
- *
- * States a function of a system, and describes how it relates
- * to the privacy data types.
+ * A Compass data use declaration record, extending a fideslang `PrivacyDeclaration`
  */
 export type DataUseDeclaration = {
   /**
    * The name of the privacy declaration on the system.
    */
   name?: string;
   /**
    * An array of data categories describing a system in a privacy declaration.
    */
   data_categories: Array<string>;

--- a/clients/admin-ui/src/types/dictionary-api/models/Vendor.ts
+++ b/clients/admin-ui/src/types/dictionary-api/models/Vendor.ts
@@ -3,23 +3,21 @@
 /* eslint-disable */
 import type { ContactDetails } from "./ContactDetails";
 import type { Cookie } from "./Cookie";
 import type { DataFlow } from "./DataFlow";
 import type { DataProtectionImpactAssessment } from "./DataProtectionImpactAssessment";
 import type { DataResponsibilityTitle } from "./DataResponsibilityTitle";
 import type { LegalBasisForProfilingEnum } from "./LegalBasisForProfilingEnum";
 import type { PrivacyDeclaration } from "./PrivacyDeclaration";
 import type { SystemMetadata } from "./SystemMetadata";
 /**
- * The System resource model.
- *
- * Describes an application and includes a list of PrivacyDeclaration resources.
+ * A Compass vendor record, extending a fideslang `System`
  */
 export type Vendor = {
   fides_key?: string;
   /**
    * Defines the Organization that this resource belongs to.
    */
   organization_fides_key?: string;
   tags?: Array<string>;
   name?: string;
   /**

--- a/clients/fides-js/src/components/tcf/TcfOverlay.tsx
+++ b/clients/fides-js/src/components/tcf/TcfOverlay.tsx
@@ -26,29 +26,30 @@
   TCFVendorConsentRecord,
   TCFVendorLegitimateInterestsRecord,
   TcfModels,
 } from "../../lib/tcf/types";
 import { updateConsentPreferences } from "../../lib/preferences";
 import {
   ButtonType,
   ConsentMethod,
   PrivacyExperience,
 } from "../../lib/consent-types";
-import { generateTcString } from "../../lib/tcf";
+import { generateFidesString } from "../../lib/tcf";
 import {
   FidesCookie,
   transformTcfPreferencesToCookieKeys,
 } from "../../lib/cookie";
 import InitialLayer from "./InitialLayer";
 import TcfTabs from "./TcfTabs";
 import Button from "../Button";
 import VendorInfoBanner from "./VendorInfoBanner";
+import { dispatchFidesEvent } from "../../lib/events";
 const resolveConsentValueFromTcfModel = (
   model:
     | TCFPurposeConsentRecord
     | TCFPurposeLegitimateInterestsRecord
     | TCFFeatureRecord
     | TCFVendorConsentRecord
     | TCFVendorLegitimateInterestsRecord
 ) => {
   if (model.current_preference) {
     return transformUserPreferenceToBoolean(model.current_preference);
@@ -164,27 +165,27 @@
    * sent to the backend, and `enabledIds` is what the FE uses. They have diverged
    * because the backend has not implemented separate vendor legint/consents yet.
    * Therefore, we need both entities right now, but eventually we should be able to
    * only use one. In other words, `enabledIds` has a field for `vendorsConsent` and
    * `vendorsLegint` but `tcf` only has `vendors`.
    */
   tcf: TcfSavePreferences,
   enabledIds: EnabledIds,
   experience: PrivacyExperience
 ): Promise<FidesCookie> => {
-  const tcString = await generateTcString({
+  const tcString = await generateFidesString({
     tcStringPreferences: enabledIds,
     experience,
   });
   return {
     ...oldCookie,
-    fides_tc_string: tcString,
+    fides_string: tcString,
     tcf_consent: transformTcfPreferencesToCookieKeys(tcf),
   };
 };
 const TcfOverlay: FunctionComponent<OverlayProps> = ({
   fidesRegionString,
   experience,
   options,
   cookie,
 }) => {
   const initialEnabledIds: EnabledIds = useMemo(() => {
@@ -212,26 +213,25 @@
   const [draftIds, setDraftIds] = useState<EnabledIds>(initialEnabledIds);
   const showBanner = useMemo(
     () => experience.show_banner && hasActionNeededNotices(experience),
     [experience]
   );
   const handleUpdateAllPreferences = useCallback(
     (enabledIds: EnabledIds) => {
       const tcf = createTcfSavePayload({ experience, enabledIds });
       updateConsentPreferences({
         consentPreferencesToSave: [],
-        experienceId: experience.id,
-        fidesApiUrl: options.fidesApiUrl,
+        experience,
         consentMethod: ConsentMethod.button,
+        options,
         userLocationString: fidesRegionString,
         cookie,
-        debug: options.debug,
         servedNotices: null, // TODO: served notices
         tcf,
         updateCookie: (oldCookie) =>
           updateCookie(oldCookie, tcf, enabledIds, experience),
       });
       setDraftIds(enabledIds);
     },
     [cookie, experience, fidesRegionString, options]
   );
   const [activeTabIndex, setActiveTabIndex] = useState(0);
@@ -285,21 +285,24 @@
       renderModalContent={({ onClose }) => {
         const onSave = (keys: EnabledIds) => {
           handleUpdateAllPreferences(keys);
           onClose();
         };
         return (
           <Fragment>
             <TcfTabs
               experience={experience}
               enabledIds={draftIds}
-              onChange={setDraftIds}
+              onChange={(updatedIds) => {
+                setDraftIds(updatedIds);
+                dispatchFidesEvent("FidesUIChanged", cookie, options.debug);
+              }}
               activeTabIndex={activeTabIndex}
               onTabChange={setActiveTabIndex}
             />
             <div className="fides-modal-footer">
               <TcfConsentButtons
                 experience={experience}
                 onSave={onSave}
                 firstButton={
                   <Button
                     buttonType={ButtonType.SECONDARY}

--- a/clients/fides-js/src/components/tcf/TcfVendors.tsx
+++ b/clients/fides-js/src/components/tcf/TcfVendors.tsx
@@ -1,123 +1,87 @@
 import { VNode, h } from "preact";
 import { useMemo, useState } from "preact/hooks";
 import { Vendor } from "@iabtechlabtcf/core";
 import {
-  GvlDataRetention,
-  EmbeddedLineItem,
   GvlDataCategories,
-  GvlVendorUrl,
   GvlDataDeclarations,
   VendorRecord,
+  EmbeddedPurpose,
 } from "../../lib/tcf/types";
 import { PrivacyExperience } from "../../lib/consent-types";
 import { UpdateEnabledIds } from "./TcfOverlay";
 import FilterButtons from "./FilterButtons";
 import {
   transformExperienceToVendorRecords,
   vendorGvlEntry,
 } from "../../lib/tcf/vendors";
 import ExternalLink from "../ExternalLink";
 import DoubleToggleTable from "./DoubleToggleTable";
 const FILTERS = [{ name: "All vendors" }, { name: "IAB TCF vendors" }];
-interface Retention {
-  mapping: Record<number, number>;
-  default: number;
-}
 const VendorDetails = ({
   label,
   lineItems,
-  dataRetention,
 }: {
   label: string;
-  lineItems: EmbeddedLineItem[] | undefined;
-  dataRetention?: Retention;
+  lineItems: EmbeddedPurpose[] | undefined;
 }) => {
   if (!lineItems || lineItems.length === 0) {
     return null;
   }
+  const hasRetentionInfo = lineItems.some((li) => li.retention_period != null);
   return (
     <table className="fides-vendor-details-table">
       <thead>
         <tr>
           <th width="80%">{label}</th>
-          {dataRetention ? (
+          {hasRetentionInfo ? (
             <th width="20%" style={{ textAlign: "right" }}>
               Retention
             </th>
           ) : null}
         </tr>
       </thead>
       <tbody>
-        {lineItems.map((item) => {
-          let retention: string | number = "N/A";
-          if (dataRetention) {
-            retention = dataRetention.mapping[item.id] ?? dataRetention.default;
-          }
-          return (
-            <tr key={item.id}>
-              <td>{item.name}</td>
-              {dataRetention ? (
-                <td style={{ textAlign: "right" }}>
-                  {retention == null ? "N/A" : `${retention} day(s)`}
-                </td>
-              ) : null}
-            </tr>
-          );
-        })}
+        {lineItems.map((item) => (
+          <tr key={item.id}>
+            <td>{item.name}</td>
+            {hasRetentionInfo ? (
+              <td style={{ textAlign: "right" }}>
+                {item.retention_period
+                  ? `${item.retention_period} day(s)`
+                  : "N/A"}
+              </td>
+            ) : null}
+          </tr>
+        ))}
       </tbody>
     </table>
   );
 };
 const PurposeVendorDetails = ({
   purposes,
   specialPurposes,
-  gvlVendor,
-}: {
-  purposes: EmbeddedLineItem[] | undefined;
-  specialPurposes: EmbeddedLineItem[] | undefined;
-  gvlVendor: Vendor | undefined;
+}: {
+  purposes: EmbeddedPurpose[] | undefined;
+  specialPurposes: EmbeddedPurpose[] | undefined;
 }) => {
   const emptyPurposes = purposes ? purposes.length === 0 : true;
   const emptySpecialPurposes = specialPurposes
     ? specialPurposes.length === 0
     : true;
   if (emptyPurposes && emptySpecialPurposes) {
     return null;
   }
-  const dataRetention: GvlDataRetention | undefined = gvlVendor?.dataRetention;
   return (
     <div>
-      <VendorDetails
-        label="Purposes"
-        lineItems={purposes as EmbeddedLineItem[]}
-        dataRetention={
-          dataRetention
-            ? {
-                mapping: dataRetention.purposes,
-                default: dataRetention.stdRetention,
-              }
-            : undefined
-        }
-      />
-      <VendorDetails
-        label="Special purposes"
-        lineItems={specialPurposes as EmbeddedLineItem[]}
-        dataRetention={
-          dataRetention
-            ? {
-                mapping: dataRetention.specialPurposes,
-                default: dataRetention.stdRetention,
-              }
-            : undefined
-        }
-      />
+      <VendorDetails label="Purposes" lineItems={purposes} />
+      <VendorDetails label="Special purposes" lineItems={specialPurposes} />
     </div>
   );
 };
 const DataCategories = ({
   gvlVendor,
   dataCategories,
 }: {
   gvlVendor: Vendor | undefined;
   dataCategories: GvlDataCategories | undefined;
 }) => {
@@ -138,40 +102,45 @@
           return (
             <tr key={id}>
               <td>{category.name}</td>
             </tr>
           );
         })}
       </tbody>
     </table>
   );
 };
-const StorageDisclosure = ({ vendor }: { vendor: Vendor }) => {
+const StorageDisclosure = ({ vendor }: { vendor: VendorRecord }) => {
   const {
     name,
-    usesCookies,
-    usesNonCookieAccess,
-    cookieMaxAgeSeconds,
-    cookieRefresh,
+    uses_cookies: usesCookies,
+    uses_non_cookie_access: usesNonCookieAccess,
+    cookie_max_age_seconds: cookieMaxAgeSeconds,
+    cookie_refresh: cookieRefresh,
   } = vendor;
   let disclosure = "";
   if (usesCookies) {
     const days = cookieMaxAgeSeconds
       ? Math.ceil(cookieMaxAgeSeconds / 60 / 60 / 24)
       : 0;
     disclosure = `${name} stores cookies with a maximum duration of about ${days} Day(s).`;
-  }
-  if (cookieRefresh) {
-    disclosure = `${disclosure} These cookies may be refreshed.`;
-  }
-  if (usesNonCookieAccess) {
-    disclosure = `${disclosure} This vendor also uses other methods like "local storage" to store and access information on your device.`;
+    if (cookieRefresh) {
+      disclosure = `${disclosure} These cookies may be refreshed.`;
+    }
+    if (usesNonCookieAccess) {
+      disclosure = `${disclosure} This vendor also uses other methods like "local storage" to store and access information on your device.`;
+    }
+  } else if (usesNonCookieAccess) {
+    disclosure = `${name} uses methods like "local storage" to store and access information on your device.`;
+  }
+  if (disclosure === "") {
+    return null;
   }
   return <p>{disclosure}</p>;
 };
 const TcfVendors = ({
   experience,
   enabledVendorConsentIds,
   enabledVendorLegintIds,
   onChange,
   allOnOffButtons,
 }: {
@@ -209,45 +178,50 @@
         enabledConsentIds={enabledVendorConsentIds}
         enabledLegintIds={enabledVendorLegintIds}
         onToggle={onChange}
         consentModelType="vendorsConsent"
         legintModelType="vendorsLegint"
         renderBadgeLabel={(vendor) =>
           vendorGvlEntry(vendor.id, experience.gvl) ? "IAB TCF" : undefined
         }
         renderToggleChild={(vendor) => {
           const gvlVendor = vendorGvlEntry(vendor.id, experience.gvl);
-          const url: GvlVendorUrl | undefined = gvlVendor?.urls.find(
-            (u: GvlVendorUrl) => u.langId === "en"
-          );
           const dataCategories: GvlDataCategories | undefined =
             experience.gvl?.dataCategories;
+          const hasUrls =
+            vendor.privacy_policy_url ||
+            vendor.legitimate_interest_disclosure_url;
           return (
             <div>
-              {gvlVendor ? <StorageDisclosure vendor={gvlVendor} /> : null}
-              <div style={{ marginBottom: "1.1em" }}>
-                {url?.privacy ? (
-                  <ExternalLink href={url.privacy}>Privacy policy</ExternalLink>
-                ) : null}
-                {url?.legIntClaim ? (
-                  <ExternalLink href={url.legIntClaim}>
-                    Legitimate interest disclosure
-                  </ExternalLink>
-                ) : null}
-              </div>
+              <StorageDisclosure vendor={vendor} />
+              {hasUrls ? (
+                <div style={{ marginBottom: "1.1em" }}>
+                  {vendor.privacy_policy_url ? (
+                    <ExternalLink href={vendor.privacy_policy_url}>
+                      Privacy policy
+                    </ExternalLink>
+                  ) : null}
+                  {vendor.legitimate_interest_disclosure_url ? (
+                    <ExternalLink
+                      href={vendor.legitimate_interest_disclosure_url}
+                    >
+                      Legitimate interest disclosure
+                    </ExternalLink>
+                  ) : null}
+                </div>
+              ) : null}
               <PurposeVendorDetails
                 purposes={[
                   ...(vendor.purpose_consents || []),
                   ...(vendor.purpose_legitimate_interests || []),
                 ]}
                 specialPurposes={vendor.special_purposes}
-                gvlVendor={gvlVendor}
               />
               <VendorDetails label="Features" lineItems={vendor.features} />
               <VendorDetails
                 label="Special features"
                 lineItems={vendor.special_features}
               />
               <DataCategories
                 gvlVendor={gvlVendor}
                 dataCategories={dataCategories}
               />

--- a/clients/fides-js/src/fides-tcf.ts
+++ b/clients/fides-js/src/fides-tcf.ts
@@ -42,70 +42,168 @@
  *   // Query user consent preferences
  *   if (window.Fides.consent.data_sales) {
  *     // ...enable advertising scripts
  *   }
  * ```
  */
 import type { TCData } from "@iabtechlabtcf/cmpapi";
 import { gtm } from "./integrations/gtm";
 import { meta } from "./integrations/meta";
 import { shopify } from "./integrations/shopify";
-import { FidesConfig, PrivacyExperience } from "./lib/consent-types";
-import { initializeCmpApi } from "./lib/tcf";
+import {
+  FidesConfig,
+  FidesOptionOverrides,
+  OverrideOptions,
+  PrivacyExperience,
+  UserConsentPreference,
+} from "./lib/consent-types";
+import { generateFidesString, initializeCmpApi } from "./lib/tcf";
 import {
   getInitialCookie,
   getInitialFides,
+  getOverrideFidesOptions,
   initialize,
 } from "./lib/initialize";
 import type { Fides } from "./lib/initialize";
 import { dispatchFidesEvent } from "./lib/events";
-import { FidesCookie, hasSavedTcfPreferences, isNewFidesCookie } from "./fides";
+import {
+  debugLog,
+  experienceIsValid,
+  FidesCookie,
+  hasSavedTcfPreferences,
+  isNewFidesCookie,
+  isPrivacyExperience,
+  tcfConsentCookieObjHasSomeConsentSet,
+  transformTcfPreferencesToCookieKeys,
+  transformUserPreferenceToBoolean,
+} from "./fides";
 import { renderOverlay } from "./lib/tcf/renderOverlay";
+import {
+  EnabledIds,
+  TcfModelsRecord,
+  TcfSavePreferences,
+} from "./lib/tcf/types";
+import { TCF_KEY_MAP } from "./lib/tcf/constants";
+import {
+  generateFidesStringFromCookieTcfConsent,
+  transformFidesStringToCookieKeys,
+} from "./lib/tcf/utils";
 declare global {
   interface Window {
     Fides: Fides;
     __tcfapiLocator?: Window;
     __tcfapi?: (
       command: string,
       version: number,
       callback: (tcData: TCData, success: boolean) => void,
       parameter?: number | string
     ) => void;
+    config: {
+      tc_info: OverrideOptions;
+    };
   }
 }
 let _Fides: Fides;
+/** Helper function to determine the initial value of a TCF object */
+const getInitialPreference = (
+  tcfObject: TcfModelsRecord
+): UserConsentPreference => {
+  if (tcfObject.current_preference) {
+    return tcfObject.current_preference;
+  }
+  return tcfObject.default_preference ?? UserConsentPreference.OPT_OUT;
+};
 const updateCookie = async (
   oldCookie: FidesCookie,
   experience: PrivacyExperience
 ): Promise<FidesCookie> => {
   if (!hasSavedTcfPreferences(experience)) {
-    return { ...oldCookie, fides_tc_string: "" };
-  }
-  return oldCookie;
+    return { ...oldCookie, fides_string: "" };
+  }
+  const tcSavePrefs: TcfSavePreferences = {};
+  const enabledIds: EnabledIds = {
+    purposesConsent: [],
+    purposesLegint: [],
+    specialPurposes: [],
+    features: [],
+    specialFeatures: [],
+    vendorsConsent: [],
+    vendorsLegint: [],
+  };
+  TCF_KEY_MAP.forEach(({ experienceKey, cookieKey, enabledIdsKey }) => {
+    tcSavePrefs[cookieKey] = [];
+    experience[experienceKey]?.forEach((record) => {
+      const pref: UserConsentPreference = getInitialPreference(record);
+      tcSavePrefs[cookieKey]?.push({
+        id: record.id,
+        preference: pref,
+      });
+      if (transformUserPreferenceToBoolean(pref)) {
+        if (enabledIdsKey) {
+          enabledIds[enabledIdsKey].push(record.id.toString());
+        }
+      }
+    });
+  });
+  const fidesString = await generateFidesString({
+    experience,
+    tcStringPreferences: enabledIds,
+  });
+  const tcfConsent = transformTcfPreferencesToCookieKeys(tcSavePrefs);
+  return { ...oldCookie, fides_string: fidesString, tcf_consent: tcfConsent };
 };
 /**
  * Initialize the global Fides object with the given configuration values
  */
 const init = async (config: FidesConfig) => {
+  const overrideOptions: Partial<FidesOptionOverrides> =
+    getOverrideFidesOptions();
+  config.options = { ...config.options, ...overrideOptions };
   const cookie = getInitialCookie(config);
+  if (config.options.fidesString) {
+    debugLog(
+      config.options.debug,
+      "Explicit fidesString detected. Proceeding to override all TCF preferences with given fidesString"
+    );
+    cookie.fides_string = config.options.fidesString;
+    cookie.tcf_consent = transformFidesStringToCookieKeys(
+      config.options.fidesString,
+      config.options.debug
+    );
+  } else if (
+    tcfConsentCookieObjHasSomeConsentSet(cookie.tcf_consent) &&
+    !cookie.fides_string &&
+    isPrivacyExperience(config.experience) &&
+    experienceIsValid(config.experience, config.options)
+  ) {
+    cookie.fides_string = await generateFidesStringFromCookieTcfConsent(
+      config.experience,
+      cookie.tcf_consent
+    );
+    debugLog(
+      config.options.debug,
+      "fides_string was missing from cookie, so it has been generated based on tcf_consent",
+      cookie.fides_string
+    );
+  }
   const initialFides = getInitialFides({ ...config, cookie });
   initializeCmpApi();
   if (initialFides) {
     Object.assign(_Fides, initialFides);
     dispatchFidesEvent("FidesInitialized", cookie, config.options.debug);
     dispatchFidesEvent("FidesUpdated", cookie, config.options.debug);
   }
   const experience = initialFides?.experience ?? config.experience;
   const updatedFides = await initialize({
     ...config,
+    cookie,
     experience,
-    cookie,
     renderOverlay,
     updateCookie,
   });
   Object.assign(_Fides, updatedFides);
   if (isNewFidesCookie(cookie)) {
     dispatchFidesEvent("FidesInitialized", cookie, config.options.debug);
   }
   dispatchFidesEvent("FidesUpdated", cookie, config.options.debug);
 };
 _Fides = {
@@ -117,20 +215,24 @@
     isOverlayEnabled: false,
     isPrefetchEnabled: false,
     isGeolocationEnabled: false,
     geolocationApiUrl: "",
     overlayParentId: null,
     modalLinkId: null,
     privacyCenterUrl: "",
     fidesApiUrl: "",
     serverSideFidesApiUrl: "",
     tcfEnabled: true,
+    fidesEmbed: false,
+    fidesDisableSaveApi: false,
+    fidesString: null,
+    apiOptions: null,
   },
   fides_meta: {},
   identity: {},
   tcf_consent: {},
   gtm,
   init,
   initialized: false,
   meta,
   shopify,
 };

--- a/clients/fides-js/src/lib/cookie.ts
+++ b/clients/fides-js/src/lib/cookie.ts
@@ -11,21 +11,22 @@
   LegacyConsentConfig,
   PrivacyExperience,
   SaveConsentPreference,
 } from "./consent-types";
 import {
   debugLog,
   transformConsentToFidesUserPreference,
   transformUserPreferenceToBoolean,
 } from "./consent-utils";
 import type { TcfCookieConsent, TcfSavePreferences } from "./tcf/types";
-import { TCF_COOKIE_KEY_TO_EXPERIENCE_KEY } from "./tcf/constants";
+import { TCF_KEY_MAP } from "./tcf/constants";
+import { TcfCookieKeyConsent } from "./tcf/types";
 /**
  * Store the user's consent preferences on the cookie, as key -> boolean pairs, e.g.
  * {
  *   "data_sales": false,
  *   "analytics": true,
  *   ...
  * }
  */
 export type CookieKeyConsent = {
   [cookieKey: string]: boolean | undefined;
@@ -45,40 +46,50 @@
  *   "version": "0.9.0",
  *   "createdAt": "2023-01-01T12:00:00.000Z",
  *   ...
  * }
  */
 export type CookieMeta = Record<string, string>;
 export interface FidesCookie {
   consent: CookieKeyConsent;
   identity: CookieIdentity;
   fides_meta: CookieMeta;
-  fides_tc_string?: string;
+  fides_string?: string;
   tcf_consent: TcfCookieConsent;
 }
 /**
  * Save the cookie under the name "fides_consent" for 365 days
  */
 export const CONSENT_COOKIE_NAME = "fides_consent";
 export const CONSENT_COOKIE_MAX_AGE_DAYS = 365;
 /**
  * The typescript-cookie default codec has a more conservative strategy in order to
  * comply with the exact requirements of RFC 6265. For ease of use in external pages,
  * we instead use encode/decodeURIComponent which are available in every browser.
  *
  * See: https://github.com/carhartl/typescript-cookie#encoding
  */
 const CODEC: Types.CookieCodecConfig<string, string> = {
   decodeName: decodeURIComponent,
   decodeValue: decodeURIComponent,
   encodeName: encodeURIComponent,
   encodeValue: encodeURIComponent,
+};
+export const tcfConsentCookieObjHasSomeConsentSet = (
+  tcf_consent: TcfCookieConsent | undefined
+): boolean => {
+  if (!tcf_consent) {
+    return false;
+  }
+  return Object.values(tcf_consent).some(
+    (val: TcfCookieKeyConsent) => Object.keys(val).length >= 0
+  );
 };
 /**
  * Each cookie will be assigned an autogenerated user/device ID, to match user's
  * consent preferences between the browser and the server. This is a randomly
  * generated UUID to prevent it from being identifiable (without matching it to
  * some other identity data!)
  */
 export const generateFidesUserDeviceId = (): string => uuidv4();
 /**
  * Determine whether or not the given cookie is "new" (ie. has never been saved
@@ -101,36 +112,41 @@
     },
     fides_meta: {
       version: "0.9.0",
       createdAt: now.toISOString(),
       updatedAt: "",
     },
     tcf_consent: {},
   };
 };
 /**
+ * Retrieve cookie by name
+ */
+export const getCookieByName = (cookieName: string): string | undefined =>
+  getCookie(cookieName, CODEC);
+/**
  * Attempt to read, parse, and return the current Fides cookie from the browser.
  * If one doesn't exist, make a new default cookie (including generating a new
  * pseudonymous ID) and return the default values.
  *
  * NOTE: This doesn't *save* the cookie to the browser. To do that, call
  * `saveFidesCookie` with a valid cookie after editing the values.
  */
 export const getOrMakeFidesCookie = (
   defaults?: CookieKeyConsent,
   debug: boolean = false
 ): FidesCookie => {
   const defaultCookie = makeFidesCookie(defaults);
   if (typeof document === "undefined") {
     return defaultCookie;
   }
-  const cookieString = getCookie(CONSENT_COOKIE_NAME, CODEC);
+  const cookieString = getCookieByName(CONSENT_COOKIE_NAME);
   if (!cookieString) {
     debugLog(
       debug,
       `No existing Fides consent cookie found, returning defaults.`,
       cookieString
     );
     return defaultCookie;
   }
   try {
     let parsedCookie: FidesCookie;
@@ -208,20 +224,57 @@
   if (!experience.privacy_notices) {
     return cookieConsent;
   }
   experience.privacy_notices.forEach((notice) => {
     cookieConsent[notice.notice_key] = resolveConsentValue(notice, context);
   });
   debugLog(debug, `Returning cookie consent for experiences.`, cookieConsent);
   return cookieConsent;
 };
 /**
+ * Populates TCF entities with items from cookie.tcf_consent.
+ * Returns TCF entities to be assigned to an experience.
+ */
+export const buildTcfEntitiesFromCookie = (
+  experience: PrivacyExperience,
+  cookie: FidesCookie
+) => {
+  const tcfEntities = {
+    tcf_purpose_consents: experience.tcf_purpose_consents,
+    tcf_purpose_legitimate_interests:
+      experience.tcf_purpose_legitimate_interests,
+    tcf_special_purposes: experience.tcf_special_purposes,
+    tcf_features: experience.tcf_features,
+    tcf_special_features: experience.tcf_special_features,
+    tcf_vendor_consents: experience.tcf_vendor_consents,
+    tcf_vendor_legitimate_interests: experience.tcf_vendor_legitimate_interests,
+    tcf_system_consents: experience.tcf_system_consents,
+    tcf_system_legitimate_interests: experience.tcf_system_legitimate_interests,
+  };
+  if (cookie.tcf_consent) {
+    TCF_KEY_MAP.forEach(({ cookieKey, experienceKey }) => {
+      const cookieConsent = cookie.tcf_consent[cookieKey] ?? {};
+      tcfEntities[experienceKey] = experience[experienceKey]?.map((item) => {
+        const preference = Object.hasOwn(cookieConsent, item.id)
+          ? transformConsentToFidesUserPreference(
+              Boolean(cookieConsent[item.id]),
+              ConsentMechanism.OPT_IN
+            )
+          : // if experience contains a tcf entity not defined by tcfEntities, we override experience current pref with the default pref
+            item.default_preference;
+        return { ...item, current_preference: preference };
+      });
+    });
+  }
+  return tcfEntities;
+};
+/**
  * Updates prefetched experience, based on:
  * 1) experience: pre-fetched experience-based consent configuration that does not contain user preference.
  * 2) cookie: cookie containing user preference.
  *
  * Returns updated experience with user preferences.
  */
 export const updateExperienceFromCookieConsent = ({
   experience,
   cookie,
   debug,
@@ -232,60 +285,35 @@
 }): PrivacyExperience => {
   const noticesWithConsent = experience.privacy_notices?.map((notice) => {
     const preference = Object.hasOwn(cookie.consent, notice.notice_key)
       ? transformConsentToFidesUserPreference(
           Boolean(cookie.consent[notice.notice_key]),
           notice.consent_mechanism
         )
       : undefined;
     return { ...notice, current_preference: preference };
   });
-  const tcfEntities: Partial<PrivacyExperience> = {
-    tcf_purpose_consents: experience.tcf_purpose_consents,
-    tcf_purpose_legitimate_interests:
-      experience.tcf_purpose_legitimate_interests,
-    tcf_special_purposes: experience.tcf_special_purposes,
-    tcf_features: experience.tcf_features,
-    tcf_special_features: experience.tcf_special_features,
-    tcf_vendor_consents: experience.tcf_vendor_consents,
-    tcf_vendor_legitimate_interests: experience.tcf_vendor_legitimate_interests,
-    tcf_system_consents: experience.tcf_system_consents,
-    tcf_system_legitimate_interests: experience.tcf_system_legitimate_interests,
-  };
-  if (cookie.tcf_consent) {
-    TCF_COOKIE_KEY_TO_EXPERIENCE_KEY.forEach(({ cookieKey, experienceKey }) => {
-      const cookieConsent = cookie.tcf_consent[cookieKey] ?? {};
-      tcfEntities[experienceKey] = experience[experienceKey]?.map((item) => {
-        const preference = Object.hasOwn(cookieConsent, item.id)
-          ? transformConsentToFidesUserPreference(
-              Boolean(cookieConsent[item.id]),
-              ConsentMechanism.OPT_IN
-            )
-          : undefined;
-        return { ...item, current_preference: preference };
-      });
-    });
-  }
+  const tcfEntities = buildTcfEntitiesFromCookie(experience, cookie);
   if (debug) {
     debugLog(
       debug,
       `Returning updated pre-fetched experience with user consent.`,
       experience
     );
   }
   return { ...experience, ...tcfEntities, privacy_notices: noticesWithConsent };
 };
 export const transformTcfPreferencesToCookieKeys = (
   tcfPreferences: TcfSavePreferences
 ): TcfCookieConsent => {
   const cookieKeys: TcfCookieConsent = {};
-  TCF_COOKIE_KEY_TO_EXPERIENCE_KEY.forEach(({ cookieKey }) => {
+  TCF_KEY_MAP.forEach(({ cookieKey }) => {
     const preferences = tcfPreferences[cookieKey] ?? [];
     cookieKeys[cookieKey] = Object.fromEntries(
       preferences.map((pref) => [
         pref.id,
         transformUserPreferenceToBoolean(pref.preference),
       ])
     );
   });
   return cookieKeys;
 };

--- a/clients/fides-js/src/lib/initialize.ts
+++ b/clients/fides-js/src/lib/initialize.ts
@@ -1,56 +1,60 @@
 import { ContainerNode } from "preact";
 import { gtm } from "../integrations/gtm";
 import { meta } from "../integrations/meta";
 import { shopify } from "../integrations/shopify";
 import { getConsentContext } from "./consent-context";
 import {
+  buildTcfEntitiesFromCookie,
   CookieIdentity,
   CookieKeyConsent,
   CookieMeta,
   FidesCookie,
+  getCookieByName,
   getOrMakeFidesCookie,
   isNewFidesCookie,
   makeConsentDefaultsLegacy,
   updateCookieFromNoticePreferences,
   updateExperienceFromCookieConsent,
 } from "./cookie";
 import {
   ConsentMechanism,
   ConsentMethod,
   EmptyExperience,
   FidesConfig,
+  FidesOptionOverrides,
   FidesOptions,
   PrivacyExperience,
   SaveConsentPreference,
   UserGeolocation,
 } from "./consent-types";
 import {
   constructFidesRegionString,
   debugLog,
   experienceIsValid,
   isPrivacyExperience,
   transformConsentToFidesUserPreference,
   validateOptions,
 } from "./consent-utils";
 import { fetchExperience } from "../services/fides/api";
 import { getGeolocation } from "../services/external/geolocation";
 import { OverlayProps } from "../components/types";
 import { updateConsentPreferences } from "./preferences";
 import { resolveConsentValue } from "./consent-value";
 import { initOverlay } from "./consent";
 import { TcfCookieConsent } from "./tcf/types";
+import { FIDES_OVERRIDE_OPTIONS_VALIDATOR_MAP } from "./consent-constants";
 export type Fides = {
   consent: CookieKeyConsent;
   experience?: PrivacyExperience | EmptyExperience;
   geolocation?: UserGeolocation;
-  fides_tc_string?: string | undefined;
+  fides_string?: string | undefined;
   options: FidesOptions;
   fides_meta: CookieMeta;
   tcf_consent: TcfCookieConsent;
   gtm: typeof gtm;
   identity: CookieIdentity;
   init: (config: FidesConfig) => Promise<void>;
   initialized: boolean;
   meta: typeof meta;
   shopify: typeof shopify;
 };
@@ -70,27 +74,27 @@
   }
   return fidesRegionString;
 };
 /**
  * Opt out of notices that can be opted out of automatically.
  * This does not currently do anything with TCF.
  */
 const automaticallyApplyGPCPreferences = ({
   cookie,
   fidesRegionString,
-  fidesApiUrl,
   effectiveExperience,
+  fidesOptions,
 }: {
   cookie: FidesCookie;
   fidesRegionString: string | null;
-  fidesApiUrl: string;
   effectiveExperience?: PrivacyExperience;
+  fidesOptions: FidesOptions;
 }) => {
   if (!effectiveExperience || !effectiveExperience.privacy_notices) {
     return;
   }
   const context = getConsentContext();
   if (!context.globalPrivacyControl) {
     return;
   }
   let gpcApplied = false;
   const consentPreferencesToSave = effectiveExperience.privacy_notices.map(
@@ -111,29 +115,61 @@
         transformConsentToFidesUserPreference(
           resolveConsentValue(notice, context),
           notice.consent_mechanism
         )
       );
     }
   );
   if (gpcApplied) {
     updateConsentPreferences({
       consentPreferencesToSave,
-      experienceId: effectiveExperience.id,
-      fidesApiUrl,
+      experience: effectiveExperience,
       consentMethod: ConsentMethod.gpc,
+      options: fidesOptions,
       userLocationString: fidesRegionString || undefined,
       cookie,
       updateCookie: (oldCookie) =>
         updateCookieFromNoticePreferences(oldCookie, consentPreferencesToSave),
     });
   }
+};
+/**
+ * Gets and validates Fides override options provided through URL query params, cookie or window obj.
+ *
+ * If the same override option is provided in multiple ways, load the value in this order:
+ * 1) query param  (top priority)
+ * 2) window obj   (second priority)
+ * 3) cookie value (last priority)
+ */
+export const getOverrideFidesOptions = (): Partial<FidesOptionOverrides> => {
+  const overrideOptions: Partial<FidesOptionOverrides> = {};
+  if (typeof window !== "undefined") {
+    const queryParams = new URLSearchParams(window.location.search);
+    const windowObj = window.config?.tc_info;
+    FIDES_OVERRIDE_OPTIONS_VALIDATOR_MAP.forEach(
+      ({ fidesOption, fidesOptionType, fidesOverrideKey, validationRegex }) => {
+        const queryParamOverride: string | null =
+          queryParams.get(fidesOverrideKey);
+        const windowObjOverride: string | boolean | undefined = windowObj
+          ? windowObj[fidesOverrideKey]
+          : undefined;
+        const cookieOverride: string | undefined =
+          getCookieByName(fidesOverrideKey);
+        const value = queryParamOverride || windowObjOverride || cookieOverride;
+        if (value && validationRegex.test(value.toString())) {
+          overrideOptions[fidesOption] =
+            fidesOptionType === "string" ? value : JSON.parse(value.toString());
+        }
+      }
+    );
+  }
+  return overrideOptions;
 };
 /**
  * Get the initial Fides cookie based on legacy consent values
  * as well as any preferences stored in existing cookies
  */
 export const getInitialCookie = ({ consent, options }: FidesConfig) => {
   const context = getConsentContext();
   const consentDefaults = makeConsentDefaultsLegacy(
     consent,
     context,
@@ -150,38 +186,38 @@
  */
 export const getInitialFides = ({
   cookie,
   experience,
   geolocation,
   options,
 }: {
   cookie: FidesCookie;
 } & FidesConfig): Partial<Fides> | null => {
   const hasExistingCookie = !isNewFidesCookie(cookie);
-  if (!hasExistingCookie) {
+  if (!hasExistingCookie && !options.fidesString) {
     return null;
   }
   let updatedExperience = experience;
   if (isPrivacyExperience(experience)) {
     updatedExperience = updateExperienceFromCookieConsent({
       experience,
       cookie,
       debug: options.debug,
     });
   }
   return {
     consent: cookie.consent,
     fides_meta: cookie.fides_meta,
     identity: cookie.identity,
     experience: updatedExperience,
     tcf_consent: cookie.tcf_consent,
-    fides_tc_string: cookie.fides_tc_string,
+    fides_string: cookie.fides_string,
     geolocation,
     options,
     initialized: true,
   };
 };
 /**
  * The bulk of the initialization logic
  * 1. Validates options
  * 2. Retrieves geolocation
  * 3. Retrieves experience
@@ -214,65 +250,87 @@
         options.debug,
         "Invalid overlay options. Skipping overlay initialization.",
         options
       );
       shouldInitOverlay = false;
     }
     fidesRegionString = await retrieveEffectiveRegionString(
       geolocation,
       options
     );
+    let fetchedClientSideExperience = false;
     if (!fidesRegionString) {
       debugLog(
         options.debug,
         `User location could not be obtained. Skipping overlay initialization.`
       );
       shouldInitOverlay = false;
     } else if (!isPrivacyExperience(effectiveExperience)) {
+      fetchedClientSideExperience = true;
       effectiveExperience = await fetchExperience(
         fidesRegionString,
         options.fidesApiUrl,
         options.debug,
         cookie.identity.fides_user_device_id
       );
     }
     if (
       isPrivacyExperience(effectiveExperience) &&
       experienceIsValid(effectiveExperience, options)
     ) {
-      const updatedCookie = await updateCookie(
-        cookie,
-        effectiveExperience,
-        options.debug
-      );
-      Object.assign(cookie, updatedCookie);
+      if (options.fidesString) {
+        if (fetchedClientSideExperience) {
+          debugLog(
+            options.debug,
+            "Overriding preferences from client-side fetched experience with cookie fides_string consent",
+            cookie.fides_string
+          );
+          const tcfEntities = buildTcfEntitiesFromCookie(
+            effectiveExperience,
+            cookie
+          );
+          Object.assign(effectiveExperience, tcfEntities);
+        }
+      } else {
+        const updatedCookie = await updateCookie(
+          cookie,
+          effectiveExperience,
+          options.debug
+        );
+        debugLog(
+          options.debug,
+          "Updated cookie based on experience",
+          updatedCookie
+        );
+        Object.assign(cookie, updatedCookie);
+      }
       if (shouldInitOverlay) {
         await initOverlay({
           experience: effectiveExperience,
           fidesRegionString: fidesRegionString as string,
           cookie,
           options,
           renderOverlay,
         }).catch(() => {});
       }
     }
   }
   if (shouldInitOverlay && isPrivacyExperience(effectiveExperience)) {
     automaticallyApplyGPCPreferences({
       cookie,
       fidesRegionString,
-      fidesApiUrl: options.fidesApiUrl,
       effectiveExperience,
+      fidesOptions: options,
     });
   }
   return {
     consent: cookie.consent,
     fides_meta: cookie.fides_meta,
     identity: cookie.identity,
-    fides_tc_string: cookie.fides_tc_string,
+    fides_string: cookie.fides_string,
     tcf_consent: cookie.tcf_consent,
     experience,
     geolocation,
     options,
     initialized: true,
   };
 };

--- a/clients/fides-js/src/lib/preferences.ts
+++ b/clients/fides-js/src/lib/preferences.ts
@@ -1,54 +1,91 @@
 import {
   ConsentMethod,
   ConsentOptionCreate,
+  FidesOptions,
   LastServedConsentSchema,
+  PrivacyExperience,
   PrivacyPreferencesRequest,
   SaveConsentPreference,
   UserConsentPreference,
 } from "./consent-types";
 import { debugLog } from "./consent-utils";
 import {
   FidesCookie,
   removeCookiesFromBrowser,
   saveFidesCookie,
 } from "./cookie";
 import { dispatchFidesEvent } from "./events";
 import { patchUserPreferenceToFidesServer } from "../services/fides/api";
 import { TcfSavePreferences } from "./tcf/types";
 /**
+ * Helper function to save preferences to an API, either custom or internal
+ */
+async function savePreferencesApi(
+  options: FidesOptions,
+  cookie: FidesCookie,
+  experience: PrivacyExperience,
+  fidesUserPreferences: Array<ConsentOptionCreate> | undefined,
+  consentMethod: ConsentMethod,
+  tcf?: TcfSavePreferences,
+  userLocationString?: string
+) {
+  if (options.apiOptions?.savePreferencesFn) {
+    debugLog(options.debug, "Calling custom save preferences fn");
+    await options.apiOptions.savePreferencesFn(
+      cookie.consent,
+      cookie.fides_string,
+      experience
+    );
+  } else {
+    const privacyPreferenceCreate: PrivacyPreferencesRequest = {
+      browser_identity: cookie.identity,
+      preferences: fidesUserPreferences,
+      privacy_experience_id: experience.id,
+      user_geography: userLocationString,
+      method: consentMethod,
+      ...(tcf ?? []),
+    };
+    debugLog(options.debug, "Saving preferences to Fides API");
+    await patchUserPreferenceToFidesServer(
+      privacyPreferenceCreate,
+      options.fidesApiUrl,
+      options.debug
+    );
+  }
+}
+/**
  * Updates the user's consent preferences, going through the following steps:
- * 1. Save preferences to Fides API
- * 2. Update the window.Fides.consent object
- * 3. Save preferences to the `fides_consent` cookie in the browser
- * 4. Remove any cookies from notices that were opted-out from the browser
- * 5. Dispatch a "FidesUpdated" event
+ * 1. Update the cookie object based on new preferences
+ * 2. Update the window.Fides object
+ * 3. Save preferences to Fides API or a custom function (`savePreferencesFn`)
+ * 4. Save preferences to the `fides_consent` cookie in the browser
+ * 5. Remove any cookies from notices that were opted-out from the browser
+ * 6. Dispatch a "FidesUpdated" event
  */
 export const updateConsentPreferences = async ({
   consentPreferencesToSave,
-  experienceId,
-  fidesApiUrl,
+  experience,
   consentMethod,
+  options,
   userLocationString,
   cookie,
-  debug = false,
   servedNotices,
   tcf,
   updateCookie,
 }: {
   consentPreferencesToSave?: Array<SaveConsentPreference>;
-  experienceId: string;
-  fidesApiUrl: string;
+  experience: PrivacyExperience;
   consentMethod: ConsentMethod;
+  options: FidesOptions;
   userLocationString?: string;
   cookie: FidesCookie;
-  debug?: boolean;
   servedNotices?: Array<LastServedConsentSchema> | null;
   tcf?: TcfSavePreferences;
   updateCookie: (oldCookie: FidesCookie) => Promise<FidesCookie>;
 }) => {
   const fidesUserPreferences: Array<ConsentOptionCreate> | undefined =
     consentPreferencesToSave
       ? consentPreferencesToSave.map(({ notice, consentPreference }) => {
           const servedNotice = servedNotices
             ? servedNotices.find(
                 (n) =>
@@ -56,40 +93,49 @@
                   notice.privacy_notice_history_id
               )
             : undefined;
           return {
             privacy_notice_history_id: notice.privacy_notice_history_id,
             preference: consentPreference,
             served_notice_history_id: servedNotice?.served_notice_history_id,
           };
         })
       : undefined;
-  debugLog(debug, "Saving preferences to Fides API");
-  const privacyPreferenceCreate: PrivacyPreferencesRequest = {
-    browser_identity: cookie.identity,
-    preferences: fidesUserPreferences,
-    privacy_experience_id: experienceId,
-    user_geography: userLocationString,
-    method: consentMethod,
-    ...(tcf ?? []),
-  };
-  patchUserPreferenceToFidesServer(privacyPreferenceCreate, fidesApiUrl, debug);
   const updatedCookie = await updateCookie(cookie);
   Object.assign(cookie, updatedCookie);
-  debugLog(debug, "Updating window.Fides");
+  debugLog(options.debug, "Updating window.Fides");
   window.Fides.consent = cookie.consent;
-  window.Fides.fides_tc_string = cookie.fides_tc_string;
+  window.Fides.fides_string = cookie.fides_string;
   window.Fides.tcf_consent = cookie.tcf_consent;
-  debugLog(debug, "Saving preferences to cookie");
+  if (!options.fidesDisableSaveApi) {
+    try {
+      await savePreferencesApi(
+        options,
+        cookie,
+        experience,
+        fidesUserPreferences,
+        consentMethod,
+        tcf,
+        userLocationString
+      );
+    } catch (e) {
+      debugLog(
+        options.debug,
+        "Error saving updated preferences to API, continuing. Error: ",
+        e
+      );
+    }
+  }
+  debugLog(options.debug, "Saving preferences to cookie");
   saveFidesCookie(cookie);
   if (consentPreferencesToSave) {
     consentPreferencesToSave
       .filter(
         (preference) =>
           preference.consentPreference === UserConsentPreference.OPT_OUT
       )
       .forEach((preference) => {
         removeCookiesFromBrowser(preference.notice.cookies);
       });
   }
-  dispatchFidesEvent("FidesUpdated", cookie, debug);
+  dispatchFidesEvent("FidesUpdated", cookie, options.debug);
 };

--- a/clients/fides-js/src/lib/tcf.ts
+++ b/clients/fides-js/src/lib/tcf.ts
@@ -32,28 +32,28 @@
   const uniqueIds = Array.from(
     new Set(
       [
         ...tcStringPreferences.vendorsConsent,
         ...tcStringPreferences.vendorsLegint,
       ]
         .filter((id) => vendorIsAc(id))
         .map((id) => decodeVendorId(id).id)
     )
   );
-  const vendorIds = uniqueIds.sort().join(".");
+  const vendorIds = uniqueIds.sort((a, b) => Number(a) - Number(b)).join(".");
   return `${AC_SPECIFICATION_VERSION}~${vendorIds}`;
 };
 /**
- * Generate TC String based on TCF-related info from privacy experience.
+ * Generate FidesString based on TCF and AC-related info from privacy experience.
  * Called when there is either a FidesInitialized or FidesUpdated event
  */
-export const generateTcString = async ({
+export const generateFidesString = async ({
   experience,
   tcStringPreferences,
 }: {
   tcStringPreferences?: EnabledIds;
   experience: PrivacyExperience;
 }): Promise<string> => {
   let encodedString = "";
   try {
     const tcModel = new TCModel(new GVL(experience.gvl));
     await tcModel.gvl.readyPromise;
@@ -112,41 +112,40 @@
     return Promise.resolve("");
   }
   return Promise.resolve(encodedString);
 };
 /**
  * Extract just the TC string from a FidesEvent. This will also remove parts of the
  * TC string that we do not want to surface with our CMP API events, such as
  * `vendors_disclosed` and our own AC string addition.
  */
 const fidesEventToTcString = (event: FidesEvent) => {
-  const { fides_tc_string: cookieString } = event.detail;
+  const { fides_string: cookieString } = event.detail;
   if (cookieString) {
     const [tcString] = cookieString.split(FIDES_SEPARATOR);
     return tcString.split(".")[0];
   }
   return cookieString;
 };
 /**
  * Initializes the CMP API, including setting up listeners on FidesEvents to update
  * the CMP API accordingly.
  */
 export const initializeCmpApi = () => {
   makeStub();
   const isServiceSpecific = true; // TODO: determine this from the backend?
   const cmpApi = new CmpApi(CMP_ID, CMP_VERSION, isServiceSpecific, {
     getTCData: (next, tcData: TCData, status) => {
       /*
        * If using with 'removeEventListener' command, add a check to see if tcData is not a boolean. */
       if (typeof tcData !== "boolean") {
-        const stringSplit =
-          window.Fides.fides_tc_string?.split(FIDES_SEPARATOR);
+        const stringSplit = window.Fides.fides_string?.split(FIDES_SEPARATOR);
         const addtlConsent = stringSplit?.length === 2 ? stringSplit[1] : "";
         next({ ...tcData, addtlConsent }, status);
         return;
       }
       next(tcData, status);
     },
   });
   window.addEventListener("FidesInitialized", (event) => {
     const tcString = fidesEventToTcString(event);
     cmpApi.update(tcString ?? null, false);

--- a/clients/fides-js/src/lib/tcf/constants.ts
+++ b/clients/fides-js/src/lib/tcf/constants.ts
@@ -1,47 +1,58 @@
-import { TcfExperienceRecords, TcfModelType } from "./types";
+import { TCModel } from "@iabtechlabtcf/core";
+import { EnabledIds, TcfExperienceRecords, TcfModelType } from "./types";
 /**
  * We store all of our preference strings (TC, AC, etc.) together as one string so that
  * we can have a single-source-of-truth for offline storage & syncing. The code responsible
  * for serving our standards-compliant JS API is responsible for separating out the
  * preference strings for consumption.
  */
 export const FIDES_SEPARATOR = ",";
-export const TCF_COOKIE_KEY_TO_EXPERIENCE_KEY: {
+export const TCF_KEY_MAP: {
   cookieKey: TcfModelType;
   experienceKey: keyof TcfExperienceRecords;
+  tcfModelKey?: keyof TCModel;
+  enabledIdsKey?: keyof EnabledIds;
 }[] = [
   {
     cookieKey: "purpose_consent_preferences",
     experienceKey: "tcf_purpose_consents",
+    tcfModelKey: "purposeConsents",
+    enabledIdsKey: "purposesConsent",
   },
   {
     cookieKey: "purpose_legitimate_interests_preferences",
     experienceKey: "tcf_purpose_legitimate_interests",
+    tcfModelKey: "purposeLegitimateInterests",
+    enabledIdsKey: "purposesLegint",
   },
   {
     cookieKey: "special_feature_preferences",
     experienceKey: "tcf_special_features",
+    tcfModelKey: "specialFeatureOptins",
+    enabledIdsKey: "specialFeatures",
   },
   {
     cookieKey: "vendor_consent_preferences",
     experienceKey: "tcf_vendor_consents",
+    tcfModelKey: "vendorConsents",
+    enabledIdsKey: "vendorsConsent",
   },
   {
     cookieKey: "vendor_legitimate_interests_preferences",
     experienceKey: "tcf_vendor_legitimate_interests",
+    tcfModelKey: "vendorLegitimateInterests",
+    enabledIdsKey: "vendorsLegint",
   },
   {
     cookieKey: "system_consent_preferences",
     experienceKey: "tcf_system_consents",
   },
   {
     cookieKey: "system_legitimate_interests_preferences",
     experienceKey: "tcf_system_legitimate_interests",
   },
 ];
-export const EXPERIENCE_KEYS_WITH_PREFERENCES =
-  TCF_COOKIE_KEY_TO_EXPERIENCE_KEY.filter(
-    ({ experienceKey }) =>
-      experienceKey !== "tcf_features" &&
-      experienceKey !== "tcf_special_purposes"
-  ).map((key) => key.experienceKey);
+export const EXPERIENCE_KEYS_WITH_PREFERENCES = TCF_KEY_MAP.filter(
+  ({ experienceKey }) =>
+    experienceKey !== "tcf_features" && experienceKey !== "tcf_special_purposes"
+).map((key) => key.experienceKey);

--- a/clients/fides-js/src/lib/tcf/vendors.ts
+++ b/clients/fides-js/src/lib/tcf/vendors.ts
@@ -37,56 +37,42 @@
   }
   const { source, id } = decodeVendorId(vendorId);
   if (source === VendorSources.GVL || source === undefined) {
     return gvl.vendors[id];
   }
   return undefined;
 };
 export const vendorIsAc = (vendorId: TCFVendorRelationships["id"]) =>
   decodeVendorId(vendorId).source === VendorSources.AC;
 export const uniqueGvlVendorIds = (experience: PrivacyExperience): number[] => {
-  const {
-    tcf_vendor_consents: vendorConsents = [],
-    tcf_vendor_legitimate_interests: vendorLegints = [],
-  } = experience;
-  const universalIds = Array.from(
-    new Set([
-      ...vendorConsents.map((v) => v.id),
-      ...vendorLegints.map((v) => v.id),
-    ])
-  );
-  const gvlIds = universalIds.filter((uid) =>
-    vendorGvlEntry(uid, experience.gvl)
-  );
+  const { tcf_vendor_relationships: vendors = [] } = experience;
+  const gvlIds = vendors
+    .map((v) => v.id)
+    .filter((uid) => vendorGvlEntry(uid, experience.gvl));
   return gvlIds.map((uid) => +decodeVendorId(uid).id);
 };
 const transformVendorDataToVendorRecords = ({
   consents,
   legints,
   relationships,
   isFidesSystem,
 }: {
   consents: TCFVendorConsentRecord[];
   legints: TCFVendorLegitimateInterestsRecord[];
   relationships: TCFVendorRelationships[];
   isFidesSystem: boolean;
 }) => {
   const records: VendorRecord[] = [];
-  const uniqueVendorIds = Array.from(
-    new Set([...consents.map((c) => c.id), ...legints.map((l) => l.id)])
-  );
-  uniqueVendorIds.forEach((id) => {
-    const vendorConsent = consents.find((v) => v.id === id);
-    const vendorLegint = legints.find((v) => v.id === id);
-    const relationship = relationships.find((r) => r.id === id);
+  relationships.forEach((relationship) => {
+    const vendorConsent = consents.find((v) => v.id === relationship.id);
+    const vendorLegint = legints.find((v) => v.id === relationship.id);
     const record: VendorRecord = {
-      id,
       ...relationship,
       ...vendorConsent,
       ...vendorLegint,
       isFidesSystem,
       isConsent: !!vendorConsent,
       isLegint: !!vendorLegint,
     };
     records.push(record);
   });
   return records;

--- a/clients/privacy-center/cypress/e2e/consent-banner-tcf.cy.ts
+++ b/clients/privacy-center/cypress/e2e/consent-banner-tcf.cy.ts
@@ -1,18 +1,19 @@
 /* eslint-disable no-underscore-dangle */
 import {
   CONSENT_COOKIE_NAME,
   FidesCookie,
   PrivacyExperience,
   UserConsentPreference,
 } from "fides-js";
-import { stubConfig } from "../support/stubs";
+import { CookieKeyConsent } from "fides-js/src/lib/cookie";
+import { OVERRIDE, stubConfig } from "../support/stubs";
 const PURPOSE_2 = {
   id: 2,
   name: "Use limited data to select advertising",
 };
 const PURPOSE_4 = {
   id: 4,
   name: "Use profiles to select personalised advertising",
 };
 const PURPOSE_6 = {
   id: 6,
@@ -48,33 +49,33 @@
 };
 const FEATURE_2 = {
   id: 2,
   name: "Link different devices",
 };
 const SPECIAL_FEATURE_1 = {
   id: 1,
   name: "Use precise geolocation data",
 };
 describe("Fides-js TCF", () => {
-  beforeEach(() => {
-    cy.getCookie(CONSENT_COOKIE_NAME).should("not.exist");
-    cy.fixture("consent/experience_tcf.json").then((experience) => {
-      stubConfig({
-        options: {
-          isOverlayEnabled: true,
-          tcfEnabled: true,
-        },
-        experience: experience.items[0],
-      });
-    });
-  });
   describe("banner appears when it should", () => {
+    beforeEach(() => {
+      cy.getCookie(CONSENT_COOKIE_NAME).should("not.exist");
+      cy.fixture("consent/experience_tcf.json").then((experience) => {
+        stubConfig({
+          options: {
+            isOverlayEnabled: true,
+            tcfEnabled: true,
+          },
+          experience: experience.items[0],
+        });
+      });
+    });
     const setAllTcfToValue = (
       experience: PrivacyExperience,
       value: UserConsentPreference | undefined
     ): PrivacyExperience => {
       const consentPurposes = experience.tcf_purpose_consents?.map((p) => ({
         ...p,
         current_preference: value,
       }));
       const legintPurposes = experience.tcf_purpose_legitimate_interests?.map(
         (p) => ({ ...p, current_preference: value })
@@ -159,20 +160,32 @@
           },
           experience: updatedExperience,
         });
         cy.waitUntilFidesInitialized().then(() => {
           cy.get("div#fides-banner");
         });
       });
     });
   });
   describe("initial layer", () => {
+    beforeEach(() => {
+      cy.getCookie(CONSENT_COOKIE_NAME).should("not.exist");
+      cy.fixture("consent/experience_tcf.json").then((experience) => {
+        stubConfig({
+          options: {
+            isOverlayEnabled: true,
+            tcfEnabled: true,
+          },
+          experience: experience.items[0],
+        });
+      });
+    });
     it("can render purposes in the initial layer as a stack", () => {
       cy.get("div#fides-banner").within(() => {
         cy.get("span").contains(STACK_1.name);
         cy.get("span").contains(PURPOSE_6.name);
         cy.get("span").contains(STACK_1.name).click();
         [PURPOSE_4.id, PURPOSE_9.id, PURPOSE_7.id, PURPOSE_2.id].forEach(
           (id) => {
             cy.get("li").contains(`Purpose ${id}`);
           }
         );
@@ -190,20 +203,30 @@
       cy.get("div#fides-banner").within(() => {
         cy.get("button").contains("Vendors").click();
       });
       cy.get("#fides-tab-Vendors");
       cy.getByTestId(`toggle-${SYSTEM_1.name}`);
       cy.getByTestId(`toggle-${VENDOR_1.name}-consent`);
     });
   });
   describe("second layer", () => {
     beforeEach(() => {
+      cy.getCookie(CONSENT_COOKIE_NAME).should("not.exist");
+      cy.fixture("consent/experience_tcf.json").then((experience) => {
+        stubConfig({
+          options: {
+            isOverlayEnabled: true,
+            tcfEnabled: true,
+          },
+          experience: experience.items[0],
+        });
+      });
       cy.get("#fides-modal-link").click();
     });
     describe("rendering the TCF modal", () => {
       it("can render tabs", () => {
         cy.get("#fides-tab-Purposes");
         cy.getByTestId("toggle-Purposes").within(() => {
           cy.get("input").should("be.checked");
         });
         cy.getByTestId(`toggle-${PURPOSE_4.name}-consent`).within(() => {
           cy.get("input").should("be.checked");
@@ -233,20 +256,21 @@
         });
       });
       it("can render IAB TCF badge on vendors and filter", () => {
         const newVendor = {
           id: "gvl.1",
           name: "Exponential Interactive, Inc d/b/a VDX.tv",
         };
         cy.fixture("consent/experience_tcf.json").then((payload) => {
           const experience = payload.items[0];
           experience.tcf_vendor_consents.push(newVendor);
+          experience.tcf_vendor_relationships.push(newVendor);
           stubConfig({
             options: {
               isOverlayEnabled: true,
               tcfEnabled: true,
             },
             experience,
           });
         });
         cy.get("#fides-modal-link").click();
         cy.get("#fides-tab-Vendors").click();
@@ -269,53 +293,95 @@
           cy.get("button").contains("IAB TCF vendors").click();
         });
         cy.get("span").contains(SYSTEM_1.name).should("not.exist");
         cy.get("span").contains(VENDOR_1.name);
         cy.get("span").contains(newVendor.name);
         cy.getByTestId("consent-modal").within(() => {
           cy.get("button").contains("Opt in to all").click();
         });
         cy.window().then((win) => {
           win.__tcfapi("getTCData", 2, cy.stub().as("getTCData"));
-        });
-        cy.get("@getTCData")
-          .should("have.been.calledOnce")
-          .its("lastCall.args")
-          .then(([tcData, success]) => {
-            expect(success).to.eql(true);
-            expect(tcData.vendor.consents).to.eql({ 1: true, 2: true });
-          });
-      });
-      it("can group toggle", () => {
+          cy.get("@getTCData")
+            .should("have.been.calledOnce")
+            .its("lastCall.args")
+            .then(([tcData, success]) => {
+              expect(success).to.eql(true);
+              expect(tcData.vendor.consents).to.eql({ 1: true, 2: true });
+            });
+        });
+      });
+      it("can render extra vendor info such as cookie and retention data", () => {
+        cy.get("#fides-tab-Vendors").click();
+        cy.get(".fides-notice-toggle-title").contains(VENDOR_1.name).click();
+        cy.get(".fides-disclosure-visible").within(() => {
+          cy.get("a")
+            .contains("Privacy policy")
+            .should("have.attr", "href")
+            .and("contain", "https://www.example.com/privacy");
+          cy.get("a")
+            .contains("Legitimate interest disclosure")
+            .should("have.attr", "href")
+            .and(
+              "contain",
+              "https://www.example.com/legitimate_interest_disclosure"
+            );
+          [PURPOSE_4, PURPOSE_6, PURPOSE_7, PURPOSE_9].forEach((purpose) => {
+            cy.get("tr")
+              .contains(purpose.name)
+              .parent()
+              .contains(`${purpose.id} day(s)`);
+          });
+          cy.get("tr")
+            .contains(SPECIAL_PURPOSE_1.name)
+            .parent()
+            .contains(`${SPECIAL_PURPOSE_1.id} day(s)`);
+          cy.get("p").contains(
+            'Captify stores cookies with a maximum duration of about 5 Day(s). These cookies may be refreshed. This vendor also uses other methods like "local storage" to store and access information on your device.'
+          );
+        });
+        cy.get(".fides-notice-toggle-title").contains(VENDOR_1.name).click();
+        cy.get(".fides-notice-toggle-title").contains(SYSTEM_1.name).click();
+        cy.get(".fides-disclosure-visible").within(() => {
+          cy.get("p").contains(
+            "Fides System stores cookies with a maximum duration of about 5 Day(s)"
+          );
+        });
+      });
+      it("can group toggle and fire FidesUIChanged events", () => {
         cy.getByTestId("toggle-Purposes").click();
         cy.getByTestId(`toggle-${PURPOSE_2.name}`).within(() => {
           cy.get("input").should("not.be.checked");
         });
+        cy.get("@FidesUIChanged").its("callCount").should("equal", 1);
         cy.getByTestId(`toggle-${PURPOSE_2.name}`).click();
         cy.getByTestId("toggle-Purposes").within(() => {
           cy.get("input").should("be.checked");
         });
+        cy.get("@FidesUIChanged").its("callCount").should("equal", 2);
         cy.getByTestId("toggle-all-Purposes-consent").click();
         cy.getByTestId(`toggle-${PURPOSE_4.name}-consent`).within(() => {
           cy.get("input").should("not.be.checked");
         });
+        cy.get("@FidesUIChanged").its("callCount").should("equal", 3);
         cy.getByTestId("toggle-all-Purposes-consent").click();
         cy.getByTestId(`toggle-${PURPOSE_4.name}-consent`).within(() => {
           cy.get("input").should("be.checked");
         });
+        cy.get("@FidesUIChanged").its("callCount").should("equal", 4);
         cy.get("button").contains("All off").click();
         cy.getByTestId(`toggle-${PURPOSE_2.name}`).within(() => {
           cy.get("input").should("not.be.checked");
         });
         cy.getByTestId(`toggle-${PURPOSE_4.name}-consent`).within(() => {
           cy.get("input").should("not.be.checked");
         });
+        cy.get("@FidesUIChanged").its("callCount").should("equal", 5);
       });
       it("can handle group toggle empty states", () => {
         cy.fixture("consent/experience_tcf.json").then((payload) => {
           const experience = payload.items[0];
           const updatedExperience = { ...experience, tcf_purpose_consents: [] };
           stubConfig({
             options: {
               isOverlayEnabled: true,
               tcfEnabled: true,
             },
@@ -374,31 +440,33 @@
           cy.waitUntilFidesInitialized().then(() => {
             cy.get("#fides-modal-link").click();
             cy.get("#fides-tab-Vendors").click();
             cy.getByTestId(`toggle-${VENDOR_1.name}`).click();
             cy.getByTestId(`toggle-${VENDOR_1.name}`).within(() => {
               cy.get("input").should("not.be.checked");
             });
             cy.getByTestId(`toggle-${VENDOR_1.name}-consent`).within(() => {
               cy.get("input").should("not.be.checked");
             });
+            cy.get("@FidesUIChanged").should("have.been.calledOnce");
           });
         });
       });
     });
     describe("saving preferences", () => {
       const expectedEndOfFidesString = ".IABE,1~";
       it("can opt in to all", () => {
         cy.getCookie(CONSENT_COOKIE_NAME).should("not.exist");
         cy.getByTestId("consent-modal").within(() => {
           cy.get("button").contains("Opt in to all").click();
           cy.wait("@patchPrivacyPreference").then((interception) => {
+            cy.get("@FidesUIChanged").should("not.have.been.called");
             const { body } = interception.request;
             expect(body.purpose_consent_preferences).to.eql([
               { id: PURPOSE_4.id, preference: "opt_in" },
               { id: PURPOSE_6.id, preference: "opt_in" },
               { id: PURPOSE_7.id, preference: "opt_in" },
               { id: PURPOSE_9.id, preference: "opt_in" },
             ]);
             expect(body.purpose_legitimate_interests_preferences).to.eql([
               { id: PURPOSE_2.id, preference: "opt_in" },
             ]);
@@ -445,28 +513,29 @@
           ).to.eql({});
           expect(
             cookieKeyConsent.tcf_consent.system_consent_preferences
           ).to.eql({});
           expect(
             cookieKeyConsent.tcf_consent.system_legitimate_interests_preferences
           )
             .property(`${SYSTEM_1.id}`)
             .is.eql(true);
           expect(
-            cookieKeyConsent.fides_tc_string?.endsWith(expectedEndOfFidesString)
+            cookieKeyConsent.fides_string?.endsWith(expectedEndOfFidesString)
           ).to.eql(true);
         });
       });
       it("can opt out of all", () => {
         cy.getByTestId("consent-modal").within(() => {
           cy.get("button").contains("Opt out of all").click();
           cy.wait("@patchPrivacyPreference").then((interception) => {
+            cy.get("@FidesUIChanged").should("not.have.been.called");
             const { body } = interception.request;
             expect(body.purpose_consent_preferences).to.eql([
               { id: PURPOSE_4.id, preference: "opt_out" },
               { id: PURPOSE_6.id, preference: "opt_out" },
               { id: PURPOSE_7.id, preference: "opt_out" },
               { id: PURPOSE_9.id, preference: "opt_out" },
             ]);
             expect(body.purpose_legitimate_interests_preferences).to.eql([
               { id: PURPOSE_2.id, preference: "opt_out" },
             ]);
@@ -513,32 +582,33 @@
           ).to.eql({});
           expect(
             cookieKeyConsent.tcf_consent.system_consent_preferences
           ).to.eql({});
           expect(
             cookieKeyConsent.tcf_consent.system_legitimate_interests_preferences
           )
             .property(`${SYSTEM_1.id}`)
             .is.eql(false);
           expect(
-            cookieKeyConsent.fides_tc_string?.endsWith(expectedEndOfFidesString)
+            cookieKeyConsent.fides_string?.endsWith(expectedEndOfFidesString)
           ).to.eql(true);
         });
       });
       it("can opt in to some and opt out of others", () => {
         cy.getByTestId("consent-modal").within(() => {
           cy.getByTestId(`toggle-${PURPOSE_4.name}-consent`).click();
           cy.get("#fides-tab-Features").click();
           cy.getByTestId(`toggle-${SPECIAL_FEATURE_1.name}`).click();
           cy.get("#fides-tab-Vendors").click();
           cy.getByTestId(`toggle-${SYSTEM_1.name}`).click();
           cy.get("button").contains("Save").click();
+          cy.get("@FidesUIChanged").its("callCount").should("equal", 3);
           cy.wait("@patchPrivacyPreference").then((interception) => {
             const { body } = interception.request;
             expect(body.purpose_consent_preferences).to.eql([
               { id: PURPOSE_4.id, preference: "opt_out" },
               { id: PURPOSE_6.id, preference: "opt_in" },
               { id: PURPOSE_7.id, preference: "opt_in" },
               { id: PURPOSE_9.id, preference: "opt_in" },
             ]);
             expect(body.purpose_legitimate_interests_preferences).to.eql([
               { id: PURPOSE_2.id, preference: "opt_in" },
@@ -587,28 +657,454 @@
           ).to.eql({});
           expect(
             cookieKeyConsent.tcf_consent.system_legitimate_interests_preferences
           )
             .property(`${SYSTEM_1.id}`)
             .is.eql(false);
           expect(
             cookieKeyConsent.tcf_consent.system_consent_preferences
           ).to.eql({});
           expect(
-            cookieKeyConsent.fides_tc_string?.endsWith(expectedEndOfFidesString)
+            cookieKeyConsent.fides_string?.endsWith(expectedEndOfFidesString)
           ).to.eql(true);
         });
       });
+      it("calls custom save preferences API fn instead of internal Fides API when it is provided in Fides.init", () => {
+        const apiOptions = {
+          /* eslint-disable @typescript-eslint/no-unused-vars */
+          savePreferencesFn: (
+            consent: CookieKeyConsent,
+            fides_string: string | undefined,
+            experience: PrivacyExperience
+          ): Promise<void> => new Promise(() => {}),
+          /* eslint-enable @typescript-eslint/no-unused-vars */
+        };
+        const spyObject = cy
+          .spy(apiOptions, "savePreferencesFn")
+          .as("mockSavePreferencesFn");
+        cy.fixture("consent/experience_tcf.json").then((privacyExperience) => {
+          stubConfig({
+            options: {
+              isOverlayEnabled: true,
+              tcfEnabled: true,
+              apiOptions,
+            },
+            experience: privacyExperience.items[0],
+          });
+          cy.waitUntilFidesInitialized().then(() => {
+            cy.get("#fides-modal-link").click();
+            cy.getByTestId("consent-modal").within(() => {
+              cy.get("button").contains("Opt out of all").click();
+              cy.get("@FidesUpdated").then(() => {
+                expect(spyObject).to.be.called;
+                const spy = spyObject.getCalls();
+                const { args } = spy[0];
+                expect(args[0]).to.deep.equal({
+                  data_sales: true,
+                  tracking: false,
+                });
+                expect(args[1]).to.equal(
+                  "CP0JloAP0JloAGXABBENATEAAAAAAAAAAAAAAAAAAAAA.IABE,1~"
+                );
+                expect(args[2]).to.deep.equal(privacyExperience.items[0]);
+              });
+              cy.on("fail", (error) => {
+                if (error.message.indexOf("Timed out retrying") !== 0) {
+                  throw error;
+                }
+              });
+              cy.wait("@patchPrivacyPreference", {
+                requestTimeout: 100,
+              }).then((xhr) => {
+                assert.isNull(xhr?.response?.body);
+              });
+            });
+          });
+        });
+      });
+      it("skips saving preferences to API when disable save is set", () => {
+        cy.fixture("consent/experience_tcf.json").then((experience) => {
+          stubConfig({
+            options: {
+              isOverlayEnabled: true,
+              tcfEnabled: true,
+              fidesDisableSaveApi: true,
+            },
+            experience: experience.items[0],
+          });
+        });
+        cy.waitUntilFidesInitialized().then(() => {
+          cy.get("#fides-modal-link").click();
+          cy.getByTestId("consent-modal").within(() => {
+            cy.get("button").contains("Opt out of all").click();
+            cy.on("fail", (error) => {
+              if (error.message.indexOf("Timed out retrying") !== 0) {
+                throw error;
+              }
+            });
+            cy.wait("@patchPrivacyPreference", {
+              requestTimeout: 100,
+            }).then((xhr) => {
+              assert.isNull(xhr?.response?.body);
+            });
+          });
+          cy.getCookie(CONSENT_COOKIE_NAME).then((cookie) => {
+            const cookieKeyConsent: FidesCookie = JSON.parse(
+              decodeURIComponent(cookie!.value)
+            );
+            [PURPOSE_4.id, PURPOSE_9.id, PURPOSE_6.id, PURPOSE_7.id].forEach(
+              (pid) => {
+                expect(cookieKeyConsent.tcf_consent.purpose_consent_preferences)
+                  .property(`${pid}`)
+                  .is.eql(false);
+              }
+            );
+            expect(
+              cookieKeyConsent.tcf_consent
+                .purpose_legitimate_interests_preferences
+            )
+              .property(`${PURPOSE_2.id}`)
+              .is.eql(false);
+            expect(cookieKeyConsent.tcf_consent.special_feature_preferences)
+              .property(`${SPECIAL_FEATURE_1.id}`)
+              .is.eql(false);
+            expect(cookieKeyConsent.tcf_consent.vendor_consent_preferences)
+              .property(`${VENDOR_1.id}`)
+              .is.eql(false);
+            expect(
+              cookieKeyConsent.tcf_consent
+                .vendor_legitimate_interests_preferences
+            ).to.eql({});
+            expect(
+              cookieKeyConsent.tcf_consent.system_consent_preferences
+            ).to.eql({});
+            expect(
+              cookieKeyConsent.tcf_consent
+                .system_legitimate_interests_preferences
+            )
+              .property(`${SYSTEM_1.id}`)
+              .is.eql(false);
+          });
+        });
+      });
+      it("skips saving preferences to API when disable save is set via cookie", () => {
+        cy.getCookie(CONSENT_COOKIE_NAME).should("not.exist");
+        cy.getCookie("fides_disable_save_api").should("not.exist");
+        cy.setCookie("fides_disable_save_api", "true");
+        cy.fixture("consent/experience_tcf.json").then((experience) => {
+          stubConfig({
+            options: {
+              isOverlayEnabled: true,
+              tcfEnabled: true,
+            },
+            experience: experience.items[0],
+          });
+        });
+        cy.waitUntilFidesInitialized().then(() => {
+          cy.get("#fides-modal-link").click();
+          cy.getByTestId("consent-modal").within(() => {
+            cy.get("button").contains("Opt out of all").click();
+            cy.on("fail", (error) => {
+              if (error.message.indexOf("Timed out retrying") !== 0) {
+                throw error;
+              }
+            });
+            cy.wait("@patchPrivacyPreference", {
+              requestTimeout: 100,
+            }).then((xhr) => {
+              assert.isNull(xhr?.response?.body);
+            });
+          });
+        });
+      });
+      it("skips saving preferences to API when disable save is set via query param", () => {
+        cy.getCookie("fides_string").should("not.exist");
+        cy.fixture("consent/experience_tcf.json").then((experience) => {
+          stubConfig(
+            {
+              options: {
+                isOverlayEnabled: true,
+                tcfEnabled: true,
+              },
+              experience: experience.items[0],
+            },
+            null,
+            null,
+            { fides_disable_save_api: true }
+          );
+        });
+        cy.waitUntilFidesInitialized().then(() => {
+          cy.get("#fides-modal-link").click();
+          cy.getByTestId("consent-modal").within(() => {
+            cy.get("button").contains("Opt out of all").click();
+            cy.on("fail", (error) => {
+              if (error.message.indexOf("Timed out retrying") !== 0) {
+                throw error;
+              }
+            });
+            cy.wait("@patchPrivacyPreference", {
+              requestTimeout: 100,
+            }).then((xhr) => {
+              assert.isNull(xhr?.response?.body);
+            });
+          });
+        });
+      });
+      it("skips saving preferences to API when disable save is set via window obj", () => {
+        cy.getCookie("fides_string").should("not.exist");
+        cy.fixture("consent/experience_tcf.json").then((experience) => {
+          stubConfig(
+            {
+              options: {
+                isOverlayEnabled: true,
+                tcfEnabled: true,
+              },
+              experience: experience.items[0],
+            },
+            null,
+            null,
+            null,
+            { fides_disable_save_api: true }
+          );
+        });
+        cy.waitUntilFidesInitialized().then(() => {
+          cy.get("#fides-modal-link").click();
+          cy.getByTestId("consent-modal").within(() => {
+            cy.get("button").contains("Opt out of all").click();
+            cy.on("fail", (error) => {
+              if (error.message.indexOf("Timed out retrying") !== 0) {
+                throw error;
+              }
+            });
+            cy.wait("@patchPrivacyPreference", {
+              requestTimeout: 100,
+            }).then((xhr) => {
+              assert.isNull(xhr?.response?.body);
+            });
+          });
+        });
+      });
     });
   });
-  describe("cmp api", () => {
+  describe("second layer embedded", () => {
+    it("automatically renders the second layer and can render tabs", () => {
+      cy.getCookie(CONSENT_COOKIE_NAME).should("not.exist");
+      cy.fixture("consent/experience_tcf.json").then((experience) => {
+        stubConfig({
+          options: {
+            isOverlayEnabled: true,
+            tcfEnabled: true,
+            fidesEmbed: true,
+          },
+          experience: experience.items[0],
+        });
+      });
+      cy.get("#fides-tab-Purposes");
+      cy.getByTestId("toggle-Purposes").within(() => {
+        cy.get("input").should("be.checked");
+      });
+      cy.getByTestId(`toggle-${PURPOSE_4.name}-consent`).within(() => {
+        cy.get("input").should("be.checked");
+      });
+      cy.getByTestId(`toggle-${PURPOSE_9.name}-consent`).within(() => {
+        cy.get("input").should("be.checked");
+      });
+      cy.getByTestId(`toggle-${PURPOSE_2.name}`).within(() => {
+        cy.get("input").should("be.checked");
+      });
+      cy.get(".fides-notice-toggle-header").contains("Special purposes");
+      cy.get(".fides-notice-toggle-title").contains(SPECIAL_PURPOSE_1.name);
+      cy.getByTestId("toggle-Special purposes").should("not.exist");
+      cy.getByTestId(`toggle-${SPECIAL_PURPOSE_1.name}`).should("not.exist");
+      cy.get("#fides-tab-Features").click();
+      cy.get(".fides-notice-toggle-header").contains("Features");
+      cy.get(".fides-notice-toggle-title").contains(FEATURE_1.name);
+      cy.get(".fides-notice-toggle-title").contains(FEATURE_2.name);
+      cy.getByTestId(`toggle-${FEATURE_1.name}`).should("not.exist");
+      cy.getByTestId(`toggle-${FEATURE_2.name}`).should("not.exist");
+      cy.getByTestId(`toggle-${SPECIAL_FEATURE_1.name}`).within(() => {
+        cy.get("input").should("not.be.checked");
+      });
+      cy.get("#fides-tab-Vendors").click();
+      cy.getByTestId(`toggle-${SYSTEM_1.name}`).within(() => {
+        cy.get("input").should("be.checked");
+      });
+    });
+    it("can opt in to some and opt out of others", () => {
+      cy.getCookie(CONSENT_COOKIE_NAME).should("not.exist");
+      cy.fixture("consent/experience_tcf.json").then((experience) => {
+        stubConfig({
+          options: {
+            isOverlayEnabled: true,
+            tcfEnabled: true,
+            fidesEmbed: true,
+          },
+          experience: experience.items[0],
+        });
+      });
+      cy.getByTestId("consent-modal").within(() => {
+        cy.getByTestId(`toggle-${PURPOSE_4.name}-consent`).click();
+        cy.get("#fides-tab-Features").click();
+        cy.getByTestId(`toggle-${SPECIAL_FEATURE_1.name}`).click();
+        cy.get("#fides-tab-Vendors").click();
+        cy.getByTestId(`toggle-${SYSTEM_1.name}`).click();
+        cy.get("button").contains("Save").click();
+        cy.wait("@patchPrivacyPreference").then((interception) => {
+          const { body } = interception.request;
+          expect(body.purpose_consent_preferences).to.eql([
+            { id: PURPOSE_4.id, preference: "opt_out" },
+            { id: PURPOSE_6.id, preference: "opt_in" },
+            { id: PURPOSE_7.id, preference: "opt_in" },
+            { id: PURPOSE_9.id, preference: "opt_in" },
+          ]);
+          expect(body.purpose_legitimate_interests_preferences).to.eql([
+            { id: PURPOSE_2.id, preference: "opt_in" },
+          ]);
+          expect(body.special_purpose_preferences).to.eql(undefined);
+          expect(body.feature_preferences).to.eql(undefined);
+          expect(body.special_feature_preferences).to.eql([
+            { id: SPECIAL_FEATURE_1.id, preference: "opt_in" },
+          ]);
+          expect(body.vendor_consent_preferences).to.eql([
+            { id: VENDOR_1.id, preference: "opt_out" },
+          ]);
+          expect(body.vendor_legitimate_interests_preferences).to.eql([]);
+          expect(body.system_legitimate_interests_preferences).to.eql([
+            { id: SYSTEM_1.id, preference: "opt_out" },
+          ]);
+          expect(body.system_consent_preferences).to.eql([]);
+        });
+      });
+      cy.getByTestId("consent-modal").should("exist");
+      cy.getCookie(CONSENT_COOKIE_NAME).then((cookie) => {
+        const cookieKeyConsent: FidesCookie = JSON.parse(
+          decodeURIComponent(cookie!.value)
+        );
+        [PURPOSE_9.id, PURPOSE_6.id, PURPOSE_7.id].forEach((pid) => {
+          expect(cookieKeyConsent.tcf_consent.purpose_consent_preferences)
+            .property(`${pid}`)
+            .is.eql(true);
+        });
+        expect(
+          cookieKeyConsent.tcf_consent.purpose_legitimate_interests_preferences
+        )
+          .property(`${PURPOSE_2.id}`)
+          .is.eql(true);
+        expect(cookieKeyConsent.tcf_consent.purpose_consent_preferences)
+          .property(`${PURPOSE_4.id}`)
+          .is.eql(false);
+        expect(cookieKeyConsent.tcf_consent.special_feature_preferences)
+          .property(`${SPECIAL_FEATURE_1.id}`)
+          .is.eql(true);
+        expect(cookieKeyConsent.tcf_consent.vendor_consent_preferences)
+          .property(`${VENDOR_1.id}`)
+          .is.eql(false);
+        expect(
+          cookieKeyConsent.tcf_consent.vendor_legitimate_interests_preferences
+        ).to.eql({});
+        expect(
+          cookieKeyConsent.tcf_consent.system_legitimate_interests_preferences
+        )
+          .property(`${SYSTEM_1.id}`)
+          .is.eql(false);
+        expect(cookieKeyConsent.tcf_consent.system_consent_preferences).to.eql(
+          {}
+        );
+      });
+    });
+    it("automatically renders the second layer when fidesEmbed is set via cookie", () => {
+      cy.getCookie(CONSENT_COOKIE_NAME).should("not.exist");
+      cy.getCookie("fides_embed").should("not.exist");
+      cy.setCookie("fides_embed", "true");
+      cy.fixture("consent/experience_tcf.json").then((experience) => {
+        stubConfig({
+          options: {
+            isOverlayEnabled: true,
+            tcfEnabled: true,
+          },
+          experience: experience.items[0],
+        });
+      });
+      cy.get("#fides-tab-Purposes");
+      cy.getByTestId("toggle-Purposes").within(() => {
+        cy.get("input").should("be.checked");
+      });
+      cy.get("#fides-tab-Vendors").click();
+      cy.getByTestId(`toggle-${SYSTEM_1.name}`).within(() => {
+        cy.get("input").should("be.checked");
+      });
+    });
+    it("automatically renders the second layer when fidesEmbed is set via query param", () => {
+      cy.getCookie(CONSENT_COOKIE_NAME).should("not.exist");
+      cy.fixture("consent/experience_tcf.json").then((experience) => {
+        stubConfig(
+          {
+            options: {
+              isOverlayEnabled: true,
+              tcfEnabled: true,
+            },
+            experience: experience.items[0],
+          },
+          null,
+          null,
+          { fides_embed: true }
+        );
+      });
+      cy.get("#fides-tab-Purposes");
+      cy.getByTestId("toggle-Purposes").within(() => {
+        cy.get("input").should("be.checked");
+      });
+      cy.get("#fides-tab-Vendors").click();
+      cy.getByTestId(`toggle-${SYSTEM_1.name}`).within(() => {
+        cy.get("input").should("be.checked");
+      });
+    });
+    it("automatically renders the second layer when fidesEmbed is set via window obj", () => {
+      cy.getCookie("fides_string").should("not.exist");
+      cy.getCookie(CONSENT_COOKIE_NAME).should("not.exist");
+      cy.fixture("consent/experience_tcf.json").then((experience) => {
+        stubConfig(
+          {
+            options: {
+              isOverlayEnabled: true,
+              tcfEnabled: true,
+            },
+            experience: experience.items[0],
+          },
+          null,
+          null,
+          null,
+          { fides_embed: true }
+        );
+      });
+      cy.get("#fides-tab-Purposes");
+      cy.getByTestId("toggle-Purposes").within(() => {
+        cy.get("input").should("be.checked");
+      });
+      cy.get("#fides-tab-Vendors").click();
+      cy.getByTestId(`toggle-${SYSTEM_1.name}`).within(() => {
+        cy.get("input").should("be.checked");
+      });
+    });
+  });
+  describe("CMP API", () => {
     beforeEach(() => {
+      cy.getCookie(CONSENT_COOKIE_NAME).should("not.exist");
+      cy.fixture("consent/experience_tcf.json").then((experience) => {
+        stubConfig({
+          options: {
+            isOverlayEnabled: true,
+            tcfEnabled: true,
+          },
+          experience: experience.items[0],
+        });
+      });
       cy.window().then((win) => {
         win.__tcfapi("addEventListener", 2, cy.stub().as("TCFEvent"));
       });
       cy.get("#fides-modal-link").click();
     });
     it("can receive a cmpuishown event", () => {
       cy.get("@TCFEvent")
         .its("firstCall.args")
         .then(([tcData, success]) => {
           expect(success).to.eql(true);
@@ -641,32 +1137,34 @@
               1: false,
             });
             expect(tcData.vendor.consents).to.eql({
               1: false,
               [VENDOR_1.id]: true,
             });
             expect(tcData.vendor.legitimateInterests).to.eql({});
           });
       });
       it("can handle inappropriate legint purposes", () => {
+        cy.getCookie(CONSENT_COOKIE_NAME).should("not.exist");
         cy.fixture("consent/experience_tcf.json").then((payload) => {
           const experience: PrivacyExperience = payload.items[0];
           const purpose4 = experience.tcf_purpose_consents?.find(
             (p) => p.id === 4
           )!;
           experience.tcf_purpose_legitimate_interests?.push(purpose4);
           const vendor = experience.tcf_purpose_consents![0];
           experience.tcf_vendor_legitimate_interests?.push({
             ...vendor,
             id: "test",
             purpose_legitimate_interests: [{ id: 4, name: purpose4.name }],
           });
+          experience.tcf_vendor_relationships?.push({ ...vendor, id: "test" });
           stubConfig({
             options: {
               isOverlayEnabled: true,
               tcfEnabled: true,
             },
             experience,
           });
         });
         cy.window().then((win) => {
           win.__tcfapi("addEventListener", 2, cy.stub().as("TCFEvent2"));
@@ -697,62 +1195,87 @@
             });
             expect(tcData.vendor.consents).to.eql({
               1: false,
               [VENDOR_1.id]: true,
             });
             expect(tcData.vendor.legitimateInterests).to.eql({});
           });
       });
     });
   });
-  describe("cookie interactions", () => {
-    it("can initialize preferences from a cookie", () => {
-      /**
-       * The default from the fixture is that
-       *   - all purposes are opted in
-       *   - all special purposes are opted in
-       *   - feature 1 is opted out, feature 2 has no preference
-       *   - all vendors are opted in
-       *   - all systems are opted in
-       *
-       * We'll change at least one value from each entity type in the cookie
-       */
+  /**
+   * There are the following potential sources of user preferences:
+   * 1) fides_string override option (via config.options.fidesString)
+   * 2) DEFER: preferences API (via a custom function)
+   * 3) local cookie (via fides_consent cookie)
+   * 4) "prefetched" experience (via config.options.experience)
+   * 5) experience API (via GET /privacy-experience)
+   *
+   * These specs test various combinations of those sources of truth and ensure
+   * that Fides loads the correct preferences in each case.
+   */
+  describe("user preferences overrides", () => {
+    beforeEach(() => {
+      cy.getCookie(CONSENT_COOKIE_NAME).should("not.exist");
+    });
+    /**
+     * Configure a valid fides_consent cookie with previously saved preferences
+     */
+    const setFidesCookie = () => {
       const uuid = "4fbb6edf-34f6-4717-a6f1-541fd1e5d585";
       const CREATED_DATE = "2022-12-24T12:00:00.000Z";
       const UPDATED_DATE = "2022-12-25T12:00:00.000Z";
-      const cookie = {
+      const cookie: FidesCookie = {
         identity: { fides_user_device_id: uuid },
         fides_meta: {
           version: "0.9.0",
           createdAt: CREATED_DATE,
           updatedAt: UPDATED_DATE,
         },
         consent: {},
         tcf_consent: {
           purpose_consent_preferences: {
             [PURPOSE_4.id]: false,
             [PURPOSE_9.id]: true,
           },
           special_feature_preferences: { [SPECIAL_FEATURE_1.id]: true },
           system_legitimate_interests_preferences: { [SYSTEM_1.id]: false },
           vendor_consent_preferences: { [VENDOR_1.id]: true },
         },
+        fides_string: "CPziCYAPziCYAGXABBENATEIAACAAAAAAAAAABEAAAAA.IABE",
       };
       cy.setCookie(CONSENT_COOKIE_NAME, JSON.stringify(cookie));
+    };
+    /**
+     * TEST CASE #1:
+     *  1) fides_string override option (via config.options.fidesString)
+     *  2) DEFER: preferences API (via a custom function)
+     *  3) local cookie (via fides_consent cookie)
+     *  4) "prefetched" experience (via config.options.experience)
+     *  5) experience API (via GET /privacy-experience)
+     *
+     * EXPECTED RESULT: use preferences from local cookie
+     */
+    it("prefers preferences from a cookie when both cookie and experience exist", () => {
+      setFidesCookie();
       cy.fixture("consent/experience_tcf.json").then((experience) => {
         stubConfig({
           options: {
             isOverlayEnabled: true,
             tcfEnabled: true,
+            fidesString: undefined,
           },
           experience: experience.items[0],
         });
+      });
+      cy.window().then((win) => {
+        win.__tcfapi("addEventListener", 2, cy.stub().as("TCFEvent"));
       });
       cy.get("#fides-modal-link").click();
       cy.getByTestId(`toggle-${PURPOSE_4.name}-consent`).within(() => {
         cy.get("input").should("not.be.checked");
       });
       cy.getByTestId(`toggle-${PURPOSE_9.name}-consent`).within(() => {
         cy.get("input").should("be.checked");
       });
       cy.getByTestId(`toggle-${PURPOSE_6.name}-consent`).within(() => {
         cy.get("input").should("not.be.checked");
@@ -761,20 +1284,500 @@
       cy.getByTestId(`toggle-${SPECIAL_FEATURE_1.name}`).within(() => {
         cy.get("input").should("be.checked");
       });
       cy.get("#fides-tab-Vendors").click();
       cy.getByTestId(`toggle-${SYSTEM_1.name}`).within(() => {
         cy.get("input").should("not.be.checked");
       });
       cy.getByTestId(`toggle-${VENDOR_1.name}-consent`).within(() => {
         cy.get("input").should("be.checked");
       });
+      cy.get("@TCFEvent")
+        .its("lastCall.args")
+        .then(([tcData, success]) => {
+          expect(success).to.eql(true);
+          expect(tcData.eventStatus).to.eql("cmpuishown");
+          expect(tcData.purpose.consents).to.eql({
+            [PURPOSE_4.id]: false,
+            [PURPOSE_6.id]: false,
+            [PURPOSE_7.id]: false,
+            2: false,
+            1: false,
+            3: false,
+            5: false,
+            8: false,
+            9: true,
+          });
+          expect(tcData.purpose.legitimateInterests).to.eql({
+            [PURPOSE_2.id]: true,
+            1: false,
+          });
+          expect(tcData.vendor.consents).to.eql({
+            1: false,
+            [VENDOR_1.id]: true,
+          });
+          expect(tcData.vendor.legitimateInterests).to.eql({});
+          expect(tcData.specialFeatureOptins).to.eql({
+            [SPECIAL_FEATURE_1.id]: true,
+          });
+        });
+    });
+    /**
+     * TEST CASE #2:
+     *  1) fides_string override option (via config.options.fidesString)
+     *  2) DEFER: preferences API (via a custom function)
+     *  3) local cookie (via fides_consent cookie)
+     *  4) "prefetched" experience (via config.options.experience)
+     *  5) experience API (via GET /privacy-experience)
+     *
+     * EXPECTED RESULT: ignore all preferences, do not load TCF experience
+     */
+    it("does nothing when cookie exists but no experience is provided (neither prefetch nor API)", () => {
+      setFidesCookie();
+      stubConfig(
+        {
+          options: {
+            isOverlayEnabled: true,
+            tcfEnabled: true,
+            fidesString: undefined,
+          },
+          experience: OVERRIDE.UNDEFINED,
+        },
+        OVERRIDE.UNDEFINED,
+        OVERRIDE.EMPTY
+      );
+      cy.waitUntilFidesInitialized().then(() => {
+        cy.get("#fides-modal-link").should("not.be.visible");
+      });
+    });
+    /**
+     * TEST CASE #3:
+     *  1) fides_string override option (via config.options.fidesString)
+     *  2) DEFER: preferences API (via a custom function)
+     *  3) local cookie (via fides_consent cookie)
+     *  4) "prefetched" experience (via config.options.experience)
+     *  5) experience API (via GET /privacy-experience)
+     *
+     * EXPECTED RESULT: ignore all preferences, do not load TCF experience
+     */
+    it("does nothing when nothing is provided (neither cookie, nor experience, nor fides_string option)", () => {
+      stubConfig(
+        {
+          options: {
+            isOverlayEnabled: true,
+            tcfEnabled: true,
+            fidesString: undefined,
+          },
+          experience: OVERRIDE.UNDEFINED,
+        },
+        OVERRIDE.UNDEFINED,
+        OVERRIDE.EMPTY
+      );
+      cy.waitUntilFidesInitialized().then(() => {
+        cy.get("#fides-modal-link").should("not.be.visible");
+      });
+    });
+    /**
+     * TEST CASE #4:
+     *  1) fides_string override option (via config.options.fidesString)
+     *  2) DEFER: preferences API (via a custom function)
+     *  3) local cookie (via fides_consent cookie)
+     *  4) "prefetched" experience (via config.options.experience)
+     *  5) experience API (via GET /privacy-experience)
+     *
+     * EXPECTED RESULT: use preferences from fides_string option
+     */
+    it("prefers preferences from fides_string option when fides_string, experience, and cookie exist", () => {
+      setFidesCookie();
+      const fidesStringOverride =
+        "CPzevcAPzevcAGXABBENATEIAAIAAAAAAAAAAAAAAAAA.IABE,1~";
+      const expectedTCString = "CPzevcAPzevcAGXABBENATEIAAIAAAAAAAAAAAAAAAAA"; // without disclosed vendors
+      cy.fixture("consent/experience_tcf.json").then((experience) => {
+        stubConfig({
+          options: {
+            isOverlayEnabled: true,
+            tcfEnabled: true,
+            fidesString: fidesStringOverride,
+          },
+          experience: experience.items[0],
+        });
+      });
+      cy.window().then((win) => {
+        win.__tcfapi("addEventListener", 2, cy.stub().as("TCFEvent"));
+      });
+      cy.get("#fides-modal-link").click();
+      cy.getByTestId(`toggle-${PURPOSE_2.name}`).within(() => {
+        cy.get("input").should("be.checked");
+      });
+      cy.getByTestId(`toggle-${PURPOSE_4.name}-consent`).within(() => {
+        cy.get("input").should("not.be.checked");
+      });
+      cy.getByTestId(`toggle-${PURPOSE_6.name}-consent`).within(() => {
+        cy.get("input").should("not.be.checked");
+      });
+      cy.getByTestId(`toggle-${PURPOSE_7.name}-consent`).within(() => {
+        cy.get("input").should("be.checked");
+      });
+      cy.getByTestId(`toggle-${PURPOSE_9.name}-consent`).within(() => {
+        cy.get("input").should("not.be.checked");
+      });
+      cy.get("#fides-tab-Features").click();
+      cy.getByTestId(`toggle-${SPECIAL_FEATURE_1.name}`).within(() => {
+        cy.get("input").should("be.checked");
+      });
+      cy.get("#fides-tab-Vendors").click();
+      cy.getByTestId(`toggle-${SYSTEM_1.name}`).within(() => {
+        cy.get("input").should("be.checked");
+      });
+      cy.getByTestId(`toggle-${VENDOR_1.name}-consent`).within(() => {
+        cy.get("input").should("not.be.checked");
+      });
+      cy.get("@TCFEvent")
+        .its("lastCall.args")
+        .then(([tcData, success]) => {
+          expect(success).to.eql(true);
+          expect(tcData.tcString).to.eql(expectedTCString);
+          expect(tcData.eventStatus).to.eql("cmpuishown");
+          expect(tcData.purpose.consents).to.eql({
+            [PURPOSE_2.id]: false,
+            [PURPOSE_4.id]: false,
+            [PURPOSE_6.id]: false,
+            [PURPOSE_7.id]: true,
+            1: false,
+            2: false,
+            3: false,
+            5: false,
+          });
+          expect(tcData.purpose.legitimateInterests).to.eql({});
+          expect(tcData.vendor.consents).to.eql({});
+          expect(tcData.vendor.legitimateInterests).to.eql({});
+        });
+    });
+    /**
+     * TEST CASE #5:
+     *  1) fides_string override option (via config.options.fidesString)
+     *  2) DEFER: preferences API (via a custom function)
+     *  3) local cookie (via fides_consent cookie)
+     *  4) "prefetched" experience (via config.options.experience)
+     *  5) experience API (via GET /privacy-experience)
+     *
+     * EXPECTED RESULT: use preferences from fides_string option
+     */
+    it("prefers preferences from fides_string option when both fides_string and experience is provided and cookie does not exist", () => {
+      const fidesStringOverride =
+        "CPzevcAPzevcAGXABBENATEIAAIAAAAAAAAAAAAAAAAA.IABE,1~";
+      const expectedTCString = "CPzevcAPzevcAGXABBENATEIAAIAAAAAAAAAAAAAAAAA"; // without disclosed vendors
+      cy.fixture("consent/experience_tcf.json").then((experience) => {
+        stubConfig({
+          options: {
+            isOverlayEnabled: true,
+            tcfEnabled: true,
+            fidesString: fidesStringOverride,
+          },
+          experience: experience.items[0],
+        });
+      });
+      cy.window().then((win) => {
+        win.__tcfapi("addEventListener", 2, cy.stub().as("TCFEvent"));
+      });
+      cy.get("#fides-modal-link").click();
+      cy.getByTestId(`toggle-${PURPOSE_2.name}`).within(() => {
+        cy.get("input").should("be.checked");
+      });
+      cy.getByTestId(`toggle-${PURPOSE_4.name}-consent`).within(() => {
+        cy.get("input").should("not.be.checked");
+      });
+      cy.getByTestId(`toggle-${PURPOSE_6.name}-consent`).within(() => {
+        cy.get("input").should("not.be.checked");
+      });
+      cy.getByTestId(`toggle-${PURPOSE_7.name}-consent`).within(() => {
+        cy.get("input").should("be.checked");
+      });
+      cy.getByTestId(`toggle-${PURPOSE_9.name}-consent`).within(() => {
+        cy.get("input").should("not.be.checked");
+      });
+      cy.get("#fides-tab-Features").click();
+      cy.getByTestId(`toggle-${SPECIAL_FEATURE_1.name}`).within(() => {
+        cy.get("input").should("be.checked");
+      });
+      cy.get("#fides-tab-Vendors").click();
+      cy.getByTestId(`toggle-${SYSTEM_1.name}`).within(() => {
+        cy.get("input").should("be.checked");
+      });
+      cy.getByTestId(`toggle-${VENDOR_1.name}-consent`).within(() => {
+        cy.get("input").should("not.be.checked");
+      });
+      cy.get("@TCFEvent")
+        .its("lastCall.args")
+        .then(([tcData, success]) => {
+          expect(success).to.eql(true);
+          expect(tcData.tcString).to.eql(expectedTCString);
+          expect(tcData.eventStatus).to.eql("cmpuishown");
+          expect(tcData.purpose.consents).to.eql({
+            [PURPOSE_2.id]: false,
+            [PURPOSE_4.id]: false,
+            [PURPOSE_6.id]: false,
+            [PURPOSE_7.id]: true,
+            1: false,
+            2: false,
+            3: false,
+            5: false,
+          });
+          expect(tcData.purpose.legitimateInterests).to.eql({});
+          expect(tcData.vendor.consents).to.eql({});
+          expect(tcData.vendor.legitimateInterests).to.eql({});
+        });
+    });
+    /**
+     * TEST CASE #6:
+     *  1) fides_string override option (via config.options.fidesString)
+     *  2) DEFER: preferences API (via a custom function)
+     *  3) local cookie (via fides_consent cookie)
+     *  4) "prefetched" experience (via config.options.experience)
+     *  5) experience API (via GET /privacy-experience)
+     *
+     * EXPECTED RESULT: ignore all preferences, do not load TCF experience
+     */
+    it("does nothing when fides_string option when both fides_string option and cookie exist but no experience exists (neither prefetch nor API)", () => {
+      const fidesStringOverride =
+        "CPzevcAPzevcAGXABBENATEIAAIAAAAAAAAAAAAAAAAA.IABE,1~";
+      setFidesCookie();
+      stubConfig(
+        {
+          options: {
+            isOverlayEnabled: true,
+            tcfEnabled: true,
+            fidesString: fidesStringOverride,
+          },
+          experience: OVERRIDE.UNDEFINED,
+        },
+        OVERRIDE.UNDEFINED,
+        OVERRIDE.EMPTY // return no experience
+      );
+      cy.waitUntilFidesInitialized().then(() => {
+        cy.get("#fides-modal-link").should("not.be.visible");
+      });
+    });
+    /**
+     * TEST CASE #7:
+     *  1) fides_string override option (via config.options.fidesString)
+     *  2) DEFER: preferences API (via a custom function)
+     *  3) local cookie (via fides_consent cookie)
+     *  4) "prefetched" experience (via config.options.experience)
+     *  5) experience API (via GET /privacy-experience)
+     *
+     * EXPECTED RESULT: use preferences from fides_string option
+     */
+    it("prefers preferences from fides_string option when both fides_string option and cookie exist and experience is fetched from API", () => {
+      const fidesStringOverride =
+        "CPzevcAPzevcAGXABBENATEIAAIAAAAAAAAAAAAAAAAA.IABE,1~";
+      const expectedTCString = "CPzevcAPzevcAGXABBENATEIAAIAAAAAAAAAAAAAAAAA"; // without disclosed vendors
+      setFidesCookie();
+      cy.fixture("consent/experience_tcf.json").then((experience) => {
+        cy.fixture("consent/geolocation_tcf.json").then((geo) => {
+          stubConfig(
+            {
+              options: {
+                isOverlayEnabled: true,
+                tcfEnabled: true,
+                fidesString: fidesStringOverride,
+              },
+              experience: OVERRIDE.UNDEFINED,
+            },
+            geo,
+            experience
+          );
+        });
+      });
+      cy.waitUntilFidesInitialized().then(() => {
+        cy.window().then((win) => {
+          win.__tcfapi("addEventListener", 2, cy.stub().as("TCFEvent"));
+        });
+      });
+      cy.get("#fides-modal-link").click();
+      cy.getByTestId(`toggle-${PURPOSE_2.name}`).within(() => {
+        cy.get("input").should("be.checked");
+      });
+      cy.getByTestId(`toggle-${PURPOSE_4.name}-consent`).within(() => {
+        cy.get("input").should("not.be.checked");
+      });
+      cy.getByTestId(`toggle-${PURPOSE_6.name}-consent`).within(() => {
+        cy.get("input").should("not.be.checked");
+      });
+      cy.getByTestId(`toggle-${PURPOSE_7.name}-consent`).within(() => {
+        cy.get("input").should("be.checked");
+      });
+      cy.getByTestId(`toggle-${PURPOSE_9.name}-consent`).within(() => {
+        cy.get("input").should("not.be.checked");
+      });
+      cy.get("#fides-tab-Features").click();
+      cy.getByTestId(`toggle-${SPECIAL_FEATURE_1.name}`).within(() => {
+        cy.get("input").should("be.checked");
+      });
+      cy.get("#fides-tab-Vendors").click();
+      cy.getByTestId(`toggle-${SYSTEM_1.name}`).within(() => {
+        cy.get("input").should("be.checked");
+      });
+      cy.getByTestId(`toggle-${VENDOR_1.name}-consent`).within(() => {
+        cy.get("input").should("not.be.checked");
+      });
+      cy.get("@TCFEvent")
+        .its("lastCall.args")
+        .then(([tcData, success]) => {
+          expect(success).to.eql(true);
+          expect(tcData.tcString).to.eql(expectedTCString);
+          expect(tcData.eventStatus).to.eql("cmpuishown");
+          expect(tcData.purpose.consents).to.eql({
+            [PURPOSE_2.id]: false,
+            [PURPOSE_4.id]: false,
+            [PURPOSE_6.id]: false,
+            [PURPOSE_7.id]: true,
+            1: false,
+            2: false,
+            3: false,
+            5: false,
+          });
+          expect(tcData.purpose.legitimateInterests).to.eql({});
+          expect(tcData.vendor.consents).to.eql({});
+          expect(tcData.vendor.legitimateInterests).to.eql({});
+        });
+    });
+  });
+  describe("fides_string override options", () => {
+    it("uses fides_string when set via cookie", () => {
+      const fidesStringOverride =
+        "CPzevcAPzevcAGXABBENATEIAAIAAAAAAAAAAAAAAAAA.IABE,1~";
+      const expectedTCString = "CPzevcAPzevcAGXABBENATEIAAIAAAAAAAAAAAAAAAAA"; // without disclosed vendors
+      cy.getCookie("fides_string").should("not.exist");
+      cy.setCookie("fides_string", fidesStringOverride);
+      cy.fixture("consent/experience_tcf.json").then((experience) => {
+        stubConfig({
+          options: {
+            isOverlayEnabled: true,
+            tcfEnabled: true,
+          },
+          experience: experience.items[0],
+        });
+      });
+      cy.window().then((win) => {
+        win.__tcfapi("addEventListener", 2, cy.stub().as("TCFEvent"));
+      });
+      cy.get("#fides-modal-link").click();
+      cy.get("@TCFEvent")
+        .its("lastCall.args")
+        .then(([tcData, success]) => {
+          expect(success).to.eql(true);
+          expect(tcData.tcString).to.eql(expectedTCString);
+          expect(tcData.eventStatus).to.eql("cmpuishown");
+          expect(tcData.purpose.consents).to.eql({
+            [PURPOSE_2.id]: false,
+            [PURPOSE_4.id]: false,
+            [PURPOSE_6.id]: false,
+            [PURPOSE_7.id]: true,
+            1: false,
+            2: false,
+            3: false,
+            5: false,
+          });
+          expect(tcData.purpose.legitimateInterests).to.eql({});
+          expect(tcData.vendor.consents).to.eql({});
+          expect(tcData.vendor.legitimateInterests).to.eql({});
+        });
+    });
+    it("uses fides_string when set via query param", () => {
+      const fidesStringOverride =
+        "CPzevcAPzevcAGXABBENATEIAAIAAAAAAAAAAAAAAAAA.IABE,1~";
+      const expectedTCString = "CPzevcAPzevcAGXABBENATEIAAIAAAAAAAAAAAAAAAAA"; // without disclosed vendors
+      cy.getCookie("fides_string").should("not.exist");
+      cy.fixture("consent/experience_tcf.json").then((experience) => {
+        stubConfig(
+          {
+            options: {
+              isOverlayEnabled: true,
+              tcfEnabled: true,
+            },
+            experience: experience.items[0],
+          },
+          null,
+          null,
+          { fides_string: fidesStringOverride }
+        );
+      });
+      cy.window().then((win) => {
+        win.__tcfapi("addEventListener", 2, cy.stub().as("TCFEvent"));
+      });
+      cy.get("#fides-modal-link").click();
+      cy.get("@TCFEvent")
+        .its("lastCall.args")
+        .then(([tcData, success]) => {
+          expect(success).to.eql(true);
+          expect(tcData.tcString).to.eql(expectedTCString);
+          expect(tcData.eventStatus).to.eql("cmpuishown");
+          expect(tcData.purpose.consents).to.eql({
+            [PURPOSE_2.id]: false,
+            [PURPOSE_4.id]: false,
+            [PURPOSE_6.id]: false,
+            [PURPOSE_7.id]: true,
+            1: false,
+            2: false,
+            3: false,
+            5: false,
+          });
+          expect(tcData.purpose.legitimateInterests).to.eql({});
+          expect(tcData.vendor.consents).to.eql({});
+          expect(tcData.vendor.legitimateInterests).to.eql({});
+        });
+    });
+    it("uses fides_string when set via window obj", () => {
+      const fidesStringOverride =
+        "CPzevcAPzevcAGXABBENATEIAAIAAAAAAAAAAAAAAAAA.IABE,1~";
+      const expectedTCString = "CPzevcAPzevcAGXABBENATEIAAIAAAAAAAAAAAAAAAAA"; // without disclosed vendors
+      cy.getCookie("fides_string").should("not.exist");
+      cy.fixture("consent/experience_tcf.json").then((experience) => {
+        stubConfig(
+          {
+            options: {
+              isOverlayEnabled: true,
+              tcfEnabled: true,
+            },
+            experience: experience.items[0],
+          },
+          null,
+          null,
+          null,
+          { fides_string: fidesStringOverride }
+        );
+      });
+      cy.window().then((win) => {
+        win.__tcfapi("addEventListener", 2, cy.stub().as("TCFEvent"));
+      });
+      cy.get("#fides-modal-link").click();
+      cy.get("@TCFEvent")
+        .its("lastCall.args")
+        .then(([tcData, success]) => {
+          expect(success).to.eql(true);
+          expect(tcData.tcString).to.eql(expectedTCString);
+          expect(tcData.eventStatus).to.eql("cmpuishown");
+          expect(tcData.purpose.consents).to.eql({
+            [PURPOSE_2.id]: false,
+            [PURPOSE_4.id]: false,
+            [PURPOSE_6.id]: false,
+            [PURPOSE_7.id]: true,
+            1: false,
+            2: false,
+            3: false,
+            5: false,
+          });
+          expect(tcData.purpose.legitimateInterests).to.eql({});
+          expect(tcData.vendor.consents).to.eql({});
+          expect(tcData.vendor.legitimateInterests).to.eql({});
+        });
     });
   });
   describe("ac string", () => {
     const AC_IDS = [42, 33, 49];
     const acceptAllAcString = `1~${AC_IDS.sort().join(".")}`;
     const rejectAllAcString = "1~";
     beforeEach(() => {
       cy.fixture("consent/experience_tcf.json").then((payload) => {
         const experience = payload.items[0];
         const baseVendor = {
@@ -788,26 +1791,26 @@
           current_served: null,
           outdated_served: null,
           purpose_consents: [
             {
               id: 4,
               name: "Use profiles to select personalised advertising",
             },
           ],
         };
         AC_IDS.forEach((id, idx) => {
+          const vendor = { ...baseVendor, id: `gacp.${id}`, name: `AC ${id}` };
           experience.tcf_vendor_consents.push({
-            ...baseVendor,
-            id: `gacp.${id}`,
-            name: `AC ${id}`,
+            ...vendor,
             purpose_consents: idx % 2 === 0 ? [] : baseVendor.purpose_consents,
           });
+          experience.tcf_vendor_relationships.push(vendor);
         });
         stubConfig({
           options: {
             isOverlayEnabled: true,
             tcfEnabled: true,
           },
           experience,
         });
       });
       cy.get("#fides-modal-link").click();
@@ -825,21 +1828,21 @@
         const { body } = interception.request;
         const expected = [
           { id: VENDOR_1.id, preference: "opt_in" },
           ...AC_IDS.map((id) => ({ id: `gacp.${id}`, preference: "opt_in" })),
         ];
         expect(body.vendor_consent_preferences).to.eql(expected);
         cy.getCookie(CONSENT_COOKIE_NAME).then((cookie) => {
           const cookieKeyConsent: FidesCookie = JSON.parse(
             decodeURIComponent(cookie!.value)
           );
-          const { fides_tc_string: tcString } = cookieKeyConsent;
+          const { fides_string: tcString } = cookieKeyConsent;
           const acString = tcString?.split(",")[1];
           expect(acString).to.eql(acceptAllAcString);
         });
       });
     });
     it("can opt out of AC vendors and generate string", () => {
       cy.get("#fides-tab-Vendors").click();
       cy.get("section#fides-panel-Vendors").within(() => {
         cy.get("button").contains("All off").click();
       });
@@ -848,41 +1851,41 @@
         const { body } = interception.request;
         const expected = [
           { id: VENDOR_1.id, preference: "opt_out" },
           ...AC_IDS.map((id) => ({ id: `gacp.${id}`, preference: "opt_out" })),
         ];
         expect(body.vendor_consent_preferences).to.eql(expected);
         cy.getCookie(CONSENT_COOKIE_NAME).then((cookie) => {
           const cookieKeyConsent: FidesCookie = JSON.parse(
             decodeURIComponent(cookie!.value)
           );
-          const { fides_tc_string: tcString } = cookieKeyConsent;
+          const { fides_string: tcString } = cookieKeyConsent;
           const acString = tcString?.split(",")[1];
           expect(acString).to.eql(rejectAllAcString);
         });
       });
     });
     it("can emit FidesEvent with composite string but CMP API without", () => {
       cy.window().then((win) => {
         win.__tcfapi("addEventListener", 2, cy.stub().as("TCFEvent"));
       });
       cy.get("#fides-tab-Vendors").click();
       cy.get("section#fides-panel-Vendors").within(() => {
         cy.get("button").contains("All on").click();
       });
       cy.get("button").contains("Save").click();
       cy.wait("@patchPrivacyPreference");
       cy.get("@FidesUpdated")
         .should("have.been.calledTwice")
-        .its("secondCall.args.0.detail.fides_tc_string")
-        .then((fidesTcString) => {
-          const parts = fidesTcString.split(",");
+        .its("secondCall.args.0.detail.fides_string")
+        .then((fidesString) => {
+          const parts = fidesString.split(",");
           expect(parts.length).to.eql(2);
           expect(parts[1]).to.eql(acceptAllAcString);
         });
       cy.get("@TCFEvent")
         .its("lastCall.args")
         .then(([tcData, success]) => {
           expect(success).to.eql(true);
           expect(tcData.eventStatus).to.eql("useractioncomplete");
           const { tcString } = tcData;
           const parts = tcString.split(",");

--- a/src/fides/api/api/v1/endpoints/privacy_preference_endpoints.py
+++ b/src/fides/api/api/v1/endpoints/privacy_preference_endpoints.py
@@ -16,21 +16,21 @@
     HTTP_422_UNPROCESSABLE_ENTITY,
 )
 from fides.api.api.deps import get_db
 from fides.api.api.v1.endpoints.consent_request_endpoints import (
     _get_consent_request_and_provided_identity,
 )
 from fides.api.api.v1.endpoints.privacy_request_endpoints import (
     create_privacy_request_func,
 )
 from fides.api.common_exceptions import (
-    DecodeTCStringError,
+    DecodeFidesStringError,
     IdentityNotFoundException,
     PrivacyNoticeHistoryNotFound,
     SystemNotFound,
 )
 from fides.api.custom_types import SafeStr
 from fides.api.db.seed import DEFAULT_CONSENT_POLICY
 from fides.api.models.fides_user import FidesUser
 from fides.api.models.privacy_experience import PrivacyExperience
 from fides.api.models.privacy_notice import (
     EnforcementLevel,
@@ -49,46 +49,48 @@
     ProvidedIdentity,
     ProvidedIdentityType,
 )
 from fides.api.oauth.utils import verify_oauth_client
 from fides.api.schemas.privacy_preference import (
     TCF_PREFERENCES_FIELD_MAPPING,
     ConsentOptionCreate,
     ConsentReportingSchema,
     CurrentPrivacyPreferenceReportingSchema,
     CurrentPrivacyPreferenceSchema,
+    FidesStringFidesPreferences,
     PrivacyPreferencesCreate,
     PrivacyPreferencesRequest,
     RecordConsentServedCreate,
     RecordConsentServedRequest,
     SavePrivacyPreferencesResponse,
-    TCStringFidesPreferences,
 )
 from fides.api.schemas.privacy_request import (
     BulkPostPrivacyRequests,
     PrivacyRequestCreate,
     VerificationCode,
 )
 from fides.api.schemas.redis_cache import Identity
 from fides.api.schemas.tcf import (
     TCFFeatureSave,
     TCFPurposeSave,
     TCFSpecialFeatureSave,
     TCFSpecialPurposeSave,
     TCFVendorSave,
 )
 from fides.api.util.api_router import APIRouter
 from fides.api.util.consent_util import (
     get_or_create_fides_user_device_id_provided_identity,
 )
 from fides.api.util.endpoint_utils import fides_limiter, validate_start_and_end_filters
-from fides.api.util.tcf.tc_mobile_data import convert_tc_string_to_mobile_data
+from fides.api.util.tcf.ac_string import decode_ac_string_to_preferences
+from fides.api.util.tcf.fides_string import split_fides_string
+from fides.api.util.tcf.tc_mobile_data import convert_fides_str_to_mobile_data
 from fides.api.util.tcf.tc_string import decode_tc_string_to_preferences
 from fides.api.util.tcf.tcf_experience_contents import (
     TCFExperienceContents,
     get_tcf_contents,
 )
 from fides.common.api.scope_registry import (
     CURRENT_PRIVACY_PREFERENCE_READ,
     PRIVACY_PREFERENCE_HISTORY_READ,
 )
 from fides.common.api.v1.urn_registry import (
@@ -281,21 +283,21 @@
     request: Request,
 ) -> SavePrivacyPreferencesResponse:
     """Saves privacy preferences in the privacy center.
     The ConsentRequest may have been created under an email, phone number, *or* fides user device id.
     Preferences can be saved under both an email *and* a fides user device id, if the email was persisted
     with the ConsentRequest and the fides user device id is passed in with this secondary request.
     Creates historical records for these preferences for record keeping, and also updates current preferences.
     Creates a privacy request to propagate preferences to third party systems where applicable.
     """
     fides_string: Optional[str] = data.fides_string
-    data = update_request_with_decoded_tc_string_fields(data, db)
+    data = update_request_with_decoded_fides_string_fields(data, db)
     verify_privacy_notice_and_historical_records(
         db=db,
         notice_history_list=[
             consent_option.privacy_notice_history_id
             for consent_option in data.preferences
         ],
     )
     verify_previously_served_records(db, data)
     consent_request, provided_identity = _get_consent_request_and_provided_identity(
         db=db,
@@ -315,29 +317,29 @@
         saved_preferences_response: SavePrivacyPreferencesResponse = (
             save_privacy_preferences_for_identities(
                 db=db,
                 consent_request=consent_request,
                 verified_provided_identity=provided_identity_verified,
                 fides_user_provided_identity=fides_user_provided_identity,
                 request=request,
                 original_request_data=data,
             )
         )
-        saved_preferences_response.fides_mobile_data = convert_tc_string_to_mobile_data(
+        saved_preferences_response.fides_mobile_data = convert_fides_str_to_mobile_data(
             fides_string
         )
         return saved_preferences_response
     except (
         IdentityNotFoundException,
         PrivacyNoticeHistoryNotFound,
         SystemNotFound,
-        DecodeTCStringError,
+        DecodeFidesStringError,
     ) as exc:
         raise HTTPException(status_code=400, detail=exc.args[0])
 def persist_tcf_preferences(
     db: Session,
     user_data: Dict[str, str],
     request_data: PrivacyPreferencesRequest,
     saved_preferences_response: SavePrivacyPreferencesResponse,
 ) -> None:
     """Save TCF preferences with respect to individual TCF components if applicable.
     All TCF Preferences have frontend-only enforcement at the moment, so no Privacy Requests
@@ -588,61 +590,73 @@
             name_for_log="privacy notice history",
         )
     for tcf_preference_type, field_name in TCF_PREFERENCES_FIELD_MAPPING.items():
         for preference in getattr(data, tcf_preference_type):
             validate_served_record(
                 preference_record=preference,
                 served_record_field=field_name,
                 saved_preference_field="id",
                 name_for_log=field_name,
             )
-def update_request_with_decoded_tc_string_fields(
+def update_request_with_decoded_fides_string_fields(
     request_body: PrivacyPreferencesRequest, db: Session
 ) -> PrivacyPreferencesRequest:
-    """Update the request body with the decoded values of the TC string if applicable"""
+    """Update the request body with the decoded values of the TC string and AC strings if applicable"""
     if request_body.fides_string:
         tcf_contents: TCFExperienceContents = get_tcf_contents(
             db
         )  # TODO cache this so we're not building each time privacy preference is saved
         try:
-            decoded_preference_request_body: TCStringFidesPreferences = (
-                decode_tc_string_to_preferences(request_body.fides_string, tcf_contents)
-            )
-        except DecodeTCStringError as exc:
+            tc_str, ac_str = split_fides_string(request_body.fides_string)
+            if tc_str and not CONFIG.consent.tcf_enabled:
+                raise DecodeFidesStringError("TCF must be enabled to decode TC String")
+            if ac_str and not CONFIG.consent.ac_enabled:
+                raise DecodeFidesStringError("AC must be enabled to decode AC String")
+            decoded_tc_str_request_body: FidesStringFidesPreferences = (
+                decode_tc_string_to_preferences(tc_str, tcf_contents)
+            )
+            decoded_ac_str_request_body: FidesStringFidesPreferences = (
+                decode_ac_string_to_preferences(ac_str, tcf_contents)
+            )
+            decoded_tc_str_request_body.vendor_consent_preferences = (
+                decoded_tc_str_request_body.vendor_consent_preferences
+                + decoded_ac_str_request_body.vendor_consent_preferences
+            )
+        except DecodeFidesStringError as exc:
             raise HTTPException(status_code=HTTP_400_BAD_REQUEST, detail=exc.args[0])
         request_body.fides_string = None
-        for decoded_tcf_section in decoded_preference_request_body.__fields__:
+        for decoded_tcf_section in decoded_tc_str_request_body.__fields__:
             setattr(
                 request_body,
                 decoded_tcf_section,
-                getattr(decoded_preference_request_body, decoded_tcf_section),
+                getattr(decoded_tc_str_request_body, decoded_tcf_section),
             )
     return request_body
 @router.patch(
     PRIVACY_PREFERENCES,
     status_code=HTTP_200_OK,
     response_model=SavePrivacyPreferencesResponse,
 )
 @fides_limiter.limit(CONFIG.security.public_request_rate_limit)
 def save_privacy_preferences(
     *,
     db: Session = Depends(get_db),
     data: PrivacyPreferencesRequest,
     request: Request,
     response: Response,  # required for rate limiting
 ) -> SavePrivacyPreferencesResponse:
     """Saves privacy preferences with respect to a fides user device id.
     Creates historical records for these preferences for record keeping, and also updates current preferences.
     Creates a privacy request to propagate preferences to third party systems if applicable.
     """
     fides_string: Optional[str] = data.fides_string
-    data = update_request_with_decoded_tc_string_fields(data, db)
+    data = update_request_with_decoded_fides_string_fields(data, db)
     verify_privacy_notice_and_historical_records(
         db=db,
         notice_history_list=[
             consent_option.privacy_notice_history_id
             for consent_option in data.preferences
         ],
     )
     verify_previously_served_records(db, data)
     fides_user_provided_identity: ProvidedIdentity = (
         get_or_create_fides_user_device_id_provided_identity(
@@ -654,29 +668,29 @@
         saved_preferences_response: SavePrivacyPreferencesResponse = (
             save_privacy_preferences_for_identities(
                 db=db,
                 consent_request=None,
                 verified_provided_identity=None,
                 fides_user_provided_identity=fides_user_provided_identity,
                 request=request,
                 original_request_data=data,
             )
         )
-        saved_preferences_response.fides_mobile_data = convert_tc_string_to_mobile_data(
+        saved_preferences_response.fides_mobile_data = convert_fides_str_to_mobile_data(
             fides_string
         )
         return saved_preferences_response
     except (
         IdentityNotFoundException,
         PrivacyNoticeHistoryNotFound,
         SystemNotFound,
-        DecodeTCStringError,
+        DecodeFidesStringError,
     ) as exc:
         raise HTTPException(status_code=400, detail=exc.args[0])
 @router.get(
     CURRENT_PRIVACY_PREFERENCES_REPORT,
     status_code=HTTP_200_OK,
     dependencies=[
         Security(verify_oauth_client, scopes=[CURRENT_PRIVACY_PREFERENCE_READ])
     ],
     response_model=Page[CurrentPrivacyPreferenceReportingSchema],
 )

--- a/src/fides/api/schemas/privacy_preference.py
+++ b/src/fides/api/schemas/privacy_preference.py
@@ -72,28 +72,28 @@
     )
     system_legitimate_interests: Optional[str] = Field(
         title="The System id with a legal basis of legitimate interests that consent was served or saved against. "
         "Used when we don't know what vendor corresponds to the system, so we save preferences against the system directly"
     )
 class ConsentOptionCreate(FidesSchema):
     """Schema for saving the user's preference for a given notice"""
     privacy_notice_history_id: str
     preference: UserConsentPreference
     served_notice_history_id: Optional[str]
-class TCStringFidesPreferences(FidesSchema):
-    """TCF Preferences that can be unpacked from a TC string"""
+class FidesStringFidesPreferences(FidesSchema):
+    """TCF Preferences that can be unpacked from TC and AC Strings"""
     purpose_consent_preferences: conlist(TCFPurposeSave, max_items=200) = []  # type: ignore
     purpose_legitimate_interests_preferences: conlist(TCFPurposeSave, max_items=200) = []  # type: ignore
     vendor_consent_preferences: conlist(TCFVendorSave, max_items=200) = []  # type: ignore
     vendor_legitimate_interests_preferences: conlist(TCFVendorSave, max_items=200) = []  # type: ignore
     special_feature_preferences: conlist(TCFSpecialFeatureSave, max_items=200) = []  # type: ignore
-class PrivacyPreferencesRequest(TCStringFidesPreferences):
+class PrivacyPreferencesRequest(FidesStringFidesPreferences):
     """Request body for creating PrivacyPreferences.
     "preferences" key reserved for saving preferences against a privacy notice.
     New *_preferences fields are used for saving preferences against various tcf components.
     """
     browser_identity: Identity
     code: Optional[SafeStr]
     fides_string: Optional[str] = Field(
         description="If supplied, TC strings and AC strings are decoded and preferences saved for purpose_consent, "
         "purpose_legitimate_interests, vendor_consent, vendor_legitimate_interests, and special_features"
     )
@@ -118,21 +118,21 @@
         """
         def tcf_duplicates_detected(preference_list: List) -> bool:
             identifiers = [preference.id for preference in preference_list]
             return len(identifiers) != len(set(identifiers))
         for field_name in TCF_PREFERENCES_FIELD_MAPPING:
             if tcf_duplicates_detected(values.get(field_name, [])):
                 raise ValueError(
                     f"Duplicate preferences saved against TCF component: '{field_name}'"
                 )
         if values.get("fides_string"):
-            for field in TCStringFidesPreferences.__fields__:
+            for field in FidesStringFidesPreferences.__fields__:
                 if values.get(field):
                     raise ValueError(
                         f"Cannot supply value for '{field}' and 'fides_string' simultaneously when saving privacy preferences."
                     )
         return values
 class PrivacyPreferencesCreate(PrivacyPreferencesRequest):
     """Schema for creating privacy preferences that is supplemented with information
     from the request headers and the experience"""
     anonymized_ip_address: Optional[str]
     experience_config_history_id: Optional[SafeStr]

--- a/src/fides/api/schemas/tcf.py
+++ b/src/fides/api/schemas/tcf.py
@@ -36,54 +36,58 @@
 class TCFSpecialPurposeRecord(NonVendorSection, MappedPurpose):
     @root_validator
     def add_default_preference(cls, values: Dict[str, Any]) -> Dict[str, Any]:
         """Default preference for special purposes is acknowledge"""
         values["default_preference"] = UserConsentPreference.acknowledge
         return values
 class EmbeddedLineItem(FidesSchema):
     """Sparse details for an embedded TCF line item within another TCF component. Read-only."""
     id: int
     name: str
+class EmbeddedPurpose(EmbeddedLineItem):
+    """Sparse details for an embedded purpose beneath a system or vendor section.  Read-only."""
+    retention_period: Optional[str]
 class CommonVendorFields(FidesSchema):
     """Fields shared between the three vendor sections of the TCF Experience"""
     id: str
     has_vendor_id: Optional[bool]
     name: Optional[str]
     description: Optional[str]
 class TCFVendorConsentRecord(UserSpecificConsentDetails, CommonVendorFields):
     """Schema for a TCF Vendor with Consent legal basis"""
-    purpose_consents: List[EmbeddedLineItem] = []
+    purpose_consents: List[EmbeddedPurpose] = []
     @root_validator
     def add_default_preference(cls, values: Dict[str, Any]) -> Dict[str, Any]:
         """Default preference for vendor with legal basis of consent is opt-out"""
         values["default_preference"] = UserConsentPreference.opt_out
         return values
 class TCFVendorLegitimateInterestsRecord(
     UserSpecificConsentDetails, CommonVendorFields
 ):
     """Schema for a TCF Vendor with Legitimate interests legal basis"""
-    purpose_legitimate_interests: List[EmbeddedLineItem] = []
+    purpose_legitimate_interests: List[EmbeddedPurpose] = []
     @root_validator
     def add_default_preference(cls, values: Dict[str, Any]) -> Dict[str, Any]:
         """Default preference for vendor with legal basis of leg interests is opt-in"""
         values["default_preference"] = UserConsentPreference.opt_in
         return values
 class TCFVendorRelationships(CommonVendorFields):
     """Collects the other relationships for a given vendor - no preferences are saved here"""
-    special_purposes: List[EmbeddedLineItem] = []
+    special_purposes: List[EmbeddedPurpose] = []
     features: List[EmbeddedLineItem] = []
     special_features: List[EmbeddedLineItem] = []
     cookie_max_age_seconds: Optional[int]
     uses_cookies: Optional[bool]
     cookie_refresh: Optional[bool]
     uses_non_cookie_access: Optional[bool]
     legitimate_interest_disclosure_url: Optional[AnyUrl]
+    privacy_policy_url: Optional[AnyUrl]
 class TCFFeatureRecord(NonVendorSection, Feature):
     """Schema for a TCF Feature: returned in the TCF Overlay Experience"""
     @root_validator
     def add_default_preference(cls, values: Dict[str, Any]) -> Dict[str, Any]:
         """Default preference for features is acknowledge"""
         values["default_preference"] = UserConsentPreference.acknowledge
         return values
 class TCFSpecialFeatureRecord(NonVendorSection, Feature):
     """Schema for a TCF Special Feature: returned in the TCF Overlay Experience"""
     @root_validator

--- a/src/fides/api/util/tcf/experience_meta.py
+++ b/src/fides/api/util/tcf/experience_meta.py
@@ -1,18 +1,19 @@
 import hashlib
 import json
 from typing import Dict, List
 from pydantic import Extra, root_validator
 from fides.api.models.privacy_notice import UserConsentPreference
 from fides.api.schemas.base_class import FidesSchema
 from fides.api.schemas.privacy_experience import ExperienceMeta
 from fides.api.schemas.tcf import TCMobileData
+from fides.api.util.tcf.fides_string import build_fides_string
 from fides.api.util.tcf.tc_mobile_data import build_tc_data_for_mobile
 from fides.api.util.tcf.tc_model import TCModel, convert_tcf_contents_to_tc_model
 from fides.api.util.tcf.tcf_experience_contents import TCFExperienceContents
 class TCFVersionHash(FidesSchema):
     """Minimal subset of the TCF experience details that capture when consent should be resurfaced"""
     policy_version: int
     purpose_consents: List[int]
     purpose_legitimate_interests: List[int]
     special_feature_optins: List[int]
     vendor_consents: List[int]
@@ -55,15 +56,21 @@
     accept_all_tc_model: TCModel = convert_tcf_contents_to_tc_model(
         tcf_contents, UserConsentPreference.opt_in
     )
     reject_all_tc_model: TCModel = convert_tcf_contents_to_tc_model(
         tcf_contents, UserConsentPreference.opt_out
     )
     accept_all_mobile_data: TCMobileData = build_tc_data_for_mobile(accept_all_tc_model)
     reject_all_mobile_data: TCMobileData = build_tc_data_for_mobile(reject_all_tc_model)
     return ExperienceMeta(
         version_hash=build_tcf_version_hash(tcf_contents),
-        accept_all_fides_string=accept_all_mobile_data.IABTCF_TCString,
-        reject_all_fides_string=reject_all_mobile_data.IABTCF_TCString,
+        accept_all_fides_string=build_fides_string(
+            accept_all_mobile_data.IABTCF_TCString,
+            accept_all_mobile_data.IABTCF_AddtlConsent,
+        ),
+        reject_all_fides_string=build_fides_string(
+            reject_all_mobile_data.IABTCF_TCString,
+            reject_all_mobile_data.IABTCF_AddtlConsent,
+        ),
         accept_all_fides_mobile_data=accept_all_mobile_data,
         reject_all_fides_mobile_data=reject_all_mobile_data,
     ).dict()

--- a/src/fides/api/util/tcf/tc_model.py
+++ b/src/fides/api/util/tcf/tc_model.py
@@ -2,38 +2,45 @@
 from datetime import datetime
 from typing import Dict, List, Optional, Tuple
 from pydantic import Field, NonNegativeInt, PositiveInt, root_validator, validator
 from fides.api.models.privacy_notice import UserConsentPreference
 from fides.api.schemas.base_class import FidesSchema
 from fides.api.schemas.tcf import (
     TCFSpecialFeatureRecord,
     TCFVendorConsentRecord,
     TCFVendorLegitimateInterestsRecord,
 )
-from fides.api.util.tcf.tcf_experience_contents import TCFExperienceContents, load_gvl
+from fides.api.util.tcf.ac_string import build_ac_vendor_consents
+from fides.api.util.tcf.tcf_experience_contents import (
+    AC_PREFIX,
+    GVL_PREFIX,
+    TCFExperienceContents,
+    load_gvl,
+)
 CMP_ID: int = 407
 CMP_VERSION = 1
 CONSENT_SCREEN = 1  # TODO On which 'screen' consent was captured; this is a CMP proprietary number encoded into the TC string
 FORBIDDEN_LEGITIMATE_INTEREST_PURPOSE_IDS = [1, 3, 4, 5, 6]
 gvl: Dict = load_gvl()
-ac_prefix = "gacp."
 def universal_vendor_id_to_gvl_id(universal_vendor_id: str) -> int:
     """Converts a universal gvl vendor id to a vendor id
     For example, converts "gvl.42" to integer 42.
     Throws a ValueError if the id cannot be converted to an integer or if this is an AC Vendor ID
     We store vendor ids as a universal vendor id internally, but need to strip this off when building TC strings.
     """
-    if universal_vendor_id.startswith(ac_prefix):
+    if universal_vendor_id.startswith(AC_PREFIX):
         raise ValueError("Skipping AC Vendor ID")
-    return int(universal_vendor_id.lstrip("gvl."))
+    return int(universal_vendor_id.lstrip(GVL_PREFIX))
 class TCModel(FidesSchema):
-    """Base internal TC schema to store and validate key details from which to later build the TC String"""
+    """Base internal TCF schema to store and validate key details from which to later build the TC String
+    and AC Strings
+    """
     _gvl: Dict = {}
     is_service_specific: bool = Field(
         default=False,
         description="Whether the signals encoded in this TC String were from site-specific storage `true` versus "
         "global consensu.org shared storage `false`. A string intended to be stored in global/shared "
         "scope but the CMP is unable to store due to a user agent not accepting third-party cookies "
         "would be considered site-specific `true`.",
     )
     support_oob: bool = Field(
         default=True,
@@ -148,20 +155,25 @@
         "prior interactions with this device/user agent.",
     )
     vendors_allowed: List = Field(
         default=[],
         description="Signals which vendors the publisher permits to use OOB legal bases.",
     )
     publisher_restrictions: List = Field(
         default=[],
     )
     num_pub_restrictions: int = 0  # Hardcoded here for now
+    ac_vendor_consents: List[int] = Field(
+        default=[],
+        description="A list of Google's Additional Consent Vendors for which the customer has opted in. These "
+        "are consented Google Ad Tech Providers that are not registered with IAB",
+    )
     @validator("publisher_country_code")
     def check_publisher_country_code(cls, publisher_country_code: str) -> str:
         """Validates that a publisher_country_code is an upper-cased two letter string"""
         upper_case_country_code: str = publisher_country_code.upper()
         pattern = r"^[A-Z]{2}$"
         if not re.match(pattern, upper_case_country_code):
             raise ValueError(
                 "publisher_country_code must be a length-2 string of alpha characters"
             )
         return upper_case_country_code
@@ -304,21 +316,21 @@
     """Convert opt_in/acknowledge preferences to True and opt_out/other preferences to False"""
     return preference in [
         UserConsentPreference.opt_in,
         UserConsentPreference.acknowledge,
     ]
 def convert_tcf_contents_to_tc_model(
     tcf_contents: TCFExperienceContents, preference: Optional[UserConsentPreference]
 ) -> TCModel:
     """
     Helper for building a TCModel from TCFExperienceContents that contains the prerequisite information to build
-    an accept-all or reject-all string, depending on the supplied preference.
+    an accept-all or reject-all fides string, with TC and AC sections, depending on the supplied preference.
     """
     if not preference:
         raise Exception(
             "Overall preference must be specified. Only accept or reject-all strings are currently supported."
         )
     consented: bool = transform_user_preference_to_boolean(preference)
     (
         vendor_consents,
         vendor_legitimate_interests,
     ) = _build_vendor_consents_and_legitimate_interests(
@@ -341,12 +353,13 @@
         cmp_version=CMP_VERSION,
         consent_screen=CONSENT_SCREEN,
         vendor_list_version=gvl.get("vendorListVersion"),
         policy_version=gvl.get("tcfPolicyVersion"),
         special_feature_optins=special_feature_opt_ins if consented else [],
         purpose_consents=purpose_consents if consented else [],
         purpose_legitimate_interests=purpose_legitimate_interests if consented else [],
         vendor_consents=vendor_consents if consented else [],
         vendor_legitimate_interests=vendor_legitimate_interests if consented else [],
         vendors_disclosed=_build_vendors_disclosed(tcf_contents),
+        ac_vendor_consents=build_ac_vendor_consents(tcf_contents, preference),
     )
     return tc_model

--- a/src/fides/api/util/tcf/tc_string.py
+++ b/src/fides/api/util/tcf/tc_string.py
@@ -1,29 +1,29 @@
 import base64
 import binascii
 from typing import Any, Dict, List, Optional, Type, Union
 from iab_tcf import ConsentV2, decode_v2  # type: ignore[import]
 from pydantic import Field
-from fides.api.common_exceptions import DecodeTCStringError
+from fides.api.common_exceptions import DecodeFidesStringError
 from fides.api.models.privacy_notice import UserConsentPreference
 from fides.api.schemas.base_class import FidesSchema
-from fides.api.schemas.privacy_preference import TCStringFidesPreferences
+from fides.api.schemas.privacy_preference import FidesStringFidesPreferences
 from fides.api.schemas.tcf import TCFPurposeSave, TCFSpecialFeatureSave, TCFVendorSave
 from fides.api.util.tcf.tc_model import TCModel, convert_tcf_contents_to_tc_model
-from fides.api.util.tcf.tcf_experience_contents import TCFExperienceContents
+from fides.api.util.tcf.tcf_experience_contents import GVL_PREFIX, TCFExperienceContents
 USE_NON_STANDARD_TEXT_BITS = 1
 SPECIAL_FEATURE_BITS = 12
 PURPOSE_CONSENTS_BITS = 24
 PURPOSE_LEGITIMATE_INTERESTS_BITS = 24
 def add_gvl_prefix(vendor_id: str) -> str:
     """Add gvl prefix to create a universal gvl identifier for the given vendor id"""
-    return "gvl." + vendor_id
+    return GVL_PREFIX + vendor_id
 class TCField(FidesSchema):
     """Schema to represent a field within a TC string segment"""
     name: str = Field(description="Field name")
     bits: int = Field(
         description="The number of bits that should be used to represent this value"
     )
     value_override: Optional[Any] = Field(
         description="The value that should be used instead of the field on the TC model"
     )
 def get_bits_for_section(fields: List[TCField], tc_model: TCModel) -> str:
@@ -160,42 +160,44 @@
             fides_preference: FidesPreferenceType = preference_class(
                 id=vendor_id, preference=boolean_to_user_consent_preference(preference)
             )
         else:
             fides_preference = preference_class(
                 id=identifier, preference=boolean_to_user_consent_preference(preference)
             )
         preferences_array.append(fides_preference)
     return preferences_array
 def decode_tc_string_to_preferences(
-    tc_string: str, tcf_contents: TCFExperienceContents
-) -> TCStringFidesPreferences:
+    tc_string: Optional[str], tcf_contents: TCFExperienceContents
+) -> FidesStringFidesPreferences:
     """Method to convert a TC String into a TCStringFidesPreferences object, which is a format from which
     preferences can be saved into the Fides database"""
+    if not tc_string:
+        return FidesStringFidesPreferences()
     try:
         decoded: ConsentV2 = decode_v2(tc_string)
         tc_str_p_c: Dict[int, bool] = decoded.purposes_consent
         tc_str_p_li: Dict[int, bool] = decoded.purposes_legitimate_interests
         tc_str_v_c: Dict[int, bool] = decoded.consented_vendors
         tc_str_v_li: Dict[int, bool] = decoded.interests_vendors
         tc_str_sf: Dict[int, bool] = decoded.special_features_optin
     except (binascii.Error, AttributeError):
-        raise DecodeTCStringError("Invalid base64-encoded TC string")
+        raise DecodeFidesStringError("Invalid base64-encoded TC string")
     all_options_tc_model: TCModel = convert_tcf_contents_to_tc_model(
         tcf_contents, UserConsentPreference.opt_in
     )
     datamap_p_c: List[int] = all_options_tc_model.purpose_consents
     datamap_p_li: List[int] = all_options_tc_model.purpose_legitimate_interests
     datamap_v_c: List[int] = all_options_tc_model.vendor_consents
     datamap_v_li: List[int] = all_options_tc_model.vendor_legitimate_interests
     datamap_sf: List[int] = all_options_tc_model.special_feature_optins
-    return TCStringFidesPreferences(
+    return FidesStringFidesPreferences(
         purpose_consent_preferences=convert_to_fides_preference(
             datamap_p_c, tc_str_p_c, TCFPurposeSave
         ),
         purpose_legitimate_interests_preferences=convert_to_fides_preference(
             datamap_p_li, tc_str_p_li, TCFPurposeSave
         ),
         vendor_consent_preferences=convert_to_fides_preference(
             datamap_v_c, tc_str_v_c, TCFVendorSave
         ),
         vendor_legitimate_interests_preferences=convert_to_fides_preference(

--- a/src/fides/api/util/tcf/tcf_experience_contents.py
+++ b/src/fides/api/util/tcf/tcf_experience_contents.py
@@ -9,45 +9,51 @@
     MAPPED_SPECIAL_PURPOSES,
     data_use_to_purpose,
     feature_id_to_feature_name,
     feature_name_to_feature,
     purpose_to_data_use,
 )
 from fideslang.gvl.models import Feature, Purpose
 from fideslang.models import LegalBasisForProcessingEnum
 from fideslang.validation import FidesKey
 from loguru import logger
+from sqlalchemy import and_, not_, or_
 from sqlalchemy.engine.row import Row  # type:ignore[import]
 from sqlalchemy.orm import Query, Session
+from sqlalchemy.sql.elements import BinaryExpression, BooleanClauseList
 from fides.api.models.sql_models import (  # type:ignore[attr-defined]
     PrivacyDeclaration,
     System,
 )
 from fides.api.schemas.base_class import FidesSchema
 from fides.api.schemas.tcf import (
+    EmbeddedPurpose,
     EmbeddedVendor,
     TCFFeatureRecord,
     TCFPurposeConsentRecord,
     TCFPurposeLegitimateInterestsRecord,
     TCFSpecialFeatureRecord,
     TCFSpecialPurposeRecord,
     TCFVendorConsentRecord,
     TCFVendorLegitimateInterestsRecord,
     TCFVendorRelationships,
 )
+from fides.config import CONFIG
 from fides.config.helpers import load_file
 _gvl: Optional[Dict] = None
 GVL_PATH = join(
     dirname(__file__),
     "../../../data",
     "gvl.json",
 )
+AC_PREFIX = "gacp."
+GVL_PREFIX = "gvl."
 PURPOSE_DATA_USES: List[str] = []
 for purpose in MAPPED_PURPOSES.values():
     PURPOSE_DATA_USES.extend(purpose.data_uses)
 SPECIAL_PURPOSE_DATA_USES: List[str] = []
 for special_purpose in MAPPED_SPECIAL_PURPOSES.values():
     SPECIAL_PURPOSE_DATA_USES.extend(special_purpose.data_uses)
 ALL_GVL_DATA_USES = list(set(PURPOSE_DATA_USES) | set(SPECIAL_PURPOSE_DATA_USES))
 NonVendorSectionType = Union[
     Type[TCFPurposeConsentRecord],
     Type[TCFPurposeLegitimateInterestsRecord],
@@ -70,20 +76,36 @@
 VendorRecord = Union[
     TCFVendorConsentRecord, TCFVendorLegitimateInterestsRecord, TCFVendorRelationships
 ]
 SystemSubSections = Union[
     List[TCFPurposeConsentRecord],
     List[TCFPurposeLegitimateInterestsRecord],
     List[TCFSpecialPurposeRecord],
     List[TCFFeatureRecord],
     List[TCFSpecialFeatureRecord],
 ]
+AC_SYSTEM_NO_PRIVACY_DECL_FILTER: BooleanClauseList = and_(
+    System.vendor_id.startswith(AC_PREFIX), PrivacyDeclaration.id.is_(None)
+)
+NOT_AC_SYSTEM_FILTER: BooleanClauseList = or_(
+    not_(System.vendor_id.startswith(AC_PREFIX)), System.vendor_id.is_(None)
+)
+CONSENT_LEGAL_BASIS_FILTER: BinaryExpression = (
+    PrivacyDeclaration.legal_basis_for_processing == LegalBasisForProcessingEnum.CONSENT
+)
+LEGITIMATE_INTEREST_LEGAL_BASIS_FILTER: BinaryExpression = (
+    PrivacyDeclaration.legal_basis_for_processing
+    == LegalBasisForProcessingEnum.LEGITIMATE_INTEREST
+)
+GVL_DATA_USE_FILTER: BinaryExpression = PrivacyDeclaration.data_use.in_(
+    ALL_GVL_DATA_USES
+)
 class ConsentRecordType(Enum):
     """*ALL* of the relevant consent items that can be served or have preferences saved against.
     Includes two privacy notices fields, and then everything in TCFComponentType
     """
     privacy_notice_id = "privacy_notice_id"
     privacy_notice_history_id = "privacy_notice_history_id"
     purpose_consent = "purpose_consent"
     purpose_legitimate_interests = "purpose_legitimate_interests"
     special_purpose = "special_purpose"
     vendor_consent = "vendor_consent"
@@ -146,39 +168,52 @@
             System.fides_key.label("system_fides_key"),
             System.name.label("system_name"),
             System.description.label("system_description"),
             System.cookie_max_age_seconds.label("system_cookie_max_age_seconds"),
             System.uses_cookies.label("system_uses_cookies"),
             System.cookie_refresh.label("system_cookie_refresh"),
             System.uses_non_cookie_access.label("system_uses_non_cookie_access"),
             System.legitimate_interest_disclosure_url.label(
                 "system_legitimate_interest_disclosure_url"
             ),
+            System.privacy_policy.label("system_privacy_policy"),
             System.vendor_id,
             PrivacyDeclaration.data_use,
             PrivacyDeclaration.legal_basis_for_processing,
             PrivacyDeclaration.features,
-        )
-        .join(PrivacyDeclaration, System.id == PrivacyDeclaration.system_id)
+            PrivacyDeclaration.retention_period,
+        )
+        .outerjoin(PrivacyDeclaration, System.id == PrivacyDeclaration.system_id)
         .filter(
-            PrivacyDeclaration.data_use.in_(ALL_GVL_DATA_USES),
-            PrivacyDeclaration.legal_basis_for_processing.in_(
-                [
-                    LegalBasisForProcessingEnum.CONSENT,
-                    LegalBasisForProcessingEnum.LEGITIMATE_INTEREST,
-                ]
-            ),
+            or_(
+                and_(
+                    GVL_DATA_USE_FILTER,
+                    PrivacyDeclaration.legal_basis_for_processing
+                    == LegalBasisForProcessingEnum.CONSENT,
+                ),
+                and_(
+                    GVL_DATA_USE_FILTER,
+                    PrivacyDeclaration.legal_basis_for_processing
+                    == LegalBasisForProcessingEnum.LEGITIMATE_INTEREST,
+                    NOT_AC_SYSTEM_FILTER,
+                ),
+                AC_SYSTEM_NO_PRIVACY_DECL_FILTER,
+            )
         )
         .order_by(
             PrivacyDeclaration.created_at.desc()
         )  # Order to get repeatable results when collapsing information
     )
+    if not CONFIG.consent.ac_enabled:
+        matching_privacy_declarations = matching_privacy_declarations.filter(
+            NOT_AC_SYSTEM_FILTER
+        )
     return matching_privacy_declarations
 def get_system_identifiers(
     privacy_declaration_row: Row,
 ) -> Tuple[Optional[str], str]:
     """Return the vendor id and overall system identifier (which is either the vendor OR system id)
     If a vendor exists, that's how we'll identify the system, and we'll consolidate information
     from multiple matching systems under that single vendor id.  If we don't have a vendor id, we don't know the
     "type" of system, so we'll surface information under that system id itself.
     """
     system_id: str = privacy_declaration_row["system_id"]
@@ -190,21 +225,21 @@
 ) -> Set[str]:
     """
     Determine the set of relevant uses or features depending on whether we're building a
     purpose or feature section
     """
     if is_purpose_type:
         return (
             {record.data_use} if record.data_use in relevant_uses_or_features else set()
         )
     unique_features: Set[str] = set()
-    for feature_name in record.features:
+    for feature_name in record.features or []:
         if feature_name in relevant_uses_or_features:
             unique_features.add(feature_name)
     return unique_features
 def _add_top_level_record_to_purpose_or_feature_section(
     tcf_component_type: NonVendorSectionType,
     non_vendor_record_map: Dict[int, NonVendorRecord],
     is_purpose_type: bool,
     use_or_feature: str,
 ) -> Optional[NonVendorRecord]:
     """
@@ -219,36 +254,47 @@
         return None
     top_level_tcf_record: NonVendorRecord = tcf_component_type(
         **fideslang_gvl_record.dict()
     )
     if top_level_tcf_record.id not in non_vendor_record_map:
         non_vendor_record_map[top_level_tcf_record.id] = top_level_tcf_record
     return non_vendor_record_map[top_level_tcf_record.id]
 def _embed_purpose_or_feature_under_system(
     embedded_tcf_record: NonVendorRecord,
     system_section: SystemSubSections,
+    retention_period: Optional[str],
+    is_purpose_section: bool,
 ) -> None:
     """
     Embed a second-level TCF purpose/feature under the systems section.
     The systems section is updated in-place.
     """
     embedded_non_vendor_record: Optional[NonVendorRecord] = next(
         (
             tcf_sub_record
             for tcf_sub_record in system_section
             if tcf_sub_record.id == embedded_tcf_record.id
         ),
         None,
     )
     if embedded_non_vendor_record:
         return
-    system_section.append(embedded_tcf_record)  # type: ignore[arg-type]
+    if is_purpose_section:
+        system_section.append(
+            EmbeddedPurpose(  # type: ignore[arg-type]
+                id=embedded_tcf_record.id,
+                name=embedded_tcf_record.name,
+                retention_period=retention_period,
+            )
+        )
+    else:
+        system_section.append(embedded_tcf_record)
 def _embed_system_under_purpose_or_feature(
     top_level_tcf_record: NonVendorRecord,
     non_vendor_record_map: Dict[int, NonVendorRecord],
     privacy_declaration_row: Row,
 ) -> None:
     """
     Embed system/vendor information beneath the corresponding top-level purpose or feature section.
     """
     vendor_id, system_identifier = get_system_identifiers(privacy_declaration_row)
     embedded_system_section: List[EmbeddedVendor] = (
@@ -319,27 +365,56 @@
                     description=privacy_declaration_row.system_description,
                     has_vendor_id=bool(
                         vendor_id
                     ),  # Has_vendor_id will let us separate data between systems and vendors
                 )
             _embed_purpose_or_feature_under_system(
                 embedded_tcf_record=top_level_tcf_record.copy(),
                 system_section=getattr(
                     vendor_map[system_identifier], vendor_subsection_name
                 ),
+                retention_period=privacy_declaration_row.retention_period,
+                is_purpose_section=is_purpose_section,
             )
             _embed_system_under_purpose_or_feature(
                 top_level_tcf_record=top_level_tcf_record,
                 non_vendor_record_map=non_vendor_record_map,
                 privacy_declaration_row=privacy_declaration_row,
             )
+        add_ac_vendor_to_vendor_consent_map(
+            vendor_map=vendor_map,
+            tcf_vendor_component_type=tcf_vendor_component_type,
+            privacy_declaration_row=privacy_declaration_row,
+        )
     return non_vendor_record_map, vendor_map
+def add_ac_vendor_to_vendor_consent_map(
+    vendor_map: Dict[str, VendorRecord],
+    tcf_vendor_component_type: VendorSectionType,
+    privacy_declaration_row: Row,
+) -> None:
+    """
+    Add systems with ac.*-prefixed vendor records to the Vendor Consent section if applicable.
+    FE shows Consent toggle only for AC vendors, and they are not required to have Privacy Declarations
+    """
+    vendor_id, _ = get_system_identifiers(privacy_declaration_row)
+    if not (vendor_id and vendor_id.startswith(AC_PREFIX)):
+        return
+    if not tcf_vendor_component_type == TCFVendorConsentRecord:
+        return
+    if vendor_id in vendor_map:
+        return
+    vendor_map[vendor_id] = TCFVendorConsentRecord(
+        id=vendor_id,
+        name=privacy_declaration_row.system_name,
+        description=privacy_declaration_row.system_description,
+        has_vendor_id=True,
+    )
 def populate_vendor_relationships_basic_attributes(
     vendor_map: Dict[str, TCFVendorRelationships],
     matching_privacy_declarations: Query,
 ) -> Dict[str, TCFVendorRelationships]:
     """Populates TCFVendorRelationships records for all vendors that we're displaying in the overlay.
     Ensures that these TCFVendorRelationships records have the "basic" TCF attributes populated.
     """
     for privacy_declaration_row in matching_privacy_declarations:
         vendor_id, system_identifier = get_system_identifiers(privacy_declaration_row)
         vendor_relationship_record = vendor_map.get(system_identifier)
@@ -360,20 +435,23 @@
             privacy_declaration_row.system_uses_cookies
         )
         vendor_relationship_record.cookie_refresh = (
             privacy_declaration_row.system_cookie_refresh
         )
         vendor_relationship_record.uses_non_cookie_access = (
             privacy_declaration_row.system_uses_non_cookie_access
         )
         vendor_relationship_record.legitimate_interest_disclosure_url = (
             privacy_declaration_row.system_legitimate_interest_disclosure_url
+        )
+        vendor_relationship_record.privacy_policy_url = (
+            privacy_declaration_row.system_privacy_policy
         )
     return vendor_map
 def get_tcf_contents(
     db: Session,
 ) -> TCFExperienceContents:
     """
     Returns the base contents of the TCF overlay.
     Queries for systems/privacy declarations that have a relevant GVL data use and a legal basis of Consent or Legitimate interests,
     and builds the TCF Overlay from these systems and privacy declarations.
     TCF Overlay has Consent Purpose, Legitimate Interest Purpose, Special Purpose, Feature, and Special Feature Sections,
@@ -388,36 +466,37 @@
     (
         purpose_consent_map,
         updated_vendor_consent_map,
     ) = build_purpose_or_feature_section_and_update_vendor_map(
         PURPOSE_DATA_USES,
         tcf_component_type=TCFPurposeConsentRecord,
         tcf_vendor_component_type=TCFVendorConsentRecord,
         vendor_subsection_name="purpose_consents",
         vendor_map=vendor_consent_map,
         matching_privacy_declaration_query=matching_privacy_declarations.filter(
-            PrivacyDeclaration.legal_basis_for_processing
-            == LegalBasisForProcessingEnum.CONSENT
+            or_(
+                CONSENT_LEGAL_BASIS_FILTER,
+                AC_SYSTEM_NO_PRIVACY_DECL_FILTER,
+            )
         ),
     )
     (
         purpose_legitimate_interests_map,
         updated_vendor_legitimate_interests_map,
     ) = build_purpose_or_feature_section_and_update_vendor_map(
         PURPOSE_DATA_USES,
         tcf_component_type=TCFPurposeLegitimateInterestsRecord,
         tcf_vendor_component_type=TCFVendorLegitimateInterestsRecord,
         vendor_subsection_name="purpose_legitimate_interests",
         vendor_map=vendor_legitimate_interests_map,
         matching_privacy_declaration_query=matching_privacy_declarations.filter(
-            PrivacyDeclaration.legal_basis_for_processing
-            == LegalBasisForProcessingEnum.LEGITIMATE_INTEREST
+            LEGITIMATE_INTEREST_LEGAL_BASIS_FILTER
         ),
     )
     (
         special_purpose_map,
         updated_vendor_relationships_map,
     ) = build_purpose_or_feature_section_and_update_vendor_map(
         SPECIAL_PURPOSE_DATA_USES,
         tcf_component_type=TCFSpecialPurposeRecord,
         tcf_vendor_component_type=TCFVendorRelationships,
         vendor_subsection_name="special_purposes",
@@ -552,77 +631,70 @@
     if tcf_field in [
         TCFComponentType.purpose_consent.value,
         TCFComponentType.purpose_legitimate_interests.value,
         TCFComponentType.special_purpose.value,
     ]:
         purpose_data_uses = purpose_to_data_use(
             tcf_value, special_purpose="special" in tcf_field
         )
     if tcf_field == TCFComponentType.purpose_consent.value:
         return systems_that_match_tcf_data_uses(
-            starting_privacy_declarations.filter(
-                PrivacyDeclaration.legal_basis_for_processing
-                == LegalBasisForProcessingEnum.CONSENT
-            ),
+            starting_privacy_declarations.filter(CONSENT_LEGAL_BASIS_FILTER),
             purpose_data_uses,
         )
     if tcf_field == TCFComponentType.purpose_legitimate_interests.value:
         return systems_that_match_tcf_data_uses(
             starting_privacy_declarations.filter(
-                PrivacyDeclaration.legal_basis_for_processing
-                == LegalBasisForProcessingEnum.LEGITIMATE_INTEREST
+                LEGITIMATE_INTEREST_LEGAL_BASIS_FILTER
             ),
             purpose_data_uses,
         )
     if tcf_field == TCFComponentType.special_purpose.value:
         return systems_that_match_tcf_data_uses(
             starting_privacy_declarations, purpose_data_uses
         )
     if tcf_field in [
         TCFComponentType.feature.value,
         TCFComponentType.special_feature.value,
     ]:
         return systems_that_match_tcf_feature(
             starting_privacy_declarations,
             feature_id_to_feature_name(
                 feature_id=tcf_value, special_feature="special" in tcf_field  # type: ignore[arg-type]
             ),
         )
     if tcf_field == TCFComponentType.vendor_consent.value:
         return systems_that_match_vendor_string(
             starting_privacy_declarations.filter(
-                PrivacyDeclaration.legal_basis_for_processing
-                == LegalBasisForProcessingEnum.CONSENT
+                or_(
+                    CONSENT_LEGAL_BASIS_FILTER,
+                    AC_SYSTEM_NO_PRIVACY_DECL_FILTER,
+                )
             ),
             tcf_value,  # type: ignore[arg-type]
         )
     if tcf_field == TCFComponentType.vendor_legitimate_interests.value:
         return systems_that_match_vendor_string(
             starting_privacy_declarations.filter(
-                PrivacyDeclaration.legal_basis_for_processing
-                == LegalBasisForProcessingEnum.LEGITIMATE_INTEREST
+                LEGITIMATE_INTEREST_LEGAL_BASIS_FILTER
             ),
             tcf_value,  # type: ignore[arg-type]
         )
     if tcf_field == TCFComponentType.system_consent.value:
         return systems_that_match_system_id(
-            starting_privacy_declarations.filter(
-                PrivacyDeclaration.legal_basis_for_processing
-                == LegalBasisForProcessingEnum.CONSENT
-            ),
+            starting_privacy_declarations.filter(CONSENT_LEGAL_BASIS_FILTER),
             tcf_value
         )
     if tcf_field == TCFComponentType.system_legitimate_interests.value:
         return systems_that_match_system_id(
             starting_privacy_declarations.filter(
-                PrivacyDeclaration.legal_basis_for_processing
-                == LegalBasisForProcessingEnum.LEGITIMATE_INTEREST
+                LEGITIMATE_INTEREST_LEGAL_BASIS_FILTER
             ),
             tcf_value,  # type: ignore[arg-type]
         )
     return []
 def systems_that_match_tcf_feature(
     matching_privacy_declarations: Query, feature: Optional[str]
 ) -> List[FidesKey]:
     """Check which systems have these data uses directly and are also relevant for TCF.
     This is used for determining relevant systems for TCF features and special features. Unlike
     determining relevant systems for Privacy Notices where we use a hierarchy-type matching,
