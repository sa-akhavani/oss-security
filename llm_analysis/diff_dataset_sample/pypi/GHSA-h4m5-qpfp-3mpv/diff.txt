--- a//dev/null
+++ b/.ci/deploy.linux.sh
@@ -0,0 +1,3 @@
+set -x
+set -e
+bash <(curl -s https://codecov.io/bash)

--- a//dev/null
+++ b/.ci/deploy.osx.sh
@@ -0,0 +1,3 @@
+set -x
+set -e
+echo "Due to a bug in codecov, coverage cannot be deployed for Mac builds."

--- a//dev/null
+++ b/.ci/deps.linux.sh
@@ -0,0 +1,3 @@
+set -x
+set -e
+echo "No dependencies to install for linux."

--- a//dev/null
+++ b/.ci/deps.osx.sh
@@ -0,0 +1,7 @@
+set -e
+set -x
+brew update >/dev/null
+brew outdated pyenv || brew upgrade --quiet pyenv
+pyenv install -ks $PYTHON_VERSION
+pyenv global $PYTHON_VERSION
+python --version

--- a/babel/__init__.py
+++ b/babel/__init__.py
@@ -1,16 +1,16 @@
 """
     babel
     ~~~~~
     Integrated collection of utilities that assist in internationalizing and
     localizing applications.
     This package is basically composed of two major parts:
      * tools to build and work with ``gettext`` message catalogs
      * a Python interface to the CLDR (Common Locale Data Repository), providing
        access to various locale display names, localized number and date
        formatting, etc.
-    :copyright: (c) 2013-2021 by the Babel Team.
+    :copyright: (c) 2013-2020 by the Babel Team.
     :license: BSD, see LICENSE for more details.
 """
 from babel.core import UnknownLocaleError, Locale, default_locale, \
     negotiate_locale, parse_locale, get_locale_identifier
-__version__ = '2.9.1'
+__version__ = '2.9.0'

--- a/babel/core.py
+++ b/babel/core.py
@@ -1,15 +1,15 @@
 """
     babel.core
     ~~~~~~~~~~
     Core locale representation and locale data access.
-    :copyright: (c) 2013-2021 by the Babel Team.
+    :copyright: (c) 2013-2020 by the Babel Team.
     :license: BSD, see LICENSE for more details.
 """
 import os
 from babel import localedata
 from babel._compat import pickle, string_types
 from babel.plural import PluralRule
 __all__ = ['UnknownLocaleError', 'Locale', 'default_locale', 'negotiate_locale',
            'parse_locale']
 _global_data = None
 _default_plural_rule = PluralRule({})

--- a/babel/dates.py
+++ b/babel/dates.py
@@ -1,20 +1,20 @@
 """
     babel.dates
     ~~~~~~~~~~~
     Locale dependent formatting and parsing of dates and times.
     The default locale for the functions in this module is determined by the
     following environment variables, in that order:
      * ``LC_TIME``,
      * ``LC_ALL``, and
      * ``LANG``
-    :copyright: (c) 2013-2021 by the Babel Team.
+    :copyright: (c) 2013-2020 by the Babel Team.
     :license: BSD, see LICENSE for more details.
 """
 from __future__ import division
 import re
 import warnings
 import pytz as _pytz
 from datetime import date, datetime, time, timedelta
 from bisect import bisect_right
 from babel.core import default_locale, get_global, Locale
 from babel.util import UTC, LOCALTZ

--- a/babel/lists.py
+++ b/babel/lists.py
@@ -1,19 +1,19 @@
 """
     babel.lists
     ~~~~~~~~~~~
     Locale dependent formatting of lists.
     The default locale for the functions in this module is determined by the
     following environment variables, in that order:
      * ``LC_ALL``, and
      * ``LANG``
-    :copyright: (c) 2015-2021 by the Babel Team.
+    :copyright: (c) 2015-2020 by the Babel Team.
     :license: BSD, see LICENSE for more details.
 """
 from babel.core import Locale, default_locale
 DEFAULT_LOCALE = default_locale()
 def format_list(lst, style='standard', locale=DEFAULT_LOCALE):
     """
     Format the items in `lst` as a list.
     >>> format_list(['apples', 'oranges', 'pears'], locale='en')
     u'apples, oranges, and pears'
     >>> format_list(['apples', 'oranges', 'pears'], locale='zh')

--- a/babel/localedata.py
+++ b/babel/localedata.py
@@ -1,58 +1,47 @@
 """
     babel.localedata
     ~~~~~~~~~~~~~~~~
     Low-level locale data access.
     :note: The `Locale` class, which uses this module under the hood, provides a
            more convenient interface for accessing the locale data.
-    :copyright: (c) 2013-2021 by the Babel Team.
+    :copyright: (c) 2013-2020 by the Babel Team.
     :license: BSD, see LICENSE for more details.
 """
 import os
-import re
-import sys
 import threading
 from itertools import chain
 from babel._compat import pickle, string_types, abc
 _cache = {}
 _cache_lock = threading.RLock()
 _dirname = os.path.join(os.path.dirname(__file__), 'locale-data')
-_windows_reserved_name_re = re.compile("^(con|prn|aux|nul|com[0-9]|lpt[0-9])$", re.I)
 def normalize_locale(name):
     """Normalize a locale ID by stripping spaces and apply proper casing.
     Returns the normalized locale ID string or `None` if the ID is not
     recognized.
     """
     if not name or not isinstance(name, string_types):
         return None
     name = name.strip().lower()
     for locale_id in chain.from_iterable([_cache, locale_identifiers()]):
         if name == locale_id.lower():
             return locale_id
-def resolve_locale_filename(name):
-    """
-    Resolve a locale identifier to a `.dat` path on disk.
-    """
-    name = os.path.basename(name)
-    if sys.platform == "win32" and _windows_reserved_name_re.match(os.path.splitext(name)[0]):
-        raise ValueError("Name %s is invalid on Windows" % name)
-    return os.path.join(_dirname, '%s.dat' % name)
 def exists(name):
     """Check whether locale data is available for the given locale.
     Returns `True` if it exists, `False` otherwise.
     :param name: the locale identifier string
     """
     if not name or not isinstance(name, string_types):
         return False
     if name in _cache:
         return True
-    file_found = os.path.exists(resolve_locale_filename(name))
+    file_found = os.path.exists(os.path.join(_dirname, '%s.dat' % name))
     return True if file_found else bool(normalize_locale(name))
 def locale_identifiers():
     """Return a list of all locale identifiers for which locale data is
     available.
     This data is cached after the first invocation in `locale_identifiers.cache`.
     Removing the `locale_identifiers.cache` attribute or setting it to `None`
     will cause this function to re-read the list from disk.
     .. versionadded:: 0.8.1
     :return: a list of locale identifiers (strings)
     """
@@ -78,38 +67,37 @@
     >>> d1 = load('en_US')
     >>> d2 = load('en_US')
     >>> d1 is d2
     True
     :param name: the locale identifier string (or "root")
     :param merge_inherited: whether the inherited data should be merged into
                             the data of the requested locale
     :raise `IOError`: if no locale data file is found for the given locale
                       identifer, or one of the locales it inherits from
     """
-    name = os.path.basename(name)
     _cache_lock.acquire()
     try:
         data = _cache.get(name)
         if not data:
             if name == 'root' or not merge_inherited:
                 data = {}
             else:
                 from babel.core import get_global
                 parent = get_global('parent_exceptions').get(name)
                 if not parent:
                     parts = name.split('_')
                     if len(parts) == 1:
                         parent = 'root'
                     else:
                         parent = '_'.join(parts[:-1])
                 data = load(parent).copy()
-            filename = resolve_locale_filename(name)
+            filename = os.path.join(_dirname, '%s.dat' % name)
             with open(filename, 'rb') as fileobj:
                 if name != 'root' and merge_inherited:
                     merge(data, pickle.load(fileobj))
                 else:
                     data = pickle.load(fileobj)
             _cache[name] = data
         return data
     finally:
         _cache_lock.release()
 def merge(dict1, dict2):

--- a/babel/localtime/__init__.py
+++ b/babel/localtime/__init__.py
@@ -1,16 +1,16 @@
 """
     babel.localtime
     ~~~~~~~~~~~~~~~
     Babel specific fork of tzlocal to determine the local timezone
     of the system.
-    :copyright: (c) 2013-2021 by the Babel Team.
+    :copyright: (c) 2013-2020 by the Babel Team.
     :license: BSD, see LICENSE for more details.
 """
 import sys
 import pytz
 import time
 from datetime import timedelta
 from datetime import tzinfo
 from threading import RLock
 if sys.platform == 'win32':
     from babel.localtime._win32 import _get_localzone

--- a/babel/messages/__init__.py
+++ b/babel/messages/__init__.py
@@ -1,8 +1,8 @@
 """
     babel.messages
     ~~~~~~~~~~~~~~
     Support for ``gettext`` message catalogs.
-    :copyright: (c) 2013-2021 by the Babel Team.
+    :copyright: (c) 2013-2020 by the Babel Team.
     :license: BSD, see LICENSE for more details.
 """
 from babel.messages.catalog import *

--- a/babel/messages/catalog.py
+++ b/babel/messages/catalog.py
@@ -1,15 +1,15 @@
 """
     babel.messages.catalog
     ~~~~~~~~~~~~~~~~~~~~~~
     Data structures for message catalogs.
-    :copyright: (c) 2013-2021 by the Babel Team.
+    :copyright: (c) 2013-2020 by the Babel Team.
     :license: BSD, see LICENSE for more details.
 """
 import re
 import time
 from cgi import parse_header
 from collections import OrderedDict
 from datetime import datetime, time as time_
 from difflib import get_close_matches
 from email import message_from_string
 from copy import copy

--- a/babel/messages/checkers.py
+++ b/babel/messages/checkers.py
@@ -1,16 +1,16 @@
 """
     babel.messages.checkers
     ~~~~~~~~~~~~~~~~~~~~~~~
     Various routines that help with validation of translations.
     :since: version 0.9
-    :copyright: (c) 2013-2021 by the Babel Team.
+    :copyright: (c) 2013-2020 by the Babel Team.
     :license: BSD, see LICENSE for more details.
 """
 from babel.messages.catalog import TranslationError, PYTHON_FORMAT
 from babel._compat import string_types, izip
 _string_format_compatibilities = [
     {'i', 'd', 'u'},
     {'x', 'X'},
     {'f', 'F', 'g', 'G'}
 ]
 def num_plurals(catalog, message):

--- a/babel/messages/extract.py
+++ b/babel/messages/extract.py
@@ -1,21 +1,21 @@
 """
     babel.messages.extract
     ~~~~~~~~~~~~~~~~~~~~~~
     Basic infrastructure for extracting localizable messages from source files.
     This module defines an extensible system for collecting localizable message
     strings from a variety of sources. A native extractor for Python source
     files is builtin, extractors for other sources can be added using very
     simple plugins.
     The main entry points into the extraction functionality are the functions
     `extract_from_dir` and `extract_from_file`.
-    :copyright: (c) 2013-2021 by the Babel Team.
+    :copyright: (c) 2013-2020 by the Babel Team.
     :license: BSD, see LICENSE for more details.
 """
 import os
 from os.path import relpath
 import sys
 from tokenize import generate_tokens, COMMENT, NAME, OP, STRING
 from babel.util import parse_encoding, parse_future_flags, pathmatch
 from babel._compat import PY2, text_type
 from textwrap import dedent
 GROUP_NAME = 'babel.extractors'

--- a/babel/messages/frontend.py
+++ b/babel/messages/frontend.py
@@ -1,15 +1,15 @@
 """
     babel.messages.frontend
     ~~~~~~~~~~~~~~~~~~~~~~~
     Frontends for the message extraction functionality.
-    :copyright: (c) 2013-2021 by the Babel Team.
+    :copyright: (c) 2013-2020 by the Babel Team.
     :license: BSD, see LICENSE for more details.
 """
 from __future__ import print_function
 import logging
 import optparse
 import os
 import re
 import shutil
 import sys
 import tempfile

--- a/babel/messages/jslexer.py
+++ b/babel/messages/jslexer.py
@@ -1,16 +1,16 @@
 """
     babel.messages.jslexer
     ~~~~~~~~~~~~~~~~~~~~~~
     A simple JavaScript 1.5 lexer which is used for the JavaScript
     extractor.
-    :copyright: (c) 2013-2021 by the Babel Team.
+    :copyright: (c) 2013-2020 by the Babel Team.
     :license: BSD, see LICENSE for more details.
 """
 from collections import namedtuple
 import re
 from babel._compat import unichr
 operators = sorted([
     '+', '-', '*', '%', '!=', '==', '<', '>', '<=', '>=', '=',
     '+=', '-=', '*=', '%=', '<<', '>>', '>>>', '<<=', '>>=',
     '>>>=', '&', '&=', '|', '|=', '&&', '||', '^', '^=', '(', ')',
     '[', ']', '{', '}', '!', '--', '++', '~', ',', ';', '.', ':'

--- a/babel/messages/mofile.py
+++ b/babel/messages/mofile.py
@@ -1,15 +1,15 @@
 """
     babel.messages.mofile
     ~~~~~~~~~~~~~~~~~~~~~
     Writing of files in the ``gettext`` MO (machine object) format.
-    :copyright: (c) 2013-2021 by the Babel Team.
+    :copyright: (c) 2013-2020 by the Babel Team.
     :license: BSD, see LICENSE for more details.
 """
 import array
 import struct
 from babel.messages.catalog import Catalog, Message
 from babel._compat import range_type, array_tobytes
 LE_MAGIC = 0x950412de
 BE_MAGIC = 0xde120495
 def read_mo(fileobj):
     """Read a binary MO file from the given file-like object and return a

--- a/babel/messages/plurals.py
+++ b/babel/messages/plurals.py
@@ -1,15 +1,15 @@
 """
     babel.messages.plurals
     ~~~~~~~~~~~~~~~~~~~~~~
     Plural form definitions.
-    :copyright: (c) 2013-2021 by the Babel Team.
+    :copyright: (c) 2013-2020 by the Babel Team.
     :license: BSD, see LICENSE for more details.
 """
 from babel.core import default_locale, Locale
 from operator import itemgetter
 LC_CTYPE = default_locale('LC_CTYPE')
 PLURALS = {
     'af': (2, '(n != 1)'),
     'ar': (6, '(n==0 ? 0 : n==1 ? 1 : n==2 ? 2 : n%100>=3 && n%100<=10 ? 3 : n%100>=0 && n%100<=2 ? 4 : 5)'),
     'be': (3, '(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)'),
     'bg': (2, '(n != 1)'),

--- a/babel/messages/pofile.py
+++ b/babel/messages/pofile.py
@@ -1,16 +1,16 @@
 """
     babel.messages.pofile
     ~~~~~~~~~~~~~~~~~~~~~
     Reading and writing of files in the ``gettext`` PO (portable object)
     format.
-    :copyright: (c) 2013-2021 by the Babel Team.
+    :copyright: (c) 2013-2020 by the Babel Team.
     :license: BSD, see LICENSE for more details.
 """
 from __future__ import print_function
 import os
 import re
 from babel.messages.catalog import Catalog, Message
 from babel.util import wraptext
 from babel._compat import text_type, cmp
 def unescape(string):
     r"""Reverse `escape` the given string.

--- a/babel/numbers.py
+++ b/babel/numbers.py
@@ -1,20 +1,20 @@
 """
     babel.numbers
     ~~~~~~~~~~~~~
     Locale dependent formatting and parsing of numeric data.
     The default locale for the functions in this module is determined by the
     following environment variables, in that order:
      * ``LC_NUMERIC``,
      * ``LC_ALL``, and
      * ``LANG``
-    :copyright: (c) 2013-2021 by the Babel Team.
+    :copyright: (c) 2013-2020 by the Babel Team.
     :license: BSD, see LICENSE for more details.
 """
 import re
 from datetime import date as date_, datetime as datetime_
 import warnings
 from babel.core import default_locale, Locale, get_global
 from babel._compat import decimal, string_types
 try:
     long
 except NameError:

--- a/babel/plural.py
+++ b/babel/plural.py
@@ -1,15 +1,15 @@
 """
     babel.numbers
     ~~~~~~~~~~~~~
     CLDR Plural support.  See UTS #35.
-    :copyright: (c) 2013-2021 by the Babel Team.
+    :copyright: (c) 2013-2020 by the Babel Team.
     :license: BSD, see LICENSE for more details.
 """
 import re
 from babel._compat import decimal
 _plural_tags = ('zero', 'one', 'two', 'few', 'many', 'other')
 _fallback_tag = 'other'
 def extract_operands(source):
     """Extract operands from a decimal, a float or an int, according to `CLDR rules`_.
     The result is a 6-tuple (n, i, v, w, f, t), where those symbols are as follows:
     ====== ===============================================================

--- a/babel/support.py
+++ b/babel/support.py
@@ -1,17 +1,17 @@
 """
     babel.support
     ~~~~~~~~~~~~~
     Several classes and functions that help with integrating and using Babel
     in applications.
     .. note: the code in this module is not used by Babel itself
-    :copyright: (c) 2013-2021 by the Babel Team.
+    :copyright: (c) 2013-2020 by the Babel Team.
     :license: BSD, see LICENSE for more details.
 """
 import gettext
 import locale
 from babel.core import Locale
 from babel.dates import format_date, format_datetime, format_time, \
     format_timedelta
 from babel.numbers import format_number, format_decimal, format_currency, \
     format_percent, format_scientific
 from babel._compat import PY2, text_type, text_to_native

--- a/babel/util.py
+++ b/babel/util.py
@@ -1,15 +1,15 @@
 """
     babel.util
     ~~~~~~~~~~
     Various utility classes and functions.
-    :copyright: (c) 2013-2021 by the Babel Team.
+    :copyright: (c) 2013-2020 by the Babel Team.
     :license: BSD, see LICENSE for more details.
 """
 import codecs
 import collections
 from datetime import timedelta, tzinfo
 import os
 import re
 import textwrap
 from babel._compat import izip, imap
 import pytz as _pytz

--- a/docs/conf.py
+++ b/docs/conf.py
@@ -1,23 +1,23 @@
 import sys, os
 sys.path.insert(0, os.path.abspath('..'))
 sys.path.append(os.path.abspath('_themes'))
 extensions = ['sphinx.ext.autodoc',
               'sphinx.ext.intersphinx',
               'sphinx.ext.extlinks']
 templates_path = ['_templates']
 source_suffix = '.rst'
 master_doc = 'index'
 project = u'Babel'
-copyright = u'2021, The Babel Team'
+copyright = u'2020, The Babel Team'
 version = '2.9'
-release = '2.9.1'
+release = '2.9.0'
 exclude_patterns = ['_build']
 pygments_style = 'sphinx'
 html_theme = 'babel'
 html_theme_path = ['_themes']
 html_static_path = ['_static']
 html_sidebars = {
     'index':    ['sidebar-about.html', 'localtoc.html', 'sidebar-links.html',
                  'searchbox.html'],
     '**':       ['sidebar-logo.html', 'localtoc.html', 'relations.html',
                  'searchbox.html']

--- a/scripts/download_import_cldr.py
+++ b/scripts/download_import_cldr.py
@@ -54,26 +54,25 @@
                                % (digest, FILESUM))
         else:
             return True
 def main():
     scripts_path = os.path.dirname(os.path.abspath(__file__))
     repo = os.path.dirname(scripts_path)
     cldr_dl_path = os.path.join(repo, 'cldr')
     cldr_path = os.path.join(repo, 'cldr', os.path.splitext(FILENAME)[0])
     zip_path = os.path.join(cldr_dl_path, FILENAME)
     changed = False
-    show_progress = (False if os.environ.get("BABEL_CLDR_NO_DOWNLOAD_PROGRESS") else sys.stdout.isatty())
     while not is_good_file(zip_path):
         log('Downloading \'%s\'', FILENAME)
         if os.path.isfile(zip_path):
             os.remove(zip_path)
-        urlretrieve(URL, zip_path, (reporthook if show_progress else None))
+        urlretrieve(URL, zip_path, reporthook)
         changed = True
         print()
     common_path = os.path.join(cldr_path, 'common')
     if changed or not os.path.isdir(common_path):
         if os.path.isdir(common_path):
             log('Deleting old CLDR checkout in \'%s\'', cldr_path)
             shutil.rmtree(common_path)
         log('Extracting CLDR to \'%s\'', cldr_path)
         with contextlib.closing(zipfile.ZipFile(zip_path)) as z:
             z.extractall(cldr_path)

--- a/scripts/import_cldr.py
+++ b/scripts/import_cldr.py
@@ -1,16 +1,15 @@
 import collections
 from optparse import OptionParser
 import os
 import re
 import sys
-import logging
 try:
     from xml.etree import cElementTree as ElementTree
 except ImportError:
     from xml.etree import ElementTree
 CHECKOUT_ROOT = os.path.abspath(os.path.join(
     os.path.dirname(__file__),
     '..'
 ))
 BABEL_PACKAGE_ROOT = os.path.join(CHECKOUT_ROOT, "babel")
 sys.path.insert(0, CHECKOUT_ROOT)
@@ -31,21 +30,27 @@
 NAME_RE = re.compile(r"^\w+$")
 TYPE_ATTR_RE = re.compile(r"^\w+\[@type='(.*?)'\]$")
 NAME_MAP = {
     'dateFormats': 'date_formats',
     'dateTimeFormats': 'datetime_formats',
     'eraAbbr': 'abbreviated',
     'eraNames': 'wide',
     'eraNarrow': 'narrow',
     'timeFormats': 'time_formats'
 }
-log = logging.getLogger("import_cldr")
+def log(message, *args):
+    if args:
+        message = message % args
+    sys.stderr.write(message + '\r\n')
+    sys.stderr.flush()
+def error(message, *args):
+    log('ERROR: %s' % message, *args)
 def need_conversion(dst_filename, data_dict, source_filename):
     with open(source_filename, 'rb') as f:
         blob = f.read(4096)
         version_match = re.search(b'version number="\\$Revision: (\\d+)', blob)
         if not version_match:  # CLDR 36.0 was shipped without proper revision numbers
             return True
         version = int(version_match.group(1))
     data_dict['_version'] = version
     if not os.path.isfile(dst_filename):
         return True
@@ -120,30 +125,23 @@
 def main():
     parser = OptionParser(usage='%prog path/to/cldr')
     parser.add_option(
         '-f', '--force', dest='force', action='store_true', default=False,
         help='force import even if destination file seems up to date'
     )
     parser.add_option(
         '-j', '--json', dest='dump_json', action='store_true', default=False,
         help='also export debugging JSON dumps of locale data'
     )
-    parser.add_option(
-        '-q', '--quiet', dest='quiet', action='store_true', default=bool(os.environ.get('BABEL_CLDR_QUIET')),
-        help='quiesce info/warning messages',
-    )
     options, args = parser.parse_args()
     if len(args) != 1:
         parser.error('incorrect number of arguments')
-    logging.basicConfig(
-        level=(logging.ERROR if options.quiet else logging.INFO),
-    )
     return process_data(
         srcdir=args[0],
         destdir=BABEL_PACKAGE_ROOT,
         force=bool(options.force),
         dump_json=bool(options.dump_json)
     )
 def process_data(srcdir, destdir, force=False, dump_json=False):
     sup_filename = os.path.join(srcdir, 'supplemental', 'supplementalData.xml')
     sup = parse(sup_filename)
     global_path = os.path.join(destdir, 'global.dat')
@@ -278,30 +276,27 @@
         elem = tree.find('.//identity/language')
         if elem is not None:
             language = elem.attrib['type']
         territory = None
         elem = tree.find('.//identity/territory')
         if elem is not None:
             territory = elem.attrib['type']
         else:
             territory = '001'  # world
         regions = territory_containment.get(territory, [])
-        log.info(
-            'Processing %s (Language = %s; Territory = %s)',
-            filename, language, territory,
-        )
+        log('Processing %s (Language = %s; Territory = %s)',
+            filename, language, territory)
         locale_id = '_'.join(filter(None, [
             language,
             territory != '001' and territory or None
         ]))
         data['locale_id'] = locale_id
-        data['unsupported_number_systems'] = set()
         if locale_id in plural_rules:
             data['plural_form'] = plural_rules[locale_id]
         if locale_id in ordinal_rules:
             data['ordinal_form'] = ordinal_rules[locale_id]
         if locale_id in day_period_rules:
             data["day_period_rules"] = day_period_rules[locale_id]
         parse_locale_display_names(data, tree)
         parse_list_patterns(data, tree)
         parse_dates(data, tree, sup, regions, territory)
         for calendar in tree.findall('.//calendars/calendar'):
@@ -320,38 +315,38 @@
         parse_decimal_formats(data, tree)
         parse_scientific_formats(data, tree)
         parse_percent_formats(data, tree)
         parse_currency_formats(data, tree)
         parse_currency_unit_patterns(data, tree)
         parse_currency_names(data, tree)
         parse_unit_patterns(data, tree)
         parse_date_fields(data, tree)
         parse_character_order(data, tree)
         parse_measurement_systems(data, tree)
-        unsupported_number_systems_string = ', '.join(sorted(data.pop('unsupported_number_systems')))
-        if unsupported_number_systems_string:
-            log.warning('%s: unsupported number systems were ignored: %s' % (
-                locale_id,
-                unsupported_number_systems_string,
-            ))
         write_datafile(data_filename, data, dump_json=dump_json)
 def _should_skip_number_elem(data, elem):
     """
     Figure out whether the numbering-containing element `elem` is in a currently
     non-supported (i.e. currently non-Latin) numbering system.
-    :param data: The root data element, for stashing the warning.
+    If it is, a warning is raised.
+    :param data: The root data element, for formatting the warning.
     :param elem: Element with `numberSystem` key
     :return: Boolean
     """
     number_system = elem.get('numberSystem', 'latn')
     if number_system != 'latn':
-        data['unsupported_number_systems'].add(number_system)
+        log('%s: Unsupported number system "%s" in <%s numberSystem="%s">' % (
+            data['locale_id'],
+            number_system,
+            elem.tag,
+            number_system,
+        ))
         return True
     return False
 def _should_skip_elem(elem, type=None, dest=None):
     """
     Check whether the given element should be skipped.
     Elements are skipped if they are drafts or alternates of data that already exists in `dest`.
     :param elem: XML element
     :param type: Type string. May be elided if the dest dict is elided.
     :param dest: Destination dict. May be elided to skip the dict check.
     :return: skip boolean
@@ -541,56 +536,56 @@
         for elem in format:
             if elem.tag == 'dateFormatLength':
                 type = elem.attrib.get('type')
                 if _should_skip_elem(elem, type, date_formats):
                     continue
                 try:
                     date_formats[type] = dates.parse_pattern(
                         text_type(elem.findtext('dateFormat/pattern'))
                     )
                 except ValueError as e:
-                    log.error(e)
+                    error(e)
             elif elem.tag == 'alias':
                 date_formats = Alias(_translate_alias(
                     ['date_formats'], elem.attrib['path'])
                 )
 def parse_calendar_time_formats(data, calendar):
     time_formats = data.setdefault('time_formats', {})
     for format in calendar.findall('timeFormats'):
         for elem in format:
             if elem.tag == 'timeFormatLength':
                 type = elem.attrib.get('type')
                 if _should_skip_elem(elem, type, time_formats):
                     continue
                 try:
                     time_formats[type] = dates.parse_pattern(
                         text_type(elem.findtext('timeFormat/pattern'))
                     )
                 except ValueError as e:
-                    log.error(e)
+                    error(e)
             elif elem.tag == 'alias':
                 time_formats = Alias(_translate_alias(
                     ['time_formats'], elem.attrib['path'])
                 )
 def parse_calendar_datetime_skeletons(data, calendar):
     datetime_formats = data.setdefault('datetime_formats', {})
     datetime_skeletons = data.setdefault('datetime_skeletons', {})
     for format in calendar.findall('dateTimeFormats'):
         for elem in format:
             if elem.tag == 'dateTimeFormatLength':
                 type = elem.attrib.get('type')
                 if _should_skip_elem(elem, type, datetime_formats):
                     continue
                 try:
                     datetime_formats[type] = text_type(elem.findtext('dateTimeFormat/pattern'))
                 except ValueError as e:
-                    log.error(e)
+                    error(e)
             elif elem.tag == 'alias':
                 datetime_formats = Alias(_translate_alias(
                     ['datetime_formats'], elem.attrib['path'])
                 )
             elif elem.tag == 'availableFormats':
                 for datetime_skeleton in elem.findall('dateFormatItem'):
                     datetime_skeletons[datetime_skeleton.attrib['id']] = (
                         dates.parse_pattern(text_type(datetime_skeleton.text))
                     )
 def parse_number_symbols(data, tree):
