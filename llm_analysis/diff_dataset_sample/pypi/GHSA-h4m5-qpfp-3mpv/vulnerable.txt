# ====================================================================
# FILE: .ci/deploy.linux.sh
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-3 ---
     1| set -x
     2| set -e
     3| bash <(curl -s https://codecov.io/bash)


# ====================================================================
# FILE: .ci/deploy.osx.sh
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-3 ---
     1| set -x
     2| set -e
     3| echo "Due to a bug in codecov, coverage cannot be deployed for Mac builds."


# ====================================================================
# FILE: .ci/deps.linux.sh
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-3 ---
     1| set -x
     2| set -e
     3| echo "No dependencies to install for linux."


# ====================================================================
# FILE: .ci/deps.osx.sh
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-7 ---
     1| set -e
     2| set -x
     3| brew update >/dev/null
     4| brew outdated pyenv || brew upgrade --quiet pyenv
     5| pyenv install -ks $PYTHON_VERSION
     6| pyenv global $PYTHON_VERSION
     7| python --version


# ====================================================================
# FILE: babel/__init__.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-16 ---
     1| """
     2|     babel
     3|     ~~~~~
     4|     Integrated collection of utilities that assist in internationalizing and
     5|     localizing applications.
     6|     This package is basically composed of two major parts:
     7|      * tools to build and work with ``gettext`` message catalogs
     8|      * a Python interface to the CLDR (Common Locale Data Repository), providing
     9|        access to various locale display names, localized number and date
    10|        formatting, etc.
    11|     :copyright: (c) 2013-2020 by the Babel Team.
    12|     :license: BSD, see LICENSE for more details.
    13| """
    14| from babel.core import UnknownLocaleError, Locale, default_locale, \
    15|     negotiate_locale, parse_locale, get_locale_identifier
    16| __version__ = '2.9.0'


# ====================================================================
# FILE: babel/core.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| """
     2|     babel.core
     3|     ~~~~~~~~~~
     4|     Core locale representation and locale data access.
     5|     :copyright: (c) 2013-2020 by the Babel Team.
     6|     :license: BSD, see LICENSE for more details.
     7| """
     8| import os
     9| from babel import localedata
    10| from babel._compat import pickle, string_types
    11| from babel.plural import PluralRule
    12| __all__ = ['UnknownLocaleError', 'Locale', 'default_locale', 'negotiate_locale',
    13|            'parse_locale']
    14| _global_data = None
    15| _default_plural_rule = PluralRule({})
    16| def _raise_no_data_error():
    17|     raise RuntimeError('The babel data files are not available. '
    18|                        'This usually happens because you are using '
    19|                        'a source checkout from Babel and you did '
    20|                        'not build the data files.  Just make sure '
    21|                        'to run "python setup.py import_cldr" before '
    22|                        'installing the library.')
    23| def get_global(key):
    24|     """Return the dictionary for the given key in the global data.
    25|     The global data is stored in the ``babel/global.dat`` file and contains


# ====================================================================
# FILE: babel/dates.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-30 ---
     1| """
     2|     babel.dates
     3|     ~~~~~~~~~~~
     4|     Locale dependent formatting and parsing of dates and times.
     5|     The default locale for the functions in this module is determined by the
     6|     following environment variables, in that order:
     7|      * ``LC_TIME``,
     8|      * ``LC_ALL``, and
     9|      * ``LANG``
    10|     :copyright: (c) 2013-2020 by the Babel Team.
    11|     :license: BSD, see LICENSE for more details.
    12| """
    13| from __future__ import division
    14| import re
    15| import warnings
    16| import pytz as _pytz
    17| from datetime import date, datetime, time, timedelta
    18| from bisect import bisect_right
    19| from babel.core import default_locale, get_global, Locale
    20| from babel.util import UTC, LOCALTZ
    21| from babel._compat import string_types, integer_types, number_types, PY2
    22| NO_INHERITANCE_MARKER = u'\u2205\u2205\u2205'
    23| LC_TIME = default_locale('LC_TIME')
    24| date_ = date
    25| datetime_ = datetime
    26| time_ = time
    27| def _get_dt_and_tzinfo(dt_or_tzinfo):
    28|     """
    29|     Parse a `dt_or_tzinfo` value into a datetime and a tzinfo.
    30|     See the docs for this function's callers for semantics.


# ====================================================================
# FILE: babel/lists.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| """
     2|     babel.lists
     3|     ~~~~~~~~~~~
     4|     Locale dependent formatting of lists.
     5|     The default locale for the functions in this module is determined by the
     6|     following environment variables, in that order:
     7|      * ``LC_ALL``, and
     8|      * ``LANG``
     9|     :copyright: (c) 2015-2020 by the Babel Team.
    10|     :license: BSD, see LICENSE for more details.
    11| """
    12| from babel.core import Locale, default_locale
    13| DEFAULT_LOCALE = default_locale()
    14| def format_list(lst, style='standard', locale=DEFAULT_LOCALE):
    15|     """
    16|     Format the items in `lst` as a list.
    17|     >>> format_list(['apples', 'oranges', 'pears'], locale='en')
    18|     u'apples, oranges, and pears'
    19|     >>> format_list(['apples', 'oranges', 'pears'], locale='zh')
    20|     u'apples\u3001oranges\u548cpears'
    21|     >>> format_list(['omena', 'peruna', 'aplari'], style='or', locale='fi')
    22|     u'omena, peruna tai aplari'
    23|     These styles are defined, but not all are necessarily available in all locales.
    24|     The following text is verbatim from the Unicode TR35-49 spec [1].
    25|     * standard:
    26|       A typical 'and' list for arbitrary placeholders.
    27|       eg. "January, February, and March"
    28|     * standard-short:
    29|       A short version of a 'and' list, suitable for use with short or abbreviated placeholder values.


# ====================================================================
# FILE: babel/localedata.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-113 ---
     1| """
     2|     babel.localedata
     3|     ~~~~~~~~~~~~~~~~
     4|     Low-level locale data access.
     5|     :note: The `Locale` class, which uses this module under the hood, provides a
     6|            more convenient interface for accessing the locale data.
     7|     :copyright: (c) 2013-2020 by the Babel Team.
     8|     :license: BSD, see LICENSE for more details.
     9| """
    10| import os
    11| import threading
    12| from itertools import chain
    13| from babel._compat import pickle, string_types, abc
    14| _cache = {}
    15| _cache_lock = threading.RLock()
    16| _dirname = os.path.join(os.path.dirname(__file__), 'locale-data')
    17| def normalize_locale(name):
    18|     """Normalize a locale ID by stripping spaces and apply proper casing.
    19|     Returns the normalized locale ID string or `None` if the ID is not
    20|     recognized.
    21|     """
    22|     if not name or not isinstance(name, string_types):
    23|         return None
    24|     name = name.strip().lower()
    25|     for locale_id in chain.from_iterable([_cache, locale_identifiers()]):
    26|         if name == locale_id.lower():
    27|             return locale_id
    28| def exists(name):
    29|     """Check whether locale data is available for the given locale.
    30|     Returns `True` if it exists, `False` otherwise.
    31|     :param name: the locale identifier string
    32|     """
    33|     if not name or not isinstance(name, string_types):
    34|         return False
    35|     if name in _cache:
    36|         return True
    37|     file_found = os.path.exists(os.path.join(_dirname, '%s.dat' % name))
    38|     return True if file_found else bool(normalize_locale(name))
    39| def locale_identifiers():
    40|     """Return a list of all locale identifiers for which locale data is
    41|     available.
    42|     This data is cached after the first invocation in `locale_identifiers.cache`.
    43|     Removing the `locale_identifiers.cache` attribute or setting it to `None`
    44|     will cause this function to re-read the list from disk.
    45|     .. versionadded:: 0.8.1
    46|     :return: a list of locale identifiers (strings)
    47|     """
    48|     data = getattr(locale_identifiers, 'cache', None)
    49|     if data is None:
    50|         locale_identifiers.cache = data = [
    51|             stem
    52|             for stem, extension in
    53|             (os.path.splitext(filename) for filename in os.listdir(_dirname))
    54|             if extension == '.dat' and stem != 'root'
    55|         ]
    56|     return data
    57| def load(name, merge_inherited=True):
    58|     """Load the locale data for the given locale.
    59|     The locale data is a dictionary that contains much of the data defined by
    60|     the Common Locale Data Repository (CLDR). This data is stored as a
    61|     collection of pickle files inside the ``babel`` package.
    62|     >>> d = load('en_US')
    63|     >>> d['languages']['sv']
    64|     u'Swedish'
    65|     Note that the results are cached, and subsequent requests for the same
    66|     locale return the same dictionary:
    67|     >>> d1 = load('en_US')
    68|     >>> d2 = load('en_US')
    69|     >>> d1 is d2
    70|     True
    71|     :param name: the locale identifier string (or "root")
    72|     :param merge_inherited: whether the inherited data should be merged into
    73|                             the data of the requested locale
    74|     :raise `IOError`: if no locale data file is found for the given locale
    75|                       identifer, or one of the locales it inherits from
    76|     """
    77|     _cache_lock.acquire()
    78|     try:
    79|         data = _cache.get(name)
    80|         if not data:
    81|             if name == 'root' or not merge_inherited:
    82|                 data = {}
    83|             else:
    84|                 from babel.core import get_global
    85|                 parent = get_global('parent_exceptions').get(name)
    86|                 if not parent:
    87|                     parts = name.split('_')
    88|                     if len(parts) == 1:
    89|                         parent = 'root'
    90|                     else:
    91|                         parent = '_'.join(parts[:-1])
    92|                 data = load(parent).copy()
    93|             filename = os.path.join(_dirname, '%s.dat' % name)
    94|             with open(filename, 'rb') as fileobj:
    95|                 if name != 'root' and merge_inherited:
    96|                     merge(data, pickle.load(fileobj))
    97|                 else:
    98|                     data = pickle.load(fileobj)
    99|             _cache[name] = data
   100|         return data
   101|     finally:
   102|         _cache_lock.release()
   103| def merge(dict1, dict2):
   104|     """Merge the data from `dict2` into the `dict1` dictionary, making copies
   105|     of nested dictionaries.
   106|     >>> d = {1: 'foo', 3: 'baz'}
   107|     >>> merge(d, {1: 'Foo', 2: 'Bar'})
   108|     >>> sorted(d.items())
   109|     [(1, 'Foo'), (2, 'Bar'), (3, 'baz')]
   110|     :param dict1: the dictionary to merge into
   111|     :param dict2: the dictionary containing the data that should be merged
   112|     """
   113|     for key, val2 in dict2.items():


# ====================================================================
# FILE: babel/localtime/__init__.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| """
     2|     babel.localtime
     3|     ~~~~~~~~~~~~~~~
     4|     Babel specific fork of tzlocal to determine the local timezone
     5|     of the system.
     6|     :copyright: (c) 2013-2020 by the Babel Team.
     7|     :license: BSD, see LICENSE for more details.
     8| """
     9| import sys
    10| import pytz
    11| import time
    12| from datetime import timedelta
    13| from datetime import tzinfo
    14| from threading import RLock
    15| if sys.platform == 'win32':
    16|     from babel.localtime._win32 import _get_localzone
    17| else:
    18|     from babel.localtime._unix import _get_localzone
    19| _cached_tz = None
    20| _cache_lock = RLock()
    21| STDOFFSET = timedelta(seconds=-time.timezone)
    22| if time.daylight:
    23|     DSTOFFSET = timedelta(seconds=-time.altzone)
    24| else:
    25|     DSTOFFSET = STDOFFSET
    26| DSTDIFF = DSTOFFSET - STDOFFSET


# ====================================================================
# FILE: babel/messages/__init__.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-8 ---
     1| """
     2|     babel.messages
     3|     ~~~~~~~~~~~~~~
     4|     Support for ``gettext`` message catalogs.
     5|     :copyright: (c) 2013-2020 by the Babel Team.
     6|     :license: BSD, see LICENSE for more details.
     7| """
     8| from babel.messages.catalog import *


# ====================================================================
# FILE: babel/messages/catalog.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| """
     2|     babel.messages.catalog
     3|     ~~~~~~~~~~~~~~~~~~~~~~
     4|     Data structures for message catalogs.
     5|     :copyright: (c) 2013-2020 by the Babel Team.
     6|     :license: BSD, see LICENSE for more details.
     7| """
     8| import re
     9| import time
    10| from cgi import parse_header
    11| from collections import OrderedDict
    12| from datetime import datetime, time as time_
    13| from difflib import get_close_matches
    14| from email import message_from_string
    15| from copy import copy
    16| from babel import __version__ as VERSION
    17| from babel.core import Locale, UnknownLocaleError
    18| from babel.dates import format_datetime
    19| from babel.messages.plurals import get_plural
    20| from babel.util import distinct, LOCALTZ, FixedOffsetTimezone
    21| from babel._compat import string_types, number_types, PY2, cmp, text_type, force_text
    22| __all__ = ['Message', 'Catalog', 'TranslationError']
    23| PYTHON_FORMAT = re.compile(r'''
    24|     \%
    25|         (?:\(([\w]*)\))?


# ====================================================================
# FILE: babel/messages/checkers.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| """
     2|     babel.messages.checkers
     3|     ~~~~~~~~~~~~~~~~~~~~~~~
     4|     Various routines that help with validation of translations.
     5|     :since: version 0.9
     6|     :copyright: (c) 2013-2020 by the Babel Team.
     7|     :license: BSD, see LICENSE for more details.
     8| """
     9| from babel.messages.catalog import TranslationError, PYTHON_FORMAT
    10| from babel._compat import string_types, izip
    11| _string_format_compatibilities = [
    12|     {'i', 'd', 'u'},
    13|     {'x', 'X'},
    14|     {'f', 'F', 'g', 'G'}
    15| ]
    16| def num_plurals(catalog, message):
    17|     """Verify the number of plurals in the translation."""
    18|     if not message.pluralizable:
    19|         if not isinstance(message.string, string_types):
    20|             raise TranslationError("Found plural forms for non-pluralizable "
    21|                                    "message")
    22|         return
    23|     elif catalog is None:
    24|         return
    25|     msgstrs = message.string
    26|     if not isinstance(msgstrs, (list, tuple)):


# ====================================================================
# FILE: babel/messages/extract.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-31 ---
     1| """
     2|     babel.messages.extract
     3|     ~~~~~~~~~~~~~~~~~~~~~~
     4|     Basic infrastructure for extracting localizable messages from source files.
     5|     This module defines an extensible system for collecting localizable message
     6|     strings from a variety of sources. A native extractor for Python source
     7|     files is builtin, extractors for other sources can be added using very
     8|     simple plugins.
     9|     The main entry points into the extraction functionality are the functions
    10|     `extract_from_dir` and `extract_from_file`.
    11|     :copyright: (c) 2013-2020 by the Babel Team.
    12|     :license: BSD, see LICENSE for more details.
    13| """
    14| import os
    15| from os.path import relpath
    16| import sys
    17| from tokenize import generate_tokens, COMMENT, NAME, OP, STRING
    18| from babel.util import parse_encoding, parse_future_flags, pathmatch
    19| from babel._compat import PY2, text_type
    20| from textwrap import dedent
    21| GROUP_NAME = 'babel.extractors'
    22| DEFAULT_KEYWORDS = {
    23|     '_': None,
    24|     'gettext': None,
    25|     'ngettext': (1, 2),
    26|     'ugettext': None,
    27|     'ungettext': (1, 2),
    28|     'dgettext': (2,),
    29|     'dngettext': (2, 3),
    30|     'N_': None,
    31|     'pgettext': ((1, 'c'), 2),


# ====================================================================
# FILE: babel/messages/frontend.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| """
     2|     babel.messages.frontend
     3|     ~~~~~~~~~~~~~~~~~~~~~~~
     4|     Frontends for the message extraction functionality.
     5|     :copyright: (c) 2013-2020 by the Babel Team.
     6|     :license: BSD, see LICENSE for more details.
     7| """
     8| from __future__ import print_function
     9| import logging
    10| import optparse
    11| import os
    12| import re
    13| import shutil
    14| import sys
    15| import tempfile
    16| from collections import OrderedDict
    17| from datetime import datetime
    18| from locale import getpreferredencoding
    19| from babel import __version__ as VERSION
    20| from babel import Locale, localedata
    21| from babel._compat import StringIO, string_types, text_type, PY2
    22| from babel.core import UnknownLocaleError
    23| from babel.messages.catalog import Catalog
    24| from babel.messages.extract import DEFAULT_KEYWORDS, DEFAULT_MAPPING, check_and_call_extract_file, extract_from_dir
    25| from babel.messages.mofile import write_mo


# ====================================================================
# FILE: babel/messages/jslexer.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| """
     2|     babel.messages.jslexer
     3|     ~~~~~~~~~~~~~~~~~~~~~~
     4|     A simple JavaScript 1.5 lexer which is used for the JavaScript
     5|     extractor.
     6|     :copyright: (c) 2013-2020 by the Babel Team.
     7|     :license: BSD, see LICENSE for more details.
     8| """
     9| from collections import namedtuple
    10| import re
    11| from babel._compat import unichr
    12| operators = sorted([
    13|     '+', '-', '*', '%', '!=', '==', '<', '>', '<=', '>=', '=',
    14|     '+=', '-=', '*=', '%=', '<<', '>>', '>>>', '<<=', '>>=',
    15|     '>>>=', '&', '&=', '|', '|=', '&&', '||', '^', '^=', '(', ')',
    16|     '[', ']', '{', '}', '!', '--', '++', '~', ',', ';', '.', ':'
    17| ], key=len, reverse=True)
    18| escapes = {'b': '\b', 'f': '\f', 'n': '\n', 'r': '\r', 't': '\t'}
    19| name_re = re.compile(r'[\w$_][\w\d$_]*', re.UNICODE)
    20| dotted_name_re = re.compile(r'[\w$_][\w\d$_.]*[\w\d$_.]', re.UNICODE)
    21| division_re = re.compile(r'/=?')
    22| regex_re = re.compile(r'/(?:[^/\\]*(?:\\.[^/\\]*)*)/[a-zA-Z]*', re.DOTALL)
    23| line_re = re.compile(r'(\r\n|\n|\r)')
    24| line_join_re = re.compile(r'\\' + line_re.pattern)
    25| uni_escape_re = re.compile(r'[a-fA-F0-9]{1,4}')
    26| Token = namedtuple('Token', 'type value lineno')


# ====================================================================
# FILE: babel/messages/mofile.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| """
     2|     babel.messages.mofile
     3|     ~~~~~~~~~~~~~~~~~~~~~
     4|     Writing of files in the ``gettext`` MO (machine object) format.
     5|     :copyright: (c) 2013-2020 by the Babel Team.
     6|     :license: BSD, see LICENSE for more details.
     7| """
     8| import array
     9| import struct
    10| from babel.messages.catalog import Catalog, Message
    11| from babel._compat import range_type, array_tobytes
    12| LE_MAGIC = 0x950412de
    13| BE_MAGIC = 0xde120495
    14| def read_mo(fileobj):
    15|     """Read a binary MO file from the given file-like object and return a
    16|     corresponding `Catalog` object.
    17|     :param fileobj: the file-like object to read the MO file from
    18|     :note: The implementation of this function is heavily based on the
    19|            ``GNUTranslations._parse`` method of the ``gettext`` module in the
    20|            standard library.
    21|     """
    22|     catalog = Catalog()
    23|     headers = {}
    24|     filename = getattr(fileobj, 'name', '')
    25|     buf = fileobj.read()


# ====================================================================
# FILE: babel/messages/plurals.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| """
     2|     babel.messages.plurals
     3|     ~~~~~~~~~~~~~~~~~~~~~~
     4|     Plural form definitions.
     5|     :copyright: (c) 2013-2020 by the Babel Team.
     6|     :license: BSD, see LICENSE for more details.
     7| """
     8| from babel.core import default_locale, Locale
     9| from operator import itemgetter
    10| LC_CTYPE = default_locale('LC_CTYPE')
    11| PLURALS = {
    12|     'af': (2, '(n != 1)'),
    13|     'ar': (6, '(n==0 ? 0 : n==1 ? 1 : n==2 ? 2 : n%100>=3 && n%100<=10 ? 3 : n%100>=0 && n%100<=2 ? 4 : 5)'),
    14|     'be': (3, '(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)'),
    15|     'bg': (2, '(n != 1)'),
    16|     'bn': (2, '(n != 1)'),
    17|     'bo': (1, '0'),
    18|     'br': (
    19|         6,
    20|         '(n==1 ? 0 : n%10==1 && n%100!=11 && n%100!=71 && n%100!=91 ? 1 : n%10==2 && n%100!=12 && n%100!=72 && '
    21|         'n%100!=92 ? 2 : (n%10==3 || n%10==4 || n%10==9) && n%100!=13 && n%100!=14 && n%100!=19 && n%100!=73 && '
    22|         'n%100!=74 && n%100!=79 && n%100!=93 && n%100!=94 && n%100!=99 ? 3 : n%1000000==0 ? 4 : 5)'
    23|     ),
    24|     'bs': (3, '(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)'),
    25|     'ca': (2, '(n != 1)'),


# ====================================================================
# FILE: babel/messages/pofile.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| """
     2|     babel.messages.pofile
     3|     ~~~~~~~~~~~~~~~~~~~~~
     4|     Reading and writing of files in the ``gettext`` PO (portable object)
     5|     format.
     6|     :copyright: (c) 2013-2020 by the Babel Team.
     7|     :license: BSD, see LICENSE for more details.
     8| """
     9| from __future__ import print_function
    10| import os
    11| import re
    12| from babel.messages.catalog import Catalog, Message
    13| from babel.util import wraptext
    14| from babel._compat import text_type, cmp
    15| def unescape(string):
    16|     r"""Reverse `escape` the given string.
    17|     >>> print(unescape('"Say:\\n  \\"hello, world!\\"\\n"'))
    18|     Say:
    19|       "hello, world!"
    20|     <BLANKLINE>
    21|     :param string: the string to unescape
    22|     """
    23|     def replace_escapes(match):
    24|         m = match.group(1)
    25|         if m == 'n':
    26|             return '\n'


# ====================================================================
# FILE: babel/numbers.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-30 ---
     1| """
     2|     babel.numbers
     3|     ~~~~~~~~~~~~~
     4|     Locale dependent formatting and parsing of numeric data.
     5|     The default locale for the functions in this module is determined by the
     6|     following environment variables, in that order:
     7|      * ``LC_NUMERIC``,
     8|      * ``LC_ALL``, and
     9|      * ``LANG``
    10|     :copyright: (c) 2013-2020 by the Babel Team.
    11|     :license: BSD, see LICENSE for more details.
    12| """
    13| import re
    14| from datetime import date as date_, datetime as datetime_
    15| import warnings
    16| from babel.core import default_locale, Locale, get_global
    17| from babel._compat import decimal, string_types
    18| try:
    19|     long
    20| except NameError:
    21|     long = int
    22| LC_NUMERIC = default_locale('LC_NUMERIC')
    23| class UnknownCurrencyError(Exception):
    24|     """Exception thrown when a currency is requested for which no data is available.
    25|     """
    26|     def __init__(self, identifier):
    27|         """Create the exception.
    28|         :param identifier: the identifier string of the unsupported currency
    29|         """
    30|         Exception.__init__(self, 'Unknown currency %r.' % identifier)


# ====================================================================
# FILE: babel/plural.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| """
     2|     babel.numbers
     3|     ~~~~~~~~~~~~~
     4|     CLDR Plural support.  See UTS #35.
     5|     :copyright: (c) 2013-2020 by the Babel Team.
     6|     :license: BSD, see LICENSE for more details.
     7| """
     8| import re
     9| from babel._compat import decimal
    10| _plural_tags = ('zero', 'one', 'two', 'few', 'many', 'other')
    11| _fallback_tag = 'other'
    12| def extract_operands(source):
    13|     """Extract operands from a decimal, a float or an int, according to `CLDR rules`_.
    14|     The result is a 6-tuple (n, i, v, w, f, t), where those symbols are as follows:
    15|     ====== ===============================================================
    16|     Symbol Value
    17|     ------ ---------------------------------------------------------------
    18|     n      absolute value of the source number (integer and decimals).
    19|     i      integer digits of n.
    20|     v      number of visible fraction digits in n, with trailing zeros.
    21|     w      number of visible fraction digits in n, without trailing zeros.
    22|     f      visible fractional digits in n, with trailing zeros.
    23|     t      visible fractional digits in n, without trailing zeros.
    24|     ====== ===============================================================
    25|     .. _`CLDR rules`: https://www.unicode.org/reports/tr35/tr35-33/tr35-numbers.html#Operands


# ====================================================================
# FILE: babel/support.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-27 ---
     1| """
     2|     babel.support
     3|     ~~~~~~~~~~~~~
     4|     Several classes and functions that help with integrating and using Babel
     5|     in applications.
     6|     .. note: the code in this module is not used by Babel itself
     7|     :copyright: (c) 2013-2020 by the Babel Team.
     8|     :license: BSD, see LICENSE for more details.
     9| """
    10| import gettext
    11| import locale
    12| from babel.core import Locale
    13| from babel.dates import format_date, format_datetime, format_time, \
    14|     format_timedelta
    15| from babel.numbers import format_number, format_decimal, format_currency, \
    16|     format_percent, format_scientific
    17| from babel._compat import PY2, text_type, text_to_native
    18| class Format(object):
    19|     """Wrapper class providing the various date and number formatting functions
    20|     bound to a specific locale and time-zone.
    21|     >>> from babel.util import UTC
    22|     >>> from datetime import date
    23|     >>> fmt = Format('en_US', UTC)
    24|     >>> fmt.date(date(2007, 4, 1))
    25|     u'Apr 1, 2007'
    26|     >>> fmt.decimal(1.2345)
    27|     u'1.234'


# ====================================================================
# FILE: babel/util.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| """
     2|     babel.util
     3|     ~~~~~~~~~~
     4|     Various utility classes and functions.
     5|     :copyright: (c) 2013-2020 by the Babel Team.
     6|     :license: BSD, see LICENSE for more details.
     7| """
     8| import codecs
     9| import collections
    10| from datetime import timedelta, tzinfo
    11| import os
    12| import re
    13| import textwrap
    14| from babel._compat import izip, imap
    15| import pytz as _pytz
    16| from babel import localtime
    17| missing = object()
    18| def distinct(iterable):
    19|     """Yield all items in an iterable collection that are distinct.
    20|     Unlike when using sets for a similar effect, the original ordering of the
    21|     items in the collection is preserved by this function.
    22|     >>> print(list(distinct([1, 2, 1, 3, 4, 4])))
    23|     [1, 2, 3, 4]
    24|     >>> print(list(distinct('foobar')))
    25|     ['f', 'o', 'b', 'a', 'r']


# ====================================================================
# FILE: docs/conf.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-33 ---
     1| import sys, os
     2| sys.path.insert(0, os.path.abspath('..'))
     3| sys.path.append(os.path.abspath('_themes'))
     4| extensions = ['sphinx.ext.autodoc',
     5|               'sphinx.ext.intersphinx',
     6|               'sphinx.ext.extlinks']
     7| templates_path = ['_templates']
     8| source_suffix = '.rst'
     9| master_doc = 'index'
    10| project = u'Babel'
    11| copyright = u'2020, The Babel Team'
    12| version = '2.9'
    13| release = '2.9.0'
    14| exclude_patterns = ['_build']
    15| pygments_style = 'sphinx'
    16| html_theme = 'babel'
    17| html_theme_path = ['_themes']
    18| html_static_path = ['_static']
    19| html_sidebars = {
    20|     'index':    ['sidebar-about.html', 'localtoc.html', 'sidebar-links.html',
    21|                  'searchbox.html'],
    22|     '**':       ['sidebar-logo.html', 'localtoc.html', 'relations.html',
    23|                  'searchbox.html']
    24| }
    25| html_show_sourcelink = False
    26| htmlhelp_basename = 'Babeldoc'
    27| latex_elements = {
    28| 'fontpkg': '',
    29| }
    30| latex_documents = [
    31|   ('index', 'Babel.tex', u'Babel Documentation',
    32|    u'The Babel Team', 'manual'),
    33| ]


# ====================================================================
# FILE: scripts/download_import_cldr.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 44-84 ---
    44|     h = hashlib.sha256()
    45|     with open(filename, 'rb') as f:
    46|         while 1:
    47|             blk = f.read(BLKSIZE)
    48|             if not blk:
    49|                 break
    50|             h.update(blk)
    51|         digest = h.hexdigest()
    52|         if digest != FILESUM:
    53|             raise RuntimeError('Checksum mismatch: %r != %r'
    54|                                % (digest, FILESUM))
    55|         else:
    56|             return True
    57| def main():
    58|     scripts_path = os.path.dirname(os.path.abspath(__file__))
    59|     repo = os.path.dirname(scripts_path)
    60|     cldr_dl_path = os.path.join(repo, 'cldr')
    61|     cldr_path = os.path.join(repo, 'cldr', os.path.splitext(FILENAME)[0])
    62|     zip_path = os.path.join(cldr_dl_path, FILENAME)
    63|     changed = False
    64|     while not is_good_file(zip_path):
    65|         log('Downloading \'%s\'', FILENAME)
    66|         if os.path.isfile(zip_path):
    67|             os.remove(zip_path)
    68|         urlretrieve(URL, zip_path, reporthook)
    69|         changed = True
    70|         print()
    71|     common_path = os.path.join(cldr_path, 'common')
    72|     if changed or not os.path.isdir(common_path):
    73|         if os.path.isdir(common_path):
    74|             log('Deleting old CLDR checkout in \'%s\'', cldr_path)
    75|             shutil.rmtree(common_path)
    76|         log('Extracting CLDR to \'%s\'', cldr_path)
    77|         with contextlib.closing(zipfile.ZipFile(zip_path)) as z:
    78|             z.extractall(cldr_path)
    79|     subprocess.check_call([
    80|         sys.executable,
    81|         os.path.join(scripts_path, 'import_cldr.py'),
    82|         common_path])
    83| if __name__ == '__main__':
    84|     main()


# ====================================================================
# FILE: scripts/import_cldr.py
# Total hunks: 6
# ====================================================================
# --- HUNK 1: Lines 1-66 ---
     1| import collections
     2| from optparse import OptionParser
     3| import os
     4| import re
     5| import sys
     6| try:
     7|     from xml.etree import cElementTree as ElementTree
     8| except ImportError:
     9|     from xml.etree import ElementTree
    10| CHECKOUT_ROOT = os.path.abspath(os.path.join(
    11|     os.path.dirname(__file__),
    12|     '..'
    13| ))
    14| BABEL_PACKAGE_ROOT = os.path.join(CHECKOUT_ROOT, "babel")
    15| sys.path.insert(0, CHECKOUT_ROOT)
    16| from babel import dates, numbers
    17| from babel._compat import pickle, text_type
    18| from babel.dates import split_interval_pattern
    19| from babel.localedata import Alias
    20| from babel.plural import PluralRule
    21| parse = ElementTree.parse
    22| weekdays = {'mon': 0, 'tue': 1, 'wed': 2, 'thu': 3, 'fri': 4, 'sat': 5,
    23|             'sun': 6}
    24| def _text(elem):
    25|     buf = [elem.text or '']
    26|     for child in elem:
    27|         buf.append(_text(child))
    28|     buf.append(elem.tail or '')
    29|     return u''.join(filter(None, buf)).strip()
    30| NAME_RE = re.compile(r"^\w+$")
    31| TYPE_ATTR_RE = re.compile(r"^\w+\[@type='(.*?)'\]$")
    32| NAME_MAP = {
    33|     'dateFormats': 'date_formats',
    34|     'dateTimeFormats': 'datetime_formats',
    35|     'eraAbbr': 'abbreviated',
    36|     'eraNames': 'wide',
    37|     'eraNarrow': 'narrow',
    38|     'timeFormats': 'time_formats'
    39| }
    40| def log(message, *args):
    41|     if args:
    42|         message = message % args
    43|     sys.stderr.write(message + '\r\n')
    44|     sys.stderr.flush()
    45| def error(message, *args):
    46|     log('ERROR: %s' % message, *args)
    47| def need_conversion(dst_filename, data_dict, source_filename):
    48|     with open(source_filename, 'rb') as f:
    49|         blob = f.read(4096)
    50|         version_match = re.search(b'version number="\\$Revision: (\\d+)', blob)
    51|         if not version_match:  # CLDR 36.0 was shipped without proper revision numbers
    52|             return True
    53|         version = int(version_match.group(1))
    54|     data_dict['_version'] = version
    55|     if not os.path.isfile(dst_filename):
    56|         return True
    57|     with open(dst_filename, 'rb') as f:
    58|         data = pickle.load(f)
    59|         return data.get('_version') != version
    60| def _translate_alias(ctxt, path):
    61|     parts = path.split('/')
    62|     keys = ctxt[:]
    63|     for part in parts:
    64|         if part == '..':
    65|             keys.pop()
    66|         else:

# --- HUNK 2: Lines 115-157 ---
   115|     if isinstance(obj, PluralRule):
   116|         return obj.abstract
   117|     return repr(obj)
   118| def write_datafile(path, data, dump_json=False):
   119|     with open(path, 'wb') as outfile:
   120|         pickle.dump(data, outfile, 2)
   121|     if dump_json:
   122|         import json
   123|         with open(path + '.json', 'w') as outfile:
   124|             json.dump(data, outfile, indent=4, default=debug_repr)
   125| def main():
   126|     parser = OptionParser(usage='%prog path/to/cldr')
   127|     parser.add_option(
   128|         '-f', '--force', dest='force', action='store_true', default=False,
   129|         help='force import even if destination file seems up to date'
   130|     )
   131|     parser.add_option(
   132|         '-j', '--json', dest='dump_json', action='store_true', default=False,
   133|         help='also export debugging JSON dumps of locale data'
   134|     )
   135|     options, args = parser.parse_args()
   136|     if len(args) != 1:
   137|         parser.error('incorrect number of arguments')
   138|     return process_data(
   139|         srcdir=args[0],
   140|         destdir=BABEL_PACKAGE_ROOT,
   141|         force=bool(options.force),
   142|         dump_json=bool(options.dump_json)
   143|     )
   144| def process_data(srcdir, destdir, force=False, dump_json=False):
   145|     sup_filename = os.path.join(srcdir, 'supplemental', 'supplementalData.xml')
   146|     sup = parse(sup_filename)
   147|     global_path = os.path.join(destdir, 'global.dat')
   148|     global_data = {}
   149|     if force or need_conversion(global_path, global_data, sup_filename):
   150|         global_data.update(parse_global(srcdir, sup))
   151|         write_datafile(global_path, global_data, dump_json=dump_json)
   152|     _process_local_datas(sup, srcdir, destdir, force=force, dump_json=dump_json)
   153| def parse_global(srcdir, sup):
   154|     global_data = {}
   155|     sup_dir = os.path.join(srcdir, 'supplemental')
   156|     territory_zones = global_data.setdefault('territory_zones', {})
   157|     zone_aliases = global_data.setdefault('zone_aliases', {})

# --- HUNK 3: Lines 266-362 ---
   266|         stem, ext = os.path.splitext(filename)
   267|         if ext != '.xml':
   268|             continue
   269|         full_filename = os.path.join(srcdir, 'main', filename)
   270|         data_filename = os.path.join(destdir, 'locale-data', stem + '.dat')
   271|         data = {}
   272|         if not (force or need_conversion(data_filename, data, full_filename)):
   273|             continue
   274|         tree = parse(full_filename)
   275|         language = None
   276|         elem = tree.find('.//identity/language')
   277|         if elem is not None:
   278|             language = elem.attrib['type']
   279|         territory = None
   280|         elem = tree.find('.//identity/territory')
   281|         if elem is not None:
   282|             territory = elem.attrib['type']
   283|         else:
   284|             territory = '001'  # world
   285|         regions = territory_containment.get(territory, [])
   286|         log('Processing %s (Language = %s; Territory = %s)',
   287|             filename, language, territory)
   288|         locale_id = '_'.join(filter(None, [
   289|             language,
   290|             territory != '001' and territory or None
   291|         ]))
   292|         data['locale_id'] = locale_id
   293|         if locale_id in plural_rules:
   294|             data['plural_form'] = plural_rules[locale_id]
   295|         if locale_id in ordinal_rules:
   296|             data['ordinal_form'] = ordinal_rules[locale_id]
   297|         if locale_id in day_period_rules:
   298|             data["day_period_rules"] = day_period_rules[locale_id]
   299|         parse_locale_display_names(data, tree)
   300|         parse_list_patterns(data, tree)
   301|         parse_dates(data, tree, sup, regions, territory)
   302|         for calendar in tree.findall('.//calendars/calendar'):
   303|             if calendar.attrib['type'] != 'gregorian':
   304|                 continue
   305|             parse_calendar_months(data, calendar)
   306|             parse_calendar_days(data, calendar)
   307|             parse_calendar_quarters(data, calendar)
   308|             parse_calendar_eras(data, calendar)
   309|             parse_calendar_periods(data, calendar)
   310|             parse_calendar_date_formats(data, calendar)
   311|             parse_calendar_time_formats(data, calendar)
   312|             parse_calendar_datetime_skeletons(data, calendar)
   313|             parse_interval_formats(data, calendar)
   314|         parse_number_symbols(data, tree)
   315|         parse_decimal_formats(data, tree)
   316|         parse_scientific_formats(data, tree)
   317|         parse_percent_formats(data, tree)
   318|         parse_currency_formats(data, tree)
   319|         parse_currency_unit_patterns(data, tree)
   320|         parse_currency_names(data, tree)
   321|         parse_unit_patterns(data, tree)
   322|         parse_date_fields(data, tree)
   323|         parse_character_order(data, tree)
   324|         parse_measurement_systems(data, tree)
   325|         write_datafile(data_filename, data, dump_json=dump_json)
   326| def _should_skip_number_elem(data, elem):
   327|     """
   328|     Figure out whether the numbering-containing element `elem` is in a currently
   329|     non-supported (i.e. currently non-Latin) numbering system.
   330|     If it is, a warning is raised.
   331|     :param data: The root data element, for formatting the warning.
   332|     :param elem: Element with `numberSystem` key
   333|     :return: Boolean
   334|     """
   335|     number_system = elem.get('numberSystem', 'latn')
   336|     if number_system != 'latn':
   337|         log('%s: Unsupported number system "%s" in <%s numberSystem="%s">' % (
   338|             data['locale_id'],
   339|             number_system,
   340|             elem.tag,
   341|             number_system,
   342|         ))
   343|         return True
   344|     return False
   345| def _should_skip_elem(elem, type=None, dest=None):
   346|     """
   347|     Check whether the given element should be skipped.
   348|     Elements are skipped if they are drafts or alternates of data that already exists in `dest`.
   349|     :param elem: XML element
   350|     :param type: Type string. May be elided if the dest dict is elided.
   351|     :param dest: Destination dict. May be elided to skip the dict check.
   352|     :return: skip boolean
   353|     """
   354|     if 'draft' in elem.attrib or 'alt' in elem.attrib:
   355|         if dest is None or type in dest:
   356|             return True
   357| def _import_type_text(dest, elem, type=None):
   358|     """
   359|     Conditionally import the element's inner text(s) into the `dest` dict.
   360|     The condition being, namely, that the element isn't a draft/alternate version
   361|     of a pre-existing element.
   362|     :param dest: Destination dict

# --- HUNK 4: Lines 526-601 ---
   526|         for day_period_width in day_period_ctx.findall('dayPeriodWidth'):
   527|             width_type = day_period_width.attrib["type"]
   528|             dest_dict = periods.setdefault(ctx_type, {}).setdefault(width_type, {})
   529|             for day_period in day_period_width.findall('dayPeriod'):
   530|                 period_type = day_period.attrib['type']
   531|                 if 'alt' not in day_period.attrib:
   532|                     dest_dict[period_type] = text_type(day_period.text)
   533| def parse_calendar_date_formats(data, calendar):
   534|     date_formats = data.setdefault('date_formats', {})
   535|     for format in calendar.findall('dateFormats'):
   536|         for elem in format:
   537|             if elem.tag == 'dateFormatLength':
   538|                 type = elem.attrib.get('type')
   539|                 if _should_skip_elem(elem, type, date_formats):
   540|                     continue
   541|                 try:
   542|                     date_formats[type] = dates.parse_pattern(
   543|                         text_type(elem.findtext('dateFormat/pattern'))
   544|                     )
   545|                 except ValueError as e:
   546|                     error(e)
   547|             elif elem.tag == 'alias':
   548|                 date_formats = Alias(_translate_alias(
   549|                     ['date_formats'], elem.attrib['path'])
   550|                 )
   551| def parse_calendar_time_formats(data, calendar):
   552|     time_formats = data.setdefault('time_formats', {})
   553|     for format in calendar.findall('timeFormats'):
   554|         for elem in format:
   555|             if elem.tag == 'timeFormatLength':
   556|                 type = elem.attrib.get('type')
   557|                 if _should_skip_elem(elem, type, time_formats):
   558|                     continue
   559|                 try:
   560|                     time_formats[type] = dates.parse_pattern(
   561|                         text_type(elem.findtext('timeFormat/pattern'))
   562|                     )
   563|                 except ValueError as e:
   564|                     error(e)
   565|             elif elem.tag == 'alias':
   566|                 time_formats = Alias(_translate_alias(
   567|                     ['time_formats'], elem.attrib['path'])
   568|                 )
   569| def parse_calendar_datetime_skeletons(data, calendar):
   570|     datetime_formats = data.setdefault('datetime_formats', {})
   571|     datetime_skeletons = data.setdefault('datetime_skeletons', {})
   572|     for format in calendar.findall('dateTimeFormats'):
   573|         for elem in format:
   574|             if elem.tag == 'dateTimeFormatLength':
   575|                 type = elem.attrib.get('type')
   576|                 if _should_skip_elem(elem, type, datetime_formats):
   577|                     continue
   578|                 try:
   579|                     datetime_formats[type] = text_type(elem.findtext('dateTimeFormat/pattern'))
   580|                 except ValueError as e:
   581|                     error(e)
   582|             elif elem.tag == 'alias':
   583|                 datetime_formats = Alias(_translate_alias(
   584|                     ['datetime_formats'], elem.attrib['path'])
   585|                 )
   586|             elif elem.tag == 'availableFormats':
   587|                 for datetime_skeleton in elem.findall('dateFormatItem'):
   588|                     datetime_skeletons[datetime_skeleton.attrib['id']] = (
   589|                         dates.parse_pattern(text_type(datetime_skeleton.text))
   590|                     )
   591| def parse_number_symbols(data, tree):
   592|     number_symbols = data.setdefault('number_symbols', {})
   593|     for symbol_elem in tree.findall('.//numbers/symbols'):
   594|         if _should_skip_number_elem(data, symbol_elem):  # TODO: Support other number systems
   595|             continue
   596|         for elem in symbol_elem.findall('./*'):
   597|             if _should_skip_elem(elem):
   598|                 continue
   599|             number_symbols[elem.tag] = text_type(elem.text)
   600| def parse_decimal_formats(data, tree):
   601|     decimal_formats = data.setdefault('decimal_formats', {})

