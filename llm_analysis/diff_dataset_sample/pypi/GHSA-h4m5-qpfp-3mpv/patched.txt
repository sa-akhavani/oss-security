# ====================================================================
# FILE: babel/__init__.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-16 ---
     1| """
     2|     babel
     3|     ~~~~~
     4|     Integrated collection of utilities that assist in internationalizing and
     5|     localizing applications.
     6|     This package is basically composed of two major parts:
     7|      * tools to build and work with ``gettext`` message catalogs
     8|      * a Python interface to the CLDR (Common Locale Data Repository), providing
     9|        access to various locale display names, localized number and date
    10|        formatting, etc.
    11|     :copyright: (c) 2013-2021 by the Babel Team.
    12|     :license: BSD, see LICENSE for more details.
    13| """
    14| from babel.core import UnknownLocaleError, Locale, default_locale, \
    15|     negotiate_locale, parse_locale, get_locale_identifier
    16| __version__ = '2.9.1'


# ====================================================================
# FILE: babel/core.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| """
     2|     babel.core
     3|     ~~~~~~~~~~
     4|     Core locale representation and locale data access.
     5|     :copyright: (c) 2013-2021 by the Babel Team.
     6|     :license: BSD, see LICENSE for more details.
     7| """
     8| import os
     9| from babel import localedata
    10| from babel._compat import pickle, string_types
    11| from babel.plural import PluralRule
    12| __all__ = ['UnknownLocaleError', 'Locale', 'default_locale', 'negotiate_locale',
    13|            'parse_locale']
    14| _global_data = None
    15| _default_plural_rule = PluralRule({})
    16| def _raise_no_data_error():
    17|     raise RuntimeError('The babel data files are not available. '
    18|                        'This usually happens because you are using '
    19|                        'a source checkout from Babel and you did '
    20|                        'not build the data files.  Just make sure '
    21|                        'to run "python setup.py import_cldr" before '
    22|                        'installing the library.')
    23| def get_global(key):
    24|     """Return the dictionary for the given key in the global data.
    25|     The global data is stored in the ``babel/global.dat`` file and contains


# ====================================================================
# FILE: babel/dates.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-30 ---
     1| """
     2|     babel.dates
     3|     ~~~~~~~~~~~
     4|     Locale dependent formatting and parsing of dates and times.
     5|     The default locale for the functions in this module is determined by the
     6|     following environment variables, in that order:
     7|      * ``LC_TIME``,
     8|      * ``LC_ALL``, and
     9|      * ``LANG``
    10|     :copyright: (c) 2013-2021 by the Babel Team.
    11|     :license: BSD, see LICENSE for more details.
    12| """
    13| from __future__ import division
    14| import re
    15| import warnings
    16| import pytz as _pytz
    17| from datetime import date, datetime, time, timedelta
    18| from bisect import bisect_right
    19| from babel.core import default_locale, get_global, Locale
    20| from babel.util import UTC, LOCALTZ
    21| from babel._compat import string_types, integer_types, number_types, PY2
    22| NO_INHERITANCE_MARKER = u'\u2205\u2205\u2205'
    23| LC_TIME = default_locale('LC_TIME')
    24| date_ = date
    25| datetime_ = datetime
    26| time_ = time
    27| def _get_dt_and_tzinfo(dt_or_tzinfo):
    28|     """
    29|     Parse a `dt_or_tzinfo` value into a datetime and a tzinfo.
    30|     See the docs for this function's callers for semantics.


# ====================================================================
# FILE: babel/lists.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| """
     2|     babel.lists
     3|     ~~~~~~~~~~~
     4|     Locale dependent formatting of lists.
     5|     The default locale for the functions in this module is determined by the
     6|     following environment variables, in that order:
     7|      * ``LC_ALL``, and
     8|      * ``LANG``
     9|     :copyright: (c) 2015-2021 by the Babel Team.
    10|     :license: BSD, see LICENSE for more details.
    11| """
    12| from babel.core import Locale, default_locale
    13| DEFAULT_LOCALE = default_locale()
    14| def format_list(lst, style='standard', locale=DEFAULT_LOCALE):
    15|     """
    16|     Format the items in `lst` as a list.
    17|     >>> format_list(['apples', 'oranges', 'pears'], locale='en')
    18|     u'apples, oranges, and pears'
    19|     >>> format_list(['apples', 'oranges', 'pears'], locale='zh')
    20|     u'apples\u3001oranges\u548cpears'
    21|     >>> format_list(['omena', 'peruna', 'aplari'], style='or', locale='fi')
    22|     u'omena, peruna tai aplari'
    23|     These styles are defined, but not all are necessarily available in all locales.
    24|     The following text is verbatim from the Unicode TR35-49 spec [1].
    25|     * standard:
    26|       A typical 'and' list for arbitrary placeholders.
    27|       eg. "January, February, and March"
    28|     * standard-short:
    29|       A short version of a 'and' list, suitable for use with short or abbreviated placeholder values.


# ====================================================================
# FILE: babel/localedata.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-125 ---
     1| """
     2|     babel.localedata
     3|     ~~~~~~~~~~~~~~~~
     4|     Low-level locale data access.
     5|     :note: The `Locale` class, which uses this module under the hood, provides a
     6|            more convenient interface for accessing the locale data.
     7|     :copyright: (c) 2013-2021 by the Babel Team.
     8|     :license: BSD, see LICENSE for more details.
     9| """
    10| import os
    11| import re
    12| import sys
    13| import threading
    14| from itertools import chain
    15| from babel._compat import pickle, string_types, abc
    16| _cache = {}
    17| _cache_lock = threading.RLock()
    18| _dirname = os.path.join(os.path.dirname(__file__), 'locale-data')
    19| _windows_reserved_name_re = re.compile("^(con|prn|aux|nul|com[0-9]|lpt[0-9])$", re.I)
    20| def normalize_locale(name):
    21|     """Normalize a locale ID by stripping spaces and apply proper casing.
    22|     Returns the normalized locale ID string or `None` if the ID is not
    23|     recognized.
    24|     """
    25|     if not name or not isinstance(name, string_types):
    26|         return None
    27|     name = name.strip().lower()
    28|     for locale_id in chain.from_iterable([_cache, locale_identifiers()]):
    29|         if name == locale_id.lower():
    30|             return locale_id
    31| def resolve_locale_filename(name):
    32|     """
    33|     Resolve a locale identifier to a `.dat` path on disk.
    34|     """
    35|     name = os.path.basename(name)
    36|     if sys.platform == "win32" and _windows_reserved_name_re.match(os.path.splitext(name)[0]):
    37|         raise ValueError("Name %s is invalid on Windows" % name)
    38|     return os.path.join(_dirname, '%s.dat' % name)
    39| def exists(name):
    40|     """Check whether locale data is available for the given locale.
    41|     Returns `True` if it exists, `False` otherwise.
    42|     :param name: the locale identifier string
    43|     """
    44|     if not name or not isinstance(name, string_types):
    45|         return False
    46|     if name in _cache:
    47|         return True
    48|     file_found = os.path.exists(resolve_locale_filename(name))
    49|     return True if file_found else bool(normalize_locale(name))
    50| def locale_identifiers():
    51|     """Return a list of all locale identifiers for which locale data is
    52|     available.
    53|     This data is cached after the first invocation in `locale_identifiers.cache`.
    54|     Removing the `locale_identifiers.cache` attribute or setting it to `None`
    55|     will cause this function to re-read the list from disk.
    56|     .. versionadded:: 0.8.1
    57|     :return: a list of locale identifiers (strings)
    58|     """
    59|     data = getattr(locale_identifiers, 'cache', None)
    60|     if data is None:
    61|         locale_identifiers.cache = data = [
    62|             stem
    63|             for stem, extension in
    64|             (os.path.splitext(filename) for filename in os.listdir(_dirname))
    65|             if extension == '.dat' and stem != 'root'
    66|         ]
    67|     return data
    68| def load(name, merge_inherited=True):
    69|     """Load the locale data for the given locale.
    70|     The locale data is a dictionary that contains much of the data defined by
    71|     the Common Locale Data Repository (CLDR). This data is stored as a
    72|     collection of pickle files inside the ``babel`` package.
    73|     >>> d = load('en_US')
    74|     >>> d['languages']['sv']
    75|     u'Swedish'
    76|     Note that the results are cached, and subsequent requests for the same
    77|     locale return the same dictionary:
    78|     >>> d1 = load('en_US')
    79|     >>> d2 = load('en_US')
    80|     >>> d1 is d2
    81|     True
    82|     :param name: the locale identifier string (or "root")
    83|     :param merge_inherited: whether the inherited data should be merged into
    84|                             the data of the requested locale
    85|     :raise `IOError`: if no locale data file is found for the given locale
    86|                       identifer, or one of the locales it inherits from
    87|     """
    88|     name = os.path.basename(name)
    89|     _cache_lock.acquire()
    90|     try:
    91|         data = _cache.get(name)
    92|         if not data:
    93|             if name == 'root' or not merge_inherited:
    94|                 data = {}
    95|             else:
    96|                 from babel.core import get_global
    97|                 parent = get_global('parent_exceptions').get(name)
    98|                 if not parent:
    99|                     parts = name.split('_')
   100|                     if len(parts) == 1:
   101|                         parent = 'root'
   102|                     else:
   103|                         parent = '_'.join(parts[:-1])
   104|                 data = load(parent).copy()
   105|             filename = resolve_locale_filename(name)
   106|             with open(filename, 'rb') as fileobj:
   107|                 if name != 'root' and merge_inherited:
   108|                     merge(data, pickle.load(fileobj))
   109|                 else:
   110|                     data = pickle.load(fileobj)
   111|             _cache[name] = data
   112|         return data
   113|     finally:
   114|         _cache_lock.release()
   115| def merge(dict1, dict2):
   116|     """Merge the data from `dict2` into the `dict1` dictionary, making copies
   117|     of nested dictionaries.
   118|     >>> d = {1: 'foo', 3: 'baz'}
   119|     >>> merge(d, {1: 'Foo', 2: 'Bar'})
   120|     >>> sorted(d.items())
   121|     [(1, 'Foo'), (2, 'Bar'), (3, 'baz')]
   122|     :param dict1: the dictionary to merge into
   123|     :param dict2: the dictionary containing the data that should be merged
   124|     """
   125|     for key, val2 in dict2.items():


# ====================================================================
# FILE: babel/localtime/__init__.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| """
     2|     babel.localtime
     3|     ~~~~~~~~~~~~~~~
     4|     Babel specific fork of tzlocal to determine the local timezone
     5|     of the system.
     6|     :copyright: (c) 2013-2021 by the Babel Team.
     7|     :license: BSD, see LICENSE for more details.
     8| """
     9| import sys
    10| import pytz
    11| import time
    12| from datetime import timedelta
    13| from datetime import tzinfo
    14| from threading import RLock
    15| if sys.platform == 'win32':
    16|     from babel.localtime._win32 import _get_localzone
    17| else:
    18|     from babel.localtime._unix import _get_localzone
    19| _cached_tz = None
    20| _cache_lock = RLock()
    21| STDOFFSET = timedelta(seconds=-time.timezone)
    22| if time.daylight:
    23|     DSTOFFSET = timedelta(seconds=-time.altzone)
    24| else:
    25|     DSTOFFSET = STDOFFSET
    26| DSTDIFF = DSTOFFSET - STDOFFSET


# ====================================================================
# FILE: babel/messages/__init__.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-8 ---
     1| """
     2|     babel.messages
     3|     ~~~~~~~~~~~~~~
     4|     Support for ``gettext`` message catalogs.
     5|     :copyright: (c) 2013-2021 by the Babel Team.
     6|     :license: BSD, see LICENSE for more details.
     7| """
     8| from babel.messages.catalog import *


# ====================================================================
# FILE: babel/messages/catalog.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| """
     2|     babel.messages.catalog
     3|     ~~~~~~~~~~~~~~~~~~~~~~
     4|     Data structures for message catalogs.
     5|     :copyright: (c) 2013-2021 by the Babel Team.
     6|     :license: BSD, see LICENSE for more details.
     7| """
     8| import re
     9| import time
    10| from cgi import parse_header
    11| from collections import OrderedDict
    12| from datetime import datetime, time as time_
    13| from difflib import get_close_matches
    14| from email import message_from_string
    15| from copy import copy
    16| from babel import __version__ as VERSION
    17| from babel.core import Locale, UnknownLocaleError
    18| from babel.dates import format_datetime
    19| from babel.messages.plurals import get_plural
    20| from babel.util import distinct, LOCALTZ, FixedOffsetTimezone
    21| from babel._compat import string_types, number_types, PY2, cmp, text_type, force_text
    22| __all__ = ['Message', 'Catalog', 'TranslationError']
    23| PYTHON_FORMAT = re.compile(r'''
    24|     \%
    25|         (?:\(([\w]*)\))?


# ====================================================================
# FILE: babel/messages/checkers.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| """
     2|     babel.messages.checkers
     3|     ~~~~~~~~~~~~~~~~~~~~~~~
     4|     Various routines that help with validation of translations.
     5|     :since: version 0.9
     6|     :copyright: (c) 2013-2021 by the Babel Team.
     7|     :license: BSD, see LICENSE for more details.
     8| """
     9| from babel.messages.catalog import TranslationError, PYTHON_FORMAT
    10| from babel._compat import string_types, izip
    11| _string_format_compatibilities = [
    12|     {'i', 'd', 'u'},
    13|     {'x', 'X'},
    14|     {'f', 'F', 'g', 'G'}
    15| ]
    16| def num_plurals(catalog, message):
    17|     """Verify the number of plurals in the translation."""
    18|     if not message.pluralizable:
    19|         if not isinstance(message.string, string_types):
    20|             raise TranslationError("Found plural forms for non-pluralizable "
    21|                                    "message")
    22|         return
    23|     elif catalog is None:
    24|         return
    25|     msgstrs = message.string
    26|     if not isinstance(msgstrs, (list, tuple)):


# ====================================================================
# FILE: babel/messages/extract.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-31 ---
     1| """
     2|     babel.messages.extract
     3|     ~~~~~~~~~~~~~~~~~~~~~~
     4|     Basic infrastructure for extracting localizable messages from source files.
     5|     This module defines an extensible system for collecting localizable message
     6|     strings from a variety of sources. A native extractor for Python source
     7|     files is builtin, extractors for other sources can be added using very
     8|     simple plugins.
     9|     The main entry points into the extraction functionality are the functions
    10|     `extract_from_dir` and `extract_from_file`.
    11|     :copyright: (c) 2013-2021 by the Babel Team.
    12|     :license: BSD, see LICENSE for more details.
    13| """
    14| import os
    15| from os.path import relpath
    16| import sys
    17| from tokenize import generate_tokens, COMMENT, NAME, OP, STRING
    18| from babel.util import parse_encoding, parse_future_flags, pathmatch
    19| from babel._compat import PY2, text_type
    20| from textwrap import dedent
    21| GROUP_NAME = 'babel.extractors'
    22| DEFAULT_KEYWORDS = {
    23|     '_': None,
    24|     'gettext': None,
    25|     'ngettext': (1, 2),
    26|     'ugettext': None,
    27|     'ungettext': (1, 2),
    28|     'dgettext': (2,),
    29|     'dngettext': (2, 3),
    30|     'N_': None,
    31|     'pgettext': ((1, 'c'), 2),


# ====================================================================
# FILE: babel/messages/frontend.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| """
     2|     babel.messages.frontend
     3|     ~~~~~~~~~~~~~~~~~~~~~~~
     4|     Frontends for the message extraction functionality.
     5|     :copyright: (c) 2013-2021 by the Babel Team.
     6|     :license: BSD, see LICENSE for more details.
     7| """
     8| from __future__ import print_function
     9| import logging
    10| import optparse
    11| import os
    12| import re
    13| import shutil
    14| import sys
    15| import tempfile
    16| from collections import OrderedDict
    17| from datetime import datetime
    18| from locale import getpreferredencoding
    19| from babel import __version__ as VERSION
    20| from babel import Locale, localedata
    21| from babel._compat import StringIO, string_types, text_type, PY2
    22| from babel.core import UnknownLocaleError
    23| from babel.messages.catalog import Catalog
    24| from babel.messages.extract import DEFAULT_KEYWORDS, DEFAULT_MAPPING, check_and_call_extract_file, extract_from_dir
    25| from babel.messages.mofile import write_mo


# ====================================================================
# FILE: babel/messages/jslexer.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| """
     2|     babel.messages.jslexer
     3|     ~~~~~~~~~~~~~~~~~~~~~~
     4|     A simple JavaScript 1.5 lexer which is used for the JavaScript
     5|     extractor.
     6|     :copyright: (c) 2013-2021 by the Babel Team.
     7|     :license: BSD, see LICENSE for more details.
     8| """
     9| from collections import namedtuple
    10| import re
    11| from babel._compat import unichr
    12| operators = sorted([
    13|     '+', '-', '*', '%', '!=', '==', '<', '>', '<=', '>=', '=',
    14|     '+=', '-=', '*=', '%=', '<<', '>>', '>>>', '<<=', '>>=',
    15|     '>>>=', '&', '&=', '|', '|=', '&&', '||', '^', '^=', '(', ')',
    16|     '[', ']', '{', '}', '!', '--', '++', '~', ',', ';', '.', ':'
    17| ], key=len, reverse=True)
    18| escapes = {'b': '\b', 'f': '\f', 'n': '\n', 'r': '\r', 't': '\t'}
    19| name_re = re.compile(r'[\w$_][\w\d$_]*', re.UNICODE)
    20| dotted_name_re = re.compile(r'[\w$_][\w\d$_.]*[\w\d$_.]', re.UNICODE)
    21| division_re = re.compile(r'/=?')
    22| regex_re = re.compile(r'/(?:[^/\\]*(?:\\.[^/\\]*)*)/[a-zA-Z]*', re.DOTALL)
    23| line_re = re.compile(r'(\r\n|\n|\r)')
    24| line_join_re = re.compile(r'\\' + line_re.pattern)
    25| uni_escape_re = re.compile(r'[a-fA-F0-9]{1,4}')
    26| Token = namedtuple('Token', 'type value lineno')


# ====================================================================
# FILE: babel/messages/mofile.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| """
     2|     babel.messages.mofile
     3|     ~~~~~~~~~~~~~~~~~~~~~
     4|     Writing of files in the ``gettext`` MO (machine object) format.
     5|     :copyright: (c) 2013-2021 by the Babel Team.
     6|     :license: BSD, see LICENSE for more details.
     7| """
     8| import array
     9| import struct
    10| from babel.messages.catalog import Catalog, Message
    11| from babel._compat import range_type, array_tobytes
    12| LE_MAGIC = 0x950412de
    13| BE_MAGIC = 0xde120495
    14| def read_mo(fileobj):
    15|     """Read a binary MO file from the given file-like object and return a
    16|     corresponding `Catalog` object.
    17|     :param fileobj: the file-like object to read the MO file from
    18|     :note: The implementation of this function is heavily based on the
    19|            ``GNUTranslations._parse`` method of the ``gettext`` module in the
    20|            standard library.
    21|     """
    22|     catalog = Catalog()
    23|     headers = {}
    24|     filename = getattr(fileobj, 'name', '')
    25|     buf = fileobj.read()


# ====================================================================
# FILE: babel/messages/plurals.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| """
     2|     babel.messages.plurals
     3|     ~~~~~~~~~~~~~~~~~~~~~~
     4|     Plural form definitions.
     5|     :copyright: (c) 2013-2021 by the Babel Team.
     6|     :license: BSD, see LICENSE for more details.
     7| """
     8| from babel.core import default_locale, Locale
     9| from operator import itemgetter
    10| LC_CTYPE = default_locale('LC_CTYPE')
    11| PLURALS = {
    12|     'af': (2, '(n != 1)'),
    13|     'ar': (6, '(n==0 ? 0 : n==1 ? 1 : n==2 ? 2 : n%100>=3 && n%100<=10 ? 3 : n%100>=0 && n%100<=2 ? 4 : 5)'),
    14|     'be': (3, '(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)'),
    15|     'bg': (2, '(n != 1)'),
    16|     'bn': (2, '(n != 1)'),
    17|     'bo': (1, '0'),
    18|     'br': (
    19|         6,
    20|         '(n==1 ? 0 : n%10==1 && n%100!=11 && n%100!=71 && n%100!=91 ? 1 : n%10==2 && n%100!=12 && n%100!=72 && '
    21|         'n%100!=92 ? 2 : (n%10==3 || n%10==4 || n%10==9) && n%100!=13 && n%100!=14 && n%100!=19 && n%100!=73 && '
    22|         'n%100!=74 && n%100!=79 && n%100!=93 && n%100!=94 && n%100!=99 ? 3 : n%1000000==0 ? 4 : 5)'
    23|     ),
    24|     'bs': (3, '(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)'),
    25|     'ca': (2, '(n != 1)'),


# ====================================================================
# FILE: babel/messages/pofile.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| """
     2|     babel.messages.pofile
     3|     ~~~~~~~~~~~~~~~~~~~~~
     4|     Reading and writing of files in the ``gettext`` PO (portable object)
     5|     format.
     6|     :copyright: (c) 2013-2021 by the Babel Team.
     7|     :license: BSD, see LICENSE for more details.
     8| """
     9| from __future__ import print_function
    10| import os
    11| import re
    12| from babel.messages.catalog import Catalog, Message
    13| from babel.util import wraptext
    14| from babel._compat import text_type, cmp
    15| def unescape(string):
    16|     r"""Reverse `escape` the given string.
    17|     >>> print(unescape('"Say:\\n  \\"hello, world!\\"\\n"'))
    18|     Say:
    19|       "hello, world!"
    20|     <BLANKLINE>
    21|     :param string: the string to unescape
    22|     """
    23|     def replace_escapes(match):
    24|         m = match.group(1)
    25|         if m == 'n':
    26|             return '\n'


# ====================================================================
# FILE: babel/numbers.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-30 ---
     1| """
     2|     babel.numbers
     3|     ~~~~~~~~~~~~~
     4|     Locale dependent formatting and parsing of numeric data.
     5|     The default locale for the functions in this module is determined by the
     6|     following environment variables, in that order:
     7|      * ``LC_NUMERIC``,
     8|      * ``LC_ALL``, and
     9|      * ``LANG``
    10|     :copyright: (c) 2013-2021 by the Babel Team.
    11|     :license: BSD, see LICENSE for more details.
    12| """
    13| import re
    14| from datetime import date as date_, datetime as datetime_
    15| import warnings
    16| from babel.core import default_locale, Locale, get_global
    17| from babel._compat import decimal, string_types
    18| try:
    19|     long
    20| except NameError:
    21|     long = int
    22| LC_NUMERIC = default_locale('LC_NUMERIC')
    23| class UnknownCurrencyError(Exception):
    24|     """Exception thrown when a currency is requested for which no data is available.
    25|     """
    26|     def __init__(self, identifier):
    27|         """Create the exception.
    28|         :param identifier: the identifier string of the unsupported currency
    29|         """
    30|         Exception.__init__(self, 'Unknown currency %r.' % identifier)


# ====================================================================
# FILE: babel/plural.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| """
     2|     babel.numbers
     3|     ~~~~~~~~~~~~~
     4|     CLDR Plural support.  See UTS #35.
     5|     :copyright: (c) 2013-2021 by the Babel Team.
     6|     :license: BSD, see LICENSE for more details.
     7| """
     8| import re
     9| from babel._compat import decimal
    10| _plural_tags = ('zero', 'one', 'two', 'few', 'many', 'other')
    11| _fallback_tag = 'other'
    12| def extract_operands(source):
    13|     """Extract operands from a decimal, a float or an int, according to `CLDR rules`_.
    14|     The result is a 6-tuple (n, i, v, w, f, t), where those symbols are as follows:
    15|     ====== ===============================================================
    16|     Symbol Value
    17|     ------ ---------------------------------------------------------------
    18|     n      absolute value of the source number (integer and decimals).
    19|     i      integer digits of n.
    20|     v      number of visible fraction digits in n, with trailing zeros.
    21|     w      number of visible fraction digits in n, without trailing zeros.
    22|     f      visible fractional digits in n, with trailing zeros.
    23|     t      visible fractional digits in n, without trailing zeros.
    24|     ====== ===============================================================
    25|     .. _`CLDR rules`: https://www.unicode.org/reports/tr35/tr35-33/tr35-numbers.html#Operands


# ====================================================================
# FILE: babel/support.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-27 ---
     1| """
     2|     babel.support
     3|     ~~~~~~~~~~~~~
     4|     Several classes and functions that help with integrating and using Babel
     5|     in applications.
     6|     .. note: the code in this module is not used by Babel itself
     7|     :copyright: (c) 2013-2021 by the Babel Team.
     8|     :license: BSD, see LICENSE for more details.
     9| """
    10| import gettext
    11| import locale
    12| from babel.core import Locale
    13| from babel.dates import format_date, format_datetime, format_time, \
    14|     format_timedelta
    15| from babel.numbers import format_number, format_decimal, format_currency, \
    16|     format_percent, format_scientific
    17| from babel._compat import PY2, text_type, text_to_native
    18| class Format(object):
    19|     """Wrapper class providing the various date and number formatting functions
    20|     bound to a specific locale and time-zone.
    21|     >>> from babel.util import UTC
    22|     >>> from datetime import date
    23|     >>> fmt = Format('en_US', UTC)
    24|     >>> fmt.date(date(2007, 4, 1))
    25|     u'Apr 1, 2007'
    26|     >>> fmt.decimal(1.2345)
    27|     u'1.234'


# ====================================================================
# FILE: babel/util.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| """
     2|     babel.util
     3|     ~~~~~~~~~~
     4|     Various utility classes and functions.
     5|     :copyright: (c) 2013-2021 by the Babel Team.
     6|     :license: BSD, see LICENSE for more details.
     7| """
     8| import codecs
     9| import collections
    10| from datetime import timedelta, tzinfo
    11| import os
    12| import re
    13| import textwrap
    14| from babel._compat import izip, imap
    15| import pytz as _pytz
    16| from babel import localtime
    17| missing = object()
    18| def distinct(iterable):
    19|     """Yield all items in an iterable collection that are distinct.
    20|     Unlike when using sets for a similar effect, the original ordering of the
    21|     items in the collection is preserved by this function.
    22|     >>> print(list(distinct([1, 2, 1, 3, 4, 4])))
    23|     [1, 2, 3, 4]
    24|     >>> print(list(distinct('foobar')))
    25|     ['f', 'o', 'b', 'a', 'r']


# ====================================================================
# FILE: docs/conf.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-33 ---
     1| import sys, os
     2| sys.path.insert(0, os.path.abspath('..'))
     3| sys.path.append(os.path.abspath('_themes'))
     4| extensions = ['sphinx.ext.autodoc',
     5|               'sphinx.ext.intersphinx',
     6|               'sphinx.ext.extlinks']
     7| templates_path = ['_templates']
     8| source_suffix = '.rst'
     9| master_doc = 'index'
    10| project = u'Babel'
    11| copyright = u'2021, The Babel Team'
    12| version = '2.9'
    13| release = '2.9.1'
    14| exclude_patterns = ['_build']
    15| pygments_style = 'sphinx'
    16| html_theme = 'babel'
    17| html_theme_path = ['_themes']
    18| html_static_path = ['_static']
    19| html_sidebars = {
    20|     'index':    ['sidebar-about.html', 'localtoc.html', 'sidebar-links.html',
    21|                  'searchbox.html'],
    22|     '**':       ['sidebar-logo.html', 'localtoc.html', 'relations.html',
    23|                  'searchbox.html']
    24| }
    25| html_show_sourcelink = False
    26| htmlhelp_basename = 'Babeldoc'
    27| latex_elements = {
    28| 'fontpkg': '',
    29| }
    30| latex_documents = [
    31|   ('index', 'Babel.tex', u'Babel Documentation',
    32|    u'The Babel Team', 'manual'),
    33| ]


# ====================================================================
# FILE: scripts/download_import_cldr.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 44-85 ---
    44|     h = hashlib.sha256()
    45|     with open(filename, 'rb') as f:
    46|         while 1:
    47|             blk = f.read(BLKSIZE)
    48|             if not blk:
    49|                 break
    50|             h.update(blk)
    51|         digest = h.hexdigest()
    52|         if digest != FILESUM:
    53|             raise RuntimeError('Checksum mismatch: %r != %r'
    54|                                % (digest, FILESUM))
    55|         else:
    56|             return True
    57| def main():
    58|     scripts_path = os.path.dirname(os.path.abspath(__file__))
    59|     repo = os.path.dirname(scripts_path)
    60|     cldr_dl_path = os.path.join(repo, 'cldr')
    61|     cldr_path = os.path.join(repo, 'cldr', os.path.splitext(FILENAME)[0])
    62|     zip_path = os.path.join(cldr_dl_path, FILENAME)
    63|     changed = False
    64|     show_progress = (False if os.environ.get("BABEL_CLDR_NO_DOWNLOAD_PROGRESS") else sys.stdout.isatty())
    65|     while not is_good_file(zip_path):
    66|         log('Downloading \'%s\'', FILENAME)
    67|         if os.path.isfile(zip_path):
    68|             os.remove(zip_path)
    69|         urlretrieve(URL, zip_path, (reporthook if show_progress else None))
    70|         changed = True
    71|         print()
    72|     common_path = os.path.join(cldr_path, 'common')
    73|     if changed or not os.path.isdir(common_path):
    74|         if os.path.isdir(common_path):
    75|             log('Deleting old CLDR checkout in \'%s\'', cldr_path)
    76|             shutil.rmtree(common_path)
    77|         log('Extracting CLDR to \'%s\'', cldr_path)
    78|         with contextlib.closing(zipfile.ZipFile(zip_path)) as z:
    79|             z.extractall(cldr_path)
    80|     subprocess.check_call([
    81|         sys.executable,
    82|         os.path.join(scripts_path, 'import_cldr.py'),
    83|         common_path])
    84| if __name__ == '__main__':
    85|     main()


# ====================================================================
# FILE: scripts/import_cldr.py
# Total hunks: 6
# ====================================================================
# --- HUNK 1: Lines 1-61 ---
     1| import collections
     2| from optparse import OptionParser
     3| import os
     4| import re
     5| import sys
     6| import logging
     7| try:
     8|     from xml.etree import cElementTree as ElementTree
     9| except ImportError:
    10|     from xml.etree import ElementTree
    11| CHECKOUT_ROOT = os.path.abspath(os.path.join(
    12|     os.path.dirname(__file__),
    13|     '..'
    14| ))
    15| BABEL_PACKAGE_ROOT = os.path.join(CHECKOUT_ROOT, "babel")
    16| sys.path.insert(0, CHECKOUT_ROOT)
    17| from babel import dates, numbers
    18| from babel._compat import pickle, text_type
    19| from babel.dates import split_interval_pattern
    20| from babel.localedata import Alias
    21| from babel.plural import PluralRule
    22| parse = ElementTree.parse
    23| weekdays = {'mon': 0, 'tue': 1, 'wed': 2, 'thu': 3, 'fri': 4, 'sat': 5,
    24|             'sun': 6}
    25| def _text(elem):
    26|     buf = [elem.text or '']
    27|     for child in elem:
    28|         buf.append(_text(child))
    29|     buf.append(elem.tail or '')
    30|     return u''.join(filter(None, buf)).strip()
    31| NAME_RE = re.compile(r"^\w+$")
    32| TYPE_ATTR_RE = re.compile(r"^\w+\[@type='(.*?)'\]$")
    33| NAME_MAP = {
    34|     'dateFormats': 'date_formats',
    35|     'dateTimeFormats': 'datetime_formats',
    36|     'eraAbbr': 'abbreviated',
    37|     'eraNames': 'wide',
    38|     'eraNarrow': 'narrow',
    39|     'timeFormats': 'time_formats'
    40| }
    41| log = logging.getLogger("import_cldr")
    42| def need_conversion(dst_filename, data_dict, source_filename):
    43|     with open(source_filename, 'rb') as f:
    44|         blob = f.read(4096)
    45|         version_match = re.search(b'version number="\\$Revision: (\\d+)', blob)
    46|         if not version_match:  # CLDR 36.0 was shipped without proper revision numbers
    47|             return True
    48|         version = int(version_match.group(1))
    49|     data_dict['_version'] = version
    50|     if not os.path.isfile(dst_filename):
    51|         return True
    52|     with open(dst_filename, 'rb') as f:
    53|         data = pickle.load(f)
    54|         return data.get('_version') != version
    55| def _translate_alias(ctxt, path):
    56|     parts = path.split('/')
    57|     keys = ctxt[:]
    58|     for part in parts:
    59|         if part == '..':
    60|             keys.pop()
    61|         else:

# --- HUNK 2: Lines 110-159 ---
   110|     if isinstance(obj, PluralRule):
   111|         return obj.abstract
   112|     return repr(obj)
   113| def write_datafile(path, data, dump_json=False):
   114|     with open(path, 'wb') as outfile:
   115|         pickle.dump(data, outfile, 2)
   116|     if dump_json:
   117|         import json
   118|         with open(path + '.json', 'w') as outfile:
   119|             json.dump(data, outfile, indent=4, default=debug_repr)
   120| def main():
   121|     parser = OptionParser(usage='%prog path/to/cldr')
   122|     parser.add_option(
   123|         '-f', '--force', dest='force', action='store_true', default=False,
   124|         help='force import even if destination file seems up to date'
   125|     )
   126|     parser.add_option(
   127|         '-j', '--json', dest='dump_json', action='store_true', default=False,
   128|         help='also export debugging JSON dumps of locale data'
   129|     )
   130|     parser.add_option(
   131|         '-q', '--quiet', dest='quiet', action='store_true', default=bool(os.environ.get('BABEL_CLDR_QUIET')),
   132|         help='quiesce info/warning messages',
   133|     )
   134|     options, args = parser.parse_args()
   135|     if len(args) != 1:
   136|         parser.error('incorrect number of arguments')
   137|     logging.basicConfig(
   138|         level=(logging.ERROR if options.quiet else logging.INFO),
   139|     )
   140|     return process_data(
   141|         srcdir=args[0],
   142|         destdir=BABEL_PACKAGE_ROOT,
   143|         force=bool(options.force),
   144|         dump_json=bool(options.dump_json)
   145|     )
   146| def process_data(srcdir, destdir, force=False, dump_json=False):
   147|     sup_filename = os.path.join(srcdir, 'supplemental', 'supplementalData.xml')
   148|     sup = parse(sup_filename)
   149|     global_path = os.path.join(destdir, 'global.dat')
   150|     global_data = {}
   151|     if force or need_conversion(global_path, global_data, sup_filename):
   152|         global_data.update(parse_global(srcdir, sup))
   153|         write_datafile(global_path, global_data, dump_json=dump_json)
   154|     _process_local_datas(sup, srcdir, destdir, force=force, dump_json=dump_json)
   155| def parse_global(srcdir, sup):
   156|     global_data = {}
   157|     sup_dir = os.path.join(srcdir, 'supplemental')
   158|     territory_zones = global_data.setdefault('territory_zones', {})
   159|     zone_aliases = global_data.setdefault('zone_aliases', {})

# --- HUNK 3: Lines 268-367 ---
   268|         stem, ext = os.path.splitext(filename)
   269|         if ext != '.xml':
   270|             continue
   271|         full_filename = os.path.join(srcdir, 'main', filename)
   272|         data_filename = os.path.join(destdir, 'locale-data', stem + '.dat')
   273|         data = {}
   274|         if not (force or need_conversion(data_filename, data, full_filename)):
   275|             continue
   276|         tree = parse(full_filename)
   277|         language = None
   278|         elem = tree.find('.//identity/language')
   279|         if elem is not None:
   280|             language = elem.attrib['type']
   281|         territory = None
   282|         elem = tree.find('.//identity/territory')
   283|         if elem is not None:
   284|             territory = elem.attrib['type']
   285|         else:
   286|             territory = '001'  # world
   287|         regions = territory_containment.get(territory, [])
   288|         log.info(
   289|             'Processing %s (Language = %s; Territory = %s)',
   290|             filename, language, territory,
   291|         )
   292|         locale_id = '_'.join(filter(None, [
   293|             language,
   294|             territory != '001' and territory or None
   295|         ]))
   296|         data['locale_id'] = locale_id
   297|         data['unsupported_number_systems'] = set()
   298|         if locale_id in plural_rules:
   299|             data['plural_form'] = plural_rules[locale_id]
   300|         if locale_id in ordinal_rules:
   301|             data['ordinal_form'] = ordinal_rules[locale_id]
   302|         if locale_id in day_period_rules:
   303|             data["day_period_rules"] = day_period_rules[locale_id]
   304|         parse_locale_display_names(data, tree)
   305|         parse_list_patterns(data, tree)
   306|         parse_dates(data, tree, sup, regions, territory)
   307|         for calendar in tree.findall('.//calendars/calendar'):
   308|             if calendar.attrib['type'] != 'gregorian':
   309|                 continue
   310|             parse_calendar_months(data, calendar)
   311|             parse_calendar_days(data, calendar)
   312|             parse_calendar_quarters(data, calendar)
   313|             parse_calendar_eras(data, calendar)
   314|             parse_calendar_periods(data, calendar)
   315|             parse_calendar_date_formats(data, calendar)
   316|             parse_calendar_time_formats(data, calendar)
   317|             parse_calendar_datetime_skeletons(data, calendar)
   318|             parse_interval_formats(data, calendar)
   319|         parse_number_symbols(data, tree)
   320|         parse_decimal_formats(data, tree)
   321|         parse_scientific_formats(data, tree)
   322|         parse_percent_formats(data, tree)
   323|         parse_currency_formats(data, tree)
   324|         parse_currency_unit_patterns(data, tree)
   325|         parse_currency_names(data, tree)
   326|         parse_unit_patterns(data, tree)
   327|         parse_date_fields(data, tree)
   328|         parse_character_order(data, tree)
   329|         parse_measurement_systems(data, tree)
   330|         unsupported_number_systems_string = ', '.join(sorted(data.pop('unsupported_number_systems')))
   331|         if unsupported_number_systems_string:
   332|             log.warning('%s: unsupported number systems were ignored: %s' % (
   333|                 locale_id,
   334|                 unsupported_number_systems_string,
   335|             ))
   336|         write_datafile(data_filename, data, dump_json=dump_json)
   337| def _should_skip_number_elem(data, elem):
   338|     """
   339|     Figure out whether the numbering-containing element `elem` is in a currently
   340|     non-supported (i.e. currently non-Latin) numbering system.
   341|     :param data: The root data element, for stashing the warning.
   342|     :param elem: Element with `numberSystem` key
   343|     :return: Boolean
   344|     """
   345|     number_system = elem.get('numberSystem', 'latn')
   346|     if number_system != 'latn':
   347|         data['unsupported_number_systems'].add(number_system)
   348|         return True
   349|     return False
   350| def _should_skip_elem(elem, type=None, dest=None):
   351|     """
   352|     Check whether the given element should be skipped.
   353|     Elements are skipped if they are drafts or alternates of data that already exists in `dest`.
   354|     :param elem: XML element
   355|     :param type: Type string. May be elided if the dest dict is elided.
   356|     :param dest: Destination dict. May be elided to skip the dict check.
   357|     :return: skip boolean
   358|     """
   359|     if 'draft' in elem.attrib or 'alt' in elem.attrib:
   360|         if dest is None or type in dest:
   361|             return True
   362| def _import_type_text(dest, elem, type=None):
   363|     """
   364|     Conditionally import the element's inner text(s) into the `dest` dict.
   365|     The condition being, namely, that the element isn't a draft/alternate version
   366|     of a pre-existing element.
   367|     :param dest: Destination dict

# --- HUNK 4: Lines 531-606 ---
   531|         for day_period_width in day_period_ctx.findall('dayPeriodWidth'):
   532|             width_type = day_period_width.attrib["type"]
   533|             dest_dict = periods.setdefault(ctx_type, {}).setdefault(width_type, {})
   534|             for day_period in day_period_width.findall('dayPeriod'):
   535|                 period_type = day_period.attrib['type']
   536|                 if 'alt' not in day_period.attrib:
   537|                     dest_dict[period_type] = text_type(day_period.text)
   538| def parse_calendar_date_formats(data, calendar):
   539|     date_formats = data.setdefault('date_formats', {})
   540|     for format in calendar.findall('dateFormats'):
   541|         for elem in format:
   542|             if elem.tag == 'dateFormatLength':
   543|                 type = elem.attrib.get('type')
   544|                 if _should_skip_elem(elem, type, date_formats):
   545|                     continue
   546|                 try:
   547|                     date_formats[type] = dates.parse_pattern(
   548|                         text_type(elem.findtext('dateFormat/pattern'))
   549|                     )
   550|                 except ValueError as e:
   551|                     log.error(e)
   552|             elif elem.tag == 'alias':
   553|                 date_formats = Alias(_translate_alias(
   554|                     ['date_formats'], elem.attrib['path'])
   555|                 )
   556| def parse_calendar_time_formats(data, calendar):
   557|     time_formats = data.setdefault('time_formats', {})
   558|     for format in calendar.findall('timeFormats'):
   559|         for elem in format:
   560|             if elem.tag == 'timeFormatLength':
   561|                 type = elem.attrib.get('type')
   562|                 if _should_skip_elem(elem, type, time_formats):
   563|                     continue
   564|                 try:
   565|                     time_formats[type] = dates.parse_pattern(
   566|                         text_type(elem.findtext('timeFormat/pattern'))
   567|                     )
   568|                 except ValueError as e:
   569|                     log.error(e)
   570|             elif elem.tag == 'alias':
   571|                 time_formats = Alias(_translate_alias(
   572|                     ['time_formats'], elem.attrib['path'])
   573|                 )
   574| def parse_calendar_datetime_skeletons(data, calendar):
   575|     datetime_formats = data.setdefault('datetime_formats', {})
   576|     datetime_skeletons = data.setdefault('datetime_skeletons', {})
   577|     for format in calendar.findall('dateTimeFormats'):
   578|         for elem in format:
   579|             if elem.tag == 'dateTimeFormatLength':
   580|                 type = elem.attrib.get('type')
   581|                 if _should_skip_elem(elem, type, datetime_formats):
   582|                     continue
   583|                 try:
   584|                     datetime_formats[type] = text_type(elem.findtext('dateTimeFormat/pattern'))
   585|                 except ValueError as e:
   586|                     log.error(e)
   587|             elif elem.tag == 'alias':
   588|                 datetime_formats = Alias(_translate_alias(
   589|                     ['datetime_formats'], elem.attrib['path'])
   590|                 )
   591|             elif elem.tag == 'availableFormats':
   592|                 for datetime_skeleton in elem.findall('dateFormatItem'):
   593|                     datetime_skeletons[datetime_skeleton.attrib['id']] = (
   594|                         dates.parse_pattern(text_type(datetime_skeleton.text))
   595|                     )
   596| def parse_number_symbols(data, tree):
   597|     number_symbols = data.setdefault('number_symbols', {})
   598|     for symbol_elem in tree.findall('.//numbers/symbols'):
   599|         if _should_skip_number_elem(data, symbol_elem):  # TODO: Support other number systems
   600|             continue
   601|         for elem in symbol_elem.findall('./*'):
   602|             if _should_skip_elem(elem):
   603|                 continue
   604|             number_symbols[elem.tag] = text_type(elem.text)
   605| def parse_decimal_formats(data, tree):
   606|     decimal_formats = data.setdefault('decimal_formats', {})

