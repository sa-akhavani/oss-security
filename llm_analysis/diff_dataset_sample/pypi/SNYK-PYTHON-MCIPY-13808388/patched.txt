# ====================================================================
# FILE: devtools/lint.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| import subprocess
     2| from funlog import log_calls
     3| from rich import get_console, reconfigure
     4| from rich import print as rprint
     5| SRC_PATHS = ["src", "devtools"]
     6| DOC_PATHS = ["README.md"]
     7| reconfigure(emoji=not get_console().options.legacy_windows)  # No emojis on legacy windows.
     8| def main():
     9|     rprint()
    10|     errcount = 0
    11|     errcount += run(["codespell", "--write-changes", *SRC_PATHS, *DOC_PATHS])
    12|     errcount += run(["ruff", "check", "--fix", *SRC_PATHS])
    13|     errcount += run(["ruff", "format", *SRC_PATHS])
    14|     errcount += run(["basedpyright", "--stats", *SRC_PATHS])
    15|     rprint()
    16|     if errcount != 0:
    17|         rprint(f"[bold red]:x: Lint failed with {errcount} errors.[/bold red]")
    18|     else:
    19|         rprint("[bold green]:white_check_mark: Lint passed![/bold green]")
    20|     rprint()
    21|     return errcount
    22| @log_calls(level="warning", show_timing_only=True)
    23| def run(cmd: list[str]) -> int:
    24|     rprint()
    25|     rprint(f"[bold green]>> {' '.join(cmd)}[/bold green]")


# ====================================================================
# FILE: example.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 18-71 ---
    18|     print("1. Initializing MCIClient with example.mci.json...")
    19|     client = MCIClient(
    20|         json_file_path="./example.mci.json",
    21|         env_vars={
    22|             "CURRENT_DATE": datetime.now().strftime("%Y-%m-%d"),
    23|             "API_KEY": "demo-api-key-123",
    24|             "USERNAME": "demo_user",
    25|         },
    26|     )
    27|     print("   ✓ Client initialized successfully")
    28|     print()
    29|     print("2. Listing available tools...")
    30|     tool_names = client.list_tools()
    31|     print(f"   Found {len(tool_names)} tools:")
    32|     for tool_name in tool_names:
    33|         print(f"   - {tool_name}")
    34|     print()
    35|     print("3. Executing 'generate_message' tool...")
    36|     print("   Input: username='Alice'")
    37|     result = client.execute(tool_name="generate_message", properties={"username": "Alice"})
    38|     if result.result.isError:
    39|         print(f"   ✗ Error: {result.result.content[0].text}")
    40|     else:
    41|         print(f"   ✓ Success!")
    42|         print(f"   Output: {result.result.content[0].text}")
    43|     print()
    44|     print("4. Executing 'load_template' tool...")
    45|     print("   Input: username='Bob'")
    46|     print("   Note: This tool reads from ./text.txt with template substitution")
    47|     result = client.execute(tool_name="load_template", properties={"username": "Bob", "new_prop": [1, 2, 3]})
    48|     if result.result.isError:
    49|         print(f"   ✗ Error: {result.result.content[0].text}")
    50|     else:
    51|         print(f"   ✓ Success!")
    52|         print(f"   Output: {result.result.content[0].text}")
    53|     print()
    54|     print("5. Demonstrating tool filtering...")
    55|     print("   Filtering to only 'load_template' and 'generate_message':")
    56|     filtered_tools = client.only(["load_template", "generate_message"])
    57|     print(f"   Found {len(filtered_tools)} tools:")
    58|     for tool in filtered_tools:
    59|         print(f"   - {tool.name}: {tool.title}")
    60|     print()
    61|     print("6. Getting tool schema...")
    62|     schema = client.get_tool_schema("generate_message")
    63|     print(f"   Schema for 'generate_message':")
    64|     print(f"   - Required properties: {schema.get('required', [])}")
    65|     print(f"   - Properties: {list(schema.get('properties', {}).keys())}")
    66|     print()
    67|     print("=" * 80)
    68|     print("Example completed successfully!")
    69|     print("=" * 80)
    70| if __name__ == "__main__":
    71|     main()


# ====================================================================
# FILE: examples/example_usage.py
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 34-192 ---
    34|     print("Example: Get weather tool (would make HTTP GET request)")
    35|     print("  Tool: get_weather")
    36|     print("  Would call: https://api.example.com/weather?location=Seattle&units=metric")
    37|     print()
    38|     print("Example: Create report tool (would make HTTP POST request)")
    39|     print("  Tool: create_report")
    40|     print("  Would call: https://api.example.com/reports")
    41|     print("  With Bearer authentication and JSON body")
    42|     print()
    43| def demo_cli_examples():
    44|     """Demonstrate CLI execution examples."""
    45|     print_section("CLI Execution Examples")
    46|     client = MCIClient(json_file_path="examples/cli_example.json")
    47|     print("Available CLI tools:")
    48|     for tool_name in client.list_tools():
    49|         print(f"  - {tool_name}")
    50|     print()
    51|     print("Executing: count_lines on README.md")
    52|     try:
    53|         result = client.execute(tool_name="count_lines", properties={"file_path": "README.md"})
    54|         if not result.result.isError:
    55|             print("  ✓ Success!")
    56|             print(f"  Output: {result.result.content[0].text.strip()}")
    57|         else:
    58|             print(f"  ✗ Error: {result.result.content[0].text}")
    59|     except Exception as e:
    60|         print(f"  ✗ Exception: {e}")
    61|     print()
    62|     print("Executing: list_files on current directory")
    63|     try:
    64|         result = client.execute(
    65|             tool_name="list_files", properties={"directory": ".", "show_hidden": False}
    66|         )
    67|         if not result.result.isError:
    68|             print("  ✓ Success!")
    69|             lines = result.result.content[0].text.strip().split("\n")
    70|             print("  Output (first 5 lines):")
    71|             for line in lines[:5]:
    72|                 print(f"    {line}")
    73|             if len(lines) > 5:
    74|                 print(f"    ... and {len(lines) - 5} more lines")
    75|         else:
    76|             print(f"  ✗ Error: {result.result.content[0].text}")
    77|     except Exception as e:
    78|         print(f"  ✗ Exception: {e}")
    79|     print()
    80| def demo_file_examples():
    81|     """Demonstrate file execution examples."""
    82|     print_section("File Execution Examples")
    83|     client = MCIClient(
    84|         json_file_path="examples/file_example.json",
    85|         env_vars={"CURRENT_DATE": datetime.now().strftime("%Y-%m-%d"), "USERNAME": "demo_user"},
    86|     )
    87|     print("Available File tools:")
    88|     for tool_name in client.list_tools():
    89|         print(f"  - {tool_name}")
    90|     print()
    91|     print("Executing: load_template")
    92|     print("  Note: This tool reads ./text.txt with placeholder substitution")
    93|     try:
    94|         result = client.execute(tool_name="load_template", properties={"username": "Alice"})
    95|         if not result.result.isError:
    96|             print("  ✓ Success!")
    97|             print(f"  Content preview: {result.result.content[0].text[:200]}...")
    98|         else:
    99|             print(f"  ✗ Error: {result.result.content[0].text}")
   100|             print("  (This is expected if text.txt doesn't exist)")
   101|     except Exception as e:
   102|         print(f"  ✗ Exception: {e}")
   103|     print()
   104| def demo_text_examples():
   105|     """Demonstrate text execution examples."""
   106|     print_section("Text Execution Examples")
   107|     client = MCIClient(
   108|         json_file_path="examples/text_example.json",
   109|         env_vars={
   110|             "CURRENT_DATE": datetime.now().strftime("%Y-%m-%d"),
   111|             "TIMESTAMP": datetime.now().isoformat(),
   112|             "APP_VERSION": "1.0.0",
   113|         },
   114|     )
   115|     print("Available Text tools:")
   116|     for tool_name in client.list_tools():
   117|         print(f"  - {tool_name}")
   118|     print()
   119|     print("Executing: generate_message")
   120|     result = client.execute(tool_name="generate_message", properties={"username": "Bob"})
   121|     if not result.result.isError:
   122|         print("  ✓ Success!")
   123|         print(f"  Output: {result.result.content[0].text}")
   124|     else:
   125|         print(f"  ✗ Error: {result.result.content[0].text}")
   126|     print()
   127|     print("Executing: generate_welcome")
   128|     result = client.execute(
   129|         tool_name="generate_welcome", properties={"username": "Alice", "email": "alice@example.com"}
   130|     )
   131|     if not result.result.isError:
   132|         print("  ✓ Success!")
   133|         print(f"  Output: {result.result.content[0].text}")
   134|     else:
   135|         print(f"  ✗ Error: {result.result.content[0].text}")
   136|     print()
   137|     print("Executing: status_message")
   138|     result = client.execute(tool_name="status_message", properties={"status": "operational"})
   139|     if not result.result.isError:
   140|         print("  ✓ Success!")
   141|         print(f"  Output: {result.result.content[0].text}")
   142|     else:
   143|         print(f"  ✗ Error: {result.result.content[0].text}")
   144|     print()
   145| def demo_mixed_examples():
   146|     """Demonstrate mixed execution examples (all types)."""
   147|     print_section("Mixed Execution Examples (All Types)")
   148|     client = MCIClient(
   149|         json_file_path="examples/mixed_example.json",
   150|         env_vars={
   151|             "CURRENT_DATE": datetime.now().strftime("%Y-%m-%d"),
   152|             "BEARER_TOKEN": "demo-bearer-token",
   153|         },
   154|     )
   155|     print("Available tools (all execution types):")
   156|     all_tools = client.tools()
   157|     for tool in all_tools:
   158|         print(f"  - {tool.name} ({tool.execution.type}): {tool.title}")
   159|     print()
   160|     print("Filtering to only text tools:")
   161|     text_tools = client.only(["generate_message", "generate_welcome"])
   162|     print(f"  Found {len(text_tools)} tools:")
   163|     for tool in text_tools:
   164|         print(f"  - {tool.name}")
   165|     print()
   166|     print("Executing: generate_message from mixed example")
   167|     result = client.execute(tool_name="generate_message", properties={"username": "Charlie"})
   168|     if not result.result.isError:
   169|         print("  ✓ Success!")
   170|         print(f"  Output: {result.result.content[0].text}")
   171|     else:
   172|         print(f"  ✗ Error: {result.result.content[0].text}")
   173|     print()
   174| def demo_tool_inspection():
   175|     """Demonstrate tool inspection capabilities."""
   176|     print_section("Tool Inspection")
   177|     client = MCIClient(json_file_path="examples/text_example.json")
   178|     print("Getting schema for 'generate_report_summary':")
   179|     schema = client.get_tool_schema("generate_report_summary")
   180|     print(f"  Required properties: {schema.get('required', [])}")
   181|     print("  Properties:")
   182|     for prop_name, prop_details in schema.get("properties", {}).items():
   183|         print(f"    - {prop_name}: {prop_details.get('description', 'No description')}")
   184|     print()
   185|     print("Getting full tool details:")
   186|     tools = client.tools()
   187|     for tool in tools[:2]:  # Show first 2 tools
   188|         print(f"\nTool: {tool.name}")
   189|         print(f"  Title: {tool.title}")
   190|         print(f"  Description: {tool.description}")
   191|         print(f"  Execution Type: {tool.execution.type}")
   192|         if hasattr(tool.execution, "text"):


# ====================================================================
# FILE: examples/toolsets_example_usage.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-91 ---
     1| """
     2| Example demonstrating the Toolsets feature.
     3| This example shows how to:
     4| - Load toolsets from a library directory
     5| - Apply schema-level filters to toolsets
     6| - Use adapter-level filtering with toolsets() method
     7| - Mix main schema tools with toolset tools
     8| - Filter by tags and names across all tools
     9| """
    10| from mcipy import MCIClient
    11| def print_section(title: str):
    12|     """Print a section header."""
    13|     print(f"\n{'=' * 70}")
    14|     print(f"  {title}")
    15|     print('=' * 70 + "\n")
    16| def print_tools(tools, prefix=""):
    17|     """Print tool names with their sources."""
    18|     for tool in tools:
    19|         source = f" (from {tool.toolset_source})" if tool.toolset_source else " (main)"
    20|         tags = f" [{', '.join(tool.tags)}]" if tool.tags else ""
    21|         print(f"{prefix}{tool.name}{source}{tags}")
    22| def main():
    23|     """Run toolsets example."""
    24|     print_section("Initializing MCI Client with Toolsets")
    25|     client = MCIClient(
    26|         schema_file_path="examples/toolsets_example.mci.json",
    27|         env_vars={
    28|             "APP_VERSION": "1.0.0",
    29|             "ENVIRONMENT": "development",
    30|             "DEBUG_MODE": "true"
    31|         }
    32|     )
    33|     print("✓ Client initialized with main schema and toolsets")
    34|     print_section("1. All Available Tools")
    35|     all_tools = client.tools()
    36|     print(f"Total: {len(all_tools)} tools\n")
    37|     print_tools(all_tools, "  ")
    38|     print_section("2. Filter by Toolset")
    39|     print("Weather toolset tools:")
    40|     weather_tools = client.toolsets(["weather"])
    41|     print_tools(weather_tools, "  ")
    42|     print("\nDatabase toolset tools:")
    43|     db_tools = client.toolsets(["database"])
    44|     print_tools(db_tools, "  ")
    45|     print("\nGitHub toolset tools:")
    46|     github_tools = client.toolsets(["github"])
    47|     print_tools(github_tools, "  ")
    48|     print_section("3. Multiple Toolsets")
    49|     api_tools = client.toolsets(["weather", "database"])
    50|     print(f"Weather + Database tools: {len(api_tools)}")
    51|     print_tools(api_tools, "  ")
    52|     print_section("4. Filter by Tags")
    53|     read_tools = client.tags(["read"])
    54|     print(f"Read-only tools: {len(read_tools)}")
    55|     print_tools(read_tools, "  ")
    56|     write_tools = client.tags(["write"])
    57|     print(f"\nWrite tools: {len(write_tools)}")
    58|     print_tools(write_tools, "  ")
    59|     print_section("5. Filter by Tool Names")
    60|     specific_tools = client.only(["app_status", "get_weather", "query_data"])
    61|     print(f"Specific tools: {len(specific_tools)}")
    62|     print_tools(specific_tools, "  ")
    63|     print_section("6. Exclude Specific Tools")
    64|     safe_tools = client.without(["delete_data"])
    65|     print(f"Tools without delete_data: {len(safe_tools)}")
    66|     print_tools(safe_tools, "  ")
    67|     print_section("7. Execute Tools from Different Sources")
    68|     print("Executing main schema tool (app_status):")
    69|     result1 = client.execute("app_status")
    70|     print(f"  → {result1.result.content[0].text}")
    71|     print("\nExecuting toolset tool (get_weather):")
    72|     result2 = client.execute("get_weather", {"location": "San Francisco"})
    73|     print(f"  → {result2.result.content[0].text}")
    74|     print("\nExecuting toolset tool (query_data):")
    75|     result3 = client.execute("query_data", {"query": "SELECT * FROM users"})
    76|     print(f"  → {result3.result.content[0].text}")
    77|     print_section("Summary")
    78|     print("""
    79| The Toolsets feature allows you to:
    80|   ✓ Organize tools into reusable libraries
    81|   ✓ Apply schema-level filters when loading toolsets
    82|   ✓ Filter tools by their source toolset at runtime
    83|   ✓ Mix main schema tools with toolset tools
    84|   ✓ Use all existing filtering methods (tags, only, without, etc.)
    85| See the documentation for more details:
    86|   - Schema Reference: docs/schema_reference.md
    87|   - API Reference: docs/api_reference.md
    88|   - Quickstart Guide: docs/quickstart.md
    89|     """)
    90| if __name__ == "__main__":
    91|     main()


# ====================================================================
# FILE: src/mcipy/__init__.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-61 ---
     1| from .client import MCIClient, MCIClientError
     2| from .enums import ExecutionType
     3| from .mcp_client import ClientCfg, LiteMcpClient, ServerCfg, SseCfg, StdioCfg
     4| from .models import (
     5|     Annotations,
     6|     ApiKeyAuth,
     7|     AudioContent,
     8|     BasicAuth,
     9|     BearerAuth,
    10|     CLIExecutionConfig,
    11|     ExecutionResult,
    12|     ExecutionResultContent,
    13|     FileExecutionConfig,
    14|     FlagConfig,
    15|     HTTPBodyConfig,
    16|     HTTPExecutionConfig,
    17|     ImageContent,
    18|     MCISchema,
    19|     Metadata,
    20|     OAuth2Auth,
    21|     RetryConfig,
    22|     TextContent,
    23|     TextExecutionConfig,
    24|     Tool,
    25| )
    26| from .parser import SchemaParser, SchemaParserError
    27| from .tool_manager import ToolManager, ToolManagerError
    28| __all__ = (
    29|     "MCIClient",
    30|     "MCIClientError",
    31|     "LiteMcpClient",
    32|     "ClientCfg",
    33|     "ServerCfg",
    34|     "StdioCfg",
    35|     "SseCfg",
    36|     "ExecutionType",
    37|     "Annotations",
    38|     "ApiKeyAuth",
    39|     "AudioContent",
    40|     "BasicAuth",
    41|     "BearerAuth",
    42|     "CLIExecutionConfig",
    43|     "ExecutionResult",
    44|     "ExecutionResultContent",
    45|     "FileExecutionConfig",
    46|     "FlagConfig",
    47|     "HTTPBodyConfig",
    48|     "HTTPExecutionConfig",
    49|     "ImageContent",
    50|     "MCISchema",
    51|     "Metadata",
    52|     "OAuth2Auth",
    53|     "RetryConfig",
    54|     "TextContent",
    55|     "TextExecutionConfig",
    56|     "Tool",
    57|     "SchemaParser",
    58|     "SchemaParserError",
    59|     "ToolManager",
    60|     "ToolManagerError",
    61| )


# ====================================================================
# FILE: src/mcipy/client.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 4-176 ---
     4| programmatic use of MCI tool contexts. It handles loading tool schemas,
     5| managing environment variables, filtering tools, and executing tools.
     6| """
     7| from typing import Any
     8| from .models import ExecutionResult, Tool
     9| from .parser import SchemaParser
    10| from .tool_manager import ToolManager, ToolManagerError
    11| class MCIClientError(Exception):
    12|     """Exception raised for MCI client errors."""
    13|     pass
    14| class MCIClient:
    15|     """
    16|     Main client for MCI adapter.
    17|     Provides the primary API for loading, filtering, and executing MCI tools.
    18|     Handles schema parsing, environment variable management, and tool execution
    19|     orchestration through the ToolManager.
    20|     Example:
    21|         ```python
    22|         from mcipy import MCIClient
    23|         client = MCIClient(
    24|             schema_file_path="example.mci.json",
    25|             env_vars={"API_KEY": "your-secret-key"}
    26|         )
    27|         client = MCIClient(
    28|             schema_file_path="example.mci.yaml",
    29|             env_vars={"API_KEY": "your-secret-key"}
    30|         )
    31|         tool_names = client.list_tools()
    32|         weather_tools = client.only(["get_weather", "get_forecast"])
    33|         safe_tools = client.without(["delete_data", "admin_tools"])
    34|         result = client.execute(
    35|             tool_name="get_weather",
    36|             properties={"location": "New York"}
    37|         )
    38|         ```
    39|     """
    40|     def __init__(
    41|         self,
    42|         schema_file_path: str | None = None,
    43|         env_vars: dict[str, Any] | None = None,
    44|         json_file_path: str | None = None,
    45|     ):
    46|         """
    47|         Initialize the MCI client with a schema file and environment variables.
    48|         Loads the MCI schema (JSON or YAML), stores environment variables for templating,
    49|         and initializes the ToolManager for tool execution.
    50|         Args:
    51|             schema_file_path: Path to the MCI schema file (.json, .yaml, or .yml)
    52|             env_vars: Environment variables for template substitution (default: empty dict)
    53|             json_file_path: DEPRECATED. Use schema_file_path instead. Kept for backward compatibility.
    54|         Raises:
    55|             MCIClientError: If the schema file cannot be loaded or parsed
    56|         """
    57|         if json_file_path is not None and schema_file_path is None:
    58|             schema_file_path = json_file_path
    59|         elif schema_file_path is None:
    60|             raise MCIClientError("Either 'schema_file_path' or 'json_file_path' must be provided")
    61|         self._schema_file_path = schema_file_path
    62|         self._env_vars = env_vars if env_vars is not None else {}
    63|         try:
    64|             self._schema = SchemaParser.parse_file(schema_file_path, env_vars=self._env_vars)
    65|         except Exception as e:
    66|             raise MCIClientError(f"Failed to load schema from {schema_file_path}: {e}") from e
    67|         self._tool_manager = ToolManager(self._schema, schema_file_path)
    68|     def tools(self) -> list[Tool]:
    69|         """
    70|         Get all available tools (excluding disabled tools).
    71|         Returns:
    72|             List of all enabled Tool objects in the schema
    73|         """
    74|         return self._tool_manager.list_tools()
    75|     def only(self, tool_names: list[str]) -> list[Tool]:
    76|         """
    77|         Filter to include only specified tools (excluding disabled tools).
    78|         Returns only the tools whose names are in the provided list and
    79|         are not disabled. Tools not in the list or that are disabled are excluded.
    80|         Args:
    81|             tool_names: List of tool names to include
    82|         Returns:
    83|             Filtered list of enabled Tool objects
    84|         """
    85|         return self._tool_manager.filter_tools(only=tool_names)
    86|     def without(self, tool_names: list[str]) -> list[Tool]:
    87|         """
    88|         Filter to exclude specified tools (disabled tools are also excluded).
    89|         Returns all enabled tools except those whose names are in the provided list.
    90|         Args:
    91|             tool_names: List of tool names to exclude
    92|         Returns:
    93|             Filtered list of enabled Tool objects
    94|         """
    95|         return self._tool_manager.filter_tools(without=tool_names)
    96|     def tags(self, tags: list[str]) -> list[Tool]:
    97|         """
    98|         Filter tools to include only those with at least one matching tag (excluding disabled tools).
    99|         Returns tools that have at least one tag matching any tag in the provided list.
   100|         Uses OR logic: a tool is included if it has any of the specified tags.
   101|         Tags are matched case-sensitively and exactly as provided.
   102|         Args:
   103|             tags: List of tags to filter by
   104|         Returns:
   105|             Filtered list of enabled Tool objects that have at least one matching tag
   106|         """
   107|         return self._tool_manager.tags(tags)
   108|     def withoutTags(self, tags: list[str]) -> list[Tool]:
   109|         """
   110|         Filter tools to exclude those with any matching tag (excluding disabled tools).
   111|         Returns tools that do NOT have any tags matching the provided list.
   112|         Uses OR logic for exclusion: a tool is excluded if it has any of the specified tags.
   113|         Tags are matched case-sensitively and exactly as provided.
   114|         Args:
   115|             tags: List of tags to exclude
   116|         Returns:
   117|             Filtered list of enabled Tool objects that do not have any of the specified tags
   118|         """
   119|         return self._tool_manager.withoutTags(tags)
   120|     def toolsets(self, toolset_names: list[str]) -> list[Tool]:
   121|         """
   122|         Filter tools to include only those from specified toolsets (excluding disabled tools).
   123|         Returns tools that were loaded from any of the specified toolsets.
   124|         Uses OR logic: a tool is included if it came from any of the specified toolsets.
   125|         Only tools that were registered by their toolset's schema-level filter are included.
   126|         Args:
   127|             toolset_names: List of toolset names to filter by
   128|         Returns:
   129|             Filtered list of enabled Tool objects from the specified toolsets
   130|         """
   131|         return self._tool_manager.toolsets(toolset_names)
   132|     def execute(self, tool_name: str, properties: dict[str, Any] | None = None) -> ExecutionResult:
   133|         """
   134|         Execute a tool by name with the provided properties.
   135|         Validates that the tool exists, builds the execution context from
   136|         properties and environment variables, and executes the tool using
   137|         the appropriate executor.
   138|         Args:
   139|             tool_name: Name of the tool to execute
   140|             properties: Properties/parameters to pass to the tool (default: empty dict)
   141|         Returns:
   142|             ExecutionResult with success/error status and content
   143|         Raises:
   144|             MCIClientError: If tool not found or execution fails with validation error
   145|         """
   146|         try:
   147|             return self._tool_manager.execute(
   148|                 tool_name=tool_name,
   149|                 properties=properties,
   150|                 env_vars=self._env_vars,
   151|             )
   152|         except ToolManagerError as e:
   153|             raise MCIClientError(str(e)) from e
   154|     def list_tools(self) -> list[str]:
   155|         """
   156|         List available tool names (excluding disabled tools).
   157|         Returns:
   158|             List of enabled tool names (strings)
   159|         """
   160|         return [tool.name for tool in self._tool_manager.list_tools()]
   161|     def get_tool_schema(self, tool_name: str) -> dict[str, Any]:
   162|         """
   163|         Get a tool's input schema.
   164|         Returns the JSON schema that defines the expected input properties
   165|         for the specified tool.
   166|         Args:
   167|             tool_name: Name of the tool
   168|         Returns:
   169|             Tool's input schema as a dictionary (or empty dict if no schema)
   170|         Raises:
   171|             MCIClientError: If tool not found
   172|         """
   173|         tool = self._tool_manager.get_tool(tool_name)
   174|         if tool is None:
   175|             raise MCIClientError(f"Tool not found: {tool_name}")
   176|         return tool.inputSchema if tool.inputSchema is not None else {}


# ====================================================================
# FILE: src/mcipy/enums.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-21 ---
     1| """
     2| Execution type enumerations for MCI.
     3| This module defines the execution types supported by the MCI adapter,
     4| including HTTP requests, CLI commands, file reading, and text templates.
     5| """
     6| from enum import Enum
     7| class ExecutionType(str, Enum):
     8|     """
     9|     Defines the types of execution supported by MCI.
    10|     Each execution type corresponds to a different way of executing a tool:
    11|     - HTTP: Make HTTP requests to APIs
    12|     - CLI: Execute command-line tools
    13|     - FILE: Read and parse files
    14|     - TEXT: Return text with placeholder substitution
    15|     - MCP: Execute tools via Model Context Protocol servers
    16|     """
    17|     HTTP = "http"
    18|     CLI = "cli"
    19|     FILE = "file"
    20|     TEXT = "text"
    21|     MCP = "mcp"


# ====================================================================
# FILE: src/mcipy/executors/__init__.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-72 ---
     1| """
     2| Execution handlers for MCI tools.
     3| This module provides the executor classes that handle different types of
     4| tool execution (HTTP, CLI, file, text, MCP). Each executor inherits from BaseExecutor
     5| and implements the execute() method according to its execution type.
     6| The ExecutorFactory provides centralized instantiation of executors based on
     7| execution type, with singleton caching for performance.
     8| """
     9| from typing import Any
    10| from ..enums import ExecutionType
    11| from .base import BaseExecutor
    12| from .cli_executor import CLIExecutor
    13| from .file_executor import FileExecutor
    14| from .http_executor import HTTPExecutor
    15| from .mcp_executor import MCPExecutor
    16| from .text_executor import TextExecutor
    17| class ExecutorFactory:
    18|     """
    19|     Factory for creating and caching executor instances.
    20|     Provides centralized instantiation of executors based on execution type.
    21|     Uses singleton pattern to cache executor instances for better performance.
    22|     MCP executors are not cached as they require server configuration.
    23|     """
    24|     _executors: dict[ExecutionType, BaseExecutor] = {}
    25|     @classmethod
    26|     def get_executor(
    27|         cls, execution_type: ExecutionType, mcp_servers: dict[str, Any] | None = None
    28|     ) -> BaseExecutor:
    29|         """
    30|         Get an executor instance for the given execution type.
    31|         Returns a cached executor instance if available (except for MCP),
    32|         otherwise creates a new one and caches it for future use.
    33|         Args:
    34|             execution_type: The type of execution (HTTP, CLI, FILE, TEXT, MCP)
    35|             mcp_servers: Dictionary of MCP server configurations (required for MCP executor)
    36|         Returns:
    37|             BaseExecutor instance for the specified type
    38|         Raises:
    39|             ValueError: If the execution type is not supported
    40|         """
    41|         if execution_type == ExecutionType.MCP:
    42|             return MCPExecutor(mcp_servers=mcp_servers)
    43|         if execution_type in cls._executors:
    44|             return cls._executors[execution_type]
    45|         if execution_type == ExecutionType.HTTP:
    46|             executor = HTTPExecutor()
    47|         elif execution_type == ExecutionType.CLI:
    48|             executor = CLIExecutor()
    49|         elif execution_type == ExecutionType.FILE:
    50|             executor = FileExecutor()
    51|         elif execution_type == ExecutionType.TEXT:
    52|             executor = TextExecutor()
    53|         else:
    54|             raise ValueError(f"Unsupported execution type: {execution_type}")
    55|         cls._executors[execution_type] = executor
    56|         return executor
    57|     @classmethod
    58|     def clear_cache(cls) -> None:
    59|         """
    60|         Clear the executor cache.
    61|         Useful for testing or when you want to ensure fresh executor instances.
    62|         """
    63|         cls._executors.clear()
    64| __all__ = [
    65|     "BaseExecutor",
    66|     "CLIExecutor",
    67|     "ExecutorFactory",
    68|     "FileExecutor",
    69|     "HTTPExecutor",
    70|     "MCPExecutor",
    71|     "TextExecutor",
    72| ]


# ====================================================================
# FILE: src/mcipy/executors/base.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-33 ---
     1| """
     2| Base executor class for MCI tool execution.
     3| This module provides the abstract BaseExecutor class that all executors inherit from.
     4| It provides common functionality for context building, timeout handling, and error formatting.
     5| """
     6| from abc import ABC, abstractmethod
     7| from typing import Any
     8| from ..models import (
     9|     ExecutionConfig,
    10|     ExecutionResult,
    11|     ExecutionResultContent,
    12|     TextContent,
    13| )
    14| from ..templating import TemplateEngine
    15| class BaseExecutor(ABC):
    16|     """
    17|     Abstract base class for all executors.
    18|     Provides common execution logic including context building, timeout handling,
    19|     and error formatting. All concrete executors (HTTP, CLI, File, Text) inherit
    20|     from this base class and implement the execute() method.
    21|     """
    22|     def __init__(self):
    23|         """Initialize the base executor with a template engine."""
    24|         self.template_engine = TemplateEngine()
    25|     @abstractmethod
    26|     def execute(self, config: ExecutionConfig, context: dict[str, Any]) -> ExecutionResult:
    27|         """
    28|         Execute a tool with the given configuration and context.
    29|         This is an abstract method that must be implemented by all concrete executors.
    30|         Args:
    31|             config: Execution configuration specific to the executor type
    32|             context: Context dictionary with 'props', 'env', and 'input' keys
    33|         Returns:

# --- HUNK 2: Lines 54-104 ---
    54|             "input": props,  # Alias for backward compatibility
    55|         }
    56|     def _handle_timeout(self, timeout_ms: int) -> int:
    57|         """
    58|         Convert timeout from milliseconds to seconds and apply defaults.
    59|         If timeout_ms is 0 or negative, returns a default timeout of 30 seconds.
    60|         Otherwise converts milliseconds to seconds (rounding up).
    61|         Args:
    62|             timeout_ms: Timeout in milliseconds
    63|         Returns:
    64|             Timeout in seconds (minimum 1 second)
    65|         """
    66|         if timeout_ms <= 0:
    67|             return 30  # Default timeout of 30 seconds
    68|         timeout_s = max(1, (timeout_ms + 999) // 1000)
    69|         return timeout_s
    70|     def _format_error(self, error: Exception) -> ExecutionResult:
    71|         """
    72|         Format an exception into a standardized ExecutionResult error response.
    73|         Converts any exception into a consistent error format with isError=True
    74|         and the error message as a text content object.
    75|         Args:
    76|             error: Exception that occurred during execution
    77|         Returns:
    78|             ExecutionResult with isError=True and error message
    79|         """
    80|         return ExecutionResult(
    81|             result=ExecutionResultContent(
    82|                 isError=True,
    83|                 content=[TextContent(text=str(error))],
    84|             )
    85|         )
    86|     def _apply_basic_templating_to_config(
    87|         self, config: ExecutionConfig, context: dict[str, Any]
    88|     ) -> None:
    89|         """
    90|         Apply basic templating to all string fields in the execution config.
    91|         Recursively processes the config object and replaces placeholders like
    92|         {{props.x}} and {{env.Y}} in all string fields. This is applied to
    93|         the entire execution configuration (URLs, paths, headers, params, etc.)
    94|         but NOT to large text content which uses advanced templating.
    95|         Args:
    96|             config: Execution configuration to process (modified in-place)
    97|             context: Context dictionary for template resolution
    98|         Note:
    99|             This method modifies the config object in-place.
   100|         """
   101|         for field_name, field_value in config.__dict__.items():
   102|             if field_value is None:
   103|                 continue
   104|             if isinstance(field_value, str):


# ====================================================================
# FILE: src/mcipy/executors/cli_executor.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-104 ---
     1| """
     2| CLI executor for MCI tools.
     3| This module provides the CLIExecutor class that handles CLI-based tool execution.
     4| It supports command execution with arguments, boolean and value flags, working directory,
     5| and timeout handling. The executor is platform-aware and handles Windows/Linux/macOS
     6| differences in command execution.
     7| """
     8| import subprocess
     9| from typing import Any
    10| from ..models import (
    11|     CLIExecutionConfig,
    12|     ExecutionConfig,
    13|     ExecutionResult,
    14|     ExecutionResultContent,
    15|     FlagConfig,
    16|     TextContent,
    17| )
    18| from .base import BaseExecutor
    19| class CLIExecutor(BaseExecutor):
    20|     """
    21|     Executor for CLI-based tools.
    22|     Handles command-line tool execution with support for arguments, flags,
    23|     working directory, and timeouts. Applies templating to all command components
    24|     and handles platform-specific differences.
    25|     """
    26|     def __init__(self):
    27|         """Initialize the CLI executor with a template engine."""
    28|         super().__init__()
    29|     def execute(self, config: ExecutionConfig, context: dict[str, Any]) -> ExecutionResult:
    30|         """
    31|         Execute a CLI-based tool by running a subprocess.
    32|         Args:
    33|             config: CLI execution configuration with command, args, flags, cwd, timeout
    34|             context: Context dictionary with 'props', 'env', 'input', and 'path_validation' keys
    35|         Returns:
    36|             ExecutionResult with command output or error
    37|         """
    38|         if not isinstance(config, CLIExecutionConfig):
    39|             return self._format_error(
    40|                 TypeError(f"Expected CLIExecutionConfig, got {type(config).__name__}")
    41|             )
    42|         try:
    43|             self._apply_basic_templating_to_config(config, context)
    44|             if context.get("path_validation") and config.cwd:
    45|                 validator = context["path_validation"]["validator"]
    46|                 from ..path_validator import PathValidationError
    47|                 try:
    48|                     validator.validate_path(config.cwd)
    49|                 except PathValidationError as e:
    50|                     return self._format_error(e)
    51|             command_list = self._build_command_args(config, context)
    52|             cwd = config.cwd if config.cwd else None
    53|             timeout = self._handle_timeout(config.timeout_ms)
    54|             stdout, stderr, returncode = self._run_subprocess(command_list, cwd, timeout)
    55|             stdout_bytes = len(stdout.encode())
    56|             stderr_bytes = len(stderr.encode())
    57|             if returncode != 0:
    58|                 error_msg = f"Command exited with code {returncode}"
    59|                 if stderr:
    60|                     error_msg += f": {stderr}"
    61|                 return ExecutionResult(
    62|                     result=ExecutionResultContent(
    63|                         isError=True,
    64|                         content=[TextContent(text=error_msg)],
    65|                         metadata={
    66|                             "exit_code": returncode,
    67|                             "stdout_bytes": stdout_bytes,
    68|                             "stderr_bytes": stderr_bytes,
    69|                             "stderr": stderr,
    70|                             "stdout": stdout,
    71|                         },
    72|                     )
    73|                 )
    74|             return ExecutionResult(
    75|                 result=ExecutionResultContent(
    76|                     isError=False,
    77|                     content=[TextContent(text=stdout)],
    78|                     metadata={
    79|                         "exit_code": returncode,
    80|                         "stdout_bytes": stdout_bytes,
    81|                         "stderr_bytes": stderr_bytes,
    82|                         "stderr": stderr,
    83|                     },
    84|                 )
    85|             )
    86|         except Exception as e:
    87|             return self._format_error(e)
    88|     def _build_command_args(self, config: CLIExecutionConfig, context: dict[str, Any]) -> list[str]:
    89|         """
    90|         Build the full command list with arguments and flags.
    91|         Combines the command, arguments, and flags into a single list suitable
    92|         for subprocess execution. Handles both boolean and value flags.
    93|         Args:
    94|             config: CLI execution configuration
    95|             context: Context dictionary for flag resolution
    96|         Returns:
    97|             List of command components (command, args, flags)
    98|         """
    99|         command_list = [config.command]
   100|         if config.args:
   101|             command_list.extend(config.args)
   102|         if config.flags:
   103|             flag_args = self._apply_flags(config.flags, context)
   104|             command_list.extend(flag_args)


# ====================================================================
# FILE: src/mcipy/executors/file_executor.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-74 ---
     1| """
     2| File executor for MCI tools.
     3| This module provides the FileExecutor class that handles file-based tool execution.
     4| It reads files from disk and optionally applies templating to the content.
     5| """
     6| from pathlib import Path
     7| from typing import Any
     8| from ..models import (
     9|     ExecutionConfig,
    10|     ExecutionResult,
    11|     ExecutionResultContent,
    12|     FileExecutionConfig,
    13|     TextContent,
    14| )
    15| from .base import BaseExecutor
    16| class FileExecutor(BaseExecutor):
    17|     """
    18|     Executor for file-based tools.
    19|     Reads files from disk and optionally applies templating to the content.
    20|     Supports both basic placeholder substitution and advanced templating
    21|     with @for, @foreach, and @if directives when enableTemplating is true.
    22|     """
    23|     def __init__(self):
    24|         """Initialize the file executor with a template engine."""
    25|         super().__init__()
    26|     def execute(self, config: ExecutionConfig, context: dict[str, Any]) -> ExecutionResult:
    27|         """
    28|         Execute a file-based tool by reading and optionally templating file content.
    29|         Args:
    30|             config: File execution configuration with path and enableTemplating flag
    31|             context: Context dictionary with 'props', 'env', 'input', and 'path_validation' keys
    32|         Returns:
    33|             ExecutionResult with file content (possibly templated) or error
    34|         """
    35|         if not isinstance(config, FileExecutionConfig):
    36|             return self._format_error(
    37|                 TypeError(f"Expected FileExecutionConfig, got {type(config).__name__}")
    38|             )
    39|         try:
    40|             self._apply_basic_templating_to_config(config, context)
    41|             if context.get("path_validation"):
    42|                 validator = context["path_validation"]["validator"]
    43|                 from ..path_validator import PathValidationError
    44|                 try:
    45|                     validator.validate_path(config.path)
    46|                 except PathValidationError as e:
    47|                     return self._format_error(e)
    48|             content = self._read_file(config.path)
    49|             parsed_content = self._parse_content(content, context, config.enableTemplating)
    50|             return ExecutionResult(
    51|                 result=ExecutionResultContent(
    52|                     isError=False,
    53|                     content=[TextContent(text=parsed_content)],
    54|                 )
    55|             )
    56|         except Exception as e:
    57|             return self._format_error(e)
    58|     def _read_file(self, path: str) -> str:
    59|         """
    60|         Read the content of a file from disk.
    61|         Args:
    62|             path: Path to the file to read
    63|         Returns:
    64|             File content as a string
    65|         Raises:
    66|             FileNotFoundError: If the file does not exist
    67|             IOError: If the file cannot be read
    68|         """
    69|         file_path = Path(path)
    70|         if not file_path.exists():
    71|             raise FileNotFoundError(f"File not found: {path}")
    72|         if not file_path.is_file():
    73|             raise OSError(f"Path is not a file: {path}")
    74|         return file_path.read_text(encoding="utf-8")


# ====================================================================
# FILE: src/mcipy/executors/http_executor.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-47 ---
     1| """
     2| HTTP executor for MCI tools.
     3| This module provides the HTTPExecutor class that handles HTTP-based tool execution.
     4| It supports various HTTP methods, authentication types (API Key, Bearer, Basic, OAuth2),
     5| request body types (JSON, form, raw), and retry logic with exponential backoff.
     6| """
     7| import base64
     8| import json
     9| import time
    10| from collections.abc import Callable
    11| from typing import Any
    12| import requests
    13| from ..models import (
    14|     ApiKeyAuth,
    15|     AudioContent,
    16|     AuthConfig,
    17|     BasicAuth,
    18|     BearerAuth,
    19|     ExecutionConfig,
    20|     ExecutionResult,
    21|     ExecutionResultContent,
    22|     HTTPBodyConfig,
    23|     HTTPExecutionConfig,
    24|     ImageContent,
    25|     OAuth2Auth,
    26|     RetryConfig,
    27|     TextContent,
    28| )
    29| from .base import BaseExecutor
    30| class HTTPExecutor(BaseExecutor):
    31|     """
    32|     Executor for HTTP-based tools.
    33|     Handles HTTP requests with various authentication methods, body types,
    34|     and retry logic. Supports GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS methods.
    35|     """
    36|     def __init__(self):
    37|         """Initialize the HTTP executor with a template engine."""
    38|         super().__init__()
    39|     def execute(self, config: ExecutionConfig, context: dict[str, Any]) -> ExecutionResult:
    40|         """
    41|         Execute an HTTP-based tool by making an HTTP request.
    42|         Args:
    43|             config: HTTP execution configuration with URL, method, headers, auth, etc.
    44|             context: Context dictionary with 'props', 'env', and 'input' keys
    45|         Returns:
    46|             ExecutionResult with response content or error
    47|         """

# --- HUNK 2: Lines 72-159 ---
    72|                 "timeout": self._handle_timeout(config.timeout_ms),
    73|             }
    74|             if config.headers:
    75|                 request_kwargs["headers"] = config.headers.copy()
    76|             if config.params:
    77|                 request_kwargs["params"] = config.params
    78|             if config.auth:
    79|                 self._apply_authentication(config.auth, request_kwargs)
    80|             if config.body:
    81|                 body_data, content_type = self._build_body(config.body, context)
    82|                 if body_data is not None:
    83|                     if config.body.type == "json":
    84|                         request_kwargs["json"] = body_data
    85|                     elif config.body.type == "form":
    86|                         request_kwargs["data"] = body_data
    87|                     else:  # raw
    88|                         request_kwargs["data"] = body_data
    89|                     if content_type and "headers" in request_kwargs:
    90|                         if "Content-Type" not in request_kwargs["headers"]:
    91|                             request_kwargs["headers"]["Content-Type"] = content_type
    92|             start_time = time.time()
    93|             if config.retries:
    94|                 response = self._apply_retry_logic(
    95|                     lambda: requests.request(**request_kwargs),
    96|                     config.retries,
    97|                 )
    98|             else:
    99|                 response = requests.request(**request_kwargs)
   100|             response_time_ms = int((time.time() - start_time) * 1000)
   101|             response.raise_for_status()
   102|             metadata = {
   103|                 "status_code": response.status_code,
   104|                 "response_time_ms": response_time_ms,
   105|             }
   106|             content_objects = self._parse_response_content(response)
   107|             return ExecutionResult(
   108|                 result=ExecutionResultContent(
   109|                     isError=False,
   110|                     content=content_objects,
   111|                     metadata=metadata,
   112|                 )
   113|             )
   114|         except Exception as e:
   115|             return self._format_error(e)
   116|     def _parse_response_content(
   117|         self, response: requests.Response
   118|     ) -> list[TextContent | ImageContent | AudioContent]:
   119|         """
   120|         Parse HTTP response into structured content objects.
   121|         Handles various content types including JSON, text, and images.
   122|         Returns appropriate content objects based on the response type.
   123|         Args:
   124|             response: HTTP response object
   125|         Returns:
   126|             List of content objects (TextContent or ImageContent)
   127|         """
   128|         content_type = response.headers.get("Content-Type", "").lower()
   129|         if content_type.startswith("image/"):
   130|             image_data = base64.b64encode(response.content).decode("utf-8")
   131|             return [ImageContent(data=image_data, mimeType=content_type.split(";")[0])]
   132|         if "application/json" in content_type:
   133|             try:
   134|                 json_data = response.json()
   135|                 text = json.dumps(json_data, indent=2)
   136|                 return [TextContent(text=text)]
   137|             except ValueError:
   138|                 pass
   139|         return [TextContent(text=response.text)]
   140|     def _apply_authentication(self, auth: AuthConfig, request_kwargs: dict[str, Any]) -> None:
   141|         """
   142|         Apply authentication configuration to the request.
   143|         Dispatches to the appropriate auth handler based on auth type.
   144|         Args:
   145|             auth: Authentication configuration
   146|             request_kwargs: Request keyword arguments dictionary (modified in-place)
   147|         """
   148|         if isinstance(auth, ApiKeyAuth):
   149|             self._handle_api_key_auth(auth, request_kwargs)
   150|         elif isinstance(auth, BearerAuth):
   151|             self._handle_bearer_auth(auth, request_kwargs)
   152|         elif isinstance(auth, BasicAuth):
   153|             self._handle_basic_auth(auth, request_kwargs)
   154|         elif isinstance(auth, OAuth2Auth):  # pyright: ignore[reportUnnecessaryIsInstance]
   155|             self._handle_oauth2_auth(auth, request_kwargs)
   156|     def _handle_api_key_auth(self, auth: ApiKeyAuth, request_kwargs: dict[str, Any]) -> None:
   157|         """
   158|         Apply API Key authentication to the request.
   159|         API keys can be placed in headers or query parameters.


# ====================================================================
# FILE: src/mcipy/executors/mcp_executor.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-125 ---
     1| """
     2| MCP executor for executing tools via Model Context Protocol servers.
     3| This module provides the MCPExecutor class for executing tools on MCP servers,
     4| handling both STDIO and HTTP transports, and managing connections and tool calls.
     5| """
     6| import asyncio
     7| from typing import Any
     8| from ..models import (
     9|     ExecutionConfig,
    10|     ExecutionResult,
    11|     ExecutionResultContent,
    12|     MCPExecutionConfig,
    13|     TextContent,
    14| )
    15| from .base import BaseExecutor
    16| class MCPExecutorError(Exception):
    17|     """Exception raised for MCP executor errors."""
    18|     pass
    19| class MCPExecutor(BaseExecutor):
    20|     """
    21|     Executor for MCP (Model Context Protocol) tools.
    22|     Connects to MCP servers via STDIO or HTTP transports and executes tools
    23|     using the MCP protocol. Handles connection management, tool calls, and
    24|     result formatting.
    25|     """
    26|     def __init__(self, mcp_servers: dict[str, Any] | None = None):
    27|         """
    28|         Initialize the MCP executor with MCP server configurations.
    29|         Args:
    30|             mcp_servers: Dictionary of MCP server configurations from main schema
    31|         """
    32|         super().__init__()
    33|         self.mcp_servers = mcp_servers or {}
    34|     def execute(self, config: ExecutionConfig, context: dict[str, Any]) -> ExecutionResult:
    35|         """
    36|         Execute an MCP tool by connecting to the server and calling the tool.
    37|         Args:
    38|             config: MCP execution configuration with server and tool names
    39|             context: Execution context with properties and environment variables
    40|         Returns:
    41|             ExecutionResult with tool execution results
    42|         Raises:
    43|             MCPExecutorError: If server is not registered or execution fails
    44|         """
    45|         if not isinstance(config, MCPExecutionConfig):
    46|             return self._format_error(
    47|                 MCPExecutorError(
    48|                     f"Invalid config type: expected MCPExecutionConfig, got {type(config)}"
    49|                 )
    50|             )
    51|         if config.serverName not in self.mcp_servers:
    52|             return self._format_error(
    53|                 MCPExecutorError(f"MCP server '{config.serverName}' not registered in main schema")
    54|             )
    55|         server_config = self.mcp_servers[config.serverName]
    56|         try:
    57|             result = asyncio.run(self._async_execute(config, context, server_config))
    58|             return result
    59|         except Exception as e:
    60|             return self._format_error(e)
    61|     async def _async_execute(
    62|         self, config: MCPExecutionConfig, context: dict[str, Any], server_config: Any
    63|     ) -> ExecutionResult:
    64|         """
    65|         Async implementation of MCP tool execution.
    66|         Connects to MCP server, calls the tool, and returns formatted results.
    67|         """
    68|         from mcp import ClientSession
    69|         from mcp.client.stdio import StdioServerParameters, stdio_client
    70|         from mcp.client.streamable_http import streamablehttp_client
    71|         from ..templating import TemplateEngine
    72|         template_engine = TemplateEngine()
    73|         from ..mcp_integration import MCPIntegration
    74|         templated_config = MCPIntegration._apply_templating_to_config(
    75|             server_config, context, template_engine
    76|         )
    77|         from ..models import StdioMCPServer
    78|         if isinstance(templated_config, StdioMCPServer):
    79|             import os
    80|             merged_env = os.environ.copy()
    81|             merged_env.update(templated_config.env)
    82|             params = StdioServerParameters(
    83|                 command=templated_config.command, args=templated_config.args, env=merged_env
    84|             )
    85|             transport_ctx = stdio_client(params)
    86|         else:
    87|             transport_ctx = streamablehttp_client(
    88|                 templated_config.url, headers=templated_config.headers or None
    89|             )
    90|         try:
    91|             async with transport_ctx as context_result:
    92|                 read, write = context_result[0], context_result[1]
    93|                 async with ClientSession(read, write) as session:
    94|                     await session.initialize()
    95|                     tool_args = context.get("props", {})
    96|                     result = await session.call_tool(config.toolName, arguments=tool_args)
    97|                     content_objects = []
    98|                     for content_item in result.content:
    99|                         if content_item.type == "text":
   100|                             content_objects.append(TextContent(text=content_item.text))
   101|                         elif content_item.type == "image":
   102|                             from ..models import ImageContent
   103|                             content_objects.append(
   104|                                 ImageContent(data=content_item.data, mimeType=content_item.mimeType)
   105|                             )
   106|                         elif content_item.type == "audio":
   107|                             from ..models import AudioContent
   108|                             content_objects.append(
   109|                                 AudioContent(data=content_item.data, mimeType=content_item.mimeType)
   110|                             )
   111|                         else:
   112|                             content_objects.append(TextContent(text=str(content_item)))
   113|                     jsonrpc_value = getattr(result, "jsonrpc", None)
   114|                     id_value = getattr(result, "id", None)
   115|                     return ExecutionResult(
   116|                         result=ExecutionResultContent(
   117|                             content=content_objects,
   118|                             isError=getattr(result, "isError", False),
   119|                             metadata={"mcp_server": config.serverName, "mcp_tool": config.toolName},
   120|                         ),
   121|                         jsonrpc=jsonrpc_value,
   122|                         id=id_value,
   123|                     )
   124|         except Exception as e:
   125|             raise MCPExecutorError(f"Failed to execute MCP tool '{config.toolName}': {e}") from e


# ====================================================================
# FILE: src/mcipy/executors/text_executor.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-48 ---
     1| """
     2| Text executor for MCI tools.
     3| This module provides the TextExecutor class that handles simple text-based tool execution.
     4| It applies templating to text strings and returns the result.
     5| """
     6| from typing import Any
     7| from ..models import (
     8|     ExecutionConfig,
     9|     ExecutionResult,
    10|     ExecutionResultContent,
    11|     TextContent,
    12|     TextExecutionConfig,
    13| )
    14| from .base import BaseExecutor
    15| class TextExecutor(BaseExecutor):
    16|     """
    17|     Executor for text-based tools.
    18|     Applies templating to text strings, supporting both basic placeholder
    19|     substitution and advanced templating with @for, @foreach, and @if directives.
    20|     """
    21|     def __init__(self):
    22|         """Initialize the text executor with a template engine."""
    23|         super().__init__()
    24|     def execute(self, config: ExecutionConfig, context: dict[str, Any]) -> ExecutionResult:
    25|         """
    26|         Execute a text-based tool by applying templating to the text.
    27|         Processes the text with advanced templating, supporting all directives
    28|         (@for, @foreach, @if) along with basic placeholder substitution.
    29|         Args:
    30|             config: Text execution configuration with the text template
    31|             context: Context dictionary with 'props', 'env', and 'input' keys
    32|         Returns:
    33|             ExecutionResult with templated text or error
    34|         """
    35|         if not isinstance(config, TextExecutionConfig):
    36|             return self._format_error(
    37|                 TypeError(f"Expected TextExecutionConfig, got {type(config).__name__}")
    38|             )
    39|         try:
    40|             result = self.template_engine.render_advanced(config.text, context)
    41|             return ExecutionResult(
    42|                 result=ExecutionResultContent(
    43|                     isError=False,
    44|                     content=[TextContent(text=result)],
    45|                 )
    46|             )
    47|         except Exception as e:
    48|             return self._format_error(e)


# ====================================================================
# FILE: src/mcipy/mcp_client.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-157 ---
     1| """
     2| LiteMcpClient - Lightweight MCP client integration using official mcp package.
     3| This module provides a minimal, robust client for connecting to MCP tool servers
     4| via STDIO (e.g., uvx/npx) and HTTP/SSE endpoints. It leverages the official `mcp`
     5| package to handle server communication and tool management.
     6| The LiteMcpClient allows seamless access to MCP tool servers for listing and
     7| calling tools with full support for both local STDIO-based servers and web-based
     8| HTTP/streamable endpoints.
     9| """
    10| from __future__ import annotations
    11| import os
    12| from typing import Any, Literal
    13| from mcp import ClientSession, StdioServerParameters
    14| from mcp.client.stdio import stdio_client
    15| from mcp.client.streamable_http import streamablehttp_client
    16| from pydantic import BaseModel, Field, HttpUrl
    17| class StdioCfg(BaseModel):
    18|     """
    19|     Configuration for STDIO-based MCP servers.
    20|     Used for local servers started via command-line tools like uvx or npx.
    21|     Supports environment variable injection for credentials and configuration.
    22|     """
    23|     type: Literal["stdio"] = "stdio"
    24|     command: str = Field(..., description="Command to run (e.g., 'uvx', 'npx', or direct path)")
    25|     args: list[str] = Field(default_factory=list, description="Arguments to pass to the command")
    26|     env: dict[str, str] = Field(
    27|         default_factory=dict, description="Environment variables for the server process"
    28|     )
    29| class SseCfg(BaseModel):
    30|     """
    31|     Configuration for HTTP/SSE-based MCP servers.
    32|     Used for web-based MCP servers using HTTP with Server-Sent Events (SSE)
    33|     or modern Streamable HTTP transport. Supports custom headers for authentication.
    34|     """
    35|     type: Literal["http"] = "http"
    36|     url: HttpUrl = Field(..., description="Server URL (e.g., 'http://localhost:8000/mcp')")
    37|     headers: dict[str, str] = Field(
    38|         default_factory=dict, description="HTTP headers for authentication"
    39|     )
    40| ServerCfg = StdioCfg | SseCfg
    41| class ClientCfg(BaseModel):
    42|     """
    43|     Complete configuration for the LiteMcpClient.
    44|     Wraps the server configuration with optional request timeout settings.
    45|     """
    46|     server: ServerCfg = Field(..., description="Server connection configuration")
    47|     request_timeout: float | None = Field(default=60.0, description="Request timeout in seconds")
    48| class LiteMcpClient:
    49|     """
    50|     Lightweight MCP client for connecting to MCP tool servers.
    51|     Provides async context manager interface for managing connections to both
    52|     STDIO-based and HTTP/SSE-based MCP servers. Supports listing and calling
    53|     tools with full error handling.
    54|     Example:
    55|         ```python
    56|         import asyncio
    57|         from mcipy.mcp_client import LiteMcpClient, ClientCfg, StdioCfg
    58|         async def main():
    59|             cfg = ClientCfg(server=StdioCfg(
    60|                 command="uvx",
    61|                 args=["mcp-browser"]
    62|             ))
    63|             async with LiteMcpClient(cfg) as client:
    64|                 tools = await client.list_tools()
    65|                 print(f"Available tools: {tools}")
    66|                 if tools:
    67|                     result = await client.call_tool(tools[0], param1="value")
    68|                     print(f"Result: {result}")
    69|         asyncio.run(main())
    70|         ```
    71|     """
    72|     def __init__(self, cfg: ClientCfg):
    73|         """
    74|         Initialize the LiteMcpClient with configuration.
    75|         Args:
    76|             cfg: Client configuration specifying server type and connection details
    77|         """
    78|         self.cfg = cfg
    79|         self._ctx = None
    80|         self._read = None
    81|         self._write = None
    82|         self.session: ClientSession | None = None
    83|     async def __aenter__(self) -> LiteMcpClient:
    84|         """
    85|         Async context manager entry - establish connection to MCP server.
    86|         Returns:
    87|             The initialized client instance with active session
    88|         """
    89|         try:
    90|             srv = self.cfg.server
    91|             if isinstance(srv, StdioCfg):
    92|                 merged_env = os.environ.copy()
    93|                 merged_env.update(srv.env)
    94|                 params = StdioServerParameters(command=srv.command, args=srv.args, env=merged_env)
    95|                 self._ctx = stdio_client(params)
    96|             else:
    97|                 self._ctx = streamablehttp_client(str(srv.url), headers=srv.headers or None)
    98|             context_result = await self._ctx.__aenter__()
    99|             self._read, self._write = context_result[0], context_result[1]
   100|             self.session = ClientSession(self._read, self._write)
   101|             await self.session.__aenter__()
   102|             await self.session.initialize()
   103|             return self
   104|         except Exception:
   105|             await self.__aexit__(None, None, None)
   106|             raise
   107|     async def __aexit__(self, *exc) -> None:
   108|         """
   109|         Async context manager exit - clean up connection.
   110|         Args:
   111|             exc: Exception information if an error occurred
   112|         """
   113|         if self.session:
   114|             try:
   115|                 await self.session.__aexit__(*exc)
   116|             except Exception:
   117|                 pass
   118|             finally:
   119|                 self.session = None
   120|         if self._ctx:
   121|             try:
   122|                 await self._ctx.__aexit__(*exc)
   123|             except Exception:
   124|                 pass
   125|             finally:
   126|                 self._ctx = None
   127|     async def list_tools(self) -> list[str]:
   128|         """
   129|         List all available tools from the MCP server.
   130|         Returns:
   131|             List of tool names available on the server
   132|         Raises:
   133|             RuntimeError: If session is not initialized (client not used as context manager)
   134|         """
   135|         if not self.session:
   136|             raise RuntimeError(
   137|                 "Session not initialized. Use LiteMcpClient as an async context manager."
   138|             )
   139|         resp = await self.session.list_tools()
   140|         return [t.name for t in resp.tools]
   141|     async def call_tool(self, name: str, **arguments: Any) -> Any:
   142|         """
   143|         Call a tool on the MCP server with the provided arguments.
   144|         Args:
   145|             name: Name of the tool to call
   146|             **arguments: Keyword arguments to pass to the tool
   147|         Returns:
   148|             The tool execution result from the server
   149|         Raises:
   150|             RuntimeError: If session is not initialized (client not used as context manager)
   151|         """
   152|         if not self.session:
   153|             raise RuntimeError(
   154|                 "Session not initialized. Use LiteMcpClient as an async context manager."
   155|             )
   156|         result = await self.session.call_tool(name, arguments=arguments)
   157|         return result


# ====================================================================
# FILE: src/mcipy/mcp_integration.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-205 ---
     1| """
     2| MCP Integration - Handles fetching and building toolsets from MCP servers.
     3| This module provides the MCPIntegration class for interacting with MCP servers,
     4| fetching their tool definitions, and building MCI-compatible toolset schemas.
     5| """
     6| import asyncio
     7| from datetime import UTC, datetime, timedelta
     8| from typing import Any
     9| from .enums import ExecutionType
    10| from .models import (
    11|     Annotations,
    12|     HttpMCPServer,
    13|     MCPExecutionConfig,
    14|     Metadata,
    15|     StdioMCPServer,
    16|     Tool,
    17|     ToolsetSchema,
    18| )
    19| from .templating import TemplateEngine
    20| class MCPIntegrationError(Exception):
    21|     """Exception raised for MCP integration errors."""
    22|     pass
    23| class MCPIntegration:
    24|     """
    25|     Handles MCP server integration and toolset generation.
    26|     Provides methods to fetch tools from MCP servers (STDIO and HTTP),
    27|     build MCI-compatible toolsets, and manage toolset metadata.
    28|     """
    29|     @staticmethod
    30|     def _annotations_to_tags(mcp_annotations: Any) -> list[str]:
    31|         """
    32|         Convert MCP tool annotations to MCI tags.
    33|         Converts boolean annotation hints (readOnlyHint, destructiveHint, etc.) to
    34|         standardized tags. Also handles audience annotations if present.
    35|         Args:
    36|             mcp_annotations: MCP ToolAnnotations object
    37|         Returns:
    38|             List of tags derived from annotations
    39|         """
    40|         tags: list[str] = []
    41|         if not mcp_annotations:
    42|             return tags
    43|         if mcp_annotations.readOnlyHint:
    44|             tags.append("IsReadOnly")
    45|         if mcp_annotations.destructiveHint:
    46|             tags.append("IsDestructive")
    47|         if mcp_annotations.idempotentHint:
    48|             tags.append("IsIdempotent")
    49|         if mcp_annotations.openWorldHint:
    50|             tags.append("IsOpenWorld")
    51|         if hasattr(mcp_annotations, "audience") and mcp_annotations.audience:
    52|             for role in mcp_annotations.audience:
    53|                 tags.append(f"audience_{role}")
    54|         return tags
    55|     @staticmethod
    56|     def fetch_and_build_toolset(
    57|         server_name: str,
    58|         server_config: StdioMCPServer | HttpMCPServer,
    59|         schema_version: str,
    60|         env_context: dict[str, Any],
    61|         template_engine: TemplateEngine,
    62|     ) -> ToolsetSchema:
    63|         """
    64|         Fetch tools from an MCP server and build a toolset schema.
    65|         Args:
    66|             server_name: Name of the MCP server
    67|             server_config: MCP server configuration (STDIO or HTTP)
    68|             schema_version: Schema version to use for the toolset
    69|             env_context: Environment context for templating
    70|             template_engine: Template engine for processing placeholders
    71|         Returns:
    72|             ToolsetSchema with tools from the MCP server and expiration date
    73|         Raises:
    74|             MCPIntegrationError: If MCP server connection or tool fetching fails
    75|         """
    76|         try:
    77|             return asyncio.run(
    78|                 MCPIntegration._async_fetch_and_build_toolset(
    79|                     server_name, server_config, schema_version, env_context, template_engine
    80|                 )
    81|             )
    82|         except Exception as e:
    83|             raise MCPIntegrationError(
    84|                 f"Failed to fetch from MCP server '{server_name}': {e}"
    85|             ) from e
    86|     @staticmethod
    87|     async def _async_fetch_and_build_toolset(
    88|         server_name: str,
    89|         server_config: StdioMCPServer | HttpMCPServer,
    90|         schema_version: str,
    91|         env_context: dict[str, Any],
    92|         template_engine: TemplateEngine,
    93|     ) -> ToolsetSchema:
    94|         """
    95|         Async implementation of fetch_and_build_toolset.
    96|         Connects to MCP server, fetches tools, and builds toolset schema.
    97|         """
    98|         from mcp import ClientSession
    99|         from mcp.client.stdio import StdioServerParameters, stdio_client
   100|         from mcp.client.streamable_http import streamablehttp_client
   101|         templated_config = MCPIntegration._apply_templating_to_config(
   102|             server_config, env_context, template_engine
   103|         )
   104|         if isinstance(templated_config, StdioMCPServer):
   105|             import os
   106|             merged_env = os.environ.copy()
   107|             merged_env.update(templated_config.env)
   108|             params = StdioServerParameters(
   109|                 command=templated_config.command, args=templated_config.args, env=merged_env
   110|             )
   111|             transport_ctx = stdio_client(params)
   112|         else:
   113|             transport_ctx = streamablehttp_client(
   114|                 templated_config.url, headers=templated_config.headers or None
   115|             )
   116|         try:
   117|             async with transport_ctx as context_result:
   118|                 read, write = context_result[0], context_result[1]
   119|                 async with ClientSession(read, write) as session:
   120|                     await session.initialize()
   121|                     tools_response = await session.list_tools()
   122|                     mci_tools = []
   123|                     for mcp_tool in tools_response.tools:
   124|                         input_schema = None
   125|                         if mcp_tool.inputSchema:
   126|                             input_schema = mcp_tool.inputSchema
   127|                         annotations = Annotations()
   128|                         if mcp_tool.annotations:
   129|                             annotations.title = mcp_tool.annotations.title
   130|                             annotations.readOnlyHint = mcp_tool.annotations.readOnlyHint
   131|                             annotations.destructiveHint = mcp_tool.annotations.destructiveHint
   132|                             annotations.idempotentHint = mcp_tool.annotations.idempotentHint
   133|                             annotations.openWorldHint = mcp_tool.annotations.openWorldHint
   134|                             if hasattr(mcp_tool.annotations, "audience"):
   135|                                 audience_value = getattr(mcp_tool.annotations, "audience", None)
   136|                                 if audience_value:
   137|                                     annotations.audience = audience_value
   138|                         tags = MCPIntegration._annotations_to_tags(mcp_tool.annotations)
   139|                         mci_tool = Tool(
   140|                             name=mcp_tool.name,
   141|                             description=mcp_tool.description or "",
   142|                             annotations=annotations,
   143|                             inputSchema=input_schema,
   144|                             tags=tags,
   145|                             execution=MCPExecutionConfig(
   146|                                 type=ExecutionType.MCP,
   147|                                 serverName=server_name,
   148|                                 toolName=mcp_tool.name,
   149|                             ),
   150|                         )
   151|                         mci_tools.append(mci_tool)
   152|                     exp_days = templated_config.config.expDays
   153|                     expires_date = (datetime.now(UTC) + timedelta(days=exp_days)).date()
   154|                     metadata = Metadata(name=server_name, description=f"MCP server: {server_name}")
   155|                     toolset = ToolsetSchema(
   156|                         schemaVersion=schema_version,
   157|                         metadata=metadata,
   158|                         tools=mci_tools,
   159|                         expiresAt=expires_date.isoformat(),  # YYYY-MM-DD format
   160|                     )
   161|                     return toolset
   162|         except Exception as e:
   163|             raise MCPIntegrationError(
   164|                 f"Failed to connect to MCP server '{server_name}': {e}"
   165|             ) from e
   166|     @staticmethod
   167|     def _apply_templating_to_config(
   168|         server_config: StdioMCPServer | HttpMCPServer,
   169|         env_context: dict[str, Any],
   170|         template_engine: TemplateEngine,
   171|     ) -> StdioMCPServer | HttpMCPServer:
   172|         """
   173|         Apply templating to MCP server configuration.
   174|         Processes environment variable placeholders in server config fields.
   175|         Args:
   176|             server_config: MCP server configuration
   177|             env_context: Environment context for templating
   178|             template_engine: Template engine for processing placeholders
   179|         Returns:
   180|             Server configuration with templated values
   181|         """
   182|         if isinstance(server_config, StdioMCPServer):
   183|             templated_command = template_engine.render_basic(server_config.command, env_context)
   184|             templated_args = [
   185|                 template_engine.render_basic(arg, env_context) for arg in server_config.args
   186|             ]
   187|             templated_env = {
   188|                 key: template_engine.render_basic(value, env_context)
   189|                 for key, value in server_config.env.items()
   190|             }
   191|             return StdioMCPServer(
   192|                 command=templated_command,
   193|                 args=templated_args,
   194|                 env=templated_env,
   195|                 config=server_config.config,
   196|             )
   197|         else:
   198|             templated_url = template_engine.render_basic(server_config.url, env_context)
   199|             templated_headers = {
   200|                 key: template_engine.render_basic(value, env_context)
   201|                 for key, value in server_config.headers.items()
   202|             }
   203|             return HttpMCPServer(
   204|                 url=templated_url, headers=templated_headers, config=server_config.config
   205|             )


# ====================================================================
# FILE: src/mcipy/models.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-32 ---
     1| """
     2| Pydantic data models for MCI schema validation.
     3| This module defines the data structures used throughout the MCI adapter,
     4| providing strong typing, validation, and schema enforcement for:
     5| - Top-level MCI schema with metadata and tools
     6| - Tool definitions with input schemas and execution configurations
     7| - Execution configurations for different execution types (HTTP, CLI, File, Text)
     8| - Authentication configurations
     9| - Execution results
    10| """
    11| from typing import Any, Literal
    12| from pydantic import BaseModel, Field, field_validator
    13| from .enums import ExecutionType
    14| class Metadata(BaseModel):
    15|     """
    16|     Optional metadata for an MCI schema.
    17|     Contains descriptive information about the tool collection,
    18|     such as name, version, description, license, and authors.
    19|     """
    20|     name: str | None = None
    21|     description: str | None = None
    22|     version: str | None = None
    23|     license: str | None = None
    24|     authors: list[str] | None = None
    25| class ApiKeyAuth(BaseModel):
    26|     """API Key authentication configuration."""
    27|     type: str = Field(default="apiKey")
    28|     in_: str = Field(alias="in")  # "header" or "query"
    29|     name: str
    30|     value: str
    31| class BearerAuth(BaseModel):
    32|     """Bearer token authentication configuration."""

# --- HUNK 2: Lines 92-287 ---
    92|     flags: dict[str, FlagConfig] | None = None
    93|     cwd: str | None = None
    94|     timeout_ms: int = Field(default=30000, ge=0)
    95| class FileExecutionConfig(ExecutionConfig):
    96|     """
    97|     File execution configuration.
    98|     Defines how to read and parse files, including the file path
    99|     and whether to parse placeholders in the file content.
   100|     """
   101|     type: ExecutionType = Field(default=ExecutionType.FILE)
   102|     path: str
   103|     enableTemplating: bool = Field(default=True)
   104| class TextExecutionConfig(ExecutionConfig):
   105|     """
   106|     Text execution configuration.
   107|     Defines a simple text template that will be processed with
   108|     placeholder substitution and returned as the result.
   109|     """
   110|     type: ExecutionType = Field(default=ExecutionType.TEXT)
   111|     text: str
   112| class MCPExecutionConfig(ExecutionConfig):
   113|     """
   114|     MCP execution configuration.
   115|     Defines how to execute tools via Model Context Protocol servers.
   116|     The serverName must match a server registered in the main schema's
   117|     mcp_servers field, and toolName identifies the specific tool to call.
   118|     """
   119|     type: ExecutionType = Field(default=ExecutionType.MCP)
   120|     serverName: str
   121|     toolName: str
   122| class Annotations(BaseModel):
   123|     """
   124|     Optional annotations about tool behavior.
   125|     Contains hints and metadata about how the tool behaves, including
   126|     display information (title) and behavioral characteristics like
   127|     whether it modifies state, is destructive, idempotent, or interacts
   128|     with external entities. Also includes audience targeting for different roles.
   129|     """
   130|     title: str | None = None
   131|     readOnlyHint: bool | None = None
   132|     destructiveHint: bool | None = None
   133|     idempotentHint: bool | None = None
   134|     openWorldHint: bool | None = None
   135|     audience: list[Literal["user", "assistant"]] | None = None
   136| class Tool(BaseModel):
   137|     """
   138|     Individual tool definition.
   139|     Represents a single tool with its name, description, disabled state,
   140|     annotations, input schema (JSON Schema), and execution configuration.
   141|     The execution configuration determines how the tool is executed
   142|     (HTTP, CLI, file, or text).
   143|     """
   144|     name: str
   145|     disabled: bool = Field(default=False)
   146|     annotations: Annotations | None = None
   147|     description: str | None = None
   148|     inputSchema: dict[str, Any] | None = None
   149|     execution: (
   150|         HTTPExecutionConfig
   151|         | CLIExecutionConfig
   152|         | FileExecutionConfig
   153|         | TextExecutionConfig
   154|         | MCPExecutionConfig
   155|     )
   156|     enableAnyPaths: bool = Field(default=False)
   157|     directoryAllowList: list[str] = Field(default_factory=list)
   158|     tags: list[str] = Field(default_factory=list)
   159|     toolset_source: str | None = Field(default=None, exclude=True)  # Internal field, not serialized
   160| class Toolset(BaseModel):
   161|     """
   162|     Toolset definition for loading tool collections from library files.
   163|     Represents a reference to a toolset file (or directory) in the libraryDir,
   164|     with optional filtering to control which tools from that toolset are loaded.
   165|     """
   166|     name: str
   167|     filter: str | None = None  # One of: "only", "except", "tags", "withoutTags"
   168|     filterValue: str | None = None  # Comma-separated list of tool names or tags
   169| class MCPServerConfig(BaseModel):
   170|     """
   171|     Configuration for filtering and expiration of MCP toolsets.
   172|     Applied when registering MCP servers to control which tools are loaded
   173|     and how long the cached toolset remains valid.
   174|     """
   175|     expDays: int = Field(default=30, ge=1)  # Days until cached toolset expires
   176|     filter: str | None = None  # One of: "only", "except", "tags", "withoutTags"
   177|     filterValue: str | None = None  # Comma-separated list of tool names or tags
   178| class StdioMCPServer(BaseModel):
   179|     """
   180|     STDIO-based MCP server configuration.
   181|     Used for local MCP servers started via command-line tools like npx or uvx.
   182|     Supports environment variable injection and templating.
   183|     """
   184|     command: str
   185|     args: list[str] = Field(default_factory=list)
   186|     env: dict[str, str] = Field(default_factory=dict)
   187|     config: MCPServerConfig = Field(default_factory=MCPServerConfig)
   188| class HttpMCPServer(BaseModel):
   189|     """
   190|     HTTP-based MCP server configuration.
   191|     Used for web-based MCP servers using HTTP with SSE or Streamable HTTP transport.
   192|     Supports custom headers for authentication and templating.
   193|     """
   194|     type: str = Field(default="http")
   195|     url: str
   196|     headers: dict[str, str] = Field(default_factory=dict)
   197|     config: MCPServerConfig = Field(default_factory=MCPServerConfig)
   198| MCPServer = StdioMCPServer | HttpMCPServer
   199| class ToolsetSchema(BaseModel):
   200|     """
   201|     Schema for individual toolset files.
   202|     Toolset files can only contain schemaVersion, optional metadata, required tools,
   203|     and optional expiresAt field for MCP toolset caching.
   204|     They cannot contain global configuration fields like toolsets, libraryDir, etc.
   205|     """
   206|     schemaVersion: str
   207|     metadata: Metadata | None = None
   208|     tools: list[Tool]
   209|     expiresAt: str | None = None  # ISO 8601 timestamp for MCP toolset expiration
   210| class MCISchema(BaseModel):
   211|     """
   212|     Top-level MCI schema.
   213|     Represents the complete MCI context file with schema version,
   214|     optional metadata, tool definitions, toolsets, and MCP server configurations.
   215|     This is the root model that validates the entire JSON schema.
   216|     """
   217|     schemaVersion: str
   218|     metadata: Metadata | None = None
   219|     tools: list[Tool] | None = Field(default=None)
   220|     toolsets: list[Toolset | str] | None = Field(default=None)
   221|     mcp_servers: dict[str, MCPServer] | None = Field(default=None)
   222|     libraryDir: str = Field(default="./mci")
   223|     enableAnyPaths: bool = Field(default=False)
   224|     directoryAllowList: list[str] = Field(default_factory=list)
   225|     @field_validator("toolsets", mode="before")
   226|     @classmethod
   227|     def normalize_toolsets(cls, v: Any) -> Any:
   228|         """
   229|         Normalize toolsets to always be Toolset objects.
   230|         Converts string toolset names to Toolset objects with just the name field.
   231|         This allows users to specify simple toolset names without creating full objects
   232|         when no filtering is needed.
   233|         Examples:
   234|             "github" -> {"name": "github"}
   235|             {"name": "github", "filter": "tags", "filterValue": "read"} -> unchanged
   236|         """
   237|         if v is None:
   238|             return v
   239|         normalized = []
   240|         for item in v:
   241|             if isinstance(item, str):
   242|                 normalized.append({"name": item})
   243|             else:
   244|                 normalized.append(item)
   245|         return normalized
   246| class TextContent(BaseModel):
   247|     """
   248|     Text content object for execution results.
   249|     Represents textual content in MCP-compatible format.
   250|     """
   251|     type: str = Field(default="text")
   252|     text: str
   253| class ImageContent(BaseModel):
   254|     """
   255|     Image content object for execution results.
   256|     Represents base64-encoded image data in MCP-compatible format.
   257|     """
   258|     type: str = Field(default="image")
   259|     data: str
   260|     mimeType: str
   261| class AudioContent(BaseModel):
   262|     """
   263|     Audio content object for execution results.
   264|     Represents base64-encoded audio data in MCP-compatible format.
   265|     """
   266|     type: str = Field(default="audio")
   267|     data: str
   268|     mimeType: str
   269| ContentObject = TextContent | ImageContent | AudioContent
   270| class ExecutionResultContent(BaseModel):
   271|     """
   272|     Inner result object containing execution result data.
   273|     Contains the structured content array, error status, and optional metadata.
   274|     """
   275|     content: list[ContentObject]
   276|     isError: bool
   277|     metadata: dict[str, Any] | None = None
   278| class ExecutionResult(BaseModel):
   279|     """
   280|     Execution result format with MCP compatibility.
   281|     Represents the result of executing a tool in MCP-compatible format
   282|     with optional JSON-RPC wrapper fields and structured content array.
   283|     The main result data is contained in the 'result' field.
   284|     """
   285|     result: ExecutionResultContent
   286|     jsonrpc: str | None = Field(default=None)
   287|     id: int | None = Field(default=None)


# ====================================================================
# FILE: src/mcipy/parser.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-163 ---
     1| """
     2| Schema parser for MCI JSON and YAML files.
     3| This module provides the SchemaParser class for loading and validating
     4| MCI schema files. It handles:
     5| - Loading JSON and YAML files from disk
     6| - Parsing dictionaries into MCISchema objects
     7| - Validating schema versions
     8| - Validating tool definitions
     9| - Building appropriate execution configurations based on type
    10| - Loading and filtering toolsets from library directories
    11| - Loading and caching MCP toolsets from MCP servers
    12| """
    13| import json
    14| import os
    15| from datetime import UTC, datetime
    16| from pathlib import Path
    17| from typing import Any
    18| import yaml
    19| from pydantic import ValidationError
    20| from .enums import ExecutionType
    21| from .models import (
    22|     CLIExecutionConfig,
    23|     ExecutionConfig,
    24|     FileExecutionConfig,
    25|     HTTPExecutionConfig,
    26|     MCISchema,
    27|     MCPExecutionConfig,
    28|     TextExecutionConfig,
    29|     Tool,
    30|     ToolsetSchema,
    31| )
    32| from .schema_config import SUPPORTED_SCHEMA_VERSIONS
    33| class SchemaParserError(Exception):
    34|     """Exception raised for schema parsing errors."""
    35|     pass
    36| class SchemaParser:
    37|     """
    38|     Parser for MCI schema files.
    39|     Loads and validates MCI JSON and YAML schema files, ensuring they conform to
    40|     the expected structure and contain valid tool definitions. Uses Pydantic
    41|     for strong validation and provides helpful error messages for invalid schemas.
    42|     """
    43|     @staticmethod
    44|     def parse_file(file_path: str, env_vars: dict[str, Any] | None = None) -> MCISchema:
    45|         """
    46|         Load and validate an MCI schema file (JSON or YAML).
    47|         Reads a JSON or YAML file from disk, validates its structure and content,
    48|         and returns a parsed MCISchema object. The file type is determined by
    49|         the file extension (.json, .yaml, or .yml).
    50|         Args:
    51|             file_path: Path to the MCI schema file (.json, .yaml, or .yml)
    52|             env_vars: Optional environment variables for MCP server templating
    53|         Returns:
    54|             Validated MCISchema object
    55|         Raises:
    56|             SchemaParserError: If the file doesn't exist, can't be read,
    57|                              contains invalid JSON/YAML, has unsupported extension,
    58|                              or fails validation
    59|         """
    60|         path = Path(file_path)
    61|         if not path.exists():
    62|             raise SchemaParserError(f"Schema file not found: {file_path}")
    63|         if not path.is_file():
    64|             raise SchemaParserError(f"Path is not a file: {file_path}")
    65|         file_extension = path.suffix.lower()
    66|         try:
    67|             with path.open("r", encoding="utf-8") as f:
    68|                 if file_extension == ".json":
    69|                     data = json.load(f)
    70|                 elif file_extension in (".yaml", ".yml"):
    71|                     data = yaml.safe_load(f)
    72|                 else:
    73|                     raise SchemaParserError(
    74|                         f"Unsupported file extension '{file_extension}'. "
    75|                         f"Supported extensions: .json, .yaml, .yml"
    76|                     )
    77|         except json.JSONDecodeError as e:
    78|             raise SchemaParserError(f"Invalid JSON in file {file_path}: {e}") from e
    79|         except yaml.YAMLError as e:
    80|             raise SchemaParserError(f"Invalid YAML in file {file_path}: {e}") from e
    81|         except OSError as e:
    82|             raise SchemaParserError(f"Failed to read file {file_path}: {e}") from e
    83|         return SchemaParser.parse_dict(data, schema_file_path=file_path, env_vars=env_vars)
    84|     @staticmethod
    85|     def parse_dict(
    86|         data: dict[str, Any],
    87|         schema_file_path: str | None = None,
    88|         env_vars: dict[str, Any] | None = None,
    89|     ) -> MCISchema:
    90|         """
    91|         Parse a dictionary into an MCISchema object.
    92|         Validates the dictionary structure, schema version, and tool definitions,
    93|         then returns a validated MCISchema object. If toolsets are defined,
    94|         loads tools from toolset files and applies schema-level filtering.
    95|         Args:
    96|             data: Dictionary containing MCI schema data
    97|             schema_file_path: Path to the schema file (for resolving relative paths in toolsets)
    98|             env_vars: Optional environment variables for MCP server templating
    99|         Returns:
   100|             Validated MCISchema object
   101|         Raises:
   102|             SchemaParserError: If the dictionary structure is invalid,
   103|                              schema version is unsupported, or validation fails
   104|         """
   105|         if not isinstance(data, dict):
   106|             raise SchemaParserError(f"Expected dictionary, got {type(data).__name__}")
   107|         if "schemaVersion" not in data:
   108|             raise SchemaParserError("Missing required field 'schemaVersion'")
   109|         has_tools = "tools" in data and data["tools"] is not None
   110|         has_toolsets = "toolsets" in data and data["toolsets"] is not None
   111|         if not has_tools and not has_toolsets:
   112|             raise SchemaParserError("Either 'tools' or 'toolsets' field must be provided")
   113|         SchemaParser._validate_schema_version(data["schemaVersion"])
   114|         if has_tools:
   115|             if not isinstance(data["tools"], list):
   116|                 raise SchemaParserError(
   117|                     f"Field 'tools' must be a list, got {type(data['tools']).__name__}"
   118|                 )
   119|             SchemaParser._validate_tools(data["tools"])
   120|         try:
   121|             schema = MCISchema(**data)
   122|         except ValidationError as e:
   123|             raise SchemaParserError(f"Schema validation failed: {e}") from e
   124|         if schema.toolsets:
   125|             toolset_tools = SchemaParser._load_toolsets(
   126|                 schema.toolsets, schema.libraryDir, schema_file_path
   127|             )
   128|             if schema.tools is None:
   129|                 schema.tools = toolset_tools
   130|             else:
   131|                 schema.tools.extend(toolset_tools)
   132|         if schema.mcp_servers:
   133|             mcp_tools = SchemaParser._load_mcp_servers(
   134|                 schema.mcp_servers,
   135|                 schema.libraryDir,
   136|                 schema_file_path,
   137|                 schema.schemaVersion,
   138|                 env_vars,
   139|             )
   140|             if schema.tools is None:
   141|                 schema.tools = mcp_tools
   142|             else:
   143|                 schema.tools.extend(mcp_tools)
   144|         return schema
   145|     @staticmethod
   146|     def _validate_schema_version(version: str) -> None:
   147|         """
   148|         Validate schema version compatibility.
   149|         Ensures the schema version is supported by this parser implementation.
   150|         Args:
   151|             version: Schema version string
   152|         Raises:
   153|             SchemaParserError: If the version is not supported
   154|         """
   155|         if not isinstance(version, str):
   156|             raise SchemaParserError(
   157|                 f"Schema version must be a string, got {type(version).__name__}"
   158|             )
   159|         if version not in SUPPORTED_SCHEMA_VERSIONS:
   160|             raise SchemaParserError(
   161|                 f"Unsupported schema version '{version}'. "
   162|                 f"Supported versions: {', '.join(SUPPORTED_SCHEMA_VERSIONS)}"
   163|             )

# --- HUNK 2: Lines 181-496 ---
   181|             if "execution" not in tool:
   182|                 raise SchemaParserError(
   183|                     f"Tool at index {idx} ('{tool.get('name', 'unknown')}') missing required field 'execution'"
   184|                 )
   185|             execution = tool["execution"]
   186|             if not isinstance(execution, dict):
   187|                 raise SchemaParserError(
   188|                     f"Tool '{tool['name']}' execution must be a dictionary, got {type(execution).__name__}"
   189|                 )
   190|             try:
   191|                 SchemaParser._build_execution_config(execution)
   192|             except SchemaParserError as e:
   193|                 raise SchemaParserError(
   194|                     f"Tool '{tool['name']}' has invalid execution config: {e}"
   195|                 ) from e
   196|     @staticmethod
   197|     def _build_execution_config(execution: dict[str, Any]) -> ExecutionConfig:
   198|         """
   199|         Build the appropriate execution config based on type.
   200|         Determines the execution type and creates the corresponding
   201|         ExecutionConfig subclass (HTTP, CLI, File, Text, or MCP).
   202|         Args:
   203|             execution: Dictionary containing execution configuration
   204|         Returns:
   205|             Appropriate ExecutionConfig subclass instance
   206|         Raises:
   207|             SchemaParserError: If the execution type is missing, invalid,
   208|                              or the configuration is invalid for that type
   209|         """
   210|         if "type" not in execution:
   211|             raise SchemaParserError("Missing required field 'type' in execution config")
   212|         exec_type = execution["type"]
   213|         if not isinstance(exec_type, str):
   214|             raise SchemaParserError(
   215|                 f"Execution type must be a string, got {type(exec_type).__name__}"
   216|             )
   217|         type_map = {
   218|             ExecutionType.HTTP.value: HTTPExecutionConfig,
   219|             ExecutionType.CLI.value: CLIExecutionConfig,
   220|             ExecutionType.FILE.value: FileExecutionConfig,
   221|             ExecutionType.TEXT.value: TextExecutionConfig,
   222|             ExecutionType.MCP.value: MCPExecutionConfig,
   223|         }
   224|         if exec_type not in type_map:
   225|             valid_types = ", ".join(type_map.keys())
   226|             raise SchemaParserError(
   227|                 f"Invalid execution type '{exec_type}'. Valid types: {valid_types}"
   228|             )
   229|         config_class = type_map[exec_type]
   230|         try:
   231|             config = config_class(**execution)
   232|         except ValidationError as e:
   233|             raise SchemaParserError(f"Invalid {exec_type} execution config: {e}") from e
   234|         return config
   235|     @staticmethod
   236|     def _load_toolsets(
   237|         toolsets: list[Any], library_dir: str, schema_file_path: str | None
   238|     ) -> list[Tool]:
   239|         """
   240|         Load tools from toolset definitions.
   241|         Discovers toolset files in the library directory, loads them,
   242|         and applies schema-level filtering based on the toolset configuration.
   243|         Args:
   244|             toolsets: List of toolset definitions from main schema
   245|             library_dir: Directory to search for toolset files (relative to schema file)
   246|             schema_file_path: Path to the main schema file (for resolving relative paths)
   247|         Returns:
   248|             List of Tool objects loaded from all toolsets with filters applied
   249|         Raises:
   250|             SchemaParserError: If toolset files cannot be found or loaded
   251|         """
   252|         all_tools: list[Tool] = []
   253|         if schema_file_path:
   254|             base_dir = Path(schema_file_path).parent
   255|             lib_path = base_dir / library_dir
   256|         else:
   257|             lib_path = Path(library_dir)
   258|         if not lib_path.exists():
   259|             raise SchemaParserError(f"Library directory not found: {lib_path}")
   260|         if not lib_path.is_dir():
   261|             raise SchemaParserError(f"Library path is not a directory: {lib_path}")
   262|         for toolset in toolsets:
   263|             toolset_schema = SchemaParser._load_toolset_file(toolset.name, lib_path)
   264|             filtered_tools = SchemaParser._apply_toolset_filter(
   265|                 toolset_schema.tools, toolset.filter, toolset.filterValue
   266|             )
   267|             for tool in filtered_tools:
   268|                 tool.toolset_source = toolset.name
   269|             all_tools.extend(filtered_tools)
   270|         return all_tools
   271|     @staticmethod
   272|     def _load_toolset_file(name: str, lib_path: Path) -> ToolsetSchema:
   273|         """
   274|         Load a toolset file from the library directory.
   275|         Tries to find the toolset as:
   276|         1. A directory containing .mci.json files
   277|         2. A file with exact name (e.g., github_prs.mci.json)
   278|         3. A file with .mci.json extension added (e.g., github_prs -> github_prs.mci.json)
   279|         Args:
   280|             name: Name of the toolset (directory, file, or bare prefix)
   281|             lib_path: Path to the library directory
   282|         Returns:
   283|             Parsed ToolsetSchema
   284|         Raises:
   285|             SchemaParserError: If toolset file cannot be found or loaded
   286|         """
   287|         dir_path = lib_path / name
   288|         if dir_path.is_dir():
   289|             toolset_files = list(dir_path.glob("*.mci.json"))
   290|             if not toolset_files:
   291|                 raise SchemaParserError(
   292|                     f"No .mci.json files found in toolset directory: {dir_path}"
   293|                 )
   294|             all_tools: list[Tool] = []
   295|             schema_version = None
   296|             for toolset_file in toolset_files:
   297|                 schema = SchemaParser._parse_toolset_file(toolset_file)
   298|                 all_tools.extend(schema.tools)
   299|                 if schema_version is None:
   300|                     schema_version = schema.schemaVersion
   301|                 elif schema.schemaVersion != schema_version:
   302|                     raise SchemaParserError(
   303|                         f"Schema version mismatch in toolset directory '{dir_path}': "
   304|                         f"File '{toolset_file.name}' has schemaVersion '{schema.schemaVersion}', "
   305|                         f"but expected '{schema_version}' (from first file in directory). "
   306|                         f"All files in a toolset directory must use the same schema version."
   307|                     )
   308|             return ToolsetSchema(
   309|                 schemaVersion=schema_version or "1.0",
   310|                 metadata=None,  # Don't merge metadata from toolset files
   311|                 tools=all_tools,
   312|             )
   313|         file_path = lib_path / name
   314|         if file_path.is_file():
   315|             return SchemaParser._parse_toolset_file(file_path)
   316|         file_with_ext = lib_path / f"{name}.mci.json"
   317|         if file_with_ext.is_file():
   318|             return SchemaParser._parse_toolset_file(file_with_ext)
   319|         file_with_yaml = lib_path / f"{name}.mci.yaml"
   320|         if file_with_yaml.is_file():
   321|             return SchemaParser._parse_toolset_file(file_with_yaml)
   322|         file_with_yml = lib_path / f"{name}.mci.yml"
   323|         if file_with_yml.is_file():
   324|             return SchemaParser._parse_toolset_file(file_with_yml)
   325|         raise SchemaParserError(
   326|             f"Toolset not found: {name}. Looked for directory, file, or file with .mci.json/.mci.yaml/.mci.yml extension in {lib_path}"
   327|         )
   328|     @staticmethod
   329|     def _parse_toolset_file(file_path: Path) -> ToolsetSchema:
   330|         """
   331|         Parse a toolset file.
   332|         Args:
   333|             file_path: Path to the toolset file
   334|         Returns:
   335|             Parsed ToolsetSchema
   336|         Raises:
   337|             SchemaParserError: If file cannot be parsed or is invalid
   338|         """
   339|         file_extension = file_path.suffix.lower()
   340|         try:
   341|             with file_path.open("r", encoding="utf-8") as f:
   342|                 if file_extension == ".json":
   343|                     data = json.load(f)
   344|                 elif file_extension in (".yaml", ".yml"):
   345|                     data = yaml.safe_load(f)
   346|                 else:
   347|                     raise SchemaParserError(
   348|                         f"Unsupported toolset file extension '{file_extension}'. "
   349|                         f"Supported extensions: .json, .yaml, .yml"
   350|                     )
   351|         except json.JSONDecodeError as e:
   352|             raise SchemaParserError(f"Invalid JSON in toolset file {file_path}: {e}") from e
   353|         except yaml.YAMLError as e:
   354|             raise SchemaParserError(f"Invalid YAML in toolset file {file_path}: {e}") from e
   355|         except OSError as e:
   356|             raise SchemaParserError(f"Failed to read toolset file {file_path}: {e}") from e
   357|         if not isinstance(data, dict):
   358|             raise SchemaParserError(
   359|                 f"Toolset file {file_path} must contain a JSON/YAML object, got {type(data).__name__}"
   360|             )
   361|         if "schemaVersion" not in data:
   362|             raise SchemaParserError(
   363|                 f"Toolset file {file_path} missing required field 'schemaVersion'"
   364|             )
   365|         if "tools" not in data:
   366|             raise SchemaParserError(f"Toolset file {file_path} missing required field 'tools'")
   367|         SchemaParser._validate_schema_version(data["schemaVersion"])
   368|         if not isinstance(data["tools"], list):
   369|             raise SchemaParserError(
   370|                 f"Toolset file {file_path} field 'tools' must be a list, got {type(data['tools']).__name__}"
   371|             )
   372|         SchemaParser._validate_tools(data["tools"])
   373|         try:
   374|             schema = ToolsetSchema(**data)
   375|         except ValidationError as e:
   376|             raise SchemaParserError(f"Toolset file {file_path} validation failed: {e}") from e
   377|         return schema
   378|     @staticmethod
   379|     def _apply_toolset_filter(
   380|         tools: list[Tool], filter_type: str | None, filter_value: str | None
   381|     ) -> list[Tool]:
   382|         """
   383|         Apply schema-level filtering to toolset tools.
   384|         Args:
   385|             tools: List of tools from the toolset
   386|             filter_type: Type of filter ("only", "except", "tags", "withoutTags", or None)
   387|             filter_value: Comma-separated list of tool names or tags
   388|         Returns:
   389|             Filtered list of Tool objects
   390|         Raises:
   391|             SchemaParserError: If filter configuration is invalid
   392|         """
   393|         if filter_type is None:
   394|             return tools
   395|         if filter_value is None:
   396|             raise SchemaParserError(
   397|                 f"Filter type '{filter_type}' specified but filterValue is missing"
   398|             )
   399|         filter_items = [item.strip() for item in filter_value.split(",") if item.strip()]
   400|         if not filter_items:
   401|             raise SchemaParserError(f"Filter value cannot be empty for filter type '{filter_type}'")
   402|         if filter_type == "only":
   403|             filter_set = set(filter_items)
   404|             return [tool for tool in tools if tool.name in filter_set]
   405|         elif filter_type == "except":
   406|             filter_set = set(filter_items)
   407|             return [tool for tool in tools if tool.name not in filter_set]
   408|         elif filter_type == "tags":
   409|             filter_set = set(filter_items)
   410|             return [tool for tool in tools if any(tag in filter_set for tag in tool.tags)]
   411|         elif filter_type == "withoutTags":
   412|             filter_set = set(filter_items)
   413|             return [tool for tool in tools if not any(tag in filter_set for tag in tool.tags)]
   414|         else:
   415|             raise SchemaParserError(
   416|                 f"Invalid filter type '{filter_type}'. Valid types: only, except, tags, withoutTags"
   417|             )
   418|     @staticmethod
   419|     def _load_mcp_servers(
   420|         mcp_servers: dict[str, Any],
   421|         library_dir: str,
   422|         schema_file_path: str | None,
   423|         schema_version: str,
   424|         env_vars: dict[str, Any] | None = None,
   425|     ) -> list[Tool]:
   426|         """
   427|         Load tools from MCP server definitions.
   428|         Checks for cached MCP toolsets in libraryDir/mcp/, fetches tools from
   429|         MCP servers if cache doesn't exist or is expired, and applies filtering.
   430|         Args:
   431|             mcp_servers: Dictionary of MCP server configurations from main schema
   432|             library_dir: Directory to search for cached toolset files (relative to schema file)
   433|             schema_file_path: Path to the main schema file (for resolving relative paths)
   434|             schema_version: Schema version from main file (to use for generated toolsets)
   435|             env_vars: Optional environment variables for MCP server templating
   436|         Returns:
   437|             List of Tool objects loaded from all MCP servers with filters applied
   438|         Raises:
   439|             SchemaParserError: If MCP toolset files cannot be loaded or MCP servers are unreachable
   440|         """
   441|         from .mcp_integration import MCPIntegration
   442|         from .templating import TemplateEngine
   443|         all_tools: list[Tool] = []
   444|         if schema_file_path:
   445|             base_dir = Path(schema_file_path).parent
   446|             lib_path = base_dir / library_dir
   447|         else:
   448|             lib_path = Path(library_dir)
   449|         mcp_dir = lib_path / "mcp"
   450|         mcp_dir.mkdir(parents=True, exist_ok=True)
   451|         for server_name, server_config in mcp_servers.items():
   452|             toolset_path = mcp_dir / f"{server_name}.mci.json"
   453|             should_fetch = True
   454|             if toolset_path.exists():
   455|                 try:
   456|                     toolset_schema = SchemaParser._parse_toolset_file(toolset_path)
   457|                     if toolset_schema.expiresAt:
   458|                         try:
   459|                             expires_date = datetime.fromisoformat(toolset_schema.expiresAt).date()
   460|                             today = datetime.now(UTC).date()
   461|                             if expires_date > today:
   462|                                 should_fetch = False
   463|                                 filtered_tools = SchemaParser._apply_toolset_filter(
   464|                                     toolset_schema.tools,
   465|                                     server_config.config.filter,
   466|                                     server_config.config.filterValue,
   467|                                 )
   468|                                 for tool in filtered_tools:
   469|                                     tool.toolset_source = server_name
   470|                                 all_tools.extend(filtered_tools)
   471|                         except (ValueError, AttributeError):
   472|                             should_fetch = True
   473|                 except Exception:
   474|                     should_fetch = True
   475|             if should_fetch:
   476|                 template_engine = TemplateEngine()
   477|                 env_context = {"env": {**dict(os.environ), **(env_vars or {})}}
   478|                 try:
   479|                     toolset_schema = MCPIntegration.fetch_and_build_toolset(
   480|                         server_name, server_config, schema_version, env_context, template_engine
   481|                     )
   482|                     with toolset_path.open("w", encoding="utf-8") as f:
   483|                         json.dump(toolset_schema.model_dump(exclude_none=True), f, indent=2)
   484|                     filtered_tools = SchemaParser._apply_toolset_filter(
   485|                         toolset_schema.tools,
   486|                         server_config.config.filter,
   487|                         server_config.config.filterValue,
   488|                     )
   489|                     for tool in filtered_tools:
   490|                         tool.toolset_source = server_name
   491|                     all_tools.extend(filtered_tools)
   492|                 except Exception as e:
   493|                     raise SchemaParserError(
   494|                         f"Failed to fetch tools from MCP server '{server_name}': {e}"
   495|                     ) from e
   496|         return all_tools


# ====================================================================
# FILE: src/mcipy/path_validator.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-102 ---
     1| """
     2| Path validation utilities for MCI tool execution.
     3| This module provides security functions to validate file paths used in tool execution.
     4| It ensures that file/CLI paths are within allowed directories unless explicitly overridden
     5| via enableAnyPaths configuration.
     6| """
     7| from pathlib import Path
     8| class PathValidationError(Exception):
     9|     """Exception raised when path validation fails."""
    10|     pass
    11| class PathValidator:
    12|     """
    13|     Validates file paths against security restrictions.
    14|     Ensures paths are within the context directory or allowed directories
    15|     unless enableAnyPaths is enabled.
    16|     """
    17|     def __init__(
    18|         self,
    19|         context_dir: Path,
    20|         enable_any_paths: bool = False,
    21|         directory_allow_list: list[str] | None = None,
    22|     ):
    23|         """
    24|         Initialize the path validator.
    25|         Args:
    26|             context_dir: Directory containing the MCI schema file (base directory)
    27|             enable_any_paths: If True, skip all path validation
    28|             directory_allow_list: Additional directories to allow (relative or absolute paths)
    29|         """
    30|         self.context_dir = context_dir.resolve()
    31|         self.enable_any_paths = enable_any_paths
    32|         self.allowed_dirs = self._build_allowed_dirs(directory_allow_list or [])
    33|     def _build_allowed_dirs(self, directory_allow_list: list[str]) -> list[Path]:
    34|         """
    35|         Build list of allowed directories (absolute paths).
    36|         Converts relative and absolute paths in the allow list to absolute paths.
    37|         Relative paths are resolved relative to the context directory.
    38|         Args:
    39|             directory_allow_list: List of directory paths (relative or absolute)
    40|         Returns:
    41|             List of resolved absolute Path objects
    42|         """
    43|         allowed = [self.context_dir]  # Context directory is always allowed
    44|         for dir_path in directory_allow_list:
    45|             path = Path(dir_path)
    46|             if not path.is_absolute():
    47|                 path = (self.context_dir / path).resolve()
    48|             else:
    49|                 path = path.resolve()
    50|             allowed.append(path)
    51|         return allowed
    52|     def validate_path(self, path: str) -> None:
    53|         """
    54|         Validate that a file path is allowed.
    55|         Checks if the path is within the context directory or an allowed directory.
    56|         Raises PathValidationError if the path is not allowed.
    57|         Args:
    58|             path: File or directory path to validate
    59|         Raises:
    60|             PathValidationError: If path is outside allowed directories and enableAnyPaths is False
    61|         """
    62|         if self.enable_any_paths:
    63|             return
    64|         path_obj = Path(path)
    65|         if not path_obj.is_absolute():
    66|             file_path = (self.context_dir / path_obj).resolve()
    67|         else:
    68|             file_path = path_obj.resolve()
    69|         for allowed_dir in self.allowed_dirs:
    70|             try:
    71|                 file_path.relative_to(allowed_dir)
    72|                 return
    73|             except ValueError:
    74|                 continue
    75|         raise PathValidationError(
    76|             f"File path access outside context directory and allow-list is not allowed "
    77|             f"unless enableAnyPaths is true. Path: {path}"
    78|         )
    79|     @staticmethod
    80|     def merge_settings(
    81|         schema_enable_any_paths: bool,
    82|         schema_directory_allow_list: list[str],
    83|         tool_enable_any_paths: bool,
    84|         tool_directory_allow_list: list[str],
    85|     ) -> tuple[bool, list[str]]:
    86|         """
    87|         Merge schema-level and tool-level settings with proper precedence.
    88|         Tool-level settings take precedence over schema-level settings.
    89|         If tool has explicit settings, use those; otherwise use schema settings.
    90|         Args:
    91|             schema_enable_any_paths: Schema-level enableAnyPaths
    92|             schema_directory_allow_list: Schema-level directoryAllowList
    93|             tool_enable_any_paths: Tool-level enableAnyPaths
    94|             tool_directory_allow_list: Tool-level directoryAllowList
    95|         Returns:
    96|             Tuple of (effective_enable_any_paths, effective_directory_allow_list)
    97|         """
    98|         effective_enable_any_paths = tool_enable_any_paths or schema_enable_any_paths
    99|         effective_directory_allow_list = (
   100|             tool_directory_allow_list if tool_directory_allow_list else schema_directory_allow_list
   101|         )
   102|         return effective_enable_any_paths, effective_directory_allow_list


# ====================================================================
# FILE: src/mcipy/templating.py
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 7-238 ---
     7| """
     8| import re
     9| from typing import Any
    10| class TemplateError(Exception):
    11|     """Exception raised when template processing fails."""
    12|     pass
    13| class TemplateEngine:
    14|     """
    15|     Template engine for processing MCI templates.
    16|     Handles both basic placeholder substitution and advanced templating
    17|     features like loops and conditional blocks. The engine supports:
    18|     - Basic placeholders: {{props.propertyName}}, {{env.VAR_NAME}}
    19|     - For loops: @for(i in range(0, 5)) ... @endfor
    20|     - Foreach loops: @foreach(item in items) ... @endforeach
    21|     - Control blocks: @if(condition) ... @elseif(condition) ... @else ... @endif
    22|     """
    23|     def render_basic(self, template: str, context: dict[str, Any]) -> str:
    24|         """
    25|         Perform basic placeholder substitution.
    26|         Replaces placeholders like {{props.propertyName}} and {{env.VAR_NAME}}
    27|         with their values from the context. Supports fallback syntax with | operator:
    28|         - {{env.VAR | 'default'}} - Use string literal as fallback
    29|         - {{env.VAR | env.OTHER}} - Use another variable as fallback
    30|         - {{env.VAR | env.OTHER | '/tmp'}} - Chain multiple fallbacks
    31|         Args:
    32|             template: The template string containing placeholders
    33|             context: Dictionary with 'props', 'env', and 'input' keys
    34|         Returns:
    35|             The template with all placeholders replaced
    36|         Raises:
    37|             TemplateError: If a placeholder cannot be resolved and no fallback is provided
    38|         """
    39|         pattern = r"\{\{([^}]+)\}\}"
    40|         def replace_placeholder(match: re.Match[str]) -> str:
    41|             full_path = match.group(1).strip()
    42|             try:
    43|                 value = self._resolve_placeholder_with_fallback(full_path, context)
    44|                 return str(value)
    45|             except Exception as e:
    46|                 placeholder_str = "{{" + full_path + "}}"
    47|                 raise TemplateError(
    48|                     f"Failed to resolve placeholder '{placeholder_str}': {e}"
    49|                 ) from e
    50|         return re.sub(pattern, replace_placeholder, template)
    51|     def render_advanced(self, template: str, context: dict[str, Any]) -> str:
    52|         """
    53|         Perform advanced templating with loops and control blocks.
    54|         Processes @for, @foreach, and @if/@elseif/@else/@endif blocks
    55|         in addition to basic placeholder substitution.
    56|         Args:
    57|             template: The template string with advanced directives
    58|             context: Dictionary with 'props', 'env', and 'input' keys
    59|         Returns:
    60|             The fully processed template
    61|         Raises:
    62|             TemplateError: If template processing fails
    63|         """
    64|         result = self._parse_for_loop(template, context)
    65|         result = self._parse_foreach_loop(result, context)
    66|         result = self._parse_control_blocks(result, context)
    67|         result = self.render_basic(result, context)
    68|         return result
    69|     def _resolve_placeholder_with_fallback(self, full_path: str, context: dict[str, Any]) -> Any:
    70|         """
    71|         Resolve a placeholder with optional fallback values using | operator.
    72|         Supports:
    73|         - env.VAR - Simple variable
    74|         - env.VAR | 'default' - Fallback to string literal (single quotes or backticks)
    75|         - env.VAR | env.OTHER - Fallback to another variable
    76|         - env.VAR | env.OTHER | '/tmp' - Chain multiple fallbacks
    77|         Args:
    78|             full_path: Path with optional fallbacks (e.g., "env.VAR | 'default' | env.OTHER")
    79|             context: Context dictionary
    80|         Returns:
    81|             The resolved value or fallback
    82|         Raises:
    83|             TemplateError: If no path can be resolved and no valid fallback provided
    84|         """
    85|         alternatives = [alt.strip() for alt in full_path.split("|")]
    86|         errors = []
    87|         for alt in alternatives:
    88|             if (alt.startswith("'") and alt.endswith("'")) or (
    89|                 alt.startswith("`") and alt.endswith("`")
    90|             ):
    91|                 return alt[1:-1]
    92|             try:
    93|                 return self._resolve_placeholder(alt, context)
    94|             except TemplateError as e:
    95|                 errors.append(f"{alt}: {e}")
    96|                 continue
    97|         raise TemplateError(
    98|             f"Could not resolve any alternative. Tried: {', '.join(alternatives)}. Errors: {'; '.join(errors)}"
    99|         )
   100|     def _resolve_placeholder(self, path: str, context: dict[str, Any]) -> Any:
   101|         """
   102|         Resolve a dot-notation path in the context.
   103|         Supports paths like 'props.location', 'env.API_KEY', 'input.user.name'
   104|         Args:
   105|             path: Dot-notation path to resolve
   106|             context: Context dictionary
   107|         Returns:
   108|             The value at the specified path
   109|         Raises:
   110|             TemplateError: If the path cannot be resolved
   111|         """
   112|         parts = path.split(".")
   113|         current = context
   114|         for i, part in enumerate(parts):
   115|             if not isinstance(current, dict):
   116|                 raise TemplateError(
   117|                     f"Cannot access '{part}' on non-dict value at '{'.'.join(parts[:i])}'"
   118|                 )
   119|             if part not in current:
   120|                 raise TemplateError(f"Path '{path}' not found in context (missing '{part}')")
   121|             current = current[part]
   122|         return current
   123|     def _replace_placeholders_with_whitespace_support(
   124|         self, content: str, replacements: dict[str, str]
   125|     ) -> str:
   126|         """
   127|         Replace placeholders in content, supporting optional whitespace around variable names.
   128|         Args:
   129|             content: The content containing placeholders
   130|             replacements: Dictionary mapping variable paths to replacement values
   131|         Returns:
   132|             Content with placeholders replaced
   133|         """
   134|         result = content
   135|         for var_path, replacement in replacements.items():
   136|             pattern = rf"\{{\{{\s*{re.escape(var_path)}\s*\}}\}}"
   137|             result = re.sub(pattern, replacement, result)
   138|         return result
   139|     def _parse_for_loop(self, content: str, context: dict[str, Any]) -> str:
   140|         """
   141|         Parse and process @for loops.
   142|         Supports syntax: @for(variable in range(start, end))...@endfor
   143|         Args:
   144|             content: Template content containing @for loops
   145|             context: Context dictionary
   146|         Returns:
   147|             Content with @for loops expanded
   148|         """
   149|         pattern = r"@for\s*\(\s*(\w+)\s+in\s+range\s*\(\s*(\d+)\s*,\s*(\d+)\s*\)\s*\)(.*?)@endfor"
   150|         def replace_for_loop(match: re.Match[str]) -> str:
   151|             var_name = match.group(1)
   152|             start = int(match.group(2))
   153|             end = int(match.group(3))
   154|             body = match.group(4)
   155|             result = []
   156|             for i in range(start, end):
   157|                 loop_context = context.copy()
   158|                 loop_context[var_name] = i
   159|                 processed_body = body
   160|                 replacements = {var_name: str(i)}
   161|                 processed_body = self._replace_placeholders_with_whitespace_support(
   162|                     processed_body, replacements
   163|                 )
   164|                 result.append(processed_body)
   165|             return "".join(result)
   166|         return re.sub(pattern, replace_for_loop, content, flags=re.DOTALL)
   167|     def _parse_foreach_loop(self, content: str, context: dict[str, Any]) -> str:
   168|         """
   169|         Parse and process @foreach loops.
   170|         Supports syntax: @foreach(item in items)...@endforeach
   171|         where 'items' is a path in the context (e.g., 'props.myArray')
   172|         Args:
   173|             content: Template content containing @foreach loops
   174|             context: Context dictionary
   175|         Returns:
   176|             Content with @foreach loops expanded
   177|         """
   178|         pattern = r"@foreach\s*\(\s*(\w+)\s+in\s+([\w.]+)\s*\)(.*?)@endforeach"
   179|         def replace_foreach_loop(match: re.Match[str]) -> str:
   180|             var_name = match.group(1)
   181|             path = match.group(2)
   182|             body = match.group(3)
   183|             try:
   184|                 items = self._resolve_placeholder(path, context)
   185|             except TemplateError as e:
   186|                 raise TemplateError(f"Failed to resolve foreach path '{path}': {e}") from e
   187|             if not isinstance(items, (list, dict)):
   188|                 raise TemplateError(
   189|                     f"@foreach requires an array or object, got {type(items).__name__}"
   190|                 )
   191|             result = []
   192|             if isinstance(items, list):
   193|                 for item in items:
   194|                     loop_context = context.copy()
   195|                     loop_context[var_name] = item
   196|                     processed_body = body
   197|                     if isinstance(item, dict):
   198|                         replacements = {}
   199|                         for key, value in item.items():
   200|                             replacements[f"{var_name}.{key}"] = str(value)
   201|                         processed_body = self._replace_placeholders_with_whitespace_support(
   202|                             processed_body, replacements
   203|                         )
   204|                     else:
   205|                         replacements = {var_name: str(item)}
   206|                         processed_body = self._replace_placeholders_with_whitespace_support(
   207|                             processed_body, replacements
   208|                         )
   209|                     result.append(processed_body)
   210|             else:  # dict
   211|                 for key, value in items.items():
   212|                     loop_context = context.copy()
   213|                     loop_context[var_name] = value
   214|                     processed_body = body
   215|                     replacements = {var_name: str(value), f"{var_name}.key": str(key)}
   216|                     processed_body = self._replace_placeholders_with_whitespace_support(
   217|                         processed_body, replacements
   218|                     )
   219|                     result.append(processed_body)
   220|             return "".join(result)
   221|         return re.sub(pattern, replace_foreach_loop, content, flags=re.DOTALL)
   222|     def _parse_control_blocks(self, content: str, context: dict[str, Any]) -> str:
   223|         """
   224|         Parse and process @if/@elseif/@else/@endif control blocks.
   225|         Supports syntax:
   226|         @if(condition)...@elseif(condition)...@else...@endif
   227|         Conditions can be:
   228|         - path.to.value (truthy check)
   229|         - path.to.value == "value" (equality)
   230|         - path.to.value != "value" (inequality)
   231|         - path.to.value > number (greater than)
   232|         - path.to.value < number (less than)
   233|         Args:
   234|             content: Template content containing control blocks
   235|             context: Context dictionary
   236|         Returns:
   237|             Content with control blocks evaluated
   238|         """


# ====================================================================
# FILE: src/mcipy/tool_manager.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-204 ---
     1| """
     2| Tool manager for MCI tools.
     3| This module provides the ToolManager class that manages tool definitions
     4| from an MCISchema, including retrieval, filtering, and execution.
     5| """
     6| from pathlib import Path
     7| from typing import Any
     8| from .executors import ExecutorFactory
     9| from .models import ExecutionResult, MCISchema, Tool
    10| class ToolManagerError(Exception):
    11|     """Exception raised for tool manager errors."""
    12|     pass
    13| class ToolManager:
    14|     """
    15|     Manager for MCI tool definitions.
    16|     Provides functionality to retrieve, filter, and execute tools from an
    17|     MCISchema. Handles input validation and dispatches execution to the
    18|     appropriate executor based on tool configuration.
    19|     """
    20|     def __init__(self, schema: MCISchema, schema_file_path: str | None = None):
    21|         """
    22|         Initialize the ToolManager with an MCISchema.
    23|         Args:
    24|             schema: MCISchema containing tool definitions
    25|             schema_file_path: Path to the schema file (for path validation context)
    26|         """
    27|         self.schema = schema
    28|         tools_list = schema.tools if schema.tools is not None else []
    29|         self._tool_map: dict[str, Tool] = {
    30|             tool.name: tool for tool in tools_list if not tool.disabled
    31|         }
    32|         self._schema_file_path = schema_file_path
    33|     def get_tool(self, name: str) -> Tool | None:
    34|         """
    35|         Retrieve a tool by name (case-sensitive), excluding disabled tools.
    36|         Args:
    37|             name: Name of the tool to retrieve
    38|         Returns:
    39|             Tool object if found and enabled, None otherwise
    40|         """
    41|         return self._tool_map.get(name)
    42|     def list_tools(self) -> list[Tool]:
    43|         """
    44|         List all available tools (excluding disabled tools).
    45|         Returns:
    46|             List of all enabled Tool objects in the schema
    47|         """
    48|         tools_list = self.schema.tools if self.schema.tools is not None else []
    49|         return [tool for tool in tools_list if not tool.disabled]
    50|     def filter_tools(
    51|         self, only: list[str] | None = None, without: list[str] | None = None
    52|     ) -> list[Tool]:
    53|         """
    54|         Filter tools by inclusion/exclusion lists (excluding disabled tools).
    55|         If both 'only' and 'without' are provided, 'only' takes precedence
    56|         (i.e., only tools in the 'only' list but not in 'without' are returned).
    57|         Disabled tools are always excluded regardless of filters.
    58|         Args:
    59|             only: List of tool names to include (if None, all enabled tools are considered)
    60|             without: List of tool names to exclude (if None, no tools are excluded)
    61|         Returns:
    62|             Filtered list of Tool objects
    63|         """
    64|         tools_list = self.schema.tools if self.schema.tools is not None else []
    65|         tools = [tool for tool in tools_list if not tool.disabled]
    66|         if only is not None:
    67|             only_set = set(only)
    68|             tools = [tool for tool in tools if tool.name in only_set]
    69|         if without is not None:
    70|             without_set = set(without)
    71|             tools = [tool for tool in tools if tool.name not in without_set]
    72|         return tools
    73|     def tags(self, tags: list[str]) -> list[Tool]:
    74|         """
    75|         Filter tools to include only those with at least one matching tag (excluding disabled tools).
    76|         Returns tools that have at least one tag matching any tag in the provided list.
    77|         Uses OR logic: a tool is included if it has any of the specified tags.
    78|         Tags are matched case-sensitively and exactly as provided.
    79|         Args:
    80|             tags: List of tags to filter by
    81|         Returns:
    82|             Filtered list of Tool objects that have at least one matching tag
    83|         """
    84|         tools_list = self.schema.tools if self.schema.tools is not None else []
    85|         tools = [tool for tool in tools_list if not tool.disabled]
    86|         if not tags:
    87|             return []
    88|         tags_set = set(tags)
    89|         tools = [tool for tool in tools if any(tag in tags_set for tag in tool.tags)]
    90|         return tools
    91|     def withoutTags(self, tags: list[str]) -> list[Tool]:
    92|         """
    93|         Filter tools to exclude those with any matching tag (excluding disabled tools).
    94|         Returns tools that do NOT have any tags matching the provided list.
    95|         Uses OR logic for exclusion: a tool is excluded if it has any of the specified tags.
    96|         Tags are matched case-sensitively and exactly as provided.
    97|         Args:
    98|             tags: List of tags to exclude
    99|         Returns:
   100|             Filtered list of Tool objects that do not have any of the specified tags
   101|         """
   102|         tools_list = self.schema.tools if self.schema.tools is not None else []
   103|         tools = [tool for tool in tools_list if not tool.disabled]
   104|         if not tags:
   105|             return tools
   106|         tags_set = set(tags)
   107|         tools = [tool for tool in tools if not any(tag in tags_set for tag in tool.tags)]
   108|         return tools
   109|     def toolsets(self, toolset_names: list[str]) -> list[Tool]:
   110|         """
   111|         Filter tools to include only those from specified toolsets (excluding disabled tools).
   112|         Returns tools that were loaded from any of the specified toolsets.
   113|         Uses OR logic: a tool is included if it came from any of the specified toolsets.
   114|         Only tools that were registered by their toolset's schema-level filter are included.
   115|         Args:
   116|             toolset_names: List of toolset names to filter by
   117|         Returns:
   118|             Filtered list of Tool objects from the specified toolsets
   119|         """
   120|         tools_list = self.schema.tools if self.schema.tools is not None else []
   121|         tools = [tool for tool in tools_list if not tool.disabled]
   122|         if not toolset_names:
   123|             return []
   124|         toolset_set = set(toolset_names)
   125|         tools = [
   126|             tool
   127|             for tool in tools
   128|             if tool.toolset_source is not None and tool.toolset_source in toolset_set
   129|         ]
   130|         return tools
   131|     def execute(
   132|         self,
   133|         tool_name: str,
   134|         properties: dict[str, Any] | None = None,
   135|         env_vars: dict[str, Any] | None = None,
   136|     ) -> ExecutionResult:
   137|         """
   138|         Execute a tool by name with the provided properties.
   139|         Validates the tool exists, validates input properties against the tool's
   140|         input schema, and executes the tool using the appropriate executor.
   141|         Args:
   142|             tool_name: Name of the tool to execute
   143|             properties: Properties/parameters to pass to the tool (default: empty dict)
   144|             env_vars: Environment variables for template context (default: empty dict)
   145|         Returns:
   146|             ExecutionResult with success/error status and content
   147|         Raises:
   148|             ToolManagerError: If tool not found or properties validation fails
   149|         """
   150|         if properties is None:
   151|             properties = {}
   152|         if env_vars is None:
   153|             env_vars = {}
   154|         tool = self.get_tool(tool_name)
   155|         if tool is None:
   156|             raise ToolManagerError(f"Tool not found: {tool_name}")
   157|         if tool.inputSchema is not None and tool.inputSchema:
   158|             self._validate_input_properties(tool, properties)
   159|         context: dict[str, Any] = {
   160|             "props": properties,
   161|             "env": env_vars,
   162|             "input": properties,  # Alias for backward compatibility
   163|         }
   164|         path_context: dict[str, Any] | None = None
   165|         if self._schema_file_path:
   166|             from .path_validator import PathValidator
   167|             context_dir = Path(self._schema_file_path).parent
   168|             enable_any_paths, directory_allow_list = PathValidator.merge_settings(
   169|                 schema_enable_any_paths=self.schema.enableAnyPaths,
   170|                 schema_directory_allow_list=self.schema.directoryAllowList,
   171|                 tool_enable_any_paths=tool.enableAnyPaths,
   172|                 tool_directory_allow_list=tool.directoryAllowList,
   173|             )
   174|             path_context = {
   175|                 "validator": PathValidator(
   176|                     context_dir=context_dir,
   177|                     enable_any_paths=enable_any_paths,
   178|                     directory_allow_list=directory_allow_list,
   179|                 )
   180|             }
   181|         context["path_validation"] = path_context
   182|         executor = ExecutorFactory.get_executor(
   183|             tool.execution.type, mcp_servers=self.schema.mcp_servers
   184|         )
   185|         result = executor.execute(tool.execution, context)
   186|         return result
   187|     def _validate_input_properties(self, tool: Tool, properties: dict[str, Any]) -> None:
   188|         """
   189|         Validate properties against the tool's input schema.
   190|         Checks that all required properties are provided.
   191|         Args:
   192|             tool: Tool object with inputSchema
   193|             properties: Properties to validate
   194|         Raises:
   195|             ToolManagerError: If required properties are missing
   196|         """
   197|         input_schema = tool.inputSchema
   198|         if not input_schema:
   199|             return
   200|         required = input_schema.get("required", [])
   201|         if required:
   202|             missing_props = [prop for prop in required if prop not in properties]
   203|             if missing_props:
   204|                 raise ToolManagerError(

