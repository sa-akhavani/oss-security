--- a/devtools/lint.py
+++ b/devtools/lint.py
@@ -1,15 +1,15 @@
 import subprocess
 from funlog import log_calls
 from rich import get_console, reconfigure
 from rich import print as rprint
-SRC_PATHS = ["src", "devtools"]
+SRC_PATHS = ["src", "tests", "devtools"]
 DOC_PATHS = ["README.md"]
 reconfigure(emoji=not get_console().options.legacy_windows)  # No emojis on legacy windows.
 def main():
     rprint()
     errcount = 0
     errcount += run(["codespell", "--write-changes", *SRC_PATHS, *DOC_PATHS])
     errcount += run(["ruff", "check", "--fix", *SRC_PATHS])
     errcount += run(["ruff", "format", *SRC_PATHS])
     errcount += run(["basedpyright", "--stats", *SRC_PATHS])
     rprint()

--- a/example.py
+++ b/example.py
@@ -28,35 +28,35 @@
     print()
     print("2. Listing available tools...")
     tool_names = client.list_tools()
     print(f"   Found {len(tool_names)} tools:")
     for tool_name in tool_names:
         print(f"   - {tool_name}")
     print()
     print("3. Executing 'generate_message' tool...")
     print("   Input: username='Alice'")
     result = client.execute(tool_name="generate_message", properties={"username": "Alice"})
-    if result.result.isError:
-        print(f"   ✗ Error: {result.result.content[0].text}")
+    if result.isError:
+        print(f"   ✗ Error: {result.error}")
     else:
         print(f"   ✓ Success!")
-        print(f"   Output: {result.result.content[0].text}")
+        print(f"   Output: {result.content}")
     print()
     print("4. Executing 'load_template' tool...")
     print("   Input: username='Bob'")
     print("   Note: This tool reads from ./text.txt with template substitution")
     result = client.execute(tool_name="load_template", properties={"username": "Bob", "new_prop": [1, 2, 3]})
-    if result.result.isError:
-        print(f"   ✗ Error: {result.result.content[0].text}")
+    if result.isError:
+        print(f"   ✗ Error: {result.error}")
     else:
         print(f"   ✓ Success!")
-        print(f"   Output: {result.result.content[0].text}")
+        print(f"   Output: {result.content}")
     print()
     print("5. Demonstrating tool filtering...")
     print("   Filtering to only 'load_template' and 'generate_message':")
     filtered_tools = client.only(["load_template", "generate_message"])
     print(f"   Found {len(filtered_tools)} tools:")
     for tool in filtered_tools:
         print(f"   - {tool.name}: {tool.title}")
     print()
     print("6. Getting tool schema...")
     schema = client.get_tool_schema("generate_message")

--- a/examples/example_usage.py
+++ b/examples/example_usage.py
@@ -44,66 +44,66 @@
     """Demonstrate CLI execution examples."""
     print_section("CLI Execution Examples")
     client = MCIClient(json_file_path="examples/cli_example.json")
     print("Available CLI tools:")
     for tool_name in client.list_tools():
         print(f"  - {tool_name}")
     print()
     print("Executing: count_lines on README.md")
     try:
         result = client.execute(tool_name="count_lines", properties={"file_path": "README.md"})
-        if not result.result.isError:
+        if not result.isError:
             print("  ✓ Success!")
-            print(f"  Output: {result.result.content[0].text.strip()}")
+            print(f"  Output: {result.content.strip()}")
         else:
-            print(f"  ✗ Error: {result.result.content[0].text}")
+            print(f"  ✗ Error: {result.error}")
     except Exception as e:
         print(f"  ✗ Exception: {e}")
     print()
     print("Executing: list_files on current directory")
     try:
         result = client.execute(
             tool_name="list_files", properties={"directory": ".", "show_hidden": False}
         )
-        if not result.result.isError:
+        if not result.isError:
             print("  ✓ Success!")
-            lines = result.result.content[0].text.strip().split("\n")
+            lines = result.content.strip().split("\n")
             print("  Output (first 5 lines):")
             for line in lines[:5]:
                 print(f"    {line}")
             if len(lines) > 5:
                 print(f"    ... and {len(lines) - 5} more lines")
         else:
-            print(f"  ✗ Error: {result.result.content[0].text}")
+            print(f"  ✗ Error: {result.error}")
     except Exception as e:
         print(f"  ✗ Exception: {e}")
     print()
 def demo_file_examples():
     """Demonstrate file execution examples."""
     print_section("File Execution Examples")
     client = MCIClient(
         json_file_path="examples/file_example.json",
         env_vars={"CURRENT_DATE": datetime.now().strftime("%Y-%m-%d"), "USERNAME": "demo_user"},
     )
     print("Available File tools:")
     for tool_name in client.list_tools():
         print(f"  - {tool_name}")
     print()
     print("Executing: load_template")
     print("  Note: This tool reads ./text.txt with placeholder substitution")
     try:
         result = client.execute(tool_name="load_template", properties={"username": "Alice"})
-        if not result.result.isError:
+        if not result.isError:
             print("  ✓ Success!")
-            print(f"  Content preview: {result.result.content[0].text[:200]}...")
+            print(f"  Content preview: {result.content[:200]}...")
         else:
-            print(f"  ✗ Error: {result.result.content[0].text}")
+            print(f"  ✗ Error: {result.error}")
             print("  (This is expected if text.txt doesn't exist)")
     except Exception as e:
         print(f"  ✗ Exception: {e}")
     print()
 def demo_text_examples():
     """Demonstrate text execution examples."""
     print_section("Text Execution Examples")
     client = MCIClient(
         json_file_path="examples/text_example.json",
         env_vars={
@@ -111,43 +111,43 @@
             "TIMESTAMP": datetime.now().isoformat(),
             "APP_VERSION": "1.0.0",
         },
     )
     print("Available Text tools:")
     for tool_name in client.list_tools():
         print(f"  - {tool_name}")
     print()
     print("Executing: generate_message")
     result = client.execute(tool_name="generate_message", properties={"username": "Bob"})
-    if not result.result.isError:
-        print("  ✓ Success!")
-        print(f"  Output: {result.result.content[0].text}")
-    else:
-        print(f"  ✗ Error: {result.result.content[0].text}")
+    if not result.isError:
+        print("  ✓ Success!")
+        print(f"  Output: {result.content}")
+    else:
+        print(f"  ✗ Error: {result.error}")
     print()
     print("Executing: generate_welcome")
     result = client.execute(
         tool_name="generate_welcome", properties={"username": "Alice", "email": "alice@example.com"}
     )
-    if not result.result.isError:
-        print("  ✓ Success!")
-        print(f"  Output: {result.result.content[0].text}")
-    else:
-        print(f"  ✗ Error: {result.result.content[0].text}")
+    if not result.isError:
+        print("  ✓ Success!")
+        print(f"  Output: {result.content}")
+    else:
+        print(f"  ✗ Error: {result.error}")
     print()
     print("Executing: status_message")
     result = client.execute(tool_name="status_message", properties={"status": "operational"})
-    if not result.result.isError:
-        print("  ✓ Success!")
-        print(f"  Output: {result.result.content[0].text}")
-    else:
-        print(f"  ✗ Error: {result.result.content[0].text}")
+    if not result.isError:
+        print("  ✓ Success!")
+        print(f"  Output: {result.content}")
+    else:
+        print(f"  ✗ Error: {result.error}")
     print()
 def demo_mixed_examples():
     """Demonstrate mixed execution examples (all types)."""
     print_section("Mixed Execution Examples (All Types)")
     client = MCIClient(
         json_file_path="examples/mixed_example.json",
         env_vars={
             "CURRENT_DATE": datetime.now().strftime("%Y-%m-%d"),
             "BEARER_TOKEN": "demo-bearer-token",
         },
@@ -158,25 +158,25 @@
         print(f"  - {tool.name} ({tool.execution.type}): {tool.title}")
     print()
     print("Filtering to only text tools:")
     text_tools = client.only(["generate_message", "generate_welcome"])
     print(f"  Found {len(text_tools)} tools:")
     for tool in text_tools:
         print(f"  - {tool.name}")
     print()
     print("Executing: generate_message from mixed example")
     result = client.execute(tool_name="generate_message", properties={"username": "Charlie"})
-    if not result.result.isError:
-        print("  ✓ Success!")
-        print(f"  Output: {result.result.content[0].text}")
-    else:
-        print(f"  ✗ Error: {result.result.content[0].text}")
+    if not result.isError:
+        print("  ✓ Success!")
+        print(f"  Output: {result.content}")
+    else:
+        print(f"  ✗ Error: {result.error}")
     print()
 def demo_tool_inspection():
     """Demonstrate tool inspection capabilities."""
     print_section("Tool Inspection")
     client = MCIClient(json_file_path="examples/text_example.json")
     print("Getting schema for 'generate_report_summary':")
     schema = client.get_tool_schema("generate_report_summary")
     print(f"  Required properties: {schema.get('required', [])}")
     print("  Properties:")
     for prop_name, prop_details in schema.get("properties", {}).items():

--- a/examples/toolsets_example_usage.py
+++ b//dev/null
@@ -1,91 +0,0 @@
-"""
-Example demonstrating the Toolsets feature.
-This example shows how to:
-- Load toolsets from a library directory
-- Apply schema-level filters to toolsets
-- Use adapter-level filtering with toolsets() method
-- Mix main schema tools with toolset tools
-- Filter by tags and names across all tools
-"""
-from mcipy import MCIClient
-def print_section(title: str):
-    """Print a section header."""
-    print(f"\n{'=' * 70}")
-    print(f"  {title}")
-    print('=' * 70 + "\n")
-def print_tools(tools, prefix=""):
-    """Print tool names with their sources."""
-    for tool in tools:
-        source = f" (from {tool.toolset_source})" if tool.toolset_source else " (main)"
-        tags = f" [{', '.join(tool.tags)}]" if tool.tags else ""
-        print(f"{prefix}{tool.name}{source}{tags}")
-def main():
-    """Run toolsets example."""
-    print_section("Initializing MCI Client with Toolsets")
-    client = MCIClient(
-        schema_file_path="examples/toolsets_example.mci.json",
-        env_vars={
-            "APP_VERSION": "1.0.0",
-            "ENVIRONMENT": "development",
-            "DEBUG_MODE": "true"
-        }
-    )
-    print("✓ Client initialized with main schema and toolsets")
-    print_section("1. All Available Tools")
-    all_tools = client.tools()
-    print(f"Total: {len(all_tools)} tools\n")
-    print_tools(all_tools, "  ")
-    print_section("2. Filter by Toolset")
-    print("Weather toolset tools:")
-    weather_tools = client.toolsets(["weather"])
-    print_tools(weather_tools, "  ")
-    print("\nDatabase toolset tools:")
-    db_tools = client.toolsets(["database"])
-    print_tools(db_tools, "  ")
-    print("\nGitHub toolset tools:")
-    github_tools = client.toolsets(["github"])
-    print_tools(github_tools, "  ")
-    print_section("3. Multiple Toolsets")
-    api_tools = client.toolsets(["weather", "database"])
-    print(f"Weather + Database tools: {len(api_tools)}")
-    print_tools(api_tools, "  ")
-    print_section("4. Filter by Tags")
-    read_tools = client.tags(["read"])
-    print(f"Read-only tools: {len(read_tools)}")
-    print_tools(read_tools, "  ")
-    write_tools = client.tags(["write"])
-    print(f"\nWrite tools: {len(write_tools)}")
-    print_tools(write_tools, "  ")
-    print_section("5. Filter by Tool Names")
-    specific_tools = client.only(["app_status", "get_weather", "query_data"])
-    print(f"Specific tools: {len(specific_tools)}")
-    print_tools(specific_tools, "  ")
-    print_section("6. Exclude Specific Tools")
-    safe_tools = client.without(["delete_data"])
-    print(f"Tools without delete_data: {len(safe_tools)}")
-    print_tools(safe_tools, "  ")
-    print_section("7. Execute Tools from Different Sources")
-    print("Executing main schema tool (app_status):")
-    result1 = client.execute("app_status")
-    print(f"  → {result1.result.content[0].text}")
-    print("\nExecuting toolset tool (get_weather):")
-    result2 = client.execute("get_weather", {"location": "San Francisco"})
-    print(f"  → {result2.result.content[0].text}")
-    print("\nExecuting toolset tool (query_data):")
-    result3 = client.execute("query_data", {"query": "SELECT * FROM users"})
-    print(f"  → {result3.result.content[0].text}")
-    print_section("Summary")
-    print("""
-The Toolsets feature allows you to:
-  ✓ Organize tools into reusable libraries
-  ✓ Apply schema-level filters when loading toolsets
-  ✓ Filter tools by their source toolset at runtime
-  ✓ Mix main schema tools with toolset tools
-  ✓ Use all existing filtering methods (tags, only, without, etc.)
-See the documentation for more details:
-  - Schema Reference: docs/schema_reference.md
-  - API Reference: docs/api_reference.md
-  - Quickstart Guide: docs/quickstart.md
-    """)
-if __name__ == "__main__":
-    main()

--- a/src/mcipy/__init__.py
+++ b/src/mcipy/__init__.py
@@ -1,61 +1,45 @@
 from .client import MCIClient, MCIClientError
 from .enums import ExecutionType
-from .mcp_client import ClientCfg, LiteMcpClient, ServerCfg, SseCfg, StdioCfg
 from .models import (
-    Annotations,
     ApiKeyAuth,
-    AudioContent,
     BasicAuth,
     BearerAuth,
     CLIExecutionConfig,
     ExecutionResult,
-    ExecutionResultContent,
     FileExecutionConfig,
     FlagConfig,
     HTTPBodyConfig,
     HTTPExecutionConfig,
-    ImageContent,
     MCISchema,
     Metadata,
     OAuth2Auth,
     RetryConfig,
-    TextContent,
     TextExecutionConfig,
     Tool,
 )
 from .parser import SchemaParser, SchemaParserError
 from .tool_manager import ToolManager, ToolManagerError
 __all__ = (
     "MCIClient",
     "MCIClientError",
-    "LiteMcpClient",
-    "ClientCfg",
-    "ServerCfg",
-    "StdioCfg",
-    "SseCfg",
     "ExecutionType",
-    "Annotations",
     "ApiKeyAuth",
-    "AudioContent",
     "BasicAuth",
     "BearerAuth",
     "CLIExecutionConfig",
     "ExecutionResult",
-    "ExecutionResultContent",
     "FileExecutionConfig",
     "FlagConfig",
     "HTTPBodyConfig",
     "HTTPExecutionConfig",
-    "ImageContent",
     "MCISchema",
     "Metadata",
     "OAuth2Auth",
     "RetryConfig",
-    "TextContent",
     "TextExecutionConfig",
     "Tool",
     "SchemaParser",
     "SchemaParserError",
     "ToolManager",
     "ToolManagerError",
 )

--- a/src/mcipy/client.py
+++ b/src/mcipy/client.py
@@ -14,128 +14,77 @@
 class MCIClient:
     """
     Main client for MCI adapter.
     Provides the primary API for loading, filtering, and executing MCI tools.
     Handles schema parsing, environment variable management, and tool execution
     orchestration through the ToolManager.
     Example:
         ```python
         from mcipy import MCIClient
         client = MCIClient(
-            schema_file_path="example.mci.json",
-            env_vars={"API_KEY": "your-secret-key"}
-        )
-        client = MCIClient(
-            schema_file_path="example.mci.yaml",
+            json_file_path="example.mci.json",
             env_vars={"API_KEY": "your-secret-key"}
         )
         tool_names = client.list_tools()
         weather_tools = client.only(["get_weather", "get_forecast"])
         safe_tools = client.without(["delete_data", "admin_tools"])
         result = client.execute(
             tool_name="get_weather",
             properties={"location": "New York"}
         )
         ```
     """
-    def __init__(
-        self,
-        schema_file_path: str | None = None,
-        env_vars: dict[str, Any] | None = None,
-        json_file_path: str | None = None,
-    ):
+    def __init__(self, json_file_path: str, env_vars: dict[str, Any] | None = None):
         """
         Initialize the MCI client with a schema file and environment variables.
-        Loads the MCI schema (JSON or YAML), stores environment variables for templating,
+        Loads the MCI JSON schema, stores environment variables for templating,
         and initializes the ToolManager for tool execution.
         Args:
-            schema_file_path: Path to the MCI schema file (.json, .yaml, or .yml)
+            json_file_path: Path to the MCI JSON schema file
             env_vars: Environment variables for template substitution (default: empty dict)
-            json_file_path: DEPRECATED. Use schema_file_path instead. Kept for backward compatibility.
         Raises:
             MCIClientError: If the schema file cannot be loaded or parsed
         """
-        if json_file_path is not None and schema_file_path is None:
-            schema_file_path = json_file_path
-        elif schema_file_path is None:
-            raise MCIClientError("Either 'schema_file_path' or 'json_file_path' must be provided")
-        self._schema_file_path = schema_file_path
+        try:
+            self._schema = SchemaParser.parse_file(json_file_path)
+        except Exception as e:
+            raise MCIClientError(f"Failed to load schema from {json_file_path}: {e}") from e
         self._env_vars = env_vars if env_vars is not None else {}
-        try:
-            self._schema = SchemaParser.parse_file(schema_file_path, env_vars=self._env_vars)
-        except Exception as e:
-            raise MCIClientError(f"Failed to load schema from {schema_file_path}: {e}") from e
-        self._tool_manager = ToolManager(self._schema, schema_file_path)
+        self._tool_manager = ToolManager(self._schema)
     def tools(self) -> list[Tool]:
         """
-        Get all available tools (excluding disabled tools).
+        Get all available tools.
         Returns:
-            List of all enabled Tool objects in the schema
+            List of all Tool objects in the schema
         """
         return self._tool_manager.list_tools()
     def only(self, tool_names: list[str]) -> list[Tool]:
         """
-        Filter to include only specified tools (excluding disabled tools).
-        Returns only the tools whose names are in the provided list and
-        are not disabled. Tools not in the list or that are disabled are excluded.
+        Filter to include only specified tools.
+        Returns only the tools whose names are in the provided list.
+        Tools not in the list are excluded.
         Args:
             tool_names: List of tool names to include
         Returns:
-            Filtered list of enabled Tool objects
+            Filtered list of Tool objects
         """
         return self._tool_manager.filter_tools(only=tool_names)
     def without(self, tool_names: list[str]) -> list[Tool]:
         """
-        Filter to exclude specified tools (disabled tools are also excluded).
-        Returns all enabled tools except those whose names are in the provided list.
+        Filter to exclude specified tools.
+        Returns all tools except those whose names are in the provided list.
         Args:
             tool_names: List of tool names to exclude
         Returns:
-            Filtered list of enabled Tool objects
+            Filtered list of Tool objects
         """
         return self._tool_manager.filter_tools(without=tool_names)
-    def tags(self, tags: list[str]) -> list[Tool]:
-        """
-        Filter tools to include only those with at least one matching tag (excluding disabled tools).
-        Returns tools that have at least one tag matching any tag in the provided list.
-        Uses OR logic: a tool is included if it has any of the specified tags.
-        Tags are matched case-sensitively and exactly as provided.
-        Args:
-            tags: List of tags to filter by
-        Returns:
-            Filtered list of enabled Tool objects that have at least one matching tag
-        """
-        return self._tool_manager.tags(tags)
-    def withoutTags(self, tags: list[str]) -> list[Tool]:
-        """
-        Filter tools to exclude those with any matching tag (excluding disabled tools).
-        Returns tools that do NOT have any tags matching the provided list.
-        Uses OR logic for exclusion: a tool is excluded if it has any of the specified tags.
-        Tags are matched case-sensitively and exactly as provided.
-        Args:
-            tags: List of tags to exclude
-        Returns:
-            Filtered list of enabled Tool objects that do not have any of the specified tags
-        """
-        return self._tool_manager.withoutTags(tags)
-    def toolsets(self, toolset_names: list[str]) -> list[Tool]:
-        """
-        Filter tools to include only those from specified toolsets (excluding disabled tools).
-        Returns tools that were loaded from any of the specified toolsets.
-        Uses OR logic: a tool is included if it came from any of the specified toolsets.
-        Only tools that were registered by their toolset's schema-level filter are included.
-        Args:
-            toolset_names: List of toolset names to filter by
-        Returns:
-            Filtered list of enabled Tool objects from the specified toolsets
-        """
-        return self._tool_manager.toolsets(toolset_names)
     def execute(self, tool_name: str, properties: dict[str, Any] | None = None) -> ExecutionResult:
         """
         Execute a tool by name with the provided properties.
         Validates that the tool exists, builds the execution context from
         properties and environment variables, and executes the tool using
         the appropriate executor.
         Args:
             tool_name: Name of the tool to execute
             properties: Properties/parameters to pass to the tool (default: empty dict)
         Returns:
@@ -146,23 +95,23 @@
         try:
             return self._tool_manager.execute(
                 tool_name=tool_name,
                 properties=properties,
                 env_vars=self._env_vars,
             )
         except ToolManagerError as e:
             raise MCIClientError(str(e)) from e
     def list_tools(self) -> list[str]:
         """
-        List available tool names (excluding disabled tools).
+        List available tool names.
         Returns:
-            List of enabled tool names (strings)
+            List of tool names (strings)
         """
         return [tool.name for tool in self._tool_manager.list_tools()]
     def get_tool_schema(self, tool_name: str) -> dict[str, Any]:
         """
         Get a tool's input schema.
         Returns the JSON schema that defines the expected input properties
         for the specified tool.
         Args:
             tool_name: Name of the tool
         Returns:

--- a/src/mcipy/enums.py
+++ b/src/mcipy/enums.py
@@ -5,17 +5,15 @@
 """
 from enum import Enum
 class ExecutionType(str, Enum):
     """
     Defines the types of execution supported by MCI.
     Each execution type corresponds to a different way of executing a tool:
     - HTTP: Make HTTP requests to APIs
     - CLI: Execute command-line tools
     - FILE: Read and parse files
     - TEXT: Return text with placeholder substitution
-    - MCP: Execute tools via Model Context Protocol servers
     """
     HTTP = "http"
     CLI = "cli"
     FILE = "file"
     TEXT = "text"
-    MCP = "mcp"

--- a/src/mcipy/executors/__init__.py
+++ b/src/mcipy/executors/__init__.py
@@ -1,52 +1,44 @@
 """
 Execution handlers for MCI tools.
 This module provides the executor classes that handle different types of
-tool execution (HTTP, CLI, file, text, MCP). Each executor inherits from BaseExecutor
+tool execution (HTTP, CLI, file, text). Each executor inherits from BaseExecutor
 and implements the execute() method according to its execution type.
 The ExecutorFactory provides centralized instantiation of executors based on
 execution type, with singleton caching for performance.
 """
-from typing import Any
 from ..enums import ExecutionType
 from .base import BaseExecutor
 from .cli_executor import CLIExecutor
 from .file_executor import FileExecutor
 from .http_executor import HTTPExecutor
-from .mcp_executor import MCPExecutor
 from .text_executor import TextExecutor
 class ExecutorFactory:
     """
     Factory for creating and caching executor instances.
     Provides centralized instantiation of executors based on execution type.
     Uses singleton pattern to cache executor instances for better performance.
-    MCP executors are not cached as they require server configuration.
     """
     _executors: dict[ExecutionType, BaseExecutor] = {}
     @classmethod
-    def get_executor(
-        cls, execution_type: ExecutionType, mcp_servers: dict[str, Any] | None = None
-    ) -> BaseExecutor:
+    def get_executor(cls, execution_type: ExecutionType) -> BaseExecutor:
         """
         Get an executor instance for the given execution type.
-        Returns a cached executor instance if available (except for MCP),
-        otherwise creates a new one and caches it for future use.
+        Returns a cached executor instance if available, otherwise creates
+        a new one and caches it for future use.
         Args:
-            execution_type: The type of execution (HTTP, CLI, FILE, TEXT, MCP)
-            mcp_servers: Dictionary of MCP server configurations (required for MCP executor)
+            execution_type: The type of execution (HTTP, CLI, FILE, TEXT)
         Returns:
             BaseExecutor instance for the specified type
         Raises:
             ValueError: If the execution type is not supported
         """
-        if execution_type == ExecutionType.MCP:
-            return MCPExecutor(mcp_servers=mcp_servers)
         if execution_type in cls._executors:
             return cls._executors[execution_type]
         if execution_type == ExecutionType.HTTP:
             executor = HTTPExecutor()
         elif execution_type == ExecutionType.CLI:
             executor = CLIExecutor()
         elif execution_type == ExecutionType.FILE:
             executor = FileExecutor()
         elif execution_type == ExecutionType.TEXT:
             executor = TextExecutor()
@@ -60,13 +52,12 @@
         Clear the executor cache.
         Useful for testing or when you want to ensure fresh executor instances.
         """
         cls._executors.clear()
 __all__ = [
     "BaseExecutor",
     "CLIExecutor",
     "ExecutorFactory",
     "FileExecutor",
     "HTTPExecutor",
-    "MCPExecutor",
     "TextExecutor",
 ]

--- a/src/mcipy/executors/base.py
+++ b/src/mcipy/executors/base.py
@@ -1,23 +1,18 @@
 """
 Base executor class for MCI tool execution.
 This module provides the abstract BaseExecutor class that all executors inherit from.
 It provides common functionality for context building, timeout handling, and error formatting.
 """
 from abc import ABC, abstractmethod
 from typing import Any
-from ..models import (
-    ExecutionConfig,
-    ExecutionResult,
-    ExecutionResultContent,
-    TextContent,
-)
+from ..models import ExecutionConfig, ExecutionResult
 from ..templating import TemplateEngine
 class BaseExecutor(ABC):
     """
     Abstract base class for all executors.
     Provides common execution logic including context building, timeout handling,
     and error formatting. All concrete executors (HTTP, CLI, File, Text) inherit
     from this base class and implement the execute() method.
     """
     def __init__(self):
         """Initialize the base executor with a template engine."""
@@ -64,31 +59,30 @@
             Timeout in seconds (minimum 1 second)
         """
         if timeout_ms <= 0:
             return 30  # Default timeout of 30 seconds
         timeout_s = max(1, (timeout_ms + 999) // 1000)
         return timeout_s
     def _format_error(self, error: Exception) -> ExecutionResult:
         """
         Format an exception into a standardized ExecutionResult error response.
         Converts any exception into a consistent error format with isError=True
-        and the error message as a text content object.
+        and the error message as a string.
         Args:
             error: Exception that occurred during execution
         Returns:
             ExecutionResult with isError=True and error message
         """
         return ExecutionResult(
-            result=ExecutionResultContent(
-                isError=True,
-                content=[TextContent(text=str(error))],
-            )
+            isError=True,
+            error=str(error),
+            content=None,
         )
     def _apply_basic_templating_to_config(
         self, config: ExecutionConfig, context: dict[str, Any]
     ) -> None:
         """
         Apply basic templating to all string fields in the execution config.
         Recursively processes the config object and replaces placeholders like
         {{props.x}} and {{env.Y}} in all string fields. This is applied to
         the entire execution configuration (URLs, paths, headers, params, etc.)
         but NOT to large text content which uses advanced templating.

--- a/src/mcipy/executors/cli_executor.py
+++ b/src/mcipy/executors/cli_executor.py
@@ -1,94 +1,65 @@
 """
 CLI executor for MCI tools.
 This module provides the CLIExecutor class that handles CLI-based tool execution.
 It supports command execution with arguments, boolean and value flags, working directory,
 and timeout handling. The executor is platform-aware and handles Windows/Linux/macOS
 differences in command execution.
 """
 import subprocess
 from typing import Any
-from ..models import (
-    CLIExecutionConfig,
-    ExecutionConfig,
-    ExecutionResult,
-    ExecutionResultContent,
-    FlagConfig,
-    TextContent,
-)
+from ..models import CLIExecutionConfig, ExecutionConfig, ExecutionResult, FlagConfig
 from .base import BaseExecutor
 class CLIExecutor(BaseExecutor):
     """
     Executor for CLI-based tools.
     Handles command-line tool execution with support for arguments, flags,
     working directory, and timeouts. Applies templating to all command components
     and handles platform-specific differences.
     """
     def __init__(self):
         """Initialize the CLI executor with a template engine."""
         super().__init__()
     def execute(self, config: ExecutionConfig, context: dict[str, Any]) -> ExecutionResult:
         """
         Execute a CLI-based tool by running a subprocess.
         Args:
             config: CLI execution configuration with command, args, flags, cwd, timeout
-            context: Context dictionary with 'props', 'env', 'input', and 'path_validation' keys
+            context: Context dictionary with 'props', 'env', and 'input' keys
         Returns:
             ExecutionResult with command output or error
         """
         if not isinstance(config, CLIExecutionConfig):
             return self._format_error(
                 TypeError(f"Expected CLIExecutionConfig, got {type(config).__name__}")
             )
         try:
             self._apply_basic_templating_to_config(config, context)
-            if context.get("path_validation") and config.cwd:
-                validator = context["path_validation"]["validator"]
-                from ..path_validator import PathValidationError
-                try:
-                    validator.validate_path(config.cwd)
-                except PathValidationError as e:
-                    return self._format_error(e)
             command_list = self._build_command_args(config, context)
             cwd = config.cwd if config.cwd else None
             timeout = self._handle_timeout(config.timeout_ms)
             stdout, stderr, returncode = self._run_subprocess(command_list, cwd, timeout)
-            stdout_bytes = len(stdout.encode())
-            stderr_bytes = len(stderr.encode())
             if returncode != 0:
                 error_msg = f"Command exited with code {returncode}"
                 if stderr:
                     error_msg += f": {stderr}"
                 return ExecutionResult(
-                    result=ExecutionResultContent(
-                        isError=True,
-                        content=[TextContent(text=error_msg)],
-                        metadata={
-                            "exit_code": returncode,
-                            "stdout_bytes": stdout_bytes,
-                            "stderr_bytes": stderr_bytes,
-                            "stderr": stderr,
-                            "stdout": stdout,
-                        },
-                    )
+                    isError=True,
+                    error=error_msg,
+                    content=None,
+                    metadata={"returncode": returncode, "stderr": stderr, "stdout": stdout},
                 )
             return ExecutionResult(
-                result=ExecutionResultContent(
-                    isError=False,
-                    content=[TextContent(text=stdout)],
-                    metadata={
-                        "exit_code": returncode,
-                        "stdout_bytes": stdout_bytes,
-                        "stderr_bytes": stderr_bytes,
-                        "stderr": stderr,
-                    },
-                )
+                isError=False,
+                content=stdout,
+                error=None,
+                metadata={"returncode": returncode, "stderr": stderr},
             )
         except Exception as e:
             return self._format_error(e)
     def _build_command_args(self, config: CLIExecutionConfig, context: dict[str, Any]) -> list[str]:
         """
         Build the full command list with arguments and flags.
         Combines the command, arguments, and flags into a single list suitable
         for subprocess execution. Handles both boolean and value flags.
         Args:
             config: CLI execution configuration

--- a/src/mcipy/executors/file_executor.py
+++ b/src/mcipy/executors/file_executor.py
@@ -1,64 +1,50 @@
 """
 File executor for MCI tools.
 This module provides the FileExecutor class that handles file-based tool execution.
 It reads files from disk and optionally applies templating to the content.
 """
 from pathlib import Path
 from typing import Any
-from ..models import (
-    ExecutionConfig,
-    ExecutionResult,
-    ExecutionResultContent,
-    FileExecutionConfig,
-    TextContent,
-)
+from ..models import ExecutionConfig, ExecutionResult, FileExecutionConfig
 from .base import BaseExecutor
 class FileExecutor(BaseExecutor):
     """
     Executor for file-based tools.
     Reads files from disk and optionally applies templating to the content.
     Supports both basic placeholder substitution and advanced templating
     with @for, @foreach, and @if directives when enableTemplating is true.
     """
     def __init__(self):
         """Initialize the file executor with a template engine."""
         super().__init__()
     def execute(self, config: ExecutionConfig, context: dict[str, Any]) -> ExecutionResult:
         """
         Execute a file-based tool by reading and optionally templating file content.
         Args:
             config: File execution configuration with path and enableTemplating flag
-            context: Context dictionary with 'props', 'env', 'input', and 'path_validation' keys
+            context: Context dictionary with 'props', 'env', and 'input' keys
         Returns:
             ExecutionResult with file content (possibly templated) or error
         """
         if not isinstance(config, FileExecutionConfig):
             return self._format_error(
                 TypeError(f"Expected FileExecutionConfig, got {type(config).__name__}")
             )
         try:
             self._apply_basic_templating_to_config(config, context)
-            if context.get("path_validation"):
-                validator = context["path_validation"]["validator"]
-                from ..path_validator import PathValidationError
-                try:
-                    validator.validate_path(config.path)
-                except PathValidationError as e:
-                    return self._format_error(e)
             content = self._read_file(config.path)
             parsed_content = self._parse_content(content, context, config.enableTemplating)
             return ExecutionResult(
-                result=ExecutionResultContent(
-                    isError=False,
-                    content=[TextContent(text=parsed_content)],
-                )
+                isError=False,
+                content=parsed_content,
+                error=None,
             )
         except Exception as e:
             return self._format_error(e)
     def _read_file(self, path: str) -> str:
         """
         Read the content of a file from disk.
         Args:
             path: Path to the file to read
         Returns:
             File content as a string

--- a/src/mcipy/executors/http_executor.py
+++ b/src/mcipy/executors/http_executor.py
@@ -1,37 +1,32 @@
 """
 HTTP executor for MCI tools.
 This module provides the HTTPExecutor class that handles HTTP-based tool execution.
 It supports various HTTP methods, authentication types (API Key, Bearer, Basic, OAuth2),
 request body types (JSON, form, raw), and retry logic with exponential backoff.
 """
 import base64
-import json
 import time
 from collections.abc import Callable
 from typing import Any
 import requests
 from ..models import (
     ApiKeyAuth,
-    AudioContent,
     AuthConfig,
     BasicAuth,
     BearerAuth,
     ExecutionConfig,
     ExecutionResult,
-    ExecutionResultContent,
     HTTPBodyConfig,
     HTTPExecutionConfig,
-    ImageContent,
     OAuth2Auth,
     RetryConfig,
-    TextContent,
 )
 from .base import BaseExecutor
 class HTTPExecutor(BaseExecutor):
     """
     Executor for HTTP-based tools.
     Handles HTTP requests with various authentication methods, body types,
     and retry logic. Supports GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS methods.
     """
     def __init__(self):
         """Initialize the HTTP executor with a template engine."""
@@ -82,68 +77,40 @@
                 if body_data is not None:
                     if config.body.type == "json":
                         request_kwargs["json"] = body_data
                     elif config.body.type == "form":
                         request_kwargs["data"] = body_data
                     else:  # raw
                         request_kwargs["data"] = body_data
                     if content_type and "headers" in request_kwargs:
                         if "Content-Type" not in request_kwargs["headers"]:
                             request_kwargs["headers"]["Content-Type"] = content_type
-            start_time = time.time()
             if config.retries:
                 response = self._apply_retry_logic(
                     lambda: requests.request(**request_kwargs),
                     config.retries,
                 )
             else:
                 response = requests.request(**request_kwargs)
-            response_time_ms = int((time.time() - start_time) * 1000)
             response.raise_for_status()
-            metadata = {
-                "status_code": response.status_code,
-                "response_time_ms": response_time_ms,
-            }
-            content_objects = self._parse_response_content(response)
+            try:
+                content = response.json()
+            except ValueError:
+                content = response.text
             return ExecutionResult(
-                result=ExecutionResultContent(
-                    isError=False,
-                    content=content_objects,
-                    metadata=metadata,
-                )
+                isError=False,
+                content=content,
+                error=None,
+                metadata={"status_code": response.status_code},
             )
         except Exception as e:
             return self._format_error(e)
-    def _parse_response_content(
-        self, response: requests.Response
-    ) -> list[TextContent | ImageContent | AudioContent]:
-        """
-        Parse HTTP response into structured content objects.
-        Handles various content types including JSON, text, and images.
-        Returns appropriate content objects based on the response type.
-        Args:
-            response: HTTP response object
-        Returns:
-            List of content objects (TextContent or ImageContent)
-        """
-        content_type = response.headers.get("Content-Type", "").lower()
-        if content_type.startswith("image/"):
-            image_data = base64.b64encode(response.content).decode("utf-8")
-            return [ImageContent(data=image_data, mimeType=content_type.split(";")[0])]
-        if "application/json" in content_type:
-            try:
-                json_data = response.json()
-                text = json.dumps(json_data, indent=2)
-                return [TextContent(text=text)]
-            except ValueError:
-                pass
-        return [TextContent(text=response.text)]
     def _apply_authentication(self, auth: AuthConfig, request_kwargs: dict[str, Any]) -> None:
         """
         Apply authentication configuration to the request.
         Dispatches to the appropriate auth handler based on auth type.
         Args:
             auth: Authentication configuration
             request_kwargs: Request keyword arguments dictionary (modified in-place)
         """
         if isinstance(auth, ApiKeyAuth):
             self._handle_api_key_auth(auth, request_kwargs)

--- a/src/mcipy/executors/mcp_executor.py
+++ b//dev/null
@@ -1,125 +0,0 @@
-"""
-MCP executor for executing tools via Model Context Protocol servers.
-This module provides the MCPExecutor class for executing tools on MCP servers,
-handling both STDIO and HTTP transports, and managing connections and tool calls.
-"""
-import asyncio
-from typing import Any
-from ..models import (
-    ExecutionConfig,
-    ExecutionResult,
-    ExecutionResultContent,
-    MCPExecutionConfig,
-    TextContent,
-)
-from .base import BaseExecutor
-class MCPExecutorError(Exception):
-    """Exception raised for MCP executor errors."""
-    pass
-class MCPExecutor(BaseExecutor):
-    """
-    Executor for MCP (Model Context Protocol) tools.
-    Connects to MCP servers via STDIO or HTTP transports and executes tools
-    using the MCP protocol. Handles connection management, tool calls, and
-    result formatting.
-    """
-    def __init__(self, mcp_servers: dict[str, Any] | None = None):
-        """
-        Initialize the MCP executor with MCP server configurations.
-        Args:
-            mcp_servers: Dictionary of MCP server configurations from main schema
-        """
-        super().__init__()
-        self.mcp_servers = mcp_servers or {}
-    def execute(self, config: ExecutionConfig, context: dict[str, Any]) -> ExecutionResult:
-        """
-        Execute an MCP tool by connecting to the server and calling the tool.
-        Args:
-            config: MCP execution configuration with server and tool names
-            context: Execution context with properties and environment variables
-        Returns:
-            ExecutionResult with tool execution results
-        Raises:
-            MCPExecutorError: If server is not registered or execution fails
-        """
-        if not isinstance(config, MCPExecutionConfig):
-            return self._format_error(
-                MCPExecutorError(
-                    f"Invalid config type: expected MCPExecutionConfig, got {type(config)}"
-                )
-            )
-        if config.serverName not in self.mcp_servers:
-            return self._format_error(
-                MCPExecutorError(f"MCP server '{config.serverName}' not registered in main schema")
-            )
-        server_config = self.mcp_servers[config.serverName]
-        try:
-            result = asyncio.run(self._async_execute(config, context, server_config))
-            return result
-        except Exception as e:
-            return self._format_error(e)
-    async def _async_execute(
-        self, config: MCPExecutionConfig, context: dict[str, Any], server_config: Any
-    ) -> ExecutionResult:
-        """
-        Async implementation of MCP tool execution.
-        Connects to MCP server, calls the tool, and returns formatted results.
-        """
-        from mcp import ClientSession
-        from mcp.client.stdio import StdioServerParameters, stdio_client
-        from mcp.client.streamable_http import streamablehttp_client
-        from ..templating import TemplateEngine
-        template_engine = TemplateEngine()
-        from ..mcp_integration import MCPIntegration
-        templated_config = MCPIntegration._apply_templating_to_config(
-            server_config, context, template_engine
-        )
-        from ..models import StdioMCPServer
-        if isinstance(templated_config, StdioMCPServer):
-            import os
-            merged_env = os.environ.copy()
-            merged_env.update(templated_config.env)
-            params = StdioServerParameters(
-                command=templated_config.command, args=templated_config.args, env=merged_env
-            )
-            transport_ctx = stdio_client(params)
-        else:
-            transport_ctx = streamablehttp_client(
-                templated_config.url, headers=templated_config.headers or None
-            )
-        try:
-            async with transport_ctx as context_result:
-                read, write = context_result[0], context_result[1]
-                async with ClientSession(read, write) as session:
-                    await session.initialize()
-                    tool_args = context.get("props", {})
-                    result = await session.call_tool(config.toolName, arguments=tool_args)
-                    content_objects = []
-                    for content_item in result.content:
-                        if content_item.type == "text":
-                            content_objects.append(TextContent(text=content_item.text))
-                        elif content_item.type == "image":
-                            from ..models import ImageContent
-                            content_objects.append(
-                                ImageContent(data=content_item.data, mimeType=content_item.mimeType)
-                            )
-                        elif content_item.type == "audio":
-                            from ..models import AudioContent
-                            content_objects.append(
-                                AudioContent(data=content_item.data, mimeType=content_item.mimeType)
-                            )
-                        else:
-                            content_objects.append(TextContent(text=str(content_item)))
-                    jsonrpc_value = getattr(result, "jsonrpc", None)
-                    id_value = getattr(result, "id", None)
-                    return ExecutionResult(
-                        result=ExecutionResultContent(
-                            content=content_objects,
-                            isError=getattr(result, "isError", False),
-                            metadata={"mcp_server": config.serverName, "mcp_tool": config.toolName},
-                        ),
-                        jsonrpc=jsonrpc_value,
-                        id=id_value,
-                    )
-        except Exception as e:
-            raise MCPExecutorError(f"Failed to execute MCP tool '{config.toolName}': {e}") from e

--- a/src/mcipy/executors/text_executor.py
+++ b/src/mcipy/executors/text_executor.py
@@ -1,23 +1,17 @@
 """
 Text executor for MCI tools.
 This module provides the TextExecutor class that handles simple text-based tool execution.
 It applies templating to text strings and returns the result.
 """
 from typing import Any
-from ..models import (
-    ExecutionConfig,
-    ExecutionResult,
-    ExecutionResultContent,
-    TextContent,
-    TextExecutionConfig,
-)
+from ..models import ExecutionConfig, ExecutionResult, TextExecutionConfig
 from .base import BaseExecutor
 class TextExecutor(BaseExecutor):
     """
     Executor for text-based tools.
     Applies templating to text strings, supporting both basic placeholder
     substitution and advanced templating with @for, @foreach, and @if directives.
     """
     def __init__(self):
         """Initialize the text executor with a template engine."""
         super().__init__()
@@ -32,17 +26,16 @@
         Returns:
             ExecutionResult with templated text or error
         """
         if not isinstance(config, TextExecutionConfig):
             return self._format_error(
                 TypeError(f"Expected TextExecutionConfig, got {type(config).__name__}")
             )
         try:
             result = self.template_engine.render_advanced(config.text, context)
             return ExecutionResult(
-                result=ExecutionResultContent(
-                    isError=False,
-                    content=[TextContent(text=result)],
-                )
+                isError=False,
+                content=result,
+                error=None,
             )
         except Exception as e:
             return self._format_error(e)

--- a/src/mcipy/mcp_client.py
+++ b//dev/null
@@ -1,157 +0,0 @@
-"""
-LiteMcpClient - Lightweight MCP client integration using official mcp package.
-This module provides a minimal, robust client for connecting to MCP tool servers
-via STDIO (e.g., uvx/npx) and HTTP/SSE endpoints. It leverages the official `mcp`
-package to handle server communication and tool management.
-The LiteMcpClient allows seamless access to MCP tool servers for listing and
-calling tools with full support for both local STDIO-based servers and web-based
-HTTP/streamable endpoints.
-"""
-from __future__ import annotations
-import os
-from typing import Any, Literal
-from mcp import ClientSession, StdioServerParameters
-from mcp.client.stdio import stdio_client
-from mcp.client.streamable_http import streamablehttp_client
-from pydantic import BaseModel, Field, HttpUrl
-class StdioCfg(BaseModel):
-    """
-    Configuration for STDIO-based MCP servers.
-    Used for local servers started via command-line tools like uvx or npx.
-    Supports environment variable injection for credentials and configuration.
-    """
-    type: Literal["stdio"] = "stdio"
-    command: str = Field(..., description="Command to run (e.g., 'uvx', 'npx', or direct path)")
-    args: list[str] = Field(default_factory=list, description="Arguments to pass to the command")
-    env: dict[str, str] = Field(
-        default_factory=dict, description="Environment variables for the server process"
-    )
-class SseCfg(BaseModel):
-    """
-    Configuration for HTTP/SSE-based MCP servers.
-    Used for web-based MCP servers using HTTP with Server-Sent Events (SSE)
-    or modern Streamable HTTP transport. Supports custom headers for authentication.
-    """
-    type: Literal["http"] = "http"
-    url: HttpUrl = Field(..., description="Server URL (e.g., 'http://localhost:8000/mcp')")
-    headers: dict[str, str] = Field(
-        default_factory=dict, description="HTTP headers for authentication"
-    )
-ServerCfg = StdioCfg | SseCfg
-class ClientCfg(BaseModel):
-    """
-    Complete configuration for the LiteMcpClient.
-    Wraps the server configuration with optional request timeout settings.
-    """
-    server: ServerCfg = Field(..., description="Server connection configuration")
-    request_timeout: float | None = Field(default=60.0, description="Request timeout in seconds")
-class LiteMcpClient:
-    """
-    Lightweight MCP client for connecting to MCP tool servers.
-    Provides async context manager interface for managing connections to both
-    STDIO-based and HTTP/SSE-based MCP servers. Supports listing and calling
-    tools with full error handling.
-    Example:
-        ```python
-        import asyncio
-        from mcipy.mcp_client import LiteMcpClient, ClientCfg, StdioCfg
-        async def main():
-            cfg = ClientCfg(server=StdioCfg(
-                command="uvx",
-                args=["mcp-browser"]
-            ))
-            async with LiteMcpClient(cfg) as client:
-                tools = await client.list_tools()
-                print(f"Available tools: {tools}")
-                if tools:
-                    result = await client.call_tool(tools[0], param1="value")
-                    print(f"Result: {result}")
-        asyncio.run(main())
-        ```
-    """
-    def __init__(self, cfg: ClientCfg):
-        """
-        Initialize the LiteMcpClient with configuration.
-        Args:
-            cfg: Client configuration specifying server type and connection details
-        """
-        self.cfg = cfg
-        self._ctx = None
-        self._read = None
-        self._write = None
-        self.session: ClientSession | None = None
-    async def __aenter__(self) -> LiteMcpClient:
-        """
-        Async context manager entry - establish connection to MCP server.
-        Returns:
-            The initialized client instance with active session
-        """
-        try:
-            srv = self.cfg.server
-            if isinstance(srv, StdioCfg):
-                merged_env = os.environ.copy()
-                merged_env.update(srv.env)
-                params = StdioServerParameters(command=srv.command, args=srv.args, env=merged_env)
-                self._ctx = stdio_client(params)
-            else:
-                self._ctx = streamablehttp_client(str(srv.url), headers=srv.headers or None)
-            context_result = await self._ctx.__aenter__()
-            self._read, self._write = context_result[0], context_result[1]
-            self.session = ClientSession(self._read, self._write)
-            await self.session.__aenter__()
-            await self.session.initialize()
-            return self
-        except Exception:
-            await self.__aexit__(None, None, None)
-            raise
-    async def __aexit__(self, *exc) -> None:
-        """
-        Async context manager exit - clean up connection.
-        Args:
-            exc: Exception information if an error occurred
-        """
-        if self.session:
-            try:
-                await self.session.__aexit__(*exc)
-            except Exception:
-                pass
-            finally:
-                self.session = None
-        if self._ctx:
-            try:
-                await self._ctx.__aexit__(*exc)
-            except Exception:
-                pass
-            finally:
-                self._ctx = None
-    async def list_tools(self) -> list[str]:
-        """
-        List all available tools from the MCP server.
-        Returns:
-            List of tool names available on the server
-        Raises:
-            RuntimeError: If session is not initialized (client not used as context manager)
-        """
-        if not self.session:
-            raise RuntimeError(
-                "Session not initialized. Use LiteMcpClient as an async context manager."
-            )
-        resp = await self.session.list_tools()
-        return [t.name for t in resp.tools]
-    async def call_tool(self, name: str, **arguments: Any) -> Any:
-        """
-        Call a tool on the MCP server with the provided arguments.
-        Args:
-            name: Name of the tool to call
-            **arguments: Keyword arguments to pass to the tool
-        Returns:
-            The tool execution result from the server
-        Raises:
-            RuntimeError: If session is not initialized (client not used as context manager)
-        """
-        if not self.session:
-            raise RuntimeError(
-                "Session not initialized. Use LiteMcpClient as an async context manager."
-            )
-        result = await self.session.call_tool(name, arguments=arguments)
-        return result

--- a/src/mcipy/mcp_integration.py
+++ b//dev/null
@@ -1,205 +0,0 @@
-"""
-MCP Integration - Handles fetching and building toolsets from MCP servers.
-This module provides the MCPIntegration class for interacting with MCP servers,
-fetching their tool definitions, and building MCI-compatible toolset schemas.
-"""
-import asyncio
-from datetime import UTC, datetime, timedelta
-from typing import Any
-from .enums import ExecutionType
-from .models import (
-    Annotations,
-    HttpMCPServer,
-    MCPExecutionConfig,
-    Metadata,
-    StdioMCPServer,
-    Tool,
-    ToolsetSchema,
-)
-from .templating import TemplateEngine
-class MCPIntegrationError(Exception):
-    """Exception raised for MCP integration errors."""
-    pass
-class MCPIntegration:
-    """
-    Handles MCP server integration and toolset generation.
-    Provides methods to fetch tools from MCP servers (STDIO and HTTP),
-    build MCI-compatible toolsets, and manage toolset metadata.
-    """
-    @staticmethod
-    def _annotations_to_tags(mcp_annotations: Any) -> list[str]:
-        """
-        Convert MCP tool annotations to MCI tags.
-        Converts boolean annotation hints (readOnlyHint, destructiveHint, etc.) to
-        standardized tags. Also handles audience annotations if present.
-        Args:
-            mcp_annotations: MCP ToolAnnotations object
-        Returns:
-            List of tags derived from annotations
-        """
-        tags: list[str] = []
-        if not mcp_annotations:
-            return tags
-        if mcp_annotations.readOnlyHint:
-            tags.append("IsReadOnly")
-        if mcp_annotations.destructiveHint:
-            tags.append("IsDestructive")
-        if mcp_annotations.idempotentHint:
-            tags.append("IsIdempotent")
-        if mcp_annotations.openWorldHint:
-            tags.append("IsOpenWorld")
-        if hasattr(mcp_annotations, "audience") and mcp_annotations.audience:
-            for role in mcp_annotations.audience:
-                tags.append(f"audience_{role}")
-        return tags
-    @staticmethod
-    def fetch_and_build_toolset(
-        server_name: str,
-        server_config: StdioMCPServer | HttpMCPServer,
-        schema_version: str,
-        env_context: dict[str, Any],
-        template_engine: TemplateEngine,
-    ) -> ToolsetSchema:
-        """
-        Fetch tools from an MCP server and build a toolset schema.
-        Args:
-            server_name: Name of the MCP server
-            server_config: MCP server configuration (STDIO or HTTP)
-            schema_version: Schema version to use for the toolset
-            env_context: Environment context for templating
-            template_engine: Template engine for processing placeholders
-        Returns:
-            ToolsetSchema with tools from the MCP server and expiration date
-        Raises:
-            MCPIntegrationError: If MCP server connection or tool fetching fails
-        """
-        try:
-            return asyncio.run(
-                MCPIntegration._async_fetch_and_build_toolset(
-                    server_name, server_config, schema_version, env_context, template_engine
-                )
-            )
-        except Exception as e:
-            raise MCPIntegrationError(
-                f"Failed to fetch from MCP server '{server_name}': {e}"
-            ) from e
-    @staticmethod
-    async def _async_fetch_and_build_toolset(
-        server_name: str,
-        server_config: StdioMCPServer | HttpMCPServer,
-        schema_version: str,
-        env_context: dict[str, Any],
-        template_engine: TemplateEngine,
-    ) -> ToolsetSchema:
-        """
-        Async implementation of fetch_and_build_toolset.
-        Connects to MCP server, fetches tools, and builds toolset schema.
-        """
-        from mcp import ClientSession
-        from mcp.client.stdio import StdioServerParameters, stdio_client
-        from mcp.client.streamable_http import streamablehttp_client
-        templated_config = MCPIntegration._apply_templating_to_config(
-            server_config, env_context, template_engine
-        )
-        if isinstance(templated_config, StdioMCPServer):
-            import os
-            merged_env = os.environ.copy()
-            merged_env.update(templated_config.env)
-            params = StdioServerParameters(
-                command=templated_config.command, args=templated_config.args, env=merged_env
-            )
-            transport_ctx = stdio_client(params)
-        else:
-            transport_ctx = streamablehttp_client(
-                templated_config.url, headers=templated_config.headers or None
-            )
-        try:
-            async with transport_ctx as context_result:
-                read, write = context_result[0], context_result[1]
-                async with ClientSession(read, write) as session:
-                    await session.initialize()
-                    tools_response = await session.list_tools()
-                    mci_tools = []
-                    for mcp_tool in tools_response.tools:
-                        input_schema = None
-                        if mcp_tool.inputSchema:
-                            input_schema = mcp_tool.inputSchema
-                        annotations = Annotations()
-                        if mcp_tool.annotations:
-                            annotations.title = mcp_tool.annotations.title
-                            annotations.readOnlyHint = mcp_tool.annotations.readOnlyHint
-                            annotations.destructiveHint = mcp_tool.annotations.destructiveHint
-                            annotations.idempotentHint = mcp_tool.annotations.idempotentHint
-                            annotations.openWorldHint = mcp_tool.annotations.openWorldHint
-                            if hasattr(mcp_tool.annotations, "audience"):
-                                audience_value = getattr(mcp_tool.annotations, "audience", None)
-                                if audience_value:
-                                    annotations.audience = audience_value
-                        tags = MCPIntegration._annotations_to_tags(mcp_tool.annotations)
-                        mci_tool = Tool(
-                            name=mcp_tool.name,
-                            description=mcp_tool.description or "",
-                            annotations=annotations,
-                            inputSchema=input_schema,
-                            tags=tags,
-                            execution=MCPExecutionConfig(
-                                type=ExecutionType.MCP,
-                                serverName=server_name,
-                                toolName=mcp_tool.name,
-                            ),
-                        )
-                        mci_tools.append(mci_tool)
-                    exp_days = templated_config.config.expDays
-                    expires_date = (datetime.now(UTC) + timedelta(days=exp_days)).date()
-                    metadata = Metadata(name=server_name, description=f"MCP server: {server_name}")
-                    toolset = ToolsetSchema(
-                        schemaVersion=schema_version,
-                        metadata=metadata,
-                        tools=mci_tools,
-                        expiresAt=expires_date.isoformat(),  # YYYY-MM-DD format
-                    )
-                    return toolset
-        except Exception as e:
-            raise MCPIntegrationError(
-                f"Failed to connect to MCP server '{server_name}': {e}"
-            ) from e
-    @staticmethod
-    def _apply_templating_to_config(
-        server_config: StdioMCPServer | HttpMCPServer,
-        env_context: dict[str, Any],
-        template_engine: TemplateEngine,
-    ) -> StdioMCPServer | HttpMCPServer:
-        """
-        Apply templating to MCP server configuration.
-        Processes environment variable placeholders in server config fields.
-        Args:
-            server_config: MCP server configuration
-            env_context: Environment context for templating
-            template_engine: Template engine for processing placeholders
-        Returns:
-            Server configuration with templated values
-        """
-        if isinstance(server_config, StdioMCPServer):
-            templated_command = template_engine.render_basic(server_config.command, env_context)
-            templated_args = [
-                template_engine.render_basic(arg, env_context) for arg in server_config.args
-            ]
-            templated_env = {
-                key: template_engine.render_basic(value, env_context)
-                for key, value in server_config.env.items()
-            }
-            return StdioMCPServer(
-                command=templated_command,
-                args=templated_args,
-                env=templated_env,
-                config=server_config.config,
-            )
-        else:
-            templated_url = template_engine.render_basic(server_config.url, env_context)
-            templated_headers = {
-                key: template_engine.render_basic(value, env_context)
-                for key, value in server_config.headers.items()
-            }
-            return HttpMCPServer(
-                url=templated_url, headers=templated_headers, config=server_config.config
-            )

--- a/src/mcipy/models.py
+++ b/src/mcipy/models.py
@@ -1,22 +1,22 @@
 """
 Pydantic data models for MCI schema validation.
 This module defines the data structures used throughout the MCI adapter,
 providing strong typing, validation, and schema enforcement for:
 - Top-level MCI schema with metadata and tools
 - Tool definitions with input schemas and execution configurations
 - Execution configurations for different execution types (HTTP, CLI, File, Text)
 - Authentication configurations
 - Execution results
 """
-from typing import Any, Literal
-from pydantic import BaseModel, Field, field_validator
+from typing import Any
+from pydantic import BaseModel, Field
 from .enums import ExecutionType
 class Metadata(BaseModel):
     """
     Optional metadata for an MCI schema.
     Contains descriptive information about the tool collection,
     such as name, version, description, license, and authors.
     """
     name: str | None = None
     description: str | None = None
     version: str | None = None
@@ -102,186 +102,44 @@
     path: str
     enableTemplating: bool = Field(default=True)
 class TextExecutionConfig(ExecutionConfig):
     """
     Text execution configuration.
     Defines a simple text template that will be processed with
     placeholder substitution and returned as the result.
     """
     type: ExecutionType = Field(default=ExecutionType.TEXT)
     text: str
-class MCPExecutionConfig(ExecutionConfig):
-    """
-    MCP execution configuration.
-    Defines how to execute tools via Model Context Protocol servers.
-    The serverName must match a server registered in the main schema's
-    mcp_servers field, and toolName identifies the specific tool to call.
-    """
-    type: ExecutionType = Field(default=ExecutionType.MCP)
-    serverName: str
-    toolName: str
-class Annotations(BaseModel):
-    """
-    Optional annotations about tool behavior.
-    Contains hints and metadata about how the tool behaves, including
-    display information (title) and behavioral characteristics like
-    whether it modifies state, is destructive, idempotent, or interacts
-    with external entities. Also includes audience targeting for different roles.
-    """
-    title: str | None = None
-    readOnlyHint: bool | None = None
-    destructiveHint: bool | None = None
-    idempotentHint: bool | None = None
-    openWorldHint: bool | None = None
-    audience: list[Literal["user", "assistant"]] | None = None
 class Tool(BaseModel):
     """
     Individual tool definition.
-    Represents a single tool with its name, description, disabled state,
-    annotations, input schema (JSON Schema), and execution configuration.
+    Represents a single tool with its name, title, description,
+    input schema (JSON Schema), and execution configuration.
     The execution configuration determines how the tool is executed
     (HTTP, CLI, file, or text).
     """
     name: str
-    disabled: bool = Field(default=False)
-    annotations: Annotations | None = None
+    title: str | None = None
     description: str | None = None
     inputSchema: dict[str, Any] | None = None
-    execution: (
-        HTTPExecutionConfig
-        | CLIExecutionConfig
-        | FileExecutionConfig
-        | TextExecutionConfig
-        | MCPExecutionConfig
-    )
-    enableAnyPaths: bool = Field(default=False)
-    directoryAllowList: list[str] = Field(default_factory=list)
-    tags: list[str] = Field(default_factory=list)
-    toolset_source: str | None = Field(default=None, exclude=True)  # Internal field, not serialized
-class Toolset(BaseModel):
+    execution: HTTPExecutionConfig | CLIExecutionConfig | FileExecutionConfig | TextExecutionConfig
+class MCISchema(BaseModel):
     """
-    Toolset definition for loading tool collections from library files.
-    Represents a reference to a toolset file (or directory) in the libraryDir,
-    with optional filtering to control which tools from that toolset are loaded.
-    """
-    name: str
-    filter: str | None = None  # One of: "only", "except", "tags", "withoutTags"
-    filterValue: str | None = None  # Comma-separated list of tool names or tags
-class MCPServerConfig(BaseModel):
-    """
-    Configuration for filtering and expiration of MCP toolsets.
-    Applied when registering MCP servers to control which tools are loaded
-    and how long the cached toolset remains valid.
-    """
-    expDays: int = Field(default=30, ge=1)  # Days until cached toolset expires
-    filter: str | None = None  # One of: "only", "except", "tags", "withoutTags"
-    filterValue: str | None = None  # Comma-separated list of tool names or tags
-class StdioMCPServer(BaseModel):
-    """
-    STDIO-based MCP server configuration.
-    Used for local MCP servers started via command-line tools like npx or uvx.
-    Supports environment variable injection and templating.
-    """
-    command: str
-    args: list[str] = Field(default_factory=list)
-    env: dict[str, str] = Field(default_factory=dict)
-    config: MCPServerConfig = Field(default_factory=MCPServerConfig)
-class HttpMCPServer(BaseModel):
-    """
-    HTTP-based MCP server configuration.
-    Used for web-based MCP servers using HTTP with SSE or Streamable HTTP transport.
-    Supports custom headers for authentication and templating.
-    """
-    type: str = Field(default="http")
-    url: str
-    headers: dict[str, str] = Field(default_factory=dict)
-    config: MCPServerConfig = Field(default_factory=MCPServerConfig)
-MCPServer = StdioMCPServer | HttpMCPServer
-class ToolsetSchema(BaseModel):
-    """
-    Schema for individual toolset files.
-    Toolset files can only contain schemaVersion, optional metadata, required tools,
-    and optional expiresAt field for MCP toolset caching.
-    They cannot contain global configuration fields like toolsets, libraryDir, etc.
+    Top-level MCI schema.
+    Represents the complete MCI context file with schema version,
+    optional metadata, and a list of tool definitions.
+    This is the root model that validates the entire JSON schema.
     """
     schemaVersion: str
     metadata: Metadata | None = None
     tools: list[Tool]
-    expiresAt: str | None = None  # ISO 8601 timestamp for MCP toolset expiration
-class MCISchema(BaseModel):
-    """
-    Top-level MCI schema.
-    Represents the complete MCI context file with schema version,
-    optional metadata, tool definitions, toolsets, and MCP server configurations.
-    This is the root model that validates the entire JSON schema.
-    """
-    schemaVersion: str
-    metadata: Metadata | None = None
-    tools: list[Tool] | None = Field(default=None)
-    toolsets: list[Toolset | str] | None = Field(default=None)
-    mcp_servers: dict[str, MCPServer] | None = Field(default=None)
-    libraryDir: str = Field(default="./mci")
-    enableAnyPaths: bool = Field(default=False)
-    directoryAllowList: list[str] = Field(default_factory=list)
-    @field_validator("toolsets", mode="before")
-    @classmethod
-    def normalize_toolsets(cls, v: Any) -> Any:
-        """
-        Normalize toolsets to always be Toolset objects.
-        Converts string toolset names to Toolset objects with just the name field.
-        This allows users to specify simple toolset names without creating full objects
-        when no filtering is needed.
-        Examples:
-            "github" -> {"name": "github"}
-            {"name": "github", "filter": "tags", "filterValue": "read"} -> unchanged
-        """
-        if v is None:
-            return v
-        normalized = []
-        for item in v:
-            if isinstance(item, str):
-                normalized.append({"name": item})
-            else:
-                normalized.append(item)
-        return normalized
-class TextContent(BaseModel):
-    """
-    Text content object for execution results.
-    Represents textual content in MCP-compatible format.
-    """
-    type: str = Field(default="text")
-    text: str
-class ImageContent(BaseModel):
-    """
-    Image content object for execution results.
-    Represents base64-encoded image data in MCP-compatible format.
-    """
-    type: str = Field(default="image")
-    data: str
-    mimeType: str
-class AudioContent(BaseModel):
-    """
-    Audio content object for execution results.
-    Represents base64-encoded audio data in MCP-compatible format.
-    """
-    type: str = Field(default="audio")
-    data: str
-    mimeType: str
-ContentObject = TextContent | ImageContent | AudioContent
-class ExecutionResultContent(BaseModel):
-    """
-    Inner result object containing execution result data.
-    Contains the structured content array, error status, and optional metadata.
-    """
-    content: list[ContentObject]
-    isError: bool
-    metadata: dict[str, Any] | None = None
 class ExecutionResult(BaseModel):
     """
-    Execution result format with MCP compatibility.
-    Represents the result of executing a tool in MCP-compatible format
-    with optional JSON-RPC wrapper fields and structured content array.
-    The main result data is contained in the 'result' field.
+    Execution result format.
+    Represents the result of executing a tool, including whether
+    an error occurred and the content or error message.
+    This provides a consistent format for all execution results.
     """
-    result: ExecutionResultContent
-    jsonrpc: str | None = Field(default=None)
-    id: int | None = Field(default=None)
+    isError: bool
+    content: Any | None = None
+    error: str | None = None
+    metadata: dict[str, Any] | None = None

--- a/src/mcipy/parser.py
+++ b/src/mcipy/parser.py
@@ -1,153 +1,101 @@
 """
-Schema parser for MCI JSON and YAML files.
+Schema parser for MCI JSON files.
 This module provides the SchemaParser class for loading and validating
 MCI schema files. It handles:
-- Loading JSON and YAML files from disk
+- Loading JSON files from disk
 - Parsing dictionaries into MCISchema objects
 - Validating schema versions
 - Validating tool definitions
 - Building appropriate execution configurations based on type
-- Loading and filtering toolsets from library directories
-- Loading and caching MCP toolsets from MCP servers
 """
 import json
-import os
-from datetime import UTC, datetime
 from pathlib import Path
 from typing import Any
-import yaml
 from pydantic import ValidationError
 from .enums import ExecutionType
 from .models import (
     CLIExecutionConfig,
     ExecutionConfig,
     FileExecutionConfig,
     HTTPExecutionConfig,
     MCISchema,
-    MCPExecutionConfig,
     TextExecutionConfig,
-    Tool,
-    ToolsetSchema,
 )
 from .schema_config import SUPPORTED_SCHEMA_VERSIONS
 class SchemaParserError(Exception):
     """Exception raised for schema parsing errors."""
     pass
 class SchemaParser:
     """
     Parser for MCI schema files.
-    Loads and validates MCI JSON and YAML schema files, ensuring they conform to
+    Loads and validates MCI JSON schema files, ensuring they conform to
     the expected structure and contain valid tool definitions. Uses Pydantic
     for strong validation and provides helpful error messages for invalid schemas.
     """
     @staticmethod
-    def parse_file(file_path: str, env_vars: dict[str, Any] | None = None) -> MCISchema:
+    def parse_file(file_path: str) -> MCISchema:
         """
-        Load and validate an MCI schema file (JSON or YAML).
-        Reads a JSON or YAML file from disk, validates its structure and content,
-        and returns a parsed MCISchema object. The file type is determined by
-        the file extension (.json, .yaml, or .yml).
+        Load and validate an MCI JSON file.
+        Reads a JSON file from disk, validates its structure and content,
+        and returns a parsed MCISchema object.
         Args:
-            file_path: Path to the MCI schema file (.json, .yaml, or .yml)
-            env_vars: Optional environment variables for MCP server templating
+            file_path: Path to the MCI JSON file
         Returns:
             Validated MCISchema object
         Raises:
             SchemaParserError: If the file doesn't exist, can't be read,
-                             contains invalid JSON/YAML, has unsupported extension,
-                             or fails validation
+                             contains invalid JSON, or fails validation
         """
         path = Path(file_path)
         if not path.exists():
             raise SchemaParserError(f"Schema file not found: {file_path}")
         if not path.is_file():
             raise SchemaParserError(f"Path is not a file: {file_path}")
-        file_extension = path.suffix.lower()
         try:
             with path.open("r", encoding="utf-8") as f:
-                if file_extension == ".json":
-                    data = json.load(f)
-                elif file_extension in (".yaml", ".yml"):
-                    data = yaml.safe_load(f)
-                else:
-                    raise SchemaParserError(
-                        f"Unsupported file extension '{file_extension}'. "
-                        f"Supported extensions: .json, .yaml, .yml"
-                    )
+                data = json.load(f)
         except json.JSONDecodeError as e:
             raise SchemaParserError(f"Invalid JSON in file {file_path}: {e}") from e
-        except yaml.YAMLError as e:
-            raise SchemaParserError(f"Invalid YAML in file {file_path}: {e}") from e
         except OSError as e:
             raise SchemaParserError(f"Failed to read file {file_path}: {e}") from e
-        return SchemaParser.parse_dict(data, schema_file_path=file_path, env_vars=env_vars)
+        return SchemaParser.parse_dict(data)
     @staticmethod
-    def parse_dict(
-        data: dict[str, Any],
-        schema_file_path: str | None = None,
-        env_vars: dict[str, Any] | None = None,
-    ) -> MCISchema:
+    def parse_dict(data: dict[str, Any]) -> MCISchema:
         """
         Parse a dictionary into an MCISchema object.
         Validates the dictionary structure, schema version, and tool definitions,
-        then returns a validated MCISchema object. If toolsets are defined,
-        loads tools from toolset files and applies schema-level filtering.
+        then returns a validated MCISchema object.
         Args:
             data: Dictionary containing MCI schema data
-            schema_file_path: Path to the schema file (for resolving relative paths in toolsets)
-            env_vars: Optional environment variables for MCP server templating
         Returns:
             Validated MCISchema object
         Raises:
             SchemaParserError: If the dictionary structure is invalid,
                              schema version is unsupported, or validation fails
         """
         if not isinstance(data, dict):
             raise SchemaParserError(f"Expected dictionary, got {type(data).__name__}")
         if "schemaVersion" not in data:
             raise SchemaParserError("Missing required field 'schemaVersion'")
-        has_tools = "tools" in data and data["tools"] is not None
-        has_toolsets = "toolsets" in data and data["toolsets"] is not None
-        if not has_tools and not has_toolsets:
-            raise SchemaParserError("Either 'tools' or 'toolsets' field must be provided")
+        if "tools" not in data:
+            raise SchemaParserError("Missing required field 'tools'")
         SchemaParser._validate_schema_version(data["schemaVersion"])
-        if has_tools:
-            if not isinstance(data["tools"], list):
-                raise SchemaParserError(
-                    f"Field 'tools' must be a list, got {type(data['tools']).__name__}"
-                )
-            SchemaParser._validate_tools(data["tools"])
+        if not isinstance(data["tools"], list):
+            raise SchemaParserError(
+                f"Field 'tools' must be a list, got {type(data['tools']).__name__}"
+            )
+        SchemaParser._validate_tools(data["tools"])
         try:
             schema = MCISchema(**data)
         except ValidationError as e:
             raise SchemaParserError(f"Schema validation failed: {e}") from e
-        if schema.toolsets:
-            toolset_tools = SchemaParser._load_toolsets(
-                schema.toolsets, schema.libraryDir, schema_file_path
-            )
-            if schema.tools is None:
-                schema.tools = toolset_tools
-            else:
-                schema.tools.extend(toolset_tools)
-        if schema.mcp_servers:
-            mcp_tools = SchemaParser._load_mcp_servers(
-                schema.mcp_servers,
-                schema.libraryDir,
-                schema_file_path,
-                schema.schemaVersion,
-                env_vars,
-            )
-            if schema.tools is None:
-                schema.tools = mcp_tools
-            else:
-                schema.tools.extend(mcp_tools)
         return schema
     @staticmethod
     def _validate_schema_version(version: str) -> None:
         """
         Validate schema version compatibility.
         Ensures the schema version is supported by this parser implementation.
         Args:
             version: Schema version string
         Raises:
             SchemaParserError: If the version is not supported
@@ -191,306 +139,43 @@
                 SchemaParser._build_execution_config(execution)
             except SchemaParserError as e:
                 raise SchemaParserError(
                     f"Tool '{tool['name']}' has invalid execution config: {e}"
                 ) from e
     @staticmethod
     def _build_execution_config(execution: dict[str, Any]) -> ExecutionConfig:
         """
         Build the appropriate execution config based on type.
         Determines the execution type and creates the corresponding
-        ExecutionConfig subclass (HTTP, CLI, File, Text, or MCP).
+        ExecutionConfig subclass (HTTP, CLI, File, or Text).
         Args:
             execution: Dictionary containing execution configuration
         Returns:
             Appropriate ExecutionConfig subclass instance
         Raises:
             SchemaParserError: If the execution type is missing, invalid,
                              or the configuration is invalid for that type
         """
         if "type" not in execution:
             raise SchemaParserError("Missing required field 'type' in execution config")
         exec_type = execution["type"]
         if not isinstance(exec_type, str):
             raise SchemaParserError(
                 f"Execution type must be a string, got {type(exec_type).__name__}"
             )
         type_map = {
             ExecutionType.HTTP.value: HTTPExecutionConfig,
             ExecutionType.CLI.value: CLIExecutionConfig,
             ExecutionType.FILE.value: FileExecutionConfig,
             ExecutionType.TEXT.value: TextExecutionConfig,
-            ExecutionType.MCP.value: MCPExecutionConfig,
         }
         if exec_type not in type_map:
             valid_types = ", ".join(type_map.keys())
             raise SchemaParserError(
                 f"Invalid execution type '{exec_type}'. Valid types: {valid_types}"
             )
         config_class = type_map[exec_type]
         try:
             config = config_class(**execution)
         except ValidationError as e:
             raise SchemaParserError(f"Invalid {exec_type} execution config: {e}") from e
         return config
-    @staticmethod
-    def _load_toolsets(
-        toolsets: list[Any], library_dir: str, schema_file_path: str | None
-    ) -> list[Tool]:
-        """
-        Load tools from toolset definitions.
-        Discovers toolset files in the library directory, loads them,
-        and applies schema-level filtering based on the toolset configuration.
-        Args:
-            toolsets: List of toolset definitions from main schema
-            library_dir: Directory to search for toolset files (relative to schema file)
-            schema_file_path: Path to the main schema file (for resolving relative paths)
-        Returns:
-            List of Tool objects loaded from all toolsets with filters applied
-        Raises:
-            SchemaParserError: If toolset files cannot be found or loaded
-        """
-        all_tools: list[Tool] = []
-        if schema_file_path:
-            base_dir = Path(schema_file_path).parent
-            lib_path = base_dir / library_dir
-        else:
-            lib_path = Path(library_dir)
-        if not lib_path.exists():
-            raise SchemaParserError(f"Library directory not found: {lib_path}")
-        if not lib_path.is_dir():
-            raise SchemaParserError(f"Library path is not a directory: {lib_path}")
-        for toolset in toolsets:
-            toolset_schema = SchemaParser._load_toolset_file(toolset.name, lib_path)
-            filtered_tools = SchemaParser._apply_toolset_filter(
-                toolset_schema.tools, toolset.filter, toolset.filterValue
-            )
-            for tool in filtered_tools:
-                tool.toolset_source = toolset.name
-            all_tools.extend(filtered_tools)
-        return all_tools
-    @staticmethod
-    def _load_toolset_file(name: str, lib_path: Path) -> ToolsetSchema:
-        """
-        Load a toolset file from the library directory.
-        Tries to find the toolset as:
-        1. A directory containing .mci.json files
-        2. A file with exact name (e.g., github_prs.mci.json)
-        3. A file with .mci.json extension added (e.g., github_prs -> github_prs.mci.json)
-        Args:
-            name: Name of the toolset (directory, file, or bare prefix)
-            lib_path: Path to the library directory
-        Returns:
-            Parsed ToolsetSchema
-        Raises:
-            SchemaParserError: If toolset file cannot be found or loaded
-        """
-        dir_path = lib_path / name
-        if dir_path.is_dir():
-            toolset_files = list(dir_path.glob("*.mci.json"))
-            if not toolset_files:
-                raise SchemaParserError(
-                    f"No .mci.json files found in toolset directory: {dir_path}"
-                )
-            all_tools: list[Tool] = []
-            schema_version = None
-            for toolset_file in toolset_files:
-                schema = SchemaParser._parse_toolset_file(toolset_file)
-                all_tools.extend(schema.tools)
-                if schema_version is None:
-                    schema_version = schema.schemaVersion
-                elif schema.schemaVersion != schema_version:
-                    raise SchemaParserError(
-                        f"Schema version mismatch in toolset directory '{dir_path}': "
-                        f"File '{toolset_file.name}' has schemaVersion '{schema.schemaVersion}', "
-                        f"but expected '{schema_version}' (from first file in directory). "
-                        f"All files in a toolset directory must use the same schema version."
-                    )
-            return ToolsetSchema(
-                schemaVersion=schema_version or "1.0",
-                metadata=None,  # Don't merge metadata from toolset files
-                tools=all_tools,
-            )
-        file_path = lib_path / name
-        if file_path.is_file():
-            return SchemaParser._parse_toolset_file(file_path)
-        file_with_ext = lib_path / f"{name}.mci.json"
-        if file_with_ext.is_file():
-            return SchemaParser._parse_toolset_file(file_with_ext)
-        file_with_yaml = lib_path / f"{name}.mci.yaml"
-        if file_with_yaml.is_file():
-            return SchemaParser._parse_toolset_file(file_with_yaml)
-        file_with_yml = lib_path / f"{name}.mci.yml"
-        if file_with_yml.is_file():
-            return SchemaParser._parse_toolset_file(file_with_yml)
-        raise SchemaParserError(
-            f"Toolset not found: {name}. Looked for directory, file, or file with .mci.json/.mci.yaml/.mci.yml extension in {lib_path}"
-        )
-    @staticmethod
-    def _parse_toolset_file(file_path: Path) -> ToolsetSchema:
-        """
-        Parse a toolset file.
-        Args:
-            file_path: Path to the toolset file
-        Returns:
-            Parsed ToolsetSchema
-        Raises:
-            SchemaParserError: If file cannot be parsed or is invalid
-        """
-        file_extension = file_path.suffix.lower()
-        try:
-            with file_path.open("r", encoding="utf-8") as f:
-                if file_extension == ".json":
-                    data = json.load(f)
-                elif file_extension in (".yaml", ".yml"):
-                    data = yaml.safe_load(f)
-                else:
-                    raise SchemaParserError(
-                        f"Unsupported toolset file extension '{file_extension}'. "
-                        f"Supported extensions: .json, .yaml, .yml"
-                    )
-        except json.JSONDecodeError as e:
-            raise SchemaParserError(f"Invalid JSON in toolset file {file_path}: {e}") from e
-        except yaml.YAMLError as e:
-            raise SchemaParserError(f"Invalid YAML in toolset file {file_path}: {e}") from e
-        except OSError as e:
-            raise SchemaParserError(f"Failed to read toolset file {file_path}: {e}") from e
-        if not isinstance(data, dict):
-            raise SchemaParserError(
-                f"Toolset file {file_path} must contain a JSON/YAML object, got {type(data).__name__}"
-            )
-        if "schemaVersion" not in data:
-            raise SchemaParserError(
-                f"Toolset file {file_path} missing required field 'schemaVersion'"
-            )
-        if "tools" not in data:
-            raise SchemaParserError(f"Toolset file {file_path} missing required field 'tools'")
-        SchemaParser._validate_schema_version(data["schemaVersion"])
-        if not isinstance(data["tools"], list):
-            raise SchemaParserError(
-                f"Toolset file {file_path} field 'tools' must be a list, got {type(data['tools']).__name__}"
-            )
-        SchemaParser._validate_tools(data["tools"])
-        try:
-            schema = ToolsetSchema(**data)
-        except ValidationError as e:
-            raise SchemaParserError(f"Toolset file {file_path} validation failed: {e}") from e
-        return schema
-    @staticmethod
-    def _apply_toolset_filter(
-        tools: list[Tool], filter_type: str | None, filter_value: str | None
-    ) -> list[Tool]:
-        """
-        Apply schema-level filtering to toolset tools.
-        Args:
-            tools: List of tools from the toolset
-            filter_type: Type of filter ("only", "except", "tags", "withoutTags", or None)
-            filter_value: Comma-separated list of tool names or tags
-        Returns:
-            Filtered list of Tool objects
-        Raises:
-            SchemaParserError: If filter configuration is invalid
-        """
-        if filter_type is None:
-            return tools
-        if filter_value is None:
-            raise SchemaParserError(
-                f"Filter type '{filter_type}' specified but filterValue is missing"
-            )
-        filter_items = [item.strip() for item in filter_value.split(",") if item.strip()]
-        if not filter_items:
-            raise SchemaParserError(f"Filter value cannot be empty for filter type '{filter_type}'")
-        if filter_type == "only":
-            filter_set = set(filter_items)
-            return [tool for tool in tools if tool.name in filter_set]
-        elif filter_type == "except":
-            filter_set = set(filter_items)
-            return [tool for tool in tools if tool.name not in filter_set]
-        elif filter_type == "tags":
-            filter_set = set(filter_items)
-            return [tool for tool in tools if any(tag in filter_set for tag in tool.tags)]
-        elif filter_type == "withoutTags":
-            filter_set = set(filter_items)
-            return [tool for tool in tools if not any(tag in filter_set for tag in tool.tags)]
-        else:
-            raise SchemaParserError(
-                f"Invalid filter type '{filter_type}'. Valid types: only, except, tags, withoutTags"
-            )
-    @staticmethod
-    def _load_mcp_servers(
-        mcp_servers: dict[str, Any],
-        library_dir: str,
-        schema_file_path: str | None,
-        schema_version: str,
-        env_vars: dict[str, Any] | None = None,
-    ) -> list[Tool]:
-        """
-        Load tools from MCP server definitions.
-        Checks for cached MCP toolsets in libraryDir/mcp/, fetches tools from
-        MCP servers if cache doesn't exist or is expired, and applies filtering.
-        Args:
-            mcp_servers: Dictionary of MCP server configurations from main schema
-            library_dir: Directory to search for cached toolset files (relative to schema file)
-            schema_file_path: Path to the main schema file (for resolving relative paths)
-            schema_version: Schema version from main file (to use for generated toolsets)
-            env_vars: Optional environment variables for MCP server templating
-        Returns:
-            List of Tool objects loaded from all MCP servers with filters applied
-        Raises:
-            SchemaParserError: If MCP toolset files cannot be loaded or MCP servers are unreachable
-        """
-        from .mcp_integration import MCPIntegration
-        from .templating import TemplateEngine
-        all_tools: list[Tool] = []
-        if schema_file_path:
-            base_dir = Path(schema_file_path).parent
-            lib_path = base_dir / library_dir
-        else:
-            lib_path = Path(library_dir)
-        mcp_dir = lib_path / "mcp"
-        mcp_dir.mkdir(parents=True, exist_ok=True)
-        for server_name, server_config in mcp_servers.items():
-            toolset_path = mcp_dir / f"{server_name}.mci.json"
-            should_fetch = True
-            if toolset_path.exists():
-                try:
-                    toolset_schema = SchemaParser._parse_toolset_file(toolset_path)
-                    if toolset_schema.expiresAt:
-                        try:
-                            expires_date = datetime.fromisoformat(toolset_schema.expiresAt).date()
-                            today = datetime.now(UTC).date()
-                            if expires_date > today:
-                                should_fetch = False
-                                filtered_tools = SchemaParser._apply_toolset_filter(
-                                    toolset_schema.tools,
-                                    server_config.config.filter,
-                                    server_config.config.filterValue,
-                                )
-                                for tool in filtered_tools:
-                                    tool.toolset_source = server_name
-                                all_tools.extend(filtered_tools)
-                        except (ValueError, AttributeError):
-                            should_fetch = True
-                except Exception:
-                    should_fetch = True
-            if should_fetch:
-                template_engine = TemplateEngine()
-                env_context = {"env": {**dict(os.environ), **(env_vars or {})}}
-                try:
-                    toolset_schema = MCPIntegration.fetch_and_build_toolset(
-                        server_name, server_config, schema_version, env_context, template_engine
-                    )
-                    with toolset_path.open("w", encoding="utf-8") as f:
-                        json.dump(toolset_schema.model_dump(exclude_none=True), f, indent=2)
-                    filtered_tools = SchemaParser._apply_toolset_filter(
-                        toolset_schema.tools,
-                        server_config.config.filter,
-                        server_config.config.filterValue,
-                    )
-                    for tool in filtered_tools:
-                        tool.toolset_source = server_name
-                    all_tools.extend(filtered_tools)
-                except Exception as e:
-                    raise SchemaParserError(
-                        f"Failed to fetch tools from MCP server '{server_name}': {e}"
-                    ) from e
-        return all_tools

--- a/src/mcipy/path_validator.py
+++ b//dev/null
@@ -1,102 +0,0 @@
-"""
-Path validation utilities for MCI tool execution.
-This module provides security functions to validate file paths used in tool execution.
-It ensures that file/CLI paths are within allowed directories unless explicitly overridden
-via enableAnyPaths configuration.
-"""
-from pathlib import Path
-class PathValidationError(Exception):
-    """Exception raised when path validation fails."""
-    pass
-class PathValidator:
-    """
-    Validates file paths against security restrictions.
-    Ensures paths are within the context directory or allowed directories
-    unless enableAnyPaths is enabled.
-    """
-    def __init__(
-        self,
-        context_dir: Path,
-        enable_any_paths: bool = False,
-        directory_allow_list: list[str] | None = None,
-    ):
-        """
-        Initialize the path validator.
-        Args:
-            context_dir: Directory containing the MCI schema file (base directory)
-            enable_any_paths: If True, skip all path validation
-            directory_allow_list: Additional directories to allow (relative or absolute paths)
-        """
-        self.context_dir = context_dir.resolve()
-        self.enable_any_paths = enable_any_paths
-        self.allowed_dirs = self._build_allowed_dirs(directory_allow_list or [])
-    def _build_allowed_dirs(self, directory_allow_list: list[str]) -> list[Path]:
-        """
-        Build list of allowed directories (absolute paths).
-        Converts relative and absolute paths in the allow list to absolute paths.
-        Relative paths are resolved relative to the context directory.
-        Args:
-            directory_allow_list: List of directory paths (relative or absolute)
-        Returns:
-            List of resolved absolute Path objects
-        """
-        allowed = [self.context_dir]  # Context directory is always allowed
-        for dir_path in directory_allow_list:
-            path = Path(dir_path)
-            if not path.is_absolute():
-                path = (self.context_dir / path).resolve()
-            else:
-                path = path.resolve()
-            allowed.append(path)
-        return allowed
-    def validate_path(self, path: str) -> None:
-        """
-        Validate that a file path is allowed.
-        Checks if the path is within the context directory or an allowed directory.
-        Raises PathValidationError if the path is not allowed.
-        Args:
-            path: File or directory path to validate
-        Raises:
-            PathValidationError: If path is outside allowed directories and enableAnyPaths is False
-        """
-        if self.enable_any_paths:
-            return
-        path_obj = Path(path)
-        if not path_obj.is_absolute():
-            file_path = (self.context_dir / path_obj).resolve()
-        else:
-            file_path = path_obj.resolve()
-        for allowed_dir in self.allowed_dirs:
-            try:
-                file_path.relative_to(allowed_dir)
-                return
-            except ValueError:
-                continue
-        raise PathValidationError(
-            f"File path access outside context directory and allow-list is not allowed "
-            f"unless enableAnyPaths is true. Path: {path}"
-        )
-    @staticmethod
-    def merge_settings(
-        schema_enable_any_paths: bool,
-        schema_directory_allow_list: list[str],
-        tool_enable_any_paths: bool,
-        tool_directory_allow_list: list[str],
-    ) -> tuple[bool, list[str]]:
-        """
-        Merge schema-level and tool-level settings with proper precedence.
-        Tool-level settings take precedence over schema-level settings.
-        If tool has explicit settings, use those; otherwise use schema settings.
-        Args:
-            schema_enable_any_paths: Schema-level enableAnyPaths
-            schema_directory_allow_list: Schema-level directoryAllowList
-            tool_enable_any_paths: Tool-level enableAnyPaths
-            tool_directory_allow_list: Tool-level directoryAllowList
-        Returns:
-            Tuple of (effective_enable_any_paths, effective_directory_allow_list)
-        """
-        effective_enable_any_paths = tool_enable_any_paths or schema_enable_any_paths
-        effective_directory_allow_list = (
-            tool_directory_allow_list if tool_directory_allow_list else schema_directory_allow_list
-        )
-        return effective_enable_any_paths, effective_directory_allow_list

--- a/src/mcipy/templating.py
+++ b/src/mcipy/templating.py
@@ -17,93 +17,56 @@
     features like loops and conditional blocks. The engine supports:
     - Basic placeholders: {{props.propertyName}}, {{env.VAR_NAME}}
     - For loops: @for(i in range(0, 5)) ... @endfor
     - Foreach loops: @foreach(item in items) ... @endforeach
     - Control blocks: @if(condition) ... @elseif(condition) ... @else ... @endif
     """
     def render_basic(self, template: str, context: dict[str, Any]) -> str:
         """
         Perform basic placeholder substitution.
         Replaces placeholders like {{props.propertyName}} and {{env.VAR_NAME}}
-        with their values from the context. Supports fallback syntax with | operator:
-        - {{env.VAR | 'default'}} - Use string literal as fallback
-        - {{env.VAR | env.OTHER}} - Use another variable as fallback
-        - {{env.VAR | env.OTHER | '/tmp'}} - Chain multiple fallbacks
+        with their values from the context.
         Args:
             template: The template string containing placeholders
             context: Dictionary with 'props', 'env', and 'input' keys
         Returns:
             The template with all placeholders replaced
         Raises:
-            TemplateError: If a placeholder cannot be resolved and no fallback is provided
+            TemplateError: If a placeholder cannot be resolved
         """
         pattern = r"\{\{([^}]+)\}\}"
         def replace_placeholder(match: re.Match[str]) -> str:
-            full_path = match.group(1).strip()
+            path = match.group(1).strip()
             try:
-                value = self._resolve_placeholder_with_fallback(full_path, context)
+                value = self._resolve_placeholder(path, context)
                 return str(value)
             except Exception as e:
-                placeholder_str = "{{" + full_path + "}}"
-                raise TemplateError(
-                    f"Failed to resolve placeholder '{placeholder_str}': {e}"
-                ) from e
+                raise TemplateError(f"Failed to resolve placeholder '{{{{{path}}}}}: {e}") from e
         return re.sub(pattern, replace_placeholder, template)
     def render_advanced(self, template: str, context: dict[str, Any]) -> str:
         """
         Perform advanced templating with loops and control blocks.
         Processes @for, @foreach, and @if/@elseif/@else/@endif blocks
         in addition to basic placeholder substitution.
         Args:
             template: The template string with advanced directives
             context: Dictionary with 'props', 'env', and 'input' keys
         Returns:
             The fully processed template
         Raises:
             TemplateError: If template processing fails
         """
         result = self._parse_for_loop(template, context)
         result = self._parse_foreach_loop(result, context)
         result = self._parse_control_blocks(result, context)
         result = self.render_basic(result, context)
         return result
-    def _resolve_placeholder_with_fallback(self, full_path: str, context: dict[str, Any]) -> Any:
-        """
-        Resolve a placeholder with optional fallback values using | operator.
-        Supports:
-        - env.VAR - Simple variable
-        - env.VAR | 'default' - Fallback to string literal (single quotes or backticks)
-        - env.VAR | env.OTHER - Fallback to another variable
-        - env.VAR | env.OTHER | '/tmp' - Chain multiple fallbacks
-        Args:
-            full_path: Path with optional fallbacks (e.g., "env.VAR | 'default' | env.OTHER")
-            context: Context dictionary
-        Returns:
-            The resolved value or fallback
-        Raises:
-            TemplateError: If no path can be resolved and no valid fallback provided
-        """
-        alternatives = [alt.strip() for alt in full_path.split("|")]
-        errors = []
-        for alt in alternatives:
-            if (alt.startswith("'") and alt.endswith("'")) or (
-                alt.startswith("`") and alt.endswith("`")
-            ):
-                return alt[1:-1]
-            try:
-                return self._resolve_placeholder(alt, context)
-            except TemplateError as e:
-                errors.append(f"{alt}: {e}")
-                continue
-        raise TemplateError(
-            f"Could not resolve any alternative. Tried: {', '.join(alternatives)}. Errors: {'; '.join(errors)}"
-        )
     def _resolve_placeholder(self, path: str, context: dict[str, Any]) -> Any:
         """
         Resolve a dot-notation path in the context.
         Supports paths like 'props.location', 'env.API_KEY', 'input.user.name'
         Args:
             path: Dot-notation path to resolve
             context: Context dictionary
         Returns:
             The value at the specified path
         Raises:
@@ -113,23 +76,21 @@
         current = context
         for i, part in enumerate(parts):
             if not isinstance(current, dict):
                 raise TemplateError(
                     f"Cannot access '{part}' on non-dict value at '{'.'.join(parts[:i])}'"
                 )
             if part not in current:
                 raise TemplateError(f"Path '{path}' not found in context (missing '{part}')")
             current = current[part]
         return current
-    def _replace_placeholders_with_whitespace_support(
-        self, content: str, replacements: dict[str, str]
-    ) -> str:
+    def _replace_placeholders_with_whitespace_support(self, content: str, replacements: dict[str, str]) -> str:
         """
         Replace placeholders in content, supporting optional whitespace around variable names.
         Args:
             content: The content containing placeholders
             replacements: Dictionary mapping variable paths to replacement values
         Returns:
             Content with placeholders replaced
         """
         result = content
         for var_path, replacement in replacements.items():
@@ -151,23 +112,21 @@
             var_name = match.group(1)
             start = int(match.group(2))
             end = int(match.group(3))
             body = match.group(4)
             result = []
             for i in range(start, end):
                 loop_context = context.copy()
                 loop_context[var_name] = i
                 processed_body = body
                 replacements = {var_name: str(i)}
-                processed_body = self._replace_placeholders_with_whitespace_support(
-                    processed_body, replacements
-                )
+                processed_body = self._replace_placeholders_with_whitespace_support(processed_body, replacements)
                 result.append(processed_body)
             return "".join(result)
         return re.sub(pattern, replace_for_loop, content, flags=re.DOTALL)
     def _parse_foreach_loop(self, content: str, context: dict[str, Any]) -> str:
         """
         Parse and process @foreach loops.
         Supports syntax: @foreach(item in items)...@endforeach
         where 'items' is a path in the context (e.g., 'props.myArray')
         Args:
             content: Template content containing @foreach loops
@@ -191,38 +150,35 @@
             result = []
             if isinstance(items, list):
                 for item in items:
                     loop_context = context.copy()
                     loop_context[var_name] = item
                     processed_body = body
                     if isinstance(item, dict):
                         replacements = {}
                         for key, value in item.items():
                             replacements[f"{var_name}.{key}"] = str(value)
-                        processed_body = self._replace_placeholders_with_whitespace_support(
-                            processed_body, replacements
-                        )
+                        processed_body = self._replace_placeholders_with_whitespace_support(processed_body, replacements)
                     else:
                         replacements = {var_name: str(item)}
-                        processed_body = self._replace_placeholders_with_whitespace_support(
-                            processed_body, replacements
-                        )
+                        processed_body = self._replace_placeholders_with_whitespace_support(processed_body, replacements)
                     result.append(processed_body)
             else:  # dict
                 for key, value in items.items():
                     loop_context = context.copy()
                     loop_context[var_name] = value
                     processed_body = body
-                    replacements = {var_name: str(value), f"{var_name}.key": str(key)}
-                    processed_body = self._replace_placeholders_with_whitespace_support(
-                        processed_body, replacements
-                    )
+                    replacements = {
+                        var_name: str(value),
+                        f"{var_name}.key": str(key)
+                    }
+                    processed_body = self._replace_placeholders_with_whitespace_support(processed_body, replacements)
                     result.append(processed_body)
             return "".join(result)
         return re.sub(pattern, replace_foreach_loop, content, flags=re.DOTALL)
     def _parse_control_blocks(self, content: str, context: dict[str, Any]) -> str:
         """
         Parse and process @if/@elseif/@else/@endif control blocks.
         Supports syntax:
         @if(condition)...@elseif(condition)...@else...@endif
         Conditions can be:
         - path.to.value (truthy check)

--- a/src/mcipy/tool_manager.py
+++ b/src/mcipy/tool_manager.py
@@ -1,139 +1,72 @@
 """
 Tool manager for MCI tools.
 This module provides the ToolManager class that manages tool definitions
 from an MCISchema, including retrieval, filtering, and execution.
 """
-from pathlib import Path
 from typing import Any
 from .executors import ExecutorFactory
 from .models import ExecutionResult, MCISchema, Tool
 class ToolManagerError(Exception):
     """Exception raised for tool manager errors."""
     pass
 class ToolManager:
     """
     Manager for MCI tool definitions.
     Provides functionality to retrieve, filter, and execute tools from an
     MCISchema. Handles input validation and dispatches execution to the
     appropriate executor based on tool configuration.
     """
-    def __init__(self, schema: MCISchema, schema_file_path: str | None = None):
+    def __init__(self, schema: MCISchema):
         """
         Initialize the ToolManager with an MCISchema.
         Args:
             schema: MCISchema containing tool definitions
-            schema_file_path: Path to the schema file (for path validation context)
         """
         self.schema = schema
-        tools_list = schema.tools if schema.tools is not None else []
-        self._tool_map: dict[str, Tool] = {
-            tool.name: tool for tool in tools_list if not tool.disabled
-        }
-        self._schema_file_path = schema_file_path
+        self._tool_map: dict[str, Tool] = {tool.name: tool for tool in schema.tools}
     def get_tool(self, name: str) -> Tool | None:
         """
-        Retrieve a tool by name (case-sensitive), excluding disabled tools.
+        Retrieve a tool by name (case-sensitive).
         Args:
             name: Name of the tool to retrieve
         Returns:
-            Tool object if found and enabled, None otherwise
+            Tool object if found, None otherwise
         """
         return self._tool_map.get(name)
     def list_tools(self) -> list[Tool]:
         """
-        List all available tools (excluding disabled tools).
+        List all available tools.
         Returns:
-            List of all enabled Tool objects in the schema
+            List of all Tool objects in the schema
         """
-        tools_list = self.schema.tools if self.schema.tools is not None else []
-        return [tool for tool in tools_list if not tool.disabled]
+        return self.schema.tools
     def filter_tools(
         self, only: list[str] | None = None, without: list[str] | None = None
     ) -> list[Tool]:
         """
-        Filter tools by inclusion/exclusion lists (excluding disabled tools).
+        Filter tools by inclusion/exclusion lists.
         If both 'only' and 'without' are provided, 'only' takes precedence
         (i.e., only tools in the 'only' list but not in 'without' are returned).
-        Disabled tools are always excluded regardless of filters.
         Args:
-            only: List of tool names to include (if None, all enabled tools are considered)
+            only: List of tool names to include (if None, all tools are considered)
             without: List of tool names to exclude (if None, no tools are excluded)
         Returns:
             Filtered list of Tool objects
         """
-        tools_list = self.schema.tools if self.schema.tools is not None else []
-        tools = [tool for tool in tools_list if not tool.disabled]
+        tools = self.schema.tools
         if only is not None:
             only_set = set(only)
             tools = [tool for tool in tools if tool.name in only_set]
         if without is not None:
             without_set = set(without)
             tools = [tool for tool in tools if tool.name not in without_set]
-        return tools
-    def tags(self, tags: list[str]) -> list[Tool]:
-        """
-        Filter tools to include only those with at least one matching tag (excluding disabled tools).
-        Returns tools that have at least one tag matching any tag in the provided list.
-        Uses OR logic: a tool is included if it has any of the specified tags.
-        Tags are matched case-sensitively and exactly as provided.
-        Args:
-            tags: List of tags to filter by
-        Returns:
-            Filtered list of Tool objects that have at least one matching tag
-        """
-        tools_list = self.schema.tools if self.schema.tools is not None else []
-        tools = [tool for tool in tools_list if not tool.disabled]
-        if not tags:
-            return []
-        tags_set = set(tags)
-        tools = [tool for tool in tools if any(tag in tags_set for tag in tool.tags)]
-        return tools
-    def withoutTags(self, tags: list[str]) -> list[Tool]:
-        """
-        Filter tools to exclude those with any matching tag (excluding disabled tools).
-        Returns tools that do NOT have any tags matching the provided list.
-        Uses OR logic for exclusion: a tool is excluded if it has any of the specified tags.
-        Tags are matched case-sensitively and exactly as provided.
-        Args:
-            tags: List of tags to exclude
-        Returns:
-            Filtered list of Tool objects that do not have any of the specified tags
-        """
-        tools_list = self.schema.tools if self.schema.tools is not None else []
-        tools = [tool for tool in tools_list if not tool.disabled]
-        if not tags:
-            return tools
-        tags_set = set(tags)
-        tools = [tool for tool in tools if not any(tag in tags_set for tag in tool.tags)]
-        return tools
-    def toolsets(self, toolset_names: list[str]) -> list[Tool]:
-        """
-        Filter tools to include only those from specified toolsets (excluding disabled tools).
-        Returns tools that were loaded from any of the specified toolsets.
-        Uses OR logic: a tool is included if it came from any of the specified toolsets.
-        Only tools that were registered by their toolset's schema-level filter are included.
-        Args:
-            toolset_names: List of toolset names to filter by
-        Returns:
-            Filtered list of Tool objects from the specified toolsets
-        """
-        tools_list = self.schema.tools if self.schema.tools is not None else []
-        tools = [tool for tool in tools_list if not tool.disabled]
-        if not toolset_names:
-            return []
-        toolset_set = set(toolset_names)
-        tools = [
-            tool
-            for tool in tools
-            if tool.toolset_source is not None and tool.toolset_source in toolset_set
-        ]
         return tools
     def execute(
         self,
         tool_name: str,
         properties: dict[str, Any] | None = None,
         env_vars: dict[str, Any] | None = None,
     ) -> ExecutionResult:
         """
         Execute a tool by name with the provided properties.
         Validates the tool exists, validates input properties against the tool's
@@ -149,46 +82,26 @@
         """
         if properties is None:
             properties = {}
         if env_vars is None:
             env_vars = {}
         tool = self.get_tool(tool_name)
         if tool is None:
             raise ToolManagerError(f"Tool not found: {tool_name}")
         if tool.inputSchema is not None and tool.inputSchema:
             self._validate_input_properties(tool, properties)
-        context: dict[str, Any] = {
+        context = {
             "props": properties,
             "env": env_vars,
             "input": properties,  # Alias for backward compatibility
         }
-        path_context: dict[str, Any] | None = None
-        if self._schema_file_path:
-            from .path_validator import PathValidator
-            context_dir = Path(self._schema_file_path).parent
-            enable_any_paths, directory_allow_list = PathValidator.merge_settings(
-                schema_enable_any_paths=self.schema.enableAnyPaths,
-                schema_directory_allow_list=self.schema.directoryAllowList,
-                tool_enable_any_paths=tool.enableAnyPaths,
-                tool_directory_allow_list=tool.directoryAllowList,
-            )
-            path_context = {
-                "validator": PathValidator(
-                    context_dir=context_dir,
-                    enable_any_paths=enable_any_paths,
-                    directory_allow_list=directory_allow_list,
-                )
-            }
-        context["path_validation"] = path_context
-        executor = ExecutorFactory.get_executor(
-            tool.execution.type, mcp_servers=self.schema.mcp_servers
-        )
+        executor = ExecutorFactory.get_executor(tool.execution.type)
         result = executor.execute(tool.execution, context)
         return result
     def _validate_input_properties(self, tool: Tool, properties: dict[str, Any]) -> None:
         """
         Validate properties against the tool's input schema.
         Checks that all required properties are provided.
         Args:
             tool: Tool object with inputSchema
             properties: Properties to validate
         Raises:
