# ====================================================================
# FILE: devtools/lint.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| import subprocess
     2| from funlog import log_calls
     3| from rich import get_console, reconfigure
     4| from rich import print as rprint
     5| SRC_PATHS = ["src", "tests", "devtools"]
     6| DOC_PATHS = ["README.md"]
     7| reconfigure(emoji=not get_console().options.legacy_windows)  # No emojis on legacy windows.
     8| def main():
     9|     rprint()
    10|     errcount = 0
    11|     errcount += run(["codespell", "--write-changes", *SRC_PATHS, *DOC_PATHS])
    12|     errcount += run(["ruff", "check", "--fix", *SRC_PATHS])
    13|     errcount += run(["ruff", "format", *SRC_PATHS])
    14|     errcount += run(["basedpyright", "--stats", *SRC_PATHS])
    15|     rprint()
    16|     if errcount != 0:
    17|         rprint(f"[bold red]:x: Lint failed with {errcount} errors.[/bold red]")
    18|     else:
    19|         rprint("[bold green]:white_check_mark: Lint passed![/bold green]")
    20|     rprint()
    21|     return errcount
    22| @log_calls(level="warning", show_timing_only=True)
    23| def run(cmd: list[str]) -> int:
    24|     rprint()
    25|     rprint(f"[bold green]>> {' '.join(cmd)}[/bold green]")


# ====================================================================
# FILE: example.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 18-71 ---
    18|     print("1. Initializing MCIClient with example.mci.json...")
    19|     client = MCIClient(
    20|         json_file_path="./example.mci.json",
    21|         env_vars={
    22|             "CURRENT_DATE": datetime.now().strftime("%Y-%m-%d"),
    23|             "API_KEY": "demo-api-key-123",
    24|             "USERNAME": "demo_user",
    25|         },
    26|     )
    27|     print("   ✓ Client initialized successfully")
    28|     print()
    29|     print("2. Listing available tools...")
    30|     tool_names = client.list_tools()
    31|     print(f"   Found {len(tool_names)} tools:")
    32|     for tool_name in tool_names:
    33|         print(f"   - {tool_name}")
    34|     print()
    35|     print("3. Executing 'generate_message' tool...")
    36|     print("   Input: username='Alice'")
    37|     result = client.execute(tool_name="generate_message", properties={"username": "Alice"})
    38|     if result.isError:
    39|         print(f"   ✗ Error: {result.error}")
    40|     else:
    41|         print(f"   ✓ Success!")
    42|         print(f"   Output: {result.content}")
    43|     print()
    44|     print("4. Executing 'load_template' tool...")
    45|     print("   Input: username='Bob'")
    46|     print("   Note: This tool reads from ./text.txt with template substitution")
    47|     result = client.execute(tool_name="load_template", properties={"username": "Bob", "new_prop": [1, 2, 3]})
    48|     if result.isError:
    49|         print(f"   ✗ Error: {result.error}")
    50|     else:
    51|         print(f"   ✓ Success!")
    52|         print(f"   Output: {result.content}")
    53|     print()
    54|     print("5. Demonstrating tool filtering...")
    55|     print("   Filtering to only 'load_template' and 'generate_message':")
    56|     filtered_tools = client.only(["load_template", "generate_message"])
    57|     print(f"   Found {len(filtered_tools)} tools:")
    58|     for tool in filtered_tools:
    59|         print(f"   - {tool.name}: {tool.title}")
    60|     print()
    61|     print("6. Getting tool schema...")
    62|     schema = client.get_tool_schema("generate_message")
    63|     print(f"   Schema for 'generate_message':")
    64|     print(f"   - Required properties: {schema.get('required', [])}")
    65|     print(f"   - Properties: {list(schema.get('properties', {}).keys())}")
    66|     print()
    67|     print("=" * 80)
    68|     print("Example completed successfully!")
    69|     print("=" * 80)
    70| if __name__ == "__main__":
    71|     main()


# ====================================================================
# FILE: examples/example_usage.py
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 34-192 ---
    34|     print("Example: Get weather tool (would make HTTP GET request)")
    35|     print("  Tool: get_weather")
    36|     print("  Would call: https://api.example.com/weather?location=Seattle&units=metric")
    37|     print()
    38|     print("Example: Create report tool (would make HTTP POST request)")
    39|     print("  Tool: create_report")
    40|     print("  Would call: https://api.example.com/reports")
    41|     print("  With Bearer authentication and JSON body")
    42|     print()
    43| def demo_cli_examples():
    44|     """Demonstrate CLI execution examples."""
    45|     print_section("CLI Execution Examples")
    46|     client = MCIClient(json_file_path="examples/cli_example.json")
    47|     print("Available CLI tools:")
    48|     for tool_name in client.list_tools():
    49|         print(f"  - {tool_name}")
    50|     print()
    51|     print("Executing: count_lines on README.md")
    52|     try:
    53|         result = client.execute(tool_name="count_lines", properties={"file_path": "README.md"})
    54|         if not result.isError:
    55|             print("  ✓ Success!")
    56|             print(f"  Output: {result.content.strip()}")
    57|         else:
    58|             print(f"  ✗ Error: {result.error}")
    59|     except Exception as e:
    60|         print(f"  ✗ Exception: {e}")
    61|     print()
    62|     print("Executing: list_files on current directory")
    63|     try:
    64|         result = client.execute(
    65|             tool_name="list_files", properties={"directory": ".", "show_hidden": False}
    66|         )
    67|         if not result.isError:
    68|             print("  ✓ Success!")
    69|             lines = result.content.strip().split("\n")
    70|             print("  Output (first 5 lines):")
    71|             for line in lines[:5]:
    72|                 print(f"    {line}")
    73|             if len(lines) > 5:
    74|                 print(f"    ... and {len(lines) - 5} more lines")
    75|         else:
    76|             print(f"  ✗ Error: {result.error}")
    77|     except Exception as e:
    78|         print(f"  ✗ Exception: {e}")
    79|     print()
    80| def demo_file_examples():
    81|     """Demonstrate file execution examples."""
    82|     print_section("File Execution Examples")
    83|     client = MCIClient(
    84|         json_file_path="examples/file_example.json",
    85|         env_vars={"CURRENT_DATE": datetime.now().strftime("%Y-%m-%d"), "USERNAME": "demo_user"},
    86|     )
    87|     print("Available File tools:")
    88|     for tool_name in client.list_tools():
    89|         print(f"  - {tool_name}")
    90|     print()
    91|     print("Executing: load_template")
    92|     print("  Note: This tool reads ./text.txt with placeholder substitution")
    93|     try:
    94|         result = client.execute(tool_name="load_template", properties={"username": "Alice"})
    95|         if not result.isError:
    96|             print("  ✓ Success!")
    97|             print(f"  Content preview: {result.content[:200]}...")
    98|         else:
    99|             print(f"  ✗ Error: {result.error}")
   100|             print("  (This is expected if text.txt doesn't exist)")
   101|     except Exception as e:
   102|         print(f"  ✗ Exception: {e}")
   103|     print()
   104| def demo_text_examples():
   105|     """Demonstrate text execution examples."""
   106|     print_section("Text Execution Examples")
   107|     client = MCIClient(
   108|         json_file_path="examples/text_example.json",
   109|         env_vars={
   110|             "CURRENT_DATE": datetime.now().strftime("%Y-%m-%d"),
   111|             "TIMESTAMP": datetime.now().isoformat(),
   112|             "APP_VERSION": "1.0.0",
   113|         },
   114|     )
   115|     print("Available Text tools:")
   116|     for tool_name in client.list_tools():
   117|         print(f"  - {tool_name}")
   118|     print()
   119|     print("Executing: generate_message")
   120|     result = client.execute(tool_name="generate_message", properties={"username": "Bob"})
   121|     if not result.isError:
   122|         print("  ✓ Success!")
   123|         print(f"  Output: {result.content}")
   124|     else:
   125|         print(f"  ✗ Error: {result.error}")
   126|     print()
   127|     print("Executing: generate_welcome")
   128|     result = client.execute(
   129|         tool_name="generate_welcome", properties={"username": "Alice", "email": "alice@example.com"}
   130|     )
   131|     if not result.isError:
   132|         print("  ✓ Success!")
   133|         print(f"  Output: {result.content}")
   134|     else:
   135|         print(f"  ✗ Error: {result.error}")
   136|     print()
   137|     print("Executing: status_message")
   138|     result = client.execute(tool_name="status_message", properties={"status": "operational"})
   139|     if not result.isError:
   140|         print("  ✓ Success!")
   141|         print(f"  Output: {result.content}")
   142|     else:
   143|         print(f"  ✗ Error: {result.error}")
   144|     print()
   145| def demo_mixed_examples():
   146|     """Demonstrate mixed execution examples (all types)."""
   147|     print_section("Mixed Execution Examples (All Types)")
   148|     client = MCIClient(
   149|         json_file_path="examples/mixed_example.json",
   150|         env_vars={
   151|             "CURRENT_DATE": datetime.now().strftime("%Y-%m-%d"),
   152|             "BEARER_TOKEN": "demo-bearer-token",
   153|         },
   154|     )
   155|     print("Available tools (all execution types):")
   156|     all_tools = client.tools()
   157|     for tool in all_tools:
   158|         print(f"  - {tool.name} ({tool.execution.type}): {tool.title}")
   159|     print()
   160|     print("Filtering to only text tools:")
   161|     text_tools = client.only(["generate_message", "generate_welcome"])
   162|     print(f"  Found {len(text_tools)} tools:")
   163|     for tool in text_tools:
   164|         print(f"  - {tool.name}")
   165|     print()
   166|     print("Executing: generate_message from mixed example")
   167|     result = client.execute(tool_name="generate_message", properties={"username": "Charlie"})
   168|     if not result.isError:
   169|         print("  ✓ Success!")
   170|         print(f"  Output: {result.content}")
   171|     else:
   172|         print(f"  ✗ Error: {result.error}")
   173|     print()
   174| def demo_tool_inspection():
   175|     """Demonstrate tool inspection capabilities."""
   176|     print_section("Tool Inspection")
   177|     client = MCIClient(json_file_path="examples/text_example.json")
   178|     print("Getting schema for 'generate_report_summary':")
   179|     schema = client.get_tool_schema("generate_report_summary")
   180|     print(f"  Required properties: {schema.get('required', [])}")
   181|     print("  Properties:")
   182|     for prop_name, prop_details in schema.get("properties", {}).items():
   183|         print(f"    - {prop_name}: {prop_details.get('description', 'No description')}")
   184|     print()
   185|     print("Getting full tool details:")
   186|     tools = client.tools()
   187|     for tool in tools[:2]:  # Show first 2 tools
   188|         print(f"\nTool: {tool.name}")
   189|         print(f"  Title: {tool.title}")
   190|         print(f"  Description: {tool.description}")
   191|         print(f"  Execution Type: {tool.execution.type}")
   192|         if hasattr(tool.execution, "text"):


# ====================================================================
# FILE: src/mcipy/__init__.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-45 ---
     1| from .client import MCIClient, MCIClientError
     2| from .enums import ExecutionType
     3| from .models import (
     4|     ApiKeyAuth,
     5|     BasicAuth,
     6|     BearerAuth,
     7|     CLIExecutionConfig,
     8|     ExecutionResult,
     9|     FileExecutionConfig,
    10|     FlagConfig,
    11|     HTTPBodyConfig,
    12|     HTTPExecutionConfig,
    13|     MCISchema,
    14|     Metadata,
    15|     OAuth2Auth,
    16|     RetryConfig,
    17|     TextExecutionConfig,
    18|     Tool,
    19| )
    20| from .parser import SchemaParser, SchemaParserError
    21| from .tool_manager import ToolManager, ToolManagerError
    22| __all__ = (
    23|     "MCIClient",
    24|     "MCIClientError",
    25|     "ExecutionType",
    26|     "ApiKeyAuth",
    27|     "BasicAuth",
    28|     "BearerAuth",
    29|     "CLIExecutionConfig",
    30|     "ExecutionResult",
    31|     "FileExecutionConfig",
    32|     "FlagConfig",
    33|     "HTTPBodyConfig",
    34|     "HTTPExecutionConfig",
    35|     "MCISchema",
    36|     "Metadata",
    37|     "OAuth2Auth",
    38|     "RetryConfig",
    39|     "TextExecutionConfig",
    40|     "Tool",
    41|     "SchemaParser",
    42|     "SchemaParserError",
    43|     "ToolManager",
    44|     "ToolManagerError",
    45| )


# ====================================================================
# FILE: src/mcipy/client.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 4-125 ---
     4| programmatic use of MCI tool contexts. It handles loading tool schemas,
     5| managing environment variables, filtering tools, and executing tools.
     6| """
     7| from typing import Any
     8| from .models import ExecutionResult, Tool
     9| from .parser import SchemaParser
    10| from .tool_manager import ToolManager, ToolManagerError
    11| class MCIClientError(Exception):
    12|     """Exception raised for MCI client errors."""
    13|     pass
    14| class MCIClient:
    15|     """
    16|     Main client for MCI adapter.
    17|     Provides the primary API for loading, filtering, and executing MCI tools.
    18|     Handles schema parsing, environment variable management, and tool execution
    19|     orchestration through the ToolManager.
    20|     Example:
    21|         ```python
    22|         from mcipy import MCIClient
    23|         client = MCIClient(
    24|             json_file_path="example.mci.json",
    25|             env_vars={"API_KEY": "your-secret-key"}
    26|         )
    27|         tool_names = client.list_tools()
    28|         weather_tools = client.only(["get_weather", "get_forecast"])
    29|         safe_tools = client.without(["delete_data", "admin_tools"])
    30|         result = client.execute(
    31|             tool_name="get_weather",
    32|             properties={"location": "New York"}
    33|         )
    34|         ```
    35|     """
    36|     def __init__(self, json_file_path: str, env_vars: dict[str, Any] | None = None):
    37|         """
    38|         Initialize the MCI client with a schema file and environment variables.
    39|         Loads the MCI JSON schema, stores environment variables for templating,
    40|         and initializes the ToolManager for tool execution.
    41|         Args:
    42|             json_file_path: Path to the MCI JSON schema file
    43|             env_vars: Environment variables for template substitution (default: empty dict)
    44|         Raises:
    45|             MCIClientError: If the schema file cannot be loaded or parsed
    46|         """
    47|         try:
    48|             self._schema = SchemaParser.parse_file(json_file_path)
    49|         except Exception as e:
    50|             raise MCIClientError(f"Failed to load schema from {json_file_path}: {e}") from e
    51|         self._env_vars = env_vars if env_vars is not None else {}
    52|         self._tool_manager = ToolManager(self._schema)
    53|     def tools(self) -> list[Tool]:
    54|         """
    55|         Get all available tools.
    56|         Returns:
    57|             List of all Tool objects in the schema
    58|         """
    59|         return self._tool_manager.list_tools()
    60|     def only(self, tool_names: list[str]) -> list[Tool]:
    61|         """
    62|         Filter to include only specified tools.
    63|         Returns only the tools whose names are in the provided list.
    64|         Tools not in the list are excluded.
    65|         Args:
    66|             tool_names: List of tool names to include
    67|         Returns:
    68|             Filtered list of Tool objects
    69|         """
    70|         return self._tool_manager.filter_tools(only=tool_names)
    71|     def without(self, tool_names: list[str]) -> list[Tool]:
    72|         """
    73|         Filter to exclude specified tools.
    74|         Returns all tools except those whose names are in the provided list.
    75|         Args:
    76|             tool_names: List of tool names to exclude
    77|         Returns:
    78|             Filtered list of Tool objects
    79|         """
    80|         return self._tool_manager.filter_tools(without=tool_names)
    81|     def execute(self, tool_name: str, properties: dict[str, Any] | None = None) -> ExecutionResult:
    82|         """
    83|         Execute a tool by name with the provided properties.
    84|         Validates that the tool exists, builds the execution context from
    85|         properties and environment variables, and executes the tool using
    86|         the appropriate executor.
    87|         Args:
    88|             tool_name: Name of the tool to execute
    89|             properties: Properties/parameters to pass to the tool (default: empty dict)
    90|         Returns:
    91|             ExecutionResult with success/error status and content
    92|         Raises:
    93|             MCIClientError: If tool not found or execution fails with validation error
    94|         """
    95|         try:
    96|             return self._tool_manager.execute(
    97|                 tool_name=tool_name,
    98|                 properties=properties,
    99|                 env_vars=self._env_vars,
   100|             )
   101|         except ToolManagerError as e:
   102|             raise MCIClientError(str(e)) from e
   103|     def list_tools(self) -> list[str]:
   104|         """
   105|         List available tool names.
   106|         Returns:
   107|             List of tool names (strings)
   108|         """
   109|         return [tool.name for tool in self._tool_manager.list_tools()]
   110|     def get_tool_schema(self, tool_name: str) -> dict[str, Any]:
   111|         """
   112|         Get a tool's input schema.
   113|         Returns the JSON schema that defines the expected input properties
   114|         for the specified tool.
   115|         Args:
   116|             tool_name: Name of the tool
   117|         Returns:
   118|             Tool's input schema as a dictionary (or empty dict if no schema)
   119|         Raises:
   120|             MCIClientError: If tool not found
   121|         """
   122|         tool = self._tool_manager.get_tool(tool_name)
   123|         if tool is None:
   124|             raise MCIClientError(f"Tool not found: {tool_name}")
   125|         return tool.inputSchema if tool.inputSchema is not None else {}


# ====================================================================
# FILE: src/mcipy/enums.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-19 ---
     1| """
     2| Execution type enumerations for MCI.
     3| This module defines the execution types supported by the MCI adapter,
     4| including HTTP requests, CLI commands, file reading, and text templates.
     5| """
     6| from enum import Enum
     7| class ExecutionType(str, Enum):
     8|     """
     9|     Defines the types of execution supported by MCI.
    10|     Each execution type corresponds to a different way of executing a tool:
    11|     - HTTP: Make HTTP requests to APIs
    12|     - CLI: Execute command-line tools
    13|     - FILE: Read and parse files
    14|     - TEXT: Return text with placeholder substitution
    15|     """
    16|     HTTP = "http"
    17|     CLI = "cli"
    18|     FILE = "file"
    19|     TEXT = "text"


# ====================================================================
# FILE: src/mcipy/executors/__init__.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-63 ---
     1| """
     2| Execution handlers for MCI tools.
     3| This module provides the executor classes that handle different types of
     4| tool execution (HTTP, CLI, file, text). Each executor inherits from BaseExecutor
     5| and implements the execute() method according to its execution type.
     6| The ExecutorFactory provides centralized instantiation of executors based on
     7| execution type, with singleton caching for performance.
     8| """
     9| from ..enums import ExecutionType
    10| from .base import BaseExecutor
    11| from .cli_executor import CLIExecutor
    12| from .file_executor import FileExecutor
    13| from .http_executor import HTTPExecutor
    14| from .text_executor import TextExecutor
    15| class ExecutorFactory:
    16|     """
    17|     Factory for creating and caching executor instances.
    18|     Provides centralized instantiation of executors based on execution type.
    19|     Uses singleton pattern to cache executor instances for better performance.
    20|     """
    21|     _executors: dict[ExecutionType, BaseExecutor] = {}
    22|     @classmethod
    23|     def get_executor(cls, execution_type: ExecutionType) -> BaseExecutor:
    24|         """
    25|         Get an executor instance for the given execution type.
    26|         Returns a cached executor instance if available, otherwise creates
    27|         a new one and caches it for future use.
    28|         Args:
    29|             execution_type: The type of execution (HTTP, CLI, FILE, TEXT)
    30|         Returns:
    31|             BaseExecutor instance for the specified type
    32|         Raises:
    33|             ValueError: If the execution type is not supported
    34|         """
    35|         if execution_type in cls._executors:
    36|             return cls._executors[execution_type]
    37|         if execution_type == ExecutionType.HTTP:
    38|             executor = HTTPExecutor()
    39|         elif execution_type == ExecutionType.CLI:
    40|             executor = CLIExecutor()
    41|         elif execution_type == ExecutionType.FILE:
    42|             executor = FileExecutor()
    43|         elif execution_type == ExecutionType.TEXT:
    44|             executor = TextExecutor()
    45|         else:
    46|             raise ValueError(f"Unsupported execution type: {execution_type}")
    47|         cls._executors[execution_type] = executor
    48|         return executor
    49|     @classmethod
    50|     def clear_cache(cls) -> None:
    51|         """
    52|         Clear the executor cache.
    53|         Useful for testing or when you want to ensure fresh executor instances.
    54|         """
    55|         cls._executors.clear()
    56| __all__ = [
    57|     "BaseExecutor",
    58|     "CLIExecutor",
    59|     "ExecutorFactory",
    60|     "FileExecutor",
    61|     "HTTPExecutor",
    62|     "TextExecutor",
    63| ]


# ====================================================================
# FILE: src/mcipy/executors/base.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-28 ---
     1| """
     2| Base executor class for MCI tool execution.
     3| This module provides the abstract BaseExecutor class that all executors inherit from.
     4| It provides common functionality for context building, timeout handling, and error formatting.
     5| """
     6| from abc import ABC, abstractmethod
     7| from typing import Any
     8| from ..models import ExecutionConfig, ExecutionResult
     9| from ..templating import TemplateEngine
    10| class BaseExecutor(ABC):
    11|     """
    12|     Abstract base class for all executors.
    13|     Provides common execution logic including context building, timeout handling,
    14|     and error formatting. All concrete executors (HTTP, CLI, File, Text) inherit
    15|     from this base class and implement the execute() method.
    16|     """
    17|     def __init__(self):
    18|         """Initialize the base executor with a template engine."""
    19|         self.template_engine = TemplateEngine()
    20|     @abstractmethod
    21|     def execute(self, config: ExecutionConfig, context: dict[str, Any]) -> ExecutionResult:
    22|         """
    23|         Execute a tool with the given configuration and context.
    24|         This is an abstract method that must be implemented by all concrete executors.
    25|         Args:
    26|             config: Execution configuration specific to the executor type
    27|             context: Context dictionary with 'props', 'env', and 'input' keys
    28|         Returns:

# --- HUNK 2: Lines 49-98 ---
    49|             "input": props,  # Alias for backward compatibility
    50|         }
    51|     def _handle_timeout(self, timeout_ms: int) -> int:
    52|         """
    53|         Convert timeout from milliseconds to seconds and apply defaults.
    54|         If timeout_ms is 0 or negative, returns a default timeout of 30 seconds.
    55|         Otherwise converts milliseconds to seconds (rounding up).
    56|         Args:
    57|             timeout_ms: Timeout in milliseconds
    58|         Returns:
    59|             Timeout in seconds (minimum 1 second)
    60|         """
    61|         if timeout_ms <= 0:
    62|             return 30  # Default timeout of 30 seconds
    63|         timeout_s = max(1, (timeout_ms + 999) // 1000)
    64|         return timeout_s
    65|     def _format_error(self, error: Exception) -> ExecutionResult:
    66|         """
    67|         Format an exception into a standardized ExecutionResult error response.
    68|         Converts any exception into a consistent error format with isError=True
    69|         and the error message as a string.
    70|         Args:
    71|             error: Exception that occurred during execution
    72|         Returns:
    73|             ExecutionResult with isError=True and error message
    74|         """
    75|         return ExecutionResult(
    76|             isError=True,
    77|             error=str(error),
    78|             content=None,
    79|         )
    80|     def _apply_basic_templating_to_config(
    81|         self, config: ExecutionConfig, context: dict[str, Any]
    82|     ) -> None:
    83|         """
    84|         Apply basic templating to all string fields in the execution config.
    85|         Recursively processes the config object and replaces placeholders like
    86|         {{props.x}} and {{env.Y}} in all string fields. This is applied to
    87|         the entire execution configuration (URLs, paths, headers, params, etc.)
    88|         but NOT to large text content which uses advanced templating.
    89|         Args:
    90|             config: Execution configuration to process (modified in-place)
    91|             context: Context dictionary for template resolution
    92|         Note:
    93|             This method modifies the config object in-place.
    94|         """
    95|         for field_name, field_value in config.__dict__.items():
    96|             if field_value is None:
    97|                 continue
    98|             if isinstance(field_value, str):


# ====================================================================
# FILE: src/mcipy/executors/cli_executor.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-75 ---
     1| """
     2| CLI executor for MCI tools.
     3| This module provides the CLIExecutor class that handles CLI-based tool execution.
     4| It supports command execution with arguments, boolean and value flags, working directory,
     5| and timeout handling. The executor is platform-aware and handles Windows/Linux/macOS
     6| differences in command execution.
     7| """
     8| import subprocess
     9| from typing import Any
    10| from ..models import CLIExecutionConfig, ExecutionConfig, ExecutionResult, FlagConfig
    11| from .base import BaseExecutor
    12| class CLIExecutor(BaseExecutor):
    13|     """
    14|     Executor for CLI-based tools.
    15|     Handles command-line tool execution with support for arguments, flags,
    16|     working directory, and timeouts. Applies templating to all command components
    17|     and handles platform-specific differences.
    18|     """
    19|     def __init__(self):
    20|         """Initialize the CLI executor with a template engine."""
    21|         super().__init__()
    22|     def execute(self, config: ExecutionConfig, context: dict[str, Any]) -> ExecutionResult:
    23|         """
    24|         Execute a CLI-based tool by running a subprocess.
    25|         Args:
    26|             config: CLI execution configuration with command, args, flags, cwd, timeout
    27|             context: Context dictionary with 'props', 'env', and 'input' keys
    28|         Returns:
    29|             ExecutionResult with command output or error
    30|         """
    31|         if not isinstance(config, CLIExecutionConfig):
    32|             return self._format_error(
    33|                 TypeError(f"Expected CLIExecutionConfig, got {type(config).__name__}")
    34|             )
    35|         try:
    36|             self._apply_basic_templating_to_config(config, context)
    37|             command_list = self._build_command_args(config, context)
    38|             cwd = config.cwd if config.cwd else None
    39|             timeout = self._handle_timeout(config.timeout_ms)
    40|             stdout, stderr, returncode = self._run_subprocess(command_list, cwd, timeout)
    41|             if returncode != 0:
    42|                 error_msg = f"Command exited with code {returncode}"
    43|                 if stderr:
    44|                     error_msg += f": {stderr}"
    45|                 return ExecutionResult(
    46|                     isError=True,
    47|                     error=error_msg,
    48|                     content=None,
    49|                     metadata={"returncode": returncode, "stderr": stderr, "stdout": stdout},
    50|                 )
    51|             return ExecutionResult(
    52|                 isError=False,
    53|                 content=stdout,
    54|                 error=None,
    55|                 metadata={"returncode": returncode, "stderr": stderr},
    56|             )
    57|         except Exception as e:
    58|             return self._format_error(e)
    59|     def _build_command_args(self, config: CLIExecutionConfig, context: dict[str, Any]) -> list[str]:
    60|         """
    61|         Build the full command list with arguments and flags.
    62|         Combines the command, arguments, and flags into a single list suitable
    63|         for subprocess execution. Handles both boolean and value flags.
    64|         Args:
    65|             config: CLI execution configuration
    66|             context: Context dictionary for flag resolution
    67|         Returns:
    68|             List of command components (command, args, flags)
    69|         """
    70|         command_list = [config.command]
    71|         if config.args:
    72|             command_list.extend(config.args)
    73|         if config.flags:
    74|             flag_args = self._apply_flags(config.flags, context)
    75|             command_list.extend(flag_args)


# ====================================================================
# FILE: src/mcipy/executors/file_executor.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-60 ---
     1| """
     2| File executor for MCI tools.
     3| This module provides the FileExecutor class that handles file-based tool execution.
     4| It reads files from disk and optionally applies templating to the content.
     5| """
     6| from pathlib import Path
     7| from typing import Any
     8| from ..models import ExecutionConfig, ExecutionResult, FileExecutionConfig
     9| from .base import BaseExecutor
    10| class FileExecutor(BaseExecutor):
    11|     """
    12|     Executor for file-based tools.
    13|     Reads files from disk and optionally applies templating to the content.
    14|     Supports both basic placeholder substitution and advanced templating
    15|     with @for, @foreach, and @if directives when enableTemplating is true.
    16|     """
    17|     def __init__(self):
    18|         """Initialize the file executor with a template engine."""
    19|         super().__init__()
    20|     def execute(self, config: ExecutionConfig, context: dict[str, Any]) -> ExecutionResult:
    21|         """
    22|         Execute a file-based tool by reading and optionally templating file content.
    23|         Args:
    24|             config: File execution configuration with path and enableTemplating flag
    25|             context: Context dictionary with 'props', 'env', and 'input' keys
    26|         Returns:
    27|             ExecutionResult with file content (possibly templated) or error
    28|         """
    29|         if not isinstance(config, FileExecutionConfig):
    30|             return self._format_error(
    31|                 TypeError(f"Expected FileExecutionConfig, got {type(config).__name__}")
    32|             )
    33|         try:
    34|             self._apply_basic_templating_to_config(config, context)
    35|             content = self._read_file(config.path)
    36|             parsed_content = self._parse_content(content, context, config.enableTemplating)
    37|             return ExecutionResult(
    38|                 isError=False,
    39|                 content=parsed_content,
    40|                 error=None,
    41|             )
    42|         except Exception as e:
    43|             return self._format_error(e)
    44|     def _read_file(self, path: str) -> str:
    45|         """
    46|         Read the content of a file from disk.
    47|         Args:
    48|             path: Path to the file to read
    49|         Returns:
    50|             File content as a string
    51|         Raises:
    52|             FileNotFoundError: If the file does not exist
    53|             IOError: If the file cannot be read
    54|         """
    55|         file_path = Path(path)
    56|         if not file_path.exists():
    57|             raise FileNotFoundError(f"File not found: {path}")
    58|         if not file_path.is_file():
    59|             raise OSError(f"Path is not a file: {path}")
    60|         return file_path.read_text(encoding="utf-8")


# ====================================================================
# FILE: src/mcipy/executors/http_executor.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-42 ---
     1| """
     2| HTTP executor for MCI tools.
     3| This module provides the HTTPExecutor class that handles HTTP-based tool execution.
     4| It supports various HTTP methods, authentication types (API Key, Bearer, Basic, OAuth2),
     5| request body types (JSON, form, raw), and retry logic with exponential backoff.
     6| """
     7| import base64
     8| import time
     9| from collections.abc import Callable
    10| from typing import Any
    11| import requests
    12| from ..models import (
    13|     ApiKeyAuth,
    14|     AuthConfig,
    15|     BasicAuth,
    16|     BearerAuth,
    17|     ExecutionConfig,
    18|     ExecutionResult,
    19|     HTTPBodyConfig,
    20|     HTTPExecutionConfig,
    21|     OAuth2Auth,
    22|     RetryConfig,
    23| )
    24| from .base import BaseExecutor
    25| class HTTPExecutor(BaseExecutor):
    26|     """
    27|     Executor for HTTP-based tools.
    28|     Handles HTTP requests with various authentication methods, body types,
    29|     and retry logic. Supports GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS methods.
    30|     """
    31|     def __init__(self):
    32|         """Initialize the HTTP executor with a template engine."""
    33|         super().__init__()
    34|     def execute(self, config: ExecutionConfig, context: dict[str, Any]) -> ExecutionResult:
    35|         """
    36|         Execute an HTTP-based tool by making an HTTP request.
    37|         Args:
    38|             config: HTTP execution configuration with URL, method, headers, auth, etc.
    39|             context: Context dictionary with 'props', 'env', and 'input' keys
    40|         Returns:
    41|             ExecutionResult with response content or error
    42|         """

# --- HUNK 2: Lines 67-126 ---
    67|                 "timeout": self._handle_timeout(config.timeout_ms),
    68|             }
    69|             if config.headers:
    70|                 request_kwargs["headers"] = config.headers.copy()
    71|             if config.params:
    72|                 request_kwargs["params"] = config.params
    73|             if config.auth:
    74|                 self._apply_authentication(config.auth, request_kwargs)
    75|             if config.body:
    76|                 body_data, content_type = self._build_body(config.body, context)
    77|                 if body_data is not None:
    78|                     if config.body.type == "json":
    79|                         request_kwargs["json"] = body_data
    80|                     elif config.body.type == "form":
    81|                         request_kwargs["data"] = body_data
    82|                     else:  # raw
    83|                         request_kwargs["data"] = body_data
    84|                     if content_type and "headers" in request_kwargs:
    85|                         if "Content-Type" not in request_kwargs["headers"]:
    86|                             request_kwargs["headers"]["Content-Type"] = content_type
    87|             if config.retries:
    88|                 response = self._apply_retry_logic(
    89|                     lambda: requests.request(**request_kwargs),
    90|                     config.retries,
    91|                 )
    92|             else:
    93|                 response = requests.request(**request_kwargs)
    94|             response.raise_for_status()
    95|             try:
    96|                 content = response.json()
    97|             except ValueError:
    98|                 content = response.text
    99|             return ExecutionResult(
   100|                 isError=False,
   101|                 content=content,
   102|                 error=None,
   103|                 metadata={"status_code": response.status_code},
   104|             )
   105|         except Exception as e:
   106|             return self._format_error(e)
   107|     def _apply_authentication(self, auth: AuthConfig, request_kwargs: dict[str, Any]) -> None:
   108|         """
   109|         Apply authentication configuration to the request.
   110|         Dispatches to the appropriate auth handler based on auth type.
   111|         Args:
   112|             auth: Authentication configuration
   113|             request_kwargs: Request keyword arguments dictionary (modified in-place)
   114|         """
   115|         if isinstance(auth, ApiKeyAuth):
   116|             self._handle_api_key_auth(auth, request_kwargs)
   117|         elif isinstance(auth, BearerAuth):
   118|             self._handle_bearer_auth(auth, request_kwargs)
   119|         elif isinstance(auth, BasicAuth):
   120|             self._handle_basic_auth(auth, request_kwargs)
   121|         elif isinstance(auth, OAuth2Auth):  # pyright: ignore[reportUnnecessaryIsInstance]
   122|             self._handle_oauth2_auth(auth, request_kwargs)
   123|     def _handle_api_key_auth(self, auth: ApiKeyAuth, request_kwargs: dict[str, Any]) -> None:
   124|         """
   125|         Apply API Key authentication to the request.
   126|         API keys can be placed in headers or query parameters.


# ====================================================================
# FILE: src/mcipy/executors/text_executor.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-41 ---
     1| """
     2| Text executor for MCI tools.
     3| This module provides the TextExecutor class that handles simple text-based tool execution.
     4| It applies templating to text strings and returns the result.
     5| """
     6| from typing import Any
     7| from ..models import ExecutionConfig, ExecutionResult, TextExecutionConfig
     8| from .base import BaseExecutor
     9| class TextExecutor(BaseExecutor):
    10|     """
    11|     Executor for text-based tools.
    12|     Applies templating to text strings, supporting both basic placeholder
    13|     substitution and advanced templating with @for, @foreach, and @if directives.
    14|     """
    15|     def __init__(self):
    16|         """Initialize the text executor with a template engine."""
    17|         super().__init__()
    18|     def execute(self, config: ExecutionConfig, context: dict[str, Any]) -> ExecutionResult:
    19|         """
    20|         Execute a text-based tool by applying templating to the text.
    21|         Processes the text with advanced templating, supporting all directives
    22|         (@for, @foreach, @if) along with basic placeholder substitution.
    23|         Args:
    24|             config: Text execution configuration with the text template
    25|             context: Context dictionary with 'props', 'env', and 'input' keys
    26|         Returns:
    27|             ExecutionResult with templated text or error
    28|         """
    29|         if not isinstance(config, TextExecutionConfig):
    30|             return self._format_error(
    31|                 TypeError(f"Expected TextExecutionConfig, got {type(config).__name__}")
    32|             )
    33|         try:
    34|             result = self.template_engine.render_advanced(config.text, context)
    35|             return ExecutionResult(
    36|                 isError=False,
    37|                 content=result,
    38|                 error=None,
    39|             )
    40|         except Exception as e:
    41|             return self._format_error(e)


# ====================================================================
# FILE: src/mcipy/models.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-32 ---
     1| """
     2| Pydantic data models for MCI schema validation.
     3| This module defines the data structures used throughout the MCI adapter,
     4| providing strong typing, validation, and schema enforcement for:
     5| - Top-level MCI schema with metadata and tools
     6| - Tool definitions with input schemas and execution configurations
     7| - Execution configurations for different execution types (HTTP, CLI, File, Text)
     8| - Authentication configurations
     9| - Execution results
    10| """
    11| from typing import Any
    12| from pydantic import BaseModel, Field
    13| from .enums import ExecutionType
    14| class Metadata(BaseModel):
    15|     """
    16|     Optional metadata for an MCI schema.
    17|     Contains descriptive information about the tool collection,
    18|     such as name, version, description, license, and authors.
    19|     """
    20|     name: str | None = None
    21|     description: str | None = None
    22|     version: str | None = None
    23|     license: str | None = None
    24|     authors: list[str] | None = None
    25| class ApiKeyAuth(BaseModel):
    26|     """API Key authentication configuration."""
    27|     type: str = Field(default="apiKey")
    28|     in_: str = Field(alias="in")  # "header" or "query"
    29|     name: str
    30|     value: str
    31| class BearerAuth(BaseModel):
    32|     """Bearer token authentication configuration."""

# --- HUNK 2: Lines 92-145 ---
    92|     flags: dict[str, FlagConfig] | None = None
    93|     cwd: str | None = None
    94|     timeout_ms: int = Field(default=30000, ge=0)
    95| class FileExecutionConfig(ExecutionConfig):
    96|     """
    97|     File execution configuration.
    98|     Defines how to read and parse files, including the file path
    99|     and whether to parse placeholders in the file content.
   100|     """
   101|     type: ExecutionType = Field(default=ExecutionType.FILE)
   102|     path: str
   103|     enableTemplating: bool = Field(default=True)
   104| class TextExecutionConfig(ExecutionConfig):
   105|     """
   106|     Text execution configuration.
   107|     Defines a simple text template that will be processed with
   108|     placeholder substitution and returned as the result.
   109|     """
   110|     type: ExecutionType = Field(default=ExecutionType.TEXT)
   111|     text: str
   112| class Tool(BaseModel):
   113|     """
   114|     Individual tool definition.
   115|     Represents a single tool with its name, title, description,
   116|     input schema (JSON Schema), and execution configuration.
   117|     The execution configuration determines how the tool is executed
   118|     (HTTP, CLI, file, or text).
   119|     """
   120|     name: str
   121|     title: str | None = None
   122|     description: str | None = None
   123|     inputSchema: dict[str, Any] | None = None
   124|     execution: HTTPExecutionConfig | CLIExecutionConfig | FileExecutionConfig | TextExecutionConfig
   125| class MCISchema(BaseModel):
   126|     """
   127|     Top-level MCI schema.
   128|     Represents the complete MCI context file with schema version,
   129|     optional metadata, and a list of tool definitions.
   130|     This is the root model that validates the entire JSON schema.
   131|     """
   132|     schemaVersion: str
   133|     metadata: Metadata | None = None
   134|     tools: list[Tool]
   135| class ExecutionResult(BaseModel):
   136|     """
   137|     Execution result format.
   138|     Represents the result of executing a tool, including whether
   139|     an error occurred and the content or error message.
   140|     This provides a consistent format for all execution results.
   141|     """
   142|     isError: bool
   143|     content: Any | None = None
   144|     error: str | None = None
   145|     metadata: dict[str, Any] | None = None


# ====================================================================
# FILE: src/mcipy/parser.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-111 ---
     1| """
     2| Schema parser for MCI JSON files.
     3| This module provides the SchemaParser class for loading and validating
     4| MCI schema files. It handles:
     5| - Loading JSON files from disk
     6| - Parsing dictionaries into MCISchema objects
     7| - Validating schema versions
     8| - Validating tool definitions
     9| - Building appropriate execution configurations based on type
    10| """
    11| import json
    12| from pathlib import Path
    13| from typing import Any
    14| from pydantic import ValidationError
    15| from .enums import ExecutionType
    16| from .models import (
    17|     CLIExecutionConfig,
    18|     ExecutionConfig,
    19|     FileExecutionConfig,
    20|     HTTPExecutionConfig,
    21|     MCISchema,
    22|     TextExecutionConfig,
    23| )
    24| from .schema_config import SUPPORTED_SCHEMA_VERSIONS
    25| class SchemaParserError(Exception):
    26|     """Exception raised for schema parsing errors."""
    27|     pass
    28| class SchemaParser:
    29|     """
    30|     Parser for MCI schema files.
    31|     Loads and validates MCI JSON schema files, ensuring they conform to
    32|     the expected structure and contain valid tool definitions. Uses Pydantic
    33|     for strong validation and provides helpful error messages for invalid schemas.
    34|     """
    35|     @staticmethod
    36|     def parse_file(file_path: str) -> MCISchema:
    37|         """
    38|         Load and validate an MCI JSON file.
    39|         Reads a JSON file from disk, validates its structure and content,
    40|         and returns a parsed MCISchema object.
    41|         Args:
    42|             file_path: Path to the MCI JSON file
    43|         Returns:
    44|             Validated MCISchema object
    45|         Raises:
    46|             SchemaParserError: If the file doesn't exist, can't be read,
    47|                              contains invalid JSON, or fails validation
    48|         """
    49|         path = Path(file_path)
    50|         if not path.exists():
    51|             raise SchemaParserError(f"Schema file not found: {file_path}")
    52|         if not path.is_file():
    53|             raise SchemaParserError(f"Path is not a file: {file_path}")
    54|         try:
    55|             with path.open("r", encoding="utf-8") as f:
    56|                 data = json.load(f)
    57|         except json.JSONDecodeError as e:
    58|             raise SchemaParserError(f"Invalid JSON in file {file_path}: {e}") from e
    59|         except OSError as e:
    60|             raise SchemaParserError(f"Failed to read file {file_path}: {e}") from e
    61|         return SchemaParser.parse_dict(data)
    62|     @staticmethod
    63|     def parse_dict(data: dict[str, Any]) -> MCISchema:
    64|         """
    65|         Parse a dictionary into an MCISchema object.
    66|         Validates the dictionary structure, schema version, and tool definitions,
    67|         then returns a validated MCISchema object.
    68|         Args:
    69|             data: Dictionary containing MCI schema data
    70|         Returns:
    71|             Validated MCISchema object
    72|         Raises:
    73|             SchemaParserError: If the dictionary structure is invalid,
    74|                              schema version is unsupported, or validation fails
    75|         """
    76|         if not isinstance(data, dict):
    77|             raise SchemaParserError(f"Expected dictionary, got {type(data).__name__}")
    78|         if "schemaVersion" not in data:
    79|             raise SchemaParserError("Missing required field 'schemaVersion'")
    80|         if "tools" not in data:
    81|             raise SchemaParserError("Missing required field 'tools'")
    82|         SchemaParser._validate_schema_version(data["schemaVersion"])
    83|         if not isinstance(data["tools"], list):
    84|             raise SchemaParserError(
    85|                 f"Field 'tools' must be a list, got {type(data['tools']).__name__}"
    86|             )
    87|         SchemaParser._validate_tools(data["tools"])
    88|         try:
    89|             schema = MCISchema(**data)
    90|         except ValidationError as e:
    91|             raise SchemaParserError(f"Schema validation failed: {e}") from e
    92|         return schema
    93|     @staticmethod
    94|     def _validate_schema_version(version: str) -> None:
    95|         """
    96|         Validate schema version compatibility.
    97|         Ensures the schema version is supported by this parser implementation.
    98|         Args:
    99|             version: Schema version string
   100|         Raises:
   101|             SchemaParserError: If the version is not supported
   102|         """
   103|         if not isinstance(version, str):
   104|             raise SchemaParserError(
   105|                 f"Schema version must be a string, got {type(version).__name__}"
   106|             )
   107|         if version not in SUPPORTED_SCHEMA_VERSIONS:
   108|             raise SchemaParserError(
   109|                 f"Unsupported schema version '{version}'. "
   110|                 f"Supported versions: {', '.join(SUPPORTED_SCHEMA_VERSIONS)}"
   111|             )

# --- HUNK 2: Lines 129-181 ---
   129|             if "execution" not in tool:
   130|                 raise SchemaParserError(
   131|                     f"Tool at index {idx} ('{tool.get('name', 'unknown')}') missing required field 'execution'"
   132|                 )
   133|             execution = tool["execution"]
   134|             if not isinstance(execution, dict):
   135|                 raise SchemaParserError(
   136|                     f"Tool '{tool['name']}' execution must be a dictionary, got {type(execution).__name__}"
   137|                 )
   138|             try:
   139|                 SchemaParser._build_execution_config(execution)
   140|             except SchemaParserError as e:
   141|                 raise SchemaParserError(
   142|                     f"Tool '{tool['name']}' has invalid execution config: {e}"
   143|                 ) from e
   144|     @staticmethod
   145|     def _build_execution_config(execution: dict[str, Any]) -> ExecutionConfig:
   146|         """
   147|         Build the appropriate execution config based on type.
   148|         Determines the execution type and creates the corresponding
   149|         ExecutionConfig subclass (HTTP, CLI, File, or Text).
   150|         Args:
   151|             execution: Dictionary containing execution configuration
   152|         Returns:
   153|             Appropriate ExecutionConfig subclass instance
   154|         Raises:
   155|             SchemaParserError: If the execution type is missing, invalid,
   156|                              or the configuration is invalid for that type
   157|         """
   158|         if "type" not in execution:
   159|             raise SchemaParserError("Missing required field 'type' in execution config")
   160|         exec_type = execution["type"]
   161|         if not isinstance(exec_type, str):
   162|             raise SchemaParserError(
   163|                 f"Execution type must be a string, got {type(exec_type).__name__}"
   164|             )
   165|         type_map = {
   166|             ExecutionType.HTTP.value: HTTPExecutionConfig,
   167|             ExecutionType.CLI.value: CLIExecutionConfig,
   168|             ExecutionType.FILE.value: FileExecutionConfig,
   169|             ExecutionType.TEXT.value: TextExecutionConfig,
   170|         }
   171|         if exec_type not in type_map:
   172|             valid_types = ", ".join(type_map.keys())
   173|             raise SchemaParserError(
   174|                 f"Invalid execution type '{exec_type}'. Valid types: {valid_types}"
   175|             )
   176|         config_class = type_map[exec_type]
   177|         try:
   178|             config = config_class(**execution)
   179|         except ValidationError as e:
   180|             raise SchemaParserError(f"Invalid {exec_type} execution config: {e}") from e
   181|         return config


# ====================================================================
# FILE: src/mcipy/templating.py
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 7-194 ---
     7| """
     8| import re
     9| from typing import Any
    10| class TemplateError(Exception):
    11|     """Exception raised when template processing fails."""
    12|     pass
    13| class TemplateEngine:
    14|     """
    15|     Template engine for processing MCI templates.
    16|     Handles both basic placeholder substitution and advanced templating
    17|     features like loops and conditional blocks. The engine supports:
    18|     - Basic placeholders: {{props.propertyName}}, {{env.VAR_NAME}}
    19|     - For loops: @for(i in range(0, 5)) ... @endfor
    20|     - Foreach loops: @foreach(item in items) ... @endforeach
    21|     - Control blocks: @if(condition) ... @elseif(condition) ... @else ... @endif
    22|     """
    23|     def render_basic(self, template: str, context: dict[str, Any]) -> str:
    24|         """
    25|         Perform basic placeholder substitution.
    26|         Replaces placeholders like {{props.propertyName}} and {{env.VAR_NAME}}
    27|         with their values from the context.
    28|         Args:
    29|             template: The template string containing placeholders
    30|             context: Dictionary with 'props', 'env', and 'input' keys
    31|         Returns:
    32|             The template with all placeholders replaced
    33|         Raises:
    34|             TemplateError: If a placeholder cannot be resolved
    35|         """
    36|         pattern = r"\{\{([^}]+)\}\}"
    37|         def replace_placeholder(match: re.Match[str]) -> str:
    38|             path = match.group(1).strip()
    39|             try:
    40|                 value = self._resolve_placeholder(path, context)
    41|                 return str(value)
    42|             except Exception as e:
    43|                 raise TemplateError(f"Failed to resolve placeholder '{{{{{path}}}}}: {e}") from e
    44|         return re.sub(pattern, replace_placeholder, template)
    45|     def render_advanced(self, template: str, context: dict[str, Any]) -> str:
    46|         """
    47|         Perform advanced templating with loops and control blocks.
    48|         Processes @for, @foreach, and @if/@elseif/@else/@endif blocks
    49|         in addition to basic placeholder substitution.
    50|         Args:
    51|             template: The template string with advanced directives
    52|             context: Dictionary with 'props', 'env', and 'input' keys
    53|         Returns:
    54|             The fully processed template
    55|         Raises:
    56|             TemplateError: If template processing fails
    57|         """
    58|         result = self._parse_for_loop(template, context)
    59|         result = self._parse_foreach_loop(result, context)
    60|         result = self._parse_control_blocks(result, context)
    61|         result = self.render_basic(result, context)
    62|         return result
    63|     def _resolve_placeholder(self, path: str, context: dict[str, Any]) -> Any:
    64|         """
    65|         Resolve a dot-notation path in the context.
    66|         Supports paths like 'props.location', 'env.API_KEY', 'input.user.name'
    67|         Args:
    68|             path: Dot-notation path to resolve
    69|             context: Context dictionary
    70|         Returns:
    71|             The value at the specified path
    72|         Raises:
    73|             TemplateError: If the path cannot be resolved
    74|         """
    75|         parts = path.split(".")
    76|         current = context
    77|         for i, part in enumerate(parts):
    78|             if not isinstance(current, dict):
    79|                 raise TemplateError(
    80|                     f"Cannot access '{part}' on non-dict value at '{'.'.join(parts[:i])}'"
    81|                 )
    82|             if part not in current:
    83|                 raise TemplateError(f"Path '{path}' not found in context (missing '{part}')")
    84|             current = current[part]
    85|         return current
    86|     def _replace_placeholders_with_whitespace_support(self, content: str, replacements: dict[str, str]) -> str:
    87|         """
    88|         Replace placeholders in content, supporting optional whitespace around variable names.
    89|         Args:
    90|             content: The content containing placeholders
    91|             replacements: Dictionary mapping variable paths to replacement values
    92|         Returns:
    93|             Content with placeholders replaced
    94|         """
    95|         result = content
    96|         for var_path, replacement in replacements.items():
    97|             pattern = rf"\{{\{{\s*{re.escape(var_path)}\s*\}}\}}"
    98|             result = re.sub(pattern, replacement, result)
    99|         return result
   100|     def _parse_for_loop(self, content: str, context: dict[str, Any]) -> str:
   101|         """
   102|         Parse and process @for loops.
   103|         Supports syntax: @for(variable in range(start, end))...@endfor
   104|         Args:
   105|             content: Template content containing @for loops
   106|             context: Context dictionary
   107|         Returns:
   108|             Content with @for loops expanded
   109|         """
   110|         pattern = r"@for\s*\(\s*(\w+)\s+in\s+range\s*\(\s*(\d+)\s*,\s*(\d+)\s*\)\s*\)(.*?)@endfor"
   111|         def replace_for_loop(match: re.Match[str]) -> str:
   112|             var_name = match.group(1)
   113|             start = int(match.group(2))
   114|             end = int(match.group(3))
   115|             body = match.group(4)
   116|             result = []
   117|             for i in range(start, end):
   118|                 loop_context = context.copy()
   119|                 loop_context[var_name] = i
   120|                 processed_body = body
   121|                 replacements = {var_name: str(i)}
   122|                 processed_body = self._replace_placeholders_with_whitespace_support(processed_body, replacements)
   123|                 result.append(processed_body)
   124|             return "".join(result)
   125|         return re.sub(pattern, replace_for_loop, content, flags=re.DOTALL)
   126|     def _parse_foreach_loop(self, content: str, context: dict[str, Any]) -> str:
   127|         """
   128|         Parse and process @foreach loops.
   129|         Supports syntax: @foreach(item in items)...@endforeach
   130|         where 'items' is a path in the context (e.g., 'props.myArray')
   131|         Args:
   132|             content: Template content containing @foreach loops
   133|             context: Context dictionary
   134|         Returns:
   135|             Content with @foreach loops expanded
   136|         """
   137|         pattern = r"@foreach\s*\(\s*(\w+)\s+in\s+([\w.]+)\s*\)(.*?)@endforeach"
   138|         def replace_foreach_loop(match: re.Match[str]) -> str:
   139|             var_name = match.group(1)
   140|             path = match.group(2)
   141|             body = match.group(3)
   142|             try:
   143|                 items = self._resolve_placeholder(path, context)
   144|             except TemplateError as e:
   145|                 raise TemplateError(f"Failed to resolve foreach path '{path}': {e}") from e
   146|             if not isinstance(items, (list, dict)):
   147|                 raise TemplateError(
   148|                     f"@foreach requires an array or object, got {type(items).__name__}"
   149|                 )
   150|             result = []
   151|             if isinstance(items, list):
   152|                 for item in items:
   153|                     loop_context = context.copy()
   154|                     loop_context[var_name] = item
   155|                     processed_body = body
   156|                     if isinstance(item, dict):
   157|                         replacements = {}
   158|                         for key, value in item.items():
   159|                             replacements[f"{var_name}.{key}"] = str(value)
   160|                         processed_body = self._replace_placeholders_with_whitespace_support(processed_body, replacements)
   161|                     else:
   162|                         replacements = {var_name: str(item)}
   163|                         processed_body = self._replace_placeholders_with_whitespace_support(processed_body, replacements)
   164|                     result.append(processed_body)
   165|             else:  # dict
   166|                 for key, value in items.items():
   167|                     loop_context = context.copy()
   168|                     loop_context[var_name] = value
   169|                     processed_body = body
   170|                     replacements = {
   171|                         var_name: str(value),
   172|                         f"{var_name}.key": str(key)
   173|                     }
   174|                     processed_body = self._replace_placeholders_with_whitespace_support(processed_body, replacements)
   175|                     result.append(processed_body)
   176|             return "".join(result)
   177|         return re.sub(pattern, replace_foreach_loop, content, flags=re.DOTALL)
   178|     def _parse_control_blocks(self, content: str, context: dict[str, Any]) -> str:
   179|         """
   180|         Parse and process @if/@elseif/@else/@endif control blocks.
   181|         Supports syntax:
   182|         @if(condition)...@elseif(condition)...@else...@endif
   183|         Conditions can be:
   184|         - path.to.value (truthy check)
   185|         - path.to.value == "value" (equality)
   186|         - path.to.value != "value" (inequality)
   187|         - path.to.value > number (greater than)
   188|         - path.to.value < number (less than)
   189|         Args:
   190|             content: Template content containing control blocks
   191|             context: Context dictionary
   192|         Returns:
   193|             Content with control blocks evaluated
   194|         """


# ====================================================================
# FILE: src/mcipy/tool_manager.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-117 ---
     1| """
     2| Tool manager for MCI tools.
     3| This module provides the ToolManager class that manages tool definitions
     4| from an MCISchema, including retrieval, filtering, and execution.
     5| """
     6| from typing import Any
     7| from .executors import ExecutorFactory
     8| from .models import ExecutionResult, MCISchema, Tool
     9| class ToolManagerError(Exception):
    10|     """Exception raised for tool manager errors."""
    11|     pass
    12| class ToolManager:
    13|     """
    14|     Manager for MCI tool definitions.
    15|     Provides functionality to retrieve, filter, and execute tools from an
    16|     MCISchema. Handles input validation and dispatches execution to the
    17|     appropriate executor based on tool configuration.
    18|     """
    19|     def __init__(self, schema: MCISchema):
    20|         """
    21|         Initialize the ToolManager with an MCISchema.
    22|         Args:
    23|             schema: MCISchema containing tool definitions
    24|         """
    25|         self.schema = schema
    26|         self._tool_map: dict[str, Tool] = {tool.name: tool for tool in schema.tools}
    27|     def get_tool(self, name: str) -> Tool | None:
    28|         """
    29|         Retrieve a tool by name (case-sensitive).
    30|         Args:
    31|             name: Name of the tool to retrieve
    32|         Returns:
    33|             Tool object if found, None otherwise
    34|         """
    35|         return self._tool_map.get(name)
    36|     def list_tools(self) -> list[Tool]:
    37|         """
    38|         List all available tools.
    39|         Returns:
    40|             List of all Tool objects in the schema
    41|         """
    42|         return self.schema.tools
    43|     def filter_tools(
    44|         self, only: list[str] | None = None, without: list[str] | None = None
    45|     ) -> list[Tool]:
    46|         """
    47|         Filter tools by inclusion/exclusion lists.
    48|         If both 'only' and 'without' are provided, 'only' takes precedence
    49|         (i.e., only tools in the 'only' list but not in 'without' are returned).
    50|         Args:
    51|             only: List of tool names to include (if None, all tools are considered)
    52|             without: List of tool names to exclude (if None, no tools are excluded)
    53|         Returns:
    54|             Filtered list of Tool objects
    55|         """
    56|         tools = self.schema.tools
    57|         if only is not None:
    58|             only_set = set(only)
    59|             tools = [tool for tool in tools if tool.name in only_set]
    60|         if without is not None:
    61|             without_set = set(without)
    62|             tools = [tool for tool in tools if tool.name not in without_set]
    63|         return tools
    64|     def execute(
    65|         self,
    66|         tool_name: str,
    67|         properties: dict[str, Any] | None = None,
    68|         env_vars: dict[str, Any] | None = None,
    69|     ) -> ExecutionResult:
    70|         """
    71|         Execute a tool by name with the provided properties.
    72|         Validates the tool exists, validates input properties against the tool's
    73|         input schema, and executes the tool using the appropriate executor.
    74|         Args:
    75|             tool_name: Name of the tool to execute
    76|             properties: Properties/parameters to pass to the tool (default: empty dict)
    77|             env_vars: Environment variables for template context (default: empty dict)
    78|         Returns:
    79|             ExecutionResult with success/error status and content
    80|         Raises:
    81|             ToolManagerError: If tool not found or properties validation fails
    82|         """
    83|         if properties is None:
    84|             properties = {}
    85|         if env_vars is None:
    86|             env_vars = {}
    87|         tool = self.get_tool(tool_name)
    88|         if tool is None:
    89|             raise ToolManagerError(f"Tool not found: {tool_name}")
    90|         if tool.inputSchema is not None and tool.inputSchema:
    91|             self._validate_input_properties(tool, properties)
    92|         context = {
    93|             "props": properties,
    94|             "env": env_vars,
    95|             "input": properties,  # Alias for backward compatibility
    96|         }
    97|         executor = ExecutorFactory.get_executor(tool.execution.type)
    98|         result = executor.execute(tool.execution, context)
    99|         return result
   100|     def _validate_input_properties(self, tool: Tool, properties: dict[str, Any]) -> None:
   101|         """
   102|         Validate properties against the tool's input schema.
   103|         Checks that all required properties are provided.
   104|         Args:
   105|             tool: Tool object with inputSchema
   106|             properties: Properties to validate
   107|         Raises:
   108|             ToolManagerError: If required properties are missing
   109|         """
   110|         input_schema = tool.inputSchema
   111|         if not input_schema:
   112|             return
   113|         required = input_schema.get("required", [])
   114|         if required:
   115|             missing_props = [prop for prop in required if prop not in properties]
   116|             if missing_props:
   117|                 raise ToolManagerError(

