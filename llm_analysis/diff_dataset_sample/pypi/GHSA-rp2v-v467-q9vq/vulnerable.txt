# ====================================================================
# FILE: guarddog/cli.py
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-93 ---
     1| """ PyPI Package Malware Scanner
     2| CLI command that scans a PyPI package version for user-specified malware flags.
     3| Includes rules based on package registry metadata and source code analysis.
     4| """
     5| import re
     6| import sys
     7| import click
     8| from termcolor import colored
     9| from .analyzer.analyzer import Analyzer
    10| from .scanners.package_scanner import PackageScanner
    11| from .scanners.project_scanner import RequirementsScanner
    12| analyzer = Analyzer()
    13| ALL_RULES = analyzer.sourcecode_ruleset | analyzer.metadata_ruleset
    14| @click.group
    15| def cli():
    16|     """Guard Dog cli tool to detect PyPI malware"""
    17|     pass
    18| @cli.command("verify")
    19| @click.argument("path")
    20| @click.option("--json", default=False, is_flag=True, help="Dump the output as JSON to standard out")
    21| def verify(path, json):
    22|     """Verify a requirements.txt file
    23|     Args:
    24|         path (str): path to requirements.txt file
    25|     """
    26|     scanner = RequirementsScanner()
    27|     results = scanner.scan_local(path)
    28|     for result in results:
    29|         identifier = result['dependency'] if result['version'] is None else f"{result['dependency']} version {result['version']}"
    30|         if not json:
    31|             print_scan_results(result.get('result'), identifier)
    32|     if json:
    33|         import json as js
    34|         print(js.dumps(results))
    35| @cli.command("scan")
    36| @click.argument("identifier")
    37| @click.option("-v", "--version", default=None, help="Specify a version to scan")
    38| @click.option("-r", "--rules", multiple=True, type=click.Choice(ALL_RULES, case_sensitive=False))
    39| @click.option("-x", "--exclude-rules", multiple=True, type=click.Choice(ALL_RULES, case_sensitive=False))
    40| @click.option("--json", default=False, is_flag=True, help="Dump the output as JSON to standard out")
    41| def scan(identifier, version, rules, exclude_rules, json):
    42|     """Scan a package
    43|     Args:
    44|         identifier (str): name or path to the package
    45|         version (str): version of the package (ex. 1.0.0), defaults to most recent
    46|         rules (str): specific rules to run, defaults to all
    47|     """
    48|     rule_param = None
    49|     if len(rules) != 0:
    50|         rule_param = rules
    51|     if len(exclude_rules):
    52|         rule_param = ALL_RULES - set(exclude_rules)
    53|     scanner = PackageScanner()
    54|     results = {}
    55|     if is_local_package(identifier):
    56|         results = scanner.scan_local(identifier, rule_param)
    57|     else:
    58|         try:
    59|             results = scanner.scan_remote(identifier, version, rule_param)
    60|         except Exception as e:
    61|             sys.stderr.write("\n")
    62|             sys.stderr.write(str(e))
    63|             sys.exit()
    64|     if json:
    65|         import json as js
    66|         print(js.dumps(results))
    67|     else:
    68|         print_scan_results(results, identifier)
    69| def is_local_package(input):
    70|     identifier_is_path = re.search(r"(.{0,2}\/)+.+", input)
    71|     return identifier_is_path or input.endswith('.tar.gz')
    72| def print_scan_results(results, identifier):
    73|     num_issues = results.get('issues')
    74|     if num_issues == 0:
    75|         print("Found " + colored('0 potentially malicious indicators', 'green', attrs=['bold']) + " scanning " + colored(identifier, None, attrs=['bold']))
    76|         print()
    77|         return
    78|     print("Found " + colored(str(num_issues) + ' potentially malicious indicators', 'red', attrs=['bold']) + " in " + colored(identifier, None, attrs=['bold']))
    79|     print()
    80|     results = results.get('results', [])
    81|     for finding in results:
    82|         description = results[finding]
    83|         if type(description) == str: # package metadata
    84|             print(colored(finding, None, attrs=['bold']) + ': ' + description)
    85|             print()
    86|         elif type(description) == list: # semgrep rule result:
    87|             source_code_findings = description
    88|             print(colored(finding, None, attrs=['bold']) + ': found ' + str(len(source_code_findings)) + ' source code matches')
    89|             for finding in source_code_findings:
    90|                 print('  * ' + finding['message'] + ' at ' + finding['location'] + '\n    ' + format_code_line_for_output(finding['code']))
    91|             print()
    92| def format_code_line_for_output(code):
    93|     return '    ' + colored(code.strip().replace('\n', '\n    ').replace('\t', '  '), None, 'on_red', attrs=['bold'])


# ====================================================================
# FILE: guarddog/scanners/package_scanner.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-56 ---
     1| import json
     2| import os
     3| import shutil
     4| import sys
     5| import tarfile
     6| import tempfile
     7| import requests
     8| from guarddog.analyzer.analyzer import Analyzer
     9| from guarddog.scanners.scanner import Scanner
    10| from guarddog.utils.package_info import get_package_info
    11| class PackageScanner(Scanner):
    12|     """
    13|     Scans package for attack vectors based on source code and metadata rules
    14|     Attributes:
    15|         analyzer (Analyzer): Analyzer for source code and metadata rules
    16|     """
    17|     def __init__(self) -> None:
    18|         self.analyzer = Analyzer()
    19|         super(Scanner)
    20|     def scan_local(self, path, rules=None) -> dict:
    21|         """
    22|         Scans local package
    23|         Args:
    24|             path (str): path to package
    25|             rules (set, optional): Set of rule names to use. Defaults to all rules.
    26|         Raises:
    27|             Exception: Analyzer exception
    28|         Returns:
    29|             dict: Analyzer output with rules to results mapping
    30|         """
    31|         if rules is not None:
    32|             rules = set(rules)
    33|         if os.path.exists(path):
    34|             if path.endswith('.tar.gz'):
    35|                 with tempfile.TemporaryDirectory() as tmpdirname:
    36|                     tarfile.open(path).extractall(tmpdirname)
    37|                     return self.analyzer.analyze_sourcecode(tmpdirname, rules=rules)
    38|             elif os.path.isdir(path):
    39|                 return self.analyzer.analyze_sourcecode(path, rules=rules)
    40|         else:
    41|             raise Exception(f"Path {path} does not exist.")
    42|     def _scan_remote(self, name, base_dir, version=None, rules=None, write_package_info=False):
    43|         directory = os.path.join(os.path.dirname(os.path.abspath(__file__)), base_dir)
    44|         file_path = os.path.join(directory, name)
    45|         self.download_package(name, directory, version)
    46|         package_info = get_package_info(name)
    47|         results = self.analyzer.analyze(file_path, package_info, rules)
    48|         if write_package_info:
    49|             suffix = f"{name}-{version}" if version is not None else name
    50|             with open(os.path.join(results["path"], f'package_info-{suffix}.json'), "w") as file:
    51|                 file.write(json.dumps(package_info))
    52|         return results
    53|     def scan_remote(self, name, version=None, rules=None, base_dir=None, write_package_info=False):
    54|         """
    55|         Scans a remote package
    56|         Args:

