# ====================================================================
# FILE: guarddog/cli.py
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-104 ---
     1| """ PyPI Package Malware Scanner
     2| CLI command that scans a PyPI package version for user-specified malware flags.
     3| Includes rules based on package registry metadata and source code analysis.
     4| """
     5| import re
     6| import sys
     7| import click
     8| from termcolor import colored
     9| from .analyzer.analyzer import Analyzer
    10| from .scanners.package_scanner import PackageScanner
    11| from .scanners.project_scanner import RequirementsScanner
    12| analyzer = Analyzer()
    13| ALL_RULES = analyzer.sourcecode_ruleset | analyzer.metadata_ruleset
    14| EXIT_CODE_ISSUES_FOUND = 1
    15| @click.group
    16| def cli():
    17|     """Guard Dog cli tool to detect PyPI malware"""
    18|     pass
    19| @cli.command("verify")
    20| @click.argument("path")
    21| @click.option("--json", default=False, is_flag=True, help="Dump the output as JSON to standard out")
    22| @click.option("--exit-non-zero-on-finding", default=False, is_flag=True, help="Exit with a non-zero status code if at least one issue is identified")
    23| def verify(path, json, exit_non_zero_on_finding):
    24|     """Verify a requirements.txt file
    25|     Args:
    26|         path (str): path to requirements.txt file
    27|     """
    28|     scanner = RequirementsScanner()
    29|     results = scanner.scan_local(path)
    30|     for result in results:
    31|         identifier = result['dependency'] if result['version'] is None else f"{result['dependency']} version {result['version']}"
    32|         if not json:
    33|             print_scan_results(result.get('result'), identifier)
    34|     if json:
    35|         import json as js
    36|         print(js.dumps(results))
    37|     if exit_non_zero_on_finding:
    38|         exit_with_status_code(results)
    39| @cli.command("scan")
    40| @click.argument("identifier")
    41| @click.option("-v", "--version", default=None, help="Specify a version to scan")
    42| @click.option("-r", "--rules", multiple=True, type=click.Choice(ALL_RULES, case_sensitive=False))
    43| @click.option("-x", "--exclude-rules", multiple=True, type=click.Choice(ALL_RULES, case_sensitive=False))
    44| @click.option("--json", default=False, is_flag=True, help="Dump the output as JSON to standard out")
    45| @click.option("--exit-non-zero-on-finding", default=False, is_flag=True, help="Exit with a non-zero status code if at least one issue is identified")
    46| def scan(identifier, version, rules, exclude_rules, json, exit_non_zero_on_finding):
    47|     """Scan a package
    48|     Args:
    49|         identifier (str): name or path to the package
    50|         version (str): version of the package (ex. 1.0.0), defaults to most recent
    51|         rules (str): specific rules to run, defaults to all
    52|     """
    53|     rule_param = None
    54|     if len(rules) != 0:
    55|         rule_param = rules
    56|     if len(exclude_rules):
    57|         rule_param = ALL_RULES - set(exclude_rules)
    58|     scanner = PackageScanner()
    59|     results = {}
    60|     if is_local_package(identifier):
    61|         results = scanner.scan_local(identifier, rule_param)
    62|     else:
    63|         try:
    64|             results = scanner.scan_remote(identifier, version, rule_param)
    65|         except Exception as e:
    66|             sys.stderr.write("\n")
    67|             sys.stderr.write(str(e))
    68|             sys.exit()
    69|     if json:
    70|         import json as js
    71|         print(js.dumps(results))
    72|     else:
    73|         print_scan_results(results, identifier)
    74|     if exit_non_zero_on_finding:
    75|         exit_with_status_code(results)
    76| def is_local_package(input):
    77|     identifier_is_path = re.search(r"(.{0,2}\/)+.+", input)
    78|     return identifier_is_path or input.endswith('.tar.gz')
    79| def print_scan_results(results, identifier):
    80|     num_issues = results.get('issues')
    81|     if num_issues == 0:
    82|         print("Found " + colored('0 potentially malicious indicators', 'green', attrs=['bold']) + " scanning " + colored(identifier, None, attrs=['bold']))
    83|         print()
    84|         return
    85|     print("Found " + colored(str(num_issues) + ' potentially malicious indicators', 'red', attrs=['bold']) + " in " + colored(identifier, None, attrs=['bold']))
    86|     print()
    87|     results = results.get('results', [])
    88|     for finding in results:
    89|         description = results[finding]
    90|         if type(description) == str: # package metadata
    91|             print(colored(finding, None, attrs=['bold']) + ': ' + description)
    92|             print()
    93|         elif type(description) == list: # semgrep rule result:
    94|             source_code_findings = description
    95|             print(colored(finding, None, attrs=['bold']) + ': found ' + str(len(source_code_findings)) + ' source code matches')
    96|             for finding in source_code_findings:
    97|                 print('  * ' + finding['message'] + ' at ' + finding['location'] + '\n    ' + format_code_line_for_output(finding['code']))
    98|             print()
    99| def format_code_line_for_output(code):
   100|     return '    ' + colored(code.strip().replace('\n', '\n    ').replace('\t', '  '), None, 'on_red', attrs=['bold'])
   101| def exit_with_status_code(results):
   102|     num_issues = results.get('issues', 0)
   103|     if num_issues > 0:
   104|         exit(EXIT_CODE_ISSUES_FOUND)


# ====================================================================
# FILE: guarddog/scanners/package_scanner.py
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-56 ---
     1| import json
     2| import os
     3| import shutil
     4| import sys
     5| import tarsafe
     6| import tempfile
     7| import requests
     8| from guarddog.analyzer.analyzer import Analyzer
     9| from guarddog.scanners.scanner import Scanner
    10| from guarddog.utils.package_info import get_package_info
    11| class PackageScanner(Scanner):
    12|     """
    13|     Scans package for attack vectors based on source code and metadata rules
    14|     Attributes:
    15|         analyzer (Analyzer): Analyzer for source code and metadata rules
    16|     """
    17|     def __init__(self) -> None:
    18|         self.analyzer = Analyzer()
    19|         super(Scanner)
    20|     def scan_local(self, path, rules=None) -> dict:
    21|         """
    22|         Scans local package
    23|         Args:
    24|             path (str): path to package
    25|             rules (set, optional): Set of rule names to use. Defaults to all rules.
    26|         Raises:
    27|             Exception: Analyzer exception
    28|         Returns:
    29|             dict: Analyzer output with rules to results mapping
    30|         """
    31|         if rules is not None:
    32|             rules = set(rules)
    33|         if os.path.exists(path):
    34|             if path.endswith('.tar.gz'):
    35|                 with tempfile.TemporaryDirectory() as tmpdirname:
    36|                     tarsafe.open(path).extractall(tmpdirname)
    37|                     return self.analyzer.analyze_sourcecode(tmpdirname, rules=rules)
    38|             elif os.path.isdir(path):
    39|                 return self.analyzer.analyze_sourcecode(path, rules=rules)
    40|         else:
    41|             raise Exception(f"Path {path} does not exist.")
    42|     def _scan_remote(self, name, base_dir, version=None, rules=None, write_package_info=False):
    43|         directory = os.path.join(os.path.dirname(os.path.abspath(__file__)), base_dir)
    44|         file_path = os.path.join(directory, name)
    45|         self.download_package(name, directory, version)
    46|         package_info = get_package_info(name)
    47|         results = self.analyzer.analyze(file_path, package_info, rules)
    48|         if write_package_info:
    49|             suffix = f"{name}-{version}" if version is not None else name
    50|             with open(os.path.join(results["path"], f'package_info-{suffix}.json'), "w") as file:
    51|                 file.write(json.dumps(package_info))
    52|         return results
    53|     def scan_remote(self, name, version=None, rules=None, base_dir=None, write_package_info=False):
    54|         """
    55|         Scans a remote package
    56|         Args:

