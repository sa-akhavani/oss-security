--- a/guarddog/cli.py
+++ b/guarddog/cli.py
@@ -4,53 +4,48 @@
 """
 import re
 import sys
 import click
 from termcolor import colored
 from .analyzer.analyzer import Analyzer
 from .scanners.package_scanner import PackageScanner
 from .scanners.project_scanner import RequirementsScanner
 analyzer = Analyzer()
 ALL_RULES = analyzer.sourcecode_ruleset | analyzer.metadata_ruleset
-EXIT_CODE_ISSUES_FOUND = 1
 @click.group
 def cli():
     """Guard Dog cli tool to detect PyPI malware"""
     pass
 @cli.command("verify")
 @click.argument("path")
 @click.option("--json", default=False, is_flag=True, help="Dump the output as JSON to standard out")
-@click.option("--exit-non-zero-on-finding", default=False, is_flag=True, help="Exit with a non-zero status code if at least one issue is identified")
-def verify(path, json, exit_non_zero_on_finding):
+def verify(path, json):
     """Verify a requirements.txt file
     Args:
         path (str): path to requirements.txt file
     """
     scanner = RequirementsScanner()
     results = scanner.scan_local(path)
     for result in results:
         identifier = result['dependency'] if result['version'] is None else f"{result['dependency']} version {result['version']}"
         if not json:
             print_scan_results(result.get('result'), identifier)
     if json:
         import json as js
         print(js.dumps(results))
-    if exit_non_zero_on_finding:
-        exit_with_status_code(results)
 @cli.command("scan")
 @click.argument("identifier")
 @click.option("-v", "--version", default=None, help="Specify a version to scan")
 @click.option("-r", "--rules", multiple=True, type=click.Choice(ALL_RULES, case_sensitive=False))
 @click.option("-x", "--exclude-rules", multiple=True, type=click.Choice(ALL_RULES, case_sensitive=False))
 @click.option("--json", default=False, is_flag=True, help="Dump the output as JSON to standard out")
-@click.option("--exit-non-zero-on-finding", default=False, is_flag=True, help="Exit with a non-zero status code if at least one issue is identified")
-def scan(identifier, version, rules, exclude_rules, json, exit_non_zero_on_finding):
+def scan(identifier, version, rules, exclude_rules, json):
     """Scan a package
     Args:
         identifier (str): name or path to the package
         version (str): version of the package (ex. 1.0.0), defaults to most recent
         rules (str): specific rules to run, defaults to all
     """
     rule_param = None
     if len(rules) != 0:
         rule_param = rules
     if len(exclude_rules):
@@ -64,22 +59,20 @@
             results = scanner.scan_remote(identifier, version, rule_param)
         except Exception as e:
             sys.stderr.write("\n")
             sys.stderr.write(str(e))
             sys.exit()
     if json:
         import json as js
         print(js.dumps(results))
     else:
         print_scan_results(results, identifier)
-    if exit_non_zero_on_finding:
-        exit_with_status_code(results)
 def is_local_package(input):
     identifier_is_path = re.search(r"(.{0,2}\/)+.+", input)
     return identifier_is_path or input.endswith('.tar.gz')
 def print_scan_results(results, identifier):
     num_issues = results.get('issues')
     if num_issues == 0:
         print("Found " + colored('0 potentially malicious indicators', 'green', attrs=['bold']) + " scanning " + colored(identifier, None, attrs=['bold']))
         print()
         return
     print("Found " + colored(str(num_issues) + ' potentially malicious indicators', 'red', attrs=['bold']) + " in " + colored(identifier, None, attrs=['bold']))
@@ -91,14 +84,10 @@
             print(colored(finding, None, attrs=['bold']) + ': ' + description)
             print()
         elif type(description) == list: # semgrep rule result:
             source_code_findings = description
             print(colored(finding, None, attrs=['bold']) + ': found ' + str(len(source_code_findings)) + ' source code matches')
             for finding in source_code_findings:
                 print('  * ' + finding['message'] + ' at ' + finding['location'] + '\n    ' + format_code_line_for_output(finding['code']))
             print()
 def format_code_line_for_output(code):
     return '    ' + colored(code.strip().replace('\n', '\n    ').replace('\t', '  '), None, 'on_red', attrs=['bold'])
-def exit_with_status_code(results):
-    num_issues = results.get('issues', 0)
-    if num_issues > 0:
-        exit(EXIT_CODE_ISSUES_FOUND)

--- a/guarddog/scanners/package_scanner.py
+++ b/guarddog/scanners/package_scanner.py
@@ -1,15 +1,15 @@
 import json
 import os
 import shutil
 import sys
-import tarsafe
+import tarfile
 import tempfile
 import requests
 from guarddog.analyzer.analyzer import Analyzer
 from guarddog.scanners.scanner import Scanner
 from guarddog.utils.package_info import get_package_info
 class PackageScanner(Scanner):
     """
     Scans package for attack vectors based on source code and metadata rules
     Attributes:
         analyzer (Analyzer): Analyzer for source code and metadata rules
@@ -26,21 +26,21 @@
         Raises:
             Exception: Analyzer exception
         Returns:
             dict: Analyzer output with rules to results mapping
         """
         if rules is not None:
             rules = set(rules)
         if os.path.exists(path):
             if path.endswith('.tar.gz'):
                 with tempfile.TemporaryDirectory() as tmpdirname:
-                    tarsafe.open(path).extractall(tmpdirname)
+                    tarfile.open(path).extractall(tmpdirname)
                     return self.analyzer.analyze_sourcecode(tmpdirname, rules=rules)
             elif os.path.isdir(path):
                 return self.analyzer.analyze_sourcecode(path, rules=rules)
         else:
             raise Exception(f"Path {path} does not exist.")
     def _scan_remote(self, name, base_dir, version=None, rules=None, write_package_info=False):
         directory = os.path.join(os.path.dirname(os.path.abspath(__file__)), base_dir)
         file_path = os.path.join(directory, name)
         self.download_package(name, directory, version)
         package_info = get_package_info(name)
