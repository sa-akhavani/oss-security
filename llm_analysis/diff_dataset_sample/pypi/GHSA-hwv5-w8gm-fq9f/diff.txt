--- a/setup.py
+++ b/setup.py
@@ -4,21 +4,21 @@
 from setuptools import setup, find_packages
 here = os.path.abspath(os.path.dirname(__file__))
 with open(os.path.join(here, "README.rst"), encoding="utf-8") as f:
     long_description = f.read()
 install_requires = [
     'flask~=0.12',
     'flask-cors~=3.0.3',
 ]
 setup(
     name="xmpp-http-upload",
-    version="0.4.0",
+    version="0.3.0",
     description="Flask-based HTTP service to handle XMPP HTTP upload requests from Prosody mod_http_upload_external",
     long_description=long_description,
     url="https://github.com/horazont/xmpp-http-upload",
     author="Jonas Wielicki",
     author_email="jonas@wielicki.name",
     license="GPLv3+",
     classifiers=[
         "Development Status :: 3 - Alpha",
         "Intended Audience :: Developers",
         "Operating System :: POSIX",

--- a/xhu.py
+++ b/xhu.py
@@ -1,39 +1,45 @@
 import contextlib
 import errno
 import fnmatch
 import json
 import hashlib
 import hmac
 import pathlib
 import typing
 import flask
-import werkzeug.exceptions
 app = flask.Flask("xmpp-http-upload")
 app.config.from_envvar("XMPP_HTTP_UPLOAD_CONFIG")
 application = app
 if app.config['ENABLE_CORS']:
     from flask_cors import CORS
     CORS(app)
-def get_paths(root: str, sub_path: str) \
-        -> typing.Tuple[pathlib.Path, pathlib.Path]:
-    base_path = flask.safe_join(root, sub_path)
-    data_file = pathlib.Path(base_path + ".data")
-    metadata_file = pathlib.Path(base_path + ".meta")
+def sanitized_join(path: str, root: pathlib.Path) -> pathlib.Path:
+    result = (root / path).absolute()
+    if not str(result).startswith(str(root) + "/"):
+        raise ValueError("resulting path is outside root")
+    return result
+def get_paths(base_path: pathlib.Path):
+    data_file = pathlib.Path(str(base_path) + ".data")
+    metadata_file = pathlib.Path(str(base_path) + ".meta")
     return data_file, metadata_file
 def load_metadata(metadata_file):
     with metadata_file.open("r") as f:
         return json.load(f)
-def get_info(path: str) -> typing.Tuple[
+def get_info(path: str, root: pathlib.Path) -> typing.Tuple[
         pathlib.Path,
         dict]:
-    data_file, metadata_file = get_paths(app.config["DATA_ROOT"], path)
+    dest_path = sanitized_join(
+        path,
+        pathlib.Path(app.config["DATA_ROOT"]),
+    )
+    data_file, metadata_file = get_paths(dest_path)
     return data_file, load_metadata(metadata_file)
 @contextlib.contextmanager
 def write_file(at: pathlib.Path):
     with at.open("xb") as f:
         try:
             yield f
         except:  # NOQA
             at.unlink()
             raise
 @app.route("/")
@@ -47,22 +53,25 @@
         data = src.read(min(nbytes, 4096))
         if not data:
             break
         dest.write(data)
         nbytes -= len(data)
     if nbytes > 0:
         raise EOFError
 @app.route("/<path:path>", methods=["PUT"])
 def put_file(path):
     try:
-        data_file, metadata_file = get_paths(app.config["DATA_ROOT"], path)
-    except werkzeug.exceptions.NotFound:
+        dest_path = sanitized_join(
+            path,
+            pathlib.Path(app.config["DATA_ROOT"]),
+        )
+    except ValueError:
         return flask.Response(
             "Not Found",
             404,
             mimetype="text/plain",
         )
     verification_key = flask.request.args.get("v", "")
     length = int(flask.request.headers.get("Content-Length", 0))
     hmac_input = "{} {}".format(path, length).encode("utf-8")
     key = app.config["SECRET_KEY"]
     mac = hmac.new(key, hmac_input, hashlib.sha256)
@@ -70,21 +79,22 @@
     if not hmac.compare_digest(digest, verification_key):
         return flask.Response(
             "Invalid verification key",
             403,
             mimetype="text/plain",
         )
     content_type = flask.request.headers.get(
         "Content-Type",
         "application/octet-stream",
     )
-    data_file.parent.mkdir(parents=True, exist_ok=True, mode=0o770)
+    dest_path.parent.mkdir(parents=True, exist_ok=True, mode=0o770)
+    data_file, metadata_file = get_paths(dest_path)
     try:
         with write_file(data_file) as fout:
             stream_file(flask.request.stream, fout, length)
             with metadata_file.open("x") as f:
                 json.dump(
                     {
                         "headers": {"Content-Type": content_type},
                     },
                     f,
                 )
@@ -115,40 +125,46 @@
         if fnmatch.fnmatch(content_type, mimetype_glob):
             break
     else:
         response_headers["Content-Disposition"] = "attachment"
     response_headers["X-Content-Type-Options"] = "nosniff"
     response_headers["X-Frame-Options"] = "DENY"
     response_headers["Content-Security-Policy"] = "default-src 'none'; frame-ancestors 'none'; sandbox"
 @app.route("/<path:path>", methods=["HEAD"])
 def head_file(path):
     try:
-        data_file, metadata = get_info(path)
+        data_file, metadata = get_info(
+            path,
+            pathlib.Path(app.config["DATA_ROOT"])
+        )
         stat = data_file.stat()
-    except (OSError, werkzeug.exceptions.NotFound):
+    except (OSError, ValueError):
         return flask.Response(
             "Not Found",
             404,
             mimetype="text/plain",
         )
     response = flask.Response()
     response.headers["Content-Length"] = str(stat.st_size)
     generate_headers(
         response.headers,
         metadata["headers"],
     )
     return response
 @app.route("/<path:path>", methods=["GET"])
 def get_file(path):
     try:
-        data_file, metadata = get_info(path)
-    except (OSError, werkzeug.exceptions.NotFound):
+        data_file, metadata = get_info(
+            path,
+            pathlib.Path(app.config["DATA_ROOT"])
+        )
+    except (OSError, ValueError):
         return flask.Response(
             "Not Found",
             404,
             mimetype="text/plain",
         )
     response = flask.make_response(flask.send_file(
         str(data_file),
     ))
     generate_headers(
         response.headers,
