# ====================================================================
# FILE: copier/_main.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1229 ---
     1| """Main functions and classes, used to generate or update projects."""
     2| from __future__ import annotations
     3| import os
     4| import platform
     5| import subprocess
     6| import sys
     7| from collections.abc import Iterable, Mapping, Sequence
     8| from contextlib import suppress
     9| from contextvars import ContextVar
    10| from dataclasses import field, replace
    11| from filecmp import dircmp
    12| from functools import cached_property, partial, wraps
    13| from itertools import chain
    14| from pathlib import Path, PurePath, PurePosixPath, PureWindowsPath
    15| from shutil import rmtree
    16| from tempfile import TemporaryDirectory
    17| from types import TracebackType
    18| from typing import (
    19|     Any,
    20|     Callable,
    21|     Literal,
    22|     TypeVar,
    23|     get_args,
    24|     overload,
    25| )
    26| from unicodedata import normalize
    27| from jinja2.loaders import FileSystemLoader
    28| from pathspec import PathSpec
    29| from plumbum import ProcessExecutionError, colors
    30| from plumbum.machines import local
    31| from pydantic import ConfigDict, PositiveInt
    32| from pydantic.dataclasses import dataclass
    33| from pydantic_core import to_jsonable_python
    34| from questionary import confirm, unsafe_prompt
    35| from ._jinja_ext import YieldEnvironment, YieldExtension
    36| from ._subproject import Subproject
    37| from ._template import Task, Template
    38| from ._tools import (
    39|     OS,
    40|     Style,
    41|     cast_to_bool,
    42|     escape_git_path,
    43|     normalize_git_path,
    44|     printf,
    45|     scantree,
    46|     set_git_alternates,
    47| )
    48| from ._types import (
    49|     MISSING,
    50|     AnyByStrDict,
    51|     AnyByStrMutableMapping,
    52|     JSONSerializable,
    53|     LazyDict,
    54|     Operation,
    55|     ParamSpec,
    56|     Phase,
    57|     RelativePath,
    58|     StrOrPath,
    59|     VcsRef,
    60| )
    61| from ._user_data import AnswersMap, Question, load_answersfile_data
    62| from ._vcs import get_git
    63| from .errors import (
    64|     CopierAnswersInterrupt,
    65|     ExtensionNotFoundError,
    66|     ForbiddenPathError,
    67|     InteractiveSessionError,
    68|     TaskError,
    69|     UnsafeTemplateError,
    70|     UserMessageError,
    71|     YieldTagInFileError,
    72| )
    73| from .settings import Settings
    74| _T = TypeVar("_T")
    75| _P = ParamSpec("_P")
    76| _operation: ContextVar[Operation] = ContextVar("_operation")
    77| def as_operation(value: Operation) -> Callable[[Callable[_P, _T]], Callable[_P, _T]]:
    78|     """Decorator to set the current operation context, if not defined already.
    79|     This value is used to template specific configuration options.
    80|     """
    81|     def _decorator(func: Callable[_P, _T]) -> Callable[_P, _T]:
    82|         @wraps(func)
    83|         def _wrapper(*args: _P.args, **kwargs: _P.kwargs) -> _T:
    84|             token = _operation.set(_operation.get(value))
    85|             try:
    86|                 return func(*args, **kwargs)
    87|             finally:
    88|                 _operation.reset(token)
    89|         return _wrapper
    90|     return _decorator
    91| @dataclass(config=ConfigDict(extra="forbid"))
    92| class Worker:
    93|     """Copier process state manager.
    94|     This class represents the state of a copier work, and contains methods to
    95|     actually produce the desired work.
    96|     To use it properly, use it as a context manager and fill all dataclass fields.
    97|     Then, execute one of its main methods, which are prefixed with `run_`:
    98|     -   [run_copy][copier.main.Worker.run_copy] to copy a subproject.
    99|     -   [run_recopy][copier.main.Worker.run_recopy] to recopy a subproject.
   100|     -   [run_update][copier.main.Worker.run_update] to update a subproject.
   101|     Example:
   102|         ```python
   103|         with Worker(
   104|             src_path="https://github.com/copier-org/autopretty.git", "output"
   105|         ) as worker:
   106|             worker.run_copy()
   107|         ```
   108|     Attributes:
   109|         src_path:
   110|             String that can be resolved to a template path, be it local or remote.
   111|             See [copier.vcs.get_repo][].
   112|             If it is `None`, then it means that you are
   113|             [updating a project][updating-a-project], and the original
   114|             `src_path` will be obtained from
   115|             [the answers file][the-copier-answersyml-file].
   116|         dst_path:
   117|             Destination path where to render the subproject.
   118|         answers_file:
   119|             Indicates the path for [the answers file][the-copier-answersyml-file].
   120|             The path must be relative to `dst_path`.
   121|             If it is `None`, the default value will be obtained from
   122|             [copier.template.Template.answers_relpath][].
   123|         vcs_ref:
   124|             Specify the VCS tag/commit to use in the template.
   125|         data:
   126|             Answers to the questionnaire defined in the template.
   127|         exclude:
   128|             User-chosen additional [file exclusion patterns][exclude].
   129|         use_prereleases:
   130|             Consider prereleases when detecting the *latest* one?
   131|             See [use_prereleases][].
   132|             Useless if specifying a [vcs_ref][].
   133|         skip_if_exists:
   134|             User-chosen additional [file skip patterns][skip_if_exists].
   135|         cleanup_on_error:
   136|             Delete `dst_path` if there's an error?
   137|             See [cleanup_on_error][].
   138|         defaults:
   139|             When `True`, use default answers to questions, which might be null if not specified.
   140|             See [defaults][].
   141|         user_defaults:
   142|             Specify user defaults that may override a template's defaults during question prompts.
   143|         overwrite:
   144|             When `True`, Overwrite files that already exist, without asking.
   145|             See [overwrite][].
   146|         pretend:
   147|             When `True`, produce no real rendering.
   148|             See [pretend][].
   149|         quiet:
   150|             When `True`, disable all output.
   151|             See [quiet][].
   152|         conflict:
   153|             One of "inline" (default), "rej".
   154|         context_lines:
   155|             Lines of context to consider when solving conflicts in updates.
   156|             With more lines, context resolution is more accurate, but it will
   157|             also produce more conflicts if your subproject has evolved.
   158|             With less lines, context resolution is less accurate, but it will
   159|             respect better the evolution of your subproject.
   160|         unsafe:
   161|             When `True`, allow usage of unsafe templates.
   162|             See [unsafe][]
   163|         skip_answered:
   164|             When `True`, skip questions that have already been answered.
   165|         skip_tasks:
   166|             When `True`, skip template tasks execution.
   167|     """
   168|     src_path: str | None = None
   169|     dst_path: Path = Path()
   170|     answers_file: RelativePath | None = None
   171|     vcs_ref: str | VcsRef | None = None
   172|     data: AnyByStrDict = field(default_factory=dict)
   173|     settings: Settings = field(default_factory=Settings.from_file)
   174|     exclude: Sequence[str] = ()
   175|     use_prereleases: bool = False
   176|     skip_if_exists: Sequence[str] = ()
   177|     cleanup_on_error: bool = True
   178|     defaults: bool = False
   179|     user_defaults: AnyByStrDict = field(default_factory=dict)
   180|     overwrite: bool = False
   181|     pretend: bool = False
   182|     quiet: bool = False
   183|     conflict: Literal["inline", "rej"] = "inline"
   184|     context_lines: PositiveInt = 3
   185|     unsafe: bool = False
   186|     skip_answered: bool = False
   187|     skip_tasks: bool = False
   188|     answers: AnswersMap = field(default_factory=AnswersMap, init=False)
   189|     _cleanup_hooks: list[Callable[[], None]] = field(default_factory=list, init=False)
   190|     def __enter__(self) -> Worker:
   191|         """Allow using worker as a context manager."""
   192|         return self
   193|     @overload
   194|     def __exit__(self, type: None, value: None, traceback: None) -> None: ...
   195|     @overload
   196|     def __exit__(
   197|         self, type: type[BaseException], value: BaseException, traceback: TracebackType
   198|     ) -> None: ...
   199|     def __exit__(
   200|         self,
   201|         type: type[BaseException] | None,
   202|         value: BaseException | None,
   203|         traceback: TracebackType | None,
   204|     ) -> None:
   205|         """Clean up garbage files after worker usage ends."""
   206|         if value is not None:
   207|             with suppress(Exception):
   208|                 self._cleanup()
   209|             raise value
   210|         self._cleanup()
   211|     def _cleanup(self) -> None:
   212|         """Execute all stored cleanup methods."""
   213|         for method in self._cleanup_hooks:
   214|             method()
   215|     def _check_unsafe(self, mode: Operation) -> None:
   216|         """Check whether a template uses unsafe features."""
   217|         if self.unsafe or self.settings.is_trusted(self.template.url):
   218|             return
   219|         features: set[str] = set()
   220|         if self.template.jinja_extensions:
   221|             features.add("jinja_extensions")
   222|         if self.template.tasks and not self.skip_tasks:
   223|             features.add("tasks")
   224|         if mode == "update" and self.subproject.template:
   225|             if self.subproject.template.jinja_extensions:
   226|                 features.add("jinja_extensions")
   227|             if self.subproject.template.tasks:
   228|                 features.add("tasks")
   229|             for stage in get_args(Literal["before", "after"]):
   230|                 if self.template.migration_tasks(stage, self.subproject.template):
   231|                     features.add("migrations")
   232|                     break
   233|         if features:
   234|             raise UnsafeTemplateError(sorted(features))
   235|     def _external_data(self) -> LazyDict[str, Any]:
   236|         """Load external data lazily.
   237|         Result keys are used for rendering, and values are the parsed contents
   238|         of the YAML files specified in [external_data][].
   239|         Files will only be parsed lazily on 1st access. This helps avoiding
   240|         circular dependencies when the file name also comes from a variable.
   241|         """
   242|         def _render(path: str) -> str:
   243|             with Phase.use(Phase.UNDEFINED):
   244|                 return self._render_string(path)
   245|         return LazyDict(
   246|             {
   247|                 name: lambda path=path: load_answersfile_data(  # type: ignore[misc]
   248|                     self.dst_path, _render(path), warn_on_missing=True
   249|                 )
   250|                 for name, path in self.template.external_data.items()
   251|             }
   252|         )
   253|     def _print_message(self, message: str) -> None:
   254|         if message and not self.quiet:
   255|             print(self._render_string(message), file=sys.stderr)
   256|     def _answers_to_remember(self) -> Mapping[str, Any]:
   257|         """Get only answers that will be remembered in the copier answers file."""
   258|         answers: AnyByStrDict = {}
   259|         commit = self.template.commit
   260|         src = self.template.url
   261|         for key, value in (("_commit", commit), ("_src_path", src)):
   262|             if value is not None:
   263|                 answers[key] = value
   264|         answers.update(
   265|             (str(k), v)
   266|             for (k, v) in self.answers.combined.items()
   267|             if not k.startswith("_")
   268|             and k not in self.answers.hidden
   269|             and k not in self.template.secret_questions
   270|             and k in self.template.questions_data
   271|             and isinstance(k, JSONSerializable)
   272|             and isinstance(v, JSONSerializable)
   273|         )
   274|         return answers
   275|     def _execute_tasks(self, tasks: Sequence[Task]) -> None:
   276|         """Run the given tasks.
   277|         Arguments:
   278|             tasks: The list of tasks to run.
   279|         """
   280|         operation = _operation.get()
   281|         for i, task in enumerate(tasks):
   282|             extra_context = {f"_{k}": v for k, v in task.extra_vars.items()}
   283|             extra_context["_copier_operation"] = operation
   284|             if not cast_to_bool(self._render_value(task.condition, extra_context)):
   285|                 continue
   286|             task_cmd = task.cmd
   287|             if isinstance(task_cmd, str):
   288|                 task_cmd = self._render_string(task_cmd, extra_context)
   289|                 use_shell = True
   290|             else:
   291|                 task_cmd = [
   292|                     self._render_string(str(part), extra_context) for part in task_cmd
   293|                 ]
   294|                 use_shell = False
   295|             if not self.quiet:
   296|                 print(
   297|                     colors.info
   298|                     | f" > Running task {i + 1} of {len(tasks)}: {task_cmd}",
   299|                     file=sys.stderr,
   300|                 )
   301|             if self.pretend:
   302|                 continue
   303|             working_directory = (
   304|                 self.subproject.local_abspath
   305|                 / Path(self._render_string(str(task.working_directory), extra_context))
   306|             ).absolute()
   307|             extra_env = {k[1:].upper(): str(v) for k, v in extra_context.items()}
   308|             with local.cwd(working_directory), local.env(**extra_env):
   309|                 process = subprocess.run(task_cmd, shell=use_shell, env=local.env)
   310|                 if process.returncode:
   311|                     raise TaskError.from_process(process)
   312|     def _render_context(self) -> AnyByStrMutableMapping:
   313|         """Produce render context for Jinja."""
   314|         conf = LazyDict(
   315|             {
   316|                 "src_path": lambda: PurePath(self.template.local_abspath),
   317|                 "dst_path": lambda: PurePath(self.dst_path),
   318|                 "answers_file": lambda: PurePath(self.answers_relpath),
   319|                 "vcs_ref": lambda: self.resolved_vcs_ref,
   320|                 "vcs_ref_hash": lambda: self.template.commit_hash,
   321|                 "data": lambda: self.data,
   322|                 "settings": lambda: self.settings,
   323|                 "exclude": lambda: self.exclude,
   324|                 "use_prereleases": lambda: self.use_prereleases,
   325|                 "skip_if_exists": lambda: self.skip_if_exists,
   326|                 "cleanup_on_error": lambda: self.cleanup_on_error,
   327|                 "defaults": lambda: self.defaults,
   328|                 "user_defaults": lambda: self.user_defaults,
   329|                 "overwrite": lambda: self.overwrite,
   330|                 "pretend": lambda: self.pretend,
   331|                 "quiet": lambda: self.quiet,
   332|                 "conflict": lambda: self.conflict,
   333|                 "context_lines": lambda: self.context_lines,
   334|                 "unsafe": lambda: self.unsafe,
   335|                 "skip_answered": lambda: self.skip_answered,
   336|                 "skip_tasks": lambda: self.skip_tasks,
   337|                 "sep": lambda: os.sep,
   338|                 "os": lambda: OS,
   339|             }
   340|         )
   341|         return dict(
   342|             **self.answers.combined,
   343|             _copier_answers=self._answers_to_remember(),
   344|             _copier_conf=conf,
   345|             _folder_name=self.subproject.local_abspath.name,
   346|             _copier_python=sys.executable,
   347|             _copier_phase=Phase.current(),
   348|         )
   349|     def _path_matcher(self, patterns: Iterable[str]) -> Callable[[Path], bool]:
   350|         """Produce a function that matches against specified patterns."""
   351|         normalized_patterns = (normalize("NFD", pattern) for pattern in patterns)
   352|         spec = PathSpec.from_lines("gitwildmatch", normalized_patterns)
   353|         return spec.match_file
   354|     def _solve_render_conflict(self, dst_relpath: Path) -> bool:
   355|         """Properly solve render conflicts.
   356|         It can ask the user if running in interactive mode.
   357|         """
   358|         assert not dst_relpath.is_absolute()
   359|         printf(
   360|             "conflict",
   361|             dst_relpath,
   362|             style=Style.DANGER,
   363|             quiet=self.quiet,
   364|             file_=sys.stderr,
   365|         )
   366|         if self.match_skip(dst_relpath):
   367|             printf(
   368|                 "skip",
   369|                 dst_relpath,
   370|                 style=Style.OK,
   371|                 quiet=self.quiet,
   372|                 file_=sys.stderr,
   373|             )
   374|             return False
   375|         if self.overwrite or dst_relpath == self.answers_relpath:
   376|             printf(
   377|                 "overwrite",
   378|                 dst_relpath,
   379|                 style=Style.WARNING,
   380|                 quiet=self.quiet,
   381|                 file_=sys.stderr,
   382|             )
   383|             return True
   384|         try:
   385|             answer = confirm(f" Overwrite {dst_relpath}?", default=True).unsafe_ask()
   386|         except EOFError as err:
   387|             raise InteractiveSessionError("Consider using `--overwrite`") from err
   388|         return bool(answer)
   389|     def _render_allowed(
   390|         self,
   391|         dst_relpath: Path,
   392|         is_dir: bool = False,
   393|         is_symlink: bool = False,
   394|         expected_contents: bytes | Path = b"",
   395|     ) -> bool:
   396|         """Determine if a file or directory can be rendered.
   397|         Args:
   398|             dst_relpath:
   399|                 Relative path to destination.
   400|             is_dir:
   401|                 Indicate if the path must be treated as a directory or not.
   402|             is_symlink:
   403|                 Indicate if the path must be treated as a symlink or not.
   404|             expected_contents:
   405|                 Used to compare existing file contents with them. Allows to know if
   406|                 rendering is needed.
   407|         """
   408|         assert not dst_relpath.is_absolute()
   409|         assert not expected_contents or not is_dir, "Dirs cannot have expected content"
   410|         dst_abspath = Path(self.subproject.local_abspath, dst_relpath)
   411|         previous_is_symlink = dst_abspath.is_symlink()
   412|         try:
   413|             previous_content: bytes | Path
   414|             if previous_is_symlink:
   415|                 previous_content = dst_abspath.readlink()
   416|             else:
   417|                 previous_content = dst_abspath.read_bytes()
   418|         except FileNotFoundError:
   419|             printf(
   420|                 "create",
   421|                 dst_relpath,
   422|                 style=Style.OK,
   423|                 quiet=self.quiet,
   424|                 file_=sys.stderr,
   425|             )
   426|             return True
   427|         except PermissionError as error:
   428|             if not (error.errno == 13 and platform.system() == "Windows"):
   429|                 raise
   430|         except IsADirectoryError:
   431|             assert is_dir
   432|         if is_dir or (
   433|             previous_content == expected_contents and previous_is_symlink == is_symlink
   434|         ):
   435|             printf(
   436|                 "identical",
   437|                 dst_relpath,
   438|                 style=Style.IGNORE,
   439|                 quiet=self.quiet,
   440|                 file_=sys.stderr,
   441|             )
   442|             return is_dir
   443|         return self._solve_render_conflict(dst_relpath)
   444|     def _ask(self) -> None:  # noqa: C901
   445|         """Ask the questions of the questionnaire and record their answers."""
   446|         self.answers = AnswersMap(
   447|             user_defaults=self.user_defaults,
   448|             init=self.data,
   449|             last=self.subproject.last_answers,
   450|             metadata=self.template.metadata,
   451|             external=self._external_data(),
   452|         )
   453|         for var_name, details in self.template.questions_data.items():
   454|             question = Question(
   455|                 answers=self.answers,
   456|                 context=self._render_context(),
   457|                 jinja_env=self.jinja_env,
   458|                 settings=self.settings,
   459|                 var_name=var_name,
   460|                 **details,
   461|             )
   462|             if var_name in self.answers.last:
   463|                 try:
   464|                     answer = question.parse_answer(self.answers.last[var_name])
   465|                     question.validate_answer(answer)
   466|                 except Exception:
   467|                     del self.answers.last[var_name]
   468|             if not question.get_when():
   469|                 self.answers.hide(var_name)
   470|                 if var_name in self.answers.last:
   471|                     del self.answers.last[var_name]
   472|                 if question.default is MISSING:
   473|                     continue
   474|             if var_name in self.answers.init:
   475|                 answer = question.parse_answer(self.answers.init[var_name])
   476|                 question.validate_answer(answer)
   477|                 self.answers.user[var_name] = answer
   478|                 continue
   479|             if self.skip_answered and var_name in self.answers.last:
   480|                 continue
   481|             try:
   482|                 if self.defaults:
   483|                     new_answer = question.get_default()
   484|                     if new_answer is MISSING:
   485|                         raise ValueError(f'Question "{var_name}" is required')
   486|                 else:
   487|                     try:
   488|                         new_answer = unsafe_prompt(
   489|                             [question.get_questionary_structure()],
   490|                             answers={question.var_name: question.get_default()},
   491|                         )[question.var_name]
   492|                     except EOFError as err:
   493|                         raise InteractiveSessionError(
   494|                             "Use `--defaults` and/or `--data`/`--data-file`"
   495|                         ) from err
   496|             except KeyboardInterrupt as err:
   497|                 raise CopierAnswersInterrupt(
   498|                     self.answers, question, self.template
   499|                 ) from err
   500|             self.answers.user[var_name] = new_answer
   501|         self.answers.external = self._external_data()
   502|     @property
   503|     def answers_relpath(self) -> Path:
   504|         """Obtain the proper relative path for the answers file.
   505|         It comes from:
   506|         1. User choice.
   507|         2. Template default.
   508|         3. Copier default.
   509|         """
   510|         path = self.answers_file or self.template.answers_relpath
   511|         template = self.jinja_env.from_string(str(path))
   512|         context = self._render_context()
   513|         context["_copier_conf"]["answers_file"] = ""
   514|         return Path(template.render(**context))
   515|     @cached_property
   516|     def all_exclusions(self) -> Sequence[str]:
   517|         """Combine default, template and user-chosen exclusions."""
   518|         return self.template.exclude + tuple(self.exclude)
   519|     @cached_property
   520|     def jinja_env(self) -> YieldEnvironment:
   521|         """Return a pre-configured Jinja environment.
   522|         Respects template settings.
   523|         """
   524|         paths = [str(self.template.local_abspath)]
   525|         loader = FileSystemLoader(paths)
   526|         default_extensions = [
   527|             "jinja2_ansible_filters.AnsibleCoreFiltersExtension",
   528|             YieldExtension,
   529|         ]
   530|         extensions = default_extensions + list(self.template.jinja_extensions)
   531|         try:
   532|             env = YieldEnvironment(
   533|                 loader=loader, extensions=extensions, **self.template.envops
   534|             )
   535|         except ModuleNotFoundError as error:
   536|             raise ExtensionNotFoundError(
   537|                 f"Copier could not load some Jinja extensions:\n{error}\n"
   538|                 "Make sure to install these extensions alongside Copier itself.\n"
   539|                 "See the docs at https://copier.readthedocs.io/en/latest/configuring/#jinja_extensions"
   540|             )
   541|         def to_json_fallback(value: Any) -> Any:
   542|             if isinstance(value, LazyDict):
   543|                 return dict(value)
   544|             if isinstance(value, PurePath):
   545|                 return str(value)
   546|             return value
   547|         env.filters["to_json"] = partial(
   548|             env.filters["to_json"],
   549|             default=partial(to_jsonable_python, fallback=to_json_fallback),
   550|         )
   551|         path_type = {
   552|             "posix": PurePosixPath,
   553|             "windows": PureWindowsPath,
   554|             "native": PurePath,
   555|         }
   556|         def _pathjoin(
   557|             *path: str, mode: Literal["posix", "windows", "native"] = "posix"
   558|         ) -> str:
   559|             return str(path_type[mode](*path))
   560|         env.globals["pathjoin"] = _pathjoin
   561|         return env
   562|     @cached_property
   563|     def match_exclude(self) -> Callable[[Path], bool]:
   564|         """Get a callable to match paths against all exclusions."""
   565|         extra_context = {"_copier_operation": _operation.get()}
   566|         return self._path_matcher(
   567|             self._render_string(exclusion, extra_context=extra_context)
   568|             for exclusion in self.all_exclusions
   569|         )
   570|     @cached_property
   571|     def match_skip(self) -> Callable[[Path], bool]:
   572|         """Get a callable to match paths against all skip-if-exists patterns."""
   573|         return self._path_matcher(
   574|             map(
   575|                 self._render_string,
   576|                 tuple(chain(self.skip_if_exists, self.template.skip_if_exists)),
   577|             )
   578|         )
   579|     def _render_template(self) -> None:
   580|         """Render the template in the subproject root."""
   581|         follow_symlinks = not self.template.preserve_symlinks
   582|         cwd = Path.cwd()
   583|         for src in scantree(str(self.template_copy_root), follow_symlinks):
   584|             src_abspath = Path(src.path)
   585|             src_relpath = Path(src_abspath).relative_to(self.template.local_abspath)
   586|             dst_relpaths_ctxs = self._render_path(
   587|                 Path(src_abspath).relative_to(self.template_copy_root)
   588|             )
   589|             for dst_relpath, ctx in dst_relpaths_ctxs:
   590|                 if not cwd.joinpath(dst_relpath).resolve().is_relative_to(cwd):
   591|                     raise ForbiddenPathError(path=dst_relpath)
   592|                 if self.match_exclude(dst_relpath):
   593|                     continue
   594|                 if src.is_symlink() and self.template.preserve_symlinks:
   595|                     self._render_symlink(src_relpath, dst_relpath)
   596|                 elif src.is_dir(follow_symlinks=follow_symlinks):
   597|                     self._render_folder(dst_relpath)
   598|                 else:
   599|                     self._render_file(src_relpath, dst_relpath, extra_context=ctx or {})
   600|     def _render_file(
   601|         self,
   602|         src_relpath: Path,
   603|         dst_relpath: Path,
   604|         extra_context: AnyByStrDict | None = None,
   605|     ) -> None:
   606|         """Render one file.
   607|         Args:
   608|             src_relpath:
   609|                 File to be rendered. It must be a path relative to the template
   610|                 root.
   611|             dst_relpath:
   612|                 File to be created. It must be a path relative to the subproject
   613|                 root.
   614|             extra_context:
   615|                 Additional variables to use for rendering the template.
   616|         """
   617|         assert not src_relpath.is_absolute()
   618|         assert not dst_relpath.is_absolute()
   619|         src_abspath = self.template.local_abspath / src_relpath
   620|         if src_relpath.name.endswith(self.template.templates_suffix):
   621|             try:
   622|                 tpl = self.jinja_env.get_template(src_relpath.as_posix())
   623|             except UnicodeDecodeError:
   624|                 if self.template.templates_suffix:
   625|                     raise
   626|                 new_content = src_abspath.read_bytes()
   627|             else:
   628|                 new_content = tpl.render(
   629|                     **self._render_context(), **(extra_context or {})
   630|                 ).encode()
   631|                 if self.jinja_env.yield_name:
   632|                     raise YieldTagInFileError(
   633|                         f"File {src_relpath} contains a yield tag, but it is not allowed."
   634|                     )
   635|         else:
   636|             new_content = src_abspath.read_bytes()
   637|         dst_abspath = self.subproject.local_abspath / dst_relpath
   638|         src_mode = src_abspath.stat().st_mode
   639|         if not self._render_allowed(dst_relpath, expected_contents=new_content):
   640|             return
   641|         if not self.pretend:
   642|             dst_abspath.parent.mkdir(parents=True, exist_ok=True)
   643|             if dst_abspath.is_symlink():
   644|                 dst_abspath.unlink()
   645|             dst_abspath.write_bytes(new_content)
   646|             dst_abspath.chmod(src_mode)
   647|     def _render_symlink(self, src_relpath: Path, dst_relpath: Path) -> None:
   648|         """Render one symlink.
   649|         Args:
   650|             src_relpath:
   651|                 Symlink to be rendered. It must be a path relative to the
   652|                 template root.
   653|             dst_relpath:
   654|                 Symlink to be created. It must be a path relative to the
   655|                 subproject root.
   656|         """
   657|         assert not src_relpath.is_absolute()
   658|         assert not dst_relpath.is_absolute()
   659|         if dst_relpath is None or self.match_exclude(dst_relpath):
   660|             return
   661|         src_abspath = self.template.local_abspath / src_relpath
   662|         src_target = src_abspath.readlink()
   663|         if src_abspath.name.endswith(self.template.templates_suffix):
   664|             dst_target = Path(self._render_string(str(src_target)))
   665|         else:
   666|             dst_target = src_target
   667|         if not self._render_allowed(
   668|             dst_relpath,
   669|             expected_contents=dst_target,
   670|             is_symlink=True,
   671|         ):
   672|             return
   673|         if not self.pretend:
   674|             dst_abspath = self.subproject.local_abspath / dst_relpath
   675|             if dst_abspath.is_symlink() or dst_abspath.exists():
   676|                 dst_abspath.unlink()
   677|             dst_abspath.parent.mkdir(parents=True, exist_ok=True)
   678|             dst_abspath.symlink_to(dst_target)
   679|             if sys.platform == "darwin":
   680|                 src_mode = src_abspath.lstat().st_mode
   681|                 dst_abspath.lchmod(src_mode)
   682|     def _render_folder(self, dst_relpath: Path) -> None:
   683|         """Create one folder (without content).
   684|         Args:
   685|             dst_relpath:
   686|                 Folder to be created. It must be a path relative to the
   687|                 subproject root.
   688|         """
   689|         assert not dst_relpath.is_absolute()
   690|         if not self.pretend and self._render_allowed(dst_relpath, is_dir=True):
   691|             dst_abspath = self.subproject.local_abspath / dst_relpath
   692|             dst_abspath.mkdir(parents=True, exist_ok=True)
   693|     def _adjust_rendered_part(self, rendered_part: str) -> str:
   694|         """Adjust the rendered part if necessary.
   695|         If `{{ _copier_conf.answers_file }}` becomes the full path,
   696|         restore part to be just the end leaf.
   697|         Args:
   698|             rendered_part:
   699|                 The rendered part of the path to adjust.
   700|         """
   701|         if str(self.answers_relpath) == rendered_part:
   702|             return Path(rendered_part).name
   703|         return rendered_part
   704|     def _render_parts(
   705|         self,
   706|         parts: tuple[str, ...],
   707|         rendered_parts: tuple[str, ...] | None = None,
   708|         extra_context: AnyByStrDict | None = None,
   709|         is_template: bool = False,
   710|     ) -> Iterable[tuple[Path, AnyByStrDict | None]]:
   711|         """Render a set of parts into path and context pairs.
   712|         If a yield tag is found in a part, it will recursively yield multiple path and context pairs.
   713|         """
   714|         if rendered_parts is None:
   715|             rendered_parts = tuple()
   716|         if not parts:
   717|             rendered_path = Path(*rendered_parts)
   718|             templated_sibling = (
   719|                 self.template.local_abspath
   720|                 / f"{rendered_path}{self.template.templates_suffix}"
   721|             )
   722|             if is_template or not templated_sibling.exists():
   723|                 yield rendered_path, extra_context
   724|             return
   725|         part = parts[0]
   726|         parts = parts[1:]
   727|         if not extra_context:
   728|             extra_context = {}
   729|         rendered_part = self._render_string(part, extra_context=extra_context)
   730|         yield_name = self.jinja_env.yield_name
   731|         if yield_name:
   732|             for value in self.jinja_env.yield_iterable or ():
   733|                 new_context = {**extra_context, yield_name: value}
   734|                 rendered_part = self._render_string(part, extra_context=new_context)
   735|                 rendered_part = self._adjust_rendered_part(rendered_part)
   736|                 if not rendered_part:
   737|                     continue
   738|                 yield from self._render_parts(
   739|                     parts, rendered_parts + (rendered_part,), new_context, is_template
   740|                 )
   741|             return
   742|         if not rendered_part:
   743|             return
   744|         rendered_part = self._adjust_rendered_part(rendered_part)
   745|         yield from self._render_parts(
   746|             parts, rendered_parts + (rendered_part,), extra_context, is_template
   747|         )
   748|     def _render_path(self, relpath: Path) -> Iterable[tuple[Path, AnyByStrDict | None]]:
   749|         """Render one relative path into multiple path and context pairs.
   750|         Args:
   751|             relpath:
   752|                 The relative path to be rendered. Obviously, it can be templated.
   753|         """
   754|         is_template = relpath.name.endswith(self.template.templates_suffix)
   755|         templated_sibling = (
   756|             self.template_copy_root / f"{relpath}{self.template.templates_suffix}"
   757|         )
   758|         if templated_sibling.exists() and self.template.templates_suffix:
   759|             return
   760|         if self.template.templates_suffix and is_template:
   761|             relpath = relpath.with_suffix("")
   762|         yield from self._render_parts(relpath.parts, is_template=is_template)
   763|     def _render_string(
   764|         self, string: str, extra_context: AnyByStrDict | None = None
   765|     ) -> str:
   766|         """Render one templated string.
   767|         Args:
   768|             string:
   769|                 The template source string.
   770|             extra_context:
   771|                 Additional variables to use for rendering the template.
   772|         """
   773|         tpl = self.jinja_env.from_string(string)
   774|         return tpl.render(**self._render_context(), **(extra_context or {}))
   775|     def _render_value(
   776|         self, value: _T, extra_context: AnyByStrDict | None = None
   777|     ) -> str | _T:
   778|         """Render a value, which may or may not be a templated string.
   779|         Args:
   780|             value:
   781|                 The value to render.
   782|             extra_context:
   783|                 Additional variables to use for rendering the template.
   784|         """
   785|         try:
   786|             return self._render_string(value, extra_context=extra_context)  # type: ignore[arg-type]
   787|         except TypeError:
   788|             return value
   789|     @cached_property
   790|     def resolved_vcs_ref(self) -> str | None:
   791|         """Get the resolved VCS reference to use.
   792|         This is either `vcs_ref` or the subproject template ref
   793|         if `vcs_ref` is `VcsRef.CURRENT`.
   794|         """
   795|         if self.vcs_ref is VcsRef.CURRENT:
   796|             if self.subproject.template is None:
   797|                 raise TypeError("Template not found")
   798|             return self.subproject.template.ref
   799|         return self.vcs_ref
   800|     @cached_property
   801|     def subproject(self) -> Subproject:
   802|         """Get related subproject."""
   803|         result = Subproject(
   804|             local_abspath=self.dst_path.absolute(),
   805|             answers_relpath=self.answers_file or Path(".copier-answers.yml"),
   806|         )
   807|         self._cleanup_hooks.append(result._cleanup)
   808|         return result
   809|     @cached_property
   810|     def template(self) -> Template:
   811|         url = self.src_path
   812|         if not url:
   813|             if self.subproject.template is None:
   814|                 raise TypeError("Template not found")
   815|             url = str(self.subproject.template.url)
   816|         ref = self.resolved_vcs_ref
   817|         result = Template(url=url, ref=ref, use_prereleases=self.use_prereleases)
   818|         self._cleanup_hooks.append(result._cleanup)
   819|         return result
   820|     @cached_property
   821|     def template_copy_root(self) -> Path:
   822|         """Absolute path from where to start copying.
   823|         It points to the cloned template local abspath + the rendered subdir, if any.
   824|         """
   825|         subdir = self._render_string(self.template.subdirectory) or ""
   826|         return self.template.local_abspath / subdir
   827|     @as_operation("copy")
   828|     def run_copy(self) -> None:
   829|         """Generate a subproject from zero, ignoring what was in the folder.
   830|         If `dst_path` was missing, it will be
   831|         created. Otherwise, `src_path` be rendered
   832|         directly into it, without worrying about evolving what was there
   833|         already.
   834|         See [generating a project][generating-a-project].
   835|         """
   836|         with suppress(AttributeError):
   837|             del self.match_exclude
   838|         self._check_unsafe("copy")
   839|         self._print_message(self.template.message_before_copy)
   840|         with Phase.use(Phase.PROMPT):
   841|             self._ask()
   842|         was_existing = self.subproject.local_abspath.exists()
   843|         try:
   844|             if not self.quiet:
   845|                 print(
   846|                     f"\nCopying from template version {self.template.version}",
   847|                     file=sys.stderr,
   848|                 )
   849|             with Phase.use(Phase.RENDER):
   850|                 self._render_template()
   851|             if not self.quiet:
   852|                 print("")  # padding space
   853|             if not self.skip_tasks:
   854|                 with Phase.use(Phase.TASKS):
   855|                     self._execute_tasks(self.template.tasks)
   856|         except Exception:
   857|             if not was_existing and self.cleanup_on_error:
   858|                 rmtree(self.subproject.local_abspath)
   859|             raise
   860|         self._print_message(self.template.message_after_copy)
   861|         if not self.quiet:
   862|             print("")  # padding space
   863|     @as_operation("copy")
   864|     def run_recopy(self) -> None:
   865|         """Update a subproject, keeping answers but discarding evolution."""
   866|         if self.subproject.template is None:
   867|             raise UserMessageError(
   868|                 "Cannot recopy because cannot obtain old template references "
   869|                 f"from `{self.subproject.answers_relpath}`."
   870|             )
   871|         with replace(self, src_path=self.subproject.template.url) as new_worker:
   872|             new_worker.run_copy()
   873|     def _print_template_update_info(self, subproject_template: Template) -> None:
   874|         if not self.quiet:
   875|             if subproject_template.version == self.template.version:
   876|                 message = f"Keeping template version {self.template.version}"
   877|             else:
   878|                 message = f"Updating to template version {self.template.version}"
   879|             print(message, file=sys.stderr)
   880|     @as_operation("update")
   881|     def run_update(self) -> None:
   882|         """Update a subproject that was already generated.
   883|         See [updating a project][updating-a-project].
   884|         """
   885|         self._check_unsafe("update")
   886|         if self.subproject.vcs != "git":
   887|             raise UserMessageError(
   888|                 "Updating is only supported in git-tracked subprojects."
   889|             )
   890|         if self.subproject.is_dirty():
   891|             raise UserMessageError(
   892|                 "Destination repository is dirty; cannot continue. "
   893|                 "Please commit or stash your local changes and retry."
   894|             )
   895|         if self.subproject.template is None or self.subproject.template.ref is None:
   896|             raise UserMessageError(
   897|                 "Cannot update because cannot obtain old template references "
   898|                 f"from `{self.subproject.answers_relpath}`."
   899|             )
   900|         if self.template.commit is None:
   901|             raise UserMessageError(
   902|                 "Updating is only supported in git-tracked templates."
   903|             )
   904|         if not self.subproject.template.version:
   905|             raise UserMessageError(
   906|                 "Cannot update: version from last update not detected."
   907|             )
   908|         if not self.template.version:
   909|             raise UserMessageError("Cannot update: version from template not detected.")
   910|         if self.subproject.template.version > self.template.version:
   911|             raise UserMessageError(
   912|                 f"You are downgrading from {self.subproject.template.version} to {self.template.version}. "
   913|                 "Downgrades are not supported."
   914|             )
   915|         if not self.overwrite:
   916|             raise UserMessageError("Enable overwrite to update a subproject.")
   917|         self._print_message(self.template.message_before_update)
   918|         self._print_template_update_info(self.subproject.template)
   919|         with suppress(AttributeError):
   920|             del self.match_exclude
   921|         self._apply_update()
   922|         self._print_message(self.template.message_after_update)
   923|     def _apply_update(self) -> None:  # noqa: C901
   924|         git = get_git()
   925|         subproject_top = Path(
   926|             git(
   927|                 "-C",
   928|                 self.subproject.local_abspath,
   929|                 "rev-parse",
   930|                 "--show-toplevel",
   931|             ).strip()
   932|         )
   933|         subproject_subdir = self.subproject.local_abspath.relative_to(subproject_top)
   934|         with (
   935|             TemporaryDirectory(
   936|                 prefix=f"{__name__}.old_copy.",
   937|             ) as old_copy,
   938|             TemporaryDirectory(
   939|                 prefix=f"{__name__}.new_copy.",
   940|             ) as new_copy,
   941|         ):
   942|             with replace(
   943|                 self,
   944|                 dst_path=old_copy / subproject_subdir,
   945|                 data=self.subproject.last_answers,
   946|                 defaults=True,
   947|                 quiet=True,
   948|                 src_path=self.subproject.template.url,  # type: ignore[union-attr]
   949|                 vcs_ref=self.subproject.template.commit,  # type: ignore[union-attr]
   950|             ) as old_worker:
   951|                 assert old_worker.template is not self.template
   952|                 for q in old_worker.template.questions_data.values():
   953|                     if q.get("secret", False):
   954|                         q.pop("validator", None)
   955|                 old_worker.run_copy()
   956|             with Phase.use(Phase.MIGRATE):
   957|                 self._execute_tasks(
   958|                     self.template.migration_tasks("before", self.subproject.template)  # type: ignore[arg-type]
   959|                 )
   960|             with local.cwd(subproject_top):
   961|                 subproject_head = git("write-tree").strip()
   962|             with local.cwd(old_copy):
   963|                 self._git_initialize_repo()
   964|                 set_git_alternates(subproject_top)
   965|                 files_removed = git(
   966|                     "diff-tree",
   967|                     "-r",
   968|                     "--diff-filter=D",
   969|                     "--name-only",
   970|                     "HEAD",
   971|                     subproject_head,
   972|                 ).splitlines()
   973|                 exclude_plus_removed = list(
   974|                     set(self.exclude).union(
   975|                         map(
   976|                             escape_git_path,
   977|                             map(
   978|                                 normalize_git_path,
   979|                                 (
   980|                                     path
   981|                                     for path in files_removed
   982|                                     if not self.match_skip(path)
   983|                                 ),
   984|                             ),
   985|                         )
   986|                     )
   987|                 )
   988|             if self.skip_answered is False:
   989|                 self.answers = AnswersMap(external=self._external_data())
   990|                 with suppress(AttributeError):
   991|                     del self.subproject.last_answers
   992|             with replace(
   993|                 self,
   994|                 exclude=exclude_plus_removed,
   995|                 quiet=True,
   996|             ) as current_worker:
   997|                 current_worker.run_copy()
   998|                 self.answers = current_worker.answers
   999|                 self.answers.external = self._external_data()
  1000|             with replace(
  1001|                 self,
  1002|                 dst_path=new_copy / subproject_subdir,
  1003|                 data={
  1004|                     k: v
  1005|                     for k, v in self.answers.combined.items()
  1006|                     if k not in self.answers.hidden
  1007|                 },
  1008|                 defaults=True,
  1009|                 quiet=True,
  1010|                 src_path=self.subproject.template.url,  # type: ignore[union-attr]
  1011|                 exclude=exclude_plus_removed,
  1012|                 vcs_ref=self.resolved_vcs_ref,
  1013|             ) as new_worker:
  1014|                 new_worker.run_copy()
  1015|             with local.cwd(new_copy):
  1016|                 self._git_initialize_repo()
  1017|                 new_copy_head = git("rev-parse", "HEAD").strip()
  1018|             with local.cwd(old_copy):
  1019|                 set_git_alternates(subproject_top, Path(new_copy))
  1020|                 diff_added_cmd = git[
  1021|                     "diff-tree", "-r", "--diff-filter=A", "--name-only"
  1022|                 ]
  1023|                 for filename in (
  1024|                     set(diff_added_cmd("HEAD", subproject_head).splitlines())
  1025|                 ) & set(diff_added_cmd("HEAD", new_copy_head).splitlines()):
  1026|                     f = Path(filename)
  1027|                     f.parent.mkdir(parents=True, exist_ok=True)
  1028|                     f.touch((subproject_top / filename).stat().st_mode)
  1029|                     git("add", "--force", filename)
  1030|                 self._git_commit("add new empty files")
  1031|                 diff_cmd = git[
  1032|                     "diff-tree",
  1033|                     f"--unified={self.context_lines}",
  1034|                     "HEAD",
  1035|                     subproject_head,
  1036|                 ]
  1037|                 try:
  1038|                     diff = diff_cmd("--inter-hunk-context=-1")
  1039|                 except ProcessExecutionError:
  1040|                     print(
  1041|                         colors.warn
  1042|                         | "Make sure Git >= 2.24 is installed to improve updates.",
  1043|                         file=sys.stderr,
  1044|                     )
  1045|                     diff = diff_cmd("--inter-hunk-context=0")
  1046|             compared = dircmp(old_copy, new_copy)
  1047|             with local.cwd(subproject_top):
  1048|                 apply_cmd = git["apply", "--reject", "--exclude", self.answers_relpath]
  1049|                 ignored_files = git["status", "--ignored", "--porcelain"]()
  1050|                 extra_exclude = [
  1051|                     filename.split("!! ").pop()
  1052|                     for filename in ignored_files.splitlines()
  1053|                 ]
  1054|                 for skip_pattern in chain(
  1055|                     self.skip_if_exists, self.template.skip_if_exists, extra_exclude
  1056|                 ):
  1057|                     apply_cmd = apply_cmd["--exclude", skip_pattern]
  1058|                 (apply_cmd << diff)(retcode=None)
  1059|                 if self.conflict == "inline":
  1060|                     conflicted = []
  1061|                     old_path = Path(old_copy)
  1062|                     new_path = Path(new_copy)
  1063|                     status = git("status", "--porcelain").strip().splitlines()
  1064|                     for line in status:
  1065|                         if not line.startswith("?? "):
  1066|                             continue
  1067|                         fname = line[3:]
  1068|                         fname = normalize_git_path(fname)
  1069|                         if not fname.endswith(".rej"):
  1070|                             continue
  1071|                         fname = fname[:-4]
  1072|                         git("checkout", "--", fname)
  1073|                         git(
  1074|                             "merge-file",
  1075|                             "-L",
  1076|                             "before updating",
  1077|                             "-L",
  1078|                             "last update",
  1079|                             "-L",
  1080|                             "after updating",
  1081|                             fname,
  1082|                             old_path / fname,
  1083|                             new_path / fname,
  1084|                             retcode=None,
  1085|                         )
  1086|                         Path(f"{fname}.rej").unlink()
  1087|                         with Path(fname).open("rb") as conflicts_candidate:
  1088|                             if any(
  1089|                                 line.rstrip()
  1090|                                 in {
  1091|                                     b"<<<<<<< before updating",
  1092|                                     b">>>>>>> after updating",
  1093|                                 }
  1094|                                 for line in conflicts_candidate
  1095|                             ):
  1096|                                 conflicted.append(fname)
  1097|                     if conflicted:
  1098|                         input_lines = []
  1099|                         for line in (
  1100|                             git("ls-files", "--stage", *conflicted).strip().splitlines()
  1101|                         ):
  1102|                             perms_sha_mode, path = line.split("\t")
  1103|                             perms, sha, _ = perms_sha_mode.split()
  1104|                             input_lines.append(f"0 {'0' * 40}\t{path}")
  1105|                             input_lines.append(f"{perms} {sha} 2\t{path}")
  1106|                             with suppress(ProcessExecutionError):
  1107|                                 old_sha = git(
  1108|                                     "hash-object",
  1109|                                     "-w",
  1110|                                     old_path / normalize_git_path(path),
  1111|                                 ).strip()
  1112|                                 input_lines.append(f"{perms} {old_sha} 1\t{path}")
  1113|                             with suppress(ProcessExecutionError):
  1114|                                 new_sha = git(
  1115|                                     "hash-object",
  1116|                                     "-w",
  1117|                                     new_path / normalize_git_path(path),
  1118|                                 ).strip()
  1119|                                 input_lines.append(f"{perms} {new_sha} 3\t{path}")
  1120|                         (
  1121|                             git["update-index", "--index-info"]
  1122|                             << "\n".join(input_lines)
  1123|                         )()
  1124|             _remove_old_files(subproject_top, compared)
  1125|         with Phase.use(Phase.MIGRATE):
  1126|             self._execute_tasks(
  1127|                 self.template.migration_tasks("after", self.subproject.template)  # type: ignore[arg-type]
  1128|             )
  1129|     def _git_initialize_repo(self) -> None:
  1130|         """Initialize a git repository in the current directory."""
  1131|         git = get_git()
  1132|         git("init", retcode=None)
  1133|         git("add", ".")
  1134|         self._git_commit()
  1135|     def _git_commit(self, message: str = "dumb commit") -> None:
  1136|         git = get_git()
  1137|         git(
  1138|             "commit",
  1139|             "--allow-empty",
  1140|             "-am",
  1141|             f"{message} 1",
  1142|             "--no-gpg-sign",
  1143|             retcode=None,
  1144|         )
  1145|         git(
  1146|             "commit",
  1147|             "--allow-empty",
  1148|             "-am",
  1149|             f"{message} 2",
  1150|             "--no-gpg-sign",
  1151|             "--no-verify",
  1152|         )
  1153| def run_copy(
  1154|     src_path: str,
  1155|     dst_path: StrOrPath = ".",
  1156|     data: AnyByStrDict | None = None,
  1157|     **kwargs: Any,
  1158| ) -> Worker:
  1159|     """Copy a template to a destination, from zero.
  1160|     This is a shortcut for [run_copy][copier.main.Worker.run_copy].
  1161|     See [Worker][copier.main.Worker] fields to understand this function's args.
  1162|     """
  1163|     if data is not None:
  1164|         kwargs["data"] = data
  1165|     with Worker(src_path=src_path, dst_path=Path(dst_path), **kwargs) as worker:
  1166|         worker.run_copy()
  1167|     return worker
  1168| def run_recopy(
  1169|     dst_path: StrOrPath = ".", data: AnyByStrDict | None = None, **kwargs: Any
  1170| ) -> Worker:
  1171|     """Update a subproject from its template, discarding subproject evolution.
  1172|     This is a shortcut for [run_recopy][copier.main.Worker.run_recopy].
  1173|     See [Worker][copier.main.Worker] fields to understand this function's args.
  1174|     """
  1175|     if data is not None:
  1176|         kwargs["data"] = data
  1177|     with Worker(dst_path=Path(dst_path), **kwargs) as worker:
  1178|         worker.run_recopy()
  1179|     return worker
  1180| def run_update(
  1181|     dst_path: StrOrPath = ".",
  1182|     data: AnyByStrDict | None = None,
  1183|     **kwargs: Any,
  1184| ) -> Worker:
  1185|     """Update a subproject, from its template.
  1186|     This is a shortcut for [run_update][copier.main.Worker.run_update].
  1187|     See [Worker][copier.main.Worker] fields to understand this function's args.
  1188|     """
  1189|     if data is not None:
  1190|         kwargs["data"] = data
  1191|     with Worker(dst_path=Path(dst_path), **kwargs) as worker:
  1192|         worker.run_update()
  1193|     return worker
  1194| def _remove_old_files(prefix: Path, cmp: dircmp[str], rm_common: bool = False) -> None:
  1195|     """Remove files and directories only found in "old" template.
  1196|     This is an internal helper method used to process a comparison of 2
  1197|     directories, where the left one is considered the "old" one, and the
  1198|     right one is the "new" one.
  1199|     Then, it will recursively try to remove anything that is only in the old
  1200|     directory.
  1201|     Args:
  1202|         prefix:
  1203|             Where we start removing. It can be different from the directories
  1204|             being compared.
  1205|         cmp:
  1206|             The comparison result.
  1207|         rm_common:
  1208|             Should we remove common files and directories?
  1209|     """
  1210|     to_rm = []
  1211|     subdirs = {}
  1212|     with suppress(NotADirectoryError, FileNotFoundError):
  1213|         to_rm = cmp.left_only
  1214|         if rm_common:
  1215|             to_rm += cmp.common_files + cmp.common_dirs
  1216|         subdirs = cmp.subdirs
  1217|     for name in to_rm:
  1218|         target = prefix / name
  1219|         if target.is_file():
  1220|             target.unlink()
  1221|         else:
  1222|             _remove_old_files(target, dircmp(Path(cmp.left, name), target), True)
  1223|             with suppress(OSError):
  1224|                 target.rmdir()  # Raises if dir not empty
  1225|     for key, value in subdirs.items():
  1226|         subdir = prefix / key
  1227|         _remove_old_files(subdir, value)
  1228|         with suppress(OSError):
  1229|             subdir.rmdir()  # Raises if dir not empty


# ====================================================================
# FILE: copier/errors.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-135 ---
     1| """Custom exceptions used by Copier."""
     2| from __future__ import annotations
     3| import subprocess
     4| import sys
     5| from collections.abc import Sequence
     6| from pathlib import Path
     7| from subprocess import CompletedProcess
     8| from typing import TYPE_CHECKING
     9| from ._tools import printf_exception
    10| from ._types import PathSeq
    11| if TYPE_CHECKING:  # always false
    12|     from ._template import Template
    13|     from ._user_data import AnswersMap, Question
    14| if sys.version_info < (3, 11):
    15|     from typing_extensions import Self
    16| else:
    17|     from typing import Self
    18| class CopierError(Exception):
    19|     """Base class for all other Copier errors."""
    20| class UserMessageError(CopierError):
    21|     """Exit the program giving a message to the user."""
    22|     def __init__(self, message: str):
    23|         self.message = message
    24|     def __str__(self) -> str:
    25|         return self.message
    26| class UnsupportedVersionError(UserMessageError):
    27|     """Copier version does not support template version."""
    28| class ConfigFileError(ValueError, CopierError):
    29|     """Parent class defining problems with the config file."""
    30| class InvalidConfigFileError(ConfigFileError):
    31|     """Indicates that the config file is wrong."""
    32|     def __init__(self, conf_path: Path, quiet: bool):
    33|         msg = str(conf_path)
    34|         printf_exception(self, "INVALID CONFIG FILE", msg=msg, quiet=quiet)
    35|         super().__init__(msg)
    36| class MultipleConfigFilesError(ConfigFileError):
    37|     """Both copier.yml and copier.yaml found, and that's an error."""
    38|     def __init__(self, conf_paths: PathSeq):
    39|         msg = str(conf_paths)
    40|         printf_exception(self, "MULTIPLE CONFIG FILES", msg=msg)
    41|         super().__init__(msg)
    42| class InvalidTypeError(TypeError, CopierError):
    43|     """The question type is not among the supported ones."""
    44| class PathError(CopierError, ValueError):
    45|     """The path is invalid in the given context."""
    46| class PathNotAbsoluteError(PathError):
    47|     """The path is not absolute, but it should be."""
    48|     def __init__(self, *, path: Path) -> None:
    49|         super().__init__(f'"{path}" is not an absolute path')
    50| class PathNotRelativeError(PathError):
    51|     """The path is not relative, but it should be."""
    52|     def __init__(self, *, path: Path) -> None:
    53|         super().__init__(f'"{path}" is not a relative path')
    54| class ForbiddenPathError(PathError):
    55|     """The path is forbidden in the given context."""
    56|     def __init__(self, *, path: Path) -> None:
    57|         super().__init__(f'"{path}" is forbidden')
    58| class ExtensionNotFoundError(UserMessageError):
    59|     """Extensions listed in the configuration could not be loaded."""
    60| class CopierAnswersInterrupt(CopierError, KeyboardInterrupt):
    61|     """CopierAnswersInterrupt is raised during interactive question prompts.
    62|     It typically follows a KeyboardInterrupt (i.e. ctrl-c) and provides an
    63|     opportunity for the caller to conduct additional cleanup, such as writing
    64|     the partially completed answers to a file.
    65|     Attributes:
    66|         answers:
    67|             AnswersMap that contains the partially completed answers object.
    68|         last_question:
    69|             Question representing the last_question that was asked at the time
    70|             the interrupt was raised.
    71|         template:
    72|             Template that was being processed for answers.
    73|     """
    74|     def __init__(
    75|         self, answers: AnswersMap, last_question: Question, template: Template
    76|     ) -> None:
    77|         self.answers = answers
    78|         self.last_question = last_question
    79|         self.template = template
    80| class UnsafeTemplateError(CopierError):
    81|     """Unsafe Copier template features are used without explicit consent."""
    82|     def __init__(self, features: Sequence[str]):
    83|         assert features
    84|         s = "s" if len(features) > 1 else ""
    85|         super().__init__(
    86|             f"Template uses potentially unsafe feature{s}: {', '.join(features)}.\n"
    87|             "If you trust this template, consider adding the `--trust` option when running `copier copy/update`."
    88|         )
    89| class YieldTagInFileError(CopierError):
    90|     """A yield tag is used in the file content, but it is not allowed."""
    91| class MultipleYieldTagsError(CopierError):
    92|     """Multiple yield tags are used in one path name, but it is not allowed."""
    93| class TaskError(subprocess.CalledProcessError, UserMessageError):
    94|     """Exception raised when a task fails."""
    95|     def __init__(
    96|         self,
    97|         command: str | Sequence[str],
    98|         returncode: int,
    99|         stdout: str | bytes | None,
   100|         stderr: str | bytes | None,
   101|     ):
   102|         subprocess.CalledProcessError.__init__(
   103|             self, returncode=returncode, cmd=command, output=stdout, stderr=stderr
   104|         )
   105|         message = f"Task {command!r} returned non-zero exit status {returncode}."
   106|         UserMessageError.__init__(self, message)
   107|     @classmethod
   108|     def from_process(
   109|         cls, process: CompletedProcess[str] | CompletedProcess[bytes]
   110|     ) -> Self:
   111|         """Create a TaskError from a CompletedProcess."""
   112|         return cls(
   113|             command=process.args,
   114|             returncode=process.returncode,
   115|             stdout=process.stdout,
   116|             stderr=process.stderr,
   117|         )
   118| class CopierWarning(Warning):
   119|     """Base class for all other Copier warnings."""
   120| class UnknownCopierVersionWarning(UserWarning, CopierWarning):
   121|     """Cannot determine installed Copier version."""
   122| class OldTemplateWarning(UserWarning, CopierWarning):
   123|     """Template was designed for an older Copier version."""
   124| class DirtyLocalWarning(UserWarning, CopierWarning):
   125|     """Changes and untracked files present in template."""
   126| class ShallowCloneWarning(UserWarning, CopierWarning):
   127|     """The template repository is a shallow clone."""
   128| class MissingSettingsWarning(UserWarning, CopierWarning):
   129|     """Settings path has been defined but file is missing."""
   130| class MissingFileWarning(UserWarning, CopierWarning):
   131|     """I still couldn't find what I'm looking for."""
   132| class InteractiveSessionError(UserMessageError):
   133|     """An interactive session is required to run this program."""
   134|     def __init__(self, message: str) -> None:
   135|         super().__init__(f"Interactive session required: {message}")


# ====================================================================
# FILE: devtasks.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-49 ---
     1| """Development helper tasks."""
     2| import logging
     3| from pathlib import Path
     4| from plumbum import TEE, CommandNotFound, ProcessExecutionError, local
     5| _logger = logging.getLogger(__name__)
     6| HERE = Path(__file__).parent
     7| def dev_setup() -> None:
     8|     """Set up a development environment."""
     9|     with local.cwd(HERE):
    10|         local["direnv"]("allow")
    11|         local["uv"]("sync", "--frozen")
    12| def lint() -> None:
    13|     """Lint and format the project."""
    14|     args = [
    15|         "run",
    16|         "--",
    17|         "uv",
    18|         "run",
    19|         "pre-commit",
    20|         "run",
    21|         "--color=always",
    22|         "--all-files",
    23|     ]
    24|     try:
    25|         local["devbox"].with_cwd(HERE)[args] & TEE
    26|     except CommandNotFound:
    27|         _logger.warning("Devbox not found; fallback to a container")
    28|         runner = local.get("podman", "docker")
    29|         try:
    30|             (
    31|                 runner[
    32|                     "container",
    33|                     "create",
    34|                     "--name=copier-lint-v1",
    35|                     f"--volume={HERE}:{HERE}:rw,z",
    36|                     f"--workdir={HERE}",
    37|                     "docker.io/jetpackio/devbox:0.15.1",
    38|                     "devbox",
    39|                 ][args]
    40|                 & TEE
    41|             )
    42|         except ProcessExecutionError:
    43|             _logger.info(
    44|                 "Couldn't create copier-lint-v1 container, probably because a previous one exists. "
    45|                 "Remove it if you want to recycle it. Otherwise, this is OK."
    46|             )
    47|         runner["container", "start", "--attach", "copier-lint-v1"] & TEE
    48|     except ProcessExecutionError as error:
    49|         raise SystemExit(error.errno)

