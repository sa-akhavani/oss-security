--- a/copier/_main.py
+++ b//dev/null
@@ -1,1229 +0,0 @@
-"""Main functions and classes, used to generate or update projects."""
-from __future__ import annotations
-import os
-import platform
-import subprocess
-import sys
-from collections.abc import Iterable, Mapping, Sequence
-from contextlib import suppress
-from contextvars import ContextVar
-from dataclasses import field, replace
-from filecmp import dircmp
-from functools import cached_property, partial, wraps
-from itertools import chain
-from pathlib import Path, PurePath, PurePosixPath, PureWindowsPath
-from shutil import rmtree
-from tempfile import TemporaryDirectory
-from types import TracebackType
-from typing import (
-    Any,
-    Callable,
-    Literal,
-    TypeVar,
-    get_args,
-    overload,
-)
-from unicodedata import normalize
-from jinja2.loaders import FileSystemLoader
-from pathspec import PathSpec
-from plumbum import ProcessExecutionError, colors
-from plumbum.machines import local
-from pydantic import ConfigDict, PositiveInt
-from pydantic.dataclasses import dataclass
-from pydantic_core import to_jsonable_python
-from questionary import confirm, unsafe_prompt
-from ._jinja_ext import YieldEnvironment, YieldExtension
-from ._subproject import Subproject
-from ._template import Task, Template
-from ._tools import (
-    OS,
-    Style,
-    cast_to_bool,
-    escape_git_path,
-    normalize_git_path,
-    printf,
-    scantree,
-    set_git_alternates,
-)
-from ._types import (
-    MISSING,
-    AnyByStrDict,
-    AnyByStrMutableMapping,
-    JSONSerializable,
-    LazyDict,
-    Operation,
-    ParamSpec,
-    Phase,
-    RelativePath,
-    StrOrPath,
-    VcsRef,
-)
-from ._user_data import AnswersMap, Question, load_answersfile_data
-from ._vcs import get_git
-from .errors import (
-    CopierAnswersInterrupt,
-    ExtensionNotFoundError,
-    ForbiddenPathError,
-    InteractiveSessionError,
-    TaskError,
-    UnsafeTemplateError,
-    UserMessageError,
-    YieldTagInFileError,
-)
-from .settings import Settings
-_T = TypeVar("_T")
-_P = ParamSpec("_P")
-_operation: ContextVar[Operation] = ContextVar("_operation")
-def as_operation(value: Operation) -> Callable[[Callable[_P, _T]], Callable[_P, _T]]:
-    """Decorator to set the current operation context, if not defined already.
-    This value is used to template specific configuration options.
-    """
-    def _decorator(func: Callable[_P, _T]) -> Callable[_P, _T]:
-        @wraps(func)
-        def _wrapper(*args: _P.args, **kwargs: _P.kwargs) -> _T:
-            token = _operation.set(_operation.get(value))
-            try:
-                return func(*args, **kwargs)
-            finally:
-                _operation.reset(token)
-        return _wrapper
-    return _decorator
-@dataclass(config=ConfigDict(extra="forbid"))
-class Worker:
-    """Copier process state manager.
-    This class represents the state of a copier work, and contains methods to
-    actually produce the desired work.
-    To use it properly, use it as a context manager and fill all dataclass fields.
-    Then, execute one of its main methods, which are prefixed with `run_`:
-    -   [run_copy][copier.main.Worker.run_copy] to copy a subproject.
-    -   [run_recopy][copier.main.Worker.run_recopy] to recopy a subproject.
-    -   [run_update][copier.main.Worker.run_update] to update a subproject.
-    Example:
-        ```python
-        with Worker(
-            src_path="https://github.com/copier-org/autopretty.git", "output"
-        ) as worker:
-            worker.run_copy()
-        ```
-    Attributes:
-        src_path:
-            String that can be resolved to a template path, be it local or remote.
-            See [copier.vcs.get_repo][].
-            If it is `None`, then it means that you are
-            [updating a project][updating-a-project], and the original
-            `src_path` will be obtained from
-            [the answers file][the-copier-answersyml-file].
-        dst_path:
-            Destination path where to render the subproject.
-        answers_file:
-            Indicates the path for [the answers file][the-copier-answersyml-file].
-            The path must be relative to `dst_path`.
-            If it is `None`, the default value will be obtained from
-            [copier.template.Template.answers_relpath][].
-        vcs_ref:
-            Specify the VCS tag/commit to use in the template.
-        data:
-            Answers to the questionnaire defined in the template.
-        exclude:
-            User-chosen additional [file exclusion patterns][exclude].
-        use_prereleases:
-            Consider prereleases when detecting the *latest* one?
-            See [use_prereleases][].
-            Useless if specifying a [vcs_ref][].
-        skip_if_exists:
-            User-chosen additional [file skip patterns][skip_if_exists].
-        cleanup_on_error:
-            Delete `dst_path` if there's an error?
-            See [cleanup_on_error][].
-        defaults:
-            When `True`, use default answers to questions, which might be null if not specified.
-            See [defaults][].
-        user_defaults:
-            Specify user defaults that may override a template's defaults during question prompts.
-        overwrite:
-            When `True`, Overwrite files that already exist, without asking.
-            See [overwrite][].
-        pretend:
-            When `True`, produce no real rendering.
-            See [pretend][].
-        quiet:
-            When `True`, disable all output.
-            See [quiet][].
-        conflict:
-            One of "inline" (default), "rej".
-        context_lines:
-            Lines of context to consider when solving conflicts in updates.
-            With more lines, context resolution is more accurate, but it will
-            also produce more conflicts if your subproject has evolved.
-            With less lines, context resolution is less accurate, but it will
-            respect better the evolution of your subproject.
-        unsafe:
-            When `True`, allow usage of unsafe templates.
-            See [unsafe][]
-        skip_answered:
-            When `True`, skip questions that have already been answered.
-        skip_tasks:
-            When `True`, skip template tasks execution.
-    """
-    src_path: str | None = None
-    dst_path: Path = Path()
-    answers_file: RelativePath | None = None
-    vcs_ref: str | VcsRef | None = None
-    data: AnyByStrDict = field(default_factory=dict)
-    settings: Settings = field(default_factory=Settings.from_file)
-    exclude: Sequence[str] = ()
-    use_prereleases: bool = False
-    skip_if_exists: Sequence[str] = ()
-    cleanup_on_error: bool = True
-    defaults: bool = False
-    user_defaults: AnyByStrDict = field(default_factory=dict)
-    overwrite: bool = False
-    pretend: bool = False
-    quiet: bool = False
-    conflict: Literal["inline", "rej"] = "inline"
-    context_lines: PositiveInt = 3
-    unsafe: bool = False
-    skip_answered: bool = False
-    skip_tasks: bool = False
-    answers: AnswersMap = field(default_factory=AnswersMap, init=False)
-    _cleanup_hooks: list[Callable[[], None]] = field(default_factory=list, init=False)
-    def __enter__(self) -> Worker:
-        """Allow using worker as a context manager."""
-        return self
-    @overload
-    def __exit__(self, type: None, value: None, traceback: None) -> None: ...
-    @overload
-    def __exit__(
-        self, type: type[BaseException], value: BaseException, traceback: TracebackType
-    ) -> None: ...
-    def __exit__(
-        self,
-        type: type[BaseException] | None,
-        value: BaseException | None,
-        traceback: TracebackType | None,
-    ) -> None:
-        """Clean up garbage files after worker usage ends."""
-        if value is not None:
-            with suppress(Exception):
-                self._cleanup()
-            raise value
-        self._cleanup()
-    def _cleanup(self) -> None:
-        """Execute all stored cleanup methods."""
-        for method in self._cleanup_hooks:
-            method()
-    def _check_unsafe(self, mode: Operation) -> None:
-        """Check whether a template uses unsafe features."""
-        if self.unsafe or self.settings.is_trusted(self.template.url):
-            return
-        features: set[str] = set()
-        if self.template.jinja_extensions:
-            features.add("jinja_extensions")
-        if self.template.tasks and not self.skip_tasks:
-            features.add("tasks")
-        if mode == "update" and self.subproject.template:
-            if self.subproject.template.jinja_extensions:
-                features.add("jinja_extensions")
-            if self.subproject.template.tasks:
-                features.add("tasks")
-            for stage in get_args(Literal["before", "after"]):
-                if self.template.migration_tasks(stage, self.subproject.template):
-                    features.add("migrations")
-                    break
-        if features:
-            raise UnsafeTemplateError(sorted(features))
-    def _external_data(self) -> LazyDict[str, Any]:
-        """Load external data lazily.
-        Result keys are used for rendering, and values are the parsed contents
-        of the YAML files specified in [external_data][].
-        Files will only be parsed lazily on 1st access. This helps avoiding
-        circular dependencies when the file name also comes from a variable.
-        """
-        def _render(path: str) -> str:
-            with Phase.use(Phase.UNDEFINED):
-                return self._render_string(path)
-        return LazyDict(
-            {
-                name: lambda path=path: load_answersfile_data(  # type: ignore[misc]
-                    self.dst_path, _render(path), warn_on_missing=True
-                )
-                for name, path in self.template.external_data.items()
-            }
-        )
-    def _print_message(self, message: str) -> None:
-        if message and not self.quiet:
-            print(self._render_string(message), file=sys.stderr)
-    def _answers_to_remember(self) -> Mapping[str, Any]:
-        """Get only answers that will be remembered in the copier answers file."""
-        answers: AnyByStrDict = {}
-        commit = self.template.commit
-        src = self.template.url
-        for key, value in (("_commit", commit), ("_src_path", src)):
-            if value is not None:
-                answers[key] = value
-        answers.update(
-            (str(k), v)
-            for (k, v) in self.answers.combined.items()
-            if not k.startswith("_")
-            and k not in self.answers.hidden
-            and k not in self.template.secret_questions
-            and k in self.template.questions_data
-            and isinstance(k, JSONSerializable)
-            and isinstance(v, JSONSerializable)
-        )
-        return answers
-    def _execute_tasks(self, tasks: Sequence[Task]) -> None:
-        """Run the given tasks.
-        Arguments:
-            tasks: The list of tasks to run.
-        """
-        operation = _operation.get()
-        for i, task in enumerate(tasks):
-            extra_context = {f"_{k}": v for k, v in task.extra_vars.items()}
-            extra_context["_copier_operation"] = operation
-            if not cast_to_bool(self._render_value(task.condition, extra_context)):
-                continue
-            task_cmd = task.cmd
-            if isinstance(task_cmd, str):
-                task_cmd = self._render_string(task_cmd, extra_context)
-                use_shell = True
-            else:
-                task_cmd = [
-                    self._render_string(str(part), extra_context) for part in task_cmd
-                ]
-                use_shell = False
-            if not self.quiet:
-                print(
-                    colors.info
-                    | f" > Running task {i + 1} of {len(tasks)}: {task_cmd}",
-                    file=sys.stderr,
-                )
-            if self.pretend:
-                continue
-            working_directory = (
-                self.subproject.local_abspath
-                / Path(self._render_string(str(task.working_directory), extra_context))
-            ).absolute()
-            extra_env = {k[1:].upper(): str(v) for k, v in extra_context.items()}
-            with local.cwd(working_directory), local.env(**extra_env):
-                process = subprocess.run(task_cmd, shell=use_shell, env=local.env)
-                if process.returncode:
-                    raise TaskError.from_process(process)
-    def _render_context(self) -> AnyByStrMutableMapping:
-        """Produce render context for Jinja."""
-        conf = LazyDict(
-            {
-                "src_path": lambda: PurePath(self.template.local_abspath),
-                "dst_path": lambda: PurePath(self.dst_path),
-                "answers_file": lambda: PurePath(self.answers_relpath),
-                "vcs_ref": lambda: self.resolved_vcs_ref,
-                "vcs_ref_hash": lambda: self.template.commit_hash,
-                "data": lambda: self.data,
-                "settings": lambda: self.settings,
-                "exclude": lambda: self.exclude,
-                "use_prereleases": lambda: self.use_prereleases,
-                "skip_if_exists": lambda: self.skip_if_exists,
-                "cleanup_on_error": lambda: self.cleanup_on_error,
-                "defaults": lambda: self.defaults,
-                "user_defaults": lambda: self.user_defaults,
-                "overwrite": lambda: self.overwrite,
-                "pretend": lambda: self.pretend,
-                "quiet": lambda: self.quiet,
-                "conflict": lambda: self.conflict,
-                "context_lines": lambda: self.context_lines,
-                "unsafe": lambda: self.unsafe,
-                "skip_answered": lambda: self.skip_answered,
-                "skip_tasks": lambda: self.skip_tasks,
-                "sep": lambda: os.sep,
-                "os": lambda: OS,
-            }
-        )
-        return dict(
-            **self.answers.combined,
-            _copier_answers=self._answers_to_remember(),
-            _copier_conf=conf,
-            _folder_name=self.subproject.local_abspath.name,
-            _copier_python=sys.executable,
-            _copier_phase=Phase.current(),
-        )
-    def _path_matcher(self, patterns: Iterable[str]) -> Callable[[Path], bool]:
-        """Produce a function that matches against specified patterns."""
-        normalized_patterns = (normalize("NFD", pattern) for pattern in patterns)
-        spec = PathSpec.from_lines("gitwildmatch", normalized_patterns)
-        return spec.match_file
-    def _solve_render_conflict(self, dst_relpath: Path) -> bool:
-        """Properly solve render conflicts.
-        It can ask the user if running in interactive mode.
-        """
-        assert not dst_relpath.is_absolute()
-        printf(
-            "conflict",
-            dst_relpath,
-            style=Style.DANGER,
-            quiet=self.quiet,
-            file_=sys.stderr,
-        )
-        if self.match_skip(dst_relpath):
-            printf(
-                "skip",
-                dst_relpath,
-                style=Style.OK,
-                quiet=self.quiet,
-                file_=sys.stderr,
-            )
-            return False
-        if self.overwrite or dst_relpath == self.answers_relpath:
-            printf(
-                "overwrite",
-                dst_relpath,
-                style=Style.WARNING,
-                quiet=self.quiet,
-                file_=sys.stderr,
-            )
-            return True
-        try:
-            answer = confirm(f" Overwrite {dst_relpath}?", default=True).unsafe_ask()
-        except EOFError as err:
-            raise InteractiveSessionError("Consider using `--overwrite`") from err
-        return bool(answer)
-    def _render_allowed(
-        self,
-        dst_relpath: Path,
-        is_dir: bool = False,
-        is_symlink: bool = False,
-        expected_contents: bytes | Path = b"",
-    ) -> bool:
-        """Determine if a file or directory can be rendered.
-        Args:
-            dst_relpath:
-                Relative path to destination.
-            is_dir:
-                Indicate if the path must be treated as a directory or not.
-            is_symlink:
-                Indicate if the path must be treated as a symlink or not.
-            expected_contents:
-                Used to compare existing file contents with them. Allows to know if
-                rendering is needed.
-        """
-        assert not dst_relpath.is_absolute()
-        assert not expected_contents or not is_dir, "Dirs cannot have expected content"
-        dst_abspath = Path(self.subproject.local_abspath, dst_relpath)
-        previous_is_symlink = dst_abspath.is_symlink()
-        try:
-            previous_content: bytes | Path
-            if previous_is_symlink:
-                previous_content = dst_abspath.readlink()
-            else:
-                previous_content = dst_abspath.read_bytes()
-        except FileNotFoundError:
-            printf(
-                "create",
-                dst_relpath,
-                style=Style.OK,
-                quiet=self.quiet,
-                file_=sys.stderr,
-            )
-            return True
-        except PermissionError as error:
-            if not (error.errno == 13 and platform.system() == "Windows"):
-                raise
-        except IsADirectoryError:
-            assert is_dir
-        if is_dir or (
-            previous_content == expected_contents and previous_is_symlink == is_symlink
-        ):
-            printf(
-                "identical",
-                dst_relpath,
-                style=Style.IGNORE,
-                quiet=self.quiet,
-                file_=sys.stderr,
-            )
-            return is_dir
-        return self._solve_render_conflict(dst_relpath)
-    def _ask(self) -> None:  # noqa: C901
-        """Ask the questions of the questionnaire and record their answers."""
-        self.answers = AnswersMap(
-            user_defaults=self.user_defaults,
-            init=self.data,
-            last=self.subproject.last_answers,
-            metadata=self.template.metadata,
-            external=self._external_data(),
-        )
-        for var_name, details in self.template.questions_data.items():
-            question = Question(
-                answers=self.answers,
-                context=self._render_context(),
-                jinja_env=self.jinja_env,
-                settings=self.settings,
-                var_name=var_name,
-                **details,
-            )
-            if var_name in self.answers.last:
-                try:
-                    answer = question.parse_answer(self.answers.last[var_name])
-                    question.validate_answer(answer)
-                except Exception:
-                    del self.answers.last[var_name]
-            if not question.get_when():
-                self.answers.hide(var_name)
-                if var_name in self.answers.last:
-                    del self.answers.last[var_name]
-                if question.default is MISSING:
-                    continue
-            if var_name in self.answers.init:
-                answer = question.parse_answer(self.answers.init[var_name])
-                question.validate_answer(answer)
-                self.answers.user[var_name] = answer
-                continue
-            if self.skip_answered and var_name in self.answers.last:
-                continue
-            try:
-                if self.defaults:
-                    new_answer = question.get_default()
-                    if new_answer is MISSING:
-                        raise ValueError(f'Question "{var_name}" is required')
-                else:
-                    try:
-                        new_answer = unsafe_prompt(
-                            [question.get_questionary_structure()],
-                            answers={question.var_name: question.get_default()},
-                        )[question.var_name]
-                    except EOFError as err:
-                        raise InteractiveSessionError(
-                            "Use `--defaults` and/or `--data`/`--data-file`"
-                        ) from err
-            except KeyboardInterrupt as err:
-                raise CopierAnswersInterrupt(
-                    self.answers, question, self.template
-                ) from err
-            self.answers.user[var_name] = new_answer
-        self.answers.external = self._external_data()
-    @property
-    def answers_relpath(self) -> Path:
-        """Obtain the proper relative path for the answers file.
-        It comes from:
-        1. User choice.
-        2. Template default.
-        3. Copier default.
-        """
-        path = self.answers_file or self.template.answers_relpath
-        template = self.jinja_env.from_string(str(path))
-        context = self._render_context()
-        context["_copier_conf"]["answers_file"] = ""
-        return Path(template.render(**context))
-    @cached_property
-    def all_exclusions(self) -> Sequence[str]:
-        """Combine default, template and user-chosen exclusions."""
-        return self.template.exclude + tuple(self.exclude)
-    @cached_property
-    def jinja_env(self) -> YieldEnvironment:
-        """Return a pre-configured Jinja environment.
-        Respects template settings.
-        """
-        paths = [str(self.template.local_abspath)]
-        loader = FileSystemLoader(paths)
-        default_extensions = [
-            "jinja2_ansible_filters.AnsibleCoreFiltersExtension",
-            YieldExtension,
-        ]
-        extensions = default_extensions + list(self.template.jinja_extensions)
-        try:
-            env = YieldEnvironment(
-                loader=loader, extensions=extensions, **self.template.envops
-            )
-        except ModuleNotFoundError as error:
-            raise ExtensionNotFoundError(
-                f"Copier could not load some Jinja extensions:\n{error}\n"
-                "Make sure to install these extensions alongside Copier itself.\n"
-                "See the docs at https://copier.readthedocs.io/en/latest/configuring/#jinja_extensions"
-            )
-        def to_json_fallback(value: Any) -> Any:
-            if isinstance(value, LazyDict):
-                return dict(value)
-            if isinstance(value, PurePath):
-                return str(value)
-            return value
-        env.filters["to_json"] = partial(
-            env.filters["to_json"],
-            default=partial(to_jsonable_python, fallback=to_json_fallback),
-        )
-        path_type = {
-            "posix": PurePosixPath,
-            "windows": PureWindowsPath,
-            "native": PurePath,
-        }
-        def _pathjoin(
-            *path: str, mode: Literal["posix", "windows", "native"] = "posix"
-        ) -> str:
-            return str(path_type[mode](*path))
-        env.globals["pathjoin"] = _pathjoin
-        return env
-    @cached_property
-    def match_exclude(self) -> Callable[[Path], bool]:
-        """Get a callable to match paths against all exclusions."""
-        extra_context = {"_copier_operation": _operation.get()}
-        return self._path_matcher(
-            self._render_string(exclusion, extra_context=extra_context)
-            for exclusion in self.all_exclusions
-        )
-    @cached_property
-    def match_skip(self) -> Callable[[Path], bool]:
-        """Get a callable to match paths against all skip-if-exists patterns."""
-        return self._path_matcher(
-            map(
-                self._render_string,
-                tuple(chain(self.skip_if_exists, self.template.skip_if_exists)),
-            )
-        )
-    def _render_template(self) -> None:
-        """Render the template in the subproject root."""
-        follow_symlinks = not self.template.preserve_symlinks
-        cwd = Path.cwd()
-        for src in scantree(str(self.template_copy_root), follow_symlinks):
-            src_abspath = Path(src.path)
-            src_relpath = Path(src_abspath).relative_to(self.template.local_abspath)
-            dst_relpaths_ctxs = self._render_path(
-                Path(src_abspath).relative_to(self.template_copy_root)
-            )
-            for dst_relpath, ctx in dst_relpaths_ctxs:
-                if not cwd.joinpath(dst_relpath).resolve().is_relative_to(cwd):
-                    raise ForbiddenPathError(path=dst_relpath)
-                if self.match_exclude(dst_relpath):
-                    continue
-                if src.is_symlink() and self.template.preserve_symlinks:
-                    self._render_symlink(src_relpath, dst_relpath)
-                elif src.is_dir(follow_symlinks=follow_symlinks):
-                    self._render_folder(dst_relpath)
-                else:
-                    self._render_file(src_relpath, dst_relpath, extra_context=ctx or {})
-    def _render_file(
-        self,
-        src_relpath: Path,
-        dst_relpath: Path,
-        extra_context: AnyByStrDict | None = None,
-    ) -> None:
-        """Render one file.
-        Args:
-            src_relpath:
-                File to be rendered. It must be a path relative to the template
-                root.
-            dst_relpath:
-                File to be created. It must be a path relative to the subproject
-                root.
-            extra_context:
-                Additional variables to use for rendering the template.
-        """
-        assert not src_relpath.is_absolute()
-        assert not dst_relpath.is_absolute()
-        src_abspath = self.template.local_abspath / src_relpath
-        if src_relpath.name.endswith(self.template.templates_suffix):
-            try:
-                tpl = self.jinja_env.get_template(src_relpath.as_posix())
-            except UnicodeDecodeError:
-                if self.template.templates_suffix:
-                    raise
-                new_content = src_abspath.read_bytes()
-            else:
-                new_content = tpl.render(
-                    **self._render_context(), **(extra_context or {})
-                ).encode()
-                if self.jinja_env.yield_name:
-                    raise YieldTagInFileError(
-                        f"File {src_relpath} contains a yield tag, but it is not allowed."
-                    )
-        else:
-            new_content = src_abspath.read_bytes()
-        dst_abspath = self.subproject.local_abspath / dst_relpath
-        src_mode = src_abspath.stat().st_mode
-        if not self._render_allowed(dst_relpath, expected_contents=new_content):
-            return
-        if not self.pretend:
-            dst_abspath.parent.mkdir(parents=True, exist_ok=True)
-            if dst_abspath.is_symlink():
-                dst_abspath.unlink()
-            dst_abspath.write_bytes(new_content)
-            dst_abspath.chmod(src_mode)
-    def _render_symlink(self, src_relpath: Path, dst_relpath: Path) -> None:
-        """Render one symlink.
-        Args:
-            src_relpath:
-                Symlink to be rendered. It must be a path relative to the
-                template root.
-            dst_relpath:
-                Symlink to be created. It must be a path relative to the
-                subproject root.
-        """
-        assert not src_relpath.is_absolute()
-        assert not dst_relpath.is_absolute()
-        if dst_relpath is None or self.match_exclude(dst_relpath):
-            return
-        src_abspath = self.template.local_abspath / src_relpath
-        src_target = src_abspath.readlink()
-        if src_abspath.name.endswith(self.template.templates_suffix):
-            dst_target = Path(self._render_string(str(src_target)))
-        else:
-            dst_target = src_target
-        if not self._render_allowed(
-            dst_relpath,
-            expected_contents=dst_target,
-            is_symlink=True,
-        ):
-            return
-        if not self.pretend:
-            dst_abspath = self.subproject.local_abspath / dst_relpath
-            if dst_abspath.is_symlink() or dst_abspath.exists():
-                dst_abspath.unlink()
-            dst_abspath.parent.mkdir(parents=True, exist_ok=True)
-            dst_abspath.symlink_to(dst_target)
-            if sys.platform == "darwin":
-                src_mode = src_abspath.lstat().st_mode
-                dst_abspath.lchmod(src_mode)
-    def _render_folder(self, dst_relpath: Path) -> None:
-        """Create one folder (without content).
-        Args:
-            dst_relpath:
-                Folder to be created. It must be a path relative to the
-                subproject root.
-        """
-        assert not dst_relpath.is_absolute()
-        if not self.pretend and self._render_allowed(dst_relpath, is_dir=True):
-            dst_abspath = self.subproject.local_abspath / dst_relpath
-            dst_abspath.mkdir(parents=True, exist_ok=True)
-    def _adjust_rendered_part(self, rendered_part: str) -> str:
-        """Adjust the rendered part if necessary.
-        If `{{ _copier_conf.answers_file }}` becomes the full path,
-        restore part to be just the end leaf.
-        Args:
-            rendered_part:
-                The rendered part of the path to adjust.
-        """
-        if str(self.answers_relpath) == rendered_part:
-            return Path(rendered_part).name
-        return rendered_part
-    def _render_parts(
-        self,
-        parts: tuple[str, ...],
-        rendered_parts: tuple[str, ...] | None = None,
-        extra_context: AnyByStrDict | None = None,
-        is_template: bool = False,
-    ) -> Iterable[tuple[Path, AnyByStrDict | None]]:
-        """Render a set of parts into path and context pairs.
-        If a yield tag is found in a part, it will recursively yield multiple path and context pairs.
-        """
-        if rendered_parts is None:
-            rendered_parts = tuple()
-        if not parts:
-            rendered_path = Path(*rendered_parts)
-            templated_sibling = (
-                self.template.local_abspath
-                / f"{rendered_path}{self.template.templates_suffix}"
-            )
-            if is_template or not templated_sibling.exists():
-                yield rendered_path, extra_context
-            return
-        part = parts[0]
-        parts = parts[1:]
-        if not extra_context:
-            extra_context = {}
-        rendered_part = self._render_string(part, extra_context=extra_context)
-        yield_name = self.jinja_env.yield_name
-        if yield_name:
-            for value in self.jinja_env.yield_iterable or ():
-                new_context = {**extra_context, yield_name: value}
-                rendered_part = self._render_string(part, extra_context=new_context)
-                rendered_part = self._adjust_rendered_part(rendered_part)
-                if not rendered_part:
-                    continue
-                yield from self._render_parts(
-                    parts, rendered_parts + (rendered_part,), new_context, is_template
-                )
-            return
-        if not rendered_part:
-            return
-        rendered_part = self._adjust_rendered_part(rendered_part)
-        yield from self._render_parts(
-            parts, rendered_parts + (rendered_part,), extra_context, is_template
-        )
-    def _render_path(self, relpath: Path) -> Iterable[tuple[Path, AnyByStrDict | None]]:
-        """Render one relative path into multiple path and context pairs.
-        Args:
-            relpath:
-                The relative path to be rendered. Obviously, it can be templated.
-        """
-        is_template = relpath.name.endswith(self.template.templates_suffix)
-        templated_sibling = (
-            self.template_copy_root / f"{relpath}{self.template.templates_suffix}"
-        )
-        if templated_sibling.exists() and self.template.templates_suffix:
-            return
-        if self.template.templates_suffix and is_template:
-            relpath = relpath.with_suffix("")
-        yield from self._render_parts(relpath.parts, is_template=is_template)
-    def _render_string(
-        self, string: str, extra_context: AnyByStrDict | None = None
-    ) -> str:
-        """Render one templated string.
-        Args:
-            string:
-                The template source string.
-            extra_context:
-                Additional variables to use for rendering the template.
-        """
-        tpl = self.jinja_env.from_string(string)
-        return tpl.render(**self._render_context(), **(extra_context or {}))
-    def _render_value(
-        self, value: _T, extra_context: AnyByStrDict | None = None
-    ) -> str | _T:
-        """Render a value, which may or may not be a templated string.
-        Args:
-            value:
-                The value to render.
-            extra_context:
-                Additional variables to use for rendering the template.
-        """
-        try:
-            return self._render_string(value, extra_context=extra_context)  # type: ignore[arg-type]
-        except TypeError:
-            return value
-    @cached_property
-    def resolved_vcs_ref(self) -> str | None:
-        """Get the resolved VCS reference to use.
-        This is either `vcs_ref` or the subproject template ref
-        if `vcs_ref` is `VcsRef.CURRENT`.
-        """
-        if self.vcs_ref is VcsRef.CURRENT:
-            if self.subproject.template is None:
-                raise TypeError("Template not found")
-            return self.subproject.template.ref
-        return self.vcs_ref
-    @cached_property
-    def subproject(self) -> Subproject:
-        """Get related subproject."""
-        result = Subproject(
-            local_abspath=self.dst_path.absolute(),
-            answers_relpath=self.answers_file or Path(".copier-answers.yml"),
-        )
-        self._cleanup_hooks.append(result._cleanup)
-        return result
-    @cached_property
-    def template(self) -> Template:
-        url = self.src_path
-        if not url:
-            if self.subproject.template is None:
-                raise TypeError("Template not found")
-            url = str(self.subproject.template.url)
-        ref = self.resolved_vcs_ref
-        result = Template(url=url, ref=ref, use_prereleases=self.use_prereleases)
-        self._cleanup_hooks.append(result._cleanup)
-        return result
-    @cached_property
-    def template_copy_root(self) -> Path:
-        """Absolute path from where to start copying.
-        It points to the cloned template local abspath + the rendered subdir, if any.
-        """
-        subdir = self._render_string(self.template.subdirectory) or ""
-        return self.template.local_abspath / subdir
-    @as_operation("copy")
-    def run_copy(self) -> None:
-        """Generate a subproject from zero, ignoring what was in the folder.
-        If `dst_path` was missing, it will be
-        created. Otherwise, `src_path` be rendered
-        directly into it, without worrying about evolving what was there
-        already.
-        See [generating a project][generating-a-project].
-        """
-        with suppress(AttributeError):
-            del self.match_exclude
-        self._check_unsafe("copy")
-        self._print_message(self.template.message_before_copy)
-        with Phase.use(Phase.PROMPT):
-            self._ask()
-        was_existing = self.subproject.local_abspath.exists()
-        try:
-            if not self.quiet:
-                print(
-                    f"\nCopying from template version {self.template.version}",
-                    file=sys.stderr,
-                )
-            with Phase.use(Phase.RENDER):
-                self._render_template()
-            if not self.quiet:
-                print("")  # padding space
-            if not self.skip_tasks:
-                with Phase.use(Phase.TASKS):
-                    self._execute_tasks(self.template.tasks)
-        except Exception:
-            if not was_existing and self.cleanup_on_error:
-                rmtree(self.subproject.local_abspath)
-            raise
-        self._print_message(self.template.message_after_copy)
-        if not self.quiet:
-            print("")  # padding space
-    @as_operation("copy")
-    def run_recopy(self) -> None:
-        """Update a subproject, keeping answers but discarding evolution."""
-        if self.subproject.template is None:
-            raise UserMessageError(
-                "Cannot recopy because cannot obtain old template references "
-                f"from `{self.subproject.answers_relpath}`."
-            )
-        with replace(self, src_path=self.subproject.template.url) as new_worker:
-            new_worker.run_copy()
-    def _print_template_update_info(self, subproject_template: Template) -> None:
-        if not self.quiet:
-            if subproject_template.version == self.template.version:
-                message = f"Keeping template version {self.template.version}"
-            else:
-                message = f"Updating to template version {self.template.version}"
-            print(message, file=sys.stderr)
-    @as_operation("update")
-    def run_update(self) -> None:
-        """Update a subproject that was already generated.
-        See [updating a project][updating-a-project].
-        """
-        self._check_unsafe("update")
-        if self.subproject.vcs != "git":
-            raise UserMessageError(
-                "Updating is only supported in git-tracked subprojects."
-            )
-        if self.subproject.is_dirty():
-            raise UserMessageError(
-                "Destination repository is dirty; cannot continue. "
-                "Please commit or stash your local changes and retry."
-            )
-        if self.subproject.template is None or self.subproject.template.ref is None:
-            raise UserMessageError(
-                "Cannot update because cannot obtain old template references "
-                f"from `{self.subproject.answers_relpath}`."
-            )
-        if self.template.commit is None:
-            raise UserMessageError(
-                "Updating is only supported in git-tracked templates."
-            )
-        if not self.subproject.template.version:
-            raise UserMessageError(
-                "Cannot update: version from last update not detected."
-            )
-        if not self.template.version:
-            raise UserMessageError("Cannot update: version from template not detected.")
-        if self.subproject.template.version > self.template.version:
-            raise UserMessageError(
-                f"You are downgrading from {self.subproject.template.version} to {self.template.version}. "
-                "Downgrades are not supported."
-            )
-        if not self.overwrite:
-            raise UserMessageError("Enable overwrite to update a subproject.")
-        self._print_message(self.template.message_before_update)
-        self._print_template_update_info(self.subproject.template)
-        with suppress(AttributeError):
-            del self.match_exclude
-        self._apply_update()
-        self._print_message(self.template.message_after_update)
-    def _apply_update(self) -> None:  # noqa: C901
-        git = get_git()
-        subproject_top = Path(
-            git(
-                "-C",
-                self.subproject.local_abspath,
-                "rev-parse",
-                "--show-toplevel",
-            ).strip()
-        )
-        subproject_subdir = self.subproject.local_abspath.relative_to(subproject_top)
-        with (
-            TemporaryDirectory(
-                prefix=f"{__name__}.old_copy.",
-            ) as old_copy,
-            TemporaryDirectory(
-                prefix=f"{__name__}.new_copy.",
-            ) as new_copy,
-        ):
-            with replace(
-                self,
-                dst_path=old_copy / subproject_subdir,
-                data=self.subproject.last_answers,
-                defaults=True,
-                quiet=True,
-                src_path=self.subproject.template.url,  # type: ignore[union-attr]
-                vcs_ref=self.subproject.template.commit,  # type: ignore[union-attr]
-            ) as old_worker:
-                assert old_worker.template is not self.template
-                for q in old_worker.template.questions_data.values():
-                    if q.get("secret", False):
-                        q.pop("validator", None)
-                old_worker.run_copy()
-            with Phase.use(Phase.MIGRATE):
-                self._execute_tasks(
-                    self.template.migration_tasks("before", self.subproject.template)  # type: ignore[arg-type]
-                )
-            with local.cwd(subproject_top):
-                subproject_head = git("write-tree").strip()
-            with local.cwd(old_copy):
-                self._git_initialize_repo()
-                set_git_alternates(subproject_top)
-                files_removed = git(
-                    "diff-tree",
-                    "-r",
-                    "--diff-filter=D",
-                    "--name-only",
-                    "HEAD",
-                    subproject_head,
-                ).splitlines()
-                exclude_plus_removed = list(
-                    set(self.exclude).union(
-                        map(
-                            escape_git_path,
-                            map(
-                                normalize_git_path,
-                                (
-                                    path
-                                    for path in files_removed
-                                    if not self.match_skip(path)
-                                ),
-                            ),
-                        )
-                    )
-                )
-            if self.skip_answered is False:
-                self.answers = AnswersMap(external=self._external_data())
-                with suppress(AttributeError):
-                    del self.subproject.last_answers
-            with replace(
-                self,
-                exclude=exclude_plus_removed,
-                quiet=True,
-            ) as current_worker:
-                current_worker.run_copy()
-                self.answers = current_worker.answers
-                self.answers.external = self._external_data()
-            with replace(
-                self,
-                dst_path=new_copy / subproject_subdir,
-                data={
-                    k: v
-                    for k, v in self.answers.combined.items()
-                    if k not in self.answers.hidden
-                },
-                defaults=True,
-                quiet=True,
-                src_path=self.subproject.template.url,  # type: ignore[union-attr]
-                exclude=exclude_plus_removed,
-                vcs_ref=self.resolved_vcs_ref,
-            ) as new_worker:
-                new_worker.run_copy()
-            with local.cwd(new_copy):
-                self._git_initialize_repo()
-                new_copy_head = git("rev-parse", "HEAD").strip()
-            with local.cwd(old_copy):
-                set_git_alternates(subproject_top, Path(new_copy))
-                diff_added_cmd = git[
-                    "diff-tree", "-r", "--diff-filter=A", "--name-only"
-                ]
-                for filename in (
-                    set(diff_added_cmd("HEAD", subproject_head).splitlines())
-                ) & set(diff_added_cmd("HEAD", new_copy_head).splitlines()):
-                    f = Path(filename)
-                    f.parent.mkdir(parents=True, exist_ok=True)
-                    f.touch((subproject_top / filename).stat().st_mode)
-                    git("add", "--force", filename)
-                self._git_commit("add new empty files")
-                diff_cmd = git[
-                    "diff-tree",
-                    f"--unified={self.context_lines}",
-                    "HEAD",
-                    subproject_head,
-                ]
-                try:
-                    diff = diff_cmd("--inter-hunk-context=-1")
-                except ProcessExecutionError:
-                    print(
-                        colors.warn
-                        | "Make sure Git >= 2.24 is installed to improve updates.",
-                        file=sys.stderr,
-                    )
-                    diff = diff_cmd("--inter-hunk-context=0")
-            compared = dircmp(old_copy, new_copy)
-            with local.cwd(subproject_top):
-                apply_cmd = git["apply", "--reject", "--exclude", self.answers_relpath]
-                ignored_files = git["status", "--ignored", "--porcelain"]()
-                extra_exclude = [
-                    filename.split("!! ").pop()
-                    for filename in ignored_files.splitlines()
-                ]
-                for skip_pattern in chain(
-                    self.skip_if_exists, self.template.skip_if_exists, extra_exclude
-                ):
-                    apply_cmd = apply_cmd["--exclude", skip_pattern]
-                (apply_cmd << diff)(retcode=None)
-                if self.conflict == "inline":
-                    conflicted = []
-                    old_path = Path(old_copy)
-                    new_path = Path(new_copy)
-                    status = git("status", "--porcelain").strip().splitlines()
-                    for line in status:
-                        if not line.startswith("?? "):
-                            continue
-                        fname = line[3:]
-                        fname = normalize_git_path(fname)
-                        if not fname.endswith(".rej"):
-                            continue
-                        fname = fname[:-4]
-                        git("checkout", "--", fname)
-                        git(
-                            "merge-file",
-                            "-L",
-                            "before updating",
-                            "-L",
-                            "last update",
-                            "-L",
-                            "after updating",
-                            fname,
-                            old_path / fname,
-                            new_path / fname,
-                            retcode=None,
-                        )
-                        Path(f"{fname}.rej").unlink()
-                        with Path(fname).open("rb") as conflicts_candidate:
-                            if any(
-                                line.rstrip()
-                                in {
-                                    b"<<<<<<< before updating",
-                                    b">>>>>>> after updating",
-                                }
-                                for line in conflicts_candidate
-                            ):
-                                conflicted.append(fname)
-                    if conflicted:
-                        input_lines = []
-                        for line in (
-                            git("ls-files", "--stage", *conflicted).strip().splitlines()
-                        ):
-                            perms_sha_mode, path = line.split("\t")
-                            perms, sha, _ = perms_sha_mode.split()
-                            input_lines.append(f"0 {'0' * 40}\t{path}")
-                            input_lines.append(f"{perms} {sha} 2\t{path}")
-                            with suppress(ProcessExecutionError):
-                                old_sha = git(
-                                    "hash-object",
-                                    "-w",
-                                    old_path / normalize_git_path(path),
-                                ).strip()
-                                input_lines.append(f"{perms} {old_sha} 1\t{path}")
-                            with suppress(ProcessExecutionError):
-                                new_sha = git(
-                                    "hash-object",
-                                    "-w",
-                                    new_path / normalize_git_path(path),
-                                ).strip()
-                                input_lines.append(f"{perms} {new_sha} 3\t{path}")
-                        (
-                            git["update-index", "--index-info"]
-                            << "\n".join(input_lines)
-                        )()
-            _remove_old_files(subproject_top, compared)
-        with Phase.use(Phase.MIGRATE):
-            self._execute_tasks(
-                self.template.migration_tasks("after", self.subproject.template)  # type: ignore[arg-type]
-            )
-    def _git_initialize_repo(self) -> None:
-        """Initialize a git repository in the current directory."""
-        git = get_git()
-        git("init", retcode=None)
-        git("add", ".")
-        self._git_commit()
-    def _git_commit(self, message: str = "dumb commit") -> None:
-        git = get_git()
-        git(
-            "commit",
-            "--allow-empty",
-            "-am",
-            f"{message} 1",
-            "--no-gpg-sign",
-            retcode=None,
-        )
-        git(
-            "commit",
-            "--allow-empty",
-            "-am",
-            f"{message} 2",
-            "--no-gpg-sign",
-            "--no-verify",
-        )
-def run_copy(
-    src_path: str,
-    dst_path: StrOrPath = ".",
-    data: AnyByStrDict | None = None,
-    **kwargs: Any,
-) -> Worker:
-    """Copy a template to a destination, from zero.
-    This is a shortcut for [run_copy][copier.main.Worker.run_copy].
-    See [Worker][copier.main.Worker] fields to understand this function's args.
-    """
-    if data is not None:
-        kwargs["data"] = data
-    with Worker(src_path=src_path, dst_path=Path(dst_path), **kwargs) as worker:
-        worker.run_copy()
-    return worker
-def run_recopy(
-    dst_path: StrOrPath = ".", data: AnyByStrDict | None = None, **kwargs: Any
-) -> Worker:
-    """Update a subproject from its template, discarding subproject evolution.
-    This is a shortcut for [run_recopy][copier.main.Worker.run_recopy].
-    See [Worker][copier.main.Worker] fields to understand this function's args.
-    """
-    if data is not None:
-        kwargs["data"] = data
-    with Worker(dst_path=Path(dst_path), **kwargs) as worker:
-        worker.run_recopy()
-    return worker
-def run_update(
-    dst_path: StrOrPath = ".",
-    data: AnyByStrDict | None = None,
-    **kwargs: Any,
-) -> Worker:
-    """Update a subproject, from its template.
-    This is a shortcut for [run_update][copier.main.Worker.run_update].
-    See [Worker][copier.main.Worker] fields to understand this function's args.
-    """
-    if data is not None:
-        kwargs["data"] = data
-    with Worker(dst_path=Path(dst_path), **kwargs) as worker:
-        worker.run_update()
-    return worker
-def _remove_old_files(prefix: Path, cmp: dircmp[str], rm_common: bool = False) -> None:
-    """Remove files and directories only found in "old" template.
-    This is an internal helper method used to process a comparison of 2
-    directories, where the left one is considered the "old" one, and the
-    right one is the "new" one.
-    Then, it will recursively try to remove anything that is only in the old
-    directory.
-    Args:
-        prefix:
-            Where we start removing. It can be different from the directories
-            being compared.
-        cmp:
-            The comparison result.
-        rm_common:
-            Should we remove common files and directories?
-    """
-    to_rm = []
-    subdirs = {}
-    with suppress(NotADirectoryError, FileNotFoundError):
-        to_rm = cmp.left_only
-        if rm_common:
-            to_rm += cmp.common_files + cmp.common_dirs
-        subdirs = cmp.subdirs
-    for name in to_rm:
-        target = prefix / name
-        if target.is_file():
-            target.unlink()
-        else:
-            _remove_old_files(target, dircmp(Path(cmp.left, name), target), True)
-            with suppress(OSError):
-                target.rmdir()  # Raises if dir not empty
-    for key, value in subdirs.items():
-        subdir = prefix / key
-        _remove_old_files(subdir, value)
-        with suppress(OSError):
-            subdir.rmdir()  # Raises if dir not empty

--- a//dev/null
+++ b/copier/cli.py
@@ -0,0 +1,298 @@
+"""
+Command line entrypoint. This module declares the Copier CLI applications.
+Basically, there are 3 different commands you can run:
+-   [`copier`][copier.cli.CopierApp], the main app, which is a shortcut for the
+    `copy` and `update` subapps.
+    If the destination project is found and has [an answers
+    file][the-copier-answersyml-file] with enough information, it will become a
+    shortcut for `copier update`.
+    Otherwise it will be a shortcut for `copier copy`.
+    !!! example
+        ```sh
+        copier gh:copier-org/autopretty my-project
+        cd my-project
+        copier
+        ```
+-   [`copier copy`][copier.cli.CopierApp], used to bootstrap a new project from
+    a template.
+    !!! example
+        ```sh
+        copier copy gh:copier-org/autopretty my-project
+        ```
+-   [`copier update`][copier.cli.CopierUpdateSubApp] to update a preexisting
+    project to a newer version of its template.
+    !!! example
+        ```sh
+        copier update
+        ```
+Below are the docs of each one of those.
+"""
+import sys
+from functools import wraps
+from io import StringIO
+from pathlib import Path
+from textwrap import dedent
+from unittest.mock import patch
+import yaml
+from plumbum import cli, colors
+from copier.tools import copier_version
+from .errors import UserMessageError
+from .main import Worker
+from .types import AnyByStrDict, OptStr, StrSeq
+def handle_exceptions(method):
+    """Handle keyboard interruption while running a method."""
+    @wraps(method)
+    def _wrapper(*args, **kwargs):
+        try:
+            try:
+                return method(*args, **kwargs)
+            except KeyboardInterrupt:
+                raise UserMessageError("Execution stopped by user")
+        except UserMessageError as error:
+            print(colors.red | "\n".join(error.args), file=sys.stderr)
+            return 1
+    return _wrapper
+class CopierApp(cli.Application):
+    """The Copier CLI application.
+    Attributes:
+        answers_file: Set [answers_file][] option.
+        exclude: Set [exclude][] option.
+        vcs_ref: Set [vcs_ref][] option.
+        pretend: Set [pretend][] option.
+        force: Set [force][] option.
+        defaults: Set [defaults][] option.
+        overwrite: Set [overwrite][] option.
+        skip: Set [skip_if_exists][] option.
+        prereleases: Set [use_prereleases][] option.
+        quiet: Set [quiet][] option.
+    """
+    DESCRIPTION = "Create a new project from a template."
+    DESCRIPTION_MORE = (
+        dedent(
+            """\
+            Docs in https://copier.readthedocs.io/
+            """
+        )
+        + (
+            colors.yellow
+            | dedent(
+                """\
+                WARNING! Use only trusted project templates, as they might
+                execute code with the same level of access as your user.\n
+                """
+            )
+        )
+    )
+    USAGE = dedent(
+        """\
+        copier [MAIN_SWITCHES] [copy] [SUB_SWITCHES] template_src destination_path
+        copier [MAIN_SWITCHES] [update] [SUB_SWITCHES] [destination_path]
+        """
+    )
+    VERSION = copier_version()
+    CALL_MAIN_IF_NESTED_COMMAND = False
+    data: AnyByStrDict = {}
+    answers_file: cli.SwitchAttr = cli.SwitchAttr(
+        ["-a", "--answers-file"],
+        default=None,
+        help=(
+            "Update using this path (relative to `destination_path`) "
+            "to find the answers file"
+        ),
+    )
+    conflict: cli.SwitchAttr = cli.SwitchAttr(
+        ["-o", "--conflict"],
+        cli.Set("rej", "inline"),
+        default="rej",
+        help=(
+            "Behavior on conflict: rej=Create .rej file, inline=inline conflict "
+            "markers"
+        ),
+    )
+    exclude: cli.SwitchAttr = cli.SwitchAttr(
+        ["-x", "--exclude"],
+        str,
+        list=True,
+        help=(
+            "A name or shell-style pattern matching files or folders "
+            "that must not be copied"
+        ),
+    )
+    vcs_ref: cli.SwitchAttr = cli.SwitchAttr(
+        ["-r", "--vcs-ref"],
+        str,
+        help=(
+            "Git reference to checkout in `template_src`. "
+            "If you do not specify it, it will try to checkout the latest git tag, "
+            "as sorted using the PEP 440 algorithm. If you want to checkout always "
+            "the latest version, use `--vcs-ref=HEAD`."
+        ),
+    )
+    pretend: cli.Flag = cli.Flag(
+        ["-n", "--pretend"], help="Run but do not make any changes"
+    )
+    force: cli.Flag = cli.Flag(
+        ["-f", "--force"],
+        help="Same as `--defaults --overwrite`.",
+    )
+    defaults: cli.Flag = cli.Flag(
+        ["-l", "--defaults"],
+        help="Use default answers to questions, which might be null if not specified.",
+    )
+    overwrite: cli.Flag = cli.Flag(
+        ["-w", "--overwrite"],
+        help="Overwrite files that already exist, without asking.",
+    )
+    skip: cli.Flag = cli.SwitchAttr(
+        ["-s", "--skip"],
+        str,
+        list=True,
+        help="Skip specified files if they exist already",
+    )
+    quiet: cli.Flag = cli.Flag(["-q", "--quiet"], help="Suppress status output")
+    prereleases: cli.Flag = cli.Flag(
+        ["-g", "--prereleases"],
+        help="Use prereleases to compare template VCS tags.",
+    )
+    @cli.switch(
+        ["-d", "--data"],
+        str,
+        "VARIABLE=VALUE",
+        list=True,
+        help="Make VARIABLE available as VALUE when rendering the template",
+    )
+    def data_switch(self, values: StrSeq) -> None:
+        """Update [data][] with provided values.
+        Arguments:
+            values: The list of values to apply.
+                Each value in the list is of the following form: `NAME=VALUE`.
+        """
+        for arg in values:
+            key, value = arg.split("=", 1)
+            value = yaml.safe_load(value)
+            self.data[key] = value
+    def _worker(self, src_path: OptStr = None, dst_path: str = ".", **kwargs) -> Worker:
+        """
+        Run Copier's internal API using CLI switches.
+        Arguments:
+            src_path: The source path of the template to generate the project from.
+            dst_path: The path to generate the project to.
+            **kwargs: Arguments passed to [Worker][copier.main.Worker].
+        """
+        return Worker(
+            data=self.data,
+            dst_path=Path(dst_path),
+            answers_file=self.answers_file,
+            exclude=self.exclude,
+            defaults=self.force or self.defaults,
+            overwrite=self.force or self.overwrite,
+            pretend=self.pretend,
+            quiet=self.quiet,
+            src_path=src_path,
+            vcs_ref=self.vcs_ref,
+            use_prereleases=self.prereleases,
+            conflict=self.conflict,
+            **kwargs,
+        )
+    @handle_exceptions
+    def main(self, *args: str) -> int:
+        """Copier CLI app shortcuts.
+        This method redirects abstract CLI calls
+        (those that don't specify `copy` or `update`)
+        to [CopierCopySubApp.main][copier.cli.CopierCopySubApp.main]
+        or [CopierUpdateSubApp.main][copier.cli.CopierUpdateSubApp.main]
+        automatically.
+        Examples:
+            - `copier from to`  `copier copy from to`
+            - `copier from`  `copier update from`
+            - `copier`  `copier update .`
+        """
+        if args and args[0] in self._subcommands:
+            self.nested_command = (
+                self._subcommands[args[0]].subapplication,
+                ["copier %s" % args[0]] + list(args[1:]),
+            )
+        elif len(args) in {0, 1}:
+            self.nested_command = (
+                self._subcommands["update"].subapplication,
+                ["copier update"] + list(args),
+            )
+        elif len(args) == 2:
+            self.nested_command = (
+                self._subcommands["copy"].subapplication,
+                ["copier copy"] + list(args),
+            )
+        else:
+            self.help()
+            raise UserMessageError("Unsupported arguments")
+        return 0
+@CopierApp.subcommand("copy")
+class CopierCopySubApp(cli.Application):
+    """The `copier copy` subcommand.
+    Use this subcommand to bootstrap a new subproject from a template, or to override
+    a preexisting subproject ignoring its history diff.
+    Attributes:
+        cleanup_on_error: Set [cleanup_on_error][] option.
+    """
+    DESCRIPTION = "Copy from a template source to a destination."
+    cleanup_on_error: cli.Flag = cli.Flag(
+        ["-C", "--no-cleanup"],
+        default=True,
+        help="On error, do not delete destination if it was created by Copier.",
+    )
+    @handle_exceptions
+    def main(self, template_src: str, destination_path: str) -> int:
+        """Call [run_copy][copier.main.Worker.run_copy].
+        Params:
+            template_src:
+                Indicate where to get the template from.
+                This can be a git URL or a local path.
+            destination_path:
+                Where to generate the new subproject. It must not exist or be empty.
+        """
+        self.parent._worker(
+            template_src,
+            destination_path,
+            cleanup_on_error=self.cleanup_on_error,
+        ).run_copy()
+        return 0
+@CopierApp.subcommand("update")
+class CopierUpdateSubApp(cli.Application):
+    """The `copier update` subcommand.
+    Use this subcommand to update an existing subproject from a template
+    that supports updates.
+    """
+    DESCRIPTION = "Update a copy from its original template"
+    DESCRIPTION_MORE = dedent(
+        """\
+        The copy must have a valid answers file which contains info
+        from the last Copier execution, including the source template
+        (it must be a key called `_src_path`).
+        If that file contains also `_commit` and `destination_path` is a git
+        repository, this command will do its best to respect the diff that you have
+        generated since the last `copier` execution. To avoid that, use `copier copy`
+        instead.
+        """
+    )
+    @handle_exceptions
+    def main(self, destination_path: cli.ExistingDirectory = ".") -> int:
+        """Call [run_update][copier.main.Worker.run_update].
+        Parameters:
+            destination_path:
+                Only the destination path is needed to update, because the
+                `src_path` comes from [the answers file][the-copier-answersyml-file].
+                The subproject must exist. If not specified, the currently
+                working directory is used.
+        """
+        self.parent._worker(
+            dst_path=destination_path,
+        ).run_update()
+        return 0
+if __doc__:
+    help_io = StringIO()
+    with patch("sys.stdout", help_io):
+        CopierApp.run(["copier", "--help-all"], exit=False)
+    help_io.seek(0)
+    __doc__ += f"\n\nCLI help generated from `copier --help-all`:\n\n```\n{help_io.read()}\n```"
+if __name__ == "__main__":
+    CopierApp.run()

--- a/copier/errors.py
+++ b//dev/null
@@ -1,135 +0,0 @@
-"""Custom exceptions used by Copier."""
-from __future__ import annotations
-import subprocess
-import sys
-from collections.abc import Sequence
-from pathlib import Path
-from subprocess import CompletedProcess
-from typing import TYPE_CHECKING
-from ._tools import printf_exception
-from ._types import PathSeq
-if TYPE_CHECKING:  # always false
-    from ._template import Template
-    from ._user_data import AnswersMap, Question
-if sys.version_info < (3, 11):
-    from typing_extensions import Self
-else:
-    from typing import Self
-class CopierError(Exception):
-    """Base class for all other Copier errors."""
-class UserMessageError(CopierError):
-    """Exit the program giving a message to the user."""
-    def __init__(self, message: str):
-        self.message = message
-    def __str__(self) -> str:
-        return self.message
-class UnsupportedVersionError(UserMessageError):
-    """Copier version does not support template version."""
-class ConfigFileError(ValueError, CopierError):
-    """Parent class defining problems with the config file."""
-class InvalidConfigFileError(ConfigFileError):
-    """Indicates that the config file is wrong."""
-    def __init__(self, conf_path: Path, quiet: bool):
-        msg = str(conf_path)
-        printf_exception(self, "INVALID CONFIG FILE", msg=msg, quiet=quiet)
-        super().__init__(msg)
-class MultipleConfigFilesError(ConfigFileError):
-    """Both copier.yml and copier.yaml found, and that's an error."""
-    def __init__(self, conf_paths: PathSeq):
-        msg = str(conf_paths)
-        printf_exception(self, "MULTIPLE CONFIG FILES", msg=msg)
-        super().__init__(msg)
-class InvalidTypeError(TypeError, CopierError):
-    """The question type is not among the supported ones."""
-class PathError(CopierError, ValueError):
-    """The path is invalid in the given context."""
-class PathNotAbsoluteError(PathError):
-    """The path is not absolute, but it should be."""
-    def __init__(self, *, path: Path) -> None:
-        super().__init__(f'"{path}" is not an absolute path')
-class PathNotRelativeError(PathError):
-    """The path is not relative, but it should be."""
-    def __init__(self, *, path: Path) -> None:
-        super().__init__(f'"{path}" is not a relative path')
-class ForbiddenPathError(PathError):
-    """The path is forbidden in the given context."""
-    def __init__(self, *, path: Path) -> None:
-        super().__init__(f'"{path}" is forbidden')
-class ExtensionNotFoundError(UserMessageError):
-    """Extensions listed in the configuration could not be loaded."""
-class CopierAnswersInterrupt(CopierError, KeyboardInterrupt):
-    """CopierAnswersInterrupt is raised during interactive question prompts.
-    It typically follows a KeyboardInterrupt (i.e. ctrl-c) and provides an
-    opportunity for the caller to conduct additional cleanup, such as writing
-    the partially completed answers to a file.
-    Attributes:
-        answers:
-            AnswersMap that contains the partially completed answers object.
-        last_question:
-            Question representing the last_question that was asked at the time
-            the interrupt was raised.
-        template:
-            Template that was being processed for answers.
-    """
-    def __init__(
-        self, answers: AnswersMap, last_question: Question, template: Template
-    ) -> None:
-        self.answers = answers
-        self.last_question = last_question
-        self.template = template
-class UnsafeTemplateError(CopierError):
-    """Unsafe Copier template features are used without explicit consent."""
-    def __init__(self, features: Sequence[str]):
-        assert features
-        s = "s" if len(features) > 1 else ""
-        super().__init__(
-            f"Template uses potentially unsafe feature{s}: {', '.join(features)}.\n"
-            "If you trust this template, consider adding the `--trust` option when running `copier copy/update`."
-        )
-class YieldTagInFileError(CopierError):
-    """A yield tag is used in the file content, but it is not allowed."""
-class MultipleYieldTagsError(CopierError):
-    """Multiple yield tags are used in one path name, but it is not allowed."""
-class TaskError(subprocess.CalledProcessError, UserMessageError):
-    """Exception raised when a task fails."""
-    def __init__(
-        self,
-        command: str | Sequence[str],
-        returncode: int,
-        stdout: str | bytes | None,
-        stderr: str | bytes | None,
-    ):
-        subprocess.CalledProcessError.__init__(
-            self, returncode=returncode, cmd=command, output=stdout, stderr=stderr
-        )
-        message = f"Task {command!r} returned non-zero exit status {returncode}."
-        UserMessageError.__init__(self, message)
-    @classmethod
-    def from_process(
-        cls, process: CompletedProcess[str] | CompletedProcess[bytes]
-    ) -> Self:
-        """Create a TaskError from a CompletedProcess."""
-        return cls(
-            command=process.args,
-            returncode=process.returncode,
-            stdout=process.stdout,
-            stderr=process.stderr,
-        )
-class CopierWarning(Warning):
-    """Base class for all other Copier warnings."""
-class UnknownCopierVersionWarning(UserWarning, CopierWarning):
-    """Cannot determine installed Copier version."""
-class OldTemplateWarning(UserWarning, CopierWarning):
-    """Template was designed for an older Copier version."""
-class DirtyLocalWarning(UserWarning, CopierWarning):
-    """Changes and untracked files present in template."""
-class ShallowCloneWarning(UserWarning, CopierWarning):
-    """The template repository is a shallow clone."""
-class MissingSettingsWarning(UserWarning, CopierWarning):
-    """Settings path has been defined but file is missing."""
-class MissingFileWarning(UserWarning, CopierWarning):
-    """I still couldn't find what I'm looking for."""
-class InteractiveSessionError(UserMessageError):
-    """An interactive session is required to run this program."""
-    def __init__(self, message: str) -> None:
-        super().__init__(f"Interactive session required: {message}")

--- a//dev/null
+++ b/copier/main.py
@@ -0,0 +1,796 @@
+"""Main functions and classes, used to generate or update projects."""
+import contextlib
+import os
+import platform
+import subprocess
+import sys
+from contextlib import suppress
+from dataclasses import asdict, field, replace
+from filecmp import dircmp
+from functools import partial
+from itertools import chain
+from pathlib import Path
+from shutil import copyfile, rmtree
+from typing import Callable, Iterable, List, Mapping, Optional, Sequence, Set
+from unicodedata import normalize
+from jinja2.loaders import FileSystemLoader
+from jinja2.sandbox import SandboxedEnvironment
+from pathspec import PathSpec
+from plumbum import ProcessExecutionError, colors
+from plumbum.cli.terminal import ask
+from plumbum.cmd import git
+from plumbum.machines import local
+from pydantic import ConfigDict, Extra
+from pydantic.dataclasses import dataclass
+from pydantic.json import pydantic_encoder
+from questionary import unsafe_prompt
+from .errors import CopierAnswersInterrupt, ExtensionNotFoundError, UserMessageError
+from .subproject import Subproject
+from .template import Task, Template
+from .tools import Style, TemporaryDirectory, printf
+from .types import (
+    AnyByStrDict,
+    JSONSerializable,
+    OptStr,
+    RelativePath,
+    StrOrPath,
+    StrSeq,
+)
+from .user_data import DEFAULT_DATA, AnswersMap, Question
+if sys.version_info >= (3, 8):
+    from functools import cached_property
+else:
+    from backports.cached_property import cached_property
+if sys.version_info >= (3, 8):
+    from shutil import copytree
+else:
+    from distutils.dir_util import copy_tree
+    def copytree(src: Path, dst: Path, dirs_exist_ok: bool = False):
+        """Backport of `shutil.copytree` with `dirs_exist_ok` argument.
+        Can be remove once python 3.7 dropped.
+        """
+        copy_tree(str(src), str(dst))
+@dataclass(config=ConfigDict(extra=Extra.forbid))
+class Worker:
+    """Copier process state manager.
+    This class represents the state of a copier work, and contains methods to
+    actually produce the desired work.
+    To use it properly, use it as a context manager and fill all dataclass fields.
+    Then, execute one of its main methods, which are prefixed with `run_`:
+    -   [run_copy][copier.main.Worker.run_copy] to copy a subproject.
+    -   [run_update][copier.main.Worker.run_update] to update a subproject.
+    -   [run_auto][copier.main.Worker.run_auto] to let it choose whether you
+        want to copy or update the subproject.
+    Example:
+        ```python
+        with Worker(src_path="https://github.com/copier-org/autopretty.git", "output") as worker:
+            worker.run_copy()
+        ```
+    Attributes:
+        src_path:
+            String that can be resolved to a template path, be it local or remote.
+            See [copier.vcs.get_repo][].
+            If it is `None`, then it means that you are
+            [updating a project][updating-a-project], and the original
+            `src_path` will be obtained from
+            [the answers file][the-copier-answersyml-file].
+        dst_path:
+            Destination path where to render the subproject.
+        answers_file:
+            Indicates the path for [the answers file][the-copier-answersyml-file].
+            The path must be relative to `dst_path`.
+            If it is `None`, the default value will be obtained from
+            [copier.template.Template.answers_relpath][].
+        vcs_ref:
+            Specify the VCS tag/commit to use in the template.
+        data:
+            Answers to the questionary defined in the template.
+        exclude:
+            User-chosen additional [file exclusion patterns][exclude].
+        use_prereleases:
+            Consider prereleases when detecting the *latest* one?
+            See [use_prereleases][].
+            Useless if specifying a [vcs_ref][].
+        skip_if_exists:
+            User-chosen additional [file skip patterns][skip_if_exists].
+        cleanup_on_error:
+            Delete `dst_path` if there's an error?
+            See [cleanup_on_error][].
+        defaults:
+            When `True`, use default answers to questions, which might be null if not specified.
+            See [defaults][].
+        user_defaults:
+            Specify user defaults that may override a template's defaults during question prompts.
+        overwrite:
+            When `True`, Overwrite files that already exist, without asking.
+            See [overwrite][].
+        pretend:
+            When `True`, produce no real rendering.
+            See [pretend][].
+        quiet:
+            When `True`, disable all output.
+            See [quiet][].
+        conflict:
+            One of "rej" (default), "inline" (still experimental).
+    """
+    src_path: Optional[str] = None
+    dst_path: Path = field(default=Path("."))
+    answers_file: Optional[RelativePath] = None
+    vcs_ref: OptStr = None
+    data: AnyByStrDict = field(default_factory=dict)
+    exclude: StrSeq = ()
+    use_prereleases: bool = False
+    skip_if_exists: StrSeq = ()
+    cleanup_on_error: bool = True
+    defaults: bool = False
+    user_defaults: AnyByStrDict = field(default_factory=dict)
+    overwrite: bool = False
+    pretend: bool = False
+    quiet: bool = False
+    conflict: str = "rej"
+    def __enter__(self):
+        return self
+    def __exit__(self, type, value, traceback):
+        if value is not None:
+            with suppress(Exception):
+                self._cleanup()
+            raise value
+        self._cleanup()
+    def _cleanup(self):
+        self.template._cleanup()
+    def _answers_to_remember(self) -> Mapping:
+        """Get only answers that will be remembered in the copier answers file."""
+        answers: AnyByStrDict = {}
+        commit = self.template.commit
+        src = self.template.url
+        for key, value in (("_commit", commit), ("_src_path", src)):
+            if value is not None:
+                answers[key] = value
+        answers.update(
+            (str(k), v)
+            for (k, v) in self.answers.combined.items()
+            if not k.startswith("_")
+            and k not in self.template.secret_questions
+            and k in self.template.questions_data
+            and isinstance(k, JSONSerializable)
+            and isinstance(v, JSONSerializable)
+        )
+        return answers
+    def _execute_tasks(self, tasks: Sequence[Task]) -> None:
+        """Run the given tasks.
+        Arguments:
+            tasks: The list of tasks to run.
+        """
+        for i, task in enumerate(tasks):
+            task_cmd = task.cmd
+            if isinstance(task_cmd, str):
+                task_cmd = self._render_string(task_cmd)
+                use_shell = True
+            else:
+                task_cmd = [self._render_string(str(part)) for part in task_cmd]
+                use_shell = False
+            if not self.quiet:
+                print(
+                    colors.info
+                    | f" > Running task {i + 1} of {len(tasks)}: {task_cmd}",
+                    file=sys.stderr,
+                )
+            with local.cwd(self.subproject.local_abspath), local.env(**task.extra_env):
+                subprocess.run(task_cmd, shell=use_shell, check=True, env=local.env)
+    def _render_context(self) -> Mapping:
+        """Produce render context for Jinja."""
+        conf = asdict(self)
+        conf.update(
+            {
+                "answers_file": self.answers_relpath,
+                "src_path": self.template.local_abspath,
+                "vcs_ref_hash": self.template.commit_hash,
+            }
+        )
+        return dict(
+            DEFAULT_DATA,
+            **self.answers.combined,
+            _copier_answers=self._answers_to_remember(),
+            _copier_conf=conf,
+            _folder_name=self.subproject.local_abspath.name,
+            _copier_python=sys.executable,
+        )
+    def _path_matcher(self, patterns: Iterable[str]) -> Callable[[Path], bool]:
+        """Produce a function that matches against specified patterns."""
+        normalized_patterns = (normalize("NFD", pattern) for pattern in patterns)
+        spec = PathSpec.from_lines("gitwildmatch", normalized_patterns)
+        return spec.match_file
+    def _solve_render_conflict(self, dst_relpath: Path):
+        """Properly solve render conflicts.
+        It can ask the user if running in interactive mode.
+        """
+        assert not dst_relpath.is_absolute()
+        printf(
+            "conflict",
+            dst_relpath,
+            style=Style.DANGER,
+            quiet=self.quiet,
+            file_=sys.stderr,
+        )
+        if self.match_skip(dst_relpath):
+            printf(
+                "skip",
+                dst_relpath,
+                style=Style.OK,
+                quiet=self.quiet,
+                file_=sys.stderr,
+            )
+            return False
+        if self.overwrite or dst_relpath == self.answers_relpath:
+            printf(
+                "overwrite",
+                dst_relpath,
+                style=Style.WARNING,
+                quiet=self.quiet,
+                file_=sys.stderr,
+            )
+            return True
+        return bool(ask(f" Overwrite {dst_relpath}?", default=True))
+    def _render_allowed(
+        self,
+        dst_relpath: Path,
+        is_dir: bool = False,
+        expected_contents: bytes = b"",
+        expected_permissions=None,
+    ) -> bool:
+        """Determine if a file or directory can be rendered.
+        Args:
+            dst_relpath:
+                Relative path to destination.
+            is_dir:
+                Indicate if the path must be treated as a directory or not.
+            expected_contents:
+                Used to compare existing file contents with them. Allows to know if
+                rendering is needed.
+        """
+        assert not dst_relpath.is_absolute()
+        assert not expected_contents or not is_dir, "Dirs cannot have expected content"
+        dst_abspath = Path(self.subproject.local_abspath, dst_relpath)
+        if dst_relpath != Path(".") and self.match_exclude(dst_relpath):
+            return False
+        try:
+            previous_content = dst_abspath.read_bytes()
+        except FileNotFoundError:
+            printf(
+                "create",
+                dst_relpath,
+                style=Style.OK,
+                quiet=self.quiet,
+                file_=sys.stderr,
+            )
+            return True
+        except (IsADirectoryError, PermissionError) as error:
+            if isinstance(error, PermissionError) and not (
+                error.errno == 13 and platform.system() == "Windows"
+            ):
+                raise
+            if is_dir:
+                printf(
+                    "identical",
+                    dst_relpath,
+                    style=Style.IGNORE,
+                    quiet=self.quiet,
+                    file_=sys.stderr,
+                )
+                return True
+            return self._solve_render_conflict(dst_relpath)
+        else:
+            if previous_content == expected_contents:
+                printf(
+                    "identical",
+                    dst_relpath,
+                    style=Style.IGNORE,
+                    quiet=self.quiet,
+                    file_=sys.stderr,
+                )
+                return True
+            return self._solve_render_conflict(dst_relpath)
+    @cached_property
+    def answers(self) -> AnswersMap:
+        """Container of all answers to the questionary.
+        It asks the user the 1st time it is called, if running interactively.
+        """
+        result = AnswersMap(
+            default=self.template.default_answers,
+            user_defaults=self.user_defaults,
+            init=self.data,
+            last=self.subproject.last_answers,
+            metadata=self.template.metadata,
+        )
+        questions: List[Question] = []
+        for var_name, details in self.template.questions_data.items():
+            if var_name in result.init:
+                continue
+            questions.append(
+                Question(
+                    answers=result,
+                    ask_user=not self.defaults,
+                    jinja_env=self.jinja_env,
+                    var_name=var_name,
+                    **details,
+                )
+            )
+        for question in questions:
+            try:
+                new_answer = (
+                    question.get_default()
+                    if self.defaults
+                    else unsafe_prompt(
+                        [question.get_questionary_structure()], answers=result.combined
+                    )[question.var_name]
+                )
+            except KeyboardInterrupt as err:
+                raise CopierAnswersInterrupt(result, question, self.template) from err
+            previous_answer = result.combined.get(question.var_name)
+            default_answer = result.default.get(question.var_name)
+            if new_answer == default_answer:
+                new_answer = question.render_value(default_answer)
+                new_answer = question.filter_answer(new_answer)
+            if new_answer != previous_answer:
+                result.user[question.var_name] = new_answer
+        return result
+    @cached_property
+    def answers_relpath(self) -> Path:
+        """Obtain the proper relative path for the answers file.
+        It comes from:
+        1. User choice.
+        2. Template default.
+        3. Copier default.
+        """
+        return self.answers_file or self.template.answers_relpath
+    @cached_property
+    def all_exclusions(self) -> StrSeq:
+        """Combine default, template and user-chosen exclusions."""
+        return self.template.exclude + tuple(self.exclude)
+    @cached_property
+    def jinja_env(self) -> SandboxedEnvironment:
+        """Return a pre-configured Jinja environment.
+        Respects template settings.
+        """
+        paths = [str(self.template.local_abspath)]
+        loader = FileSystemLoader(paths)
+        default_extensions = [
+            "jinja2_ansible_filters.AnsibleCoreFiltersExtension",
+        ]
+        extensions = default_extensions + list(self.template.jinja_extensions)
+        try:
+            env = SandboxedEnvironment(
+                loader=loader, extensions=extensions, **self.template.envops
+            )
+        except ModuleNotFoundError as error:
+            raise ExtensionNotFoundError(
+                f"Copier could not load some Jinja extensions:\n{error}\n"
+                "Make sure to install these extensions alongside Copier itself.\n"
+                "See the docs at https://copier.readthedocs.io/en/latest/configuring/#jinja_extensions"
+            )
+        env.filters["to_json"] = partial(
+            env.filters["to_json"], default=pydantic_encoder
+        )
+        return env
+    @cached_property
+    def match_exclude(self) -> Callable[[Path], bool]:
+        """Get a callable to match paths against all exclusions."""
+        return self._path_matcher(self.all_exclusions)
+    @cached_property
+    def match_skip(self) -> Callable[[Path], bool]:
+        """Get a callable to match paths against all skip-if-exists patterns."""
+        return self._path_matcher(
+            map(
+                self._render_string,
+                tuple(chain(self.skip_if_exists, self.template.skip_if_exists)),
+            )
+        )
+    def _render_file(self, src_abspath: Path) -> None:
+        """Render one file.
+        Args:
+            src_abspath:
+                The absolute path to the file that will be rendered.
+        """
+        assert src_abspath.is_absolute()
+        src_relpath = src_abspath.relative_to(self.template.local_abspath).as_posix()
+        src_renderpath = src_abspath.relative_to(self.template_copy_root)
+        dst_relpath = self._render_path(src_renderpath)
+        if dst_relpath is None:
+            return
+        if src_abspath.name.endswith(self.template.templates_suffix):
+            try:
+                tpl = self.jinja_env.get_template(src_relpath)
+            except UnicodeDecodeError:
+                if self.template.templates_suffix:
+                    raise
+                new_content = src_abspath.read_bytes()
+            else:
+                new_content = tpl.render(**self._render_context()).encode()
+        else:
+            new_content = src_abspath.read_bytes()
+        dst_abspath = Path(self.subproject.local_abspath, dst_relpath)
+        if dst_abspath.is_dir():
+            return
+        src_mode = src_abspath.stat().st_mode
+        if not self._render_allowed(
+            dst_relpath,
+            expected_contents=new_content,
+            expected_permissions=src_mode,
+        ):
+            return
+        if not self.pretend:
+            dst_abspath.write_bytes(new_content)
+            dst_abspath.chmod(src_mode)
+    def _render_folder(self, src_abspath: Path) -> None:
+        """Recursively render a folder.
+        Args:
+            src_path:
+                Folder to be rendered. It must be an absolute path within
+                the template.
+        """
+        assert src_abspath.is_absolute()
+        src_relpath = src_abspath.relative_to(self.template_copy_root)
+        dst_relpath = self._render_path(src_relpath)
+        if dst_relpath is None:
+            return
+        if not self._render_allowed(dst_relpath, is_dir=True):
+            return
+        dst_abspath = Path(self.subproject.local_abspath, dst_relpath)
+        if not self.pretend:
+            dst_abspath.mkdir(parents=True, exist_ok=True)
+        for file in src_abspath.iterdir():
+            if file.is_dir():
+                self._render_folder(file)
+            else:
+                self._render_file(file)
+    def _render_path(self, relpath: Path) -> Optional[Path]:
+        """Render one relative path.
+        Args:
+            relpath:
+                The relative path to be rendered. Obviously, it can be templated.
+        """
+        is_template = relpath.name.endswith(self.template.templates_suffix)
+        templated_sibling = (
+            self.template.local_abspath / f"{relpath}{self.template.templates_suffix}"
+        )
+        if templated_sibling.exists() and self.template.templates_suffix:
+            return None
+        rendered_parts = []
+        for part in relpath.parts:
+            part = self._render_string(part)
+            if not part:
+                return None
+            rendered_parts.append(part)
+        with suppress(IndexError):
+            if is_template and self.template.templates_suffix:
+                rendered_parts[-1] = rendered_parts[-1][
+                    : -len(self.template.templates_suffix)
+                ]
+        result = Path(*rendered_parts)
+        if not is_template:
+            templated_sibling = (
+                self.template.local_abspath
+                / f"{result}{self.template.templates_suffix}"
+            )
+            if templated_sibling.exists():
+                return None
+        return result
+    def _render_string(self, string: str) -> str:
+        """Render one templated string.
+        Args:
+            string:
+                The template source string.
+        """
+        tpl = self.jinja_env.from_string(string)
+        return tpl.render(**self._render_context())
+    @cached_property
+    def subproject(self) -> Subproject:
+        """Get related subproject."""
+        return Subproject(
+            local_abspath=self.dst_path.absolute(),
+            answers_relpath=self.answers_file or Path(".copier-answers.yml"),
+        )
+    @cached_property
+    def template(self) -> Template:
+        """Get related template."""
+        url = self.src_path
+        if not url:
+            if self.subproject.template is None:
+                raise TypeError("Template not found")
+            url = str(self.subproject.template.url)
+        return Template(url=url, ref=self.vcs_ref, use_prereleases=self.use_prereleases)
+    @cached_property
+    def template_copy_root(self) -> Path:
+        """Absolute path from where to start copying.
+        It points to the cloned template local abspath + the rendered subdir, if any.
+        """
+        subdir = self._render_string(self.template.subdirectory) or ""
+        return self.template.local_abspath / subdir
+    def run_auto(self) -> None:
+        """Copy or update automatically.
+        If `src_path` was supplied, execute
+        [run_copy][copier.main.Worker.run_copy].
+        Otherwise, execute [run_update][copier.main.Worker.run_update].
+        """
+        if self.src_path:
+            return self.run_copy()
+        return self.run_update()
+    def run_copy(self) -> None:
+        """Generate a subproject from zero, ignoring what was in the folder.
+        If `dst_path` was missing, it will be
+        created. Otherwise, `src_path` be rendered
+        directly into it, without worrying about evolving what was there
+        already.
+        See [generating a project][generating-a-project].
+        """
+        was_existing = self.subproject.local_abspath.exists()
+        src_abspath = self.template_copy_root
+        try:
+            if not self.quiet:
+                print(
+                    f"\nCopying from template version {self.template.version}",
+                    file=sys.stderr,
+                )
+            self._render_folder(src_abspath)
+            if not self.quiet:
+                print("")  # padding space
+            self._execute_tasks(self.template.tasks)
+        except Exception:
+            if not was_existing and self.cleanup_on_error:
+                rmtree(self.subproject.local_abspath)
+            raise
+        if not self.quiet:
+            print("")  # padding space
+    def run_update(self) -> None:
+        """Update a subproject that was already generated.
+        See [updating a project][updating-a-project].
+        """
+        if self.subproject.vcs != "git":
+            raise UserMessageError(
+                "Updating is only supported in git-tracked subprojects."
+            )
+        if self.subproject.is_dirty():
+            raise UserMessageError(
+                "Destination repository is dirty; cannot continue. "
+                "Please commit or stash your local changes and retry."
+            )
+        if self.subproject.template is None or self.subproject.template.ref is None:
+            raise UserMessageError(
+                "Cannot update because cannot obtain old template references "
+                f"from `{self.subproject.answers_relpath}`."
+            )
+        if self.template.commit is None:
+            raise UserMessageError(
+                "Updating is only supported in git-tracked templates."
+            )
+        if not self.subproject.template.version:
+            raise UserMessageError(
+                "Cannot update: version from last update not detected."
+            )
+        if not self.template.version:
+            raise UserMessageError("Cannot update: version from template not detected.")
+        if self.subproject.template.version > self.template.version:
+            raise UserMessageError(
+                f"Your are downgrading from {self.subproject.template.version} to {self.template.version}. "
+                "Downgrades are not supported."
+            )
+        if not self.quiet:
+            print(
+                f"Updating to template version {self.template.version}", file=sys.stderr
+            )
+        self._apply_update()
+    def _apply_update(self):
+        if self.conflict == "inline":
+            self._apply_update_inline_conflict_markers()
+            return
+        with TemporaryDirectory(
+            prefix=f"{__name__}.update_diff."
+        ) as old_copy, TemporaryDirectory(
+            prefix=f"{__name__}.recopy_diff."
+        ) as new_copy:
+            old_worker = self._make_old_worker(old_copy)
+            old_worker.run_copy()
+            recopy_worker = replace(
+                self,
+                dst_path=new_copy,
+                data=self.subproject.last_answers,
+                defaults=True,
+                quiet=True,
+                src_path=self.subproject.template.url,
+            )
+            recopy_worker.run_copy()
+            compared = dircmp(old_copy, new_copy)
+            with local.cwd(old_copy):
+                subproject_top = git(
+                    "-C",
+                    self.subproject.local_abspath.absolute(),
+                    "rev-parse",
+                    "--show-toplevel",
+                ).strip()
+                self._git_initialize_repo()
+                git("remote", "add", "real_dst", "file://" + subproject_top)
+                git("fetch", "--depth=1", "real_dst", "HEAD")
+                diff_cmd = git["diff-tree", "--unified=1", "HEAD...FETCH_HEAD"]
+                try:
+                    diff = diff_cmd("--inter-hunk-context=-1")
+                except ProcessExecutionError:
+                    print(
+                        colors.warn
+                        | "Make sure Git >= 2.24 is installed to improve updates.",
+                        file=sys.stderr,
+                    )
+                    diff = diff_cmd("--inter-hunk-context=0")
+            self._execute_tasks(
+                self.template.migration_tasks("before", self.subproject.template)
+            )
+            self._uncached_copy()
+            with local.cwd(self.subproject.local_abspath):
+                apply_cmd = git["apply", "--reject", "--exclude", self.answers_relpath]
+                for skip_pattern in chain(
+                    self.skip_if_exists, self.template.skip_if_exists
+                ):
+                    apply_cmd = apply_cmd["--exclude", skip_pattern]
+                (apply_cmd << diff)(retcode=None)
+            _remove_old_files(self.subproject.local_abspath, compared)
+        self._execute_tasks(
+            self.template.migration_tasks("after", self.subproject.template)
+        )
+    def _apply_update_inline_conflict_markers(self):
+        """Implements the apply_update() method using inline conflict markers."""
+        with TemporaryDirectory(
+            prefix=f"{__name__}.update_diff.reference."
+        ) as reference_dst_temp, TemporaryDirectory(
+            prefix=f"{__name__}.update_diff.original."
+        ) as old_copy, TemporaryDirectory(
+            prefix=f"{__name__}.update_diff.merge."
+        ) as merge_dst_temp:
+            copytree(self.dst_path, reference_dst_temp, dirs_exist_ok=True)
+            assert self.subproject
+            assert self.subproject.template
+            old_worker = self._make_old_worker(old_copy)
+            old_worker.run_copy()
+            with local.cwd(old_copy):
+                self._git_initialize_repo()
+            self._execute_tasks(
+                self.template.migration_tasks("before", self.subproject.template)
+            )
+            self._uncached_copy()
+            participating_files: Set[Path] = set()
+            for src_dir in (old_copy, reference_dst_temp):
+                for root, dirs, files in os.walk(src_dir, topdown=True):
+                    if root == src_dir and ".git" in dirs:
+                        dirs.remove(".git")
+                    root = Path(root).relative_to(src_dir)
+                    participating_files.update(Path(root, f) for f in files)
+            for basename in sorted(participating_files):
+                subfile_names = []
+                for subfile_kind, src_dir in [
+                    ("modified", reference_dst_temp),
+                    ("old upstream", old_copy),
+                    ("new upstream", self.dst_path),
+                ]:
+                    path = Path(src_dir, basename)
+                    if path.is_file():
+                        copyfile(path, Path(merge_dst_temp, subfile_kind))
+                    else:
+                        subfile_kind = os.devnull
+                    subfile_names.append(subfile_kind)
+                with local.cwd(merge_dst_temp):
+                    output = git("merge-file", "-p", *subfile_names, retcode=None)
+                dest_path = Path(self.dst_path, basename)
+                if not output and "modified" not in subfile_names:
+                    with contextlib.suppress(FileNotFoundError):
+                        dest_path.unlink()
+                else:
+                    dest_path.parent.mkdir(parents=True, exist_ok=True)
+                    dest_path.write_text(output)
+        self._execute_tasks(
+            self.template.migration_tasks("after", self.subproject.template)
+        )
+    def _uncached_copy(self):
+        """Copy template to destination without using answer cache."""
+        with suppress(AttributeError):
+            del self.answers
+        with suppress(AttributeError):
+            del self.subproject.last_answers
+        self.run_copy()
+    def _make_old_worker(self, old_copy):
+        """Create a worker to copy the old template into a temporary destination."""
+        old_worker = replace(
+            self,
+            dst_path=old_copy,
+            data=self.subproject.last_answers,
+            defaults=True,
+            quiet=True,
+            src_path=self.subproject.template.url,
+            vcs_ref=self.subproject.template.commit,
+        )
+        return old_worker
+    def _git_initialize_repo(self):
+        """Initialize a git repository in the current directory."""
+        git("init", retcode=None)
+        git("add", ".")
+        git("config", "user.name", "Copier")
+        git("config", "user.email", "copier@copier")
+        git("commit", "--allow-empty", "-am", "dumb commit 1", retcode=None)
+        git("commit", "--allow-empty", "-am", "dumb commit 2")
+        git("config", "--unset", "user.name")
+        git("config", "--unset", "user.email")
+def run_copy(
+    src_path: str,
+    dst_path: StrOrPath = ".",
+    data: AnyByStrDict = None,
+    **kwargs,
+) -> Worker:
+    """Copy a template to a destination, from zero.
+    This is a shortcut for [run_copy][copier.main.Worker.run_copy].
+    See [Worker][copier.main.Worker] fields to understand this function's args.
+    """
+    if data is not None:
+        kwargs["data"] = data
+    with Worker(src_path=src_path, dst_path=Path(dst_path), **kwargs) as worker:
+        worker.run_copy()
+    return worker
+def run_update(
+    dst_path: StrOrPath = ".",
+    data: AnyByStrDict = None,
+    **kwargs,
+) -> Worker:
+    """Update a subproject, from its template.
+    This is a shortcut for [run_update][copier.main.Worker.run_update].
+    See [Worker][copier.main.Worker] fields to understand this function's args.
+    """
+    if data is not None:
+        kwargs["data"] = data
+    with Worker(dst_path=Path(dst_path), **kwargs) as worker:
+        worker.run_update()
+    return worker
+def run_auto(
+    src_path: OptStr = None,
+    dst_path: StrOrPath = ".",
+    data: AnyByStrDict = None,
+    **kwargs,
+) -> Worker:
+    """Generate or update a subproject.
+    This is a shortcut for [run_auto][copier.main.Worker.run_auto].
+    See [Worker][copier.main.Worker] fields to understand this function's args.
+    """
+    if src_path is None:
+        return run_update(dst_path, data, **kwargs)
+    return run_copy(src_path, dst_path, data, **kwargs)
+def _remove_old_files(prefix: Path, cmp: dircmp, rm_common: bool = False):
+    """Remove files and directories only found in "old" template.
+    This is an internal helper method used to process a comparison of 2
+    directories, where the left one is considered the "old" one, and the
+    right one is the "new" one.
+    Then, it will recursively try to remove anything that is only in the old
+    directory.
+    Args:
+        prefix:
+            Where we start removing. It can be different from the directories
+            being compared.
+        cmp:
+            The comparison result.
+        rm_common:
+            Should we remove common files and directories?
+    """
+    to_rm = []
+    subdirs = {}
+    with suppress(NotADirectoryError, FileNotFoundError):
+        to_rm = cmp.left_only
+        if rm_common:
+            to_rm += cmp.common_files + cmp.common_dirs
+        subdirs = cmp.subdirs
+    for name in to_rm:
+        target = prefix / name
+        if target.is_file():
+            target.unlink()
+        else:
+            _remove_old_files(target, dircmp(Path(cmp.left, name), target), True)
+            with suppress(OSError):
+                target.rmdir()  # Raises if dir not empty
+    for key, value in subdirs.items():
+        subdir = prefix / key
+        _remove_old_files(subdir, value)
+        with suppress(OSError):
+            subdir.rmdir()  # Raises if dir not empty

--- a//dev/null
+++ b/copier/template.py
@@ -0,0 +1,394 @@
+"""Tools related to template management."""
+import re
+import sys
+from collections import ChainMap, defaultdict
+from contextlib import suppress
+from dataclasses import field
+from pathlib import Path
+from shutil import rmtree
+from typing import List, Mapping, Optional, Sequence, Set, Tuple
+from warnings import warn
+import dunamai
+import packaging.version
+import yaml
+from funcy import lflatten
+from packaging.version import Version, parse
+from plumbum.cmd import git
+from plumbum.machines import local
+from pydantic.dataclasses import dataclass
+from yamlinclude import YamlIncludeConstructor
+from .errors import (
+    InvalidConfigFileError,
+    MultipleConfigFilesError,
+    OldTemplateWarning,
+    UnknownCopierVersionWarning,
+    UnsupportedVersionError,
+)
+from .tools import copier_version, handle_remove_readonly
+from .types import AnyByStrDict, Env, OptStr, StrSeq, Union, VCSTypes
+from .vcs import checkout_latest_tag, clone, get_repo
+if sys.version_info >= (3, 8):
+    from functools import cached_property
+else:
+    from backports.cached_property import cached_property
+from .types import Literal
+DEFAULT_EXCLUDE: Tuple[str, ...] = (
+    "copier.yaml",
+    "copier.yml",
+    "~*",
+    "*.py[co]",
+    "__pycache__",
+    ".git",
+    ".DS_Store",
+    ".svn",
+)
+DEFAULT_TEMPLATES_SUFFIX = ".jinja"
+def filter_config(data: AnyByStrDict) -> Tuple[AnyByStrDict, AnyByStrDict]:
+    """Separates config and questions data."""
+    conf_data: AnyByStrDict = {"secret_questions": set()}
+    questions_data = {}
+    for k, v in data.items():
+        if k == "_secret_questions":
+            conf_data["secret_questions"].update(v)
+        elif k.startswith("_"):
+            conf_data[k[1:]] = v
+        else:
+            if not isinstance(v, dict):
+                v = {"default": v}
+            questions_data[k] = v
+            if v.get("secret"):
+                conf_data["secret_questions"].add(k)
+    return conf_data, questions_data
+def load_template_config(conf_path: Path, quiet: bool = False) -> AnyByStrDict:
+    """Load the `copier.yml` file.
+    This is like a simple YAML load, but applying all specific quirks needed
+    for [the `copier.yml` file][the-copieryml-file].
+    For example, it supports the `!include` tag with glob includes, and
+    merges multiple sections.
+    Params:
+        conf_path: The path to the `copier.yml` file.
+        quiet: Used to configure the exception.
+    Raises:
+        InvalidConfigFileError: When the file is formatted badly.
+    """
+    YamlIncludeConstructor.add_to_loader_class(
+        loader_class=yaml.FullLoader, base_dir=conf_path.parent
+    )
+    try:
+        with open(conf_path) as f:
+            flattened_result = lflatten(yaml.load_all(f, Loader=yaml.FullLoader))
+            merged_options = defaultdict(list)
+            for option in (
+                "_exclude",
+                "_jinja_extensions",
+                "_secret_questions",
+                "_skip_if_exists",
+            ):
+                for result in flattened_result:
+                    try:
+                        values = result[option]
+                    except KeyError:
+                        pass
+                    else:
+                        merged_options[option].extend(values)
+            return dict(ChainMap(dict(merged_options), *reversed(flattened_result)))
+    except yaml.parser.ParserError as e:
+        raise InvalidConfigFileError(conf_path, quiet) from e
+def verify_copier_version(version_str: str) -> None:
+    """Raise an error if the current Copier version is less than the given version.
+    Args:
+        version_str:
+            Minimal copier version for the template.
+    """
+    installed_version = copier_version()
+    if installed_version == Version("0.0.0"):
+        warn(
+            "Cannot check Copier version constraint.",
+            UnknownCopierVersionWarning,
+        )
+        return
+    parsed_min = Version(version_str)
+    if installed_version < parsed_min:
+        raise UnsupportedVersionError(
+            f"This template requires Copier version >= {version_str}, "
+            f"while your version of Copier is {installed_version}."
+        )
+    if installed_version.major > parsed_min.major:
+        warn(
+            f"This template was designed for Copier {version_str}, "
+            f"but your version of Copier is {installed_version}. "
+            f"You could find some incompatibilities.",
+            OldTemplateWarning,
+        )
+@dataclass
+class Task:
+    """Object that represents a task to execute.
+    Attributes:
+        cmd:
+            Command to execute.
+        extra_env:
+            Additional environment variables to set while executing the command.
+    """
+    cmd: Union[str, Sequence[str]]
+    extra_env: Env = field(default_factory=dict)
+@dataclass
+class Template:
+    """Object that represents a template and its current state.
+    See [configuring a template][configuring-a-template].
+    Attributes:
+        url:
+            Absolute origin that points to the template.
+            It can be:
+            - A local path.
+            - A Git url. Note: if something fails, prefix the URL with `git+`.
+        ref:
+            The tag to checkout in the template.
+            Only used if `url` points to a VCS-tracked template.
+            If `None`, then it will checkout the latest tag, sorted by PEP440.
+            Otherwise it will checkout the reference used here.
+            Usually it should be a tag, or `None`.
+        use_prereleases:
+            When `True`, the template's *latest* release will consider prereleases.
+            Only used if:
+            - `url` points to a VCS-tracked template
+            - `ref` is `None`.
+            Helpful if you want to test templates before doing a proper release, but you
+            need some features that require a proper PEP440 version identifier.
+    """
+    url: str
+    ref: OptStr = None
+    use_prereleases: bool = False
+    def _cleanup(self) -> None:
+        temp_clone = self._temp_clone
+        if temp_clone:
+            rmtree(
+                temp_clone,
+                ignore_errors=False,
+                onerror=handle_remove_readonly,
+            )
+    @property
+    def _temp_clone(self) -> Optional[Path]:
+        clone_path = self.local_abspath
+        original_path = Path(self.url).expanduser()
+        with suppress(OSError):  # triggered for URLs on Windows
+            original_path = original_path.resolve()
+        if clone_path != original_path:
+            return clone_path
+        return None
+    @cached_property
+    def _raw_config(self) -> AnyByStrDict:
+        """Get template configuration, raw.
+        It reads [the `copier.yml` file][the-copieryml-file].
+        """
+        conf_paths = [
+            p
+            for p in self.local_abspath.glob("copier.*")
+            if p.is_file() and re.match(r"\.ya?ml", p.suffix, re.I)
+        ]
+        if len(conf_paths) > 1:
+            raise MultipleConfigFilesError(conf_paths)
+        elif len(conf_paths) == 1:
+            return load_template_config(conf_paths[0])
+        return {}
+    @cached_property
+    def answers_relpath(self) -> Path:
+        """Get the answers file relative path, as specified in the template.
+        If not specified, returns the default `.copier-answers.yml`.
+        See [answers_file][].
+        """
+        result = Path(self.config_data.get("answers_file", ".copier-answers.yml"))
+        assert not result.is_absolute()
+        return result
+    @cached_property
+    def commit(self) -> OptStr:
+        """If the template is VCS-tracked, get its commit description."""
+        if self.vcs == "git":
+            with local.cwd(self.local_abspath):
+                return git("describe", "--tags", "--always").strip()
+    @cached_property
+    def commit_hash(self) -> OptStr:
+        """If the template is VCS-tracked, get its commit full hash."""
+        if self.vcs == "git":
+            return git("-C", self.local_abspath, "rev-parse", "HEAD").strip()
+    @cached_property
+    def config_data(self) -> AnyByStrDict:
+        """Get config from the template.
+        It reads [the `copier.yml` file][the-copieryml-file] to get its
+        [settings][available-settings].
+        """
+        result = filter_config(self._raw_config)[0]
+        with suppress(KeyError):
+            verify_copier_version(result["min_copier_version"])
+        return result
+    @cached_property
+    def default_answers(self) -> AnyByStrDict:
+        """Get default answers for template's questions."""
+        return {key: value.get("default") for key, value in self.questions_data.items()}
+    @cached_property
+    def envops(self) -> Mapping:
+        """Get the Jinja configuration specified in the template, or default values.
+        See [envops][].
+        """
+        result = self.config_data.get("envops", {})
+        if "keep_trailing_newline" not in result:
+            result["keep_trailing_newline"] = True
+        return result
+    @cached_property
+    def exclude(self) -> Tuple[str, ...]:
+        """Get exclusions specified in the template, or default ones.
+        See [exclude][].
+        """
+        return tuple(self.config_data.get("exclude", DEFAULT_EXCLUDE))
+    @cached_property
+    def jinja_extensions(self) -> Tuple[str, ...]:
+        """Get Jinja2 extensions specified in the template, or `()`.
+        See [jinja_extensions][].
+        """
+        return tuple(self.config_data.get("jinja_extensions", ()))
+    @cached_property
+    def metadata(self) -> AnyByStrDict:
+        """Get template metadata.
+        This data, if any, should be saved in the answers file to be able to
+        restore the template to this same state.
+        """
+        result: AnyByStrDict = {"_src_path": self.url}
+        if self.commit:
+            result["_commit"] = self.commit
+        return result
+    def migration_tasks(
+        self, stage: Literal["before", "after"], from_template: "Template"
+    ) -> Sequence[Task]:
+        """Get migration objects that match current version spec.
+        Versions are compared using PEP 440.
+        See [migrations][].
+        Args:
+            stage: A valid stage name to find tasks for.
+            from_template: Original template, from which we are migrating.
+        """
+        result: List[Task] = []
+        if not (self.version and from_template.version):
+            return result
+        extra_env: Env = {
+            "STAGE": stage,
+            "VERSION_FROM": str(from_template.commit),
+            "VERSION_TO": str(self.commit),
+            "VERSION_PEP440_FROM": str(from_template.version),
+            "VERSION_PEP440_TO": str(self.version),
+        }
+        migration: dict
+        for migration in self._raw_config.get("_migrations", []):
+            current = parse(migration["version"])
+            if self.version >= current > from_template.version:
+                extra_env = {
+                    **extra_env,
+                    "VERSION_CURRENT": migration["version"],
+                    "VERSION_PEP440_CURRENT": str(current),
+                }
+                for cmd in migration.get(stage, []):
+                    result.append(Task(cmd=cmd, extra_env=extra_env))
+        return result
+    @cached_property
+    def min_copier_version(self) -> Optional[Version]:
+        """Gets minimal copier version for the template and validates it.
+        See [min_copier_version][].
+        """
+        try:
+            return Version(self.config_data["min_copier_version"])
+        except KeyError:
+            return None
+    @cached_property
+    def questions_data(self) -> AnyByStrDict:
+        """Get questions from the template.
+        See [questions][].
+        """
+        return filter_config(self._raw_config)[1]
+    @cached_property
+    def secret_questions(self) -> Set[str]:
+        """Get names of secret questions from the template.
+        These questions shouldn't be saved into the answers file.
+        """
+        result = set(self.config_data.get("secret_questions", {}))
+        for key, value in self.questions_data.items():
+            if value.get("secret"):
+                result.add(key)
+        return result
+    @cached_property
+    def skip_if_exists(self) -> StrSeq:
+        """Get skip patterns from the template.
+        These files will never be rewritten when rendering the template.
+        See [skip_if_exists][].
+        """
+        return self.config_data.get("skip_if_exists", ())
+    @cached_property
+    def subdirectory(self) -> str:
+        """Get the subdirectory as specified in the template.
+        The subdirectory points to the real template code, allowing the
+        templater to separate it from other template assets, such as docs,
+        tests, etc.
+        See [subdirectory][].
+        """
+        return self.config_data.get("subdirectory", "")
+    @cached_property
+    def tasks(self) -> Sequence[Task]:
+        """Get tasks defined in the template.
+        See [tasks][].
+        """
+        return [
+            Task(cmd=cmd, extra_env={"STAGE": "task"})
+            for cmd in self.config_data.get("tasks", [])
+        ]
+    @cached_property
+    def templates_suffix(self) -> str:
+        """Get the suffix defined for templates.
+        By default: `.jinja`.
+        See [templates_suffix][].
+        """
+        result = self.config_data.get("templates_suffix")
+        if result is None:
+            return DEFAULT_TEMPLATES_SUFFIX
+        return result
+    @cached_property
+    def local_abspath(self) -> Path:
+        """Get the absolute path to the template on disk.
+        This may clone it if `url` points to a VCS-tracked template.
+        Dirty changes for local VCS-tracked templates will be copied.
+        """
+        result = Path(self.url)
+        if self.vcs == "git":
+            result = Path(clone(self.url_expanded, self.ref))
+            if self.ref is None:
+                checkout_latest_tag(result, self.use_prereleases)
+        if not result.is_dir():
+            raise ValueError("Local template must be a directory.")
+        return result.absolute()
+    @cached_property
+    def url_expanded(self) -> str:
+        """Get usable URL.
+        `url` can be specified in shortcut
+        format, which wouldn't be understood by the underlying VCS system. This
+        property returns the expanded version, which should work properly.
+        """
+        return get_repo(self.url) or self.url
+    @cached_property
+    def version(self) -> Optional[Version]:
+        """PEP440-compliant version object."""
+        if self.vcs != "git" or not self.commit:
+            return None
+        try:
+            with local.cwd(self.local_abspath):
+                return Version(
+                    dunamai.Version.from_git().serialize(style=dunamai.Style.Pep440)
+                )
+        except ValueError:
+            if re.match(r"^.+-\d+-g\w+$", self.commit):
+                base, count, git_hash = self.commit.rsplit("-", 2)
+                return Version(f"{base}.post{count}+{git_hash}")
+        try:
+            return Version(self.commit)
+        except packaging.version.InvalidVersion:
+            return None
+    @cached_property
+    def vcs(self) -> Optional[VCSTypes]:
+        """Get VCS system used by the template, if any."""
+        if get_repo(self.url):
+            return "git"

--- a/devtasks.py
+++ b//dev/null
@@ -1,49 +0,0 @@
-"""Development helper tasks."""
-import logging
-from pathlib import Path
-from plumbum import TEE, CommandNotFound, ProcessExecutionError, local
-_logger = logging.getLogger(__name__)
-HERE = Path(__file__).parent
-def dev_setup() -> None:
-    """Set up a development environment."""
-    with local.cwd(HERE):
-        local["direnv"]("allow")
-        local["uv"]("sync", "--frozen")
-def lint() -> None:
-    """Lint and format the project."""
-    args = [
-        "run",
-        "--",
-        "uv",
-        "run",
-        "pre-commit",
-        "run",
-        "--color=always",
-        "--all-files",
-    ]
-    try:
-        local["devbox"].with_cwd(HERE)[args] & TEE
-    except CommandNotFound:
-        _logger.warning("Devbox not found; fallback to a container")
-        runner = local.get("podman", "docker")
-        try:
-            (
-                runner[
-                    "container",
-                    "create",
-                    "--name=copier-lint-v1",
-                    f"--volume={HERE}:{HERE}:rw,z",
-                    f"--workdir={HERE}",
-                    "docker.io/jetpackio/devbox:0.15.1",
-                    "devbox",
-                ][args]
-                & TEE
-            )
-        except ProcessExecutionError:
-            _logger.info(
-                "Couldn't create copier-lint-v1 container, probably because a previous one exists. "
-                "Remove it if you want to recycle it. Otherwise, this is OK."
-            )
-        runner["container", "start", "--attach", "copier-lint-v1"] & TEE
-    except ProcessExecutionError as error:
-        raise SystemExit(error.errno)
