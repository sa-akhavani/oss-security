--- a/hazelcast-build-utils/src/main/java/com/hazelcast/buildutils/HazelcastManifestTransformer.java
+++ b/hazelcast-build-utils/src/main/java/com/hazelcast/buildutils/HazelcastManifestTransformer.java
@@ -20,21 +20,20 @@
 import org.apache.maven.plugins.shade.resource.ManifestResourceTransformer;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.jar.Attributes;
-import java.util.jar.Attributes.Name;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 import java.util.jar.JarOutputStream;
 import java.util.jar.Manifest;
 import static java.util.Arrays.asList;
 import static java.util.Collections.emptySet;
 import static org.codehaus.plexus.util.IOUtil.close;
 import static org.codehaus.plexus.util.StringUtils.join;
 /**
  * This transformer implementation is used to merge MANIFEST and OSGi
@@ -42,21 +41,20 @@
  * integrating multiple dependencies into one output JAR.
  */
 public class HazelcastManifestTransformer extends ManifestResourceTransformer {
     private static final String VERSION_PREFIX = "version=";
     private static final String RESOLUTION_PREFIX = "resolution:=";
     private static final String USES_PREFIX = "uses:=";
     private static final int VERSION_OFFSET = 8;
     private static final int USES_OFFSET = 7;
     private static final String IMPORT_PACKAGE = "Import-Package";
     private static final String EXPORT_PACKAGE = "Export-Package";
-    private static final Name AUTOMATIC_MODULE_NAME = new Name("Automatic-Module-Name");
     @SuppressFBWarnings(value = "UWF_UNWRITTEN_FIELD", justification = "Filled by Maven")
     String mainClass;
     @SuppressFBWarnings(value = "UWF_UNWRITTEN_FIELD", justification = "Filled by Maven")
     Map<String, Attributes> manifestEntries;
     @SuppressFBWarnings(value = "UWF_UNWRITTEN_FIELD", justification = "Filled by Maven")
     Map<String, String> overrideInstructions;
     private final Map<String, PackageDefinition> importedPackages = new HashMap<String, PackageDefinition>();
     private final Map<String, PackageDefinition> exportedPackages = new HashMap<String, PackageDefinition>();
     private final List<InstructionDefinition> importOverrideInstructions = new ArrayList<InstructionDefinition>();
     private final List<InstructionDefinition> exportOverrideInstructions = new ArrayList<InstructionDefinition>();
@@ -145,21 +143,20 @@
         attributes.putValue(EXPORT_PACKAGE, join(shadeExports().iterator(), ","));
         attributes.putValue("Created-By", "HazelcastManifestTransformer through Shade Plugin");
         if (mainClass != null) {
             attributes.put(Attributes.Name.MAIN_CLASS, mainClass);
         }
         if (manifestEntries != null) {
             for (Map.Entry<String, Attributes> entry : manifestEntries.entrySet()) {
                 attributes.put(new Attributes.Name(entry.getKey()), entry.getValue());
             }
         }
-        attributes.remove(AUTOMATIC_MODULE_NAME);
         jarOutputStream.putNextEntry(new JarEntry(JarFile.MANIFEST_NAME));
         shadedManifest.write(jarOutputStream);
         jarOutputStream.flush();
     }
     @SuppressFBWarnings(value = "NP_UNWRITTEN_FIELD", justification = "Field is set by Maven")
     private void precompileOverrideInstructions() {
         String importPackageInstructions = overrideInstructions.get(IMPORT_PACKAGE);
         if (importPackageInstructions != null) {
             List<String> packageInstructions = ElementParser.parseDelimitedString(importPackageInstructions, ',', true);
             for (String packageInstruction : packageInstructions) {

--- a/hazelcast-client/src/main/java/com/hazelcast/client/AuthenticationException.java
+++ b//dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.hazelcast.client;
-import com.hazelcast.core.HazelcastException;
-/**
- * A {@link HazelcastException} that is thrown when there is an Authentication failure: e.g. credentials from client is not valid.
- */
-public class AuthenticationException extends HazelcastException {
-    /**
-     * Creates a AuthenticationException with a default message.
-     */
-    public AuthenticationException() {
-        super("Wrong group name or password.");
-    }
-    /**
-     * Creates a AuthenticationException with the given message.
-     *
-     * @param message the message.
-     */
-    public AuthenticationException(String message) {
-        super(message);
-    }
-}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/ClientExtension.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/ClientExtension.java
@@ -7,31 +7,31 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.spi.ClientProxyFactory;
 import com.hazelcast.internal.nearcache.NearCacheManager;
-import com.hazelcast.internal.networking.ChannelInitializer;
+import com.hazelcast.internal.networking.ChannelFactory;
 import com.hazelcast.internal.serialization.InternalSerializationService;
 import com.hazelcast.map.impl.MapService;
 import com.hazelcast.memory.MemoryStats;
 import com.hazelcast.nio.SocketInterceptor;
 /**
  * ClientExtension is a client extension mechanism to be able to plug different implementations of
- * some modules, like; {@link InternalSerializationService} etc.
+ * some modules, like; {@link InternalSerializationService}, {@link ChannelFactory} etc.
  */
 public interface ClientExtension {
     /**
      * Called before client is started
      */
     void beforeStart(HazelcastClientInstanceImpl client);
     /**
      * Called after node is started
      */
     void afterStart(HazelcastClientInstanceImpl client);
@@ -44,21 +44,26 @@
      */
     InternalSerializationService createSerializationService(byte version);
     /**
      * Creates a {@link SocketInterceptor} to be used by this client if available,
      * otherwise returns <code>null</code>
      *
      * @return the created {@link SocketInterceptor} instance if available,
      * +          otherwise <code>null</code>
      */
     SocketInterceptor createSocketInterceptor();
-    ChannelInitializer createChannelInitializer();
+    /**
+     * Creates a {@link ChannelFactory} instance to be used by this client.
+     *
+     * @return the created {@link ChannelFactory} instance
+     */
+    ChannelFactory createSocketChannelWrapperFactory();
     /**
      * Creates a {@link NearCacheManager} instance to be used by this client.
      *
      * @return the created {@link NearCacheManager} instance
      */
     NearCacheManager createNearCacheManager();
     /**
      * Creates a {@code ClientProxyFactory} for the supplied service class. Currently only the {@link MapService} is supported.
      *
      * @param service service for the proxy to create.

--- a/hazelcast-client/src/main/java/com/hazelcast/client/ClientOutOfMemoryHandler.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/ClientOutOfMemoryHandler.java
@@ -8,21 +8,21 @@
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client;
 import com.hazelcast.client.connection.nio.ClientConnectionManagerImpl;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.core.HazelcastInstance;
 import com.hazelcast.instance.DefaultOutOfMemoryHandler;
 import static com.hazelcast.util.EmptyStatement.ignore;
 /**
  * To clear resources of the client upon OutOfMemory
  */
 public class ClientOutOfMemoryHandler extends DefaultOutOfMemoryHandler {
     @Override
     public void onOutOfMemory(OutOfMemoryError oome, HazelcastInstance[] hazelcastInstances) {
         for (HazelcastInstance instance : hazelcastInstances) {

--- a/hazelcast-client/src/main/java/com/hazelcast/client/HazelcastClient.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/HazelcastClient.java
@@ -8,23 +8,23 @@
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client;
 import com.hazelcast.client.config.ClientConfig;
-import com.hazelcast.client.impl.clientside.ClientConnectionManagerFactory;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
-import com.hazelcast.client.impl.clientside.HazelcastClientProxy;
+import com.hazelcast.client.impl.ClientConnectionManagerFactory;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientProxy;
 import com.hazelcast.core.HazelcastInstance;
 import com.hazelcast.core.OutOfMemoryHandler;
 import java.util.Collection;
 /**
  * The HazelcastClient is comparable to the {@link com.hazelcast.core.Hazelcast} class and provides the ability
  * the create and manage Hazelcast clients. Hazelcast clients are {@link HazelcastInstance} implementations, so
  * in most cases most of the code is unaware of talking to a cluster member or a client.
  * <p/>
  * <h1>Smart vs dumb clients</h1>
  * Hazelcast Client enables you to do all Hazelcast operations without being a member of the cluster. Clients can be:

--- a/hazelcast-client/src/main/java/com/hazelcast/client/HazelcastClientFactory.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/HazelcastClientFactory.java
@@ -8,23 +8,23 @@
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client;
 import com.hazelcast.client.config.ClientConfig;
-import com.hazelcast.client.impl.clientside.ClientConnectionManagerFactory;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
-import com.hazelcast.client.impl.clientside.HazelcastClientProxy;
+import com.hazelcast.client.impl.ClientConnectionManagerFactory;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientProxy;
 /**
  * Provides the capability for the customization of Hazelcast client factories.
  *
  * Its implementation can be changed and passed to the constructors of {@link HazelcastClientManager}.
  *
  * @param <T> type of {@link HazelcastClientInstanceImpl}
  * @param <V> type of {@link HazelcastClientProxy}
  * @param <C> type of {@link ClientConfig}
  */
 public interface HazelcastClientFactory<T extends HazelcastClientInstanceImpl,

--- a/hazelcast-client/src/main/java/com/hazelcast/client/HazelcastClientManager.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/HazelcastClientManager.java
@@ -9,24 +9,24 @@
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client;
 import com.hazelcast.client.config.ClientConfig;
 import com.hazelcast.client.config.XmlClientConfigBuilder;
-import com.hazelcast.client.impl.clientside.ClientConnectionManagerFactory;
-import com.hazelcast.client.impl.clientside.DefaultClientConnectionManagerFactory;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
-import com.hazelcast.client.impl.clientside.HazelcastClientProxy;
+import com.hazelcast.client.impl.ClientConnectionManagerFactory;
+import com.hazelcast.client.impl.DefaultClientConnectionManagerFactory;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientProxy;
 import com.hazelcast.core.DuplicateInstanceNameException;
 import com.hazelcast.core.HazelcastInstance;
 import com.hazelcast.core.OutOfMemoryHandler;
 import com.hazelcast.instance.OutOfMemoryErrorDispatcher;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import static com.hazelcast.util.EmptyStatement.ignore;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/UndefinedErrorCodeException.java
+++ b//dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.hazelcast.client;
-import com.hazelcast.core.HazelcastException;
-/**
- * This exception is thrown when an exception that is coming from server is not recognized by the protocol.
- * Class name of the original exception is included in the exception
- */
-public class UndefinedErrorCodeException extends HazelcastException {
-    private final String className;
-    public UndefinedErrorCodeException(String message, String className) {
-        super("Class name: " + className + ", Message: " + message);
-        this.className = className;
-    }
-    /**
-     * @return name of the original class name
-     */
-    public String getOriginClassName() {
-        return className;
-    }
-}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/AbstractClientCacheProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/AbstractClientCacheProxy.java
@@ -8,52 +8,49 @@
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.cache.impl;
 import com.hazelcast.cache.CacheStatistics;
-import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
+import com.hazelcast.client.impl.ClientMessageDecoder;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.CacheGetAllCodec;
 import com.hazelcast.client.impl.protocol.codec.CacheGetCodec;
 import com.hazelcast.client.impl.protocol.codec.CachePutAllCodec;
-import com.hazelcast.client.impl.protocol.codec.CacheSetExpiryPolicyCodec;
 import com.hazelcast.client.impl.protocol.codec.CacheSizeCodec;
 import com.hazelcast.client.spi.ClientContext;
 import com.hazelcast.client.spi.ClientPartitionService;
 import com.hazelcast.client.spi.impl.ClientInvocation;
 import com.hazelcast.client.spi.impl.ClientInvocationFuture;
 import com.hazelcast.client.util.ClientDelegatingFuture;
 import com.hazelcast.config.CacheConfig;
 import com.hazelcast.core.ExecutionCallback;
 import com.hazelcast.core.ICompletableFuture;
 import com.hazelcast.nio.serialization.Data;
 import com.hazelcast.spi.InternalCompletableFuture;
-import com.hazelcast.util.FutureUtil;
 import javax.cache.CacheException;
 import javax.cache.expiry.ExpiryPolicy;
 import java.util.AbstractMap;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import static com.hazelcast.cache.impl.CacheProxyUtil.NULL_KEY_IS_NOT_ALLOWED;
 import static com.hazelcast.cache.impl.CacheProxyUtil.validateNotNull;
-import static com.hazelcast.cache.impl.operation.MutableOperation.IGNORE_COMPLETION;
 import static com.hazelcast.util.CollectionUtil.objectToDataCollection;
 import static com.hazelcast.util.ExceptionUtil.rethrow;
 import static com.hazelcast.util.ExceptionUtil.rethrowAllowedTypeFirst;
 import static com.hazelcast.util.MapUtil.createHashMap;
 import static com.hazelcast.util.Preconditions.checkNotNull;
 import static java.util.Collections.emptyMap;
 /**
  * Hazelcast provides extension functionality to default spec interface {@link javax.cache.Cache}.
  * {@link com.hazelcast.cache.ICache} is the designated interface.
  *
@@ -232,45 +229,20 @@
     @SuppressWarnings("unchecked")
     public void putAll(Map<? extends K, ? extends V> map, ExpiryPolicy expiryPolicy) {
         long startNanos = nowInNanosOrDefault();
         ensureOpen();
         checkNotNull(map, "map is null");
         if (map.isEmpty()) {
             return;
         }
         putAllInternal(map, expiryPolicy, null, new List[partitionCount], startNanos);
     }
-    @Override
-    public void setExpiryPolicy(Set<? extends K> keys, ExpiryPolicy policy) {
-        ensureOpen();
-        checkNotNull(keys);
-        checkNotNull(policy);
-        if (keys.isEmpty()) {
-            return;
-        }
-        setExpiryPolicyInternal(keys, policy);
-    }
-    @Override
-    public boolean setExpiryPolicy(K key, ExpiryPolicy expiryPolicy) {
-        return setExpiryPolicyInternal(key, expiryPolicy);
-    }
-    protected void setExpiryPolicyInternal(Set<? extends K> keys, ExpiryPolicy policy) {
-        setExpiryPolicyInternal(keys, policy, null);
-    }
-    protected void setExpiryPolicyInternal(Set<? extends K> keys, ExpiryPolicy policy, Set<Data> serializedKeys) {
-        try {
-            List<Data>[] keysByPartition = groupKeysToPartitions(keys, serializedKeys);
-            setExpiryPolicyAndWaitForCompletion(keysByPartition, policy);
-        } catch (Exception e) {
-            throw rethrow(e);
-        }
-    }
     protected void putAllInternal(Map<? extends K, ? extends V> map, ExpiryPolicy expiryPolicy, Map<Object, Data> keyMap,
                                   List<Map.Entry<Data, Data>>[] entriesPerPartition, long startNanos) {
         try {
             groupDataToPartitions(map, getContext().getPartitionService(), keyMap, entriesPerPartition);
             putToAllPartitionsAndWaitForCompletion(entriesPerPartition, expiryPolicy, startNanos);
         } catch (Exception t) {
             throw rethrow(t);
         }
     }
     private void groupDataToPartitions(Map<? extends K, ? extends V> map, ClientPartitionService partitionService,
@@ -285,38 +257,20 @@
                 keyMap.put(key, keyData);
             }
             int partitionId = partitionService.getPartitionId(keyData);
             List<Map.Entry<Data, Data>> entries = entriesPerPartition[partitionId];
             if (entries == null) {
                 entries = new ArrayList<Map.Entry<Data, Data>>();
                 entriesPerPartition[partitionId] = entries;
             }
             entries.add(new AbstractMap.SimpleImmutableEntry<Data, Data>(keyData, valueData));
         }
-    }
-    private List<Data>[] groupKeysToPartitions(Set<? extends K> keys, Set<Data> serializedKeys) {
-        List<Data>[] keysByPartition = new List[partitionCount];
-        ClientPartitionService partitionService = getContext().getPartitionService();
-        for (K key: keys) {
-            Data keyData = getSerializationService().toData(key);
-            if (serializedKeys != null) {
-                serializedKeys.add(keyData);
-            }
-            int partitionId = partitionService.getPartitionId(keyData);
-            List<Data> partition = keysByPartition[partitionId];
-            if (partition == null) {
-                partition = new ArrayList<Data>();
-                keysByPartition[partitionId] = partition;
-            }
-            partition.add(keyData);
-        }
-        return keysByPartition;
     }
     private static final class FutureEntriesTuple {
         private final Future future;
         private final List<Map.Entry<Data, Data>> entries;
         private FutureEntriesTuple(Future future, List<Map.Entry<Data, Data>> entries) {
             this.future = future;
             this.entries = entries;
         }
     }
     private void putToAllPartitionsAndWaitForCompletion(List<Map.Entry<Data, Data>>[] entriesPerPartition,
@@ -327,35 +281,20 @@
         for (int partitionId = 0; partitionId < entriesPerPartition.length; partitionId++) {
             List<Map.Entry<Data, Data>> entries = entriesPerPartition[partitionId];
             if (entries != null) {
                 int completionId = nextCompletionId();
                 ClientMessage request = CachePutAllCodec.encodeRequest(nameWithPrefix, entries, expiryPolicyData, completionId);
                 Future future = invoke(request, partitionId, completionId);
                 futureEntriesTuples.add(new FutureEntriesTuple(future, entries));
             }
         }
         waitResponseFromAllPartitionsForPutAll(futureEntriesTuples, startNanos);
-    }
-    private void setExpiryPolicyAndWaitForCompletion(List<Data>[] keysByPartition, ExpiryPolicy expiryPolicy) {
-        List<Future> futures = new ArrayList<Future>(keysByPartition.length);
-        Data policyData = toData(expiryPolicy);
-        for (int partitionId = 0; partitionId < keysByPartition.length; partitionId++) {
-            List<Data> keys = keysByPartition[partitionId];
-            if (keys != null) {
-                ClientMessage request = CacheSetExpiryPolicyCodec.encodeRequest(nameWithPrefix, keys, policyData);
-                futures.add(invoke(request, partitionId, IGNORE_COMPLETION));
-            }
-        }
-        List<Throwable> throwables = FutureUtil.waitUntilAllResponded(futures);
-        if (throwables.size() > 0) {
-            throw rethrow(throwables.get(0));
-        }
     }
     private void waitResponseFromAllPartitionsForPutAll(List<FutureEntriesTuple> futureEntriesTuples, long startNanos) {
         Throwable error = null;
         for (FutureEntriesTuple tuple : futureEntriesTuples) {
             Future future = tuple.future;
             List<Map.Entry<Data, Data>> entries = tuple.entries;
             try {
                 future.get();
                 if (statisticsEnabled) {
                     statsHandler.getStatistics().increaseCachePuts(entries.size());

--- a/hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/AbstractClientCacheProxyBase.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/AbstractClientCacheProxyBase.java
@@ -9,21 +9,21 @@
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.cache.impl;
 import com.hazelcast.cache.impl.ICacheInternal;
 import com.hazelcast.cache.impl.ICacheService;
-import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
+import com.hazelcast.client.impl.ClientMessageDecoder;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.spi.ClientContext;
 import com.hazelcast.client.spi.ClientProxy;
 import com.hazelcast.client.spi.impl.ClientInvocation;
 import com.hazelcast.client.spi.impl.ClientInvocationFuture;
 import com.hazelcast.client.util.ClientDelegatingFuture;
 import com.hazelcast.config.CacheConfig;
 import com.hazelcast.core.ExecutionCallback;
 import com.hazelcast.core.ManagedContext;
 import com.hazelcast.logging.ILogger;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/AbstractClientInternalCacheProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/AbstractClientInternalCacheProxy.java
@@ -13,55 +13,52 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.cache.impl;
 import com.hazelcast.cache.HazelcastCacheManager;
 import com.hazelcast.cache.impl.CacheEventData;
 import com.hazelcast.cache.impl.CacheEventListenerAdaptor;
 import com.hazelcast.cache.impl.CacheSyncListenerCompleter;
 import com.hazelcast.cache.impl.operation.MutableOperation;
 import com.hazelcast.client.HazelcastClientNotActiveException;
-import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
+import com.hazelcast.client.impl.ClientMessageDecoder;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.CacheAddEntryListenerCodec;
 import com.hazelcast.client.impl.protocol.codec.CacheClearCodec;
 import com.hazelcast.client.impl.protocol.codec.CacheGetAndRemoveCodec;
 import com.hazelcast.client.impl.protocol.codec.CacheGetAndReplaceCodec;
 import com.hazelcast.client.impl.protocol.codec.CachePutCodec;
 import com.hazelcast.client.impl.protocol.codec.CachePutIfAbsentCodec;
 import com.hazelcast.client.impl.protocol.codec.CacheRemoveAllCodec;
 import com.hazelcast.client.impl.protocol.codec.CacheRemoveAllKeysCodec;
 import com.hazelcast.client.impl.protocol.codec.CacheRemoveCodec;
 import com.hazelcast.client.impl.protocol.codec.CacheReplaceCodec;
-import com.hazelcast.client.impl.protocol.codec.CacheSetExpiryPolicyCodec;
 import com.hazelcast.client.spi.ClientContext;
 import com.hazelcast.client.spi.ClientListenerService;
 import com.hazelcast.client.spi.ClientPartitionService;
 import com.hazelcast.client.spi.EventHandler;
 import com.hazelcast.client.spi.impl.ClientInvocation;
 import com.hazelcast.client.spi.impl.ClientInvocationFuture;
 import com.hazelcast.client.util.ClientDelegatingFuture;
 import com.hazelcast.config.CacheConfig;
 import com.hazelcast.core.ExecutionCallback;
 import com.hazelcast.core.ICompletableFuture;
 import com.hazelcast.nio.IOUtil;
 import com.hazelcast.nio.serialization.Data;
 import javax.cache.CacheException;
 import javax.cache.CacheManager;
 import javax.cache.configuration.CacheEntryListenerConfiguration;
 import javax.cache.event.CacheEntryListener;
 import javax.cache.expiry.ExpiryPolicy;
 import java.io.Closeable;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Iterator;
-import java.util.List;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 import static com.hazelcast.cache.impl.CacheProxyUtil.validateConfiguredTypes;
 import static com.hazelcast.cache.impl.CacheProxyUtil.validateNotNull;
@@ -120,26 +117,20 @@
             return (T) CachePutCodec.decodeResponse(clientMessage).response;
         }
     };
     @SuppressWarnings("unchecked")
     private static final ClientMessageDecoder PUT_IF_ABSENT_RESPONSE_DECODER = new ClientMessageDecoder() {
         @Override
         public <T> T decodeClientMessage(ClientMessage clientMessage) {
             return (T) Boolean.valueOf(CachePutIfAbsentCodec.decodeResponse(clientMessage).response);
         }
     };
-    private static final ClientMessageDecoder SET_EXPIRY_POLICY_DECODER = new ClientMessageDecoder() {
-        @Override
-        public <T> T decodeClientMessage(ClientMessage clientMessage) {
-            return (T) Boolean.valueOf(CacheSetExpiryPolicyCodec.decodeResponse(clientMessage).response);
-        }
-    };
     protected final AtomicReference<HazelcastClientCacheManager> cacheManagerRef
             = new AtomicReference<HazelcastClientCacheManager>();
     protected int partitionCount;
     private final ConcurrentMap<CacheEntryListenerConfiguration, String> asyncListenerRegistrations;
     private final ConcurrentMap<CacheEntryListenerConfiguration, String> syncListenerRegistrations;
     private final ConcurrentMap<String, Closeable> closeableListeners;
     private final ConcurrentMap<Integer, CountDownLatch> syncLocks;
     AbstractClientInternalCacheProxy(CacheConfig<K, V> cacheConfig, ClientContext context) {
         super(cacheConfig, context);
         this.asyncListenerRegistrations = new ConcurrentHashMap<CacheEntryListenerConfiguration, String>();
@@ -413,36 +404,20 @@
         CallbackAwareClientDelegatingFuture<V> future = new CallbackAwareClientDelegatingFuture<V>(invocationFuture,
                 getSerializationService(), PUT_RESPONSE_DECODER, callback);
         future.andThenInternal(callback, true);
         return future;
     }
     protected OneShotExecutionCallback<V> newStatsCallbackOrNull(boolean isGet) {
         if (!statisticsEnabled) {
             return null;
         }
         return statsHandler.newOnPutCallback(isGet, System.nanoTime());
-    }
-    protected boolean setExpiryPolicyInternal(K key, ExpiryPolicy expiryPolicy) {
-        ensureOpen();
-        validateNotNull(key);
-        validateNotNull(expiryPolicy);
-        Data keyData = toData(key);
-        Data expiryPolicyData = toData(expiryPolicy);
-        List<Data> list = Collections.singletonList(keyData);
-        ClientMessage request = CacheSetExpiryPolicyCodec.encodeRequest(nameWithPrefix, list, expiryPolicyData);
-        ClientInvocationFuture future = invoke(request, keyData, IGNORE_COMPLETION);
-        ClientDelegatingFuture<Boolean> delegatingFuture = newDelegatingFuture(future, SET_EXPIRY_POLICY_DECODER);
-        try {
-            return delegatingFuture.get();
-        } catch (Throwable e) {
-            throw rethrowAllowedTypeFirst(e, CacheException.class);
-        }
     }
     protected Object putIfAbsentInternal(K key, V value, ExpiryPolicy expiryPolicy, boolean withCompletionEvent, boolean async) {
         long startNanos = nowInNanosOrDefault();
         ensureOpen();
         validateNotNull(key, value);
         validateConfiguredTypes(cacheConfig, key, value);
         Data keyData = toData(key);
         Data valueData = toData(value);
         Data expiryPolicyData = toData(expiryPolicy);
         int completionId = withCompletionEvent ? nextCompletionId() : -1;
@@ -647,21 +622,21 @@
         return new CacheEventHandler(adaptor);
     }
     private final class CacheEventHandler
             extends CacheAddEntryListenerCodec.AbstractEventHandler
             implements EventHandler<ClientMessage> {
         private final CacheEventListenerAdaptor<K, V> adaptor;
         private CacheEventHandler(CacheEventListenerAdaptor<K, V> adaptor) {
             this.adaptor = adaptor;
         }
         @Override
-        public void handleCacheEventV10(int type, Collection<CacheEventData> keys, int completionId) {
+        public void handle(int type, Collection<CacheEventData> keys, int completionId) {
             adaptor.handle(type, keys, completionId);
         }
         @Override
         public void beforeListenerRegister() {
         }
         @Override
         public void onListenerRegister() {
         }
     }
 }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/CallbackAwareClientDelegatingFuture.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/CallbackAwareClientDelegatingFuture.java
@@ -7,21 +7,21 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.cache.impl;
-import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
+import com.hazelcast.client.impl.ClientMessageDecoder;
 import com.hazelcast.client.spi.impl.ClientInvocationFuture;
 import com.hazelcast.client.util.ClientDelegatingFuture;
 import com.hazelcast.spi.serialization.SerializationService;
 import com.hazelcast.util.Clock;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import static com.hazelcast.util.ExceptionUtil.sneakyThrow;
 /**
  * A specific {@link ClientDelegatingFuture} implementation which calls given {@link OneShotExecutionCallback} as sync on get.

--- a/hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/ClientCacheHelper.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/ClientCacheHelper.java
@@ -10,21 +10,21 @@
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.cache.impl;
 import com.hazelcast.cache.impl.CacheProxyUtil;
 import com.hazelcast.client.HazelcastClientNotActiveException;
 import com.hazelcast.client.connection.nio.ClientConnection;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.CacheCreateConfigCodec;
 import com.hazelcast.client.impl.protocol.codec.CacheGetConfigCodec;
 import com.hazelcast.client.impl.protocol.codec.CacheManagementConfigCodec;
 import com.hazelcast.client.spi.impl.AbstractClientInvocationService;
 import com.hazelcast.client.spi.impl.ClientInvocation;
 import com.hazelcast.client.spi.properties.ClientProperty;
 import com.hazelcast.config.CacheConfig;
 import com.hazelcast.config.LegacyCacheConfig;
 import com.hazelcast.core.Member;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/ClientCacheProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/ClientCacheProxy.java
@@ -12,21 +12,21 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.cache.impl;
 import com.hazelcast.cache.impl.CacheEntryProcessorResult;
 import com.hazelcast.cache.impl.CacheEventListenerAdaptor;
 import com.hazelcast.cache.impl.event.CachePartitionLostEvent;
 import com.hazelcast.cache.impl.event.CachePartitionLostListener;
 import com.hazelcast.cache.journal.EventJournalCacheEvent;
-import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
+import com.hazelcast.client.impl.ClientMessageDecoder;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.CacheAddEntryListenerCodec;
 import com.hazelcast.client.impl.protocol.codec.CacheAddPartitionLostListenerCodec;
 import com.hazelcast.client.impl.protocol.codec.CacheContainsKeyCodec;
 import com.hazelcast.client.impl.protocol.codec.CacheEntryProcessorCodec;
 import com.hazelcast.client.impl.protocol.codec.CacheEventJournalReadCodec;
 import com.hazelcast.client.impl.protocol.codec.CacheEventJournalSubscribeCodec;
 import com.hazelcast.client.impl.protocol.codec.CacheEventJournalSubscribeCodec.ResponseParameters;
 import com.hazelcast.client.impl.protocol.codec.CacheListenerRegistrationCodec;
 import com.hazelcast.client.impl.protocol.codec.CacheLoadAllCodec;
@@ -488,16 +488,16 @@
         private ClientCachePartitionLostEventHandler(CachePartitionLostListener listener) {
             this.listener = listener;
         }
         @Override
         public void beforeListenerRegister() {
         }
         @Override
         public void onListenerRegister() {
         }
         @Override
-        public void handleCachePartitionLostEventV10(int partitionId, String uuid) {
+        public void handle(int partitionId, String uuid) {
             Member member = getContext().getClusterService().getMember(uuid);
             listener.partitionLost(new CachePartitionLostEvent(name, member, PARTITION_LOST.getType(), partitionId));
         }
     }
 }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/ClientCacheProxyFactory.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/ClientCacheProxyFactory.java
@@ -9,21 +9,21 @@
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.cache.impl;
 import com.hazelcast.cache.CacheNotExistsException;
 import com.hazelcast.cache.HazelcastCacheManager;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.spi.ClientContext;
 import com.hazelcast.client.spi.ClientProxy;
 import com.hazelcast.client.spi.impl.ClientProxyFactoryWithContext;
 import com.hazelcast.config.CacheConfig;
 import com.hazelcast.config.NearCacheConfig;
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/ClientClusterWideIterator.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/ClientClusterWideIterator.java
@@ -9,21 +9,21 @@
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.cache.impl;
 import com.hazelcast.cache.impl.AbstractClusterWideIterator;
 import com.hazelcast.cache.impl.ICacheInternal;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.CacheIterateCodec;
 import com.hazelcast.client.impl.protocol.codec.CacheIterateEntriesCodec;
 import com.hazelcast.client.spi.ClientContext;
 import com.hazelcast.client.spi.impl.ClientInvocation;
 import com.hazelcast.client.spi.impl.ClientInvocationFuture;
 import com.hazelcast.nio.serialization.Data;
 import javax.cache.Cache;
 import java.util.Iterator;
 import java.util.List;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/HazelcastClientCacheManager.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/HazelcastClientCacheManager.java
@@ -11,24 +11,23 @@
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.cache.impl;
 import com.hazelcast.cache.HazelcastCachingProvider;
 import com.hazelcast.cache.impl.AbstractHazelcastCacheManager;
 import com.hazelcast.cache.impl.ICacheInternal;
 import com.hazelcast.cache.impl.ICacheService;
-import com.hazelcast.client.impl.clientside.ClientICacheManager;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
-import com.hazelcast.client.impl.clientside.HazelcastClientProxy;
-import com.hazelcast.client.spi.ProxyManager;
+import com.hazelcast.client.impl.ClientICacheManager;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientProxy;
 import com.hazelcast.config.CacheConfig;
 import com.hazelcast.core.HazelcastInstance;
 import com.hazelcast.internal.nearcache.NearCacheManager;
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import java.net.URI;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Properties;
 import static com.hazelcast.internal.config.ConfigValidator.checkCacheConfig;
 import static com.hazelcast.util.ExceptionUtil.rethrow;
@@ -40,49 +39,47 @@
  */
 public final class HazelcastClientCacheManager extends AbstractHazelcastCacheManager {
     private final HazelcastClientInstanceImpl client;
     private final ClientCacheProxyFactory clientCacheProxyFactory;
     public HazelcastClientCacheManager(HazelcastClientCachingProvider cachingProvider, HazelcastInstance hazelcastInstance,
                                        URI uri, ClassLoader classLoader, Properties properties) {
         super(cachingProvider, hazelcastInstance, uri, classLoader, properties);
         /*
          * TODO:
          *
-         * A new interface, such as `InternalHazelcastInstance` (with a
-         * `getOriginalInstance()` method), might be introduced. Then the
-         * underlying actual (original) Hazelcast instance can be retrieved
-         * through this.
+         * A new interface, such as `InternalHazelcastInstance` (has `getOriginalInstance()` method),
+         * might be introduced. Then underlying actual (original) Hazelcast instance is retrieved through this.
          *
-         * The original Hazelcast instance is used for getting access to
-         * internals. It's also used for passing the full cache name directly
-         * by this cache manager itself.
+         * Original Hazelcast instance is used for getting `NearCacheManager` and
+         * passing full cache name directly by this cache manager itself.
          */
         if (hazelcastInstance instanceof HazelcastClientProxy) {
             client = ((HazelcastClientProxy) hazelcastInstance).client;
         } else {
             client = ((HazelcastClientInstanceImpl) hazelcastInstance);
         }
-        ProxyManager proxyManager = client.getProxyManager();
-        clientCacheProxyFactory = (ClientCacheProxyFactory) proxyManager.getClientProxyFactory(ICacheService.SERVICE_NAME);
+        clientCacheProxyFactory =
+                (ClientCacheProxyFactory) client.getProxyManager().getClientProxyFactory(ICacheService.SERVICE_NAME);
     }
     @Override
     public void enableManagement(String cacheName, boolean enabled) {
         enableStatisticManagementOnNodes(cacheName, false, enabled);
     }
     @Override
     public void enableStatistics(String cacheName, boolean enabled) {
         enableStatisticManagementOnNodes(cacheName, true, enabled);
     }
     private void enableStatisticManagementOnNodes(String cacheName, boolean statOrMan, boolean enabled) {
         ensureOpen();
         checkNotNull(cacheName, "cacheName cannot be null");
-        ClientCacheHelper.enableStatisticManagementOnNodes(client, getCacheNameWithPrefix(cacheName), statOrMan, enabled);
+        ClientCacheHelper.enableStatisticManagementOnNodes(client, getCacheNameWithPrefix(cacheName),
+                statOrMan, enabled);
     }
     @SuppressFBWarnings("RV_RETURN_VALUE_OF_PUTIFABSENT_IGNORED")
     @Override
     protected <K, V> void addCacheConfigIfAbsent(CacheConfig<K, V> cacheConfig) {
         clientCacheProxyFactory.addCacheConfig(cacheConfig.getNameWithPrefix(), cacheConfig);
     }
     @Override
     protected void removeCacheConfigFromLocal(String cacheNameWithPrefix) {
         clientCacheProxyFactory.removeCacheConfig(cacheNameWithPrefix);
     }
@@ -98,60 +95,58 @@
             String nameWithPrefix = cacheConfig.getNameWithPrefix();
             ICacheInternal<K, V> cache = (ICacheInternal<K, V>) cacheManager.getCacheByFullName(nameWithPrefix);
             cache.setCacheManager(this);
             return cache;
         } catch (Throwable t) {
             clientCacheProxyFactory.removeCacheConfig(cacheConfig.getNameWithPrefix());
             throw rethrow(t);
         }
     }
     @Override
-    @SuppressWarnings("unchecked")
     protected <K, V> CacheConfig<K, V> findCacheConfig(String cacheName, String simpleCacheName) {
         if (simpleCacheName == null) {
             return null;
         }
         CacheConfig<K, V> config = clientCacheProxyFactory.getCacheConfig(cacheName);
         if (config == null) {
             config = getCacheConfig(cacheName, simpleCacheName);
             if (config != null) {
                 createCacheConfig(cacheName, config);
             }
         }
         return config;
     }
     @Override
     protected <K, V> void createCacheConfig(String cacheName, CacheConfig<K, V> config) {
         ClientCacheHelper.createCacheConfig(client, config);
     }
     @Override
-    @SuppressWarnings("unchecked")
     public <T> T unwrap(Class<T> clazz) {
         if (HazelcastClientCacheManager.class.isAssignableFrom(clazz)) {
             return (T) this;
         }
         throw new IllegalArgumentException();
     }
     @Override
     protected void postClose() {
         if (properties.getProperty(HazelcastCachingProvider.HAZELCAST_CONFIG_LOCATION) != null) {
             hazelcastInstance.shutdown();
         }
     }
     @Override
     protected void postDestroy() {
-        Iterator<Map.Entry<String, CacheConfig>> iterator = clientCacheProxyFactory.configs().iterator();
-        while (iterator.hasNext()) {
-            Map.Entry<String, CacheConfig> entry = iterator.next();
+        Iterator<Map.Entry<String, CacheConfig>> iter = clientCacheProxyFactory.configs().iterator();
+        while (iter.hasNext()) {
+            Map.Entry<String, CacheConfig> entry = iter.next();
             String cacheName = entry.getKey();
             clientCacheProxyFactory.removeCacheConfig(cacheName);
-            iterator.remove();
+            iter.remove();
         }
     }
     @Override
     protected <K, V> void validateCacheConfig(CacheConfig<K, V> cacheConfig) {
         checkCacheConfig(cacheConfig, null);
     }
     @Override
     protected void onShuttingDown() {
     }
     /**

--- a/hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/HazelcastClientCachingProvider.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/HazelcastClientCachingProvider.java
@@ -7,185 +7,172 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.cache.impl;
-import com.hazelcast.cache.impl.AbstractHazelcastCacheManager;
 import com.hazelcast.cache.impl.AbstractHazelcastCachingProvider;
 import com.hazelcast.client.HazelcastClient;
 import com.hazelcast.client.config.ClientConfig;
 import com.hazelcast.client.config.XmlClientConfigBuilder;
 import com.hazelcast.core.HazelcastInstance;
+import com.hazelcast.util.StringUtil;
 import java.io.IOException;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
 import java.util.Properties;
 import static com.hazelcast.cache.HazelcastCachingProvider.HAZELCAST_CONFIG_LOCATION;
 import static com.hazelcast.cache.HazelcastCachingProvider.HAZELCAST_INSTANCE_ITSELF;
 import static com.hazelcast.cache.HazelcastCachingProvider.HAZELCAST_INSTANCE_NAME;
 import static com.hazelcast.util.ExceptionUtil.rethrow;
-import static com.hazelcast.util.StringUtil.isNullOrEmpty;
 import static com.hazelcast.util.StringUtil.isNullOrEmptyAfterTrim;
 /**
- * Hazelcast client implementation of {@link javax.cache.spi.CachingProvider}.
- * <p>
- * Used internally by {@link com.hazelcast.cache.HazelcastCachingProvider} when
- * the JCache type is configured as {@code client}.
- * <p>
- * This implementation creates a new singleton {@link HazelcastInstance}
- * client. This instance is provided into the created managers.
- * <p>
- * If you need to use your already created HazelcastInstance, you can directly
- * create a provider using
- * {@link #createCachingProvider(com.hazelcast.core.HazelcastInstance)}.
- *
- * @see javax.cache.spi.CachingProvider
+ * Client side {@link javax.cache.spi.CachingProvider} implementation.
  */
 public final class HazelcastClientCachingProvider extends AbstractHazelcastCachingProvider {
     public HazelcastClientCachingProvider() {
     }
     /**
      * Helper method for creating caching provider for testing etc.
      */
     public static HazelcastClientCachingProvider createCachingProvider(HazelcastInstance hazelcastInstance) {
-        HazelcastClientCachingProvider cachingProvider = new HazelcastClientCachingProvider();
+        final HazelcastClientCachingProvider cachingProvider = new HazelcastClientCachingProvider();
         cachingProvider.hazelcastInstance = hazelcastInstance;
         return cachingProvider;
     }
     @Override
-    @SuppressWarnings("unchecked")
-    protected <T extends AbstractHazelcastCacheManager> T createCacheManager(HazelcastInstance instance, URI uri,
-                                                                             ClassLoader classLoader, Properties properties) {
-        return (T) new HazelcastClientCacheManager(this, instance, uri, classLoader, properties);
+    protected HazelcastClientCacheManager createCacheManager(HazelcastInstance instance,
+                                                             URI uri, ClassLoader classLoader,
+                                                             Properties properties) {
+        return new HazelcastClientCacheManager(this, instance, uri, classLoader, properties);
     }
     @Override
     protected HazelcastInstance getOrCreateInstance(URI uri, ClassLoader classLoader, Properties properties)
             throws URISyntaxException, IOException {
         HazelcastInstance instanceItself = (HazelcastInstance) properties.get(HAZELCAST_INSTANCE_ITSELF);
         if (instanceItself != null) {
             return instanceItself;
         }
         String location = properties.getProperty(HAZELCAST_CONFIG_LOCATION);
         String instanceName = properties.getProperty(HAZELCAST_INSTANCE_NAME);
         if (location != null) {
             ClientConfig config = getConfigFromLocation(location, classLoader, instanceName);
             return getOrCreateInstanceByConfig(config);
         }
         if (instanceName != null) {
-            return getOrCreateByInstanceName(instanceName);
+            HazelcastInstance instance = getOrCreateByInstanceName(instanceName);
+            return instance;
         }
-        boolean isDefaultURI = (uri == null || uri.equals(getDefaultURI()));
+        final boolean isDefaultURI = (uri == null || uri.equals(getDefaultURI()));
         if (!isDefaultURI) {
             if (isConfigLocation(uri)) {
                 try {
                     ClientConfig config = getConfigFromLocation(uri, classLoader, null);
                     return getOrCreateInstanceByConfig(config);
                 } catch (Exception e) {
                     if (LOGGER.isFinestEnabled()) {
-                        LOGGER.finest("Could not get or create Hazelcast instance from URI " + uri.toString(), e);
+                        LOGGER.finest("Could not get or create hazelcast instance from URI " + uri.toString(), e);
                     }
                 }
             } else {
                 try {
                     return getOrCreateByInstanceName(uri.toString());
                 } catch (Exception e) {
                     if (LOGGER.isFinestEnabled()) {
-                        LOGGER.finest("Could not get Hazelcast instance from instance name " + uri.toString(), e);
+                        LOGGER.finest("Could not get hazelcast instance from instance name " + uri.toString(), e);
                     }
                 }
             }
             return null;
         } else {
             return getDefaultInstance();
         }
     }
     private HazelcastInstance getDefaultInstance() {
         if (hazelcastInstance == null) {
             ClientConfig clientConfig = getDefaultClientConfig();
             if (isNullOrEmptyAfterTrim(clientConfig.getInstanceName())) {
                 hazelcastInstance = HazelcastClient.newHazelcastClient();
             } else {
                 hazelcastInstance = getOrCreateInstanceByConfig(clientConfig);
             }
         }
         return hazelcastInstance;
     }
     /**
-     * Gets an existing {@link HazelcastInstance} by {@code instanceName} or,
-     * if not found, creates a new {@link HazelcastInstance} with the default
-     * configuration and given {@code instanceName}.
+     * Get an existing {@link HazelcastInstance} by {@code instanceName} or, if not found, create a new {@link HazelcastInstance}
+     * with default configuration and given {@code instanceName}.
      *
-     * @param instanceName name to lookup an existing {@link HazelcastInstance}
-     *                     or to create a new one
-     * @return a {@link HazelcastInstance} with the given {@code instanceName}
+     * @param instanceName name by which to lookup existing {@link HazelcastInstance} or create new one.
+     * @return             a {@link HazelcastInstance} with the given {@code instanceName}
      */
     private HazelcastInstance getOrCreateByInstanceName(String instanceName) {
         HazelcastInstance instance = HazelcastClient.getHazelcastClientByName(instanceName);
         if (instance == null) {
             ClientConfig clientConfig = getDefaultClientConfig();
             clientConfig.setInstanceName(instanceName);
             instance = HazelcastClient.newHazelcastClient(clientConfig);
         }
         return instance;
     }
     private ClientConfig getDefaultClientConfig() {
         ClientConfig clientConfig = new XmlClientConfigBuilder().build();
-        if (namedDefaultHzInstance && isNullOrEmpty(clientConfig.getInstanceName())) {
+        if (namedDefaultHzInstance && StringUtil.isNullOrEmpty(clientConfig.getInstanceName())) {
             clientConfig.setInstanceName(SHARED_JCACHE_INSTANCE_NAME);
         }
         return clientConfig;
     }
-    private ClientConfig getConfigFromLocation(String location, ClassLoader classLoader, String instanceName)
+    protected ClientConfig getConfigFromLocation(String location, ClassLoader classLoader, String instanceName)
             throws URISyntaxException, IOException {
         URI uri = new URI(location);
         return getConfigFromLocation(uri, classLoader, instanceName);
     }
-    private ClientConfig getConfigFromLocation(URI location, ClassLoader classLoader, String instanceName)
+    protected ClientConfig getConfigFromLocation(URI uri, ClassLoader classLoader, String instanceName)
             throws URISyntaxException, IOException {
-        String scheme = location.getScheme();
+        String scheme = uri.getScheme();
         if (scheme == null) {
-            location = new URI(System.getProperty(location.getRawSchemeSpecificPart()));
-            scheme = location.getScheme();
+            uri = new URI(System.getProperty(uri.getRawSchemeSpecificPart()));
+            scheme = uri.getScheme();
         }
         ClassLoader theClassLoader = classLoader == null ? getDefaultClassLoader() : classLoader;
         URL configURL;
         if ("classpath".equals(scheme)) {
-            configURL = theClassLoader.getResource(location.getRawSchemeSpecificPart());
+            configURL = theClassLoader.getResource(uri.getRawSchemeSpecificPart());
         } else if ("file".equals(scheme) || "http".equals(scheme) || "https".equals(scheme)) {
-            configURL = location.toURL();
+            configURL = uri.toURL();
         } else {
-            throw new URISyntaxException(location.toString(), "Unsupported protocol in configuration location URL");
+            throw new URISyntaxException(uri.toString(), "Unsupported protocol in configuration location URL");
         }
         try {
-            return getConfig(configURL, theClassLoader, instanceName);
+            return getConfig(configURL, classLoader, instanceName);
         } catch (Exception e) {
             throw rethrow(e);
         }
     }
-    private ClientConfig getConfig(URL configURL, ClassLoader theClassLoader, String instanceName) throws IOException {
-        ClientConfig config = new XmlClientConfigBuilder(configURL).build()
-                .setClassLoader(theClassLoader);
+    private ClientConfig getConfig(URL configURL, ClassLoader theClassLoader, String instanceName)
+            throws IOException {
+        ClientConfig config = new XmlClientConfigBuilder(configURL).build();
+        config.setClassLoader(theClassLoader);
         if (instanceName != null) {
             config.setInstanceName(instanceName);
         } else if (config.getInstanceName() == null) {
             config.setInstanceName(configURL.toString());
         }
         return config;
-    }
-    @Override
-    public String toString() {
-        return "HazelcastClientCachingProvider{hazelcastInstance=" + hazelcastInstance + '}';
     }
     private HazelcastInstance getOrCreateInstanceByConfig(ClientConfig config) {
         HazelcastInstance instance = HazelcastClient.getHazelcastClientByName(config.getInstanceName());
         if (instance == null) {
             instance = HazelcastClient.newHazelcastClient(config);
         }
         return instance;
     }
+    @Override
+    public String toString() {
+        return "HazelcastClientCachingProvider{hazelcastInstance=" + hazelcastInstance + '}';
+    }
 }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/NearCachedClientCacheProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/NearCachedClientCacheProxy.java
@@ -36,21 +36,20 @@
 import com.hazelcast.internal.nearcache.NearCacheManager;
 import com.hazelcast.internal.nearcache.impl.invalidation.RepairingHandler;
 import com.hazelcast.internal.nearcache.impl.invalidation.RepairingTask;
 import com.hazelcast.logging.ILogger;
 import com.hazelcast.nio.serialization.Data;
 import com.hazelcast.spi.InternalCompletableFuture;
 import com.hazelcast.util.executor.CompletedFuture;
 import javax.cache.expiry.ExpiryPolicy;
 import javax.cache.integration.CompletionListener;
 import java.util.Collection;
-import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.UUID;
 import static com.hazelcast.config.InMemoryFormat.NATIVE;
 import static com.hazelcast.config.NearCacheConfig.LocalUpdatePolicy.CACHE;
 import static com.hazelcast.config.NearCacheConfig.LocalUpdatePolicy.CACHE_ON_UPDATE;
 import static com.hazelcast.instance.BuildInfo.calculateVersion;
@@ -266,61 +265,31 @@
             }
             Long reservationId = reservations.get(ncKey);
             if (reservationId != null) {
                 Object cachedValue = tryPublishReserved(ncKey, valueData, reservationId);
                 resultingKeyValuePairs.set(i + 1, cachedValue);
                 reservations.remove(ncKey);
             }
         }
     }
     @Override
-    public void setExpiryPolicyInternal(Set<? extends K> keys, ExpiryPolicy expiryPolicy) {
-        Set<Data> serializedKeys = null;
-        if (serializeKeys) {
-            serializedKeys = new HashSet<Data>(keys.size());
-        }
-        super.setExpiryPolicyInternal(keys, expiryPolicy, serializedKeys);
-        invalidate(keys, serializedKeys);
-    }
-    @Override
-    protected boolean setExpiryPolicyInternal(K key, ExpiryPolicy expiryPolicy) {
-        boolean result = super.setExpiryPolicyInternal(key, expiryPolicy);
-        if (serializeKeys) {
-            invalidateNearCache(toData(key));
-        } else {
-            invalidateNearCache(key);
-        }
-        return result;
-    }
-    @Override
     protected void putAllInternal(Map<? extends K, ? extends V> map, ExpiryPolicy expiryPolicy, Map<Object, Data> keyMap,
                                   List<Map.Entry<Data, Data>>[] entriesPerPartition, long startNanos) {
         try {
             if (!serializeKeys) {
                 keyMap = createHashMap(map.size());
             }
             super.putAllInternal(map, expiryPolicy, keyMap, entriesPerPartition, startNanos);
             cacheOrInvalidate(map, keyMap, entriesPerPartition, true);
         } catch (Throwable t) {
             cacheOrInvalidate(map, keyMap, entriesPerPartition, false);
             throw rethrow(t);
-        }
-    }
-    private void invalidate(Set<? extends K> keys, Set<Data> keysData) {
-        if (serializeKeys) {
-            for (Data key: keysData) {
-                invalidateNearCache(key);
-            }
-        } else {
-            for (K key: keys) {
-                invalidateNearCache(key);
-            }
         }
     }
     private void cacheOrInvalidate(Map<? extends K, ? extends V> map, Map<Object, Data> keyMap,
                                    List<Map.Entry<Data, Data>>[] entriesPerPartition, boolean isCacheOrInvalidate) {
         if (serializeKeys) {
             for (int partitionId = 0; partitionId < entriesPerPartition.length; partitionId++) {
                 List<Map.Entry<Data, Data>> entries = entriesPerPartition[partitionId];
                 if (entries != null) {
                     for (Map.Entry<Data, Data> entry : entries) {
                         Data key = entry.getKey();
@@ -453,21 +422,21 @@
     private void cacheOrInvalidate(Object key, Data keyData, V value, Data valueData) {
         if (cacheOnUpdate) {
             V valueToStore = (V) nearCache.selectToSave(valueData, value);
             nearCache.put(key, keyData, valueToStore);
         } else {
             invalidateNearCache(key);
         }
     }
     private void invalidateNearCache(Object key) {
         assert key != null;
-        nearCache.invalidate(key);
+        nearCache.remove(key);
     }
     private long tryReserveForUpdate(Object key, Data keyData) {
         return nearCache.tryReserveForUpdate(key, keyData);
     }
     /**
      * Publishes value got from remote or deletes reserved record when remote value is {@code null}.
      *
      * @param key           key to update in Near Cache
      * @param remoteValue   fetched value from server
      * @param reservationId reservation ID for this key
@@ -484,31 +453,31 @@
         if (reservationId != NOT_RESERVED) {
             cachedValue = nearCache.tryPublishReserved(key, remoteValue, reservationId, deserialize);
         }
         return cachedValue == null ? remoteValue : cachedValue;
     }
     private Object tryPublishReserved(Object key, Object remoteValue, long reservationId) {
         return tryPublishReserved(key, remoteValue, reservationId, true);
     }
     private void releaseRemainingReservedKeys(Map<Object, Long> reservedKeys) {
         for (Object key : reservedKeys.keySet()) {
-            nearCache.invalidate(key);
+            nearCache.remove(key);
         }
     }
     public String addNearCacheInvalidationListener(EventHandler eventHandler) {
         return registerListener(createInvalidationListenerCodec(), eventHandler);
     }
     private void registerInvalidationListener() {
         if (!invalidateOnChange) {
             return;
         }
-        EventHandler eventHandler = new NearCacheInvalidationEventHandler();
+        EventHandler eventHandler = new ConnectedServerVersionAwareNearCacheEventHandler();
         nearCacheMembershipRegistrationId = addNearCacheInvalidationListener(eventHandler);
     }
     private ListenerMessageCodec createInvalidationListenerCodec() {
         return new ListenerMessageCodec() {
             @Override
             public ClientMessage encodeAddRequest(boolean localOnly) {
                 if (supportsRepairableNearCache()) {
                     return CacheAddNearCacheInvalidationListenerCodec.encodeRequest(nameWithPrefix, localOnly);
                 }
                 return CacheAddInvalidationListenerCodec.encodeRequest(nameWithPrefix, localOnly);
@@ -683,89 +652,129 @@
             try {
                 if (callback != null) {
                     callback.onFailure(t);
                 }
             } finally {
                 invalidateNearCache(key);
             }
         }
     }
     /**
-     * Eventual consistency for Near Cache can be used with server versions >= 3.8
+     * Deals with client compatibility.
+     * <p>
+     * Eventual consistency for Near Cache can be used with server versions >= 3.8,
+     * other connected server versions must use {@link Pre38NearCacheEventHandler}.
+     */
+    private final class ConnectedServerVersionAwareNearCacheEventHandler implements EventHandler<ClientMessage> {
+        private final Pre38NearCacheEventHandler pre38EventHandler = new Pre38NearCacheEventHandler();
+        private final RepairableNearCacheEventHandler repairingEventHandler = new RepairableNearCacheEventHandler();
+        private volatile boolean supportsRepairableNearCache;
+        @Override
+        public void beforeListenerRegister() {
+            repairingEventHandler.beforeListenerRegister();
+            supportsRepairableNearCache = supportsRepairableNearCache();
+            if (!supportsRepairableNearCache) {
+                pre38EventHandler.beforeListenerRegister();
+                logger.warning(format("Near Cache for '%s' cache is started in legacy mode", name));
+            }
+        }
+        @Override
+        public void onListenerRegister() {
+            if (supportsRepairableNearCache) {
+                repairingEventHandler.onListenerRegister();
+            } else {
+                pre38EventHandler.onListenerRegister();
+            }
+        }
+        @Override
+        public void handle(ClientMessage clientMessage) {
+            if (supportsRepairableNearCache) {
+                repairingEventHandler.handle(clientMessage);
+            } else {
+                pre38EventHandler.handle(clientMessage);
+            }
+        }
+    }
+    /**
+     * This event handler can only be used with server versions >= 3.8 and supports Near Cache eventual consistency improvements.
      * For repairing functionality please see {@link RepairingHandler}
-     * handleCacheInvalidationEventV14 and handleCacheBatchInvalidationEventV14
-     *
-     * If server version is < 3.8 and client version is >= 3.8, eventual consistency is not supported
-     * Following methods handle the old behaviour:
-     * handleCacheBatchInvalidationEventV10 and handleCacheInvalidationEventV10
      */
-    private final class NearCacheInvalidationEventHandler
-            extends CacheAddInvalidationListenerCodec.AbstractEventHandler
+    private final class RepairableNearCacheEventHandler
+            extends CacheAddNearCacheInvalidationListenerCodec.AbstractEventHandler
             implements EventHandler<ClientMessage> {
-        private String clientUuid;
         private volatile RepairingHandler repairingHandler;
-        private volatile boolean supportsRepairableNearCache;
-        private NearCacheInvalidationEventHandler() {
-            this.clientUuid = getContext().getClusterService().getLocalClient().getUuid();
-        }
         @Override
         public void beforeListenerRegister() {
-            supportsRepairableNearCache = supportsRepairableNearCache();
-            if (supportsRepairableNearCache) {
+            if (supportsRepairableNearCache()) {
                 RepairingTask repairingTask = getContext().getRepairingTask(getServiceName());
                 repairingHandler = repairingTask.registerAndGetHandler(nameWithPrefix, nearCache);
             } else {
                 RepairingTask repairingTask = getContext().getRepairingTask(getServiceName());
                 repairingTask.deregisterHandler(nameWithPrefix);
-                logger.warning(format("Near Cache for '%s' cache is started in legacy mode", name));
             }
         }
         @Override
         public void onListenerRegister() {
-            if (!supportsRepairableNearCache) {
-                nearCache.clear();
-            }
-        }
-        @Override
-        public void handleCacheInvalidationEventV10(String name, Data key, String sourceUuid) {
+        }
+        @Override
+        public void handle(String name, Data key, String sourceUuid, UUID partitionUuid, long sequence) {
+            repairingHandler.handle(key, sourceUuid, partitionUuid, sequence);
+        }
+        @Override
+        public void handle(String name, Collection<Data> keys, Collection<String> sourceUuids,
+                           Collection<UUID> partitionUuids, Collection<Long> sequences) {
+            repairingHandler.handle(keys, sourceUuids, partitionUuids, sequences);
+        }
+    }
+    /**
+     * This event handler is here to be used with server versions < 3.8.
+     * <p>
+     * If server version is < 3.8 and client version is >= 3.8, this event handler must be used to
+     * listen Near Cache invalidations. Because new improvements for Near Cache eventual consistency
+     * cannot work with server versions < 3.8.
+     */
+    private final class Pre38NearCacheEventHandler
+            extends CacheAddInvalidationListenerCodec.AbstractEventHandler
+            implements EventHandler<ClientMessage> {
+        private String clientUuid;
+        private Pre38NearCacheEventHandler() {
+            this.clientUuid = getContext().getClusterService().getLocalClient().getUuid();
+        }
+        @Override
+        public void handle(String name, Data key, String sourceUuid, UUID partitionUuid, long sequence) {
             if (clientUuid.equals(sourceUuid)) {
                 return;
             }
             if (key != null) {
-                nearCache.invalidate(serializeKeys ? key : toObject(key));
+                nearCache.remove(serializeKeys ? key : toObject(key));
             } else {
                 nearCache.clear();
             }
         }
         @Override
-        public void handleCacheInvalidationEventV14(String name, Data key, String sourceUuid,
-                                                    UUID partitionUuid, long sequence) {
-            repairingHandler.handle(key, sourceUuid, partitionUuid, sequence);
-        }
-        @Override
-        public void handleCacheBatchInvalidationEventV10(String name, Collection<Data> keys,
-                                                         Collection<String> sourceUuids) {
+        public void handle(String name, Collection<Data> keys, Collection<String> sourceUuids,
+                           Collection<UUID> partitionUuids, Collection<Long> sequences) {
             if (sourceUuids != null && !sourceUuids.isEmpty()) {
                 Iterator<Data> keysIt = keys.iterator();
                 Iterator<String> sourceUuidsIt = sourceUuids.iterator();
                 while (keysIt.hasNext() && sourceUuidsIt.hasNext()) {
                     Data key = keysIt.next();
                     String sourceUuid = sourceUuidsIt.next();
                     if (!clientUuid.equals(sourceUuid)) {
-                        nearCache.invalidate(serializeKeys ? key : toObject(key));
+                        nearCache.remove(serializeKeys ? key : toObject(key));
                     }
                 }
             } else {
                 for (Data key : keys) {
-                    nearCache.invalidate(serializeKeys ? key : toObject(key));
-                }
-            }
-        }
-        @Override
-        public void handleCacheBatchInvalidationEventV14(String name, Collection<Data> keys,
-                                                         Collection<String> sourceUuids,
-                                                         Collection<UUID> partitionUuids,
-                                                         Collection<Long> sequences) {
-            repairingHandler.handle(keys, sourceUuids, partitionUuids, sequences);
+                    nearCache.remove(serializeKeys ? key : toObject(key));
+                }
+            }
+        }
+        @Override
+        public void beforeListenerRegister() {
+        }
+        @Override
+        public void onListenerRegister() {
+            nearCache.clear();
         }
     }
 }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/nearcache/invalidation/ClientCacheInvalidationMetaDataFetcher.java
+++ b//dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.hazelcast.client.cache.impl.nearcache.invalidation;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
-import com.hazelcast.client.impl.protocol.ClientMessage;
-import com.hazelcast.client.impl.protocol.codec.CacheFetchNearCacheInvalidationMetadataCodec.ResponseParameters;
-import com.hazelcast.client.spi.ClientClusterService;
-import com.hazelcast.client.spi.ClientContext;
-import com.hazelcast.client.spi.impl.ClientInvocation;
-import com.hazelcast.core.Member;
-import com.hazelcast.internal.nearcache.impl.invalidation.InvalidationMetaDataFetcher;
-import com.hazelcast.nio.Address;
-import com.hazelcast.spi.InternalCompletableFuture;
-import java.util.Collection;
-import java.util.List;
-import static com.hazelcast.client.impl.protocol.codec.CacheFetchNearCacheInvalidationMetadataCodec.decodeResponse;
-import static com.hazelcast.client.impl.protocol.codec.CacheFetchNearCacheInvalidationMetadataCodec.encodeRequest;
-import static com.hazelcast.cluster.memberselector.MemberSelectors.DATA_MEMBER_SELECTOR;
-import static java.util.concurrent.TimeUnit.MINUTES;
-/**
- * {@code InvalidationMetaDataFetcher} for client side usage
- */
-public class ClientCacheInvalidationMetaDataFetcher extends InvalidationMetaDataFetcher {
-    private final ClientClusterService clusterService;
-    private final HazelcastClientInstanceImpl clientImpl;
-    public ClientCacheInvalidationMetaDataFetcher(ClientContext clientContext) {
-        super(clientContext.getLoggingService().getLogger(ClientCacheInvalidationMetaDataFetcher.class));
-        this.clusterService = clientContext.getClusterService();
-        this.clientImpl = (HazelcastClientInstanceImpl) clientContext.getHazelcastInstance();
-    }
-    @Override
-    protected Collection<Member> getDataMembers() {
-        return clusterService.getMembers(DATA_MEMBER_SELECTOR);
-    }
-    @Override
-    protected InternalCompletableFuture fetchMetadataOf(Address address, List<String> names) {
-        ClientMessage message = encodeRequest(names, address);
-        ClientInvocation invocation = new ClientInvocation(clientImpl, message, null, address);
-        return invocation.invoke();
-    }
-    @Override
-    protected void extractMemberMetadata(Member member,
-                                         InternalCompletableFuture future,
-                                         MetadataHolder metadataHolder) throws Exception {
-        ClientMessage message = ((ClientMessage) future.get(ASYNC_RESULT_WAIT_TIMEOUT_MINUTES, MINUTES));
-        ResponseParameters response = decodeResponse(message);
-        metadataHolder.setMetadata(response.partitionUuidList, response.namePartitionSequenceList);
-    }
-}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/config/ClientAliasedDiscoveryConfigUtils.java
+++ b//dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.hazelcast.client.config;
-import com.hazelcast.config.AliasedDiscoveryConfig;
-import com.hazelcast.config.AliasedDiscoveryConfigUtils;
-import com.hazelcast.config.DiscoveryStrategyConfig;
-import com.hazelcast.config.InvalidConfigurationException;
-import java.util.List;
-import static java.util.Arrays.asList;
-/**
- * Utility class for Aliased Discovery Configs in Hazelcast Client.
- */
-public final class ClientAliasedDiscoveryConfigUtils {
-    private ClientAliasedDiscoveryConfigUtils() {
-    }
-    /**
-     * Extracts aliased discovery configs from {@code config} and creates a list of {@link DiscoveryStrategyConfig} out of them.
-     */
-    public static List<DiscoveryStrategyConfig> createDiscoveryStrategyConfigs(ClientConfig config) {
-        return AliasedDiscoveryConfigUtils.map(aliasedDiscoveryConfigsFrom(config));
-    }
-    /**
-     * Gets the {@link AliasedDiscoveryConfig} from {@code config} by {@code tag}.
-     */
-    public static AliasedDiscoveryConfig getConfigByTag(ClientNetworkConfig config, String tag) {
-        if ("aws".equals(tag)) {
-            return config.getAwsConfig();
-        } else if ("gcp".equals(tag)) {
-            return config.getGcpConfig();
-        } else if ("azure".equals(tag)) {
-            return config.getAzureConfig();
-        } else if ("kubernetes".equals(tag)) {
-            return config.getKubernetesConfig();
-        } else if ("eureka".equals(tag)) {
-            return config.getEurekaConfig();
-        } else {
-            throw new InvalidConfigurationException(String.format("Invalid configuration tag: '%s'", tag));
-        }
-    }
-    /**
-     * Gets a list of all aliased discovery configs from {@code config}.
-     */
-    public static List<AliasedDiscoveryConfig<?>> aliasedDiscoveryConfigsFrom(ClientConfig config) {
-        ClientNetworkConfig networkConfig = config.getNetworkConfig();
-        return asList(networkConfig.getAwsConfig(), networkConfig.getGcpConfig(), networkConfig.getAzureConfig(),
-                networkConfig.getKubernetesConfig(), networkConfig.getEurekaConfig());
-    }
-    /**
-     * Creates new {@link AliasedDiscoveryConfig} by the given {@code tag}.
-     */
-    public static AliasedDiscoveryConfig newAliasedDiscoveryConfig(String name) {
-        if ("aws".equals(name)) {
-            return new ClientAwsConfig();
-        } else {
-            return AliasedDiscoveryConfigUtils.newConfigFor(name);
-        }
-    }
-}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/config/ClientAwsConfig.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/config/ClientAwsConfig.java
@@ -9,59 +9,36 @@
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.config;
 import com.hazelcast.config.AwsConfig;
 /**
- * The AWSConfig contains the configuration for client to connect to nodes in aws environment.
- *
- * @deprecated Use {@link AwsConfig} instead.
+ * The AWSConfig contains the configuration for client
+ * to connect to nodes in aws environment.
  */
-@Deprecated
-public class ClientAwsConfig
-        extends AwsConfig {
-    private static final String INSIDE_AWS_PROPERTY = "inside-aws";
+public class ClientAwsConfig extends AwsConfig {
+    private boolean insideAws;
     /**
      * If client is inside aws, it will use private ip addresses directly,
      * otherwise it will convert private ip addresses to public addresses
      * internally by calling AWS API.
      *
      * @return boolean true if client is inside aws environment.
      */
-    @Deprecated
     public boolean isInsideAws() {
-        return !isUsePublicIp();
+        return insideAws;
     }
     /**
      * Set to true if client is inside aws environment
      * Default value is false.
      *
      * @param insideAws isInsideAws
      */
-    @Deprecated
     public ClientAwsConfig setInsideAws(boolean insideAws) {
-        setUsePublicIp(!insideAws);
-        return this;
-    }
-    /**
-     * Sets the property understood by the AWS SPI Discovery Strategy.
-     * <p>
-     * Note that it interprets the "inside-aws" property and maps it to the contrary of the generic "use-public-ip" property.
-     *
-     * @param name  property name
-     * @param value property value
-     * @return the updated Client Aws Config
-     */
-    @Override
-    public ClientAwsConfig setProperty(String name, String value) {
-        if (INSIDE_AWS_PROPERTY.equals(name)) {
-            setInsideAws(Boolean.parseBoolean(value));
-        } else {
-            super.setProperty(name, value);
-        }
+        this.insideAws = insideAws;
         return this;
     }
 }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/config/ClientCloudConfig.java
+++ b//dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.hazelcast.client.config;
-/**
- * hazelcast.cloud configuration to let the client connect the cluster via hazelcast.cloud
- */
-public class ClientCloudConfig {
-    private String discoveryToken;
-    private boolean enabled;
-    /**
-     * hazelcast.cloud discoveryToken of your cluster
-     *
-     * @return discoveryToken
-     */
-    public String getDiscoveryToken() {
-        return discoveryToken;
-    }
-    /**
-     * @param discoveryToken hazelcast.cloud discoveryToken of your cluster
-     * @return configured {@link com.hazelcast.client.config.ClientCloudConfig} for chaining
-     */
-    public ClientCloudConfig setDiscoveryToken(String discoveryToken) {
-        this.discoveryToken = discoveryToken;
-        return this;
-    }
-    /**
-     * @return true if enabled, false otherwise
-     */
-    public boolean isEnabled() {
-        return enabled;
-    }
-    /**
-     * @param enabled true to use hazelcast.cloud
-     * @return configured {@link com.hazelcast.client.config.ClientCloudConfig} for chaining
-     */
-    public ClientCloudConfig setEnabled(boolean enabled) {
-        this.enabled = enabled;
-        return this;
-    }
-}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/config/ClientConfig.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/config/ClientConfig.java
@@ -30,21 +30,20 @@
 import com.hazelcast.logging.ILogger;
 import com.hazelcast.logging.Logger;
 import com.hazelcast.security.Credentials;
 import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Properties;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
 import static com.hazelcast.config.NearCacheConfigAccessor.initDefaultMaxSizeForOnHeapMaps;
 import static com.hazelcast.internal.config.ConfigUtils.lookupByPattern;
 import static com.hazelcast.partition.strategy.StringPartitioningStrategy.getBaseName;
 import static com.hazelcast.util.Preconditions.checkFalse;
 /**
  * Main configuration to setup a Hazelcast Client
  */
 public class ClientConfig {
     private static final ILogger LOGGER = Logger.getLogger(ClientConfig.class);
     /**
@@ -88,21 +87,20 @@
     private SerializationConfig serializationConfig = new SerializationConfig();
     private NativeMemoryConfig nativeMemoryConfig = new NativeMemoryConfig();
     private final List<ProxyFactoryConfig> proxyFactoryConfigs = new LinkedList<ProxyFactoryConfig>();
     private ManagedContext managedContext;
     private ClassLoader classLoader;
     private String licenseKey;
     private ClientConnectionStrategyConfig connectionStrategyConfig = new ClientConnectionStrategyConfig();
     private ClientUserCodeDeploymentConfig userCodeDeploymentConfig = new ClientUserCodeDeploymentConfig();
     private final Map<String, ClientFlakeIdGeneratorConfig> flakeIdGeneratorConfigMap =
             new ConcurrentHashMap<String, ClientFlakeIdGeneratorConfig>();
-    private ConcurrentMap<String, Object> userContext = new ConcurrentHashMap<String, Object>();
     /**
      * Sets the pattern matcher which is used to match item names to
      * configuration objects.
      * By default the {@link MatchingPointConfigPatternMatcher} is used.
      *
      * @param configPatternMatcher the pattern matcher
      * @throws IllegalArgumentException if the pattern matcher is {@code null}
      */
     public void setConfigPatternMatcher(ConfigPatternMatcher configPatternMatcher) {
         if (configPatternMatcher == null) {
@@ -407,46 +405,20 @@
      */
     public ClientConfig setFlakeIdGeneratorConfigMap(Map<String, ClientFlakeIdGeneratorConfig> map) {
         flakeIdGeneratorConfigMap.clear();
         flakeIdGeneratorConfigMap.putAll(map);
         for (Entry<String, ClientFlakeIdGeneratorConfig> entry : map.entrySet()) {
             entry.getValue().setName(entry.getKey());
         }
         return this;
     }
     /**
-     * Sets the map of {@link ClientReliableTopicConfig},
-     * mapped by config name. The config name may be a pattern with which the
-     * configuration will be obtained in the future.
-     *
-     * @param map the FlakeIdGenerator configuration map to set
-     * @return this config instance
-     */
-    public ClientConfig setReliableTopicConfigMap(Map<String, ClientReliableTopicConfig> map) {
-        reliableTopicConfigMap.clear();
-        reliableTopicConfigMap.putAll(map);
-        for (Entry<String, ClientReliableTopicConfig> entry : map.entrySet()) {
-            entry.getValue().setName(entry.getKey());
-        }
-        return this;
-    }
-    /**
-     * Returns the map of reliable topic configurations,
-     * mapped by config name. The config name may be a pattern with which the
-     * configuration was initially obtained.
-     *
-     * @return the map configurations mapped by config name
-     */
-    public Map<String, ClientReliableTopicConfig> getReliableTopicConfigMap() {
-        return reliableTopicConfigMap;
-    }
-    /**
      * Use {@link ClientNetworkConfig#isSmartRouting} instead
      */
     @Deprecated
     public boolean isSmartRouting() {
         return networkConfig.isSmartRouting();
     }
     /**
      * Use {@link ClientNetworkConfig#setSmartRouting} instead
      */
     @Deprecated
@@ -747,20 +719,21 @@
     public ClientConfig setNativeMemoryConfig(NativeMemoryConfig nativeMemoryConfig) {
         this.nativeMemoryConfig = nativeMemoryConfig;
         return this;
     }
     public String getLicenseKey() {
         return licenseKey;
     }
     /**
      * @deprecated As of Hazelcast 3.10.3, enterprise license keys are required only for members, and not for clients
      */
+    @Deprecated
     public ClientConfig setLicenseKey(final String licenseKey) {
         this.licenseKey = licenseKey;
         return this;
     }
     public ClientConfig addQueryCacheConfig(String mapName, QueryCacheConfig queryCacheConfig) {
         Map<String, Map<String, QueryCacheConfig>> queryCacheConfigsPerMap = getQueryCacheConfigs();
         String queryCacheName = queryCacheConfig.getName();
         Map<String, QueryCacheConfig> queryCacheConfigs = queryCacheConfigsPerMap.get(mapName);
         if (queryCacheConfigs != null) {
             checkFalse(queryCacheConfigs.containsKey(queryCacheName),
@@ -842,21 +815,11 @@
     public QueryCacheConfig getOrNullQueryCacheConfig(String mapName, String cacheName) {
         if (queryCacheConfigs == null) {
             return null;
         }
         Map<String, QueryCacheConfig> queryCacheConfigsForMap = lookupByPattern(configPatternMatcher, queryCacheConfigs, mapName);
         if (queryCacheConfigsForMap == null) {
             return null;
         }
         return lookupByPattern(configPatternMatcher, queryCacheConfigsForMap, cacheName);
     }
-    public ClientConfig setUserContext(ConcurrentMap<String, Object> userContext) {
-        if (userContext == null) {
-            throw new IllegalArgumentException("userContext can't be null");
-        }
-        this.userContext = userContext;
-        return this;
-    }
-    public ConcurrentMap<String, Object> getUserContext() {
-        return userContext;
-    }
 }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/config/ClientConnectionStrategyConfig.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/config/ClientConnectionStrategyConfig.java
@@ -32,73 +32,49 @@
          */
         ON,
         /**
          * Reconnect to cluster without blocking invocations. Invocations will receive
          * {@link com.hazelcast.client.HazelcastClientOfflineException }
          */
         ASYNC
     }
     private boolean asyncStart;
     private ReconnectMode reconnectMode = ReconnectMode.ON;
-    private ConnectionRetryConfig connectionRetryConfig = new ConnectionRetryConfig();
     /**
      * Client instance creation won't block on {@link HazelcastClient#newHazelcastClient()} if this value is true
-     *
      * @return if client connects to cluster asynchronously
      */
     public boolean isAsyncStart() {
         return asyncStart;
     }
     /**
      * Set true for non blocking {@link HazelcastClient#newHazelcastClient()}. The client creation won't wait to
      * connect to cluster. The client instace will throw exception until it connects to cluster and become ready.
      * If set to false, {@link HazelcastClient#newHazelcastClient()} will block until a cluster connection established and it's
      * ready to use client instance
      *
      * default value is false
-     *
      * @param asyncStart true for async client creation
      * @return the updated ClientConnectionStrategyConfig
      */
     public ClientConnectionStrategyConfig setAsyncStart(boolean asyncStart) {
         this.asyncStart = asyncStart;
         return this;
     }
     /**
      * @return reconnect mode
      */
     public ReconnectMode getReconnectMode() {
         return reconnectMode;
     }
     /**
      * How a client reconnect to cluster after a disconnect can be configured. This parameter is used by default strategy and
      * custom implementations may ignore it if configured.
      * default value is {@link ReconnectMode#ON}
-     *
      * @param reconnectMode
-     * @return the updated ClientConnectionStrategyConfig
+     * @return
      */
     public ClientConnectionStrategyConfig setReconnectMode(ReconnectMode reconnectMode) {
         this.reconnectMode = reconnectMode;
         return this;
     }
-    /**
-     * Connection Retry Config is controls the period among the retries and when should a client gave up
-     * retrying. Exponential behaviour can be chosen or jitter can be added to wait periods.
-     *
-     * @return connection retry config
-     */
-    public ConnectionRetryConfig getConnectionRetryConfig() {
-        return connectionRetryConfig;
-    }
-    /**
-     * Connection Retry Config is controls the period among the retries and when should a client gave up
-     * retrying. Exponential behaviour can be chosen or jitter can be added to wait periods.
-     *
-     * @param connectionRetryConfig
-     * @return the updated ClientConnectionStrategyConfig
-     */
-    public ClientConnectionStrategyConfig setConnectionRetryConfig(ConnectionRetryConfig connectionRetryConfig) {
-        this.connectionRetryConfig = connectionRetryConfig;
-        return this;
-    }
 }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/config/ClientNetworkConfig.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/config/ClientNetworkConfig.java
@@ -7,25 +7,21 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.config;
-import com.hazelcast.config.AzureConfig;
 import com.hazelcast.config.DiscoveryConfig;
-import com.hazelcast.config.EurekaConfig;
-import com.hazelcast.config.GcpConfig;
-import com.hazelcast.config.KubernetesConfig;
 import com.hazelcast.config.SSLConfig;
 import com.hazelcast.config.SocketInterceptorConfig;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import static com.hazelcast.util.Preconditions.checkHasText;
 import static com.hazelcast.util.Preconditions.isNotNull;
 /**
@@ -36,26 +32,21 @@
     private static final int CONNECTION_ATTEMPT_PERIOD = 3000;
     private final List<String> addressList = new ArrayList<String>(10);
     private boolean smartRouting = true;
     private boolean redoOperation;
     private int connectionTimeout = CONNECTION_TIMEOUT;
     private int connectionAttemptLimit = -1;
     private int connectionAttemptPeriod = CONNECTION_ATTEMPT_PERIOD;
     private SocketInterceptorConfig socketInterceptorConfig;
     private SocketOptions socketOptions = new SocketOptions();
     private SSLConfig sslConfig;
-    private ClientAwsConfig awsConfig = new ClientAwsConfig();
-    private GcpConfig gcpConfig = new GcpConfig();
-    private AzureConfig azureConfig = new AzureConfig();
-    private KubernetesConfig kubernetesConfig = new KubernetesConfig();
-    private EurekaConfig eurekaConfig = new EurekaConfig();
-    private ClientCloudConfig cloudConfig = new ClientCloudConfig();
+    private ClientAwsConfig clientAwsConfig;
     private DiscoveryConfig discoveryConfig;
     private Collection<String> outboundPortDefinitions;
     private Collection<Integer> outboundPorts;
     private ClientIcmpPingConfig clientIcmpPingConfig = new ClientIcmpPingConfig();
     /**
      * Returns the configuration of the Hazelcast Discovery SPI and configured discovery providers
      *
      * @return Discovery Provider SPI configuration
      */
     public DiscoveryConfig getDiscoveryConfig() {
@@ -270,119 +261,38 @@
      *
      * @param sslConfig the SSLConfig.
      * @return the updated ClientNetworkConfig.
      * @see #getSSLConfig()
      */
     public ClientNetworkConfig setSSLConfig(SSLConfig sslConfig) {
         this.sslConfig = sslConfig;
         return this;
     }
     /**
-     * Sets configuration to connect nodes in AWS environment.
+     * Sets configuration to connect nodes in aws environment.
+     * null value indicates that no AwsConfig should be used.
      *
      * @param clientAwsConfig the ClientAwsConfig
      * @see #getAwsConfig()
      */
     public ClientNetworkConfig setAwsConfig(ClientAwsConfig clientAwsConfig) {
-        this.awsConfig = clientAwsConfig;
-        return this;
-    }
-    /**
-     * Returns the current {@link ClientAwsConfig}.
+        this.clientAwsConfig = clientAwsConfig;
+        return this;
+    }
+    /**
+     * Returns the current {@link ClientAwsConfig}. It is possible that null is returned if no SSLConfig has been
      *
      * @return ClientAwsConfig
      * @see #setAwsConfig(ClientAwsConfig)
      */
     public ClientAwsConfig getAwsConfig() {
-        return awsConfig;
-    }
-    /**
-     * Sets configuration to connect nodes in GCP environment.
-     *
-     * @param gcpConfig the GcpConfig
-     * @see #getGcpConfig()
-     */
-    public ClientNetworkConfig setGcpConfig(GcpConfig gcpConfig) {
-        this.gcpConfig = gcpConfig;
-        return this;
-    }
-    /**
-     * Returns the current {@link GcpConfig}.
-     *
-     * @return GcpConfig
-     * @see #setGcpConfig(GcpConfig)
-     */
-    public GcpConfig getGcpConfig() {
-        return gcpConfig;
-    }
-    /**
-     * Sets configuration to connect nodes in Azure environment.
-     *
-     * @param azureConfig the AzureConfig
-     * @see #getAzureConfig()
-     */
-    public ClientNetworkConfig setAzureConfig(AzureConfig azureConfig) {
-        this.azureConfig = azureConfig;
-        return this;
-    }
-    /**
-     * Returns the current {@link AzureConfig}.
-     *
-     * @return AzureConfig
-     * @see #setAzureConfig(AzureConfig)
-     */
-    public AzureConfig getAzureConfig() {
-        return azureConfig;
-    }
-    /**
-     * Sets configuration to connect nodes in Kubernetes environment.
-     *
-     * @param kubernetesConfig the KubernetesConfig
-     * @see #getKubernetesConfig()
-     */
-    public ClientNetworkConfig setKubernetesConfig(KubernetesConfig kubernetesConfig) {
-        this.kubernetesConfig = kubernetesConfig;
-        return this;
-    }
-    /**
-     * Returns the current {@link KubernetesConfig}.
-     *
-     * @return KubernetesConfig
-     * @see #setKubernetesConfig(KubernetesConfig)
-     */
-    public KubernetesConfig getKubernetesConfig() {
-        return kubernetesConfig;
-    }
-    /**
-     * Sets configuration to connect nodes in Eureka environment.
-     *
-     * @param eurekaConfig the EurekaConfig
-     * @see #getEurekaConfig()
-     */
-    public ClientNetworkConfig setEurekaConfig(EurekaConfig eurekaConfig) {
-        this.eurekaConfig = eurekaConfig;
-        return this;
-    }
-    /**
-     * Returns the current {@link EurekaConfig}.
-     *
-     * @return EurekaConfig
-     * @see #setEurekaConfig(EurekaConfig)
-     */
-    public EurekaConfig getEurekaConfig() {
-        return eurekaConfig;
-    }
-    public ClientCloudConfig getCloudConfig() {
-        return cloudConfig;
-    }
-    public void setCloudConfig(ClientCloudConfig cloudConfig) {
-        this.cloudConfig = cloudConfig;
+        return clientAwsConfig;
     }
     /**
      * Returns the outbound port definitions. It is possible that null is returned if not defined.
      *
      * @return list of outbound port definitions
      */
     public Collection<String> getOutboundPortDefinitions() {
         return outboundPortDefinitions;
     }
     /**

--- a/hazelcast-client/src/main/java/com/hazelcast/client/config/ClientReliableTopicConfig.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/config/ClientReliableTopicConfig.java
@@ -30,42 +30,33 @@
      */
     public static final int DEFAULT_READ_BATCH_SIZE = 10;
     /**
      * The default slow consumer policy.
      */
     public static final TopicOverloadPolicy DEFAULT_TOPIC_OVERLOAD_POLICY = BLOCK;
     private Executor executor;
     private int readBatchSize = DEFAULT_READ_BATCH_SIZE;
     private String name;
     private TopicOverloadPolicy topicOverloadPolicy = DEFAULT_TOPIC_OVERLOAD_POLICY;
-    public ClientReliableTopicConfig() {
-    }
     /**
      * Creates a new ReliableTopicConfig with default settings.
      */
     public ClientReliableTopicConfig(String name) {
         this.name = checkNotNull(name, "name");
     }
     /**
      * Gets the name of the reliable topic.
      *
      * @return the name of the reliable topic.
      */
     public String getName() {
         return name;
-    }
-    /**
-     * Sets the name or name pattern for this config. Must not be modified after this
-     * instance is added to {@link ClientConfig}.
-     */
-    public void setName(String name) {
-        this.name = name;
     }
     /**
      * Gets the TopicOverloadPolicy for this reliable topic.
      *
      * @return the TopicOverloadPolicy.
      */
     public TopicOverloadPolicy getTopicOverloadPolicy() {
         return topicOverloadPolicy;
     }
     /**

--- a/hazelcast-client/src/main/java/com/hazelcast/client/config/ClientSecurityConfig.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/config/ClientSecurityConfig.java
@@ -7,71 +7,32 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.config;
-import com.hazelcast.config.CredentialsFactoryConfig;
 import com.hazelcast.security.Credentials;
 /**
- * Contains the security configuration for the client.
- * Credentials object is used for both authentication and authorization
- * Credentials is used with ClusterLoginModule for authentication
- * It is also used with SecurityInterceptor and to define principal in client-permissions for authorization.
- *
- * @see Credentials#getPrincipal()
- * @see com.hazelcast.security.SecurityInterceptor
+ * Contains the security configuration for a client.
  */
 public class ClientSecurityConfig {
     private Credentials credentials;
     private String credentialsClassname;
-    private CredentialsFactoryConfig credentialsFactoryConfig = new CredentialsFactoryConfig();
     public Credentials getCredentials() {
         return credentials;
     }
-    /**
-     * @param credentials that will be used when
-     * @return configured {@link com.hazelcast.client.config.ClientSecurityConfig} for chaining
-     */
     public ClientSecurityConfig setCredentials(Credentials credentials) {
         this.credentials = credentials;
         return this;
     }
-    /**
-     * @return configured class name for credentials
-     */
     public String getCredentialsClassname() {
         return credentialsClassname;
     }
-    /**
-     * Credentials class will be instantiated from class name when setCredentialsFactoryConfig and  setCredentials
-     * are not used. The class will be instantiated with empty constructor.
-     *
-     * @param credentialsClassname class name for credentials
-     * @return configured {@link com.hazelcast.client.config.ClientSecurityConfig} for chaining
-     */
     public ClientSecurityConfig setCredentialsClassname(String credentialsClassname) {
         this.credentialsClassname = credentialsClassname;
         return this;
     }
-    /**
-     * @return credentials factory config
-     */
-    public CredentialsFactoryConfig getCredentialsFactoryConfig() {
-        return credentialsFactoryConfig;
-    }
-    /**
-     * Credentials Factory Config allows user to pass custom properties and use group config when instantiating
-     * a credentials object.
-     *
-     * @param credentialsFactoryConfig the config that will be used to create credentials factory
-     * @return configured {@link com.hazelcast.client.config.ClientSecurityConfig} for chaining
-     */
-    public ClientSecurityConfig setCredentialsFactoryConfig(CredentialsFactoryConfig credentialsFactoryConfig) {
-        this.credentialsFactoryConfig = credentialsFactoryConfig;
-        return this;
-    }
 }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/config/ClientXmlElements.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/config/ClientXmlElements.java
@@ -26,22 +26,21 @@
     LISTENERS("listeners", false),
     NETWORK("network", false),
     LOAD_BALANCER("load-balancer", false),
     NEAR_CACHE("near-cache", true),
     QUERY_CACHES("query-caches", false),
     EXECUTOR_POOL_SIZE("executor-pool-size", false),
     LICENSE_KEY("license-key", false),
     INSTANCE_NAME("instance-name", false),
     CONNECTION_STRATEGY("connection-strategy", false),
     USER_CODE_DEPLOYMENT("user-code-deployment", false),
-    FLAKE_ID_GENERATOR("flake-id-generator", true),
-    RELIABLE_TOPIC("reliable-topic", true);
+    FLAKE_ID_GENERATOR("flake-id-generator", true);
     final String name;
     final boolean multipleOccurrence;
     ClientXmlElements(String name, boolean multipleOccurrence) {
         this.name = name;
         this.multipleOccurrence = multipleOccurrence;
     }
     public static boolean canOccurMultipleTimes(String name) {
         for (ClientXmlElements element : values()) {
             if (name.equals(element.name)) {
                 return element.multipleOccurrence;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/config/ConnectionRetryConfig.java
+++ b//dev/null
@@ -1,146 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.hazelcast.client.config;
-/**
- * Connection Retry Config is controls the period among the retries and when should a client gave up
- * retrying. Exponential behaviour can be chosen or jitter can be added to wait periods.
- */
-public class ConnectionRetryConfig {
-    private static final int INITIAL_BACKOFF_MILLIS = 1000;
-    private static final int MAX_BACKOFF_MILLIS = 30000;
-    private static final double JITTER = 0.2;
-    private int initialBackoffMillis = INITIAL_BACKOFF_MILLIS;
-    private int maxBackoffMillis = MAX_BACKOFF_MILLIS;
-    private double multiplier = 2;
-    private boolean failOnMaxBackoff;
-    private double jitter = JITTER;
-    private boolean enabled;
-    /**
-     * how long to wait after the first failure before retrying
-     *
-     * @return initialBackoffMillis
-     */
-    public int getInitialBackoffMillis() {
-        return initialBackoffMillis;
-    }
-    /**
-     * @param initialBackoffMillis how long to wait after the first failure before retrying
-     * @return updated ConnectionRetryConfig
-     */
-    public ConnectionRetryConfig setInitialBackoffMillis(int initialBackoffMillis) {
-        this.initialBackoffMillis = initialBackoffMillis;
-        return this;
-    }
-    /**
-     * When backoff reaches this upper bound, it does not increase any more. Behaviour after that changes
-     * depending on `failOnMaxBackoff` option
-     *
-     * @return maxBackoffMillis
-     */
-    public int getMaxBackoffMillis() {
-        return maxBackoffMillis;
-    }
-    /**
-     * When backoff reaches this upper bound, it does not increase any more. Behaviour after that changes
-     * depending on `failOnMaxBackoff` option
-     *
-     * @param maxBackoffMillis upper bound on backoff
-     * @return updated ConnectionRetryConfig
-     */
-    public ConnectionRetryConfig setMaxBackoffMillis(int maxBackoffMillis) {
-        this.maxBackoffMillis = maxBackoffMillis;
-        return this;
-    }
-    /**
-     * factor with which to multiply backoff after a failed retry
-     *
-     * @return multiplier
-     */
-    public double getMultiplier() {
-        return multiplier;
-    }
-    /**
-     * @param multiplier factor with which to multiply backoff after a failed retry
-     * @return updated ConnectionRetryConfig
-     */
-    public ConnectionRetryConfig setMultiplier(double multiplier) {
-        this.multiplier = multiplier;
-        return this;
-    }
-    /**
-     * whether to fail when the max-backoff has reached or continue waiting max-backoff-millis at each iteration
-     * When on fail, client shuts down.
-     *
-     * @return failOnMaxBackoff
-     */
-    public boolean isFailOnMaxBackoff() {
-        return failOnMaxBackoff;
-    }
-    /**
-     * @param failOnMaxBackoff whether to fail when the max-backoff has reached or
-     *                         continue waiting max-backoff-millis at each iteration
-     * @return updated ConnectionRetryConfig
-     */
-    public ConnectionRetryConfig setFailOnMaxBackoff(boolean failOnMaxBackoff) {
-        this.failOnMaxBackoff = failOnMaxBackoff;
-        return this;
-    }
-    /**
-     * by how much to randomize backoffs.
-     * At each iteration calculated back-off is randomized via following method
-     * Random(-jitter * current_backoff, jitter * current_backoff)
-     *
-     * @return jitter
-     */
-    public double getJitter() {
-        return jitter;
-    }
-    /**
-     * At each iteration calculated back-off is randomized via following method
-     * Random(-jitter * current_backoff, jitter * current_backoff)
-     *
-     * @param jitter by how much to randomize backoffs
-     * @return updated ConnectionRetryConfig
-     */
-    public ConnectionRetryConfig setJitter(double jitter) {
-        this.jitter = jitter;
-        return this;
-    }
-    /**
-     * enables connection retry logic.
-     * When disabled, old configurations are used:
-     * {@link ClientNetworkConfig#getConnectionAttemptLimit()}
-     * {@link ClientNetworkConfig#getConnectionAttemptPeriod()} ()}
-     *
-     * @return true if enabled
-     */
-    public boolean isEnabled() {
-        return enabled;
-    }
-    /**
-     * enables connection retry logic.
-     * When disabled, old configurations are used:
-     * {@link ClientNetworkConfig#getConnectionAttemptLimit()}
-     * {@link ClientNetworkConfig#getConnectionAttemptPeriod()} ()}
-     *
-     * @param enabled
-     * @return updated ConnectionRetryConfig
-     */
-    public ConnectionRetryConfig setEnabled(boolean enabled) {
-        this.enabled = enabled;
-        return this;
-    }
-}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/config/XmlClientConfigBuilder.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/config/XmlClientConfigBuilder.java
@@ -11,41 +11,37 @@
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.config;
 import com.hazelcast.client.config.ClientConnectionStrategyConfig.ReconnectMode;
 import com.hazelcast.client.util.RandomLB;
 import com.hazelcast.client.util.RoundRobinLB;
 import com.hazelcast.config.AbstractConfigBuilder;
-import com.hazelcast.config.AliasedDiscoveryConfig;
 import com.hazelcast.config.ConfigLoader;
-import com.hazelcast.config.CredentialsFactoryConfig;
-import com.hazelcast.config.AliasedDiscoveryConfigUtils;
 import com.hazelcast.config.DiscoveryConfig;
 import com.hazelcast.config.DiscoveryStrategyConfig;
 import com.hazelcast.config.EvictionConfig;
 import com.hazelcast.config.EvictionConfig.MaxSizePolicy;
 import com.hazelcast.config.EvictionPolicy;
 import com.hazelcast.config.InMemoryFormat;
 import com.hazelcast.config.InvalidConfigurationException;
 import com.hazelcast.config.ListenerConfig;
 import com.hazelcast.config.NearCacheConfig;
 import com.hazelcast.config.NearCachePreloaderConfig;
 import com.hazelcast.config.SSLConfig;
 import com.hazelcast.config.SerializationConfig;
 import com.hazelcast.config.SocketInterceptorConfig;
 import com.hazelcast.logging.ILogger;
 import com.hazelcast.logging.Logger;
 import com.hazelcast.nio.IOUtil;
-import com.hazelcast.topic.TopicOverloadPolicy;
 import com.hazelcast.util.ExceptionUtil;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.w3c.dom.NamedNodeMap;
 import org.w3c.dom.Node;
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
@@ -63,21 +59,20 @@
 import static com.hazelcast.client.config.ClientXmlElements.INSTANCE_NAME;
 import static com.hazelcast.client.config.ClientXmlElements.LICENSE_KEY;
 import static com.hazelcast.client.config.ClientXmlElements.LISTENERS;
 import static com.hazelcast.client.config.ClientXmlElements.LOAD_BALANCER;
 import static com.hazelcast.client.config.ClientXmlElements.NATIVE_MEMORY;
 import static com.hazelcast.client.config.ClientXmlElements.NEAR_CACHE;
 import static com.hazelcast.client.config.ClientXmlElements.NETWORK;
 import static com.hazelcast.client.config.ClientXmlElements.PROPERTIES;
 import static com.hazelcast.client.config.ClientXmlElements.PROXY_FACTORIES;
 import static com.hazelcast.client.config.ClientXmlElements.QUERY_CACHES;
-import static com.hazelcast.client.config.ClientXmlElements.RELIABLE_TOPIC;
 import static com.hazelcast.client.config.ClientXmlElements.SECURITY;
 import static com.hazelcast.client.config.ClientXmlElements.SERIALIZATION;
 import static com.hazelcast.client.config.ClientXmlElements.USER_CODE_DEPLOYMENT;
 import static com.hazelcast.client.config.ClientXmlElements.canOccurMultipleTimes;
 import static com.hazelcast.util.StringUtil.LINE_SEPARATOR;
 import static com.hazelcast.util.StringUtil.upperCaseInternal;
 /**
  * Loads the {@link com.hazelcast.client.config.ClientConfig} using XML.
  */
 @SuppressWarnings("checkstyle:methodcount")
@@ -232,68 +227,31 @@
         } else if (LICENSE_KEY.isEqual(nodeName)) {
             clientConfig.setLicenseKey(getTextContent(node));
         } else if (INSTANCE_NAME.isEqual(nodeName)) {
             clientConfig.setInstanceName(getTextContent(node));
         } else if (CONNECTION_STRATEGY.isEqual(nodeName)) {
             handleConnectionStrategy(node);
         } else if (USER_CODE_DEPLOYMENT.isEqual(nodeName)) {
             handleUserCodeDeployment(node);
         } else if (FLAKE_ID_GENERATOR.isEqual(nodeName)) {
             handleFlakeIdGenerator(node);
-        } else if (RELIABLE_TOPIC.isEqual(nodeName)) {
-            handleReliableTopic(node);
         }
     }
     private void handleConnectionStrategy(Node node) {
         ClientConnectionStrategyConfig strategyConfig = new ClientConnectionStrategyConfig();
         String attrValue = getAttribute(node, "async-start");
         strategyConfig.setAsyncStart(attrValue != null && getBooleanValue(attrValue.trim()));
         attrValue = getAttribute(node, "reconnect-mode");
         if (attrValue != null) {
             strategyConfig.setReconnectMode(ReconnectMode.valueOf(upperCaseInternal(attrValue.trim())));
         }
-        for (Node child : childElements(node)) {
-            String nodeName = cleanNodeName(child);
-            if ("connection-retry".equals(nodeName)) {
-                handleConnectionRetry(child, strategyConfig);
-            }
-        }
         clientConfig.setConnectionStrategyConfig(strategyConfig);
-    }
-    private void handleConnectionRetry(Node node, ClientConnectionStrategyConfig strategyConfig) {
-        Node enabledNode = node.getAttributes().getNamedItem("enabled");
-        boolean enabled = enabledNode != null && getBooleanValue(getTextContent(enabledNode).trim());
-        if (!enabled) {
-            LOGGER.warning("Exponential Connection Strategy is not enabled.");
-        }
-        ConnectionRetryConfig connectionRetryConfig = new ConnectionRetryConfig();
-        connectionRetryConfig.setEnabled(enabled);
-        String initialBackoffMillis = "initial-backoff-millis";
-        String maxBackoffMillis = "max-backoff-millis";
-        String multiplier = "multiplier";
-        String jitter = "jitter";
-        for (Node child : childElements(node)) {
-            String nodeName = cleanNodeName(child);
-            String value = getTextContent(child).trim();
-            if (initialBackoffMillis.equals(nodeName)) {
-                connectionRetryConfig.setInitialBackoffMillis(getIntegerValue(initialBackoffMillis, value));
-            } else if (maxBackoffMillis.equals(nodeName)) {
-                connectionRetryConfig.setMaxBackoffMillis(getIntegerValue(maxBackoffMillis, value));
-            } else if (multiplier.equals(nodeName)) {
-                connectionRetryConfig.setMultiplier(getIntegerValue(multiplier, value));
-            } else if ("fail-on-max-backoff".equals(nodeName)) {
-                connectionRetryConfig.setFailOnMaxBackoff(getBooleanValue(value));
-            } else if (jitter.equals(nodeName)) {
-                connectionRetryConfig.setJitter(getDoubleValue(jitter, value));
-            }
-        }
-        strategyConfig.setConnectionRetryConfig(connectionRetryConfig);
     }
     private void handleUserCodeDeployment(Node node) {
         NamedNodeMap atts = node.getAttributes();
         Node enabledNode = atts.getNamedItem("enabled");
         boolean enabled = enabledNode != null && getBooleanValue(getTextContent(enabledNode).trim());
         ClientUserCodeDeploymentConfig userCodeDeploymentConfig = new ClientUserCodeDeploymentConfig();
         userCodeDeploymentConfig.setEnabled(enabled);
         for (Node child : childElements(node)) {
             String childNodeName = cleanNodeName(child);
             if ("classnames".equals(childNodeName)) {
@@ -362,34 +320,20 @@
             String nodeName = cleanNodeName(child);
             String value = getTextContent(child).trim();
             if ("prefetch-count".equals(nodeName)) {
                 config.setPrefetchCount(Integer.parseInt(value));
             } else if ("prefetch-validity-millis".equalsIgnoreCase(nodeName)) {
                 config.setPrefetchValidityMillis(Long.parseLong(value));
             }
         }
         clientConfig.addFlakeIdGeneratorConfig(config);
     }
-    private void handleReliableTopic(Node node) {
-        String name = getAttribute(node, "name");
-        ClientReliableTopicConfig config = new ClientReliableTopicConfig(name);
-        for (Node child : childElements(node)) {
-            String nodeName = cleanNodeName(child);
-            String value = getTextContent(child).trim();
-            if ("topic-overload-policy".equals(nodeName)) {
-                config.setTopicOverloadPolicy(TopicOverloadPolicy.valueOf(value));
-            } else if ("read-batch-size".equalsIgnoreCase(nodeName)) {
-                config.setReadBatchSize(Integer.parseInt(value));
-            }
-        }
-        clientConfig.addReliableTopicConfig(config);
-    }
     private EvictionConfig getEvictionConfig(Node node) {
         EvictionConfig evictionConfig = new EvictionConfig();
         Node size = node.getAttributes().getNamedItem("size");
         Node maxSizePolicy = node.getAttributes().getNamedItem("max-size-policy");
         Node evictionPolicy = node.getAttributes().getNamedItem("eviction-policy");
         if (size != null) {
             evictionConfig.setSize(Integer.parseInt(getTextContent(size)));
         }
         if (maxSizePolicy != null) {
             evictionConfig.setMaximumSizePolicy(MaxSizePolicy.valueOf(upperCaseInternal(getTextContent(maxSizePolicy)))
@@ -445,46 +389,31 @@
             } else if ("connection-attempt-period".equals(nodeName)) {
                 clientNetworkConfig.setConnectionAttemptPeriod(Integer.parseInt(getTextContent(child)));
             } else if ("connection-attempt-limit".equals(nodeName)) {
                 clientNetworkConfig.setConnectionAttemptLimit(Integer.parseInt(getTextContent(child)));
             } else if ("socket-options".equals(nodeName)) {
                 handleSocketOptions(child, clientNetworkConfig);
             } else if ("socket-interceptor".equals(nodeName)) {
                 handleSocketInterceptorConfig(child, clientNetworkConfig);
             } else if ("ssl".equals(nodeName)) {
                 handleSSLConfig(child, clientNetworkConfig);
-            } else if (AliasedDiscoveryConfigUtils.supports(nodeName)) {
-                handleAliasedDiscoveryStrategy(child, clientNetworkConfig, nodeName);
+            } else if ("aws".equals(nodeName)) {
+                handleAWS(child, clientNetworkConfig);
             } else if ("discovery-strategies".equals(nodeName)) {
                 handleDiscoveryStrategies(child, clientNetworkConfig);
             } else if ("outbound-ports".equals(nodeName)) {
                 handleOutboundPorts(child, clientNetworkConfig);
             } else if ("icmp-ping".equals(nodeName)) {
                 handleIcmpPing(child, clientNetworkConfig);
-            } else if ("hazelcast-cloud".equals(nodeName)) {
-                handleHazelcastCloud(child, clientNetworkConfig);
             }
         }
         clientConfig.setNetworkConfig(clientNetworkConfig);
-    }
-    private void handleHazelcastCloud(Node node, ClientNetworkConfig clientNetworkConfig) {
-        ClientCloudConfig cloudConfig = clientNetworkConfig.getCloudConfig();
-        NamedNodeMap atts = node.getAttributes();
-        Node enabledNode = atts.getNamedItem("enabled");
-        boolean enabled = enabledNode != null && getBooleanValue(getTextContent(enabledNode).trim());
-        cloudConfig.setEnabled(enabled);
-        for (Node child : childElements(node)) {
-            String nodeName = cleanNodeName(child);
-            if ("discovery-token".equals(nodeName)) {
-                cloudConfig.setDiscoveryToken(getTextContent(child));
-            }
-        }
     }
     private void handleIcmpPing(Node node, ClientNetworkConfig clientNetworkConfig) {
         ClientIcmpPingConfig icmpPingConfig = clientNetworkConfig.getClientIcmpPingConfig();
         NamedNodeMap atts = node.getAttributes();
         Node enabledNode = atts.getNamedItem("enabled");
         boolean enabled = enabledNode != null && getBooleanValue(getTextContent(enabledNode).trim());
         icmpPingConfig.setEnabled(enabled);
         for (Node child : childElements(node)) {
             String nodeName = cleanNodeName(child);
             if ("timeout-milliseconds".equals(nodeName)) {
@@ -537,37 +466,63 @@
         }
         Map<String, Comparable> properties = new HashMap<String, Comparable>();
         for (Node child : childElements(node)) {
             String name = cleanNodeName(child);
             if ("properties".equals(name)) {
                 fillProperties(child, properties);
             }
         }
         discoveryConfig.addDiscoveryStrategyConfig(new DiscoveryStrategyConfig(clazz, properties));
     }
-    private void handleAliasedDiscoveryStrategy(Node node, ClientNetworkConfig clientNetworkConfig, String tag) {
-        AliasedDiscoveryConfig config = ClientAliasedDiscoveryConfigUtils.getConfigByTag(clientNetworkConfig, tag);
+    private void handleAWS(Node node, ClientNetworkConfig clientNetworkConfig) {
+        ClientAwsConfig clientAwsConfig = handleAwsAttributes(node);
+        for (Node n : childElements(node)) {
+            String value = getTextContent(n).trim();
+            if ("secret-key".equals(cleanNodeName(n))) {
+                clientAwsConfig.setSecretKey(value);
+            } else if ("access-key".equals(cleanNodeName(n))) {
+                clientAwsConfig.setAccessKey(value);
+            } else if ("region".equals(cleanNodeName(n))) {
+                clientAwsConfig.setRegion(value);
+            } else if ("host-header".equals(cleanNodeName(n))) {
+                clientAwsConfig.setHostHeader(value);
+            } else if ("security-group-name".equals(cleanNodeName(n))) {
+                clientAwsConfig.setSecurityGroupName(value);
+            } else if ("tag-key".equals(cleanNodeName(n))) {
+                clientAwsConfig.setTagKey(value);
+            } else if ("tag-value".equals(cleanNodeName(n))) {
+                clientAwsConfig.setTagValue(value);
+            } else if ("inside-aws".equals(cleanNodeName(n))) {
+                clientAwsConfig.setInsideAws(getBooleanValue(value));
+            } else if ("iam-role".equals(cleanNodeName(n))) {
+                clientAwsConfig.setIamRole(value);
+            }
+        }
+        if (!clientAwsConfig.isInsideAws() && clientAwsConfig.getIamRole() != null) {
+            throw new InvalidConfigurationException("You cannot set IAM Role from outside EC2");
+        }
+        clientNetworkConfig.setAwsConfig(clientAwsConfig);
+    }
+    private ClientAwsConfig handleAwsAttributes(Node node) {
         NamedNodeMap atts = node.getAttributes();
+        ClientAwsConfig clientAwsConfig = new ClientAwsConfig();
         for (int i = 0; i < atts.getLength(); i++) {
             Node att = atts.item(i);
             String value = getTextContent(att).trim();
             if ("enabled".equalsIgnoreCase(att.getNodeName())) {
-                config.setEnabled(getBooleanValue(value));
+                clientAwsConfig.setEnabled(getBooleanValue(value));
             } else if (att.getNodeName().equals("connection-timeout-seconds")) {
-                config.setProperty("connection-timeout-seconds", value);
-            }
-        }
-        for (Node n : childElements(node)) {
-            String key = cleanNodeName(n);
-            String value = getTextContent(n).trim();
-            config.setProperty(key, value);
-        }
+                int timeout = getIntegerValue("connection-timeout-seconds", value);
+                clientAwsConfig.setConnectionTimeoutSeconds(timeout);
+            }
+        }
+        return clientAwsConfig;
     }
     private void handleSSLConfig(Node node, ClientNetworkConfig clientNetworkConfig) {
         SSLConfig sslConfig = new SSLConfig();
         NamedNodeMap atts = node.getAttributes();
         Node enabledNode = atts.getNamedItem("enabled");
         boolean enabled = enabledNode != null && getBooleanValue(getTextContent(enabledNode).trim());
         sslConfig.setEnabled(enabled);
         for (Node n : childElements(node)) {
             String nodeName = cleanNodeName(n);
             if ("factory-class-name".equals(nodeName)) {
@@ -644,39 +599,23 @@
         SocketInterceptorConfig socketInterceptorConfig = parseSocketInterceptorConfig(node);
         clientNetworkConfig.setSocketInterceptorConfig(socketInterceptorConfig);
     }
     private void handleSecurity(Node node) throws Exception {
         ClientSecurityConfig clientSecurityConfig = new ClientSecurityConfig();
         for (Node child : childElements(node)) {
             String nodeName = cleanNodeName(child);
             if ("credentials".equals(nodeName)) {
                 String className = getTextContent(child);
                 clientSecurityConfig.setCredentialsClassname(className);
-            } else if ("credentials-factory".equals(nodeName)) {
-                handleCredentialsFactory(child, clientSecurityConfig);
             }
         }
         clientConfig.setSecurityConfig(clientSecurityConfig);
-    }
-    private void handleCredentialsFactory(Node node, ClientSecurityConfig clientSecurityConfig) {
-        NamedNodeMap attrs = node.getAttributes();
-        Node classNameNode = attrs.getNamedItem("class-name");
-        String className = getTextContent(classNameNode);
-        CredentialsFactoryConfig credentialsFactoryConfig = new CredentialsFactoryConfig(className);
-        clientSecurityConfig.setCredentialsFactoryConfig(credentialsFactoryConfig);
-        for (Node child : childElements(node)) {
-            String nodeName = cleanNodeName(child);
-            if ("properties".equals(nodeName)) {
-                fillProperties(child, credentialsFactoryConfig.getProperties());
-                break;
-            }
-        }
     }
     private void handleOutboundPorts(Node child, ClientNetworkConfig clientNetworkConfig) {
         for (Node n : childElements(child)) {
             String nodeName = cleanNodeName(n);
             if ("ports".equals(nodeName)) {
                 String value = getTextContent(n);
                 clientNetworkConfig.addOutboundPortDefinition(value);
             }
         }
     }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/connection/ClientConnectionManager.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/connection/ClientConnectionManager.java
@@ -9,20 +9,21 @@
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.connection;
 import com.hazelcast.client.connection.nio.ClientConnection;
 import com.hazelcast.client.impl.client.ClientPrincipal;
+import com.hazelcast.client.spi.impl.ConnectionHeartbeatListener;
 import com.hazelcast.nio.Address;
 import com.hazelcast.nio.Connection;
 import com.hazelcast.nio.ConnectionListenable;
 import java.io.IOException;
 import java.util.Collection;
 import java.util.concurrent.Future;
 /**
  * Responsible for managing {@link com.hazelcast.client.connection.nio.ClientConnection} objects.
  */
 public interface ClientConnectionManager extends ConnectionListenable {
@@ -43,17 +44,18 @@
      * @return associated connection if available, creates new connection otherwise
      * @throws IOException if connection is not established
      */
     Connection getOrConnect(Address address) throws IOException;
     /**
      * @param address to be connected
      * @return associated connection if available, returns null and triggers new connection creation otherwise
      * @throws IOException if connection is not able to triggered
      */
     Connection getOrTriggerConnect(Address address, boolean acquiresResource) throws IOException;
+    void addConnectionHeartbeatListener(ConnectionHeartbeatListener connectionHeartbeatListener);
     Collection<ClientConnection> getActiveConnections();
     Address getOwnerConnectionAddress();
     ClientPrincipal getPrincipal();
     ClientConnection getOwnerConnection();
     void connectToCluster();
     Future<Void> connectToClusterAsync();
 }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/connection/ClientConnectionStrategy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/connection/ClientConnectionStrategy.java
@@ -62,39 +62,44 @@
      * this method will be called.
      *
      * This request can be rejected by throwing an instance of non retryable exceptions;
      * {@link java.io.IOException}, {@link com.hazelcast.core.HazelcastInstanceNotActiveException} or
      * {@link com.hazelcast.spi.exception.RetryableException}
      * @param target address of the requested connection
      */
     public abstract void beforeOpenConnection(Address target);
     /**
      * If a cluster connection is established, this method will be called.
-     * @param target address of the requested connection
-     */
-    public abstract void beforeConnectToCluster(Address target);
-    /**
-     * If a cluster connection is established, this method will be called.
      * if an exception is thrown, the already established connection will be closed.
      */
     public abstract void onConnectToCluster();
     /**
      * If the cluster connection is lost for any reason, this method will be called.
      *
      */
     public abstract void onDisconnectFromCluster();
     /**
      * If the {@link ClientConnectionManager} opens a new connection to a member,
      * this method will be called with the connection parameter
      * @param connection the new established connection
      */
     public abstract void onConnect(ClientConnection connection);
     /**
      * If a connection is disconnected, this method will be called with the connection parameter
      * @param connection the closed connection
      */
     public abstract void onDisconnect(ClientConnection connection);
     /**
+     * The {@link ClientConnectionManager} will inform this method that the provided connection's heartbeat stopped
+     * @param connection the connection that heartbeat failed
+     */
+    public abstract void onHeartbeatStopped(ClientConnection connection);
+    /**
+     * The {@link ClientConnectionManager} will inform this method that the provided connection's heartbeat resumed
+     * @param connection the connection that heartbeat resumed
+     */
+    public abstract void onHeartbeatResumed(ClientConnection connection);
+    /**
      * The {@link ClientConnectionManager} will call this method as a last step of its shutdown.
      */
     public abstract void shutdown();
 }

--- a//dev/null
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/ClientChannelInitializer.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.hazelcast.client.connection.nio;
+import com.hazelcast.client.impl.protocol.ClientMessage;
+import com.hazelcast.client.impl.protocol.util.ClientMessageDecoder;
+import com.hazelcast.client.impl.protocol.util.ClientMessageEncoder;
+import com.hazelcast.client.impl.protocol.util.ClientMessageHandler;
+import com.hazelcast.internal.networking.Channel;
+import com.hazelcast.internal.networking.ChannelInboundHandler;
+import com.hazelcast.internal.networking.ChannelInitializer;
+import com.hazelcast.internal.networking.ChannelOutboundHandler;
+import com.hazelcast.internal.networking.InitResult;
+import com.hazelcast.nio.Connection;
+import java.nio.ByteBuffer;
+import static com.hazelcast.nio.IOUtil.newByteBuffer;
+import static com.hazelcast.nio.Protocols.CLIENT_BINARY_NEW;
+import static com.hazelcast.util.StringUtil.stringToBytes;
+/**
+ * Client side ChannelInitializer. Client in this case is a real client using client protocol etc.
+ *
+ * It will automatically send the Client Protocol to the server and configure the correct buffers/handlers.
+ */
+class ClientChannelInitializer implements ChannelInitializer {
+    private final int bufferSize;
+    private final boolean direct;
+    ClientChannelInitializer(int bufferSize, boolean direct) {
+        this.bufferSize = bufferSize;
+        this.direct = direct;
+    }
+    @Override
+    public InitResult<ChannelInboundHandler> initInbound(final Channel channel) {
+        ByteBuffer inputBuffer = newByteBuffer(bufferSize, direct);
+        final ClientConnection clientConnection = (ClientConnection) channel.attributeMap().get(ClientConnection.class);
+        ChannelInboundHandler inboundHandler = new ClientMessageDecoder(clientConnection,
+                new ClientMessageHandler() {
+                    @Override
+                    public void handle(ClientMessage message, Connection connection) {
+                        clientConnection.handleClientMessage(message);
+                    }
+                });
+        return new InitResult<ChannelInboundHandler>(inputBuffer, inboundHandler);
+    }
+    @Override
+    public InitResult<ChannelOutboundHandler> initOutbound(Channel channel) {
+        ByteBuffer outputBuffer = newByteBuffer(bufferSize, direct);
+        outputBuffer.put(stringToBytes(CLIENT_BINARY_NEW));
+        return new InitResult<ChannelOutboundHandler>(outputBuffer, new ClientMessageEncoder());
+    }
+}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/ClientConnection.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/ClientConnection.java
@@ -8,56 +8,63 @@
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.connection.nio;
 import com.hazelcast.client.connection.ClientConnectionManager;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.spi.impl.ClientResponseHandler;
 import com.hazelcast.client.spi.impl.listener.AbstractClientListenerService;
 import com.hazelcast.core.LifecycleService;
 import com.hazelcast.instance.BuildInfo;
 import com.hazelcast.internal.metrics.Probe;
 import com.hazelcast.internal.metrics.ProbeLevel;
 import com.hazelcast.internal.networking.Channel;
 import com.hazelcast.internal.networking.OutboundFrame;
 import com.hazelcast.logging.ILogger;
 import com.hazelcast.nio.Address;
 import com.hazelcast.nio.Connection;
 import com.hazelcast.nio.ConnectionType;
+import com.hazelcast.util.Clock;
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.nio.channels.CancelledKeyException;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 import static com.hazelcast.util.StringUtil.timeToStringFriendly;
 /**
  * Client implementation of {@link Connection}.
  * ClientConnection is a connection between a Hazelcast Client and a Hazelcast Member.
  */
 public class ClientConnection implements Connection {
     @Probe
     private final int connectionId;
     private final ILogger logger;
+    private final AtomicInteger pendingPacketCount = new AtomicInteger(0);
     private final Channel channel;
     private final ClientConnectionManagerImpl connectionManager;
     private final LifecycleService lifecycleService;
     private final HazelcastClientInstanceImpl client;
     private final long startTime = System.currentTimeMillis();
     private final ClientResponseHandler responseHandler;
     private volatile Address remoteEndpoint;
+    private volatile boolean isHeartBeating = true;
+    private volatile long lastHeartbeatRequestedMillis;
+    private volatile long lastHeartbeatReceivedMillis;
     private volatile boolean isAuthenticatedAsOwner;
     @Probe(level = ProbeLevel.DEBUG)
     private final AtomicLong closedTime = new AtomicLong();
     private volatile Throwable closeCause;
     private volatile String closeReason;
     private int connectedServerVersion = BuildInfo.UNKNOWN_HAZELCAST_VERSION;
     private String connectedServerVersionString;
     public ClientConnection(HazelcastClientInstanceImpl client, int connectionId, Channel channel) {
         this.client = client;
         this.responseHandler = client.getInvocationService().getResponseHandler();
@@ -70,20 +77,29 @@
     }
     public ClientConnection(HazelcastClientInstanceImpl client, int connectionId) {
         this.client = client;
         this.responseHandler = client.getInvocationService().getResponseHandler();
         this.connectionManager = (ClientConnectionManagerImpl) client.getConnectionManager();
         this.lifecycleService = client.getLifecycleService();
         this.connectionId = connectionId;
         this.channel = null;
         this.logger = client.getLoggingService().getLogger(ClientConnection.class);
     }
+    public void incrementPendingPacketCount() {
+        pendingPacketCount.incrementAndGet();
+    }
+    public void decrementPendingPacketCount() {
+        pendingPacketCount.decrementAndGet();
+    }
+    public int getPendingPacketCount() {
+        return pendingPacketCount.get();
+    }
     @Override
     public boolean write(OutboundFrame frame) {
         if (channel.write(frame)) {
             return true;
         }
         if (logger.isFinestEnabled()) {
             logger.finest("Connection is closed, dropping frame -> " + frame);
         }
         return false;
     }
@@ -183,26 +199,43 @@
     }
     @Override
     public String getCloseReason() {
         if (closeReason == null) {
             return closeCause == null ? null : closeCause.getMessage();
         } else {
             return closeReason;
         }
     }
     public void handleClientMessage(ClientMessage message) {
+        incrementPendingPacketCount();
         if (message.isFlagSet(ClientMessage.LISTENER_EVENT_FLAG)) {
             AbstractClientListenerService listenerService = (AbstractClientListenerService) client.getListenerService();
-            listenerService.handleClientMessage(message);
-        } else {
-            responseHandler.handle(message);
-        }
+            listenerService.handleClientMessage(message, this);
+        } else {
+            responseHandler.handle(message, this);
+        }
+    }
+    @SuppressFBWarnings(value = "VO_VOLATILE_INCREMENT", justification = "incremented in single thread")
+    void onHeartbeatFailed() {
+        isHeartBeating = false;
+    }
+    void onHeartbeatResumed() {
+        isHeartBeating = true;
+    }
+    void onHeartbeatReceived() {
+        lastHeartbeatReceivedMillis = Clock.currentTimeMillis();
+    }
+    void onHeartbeatRequested() {
+        lastHeartbeatRequestedMillis = Clock.currentTimeMillis();
+    }
+    public boolean isHeartBeating() {
+        return isAlive() && isHeartBeating;
     }
     public boolean isAuthenticatedAsOwner() {
         return isAuthenticatedAsOwner;
     }
     public void setIsAuthenticatedAsOwner() {
         this.isAuthenticatedAsOwner = true;
     }
     public long getStartTime() {
         return startTime;
     }
@@ -224,22 +257,32 @@
     @Override
     public String toString() {
         return "ClientConnection{"
                 + "alive=" + isAlive()
                 + ", connectionId=" + connectionId
                 + ", channel=" + channel
                 + ", remoteEndpoint=" + remoteEndpoint
                 + ", lastReadTime=" + timeToStringFriendly(lastReadTimeMillis())
                 + ", lastWriteTime=" + timeToStringFriendly(lastWriteTimeMillis())
                 + ", closedTime=" + timeToStringFriendly(closedTime.get())
+                + ", lastHeartbeatRequested=" + timeToStringFriendly(lastHeartbeatRequestedMillis)
+                + ", lastHeartbeatReceived=" + timeToStringFriendly(lastHeartbeatReceivedMillis)
                 + ", connected server version=" + connectedServerVersionString
                 + '}';
+    }
+    /**
+     * Closed time is the first time connection.close called.
+     *
+     * @return the closed time of connection, returns zero if not closed yet
+     */
+    public long getClosedTime() {
+        return closedTime.get();
     }
     public void setConnectedServerVersion(String connectedServerVersion) {
         this.connectedServerVersionString = connectedServerVersion;
         this.connectedServerVersion = BuildInfo.calculateVersion(connectedServerVersion);
     }
     public int getConnectedServerVersion() {
         return connectedServerVersion;
     }
     public String getConnectedServerVersionString() {
         return connectedServerVersionString;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/ClientConnectionManagerImpl.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/ClientConnectionManagerImpl.java
@@ -9,130 +9,182 @@
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.connection.nio;
 import com.hazelcast.client.AuthenticationException;
 import com.hazelcast.client.ClientExtension;
+import com.hazelcast.client.ClientTypes;
 import com.hazelcast.client.HazelcastClientNotActiveException;
 import com.hazelcast.client.HazelcastClientOfflineException;
 import com.hazelcast.client.config.ClientNetworkConfig;
+import com.hazelcast.client.config.SocketOptions;
 import com.hazelcast.client.connection.AddressProvider;
 import com.hazelcast.client.connection.AddressTranslator;
 import com.hazelcast.client.connection.ClientConnectionManager;
 import com.hazelcast.client.connection.ClientConnectionStrategy;
-import com.hazelcast.client.impl.ClientTypes;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.LifecycleServiceImpl;
 import com.hazelcast.client.impl.client.ClientPrincipal;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
 import com.hazelcast.client.impl.protocol.AuthenticationStatus;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.ClientAuthenticationCodec;
 import com.hazelcast.client.impl.protocol.codec.ClientAuthenticationCustomCodec;
 import com.hazelcast.client.spi.ClientContext;
 import com.hazelcast.client.spi.impl.ClientExecutionServiceImpl;
 import com.hazelcast.client.spi.impl.ClientInvocation;
 import com.hazelcast.client.spi.impl.ClientInvocationFuture;
+import com.hazelcast.client.spi.impl.ConnectionHeartbeatListener;
 import com.hazelcast.config.SSLConfig;
 import com.hazelcast.config.SocketInterceptorConfig;
 import com.hazelcast.core.ExecutionCallback;
 import com.hazelcast.core.HazelcastException;
+import com.hazelcast.core.LifecycleEvent;
+import com.hazelcast.core.Member;
 import com.hazelcast.instance.BuildInfoProvider;
 import com.hazelcast.internal.networking.Channel;
 import com.hazelcast.internal.networking.ChannelErrorHandler;
-import com.hazelcast.internal.networking.nio.NioNetworking;
+import com.hazelcast.internal.networking.ChannelFactory;
+import com.hazelcast.internal.networking.nio.NioEventLoopGroup;
 import com.hazelcast.internal.serialization.InternalSerializationService;
 import com.hazelcast.logging.ILogger;
 import com.hazelcast.nio.Address;
 import com.hazelcast.nio.ClassLoaderUtil;
 import com.hazelcast.nio.Connection;
 import com.hazelcast.nio.ConnectionListener;
 import com.hazelcast.nio.SocketInterceptor;
 import com.hazelcast.nio.serialization.Data;
 import com.hazelcast.security.Credentials;
-import com.hazelcast.security.ICredentialsFactory;
 import com.hazelcast.security.UsernamePasswordCredentials;
 import com.hazelcast.spi.properties.HazelcastProperties;
 import com.hazelcast.spi.serialization.SerializationService;
 import com.hazelcast.util.AddressUtil;
+import com.hazelcast.util.Clock;
+import com.hazelcast.util.executor.SingleExecutorThreadFactory;
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.net.Socket;
 import java.net.SocketAddress;
 import java.nio.channels.SocketChannel;
+import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Future;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicInteger;
+import static com.hazelcast.client.config.SocketOptions.DEFAULT_BUFFER_SIZE_BYTE;
+import static com.hazelcast.client.config.SocketOptions.KILO_BYTE;
 import static com.hazelcast.client.spi.properties.ClientProperty.ALLOW_INVOCATIONS_WHEN_DISCONNECTED;
 import static com.hazelcast.client.spi.properties.ClientProperty.IO_BALANCER_INTERVAL_SECONDS;
 import static com.hazelcast.client.spi.properties.ClientProperty.IO_INPUT_THREAD_COUNT;
 import static com.hazelcast.client.spi.properties.ClientProperty.IO_OUTPUT_THREAD_COUNT;
-import static com.hazelcast.nio.IOUtil.closeResource;
+import static com.hazelcast.client.spi.properties.ClientProperty.SHUFFLE_MEMBER_LIST;
+import static com.hazelcast.spi.properties.GroupProperty.SOCKET_CLIENT_BUFFER_DIRECT;
 import static com.hazelcast.util.ExceptionUtil.rethrow;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 /**
  * Implementation of {@link ClientConnectionManager}.
  */
 @SuppressWarnings("checkstyle:classdataabstractioncoupling")
-public class ClientConnectionManagerImpl implements ClientConnectionManager {
+public class ClientConnectionManagerImpl implements ClientConnectionManager, ConnectionHeartbeatListener {
     private static final int DEFAULT_SSL_THREAD_COUNT = 3;
+    private static final int DEFAULT_CONNECTION_ATTEMPT_LIMIT_SYNC = 2;
+    private static final int DEFAULT_CONNECTION_ATTEMPT_LIMIT_ASYNC = 20;
     protected final AtomicInteger connectionIdGen = new AtomicInteger();
     protected volatile boolean alive;
     private final ILogger logger;
     private final int connectionTimeoutMillis;
     private final HazelcastClientInstanceImpl client;
     private final SocketInterceptor socketInterceptor;
+    private final SocketOptions socketOptions;
+    private final ChannelFactory channelFactory;
     private final ClientExecutionServiceImpl executionService;
     private final AddressTranslator addressTranslator;
-    private final ConcurrentMap<Address, ClientConnection> activeConnections = new ConcurrentHashMap<Address, ClientConnection>();
+    private final ConcurrentMap<Address, ClientConnection> activeConnections
+            = new ConcurrentHashMap<Address, ClientConnection>();
     private final ConcurrentMap<Address, AuthenticationFuture> connectionsInProgress =
             new ConcurrentHashMap<Address, AuthenticationFuture>();
     private final Collection<ConnectionListener> connectionListeners = new CopyOnWriteArrayList<ConnectionListener>();
     private final boolean allowInvokeWhenDisconnected;
-    private final ICredentialsFactory credentialsFactory;
-    private final NioNetworking networking;
+    private final Credentials credentials;
+    private final NioEventLoopGroup eventLoopGroup;
+    private volatile Address ownerConnectionAddress;
+    private volatile Address previousOwnerConnectionAddress;
     private final HeartbeatManager heartbeat;
-    private final ClusterConnector clusterConnector;
     private final long authenticationTimeout;
     private volatile ClientPrincipal principal;
     private final ClientConnectionStrategy connectionStrategy;
+    private final ExecutorService clusterConnectionExecutor;
+    private final int connectionAttemptPeriod;
+    private final int connectionAttemptLimit;
+    private final boolean shuffleMemberList;
+    private final Collection<AddressProvider> addressProviders;
     private final LinkedList<Integer> outboundPorts = new LinkedList<Integer>();
     private final int outboundPortCount;
-    private volatile Credentials lastCredentials;
+    @SuppressWarnings("checkstyle:executablestatementcount")
     public ClientConnectionManagerImpl(HazelcastClientInstanceImpl client, AddressTranslator addressTranslator,
                                        Collection<AddressProvider> addressProviders) {
         allowInvokeWhenDisconnected = client.getProperties().getBoolean(ALLOW_INVOCATIONS_WHEN_DISCONNECTED);
         this.client = client;
         this.addressTranslator = addressTranslator;
         this.logger = client.getLoggingService().getLogger(ClientConnectionManager.class);
         ClientNetworkConfig networkConfig = client.getClientConfig().getNetworkConfig();
         final int connTimeout = networkConfig.getConnectionTimeout();
         this.connectionTimeoutMillis = connTimeout == 0 ? Integer.MAX_VALUE : connTimeout;
         this.executionService = (ClientExecutionServiceImpl) client.getClientExecutionService();
-        this.networking = initNetworking(client);
+        this.socketOptions = networkConfig.getSocketOptions();
+        this.eventLoopGroup = initEventLoopGroup(client);
+        this.channelFactory = client.getClientExtension().createSocketChannelWrapperFactory();
         this.socketInterceptor = initSocketInterceptor(networkConfig.getSocketInterceptorConfig());
-        this.credentialsFactory = client.getCredentialsFactory();
+        this.credentials = client.getCredentials();
         this.connectionStrategy = initializeStrategy(client);
+        this.clusterConnectionExecutor = createSingleThreadExecutorService(client);
+        this.shuffleMemberList = client.getProperties().getBoolean(SHUFFLE_MEMBER_LIST);
+        this.addressProviders = addressProviders;
+        this.connectionAttemptPeriod = networkConfig.getConnectionAttemptPeriod();
+        int connAttemptLimit = networkConfig.getConnectionAttemptLimit();
+        boolean isAsync = client.getClientConfig().getConnectionStrategyConfig().isAsyncStart();
+        if (connAttemptLimit < 0) {
+            this.connectionAttemptLimit = isAsync ? DEFAULT_CONNECTION_ATTEMPT_LIMIT_ASYNC
+                    : DEFAULT_CONNECTION_ATTEMPT_LIMIT_SYNC;
+        } else {
+            this.connectionAttemptLimit = connAttemptLimit == 0 ? Integer.MAX_VALUE : connAttemptLimit;
+        }
         this.outboundPorts.addAll(getOutboundPorts(networkConfig));
         this.outboundPortCount = outboundPorts.size();
         this.heartbeat = new HeartbeatManager(this, client);
         this.authenticationTimeout = heartbeat.getHeartbeatTimeout();
-        this.clusterConnector = new ClusterConnector(client, this, connectionStrategy, addressProviders);
+        checkSslAllowed();
+    }
+    private void checkSslAllowed() {
+        SSLConfig sslConfig = client.getClientConfig().getNetworkConfig().getSSLConfig();
+        if (sslConfig != null && sslConfig.isEnabled()) {
+            if (!BuildInfoProvider.getBuildInfo().isEnterprise()) {
+                throw new IllegalStateException("SSL/TLS requires Hazelcast Enterprise Edition");
+            }
+        }
     }
     private Collection<Integer> getOutboundPorts(ClientNetworkConfig networkConfig) {
         Collection<Integer> outboundPorts = networkConfig.getOutboundPorts();
         Collection<String> outboundPortDefinitions = networkConfig.getOutboundPortDefinitions();
         return AddressUtil.getOutboundPorts(outboundPorts, outboundPortDefinitions);
     }
     private ClientConnectionStrategy initializeStrategy(HazelcastClientInstanceImpl client) {
         ClientConnectionStrategy strategy;
         String className = client.getProperties().get("hazelcast.client.connection.strategy.classname");
         if (className != null) {
@@ -140,107 +192,105 @@
                 ClassLoader configClassLoader = client.getClientConfig().getClassLoader();
                 return ClassLoaderUtil.newInstance(configClassLoader, className);
             } catch (Exception e) {
                 throw rethrow(e);
             }
         } else {
             strategy = new DefaultClientConnectionStrategy();
         }
         return strategy;
     }
-    public NioNetworking getNetworking() {
-        return networking;
-    }
-    protected NioNetworking initNetworking(HazelcastClientInstanceImpl client) {
+    public NioEventLoopGroup getEventLoopGroup() {
+        return eventLoopGroup;
+    }
+    protected NioEventLoopGroup initEventLoopGroup(HazelcastClientInstanceImpl client) {
         HazelcastProperties properties = client.getProperties();
+        boolean directBuffer = properties.getBoolean(SOCKET_CLIENT_BUFFER_DIRECT);
         SSLConfig sslConfig = client.getClientConfig().getNetworkConfig().getSSLConfig();
         boolean sslEnabled = sslConfig != null && sslConfig.isEnabled();
         int configuredInputThreads = properties.getInteger(IO_INPUT_THREAD_COUNT);
         int configuredOutputThreads = properties.getInteger(IO_OUTPUT_THREAD_COUNT);
         int inputThreads;
         if (configuredInputThreads == -1) {
             inputThreads = sslEnabled ? DEFAULT_SSL_THREAD_COUNT : 1;
         } else {
             inputThreads = configuredInputThreads;
         }
         int outputThreads;
         if (configuredOutputThreads == -1) {
             outputThreads = sslEnabled ? DEFAULT_SSL_THREAD_COUNT : 1;
         } else {
             outputThreads = configuredOutputThreads;
         }
-        return new NioNetworking(
-                new NioNetworking.Context()
+        return new NioEventLoopGroup(
+                new NioEventLoopGroup.Context()
                         .loggingService(client.getLoggingService())
                         .metricsRegistry(client.getMetricsRegistry())
                         .threadNamePrefix(client.getName())
                         .errorHandler(new ClientConnectionChannelErrorHandler())
                         .inputThreadCount(inputThreads)
                         .outputThreadCount(outputThreads)
                         .balancerIntervalSeconds(properties.getInteger(IO_BALANCER_INTERVAL_SECONDS))
-                        .channelInitializer(client.getClientExtension().createChannelInitializer()));
+                        .channelInitializer(new ClientChannelInitializer(getBufferSize(), directBuffer)));
     }
     private SocketInterceptor initSocketInterceptor(SocketInterceptorConfig sic) {
         if (sic != null && sic.isEnabled()) {
             ClientExtension clientExtension = client.getClientExtension();
             return clientExtension.createSocketInterceptor();
         }
         return null;
     }
-    public ClientConnectionStrategy getConnectionStrategy() {
-        return connectionStrategy;
-    }
     @Override
     public Collection<ClientConnection> getActiveConnections() {
         return activeConnections.values();
     }
     @Override
     public boolean isAlive() {
         return alive;
     }
     public synchronized void start(ClientContext clientContext) {
         if (alive) {
             return;
         }
         alive = true;
-        startNetworking();
+        startEventLoopGroup();
         heartbeat.start();
+        addConnectionHeartbeatListener(this);
         connectionStrategy.init(clientContext);
         connectionStrategy.start();
     }
-    protected void startNetworking() {
-        networking.start();
+    protected void startEventLoopGroup() {
+        eventLoopGroup.start();
     }
     public synchronized void shutdown() {
         if (!alive) {
             return;
         }
         alive = false;
         for (Connection connection : activeConnections.values()) {
             connection.close("Hazelcast client is shutting down", null);
         }
-        clusterConnector.shutdown();
-        stopNetworking();
+        ClientExecutionServiceImpl.shutdownExecutor("cluster", clusterConnectionExecutor, logger);
+        stopEventLoopGroup();
         connectionListeners.clear();
         heartbeat.shutdown();
         connectionStrategy.shutdown();
-        credentialsFactory.destroy();
     }
     @Override
     public ClientPrincipal getPrincipal() {
         return principal;
     }
     private void setPrincipal(ClientPrincipal principal) {
         this.principal = principal;
     }
-    protected void stopNetworking() {
-        networking.shutdown();
+    protected void stopEventLoopGroup() {
+        eventLoopGroup.shutdown();
     }
     @Override
     public Connection getActiveConnection(Address target) {
         if (target == null) {
             return null;
         }
         return activeConnections.get(target);
     }
     @Override
     public Connection getOrConnect(Address address) throws IOException {
@@ -269,43 +319,46 @@
                 return connection;
             }
         }
         return null;
     }
     private void checkAllowed(Address target, boolean asOwner, boolean acquiresResources) throws IOException {
         if (!alive) {
             throw new HazelcastClientNotActiveException("ConnectionManager is not active!");
         }
         if (asOwner) {
-            connectionStrategy.beforeConnectToCluster(target);
             return;
         }
         try {
             connectionStrategy.beforeGetConnection(target);
         } catch (HazelcastClientOfflineException e) {
             if (allowInvokeWhenDisconnected && !acquiresResources) {
                 return;
             }
             throw e;
         }
         if (getOwnerConnection() == null) {
             if (allowInvokeWhenDisconnected && !acquiresResources) {
                 return;
             }
             throw new IOException("Owner connection is not available!");
         }
     }
     @Override
     public Address getOwnerConnectionAddress() {
-        return clusterConnector.getOwnerConnectionAddress();
-    }
-    Connection getOrConnect(Address address, boolean asOwner) {
+        return ownerConnectionAddress;
+    }
+    private void setOwnerConnectionAddress(Address ownerConnectionAddress) {
+        this.previousOwnerConnectionAddress = this.ownerConnectionAddress;
+        this.ownerConnectionAddress = ownerConnectionAddress;
+    }
+    private Connection getOrConnect(Address address, boolean asOwner) {
         try {
             while (true) {
                 ClientConnection connection = (ClientConnection) getConnection(address, asOwner, true);
                 if (connection != null) {
                     return connection;
                 }
                 AuthenticationFuture future = triggerConnect(address, asOwner);
                 connection = (ClientConnection) future.get();
                 if (!asOwner) {
                     return connection;
@@ -325,40 +378,77 @@
         AuthenticationFuture future = new AuthenticationFuture();
         AuthenticationFuture oldFuture = connectionsInProgress.putIfAbsent(target, future);
         if (oldFuture == null) {
             executionService.execute(new InitConnectionTask(target, asOwner, future));
             return future;
         }
         return oldFuture;
     }
     @Override
     public ClientConnection getOwnerConnection() {
-        Address ownerConnectionAddress = clusterConnector.getOwnerConnectionAddress();
         if (ownerConnectionAddress == null) {
             return null;
         }
-        return (ClientConnection) getActiveConnection(ownerConnectionAddress);
+        ClientConnection connection = (ClientConnection) getActiveConnection(ownerConnectionAddress);
+        return connection;
+    }
+    private Connection connectAsOwner(Address address) {
+        Connection connection = null;
+        try {
+            logger.info("Trying to connect to " + address + " as owner member");
+            connection = getOrConnect(address, true);
+            client.onClusterConnect(connection);
+            fireConnectionEvent(LifecycleEvent.LifecycleState.CLIENT_CONNECTED);
+            connectionStrategy.onConnectToCluster();
+        } catch (Exception e) {
+            logger.warning("Exception during initial connection to " + address + ", exception " + e);
+            if (null != connection) {
+                connection.close("Could not connect to " + address + " as owner", e);
+            }
+            return null;
+        }
+        return connection;
     }
     private void fireConnectionAddedEvent(ClientConnection connection) {
         for (ConnectionListener connectionListener : connectionListeners) {
             connectionListener.connectionAdded(connection);
         }
         connectionStrategy.onConnect(connection);
     }
     private void fireConnectionRemovedEvent(ClientConnection connection) {
         if (connection.isAuthenticatedAsOwner()) {
-            clusterConnector.disconnectFromCluster(connection);
+            disconnectFromCluster(connection);
         }
         for (ConnectionListener listener : connectionListeners) {
             listener.connectionRemoved(connection);
         }
         connectionStrategy.onDisconnect(connection);
+    }
+    private void disconnectFromCluster(final ClientConnection connection) {
+        clusterConnectionExecutor.execute(new Runnable() {
+            @Override
+            public void run() {
+                Address endpoint = connection.getEndPoint();
+                if (endpoint == null || !endpoint.equals(ownerConnectionAddress)) {
+                    return;
+                }
+                setOwnerConnectionAddress(null);
+                connectionStrategy.onDisconnectFromCluster();
+                if (client.getLifecycleService().isRunning()) {
+                    fireConnectionEvent(LifecycleEvent.LifecycleState.CLIENT_DISCONNECTED);
+                }
+            }
+        });
+    }
+    private void fireConnectionEvent(final LifecycleEvent.LifecycleState state) {
+        final LifecycleServiceImpl lifecycleService = (LifecycleServiceImpl) client.getLifecycleService();
+        lifecycleService.fireLifecycleEvent(state);
     }
     private boolean useAnyOutboundPort() {
         return outboundPortCount == 0;
     }
     private int acquireOutboundPort() {
         if (outboundPortCount == 0) {
             return 0;
         }
         synchronized (outboundPorts) {
             final Integer port = outboundPorts.removeFirst();
@@ -383,40 +473,59 @@
                     socket.bind(socketAddress);
                     return;
                 } catch (IOException e) {
                     ex = e;
                     logger.finest("Could not bind port[ " + port + "]: " + e.getMessage());
                 }
             }
             throw ex;
         }
     }
-    protected ClientConnection createSocketConnection(final Address remoteAddress) throws IOException {
+    protected ClientConnection createSocketConnection(final Address address) throws IOException {
         SocketChannel socketChannel = null;
         try {
             socketChannel = SocketChannel.open();
             Socket socket = socketChannel.socket();
+            socket.setKeepAlive(socketOptions.isKeepAlive());
+            socket.setTcpNoDelay(socketOptions.isTcpNoDelay());
+            socket.setReuseAddress(socketOptions.isReuseAddress());
+            if (socketOptions.getLingerSeconds() > 0) {
+                socket.setSoLinger(true, socketOptions.getLingerSeconds());
+            }
+            int bufferSize = getBufferSize();
+            socket.setSendBufferSize(bufferSize);
+            socket.setReceiveBufferSize(bufferSize);
+            InetSocketAddress inetSocketAddress = address.getInetSocketAddress();
             bindSocketToPort(socket);
-            Channel channel = networking.register(socketChannel, true);
-            channel.connect(remoteAddress.getInetSocketAddress(), connectionTimeoutMillis);
-            ClientConnection connection
-                    = new ClientConnection(client, connectionIdGen.incrementAndGet(), channel);
+            socketChannel.socket().connect(inetSocketAddress, connectionTimeoutMillis);
+            HazelcastProperties properties = client.getProperties();
+            boolean directBuffer = properties.getBoolean(SOCKET_CLIENT_BUFFER_DIRECT);
+            Channel channel = channelFactory.create(socketChannel, true, directBuffer);
+            final ClientConnection clientConnection = new ClientConnection(
+                    client, connectionIdGen.incrementAndGet(), channel);
             socketChannel.configureBlocking(true);
             if (socketInterceptor != null) {
                 socketInterceptor.onConnect(socket);
             }
-            channel.start();
-            return connection;
+            socket.setSoTimeout(0);
+            eventLoopGroup.register(channel);
+            return clientConnection;
         } catch (Exception e) {
-            closeResource(socketChannel);
+            if (socketChannel != null) {
+                socketChannel.close();
+            }
             throw rethrow(e, IOException.class);
         }
+    }
+    private int getBufferSize() {
+        int bufferSize = socketOptions.getBufferSize() * KILO_BYTE;
+        return bufferSize <= 0 ? DEFAULT_BUFFER_SIZE_BYTE : bufferSize;
     }
     void onClose(Connection connection) {
         removeFromActiveConnections(connection);
     }
     private void removeFromActiveConnections(Connection connection) {
         Address endpoint = connection.getEndPoint();
         if (endpoint == null) {
             if (logger.isFinestEnabled()) {
                 logger.finest("Destroying " + connection + ", but it has end-point set to null "
                         + "-> not removing it from a connection map");
@@ -429,42 +538,44 @@
         } else {
             if (logger.isFinestEnabled()) {
                 logger.finest("Destroying a connection, but there is no mapping " + endpoint + " -> " + connection
                         + " in the connection map.");
             }
         }
     }
     @Override
     public void addConnectionListener(ConnectionListener connectionListener) {
         connectionListeners.add(connectionListener);
+    }
+    @Override
+    public void addConnectionHeartbeatListener(ConnectionHeartbeatListener connectionHeartbeatListener) {
+        heartbeat.addConnectionHeartbeatListener(connectionHeartbeatListener);
     }
     private void authenticate(final Address target, final ClientConnection connection, final boolean asOwner,
                               final AuthenticationFuture future) {
         final ClientPrincipal principal = getPrincipal();
         ClientMessage clientMessage = encodeAuthenticationRequest(asOwner, client.getSerializationService(), principal);
         ClientInvocation clientInvocation = new ClientInvocation(client, clientMessage, null, connection);
         ClientInvocationFuture invocationFuture = clientInvocation.invokeUrgent();
         ScheduledFuture timeoutTaskFuture = executionService.schedule(
                 new TimeoutAuthenticationTask(invocationFuture), authenticationTimeout, MILLISECONDS);
         invocationFuture.andThen(new AuthCallback(connection, asOwner, target, future, timeoutTaskFuture));
     }
     private ClientMessage encodeAuthenticationRequest(boolean asOwner, SerializationService ss, ClientPrincipal principal) {
         byte serializationVersion = ((InternalSerializationService) ss).getVersion();
         String uuid = null;
         String ownerUuid = null;
         if (principal != null) {
             uuid = principal.getUuid();
             ownerUuid = principal.getOwnerUuid();
         }
         ClientMessage clientMessage;
-        Credentials credentials = credentialsFactory.newCredentials();
-        lastCredentials = credentials;
         if (credentials.getClass().equals(UsernamePasswordCredentials.class)) {
             UsernamePasswordCredentials cr = (UsernamePasswordCredentials) credentials;
             clientMessage = ClientAuthenticationCodec
                     .encodeRequest(cr.getUsername(), cr.getPassword(), uuid, ownerUuid, asOwner, ClientTypes.JAVA,
                             serializationVersion, BuildInfoProvider.getBuildInfo().getVersion());
         } else {
             Data data = ss.toData(credentials);
             clientMessage = ClientAuthenticationCustomCodec.encodeRequest(data, uuid, ownerUuid,
                     asOwner, ClientTypes.JAVA, serializationVersion, BuildInfoProvider.getBuildInfo().getVersion());
         }
@@ -501,25 +612,27 @@
             removeFromActiveConnections(connection);
         }
     }
     private void onAuthenticationFailed(Address target, ClientConnection connection, Throwable cause) {
         if (logger.isFinestEnabled()) {
             logger.finest("Authentication of " + connection + " failed.", cause);
         }
         connection.close(null, cause);
         connectionsInProgress.remove(target);
     }
-    public Credentials getLastCredentials() {
-        return lastCredentials;
-    }
-    Collection<Address> getPossibleMemberAddresses() {
-        return clusterConnector.getPossibleMemberAddresses();
+    @Override
+    public void heartbeatResumed(Connection connection) {
+        connectionStrategy.onHeartbeatResumed((ClientConnection) connection);
+    }
+    @Override
+    public void heartbeatStopped(Connection connection) {
+        connectionStrategy.onHeartbeatStopped((ClientConnection) connection);
     }
     private class TimeoutAuthenticationTask implements Runnable {
         private final ClientInvocationFuture future;
         TimeoutAuthenticationTask(ClientInvocationFuture future) {
             this.future = future;
         }
         @Override
         public void run() {
             if (future.isDone()) {
                 return;
@@ -582,25 +695,135 @@
                 if (cause instanceof EOFException) {
                     connection.close("Connection closed by the other side", cause);
                 } else {
                     connection.close("Exception in " + connection + ", thread=" + Thread.currentThread().getName(), cause);
                 }
             }
         }
     }
     @Override
     public void connectToCluster() {
-        clusterConnector.connectToCluster();
+        try {
+            connectToClusterAsync().get();
+        } catch (Exception e) {
+            throw rethrow(e);
+        }
+    }
+    private void connectToClusterInternal() {
+        int attempt = 0;
+        Set<Address> triedAddresses = new HashSet<Address>();
+        while (attempt < connectionAttemptLimit) {
+            attempt++;
+            long nextTry = Clock.currentTimeMillis() + connectionAttemptPeriod;
+            Collection<Address> addresses = getPossibleMemberAddresses();
+            for (Address address : addresses) {
+                if (!client.getLifecycleService().isRunning()) {
+                    throw new IllegalStateException("Giving up on retrying to connect to cluster since client is shutdown.");
+                }
+                triedAddresses.add(address);
+                if (connectAsOwner(address) != null) {
+                    return;
+                }
+            }
+            if (!client.getLifecycleService().isRunning()) {
+                throw new IllegalStateException("Client is being shutdown.");
+            }
+            if (attempt < connectionAttemptLimit) {
+                final long remainingTime = nextTry - Clock.currentTimeMillis();
+                logger.warning(String.format("Unable to get alive cluster connection, try in %d ms later, attempt %d of %d.",
+                        Math.max(0, remainingTime), attempt, connectionAttemptLimit));
+                if (remainingTime > 0) {
+                    try {
+                        Thread.sleep(remainingTime);
+                    } catch (InterruptedException e) {
+                        Thread.currentThread().interrupt();
+                        break;
+                    }
+                }
+            } else {
+                logger.warning(String.format("Unable to get alive cluster connection, attempt %d of %d.", attempt,
+                        connectionAttemptLimit));
+            }
+        }
+        throw new IllegalStateException(
+                "Unable to connect to any address! The following addresses were tried: " + triedAddresses);
     }
     @Override
     public Future<Void> connectToClusterAsync() {
-        return clusterConnector.connectToClusterAsync();
+        return clusterConnectionExecutor.submit(new Callable<Void>() {
+            @Override
+            public Void call() throws Exception {
+                try {
+                    connectToClusterInternal();
+                } catch (Exception e) {
+                    logger.warning("Could not connect to cluster, shutting down the client. " + e.getMessage());
+                    new Thread(new Runnable() {
+                        @Override
+                        public void run() {
+                            try {
+                                client.getLifecycleService().shutdown();
+                            } catch (Exception exception) {
+                                logger.severe("Exception during client shutdown ", exception);
+                            }
+                        }
+                    }, client.getName() + ".clientShutdown-").start();
+                    throw rethrow(e);
+                }
+                return null;
+            }
+        });
+    }
+    Collection<Address> getPossibleMemberAddresses() {
+        LinkedHashSet<Address> addresses = new LinkedHashSet<Address>();
+        Collection<Member> memberList = client.getClientClusterService().getMemberList();
+        for (Member member : memberList) {
+            addresses.add(member.getAddress());
+        }
+        if (shuffleMemberList) {
+            shuffle(addresses);
+        }
+        LinkedHashSet<Address> providerAddresses = new LinkedHashSet<Address>();
+        for (AddressProvider addressProvider : addressProviders) {
+            try {
+                providerAddresses.addAll(addressProvider.loadAddresses());
+            } catch (NullPointerException e) {
+                throw e;
+            } catch (Exception e) {
+                logger.warning("Exception from AddressProvider: " + addressProvider, e);
+            }
+        }
+        if (shuffleMemberList) {
+            shuffle(providerAddresses);
+        }
+        addresses.addAll(providerAddresses);
+        if (previousOwnerConnectionAddress != null) {
+            /*
+             * Previous owner address is moved to last item in set so that client will not try to connect to same one immediately.
+             * It could be the case that address is removed because it is healthy(it not responding to heartbeat/pings)
+             * In that case, trying other addresses first to upgrade make more sense.
+             */
+            addresses.remove(previousOwnerConnectionAddress);
+            addresses.add(previousOwnerConnectionAddress);
+        }
+        return addresses;
+    }
+    private static <T> Set<T> shuffle(Set<T> set) {
+        List<T> shuffleMe = new ArrayList<T>(set);
+        Collections.shuffle(shuffleMe);
+        Set<T> shuffledSet = new LinkedHashSet<T>();
+        shuffledSet.addAll(shuffleMe);
+        return shuffledSet;
+    }
+    private ExecutorService createSingleThreadExecutorService(HazelcastClientInstanceImpl client) {
+        ClassLoader classLoader = client.getClientConfig().getClassLoader();
+        SingleExecutorThreadFactory threadFactory = new SingleExecutorThreadFactory(classLoader, client.getName() + ".cluster-");
+        return Executors.newSingleThreadExecutor(threadFactory);
     }
     private class AuthCallback implements ExecutionCallback<ClientMessage> {
         private final ClientConnection connection;
         private final boolean asOwner;
         private final Address target;
         private final AuthenticationFuture future;
         private final ScheduledFuture timeoutTaskFuture;
         AuthCallback(ClientConnection connection, boolean asOwner, Address target,
                      AuthenticationFuture future, ScheduledFuture timeoutTaskFuture) {
             this.connection = connection;
@@ -621,21 +844,21 @@
             }
             AuthenticationStatus authenticationStatus = AuthenticationStatus.getById(result.status);
             switch (authenticationStatus) {
                 case AUTHENTICATED:
                     connection.setConnectedServerVersion(result.serverHazelcastVersion);
                     connection.setRemoteEndpoint(result.address);
                     if (asOwner) {
                         connection.setIsAuthenticatedAsOwner();
                         ClientPrincipal principal = new ClientPrincipal(result.uuid, result.ownerUuid);
                         setPrincipal(principal);
-                        clusterConnector.setOwnerConnectionAddress(connection.getEndPoint());
+                        setOwnerConnectionAddress(connection.getEndPoint());
                         logger.info("Setting " + connection + " as owner with principal " + principal);
                     }
                     onAuthenticated(target, connection);
                     future.onSuccess(connection);
                     break;
                 case CREDENTIALS_FAILED:
                     onFailure(new AuthenticationException("Invalid credentials! Principal: " + principal));
                     break;
                 default:
                     onFailure(new AuthenticationException("Authentication status code not supported. status: "

--- a/hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/ClientICMPManager.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/ClientICMPManager.java
@@ -138,21 +138,22 @@
                 Address address = connection.getEndPoint();
                 logger.fine(format("will ping %s", address));
                 if (doPing(address, Level.FINE)) {
                     icmpFailureDetector.heartbeat(connection);
                     return;
                 }
                 icmpFailureDetector.logAttempt(connection);
                 String reason = format("Could not ping %s", address);
                 logger.warning(reason);
                 if (!icmpFailureDetector.isAlive(connection)) {
-                    heartbeatManager.onHeartbeatStopped(connection, "ICMP ping time out");
+                    connection.onHeartbeatFailed();
+                    heartbeatManager.fireHeartbeatStopped(connection);
                 }
             } catch (Throwable ignored) {
                 ignore(ignored);
             } finally {
                 if (!connection.isAlive()) {
                     icmpFailureDetector.remove(connection);
                 }
             }
         }
     }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/ClientPlainChannelInitializer.java
+++ b//dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.hazelcast.client.connection.nio;
-import com.hazelcast.client.config.SocketOptions;
-import com.hazelcast.client.impl.protocol.ClientMessage;
-import com.hazelcast.client.impl.protocol.util.ClientMessageDecoder;
-import com.hazelcast.client.impl.protocol.util.ClientMessageEncoder;
-import com.hazelcast.internal.networking.Channel;
-import com.hazelcast.internal.networking.ChannelInitializer;
-import com.hazelcast.util.function.Consumer;
-import static com.hazelcast.client.config.SocketOptions.KILO_BYTE;
-import static com.hazelcast.internal.networking.ChannelOption.DIRECT_BUF;
-import static com.hazelcast.internal.networking.ChannelOption.SO_KEEPALIVE;
-import static com.hazelcast.internal.networking.ChannelOption.SO_LINGER;
-import static com.hazelcast.internal.networking.ChannelOption.SO_RCVBUF;
-import static com.hazelcast.internal.networking.ChannelOption.SO_REUSEADDR;
-import static com.hazelcast.internal.networking.ChannelOption.SO_SNDBUF;
-import static com.hazelcast.internal.networking.ChannelOption.SO_TIMEOUT;
-import static com.hazelcast.internal.networking.ChannelOption.TCP_NODELAY;
-/**
- * Client side ChannelInitializer for connections without SSL/TLS. Client in this
- * case is a real client using client protocol etc.
- *
- * It will automatically send the Client Protocol to the server and configure the
- * correct buffers/handlers.
- */
-public class ClientPlainChannelInitializer implements ChannelInitializer {
-    private final boolean directBuffer;
-    private final SocketOptions socketOptions;
-    public ClientPlainChannelInitializer(SocketOptions socketOptions, boolean directBuffer) {
-        this.socketOptions = socketOptions;
-        this.directBuffer = directBuffer;
-    }
-    @Override
-    public void initChannel(Channel channel) {
-        channel.options()
-                .setOption(SO_SNDBUF, KILO_BYTE * socketOptions.getBufferSize())
-                .setOption(SO_RCVBUF, KILO_BYTE * socketOptions.getBufferSize())
-                .setOption(SO_REUSEADDR, socketOptions.isReuseAddress())
-                .setOption(SO_KEEPALIVE, socketOptions.isKeepAlive())
-                .setOption(SO_LINGER, socketOptions.getLingerSeconds())
-                .setOption(SO_TIMEOUT, 0)
-                .setOption(TCP_NODELAY, socketOptions.isTcpNoDelay())
-                .setOption(DIRECT_BUF, directBuffer);
-        final ClientConnection connection = (ClientConnection) channel.attributeMap().get(ClientConnection.class);
-        ClientMessageDecoder decoder = new ClientMessageDecoder(connection, new Consumer<ClientMessage>() {
-            @Override
-            public void accept(ClientMessage message) {
-                connection.handleClientMessage(message);
-            }
-        });
-        channel.inboundPipeline().addLast(decoder);
-        channel.outboundPipeline().addLast(new ClientMessageEncoder());
-        channel.outboundPipeline().addLast(new ClientProtocolEncoder());
-    }
-}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/ClientProtocolEncoder.java
+++ b//dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.hazelcast.client.connection.nio;
-import com.hazelcast.internal.networking.OutboundHandler;
-import com.hazelcast.internal.networking.HandlerStatus;
-import java.nio.ByteBuffer;
-import static com.hazelcast.internal.networking.HandlerStatus.CLEAN;
-import static com.hazelcast.internal.networking.HandlerStatus.DIRTY;
-import static com.hazelcast.nio.Protocols.CLIENT_BINARY_NEW;
-import static com.hazelcast.nio.Protocols.PROTOCOL_LENGTH;
-import static com.hazelcast.util.StringUtil.stringToBytes;
-/**
- * A {@link OutboundHandler} that writes the client protocol bytes
- * and once they have been fully written, it removes itself from pipeline.
- *
- * On a plain connection, this should be the last encoder in the pipeline.
- *
- * Even though the ClientProtocolEncoder has a ByteBuffer as src, it will
- * never consume bytes from this source.
- */
-public class ClientProtocolEncoder extends OutboundHandler<ByteBuffer, ByteBuffer> {
-    @Override
-    public void handlerAdded() {
-        initDstBuffer(PROTOCOL_LENGTH, stringToBytes(CLIENT_BINARY_NEW));
-    }
-    @Override
-    public HandlerStatus onWrite() {
-        if (dst.remaining() == 0) {
-            channel.outboundPipeline().remove(this);
-            return CLEAN;
-        } else {
-            return DIRTY;
-        }
-    }
-}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/ClusterConnector.java
+++ b//dev/null
@@ -1,320 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.hazelcast.client.connection.nio;
-import com.hazelcast.client.config.ClientConfig;
-import com.hazelcast.client.config.ClientConnectionStrategyConfig;
-import com.hazelcast.client.config.ClientNetworkConfig;
-import com.hazelcast.client.config.ConnectionRetryConfig;
-import com.hazelcast.client.connection.AddressProvider;
-import com.hazelcast.client.connection.ClientConnectionManager;
-import com.hazelcast.client.connection.ClientConnectionStrategy;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
-import com.hazelcast.client.impl.clientside.LifecycleServiceImpl;
-import com.hazelcast.client.spi.impl.ClientExecutionServiceImpl;
-import com.hazelcast.core.LifecycleEvent;
-import com.hazelcast.core.Member;
-import com.hazelcast.logging.ILogger;
-import com.hazelcast.nio.Address;
-import com.hazelcast.nio.Connection;
-import com.hazelcast.util.executor.SingleExecutorThreadFactory;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Random;
-import java.util.Set;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import static com.hazelcast.client.spi.properties.ClientProperty.SHUFFLE_MEMBER_LIST;
-import static com.hazelcast.util.ExceptionUtil.rethrow;
-/**
- * Helper to ClientConnectionManager.
- * selecting owner connection, connecting and disconnecting from cluster implemented in this class.
- */
-class ClusterConnector {
-    private static final int DEFAULT_CONNECTION_ATTEMPT_LIMIT_SYNC = 2;
-    private static final int DEFAULT_CONNECTION_ATTEMPT_LIMIT_ASYNC = 20;
-    private final ILogger logger;
-    private final HazelcastClientInstanceImpl client;
-    private final ClientConnectionManagerImpl connectionManager;
-    private final ClientConnectionStrategy connectionStrategy;
-    private final ExecutorService clusterConnectionExecutor;
-    private final boolean shuffleMemberList;
-    private final WaitStrategy waitStrategy;
-    private final Collection<AddressProvider> addressProviders;
-    private volatile Address ownerConnectionAddress;
-    private volatile Address previousOwnerConnectionAddress;
-    ClusterConnector(HazelcastClientInstanceImpl client,
-                     ClientConnectionManagerImpl connectionManager,
-                     ClientConnectionStrategy connectionStrategy,
-                     Collection<AddressProvider> addressProviders) {
-        this.client = client;
-        this.connectionManager = connectionManager;
-        this.logger = client.getLoggingService().getLogger(ClientConnectionManager.class);
-        this.connectionStrategy = connectionStrategy;
-        this.clusterConnectionExecutor = createSingleThreadExecutorService(client);
-        this.shuffleMemberList = client.getProperties().getBoolean(SHUFFLE_MEMBER_LIST);
-        this.addressProviders = addressProviders;
-        this.waitStrategy = initializeWaitStrategy(client.getClientConfig());
-    }
-    private WaitStrategy initializeWaitStrategy(ClientConfig clientConfig) {
-        ClientConnectionStrategyConfig connectionStrategyConfig = client.getClientConfig().getConnectionStrategyConfig();
-        ConnectionRetryConfig expoRetryConfig = connectionStrategyConfig.getConnectionRetryConfig();
-        if (expoRetryConfig.isEnabled()) {
-            return new ExponentialWaitStrategy(expoRetryConfig.getInitialBackoffMillis(),
-                    expoRetryConfig.getMaxBackoffMillis(),
-                    expoRetryConfig.getMultiplier(),
-                    expoRetryConfig.isFailOnMaxBackoff(),
-                    expoRetryConfig.getJitter());
-        }
-        ClientNetworkConfig networkConfig = clientConfig.getNetworkConfig();
-        int connectionAttemptPeriod = networkConfig.getConnectionAttemptPeriod();
-        boolean isAsync = connectionStrategyConfig.isAsyncStart();
-        int connectionAttemptLimit = networkConfig.getConnectionAttemptLimit();
-        if (connectionAttemptLimit < 0) {
-            connectionAttemptLimit = isAsync ? DEFAULT_CONNECTION_ATTEMPT_LIMIT_ASYNC
-                    : DEFAULT_CONNECTION_ATTEMPT_LIMIT_SYNC;
-        } else {
-            connectionAttemptLimit = connectionAttemptLimit == 0 ? Integer.MAX_VALUE : connectionAttemptLimit;
-        }
-        return new DefaultWaitStrategy(connectionAttemptPeriod, connectionAttemptLimit);
-    }
-    void connectToCluster() {
-        try {
-            connectToClusterAsync().get();
-        } catch (Exception e) {
-            throw rethrow(e);
-        }
-    }
-    Address getOwnerConnectionAddress() {
-        return ownerConnectionAddress;
-    }
-    void setOwnerConnectionAddress(Address ownerConnectionAddress) {
-        this.previousOwnerConnectionAddress = this.ownerConnectionAddress;
-        this.ownerConnectionAddress = ownerConnectionAddress;
-    }
-    private Connection connectAsOwner(Address address) {
-        Connection connection = null;
-        try {
-            logger.info("Trying to connect to " + address + " as owner member");
-            connection = connectionManager.getOrConnect(address, true);
-            client.onClusterConnect(connection);
-            fireConnectionEvent(LifecycleEvent.LifecycleState.CLIENT_CONNECTED);
-            connectionStrategy.onConnectToCluster();
-        } catch (Exception e) {
-            logger.warning("Exception during initial connection to " + address + ", exception " + e);
-            if (null != connection) {
-                connection.close("Could not connect to " + address + " as owner", e);
-            }
-            return null;
-        }
-        return connection;
-    }
-    void disconnectFromCluster(final ClientConnection connection) {
-        clusterConnectionExecutor.execute(new Runnable() {
-            @Override
-            public void run() {
-                Address endpoint = connection.getEndPoint();
-                if (endpoint == null || !endpoint.equals(ownerConnectionAddress)) {
-                    return;
-                }
-                setOwnerConnectionAddress(null);
-                connectionStrategy.onDisconnectFromCluster();
-                if (client.getLifecycleService().isRunning()) {
-                    fireConnectionEvent(LifecycleEvent.LifecycleState.CLIENT_DISCONNECTED);
-                }
-            }
-        });
-    }
-    private void fireConnectionEvent(final LifecycleEvent.LifecycleState state) {
-        final LifecycleServiceImpl lifecycleService = (LifecycleServiceImpl) client.getLifecycleService();
-        lifecycleService.fireLifecycleEvent(state);
-    }
-    private ExecutorService createSingleThreadExecutorService(HazelcastClientInstanceImpl client) {
-        ClassLoader classLoader = client.getClientConfig().getClassLoader();
-        SingleExecutorThreadFactory threadFactory = new SingleExecutorThreadFactory(classLoader, client.getName() + ".cluster-");
-        return Executors.newSingleThreadExecutor(threadFactory);
-    }
-    private void connectToClusterInternal() {
-        Set<Address> triedAddresses = new HashSet<Address>();
-        waitStrategy.reset();
-        do {
-            Collection<Address> addresses = getPossibleMemberAddresses();
-            for (Address address : addresses) {
-                if (!client.getLifecycleService().isRunning()) {
-                    throw new IllegalStateException("Giving up on retrying to connect to cluster since client is shutdown.");
-                }
-                triedAddresses.add(address);
-                if (connectAsOwner(address) != null) {
-                    return;
-                }
-            }
-            if (!client.getLifecycleService().isRunning()) {
-                throw new IllegalStateException("Client is being shutdown.");
-            }
-        } while (waitStrategy.sleep());
-        throw new IllegalStateException(
-                "Unable to connect to any address! The following addresses were tried: " + triedAddresses);
-    }
-    Future<Void> connectToClusterAsync() {
-        return clusterConnectionExecutor.submit(new Callable<Void>() {
-            @Override
-            public Void call() throws Exception {
-                try {
-                    connectToClusterInternal();
-                } catch (Exception e) {
-                    logger.warning("Could not connect to cluster, shutting down the client. " + e.getMessage());
-                    new Thread(new Runnable() {
-                        @Override
-                        public void run() {
-                            try {
-                                client.getLifecycleService().shutdown();
-                            } catch (Exception exception) {
-                                logger.severe("Exception during client shutdown ", exception);
-                            }
-                        }
-                    }, client.getName() + ".clientShutdown-").start();
-                    throw rethrow(e);
-                }
-                return null;
-            }
-        });
-    }
-    Collection<Address> getPossibleMemberAddresses() {
-        LinkedHashSet<Address> addresses = new LinkedHashSet<Address>();
-        Collection<Member> memberList = client.getClientClusterService().getMemberList();
-        for (Member member : memberList) {
-            addresses.add(member.getAddress());
-        }
-        if (shuffleMemberList) {
-            addresses = (LinkedHashSet<Address>) shuffle(addresses);
-        }
-        LinkedHashSet<Address> providerAddresses = new LinkedHashSet<Address>();
-        for (AddressProvider addressProvider : addressProviders) {
-            try {
-                providerAddresses.addAll(addressProvider.loadAddresses());
-            } catch (NullPointerException e) {
-                throw e;
-            } catch (Exception e) {
-                logger.warning("Exception from AddressProvider: " + addressProvider, e);
-            }
-        }
-        if (shuffleMemberList) {
-            providerAddresses = (LinkedHashSet<Address>) shuffle(providerAddresses);
-        }
-        addresses.addAll(providerAddresses);
-        if (previousOwnerConnectionAddress != null) {
-            /*
-             * Previous owner address is moved to last item in set so that client will not try to connect to same one immediately.
-             * It could be the case that address is removed because it is healthy(it not responding to heartbeat/pings)
-             * In that case, trying other addresses first to upgrade make more sense.
-             */
-            addresses.remove(previousOwnerConnectionAddress);
-            addresses.add(previousOwnerConnectionAddress);
-        }
-        return addresses;
-    }
-    private static <T> Set<T> shuffle(Set<T> set) {
-        List<T> shuffleMe = new ArrayList<T>(set);
-        Collections.shuffle(shuffleMe);
-        return new LinkedHashSet<T>(shuffleMe);
-    }
-    public void shutdown() {
-        ClientExecutionServiceImpl.shutdownExecutor("cluster", clusterConnectionExecutor, logger);
-    }
-    interface WaitStrategy {
-        void reset();
-        boolean sleep();
-    }
-    class DefaultWaitStrategy implements WaitStrategy {
-        private final int connectionAttemptPeriod;
-        private final int connectionAttemptLimit;
-        private int attempt;
-        DefaultWaitStrategy(int connectionAttemptPeriod, int connectionAttemptLimit) {
-            this.connectionAttemptPeriod = connectionAttemptPeriod;
-            this.connectionAttemptLimit = connectionAttemptLimit;
-        }
-        @Override
-        public void reset() {
-            attempt = 0;
-        }
-        @Override
-        public boolean sleep() {
-            attempt++;
-            if (attempt >= connectionAttemptLimit) {
-                logger.warning(String.format("Unable to get alive cluster connection, attempt %d of %d.", attempt,
-                        connectionAttemptLimit));
-                return false;
-            }
-            logger.warning(String.format("Unable to get alive cluster connection, try in %d ms later, attempt %d of %d.",
-                    connectionAttemptPeriod, attempt, connectionAttemptLimit));
-            try {
-                Thread.sleep(connectionAttemptPeriod);
-            } catch (InterruptedException e) {
-                Thread.currentThread().interrupt();
-                return false;
-            }
-            return true;
-        }
-    }
-    class ExponentialWaitStrategy implements WaitStrategy {
-        private final int initialBackoffMillis;
-        private final int maxBackoffMillis;
-        private final double multiplier;
-        private final boolean failOnMaxBackoff;
-        private final double jitter;
-        private final Random random = new Random();
-        private int attempt;
-        private int currentBackoffMillis;
-        ExponentialWaitStrategy(int initialBackoffMillis, int maxBackoffMillis,
-                                double multiplier, boolean failOnMaxBackoff, double jitter) {
-            this.initialBackoffMillis = initialBackoffMillis;
-            this.maxBackoffMillis = maxBackoffMillis;
-            this.multiplier = multiplier;
-            this.failOnMaxBackoff = failOnMaxBackoff;
-            this.jitter = jitter;
-        }
-        @Override
-        public void reset() {
-            attempt = 0;
-            currentBackoffMillis = Math.min(maxBackoffMillis, initialBackoffMillis);
-        }
-        @Override
-        public boolean sleep() {
-            attempt++;
-            if (failOnMaxBackoff && currentBackoffMillis >= maxBackoffMillis) {
-                logger.warning(String.format("Unable to get alive cluster connection, attempt %d.", attempt));
-                return false;
-            }
-            long actualSleepTime = (long) (currentBackoffMillis - (currentBackoffMillis * jitter)
-                    + (currentBackoffMillis * jitter * random.nextDouble()));
-            logger.warning(String.format("Unable to get alive cluster connection, try in %d ms later, attempt %d "
-                    + ", cap retry timeout millis %d", actualSleepTime, attempt, maxBackoffMillis));
-            try {
-                Thread.sleep(actualSleepTime);
-            } catch (InterruptedException e) {
-                Thread.currentThread().interrupt();
-                return false;
-            }
-            currentBackoffMillis = (int) Math.min(currentBackoffMillis * multiplier, maxBackoffMillis);
-            return true;
-        }
-    }
-}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/DefaultClientConnectionStrategy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/DefaultClientConnectionStrategy.java
@@ -11,20 +11,21 @@
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.connection.nio;
 import com.hazelcast.client.HazelcastClientOfflineException;
 import com.hazelcast.client.config.ClientConnectionStrategyConfig;
 import com.hazelcast.client.connection.ClientConnectionStrategy;
 import com.hazelcast.nio.Address;
+import com.hazelcast.spi.exception.TargetDisconnectedException;
 import java.util.concurrent.RejectedExecutionException;
 import static com.hazelcast.client.config.ClientConnectionStrategyConfig.ReconnectMode.ASYNC;
 import static com.hazelcast.client.config.ClientConnectionStrategyConfig.ReconnectMode.OFF;
 /**
  * Default client connection strategy supporting async client start, reconnection modes and disabling reconnection.
  */
 public class DefaultClientConnectionStrategy extends ClientConnectionStrategy {
     private volatile boolean disconnectedFromCluster;
     private boolean clientStartAsync;
     private ClientConnectionStrategyConfig.ReconnectMode reconnectMode;
@@ -53,23 +54,20 @@
     @Override
     public void beforeOpenConnection(Address target) {
         if (isClusterAvailable()) {
             return;
         }
         if (reconnectMode == ASYNC && disconnectedFromCluster) {
             throw new HazelcastClientOfflineException("Client is offline");
         }
     }
     @Override
-    public void beforeConnectToCluster(Address target) {
-    }
-    @Override
     public void onConnectToCluster() {
     }
     @Override
     public void onDisconnectFromCluster() {
         disconnectedFromCluster = true;
         if (reconnectMode == OFF) {
             shutdownWithExternalThread();
             return;
         }
         if (clientContext.getLifecycleService().isRunning()) {
@@ -92,16 +90,25 @@
             }
         }, clientContext.getName() + ".clientShutdown-").start();
     }
     @Override
     public void onConnect(ClientConnection connection) {
     }
     @Override
     public void onDisconnect(ClientConnection connection) {
     }
     @Override
+    public void onHeartbeatStopped(ClientConnection connection) {
+        if (connection.isAuthenticatedAsOwner()) {
+            connection.close(null, new TargetDisconnectedException("Heartbeat timed out to owner connection " + connection));
+        }
+    }
+    @Override
+    public void onHeartbeatResumed(ClientConnection connection) {
+    }
+    @Override
     public void shutdown() {
     }
     private boolean isClusterAvailable() {
         return clientContext.getConnectionManager().getOwnerConnectionAddress() != null;
     }
 }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/DefaultCredentialsFactory.java
+++ b//dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.hazelcast.client.connection.nio;
-import com.hazelcast.client.config.ClientSecurityConfig;
-import com.hazelcast.config.GroupConfig;
-import com.hazelcast.nio.ClassLoaderUtil;
-import com.hazelcast.security.Credentials;
-import com.hazelcast.security.ICredentialsFactory;
-import com.hazelcast.security.UsernamePasswordCredentials;
-import java.util.Properties;
-import static com.hazelcast.util.ExceptionUtil.rethrow;
-/**
- * This is the factory that uses Credentials instance giving by either class name or implementation
- * instead of factory given bey user.
- */
-public class DefaultCredentialsFactory implements ICredentialsFactory {
-    private final Credentials credentials;
-    public DefaultCredentialsFactory(ClientSecurityConfig securityConfig, GroupConfig groupConfig,
-                                     ClassLoader classLoader) {
-        credentials = initCredentials(securityConfig, groupConfig, classLoader);
-    }
-    private Credentials initCredentials(ClientSecurityConfig securityConfig, GroupConfig groupConfig, ClassLoader classLoader) {
-        Credentials credentials = securityConfig.getCredentials();
-        if (credentials == null) {
-            String credentialsClassname = securityConfig.getCredentialsClassname();
-            if (credentialsClassname != null) {
-                try {
-                    credentials = ClassLoaderUtil.newInstance(classLoader, credentialsClassname);
-                } catch (Exception e) {
-                    throw rethrow(e);
-                }
-            }
-        }
-        if (credentials == null) {
-            credentials = new UsernamePasswordCredentials(groupConfig.getName(), groupConfig.getPassword());
-        }
-        return credentials;
-    }
-    @Override
-    public void configure(GroupConfig groupConfig, Properties properties) {
-    }
-    @Override
-    public Credentials newCredentials() {
-        return credentials;
-    }
-    @Override
-    public void destroy() {
-    }
-}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/HeartbeatManager.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/HeartbeatManager.java
@@ -8,48 +8,54 @@
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.connection.nio;
 import com.hazelcast.client.config.ClientIcmpPingConfig;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.ClientPingCodec;
 import com.hazelcast.client.spi.impl.ClientExecutionServiceImpl;
 import com.hazelcast.client.spi.impl.ClientInvocation;
+import com.hazelcast.client.spi.impl.ConnectionHeartbeatListener;
+import com.hazelcast.core.ExecutionCallback;
 import com.hazelcast.logging.ILogger;
-import com.hazelcast.spi.exception.TargetDisconnectedException;
 import com.hazelcast.spi.properties.HazelcastProperties;
 import com.hazelcast.util.Clock;
+import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
 import java.util.concurrent.TimeUnit;
 import static com.hazelcast.client.spi.properties.ClientProperty.HEARTBEAT_INTERVAL;
 import static com.hazelcast.client.spi.properties.ClientProperty.HEARTBEAT_TIMEOUT;
 /**
  * HeartbeatManager manager used by connection manager.
  */
 public class HeartbeatManager implements Runnable {
     private final ClientConnectionManagerImpl clientConnectionManager;
     private final HazelcastClientInstanceImpl client;
     private final ILogger logger;
     private final long heartbeatInterval;
     private final long heartbeatTimeout;
     private final ClientICMPManager clientICMPManager;
+    private final Set<ConnectionHeartbeatListener> heartbeatListeners = new CopyOnWriteArraySet<ConnectionHeartbeatListener>();
     HeartbeatManager(ClientConnectionManagerImpl clientConnectionManager, HazelcastClientInstanceImpl client) {
         this.clientConnectionManager = clientConnectionManager;
         this.client = client;
         HazelcastProperties hazelcastProperties = client.getProperties();
-        this.heartbeatTimeout = hazelcastProperties.getPositiveMillisOrDefault(HEARTBEAT_TIMEOUT);
-        this.heartbeatInterval = hazelcastProperties.getPositiveMillisOrDefault(HEARTBEAT_INTERVAL);
+        long timeout = hazelcastProperties.getMillis(HEARTBEAT_TIMEOUT);
+        this.heartbeatTimeout = timeout > 0 ? timeout : Integer.parseInt(HEARTBEAT_TIMEOUT.getDefaultValue());
+        long interval = hazelcastProperties.getMillis(HEARTBEAT_INTERVAL);
+        this.heartbeatInterval = interval > 0 ? interval : Integer.parseInt(HEARTBEAT_INTERVAL.getDefaultValue());
         this.logger = client.getLoggingService().getLogger(HeartbeatManager.class);
         ClientIcmpPingConfig icmpPingConfig = client.getClientConfig().getNetworkConfig().getClientIcmpPingConfig();
         this.clientICMPManager = new ClientICMPManager(icmpPingConfig,
                 (ClientExecutionServiceImpl) client.getClientExecutionService(),
                 client.getLoggingService(), clientConnectionManager, this);
     }
     public void start() {
         final ClientExecutionServiceImpl es = (ClientExecutionServiceImpl) client.getClientExecutionService();
         es.scheduleWithRepetition(this, heartbeatInterval, heartbeatInterval, TimeUnit.MILLISECONDS);
         clientICMPManager.start();
@@ -65,28 +71,61 @@
         long now = Clock.currentTimeMillis();
         for (final ClientConnection connection : clientConnectionManager.getActiveConnections()) {
             checkConnection(now, connection);
         }
     }
     private void checkConnection(long now, final ClientConnection connection) {
         if (!connection.isAlive()) {
             return;
         }
         if (now - connection.lastReadTimeMillis() > heartbeatTimeout) {
-            if (connection.isAlive()) {
+            if (connection.isHeartBeating()) {
                 logger.warning("Heartbeat failed over the connection: " + connection);
-                onHeartbeatStopped(connection, "Heartbeat timed out");
+                connection.onHeartbeatFailed();
+                fireHeartbeatStopped(connection);
+            }
+        } else {
+            if (!connection.isHeartBeating()) {
+                logger.warning("Heartbeat is back to healthy for the connection: " + connection);
+                connection.onHeartbeatResumed();
+                fireHeartbeatResumed(connection);
             }
         }
         if (now - connection.lastWriteTimeMillis() > heartbeatInterval) {
             ClientMessage request = ClientPingCodec.encodeRequest();
-            ClientInvocation clientInvocation = new ClientInvocation(client, request, null, connection);
-            clientInvocation.invokeUrgent();
+            final ClientInvocation clientInvocation = new ClientInvocation(client, request, null, connection);
+            clientInvocation.setBypassHeartbeatCheck(true);
+            connection.onHeartbeatRequested();
+            clientInvocation.invokeUrgent().andThen(new ExecutionCallback<ClientMessage>() {
+                @Override
+                public void onResponse(ClientMessage response) {
+                    if (connection.isAlive()) {
+                        connection.onHeartbeatReceived();
+                    }
+                }
+                @Override
+                public void onFailure(Throwable t) {
+                    if (connection.isAlive()) {
+                        logger.warning("Error receiving ping answer from the connection: " + connection, t);
+                    }
+                }
+            });
         }
     }
-    void onHeartbeatStopped(ClientConnection connection, String reason) {
-        connection.close(reason, new TargetDisconnectedException("Heartbeat timed out to connection " + connection));
+    private void fireHeartbeatResumed(ClientConnection connection) {
+        for (ConnectionHeartbeatListener heartbeatListener : heartbeatListeners) {
+            heartbeatListener.heartbeatResumed(connection);
+        }
+    }
+    void fireHeartbeatStopped(ClientConnection connection) {
+        for (ConnectionHeartbeatListener heartbeatListener : heartbeatListeners) {
+            heartbeatListener.heartbeatStopped(connection);
+        }
+    }
+    public void addConnectionHeartbeatListener(ConnectionHeartbeatListener connectionHeartbeatListener) {
+        heartbeatListeners.add(connectionHeartbeatListener);
     }
     public void shutdown() {
+        heartbeatListeners.clear();
         clientICMPManager.shutdown();
     }
 }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/console/ClientConsoleApp.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/console/ClientConsoleApp.java
@@ -33,21 +33,20 @@
 import com.hazelcast.core.ITopic;
 import com.hazelcast.core.ItemEvent;
 import com.hazelcast.core.ItemListener;
 import com.hazelcast.core.MapEvent;
 import com.hazelcast.core.Member;
 import com.hazelcast.core.Message;
 import com.hazelcast.core.MessageListener;
 import com.hazelcast.core.MultiMap;
 import com.hazelcast.core.Partition;
 import com.hazelcast.internal.util.RuntimeAvailableProcessors;
-import com.hazelcast.nio.IOUtil;
 import com.hazelcast.util.Clock;
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.lang.management.ManagementFactory;
 import java.nio.charset.Charset;
 import java.util.Collection;
@@ -64,21 +63,20 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.Lock;
 import static com.hazelcast.util.StringUtil.lowerCaseInternal;
 import static java.lang.String.format;
 import static java.lang.Thread.currentThread;
 /**
  * A demo application to demonstrate a Hazelcast client. This is probably NOT something you want to use in production.
  */
-@SuppressWarnings({"WeakerAccess", "unused"})
 public class ClientConsoleApp implements EntryListener, ItemListener, MessageListener {
     private static final int ONE_KB = 1024;
     private static final int ONE_THOUSAND = 1000;
     private static final int ONE_HUNDRED = 100;
     private static final int ONE_HOUR = 3600;
     private static final int MAX_THREAD_COUNT = 16;
     private static final int HUNDRED_CONSTANT = 100;
     private static final int BYTE_TO_BIT = 8;
     private static final int LENGTH_BORDER = 4;
     private IQueue<Object> queue;
@@ -130,21 +128,21 @@
         this.hazelcast = hazelcast;
         map = null;
         list = null;
         set = null;
         queue = null;
         topic = null;
     }
     public void stop() {
         running = false;
     }
-    public void start(String[] args) {
+    public void start(String[] args) throws Exception {
         getMap().size();
         getList().size();
         getSet().size();
         getQueue().size();
         getMultiMap().size();
         if (lineReader == null) {
             lineReader = new DefaultLineReader();
         }
         running = true;
         while (running) {
@@ -160,41 +158,42 @@
     /**
      * A line reader
      */
     static class DefaultLineReader implements LineReader {
         BufferedReader in = new BufferedReader(new InputStreamReader(System.in, Charset.forName("UTF-8")));
         public String readLine() throws Exception {
             return in.readLine();
         }
     }
     /**
-     * Handle a command.
+     * Handle a command
+     *
+     * @param commandInputted
      */
     @SuppressFBWarnings("DM_EXIT")
-    @SuppressWarnings({"checkstyle:methodlength", "checkstyle:cyclomaticcomplexity", "checkstyle:npathcomplexity"})
     protected void handleCommand(String commandInputted) {
         String command = commandInputted;
         if (command == null) {
             return;
         }
         if (command.contains("__")) {
             namespace = command.split("__")[0];
             command = command.substring(command.indexOf("__") + 2);
         }
         if (echo) {
             handleEcho(command);
         }
-        if (command.startsWith("//")) {
+        if (command == null || command.startsWith("//")) {
             return;
         }
         command = command.trim();
-        if (command.length() == 0) {
+        if (command == null || command.length() == 0) {
             return;
         }
         String first = command;
         int spaceIndex = command.indexOf(' ');
         String[] argsSplit = command.split(" ");
         String[] args = new String[argsSplit.length];
         for (int i = 0; i < argsSplit.length; i++) {
             args[i] = argsSplit[i].trim();
         }
         if (spaceIndex != -1) {
@@ -211,22 +210,24 @@
             println("ops/s = " + repeat * ONE_THOUSAND / (Clock.currentTimeMillis() - t0));
         } else if (first.startsWith("&") && first.length() > 1) {
             final int fork = Integer.parseInt(first.substring(1));
             ExecutorService pool = Executors.newFixedThreadPool(fork);
             final String threadCommand = command.substring(first.length());
             for (int i = 0; i < fork; i++) {
                 final int threadID = i;
                 pool.submit(new Runnable() {
                     public void run() {
                         String command = threadCommand;
-                        String[] threadArgs = command.replaceAll("\\$t", "" + threadID).trim().split(" ");
-                        if ("m.putmany".equals(threadArgs[0]) || "m.removemany".equals(threadArgs[0])) {
+                        String[] threadArgs = command.replaceAll("\\$t", "" + threadID).trim()
+                                .split(" ");
+                        if ("m.putmany".equals(threadArgs[0])
+                                || "m.removemany".equals(threadArgs[0])) {
                             if (threadArgs.length < LENGTH_BORDER) {
                                 command += " " + Integer.parseInt(threadArgs[1]) * threadID;
                             }
                         }
                         handleCommand(command);
                     }
                 });
             }
             pool.shutdown();
             try {
@@ -330,20 +331,22 @@
         } else if (first.equals("m.lock")) {
             handleMapLock(args);
         } else if (first.equalsIgnoreCase("m.tryLock")) {
             handleMapTryLock(args);
         } else if (first.equals("m.unlock")) {
             handleMapUnlock(args);
         } else if (first.contains(".addListener")) {
             handleAddListener(args);
         } else if (first.equals("m.removeMapListener")) {
             handleRemoveListener(args);
+        } else if (first.equals("m.unlock")) {
+            handleMapUnlock(args);
         } else if (first.equals("mm.put")) {
             handleMultiMapPut(args);
         } else if (first.equals("mm.get")) {
             handleMultiMapGet(args);
         } else if (first.equals("mm.remove")) {
             handleMultiMapRemove(args);
         } else if (command.equals("mm.keys")) {
             handleMultiMapKeys();
         } else if (command.equals("mm.values")) {
             handleMultiMapValues();
@@ -437,32 +440,30 @@
     }
     @SuppressFBWarnings("DM_DEFAULT_ENCODING")
     private void handleAt(String first) {
         if (first.length() == 1) {
             println("usage: @<file-name>");
             return;
         }
         File f = new File(first.substring(1));
         println("Executing script file " + f.getAbsolutePath());
         if (f.exists()) {
-            BufferedReader br = null;
             try {
-                br = new BufferedReader(new FileReader(f));
+                BufferedReader br = new BufferedReader(new FileReader(f));
                 String l = br.readLine();
                 while (l != null) {
                     handleCommand(l);
                     l = br.readLine();
                 }
+                br.close();
             } catch (IOException e) {
                 e.printStackTrace();
-            } finally {
-                IOUtil.closeResource(br);
             }
         } else {
             println("File not found! " + f.getAbsolutePath());
         }
     }
     private void handleEcho(String command) {
         String threadName = lowerCaseInternal(Thread.currentThread().getName());
         if (!threadName.contains("main")) {
             println(" [" + Thread.currentThread().getName() + "] " + command);
         } else {
@@ -550,29 +551,30 @@
     protected void handleInstances(String[] args) {
         Collection<DistributedObject> distributedObjects = hazelcast.getDistributedObjects();
         for (DistributedObject distributedObject : distributedObjects) {
             println(distributedObject);
         }
     }
     protected void handleListContains(String[] args) {
         println(getList().contains(args[1]));
     }
     protected void handleListRemove(String[] args) {
+        int index = -1;
         try {
-            int index = Integer.parseInt(args[1]);
-            if (index >= 0) {
-                println(getList().remove(index));
-            } else {
-                println(getList().remove(args[1]));
-            }
+            index = Integer.parseInt(args[1]);
         } catch (NumberFormatException e) {
             throw new RuntimeException(e);
+        }
+        if (index >= 0) {
+            println(getList().remove(index));
+        } else {
+            println(getList().remove(args[1]));
         }
     }
     protected void handleListAdd(String[] args) {
         if (args.length == 3) {
             final int index = Integer.parseInt(args[1]);
             getList().add(index, args[2]);
             println("true");
         } else {
             println(getList().add(args[1]));
         }
@@ -652,21 +654,21 @@
         int b = ONE_HUNDRED;
         byte[] value = new byte[b];
         if (args.length > 2) {
             b = Integer.parseInt(args[2]);
             value = new byte[b];
         }
         int start = getMap().size();
         if (args.length > 3) {
             start = Integer.parseInt(args[3]);
         }
-        Map<String, byte[]> theMap = new HashMap<String, byte[]>(count);
+        Map theMap = new HashMap(count);
         for (int i = 0; i < count; i++) {
             theMap.put("key" + (start + i), value);
         }
         long t0 = Clock.currentTimeMillis();
         getMap().putAll(theMap);
         long t1 = Clock.currentTimeMillis();
         if (t1 - t0 > 1) {
             println("size = " + getMap().size() + ", " + count * ONE_THOUSAND / (t1 - t0)
                     + " evt/s, " + (count * ONE_THOUSAND / (t1 - t0)) * (b * BYTE_TO_BIT) / ONE_KB + " Kbit/s, "
                     + count * b / ONE_KB + " KB added");
@@ -832,21 +834,21 @@
     private void handStats(String[] args) {
         String iteratorStr = args[0];
         if (iteratorStr.startsWith("m.")) {
             println(getMap().getLocalMapStats());
         } else if (iteratorStr.startsWith("mm.")) {
             println(getMultiMap().getLocalMultiMapStats());
         } else if (iteratorStr.startsWith("q.")) {
             println(getQueue().getLocalQueueStats());
         }
     }
-    @SuppressWarnings({"LockAcquiredButNotSafelyReleased", "squid:S2222"})
+    @SuppressWarnings("LockAcquiredButNotSafelyReleased")
     protected void handleLock(String[] args) {
         String lockStr = args[0];
         String key = args[1];
         Lock lock = hazelcast.getLock(key);
         if (lockStr.equalsIgnoreCase("lock")) {
             lock.lock();
             println("true");
         } else if (lockStr.equalsIgnoreCase("unlock")) {
             lock.unlock();
             println("true");
@@ -1126,21 +1128,21 @@
     private void doExecute(boolean onKey, boolean onMember, String[] args) {
         try {
             IExecutorService executorService = hazelcast.getExecutorService("default");
             Echo callable = new Echo(args[1]);
             Future<String> future;
             if (onKey) {
                 String key = args[2];
                 future = executorService.submitToKeyOwner(callable, key);
             } else if (onMember) {
                 int memberIndex = Integer.parseInt(args[2]);
-                List<Member> members = new LinkedList<Member>(hazelcast.getCluster().getMembers());
+                List<Member> members = new LinkedList(hazelcast.getCluster().getMembers());
                 if (memberIndex >= members.size()) {
                     throw new IndexOutOfBoundsException("Member index: " + memberIndex + " must be smaller than " + members
                             .size());
                 }
                 Member member = members.get(memberIndex);
                 future = executorService.submitToMember(callable, member);
             } else {
                 future = executorService.submit(callable);
             }
             println("Result: " + future.get());
@@ -1196,21 +1198,23 @@
     }
     @Override
     public void itemRemoved(ItemEvent itemEvent) {
         println("Item removed = " + itemEvent.getItem());
     }
     @Override
     public void onMessage(Message msg) {
         println("Topic received = " + msg.getMessageObject());
     }
     /**
-     * Handles the help command.
+     * Handled the help command
+     *
+     * @param command
      */
     protected void handleHelp(String command) {
         boolean silentBefore = silent;
         silent = false;
         println("Commands:");
         printGeneralCommands();
         printQueueCommands();
         printSetCommands();
         printLockCommands();
         printMapCommands();
@@ -1352,22 +1356,25 @@
         }
     }
     public void print(Object obj) {
         if (!silent) {
             System.out.print(obj);
         }
     }
     /**
      * Starts the test application. Loads the config from classpath hazelcast.xml,
      * if it fails to load, will use default config.
+     *
+     * @param args none
+     * @throws Exception
      */
-    public static void main(String[] args) {
+    public static void main(String[] args) throws Exception {
         ClientConfig clientConfig;
         try {
             clientConfig = new XmlClientConfigBuilder().build();
         } catch (IllegalArgumentException e) {
             clientConfig = new ClientConfig();
         }
         final HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);
         ClientConsoleApp clientConsoleApp = new ClientConsoleApp(client);
         clientConsoleApp.start(args);
     }

--- a//dev/null
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/impl/DefaultClientConnectionManagerFactory.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.hazelcast.client.impl;
+import com.hazelcast.client.connection.AddressProvider;
+import com.hazelcast.client.connection.AddressTranslator;
+import com.hazelcast.client.connection.ClientConnectionManager;
+import com.hazelcast.client.connection.nio.ClientConnectionManagerImpl;
+import java.util.Collection;
+public class DefaultClientConnectionManagerFactory implements ClientConnectionManagerFactory {
+    public DefaultClientConnectionManagerFactory() {
+    }
+    @Override
+    public ClientConnectionManager createConnectionManager(HazelcastClientInstanceImpl client,
+                                                           AddressTranslator addressTranslator,
+                                                           Collection<AddressProvider> addressProviders) {
+        return new ClientConnectionManagerImpl(client, addressTranslator, addressProviders);
+    }
+}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/ClientConnectionManagerFactory.java
+++ b//dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.hazelcast.client.impl.clientside;
-import com.hazelcast.client.connection.AddressProvider;
-import com.hazelcast.client.connection.AddressTranslator;
-import com.hazelcast.client.connection.ClientConnectionManager;
-import java.util.Collection;
-public interface ClientConnectionManagerFactory {
-    ClientConnectionManager createConnectionManager(HazelcastClientInstanceImpl client,
-                                                    AddressTranslator addressTranslator,
-                                                    Collection<AddressProvider> addressProviders);
-}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/ClientDynamicClusterConfig.java
+++ b//dev/null
@@ -1,1054 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.hazelcast.client.impl.clientside;
-import com.hazelcast.client.impl.protocol.ClientMessage;
-import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddAtomicLongConfigCodec;
-import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddAtomicReferenceConfigCodec;
-import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddCacheConfigCodec;
-import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddCardinalityEstimatorConfigCodec;
-import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddCountDownLatchConfigCodec;
-import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddDurableExecutorConfigCodec;
-import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddEventJournalConfigCodec;
-import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddExecutorConfigCodec;
-import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddFlakeIdGeneratorConfigCodec;
-import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddListConfigCodec;
-import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddLockConfigCodec;
-import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddMapConfigCodec;
-import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddMerkleTreeConfigCodec;
-import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddMultiMapConfigCodec;
-import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddPNCounterConfigCodec;
-import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddQueueConfigCodec;
-import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddReliableTopicConfigCodec;
-import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddReplicatedMapConfigCodec;
-import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddRingbufferConfigCodec;
-import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddScheduledExecutorConfigCodec;
-import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddSemaphoreConfigCodec;
-import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddSetConfigCodec;
-import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddTopicConfigCodec;
-import com.hazelcast.client.impl.protocol.task.dynamicconfig.EvictionConfigHolder;
-import com.hazelcast.client.impl.protocol.task.dynamicconfig.ListenerConfigHolder;
-import com.hazelcast.client.impl.protocol.task.dynamicconfig.MapStoreConfigHolder;
-import com.hazelcast.client.impl.protocol.task.dynamicconfig.NearCacheConfigHolder;
-import com.hazelcast.client.impl.protocol.task.dynamicconfig.QueryCacheConfigHolder;
-import com.hazelcast.client.impl.protocol.task.dynamicconfig.QueueStoreConfigHolder;
-import com.hazelcast.client.impl.protocol.task.dynamicconfig.RingbufferStoreConfigHolder;
-import com.hazelcast.client.spi.impl.ClientInvocation;
-import com.hazelcast.client.spi.impl.ClientInvocationFuture;
-import com.hazelcast.config.AtomicLongConfig;
-import com.hazelcast.config.AtomicReferenceConfig;
-import com.hazelcast.config.CRDTReplicationConfig;
-import com.hazelcast.config.CacheSimpleConfig;
-import com.hazelcast.config.CardinalityEstimatorConfig;
-import com.hazelcast.config.Config;
-import com.hazelcast.config.ConfigPatternMatcher;
-import com.hazelcast.config.CountDownLatchConfig;
-import com.hazelcast.config.DurableExecutorConfig;
-import com.hazelcast.config.EventJournalConfig;
-import com.hazelcast.config.ExecutorConfig;
-import com.hazelcast.config.FlakeIdGeneratorConfig;
-import com.hazelcast.config.GroupConfig;
-import com.hazelcast.config.HotRestartPersistenceConfig;
-import com.hazelcast.config.JobTrackerConfig;
-import com.hazelcast.config.ListConfig;
-import com.hazelcast.config.ListenerConfig;
-import com.hazelcast.config.LockConfig;
-import com.hazelcast.config.ManagementCenterConfig;
-import com.hazelcast.config.MapConfig;
-import com.hazelcast.config.MemberAttributeConfig;
-import com.hazelcast.config.MerkleTreeConfig;
-import com.hazelcast.config.MultiMapConfig;
-import com.hazelcast.config.NativeMemoryConfig;
-import com.hazelcast.config.NetworkConfig;
-import com.hazelcast.config.PNCounterConfig;
-import com.hazelcast.config.PartitionGroupConfig;
-import com.hazelcast.config.QueryCacheConfig;
-import com.hazelcast.config.QueueConfig;
-import com.hazelcast.config.QuorumConfig;
-import com.hazelcast.config.ReliableTopicConfig;
-import com.hazelcast.config.ReplicatedMapConfig;
-import com.hazelcast.config.RingbufferConfig;
-import com.hazelcast.config.RingbufferStoreConfig;
-import com.hazelcast.config.ScheduledExecutorConfig;
-import com.hazelcast.config.SecurityConfig;
-import com.hazelcast.config.SemaphoreConfig;
-import com.hazelcast.config.SerializationConfig;
-import com.hazelcast.config.ServicesConfig;
-import com.hazelcast.config.SetConfig;
-import com.hazelcast.config.TopicConfig;
-import com.hazelcast.config.UserCodeDeploymentConfig;
-import com.hazelcast.config.WanReplicationConfig;
-import com.hazelcast.core.ManagedContext;
-import com.hazelcast.nio.serialization.Data;
-import com.hazelcast.spi.serialization.SerializationService;
-import com.hazelcast.util.Preconditions;
-import com.hazelcast.util.StringUtil;
-import java.io.File;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-import java.util.concurrent.ConcurrentMap;
-import static com.hazelcast.util.ExceptionUtil.rethrow;
-/**
- * Client implementation of member side config. Clients use this to submit new data structure configurations into
- * a live Hazelcast cluster.
- */
-@SuppressWarnings({"checkstyle:methodcount", "checkstyle:classfanoutcomplexity"})
-public class ClientDynamicClusterConfig extends Config {
-    private static final String UNSUPPORTED_ERROR_MESSAGE =
-            "Client config object only supports adding new data structure configurations";
-    private final HazelcastClientInstanceImpl instance;
-    private final SerializationService serializationService;
-    public ClientDynamicClusterConfig(HazelcastClientInstanceImpl instance) {
-        this.instance = instance;
-        this.serializationService = instance.getSerializationService();
-    }
-    @Override
-    public Config addMapConfig(MapConfig mapConfig) {
-        List<ListenerConfigHolder> listenerConfigs = adaptListenerConfigs(mapConfig.getEntryListenerConfigs());
-        List<ListenerConfigHolder> partitionLostListenerConfigs =
-                adaptListenerConfigs(mapConfig.getPartitionLostListenerConfigs());
-        List<QueryCacheConfigHolder> queryCacheConfigHolders = null;
-        if (mapConfig.getQueryCacheConfigs() != null && !mapConfig.getQueryCacheConfigs().isEmpty()) {
-            queryCacheConfigHolders = new ArrayList<QueryCacheConfigHolder>(mapConfig.getQueryCacheConfigs().size());
-            for (QueryCacheConfig config : mapConfig.getQueryCacheConfigs()) {
-                queryCacheConfigHolders.add(QueryCacheConfigHolder.of(config, serializationService));
-            }
-        }
-        String partitioningStrategyClassName = mapConfig.getPartitioningStrategyConfig() == null
-                ? null : mapConfig.getPartitioningStrategyConfig().getPartitioningStrategyClass();
-        Data partitioningStrategy = mapConfig.getPartitioningStrategyConfig() == null
-                ? null : serializationService.toData(mapConfig.getPartitioningStrategyConfig().getPartitioningStrategy());
-        ClientMessage request = DynamicConfigAddMapConfigCodec.encodeRequest(mapConfig.getName(),
-                mapConfig.getBackupCount(), mapConfig.getAsyncBackupCount(), mapConfig.getTimeToLiveSeconds(),
-                mapConfig.getMaxIdleSeconds(), mapConfig.getEvictionPolicy().name(), mapConfig.isReadBackupData(),
-                mapConfig.getCacheDeserializedValues().name(), mapConfig.getMergePolicy(), mapConfig.getInMemoryFormat().name(),
-                listenerConfigs, partitionLostListenerConfigs, mapConfig.isStatisticsEnabled(), mapConfig.getQuorumName(),
-                serializationService.toData(mapConfig.getMapEvictionPolicy()),
-                mapConfig.getMaxSizeConfig().getMaxSizePolicy().name(), mapConfig.getMaxSizeConfig().getSize(),
-                MapStoreConfigHolder.of(mapConfig.getMapStoreConfig(), serializationService),
-                NearCacheConfigHolder.of(mapConfig.getNearCacheConfig(), serializationService),
-                mapConfig.getWanReplicationRef(), mapConfig.getMapIndexConfigs(), mapConfig.getMapAttributeConfigs(),
-                queryCacheConfigHolders, partitioningStrategyClassName, partitioningStrategy, mapConfig.getHotRestartConfig(),
-                mapConfig.getMergePolicyConfig().getBatchSize());
-        invoke(request);
-        return this;
-    }
-    @Override
-    public Config addCacheConfig(CacheSimpleConfig cacheConfig) {
-        List<ListenerConfigHolder> partitionLostListenerConfigs =
-                adaptListenerConfigs(cacheConfig.getPartitionLostListenerConfigs());
-        ClientMessage request = DynamicConfigAddCacheConfigCodec.encodeRequest(cacheConfig.getName(), cacheConfig.getKeyType(),
-                cacheConfig.getValueType(), cacheConfig.isStatisticsEnabled(), cacheConfig.isManagementEnabled(),
-                cacheConfig.isReadThrough(), cacheConfig.isWriteThrough(), cacheConfig.getCacheLoaderFactory(),
-                cacheConfig.getCacheWriterFactory(), cacheConfig.getCacheLoader(), cacheConfig.getCacheWriter(),
-                cacheConfig.getBackupCount(), cacheConfig.getAsyncBackupCount(), cacheConfig.getInMemoryFormat().name(),
-                cacheConfig.getQuorumName(), cacheConfig.getMergePolicy(), cacheConfig.isDisablePerEntryInvalidationEvents(),
-                partitionLostListenerConfigs,
-                cacheConfig.getExpiryPolicyFactoryConfig() == null ? null
-                        : cacheConfig.getExpiryPolicyFactoryConfig().getClassName(),
-                cacheConfig.getExpiryPolicyFactoryConfig() == null ? null
-                        : cacheConfig.getExpiryPolicyFactoryConfig().getTimedExpiryPolicyFactoryConfig(),
-                cacheConfig.getCacheEntryListeners(),
-                EvictionConfigHolder.of(cacheConfig.getEvictionConfig(), serializationService),
-                cacheConfig.getWanReplicationRef(), cacheConfig.getHotRestartConfig());
-        invoke(request);
-        return this;
-    }
-    @Override
-    public Config addQueueConfig(QueueConfig queueConfig) {
-        List<ListenerConfigHolder> listenerConfigs = adaptListenerConfigs(queueConfig.getItemListenerConfigs());
-        QueueStoreConfigHolder queueStoreConfigHolder = QueueStoreConfigHolder.of(queueConfig.getQueueStoreConfig(),
-                serializationService);
-        ClientMessage request = DynamicConfigAddQueueConfigCodec.encodeRequest(queueConfig.getName(), listenerConfigs,
-                queueConfig.getBackupCount(), queueConfig.getAsyncBackupCount(), queueConfig.getMaxSize(),
-                queueConfig.getEmptyQueueTtl(), queueConfig.isStatisticsEnabled(), queueConfig.getQuorumName(),
-                queueStoreConfigHolder, queueConfig.getMergePolicyConfig().getPolicy(),
-                queueConfig.getMergePolicyConfig().getBatchSize());
-        invoke(request);
-        return this;
-    }
-    @Override
-    public Config addLockConfig(LockConfig lockConfig) {
-        ClientMessage request = DynamicConfigAddLockConfigCodec.encodeRequest(lockConfig.getName(), lockConfig.getQuorumName());
-        invoke(request);
-        return this;
-    }
-    @Override
-    public Config addListConfig(ListConfig listConfig) {
-        List<ListenerConfigHolder> listenerConfigs = adaptListenerConfigs(listConfig.getItemListenerConfigs());
-        ClientMessage request = DynamicConfigAddListConfigCodec.encodeRequest(listConfig.getName(), listenerConfigs,
-                listConfig.getBackupCount(), listConfig.getAsyncBackupCount(), listConfig.getMaxSize(),
-                listConfig.isStatisticsEnabled(), listConfig.getQuorumName(), listConfig.getMergePolicyConfig().getPolicy(),
-                listConfig.getMergePolicyConfig().getBatchSize());
-        invoke(request);
-        return this;
-    }
-    @Override
-    public Config addSetConfig(SetConfig setConfig) {
-        List<ListenerConfigHolder> listenerConfigs = adaptListenerConfigs(setConfig.getItemListenerConfigs());
-        ClientMessage request = DynamicConfigAddSetConfigCodec.encodeRequest(setConfig.getName(), listenerConfigs,
-                setConfig.getBackupCount(), setConfig.getAsyncBackupCount(), setConfig.getMaxSize(),
-                setConfig.isStatisticsEnabled(), setConfig.getQuorumName(), setConfig.getMergePolicyConfig().getPolicy(),
-                setConfig.getMergePolicyConfig().getBatchSize());
-        invoke(request);
-        return this;
-    }
-    @Override
-    public Config addMultiMapConfig(MultiMapConfig multiMapConfig) {
-        List<ListenerConfigHolder> listenerConfigHolders = adaptListenerConfigs(multiMapConfig.getEntryListenerConfigs());
-        ClientMessage request = DynamicConfigAddMultiMapConfigCodec.encodeRequest(
-                multiMapConfig.getName(), multiMapConfig.getValueCollectionType().toString(),
-                listenerConfigHolders,
-                multiMapConfig.isBinary(), multiMapConfig.getBackupCount(), multiMapConfig.getAsyncBackupCount(),
-                multiMapConfig.isStatisticsEnabled(), multiMapConfig.getQuorumName(),
-                multiMapConfig.getMergePolicyConfig().getPolicy(), multiMapConfig.getMergePolicyConfig().getBatchSize());
-        invoke(request);
-        return this;
-    }
-    @Override
-    public Config addReplicatedMapConfig(ReplicatedMapConfig replicatedMapConfig) {
-        List<ListenerConfigHolder> listenerConfigHolders = adaptListenerConfigs(replicatedMapConfig.getListenerConfigs());
-        ClientMessage request = DynamicConfigAddReplicatedMapConfigCodec.encodeRequest(
-                replicatedMapConfig.getName(), replicatedMapConfig.getInMemoryFormat().name(),
-                replicatedMapConfig.isAsyncFillup(), replicatedMapConfig.isStatisticsEnabled(),
-                replicatedMapConfig.getMergePolicyConfig().getPolicy(),
-                listenerConfigHolders, replicatedMapConfig.getQuorumName(),
-                replicatedMapConfig.getMergePolicyConfig().getBatchSize());
-        invoke(request);
-        return this;
-    }
-    @Override
-    public Config addRingBufferConfig(RingbufferConfig ringbufferConfig) {
-        RingbufferStoreConfigHolder ringbufferStoreConfig = null;
-        if (ringbufferConfig.getRingbufferStoreConfig() != null
-                && ringbufferConfig.getRingbufferStoreConfig().isEnabled()) {
-            RingbufferStoreConfig storeConfig = ringbufferConfig.getRingbufferStoreConfig();
-            ringbufferStoreConfig = RingbufferStoreConfigHolder.of(storeConfig, instance.getSerializationService());
-        }
-        ClientMessage request = DynamicConfigAddRingbufferConfigCodec.encodeRequest(
-                ringbufferConfig.getName(), ringbufferConfig.getCapacity(), ringbufferConfig.getBackupCount(),
-                ringbufferConfig.getAsyncBackupCount(), ringbufferConfig.getTimeToLiveSeconds(),
-                ringbufferConfig.getInMemoryFormat().name(), ringbufferStoreConfig, ringbufferConfig.getQuorumName(),
-                ringbufferConfig.getMergePolicyConfig().getPolicy(), ringbufferConfig.getMergePolicyConfig().getBatchSize());
-        invoke(request);
-        return this;
-    }
-    @Override
-    public Config addTopicConfig(TopicConfig topicConfig) {
-        List<ListenerConfigHolder> listenerConfigHolders = adaptListenerConfigs(topicConfig.getMessageListenerConfigs());
-        ClientMessage request = DynamicConfigAddTopicConfigCodec.encodeRequest(
-                topicConfig.getName(), topicConfig.isGlobalOrderingEnabled(), topicConfig.isStatisticsEnabled(),
-                topicConfig.isMultiThreadingEnabled(), listenerConfigHolders);
-        invoke(request);
-        return this;
-    }
-    @Override
-    public Config addReliableTopicConfig(ReliableTopicConfig config) {
-        List<ListenerConfigHolder> listenerConfigHolders = adaptListenerConfigs(config.getMessageListenerConfigs());
-        Data executorData = serializationService.toData(config.getExecutor());
-        ClientMessage request = DynamicConfigAddReliableTopicConfigCodec.encodeRequest(config.getName(),
-                listenerConfigHolders, config.getReadBatchSize(), config.isStatisticsEnabled(),
-                config.getTopicOverloadPolicy().name(), executorData);
-        invoke(request);
-        return this;
-    }
-    @Override
-    public Config addExecutorConfig(ExecutorConfig executorConfig) {
-        ClientMessage request = DynamicConfigAddExecutorConfigCodec.encodeRequest(
-                executorConfig.getName(), executorConfig.getPoolSize(), executorConfig.getQueueCapacity(),
-                executorConfig.isStatisticsEnabled(), executorConfig.getQuorumName());
-        invoke(request);
-        return this;
-    }
-    @Override
-    public Config addDurableExecutorConfig(DurableExecutorConfig durableExecutorConfig) {
-        ClientMessage request = DynamicConfigAddDurableExecutorConfigCodec.encodeRequest(
-                durableExecutorConfig.getName(), durableExecutorConfig.getPoolSize(),
-                durableExecutorConfig.getDurability(), durableExecutorConfig.getCapacity(),
-                durableExecutorConfig.getQuorumName());
-        invoke(request);
-        return this;
-    }
-    @Override
-    public Config addScheduledExecutorConfig(ScheduledExecutorConfig scheduledExecutorConfig) {
-        ClientMessage request = DynamicConfigAddScheduledExecutorConfigCodec.encodeRequest(
-                scheduledExecutorConfig.getName(), scheduledExecutorConfig.getPoolSize(),
-                scheduledExecutorConfig.getDurability(), scheduledExecutorConfig.getCapacity(),
-                scheduledExecutorConfig.getQuorumName(), scheduledExecutorConfig.getMergePolicyConfig().getPolicy(),
-                scheduledExecutorConfig.getMergePolicyConfig().getBatchSize());
-        invoke(request);
-        return this;
-    }
-    @Override
-    public Config addCardinalityEstimatorConfig(CardinalityEstimatorConfig cardinalityEstimatorConfig) {
-        ClientMessage request = DynamicConfigAddCardinalityEstimatorConfigCodec.encodeRequest(
-                cardinalityEstimatorConfig.getName(), cardinalityEstimatorConfig.getBackupCount(),
-                cardinalityEstimatorConfig.getAsyncBackupCount(), cardinalityEstimatorConfig.getQuorumName(),
-                cardinalityEstimatorConfig.getMergePolicyConfig().getPolicy(),
-                cardinalityEstimatorConfig.getMergePolicyConfig().getBatchSize());
-        invoke(request);
-        return this;
-    }
-    @Override
-    public Config addSemaphoreConfig(SemaphoreConfig semaphoreConfig) {
-        ClientMessage request = DynamicConfigAddSemaphoreConfigCodec.encodeRequest(
-                semaphoreConfig.getName(), semaphoreConfig.getInitialPermits(), semaphoreConfig.getBackupCount(),
-                semaphoreConfig.getAsyncBackupCount(), semaphoreConfig.getQuorumName());
-        invoke(request);
-        return this;
-    }
-    @Override
-    public Config addPNCounterConfig(PNCounterConfig pnCounterConfig) {
-        ClientMessage request = DynamicConfigAddPNCounterConfigCodec.encodeRequest(
-                pnCounterConfig.getName(), pnCounterConfig.getReplicaCount(),
-                pnCounterConfig.isStatisticsEnabled(), pnCounterConfig.getQuorumName());
-        invoke(request);
-        return this;
-    }
-    @Override
-    public Config addAtomicReferenceConfig(AtomicReferenceConfig atomicReferenceConfig) {
-        ClientMessage request = DynamicConfigAddAtomicReferenceConfigCodec.encodeRequest(
-                atomicReferenceConfig.getName(), atomicReferenceConfig.getQuorumName(),
-                atomicReferenceConfig.getMergePolicyConfig().getPolicy(),
-                atomicReferenceConfig.getMergePolicyConfig().getBatchSize());
-        invoke(request);
-        return this;
-    }
-    @Override
-    public Config addAtomicLongConfig(AtomicLongConfig atomicLongConfig) {
-        ClientMessage request = DynamicConfigAddAtomicLongConfigCodec.encodeRequest(
-                atomicLongConfig.getName(), atomicLongConfig.getQuorumName(),
-                atomicLongConfig.getMergePolicyConfig().getPolicy(), atomicLongConfig.getMergePolicyConfig().getBatchSize());
-        invoke(request);
-        return this;
-    }
-    @Override
-    public Config addCountDownLatchConfig(CountDownLatchConfig countDownLatchConfig) {
-        ClientMessage request = DynamicConfigAddCountDownLatchConfigCodec.encodeRequest(
-                countDownLatchConfig.getName(), countDownLatchConfig.getQuorumName());
-        invoke(request);
-        return this;
-    }
-    @Override
-    public Config addWanReplicationConfig(WanReplicationConfig wanReplicationConfig) {
-        return super.addWanReplicationConfig(wanReplicationConfig);
-    }
-    @Override
-    public Config addJobTrackerConfig(JobTrackerConfig jobTrackerConfig) {
-        throw new UnsupportedOperationException("JobTracker is deprecated and will be removed in Hazelcast 4.0");
-    }
-    @Override
-    public Config addQuorumConfig(QuorumConfig quorumConfig) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config addListenerConfig(ListenerConfig listenerConfig) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config addEventJournalConfig(EventJournalConfig eventJournalConfig) {
-        String mapName = eventJournalConfig.getMapName();
-        String cacheName = eventJournalConfig.getCacheName();
-        if (StringUtil.isNullOrEmpty(mapName) && StringUtil.isNullOrEmpty(cacheName)) {
-            throw new IllegalArgumentException("Event journal config should have non-empty map name and/or cache name");
-        }
-        ClientMessage request = DynamicConfigAddEventJournalConfigCodec.encodeRequest(eventJournalConfig.getMapName(),
-                eventJournalConfig.getCacheName(), eventJournalConfig.isEnabled(), eventJournalConfig.getCapacity(),
-                eventJournalConfig.getTimeToLiveSeconds());
-        invoke(request);
-        return this;
-    }
-    @Override
-    public EventJournalConfig findMapEventJournalConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public EventJournalConfig findCacheEventJournalConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public EventJournalConfig getMapEventJournalConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public EventJournalConfig getCacheEventJournalConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, EventJournalConfig> getMapEventJournalConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, EventJournalConfig> getCacheEventJournalConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setMapEventJournalConfigs(Map<String, EventJournalConfig> eventJournalConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setCacheEventJournalConfigs(Map<String, EventJournalConfig> eventJournalConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public MerkleTreeConfig findMapMerkleTreeConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public MerkleTreeConfig getMapMerkleTreeConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config addMerkleTreeConfig(MerkleTreeConfig merkleTreeConfig) {
-        String mapName = merkleTreeConfig.getMapName();
-        Preconditions.checkHasText(mapName, "Merkle tree config must define a map name");
-        ClientMessage request = DynamicConfigAddMerkleTreeConfigCodec.encodeRequest(
-                merkleTreeConfig.getMapName(), merkleTreeConfig.isEnabled(), merkleTreeConfig.getDepth());
-        invoke(request);
-        return this;
-    }
-    @Override
-    public Map<String, MerkleTreeConfig> getMapMerkleTreeConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setMapMerkleTreeConfigs(Map<String, MerkleTreeConfig> merkleTreeConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config addFlakeIdGeneratorConfig(FlakeIdGeneratorConfig flakeIdGeneratorConfig) {
-        ClientMessage request = DynamicConfigAddFlakeIdGeneratorConfigCodec.encodeRequest(
-                flakeIdGeneratorConfig.getName(),
-                flakeIdGeneratorConfig.getPrefetchCount(),
-                flakeIdGeneratorConfig.getPrefetchValidityMillis(),
-                flakeIdGeneratorConfig.getIdOffset(),
-                flakeIdGeneratorConfig.isStatisticsEnabled(),
-                flakeIdGeneratorConfig.getNodeIdOffset());
-        invoke(request);
-        return this;
-    }
-    @Override
-    public ClassLoader getClassLoader() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setClassLoader(ClassLoader classLoader) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public ConfigPatternMatcher getConfigPatternMatcher() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public void setConfigPatternMatcher(ConfigPatternMatcher configPatternMatcher) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public String getProperty(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setProperty(String name, String value) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public MemberAttributeConfig getMemberAttributeConfig() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public void setMemberAttributeConfig(MemberAttributeConfig memberAttributeConfig) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Properties getProperties() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setProperties(Properties properties) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public String getInstanceName() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setInstanceName(String instanceName) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public GroupConfig getGroupConfig() {
-        return instance.getClientConfig().getGroupConfig();
-    }
-    @Override
-    public Config setGroupConfig(GroupConfig groupConfig) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public NetworkConfig getNetworkConfig() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setNetworkConfig(NetworkConfig networkConfig) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public MapConfig findMapConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public MapConfig getMapConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, MapConfig> getMapConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setMapConfigs(Map<String, MapConfig> mapConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public CacheSimpleConfig findCacheConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public CacheSimpleConfig getCacheConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, CacheSimpleConfig> getCacheConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setCacheConfigs(Map<String, CacheSimpleConfig> cacheConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public QueueConfig findQueueConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public QueueConfig getQueueConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, QueueConfig> getQueueConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setQueueConfigs(Map<String, QueueConfig> queueConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public LockConfig findLockConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public LockConfig getLockConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, LockConfig> getLockConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setLockConfigs(Map<String, LockConfig> lockConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public ListConfig findListConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public ListConfig getListConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, ListConfig> getListConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setListConfigs(Map<String, ListConfig> listConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public SetConfig findSetConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public SetConfig getSetConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, SetConfig> getSetConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setSetConfigs(Map<String, SetConfig> setConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public MultiMapConfig findMultiMapConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public MultiMapConfig getMultiMapConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, MultiMapConfig> getMultiMapConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setMultiMapConfigs(Map<String, MultiMapConfig> multiMapConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public ReplicatedMapConfig findReplicatedMapConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public ReplicatedMapConfig getReplicatedMapConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, ReplicatedMapConfig> getReplicatedMapConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setReplicatedMapConfigs(Map<String, ReplicatedMapConfig> replicatedMapConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public RingbufferConfig findRingbufferConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public RingbufferConfig getRingbufferConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, RingbufferConfig> getRingbufferConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setRingbufferConfigs(Map<String, RingbufferConfig> ringbufferConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public TopicConfig findTopicConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public TopicConfig getTopicConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public ReliableTopicConfig findReliableTopicConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public ReliableTopicConfig getReliableTopicConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, ReliableTopicConfig> getReliableTopicConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setReliableTopicConfigs(Map<String, ReliableTopicConfig> reliableTopicConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, TopicConfig> getTopicConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setTopicConfigs(Map<String, TopicConfig> mapTopicConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public ExecutorConfig findExecutorConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public DurableExecutorConfig findDurableExecutorConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public ScheduledExecutorConfig findScheduledExecutorConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public CardinalityEstimatorConfig findCardinalityEstimatorConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public ExecutorConfig getExecutorConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public DurableExecutorConfig getDurableExecutorConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public ScheduledExecutorConfig getScheduledExecutorConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public CardinalityEstimatorConfig getCardinalityEstimatorConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, ExecutorConfig> getExecutorConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setExecutorConfigs(Map<String, ExecutorConfig> executorConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, DurableExecutorConfig> getDurableExecutorConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setDurableExecutorConfigs(Map<String, DurableExecutorConfig> durableExecutorConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, ScheduledExecutorConfig> getScheduledExecutorConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setScheduledExecutorConfigs(Map<String, ScheduledExecutorConfig> scheduledExecutorConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, CardinalityEstimatorConfig> getCardinalityEstimatorConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setCardinalityEstimatorConfigs(
-            Map<String, CardinalityEstimatorConfig> cardinalityEstimatorConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public SemaphoreConfig findSemaphoreConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public SemaphoreConfig getSemaphoreConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Collection<SemaphoreConfig> getSemaphoreConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, SemaphoreConfig> getSemaphoreConfigsAsMap() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setSemaphoreConfigs(Map<String, SemaphoreConfig> semaphoreConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public AtomicReferenceConfig findAtomicReferenceConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public AtomicReferenceConfig getAtomicReferenceConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, AtomicReferenceConfig> getAtomicReferenceConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setAtomicReferenceConfigs(Map<String, AtomicReferenceConfig> atomicReferenceConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public AtomicLongConfig findAtomicLongConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public AtomicLongConfig getAtomicLongConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, AtomicLongConfig> getAtomicLongConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setAtomicLongConfigs(Map<String, AtomicLongConfig> atomicLongConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public CountDownLatchConfig findCountDownLatchConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public CountDownLatchConfig getCountDownLatchConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, CountDownLatchConfig> getCountDownLatchConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setCountDownLatchConfigs(Map<String, CountDownLatchConfig> countDownLatchConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public WanReplicationConfig getWanReplicationConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, WanReplicationConfig> getWanReplicationConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setWanReplicationConfigs(Map<String, WanReplicationConfig> wanReplicationConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public JobTrackerConfig findJobTrackerConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public JobTrackerConfig getJobTrackerConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, JobTrackerConfig> getJobTrackerConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setJobTrackerConfigs(Map<String, JobTrackerConfig> jobTrackerConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, QuorumConfig> getQuorumConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public QuorumConfig getQuorumConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public QuorumConfig findQuorumConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setQuorumConfigs(Map<String, QuorumConfig> quorumConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public ManagementCenterConfig getManagementCenterConfig() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setManagementCenterConfig(ManagementCenterConfig managementCenterConfig) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public ServicesConfig getServicesConfig() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setServicesConfig(ServicesConfig servicesConfig) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public SecurityConfig getSecurityConfig() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setSecurityConfig(SecurityConfig securityConfig) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public List<ListenerConfig> getListenerConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setListenerConfigs(List<ListenerConfig> listenerConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public SerializationConfig getSerializationConfig() {
-        return instance.getClientConfig().getSerializationConfig();
-    }
-    @Override
-    public Config setSerializationConfig(SerializationConfig serializationConfig) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public PartitionGroupConfig getPartitionGroupConfig() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setPartitionGroupConfig(PartitionGroupConfig partitionGroupConfig) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public HotRestartPersistenceConfig getHotRestartPersistenceConfig() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setHotRestartPersistenceConfig(HotRestartPersistenceConfig hrConfig) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public CRDTReplicationConfig getCRDTReplicationConfig() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setCRDTReplicationConfig(CRDTReplicationConfig crdtReplicationConfig) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public ManagedContext getManagedContext() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setManagedContext(ManagedContext managedContext) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public ConcurrentMap<String, Object> getUserContext() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setUserContext(ConcurrentMap<String, Object> userContext) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public NativeMemoryConfig getNativeMemoryConfig() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setNativeMemoryConfig(NativeMemoryConfig nativeMemoryConfig) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public URL getConfigurationUrl() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setConfigurationUrl(URL configurationUrl) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public File getConfigurationFile() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setConfigurationFile(File configurationFile) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public String getLicenseKey() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setLicenseKey(String licenseKey) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public boolean isLiteMember() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setLiteMember(boolean liteMember) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public UserCodeDeploymentConfig getUserCodeDeploymentConfig() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setUserCodeDeploymentConfig(UserCodeDeploymentConfig userCodeDeploymentConfig) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public FlakeIdGeneratorConfig getFlakeIdGeneratorConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public FlakeIdGeneratorConfig findFlakeIdGeneratorConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, FlakeIdGeneratorConfig> getFlakeIdGeneratorConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setFlakeIdGeneratorConfigs(Map<String, FlakeIdGeneratorConfig> map) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public MapConfig getMapConfigOrNull(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public CacheSimpleConfig findCacheConfigOrNull(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public PNCounterConfig findPNCounterConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Map<String, PNCounterConfig> getPNCounterConfigs() {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public PNCounterConfig getPNCounterConfig(String name) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public Config setPNCounterConfigs(Map<String, PNCounterConfig> pnCounterConfigs) {
-        throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
-    }
-    @Override
-    public String toString() {
-        return "DynamicClusterConfig{instance=" + instance + "}";
-    }
-    private void invoke(ClientMessage request) {
-        try {
-            ClientInvocation invocation = new ClientInvocation(instance, request, null);
-            ClientInvocationFuture future = invocation.invoke();
-            future.get();
-        } catch (Exception e) {
-            throw rethrow(e);
-        }
-    }
-    private List<ListenerConfigHolder> adaptListenerConfigs(List<? extends ListenerConfig> listenerConfigs) {
-        List<ListenerConfigHolder> listenerConfigHolders = null;
-        if (listenerConfigs != null && !listenerConfigs.isEmpty()) {
-            listenerConfigHolders = new ArrayList<ListenerConfigHolder>();
-            for (ListenerConfig listenerConfig : listenerConfigs) {
-                listenerConfigHolders.add(ListenerConfigHolder.of(listenerConfig, serializationService));
-            }
-        }
-        return listenerConfigHolders;
-    }
-}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/ClientExceptionFactory.java
+++ b//dev/null
@@ -1,724 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.hazelcast.client.impl.clientside;
-import com.hazelcast.cache.CacheNotExistsException;
-import com.hazelcast.client.AuthenticationException;
-import com.hazelcast.client.UndefinedErrorCodeException;
-import com.hazelcast.client.impl.protocol.ClientMessage;
-import com.hazelcast.client.impl.protocol.ClientProtocolErrorCodes;
-import com.hazelcast.client.impl.protocol.codec.ErrorCodec;
-import com.hazelcast.client.impl.protocol.exception.MaxMessageSizeExceeded;
-import com.hazelcast.config.ConfigurationException;
-import com.hazelcast.config.InvalidConfigurationException;
-import com.hazelcast.core.ConsistencyLostException;
-import com.hazelcast.core.DuplicateInstanceNameException;
-import com.hazelcast.core.HazelcastException;
-import com.hazelcast.core.HazelcastInstanceNotActiveException;
-import com.hazelcast.core.HazelcastOverloadException;
-import com.hazelcast.core.IndeterminateOperationStateException;
-import com.hazelcast.core.LocalMemberResetException;
-import com.hazelcast.core.MemberLeftException;
-import com.hazelcast.core.OperationTimeoutException;
-import com.hazelcast.crdt.MutationDisallowedException;
-import com.hazelcast.crdt.TargetNotReplicaException;
-import com.hazelcast.durableexecutor.StaleTaskIdException;
-import com.hazelcast.flakeidgen.impl.NodeIdOutOfRangeException;
-import com.hazelcast.internal.cluster.impl.ConfigMismatchException;
-import com.hazelcast.map.QueryResultSizeExceededException;
-import com.hazelcast.map.ReachedMaxSizeException;
-import com.hazelcast.mapreduce.RemoteMapReduceException;
-import com.hazelcast.mapreduce.TopologyChangedException;
-import com.hazelcast.memory.NativeOutOfMemoryError;
-import com.hazelcast.nio.serialization.HazelcastSerializationException;
-import com.hazelcast.partition.NoDataMemberInClusterException;
-import com.hazelcast.query.QueryException;
-import com.hazelcast.quorum.QuorumException;
-import com.hazelcast.replicatedmap.ReplicatedMapCantBeCreatedOnLiteMemberException;
-import com.hazelcast.ringbuffer.StaleSequenceException;
-import com.hazelcast.scheduledexecutor.DuplicateTaskException;
-import com.hazelcast.scheduledexecutor.StaleTaskException;
-import com.hazelcast.spi.exception.CallerNotMemberException;
-import com.hazelcast.spi.exception.DistributedObjectDestroyedException;
-import com.hazelcast.spi.exception.PartitionMigratingException;
-import com.hazelcast.spi.exception.ResponseAlreadySentException;
-import com.hazelcast.spi.exception.RetryableHazelcastException;
-import com.hazelcast.spi.exception.RetryableIOException;
-import com.hazelcast.spi.exception.ServiceNotFoundException;
-import com.hazelcast.spi.exception.TargetDisconnectedException;
-import com.hazelcast.spi.exception.TargetNotMemberException;
-import com.hazelcast.spi.exception.WrongTargetException;
-import com.hazelcast.topic.TopicOverloadException;
-import com.hazelcast.transaction.TransactionException;
-import com.hazelcast.transaction.TransactionNotActiveException;
-import com.hazelcast.transaction.TransactionTimedOutException;
-import com.hazelcast.util.AddressUtil;
-import com.hazelcast.wan.WANReplicationQueueFullException;
-import javax.cache.CacheException;
-import javax.cache.integration.CacheLoaderException;
-import javax.cache.integration.CacheWriterException;
-import javax.cache.processor.EntryProcessorException;
-import javax.security.auth.callback.UnsupportedCallbackException;
-import javax.security.auth.login.LoginException;
-import javax.transaction.xa.XAException;
-import java.io.EOFException;
-import java.io.IOException;
-import java.io.NotSerializableException;
-import java.io.UTFDataFormatException;
-import java.net.SocketException;
-import java.net.URISyntaxException;
-import java.security.AccessControlException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.ConcurrentModificationException;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.NoSuchElementException;
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.TimeoutException;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-/**
- * This class has the error codes and means of
- * 1) creating exception from error code
- * 2) getting the error code of given exception
- */
-public class ClientExceptionFactory {
-    private static final String CAUSED_BY_STACKTRACE_MARKER = "###### Caused by:";
-    /**
-     * This pattern extracts errorCode and exception message from the encoded Caused-by marker.
-     * It has the form:
-     * <pre>    ###### Caused by: (&lt;errorCode>) &lt;cause.toString()> ------</pre>
-     *
-     * As per {@link Throwable#toString()}, this has the form
-     * <pre>&lt;exception class>: &lt;message></pre>
-     *
-     * if message is present, or just {@code &lt;exception class>}, if message is null.
-     *
-     * <p>Commonly, exceptions with causes are created like this:
-     * <pre>new RuntimeException("Additional message: " + e, e);</pre>
-     *
-     * Thus, this pattern matches the marker, error code in parentheses, text up to the semicolon
-     * (reluctantly, as to find the first one), and optional semicolon and the rest of message.
-     */
-    private static final Pattern CAUSED_BY_STACKTRACE_PARSER = Pattern.compile(Pattern.quote(CAUSED_BY_STACKTRACE_MARKER)
-            + " \\((-?[0-9]+)\\) (.+?)(: (.*))? ------", Pattern.DOTALL);
-    private static final int CAUSED_BY_STACKTRACE_PARSER_ERROR_CODE_GROUP = 1;
-    private static final int CAUSED_BY_STACKTRACE_PARSER_CLASS_NAME_GROUP = 2;
-    private static final int CAUSED_BY_STACKTRACE_PARSER_MESSAGE_GROUP = 4;
-    private final Map<Integer, ExceptionFactory> intToFactory = new HashMap<Integer, ExceptionFactory>();
-    public ClientExceptionFactory(boolean jcacheAvailable) {
-        if (jcacheAvailable) {
-            register(ClientProtocolErrorCodes.CACHE, CacheException.class, new ExceptionFactory() {
-                @Override
-                public Throwable createException(String message, Throwable cause) {
-                    return new CacheException(message, cause);
-                }
-            });
-            register(ClientProtocolErrorCodes.CACHE_LOADER, CacheLoaderException.class, new ExceptionFactory() {
-                @Override
-                public Throwable createException(String message, Throwable cause) {
-                    return new CacheLoaderException(message, cause);
-                }
-            });
-            register(ClientProtocolErrorCodes.CACHE_WRITER, CacheWriterException.class, new ExceptionFactory() {
-                @Override
-                public Throwable createException(String message, Throwable cause) {
-                    return new CacheWriterException(message, cause);
-                }
-            });
-            register(ClientProtocolErrorCodes.ENTRY_PROCESSOR, EntryProcessorException.class, new ExceptionFactory() {
-                @Override
-                public Throwable createException(String message, Throwable cause) {
-                    return new EntryProcessorException(message, cause);
-                }
-            });
-        }
-        register(ClientProtocolErrorCodes.ARRAY_INDEX_OUT_OF_BOUNDS, ArrayIndexOutOfBoundsException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new ArrayIndexOutOfBoundsException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.ARRAY_STORE, ArrayStoreException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new ArrayStoreException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.AUTHENTICATION, AuthenticationException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new AuthenticationException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.CACHE_NOT_EXISTS, CacheNotExistsException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new CacheNotExistsException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.CALLER_NOT_MEMBER, CallerNotMemberException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new CallerNotMemberException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.CANCELLATION, CancellationException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new CancellationException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.CLASS_CAST, ClassCastException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new ClassCastException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.CLASS_NOT_FOUND, ClassNotFoundException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new ClassNotFoundException(message, cause);
-            }
-        });
-        register(ClientProtocolErrorCodes.CONCURRENT_MODIFICATION, ConcurrentModificationException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new ConcurrentModificationException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.CONFIG_MISMATCH, ConfigMismatchException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new ConfigMismatchException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.CONFIGURATION, ConfigurationException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new ConfigurationException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.DISTRIBUTED_OBJECT_DESTROYED, DistributedObjectDestroyedException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new DistributedObjectDestroyedException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.DUPLICATE_INSTANCE_NAME, DuplicateInstanceNameException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new DuplicateInstanceNameException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.EOF, EOFException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new EOFException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.EXECUTION, ExecutionException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new ExecutionException(message, cause);
-            }
-        });
-        register(ClientProtocolErrorCodes.HAZELCAST, HazelcastException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new HazelcastException(message, cause);
-            }
-        });
-        register(ClientProtocolErrorCodes.HAZELCAST_INSTANCE_NOT_ACTIVE, HazelcastInstanceNotActiveException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new HazelcastInstanceNotActiveException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.HAZELCAST_OVERLOAD, HazelcastOverloadException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new HazelcastOverloadException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.HAZELCAST_SERIALIZATION, HazelcastSerializationException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new HazelcastSerializationException(message, cause);
-            }
-        });
-        register(ClientProtocolErrorCodes.IO, IOException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new IOException(message, cause);
-            }
-        });
-        register(ClientProtocolErrorCodes.ILLEGAL_ARGUMENT, IllegalArgumentException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new IllegalArgumentException(message, cause);
-            }
-        });
-        register(ClientProtocolErrorCodes.ILLEGAL_ACCESS_EXCEPTION, IllegalAccessException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new IllegalAccessException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.ILLEGAL_ACCESS_ERROR, IllegalAccessError.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new IllegalAccessError(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.ILLEGAL_MONITOR_STATE, IllegalMonitorStateException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new IllegalMonitorStateException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.ILLEGAL_STATE, IllegalStateException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new IllegalStateException(message, cause);
-            }
-        });
-        register(ClientProtocolErrorCodes.ILLEGAL_THREAD_STATE, IllegalThreadStateException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new IllegalThreadStateException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.INDEX_OUT_OF_BOUNDS, IndexOutOfBoundsException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new IndexOutOfBoundsException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.INTERRUPTED, InterruptedException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new InterruptedException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.INVALID_ADDRESS, AddressUtil.InvalidAddressException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new AddressUtil.InvalidAddressException(message, false);
-            }
-        });
-        register(ClientProtocolErrorCodes.INVALID_CONFIGURATION, InvalidConfigurationException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new InvalidConfigurationException(message, cause);
-            }
-        });
-        register(ClientProtocolErrorCodes.MEMBER_LEFT, MemberLeftException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new MemberLeftException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.NEGATIVE_ARRAY_SIZE, NegativeArraySizeException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new NegativeArraySizeException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.NO_SUCH_ELEMENT, NoSuchElementException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new NoSuchElementException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.NOT_SERIALIZABLE, NotSerializableException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new NotSerializableException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.NULL_POINTER, NullPointerException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new NullPointerException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.OPERATION_TIMEOUT, OperationTimeoutException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new OperationTimeoutException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.PARTITION_MIGRATING, PartitionMigratingException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new PartitionMigratingException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.QUERY, QueryException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new QueryException(message, cause);
-            }
-        });
-        register(ClientProtocolErrorCodes.QUERY_RESULT_SIZE_EXCEEDED, QueryResultSizeExceededException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new QueryResultSizeExceededException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.QUORUM, QuorumException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new QuorumException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.REACHED_MAX_SIZE, ReachedMaxSizeException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new ReachedMaxSizeException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.REJECTED_EXECUTION, RejectedExecutionException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new RejectedExecutionException(message, cause);
-            }
-        });
-        register(ClientProtocolErrorCodes.REMOTE_MAP_REDUCE, RemoteMapReduceException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new RemoteMapReduceException(message, Collections.<Exception>emptyList());
-            }
-        });
-        register(ClientProtocolErrorCodes.RESPONSE_ALREADY_SENT, ResponseAlreadySentException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new ResponseAlreadySentException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.RETRYABLE_HAZELCAST, RetryableHazelcastException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new RetryableHazelcastException(message, cause);
-            }
-        });
-        register(ClientProtocolErrorCodes.RETRYABLE_IO, RetryableIOException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new RetryableIOException(message, cause);
-            }
-        });
-        register(ClientProtocolErrorCodes.RUNTIME, RuntimeException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new RuntimeException(message, cause);
-            }
-        });
-        register(ClientProtocolErrorCodes.SECURITY, SecurityException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new SecurityException(message, cause);
-            }
-        });
-        register(ClientProtocolErrorCodes.SOCKET, SocketException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new SocketException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.STALE_SEQUENCE, StaleSequenceException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new StaleSequenceException(message, 0);
-            }
-        });
-        register(ClientProtocolErrorCodes.TARGET_DISCONNECTED, TargetDisconnectedException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new TargetDisconnectedException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.TARGET_NOT_MEMBER, TargetNotMemberException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new TargetNotMemberException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.TIMEOUT, TimeoutException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new TimeoutException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.TOPIC_OVERLOAD, TopicOverloadException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new TopicOverloadException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.TOPOLOGY_CHANGED, TopologyChangedException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new TopologyChangedException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.TRANSACTION, TransactionException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new TransactionException(message, cause);
-            }
-        });
-        register(ClientProtocolErrorCodes.TRANSACTION_NOT_ACTIVE, TransactionNotActiveException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new TransactionNotActiveException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.TRANSACTION_TIMED_OUT, TransactionTimedOutException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new TransactionTimedOutException(message, cause);
-            }
-        });
-        register(ClientProtocolErrorCodes.URI_SYNTAX, URISyntaxException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new URISyntaxException("not available", message);
-            }
-        });
-        register(ClientProtocolErrorCodes.UTF_DATA_FORMAT, UTFDataFormatException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new UTFDataFormatException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.UNSUPPORTED_OPERATION, UnsupportedOperationException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new UnsupportedOperationException(message, cause);
-            }
-        });
-        register(ClientProtocolErrorCodes.WRONG_TARGET, WrongTargetException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new WrongTargetException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.XA, XAException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new XAException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.ACCESS_CONTROL, AccessControlException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new AccessControlException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.LOGIN, LoginException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new LoginException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.UNSUPPORTED_CALLBACK, UnsupportedCallbackException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new UnsupportedCallbackException(null, message);
-            }
-        });
-        register(ClientProtocolErrorCodes.NO_DATA_MEMBER, NoDataMemberInClusterException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new NoDataMemberInClusterException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.REPLICATED_MAP_CANT_BE_CREATED, ReplicatedMapCantBeCreatedOnLiteMemberException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new ReplicatedMapCantBeCreatedOnLiteMemberException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.MAX_MESSAGE_SIZE_EXCEEDED, MaxMessageSizeExceeded.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new MaxMessageSizeExceeded();
-            }
-        });
-        register(ClientProtocolErrorCodes.WAN_REPLICATION_QUEUE_FULL, WANReplicationQueueFullException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new WANReplicationQueueFullException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.ASSERTION_ERROR, AssertionError.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new AssertionError(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.OUT_OF_MEMORY_ERROR, OutOfMemoryError.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new OutOfMemoryError(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.STACK_OVERFLOW_ERROR, StackOverflowError.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new StackOverflowError(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.NATIVE_OUT_OF_MEMORY_ERROR, NativeOutOfMemoryError.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new NativeOutOfMemoryError(message, cause);
-            }
-        });
-        register(ClientProtocolErrorCodes.SERVICE_NOT_FOUND, ServiceNotFoundException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new ServiceNotFoundException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.STALE_TASK_ID, StaleTaskIdException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new StaleTaskIdException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.DUPLICATE_TASK, DuplicateTaskException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new DuplicateTaskException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.STALE_TASK, StaleTaskException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new StaleTaskException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.LOCAL_MEMBER_RESET, LocalMemberResetException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new LocalMemberResetException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.INDETERMINATE_OPERATION_STATE, IndeterminateOperationStateException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new IndeterminateOperationStateException(message, cause);
-            }
-        });
-        register(ClientProtocolErrorCodes.FLAKE_ID_NODE_ID_OUT_OF_RANGE_EXCEPTION, NodeIdOutOfRangeException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new NodeIdOutOfRangeException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.TARGET_NOT_REPLICA_EXCEPTION, TargetNotReplicaException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new TargetNotReplicaException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.MUTATION_DISALLOWED_EXCEPTION, MutationDisallowedException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new MutationDisallowedException(message);
-            }
-        });
-        register(ClientProtocolErrorCodes.CONSISTENCY_LOST_EXCEPTION, ConsistencyLostException.class, new ExceptionFactory() {
-            @Override
-            public Throwable createException(String message, Throwable cause) {
-                return new ConsistencyLostException(message);
-            }
-        });
-    }
-    public Throwable createException(ClientMessage clientMessage) {
-        ErrorCodec parameters = ErrorCodec.decode(clientMessage);
-        boolean causedByMarkerFound = false;
-        for (int i = 0; ! causedByMarkerFound && i < parameters.stackTrace.length; i++) {
-            causedByMarkerFound = parameters.stackTrace[i].getClassName().startsWith(CAUSED_BY_STACKTRACE_MARKER);
-        }
-        if (causedByMarkerFound) {
-            StackTraceElement[] st = parameters.stackTrace;
-            int pos = st.length;
-            int lastPos = pos;
-            Throwable t = null;
-            while (pos >= 0) {
-                Throwable t1 = null;
-                if (pos == 0) {
-                    t1 = createException(parameters.errorCode, parameters.className, parameters.message, t);
-                } else if (st[pos - 1].getClassName().startsWith(CAUSED_BY_STACKTRACE_MARKER)) {
-                    Matcher matcher = CAUSED_BY_STACKTRACE_PARSER.matcher(st[pos - 1].getClassName());
-                    if (matcher.find()) {
-                        int errorCode = Integer.parseInt(matcher.group(CAUSED_BY_STACKTRACE_PARSER_ERROR_CODE_GROUP));
-                        String className = matcher.group(CAUSED_BY_STACKTRACE_PARSER_CLASS_NAME_GROUP);
-                        String message = matcher.group(CAUSED_BY_STACKTRACE_PARSER_MESSAGE_GROUP);
-                        t1 = createException(errorCode, className, message, t);
-                    } else {
-                        t1 = createException(ClientProtocolErrorCodes.UNDEFINED, st[pos - 1].toString(), null, t);
-                    }
-                }
-                if (t1 != null) {
-                    t1.setStackTrace(Arrays.copyOfRange(st, pos, lastPos));
-                    pos--;
-                    lastPos = pos;
-                    t = t1;
-                }
-                pos--;
-            }
-            return t;
-        } else {
-            Throwable cause = null;
-            if (parameters.causeClassName != null) {
-                cause = createException(parameters.causeErrorCode, parameters.causeClassName, null, null);
-            }
-            Throwable throwable = createException(parameters.errorCode, parameters.className, parameters.message, cause);
-            throwable.setStackTrace(parameters.stackTrace);
-            return throwable;
-        }
-    }
-    private Throwable createException(int errorCode, String className, String message, Throwable cause) {
-        ExceptionFactory exceptionFactory = intToFactory.get(errorCode);
-        Throwable throwable;
-        if (exceptionFactory == null) {
-            throwable = new UndefinedErrorCodeException(message, className);
-        } else {
-            throwable = exceptionFactory.createException(message, cause);
-        }
-        return throwable;
-    }
-    @SuppressWarnings("WeakerAccess")
-    public void register(int errorCode, Class clazz, ExceptionFactory exceptionFactory) {
-        if (intToFactory.containsKey(errorCode)) {
-            throw new HazelcastException("Code " + errorCode + " already used");
-        }
-        if (!clazz.equals(exceptionFactory.createException("", null).getClass())) {
-            throw new HazelcastException("Exception factory did not produce an instance of expected class");
-        }
-        intToFactory.put(errorCode, exceptionFactory);
-    }
-    public interface ExceptionFactory {
-        Throwable createException(String message, Throwable cause);
-    }
-}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/ClientICacheManager.java
+++ b//dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.hazelcast.client.impl.clientside;
-import com.hazelcast.cache.HazelcastCacheManager;
-import com.hazelcast.cache.ICache;
-import com.hazelcast.cache.impl.ICacheService;
-import com.hazelcast.client.spi.impl.ClientServiceNotFoundException;
-import com.hazelcast.core.HazelcastException;
-import com.hazelcast.core.HazelcastInstance;
-import com.hazelcast.core.ICacheManager;
-import com.hazelcast.spi.exception.ServiceNotFoundException;
-import static com.hazelcast.util.Preconditions.checkNotNull;
-/**
- * Hazelcast instance cache manager provides a means to obtain JCache caches via HazelcastInstance API.
- * Note that this is not a JCache {@code CacheManager}.
- *
- * @see ICacheManager
- */
-public class ClientICacheManager implements ICacheManager {
-    private final HazelcastInstance instance;
-    ClientICacheManager(HazelcastInstance instance) {
-        this.instance = instance;
-    }
-    @Override
-    public <K, V> ICache<K, V> getCache(String name) {
-        checkNotNull(name, "Retrieving a cache instance with a null name is not allowed!");
-        return getCacheByFullName(HazelcastCacheManager.CACHE_MANAGER_PREFIX + name);
-    }
-    public <K, V> ICache<K, V> getCacheByFullName(String fullName) {
-        checkNotNull(fullName, "Retrieving a cache instance with a null name is not allowed!");
-        try {
-            return instance.getDistributedObject(ICacheService.SERVICE_NAME, fullName);
-        } catch (ClientServiceNotFoundException e) {
-            throw new IllegalStateException("At client, " + ICacheService.CACHE_SUPPORT_NOT_AVAILABLE_ERROR_MESSAGE);
-        } catch (HazelcastException e) {
-            if (e.getCause() instanceof ServiceNotFoundException) {
-                throw new IllegalStateException("At server, " + ICacheService.CACHE_SUPPORT_NOT_AVAILABLE_ERROR_MESSAGE);
-            } else {
-                throw e;
-            }
-        }
-    }
-}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/ClientImpl.java
+++ b//dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.hazelcast.client.impl.clientside;
-import com.hazelcast.core.Client;
-import com.hazelcast.core.ClientType;
-import java.net.InetSocketAddress;
-/**
- * Default {@link com.hazelcast.core.Client} implementation.
- */
-public class ClientImpl implements Client {
-    private final String uuid;
-    private final InetSocketAddress socketAddress;
-    public ClientImpl(String uuid, InetSocketAddress socketAddress) {
-        this.uuid = uuid;
-        this.socketAddress = socketAddress;
-    }
-    @Override
-    public String getUuid() {
-        return uuid;
-    }
-    @Override
-    public InetSocketAddress getSocketAddress() {
-        return socketAddress;
-    }
-    @Override
-    public ClientType getClientType() {
-        return ClientType.JAVA;
-    }
-}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/ClientLockReferenceIdGenerator.java
+++ b//dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.hazelcast.client.impl.clientside;
-import java.util.concurrent.atomic.AtomicLong;
-/**
- * This class generates unique (per client) incrementing reference ID which is used during locking related requests.
- * The server side uses this ID to match if any previous request with the same ID was issued and shall not re-do the lock related
- * operation but it shall just return the previous result. Hence, this ID identifies the outstanding request sent to the server
- * side for locking operations. Similarly, if the client resends the request to the server for some reason it will use the same
- * reference ID to make sure that the operation is not executed more than once at the server side.
- */
-public final class ClientLockReferenceIdGenerator {
-    private AtomicLong referenceIdCounter = new AtomicLong();
-    /**
-     * @return A per client unique reference ID
-     */
-    public long getNextReferenceId() {
-        return referenceIdCounter.incrementAndGet();
-    }
-}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/ClientLoggingService.java
+++ b//dev/null
@@ -1,93 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.hazelcast.client.impl.clientside;
-import com.hazelcast.instance.BuildInfo;
-import com.hazelcast.instance.JetBuildInfo;
-import com.hazelcast.logging.AbstractLogger;
-import com.hazelcast.logging.ILogger;
-import com.hazelcast.logging.LogEvent;
-import com.hazelcast.logging.LogListener;
-import com.hazelcast.logging.Logger;
-import com.hazelcast.logging.LoggerFactory;
-import com.hazelcast.logging.LoggingService;
-import com.hazelcast.util.ConstructorFunction;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import java.util.logging.Level;
-import static com.hazelcast.util.ConcurrencyUtil.getOrPutIfAbsent;
-public class ClientLoggingService implements LoggingService {
-    private final ConcurrentMap<String, ILogger> mapLoggers = new ConcurrentHashMap<String, ILogger>(100);
-    private final ConstructorFunction<String, ILogger> loggerConstructor
-            = new ConstructorFunction<String, ILogger>() {
-        @Override
-        public ILogger createNew(String key) {
-            return new DefaultLogger(key);
-        }
-    };
-    private final LoggerFactory loggerFactory;
-    private final String versionMessage;
-    public ClientLoggingService(String groupName, String loggingType, BuildInfo buildInfo, String clientName) {
-        this.loggerFactory = Logger.newLoggerFactory(loggingType);
-        JetBuildInfo jetBuildInfo = buildInfo.getJetBuildInfo();
-        this.versionMessage = clientName + " [" + groupName + "]"
-                + (jetBuildInfo != null ? " [" + jetBuildInfo.getVersion() + "]" : "")
-                + " [" + buildInfo.getVersion() + "] ";
-    }
-    @Override
-    public void addLogListener(Level level, LogListener logListener) {
-        throw new UnsupportedOperationException();
-    }
-    @Override
-    public void removeLogListener(LogListener logListener) {
-        throw new UnsupportedOperationException();
-    }
-    public ILogger getLogger(String name) {
-        return getOrPutIfAbsent(mapLoggers, name, loggerConstructor);
-    }
-    public ILogger getLogger(Class clazz) {
-        return getOrPutIfAbsent(mapLoggers, clazz.getName(), loggerConstructor);
-    }
-    private class DefaultLogger extends AbstractLogger {
-        final String name;
-        final ILogger logger;
-        DefaultLogger(String name) {
-            this.name = name;
-            this.logger = loggerFactory.getLogger(name);
-        }
-        @Override
-        public void log(Level level, String message) {
-            log(level, message, null);
-        }
-        @Override
-        public void log(Level level, String message, Throwable thrown) {
-            if (logger.isLoggable(level)) {
-                String logMessage = versionMessage + message;
-                logger.log(level, logMessage, thrown);
-            }
-        }
-        @Override
-        public void log(LogEvent logEvent) {
-        }
-        @Override
-        public Level getLevel() {
-            return logger.getLevel();
-        }
-        @Override
-        public boolean isLoggable(Level level) {
-            return logger.isLoggable(level);
-        }
-    }
-}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/ClientMessageDecoder.java
+++ b//dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.hazelcast.client.impl.clientside;
-import com.hazelcast.client.impl.protocol.ClientMessage;
-/**
- * Interface to pass specific decode methods to generic data structures that is dealing with client message
- */
-public interface ClientMessageDecoder {
-    <T> T decodeClientMessage(ClientMessage clientMessage);
-}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/DefaultClientConnectionManagerFactory.java
+++ b//dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.hazelcast.client.impl.clientside;
-import com.hazelcast.client.connection.AddressProvider;
-import com.hazelcast.client.connection.AddressTranslator;
-import com.hazelcast.client.connection.ClientConnectionManager;
-import com.hazelcast.client.connection.nio.ClientConnectionManagerImpl;
-import java.util.Collection;
-public class DefaultClientConnectionManagerFactory implements ClientConnectionManagerFactory {
-    public DefaultClientConnectionManagerFactory() {
-    }
-    @Override
-    public ClientConnectionManager createConnectionManager(HazelcastClientInstanceImpl client,
-                                                           AddressTranslator addressTranslator,
-                                                           Collection<AddressProvider> addressProviders) {
-        return new ClientConnectionManagerImpl(client, addressTranslator, addressProviders);
-    }
-}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/DefaultClientExtension.java
+++ b//dev/null
@@ -1,161 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.hazelcast.client.impl.clientside;
-import com.hazelcast.client.ClientExtension;
-import com.hazelcast.client.HazelcastClientNotActiveException;
-import com.hazelcast.client.config.ClientConfig;
-import com.hazelcast.client.config.ClientNetworkConfig;
-import com.hazelcast.client.config.SocketOptions;
-import com.hazelcast.client.connection.nio.ClientPlainChannelInitializer;
-import com.hazelcast.client.proxy.ClientMapProxy;
-import com.hazelcast.client.proxy.NearCachedClientMapProxy;
-import com.hazelcast.client.spi.ClientContext;
-import com.hazelcast.client.spi.ClientExecutionService;
-import com.hazelcast.client.spi.ClientProxy;
-import com.hazelcast.client.spi.ClientProxyFactory;
-import com.hazelcast.client.spi.impl.ClientProxyFactoryWithContext;
-import com.hazelcast.config.NearCacheConfig;
-import com.hazelcast.config.SSLConfig;
-import com.hazelcast.config.SerializationConfig;
-import com.hazelcast.core.HazelcastInstance;
-import com.hazelcast.core.PartitioningStrategy;
-import com.hazelcast.instance.BuildInfoProvider;
-import com.hazelcast.internal.nearcache.NearCacheManager;
-import com.hazelcast.internal.nearcache.impl.DefaultNearCacheManager;
-import com.hazelcast.internal.networking.ChannelInitializer;
-import com.hazelcast.internal.serialization.InternalSerializationService;
-import com.hazelcast.internal.serialization.SerializationServiceBuilder;
-import com.hazelcast.internal.serialization.impl.DefaultSerializationServiceBuilder;
-import com.hazelcast.logging.ILogger;
-import com.hazelcast.logging.Logger;
-import com.hazelcast.map.impl.MapService;
-import com.hazelcast.memory.DefaultMemoryStats;
-import com.hazelcast.memory.MemoryStats;
-import com.hazelcast.nio.ClassLoaderUtil;
-import com.hazelcast.nio.SocketInterceptor;
-import com.hazelcast.partition.strategy.DefaultPartitioningStrategy;
-import com.hazelcast.spi.properties.GroupProperty;
-import com.hazelcast.spi.properties.HazelcastProperties;
-import com.hazelcast.spi.serialization.SerializationService;
-import com.hazelcast.util.function.Supplier;
-import static com.hazelcast.internal.config.ConfigValidator.checkNearCacheConfig;
-import static com.hazelcast.spi.properties.GroupProperty.SOCKET_CLIENT_BUFFER_DIRECT;
-import static com.hazelcast.util.ExceptionUtil.rethrow;
-@SuppressWarnings("WeakerAccess")
-public class DefaultClientExtension implements ClientExtension {
-    protected static final ILogger LOGGER = Logger.getLogger(ClientExtension.class);
-    protected volatile HazelcastClientInstanceImpl client;
-    private final MemoryStats memoryStats = new DefaultMemoryStats();
-    @Override
-    public void beforeStart(HazelcastClientInstanceImpl client) {
-        this.client = client;
-    }
-    @Override
-    public void afterStart(HazelcastClientInstanceImpl client) {
-    }
-    @Override
-    public InternalSerializationService createSerializationService(byte version) {
-        try {
-            ClientConfig config = client.getClientConfig();
-            ClassLoader configClassLoader = config.getClassLoader();
-            HazelcastInstance hazelcastInstance = client;
-            PartitioningStrategy partitioningStrategy = getPartitioningStrategy(configClassLoader);
-            SerializationConfig serializationConfig = config.getSerializationConfig() != null
-                    ? config.getSerializationConfig()
-                    : new SerializationConfig();
-            SerializationServiceBuilder builder = new DefaultSerializationServiceBuilder();
-            if (version > 0) {
-                builder.setVersion(version);
-            }
-            return builder
-                    .setClassLoader(configClassLoader)
-                    .setConfig(serializationConfig)
-                    .setManagedContext(new HazelcastClientManagedContext(client, config.getManagedContext()))
-                    .setPartitioningStrategy(partitioningStrategy)
-                    .setHazelcastInstance(hazelcastInstance)
-                    .setNotActiveExceptionSupplier(new Supplier<RuntimeException>() {
-                        @Override
-                        public RuntimeException get() {
-                            return new HazelcastClientNotActiveException("Client is shutdown");
-                        }
-                    })
-                    .build();
-        } catch (Exception e) {
-            throw rethrow(e);
-        }
-    }
-    protected PartitioningStrategy getPartitioningStrategy(ClassLoader configClassLoader) throws Exception {
-        String partitioningStrategyClassName = GroupProperty.PARTITIONING_STRATEGY_CLASS.getSystemProperty();
-        if (partitioningStrategyClassName != null && partitioningStrategyClassName.length() > 0) {
-            return ClassLoaderUtil.newInstance(configClassLoader, partitioningStrategyClassName);
-        } else {
-            return new DefaultPartitioningStrategy();
-        }
-    }
-    @Override
-    public SocketInterceptor createSocketInterceptor() {
-        LOGGER.warning("SocketInterceptor feature is only available on Hazelcast Enterprise!");
-        return null;
-    }
-    @Override
-    public ChannelInitializer createChannelInitializer() {
-        ClientNetworkConfig networkConfig = client.getClientConfig().getNetworkConfig();
-        SSLConfig sslConfig = networkConfig.getSSLConfig();
-        if (sslConfig != null && sslConfig.isEnabled()) {
-            if (!BuildInfoProvider.getBuildInfo().isEnterprise()) {
-                throw new IllegalStateException("SSL/TLS requires Hazelcast Enterprise Edition");
-            }
-        }
-        SocketOptions socketOptions = networkConfig.getSocketOptions();
-        HazelcastProperties properties = client.getProperties();
-        boolean directBuffer = properties.getBoolean(SOCKET_CLIENT_BUFFER_DIRECT);
-        return new ClientPlainChannelInitializer(socketOptions, directBuffer);
-    }
-    @Override
-    public <T> ClientProxyFactory createServiceProxyFactory(Class<T> service) {
-        if (MapService.class.isAssignableFrom(service)) {
-            return createClientMapProxyFactory();
-        }
-        throw new IllegalArgumentException("Proxy factory cannot be created. Unknown service: " + service);
-    }
-    @Override
-    public MemoryStats getMemoryStats() {
-        return memoryStats;
-    }
-    private ClientProxyFactory createClientMapProxyFactory() {
-        return new ClientProxyFactoryWithContext() {
-            @Override
-            public ClientProxy create(String id, ClientContext context) {
-                ClientConfig clientConfig = client.getClientConfig();
-                NearCacheConfig nearCacheConfig = clientConfig.getNearCacheConfig(id);
-                if (nearCacheConfig != null) {
-                    checkNearCacheConfig(id, nearCacheConfig, clientConfig.getNativeMemoryConfig(), true);
-                    return new NearCachedClientMapProxy(MapService.SERVICE_NAME, id, context);
-                } else {
-                    return new ClientMapProxy(MapService.SERVICE_NAME, id, context);
-                }
-            }
-        };
-    }
-    @Override
-    public NearCacheManager createNearCacheManager() {
-        SerializationService ss = client.getSerializationService();
-        ClientExecutionService es = client.getClientExecutionService();
-        ClassLoader classLoader = client.getClientConfig().getClassLoader();
-        HazelcastProperties properties = client.getProperties();
-        return new DefaultNearCacheManager(ss, es, classLoader, properties);
-    }
-}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/HazelcastClientInstanceImpl.java
+++ b//dev/null
@@ -1,855 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.hazelcast.client.impl.clientside;
-import com.hazelcast.cache.impl.JCacheDetector;
-import com.hazelcast.cardinality.CardinalityEstimator;
-import com.hazelcast.cardinality.impl.CardinalityEstimatorService;
-import com.hazelcast.client.ClientExtension;
-import com.hazelcast.client.HazelcastClient;
-import com.hazelcast.client.LoadBalancer;
-import com.hazelcast.client.config.ClientAliasedDiscoveryConfigUtils;
-import com.hazelcast.client.config.ClientCloudConfig;
-import com.hazelcast.client.config.ClientConfig;
-import com.hazelcast.client.config.ClientNetworkConfig;
-import com.hazelcast.client.config.ClientSecurityConfig;
-import com.hazelcast.client.connection.AddressProvider;
-import com.hazelcast.client.connection.AddressTranslator;
-import com.hazelcast.client.connection.ClientConnectionManager;
-import com.hazelcast.client.connection.nio.ClientConnectionManagerImpl;
-import com.hazelcast.client.connection.nio.DefaultCredentialsFactory;
-import com.hazelcast.client.impl.client.DistributedObjectInfo;
-import com.hazelcast.client.impl.protocol.ClientMessage;
-import com.hazelcast.client.impl.protocol.codec.ClientGetDistributedObjectsCodec;
-import com.hazelcast.client.impl.statistics.Statistics;
-import com.hazelcast.client.proxy.ClientClusterProxy;
-import com.hazelcast.client.proxy.PartitionServiceProxy;
-import com.hazelcast.client.spi.ClientClusterService;
-import com.hazelcast.client.spi.ClientContext;
-import com.hazelcast.client.spi.ClientExecutionService;
-import com.hazelcast.client.spi.ClientInvocationService;
-import com.hazelcast.client.spi.ClientListenerService;
-import com.hazelcast.client.spi.ClientPartitionService;
-import com.hazelcast.client.spi.ClientTransactionManagerService;
-import com.hazelcast.client.spi.ProxyManager;
-import com.hazelcast.client.spi.impl.AbstractClientInvocationService;
-import com.hazelcast.client.spi.impl.ClientClusterServiceImpl;
-import com.hazelcast.client.spi.impl.ClientExecutionServiceImpl;
-import com.hazelcast.client.spi.impl.ClientInvocation;
-import com.hazelcast.client.spi.impl.ClientPartitionServiceImpl;
-import com.hazelcast.client.spi.impl.ClientTransactionManagerServiceImpl;
-import com.hazelcast.client.spi.impl.ClientUserCodeDeploymentService;
-import com.hazelcast.client.spi.impl.DefaultAddressProvider;
-import com.hazelcast.client.spi.impl.DefaultAddressTranslator;
-import com.hazelcast.client.spi.impl.NonSmartClientInvocationService;
-import com.hazelcast.client.spi.impl.SmartClientInvocationService;
-import com.hazelcast.client.spi.impl.discovery.DiscoveryAddressProvider;
-import com.hazelcast.client.spi.impl.discovery.DiscoveryAddressTranslator;
-import com.hazelcast.client.spi.impl.discovery.HazelcastCloudAddressProvider;
-import com.hazelcast.client.spi.impl.discovery.HazelcastCloudAddressTranslator;
-import com.hazelcast.client.spi.impl.discovery.HazelcastCloudDiscovery;
-import com.hazelcast.client.spi.impl.listener.AbstractClientListenerService;
-import com.hazelcast.client.spi.impl.listener.NonSmartClientListenerService;
-import com.hazelcast.client.spi.impl.listener.SmartClientListenerService;
-import com.hazelcast.client.spi.properties.ClientProperty;
-import com.hazelcast.client.util.RoundRobinLB;
-import com.hazelcast.collection.impl.list.ListService;
-import com.hazelcast.collection.impl.queue.QueueService;
-import com.hazelcast.collection.impl.set.SetService;
-import com.hazelcast.concurrent.atomiclong.AtomicLongService;
-import com.hazelcast.concurrent.atomicreference.AtomicReferenceService;
-import com.hazelcast.concurrent.countdownlatch.CountDownLatchService;
-import com.hazelcast.concurrent.idgen.IdGeneratorService;
-import com.hazelcast.concurrent.lock.LockServiceImpl;
-import com.hazelcast.concurrent.semaphore.SemaphoreService;
-import com.hazelcast.config.Config;
-import com.hazelcast.config.CredentialsFactoryConfig;
-import com.hazelcast.config.DiscoveryConfig;
-import com.hazelcast.config.DiscoveryStrategyConfig;
-import com.hazelcast.config.GroupConfig;
-import com.hazelcast.core.Client;
-import com.hazelcast.core.ClientService;
-import com.hazelcast.core.Cluster;
-import com.hazelcast.core.DistributedObject;
-import com.hazelcast.core.DistributedObjectListener;
-import com.hazelcast.core.HazelcastInstance;
-import com.hazelcast.core.IAtomicLong;
-import com.hazelcast.core.IAtomicReference;
-import com.hazelcast.core.ICountDownLatch;
-import com.hazelcast.core.IExecutorService;
-import com.hazelcast.core.IList;
-import com.hazelcast.core.ILock;
-import com.hazelcast.core.IMap;
-import com.hazelcast.core.IQueue;
-import com.hazelcast.core.ISemaphore;
-import com.hazelcast.core.ISet;
-import com.hazelcast.core.ITopic;
-import com.hazelcast.core.IdGenerator;
-import com.hazelcast.core.LifecycleService;
-import com.hazelcast.core.MultiMap;
-import com.hazelcast.core.PartitionService;
-import com.hazelcast.core.ReplicatedMap;
-import com.hazelcast.crdt.pncounter.PNCounter;
-import com.hazelcast.crdt.pncounter.PNCounterService;
-import com.hazelcast.durableexecutor.DurableExecutorService;
-import com.hazelcast.durableexecutor.impl.DistributedDurableExecutorService;
-import com.hazelcast.executor.impl.DistributedExecutorService;
-import com.hazelcast.flakeidgen.FlakeIdGenerator;
-import com.hazelcast.flakeidgen.impl.FlakeIdGeneratorService;
-import com.hazelcast.instance.BuildInfoProvider;
-import com.hazelcast.internal.diagnostics.BuildInfoPlugin;
-import com.hazelcast.internal.diagnostics.ConfigPropertiesPlugin;
-import com.hazelcast.internal.diagnostics.Diagnostics;
-import com.hazelcast.internal.diagnostics.EventQueuePlugin;
-import com.hazelcast.internal.diagnostics.MetricsPlugin;
-import com.hazelcast.internal.diagnostics.NetworkingImbalancePlugin;
-import com.hazelcast.internal.diagnostics.SystemLogPlugin;
-import com.hazelcast.internal.diagnostics.SystemPropertiesPlugin;
-import com.hazelcast.internal.metrics.ProbeLevel;
-import com.hazelcast.internal.metrics.impl.MetricsRegistryImpl;
-import com.hazelcast.internal.metrics.metricsets.ClassLoadingMetricSet;
-import com.hazelcast.internal.metrics.metricsets.FileMetricSet;
-import com.hazelcast.internal.metrics.metricsets.GarbageCollectionMetricSet;
-import com.hazelcast.internal.metrics.metricsets.OperatingSystemMetricSet;
-import com.hazelcast.internal.metrics.metricsets.RuntimeMetricSet;
-import com.hazelcast.internal.metrics.metricsets.ThreadMetricSet;
-import com.hazelcast.internal.nearcache.NearCacheManager;
-import com.hazelcast.internal.serialization.InternalSerializationService;
-import com.hazelcast.logging.ILogger;
-import com.hazelcast.logging.LoggingService;
-import com.hazelcast.map.impl.MapService;
-import com.hazelcast.mapreduce.JobTracker;
-import com.hazelcast.mapreduce.impl.MapReduceService;
-import com.hazelcast.multimap.impl.MultiMapService;
-import com.hazelcast.nio.ClassLoaderUtil;
-import com.hazelcast.nio.Connection;
-import com.hazelcast.quorum.QuorumService;
-import com.hazelcast.replicatedmap.impl.ReplicatedMapService;
-import com.hazelcast.ringbuffer.Ringbuffer;
-import com.hazelcast.ringbuffer.impl.RingbufferService;
-import com.hazelcast.scheduledexecutor.IScheduledExecutorService;
-import com.hazelcast.scheduledexecutor.impl.DistributedScheduledExecutorService;
-import com.hazelcast.security.ICredentialsFactory;
-import com.hazelcast.spi.discovery.impl.DefaultDiscoveryServiceProvider;
-import com.hazelcast.spi.discovery.integration.DiscoveryMode;
-import com.hazelcast.spi.discovery.integration.DiscoveryService;
-import com.hazelcast.spi.discovery.integration.DiscoveryServiceProvider;
-import com.hazelcast.spi.discovery.integration.DiscoveryServiceSettings;
-import com.hazelcast.spi.impl.SerializationServiceSupport;
-import com.hazelcast.spi.properties.GroupProperty;
-import com.hazelcast.spi.properties.HazelcastProperties;
-import com.hazelcast.spi.serialization.SerializationService;
-import com.hazelcast.topic.impl.TopicService;
-import com.hazelcast.topic.impl.reliable.ReliableTopicService;
-import com.hazelcast.transaction.HazelcastXAResource;
-import com.hazelcast.transaction.TransactionContext;
-import com.hazelcast.transaction.TransactionException;
-import com.hazelcast.transaction.TransactionOptions;
-import com.hazelcast.transaction.TransactionalTask;
-import com.hazelcast.transaction.impl.xa.XAService;
-import com.hazelcast.util.ServiceLoader;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.Future;
-import java.util.concurrent.atomic.AtomicInteger;
-import static com.hazelcast.client.spi.properties.ClientProperty.DISCOVERY_SPI_ENABLED;
-import static com.hazelcast.client.spi.properties.ClientProperty.HAZELCAST_CLOUD_DISCOVERY_TOKEN;
-import static com.hazelcast.config.AliasedDiscoveryConfigUtils.allUsePublicAddress;
-import static com.hazelcast.util.ExceptionUtil.rethrow;
-import static com.hazelcast.util.Preconditions.checkNotNull;
-import static com.hazelcast.util.StringUtil.isNullOrEmpty;
-import static java.lang.System.currentTimeMillis;
-public class HazelcastClientInstanceImpl implements HazelcastInstance, SerializationServiceSupport {
-    private static final AtomicInteger CLIENT_ID = new AtomicInteger();
-    private static final short PROTOCOL_VERSION = ClientMessage.VERSION;
-    private final HazelcastProperties properties;
-    private final int id = CLIENT_ID.getAndIncrement();
-    private final String instanceName;
-    private final ClientConfig config;
-    private final LifecycleServiceImpl lifecycleService;
-    private final ClientConnectionManagerImpl connectionManager;
-    private final ClientClusterServiceImpl clusterService;
-    private final ClientPartitionServiceImpl partitionService;
-    private final AbstractClientInvocationService invocationService;
-    private final ClientExecutionServiceImpl executionService;
-    private final AbstractClientListenerService listenerService;
-    private final ClientTransactionManagerServiceImpl transactionManager;
-    private final NearCacheManager nearCacheManager;
-    private final ProxyManager proxyManager;
-    private final ConcurrentMap<String, Object> userContext;
-    private final LoadBalancer loadBalancer;
-    private final ClientExtension clientExtension;
-    private final ICredentialsFactory credentialsFactory;
-    private final DiscoveryService discoveryService;
-    private final LoggingService loggingService;
-    private final MetricsRegistryImpl metricsRegistry;
-    private final Statistics statistics;
-    private final Diagnostics diagnostics;
-    private final SerializationService serializationService;
-    private final ClientICacheManager hazelcastCacheManager;
-    private final ClientLockReferenceIdGenerator lockReferenceIdGenerator;
-    private final ClientExceptionFactory clientExceptionFactory;
-    private final ClientUserCodeDeploymentService userCodeDeploymentService;
-    public HazelcastClientInstanceImpl(ClientConfig config,
-                                       ClientConnectionManagerFactory clientConnectionManagerFactory,
-                                       AddressProvider externalAddressProvider) {
-        this.config = config;
-        if (config.getInstanceName() != null) {
-            instanceName = config.getInstanceName();
-        } else {
-            instanceName = "hz.client_" + id;
-        }
-        GroupConfig groupConfig = config.getGroupConfig();
-        String loggingType = config.getProperty(GroupProperty.LOGGING_TYPE.getName());
-        loggingService = new ClientLoggingService(groupConfig.getName(),
-                loggingType, BuildInfoProvider.getBuildInfo(), instanceName);
-        logGroupPasswordInfo();
-        ClassLoader classLoader = config.getClassLoader();
-        clientExtension = createClientInitializer(classLoader);
-        clientExtension.beforeStart(this);
-        credentialsFactory = initCredentialsFactory(config);
-        lifecycleService = new LifecycleServiceImpl(this);
-        properties = new HazelcastProperties(config.getProperties());
-        metricsRegistry = initMetricsRegistry();
-        serializationService = clientExtension.createSerializationService((byte) -1);
-        metricsRegistry.collectMetrics(clientExtension);
-        proxyManager = new ProxyManager(this);
-        executionService = initExecutionService();
-        metricsRegistry.collectMetrics(executionService);
-        loadBalancer = initLoadBalancer(config);
-        transactionManager = new ClientTransactionManagerServiceImpl(this, loadBalancer);
-        partitionService = new ClientPartitionServiceImpl(this);
-        discoveryService = initDiscoveryService(config);
-        Collection<AddressProvider> addressProviders = createAddressProviders(externalAddressProvider);
-        AddressTranslator addressTranslator = createAddressTranslator();
-        connectionManager = (ClientConnectionManagerImpl) clientConnectionManagerFactory
-                .createConnectionManager(this, addressTranslator, addressProviders);
-        clusterService = new ClientClusterServiceImpl(this);
-        invocationService = initInvocationService();
-        listenerService = initListenerService();
-        userContext = new ConcurrentHashMap<String, Object>();
-        userContext.putAll(config.getUserContext());
-        diagnostics = initDiagnostics();
-        hazelcastCacheManager = new ClientICacheManager(this);
-        lockReferenceIdGenerator = new ClientLockReferenceIdGenerator();
-        nearCacheManager = clientExtension.createNearCacheManager();
-        clientExceptionFactory = initClientExceptionFactory();
-        statistics = new Statistics(this);
-        userCodeDeploymentService = new ClientUserCodeDeploymentService(config.getUserCodeDeploymentConfig(), classLoader);
-    }
-    private int getConnectionTimeoutMillis() {
-        ClientNetworkConfig networkConfig = config.getNetworkConfig();
-        int connTimeout = networkConfig.getConnectionTimeout();
-        return connTimeout == 0 ? Integer.MAX_VALUE : connTimeout;
-    }
-    private Diagnostics initDiagnostics() {
-        String name = "diagnostics-client-" + id + "-" + currentTimeMillis();
-        ILogger logger = loggingService.getLogger(Diagnostics.class);
-        return new Diagnostics(name, logger, instanceName, properties);
-    }
-    private MetricsRegistryImpl initMetricsRegistry() {
-        ProbeLevel probeLevel = properties.getEnum(Diagnostics.METRICS_LEVEL, ProbeLevel.class);
-        ILogger logger = loggingService.getLogger(MetricsRegistryImpl.class);
-        MetricsRegistryImpl metricsRegistry = new MetricsRegistryImpl(getName(), logger, probeLevel);
-        RuntimeMetricSet.register(metricsRegistry);
-        GarbageCollectionMetricSet.register(metricsRegistry);
-        OperatingSystemMetricSet.register(metricsRegistry);
-        ThreadMetricSet.register(metricsRegistry);
-        ClassLoadingMetricSet.register(metricsRegistry);
-        FileMetricSet.register(metricsRegistry);
-        metricsRegistry.scanAndRegister(clientExtension.getMemoryStats(), "memory");
-        return metricsRegistry;
-    }
-    private Collection<AddressProvider> createAddressProviders(AddressProvider externalAddressProvider) {
-        ClientNetworkConfig networkConfig = getClientConfig().getNetworkConfig();
-        Collection<AddressProvider> addressProviders = new LinkedList<AddressProvider>();
-        if (externalAddressProvider != null) {
-            addressProviders.add(externalAddressProvider);
-        }
-        if (discoveryService != null) {
-            addressProviders.add(new DiscoveryAddressProvider(discoveryService, loggingService));
-        }
-        ClientCloudConfig cloudConfig = networkConfig.getCloudConfig();
-        HazelcastCloudAddressProvider cloudAddressProvider = initCloudAddressProvider(cloudConfig);
-        if (cloudAddressProvider != null) {
-            addressProviders.add(cloudAddressProvider);
-        }
-        addressProviders.add(new DefaultAddressProvider(networkConfig, addressProviders.isEmpty()));
-        return addressProviders;
-    }
-    private HazelcastCloudAddressProvider initCloudAddressProvider(ClientCloudConfig cloudConfig) {
-        if (cloudConfig.isEnabled()) {
-            String discoveryToken = cloudConfig.getDiscoveryToken();
-            String urlEndpoint = HazelcastCloudDiscovery.createUrlEndpoint(getProperties(), discoveryToken);
-            return new HazelcastCloudAddressProvider(urlEndpoint, getConnectionTimeoutMillis(), loggingService);
-        }
-        String cloudToken = properties.getString(ClientProperty.HAZELCAST_CLOUD_DISCOVERY_TOKEN);
-        if (cloudToken != null) {
-            String urlEndpoint = HazelcastCloudDiscovery.createUrlEndpoint(getProperties(), cloudToken);
-            return new HazelcastCloudAddressProvider(urlEndpoint, getConnectionTimeoutMillis(), loggingService);
-        }
-        return null;
-    }
-    private AddressTranslator createAddressTranslator() {
-        ClientNetworkConfig networkConfig = getClientConfig().getNetworkConfig();
-        ClientCloudConfig cloudConfig = networkConfig.getCloudConfig();
-        List<String> addresses = networkConfig.getAddresses();
-        boolean addressListProvided = addresses.size() != 0;
-        boolean awsDiscoveryEnabled = networkConfig.getAwsConfig() != null && networkConfig.getAwsConfig().isEnabled();
-        boolean gcpDiscoveryEnabled = networkConfig.getGcpConfig() != null && networkConfig.getGcpConfig().isEnabled();
-        boolean azureDiscoveryEnabled = networkConfig.getAzureConfig() != null && networkConfig.getAzureConfig().isEnabled();
-        boolean kubernetesDiscoveryEnabled = networkConfig.getKubernetesConfig() != null
-                && networkConfig.getKubernetesConfig().isEnabled();
-        boolean eurekaDiscoveryEnabled = networkConfig.getEurekaConfig() != null && networkConfig.getEurekaConfig().isEnabled();
-        boolean discoverySpiEnabled = discoverySpiEnabled(networkConfig);
-        String cloudDiscoveryToken = properties.getString(HAZELCAST_CLOUD_DISCOVERY_TOKEN);
-        if (cloudDiscoveryToken != null && cloudConfig.isEnabled()) {
-            throw new IllegalStateException("Ambiguous hazelcast.cloud configuration. "
-                    + "Both property based and client configuration based settings are provided for "
-                    + "Hazelcast cloud discovery together. Use only one.");
-        }
-        boolean hazelcastCloudEnabled = cloudDiscoveryToken != null || cloudConfig.isEnabled();
-        isDiscoveryConfigurationConsistent(addressListProvided, awsDiscoveryEnabled, gcpDiscoveryEnabled, azureDiscoveryEnabled,
-                kubernetesDiscoveryEnabled, eurekaDiscoveryEnabled, discoverySpiEnabled, hazelcastCloudEnabled);
-        if (discoveryService != null) {
-            return new DiscoveryAddressTranslator(discoveryService, usePublicAddress(config));
-        } else if (hazelcastCloudEnabled) {
-            String discoveryToken;
-            if (cloudConfig.isEnabled()) {
-                discoveryToken = cloudConfig.getDiscoveryToken();
-            } else {
-                discoveryToken = cloudDiscoveryToken;
-            }
-            String urlEndpoint = HazelcastCloudDiscovery.createUrlEndpoint(getProperties(), discoveryToken);
-            return new HazelcastCloudAddressTranslator(urlEndpoint, getConnectionTimeoutMillis(), loggingService);
-        }
-        return new DefaultAddressTranslator();
-    }
-    private boolean discoverySpiEnabled(ClientNetworkConfig networkConfig) {
-        return (networkConfig.getDiscoveryConfig() != null && networkConfig.getDiscoveryConfig().isEnabled())
-                || Boolean.parseBoolean(properties.getString(DISCOVERY_SPI_ENABLED));
-    }
-    private boolean usePublicAddress(ClientConfig config) {
-        return getProperties().getBoolean(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED)
-                || allUsePublicAddress(ClientAliasedDiscoveryConfigUtils.aliasedDiscoveryConfigsFrom(config));
-    }
-    @SuppressWarnings({"checkstyle:booleanexpressioncomplexity", "checkstyle:npathcomplexity"})
-    private void isDiscoveryConfigurationConsistent(boolean addressListProvided, boolean awsDiscoveryEnabled,
-                                                    boolean gcpDiscoveryEnabled, boolean azureDiscoveryEnabled,
-                                                    boolean kubernetesDiscoveryEnabled, boolean eurekaDiscoveryEnabled,
-                                                    boolean discoverySpiEnabled, boolean hazelcastCloudEnabled) {
-        int count = 0;
-        if (addressListProvided) {
-            count++;
-        }
-        if (awsDiscoveryEnabled) {
-            count++;
-        }
-        if (gcpDiscoveryEnabled) {
-            count++;
-        }
-        if (azureDiscoveryEnabled) {
-            count++;
-        }
-        if (kubernetesDiscoveryEnabled) {
-            count++;
-        }
-        if (eurekaDiscoveryEnabled) {
-            count++;
-        }
-        if (discoverySpiEnabled) {
-            count++;
-        }
-        if (hazelcastCloudEnabled) {
-            count++;
-        }
-        if (count > 1) {
-            throw new IllegalStateException("Only one discovery method can be enabled at a time. "
-                    + "cluster members given explicitly : " + addressListProvided
-                    + ", aws discovery: " + awsDiscoveryEnabled
-                    + ", gcp discovery: " + gcpDiscoveryEnabled
-                    + ", azure discovery: " + azureDiscoveryEnabled
-                    + ", kubernetes discovery: " + kubernetesDiscoveryEnabled
-                    + ", eureka discovery: " + eurekaDiscoveryEnabled
-                    + ", discovery spi enabled : " + discoverySpiEnabled
-                    + ", hazelcast.cloud enabled : " + hazelcastCloudEnabled);
-        }
-    }
-    private DiscoveryService initDiscoveryService(ClientConfig config) {
-        List<DiscoveryStrategyConfig> aliasedDiscoveryConfigs =
-                ClientAliasedDiscoveryConfigUtils.createDiscoveryStrategyConfigs(config);
-        if (!properties.getBoolean(ClientProperty.DISCOVERY_SPI_ENABLED) && aliasedDiscoveryConfigs.isEmpty()) {
-            return null;
-        }
-        ILogger logger = loggingService.getLogger(DiscoveryService.class);
-        ClientNetworkConfig networkConfig = config.getNetworkConfig();
-        DiscoveryConfig discoveryConfig = networkConfig.getDiscoveryConfig().getAsReadOnly();
-        DiscoveryServiceProvider factory = discoveryConfig.getDiscoveryServiceProvider();
-        if (factory == null) {
-            factory = new DefaultDiscoveryServiceProvider();
-        }
-        DiscoveryServiceSettings settings = new DiscoveryServiceSettings()
-                .setConfigClassLoader(config.getClassLoader())
-                .setLogger(logger)
-                .setDiscoveryMode(DiscoveryMode.Client)
-                .setAliasedDiscoveryConfigs(aliasedDiscoveryConfigs)
-                .setDiscoveryConfig(discoveryConfig);
-        DiscoveryService discoveryService = factory.newDiscoveryService(settings);
-        discoveryService.start();
-        return discoveryService;
-    }
-    private LoadBalancer initLoadBalancer(ClientConfig config) {
-        LoadBalancer lb = config.getLoadBalancer();
-        if (lb == null) {
-            lb = new RoundRobinLB();
-        }
-        return lb;
-    }
-    private ICredentialsFactory initCredentialsFactory(ClientConfig config) {
-        ClientSecurityConfig securityConfig = config.getSecurityConfig();
-        validateSecurityConfig(securityConfig);
-        ICredentialsFactory c = getCredentialsFromFactory(config);
-        if (c == null) {
-            return new DefaultCredentialsFactory(securityConfig, config.getGroupConfig(), config.getClassLoader());
-        }
-        return c;
-    }
-    private void validateSecurityConfig(ClientSecurityConfig securityConfig) {
-        boolean configuredViaCredentials = securityConfig.getCredentials() != null
-                || securityConfig.getCredentialsClassname() != null;
-        CredentialsFactoryConfig factoryConfig = securityConfig.getCredentialsFactoryConfig();
-        boolean configuredViaCredentialsFactory = factoryConfig.getClassName() != null
-                || factoryConfig.getImplementation() != null;
-        if (configuredViaCredentials && configuredViaCredentialsFactory) {
-            throw new IllegalStateException("Ambiguous Credentials config. Set only one of Credentials or ICredentialsFactory");
-        }
-    }
-    private ICredentialsFactory getCredentialsFromFactory(ClientConfig config) {
-        CredentialsFactoryConfig credentialsFactoryConfig = config.getSecurityConfig().getCredentialsFactoryConfig();
-        ICredentialsFactory factory = credentialsFactoryConfig.getImplementation();
-        if (factory == null) {
-            String factoryClassName = credentialsFactoryConfig.getClassName();
-            if (factoryClassName != null) {
-                try {
-                    factory = ClassLoaderUtil.newInstance(config.getClassLoader(), factoryClassName);
-                } catch (Exception e) {
-                    throw rethrow(e);
-                }
-            }
-        }
-        if (factory == null) {
-            return null;
-        }
-        factory.configure(config.getGroupConfig(), credentialsFactoryConfig.getProperties());
-        return factory;
-    }
-    @SuppressWarnings("checkstyle:illegaltype")
-    private AbstractClientInvocationService initInvocationService() {
-        final ClientNetworkConfig networkConfig = config.getNetworkConfig();
-        if (networkConfig.isSmartRouting()) {
-            return new SmartClientInvocationService(this, loadBalancer);
-        } else {
-            return new NonSmartClientInvocationService(this);
-        }
-    }
-    public int getId() {
-        return id;
-    }
-    private ClientExtension createClientInitializer(ClassLoader classLoader) {
-        try {
-            String factoryId = ClientExtension.class.getName();
-            Iterator<ClientExtension> iter = ServiceLoader.iterator(ClientExtension.class, factoryId, classLoader);
-            while (iter.hasNext()) {
-                ClientExtension initializer = iter.next();
-                if (!(initializer.getClass().equals(DefaultClientExtension.class))) {
-                    return initializer;
-                }
-            }
-        } catch (Exception e) {
-            throw rethrow(e);
-        }
-        return new DefaultClientExtension();
-    }
-    @SuppressWarnings("checkstyle:illegaltype")
-    private AbstractClientListenerService initListenerService() {
-        int eventQueueCapacity = properties.getInteger(ClientProperty.EVENT_QUEUE_CAPACITY);
-        int eventThreadCount = properties.getInteger(ClientProperty.EVENT_THREAD_COUNT);
-        final ClientNetworkConfig networkConfig = config.getNetworkConfig();
-        if (networkConfig.isSmartRouting()) {
-            return new SmartClientListenerService(this, eventThreadCount, eventQueueCapacity);
-        } else {
-            return new NonSmartClientListenerService(this, eventThreadCount, eventQueueCapacity);
-        }
-    }
-    private ClientExecutionServiceImpl initExecutionService() {
-        return new ClientExecutionServiceImpl(instanceName,
-                config.getClassLoader(), properties, config.getExecutorPoolSize(), loggingService);
-    }
-    private void logGroupPasswordInfo() {
-        if (!isNullOrEmpty(config.getGroupConfig().getPassword())) {
-            ILogger logger = loggingService.getLogger(HazelcastClient.class);
-            logger.info("A non-empty group password is configured for the Hazelcast client."
-                    + " Starting with Hazelcast version 3.11, clients with the same group name,"
-                    + " but with different group passwords (that do not use authentication) will be accepted to a cluster."
-                    + " The group password configuration will be removed completely in a future release.");
-        }
-    }
-    public void start() {
-        lifecycleService.setStarted();
-        invocationService.start();
-        clusterService.start();
-        ClientContext clientContext = new ClientContext(this);
-        try {
-            userCodeDeploymentService.start();
-            connectionManager.start(clientContext);
-        } catch (Exception e) {
-            throw rethrow(e);
-        }
-        diagnostics.start();
-        diagnostics.register(
-                new BuildInfoPlugin(loggingService.getLogger(BuildInfoPlugin.class)));
-        diagnostics.register(
-                new ConfigPropertiesPlugin(loggingService.getLogger(ConfigPropertiesPlugin.class), properties));
-        diagnostics.register(
-                new SystemPropertiesPlugin(loggingService.getLogger(SystemPropertiesPlugin.class)));
-        diagnostics.register(
-                new MetricsPlugin(loggingService.getLogger(MetricsPlugin.class), metricsRegistry, properties));
-        diagnostics.register(
-                new SystemLogPlugin(properties, connectionManager, this, loggingService.getLogger(SystemLogPlugin.class)));
-        diagnostics.register(
-                new NetworkingImbalancePlugin(properties, connectionManager.getNetworking(),
-                        loggingService.getLogger(NetworkingImbalancePlugin.class)));
-        diagnostics.register(
-                new EventQueuePlugin(loggingService.getLogger(EventQueuePlugin.class), listenerService.getEventExecutor(),
-                        properties));
-        metricsRegistry.collectMetrics(listenerService);
-        proxyManager.init(config, clientContext);
-        listenerService.start();
-        loadBalancer.init(getCluster(), config);
-        partitionService.start();
-        statistics.start();
-        clientExtension.afterStart(this);
-    }
-    public void onClusterConnect(Connection ownerConnection) throws Exception {
-        partitionService.listenPartitionTable(ownerConnection);
-        clusterService.listenMembershipEvents(ownerConnection);
-        userCodeDeploymentService.deploy(this, ownerConnection);
-        proxyManager.createDistributedObjectsOnCluster(ownerConnection);
-    }
-    public MetricsRegistryImpl getMetricsRegistry() {
-        return metricsRegistry;
-    }
-    @Override
-    public HazelcastXAResource getXAResource() {
-        return getDistributedObject(XAService.SERVICE_NAME, XAService.SERVICE_NAME);
-    }
-    @Override
-    public Config getConfig() {
-        return new ClientDynamicClusterConfig(this);
-    }
-    public HazelcastProperties getProperties() {
-        return properties;
-    }
-    @Override
-    public String getName() {
-        return instanceName;
-    }
-    @Override
-    public <E> IQueue<E> getQueue(String name) {
-        checkNotNull(name, "Retrieving a queue instance with a null name is not allowed!");
-        return getDistributedObject(QueueService.SERVICE_NAME, name);
-    }
-    @Override
-    public <E> ITopic<E> getTopic(String name) {
-        checkNotNull(name, "Retrieving a topic instance with a null name is not allowed!");
-        return getDistributedObject(TopicService.SERVICE_NAME, name);
-    }
-    @Override
-    public <E> ISet<E> getSet(String name) {
-        checkNotNull(name, "Retrieving a set instance with a null name is not allowed!");
-        return getDistributedObject(SetService.SERVICE_NAME, name);
-    }
-    @Override
-    public <E> IList<E> getList(String name) {
-        checkNotNull(name, "Retrieving a list instance with a null name is not allowed!");
-        return getDistributedObject(ListService.SERVICE_NAME, name);
-    }
-    @Override
-    public <K, V> IMap<K, V> getMap(String name) {
-        checkNotNull(name, "Retrieving a map instance with a null name is not allowed!");
-        return getDistributedObject(MapService.SERVICE_NAME, name);
-    }
-    @Override
-    public <K, V> MultiMap<K, V> getMultiMap(String name) {
-        checkNotNull(name, "Retrieving a multi-map instance with a null name is not allowed!");
-        return getDistributedObject(MultiMapService.SERVICE_NAME, name);
-    }
-    @Override
-    public <K, V> ReplicatedMap<K, V> getReplicatedMap(String name) {
-        checkNotNull(name, "Retrieving a replicated map instance with a null name is not allowed!");
-        return getDistributedObject(ReplicatedMapService.SERVICE_NAME, name);
-    }
-    @Override
-    public JobTracker getJobTracker(String name) {
-        checkNotNull(name, "Retrieving a job tracker instance with a null name is not allowed!");
-        return getDistributedObject(MapReduceService.SERVICE_NAME, name);
-    }
-    @Override
-    public ILock getLock(String key) {
-        checkNotNull(key, "Retrieving a lock instance with a null key is not allowed!");
-        return getDistributedObject(LockServiceImpl.SERVICE_NAME, key);
-    }
-    @Override
-    public <E> ITopic<E> getReliableTopic(String name) {
-        checkNotNull(name, "Retrieving a topic instance with a null name is not allowed!");
-        return getDistributedObject(ReliableTopicService.SERVICE_NAME, name);
-    }
-    @Override
-    public <E> Ringbuffer<E> getRingbuffer(String name) {
-        checkNotNull(name, "Retrieving a ringbuffer instance with a null name is not allowed!");
-        return getDistributedObject(RingbufferService.SERVICE_NAME, name);
-    }
-    @Override
-    public ClientICacheManager getCacheManager() {
-        return hazelcastCacheManager;
-    }
-    @Override
-    public Cluster getCluster() {
-        return new ClientClusterProxy(clusterService);
-    }
-    @Override
-    public Client getLocalEndpoint() {
-        return clusterService.getLocalClient();
-    }
-    @Override
-    public IExecutorService getExecutorService(String name) {
-        checkNotNull(name, "Retrieving an executor instance with a null name is not allowed!");
-        return getDistributedObject(DistributedExecutorService.SERVICE_NAME, name);
-    }
-    @Override
-    public DurableExecutorService getDurableExecutorService(String name) {
-        checkNotNull(name, "Retrieving a durable executor instance with a null name is not allowed!");
-        return getDistributedObject(DistributedDurableExecutorService.SERVICE_NAME, name);
-    }
-    @Override
-    public <T> T executeTransaction(TransactionalTask<T> task) throws TransactionException {
-        return transactionManager.executeTransaction(task);
-    }
-    @Override
-    public <T> T executeTransaction(TransactionOptions options, TransactionalTask<T> task) throws TransactionException {
-        return transactionManager.executeTransaction(options, task);
-    }
-    @Override
-    public TransactionContext newTransactionContext() {
-        return transactionManager.newTransactionContext();
-    }
-    @Override
-    public TransactionContext newTransactionContext(TransactionOptions options) {
-        return transactionManager.newTransactionContext(options);
-    }
-    public ClientTransactionManagerService getTransactionManager() {
-        return transactionManager;
-    }
-    @Override
-    public IdGenerator getIdGenerator(String name) {
-        checkNotNull(name, "Retrieving an ID-generator instance with a null name is not allowed!");
-        return getDistributedObject(IdGeneratorService.SERVICE_NAME, name);
-    }
-    @Override
-    public FlakeIdGenerator getFlakeIdGenerator(String name) {
-        checkNotNull(name, "Retrieving a Flake ID-generator instance with a null name is not allowed!");
-        return getDistributedObject(FlakeIdGeneratorService.SERVICE_NAME, name);
-    }
-    @Override
-    public IAtomicLong getAtomicLong(String name) {
-        checkNotNull(name, "Retrieving an atomic-long instance with a null name is not allowed!");
-        return getDistributedObject(AtomicLongService.SERVICE_NAME, name);
-    }
-    @Override
-    public CardinalityEstimator getCardinalityEstimator(String name) {
-        checkNotNull(name, "Retrieving a cardinality estimator instance with a null name is not allowed!");
-        return getDistributedObject(CardinalityEstimatorService.SERVICE_NAME, name);
-    }
-    @Override
-    public PNCounter getPNCounter(String name) {
-        checkNotNull(name, "Retrieving a PN counter instance with a null name is not allowed!");
-        return getDistributedObject(PNCounterService.SERVICE_NAME, name);
-    }
-    @Override
-    public <E> IAtomicReference<E> getAtomicReference(String name) {
-        checkNotNull(name, "Retrieving an atomic-reference instance with a null name is not allowed!");
-        return getDistributedObject(AtomicReferenceService.SERVICE_NAME, name);
-    }
-    @Override
-    public ICountDownLatch getCountDownLatch(String name) {
-        checkNotNull(name, "Retrieving a countdown-latch instance with a null name is not allowed!");
-        return getDistributedObject(CountDownLatchService.SERVICE_NAME, name);
-    }
-    @Override
-    public ISemaphore getSemaphore(String name) {
-        checkNotNull(name, "Retrieving a semaphore instance with a null name is not allowed!");
-        return getDistributedObject(SemaphoreService.SERVICE_NAME, name);
-    }
-    @Override
-    public IScheduledExecutorService getScheduledExecutorService(String name) {
-        checkNotNull(name, "Retrieving a scheduled executor instance with a null name is not allowed!");
-        return getDistributedObject(DistributedScheduledExecutorService.SERVICE_NAME, name);
-    }
-    @Override
-    public Collection<DistributedObject> getDistributedObjects() {
-        try {
-            ClientMessage request = ClientGetDistributedObjectsCodec.encodeRequest();
-            final Future<ClientMessage> future = new ClientInvocation(this, request, getName()).invoke();
-            ClientMessage response = future.get();
-            ClientGetDistributedObjectsCodec.ResponseParameters resultParameters =
-                    ClientGetDistributedObjectsCodec.decodeResponse(response);
-            Collection<? extends DistributedObject> distributedObjects = proxyManager.getDistributedObjects();
-            Set<DistributedObjectInfo> localDistributedObjects = new HashSet<DistributedObjectInfo>();
-            for (DistributedObject localInfo : distributedObjects) {
-                localDistributedObjects.add(new DistributedObjectInfo(localInfo.getServiceName(), localInfo.getName()));
-            }
-            Collection<DistributedObjectInfo> newDistributedObjectInfo = resultParameters.response;
-            for (DistributedObjectInfo distributedObjectInfo : newDistributedObjectInfo) {
-                localDistributedObjects.remove(distributedObjectInfo);
-                getDistributedObject(distributedObjectInfo.getServiceName(), distributedObjectInfo.getName());
-            }
-            for (DistributedObjectInfo distributedObjectInfo : localDistributedObjects) {
-                proxyManager.destroyProxyLocally(distributedObjectInfo.getServiceName(), distributedObjectInfo.getName());
-            }
-            return (Collection<DistributedObject>) proxyManager.getDistributedObjects();
-        } catch (Exception e) {
-            throw rethrow(e);
-        }
-    }
-    @Override
-    public String addDistributedObjectListener(DistributedObjectListener distributedObjectListener) {
-        return proxyManager.addDistributedObjectListener(distributedObjectListener);
-    }
-    @Override
-    public boolean removeDistributedObjectListener(String registrationId) {
-        return proxyManager.removeDistributedObjectListener(registrationId);
-    }
-    @Override
-    public PartitionService getPartitionService() {
-        return new PartitionServiceProxy(partitionService, listenerService);
-    }
-    @Override
-    public QuorumService getQuorumService() {
-        throw new UnsupportedOperationException();
-    }
-    @Override
-    public ClientService getClientService() {
-        throw new UnsupportedOperationException();
-    }
-    @Override
-    public LoggingService getLoggingService() {
-        return loggingService;
-    }
-    @Override
-    public LifecycleService getLifecycleService() {
-        return lifecycleService;
-    }
-    @Override
-    public <T extends DistributedObject> T getDistributedObject(String serviceName, String name) {
-        return (T) proxyManager.getOrCreateProxy(serviceName, name);
-    }
-    @Override
-    public ConcurrentMap<String, Object> getUserContext() {
-        return userContext;
-    }
-    public ClientConfig getClientConfig() {
-        return config;
-    }
-    @Override
-    public SerializationService getSerializationService() {
-        return serializationService;
-    }
-    public ClientUserCodeDeploymentService getUserCodeDeploymentService() {
-        return userCodeDeploymentService;
-    }
-    public ProxyManager getProxyManager() {
-        return proxyManager;
-    }
-    public ClientConnectionManager getConnectionManager() {
-        return connectionManager;
-    }
-    public ClientClusterService getClientClusterService() {
-        return clusterService;
-    }
-    public ClientExecutionService getClientExecutionService() {
-        return executionService;
-    }
-    public ClientPartitionService getClientPartitionService() {
-        return partitionService;
-    }
-    public ClientInvocationService getInvocationService() {
-        return invocationService;
-    }
-    public ClientListenerService getListenerService() {
-        return listenerService;
-    }
-    public NearCacheManager getNearCacheManager() {
-        return nearCacheManager;
-    }
-    public LoadBalancer getLoadBalancer() {
-        return loadBalancer;
-    }
-    public ClientExtension getClientExtension() {
-        return clientExtension;
-    }
-    public ICredentialsFactory getCredentialsFactory() {
-        return credentialsFactory;
-    }
-    public short getProtocolVersion() {
-        return PROTOCOL_VERSION;
-    }
-    @Override
-    public void shutdown() {
-        getLifecycleService().shutdown();
-    }
-    public void doShutdown() {
-        proxyManager.destroy();
-        connectionManager.shutdown();
-        clusterService.shutdown();
-        partitionService.stop();
-        transactionManager.shutdown();
-        invocationService.shutdown();
-        executionService.shutdown();
-        listenerService.shutdown();
-        nearCacheManager.destroyAllNearCaches();
-        if (discoveryService != null) {
-            discoveryService.destroy();
-        }
-        metricsRegistry.shutdown();
-        diagnostics.shutdown();
-        ((InternalSerializationService) serializationService).dispose();
-    }
-    public ClientLockReferenceIdGenerator getLockReferenceIdGenerator() {
-        return lockReferenceIdGenerator;
-    }
-    private ClientExceptionFactory initClientExceptionFactory() {
-        boolean jCacheAvailable = JCacheDetector.isJCacheAvailable(getClientConfig().getClassLoader());
-        return new ClientExceptionFactory(jCacheAvailable);
-    }
-    public ClientExceptionFactory getClientExceptionFactory() {
-        return clientExceptionFactory;
-    }
-}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/HazelcastClientManagedContext.java
+++ b//dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.hazelcast.client.impl.clientside;
-import com.hazelcast.core.HazelcastInstanceAware;
-import com.hazelcast.core.ManagedContext;
-import com.hazelcast.spi.serialization.SerializationServiceAware;
-final class HazelcastClientManagedContext implements ManagedContext {
-    private final HazelcastClientInstanceImpl instance;
-    private final ManagedContext externalContext;
-    private final boolean hasExternalContext;
-    public HazelcastClientManagedContext(HazelcastClientInstanceImpl instance, ManagedContext externalContext) {
-        this.instance = instance;
-        this.externalContext = externalContext;
-        this.hasExternalContext = externalContext != null;
-    }
-    @Override
-    public Object initialize(Object obj) {
-        Object object = obj;
-        if (object instanceof HazelcastInstanceAware) {
-            ((HazelcastInstanceAware) object).setHazelcastInstance(instance);
-        }
-        if (object instanceof SerializationServiceAware) {
-            ((SerializationServiceAware) object).setSerializationService(instance.getSerializationService());
-        }
-        if (hasExternalContext) {
-            object = externalContext.initialize(object);
-        }
-        return object;
-    }
-}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/HazelcastClientProxy.java
+++ b//dev/null
@@ -1,267 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.hazelcast.client.impl.clientside;
-import com.hazelcast.cardinality.CardinalityEstimator;
-import com.hazelcast.client.HazelcastClientNotActiveException;
-import com.hazelcast.client.config.ClientConfig;
-import com.hazelcast.config.Config;
-import com.hazelcast.core.Client;
-import com.hazelcast.core.ClientService;
-import com.hazelcast.core.Cluster;
-import com.hazelcast.core.DistributedObject;
-import com.hazelcast.core.DistributedObjectListener;
-import com.hazelcast.core.HazelcastInstance;
-import com.hazelcast.core.IAtomicLong;
-import com.hazelcast.core.IAtomicReference;
-import com.hazelcast.core.ICacheManager;
-import com.hazelcast.core.ICountDownLatch;
-import com.hazelcast.core.IExecutorService;
-import com.hazelcast.core.IList;
-import com.hazelcast.core.ILock;
-import com.hazelcast.core.IMap;
-import com.hazelcast.core.IQueue;
-import com.hazelcast.core.ISemaphore;
-import com.hazelcast.core.ISet;
-import com.hazelcast.core.ITopic;
-import com.hazelcast.core.IdGenerator;
-import com.hazelcast.core.LifecycleService;
-import com.hazelcast.core.MultiMap;
-import com.hazelcast.core.PartitionService;
-import com.hazelcast.core.ReplicatedMap;
-import com.hazelcast.crdt.pncounter.PNCounter;
-import com.hazelcast.durableexecutor.DurableExecutorService;
-import com.hazelcast.flakeidgen.FlakeIdGenerator;
-import com.hazelcast.instance.TerminatedLifecycleService;
-import com.hazelcast.logging.LoggingService;
-import com.hazelcast.mapreduce.JobTracker;
-import com.hazelcast.quorum.QuorumService;
-import com.hazelcast.ringbuffer.Ringbuffer;
-import com.hazelcast.scheduledexecutor.IScheduledExecutorService;
-import com.hazelcast.spi.impl.SerializationServiceSupport;
-import com.hazelcast.spi.serialization.SerializationService;
-import com.hazelcast.transaction.HazelcastXAResource;
-import com.hazelcast.transaction.TransactionContext;
-import com.hazelcast.transaction.TransactionException;
-import com.hazelcast.transaction.TransactionOptions;
-import com.hazelcast.transaction.TransactionalTask;
-import java.util.Collection;
-import java.util.concurrent.ConcurrentMap;
-/**
- * A client-side proxy {@link com.hazelcast.core.HazelcastInstance} instance.
- */
-@SuppressWarnings("checkstyle:classfanoutcomplexity")
-public class HazelcastClientProxy implements HazelcastInstance, SerializationServiceSupport {
-    public volatile HazelcastClientInstanceImpl client;
-    public HazelcastClientProxy(HazelcastClientInstanceImpl client) {
-        this.client = client;
-    }
-    @Override
-    public Config getConfig() {
-        return getClient().getConfig();
-    }
-    @Override
-    public String getName() {
-        return getClient().getName();
-    }
-    @Override
-    public <E> Ringbuffer<E> getRingbuffer(String name) {
-        return getClient().getRingbuffer(name);
-    }
-    @Override
-    public <E> IQueue<E> getQueue(String name) {
-        return getClient().getQueue(name);
-    }
-    @Override
-    public <E> ITopic<E> getTopic(String name) {
-        return getClient().getTopic(name);
-    }
-    @Override
-    public <E> ITopic<E> getReliableTopic(String name) {
-        return getClient().getReliableTopic(name);
-    }
-    @Override
-    public <E> ISet<E> getSet(String name) {
-        return getClient().getSet(name);
-    }
-    @Override
-    public <E> IList<E> getList(String name) {
-        return getClient().getList(name);
-    }
-    @Override
-    public <K, V> IMap<K, V> getMap(String name) {
-        return getClient().getMap(name);
-    }
-    @Override
-    public <K, V> MultiMap<K, V> getMultiMap(String name) {
-        return getClient().getMultiMap(name);
-    }
-    @Override
-    public <K, V> ReplicatedMap<K, V> getReplicatedMap(String name) {
-        return getClient().getReplicatedMap(name);
-    }
-    @Override
-    public JobTracker getJobTracker(String name) {
-        return getClient().getJobTracker(name);
-    }
-    @Override
-    public ILock getLock(String key) {
-        return getClient().getLock(key);
-    }
-    @Override
-    public ICacheManager getCacheManager() {
-        return getClient().getCacheManager();
-    }
-    @Override
-    public Cluster getCluster() {
-        return getClient().getCluster();
-    }
-    @Override
-    public Client getLocalEndpoint() {
-        return getClient().getLocalEndpoint();
-    }
-    @Override
-    public IExecutorService getExecutorService(String name) {
-        return getClient().getExecutorService(name);
-    }
-    @Override
-    public DurableExecutorService getDurableExecutorService(String name) {
-        return getClient().getDurableExecutorService(name);
-    }
-    @Override
-    public <T> T executeTransaction(TransactionalTask<T> task)
-            throws TransactionException {
-        return getClient().executeTransaction(task);
-    }
-    @Override
-    public <T> T executeTransaction(TransactionOptions options, TransactionalTask<T> task)
-            throws TransactionException {
-        return getClient().executeTransaction(options, task);
-    }
-    @Override
-    public TransactionContext newTransactionContext() {
-        return getClient().newTransactionContext();
-    }
-    @Override
-    public TransactionContext newTransactionContext(TransactionOptions options) {
-        return getClient().newTransactionContext(options);
-    }
-    @Override
-    public IdGenerator getIdGenerator(String name) {
-        return getClient().getIdGenerator(name);
-    }
-    @Override
-    public FlakeIdGenerator getFlakeIdGenerator(String name) {
-        return getClient().getFlakeIdGenerator(name);
-    }
-    @Override
-    public IAtomicLong getAtomicLong(String name) {
-        return getClient().getAtomicLong(name);
-    }
-    @Override
-    public <E> IAtomicReference<E> getAtomicReference(String name) {
-        return getClient().getAtomicReference(name);
-    }
-    @Override
-    public ICountDownLatch getCountDownLatch(String name) {
-        return getClient().getCountDownLatch(name);
-    }
-    @Override
-    public ISemaphore getSemaphore(String name) {
-        return getClient().getSemaphore(name);
-    }
-    @Override
-    public CardinalityEstimator getCardinalityEstimator(String name) {
-        return getClient().getCardinalityEstimator(name);
-    }
-    @Override
-    public PNCounter getPNCounter(String name) {
-        return getClient().getPNCounter(name);
-    }
-    @Override
-    public IScheduledExecutorService getScheduledExecutorService(String name) {
-        return getClient().getScheduledExecutorService(name);
-    }
-    @Override
-    public Collection<DistributedObject> getDistributedObjects() {
-        return getClient().getDistributedObjects();
-    }
-    @Override
-    public String addDistributedObjectListener(DistributedObjectListener distributedObjectListener) {
-        return getClient().addDistributedObjectListener(distributedObjectListener);
-    }
-    @Override
-    public boolean removeDistributedObjectListener(String registrationId) {
-        return getClient().removeDistributedObjectListener(registrationId);
-    }
-    @Override
-    public PartitionService getPartitionService() {
-        return getClient().getPartitionService();
-    }
-    @Override
-    public QuorumService getQuorumService() {
-        throw new UnsupportedOperationException();
-    }
-    @Override
-    public ClientService getClientService() {
-        return getClient().getClientService();
-    }
-    @Override
-    public LoggingService getLoggingService() {
-        return getClient().getLoggingService();
-    }
-    @Override
-    public LifecycleService getLifecycleService() {
-        final HazelcastClientInstanceImpl hz = client;
-        return hz != null ? hz.getLifecycleService() : new TerminatedLifecycleService();
-    }
-    @Override
-    public <T extends DistributedObject> T getDistributedObject(String serviceName, String name) {
-        return getClient().getDistributedObject(serviceName, name);
-    }
-    @Override
-    public ConcurrentMap<String, Object> getUserContext() {
-        return getClient().getUserContext();
-    }
-    public ClientConfig getClientConfig() {
-        return getClient().getClientConfig();
-    }
-    @Override
-    public HazelcastXAResource getXAResource() {
-        return getClient().getXAResource();
-    }
-    @Override
-    public void shutdown() {
-        getLifecycleService().shutdown();
-    }
-    @Override
-    public SerializationService getSerializationService() {
-        return getClient().getSerializationService();
-    }
-    protected HazelcastClientInstanceImpl getClient() {
-        final HazelcastClientInstanceImpl c = client;
-        if (c == null || !c.getLifecycleService().isRunning()) {
-            throw new HazelcastClientNotActiveException("Client is not active.");
-        }
-        return c;
-    }
-    public String toString() {
-        final HazelcastClientInstanceImpl hazelcastInstance = client;
-        if (hazelcastInstance != null) {
-            return hazelcastInstance.toString();
-        }
-        return "HazelcastClientInstance {NOT ACTIVE}";
-    }
-}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/LifecycleServiceImpl.java
+++ b//dev/null
@@ -1,154 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.hazelcast.client.impl.clientside;
-import com.hazelcast.client.HazelcastClient;
-import com.hazelcast.config.ListenerConfig;
-import com.hazelcast.core.LifecycleEvent;
-import com.hazelcast.core.LifecycleListener;
-import com.hazelcast.core.LifecycleService;
-import com.hazelcast.instance.BuildInfo;
-import com.hazelcast.instance.BuildInfoProvider;
-import com.hazelcast.logging.ILogger;
-import com.hazelcast.nio.ClassLoaderUtil;
-import com.hazelcast.util.UuidUtil;
-import com.hazelcast.util.executor.PoolExecutorThreadFactory;
-import java.util.EventListener;
-import java.util.List;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import static com.hazelcast.core.LifecycleEvent.LifecycleState.SHUTDOWN;
-import static com.hazelcast.core.LifecycleEvent.LifecycleState.SHUTTING_DOWN;
-import static com.hazelcast.core.LifecycleEvent.LifecycleState.STARTED;
-import static com.hazelcast.core.LifecycleEvent.LifecycleState.STARTING;
-import static com.hazelcast.util.StringUtil.isNullOrEmpty;
-/**
- * Default {@link com.hazelcast.core.LifecycleService} implementation for the client.
- */
-public final class LifecycleServiceImpl implements LifecycleService {
-    private static final long TERMINATE_TIMEOUT_SECONDS = 30;
-    private final HazelcastClientInstanceImpl client;
-    private final ConcurrentMap<String, LifecycleListener> lifecycleListeners
-            = new ConcurrentHashMap<String, LifecycleListener>();
-    private final AtomicBoolean active = new AtomicBoolean(false);
-    private final BuildInfo buildInfo;
-    private final ExecutorService executor;
-    public LifecycleServiceImpl(HazelcastClientInstanceImpl client) {
-        this.client = client;
-        ClassLoader classLoader = client.getClientConfig().getClassLoader();
-        executor = Executors.newSingleThreadExecutor(
-                new PoolExecutorThreadFactory(client.getName() + ".lifecycle-", classLoader));
-        final List<ListenerConfig> listenerConfigs = client.getClientConfig().getListenerConfigs();
-        if (listenerConfigs != null && !listenerConfigs.isEmpty()) {
-            for (ListenerConfig listenerConfig : listenerConfigs) {
-                EventListener implementation = listenerConfig.getImplementation();
-                if (implementation == null) {
-                    try {
-                        implementation = ClassLoaderUtil.newInstance(classLoader, listenerConfig.getClassName());
-                    } catch (Exception e) {
-                        getLogger().severe(e);
-                    }
-                }
-                if (implementation instanceof LifecycleListener) {
-                    addLifecycleListener((LifecycleListener) implementation);
-                }
-            }
-        }
-        buildInfo = BuildInfoProvider.getBuildInfo();
-        fireLifecycleEvent(STARTING);
-    }
-    private ILogger getLogger() {
-        return client.getLoggingService().getLogger(LifecycleService.class);
-    }
-    @Override
-    public String addLifecycleListener(LifecycleListener lifecycleListener) {
-        final String id = UuidUtil.newUnsecureUuidString();
-        lifecycleListeners.put(id, lifecycleListener);
-        return id;
-    }
-    @Override
-    public boolean removeLifecycleListener(String registrationId) {
-        return lifecycleListeners.remove(registrationId) != null;
-    }
-    public void fireLifecycleEvent(LifecycleEvent.LifecycleState lifecycleState) {
-        final LifecycleEvent lifecycleEvent = new LifecycleEvent(lifecycleState);
-        String revision = buildInfo.getRevision();
-        if (isNullOrEmpty(revision)) {
-            revision = "";
-        } else {
-            revision = " - " + revision;
-            BuildInfo upstreamInfo = buildInfo.getUpstreamBuildInfo();
-            if (upstreamInfo != null) {
-                String upstreamRevision = upstreamInfo.getRevision();
-                if (!isNullOrEmpty(upstreamRevision)) {
-                    revision += ", " + upstreamRevision;
-                }
-            }
-        }
-        getLogger().info("HazelcastClient " + buildInfo.getVersion() + " ("
-                + buildInfo.getBuild() + revision + ") is "
-                + lifecycleEvent.getState());
-        executor.execute(new Runnable() {
-            @Override
-            public void run() {
-                for (LifecycleListener lifecycleListener : lifecycleListeners.values()) {
-                    lifecycleListener.stateChanged(lifecycleEvent);
-                }
-            }
-        });
-    }
-    public void setStarted() {
-        active.set(true);
-        fireLifecycleEvent(STARTED);
-    }
-    @Override
-    public boolean isRunning() {
-        return active.get();
-    }
-    @Override
-    public void shutdown() {
-        if (!active.compareAndSet(true, false)) {
-            return;
-        }
-        fireLifecycleEvent(SHUTTING_DOWN);
-        HazelcastClient.shutdown(client.getName());
-        client.doShutdown();
-        fireLifecycleEvent(SHUTDOWN);
-        shutdownExecutor();
-    }
-    @Override
-    public void terminate() {
-        shutdown();
-    }
-    private void shutdownExecutor() {
-        executor.shutdown();
-        try {
-            boolean success = executor.awaitTermination(TERMINATE_TIMEOUT_SECONDS, TimeUnit.SECONDS);
-            if (!success) {
-                getLogger().warning("LifecycleService executor awaitTermination could not completed gracefully in "
-                        + TERMINATE_TIMEOUT_SECONDS + " seconds. Terminating forcefully.");
-                executor.shutdownNow();
-            }
-        } catch (InterruptedException e) {
-            Thread.currentThread().interrupt();
-            getLogger().warning("LifecycleService executor awaitTermination is interrupted. Terminating forcefully.", e);
-            executor.shutdownNow();
-        }
-    }
-}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/package-info.java
+++ b//dev/null
@@ -1,19 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/**
- * Contains most of the client side HazelcastInstance implementation functionality.
- */
-package com.hazelcast.client.impl.clientside;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/impl/querycache/subscriber/ClientInvokerWrapper.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/impl/querycache/subscriber/ClientInvokerWrapper.java
@@ -7,21 +7,21 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.impl.querycache.subscriber;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.spi.ClientContext;
 import com.hazelcast.client.spi.impl.ClientInvocation;
 import com.hazelcast.client.spi.impl.ClientInvocationFuture;
 import com.hazelcast.map.impl.querycache.InvokerWrapper;
 import com.hazelcast.map.impl.querycache.QueryCacheContext;
 import com.hazelcast.nio.Address;
 import com.hazelcast.spi.Operation;
 import java.util.concurrent.Future;
 import static com.hazelcast.util.ExceptionUtil.rethrow;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/impl/querycache/subscriber/ClientQueryCacheEventService.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/impl/querycache/subscriber/ClientQueryCacheEventService.java
@@ -183,25 +183,25 @@
         private QueryCacheHandler(ListenerAdapter adapter) {
             this.adapter = adapter;
         }
         @Override
         public void beforeListenerRegister() {
         }
         @Override
         public void onListenerRegister() {
         }
         @Override
-        public void handleQueryCacheSingleEventV10(QueryCacheEventData data) {
+        public void handle(QueryCacheEventData data) {
             adapter.onEvent(new SingleIMapEvent(data));
         }
         @Override
-        public void handleQueryCacheBatchEventV10(Collection<QueryCacheEventData> events, String source, int partitionId) {
+        public void handle(Collection<QueryCacheEventData> events, String source, int partitionId) {
             adapter.onEvent(new BatchIMapEvent(new BatchEventData(events, source, partitionId)));
         }
     }
     private Collection<ListenerInfo> getListeners(String mapName, String cacheName) {
         QueryCacheToListenerMapper queryCacheToListenerMapper = registrations.get(mapName);
         if (queryCacheToListenerMapper == null) {
             return Collections.emptySet();
         }
         return queryCacheToListenerMapper.getListenerInfos(cacheName);
     }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/impl/statistics/Statistics.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/impl/statistics/Statistics.java
@@ -8,36 +8,36 @@
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.impl.statistics;
 import com.hazelcast.client.connection.nio.ClientConnection;
-import com.hazelcast.client.connection.nio.ClientConnectionManagerImpl;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.ClientStatisticsCodec;
 import com.hazelcast.client.spi.impl.ClientInvocation;
 import com.hazelcast.core.ClientType;
 import com.hazelcast.instance.BuildInfo;
 import com.hazelcast.instance.BuildInfoProvider;
+import com.hazelcast.internal.metrics.MetricsRegistry;
 import com.hazelcast.internal.metrics.Gauge;
-import com.hazelcast.internal.metrics.MetricsRegistry;
 import com.hazelcast.internal.nearcache.NearCache;
 import com.hazelcast.logging.ILogger;
 import com.hazelcast.logging.Logger;
-import com.hazelcast.monitor.impl.NearCacheStatsImpl;
+import com.hazelcast.monitor.NearCacheStats;
 import com.hazelcast.nio.Address;
 import com.hazelcast.security.Credentials;
+import com.hazelcast.security.UsernamePasswordCredentials;
 import com.hazelcast.spi.properties.HazelcastProperties;
 import com.hazelcast.spi.properties.HazelcastProperty;
 import java.util.ArrayList;
 import java.util.List;
 import static java.lang.String.format;
 import static java.util.concurrent.TimeUnit.SECONDS;
 /**
  * This class is the main entry point for collecting and sending the client
  * statistics to the cluster. If the client statistics feature is enabled,
  * it will be scheduled for periodic statistics collection and sent.
@@ -135,34 +135,32 @@
                 addNearCacheStats(stats);
                 sendStats(stats.toString(), ownerConnection);
             }
         }, 0, periodSeconds, SECONDS);
     }
     private void addNearCacheStats(final StringBuilder stats) {
         for (NearCache nearCache : client.getNearCacheManager().listAllNearCaches()) {
             String nearCacheName = nearCache.getName();
             StringBuilder nearCacheNameWithPrefix = getNameWithPrefix(nearCacheName);
             nearCacheNameWithPrefix.append('.');
-            NearCacheStatsImpl nearCacheStats = (NearCacheStatsImpl) nearCache.getNearCacheStats();
+            NearCacheStats nearCacheStats = nearCache.getNearCacheStats();
             String prefix = nearCacheNameWithPrefix.toString();
             addStat(stats, prefix, "creationTime", nearCacheStats.getCreationTime());
             addStat(stats, prefix, "evictions", nearCacheStats.getEvictions());
             addStat(stats, prefix, "hits", nearCacheStats.getHits());
             addStat(stats, prefix, "lastPersistenceDuration", nearCacheStats.getLastPersistenceDuration());
             addStat(stats, prefix, "lastPersistenceKeyCount", nearCacheStats.getLastPersistenceKeyCount());
             addStat(stats, prefix, "lastPersistenceTime", nearCacheStats.getLastPersistenceTime());
             addStat(stats, prefix, "lastPersistenceWrittenBytes", nearCacheStats.getLastPersistenceWrittenBytes());
             addStat(stats, prefix, "misses", nearCacheStats.getMisses());
             addStat(stats, prefix, "ownedEntryCount", nearCacheStats.getOwnedEntryCount());
             addStat(stats, prefix, "expirations", nearCacheStats.getExpirations());
-            addStat(stats, prefix, "invalidations", nearCacheStats.getInvalidations());
-            addStat(stats, prefix, "invalidationRequests", nearCacheStats.getInvalidationRequests());
             addStat(stats, prefix, "ownedEntryMemoryCost", nearCacheStats.getOwnedEntryMemoryCost());
             String persistenceFailure = nearCacheStats.getLastPersistenceFailure();
             if (persistenceFailure != null && !persistenceFailure.isEmpty()) {
                 addStat(stats, prefix, "lastPersistenceFailure", persistenceFailure);
             }
         }
     }
     private void addStat(final StringBuilder stats, final String name, long value) {
         addStat(stats, null, name, value);
     }
@@ -302,22 +300,21 @@
         void fillMetrics(final StringBuilder stats, final ClientConnection ownerConnection) {
             stats.append("lastStatisticsCollectionTime").append(KEY_VALUE_SEPARATOR).append(System.currentTimeMillis());
             addStat(stats, "enterprise", enterprise);
             addStat(stats, "clientType", ClientType.JAVA.toString());
             addStat(stats, "clientVersion", BuildInfoProvider.getBuildInfo().getVersion());
             addStat(stats, "clusterConnectionTimestamp", ownerConnection.getStartTime());
             stats.append(STAT_SEPARATOR).append("clientAddress").append(KEY_VALUE_SEPARATOR)
                  .append(ownerConnection.getLocalSocketAddress().getAddress().getHostAddress()).append(":")
                  .append(ownerConnection.getLocalSocketAddress().getPort());
             addStat(stats, "clientName", client.getName());
-            ClientConnectionManagerImpl connectionManager = (ClientConnectionManagerImpl) client.getConnectionManager();
-            Credentials credentials = connectionManager.getLastCredentials();
-            if (credentials != null) {
+            Credentials credentials = client.getCredentials();
+            if (!(credentials instanceof UsernamePasswordCredentials)) {
                 addStat(stats, "credentials.principal", credentials.getPrincipal());
             }
             for (Gauge gauge : allGauges) {
                 stats.append(STAT_SEPARATOR).append(gauge.getName()).append(KEY_VALUE_SEPARATOR);
                 gauge.render(stats);
             }
         }
     }
 }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/map/impl/ClientMapPartitionIterator.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/map/impl/ClientMapPartitionIterator.java
@@ -7,21 +7,21 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.map.impl;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.MapFetchEntriesCodec;
 import com.hazelcast.client.impl.protocol.codec.MapFetchKeysCodec;
 import com.hazelcast.client.proxy.ClientMapProxy;
 import com.hazelcast.client.spi.ClientContext;
 import com.hazelcast.client.spi.impl.ClientInvocation;
 import com.hazelcast.client.spi.impl.ClientInvocationFuture;
 import com.hazelcast.core.IMap;
 import com.hazelcast.map.impl.iterator.AbstractMapPartitionIterator;
 import com.hazelcast.spi.serialization.SerializationService;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/map/impl/ClientMapQueryPartitionIterator.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/map/impl/ClientMapQueryPartitionIterator.java
@@ -7,21 +7,21 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.map.impl;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.MapFetchWithQueryCodec;
 import com.hazelcast.client.proxy.ClientMapProxy;
 import com.hazelcast.client.spi.ClientContext;
 import com.hazelcast.client.spi.impl.ClientInvocation;
 import com.hazelcast.client.spi.impl.ClientInvocationFuture;
 import com.hazelcast.core.IMap;
 import com.hazelcast.map.impl.iterator.AbstractMapQueryPartitionIterator;
 import com.hazelcast.nio.serialization.Data;
 import com.hazelcast.projection.Projection;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/map/impl/nearcache/invalidation/ClientMapInvalidationMetaDataFetcher.java
+++ b//dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.hazelcast.client.map.impl.nearcache.invalidation;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
-import com.hazelcast.client.impl.protocol.ClientMessage;
-import com.hazelcast.client.impl.protocol.codec.MapFetchNearCacheInvalidationMetadataCodec.ResponseParameters;
-import com.hazelcast.client.spi.ClientClusterService;
-import com.hazelcast.client.spi.ClientContext;
-import com.hazelcast.client.spi.impl.ClientInvocation;
-import com.hazelcast.core.Member;
-import com.hazelcast.internal.nearcache.impl.invalidation.InvalidationMetaDataFetcher;
-import com.hazelcast.nio.Address;
-import com.hazelcast.spi.InternalCompletableFuture;
-import java.util.Collection;
-import java.util.List;
-import static com.hazelcast.client.impl.protocol.codec.MapFetchNearCacheInvalidationMetadataCodec.decodeResponse;
-import static com.hazelcast.client.impl.protocol.codec.MapFetchNearCacheInvalidationMetadataCodec.encodeRequest;
-import static com.hazelcast.cluster.memberselector.MemberSelectors.DATA_MEMBER_SELECTOR;
-import static java.util.concurrent.TimeUnit.MINUTES;
-/**
- * {@code InvalidationMetaDataFetcher} for client side usage
- */
-public class ClientMapInvalidationMetaDataFetcher extends InvalidationMetaDataFetcher {
-    private final ClientClusterService clusterService;
-    private final HazelcastClientInstanceImpl clientImpl;
-    public ClientMapInvalidationMetaDataFetcher(ClientContext clientContext) {
-        super(clientContext.getLoggingService().getLogger(ClientMapInvalidationMetaDataFetcher.class));
-        this.clusterService = clientContext.getClusterService();
-        this.clientImpl = (HazelcastClientInstanceImpl) clientContext.getHazelcastInstance();
-    }
-    @Override
-    protected Collection<Member> getDataMembers() {
-        return clusterService.getMembers(DATA_MEMBER_SELECTOR);
-    }
-    @Override
-    protected InternalCompletableFuture fetchMetadataOf(Address address, List<String> names) {
-        ClientMessage message = encodeRequest(names, address);
-        ClientInvocation invocation = new ClientInvocation(clientImpl, message, null, address);
-        return invocation.invoke();
-    }
-    @Override
-    protected void extractMemberMetadata(Member member,
-                                         InternalCompletableFuture future,
-                                         MetadataHolder metadataHolder) throws Exception {
-        ClientMessage message = ((ClientMessage) future.get(ASYNC_RESULT_WAIT_TIMEOUT_MINUTES, MINUTES));
-        ResponseParameters response = decodeResponse(message);
-        metadataHolder.setMetadata(response.partitionUuidList, response.namePartitionSequenceList);
-    }
-}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientAtomicLongProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientAtomicLongProxy.java
@@ -7,21 +7,21 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.proxy;
-import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
+import com.hazelcast.client.impl.ClientMessageDecoder;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.AtomicLongAddAndGetCodec;
 import com.hazelcast.client.impl.protocol.codec.AtomicLongAlterAndGetCodec;
 import com.hazelcast.client.impl.protocol.codec.AtomicLongAlterCodec;
 import com.hazelcast.client.impl.protocol.codec.AtomicLongApplyCodec;
 import com.hazelcast.client.impl.protocol.codec.AtomicLongCompareAndSetCodec;
 import com.hazelcast.client.impl.protocol.codec.AtomicLongDecrementAndGetCodec;
 import com.hazelcast.client.impl.protocol.codec.AtomicLongGetAndAddCodec;
 import com.hazelcast.client.impl.protocol.codec.AtomicLongGetAndAlterCodec;
 import com.hazelcast.client.impl.protocol.codec.AtomicLongGetAndIncrementCodec;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientAtomicReferenceProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientAtomicReferenceProxy.java
@@ -7,21 +7,21 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.proxy;
-import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
+import com.hazelcast.client.impl.ClientMessageDecoder;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.AtomicReferenceAlterAndGetCodec;
 import com.hazelcast.client.impl.protocol.codec.AtomicReferenceAlterCodec;
 import com.hazelcast.client.impl.protocol.codec.AtomicReferenceApplyCodec;
 import com.hazelcast.client.impl.protocol.codec.AtomicReferenceClearCodec;
 import com.hazelcast.client.impl.protocol.codec.AtomicReferenceCompareAndSetCodec;
 import com.hazelcast.client.impl.protocol.codec.AtomicReferenceContainsCodec;
 import com.hazelcast.client.impl.protocol.codec.AtomicReferenceGetAndAlterCodec;
 import com.hazelcast.client.impl.protocol.codec.AtomicReferenceGetAndSetCodec;
 import com.hazelcast.client.impl.protocol.codec.AtomicReferenceGetCodec;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientCardinalityEstimatorProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientCardinalityEstimatorProxy.java
@@ -8,21 +8,21 @@
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.proxy;
 import com.hazelcast.cardinality.CardinalityEstimator;
-import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
+import com.hazelcast.client.impl.ClientMessageDecoder;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.CardinalityEstimatorAddCodec;
 import com.hazelcast.client.impl.protocol.codec.CardinalityEstimatorEstimateCodec;
 import com.hazelcast.client.spi.ClientContext;
 import com.hazelcast.nio.serialization.Data;
 import com.hazelcast.spi.InternalCompletableFuture;
 import static com.hazelcast.util.Preconditions.checkNotNull;
 /**
  * Proxy implementation of {@link CardinalityEstimator}.
  */

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientConditionProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientConditionProxy.java
@@ -7,21 +7,21 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.proxy;
-import com.hazelcast.client.impl.clientside.ClientLockReferenceIdGenerator;
+import com.hazelcast.client.impl.ClientLockReferenceIdGenerator;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.ConditionAwaitCodec;
 import com.hazelcast.client.impl.protocol.codec.ConditionBeforeAwaitCodec;
 import com.hazelcast.client.impl.protocol.codec.ConditionSignalAllCodec;
 import com.hazelcast.client.impl.protocol.codec.ConditionSignalCodec;
 import com.hazelcast.client.spi.ClientContext;
 import com.hazelcast.concurrent.lock.LockService;
 import com.hazelcast.core.ICondition;
 import com.hazelcast.util.Clock;
 import com.hazelcast.util.ThreadUtil;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientDurableExecutorServiceProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientDurableExecutorServiceProxy.java
@@ -7,21 +7,21 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.proxy;
-import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
+import com.hazelcast.client.impl.ClientMessageDecoder;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.DurableExecutorDisposeResultCodec;
 import com.hazelcast.client.impl.protocol.codec.DurableExecutorIsShutdownCodec;
 import com.hazelcast.client.impl.protocol.codec.DurableExecutorRetrieveAndDisposeResultCodec;
 import com.hazelcast.client.impl.protocol.codec.DurableExecutorRetrieveResultCodec;
 import com.hazelcast.client.impl.protocol.codec.DurableExecutorShutdownCodec;
 import com.hazelcast.client.impl.protocol.codec.DurableExecutorSubmitToPartitionCodec;
 import com.hazelcast.client.spi.ClientContext;
 import com.hazelcast.client.spi.ClientPartitionService;
 import com.hazelcast.client.spi.ClientProxy;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientExecutorServiceProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientExecutorServiceProxy.java
@@ -7,21 +7,21 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.proxy;
-import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
+import com.hazelcast.client.impl.ClientMessageDecoder;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.ExecutorServiceIsShutdownCodec;
 import com.hazelcast.client.impl.protocol.codec.ExecutorServiceShutdownCodec;
 import com.hazelcast.client.impl.protocol.codec.ExecutorServiceSubmitToAddressCodec;
 import com.hazelcast.client.impl.protocol.codec.ExecutorServiceSubmitToPartitionCodec;
 import com.hazelcast.client.spi.ClientContext;
 import com.hazelcast.client.spi.ClientPartitionService;
 import com.hazelcast.client.spi.ClientProxy;
 import com.hazelcast.client.spi.impl.ClientInvocation;
 import com.hazelcast.client.spi.impl.ClientInvocationFuture;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientListProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientListProxy.java
@@ -283,21 +283,21 @@
     public String toString() {
         return "IList{" + "name='" + name + '\'' + '}';
     }
     private class ItemEventHandler extends ListAddListenerCodec.AbstractEventHandler
             implements EventHandler<ClientMessage> {
         private final ItemListener<E> listener;
         public ItemEventHandler(ItemListener<E> listener) {
             this.listener = listener;
         }
         @Override
-        public void handleItemEventV10(Data dataItem, String uuid, int eventType) {
+        public void handle(Data dataItem, String uuid, int eventType) {
             Member member = getContext().getClusterService().getMember(uuid);
             ItemEvent<E> itemEvent = new DataAwareItemEvent(name, ItemEventType.getByType(eventType),
                     dataItem, member, getSerializationService());
             if (eventType == ItemEventType.ADDED.getType()) {
                 listener.itemAdded(itemEvent);
             } else {
                 listener.itemRemoved(itemEvent);
             }
         }
         @Override

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientLockProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientLockProxy.java
@@ -7,21 +7,21 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.proxy;
-import com.hazelcast.client.impl.clientside.ClientLockReferenceIdGenerator;
+import com.hazelcast.client.impl.ClientLockReferenceIdGenerator;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.LockForceUnlockCodec;
 import com.hazelcast.client.impl.protocol.codec.LockGetLockCountCodec;
 import com.hazelcast.client.impl.protocol.codec.LockGetRemainingLeaseTimeCodec;
 import com.hazelcast.client.impl.protocol.codec.LockIsLockedByCurrentThreadCodec;
 import com.hazelcast.client.impl.protocol.codec.LockIsLockedCodec;
 import com.hazelcast.client.impl.protocol.codec.LockLockCodec;
 import com.hazelcast.client.impl.protocol.codec.LockTryLockCodec;
 import com.hazelcast.client.impl.protocol.codec.LockUnlockCodec;
 import com.hazelcast.client.spi.ClientContext;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientMapProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientMapProxy.java
@@ -8,22 +8,22 @@
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.proxy;
 import com.hazelcast.aggregation.Aggregator;
-import com.hazelcast.client.impl.clientside.ClientLockReferenceIdGenerator;
-import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
+import com.hazelcast.client.impl.ClientLockReferenceIdGenerator;
+import com.hazelcast.client.impl.ClientMessageDecoder;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.MapAddEntryListenerCodec;
 import com.hazelcast.client.impl.protocol.codec.MapAddEntryListenerToKeyCodec;
 import com.hazelcast.client.impl.protocol.codec.MapAddEntryListenerToKeyWithPredicateCodec;
 import com.hazelcast.client.impl.protocol.codec.MapAddEntryListenerWithPredicateCodec;
 import com.hazelcast.client.impl.protocol.codec.MapAddIndexCodec;
 import com.hazelcast.client.impl.protocol.codec.MapAddInterceptorCodec;
 import com.hazelcast.client.impl.protocol.codec.MapAddPartitionLostListenerCodec;
 import com.hazelcast.client.impl.protocol.codec.MapAggregateCodec;
 import com.hazelcast.client.impl.protocol.codec.MapAggregateWithPredicateCodec;
@@ -54,35 +54,30 @@
 import com.hazelcast.client.impl.protocol.codec.MapKeySetWithPagingPredicateCodec;
 import com.hazelcast.client.impl.protocol.codec.MapKeySetWithPredicateCodec;
 import com.hazelcast.client.impl.protocol.codec.MapLoadAllCodec;
 import com.hazelcast.client.impl.protocol.codec.MapLoadGivenKeysCodec;
 import com.hazelcast.client.impl.protocol.codec.MapLockCodec;
 import com.hazelcast.client.impl.protocol.codec.MapProjectCodec;
 import com.hazelcast.client.impl.protocol.codec.MapProjectWithPredicateCodec;
 import com.hazelcast.client.impl.protocol.codec.MapPutAllCodec;
 import com.hazelcast.client.impl.protocol.codec.MapPutCodec;
 import com.hazelcast.client.impl.protocol.codec.MapPutIfAbsentCodec;
-import com.hazelcast.client.impl.protocol.codec.MapPutIfAbsentWithMaxIdleCodec;
 import com.hazelcast.client.impl.protocol.codec.MapPutTransientCodec;
-import com.hazelcast.client.impl.protocol.codec.MapPutTransientWithMaxIdleCodec;
-import com.hazelcast.client.impl.protocol.codec.MapPutWithMaxIdleCodec;
 import com.hazelcast.client.impl.protocol.codec.MapRemoveAllCodec;
 import com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;
 import com.hazelcast.client.impl.protocol.codec.MapRemoveEntryListenerCodec;
 import com.hazelcast.client.impl.protocol.codec.MapRemoveIfSameCodec;
 import com.hazelcast.client.impl.protocol.codec.MapRemoveInterceptorCodec;
 import com.hazelcast.client.impl.protocol.codec.MapRemovePartitionLostListenerCodec;
 import com.hazelcast.client.impl.protocol.codec.MapReplaceCodec;
 import com.hazelcast.client.impl.protocol.codec.MapReplaceIfSameCodec;
 import com.hazelcast.client.impl.protocol.codec.MapSetCodec;
-import com.hazelcast.client.impl.protocol.codec.MapSetTtlCodec;
-import com.hazelcast.client.impl.protocol.codec.MapSetWithMaxIdleCodec;
 import com.hazelcast.client.impl.protocol.codec.MapSizeCodec;
 import com.hazelcast.client.impl.protocol.codec.MapSubmitToKeyCodec;
 import com.hazelcast.client.impl.protocol.codec.MapTryLockCodec;
 import com.hazelcast.client.impl.protocol.codec.MapTryPutCodec;
 import com.hazelcast.client.impl.protocol.codec.MapTryRemoveCodec;
 import com.hazelcast.client.impl.protocol.codec.MapUnlockCodec;
 import com.hazelcast.client.impl.protocol.codec.MapValuesCodec;
 import com.hazelcast.client.impl.protocol.codec.MapValuesWithPagingPredicateCodec;
 import com.hazelcast.client.impl.protocol.codec.MapValuesWithPredicateCodec;
 import com.hazelcast.client.impl.querycache.ClientQueryCacheContext;
@@ -105,21 +100,20 @@
 import com.hazelcast.core.HazelcastException;
 import com.hazelcast.core.ICompletableFuture;
 import com.hazelcast.core.IMap;
 import com.hazelcast.core.IMapEvent;
 import com.hazelcast.core.MapEvent;
 import com.hazelcast.core.Member;
 import com.hazelcast.core.ReadOnly;
 import com.hazelcast.internal.journal.EventJournalInitialSubscriberState;
 import com.hazelcast.internal.journal.EventJournalReader;
 import com.hazelcast.internal.serialization.InternalSerializationService;
-import com.hazelcast.internal.util.SimpleCompletedFuture;
 import com.hazelcast.map.EntryBackupProcessor;
 import com.hazelcast.map.EntryProcessor;
 import com.hazelcast.map.MapInterceptor;
 import com.hazelcast.map.MapPartitionLostEvent;
 import com.hazelcast.map.QueryCache;
 import com.hazelcast.map.impl.DataAwareEntryEvent;
 import com.hazelcast.map.impl.LazyMapEntry;
 import com.hazelcast.map.impl.ListenerAdapter;
 import com.hazelcast.map.impl.SimpleEntryView;
 import com.hazelcast.map.impl.querycache.subscriber.QueryCacheEndToEndProvider;
@@ -150,44 +144,39 @@
 import com.hazelcast.ringbuffer.impl.client.PortableReadResultSet;
 import com.hazelcast.spi.impl.UnmodifiableLazyList;
 import com.hazelcast.spi.serialization.SerializationService;
 import com.hazelcast.util.CollectionUtil;
 import com.hazelcast.util.IterationType;
 import com.hazelcast.util.Preconditions;
 import com.hazelcast.util.collection.InflatableSet;
 import java.util.AbstractMap;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import static com.hazelcast.map.impl.ListenerAdapters.createListenerAdapter;
 import static com.hazelcast.map.impl.MapListenerFlagOperator.setAndGetListenerFlags;
 import static com.hazelcast.map.impl.querycache.subscriber.QueryCacheRequest.newQueryCacheRequest;
-import static com.hazelcast.map.impl.recordstore.RecordStore.DEFAULT_TTL;
 import static com.hazelcast.util.CollectionUtil.objectToDataCollection;
 import static com.hazelcast.util.ExceptionUtil.rethrow;
 import static com.hazelcast.util.MapUtil.createHashMap;
 import static com.hazelcast.util.Preconditions.checkNotInstanceOf;
 import static com.hazelcast.util.Preconditions.checkNotNull;
 import static com.hazelcast.util.SortingUtil.getSortedQueryResultSet;
 import static com.hazelcast.util.ThreadUtil.getThreadId;
-import static com.hazelcast.util.TimeUtil.timeInMsOrOneIfResultIsZero;
-import static com.hazelcast.util.TimeUtil.timeInMsOrTimeIfNullUnit;
 import static java.lang.Thread.currentThread;
 import static java.util.Collections.emptyMap;
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
 /**
  * Proxy implementation of {@link IMap}.
  *
  * @param <K> key
  * @param <V> value
  */
 @SuppressWarnings("checkstyle:classdataabstractioncoupling")
 public class ClientMapProxy<K, V> extends ClientProxy
         implements IMap<K, V>, EventJournalReader<EventJournalMapEvent<K, V>> {
     protected static final String NULL_LISTENER_IS_NOT_ALLOWED = "Null listener is not allowed!";
@@ -224,27 +213,20 @@
             return (T) MapRemoveCodec.decodeResponse(clientMessage).response;
         }
     };
     @SuppressWarnings("unchecked")
     private static final ClientMessageDecoder SUBMIT_TO_KEY_RESPONSE_DECODER = new ClientMessageDecoder() {
         @Override
         public <T> T decodeClientMessage(ClientMessage clientMessage) {
             return (T) MapSubmitToKeyCodec.decodeResponse(clientMessage).response;
         }
     };
-    @SuppressWarnings("unchecked")
-    private final ClientMessageDecoder submitToKeysResponseDecoder = new ClientMessageDecoder() {
-        @Override
-        public <T> T decodeClientMessage(ClientMessage clientMessage) {
-            return (T) prepareResult(MapExecuteOnKeysCodec.decodeResponse(clientMessage).response);
-        }
-    };
     private ClientMessageDecoder eventJournalReadResponseDecoder;
     private ClientMessageDecoder eventJournalSubscribeResponseDecoder;
     private ClientLockReferenceIdGenerator lockReferenceIdGenerator;
     private ClientQueryCacheContext queryCacheContext;
     public ClientMapProxy(String serviceName, String name, ClientContext context) {
         super(serviceName, name, context);
     }
     @Override
     protected void onInitialize() {
         super.onInitialize();
@@ -297,29 +279,21 @@
     }
     protected Object getInternal(Object key) {
         Data keyData = toData(key);
         ClientMessage request = MapGetCodec.encodeRequest(name, keyData, getThreadId());
         ClientMessage response = invoke(request, keyData);
         MapGetCodec.ResponseParameters resultParameters = MapGetCodec.decodeResponse(response);
         return resultParameters.response;
     }
     @Override
     public V put(K key, V value) {
-        checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
-        checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
-        return putInternal(DEFAULT_TTL, MILLISECONDS, null, null, key, value);
-    }
-    @Override
-    public V put(K key, V value, long ttl, TimeUnit ttlUnit, long maxIdle, TimeUnit maxIdleUnit) {
-        checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
-        checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
-        return putInternal(ttl, ttlUnit, maxIdle, maxIdleUnit, key, value);
+        return put(key, value, -1, TimeUnit.MILLISECONDS);
     }
     @Override
     public V remove(Object key) {
         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
         MapRemoveCodec.ResponseParameters resultParameters = removeInternal(key);
         return toObject(resultParameters.response);
     }
     protected MapRemoveCodec.ResponseParameters removeInternal(Object key) {
         Data keyData = toData(key);
         ClientMessage request = MapRemoveCodec.encodeRequest(name, keyData, getThreadId());
@@ -379,82 +353,56 @@
             throw rethrow(e);
         }
     }
     private ClientInvocationFuture invokeOnKeyOwner(ClientMessage request, Data keyData) {
         int partitionId = getContext().getPartitionService().getPartitionId(keyData);
         ClientInvocation clientInvocation = new ClientInvocation(getClient(), request, getName(), partitionId);
         return clientInvocation.invoke();
     }
     @Override
     public ICompletableFuture<V> putAsync(K key, V value) {
-        return putAsyncInternal(DEFAULT_TTL, MILLISECONDS, null, null, key, value);
+        return putAsync(key, value, -1, TimeUnit.MILLISECONDS);
     }
     @Override
     public ICompletableFuture<V> putAsync(K key, V value, long ttl, TimeUnit timeunit) {
         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
-        return putAsyncInternal(ttl, timeunit, null, null, key, value);
-    }
-    @Override
-    public ICompletableFuture<V> putAsync(K key, V value, long ttl, TimeUnit ttlUnit, long maxIdle, TimeUnit maxIdleUnit) {
-        checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
-        checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
-        return putAsyncInternal(ttl, ttlUnit, maxIdle, maxIdleUnit, key, value);
-    }
-    protected ICompletableFuture<V> putAsyncInternal(long ttl, TimeUnit timeunit, Long maxIdle, TimeUnit maxIdleUnit,
-                                                     Object key, Object value) {
+        return putAsyncInternal(ttl, timeunit, key, value);
+    }
+    protected ICompletableFuture<V> putAsyncInternal(long ttl, TimeUnit timeunit, Object key, Object value) {
         try {
             Data keyData = toData(key);
             Data valueData = toData(value);
-            long ttlMillis = timeInMsOrOneIfResultIsZero(ttl, timeunit);
-            ClientMessage request;
-            if (maxIdle != null) {
-                request = MapPutWithMaxIdleCodec.encodeRequest(name, keyData, valueData, getThreadId(),
-                        ttlMillis, timeInMsOrOneIfResultIsZero(maxIdle, maxIdleUnit));
-            } else {
-                request = MapPutCodec.encodeRequest(name, keyData, valueData, getThreadId(), ttlMillis);
-            }
+            long ttlMillis = getTimeInMillis(ttl, timeunit);
+            ClientMessage request = MapPutCodec.encodeRequest(name, keyData, valueData, getThreadId(), ttlMillis);
             ClientInvocationFuture future = invokeOnKeyOwner(request, keyData);
             return new ClientDelegatingFuture<V>(future, getSerializationService(), PUT_ASYNC_RESPONSE_DECODER);
         } catch (Exception e) {
             throw rethrow(e);
         }
     }
     @Override
     public ICompletableFuture<Void> setAsync(K key, V value) {
-        return setAsync(key, value, -1, MILLISECONDS);
+        return setAsync(key, value, -1, TimeUnit.MILLISECONDS);
     }
     @Override
     public ICompletableFuture<Void> setAsync(K key, V value, long ttl, TimeUnit timeunit) {
         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
-        return setAsyncInternal(ttl, timeunit, null, null, key, value);
-    }
-    @Override
-    public ICompletableFuture<Void> setAsync(K key, V value, long ttl, TimeUnit ttlUnit, long maxIdle, TimeUnit maxIdleUnit) {
-        checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
-        checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
-        return setAsyncInternal(ttl, ttlUnit, maxIdle, maxIdleUnit, key, value);
-    }
-    protected ICompletableFuture<Void> setAsyncInternal(long ttl, TimeUnit timeunit, Long maxIdle, TimeUnit maxIdleUnit,
-                                                        Object key, Object value) {
+        return setAsyncInternal(ttl, timeunit, key, value);
+    }
+    protected ICompletableFuture<Void> setAsyncInternal(long ttl, TimeUnit timeunit, Object key, Object value) {
         try {
             Data keyData = toData(key);
             Data valueData = toData(value);
-            long ttlMillis = timeInMsOrOneIfResultIsZero(ttl, timeunit);
-            ClientMessage request;
-            if (maxIdle != null) {
-                request = MapSetWithMaxIdleCodec.encodeRequest(name, keyData, valueData, getThreadId(),
-                        ttlMillis, timeInMsOrOneIfResultIsZero(maxIdle, maxIdleUnit));
-            } else {
-                request = MapSetCodec.encodeRequest(name, keyData, valueData, getThreadId(), ttlMillis);
-            }
+            long ttlMillis = getTimeInMillis(ttl, timeunit);
+            ClientMessage request = MapSetCodec.encodeRequest(name, keyData, valueData, getThreadId(), ttlMillis);
             ClientInvocationFuture future = invokeOnKeyOwner(request, keyData);
             return new ClientDelegatingFuture<Void>(future, getSerializationService(), SET_ASYNC_RESPONSE_DECODER);
         } catch (Exception e) {
             throw rethrow(e);
         }
     }
     @Override
     public ICompletableFuture<V> removeAsync(K key) {
         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
         return removeAsyncInternal(key);
@@ -483,103 +431,69 @@
     }
     @Override
     public boolean tryPut(K key, V value, long timeout, TimeUnit timeunit) {
         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
         return tryPutInternal(timeout, timeunit, key, value);
     }
     protected boolean tryPutInternal(long timeout, TimeUnit timeunit, Object key, Object value) {
         Data keyData = toData(key);
         Data valueData = toData(value);
-        long timeoutMillis = timeInMsOrOneIfResultIsZero(timeout, timeunit);
+        long timeoutMillis = getTimeInMillis(timeout, timeunit);
         ClientMessage request = MapTryPutCodec.encodeRequest(name, keyData, valueData, getThreadId(), timeoutMillis);
         ClientMessage response = invoke(request, keyData);
         MapTryPutCodec.ResponseParameters resultParameters = MapTryPutCodec.decodeResponse(response);
         return resultParameters.response;
     }
     @Override
     public V put(K key, V value, long ttl, TimeUnit timeunit) {
         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
-        return putInternal(ttl, timeunit, null, null, key, value);
-    }
-    protected V putInternal(long ttl, TimeUnit ttlUnit, Long maxIdle, TimeUnit maxIdleUnit, Object key, Object value) {
+        return putInternal(ttl, timeunit, key, value);
+    }
+    protected V putInternal(long ttl, TimeUnit timeunit, Object key, Object value) {
         Data keyData = toData(key);
         Data valueData = toData(value);
-        long ttlMillis = timeInMsOrOneIfResultIsZero(ttl, ttlUnit);
-        ClientMessage request;
-        if (maxIdle != null) {
-            request = MapPutWithMaxIdleCodec.encodeRequest(name, keyData, valueData,
-                    getThreadId(), ttlMillis, timeInMsOrOneIfResultIsZero(maxIdle, maxIdleUnit));
-        } else {
-            request = MapPutCodec.encodeRequest(name, keyData, valueData, getThreadId(), ttlMillis);
-        }
+        long ttlMillis = getTimeInMillis(ttl, timeunit);
+        ClientMessage request = MapPutCodec.encodeRequest(name, keyData, valueData, getThreadId(), ttlMillis);
         ClientMessage response = invoke(request, keyData);
         MapPutCodec.ResponseParameters resultParameters = MapPutCodec.decodeResponse(response);
         return toObject(resultParameters.response);
     }
     @Override
     public void putTransient(K key, V value, long ttl, TimeUnit timeunit) {
         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
-        putTransientInternal(ttl, timeunit, null, null, key, value);
-    }
-    @Override
-    public void putTransient(K key, V value, long ttl, TimeUnit ttlUnit, long maxIdle, TimeUnit maxIdleUnit) {
+        putTransientInternal(ttl, timeunit, key, value);
+    }
+    protected void putTransientInternal(long ttl, TimeUnit timeunit, Object key, Object value) {
+        Data keyData = toData(key);
+        Data valueData = toData(value);
+        long ttlMillis = getTimeInMillis(ttl, timeunit);
+        ClientMessage request = MapPutTransientCodec.encodeRequest(name, keyData, valueData, getThreadId(), ttlMillis);
+        invoke(request, keyData);
+    }
+    @Override
+    public V putIfAbsent(K key, V value) {
+        return putIfAbsent(key, value, -1, TimeUnit.MILLISECONDS);
+    }
+    @Override
+    public V putIfAbsent(K key, V value, long ttl, TimeUnit timeunit) {
         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
-        putTransientInternal(ttl, ttlUnit, maxIdle, maxIdleUnit, key, value);
-    }
-    protected void putTransientInternal(long ttl, TimeUnit timeunit, Long maxIdle, TimeUnit maxIdleUnit,
-                                        Object key, Object value) {
+        return putIfAbsentInternal(ttl, timeunit, key, value);
+    }
+    protected V putIfAbsentInternal(long ttl, TimeUnit timeunit, Object key, Object value) {
         Data keyData = toData(key);
         Data valueData = toData(value);
-        long ttlMillis = timeInMsOrOneIfResultIsZero(ttl, timeunit);
-        ClientMessage request;
-        if (maxIdle != null) {
-            request = MapPutTransientWithMaxIdleCodec.encodeRequest(name, keyData, valueData,
-                    getThreadId(), ttlMillis, timeInMsOrOneIfResultIsZero(maxIdle, maxIdleUnit));
-        } else {
-            request = MapPutTransientCodec.encodeRequest(name, keyData, valueData, getThreadId(), ttlMillis);
-        }
-        invoke(request, keyData);
-    }
-    @Override
-    public V putIfAbsent(K key, V value) {
-        checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
-        checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
-        return putIfAbsentInternal(DEFAULT_TTL, MILLISECONDS, null, null, key, value);
-    }
-    @Override
-    public V putIfAbsent(K key, V value, long ttl, TimeUnit timeunit) {
-        checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
-        checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
-        return putIfAbsentInternal(ttl, timeunit, null, null, key, value);
-    }
-    @Override
-    public V putIfAbsent(K key, V value, long ttl, TimeUnit ttlUnit, long maxIdle, TimeUnit maxIdleUnit) {
-        checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
-        checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
-        return putIfAbsentInternal(ttl, ttlUnit, maxIdle, maxIdleUnit, key, value);
-    }
-    protected V putIfAbsentInternal(long ttl, TimeUnit timeunit, Long maxIdle, TimeUnit maxIdleUnit, Object key, Object value) {
-        Data keyData = toData(key);
-        Data valueData = toData(value);
-        long ttlMillis = timeInMsOrOneIfResultIsZero(ttl, timeunit);
-        ClientMessage request;
-        if (maxIdle != null) {
-            request = MapPutIfAbsentWithMaxIdleCodec.encodeRequest(name, keyData, valueData,
-                    getThreadId(), ttlMillis, timeInMsOrOneIfResultIsZero(maxIdle, maxIdleUnit));
-        } else {
-             request = MapPutIfAbsentCodec.encodeRequest(name, keyData, valueData,
-                    getThreadId(), ttlMillis);
-        }
+        long ttlMillis = getTimeInMillis(ttl, timeunit);
+        ClientMessage request = MapPutIfAbsentCodec.encodeRequest(name, keyData, valueData, getThreadId(), ttlMillis);
         ClientMessage result = invoke(request, keyData);
         MapPutIfAbsentCodec.ResponseParameters resultParameters = MapPutIfAbsentCodec.decodeResponse(result);
         return toObject(resultParameters.response);
     }
     @Override
     public boolean replace(K key, V oldValue, V newValue) {
         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
         checkNotNull(oldValue, NULL_VALUE_IS_NOT_ALLOWED);
         checkNotNull(newValue, NULL_VALUE_IS_NOT_ALLOWED);
         return replaceIfSameInternal(key, oldValue, newValue);
@@ -604,51 +518,39 @@
         Data valueData = toData(value);
         ClientMessage request = MapReplaceCodec.encodeRequest(name, keyData, valueData, getThreadId());
         ClientMessage response = invoke(request, keyData);
         MapReplaceCodec.ResponseParameters resultParameters = MapReplaceCodec.decodeResponse(response);
         return toObject(resultParameters.response);
     }
     @Override
     public void set(K key, V value, long ttl, TimeUnit timeunit) {
         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
-        setInternal(ttl, timeunit, null, null, key, value);
-    }
-    @Override
-    public void set(K key, V value, long ttl, TimeUnit ttlUnit, long maxIdle, TimeUnit maxIdleUnit) {
-        checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
-        checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
-        setInternal(ttl, ttlUnit, maxIdle, maxIdleUnit, key, value);
-    }
-    protected void setInternal(long ttl, TimeUnit timeunit, Long maxIdle, TimeUnit maxIdleUnit, Object key, Object value) {
+        setInternal(ttl, timeunit, key, value);
+    }
+    protected void setInternal(long ttl, TimeUnit timeunit, Object key, Object value) {
         Data keyData = toData(key);
         Data valueData = toData(value);
-        long ttlMillis = timeInMsOrOneIfResultIsZero(ttl, timeunit);
-        ClientMessage request;
-        if (maxIdle != null) {
-            request = MapSetWithMaxIdleCodec.encodeRequest(name, keyData, valueData, getThreadId(),
-                    ttlMillis, timeInMsOrOneIfResultIsZero(maxIdle, maxIdleUnit));
-        } else {
-            request = MapSetCodec.encodeRequest(name, keyData, valueData, getThreadId(), ttlMillis);
-        }
+        long ttlMillis = getTimeInMillis(ttl, timeunit);
+        ClientMessage request = MapSetCodec.encodeRequest(name, keyData, valueData, getThreadId(), ttlMillis);
         invoke(request, keyData);
     }
     @Override
     public void lock(K key) {
-        lock(key, -1, MILLISECONDS);
+        lock(key, -1, TimeUnit.MILLISECONDS);
     }
     @Override
     public void lock(K key, long leaseTime, TimeUnit timeUnit) {
         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
         Data keyData = toData(key);
-        ClientMessage request = MapLockCodec.encodeRequest(name, keyData, getThreadId(),
-                timeInMsOrTimeIfNullUnit(leaseTime, timeUnit), lockReferenceIdGenerator.getNextReferenceId());
+        ClientMessage request = MapLockCodec.encodeRequest(name, keyData, getThreadId(), getTimeInMillis(leaseTime, timeUnit),
+                lockReferenceIdGenerator.getNextReferenceId());
         invoke(request, keyData, Long.MAX_VALUE);
     }
     private <T> T invoke(ClientMessage clientMessage, Object key, long invocationTimeoutSeconds) {
         final int partitionId = getContext().getPartitionService().getPartitionId(key);
         try {
             ClientInvocation clientInvocation = new ClientInvocation(getClient(), clientMessage, getName(), partitionId);
             clientInvocation.setInvocationTimeoutMillis(invocationTimeoutSeconds);
             final Future future = clientInvocation.invoke();
             return (T) future.get();
         } catch (Exception e) {
@@ -674,22 +576,22 @@
         }
     }
     @Override
     public boolean tryLock(K key, long time, TimeUnit timeunit) throws InterruptedException {
         return tryLock(key, time, timeunit, Long.MAX_VALUE, null);
     }
     @Override
     public boolean tryLock(K key, long time, TimeUnit timeunit, long leaseTime, TimeUnit leaseUnit) throws InterruptedException {
         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
         Data keyData = toData(key);
-        long leaseTimeMillis = timeInMsOrTimeIfNullUnit(leaseTime, leaseUnit);
-        long timeoutMillis = timeInMsOrTimeIfNullUnit(time, timeunit);
+        long leaseTimeMillis = getTimeInMillis(leaseTime, leaseUnit);
+        long timeoutMillis = getTimeInMillis(time, timeunit);
         ClientMessage request = MapTryLockCodec.encodeRequest(name, keyData, getThreadId(), leaseTimeMillis, timeoutMillis,
                 lockReferenceIdGenerator.getNextReferenceId());
         ClientMessage response = invoke(request, keyData, Long.MAX_VALUE);
         MapTryLockCodec.ResponseParameters resultParameters = MapTryLockCodec.decodeResponse(response);
         return resultParameters.response;
     }
     @Override
     public void unlock(K key) {
         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
         Data keyData = toData(key);
@@ -961,22 +863,21 @@
                 .withValue((V) toObject(dataEntryView.getValue()))
                 .withCost(dataEntryView.getCost())
                 .withCreationTime(dataEntryView.getCreationTime())
                 .withExpirationTime(dataEntryView.getExpirationTime())
                 .withHits(dataEntryView.getHits())
                 .withLastAccessTime(dataEntryView.getLastAccessTime())
                 .withLastStoredTime(dataEntryView.getLastStoredTime())
                 .withLastUpdateTime(dataEntryView.getLastUpdateTime())
                 .withVersion(dataEntryView.getVersion())
                 .withHits(dataEntryView.getHits())
-                .withTtl(dataEntryView.getTtl())
-                .withMaxIdle(parameters.maxIdle);
+                .withTtl(dataEntryView.getTtl());
     }
     @Override
     public boolean evict(K key) {
         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
         return evictInternal(key);
     }
     protected boolean evictInternal(Object key) {
         Data keyData = toData(key);
         ClientMessage request = MapEvictCodec.encodeRequest(name, keyData, getThreadId());
         ClientMessage response = invoke(request, keyData);
@@ -1213,34 +1114,20 @@
         throw new UnsupportedOperationException("Locality is ambiguous for client!");
     }
     @Override
     public void addIndex(String attribute, boolean ordered) {
         ClientMessage request = MapAddIndexCodec.encodeRequest(name, attribute, ordered);
         invoke(request);
     }
     @Override
     public LocalMapStats getLocalMapStats() {
         return new LocalMapStatsImpl();
-    }
-    @Override
-    public boolean setTtl(K key, long ttl, TimeUnit timeunit) {
-        checkNotNull(key);
-        checkNotNull(timeunit);
-        return setTtlInternal(key, ttl, timeunit);
-    }
-    protected boolean setTtlInternal(Object key, long ttl, TimeUnit timeUnit) {
-        long ttlMillis = timeUnit.toMillis(ttl);
-        Data keyData = toData(key);
-        ClientMessage request = MapSetTtlCodec.encodeRequest(getName(), keyData, ttlMillis);
-        ClientMessage result = invoke(request, keyData);
-        MapSetTtlCodec.ResponseParameters resultParameters = MapSetTtlCodec.decodeResponse(result);
-        return resultParameters.response;
     }
     @Override
     public Object executeOnKey(K key, EntryProcessor entryProcessor) {
         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
         return executeOnKeyInternal(key, entryProcessor);
     }
     public Object executeOnKeyInternal(Object key, EntryProcessor entryProcessor) {
         validateEntryProcessorForSingleKeyProcessing(entryProcessor);
         Data keyData = toData(key);
         ClientMessage request = MapExecuteOnKeyCodec.encodeRequest(name, toData(entryProcessor), keyData, getThreadId());
@@ -1415,36 +1302,23 @@
         checkNotNull(keys, NULL_KEY_IS_NOT_ALLOWED);
         if (keys.isEmpty()) {
             return emptyMap();
         }
         Collection<Data> dataCollection = objectToDataCollection(keys, getSerializationService());
         ClientMessage request = MapExecuteOnKeysCodec.encodeRequest(name, toData(entryProcessor), dataCollection);
         ClientMessage response = invoke(request);
         MapExecuteOnKeysCodec.ResponseParameters resultParameters = MapExecuteOnKeysCodec.decodeResponse(response);
         return prepareResult(resultParameters.response);
     }
-    /**
-     * Async version of {@link #executeOnKeys}.
-     */
-    public ICompletableFuture<Map<K, Object>> submitToKeys(Set<K> keys, EntryProcessor entryProcessor) {
-        checkNotNull(keys, NULL_KEY_IS_NOT_ALLOWED);
-        if (keys.isEmpty()) {
-            return new SimpleCompletedFuture<Map<K, Object>>(Collections.<K, Object>emptyMap());
-        }
-        Collection<Data> dataCollection = objectToDataCollection(keys, getSerializationService());
-        ClientMessage request = MapExecuteOnKeysCodec.encodeRequest(name, toData(entryProcessor), dataCollection);
-        ClientInvocationFuture future = new ClientInvocation(getClient(), request, getName()).invoke();
-        return new ClientDelegatingFuture<Map<K, Object>>(future, getSerializationService(), submitToKeysResponseDecoder);
-    }
     @Override
     public void set(K key, V value) {
-        set(key, value, -1, MILLISECONDS);
+        set(key, value, -1, TimeUnit.MILLISECONDS);
     }
     @Override
     public int size() {
         ClientMessage request = MapSizeCodec.encodeRequest(name);
         ClientMessage response = invoke(request);
         MapSizeCodec.ResponseParameters resultParameters = MapSizeCodec.decodeResponse(response);
         return resultParameters.response;
     }
     @Override
     public boolean isEmpty() {
@@ -1580,20 +1454,23 @@
         }
         final SerializationService ss = getSerializationService();
         final ClientMessage request = MapEventJournalReadCodec.encodeRequest(
                 name, startSequence, minSize, maxSize, ss.toData(predicate), ss.toData(projection));
         final ClientInvocationFuture fut = new ClientInvocation(getClient(), request, getName(), partitionId).invoke();
         return new ClientDelegatingFuture<ReadResultSet<T>>(fut, ss, eventJournalReadResponseDecoder);
     }
     public ClientQueryCacheContext getQueryCacheContext() {
         return queryCacheContext;
     }
+    private long getTimeInMillis(long time, TimeUnit timeunit) {
+        return timeunit != null ? timeunit.toMillis(time) : time;
+    }
     private EventHandler<ClientMessage> createHandler(ListenerAdapter<IMapEvent> listenerAdapter) {
         return new ClientMapEventHandler(listenerAdapter);
     }
     private static void validateEntryProcessorForSingleKeyProcessing(EntryProcessor entryProcessor) {
         if (entryProcessor instanceof ReadOnly) {
             EntryBackupProcessor backupProcessor = entryProcessor.getBackupProcessor();
             if (backupProcessor != null) {
                 throw new IllegalArgumentException(
                         "EntryProcessor.getBackupProcessor() should be null for a read-only EntryProcessor");
             }
@@ -1622,38 +1499,37 @@
         return (PagingPredicate) unwrappedPredicate;
     }
     private class ClientMapEventHandler
             extends MapAddEntryListenerCodec.AbstractEventHandler
             implements EventHandler<ClientMessage> {
         private ListenerAdapter<IMapEvent> listenerAdapter;
         ClientMapEventHandler(ListenerAdapter<IMapEvent> listenerAdapter) {
             this.listenerAdapter = listenerAdapter;
         }
         @Override
-        public void handleEntryEventV10(Data key, Data value, Data oldValue, Data mergingValue, int eventType, String uuid,
-                                        int numberOfAffectedEntries) {
+        public void handle(Data key, Data value, Data oldValue, Data mergingValue, int eventType, String uuid,
+                           int numberOfAffectedEntries) {
             Member member = getContext().getClusterService().getMember(uuid);
             listenerAdapter.onEvent(createIMapEvent(key, value, oldValue, mergingValue, eventType, numberOfAffectedEntries,
                     member));
         }
         private IMapEvent createIMapEvent(Data key, Data value, Data oldValue, Data mergingValue, int eventType,
                                           int numberOfAffectedEntries, Member member) {
             EntryEventType entryEventType = EntryEventType.getByType(eventType);
             checkNotNull(entryEventType, "Unknown eventType: " + eventType);
             switch (entryEventType) {
                 case ADDED:
                 case REMOVED:
                 case UPDATED:
                 case EVICTED:
                 case EXPIRED:
                 case MERGED:
-                case LOADED:
                     return createEntryEvent(key, value, oldValue, mergingValue, eventType, member);
                 case EVICT_ALL:
                 case CLEAR_ALL:
                     return createMapEvent(eventType, numberOfAffectedEntries, member);
                 default:
                     throw new IllegalArgumentException("Not a known event type: " + entryEventType);
             }
         }
         private MapEvent createMapEvent(int eventType, int numberOfAffectedEntries, Member member) {
             return new MapEvent(name, member, eventType, numberOfAffectedEntries);
@@ -1677,21 +1553,21 @@
         ClientMapPartitionLostEventHandler(MapPartitionLostListener listener) {
             this.listener = listener;
         }
         @Override
         public void beforeListenerRegister() {
         }
         @Override
         public void onListenerRegister() {
         }
         @Override
-        public void handleMapPartitionLostEventV10(int partitionId, String uuid) {
+        public void handle(int partitionId, String uuid) {
             Member member = getContext().getClusterService().getMember(uuid);
             listener.partitionLost(new MapPartitionLostEvent(name, member, -1, partitionId));
         }
     }
     @Override
     protected void onDestroy() {
         try {
             SubscriberContext subscriberContext = queryCacheContext.getSubscriberContext();
             QueryCacheEndToEndProvider provider = subscriberContext.getEndToEndQueryCacheProvider();
             provider.destroyAllQueryCaches(name);

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientMapReduceProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientMapReduceProxy.java
@@ -218,22 +218,22 @@
             try {
                 ClientMessage request = MapReduceCancelCodec.encodeRequest(name, jobId);
                 ClientMessage response = invoke(request, jobId);
                 cancelled = MapReduceCancelCodec.decodeResponse(response).response;
             } catch (Exception ignore) {
                 ignore(ignore);
             }
             return cancelled;
         }
         @Override
-        protected boolean setResult(Object result) {
-            return super.setResult(result);
+        protected void setResult(Object result) {
+            super.setResult(result);
         }
     }
     private final class ClientTrackableJob<V>
             implements TrackableJob<V> {
         private final String jobId;
         private final ClientInvocation clientInvocation;
         private final AbstractCompletableFuture<V> completableFuture;
         private ClientTrackableJob(String jobId, ClientInvocation clientInvocation,
                                    AbstractCompletableFuture<V> completableFuture) {
             this.jobId = jobId;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientMultiMapProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientMultiMapProxy.java
@@ -7,21 +7,21 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.proxy;
-import com.hazelcast.client.impl.clientside.ClientLockReferenceIdGenerator;
+import com.hazelcast.client.impl.ClientLockReferenceIdGenerator;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.MultiMapAddEntryListenerCodec;
 import com.hazelcast.client.impl.protocol.codec.MultiMapAddEntryListenerToKeyCodec;
 import com.hazelcast.client.impl.protocol.codec.MultiMapClearCodec;
 import com.hazelcast.client.impl.protocol.codec.MultiMapContainsEntryCodec;
 import com.hazelcast.client.impl.protocol.codec.MultiMapContainsKeyCodec;
 import com.hazelcast.client.impl.protocol.codec.MultiMapContainsValueCodec;
 import com.hazelcast.client.impl.protocol.codec.MultiMapDeleteCodec;
 import com.hazelcast.client.impl.protocol.codec.MultiMapEntrySetCodec;
 import com.hazelcast.client.impl.protocol.codec.MultiMapForceUnlockCodec;
@@ -411,21 +411,21 @@
         final ListenerAdapter listenerAdaptor = createListenerAdapter(listener);
         return new ClientMultiMapEventHandler(listenerAdaptor);
     }
     private class ClientMultiMapEventHandler extends MultiMapAddEntryListenerCodec.AbstractEventHandler
             implements EventHandler<ClientMessage> {
         private final ListenerAdapter listenerAdapter;
         public ClientMultiMapEventHandler(ListenerAdapter listenerAdapter) {
             this.listenerAdapter = listenerAdapter;
         }
         @Override
-        public void handleEntryEventV10(Data key, Data value, Data oldValue, Data mergingValue,
+        public void handle(Data key, Data value, Data oldValue, Data mergingValue,
                            int eventType, String uuid, int numberOfAffectedEntries) {
             Member member = getContext().getClusterService().getMember(uuid);
             final IMapEvent iMapEvent = createIMapEvent(key, value, oldValue,
                     mergingValue, eventType, numberOfAffectedEntries, member);
             listenerAdapter.onEvent(iMapEvent);
         }
         private IMapEvent createIMapEvent(Data key, Data value, Data oldValue, Data mergingValue,
                                           int eventType, int numberOfAffectedEntries, Member member) {
             IMapEvent iMapEvent;
             EntryEventType entryEventType = EntryEventType.getByType(eventType);

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientQueueProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientQueueProxy.java
@@ -94,21 +94,21 @@
     }
     private class ItemEventHandler extends ListAddListenerCodec.AbstractEventHandler
             implements EventHandler<ClientMessage> {
         private final boolean includeValue;
         private final ItemListener<E> listener;
         public ItemEventHandler(boolean includeValue, ItemListener<E> listener) {
             this.includeValue = includeValue;
             this.listener = listener;
         }
         @Override
-        public void handleItemEventV10(Data dataItem, String uuid, int eventType) {
+        public void handle(Data dataItem, String uuid, int eventType) {
             Member member = getContext().getClusterService().getMember(uuid);
             ItemEvent<E> itemEvent = new DataAwareItemEvent(name, ItemEventType.getByType(eventType),
                     dataItem, member, getSerializationService());
             if (eventType == ItemEventType.ADDED.getType()) {
                 listener.itemAdded(itemEvent);
             } else {
                 listener.itemRemoved(itemEvent);
             }
         }
         @Override

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientReliableTopicProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientReliableTopicProxy.java
@@ -8,21 +8,21 @@
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.proxy;
 import com.hazelcast.client.config.ClientReliableTopicConfig;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.spi.ClientContext;
 import com.hazelcast.client.spi.ClientProxy;
 import com.hazelcast.core.ITopic;
 import com.hazelcast.core.MessageListener;
 import com.hazelcast.logging.ILogger;
 import com.hazelcast.monitor.LocalTopicStats;
 import com.hazelcast.nio.serialization.Data;
 import com.hazelcast.ringbuffer.OverflowPolicy;
 import com.hazelcast.ringbuffer.Ringbuffer;
 import com.hazelcast.spi.serialization.SerializationService;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientReplicatedMapProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientReplicatedMapProxy.java
@@ -461,32 +461,32 @@
     private long tryReserveForUpdate(K key, Data keyData) {
         if (nearCache == null) {
             return NOT_RESERVED;
         }
         return nearCache.tryReserveForUpdate(key, keyData);
     }
     private void invalidate(K key) {
         if (nearCache == null) {
             return;
         }
-        nearCache.invalidate(key);
+        nearCache.remove(key);
     }
     private class ReplicatedMapEventHandler
             extends ReplicatedMapAddEntryListenerCodec.AbstractEventHandler
             implements EventHandler<ClientMessage> {
         private final EntryListener<K, V> listener;
         ReplicatedMapEventHandler(EntryListener<K, V> listener) {
             this.listener = listener;
         }
         @Override
-        public void handleEntryEventV10(Data keyData, Data valueData, Data oldValueData, Data mergingValue,
-                                        int eventTypeId, String uuid, int numberOfAffectedEntries) {
+        public void handle(Data keyData, Data valueData, Data oldValueData, Data mergingValue, int eventTypeId, String uuid,
+                           int numberOfAffectedEntries) {
             Member member = getContext().getClusterService().getMember(uuid);
             EntryEventType eventType = EntryEventType.getByType(eventTypeId);
             EntryEvent<K, V> entryEvent = new DataAwareEntryEvent<K, V>(member, eventTypeId, name, keyData, valueData,
                     oldValueData, null, getSerializationService());
             switch (eventType) {
                 case ADDED:
                     listener.entryAdded(entryEvent);
                     break;
                 case REMOVED:
                     listener.entryRemoved(entryEvent);
@@ -521,30 +521,30 @@
                 nearCache.clear();
             }
         }
         @Override
         public void onListenerRegister() {
             if (nearCache != null) {
                 nearCache.clear();
             }
         }
         @Override
-        public void handleEntryEventV10(Data dataKey, Data value, Data oldValue, Data mergingValue,
-                                        int eventType, String uuid, int numberOfAffectedEntries) {
+        public void handle(Data dataKey, Data value, Data oldValue, Data mergingValue, int eventType, String uuid,
+                           int numberOfAffectedEntries) {
             EntryEventType entryEventType = EntryEventType.getByType(eventType);
             switch (entryEventType) {
                 case ADDED:
                 case REMOVED:
                 case UPDATED:
                 case EVICTED:
                     K key = toObject(dataKey);
-                    nearCache.invalidate(key);
+                    nearCache.remove(key);
                     break;
                 case CLEAR_ALL:
                     nearCache.clear();
                     break;
                 default:
                     throw new IllegalArgumentException("Not a known event type " + entryEventType);
             }
         }
     }
 }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientRingbufferProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientRingbufferProxy.java
@@ -7,21 +7,21 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.proxy;
-import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
+import com.hazelcast.client.impl.ClientMessageDecoder;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.RingbufferAddAllCodec;
 import com.hazelcast.client.impl.protocol.codec.RingbufferAddCodec;
 import com.hazelcast.client.impl.protocol.codec.RingbufferCapacityCodec;
 import com.hazelcast.client.impl.protocol.codec.RingbufferHeadSequenceCodec;
 import com.hazelcast.client.impl.protocol.codec.RingbufferReadManyCodec;
 import com.hazelcast.client.impl.protocol.codec.RingbufferReadOneCodec;
 import com.hazelcast.client.impl.protocol.codec.RingbufferRemainingCapacityCodec;
 import com.hazelcast.client.impl.protocol.codec.RingbufferSizeCodec;
 import com.hazelcast.client.impl.protocol.codec.RingbufferTailSequenceCodec;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientScheduledExecutorProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientScheduledExecutorProxy.java
@@ -7,21 +7,21 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.proxy;
-import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
+import com.hazelcast.client.impl.ClientMessageDecoder;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.ScheduledExecutorGetAllScheduledFuturesCodec;
 import com.hazelcast.client.impl.protocol.codec.ScheduledExecutorShutdownCodec;
 import com.hazelcast.client.impl.protocol.codec.ScheduledExecutorSubmitToAddressCodec;
 import com.hazelcast.client.impl.protocol.codec.ScheduledExecutorSubmitToPartitionCodec;
 import com.hazelcast.client.spi.ClientContext;
 import com.hazelcast.client.spi.impl.ClientInvocation;
 import com.hazelcast.client.spi.impl.ClientInvocationFuture;
 import com.hazelcast.client.util.ClientDelegatingFuture;
 import com.hazelcast.core.Member;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientSetProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientSetProxy.java
@@ -190,21 +190,21 @@
     public String toString() {
         return "ISet{" + "name='" + name + '\'' + '}';
     }
     private class ItemEventHandler extends ListAddListenerCodec.AbstractEventHandler
             implements EventHandler<ClientMessage> {
         private final ItemListener<E> listener;
         public ItemEventHandler(ItemListener<E> listener) {
             this.listener = listener;
         }
         @Override
-        public void handleItemEventV10(Data dataItem, String uuid, int eventType) {
+        public void handle(Data dataItem, String uuid, int eventType) {
             Member member = getContext().getClusterService().getMember(uuid);
             ItemEvent<E> itemEvent = new DataAwareItemEvent(name, ItemEventType.getByType(eventType),
                     dataItem, member, getSerializationService());
             if (eventType == ItemEventType.ADDED.getType()) {
                 listener.itemAdded(itemEvent);
             } else {
                 listener.itemRemoved(itemEvent);
             }
         }
         @Override

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientTopicProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientTopicProxy.java
@@ -63,21 +63,21 @@
     public String toString() {
         return "ITopic{" + "name='" + name + '\'' + '}';
     }
     private final class TopicItemHandler extends TopicAddMessageListenerCodec.AbstractEventHandler
             implements EventHandler<ClientMessage> {
         private final MessageListener<E> listener;
         private TopicItemHandler(MessageListener<E> listener) {
             this.listener = listener;
         }
         @Override
-        public void handleTopicEventV10(Data item, long publishTime, String uuid) {
+        public void handle(Data item, long publishTime, String uuid) {
             Member member = getContext().getClusterService().getMember(uuid);
             Message message = new DataAwareMessage(name, item, publishTime, member, getSerializationService());
             listener.onMessage(message);
         }
         @Override
         public void beforeListenerRegister() {
         }
         @Override
         public void onListenerRegister() {
         }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/IExecutorDelegatingFuture.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/IExecutorDelegatingFuture.java
@@ -7,22 +7,22 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.proxy;
-import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.ClientMessageDecoder;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.ExecutorServiceCancelOnAddressCodec;
 import com.hazelcast.client.impl.protocol.codec.ExecutorServiceCancelOnPartitionCodec;
 import com.hazelcast.client.spi.ClientContext;
 import com.hazelcast.client.spi.impl.ClientInvocation;
 import com.hazelcast.client.spi.impl.ClientInvocationFuture;
 import com.hazelcast.client.util.ClientDelegatingFuture;
 import com.hazelcast.core.ICompletableFuture;
 import com.hazelcast.nio.Address;
 import java.util.concurrent.CancellationException;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/NearCachedClientMapProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/NearCachedClientMapProxy.java
@@ -109,29 +109,20 @@
             if (reservationId != NOT_RESERVED) {
                 value = (V) tryPublishReserved(key, value, reservationId);
             }
             return value;
         } catch (Throwable throwable) {
             invalidateNearCache(key);
             throw rethrow(throwable);
         }
     }
     @Override
-    protected boolean setTtlInternal(Object key, long ttl, TimeUnit timeUnit) {
-        key = toNearCacheKey(key);
-        try {
-            return super.setTtlInternal(key, ttl, timeUnit);
-        } finally {
-            invalidateNearCache(key);
-        }
-    }
-    @Override
     public ICompletableFuture<V> getAsyncInternal(Object keyParameter) {
         final Object key = toNearCacheKey(keyParameter);
         Object value = getCachedValue(key, false);
         if (value != NOT_CACHED) {
             ExecutorService executor = getContext().getExecutionService().getUserExecutor();
             return new CompletedFuture<V>(getSerializationService(), value, executor);
         }
         Data keyData = toData(key);
         final long reservationId = nearCache.tryReserveForUpdate(key, keyData);
         ICompletableFuture<V> future;
@@ -188,38 +179,36 @@
     @Override
     protected void deleteInternal(Object key) {
         key = toNearCacheKey(key);
         try {
             super.deleteInternal(key);
         } finally {
             invalidateNearCache(key);
         }
     }
     @Override
-    protected ICompletableFuture<V> putAsyncInternal(long ttl, TimeUnit timeunit, Long maxIdle, TimeUnit maxIdleUnit,
-                                                     Object key, Object value) {
+    protected ICompletableFuture<V> putAsyncInternal(long ttl, TimeUnit timeunit, Object key, Object value) {
         key = toNearCacheKey(key);
         ICompletableFuture<V> future;
         try {
-            future = super.putAsyncInternal(ttl, timeunit, maxIdle, maxIdleUnit, key, value);
+            future = super.putAsyncInternal(ttl, timeunit, key, value);
         } finally {
             invalidateNearCache(key);
         }
         return future;
     }
     @Override
-    protected ICompletableFuture<Void> setAsyncInternal(long ttl, TimeUnit timeunit, Long maxIdle, TimeUnit maxIdleUnit,
-                                                        Object key, Object value) {
+    protected ICompletableFuture<Void> setAsyncInternal(long ttl, TimeUnit timeunit, Object key, Object value) {
         key = toNearCacheKey(key);
         ICompletableFuture<Void> future;
         try {
-            future = super.setAsyncInternal(ttl, timeunit, maxIdle, maxIdleUnit, key, value);
+            future = super.setAsyncInternal(ttl, timeunit, key, value);
         } finally {
             invalidateNearCache(key);
         }
         return future;
     }
     @Override
     protected ICompletableFuture<V> removeAsyncInternal(Object key) {
         key = toNearCacheKey(key);
         ICompletableFuture<V> future;
         try {
@@ -234,59 +223,56 @@
         key = toNearCacheKey(key);
         boolean removed;
         try {
             removed = super.tryRemoveInternal(timeout, timeunit, key);
         } finally {
             invalidateNearCache(key);
         }
         return removed;
     }
     @Override
-    protected boolean tryPutInternal(long timeout, TimeUnit timeunit,
-                                     Object key, Object value) {
+    protected boolean tryPutInternal(long timeout, TimeUnit timeunit, Object key, Object value) {
         key = toNearCacheKey(key);
         boolean putInternal;
         try {
             putInternal = super.tryPutInternal(timeout, timeunit, key, value);
         } finally {
             invalidateNearCache(key);
         }
         return putInternal;
     }
     @Override
-    protected V putInternal(long ttl, TimeUnit ttlUnit, Long maxIdle, TimeUnit maxIdleUnit, Object key, Object value) {
+    protected V putInternal(long ttl, TimeUnit timeunit, Object key, Object value) {
         key = toNearCacheKey(key);
         V previousValue;
         try {
-            previousValue = super.putInternal(ttl, ttlUnit, maxIdle, maxIdleUnit, key, value);
+            previousValue = super.putInternal(ttl, timeunit, key, value);
         } finally {
             invalidateNearCache(key);
         }
         return previousValue;
     }
     @Override
-    protected void putTransientInternal(long ttl, TimeUnit timeunit, Long maxIdle, TimeUnit maxIdleUnit,
-                                        Object key, Object value) {
-        key = toNearCacheKey(key);
-        try {
-            super.putTransientInternal(ttl, timeunit, maxIdle, maxIdleUnit, key, value);
-        } finally {
-            invalidateNearCache(key);
-        }
-    }
-    @Override
-    protected V putIfAbsentInternal(long ttl, TimeUnit timeunit, Long maxIdle, TimeUnit maxIdleUnit,
-                                    Object key, Object value) {
+    protected void putTransientInternal(long ttl, TimeUnit timeunit, Object key, Object value) {
+        key = toNearCacheKey(key);
+        try {
+            super.putTransientInternal(ttl, timeunit, key, value);
+        } finally {
+            invalidateNearCache(key);
+        }
+    }
+    @Override
+    protected V putIfAbsentInternal(long ttl, TimeUnit timeunit, Object key, Object value) {
         key = toNearCacheKey(key);
         V previousValue;
         try {
-            previousValue = super.putIfAbsentInternal(ttl, timeunit, maxIdle, maxIdleUnit, key, value);
+            previousValue = super.putIfAbsentInternal(ttl, timeunit, key, value);
         } finally {
             invalidateNearCache(key);
         }
         return previousValue;
     }
     @Override
     protected boolean replaceIfSameInternal(Object key, Object oldValue, Object newValue) {
         key = toNearCacheKey(key);
         boolean replaceIfSame;
         try {
@@ -301,24 +287,24 @@
         key = toNearCacheKey(key);
         V v;
         try {
             v = super.replaceInternal(key, value);
         } finally {
             invalidateNearCache(key);
         }
         return v;
     }
     @Override
-    protected void setInternal(long ttl, TimeUnit timeunit, Long maxIdle, TimeUnit maxIdleUnit, Object key, Object value) {
-        key = toNearCacheKey(key);
-        try {
-            super.setInternal(ttl, timeunit, maxIdle, maxIdleUnit, key, value);
+    protected void setInternal(long ttl, TimeUnit timeunit, Object key, Object value) {
+        key = toNearCacheKey(key);
+        try {
+            super.setInternal(ttl, timeunit, key, value);
         } finally {
             invalidateNearCache(key);
         }
     }
     @Override
     protected boolean evictInternal(Object key) {
         key = toNearCacheKey(key);
         boolean evicted;
         try {
             evicted = super.evictInternal(key);
@@ -529,28 +515,28 @@
         }
         if (value == CACHED_AS_NULL) {
             return null;
         }
         return deserializeValue ? toObject(value) : value;
     }
     public NearCache<Object, Object> getNearCache() {
         return nearCache;
     }
     private void invalidateNearCache(Object key) {
-        nearCache.invalidate(key);
+        nearCache.remove(key);
     }
     public String addNearCacheInvalidationListener(EventHandler handler) {
         return registerListener(createNearCacheEntryListenerCodec(), handler);
     }
     private void registerInvalidationListener() {
         try {
-            invalidationListenerId = addNearCacheInvalidationListener(new NearCacheInvalidationEventHandler());
+            invalidationListenerId = addNearCacheInvalidationListener(new ConnectedServerVersionAwareNearCacheEventHandler());
         } catch (Exception e) {
             ILogger logger = getContext().getLoggingService().getLogger(getClass());
             logger.severe("-----------------\nNear Cache is not initialized!\n-----------------", e);
         }
     }
     @SuppressWarnings("checkstyle:anoninnerlength")
     private ListenerMessageCodec createNearCacheEntryListenerCodec() {
         return new ListenerMessageCodec() {
             @Override
             public ClientMessage encodeAddRequest(boolean localOnly) {
@@ -577,74 +563,115 @@
         };
     }
     private void removeNearCacheInvalidationListener() {
         String invalidationListenerId = this.invalidationListenerId;
         if (invalidationListenerId == null) {
             return;
         }
         getContext().getRepairingTask(getServiceName()).deregisterHandler(name);
         deregisterListener(invalidationListenerId);
     }
-    private boolean supportsRepairableNearCache() {
-        return getConnectedServerVersion() >= minConsistentNearCacheSupportingServerVersion;
-    }
     /**
-     * Eventual consistency for Near Cache can be used with server versions >= 3.8
-     * For repairing functionality please see {@link RepairingHandler}
-     * handleCacheInvalidationEventV14 and handleCacheBatchInvalidationEventV14
-     *
-     * If server version is < 3.8 and client version is >= 3.8, eventual consistency is not supported
-     * Following methods handle the old behaviour:
-     * handleCacheBatchInvalidationEventV10 and handleCacheInvalidationEventV10
+     * Deals with client compatibility.
+     * <p>
+     * Eventual consistency for Near Cache can be used with server versions >= 3.8,
+     * other connected server versions must use {@link Pre38NearCacheEventHandler}
      */
-    private final class NearCacheInvalidationEventHandler
+    private final class ConnectedServerVersionAwareNearCacheEventHandler implements EventHandler<ClientMessage> {
+        private final Pre38NearCacheEventHandler pre38EventHandler = new Pre38NearCacheEventHandler();
+        private final RepairableNearCacheEventHandler repairingEventHandler = new RepairableNearCacheEventHandler();
+        private volatile boolean supportsRepairableNearCache;
+        @Override
+        public void beforeListenerRegister() {
+            repairingEventHandler.beforeListenerRegister();
+            supportsRepairableNearCache = supportsRepairableNearCache();
+            if (!supportsRepairableNearCache) {
+                pre38EventHandler.beforeListenerRegister();
+                logger.warning(format("Near Cache for '%s' map is started in legacy mode", name));
+            }
+        }
+        @Override
+        public void onListenerRegister() {
+            if (supportsRepairableNearCache) {
+                repairingEventHandler.onListenerRegister();
+            } else {
+                pre38EventHandler.onListenerRegister();
+            }
+        }
+        @Override
+        public void handle(ClientMessage clientMessage) {
+            if (supportsRepairableNearCache) {
+                repairingEventHandler.handle(clientMessage);
+            } else {
+                pre38EventHandler.handle(clientMessage);
+            }
+        }
+    }
+    /**
+     * This event handler can only be used with server versions >= 3.8 and supports Near Cache eventual consistency improvements.
+     * For repairing functionality please see {@link RepairingHandler}.
+     */
+    private final class RepairableNearCacheEventHandler
             extends MapAddNearCacheInvalidationListenerCodec.AbstractEventHandler
             implements EventHandler<ClientMessage> {
         private volatile RepairingHandler repairingHandler;
-        private volatile boolean supportsRepairableNearCache;
         @Override
         public void beforeListenerRegister() {
-            supportsRepairableNearCache = supportsRepairableNearCache();
-            if (supportsRepairableNearCache) {
+            if (supportsRepairableNearCache()) {
                 RepairingTask repairingTask = getContext().getRepairingTask(getServiceName());
                 repairingHandler = repairingTask.registerAndGetHandler(name, nearCache);
             } else {
-                nearCache.clear();
                 RepairingTask repairingTask = getContext().getRepairingTask(getServiceName());
                 repairingTask.deregisterHandler(name);
-                logger.warning(format("Near Cache for '%s' map is started in legacy mode", name));
             }
         }
         @Override
         public void onListenerRegister() {
-            if (!supportsRepairableNearCache) {
+        }
+        @Override
+        public void handle(Data key, String sourceUuid, UUID partitionUuid, long sequence) {
+            repairingHandler.handle(key, sourceUuid, partitionUuid, sequence);
+        }
+        @Override
+        public void handle(Collection<Data> keys, Collection<String> sourceUuids,
+                           Collection<UUID> partitionUuids, Collection<Long> sequences) {
+            repairingHandler.handle(keys, sourceUuids, partitionUuids, sequences);
+        }
+    }
+    /**
+     * This event handler is here to be used with server versions < 3.8.
+     * <p>
+     * If server version is < 3.8 and client version is >= 3.8, this event handler must be used to
+     * listen Near Cache invalidations. Because new improvements for Near Cache eventual consistency
+     * cannot work with server versions < 3.8.
+     */
+    private final class Pre38NearCacheEventHandler
+            extends MapAddNearCacheEntryListenerCodec.AbstractEventHandler
+            implements EventHandler<ClientMessage> {
+        @Override
+        public void beforeListenerRegister() {
+            nearCache.clear();
+        }
+        @Override
+        public void onListenerRegister() {
+            nearCache.clear();
+        }
+        @Override
+        public void handle(Data key, String sourceUuid, UUID partitionUuid, long sequence) {
+            if (key == null) {
                 nearCache.clear();
-            }
-        }
-        @Override
-        public void handleIMapInvalidationEventV10(Data key) {
-            if (key != null) {
-                nearCache.invalidate(serializeKeys ? key : toObject(key));
             } else {
-                nearCache.clear();
-            }
-        }
-        @Override
-        public void handleIMapBatchInvalidationEventV10(Collection<Data> keys) {
+                nearCache.remove(serializeKeys ? key : toObject(key));
+            }
+        }
+        @Override
+        public void handle(Collection<Data> keys, Collection<String> sourceUuids,
+                           Collection<UUID> partitionUuids, Collection<Long> sequences) {
             for (Data key : keys) {
-                nearCache.invalidate(serializeKeys ? key : toObject(key));
-            }
-        }
-        @Override
-        public void handleIMapInvalidationEventV14(Data key, String sourceUuid,
-                                                   UUID partitionUuid, long sequence) {
-            repairingHandler.handle(key, sourceUuid, partitionUuid, sequence);
-        }
-        @Override
-        public void handleIMapBatchInvalidationEventV14(Collection<Data> keys,
-                                                        Collection<String> sourceUuids,
-                                                        Collection<UUID> partitionUuids,
-                                                        Collection<Long> sequences) {
-            repairingHandler.handle(keys, sourceUuids, partitionUuids, sequences);
-        }
+                nearCache.remove(serializeKeys ? key : toObject(key));
+            }
+        }
+    }
+    private boolean supportsRepairableNearCache() {
+        return getConnectedServerVersion() >= minConsistentNearCacheSupportingServerVersion;
     }
 }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/PartitionServiceProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/PartitionServiceProxy.java
@@ -115,21 +115,21 @@
     public boolean forceLocalMemberToBeSafe(long timeout, TimeUnit unit) {
         throw new UnsupportedOperationException();
     }
     private static class ClientPartitionLostEventHandler extends ClientAddPartitionLostListenerCodec.AbstractEventHandler
             implements EventHandler<ClientMessage> {
         private PartitionLostListener listener;
         public ClientPartitionLostEventHandler(PartitionLostListener listener) {
             this.listener = listener;
         }
         @Override
-        public void handlePartitionLostEventV10(int partitionId, int lostBackupCount, Address source) {
+        public void handle(int partitionId, int lostBackupCount, Address source) {
             listener.partitionLost(new PartitionLostEvent(partitionId, lostBackupCount, source));
         }
         @Override
         public void beforeListenerRegister() {
         }
         @Override
         public void onListenerRegister() {
         }
     }
 }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/PartitionSpecificClientProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/PartitionSpecificClientProxy.java
@@ -7,21 +7,21 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.proxy;
-import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
+import com.hazelcast.client.impl.ClientMessageDecoder;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.spi.ClientContext;
 import com.hazelcast.client.spi.ClientProxy;
 import com.hazelcast.client.spi.impl.ClientInvocation;
 import com.hazelcast.client.spi.impl.ClientInvocationFuture;
 import com.hazelcast.client.util.ClientDelegatingFuture;
 import com.hazelcast.partition.strategy.StringPartitioningStrategy;
 import com.hazelcast.util.ExceptionUtil;
 import java.util.concurrent.Future;
 import static com.hazelcast.util.ExceptionUtil.rethrow;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/txn/ClientTransactionUtil.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/txn/ClientTransactionUtil.java
@@ -7,21 +7,21 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.proxy.txn;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.spi.impl.ClientInvocation;
 import com.hazelcast.nio.Connection;
 import com.hazelcast.transaction.TransactionException;
 import com.hazelcast.util.ExceptionUtil.RuntimeExceptionFactory;
 import java.util.concurrent.Future;
 import static com.hazelcast.util.ExceptionUtil.rethrow;
 /**
  * Contains static method that is used from client transaction classes.
  */

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/txn/ClientTxnProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/txn/ClientTxnProxy.java
@@ -8,21 +8,21 @@
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.proxy.txn;
 import com.hazelcast.client.connection.nio.ClientConnection;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.ClientDestroyProxyCodec;
 import com.hazelcast.client.spi.ClientTransactionContext;
 import com.hazelcast.nio.serialization.Data;
 import com.hazelcast.partition.strategy.StringPartitioningStrategy;
 import com.hazelcast.spi.serialization.SerializationService;
 import com.hazelcast.transaction.TransactionalObject;
 abstract class ClientTxnProxy implements TransactionalObject {
     final String name;
     final ClientTransactionContext transactionContext;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/txn/TransactionContextProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/txn/TransactionContextProxy.java
@@ -8,21 +8,21 @@
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.proxy.txn;
 import com.hazelcast.client.connection.nio.ClientConnection;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.spi.ClientTransactionContext;
 import com.hazelcast.client.spi.impl.ClientTransactionManagerServiceImpl;
 import com.hazelcast.collection.impl.list.ListService;
 import com.hazelcast.collection.impl.queue.QueueService;
 import com.hazelcast.collection.impl.set.SetService;
 import com.hazelcast.core.TransactionalList;
 import com.hazelcast.core.TransactionalMap;
 import com.hazelcast.core.TransactionalMultiMap;
 import com.hazelcast.core.TransactionalQueue;
 import com.hazelcast.core.TransactionalSet;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/txn/TransactionProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/txn/TransactionProxy.java
@@ -8,21 +8,21 @@
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.proxy.txn;
 import com.hazelcast.client.connection.nio.ClientConnection;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.TransactionCommitCodec;
 import com.hazelcast.client.impl.protocol.codec.TransactionCreateCodec;
 import com.hazelcast.client.impl.protocol.codec.TransactionRollbackCodec;
 import com.hazelcast.logging.ILogger;
 import com.hazelcast.transaction.TransactionException;
 import com.hazelcast.transaction.TransactionNotActiveException;
 import com.hazelcast.transaction.TransactionOptions;
 import com.hazelcast.util.Clock;
 import com.hazelcast.util.ThreadUtil;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/txn/xa/XATransactionContextProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/txn/xa/XATransactionContextProxy.java
@@ -8,21 +8,21 @@
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.proxy.txn.xa;
 import com.hazelcast.client.connection.nio.ClientConnection;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.proxy.txn.ClientTxnListProxy;
 import com.hazelcast.client.proxy.txn.ClientTxnMapProxy;
 import com.hazelcast.client.proxy.txn.ClientTxnMultiMapProxy;
 import com.hazelcast.client.proxy.txn.ClientTxnQueueProxy;
 import com.hazelcast.client.proxy.txn.ClientTxnSetProxy;
 import com.hazelcast.client.spi.ClientTransactionContext;
 import com.hazelcast.client.spi.impl.ClientTransactionManagerServiceImpl;
 import com.hazelcast.collection.impl.list.ListService;
 import com.hazelcast.collection.impl.queue.QueueService;
 import com.hazelcast.collection.impl.set.SetService;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/proxy/txn/xa/XATransactionProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/proxy/txn/xa/XATransactionProxy.java
@@ -8,21 +8,21 @@
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.proxy.txn.xa;
 import com.hazelcast.client.connection.nio.ClientConnection;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.XATransactionCommitCodec;
 import com.hazelcast.client.impl.protocol.codec.XATransactionCreateCodec;
 import com.hazelcast.client.impl.protocol.codec.XATransactionPrepareCodec;
 import com.hazelcast.client.impl.protocol.codec.XATransactionRollbackCodec;
 import com.hazelcast.client.proxy.txn.ClientTransactionUtil;
 import com.hazelcast.logging.ILogger;
 import com.hazelcast.transaction.TransactionException;
 import com.hazelcast.transaction.TransactionNotActiveException;
 import com.hazelcast.transaction.impl.Transaction;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/spi/ClientContext.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/spi/ClientContext.java
@@ -8,30 +8,30 @@
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.spi;
 import com.hazelcast.cache.impl.CacheService;
-import com.hazelcast.client.cache.impl.nearcache.invalidation.ClientCacheInvalidationMetaDataFetcher;
+import com.hazelcast.client.cache.impl.nearcache.invalidation.ClientCacheMetaDataFetcher;
 import com.hazelcast.client.config.ClientConfig;
 import com.hazelcast.client.connection.ClientConnectionManager;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.impl.querycache.ClientQueryCacheContext;
-import com.hazelcast.client.map.impl.nearcache.invalidation.ClientMapInvalidationMetaDataFetcher;
+import com.hazelcast.client.map.impl.nearcache.invalidation.ClientMapMetaDataFetcher;
 import com.hazelcast.core.HazelcastInstance;
 import com.hazelcast.core.LifecycleService;
 import com.hazelcast.internal.nearcache.NearCacheManager;
-import com.hazelcast.internal.nearcache.impl.invalidation.InvalidationMetaDataFetcher;
+import com.hazelcast.internal.nearcache.impl.invalidation.MetaDataFetcher;
 import com.hazelcast.internal.nearcache.impl.invalidation.MinimalPartitionService;
 import com.hazelcast.internal.nearcache.impl.invalidation.RepairingTask;
 import com.hazelcast.logging.ILogger;
 import com.hazelcast.logging.LoggingService;
 import com.hazelcast.map.impl.MapService;
 import com.hazelcast.nio.serialization.Data;
 import com.hazelcast.spi.properties.HazelcastProperties;
 import com.hazelcast.spi.serialization.SerializationService;
 import com.hazelcast.util.ConstructorFunction;
 import java.util.concurrent.ConcurrentHashMap;
@@ -94,32 +94,31 @@
     public RepairingTask getRepairingTask(String serviceName) {
         return getOrPutIfAbsent(repairingTasks, serviceName, repairingTaskConstructor);
     }
     private String getLocalUuid() {
         if (this.localUuid == null) {
             this.localUuid = clusterService.getLocalClient().getUuid();
         }
         return this.localUuid;
     }
     private RepairingTask newRepairingTask(String serviceName) {
-        InvalidationMetaDataFetcher invalidationMetaDataFetcher = newMetaDataFetcher(serviceName);
+        MetaDataFetcher metaDataFetcher = newMetaDataFetcher(serviceName);
         ILogger logger = loggingService.getLogger(RepairingTask.class);
-        return new RepairingTask(properties, invalidationMetaDataFetcher,
-                executionService, serializationService, minimalPartitionService,
+        return new RepairingTask(properties, metaDataFetcher, executionService, serializationService, minimalPartitionService,
                 getLocalUuid(), logger);
     }
-    private InvalidationMetaDataFetcher newMetaDataFetcher(String serviceName) {
+    private MetaDataFetcher newMetaDataFetcher(String serviceName) {
         if (MapService.SERVICE_NAME.equals(serviceName)) {
-            return new ClientMapInvalidationMetaDataFetcher(this);
+            return new ClientMapMetaDataFetcher(this);
         }
         if (CacheService.SERVICE_NAME.equals(serviceName)) {
-            return new ClientCacheInvalidationMetaDataFetcher(this);
+            return new ClientCacheMetaDataFetcher(this);
         }
         throw new IllegalArgumentException(format("%s is not a known service-name to fetch metadata for", serviceName));
     }
     public String getName() {
         return name;
     }
     /**
      * Client side implementation of {@link MinimalPartitionService}
      */
     private class ClientMinimalPartitionService implements MinimalPartitionService {

--- a/hazelcast-client/src/main/java/com/hazelcast/client/spi/ClientProxy.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/spi/ClientProxy.java
@@ -9,21 +9,21 @@
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.spi;
 import com.hazelcast.client.connection.ClientConnectionManager;
 import com.hazelcast.client.connection.nio.ClientConnection;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.ClientDestroyProxyCodec;
 import com.hazelcast.client.spi.impl.ClientInvocation;
 import com.hazelcast.client.spi.impl.ListenerMessageCodec;
 import com.hazelcast.core.DistributedObject;
 import com.hazelcast.nio.Address;
 import com.hazelcast.nio.serialization.Data;
 import com.hazelcast.partition.strategy.StringPartitioningStrategy;
 import com.hazelcast.spi.serialization.SerializationService;
 import com.hazelcast.util.ExceptionUtil;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/spi/ClientTransactionContext.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/spi/ClientTransactionContext.java
@@ -8,21 +8,21 @@
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.spi;
 import com.hazelcast.client.connection.nio.ClientConnection;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.transaction.TransactionContext;
 /**
  * Provides a context to perform transactional operations: beginning/committing transactions, but also retrieving
  * transactional data-structures like the {@link com.hazelcast.core.TransactionalMap}.
  *
  * Provides client instance and client connection proxies that need to be accessed for sending invocations.
  */
 public interface ClientTransactionContext extends TransactionContext {
     HazelcastClientInstanceImpl getClient();
     ClientConnection getConnection();

--- a/hazelcast-client/src/main/java/com/hazelcast/client/spi/ProxyManager.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/spi/ProxyManager.java
@@ -16,21 +16,21 @@
 package com.hazelcast.client.spi;
 import com.hazelcast.cache.impl.ICacheService;
 import com.hazelcast.cache.impl.JCacheDetector;
 import com.hazelcast.cardinality.impl.CardinalityEstimatorService;
 import com.hazelcast.client.ClientExtension;
 import com.hazelcast.client.HazelcastClientOfflineException;
 import com.hazelcast.client.LoadBalancer;
 import com.hazelcast.client.cache.impl.ClientCacheProxyFactory;
 import com.hazelcast.client.config.ClientConfig;
 import com.hazelcast.client.config.ProxyFactoryConfig;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.ClientAddDistributedObjectListenerCodec;
 import com.hazelcast.client.impl.protocol.codec.ClientCreateProxiesCodec;
 import com.hazelcast.client.impl.protocol.codec.ClientCreateProxyCodec;
 import com.hazelcast.client.impl.protocol.codec.ClientRemoveDistributedObjectListenerCodec;
 import com.hazelcast.client.proxy.ClientAtomicLongProxy;
 import com.hazelcast.client.proxy.ClientAtomicReferenceProxy;
 import com.hazelcast.client.proxy.ClientCardinalityEstimatorProxy;
 import com.hazelcast.client.proxy.ClientCountDownLatchProxy;
 import com.hazelcast.client.proxy.ClientDurableExecutorServiceProxy;
@@ -104,22 +104,21 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.ExecutionException;
 import static com.hazelcast.util.ExceptionUtil.rethrow;
 import static com.hazelcast.util.ServiceLoader.classIterator;
 import static java.lang.Thread.currentThread;
 /**
  * The ProxyManager handles client proxy instantiation and retrieval at start and runtime by registering
  * corresponding service manager names and their {@link com.hazelcast.client.spi.ClientProxyFactory}s.
  */
-@SuppressWarnings({"checkstyle:classfanoutcomplexity",
-        "checkstyle:classdataabstractioncoupling", "checkstyle:methodcount"})
+@SuppressWarnings({"checkstyle:classfanoutcomplexity", "checkstyle:classdataabstractioncoupling"})
 public final class ProxyManager {
     private static final String PROVIDER_ID = ClientProxyDescriptorProvider.class.getCanonicalName();
     private static final Class[] LEGACY_CONSTRUCTOR_ARGUMENT_TYPES = new Class[]{String.class, String.class};
     private static final Class[] CONSTRUCTOR_ARGUMENT_TYPES = new Class[]{String.class, String.class, ClientContext.class};
     private final ConcurrentMap<String, ClientProxyFactory> proxyFactories = new ConcurrentHashMap<String, ClientProxyFactory>();
     private final ConcurrentMap<ObjectNamespace, ClientProxyFuture> proxies
             = new ConcurrentHashMap<ObjectNamespace, ClientProxyFuture>();
     private final ListenerMessageCodec distributedObjectListenerCodec = new ListenerMessageCodec() {
         @Override
         public ClientMessage encodeAddRequest(boolean localOnly) {
@@ -445,21 +444,21 @@
     }
     private final class DistributedObjectEventHandler extends ClientAddDistributedObjectListenerCodec.AbstractEventHandler
             implements EventHandler<ClientMessage> {
         private final DistributedObjectListener listener;
         private ProxyManager proxyManager;
         private DistributedObjectEventHandler(DistributedObjectListener listener, ProxyManager proxyManager) {
             this.listener = listener;
             this.proxyManager = proxyManager;
         }
         @Override
-        public void handleDistributedObjectEventV10(String name, String serviceName, String eventTypeName) {
+        public void handle(String name, String serviceName, String eventTypeName) {
             final ObjectNamespace ns = new DistributedObjectNamespace(serviceName, name);
             ClientProxyFuture future = proxies.get(ns);
             ClientProxy proxy = future == null ? null : future.get();
             DistributedObjectEvent.EventType eventType = DistributedObjectEvent.EventType.valueOf(eventTypeName);
             LazyDistributedObjectEvent event = new LazyDistributedObjectEvent(eventType, serviceName, name, proxy,
                     proxyManager);
             if (DistributedObjectEvent.EventType.CREATED.equals(eventType)) {
                 listener.distributedObjectCreated(event);
             } else if (DistributedObjectEvent.EventType.DESTROYED.equals(eventType)) {
                 listener.distributedObjectDestroyed(event);

--- a/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/AbstractClientInvocationService.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/AbstractClientInvocationService.java
@@ -10,138 +10,127 @@
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.spi.impl;
 import com.hazelcast.client.HazelcastClientNotActiveException;
 import com.hazelcast.client.connection.ClientConnectionManager;
 import com.hazelcast.client.connection.nio.ClientConnection;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.spi.ClientExecutionService;
 import com.hazelcast.client.spi.ClientInvocationService;
 import com.hazelcast.client.spi.ClientPartitionService;
 import com.hazelcast.client.spi.EventHandler;
 import com.hazelcast.client.spi.impl.listener.AbstractClientListenerService;
 import com.hazelcast.internal.metrics.Probe;
+import com.hazelcast.internal.metrics.ProbeLevel;
 import com.hazelcast.logging.ILogger;
 import com.hazelcast.spi.exception.TargetDisconnectedException;
-import com.hazelcast.spi.impl.sequence.CallIdFactory;
-import com.hazelcast.spi.impl.sequence.CallIdSequence;
-import com.hazelcast.spi.properties.HazelcastProperties;
 import com.hazelcast.spi.properties.HazelcastProperty;
 import java.io.IOException;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
-import static com.hazelcast.client.spi.properties.ClientProperty.BACKPRESSURE_BACKOFF_TIMEOUT_MILLIS;
 import static com.hazelcast.client.spi.properties.ClientProperty.INVOCATION_RETRY_PAUSE_MILLIS;
 import static com.hazelcast.client.spi.properties.ClientProperty.INVOCATION_TIMEOUT_SECONDS;
-import static com.hazelcast.client.spi.properties.ClientProperty.MAX_CONCURRENT_INVOCATIONS;
-import static com.hazelcast.internal.metrics.ProbeLevel.MANDATORY;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 public abstract class AbstractClientInvocationService implements ClientInvocationService {
     private static final HazelcastProperty CLEAN_RESOURCES_MILLIS
             = new HazelcastProperty("hazelcast.client.internal.clean.resources.millis", 100, MILLISECONDS);
     protected final HazelcastClientInstanceImpl client;
     protected ClientConnectionManager connectionManager;
     protected ClientPartitionService partitionService;
     final ILogger invocationLogger;
     private AbstractClientListenerService clientListenerService;
-    @Probe(name = "pendingCalls", level = MANDATORY)
+    @Probe(name = "pendingCalls", level = ProbeLevel.MANDATORY)
     private ConcurrentMap<Long, ClientInvocation> invocations = new ConcurrentHashMap<Long, ClientInvocation>();
     private ClientResponseHandlerSupplier responseHandlerSupplier;
     private volatile boolean isShutdown;
     private final long invocationTimeoutMillis;
     private final long invocationRetryPauseMillis;
-    private final CallIdSequence callIdSequence;
     public AbstractClientInvocationService(HazelcastClientInstanceImpl client) {
         this.client = client;
         this.invocationLogger = client.getLoggingService().getLogger(ClientInvocationService.class);
         this.invocationTimeoutMillis = initInvocationTimeoutMillis();
         this.invocationRetryPauseMillis = initInvocationRetryPauseMillis();
         this.responseHandlerSupplier = new ClientResponseHandlerSupplier(this);
-        HazelcastProperties properties = client.getProperties();
-        int maxAllowedConcurrentInvocations = properties.getInteger(MAX_CONCURRENT_INVOCATIONS);
-        long backofftimeoutMs = properties.getLong(BACKPRESSURE_BACKOFF_TIMEOUT_MILLIS);
-        boolean isBackPressureEnabled = maxAllowedConcurrentInvocations != Integer.MAX_VALUE;
-        callIdSequence = CallIdFactory
-                .newCallIdSequence(isBackPressureEnabled, maxAllowedConcurrentInvocations, backofftimeoutMs);
         client.getMetricsRegistry().scanAndRegister(this, "invocations");
     }
     private long initInvocationRetryPauseMillis() {
-        return client.getProperties().getPositiveMillisOrDefault(INVOCATION_RETRY_PAUSE_MILLIS);
+        long pauseTime = client.getProperties().getMillis(INVOCATION_RETRY_PAUSE_MILLIS);
+        return pauseTime > 0 ? pauseTime : Long.parseLong(INVOCATION_RETRY_PAUSE_MILLIS.getDefaultValue());
     }
     private long initInvocationTimeoutMillis() {
-        return client.getProperties().getPositiveMillisOrDefault(INVOCATION_TIMEOUT_SECONDS);
-    }
-    @Probe(level = MANDATORY)
-    private long startedInvocations() {
-        return callIdSequence.getLastCallId();
-    }
-    @Probe(level = MANDATORY)
-    private long maxCurrentInvocations() {
-        return callIdSequence.getMaxConcurrentInvocations();
-    }
-    public long getInvocationTimeoutMillis() {
-        return invocationTimeoutMillis;
-    }
-    public long getInvocationRetryPauseMillis() {
-        return invocationRetryPauseMillis;
-    }
-    CallIdSequence getCallIdSequence() {
-        return callIdSequence;
+        long waitTime = client.getProperties().getMillis(INVOCATION_TIMEOUT_SECONDS);
+        return waitTime > 0 ? waitTime : Integer.parseInt(INVOCATION_TIMEOUT_SECONDS.getDefaultValue());
     }
     public void start() {
         connectionManager = client.getConnectionManager();
         clientListenerService = (AbstractClientListenerService) client.getListenerService();
         partitionService = client.getClientPartitionService();
         responseHandlerSupplier.start();
         ClientExecutionService executionService = client.getClientExecutionService();
-        long cleanResourcesMillis = client.getProperties().getPositiveMillisOrDefault(CLEAN_RESOURCES_MILLIS);
+        long cleanResourcesMillis = client.getProperties().getMillis(CLEAN_RESOURCES_MILLIS);
+        if (cleanResourcesMillis <= 0) {
+            cleanResourcesMillis = Integer.parseInt(CLEAN_RESOURCES_MILLIS.getDefaultValue());
+        }
         executionService.scheduleWithRepetition(new CleanResourcesTask(), cleanResourcesMillis,
                 cleanResourcesMillis, MILLISECONDS);
     }
     @Override
     public ClientResponseHandler getResponseHandler() {
         return responseHandlerSupplier.get();
     }
     @Override
     public boolean isRedoOperation() {
         return client.getClientConfig().getNetworkConfig().isRedoOperation();
     }
     protected void send(ClientInvocation invocation, ClientConnection connection) throws IOException {
         if (isShutdown) {
             throw new HazelcastClientNotActiveException("Client is shut down");
         }
         registerInvocation(invocation);
         ClientMessage clientMessage = invocation.getClientMessage();
-        if (!writeToConnection(connection, clientMessage)) {
+        if (!isAllowedToSendRequest(connection, invocation) || !writeToConnection(connection, clientMessage)) {
             final long callId = clientMessage.getCorrelationId();
             ClientInvocation clientInvocation = deRegisterCallId(callId);
             if (clientInvocation != null) {
                 throw new IOException("Packet not sent to " + connection.getEndPoint());
             } else {
                 if (invocationLogger.isFinestEnabled()) {
                     invocationLogger.finest("Invocation not found to deregister for call ID " + callId);
                 }
                 return;
             }
         }
         invocation.setSendConnection(connection);
     }
     private boolean writeToConnection(ClientConnection connection, ClientMessage clientMessage) {
         clientMessage.addFlag(ClientMessage.BEGIN_AND_END_FLAGS);
         return connection.write(clientMessage);
+    }
+    private boolean isAllowedToSendRequest(ClientConnection connection, ClientInvocation invocation) {
+        if (!connection.isHeartBeating()) {
+            if (invocation.shouldBypassHeartbeatCheck()) {
+                return true;
+            }
+            if (invocationLogger.isFinestEnabled()) {
+                invocationLogger.finest("Connection is not heart-beating, won't write client message -> "
+                        + invocation.getClientMessage());
+            }
+            return false;
+        }
+        return true;
     }
     private void registerInvocation(ClientInvocation clientInvocation) {
         short protocolVersion = client.getProtocolVersion();
         ClientMessage clientMessage = clientInvocation.getClientMessage();
         clientMessage.setVersion(protocolVersion);
         long correlationId = clientMessage.getCorrelationId();
         invocations.put(correlationId, clientInvocation);
         EventHandler handler = clientInvocation.getEventHandler();
         if (handler != null) {
             clientListenerService.addEventHandler(correlationId, handler);
@@ -156,34 +145,45 @@
     public void shutdown() {
         isShutdown = true;
         responseHandlerSupplier.shutdown();
         Iterator<ClientInvocation> iterator = invocations.values().iterator();
         while (iterator.hasNext()) {
             ClientInvocation invocation = iterator.next();
             iterator.remove();
             invocation.notifyException(new HazelcastClientNotActiveException("Client is shutting down"));
         }
     }
+    public long getInvocationTimeoutMillis() {
+        return invocationTimeoutMillis;
+    }
+    public long getInvocationRetryPauseMillis() {
+        return invocationRetryPauseMillis;
+    }
     private class CleanResourcesTask implements Runnable {
         @Override
         public void run() {
             Iterator<Map.Entry<Long, ClientInvocation>> iter = invocations.entrySet().iterator();
             while (iter.hasNext()) {
                 Map.Entry<Long, ClientInvocation> entry = iter.next();
                 ClientInvocation invocation = entry.getValue();
                 ClientConnection connection = invocation.getSendConnection();
                 if (connection == null) {
                     continue;
                 }
-                if (connection.isAlive()) {
+                if (connection.isHeartBeating()) {
                     continue;
                 }
                 iter.remove();
                 notifyException(invocation, connection);
             }
         }
         private void notifyException(ClientInvocation invocation, ClientConnection connection) {
-            Exception ex = new TargetDisconnectedException(connection.getCloseReason(), connection.getCloseCause());
+            Exception ex;
+            if (!connection.isAlive()) {
+                ex = new TargetDisconnectedException(connection.getCloseReason(), connection.getCloseCause());
+            } else {
+                ex = new TargetDisconnectedException("Heartbeat timed out to " + connection);
+            }
             invocation.notifyException(ex);
         }
     }
 }

--- a//dev/null
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/AwsAddressProvider.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.hazelcast.client.spi.impl;
+import com.hazelcast.aws.AWSClient;
+import com.hazelcast.client.config.ClientAwsConfig;
+import com.hazelcast.client.connection.AddressProvider;
+import com.hazelcast.client.util.AddressHelper;
+import com.hazelcast.logging.ILogger;
+import com.hazelcast.logging.LoggingService;
+import com.hazelcast.nio.Address;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Map;
+/**
+ * Calls the AWS API to load ip addresses related to given credentials.
+ */
+public class AwsAddressProvider implements AddressProvider {
+    private final ILogger logger;
+    private final AWSClient awsClient;
+    private volatile Map<String, String> privateToPublic;
+    public AwsAddressProvider(ClientAwsConfig awsConfig, LoggingService loggingService) {
+        this(new AWSClient(awsConfig), loggingService);
+    }
+    AwsAddressProvider(AWSClient awsClient, LoggingService loggingService) {
+        this.awsClient = awsClient;
+        this.logger = loggingService.getLogger(AwsAddressProvider.class);
+    }
+    @Override
+    public Collection<Address> loadAddresses() {
+        updateLookupTable();
+        final Map<String, String> lookupTable = getLookupTable();
+        final Collection<Address> addresses = new ArrayList<Address>(lookupTable.size());
+        for (String privateAddress : lookupTable.keySet()) {
+            addresses.addAll(AddressHelper.getSocketAddresses(privateAddress));
+        }
+        return addresses;
+    }
+    private Map<String, String> getLookupTable() {
+        Map<String, String> table = privateToPublic;
+        return table != null ? table : Collections.<String, String>emptyMap();
+    }
+    private void updateLookupTable() {
+        try {
+            privateToPublic = awsClient.getAddresses();
+        } catch (Exception e) {
+            logger.warning("Aws addresses failed to load: " + e.getMessage());
+        }
+    }
+}

--- a//dev/null
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/AwsAddressTranslator.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.hazelcast.client.spi.impl;
+import com.hazelcast.aws.AWSClient;
+import com.hazelcast.client.config.ClientAwsConfig;
+import com.hazelcast.client.connection.AddressTranslator;
+import com.hazelcast.logging.ILogger;
+import com.hazelcast.logging.LoggingService;
+import com.hazelcast.nio.Address;
+import java.net.UnknownHostException;
+import java.util.HashMap;
+import java.util.Map;
+/**
+ * AwsAddressTranslator loads EC2 IP addresses with given AWS credentials.
+ *
+ * Keeps a lookup table of private to public IP addresses.
+ */
+public class AwsAddressTranslator implements AddressTranslator {
+    private final ILogger logger;
+    private final AWSClient awsClient;
+    private final boolean isInsideAws;
+    private volatile Map<String, String> privateToPublic = new HashMap<String, String>();
+    public AwsAddressTranslator(ClientAwsConfig awsConfig, LoggingService loggingService) {
+        this(new AWSClient(awsConfig), awsConfig, loggingService);
+    }
+    AwsAddressTranslator(AWSClient awsClient, ClientAwsConfig awsConfig, LoggingService loggingService) {
+        this.awsClient = awsClient;
+        this.isInsideAws = awsConfig.isInsideAws();
+        this.logger = loggingService.getLogger(AwsAddressTranslator.class);
+    }
+    /**
+     * Translates an IP address from the private AWS network to the public network.
+     *
+     * @param address the private address to translate
+     * @return public address of network whose private address is given, if address not founds returns {@code null}.
+     */
+    @Override
+    public Address translate(Address address) {
+        if (isInsideAws) {
+            return address;
+        }
+        if (address == null) {
+            return null;
+        }
+        String publicAddress = privateToPublic.get(address.getHost());
+        if (publicAddress != null) {
+            return createAddressOrNull(publicAddress, address);
+        }
+        if (privateToPublic.values().contains(address.getHost())) {
+            return address;
+        }
+        refresh();
+        publicAddress = privateToPublic.get(address.getHost());
+        if (publicAddress != null) {
+            return createAddressOrNull(publicAddress, address);
+        }
+        return null;
+    }
+    @Override
+    public void refresh() {
+        try {
+            privateToPublic = awsClient.getAddresses();
+        } catch (Exception e) {
+            logger.warning("AWS addresses failed to load: " + e.getMessage());
+        }
+    }
+    Map<String, String> getLookupTable() {
+        return privateToPublic;
+    }
+    private static Address createAddressOrNull(String hostAddress, Address portAddress) {
+        try {
+            return new Address(hostAddress, portAddress.getPort());
+        } catch (UnknownHostException e) {
+            return null;
+        }
+    }
+}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientClusterServiceImpl.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientClusterServiceImpl.java
@@ -10,23 +10,23 @@
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.spi.impl;
 import com.hazelcast.client.config.ClientConfig;
 import com.hazelcast.client.connection.ClientConnectionManager;
 import com.hazelcast.client.connection.nio.ClientConnection;
+import com.hazelcast.client.impl.ClientImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.impl.client.ClientPrincipal;
-import com.hazelcast.client.impl.clientside.ClientImpl;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
 import com.hazelcast.client.spi.ClientClusterService;
 import com.hazelcast.config.ListenerConfig;
 import com.hazelcast.core.Client;
 import com.hazelcast.core.Cluster;
 import com.hazelcast.core.InitialMembershipEvent;
 import com.hazelcast.core.InitialMembershipListener;
 import com.hazelcast.core.Member;
 import com.hazelcast.core.MemberAttributeEvent;
 import com.hazelcast.core.MemberSelector;
 import com.hazelcast.core.MembershipEvent;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientInvocation.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientInvocation.java
@@ -9,21 +9,21 @@
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.spi.impl;
 import com.hazelcast.client.HazelcastClientNotActiveException;
 import com.hazelcast.client.connection.nio.ClientConnection;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.spi.ClientClusterService;
 import com.hazelcast.client.spi.ClientExecutionService;
 import com.hazelcast.client.spi.EventHandler;
 import com.hazelcast.core.HazelcastInstanceNotActiveException;
 import com.hazelcast.core.HazelcastOverloadException;
 import com.hazelcast.core.LifecycleService;
 import com.hazelcast.core.OperationTimeoutException;
 import com.hazelcast.logging.ILogger;
 import com.hazelcast.nio.Address;
@@ -59,20 +59,21 @@
     private final ClientExecutionService executionService;
     private volatile ClientMessage clientMessage;
     private final CallIdSequence callIdSequence;
     private final Address address;
     private final int partitionId;
     private final Connection connection;
     private final long startTimeMillis;
     private final long retryPauseMillis;
     private final String objectName;
     private volatile ClientConnection sendConnection;
+    private boolean bypassHeartbeatCheck;
     private EventHandler handler;
     private volatile long invokeCount;
     private volatile long invocationTimeoutMillis;
     protected ClientInvocation(HazelcastClientInstanceImpl client,
                                ClientMessage clientMessage,
                                String objectName,
                                int partitionId,
                                Address address,
                                Connection connection) {
         this.clientClusterService = client.getClientClusterService();
@@ -80,21 +81,21 @@
         this.invocationService = (AbstractClientInvocationService) client.getInvocationService();
         this.executionService = client.getClientExecutionService();
         this.objectName = objectName;
         this.clientMessage = clientMessage;
         this.partitionId = partitionId;
         this.address = address;
         this.connection = connection;
         this.startTimeMillis = System.currentTimeMillis();
         this.retryPauseMillis = invocationService.getInvocationRetryPauseMillis();
         this.logger = invocationService.invocationLogger;
-        this.callIdSequence = invocationService.getCallIdSequence();
+        this.callIdSequence = client.getCallIdSequence();
         this.clientInvocationFuture = new ClientInvocationFuture(this, executionService,
                 clientMessage, logger, callIdSequence);
         this.invocationTimeoutMillis = invocationService.getInvocationTimeoutMillis();
     }
     /**
      * Create an invocation that will be executed on random member.
      */
     public ClientInvocation(HazelcastClientInstanceImpl client, ClientMessage clientMessage, String objectName) {
         this(client, clientMessage, objectName, UNASSIGNED_PARTITION, null, null);
     }
@@ -175,21 +176,21 @@
     }
     public void notify(ClientMessage clientMessage) {
         if (clientMessage == null) {
             throw new IllegalArgumentException("response can't be null");
         }
         clientInvocationFuture.complete(clientMessage);
     }
     public void notifyException(Throwable exception) {
         logException(exception);
         if (!lifecycleService.isRunning()) {
-            clientInvocationFuture.complete(new HazelcastClientNotActiveException("Client is shutting down", exception));
+            clientInvocationFuture.complete(new HazelcastClientNotActiveException(exception.getMessage(), exception));
             return;
         }
         if (isNotAllowedToRetryOnSelection(exception)) {
             clientInvocationFuture.complete(exception);
             return;
         }
         boolean retry = isRetrySafeException(exception)
                 || invocationService.isRedoOperation()
                 || (exception instanceof TargetDisconnectedException && clientMessage.isRetryable());
         if (!retry) {
@@ -239,20 +240,26 @@
         return false;
     }
     private boolean isBindToSingleConnection() {
         return connection != null;
     }
     public EventHandler getEventHandler() {
         return handler;
     }
     public void setEventHandler(EventHandler handler) {
         this.handler = handler;
+    }
+    public boolean shouldBypassHeartbeatCheck() {
+        return bypassHeartbeatCheck;
+    }
+    public void setBypassHeartbeatCheck(boolean bypassHeartbeatCheck) {
+        this.bypassHeartbeatCheck = bypassHeartbeatCheck;
     }
     public void setSendConnection(ClientConnection connection) {
         this.sendConnection = connection;
     }
     public ClientConnection getSendConnectionOrWait() throws InterruptedException {
         while (sendConnection == null && !clientInvocationFuture.isDone()) {
             Thread.sleep(retryPauseMillis);
         }
         return sendConnection;
     }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientMembershipListener.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientMembershipListener.java
@@ -8,21 +8,21 @@
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.spi.impl;
 import com.hazelcast.client.connection.nio.ClientConnectionManagerImpl;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.ClientAddMembershipListenerCodec;
 import com.hazelcast.client.spi.EventHandler;
 import com.hazelcast.cluster.MemberAttributeOperationType;
 import com.hazelcast.core.InitialMembershipEvent;
 import com.hazelcast.core.Member;
 import com.hazelcast.core.MemberAttributeEvent;
 import com.hazelcast.core.MembershipEvent;
 import com.hazelcast.instance.AbstractMember;
 import com.hazelcast.logging.ILogger;
@@ -51,35 +51,35 @@
     private final ClientConnectionManagerImpl connectionManager;
     private volatile CountDownLatch initialListFetchedLatch;
     public ClientMembershipListener(HazelcastClientInstanceImpl client) {
         this.client = client;
         logger = client.getLoggingService().getLogger(ClientMembershipListener.class);
         connectionManager = (ClientConnectionManagerImpl) client.getConnectionManager();
         partitionService = (ClientPartitionServiceImpl) client.getClientPartitionService();
         clusterService = (ClientClusterServiceImpl) client.getClientClusterService();
     }
     @Override
-    public void handleMemberEventV10(Member member, int eventType) {
+    public void handle(Member member, int eventType) {
         switch (eventType) {
             case MembershipEvent.MEMBER_ADDED:
                 memberAdded(member);
                 break;
             case MembershipEvent.MEMBER_REMOVED:
                 memberRemoved(member);
                 break;
             default:
                 logger.warning("Unknown event type: " + eventType);
         }
         partitionService.refreshPartitions();
     }
     @Override
-    public void handleMemberListEventV10(Collection<Member> initialMembers) {
+    public void handle(Collection<Member> initialMembers) {
         Map<String, Member> prevMembers = Collections.emptyMap();
         if (!members.isEmpty()) {
             prevMembers = new HashMap<String, Member>(members.size());
             for (Member member : members) {
                 prevMembers.put(member.getUuid(), member);
             }
             members.clear();
         }
         for (Member initialMember : initialMembers) {
             members.add(initialMember);
@@ -90,21 +90,21 @@
                     new InitialMembershipEvent(client.getCluster(), unmodifiableSet(members)));
             initialListFetchedLatch.countDown();
             return;
         }
         List<MembershipEvent> events = detectMembershipEvents(prevMembers);
         logger.info(membersString());
         fireMembershipEvent(events);
         initialListFetchedLatch.countDown();
     }
     @Override
-    public void handleMemberAttributeChangeEventV10(String uuid, String key, int opType, String value) {
+    public void handle(String uuid, String key, int opType, String value) {
         Collection<Member> members = clusterService.getMemberList();
         for (Member target : members) {
             if (target.getUuid().equals(uuid)) {
                 final MemberAttributeOperationType operationType = MemberAttributeOperationType.getValue(opType);
                 ((AbstractMember) target).updateAttribute(operationType, key, value);
                 MemberAttributeEvent memberAttributeEvent =
                         new MemberAttributeEvent(client.getCluster(), target, operationType, key, value);
                 clusterService.fireMemberAttributeEvent(memberAttributeEvent);
                 break;
             }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientPartitionServiceImpl.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientPartitionServiceImpl.java
@@ -9,21 +9,21 @@
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.spi.impl;
 import com.hazelcast.client.connection.ClientConnectionManager;
 import com.hazelcast.client.connection.nio.ClientConnection;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.ClientAddPartitionListenerCodec;
 import com.hazelcast.client.impl.protocol.codec.ClientGetPartitionsCodec;
 import com.hazelcast.client.spi.ClientClusterService;
 import com.hazelcast.client.spi.ClientPartitionService;
 import com.hazelcast.client.spi.EventHandler;
 import com.hazelcast.cluster.memberselector.MemberSelectors;
 import com.hazelcast.core.ExecutionCallback;
 import com.hazelcast.core.Member;
 import com.hazelcast.core.Partition;
@@ -75,21 +75,21 @@
         }
     }
     public void refreshPartitions() {
         try {
             clientExecutionService.execute(new RefreshTask());
         } catch (RejectedExecutionException ignored) {
             ignore(ignored);
         }
     }
     @Override
-    public void handlePartitionsEventV15(Collection<Map.Entry<Address, List<Integer>>> collection, int partitionStateVersion) {
+    public void handle(Collection<Map.Entry<Address, List<Integer>>> collection, int partitionStateVersion) {
         processPartitionResponse(collection, partitionStateVersion, true);
     }
     @Override
     public void beforeListenerRegister() {
     }
     @Override
     public void onListenerRegister() {
     }
     private void waitForPartitionsFetchedOnce() {
         while (partitionCount == 0 && client.getConnectionManager().isAlive()) {

--- a/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientResponseHandler.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientResponseHandler.java
@@ -7,17 +7,18 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.spi.impl;
+import com.hazelcast.client.connection.nio.ClientConnection;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 /**
  * Responsible for handling responses to invocations.
  */
 public interface ClientResponseHandler {
-    void handle(ClientMessage message);
+    void handle(ClientMessage message, ClientConnection connection);
 }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientResponseHandlerSupplier.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientResponseHandlerSupplier.java
@@ -7,21 +7,22 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.spi.impl;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.connection.nio.ClientConnection;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.ErrorCodec;
 import com.hazelcast.internal.util.concurrent.MPSCQueue;
 import com.hazelcast.logging.ILogger;
 import com.hazelcast.spi.properties.HazelcastProperty;
 import com.hazelcast.util.MutableInteger;
 import com.hazelcast.util.function.Supplier;
 import java.util.concurrent.BlockingQueue;
 import static com.hazelcast.client.spi.properties.ClientProperty.RESPONSE_THREAD_COUNT;
 import static com.hazelcast.instance.OutOfMemoryErrorDispatcher.onOutOfMemory;
@@ -86,80 +87,90 @@
     }
     public void shutdown() {
         for (ResponseThread responseThread : responseThreads) {
             responseThread.interrupt();
         }
     }
     @Override
     public ClientResponseHandler get() {
         return responseHandler;
     }
-    private void process(ClientMessage response) {
+    private void process(ClientConnection connection, ClientMessage message) {
         try {
-            handleResponse(response);
+            handleClientMessage(message);
         } catch (Exception e) {
-            logger.severe("Failed to process response: " + response
+            logger.severe("Failed to process task: " + new ClientPacket(connection, message)
                     + " on responseThread: " + Thread.currentThread().getName(), e);
+        } finally {
+            connection.decrementPendingPacketCount();
         }
     }
-    private void handleResponse(ClientMessage clientMessage) {
+    private void handleClientMessage(ClientMessage clientMessage) {
         long correlationId = clientMessage.getCorrelationId();
         ClientInvocation future = invocationService.deRegisterCallId(correlationId);
         if (future == null) {
             logger.warning("No call for callId: " + correlationId + ", response: " + clientMessage);
             return;
         }
         if (ErrorCodec.TYPE == clientMessage.getMessageType()) {
             future.notifyException(client.getClientExceptionFactory().createException(clientMessage));
         } else {
             future.notify(clientMessage);
         }
     }
     private class ResponseThread extends Thread {
-        private final BlockingQueue<ClientMessage> responseQueue;
+        private final BlockingQueue<ClientPacket> responseQueue;
         ResponseThread(String name) {
             super(name);
             setContextClassLoader(client.getClientConfig().getClassLoader());
-            this.responseQueue = new MPSCQueue<ClientMessage>(this, getIdleStrategy(client.getProperties(), IDLE_STRATEGY));
+            this.responseQueue = new MPSCQueue<ClientPacket>(this, getIdleStrategy(client.getProperties(), IDLE_STRATEGY));
         }
         @Override
         public void run() {
             try {
                 doRun();
             } catch (OutOfMemoryError e) {
                 onOutOfMemory(e);
             } catch (Throwable t) {
                 invocationService.invocationLogger.severe(t);
             }
         }
         private void doRun() {
             while (!invocationService.isShutdown()) {
-                ClientMessage response;
+                ClientPacket task;
                 try {
-                    response = responseQueue.take();
+                    task = responseQueue.take();
                 } catch (InterruptedException e) {
                     continue;
                 }
-                process(response);
+                process(task.connection, task.message);
             }
         }
     }
     class SyncResponseHandler implements ClientResponseHandler {
         @Override
-        public void handle(ClientMessage message) {
-            process(message);
+        public void handle(ClientMessage message, ClientConnection connection) {
+            process(connection, message);
         }
     }
     class AsyncSingleThreadedResponseHandler implements ClientResponseHandler {
         @Override
-        public void handle(ClientMessage message) {
-            responseThreads[0].responseQueue.add(message);
+        public void handle(ClientMessage message, ClientConnection connection) {
+            responseThreads[0].responseQueue.add(new ClientPacket(connection, message));
         }
     }
     class AsyncMultiThreadedResponseHandler implements ClientResponseHandler {
         @Override
-        public void handle(ClientMessage message) {
+        public void handle(ClientMessage message, ClientConnection connection) {
             int threadIndex = hashToIndex(INT_HOLDER.get().getAndInc(), responseThreads.length);
-            responseThreads[threadIndex].responseQueue.add(message);
+            responseThreads[threadIndex].responseQueue.add(new ClientPacket(connection, message));
+        }
+    }
+    private static class ClientPacket {
+        private final ClientConnection connection;
+        private final ClientMessage message;
+        ClientPacket(ClientConnection connection, ClientMessage message) {
+            this.connection = connection;
+            this.message = message;
         }
     }
 }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientTransactionManagerServiceImpl.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientTransactionManagerServiceImpl.java
@@ -13,21 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.spi.impl;
 import com.hazelcast.client.HazelcastClientNotActiveException;
 import com.hazelcast.client.HazelcastClientOfflineException;
 import com.hazelcast.client.LoadBalancer;
 import com.hazelcast.client.config.ClientConfig;
 import com.hazelcast.client.config.ClientConnectionStrategyConfig;
 import com.hazelcast.client.connection.nio.ClientConnection;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.proxy.txn.TransactionContextProxy;
 import com.hazelcast.client.proxy.txn.xa.XATransactionContextProxy;
 import com.hazelcast.client.spi.ClientTransactionManagerService;
 import com.hazelcast.config.GroupConfig;
 import com.hazelcast.core.Member;
 import com.hazelcast.core.OperationTimeoutException;
 import com.hazelcast.nio.Address;
 import com.hazelcast.transaction.TransactionContext;
 import com.hazelcast.transaction.TransactionException;
 import com.hazelcast.transaction.TransactionOptions;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientUserCodeDeploymentService.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientUserCodeDeploymentService.java
@@ -8,21 +8,21 @@
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.spi.impl;
 import com.hazelcast.client.config.ClientUserCodeDeploymentConfig;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.impl.protocol.codec.ClientDeployClassesCodec;
 import com.hazelcast.nio.Connection;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.MalformedURLException;

--- a//dev/null
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ConnectionHeartbeatListener.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.hazelcast.client.spi.impl;
+import com.hazelcast.nio.Connection;
+/**
+ * A listener for the {@link com.hazelcast.client.connection.ClientConnectionManager} to listen to connection heartbeats.
+ */
+public interface ConnectionHeartbeatListener {
+    /**
+     * This event will be fired when the heartbeat is resumed for a connection to a member.
+     */
+    void heartbeatResumed(Connection connection);
+    /**
+     * This event will be fired when no heartbeat response is received for
+     * {@link com.hazelcast.client.spi.properties.ClientProperty#HEARTBEAT_TIMEOUT} milliseconds from the member.
+     */
+    void heartbeatStopped(Connection connection);
+}

--- a/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/NonSmartClientInvocationService.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/NonSmartClientInvocationService.java
@@ -8,21 +8,21 @@
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.spi.impl;
 import com.hazelcast.client.connection.nio.ClientConnection;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.nio.Address;
 import java.io.IOException;
 public class NonSmartClientInvocationService extends AbstractClientInvocationService {
     public NonSmartClientInvocationService(HazelcastClientInstanceImpl client) {
         super(client);
     }
     @Override
     public void invokeOnRandomTarget(ClientInvocation invocation) throws IOException {
         send(invocation, getOwnerConnection());
     }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/SmartClientInvocationService.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/SmartClientInvocationService.java
@@ -9,21 +9,21 @@
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.spi.impl;
 import com.hazelcast.client.LoadBalancer;
 import com.hazelcast.client.connection.nio.ClientConnection;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.core.Member;
 import com.hazelcast.nio.Address;
 import com.hazelcast.nio.Connection;
 import com.hazelcast.spi.exception.TargetNotMemberException;
 import java.io.IOException;
 public class SmartClientInvocationService extends AbstractClientInvocationService {
     private final LoadBalancer loadBalancer;
     public SmartClientInvocationService(HazelcastClientInstanceImpl client, LoadBalancer loadBalancer) {
         super(client);
         this.loadBalancer = loadBalancer;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/discovery/HazelcastCloudDiscovery.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/discovery/HazelcastCloudDiscovery.java
@@ -7,23 +7,23 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.spi.impl.discovery;
+import com.hazelcast.com.eclipsesource.json.Json;
+import com.hazelcast.com.eclipsesource.json.JsonValue;
 import com.hazelcast.client.util.AddressHelper;
-import com.hazelcast.internal.json.Json;
-import com.hazelcast.internal.json.JsonValue;
 import com.hazelcast.nio.Address;
 import com.hazelcast.spi.properties.HazelcastProperties;
 import com.hazelcast.spi.properties.HazelcastProperty;
 import com.hazelcast.util.AddressUtil;
 import javax.net.ssl.HttpsURLConnection;
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.net.HttpURLConnection;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/listener/AbstractClientListenerService.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/listener/AbstractClientListenerService.java
@@ -7,303 +7,115 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.spi.impl.listener;
-import com.hazelcast.client.connection.ClientConnectionManager;
 import com.hazelcast.client.connection.nio.ClientConnection;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.spi.ClientListenerService;
 import com.hazelcast.client.spi.EventHandler;
-import com.hazelcast.client.spi.impl.AbstractClientInvocationService;
 import com.hazelcast.client.spi.impl.ClientExecutionServiceImpl;
-import com.hazelcast.client.spi.impl.ClientInvocation;
-import com.hazelcast.client.spi.impl.ClientInvocationFuture;
-import com.hazelcast.client.spi.impl.ListenerMessageCodec;
-import com.hazelcast.core.HazelcastException;
 import com.hazelcast.internal.metrics.MetricsProvider;
 import com.hazelcast.internal.metrics.MetricsRegistry;
 import com.hazelcast.internal.metrics.Probe;
 import com.hazelcast.logging.ILogger;
 import com.hazelcast.nio.Connection;
-import com.hazelcast.nio.ConnectionListener;
 import com.hazelcast.spi.serialization.SerializationService;
-import com.hazelcast.util.EmptyStatement;
-import com.hazelcast.util.ExceptionUtil;
-import com.hazelcast.util.UuidUtil;
 import com.hazelcast.util.executor.SingleExecutorThreadFactory;
 import com.hazelcast.util.executor.StripedExecutor;
 import com.hazelcast.util.executor.StripedRunnable;
 import java.util.Collection;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.Map;
-import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ThreadFactory;
 import static com.hazelcast.internal.metrics.ProbeLevel.MANDATORY;
-public abstract class AbstractClientListenerService implements ClientListenerService, MetricsProvider, ConnectionListener {
+public abstract class AbstractClientListenerService implements ClientListenerService, MetricsProvider {
     protected final HazelcastClientInstanceImpl client;
     protected final SerializationService serializationService;
-    protected final long invocationTimeoutMillis;
-    protected final long invocationRetryPauseMillis;
-    protected final Map<ClientRegistrationKey, Map<Connection, ClientEventRegistration>> registrations
-            = new ConcurrentHashMap<ClientRegistrationKey, Map<Connection, ClientEventRegistration>>();
-    final ScheduledExecutorService registrationExecutor;
-    final ClientConnectionManager clientConnectionManager;
-    private final ILogger logger;
+    protected final ScheduledExecutorService registrationExecutor;
+    protected final ILogger logger;
     @Probe(name = "eventHandlerCount", level = MANDATORY)
     private final ConcurrentMap<Long, EventHandler> eventHandlerMap
             = new ConcurrentHashMap<Long, EventHandler>();
     private final StripedExecutor eventExecutor;
-    AbstractClientListenerService(HazelcastClientInstanceImpl client, int eventThreadCount, int eventQueueCapacity) {
+    public AbstractClientListenerService(HazelcastClientInstanceImpl client, int eventThreadCount, int eventQueueCapacity) {
         this.client = client;
         serializationService = client.getSerializationService();
         logger = client.getLoggingService().getLogger(ClientListenerService.class);
         String name = client.getName();
         eventExecutor = new StripedExecutor(logger, name + ".event", eventThreadCount, eventQueueCapacity);
         ClassLoader classLoader = client.getClientConfig().getClassLoader();
         ThreadFactory threadFactory = new SingleExecutorThreadFactory(classLoader, name + ".eventRegistration-");
         registrationExecutor = Executors.newSingleThreadScheduledExecutor(threadFactory);
-        clientConnectionManager = client.getConnectionManager();
-        AbstractClientInvocationService invocationService = (AbstractClientInvocationService) client.getInvocationService();
-        invocationTimeoutMillis = invocationService.getInvocationTimeoutMillis();
-        invocationRetryPauseMillis = invocationService.getInvocationRetryPauseMillis();
-    }
-    @Override
-    public String registerListener(final ListenerMessageCodec codec, final EventHandler handler) {
-        assert (!Thread.currentThread().getName().contains("eventRegistration"));
-        Future<String> future = registrationExecutor.submit(new Callable<String>() {
-            @Override
-            public String call() {
-                String userRegistrationId = UuidUtil.newUnsecureUuidString();
-                ClientRegistrationKey registrationKey = new ClientRegistrationKey(userRegistrationId, handler, codec);
-                registrations.put(registrationKey, new ConcurrentHashMap<Connection, ClientEventRegistration>());
-                Collection<ClientConnection> connections = clientConnectionManager.getActiveConnections();
-                for (ClientConnection connection : connections) {
-                    try {
-                        invoke(registrationKey, connection);
-                    } catch (Exception e) {
-                        if (connection.isAlive()) {
-                            deregisterListenerInternal(userRegistrationId);
-                            throw new HazelcastException("Listener can not be added ", e);
-                        }
-                    }
-                }
-                return userRegistrationId;
-            }
-        });
-        try {
-            return future.get();
-        } catch (Exception e) {
-            throw ExceptionUtil.rethrow(e);
-        }
-    }
-    @Override
-    public boolean deregisterListener(final String userRegistrationId) {
-        assert (!Thread.currentThread().getName().contains("eventRegistration"));
-        try {
-            Future<Boolean> future = registrationExecutor.submit(new Callable<Boolean>() {
-                @Override
-                public Boolean call() {
-                    return deregisterListenerInternal(userRegistrationId);
-                }
-            });
-            try {
-                return future.get();
-            } catch (Exception e) {
-                throw ExceptionUtil.rethrow(e);
-            }
-        } catch (RejectedExecutionException ignored) {
-            EmptyStatement.ignore(ignored);
-            return true;
-        }
     }
     @Override
     public void provideMetrics(MetricsRegistry registry) {
         registry.scanAndRegister(this, "listeners");
     }
     @Probe(level = MANDATORY)
     private int eventQueueSize() {
         return eventExecutor.getWorkQueueSize();
     }
     @Probe(level = MANDATORY)
     private long eventsProcessed() {
         return eventExecutor.processedCount();
     }
     public void addEventHandler(long callId, EventHandler handler) {
         eventHandlerMap.put(callId, handler);
     }
-    public void handleClientMessage(ClientMessage clientMessage) {
+    protected void removeEventHandler(long callId) {
+        eventHandlerMap.remove(callId);
+    }
+    public void handleClientMessage(ClientMessage clientMessage, Connection connection) {
         try {
-            eventExecutor.execute(new ClientEventProcessor(clientMessage));
+            eventExecutor.execute(new ClientEventProcessor(clientMessage, (ClientConnection) connection));
         } catch (RejectedExecutionException e) {
             logger.warning("Event clientMessage could not be handled", e);
         }
-    }
-    protected void invoke(ClientRegistrationKey registrationKey, Connection connection) throws Exception {
-        assert (Thread.currentThread().getName().contains("eventRegistration"));
-        Map<Connection, ClientEventRegistration> registrationMap = registrations.get(registrationKey);
-        if (registrationMap.containsKey(connection)) {
-            return;
-        }
-        ListenerMessageCodec codec = registrationKey.getCodec();
-        ClientMessage request = codec.encodeAddRequest(registersLocalOnly());
-        EventHandler handler = registrationKey.getHandler();
-        handler.beforeListenerRegister();
-        ClientInvocation invocation = new ClientInvocation(client, request, null, connection);
-        invocation.setEventHandler(handler);
-        ClientInvocationFuture future = invocation.invokeUrgent();
-        ClientMessage clientMessage;
-        try {
-            clientMessage = future.get();
-        } catch (Exception e) {
-            throw ExceptionUtil.rethrow(e, Exception.class);
-        }
-        String serverRegistrationId = codec.decodeAddResponse(clientMessage);
-        handler.onListenerRegister();
-        long correlationId = request.getCorrelationId();
-        ClientEventRegistration registration
-                = new ClientEventRegistration(serverRegistrationId, correlationId, connection, codec);
-        registrationMap.put(connection, registration);
-    }
-    @Override
-    public void connectionAdded(final Connection connection) {
-        assert (!Thread.currentThread().getName().contains("eventRegistration"));
-        registrationExecutor.submit(new Runnable() {
-            @Override
-            public void run() {
-                for (ClientRegistrationKey registrationKey : registrations.keySet()) {
-                    invokeFromInternalThread(registrationKey, connection);
-                }
-            }
-        });
     }
     public void shutdown() {
         eventExecutor.shutdown();
         ClientExecutionServiceImpl.shutdownExecutor("registrationExecutor", registrationExecutor, logger);
     }
     public void start() {
-        clientConnectionManager.addConnectionListener(this);
-    }
-    @Override
-    public void connectionRemoved(final Connection connection) {
-        assert (!Thread.currentThread().getName().contains("eventRegistration"));
-        registrationExecutor.submit(new Runnable() {
-            @Override
-            public void run() {
-                for (Map<Connection, ClientEventRegistration> registrationMap : registrations.values()) {
-                    ClientEventRegistration registration = registrationMap.remove(connection);
-                    if (registration != null) {
-                        removeEventHandler(registration.getCallId());
-                    }
-                }
-            }
-        });
-    }
-    public StripedExecutor getEventExecutor() {
-        return eventExecutor;
-    }
-    public Collection<ClientEventRegistration> getActiveRegistrations(final String uuid) {
-        assert (!Thread.currentThread().getName().contains("eventRegistration"));
-        Future<Collection<ClientEventRegistration>> future = registrationExecutor.submit(
-                new Callable<Collection<ClientEventRegistration>>() {
-                    @Override
-                    public Collection<ClientEventRegistration> call() {
-                        ClientRegistrationKey key = new ClientRegistrationKey(uuid);
-                        Map<Connection, ClientEventRegistration> registrationMap = registrations.get(key);
-                        if (registrationMap == null) {
-                            return Collections.EMPTY_LIST;
-                        }
-                        LinkedList<ClientEventRegistration> activeRegistrations = new LinkedList<ClientEventRegistration>();
-                        for (ClientEventRegistration registration : registrationMap.values()) {
-                            activeRegistrations.add(registration);
-                        }
-                        return activeRegistrations;
-                    }
-                });
-        try {
-            return future.get();
-        } catch (Exception e) {
-            throw ExceptionUtil.rethrow(e);
-        }
-    }
-    public Map<ClientRegistrationKey, Map<Connection, ClientEventRegistration>> getRegistrations() {
-        return registrations;
-    }
-    private void invokeFromInternalThread(ClientRegistrationKey registrationKey, Connection connection) {
-        assert (Thread.currentThread().getName().contains("eventRegistration"));
-        try {
-            invoke(registrationKey, connection);
-        } catch (Exception e) {
-            logger.warning("Listener " + registrationKey + " can not be added to a new connection: "
-                    + connection + ", reason: " + e.getMessage());
-        }
-    }
-    abstract boolean registersLocalOnly();
-    private void removeEventHandler(long callId) {
-        eventHandlerMap.remove(callId);
-    }
-    private Boolean deregisterListenerInternal(String userRegistrationId) {
-        assert (Thread.currentThread().getName().contains("eventRegistration"));
-        ClientRegistrationKey key = new ClientRegistrationKey(userRegistrationId);
-        Map<Connection, ClientEventRegistration> registrationMap = registrations.get(key);
-        if (registrationMap == null) {
-            return false;
-        }
-        boolean successful = true;
-        for (Iterator<ClientEventRegistration> iterator = registrationMap.values().iterator(); iterator.hasNext(); ) {
-            ClientEventRegistration registration = iterator.next();
-            Connection subscriber = registration.getSubscriber();
-            try {
-                ListenerMessageCodec listenerMessageCodec = registration.getCodec();
-                String serverRegistrationId = registration.getServerRegistrationId();
-                ClientMessage request = listenerMessageCodec.encodeRemoveRequest(serverRegistrationId);
-                new ClientInvocation(client, request, null, subscriber).invoke().get();
-                removeEventHandler(registration.getCallId());
-                iterator.remove();
-            } catch (Exception e) {
-                if (subscriber.isAlive()) {
-                    successful = false;
-                    logger.warning("Deregistration of listener with ID " + userRegistrationId
-                            + " has failed to address " + subscriber.getEndPoint(), e);
-                }
-            }
-        }
-        if (successful) {
-            registrations.remove(key);
-        }
-        return successful;
     }
     private final class ClientEventProcessor implements StripedRunnable {
         final ClientMessage clientMessage;
-        private ClientEventProcessor(ClientMessage clientMessage) {
+        final ClientConnection connection;
+        private ClientEventProcessor(ClientMessage clientMessage, ClientConnection connection) {
             this.clientMessage = clientMessage;
+            this.connection = connection;
         }
         @Override
         public void run() {
-            long correlationId = clientMessage.getCorrelationId();
-            final EventHandler eventHandler = eventHandlerMap.get(correlationId);
-            if (eventHandler == null) {
-                logger.warning("No eventHandler for callId: " + correlationId + ", event: " + clientMessage);
-                return;
+            try {
+                long correlationId = clientMessage.getCorrelationId();
+                final EventHandler eventHandler = eventHandlerMap.get(correlationId);
+                if (eventHandler == null) {
+                    logger.warning("No eventHandler for callId: " + correlationId + ", event: " + clientMessage
+                            + ", connection: " + connection);
+                    return;
+                }
+                eventHandler.handle(clientMessage);
+            } finally {
+                connection.decrementPendingPacketCount();
             }
-            eventHandler.handle(clientMessage);
         }
         @Override
         public int getKey() {
             return clientMessage.getPartitionId();
         }
     }
+    public StripedExecutor getEventExecutor() {
+        return eventExecutor;
+    }
+    public abstract Collection<ClientEventRegistration> getActiveRegistrations(String uuid);
 }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/listener/NonSmartClientListenerService.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/listener/NonSmartClientListenerService.java
@@ -7,21 +7,169 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.spi.impl.listener;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.protocol.ClientMessage;
+import com.hazelcast.client.spi.EventHandler;
+import com.hazelcast.client.spi.impl.ClientInvocation;
+import com.hazelcast.client.spi.impl.ClientInvocationFuture;
+import com.hazelcast.client.spi.impl.ListenerMessageCodec;
+import com.hazelcast.core.HazelcastException;
+import com.hazelcast.nio.Connection;
 import com.hazelcast.nio.ConnectionListener;
+import com.hazelcast.util.EmptyStatement;
+import com.hazelcast.util.ExceptionUtil;
+import com.hazelcast.util.UuidUtil;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.LinkedList;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.Future;
+import java.util.concurrent.RejectedExecutionException;
 public class NonSmartClientListenerService extends AbstractClientListenerService implements ConnectionListener {
+    private final Map<ClientRegistrationKey, ClientEventRegistration> activeRegistrations
+            = new ConcurrentHashMap<ClientRegistrationKey, ClientEventRegistration>();
+    private final Set<ClientRegistrationKey> userRegistrations = new HashSet<ClientRegistrationKey>();
     public NonSmartClientListenerService(HazelcastClientInstanceImpl client,
                                          int eventThreadCount, int eventQueueCapacity) {
         super(client, eventThreadCount, eventQueueCapacity);
     }
-    boolean registersLocalOnly() {
-        return false;
+    @Override
+    public String registerListener(final ListenerMessageCodec codec, final EventHandler handler) {
+        assert (!Thread.currentThread().getName().contains("eventRegistration"));
+        Future<String> future = registrationExecutor.submit(new Callable<String>() {
+            @Override
+            public String call() throws Exception {
+                String userRegistrationId = UuidUtil.newUnsecureUuidString();
+                ClientRegistrationKey registrationKey = new ClientRegistrationKey(userRegistrationId, handler, codec);
+                try {
+                    ClientEventRegistration registration = invoke(registrationKey);
+                    activeRegistrations.put(registrationKey, registration);
+                    userRegistrations.add(registrationKey);
+                } catch (Exception e) {
+                    throw new HazelcastException("Listener can not be added", e);
+                }
+                return userRegistrationId;
+            }
+        });
+        try {
+            return future.get();
+        } catch (Exception e) {
+            throw ExceptionUtil.rethrow(e);
+        }
+    }
+    private ClientEventRegistration invoke(ClientRegistrationKey registrationKey) throws Exception {
+        assert (Thread.currentThread().getName().contains("eventRegistration"));
+        EventHandler handler = registrationKey.getHandler();
+        handler.beforeListenerRegister();
+        ClientMessage request = registrationKey.getCodec().encodeAddRequest(false);
+        ClientInvocation invocation = new ClientInvocation(client, request, null);
+        invocation.setEventHandler(handler);
+        ClientInvocationFuture future = invocation.invoke();
+        String registrationId = registrationKey.getCodec().decodeAddResponse(future.get());
+        handler.onListenerRegister();
+        Connection connection = future.getInvocation().getSendConnection();
+        return new ClientEventRegistration(registrationId,
+                request.getCorrelationId(), connection, registrationKey.getCodec());
+    }
+    @Override
+    public boolean deregisterListener(final String userRegistrationId) {
+        assert (!Thread.currentThread().getName().contains("eventRegistration"));
+        try {
+            Future<Boolean> future = registrationExecutor.submit(new Callable<Boolean>() {
+                @Override
+                public Boolean call() throws Exception {
+                    return deregisterListenerInternal(userRegistrationId);
+                }
+            });
+            try {
+                return future.get();
+            } catch (Exception e) {
+                throw ExceptionUtil.rethrow(e);
+            }
+        } catch (RejectedExecutionException ignored) {
+            EmptyStatement.ignore(ignored);
+            return true;
+        }
+    }
+    private Boolean deregisterListenerInternal(String userRegistrationId) {
+        ClientRegistrationKey key = new ClientRegistrationKey(userRegistrationId);
+        if (!userRegistrations.remove(key)) {
+            return false;
+        }
+        ClientEventRegistration registration = activeRegistrations.get(key);
+        if (registration == null) {
+            return true;
+        }
+        ClientMessage request = registration.getCodec().encodeRemoveRequest(registration.getServerRegistrationId());
+        try {
+            Future future = new ClientInvocation(client, request, null).invoke();
+            future.get();
+            removeEventHandler(registration.getCallId());
+            activeRegistrations.remove(key);
+        } catch (Exception e) {
+            throw new HazelcastException("Listener with ID " + userRegistrationId + " could not be removed", e);
+        }
+        return true;
+    }
+    @Override
+    public void start() {
+        client.getConnectionManager().addConnectionListener(this);
+    }
+    @Override
+    public void connectionAdded(final Connection connection) {
+        assert (!Thread.currentThread().getName().contains("eventRegistration"));
+        registrationExecutor.submit(new Runnable() {
+            @Override
+            public void run() {
+                for (ClientRegistrationKey registrationKey : userRegistrations) {
+                    try {
+                        ClientEventRegistration oldRegistration = activeRegistrations.get(registrationKey);
+                        if (oldRegistration != null) {
+                            removeEventHandler(oldRegistration.getCallId());
+                        }
+                        ClientEventRegistration eventRegistration = invoke(registrationKey);
+                        activeRegistrations.put(registrationKey, eventRegistration);
+                    } catch (Exception e) {
+                        logger.warning("Listener " + registrationKey + " can not be added to new connection: "
+                                + connection, e);
+                    }
+                }
+            }
+        });
+    }
+    @Override
+    public void connectionRemoved(Connection connection) {
+    }
+    public Collection<ClientEventRegistration> getActiveRegistrations(final String uuid) {
+        assert (!Thread.currentThread().getName().contains("eventRegistration"));
+        Future<Collection<ClientEventRegistration>> future = registrationExecutor.submit(
+                new Callable<Collection<ClientEventRegistration>>() {
+                    @Override
+                    public Collection<ClientEventRegistration> call() throws Exception {
+                        ClientEventRegistration registration = activeRegistrations.get(new ClientRegistrationKey(uuid));
+                        if (registration == null || !registration.getSubscriber().isAlive()) {
+                            return Collections.EMPTY_LIST;
+                        }
+                        LinkedList<ClientEventRegistration> activeRegistrations = new LinkedList<ClientEventRegistration>();
+                        activeRegistrations.add(registration);
+                        return activeRegistrations;
+                    }
+                });
+        try {
+            return future.get();
+        } catch (Exception e) {
+            throw ExceptionUtil.rethrow(e);
+        }
     }
 }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/listener/SmartClientListenerService.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/listener/SmartClientListenerService.java
@@ -7,62 +7,194 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.spi.impl.listener;
-import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
+import com.hazelcast.client.connection.ClientConnectionManager;
+import com.hazelcast.client.connection.nio.ClientConnection;
+import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
+import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.spi.ClientClusterService;
 import com.hazelcast.client.spi.EventHandler;
+import com.hazelcast.client.spi.impl.ClientInvocation;
+import com.hazelcast.client.spi.impl.ClientInvocationFuture;
+import com.hazelcast.client.spi.impl.AbstractClientInvocationService;
+import com.hazelcast.client.spi.impl.ConnectionHeartbeatListener;
 import com.hazelcast.client.spi.impl.ListenerMessageCodec;
+import com.hazelcast.core.HazelcastException;
 import com.hazelcast.core.Member;
 import com.hazelcast.core.OperationTimeoutException;
+import com.hazelcast.nio.Connection;
+import com.hazelcast.nio.ConnectionListener;
+import com.hazelcast.util.EmptyStatement;
 import com.hazelcast.util.ExceptionUtil;
+import com.hazelcast.util.UuidUtil;
 import java.io.IOException;
 import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.Map;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.Future;
+import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.TimeUnit;
 import static com.hazelcast.util.StringUtil.timeToString;
-public class SmartClientListenerService extends AbstractClientListenerService  {
+public class SmartClientListenerService extends AbstractClientListenerService
+        implements ConnectionListener, ConnectionHeartbeatListener {
+    private final long invocationTimeoutMillis;
+    private final long invocationRetryPauseMillis;
+    private final Map<ClientRegistrationKey, Map<Connection, ClientEventRegistration>> registrations
+            = new ConcurrentHashMap<ClientRegistrationKey, Map<Connection, ClientEventRegistration>>();
+    private final ClientConnectionManager clientConnectionManager;
+    private final Map<Connection, Collection<ClientRegistrationKey>> failedRegistrations
+            = new ConcurrentHashMap<Connection, Collection<ClientRegistrationKey>>();
     public SmartClientListenerService(HazelcastClientInstanceImpl client,
                                       int eventThreadCount, int eventQueueCapacity) {
         super(client, eventThreadCount, eventQueueCapacity);
+        clientConnectionManager = client.getConnectionManager();
+        AbstractClientInvocationService invocationService = (AbstractClientInvocationService) client.getInvocationService();
+        invocationTimeoutMillis = invocationService.getInvocationTimeoutMillis();
+        invocationRetryPauseMillis = invocationService.getInvocationRetryPauseMillis();
+    }
+    @Override
+    public String registerListener(final ListenerMessageCodec codec, final EventHandler handler) {
+        assert (!Thread.currentThread().getName().contains("eventRegistration"));
+        trySyncConnectToAllMembers();
+        Future<String> future = registrationExecutor.submit(new Callable<String>() {
+            @Override
+            public String call() {
+                String userRegistrationId = UuidUtil.newUnsecureUuidString();
+                ClientRegistrationKey registrationKey = new ClientRegistrationKey(userRegistrationId, handler, codec);
+                registrations.put(registrationKey, new ConcurrentHashMap<Connection, ClientEventRegistration>());
+                Collection<ClientConnection> connections = clientConnectionManager.getActiveConnections();
+                for (ClientConnection connection : connections) {
+                    try {
+                        invoke(registrationKey, connection);
+                    } catch (Exception e) {
+                        if (connection.isAlive()) {
+                            deregisterListenerInternal(userRegistrationId);
+                            throw new HazelcastException("Listener can not be added ", e);
+                        }
+                    }
+                }
+                return userRegistrationId;
+            }
+        });
+        try {
+            return future.get();
+        } catch (Exception e) {
+            throw ExceptionUtil.rethrow(e);
+        }
+    }
+    private void invoke(ClientRegistrationKey registrationKey, Connection connection) throws Exception {
+        assert (Thread.currentThread().getName().contains("eventRegistration"));
+        Map<Connection, ClientEventRegistration> registrationMap = registrations.get(registrationKey);
+        if (registrationMap.containsKey(connection)) {
+            return;
+        }
+        ListenerMessageCodec codec = registrationKey.getCodec();
+        ClientMessage request = codec.encodeAddRequest(true);
+        EventHandler handler = registrationKey.getHandler();
+        handler.beforeListenerRegister();
+        ClientInvocation invocation = new ClientInvocation(client, request, null, connection);
+        invocation.setEventHandler(handler);
+        ClientInvocationFuture future = invocation.invokeUrgent();
+        ClientMessage clientMessage;
+        try {
+            clientMessage = future.get();
+        } catch (Exception e) {
+            throw ExceptionUtil.rethrow(e, Exception.class);
+        }
+        String serverRegistrationId = codec.decodeAddResponse(clientMessage);
+        handler.onListenerRegister();
+        long correlationId = request.getCorrelationId();
+        ClientEventRegistration registration
+                = new ClientEventRegistration(serverRegistrationId, correlationId, connection, codec);
+        registrationMap.put(connection, registration);
+    }
+    @Override
+    public boolean deregisterListener(final String userRegistrationId) {
+        assert (!Thread.currentThread().getName().contains("eventRegistration"));
+        try {
+            Future<Boolean> future = registrationExecutor.submit(new Callable<Boolean>() {
+                @Override
+                public Boolean call() {
+                    return deregisterListenerInternal(userRegistrationId);
+                }
+            });
+            try {
+                return future.get();
+            } catch (Exception e) {
+                throw ExceptionUtil.rethrow(e);
+            }
+        } catch (RejectedExecutionException ignored) {
+            EmptyStatement.ignore(ignored);
+            return true;
+        }
+    }
+    private Boolean deregisterListenerInternal(String userRegistrationId) {
+        assert (Thread.currentThread().getName().contains("eventRegistration"));
+        ClientRegistrationKey key = new ClientRegistrationKey(userRegistrationId);
+        Map<Connection, ClientEventRegistration> registrationMap = registrations.get(key);
+        if (registrationMap == null) {
+            return false;
+        }
+        boolean successful = true;
+        for (Iterator<ClientEventRegistration> iterator = registrationMap.values().iterator(); iterator.hasNext(); ) {
+            ClientEventRegistration registration = iterator.next();
+            Connection subscriber = registration.getSubscriber();
+            try {
+                ListenerMessageCodec listenerMessageCodec = registration.getCodec();
+                String serverRegistrationId = registration.getServerRegistrationId();
+                ClientMessage request = listenerMessageCodec.encodeRemoveRequest(serverRegistrationId);
+                new ClientInvocation(client, request, null, subscriber).invoke().get();
+                removeEventHandler(registration.getCallId());
+                iterator.remove();
+            } catch (Exception e) {
+                if (subscriber.isAlive()) {
+                    successful = false;
+                    logger.warning("Deregistration of listener with ID " + userRegistrationId
+                            + " has failed to address " + subscriber.getEndPoint(), e);
+                }
+            }
+        }
+        if (successful) {
+            registrations.remove(key);
+        }
+        return successful;
     }
     @Override
     public void start() {
-        super.start();
+        clientConnectionManager.addConnectionListener(this);
+        clientConnectionManager.addConnectionHeartbeatListener(this);
         final ClientClusterService clientClusterService = client.getClientClusterService();
         registrationExecutor.scheduleWithFixedDelay(new Runnable() {
             @Override
             public void run() {
                 Collection<Member> memberList = clientClusterService.getMemberList();
                 for (Member member : memberList) {
                     try {
                         clientConnectionManager.getOrTriggerConnect(member.getAddress(), false);
                     } catch (IOException e) {
                         return;
                     }
                 }
             }
         }, 1, 1, TimeUnit.SECONDS);
-    }
-    @Override
-    public String registerListener(final ListenerMessageCodec codec, final EventHandler handler) {
-        trySyncConnectToAllMembers();
-        return super.registerListener(codec, handler);
-    }
-    @Override
-    boolean registersLocalOnly() {
-        return true;
     }
     private void trySyncConnectToAllMembers() {
         ClientClusterService clientClusterService = client.getClientClusterService();
         long startMillis = System.currentTimeMillis();
         do {
             Member lastFailedMember = null;
             Exception lastException = null;
             for (Member member : clientClusterService.getMemberList()) {
                 try {
                     clientConnectionManager.getOrConnect(member.getAddress());
@@ -70,38 +202,125 @@
                     lastFailedMember = member;
                     lastException = e;
                 }
             }
             if (lastException == null) {
                 break;
             }
             timeOutOrSleepBeforeNextTry(startMillis, lastFailedMember, lastException);
         } while (client.getLifecycleService().isRunning());
     }
+    private void sleepBeforeNextTry() {
+        try {
+            Thread.sleep(invocationRetryPauseMillis);
+        } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+            throw ExceptionUtil.rethrow(e);
+        }
+    }
     private void timeOutOrSleepBeforeNextTry(long startMillis, Member lastFailedMember, Exception lastException) {
         long nowInMillis = System.currentTimeMillis();
         long elapsedMillis = nowInMillis - startMillis;
         boolean timedOut = elapsedMillis > invocationTimeoutMillis;
         if (timedOut) {
             throwOperationTimeoutException(startMillis, nowInMillis, elapsedMillis, lastFailedMember, lastException);
         } else {
             sleepBeforeNextTry();
         }
     }
-    private void sleepBeforeNextTry() {
-        try {
-            Thread.sleep(invocationRetryPauseMillis);
-        } catch (InterruptedException e) {
-            Thread.currentThread().interrupt();
-            throw ExceptionUtil.rethrow(e);
-        }
-    }
     private void throwOperationTimeoutException(long startMillis, long nowInMillis,
                                                 long elapsedMillis, Member lastFailedMember, Exception lastException) {
         throw new OperationTimeoutException("Registering listeners is timed out."
                 + " Last failed member : " + lastFailedMember + ", "
                 + " Current time: " + timeToString(nowInMillis) + ", "
                 + " Start time : " + timeToString(startMillis) + ", "
                 + " Client invocation timeout : " + invocationTimeoutMillis + " ms, "
                 + " Elapsed time : " + elapsedMillis + " ms. ", lastException);
     }
+    @Override
+    public void connectionAdded(final Connection connection) {
+        assert (!Thread.currentThread().getName().contains("eventRegistration"));
+        registrationExecutor.submit(new Runnable() {
+            @Override
+            public void run() {
+                for (ClientRegistrationKey registrationKey : registrations.keySet()) {
+                    invokeFromInternalThread(registrationKey, connection);
+                }
+            }
+        });
+    }
+    @Override
+    public void connectionRemoved(final Connection connection) {
+        assert (!Thread.currentThread().getName().contains("eventRegistration"));
+        registrationExecutor.submit(new Runnable() {
+            @Override
+            public void run() {
+                failedRegistrations.remove(connection);
+                for (Map<Connection, ClientEventRegistration> registrationMap : registrations.values()) {
+                    ClientEventRegistration registration = registrationMap.remove(connection);
+                    if (registration != null) {
+                        removeEventHandler(registration.getCallId());
+                    }
+                }
+            }
+        });
+    }
+    @Override
+    public void heartbeatResumed(final Connection connection) {
+        assert (!Thread.currentThread().getName().contains("eventRegistration"));
+        registrationExecutor.submit(new Runnable() {
+            @Override
+            public void run() {
+                Collection<ClientRegistrationKey> registrationKeys = failedRegistrations.get(connection);
+                for (ClientRegistrationKey registrationKey : registrationKeys) {
+                    invokeFromInternalThread(registrationKey, connection);
+                }
+            }
+        });
+    }
+    private void invokeFromInternalThread(ClientRegistrationKey registrationKey, Connection connection) {
+        assert (Thread.currentThread().getName().contains("eventRegistration"));
+        try {
+            invoke(registrationKey, connection);
+        } catch (IOException e) {
+            Collection<ClientRegistrationKey> failedRegsToConnection = failedRegistrations.get(connection);
+            if (failedRegsToConnection == null) {
+                failedRegsToConnection = Collections.newSetFromMap(new HashMap<ClientRegistrationKey, Boolean>());
+                failedRegistrations.put(connection, failedRegsToConnection);
+            }
+            failedRegsToConnection.add(registrationKey);
+        } catch (Exception e) {
+            logger.warning("Listener " + registrationKey + " can not be added to a new connection: "
+                    + connection + ", reason: " + e.getMessage());
+        }
+    }
+    @Override
+    public void heartbeatStopped(Connection connection) {
+    }
+    public Collection<ClientEventRegistration> getActiveRegistrations(final String uuid) {
+        assert (!Thread.currentThread().getName().contains("eventRegistration"));
+        Future<Collection<ClientEventRegistration>> future = registrationExecutor.submit(
+                new Callable<Collection<ClientEventRegistration>>() {
+                    @Override
+                    public Collection<ClientEventRegistration> call() {
+                        ClientRegistrationKey key = new ClientRegistrationKey(uuid);
+                        Map<Connection, ClientEventRegistration> registrationMap = registrations.get(key);
+                        if (registrationMap == null) {
+                            return Collections.EMPTY_LIST;
+                        }
+                        LinkedList<ClientEventRegistration> activeRegistrations = new LinkedList<ClientEventRegistration>();
+                        for (ClientEventRegistration registration : registrationMap.values()) {
+                            activeRegistrations.add(registration);
+                        }
+                        return activeRegistrations;
+                    }
+                });
+        try {
+            return future.get();
+        } catch (Exception e) {
+            throw ExceptionUtil.rethrow(e);
+        }
+    }
+    public Map<ClientRegistrationKey, Map<Connection, ClientEventRegistration>> getRegistrations() {
+        return registrations;
+    }
 }

--- a/hazelcast-client/src/main/java/com/hazelcast/client/util/AbstractLoadBalancer.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/util/AbstractLoadBalancer.java
@@ -21,30 +21,30 @@
 import com.hazelcast.core.InitialMembershipListener;
 import com.hazelcast.core.Member;
 import com.hazelcast.core.MemberAttributeEvent;
 import com.hazelcast.core.MembershipEvent;
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicReference;
 /**
  * An abstract {@link com.hazelcast.client.LoadBalancer} implementation.
  */
 public abstract class AbstractLoadBalancer implements LoadBalancer, InitialMembershipListener {
-    private final AtomicReference<Member[]> membersRef = new AtomicReference<Member[]>(new Member[0]);
+    private final AtomicReference<Member[]> membersRef = new AtomicReference(new Member[]{});
     private volatile Cluster clusterRef;
     @Override
     public final void init(Cluster cluster, ClientConfig config) {
         this.clusterRef = cluster;
         cluster.addMembershipListener(this);
     }
     private void setMembersRef() {
         Set<Member> memberSet = clusterRef.getMembers();
-        Member[] members = memberSet.toArray(new Member[0]);
+        Member[] members = memberSet.toArray(new Member[memberSet.size()]);
         membersRef.set(members);
     }
     protected Member[] getMembers() {
         return membersRef.get();
     }
     @Override
     public final void init(InitialMembershipEvent event) {
         setMembersRef();
     }
     @Override

--- a/hazelcast-client/src/main/java/com/hazelcast/client/util/ClientDelegatingFuture.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/util/ClientDelegatingFuture.java
@@ -7,21 +7,21 @@
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.hazelcast.client.util;
-import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
+import com.hazelcast.client.impl.ClientMessageDecoder;
 import com.hazelcast.client.impl.protocol.ClientMessage;
 import com.hazelcast.client.spi.impl.ClientInvocationFuture;
 import com.hazelcast.core.ExecutionCallback;
 import com.hazelcast.spi.InternalCompletableFuture;
 import com.hazelcast.spi.serialization.SerializationService;
 import com.hazelcast.util.ExceptionUtil;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;

--- a/hazelcast-client/src/main/java/com/hazelcast/client/util/ClientStateListener.java
+++ b/hazelcast-client/src/main/java/com/hazelcast/client/util/ClientStateListener.java
@@ -50,22 +50,21 @@
     public ClientStateListener(ClientConfig clientConfig) {
         clientConfig.addListenerConfig(new ListenerConfig(this));
     }
     @Override
     public void stateChanged(LifecycleEvent event) {
         lock.lock();
         try {
             currentState = event.getState();
             if (currentState.equals(CLIENT_CONNECTED) || currentState.equals(SHUTTING_DOWN) || currentState.equals(SHUTDOWN)) {
                 connectedCondition.signalAll();
-            }
-            if (currentState.equals(CLIENT_DISCONNECTED) || currentState.equals(SHUTTING_DOWN) || currentState
+            } else if (currentState.equals(CLIENT_DISCONNECTED) || currentState.equals(SHUTTING_DOWN) || currentState
                     .equals(SHUTDOWN)) {
                 disconnectedCondition.signalAll();
             }
         } finally {
             lock.unlock();
         }
     }
     /**
      * Waits until the client is connected to cluster or the timeout expires.
      * Does not wait if the client is already shutting down or shutdown.
