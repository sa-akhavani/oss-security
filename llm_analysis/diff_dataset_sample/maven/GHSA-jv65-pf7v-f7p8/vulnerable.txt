# ====================================================================
# FILE: hazelcast-build-utils/src/main/java/com/hazelcast/buildutils/HazelcastManifestTransformer.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 10-70 ---
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.buildutils;
    17| import aQute.lib.osgi.Instruction;
    18| import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
    19| import org.apache.maven.plugins.shade.relocation.Relocator;
    20| import org.apache.maven.plugins.shade.resource.ManifestResourceTransformer;
    21| import java.io.IOException;
    22| import java.io.InputStream;
    23| import java.util.ArrayList;
    24| import java.util.HashMap;
    25| import java.util.LinkedHashSet;
    26| import java.util.List;
    27| import java.util.Map;
    28| import java.util.Set;
    29| import java.util.jar.Attributes;
    30| import java.util.jar.JarEntry;
    31| import java.util.jar.JarFile;
    32| import java.util.jar.JarOutputStream;
    33| import java.util.jar.Manifest;
    34| import static java.util.Arrays.asList;
    35| import static java.util.Collections.emptySet;
    36| import static org.codehaus.plexus.util.IOUtil.close;
    37| import static org.codehaus.plexus.util.StringUtils.join;
    38| /**
    39|  * This transformer implementation is used to merge MANIFEST and OSGi
    40|  * bundle metadata in conjunction with the Maven Shade plugin when
    41|  * integrating multiple dependencies into one output JAR.
    42|  */
    43| public class HazelcastManifestTransformer extends ManifestResourceTransformer {
    44|     private static final String VERSION_PREFIX = "version=";
    45|     private static final String RESOLUTION_PREFIX = "resolution:=";
    46|     private static final String USES_PREFIX = "uses:=";
    47|     private static final int VERSION_OFFSET = 8;
    48|     private static final int USES_OFFSET = 7;
    49|     private static final String IMPORT_PACKAGE = "Import-Package";
    50|     private static final String EXPORT_PACKAGE = "Export-Package";
    51|     @SuppressFBWarnings(value = "UWF_UNWRITTEN_FIELD", justification = "Filled by Maven")
    52|     String mainClass;
    53|     @SuppressFBWarnings(value = "UWF_UNWRITTEN_FIELD", justification = "Filled by Maven")
    54|     Map<String, Attributes> manifestEntries;
    55|     @SuppressFBWarnings(value = "UWF_UNWRITTEN_FIELD", justification = "Filled by Maven")
    56|     Map<String, String> overrideInstructions;
    57|     private final Map<String, PackageDefinition> importedPackages = new HashMap<String, PackageDefinition>();
    58|     private final Map<String, PackageDefinition> exportedPackages = new HashMap<String, PackageDefinition>();
    59|     private final List<InstructionDefinition> importOverrideInstructions = new ArrayList<InstructionDefinition>();
    60|     private final List<InstructionDefinition> exportOverrideInstructions = new ArrayList<InstructionDefinition>();
    61|     private Manifest shadedManifest;
    62|     @Override
    63|     public boolean canTransformResource(String resource) {
    64|         return JarFile.MANIFEST_NAME.equalsIgnoreCase(resource);
    65|     }
    66|     @Override
    67|     public void processResource(String resource, InputStream inputStream, List<Relocator> relocators) throws IOException {
    68|         Attributes attributes;
    69|         if (shadedManifest == null) {
    70|             shadedManifest = new Manifest(inputStream);

# --- HUNK 2: Lines 133-172 ---
   133|     }
   134|     @Override
   135|     @SuppressWarnings("Since15")
   136|     public void modifyOutputStream(JarOutputStream jarOutputStream) throws IOException {
   137|         if (shadedManifest == null) {
   138|             shadedManifest = new Manifest();
   139|         }
   140|         precompileOverrideInstructions();
   141|         Attributes attributes = shadedManifest.getMainAttributes();
   142|         attributes.putValue(IMPORT_PACKAGE, join(shadeImports().iterator(), ","));
   143|         attributes.putValue(EXPORT_PACKAGE, join(shadeExports().iterator(), ","));
   144|         attributes.putValue("Created-By", "HazelcastManifestTransformer through Shade Plugin");
   145|         if (mainClass != null) {
   146|             attributes.put(Attributes.Name.MAIN_CLASS, mainClass);
   147|         }
   148|         if (manifestEntries != null) {
   149|             for (Map.Entry<String, Attributes> entry : manifestEntries.entrySet()) {
   150|                 attributes.put(new Attributes.Name(entry.getKey()), entry.getValue());
   151|             }
   152|         }
   153|         jarOutputStream.putNextEntry(new JarEntry(JarFile.MANIFEST_NAME));
   154|         shadedManifest.write(jarOutputStream);
   155|         jarOutputStream.flush();
   156|     }
   157|     @SuppressFBWarnings(value = "NP_UNWRITTEN_FIELD", justification = "Field is set by Maven")
   158|     private void precompileOverrideInstructions() {
   159|         String importPackageInstructions = overrideInstructions.get(IMPORT_PACKAGE);
   160|         if (importPackageInstructions != null) {
   161|             List<String> packageInstructions = ElementParser.parseDelimitedString(importPackageInstructions, ',', true);
   162|             for (String packageInstruction : packageInstructions) {
   163|                 PackageDefinition packageDefinition = new PackageDefinition(packageInstruction);
   164|                 Instruction instruction = Instruction.getPattern(packageDefinition.packageName);
   165|                 System.out.println("Compiled import instruction '" + packageInstruction + "' -> " + instruction);
   166|                 importOverrideInstructions.add(new InstructionDefinition(packageDefinition, instruction));
   167|             }
   168|         }
   169|         String exportPackageInstructions = overrideInstructions.get(EXPORT_PACKAGE);
   170|         if (exportPackageInstructions != null) {
   171|             List<String> packageInstructions = ElementParser.parseDelimitedString(exportPackageInstructions, ',', true);
   172|             for (String packageInstruction : packageInstructions) {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/ClientExtension.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-79 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client;
    17| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    18| import com.hazelcast.client.spi.ClientProxyFactory;
    19| import com.hazelcast.internal.nearcache.NearCacheManager;
    20| import com.hazelcast.internal.networking.ChannelFactory;
    21| import com.hazelcast.internal.serialization.InternalSerializationService;
    22| import com.hazelcast.map.impl.MapService;
    23| import com.hazelcast.memory.MemoryStats;
    24| import com.hazelcast.nio.SocketInterceptor;
    25| /**
    26|  * ClientExtension is a client extension mechanism to be able to plug different implementations of
    27|  * some modules, like; {@link InternalSerializationService}, {@link ChannelFactory} etc.
    28|  */
    29| public interface ClientExtension {
    30|     /**
    31|      * Called before client is started
    32|      */
    33|     void beforeStart(HazelcastClientInstanceImpl client);
    34|     /**
    35|      * Called after node is started
    36|      */
    37|     void afterStart(HazelcastClientInstanceImpl client);
    38|     /**
    39|      * Creates a {@link InternalSerializationService} instance to be used by this client.
    40|      *
    41|      * @param version serialization version to be created. Values less than 1 will be ignored and max supported version
    42|      *                will be used
    43|      * @return the created {@link InternalSerializationService} instance
    44|      */
    45|     InternalSerializationService createSerializationService(byte version);
    46|     /**
    47|      * Creates a {@link SocketInterceptor} to be used by this client if available,
    48|      * otherwise returns <code>null</code>
    49|      *
    50|      * @return the created {@link SocketInterceptor} instance if available,
    51|      * +          otherwise <code>null</code>
    52|      */
    53|     SocketInterceptor createSocketInterceptor();
    54|     /**
    55|      * Creates a {@link ChannelFactory} instance to be used by this client.
    56|      *
    57|      * @return the created {@link ChannelFactory} instance
    58|      */
    59|     ChannelFactory createSocketChannelWrapperFactory();
    60|     /**
    61|      * Creates a {@link NearCacheManager} instance to be used by this client.
    62|      *
    63|      * @return the created {@link NearCacheManager} instance
    64|      */
    65|     NearCacheManager createNearCacheManager();
    66|     /**
    67|      * Creates a {@code ClientProxyFactory} for the supplied service class. Currently only the {@link MapService} is supported.
    68|      *
    69|      * @param service service for the proxy to create.
    70|      * @return {@code ClientProxyFactory} for the service.
    71|      * @throws java.lang.IllegalArgumentException if service is not known
    72|      */
    73|     <T> ClientProxyFactory createServiceProxyFactory(Class<T> service);
    74|     /**
    75|      * Returns MemoryStats of for the JVM and current HazelcastInstance.
    76|      *
    77|      * @return memory statistics
    78|      */
    79|     MemoryStats getMemoryStats();


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/ClientOutOfMemoryHandler.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client;
    17| import com.hazelcast.client.connection.nio.ClientConnectionManagerImpl;
    18| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    19| import com.hazelcast.core.HazelcastInstance;
    20| import com.hazelcast.instance.DefaultOutOfMemoryHandler;
    21| import static com.hazelcast.util.EmptyStatement.ignore;
    22| /**
    23|  * To clear resources of the client upon OutOfMemory
    24|  */
    25| public class ClientOutOfMemoryHandler extends DefaultOutOfMemoryHandler {
    26|     @Override
    27|     public void onOutOfMemory(OutOfMemoryError oome, HazelcastInstance[] hazelcastInstances) {
    28|         for (HazelcastInstance instance : hazelcastInstances) {
    29|             if (instance instanceof HazelcastClientInstanceImpl) {
    30|                 ClientHelper.cleanResources((HazelcastClientInstanceImpl) instance);
    31|             }
    32|         }
    33|         try {
    34|             oome.printStackTrace(System.err);
    35|         } catch (Throwable ignored) {
    36|             ignore(ignored);
    37|         }
    38|     }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/HazelcastClient.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-40 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client;
    17| import com.hazelcast.client.config.ClientConfig;
    18| import com.hazelcast.client.impl.ClientConnectionManagerFactory;
    19| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    20| import com.hazelcast.client.impl.HazelcastClientProxy;
    21| import com.hazelcast.core.HazelcastInstance;
    22| import com.hazelcast.core.OutOfMemoryHandler;
    23| import java.util.Collection;
    24| /**
    25|  * The HazelcastClient is comparable to the {@link com.hazelcast.core.Hazelcast} class and provides the ability
    26|  * the create and manage Hazelcast clients. Hazelcast clients are {@link HazelcastInstance} implementations, so
    27|  * in most cases most of the code is unaware of talking to a cluster member or a client.
    28|  * <p/>
    29|  * <h1>Smart vs dumb clients</h1>
    30|  * Hazelcast Client enables you to do all Hazelcast operations without being a member of the cluster. Clients can be:
    31|  * <ol>
    32|  * <li>smart: this means that they immediately can send an operation like map.get(key) to the member that owns that
    33|  * specific key.
    34|  * </li>
    35|  * <li>
    36|  * dumb: it will connect to a random member in the cluster and send requests to this member. This member then needs
    37|  * to send the request to the correct member.
    38|  * </li>
    39|  * </ol>
    40|  * For more information see {@link com.hazelcast.client.config.ClientNetworkConfig#setSmartRouting(boolean)}.


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/HazelcastClientFactory.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-35 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client;
    17| import com.hazelcast.client.config.ClientConfig;
    18| import com.hazelcast.client.impl.ClientConnectionManagerFactory;
    19| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    20| import com.hazelcast.client.impl.HazelcastClientProxy;
    21| /**
    22|  * Provides the capability for the customization of Hazelcast client factories.
    23|  *
    24|  * Its implementation can be changed and passed to the constructors of {@link HazelcastClientManager}.
    25|  *
    26|  * @param <T> type of {@link HazelcastClientInstanceImpl}
    27|  * @param <V> type of {@link HazelcastClientProxy}
    28|  * @param <C> type of {@link ClientConfig}
    29|  */
    30| public interface HazelcastClientFactory<T extends HazelcastClientInstanceImpl,
    31|         V extends HazelcastClientProxy,
    32|         C extends ClientConfig> {
    33|     T createHazelcastInstanceClient(C config, ClientConnectionManagerFactory hazelcastClientFactory);
    34|     V createProxy(T client);
    35| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/HazelcastClientManager.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-42 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client;
    17| import com.hazelcast.client.config.ClientConfig;
    18| import com.hazelcast.client.config.XmlClientConfigBuilder;
    19| import com.hazelcast.client.impl.ClientConnectionManagerFactory;
    20| import com.hazelcast.client.impl.DefaultClientConnectionManagerFactory;
    21| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    22| import com.hazelcast.client.impl.HazelcastClientProxy;
    23| import com.hazelcast.core.DuplicateInstanceNameException;
    24| import com.hazelcast.core.HazelcastInstance;
    25| import com.hazelcast.core.OutOfMemoryHandler;
    26| import com.hazelcast.instance.OutOfMemoryErrorDispatcher;
    27| import java.util.Collection;
    28| import java.util.Collections;
    29| import java.util.HashSet;
    30| import java.util.concurrent.ConcurrentHashMap;
    31| import java.util.concurrent.ConcurrentMap;
    32| import static com.hazelcast.util.EmptyStatement.ignore;
    33| /**
    34|  * Central manager for all Hazelcast clients of the JVM.
    35|  *
    36|  * All creation functionality will be stored here and a particular instance of a client will delegate here.
    37|  */
    38| public final class HazelcastClientManager {
    39|     /**
    40|      * Global instance of {@link HazelcastClientManager}
    41|      */
    42|     public static final HazelcastClientManager INSTANCE = new HazelcastClientManager();


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/AbstractClientCacheProxy.java
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 1-66 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.cache.impl;
    17| import com.hazelcast.cache.CacheStatistics;
    18| import com.hazelcast.client.impl.ClientMessageDecoder;
    19| import com.hazelcast.client.impl.protocol.ClientMessage;
    20| import com.hazelcast.client.impl.protocol.codec.CacheGetAllCodec;
    21| import com.hazelcast.client.impl.protocol.codec.CacheGetCodec;
    22| import com.hazelcast.client.impl.protocol.codec.CachePutAllCodec;
    23| import com.hazelcast.client.impl.protocol.codec.CacheSizeCodec;
    24| import com.hazelcast.client.spi.ClientContext;
    25| import com.hazelcast.client.spi.ClientPartitionService;
    26| import com.hazelcast.client.spi.impl.ClientInvocation;
    27| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    28| import com.hazelcast.client.util.ClientDelegatingFuture;
    29| import com.hazelcast.config.CacheConfig;
    30| import com.hazelcast.core.ExecutionCallback;
    31| import com.hazelcast.core.ICompletableFuture;
    32| import com.hazelcast.nio.serialization.Data;
    33| import com.hazelcast.spi.InternalCompletableFuture;
    34| import javax.cache.CacheException;
    35| import javax.cache.expiry.ExpiryPolicy;
    36| import java.util.AbstractMap;
    37| import java.util.ArrayList;
    38| import java.util.Collection;
    39| import java.util.LinkedList;
    40| import java.util.List;
    41| import java.util.Map;
    42| import java.util.Set;
    43| import java.util.concurrent.ExecutionException;
    44| import java.util.concurrent.Future;
    45| import static com.hazelcast.cache.impl.CacheProxyUtil.NULL_KEY_IS_NOT_ALLOWED;
    46| import static com.hazelcast.cache.impl.CacheProxyUtil.validateNotNull;
    47| import static com.hazelcast.util.CollectionUtil.objectToDataCollection;
    48| import static com.hazelcast.util.ExceptionUtil.rethrow;
    49| import static com.hazelcast.util.ExceptionUtil.rethrowAllowedTypeFirst;
    50| import static com.hazelcast.util.MapUtil.createHashMap;
    51| import static com.hazelcast.util.Preconditions.checkNotNull;
    52| import static java.util.Collections.emptyMap;
    53| /**
    54|  * Hazelcast provides extension functionality to default spec interface {@link javax.cache.Cache}.
    55|  * {@link com.hazelcast.cache.ICache} is the designated interface.
    56|  *
    57|  * AbstractCacheProxyExtension provides implementation of various {@link com.hazelcast.cache.ICache} methods.
    58|  *
    59|  * Note: this partial implementation is used by client.
    60|  *
    61|  * @param <K> the type of key
    62|  * @param <V> the type of value
    63|  */
    64| @SuppressWarnings("checkstyle:npathcomplexity")
    65| abstract class AbstractClientCacheProxy<K, V> extends AbstractClientInternalCacheProxy<K, V> {
    66|     @SuppressWarnings("unchecked")

# --- HUNK 2: Lines 219-310 ---
   219|     }
   220|     @Override
   221|     public void put(K key, V value, ExpiryPolicy expiryPolicy) {
   222|         putSyncInternal(key, value, expiryPolicy, false);
   223|     }
   224|     @Override
   225|     public V getAndPut(K key, V value, ExpiryPolicy expiryPolicy) {
   226|         return putSyncInternal(key, value, expiryPolicy, true);
   227|     }
   228|     @Override
   229|     @SuppressWarnings("unchecked")
   230|     public void putAll(Map<? extends K, ? extends V> map, ExpiryPolicy expiryPolicy) {
   231|         long startNanos = nowInNanosOrDefault();
   232|         ensureOpen();
   233|         checkNotNull(map, "map is null");
   234|         if (map.isEmpty()) {
   235|             return;
   236|         }
   237|         putAllInternal(map, expiryPolicy, null, new List[partitionCount], startNanos);
   238|     }
   239|     protected void putAllInternal(Map<? extends K, ? extends V> map, ExpiryPolicy expiryPolicy, Map<Object, Data> keyMap,
   240|                                   List<Map.Entry<Data, Data>>[] entriesPerPartition, long startNanos) {
   241|         try {
   242|             groupDataToPartitions(map, getContext().getPartitionService(), keyMap, entriesPerPartition);
   243|             putToAllPartitionsAndWaitForCompletion(entriesPerPartition, expiryPolicy, startNanos);
   244|         } catch (Exception t) {
   245|             throw rethrow(t);
   246|         }
   247|     }
   248|     private void groupDataToPartitions(Map<? extends K, ? extends V> map, ClientPartitionService partitionService,
   249|                                        Map<Object, Data> keyMap, List<Map.Entry<Data, Data>>[] entriesPerPartition) {
   250|         for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {
   251|             K key = entry.getKey();
   252|             V value = entry.getValue();
   253|             validateNotNull(key, value);
   254|             Data keyData = toData(key);
   255|             Data valueData = toData(value);
   256|             if (keyMap != null) {
   257|                 keyMap.put(key, keyData);
   258|             }
   259|             int partitionId = partitionService.getPartitionId(keyData);
   260|             List<Map.Entry<Data, Data>> entries = entriesPerPartition[partitionId];
   261|             if (entries == null) {
   262|                 entries = new ArrayList<Map.Entry<Data, Data>>();
   263|                 entriesPerPartition[partitionId] = entries;
   264|             }
   265|             entries.add(new AbstractMap.SimpleImmutableEntry<Data, Data>(keyData, valueData));
   266|         }
   267|     }
   268|     private static final class FutureEntriesTuple {
   269|         private final Future future;
   270|         private final List<Map.Entry<Data, Data>> entries;
   271|         private FutureEntriesTuple(Future future, List<Map.Entry<Data, Data>> entries) {
   272|             this.future = future;
   273|             this.entries = entries;
   274|         }
   275|     }
   276|     private void putToAllPartitionsAndWaitForCompletion(List<Map.Entry<Data, Data>>[] entriesPerPartition,
   277|                                                         ExpiryPolicy expiryPolicy, long startNanos)
   278|             throws ExecutionException, InterruptedException {
   279|         Data expiryPolicyData = toData(expiryPolicy);
   280|         List<FutureEntriesTuple> futureEntriesTuples = new ArrayList<FutureEntriesTuple>(entriesPerPartition.length);
   281|         for (int partitionId = 0; partitionId < entriesPerPartition.length; partitionId++) {
   282|             List<Map.Entry<Data, Data>> entries = entriesPerPartition[partitionId];
   283|             if (entries != null) {
   284|                 int completionId = nextCompletionId();
   285|                 ClientMessage request = CachePutAllCodec.encodeRequest(nameWithPrefix, entries, expiryPolicyData, completionId);
   286|                 Future future = invoke(request, partitionId, completionId);
   287|                 futureEntriesTuples.add(new FutureEntriesTuple(future, entries));
   288|             }
   289|         }
   290|         waitResponseFromAllPartitionsForPutAll(futureEntriesTuples, startNanos);
   291|     }
   292|     private void waitResponseFromAllPartitionsForPutAll(List<FutureEntriesTuple> futureEntriesTuples, long startNanos) {
   293|         Throwable error = null;
   294|         for (FutureEntriesTuple tuple : futureEntriesTuples) {
   295|             Future future = tuple.future;
   296|             List<Map.Entry<Data, Data>> entries = tuple.entries;
   297|             try {
   298|                 future.get();
   299|                 if (statisticsEnabled) {
   300|                     statsHandler.getStatistics().increaseCachePuts(entries.size());
   301|                 }
   302|             } catch (Throwable t) {
   303|                 logger.finest("Error occurred while putting entries as batch!", t);
   304|                 if (error == null) {
   305|                     error = t;
   306|                 }
   307|             }
   308|         }
   309|         if (statisticsEnabled) {
   310|             statsHandler.getStatistics().addPutTimeNanos(nowInNanosOrDefault() - startNanos);


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/AbstractClientCacheProxyBase.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.cache.impl;
    17| import com.hazelcast.cache.impl.ICacheInternal;
    18| import com.hazelcast.cache.impl.ICacheService;
    19| import com.hazelcast.client.impl.ClientMessageDecoder;
    20| import com.hazelcast.client.impl.protocol.ClientMessage;
    21| import com.hazelcast.client.spi.ClientContext;
    22| import com.hazelcast.client.spi.ClientProxy;
    23| import com.hazelcast.client.spi.impl.ClientInvocation;
    24| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    25| import com.hazelcast.client.util.ClientDelegatingFuture;
    26| import com.hazelcast.config.CacheConfig;
    27| import com.hazelcast.core.ExecutionCallback;
    28| import com.hazelcast.core.ManagedContext;
    29| import com.hazelcast.logging.ILogger;
    30| import com.hazelcast.nio.serialization.Data;
    31| import javax.cache.CacheException;
    32| import javax.cache.integration.CompletionListener;
    33| import java.util.Iterator;
    34| import java.util.List;
    35| import java.util.Map;
    36| import java.util.concurrent.ConcurrentHashMap;
    37| import java.util.concurrent.ConcurrentMap;
    38| import java.util.concurrent.ExecutionException;
    39| import java.util.concurrent.Future;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/AbstractClientInternalCacheProxy.java
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 3-74 ---
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.cache.impl;
    17| import com.hazelcast.cache.HazelcastCacheManager;
    18| import com.hazelcast.cache.impl.CacheEventData;
    19| import com.hazelcast.cache.impl.CacheEventListenerAdaptor;
    20| import com.hazelcast.cache.impl.CacheSyncListenerCompleter;
    21| import com.hazelcast.cache.impl.operation.MutableOperation;
    22| import com.hazelcast.client.HazelcastClientNotActiveException;
    23| import com.hazelcast.client.impl.ClientMessageDecoder;
    24| import com.hazelcast.client.impl.protocol.ClientMessage;
    25| import com.hazelcast.client.impl.protocol.codec.CacheAddEntryListenerCodec;
    26| import com.hazelcast.client.impl.protocol.codec.CacheClearCodec;
    27| import com.hazelcast.client.impl.protocol.codec.CacheGetAndRemoveCodec;
    28| import com.hazelcast.client.impl.protocol.codec.CacheGetAndReplaceCodec;
    29| import com.hazelcast.client.impl.protocol.codec.CachePutCodec;
    30| import com.hazelcast.client.impl.protocol.codec.CachePutIfAbsentCodec;
    31| import com.hazelcast.client.impl.protocol.codec.CacheRemoveAllCodec;
    32| import com.hazelcast.client.impl.protocol.codec.CacheRemoveAllKeysCodec;
    33| import com.hazelcast.client.impl.protocol.codec.CacheRemoveCodec;
    34| import com.hazelcast.client.impl.protocol.codec.CacheReplaceCodec;
    35| import com.hazelcast.client.spi.ClientContext;
    36| import com.hazelcast.client.spi.ClientListenerService;
    37| import com.hazelcast.client.spi.ClientPartitionService;
    38| import com.hazelcast.client.spi.EventHandler;
    39| import com.hazelcast.client.spi.impl.ClientInvocation;
    40| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    41| import com.hazelcast.client.util.ClientDelegatingFuture;
    42| import com.hazelcast.config.CacheConfig;
    43| import com.hazelcast.core.ExecutionCallback;
    44| import com.hazelcast.core.ICompletableFuture;
    45| import com.hazelcast.nio.IOUtil;
    46| import com.hazelcast.nio.serialization.Data;
    47| import javax.cache.CacheException;
    48| import javax.cache.CacheManager;
    49| import javax.cache.configuration.CacheEntryListenerConfiguration;
    50| import javax.cache.event.CacheEntryListener;
    51| import javax.cache.expiry.ExpiryPolicy;
    52| import java.io.Closeable;
    53| import java.util.Collection;
    54| import java.util.Iterator;
    55| import java.util.Set;
    56| import java.util.concurrent.ConcurrentHashMap;
    57| import java.util.concurrent.ConcurrentMap;
    58| import java.util.concurrent.CountDownLatch;
    59| import java.util.concurrent.ExecutionException;
    60| import java.util.concurrent.Future;
    61| import java.util.concurrent.TimeUnit;
    62| import java.util.concurrent.atomic.AtomicReference;
    63| import static com.hazelcast.cache.impl.CacheProxyUtil.validateConfiguredTypes;
    64| import static com.hazelcast.cache.impl.CacheProxyUtil.validateNotNull;
    65| import static com.hazelcast.cache.impl.operation.MutableOperation.IGNORE_COMPLETION;
    66| import static com.hazelcast.util.ExceptionUtil.rethrow;
    67| import static com.hazelcast.util.ExceptionUtil.rethrowAllowedTypeFirst;
    68| import static com.hazelcast.util.ExceptionUtil.sneakyThrow;
    69| import static java.lang.Thread.currentThread;
    70| /**
    71|  * Abstract {@link com.hazelcast.cache.ICache} implementation which provides shared internal implementations
    72|  * of cache operations like put, replace, remove and invoke. These internal implementations are delegated
    73|  * by actual cache methods.
    74|  * <p>

# --- HUNK 2: Lines 107-146 ---
   107|     private static final ClientMessageDecoder GET_AND_REPLACE_RESPONSE_DECODER = new ClientMessageDecoder() {
   108|         @Override
   109|         public <T> T decodeClientMessage(ClientMessage clientMessage) {
   110|             return (T) CacheGetAndReplaceCodec.decodeResponse(clientMessage).response;
   111|         }
   112|     };
   113|     @SuppressWarnings("unchecked")
   114|     private static final ClientMessageDecoder PUT_RESPONSE_DECODER = new ClientMessageDecoder() {
   115|         @Override
   116|         public <T> T decodeClientMessage(ClientMessage clientMessage) {
   117|             return (T) CachePutCodec.decodeResponse(clientMessage).response;
   118|         }
   119|     };
   120|     @SuppressWarnings("unchecked")
   121|     private static final ClientMessageDecoder PUT_IF_ABSENT_RESPONSE_DECODER = new ClientMessageDecoder() {
   122|         @Override
   123|         public <T> T decodeClientMessage(ClientMessage clientMessage) {
   124|             return (T) Boolean.valueOf(CachePutIfAbsentCodec.decodeResponse(clientMessage).response);
   125|         }
   126|     };
   127|     protected final AtomicReference<HazelcastClientCacheManager> cacheManagerRef
   128|             = new AtomicReference<HazelcastClientCacheManager>();
   129|     protected int partitionCount;
   130|     private final ConcurrentMap<CacheEntryListenerConfiguration, String> asyncListenerRegistrations;
   131|     private final ConcurrentMap<CacheEntryListenerConfiguration, String> syncListenerRegistrations;
   132|     private final ConcurrentMap<String, Closeable> closeableListeners;
   133|     private final ConcurrentMap<Integer, CountDownLatch> syncLocks;
   134|     AbstractClientInternalCacheProxy(CacheConfig<K, V> cacheConfig, ClientContext context) {
   135|         super(cacheConfig, context);
   136|         this.asyncListenerRegistrations = new ConcurrentHashMap<CacheEntryListenerConfiguration, String>();
   137|         this.syncListenerRegistrations = new ConcurrentHashMap<CacheEntryListenerConfiguration, String>();
   138|         this.closeableListeners = new ConcurrentHashMap<String, Closeable>();
   139|         this.syncLocks = new ConcurrentHashMap<Integer, CountDownLatch>();
   140|     }
   141|     @Override
   142|     protected void onInitialize() {
   143|         super.onInitialize();
   144|         ClientPartitionService partitionService = getContext().getPartitionService();
   145|         partitionCount = partitionService.getPartitionCount();
   146|     }

# --- HUNK 3: Lines 394-433 ---
   394|         Data expiryPolicyData = toData(expiryPolicy);
   395|         ClientInvocationFuture invocationFuture = putInternal(keyData, valueData, expiryPolicyData, isGet, withCompletionEvent);
   396|         return wrapPutAsyncFuture(key, value, keyData, valueData, invocationFuture, callback);
   397|     }
   398|     protected ClientDelegatingFuture<V> wrapPutAsyncFuture(K key, V value, Data keyData, Data valueData,
   399|                                                            ClientInvocationFuture invocationFuture,
   400|                                                            OneShotExecutionCallback<V> callback) {
   401|         if (callback == null) {
   402|             return newDelegatingFuture(invocationFuture, PUT_RESPONSE_DECODER);
   403|         }
   404|         CallbackAwareClientDelegatingFuture<V> future = new CallbackAwareClientDelegatingFuture<V>(invocationFuture,
   405|                 getSerializationService(), PUT_RESPONSE_DECODER, callback);
   406|         future.andThenInternal(callback, true);
   407|         return future;
   408|     }
   409|     protected OneShotExecutionCallback<V> newStatsCallbackOrNull(boolean isGet) {
   410|         if (!statisticsEnabled) {
   411|             return null;
   412|         }
   413|         return statsHandler.newOnPutCallback(isGet, System.nanoTime());
   414|     }
   415|     protected Object putIfAbsentInternal(K key, V value, ExpiryPolicy expiryPolicy, boolean withCompletionEvent, boolean async) {
   416|         long startNanos = nowInNanosOrDefault();
   417|         ensureOpen();
   418|         validateNotNull(key, value);
   419|         validateConfiguredTypes(cacheConfig, key, value);
   420|         Data keyData = toData(key);
   421|         Data valueData = toData(value);
   422|         Data expiryPolicyData = toData(expiryPolicy);
   423|         int completionId = withCompletionEvent ? nextCompletionId() : -1;
   424|         ClientMessage request = CachePutIfAbsentCodec.encodeRequest(nameWithPrefix, keyData, valueData,
   425|                 expiryPolicyData, completionId);
   426|         ClientInvocationFuture future = invoke(request, keyData, completionId);
   427|         ClientDelegatingFuture<Boolean> delegatingFuture = newDelegatingFuture(future, PUT_IF_ABSENT_RESPONSE_DECODER);
   428|         if (async) {
   429|             ExecutionCallback<Boolean> callback = !statisticsEnabled ? null : statsHandler.newOnPutIfAbsentCallback(startNanos);
   430|             onPutIfAbsentAsyncInternal(key, value, keyData, valueData, delegatingFuture, callback);
   431|             return delegatingFuture;
   432|         } else {
   433|             try {

# --- HUNK 4: Lines 612-642 ---
   612|             }
   613|             if (countDownLatch.getCount() > 0) {
   614|                 logger.finest("Countdown latch wait timeout after " + MAX_COMPLETION_LATCH_WAIT_TIME + " milliseconds!");
   615|             }
   616|         } catch (InterruptedException e) {
   617|             currentThread().interrupt();
   618|             sneakyThrow(e);
   619|         }
   620|     }
   621|     protected EventHandler createHandler(CacheEventListenerAdaptor<K, V> adaptor) {
   622|         return new CacheEventHandler(adaptor);
   623|     }
   624|     private final class CacheEventHandler
   625|             extends CacheAddEntryListenerCodec.AbstractEventHandler
   626|             implements EventHandler<ClientMessage> {
   627|         private final CacheEventListenerAdaptor<K, V> adaptor;
   628|         private CacheEventHandler(CacheEventListenerAdaptor<K, V> adaptor) {
   629|             this.adaptor = adaptor;
   630|         }
   631|         @Override
   632|         public void handle(int type, Collection<CacheEventData> keys, int completionId) {
   633|             adaptor.handle(type, keys, completionId);
   634|         }
   635|         @Override
   636|         public void beforeListenerRegister() {
   637|         }
   638|         @Override
   639|         public void onListenerRegister() {
   640|         }
   641|     }
   642| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/CallbackAwareClientDelegatingFuture.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.cache.impl;
    17| import com.hazelcast.client.impl.ClientMessageDecoder;
    18| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    19| import com.hazelcast.client.util.ClientDelegatingFuture;
    20| import com.hazelcast.spi.serialization.SerializationService;
    21| import com.hazelcast.util.Clock;
    22| import java.util.concurrent.ExecutionException;
    23| import java.util.concurrent.TimeUnit;
    24| import java.util.concurrent.TimeoutException;
    25| import static com.hazelcast.util.ExceptionUtil.sneakyThrow;
    26| /**
    27|  * A specific {@link ClientDelegatingFuture} implementation which calls given {@link OneShotExecutionCallback} as sync on get.
    28|  */
    29| class CallbackAwareClientDelegatingFuture<V> extends ClientDelegatingFuture<V> {
    30|     private final OneShotExecutionCallback<V> callback;
    31|     CallbackAwareClientDelegatingFuture(ClientInvocationFuture clientInvocationFuture,
    32|                                         SerializationService serializationService,
    33|                                         ClientMessageDecoder clientMessageDecoder,
    34|                                         OneShotExecutionCallback<V> callback) {
    35|         super(clientInvocationFuture, serializationService, clientMessageDecoder);
    36|         this.callback = callback;
    37|     }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/ClientCacheHelper.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-40 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.cache.impl;
    17| import com.hazelcast.cache.impl.CacheProxyUtil;
    18| import com.hazelcast.client.HazelcastClientNotActiveException;
    19| import com.hazelcast.client.connection.nio.ClientConnection;
    20| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    21| import com.hazelcast.client.impl.protocol.ClientMessage;
    22| import com.hazelcast.client.impl.protocol.codec.CacheCreateConfigCodec;
    23| import com.hazelcast.client.impl.protocol.codec.CacheGetConfigCodec;
    24| import com.hazelcast.client.impl.protocol.codec.CacheManagementConfigCodec;
    25| import com.hazelcast.client.spi.impl.AbstractClientInvocationService;
    26| import com.hazelcast.client.spi.impl.ClientInvocation;
    27| import com.hazelcast.client.spi.properties.ClientProperty;
    28| import com.hazelcast.config.CacheConfig;
    29| import com.hazelcast.config.LegacyCacheConfig;
    30| import com.hazelcast.core.Member;
    31| import com.hazelcast.core.OperationTimeoutException;
    32| import com.hazelcast.instance.BuildInfo;
    33| import com.hazelcast.nio.Address;
    34| import com.hazelcast.nio.serialization.Data;
    35| import com.hazelcast.spi.serialization.SerializationService;
    36| import com.hazelcast.util.ExceptionUtil;
    37| import com.hazelcast.util.FutureUtil;
    38| import java.io.IOException;
    39| import java.util.ArrayList;
    40| import java.util.Collection;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/ClientCacheProxy.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 2-42 ---
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.cache.impl;
    17| import com.hazelcast.cache.impl.CacheEntryProcessorResult;
    18| import com.hazelcast.cache.impl.CacheEventListenerAdaptor;
    19| import com.hazelcast.cache.impl.event.CachePartitionLostEvent;
    20| import com.hazelcast.cache.impl.event.CachePartitionLostListener;
    21| import com.hazelcast.cache.journal.EventJournalCacheEvent;
    22| import com.hazelcast.client.impl.ClientMessageDecoder;
    23| import com.hazelcast.client.impl.protocol.ClientMessage;
    24| import com.hazelcast.client.impl.protocol.codec.CacheAddEntryListenerCodec;
    25| import com.hazelcast.client.impl.protocol.codec.CacheAddPartitionLostListenerCodec;
    26| import com.hazelcast.client.impl.protocol.codec.CacheContainsKeyCodec;
    27| import com.hazelcast.client.impl.protocol.codec.CacheEntryProcessorCodec;
    28| import com.hazelcast.client.impl.protocol.codec.CacheEventJournalReadCodec;
    29| import com.hazelcast.client.impl.protocol.codec.CacheEventJournalSubscribeCodec;
    30| import com.hazelcast.client.impl.protocol.codec.CacheEventJournalSubscribeCodec.ResponseParameters;
    31| import com.hazelcast.client.impl.protocol.codec.CacheListenerRegistrationCodec;
    32| import com.hazelcast.client.impl.protocol.codec.CacheLoadAllCodec;
    33| import com.hazelcast.client.impl.protocol.codec.CacheRemoveEntryListenerCodec;
    34| import com.hazelcast.client.impl.protocol.codec.CacheRemovePartitionLostListenerCodec;
    35| import com.hazelcast.client.spi.ClientContext;
    36| import com.hazelcast.client.spi.EventHandler;
    37| import com.hazelcast.client.spi.impl.ClientInvocation;
    38| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    39| import com.hazelcast.client.spi.impl.ListenerMessageCodec;
    40| import com.hazelcast.client.util.ClientDelegatingFuture;
    41| import com.hazelcast.config.CacheConfig;
    42| import com.hazelcast.core.ICompletableFuture;

# --- HUNK 2: Lines 478-503 ---
   478|         final SerializationService ss = getSerializationService();
   479|         final ClientMessage request = CacheEventJournalReadCodec.encodeRequest(
   480|                 nameWithPrefix, startSequence, minSize, maxSize, ss.toData(predicate), ss.toData(projection));
   481|         final ClientInvocationFuture fut = new ClientInvocation(getClient(), request, getName(), partitionId).invoke();
   482|         return new ClientDelegatingFuture<ReadResultSet<T>>(fut, ss, eventJournalReadResponseDecoder);
   483|     }
   484|     private final class ClientCachePartitionLostEventHandler
   485|             extends CacheAddPartitionLostListenerCodec.AbstractEventHandler
   486|             implements EventHandler<ClientMessage> {
   487|         private CachePartitionLostListener listener;
   488|         private ClientCachePartitionLostEventHandler(CachePartitionLostListener listener) {
   489|             this.listener = listener;
   490|         }
   491|         @Override
   492|         public void beforeListenerRegister() {
   493|         }
   494|         @Override
   495|         public void onListenerRegister() {
   496|         }
   497|         @Override
   498|         public void handle(int partitionId, String uuid) {
   499|             Member member = getContext().getClusterService().getMember(uuid);
   500|             listener.partitionLost(new CachePartitionLostEvent(name, member, PARTITION_LOST.getType(), partitionId));
   501|         }
   502|     }
   503| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/ClientCacheProxyFactory.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.cache.impl;
    17| import com.hazelcast.cache.CacheNotExistsException;
    18| import com.hazelcast.cache.HazelcastCacheManager;
    19| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    20| import com.hazelcast.client.spi.ClientContext;
    21| import com.hazelcast.client.spi.ClientProxy;
    22| import com.hazelcast.client.spi.impl.ClientProxyFactoryWithContext;
    23| import com.hazelcast.config.CacheConfig;
    24| import com.hazelcast.config.NearCacheConfig;
    25| import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
    26| import java.util.Map;
    27| import java.util.Set;
    28| import java.util.concurrent.ConcurrentHashMap;
    29| import java.util.concurrent.ConcurrentMap;
    30| public class ClientCacheProxyFactory extends ClientProxyFactoryWithContext {
    31|     private final HazelcastClientInstanceImpl client;
    32|     private final ConcurrentMap<String, CacheConfig> configs = new ConcurrentHashMap<String, CacheConfig>();
    33|     public ClientCacheProxyFactory(HazelcastClientInstanceImpl client) {
    34|         this.client = client;
    35|     }
    36|     @Override
    37|     public ClientProxy create(String id, ClientContext context) {
    38|         CacheConfig cacheConfig = findCacheConfig(id);
    39|         if (cacheConfig == null) {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/ClientClusterWideIterator.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.cache.impl;
    17| import com.hazelcast.cache.impl.AbstractClusterWideIterator;
    18| import com.hazelcast.cache.impl.ICacheInternal;
    19| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    20| import com.hazelcast.client.impl.protocol.ClientMessage;
    21| import com.hazelcast.client.impl.protocol.codec.CacheIterateCodec;
    22| import com.hazelcast.client.impl.protocol.codec.CacheIterateEntriesCodec;
    23| import com.hazelcast.client.spi.ClientContext;
    24| import com.hazelcast.client.spi.impl.ClientInvocation;
    25| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    26| import com.hazelcast.nio.serialization.Data;
    27| import javax.cache.Cache;
    28| import java.util.Iterator;
    29| import java.util.List;
    30| import static com.hazelcast.util.ExceptionUtil.rethrow;
    31| /**
    32|  * Client side cluster-wide iterator for {@link com.hazelcast.cache.ICache}.
    33|  *
    34|  * This implementation is used by client implementation of JCache.
    35|  *
    36|  * Note: For more information on the iterator details, see {@link AbstractClusterWideIterator}.
    37|  *
    38|  * @param <K> the type of key.
    39|  * @param <V> the type of value.


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/HazelcastClientCacheManager.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-160 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.cache.impl;
    17| import com.hazelcast.cache.HazelcastCachingProvider;
    18| import com.hazelcast.cache.impl.AbstractHazelcastCacheManager;
    19| import com.hazelcast.cache.impl.ICacheInternal;
    20| import com.hazelcast.cache.impl.ICacheService;
    21| import com.hazelcast.client.impl.ClientICacheManager;
    22| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    23| import com.hazelcast.client.impl.HazelcastClientProxy;
    24| import com.hazelcast.config.CacheConfig;
    25| import com.hazelcast.core.HazelcastInstance;
    26| import com.hazelcast.internal.nearcache.NearCacheManager;
    27| import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
    28| import java.net.URI;
    29| import java.util.Iterator;
    30| import java.util.Map;
    31| import java.util.Properties;
    32| import static com.hazelcast.internal.config.ConfigValidator.checkCacheConfig;
    33| import static com.hazelcast.util.ExceptionUtil.rethrow;
    34| import static com.hazelcast.util.Preconditions.checkNotNull;
    35| /**
    36|  * {@link javax.cache.CacheManager} implementation for client side.
    37|  * <p>
    38|  * Provides client side CacheManager functionality.
    39|  */
    40| public final class HazelcastClientCacheManager extends AbstractHazelcastCacheManager {
    41|     private final HazelcastClientInstanceImpl client;
    42|     private final ClientCacheProxyFactory clientCacheProxyFactory;
    43|     public HazelcastClientCacheManager(HazelcastClientCachingProvider cachingProvider, HazelcastInstance hazelcastInstance,
    44|                                        URI uri, ClassLoader classLoader, Properties properties) {
    45|         super(cachingProvider, hazelcastInstance, uri, classLoader, properties);
    46|         /*
    47|          * TODO:
    48|          *
    49|          * A new interface, such as `InternalHazelcastInstance` (has `getOriginalInstance()` method),
    50|          * might be introduced. Then underlying actual (original) Hazelcast instance is retrieved through this.
    51|          *
    52|          * Original Hazelcast instance is used for getting `NearCacheManager` and
    53|          * passing full cache name directly by this cache manager itself.
    54|          */
    55|         if (hazelcastInstance instanceof HazelcastClientProxy) {
    56|             client = ((HazelcastClientProxy) hazelcastInstance).client;
    57|         } else {
    58|             client = ((HazelcastClientInstanceImpl) hazelcastInstance);
    59|         }
    60|         clientCacheProxyFactory =
    61|                 (ClientCacheProxyFactory) client.getProxyManager().getClientProxyFactory(ICacheService.SERVICE_NAME);
    62|     }
    63|     @Override
    64|     public void enableManagement(String cacheName, boolean enabled) {
    65|         enableStatisticManagementOnNodes(cacheName, false, enabled);
    66|     }
    67|     @Override
    68|     public void enableStatistics(String cacheName, boolean enabled) {
    69|         enableStatisticManagementOnNodes(cacheName, true, enabled);
    70|     }
    71|     private void enableStatisticManagementOnNodes(String cacheName, boolean statOrMan, boolean enabled) {
    72|         ensureOpen();
    73|         checkNotNull(cacheName, "cacheName cannot be null");
    74|         ClientCacheHelper.enableStatisticManagementOnNodes(client, getCacheNameWithPrefix(cacheName),
    75|                 statOrMan, enabled);
    76|     }
    77|     @SuppressFBWarnings("RV_RETURN_VALUE_OF_PUTIFABSENT_IGNORED")
    78|     @Override
    79|     protected <K, V> void addCacheConfigIfAbsent(CacheConfig<K, V> cacheConfig) {
    80|         clientCacheProxyFactory.addCacheConfig(cacheConfig.getNameWithPrefix(), cacheConfig);
    81|     }
    82|     @Override
    83|     protected void removeCacheConfigFromLocal(String cacheNameWithPrefix) {
    84|         clientCacheProxyFactory.removeCacheConfig(cacheNameWithPrefix);
    85|     }
    86|     @Override
    87|     protected <K, V> CacheConfig<K, V> getCacheConfig(String cacheName, String simpleCacheName) {
    88|         return ClientCacheHelper.getCacheConfig(client, cacheName, simpleCacheName);
    89|     }
    90|     @Override
    91|     protected <K, V> ICacheInternal<K, V> createCacheProxy(CacheConfig<K, V> cacheConfig) {
    92|         clientCacheProxyFactory.addCacheConfig(cacheConfig.getNameWithPrefix(), cacheConfig);
    93|         try {
    94|             ClientICacheManager cacheManager = client.getCacheManager();
    95|             String nameWithPrefix = cacheConfig.getNameWithPrefix();
    96|             ICacheInternal<K, V> cache = (ICacheInternal<K, V>) cacheManager.getCacheByFullName(nameWithPrefix);
    97|             cache.setCacheManager(this);
    98|             return cache;
    99|         } catch (Throwable t) {
   100|             clientCacheProxyFactory.removeCacheConfig(cacheConfig.getNameWithPrefix());
   101|             throw rethrow(t);
   102|         }
   103|     }
   104|     @Override
   105|     protected <K, V> CacheConfig<K, V> findCacheConfig(String cacheName, String simpleCacheName) {
   106|         if (simpleCacheName == null) {
   107|             return null;
   108|         }
   109|         CacheConfig<K, V> config = clientCacheProxyFactory.getCacheConfig(cacheName);
   110|         if (config == null) {
   111|             config = getCacheConfig(cacheName, simpleCacheName);
   112|             if (config != null) {
   113|                 createCacheConfig(cacheName, config);
   114|             }
   115|         }
   116|         return config;
   117|     }
   118|     @Override
   119|     protected <K, V> void createCacheConfig(String cacheName, CacheConfig<K, V> config) {
   120|         ClientCacheHelper.createCacheConfig(client, config);
   121|     }
   122|     @Override
   123|     public <T> T unwrap(Class<T> clazz) {
   124|         if (HazelcastClientCacheManager.class.isAssignableFrom(clazz)) {
   125|             return (T) this;
   126|         }
   127|         throw new IllegalArgumentException();
   128|     }
   129|     @Override
   130|     protected void postClose() {
   131|         if (properties.getProperty(HazelcastCachingProvider.HAZELCAST_CONFIG_LOCATION) != null) {
   132|             hazelcastInstance.shutdown();
   133|         }
   134|     }
   135|     @Override
   136|     protected void postDestroy() {
   137|         Iterator<Map.Entry<String, CacheConfig>> iter = clientCacheProxyFactory.configs().iterator();
   138|         while (iter.hasNext()) {
   139|             Map.Entry<String, CacheConfig> entry = iter.next();
   140|             String cacheName = entry.getKey();
   141|             clientCacheProxyFactory.removeCacheConfig(cacheName);
   142|             iter.remove();
   143|         }
   144|     }
   145|     @Override
   146|     protected <K, V> void validateCacheConfig(CacheConfig<K, V> cacheConfig) {
   147|         checkCacheConfig(cacheConfig, null);
   148|     }
   149|     @Override
   150|     protected void onShuttingDown() {
   151|     }
   152|     /**
   153|      * Gets the related {@link NearCacheManager} with the underlying client instance.
   154|      *
   155|      * @return the related {@link NearCacheManager} with the underlying client instance
   156|      */
   157|     public NearCacheManager getNearCacheManager() {
   158|         return client.getNearCacheManager();
   159|     }
   160| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/HazelcastClientCachingProvider.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-178 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.cache.impl;
    17| import com.hazelcast.cache.impl.AbstractHazelcastCachingProvider;
    18| import com.hazelcast.client.HazelcastClient;
    19| import com.hazelcast.client.config.ClientConfig;
    20| import com.hazelcast.client.config.XmlClientConfigBuilder;
    21| import com.hazelcast.core.HazelcastInstance;
    22| import com.hazelcast.util.StringUtil;
    23| import java.io.IOException;
    24| import java.net.URI;
    25| import java.net.URISyntaxException;
    26| import java.net.URL;
    27| import java.util.Properties;
    28| import static com.hazelcast.cache.HazelcastCachingProvider.HAZELCAST_CONFIG_LOCATION;
    29| import static com.hazelcast.cache.HazelcastCachingProvider.HAZELCAST_INSTANCE_ITSELF;
    30| import static com.hazelcast.cache.HazelcastCachingProvider.HAZELCAST_INSTANCE_NAME;
    31| import static com.hazelcast.util.ExceptionUtil.rethrow;
    32| import static com.hazelcast.util.StringUtil.isNullOrEmptyAfterTrim;
    33| /**
    34|  * Client side {@link javax.cache.spi.CachingProvider} implementation.
    35|  */
    36| public final class HazelcastClientCachingProvider extends AbstractHazelcastCachingProvider {
    37|     public HazelcastClientCachingProvider() {
    38|     }
    39|     /**
    40|      * Helper method for creating caching provider for testing etc.
    41|      */
    42|     public static HazelcastClientCachingProvider createCachingProvider(HazelcastInstance hazelcastInstance) {
    43|         final HazelcastClientCachingProvider cachingProvider = new HazelcastClientCachingProvider();
    44|         cachingProvider.hazelcastInstance = hazelcastInstance;
    45|         return cachingProvider;
    46|     }
    47|     @Override
    48|     protected HazelcastClientCacheManager createCacheManager(HazelcastInstance instance,
    49|                                                              URI uri, ClassLoader classLoader,
    50|                                                              Properties properties) {
    51|         return new HazelcastClientCacheManager(this, instance, uri, classLoader, properties);
    52|     }
    53|     @Override
    54|     protected HazelcastInstance getOrCreateInstance(URI uri, ClassLoader classLoader, Properties properties)
    55|             throws URISyntaxException, IOException {
    56|         HazelcastInstance instanceItself = (HazelcastInstance) properties.get(HAZELCAST_INSTANCE_ITSELF);
    57|         if (instanceItself != null) {
    58|             return instanceItself;
    59|         }
    60|         String location = properties.getProperty(HAZELCAST_CONFIG_LOCATION);
    61|         String instanceName = properties.getProperty(HAZELCAST_INSTANCE_NAME);
    62|         if (location != null) {
    63|             ClientConfig config = getConfigFromLocation(location, classLoader, instanceName);
    64|             return getOrCreateInstanceByConfig(config);
    65|         }
    66|         if (instanceName != null) {
    67|             HazelcastInstance instance = getOrCreateByInstanceName(instanceName);
    68|             return instance;
    69|         }
    70|         final boolean isDefaultURI = (uri == null || uri.equals(getDefaultURI()));
    71|         if (!isDefaultURI) {
    72|             if (isConfigLocation(uri)) {
    73|                 try {
    74|                     ClientConfig config = getConfigFromLocation(uri, classLoader, null);
    75|                     return getOrCreateInstanceByConfig(config);
    76|                 } catch (Exception e) {
    77|                     if (LOGGER.isFinestEnabled()) {
    78|                         LOGGER.finest("Could not get or create hazelcast instance from URI " + uri.toString(), e);
    79|                     }
    80|                 }
    81|             } else {
    82|                 try {
    83|                     return getOrCreateByInstanceName(uri.toString());
    84|                 } catch (Exception e) {
    85|                     if (LOGGER.isFinestEnabled()) {
    86|                         LOGGER.finest("Could not get hazelcast instance from instance name " + uri.toString(), e);
    87|                     }
    88|                 }
    89|             }
    90|             return null;
    91|         } else {
    92|             return getDefaultInstance();
    93|         }
    94|     }
    95|     private HazelcastInstance getDefaultInstance() {
    96|         if (hazelcastInstance == null) {
    97|             ClientConfig clientConfig = getDefaultClientConfig();
    98|             if (isNullOrEmptyAfterTrim(clientConfig.getInstanceName())) {
    99|                 hazelcastInstance = HazelcastClient.newHazelcastClient();
   100|             } else {
   101|                 hazelcastInstance = getOrCreateInstanceByConfig(clientConfig);
   102|             }
   103|         }
   104|         return hazelcastInstance;
   105|     }
   106|     /**
   107|      * Get an existing {@link HazelcastInstance} by {@code instanceName} or, if not found, create a new {@link HazelcastInstance}
   108|      * with default configuration and given {@code instanceName}.
   109|      *
   110|      * @param instanceName name by which to lookup existing {@link HazelcastInstance} or create new one.
   111|      * @return             a {@link HazelcastInstance} with the given {@code instanceName}
   112|      */
   113|     private HazelcastInstance getOrCreateByInstanceName(String instanceName) {
   114|         HazelcastInstance instance = HazelcastClient.getHazelcastClientByName(instanceName);
   115|         if (instance == null) {
   116|             ClientConfig clientConfig = getDefaultClientConfig();
   117|             clientConfig.setInstanceName(instanceName);
   118|             instance = HazelcastClient.newHazelcastClient(clientConfig);
   119|         }
   120|         return instance;
   121|     }
   122|     private ClientConfig getDefaultClientConfig() {
   123|         ClientConfig clientConfig = new XmlClientConfigBuilder().build();
   124|         if (namedDefaultHzInstance && StringUtil.isNullOrEmpty(clientConfig.getInstanceName())) {
   125|             clientConfig.setInstanceName(SHARED_JCACHE_INSTANCE_NAME);
   126|         }
   127|         return clientConfig;
   128|     }
   129|     protected ClientConfig getConfigFromLocation(String location, ClassLoader classLoader, String instanceName)
   130|             throws URISyntaxException, IOException {
   131|         URI uri = new URI(location);
   132|         return getConfigFromLocation(uri, classLoader, instanceName);
   133|     }
   134|     protected ClientConfig getConfigFromLocation(URI uri, ClassLoader classLoader, String instanceName)
   135|             throws URISyntaxException, IOException {
   136|         String scheme = uri.getScheme();
   137|         if (scheme == null) {
   138|             uri = new URI(System.getProperty(uri.getRawSchemeSpecificPart()));
   139|             scheme = uri.getScheme();
   140|         }
   141|         ClassLoader theClassLoader = classLoader == null ? getDefaultClassLoader() : classLoader;
   142|         URL configURL;
   143|         if ("classpath".equals(scheme)) {
   144|             configURL = theClassLoader.getResource(uri.getRawSchemeSpecificPart());
   145|         } else if ("file".equals(scheme) || "http".equals(scheme) || "https".equals(scheme)) {
   146|             configURL = uri.toURL();
   147|         } else {
   148|             throw new URISyntaxException(uri.toString(), "Unsupported protocol in configuration location URL");
   149|         }
   150|         try {
   151|             return getConfig(configURL, classLoader, instanceName);
   152|         } catch (Exception e) {
   153|             throw rethrow(e);
   154|         }
   155|     }
   156|     private ClientConfig getConfig(URL configURL, ClassLoader theClassLoader, String instanceName)
   157|             throws IOException {
   158|         ClientConfig config = new XmlClientConfigBuilder(configURL).build();
   159|         config.setClassLoader(theClassLoader);
   160|         if (instanceName != null) {
   161|             config.setInstanceName(instanceName);
   162|         } else if (config.getInstanceName() == null) {
   163|             config.setInstanceName(configURL.toString());
   164|         }
   165|         return config;
   166|     }
   167|     private HazelcastInstance getOrCreateInstanceByConfig(ClientConfig config) {
   168|         HazelcastInstance instance = HazelcastClient.getHazelcastClientByName(config.getInstanceName());
   169|         if (instance == null) {
   170|             instance = HazelcastClient.newHazelcastClient(config);
   171|         }
   172|         return instance;
   173|     }
   174|     @Override
   175|     public String toString() {
   176|         return "HazelcastClientCachingProvider{hazelcastInstance=" + hazelcastInstance + '}';
   177|     }
   178| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/NearCachedClientCacheProxy.java
# Total hunks: 5
# ====================================================================
# --- HUNK 1: Lines 26-65 ---
    26| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    27| import com.hazelcast.client.spi.impl.ListenerMessageCodec;
    28| import com.hazelcast.client.util.ClientDelegatingFuture;
    29| import com.hazelcast.config.CacheConfig;
    30| import com.hazelcast.config.InMemoryFormat;
    31| import com.hazelcast.config.NativeMemoryConfig;
    32| import com.hazelcast.config.NearCacheConfig;
    33| import com.hazelcast.core.ExecutionCallback;
    34| import com.hazelcast.internal.adapter.ICacheDataStructureAdapter;
    35| import com.hazelcast.internal.nearcache.NearCache;
    36| import com.hazelcast.internal.nearcache.NearCacheManager;
    37| import com.hazelcast.internal.nearcache.impl.invalidation.RepairingHandler;
    38| import com.hazelcast.internal.nearcache.impl.invalidation.RepairingTask;
    39| import com.hazelcast.logging.ILogger;
    40| import com.hazelcast.nio.serialization.Data;
    41| import com.hazelcast.spi.InternalCompletableFuture;
    42| import com.hazelcast.util.executor.CompletedFuture;
    43| import javax.cache.expiry.ExpiryPolicy;
    44| import javax.cache.integration.CompletionListener;
    45| import java.util.Collection;
    46| import java.util.Iterator;
    47| import java.util.LinkedList;
    48| import java.util.List;
    49| import java.util.Map;
    50| import java.util.Set;
    51| import java.util.UUID;
    52| import static com.hazelcast.config.InMemoryFormat.NATIVE;
    53| import static com.hazelcast.config.NearCacheConfig.LocalUpdatePolicy.CACHE;
    54| import static com.hazelcast.config.NearCacheConfig.LocalUpdatePolicy.CACHE_ON_UPDATE;
    55| import static com.hazelcast.instance.BuildInfo.calculateVersion;
    56| import static com.hazelcast.internal.nearcache.NearCache.CACHED_AS_NULL;
    57| import static com.hazelcast.internal.nearcache.NearCache.NOT_CACHED;
    58| import static com.hazelcast.internal.nearcache.NearCacheRecord.NOT_RESERVED;
    59| import static com.hazelcast.util.ExceptionUtil.rethrow;
    60| import static com.hazelcast.util.MapUtil.createHashMap;
    61| import static com.hazelcast.util.Preconditions.checkTrue;
    62| import static java.lang.String.format;
    63| /**
    64|  * An {@link ICacheInternal} implementation which handles Near Cache specific behaviour of methods.
    65|  *

# --- HUNK 2: Lines 255-305 ---
   255|         }
   256|     }
   257|     private void populateResultFromRemote(int currentSize, List<Object> resultingKeyValuePairs, Map<Object, Long> reservations,
   258|                                           Map<Data, Object> reverseKeyMap) {
   259|         for (int i = currentSize; i < resultingKeyValuePairs.size(); i += 2) {
   260|             Data keyData = (Data) resultingKeyValuePairs.get(i);
   261|             Data valueData = (Data) resultingKeyValuePairs.get(i + 1);
   262|             Object ncKey = serializeKeys ? keyData : reverseKeyMap.get(keyData);
   263|             if (!serializeKeys) {
   264|                 resultingKeyValuePairs.set(i, ncKey);
   265|             }
   266|             Long reservationId = reservations.get(ncKey);
   267|             if (reservationId != null) {
   268|                 Object cachedValue = tryPublishReserved(ncKey, valueData, reservationId);
   269|                 resultingKeyValuePairs.set(i + 1, cachedValue);
   270|                 reservations.remove(ncKey);
   271|             }
   272|         }
   273|     }
   274|     @Override
   275|     protected void putAllInternal(Map<? extends K, ? extends V> map, ExpiryPolicy expiryPolicy, Map<Object, Data> keyMap,
   276|                                   List<Map.Entry<Data, Data>>[] entriesPerPartition, long startNanos) {
   277|         try {
   278|             if (!serializeKeys) {
   279|                 keyMap = createHashMap(map.size());
   280|             }
   281|             super.putAllInternal(map, expiryPolicy, keyMap, entriesPerPartition, startNanos);
   282|             cacheOrInvalidate(map, keyMap, entriesPerPartition, true);
   283|         } catch (Throwable t) {
   284|             cacheOrInvalidate(map, keyMap, entriesPerPartition, false);
   285|             throw rethrow(t);
   286|         }
   287|     }
   288|     private void cacheOrInvalidate(Map<? extends K, ? extends V> map, Map<Object, Data> keyMap,
   289|                                    List<Map.Entry<Data, Data>>[] entriesPerPartition, boolean isCacheOrInvalidate) {
   290|         if (serializeKeys) {
   291|             for (int partitionId = 0; partitionId < entriesPerPartition.length; partitionId++) {
   292|                 List<Map.Entry<Data, Data>> entries = entriesPerPartition[partitionId];
   293|                 if (entries != null) {
   294|                     for (Map.Entry<Data, Data> entry : entries) {
   295|                         Data key = entry.getKey();
   296|                         if (isCacheOrInvalidate) {
   297|                             cacheOrInvalidate(key, key, null, entry.getValue());
   298|                         } else {
   299|                             invalidateNearCache(key);
   300|                         }
   301|                     }
   302|                 }
   303|             }
   304|         } else {
   305|             for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {

# --- HUNK 3: Lines 412-493 ---
   412|     }
   413|     private Object getCachedValue(Object key, boolean deserializeValue) {
   414|         Object cached = nearCache.get(key);
   415|         assert cached != CACHED_AS_NULL;
   416|         if (cached == null) {
   417|             return NOT_CACHED;
   418|         }
   419|         return deserializeValue ? toObject(cached) : cached;
   420|     }
   421|     @SuppressWarnings("unchecked")
   422|     private void cacheOrInvalidate(Object key, Data keyData, V value, Data valueData) {
   423|         if (cacheOnUpdate) {
   424|             V valueToStore = (V) nearCache.selectToSave(valueData, value);
   425|             nearCache.put(key, keyData, valueToStore);
   426|         } else {
   427|             invalidateNearCache(key);
   428|         }
   429|     }
   430|     private void invalidateNearCache(Object key) {
   431|         assert key != null;
   432|         nearCache.remove(key);
   433|     }
   434|     private long tryReserveForUpdate(Object key, Data keyData) {
   435|         return nearCache.tryReserveForUpdate(key, keyData);
   436|     }
   437|     /**
   438|      * Publishes value got from remote or deletes reserved record when remote value is {@code null}.
   439|      *
   440|      * @param key           key to update in Near Cache
   441|      * @param remoteValue   fetched value from server
   442|      * @param reservationId reservation ID for this key
   443|      * @param deserialize   deserialize returned value
   444|      * @return last known value for the key
   445|      */
   446|     private Object tryPublishReserved(Object key, Object remoteValue, long reservationId, boolean deserialize) {
   447|         assert remoteValue != NOT_CACHED;
   448|         if (remoteValue == null) {
   449|             invalidateNearCache(key);
   450|             return null;
   451|         }
   452|         Object cachedValue = null;
   453|         if (reservationId != NOT_RESERVED) {
   454|             cachedValue = nearCache.tryPublishReserved(key, remoteValue, reservationId, deserialize);
   455|         }
   456|         return cachedValue == null ? remoteValue : cachedValue;
   457|     }
   458|     private Object tryPublishReserved(Object key, Object remoteValue, long reservationId) {
   459|         return tryPublishReserved(key, remoteValue, reservationId, true);
   460|     }
   461|     private void releaseRemainingReservedKeys(Map<Object, Long> reservedKeys) {
   462|         for (Object key : reservedKeys.keySet()) {
   463|             nearCache.remove(key);
   464|         }
   465|     }
   466|     public String addNearCacheInvalidationListener(EventHandler eventHandler) {
   467|         return registerListener(createInvalidationListenerCodec(), eventHandler);
   468|     }
   469|     private void registerInvalidationListener() {
   470|         if (!invalidateOnChange) {
   471|             return;
   472|         }
   473|         EventHandler eventHandler = new ConnectedServerVersionAwareNearCacheEventHandler();
   474|         nearCacheMembershipRegistrationId = addNearCacheInvalidationListener(eventHandler);
   475|     }
   476|     private ListenerMessageCodec createInvalidationListenerCodec() {
   477|         return new ListenerMessageCodec() {
   478|             @Override
   479|             public ClientMessage encodeAddRequest(boolean localOnly) {
   480|                 if (supportsRepairableNearCache()) {
   481|                     return CacheAddNearCacheInvalidationListenerCodec.encodeRequest(nameWithPrefix, localOnly);
   482|                 }
   483|                 return CacheAddInvalidationListenerCodec.encodeRequest(nameWithPrefix, localOnly);
   484|             }
   485|             @Override
   486|             public String decodeAddResponse(ClientMessage clientMessage) {
   487|                 if (supportsRepairableNearCache()) {
   488|                     return CacheAddNearCacheInvalidationListenerCodec.decodeResponse(clientMessage).response;
   489|                 }
   490|                 return CacheAddInvalidationListenerCodec.decodeResponse(clientMessage).response;
   491|             }
   492|             @Override
   493|             public ClientMessage encodeRemoveRequest(String realRegistrationId) {

# --- HUNK 4: Lines 642-780 ---
   642|             try {
   643|                 if (callback != null) {
   644|                     callback.onResponse(response);
   645|                 }
   646|             } finally {
   647|                 invalidateNearCache(key);
   648|             }
   649|         }
   650|         @Override
   651|         public void onFailure(Throwable t) {
   652|             try {
   653|                 if (callback != null) {
   654|                     callback.onFailure(t);
   655|                 }
   656|             } finally {
   657|                 invalidateNearCache(key);
   658|             }
   659|         }
   660|     }
   661|     /**
   662|      * Deals with client compatibility.
   663|      * <p>
   664|      * Eventual consistency for Near Cache can be used with server versions >= 3.8,
   665|      * other connected server versions must use {@link Pre38NearCacheEventHandler}.
   666|      */
   667|     private final class ConnectedServerVersionAwareNearCacheEventHandler implements EventHandler<ClientMessage> {
   668|         private final Pre38NearCacheEventHandler pre38EventHandler = new Pre38NearCacheEventHandler();
   669|         private final RepairableNearCacheEventHandler repairingEventHandler = new RepairableNearCacheEventHandler();
   670|         private volatile boolean supportsRepairableNearCache;
   671|         @Override
   672|         public void beforeListenerRegister() {
   673|             repairingEventHandler.beforeListenerRegister();
   674|             supportsRepairableNearCache = supportsRepairableNearCache();
   675|             if (!supportsRepairableNearCache) {
   676|                 pre38EventHandler.beforeListenerRegister();
   677|                 logger.warning(format("Near Cache for '%s' cache is started in legacy mode", name));
   678|             }
   679|         }
   680|         @Override
   681|         public void onListenerRegister() {
   682|             if (supportsRepairableNearCache) {
   683|                 repairingEventHandler.onListenerRegister();
   684|             } else {
   685|                 pre38EventHandler.onListenerRegister();
   686|             }
   687|         }
   688|         @Override
   689|         public void handle(ClientMessage clientMessage) {
   690|             if (supportsRepairableNearCache) {
   691|                 repairingEventHandler.handle(clientMessage);
   692|             } else {
   693|                 pre38EventHandler.handle(clientMessage);
   694|             }
   695|         }
   696|     }
   697|     /**
   698|      * This event handler can only be used with server versions >= 3.8 and supports Near Cache eventual consistency improvements.
   699|      * For repairing functionality please see {@link RepairingHandler}
   700|      */
   701|     private final class RepairableNearCacheEventHandler
   702|             extends CacheAddNearCacheInvalidationListenerCodec.AbstractEventHandler
   703|             implements EventHandler<ClientMessage> {
   704|         private volatile RepairingHandler repairingHandler;
   705|         @Override
   706|         public void beforeListenerRegister() {
   707|             if (supportsRepairableNearCache()) {
   708|                 RepairingTask repairingTask = getContext().getRepairingTask(getServiceName());
   709|                 repairingHandler = repairingTask.registerAndGetHandler(nameWithPrefix, nearCache);
   710|             } else {
   711|                 RepairingTask repairingTask = getContext().getRepairingTask(getServiceName());
   712|                 repairingTask.deregisterHandler(nameWithPrefix);
   713|             }
   714|         }
   715|         @Override
   716|         public void onListenerRegister() {
   717|         }
   718|         @Override
   719|         public void handle(String name, Data key, String sourceUuid, UUID partitionUuid, long sequence) {
   720|             repairingHandler.handle(key, sourceUuid, partitionUuid, sequence);
   721|         }
   722|         @Override
   723|         public void handle(String name, Collection<Data> keys, Collection<String> sourceUuids,
   724|                            Collection<UUID> partitionUuids, Collection<Long> sequences) {
   725|             repairingHandler.handle(keys, sourceUuids, partitionUuids, sequences);
   726|         }
   727|     }
   728|     /**
   729|      * This event handler is here to be used with server versions < 3.8.
   730|      * <p>
   731|      * If server version is < 3.8 and client version is >= 3.8, this event handler must be used to
   732|      * listen Near Cache invalidations. Because new improvements for Near Cache eventual consistency
   733|      * cannot work with server versions < 3.8.
   734|      */
   735|     private final class Pre38NearCacheEventHandler
   736|             extends CacheAddInvalidationListenerCodec.AbstractEventHandler
   737|             implements EventHandler<ClientMessage> {
   738|         private String clientUuid;
   739|         private Pre38NearCacheEventHandler() {
   740|             this.clientUuid = getContext().getClusterService().getLocalClient().getUuid();
   741|         }
   742|         @Override
   743|         public void handle(String name, Data key, String sourceUuid, UUID partitionUuid, long sequence) {
   744|             if (clientUuid.equals(sourceUuid)) {
   745|                 return;
   746|             }
   747|             if (key != null) {
   748|                 nearCache.remove(serializeKeys ? key : toObject(key));
   749|             } else {
   750|                 nearCache.clear();
   751|             }
   752|         }
   753|         @Override
   754|         public void handle(String name, Collection<Data> keys, Collection<String> sourceUuids,
   755|                            Collection<UUID> partitionUuids, Collection<Long> sequences) {
   756|             if (sourceUuids != null && !sourceUuids.isEmpty()) {
   757|                 Iterator<Data> keysIt = keys.iterator();
   758|                 Iterator<String> sourceUuidsIt = sourceUuids.iterator();
   759|                 while (keysIt.hasNext() && sourceUuidsIt.hasNext()) {
   760|                     Data key = keysIt.next();
   761|                     String sourceUuid = sourceUuidsIt.next();
   762|                     if (!clientUuid.equals(sourceUuid)) {
   763|                         nearCache.remove(serializeKeys ? key : toObject(key));
   764|                     }
   765|                 }
   766|             } else {
   767|                 for (Data key : keys) {
   768|                     nearCache.remove(serializeKeys ? key : toObject(key));
   769|                 }
   770|             }
   771|         }
   772|         @Override
   773|         public void beforeListenerRegister() {
   774|         }
   775|         @Override
   776|         public void onListenerRegister() {
   777|             nearCache.clear();
   778|         }
   779|     }
   780| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/config/ClientAwsConfig.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-44 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.config;
    17| import com.hazelcast.config.AwsConfig;
    18| /**
    19|  * The AWSConfig contains the configuration for client
    20|  * to connect to nodes in aws environment.
    21|  */
    22| public class ClientAwsConfig extends AwsConfig {
    23|     private boolean insideAws;
    24|     /**
    25|      * If client is inside aws, it will use private ip addresses directly,
    26|      * otherwise it will convert private ip addresses to public addresses
    27|      * internally by calling AWS API.
    28|      *
    29|      * @return boolean true if client is inside aws environment.
    30|      */
    31|     public boolean isInsideAws() {
    32|         return insideAws;
    33|     }
    34|     /**
    35|      * Set to true if client is inside aws environment
    36|      * Default value is false.
    37|      *
    38|      * @param insideAws isInsideAws
    39|      */
    40|     public ClientAwsConfig setInsideAws(boolean insideAws) {
    41|         this.insideAws = insideAws;
    42|         return this;
    43|     }
    44| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/config/ClientConfig.java
# Total hunks: 5
# ====================================================================
# --- HUNK 1: Lines 20-59 ---
    20| import com.hazelcast.config.GroupConfig;
    21| import com.hazelcast.config.ListenerConfig;
    22| import com.hazelcast.config.NativeMemoryConfig;
    23| import com.hazelcast.config.NearCacheConfig;
    24| import com.hazelcast.config.QueryCacheConfig;
    25| import com.hazelcast.config.SerializationConfig;
    26| import com.hazelcast.config.SocketInterceptorConfig;
    27| import com.hazelcast.config.matcher.MatchingPointConfigPatternMatcher;
    28| import com.hazelcast.core.ManagedContext;
    29| import com.hazelcast.flakeidgen.FlakeIdGenerator;
    30| import com.hazelcast.logging.ILogger;
    31| import com.hazelcast.logging.Logger;
    32| import com.hazelcast.security.Credentials;
    33| import java.util.HashMap;
    34| import java.util.LinkedList;
    35| import java.util.List;
    36| import java.util.Map;
    37| import java.util.Map.Entry;
    38| import java.util.Properties;
    39| import java.util.concurrent.ConcurrentHashMap;
    40| import static com.hazelcast.config.NearCacheConfigAccessor.initDefaultMaxSizeForOnHeapMaps;
    41| import static com.hazelcast.internal.config.ConfigUtils.lookupByPattern;
    42| import static com.hazelcast.partition.strategy.StringPartitioningStrategy.getBaseName;
    43| import static com.hazelcast.util.Preconditions.checkFalse;
    44| /**
    45|  * Main configuration to setup a Hazelcast Client
    46|  */
    47| public class ClientConfig {
    48|     private static final ILogger LOGGER = Logger.getLogger(ClientConfig.class);
    49|     /**
    50|      * To pass properties
    51|      */
    52|     private Properties properties = new Properties();
    53|     /**
    54|      * The Group Configuration properties like:
    55|      * Name and Password that is used to connect to the cluster.
    56|      */
    57|     private GroupConfig groupConfig = new GroupConfig();
    58|     /**
    59|      * The Security Configuration for custom Credentials:

# --- HUNK 2: Lines 77-116 ---
    77|     /**
    78|      * pool-size for internal ExecutorService which handles responses etc.
    79|      */
    80|     private int executorPoolSize = -1;
    81|     private String instanceName;
    82|     private ConfigPatternMatcher configPatternMatcher = new MatchingPointConfigPatternMatcher();
    83|     private final Map<String, NearCacheConfig> nearCacheConfigMap = new ConcurrentHashMap<String, NearCacheConfig>();
    84|     private final Map<String, ClientReliableTopicConfig> reliableTopicConfigMap
    85|             = new ConcurrentHashMap<String, ClientReliableTopicConfig>();
    86|     private Map<String, Map<String, QueryCacheConfig>> queryCacheConfigs;
    87|     private SerializationConfig serializationConfig = new SerializationConfig();
    88|     private NativeMemoryConfig nativeMemoryConfig = new NativeMemoryConfig();
    89|     private final List<ProxyFactoryConfig> proxyFactoryConfigs = new LinkedList<ProxyFactoryConfig>();
    90|     private ManagedContext managedContext;
    91|     private ClassLoader classLoader;
    92|     private String licenseKey;
    93|     private ClientConnectionStrategyConfig connectionStrategyConfig = new ClientConnectionStrategyConfig();
    94|     private ClientUserCodeDeploymentConfig userCodeDeploymentConfig = new ClientUserCodeDeploymentConfig();
    95|     private final Map<String, ClientFlakeIdGeneratorConfig> flakeIdGeneratorConfigMap =
    96|             new ConcurrentHashMap<String, ClientFlakeIdGeneratorConfig>();
    97|     /**
    98|      * Sets the pattern matcher which is used to match item names to
    99|      * configuration objects.
   100|      * By default the {@link MatchingPointConfigPatternMatcher} is used.
   101|      *
   102|      * @param configPatternMatcher the pattern matcher
   103|      * @throws IllegalArgumentException if the pattern matcher is {@code null}
   104|      */
   105|     public void setConfigPatternMatcher(ConfigPatternMatcher configPatternMatcher) {
   106|         if (configPatternMatcher == null) {
   107|             throw new IllegalArgumentException("ConfigPatternMatcher is not allowed to be null!");
   108|         }
   109|         this.configPatternMatcher = configPatternMatcher;
   110|     }
   111|     /**
   112|      * Returns the pattern matcher which is used to match item names to
   113|      * configuration objects.
   114|      * By default the {@link MatchingPointConfigPatternMatcher} is used.
   115|      *
   116|      * @return the pattern matcher

# --- HUNK 3: Lines 395-434 ---
   395|         flakeIdGeneratorConfigMap.put(config.getName(), config);
   396|         return this;
   397|     }
   398|     /**
   399|      * Sets the map of {@link FlakeIdGenerator} configurations,
   400|      * mapped by config name. The config name may be a pattern with which the
   401|      * configuration will be obtained in the future.
   402|      *
   403|      * @param map the FlakeIdGenerator configuration map to set
   404|      * @return this config instance
   405|      */
   406|     public ClientConfig setFlakeIdGeneratorConfigMap(Map<String, ClientFlakeIdGeneratorConfig> map) {
   407|         flakeIdGeneratorConfigMap.clear();
   408|         flakeIdGeneratorConfigMap.putAll(map);
   409|         for (Entry<String, ClientFlakeIdGeneratorConfig> entry : map.entrySet()) {
   410|             entry.getValue().setName(entry.getKey());
   411|         }
   412|         return this;
   413|     }
   414|     /**
   415|      * Use {@link ClientNetworkConfig#isSmartRouting} instead
   416|      */
   417|     @Deprecated
   418|     public boolean isSmartRouting() {
   419|         return networkConfig.isSmartRouting();
   420|     }
   421|     /**
   422|      * Use {@link ClientNetworkConfig#setSmartRouting} instead
   423|      */
   424|     @Deprecated
   425|     public ClientConfig setSmartRouting(boolean smartRouting) {
   426|         networkConfig.setSmartRouting(smartRouting);
   427|         return this;
   428|     }
   429|     /**
   430|      * Use {@link ClientNetworkConfig#getSocketInterceptorConfig} instead
   431|      */
   432|     @Deprecated
   433|     public SocketInterceptorConfig getSocketInterceptorConfig() {
   434|         return networkConfig.getSocketInterceptorConfig();

# --- HUNK 4: Lines 709-749 ---
   709|      * @return configured {@link com.hazelcast.client.config.ClientConfig} for chaining
   710|      * @see com.hazelcast.config.SerializationConfig
   711|      */
   712|     public ClientConfig setSerializationConfig(SerializationConfig serializationConfig) {
   713|         this.serializationConfig = serializationConfig;
   714|         return this;
   715|     }
   716|     public NativeMemoryConfig getNativeMemoryConfig() {
   717|         return nativeMemoryConfig;
   718|     }
   719|     public ClientConfig setNativeMemoryConfig(NativeMemoryConfig nativeMemoryConfig) {
   720|         this.nativeMemoryConfig = nativeMemoryConfig;
   721|         return this;
   722|     }
   723|     public String getLicenseKey() {
   724|         return licenseKey;
   725|     }
   726|     /**
   727|      * @deprecated As of Hazelcast 3.10.3, enterprise license keys are required only for members, and not for clients
   728|      */
   729|     @Deprecated
   730|     public ClientConfig setLicenseKey(final String licenseKey) {
   731|         this.licenseKey = licenseKey;
   732|         return this;
   733|     }
   734|     public ClientConfig addQueryCacheConfig(String mapName, QueryCacheConfig queryCacheConfig) {
   735|         Map<String, Map<String, QueryCacheConfig>> queryCacheConfigsPerMap = getQueryCacheConfigs();
   736|         String queryCacheName = queryCacheConfig.getName();
   737|         Map<String, QueryCacheConfig> queryCacheConfigs = queryCacheConfigsPerMap.get(mapName);
   738|         if (queryCacheConfigs != null) {
   739|             checkFalse(queryCacheConfigs.containsKey(queryCacheName),
   740|                     "A query cache already exists with name = [" + queryCacheName + ']');
   741|         } else {
   742|             queryCacheConfigs = new ConcurrentHashMap<String, QueryCacheConfig>();
   743|             queryCacheConfigsPerMap.put(mapName, queryCacheConfigs);
   744|         }
   745|         queryCacheConfigs.put(queryCacheName, queryCacheConfig);
   746|         return this;
   747|     }
   748|     public Map<String, Map<String, QueryCacheConfig>> getQueryCacheConfigs() {
   749|         if (queryCacheConfigs == null) {

# --- HUNK 5: Lines 805-825 ---
   805|             queryCacheConfig = new QueryCacheConfig(cacheName);
   806|             queryCacheConfigsForMap.put(cacheName, queryCacheConfig);
   807|         }
   808|         return queryCacheConfig;
   809|     }
   810|     /**
   811|      * @param mapName   The name of the map for which the query cache config is to be returned.
   812|      * @param cacheName The name of the query cache.
   813|      * @return The query cache config. If no such config exist null is returned.
   814|      */
   815|     public QueryCacheConfig getOrNullQueryCacheConfig(String mapName, String cacheName) {
   816|         if (queryCacheConfigs == null) {
   817|             return null;
   818|         }
   819|         Map<String, QueryCacheConfig> queryCacheConfigsForMap = lookupByPattern(configPatternMatcher, queryCacheConfigs, mapName);
   820|         if (queryCacheConfigsForMap == null) {
   821|             return null;
   822|         }
   823|         return lookupByPattern(configPatternMatcher, queryCacheConfigsForMap, cacheName);
   824|     }
   825| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/config/ClientConnectionStrategyConfig.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 22-80 ---
    22|     /**
    23|      * Reconnect options.
    24|      */
    25|     public enum ReconnectMode {
    26|         /**
    27|          * Prevent reconnect to cluster after a disconnect
    28|          */
    29|         OFF,
    30|         /**
    31|          * Reconnect to cluster by blocking invocations
    32|          */
    33|         ON,
    34|         /**
    35|          * Reconnect to cluster without blocking invocations. Invocations will receive
    36|          * {@link com.hazelcast.client.HazelcastClientOfflineException }
    37|          */
    38|         ASYNC
    39|     }
    40|     private boolean asyncStart;
    41|     private ReconnectMode reconnectMode = ReconnectMode.ON;
    42|     /**
    43|      * Client instance creation won't block on {@link HazelcastClient#newHazelcastClient()} if this value is true
    44|      * @return if client connects to cluster asynchronously
    45|      */
    46|     public boolean isAsyncStart() {
    47|         return asyncStart;
    48|     }
    49|     /**
    50|      * Set true for non blocking {@link HazelcastClient#newHazelcastClient()}. The client creation won't wait to
    51|      * connect to cluster. The client instace will throw exception until it connects to cluster and become ready.
    52|      * If set to false, {@link HazelcastClient#newHazelcastClient()} will block until a cluster connection established and it's
    53|      * ready to use client instance
    54|      *
    55|      * default value is false
    56|      * @param asyncStart true for async client creation
    57|      * @return the updated ClientConnectionStrategyConfig
    58|      */
    59|     public ClientConnectionStrategyConfig setAsyncStart(boolean asyncStart) {
    60|         this.asyncStart = asyncStart;
    61|         return this;
    62|     }
    63|     /**
    64|      * @return reconnect mode
    65|      */
    66|     public ReconnectMode getReconnectMode() {
    67|         return reconnectMode;
    68|     }
    69|     /**
    70|      * How a client reconnect to cluster after a disconnect can be configured. This parameter is used by default strategy and
    71|      * custom implementations may ignore it if configured.
    72|      * default value is {@link ReconnectMode#ON}
    73|      * @param reconnectMode
    74|      * @return
    75|      */
    76|     public ClientConnectionStrategyConfig setReconnectMode(ReconnectMode reconnectMode) {
    77|         this.reconnectMode = reconnectMode;
    78|         return this;
    79|     }
    80| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/config/ClientNetworkConfig.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-62 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.config;
    17| import com.hazelcast.config.DiscoveryConfig;
    18| import com.hazelcast.config.SSLConfig;
    19| import com.hazelcast.config.SocketInterceptorConfig;
    20| import java.util.ArrayList;
    21| import java.util.Collection;
    22| import java.util.Collections;
    23| import java.util.HashSet;
    24| import java.util.List;
    25| import static com.hazelcast.util.Preconditions.checkHasText;
    26| import static com.hazelcast.util.Preconditions.isNotNull;
    27| /**
    28|  * Contains configuration parameters for client network related behaviour
    29|  */
    30| public class ClientNetworkConfig {
    31|     private static final int CONNECTION_TIMEOUT = 5000;
    32|     private static final int CONNECTION_ATTEMPT_PERIOD = 3000;
    33|     private final List<String> addressList = new ArrayList<String>(10);
    34|     private boolean smartRouting = true;
    35|     private boolean redoOperation;
    36|     private int connectionTimeout = CONNECTION_TIMEOUT;
    37|     private int connectionAttemptLimit = -1;
    38|     private int connectionAttemptPeriod = CONNECTION_ATTEMPT_PERIOD;
    39|     private SocketInterceptorConfig socketInterceptorConfig;
    40|     private SocketOptions socketOptions = new SocketOptions();
    41|     private SSLConfig sslConfig;
    42|     private ClientAwsConfig clientAwsConfig;
    43|     private DiscoveryConfig discoveryConfig;
    44|     private Collection<String> outboundPortDefinitions;
    45|     private Collection<Integer> outboundPorts;
    46|     private ClientIcmpPingConfig clientIcmpPingConfig = new ClientIcmpPingConfig();
    47|     /**
    48|      * Returns the configuration of the Hazelcast Discovery SPI and configured discovery providers
    49|      *
    50|      * @return Discovery Provider SPI configuration
    51|      */
    52|     public DiscoveryConfig getDiscoveryConfig() {
    53|         if (discoveryConfig == null) {
    54|             discoveryConfig = new DiscoveryConfig();
    55|         }
    56|         return discoveryConfig;
    57|     }
    58|     /**
    59|      * Defines the Discovery Provider SPI configuration
    60|      *
    61|      * @param discoveryConfig the Discovery Provider SPI configuration
    62|      * @throws java.lang.IllegalArgumentException if discoveryConfig is null

# --- HUNK 2: Lines 251-308 ---
   251|      * set.
   252|      *
   253|      * @return the SSLConfig.
   254|      * @see #setSSLConfig(SSLConfig)
   255|      */
   256|     public SSLConfig getSSLConfig() {
   257|         return sslConfig;
   258|     }
   259|     /**
   260|      * Sets the {@link SSLConfig}. null value indicates that no SSLConfig should be used.
   261|      *
   262|      * @param sslConfig the SSLConfig.
   263|      * @return the updated ClientNetworkConfig.
   264|      * @see #getSSLConfig()
   265|      */
   266|     public ClientNetworkConfig setSSLConfig(SSLConfig sslConfig) {
   267|         this.sslConfig = sslConfig;
   268|         return this;
   269|     }
   270|     /**
   271|      * Sets configuration to connect nodes in aws environment.
   272|      * null value indicates that no AwsConfig should be used.
   273|      *
   274|      * @param clientAwsConfig the ClientAwsConfig
   275|      * @see #getAwsConfig()
   276|      */
   277|     public ClientNetworkConfig setAwsConfig(ClientAwsConfig clientAwsConfig) {
   278|         this.clientAwsConfig = clientAwsConfig;
   279|         return this;
   280|     }
   281|     /**
   282|      * Returns the current {@link ClientAwsConfig}. It is possible that null is returned if no SSLConfig has been
   283|      *
   284|      * @return ClientAwsConfig
   285|      * @see #setAwsConfig(ClientAwsConfig)
   286|      */
   287|     public ClientAwsConfig getAwsConfig() {
   288|         return clientAwsConfig;
   289|     }
   290|     /**
   291|      * Returns the outbound port definitions. It is possible that null is returned if not defined.
   292|      *
   293|      * @return list of outbound port definitions
   294|      */
   295|     public Collection<String> getOutboundPortDefinitions() {
   296|         return outboundPortDefinitions;
   297|     }
   298|     /**
   299|      * Returns the outbound ports. It is possible that null is returned if not defined.
   300|      *
   301|      * @return list of outbound ports
   302|      */
   303|     public Collection<Integer> getOutboundPorts() {
   304|         return outboundPorts;
   305|     }
   306|     /**
   307|      * Set outbound port definitions
   308|      *


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/config/ClientReliableTopicConfig.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 20-72 ---
    20| import static com.hazelcast.util.Preconditions.checkNotNull;
    21| import static com.hazelcast.util.Preconditions.checkPositive;
    22| /**
    23|  * Contains the ReliableTopic configuration for a client.
    24|  *
    25|  * @see com.hazelcast.client.proxy.ClientReliableTopicProxy
    26|  */
    27| public class ClientReliableTopicConfig {
    28|     /**
    29|      * The default read batch size.
    30|      */
    31|     public static final int DEFAULT_READ_BATCH_SIZE = 10;
    32|     /**
    33|      * The default slow consumer policy.
    34|      */
    35|     public static final TopicOverloadPolicy DEFAULT_TOPIC_OVERLOAD_POLICY = BLOCK;
    36|     private Executor executor;
    37|     private int readBatchSize = DEFAULT_READ_BATCH_SIZE;
    38|     private String name;
    39|     private TopicOverloadPolicy topicOverloadPolicy = DEFAULT_TOPIC_OVERLOAD_POLICY;
    40|     /**
    41|      * Creates a new ReliableTopicConfig with default settings.
    42|      */
    43|     public ClientReliableTopicConfig(String name) {
    44|         this.name = checkNotNull(name, "name");
    45|     }
    46|     /**
    47|      * Gets the name of the reliable topic.
    48|      *
    49|      * @return the name of the reliable topic.
    50|      */
    51|     public String getName() {
    52|         return name;
    53|     }
    54|     /**
    55|      * Gets the TopicOverloadPolicy for this reliable topic.
    56|      *
    57|      * @return the TopicOverloadPolicy.
    58|      */
    59|     public TopicOverloadPolicy getTopicOverloadPolicy() {
    60|         return topicOverloadPolicy;
    61|     }
    62|     /**
    63|      * Sets the TopicOverloadPolicy for this reliable topic. Check the {@link TopicOverloadPolicy} for more details about
    64|      * this setting.
    65|      *
    66|      * @param topicOverloadPolicy the new TopicOverloadPolicy.
    67|      * @return the updated reliable topic config.
    68|      * @throws IllegalArgumentException if topicOverloadPolicy is null.
    69|      */
    70|     public ClientReliableTopicConfig setTopicOverloadPolicy(TopicOverloadPolicy topicOverloadPolicy) {
    71|         this.topicOverloadPolicy = checkNotNull(topicOverloadPolicy, "topicOverloadPolicy can't be null");
    72|         return this;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/config/ClientSecurityConfig.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.config;
    17| import com.hazelcast.security.Credentials;
    18| /**
    19|  * Contains the security configuration for a client.
    20|  */
    21| public class ClientSecurityConfig {
    22|     private Credentials credentials;
    23|     private String credentialsClassname;
    24|     public Credentials getCredentials() {
    25|         return credentials;
    26|     }
    27|     public ClientSecurityConfig setCredentials(Credentials credentials) {
    28|         this.credentials = credentials;
    29|         return this;
    30|     }
    31|     public String getCredentialsClassname() {
    32|         return credentialsClassname;
    33|     }
    34|     public ClientSecurityConfig setCredentialsClassname(String credentialsClassname) {
    35|         this.credentialsClassname = credentialsClassname;
    36|         return this;
    37|     }
    38| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/config/ClientXmlElements.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 16-54 ---
    16| package com.hazelcast.client.config;
    17| enum ClientXmlElements {
    18|     HAZELCAST_CLIENT("hazelcast-client", false),
    19|     IMPORT("import", true),
    20|     SECURITY("security", false),
    21|     PROXY_FACTORIES("proxy-factories", false),
    22|     PROPERTIES("properties", false),
    23|     SERIALIZATION("serialization", false),
    24|     NATIVE_MEMORY("native-memory", false),
    25|     GROUP("group", false),
    26|     LISTENERS("listeners", false),
    27|     NETWORK("network", false),
    28|     LOAD_BALANCER("load-balancer", false),
    29|     NEAR_CACHE("near-cache", true),
    30|     QUERY_CACHES("query-caches", false),
    31|     EXECUTOR_POOL_SIZE("executor-pool-size", false),
    32|     LICENSE_KEY("license-key", false),
    33|     INSTANCE_NAME("instance-name", false),
    34|     CONNECTION_STRATEGY("connection-strategy", false),
    35|     USER_CODE_DEPLOYMENT("user-code-deployment", false),
    36|     FLAKE_ID_GENERATOR("flake-id-generator", true);
    37|     final String name;
    38|     final boolean multipleOccurrence;
    39|     ClientXmlElements(String name, boolean multipleOccurrence) {
    40|         this.name = name;
    41|         this.multipleOccurrence = multipleOccurrence;
    42|     }
    43|     public static boolean canOccurMultipleTimes(String name) {
    44|         for (ClientXmlElements element : values()) {
    45|             if (name.equals(element.name)) {
    46|                 return element.multipleOccurrence;
    47|             }
    48|         }
    49|         return true;
    50|     }
    51|     public boolean isEqual(String name) {
    52|         return this.name.equals(name);
    53|     }
    54| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/config/XmlClientConfigBuilder.java
# Total hunks: 7
# ====================================================================
# --- HUNK 1: Lines 1-88 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.config;
    17| import com.hazelcast.client.config.ClientConnectionStrategyConfig.ReconnectMode;
    18| import com.hazelcast.client.util.RandomLB;
    19| import com.hazelcast.client.util.RoundRobinLB;
    20| import com.hazelcast.config.AbstractConfigBuilder;
    21| import com.hazelcast.config.ConfigLoader;
    22| import com.hazelcast.config.DiscoveryConfig;
    23| import com.hazelcast.config.DiscoveryStrategyConfig;
    24| import com.hazelcast.config.EvictionConfig;
    25| import com.hazelcast.config.EvictionConfig.MaxSizePolicy;
    26| import com.hazelcast.config.EvictionPolicy;
    27| import com.hazelcast.config.InMemoryFormat;
    28| import com.hazelcast.config.InvalidConfigurationException;
    29| import com.hazelcast.config.ListenerConfig;
    30| import com.hazelcast.config.NearCacheConfig;
    31| import com.hazelcast.config.NearCachePreloaderConfig;
    32| import com.hazelcast.config.SSLConfig;
    33| import com.hazelcast.config.SerializationConfig;
    34| import com.hazelcast.config.SocketInterceptorConfig;
    35| import com.hazelcast.logging.ILogger;
    36| import com.hazelcast.logging.Logger;
    37| import com.hazelcast.nio.IOUtil;
    38| import com.hazelcast.util.ExceptionUtil;
    39| import org.w3c.dom.Document;
    40| import org.w3c.dom.Element;
    41| import org.w3c.dom.NamedNodeMap;
    42| import org.w3c.dom.Node;
    43| import javax.xml.parsers.DocumentBuilder;
    44| import javax.xml.parsers.DocumentBuilderFactory;
    45| import java.io.File;
    46| import java.io.FileInputStream;
    47| import java.io.IOException;
    48| import java.io.InputStream;
    49| import java.net.URL;
    50| import java.util.HashMap;
    51| import java.util.HashSet;
    52| import java.util.Map;
    53| import java.util.Properties;
    54| import java.util.Set;
    55| import static com.hazelcast.client.config.ClientXmlElements.CONNECTION_STRATEGY;
    56| import static com.hazelcast.client.config.ClientXmlElements.EXECUTOR_POOL_SIZE;
    57| import static com.hazelcast.client.config.ClientXmlElements.FLAKE_ID_GENERATOR;
    58| import static com.hazelcast.client.config.ClientXmlElements.GROUP;
    59| import static com.hazelcast.client.config.ClientXmlElements.INSTANCE_NAME;
    60| import static com.hazelcast.client.config.ClientXmlElements.LICENSE_KEY;
    61| import static com.hazelcast.client.config.ClientXmlElements.LISTENERS;
    62| import static com.hazelcast.client.config.ClientXmlElements.LOAD_BALANCER;
    63| import static com.hazelcast.client.config.ClientXmlElements.NATIVE_MEMORY;
    64| import static com.hazelcast.client.config.ClientXmlElements.NEAR_CACHE;
    65| import static com.hazelcast.client.config.ClientXmlElements.NETWORK;
    66| import static com.hazelcast.client.config.ClientXmlElements.PROPERTIES;
    67| import static com.hazelcast.client.config.ClientXmlElements.PROXY_FACTORIES;
    68| import static com.hazelcast.client.config.ClientXmlElements.QUERY_CACHES;
    69| import static com.hazelcast.client.config.ClientXmlElements.SECURITY;
    70| import static com.hazelcast.client.config.ClientXmlElements.SERIALIZATION;
    71| import static com.hazelcast.client.config.ClientXmlElements.USER_CODE_DEPLOYMENT;
    72| import static com.hazelcast.client.config.ClientXmlElements.canOccurMultipleTimes;
    73| import static com.hazelcast.util.StringUtil.LINE_SEPARATOR;
    74| import static com.hazelcast.util.StringUtil.upperCaseInternal;
    75| /**
    76|  * Loads the {@link com.hazelcast.client.config.ClientConfig} using XML.
    77|  */
    78| @SuppressWarnings("checkstyle:methodcount")
    79| public class XmlClientConfigBuilder extends AbstractConfigBuilder {
    80|     private static final ILogger LOGGER = Logger.getLogger(XmlClientConfigBuilder.class);
    81|     private final QueryCacheConfigBuilderHelper queryCacheConfigBuilderHelper = new QueryCacheConfigBuilderHelper();
    82|     private final Set<String> occurrenceSet = new HashSet<String>();
    83|     private final InputStream in;
    84|     private Properties properties = System.getProperties();
    85|     private ClientConfig clientConfig;
    86|     public XmlClientConfigBuilder(String resource) throws IOException {
    87|         URL url = ConfigLoader.locateConfig(resource);
    88|         if (url == null) {

# --- HUNK 2: Lines 217-267 ---
   217|         } else if (NETWORK.isEqual(nodeName)) {
   218|             handleNetwork(node);
   219|         } else if (LOAD_BALANCER.isEqual(nodeName)) {
   220|             handleLoadBalancer(node);
   221|         } else if (NEAR_CACHE.isEqual(nodeName)) {
   222|             handleNearCache(node);
   223|         } else if (QUERY_CACHES.isEqual(nodeName)) {
   224|             queryCacheConfigBuilderHelper.handleQueryCache(clientConfig, node);
   225|         } else if (EXECUTOR_POOL_SIZE.isEqual(nodeName)) {
   226|             handleExecutorPoolSize(node);
   227|         } else if (LICENSE_KEY.isEqual(nodeName)) {
   228|             clientConfig.setLicenseKey(getTextContent(node));
   229|         } else if (INSTANCE_NAME.isEqual(nodeName)) {
   230|             clientConfig.setInstanceName(getTextContent(node));
   231|         } else if (CONNECTION_STRATEGY.isEqual(nodeName)) {
   232|             handleConnectionStrategy(node);
   233|         } else if (USER_CODE_DEPLOYMENT.isEqual(nodeName)) {
   234|             handleUserCodeDeployment(node);
   235|         } else if (FLAKE_ID_GENERATOR.isEqual(nodeName)) {
   236|             handleFlakeIdGenerator(node);
   237|         }
   238|     }
   239|     private void handleConnectionStrategy(Node node) {
   240|         ClientConnectionStrategyConfig strategyConfig = new ClientConnectionStrategyConfig();
   241|         String attrValue = getAttribute(node, "async-start");
   242|         strategyConfig.setAsyncStart(attrValue != null && getBooleanValue(attrValue.trim()));
   243|         attrValue = getAttribute(node, "reconnect-mode");
   244|         if (attrValue != null) {
   245|             strategyConfig.setReconnectMode(ReconnectMode.valueOf(upperCaseInternal(attrValue.trim())));
   246|         }
   247|         clientConfig.setConnectionStrategyConfig(strategyConfig);
   248|     }
   249|     private void handleUserCodeDeployment(Node node) {
   250|         NamedNodeMap atts = node.getAttributes();
   251|         Node enabledNode = atts.getNamedItem("enabled");
   252|         boolean enabled = enabledNode != null && getBooleanValue(getTextContent(enabledNode).trim());
   253|         ClientUserCodeDeploymentConfig userCodeDeploymentConfig = new ClientUserCodeDeploymentConfig();
   254|         userCodeDeploymentConfig.setEnabled(enabled);
   255|         for (Node child : childElements(node)) {
   256|             String childNodeName = cleanNodeName(child);
   257|             if ("classnames".equals(childNodeName)) {
   258|                 for (Node classNameNode : childElements(child)) {
   259|                     userCodeDeploymentConfig.addClass(getTextContent(classNameNode));
   260|                 }
   261|             } else if ("jarpaths".equals(childNodeName)) {
   262|                 for (Node jarPathNode : childElements(child)) {
   263|                     userCodeDeploymentConfig.addJar(getTextContent(jarPathNode));
   264|                 }
   265|             } else {
   266|                 throw new InvalidConfigurationException("User code deployement can either be className or jarPath. "
   267|                         + childNodeName + " is invalid");

# --- HUNK 3: Lines 310-349 ---
   310|         if (serializeKeys != null && !serializeKeys && nearCacheConfig.getInMemoryFormat() == InMemoryFormat.NATIVE) {
   311|             LOGGER.warning("The Near Cache doesn't support keys by-reference with NATIVE in-memory-format."
   312|                     + " This setting will have no effect!");
   313|         }
   314|         clientConfig.addNearCacheConfig(nearCacheConfig);
   315|     }
   316|     private void handleFlakeIdGenerator(Node node) {
   317|         String name = getAttribute(node, "name");
   318|         ClientFlakeIdGeneratorConfig config = new ClientFlakeIdGeneratorConfig(name);
   319|         for (Node child : childElements(node)) {
   320|             String nodeName = cleanNodeName(child);
   321|             String value = getTextContent(child).trim();
   322|             if ("prefetch-count".equals(nodeName)) {
   323|                 config.setPrefetchCount(Integer.parseInt(value));
   324|             } else if ("prefetch-validity-millis".equalsIgnoreCase(nodeName)) {
   325|                 config.setPrefetchValidityMillis(Long.parseLong(value));
   326|             }
   327|         }
   328|         clientConfig.addFlakeIdGeneratorConfig(config);
   329|     }
   330|     private EvictionConfig getEvictionConfig(Node node) {
   331|         EvictionConfig evictionConfig = new EvictionConfig();
   332|         Node size = node.getAttributes().getNamedItem("size");
   333|         Node maxSizePolicy = node.getAttributes().getNamedItem("max-size-policy");
   334|         Node evictionPolicy = node.getAttributes().getNamedItem("eviction-policy");
   335|         if (size != null) {
   336|             evictionConfig.setSize(Integer.parseInt(getTextContent(size)));
   337|         }
   338|         if (maxSizePolicy != null) {
   339|             evictionConfig.setMaximumSizePolicy(MaxSizePolicy.valueOf(upperCaseInternal(getTextContent(maxSizePolicy)))
   340|             );
   341|         }
   342|         if (evictionPolicy != null) {
   343|             evictionConfig.setEvictionPolicy(EvictionPolicy.valueOf(upperCaseInternal(getTextContent(evictionPolicy)))
   344|             );
   345|         }
   346|         return evictionConfig;
   347|     }
   348|     private NearCachePreloaderConfig getNearCachePreloaderConfig(Node node) {
   349|         NearCachePreloaderConfig preloaderConfig = new NearCachePreloaderConfig();

# --- HUNK 4: Lines 379-429 ---
   379|         for (Node child : childElements(node)) {
   380|             String nodeName = cleanNodeName(child);
   381|             if ("cluster-members".equals(nodeName)) {
   382|                 handleClusterMembers(child, clientNetworkConfig);
   383|             } else if ("smart-routing".equals(nodeName)) {
   384|                 clientNetworkConfig.setSmartRouting(Boolean.parseBoolean(getTextContent(child)));
   385|             } else if ("redo-operation".equals(nodeName)) {
   386|                 clientNetworkConfig.setRedoOperation(Boolean.parseBoolean(getTextContent(child)));
   387|             } else if ("connection-timeout".equals(nodeName)) {
   388|                 clientNetworkConfig.setConnectionTimeout(Integer.parseInt(getTextContent(child)));
   389|             } else if ("connection-attempt-period".equals(nodeName)) {
   390|                 clientNetworkConfig.setConnectionAttemptPeriod(Integer.parseInt(getTextContent(child)));
   391|             } else if ("connection-attempt-limit".equals(nodeName)) {
   392|                 clientNetworkConfig.setConnectionAttemptLimit(Integer.parseInt(getTextContent(child)));
   393|             } else if ("socket-options".equals(nodeName)) {
   394|                 handleSocketOptions(child, clientNetworkConfig);
   395|             } else if ("socket-interceptor".equals(nodeName)) {
   396|                 handleSocketInterceptorConfig(child, clientNetworkConfig);
   397|             } else if ("ssl".equals(nodeName)) {
   398|                 handleSSLConfig(child, clientNetworkConfig);
   399|             } else if ("aws".equals(nodeName)) {
   400|                 handleAWS(child, clientNetworkConfig);
   401|             } else if ("discovery-strategies".equals(nodeName)) {
   402|                 handleDiscoveryStrategies(child, clientNetworkConfig);
   403|             } else if ("outbound-ports".equals(nodeName)) {
   404|                 handleOutboundPorts(child, clientNetworkConfig);
   405|             } else if ("icmp-ping".equals(nodeName)) {
   406|                 handleIcmpPing(child, clientNetworkConfig);
   407|             }
   408|         }
   409|         clientConfig.setNetworkConfig(clientNetworkConfig);
   410|     }
   411|     private void handleIcmpPing(Node node, ClientNetworkConfig clientNetworkConfig) {
   412|         ClientIcmpPingConfig icmpPingConfig = clientNetworkConfig.getClientIcmpPingConfig();
   413|         NamedNodeMap atts = node.getAttributes();
   414|         Node enabledNode = atts.getNamedItem("enabled");
   415|         boolean enabled = enabledNode != null && getBooleanValue(getTextContent(enabledNode).trim());
   416|         icmpPingConfig.setEnabled(enabled);
   417|         for (Node child : childElements(node)) {
   418|             String nodeName = cleanNodeName(child);
   419|             if ("timeout-milliseconds".equals(nodeName)) {
   420|                 icmpPingConfig.setTimeoutMilliseconds(Integer.parseInt(getTextContent(child)));
   421|             } else if ("interval-milliseconds".equals(nodeName)) {
   422|                 icmpPingConfig.setIntervalMilliseconds(Integer.parseInt(getTextContent(child)));
   423|             } else if ("ttl".equals(nodeName)) {
   424|                 icmpPingConfig.setTtl(Integer.parseInt(getTextContent(child)));
   425|             } else if ("max-attempts".equals(nodeName)) {
   426|                 icmpPingConfig.setMaxAttempts(Integer.parseInt(getTextContent(child)));
   427|             } else if ("echo-fail-fast-on-startup".equals(nodeName)) {
   428|                 icmpPingConfig.setEchoFailFastOnStartup(Boolean.parseBoolean(getTextContent(child)));
   429|             }

# --- HUNK 5: Lines 456-538 ---
   456|             Node att = atts.item(a);
   457|             String value = getTextContent(att).trim();
   458|             if ("enabled".equalsIgnoreCase(att.getNodeName())) {
   459|                 enabled = getBooleanValue(value);
   460|             } else if ("class".equals(att.getNodeName())) {
   461|                 clazz = value;
   462|             }
   463|         }
   464|         if (!enabled || clazz == null) {
   465|             return;
   466|         }
   467|         Map<String, Comparable> properties = new HashMap<String, Comparable>();
   468|         for (Node child : childElements(node)) {
   469|             String name = cleanNodeName(child);
   470|             if ("properties".equals(name)) {
   471|                 fillProperties(child, properties);
   472|             }
   473|         }
   474|         discoveryConfig.addDiscoveryStrategyConfig(new DiscoveryStrategyConfig(clazz, properties));
   475|     }
   476|     private void handleAWS(Node node, ClientNetworkConfig clientNetworkConfig) {
   477|         ClientAwsConfig clientAwsConfig = handleAwsAttributes(node);
   478|         for (Node n : childElements(node)) {
   479|             String value = getTextContent(n).trim();
   480|             if ("secret-key".equals(cleanNodeName(n))) {
   481|                 clientAwsConfig.setSecretKey(value);
   482|             } else if ("access-key".equals(cleanNodeName(n))) {
   483|                 clientAwsConfig.setAccessKey(value);
   484|             } else if ("region".equals(cleanNodeName(n))) {
   485|                 clientAwsConfig.setRegion(value);
   486|             } else if ("host-header".equals(cleanNodeName(n))) {
   487|                 clientAwsConfig.setHostHeader(value);
   488|             } else if ("security-group-name".equals(cleanNodeName(n))) {
   489|                 clientAwsConfig.setSecurityGroupName(value);
   490|             } else if ("tag-key".equals(cleanNodeName(n))) {
   491|                 clientAwsConfig.setTagKey(value);
   492|             } else if ("tag-value".equals(cleanNodeName(n))) {
   493|                 clientAwsConfig.setTagValue(value);
   494|             } else if ("inside-aws".equals(cleanNodeName(n))) {
   495|                 clientAwsConfig.setInsideAws(getBooleanValue(value));
   496|             } else if ("iam-role".equals(cleanNodeName(n))) {
   497|                 clientAwsConfig.setIamRole(value);
   498|             }
   499|         }
   500|         if (!clientAwsConfig.isInsideAws() && clientAwsConfig.getIamRole() != null) {
   501|             throw new InvalidConfigurationException("You cannot set IAM Role from outside EC2");
   502|         }
   503|         clientNetworkConfig.setAwsConfig(clientAwsConfig);
   504|     }
   505|     private ClientAwsConfig handleAwsAttributes(Node node) {
   506|         NamedNodeMap atts = node.getAttributes();
   507|         ClientAwsConfig clientAwsConfig = new ClientAwsConfig();
   508|         for (int i = 0; i < atts.getLength(); i++) {
   509|             Node att = atts.item(i);
   510|             String value = getTextContent(att).trim();
   511|             if ("enabled".equalsIgnoreCase(att.getNodeName())) {
   512|                 clientAwsConfig.setEnabled(getBooleanValue(value));
   513|             } else if (att.getNodeName().equals("connection-timeout-seconds")) {
   514|                 int timeout = getIntegerValue("connection-timeout-seconds", value);
   515|                 clientAwsConfig.setConnectionTimeoutSeconds(timeout);
   516|             }
   517|         }
   518|         return clientAwsConfig;
   519|     }
   520|     private void handleSSLConfig(Node node, ClientNetworkConfig clientNetworkConfig) {
   521|         SSLConfig sslConfig = new SSLConfig();
   522|         NamedNodeMap atts = node.getAttributes();
   523|         Node enabledNode = atts.getNamedItem("enabled");
   524|         boolean enabled = enabledNode != null && getBooleanValue(getTextContent(enabledNode).trim());
   525|         sslConfig.setEnabled(enabled);
   526|         for (Node n : childElements(node)) {
   527|             String nodeName = cleanNodeName(n);
   528|             if ("factory-class-name".equals(nodeName)) {
   529|                 sslConfig.setFactoryClassName(getTextContent(n).trim());
   530|             } else if ("properties".equals(nodeName)) {
   531|                 fillProperties(n, sslConfig.getProperties());
   532|             }
   533|         }
   534|         clientNetworkConfig.setSSLConfig(sslConfig);
   535|     }
   536|     private void handleSocketOptions(Node node, ClientNetworkConfig clientNetworkConfig) {
   537|         SocketOptions socketOptions = clientConfig.getSocketOptions();
   538|         for (Node child : childElements(node)) {

# --- HUNK 6: Lines 589-622 ---
   589|             }
   590|         }
   591|     }
   592|     private void handleProxyFactory(Node node) throws Exception {
   593|         String service = getAttribute(node, "service");
   594|         String className = getAttribute(node, "class-name");
   595|         ProxyFactoryConfig proxyFactoryConfig = new ProxyFactoryConfig(className, service);
   596|         clientConfig.addProxyFactoryConfig(proxyFactoryConfig);
   597|     }
   598|     private void handleSocketInterceptorConfig(Node node, ClientNetworkConfig clientNetworkConfig) {
   599|         SocketInterceptorConfig socketInterceptorConfig = parseSocketInterceptorConfig(node);
   600|         clientNetworkConfig.setSocketInterceptorConfig(socketInterceptorConfig);
   601|     }
   602|     private void handleSecurity(Node node) throws Exception {
   603|         ClientSecurityConfig clientSecurityConfig = new ClientSecurityConfig();
   604|         for (Node child : childElements(node)) {
   605|             String nodeName = cleanNodeName(child);
   606|             if ("credentials".equals(nodeName)) {
   607|                 String className = getTextContent(child);
   608|                 clientSecurityConfig.setCredentialsClassname(className);
   609|             }
   610|         }
   611|         clientConfig.setSecurityConfig(clientSecurityConfig);
   612|     }
   613|     private void handleOutboundPorts(Node child, ClientNetworkConfig clientNetworkConfig) {
   614|         for (Node n : childElements(child)) {
   615|             String nodeName = cleanNodeName(n);
   616|             if ("ports".equals(nodeName)) {
   617|                 String value = getTextContent(n);
   618|                 clientNetworkConfig.addOutboundPortDefinition(value);
   619|             }
   620|         }
   621|     }
   622| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/connection/ClientConnectionManager.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-61 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.connection;
    17| import com.hazelcast.client.connection.nio.ClientConnection;
    18| import com.hazelcast.client.impl.client.ClientPrincipal;
    19| import com.hazelcast.client.spi.impl.ConnectionHeartbeatListener;
    20| import com.hazelcast.nio.Address;
    21| import com.hazelcast.nio.Connection;
    22| import com.hazelcast.nio.ConnectionListenable;
    23| import java.io.IOException;
    24| import java.util.Collection;
    25| import java.util.concurrent.Future;
    26| /**
    27|  * Responsible for managing {@link com.hazelcast.client.connection.nio.ClientConnection} objects.
    28|  */
    29| public interface ClientConnectionManager extends ConnectionListenable {
    30|     /**
    31|      * Check if client connection manager is alive.
    32|      * ClientConnectionManager is not alive only when client is closing.
    33|      *
    34|      * @return true if alive, false otherwise.
    35|      */
    36|     boolean isAlive();
    37|     /**
    38|      * @param address to be connected
    39|      * @return connection if available, null otherwise
    40|      */
    41|     Connection getActiveConnection(Address address);
    42|     /**
    43|      * @param address to be connected
    44|      * @return associated connection if available, creates new connection otherwise
    45|      * @throws IOException if connection is not established
    46|      */
    47|     Connection getOrConnect(Address address) throws IOException;
    48|     /**
    49|      * @param address to be connected
    50|      * @return associated connection if available, returns null and triggers new connection creation otherwise
    51|      * @throws IOException if connection is not able to triggered
    52|      */
    53|     Connection getOrTriggerConnect(Address address, boolean acquiresResource) throws IOException;
    54|     void addConnectionHeartbeatListener(ConnectionHeartbeatListener connectionHeartbeatListener);
    55|     Collection<ClientConnection> getActiveConnections();
    56|     Address getOwnerConnectionAddress();
    57|     ClientPrincipal getPrincipal();
    58|     ClientConnection getOwnerConnection();
    59|     void connectToCluster();
    60|     Future<Void> connectToClusterAsync();
    61| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/connection/ClientConnectionStrategy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 52-105 ---
    52|      * The build in retry mechanism can be stopped by throwing an instance of non retryable exceptions;
    53|      * {@link java.io.IOException}, {@link com.hazelcast.core.HazelcastInstanceNotActiveException} or
    54|      * {@link com.hazelcast.spi.exception.RetryableException}
    55|      *
    56|      * The thrown exception will be received on the blocking user. Any blocking invocation will exit by that exception.
    57|      * @param target address of the requested connection
    58|      */
    59|     public abstract void beforeGetConnection(Address target);
    60|     /**
    61|      * If a new connection is required to open by {@link ClientConnectionManager},
    62|      * this method will be called.
    63|      *
    64|      * This request can be rejected by throwing an instance of non retryable exceptions;
    65|      * {@link java.io.IOException}, {@link com.hazelcast.core.HazelcastInstanceNotActiveException} or
    66|      * {@link com.hazelcast.spi.exception.RetryableException}
    67|      * @param target address of the requested connection
    68|      */
    69|     public abstract void beforeOpenConnection(Address target);
    70|     /**
    71|      * If a cluster connection is established, this method will be called.
    72|      * if an exception is thrown, the already established connection will be closed.
    73|      */
    74|     public abstract void onConnectToCluster();
    75|     /**
    76|      * If the cluster connection is lost for any reason, this method will be called.
    77|      *
    78|      */
    79|     public abstract void onDisconnectFromCluster();
    80|     /**
    81|      * If the {@link ClientConnectionManager} opens a new connection to a member,
    82|      * this method will be called with the connection parameter
    83|      * @param connection the new established connection
    84|      */
    85|     public abstract void onConnect(ClientConnection connection);
    86|     /**
    87|      * If a connection is disconnected, this method will be called with the connection parameter
    88|      * @param connection the closed connection
    89|      */
    90|     public abstract void onDisconnect(ClientConnection connection);
    91|     /**
    92|      * The {@link ClientConnectionManager} will inform this method that the provided connection's heartbeat stopped
    93|      * @param connection the connection that heartbeat failed
    94|      */
    95|     public abstract void onHeartbeatStopped(ClientConnection connection);
    96|     /**
    97|      * The {@link ClientConnectionManager} will inform this method that the provided connection's heartbeat resumed
    98|      * @param connection the connection that heartbeat resumed
    99|      */
   100|     public abstract void onHeartbeatResumed(ClientConnection connection);
   101|     /**
   102|      * The {@link ClientConnectionManager} will call this method as a last step of its shutdown.
   103|      */
   104|     public abstract void shutdown();
   105| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/ClientChannelInitializer.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-62 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.connection.nio;
    17| import com.hazelcast.client.impl.protocol.ClientMessage;
    18| import com.hazelcast.client.impl.protocol.util.ClientMessageDecoder;
    19| import com.hazelcast.client.impl.protocol.util.ClientMessageEncoder;
    20| import com.hazelcast.client.impl.protocol.util.ClientMessageHandler;
    21| import com.hazelcast.internal.networking.Channel;
    22| import com.hazelcast.internal.networking.ChannelInboundHandler;
    23| import com.hazelcast.internal.networking.ChannelInitializer;
    24| import com.hazelcast.internal.networking.ChannelOutboundHandler;
    25| import com.hazelcast.internal.networking.InitResult;
    26| import com.hazelcast.nio.Connection;
    27| import java.nio.ByteBuffer;
    28| import static com.hazelcast.nio.IOUtil.newByteBuffer;
    29| import static com.hazelcast.nio.Protocols.CLIENT_BINARY_NEW;
    30| import static com.hazelcast.util.StringUtil.stringToBytes;
    31| /**
    32|  * Client side ChannelInitializer. Client in this case is a real client using client protocol etc.
    33|  *
    34|  * It will automatically send the Client Protocol to the server and configure the correct buffers/handlers.
    35|  */
    36| class ClientChannelInitializer implements ChannelInitializer {
    37|     private final int bufferSize;
    38|     private final boolean direct;
    39|     ClientChannelInitializer(int bufferSize, boolean direct) {
    40|         this.bufferSize = bufferSize;
    41|         this.direct = direct;
    42|     }
    43|     @Override
    44|     public InitResult<ChannelInboundHandler> initInbound(final Channel channel) {
    45|         ByteBuffer inputBuffer = newByteBuffer(bufferSize, direct);
    46|         final ClientConnection clientConnection = (ClientConnection) channel.attributeMap().get(ClientConnection.class);
    47|         ChannelInboundHandler inboundHandler = new ClientMessageDecoder(clientConnection,
    48|                 new ClientMessageHandler() {
    49|                     @Override
    50|                     public void handle(ClientMessage message, Connection connection) {
    51|                         clientConnection.handleClientMessage(message);
    52|                     }
    53|                 });
    54|         return new InitResult<ChannelInboundHandler>(inputBuffer, inboundHandler);
    55|     }
    56|     @Override
    57|     public InitResult<ChannelOutboundHandler> initOutbound(Channel channel) {
    58|         ByteBuffer outputBuffer = newByteBuffer(bufferSize, direct);
    59|         outputBuffer.put(stringToBytes(CLIENT_BINARY_NEW));
    60|         return new InitResult<ChannelOutboundHandler>(outputBuffer, new ClientMessageEncoder());
    61|     }
    62| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/ClientConnection.java
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 1-115 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.connection.nio;
    17| import com.hazelcast.client.connection.ClientConnectionManager;
    18| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    19| import com.hazelcast.client.impl.protocol.ClientMessage;
    20| import com.hazelcast.client.spi.impl.ClientResponseHandler;
    21| import com.hazelcast.client.spi.impl.listener.AbstractClientListenerService;
    22| import com.hazelcast.core.LifecycleService;
    23| import com.hazelcast.instance.BuildInfo;
    24| import com.hazelcast.internal.metrics.Probe;
    25| import com.hazelcast.internal.metrics.ProbeLevel;
    26| import com.hazelcast.internal.networking.Channel;
    27| import com.hazelcast.internal.networking.OutboundFrame;
    28| import com.hazelcast.logging.ILogger;
    29| import com.hazelcast.nio.Address;
    30| import com.hazelcast.nio.Connection;
    31| import com.hazelcast.nio.ConnectionType;
    32| import com.hazelcast.util.Clock;
    33| import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
    34| import java.io.EOFException;
    35| import java.io.IOException;
    36| import java.net.InetAddress;
    37| import java.net.InetSocketAddress;
    38| import java.nio.channels.CancelledKeyException;
    39| import java.util.concurrent.atomic.AtomicInteger;
    40| import java.util.concurrent.atomic.AtomicLong;
    41| import static com.hazelcast.util.StringUtil.timeToStringFriendly;
    42| /**
    43|  * Client implementation of {@link Connection}.
    44|  * ClientConnection is a connection between a Hazelcast Client and a Hazelcast Member.
    45|  */
    46| public class ClientConnection implements Connection {
    47|     @Probe
    48|     private final int connectionId;
    49|     private final ILogger logger;
    50|     private final AtomicInteger pendingPacketCount = new AtomicInteger(0);
    51|     private final Channel channel;
    52|     private final ClientConnectionManagerImpl connectionManager;
    53|     private final LifecycleService lifecycleService;
    54|     private final HazelcastClientInstanceImpl client;
    55|     private final long startTime = System.currentTimeMillis();
    56|     private final ClientResponseHandler responseHandler;
    57|     private volatile Address remoteEndpoint;
    58|     private volatile boolean isHeartBeating = true;
    59|     private volatile long lastHeartbeatRequestedMillis;
    60|     private volatile long lastHeartbeatReceivedMillis;
    61|     private volatile boolean isAuthenticatedAsOwner;
    62|     @Probe(level = ProbeLevel.DEBUG)
    63|     private final AtomicLong closedTime = new AtomicLong();
    64|     private volatile Throwable closeCause;
    65|     private volatile String closeReason;
    66|     private int connectedServerVersion = BuildInfo.UNKNOWN_HAZELCAST_VERSION;
    67|     private String connectedServerVersionString;
    68|     public ClientConnection(HazelcastClientInstanceImpl client, int connectionId, Channel channel) {
    69|         this.client = client;
    70|         this.responseHandler = client.getInvocationService().getResponseHandler();
    71|         this.connectionManager = (ClientConnectionManagerImpl) client.getConnectionManager();
    72|         this.lifecycleService = client.getLifecycleService();
    73|         this.channel = channel;
    74|         channel.attributeMap().put(ClientConnection.class, this);
    75|         this.connectionId = connectionId;
    76|         this.logger = client.getLoggingService().getLogger(ClientConnection.class);
    77|     }
    78|     public ClientConnection(HazelcastClientInstanceImpl client, int connectionId) {
    79|         this.client = client;
    80|         this.responseHandler = client.getInvocationService().getResponseHandler();
    81|         this.connectionManager = (ClientConnectionManagerImpl) client.getConnectionManager();
    82|         this.lifecycleService = client.getLifecycleService();
    83|         this.connectionId = connectionId;
    84|         this.channel = null;
    85|         this.logger = client.getLoggingService().getLogger(ClientConnection.class);
    86|     }
    87|     public void incrementPendingPacketCount() {
    88|         pendingPacketCount.incrementAndGet();
    89|     }
    90|     public void decrementPendingPacketCount() {
    91|         pendingPacketCount.decrementAndGet();
    92|     }
    93|     public int getPendingPacketCount() {
    94|         return pendingPacketCount.get();
    95|     }
    96|     @Override
    97|     public boolean write(OutboundFrame frame) {
    98|         if (channel.write(frame)) {
    99|             return true;
   100|         }
   101|         if (logger.isFinestEnabled()) {
   102|             logger.finest("Connection is closed, dropping frame -> " + frame);
   103|         }
   104|         return false;
   105|     }
   106|     @Override
   107|     public Address getEndPoint() {
   108|         return remoteEndpoint;
   109|     }
   110|     @Override
   111|     public boolean isAlive() {
   112|         return closedTime.get() == 0;
   113|     }
   114|     @Override
   115|     public long lastReadTimeMillis() {

# --- HUNK 2: Lines 189-290 ---
   189|                 logger.finest(message, closeCause);
   190|             }
   191|         }
   192|     }
   193|     protected void innerClose() throws IOException {
   194|         channel.close();
   195|     }
   196|     @Override
   197|     public Throwable getCloseCause() {
   198|         return closeCause;
   199|     }
   200|     @Override
   201|     public String getCloseReason() {
   202|         if (closeReason == null) {
   203|             return closeCause == null ? null : closeCause.getMessage();
   204|         } else {
   205|             return closeReason;
   206|         }
   207|     }
   208|     public void handleClientMessage(ClientMessage message) {
   209|         incrementPendingPacketCount();
   210|         if (message.isFlagSet(ClientMessage.LISTENER_EVENT_FLAG)) {
   211|             AbstractClientListenerService listenerService = (AbstractClientListenerService) client.getListenerService();
   212|             listenerService.handleClientMessage(message, this);
   213|         } else {
   214|             responseHandler.handle(message, this);
   215|         }
   216|     }
   217|     @SuppressFBWarnings(value = "VO_VOLATILE_INCREMENT", justification = "incremented in single thread")
   218|     void onHeartbeatFailed() {
   219|         isHeartBeating = false;
   220|     }
   221|     void onHeartbeatResumed() {
   222|         isHeartBeating = true;
   223|     }
   224|     void onHeartbeatReceived() {
   225|         lastHeartbeatReceivedMillis = Clock.currentTimeMillis();
   226|     }
   227|     void onHeartbeatRequested() {
   228|         lastHeartbeatRequestedMillis = Clock.currentTimeMillis();
   229|     }
   230|     public boolean isHeartBeating() {
   231|         return isAlive() && isHeartBeating;
   232|     }
   233|     public boolean isAuthenticatedAsOwner() {
   234|         return isAuthenticatedAsOwner;
   235|     }
   236|     public void setIsAuthenticatedAsOwner() {
   237|         this.isAuthenticatedAsOwner = true;
   238|     }
   239|     public long getStartTime() {
   240|         return startTime;
   241|     }
   242|     @Override
   243|     public boolean equals(Object o) {
   244|         if (this == o) {
   245|             return true;
   246|         }
   247|         if (!(o instanceof ClientConnection)) {
   248|             return false;
   249|         }
   250|         ClientConnection that = (ClientConnection) o;
   251|         return connectionId == that.connectionId;
   252|     }
   253|     @Override
   254|     public int hashCode() {
   255|         return connectionId;
   256|     }
   257|     @Override
   258|     public String toString() {
   259|         return "ClientConnection{"
   260|                 + "alive=" + isAlive()
   261|                 + ", connectionId=" + connectionId
   262|                 + ", channel=" + channel
   263|                 + ", remoteEndpoint=" + remoteEndpoint
   264|                 + ", lastReadTime=" + timeToStringFriendly(lastReadTimeMillis())
   265|                 + ", lastWriteTime=" + timeToStringFriendly(lastWriteTimeMillis())
   266|                 + ", closedTime=" + timeToStringFriendly(closedTime.get())
   267|                 + ", lastHeartbeatRequested=" + timeToStringFriendly(lastHeartbeatRequestedMillis)
   268|                 + ", lastHeartbeatReceived=" + timeToStringFriendly(lastHeartbeatReceivedMillis)
   269|                 + ", connected server version=" + connectedServerVersionString
   270|                 + '}';
   271|     }
   272|     /**
   273|      * Closed time is the first time connection.close called.
   274|      *
   275|      * @return the closed time of connection, returns zero if not closed yet
   276|      */
   277|     public long getClosedTime() {
   278|         return closedTime.get();
   279|     }
   280|     public void setConnectedServerVersion(String connectedServerVersion) {
   281|         this.connectedServerVersionString = connectedServerVersion;
   282|         this.connectedServerVersion = BuildInfo.calculateVersion(connectedServerVersion);
   283|     }
   284|     public int getConnectedServerVersion() {
   285|         return connectedServerVersion;
   286|     }
   287|     public String getConnectedServerVersionString() {
   288|         return connectedServerVersionString;
   289|     }
   290| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/ClientConnectionManagerImpl.java
# Total hunks: 9
# ====================================================================
# --- HUNK 1: Lines 1-306 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.connection.nio;
    17| import com.hazelcast.client.AuthenticationException;
    18| import com.hazelcast.client.ClientExtension;
    19| import com.hazelcast.client.ClientTypes;
    20| import com.hazelcast.client.HazelcastClientNotActiveException;
    21| import com.hazelcast.client.HazelcastClientOfflineException;
    22| import com.hazelcast.client.config.ClientNetworkConfig;
    23| import com.hazelcast.client.config.SocketOptions;
    24| import com.hazelcast.client.connection.AddressProvider;
    25| import com.hazelcast.client.connection.AddressTranslator;
    26| import com.hazelcast.client.connection.ClientConnectionManager;
    27| import com.hazelcast.client.connection.ClientConnectionStrategy;
    28| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    29| import com.hazelcast.client.impl.LifecycleServiceImpl;
    30| import com.hazelcast.client.impl.client.ClientPrincipal;
    31| import com.hazelcast.client.impl.protocol.AuthenticationStatus;
    32| import com.hazelcast.client.impl.protocol.ClientMessage;
    33| import com.hazelcast.client.impl.protocol.codec.ClientAuthenticationCodec;
    34| import com.hazelcast.client.impl.protocol.codec.ClientAuthenticationCustomCodec;
    35| import com.hazelcast.client.spi.ClientContext;
    36| import com.hazelcast.client.spi.impl.ClientExecutionServiceImpl;
    37| import com.hazelcast.client.spi.impl.ClientInvocation;
    38| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    39| import com.hazelcast.client.spi.impl.ConnectionHeartbeatListener;
    40| import com.hazelcast.config.SSLConfig;
    41| import com.hazelcast.config.SocketInterceptorConfig;
    42| import com.hazelcast.core.ExecutionCallback;
    43| import com.hazelcast.core.HazelcastException;
    44| import com.hazelcast.core.LifecycleEvent;
    45| import com.hazelcast.core.Member;
    46| import com.hazelcast.instance.BuildInfoProvider;
    47| import com.hazelcast.internal.networking.Channel;
    48| import com.hazelcast.internal.networking.ChannelErrorHandler;
    49| import com.hazelcast.internal.networking.ChannelFactory;
    50| import com.hazelcast.internal.networking.nio.NioEventLoopGroup;
    51| import com.hazelcast.internal.serialization.InternalSerializationService;
    52| import com.hazelcast.logging.ILogger;
    53| import com.hazelcast.nio.Address;
    54| import com.hazelcast.nio.ClassLoaderUtil;
    55| import com.hazelcast.nio.Connection;
    56| import com.hazelcast.nio.ConnectionListener;
    57| import com.hazelcast.nio.SocketInterceptor;
    58| import com.hazelcast.nio.serialization.Data;
    59| import com.hazelcast.security.Credentials;
    60| import com.hazelcast.security.UsernamePasswordCredentials;
    61| import com.hazelcast.spi.properties.HazelcastProperties;
    62| import com.hazelcast.spi.serialization.SerializationService;
    63| import com.hazelcast.util.AddressUtil;
    64| import com.hazelcast.util.Clock;
    65| import com.hazelcast.util.executor.SingleExecutorThreadFactory;
    66| import java.io.EOFException;
    67| import java.io.IOException;
    68| import java.net.InetSocketAddress;
    69| import java.net.Socket;
    70| import java.net.SocketAddress;
    71| import java.nio.channels.SocketChannel;
    72| import java.util.ArrayList;
    73| import java.util.Collection;
    74| import java.util.Collections;
    75| import java.util.HashSet;
    76| import java.util.LinkedHashSet;
    77| import java.util.LinkedList;
    78| import java.util.List;
    79| import java.util.Set;
    80| import java.util.concurrent.Callable;
    81| import java.util.concurrent.ConcurrentHashMap;
    82| import java.util.concurrent.ConcurrentMap;
    83| import java.util.concurrent.ExecutorService;
    84| import java.util.concurrent.Executors;
    85| import java.util.concurrent.CopyOnWriteArrayList;
    86| import java.util.concurrent.Future;
    87| import java.util.concurrent.ScheduledFuture;
    88| import java.util.concurrent.TimeoutException;
    89| import java.util.concurrent.atomic.AtomicInteger;
    90| import static com.hazelcast.client.config.SocketOptions.DEFAULT_BUFFER_SIZE_BYTE;
    91| import static com.hazelcast.client.config.SocketOptions.KILO_BYTE;
    92| import static com.hazelcast.client.spi.properties.ClientProperty.ALLOW_INVOCATIONS_WHEN_DISCONNECTED;
    93| import static com.hazelcast.client.spi.properties.ClientProperty.IO_BALANCER_INTERVAL_SECONDS;
    94| import static com.hazelcast.client.spi.properties.ClientProperty.IO_INPUT_THREAD_COUNT;
    95| import static com.hazelcast.client.spi.properties.ClientProperty.IO_OUTPUT_THREAD_COUNT;
    96| import static com.hazelcast.client.spi.properties.ClientProperty.SHUFFLE_MEMBER_LIST;
    97| import static com.hazelcast.spi.properties.GroupProperty.SOCKET_CLIENT_BUFFER_DIRECT;
    98| import static com.hazelcast.util.ExceptionUtil.rethrow;
    99| import static java.util.concurrent.TimeUnit.MILLISECONDS;
   100| /**
   101|  * Implementation of {@link ClientConnectionManager}.
   102|  */
   103| @SuppressWarnings("checkstyle:classdataabstractioncoupling")
   104| public class ClientConnectionManagerImpl implements ClientConnectionManager, ConnectionHeartbeatListener {
   105|     private static final int DEFAULT_SSL_THREAD_COUNT = 3;
   106|     private static final int DEFAULT_CONNECTION_ATTEMPT_LIMIT_SYNC = 2;
   107|     private static final int DEFAULT_CONNECTION_ATTEMPT_LIMIT_ASYNC = 20;
   108|     protected final AtomicInteger connectionIdGen = new AtomicInteger();
   109|     protected volatile boolean alive;
   110|     private final ILogger logger;
   111|     private final int connectionTimeoutMillis;
   112|     private final HazelcastClientInstanceImpl client;
   113|     private final SocketInterceptor socketInterceptor;
   114|     private final SocketOptions socketOptions;
   115|     private final ChannelFactory channelFactory;
   116|     private final ClientExecutionServiceImpl executionService;
   117|     private final AddressTranslator addressTranslator;
   118|     private final ConcurrentMap<Address, ClientConnection> activeConnections
   119|             = new ConcurrentHashMap<Address, ClientConnection>();
   120|     private final ConcurrentMap<Address, AuthenticationFuture> connectionsInProgress =
   121|             new ConcurrentHashMap<Address, AuthenticationFuture>();
   122|     private final Collection<ConnectionListener> connectionListeners = new CopyOnWriteArrayList<ConnectionListener>();
   123|     private final boolean allowInvokeWhenDisconnected;
   124|     private final Credentials credentials;
   125|     private final NioEventLoopGroup eventLoopGroup;
   126|     private volatile Address ownerConnectionAddress;
   127|     private volatile Address previousOwnerConnectionAddress;
   128|     private final HeartbeatManager heartbeat;
   129|     private final long authenticationTimeout;
   130|     private volatile ClientPrincipal principal;
   131|     private final ClientConnectionStrategy connectionStrategy;
   132|     private final ExecutorService clusterConnectionExecutor;
   133|     private final int connectionAttemptPeriod;
   134|     private final int connectionAttemptLimit;
   135|     private final boolean shuffleMemberList;
   136|     private final Collection<AddressProvider> addressProviders;
   137|     private final LinkedList<Integer> outboundPorts = new LinkedList<Integer>();
   138|     private final int outboundPortCount;
   139|     @SuppressWarnings("checkstyle:executablestatementcount")
   140|     public ClientConnectionManagerImpl(HazelcastClientInstanceImpl client, AddressTranslator addressTranslator,
   141|                                        Collection<AddressProvider> addressProviders) {
   142|         allowInvokeWhenDisconnected = client.getProperties().getBoolean(ALLOW_INVOCATIONS_WHEN_DISCONNECTED);
   143|         this.client = client;
   144|         this.addressTranslator = addressTranslator;
   145|         this.logger = client.getLoggingService().getLogger(ClientConnectionManager.class);
   146|         ClientNetworkConfig networkConfig = client.getClientConfig().getNetworkConfig();
   147|         final int connTimeout = networkConfig.getConnectionTimeout();
   148|         this.connectionTimeoutMillis = connTimeout == 0 ? Integer.MAX_VALUE : connTimeout;
   149|         this.executionService = (ClientExecutionServiceImpl) client.getClientExecutionService();
   150|         this.socketOptions = networkConfig.getSocketOptions();
   151|         this.eventLoopGroup = initEventLoopGroup(client);
   152|         this.channelFactory = client.getClientExtension().createSocketChannelWrapperFactory();
   153|         this.socketInterceptor = initSocketInterceptor(networkConfig.getSocketInterceptorConfig());
   154|         this.credentials = client.getCredentials();
   155|         this.connectionStrategy = initializeStrategy(client);
   156|         this.clusterConnectionExecutor = createSingleThreadExecutorService(client);
   157|         this.shuffleMemberList = client.getProperties().getBoolean(SHUFFLE_MEMBER_LIST);
   158|         this.addressProviders = addressProviders;
   159|         this.connectionAttemptPeriod = networkConfig.getConnectionAttemptPeriod();
   160|         int connAttemptLimit = networkConfig.getConnectionAttemptLimit();
   161|         boolean isAsync = client.getClientConfig().getConnectionStrategyConfig().isAsyncStart();
   162|         if (connAttemptLimit < 0) {
   163|             this.connectionAttemptLimit = isAsync ? DEFAULT_CONNECTION_ATTEMPT_LIMIT_ASYNC
   164|                     : DEFAULT_CONNECTION_ATTEMPT_LIMIT_SYNC;
   165|         } else {
   166|             this.connectionAttemptLimit = connAttemptLimit == 0 ? Integer.MAX_VALUE : connAttemptLimit;
   167|         }
   168|         this.outboundPorts.addAll(getOutboundPorts(networkConfig));
   169|         this.outboundPortCount = outboundPorts.size();
   170|         this.heartbeat = new HeartbeatManager(this, client);
   171|         this.authenticationTimeout = heartbeat.getHeartbeatTimeout();
   172|         checkSslAllowed();
   173|     }
   174|     private void checkSslAllowed() {
   175|         SSLConfig sslConfig = client.getClientConfig().getNetworkConfig().getSSLConfig();
   176|         if (sslConfig != null && sslConfig.isEnabled()) {
   177|             if (!BuildInfoProvider.getBuildInfo().isEnterprise()) {
   178|                 throw new IllegalStateException("SSL/TLS requires Hazelcast Enterprise Edition");
   179|             }
   180|         }
   181|     }
   182|     private Collection<Integer> getOutboundPorts(ClientNetworkConfig networkConfig) {
   183|         Collection<Integer> outboundPorts = networkConfig.getOutboundPorts();
   184|         Collection<String> outboundPortDefinitions = networkConfig.getOutboundPortDefinitions();
   185|         return AddressUtil.getOutboundPorts(outboundPorts, outboundPortDefinitions);
   186|     }
   187|     private ClientConnectionStrategy initializeStrategy(HazelcastClientInstanceImpl client) {
   188|         ClientConnectionStrategy strategy;
   189|         String className = client.getProperties().get("hazelcast.client.connection.strategy.classname");
   190|         if (className != null) {
   191|             try {
   192|                 ClassLoader configClassLoader = client.getClientConfig().getClassLoader();
   193|                 return ClassLoaderUtil.newInstance(configClassLoader, className);
   194|             } catch (Exception e) {
   195|                 throw rethrow(e);
   196|             }
   197|         } else {
   198|             strategy = new DefaultClientConnectionStrategy();
   199|         }
   200|         return strategy;
   201|     }
   202|     public NioEventLoopGroup getEventLoopGroup() {
   203|         return eventLoopGroup;
   204|     }
   205|     protected NioEventLoopGroup initEventLoopGroup(HazelcastClientInstanceImpl client) {
   206|         HazelcastProperties properties = client.getProperties();
   207|         boolean directBuffer = properties.getBoolean(SOCKET_CLIENT_BUFFER_DIRECT);
   208|         SSLConfig sslConfig = client.getClientConfig().getNetworkConfig().getSSLConfig();
   209|         boolean sslEnabled = sslConfig != null && sslConfig.isEnabled();
   210|         int configuredInputThreads = properties.getInteger(IO_INPUT_THREAD_COUNT);
   211|         int configuredOutputThreads = properties.getInteger(IO_OUTPUT_THREAD_COUNT);
   212|         int inputThreads;
   213|         if (configuredInputThreads == -1) {
   214|             inputThreads = sslEnabled ? DEFAULT_SSL_THREAD_COUNT : 1;
   215|         } else {
   216|             inputThreads = configuredInputThreads;
   217|         }
   218|         int outputThreads;
   219|         if (configuredOutputThreads == -1) {
   220|             outputThreads = sslEnabled ? DEFAULT_SSL_THREAD_COUNT : 1;
   221|         } else {
   222|             outputThreads = configuredOutputThreads;
   223|         }
   224|         return new NioEventLoopGroup(
   225|                 new NioEventLoopGroup.Context()
   226|                         .loggingService(client.getLoggingService())
   227|                         .metricsRegistry(client.getMetricsRegistry())
   228|                         .threadNamePrefix(client.getName())
   229|                         .errorHandler(new ClientConnectionChannelErrorHandler())
   230|                         .inputThreadCount(inputThreads)
   231|                         .outputThreadCount(outputThreads)
   232|                         .balancerIntervalSeconds(properties.getInteger(IO_BALANCER_INTERVAL_SECONDS))
   233|                         .channelInitializer(new ClientChannelInitializer(getBufferSize(), directBuffer)));
   234|     }
   235|     private SocketInterceptor initSocketInterceptor(SocketInterceptorConfig sic) {
   236|         if (sic != null && sic.isEnabled()) {
   237|             ClientExtension clientExtension = client.getClientExtension();
   238|             return clientExtension.createSocketInterceptor();
   239|         }
   240|         return null;
   241|     }
   242|     @Override
   243|     public Collection<ClientConnection> getActiveConnections() {
   244|         return activeConnections.values();
   245|     }
   246|     @Override
   247|     public boolean isAlive() {
   248|         return alive;
   249|     }
   250|     public synchronized void start(ClientContext clientContext) {
   251|         if (alive) {
   252|             return;
   253|         }
   254|         alive = true;
   255|         startEventLoopGroup();
   256|         heartbeat.start();
   257|         addConnectionHeartbeatListener(this);
   258|         connectionStrategy.init(clientContext);
   259|         connectionStrategy.start();
   260|     }
   261|     protected void startEventLoopGroup() {
   262|         eventLoopGroup.start();
   263|     }
   264|     public synchronized void shutdown() {
   265|         if (!alive) {
   266|             return;
   267|         }
   268|         alive = false;
   269|         for (Connection connection : activeConnections.values()) {
   270|             connection.close("Hazelcast client is shutting down", null);
   271|         }
   272|         ClientExecutionServiceImpl.shutdownExecutor("cluster", clusterConnectionExecutor, logger);
   273|         stopEventLoopGroup();
   274|         connectionListeners.clear();
   275|         heartbeat.shutdown();
   276|         connectionStrategy.shutdown();
   277|     }
   278|     @Override
   279|     public ClientPrincipal getPrincipal() {
   280|         return principal;
   281|     }
   282|     private void setPrincipal(ClientPrincipal principal) {
   283|         this.principal = principal;
   284|     }
   285|     protected void stopEventLoopGroup() {
   286|         eventLoopGroup.shutdown();
   287|     }
   288|     @Override
   289|     public Connection getActiveConnection(Address target) {
   290|         if (target == null) {
   291|             return null;
   292|         }
   293|         return activeConnections.get(target);
   294|     }
   295|     @Override
   296|     public Connection getOrConnect(Address address) throws IOException {
   297|         return getOrConnect(address, false);
   298|     }
   299|     @Override
   300|     public Connection getOrTriggerConnect(Address target, boolean acquiresResources) throws IOException {
   301|         Connection connection = getConnection(target, false, acquiresResources);
   302|         if (connection != null) {
   303|             return connection;
   304|         }
   305|         triggerConnect(target, false);
   306|         return null;

# --- HUNK 2: Lines 309-591 ---
   309|         checkAllowed(target, asOwner, acquiresResources);
   310|         if (target == null) {
   311|             throw new IllegalStateException("Address can not be null");
   312|         }
   313|         ClientConnection connection = activeConnections.get(target);
   314|         if (connection != null) {
   315|             if (!asOwner) {
   316|                 return connection;
   317|             }
   318|             if (connection.isAuthenticatedAsOwner()) {
   319|                 return connection;
   320|             }
   321|         }
   322|         return null;
   323|     }
   324|     private void checkAllowed(Address target, boolean asOwner, boolean acquiresResources) throws IOException {
   325|         if (!alive) {
   326|             throw new HazelcastClientNotActiveException("ConnectionManager is not active!");
   327|         }
   328|         if (asOwner) {
   329|             return;
   330|         }
   331|         try {
   332|             connectionStrategy.beforeGetConnection(target);
   333|         } catch (HazelcastClientOfflineException e) {
   334|             if (allowInvokeWhenDisconnected && !acquiresResources) {
   335|                 return;
   336|             }
   337|             throw e;
   338|         }
   339|         if (getOwnerConnection() == null) {
   340|             if (allowInvokeWhenDisconnected && !acquiresResources) {
   341|                 return;
   342|             }
   343|             throw new IOException("Owner connection is not available!");
   344|         }
   345|     }
   346|     @Override
   347|     public Address getOwnerConnectionAddress() {
   348|         return ownerConnectionAddress;
   349|     }
   350|     private void setOwnerConnectionAddress(Address ownerConnectionAddress) {
   351|         this.previousOwnerConnectionAddress = this.ownerConnectionAddress;
   352|         this.ownerConnectionAddress = ownerConnectionAddress;
   353|     }
   354|     private Connection getOrConnect(Address address, boolean asOwner) {
   355|         try {
   356|             while (true) {
   357|                 ClientConnection connection = (ClientConnection) getConnection(address, asOwner, true);
   358|                 if (connection != null) {
   359|                     return connection;
   360|                 }
   361|                 AuthenticationFuture future = triggerConnect(address, asOwner);
   362|                 connection = (ClientConnection) future.get();
   363|                 if (!asOwner) {
   364|                     return connection;
   365|                 }
   366|                 if (connection.isAuthenticatedAsOwner()) {
   367|                     return connection;
   368|                 }
   369|             }
   370|         } catch (Throwable e) {
   371|             throw rethrow(e);
   372|         }
   373|     }
   374|     private AuthenticationFuture triggerConnect(Address target, boolean asOwner) {
   375|         if (!asOwner) {
   376|             connectionStrategy.beforeOpenConnection(target);
   377|         }
   378|         AuthenticationFuture future = new AuthenticationFuture();
   379|         AuthenticationFuture oldFuture = connectionsInProgress.putIfAbsent(target, future);
   380|         if (oldFuture == null) {
   381|             executionService.execute(new InitConnectionTask(target, asOwner, future));
   382|             return future;
   383|         }
   384|         return oldFuture;
   385|     }
   386|     @Override
   387|     public ClientConnection getOwnerConnection() {
   388|         if (ownerConnectionAddress == null) {
   389|             return null;
   390|         }
   391|         ClientConnection connection = (ClientConnection) getActiveConnection(ownerConnectionAddress);
   392|         return connection;
   393|     }
   394|     private Connection connectAsOwner(Address address) {
   395|         Connection connection = null;
   396|         try {
   397|             logger.info("Trying to connect to " + address + " as owner member");
   398|             connection = getOrConnect(address, true);
   399|             client.onClusterConnect(connection);
   400|             fireConnectionEvent(LifecycleEvent.LifecycleState.CLIENT_CONNECTED);
   401|             connectionStrategy.onConnectToCluster();
   402|         } catch (Exception e) {
   403|             logger.warning("Exception during initial connection to " + address + ", exception " + e);
   404|             if (null != connection) {
   405|                 connection.close("Could not connect to " + address + " as owner", e);
   406|             }
   407|             return null;
   408|         }
   409|         return connection;
   410|     }
   411|     private void fireConnectionAddedEvent(ClientConnection connection) {
   412|         for (ConnectionListener connectionListener : connectionListeners) {
   413|             connectionListener.connectionAdded(connection);
   414|         }
   415|         connectionStrategy.onConnect(connection);
   416|     }
   417|     private void fireConnectionRemovedEvent(ClientConnection connection) {
   418|         if (connection.isAuthenticatedAsOwner()) {
   419|             disconnectFromCluster(connection);
   420|         }
   421|         for (ConnectionListener listener : connectionListeners) {
   422|             listener.connectionRemoved(connection);
   423|         }
   424|         connectionStrategy.onDisconnect(connection);
   425|     }
   426|     private void disconnectFromCluster(final ClientConnection connection) {
   427|         clusterConnectionExecutor.execute(new Runnable() {
   428|             @Override
   429|             public void run() {
   430|                 Address endpoint = connection.getEndPoint();
   431|                 if (endpoint == null || !endpoint.equals(ownerConnectionAddress)) {
   432|                     return;
   433|                 }
   434|                 setOwnerConnectionAddress(null);
   435|                 connectionStrategy.onDisconnectFromCluster();
   436|                 if (client.getLifecycleService().isRunning()) {
   437|                     fireConnectionEvent(LifecycleEvent.LifecycleState.CLIENT_DISCONNECTED);
   438|                 }
   439|             }
   440|         });
   441|     }
   442|     private void fireConnectionEvent(final LifecycleEvent.LifecycleState state) {
   443|         final LifecycleServiceImpl lifecycleService = (LifecycleServiceImpl) client.getLifecycleService();
   444|         lifecycleService.fireLifecycleEvent(state);
   445|     }
   446|     private boolean useAnyOutboundPort() {
   447|         return outboundPortCount == 0;
   448|     }
   449|     private int acquireOutboundPort() {
   450|         if (outboundPortCount == 0) {
   451|             return 0;
   452|         }
   453|         synchronized (outboundPorts) {
   454|             final Integer port = outboundPorts.removeFirst();
   455|             outboundPorts.addLast(port);
   456|             return port;
   457|         }
   458|     }
   459|     private void bindSocketToPort(Socket socket) throws IOException {
   460|         if (useAnyOutboundPort()) {
   461|             SocketAddress socketAddress = new InetSocketAddress(0);
   462|             socket.bind(socketAddress);
   463|         } else {
   464|             int retryCount = outboundPortCount * 2;
   465|             IOException ex = null;
   466|             for (int i = 0; i < retryCount; i++) {
   467|                 int port = acquireOutboundPort();
   468|                 if (port == 0) {
   469|                     return;
   470|                 }
   471|                 SocketAddress socketAddress = new InetSocketAddress(port);
   472|                 try {
   473|                     socket.bind(socketAddress);
   474|                     return;
   475|                 } catch (IOException e) {
   476|                     ex = e;
   477|                     logger.finest("Could not bind port[ " + port + "]: " + e.getMessage());
   478|                 }
   479|             }
   480|             throw ex;
   481|         }
   482|     }
   483|     protected ClientConnection createSocketConnection(final Address address) throws IOException {
   484|         SocketChannel socketChannel = null;
   485|         try {
   486|             socketChannel = SocketChannel.open();
   487|             Socket socket = socketChannel.socket();
   488|             socket.setKeepAlive(socketOptions.isKeepAlive());
   489|             socket.setTcpNoDelay(socketOptions.isTcpNoDelay());
   490|             socket.setReuseAddress(socketOptions.isReuseAddress());
   491|             if (socketOptions.getLingerSeconds() > 0) {
   492|                 socket.setSoLinger(true, socketOptions.getLingerSeconds());
   493|             }
   494|             int bufferSize = getBufferSize();
   495|             socket.setSendBufferSize(bufferSize);
   496|             socket.setReceiveBufferSize(bufferSize);
   497|             InetSocketAddress inetSocketAddress = address.getInetSocketAddress();
   498|             bindSocketToPort(socket);
   499|             socketChannel.socket().connect(inetSocketAddress, connectionTimeoutMillis);
   500|             HazelcastProperties properties = client.getProperties();
   501|             boolean directBuffer = properties.getBoolean(SOCKET_CLIENT_BUFFER_DIRECT);
   502|             Channel channel = channelFactory.create(socketChannel, true, directBuffer);
   503|             final ClientConnection clientConnection = new ClientConnection(
   504|                     client, connectionIdGen.incrementAndGet(), channel);
   505|             socketChannel.configureBlocking(true);
   506|             if (socketInterceptor != null) {
   507|                 socketInterceptor.onConnect(socket);
   508|             }
   509|             socket.setSoTimeout(0);
   510|             eventLoopGroup.register(channel);
   511|             return clientConnection;
   512|         } catch (Exception e) {
   513|             if (socketChannel != null) {
   514|                 socketChannel.close();
   515|             }
   516|             throw rethrow(e, IOException.class);
   517|         }
   518|     }
   519|     private int getBufferSize() {
   520|         int bufferSize = socketOptions.getBufferSize() * KILO_BYTE;
   521|         return bufferSize <= 0 ? DEFAULT_BUFFER_SIZE_BYTE : bufferSize;
   522|     }
   523|     void onClose(Connection connection) {
   524|         removeFromActiveConnections(connection);
   525|     }
   526|     private void removeFromActiveConnections(Connection connection) {
   527|         Address endpoint = connection.getEndPoint();
   528|         if (endpoint == null) {
   529|             if (logger.isFinestEnabled()) {
   530|                 logger.finest("Destroying " + connection + ", but it has end-point set to null "
   531|                         + "-> not removing it from a connection map");
   532|             }
   533|             return;
   534|         }
   535|         if (activeConnections.remove(endpoint, connection)) {
   536|             logger.info("Removed connection to endpoint: " + endpoint + ", connection: " + connection);
   537|             fireConnectionRemovedEvent((ClientConnection) connection);
   538|         } else {
   539|             if (logger.isFinestEnabled()) {
   540|                 logger.finest("Destroying a connection, but there is no mapping " + endpoint + " -> " + connection
   541|                         + " in the connection map.");
   542|             }
   543|         }
   544|     }
   545|     @Override
   546|     public void addConnectionListener(ConnectionListener connectionListener) {
   547|         connectionListeners.add(connectionListener);
   548|     }
   549|     @Override
   550|     public void addConnectionHeartbeatListener(ConnectionHeartbeatListener connectionHeartbeatListener) {
   551|         heartbeat.addConnectionHeartbeatListener(connectionHeartbeatListener);
   552|     }
   553|     private void authenticate(final Address target, final ClientConnection connection, final boolean asOwner,
   554|                               final AuthenticationFuture future) {
   555|         final ClientPrincipal principal = getPrincipal();
   556|         ClientMessage clientMessage = encodeAuthenticationRequest(asOwner, client.getSerializationService(), principal);
   557|         ClientInvocation clientInvocation = new ClientInvocation(client, clientMessage, null, connection);
   558|         ClientInvocationFuture invocationFuture = clientInvocation.invokeUrgent();
   559|         ScheduledFuture timeoutTaskFuture = executionService.schedule(
   560|                 new TimeoutAuthenticationTask(invocationFuture), authenticationTimeout, MILLISECONDS);
   561|         invocationFuture.andThen(new AuthCallback(connection, asOwner, target, future, timeoutTaskFuture));
   562|     }
   563|     private ClientMessage encodeAuthenticationRequest(boolean asOwner, SerializationService ss, ClientPrincipal principal) {
   564|         byte serializationVersion = ((InternalSerializationService) ss).getVersion();
   565|         String uuid = null;
   566|         String ownerUuid = null;
   567|         if (principal != null) {
   568|             uuid = principal.getUuid();
   569|             ownerUuid = principal.getOwnerUuid();
   570|         }
   571|         ClientMessage clientMessage;
   572|         if (credentials.getClass().equals(UsernamePasswordCredentials.class)) {
   573|             UsernamePasswordCredentials cr = (UsernamePasswordCredentials) credentials;
   574|             clientMessage = ClientAuthenticationCodec
   575|                     .encodeRequest(cr.getUsername(), cr.getPassword(), uuid, ownerUuid, asOwner, ClientTypes.JAVA,
   576|                             serializationVersion, BuildInfoProvider.getBuildInfo().getVersion());
   577|         } else {
   578|             Data data = ss.toData(credentials);
   579|             clientMessage = ClientAuthenticationCustomCodec.encodeRequest(data, uuid, ownerUuid,
   580|                     asOwner, ClientTypes.JAVA, serializationVersion, BuildInfoProvider.getBuildInfo().getVersion());
   581|         }
   582|         return clientMessage;
   583|     }
   584|     private void onAuthenticated(Address target, ClientConnection connection) {
   585|         ClientConnection oldConnection = activeConnections.put(connection.getEndPoint(), connection);
   586|         if (oldConnection == null) {
   587|             if (logger.isFinestEnabled()) {
   588|                 logger.finest("Authentication succeeded for " + connection
   589|                         + " and there was no old connection to this end-point");
   590|             }
   591|             fireConnectionAddedEvent(connection);

# --- HUNK 3: Lines 602-648 ---
   602|         we need to remove it back from active connections.
   603|         Race description from https://github.com/hazelcast/hazelcast/pull/8832.(A little bit changed)
   604|         - open a connection client -> member
   605|         - send auth message
   606|         - receive auth reply -> reply processing is offloaded to an executor. Did not start to run yet.
   607|         - member closes the connection -> the connection is trying to removed from map
   608|                                                              but it was not there to begin with
   609|         - the executor start processing the auth reply -> it put the connection to the connection map.
   610|         - we end up with a closed connection in activeConnections map */
   611|         if (!connection.isAlive()) {
   612|             removeFromActiveConnections(connection);
   613|         }
   614|     }
   615|     private void onAuthenticationFailed(Address target, ClientConnection connection, Throwable cause) {
   616|         if (logger.isFinestEnabled()) {
   617|             logger.finest("Authentication of " + connection + " failed.", cause);
   618|         }
   619|         connection.close(null, cause);
   620|         connectionsInProgress.remove(target);
   621|     }
   622|     @Override
   623|     public void heartbeatResumed(Connection connection) {
   624|         connectionStrategy.onHeartbeatResumed((ClientConnection) connection);
   625|     }
   626|     @Override
   627|     public void heartbeatStopped(Connection connection) {
   628|         connectionStrategy.onHeartbeatStopped((ClientConnection) connection);
   629|     }
   630|     private class TimeoutAuthenticationTask implements Runnable {
   631|         private final ClientInvocationFuture future;
   632|         TimeoutAuthenticationTask(ClientInvocationFuture future) {
   633|             this.future = future;
   634|         }
   635|         @Override
   636|         public void run() {
   637|             if (future.isDone()) {
   638|                 return;
   639|             }
   640|             future.complete(new TimeoutException("Authentication response did not come back in "
   641|                     + authenticationTimeout + " millis"));
   642|         }
   643|     }
   644|     private class InitConnectionTask implements Runnable {
   645|         private final Address target;
   646|         private final boolean asOwner;
   647|         private final AuthenticationFuture future;
   648|         InitConnectionTask(Address target, boolean asOwner, AuthenticationFuture future) {

# --- HUNK 4: Lines 685-874 ---
   685|     private class ClientConnectionChannelErrorHandler implements ChannelErrorHandler {
   686|         @Override
   687|         public void onError(Channel channel, Throwable cause) {
   688|             if (channel == null) {
   689|                 logger.severe(cause);
   690|             } else {
   691|                 if (cause instanceof OutOfMemoryError) {
   692|                     logger.severe(cause);
   693|                 }
   694|                 ClientConnection connection = (ClientConnection) channel.attributeMap().get(ClientConnection.class);
   695|                 if (cause instanceof EOFException) {
   696|                     connection.close("Connection closed by the other side", cause);
   697|                 } else {
   698|                     connection.close("Exception in " + connection + ", thread=" + Thread.currentThread().getName(), cause);
   699|                 }
   700|             }
   701|         }
   702|     }
   703|     @Override
   704|     public void connectToCluster() {
   705|         try {
   706|             connectToClusterAsync().get();
   707|         } catch (Exception e) {
   708|             throw rethrow(e);
   709|         }
   710|     }
   711|     private void connectToClusterInternal() {
   712|         int attempt = 0;
   713|         Set<Address> triedAddresses = new HashSet<Address>();
   714|         while (attempt < connectionAttemptLimit) {
   715|             attempt++;
   716|             long nextTry = Clock.currentTimeMillis() + connectionAttemptPeriod;
   717|             Collection<Address> addresses = getPossibleMemberAddresses();
   718|             for (Address address : addresses) {
   719|                 if (!client.getLifecycleService().isRunning()) {
   720|                     throw new IllegalStateException("Giving up on retrying to connect to cluster since client is shutdown.");
   721|                 }
   722|                 triedAddresses.add(address);
   723|                 if (connectAsOwner(address) != null) {
   724|                     return;
   725|                 }
   726|             }
   727|             if (!client.getLifecycleService().isRunning()) {
   728|                 throw new IllegalStateException("Client is being shutdown.");
   729|             }
   730|             if (attempt < connectionAttemptLimit) {
   731|                 final long remainingTime = nextTry - Clock.currentTimeMillis();
   732|                 logger.warning(String.format("Unable to get alive cluster connection, try in %d ms later, attempt %d of %d.",
   733|                         Math.max(0, remainingTime), attempt, connectionAttemptLimit));
   734|                 if (remainingTime > 0) {
   735|                     try {
   736|                         Thread.sleep(remainingTime);
   737|                     } catch (InterruptedException e) {
   738|                         Thread.currentThread().interrupt();
   739|                         break;
   740|                     }
   741|                 }
   742|             } else {
   743|                 logger.warning(String.format("Unable to get alive cluster connection, attempt %d of %d.", attempt,
   744|                         connectionAttemptLimit));
   745|             }
   746|         }
   747|         throw new IllegalStateException(
   748|                 "Unable to connect to any address! The following addresses were tried: " + triedAddresses);
   749|     }
   750|     @Override
   751|     public Future<Void> connectToClusterAsync() {
   752|         return clusterConnectionExecutor.submit(new Callable<Void>() {
   753|             @Override
   754|             public Void call() throws Exception {
   755|                 try {
   756|                     connectToClusterInternal();
   757|                 } catch (Exception e) {
   758|                     logger.warning("Could not connect to cluster, shutting down the client. " + e.getMessage());
   759|                     new Thread(new Runnable() {
   760|                         @Override
   761|                         public void run() {
   762|                             try {
   763|                                 client.getLifecycleService().shutdown();
   764|                             } catch (Exception exception) {
   765|                                 logger.severe("Exception during client shutdown ", exception);
   766|                             }
   767|                         }
   768|                     }, client.getName() + ".clientShutdown-").start();
   769|                     throw rethrow(e);
   770|                 }
   771|                 return null;
   772|             }
   773|         });
   774|     }
   775|     Collection<Address> getPossibleMemberAddresses() {
   776|         LinkedHashSet<Address> addresses = new LinkedHashSet<Address>();
   777|         Collection<Member> memberList = client.getClientClusterService().getMemberList();
   778|         for (Member member : memberList) {
   779|             addresses.add(member.getAddress());
   780|         }
   781|         if (shuffleMemberList) {
   782|             shuffle(addresses);
   783|         }
   784|         LinkedHashSet<Address> providerAddresses = new LinkedHashSet<Address>();
   785|         for (AddressProvider addressProvider : addressProviders) {
   786|             try {
   787|                 providerAddresses.addAll(addressProvider.loadAddresses());
   788|             } catch (NullPointerException e) {
   789|                 throw e;
   790|             } catch (Exception e) {
   791|                 logger.warning("Exception from AddressProvider: " + addressProvider, e);
   792|             }
   793|         }
   794|         if (shuffleMemberList) {
   795|             shuffle(providerAddresses);
   796|         }
   797|         addresses.addAll(providerAddresses);
   798|         if (previousOwnerConnectionAddress != null) {
   799|             /*
   800|              * Previous owner address is moved to last item in set so that client will not try to connect to same one immediately.
   801|              * It could be the case that address is removed because it is healthy(it not responding to heartbeat/pings)
   802|              * In that case, trying other addresses first to upgrade make more sense.
   803|              */
   804|             addresses.remove(previousOwnerConnectionAddress);
   805|             addresses.add(previousOwnerConnectionAddress);
   806|         }
   807|         return addresses;
   808|     }
   809|     private static <T> Set<T> shuffle(Set<T> set) {
   810|         List<T> shuffleMe = new ArrayList<T>(set);
   811|         Collections.shuffle(shuffleMe);
   812|         Set<T> shuffledSet = new LinkedHashSet<T>();
   813|         shuffledSet.addAll(shuffleMe);
   814|         return shuffledSet;
   815|     }
   816|     private ExecutorService createSingleThreadExecutorService(HazelcastClientInstanceImpl client) {
   817|         ClassLoader classLoader = client.getClientConfig().getClassLoader();
   818|         SingleExecutorThreadFactory threadFactory = new SingleExecutorThreadFactory(classLoader, client.getName() + ".cluster-");
   819|         return Executors.newSingleThreadExecutor(threadFactory);
   820|     }
   821|     private class AuthCallback implements ExecutionCallback<ClientMessage> {
   822|         private final ClientConnection connection;
   823|         private final boolean asOwner;
   824|         private final Address target;
   825|         private final AuthenticationFuture future;
   826|         private final ScheduledFuture timeoutTaskFuture;
   827|         AuthCallback(ClientConnection connection, boolean asOwner, Address target,
   828|                      AuthenticationFuture future, ScheduledFuture timeoutTaskFuture) {
   829|             this.connection = connection;
   830|             this.asOwner = asOwner;
   831|             this.target = target;
   832|             this.future = future;
   833|             this.timeoutTaskFuture = timeoutTaskFuture;
   834|         }
   835|         @Override
   836|         public void onResponse(ClientMessage response) {
   837|             timeoutTaskFuture.cancel(true);
   838|             ClientAuthenticationCodec.ResponseParameters result;
   839|             try {
   840|                 result = ClientAuthenticationCodec.decodeResponse(response);
   841|             } catch (HazelcastException e) {
   842|                 onFailure(e);
   843|                 return;
   844|             }
   845|             AuthenticationStatus authenticationStatus = AuthenticationStatus.getById(result.status);
   846|             switch (authenticationStatus) {
   847|                 case AUTHENTICATED:
   848|                     connection.setConnectedServerVersion(result.serverHazelcastVersion);
   849|                     connection.setRemoteEndpoint(result.address);
   850|                     if (asOwner) {
   851|                         connection.setIsAuthenticatedAsOwner();
   852|                         ClientPrincipal principal = new ClientPrincipal(result.uuid, result.ownerUuid);
   853|                         setPrincipal(principal);
   854|                         setOwnerConnectionAddress(connection.getEndPoint());
   855|                         logger.info("Setting " + connection + " as owner with principal " + principal);
   856|                     }
   857|                     onAuthenticated(target, connection);
   858|                     future.onSuccess(connection);
   859|                     break;
   860|                 case CREDENTIALS_FAILED:
   861|                     onFailure(new AuthenticationException("Invalid credentials! Principal: " + principal));
   862|                     break;
   863|                 default:
   864|                     onFailure(new AuthenticationException("Authentication status code not supported. status: "
   865|                             + authenticationStatus));
   866|             }
   867|         }
   868|         @Override
   869|         public void onFailure(Throwable t) {
   870|             timeoutTaskFuture.cancel(true);
   871|             onAuthenticationFailed(target, connection, t);
   872|             future.onFailure(t);
   873|         }
   874|     }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/ClientICMPManager.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 128-160 ---
   128|                     logger.log(level, msg);
   129|                     return true;
   130|                 }
   131|             } catch (ConnectException ignored) {
   132|                 ignore(ignored);
   133|             }
   134|             return false;
   135|         }
   136|         public void run() {
   137|             try {
   138|                 Address address = connection.getEndPoint();
   139|                 logger.fine(format("will ping %s", address));
   140|                 if (doPing(address, Level.FINE)) {
   141|                     icmpFailureDetector.heartbeat(connection);
   142|                     return;
   143|                 }
   144|                 icmpFailureDetector.logAttempt(connection);
   145|                 String reason = format("Could not ping %s", address);
   146|                 logger.warning(reason);
   147|                 if (!icmpFailureDetector.isAlive(connection)) {
   148|                     connection.onHeartbeatFailed();
   149|                     heartbeatManager.fireHeartbeatStopped(connection);
   150|                 }
   151|             } catch (Throwable ignored) {
   152|                 ignore(ignored);
   153|             } finally {
   154|                 if (!connection.isAlive()) {
   155|                     icmpFailureDetector.remove(connection);
   156|                 }
   157|             }
   158|         }
   159|     }
   160| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/DefaultClientConnectionStrategy.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-41 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.connection.nio;
    17| import com.hazelcast.client.HazelcastClientOfflineException;
    18| import com.hazelcast.client.config.ClientConnectionStrategyConfig;
    19| import com.hazelcast.client.connection.ClientConnectionStrategy;
    20| import com.hazelcast.nio.Address;
    21| import com.hazelcast.spi.exception.TargetDisconnectedException;
    22| import java.util.concurrent.RejectedExecutionException;
    23| import static com.hazelcast.client.config.ClientConnectionStrategyConfig.ReconnectMode.ASYNC;
    24| import static com.hazelcast.client.config.ClientConnectionStrategyConfig.ReconnectMode.OFF;
    25| /**
    26|  * Default client connection strategy supporting async client start, reconnection modes and disabling reconnection.
    27|  */
    28| public class DefaultClientConnectionStrategy extends ClientConnectionStrategy {
    29|     private volatile boolean disconnectedFromCluster;
    30|     private boolean clientStartAsync;
    31|     private ClientConnectionStrategyConfig.ReconnectMode reconnectMode;
    32|     @Override
    33|     public void start() {
    34|         clientStartAsync = clientConnectionStrategyConfig.isAsyncStart();
    35|         reconnectMode = clientConnectionStrategyConfig.getReconnectMode();
    36|         if (clientStartAsync) {
    37|             clientContext.getConnectionManager().connectToClusterAsync();
    38|         } else {
    39|             clientContext.getConnectionManager().connectToCluster();
    40|         }
    41|     }

# --- HUNK 2: Lines 44-114 ---
    44|         if (isClusterAvailable()) {
    45|             return;
    46|         }
    47|         if (clientStartAsync && !disconnectedFromCluster) {
    48|             throw new HazelcastClientOfflineException("Client is connecting to cluster.");
    49|         }
    50|         if (reconnectMode == ASYNC && disconnectedFromCluster) {
    51|             throw new HazelcastClientOfflineException("Client is offline.");
    52|         }
    53|     }
    54|     @Override
    55|     public void beforeOpenConnection(Address target) {
    56|         if (isClusterAvailable()) {
    57|             return;
    58|         }
    59|         if (reconnectMode == ASYNC && disconnectedFromCluster) {
    60|             throw new HazelcastClientOfflineException("Client is offline");
    61|         }
    62|     }
    63|     @Override
    64|     public void onConnectToCluster() {
    65|     }
    66|     @Override
    67|     public void onDisconnectFromCluster() {
    68|         disconnectedFromCluster = true;
    69|         if (reconnectMode == OFF) {
    70|             shutdownWithExternalThread();
    71|             return;
    72|         }
    73|         if (clientContext.getLifecycleService().isRunning()) {
    74|             try {
    75|                 clientContext.getConnectionManager().connectToClusterAsync();
    76|             } catch (RejectedExecutionException r) {
    77|                 shutdownWithExternalThread();
    78|             }
    79|         }
    80|     }
    81|     private void shutdownWithExternalThread() {
    82|         new Thread(new Runnable() {
    83|             @Override
    84|             public void run() {
    85|                 try {
    86|                     clientContext.getLifecycleService().shutdown();
    87|                 } catch (Exception exception) {
    88|                     logger.severe("Exception during client shutdown ", exception);
    89|                 }
    90|             }
    91|         }, clientContext.getName() + ".clientShutdown-").start();
    92|     }
    93|     @Override
    94|     public void onConnect(ClientConnection connection) {
    95|     }
    96|     @Override
    97|     public void onDisconnect(ClientConnection connection) {
    98|     }
    99|     @Override
   100|     public void onHeartbeatStopped(ClientConnection connection) {
   101|         if (connection.isAuthenticatedAsOwner()) {
   102|             connection.close(null, new TargetDisconnectedException("Heartbeat timed out to owner connection " + connection));
   103|         }
   104|     }
   105|     @Override
   106|     public void onHeartbeatResumed(ClientConnection connection) {
   107|     }
   108|     @Override
   109|     public void shutdown() {
   110|     }
   111|     private boolean isClusterAvailable() {
   112|         return clientContext.getConnectionManager().getOwnerConnectionAddress() != null;
   113|     }
   114| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/HeartbeatManager.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-131 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.connection.nio;
    17| import com.hazelcast.client.config.ClientIcmpPingConfig;
    18| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    19| import com.hazelcast.client.impl.protocol.ClientMessage;
    20| import com.hazelcast.client.impl.protocol.codec.ClientPingCodec;
    21| import com.hazelcast.client.spi.impl.ClientExecutionServiceImpl;
    22| import com.hazelcast.client.spi.impl.ClientInvocation;
    23| import com.hazelcast.client.spi.impl.ConnectionHeartbeatListener;
    24| import com.hazelcast.core.ExecutionCallback;
    25| import com.hazelcast.logging.ILogger;
    26| import com.hazelcast.spi.properties.HazelcastProperties;
    27| import com.hazelcast.util.Clock;
    28| import java.util.Set;
    29| import java.util.concurrent.CopyOnWriteArraySet;
    30| import java.util.concurrent.TimeUnit;
    31| import static com.hazelcast.client.spi.properties.ClientProperty.HEARTBEAT_INTERVAL;
    32| import static com.hazelcast.client.spi.properties.ClientProperty.HEARTBEAT_TIMEOUT;
    33| /**
    34|  * HeartbeatManager manager used by connection manager.
    35|  */
    36| public class HeartbeatManager implements Runnable {
    37|     private final ClientConnectionManagerImpl clientConnectionManager;
    38|     private final HazelcastClientInstanceImpl client;
    39|     private final ILogger logger;
    40|     private final long heartbeatInterval;
    41|     private final long heartbeatTimeout;
    42|     private final ClientICMPManager clientICMPManager;
    43|     private final Set<ConnectionHeartbeatListener> heartbeatListeners = new CopyOnWriteArraySet<ConnectionHeartbeatListener>();
    44|     HeartbeatManager(ClientConnectionManagerImpl clientConnectionManager, HazelcastClientInstanceImpl client) {
    45|         this.clientConnectionManager = clientConnectionManager;
    46|         this.client = client;
    47|         HazelcastProperties hazelcastProperties = client.getProperties();
    48|         long timeout = hazelcastProperties.getMillis(HEARTBEAT_TIMEOUT);
    49|         this.heartbeatTimeout = timeout > 0 ? timeout : Integer.parseInt(HEARTBEAT_TIMEOUT.getDefaultValue());
    50|         long interval = hazelcastProperties.getMillis(HEARTBEAT_INTERVAL);
    51|         this.heartbeatInterval = interval > 0 ? interval : Integer.parseInt(HEARTBEAT_INTERVAL.getDefaultValue());
    52|         this.logger = client.getLoggingService().getLogger(HeartbeatManager.class);
    53|         ClientIcmpPingConfig icmpPingConfig = client.getClientConfig().getNetworkConfig().getClientIcmpPingConfig();
    54|         this.clientICMPManager = new ClientICMPManager(icmpPingConfig,
    55|                 (ClientExecutionServiceImpl) client.getClientExecutionService(),
    56|                 client.getLoggingService(), clientConnectionManager, this);
    57|     }
    58|     public void start() {
    59|         final ClientExecutionServiceImpl es = (ClientExecutionServiceImpl) client.getClientExecutionService();
    60|         es.scheduleWithRepetition(this, heartbeatInterval, heartbeatInterval, TimeUnit.MILLISECONDS);
    61|         clientICMPManager.start();
    62|     }
    63|     long getHeartbeatTimeout() {
    64|         return heartbeatTimeout;
    65|     }
    66|     @Override
    67|     public void run() {
    68|         if (!clientConnectionManager.alive) {
    69|             return;
    70|         }
    71|         long now = Clock.currentTimeMillis();
    72|         for (final ClientConnection connection : clientConnectionManager.getActiveConnections()) {
    73|             checkConnection(now, connection);
    74|         }
    75|     }
    76|     private void checkConnection(long now, final ClientConnection connection) {
    77|         if (!connection.isAlive()) {
    78|             return;
    79|         }
    80|         if (now - connection.lastReadTimeMillis() > heartbeatTimeout) {
    81|             if (connection.isHeartBeating()) {
    82|                 logger.warning("Heartbeat failed over the connection: " + connection);
    83|                 connection.onHeartbeatFailed();
    84|                 fireHeartbeatStopped(connection);
    85|             }
    86|         } else {
    87|             if (!connection.isHeartBeating()) {
    88|                 logger.warning("Heartbeat is back to healthy for the connection: " + connection);
    89|                 connection.onHeartbeatResumed();
    90|                 fireHeartbeatResumed(connection);
    91|             }
    92|         }
    93|         if (now - connection.lastWriteTimeMillis() > heartbeatInterval) {
    94|             ClientMessage request = ClientPingCodec.encodeRequest();
    95|             final ClientInvocation clientInvocation = new ClientInvocation(client, request, null, connection);
    96|             clientInvocation.setBypassHeartbeatCheck(true);
    97|             connection.onHeartbeatRequested();
    98|             clientInvocation.invokeUrgent().andThen(new ExecutionCallback<ClientMessage>() {
    99|                 @Override
   100|                 public void onResponse(ClientMessage response) {
   101|                     if (connection.isAlive()) {
   102|                         connection.onHeartbeatReceived();
   103|                     }
   104|                 }
   105|                 @Override
   106|                 public void onFailure(Throwable t) {
   107|                     if (connection.isAlive()) {
   108|                         logger.warning("Error receiving ping answer from the connection: " + connection, t);
   109|                     }
   110|                 }
   111|             });
   112|         }
   113|     }
   114|     private void fireHeartbeatResumed(ClientConnection connection) {
   115|         for (ConnectionHeartbeatListener heartbeatListener : heartbeatListeners) {
   116|             heartbeatListener.heartbeatResumed(connection);
   117|         }
   118|     }
   119|     void fireHeartbeatStopped(ClientConnection connection) {
   120|         for (ConnectionHeartbeatListener heartbeatListener : heartbeatListeners) {
   121|             heartbeatListener.heartbeatStopped(connection);
   122|         }
   123|     }
   124|     public void addConnectionHeartbeatListener(ConnectionHeartbeatListener connectionHeartbeatListener) {
   125|         heartbeatListeners.add(connectionHeartbeatListener);
   126|     }
   127|     public void shutdown() {
   128|         heartbeatListeners.clear();
   129|         clientICMPManager.shutdown();
   130|     }
   131| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/console/ClientConsoleApp.java
# Total hunks: 13
# ====================================================================
# --- HUNK 1: Lines 23-92 ---
    23| import com.hazelcast.core.DistributedObject;
    24| import com.hazelcast.core.EntryEvent;
    25| import com.hazelcast.core.EntryListener;
    26| import com.hazelcast.core.HazelcastInstance;
    27| import com.hazelcast.core.IAtomicLong;
    28| import com.hazelcast.core.IExecutorService;
    29| import com.hazelcast.core.IList;
    30| import com.hazelcast.core.IMap;
    31| import com.hazelcast.core.IQueue;
    32| import com.hazelcast.core.ISet;
    33| import com.hazelcast.core.ITopic;
    34| import com.hazelcast.core.ItemEvent;
    35| import com.hazelcast.core.ItemListener;
    36| import com.hazelcast.core.MapEvent;
    37| import com.hazelcast.core.Member;
    38| import com.hazelcast.core.Message;
    39| import com.hazelcast.core.MessageListener;
    40| import com.hazelcast.core.MultiMap;
    41| import com.hazelcast.core.Partition;
    42| import com.hazelcast.internal.util.RuntimeAvailableProcessors;
    43| import com.hazelcast.util.Clock;
    44| import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
    45| import java.io.BufferedReader;
    46| import java.io.File;
    47| import java.io.FileReader;
    48| import java.io.IOException;
    49| import java.io.InputStreamReader;
    50| import java.lang.management.ManagementFactory;
    51| import java.nio.charset.Charset;
    52| import java.util.Collection;
    53| import java.util.HashMap;
    54| import java.util.Iterator;
    55| import java.util.LinkedList;
    56| import java.util.List;
    57| import java.util.Map;
    58| import java.util.Map.Entry;
    59| import java.util.Set;
    60| import java.util.StringTokenizer;
    61| import java.util.concurrent.ExecutionException;
    62| import java.util.concurrent.ExecutorService;
    63| import java.util.concurrent.Executors;
    64| import java.util.concurrent.Future;
    65| import java.util.concurrent.TimeUnit;
    66| import java.util.concurrent.locks.Lock;
    67| import static com.hazelcast.util.StringUtil.lowerCaseInternal;
    68| import static java.lang.String.format;
    69| import static java.lang.Thread.currentThread;
    70| /**
    71|  * A demo application to demonstrate a Hazelcast client. This is probably NOT something you want to use in production.
    72|  */
    73| public class ClientConsoleApp implements EntryListener, ItemListener, MessageListener {
    74|     private static final int ONE_KB = 1024;
    75|     private static final int ONE_THOUSAND = 1000;
    76|     private static final int ONE_HUNDRED = 100;
    77|     private static final int ONE_HOUR = 3600;
    78|     private static final int MAX_THREAD_COUNT = 16;
    79|     private static final int HUNDRED_CONSTANT = 100;
    80|     private static final int BYTE_TO_BIT = 8;
    81|     private static final int LENGTH_BORDER = 4;
    82|     private IQueue<Object> queue;
    83|     private ITopic<Object> topic;
    84|     private IMap<Object, Object> map;
    85|     private MultiMap<Object, Object> multiMap;
    86|     private ISet<Object> set;
    87|     private IList<Object> list;
    88|     private IAtomicLong atomicNumber;
    89|     private String namespace = "default";
    90|     private String executorNamespace = "Sample Executor";
    91|     private boolean silent;
    92|     private boolean echo;

# --- HUNK 2: Lines 118-243 ---
   118|     }
   119|     public ISet<Object> getSet() {
   120|         set = hazelcast.getSet(namespace);
   121|         return set;
   122|     }
   123|     public IList<Object> getList() {
   124|         list = hazelcast.getList(namespace);
   125|         return list;
   126|     }
   127|     public void setHazelcast(HazelcastInstance hazelcast) {
   128|         this.hazelcast = hazelcast;
   129|         map = null;
   130|         list = null;
   131|         set = null;
   132|         queue = null;
   133|         topic = null;
   134|     }
   135|     public void stop() {
   136|         running = false;
   137|     }
   138|     public void start(String[] args) throws Exception {
   139|         getMap().size();
   140|         getList().size();
   141|         getSet().size();
   142|         getQueue().size();
   143|         getMultiMap().size();
   144|         if (lineReader == null) {
   145|             lineReader = new DefaultLineReader();
   146|         }
   147|         running = true;
   148|         while (running) {
   149|             print("hazelcast[" + namespace + "] > ");
   150|             try {
   151|                 final String command = lineReader.readLine();
   152|                 handleCommand(command);
   153|             } catch (Throwable e) {
   154|                 e.printStackTrace();
   155|             }
   156|         }
   157|     }
   158|     /**
   159|      * A line reader
   160|      */
   161|     static class DefaultLineReader implements LineReader {
   162|         BufferedReader in = new BufferedReader(new InputStreamReader(System.in, Charset.forName("UTF-8")));
   163|         public String readLine() throws Exception {
   164|             return in.readLine();
   165|         }
   166|     }
   167|     /**
   168|      * Handle a command
   169|      *
   170|      * @param commandInputted
   171|      */
   172|     @SuppressFBWarnings("DM_EXIT")
   173|     protected void handleCommand(String commandInputted) {
   174|         String command = commandInputted;
   175|         if (command == null) {
   176|             return;
   177|         }
   178|         if (command.contains("__")) {
   179|             namespace = command.split("__")[0];
   180|             command = command.substring(command.indexOf("__") + 2);
   181|         }
   182|         if (echo) {
   183|             handleEcho(command);
   184|         }
   185|         if (command == null || command.startsWith("//")) {
   186|             return;
   187|         }
   188|         command = command.trim();
   189|         if (command == null || command.length() == 0) {
   190|             return;
   191|         }
   192|         String first = command;
   193|         int spaceIndex = command.indexOf(' ');
   194|         String[] argsSplit = command.split(" ");
   195|         String[] args = new String[argsSplit.length];
   196|         for (int i = 0; i < argsSplit.length; i++) {
   197|             args[i] = argsSplit[i].trim();
   198|         }
   199|         if (spaceIndex != -1) {
   200|             first = args[0];
   201|         }
   202|         if (command.startsWith("help")) {
   203|             handleHelp(command);
   204|         } else if (first.startsWith("#") && first.length() > 1) {
   205|             int repeat = Integer.parseInt(first.substring(1));
   206|             long t0 = Clock.currentTimeMillis();
   207|             for (int i = 0; i < repeat; i++) {
   208|                 handleCommand(command.substring(first.length()).replaceAll("\\$i", "" + i));
   209|             }
   210|             println("ops/s = " + repeat * ONE_THOUSAND / (Clock.currentTimeMillis() - t0));
   211|         } else if (first.startsWith("&") && first.length() > 1) {
   212|             final int fork = Integer.parseInt(first.substring(1));
   213|             ExecutorService pool = Executors.newFixedThreadPool(fork);
   214|             final String threadCommand = command.substring(first.length());
   215|             for (int i = 0; i < fork; i++) {
   216|                 final int threadID = i;
   217|                 pool.submit(new Runnable() {
   218|                     public void run() {
   219|                         String command = threadCommand;
   220|                         String[] threadArgs = command.replaceAll("\\$t", "" + threadID).trim()
   221|                                 .split(" ");
   222|                         if ("m.putmany".equals(threadArgs[0])
   223|                                 || "m.removemany".equals(threadArgs[0])) {
   224|                             if (threadArgs.length < LENGTH_BORDER) {
   225|                                 command += " " + Integer.parseInt(threadArgs[1]) * threadID;
   226|                             }
   227|                         }
   228|                         handleCommand(command);
   229|                     }
   230|                 });
   231|             }
   232|             pool.shutdown();
   233|             try {
   234|                 pool.awaitTermination(ONE_HOUR, TimeUnit.SECONDS);
   235|             } catch (Exception e) {
   236|                 e.printStackTrace();
   237|             }
   238|         } else if (first.startsWith("@")) {
   239|             handleAt(first);
   240|         } else if (command.indexOf(';') != -1) {
   241|             handleColon(command);
   242|         } else if ("silent".equals(first)) {
   243|             silent = Boolean.parseBoolean(args[1]);

# --- HUNK 3: Lines 321-362 ---
   321|         } else if (command.equalsIgnoreCase("m.localKeys")) {
   322|             handleMapLocalKeys();
   323|         } else if (command.equalsIgnoreCase("m.localSize")) {
   324|             handleMapLocalSize();
   325|         } else if (command.equals("m.keys")) {
   326|             handleMapKeys();
   327|         } else if (command.equals("m.values")) {
   328|             handleMapValues();
   329|         } else if (command.equals("m.entries")) {
   330|             handleMapEntries();
   331|         } else if (first.equals("m.lock")) {
   332|             handleMapLock(args);
   333|         } else if (first.equalsIgnoreCase("m.tryLock")) {
   334|             handleMapTryLock(args);
   335|         } else if (first.equals("m.unlock")) {
   336|             handleMapUnlock(args);
   337|         } else if (first.contains(".addListener")) {
   338|             handleAddListener(args);
   339|         } else if (first.equals("m.removeMapListener")) {
   340|             handleRemoveListener(args);
   341|         } else if (first.equals("m.unlock")) {
   342|             handleMapUnlock(args);
   343|         } else if (first.equals("mm.put")) {
   344|             handleMultiMapPut(args);
   345|         } else if (first.equals("mm.get")) {
   346|             handleMultiMapGet(args);
   347|         } else if (first.equals("mm.remove")) {
   348|             handleMultiMapRemove(args);
   349|         } else if (command.equals("mm.keys")) {
   350|             handleMultiMapKeys();
   351|         } else if (command.equals("mm.values")) {
   352|             handleMultiMapValues();
   353|         } else if (command.equals("mm.entries")) {
   354|             handleMultiMapEntries();
   355|         } else if (first.equals("mm.lock")) {
   356|             handleMultiMapLock(args);
   357|         } else if (first.equalsIgnoreCase("mm.tryLock")) {
   358|             handleMultiMapTryLock(args);
   359|         } else if (first.equals("mm.unlock")) {
   360|             handleMultiMapUnlock(args);
   361|         } else if (first.equals("l.add")) {
   362|             handleListAdd(args);

# --- HUNK 4: Lines 430-479 ---
   430|             }
   431|         }
   432|         long durationMs = System.currentTimeMillis() - startMs;
   433|         println(format("Executed %s tasks in %s ms", taskCount, durationMs));
   434|     }
   435|     private void handleColon(String command) {
   436|         StringTokenizer st = new StringTokenizer(command, ";");
   437|         while (st.hasMoreTokens()) {
   438|             handleCommand(st.nextToken());
   439|         }
   440|     }
   441|     @SuppressFBWarnings("DM_DEFAULT_ENCODING")
   442|     private void handleAt(String first) {
   443|         if (first.length() == 1) {
   444|             println("usage: @<file-name>");
   445|             return;
   446|         }
   447|         File f = new File(first.substring(1));
   448|         println("Executing script file " + f.getAbsolutePath());
   449|         if (f.exists()) {
   450|             try {
   451|                 BufferedReader br = new BufferedReader(new FileReader(f));
   452|                 String l = br.readLine();
   453|                 while (l != null) {
   454|                     handleCommand(l);
   455|                     l = br.readLine();
   456|                 }
   457|                 br.close();
   458|             } catch (IOException e) {
   459|                 e.printStackTrace();
   460|             }
   461|         } else {
   462|             println("File not found! " + f.getAbsolutePath());
   463|         }
   464|     }
   465|     private void handleEcho(String command) {
   466|         String threadName = lowerCaseInternal(Thread.currentThread().getName());
   467|         if (!threadName.contains("main")) {
   468|             println(" [" + Thread.currentThread().getName() + "] " + command);
   469|         } else {
   470|             println(command);
   471|         }
   472|     }
   473|     private void handleNamespace(String[] args) {
   474|         if (args.length > 1) {
   475|             namespace = args[1];
   476|             println("namespace: " + namespace);
   477|         }
   478|     }
   479|     @SuppressFBWarnings("DM_GC")

# --- HUNK 5: Lines 541-590 ---
   541|                 }
   542|                 partitionCounts.put(owner, newCount);
   543|             }
   544|             println(partition);
   545|         }
   546|         Set<Entry<Member, Integer>> entries = partitionCounts.entrySet();
   547|         for (Entry<Member, Integer> entry : entries) {
   548|             println(entry.getKey() + ":" + entry.getValue());
   549|         }
   550|     }
   551|     protected void handleInstances(String[] args) {
   552|         Collection<DistributedObject> distributedObjects = hazelcast.getDistributedObjects();
   553|         for (DistributedObject distributedObject : distributedObjects) {
   554|             println(distributedObject);
   555|         }
   556|     }
   557|     protected void handleListContains(String[] args) {
   558|         println(getList().contains(args[1]));
   559|     }
   560|     protected void handleListRemove(String[] args) {
   561|         int index = -1;
   562|         try {
   563|             index = Integer.parseInt(args[1]);
   564|         } catch (NumberFormatException e) {
   565|             throw new RuntimeException(e);
   566|         }
   567|         if (index >= 0) {
   568|             println(getList().remove(index));
   569|         } else {
   570|             println(getList().remove(args[1]));
   571|         }
   572|     }
   573|     protected void handleListAdd(String[] args) {
   574|         if (args.length == 3) {
   575|             final int index = Integer.parseInt(args[1]);
   576|             getList().add(index, args[2]);
   577|             println("true");
   578|         } else {
   579|             println(getList().add(args[1]));
   580|         }
   581|     }
   582|     protected void handleListSet(String[] args) {
   583|         final int index = Integer.parseInt(args[1]);
   584|         println(getList().set(index, args[2]));
   585|     }
   586|     protected void handleListAddMany(String[] args) {
   587|         int count = 1;
   588|         if (args.length > 1) {
   589|             count = Integer.parseInt(args[1]);
   590|         }

# --- HUNK 6: Lines 644-684 ---
   644|         println("true");
   645|     }
   646|     protected void handleMapEvict(String[] args) {
   647|         println(getMap().evict(args[1]));
   648|     }
   649|     protected void handleMapPutMany(String[] args) {
   650|         int count = 1;
   651|         if (args.length > 1) {
   652|             count = Integer.parseInt(args[1]);
   653|         }
   654|         int b = ONE_HUNDRED;
   655|         byte[] value = new byte[b];
   656|         if (args.length > 2) {
   657|             b = Integer.parseInt(args[2]);
   658|             value = new byte[b];
   659|         }
   660|         int start = getMap().size();
   661|         if (args.length > 3) {
   662|             start = Integer.parseInt(args[3]);
   663|         }
   664|         Map theMap = new HashMap(count);
   665|         for (int i = 0; i < count; i++) {
   666|             theMap.put("key" + (start + i), value);
   667|         }
   668|         long t0 = Clock.currentTimeMillis();
   669|         getMap().putAll(theMap);
   670|         long t1 = Clock.currentTimeMillis();
   671|         if (t1 - t0 > 1) {
   672|             println("size = " + getMap().size() + ", " + count * ONE_THOUSAND / (t1 - t0)
   673|                     + " evt/s, " + (count * ONE_THOUSAND / (t1 - t0)) * (b * BYTE_TO_BIT) / ONE_KB + " Kbit/s, "
   674|                     + count * b / ONE_KB + " KB added");
   675|         }
   676|     }
   677|     protected void handleMapGetMany(String[] args) {
   678|         int count = 1;
   679|         if (args.length > 1) {
   680|             count = Integer.parseInt(args[1]);
   681|         }
   682|         for (int i = 0; i < count; i++) {
   683|             println(getMap().get("key" + i));
   684|         }

# --- HUNK 7: Lines 824-864 ---
   824|                 currentThread().interrupt();
   825|                 locked = false;
   826|             }
   827|         }
   828|         println(locked);
   829|     }
   830|     protected void handleMultiMapUnlock(String[] args) {
   831|         getMultiMap().unlock(args[1]);
   832|         println("true");
   833|     }
   834|     private void handStats(String[] args) {
   835|         String iteratorStr = args[0];
   836|         if (iteratorStr.startsWith("m.")) {
   837|             println(getMap().getLocalMapStats());
   838|         } else if (iteratorStr.startsWith("mm.")) {
   839|             println(getMultiMap().getLocalMultiMapStats());
   840|         } else if (iteratorStr.startsWith("q.")) {
   841|             println(getQueue().getLocalQueueStats());
   842|         }
   843|     }
   844|     @SuppressWarnings("LockAcquiredButNotSafelyReleased")
   845|     protected void handleLock(String[] args) {
   846|         String lockStr = args[0];
   847|         String key = args[1];
   848|         Lock lock = hazelcast.getLock(key);
   849|         if (lockStr.equalsIgnoreCase("lock")) {
   850|             lock.lock();
   851|             println("true");
   852|         } else if (lockStr.equalsIgnoreCase("unlock")) {
   853|             lock.unlock();
   854|             println("true");
   855|         } else if (lockStr.equalsIgnoreCase("trylock")) {
   856|             String timeout = args.length > 2 ? args[2] : null;
   857|             if (timeout == null) {
   858|                 println(lock.tryLock());
   859|             } else {
   860|                 long time = Long.parseLong(timeout);
   861|                 try {
   862|                     println(lock.tryLock(time, TimeUnit.SECONDS));
   863|                 } catch (InterruptedException e) {
   864|                     e.printStackTrace();

# --- HUNK 8: Lines 1118-1158 ---
  1118|     }
  1119|     private void execute(String[] args) {
  1120|         doExecute(false, false, args);
  1121|     }
  1122|     private void executeOnKey(String[] args) {
  1123|         doExecute(true, false, args);
  1124|     }
  1125|     private void executeOnMember(String[] args) {
  1126|         doExecute(false, true, args);
  1127|     }
  1128|     private void doExecute(boolean onKey, boolean onMember, String[] args) {
  1129|         try {
  1130|             IExecutorService executorService = hazelcast.getExecutorService("default");
  1131|             Echo callable = new Echo(args[1]);
  1132|             Future<String> future;
  1133|             if (onKey) {
  1134|                 String key = args[2];
  1135|                 future = executorService.submitToKeyOwner(callable, key);
  1136|             } else if (onMember) {
  1137|                 int memberIndex = Integer.parseInt(args[2]);
  1138|                 List<Member> members = new LinkedList(hazelcast.getCluster().getMembers());
  1139|                 if (memberIndex >= members.size()) {
  1140|                     throw new IndexOutOfBoundsException("Member index: " + memberIndex + " must be smaller than " + members
  1141|                             .size());
  1142|                 }
  1143|                 Member member = members.get(memberIndex);
  1144|                 future = executorService.submitToMember(callable, member);
  1145|             } else {
  1146|                 future = executorService.submit(callable);
  1147|             }
  1148|             println("Result: " + future.get());
  1149|         } catch (InterruptedException e) {
  1150|             currentThread().interrupt();
  1151|             e.printStackTrace();
  1152|         } catch (ExecutionException e) {
  1153|             e.printStackTrace();
  1154|         }
  1155|     }
  1156|     private void executeOnMembers(String[] args) {
  1157|         try {
  1158|             IExecutorService executorService = hazelcast.getExecutorService("default");

# --- HUNK 9: Lines 1188-1230 ---
  1188|     public void mapEvicted(MapEvent event) {
  1189|         println(event);
  1190|     }
  1191|     @Override
  1192|     public void mapCleared(MapEvent event) {
  1193|         println(event);
  1194|     }
  1195|     @Override
  1196|     public void itemAdded(ItemEvent itemEvent) {
  1197|         println("Item added = " + itemEvent.getItem());
  1198|     }
  1199|     @Override
  1200|     public void itemRemoved(ItemEvent itemEvent) {
  1201|         println("Item removed = " + itemEvent.getItem());
  1202|     }
  1203|     @Override
  1204|     public void onMessage(Message msg) {
  1205|         println("Topic received = " + msg.getMessageObject());
  1206|     }
  1207|     /**
  1208|      * Handled the help command
  1209|      *
  1210|      * @param command
  1211|      */
  1212|     protected void handleHelp(String command) {
  1213|         boolean silentBefore = silent;
  1214|         silent = false;
  1215|         println("Commands:");
  1216|         printGeneralCommands();
  1217|         printQueueCommands();
  1218|         printSetCommands();
  1219|         printLockCommands();
  1220|         printMapCommands();
  1221|         printMulitiMapCommands();
  1222|         printListCommands();
  1223|         printAtomicLongCommands();
  1224|         printExecutorServiceCommands();
  1225|         silent = silentBefore;
  1226|     }
  1227|     private void printGeneralCommands() {
  1228|         println("-- General commands");
  1229|         println("echo true|false                      //turns on/off echo of commands (default false)");
  1230|         println("silent true|false                    //turns on/off silent of command output (default false)");

# --- HUNK 10: Lines 1346-1381 ---
  1346|         println("l.remove <index>");
  1347|         println("l.set <index> <string>");
  1348|         println("l.iterator [remove]");
  1349|         println("l.size");
  1350|         println("l.clear");
  1351|         print("");
  1352|     }
  1353|     public void println(Object obj) {
  1354|         if (!silent) {
  1355|             System.out.println(obj);
  1356|         }
  1357|     }
  1358|     public void print(Object obj) {
  1359|         if (!silent) {
  1360|             System.out.print(obj);
  1361|         }
  1362|     }
  1363|     /**
  1364|      * Starts the test application. Loads the config from classpath hazelcast.xml,
  1365|      * if it fails to load, will use default config.
  1366|      *
  1367|      * @param args none
  1368|      * @throws Exception
  1369|      */
  1370|     public static void main(String[] args) throws Exception {
  1371|         ClientConfig clientConfig;
  1372|         try {
  1373|             clientConfig = new XmlClientConfigBuilder().build();
  1374|         } catch (IllegalArgumentException e) {
  1375|             clientConfig = new ClientConfig();
  1376|         }
  1377|         final HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);
  1378|         ClientConsoleApp clientConsoleApp = new ClientConsoleApp(client);
  1379|         clientConsoleApp.start(args);
  1380|     }
  1381| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/impl/DefaultClientConnectionManagerFactory.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-31 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.impl;
    17| import com.hazelcast.client.connection.AddressProvider;
    18| import com.hazelcast.client.connection.AddressTranslator;
    19| import com.hazelcast.client.connection.ClientConnectionManager;
    20| import com.hazelcast.client.connection.nio.ClientConnectionManagerImpl;
    21| import java.util.Collection;
    22| public class DefaultClientConnectionManagerFactory implements ClientConnectionManagerFactory {
    23|     public DefaultClientConnectionManagerFactory() {
    24|     }
    25|     @Override
    26|     public ClientConnectionManager createConnectionManager(HazelcastClientInstanceImpl client,
    27|                                                            AddressTranslator addressTranslator,
    28|                                                            Collection<AddressProvider> addressProviders) {
    29|         return new ClientConnectionManagerImpl(client, addressTranslator, addressProviders);
    30|     }
    31| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/impl/querycache/subscriber/ClientInvokerWrapper.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.impl.querycache.subscriber;
    17| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.spi.ClientContext;
    20| import com.hazelcast.client.spi.impl.ClientInvocation;
    21| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    22| import com.hazelcast.map.impl.querycache.InvokerWrapper;
    23| import com.hazelcast.map.impl.querycache.QueryCacheContext;
    24| import com.hazelcast.nio.Address;
    25| import com.hazelcast.spi.Operation;
    26| import java.util.concurrent.Future;
    27| import static com.hazelcast.util.ExceptionUtil.rethrow;
    28| import static com.hazelcast.util.Preconditions.checkNotNegative;
    29| import static com.hazelcast.util.Preconditions.checkNotNull;
    30| /**
    31|  * Invocation functionality for client-side {@link QueryCacheContext}.
    32|  *
    33|  * @see InvokerWrapper
    34|  */
    35| public class ClientInvokerWrapper implements InvokerWrapper {
    36|     private final QueryCacheContext context;
    37|     private final ClientContext clientContext;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/impl/querycache/subscriber/ClientQueryCacheEventService.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 173-217 ---
   173|         if (queryCacheToListenerMap != null) {
   174|             queryCacheToListenerMap.removeAllListeners(cacheId);
   175|         }
   176|     }
   177|     /**
   178|      * Query cache event handler.
   179|      */
   180|     private final class QueryCacheHandler extends ContinuousQueryAddListenerCodec.AbstractEventHandler
   181|             implements EventHandler<ClientMessage> {
   182|         private final ListenerAdapter adapter;
   183|         private QueryCacheHandler(ListenerAdapter adapter) {
   184|             this.adapter = adapter;
   185|         }
   186|         @Override
   187|         public void beforeListenerRegister() {
   188|         }
   189|         @Override
   190|         public void onListenerRegister() {
   191|         }
   192|         @Override
   193|         public void handle(QueryCacheEventData data) {
   194|             adapter.onEvent(new SingleIMapEvent(data));
   195|         }
   196|         @Override
   197|         public void handle(Collection<QueryCacheEventData> events, String source, int partitionId) {
   198|             adapter.onEvent(new BatchIMapEvent(new BatchEventData(events, source, partitionId)));
   199|         }
   200|     }
   201|     private Collection<ListenerInfo> getListeners(String mapName, String cacheName) {
   202|         QueryCacheToListenerMapper queryCacheToListenerMapper = registrations.get(mapName);
   203|         if (queryCacheToListenerMapper == null) {
   204|             return Collections.emptySet();
   205|         }
   206|         return queryCacheToListenerMapper.getListenerInfos(cacheName);
   207|     }
   208|     /**
   209|      * Dispatches an event to a listener.
   210|      */
   211|     private static class EventDispatcher implements StripedRunnable, TimeoutRunnable {
   212|         private final Object event;
   213|         private final ListenerInfo listenerInfo;
   214|         private final int orderKey;
   215|         private final long timeoutMs;
   216|         private final SerializationService serializationService;
   217|         public EventDispatcher(Object event, ListenerInfo listenerInfo, int orderKey,


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/impl/statistics/Statistics.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-53 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.impl.statistics;
    17| import com.hazelcast.client.connection.nio.ClientConnection;
    18| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    19| import com.hazelcast.client.impl.protocol.ClientMessage;
    20| import com.hazelcast.client.impl.protocol.codec.ClientStatisticsCodec;
    21| import com.hazelcast.client.spi.impl.ClientInvocation;
    22| import com.hazelcast.core.ClientType;
    23| import com.hazelcast.instance.BuildInfo;
    24| import com.hazelcast.instance.BuildInfoProvider;
    25| import com.hazelcast.internal.metrics.MetricsRegistry;
    26| import com.hazelcast.internal.metrics.Gauge;
    27| import com.hazelcast.internal.nearcache.NearCache;
    28| import com.hazelcast.logging.ILogger;
    29| import com.hazelcast.logging.Logger;
    30| import com.hazelcast.monitor.NearCacheStats;
    31| import com.hazelcast.nio.Address;
    32| import com.hazelcast.security.Credentials;
    33| import com.hazelcast.security.UsernamePasswordCredentials;
    34| import com.hazelcast.spi.properties.HazelcastProperties;
    35| import com.hazelcast.spi.properties.HazelcastProperty;
    36| import java.util.ArrayList;
    37| import java.util.List;
    38| import static java.lang.String.format;
    39| import static java.util.concurrent.TimeUnit.SECONDS;
    40| /**
    41|  * This class is the main entry point for collecting and sending the client
    42|  * statistics to the cluster. If the client statistics feature is enabled,
    43|  * it will be scheduled for periodic statistics collection and sent.
    44|  */
    45| public class Statistics {
    46|     /**
    47|      * Use to enable the client statistics collection.
    48|      * <p>
    49|      * The default is false.
    50|      */
    51|     public static final HazelcastProperty ENABLED = new HazelcastProperty("hazelcast.client.statistics.enabled", false);
    52|     /**
    53|      * The period in seconds the statistics run.

# --- HUNK 2: Lines 125-176 ---
   125|         client.getClientExecutionService().scheduleWithRepetition(new Runnable() {
   126|             @Override
   127|             public void run() {
   128|                 ClientConnection ownerConnection = getOwnerConnection();
   129|                 if (null == ownerConnection) {
   130|                     logger.finest("Can not send client statistics to the server. No owner connection.");
   131|                     return;
   132|                 }
   133|                 final StringBuilder stats = new StringBuilder();
   134|                 periodicStats.fillMetrics(stats, ownerConnection);
   135|                 addNearCacheStats(stats);
   136|                 sendStats(stats.toString(), ownerConnection);
   137|             }
   138|         }, 0, periodSeconds, SECONDS);
   139|     }
   140|     private void addNearCacheStats(final StringBuilder stats) {
   141|         for (NearCache nearCache : client.getNearCacheManager().listAllNearCaches()) {
   142|             String nearCacheName = nearCache.getName();
   143|             StringBuilder nearCacheNameWithPrefix = getNameWithPrefix(nearCacheName);
   144|             nearCacheNameWithPrefix.append('.');
   145|             NearCacheStats nearCacheStats = nearCache.getNearCacheStats();
   146|             String prefix = nearCacheNameWithPrefix.toString();
   147|             addStat(stats, prefix, "creationTime", nearCacheStats.getCreationTime());
   148|             addStat(stats, prefix, "evictions", nearCacheStats.getEvictions());
   149|             addStat(stats, prefix, "hits", nearCacheStats.getHits());
   150|             addStat(stats, prefix, "lastPersistenceDuration", nearCacheStats.getLastPersistenceDuration());
   151|             addStat(stats, prefix, "lastPersistenceKeyCount", nearCacheStats.getLastPersistenceKeyCount());
   152|             addStat(stats, prefix, "lastPersistenceTime", nearCacheStats.getLastPersistenceTime());
   153|             addStat(stats, prefix, "lastPersistenceWrittenBytes", nearCacheStats.getLastPersistenceWrittenBytes());
   154|             addStat(stats, prefix, "misses", nearCacheStats.getMisses());
   155|             addStat(stats, prefix, "ownedEntryCount", nearCacheStats.getOwnedEntryCount());
   156|             addStat(stats, prefix, "expirations", nearCacheStats.getExpirations());
   157|             addStat(stats, prefix, "ownedEntryMemoryCost", nearCacheStats.getOwnedEntryMemoryCost());
   158|             String persistenceFailure = nearCacheStats.getLastPersistenceFailure();
   159|             if (persistenceFailure != null && !persistenceFailure.isEmpty()) {
   160|                 addStat(stats, prefix, "lastPersistenceFailure", persistenceFailure);
   161|             }
   162|         }
   163|     }
   164|     private void addStat(final StringBuilder stats, final String name, long value) {
   165|         addStat(stats, null, name, value);
   166|     }
   167|     private void addStat(final StringBuilder stats, final String keyPrefix, final String name, long value) {
   168|         stats.append(STAT_SEPARATOR);
   169|         if (null != keyPrefix) {
   170|             stats.append(keyPrefix);
   171|         }
   172|         stats.append(name).append(KEY_VALUE_SEPARATOR).append(value);
   173|     }
   174|     private void addStat(StringBuilder stats, String name, String value) {
   175|         addStat(stats, null, name, value);
   176|     }

# --- HUNK 3: Lines 290-320 ---
   290|                     metricsRegistry.newLongGauge("os.totalPhysicalMemorySize"),
   291|                     metricsRegistry.newLongGauge("os.totalSwapSpaceSize"),
   292|                     metricsRegistry.newLongGauge("runtime.availableProcessors"),
   293|                     metricsRegistry.newLongGauge("runtime.freeMemory"),
   294|                     metricsRegistry.newLongGauge("runtime.maxMemory"),
   295|                     metricsRegistry.newLongGauge("runtime.totalMemory"),
   296|                     metricsRegistry.newLongGauge("runtime.uptime"),
   297|                     metricsRegistry.newLongGauge("runtime.usedMemory"),
   298|                     metricsRegistry.newLongGauge("executionService.userExecutorQueueSize"),
   299|                 };
   300|         void fillMetrics(final StringBuilder stats, final ClientConnection ownerConnection) {
   301|             stats.append("lastStatisticsCollectionTime").append(KEY_VALUE_SEPARATOR).append(System.currentTimeMillis());
   302|             addStat(stats, "enterprise", enterprise);
   303|             addStat(stats, "clientType", ClientType.JAVA.toString());
   304|             addStat(stats, "clientVersion", BuildInfoProvider.getBuildInfo().getVersion());
   305|             addStat(stats, "clusterConnectionTimestamp", ownerConnection.getStartTime());
   306|             stats.append(STAT_SEPARATOR).append("clientAddress").append(KEY_VALUE_SEPARATOR)
   307|                  .append(ownerConnection.getLocalSocketAddress().getAddress().getHostAddress()).append(":")
   308|                  .append(ownerConnection.getLocalSocketAddress().getPort());
   309|             addStat(stats, "clientName", client.getName());
   310|             Credentials credentials = client.getCredentials();
   311|             if (!(credentials instanceof UsernamePasswordCredentials)) {
   312|                 addStat(stats, "credentials.principal", credentials.getPrincipal());
   313|             }
   314|             for (Gauge gauge : allGauges) {
   315|                 stats.append(STAT_SEPARATOR).append(gauge.getName()).append(KEY_VALUE_SEPARATOR);
   316|                 gauge.render(stats);
   317|             }
   318|         }
   319|     }
   320| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/map/impl/ClientMapPartitionIterator.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.map.impl;
    17| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.codec.MapFetchEntriesCodec;
    20| import com.hazelcast.client.impl.protocol.codec.MapFetchKeysCodec;
    21| import com.hazelcast.client.proxy.ClientMapProxy;
    22| import com.hazelcast.client.spi.ClientContext;
    23| import com.hazelcast.client.spi.impl.ClientInvocation;
    24| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    25| import com.hazelcast.core.IMap;
    26| import com.hazelcast.map.impl.iterator.AbstractMapPartitionIterator;
    27| import com.hazelcast.spi.serialization.SerializationService;
    28| import com.hazelcast.util.ExceptionUtil;
    29| import java.util.List;
    30| /**
    31|  * Iterator for iterating map entries in the {@code partitionId}. The values are not fetched one-by-one but rather in batches.
    32|  * <b>NOTE</b>
    33|  * Iterating the map should be done only when the {@link IMap} is not being
    34|  * mutated and the cluster is stable (there are no migrations or membership changes).
    35|  * In other cases, the iterator may not return some entries or may return an entry twice.
    36|  */
    37| public class ClientMapPartitionIterator<K, V> extends AbstractMapPartitionIterator<K, V> {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/map/impl/ClientMapQueryPartitionIterator.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.map.impl;
    17| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.codec.MapFetchWithQueryCodec;
    20| import com.hazelcast.client.proxy.ClientMapProxy;
    21| import com.hazelcast.client.spi.ClientContext;
    22| import com.hazelcast.client.spi.impl.ClientInvocation;
    23| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    24| import com.hazelcast.core.IMap;
    25| import com.hazelcast.map.impl.iterator.AbstractMapQueryPartitionIterator;
    26| import com.hazelcast.nio.serialization.Data;
    27| import com.hazelcast.projection.Projection;
    28| import com.hazelcast.query.Predicate;
    29| import com.hazelcast.spi.serialization.SerializationService;
    30| import com.hazelcast.util.ExceptionUtil;
    31| import java.util.Iterator;
    32| import java.util.List;
    33| import java.util.Map.Entry;
    34| /**
    35|  * Iterator for iterating map entries in the {@code partitionId}. The values are not fetched one-by-one but rather in batches.
    36|  * The {@link Iterator#remove()} method is not supported and will throw an {@link UnsupportedOperationException}.
    37|  * <b>NOTE</b>


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientAtomicLongProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.client.impl.ClientMessageDecoder;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.codec.AtomicLongAddAndGetCodec;
    20| import com.hazelcast.client.impl.protocol.codec.AtomicLongAlterAndGetCodec;
    21| import com.hazelcast.client.impl.protocol.codec.AtomicLongAlterCodec;
    22| import com.hazelcast.client.impl.protocol.codec.AtomicLongApplyCodec;
    23| import com.hazelcast.client.impl.protocol.codec.AtomicLongCompareAndSetCodec;
    24| import com.hazelcast.client.impl.protocol.codec.AtomicLongDecrementAndGetCodec;
    25| import com.hazelcast.client.impl.protocol.codec.AtomicLongGetAndAddCodec;
    26| import com.hazelcast.client.impl.protocol.codec.AtomicLongGetAndAlterCodec;
    27| import com.hazelcast.client.impl.protocol.codec.AtomicLongGetAndIncrementCodec;
    28| import com.hazelcast.client.impl.protocol.codec.AtomicLongGetAndSetCodec;
    29| import com.hazelcast.client.impl.protocol.codec.AtomicLongGetCodec;
    30| import com.hazelcast.client.impl.protocol.codec.AtomicLongIncrementAndGetCodec;
    31| import com.hazelcast.client.impl.protocol.codec.AtomicLongSetCodec;
    32| import com.hazelcast.client.spi.ClientContext;
    33| import com.hazelcast.core.IAtomicLong;
    34| import com.hazelcast.core.IFunction;
    35| import com.hazelcast.spi.InternalCompletableFuture;
    36| import static com.hazelcast.util.Preconditions.isNotNull;
    37| /**


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientAtomicReferenceProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.client.impl.ClientMessageDecoder;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.codec.AtomicReferenceAlterAndGetCodec;
    20| import com.hazelcast.client.impl.protocol.codec.AtomicReferenceAlterCodec;
    21| import com.hazelcast.client.impl.protocol.codec.AtomicReferenceApplyCodec;
    22| import com.hazelcast.client.impl.protocol.codec.AtomicReferenceClearCodec;
    23| import com.hazelcast.client.impl.protocol.codec.AtomicReferenceCompareAndSetCodec;
    24| import com.hazelcast.client.impl.protocol.codec.AtomicReferenceContainsCodec;
    25| import com.hazelcast.client.impl.protocol.codec.AtomicReferenceGetAndAlterCodec;
    26| import com.hazelcast.client.impl.protocol.codec.AtomicReferenceGetAndSetCodec;
    27| import com.hazelcast.client.impl.protocol.codec.AtomicReferenceGetCodec;
    28| import com.hazelcast.client.impl.protocol.codec.AtomicReferenceIsNullCodec;
    29| import com.hazelcast.client.impl.protocol.codec.AtomicReferenceSetAndGetCodec;
    30| import com.hazelcast.client.impl.protocol.codec.AtomicReferenceSetCodec;
    31| import com.hazelcast.client.spi.ClientContext;
    32| import com.hazelcast.core.IAtomicReference;
    33| import com.hazelcast.core.IFunction;
    34| import com.hazelcast.spi.InternalCompletableFuture;
    35| import static com.hazelcast.util.Preconditions.isNotNull;
    36| /**
    37|  * Proxy implementation of {@link IAtomicReference}.


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientCardinalityEstimatorProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.cardinality.CardinalityEstimator;
    18| import com.hazelcast.client.impl.ClientMessageDecoder;
    19| import com.hazelcast.client.impl.protocol.ClientMessage;
    20| import com.hazelcast.client.impl.protocol.codec.CardinalityEstimatorAddCodec;
    21| import com.hazelcast.client.impl.protocol.codec.CardinalityEstimatorEstimateCodec;
    22| import com.hazelcast.client.spi.ClientContext;
    23| import com.hazelcast.nio.serialization.Data;
    24| import com.hazelcast.spi.InternalCompletableFuture;
    25| import static com.hazelcast.util.Preconditions.checkNotNull;
    26| /**
    27|  * Proxy implementation of {@link CardinalityEstimator}.
    28|  */
    29| public class ClientCardinalityEstimatorProxy
    30|         extends PartitionSpecificClientProxy implements CardinalityEstimator {
    31|     private static final ClientMessageDecoder ADD_DECODER = new ClientMessageDecoder() {
    32|         @Override
    33|         public Void decodeClientMessage(ClientMessage clientMessage) {
    34|             return null;
    35|         }
    36|     };
    37|     private static final ClientMessageDecoder ESTIMATE_DECODER = new ClientMessageDecoder() {
    38|         @Override


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientConditionProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.client.impl.ClientLockReferenceIdGenerator;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.codec.ConditionAwaitCodec;
    20| import com.hazelcast.client.impl.protocol.codec.ConditionBeforeAwaitCodec;
    21| import com.hazelcast.client.impl.protocol.codec.ConditionSignalAllCodec;
    22| import com.hazelcast.client.impl.protocol.codec.ConditionSignalCodec;
    23| import com.hazelcast.client.spi.ClientContext;
    24| import com.hazelcast.concurrent.lock.LockService;
    25| import com.hazelcast.core.ICondition;
    26| import com.hazelcast.util.Clock;
    27| import com.hazelcast.util.ThreadUtil;
    28| import java.util.Date;
    29| import java.util.concurrent.TimeUnit;
    30| import static com.hazelcast.util.ExceptionUtil.sneakyThrow;
    31| /**
    32|  * Proxy implementation of {@link ICondition}.
    33|  */
    34| public class ClientConditionProxy extends PartitionSpecificClientProxy implements ICondition {
    35|     private final String conditionId;
    36|     private ClientLockReferenceIdGenerator referenceIdGenerator;
    37|     public ClientConditionProxy(ClientLockProxy clientLockProxy, String name, ClientContext context) {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientDurableExecutorServiceProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.client.impl.ClientMessageDecoder;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.codec.DurableExecutorDisposeResultCodec;
    20| import com.hazelcast.client.impl.protocol.codec.DurableExecutorIsShutdownCodec;
    21| import com.hazelcast.client.impl.protocol.codec.DurableExecutorRetrieveAndDisposeResultCodec;
    22| import com.hazelcast.client.impl.protocol.codec.DurableExecutorRetrieveResultCodec;
    23| import com.hazelcast.client.impl.protocol.codec.DurableExecutorShutdownCodec;
    24| import com.hazelcast.client.impl.protocol.codec.DurableExecutorSubmitToPartitionCodec;
    25| import com.hazelcast.client.spi.ClientContext;
    26| import com.hazelcast.client.spi.ClientPartitionService;
    27| import com.hazelcast.client.spi.ClientProxy;
    28| import com.hazelcast.client.spi.impl.ClientInvocation;
    29| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    30| import com.hazelcast.client.util.ClientDelegatingFuture;
    31| import com.hazelcast.core.ExecutionCallback;
    32| import com.hazelcast.core.PartitionAware;
    33| import com.hazelcast.durableexecutor.DurableExecutorService;
    34| import com.hazelcast.durableexecutor.DurableExecutorServiceFuture;
    35| import com.hazelcast.executor.impl.RunnableAdapter;
    36| import com.hazelcast.nio.Bits;
    37| import com.hazelcast.spi.serialization.SerializationService;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientExecutorServiceProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.client.impl.ClientMessageDecoder;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.codec.ExecutorServiceIsShutdownCodec;
    20| import com.hazelcast.client.impl.protocol.codec.ExecutorServiceShutdownCodec;
    21| import com.hazelcast.client.impl.protocol.codec.ExecutorServiceSubmitToAddressCodec;
    22| import com.hazelcast.client.impl.protocol.codec.ExecutorServiceSubmitToPartitionCodec;
    23| import com.hazelcast.client.spi.ClientContext;
    24| import com.hazelcast.client.spi.ClientPartitionService;
    25| import com.hazelcast.client.spi.ClientProxy;
    26| import com.hazelcast.client.spi.impl.ClientInvocation;
    27| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    28| import com.hazelcast.client.util.ClientDelegatingFuture;
    29| import com.hazelcast.core.ExecutionCallback;
    30| import com.hazelcast.core.HazelcastException;
    31| import com.hazelcast.core.IExecutorService;
    32| import com.hazelcast.core.Member;
    33| import com.hazelcast.core.MemberSelector;
    34| import com.hazelcast.core.MultiExecutionCallback;
    35| import com.hazelcast.core.PartitionAware;
    36| import com.hazelcast.executor.impl.RunnableAdapter;
    37| import com.hazelcast.monitor.LocalExecutorStats;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientListProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 273-310 ---
   273|     }
   274|     @Override
   275|     public List<E> subList(int fromIndex, int toIndex) {
   276|         ClientMessage request = ListSubCodec.encodeRequest(name, fromIndex, toIndex);
   277|         ClientMessage response = invokeOnPartition(request);
   278|         ListSubCodec.ResponseParameters resultParameters = ListSubCodec.decodeResponse(response);
   279|         List<Data> resultCollection = resultParameters.response;
   280|         return new UnmodifiableLazyList<E>(resultCollection, getSerializationService());
   281|     }
   282|     @Override
   283|     public String toString() {
   284|         return "IList{" + "name='" + name + '\'' + '}';
   285|     }
   286|     private class ItemEventHandler extends ListAddListenerCodec.AbstractEventHandler
   287|             implements EventHandler<ClientMessage> {
   288|         private final ItemListener<E> listener;
   289|         public ItemEventHandler(ItemListener<E> listener) {
   290|             this.listener = listener;
   291|         }
   292|         @Override
   293|         public void handle(Data dataItem, String uuid, int eventType) {
   294|             Member member = getContext().getClusterService().getMember(uuid);
   295|             ItemEvent<E> itemEvent = new DataAwareItemEvent(name, ItemEventType.getByType(eventType),
   296|                     dataItem, member, getSerializationService());
   297|             if (eventType == ItemEventType.ADDED.getType()) {
   298|                 listener.itemAdded(itemEvent);
   299|             } else {
   300|                 listener.itemRemoved(itemEvent);
   301|             }
   302|         }
   303|         @Override
   304|         public void beforeListenerRegister() {
   305|         }
   306|         @Override
   307|         public void onListenerRegister() {
   308|         }
   309|     }
   310| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientLockProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.client.impl.ClientLockReferenceIdGenerator;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.codec.LockForceUnlockCodec;
    20| import com.hazelcast.client.impl.protocol.codec.LockGetLockCountCodec;
    21| import com.hazelcast.client.impl.protocol.codec.LockGetRemainingLeaseTimeCodec;
    22| import com.hazelcast.client.impl.protocol.codec.LockIsLockedByCurrentThreadCodec;
    23| import com.hazelcast.client.impl.protocol.codec.LockIsLockedCodec;
    24| import com.hazelcast.client.impl.protocol.codec.LockLockCodec;
    25| import com.hazelcast.client.impl.protocol.codec.LockTryLockCodec;
    26| import com.hazelcast.client.impl.protocol.codec.LockUnlockCodec;
    27| import com.hazelcast.client.spi.ClientContext;
    28| import com.hazelcast.core.ICondition;
    29| import com.hazelcast.core.ILock;
    30| import com.hazelcast.util.ThreadUtil;
    31| import java.util.concurrent.TimeUnit;
    32| import java.util.concurrent.locks.Condition;
    33| import static com.hazelcast.util.Preconditions.checkNotNull;
    34| import static com.hazelcast.util.Preconditions.checkPositive;
    35| import static java.lang.Thread.currentThread;
    36| /**
    37|  * Proxy implementation of {@link ILock}.


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientMapProxy.java
# Total hunks: 16
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.aggregation.Aggregator;
    18| import com.hazelcast.client.impl.ClientLockReferenceIdGenerator;
    19| import com.hazelcast.client.impl.ClientMessageDecoder;
    20| import com.hazelcast.client.impl.protocol.ClientMessage;
    21| import com.hazelcast.client.impl.protocol.codec.MapAddEntryListenerCodec;
    22| import com.hazelcast.client.impl.protocol.codec.MapAddEntryListenerToKeyCodec;
    23| import com.hazelcast.client.impl.protocol.codec.MapAddEntryListenerToKeyWithPredicateCodec;
    24| import com.hazelcast.client.impl.protocol.codec.MapAddEntryListenerWithPredicateCodec;
    25| import com.hazelcast.client.impl.protocol.codec.MapAddIndexCodec;
    26| import com.hazelcast.client.impl.protocol.codec.MapAddInterceptorCodec;
    27| import com.hazelcast.client.impl.protocol.codec.MapAddPartitionLostListenerCodec;
    28| import com.hazelcast.client.impl.protocol.codec.MapAggregateCodec;
    29| import com.hazelcast.client.impl.protocol.codec.MapAggregateWithPredicateCodec;
    30| import com.hazelcast.client.impl.protocol.codec.MapClearCodec;
    31| import com.hazelcast.client.impl.protocol.codec.MapContainsKeyCodec;
    32| import com.hazelcast.client.impl.protocol.codec.MapContainsValueCodec;
    33| import com.hazelcast.client.impl.protocol.codec.MapDeleteCodec;
    34| import com.hazelcast.client.impl.protocol.codec.MapEntriesWithPagingPredicateCodec;
    35| import com.hazelcast.client.impl.protocol.codec.MapEntriesWithPredicateCodec;
    36| import com.hazelcast.client.impl.protocol.codec.MapEntrySetCodec;
    37| import com.hazelcast.client.impl.protocol.codec.MapEventJournalReadCodec;
    38| import com.hazelcast.client.impl.protocol.codec.MapEventJournalSubscribeCodec;
    39| import com.hazelcast.client.impl.protocol.codec.MapEventJournalSubscribeCodec.ResponseParameters;

# --- HUNK 2: Lines 44-129 ---
    44| import com.hazelcast.client.impl.protocol.codec.MapExecuteOnKeysCodec;
    45| import com.hazelcast.client.impl.protocol.codec.MapExecuteWithPredicateCodec;
    46| import com.hazelcast.client.impl.protocol.codec.MapFlushCodec;
    47| import com.hazelcast.client.impl.protocol.codec.MapForceUnlockCodec;
    48| import com.hazelcast.client.impl.protocol.codec.MapGetAllCodec;
    49| import com.hazelcast.client.impl.protocol.codec.MapGetCodec;
    50| import com.hazelcast.client.impl.protocol.codec.MapGetEntryViewCodec;
    51| import com.hazelcast.client.impl.protocol.codec.MapIsEmptyCodec;
    52| import com.hazelcast.client.impl.protocol.codec.MapIsLockedCodec;
    53| import com.hazelcast.client.impl.protocol.codec.MapKeySetCodec;
    54| import com.hazelcast.client.impl.protocol.codec.MapKeySetWithPagingPredicateCodec;
    55| import com.hazelcast.client.impl.protocol.codec.MapKeySetWithPredicateCodec;
    56| import com.hazelcast.client.impl.protocol.codec.MapLoadAllCodec;
    57| import com.hazelcast.client.impl.protocol.codec.MapLoadGivenKeysCodec;
    58| import com.hazelcast.client.impl.protocol.codec.MapLockCodec;
    59| import com.hazelcast.client.impl.protocol.codec.MapProjectCodec;
    60| import com.hazelcast.client.impl.protocol.codec.MapProjectWithPredicateCodec;
    61| import com.hazelcast.client.impl.protocol.codec.MapPutAllCodec;
    62| import com.hazelcast.client.impl.protocol.codec.MapPutCodec;
    63| import com.hazelcast.client.impl.protocol.codec.MapPutIfAbsentCodec;
    64| import com.hazelcast.client.impl.protocol.codec.MapPutTransientCodec;
    65| import com.hazelcast.client.impl.protocol.codec.MapRemoveAllCodec;
    66| import com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;
    67| import com.hazelcast.client.impl.protocol.codec.MapRemoveEntryListenerCodec;
    68| import com.hazelcast.client.impl.protocol.codec.MapRemoveIfSameCodec;
    69| import com.hazelcast.client.impl.protocol.codec.MapRemoveInterceptorCodec;
    70| import com.hazelcast.client.impl.protocol.codec.MapRemovePartitionLostListenerCodec;
    71| import com.hazelcast.client.impl.protocol.codec.MapReplaceCodec;
    72| import com.hazelcast.client.impl.protocol.codec.MapReplaceIfSameCodec;
    73| import com.hazelcast.client.impl.protocol.codec.MapSetCodec;
    74| import com.hazelcast.client.impl.protocol.codec.MapSizeCodec;
    75| import com.hazelcast.client.impl.protocol.codec.MapSubmitToKeyCodec;
    76| import com.hazelcast.client.impl.protocol.codec.MapTryLockCodec;
    77| import com.hazelcast.client.impl.protocol.codec.MapTryPutCodec;
    78| import com.hazelcast.client.impl.protocol.codec.MapTryRemoveCodec;
    79| import com.hazelcast.client.impl.protocol.codec.MapUnlockCodec;
    80| import com.hazelcast.client.impl.protocol.codec.MapValuesCodec;
    81| import com.hazelcast.client.impl.protocol.codec.MapValuesWithPagingPredicateCodec;
    82| import com.hazelcast.client.impl.protocol.codec.MapValuesWithPredicateCodec;
    83| import com.hazelcast.client.impl.querycache.ClientQueryCacheContext;
    84| import com.hazelcast.client.impl.querycache.subscriber.ClientQueryCacheEndToEndConstructor;
    85| import com.hazelcast.client.map.impl.ClientMapPartitionIterator;
    86| import com.hazelcast.client.map.impl.ClientMapQueryPartitionIterator;
    87| import com.hazelcast.client.spi.ClientContext;
    88| import com.hazelcast.client.spi.ClientPartitionService;
    89| import com.hazelcast.client.spi.ClientProxy;
    90| import com.hazelcast.client.spi.EventHandler;
    91| import com.hazelcast.client.spi.impl.ClientInvocation;
    92| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    93| import com.hazelcast.client.spi.impl.ListenerMessageCodec;
    94| import com.hazelcast.client.util.ClientDelegatingFuture;
    95| import com.hazelcast.core.EntryEvent;
    96| import com.hazelcast.core.EntryEventType;
    97| import com.hazelcast.core.EntryListener;
    98| import com.hazelcast.core.EntryView;
    99| import com.hazelcast.core.ExecutionCallback;
   100| import com.hazelcast.core.HazelcastException;
   101| import com.hazelcast.core.ICompletableFuture;
   102| import com.hazelcast.core.IMap;
   103| import com.hazelcast.core.IMapEvent;
   104| import com.hazelcast.core.MapEvent;
   105| import com.hazelcast.core.Member;
   106| import com.hazelcast.core.ReadOnly;
   107| import com.hazelcast.internal.journal.EventJournalInitialSubscriberState;
   108| import com.hazelcast.internal.journal.EventJournalReader;
   109| import com.hazelcast.internal.serialization.InternalSerializationService;
   110| import com.hazelcast.map.EntryBackupProcessor;
   111| import com.hazelcast.map.EntryProcessor;
   112| import com.hazelcast.map.MapInterceptor;
   113| import com.hazelcast.map.MapPartitionLostEvent;
   114| import com.hazelcast.map.QueryCache;
   115| import com.hazelcast.map.impl.DataAwareEntryEvent;
   116| import com.hazelcast.map.impl.LazyMapEntry;
   117| import com.hazelcast.map.impl.ListenerAdapter;
   118| import com.hazelcast.map.impl.SimpleEntryView;
   119| import com.hazelcast.map.impl.querycache.subscriber.QueryCacheEndToEndProvider;
   120| import com.hazelcast.map.impl.querycache.subscriber.QueryCacheRequest;
   121| import com.hazelcast.map.impl.querycache.subscriber.SubscriberContext;
   122| import com.hazelcast.map.journal.EventJournalMapEvent;
   123| import com.hazelcast.map.listener.MapListener;
   124| import com.hazelcast.map.listener.MapPartitionLostListener;
   125| import com.hazelcast.mapreduce.Collator;
   126| import com.hazelcast.mapreduce.CombinerFactory;
   127| import com.hazelcast.mapreduce.Job;
   128| import com.hazelcast.mapreduce.JobTracker;
   129| import com.hazelcast.mapreduce.KeyValueSource;

# --- HUNK 3: Lines 134-192 ---
   134| import com.hazelcast.mapreduce.aggregation.Aggregation;
   135| import com.hazelcast.mapreduce.aggregation.Supplier;
   136| import com.hazelcast.monitor.LocalMapStats;
   137| import com.hazelcast.monitor.impl.LocalMapStatsImpl;
   138| import com.hazelcast.nio.serialization.Data;
   139| import com.hazelcast.projection.Projection;
   140| import com.hazelcast.query.PagingPredicate;
   141| import com.hazelcast.query.PartitionPredicate;
   142| import com.hazelcast.query.Predicate;
   143| import com.hazelcast.ringbuffer.ReadResultSet;
   144| import com.hazelcast.ringbuffer.impl.client.PortableReadResultSet;
   145| import com.hazelcast.spi.impl.UnmodifiableLazyList;
   146| import com.hazelcast.spi.serialization.SerializationService;
   147| import com.hazelcast.util.CollectionUtil;
   148| import com.hazelcast.util.IterationType;
   149| import com.hazelcast.util.Preconditions;
   150| import com.hazelcast.util.collection.InflatableSet;
   151| import java.util.AbstractMap;
   152| import java.util.ArrayList;
   153| import java.util.Collection;
   154| import java.util.HashMap;
   155| import java.util.Iterator;
   156| import java.util.List;
   157| import java.util.Map;
   158| import java.util.Set;
   159| import java.util.concurrent.Future;
   160| import java.util.concurrent.TimeUnit;
   161| import static com.hazelcast.map.impl.ListenerAdapters.createListenerAdapter;
   162| import static com.hazelcast.map.impl.MapListenerFlagOperator.setAndGetListenerFlags;
   163| import static com.hazelcast.map.impl.querycache.subscriber.QueryCacheRequest.newQueryCacheRequest;
   164| import static com.hazelcast.util.CollectionUtil.objectToDataCollection;
   165| import static com.hazelcast.util.ExceptionUtil.rethrow;
   166| import static com.hazelcast.util.MapUtil.createHashMap;
   167| import static com.hazelcast.util.Preconditions.checkNotInstanceOf;
   168| import static com.hazelcast.util.Preconditions.checkNotNull;
   169| import static com.hazelcast.util.SortingUtil.getSortedQueryResultSet;
   170| import static com.hazelcast.util.ThreadUtil.getThreadId;
   171| import static java.lang.Thread.currentThread;
   172| import static java.util.Collections.emptyMap;
   173| /**
   174|  * Proxy implementation of {@link IMap}.
   175|  *
   176|  * @param <K> key
   177|  * @param <V> value
   178|  */
   179| @SuppressWarnings("checkstyle:classdataabstractioncoupling")
   180| public class ClientMapProxy<K, V> extends ClientProxy
   181|         implements IMap<K, V>, EventJournalReader<EventJournalMapEvent<K, V>> {
   182|     protected static final String NULL_LISTENER_IS_NOT_ALLOWED = "Null listener is not allowed!";
   183|     protected static final String NULL_KEY_IS_NOT_ALLOWED = "Null key is not allowed!";
   184|     protected static final String NULL_VALUE_IS_NOT_ALLOWED = "Null value is not allowed!";
   185|     protected static final String NULL_PREDICATE_IS_NOT_ALLOWED = "Predicate should not be null!";
   186|     protected static final String NULL_AGGREGATOR_IS_NOT_ALLOWED = "Aggregator should not be null!";
   187|     protected static final String NULL_PROJECTION_IS_NOT_ALLOWED = "Projection should not be null!";
   188|     @SuppressWarnings("unchecked")
   189|     private static final ClientMessageDecoder GET_ASYNC_RESPONSE_DECODER = new ClientMessageDecoder() {
   190|         @Override
   191|         public <T> T decodeClientMessage(ClientMessage clientMessage) {
   192|             return (T) MapGetCodec.decodeResponse(clientMessage).response;

# --- HUNK 4: Lines 203-242 ---
   203|     private static final ClientMessageDecoder SET_ASYNC_RESPONSE_DECODER = new ClientMessageDecoder() {
   204|         @Override
   205|         public <T> T decodeClientMessage(ClientMessage clientMessage) {
   206|             return null;
   207|         }
   208|     };
   209|     @SuppressWarnings("unchecked")
   210|     private static final ClientMessageDecoder REMOVE_ASYNC_RESPONSE_DECODER = new ClientMessageDecoder() {
   211|         @Override
   212|         public <T> T decodeClientMessage(ClientMessage clientMessage) {
   213|             return (T) MapRemoveCodec.decodeResponse(clientMessage).response;
   214|         }
   215|     };
   216|     @SuppressWarnings("unchecked")
   217|     private static final ClientMessageDecoder SUBMIT_TO_KEY_RESPONSE_DECODER = new ClientMessageDecoder() {
   218|         @Override
   219|         public <T> T decodeClientMessage(ClientMessage clientMessage) {
   220|             return (T) MapSubmitToKeyCodec.decodeResponse(clientMessage).response;
   221|         }
   222|     };
   223|     private ClientMessageDecoder eventJournalReadResponseDecoder;
   224|     private ClientMessageDecoder eventJournalSubscribeResponseDecoder;
   225|     private ClientLockReferenceIdGenerator lockReferenceIdGenerator;
   226|     private ClientQueryCacheContext queryCacheContext;
   227|     public ClientMapProxy(String serviceName, String name, ClientContext context) {
   228|         super(serviceName, name, context);
   229|     }
   230|     @Override
   231|     protected void onInitialize() {
   232|         super.onInitialize();
   233|         lockReferenceIdGenerator = getClient().getLockReferenceIdGenerator();
   234|         queryCacheContext = getContext().getQueryCacheContext();
   235|         eventJournalReadResponseDecoder = new ClientMessageDecoder() {
   236|             @Override
   237|             public ReadResultSet<?> decodeClientMessage(ClientMessage message) {
   238|                 final MapEventJournalReadCodec.ResponseParameters params = MapEventJournalReadCodec.decodeResponse(message);
   239|                 final PortableReadResultSet<?> resultSet = new PortableReadResultSet<Object>(
   240|                         params.readCount, params.items, params.itemSeqs,
   241|                         params.nextSeqExist ? params.nextSeq : ReadResultSet.SEQUENCE_UNAVAILABLE);
   242|                 resultSet.setSerializationService(getSerializationService());

# --- HUNK 5: Lines 269-309 ---
   269|         Data valueData = toData(value);
   270|         ClientMessage request = MapContainsValueCodec.encodeRequest(name, valueData);
   271|         ClientMessage response = invoke(request);
   272|         MapContainsValueCodec.ResponseParameters resultParameters = MapContainsValueCodec.decodeResponse(response);
   273|         return resultParameters.response;
   274|     }
   275|     @Override
   276|     public V get(Object key) {
   277|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   278|         return toObject(getInternal(key));
   279|     }
   280|     protected Object getInternal(Object key) {
   281|         Data keyData = toData(key);
   282|         ClientMessage request = MapGetCodec.encodeRequest(name, keyData, getThreadId());
   283|         ClientMessage response = invoke(request, keyData);
   284|         MapGetCodec.ResponseParameters resultParameters = MapGetCodec.decodeResponse(response);
   285|         return resultParameters.response;
   286|     }
   287|     @Override
   288|     public V put(K key, V value) {
   289|         return put(key, value, -1, TimeUnit.MILLISECONDS);
   290|     }
   291|     @Override
   292|     public V remove(Object key) {
   293|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   294|         MapRemoveCodec.ResponseParameters resultParameters = removeInternal(key);
   295|         return toObject(resultParameters.response);
   296|     }
   297|     protected MapRemoveCodec.ResponseParameters removeInternal(Object key) {
   298|         Data keyData = toData(key);
   299|         ClientMessage request = MapRemoveCodec.encodeRequest(name, keyData, getThreadId());
   300|         ClientMessage response = invoke(request, keyData);
   301|         return MapRemoveCodec.decodeResponse(response);
   302|     }
   303|     @Override
   304|     public boolean remove(Object key, Object value) {
   305|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   306|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   307|         return removeInternal(key, value);
   308|     }
   309|     protected boolean removeInternal(Object key, Object value) {

# --- HUNK 6: Lines 343-418 ---
   343|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   344|         return getAsyncInternal(key);
   345|     }
   346|     protected ICompletableFuture<V> getAsyncInternal(Object key) {
   347|         try {
   348|             Data keyData = toData(key);
   349|             ClientMessage request = MapGetCodec.encodeRequest(name, keyData, getThreadId());
   350|             ClientInvocationFuture future = invokeOnKeyOwner(request, keyData);
   351|             return new ClientDelegatingFuture<V>(future, getSerializationService(), GET_ASYNC_RESPONSE_DECODER);
   352|         } catch (Exception e) {
   353|             throw rethrow(e);
   354|         }
   355|     }
   356|     private ClientInvocationFuture invokeOnKeyOwner(ClientMessage request, Data keyData) {
   357|         int partitionId = getContext().getPartitionService().getPartitionId(keyData);
   358|         ClientInvocation clientInvocation = new ClientInvocation(getClient(), request, getName(), partitionId);
   359|         return clientInvocation.invoke();
   360|     }
   361|     @Override
   362|     public ICompletableFuture<V> putAsync(K key, V value) {
   363|         return putAsync(key, value, -1, TimeUnit.MILLISECONDS);
   364|     }
   365|     @Override
   366|     public ICompletableFuture<V> putAsync(K key, V value, long ttl, TimeUnit timeunit) {
   367|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   368|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   369|         return putAsyncInternal(ttl, timeunit, key, value);
   370|     }
   371|     protected ICompletableFuture<V> putAsyncInternal(long ttl, TimeUnit timeunit, Object key, Object value) {
   372|         try {
   373|             Data keyData = toData(key);
   374|             Data valueData = toData(value);
   375|             long ttlMillis = getTimeInMillis(ttl, timeunit);
   376|             ClientMessage request = MapPutCodec.encodeRequest(name, keyData, valueData, getThreadId(), ttlMillis);
   377|             ClientInvocationFuture future = invokeOnKeyOwner(request, keyData);
   378|             return new ClientDelegatingFuture<V>(future, getSerializationService(), PUT_ASYNC_RESPONSE_DECODER);
   379|         } catch (Exception e) {
   380|             throw rethrow(e);
   381|         }
   382|     }
   383|     @Override
   384|     public ICompletableFuture<Void> setAsync(K key, V value) {
   385|         return setAsync(key, value, -1, TimeUnit.MILLISECONDS);
   386|     }
   387|     @Override
   388|     public ICompletableFuture<Void> setAsync(K key, V value, long ttl, TimeUnit timeunit) {
   389|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   390|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   391|         return setAsyncInternal(ttl, timeunit, key, value);
   392|     }
   393|     protected ICompletableFuture<Void> setAsyncInternal(long ttl, TimeUnit timeunit, Object key, Object value) {
   394|         try {
   395|             Data keyData = toData(key);
   396|             Data valueData = toData(value);
   397|             long ttlMillis = getTimeInMillis(ttl, timeunit);
   398|             ClientMessage request = MapSetCodec.encodeRequest(name, keyData, valueData, getThreadId(), ttlMillis);
   399|             ClientInvocationFuture future = invokeOnKeyOwner(request, keyData);
   400|             return new ClientDelegatingFuture<Void>(future, getSerializationService(), SET_ASYNC_RESPONSE_DECODER);
   401|         } catch (Exception e) {
   402|             throw rethrow(e);
   403|         }
   404|     }
   405|     @Override
   406|     public ICompletableFuture<V> removeAsync(K key) {
   407|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   408|         return removeAsyncInternal(key);
   409|     }
   410|     protected ICompletableFuture<V> removeAsyncInternal(Object key) {
   411|         try {
   412|             Data keyData = toData(key);
   413|             ClientMessage request = MapRemoveCodec.encodeRequest(name, keyData, getThreadId());
   414|             ClientInvocationFuture future = invokeOnKeyOwner(request, keyData);
   415|             return new ClientDelegatingFuture<V>(future, getSerializationService(), REMOVE_ASYNC_RESPONSE_DECODER);
   416|         } catch (Exception e) {
   417|             throw rethrow(e);
   418|         }

# --- HUNK 7: Lines 421-607 ---
   421|     public boolean tryRemove(K key, long timeout, TimeUnit timeunit) {
   422|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   423|         return tryRemoveInternal(timeout, timeunit, key);
   424|     }
   425|     protected boolean tryRemoveInternal(long timeout, TimeUnit timeunit, Object key) {
   426|         Data keyData = toData(key);
   427|         ClientMessage request = MapTryRemoveCodec.encodeRequest(name, keyData, getThreadId(), timeunit.toMillis(timeout));
   428|         ClientMessage response = invoke(request, keyData);
   429|         MapTryRemoveCodec.ResponseParameters resultParameters = MapTryRemoveCodec.decodeResponse(response);
   430|         return resultParameters.response;
   431|     }
   432|     @Override
   433|     public boolean tryPut(K key, V value, long timeout, TimeUnit timeunit) {
   434|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   435|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   436|         return tryPutInternal(timeout, timeunit, key, value);
   437|     }
   438|     protected boolean tryPutInternal(long timeout, TimeUnit timeunit, Object key, Object value) {
   439|         Data keyData = toData(key);
   440|         Data valueData = toData(value);
   441|         long timeoutMillis = getTimeInMillis(timeout, timeunit);
   442|         ClientMessage request = MapTryPutCodec.encodeRequest(name, keyData, valueData, getThreadId(), timeoutMillis);
   443|         ClientMessage response = invoke(request, keyData);
   444|         MapTryPutCodec.ResponseParameters resultParameters = MapTryPutCodec.decodeResponse(response);
   445|         return resultParameters.response;
   446|     }
   447|     @Override
   448|     public V put(K key, V value, long ttl, TimeUnit timeunit) {
   449|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   450|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   451|         return putInternal(ttl, timeunit, key, value);
   452|     }
   453|     protected V putInternal(long ttl, TimeUnit timeunit, Object key, Object value) {
   454|         Data keyData = toData(key);
   455|         Data valueData = toData(value);
   456|         long ttlMillis = getTimeInMillis(ttl, timeunit);
   457|         ClientMessage request = MapPutCodec.encodeRequest(name, keyData, valueData, getThreadId(), ttlMillis);
   458|         ClientMessage response = invoke(request, keyData);
   459|         MapPutCodec.ResponseParameters resultParameters = MapPutCodec.decodeResponse(response);
   460|         return toObject(resultParameters.response);
   461|     }
   462|     @Override
   463|     public void putTransient(K key, V value, long ttl, TimeUnit timeunit) {
   464|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   465|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   466|         putTransientInternal(ttl, timeunit, key, value);
   467|     }
   468|     protected void putTransientInternal(long ttl, TimeUnit timeunit, Object key, Object value) {
   469|         Data keyData = toData(key);
   470|         Data valueData = toData(value);
   471|         long ttlMillis = getTimeInMillis(ttl, timeunit);
   472|         ClientMessage request = MapPutTransientCodec.encodeRequest(name, keyData, valueData, getThreadId(), ttlMillis);
   473|         invoke(request, keyData);
   474|     }
   475|     @Override
   476|     public V putIfAbsent(K key, V value) {
   477|         return putIfAbsent(key, value, -1, TimeUnit.MILLISECONDS);
   478|     }
   479|     @Override
   480|     public V putIfAbsent(K key, V value, long ttl, TimeUnit timeunit) {
   481|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   482|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   483|         return putIfAbsentInternal(ttl, timeunit, key, value);
   484|     }
   485|     protected V putIfAbsentInternal(long ttl, TimeUnit timeunit, Object key, Object value) {
   486|         Data keyData = toData(key);
   487|         Data valueData = toData(value);
   488|         long ttlMillis = getTimeInMillis(ttl, timeunit);
   489|         ClientMessage request = MapPutIfAbsentCodec.encodeRequest(name, keyData, valueData, getThreadId(), ttlMillis);
   490|         ClientMessage result = invoke(request, keyData);
   491|         MapPutIfAbsentCodec.ResponseParameters resultParameters = MapPutIfAbsentCodec.decodeResponse(result);
   492|         return toObject(resultParameters.response);
   493|     }
   494|     @Override
   495|     public boolean replace(K key, V oldValue, V newValue) {
   496|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   497|         checkNotNull(oldValue, NULL_VALUE_IS_NOT_ALLOWED);
   498|         checkNotNull(newValue, NULL_VALUE_IS_NOT_ALLOWED);
   499|         return replaceIfSameInternal(key, oldValue, newValue);
   500|     }
   501|     protected boolean replaceIfSameInternal(Object key, Object oldValue, Object newValue) {
   502|         Data keyData = toData(key);
   503|         Data oldValueData = toData(oldValue);
   504|         Data newValueData = toData(newValue);
   505|         ClientMessage request = MapReplaceIfSameCodec.encodeRequest(name, keyData, oldValueData, newValueData, getThreadId());
   506|         ClientMessage response = invoke(request, keyData);
   507|         MapReplaceIfSameCodec.ResponseParameters resultParameters = MapReplaceIfSameCodec.decodeResponse(response);
   508|         return resultParameters.response;
   509|     }
   510|     @Override
   511|     public V replace(K key, V value) {
   512|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   513|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   514|         return replaceInternal(key, value);
   515|     }
   516|     protected V replaceInternal(Object key, Object value) {
   517|         Data keyData = toData(key);
   518|         Data valueData = toData(value);
   519|         ClientMessage request = MapReplaceCodec.encodeRequest(name, keyData, valueData, getThreadId());
   520|         ClientMessage response = invoke(request, keyData);
   521|         MapReplaceCodec.ResponseParameters resultParameters = MapReplaceCodec.decodeResponse(response);
   522|         return toObject(resultParameters.response);
   523|     }
   524|     @Override
   525|     public void set(K key, V value, long ttl, TimeUnit timeunit) {
   526|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   527|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   528|         setInternal(ttl, timeunit, key, value);
   529|     }
   530|     protected void setInternal(long ttl, TimeUnit timeunit, Object key, Object value) {
   531|         Data keyData = toData(key);
   532|         Data valueData = toData(value);
   533|         long ttlMillis = getTimeInMillis(ttl, timeunit);
   534|         ClientMessage request = MapSetCodec.encodeRequest(name, keyData, valueData, getThreadId(), ttlMillis);
   535|         invoke(request, keyData);
   536|     }
   537|     @Override
   538|     public void lock(K key) {
   539|         lock(key, -1, TimeUnit.MILLISECONDS);
   540|     }
   541|     @Override
   542|     public void lock(K key, long leaseTime, TimeUnit timeUnit) {
   543|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   544|         Data keyData = toData(key);
   545|         ClientMessage request = MapLockCodec.encodeRequest(name, keyData, getThreadId(), getTimeInMillis(leaseTime, timeUnit),
   546|                 lockReferenceIdGenerator.getNextReferenceId());
   547|         invoke(request, keyData, Long.MAX_VALUE);
   548|     }
   549|     private <T> T invoke(ClientMessage clientMessage, Object key, long invocationTimeoutSeconds) {
   550|         final int partitionId = getContext().getPartitionService().getPartitionId(key);
   551|         try {
   552|             ClientInvocation clientInvocation = new ClientInvocation(getClient(), clientMessage, getName(), partitionId);
   553|             clientInvocation.setInvocationTimeoutMillis(invocationTimeoutSeconds);
   554|             final Future future = clientInvocation.invoke();
   555|             return (T) future.get();
   556|         } catch (Exception e) {
   557|             throw rethrow(e);
   558|         }
   559|     }
   560|     @Override
   561|     public boolean isLocked(K key) {
   562|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   563|         Data keyData = toData(key);
   564|         ClientMessage request = MapIsLockedCodec.encodeRequest(name, keyData);
   565|         ClientMessage response = invoke(request, keyData);
   566|         MapIsLockedCodec.ResponseParameters resultParameters = MapIsLockedCodec.decodeResponse(response);
   567|         return resultParameters.response;
   568|     }
   569|     @Override
   570|     public boolean tryLock(K key) {
   571|         try {
   572|             return tryLock(key, 0, null);
   573|         } catch (InterruptedException e) {
   574|             currentThread().interrupt();
   575|             return false;
   576|         }
   577|     }
   578|     @Override
   579|     public boolean tryLock(K key, long time, TimeUnit timeunit) throws InterruptedException {
   580|         return tryLock(key, time, timeunit, Long.MAX_VALUE, null);
   581|     }
   582|     @Override
   583|     public boolean tryLock(K key, long time, TimeUnit timeunit, long leaseTime, TimeUnit leaseUnit) throws InterruptedException {
   584|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   585|         Data keyData = toData(key);
   586|         long leaseTimeMillis = getTimeInMillis(leaseTime, leaseUnit);
   587|         long timeoutMillis = getTimeInMillis(time, timeunit);
   588|         ClientMessage request = MapTryLockCodec.encodeRequest(name, keyData, getThreadId(), leaseTimeMillis, timeoutMillis,
   589|                 lockReferenceIdGenerator.getNextReferenceId());
   590|         ClientMessage response = invoke(request, keyData, Long.MAX_VALUE);
   591|         MapTryLockCodec.ResponseParameters resultParameters = MapTryLockCodec.decodeResponse(response);
   592|         return resultParameters.response;
   593|     }
   594|     @Override
   595|     public void unlock(K key) {
   596|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   597|         Data keyData = toData(key);
   598|         ClientMessage request = MapUnlockCodec.encodeRequest(name, keyData, getThreadId(),
   599|                 lockReferenceIdGenerator.getNextReferenceId());
   600|         invoke(request, keyData);
   601|     }
   602|     @Override
   603|     public void forceUnlock(K key) {
   604|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   605|         Data keyData = toData(key);
   606|         ClientMessage request = MapForceUnlockCodec.encodeRequest(name, keyData, lockReferenceIdGenerator.getNextReferenceId());
   607|         invoke(request, keyData);

# --- HUNK 8: Lines 853-893 ---
   853|         Data keyData = toData(key);
   854|         ClientMessage request = MapGetEntryViewCodec.encodeRequest(name, keyData, getThreadId());
   855|         ClientMessage response = invoke(request, keyData);
   856|         MapGetEntryViewCodec.ResponseParameters parameters = MapGetEntryViewCodec.decodeResponse(response);
   857|         SimpleEntryView<Data, Data> dataEntryView = parameters.response;
   858|         if (dataEntryView == null) {
   859|             return null;
   860|         }
   861|         return new SimpleEntryView<K, V>()
   862|                 .withKey((K) toObject(dataEntryView.getKey()))
   863|                 .withValue((V) toObject(dataEntryView.getValue()))
   864|                 .withCost(dataEntryView.getCost())
   865|                 .withCreationTime(dataEntryView.getCreationTime())
   866|                 .withExpirationTime(dataEntryView.getExpirationTime())
   867|                 .withHits(dataEntryView.getHits())
   868|                 .withLastAccessTime(dataEntryView.getLastAccessTime())
   869|                 .withLastStoredTime(dataEntryView.getLastStoredTime())
   870|                 .withLastUpdateTime(dataEntryView.getLastUpdateTime())
   871|                 .withVersion(dataEntryView.getVersion())
   872|                 .withHits(dataEntryView.getHits())
   873|                 .withTtl(dataEntryView.getTtl());
   874|     }
   875|     @Override
   876|     public boolean evict(K key) {
   877|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   878|         return evictInternal(key);
   879|     }
   880|     protected boolean evictInternal(Object key) {
   881|         Data keyData = toData(key);
   882|         ClientMessage request = MapEvictCodec.encodeRequest(name, keyData, getThreadId());
   883|         ClientMessage response = invoke(request, keyData);
   884|         MapEvictCodec.ResponseParameters resultParameters = MapEvictCodec.decodeResponse(response);
   885|         return resultParameters.response;
   886|     }
   887|     @Override
   888|     public void evictAll() {
   889|         ClientMessage request = MapEvictAllCodec.encodeRequest(name);
   890|         invoke(request);
   891|     }
   892|     @Override
   893|     public void loadAll(boolean replaceExistingValues) {

# --- HUNK 9: Lines 1104-1143 ---
  1104|             resultList.add(new AbstractMap.SimpleImmutableEntry<K, V>(key, value));
  1105|         }
  1106|         return (Collection<V>) getSortedQueryResultSet(resultList, pagingPredicate, IterationType.VALUE);
  1107|     }
  1108|     @Override
  1109|     public Set<K> localKeySet() {
  1110|         throw new UnsupportedOperationException("Locality is ambiguous for client!");
  1111|     }
  1112|     @Override
  1113|     public Set<K> localKeySet(Predicate predicate) {
  1114|         throw new UnsupportedOperationException("Locality is ambiguous for client!");
  1115|     }
  1116|     @Override
  1117|     public void addIndex(String attribute, boolean ordered) {
  1118|         ClientMessage request = MapAddIndexCodec.encodeRequest(name, attribute, ordered);
  1119|         invoke(request);
  1120|     }
  1121|     @Override
  1122|     public LocalMapStats getLocalMapStats() {
  1123|         return new LocalMapStatsImpl();
  1124|     }
  1125|     @Override
  1126|     public Object executeOnKey(K key, EntryProcessor entryProcessor) {
  1127|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
  1128|         return executeOnKeyInternal(key, entryProcessor);
  1129|     }
  1130|     public Object executeOnKeyInternal(Object key, EntryProcessor entryProcessor) {
  1131|         validateEntryProcessorForSingleKeyProcessing(entryProcessor);
  1132|         Data keyData = toData(key);
  1133|         ClientMessage request = MapExecuteOnKeyCodec.encodeRequest(name, toData(entryProcessor), keyData, getThreadId());
  1134|         ClientMessage response = invoke(request, keyData);
  1135|         MapExecuteOnKeyCodec.ResponseParameters resultParameters = MapExecuteOnKeyCodec.decodeResponse(response);
  1136|         return toObject(resultParameters.response);
  1137|     }
  1138|     @Override
  1139|     public void submitToKey(K key, EntryProcessor entryProcessor, ExecutionCallback callback) {
  1140|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
  1141|         submitToKeyInternal(key, entryProcessor, callback);
  1142|     }
  1143|     @SuppressWarnings("unchecked")

# --- HUNK 10: Lines 1292-1334 ---
  1292|     }
  1293|     @SuppressWarnings("unchecked")
  1294|     private QueryCache<K, V> createQueryCache(QueryCacheRequest request) {
  1295|         SubscriberContext subscriberContext = queryCacheContext.getSubscriberContext();
  1296|         QueryCacheEndToEndProvider queryCacheEndToEndProvider = subscriberContext.getEndToEndQueryCacheProvider();
  1297|         return queryCacheEndToEndProvider.getOrCreateQueryCache(request.getMapName(), request.getCacheName(),
  1298|                 new ClientQueryCacheEndToEndConstructor(request));
  1299|     }
  1300|     @Override
  1301|     public Map<K, Object> executeOnKeys(Set<K> keys, EntryProcessor entryProcessor) {
  1302|         checkNotNull(keys, NULL_KEY_IS_NOT_ALLOWED);
  1303|         if (keys.isEmpty()) {
  1304|             return emptyMap();
  1305|         }
  1306|         Collection<Data> dataCollection = objectToDataCollection(keys, getSerializationService());
  1307|         ClientMessage request = MapExecuteOnKeysCodec.encodeRequest(name, toData(entryProcessor), dataCollection);
  1308|         ClientMessage response = invoke(request);
  1309|         MapExecuteOnKeysCodec.ResponseParameters resultParameters = MapExecuteOnKeysCodec.decodeResponse(response);
  1310|         return prepareResult(resultParameters.response);
  1311|     }
  1312|     @Override
  1313|     public void set(K key, V value) {
  1314|         set(key, value, -1, TimeUnit.MILLISECONDS);
  1315|     }
  1316|     @Override
  1317|     public int size() {
  1318|         ClientMessage request = MapSizeCodec.encodeRequest(name);
  1319|         ClientMessage response = invoke(request);
  1320|         MapSizeCodec.ResponseParameters resultParameters = MapSizeCodec.decodeResponse(response);
  1321|         return resultParameters.response;
  1322|     }
  1323|     @Override
  1324|     public boolean isEmpty() {
  1325|         ClientMessage request = MapIsEmptyCodec.encodeRequest(name);
  1326|         ClientMessage response = invoke(request);
  1327|         MapIsEmptyCodec.ResponseParameters resultParameters = MapIsEmptyCodec.decodeResponse(response);
  1328|         return resultParameters.response;
  1329|     }
  1330|     @Override
  1331|     public void putAll(Map<? extends K, ? extends V> map) {
  1332|         ClientPartitionService partitionService = getContext().getPartitionService();
  1333|         int partitionCount = partitionService.getPartitionCount();
  1334|         Map<Integer, List<Map.Entry<Data, Data>>> entryMap = new HashMap<Integer, List<Map.Entry<Data, Data>>>(partitionCount);

# --- HUNK 11: Lines 1444-1486 ---
  1444|             long startSequence,
  1445|             int minSize,
  1446|             int maxSize,
  1447|             int partitionId,
  1448|             com.hazelcast.util.function.Predicate<? super EventJournalMapEvent<K, V>> predicate,
  1449|             Projection<? super EventJournalMapEvent<K, V>, ? extends T> projection
  1450|     ) {
  1451|         if (maxSize < minSize) {
  1452|             throw new IllegalArgumentException("maxSize " + maxSize
  1453|                     + " must be greater or equal to minSize " + minSize);
  1454|         }
  1455|         final SerializationService ss = getSerializationService();
  1456|         final ClientMessage request = MapEventJournalReadCodec.encodeRequest(
  1457|                 name, startSequence, minSize, maxSize, ss.toData(predicate), ss.toData(projection));
  1458|         final ClientInvocationFuture fut = new ClientInvocation(getClient(), request, getName(), partitionId).invoke();
  1459|         return new ClientDelegatingFuture<ReadResultSet<T>>(fut, ss, eventJournalReadResponseDecoder);
  1460|     }
  1461|     public ClientQueryCacheContext getQueryCacheContext() {
  1462|         return queryCacheContext;
  1463|     }
  1464|     private long getTimeInMillis(long time, TimeUnit timeunit) {
  1465|         return timeunit != null ? timeunit.toMillis(time) : time;
  1466|     }
  1467|     private EventHandler<ClientMessage> createHandler(ListenerAdapter<IMapEvent> listenerAdapter) {
  1468|         return new ClientMapEventHandler(listenerAdapter);
  1469|     }
  1470|     private static void validateEntryProcessorForSingleKeyProcessing(EntryProcessor entryProcessor) {
  1471|         if (entryProcessor instanceof ReadOnly) {
  1472|             EntryBackupProcessor backupProcessor = entryProcessor.getBackupProcessor();
  1473|             if (backupProcessor != null) {
  1474|                 throw new IllegalArgumentException(
  1475|                         "EntryProcessor.getBackupProcessor() should be null for a read-only EntryProcessor");
  1476|             }
  1477|         }
  1478|     }
  1479|     private static void checkNotPagingPredicate(Predicate predicate, String method) {
  1480|         if (predicate instanceof PagingPredicate) {
  1481|             throw new IllegalArgumentException("PagingPredicate not supported in " + method + " method");
  1482|         }
  1483|     }
  1484|     private static boolean containsPagingPredicate(Predicate predicate) {
  1485|         if (predicate instanceof PagingPredicate) {
  1486|             return true;

# --- HUNK 12: Lines 1489-1578 ---
  1489|             return false;
  1490|         }
  1491|         PartitionPredicate partitionPredicate = (PartitionPredicate) predicate;
  1492|         return partitionPredicate.getTarget() instanceof PagingPredicate;
  1493|     }
  1494|     private static PagingPredicate unwrapPagingPredicate(Predicate predicate) {
  1495|         if (predicate instanceof PagingPredicate) {
  1496|             return (PagingPredicate) predicate;
  1497|         }
  1498|         Predicate unwrappedPredicate = ((PartitionPredicate) predicate).getTarget();
  1499|         return (PagingPredicate) unwrappedPredicate;
  1500|     }
  1501|     private class ClientMapEventHandler
  1502|             extends MapAddEntryListenerCodec.AbstractEventHandler
  1503|             implements EventHandler<ClientMessage> {
  1504|         private ListenerAdapter<IMapEvent> listenerAdapter;
  1505|         ClientMapEventHandler(ListenerAdapter<IMapEvent> listenerAdapter) {
  1506|             this.listenerAdapter = listenerAdapter;
  1507|         }
  1508|         @Override
  1509|         public void handle(Data key, Data value, Data oldValue, Data mergingValue, int eventType, String uuid,
  1510|                            int numberOfAffectedEntries) {
  1511|             Member member = getContext().getClusterService().getMember(uuid);
  1512|             listenerAdapter.onEvent(createIMapEvent(key, value, oldValue, mergingValue, eventType, numberOfAffectedEntries,
  1513|                     member));
  1514|         }
  1515|         private IMapEvent createIMapEvent(Data key, Data value, Data oldValue, Data mergingValue, int eventType,
  1516|                                           int numberOfAffectedEntries, Member member) {
  1517|             EntryEventType entryEventType = EntryEventType.getByType(eventType);
  1518|             checkNotNull(entryEventType, "Unknown eventType: " + eventType);
  1519|             switch (entryEventType) {
  1520|                 case ADDED:
  1521|                 case REMOVED:
  1522|                 case UPDATED:
  1523|                 case EVICTED:
  1524|                 case EXPIRED:
  1525|                 case MERGED:
  1526|                     return createEntryEvent(key, value, oldValue, mergingValue, eventType, member);
  1527|                 case EVICT_ALL:
  1528|                 case CLEAR_ALL:
  1529|                     return createMapEvent(eventType, numberOfAffectedEntries, member);
  1530|                 default:
  1531|                     throw new IllegalArgumentException("Not a known event type: " + entryEventType);
  1532|             }
  1533|         }
  1534|         private MapEvent createMapEvent(int eventType, int numberOfAffectedEntries, Member member) {
  1535|             return new MapEvent(name, member, eventType, numberOfAffectedEntries);
  1536|         }
  1537|         private EntryEvent<K, V> createEntryEvent(Data keyData, Data valueData, Data oldValueData, Data mergingValueData,
  1538|                                                   int eventType, Member member) {
  1539|             return new DataAwareEntryEvent<K, V>(member, eventType, name, keyData, valueData, oldValueData, mergingValueData,
  1540|                     getSerializationService());
  1541|         }
  1542|         @Override
  1543|         public void beforeListenerRegister() {
  1544|         }
  1545|         @Override
  1546|         public void onListenerRegister() {
  1547|         }
  1548|     }
  1549|     private class ClientMapPartitionLostEventHandler
  1550|             extends MapAddPartitionLostListenerCodec.AbstractEventHandler
  1551|             implements EventHandler<ClientMessage> {
  1552|         private MapPartitionLostListener listener;
  1553|         ClientMapPartitionLostEventHandler(MapPartitionLostListener listener) {
  1554|             this.listener = listener;
  1555|         }
  1556|         @Override
  1557|         public void beforeListenerRegister() {
  1558|         }
  1559|         @Override
  1560|         public void onListenerRegister() {
  1561|         }
  1562|         @Override
  1563|         public void handle(int partitionId, String uuid) {
  1564|             Member member = getContext().getClusterService().getMember(uuid);
  1565|             listener.partitionLost(new MapPartitionLostEvent(name, member, -1, partitionId));
  1566|         }
  1567|     }
  1568|     @Override
  1569|     protected void onDestroy() {
  1570|         try {
  1571|             SubscriberContext subscriberContext = queryCacheContext.getSubscriberContext();
  1572|             QueryCacheEndToEndProvider provider = subscriberContext.getEndToEndQueryCacheProvider();
  1573|             provider.destroyAllQueryCaches(name);
  1574|         } finally {
  1575|             super.onDestroy();
  1576|         }
  1577|     }
  1578| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientMapReduceProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 208-249 ---
   208|                     getContext().getLoggingService().getLogger(ClientCompletableFuture.class));
   209|             this.jobId = jobId;
   210|         }
   211|         @Override
   212|         public String getJobId() {
   213|             return jobId;
   214|         }
   215|         @Override
   216|         protected boolean shouldCancel(boolean mayInterruptIfRunning) {
   217|             boolean cancelled = false;
   218|             try {
   219|                 ClientMessage request = MapReduceCancelCodec.encodeRequest(name, jobId);
   220|                 ClientMessage response = invoke(request, jobId);
   221|                 cancelled = MapReduceCancelCodec.decodeResponse(response).response;
   222|             } catch (Exception ignore) {
   223|                 ignore(ignore);
   224|             }
   225|             return cancelled;
   226|         }
   227|         @Override
   228|         protected void setResult(Object result) {
   229|             super.setResult(result);
   230|         }
   231|     }
   232|     private final class ClientTrackableJob<V>
   233|             implements TrackableJob<V> {
   234|         private final String jobId;
   235|         private final ClientInvocation clientInvocation;
   236|         private final AbstractCompletableFuture<V> completableFuture;
   237|         private ClientTrackableJob(String jobId, ClientInvocation clientInvocation,
   238|                                    AbstractCompletableFuture<V> completableFuture) {
   239|             this.jobId = jobId;
   240|             this.clientInvocation = clientInvocation;
   241|             this.completableFuture = completableFuture;
   242|         }
   243|         @Override
   244|         public JobTracker getJobTracker() {
   245|             return ClientMapReduceProxy.this;
   246|         }
   247|         @Override
   248|         public String getName() {
   249|             return ClientMapReduceProxy.this.name;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientMultiMapProxy.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.client.impl.ClientLockReferenceIdGenerator;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.codec.MultiMapAddEntryListenerCodec;
    20| import com.hazelcast.client.impl.protocol.codec.MultiMapAddEntryListenerToKeyCodec;
    21| import com.hazelcast.client.impl.protocol.codec.MultiMapClearCodec;
    22| import com.hazelcast.client.impl.protocol.codec.MultiMapContainsEntryCodec;
    23| import com.hazelcast.client.impl.protocol.codec.MultiMapContainsKeyCodec;
    24| import com.hazelcast.client.impl.protocol.codec.MultiMapContainsValueCodec;
    25| import com.hazelcast.client.impl.protocol.codec.MultiMapDeleteCodec;
    26| import com.hazelcast.client.impl.protocol.codec.MultiMapEntrySetCodec;
    27| import com.hazelcast.client.impl.protocol.codec.MultiMapForceUnlockCodec;
    28| import com.hazelcast.client.impl.protocol.codec.MultiMapGetCodec;
    29| import com.hazelcast.client.impl.protocol.codec.MultiMapIsLockedCodec;
    30| import com.hazelcast.client.impl.protocol.codec.MultiMapKeySetCodec;
    31| import com.hazelcast.client.impl.protocol.codec.MultiMapLockCodec;
    32| import com.hazelcast.client.impl.protocol.codec.MultiMapPutCodec;
    33| import com.hazelcast.client.impl.protocol.codec.MultiMapRemoveCodec;
    34| import com.hazelcast.client.impl.protocol.codec.MultiMapRemoveEntryCodec;
    35| import com.hazelcast.client.impl.protocol.codec.MultiMapRemoveEntryListenerCodec;
    36| import com.hazelcast.client.impl.protocol.codec.MultiMapSizeCodec;
    37| import com.hazelcast.client.impl.protocol.codec.MultiMapTryLockCodec;

# --- HUNK 2: Lines 401-441 ---
   401|     }
   402|     protected long getTimeInMillis(final long time, final TimeUnit timeunit) {
   403|         return timeunit != null ? timeunit.toMillis(time) : time;
   404|     }
   405|     @Override
   406|     protected void onInitialize() {
   407|         super.onInitialize();
   408|         lockReferenceIdGenerator = getClient().getLockReferenceIdGenerator();
   409|     }
   410|     private EventHandler<ClientMessage> createHandler(final Object listener) {
   411|         final ListenerAdapter listenerAdaptor = createListenerAdapter(listener);
   412|         return new ClientMultiMapEventHandler(listenerAdaptor);
   413|     }
   414|     private class ClientMultiMapEventHandler extends MultiMapAddEntryListenerCodec.AbstractEventHandler
   415|             implements EventHandler<ClientMessage> {
   416|         private final ListenerAdapter listenerAdapter;
   417|         public ClientMultiMapEventHandler(ListenerAdapter listenerAdapter) {
   418|             this.listenerAdapter = listenerAdapter;
   419|         }
   420|         @Override
   421|         public void handle(Data key, Data value, Data oldValue, Data mergingValue,
   422|                            int eventType, String uuid, int numberOfAffectedEntries) {
   423|             Member member = getContext().getClusterService().getMember(uuid);
   424|             final IMapEvent iMapEvent = createIMapEvent(key, value, oldValue,
   425|                     mergingValue, eventType, numberOfAffectedEntries, member);
   426|             listenerAdapter.onEvent(iMapEvent);
   427|         }
   428|         private IMapEvent createIMapEvent(Data key, Data value, Data oldValue, Data mergingValue,
   429|                                           int eventType, int numberOfAffectedEntries, Member member) {
   430|             IMapEvent iMapEvent;
   431|             EntryEventType entryEventType = EntryEventType.getByType(eventType);
   432|             switch (entryEventType) {
   433|                 case ADDED:
   434|                 case REMOVED:
   435|                 case UPDATED:
   436|                 case EVICTED:
   437|                 case MERGED:
   438|                     iMapEvent = createEntryEvent(key, value, oldValue, mergingValue, eventType, member);
   439|                     break;
   440|                 case EVICT_ALL:
   441|                 case CLEAR_ALL:


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientQueueProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 84-124 ---
    84|             }
    85|             @Override
    86|             public ClientMessage encodeRemoveRequest(String realRegistrationId) {
    87|                 return QueueRemoveListenerCodec.encodeRequest(name, realRegistrationId);
    88|             }
    89|             @Override
    90|             public boolean decodeRemoveResponse(ClientMessage clientMessage) {
    91|                 return QueueRemoveListenerCodec.decodeResponse(clientMessage).response;
    92|             }
    93|         };
    94|     }
    95|     private class ItemEventHandler extends ListAddListenerCodec.AbstractEventHandler
    96|             implements EventHandler<ClientMessage> {
    97|         private final boolean includeValue;
    98|         private final ItemListener<E> listener;
    99|         public ItemEventHandler(boolean includeValue, ItemListener<E> listener) {
   100|             this.includeValue = includeValue;
   101|             this.listener = listener;
   102|         }
   103|         @Override
   104|         public void handle(Data dataItem, String uuid, int eventType) {
   105|             Member member = getContext().getClusterService().getMember(uuid);
   106|             ItemEvent<E> itemEvent = new DataAwareItemEvent(name, ItemEventType.getByType(eventType),
   107|                     dataItem, member, getSerializationService());
   108|             if (eventType == ItemEventType.ADDED.getType()) {
   109|                 listener.itemAdded(itemEvent);
   110|             } else {
   111|                 listener.itemRemoved(itemEvent);
   112|             }
   113|         }
   114|         @Override
   115|         public void beforeListenerRegister() {
   116|         }
   117|         @Override
   118|         public void onListenerRegister() {
   119|         }
   120|     }
   121|     @Override
   122|     public boolean removeItemListener(String registrationId) {
   123|         return deregisterListener(registrationId);
   124|     }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientReliableTopicProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.client.config.ClientReliableTopicConfig;
    18| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    19| import com.hazelcast.client.spi.ClientContext;
    20| import com.hazelcast.client.spi.ClientProxy;
    21| import com.hazelcast.core.ITopic;
    22| import com.hazelcast.core.MessageListener;
    23| import com.hazelcast.logging.ILogger;
    24| import com.hazelcast.monitor.LocalTopicStats;
    25| import com.hazelcast.nio.serialization.Data;
    26| import com.hazelcast.ringbuffer.OverflowPolicy;
    27| import com.hazelcast.ringbuffer.Ringbuffer;
    28| import com.hazelcast.spi.serialization.SerializationService;
    29| import com.hazelcast.topic.ReliableMessageListener;
    30| import com.hazelcast.topic.TopicOverloadException;
    31| import com.hazelcast.topic.TopicOverloadPolicy;
    32| import com.hazelcast.topic.impl.reliable.MessageRunner;
    33| import com.hazelcast.topic.impl.reliable.ReliableMessageListenerAdapter;
    34| import com.hazelcast.topic.impl.reliable.ReliableTopicMessage;
    35| import com.hazelcast.util.UuidUtil;
    36| import java.util.concurrent.ConcurrentHashMap;
    37| import java.util.concurrent.ConcurrentMap;
    38| import java.util.concurrent.Executor;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientReplicatedMapProxy.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 451-502 ---
   451|         return toObject(value);
   452|     }
   453|     private void tryPublishReserved(K key, V value, long reservationId) {
   454|         if (nearCache == null) {
   455|             return;
   456|         }
   457|         if (reservationId != NOT_RESERVED) {
   458|             nearCache.tryPublishReserved(key, value, reservationId, false);
   459|         }
   460|     }
   461|     private long tryReserveForUpdate(K key, Data keyData) {
   462|         if (nearCache == null) {
   463|             return NOT_RESERVED;
   464|         }
   465|         return nearCache.tryReserveForUpdate(key, keyData);
   466|     }
   467|     private void invalidate(K key) {
   468|         if (nearCache == null) {
   469|             return;
   470|         }
   471|         nearCache.remove(key);
   472|     }
   473|     private class ReplicatedMapEventHandler
   474|             extends ReplicatedMapAddEntryListenerCodec.AbstractEventHandler
   475|             implements EventHandler<ClientMessage> {
   476|         private final EntryListener<K, V> listener;
   477|         ReplicatedMapEventHandler(EntryListener<K, V> listener) {
   478|             this.listener = listener;
   479|         }
   480|         @Override
   481|         public void handle(Data keyData, Data valueData, Data oldValueData, Data mergingValue, int eventTypeId, String uuid,
   482|                            int numberOfAffectedEntries) {
   483|             Member member = getContext().getClusterService().getMember(uuid);
   484|             EntryEventType eventType = EntryEventType.getByType(eventTypeId);
   485|             EntryEvent<K, V> entryEvent = new DataAwareEntryEvent<K, V>(member, eventTypeId, name, keyData, valueData,
   486|                     oldValueData, null, getSerializationService());
   487|             switch (eventType) {
   488|                 case ADDED:
   489|                     listener.entryAdded(entryEvent);
   490|                     break;
   491|                 case REMOVED:
   492|                     listener.entryRemoved(entryEvent);
   493|                     break;
   494|                 case UPDATED:
   495|                     listener.entryUpdated(entryEvent);
   496|                     break;
   497|                 case EVICTED:
   498|                     listener.entryEvicted(entryEvent);
   499|                     break;
   500|                 case CLEAR_ALL:
   501|                     MapEvent mapEvent = new MapEvent(getName(), member, eventTypeId, numberOfAffectedEntries);
   502|                     listener.mapCleared(mapEvent);

# --- HUNK 2: Lines 511-550 ---
   511|         @Override
   512|         public void onListenerRegister() {
   513|         }
   514|     }
   515|     private class ReplicatedMapAddNearCacheEventHandler
   516|             extends ReplicatedMapAddNearCacheEntryListenerCodec.AbstractEventHandler
   517|             implements EventHandler<ClientMessage> {
   518|         @Override
   519|         public void beforeListenerRegister() {
   520|             if (nearCache != null) {
   521|                 nearCache.clear();
   522|             }
   523|         }
   524|         @Override
   525|         public void onListenerRegister() {
   526|             if (nearCache != null) {
   527|                 nearCache.clear();
   528|             }
   529|         }
   530|         @Override
   531|         public void handle(Data dataKey, Data value, Data oldValue, Data mergingValue, int eventType, String uuid,
   532|                            int numberOfAffectedEntries) {
   533|             EntryEventType entryEventType = EntryEventType.getByType(eventType);
   534|             switch (entryEventType) {
   535|                 case ADDED:
   536|                 case REMOVED:
   537|                 case UPDATED:
   538|                 case EVICTED:
   539|                     K key = toObject(dataKey);
   540|                     nearCache.remove(key);
   541|                     break;
   542|                 case CLEAR_ALL:
   543|                     nearCache.clear();
   544|                     break;
   545|                 default:
   546|                     throw new IllegalArgumentException("Not a known event type " + entryEventType);
   547|             }
   548|         }
   549|     }
   550| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientRingbufferProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.client.impl.ClientMessageDecoder;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.codec.RingbufferAddAllCodec;
    20| import com.hazelcast.client.impl.protocol.codec.RingbufferAddCodec;
    21| import com.hazelcast.client.impl.protocol.codec.RingbufferCapacityCodec;
    22| import com.hazelcast.client.impl.protocol.codec.RingbufferHeadSequenceCodec;
    23| import com.hazelcast.client.impl.protocol.codec.RingbufferReadManyCodec;
    24| import com.hazelcast.client.impl.protocol.codec.RingbufferReadOneCodec;
    25| import com.hazelcast.client.impl.protocol.codec.RingbufferRemainingCapacityCodec;
    26| import com.hazelcast.client.impl.protocol.codec.RingbufferSizeCodec;
    27| import com.hazelcast.client.impl.protocol.codec.RingbufferTailSequenceCodec;
    28| import com.hazelcast.client.spi.ClientContext;
    29| import com.hazelcast.client.spi.ClientProxy;
    30| import com.hazelcast.client.spi.impl.ClientInvocation;
    31| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    32| import com.hazelcast.client.util.ClientDelegatingFuture;
    33| import com.hazelcast.core.ICompletableFuture;
    34| import com.hazelcast.core.IFunction;
    35| import com.hazelcast.nio.serialization.Data;
    36| import com.hazelcast.partition.strategy.StringPartitioningStrategy;
    37| import com.hazelcast.ringbuffer.OverflowPolicy;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientScheduledExecutorProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.client.impl.ClientMessageDecoder;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.codec.ScheduledExecutorGetAllScheduledFuturesCodec;
    20| import com.hazelcast.client.impl.protocol.codec.ScheduledExecutorShutdownCodec;
    21| import com.hazelcast.client.impl.protocol.codec.ScheduledExecutorSubmitToAddressCodec;
    22| import com.hazelcast.client.impl.protocol.codec.ScheduledExecutorSubmitToPartitionCodec;
    23| import com.hazelcast.client.spi.ClientContext;
    24| import com.hazelcast.client.spi.impl.ClientInvocation;
    25| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    26| import com.hazelcast.client.util.ClientDelegatingFuture;
    27| import com.hazelcast.core.Member;
    28| import com.hazelcast.core.PartitionAware;
    29| import com.hazelcast.logging.ILogger;
    30| import com.hazelcast.logging.Logger;
    31| import com.hazelcast.nio.Address;
    32| import com.hazelcast.nio.serialization.Data;
    33| import com.hazelcast.quorum.QuorumException;
    34| import com.hazelcast.scheduledexecutor.IScheduledExecutorService;
    35| import com.hazelcast.scheduledexecutor.IScheduledFuture;
    36| import com.hazelcast.scheduledexecutor.NamedTask;
    37| import com.hazelcast.scheduledexecutor.ScheduledTaskHandler;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientSetProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 180-217 ---
   180|         return deregisterListener(registrationId);
   181|     }
   182|     private Collection<E> getAll() {
   183|         ClientMessage request = SetGetAllCodec.encodeRequest(name);
   184|         ClientMessage response = invokeOnPartition(request);
   185|         SetGetAllCodec.ResponseParameters resultParameters = SetGetAllCodec.decodeResponse(response);
   186|         List<Data> resultCollection = resultParameters.response;
   187|         return new UnmodifiableLazyList<E>(resultCollection, getSerializationService());
   188|     }
   189|     @Override
   190|     public String toString() {
   191|         return "ISet{" + "name='" + name + '\'' + '}';
   192|     }
   193|     private class ItemEventHandler extends ListAddListenerCodec.AbstractEventHandler
   194|             implements EventHandler<ClientMessage> {
   195|         private final ItemListener<E> listener;
   196|         public ItemEventHandler(ItemListener<E> listener) {
   197|             this.listener = listener;
   198|         }
   199|         @Override
   200|         public void handle(Data dataItem, String uuid, int eventType) {
   201|             Member member = getContext().getClusterService().getMember(uuid);
   202|             ItemEvent<E> itemEvent = new DataAwareItemEvent(name, ItemEventType.getByType(eventType),
   203|                     dataItem, member, getSerializationService());
   204|             if (eventType == ItemEventType.ADDED.getType()) {
   205|                 listener.itemAdded(itemEvent);
   206|             } else {
   207|                 listener.itemRemoved(itemEvent);
   208|             }
   209|         }
   210|         @Override
   211|         public void beforeListenerRegister() {
   212|         }
   213|         @Override
   214|         public void onListenerRegister() {
   215|         }
   216|     }
   217| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientTopicProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 53-93 ---
    53|     }
    54|     @Override
    55|     public boolean removeMessageListener(String registrationId) {
    56|         return deregisterListener(registrationId);
    57|     }
    58|     @Override
    59|     public LocalTopicStats getLocalTopicStats() {
    60|         throw new UnsupportedOperationException("Locality is ambiguous for client!");
    61|     }
    62|     @Override
    63|     public String toString() {
    64|         return "ITopic{" + "name='" + name + '\'' + '}';
    65|     }
    66|     private final class TopicItemHandler extends TopicAddMessageListenerCodec.AbstractEventHandler
    67|             implements EventHandler<ClientMessage> {
    68|         private final MessageListener<E> listener;
    69|         private TopicItemHandler(MessageListener<E> listener) {
    70|             this.listener = listener;
    71|         }
    72|         @Override
    73|         public void handle(Data item, long publishTime, String uuid) {
    74|             Member member = getContext().getClusterService().getMember(uuid);
    75|             Message message = new DataAwareMessage(name, item, publishTime, member, getSerializationService());
    76|             listener.onMessage(message);
    77|         }
    78|         @Override
    79|         public void beforeListenerRegister() {
    80|         }
    81|         @Override
    82|         public void onListenerRegister() {
    83|         }
    84|     }
    85|     private class Codec implements ListenerMessageCodec {
    86|         @Override
    87|         public ClientMessage encodeAddRequest(boolean localOnly) {
    88|             return TopicAddMessageListenerCodec.encodeRequest(name, localOnly);
    89|         }
    90|         @Override
    91|         public String decodeAddResponse(ClientMessage clientMessage) {
    92|             return TopicAddMessageListenerCodec.decodeResponse(clientMessage).response;
    93|         }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/IExecutorDelegatingFuture.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.client.impl.ClientMessageDecoder;
    18| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    19| import com.hazelcast.client.impl.protocol.ClientMessage;
    20| import com.hazelcast.client.impl.protocol.codec.ExecutorServiceCancelOnAddressCodec;
    21| import com.hazelcast.client.impl.protocol.codec.ExecutorServiceCancelOnPartitionCodec;
    22| import com.hazelcast.client.spi.ClientContext;
    23| import com.hazelcast.client.spi.impl.ClientInvocation;
    24| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    25| import com.hazelcast.client.util.ClientDelegatingFuture;
    26| import com.hazelcast.core.ICompletableFuture;
    27| import com.hazelcast.nio.Address;
    28| import java.util.concurrent.CancellationException;
    29| import java.util.concurrent.ExecutionException;
    30| import static com.hazelcast.util.ExceptionUtil.rethrow;
    31| /**
    32|  * An Abstract DelegatingFuture that can cancel a Runnable/Callable that is executed by an
    33|  * {@link com.hazelcast.core.IExecutorService}.
    34|  * It does this by sending a Cancellation Request to the remote owning member and then cancelling the running task.
    35|  *
    36|  * @param <V> Type of returned object from the get method of this class.
    37|  */
    38| public final class IExecutorDelegatingFuture<V> extends ClientDelegatingFuture<V> {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/NearCachedClientMapProxy.java
# Total hunks: 6
# ====================================================================
# --- HUNK 1: Lines 99-138 ---
    99|     protected V getInternal(Object key) {
   100|         key = toNearCacheKey(key);
   101|         V value = (V) getCachedValue(key, true);
   102|         if (value != NOT_CACHED) {
   103|             return value;
   104|         }
   105|         try {
   106|             Data keyData = toData(key);
   107|             long reservationId = nearCache.tryReserveForUpdate(key, keyData);
   108|             value = (V) super.getInternal(keyData);
   109|             if (reservationId != NOT_RESERVED) {
   110|                 value = (V) tryPublishReserved(key, value, reservationId);
   111|             }
   112|             return value;
   113|         } catch (Throwable throwable) {
   114|             invalidateNearCache(key);
   115|             throw rethrow(throwable);
   116|         }
   117|     }
   118|     @Override
   119|     public ICompletableFuture<V> getAsyncInternal(Object keyParameter) {
   120|         final Object key = toNearCacheKey(keyParameter);
   121|         Object value = getCachedValue(key, false);
   122|         if (value != NOT_CACHED) {
   123|             ExecutorService executor = getContext().getExecutionService().getUserExecutor();
   124|             return new CompletedFuture<V>(getSerializationService(), value, executor);
   125|         }
   126|         Data keyData = toData(key);
   127|         final long reservationId = nearCache.tryReserveForUpdate(key, keyData);
   128|         ICompletableFuture<V> future;
   129|         try {
   130|             future = super.getAsyncInternal(keyData);
   131|         } catch (Throwable t) {
   132|             invalidateNearCache(key);
   133|             throw rethrow(t);
   134|         }
   135|         if (reservationId != NOT_RESERVED) {
   136|             ((ClientDelegatingFuture) future).andThenInternal(new ExecutionCallback<Object>() {
   137|                 @Override
   138|                 public void onResponse(Object value) {

# --- HUNK 2: Lines 169-320 ---
   169|         return removed;
   170|     }
   171|     @Override
   172|     protected void removeAllInternal(Predicate predicate) {
   173|         try {
   174|             super.removeAllInternal(predicate);
   175|         } finally {
   176|             nearCache.clear();
   177|         }
   178|     }
   179|     @Override
   180|     protected void deleteInternal(Object key) {
   181|         key = toNearCacheKey(key);
   182|         try {
   183|             super.deleteInternal(key);
   184|         } finally {
   185|             invalidateNearCache(key);
   186|         }
   187|     }
   188|     @Override
   189|     protected ICompletableFuture<V> putAsyncInternal(long ttl, TimeUnit timeunit, Object key, Object value) {
   190|         key = toNearCacheKey(key);
   191|         ICompletableFuture<V> future;
   192|         try {
   193|             future = super.putAsyncInternal(ttl, timeunit, key, value);
   194|         } finally {
   195|             invalidateNearCache(key);
   196|         }
   197|         return future;
   198|     }
   199|     @Override
   200|     protected ICompletableFuture<Void> setAsyncInternal(long ttl, TimeUnit timeunit, Object key, Object value) {
   201|         key = toNearCacheKey(key);
   202|         ICompletableFuture<Void> future;
   203|         try {
   204|             future = super.setAsyncInternal(ttl, timeunit, key, value);
   205|         } finally {
   206|             invalidateNearCache(key);
   207|         }
   208|         return future;
   209|     }
   210|     @Override
   211|     protected ICompletableFuture<V> removeAsyncInternal(Object key) {
   212|         key = toNearCacheKey(key);
   213|         ICompletableFuture<V> future;
   214|         try {
   215|             future = super.removeAsyncInternal(key);
   216|         } finally {
   217|             invalidateNearCache(key);
   218|         }
   219|         return future;
   220|     }
   221|     @Override
   222|     protected boolean tryRemoveInternal(long timeout, TimeUnit timeunit, Object key) {
   223|         key = toNearCacheKey(key);
   224|         boolean removed;
   225|         try {
   226|             removed = super.tryRemoveInternal(timeout, timeunit, key);
   227|         } finally {
   228|             invalidateNearCache(key);
   229|         }
   230|         return removed;
   231|     }
   232|     @Override
   233|     protected boolean tryPutInternal(long timeout, TimeUnit timeunit, Object key, Object value) {
   234|         key = toNearCacheKey(key);
   235|         boolean putInternal;
   236|         try {
   237|             putInternal = super.tryPutInternal(timeout, timeunit, key, value);
   238|         } finally {
   239|             invalidateNearCache(key);
   240|         }
   241|         return putInternal;
   242|     }
   243|     @Override
   244|     protected V putInternal(long ttl, TimeUnit timeunit, Object key, Object value) {
   245|         key = toNearCacheKey(key);
   246|         V previousValue;
   247|         try {
   248|             previousValue = super.putInternal(ttl, timeunit, key, value);
   249|         } finally {
   250|             invalidateNearCache(key);
   251|         }
   252|         return previousValue;
   253|     }
   254|     @Override
   255|     protected void putTransientInternal(long ttl, TimeUnit timeunit, Object key, Object value) {
   256|         key = toNearCacheKey(key);
   257|         try {
   258|             super.putTransientInternal(ttl, timeunit, key, value);
   259|         } finally {
   260|             invalidateNearCache(key);
   261|         }
   262|     }
   263|     @Override
   264|     protected V putIfAbsentInternal(long ttl, TimeUnit timeunit, Object key, Object value) {
   265|         key = toNearCacheKey(key);
   266|         V previousValue;
   267|         try {
   268|             previousValue = super.putIfAbsentInternal(ttl, timeunit, key, value);
   269|         } finally {
   270|             invalidateNearCache(key);
   271|         }
   272|         return previousValue;
   273|     }
   274|     @Override
   275|     protected boolean replaceIfSameInternal(Object key, Object oldValue, Object newValue) {
   276|         key = toNearCacheKey(key);
   277|         boolean replaceIfSame;
   278|         try {
   279|             replaceIfSame = super.replaceIfSameInternal(key, oldValue, newValue);
   280|         } finally {
   281|             invalidateNearCache(key);
   282|         }
   283|         return replaceIfSame;
   284|     }
   285|     @Override
   286|     protected V replaceInternal(Object key, Object value) {
   287|         key = toNearCacheKey(key);
   288|         V v;
   289|         try {
   290|             v = super.replaceInternal(key, value);
   291|         } finally {
   292|             invalidateNearCache(key);
   293|         }
   294|         return v;
   295|     }
   296|     @Override
   297|     protected void setInternal(long ttl, TimeUnit timeunit, Object key, Object value) {
   298|         key = toNearCacheKey(key);
   299|         try {
   300|             super.setInternal(ttl, timeunit, key, value);
   301|         } finally {
   302|             invalidateNearCache(key);
   303|         }
   304|     }
   305|     @Override
   306|     protected boolean evictInternal(Object key) {
   307|         key = toNearCacheKey(key);
   308|         boolean evicted;
   309|         try {
   310|             evicted = super.evictInternal(key);
   311|         } finally {
   312|             invalidateNearCache(key);
   313|         }
   314|         return evicted;
   315|     }
   316|     @Override
   317|     public void evictAll() {
   318|         try {
   319|             super.evictAll();
   320|         } finally {

# --- HUNK 3: Lines 505-677 ---
   505|     }
   506|     private Object tryPublishReserved(Object key, Object value, long reservationId) {
   507|         assert value != NOT_CACHED;
   508|         Object cachedValue = nearCache.tryPublishReserved(key, value, reservationId, true);
   509|         return cachedValue != null ? cachedValue : value;
   510|     }
   511|     private Object getCachedValue(Object key, boolean deserializeValue) {
   512|         Object value = nearCache.get(key);
   513|         if (value == null) {
   514|             return NOT_CACHED;
   515|         }
   516|         if (value == CACHED_AS_NULL) {
   517|             return null;
   518|         }
   519|         return deserializeValue ? toObject(value) : value;
   520|     }
   521|     public NearCache<Object, Object> getNearCache() {
   522|         return nearCache;
   523|     }
   524|     private void invalidateNearCache(Object key) {
   525|         nearCache.remove(key);
   526|     }
   527|     public String addNearCacheInvalidationListener(EventHandler handler) {
   528|         return registerListener(createNearCacheEntryListenerCodec(), handler);
   529|     }
   530|     private void registerInvalidationListener() {
   531|         try {
   532|             invalidationListenerId = addNearCacheInvalidationListener(new ConnectedServerVersionAwareNearCacheEventHandler());
   533|         } catch (Exception e) {
   534|             ILogger logger = getContext().getLoggingService().getLogger(getClass());
   535|             logger.severe("-----------------\nNear Cache is not initialized!\n-----------------", e);
   536|         }
   537|     }
   538|     @SuppressWarnings("checkstyle:anoninnerlength")
   539|     private ListenerMessageCodec createNearCacheEntryListenerCodec() {
   540|         return new ListenerMessageCodec() {
   541|             @Override
   542|             public ClientMessage encodeAddRequest(boolean localOnly) {
   543|                 if (supportsRepairableNearCache()) {
   544|                     return MapAddNearCacheInvalidationListenerCodec.encodeRequest(name, INVALIDATION.getType(), localOnly);
   545|                 }
   546|                 return MapAddNearCacheEntryListenerCodec.encodeRequest(name, INVALIDATION.getType(), localOnly);
   547|             }
   548|             @Override
   549|             public String decodeAddResponse(ClientMessage clientMessage) {
   550|                 if (supportsRepairableNearCache()) {
   551|                     return MapAddNearCacheInvalidationListenerCodec.decodeResponse(clientMessage).response;
   552|                 }
   553|                 return MapAddNearCacheEntryListenerCodec.decodeResponse(clientMessage).response;
   554|             }
   555|             @Override
   556|             public ClientMessage encodeRemoveRequest(String realRegistrationId) {
   557|                 return MapRemoveEntryListenerCodec.encodeRequest(name, realRegistrationId);
   558|             }
   559|             @Override
   560|             public boolean decodeRemoveResponse(ClientMessage clientMessage) {
   561|                 return MapRemoveEntryListenerCodec.decodeResponse(clientMessage).response;
   562|             }
   563|         };
   564|     }
   565|     private void removeNearCacheInvalidationListener() {
   566|         String invalidationListenerId = this.invalidationListenerId;
   567|         if (invalidationListenerId == null) {
   568|             return;
   569|         }
   570|         getContext().getRepairingTask(getServiceName()).deregisterHandler(name);
   571|         deregisterListener(invalidationListenerId);
   572|     }
   573|     /**
   574|      * Deals with client compatibility.
   575|      * <p>
   576|      * Eventual consistency for Near Cache can be used with server versions >= 3.8,
   577|      * other connected server versions must use {@link Pre38NearCacheEventHandler}
   578|      */
   579|     private final class ConnectedServerVersionAwareNearCacheEventHandler implements EventHandler<ClientMessage> {
   580|         private final Pre38NearCacheEventHandler pre38EventHandler = new Pre38NearCacheEventHandler();
   581|         private final RepairableNearCacheEventHandler repairingEventHandler = new RepairableNearCacheEventHandler();
   582|         private volatile boolean supportsRepairableNearCache;
   583|         @Override
   584|         public void beforeListenerRegister() {
   585|             repairingEventHandler.beforeListenerRegister();
   586|             supportsRepairableNearCache = supportsRepairableNearCache();
   587|             if (!supportsRepairableNearCache) {
   588|                 pre38EventHandler.beforeListenerRegister();
   589|                 logger.warning(format("Near Cache for '%s' map is started in legacy mode", name));
   590|             }
   591|         }
   592|         @Override
   593|         public void onListenerRegister() {
   594|             if (supportsRepairableNearCache) {
   595|                 repairingEventHandler.onListenerRegister();
   596|             } else {
   597|                 pre38EventHandler.onListenerRegister();
   598|             }
   599|         }
   600|         @Override
   601|         public void handle(ClientMessage clientMessage) {
   602|             if (supportsRepairableNearCache) {
   603|                 repairingEventHandler.handle(clientMessage);
   604|             } else {
   605|                 pre38EventHandler.handle(clientMessage);
   606|             }
   607|         }
   608|     }
   609|     /**
   610|      * This event handler can only be used with server versions >= 3.8 and supports Near Cache eventual consistency improvements.
   611|      * For repairing functionality please see {@link RepairingHandler}.
   612|      */
   613|     private final class RepairableNearCacheEventHandler
   614|             extends MapAddNearCacheInvalidationListenerCodec.AbstractEventHandler
   615|             implements EventHandler<ClientMessage> {
   616|         private volatile RepairingHandler repairingHandler;
   617|         @Override
   618|         public void beforeListenerRegister() {
   619|             if (supportsRepairableNearCache()) {
   620|                 RepairingTask repairingTask = getContext().getRepairingTask(getServiceName());
   621|                 repairingHandler = repairingTask.registerAndGetHandler(name, nearCache);
   622|             } else {
   623|                 RepairingTask repairingTask = getContext().getRepairingTask(getServiceName());
   624|                 repairingTask.deregisterHandler(name);
   625|             }
   626|         }
   627|         @Override
   628|         public void onListenerRegister() {
   629|         }
   630|         @Override
   631|         public void handle(Data key, String sourceUuid, UUID partitionUuid, long sequence) {
   632|             repairingHandler.handle(key, sourceUuid, partitionUuid, sequence);
   633|         }
   634|         @Override
   635|         public void handle(Collection<Data> keys, Collection<String> sourceUuids,
   636|                            Collection<UUID> partitionUuids, Collection<Long> sequences) {
   637|             repairingHandler.handle(keys, sourceUuids, partitionUuids, sequences);
   638|         }
   639|     }
   640|     /**
   641|      * This event handler is here to be used with server versions < 3.8.
   642|      * <p>
   643|      * If server version is < 3.8 and client version is >= 3.8, this event handler must be used to
   644|      * listen Near Cache invalidations. Because new improvements for Near Cache eventual consistency
   645|      * cannot work with server versions < 3.8.
   646|      */
   647|     private final class Pre38NearCacheEventHandler
   648|             extends MapAddNearCacheEntryListenerCodec.AbstractEventHandler
   649|             implements EventHandler<ClientMessage> {
   650|         @Override
   651|         public void beforeListenerRegister() {
   652|             nearCache.clear();
   653|         }
   654|         @Override
   655|         public void onListenerRegister() {
   656|             nearCache.clear();
   657|         }
   658|         @Override
   659|         public void handle(Data key, String sourceUuid, UUID partitionUuid, long sequence) {
   660|             if (key == null) {
   661|                 nearCache.clear();
   662|             } else {
   663|                 nearCache.remove(serializeKeys ? key : toObject(key));
   664|             }
   665|         }
   666|         @Override
   667|         public void handle(Collection<Data> keys, Collection<String> sourceUuids,
   668|                            Collection<UUID> partitionUuids, Collection<Long> sequences) {
   669|             for (Data key : keys) {
   670|                 nearCache.remove(serializeKeys ? key : toObject(key));
   671|             }
   672|         }
   673|     }
   674|     private boolean supportsRepairableNearCache() {
   675|         return getConnectedServerVersion() >= minConsistentNearCacheSupportingServerVersion;
   676|     }
   677| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/PartitionServiceProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 105-135 ---
   105|     }
   106|     @Override
   107|     public boolean isMemberSafe(Member member) {
   108|         throw new UnsupportedOperationException();
   109|     }
   110|     @Override
   111|     public boolean isLocalMemberSafe() {
   112|         throw new UnsupportedOperationException();
   113|     }
   114|     @Override
   115|     public boolean forceLocalMemberToBeSafe(long timeout, TimeUnit unit) {
   116|         throw new UnsupportedOperationException();
   117|     }
   118|     private static class ClientPartitionLostEventHandler extends ClientAddPartitionLostListenerCodec.AbstractEventHandler
   119|             implements EventHandler<ClientMessage> {
   120|         private PartitionLostListener listener;
   121|         public ClientPartitionLostEventHandler(PartitionLostListener listener) {
   122|             this.listener = listener;
   123|         }
   124|         @Override
   125|         public void handle(int partitionId, int lostBackupCount, Address source) {
   126|             listener.partitionLost(new PartitionLostEvent(partitionId, lostBackupCount, source));
   127|         }
   128|         @Override
   129|         public void beforeListenerRegister() {
   130|         }
   131|         @Override
   132|         public void onListenerRegister() {
   133|         }
   134|     }
   135| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/PartitionSpecificClientProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.client.impl.ClientMessageDecoder;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.spi.ClientContext;
    20| import com.hazelcast.client.spi.ClientProxy;
    21| import com.hazelcast.client.spi.impl.ClientInvocation;
    22| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    23| import com.hazelcast.client.util.ClientDelegatingFuture;
    24| import com.hazelcast.partition.strategy.StringPartitioningStrategy;
    25| import com.hazelcast.util.ExceptionUtil;
    26| import java.util.concurrent.Future;
    27| import static com.hazelcast.util.ExceptionUtil.rethrow;
    28| /**
    29|  * Base class for proxies of distributed objects that lives in on partition.
    30|  */
    31| abstract class PartitionSpecificClientProxy extends ClientProxy {
    32|     private int partitionId;
    33|     protected PartitionSpecificClientProxy(String serviceName, String objectName, ClientContext context) {
    34|         super(serviceName, objectName, context);
    35|     }
    36|     @Override
    37|     protected void onInitialize() {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/txn/ClientTransactionUtil.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy.txn;
    17| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.spi.impl.ClientInvocation;
    20| import com.hazelcast.nio.Connection;
    21| import com.hazelcast.transaction.TransactionException;
    22| import com.hazelcast.util.ExceptionUtil.RuntimeExceptionFactory;
    23| import java.util.concurrent.Future;
    24| import static com.hazelcast.util.ExceptionUtil.rethrow;
    25| /**
    26|  * Contains static method that is used from client transaction classes.
    27|  */
    28| public final class ClientTransactionUtil {
    29|     private static final RuntimeExceptionFactory TRANSACTION_EXCEPTION_FACTORY =
    30|             new RuntimeExceptionFactory() {
    31|                 @Override
    32|                 public RuntimeException create(Throwable throwable, String message) {
    33|                     return new TransactionException(message, throwable);
    34|                 }
    35|             };
    36|     private ClientTransactionUtil() {
    37|     }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/txn/ClientTxnProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy.txn;
    17| import com.hazelcast.client.connection.nio.ClientConnection;
    18| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    19| import com.hazelcast.client.impl.protocol.ClientMessage;
    20| import com.hazelcast.client.impl.protocol.codec.ClientDestroyProxyCodec;
    21| import com.hazelcast.client.spi.ClientTransactionContext;
    22| import com.hazelcast.nio.serialization.Data;
    23| import com.hazelcast.partition.strategy.StringPartitioningStrategy;
    24| import com.hazelcast.spi.serialization.SerializationService;
    25| import com.hazelcast.transaction.TransactionalObject;
    26| abstract class ClientTxnProxy implements TransactionalObject {
    27|     final String name;
    28|     final ClientTransactionContext transactionContext;
    29|     ClientTxnProxy(String name, ClientTransactionContext transactionContext) {
    30|         this.name = name;
    31|         this.transactionContext = transactionContext;
    32|     }
    33|     @Override
    34|     public String getName() {
    35|         return name;
    36|     }
    37|     @Override
    38|     public String getPartitionKey() {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/txn/TransactionContextProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy.txn;
    17| import com.hazelcast.client.connection.nio.ClientConnection;
    18| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    19| import com.hazelcast.client.spi.ClientTransactionContext;
    20| import com.hazelcast.client.spi.impl.ClientTransactionManagerServiceImpl;
    21| import com.hazelcast.collection.impl.list.ListService;
    22| import com.hazelcast.collection.impl.queue.QueueService;
    23| import com.hazelcast.collection.impl.set.SetService;
    24| import com.hazelcast.core.TransactionalList;
    25| import com.hazelcast.core.TransactionalMap;
    26| import com.hazelcast.core.TransactionalMultiMap;
    27| import com.hazelcast.core.TransactionalQueue;
    28| import com.hazelcast.core.TransactionalSet;
    29| import com.hazelcast.map.impl.MapService;
    30| import com.hazelcast.multimap.impl.MultiMapService;
    31| import com.hazelcast.transaction.TransactionException;
    32| import com.hazelcast.transaction.TransactionNotActiveException;
    33| import com.hazelcast.transaction.TransactionOptions;
    34| import com.hazelcast.transaction.TransactionalObject;
    35| import com.hazelcast.transaction.impl.Transaction;
    36| import com.hazelcast.transaction.impl.TransactionalObjectKey;
    37| import javax.transaction.xa.XAResource;
    38| import java.util.HashMap;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/txn/TransactionProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy.txn;
    17| import com.hazelcast.client.connection.nio.ClientConnection;
    18| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    19| import com.hazelcast.client.impl.protocol.ClientMessage;
    20| import com.hazelcast.client.impl.protocol.codec.TransactionCommitCodec;
    21| import com.hazelcast.client.impl.protocol.codec.TransactionCreateCodec;
    22| import com.hazelcast.client.impl.protocol.codec.TransactionRollbackCodec;
    23| import com.hazelcast.logging.ILogger;
    24| import com.hazelcast.transaction.TransactionException;
    25| import com.hazelcast.transaction.TransactionNotActiveException;
    26| import com.hazelcast.transaction.TransactionOptions;
    27| import com.hazelcast.util.Clock;
    28| import com.hazelcast.util.ThreadUtil;
    29| import static com.hazelcast.transaction.impl.Transaction.State;
    30| import static com.hazelcast.transaction.impl.Transaction.State.ACTIVE;
    31| import static com.hazelcast.transaction.impl.Transaction.State.COMMITTED;
    32| import static com.hazelcast.transaction.impl.Transaction.State.COMMITTING;
    33| import static com.hazelcast.transaction.impl.Transaction.State.COMMIT_FAILED;
    34| import static com.hazelcast.transaction.impl.Transaction.State.NO_TXN;
    35| import static com.hazelcast.transaction.impl.Transaction.State.ROLLED_BACK;
    36| import static com.hazelcast.transaction.impl.Transaction.State.ROLLING_BACK;
    37| import static com.hazelcast.util.ExceptionUtil.rethrow;
    38| final class TransactionProxy {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/txn/xa/XATransactionContextProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy.txn.xa;
    17| import com.hazelcast.client.connection.nio.ClientConnection;
    18| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    19| import com.hazelcast.client.proxy.txn.ClientTxnListProxy;
    20| import com.hazelcast.client.proxy.txn.ClientTxnMapProxy;
    21| import com.hazelcast.client.proxy.txn.ClientTxnMultiMapProxy;
    22| import com.hazelcast.client.proxy.txn.ClientTxnQueueProxy;
    23| import com.hazelcast.client.proxy.txn.ClientTxnSetProxy;
    24| import com.hazelcast.client.spi.ClientTransactionContext;
    25| import com.hazelcast.client.spi.impl.ClientTransactionManagerServiceImpl;
    26| import com.hazelcast.collection.impl.list.ListService;
    27| import com.hazelcast.collection.impl.queue.QueueService;
    28| import com.hazelcast.collection.impl.set.SetService;
    29| import com.hazelcast.core.HazelcastException;
    30| import com.hazelcast.core.TransactionalList;
    31| import com.hazelcast.core.TransactionalMap;
    32| import com.hazelcast.core.TransactionalMultiMap;
    33| import com.hazelcast.core.TransactionalQueue;
    34| import com.hazelcast.core.TransactionalSet;
    35| import com.hazelcast.map.impl.MapService;
    36| import com.hazelcast.multimap.impl.MultiMapService;
    37| import com.hazelcast.transaction.TransactionException;
    38| import com.hazelcast.transaction.TransactionNotActiveException;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/txn/xa/XATransactionProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy.txn.xa;
    17| import com.hazelcast.client.connection.nio.ClientConnection;
    18| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    19| import com.hazelcast.client.impl.protocol.ClientMessage;
    20| import com.hazelcast.client.impl.protocol.codec.XATransactionCommitCodec;
    21| import com.hazelcast.client.impl.protocol.codec.XATransactionCreateCodec;
    22| import com.hazelcast.client.impl.protocol.codec.XATransactionPrepareCodec;
    23| import com.hazelcast.client.impl.protocol.codec.XATransactionRollbackCodec;
    24| import com.hazelcast.client.proxy.txn.ClientTransactionUtil;
    25| import com.hazelcast.logging.ILogger;
    26| import com.hazelcast.transaction.TransactionException;
    27| import com.hazelcast.transaction.TransactionNotActiveException;
    28| import com.hazelcast.transaction.impl.Transaction;
    29| import com.hazelcast.transaction.impl.xa.SerializableXID;
    30| import com.hazelcast.util.Clock;
    31| import javax.transaction.xa.XAException;
    32| import javax.transaction.xa.Xid;
    33| import java.util.concurrent.TimeUnit;
    34| import static com.hazelcast.transaction.impl.Transaction.State.ACTIVE;
    35| import static com.hazelcast.transaction.impl.Transaction.State.COMMITTED;
    36| import static com.hazelcast.transaction.impl.Transaction.State.COMMITTING;
    37| import static com.hazelcast.transaction.impl.Transaction.State.COMMIT_FAILED;
    38| import static com.hazelcast.transaction.impl.Transaction.State.NO_TXN;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/ClientContext.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-47 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi;
    17| import com.hazelcast.cache.impl.CacheService;
    18| import com.hazelcast.client.cache.impl.nearcache.invalidation.ClientCacheMetaDataFetcher;
    19| import com.hazelcast.client.config.ClientConfig;
    20| import com.hazelcast.client.connection.ClientConnectionManager;
    21| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    22| import com.hazelcast.client.impl.querycache.ClientQueryCacheContext;
    23| import com.hazelcast.client.map.impl.nearcache.invalidation.ClientMapMetaDataFetcher;
    24| import com.hazelcast.core.HazelcastInstance;
    25| import com.hazelcast.core.LifecycleService;
    26| import com.hazelcast.internal.nearcache.NearCacheManager;
    27| import com.hazelcast.internal.nearcache.impl.invalidation.MetaDataFetcher;
    28| import com.hazelcast.internal.nearcache.impl.invalidation.MinimalPartitionService;
    29| import com.hazelcast.internal.nearcache.impl.invalidation.RepairingTask;
    30| import com.hazelcast.logging.ILogger;
    31| import com.hazelcast.logging.LoggingService;
    32| import com.hazelcast.map.impl.MapService;
    33| import com.hazelcast.nio.serialization.Data;
    34| import com.hazelcast.spi.properties.HazelcastProperties;
    35| import com.hazelcast.spi.serialization.SerializationService;
    36| import com.hazelcast.util.ConstructorFunction;
    37| import java.util.concurrent.ConcurrentHashMap;
    38| import java.util.concurrent.ConcurrentMap;
    39| import static com.hazelcast.util.ConcurrencyUtil.getOrPutIfAbsent;
    40| import static java.lang.String.format;
    41| /**
    42|  * Context holding all the required services, managers and the configuration for a Hazelcast client.
    43|  */
    44| public final class ClientContext {
    45|     private String localUuid;
    46|     private final SerializationService serializationService;
    47|     private final ClientClusterService clusterService;

# --- HUNK 2: Lines 84-134 ---
    84|         this.loggingService = client.getLoggingService();
    85|         this.nearCacheManager = client.getNearCacheManager();
    86|         this.properties = client.getProperties();
    87|         this.localUuid = client.getLocalEndpoint().getUuid();
    88|         this.minimalPartitionService = new ClientMinimalPartitionService();
    89|         this.queryCacheContext = new ClientQueryCacheContext(this);
    90|     }
    91|     public ClientQueryCacheContext getQueryCacheContext() {
    92|         return queryCacheContext;
    93|     }
    94|     public RepairingTask getRepairingTask(String serviceName) {
    95|         return getOrPutIfAbsent(repairingTasks, serviceName, repairingTaskConstructor);
    96|     }
    97|     private String getLocalUuid() {
    98|         if (this.localUuid == null) {
    99|             this.localUuid = clusterService.getLocalClient().getUuid();
   100|         }
   101|         return this.localUuid;
   102|     }
   103|     private RepairingTask newRepairingTask(String serviceName) {
   104|         MetaDataFetcher metaDataFetcher = newMetaDataFetcher(serviceName);
   105|         ILogger logger = loggingService.getLogger(RepairingTask.class);
   106|         return new RepairingTask(properties, metaDataFetcher, executionService, serializationService, minimalPartitionService,
   107|                 getLocalUuid(), logger);
   108|     }
   109|     private MetaDataFetcher newMetaDataFetcher(String serviceName) {
   110|         if (MapService.SERVICE_NAME.equals(serviceName)) {
   111|             return new ClientMapMetaDataFetcher(this);
   112|         }
   113|         if (CacheService.SERVICE_NAME.equals(serviceName)) {
   114|             return new ClientCacheMetaDataFetcher(this);
   115|         }
   116|         throw new IllegalArgumentException(format("%s is not a known service-name to fetch metadata for", serviceName));
   117|     }
   118|     public String getName() {
   119|         return name;
   120|     }
   121|     /**
   122|      * Client side implementation of {@link MinimalPartitionService}
   123|      */
   124|     private class ClientMinimalPartitionService implements MinimalPartitionService {
   125|         @Override
   126|         public int getPartitionId(Data key) {
   127|             return partitionService.getPartitionId(key);
   128|         }
   129|         @Override
   130|         public int getPartitionId(Object key) {
   131|             return partitionService.getPartitionId(key);
   132|         }
   133|         @Override
   134|         public int getPartitionCount() {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/ClientProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi;
    17| import com.hazelcast.client.connection.ClientConnectionManager;
    18| import com.hazelcast.client.connection.nio.ClientConnection;
    19| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    20| import com.hazelcast.client.impl.protocol.ClientMessage;
    21| import com.hazelcast.client.impl.protocol.codec.ClientDestroyProxyCodec;
    22| import com.hazelcast.client.spi.impl.ClientInvocation;
    23| import com.hazelcast.client.spi.impl.ListenerMessageCodec;
    24| import com.hazelcast.core.DistributedObject;
    25| import com.hazelcast.nio.Address;
    26| import com.hazelcast.nio.serialization.Data;
    27| import com.hazelcast.partition.strategy.StringPartitioningStrategy;
    28| import com.hazelcast.spi.serialization.SerializationService;
    29| import com.hazelcast.util.ExceptionUtil;
    30| import java.util.Collection;
    31| import java.util.concurrent.Future;
    32| import static com.hazelcast.instance.BuildInfo.UNKNOWN_HAZELCAST_VERSION;
    33| import static com.hazelcast.util.ExceptionUtil.rethrow;
    34| /**
    35|  * Base class for client proxies.
    36|  * <p>
    37|  * Allows the client to proxy operations through member nodes.
    38|  */
    39| public abstract class ClientProxy implements DistributedObject {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/ClientTransactionContext.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi;
    17| import com.hazelcast.client.connection.nio.ClientConnection;
    18| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    19| import com.hazelcast.transaction.TransactionContext;
    20| /**
    21|  * Provides a context to perform transactional operations: beginning/committing transactions, but also retrieving
    22|  * transactional data-structures like the {@link com.hazelcast.core.TransactionalMap}.
    23|  *
    24|  * Provides client instance and client connection proxies that need to be accessed for sending invocations.
    25|  */
    26| public interface ClientTransactionContext extends TransactionContext {
    27|     HazelcastClientInstanceImpl getClient();
    28|     ClientConnection getConnection();
    29| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/ProxyManager.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 6-46 ---
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi;
    17| import com.hazelcast.cache.impl.ICacheService;
    18| import com.hazelcast.cache.impl.JCacheDetector;
    19| import com.hazelcast.cardinality.impl.CardinalityEstimatorService;
    20| import com.hazelcast.client.ClientExtension;
    21| import com.hazelcast.client.HazelcastClientOfflineException;
    22| import com.hazelcast.client.LoadBalancer;
    23| import com.hazelcast.client.cache.impl.ClientCacheProxyFactory;
    24| import com.hazelcast.client.config.ClientConfig;
    25| import com.hazelcast.client.config.ProxyFactoryConfig;
    26| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    27| import com.hazelcast.client.impl.protocol.ClientMessage;
    28| import com.hazelcast.client.impl.protocol.codec.ClientAddDistributedObjectListenerCodec;
    29| import com.hazelcast.client.impl.protocol.codec.ClientCreateProxiesCodec;
    30| import com.hazelcast.client.impl.protocol.codec.ClientCreateProxyCodec;
    31| import com.hazelcast.client.impl.protocol.codec.ClientRemoveDistributedObjectListenerCodec;
    32| import com.hazelcast.client.proxy.ClientAtomicLongProxy;
    33| import com.hazelcast.client.proxy.ClientAtomicReferenceProxy;
    34| import com.hazelcast.client.proxy.ClientCardinalityEstimatorProxy;
    35| import com.hazelcast.client.proxy.ClientCountDownLatchProxy;
    36| import com.hazelcast.client.proxy.ClientDurableExecutorServiceProxy;
    37| import com.hazelcast.client.proxy.ClientExecutorServiceProxy;
    38| import com.hazelcast.client.proxy.ClientFlakeIdGeneratorProxy;
    39| import com.hazelcast.client.proxy.ClientIdGeneratorProxy;
    40| import com.hazelcast.client.proxy.ClientListProxy;
    41| import com.hazelcast.client.proxy.ClientLockProxy;
    42| import com.hazelcast.client.proxy.ClientMapReduceProxy;
    43| import com.hazelcast.client.proxy.ClientMultiMapProxy;
    44| import com.hazelcast.client.proxy.ClientPNCounterProxy;
    45| import com.hazelcast.client.proxy.ClientQueueProxy;
    46| import com.hazelcast.client.proxy.ClientReliableTopicProxy;

# --- HUNK 2: Lines 94-134 ---
    94| import com.hazelcast.topic.impl.reliable.ReliableTopicService;
    95| import com.hazelcast.transaction.impl.xa.XAService;
    96| import java.io.IOException;
    97| import java.lang.reflect.Constructor;
    98| import java.util.AbstractMap;
    99| import java.util.Collection;
   100| import java.util.Iterator;
   101| import java.util.LinkedList;
   102| import java.util.List;
   103| import java.util.Map;
   104| import java.util.concurrent.ConcurrentHashMap;
   105| import java.util.concurrent.ConcurrentMap;
   106| import java.util.concurrent.ExecutionException;
   107| import static com.hazelcast.util.ExceptionUtil.rethrow;
   108| import static com.hazelcast.util.ServiceLoader.classIterator;
   109| import static java.lang.Thread.currentThread;
   110| /**
   111|  * The ProxyManager handles client proxy instantiation and retrieval at start and runtime by registering
   112|  * corresponding service manager names and their {@link com.hazelcast.client.spi.ClientProxyFactory}s.
   113|  */
   114| @SuppressWarnings({"checkstyle:classfanoutcomplexity", "checkstyle:classdataabstractioncoupling"})
   115| public final class ProxyManager {
   116|     private static final String PROVIDER_ID = ClientProxyDescriptorProvider.class.getCanonicalName();
   117|     private static final Class[] LEGACY_CONSTRUCTOR_ARGUMENT_TYPES = new Class[]{String.class, String.class};
   118|     private static final Class[] CONSTRUCTOR_ARGUMENT_TYPES = new Class[]{String.class, String.class, ClientContext.class};
   119|     private final ConcurrentMap<String, ClientProxyFactory> proxyFactories = new ConcurrentHashMap<String, ClientProxyFactory>();
   120|     private final ConcurrentMap<ObjectNamespace, ClientProxyFuture> proxies
   121|             = new ConcurrentHashMap<ObjectNamespace, ClientProxyFuture>();
   122|     private final ListenerMessageCodec distributedObjectListenerCodec = new ListenerMessageCodec() {
   123|         @Override
   124|         public ClientMessage encodeAddRequest(boolean localOnly) {
   125|             return ClientAddDistributedObjectListenerCodec.encodeRequest(localOnly);
   126|         }
   127|         @Override
   128|         public String decodeAddResponse(ClientMessage clientMessage) {
   129|             return ClientAddDistributedObjectListenerCodec.decodeResponse(clientMessage).response;
   130|         }
   131|         @Override
   132|         public ClientMessage encodeRemoveRequest(String realRegistrationId) {
   133|             return ClientRemoveDistributedObjectListenerCodec.encodeRequest(realRegistrationId);
   134|         }

# --- HUNK 3: Lines 434-474 ---
   434|         }
   435|         ClientMessage clientMessage = ClientCreateProxiesCodec.encodeRequest(proxyEntries);
   436|         new ClientInvocation(client, clientMessage, null, ownerConnection).invokeUrgent();
   437|         createCachesOnCluster();
   438|     }
   439|     private void createCachesOnCluster() {
   440|         ClientCacheProxyFactory proxyFactory = (ClientCacheProxyFactory) getClientProxyFactory(ICacheService.SERVICE_NAME);
   441|         if (proxyFactory != null) {
   442|             proxyFactory.recreateCachesOnCluster();
   443|         }
   444|     }
   445|     private final class DistributedObjectEventHandler extends ClientAddDistributedObjectListenerCodec.AbstractEventHandler
   446|             implements EventHandler<ClientMessage> {
   447|         private final DistributedObjectListener listener;
   448|         private ProxyManager proxyManager;
   449|         private DistributedObjectEventHandler(DistributedObjectListener listener, ProxyManager proxyManager) {
   450|             this.listener = listener;
   451|             this.proxyManager = proxyManager;
   452|         }
   453|         @Override
   454|         public void handle(String name, String serviceName, String eventTypeName) {
   455|             final ObjectNamespace ns = new DistributedObjectNamespace(serviceName, name);
   456|             ClientProxyFuture future = proxies.get(ns);
   457|             ClientProxy proxy = future == null ? null : future.get();
   458|             DistributedObjectEvent.EventType eventType = DistributedObjectEvent.EventType.valueOf(eventTypeName);
   459|             LazyDistributedObjectEvent event = new LazyDistributedObjectEvent(eventType, serviceName, name, proxy,
   460|                     proxyManager);
   461|             if (DistributedObjectEvent.EventType.CREATED.equals(eventType)) {
   462|                 listener.distributedObjectCreated(event);
   463|             } else if (DistributedObjectEvent.EventType.DESTROYED.equals(eventType)) {
   464|                 listener.distributedObjectDestroyed(event);
   465|             }
   466|         }
   467|         @Override
   468|         public void beforeListenerRegister() {
   469|         }
   470|         @Override
   471|         public void onListenerRegister() {
   472|         }
   473|     }
   474|     public boolean removeDistributedObjectListener(String id) {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/AbstractClientInvocationService.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-189 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl;
    17| import com.hazelcast.client.HazelcastClientNotActiveException;
    18| import com.hazelcast.client.connection.ClientConnectionManager;
    19| import com.hazelcast.client.connection.nio.ClientConnection;
    20| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    21| import com.hazelcast.client.impl.protocol.ClientMessage;
    22| import com.hazelcast.client.spi.ClientExecutionService;
    23| import com.hazelcast.client.spi.ClientInvocationService;
    24| import com.hazelcast.client.spi.ClientPartitionService;
    25| import com.hazelcast.client.spi.EventHandler;
    26| import com.hazelcast.client.spi.impl.listener.AbstractClientListenerService;
    27| import com.hazelcast.internal.metrics.Probe;
    28| import com.hazelcast.internal.metrics.ProbeLevel;
    29| import com.hazelcast.logging.ILogger;
    30| import com.hazelcast.spi.exception.TargetDisconnectedException;
    31| import com.hazelcast.spi.properties.HazelcastProperty;
    32| import java.io.IOException;
    33| import java.util.Iterator;
    34| import java.util.Map;
    35| import java.util.concurrent.ConcurrentHashMap;
    36| import java.util.concurrent.ConcurrentMap;
    37| import static com.hazelcast.client.spi.properties.ClientProperty.INVOCATION_RETRY_PAUSE_MILLIS;
    38| import static com.hazelcast.client.spi.properties.ClientProperty.INVOCATION_TIMEOUT_SECONDS;
    39| import static java.util.concurrent.TimeUnit.MILLISECONDS;
    40| public abstract class AbstractClientInvocationService implements ClientInvocationService {
    41|     private static final HazelcastProperty CLEAN_RESOURCES_MILLIS
    42|             = new HazelcastProperty("hazelcast.client.internal.clean.resources.millis", 100, MILLISECONDS);
    43|     protected final HazelcastClientInstanceImpl client;
    44|     protected ClientConnectionManager connectionManager;
    45|     protected ClientPartitionService partitionService;
    46|     final ILogger invocationLogger;
    47|     private AbstractClientListenerService clientListenerService;
    48|     @Probe(name = "pendingCalls", level = ProbeLevel.MANDATORY)
    49|     private ConcurrentMap<Long, ClientInvocation> invocations = new ConcurrentHashMap<Long, ClientInvocation>();
    50|     private ClientResponseHandlerSupplier responseHandlerSupplier;
    51|     private volatile boolean isShutdown;
    52|     private final long invocationTimeoutMillis;
    53|     private final long invocationRetryPauseMillis;
    54|     public AbstractClientInvocationService(HazelcastClientInstanceImpl client) {
    55|         this.client = client;
    56|         this.invocationLogger = client.getLoggingService().getLogger(ClientInvocationService.class);
    57|         this.invocationTimeoutMillis = initInvocationTimeoutMillis();
    58|         this.invocationRetryPauseMillis = initInvocationRetryPauseMillis();
    59|         this.responseHandlerSupplier = new ClientResponseHandlerSupplier(this);
    60|         client.getMetricsRegistry().scanAndRegister(this, "invocations");
    61|     }
    62|     private long initInvocationRetryPauseMillis() {
    63|         long pauseTime = client.getProperties().getMillis(INVOCATION_RETRY_PAUSE_MILLIS);
    64|         return pauseTime > 0 ? pauseTime : Long.parseLong(INVOCATION_RETRY_PAUSE_MILLIS.getDefaultValue());
    65|     }
    66|     private long initInvocationTimeoutMillis() {
    67|         long waitTime = client.getProperties().getMillis(INVOCATION_TIMEOUT_SECONDS);
    68|         return waitTime > 0 ? waitTime : Integer.parseInt(INVOCATION_TIMEOUT_SECONDS.getDefaultValue());
    69|     }
    70|     public void start() {
    71|         connectionManager = client.getConnectionManager();
    72|         clientListenerService = (AbstractClientListenerService) client.getListenerService();
    73|         partitionService = client.getClientPartitionService();
    74|         responseHandlerSupplier.start();
    75|         ClientExecutionService executionService = client.getClientExecutionService();
    76|         long cleanResourcesMillis = client.getProperties().getMillis(CLEAN_RESOURCES_MILLIS);
    77|         if (cleanResourcesMillis <= 0) {
    78|             cleanResourcesMillis = Integer.parseInt(CLEAN_RESOURCES_MILLIS.getDefaultValue());
    79|         }
    80|         executionService.scheduleWithRepetition(new CleanResourcesTask(), cleanResourcesMillis,
    81|                 cleanResourcesMillis, MILLISECONDS);
    82|     }
    83|     @Override
    84|     public ClientResponseHandler getResponseHandler() {
    85|         return responseHandlerSupplier.get();
    86|     }
    87|     @Override
    88|     public boolean isRedoOperation() {
    89|         return client.getClientConfig().getNetworkConfig().isRedoOperation();
    90|     }
    91|     protected void send(ClientInvocation invocation, ClientConnection connection) throws IOException {
    92|         if (isShutdown) {
    93|             throw new HazelcastClientNotActiveException("Client is shut down");
    94|         }
    95|         registerInvocation(invocation);
    96|         ClientMessage clientMessage = invocation.getClientMessage();
    97|         if (!isAllowedToSendRequest(connection, invocation) || !writeToConnection(connection, clientMessage)) {
    98|             final long callId = clientMessage.getCorrelationId();
    99|             ClientInvocation clientInvocation = deRegisterCallId(callId);
   100|             if (clientInvocation != null) {
   101|                 throw new IOException("Packet not sent to " + connection.getEndPoint());
   102|             } else {
   103|                 if (invocationLogger.isFinestEnabled()) {
   104|                     invocationLogger.finest("Invocation not found to deregister for call ID " + callId);
   105|                 }
   106|                 return;
   107|             }
   108|         }
   109|         invocation.setSendConnection(connection);
   110|     }
   111|     private boolean writeToConnection(ClientConnection connection, ClientMessage clientMessage) {
   112|         clientMessage.addFlag(ClientMessage.BEGIN_AND_END_FLAGS);
   113|         return connection.write(clientMessage);
   114|     }
   115|     private boolean isAllowedToSendRequest(ClientConnection connection, ClientInvocation invocation) {
   116|         if (!connection.isHeartBeating()) {
   117|             if (invocation.shouldBypassHeartbeatCheck()) {
   118|                 return true;
   119|             }
   120|             if (invocationLogger.isFinestEnabled()) {
   121|                 invocationLogger.finest("Connection is not heart-beating, won't write client message -> "
   122|                         + invocation.getClientMessage());
   123|             }
   124|             return false;
   125|         }
   126|         return true;
   127|     }
   128|     private void registerInvocation(ClientInvocation clientInvocation) {
   129|         short protocolVersion = client.getProtocolVersion();
   130|         ClientMessage clientMessage = clientInvocation.getClientMessage();
   131|         clientMessage.setVersion(protocolVersion);
   132|         long correlationId = clientMessage.getCorrelationId();
   133|         invocations.put(correlationId, clientInvocation);
   134|         EventHandler handler = clientInvocation.getEventHandler();
   135|         if (handler != null) {
   136|             clientListenerService.addEventHandler(correlationId, handler);
   137|         }
   138|     }
   139|     ClientInvocation deRegisterCallId(long callId) {
   140|         return invocations.remove(callId);
   141|     }
   142|     public boolean isShutdown() {
   143|         return isShutdown;
   144|     }
   145|     public void shutdown() {
   146|         isShutdown = true;
   147|         responseHandlerSupplier.shutdown();
   148|         Iterator<ClientInvocation> iterator = invocations.values().iterator();
   149|         while (iterator.hasNext()) {
   150|             ClientInvocation invocation = iterator.next();
   151|             iterator.remove();
   152|             invocation.notifyException(new HazelcastClientNotActiveException("Client is shutting down"));
   153|         }
   154|     }
   155|     public long getInvocationTimeoutMillis() {
   156|         return invocationTimeoutMillis;
   157|     }
   158|     public long getInvocationRetryPauseMillis() {
   159|         return invocationRetryPauseMillis;
   160|     }
   161|     private class CleanResourcesTask implements Runnable {
   162|         @Override
   163|         public void run() {
   164|             Iterator<Map.Entry<Long, ClientInvocation>> iter = invocations.entrySet().iterator();
   165|             while (iter.hasNext()) {
   166|                 Map.Entry<Long, ClientInvocation> entry = iter.next();
   167|                 ClientInvocation invocation = entry.getValue();
   168|                 ClientConnection connection = invocation.getSendConnection();
   169|                 if (connection == null) {
   170|                     continue;
   171|                 }
   172|                 if (connection.isHeartBeating()) {
   173|                     continue;
   174|                 }
   175|                 iter.remove();
   176|                 notifyException(invocation, connection);
   177|             }
   178|         }
   179|         private void notifyException(ClientInvocation invocation, ClientConnection connection) {
   180|             Exception ex;
   181|             if (!connection.isAlive()) {
   182|                 ex = new TargetDisconnectedException(connection.getCloseReason(), connection.getCloseCause());
   183|             } else {
   184|                 ex = new TargetDisconnectedException("Heartbeat timed out to " + connection);
   185|             }
   186|             invocation.notifyException(ex);
   187|         }
   188|     }
   189| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/AwsAddressProvider.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-63 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl;
    17| import com.hazelcast.aws.AWSClient;
    18| import com.hazelcast.client.config.ClientAwsConfig;
    19| import com.hazelcast.client.connection.AddressProvider;
    20| import com.hazelcast.client.util.AddressHelper;
    21| import com.hazelcast.logging.ILogger;
    22| import com.hazelcast.logging.LoggingService;
    23| import com.hazelcast.nio.Address;
    24| import java.util.ArrayList;
    25| import java.util.Collection;
    26| import java.util.Collections;
    27| import java.util.Map;
    28| /**
    29|  * Calls the AWS API to load ip addresses related to given credentials.
    30|  */
    31| public class AwsAddressProvider implements AddressProvider {
    32|     private final ILogger logger;
    33|     private final AWSClient awsClient;
    34|     private volatile Map<String, String> privateToPublic;
    35|     public AwsAddressProvider(ClientAwsConfig awsConfig, LoggingService loggingService) {
    36|         this(new AWSClient(awsConfig), loggingService);
    37|     }
    38|     AwsAddressProvider(AWSClient awsClient, LoggingService loggingService) {
    39|         this.awsClient = awsClient;
    40|         this.logger = loggingService.getLogger(AwsAddressProvider.class);
    41|     }
    42|     @Override
    43|     public Collection<Address> loadAddresses() {
    44|         updateLookupTable();
    45|         final Map<String, String> lookupTable = getLookupTable();
    46|         final Collection<Address> addresses = new ArrayList<Address>(lookupTable.size());
    47|         for (String privateAddress : lookupTable.keySet()) {
    48|             addresses.addAll(AddressHelper.getSocketAddresses(privateAddress));
    49|         }
    50|         return addresses;
    51|     }
    52|     private Map<String, String> getLookupTable() {
    53|         Map<String, String> table = privateToPublic;
    54|         return table != null ? table : Collections.<String, String>emptyMap();
    55|     }
    56|     private void updateLookupTable() {
    57|         try {
    58|             privateToPublic = awsClient.getAddresses();
    59|         } catch (Exception e) {
    60|             logger.warning("Aws addresses failed to load: " + e.getMessage());
    61|         }
    62|     }
    63| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/AwsAddressTranslator.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-90 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl;
    17| import com.hazelcast.aws.AWSClient;
    18| import com.hazelcast.client.config.ClientAwsConfig;
    19| import com.hazelcast.client.connection.AddressTranslator;
    20| import com.hazelcast.logging.ILogger;
    21| import com.hazelcast.logging.LoggingService;
    22| import com.hazelcast.nio.Address;
    23| import java.net.UnknownHostException;
    24| import java.util.HashMap;
    25| import java.util.Map;
    26| /**
    27|  * AwsAddressTranslator loads EC2 IP addresses with given AWS credentials.
    28|  *
    29|  * Keeps a lookup table of private to public IP addresses.
    30|  */
    31| public class AwsAddressTranslator implements AddressTranslator {
    32|     private final ILogger logger;
    33|     private final AWSClient awsClient;
    34|     private final boolean isInsideAws;
    35|     private volatile Map<String, String> privateToPublic = new HashMap<String, String>();
    36|     public AwsAddressTranslator(ClientAwsConfig awsConfig, LoggingService loggingService) {
    37|         this(new AWSClient(awsConfig), awsConfig, loggingService);
    38|     }
    39|     AwsAddressTranslator(AWSClient awsClient, ClientAwsConfig awsConfig, LoggingService loggingService) {
    40|         this.awsClient = awsClient;
    41|         this.isInsideAws = awsConfig.isInsideAws();
    42|         this.logger = loggingService.getLogger(AwsAddressTranslator.class);
    43|     }
    44|     /**
    45|      * Translates an IP address from the private AWS network to the public network.
    46|      *
    47|      * @param address the private address to translate
    48|      * @return public address of network whose private address is given, if address not founds returns {@code null}.
    49|      */
    50|     @Override
    51|     public Address translate(Address address) {
    52|         if (isInsideAws) {
    53|             return address;
    54|         }
    55|         if (address == null) {
    56|             return null;
    57|         }
    58|         String publicAddress = privateToPublic.get(address.getHost());
    59|         if (publicAddress != null) {
    60|             return createAddressOrNull(publicAddress, address);
    61|         }
    62|         if (privateToPublic.values().contains(address.getHost())) {
    63|             return address;
    64|         }
    65|         refresh();
    66|         publicAddress = privateToPublic.get(address.getHost());
    67|         if (publicAddress != null) {
    68|             return createAddressOrNull(publicAddress, address);
    69|         }
    70|         return null;
    71|     }
    72|     @Override
    73|     public void refresh() {
    74|         try {
    75|             privateToPublic = awsClient.getAddresses();
    76|         } catch (Exception e) {
    77|             logger.warning("AWS addresses failed to load: " + e.getMessage());
    78|         }
    79|     }
    80|     Map<String, String> getLookupTable() {
    81|         return privateToPublic;
    82|     }
    83|     private static Address createAddressOrNull(String hostAddress, Address portAddress) {
    84|         try {
    85|             return new Address(hostAddress, portAddress.getPort());
    86|         } catch (UnknownHostException e) {
    87|             return null;
    88|         }
    89|     }
    90| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientClusterServiceImpl.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-42 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl;
    17| import com.hazelcast.client.config.ClientConfig;
    18| import com.hazelcast.client.connection.ClientConnectionManager;
    19| import com.hazelcast.client.connection.nio.ClientConnection;
    20| import com.hazelcast.client.impl.ClientImpl;
    21| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    22| import com.hazelcast.client.impl.client.ClientPrincipal;
    23| import com.hazelcast.client.spi.ClientClusterService;
    24| import com.hazelcast.config.ListenerConfig;
    25| import com.hazelcast.core.Client;
    26| import com.hazelcast.core.Cluster;
    27| import com.hazelcast.core.InitialMembershipEvent;
    28| import com.hazelcast.core.InitialMembershipListener;
    29| import com.hazelcast.core.Member;
    30| import com.hazelcast.core.MemberAttributeEvent;
    31| import com.hazelcast.core.MemberSelector;
    32| import com.hazelcast.core.MembershipEvent;
    33| import com.hazelcast.core.MembershipListener;
    34| import com.hazelcast.internal.cluster.impl.MemberSelectingCollection;
    35| import com.hazelcast.logging.ILogger;
    36| import com.hazelcast.nio.Address;
    37| import com.hazelcast.nio.ClassLoaderUtil;
    38| import com.hazelcast.nio.Connection;
    39| import com.hazelcast.util.Clock;
    40| import com.hazelcast.util.UuidUtil;
    41| import java.net.InetSocketAddress;
    42| import java.util.Collection;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientInvocation.java
# Total hunks: 5
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl;
    17| import com.hazelcast.client.HazelcastClientNotActiveException;
    18| import com.hazelcast.client.connection.nio.ClientConnection;
    19| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    20| import com.hazelcast.client.impl.protocol.ClientMessage;
    21| import com.hazelcast.client.spi.ClientClusterService;
    22| import com.hazelcast.client.spi.ClientExecutionService;
    23| import com.hazelcast.client.spi.EventHandler;
    24| import com.hazelcast.core.HazelcastInstanceNotActiveException;
    25| import com.hazelcast.core.HazelcastOverloadException;
    26| import com.hazelcast.core.LifecycleService;
    27| import com.hazelcast.core.OperationTimeoutException;
    28| import com.hazelcast.logging.ILogger;
    29| import com.hazelcast.nio.Address;
    30| import com.hazelcast.nio.Connection;
    31| import com.hazelcast.spi.exception.RetryableException;
    32| import com.hazelcast.spi.exception.TargetDisconnectedException;
    33| import com.hazelcast.spi.exception.TargetNotMemberException;
    34| import com.hazelcast.spi.impl.sequence.CallIdSequence;
    35| import java.io.IOException;
    36| import java.util.concurrent.Executor;
    37| import java.util.concurrent.RejectedExecutionException;
    38| import java.util.concurrent.TimeUnit;
    39| import java.util.concurrent.atomic.AtomicLongFieldUpdater;

# --- HUNK 2: Lines 49-111 ---
    49| public class ClientInvocation implements Runnable {
    50|     private static final int MAX_FAST_INVOCATION_COUNT = 5;
    51|     private static final int UNASSIGNED_PARTITION = -1;
    52|     private static final AtomicLongFieldUpdater<ClientInvocation> INVOKE_COUNT
    53|             = AtomicLongFieldUpdater.newUpdater(ClientInvocation.class, "invokeCount");
    54|     private final ClientInvocationFuture clientInvocationFuture;
    55|     private final ILogger logger;
    56|     private final LifecycleService lifecycleService;
    57|     private final ClientClusterService clientClusterService;
    58|     private final AbstractClientInvocationService invocationService;
    59|     private final ClientExecutionService executionService;
    60|     private volatile ClientMessage clientMessage;
    61|     private final CallIdSequence callIdSequence;
    62|     private final Address address;
    63|     private final int partitionId;
    64|     private final Connection connection;
    65|     private final long startTimeMillis;
    66|     private final long retryPauseMillis;
    67|     private final String objectName;
    68|     private volatile ClientConnection sendConnection;
    69|     private boolean bypassHeartbeatCheck;
    70|     private EventHandler handler;
    71|     private volatile long invokeCount;
    72|     private volatile long invocationTimeoutMillis;
    73|     protected ClientInvocation(HazelcastClientInstanceImpl client,
    74|                                ClientMessage clientMessage,
    75|                                String objectName,
    76|                                int partitionId,
    77|                                Address address,
    78|                                Connection connection) {
    79|         this.clientClusterService = client.getClientClusterService();
    80|         this.lifecycleService = client.getLifecycleService();
    81|         this.invocationService = (AbstractClientInvocationService) client.getInvocationService();
    82|         this.executionService = client.getClientExecutionService();
    83|         this.objectName = objectName;
    84|         this.clientMessage = clientMessage;
    85|         this.partitionId = partitionId;
    86|         this.address = address;
    87|         this.connection = connection;
    88|         this.startTimeMillis = System.currentTimeMillis();
    89|         this.retryPauseMillis = invocationService.getInvocationRetryPauseMillis();
    90|         this.logger = invocationService.invocationLogger;
    91|         this.callIdSequence = client.getCallIdSequence();
    92|         this.clientInvocationFuture = new ClientInvocationFuture(this, executionService,
    93|                 clientMessage, logger, callIdSequence);
    94|         this.invocationTimeoutMillis = invocationService.getInvocationTimeoutMillis();
    95|     }
    96|     /**
    97|      * Create an invocation that will be executed on random member.
    98|      */
    99|     public ClientInvocation(HazelcastClientInstanceImpl client, ClientMessage clientMessage, String objectName) {
   100|         this(client, clientMessage, objectName, UNASSIGNED_PARTITION, null, null);
   101|     }
   102|     /**
   103|      * Create an invocation that will be executed on owner of {@code partitionId}.
   104|      */
   105|     public ClientInvocation(HazelcastClientInstanceImpl client, ClientMessage clientMessage, String objectName,
   106|                             int partitionId) {
   107|         this(client, clientMessage, objectName, partitionId, null, null);
   108|     }
   109|     /**
   110|      * Create an invocation that will be executed on member with given {@code address}.
   111|      */

# --- HUNK 3: Lines 166-206 ---
   166|         clientMessage.setCorrelationId(callIdSequence.forceNext());
   167|         callIdSequence.complete();
   168|         try {
   169|             invokeOnSelection();
   170|         } catch (Throwable e) {
   171|             clientInvocationFuture.complete(e);
   172|         }
   173|     }
   174|     public void setInvocationTimeoutMillis(long invocationTimeoutMillis) {
   175|         this.invocationTimeoutMillis = invocationTimeoutMillis;
   176|     }
   177|     public void notify(ClientMessage clientMessage) {
   178|         if (clientMessage == null) {
   179|             throw new IllegalArgumentException("response can't be null");
   180|         }
   181|         clientInvocationFuture.complete(clientMessage);
   182|     }
   183|     public void notifyException(Throwable exception) {
   184|         logException(exception);
   185|         if (!lifecycleService.isRunning()) {
   186|             clientInvocationFuture.complete(new HazelcastClientNotActiveException(exception.getMessage(), exception));
   187|             return;
   188|         }
   189|         if (isNotAllowedToRetryOnSelection(exception)) {
   190|             clientInvocationFuture.complete(exception);
   191|             return;
   192|         }
   193|         boolean retry = isRetrySafeException(exception)
   194|                 || invocationService.isRedoOperation()
   195|                 || (exception instanceof TargetDisconnectedException && clientMessage.isRetryable());
   196|         if (!retry) {
   197|             clientInvocationFuture.complete(exception);
   198|             return;
   199|         }
   200|         long timePassed = System.currentTimeMillis() - startTimeMillis;
   201|         if (timePassed > invocationTimeoutMillis) {
   202|             if (logger.isFinestEnabled()) {
   203|                 logger.finest("Exception will not be retried because invocation timed out", exception);
   204|             }
   205|             clientInvocationFuture.complete(newOperationTimeoutException(exception));
   206|             return;

# --- HUNK 4: Lines 230-275 ---
   230|     }
   231|     private boolean isNotAllowedToRetryOnSelection(Throwable exception) {
   232|         if (isBindToSingleConnection() && exception instanceof IOException) {
   233|             return true;
   234|         }
   235|         if (address != null
   236|                 && exception instanceof TargetNotMemberException
   237|                 && clientClusterService.getMember(address) == null) {
   238|             return true;
   239|         }
   240|         return false;
   241|     }
   242|     private boolean isBindToSingleConnection() {
   243|         return connection != null;
   244|     }
   245|     public EventHandler getEventHandler() {
   246|         return handler;
   247|     }
   248|     public void setEventHandler(EventHandler handler) {
   249|         this.handler = handler;
   250|     }
   251|     public boolean shouldBypassHeartbeatCheck() {
   252|         return bypassHeartbeatCheck;
   253|     }
   254|     public void setBypassHeartbeatCheck(boolean bypassHeartbeatCheck) {
   255|         this.bypassHeartbeatCheck = bypassHeartbeatCheck;
   256|     }
   257|     public void setSendConnection(ClientConnection connection) {
   258|         this.sendConnection = connection;
   259|     }
   260|     public ClientConnection getSendConnectionOrWait() throws InterruptedException {
   261|         while (sendConnection == null && !clientInvocationFuture.isDone()) {
   262|             Thread.sleep(retryPauseMillis);
   263|         }
   264|         return sendConnection;
   265|     }
   266|     public ClientConnection getSendConnection() {
   267|         return sendConnection;
   268|     }
   269|     public static boolean isRetrySafeException(Throwable t) {
   270|         return t instanceof IOException
   271|                 || t instanceof HazelcastInstanceNotActiveException
   272|                 || t instanceof RetryableException;
   273|     }
   274|     public Executor getUserExecutor() {
   275|         return executionService.getUserExecutor();


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientMembershipListener.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl;
    17| import com.hazelcast.client.connection.nio.ClientConnectionManagerImpl;
    18| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    19| import com.hazelcast.client.impl.protocol.ClientMessage;
    20| import com.hazelcast.client.impl.protocol.codec.ClientAddMembershipListenerCodec;
    21| import com.hazelcast.client.spi.EventHandler;
    22| import com.hazelcast.cluster.MemberAttributeOperationType;
    23| import com.hazelcast.core.InitialMembershipEvent;
    24| import com.hazelcast.core.Member;
    25| import com.hazelcast.core.MemberAttributeEvent;
    26| import com.hazelcast.core.MembershipEvent;
    27| import com.hazelcast.instance.AbstractMember;
    28| import com.hazelcast.logging.ILogger;
    29| import com.hazelcast.nio.Address;
    30| import com.hazelcast.nio.Connection;
    31| import com.hazelcast.spi.exception.TargetDisconnectedException;
    32| import java.util.Collection;
    33| import java.util.Collections;
    34| import java.util.HashMap;
    35| import java.util.LinkedHashSet;
    36| import java.util.LinkedList;
    37| import java.util.List;
    38| import java.util.Map;

# --- HUNK 2: Lines 41-120 ---
    41| import java.util.concurrent.TimeUnit;
    42| import static java.util.Collections.unmodifiableSet;
    43| class ClientMembershipListener extends ClientAddMembershipListenerCodec.AbstractEventHandler
    44|         implements EventHandler<ClientMessage> {
    45|     private static final int INITIAL_MEMBERS_TIMEOUT_SECONDS = 5;
    46|     private final ILogger logger;
    47|     private final Set<Member> members = new LinkedHashSet<Member>();
    48|     private final HazelcastClientInstanceImpl client;
    49|     private final ClientClusterServiceImpl clusterService;
    50|     private final ClientPartitionServiceImpl partitionService;
    51|     private final ClientConnectionManagerImpl connectionManager;
    52|     private volatile CountDownLatch initialListFetchedLatch;
    53|     public ClientMembershipListener(HazelcastClientInstanceImpl client) {
    54|         this.client = client;
    55|         logger = client.getLoggingService().getLogger(ClientMembershipListener.class);
    56|         connectionManager = (ClientConnectionManagerImpl) client.getConnectionManager();
    57|         partitionService = (ClientPartitionServiceImpl) client.getClientPartitionService();
    58|         clusterService = (ClientClusterServiceImpl) client.getClientClusterService();
    59|     }
    60|     @Override
    61|     public void handle(Member member, int eventType) {
    62|         switch (eventType) {
    63|             case MembershipEvent.MEMBER_ADDED:
    64|                 memberAdded(member);
    65|                 break;
    66|             case MembershipEvent.MEMBER_REMOVED:
    67|                 memberRemoved(member);
    68|                 break;
    69|             default:
    70|                 logger.warning("Unknown event type: " + eventType);
    71|         }
    72|         partitionService.refreshPartitions();
    73|     }
    74|     @Override
    75|     public void handle(Collection<Member> initialMembers) {
    76|         Map<String, Member> prevMembers = Collections.emptyMap();
    77|         if (!members.isEmpty()) {
    78|             prevMembers = new HashMap<String, Member>(members.size());
    79|             for (Member member : members) {
    80|                 prevMembers.put(member.getUuid(), member);
    81|             }
    82|             members.clear();
    83|         }
    84|         for (Member initialMember : initialMembers) {
    85|             members.add(initialMember);
    86|         }
    87|         if (prevMembers.isEmpty()) {
    88|             logger.info(membersString());
    89|             clusterService.handleInitialMembershipEvent(
    90|                     new InitialMembershipEvent(client.getCluster(), unmodifiableSet(members)));
    91|             initialListFetchedLatch.countDown();
    92|             return;
    93|         }
    94|         List<MembershipEvent> events = detectMembershipEvents(prevMembers);
    95|         logger.info(membersString());
    96|         fireMembershipEvent(events);
    97|         initialListFetchedLatch.countDown();
    98|     }
    99|     @Override
   100|     public void handle(String uuid, String key, int opType, String value) {
   101|         Collection<Member> members = clusterService.getMemberList();
   102|         for (Member target : members) {
   103|             if (target.getUuid().equals(uuid)) {
   104|                 final MemberAttributeOperationType operationType = MemberAttributeOperationType.getValue(opType);
   105|                 ((AbstractMember) target).updateAttribute(operationType, key, value);
   106|                 MemberAttributeEvent memberAttributeEvent =
   107|                         new MemberAttributeEvent(client.getCluster(), target, operationType, key, value);
   108|                 clusterService.fireMemberAttributeEvent(memberAttributeEvent);
   109|                 break;
   110|             }
   111|         }
   112|     }
   113|     @Override
   114|     public void beforeListenerRegister() {
   115|     }
   116|     @Override
   117|     public void onListenerRegister() {
   118|     }
   119|     void listenMembershipEvents(Connection ownerConnection) throws Exception {
   120|         initialListFetchedLatch = new CountDownLatch(1);


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientPartitionServiceImpl.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl;
    17| import com.hazelcast.client.connection.ClientConnectionManager;
    18| import com.hazelcast.client.connection.nio.ClientConnection;
    19| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    20| import com.hazelcast.client.impl.protocol.ClientMessage;
    21| import com.hazelcast.client.impl.protocol.codec.ClientAddPartitionListenerCodec;
    22| import com.hazelcast.client.impl.protocol.codec.ClientGetPartitionsCodec;
    23| import com.hazelcast.client.spi.ClientClusterService;
    24| import com.hazelcast.client.spi.ClientPartitionService;
    25| import com.hazelcast.client.spi.EventHandler;
    26| import com.hazelcast.cluster.memberselector.MemberSelectors;
    27| import com.hazelcast.core.ExecutionCallback;
    28| import com.hazelcast.core.Member;
    29| import com.hazelcast.core.Partition;
    30| import com.hazelcast.instance.BuildInfo;
    31| import com.hazelcast.logging.ILogger;
    32| import com.hazelcast.nio.Address;
    33| import com.hazelcast.nio.Connection;
    34| import com.hazelcast.nio.serialization.Data;
    35| import com.hazelcast.partition.NoDataMemberInClusterException;
    36| import com.hazelcast.util.HashUtil;
    37| import java.util.Collection;
    38| import java.util.List;
    39| import java.util.Map;

# --- HUNK 2: Lines 65-105 ---
    65|     public void start() {
    66|         clientExecutionService.scheduleWithRepetition(new RefreshTask(), INITIAL_DELAY, PERIOD, TimeUnit.SECONDS);
    67|     }
    68|     public void listenPartitionTable(Connection ownerConnection) throws Exception {
    69|         lastPartitionStateVersion = -1;
    70|         if (((ClientConnection) ownerConnection).getConnectedServerVersion() >= BuildInfo.calculateVersion("3.9")) {
    71|             ClientMessage clientMessage = ClientAddPartitionListenerCodec.encodeRequest();
    72|             ClientInvocation invocation = new ClientInvocation(client, clientMessage, null, ownerConnection);
    73|             invocation.setEventHandler(this);
    74|             invocation.invokeUrgent().get();
    75|         }
    76|     }
    77|     public void refreshPartitions() {
    78|         try {
    79|             clientExecutionService.execute(new RefreshTask());
    80|         } catch (RejectedExecutionException ignored) {
    81|             ignore(ignored);
    82|         }
    83|     }
    84|     @Override
    85|     public void handle(Collection<Map.Entry<Address, List<Integer>>> collection, int partitionStateVersion) {
    86|         processPartitionResponse(collection, partitionStateVersion, true);
    87|     }
    88|     @Override
    89|     public void beforeListenerRegister() {
    90|     }
    91|     @Override
    92|     public void onListenerRegister() {
    93|     }
    94|     private void waitForPartitionsFetchedOnce() {
    95|         while (partitionCount == 0 && client.getConnectionManager().isAlive()) {
    96|             if (isClusterFormedByOnlyLiteMembers()) {
    97|                 throw new NoDataMemberInClusterException(
    98|                         "Partitions can't be assigned since all nodes in the cluster are lite members");
    99|             }
   100|             ClientMessage requestMessage = ClientGetPartitionsCodec.encodeRequest();
   101|             ClientInvocationFuture future = new ClientInvocation(client, requestMessage, null).invokeUrgent();
   102|             try {
   103|                 ClientMessage responseMessage = future.get();
   104|                 ClientGetPartitionsCodec.ResponseParameters response =
   105|                         ClientGetPartitionsCodec.decodeResponse(responseMessage);


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientResponseHandler.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-24 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl;
    17| import com.hazelcast.client.connection.nio.ClientConnection;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| /**
    20|  * Responsible for handling responses to invocations.
    21|  */
    22| public interface ClientResponseHandler {
    23|     void handle(ClientMessage message, ClientConnection connection);
    24| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientResponseHandlerSupplier.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl;
    17| import com.hazelcast.client.connection.nio.ClientConnection;
    18| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    19| import com.hazelcast.client.impl.protocol.ClientMessage;
    20| import com.hazelcast.client.impl.protocol.codec.ErrorCodec;
    21| import com.hazelcast.internal.util.concurrent.MPSCQueue;
    22| import com.hazelcast.logging.ILogger;
    23| import com.hazelcast.spi.properties.HazelcastProperty;
    24| import com.hazelcast.util.MutableInteger;
    25| import com.hazelcast.util.function.Supplier;
    26| import java.util.concurrent.BlockingQueue;
    27| import static com.hazelcast.client.spi.properties.ClientProperty.RESPONSE_THREAD_COUNT;
    28| import static com.hazelcast.instance.OutOfMemoryErrorDispatcher.onOutOfMemory;
    29| import static com.hazelcast.spi.impl.operationservice.impl.InboundResponseHandlerSupplier.getIdleStrategy;
    30| import static com.hazelcast.util.HashUtil.hashToIndex;
    31| /**
    32|  * A {@link Supplier} for {@link ClientResponseHandler} instance.
    33|  *
    34|  * Depending on the configuration the supplier provides:
    35|  * <ol>
    36|  * <li>a on thread ClientResponseHandler (so no offloading to a different thread)</li>
    37|  * <li>a single threaded ClientResponseHandler that offloads the response processing
    38|  * a ResponseThread/li>

# --- HUNK 2: Lines 77-176 ---
    77|                 this.responseHandler = new AsyncSingleThreadedResponseHandler();
    78|                 break;
    79|             default:
    80|                 this.responseHandler = new AsyncMultiThreadedResponseHandler();
    81|         }
    82|     }
    83|     public void start() {
    84|         for (ResponseThread responseThread : responseThreads) {
    85|             responseThread.start();
    86|         }
    87|     }
    88|     public void shutdown() {
    89|         for (ResponseThread responseThread : responseThreads) {
    90|             responseThread.interrupt();
    91|         }
    92|     }
    93|     @Override
    94|     public ClientResponseHandler get() {
    95|         return responseHandler;
    96|     }
    97|     private void process(ClientConnection connection, ClientMessage message) {
    98|         try {
    99|             handleClientMessage(message);
   100|         } catch (Exception e) {
   101|             logger.severe("Failed to process task: " + new ClientPacket(connection, message)
   102|                     + " on responseThread: " + Thread.currentThread().getName(), e);
   103|         } finally {
   104|             connection.decrementPendingPacketCount();
   105|         }
   106|     }
   107|     private void handleClientMessage(ClientMessage clientMessage) {
   108|         long correlationId = clientMessage.getCorrelationId();
   109|         ClientInvocation future = invocationService.deRegisterCallId(correlationId);
   110|         if (future == null) {
   111|             logger.warning("No call for callId: " + correlationId + ", response: " + clientMessage);
   112|             return;
   113|         }
   114|         if (ErrorCodec.TYPE == clientMessage.getMessageType()) {
   115|             future.notifyException(client.getClientExceptionFactory().createException(clientMessage));
   116|         } else {
   117|             future.notify(clientMessage);
   118|         }
   119|     }
   120|     private class ResponseThread extends Thread {
   121|         private final BlockingQueue<ClientPacket> responseQueue;
   122|         ResponseThread(String name) {
   123|             super(name);
   124|             setContextClassLoader(client.getClientConfig().getClassLoader());
   125|             this.responseQueue = new MPSCQueue<ClientPacket>(this, getIdleStrategy(client.getProperties(), IDLE_STRATEGY));
   126|         }
   127|         @Override
   128|         public void run() {
   129|             try {
   130|                 doRun();
   131|             } catch (OutOfMemoryError e) {
   132|                 onOutOfMemory(e);
   133|             } catch (Throwable t) {
   134|                 invocationService.invocationLogger.severe(t);
   135|             }
   136|         }
   137|         private void doRun() {
   138|             while (!invocationService.isShutdown()) {
   139|                 ClientPacket task;
   140|                 try {
   141|                     task = responseQueue.take();
   142|                 } catch (InterruptedException e) {
   143|                     continue;
   144|                 }
   145|                 process(task.connection, task.message);
   146|             }
   147|         }
   148|     }
   149|     class SyncResponseHandler implements ClientResponseHandler {
   150|         @Override
   151|         public void handle(ClientMessage message, ClientConnection connection) {
   152|             process(connection, message);
   153|         }
   154|     }
   155|     class AsyncSingleThreadedResponseHandler implements ClientResponseHandler {
   156|         @Override
   157|         public void handle(ClientMessage message, ClientConnection connection) {
   158|             responseThreads[0].responseQueue.add(new ClientPacket(connection, message));
   159|         }
   160|     }
   161|     class AsyncMultiThreadedResponseHandler implements ClientResponseHandler {
   162|         @Override
   163|         public void handle(ClientMessage message, ClientConnection connection) {
   164|             int threadIndex = hashToIndex(INT_HOLDER.get().getAndInc(), responseThreads.length);
   165|             responseThreads[threadIndex].responseQueue.add(new ClientPacket(connection, message));
   166|         }
   167|     }
   168|     private static class ClientPacket {
   169|         private final ClientConnection connection;
   170|         private final ClientMessage message;
   171|         ClientPacket(ClientConnection connection, ClientMessage message) {
   172|             this.connection = connection;
   173|             this.message = message;
   174|         }
   175|     }
   176| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientTransactionManagerServiceImpl.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 3-43 ---
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl;
    17| import com.hazelcast.client.HazelcastClientNotActiveException;
    18| import com.hazelcast.client.HazelcastClientOfflineException;
    19| import com.hazelcast.client.LoadBalancer;
    20| import com.hazelcast.client.config.ClientConfig;
    21| import com.hazelcast.client.config.ClientConnectionStrategyConfig;
    22| import com.hazelcast.client.connection.nio.ClientConnection;
    23| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    24| import com.hazelcast.client.proxy.txn.TransactionContextProxy;
    25| import com.hazelcast.client.proxy.txn.xa.XATransactionContextProxy;
    26| import com.hazelcast.client.spi.ClientTransactionManagerService;
    27| import com.hazelcast.config.GroupConfig;
    28| import com.hazelcast.core.Member;
    29| import com.hazelcast.core.OperationTimeoutException;
    30| import com.hazelcast.nio.Address;
    31| import com.hazelcast.transaction.TransactionContext;
    32| import com.hazelcast.transaction.TransactionException;
    33| import com.hazelcast.transaction.TransactionOptions;
    34| import com.hazelcast.transaction.TransactionalTask;
    35| import javax.transaction.xa.Xid;
    36| import java.io.IOException;
    37| import java.util.Set;
    38| import static com.hazelcast.util.Clock.currentTimeMillis;
    39| import static com.hazelcast.util.StringUtil.timeToString;
    40| public class ClientTransactionManagerServiceImpl implements ClientTransactionManagerService {
    41|     private final HazelcastClientInstanceImpl client;
    42|     private final LoadBalancer loadBalancer;
    43|     public ClientTransactionManagerServiceImpl(HazelcastClientInstanceImpl client, LoadBalancer loadBalancer) {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientUserCodeDeploymentService.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl;
    17| import com.hazelcast.client.config.ClientUserCodeDeploymentConfig;
    18| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    19| import com.hazelcast.client.impl.protocol.ClientMessage;
    20| import com.hazelcast.client.impl.protocol.codec.ClientDeployClassesCodec;
    21| import com.hazelcast.nio.Connection;
    22| import java.io.ByteArrayOutputStream;
    23| import java.io.File;
    24| import java.io.FileInputStream;
    25| import java.io.FileNotFoundException;
    26| import java.io.IOException;
    27| import java.io.InputStream;
    28| import java.net.MalformedURLException;
    29| import java.net.URL;
    30| import java.util.AbstractMap;
    31| import java.util.ArrayList;
    32| import java.util.List;
    33| import java.util.Map;
    34| import java.util.concurrent.ExecutionException;
    35| import java.util.jar.JarEntry;
    36| import java.util.jar.JarInputStream;
    37| import java.util.regex.Matcher;
    38| import java.util.regex.Pattern;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ConnectionHeartbeatListener.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-31 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl;
    17| import com.hazelcast.nio.Connection;
    18| /**
    19|  * A listener for the {@link com.hazelcast.client.connection.ClientConnectionManager} to listen to connection heartbeats.
    20|  */
    21| public interface ConnectionHeartbeatListener {
    22|     /**
    23|      * This event will be fired when the heartbeat is resumed for a connection to a member.
    24|      */
    25|     void heartbeatResumed(Connection connection);
    26|     /**
    27|      * This event will be fired when no heartbeat response is received for
    28|      * {@link com.hazelcast.client.spi.properties.ClientProperty#HEARTBEAT_TIMEOUT} milliseconds from the member.
    29|      */
    30|     void heartbeatStopped(Connection connection);
    31| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/NonSmartClientInvocationService.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl;
    17| import com.hazelcast.client.connection.nio.ClientConnection;
    18| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    19| import com.hazelcast.nio.Address;
    20| import java.io.IOException;
    21| public class NonSmartClientInvocationService extends AbstractClientInvocationService {
    22|     public NonSmartClientInvocationService(HazelcastClientInstanceImpl client) {
    23|         super(client);
    24|     }
    25|     @Override
    26|     public void invokeOnRandomTarget(ClientInvocation invocation) throws IOException {
    27|         send(invocation, getOwnerConnection());
    28|     }
    29|     @Override
    30|     public void invokeOnConnection(ClientInvocation invocation, ClientConnection connection) throws IOException {
    31|         assert connection != null;
    32|         send(invocation, connection);
    33|     }
    34|     @Override
    35|     public void invokeOnPartitionOwner(ClientInvocation invocation, int partitionId) throws IOException {
    36|         invocation.getClientMessage().setPartitionId(partitionId);
    37|         send(invocation, getOwnerConnection());
    38|     }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/SmartClientInvocationService.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl;
    17| import com.hazelcast.client.LoadBalancer;
    18| import com.hazelcast.client.connection.nio.ClientConnection;
    19| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    20| import com.hazelcast.core.Member;
    21| import com.hazelcast.nio.Address;
    22| import com.hazelcast.nio.Connection;
    23| import com.hazelcast.spi.exception.TargetNotMemberException;
    24| import java.io.IOException;
    25| public class SmartClientInvocationService extends AbstractClientInvocationService {
    26|     private final LoadBalancer loadBalancer;
    27|     public SmartClientInvocationService(HazelcastClientInstanceImpl client, LoadBalancer loadBalancer) {
    28|         super(client);
    29|         this.loadBalancer = loadBalancer;
    30|     }
    31|     @Override
    32|     public void invokeOnPartitionOwner(ClientInvocation invocation, int partitionId) throws IOException {
    33|         final Address owner = partitionService.getPartitionOwner(partitionId);
    34|         if (owner == null) {
    35|             throw new IOException("Partition does not have an owner. partitionId: " + partitionId);
    36|         }
    37|         if (!isMember(owner)) {
    38|             throw new TargetNotMemberException("Partition owner '" + owner + "' is not a member.");
    39|         }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/discovery/HazelcastCloudDiscovery.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl.discovery;
    17| import com.hazelcast.com.eclipsesource.json.Json;
    18| import com.hazelcast.com.eclipsesource.json.JsonValue;
    19| import com.hazelcast.client.util.AddressHelper;
    20| import com.hazelcast.nio.Address;
    21| import com.hazelcast.spi.properties.HazelcastProperties;
    22| import com.hazelcast.spi.properties.HazelcastProperty;
    23| import com.hazelcast.util.AddressUtil;
    24| import javax.net.ssl.HttpsURLConnection;
    25| import java.io.BufferedReader;
    26| import java.io.IOException;
    27| import java.io.InputStream;
    28| import java.io.InputStreamReader;
    29| import java.net.HttpURLConnection;
    30| import java.net.URL;
    31| import java.security.cert.Certificate;
    32| import java.security.cert.CertificateException;
    33| import java.security.cert.X509Certificate;
    34| import java.util.HashMap;
    35| import java.util.List;
    36| import java.util.Map;
    37| import java.util.Scanner;
    38| import static com.hazelcast.util.ExceptionUtil.rethrow;
    39| /**


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/listener/AbstractClientListenerService.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-121 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl.listener;
    17| import com.hazelcast.client.connection.nio.ClientConnection;
    18| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    19| import com.hazelcast.client.impl.protocol.ClientMessage;
    20| import com.hazelcast.client.spi.ClientListenerService;
    21| import com.hazelcast.client.spi.EventHandler;
    22| import com.hazelcast.client.spi.impl.ClientExecutionServiceImpl;
    23| import com.hazelcast.internal.metrics.MetricsProvider;
    24| import com.hazelcast.internal.metrics.MetricsRegistry;
    25| import com.hazelcast.internal.metrics.Probe;
    26| import com.hazelcast.logging.ILogger;
    27| import com.hazelcast.nio.Connection;
    28| import com.hazelcast.spi.serialization.SerializationService;
    29| import com.hazelcast.util.executor.SingleExecutorThreadFactory;
    30| import com.hazelcast.util.executor.StripedExecutor;
    31| import com.hazelcast.util.executor.StripedRunnable;
    32| import java.util.Collection;
    33| import java.util.concurrent.ConcurrentHashMap;
    34| import java.util.concurrent.ConcurrentMap;
    35| import java.util.concurrent.Executors;
    36| import java.util.concurrent.RejectedExecutionException;
    37| import java.util.concurrent.ScheduledExecutorService;
    38| import java.util.concurrent.ThreadFactory;
    39| import static com.hazelcast.internal.metrics.ProbeLevel.MANDATORY;
    40| public abstract class AbstractClientListenerService implements ClientListenerService, MetricsProvider {
    41|     protected final HazelcastClientInstanceImpl client;
    42|     protected final SerializationService serializationService;
    43|     protected final ScheduledExecutorService registrationExecutor;
    44|     protected final ILogger logger;
    45|     @Probe(name = "eventHandlerCount", level = MANDATORY)
    46|     private final ConcurrentMap<Long, EventHandler> eventHandlerMap
    47|             = new ConcurrentHashMap<Long, EventHandler>();
    48|     private final StripedExecutor eventExecutor;
    49|     public AbstractClientListenerService(HazelcastClientInstanceImpl client, int eventThreadCount, int eventQueueCapacity) {
    50|         this.client = client;
    51|         serializationService = client.getSerializationService();
    52|         logger = client.getLoggingService().getLogger(ClientListenerService.class);
    53|         String name = client.getName();
    54|         eventExecutor = new StripedExecutor(logger, name + ".event", eventThreadCount, eventQueueCapacity);
    55|         ClassLoader classLoader = client.getClientConfig().getClassLoader();
    56|         ThreadFactory threadFactory = new SingleExecutorThreadFactory(classLoader, name + ".eventRegistration-");
    57|         registrationExecutor = Executors.newSingleThreadScheduledExecutor(threadFactory);
    58|     }
    59|     @Override
    60|     public void provideMetrics(MetricsRegistry registry) {
    61|         registry.scanAndRegister(this, "listeners");
    62|     }
    63|     @Probe(level = MANDATORY)
    64|     private int eventQueueSize() {
    65|         return eventExecutor.getWorkQueueSize();
    66|     }
    67|     @Probe(level = MANDATORY)
    68|     private long eventsProcessed() {
    69|         return eventExecutor.processedCount();
    70|     }
    71|     public void addEventHandler(long callId, EventHandler handler) {
    72|         eventHandlerMap.put(callId, handler);
    73|     }
    74|     protected void removeEventHandler(long callId) {
    75|         eventHandlerMap.remove(callId);
    76|     }
    77|     public void handleClientMessage(ClientMessage clientMessage, Connection connection) {
    78|         try {
    79|             eventExecutor.execute(new ClientEventProcessor(clientMessage, (ClientConnection) connection));
    80|         } catch (RejectedExecutionException e) {
    81|             logger.warning("Event clientMessage could not be handled", e);
    82|         }
    83|     }
    84|     public void shutdown() {
    85|         eventExecutor.shutdown();
    86|         ClientExecutionServiceImpl.shutdownExecutor("registrationExecutor", registrationExecutor, logger);
    87|     }
    88|     public void start() {
    89|     }
    90|     private final class ClientEventProcessor implements StripedRunnable {
    91|         final ClientMessage clientMessage;
    92|         final ClientConnection connection;
    93|         private ClientEventProcessor(ClientMessage clientMessage, ClientConnection connection) {
    94|             this.clientMessage = clientMessage;
    95|             this.connection = connection;
    96|         }
    97|         @Override
    98|         public void run() {
    99|             try {
   100|                 long correlationId = clientMessage.getCorrelationId();
   101|                 final EventHandler eventHandler = eventHandlerMap.get(correlationId);
   102|                 if (eventHandler == null) {
   103|                     logger.warning("No eventHandler for callId: " + correlationId + ", event: " + clientMessage
   104|                             + ", connection: " + connection);
   105|                     return;
   106|                 }
   107|                 eventHandler.handle(clientMessage);
   108|             } finally {
   109|                 connection.decrementPendingPacketCount();
   110|             }
   111|         }
   112|         @Override
   113|         public int getKey() {
   114|             return clientMessage.getPartitionId();
   115|         }
   116|     }
   117|     public StripedExecutor getEventExecutor() {
   118|         return eventExecutor;
   119|     }
   120|     public abstract Collection<ClientEventRegistration> getActiveRegistrations(String uuid);
   121| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/listener/NonSmartClientListenerService.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-175 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl.listener;
    17| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.spi.EventHandler;
    20| import com.hazelcast.client.spi.impl.ClientInvocation;
    21| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    22| import com.hazelcast.client.spi.impl.ListenerMessageCodec;
    23| import com.hazelcast.core.HazelcastException;
    24| import com.hazelcast.nio.Connection;
    25| import com.hazelcast.nio.ConnectionListener;
    26| import com.hazelcast.util.EmptyStatement;
    27| import com.hazelcast.util.ExceptionUtil;
    28| import com.hazelcast.util.UuidUtil;
    29| import java.util.Collection;
    30| import java.util.Collections;
    31| import java.util.HashSet;
    32| import java.util.LinkedList;
    33| import java.util.Map;
    34| import java.util.Set;
    35| import java.util.concurrent.Callable;
    36| import java.util.concurrent.ConcurrentHashMap;
    37| import java.util.concurrent.Future;
    38| import java.util.concurrent.RejectedExecutionException;
    39| public class NonSmartClientListenerService extends AbstractClientListenerService implements ConnectionListener {
    40|     private final Map<ClientRegistrationKey, ClientEventRegistration> activeRegistrations
    41|             = new ConcurrentHashMap<ClientRegistrationKey, ClientEventRegistration>();
    42|     private final Set<ClientRegistrationKey> userRegistrations = new HashSet<ClientRegistrationKey>();
    43|     public NonSmartClientListenerService(HazelcastClientInstanceImpl client,
    44|                                          int eventThreadCount, int eventQueueCapacity) {
    45|         super(client, eventThreadCount, eventQueueCapacity);
    46|     }
    47|     @Override
    48|     public String registerListener(final ListenerMessageCodec codec, final EventHandler handler) {
    49|         assert (!Thread.currentThread().getName().contains("eventRegistration"));
    50|         Future<String> future = registrationExecutor.submit(new Callable<String>() {
    51|             @Override
    52|             public String call() throws Exception {
    53|                 String userRegistrationId = UuidUtil.newUnsecureUuidString();
    54|                 ClientRegistrationKey registrationKey = new ClientRegistrationKey(userRegistrationId, handler, codec);
    55|                 try {
    56|                     ClientEventRegistration registration = invoke(registrationKey);
    57|                     activeRegistrations.put(registrationKey, registration);
    58|                     userRegistrations.add(registrationKey);
    59|                 } catch (Exception e) {
    60|                     throw new HazelcastException("Listener can not be added", e);
    61|                 }
    62|                 return userRegistrationId;
    63|             }
    64|         });
    65|         try {
    66|             return future.get();
    67|         } catch (Exception e) {
    68|             throw ExceptionUtil.rethrow(e);
    69|         }
    70|     }
    71|     private ClientEventRegistration invoke(ClientRegistrationKey registrationKey) throws Exception {
    72|         assert (Thread.currentThread().getName().contains("eventRegistration"));
    73|         EventHandler handler = registrationKey.getHandler();
    74|         handler.beforeListenerRegister();
    75|         ClientMessage request = registrationKey.getCodec().encodeAddRequest(false);
    76|         ClientInvocation invocation = new ClientInvocation(client, request, null);
    77|         invocation.setEventHandler(handler);
    78|         ClientInvocationFuture future = invocation.invoke();
    79|         String registrationId = registrationKey.getCodec().decodeAddResponse(future.get());
    80|         handler.onListenerRegister();
    81|         Connection connection = future.getInvocation().getSendConnection();
    82|         return new ClientEventRegistration(registrationId,
    83|                 request.getCorrelationId(), connection, registrationKey.getCodec());
    84|     }
    85|     @Override
    86|     public boolean deregisterListener(final String userRegistrationId) {
    87|         assert (!Thread.currentThread().getName().contains("eventRegistration"));
    88|         try {
    89|             Future<Boolean> future = registrationExecutor.submit(new Callable<Boolean>() {
    90|                 @Override
    91|                 public Boolean call() throws Exception {
    92|                     return deregisterListenerInternal(userRegistrationId);
    93|                 }
    94|             });
    95|             try {
    96|                 return future.get();
    97|             } catch (Exception e) {
    98|                 throw ExceptionUtil.rethrow(e);
    99|             }
   100|         } catch (RejectedExecutionException ignored) {
   101|             EmptyStatement.ignore(ignored);
   102|             return true;
   103|         }
   104|     }
   105|     private Boolean deregisterListenerInternal(String userRegistrationId) {
   106|         ClientRegistrationKey key = new ClientRegistrationKey(userRegistrationId);
   107|         if (!userRegistrations.remove(key)) {
   108|             return false;
   109|         }
   110|         ClientEventRegistration registration = activeRegistrations.get(key);
   111|         if (registration == null) {
   112|             return true;
   113|         }
   114|         ClientMessage request = registration.getCodec().encodeRemoveRequest(registration.getServerRegistrationId());
   115|         try {
   116|             Future future = new ClientInvocation(client, request, null).invoke();
   117|             future.get();
   118|             removeEventHandler(registration.getCallId());
   119|             activeRegistrations.remove(key);
   120|         } catch (Exception e) {
   121|             throw new HazelcastException("Listener with ID " + userRegistrationId + " could not be removed", e);
   122|         }
   123|         return true;
   124|     }
   125|     @Override
   126|     public void start() {
   127|         client.getConnectionManager().addConnectionListener(this);
   128|     }
   129|     @Override
   130|     public void connectionAdded(final Connection connection) {
   131|         assert (!Thread.currentThread().getName().contains("eventRegistration"));
   132|         registrationExecutor.submit(new Runnable() {
   133|             @Override
   134|             public void run() {
   135|                 for (ClientRegistrationKey registrationKey : userRegistrations) {
   136|                     try {
   137|                         ClientEventRegistration oldRegistration = activeRegistrations.get(registrationKey);
   138|                         if (oldRegistration != null) {
   139|                             removeEventHandler(oldRegistration.getCallId());
   140|                         }
   141|                         ClientEventRegistration eventRegistration = invoke(registrationKey);
   142|                         activeRegistrations.put(registrationKey, eventRegistration);
   143|                     } catch (Exception e) {
   144|                         logger.warning("Listener " + registrationKey + " can not be added to new connection: "
   145|                                 + connection, e);
   146|                     }
   147|                 }
   148|             }
   149|         });
   150|     }
   151|     @Override
   152|     public void connectionRemoved(Connection connection) {
   153|     }
   154|     public Collection<ClientEventRegistration> getActiveRegistrations(final String uuid) {
   155|         assert (!Thread.currentThread().getName().contains("eventRegistration"));
   156|         Future<Collection<ClientEventRegistration>> future = registrationExecutor.submit(
   157|                 new Callable<Collection<ClientEventRegistration>>() {
   158|                     @Override
   159|                     public Collection<ClientEventRegistration> call() throws Exception {
   160|                         ClientEventRegistration registration = activeRegistrations.get(new ClientRegistrationKey(uuid));
   161|                         if (registration == null || !registration.getSubscriber().isAlive()) {
   162|                             return Collections.EMPTY_LIST;
   163|                         }
   164|                         LinkedList<ClientEventRegistration> activeRegistrations = new LinkedList<ClientEventRegistration>();
   165|                         activeRegistrations.add(registration);
   166|                         return activeRegistrations;
   167|                     }
   168|                 });
   169|         try {
   170|             return future.get();
   171|         } catch (Exception e) {
   172|             throw ExceptionUtil.rethrow(e);
   173|         }
   174|     }
   175| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/listener/SmartClientListenerService.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-326 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl.listener;
    17| import com.hazelcast.client.connection.ClientConnectionManager;
    18| import com.hazelcast.client.connection.nio.ClientConnection;
    19| import com.hazelcast.client.impl.HazelcastClientInstanceImpl;
    20| import com.hazelcast.client.impl.protocol.ClientMessage;
    21| import com.hazelcast.client.spi.ClientClusterService;
    22| import com.hazelcast.client.spi.EventHandler;
    23| import com.hazelcast.client.spi.impl.ClientInvocation;
    24| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    25| import com.hazelcast.client.spi.impl.AbstractClientInvocationService;
    26| import com.hazelcast.client.spi.impl.ConnectionHeartbeatListener;
    27| import com.hazelcast.client.spi.impl.ListenerMessageCodec;
    28| import com.hazelcast.core.HazelcastException;
    29| import com.hazelcast.core.Member;
    30| import com.hazelcast.core.OperationTimeoutException;
    31| import com.hazelcast.nio.Connection;
    32| import com.hazelcast.nio.ConnectionListener;
    33| import com.hazelcast.util.EmptyStatement;
    34| import com.hazelcast.util.ExceptionUtil;
    35| import com.hazelcast.util.UuidUtil;
    36| import java.io.IOException;
    37| import java.util.Collection;
    38| import java.util.Collections;
    39| import java.util.HashMap;
    40| import java.util.Iterator;
    41| import java.util.LinkedList;
    42| import java.util.Map;
    43| import java.util.concurrent.Callable;
    44| import java.util.concurrent.ConcurrentHashMap;
    45| import java.util.concurrent.Future;
    46| import java.util.concurrent.RejectedExecutionException;
    47| import java.util.concurrent.TimeUnit;
    48| import static com.hazelcast.util.StringUtil.timeToString;
    49| public class SmartClientListenerService extends AbstractClientListenerService
    50|         implements ConnectionListener, ConnectionHeartbeatListener {
    51|     private final long invocationTimeoutMillis;
    52|     private final long invocationRetryPauseMillis;
    53|     private final Map<ClientRegistrationKey, Map<Connection, ClientEventRegistration>> registrations
    54|             = new ConcurrentHashMap<ClientRegistrationKey, Map<Connection, ClientEventRegistration>>();
    55|     private final ClientConnectionManager clientConnectionManager;
    56|     private final Map<Connection, Collection<ClientRegistrationKey>> failedRegistrations
    57|             = new ConcurrentHashMap<Connection, Collection<ClientRegistrationKey>>();
    58|     public SmartClientListenerService(HazelcastClientInstanceImpl client,
    59|                                       int eventThreadCount, int eventQueueCapacity) {
    60|         super(client, eventThreadCount, eventQueueCapacity);
    61|         clientConnectionManager = client.getConnectionManager();
    62|         AbstractClientInvocationService invocationService = (AbstractClientInvocationService) client.getInvocationService();
    63|         invocationTimeoutMillis = invocationService.getInvocationTimeoutMillis();
    64|         invocationRetryPauseMillis = invocationService.getInvocationRetryPauseMillis();
    65|     }
    66|     @Override
    67|     public String registerListener(final ListenerMessageCodec codec, final EventHandler handler) {
    68|         assert (!Thread.currentThread().getName().contains("eventRegistration"));
    69|         trySyncConnectToAllMembers();
    70|         Future<String> future = registrationExecutor.submit(new Callable<String>() {
    71|             @Override
    72|             public String call() {
    73|                 String userRegistrationId = UuidUtil.newUnsecureUuidString();
    74|                 ClientRegistrationKey registrationKey = new ClientRegistrationKey(userRegistrationId, handler, codec);
    75|                 registrations.put(registrationKey, new ConcurrentHashMap<Connection, ClientEventRegistration>());
    76|                 Collection<ClientConnection> connections = clientConnectionManager.getActiveConnections();
    77|                 for (ClientConnection connection : connections) {
    78|                     try {
    79|                         invoke(registrationKey, connection);
    80|                     } catch (Exception e) {
    81|                         if (connection.isAlive()) {
    82|                             deregisterListenerInternal(userRegistrationId);
    83|                             throw new HazelcastException("Listener can not be added ", e);
    84|                         }
    85|                     }
    86|                 }
    87|                 return userRegistrationId;
    88|             }
    89|         });
    90|         try {
    91|             return future.get();
    92|         } catch (Exception e) {
    93|             throw ExceptionUtil.rethrow(e);
    94|         }
    95|     }
    96|     private void invoke(ClientRegistrationKey registrationKey, Connection connection) throws Exception {
    97|         assert (Thread.currentThread().getName().contains("eventRegistration"));
    98|         Map<Connection, ClientEventRegistration> registrationMap = registrations.get(registrationKey);
    99|         if (registrationMap.containsKey(connection)) {
   100|             return;
   101|         }
   102|         ListenerMessageCodec codec = registrationKey.getCodec();
   103|         ClientMessage request = codec.encodeAddRequest(true);
   104|         EventHandler handler = registrationKey.getHandler();
   105|         handler.beforeListenerRegister();
   106|         ClientInvocation invocation = new ClientInvocation(client, request, null, connection);
   107|         invocation.setEventHandler(handler);
   108|         ClientInvocationFuture future = invocation.invokeUrgent();
   109|         ClientMessage clientMessage;
   110|         try {
   111|             clientMessage = future.get();
   112|         } catch (Exception e) {
   113|             throw ExceptionUtil.rethrow(e, Exception.class);
   114|         }
   115|         String serverRegistrationId = codec.decodeAddResponse(clientMessage);
   116|         handler.onListenerRegister();
   117|         long correlationId = request.getCorrelationId();
   118|         ClientEventRegistration registration
   119|                 = new ClientEventRegistration(serverRegistrationId, correlationId, connection, codec);
   120|         registrationMap.put(connection, registration);
   121|     }
   122|     @Override
   123|     public boolean deregisterListener(final String userRegistrationId) {
   124|         assert (!Thread.currentThread().getName().contains("eventRegistration"));
   125|         try {
   126|             Future<Boolean> future = registrationExecutor.submit(new Callable<Boolean>() {
   127|                 @Override
   128|                 public Boolean call() {
   129|                     return deregisterListenerInternal(userRegistrationId);
   130|                 }
   131|             });
   132|             try {
   133|                 return future.get();
   134|             } catch (Exception e) {
   135|                 throw ExceptionUtil.rethrow(e);
   136|             }
   137|         } catch (RejectedExecutionException ignored) {
   138|             EmptyStatement.ignore(ignored);
   139|             return true;
   140|         }
   141|     }
   142|     private Boolean deregisterListenerInternal(String userRegistrationId) {
   143|         assert (Thread.currentThread().getName().contains("eventRegistration"));
   144|         ClientRegistrationKey key = new ClientRegistrationKey(userRegistrationId);
   145|         Map<Connection, ClientEventRegistration> registrationMap = registrations.get(key);
   146|         if (registrationMap == null) {
   147|             return false;
   148|         }
   149|         boolean successful = true;
   150|         for (Iterator<ClientEventRegistration> iterator = registrationMap.values().iterator(); iterator.hasNext(); ) {
   151|             ClientEventRegistration registration = iterator.next();
   152|             Connection subscriber = registration.getSubscriber();
   153|             try {
   154|                 ListenerMessageCodec listenerMessageCodec = registration.getCodec();
   155|                 String serverRegistrationId = registration.getServerRegistrationId();
   156|                 ClientMessage request = listenerMessageCodec.encodeRemoveRequest(serverRegistrationId);
   157|                 new ClientInvocation(client, request, null, subscriber).invoke().get();
   158|                 removeEventHandler(registration.getCallId());
   159|                 iterator.remove();
   160|             } catch (Exception e) {
   161|                 if (subscriber.isAlive()) {
   162|                     successful = false;
   163|                     logger.warning("Deregistration of listener with ID " + userRegistrationId
   164|                             + " has failed to address " + subscriber.getEndPoint(), e);
   165|                 }
   166|             }
   167|         }
   168|         if (successful) {
   169|             registrations.remove(key);
   170|         }
   171|         return successful;
   172|     }
   173|     @Override
   174|     public void start() {
   175|         clientConnectionManager.addConnectionListener(this);
   176|         clientConnectionManager.addConnectionHeartbeatListener(this);
   177|         final ClientClusterService clientClusterService = client.getClientClusterService();
   178|         registrationExecutor.scheduleWithFixedDelay(new Runnable() {
   179|             @Override
   180|             public void run() {
   181|                 Collection<Member> memberList = clientClusterService.getMemberList();
   182|                 for (Member member : memberList) {
   183|                     try {
   184|                         clientConnectionManager.getOrTriggerConnect(member.getAddress(), false);
   185|                     } catch (IOException e) {
   186|                         return;
   187|                     }
   188|                 }
   189|             }
   190|         }, 1, 1, TimeUnit.SECONDS);
   191|     }
   192|     private void trySyncConnectToAllMembers() {
   193|         ClientClusterService clientClusterService = client.getClientClusterService();
   194|         long startMillis = System.currentTimeMillis();
   195|         do {
   196|             Member lastFailedMember = null;
   197|             Exception lastException = null;
   198|             for (Member member : clientClusterService.getMemberList()) {
   199|                 try {
   200|                     clientConnectionManager.getOrConnect(member.getAddress());
   201|                 } catch (Exception e) {
   202|                     lastFailedMember = member;
   203|                     lastException = e;
   204|                 }
   205|             }
   206|             if (lastException == null) {
   207|                 break;
   208|             }
   209|             timeOutOrSleepBeforeNextTry(startMillis, lastFailedMember, lastException);
   210|         } while (client.getLifecycleService().isRunning());
   211|     }
   212|     private void sleepBeforeNextTry() {
   213|         try {
   214|             Thread.sleep(invocationRetryPauseMillis);
   215|         } catch (InterruptedException e) {
   216|             Thread.currentThread().interrupt();
   217|             throw ExceptionUtil.rethrow(e);
   218|         }
   219|     }
   220|     private void timeOutOrSleepBeforeNextTry(long startMillis, Member lastFailedMember, Exception lastException) {
   221|         long nowInMillis = System.currentTimeMillis();
   222|         long elapsedMillis = nowInMillis - startMillis;
   223|         boolean timedOut = elapsedMillis > invocationTimeoutMillis;
   224|         if (timedOut) {
   225|             throwOperationTimeoutException(startMillis, nowInMillis, elapsedMillis, lastFailedMember, lastException);
   226|         } else {
   227|             sleepBeforeNextTry();
   228|         }
   229|     }
   230|     private void throwOperationTimeoutException(long startMillis, long nowInMillis,
   231|                                                 long elapsedMillis, Member lastFailedMember, Exception lastException) {
   232|         throw new OperationTimeoutException("Registering listeners is timed out."
   233|                 + " Last failed member : " + lastFailedMember + ", "
   234|                 + " Current time: " + timeToString(nowInMillis) + ", "
   235|                 + " Start time : " + timeToString(startMillis) + ", "
   236|                 + " Client invocation timeout : " + invocationTimeoutMillis + " ms, "
   237|                 + " Elapsed time : " + elapsedMillis + " ms. ", lastException);
   238|     }
   239|     @Override
   240|     public void connectionAdded(final Connection connection) {
   241|         assert (!Thread.currentThread().getName().contains("eventRegistration"));
   242|         registrationExecutor.submit(new Runnable() {
   243|             @Override
   244|             public void run() {
   245|                 for (ClientRegistrationKey registrationKey : registrations.keySet()) {
   246|                     invokeFromInternalThread(registrationKey, connection);
   247|                 }
   248|             }
   249|         });
   250|     }
   251|     @Override
   252|     public void connectionRemoved(final Connection connection) {
   253|         assert (!Thread.currentThread().getName().contains("eventRegistration"));
   254|         registrationExecutor.submit(new Runnable() {
   255|             @Override
   256|             public void run() {
   257|                 failedRegistrations.remove(connection);
   258|                 for (Map<Connection, ClientEventRegistration> registrationMap : registrations.values()) {
   259|                     ClientEventRegistration registration = registrationMap.remove(connection);
   260|                     if (registration != null) {
   261|                         removeEventHandler(registration.getCallId());
   262|                     }
   263|                 }
   264|             }
   265|         });
   266|     }
   267|     @Override
   268|     public void heartbeatResumed(final Connection connection) {
   269|         assert (!Thread.currentThread().getName().contains("eventRegistration"));
   270|         registrationExecutor.submit(new Runnable() {
   271|             @Override
   272|             public void run() {
   273|                 Collection<ClientRegistrationKey> registrationKeys = failedRegistrations.get(connection);
   274|                 for (ClientRegistrationKey registrationKey : registrationKeys) {
   275|                     invokeFromInternalThread(registrationKey, connection);
   276|                 }
   277|             }
   278|         });
   279|     }
   280|     private void invokeFromInternalThread(ClientRegistrationKey registrationKey, Connection connection) {
   281|         assert (Thread.currentThread().getName().contains("eventRegistration"));
   282|         try {
   283|             invoke(registrationKey, connection);
   284|         } catch (IOException e) {
   285|             Collection<ClientRegistrationKey> failedRegsToConnection = failedRegistrations.get(connection);
   286|             if (failedRegsToConnection == null) {
   287|                 failedRegsToConnection = Collections.newSetFromMap(new HashMap<ClientRegistrationKey, Boolean>());
   288|                 failedRegistrations.put(connection, failedRegsToConnection);
   289|             }
   290|             failedRegsToConnection.add(registrationKey);
   291|         } catch (Exception e) {
   292|             logger.warning("Listener " + registrationKey + " can not be added to a new connection: "
   293|                     + connection + ", reason: " + e.getMessage());
   294|         }
   295|     }
   296|     @Override
   297|     public void heartbeatStopped(Connection connection) {
   298|     }
   299|     public Collection<ClientEventRegistration> getActiveRegistrations(final String uuid) {
   300|         assert (!Thread.currentThread().getName().contains("eventRegistration"));
   301|         Future<Collection<ClientEventRegistration>> future = registrationExecutor.submit(
   302|                 new Callable<Collection<ClientEventRegistration>>() {
   303|                     @Override
   304|                     public Collection<ClientEventRegistration> call() {
   305|                         ClientRegistrationKey key = new ClientRegistrationKey(uuid);
   306|                         Map<Connection, ClientEventRegistration> registrationMap = registrations.get(key);
   307|                         if (registrationMap == null) {
   308|                             return Collections.EMPTY_LIST;
   309|                         }
   310|                         LinkedList<ClientEventRegistration> activeRegistrations = new LinkedList<ClientEventRegistration>();
   311|                         for (ClientEventRegistration registration : registrationMap.values()) {
   312|                             activeRegistrations.add(registration);
   313|                         }
   314|                         return activeRegistrations;
   315|                     }
   316|                 });
   317|         try {
   318|             return future.get();
   319|         } catch (Exception e) {
   320|             throw ExceptionUtil.rethrow(e);
   321|         }
   322|     }
   323|     public Map<ClientRegistrationKey, Map<Connection, ClientEventRegistration>> getRegistrations() {
   324|         return registrations;
   325|     }
   326| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/util/AbstractLoadBalancer.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 11-60 ---
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.util;
    17| import com.hazelcast.client.LoadBalancer;
    18| import com.hazelcast.client.config.ClientConfig;
    19| import com.hazelcast.core.Cluster;
    20| import com.hazelcast.core.InitialMembershipEvent;
    21| import com.hazelcast.core.InitialMembershipListener;
    22| import com.hazelcast.core.Member;
    23| import com.hazelcast.core.MemberAttributeEvent;
    24| import com.hazelcast.core.MembershipEvent;
    25| import java.util.Set;
    26| import java.util.concurrent.atomic.AtomicReference;
    27| /**
    28|  * An abstract {@link com.hazelcast.client.LoadBalancer} implementation.
    29|  */
    30| public abstract class AbstractLoadBalancer implements LoadBalancer, InitialMembershipListener {
    31|     private final AtomicReference<Member[]> membersRef = new AtomicReference(new Member[]{});
    32|     private volatile Cluster clusterRef;
    33|     @Override
    34|     public final void init(Cluster cluster, ClientConfig config) {
    35|         this.clusterRef = cluster;
    36|         cluster.addMembershipListener(this);
    37|     }
    38|     private void setMembersRef() {
    39|         Set<Member> memberSet = clusterRef.getMembers();
    40|         Member[] members = memberSet.toArray(new Member[memberSet.size()]);
    41|         membersRef.set(members);
    42|     }
    43|     protected Member[] getMembers() {
    44|         return membersRef.get();
    45|     }
    46|     @Override
    47|     public final void init(InitialMembershipEvent event) {
    48|         setMembersRef();
    49|     }
    50|     @Override
    51|     public final void memberAdded(MembershipEvent membershipEvent) {
    52|         setMembersRef();
    53|     }
    54|     @Override
    55|     public final void memberRemoved(MembershipEvent membershipEvent) {
    56|         setMembersRef();
    57|     }
    58|     @Override
    59|     public final void memberAttributeChanged(MemberAttributeEvent memberAttributeEvent) {
    60|     }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/util/ClientDelegatingFuture.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.util;
    17| import com.hazelcast.client.impl.ClientMessageDecoder;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    20| import com.hazelcast.core.ExecutionCallback;
    21| import com.hazelcast.spi.InternalCompletableFuture;
    22| import com.hazelcast.spi.serialization.SerializationService;
    23| import com.hazelcast.util.ExceptionUtil;
    24| import java.util.concurrent.ExecutionException;
    25| import java.util.concurrent.Executor;
    26| import java.util.concurrent.TimeUnit;
    27| import java.util.concurrent.TimeoutException;
    28| import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
    29| /**
    30|  * The Client Delegating Future is used to delegate {@link
    31|  * ClientInvocationFuture} to a user type to be used with {@code andThen()} or
    32|  * {@code get()}. It converts {@link ClientMessage} coming from {@link
    33|  * ClientInvocationFuture} to a user object.
    34|  *
    35|  * @param <V> Value type that the user expects
    36|  */
    37| public class ClientDelegatingFuture<V> implements InternalCompletableFuture<V> {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/util/ClientStateListener.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 40-80 ---
    40|         implements LifecycleListener {
    41|     private LifecycleEvent.LifecycleState currentState = STARTING;
    42|     private final Lock lock = new ReentrantLock();
    43|     private final Condition connectedCondition = lock.newCondition();
    44|     private final Condition disconnectedCondition = lock.newCondition();
    45|     /**
    46|      * Registers this instance with the provided client configuration
    47|      *
    48|      * @param clientConfig The client configuration to which this listener will be registered
    49|      */
    50|     public ClientStateListener(ClientConfig clientConfig) {
    51|         clientConfig.addListenerConfig(new ListenerConfig(this));
    52|     }
    53|     @Override
    54|     public void stateChanged(LifecycleEvent event) {
    55|         lock.lock();
    56|         try {
    57|             currentState = event.getState();
    58|             if (currentState.equals(CLIENT_CONNECTED) || currentState.equals(SHUTTING_DOWN) || currentState.equals(SHUTDOWN)) {
    59|                 connectedCondition.signalAll();
    60|             } else if (currentState.equals(CLIENT_DISCONNECTED) || currentState.equals(SHUTTING_DOWN) || currentState
    61|                     .equals(SHUTDOWN)) {
    62|                 disconnectedCondition.signalAll();
    63|             }
    64|         } finally {
    65|             lock.unlock();
    66|         }
    67|     }
    68|     /**
    69|      * Waits until the client is connected to cluster or the timeout expires.
    70|      * Does not wait if the client is already shutting down or shutdown.
    71|      *
    72|      * @param timeout the maximum time to wait
    73|      * @param unit    the time unit of the {@code timeout} argument
    74|      * @return true if the client is connected to the cluster. On returning false,
    75|      * you can check if timeout occured or the client is shutdown using {@code isShutdown} {@code getCurrentState}
    76|      * @throws InterruptedException
    77|      */
    78|     public boolean awaitConnected(long timeout, TimeUnit unit)
    79|             throws InterruptedException {
    80|         lock.lock();

