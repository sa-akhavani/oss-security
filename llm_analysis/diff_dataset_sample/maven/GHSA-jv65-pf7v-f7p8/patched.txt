# ====================================================================
# FILE: hazelcast-build-utils/src/main/java/com/hazelcast/buildutils/HazelcastManifestTransformer.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 10-72 ---
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.buildutils;
    17| import aQute.lib.osgi.Instruction;
    18| import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
    19| import org.apache.maven.plugins.shade.relocation.Relocator;
    20| import org.apache.maven.plugins.shade.resource.ManifestResourceTransformer;
    21| import java.io.IOException;
    22| import java.io.InputStream;
    23| import java.util.ArrayList;
    24| import java.util.HashMap;
    25| import java.util.LinkedHashSet;
    26| import java.util.List;
    27| import java.util.Map;
    28| import java.util.Set;
    29| import java.util.jar.Attributes;
    30| import java.util.jar.Attributes.Name;
    31| import java.util.jar.JarEntry;
    32| import java.util.jar.JarFile;
    33| import java.util.jar.JarOutputStream;
    34| import java.util.jar.Manifest;
    35| import static java.util.Arrays.asList;
    36| import static java.util.Collections.emptySet;
    37| import static org.codehaus.plexus.util.IOUtil.close;
    38| import static org.codehaus.plexus.util.StringUtils.join;
    39| /**
    40|  * This transformer implementation is used to merge MANIFEST and OSGi
    41|  * bundle metadata in conjunction with the Maven Shade plugin when
    42|  * integrating multiple dependencies into one output JAR.
    43|  */
    44| public class HazelcastManifestTransformer extends ManifestResourceTransformer {
    45|     private static final String VERSION_PREFIX = "version=";
    46|     private static final String RESOLUTION_PREFIX = "resolution:=";
    47|     private static final String USES_PREFIX = "uses:=";
    48|     private static final int VERSION_OFFSET = 8;
    49|     private static final int USES_OFFSET = 7;
    50|     private static final String IMPORT_PACKAGE = "Import-Package";
    51|     private static final String EXPORT_PACKAGE = "Export-Package";
    52|     private static final Name AUTOMATIC_MODULE_NAME = new Name("Automatic-Module-Name");
    53|     @SuppressFBWarnings(value = "UWF_UNWRITTEN_FIELD", justification = "Filled by Maven")
    54|     String mainClass;
    55|     @SuppressFBWarnings(value = "UWF_UNWRITTEN_FIELD", justification = "Filled by Maven")
    56|     Map<String, Attributes> manifestEntries;
    57|     @SuppressFBWarnings(value = "UWF_UNWRITTEN_FIELD", justification = "Filled by Maven")
    58|     Map<String, String> overrideInstructions;
    59|     private final Map<String, PackageDefinition> importedPackages = new HashMap<String, PackageDefinition>();
    60|     private final Map<String, PackageDefinition> exportedPackages = new HashMap<String, PackageDefinition>();
    61|     private final List<InstructionDefinition> importOverrideInstructions = new ArrayList<InstructionDefinition>();
    62|     private final List<InstructionDefinition> exportOverrideInstructions = new ArrayList<InstructionDefinition>();
    63|     private Manifest shadedManifest;
    64|     @Override
    65|     public boolean canTransformResource(String resource) {
    66|         return JarFile.MANIFEST_NAME.equalsIgnoreCase(resource);
    67|     }
    68|     @Override
    69|     public void processResource(String resource, InputStream inputStream, List<Relocator> relocators) throws IOException {
    70|         Attributes attributes;
    71|         if (shadedManifest == null) {
    72|             shadedManifest = new Manifest(inputStream);

# --- HUNK 2: Lines 135-175 ---
   135|     }
   136|     @Override
   137|     @SuppressWarnings("Since15")
   138|     public void modifyOutputStream(JarOutputStream jarOutputStream) throws IOException {
   139|         if (shadedManifest == null) {
   140|             shadedManifest = new Manifest();
   141|         }
   142|         precompileOverrideInstructions();
   143|         Attributes attributes = shadedManifest.getMainAttributes();
   144|         attributes.putValue(IMPORT_PACKAGE, join(shadeImports().iterator(), ","));
   145|         attributes.putValue(EXPORT_PACKAGE, join(shadeExports().iterator(), ","));
   146|         attributes.putValue("Created-By", "HazelcastManifestTransformer through Shade Plugin");
   147|         if (mainClass != null) {
   148|             attributes.put(Attributes.Name.MAIN_CLASS, mainClass);
   149|         }
   150|         if (manifestEntries != null) {
   151|             for (Map.Entry<String, Attributes> entry : manifestEntries.entrySet()) {
   152|                 attributes.put(new Attributes.Name(entry.getKey()), entry.getValue());
   153|             }
   154|         }
   155|         attributes.remove(AUTOMATIC_MODULE_NAME);
   156|         jarOutputStream.putNextEntry(new JarEntry(JarFile.MANIFEST_NAME));
   157|         shadedManifest.write(jarOutputStream);
   158|         jarOutputStream.flush();
   159|     }
   160|     @SuppressFBWarnings(value = "NP_UNWRITTEN_FIELD", justification = "Field is set by Maven")
   161|     private void precompileOverrideInstructions() {
   162|         String importPackageInstructions = overrideInstructions.get(IMPORT_PACKAGE);
   163|         if (importPackageInstructions != null) {
   164|             List<String> packageInstructions = ElementParser.parseDelimitedString(importPackageInstructions, ',', true);
   165|             for (String packageInstruction : packageInstructions) {
   166|                 PackageDefinition packageDefinition = new PackageDefinition(packageInstruction);
   167|                 Instruction instruction = Instruction.getPattern(packageDefinition.packageName);
   168|                 System.out.println("Compiled import instruction '" + packageInstruction + "' -> " + instruction);
   169|                 importOverrideInstructions.add(new InstructionDefinition(packageDefinition, instruction));
   170|             }
   171|         }
   172|         String exportPackageInstructions = overrideInstructions.get(EXPORT_PACKAGE);
   173|         if (exportPackageInstructions != null) {
   174|             List<String> packageInstructions = ElementParser.parseDelimitedString(exportPackageInstructions, ',', true);
   175|             for (String packageInstruction : packageInstructions) {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/AuthenticationException.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-36 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client;
    17| import com.hazelcast.core.HazelcastException;
    18| /**
    19|  * A {@link HazelcastException} that is thrown when there is an Authentication failure: e.g. credentials from client is not valid.
    20|  */
    21| public class AuthenticationException extends HazelcastException {
    22|     /**
    23|      * Creates a AuthenticationException with a default message.
    24|      */
    25|     public AuthenticationException() {
    26|         super("Wrong group name or password.");
    27|     }
    28|     /**
    29|      * Creates a AuthenticationException with the given message.
    30|      *
    31|      * @param message the message.
    32|      */
    33|     public AuthenticationException(String message) {
    34|         super(message);
    35|     }
    36| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/ClientExtension.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-74 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client;
    17| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    18| import com.hazelcast.client.spi.ClientProxyFactory;
    19| import com.hazelcast.internal.nearcache.NearCacheManager;
    20| import com.hazelcast.internal.networking.ChannelInitializer;
    21| import com.hazelcast.internal.serialization.InternalSerializationService;
    22| import com.hazelcast.map.impl.MapService;
    23| import com.hazelcast.memory.MemoryStats;
    24| import com.hazelcast.nio.SocketInterceptor;
    25| /**
    26|  * ClientExtension is a client extension mechanism to be able to plug different implementations of
    27|  * some modules, like; {@link InternalSerializationService} etc.
    28|  */
    29| public interface ClientExtension {
    30|     /**
    31|      * Called before client is started
    32|      */
    33|     void beforeStart(HazelcastClientInstanceImpl client);
    34|     /**
    35|      * Called after node is started
    36|      */
    37|     void afterStart(HazelcastClientInstanceImpl client);
    38|     /**
    39|      * Creates a {@link InternalSerializationService} instance to be used by this client.
    40|      *
    41|      * @param version serialization version to be created. Values less than 1 will be ignored and max supported version
    42|      *                will be used
    43|      * @return the created {@link InternalSerializationService} instance
    44|      */
    45|     InternalSerializationService createSerializationService(byte version);
    46|     /**
    47|      * Creates a {@link SocketInterceptor} to be used by this client if available,
    48|      * otherwise returns <code>null</code>
    49|      *
    50|      * @return the created {@link SocketInterceptor} instance if available,
    51|      * +          otherwise <code>null</code>
    52|      */
    53|     SocketInterceptor createSocketInterceptor();
    54|     ChannelInitializer createChannelInitializer();
    55|     /**
    56|      * Creates a {@link NearCacheManager} instance to be used by this client.
    57|      *
    58|      * @return the created {@link NearCacheManager} instance
    59|      */
    60|     NearCacheManager createNearCacheManager();
    61|     /**
    62|      * Creates a {@code ClientProxyFactory} for the supplied service class. Currently only the {@link MapService} is supported.
    63|      *
    64|      * @param service service for the proxy to create.
    65|      * @return {@code ClientProxyFactory} for the service.
    66|      * @throws java.lang.IllegalArgumentException if service is not known
    67|      */
    68|     <T> ClientProxyFactory createServiceProxyFactory(Class<T> service);
    69|     /**
    70|      * Returns MemoryStats of for the JVM and current HazelcastInstance.
    71|      *
    72|      * @return memory statistics
    73|      */
    74|     MemoryStats getMemoryStats();


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/ClientOutOfMemoryHandler.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client;
    17| import com.hazelcast.client.connection.nio.ClientConnectionManagerImpl;
    18| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    19| import com.hazelcast.core.HazelcastInstance;
    20| import com.hazelcast.instance.DefaultOutOfMemoryHandler;
    21| import static com.hazelcast.util.EmptyStatement.ignore;
    22| /**
    23|  * To clear resources of the client upon OutOfMemory
    24|  */
    25| public class ClientOutOfMemoryHandler extends DefaultOutOfMemoryHandler {
    26|     @Override
    27|     public void onOutOfMemory(OutOfMemoryError oome, HazelcastInstance[] hazelcastInstances) {
    28|         for (HazelcastInstance instance : hazelcastInstances) {
    29|             if (instance instanceof HazelcastClientInstanceImpl) {
    30|                 ClientHelper.cleanResources((HazelcastClientInstanceImpl) instance);
    31|             }
    32|         }
    33|         try {
    34|             oome.printStackTrace(System.err);
    35|         } catch (Throwable ignored) {
    36|             ignore(ignored);
    37|         }
    38|     }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/HazelcastClient.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-40 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client;
    17| import com.hazelcast.client.config.ClientConfig;
    18| import com.hazelcast.client.impl.clientside.ClientConnectionManagerFactory;
    19| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    20| import com.hazelcast.client.impl.clientside.HazelcastClientProxy;
    21| import com.hazelcast.core.HazelcastInstance;
    22| import com.hazelcast.core.OutOfMemoryHandler;
    23| import java.util.Collection;
    24| /**
    25|  * The HazelcastClient is comparable to the {@link com.hazelcast.core.Hazelcast} class and provides the ability
    26|  * the create and manage Hazelcast clients. Hazelcast clients are {@link HazelcastInstance} implementations, so
    27|  * in most cases most of the code is unaware of talking to a cluster member or a client.
    28|  * <p/>
    29|  * <h1>Smart vs dumb clients</h1>
    30|  * Hazelcast Client enables you to do all Hazelcast operations without being a member of the cluster. Clients can be:
    31|  * <ol>
    32|  * <li>smart: this means that they immediately can send an operation like map.get(key) to the member that owns that
    33|  * specific key.
    34|  * </li>
    35|  * <li>
    36|  * dumb: it will connect to a random member in the cluster and send requests to this member. This member then needs
    37|  * to send the request to the correct member.
    38|  * </li>
    39|  * </ol>
    40|  * For more information see {@link com.hazelcast.client.config.ClientNetworkConfig#setSmartRouting(boolean)}.


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/HazelcastClientFactory.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-35 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client;
    17| import com.hazelcast.client.config.ClientConfig;
    18| import com.hazelcast.client.impl.clientside.ClientConnectionManagerFactory;
    19| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    20| import com.hazelcast.client.impl.clientside.HazelcastClientProxy;
    21| /**
    22|  * Provides the capability for the customization of Hazelcast client factories.
    23|  *
    24|  * Its implementation can be changed and passed to the constructors of {@link HazelcastClientManager}.
    25|  *
    26|  * @param <T> type of {@link HazelcastClientInstanceImpl}
    27|  * @param <V> type of {@link HazelcastClientProxy}
    28|  * @param <C> type of {@link ClientConfig}
    29|  */
    30| public interface HazelcastClientFactory<T extends HazelcastClientInstanceImpl,
    31|         V extends HazelcastClientProxy,
    32|         C extends ClientConfig> {
    33|     T createHazelcastInstanceClient(C config, ClientConnectionManagerFactory hazelcastClientFactory);
    34|     V createProxy(T client);
    35| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/HazelcastClientManager.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-42 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client;
    17| import com.hazelcast.client.config.ClientConfig;
    18| import com.hazelcast.client.config.XmlClientConfigBuilder;
    19| import com.hazelcast.client.impl.clientside.ClientConnectionManagerFactory;
    20| import com.hazelcast.client.impl.clientside.DefaultClientConnectionManagerFactory;
    21| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    22| import com.hazelcast.client.impl.clientside.HazelcastClientProxy;
    23| import com.hazelcast.core.DuplicateInstanceNameException;
    24| import com.hazelcast.core.HazelcastInstance;
    25| import com.hazelcast.core.OutOfMemoryHandler;
    26| import com.hazelcast.instance.OutOfMemoryErrorDispatcher;
    27| import java.util.Collection;
    28| import java.util.Collections;
    29| import java.util.HashSet;
    30| import java.util.concurrent.ConcurrentHashMap;
    31| import java.util.concurrent.ConcurrentMap;
    32| import static com.hazelcast.util.EmptyStatement.ignore;
    33| /**
    34|  * Central manager for all Hazelcast clients of the JVM.
    35|  *
    36|  * All creation functionality will be stored here and a particular instance of a client will delegate here.
    37|  */
    38| public final class HazelcastClientManager {
    39|     /**
    40|      * Global instance of {@link HazelcastClientManager}
    41|      */
    42|     public static final HazelcastClientManager INSTANCE = new HazelcastClientManager();


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/UndefinedErrorCodeException.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-34 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client;
    17| import com.hazelcast.core.HazelcastException;
    18| /**
    19|  * This exception is thrown when an exception that is coming from server is not recognized by the protocol.
    20|  * Class name of the original exception is included in the exception
    21|  */
    22| public class UndefinedErrorCodeException extends HazelcastException {
    23|     private final String className;
    24|     public UndefinedErrorCodeException(String message, String className) {
    25|         super("Class name: " + className + ", Message: " + message);
    26|         this.className = className;
    27|     }
    28|     /**
    29|      * @return name of the original class name
    30|      */
    31|     public String getOriginClassName() {
    32|         return className;
    33|     }
    34| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/AbstractClientCacheProxy.java
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 1-69 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.cache.impl;
    17| import com.hazelcast.cache.CacheStatistics;
    18| import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
    19| import com.hazelcast.client.impl.protocol.ClientMessage;
    20| import com.hazelcast.client.impl.protocol.codec.CacheGetAllCodec;
    21| import com.hazelcast.client.impl.protocol.codec.CacheGetCodec;
    22| import com.hazelcast.client.impl.protocol.codec.CachePutAllCodec;
    23| import com.hazelcast.client.impl.protocol.codec.CacheSetExpiryPolicyCodec;
    24| import com.hazelcast.client.impl.protocol.codec.CacheSizeCodec;
    25| import com.hazelcast.client.spi.ClientContext;
    26| import com.hazelcast.client.spi.ClientPartitionService;
    27| import com.hazelcast.client.spi.impl.ClientInvocation;
    28| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    29| import com.hazelcast.client.util.ClientDelegatingFuture;
    30| import com.hazelcast.config.CacheConfig;
    31| import com.hazelcast.core.ExecutionCallback;
    32| import com.hazelcast.core.ICompletableFuture;
    33| import com.hazelcast.nio.serialization.Data;
    34| import com.hazelcast.spi.InternalCompletableFuture;
    35| import com.hazelcast.util.FutureUtil;
    36| import javax.cache.CacheException;
    37| import javax.cache.expiry.ExpiryPolicy;
    38| import java.util.AbstractMap;
    39| import java.util.ArrayList;
    40| import java.util.Collection;
    41| import java.util.LinkedList;
    42| import java.util.List;
    43| import java.util.Map;
    44| import java.util.Set;
    45| import java.util.concurrent.ExecutionException;
    46| import java.util.concurrent.Future;
    47| import static com.hazelcast.cache.impl.CacheProxyUtil.NULL_KEY_IS_NOT_ALLOWED;
    48| import static com.hazelcast.cache.impl.CacheProxyUtil.validateNotNull;
    49| import static com.hazelcast.cache.impl.operation.MutableOperation.IGNORE_COMPLETION;
    50| import static com.hazelcast.util.CollectionUtil.objectToDataCollection;
    51| import static com.hazelcast.util.ExceptionUtil.rethrow;
    52| import static com.hazelcast.util.ExceptionUtil.rethrowAllowedTypeFirst;
    53| import static com.hazelcast.util.MapUtil.createHashMap;
    54| import static com.hazelcast.util.Preconditions.checkNotNull;
    55| import static java.util.Collections.emptyMap;
    56| /**
    57|  * Hazelcast provides extension functionality to default spec interface {@link javax.cache.Cache}.
    58|  * {@link com.hazelcast.cache.ICache} is the designated interface.
    59|  *
    60|  * AbstractCacheProxyExtension provides implementation of various {@link com.hazelcast.cache.ICache} methods.
    61|  *
    62|  * Note: this partial implementation is used by client.
    63|  *
    64|  * @param <K> the type of key
    65|  * @param <V> the type of value
    66|  */
    67| @SuppressWarnings("checkstyle:npathcomplexity")
    68| abstract class AbstractClientCacheProxy<K, V> extends AbstractClientInternalCacheProxy<K, V> {
    69|     @SuppressWarnings("unchecked")

# --- HUNK 2: Lines 222-371 ---
   222|     }
   223|     @Override
   224|     public void put(K key, V value, ExpiryPolicy expiryPolicy) {
   225|         putSyncInternal(key, value, expiryPolicy, false);
   226|     }
   227|     @Override
   228|     public V getAndPut(K key, V value, ExpiryPolicy expiryPolicy) {
   229|         return putSyncInternal(key, value, expiryPolicy, true);
   230|     }
   231|     @Override
   232|     @SuppressWarnings("unchecked")
   233|     public void putAll(Map<? extends K, ? extends V> map, ExpiryPolicy expiryPolicy) {
   234|         long startNanos = nowInNanosOrDefault();
   235|         ensureOpen();
   236|         checkNotNull(map, "map is null");
   237|         if (map.isEmpty()) {
   238|             return;
   239|         }
   240|         putAllInternal(map, expiryPolicy, null, new List[partitionCount], startNanos);
   241|     }
   242|     @Override
   243|     public void setExpiryPolicy(Set<? extends K> keys, ExpiryPolicy policy) {
   244|         ensureOpen();
   245|         checkNotNull(keys);
   246|         checkNotNull(policy);
   247|         if (keys.isEmpty()) {
   248|             return;
   249|         }
   250|         setExpiryPolicyInternal(keys, policy);
   251|     }
   252|     @Override
   253|     public boolean setExpiryPolicy(K key, ExpiryPolicy expiryPolicy) {
   254|         return setExpiryPolicyInternal(key, expiryPolicy);
   255|     }
   256|     protected void setExpiryPolicyInternal(Set<? extends K> keys, ExpiryPolicy policy) {
   257|         setExpiryPolicyInternal(keys, policy, null);
   258|     }
   259|     protected void setExpiryPolicyInternal(Set<? extends K> keys, ExpiryPolicy policy, Set<Data> serializedKeys) {
   260|         try {
   261|             List<Data>[] keysByPartition = groupKeysToPartitions(keys, serializedKeys);
   262|             setExpiryPolicyAndWaitForCompletion(keysByPartition, policy);
   263|         } catch (Exception e) {
   264|             throw rethrow(e);
   265|         }
   266|     }
   267|     protected void putAllInternal(Map<? extends K, ? extends V> map, ExpiryPolicy expiryPolicy, Map<Object, Data> keyMap,
   268|                                   List<Map.Entry<Data, Data>>[] entriesPerPartition, long startNanos) {
   269|         try {
   270|             groupDataToPartitions(map, getContext().getPartitionService(), keyMap, entriesPerPartition);
   271|             putToAllPartitionsAndWaitForCompletion(entriesPerPartition, expiryPolicy, startNanos);
   272|         } catch (Exception t) {
   273|             throw rethrow(t);
   274|         }
   275|     }
   276|     private void groupDataToPartitions(Map<? extends K, ? extends V> map, ClientPartitionService partitionService,
   277|                                        Map<Object, Data> keyMap, List<Map.Entry<Data, Data>>[] entriesPerPartition) {
   278|         for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {
   279|             K key = entry.getKey();
   280|             V value = entry.getValue();
   281|             validateNotNull(key, value);
   282|             Data keyData = toData(key);
   283|             Data valueData = toData(value);
   284|             if (keyMap != null) {
   285|                 keyMap.put(key, keyData);
   286|             }
   287|             int partitionId = partitionService.getPartitionId(keyData);
   288|             List<Map.Entry<Data, Data>> entries = entriesPerPartition[partitionId];
   289|             if (entries == null) {
   290|                 entries = new ArrayList<Map.Entry<Data, Data>>();
   291|                 entriesPerPartition[partitionId] = entries;
   292|             }
   293|             entries.add(new AbstractMap.SimpleImmutableEntry<Data, Data>(keyData, valueData));
   294|         }
   295|     }
   296|     private List<Data>[] groupKeysToPartitions(Set<? extends K> keys, Set<Data> serializedKeys) {
   297|         List<Data>[] keysByPartition = new List[partitionCount];
   298|         ClientPartitionService partitionService = getContext().getPartitionService();
   299|         for (K key: keys) {
   300|             Data keyData = getSerializationService().toData(key);
   301|             if (serializedKeys != null) {
   302|                 serializedKeys.add(keyData);
   303|             }
   304|             int partitionId = partitionService.getPartitionId(keyData);
   305|             List<Data> partition = keysByPartition[partitionId];
   306|             if (partition == null) {
   307|                 partition = new ArrayList<Data>();
   308|                 keysByPartition[partitionId] = partition;
   309|             }
   310|             partition.add(keyData);
   311|         }
   312|         return keysByPartition;
   313|     }
   314|     private static final class FutureEntriesTuple {
   315|         private final Future future;
   316|         private final List<Map.Entry<Data, Data>> entries;
   317|         private FutureEntriesTuple(Future future, List<Map.Entry<Data, Data>> entries) {
   318|             this.future = future;
   319|             this.entries = entries;
   320|         }
   321|     }
   322|     private void putToAllPartitionsAndWaitForCompletion(List<Map.Entry<Data, Data>>[] entriesPerPartition,
   323|                                                         ExpiryPolicy expiryPolicy, long startNanos)
   324|             throws ExecutionException, InterruptedException {
   325|         Data expiryPolicyData = toData(expiryPolicy);
   326|         List<FutureEntriesTuple> futureEntriesTuples = new ArrayList<FutureEntriesTuple>(entriesPerPartition.length);
   327|         for (int partitionId = 0; partitionId < entriesPerPartition.length; partitionId++) {
   328|             List<Map.Entry<Data, Data>> entries = entriesPerPartition[partitionId];
   329|             if (entries != null) {
   330|                 int completionId = nextCompletionId();
   331|                 ClientMessage request = CachePutAllCodec.encodeRequest(nameWithPrefix, entries, expiryPolicyData, completionId);
   332|                 Future future = invoke(request, partitionId, completionId);
   333|                 futureEntriesTuples.add(new FutureEntriesTuple(future, entries));
   334|             }
   335|         }
   336|         waitResponseFromAllPartitionsForPutAll(futureEntriesTuples, startNanos);
   337|     }
   338|     private void setExpiryPolicyAndWaitForCompletion(List<Data>[] keysByPartition, ExpiryPolicy expiryPolicy) {
   339|         List<Future> futures = new ArrayList<Future>(keysByPartition.length);
   340|         Data policyData = toData(expiryPolicy);
   341|         for (int partitionId = 0; partitionId < keysByPartition.length; partitionId++) {
   342|             List<Data> keys = keysByPartition[partitionId];
   343|             if (keys != null) {
   344|                 ClientMessage request = CacheSetExpiryPolicyCodec.encodeRequest(nameWithPrefix, keys, policyData);
   345|                 futures.add(invoke(request, partitionId, IGNORE_COMPLETION));
   346|             }
   347|         }
   348|         List<Throwable> throwables = FutureUtil.waitUntilAllResponded(futures);
   349|         if (throwables.size() > 0) {
   350|             throw rethrow(throwables.get(0));
   351|         }
   352|     }
   353|     private void waitResponseFromAllPartitionsForPutAll(List<FutureEntriesTuple> futureEntriesTuples, long startNanos) {
   354|         Throwable error = null;
   355|         for (FutureEntriesTuple tuple : futureEntriesTuples) {
   356|             Future future = tuple.future;
   357|             List<Map.Entry<Data, Data>> entries = tuple.entries;
   358|             try {
   359|                 future.get();
   360|                 if (statisticsEnabled) {
   361|                     statsHandler.getStatistics().increaseCachePuts(entries.size());
   362|                 }
   363|             } catch (Throwable t) {
   364|                 logger.finest("Error occurred while putting entries as batch!", t);
   365|                 if (error == null) {
   366|                     error = t;
   367|                 }
   368|             }
   369|         }
   370|         if (statisticsEnabled) {
   371|             statsHandler.getStatistics().addPutTimeNanos(nowInNanosOrDefault() - startNanos);


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/AbstractClientCacheProxyBase.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.cache.impl;
    17| import com.hazelcast.cache.impl.ICacheInternal;
    18| import com.hazelcast.cache.impl.ICacheService;
    19| import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
    20| import com.hazelcast.client.impl.protocol.ClientMessage;
    21| import com.hazelcast.client.spi.ClientContext;
    22| import com.hazelcast.client.spi.ClientProxy;
    23| import com.hazelcast.client.spi.impl.ClientInvocation;
    24| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    25| import com.hazelcast.client.util.ClientDelegatingFuture;
    26| import com.hazelcast.config.CacheConfig;
    27| import com.hazelcast.core.ExecutionCallback;
    28| import com.hazelcast.core.ManagedContext;
    29| import com.hazelcast.logging.ILogger;
    30| import com.hazelcast.nio.serialization.Data;
    31| import javax.cache.CacheException;
    32| import javax.cache.integration.CompletionListener;
    33| import java.util.Iterator;
    34| import java.util.List;
    35| import java.util.Map;
    36| import java.util.concurrent.ConcurrentHashMap;
    37| import java.util.concurrent.ConcurrentMap;
    38| import java.util.concurrent.ExecutionException;
    39| import java.util.concurrent.Future;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/AbstractClientInternalCacheProxy.java
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 3-77 ---
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.cache.impl;
    17| import com.hazelcast.cache.HazelcastCacheManager;
    18| import com.hazelcast.cache.impl.CacheEventData;
    19| import com.hazelcast.cache.impl.CacheEventListenerAdaptor;
    20| import com.hazelcast.cache.impl.CacheSyncListenerCompleter;
    21| import com.hazelcast.cache.impl.operation.MutableOperation;
    22| import com.hazelcast.client.HazelcastClientNotActiveException;
    23| import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
    24| import com.hazelcast.client.impl.protocol.ClientMessage;
    25| import com.hazelcast.client.impl.protocol.codec.CacheAddEntryListenerCodec;
    26| import com.hazelcast.client.impl.protocol.codec.CacheClearCodec;
    27| import com.hazelcast.client.impl.protocol.codec.CacheGetAndRemoveCodec;
    28| import com.hazelcast.client.impl.protocol.codec.CacheGetAndReplaceCodec;
    29| import com.hazelcast.client.impl.protocol.codec.CachePutCodec;
    30| import com.hazelcast.client.impl.protocol.codec.CachePutIfAbsentCodec;
    31| import com.hazelcast.client.impl.protocol.codec.CacheRemoveAllCodec;
    32| import com.hazelcast.client.impl.protocol.codec.CacheRemoveAllKeysCodec;
    33| import com.hazelcast.client.impl.protocol.codec.CacheRemoveCodec;
    34| import com.hazelcast.client.impl.protocol.codec.CacheReplaceCodec;
    35| import com.hazelcast.client.impl.protocol.codec.CacheSetExpiryPolicyCodec;
    36| import com.hazelcast.client.spi.ClientContext;
    37| import com.hazelcast.client.spi.ClientListenerService;
    38| import com.hazelcast.client.spi.ClientPartitionService;
    39| import com.hazelcast.client.spi.EventHandler;
    40| import com.hazelcast.client.spi.impl.ClientInvocation;
    41| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    42| import com.hazelcast.client.util.ClientDelegatingFuture;
    43| import com.hazelcast.config.CacheConfig;
    44| import com.hazelcast.core.ExecutionCallback;
    45| import com.hazelcast.core.ICompletableFuture;
    46| import com.hazelcast.nio.IOUtil;
    47| import com.hazelcast.nio.serialization.Data;
    48| import javax.cache.CacheException;
    49| import javax.cache.CacheManager;
    50| import javax.cache.configuration.CacheEntryListenerConfiguration;
    51| import javax.cache.event.CacheEntryListener;
    52| import javax.cache.expiry.ExpiryPolicy;
    53| import java.io.Closeable;
    54| import java.util.Collection;
    55| import java.util.Collections;
    56| import java.util.Iterator;
    57| import java.util.List;
    58| import java.util.Set;
    59| import java.util.concurrent.ConcurrentHashMap;
    60| import java.util.concurrent.ConcurrentMap;
    61| import java.util.concurrent.CountDownLatch;
    62| import java.util.concurrent.ExecutionException;
    63| import java.util.concurrent.Future;
    64| import java.util.concurrent.TimeUnit;
    65| import java.util.concurrent.atomic.AtomicReference;
    66| import static com.hazelcast.cache.impl.CacheProxyUtil.validateConfiguredTypes;
    67| import static com.hazelcast.cache.impl.CacheProxyUtil.validateNotNull;
    68| import static com.hazelcast.cache.impl.operation.MutableOperation.IGNORE_COMPLETION;
    69| import static com.hazelcast.util.ExceptionUtil.rethrow;
    70| import static com.hazelcast.util.ExceptionUtil.rethrowAllowedTypeFirst;
    71| import static com.hazelcast.util.ExceptionUtil.sneakyThrow;
    72| import static java.lang.Thread.currentThread;
    73| /**
    74|  * Abstract {@link com.hazelcast.cache.ICache} implementation which provides shared internal implementations
    75|  * of cache operations like put, replace, remove and invoke. These internal implementations are delegated
    76|  * by actual cache methods.
    77|  * <p>

# --- HUNK 2: Lines 110-155 ---
   110|     private static final ClientMessageDecoder GET_AND_REPLACE_RESPONSE_DECODER = new ClientMessageDecoder() {
   111|         @Override
   112|         public <T> T decodeClientMessage(ClientMessage clientMessage) {
   113|             return (T) CacheGetAndReplaceCodec.decodeResponse(clientMessage).response;
   114|         }
   115|     };
   116|     @SuppressWarnings("unchecked")
   117|     private static final ClientMessageDecoder PUT_RESPONSE_DECODER = new ClientMessageDecoder() {
   118|         @Override
   119|         public <T> T decodeClientMessage(ClientMessage clientMessage) {
   120|             return (T) CachePutCodec.decodeResponse(clientMessage).response;
   121|         }
   122|     };
   123|     @SuppressWarnings("unchecked")
   124|     private static final ClientMessageDecoder PUT_IF_ABSENT_RESPONSE_DECODER = new ClientMessageDecoder() {
   125|         @Override
   126|         public <T> T decodeClientMessage(ClientMessage clientMessage) {
   127|             return (T) Boolean.valueOf(CachePutIfAbsentCodec.decodeResponse(clientMessage).response);
   128|         }
   129|     };
   130|     private static final ClientMessageDecoder SET_EXPIRY_POLICY_DECODER = new ClientMessageDecoder() {
   131|         @Override
   132|         public <T> T decodeClientMessage(ClientMessage clientMessage) {
   133|             return (T) Boolean.valueOf(CacheSetExpiryPolicyCodec.decodeResponse(clientMessage).response);
   134|         }
   135|     };
   136|     protected final AtomicReference<HazelcastClientCacheManager> cacheManagerRef
   137|             = new AtomicReference<HazelcastClientCacheManager>();
   138|     protected int partitionCount;
   139|     private final ConcurrentMap<CacheEntryListenerConfiguration, String> asyncListenerRegistrations;
   140|     private final ConcurrentMap<CacheEntryListenerConfiguration, String> syncListenerRegistrations;
   141|     private final ConcurrentMap<String, Closeable> closeableListeners;
   142|     private final ConcurrentMap<Integer, CountDownLatch> syncLocks;
   143|     AbstractClientInternalCacheProxy(CacheConfig<K, V> cacheConfig, ClientContext context) {
   144|         super(cacheConfig, context);
   145|         this.asyncListenerRegistrations = new ConcurrentHashMap<CacheEntryListenerConfiguration, String>();
   146|         this.syncListenerRegistrations = new ConcurrentHashMap<CacheEntryListenerConfiguration, String>();
   147|         this.closeableListeners = new ConcurrentHashMap<String, Closeable>();
   148|         this.syncLocks = new ConcurrentHashMap<Integer, CountDownLatch>();
   149|     }
   150|     @Override
   151|     protected void onInitialize() {
   152|         super.onInitialize();
   153|         ClientPartitionService partitionService = getContext().getPartitionService();
   154|         partitionCount = partitionService.getPartitionCount();
   155|     }

# --- HUNK 3: Lines 403-458 ---
   403|         Data expiryPolicyData = toData(expiryPolicy);
   404|         ClientInvocationFuture invocationFuture = putInternal(keyData, valueData, expiryPolicyData, isGet, withCompletionEvent);
   405|         return wrapPutAsyncFuture(key, value, keyData, valueData, invocationFuture, callback);
   406|     }
   407|     protected ClientDelegatingFuture<V> wrapPutAsyncFuture(K key, V value, Data keyData, Data valueData,
   408|                                                            ClientInvocationFuture invocationFuture,
   409|                                                            OneShotExecutionCallback<V> callback) {
   410|         if (callback == null) {
   411|             return newDelegatingFuture(invocationFuture, PUT_RESPONSE_DECODER);
   412|         }
   413|         CallbackAwareClientDelegatingFuture<V> future = new CallbackAwareClientDelegatingFuture<V>(invocationFuture,
   414|                 getSerializationService(), PUT_RESPONSE_DECODER, callback);
   415|         future.andThenInternal(callback, true);
   416|         return future;
   417|     }
   418|     protected OneShotExecutionCallback<V> newStatsCallbackOrNull(boolean isGet) {
   419|         if (!statisticsEnabled) {
   420|             return null;
   421|         }
   422|         return statsHandler.newOnPutCallback(isGet, System.nanoTime());
   423|     }
   424|     protected boolean setExpiryPolicyInternal(K key, ExpiryPolicy expiryPolicy) {
   425|         ensureOpen();
   426|         validateNotNull(key);
   427|         validateNotNull(expiryPolicy);
   428|         Data keyData = toData(key);
   429|         Data expiryPolicyData = toData(expiryPolicy);
   430|         List<Data> list = Collections.singletonList(keyData);
   431|         ClientMessage request = CacheSetExpiryPolicyCodec.encodeRequest(nameWithPrefix, list, expiryPolicyData);
   432|         ClientInvocationFuture future = invoke(request, keyData, IGNORE_COMPLETION);
   433|         ClientDelegatingFuture<Boolean> delegatingFuture = newDelegatingFuture(future, SET_EXPIRY_POLICY_DECODER);
   434|         try {
   435|             return delegatingFuture.get();
   436|         } catch (Throwable e) {
   437|             throw rethrowAllowedTypeFirst(e, CacheException.class);
   438|         }
   439|     }
   440|     protected Object putIfAbsentInternal(K key, V value, ExpiryPolicy expiryPolicy, boolean withCompletionEvent, boolean async) {
   441|         long startNanos = nowInNanosOrDefault();
   442|         ensureOpen();
   443|         validateNotNull(key, value);
   444|         validateConfiguredTypes(cacheConfig, key, value);
   445|         Data keyData = toData(key);
   446|         Data valueData = toData(value);
   447|         Data expiryPolicyData = toData(expiryPolicy);
   448|         int completionId = withCompletionEvent ? nextCompletionId() : -1;
   449|         ClientMessage request = CachePutIfAbsentCodec.encodeRequest(nameWithPrefix, keyData, valueData,
   450|                 expiryPolicyData, completionId);
   451|         ClientInvocationFuture future = invoke(request, keyData, completionId);
   452|         ClientDelegatingFuture<Boolean> delegatingFuture = newDelegatingFuture(future, PUT_IF_ABSENT_RESPONSE_DECODER);
   453|         if (async) {
   454|             ExecutionCallback<Boolean> callback = !statisticsEnabled ? null : statsHandler.newOnPutIfAbsentCallback(startNanos);
   455|             onPutIfAbsentAsyncInternal(key, value, keyData, valueData, delegatingFuture, callback);
   456|             return delegatingFuture;
   457|         } else {
   458|             try {

# --- HUNK 4: Lines 637-667 ---
   637|             }
   638|             if (countDownLatch.getCount() > 0) {
   639|                 logger.finest("Countdown latch wait timeout after " + MAX_COMPLETION_LATCH_WAIT_TIME + " milliseconds!");
   640|             }
   641|         } catch (InterruptedException e) {
   642|             currentThread().interrupt();
   643|             sneakyThrow(e);
   644|         }
   645|     }
   646|     protected EventHandler createHandler(CacheEventListenerAdaptor<K, V> adaptor) {
   647|         return new CacheEventHandler(adaptor);
   648|     }
   649|     private final class CacheEventHandler
   650|             extends CacheAddEntryListenerCodec.AbstractEventHandler
   651|             implements EventHandler<ClientMessage> {
   652|         private final CacheEventListenerAdaptor<K, V> adaptor;
   653|         private CacheEventHandler(CacheEventListenerAdaptor<K, V> adaptor) {
   654|             this.adaptor = adaptor;
   655|         }
   656|         @Override
   657|         public void handleCacheEventV10(int type, Collection<CacheEventData> keys, int completionId) {
   658|             adaptor.handle(type, keys, completionId);
   659|         }
   660|         @Override
   661|         public void beforeListenerRegister() {
   662|         }
   663|         @Override
   664|         public void onListenerRegister() {
   665|         }
   666|     }
   667| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/CallbackAwareClientDelegatingFuture.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.cache.impl;
    17| import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
    18| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    19| import com.hazelcast.client.util.ClientDelegatingFuture;
    20| import com.hazelcast.spi.serialization.SerializationService;
    21| import com.hazelcast.util.Clock;
    22| import java.util.concurrent.ExecutionException;
    23| import java.util.concurrent.TimeUnit;
    24| import java.util.concurrent.TimeoutException;
    25| import static com.hazelcast.util.ExceptionUtil.sneakyThrow;
    26| /**
    27|  * A specific {@link ClientDelegatingFuture} implementation which calls given {@link OneShotExecutionCallback} as sync on get.
    28|  */
    29| class CallbackAwareClientDelegatingFuture<V> extends ClientDelegatingFuture<V> {
    30|     private final OneShotExecutionCallback<V> callback;
    31|     CallbackAwareClientDelegatingFuture(ClientInvocationFuture clientInvocationFuture,
    32|                                         SerializationService serializationService,
    33|                                         ClientMessageDecoder clientMessageDecoder,
    34|                                         OneShotExecutionCallback<V> callback) {
    35|         super(clientInvocationFuture, serializationService, clientMessageDecoder);
    36|         this.callback = callback;
    37|     }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/ClientCacheHelper.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-40 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.cache.impl;
    17| import com.hazelcast.cache.impl.CacheProxyUtil;
    18| import com.hazelcast.client.HazelcastClientNotActiveException;
    19| import com.hazelcast.client.connection.nio.ClientConnection;
    20| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    21| import com.hazelcast.client.impl.protocol.ClientMessage;
    22| import com.hazelcast.client.impl.protocol.codec.CacheCreateConfigCodec;
    23| import com.hazelcast.client.impl.protocol.codec.CacheGetConfigCodec;
    24| import com.hazelcast.client.impl.protocol.codec.CacheManagementConfigCodec;
    25| import com.hazelcast.client.spi.impl.AbstractClientInvocationService;
    26| import com.hazelcast.client.spi.impl.ClientInvocation;
    27| import com.hazelcast.client.spi.properties.ClientProperty;
    28| import com.hazelcast.config.CacheConfig;
    29| import com.hazelcast.config.LegacyCacheConfig;
    30| import com.hazelcast.core.Member;
    31| import com.hazelcast.core.OperationTimeoutException;
    32| import com.hazelcast.instance.BuildInfo;
    33| import com.hazelcast.nio.Address;
    34| import com.hazelcast.nio.serialization.Data;
    35| import com.hazelcast.spi.serialization.SerializationService;
    36| import com.hazelcast.util.ExceptionUtil;
    37| import com.hazelcast.util.FutureUtil;
    38| import java.io.IOException;
    39| import java.util.ArrayList;
    40| import java.util.Collection;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/ClientCacheProxy.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 2-42 ---
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.cache.impl;
    17| import com.hazelcast.cache.impl.CacheEntryProcessorResult;
    18| import com.hazelcast.cache.impl.CacheEventListenerAdaptor;
    19| import com.hazelcast.cache.impl.event.CachePartitionLostEvent;
    20| import com.hazelcast.cache.impl.event.CachePartitionLostListener;
    21| import com.hazelcast.cache.journal.EventJournalCacheEvent;
    22| import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
    23| import com.hazelcast.client.impl.protocol.ClientMessage;
    24| import com.hazelcast.client.impl.protocol.codec.CacheAddEntryListenerCodec;
    25| import com.hazelcast.client.impl.protocol.codec.CacheAddPartitionLostListenerCodec;
    26| import com.hazelcast.client.impl.protocol.codec.CacheContainsKeyCodec;
    27| import com.hazelcast.client.impl.protocol.codec.CacheEntryProcessorCodec;
    28| import com.hazelcast.client.impl.protocol.codec.CacheEventJournalReadCodec;
    29| import com.hazelcast.client.impl.protocol.codec.CacheEventJournalSubscribeCodec;
    30| import com.hazelcast.client.impl.protocol.codec.CacheEventJournalSubscribeCodec.ResponseParameters;
    31| import com.hazelcast.client.impl.protocol.codec.CacheListenerRegistrationCodec;
    32| import com.hazelcast.client.impl.protocol.codec.CacheLoadAllCodec;
    33| import com.hazelcast.client.impl.protocol.codec.CacheRemoveEntryListenerCodec;
    34| import com.hazelcast.client.impl.protocol.codec.CacheRemovePartitionLostListenerCodec;
    35| import com.hazelcast.client.spi.ClientContext;
    36| import com.hazelcast.client.spi.EventHandler;
    37| import com.hazelcast.client.spi.impl.ClientInvocation;
    38| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    39| import com.hazelcast.client.spi.impl.ListenerMessageCodec;
    40| import com.hazelcast.client.util.ClientDelegatingFuture;
    41| import com.hazelcast.config.CacheConfig;
    42| import com.hazelcast.core.ICompletableFuture;

# --- HUNK 2: Lines 478-503 ---
   478|         final SerializationService ss = getSerializationService();
   479|         final ClientMessage request = CacheEventJournalReadCodec.encodeRequest(
   480|                 nameWithPrefix, startSequence, minSize, maxSize, ss.toData(predicate), ss.toData(projection));
   481|         final ClientInvocationFuture fut = new ClientInvocation(getClient(), request, getName(), partitionId).invoke();
   482|         return new ClientDelegatingFuture<ReadResultSet<T>>(fut, ss, eventJournalReadResponseDecoder);
   483|     }
   484|     private final class ClientCachePartitionLostEventHandler
   485|             extends CacheAddPartitionLostListenerCodec.AbstractEventHandler
   486|             implements EventHandler<ClientMessage> {
   487|         private CachePartitionLostListener listener;
   488|         private ClientCachePartitionLostEventHandler(CachePartitionLostListener listener) {
   489|             this.listener = listener;
   490|         }
   491|         @Override
   492|         public void beforeListenerRegister() {
   493|         }
   494|         @Override
   495|         public void onListenerRegister() {
   496|         }
   497|         @Override
   498|         public void handleCachePartitionLostEventV10(int partitionId, String uuid) {
   499|             Member member = getContext().getClusterService().getMember(uuid);
   500|             listener.partitionLost(new CachePartitionLostEvent(name, member, PARTITION_LOST.getType(), partitionId));
   501|         }
   502|     }
   503| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/ClientCacheProxyFactory.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.cache.impl;
    17| import com.hazelcast.cache.CacheNotExistsException;
    18| import com.hazelcast.cache.HazelcastCacheManager;
    19| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    20| import com.hazelcast.client.spi.ClientContext;
    21| import com.hazelcast.client.spi.ClientProxy;
    22| import com.hazelcast.client.spi.impl.ClientProxyFactoryWithContext;
    23| import com.hazelcast.config.CacheConfig;
    24| import com.hazelcast.config.NearCacheConfig;
    25| import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
    26| import java.util.Map;
    27| import java.util.Set;
    28| import java.util.concurrent.ConcurrentHashMap;
    29| import java.util.concurrent.ConcurrentMap;
    30| public class ClientCacheProxyFactory extends ClientProxyFactoryWithContext {
    31|     private final HazelcastClientInstanceImpl client;
    32|     private final ConcurrentMap<String, CacheConfig> configs = new ConcurrentHashMap<String, CacheConfig>();
    33|     public ClientCacheProxyFactory(HazelcastClientInstanceImpl client) {
    34|         this.client = client;
    35|     }
    36|     @Override
    37|     public ClientProxy create(String id, ClientContext context) {
    38|         CacheConfig cacheConfig = findCacheConfig(id);
    39|         if (cacheConfig == null) {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/ClientClusterWideIterator.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.cache.impl;
    17| import com.hazelcast.cache.impl.AbstractClusterWideIterator;
    18| import com.hazelcast.cache.impl.ICacheInternal;
    19| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    20| import com.hazelcast.client.impl.protocol.ClientMessage;
    21| import com.hazelcast.client.impl.protocol.codec.CacheIterateCodec;
    22| import com.hazelcast.client.impl.protocol.codec.CacheIterateEntriesCodec;
    23| import com.hazelcast.client.spi.ClientContext;
    24| import com.hazelcast.client.spi.impl.ClientInvocation;
    25| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    26| import com.hazelcast.nio.serialization.Data;
    27| import javax.cache.Cache;
    28| import java.util.Iterator;
    29| import java.util.List;
    30| import static com.hazelcast.util.ExceptionUtil.rethrow;
    31| /**
    32|  * Client side cluster-wide iterator for {@link com.hazelcast.cache.ICache}.
    33|  *
    34|  * This implementation is used by client implementation of JCache.
    35|  *
    36|  * Note: For more information on the iterator details, see {@link AbstractClusterWideIterator}.
    37|  *
    38|  * @param <K> the type of key.
    39|  * @param <V> the type of value.


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/HazelcastClientCacheManager.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-165 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.cache.impl;
    17| import com.hazelcast.cache.HazelcastCachingProvider;
    18| import com.hazelcast.cache.impl.AbstractHazelcastCacheManager;
    19| import com.hazelcast.cache.impl.ICacheInternal;
    20| import com.hazelcast.cache.impl.ICacheService;
    21| import com.hazelcast.client.impl.clientside.ClientICacheManager;
    22| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    23| import com.hazelcast.client.impl.clientside.HazelcastClientProxy;
    24| import com.hazelcast.client.spi.ProxyManager;
    25| import com.hazelcast.config.CacheConfig;
    26| import com.hazelcast.core.HazelcastInstance;
    27| import com.hazelcast.internal.nearcache.NearCacheManager;
    28| import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
    29| import java.net.URI;
    30| import java.util.Iterator;
    31| import java.util.Map;
    32| import java.util.Properties;
    33| import static com.hazelcast.internal.config.ConfigValidator.checkCacheConfig;
    34| import static com.hazelcast.util.ExceptionUtil.rethrow;
    35| import static com.hazelcast.util.Preconditions.checkNotNull;
    36| /**
    37|  * {@link javax.cache.CacheManager} implementation for client side.
    38|  * <p>
    39|  * Provides client side CacheManager functionality.
    40|  */
    41| public final class HazelcastClientCacheManager extends AbstractHazelcastCacheManager {
    42|     private final HazelcastClientInstanceImpl client;
    43|     private final ClientCacheProxyFactory clientCacheProxyFactory;
    44|     public HazelcastClientCacheManager(HazelcastClientCachingProvider cachingProvider, HazelcastInstance hazelcastInstance,
    45|                                        URI uri, ClassLoader classLoader, Properties properties) {
    46|         super(cachingProvider, hazelcastInstance, uri, classLoader, properties);
    47|         /*
    48|          * TODO:
    49|          *
    50|          * A new interface, such as `InternalHazelcastInstance` (with a
    51|          * `getOriginalInstance()` method), might be introduced. Then the
    52|          * underlying actual (original) Hazelcast instance can be retrieved
    53|          * through this.
    54|          *
    55|          * The original Hazelcast instance is used for getting access to
    56|          * internals. It's also used for passing the full cache name directly
    57|          * by this cache manager itself.
    58|          */
    59|         if (hazelcastInstance instanceof HazelcastClientProxy) {
    60|             client = ((HazelcastClientProxy) hazelcastInstance).client;
    61|         } else {
    62|             client = ((HazelcastClientInstanceImpl) hazelcastInstance);
    63|         }
    64|         ProxyManager proxyManager = client.getProxyManager();
    65|         clientCacheProxyFactory = (ClientCacheProxyFactory) proxyManager.getClientProxyFactory(ICacheService.SERVICE_NAME);
    66|     }
    67|     @Override
    68|     public void enableManagement(String cacheName, boolean enabled) {
    69|         enableStatisticManagementOnNodes(cacheName, false, enabled);
    70|     }
    71|     @Override
    72|     public void enableStatistics(String cacheName, boolean enabled) {
    73|         enableStatisticManagementOnNodes(cacheName, true, enabled);
    74|     }
    75|     private void enableStatisticManagementOnNodes(String cacheName, boolean statOrMan, boolean enabled) {
    76|         ensureOpen();
    77|         checkNotNull(cacheName, "cacheName cannot be null");
    78|         ClientCacheHelper.enableStatisticManagementOnNodes(client, getCacheNameWithPrefix(cacheName), statOrMan, enabled);
    79|     }
    80|     @SuppressFBWarnings("RV_RETURN_VALUE_OF_PUTIFABSENT_IGNORED")
    81|     @Override
    82|     protected <K, V> void addCacheConfigIfAbsent(CacheConfig<K, V> cacheConfig) {
    83|         clientCacheProxyFactory.addCacheConfig(cacheConfig.getNameWithPrefix(), cacheConfig);
    84|     }
    85|     @Override
    86|     protected void removeCacheConfigFromLocal(String cacheNameWithPrefix) {
    87|         clientCacheProxyFactory.removeCacheConfig(cacheNameWithPrefix);
    88|     }
    89|     @Override
    90|     protected <K, V> CacheConfig<K, V> getCacheConfig(String cacheName, String simpleCacheName) {
    91|         return ClientCacheHelper.getCacheConfig(client, cacheName, simpleCacheName);
    92|     }
    93|     @Override
    94|     protected <K, V> ICacheInternal<K, V> createCacheProxy(CacheConfig<K, V> cacheConfig) {
    95|         clientCacheProxyFactory.addCacheConfig(cacheConfig.getNameWithPrefix(), cacheConfig);
    96|         try {
    97|             ClientICacheManager cacheManager = client.getCacheManager();
    98|             String nameWithPrefix = cacheConfig.getNameWithPrefix();
    99|             ICacheInternal<K, V> cache = (ICacheInternal<K, V>) cacheManager.getCacheByFullName(nameWithPrefix);
   100|             cache.setCacheManager(this);
   101|             return cache;
   102|         } catch (Throwable t) {
   103|             clientCacheProxyFactory.removeCacheConfig(cacheConfig.getNameWithPrefix());
   104|             throw rethrow(t);
   105|         }
   106|     }
   107|     @Override
   108|     @SuppressWarnings("unchecked")
   109|     protected <K, V> CacheConfig<K, V> findCacheConfig(String cacheName, String simpleCacheName) {
   110|         if (simpleCacheName == null) {
   111|             return null;
   112|         }
   113|         CacheConfig<K, V> config = clientCacheProxyFactory.getCacheConfig(cacheName);
   114|         if (config == null) {
   115|             config = getCacheConfig(cacheName, simpleCacheName);
   116|             if (config != null) {
   117|                 createCacheConfig(cacheName, config);
   118|             }
   119|         }
   120|         return config;
   121|     }
   122|     @Override
   123|     protected <K, V> void createCacheConfig(String cacheName, CacheConfig<K, V> config) {
   124|         ClientCacheHelper.createCacheConfig(client, config);
   125|     }
   126|     @Override
   127|     @SuppressWarnings("unchecked")
   128|     public <T> T unwrap(Class<T> clazz) {
   129|         if (HazelcastClientCacheManager.class.isAssignableFrom(clazz)) {
   130|             return (T) this;
   131|         }
   132|         throw new IllegalArgumentException();
   133|     }
   134|     @Override
   135|     protected void postClose() {
   136|         if (properties.getProperty(HazelcastCachingProvider.HAZELCAST_CONFIG_LOCATION) != null) {
   137|             hazelcastInstance.shutdown();
   138|         }
   139|     }
   140|     @Override
   141|     protected void postDestroy() {
   142|         Iterator<Map.Entry<String, CacheConfig>> iterator = clientCacheProxyFactory.configs().iterator();
   143|         while (iterator.hasNext()) {
   144|             Map.Entry<String, CacheConfig> entry = iterator.next();
   145|             String cacheName = entry.getKey();
   146|             clientCacheProxyFactory.removeCacheConfig(cacheName);
   147|             iterator.remove();
   148|         }
   149|     }
   150|     @Override
   151|     protected <K, V> void validateCacheConfig(CacheConfig<K, V> cacheConfig) {
   152|         checkCacheConfig(cacheConfig, null);
   153|     }
   154|     @Override
   155|     protected void onShuttingDown() {
   156|     }
   157|     /**
   158|      * Gets the related {@link NearCacheManager} with the underlying client instance.
   159|      *
   160|      * @return the related {@link NearCacheManager} with the underlying client instance
   161|      */
   162|     public NearCacheManager getNearCacheManager() {
   163|         return client.getNearCacheManager();
   164|     }
   165| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/HazelcastClientCachingProvider.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-191 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.cache.impl;
    17| import com.hazelcast.cache.impl.AbstractHazelcastCacheManager;
    18| import com.hazelcast.cache.impl.AbstractHazelcastCachingProvider;
    19| import com.hazelcast.client.HazelcastClient;
    20| import com.hazelcast.client.config.ClientConfig;
    21| import com.hazelcast.client.config.XmlClientConfigBuilder;
    22| import com.hazelcast.core.HazelcastInstance;
    23| import java.io.IOException;
    24| import java.net.URI;
    25| import java.net.URISyntaxException;
    26| import java.net.URL;
    27| import java.util.Properties;
    28| import static com.hazelcast.cache.HazelcastCachingProvider.HAZELCAST_CONFIG_LOCATION;
    29| import static com.hazelcast.cache.HazelcastCachingProvider.HAZELCAST_INSTANCE_ITSELF;
    30| import static com.hazelcast.cache.HazelcastCachingProvider.HAZELCAST_INSTANCE_NAME;
    31| import static com.hazelcast.util.ExceptionUtil.rethrow;
    32| import static com.hazelcast.util.StringUtil.isNullOrEmpty;
    33| import static com.hazelcast.util.StringUtil.isNullOrEmptyAfterTrim;
    34| /**
    35|  * Hazelcast client implementation of {@link javax.cache.spi.CachingProvider}.
    36|  * <p>
    37|  * Used internally by {@link com.hazelcast.cache.HazelcastCachingProvider} when
    38|  * the JCache type is configured as {@code client}.
    39|  * <p>
    40|  * This implementation creates a new singleton {@link HazelcastInstance}
    41|  * client. This instance is provided into the created managers.
    42|  * <p>
    43|  * If you need to use your already created HazelcastInstance, you can directly
    44|  * create a provider using
    45|  * {@link #createCachingProvider(com.hazelcast.core.HazelcastInstance)}.
    46|  *
    47|  * @see javax.cache.spi.CachingProvider
    48|  */
    49| public final class HazelcastClientCachingProvider extends AbstractHazelcastCachingProvider {
    50|     public HazelcastClientCachingProvider() {
    51|     }
    52|     /**
    53|      * Helper method for creating caching provider for testing etc.
    54|      */
    55|     public static HazelcastClientCachingProvider createCachingProvider(HazelcastInstance hazelcastInstance) {
    56|         HazelcastClientCachingProvider cachingProvider = new HazelcastClientCachingProvider();
    57|         cachingProvider.hazelcastInstance = hazelcastInstance;
    58|         return cachingProvider;
    59|     }
    60|     @Override
    61|     @SuppressWarnings("unchecked")
    62|     protected <T extends AbstractHazelcastCacheManager> T createCacheManager(HazelcastInstance instance, URI uri,
    63|                                                                              ClassLoader classLoader, Properties properties) {
    64|         return (T) new HazelcastClientCacheManager(this, instance, uri, classLoader, properties);
    65|     }
    66|     @Override
    67|     protected HazelcastInstance getOrCreateInstance(URI uri, ClassLoader classLoader, Properties properties)
    68|             throws URISyntaxException, IOException {
    69|         HazelcastInstance instanceItself = (HazelcastInstance) properties.get(HAZELCAST_INSTANCE_ITSELF);
    70|         if (instanceItself != null) {
    71|             return instanceItself;
    72|         }
    73|         String location = properties.getProperty(HAZELCAST_CONFIG_LOCATION);
    74|         String instanceName = properties.getProperty(HAZELCAST_INSTANCE_NAME);
    75|         if (location != null) {
    76|             ClientConfig config = getConfigFromLocation(location, classLoader, instanceName);
    77|             return getOrCreateInstanceByConfig(config);
    78|         }
    79|         if (instanceName != null) {
    80|             return getOrCreateByInstanceName(instanceName);
    81|         }
    82|         boolean isDefaultURI = (uri == null || uri.equals(getDefaultURI()));
    83|         if (!isDefaultURI) {
    84|             if (isConfigLocation(uri)) {
    85|                 try {
    86|                     ClientConfig config = getConfigFromLocation(uri, classLoader, null);
    87|                     return getOrCreateInstanceByConfig(config);
    88|                 } catch (Exception e) {
    89|                     if (LOGGER.isFinestEnabled()) {
    90|                         LOGGER.finest("Could not get or create Hazelcast instance from URI " + uri.toString(), e);
    91|                     }
    92|                 }
    93|             } else {
    94|                 try {
    95|                     return getOrCreateByInstanceName(uri.toString());
    96|                 } catch (Exception e) {
    97|                     if (LOGGER.isFinestEnabled()) {
    98|                         LOGGER.finest("Could not get Hazelcast instance from instance name " + uri.toString(), e);
    99|                     }
   100|                 }
   101|             }
   102|             return null;
   103|         } else {
   104|             return getDefaultInstance();
   105|         }
   106|     }
   107|     private HazelcastInstance getDefaultInstance() {
   108|         if (hazelcastInstance == null) {
   109|             ClientConfig clientConfig = getDefaultClientConfig();
   110|             if (isNullOrEmptyAfterTrim(clientConfig.getInstanceName())) {
   111|                 hazelcastInstance = HazelcastClient.newHazelcastClient();
   112|             } else {
   113|                 hazelcastInstance = getOrCreateInstanceByConfig(clientConfig);
   114|             }
   115|         }
   116|         return hazelcastInstance;
   117|     }
   118|     /**
   119|      * Gets an existing {@link HazelcastInstance} by {@code instanceName} or,
   120|      * if not found, creates a new {@link HazelcastInstance} with the default
   121|      * configuration and given {@code instanceName}.
   122|      *
   123|      * @param instanceName name to lookup an existing {@link HazelcastInstance}
   124|      *                     or to create a new one
   125|      * @return a {@link HazelcastInstance} with the given {@code instanceName}
   126|      */
   127|     private HazelcastInstance getOrCreateByInstanceName(String instanceName) {
   128|         HazelcastInstance instance = HazelcastClient.getHazelcastClientByName(instanceName);
   129|         if (instance == null) {
   130|             ClientConfig clientConfig = getDefaultClientConfig();
   131|             clientConfig.setInstanceName(instanceName);
   132|             instance = HazelcastClient.newHazelcastClient(clientConfig);
   133|         }
   134|         return instance;
   135|     }
   136|     private ClientConfig getDefaultClientConfig() {
   137|         ClientConfig clientConfig = new XmlClientConfigBuilder().build();
   138|         if (namedDefaultHzInstance && isNullOrEmpty(clientConfig.getInstanceName())) {
   139|             clientConfig.setInstanceName(SHARED_JCACHE_INSTANCE_NAME);
   140|         }
   141|         return clientConfig;
   142|     }
   143|     private ClientConfig getConfigFromLocation(String location, ClassLoader classLoader, String instanceName)
   144|             throws URISyntaxException, IOException {
   145|         URI uri = new URI(location);
   146|         return getConfigFromLocation(uri, classLoader, instanceName);
   147|     }
   148|     private ClientConfig getConfigFromLocation(URI location, ClassLoader classLoader, String instanceName)
   149|             throws URISyntaxException, IOException {
   150|         String scheme = location.getScheme();
   151|         if (scheme == null) {
   152|             location = new URI(System.getProperty(location.getRawSchemeSpecificPart()));
   153|             scheme = location.getScheme();
   154|         }
   155|         ClassLoader theClassLoader = classLoader == null ? getDefaultClassLoader() : classLoader;
   156|         URL configURL;
   157|         if ("classpath".equals(scheme)) {
   158|             configURL = theClassLoader.getResource(location.getRawSchemeSpecificPart());
   159|         } else if ("file".equals(scheme) || "http".equals(scheme) || "https".equals(scheme)) {
   160|             configURL = location.toURL();
   161|         } else {
   162|             throw new URISyntaxException(location.toString(), "Unsupported protocol in configuration location URL");
   163|         }
   164|         try {
   165|             return getConfig(configURL, theClassLoader, instanceName);
   166|         } catch (Exception e) {
   167|             throw rethrow(e);
   168|         }
   169|     }
   170|     private ClientConfig getConfig(URL configURL, ClassLoader theClassLoader, String instanceName) throws IOException {
   171|         ClientConfig config = new XmlClientConfigBuilder(configURL).build()
   172|                 .setClassLoader(theClassLoader);
   173|         if (instanceName != null) {
   174|             config.setInstanceName(instanceName);
   175|         } else if (config.getInstanceName() == null) {
   176|             config.setInstanceName(configURL.toString());
   177|         }
   178|         return config;
   179|     }
   180|     @Override
   181|     public String toString() {
   182|         return "HazelcastClientCachingProvider{hazelcastInstance=" + hazelcastInstance + '}';
   183|     }
   184|     private HazelcastInstance getOrCreateInstanceByConfig(ClientConfig config) {
   185|         HazelcastInstance instance = HazelcastClient.getHazelcastClientByName(config.getInstanceName());
   186|         if (instance == null) {
   187|             instance = HazelcastClient.newHazelcastClient(config);
   188|         }
   189|         return instance;
   190|     }
   191| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/NearCachedClientCacheProxy.java
# Total hunks: 5
# ====================================================================
# --- HUNK 1: Lines 26-66 ---
    26| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    27| import com.hazelcast.client.spi.impl.ListenerMessageCodec;
    28| import com.hazelcast.client.util.ClientDelegatingFuture;
    29| import com.hazelcast.config.CacheConfig;
    30| import com.hazelcast.config.InMemoryFormat;
    31| import com.hazelcast.config.NativeMemoryConfig;
    32| import com.hazelcast.config.NearCacheConfig;
    33| import com.hazelcast.core.ExecutionCallback;
    34| import com.hazelcast.internal.adapter.ICacheDataStructureAdapter;
    35| import com.hazelcast.internal.nearcache.NearCache;
    36| import com.hazelcast.internal.nearcache.NearCacheManager;
    37| import com.hazelcast.internal.nearcache.impl.invalidation.RepairingHandler;
    38| import com.hazelcast.internal.nearcache.impl.invalidation.RepairingTask;
    39| import com.hazelcast.logging.ILogger;
    40| import com.hazelcast.nio.serialization.Data;
    41| import com.hazelcast.spi.InternalCompletableFuture;
    42| import com.hazelcast.util.executor.CompletedFuture;
    43| import javax.cache.expiry.ExpiryPolicy;
    44| import javax.cache.integration.CompletionListener;
    45| import java.util.Collection;
    46| import java.util.HashSet;
    47| import java.util.Iterator;
    48| import java.util.LinkedList;
    49| import java.util.List;
    50| import java.util.Map;
    51| import java.util.Set;
    52| import java.util.UUID;
    53| import static com.hazelcast.config.InMemoryFormat.NATIVE;
    54| import static com.hazelcast.config.NearCacheConfig.LocalUpdatePolicy.CACHE;
    55| import static com.hazelcast.config.NearCacheConfig.LocalUpdatePolicy.CACHE_ON_UPDATE;
    56| import static com.hazelcast.instance.BuildInfo.calculateVersion;
    57| import static com.hazelcast.internal.nearcache.NearCache.CACHED_AS_NULL;
    58| import static com.hazelcast.internal.nearcache.NearCache.NOT_CACHED;
    59| import static com.hazelcast.internal.nearcache.NearCacheRecord.NOT_RESERVED;
    60| import static com.hazelcast.util.ExceptionUtil.rethrow;
    61| import static com.hazelcast.util.MapUtil.createHashMap;
    62| import static com.hazelcast.util.Preconditions.checkTrue;
    63| import static java.lang.String.format;
    64| /**
    65|  * An {@link ICacheInternal} implementation which handles Near Cache specific behaviour of methods.
    66|  *

# --- HUNK 2: Lines 256-336 ---
   256|         }
   257|     }
   258|     private void populateResultFromRemote(int currentSize, List<Object> resultingKeyValuePairs, Map<Object, Long> reservations,
   259|                                           Map<Data, Object> reverseKeyMap) {
   260|         for (int i = currentSize; i < resultingKeyValuePairs.size(); i += 2) {
   261|             Data keyData = (Data) resultingKeyValuePairs.get(i);
   262|             Data valueData = (Data) resultingKeyValuePairs.get(i + 1);
   263|             Object ncKey = serializeKeys ? keyData : reverseKeyMap.get(keyData);
   264|             if (!serializeKeys) {
   265|                 resultingKeyValuePairs.set(i, ncKey);
   266|             }
   267|             Long reservationId = reservations.get(ncKey);
   268|             if (reservationId != null) {
   269|                 Object cachedValue = tryPublishReserved(ncKey, valueData, reservationId);
   270|                 resultingKeyValuePairs.set(i + 1, cachedValue);
   271|                 reservations.remove(ncKey);
   272|             }
   273|         }
   274|     }
   275|     @Override
   276|     public void setExpiryPolicyInternal(Set<? extends K> keys, ExpiryPolicy expiryPolicy) {
   277|         Set<Data> serializedKeys = null;
   278|         if (serializeKeys) {
   279|             serializedKeys = new HashSet<Data>(keys.size());
   280|         }
   281|         super.setExpiryPolicyInternal(keys, expiryPolicy, serializedKeys);
   282|         invalidate(keys, serializedKeys);
   283|     }
   284|     @Override
   285|     protected boolean setExpiryPolicyInternal(K key, ExpiryPolicy expiryPolicy) {
   286|         boolean result = super.setExpiryPolicyInternal(key, expiryPolicy);
   287|         if (serializeKeys) {
   288|             invalidateNearCache(toData(key));
   289|         } else {
   290|             invalidateNearCache(key);
   291|         }
   292|         return result;
   293|     }
   294|     @Override
   295|     protected void putAllInternal(Map<? extends K, ? extends V> map, ExpiryPolicy expiryPolicy, Map<Object, Data> keyMap,
   296|                                   List<Map.Entry<Data, Data>>[] entriesPerPartition, long startNanos) {
   297|         try {
   298|             if (!serializeKeys) {
   299|                 keyMap = createHashMap(map.size());
   300|             }
   301|             super.putAllInternal(map, expiryPolicy, keyMap, entriesPerPartition, startNanos);
   302|             cacheOrInvalidate(map, keyMap, entriesPerPartition, true);
   303|         } catch (Throwable t) {
   304|             cacheOrInvalidate(map, keyMap, entriesPerPartition, false);
   305|             throw rethrow(t);
   306|         }
   307|     }
   308|     private void invalidate(Set<? extends K> keys, Set<Data> keysData) {
   309|         if (serializeKeys) {
   310|             for (Data key: keysData) {
   311|                 invalidateNearCache(key);
   312|             }
   313|         } else {
   314|             for (K key: keys) {
   315|                 invalidateNearCache(key);
   316|             }
   317|         }
   318|     }
   319|     private void cacheOrInvalidate(Map<? extends K, ? extends V> map, Map<Object, Data> keyMap,
   320|                                    List<Map.Entry<Data, Data>>[] entriesPerPartition, boolean isCacheOrInvalidate) {
   321|         if (serializeKeys) {
   322|             for (int partitionId = 0; partitionId < entriesPerPartition.length; partitionId++) {
   323|                 List<Map.Entry<Data, Data>> entries = entriesPerPartition[partitionId];
   324|                 if (entries != null) {
   325|                     for (Map.Entry<Data, Data> entry : entries) {
   326|                         Data key = entry.getKey();
   327|                         if (isCacheOrInvalidate) {
   328|                             cacheOrInvalidate(key, key, null, entry.getValue());
   329|                         } else {
   330|                             invalidateNearCache(key);
   331|                         }
   332|                     }
   333|                 }
   334|             }
   335|         } else {
   336|             for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {

# --- HUNK 3: Lines 443-524 ---
   443|     }
   444|     private Object getCachedValue(Object key, boolean deserializeValue) {
   445|         Object cached = nearCache.get(key);
   446|         assert cached != CACHED_AS_NULL;
   447|         if (cached == null) {
   448|             return NOT_CACHED;
   449|         }
   450|         return deserializeValue ? toObject(cached) : cached;
   451|     }
   452|     @SuppressWarnings("unchecked")
   453|     private void cacheOrInvalidate(Object key, Data keyData, V value, Data valueData) {
   454|         if (cacheOnUpdate) {
   455|             V valueToStore = (V) nearCache.selectToSave(valueData, value);
   456|             nearCache.put(key, keyData, valueToStore);
   457|         } else {
   458|             invalidateNearCache(key);
   459|         }
   460|     }
   461|     private void invalidateNearCache(Object key) {
   462|         assert key != null;
   463|         nearCache.invalidate(key);
   464|     }
   465|     private long tryReserveForUpdate(Object key, Data keyData) {
   466|         return nearCache.tryReserveForUpdate(key, keyData);
   467|     }
   468|     /**
   469|      * Publishes value got from remote or deletes reserved record when remote value is {@code null}.
   470|      *
   471|      * @param key           key to update in Near Cache
   472|      * @param remoteValue   fetched value from server
   473|      * @param reservationId reservation ID for this key
   474|      * @param deserialize   deserialize returned value
   475|      * @return last known value for the key
   476|      */
   477|     private Object tryPublishReserved(Object key, Object remoteValue, long reservationId, boolean deserialize) {
   478|         assert remoteValue != NOT_CACHED;
   479|         if (remoteValue == null) {
   480|             invalidateNearCache(key);
   481|             return null;
   482|         }
   483|         Object cachedValue = null;
   484|         if (reservationId != NOT_RESERVED) {
   485|             cachedValue = nearCache.tryPublishReserved(key, remoteValue, reservationId, deserialize);
   486|         }
   487|         return cachedValue == null ? remoteValue : cachedValue;
   488|     }
   489|     private Object tryPublishReserved(Object key, Object remoteValue, long reservationId) {
   490|         return tryPublishReserved(key, remoteValue, reservationId, true);
   491|     }
   492|     private void releaseRemainingReservedKeys(Map<Object, Long> reservedKeys) {
   493|         for (Object key : reservedKeys.keySet()) {
   494|             nearCache.invalidate(key);
   495|         }
   496|     }
   497|     public String addNearCacheInvalidationListener(EventHandler eventHandler) {
   498|         return registerListener(createInvalidationListenerCodec(), eventHandler);
   499|     }
   500|     private void registerInvalidationListener() {
   501|         if (!invalidateOnChange) {
   502|             return;
   503|         }
   504|         EventHandler eventHandler = new NearCacheInvalidationEventHandler();
   505|         nearCacheMembershipRegistrationId = addNearCacheInvalidationListener(eventHandler);
   506|     }
   507|     private ListenerMessageCodec createInvalidationListenerCodec() {
   508|         return new ListenerMessageCodec() {
   509|             @Override
   510|             public ClientMessage encodeAddRequest(boolean localOnly) {
   511|                 if (supportsRepairableNearCache()) {
   512|                     return CacheAddNearCacheInvalidationListenerCodec.encodeRequest(nameWithPrefix, localOnly);
   513|                 }
   514|                 return CacheAddInvalidationListenerCodec.encodeRequest(nameWithPrefix, localOnly);
   515|             }
   516|             @Override
   517|             public String decodeAddResponse(ClientMessage clientMessage) {
   518|                 if (supportsRepairableNearCache()) {
   519|                     return CacheAddNearCacheInvalidationListenerCodec.decodeResponse(clientMessage).response;
   520|                 }
   521|                 return CacheAddInvalidationListenerCodec.decodeResponse(clientMessage).response;
   522|             }
   523|             @Override
   524|             public ClientMessage encodeRemoveRequest(String realRegistrationId) {

# --- HUNK 4: Lines 673-771 ---
   673|             try {
   674|                 if (callback != null) {
   675|                     callback.onResponse(response);
   676|                 }
   677|             } finally {
   678|                 invalidateNearCache(key);
   679|             }
   680|         }
   681|         @Override
   682|         public void onFailure(Throwable t) {
   683|             try {
   684|                 if (callback != null) {
   685|                     callback.onFailure(t);
   686|                 }
   687|             } finally {
   688|                 invalidateNearCache(key);
   689|             }
   690|         }
   691|     }
   692|     /**
   693|      * Eventual consistency for Near Cache can be used with server versions >= 3.8
   694|      * For repairing functionality please see {@link RepairingHandler}
   695|      * handleCacheInvalidationEventV14 and handleCacheBatchInvalidationEventV14
   696|      *
   697|      * If server version is < 3.8 and client version is >= 3.8, eventual consistency is not supported
   698|      * Following methods handle the old behaviour:
   699|      * handleCacheBatchInvalidationEventV10 and handleCacheInvalidationEventV10
   700|      */
   701|     private final class NearCacheInvalidationEventHandler
   702|             extends CacheAddInvalidationListenerCodec.AbstractEventHandler
   703|             implements EventHandler<ClientMessage> {
   704|         private String clientUuid;
   705|         private volatile RepairingHandler repairingHandler;
   706|         private volatile boolean supportsRepairableNearCache;
   707|         private NearCacheInvalidationEventHandler() {
   708|             this.clientUuid = getContext().getClusterService().getLocalClient().getUuid();
   709|         }
   710|         @Override
   711|         public void beforeListenerRegister() {
   712|             supportsRepairableNearCache = supportsRepairableNearCache();
   713|             if (supportsRepairableNearCache) {
   714|                 RepairingTask repairingTask = getContext().getRepairingTask(getServiceName());
   715|                 repairingHandler = repairingTask.registerAndGetHandler(nameWithPrefix, nearCache);
   716|             } else {
   717|                 RepairingTask repairingTask = getContext().getRepairingTask(getServiceName());
   718|                 repairingTask.deregisterHandler(nameWithPrefix);
   719|                 logger.warning(format("Near Cache for '%s' cache is started in legacy mode", name));
   720|             }
   721|         }
   722|         @Override
   723|         public void onListenerRegister() {
   724|             if (!supportsRepairableNearCache) {
   725|                 nearCache.clear();
   726|             }
   727|         }
   728|         @Override
   729|         public void handleCacheInvalidationEventV10(String name, Data key, String sourceUuid) {
   730|             if (clientUuid.equals(sourceUuid)) {
   731|                 return;
   732|             }
   733|             if (key != null) {
   734|                 nearCache.invalidate(serializeKeys ? key : toObject(key));
   735|             } else {
   736|                 nearCache.clear();
   737|             }
   738|         }
   739|         @Override
   740|         public void handleCacheInvalidationEventV14(String name, Data key, String sourceUuid,
   741|                                                     UUID partitionUuid, long sequence) {
   742|             repairingHandler.handle(key, sourceUuid, partitionUuid, sequence);
   743|         }
   744|         @Override
   745|         public void handleCacheBatchInvalidationEventV10(String name, Collection<Data> keys,
   746|                                                          Collection<String> sourceUuids) {
   747|             if (sourceUuids != null && !sourceUuids.isEmpty()) {
   748|                 Iterator<Data> keysIt = keys.iterator();
   749|                 Iterator<String> sourceUuidsIt = sourceUuids.iterator();
   750|                 while (keysIt.hasNext() && sourceUuidsIt.hasNext()) {
   751|                     Data key = keysIt.next();
   752|                     String sourceUuid = sourceUuidsIt.next();
   753|                     if (!clientUuid.equals(sourceUuid)) {
   754|                         nearCache.invalidate(serializeKeys ? key : toObject(key));
   755|                     }
   756|                 }
   757|             } else {
   758|                 for (Data key : keys) {
   759|                     nearCache.invalidate(serializeKeys ? key : toObject(key));
   760|                 }
   761|             }
   762|         }
   763|         @Override
   764|         public void handleCacheBatchInvalidationEventV14(String name, Collection<Data> keys,
   765|                                                          Collection<String> sourceUuids,
   766|                                                          Collection<UUID> partitionUuids,
   767|                                                          Collection<Long> sequences) {
   768|             repairingHandler.handle(keys, sourceUuids, partitionUuids, sequences);
   769|         }
   770|     }
   771| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/cache/impl/nearcache/invalidation/ClientCacheInvalidationMetaDataFetcher.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-62 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.cache.impl.nearcache.invalidation;
    17| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.codec.CacheFetchNearCacheInvalidationMetadataCodec.ResponseParameters;
    20| import com.hazelcast.client.spi.ClientClusterService;
    21| import com.hazelcast.client.spi.ClientContext;
    22| import com.hazelcast.client.spi.impl.ClientInvocation;
    23| import com.hazelcast.core.Member;
    24| import com.hazelcast.internal.nearcache.impl.invalidation.InvalidationMetaDataFetcher;
    25| import com.hazelcast.nio.Address;
    26| import com.hazelcast.spi.InternalCompletableFuture;
    27| import java.util.Collection;
    28| import java.util.List;
    29| import static com.hazelcast.client.impl.protocol.codec.CacheFetchNearCacheInvalidationMetadataCodec.decodeResponse;
    30| import static com.hazelcast.client.impl.protocol.codec.CacheFetchNearCacheInvalidationMetadataCodec.encodeRequest;
    31| import static com.hazelcast.cluster.memberselector.MemberSelectors.DATA_MEMBER_SELECTOR;
    32| import static java.util.concurrent.TimeUnit.MINUTES;
    33| /**
    34|  * {@code InvalidationMetaDataFetcher} for client side usage
    35|  */
    36| public class ClientCacheInvalidationMetaDataFetcher extends InvalidationMetaDataFetcher {
    37|     private final ClientClusterService clusterService;
    38|     private final HazelcastClientInstanceImpl clientImpl;
    39|     public ClientCacheInvalidationMetaDataFetcher(ClientContext clientContext) {
    40|         super(clientContext.getLoggingService().getLogger(ClientCacheInvalidationMetaDataFetcher.class));
    41|         this.clusterService = clientContext.getClusterService();
    42|         this.clientImpl = (HazelcastClientInstanceImpl) clientContext.getHazelcastInstance();
    43|     }
    44|     @Override
    45|     protected Collection<Member> getDataMembers() {
    46|         return clusterService.getMembers(DATA_MEMBER_SELECTOR);
    47|     }
    48|     @Override
    49|     protected InternalCompletableFuture fetchMetadataOf(Address address, List<String> names) {
    50|         ClientMessage message = encodeRequest(names, address);
    51|         ClientInvocation invocation = new ClientInvocation(clientImpl, message, null, address);
    52|         return invocation.invoke();
    53|     }
    54|     @Override
    55|     protected void extractMemberMetadata(Member member,
    56|                                          InternalCompletableFuture future,
    57|                                          MetadataHolder metadataHolder) throws Exception {
    58|         ClientMessage message = ((ClientMessage) future.get(ASYNC_RESULT_WAIT_TIMEOUT_MINUTES, MINUTES));
    59|         ResponseParameters response = decodeResponse(message);
    60|         metadataHolder.setMetadata(response.partitionUuidList, response.namePartitionSequenceList);
    61|     }
    62| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/config/ClientAliasedDiscoveryConfigUtils.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-71 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.config;
    17| import com.hazelcast.config.AliasedDiscoveryConfig;
    18| import com.hazelcast.config.AliasedDiscoveryConfigUtils;
    19| import com.hazelcast.config.DiscoveryStrategyConfig;
    20| import com.hazelcast.config.InvalidConfigurationException;
    21| import java.util.List;
    22| import static java.util.Arrays.asList;
    23| /**
    24|  * Utility class for Aliased Discovery Configs in Hazelcast Client.
    25|  */
    26| public final class ClientAliasedDiscoveryConfigUtils {
    27|     private ClientAliasedDiscoveryConfigUtils() {
    28|     }
    29|     /**
    30|      * Extracts aliased discovery configs from {@code config} and creates a list of {@link DiscoveryStrategyConfig} out of them.
    31|      */
    32|     public static List<DiscoveryStrategyConfig> createDiscoveryStrategyConfigs(ClientConfig config) {
    33|         return AliasedDiscoveryConfigUtils.map(aliasedDiscoveryConfigsFrom(config));
    34|     }
    35|     /**
    36|      * Gets the {@link AliasedDiscoveryConfig} from {@code config} by {@code tag}.
    37|      */
    38|     public static AliasedDiscoveryConfig getConfigByTag(ClientNetworkConfig config, String tag) {
    39|         if ("aws".equals(tag)) {
    40|             return config.getAwsConfig();
    41|         } else if ("gcp".equals(tag)) {
    42|             return config.getGcpConfig();
    43|         } else if ("azure".equals(tag)) {
    44|             return config.getAzureConfig();
    45|         } else if ("kubernetes".equals(tag)) {
    46|             return config.getKubernetesConfig();
    47|         } else if ("eureka".equals(tag)) {
    48|             return config.getEurekaConfig();
    49|         } else {
    50|             throw new InvalidConfigurationException(String.format("Invalid configuration tag: '%s'", tag));
    51|         }
    52|     }
    53|     /**
    54|      * Gets a list of all aliased discovery configs from {@code config}.
    55|      */
    56|     public static List<AliasedDiscoveryConfig<?>> aliasedDiscoveryConfigsFrom(ClientConfig config) {
    57|         ClientNetworkConfig networkConfig = config.getNetworkConfig();
    58|         return asList(networkConfig.getAwsConfig(), networkConfig.getGcpConfig(), networkConfig.getAzureConfig(),
    59|                 networkConfig.getKubernetesConfig(), networkConfig.getEurekaConfig());
    60|     }
    61|     /**
    62|      * Creates new {@link AliasedDiscoveryConfig} by the given {@code tag}.
    63|      */
    64|     public static AliasedDiscoveryConfig newAliasedDiscoveryConfig(String name) {
    65|         if ("aws".equals(name)) {
    66|             return new ClientAwsConfig();
    67|         } else {
    68|             return AliasedDiscoveryConfigUtils.newConfigFor(name);
    69|         }
    70|     }
    71| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/config/ClientAwsConfig.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-67 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.config;
    17| import com.hazelcast.config.AwsConfig;
    18| /**
    19|  * The AWSConfig contains the configuration for client to connect to nodes in aws environment.
    20|  *
    21|  * @deprecated Use {@link AwsConfig} instead.
    22|  */
    23| @Deprecated
    24| public class ClientAwsConfig
    25|         extends AwsConfig {
    26|     private static final String INSIDE_AWS_PROPERTY = "inside-aws";
    27|     /**
    28|      * If client is inside aws, it will use private ip addresses directly,
    29|      * otherwise it will convert private ip addresses to public addresses
    30|      * internally by calling AWS API.
    31|      *
    32|      * @return boolean true if client is inside aws environment.
    33|      */
    34|     @Deprecated
    35|     public boolean isInsideAws() {
    36|         return !isUsePublicIp();
    37|     }
    38|     /**
    39|      * Set to true if client is inside aws environment
    40|      * Default value is false.
    41|      *
    42|      * @param insideAws isInsideAws
    43|      */
    44|     @Deprecated
    45|     public ClientAwsConfig setInsideAws(boolean insideAws) {
    46|         setUsePublicIp(!insideAws);
    47|         return this;
    48|     }
    49|     /**
    50|      * Sets the property understood by the AWS SPI Discovery Strategy.
    51|      * <p>
    52|      * Note that it interprets the "inside-aws" property and maps it to the contrary of the generic "use-public-ip" property.
    53|      *
    54|      * @param name  property name
    55|      * @param value property value
    56|      * @return the updated Client Aws Config
    57|      */
    58|     @Override
    59|     public ClientAwsConfig setProperty(String name, String value) {
    60|         if (INSIDE_AWS_PROPERTY.equals(name)) {
    61|             setInsideAws(Boolean.parseBoolean(value));
    62|         } else {
    63|             super.setProperty(name, value);
    64|         }
    65|         return this;
    66|     }
    67| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/config/ClientCloudConfig.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-53 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.config;
    17| /**
    18|  * hazelcast.cloud configuration to let the client connect the cluster via hazelcast.cloud
    19|  */
    20| public class ClientCloudConfig {
    21|     private String discoveryToken;
    22|     private boolean enabled;
    23|     /**
    24|      * hazelcast.cloud discoveryToken of your cluster
    25|      *
    26|      * @return discoveryToken
    27|      */
    28|     public String getDiscoveryToken() {
    29|         return discoveryToken;
    30|     }
    31|     /**
    32|      * @param discoveryToken hazelcast.cloud discoveryToken of your cluster
    33|      * @return configured {@link com.hazelcast.client.config.ClientCloudConfig} for chaining
    34|      */
    35|     public ClientCloudConfig setDiscoveryToken(String discoveryToken) {
    36|         this.discoveryToken = discoveryToken;
    37|         return this;
    38|     }
    39|     /**
    40|      * @return true if enabled, false otherwise
    41|      */
    42|     public boolean isEnabled() {
    43|         return enabled;
    44|     }
    45|     /**
    46|      * @param enabled true to use hazelcast.cloud
    47|      * @return configured {@link com.hazelcast.client.config.ClientCloudConfig} for chaining
    48|      */
    49|     public ClientCloudConfig setEnabled(boolean enabled) {
    50|         this.enabled = enabled;
    51|         return this;
    52|     }
    53| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/config/ClientConfig.java
# Total hunks: 5
# ====================================================================
# --- HUNK 1: Lines 20-60 ---
    20| import com.hazelcast.config.GroupConfig;
    21| import com.hazelcast.config.ListenerConfig;
    22| import com.hazelcast.config.NativeMemoryConfig;
    23| import com.hazelcast.config.NearCacheConfig;
    24| import com.hazelcast.config.QueryCacheConfig;
    25| import com.hazelcast.config.SerializationConfig;
    26| import com.hazelcast.config.SocketInterceptorConfig;
    27| import com.hazelcast.config.matcher.MatchingPointConfigPatternMatcher;
    28| import com.hazelcast.core.ManagedContext;
    29| import com.hazelcast.flakeidgen.FlakeIdGenerator;
    30| import com.hazelcast.logging.ILogger;
    31| import com.hazelcast.logging.Logger;
    32| import com.hazelcast.security.Credentials;
    33| import java.util.HashMap;
    34| import java.util.LinkedList;
    35| import java.util.List;
    36| import java.util.Map;
    37| import java.util.Map.Entry;
    38| import java.util.Properties;
    39| import java.util.concurrent.ConcurrentHashMap;
    40| import java.util.concurrent.ConcurrentMap;
    41| import static com.hazelcast.config.NearCacheConfigAccessor.initDefaultMaxSizeForOnHeapMaps;
    42| import static com.hazelcast.internal.config.ConfigUtils.lookupByPattern;
    43| import static com.hazelcast.partition.strategy.StringPartitioningStrategy.getBaseName;
    44| import static com.hazelcast.util.Preconditions.checkFalse;
    45| /**
    46|  * Main configuration to setup a Hazelcast Client
    47|  */
    48| public class ClientConfig {
    49|     private static final ILogger LOGGER = Logger.getLogger(ClientConfig.class);
    50|     /**
    51|      * To pass properties
    52|      */
    53|     private Properties properties = new Properties();
    54|     /**
    55|      * The Group Configuration properties like:
    56|      * Name and Password that is used to connect to the cluster.
    57|      */
    58|     private GroupConfig groupConfig = new GroupConfig();
    59|     /**
    60|      * The Security Configuration for custom Credentials:

# --- HUNK 2: Lines 78-118 ---
    78|     /**
    79|      * pool-size for internal ExecutorService which handles responses etc.
    80|      */
    81|     private int executorPoolSize = -1;
    82|     private String instanceName;
    83|     private ConfigPatternMatcher configPatternMatcher = new MatchingPointConfigPatternMatcher();
    84|     private final Map<String, NearCacheConfig> nearCacheConfigMap = new ConcurrentHashMap<String, NearCacheConfig>();
    85|     private final Map<String, ClientReliableTopicConfig> reliableTopicConfigMap
    86|             = new ConcurrentHashMap<String, ClientReliableTopicConfig>();
    87|     private Map<String, Map<String, QueryCacheConfig>> queryCacheConfigs;
    88|     private SerializationConfig serializationConfig = new SerializationConfig();
    89|     private NativeMemoryConfig nativeMemoryConfig = new NativeMemoryConfig();
    90|     private final List<ProxyFactoryConfig> proxyFactoryConfigs = new LinkedList<ProxyFactoryConfig>();
    91|     private ManagedContext managedContext;
    92|     private ClassLoader classLoader;
    93|     private String licenseKey;
    94|     private ClientConnectionStrategyConfig connectionStrategyConfig = new ClientConnectionStrategyConfig();
    95|     private ClientUserCodeDeploymentConfig userCodeDeploymentConfig = new ClientUserCodeDeploymentConfig();
    96|     private final Map<String, ClientFlakeIdGeneratorConfig> flakeIdGeneratorConfigMap =
    97|             new ConcurrentHashMap<String, ClientFlakeIdGeneratorConfig>();
    98|     private ConcurrentMap<String, Object> userContext = new ConcurrentHashMap<String, Object>();
    99|     /**
   100|      * Sets the pattern matcher which is used to match item names to
   101|      * configuration objects.
   102|      * By default the {@link MatchingPointConfigPatternMatcher} is used.
   103|      *
   104|      * @param configPatternMatcher the pattern matcher
   105|      * @throws IllegalArgumentException if the pattern matcher is {@code null}
   106|      */
   107|     public void setConfigPatternMatcher(ConfigPatternMatcher configPatternMatcher) {
   108|         if (configPatternMatcher == null) {
   109|             throw new IllegalArgumentException("ConfigPatternMatcher is not allowed to be null!");
   110|         }
   111|         this.configPatternMatcher = configPatternMatcher;
   112|     }
   113|     /**
   114|      * Returns the pattern matcher which is used to match item names to
   115|      * configuration objects.
   116|      * By default the {@link MatchingPointConfigPatternMatcher} is used.
   117|      *
   118|      * @return the pattern matcher

# --- HUNK 3: Lines 397-462 ---
   397|         flakeIdGeneratorConfigMap.put(config.getName(), config);
   398|         return this;
   399|     }
   400|     /**
   401|      * Sets the map of {@link FlakeIdGenerator} configurations,
   402|      * mapped by config name. The config name may be a pattern with which the
   403|      * configuration will be obtained in the future.
   404|      *
   405|      * @param map the FlakeIdGenerator configuration map to set
   406|      * @return this config instance
   407|      */
   408|     public ClientConfig setFlakeIdGeneratorConfigMap(Map<String, ClientFlakeIdGeneratorConfig> map) {
   409|         flakeIdGeneratorConfigMap.clear();
   410|         flakeIdGeneratorConfigMap.putAll(map);
   411|         for (Entry<String, ClientFlakeIdGeneratorConfig> entry : map.entrySet()) {
   412|             entry.getValue().setName(entry.getKey());
   413|         }
   414|         return this;
   415|     }
   416|     /**
   417|      * Sets the map of {@link ClientReliableTopicConfig},
   418|      * mapped by config name. The config name may be a pattern with which the
   419|      * configuration will be obtained in the future.
   420|      *
   421|      * @param map the FlakeIdGenerator configuration map to set
   422|      * @return this config instance
   423|      */
   424|     public ClientConfig setReliableTopicConfigMap(Map<String, ClientReliableTopicConfig> map) {
   425|         reliableTopicConfigMap.clear();
   426|         reliableTopicConfigMap.putAll(map);
   427|         for (Entry<String, ClientReliableTopicConfig> entry : map.entrySet()) {
   428|             entry.getValue().setName(entry.getKey());
   429|         }
   430|         return this;
   431|     }
   432|     /**
   433|      * Returns the map of reliable topic configurations,
   434|      * mapped by config name. The config name may be a pattern with which the
   435|      * configuration was initially obtained.
   436|      *
   437|      * @return the map configurations mapped by config name
   438|      */
   439|     public Map<String, ClientReliableTopicConfig> getReliableTopicConfigMap() {
   440|         return reliableTopicConfigMap;
   441|     }
   442|     /**
   443|      * Use {@link ClientNetworkConfig#isSmartRouting} instead
   444|      */
   445|     @Deprecated
   446|     public boolean isSmartRouting() {
   447|         return networkConfig.isSmartRouting();
   448|     }
   449|     /**
   450|      * Use {@link ClientNetworkConfig#setSmartRouting} instead
   451|      */
   452|     @Deprecated
   453|     public ClientConfig setSmartRouting(boolean smartRouting) {
   454|         networkConfig.setSmartRouting(smartRouting);
   455|         return this;
   456|     }
   457|     /**
   458|      * Use {@link ClientNetworkConfig#getSocketInterceptorConfig} instead
   459|      */
   460|     @Deprecated
   461|     public SocketInterceptorConfig getSocketInterceptorConfig() {
   462|         return networkConfig.getSocketInterceptorConfig();

# --- HUNK 4: Lines 737-776 ---
   737|      * @return configured {@link com.hazelcast.client.config.ClientConfig} for chaining
   738|      * @see com.hazelcast.config.SerializationConfig
   739|      */
   740|     public ClientConfig setSerializationConfig(SerializationConfig serializationConfig) {
   741|         this.serializationConfig = serializationConfig;
   742|         return this;
   743|     }
   744|     public NativeMemoryConfig getNativeMemoryConfig() {
   745|         return nativeMemoryConfig;
   746|     }
   747|     public ClientConfig setNativeMemoryConfig(NativeMemoryConfig nativeMemoryConfig) {
   748|         this.nativeMemoryConfig = nativeMemoryConfig;
   749|         return this;
   750|     }
   751|     public String getLicenseKey() {
   752|         return licenseKey;
   753|     }
   754|     /**
   755|      * @deprecated As of Hazelcast 3.10.3, enterprise license keys are required only for members, and not for clients
   756|      */
   757|     public ClientConfig setLicenseKey(final String licenseKey) {
   758|         this.licenseKey = licenseKey;
   759|         return this;
   760|     }
   761|     public ClientConfig addQueryCacheConfig(String mapName, QueryCacheConfig queryCacheConfig) {
   762|         Map<String, Map<String, QueryCacheConfig>> queryCacheConfigsPerMap = getQueryCacheConfigs();
   763|         String queryCacheName = queryCacheConfig.getName();
   764|         Map<String, QueryCacheConfig> queryCacheConfigs = queryCacheConfigsPerMap.get(mapName);
   765|         if (queryCacheConfigs != null) {
   766|             checkFalse(queryCacheConfigs.containsKey(queryCacheName),
   767|                     "A query cache already exists with name = [" + queryCacheName + ']');
   768|         } else {
   769|             queryCacheConfigs = new ConcurrentHashMap<String, QueryCacheConfig>();
   770|             queryCacheConfigsPerMap.put(mapName, queryCacheConfigs);
   771|         }
   772|         queryCacheConfigs.put(queryCacheName, queryCacheConfig);
   773|         return this;
   774|     }
   775|     public Map<String, Map<String, QueryCacheConfig>> getQueryCacheConfigs() {
   776|         if (queryCacheConfigs == null) {

# --- HUNK 5: Lines 832-862 ---
   832|             queryCacheConfig = new QueryCacheConfig(cacheName);
   833|             queryCacheConfigsForMap.put(cacheName, queryCacheConfig);
   834|         }
   835|         return queryCacheConfig;
   836|     }
   837|     /**
   838|      * @param mapName   The name of the map for which the query cache config is to be returned.
   839|      * @param cacheName The name of the query cache.
   840|      * @return The query cache config. If no such config exist null is returned.
   841|      */
   842|     public QueryCacheConfig getOrNullQueryCacheConfig(String mapName, String cacheName) {
   843|         if (queryCacheConfigs == null) {
   844|             return null;
   845|         }
   846|         Map<String, QueryCacheConfig> queryCacheConfigsForMap = lookupByPattern(configPatternMatcher, queryCacheConfigs, mapName);
   847|         if (queryCacheConfigsForMap == null) {
   848|             return null;
   849|         }
   850|         return lookupByPattern(configPatternMatcher, queryCacheConfigsForMap, cacheName);
   851|     }
   852|     public ClientConfig setUserContext(ConcurrentMap<String, Object> userContext) {
   853|         if (userContext == null) {
   854|             throw new IllegalArgumentException("userContext can't be null");
   855|         }
   856|         this.userContext = userContext;
   857|         return this;
   858|     }
   859|     public ConcurrentMap<String, Object> getUserContext() {
   860|         return userContext;
   861|     }
   862| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/config/ClientConnectionStrategyConfig.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 22-104 ---
    22|     /**
    23|      * Reconnect options.
    24|      */
    25|     public enum ReconnectMode {
    26|         /**
    27|          * Prevent reconnect to cluster after a disconnect
    28|          */
    29|         OFF,
    30|         /**
    31|          * Reconnect to cluster by blocking invocations
    32|          */
    33|         ON,
    34|         /**
    35|          * Reconnect to cluster without blocking invocations. Invocations will receive
    36|          * {@link com.hazelcast.client.HazelcastClientOfflineException }
    37|          */
    38|         ASYNC
    39|     }
    40|     private boolean asyncStart;
    41|     private ReconnectMode reconnectMode = ReconnectMode.ON;
    42|     private ConnectionRetryConfig connectionRetryConfig = new ConnectionRetryConfig();
    43|     /**
    44|      * Client instance creation won't block on {@link HazelcastClient#newHazelcastClient()} if this value is true
    45|      *
    46|      * @return if client connects to cluster asynchronously
    47|      */
    48|     public boolean isAsyncStart() {
    49|         return asyncStart;
    50|     }
    51|     /**
    52|      * Set true for non blocking {@link HazelcastClient#newHazelcastClient()}. The client creation won't wait to
    53|      * connect to cluster. The client instace will throw exception until it connects to cluster and become ready.
    54|      * If set to false, {@link HazelcastClient#newHazelcastClient()} will block until a cluster connection established and it's
    55|      * ready to use client instance
    56|      *
    57|      * default value is false
    58|      *
    59|      * @param asyncStart true for async client creation
    60|      * @return the updated ClientConnectionStrategyConfig
    61|      */
    62|     public ClientConnectionStrategyConfig setAsyncStart(boolean asyncStart) {
    63|         this.asyncStart = asyncStart;
    64|         return this;
    65|     }
    66|     /**
    67|      * @return reconnect mode
    68|      */
    69|     public ReconnectMode getReconnectMode() {
    70|         return reconnectMode;
    71|     }
    72|     /**
    73|      * How a client reconnect to cluster after a disconnect can be configured. This parameter is used by default strategy and
    74|      * custom implementations may ignore it if configured.
    75|      * default value is {@link ReconnectMode#ON}
    76|      *
    77|      * @param reconnectMode
    78|      * @return the updated ClientConnectionStrategyConfig
    79|      */
    80|     public ClientConnectionStrategyConfig setReconnectMode(ReconnectMode reconnectMode) {
    81|         this.reconnectMode = reconnectMode;
    82|         return this;
    83|     }
    84|     /**
    85|      * Connection Retry Config is controls the period among the retries and when should a client gave up
    86|      * retrying. Exponential behaviour can be chosen or jitter can be added to wait periods.
    87|      *
    88|      * @return connection retry config
    89|      */
    90|     public ConnectionRetryConfig getConnectionRetryConfig() {
    91|         return connectionRetryConfig;
    92|     }
    93|     /**
    94|      * Connection Retry Config is controls the period among the retries and when should a client gave up
    95|      * retrying. Exponential behaviour can be chosen or jitter can be added to wait periods.
    96|      *
    97|      * @param connectionRetryConfig
    98|      * @return the updated ClientConnectionStrategyConfig
    99|      */
   100|     public ClientConnectionStrategyConfig setConnectionRetryConfig(ConnectionRetryConfig connectionRetryConfig) {
   101|         this.connectionRetryConfig = connectionRetryConfig;
   102|         return this;
   103|     }
   104| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/config/ClientNetworkConfig.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-71 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.config;
    17| import com.hazelcast.config.AzureConfig;
    18| import com.hazelcast.config.DiscoveryConfig;
    19| import com.hazelcast.config.EurekaConfig;
    20| import com.hazelcast.config.GcpConfig;
    21| import com.hazelcast.config.KubernetesConfig;
    22| import com.hazelcast.config.SSLConfig;
    23| import com.hazelcast.config.SocketInterceptorConfig;
    24| import java.util.ArrayList;
    25| import java.util.Collection;
    26| import java.util.Collections;
    27| import java.util.HashSet;
    28| import java.util.List;
    29| import static com.hazelcast.util.Preconditions.checkHasText;
    30| import static com.hazelcast.util.Preconditions.isNotNull;
    31| /**
    32|  * Contains configuration parameters for client network related behaviour
    33|  */
    34| public class ClientNetworkConfig {
    35|     private static final int CONNECTION_TIMEOUT = 5000;
    36|     private static final int CONNECTION_ATTEMPT_PERIOD = 3000;
    37|     private final List<String> addressList = new ArrayList<String>(10);
    38|     private boolean smartRouting = true;
    39|     private boolean redoOperation;
    40|     private int connectionTimeout = CONNECTION_TIMEOUT;
    41|     private int connectionAttemptLimit = -1;
    42|     private int connectionAttemptPeriod = CONNECTION_ATTEMPT_PERIOD;
    43|     private SocketInterceptorConfig socketInterceptorConfig;
    44|     private SocketOptions socketOptions = new SocketOptions();
    45|     private SSLConfig sslConfig;
    46|     private ClientAwsConfig awsConfig = new ClientAwsConfig();
    47|     private GcpConfig gcpConfig = new GcpConfig();
    48|     private AzureConfig azureConfig = new AzureConfig();
    49|     private KubernetesConfig kubernetesConfig = new KubernetesConfig();
    50|     private EurekaConfig eurekaConfig = new EurekaConfig();
    51|     private ClientCloudConfig cloudConfig = new ClientCloudConfig();
    52|     private DiscoveryConfig discoveryConfig;
    53|     private Collection<String> outboundPortDefinitions;
    54|     private Collection<Integer> outboundPorts;
    55|     private ClientIcmpPingConfig clientIcmpPingConfig = new ClientIcmpPingConfig();
    56|     /**
    57|      * Returns the configuration of the Hazelcast Discovery SPI and configured discovery providers
    58|      *
    59|      * @return Discovery Provider SPI configuration
    60|      */
    61|     public DiscoveryConfig getDiscoveryConfig() {
    62|         if (discoveryConfig == null) {
    63|             discoveryConfig = new DiscoveryConfig();
    64|         }
    65|         return discoveryConfig;
    66|     }
    67|     /**
    68|      * Defines the Discovery Provider SPI configuration
    69|      *
    70|      * @param discoveryConfig the Discovery Provider SPI configuration
    71|      * @throws java.lang.IllegalArgumentException if discoveryConfig is null

# --- HUNK 2: Lines 260-398 ---
   260|      * set.
   261|      *
   262|      * @return the SSLConfig.
   263|      * @see #setSSLConfig(SSLConfig)
   264|      */
   265|     public SSLConfig getSSLConfig() {
   266|         return sslConfig;
   267|     }
   268|     /**
   269|      * Sets the {@link SSLConfig}. null value indicates that no SSLConfig should be used.
   270|      *
   271|      * @param sslConfig the SSLConfig.
   272|      * @return the updated ClientNetworkConfig.
   273|      * @see #getSSLConfig()
   274|      */
   275|     public ClientNetworkConfig setSSLConfig(SSLConfig sslConfig) {
   276|         this.sslConfig = sslConfig;
   277|         return this;
   278|     }
   279|     /**
   280|      * Sets configuration to connect nodes in AWS environment.
   281|      *
   282|      * @param clientAwsConfig the ClientAwsConfig
   283|      * @see #getAwsConfig()
   284|      */
   285|     public ClientNetworkConfig setAwsConfig(ClientAwsConfig clientAwsConfig) {
   286|         this.awsConfig = clientAwsConfig;
   287|         return this;
   288|     }
   289|     /**
   290|      * Returns the current {@link ClientAwsConfig}.
   291|      *
   292|      * @return ClientAwsConfig
   293|      * @see #setAwsConfig(ClientAwsConfig)
   294|      */
   295|     public ClientAwsConfig getAwsConfig() {
   296|         return awsConfig;
   297|     }
   298|     /**
   299|      * Sets configuration to connect nodes in GCP environment.
   300|      *
   301|      * @param gcpConfig the GcpConfig
   302|      * @see #getGcpConfig()
   303|      */
   304|     public ClientNetworkConfig setGcpConfig(GcpConfig gcpConfig) {
   305|         this.gcpConfig = gcpConfig;
   306|         return this;
   307|     }
   308|     /**
   309|      * Returns the current {@link GcpConfig}.
   310|      *
   311|      * @return GcpConfig
   312|      * @see #setGcpConfig(GcpConfig)
   313|      */
   314|     public GcpConfig getGcpConfig() {
   315|         return gcpConfig;
   316|     }
   317|     /**
   318|      * Sets configuration to connect nodes in Azure environment.
   319|      *
   320|      * @param azureConfig the AzureConfig
   321|      * @see #getAzureConfig()
   322|      */
   323|     public ClientNetworkConfig setAzureConfig(AzureConfig azureConfig) {
   324|         this.azureConfig = azureConfig;
   325|         return this;
   326|     }
   327|     /**
   328|      * Returns the current {@link AzureConfig}.
   329|      *
   330|      * @return AzureConfig
   331|      * @see #setAzureConfig(AzureConfig)
   332|      */
   333|     public AzureConfig getAzureConfig() {
   334|         return azureConfig;
   335|     }
   336|     /**
   337|      * Sets configuration to connect nodes in Kubernetes environment.
   338|      *
   339|      * @param kubernetesConfig the KubernetesConfig
   340|      * @see #getKubernetesConfig()
   341|      */
   342|     public ClientNetworkConfig setKubernetesConfig(KubernetesConfig kubernetesConfig) {
   343|         this.kubernetesConfig = kubernetesConfig;
   344|         return this;
   345|     }
   346|     /**
   347|      * Returns the current {@link KubernetesConfig}.
   348|      *
   349|      * @return KubernetesConfig
   350|      * @see #setKubernetesConfig(KubernetesConfig)
   351|      */
   352|     public KubernetesConfig getKubernetesConfig() {
   353|         return kubernetesConfig;
   354|     }
   355|     /**
   356|      * Sets configuration to connect nodes in Eureka environment.
   357|      *
   358|      * @param eurekaConfig the EurekaConfig
   359|      * @see #getEurekaConfig()
   360|      */
   361|     public ClientNetworkConfig setEurekaConfig(EurekaConfig eurekaConfig) {
   362|         this.eurekaConfig = eurekaConfig;
   363|         return this;
   364|     }
   365|     /**
   366|      * Returns the current {@link EurekaConfig}.
   367|      *
   368|      * @return EurekaConfig
   369|      * @see #setEurekaConfig(EurekaConfig)
   370|      */
   371|     public EurekaConfig getEurekaConfig() {
   372|         return eurekaConfig;
   373|     }
   374|     public ClientCloudConfig getCloudConfig() {
   375|         return cloudConfig;
   376|     }
   377|     public void setCloudConfig(ClientCloudConfig cloudConfig) {
   378|         this.cloudConfig = cloudConfig;
   379|     }
   380|     /**
   381|      * Returns the outbound port definitions. It is possible that null is returned if not defined.
   382|      *
   383|      * @return list of outbound port definitions
   384|      */
   385|     public Collection<String> getOutboundPortDefinitions() {
   386|         return outboundPortDefinitions;
   387|     }
   388|     /**
   389|      * Returns the outbound ports. It is possible that null is returned if not defined.
   390|      *
   391|      * @return list of outbound ports
   392|      */
   393|     public Collection<Integer> getOutboundPorts() {
   394|         return outboundPorts;
   395|     }
   396|     /**
   397|      * Set outbound port definitions
   398|      *


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/config/ClientReliableTopicConfig.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 20-81 ---
    20| import static com.hazelcast.util.Preconditions.checkNotNull;
    21| import static com.hazelcast.util.Preconditions.checkPositive;
    22| /**
    23|  * Contains the ReliableTopic configuration for a client.
    24|  *
    25|  * @see com.hazelcast.client.proxy.ClientReliableTopicProxy
    26|  */
    27| public class ClientReliableTopicConfig {
    28|     /**
    29|      * The default read batch size.
    30|      */
    31|     public static final int DEFAULT_READ_BATCH_SIZE = 10;
    32|     /**
    33|      * The default slow consumer policy.
    34|      */
    35|     public static final TopicOverloadPolicy DEFAULT_TOPIC_OVERLOAD_POLICY = BLOCK;
    36|     private Executor executor;
    37|     private int readBatchSize = DEFAULT_READ_BATCH_SIZE;
    38|     private String name;
    39|     private TopicOverloadPolicy topicOverloadPolicy = DEFAULT_TOPIC_OVERLOAD_POLICY;
    40|     public ClientReliableTopicConfig() {
    41|     }
    42|     /**
    43|      * Creates a new ReliableTopicConfig with default settings.
    44|      */
    45|     public ClientReliableTopicConfig(String name) {
    46|         this.name = checkNotNull(name, "name");
    47|     }
    48|     /**
    49|      * Gets the name of the reliable topic.
    50|      *
    51|      * @return the name of the reliable topic.
    52|      */
    53|     public String getName() {
    54|         return name;
    55|     }
    56|     /**
    57|      * Sets the name or name pattern for this config. Must not be modified after this
    58|      * instance is added to {@link ClientConfig}.
    59|      */
    60|     public void setName(String name) {
    61|         this.name = name;
    62|     }
    63|     /**
    64|      * Gets the TopicOverloadPolicy for this reliable topic.
    65|      *
    66|      * @return the TopicOverloadPolicy.
    67|      */
    68|     public TopicOverloadPolicy getTopicOverloadPolicy() {
    69|         return topicOverloadPolicy;
    70|     }
    71|     /**
    72|      * Sets the TopicOverloadPolicy for this reliable topic. Check the {@link TopicOverloadPolicy} for more details about
    73|      * this setting.
    74|      *
    75|      * @param topicOverloadPolicy the new TopicOverloadPolicy.
    76|      * @return the updated reliable topic config.
    77|      * @throws IllegalArgumentException if topicOverloadPolicy is null.
    78|      */
    79|     public ClientReliableTopicConfig setTopicOverloadPolicy(TopicOverloadPolicy topicOverloadPolicy) {
    80|         this.topicOverloadPolicy = checkNotNull(topicOverloadPolicy, "topicOverloadPolicy can't be null");
    81|         return this;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/config/ClientSecurityConfig.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-77 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.config;
    17| import com.hazelcast.config.CredentialsFactoryConfig;
    18| import com.hazelcast.security.Credentials;
    19| /**
    20|  * Contains the security configuration for the client.
    21|  * Credentials object is used for both authentication and authorization
    22|  * Credentials is used with ClusterLoginModule for authentication
    23|  * It is also used with SecurityInterceptor and to define principal in client-permissions for authorization.
    24|  *
    25|  * @see Credentials#getPrincipal()
    26|  * @see com.hazelcast.security.SecurityInterceptor
    27|  */
    28| public class ClientSecurityConfig {
    29|     private Credentials credentials;
    30|     private String credentialsClassname;
    31|     private CredentialsFactoryConfig credentialsFactoryConfig = new CredentialsFactoryConfig();
    32|     public Credentials getCredentials() {
    33|         return credentials;
    34|     }
    35|     /**
    36|      * @param credentials that will be used when
    37|      * @return configured {@link com.hazelcast.client.config.ClientSecurityConfig} for chaining
    38|      */
    39|     public ClientSecurityConfig setCredentials(Credentials credentials) {
    40|         this.credentials = credentials;
    41|         return this;
    42|     }
    43|     /**
    44|      * @return configured class name for credentials
    45|      */
    46|     public String getCredentialsClassname() {
    47|         return credentialsClassname;
    48|     }
    49|     /**
    50|      * Credentials class will be instantiated from class name when setCredentialsFactoryConfig and  setCredentials
    51|      * are not used. The class will be instantiated with empty constructor.
    52|      *
    53|      * @param credentialsClassname class name for credentials
    54|      * @return configured {@link com.hazelcast.client.config.ClientSecurityConfig} for chaining
    55|      */
    56|     public ClientSecurityConfig setCredentialsClassname(String credentialsClassname) {
    57|         this.credentialsClassname = credentialsClassname;
    58|         return this;
    59|     }
    60|     /**
    61|      * @return credentials factory config
    62|      */
    63|     public CredentialsFactoryConfig getCredentialsFactoryConfig() {
    64|         return credentialsFactoryConfig;
    65|     }
    66|     /**
    67|      * Credentials Factory Config allows user to pass custom properties and use group config when instantiating
    68|      * a credentials object.
    69|      *
    70|      * @param credentialsFactoryConfig the config that will be used to create credentials factory
    71|      * @return configured {@link com.hazelcast.client.config.ClientSecurityConfig} for chaining
    72|      */
    73|     public ClientSecurityConfig setCredentialsFactoryConfig(CredentialsFactoryConfig credentialsFactoryConfig) {
    74|         this.credentialsFactoryConfig = credentialsFactoryConfig;
    75|         return this;
    76|     }
    77| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/config/ClientXmlElements.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 16-55 ---
    16| package com.hazelcast.client.config;
    17| enum ClientXmlElements {
    18|     HAZELCAST_CLIENT("hazelcast-client", false),
    19|     IMPORT("import", true),
    20|     SECURITY("security", false),
    21|     PROXY_FACTORIES("proxy-factories", false),
    22|     PROPERTIES("properties", false),
    23|     SERIALIZATION("serialization", false),
    24|     NATIVE_MEMORY("native-memory", false),
    25|     GROUP("group", false),
    26|     LISTENERS("listeners", false),
    27|     NETWORK("network", false),
    28|     LOAD_BALANCER("load-balancer", false),
    29|     NEAR_CACHE("near-cache", true),
    30|     QUERY_CACHES("query-caches", false),
    31|     EXECUTOR_POOL_SIZE("executor-pool-size", false),
    32|     LICENSE_KEY("license-key", false),
    33|     INSTANCE_NAME("instance-name", false),
    34|     CONNECTION_STRATEGY("connection-strategy", false),
    35|     USER_CODE_DEPLOYMENT("user-code-deployment", false),
    36|     FLAKE_ID_GENERATOR("flake-id-generator", true),
    37|     RELIABLE_TOPIC("reliable-topic", true);
    38|     final String name;
    39|     final boolean multipleOccurrence;
    40|     ClientXmlElements(String name, boolean multipleOccurrence) {
    41|         this.name = name;
    42|         this.multipleOccurrence = multipleOccurrence;
    43|     }
    44|     public static boolean canOccurMultipleTimes(String name) {
    45|         for (ClientXmlElements element : values()) {
    46|             if (name.equals(element.name)) {
    47|                 return element.multipleOccurrence;
    48|             }
    49|         }
    50|         return true;
    51|     }
    52|     public boolean isEqual(String name) {
    53|         return this.name.equals(name);
    54|     }
    55| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/config/ConnectionRetryConfig.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-146 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.config;
    17| /**
    18|  * Connection Retry Config is controls the period among the retries and when should a client gave up
    19|  * retrying. Exponential behaviour can be chosen or jitter can be added to wait periods.
    20|  */
    21| public class ConnectionRetryConfig {
    22|     private static final int INITIAL_BACKOFF_MILLIS = 1000;
    23|     private static final int MAX_BACKOFF_MILLIS = 30000;
    24|     private static final double JITTER = 0.2;
    25|     private int initialBackoffMillis = INITIAL_BACKOFF_MILLIS;
    26|     private int maxBackoffMillis = MAX_BACKOFF_MILLIS;
    27|     private double multiplier = 2;
    28|     private boolean failOnMaxBackoff;
    29|     private double jitter = JITTER;
    30|     private boolean enabled;
    31|     /**
    32|      * how long to wait after the first failure before retrying
    33|      *
    34|      * @return initialBackoffMillis
    35|      */
    36|     public int getInitialBackoffMillis() {
    37|         return initialBackoffMillis;
    38|     }
    39|     /**
    40|      * @param initialBackoffMillis how long to wait after the first failure before retrying
    41|      * @return updated ConnectionRetryConfig
    42|      */
    43|     public ConnectionRetryConfig setInitialBackoffMillis(int initialBackoffMillis) {
    44|         this.initialBackoffMillis = initialBackoffMillis;
    45|         return this;
    46|     }
    47|     /**
    48|      * When backoff reaches this upper bound, it does not increase any more. Behaviour after that changes
    49|      * depending on `failOnMaxBackoff` option
    50|      *
    51|      * @return maxBackoffMillis
    52|      */
    53|     public int getMaxBackoffMillis() {
    54|         return maxBackoffMillis;
    55|     }
    56|     /**
    57|      * When backoff reaches this upper bound, it does not increase any more. Behaviour after that changes
    58|      * depending on `failOnMaxBackoff` option
    59|      *
    60|      * @param maxBackoffMillis upper bound on backoff
    61|      * @return updated ConnectionRetryConfig
    62|      */
    63|     public ConnectionRetryConfig setMaxBackoffMillis(int maxBackoffMillis) {
    64|         this.maxBackoffMillis = maxBackoffMillis;
    65|         return this;
    66|     }
    67|     /**
    68|      * factor with which to multiply backoff after a failed retry
    69|      *
    70|      * @return multiplier
    71|      */
    72|     public double getMultiplier() {
    73|         return multiplier;
    74|     }
    75|     /**
    76|      * @param multiplier factor with which to multiply backoff after a failed retry
    77|      * @return updated ConnectionRetryConfig
    78|      */
    79|     public ConnectionRetryConfig setMultiplier(double multiplier) {
    80|         this.multiplier = multiplier;
    81|         return this;
    82|     }
    83|     /**
    84|      * whether to fail when the max-backoff has reached or continue waiting max-backoff-millis at each iteration
    85|      * When on fail, client shuts down.
    86|      *
    87|      * @return failOnMaxBackoff
    88|      */
    89|     public boolean isFailOnMaxBackoff() {
    90|         return failOnMaxBackoff;
    91|     }
    92|     /**
    93|      * @param failOnMaxBackoff whether to fail when the max-backoff has reached or
    94|      *                         continue waiting max-backoff-millis at each iteration
    95|      * @return updated ConnectionRetryConfig
    96|      */
    97|     public ConnectionRetryConfig setFailOnMaxBackoff(boolean failOnMaxBackoff) {
    98|         this.failOnMaxBackoff = failOnMaxBackoff;
    99|         return this;
   100|     }
   101|     /**
   102|      * by how much to randomize backoffs.
   103|      * At each iteration calculated back-off is randomized via following method
   104|      * Random(-jitter * current_backoff, jitter * current_backoff)
   105|      *
   106|      * @return jitter
   107|      */
   108|     public double getJitter() {
   109|         return jitter;
   110|     }
   111|     /**
   112|      * At each iteration calculated back-off is randomized via following method
   113|      * Random(-jitter * current_backoff, jitter * current_backoff)
   114|      *
   115|      * @param jitter by how much to randomize backoffs
   116|      * @return updated ConnectionRetryConfig
   117|      */
   118|     public ConnectionRetryConfig setJitter(double jitter) {
   119|         this.jitter = jitter;
   120|         return this;
   121|     }
   122|     /**
   123|      * enables connection retry logic.
   124|      * When disabled, old configurations are used:
   125|      * {@link ClientNetworkConfig#getConnectionAttemptLimit()}
   126|      * {@link ClientNetworkConfig#getConnectionAttemptPeriod()} ()}
   127|      *
   128|      * @return true if enabled
   129|      */
   130|     public boolean isEnabled() {
   131|         return enabled;
   132|     }
   133|     /**
   134|      * enables connection retry logic.
   135|      * When disabled, old configurations are used:
   136|      * {@link ClientNetworkConfig#getConnectionAttemptLimit()}
   137|      * {@link ClientNetworkConfig#getConnectionAttemptPeriod()} ()}
   138|      *
   139|      * @param enabled
   140|      * @return updated ConnectionRetryConfig
   141|      */
   142|     public ConnectionRetryConfig setEnabled(boolean enabled) {
   143|         this.enabled = enabled;
   144|         return this;
   145|     }
   146| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/config/XmlClientConfigBuilder.java
# Total hunks: 7
# ====================================================================
# --- HUNK 1: Lines 1-93 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.config;
    17| import com.hazelcast.client.config.ClientConnectionStrategyConfig.ReconnectMode;
    18| import com.hazelcast.client.util.RandomLB;
    19| import com.hazelcast.client.util.RoundRobinLB;
    20| import com.hazelcast.config.AbstractConfigBuilder;
    21| import com.hazelcast.config.AliasedDiscoveryConfig;
    22| import com.hazelcast.config.ConfigLoader;
    23| import com.hazelcast.config.CredentialsFactoryConfig;
    24| import com.hazelcast.config.AliasedDiscoveryConfigUtils;
    25| import com.hazelcast.config.DiscoveryConfig;
    26| import com.hazelcast.config.DiscoveryStrategyConfig;
    27| import com.hazelcast.config.EvictionConfig;
    28| import com.hazelcast.config.EvictionConfig.MaxSizePolicy;
    29| import com.hazelcast.config.EvictionPolicy;
    30| import com.hazelcast.config.InMemoryFormat;
    31| import com.hazelcast.config.InvalidConfigurationException;
    32| import com.hazelcast.config.ListenerConfig;
    33| import com.hazelcast.config.NearCacheConfig;
    34| import com.hazelcast.config.NearCachePreloaderConfig;
    35| import com.hazelcast.config.SSLConfig;
    36| import com.hazelcast.config.SerializationConfig;
    37| import com.hazelcast.config.SocketInterceptorConfig;
    38| import com.hazelcast.logging.ILogger;
    39| import com.hazelcast.logging.Logger;
    40| import com.hazelcast.nio.IOUtil;
    41| import com.hazelcast.topic.TopicOverloadPolicy;
    42| import com.hazelcast.util.ExceptionUtil;
    43| import org.w3c.dom.Document;
    44| import org.w3c.dom.Element;
    45| import org.w3c.dom.NamedNodeMap;
    46| import org.w3c.dom.Node;
    47| import javax.xml.parsers.DocumentBuilder;
    48| import javax.xml.parsers.DocumentBuilderFactory;
    49| import java.io.File;
    50| import java.io.FileInputStream;
    51| import java.io.IOException;
    52| import java.io.InputStream;
    53| import java.net.URL;
    54| import java.util.HashMap;
    55| import java.util.HashSet;
    56| import java.util.Map;
    57| import java.util.Properties;
    58| import java.util.Set;
    59| import static com.hazelcast.client.config.ClientXmlElements.CONNECTION_STRATEGY;
    60| import static com.hazelcast.client.config.ClientXmlElements.EXECUTOR_POOL_SIZE;
    61| import static com.hazelcast.client.config.ClientXmlElements.FLAKE_ID_GENERATOR;
    62| import static com.hazelcast.client.config.ClientXmlElements.GROUP;
    63| import static com.hazelcast.client.config.ClientXmlElements.INSTANCE_NAME;
    64| import static com.hazelcast.client.config.ClientXmlElements.LICENSE_KEY;
    65| import static com.hazelcast.client.config.ClientXmlElements.LISTENERS;
    66| import static com.hazelcast.client.config.ClientXmlElements.LOAD_BALANCER;
    67| import static com.hazelcast.client.config.ClientXmlElements.NATIVE_MEMORY;
    68| import static com.hazelcast.client.config.ClientXmlElements.NEAR_CACHE;
    69| import static com.hazelcast.client.config.ClientXmlElements.NETWORK;
    70| import static com.hazelcast.client.config.ClientXmlElements.PROPERTIES;
    71| import static com.hazelcast.client.config.ClientXmlElements.PROXY_FACTORIES;
    72| import static com.hazelcast.client.config.ClientXmlElements.QUERY_CACHES;
    73| import static com.hazelcast.client.config.ClientXmlElements.RELIABLE_TOPIC;
    74| import static com.hazelcast.client.config.ClientXmlElements.SECURITY;
    75| import static com.hazelcast.client.config.ClientXmlElements.SERIALIZATION;
    76| import static com.hazelcast.client.config.ClientXmlElements.USER_CODE_DEPLOYMENT;
    77| import static com.hazelcast.client.config.ClientXmlElements.canOccurMultipleTimes;
    78| import static com.hazelcast.util.StringUtil.LINE_SEPARATOR;
    79| import static com.hazelcast.util.StringUtil.upperCaseInternal;
    80| /**
    81|  * Loads the {@link com.hazelcast.client.config.ClientConfig} using XML.
    82|  */
    83| @SuppressWarnings("checkstyle:methodcount")
    84| public class XmlClientConfigBuilder extends AbstractConfigBuilder {
    85|     private static final ILogger LOGGER = Logger.getLogger(XmlClientConfigBuilder.class);
    86|     private final QueryCacheConfigBuilderHelper queryCacheConfigBuilderHelper = new QueryCacheConfigBuilderHelper();
    87|     private final Set<String> occurrenceSet = new HashSet<String>();
    88|     private final InputStream in;
    89|     private Properties properties = System.getProperties();
    90|     private ClientConfig clientConfig;
    91|     public XmlClientConfigBuilder(String resource) throws IOException {
    92|         URL url = ConfigLoader.locateConfig(resource);
    93|         if (url == null) {

# --- HUNK 2: Lines 222-309 ---
   222|         } else if (NETWORK.isEqual(nodeName)) {
   223|             handleNetwork(node);
   224|         } else if (LOAD_BALANCER.isEqual(nodeName)) {
   225|             handleLoadBalancer(node);
   226|         } else if (NEAR_CACHE.isEqual(nodeName)) {
   227|             handleNearCache(node);
   228|         } else if (QUERY_CACHES.isEqual(nodeName)) {
   229|             queryCacheConfigBuilderHelper.handleQueryCache(clientConfig, node);
   230|         } else if (EXECUTOR_POOL_SIZE.isEqual(nodeName)) {
   231|             handleExecutorPoolSize(node);
   232|         } else if (LICENSE_KEY.isEqual(nodeName)) {
   233|             clientConfig.setLicenseKey(getTextContent(node));
   234|         } else if (INSTANCE_NAME.isEqual(nodeName)) {
   235|             clientConfig.setInstanceName(getTextContent(node));
   236|         } else if (CONNECTION_STRATEGY.isEqual(nodeName)) {
   237|             handleConnectionStrategy(node);
   238|         } else if (USER_CODE_DEPLOYMENT.isEqual(nodeName)) {
   239|             handleUserCodeDeployment(node);
   240|         } else if (FLAKE_ID_GENERATOR.isEqual(nodeName)) {
   241|             handleFlakeIdGenerator(node);
   242|         } else if (RELIABLE_TOPIC.isEqual(nodeName)) {
   243|             handleReliableTopic(node);
   244|         }
   245|     }
   246|     private void handleConnectionStrategy(Node node) {
   247|         ClientConnectionStrategyConfig strategyConfig = new ClientConnectionStrategyConfig();
   248|         String attrValue = getAttribute(node, "async-start");
   249|         strategyConfig.setAsyncStart(attrValue != null && getBooleanValue(attrValue.trim()));
   250|         attrValue = getAttribute(node, "reconnect-mode");
   251|         if (attrValue != null) {
   252|             strategyConfig.setReconnectMode(ReconnectMode.valueOf(upperCaseInternal(attrValue.trim())));
   253|         }
   254|         for (Node child : childElements(node)) {
   255|             String nodeName = cleanNodeName(child);
   256|             if ("connection-retry".equals(nodeName)) {
   257|                 handleConnectionRetry(child, strategyConfig);
   258|             }
   259|         }
   260|         clientConfig.setConnectionStrategyConfig(strategyConfig);
   261|     }
   262|     private void handleConnectionRetry(Node node, ClientConnectionStrategyConfig strategyConfig) {
   263|         Node enabledNode = node.getAttributes().getNamedItem("enabled");
   264|         boolean enabled = enabledNode != null && getBooleanValue(getTextContent(enabledNode).trim());
   265|         if (!enabled) {
   266|             LOGGER.warning("Exponential Connection Strategy is not enabled.");
   267|         }
   268|         ConnectionRetryConfig connectionRetryConfig = new ConnectionRetryConfig();
   269|         connectionRetryConfig.setEnabled(enabled);
   270|         String initialBackoffMillis = "initial-backoff-millis";
   271|         String maxBackoffMillis = "max-backoff-millis";
   272|         String multiplier = "multiplier";
   273|         String jitter = "jitter";
   274|         for (Node child : childElements(node)) {
   275|             String nodeName = cleanNodeName(child);
   276|             String value = getTextContent(child).trim();
   277|             if (initialBackoffMillis.equals(nodeName)) {
   278|                 connectionRetryConfig.setInitialBackoffMillis(getIntegerValue(initialBackoffMillis, value));
   279|             } else if (maxBackoffMillis.equals(nodeName)) {
   280|                 connectionRetryConfig.setMaxBackoffMillis(getIntegerValue(maxBackoffMillis, value));
   281|             } else if (multiplier.equals(nodeName)) {
   282|                 connectionRetryConfig.setMultiplier(getIntegerValue(multiplier, value));
   283|             } else if ("fail-on-max-backoff".equals(nodeName)) {
   284|                 connectionRetryConfig.setFailOnMaxBackoff(getBooleanValue(value));
   285|             } else if (jitter.equals(nodeName)) {
   286|                 connectionRetryConfig.setJitter(getDoubleValue(jitter, value));
   287|             }
   288|         }
   289|         strategyConfig.setConnectionRetryConfig(connectionRetryConfig);
   290|     }
   291|     private void handleUserCodeDeployment(Node node) {
   292|         NamedNodeMap atts = node.getAttributes();
   293|         Node enabledNode = atts.getNamedItem("enabled");
   294|         boolean enabled = enabledNode != null && getBooleanValue(getTextContent(enabledNode).trim());
   295|         ClientUserCodeDeploymentConfig userCodeDeploymentConfig = new ClientUserCodeDeploymentConfig();
   296|         userCodeDeploymentConfig.setEnabled(enabled);
   297|         for (Node child : childElements(node)) {
   298|             String childNodeName = cleanNodeName(child);
   299|             if ("classnames".equals(childNodeName)) {
   300|                 for (Node classNameNode : childElements(child)) {
   301|                     userCodeDeploymentConfig.addClass(getTextContent(classNameNode));
   302|                 }
   303|             } else if ("jarpaths".equals(childNodeName)) {
   304|                 for (Node jarPathNode : childElements(child)) {
   305|                     userCodeDeploymentConfig.addJar(getTextContent(jarPathNode));
   306|                 }
   307|             } else {
   308|                 throw new InvalidConfigurationException("User code deployement can either be className or jarPath. "
   309|                         + childNodeName + " is invalid");

# --- HUNK 3: Lines 352-405 ---
   352|         if (serializeKeys != null && !serializeKeys && nearCacheConfig.getInMemoryFormat() == InMemoryFormat.NATIVE) {
   353|             LOGGER.warning("The Near Cache doesn't support keys by-reference with NATIVE in-memory-format."
   354|                     + " This setting will have no effect!");
   355|         }
   356|         clientConfig.addNearCacheConfig(nearCacheConfig);
   357|     }
   358|     private void handleFlakeIdGenerator(Node node) {
   359|         String name = getAttribute(node, "name");
   360|         ClientFlakeIdGeneratorConfig config = new ClientFlakeIdGeneratorConfig(name);
   361|         for (Node child : childElements(node)) {
   362|             String nodeName = cleanNodeName(child);
   363|             String value = getTextContent(child).trim();
   364|             if ("prefetch-count".equals(nodeName)) {
   365|                 config.setPrefetchCount(Integer.parseInt(value));
   366|             } else if ("prefetch-validity-millis".equalsIgnoreCase(nodeName)) {
   367|                 config.setPrefetchValidityMillis(Long.parseLong(value));
   368|             }
   369|         }
   370|         clientConfig.addFlakeIdGeneratorConfig(config);
   371|     }
   372|     private void handleReliableTopic(Node node) {
   373|         String name = getAttribute(node, "name");
   374|         ClientReliableTopicConfig config = new ClientReliableTopicConfig(name);
   375|         for (Node child : childElements(node)) {
   376|             String nodeName = cleanNodeName(child);
   377|             String value = getTextContent(child).trim();
   378|             if ("topic-overload-policy".equals(nodeName)) {
   379|                 config.setTopicOverloadPolicy(TopicOverloadPolicy.valueOf(value));
   380|             } else if ("read-batch-size".equalsIgnoreCase(nodeName)) {
   381|                 config.setReadBatchSize(Integer.parseInt(value));
   382|             }
   383|         }
   384|         clientConfig.addReliableTopicConfig(config);
   385|     }
   386|     private EvictionConfig getEvictionConfig(Node node) {
   387|         EvictionConfig evictionConfig = new EvictionConfig();
   388|         Node size = node.getAttributes().getNamedItem("size");
   389|         Node maxSizePolicy = node.getAttributes().getNamedItem("max-size-policy");
   390|         Node evictionPolicy = node.getAttributes().getNamedItem("eviction-policy");
   391|         if (size != null) {
   392|             evictionConfig.setSize(Integer.parseInt(getTextContent(size)));
   393|         }
   394|         if (maxSizePolicy != null) {
   395|             evictionConfig.setMaximumSizePolicy(MaxSizePolicy.valueOf(upperCaseInternal(getTextContent(maxSizePolicy)))
   396|             );
   397|         }
   398|         if (evictionPolicy != null) {
   399|             evictionConfig.setEvictionPolicy(EvictionPolicy.valueOf(upperCaseInternal(getTextContent(evictionPolicy)))
   400|             );
   401|         }
   402|         return evictionConfig;
   403|     }
   404|     private NearCachePreloaderConfig getNearCachePreloaderConfig(Node node) {
   405|         NearCachePreloaderConfig preloaderConfig = new NearCachePreloaderConfig();

# --- HUNK 4: Lines 435-500 ---
   435|         for (Node child : childElements(node)) {
   436|             String nodeName = cleanNodeName(child);
   437|             if ("cluster-members".equals(nodeName)) {
   438|                 handleClusterMembers(child, clientNetworkConfig);
   439|             } else if ("smart-routing".equals(nodeName)) {
   440|                 clientNetworkConfig.setSmartRouting(Boolean.parseBoolean(getTextContent(child)));
   441|             } else if ("redo-operation".equals(nodeName)) {
   442|                 clientNetworkConfig.setRedoOperation(Boolean.parseBoolean(getTextContent(child)));
   443|             } else if ("connection-timeout".equals(nodeName)) {
   444|                 clientNetworkConfig.setConnectionTimeout(Integer.parseInt(getTextContent(child)));
   445|             } else if ("connection-attempt-period".equals(nodeName)) {
   446|                 clientNetworkConfig.setConnectionAttemptPeriod(Integer.parseInt(getTextContent(child)));
   447|             } else if ("connection-attempt-limit".equals(nodeName)) {
   448|                 clientNetworkConfig.setConnectionAttemptLimit(Integer.parseInt(getTextContent(child)));
   449|             } else if ("socket-options".equals(nodeName)) {
   450|                 handleSocketOptions(child, clientNetworkConfig);
   451|             } else if ("socket-interceptor".equals(nodeName)) {
   452|                 handleSocketInterceptorConfig(child, clientNetworkConfig);
   453|             } else if ("ssl".equals(nodeName)) {
   454|                 handleSSLConfig(child, clientNetworkConfig);
   455|             } else if (AliasedDiscoveryConfigUtils.supports(nodeName)) {
   456|                 handleAliasedDiscoveryStrategy(child, clientNetworkConfig, nodeName);
   457|             } else if ("discovery-strategies".equals(nodeName)) {
   458|                 handleDiscoveryStrategies(child, clientNetworkConfig);
   459|             } else if ("outbound-ports".equals(nodeName)) {
   460|                 handleOutboundPorts(child, clientNetworkConfig);
   461|             } else if ("icmp-ping".equals(nodeName)) {
   462|                 handleIcmpPing(child, clientNetworkConfig);
   463|             } else if ("hazelcast-cloud".equals(nodeName)) {
   464|                 handleHazelcastCloud(child, clientNetworkConfig);
   465|             }
   466|         }
   467|         clientConfig.setNetworkConfig(clientNetworkConfig);
   468|     }
   469|     private void handleHazelcastCloud(Node node, ClientNetworkConfig clientNetworkConfig) {
   470|         ClientCloudConfig cloudConfig = clientNetworkConfig.getCloudConfig();
   471|         NamedNodeMap atts = node.getAttributes();
   472|         Node enabledNode = atts.getNamedItem("enabled");
   473|         boolean enabled = enabledNode != null && getBooleanValue(getTextContent(enabledNode).trim());
   474|         cloudConfig.setEnabled(enabled);
   475|         for (Node child : childElements(node)) {
   476|             String nodeName = cleanNodeName(child);
   477|             if ("discovery-token".equals(nodeName)) {
   478|                 cloudConfig.setDiscoveryToken(getTextContent(child));
   479|             }
   480|         }
   481|     }
   482|     private void handleIcmpPing(Node node, ClientNetworkConfig clientNetworkConfig) {
   483|         ClientIcmpPingConfig icmpPingConfig = clientNetworkConfig.getClientIcmpPingConfig();
   484|         NamedNodeMap atts = node.getAttributes();
   485|         Node enabledNode = atts.getNamedItem("enabled");
   486|         boolean enabled = enabledNode != null && getBooleanValue(getTextContent(enabledNode).trim());
   487|         icmpPingConfig.setEnabled(enabled);
   488|         for (Node child : childElements(node)) {
   489|             String nodeName = cleanNodeName(child);
   490|             if ("timeout-milliseconds".equals(nodeName)) {
   491|                 icmpPingConfig.setTimeoutMilliseconds(Integer.parseInt(getTextContent(child)));
   492|             } else if ("interval-milliseconds".equals(nodeName)) {
   493|                 icmpPingConfig.setIntervalMilliseconds(Integer.parseInt(getTextContent(child)));
   494|             } else if ("ttl".equals(nodeName)) {
   495|                 icmpPingConfig.setTtl(Integer.parseInt(getTextContent(child)));
   496|             } else if ("max-attempts".equals(nodeName)) {
   497|                 icmpPingConfig.setMaxAttempts(Integer.parseInt(getTextContent(child)));
   498|             } else if ("echo-fail-fast-on-startup".equals(nodeName)) {
   499|                 icmpPingConfig.setEchoFailFastOnStartup(Boolean.parseBoolean(getTextContent(child)));
   500|             }

# --- HUNK 5: Lines 527-583 ---
   527|             Node att = atts.item(a);
   528|             String value = getTextContent(att).trim();
   529|             if ("enabled".equalsIgnoreCase(att.getNodeName())) {
   530|                 enabled = getBooleanValue(value);
   531|             } else if ("class".equals(att.getNodeName())) {
   532|                 clazz = value;
   533|             }
   534|         }
   535|         if (!enabled || clazz == null) {
   536|             return;
   537|         }
   538|         Map<String, Comparable> properties = new HashMap<String, Comparable>();
   539|         for (Node child : childElements(node)) {
   540|             String name = cleanNodeName(child);
   541|             if ("properties".equals(name)) {
   542|                 fillProperties(child, properties);
   543|             }
   544|         }
   545|         discoveryConfig.addDiscoveryStrategyConfig(new DiscoveryStrategyConfig(clazz, properties));
   546|     }
   547|     private void handleAliasedDiscoveryStrategy(Node node, ClientNetworkConfig clientNetworkConfig, String tag) {
   548|         AliasedDiscoveryConfig config = ClientAliasedDiscoveryConfigUtils.getConfigByTag(clientNetworkConfig, tag);
   549|         NamedNodeMap atts = node.getAttributes();
   550|         for (int i = 0; i < atts.getLength(); i++) {
   551|             Node att = atts.item(i);
   552|             String value = getTextContent(att).trim();
   553|             if ("enabled".equalsIgnoreCase(att.getNodeName())) {
   554|                 config.setEnabled(getBooleanValue(value));
   555|             } else if (att.getNodeName().equals("connection-timeout-seconds")) {
   556|                 config.setProperty("connection-timeout-seconds", value);
   557|             }
   558|         }
   559|         for (Node n : childElements(node)) {
   560|             String key = cleanNodeName(n);
   561|             String value = getTextContent(n).trim();
   562|             config.setProperty(key, value);
   563|         }
   564|     }
   565|     private void handleSSLConfig(Node node, ClientNetworkConfig clientNetworkConfig) {
   566|         SSLConfig sslConfig = new SSLConfig();
   567|         NamedNodeMap atts = node.getAttributes();
   568|         Node enabledNode = atts.getNamedItem("enabled");
   569|         boolean enabled = enabledNode != null && getBooleanValue(getTextContent(enabledNode).trim());
   570|         sslConfig.setEnabled(enabled);
   571|         for (Node n : childElements(node)) {
   572|             String nodeName = cleanNodeName(n);
   573|             if ("factory-class-name".equals(nodeName)) {
   574|                 sslConfig.setFactoryClassName(getTextContent(n).trim());
   575|             } else if ("properties".equals(nodeName)) {
   576|                 fillProperties(n, sslConfig.getProperties());
   577|             }
   578|         }
   579|         clientNetworkConfig.setSSLConfig(sslConfig);
   580|     }
   581|     private void handleSocketOptions(Node node, ClientNetworkConfig clientNetworkConfig) {
   582|         SocketOptions socketOptions = clientConfig.getSocketOptions();
   583|         for (Node child : childElements(node)) {

# --- HUNK 6: Lines 634-683 ---
   634|             }
   635|         }
   636|     }
   637|     private void handleProxyFactory(Node node) throws Exception {
   638|         String service = getAttribute(node, "service");
   639|         String className = getAttribute(node, "class-name");
   640|         ProxyFactoryConfig proxyFactoryConfig = new ProxyFactoryConfig(className, service);
   641|         clientConfig.addProxyFactoryConfig(proxyFactoryConfig);
   642|     }
   643|     private void handleSocketInterceptorConfig(Node node, ClientNetworkConfig clientNetworkConfig) {
   644|         SocketInterceptorConfig socketInterceptorConfig = parseSocketInterceptorConfig(node);
   645|         clientNetworkConfig.setSocketInterceptorConfig(socketInterceptorConfig);
   646|     }
   647|     private void handleSecurity(Node node) throws Exception {
   648|         ClientSecurityConfig clientSecurityConfig = new ClientSecurityConfig();
   649|         for (Node child : childElements(node)) {
   650|             String nodeName = cleanNodeName(child);
   651|             if ("credentials".equals(nodeName)) {
   652|                 String className = getTextContent(child);
   653|                 clientSecurityConfig.setCredentialsClassname(className);
   654|             } else if ("credentials-factory".equals(nodeName)) {
   655|                 handleCredentialsFactory(child, clientSecurityConfig);
   656|             }
   657|         }
   658|         clientConfig.setSecurityConfig(clientSecurityConfig);
   659|     }
   660|     private void handleCredentialsFactory(Node node, ClientSecurityConfig clientSecurityConfig) {
   661|         NamedNodeMap attrs = node.getAttributes();
   662|         Node classNameNode = attrs.getNamedItem("class-name");
   663|         String className = getTextContent(classNameNode);
   664|         CredentialsFactoryConfig credentialsFactoryConfig = new CredentialsFactoryConfig(className);
   665|         clientSecurityConfig.setCredentialsFactoryConfig(credentialsFactoryConfig);
   666|         for (Node child : childElements(node)) {
   667|             String nodeName = cleanNodeName(child);
   668|             if ("properties".equals(nodeName)) {
   669|                 fillProperties(child, credentialsFactoryConfig.getProperties());
   670|                 break;
   671|             }
   672|         }
   673|     }
   674|     private void handleOutboundPorts(Node child, ClientNetworkConfig clientNetworkConfig) {
   675|         for (Node n : childElements(child)) {
   676|             String nodeName = cleanNodeName(n);
   677|             if ("ports".equals(nodeName)) {
   678|                 String value = getTextContent(n);
   679|                 clientNetworkConfig.addOutboundPortDefinition(value);
   680|             }
   681|         }
   682|     }
   683| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/connection/ClientConnectionManager.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-59 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.connection;
    17| import com.hazelcast.client.connection.nio.ClientConnection;
    18| import com.hazelcast.client.impl.client.ClientPrincipal;
    19| import com.hazelcast.nio.Address;
    20| import com.hazelcast.nio.Connection;
    21| import com.hazelcast.nio.ConnectionListenable;
    22| import java.io.IOException;
    23| import java.util.Collection;
    24| import java.util.concurrent.Future;
    25| /**
    26|  * Responsible for managing {@link com.hazelcast.client.connection.nio.ClientConnection} objects.
    27|  */
    28| public interface ClientConnectionManager extends ConnectionListenable {
    29|     /**
    30|      * Check if client connection manager is alive.
    31|      * ClientConnectionManager is not alive only when client is closing.
    32|      *
    33|      * @return true if alive, false otherwise.
    34|      */
    35|     boolean isAlive();
    36|     /**
    37|      * @param address to be connected
    38|      * @return connection if available, null otherwise
    39|      */
    40|     Connection getActiveConnection(Address address);
    41|     /**
    42|      * @param address to be connected
    43|      * @return associated connection if available, creates new connection otherwise
    44|      * @throws IOException if connection is not established
    45|      */
    46|     Connection getOrConnect(Address address) throws IOException;
    47|     /**
    48|      * @param address to be connected
    49|      * @return associated connection if available, returns null and triggers new connection creation otherwise
    50|      * @throws IOException if connection is not able to triggered
    51|      */
    52|     Connection getOrTriggerConnect(Address address, boolean acquiresResource) throws IOException;
    53|     Collection<ClientConnection> getActiveConnections();
    54|     Address getOwnerConnectionAddress();
    55|     ClientPrincipal getPrincipal();
    56|     ClientConnection getOwnerConnection();
    57|     void connectToCluster();
    58|     Future<Void> connectToClusterAsync();
    59| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/connection/ClientConnectionStrategy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 52-100 ---
    52|      * The build in retry mechanism can be stopped by throwing an instance of non retryable exceptions;
    53|      * {@link java.io.IOException}, {@link com.hazelcast.core.HazelcastInstanceNotActiveException} or
    54|      * {@link com.hazelcast.spi.exception.RetryableException}
    55|      *
    56|      * The thrown exception will be received on the blocking user. Any blocking invocation will exit by that exception.
    57|      * @param target address of the requested connection
    58|      */
    59|     public abstract void beforeGetConnection(Address target);
    60|     /**
    61|      * If a new connection is required to open by {@link ClientConnectionManager},
    62|      * this method will be called.
    63|      *
    64|      * This request can be rejected by throwing an instance of non retryable exceptions;
    65|      * {@link java.io.IOException}, {@link com.hazelcast.core.HazelcastInstanceNotActiveException} or
    66|      * {@link com.hazelcast.spi.exception.RetryableException}
    67|      * @param target address of the requested connection
    68|      */
    69|     public abstract void beforeOpenConnection(Address target);
    70|     /**
    71|      * If a cluster connection is established, this method will be called.
    72|      * @param target address of the requested connection
    73|      */
    74|     public abstract void beforeConnectToCluster(Address target);
    75|     /**
    76|      * If a cluster connection is established, this method will be called.
    77|      * if an exception is thrown, the already established connection will be closed.
    78|      */
    79|     public abstract void onConnectToCluster();
    80|     /**
    81|      * If the cluster connection is lost for any reason, this method will be called.
    82|      *
    83|      */
    84|     public abstract void onDisconnectFromCluster();
    85|     /**
    86|      * If the {@link ClientConnectionManager} opens a new connection to a member,
    87|      * this method will be called with the connection parameter
    88|      * @param connection the new established connection
    89|      */
    90|     public abstract void onConnect(ClientConnection connection);
    91|     /**
    92|      * If a connection is disconnected, this method will be called with the connection parameter
    93|      * @param connection the closed connection
    94|      */
    95|     public abstract void onDisconnect(ClientConnection connection);
    96|     /**
    97|      * The {@link ClientConnectionManager} will call this method as a last step of its shutdown.
    98|      */
    99|     public abstract void shutdown();
   100| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/ClientConnection.java
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 1-99 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.connection.nio;
    17| import com.hazelcast.client.connection.ClientConnectionManager;
    18| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    19| import com.hazelcast.client.impl.protocol.ClientMessage;
    20| import com.hazelcast.client.spi.impl.ClientResponseHandler;
    21| import com.hazelcast.client.spi.impl.listener.AbstractClientListenerService;
    22| import com.hazelcast.core.LifecycleService;
    23| import com.hazelcast.instance.BuildInfo;
    24| import com.hazelcast.internal.metrics.Probe;
    25| import com.hazelcast.internal.metrics.ProbeLevel;
    26| import com.hazelcast.internal.networking.Channel;
    27| import com.hazelcast.internal.networking.OutboundFrame;
    28| import com.hazelcast.logging.ILogger;
    29| import com.hazelcast.nio.Address;
    30| import com.hazelcast.nio.Connection;
    31| import com.hazelcast.nio.ConnectionType;
    32| import java.io.EOFException;
    33| import java.io.IOException;
    34| import java.net.InetAddress;
    35| import java.net.InetSocketAddress;
    36| import java.nio.channels.CancelledKeyException;
    37| import java.util.concurrent.atomic.AtomicLong;
    38| import static com.hazelcast.util.StringUtil.timeToStringFriendly;
    39| /**
    40|  * Client implementation of {@link Connection}.
    41|  * ClientConnection is a connection between a Hazelcast Client and a Hazelcast Member.
    42|  */
    43| public class ClientConnection implements Connection {
    44|     @Probe
    45|     private final int connectionId;
    46|     private final ILogger logger;
    47|     private final Channel channel;
    48|     private final ClientConnectionManagerImpl connectionManager;
    49|     private final LifecycleService lifecycleService;
    50|     private final HazelcastClientInstanceImpl client;
    51|     private final long startTime = System.currentTimeMillis();
    52|     private final ClientResponseHandler responseHandler;
    53|     private volatile Address remoteEndpoint;
    54|     private volatile boolean isAuthenticatedAsOwner;
    55|     @Probe(level = ProbeLevel.DEBUG)
    56|     private final AtomicLong closedTime = new AtomicLong();
    57|     private volatile Throwable closeCause;
    58|     private volatile String closeReason;
    59|     private int connectedServerVersion = BuildInfo.UNKNOWN_HAZELCAST_VERSION;
    60|     private String connectedServerVersionString;
    61|     public ClientConnection(HazelcastClientInstanceImpl client, int connectionId, Channel channel) {
    62|         this.client = client;
    63|         this.responseHandler = client.getInvocationService().getResponseHandler();
    64|         this.connectionManager = (ClientConnectionManagerImpl) client.getConnectionManager();
    65|         this.lifecycleService = client.getLifecycleService();
    66|         this.channel = channel;
    67|         channel.attributeMap().put(ClientConnection.class, this);
    68|         this.connectionId = connectionId;
    69|         this.logger = client.getLoggingService().getLogger(ClientConnection.class);
    70|     }
    71|     public ClientConnection(HazelcastClientInstanceImpl client, int connectionId) {
    72|         this.client = client;
    73|         this.responseHandler = client.getInvocationService().getResponseHandler();
    74|         this.connectionManager = (ClientConnectionManagerImpl) client.getConnectionManager();
    75|         this.lifecycleService = client.getLifecycleService();
    76|         this.connectionId = connectionId;
    77|         this.channel = null;
    78|         this.logger = client.getLoggingService().getLogger(ClientConnection.class);
    79|     }
    80|     @Override
    81|     public boolean write(OutboundFrame frame) {
    82|         if (channel.write(frame)) {
    83|             return true;
    84|         }
    85|         if (logger.isFinestEnabled()) {
    86|             logger.finest("Connection is closed, dropping frame -> " + frame);
    87|         }
    88|         return false;
    89|     }
    90|     @Override
    91|     public Address getEndPoint() {
    92|         return remoteEndpoint;
    93|     }
    94|     @Override
    95|     public boolean isAlive() {
    96|         return closedTime.get() == 0;
    97|     }
    98|     @Override
    99|     public long lastReadTimeMillis() {

# --- HUNK 2: Lines 173-247 ---
   173|                 logger.finest(message, closeCause);
   174|             }
   175|         }
   176|     }
   177|     protected void innerClose() throws IOException {
   178|         channel.close();
   179|     }
   180|     @Override
   181|     public Throwable getCloseCause() {
   182|         return closeCause;
   183|     }
   184|     @Override
   185|     public String getCloseReason() {
   186|         if (closeReason == null) {
   187|             return closeCause == null ? null : closeCause.getMessage();
   188|         } else {
   189|             return closeReason;
   190|         }
   191|     }
   192|     public void handleClientMessage(ClientMessage message) {
   193|         if (message.isFlagSet(ClientMessage.LISTENER_EVENT_FLAG)) {
   194|             AbstractClientListenerService listenerService = (AbstractClientListenerService) client.getListenerService();
   195|             listenerService.handleClientMessage(message);
   196|         } else {
   197|             responseHandler.handle(message);
   198|         }
   199|     }
   200|     public boolean isAuthenticatedAsOwner() {
   201|         return isAuthenticatedAsOwner;
   202|     }
   203|     public void setIsAuthenticatedAsOwner() {
   204|         this.isAuthenticatedAsOwner = true;
   205|     }
   206|     public long getStartTime() {
   207|         return startTime;
   208|     }
   209|     @Override
   210|     public boolean equals(Object o) {
   211|         if (this == o) {
   212|             return true;
   213|         }
   214|         if (!(o instanceof ClientConnection)) {
   215|             return false;
   216|         }
   217|         ClientConnection that = (ClientConnection) o;
   218|         return connectionId == that.connectionId;
   219|     }
   220|     @Override
   221|     public int hashCode() {
   222|         return connectionId;
   223|     }
   224|     @Override
   225|     public String toString() {
   226|         return "ClientConnection{"
   227|                 + "alive=" + isAlive()
   228|                 + ", connectionId=" + connectionId
   229|                 + ", channel=" + channel
   230|                 + ", remoteEndpoint=" + remoteEndpoint
   231|                 + ", lastReadTime=" + timeToStringFriendly(lastReadTimeMillis())
   232|                 + ", lastWriteTime=" + timeToStringFriendly(lastWriteTimeMillis())
   233|                 + ", closedTime=" + timeToStringFriendly(closedTime.get())
   234|                 + ", connected server version=" + connectedServerVersionString
   235|                 + '}';
   236|     }
   237|     public void setConnectedServerVersion(String connectedServerVersion) {
   238|         this.connectedServerVersionString = connectedServerVersion;
   239|         this.connectedServerVersion = BuildInfo.calculateVersion(connectedServerVersion);
   240|     }
   241|     public int getConnectedServerVersion() {
   242|         return connectedServerVersion;
   243|     }
   244|     public String getConnectedServerVersionString() {
   245|         return connectedServerVersionString;
   246|     }
   247| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/ClientConnectionManagerImpl.java
# Total hunks: 9
# ====================================================================
# --- HUNK 1: Lines 1-256 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.connection.nio;
    17| import com.hazelcast.client.AuthenticationException;
    18| import com.hazelcast.client.ClientExtension;
    19| import com.hazelcast.client.HazelcastClientNotActiveException;
    20| import com.hazelcast.client.HazelcastClientOfflineException;
    21| import com.hazelcast.client.config.ClientNetworkConfig;
    22| import com.hazelcast.client.connection.AddressProvider;
    23| import com.hazelcast.client.connection.AddressTranslator;
    24| import com.hazelcast.client.connection.ClientConnectionManager;
    25| import com.hazelcast.client.connection.ClientConnectionStrategy;
    26| import com.hazelcast.client.impl.ClientTypes;
    27| import com.hazelcast.client.impl.client.ClientPrincipal;
    28| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    29| import com.hazelcast.client.impl.protocol.AuthenticationStatus;
    30| import com.hazelcast.client.impl.protocol.ClientMessage;
    31| import com.hazelcast.client.impl.protocol.codec.ClientAuthenticationCodec;
    32| import com.hazelcast.client.impl.protocol.codec.ClientAuthenticationCustomCodec;
    33| import com.hazelcast.client.spi.ClientContext;
    34| import com.hazelcast.client.spi.impl.ClientExecutionServiceImpl;
    35| import com.hazelcast.client.spi.impl.ClientInvocation;
    36| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    37| import com.hazelcast.config.SSLConfig;
    38| import com.hazelcast.config.SocketInterceptorConfig;
    39| import com.hazelcast.core.ExecutionCallback;
    40| import com.hazelcast.core.HazelcastException;
    41| import com.hazelcast.instance.BuildInfoProvider;
    42| import com.hazelcast.internal.networking.Channel;
    43| import com.hazelcast.internal.networking.ChannelErrorHandler;
    44| import com.hazelcast.internal.networking.nio.NioNetworking;
    45| import com.hazelcast.internal.serialization.InternalSerializationService;
    46| import com.hazelcast.logging.ILogger;
    47| import com.hazelcast.nio.Address;
    48| import com.hazelcast.nio.ClassLoaderUtil;
    49| import com.hazelcast.nio.Connection;
    50| import com.hazelcast.nio.ConnectionListener;
    51| import com.hazelcast.nio.SocketInterceptor;
    52| import com.hazelcast.nio.serialization.Data;
    53| import com.hazelcast.security.Credentials;
    54| import com.hazelcast.security.ICredentialsFactory;
    55| import com.hazelcast.security.UsernamePasswordCredentials;
    56| import com.hazelcast.spi.properties.HazelcastProperties;
    57| import com.hazelcast.spi.serialization.SerializationService;
    58| import com.hazelcast.util.AddressUtil;
    59| import java.io.EOFException;
    60| import java.io.IOException;
    61| import java.net.InetSocketAddress;
    62| import java.net.Socket;
    63| import java.net.SocketAddress;
    64| import java.nio.channels.SocketChannel;
    65| import java.util.Collection;
    66| import java.util.LinkedList;
    67| import java.util.concurrent.ConcurrentHashMap;
    68| import java.util.concurrent.ConcurrentMap;
    69| import java.util.concurrent.CopyOnWriteArrayList;
    70| import java.util.concurrent.Future;
    71| import java.util.concurrent.ScheduledFuture;
    72| import java.util.concurrent.TimeoutException;
    73| import java.util.concurrent.atomic.AtomicInteger;
    74| import static com.hazelcast.client.spi.properties.ClientProperty.ALLOW_INVOCATIONS_WHEN_DISCONNECTED;
    75| import static com.hazelcast.client.spi.properties.ClientProperty.IO_BALANCER_INTERVAL_SECONDS;
    76| import static com.hazelcast.client.spi.properties.ClientProperty.IO_INPUT_THREAD_COUNT;
    77| import static com.hazelcast.client.spi.properties.ClientProperty.IO_OUTPUT_THREAD_COUNT;
    78| import static com.hazelcast.nio.IOUtil.closeResource;
    79| import static com.hazelcast.util.ExceptionUtil.rethrow;
    80| import static java.util.concurrent.TimeUnit.MILLISECONDS;
    81| /**
    82|  * Implementation of {@link ClientConnectionManager}.
    83|  */
    84| @SuppressWarnings("checkstyle:classdataabstractioncoupling")
    85| public class ClientConnectionManagerImpl implements ClientConnectionManager {
    86|     private static final int DEFAULT_SSL_THREAD_COUNT = 3;
    87|     protected final AtomicInteger connectionIdGen = new AtomicInteger();
    88|     protected volatile boolean alive;
    89|     private final ILogger logger;
    90|     private final int connectionTimeoutMillis;
    91|     private final HazelcastClientInstanceImpl client;
    92|     private final SocketInterceptor socketInterceptor;
    93|     private final ClientExecutionServiceImpl executionService;
    94|     private final AddressTranslator addressTranslator;
    95|     private final ConcurrentMap<Address, ClientConnection> activeConnections = new ConcurrentHashMap<Address, ClientConnection>();
    96|     private final ConcurrentMap<Address, AuthenticationFuture> connectionsInProgress =
    97|             new ConcurrentHashMap<Address, AuthenticationFuture>();
    98|     private final Collection<ConnectionListener> connectionListeners = new CopyOnWriteArrayList<ConnectionListener>();
    99|     private final boolean allowInvokeWhenDisconnected;
   100|     private final ICredentialsFactory credentialsFactory;
   101|     private final NioNetworking networking;
   102|     private final HeartbeatManager heartbeat;
   103|     private final ClusterConnector clusterConnector;
   104|     private final long authenticationTimeout;
   105|     private volatile ClientPrincipal principal;
   106|     private final ClientConnectionStrategy connectionStrategy;
   107|     private final LinkedList<Integer> outboundPorts = new LinkedList<Integer>();
   108|     private final int outboundPortCount;
   109|     private volatile Credentials lastCredentials;
   110|     public ClientConnectionManagerImpl(HazelcastClientInstanceImpl client, AddressTranslator addressTranslator,
   111|                                        Collection<AddressProvider> addressProviders) {
   112|         allowInvokeWhenDisconnected = client.getProperties().getBoolean(ALLOW_INVOCATIONS_WHEN_DISCONNECTED);
   113|         this.client = client;
   114|         this.addressTranslator = addressTranslator;
   115|         this.logger = client.getLoggingService().getLogger(ClientConnectionManager.class);
   116|         ClientNetworkConfig networkConfig = client.getClientConfig().getNetworkConfig();
   117|         final int connTimeout = networkConfig.getConnectionTimeout();
   118|         this.connectionTimeoutMillis = connTimeout == 0 ? Integer.MAX_VALUE : connTimeout;
   119|         this.executionService = (ClientExecutionServiceImpl) client.getClientExecutionService();
   120|         this.networking = initNetworking(client);
   121|         this.socketInterceptor = initSocketInterceptor(networkConfig.getSocketInterceptorConfig());
   122|         this.credentialsFactory = client.getCredentialsFactory();
   123|         this.connectionStrategy = initializeStrategy(client);
   124|         this.outboundPorts.addAll(getOutboundPorts(networkConfig));
   125|         this.outboundPortCount = outboundPorts.size();
   126|         this.heartbeat = new HeartbeatManager(this, client);
   127|         this.authenticationTimeout = heartbeat.getHeartbeatTimeout();
   128|         this.clusterConnector = new ClusterConnector(client, this, connectionStrategy, addressProviders);
   129|     }
   130|     private Collection<Integer> getOutboundPorts(ClientNetworkConfig networkConfig) {
   131|         Collection<Integer> outboundPorts = networkConfig.getOutboundPorts();
   132|         Collection<String> outboundPortDefinitions = networkConfig.getOutboundPortDefinitions();
   133|         return AddressUtil.getOutboundPorts(outboundPorts, outboundPortDefinitions);
   134|     }
   135|     private ClientConnectionStrategy initializeStrategy(HazelcastClientInstanceImpl client) {
   136|         ClientConnectionStrategy strategy;
   137|         String className = client.getProperties().get("hazelcast.client.connection.strategy.classname");
   138|         if (className != null) {
   139|             try {
   140|                 ClassLoader configClassLoader = client.getClientConfig().getClassLoader();
   141|                 return ClassLoaderUtil.newInstance(configClassLoader, className);
   142|             } catch (Exception e) {
   143|                 throw rethrow(e);
   144|             }
   145|         } else {
   146|             strategy = new DefaultClientConnectionStrategy();
   147|         }
   148|         return strategy;
   149|     }
   150|     public NioNetworking getNetworking() {
   151|         return networking;
   152|     }
   153|     protected NioNetworking initNetworking(HazelcastClientInstanceImpl client) {
   154|         HazelcastProperties properties = client.getProperties();
   155|         SSLConfig sslConfig = client.getClientConfig().getNetworkConfig().getSSLConfig();
   156|         boolean sslEnabled = sslConfig != null && sslConfig.isEnabled();
   157|         int configuredInputThreads = properties.getInteger(IO_INPUT_THREAD_COUNT);
   158|         int configuredOutputThreads = properties.getInteger(IO_OUTPUT_THREAD_COUNT);
   159|         int inputThreads;
   160|         if (configuredInputThreads == -1) {
   161|             inputThreads = sslEnabled ? DEFAULT_SSL_THREAD_COUNT : 1;
   162|         } else {
   163|             inputThreads = configuredInputThreads;
   164|         }
   165|         int outputThreads;
   166|         if (configuredOutputThreads == -1) {
   167|             outputThreads = sslEnabled ? DEFAULT_SSL_THREAD_COUNT : 1;
   168|         } else {
   169|             outputThreads = configuredOutputThreads;
   170|         }
   171|         return new NioNetworking(
   172|                 new NioNetworking.Context()
   173|                         .loggingService(client.getLoggingService())
   174|                         .metricsRegistry(client.getMetricsRegistry())
   175|                         .threadNamePrefix(client.getName())
   176|                         .errorHandler(new ClientConnectionChannelErrorHandler())
   177|                         .inputThreadCount(inputThreads)
   178|                         .outputThreadCount(outputThreads)
   179|                         .balancerIntervalSeconds(properties.getInteger(IO_BALANCER_INTERVAL_SECONDS))
   180|                         .channelInitializer(client.getClientExtension().createChannelInitializer()));
   181|     }
   182|     private SocketInterceptor initSocketInterceptor(SocketInterceptorConfig sic) {
   183|         if (sic != null && sic.isEnabled()) {
   184|             ClientExtension clientExtension = client.getClientExtension();
   185|             return clientExtension.createSocketInterceptor();
   186|         }
   187|         return null;
   188|     }
   189|     public ClientConnectionStrategy getConnectionStrategy() {
   190|         return connectionStrategy;
   191|     }
   192|     @Override
   193|     public Collection<ClientConnection> getActiveConnections() {
   194|         return activeConnections.values();
   195|     }
   196|     @Override
   197|     public boolean isAlive() {
   198|         return alive;
   199|     }
   200|     public synchronized void start(ClientContext clientContext) {
   201|         if (alive) {
   202|             return;
   203|         }
   204|         alive = true;
   205|         startNetworking();
   206|         heartbeat.start();
   207|         connectionStrategy.init(clientContext);
   208|         connectionStrategy.start();
   209|     }
   210|     protected void startNetworking() {
   211|         networking.start();
   212|     }
   213|     public synchronized void shutdown() {
   214|         if (!alive) {
   215|             return;
   216|         }
   217|         alive = false;
   218|         for (Connection connection : activeConnections.values()) {
   219|             connection.close("Hazelcast client is shutting down", null);
   220|         }
   221|         clusterConnector.shutdown();
   222|         stopNetworking();
   223|         connectionListeners.clear();
   224|         heartbeat.shutdown();
   225|         connectionStrategy.shutdown();
   226|         credentialsFactory.destroy();
   227|     }
   228|     @Override
   229|     public ClientPrincipal getPrincipal() {
   230|         return principal;
   231|     }
   232|     private void setPrincipal(ClientPrincipal principal) {
   233|         this.principal = principal;
   234|     }
   235|     protected void stopNetworking() {
   236|         networking.shutdown();
   237|     }
   238|     @Override
   239|     public Connection getActiveConnection(Address target) {
   240|         if (target == null) {
   241|             return null;
   242|         }
   243|         return activeConnections.get(target);
   244|     }
   245|     @Override
   246|     public Connection getOrConnect(Address address) throws IOException {
   247|         return getOrConnect(address, false);
   248|     }
   249|     @Override
   250|     public Connection getOrTriggerConnect(Address target, boolean acquiresResources) throws IOException {
   251|         Connection connection = getConnection(target, false, acquiresResources);
   252|         if (connection != null) {
   253|             return connection;
   254|         }
   255|         triggerConnect(target, false);
   256|         return null;

# --- HUNK 2: Lines 259-480 ---
   259|         checkAllowed(target, asOwner, acquiresResources);
   260|         if (target == null) {
   261|             throw new IllegalStateException("Address can not be null");
   262|         }
   263|         ClientConnection connection = activeConnections.get(target);
   264|         if (connection != null) {
   265|             if (!asOwner) {
   266|                 return connection;
   267|             }
   268|             if (connection.isAuthenticatedAsOwner()) {
   269|                 return connection;
   270|             }
   271|         }
   272|         return null;
   273|     }
   274|     private void checkAllowed(Address target, boolean asOwner, boolean acquiresResources) throws IOException {
   275|         if (!alive) {
   276|             throw new HazelcastClientNotActiveException("ConnectionManager is not active!");
   277|         }
   278|         if (asOwner) {
   279|             connectionStrategy.beforeConnectToCluster(target);
   280|             return;
   281|         }
   282|         try {
   283|             connectionStrategy.beforeGetConnection(target);
   284|         } catch (HazelcastClientOfflineException e) {
   285|             if (allowInvokeWhenDisconnected && !acquiresResources) {
   286|                 return;
   287|             }
   288|             throw e;
   289|         }
   290|         if (getOwnerConnection() == null) {
   291|             if (allowInvokeWhenDisconnected && !acquiresResources) {
   292|                 return;
   293|             }
   294|             throw new IOException("Owner connection is not available!");
   295|         }
   296|     }
   297|     @Override
   298|     public Address getOwnerConnectionAddress() {
   299|         return clusterConnector.getOwnerConnectionAddress();
   300|     }
   301|     Connection getOrConnect(Address address, boolean asOwner) {
   302|         try {
   303|             while (true) {
   304|                 ClientConnection connection = (ClientConnection) getConnection(address, asOwner, true);
   305|                 if (connection != null) {
   306|                     return connection;
   307|                 }
   308|                 AuthenticationFuture future = triggerConnect(address, asOwner);
   309|                 connection = (ClientConnection) future.get();
   310|                 if (!asOwner) {
   311|                     return connection;
   312|                 }
   313|                 if (connection.isAuthenticatedAsOwner()) {
   314|                     return connection;
   315|                 }
   316|             }
   317|         } catch (Throwable e) {
   318|             throw rethrow(e);
   319|         }
   320|     }
   321|     private AuthenticationFuture triggerConnect(Address target, boolean asOwner) {
   322|         if (!asOwner) {
   323|             connectionStrategy.beforeOpenConnection(target);
   324|         }
   325|         AuthenticationFuture future = new AuthenticationFuture();
   326|         AuthenticationFuture oldFuture = connectionsInProgress.putIfAbsent(target, future);
   327|         if (oldFuture == null) {
   328|             executionService.execute(new InitConnectionTask(target, asOwner, future));
   329|             return future;
   330|         }
   331|         return oldFuture;
   332|     }
   333|     @Override
   334|     public ClientConnection getOwnerConnection() {
   335|         Address ownerConnectionAddress = clusterConnector.getOwnerConnectionAddress();
   336|         if (ownerConnectionAddress == null) {
   337|             return null;
   338|         }
   339|         return (ClientConnection) getActiveConnection(ownerConnectionAddress);
   340|     }
   341|     private void fireConnectionAddedEvent(ClientConnection connection) {
   342|         for (ConnectionListener connectionListener : connectionListeners) {
   343|             connectionListener.connectionAdded(connection);
   344|         }
   345|         connectionStrategy.onConnect(connection);
   346|     }
   347|     private void fireConnectionRemovedEvent(ClientConnection connection) {
   348|         if (connection.isAuthenticatedAsOwner()) {
   349|             clusterConnector.disconnectFromCluster(connection);
   350|         }
   351|         for (ConnectionListener listener : connectionListeners) {
   352|             listener.connectionRemoved(connection);
   353|         }
   354|         connectionStrategy.onDisconnect(connection);
   355|     }
   356|     private boolean useAnyOutboundPort() {
   357|         return outboundPortCount == 0;
   358|     }
   359|     private int acquireOutboundPort() {
   360|         if (outboundPortCount == 0) {
   361|             return 0;
   362|         }
   363|         synchronized (outboundPorts) {
   364|             final Integer port = outboundPorts.removeFirst();
   365|             outboundPorts.addLast(port);
   366|             return port;
   367|         }
   368|     }
   369|     private void bindSocketToPort(Socket socket) throws IOException {
   370|         if (useAnyOutboundPort()) {
   371|             SocketAddress socketAddress = new InetSocketAddress(0);
   372|             socket.bind(socketAddress);
   373|         } else {
   374|             int retryCount = outboundPortCount * 2;
   375|             IOException ex = null;
   376|             for (int i = 0; i < retryCount; i++) {
   377|                 int port = acquireOutboundPort();
   378|                 if (port == 0) {
   379|                     return;
   380|                 }
   381|                 SocketAddress socketAddress = new InetSocketAddress(port);
   382|                 try {
   383|                     socket.bind(socketAddress);
   384|                     return;
   385|                 } catch (IOException e) {
   386|                     ex = e;
   387|                     logger.finest("Could not bind port[ " + port + "]: " + e.getMessage());
   388|                 }
   389|             }
   390|             throw ex;
   391|         }
   392|     }
   393|     protected ClientConnection createSocketConnection(final Address remoteAddress) throws IOException {
   394|         SocketChannel socketChannel = null;
   395|         try {
   396|             socketChannel = SocketChannel.open();
   397|             Socket socket = socketChannel.socket();
   398|             bindSocketToPort(socket);
   399|             Channel channel = networking.register(socketChannel, true);
   400|             channel.connect(remoteAddress.getInetSocketAddress(), connectionTimeoutMillis);
   401|             ClientConnection connection
   402|                     = new ClientConnection(client, connectionIdGen.incrementAndGet(), channel);
   403|             socketChannel.configureBlocking(true);
   404|             if (socketInterceptor != null) {
   405|                 socketInterceptor.onConnect(socket);
   406|             }
   407|             channel.start();
   408|             return connection;
   409|         } catch (Exception e) {
   410|             closeResource(socketChannel);
   411|             throw rethrow(e, IOException.class);
   412|         }
   413|     }
   414|     void onClose(Connection connection) {
   415|         removeFromActiveConnections(connection);
   416|     }
   417|     private void removeFromActiveConnections(Connection connection) {
   418|         Address endpoint = connection.getEndPoint();
   419|         if (endpoint == null) {
   420|             if (logger.isFinestEnabled()) {
   421|                 logger.finest("Destroying " + connection + ", but it has end-point set to null "
   422|                         + "-> not removing it from a connection map");
   423|             }
   424|             return;
   425|         }
   426|         if (activeConnections.remove(endpoint, connection)) {
   427|             logger.info("Removed connection to endpoint: " + endpoint + ", connection: " + connection);
   428|             fireConnectionRemovedEvent((ClientConnection) connection);
   429|         } else {
   430|             if (logger.isFinestEnabled()) {
   431|                 logger.finest("Destroying a connection, but there is no mapping " + endpoint + " -> " + connection
   432|                         + " in the connection map.");
   433|             }
   434|         }
   435|     }
   436|     @Override
   437|     public void addConnectionListener(ConnectionListener connectionListener) {
   438|         connectionListeners.add(connectionListener);
   439|     }
   440|     private void authenticate(final Address target, final ClientConnection connection, final boolean asOwner,
   441|                               final AuthenticationFuture future) {
   442|         final ClientPrincipal principal = getPrincipal();
   443|         ClientMessage clientMessage = encodeAuthenticationRequest(asOwner, client.getSerializationService(), principal);
   444|         ClientInvocation clientInvocation = new ClientInvocation(client, clientMessage, null, connection);
   445|         ClientInvocationFuture invocationFuture = clientInvocation.invokeUrgent();
   446|         ScheduledFuture timeoutTaskFuture = executionService.schedule(
   447|                 new TimeoutAuthenticationTask(invocationFuture), authenticationTimeout, MILLISECONDS);
   448|         invocationFuture.andThen(new AuthCallback(connection, asOwner, target, future, timeoutTaskFuture));
   449|     }
   450|     private ClientMessage encodeAuthenticationRequest(boolean asOwner, SerializationService ss, ClientPrincipal principal) {
   451|         byte serializationVersion = ((InternalSerializationService) ss).getVersion();
   452|         String uuid = null;
   453|         String ownerUuid = null;
   454|         if (principal != null) {
   455|             uuid = principal.getUuid();
   456|             ownerUuid = principal.getOwnerUuid();
   457|         }
   458|         ClientMessage clientMessage;
   459|         Credentials credentials = credentialsFactory.newCredentials();
   460|         lastCredentials = credentials;
   461|         if (credentials.getClass().equals(UsernamePasswordCredentials.class)) {
   462|             UsernamePasswordCredentials cr = (UsernamePasswordCredentials) credentials;
   463|             clientMessage = ClientAuthenticationCodec
   464|                     .encodeRequest(cr.getUsername(), cr.getPassword(), uuid, ownerUuid, asOwner, ClientTypes.JAVA,
   465|                             serializationVersion, BuildInfoProvider.getBuildInfo().getVersion());
   466|         } else {
   467|             Data data = ss.toData(credentials);
   468|             clientMessage = ClientAuthenticationCustomCodec.encodeRequest(data, uuid, ownerUuid,
   469|                     asOwner, ClientTypes.JAVA, serializationVersion, BuildInfoProvider.getBuildInfo().getVersion());
   470|         }
   471|         return clientMessage;
   472|     }
   473|     private void onAuthenticated(Address target, ClientConnection connection) {
   474|         ClientConnection oldConnection = activeConnections.put(connection.getEndPoint(), connection);
   475|         if (oldConnection == null) {
   476|             if (logger.isFinestEnabled()) {
   477|                 logger.finest("Authentication succeeded for " + connection
   478|                         + " and there was no old connection to this end-point");
   479|             }
   480|             fireConnectionAddedEvent(connection);

# --- HUNK 3: Lines 491-535 ---
   491|         we need to remove it back from active connections.
   492|         Race description from https://github.com/hazelcast/hazelcast/pull/8832.(A little bit changed)
   493|         - open a connection client -> member
   494|         - send auth message
   495|         - receive auth reply -> reply processing is offloaded to an executor. Did not start to run yet.
   496|         - member closes the connection -> the connection is trying to removed from map
   497|                                                              but it was not there to begin with
   498|         - the executor start processing the auth reply -> it put the connection to the connection map.
   499|         - we end up with a closed connection in activeConnections map */
   500|         if (!connection.isAlive()) {
   501|             removeFromActiveConnections(connection);
   502|         }
   503|     }
   504|     private void onAuthenticationFailed(Address target, ClientConnection connection, Throwable cause) {
   505|         if (logger.isFinestEnabled()) {
   506|             logger.finest("Authentication of " + connection + " failed.", cause);
   507|         }
   508|         connection.close(null, cause);
   509|         connectionsInProgress.remove(target);
   510|     }
   511|     public Credentials getLastCredentials() {
   512|         return lastCredentials;
   513|     }
   514|     Collection<Address> getPossibleMemberAddresses() {
   515|         return clusterConnector.getPossibleMemberAddresses();
   516|     }
   517|     private class TimeoutAuthenticationTask implements Runnable {
   518|         private final ClientInvocationFuture future;
   519|         TimeoutAuthenticationTask(ClientInvocationFuture future) {
   520|             this.future = future;
   521|         }
   522|         @Override
   523|         public void run() {
   524|             if (future.isDone()) {
   525|                 return;
   526|             }
   527|             future.complete(new TimeoutException("Authentication response did not come back in "
   528|                     + authenticationTimeout + " millis"));
   529|         }
   530|     }
   531|     private class InitConnectionTask implements Runnable {
   532|         private final Address target;
   533|         private final boolean asOwner;
   534|         private final AuthenticationFuture future;
   535|         InitConnectionTask(Address target, boolean asOwner, AuthenticationFuture future) {

# --- HUNK 4: Lines 572-651 ---
   572|     private class ClientConnectionChannelErrorHandler implements ChannelErrorHandler {
   573|         @Override
   574|         public void onError(Channel channel, Throwable cause) {
   575|             if (channel == null) {
   576|                 logger.severe(cause);
   577|             } else {
   578|                 if (cause instanceof OutOfMemoryError) {
   579|                     logger.severe(cause);
   580|                 }
   581|                 ClientConnection connection = (ClientConnection) channel.attributeMap().get(ClientConnection.class);
   582|                 if (cause instanceof EOFException) {
   583|                     connection.close("Connection closed by the other side", cause);
   584|                 } else {
   585|                     connection.close("Exception in " + connection + ", thread=" + Thread.currentThread().getName(), cause);
   586|                 }
   587|             }
   588|         }
   589|     }
   590|     @Override
   591|     public void connectToCluster() {
   592|         clusterConnector.connectToCluster();
   593|     }
   594|     @Override
   595|     public Future<Void> connectToClusterAsync() {
   596|         return clusterConnector.connectToClusterAsync();
   597|     }
   598|     private class AuthCallback implements ExecutionCallback<ClientMessage> {
   599|         private final ClientConnection connection;
   600|         private final boolean asOwner;
   601|         private final Address target;
   602|         private final AuthenticationFuture future;
   603|         private final ScheduledFuture timeoutTaskFuture;
   604|         AuthCallback(ClientConnection connection, boolean asOwner, Address target,
   605|                      AuthenticationFuture future, ScheduledFuture timeoutTaskFuture) {
   606|             this.connection = connection;
   607|             this.asOwner = asOwner;
   608|             this.target = target;
   609|             this.future = future;
   610|             this.timeoutTaskFuture = timeoutTaskFuture;
   611|         }
   612|         @Override
   613|         public void onResponse(ClientMessage response) {
   614|             timeoutTaskFuture.cancel(true);
   615|             ClientAuthenticationCodec.ResponseParameters result;
   616|             try {
   617|                 result = ClientAuthenticationCodec.decodeResponse(response);
   618|             } catch (HazelcastException e) {
   619|                 onFailure(e);
   620|                 return;
   621|             }
   622|             AuthenticationStatus authenticationStatus = AuthenticationStatus.getById(result.status);
   623|             switch (authenticationStatus) {
   624|                 case AUTHENTICATED:
   625|                     connection.setConnectedServerVersion(result.serverHazelcastVersion);
   626|                     connection.setRemoteEndpoint(result.address);
   627|                     if (asOwner) {
   628|                         connection.setIsAuthenticatedAsOwner();
   629|                         ClientPrincipal principal = new ClientPrincipal(result.uuid, result.ownerUuid);
   630|                         setPrincipal(principal);
   631|                         clusterConnector.setOwnerConnectionAddress(connection.getEndPoint());
   632|                         logger.info("Setting " + connection + " as owner with principal " + principal);
   633|                     }
   634|                     onAuthenticated(target, connection);
   635|                     future.onSuccess(connection);
   636|                     break;
   637|                 case CREDENTIALS_FAILED:
   638|                     onFailure(new AuthenticationException("Invalid credentials! Principal: " + principal));
   639|                     break;
   640|                 default:
   641|                     onFailure(new AuthenticationException("Authentication status code not supported. status: "
   642|                             + authenticationStatus));
   643|             }
   644|         }
   645|         @Override
   646|         public void onFailure(Throwable t) {
   647|             timeoutTaskFuture.cancel(true);
   648|             onAuthenticationFailed(target, connection, t);
   649|             future.onFailure(t);
   650|         }
   651|     }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/ClientICMPManager.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 128-159 ---
   128|                     logger.log(level, msg);
   129|                     return true;
   130|                 }
   131|             } catch (ConnectException ignored) {
   132|                 ignore(ignored);
   133|             }
   134|             return false;
   135|         }
   136|         public void run() {
   137|             try {
   138|                 Address address = connection.getEndPoint();
   139|                 logger.fine(format("will ping %s", address));
   140|                 if (doPing(address, Level.FINE)) {
   141|                     icmpFailureDetector.heartbeat(connection);
   142|                     return;
   143|                 }
   144|                 icmpFailureDetector.logAttempt(connection);
   145|                 String reason = format("Could not ping %s", address);
   146|                 logger.warning(reason);
   147|                 if (!icmpFailureDetector.isAlive(connection)) {
   148|                     heartbeatManager.onHeartbeatStopped(connection, "ICMP ping time out");
   149|                 }
   150|             } catch (Throwable ignored) {
   151|                 ignore(ignored);
   152|             } finally {
   153|                 if (!connection.isAlive()) {
   154|                     icmpFailureDetector.remove(connection);
   155|                 }
   156|             }
   157|         }
   158|     }
   159| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/ClientPlainChannelInitializer.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-69 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.connection.nio;
    17| import com.hazelcast.client.config.SocketOptions;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.util.ClientMessageDecoder;
    20| import com.hazelcast.client.impl.protocol.util.ClientMessageEncoder;
    21| import com.hazelcast.internal.networking.Channel;
    22| import com.hazelcast.internal.networking.ChannelInitializer;
    23| import com.hazelcast.util.function.Consumer;
    24| import static com.hazelcast.client.config.SocketOptions.KILO_BYTE;
    25| import static com.hazelcast.internal.networking.ChannelOption.DIRECT_BUF;
    26| import static com.hazelcast.internal.networking.ChannelOption.SO_KEEPALIVE;
    27| import static com.hazelcast.internal.networking.ChannelOption.SO_LINGER;
    28| import static com.hazelcast.internal.networking.ChannelOption.SO_RCVBUF;
    29| import static com.hazelcast.internal.networking.ChannelOption.SO_REUSEADDR;
    30| import static com.hazelcast.internal.networking.ChannelOption.SO_SNDBUF;
    31| import static com.hazelcast.internal.networking.ChannelOption.SO_TIMEOUT;
    32| import static com.hazelcast.internal.networking.ChannelOption.TCP_NODELAY;
    33| /**
    34|  * Client side ChannelInitializer for connections without SSL/TLS. Client in this
    35|  * case is a real client using client protocol etc.
    36|  *
    37|  * It will automatically send the Client Protocol to the server and configure the
    38|  * correct buffers/handlers.
    39|  */
    40| public class ClientPlainChannelInitializer implements ChannelInitializer {
    41|     private final boolean directBuffer;
    42|     private final SocketOptions socketOptions;
    43|     public ClientPlainChannelInitializer(SocketOptions socketOptions, boolean directBuffer) {
    44|         this.socketOptions = socketOptions;
    45|         this.directBuffer = directBuffer;
    46|     }
    47|     @Override
    48|     public void initChannel(Channel channel) {
    49|         channel.options()
    50|                 .setOption(SO_SNDBUF, KILO_BYTE * socketOptions.getBufferSize())
    51|                 .setOption(SO_RCVBUF, KILO_BYTE * socketOptions.getBufferSize())
    52|                 .setOption(SO_REUSEADDR, socketOptions.isReuseAddress())
    53|                 .setOption(SO_KEEPALIVE, socketOptions.isKeepAlive())
    54|                 .setOption(SO_LINGER, socketOptions.getLingerSeconds())
    55|                 .setOption(SO_TIMEOUT, 0)
    56|                 .setOption(TCP_NODELAY, socketOptions.isTcpNoDelay())
    57|                 .setOption(DIRECT_BUF, directBuffer);
    58|         final ClientConnection connection = (ClientConnection) channel.attributeMap().get(ClientConnection.class);
    59|         ClientMessageDecoder decoder = new ClientMessageDecoder(connection, new Consumer<ClientMessage>() {
    60|             @Override
    61|             public void accept(ClientMessage message) {
    62|                 connection.handleClientMessage(message);
    63|             }
    64|         });
    65|         channel.inboundPipeline().addLast(decoder);
    66|         channel.outboundPipeline().addLast(new ClientMessageEncoder());
    67|         channel.outboundPipeline().addLast(new ClientProtocolEncoder());
    68|     }
    69| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/ClientProtocolEncoder.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-48 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.connection.nio;
    17| import com.hazelcast.internal.networking.OutboundHandler;
    18| import com.hazelcast.internal.networking.HandlerStatus;
    19| import java.nio.ByteBuffer;
    20| import static com.hazelcast.internal.networking.HandlerStatus.CLEAN;
    21| import static com.hazelcast.internal.networking.HandlerStatus.DIRTY;
    22| import static com.hazelcast.nio.Protocols.CLIENT_BINARY_NEW;
    23| import static com.hazelcast.nio.Protocols.PROTOCOL_LENGTH;
    24| import static com.hazelcast.util.StringUtil.stringToBytes;
    25| /**
    26|  * A {@link OutboundHandler} that writes the client protocol bytes
    27|  * and once they have been fully written, it removes itself from pipeline.
    28|  *
    29|  * On a plain connection, this should be the last encoder in the pipeline.
    30|  *
    31|  * Even though the ClientProtocolEncoder has a ByteBuffer as src, it will
    32|  * never consume bytes from this source.
    33|  */
    34| public class ClientProtocolEncoder extends OutboundHandler<ByteBuffer, ByteBuffer> {
    35|     @Override
    36|     public void handlerAdded() {
    37|         initDstBuffer(PROTOCOL_LENGTH, stringToBytes(CLIENT_BINARY_NEW));
    38|     }
    39|     @Override
    40|     public HandlerStatus onWrite() {
    41|         if (dst.remaining() == 0) {
    42|             channel.outboundPipeline().remove(this);
    43|             return CLEAN;
    44|         } else {
    45|             return DIRTY;
    46|         }
    47|     }
    48| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/ClusterConnector.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-320 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.connection.nio;
    17| import com.hazelcast.client.config.ClientConfig;
    18| import com.hazelcast.client.config.ClientConnectionStrategyConfig;
    19| import com.hazelcast.client.config.ClientNetworkConfig;
    20| import com.hazelcast.client.config.ConnectionRetryConfig;
    21| import com.hazelcast.client.connection.AddressProvider;
    22| import com.hazelcast.client.connection.ClientConnectionManager;
    23| import com.hazelcast.client.connection.ClientConnectionStrategy;
    24| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    25| import com.hazelcast.client.impl.clientside.LifecycleServiceImpl;
    26| import com.hazelcast.client.spi.impl.ClientExecutionServiceImpl;
    27| import com.hazelcast.core.LifecycleEvent;
    28| import com.hazelcast.core.Member;
    29| import com.hazelcast.logging.ILogger;
    30| import com.hazelcast.nio.Address;
    31| import com.hazelcast.nio.Connection;
    32| import com.hazelcast.util.executor.SingleExecutorThreadFactory;
    33| import java.util.ArrayList;
    34| import java.util.Collection;
    35| import java.util.Collections;
    36| import java.util.HashSet;
    37| import java.util.LinkedHashSet;
    38| import java.util.List;
    39| import java.util.Random;
    40| import java.util.Set;
    41| import java.util.concurrent.Callable;
    42| import java.util.concurrent.ExecutorService;
    43| import java.util.concurrent.Executors;
    44| import java.util.concurrent.Future;
    45| import static com.hazelcast.client.spi.properties.ClientProperty.SHUFFLE_MEMBER_LIST;
    46| import static com.hazelcast.util.ExceptionUtil.rethrow;
    47| /**
    48|  * Helper to ClientConnectionManager.
    49|  * selecting owner connection, connecting and disconnecting from cluster implemented in this class.
    50|  */
    51| class ClusterConnector {
    52|     private static final int DEFAULT_CONNECTION_ATTEMPT_LIMIT_SYNC = 2;
    53|     private static final int DEFAULT_CONNECTION_ATTEMPT_LIMIT_ASYNC = 20;
    54|     private final ILogger logger;
    55|     private final HazelcastClientInstanceImpl client;
    56|     private final ClientConnectionManagerImpl connectionManager;
    57|     private final ClientConnectionStrategy connectionStrategy;
    58|     private final ExecutorService clusterConnectionExecutor;
    59|     private final boolean shuffleMemberList;
    60|     private final WaitStrategy waitStrategy;
    61|     private final Collection<AddressProvider> addressProviders;
    62|     private volatile Address ownerConnectionAddress;
    63|     private volatile Address previousOwnerConnectionAddress;
    64|     ClusterConnector(HazelcastClientInstanceImpl client,
    65|                      ClientConnectionManagerImpl connectionManager,
    66|                      ClientConnectionStrategy connectionStrategy,
    67|                      Collection<AddressProvider> addressProviders) {
    68|         this.client = client;
    69|         this.connectionManager = connectionManager;
    70|         this.logger = client.getLoggingService().getLogger(ClientConnectionManager.class);
    71|         this.connectionStrategy = connectionStrategy;
    72|         this.clusterConnectionExecutor = createSingleThreadExecutorService(client);
    73|         this.shuffleMemberList = client.getProperties().getBoolean(SHUFFLE_MEMBER_LIST);
    74|         this.addressProviders = addressProviders;
    75|         this.waitStrategy = initializeWaitStrategy(client.getClientConfig());
    76|     }
    77|     private WaitStrategy initializeWaitStrategy(ClientConfig clientConfig) {
    78|         ClientConnectionStrategyConfig connectionStrategyConfig = client.getClientConfig().getConnectionStrategyConfig();
    79|         ConnectionRetryConfig expoRetryConfig = connectionStrategyConfig.getConnectionRetryConfig();
    80|         if (expoRetryConfig.isEnabled()) {
    81|             return new ExponentialWaitStrategy(expoRetryConfig.getInitialBackoffMillis(),
    82|                     expoRetryConfig.getMaxBackoffMillis(),
    83|                     expoRetryConfig.getMultiplier(),
    84|                     expoRetryConfig.isFailOnMaxBackoff(),
    85|                     expoRetryConfig.getJitter());
    86|         }
    87|         ClientNetworkConfig networkConfig = clientConfig.getNetworkConfig();
    88|         int connectionAttemptPeriod = networkConfig.getConnectionAttemptPeriod();
    89|         boolean isAsync = connectionStrategyConfig.isAsyncStart();
    90|         int connectionAttemptLimit = networkConfig.getConnectionAttemptLimit();
    91|         if (connectionAttemptLimit < 0) {
    92|             connectionAttemptLimit = isAsync ? DEFAULT_CONNECTION_ATTEMPT_LIMIT_ASYNC
    93|                     : DEFAULT_CONNECTION_ATTEMPT_LIMIT_SYNC;
    94|         } else {
    95|             connectionAttemptLimit = connectionAttemptLimit == 0 ? Integer.MAX_VALUE : connectionAttemptLimit;
    96|         }
    97|         return new DefaultWaitStrategy(connectionAttemptPeriod, connectionAttemptLimit);
    98|     }
    99|     void connectToCluster() {
   100|         try {
   101|             connectToClusterAsync().get();
   102|         } catch (Exception e) {
   103|             throw rethrow(e);
   104|         }
   105|     }
   106|     Address getOwnerConnectionAddress() {
   107|         return ownerConnectionAddress;
   108|     }
   109|     void setOwnerConnectionAddress(Address ownerConnectionAddress) {
   110|         this.previousOwnerConnectionAddress = this.ownerConnectionAddress;
   111|         this.ownerConnectionAddress = ownerConnectionAddress;
   112|     }
   113|     private Connection connectAsOwner(Address address) {
   114|         Connection connection = null;
   115|         try {
   116|             logger.info("Trying to connect to " + address + " as owner member");
   117|             connection = connectionManager.getOrConnect(address, true);
   118|             client.onClusterConnect(connection);
   119|             fireConnectionEvent(LifecycleEvent.LifecycleState.CLIENT_CONNECTED);
   120|             connectionStrategy.onConnectToCluster();
   121|         } catch (Exception e) {
   122|             logger.warning("Exception during initial connection to " + address + ", exception " + e);
   123|             if (null != connection) {
   124|                 connection.close("Could not connect to " + address + " as owner", e);
   125|             }
   126|             return null;
   127|         }
   128|         return connection;
   129|     }
   130|     void disconnectFromCluster(final ClientConnection connection) {
   131|         clusterConnectionExecutor.execute(new Runnable() {
   132|             @Override
   133|             public void run() {
   134|                 Address endpoint = connection.getEndPoint();
   135|                 if (endpoint == null || !endpoint.equals(ownerConnectionAddress)) {
   136|                     return;
   137|                 }
   138|                 setOwnerConnectionAddress(null);
   139|                 connectionStrategy.onDisconnectFromCluster();
   140|                 if (client.getLifecycleService().isRunning()) {
   141|                     fireConnectionEvent(LifecycleEvent.LifecycleState.CLIENT_DISCONNECTED);
   142|                 }
   143|             }
   144|         });
   145|     }
   146|     private void fireConnectionEvent(final LifecycleEvent.LifecycleState state) {
   147|         final LifecycleServiceImpl lifecycleService = (LifecycleServiceImpl) client.getLifecycleService();
   148|         lifecycleService.fireLifecycleEvent(state);
   149|     }
   150|     private ExecutorService createSingleThreadExecutorService(HazelcastClientInstanceImpl client) {
   151|         ClassLoader classLoader = client.getClientConfig().getClassLoader();
   152|         SingleExecutorThreadFactory threadFactory = new SingleExecutorThreadFactory(classLoader, client.getName() + ".cluster-");
   153|         return Executors.newSingleThreadExecutor(threadFactory);
   154|     }
   155|     private void connectToClusterInternal() {
   156|         Set<Address> triedAddresses = new HashSet<Address>();
   157|         waitStrategy.reset();
   158|         do {
   159|             Collection<Address> addresses = getPossibleMemberAddresses();
   160|             for (Address address : addresses) {
   161|                 if (!client.getLifecycleService().isRunning()) {
   162|                     throw new IllegalStateException("Giving up on retrying to connect to cluster since client is shutdown.");
   163|                 }
   164|                 triedAddresses.add(address);
   165|                 if (connectAsOwner(address) != null) {
   166|                     return;
   167|                 }
   168|             }
   169|             if (!client.getLifecycleService().isRunning()) {
   170|                 throw new IllegalStateException("Client is being shutdown.");
   171|             }
   172|         } while (waitStrategy.sleep());
   173|         throw new IllegalStateException(
   174|                 "Unable to connect to any address! The following addresses were tried: " + triedAddresses);
   175|     }
   176|     Future<Void> connectToClusterAsync() {
   177|         return clusterConnectionExecutor.submit(new Callable<Void>() {
   178|             @Override
   179|             public Void call() throws Exception {
   180|                 try {
   181|                     connectToClusterInternal();
   182|                 } catch (Exception e) {
   183|                     logger.warning("Could not connect to cluster, shutting down the client. " + e.getMessage());
   184|                     new Thread(new Runnable() {
   185|                         @Override
   186|                         public void run() {
   187|                             try {
   188|                                 client.getLifecycleService().shutdown();
   189|                             } catch (Exception exception) {
   190|                                 logger.severe("Exception during client shutdown ", exception);
   191|                             }
   192|                         }
   193|                     }, client.getName() + ".clientShutdown-").start();
   194|                     throw rethrow(e);
   195|                 }
   196|                 return null;
   197|             }
   198|         });
   199|     }
   200|     Collection<Address> getPossibleMemberAddresses() {
   201|         LinkedHashSet<Address> addresses = new LinkedHashSet<Address>();
   202|         Collection<Member> memberList = client.getClientClusterService().getMemberList();
   203|         for (Member member : memberList) {
   204|             addresses.add(member.getAddress());
   205|         }
   206|         if (shuffleMemberList) {
   207|             addresses = (LinkedHashSet<Address>) shuffle(addresses);
   208|         }
   209|         LinkedHashSet<Address> providerAddresses = new LinkedHashSet<Address>();
   210|         for (AddressProvider addressProvider : addressProviders) {
   211|             try {
   212|                 providerAddresses.addAll(addressProvider.loadAddresses());
   213|             } catch (NullPointerException e) {
   214|                 throw e;
   215|             } catch (Exception e) {
   216|                 logger.warning("Exception from AddressProvider: " + addressProvider, e);
   217|             }
   218|         }
   219|         if (shuffleMemberList) {
   220|             providerAddresses = (LinkedHashSet<Address>) shuffle(providerAddresses);
   221|         }
   222|         addresses.addAll(providerAddresses);
   223|         if (previousOwnerConnectionAddress != null) {
   224|             /*
   225|              * Previous owner address is moved to last item in set so that client will not try to connect to same one immediately.
   226|              * It could be the case that address is removed because it is healthy(it not responding to heartbeat/pings)
   227|              * In that case, trying other addresses first to upgrade make more sense.
   228|              */
   229|             addresses.remove(previousOwnerConnectionAddress);
   230|             addresses.add(previousOwnerConnectionAddress);
   231|         }
   232|         return addresses;
   233|     }
   234|     private static <T> Set<T> shuffle(Set<T> set) {
   235|         List<T> shuffleMe = new ArrayList<T>(set);
   236|         Collections.shuffle(shuffleMe);
   237|         return new LinkedHashSet<T>(shuffleMe);
   238|     }
   239|     public void shutdown() {
   240|         ClientExecutionServiceImpl.shutdownExecutor("cluster", clusterConnectionExecutor, logger);
   241|     }
   242|     interface WaitStrategy {
   243|         void reset();
   244|         boolean sleep();
   245|     }
   246|     class DefaultWaitStrategy implements WaitStrategy {
   247|         private final int connectionAttemptPeriod;
   248|         private final int connectionAttemptLimit;
   249|         private int attempt;
   250|         DefaultWaitStrategy(int connectionAttemptPeriod, int connectionAttemptLimit) {
   251|             this.connectionAttemptPeriod = connectionAttemptPeriod;
   252|             this.connectionAttemptLimit = connectionAttemptLimit;
   253|         }
   254|         @Override
   255|         public void reset() {
   256|             attempt = 0;
   257|         }
   258|         @Override
   259|         public boolean sleep() {
   260|             attempt++;
   261|             if (attempt >= connectionAttemptLimit) {
   262|                 logger.warning(String.format("Unable to get alive cluster connection, attempt %d of %d.", attempt,
   263|                         connectionAttemptLimit));
   264|                 return false;
   265|             }
   266|             logger.warning(String.format("Unable to get alive cluster connection, try in %d ms later, attempt %d of %d.",
   267|                     connectionAttemptPeriod, attempt, connectionAttemptLimit));
   268|             try {
   269|                 Thread.sleep(connectionAttemptPeriod);
   270|             } catch (InterruptedException e) {
   271|                 Thread.currentThread().interrupt();
   272|                 return false;
   273|             }
   274|             return true;
   275|         }
   276|     }
   277|     class ExponentialWaitStrategy implements WaitStrategy {
   278|         private final int initialBackoffMillis;
   279|         private final int maxBackoffMillis;
   280|         private final double multiplier;
   281|         private final boolean failOnMaxBackoff;
   282|         private final double jitter;
   283|         private final Random random = new Random();
   284|         private int attempt;
   285|         private int currentBackoffMillis;
   286|         ExponentialWaitStrategy(int initialBackoffMillis, int maxBackoffMillis,
   287|                                 double multiplier, boolean failOnMaxBackoff, double jitter) {
   288|             this.initialBackoffMillis = initialBackoffMillis;
   289|             this.maxBackoffMillis = maxBackoffMillis;
   290|             this.multiplier = multiplier;
   291|             this.failOnMaxBackoff = failOnMaxBackoff;
   292|             this.jitter = jitter;
   293|         }
   294|         @Override
   295|         public void reset() {
   296|             attempt = 0;
   297|             currentBackoffMillis = Math.min(maxBackoffMillis, initialBackoffMillis);
   298|         }
   299|         @Override
   300|         public boolean sleep() {
   301|             attempt++;
   302|             if (failOnMaxBackoff && currentBackoffMillis >= maxBackoffMillis) {
   303|                 logger.warning(String.format("Unable to get alive cluster connection, attempt %d.", attempt));
   304|                 return false;
   305|             }
   306|             long actualSleepTime = (long) (currentBackoffMillis - (currentBackoffMillis * jitter)
   307|                     + (currentBackoffMillis * jitter * random.nextDouble()));
   308|             logger.warning(String.format("Unable to get alive cluster connection, try in %d ms later, attempt %d "
   309|                     + ", cap retry timeout millis %d", actualSleepTime, attempt, maxBackoffMillis));
   310|             try {
   311|                 Thread.sleep(actualSleepTime);
   312|             } catch (InterruptedException e) {
   313|                 Thread.currentThread().interrupt();
   314|                 return false;
   315|             }
   316|             currentBackoffMillis = (int) Math.min(currentBackoffMillis * multiplier, maxBackoffMillis);
   317|             return true;
   318|         }
   319|     }
   320| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/DefaultClientConnectionStrategy.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-40 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.connection.nio;
    17| import com.hazelcast.client.HazelcastClientOfflineException;
    18| import com.hazelcast.client.config.ClientConnectionStrategyConfig;
    19| import com.hazelcast.client.connection.ClientConnectionStrategy;
    20| import com.hazelcast.nio.Address;
    21| import java.util.concurrent.RejectedExecutionException;
    22| import static com.hazelcast.client.config.ClientConnectionStrategyConfig.ReconnectMode.ASYNC;
    23| import static com.hazelcast.client.config.ClientConnectionStrategyConfig.ReconnectMode.OFF;
    24| /**
    25|  * Default client connection strategy supporting async client start, reconnection modes and disabling reconnection.
    26|  */
    27| public class DefaultClientConnectionStrategy extends ClientConnectionStrategy {
    28|     private volatile boolean disconnectedFromCluster;
    29|     private boolean clientStartAsync;
    30|     private ClientConnectionStrategyConfig.ReconnectMode reconnectMode;
    31|     @Override
    32|     public void start() {
    33|         clientStartAsync = clientConnectionStrategyConfig.isAsyncStart();
    34|         reconnectMode = clientConnectionStrategyConfig.getReconnectMode();
    35|         if (clientStartAsync) {
    36|             clientContext.getConnectionManager().connectToClusterAsync();
    37|         } else {
    38|             clientContext.getConnectionManager().connectToCluster();
    39|         }
    40|     }

# --- HUNK 2: Lines 43-107 ---
    43|         if (isClusterAvailable()) {
    44|             return;
    45|         }
    46|         if (clientStartAsync && !disconnectedFromCluster) {
    47|             throw new HazelcastClientOfflineException("Client is connecting to cluster.");
    48|         }
    49|         if (reconnectMode == ASYNC && disconnectedFromCluster) {
    50|             throw new HazelcastClientOfflineException("Client is offline.");
    51|         }
    52|     }
    53|     @Override
    54|     public void beforeOpenConnection(Address target) {
    55|         if (isClusterAvailable()) {
    56|             return;
    57|         }
    58|         if (reconnectMode == ASYNC && disconnectedFromCluster) {
    59|             throw new HazelcastClientOfflineException("Client is offline");
    60|         }
    61|     }
    62|     @Override
    63|     public void beforeConnectToCluster(Address target) {
    64|     }
    65|     @Override
    66|     public void onConnectToCluster() {
    67|     }
    68|     @Override
    69|     public void onDisconnectFromCluster() {
    70|         disconnectedFromCluster = true;
    71|         if (reconnectMode == OFF) {
    72|             shutdownWithExternalThread();
    73|             return;
    74|         }
    75|         if (clientContext.getLifecycleService().isRunning()) {
    76|             try {
    77|                 clientContext.getConnectionManager().connectToClusterAsync();
    78|             } catch (RejectedExecutionException r) {
    79|                 shutdownWithExternalThread();
    80|             }
    81|         }
    82|     }
    83|     private void shutdownWithExternalThread() {
    84|         new Thread(new Runnable() {
    85|             @Override
    86|             public void run() {
    87|                 try {
    88|                     clientContext.getLifecycleService().shutdown();
    89|                 } catch (Exception exception) {
    90|                     logger.severe("Exception during client shutdown ", exception);
    91|                 }
    92|             }
    93|         }, clientContext.getName() + ".clientShutdown-").start();
    94|     }
    95|     @Override
    96|     public void onConnect(ClientConnection connection) {
    97|     }
    98|     @Override
    99|     public void onDisconnect(ClientConnection connection) {
   100|     }
   101|     @Override
   102|     public void shutdown() {
   103|     }
   104|     private boolean isClusterAvailable() {
   105|         return clientContext.getConnectionManager().getOwnerConnectionAddress() != null;
   106|     }
   107| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/DefaultCredentialsFactory.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-62 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.connection.nio;
    17| import com.hazelcast.client.config.ClientSecurityConfig;
    18| import com.hazelcast.config.GroupConfig;
    19| import com.hazelcast.nio.ClassLoaderUtil;
    20| import com.hazelcast.security.Credentials;
    21| import com.hazelcast.security.ICredentialsFactory;
    22| import com.hazelcast.security.UsernamePasswordCredentials;
    23| import java.util.Properties;
    24| import static com.hazelcast.util.ExceptionUtil.rethrow;
    25| /**
    26|  * This is the factory that uses Credentials instance giving by either class name or implementation
    27|  * instead of factory given bey user.
    28|  */
    29| public class DefaultCredentialsFactory implements ICredentialsFactory {
    30|     private final Credentials credentials;
    31|     public DefaultCredentialsFactory(ClientSecurityConfig securityConfig, GroupConfig groupConfig,
    32|                                      ClassLoader classLoader) {
    33|         credentials = initCredentials(securityConfig, groupConfig, classLoader);
    34|     }
    35|     private Credentials initCredentials(ClientSecurityConfig securityConfig, GroupConfig groupConfig, ClassLoader classLoader) {
    36|         Credentials credentials = securityConfig.getCredentials();
    37|         if (credentials == null) {
    38|             String credentialsClassname = securityConfig.getCredentialsClassname();
    39|             if (credentialsClassname != null) {
    40|                 try {
    41|                     credentials = ClassLoaderUtil.newInstance(classLoader, credentialsClassname);
    42|                 } catch (Exception e) {
    43|                     throw rethrow(e);
    44|                 }
    45|             }
    46|         }
    47|         if (credentials == null) {
    48|             credentials = new UsernamePasswordCredentials(groupConfig.getName(), groupConfig.getPassword());
    49|         }
    50|         return credentials;
    51|     }
    52|     @Override
    53|     public void configure(GroupConfig groupConfig, Properties properties) {
    54|     }
    55|     @Override
    56|     public Credentials newCredentials() {
    57|         return credentials;
    58|     }
    59|     @Override
    60|     public void destroy() {
    61|     }
    62| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/connection/nio/HeartbeatManager.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-92 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.connection.nio;
    17| import com.hazelcast.client.config.ClientIcmpPingConfig;
    18| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    19| import com.hazelcast.client.impl.protocol.ClientMessage;
    20| import com.hazelcast.client.impl.protocol.codec.ClientPingCodec;
    21| import com.hazelcast.client.spi.impl.ClientExecutionServiceImpl;
    22| import com.hazelcast.client.spi.impl.ClientInvocation;
    23| import com.hazelcast.logging.ILogger;
    24| import com.hazelcast.spi.exception.TargetDisconnectedException;
    25| import com.hazelcast.spi.properties.HazelcastProperties;
    26| import com.hazelcast.util.Clock;
    27| import java.util.concurrent.TimeUnit;
    28| import static com.hazelcast.client.spi.properties.ClientProperty.HEARTBEAT_INTERVAL;
    29| import static com.hazelcast.client.spi.properties.ClientProperty.HEARTBEAT_TIMEOUT;
    30| /**
    31|  * HeartbeatManager manager used by connection manager.
    32|  */
    33| public class HeartbeatManager implements Runnable {
    34|     private final ClientConnectionManagerImpl clientConnectionManager;
    35|     private final HazelcastClientInstanceImpl client;
    36|     private final ILogger logger;
    37|     private final long heartbeatInterval;
    38|     private final long heartbeatTimeout;
    39|     private final ClientICMPManager clientICMPManager;
    40|     HeartbeatManager(ClientConnectionManagerImpl clientConnectionManager, HazelcastClientInstanceImpl client) {
    41|         this.clientConnectionManager = clientConnectionManager;
    42|         this.client = client;
    43|         HazelcastProperties hazelcastProperties = client.getProperties();
    44|         this.heartbeatTimeout = hazelcastProperties.getPositiveMillisOrDefault(HEARTBEAT_TIMEOUT);
    45|         this.heartbeatInterval = hazelcastProperties.getPositiveMillisOrDefault(HEARTBEAT_INTERVAL);
    46|         this.logger = client.getLoggingService().getLogger(HeartbeatManager.class);
    47|         ClientIcmpPingConfig icmpPingConfig = client.getClientConfig().getNetworkConfig().getClientIcmpPingConfig();
    48|         this.clientICMPManager = new ClientICMPManager(icmpPingConfig,
    49|                 (ClientExecutionServiceImpl) client.getClientExecutionService(),
    50|                 client.getLoggingService(), clientConnectionManager, this);
    51|     }
    52|     public void start() {
    53|         final ClientExecutionServiceImpl es = (ClientExecutionServiceImpl) client.getClientExecutionService();
    54|         es.scheduleWithRepetition(this, heartbeatInterval, heartbeatInterval, TimeUnit.MILLISECONDS);
    55|         clientICMPManager.start();
    56|     }
    57|     long getHeartbeatTimeout() {
    58|         return heartbeatTimeout;
    59|     }
    60|     @Override
    61|     public void run() {
    62|         if (!clientConnectionManager.alive) {
    63|             return;
    64|         }
    65|         long now = Clock.currentTimeMillis();
    66|         for (final ClientConnection connection : clientConnectionManager.getActiveConnections()) {
    67|             checkConnection(now, connection);
    68|         }
    69|     }
    70|     private void checkConnection(long now, final ClientConnection connection) {
    71|         if (!connection.isAlive()) {
    72|             return;
    73|         }
    74|         if (now - connection.lastReadTimeMillis() > heartbeatTimeout) {
    75|             if (connection.isAlive()) {
    76|                 logger.warning("Heartbeat failed over the connection: " + connection);
    77|                 onHeartbeatStopped(connection, "Heartbeat timed out");
    78|             }
    79|         }
    80|         if (now - connection.lastWriteTimeMillis() > heartbeatInterval) {
    81|             ClientMessage request = ClientPingCodec.encodeRequest();
    82|             ClientInvocation clientInvocation = new ClientInvocation(client, request, null, connection);
    83|             clientInvocation.invokeUrgent();
    84|         }
    85|     }
    86|     void onHeartbeatStopped(ClientConnection connection, String reason) {
    87|         connection.close(reason, new TargetDisconnectedException("Heartbeat timed out to connection " + connection));
    88|     }
    89|     public void shutdown() {
    90|         clientICMPManager.shutdown();
    91|     }
    92| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/console/ClientConsoleApp.java
# Total hunks: 13
# ====================================================================
# --- HUNK 1: Lines 23-94 ---
    23| import com.hazelcast.core.DistributedObject;
    24| import com.hazelcast.core.EntryEvent;
    25| import com.hazelcast.core.EntryListener;
    26| import com.hazelcast.core.HazelcastInstance;
    27| import com.hazelcast.core.IAtomicLong;
    28| import com.hazelcast.core.IExecutorService;
    29| import com.hazelcast.core.IList;
    30| import com.hazelcast.core.IMap;
    31| import com.hazelcast.core.IQueue;
    32| import com.hazelcast.core.ISet;
    33| import com.hazelcast.core.ITopic;
    34| import com.hazelcast.core.ItemEvent;
    35| import com.hazelcast.core.ItemListener;
    36| import com.hazelcast.core.MapEvent;
    37| import com.hazelcast.core.Member;
    38| import com.hazelcast.core.Message;
    39| import com.hazelcast.core.MessageListener;
    40| import com.hazelcast.core.MultiMap;
    41| import com.hazelcast.core.Partition;
    42| import com.hazelcast.internal.util.RuntimeAvailableProcessors;
    43| import com.hazelcast.nio.IOUtil;
    44| import com.hazelcast.util.Clock;
    45| import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
    46| import java.io.BufferedReader;
    47| import java.io.File;
    48| import java.io.FileReader;
    49| import java.io.IOException;
    50| import java.io.InputStreamReader;
    51| import java.lang.management.ManagementFactory;
    52| import java.nio.charset.Charset;
    53| import java.util.Collection;
    54| import java.util.HashMap;
    55| import java.util.Iterator;
    56| import java.util.LinkedList;
    57| import java.util.List;
    58| import java.util.Map;
    59| import java.util.Map.Entry;
    60| import java.util.Set;
    61| import java.util.StringTokenizer;
    62| import java.util.concurrent.ExecutionException;
    63| import java.util.concurrent.ExecutorService;
    64| import java.util.concurrent.Executors;
    65| import java.util.concurrent.Future;
    66| import java.util.concurrent.TimeUnit;
    67| import java.util.concurrent.locks.Lock;
    68| import static com.hazelcast.util.StringUtil.lowerCaseInternal;
    69| import static java.lang.String.format;
    70| import static java.lang.Thread.currentThread;
    71| /**
    72|  * A demo application to demonstrate a Hazelcast client. This is probably NOT something you want to use in production.
    73|  */
    74| @SuppressWarnings({"WeakerAccess", "unused"})
    75| public class ClientConsoleApp implements EntryListener, ItemListener, MessageListener {
    76|     private static final int ONE_KB = 1024;
    77|     private static final int ONE_THOUSAND = 1000;
    78|     private static final int ONE_HUNDRED = 100;
    79|     private static final int ONE_HOUR = 3600;
    80|     private static final int MAX_THREAD_COUNT = 16;
    81|     private static final int HUNDRED_CONSTANT = 100;
    82|     private static final int BYTE_TO_BIT = 8;
    83|     private static final int LENGTH_BORDER = 4;
    84|     private IQueue<Object> queue;
    85|     private ITopic<Object> topic;
    86|     private IMap<Object, Object> map;
    87|     private MultiMap<Object, Object> multiMap;
    88|     private ISet<Object> set;
    89|     private IList<Object> list;
    90|     private IAtomicLong atomicNumber;
    91|     private String namespace = "default";
    92|     private String executorNamespace = "Sample Executor";
    93|     private boolean silent;
    94|     private boolean echo;

# --- HUNK 2: Lines 120-242 ---
   120|     }
   121|     public ISet<Object> getSet() {
   122|         set = hazelcast.getSet(namespace);
   123|         return set;
   124|     }
   125|     public IList<Object> getList() {
   126|         list = hazelcast.getList(namespace);
   127|         return list;
   128|     }
   129|     public void setHazelcast(HazelcastInstance hazelcast) {
   130|         this.hazelcast = hazelcast;
   131|         map = null;
   132|         list = null;
   133|         set = null;
   134|         queue = null;
   135|         topic = null;
   136|     }
   137|     public void stop() {
   138|         running = false;
   139|     }
   140|     public void start(String[] args) {
   141|         getMap().size();
   142|         getList().size();
   143|         getSet().size();
   144|         getQueue().size();
   145|         getMultiMap().size();
   146|         if (lineReader == null) {
   147|             lineReader = new DefaultLineReader();
   148|         }
   149|         running = true;
   150|         while (running) {
   151|             print("hazelcast[" + namespace + "] > ");
   152|             try {
   153|                 final String command = lineReader.readLine();
   154|                 handleCommand(command);
   155|             } catch (Throwable e) {
   156|                 e.printStackTrace();
   157|             }
   158|         }
   159|     }
   160|     /**
   161|      * A line reader
   162|      */
   163|     static class DefaultLineReader implements LineReader {
   164|         BufferedReader in = new BufferedReader(new InputStreamReader(System.in, Charset.forName("UTF-8")));
   165|         public String readLine() throws Exception {
   166|             return in.readLine();
   167|         }
   168|     }
   169|     /**
   170|      * Handle a command.
   171|      */
   172|     @SuppressFBWarnings("DM_EXIT")
   173|     @SuppressWarnings({"checkstyle:methodlength", "checkstyle:cyclomaticcomplexity", "checkstyle:npathcomplexity"})
   174|     protected void handleCommand(String commandInputted) {
   175|         String command = commandInputted;
   176|         if (command == null) {
   177|             return;
   178|         }
   179|         if (command.contains("__")) {
   180|             namespace = command.split("__")[0];
   181|             command = command.substring(command.indexOf("__") + 2);
   182|         }
   183|         if (echo) {
   184|             handleEcho(command);
   185|         }
   186|         if (command.startsWith("//")) {
   187|             return;
   188|         }
   189|         command = command.trim();
   190|         if (command.length() == 0) {
   191|             return;
   192|         }
   193|         String first = command;
   194|         int spaceIndex = command.indexOf(' ');
   195|         String[] argsSplit = command.split(" ");
   196|         String[] args = new String[argsSplit.length];
   197|         for (int i = 0; i < argsSplit.length; i++) {
   198|             args[i] = argsSplit[i].trim();
   199|         }
   200|         if (spaceIndex != -1) {
   201|             first = args[0];
   202|         }
   203|         if (command.startsWith("help")) {
   204|             handleHelp(command);
   205|         } else if (first.startsWith("#") && first.length() > 1) {
   206|             int repeat = Integer.parseInt(first.substring(1));
   207|             long t0 = Clock.currentTimeMillis();
   208|             for (int i = 0; i < repeat; i++) {
   209|                 handleCommand(command.substring(first.length()).replaceAll("\\$i", "" + i));
   210|             }
   211|             println("ops/s = " + repeat * ONE_THOUSAND / (Clock.currentTimeMillis() - t0));
   212|         } else if (first.startsWith("&") && first.length() > 1) {
   213|             final int fork = Integer.parseInt(first.substring(1));
   214|             ExecutorService pool = Executors.newFixedThreadPool(fork);
   215|             final String threadCommand = command.substring(first.length());
   216|             for (int i = 0; i < fork; i++) {
   217|                 final int threadID = i;
   218|                 pool.submit(new Runnable() {
   219|                     public void run() {
   220|                         String command = threadCommand;
   221|                         String[] threadArgs = command.replaceAll("\\$t", "" + threadID).trim().split(" ");
   222|                         if ("m.putmany".equals(threadArgs[0]) || "m.removemany".equals(threadArgs[0])) {
   223|                             if (threadArgs.length < LENGTH_BORDER) {
   224|                                 command += " " + Integer.parseInt(threadArgs[1]) * threadID;
   225|                             }
   226|                         }
   227|                         handleCommand(command);
   228|                     }
   229|                 });
   230|             }
   231|             pool.shutdown();
   232|             try {
   233|                 pool.awaitTermination(ONE_HOUR, TimeUnit.SECONDS);
   234|             } catch (Exception e) {
   235|                 e.printStackTrace();
   236|             }
   237|         } else if (first.startsWith("@")) {
   238|             handleAt(first);
   239|         } else if (command.indexOf(';') != -1) {
   240|             handleColon(command);
   241|         } else if ("silent".equals(first)) {
   242|             silent = Boolean.parseBoolean(args[1]);

# --- HUNK 3: Lines 320-359 ---
   320|         } else if (command.equalsIgnoreCase("m.localKeys")) {
   321|             handleMapLocalKeys();
   322|         } else if (command.equalsIgnoreCase("m.localSize")) {
   323|             handleMapLocalSize();
   324|         } else if (command.equals("m.keys")) {
   325|             handleMapKeys();
   326|         } else if (command.equals("m.values")) {
   327|             handleMapValues();
   328|         } else if (command.equals("m.entries")) {
   329|             handleMapEntries();
   330|         } else if (first.equals("m.lock")) {
   331|             handleMapLock(args);
   332|         } else if (first.equalsIgnoreCase("m.tryLock")) {
   333|             handleMapTryLock(args);
   334|         } else if (first.equals("m.unlock")) {
   335|             handleMapUnlock(args);
   336|         } else if (first.contains(".addListener")) {
   337|             handleAddListener(args);
   338|         } else if (first.equals("m.removeMapListener")) {
   339|             handleRemoveListener(args);
   340|         } else if (first.equals("mm.put")) {
   341|             handleMultiMapPut(args);
   342|         } else if (first.equals("mm.get")) {
   343|             handleMultiMapGet(args);
   344|         } else if (first.equals("mm.remove")) {
   345|             handleMultiMapRemove(args);
   346|         } else if (command.equals("mm.keys")) {
   347|             handleMultiMapKeys();
   348|         } else if (command.equals("mm.values")) {
   349|             handleMultiMapValues();
   350|         } else if (command.equals("mm.entries")) {
   351|             handleMultiMapEntries();
   352|         } else if (first.equals("mm.lock")) {
   353|             handleMultiMapLock(args);
   354|         } else if (first.equalsIgnoreCase("mm.tryLock")) {
   355|             handleMultiMapTryLock(args);
   356|         } else if (first.equals("mm.unlock")) {
   357|             handleMultiMapUnlock(args);
   358|         } else if (first.equals("l.add")) {
   359|             handleListAdd(args);

# --- HUNK 4: Lines 427-478 ---
   427|             }
   428|         }
   429|         long durationMs = System.currentTimeMillis() - startMs;
   430|         println(format("Executed %s tasks in %s ms", taskCount, durationMs));
   431|     }
   432|     private void handleColon(String command) {
   433|         StringTokenizer st = new StringTokenizer(command, ";");
   434|         while (st.hasMoreTokens()) {
   435|             handleCommand(st.nextToken());
   436|         }
   437|     }
   438|     @SuppressFBWarnings("DM_DEFAULT_ENCODING")
   439|     private void handleAt(String first) {
   440|         if (first.length() == 1) {
   441|             println("usage: @<file-name>");
   442|             return;
   443|         }
   444|         File f = new File(first.substring(1));
   445|         println("Executing script file " + f.getAbsolutePath());
   446|         if (f.exists()) {
   447|             BufferedReader br = null;
   448|             try {
   449|                 br = new BufferedReader(new FileReader(f));
   450|                 String l = br.readLine();
   451|                 while (l != null) {
   452|                     handleCommand(l);
   453|                     l = br.readLine();
   454|                 }
   455|             } catch (IOException e) {
   456|                 e.printStackTrace();
   457|             } finally {
   458|                 IOUtil.closeResource(br);
   459|             }
   460|         } else {
   461|             println("File not found! " + f.getAbsolutePath());
   462|         }
   463|     }
   464|     private void handleEcho(String command) {
   465|         String threadName = lowerCaseInternal(Thread.currentThread().getName());
   466|         if (!threadName.contains("main")) {
   467|             println(" [" + Thread.currentThread().getName() + "] " + command);
   468|         } else {
   469|             println(command);
   470|         }
   471|     }
   472|     private void handleNamespace(String[] args) {
   473|         if (args.length > 1) {
   474|             namespace = args[1];
   475|             println("namespace: " + namespace);
   476|         }
   477|     }
   478|     @SuppressFBWarnings("DM_GC")

# --- HUNK 5: Lines 540-588 ---
   540|                 }
   541|                 partitionCounts.put(owner, newCount);
   542|             }
   543|             println(partition);
   544|         }
   545|         Set<Entry<Member, Integer>> entries = partitionCounts.entrySet();
   546|         for (Entry<Member, Integer> entry : entries) {
   547|             println(entry.getKey() + ":" + entry.getValue());
   548|         }
   549|     }
   550|     protected void handleInstances(String[] args) {
   551|         Collection<DistributedObject> distributedObjects = hazelcast.getDistributedObjects();
   552|         for (DistributedObject distributedObject : distributedObjects) {
   553|             println(distributedObject);
   554|         }
   555|     }
   556|     protected void handleListContains(String[] args) {
   557|         println(getList().contains(args[1]));
   558|     }
   559|     protected void handleListRemove(String[] args) {
   560|         try {
   561|             int index = Integer.parseInt(args[1]);
   562|             if (index >= 0) {
   563|                 println(getList().remove(index));
   564|             } else {
   565|                 println(getList().remove(args[1]));
   566|             }
   567|         } catch (NumberFormatException e) {
   568|             throw new RuntimeException(e);
   569|         }
   570|     }
   571|     protected void handleListAdd(String[] args) {
   572|         if (args.length == 3) {
   573|             final int index = Integer.parseInt(args[1]);
   574|             getList().add(index, args[2]);
   575|             println("true");
   576|         } else {
   577|             println(getList().add(args[1]));
   578|         }
   579|     }
   580|     protected void handleListSet(String[] args) {
   581|         final int index = Integer.parseInt(args[1]);
   582|         println(getList().set(index, args[2]));
   583|     }
   584|     protected void handleListAddMany(String[] args) {
   585|         int count = 1;
   586|         if (args.length > 1) {
   587|             count = Integer.parseInt(args[1]);
   588|         }

# --- HUNK 6: Lines 642-682 ---
   642|         println("true");
   643|     }
   644|     protected void handleMapEvict(String[] args) {
   645|         println(getMap().evict(args[1]));
   646|     }
   647|     protected void handleMapPutMany(String[] args) {
   648|         int count = 1;
   649|         if (args.length > 1) {
   650|             count = Integer.parseInt(args[1]);
   651|         }
   652|         int b = ONE_HUNDRED;
   653|         byte[] value = new byte[b];
   654|         if (args.length > 2) {
   655|             b = Integer.parseInt(args[2]);
   656|             value = new byte[b];
   657|         }
   658|         int start = getMap().size();
   659|         if (args.length > 3) {
   660|             start = Integer.parseInt(args[3]);
   661|         }
   662|         Map<String, byte[]> theMap = new HashMap<String, byte[]>(count);
   663|         for (int i = 0; i < count; i++) {
   664|             theMap.put("key" + (start + i), value);
   665|         }
   666|         long t0 = Clock.currentTimeMillis();
   667|         getMap().putAll(theMap);
   668|         long t1 = Clock.currentTimeMillis();
   669|         if (t1 - t0 > 1) {
   670|             println("size = " + getMap().size() + ", " + count * ONE_THOUSAND / (t1 - t0)
   671|                     + " evt/s, " + (count * ONE_THOUSAND / (t1 - t0)) * (b * BYTE_TO_BIT) / ONE_KB + " Kbit/s, "
   672|                     + count * b / ONE_KB + " KB added");
   673|         }
   674|     }
   675|     protected void handleMapGetMany(String[] args) {
   676|         int count = 1;
   677|         if (args.length > 1) {
   678|             count = Integer.parseInt(args[1]);
   679|         }
   680|         for (int i = 0; i < count; i++) {
   681|             println(getMap().get("key" + i));
   682|         }

# --- HUNK 7: Lines 822-862 ---
   822|                 currentThread().interrupt();
   823|                 locked = false;
   824|             }
   825|         }
   826|         println(locked);
   827|     }
   828|     protected void handleMultiMapUnlock(String[] args) {
   829|         getMultiMap().unlock(args[1]);
   830|         println("true");
   831|     }
   832|     private void handStats(String[] args) {
   833|         String iteratorStr = args[0];
   834|         if (iteratorStr.startsWith("m.")) {
   835|             println(getMap().getLocalMapStats());
   836|         } else if (iteratorStr.startsWith("mm.")) {
   837|             println(getMultiMap().getLocalMultiMapStats());
   838|         } else if (iteratorStr.startsWith("q.")) {
   839|             println(getQueue().getLocalQueueStats());
   840|         }
   841|     }
   842|     @SuppressWarnings({"LockAcquiredButNotSafelyReleased", "squid:S2222"})
   843|     protected void handleLock(String[] args) {
   844|         String lockStr = args[0];
   845|         String key = args[1];
   846|         Lock lock = hazelcast.getLock(key);
   847|         if (lockStr.equalsIgnoreCase("lock")) {
   848|             lock.lock();
   849|             println("true");
   850|         } else if (lockStr.equalsIgnoreCase("unlock")) {
   851|             lock.unlock();
   852|             println("true");
   853|         } else if (lockStr.equalsIgnoreCase("trylock")) {
   854|             String timeout = args.length > 2 ? args[2] : null;
   855|             if (timeout == null) {
   856|                 println(lock.tryLock());
   857|             } else {
   858|                 long time = Long.parseLong(timeout);
   859|                 try {
   860|                     println(lock.tryLock(time, TimeUnit.SECONDS));
   861|                 } catch (InterruptedException e) {
   862|                     e.printStackTrace();

# --- HUNK 8: Lines 1116-1156 ---
  1116|     }
  1117|     private void execute(String[] args) {
  1118|         doExecute(false, false, args);
  1119|     }
  1120|     private void executeOnKey(String[] args) {
  1121|         doExecute(true, false, args);
  1122|     }
  1123|     private void executeOnMember(String[] args) {
  1124|         doExecute(false, true, args);
  1125|     }
  1126|     private void doExecute(boolean onKey, boolean onMember, String[] args) {
  1127|         try {
  1128|             IExecutorService executorService = hazelcast.getExecutorService("default");
  1129|             Echo callable = new Echo(args[1]);
  1130|             Future<String> future;
  1131|             if (onKey) {
  1132|                 String key = args[2];
  1133|                 future = executorService.submitToKeyOwner(callable, key);
  1134|             } else if (onMember) {
  1135|                 int memberIndex = Integer.parseInt(args[2]);
  1136|                 List<Member> members = new LinkedList<Member>(hazelcast.getCluster().getMembers());
  1137|                 if (memberIndex >= members.size()) {
  1138|                     throw new IndexOutOfBoundsException("Member index: " + memberIndex + " must be smaller than " + members
  1139|                             .size());
  1140|                 }
  1141|                 Member member = members.get(memberIndex);
  1142|                 future = executorService.submitToMember(callable, member);
  1143|             } else {
  1144|                 future = executorService.submit(callable);
  1145|             }
  1146|             println("Result: " + future.get());
  1147|         } catch (InterruptedException e) {
  1148|             currentThread().interrupt();
  1149|             e.printStackTrace();
  1150|         } catch (ExecutionException e) {
  1151|             e.printStackTrace();
  1152|         }
  1153|     }
  1154|     private void executeOnMembers(String[] args) {
  1155|         try {
  1156|             IExecutorService executorService = hazelcast.getExecutorService("default");

# --- HUNK 9: Lines 1186-1226 ---
  1186|     public void mapEvicted(MapEvent event) {
  1187|         println(event);
  1188|     }
  1189|     @Override
  1190|     public void mapCleared(MapEvent event) {
  1191|         println(event);
  1192|     }
  1193|     @Override
  1194|     public void itemAdded(ItemEvent itemEvent) {
  1195|         println("Item added = " + itemEvent.getItem());
  1196|     }
  1197|     @Override
  1198|     public void itemRemoved(ItemEvent itemEvent) {
  1199|         println("Item removed = " + itemEvent.getItem());
  1200|     }
  1201|     @Override
  1202|     public void onMessage(Message msg) {
  1203|         println("Topic received = " + msg.getMessageObject());
  1204|     }
  1205|     /**
  1206|      * Handles the help command.
  1207|      */
  1208|     protected void handleHelp(String command) {
  1209|         boolean silentBefore = silent;
  1210|         silent = false;
  1211|         println("Commands:");
  1212|         printGeneralCommands();
  1213|         printQueueCommands();
  1214|         printSetCommands();
  1215|         printLockCommands();
  1216|         printMapCommands();
  1217|         printMulitiMapCommands();
  1218|         printListCommands();
  1219|         printAtomicLongCommands();
  1220|         printExecutorServiceCommands();
  1221|         silent = silentBefore;
  1222|     }
  1223|     private void printGeneralCommands() {
  1224|         println("-- General commands");
  1225|         println("echo true|false                      //turns on/off echo of commands (default false)");
  1226|         println("silent true|false                    //turns on/off silent of command output (default false)");

# --- HUNK 10: Lines 1342-1374 ---
  1342|         println("l.remove <index>");
  1343|         println("l.set <index> <string>");
  1344|         println("l.iterator [remove]");
  1345|         println("l.size");
  1346|         println("l.clear");
  1347|         print("");
  1348|     }
  1349|     public void println(Object obj) {
  1350|         if (!silent) {
  1351|             System.out.println(obj);
  1352|         }
  1353|     }
  1354|     public void print(Object obj) {
  1355|         if (!silent) {
  1356|             System.out.print(obj);
  1357|         }
  1358|     }
  1359|     /**
  1360|      * Starts the test application. Loads the config from classpath hazelcast.xml,
  1361|      * if it fails to load, will use default config.
  1362|      */
  1363|     public static void main(String[] args) {
  1364|         ClientConfig clientConfig;
  1365|         try {
  1366|             clientConfig = new XmlClientConfigBuilder().build();
  1367|         } catch (IllegalArgumentException e) {
  1368|             clientConfig = new ClientConfig();
  1369|         }
  1370|         final HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);
  1371|         ClientConsoleApp clientConsoleApp = new ClientConsoleApp(client);
  1372|         clientConsoleApp.start(args);
  1373|     }
  1374| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/ClientConnectionManagerFactory.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.impl.clientside;
    17| import com.hazelcast.client.connection.AddressProvider;
    18| import com.hazelcast.client.connection.AddressTranslator;
    19| import com.hazelcast.client.connection.ClientConnectionManager;
    20| import java.util.Collection;
    21| public interface ClientConnectionManagerFactory {
    22|     ClientConnectionManager createConnectionManager(HazelcastClientInstanceImpl client,
    23|                                                     AddressTranslator addressTranslator,
    24|                                                     Collection<AddressProvider> addressProviders);
    25| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/ClientDynamicClusterConfig.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1054 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.impl.clientside;
    17| import com.hazelcast.client.impl.protocol.ClientMessage;
    18| import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddAtomicLongConfigCodec;
    19| import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddAtomicReferenceConfigCodec;
    20| import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddCacheConfigCodec;
    21| import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddCardinalityEstimatorConfigCodec;
    22| import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddCountDownLatchConfigCodec;
    23| import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddDurableExecutorConfigCodec;
    24| import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddEventJournalConfigCodec;
    25| import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddExecutorConfigCodec;
    26| import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddFlakeIdGeneratorConfigCodec;
    27| import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddListConfigCodec;
    28| import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddLockConfigCodec;
    29| import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddMapConfigCodec;
    30| import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddMerkleTreeConfigCodec;
    31| import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddMultiMapConfigCodec;
    32| import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddPNCounterConfigCodec;
    33| import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddQueueConfigCodec;
    34| import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddReliableTopicConfigCodec;
    35| import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddReplicatedMapConfigCodec;
    36| import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddRingbufferConfigCodec;
    37| import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddScheduledExecutorConfigCodec;
    38| import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddSemaphoreConfigCodec;
    39| import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddSetConfigCodec;
    40| import com.hazelcast.client.impl.protocol.codec.DynamicConfigAddTopicConfigCodec;
    41| import com.hazelcast.client.impl.protocol.task.dynamicconfig.EvictionConfigHolder;
    42| import com.hazelcast.client.impl.protocol.task.dynamicconfig.ListenerConfigHolder;
    43| import com.hazelcast.client.impl.protocol.task.dynamicconfig.MapStoreConfigHolder;
    44| import com.hazelcast.client.impl.protocol.task.dynamicconfig.NearCacheConfigHolder;
    45| import com.hazelcast.client.impl.protocol.task.dynamicconfig.QueryCacheConfigHolder;
    46| import com.hazelcast.client.impl.protocol.task.dynamicconfig.QueueStoreConfigHolder;
    47| import com.hazelcast.client.impl.protocol.task.dynamicconfig.RingbufferStoreConfigHolder;
    48| import com.hazelcast.client.spi.impl.ClientInvocation;
    49| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    50| import com.hazelcast.config.AtomicLongConfig;
    51| import com.hazelcast.config.AtomicReferenceConfig;
    52| import com.hazelcast.config.CRDTReplicationConfig;
    53| import com.hazelcast.config.CacheSimpleConfig;
    54| import com.hazelcast.config.CardinalityEstimatorConfig;
    55| import com.hazelcast.config.Config;
    56| import com.hazelcast.config.ConfigPatternMatcher;
    57| import com.hazelcast.config.CountDownLatchConfig;
    58| import com.hazelcast.config.DurableExecutorConfig;
    59| import com.hazelcast.config.EventJournalConfig;
    60| import com.hazelcast.config.ExecutorConfig;
    61| import com.hazelcast.config.FlakeIdGeneratorConfig;
    62| import com.hazelcast.config.GroupConfig;
    63| import com.hazelcast.config.HotRestartPersistenceConfig;
    64| import com.hazelcast.config.JobTrackerConfig;
    65| import com.hazelcast.config.ListConfig;
    66| import com.hazelcast.config.ListenerConfig;
    67| import com.hazelcast.config.LockConfig;
    68| import com.hazelcast.config.ManagementCenterConfig;
    69| import com.hazelcast.config.MapConfig;
    70| import com.hazelcast.config.MemberAttributeConfig;
    71| import com.hazelcast.config.MerkleTreeConfig;
    72| import com.hazelcast.config.MultiMapConfig;
    73| import com.hazelcast.config.NativeMemoryConfig;
    74| import com.hazelcast.config.NetworkConfig;
    75| import com.hazelcast.config.PNCounterConfig;
    76| import com.hazelcast.config.PartitionGroupConfig;
    77| import com.hazelcast.config.QueryCacheConfig;
    78| import com.hazelcast.config.QueueConfig;
    79| import com.hazelcast.config.QuorumConfig;
    80| import com.hazelcast.config.ReliableTopicConfig;
    81| import com.hazelcast.config.ReplicatedMapConfig;
    82| import com.hazelcast.config.RingbufferConfig;
    83| import com.hazelcast.config.RingbufferStoreConfig;
    84| import com.hazelcast.config.ScheduledExecutorConfig;
    85| import com.hazelcast.config.SecurityConfig;
    86| import com.hazelcast.config.SemaphoreConfig;
    87| import com.hazelcast.config.SerializationConfig;
    88| import com.hazelcast.config.ServicesConfig;
    89| import com.hazelcast.config.SetConfig;
    90| import com.hazelcast.config.TopicConfig;
    91| import com.hazelcast.config.UserCodeDeploymentConfig;
    92| import com.hazelcast.config.WanReplicationConfig;
    93| import com.hazelcast.core.ManagedContext;
    94| import com.hazelcast.nio.serialization.Data;
    95| import com.hazelcast.spi.serialization.SerializationService;
    96| import com.hazelcast.util.Preconditions;
    97| import com.hazelcast.util.StringUtil;
    98| import java.io.File;
    99| import java.net.URL;
   100| import java.util.ArrayList;
   101| import java.util.Collection;
   102| import java.util.List;
   103| import java.util.Map;
   104| import java.util.Properties;
   105| import java.util.concurrent.ConcurrentMap;
   106| import static com.hazelcast.util.ExceptionUtil.rethrow;
   107| /**
   108|  * Client implementation of member side config. Clients use this to submit new data structure configurations into
   109|  * a live Hazelcast cluster.
   110|  */
   111| @SuppressWarnings({"checkstyle:methodcount", "checkstyle:classfanoutcomplexity"})
   112| public class ClientDynamicClusterConfig extends Config {
   113|     private static final String UNSUPPORTED_ERROR_MESSAGE =
   114|             "Client config object only supports adding new data structure configurations";
   115|     private final HazelcastClientInstanceImpl instance;
   116|     private final SerializationService serializationService;
   117|     public ClientDynamicClusterConfig(HazelcastClientInstanceImpl instance) {
   118|         this.instance = instance;
   119|         this.serializationService = instance.getSerializationService();
   120|     }
   121|     @Override
   122|     public Config addMapConfig(MapConfig mapConfig) {
   123|         List<ListenerConfigHolder> listenerConfigs = adaptListenerConfigs(mapConfig.getEntryListenerConfigs());
   124|         List<ListenerConfigHolder> partitionLostListenerConfigs =
   125|                 adaptListenerConfigs(mapConfig.getPartitionLostListenerConfigs());
   126|         List<QueryCacheConfigHolder> queryCacheConfigHolders = null;
   127|         if (mapConfig.getQueryCacheConfigs() != null && !mapConfig.getQueryCacheConfigs().isEmpty()) {
   128|             queryCacheConfigHolders = new ArrayList<QueryCacheConfigHolder>(mapConfig.getQueryCacheConfigs().size());
   129|             for (QueryCacheConfig config : mapConfig.getQueryCacheConfigs()) {
   130|                 queryCacheConfigHolders.add(QueryCacheConfigHolder.of(config, serializationService));
   131|             }
   132|         }
   133|         String partitioningStrategyClassName = mapConfig.getPartitioningStrategyConfig() == null
   134|                 ? null : mapConfig.getPartitioningStrategyConfig().getPartitioningStrategyClass();
   135|         Data partitioningStrategy = mapConfig.getPartitioningStrategyConfig() == null
   136|                 ? null : serializationService.toData(mapConfig.getPartitioningStrategyConfig().getPartitioningStrategy());
   137|         ClientMessage request = DynamicConfigAddMapConfigCodec.encodeRequest(mapConfig.getName(),
   138|                 mapConfig.getBackupCount(), mapConfig.getAsyncBackupCount(), mapConfig.getTimeToLiveSeconds(),
   139|                 mapConfig.getMaxIdleSeconds(), mapConfig.getEvictionPolicy().name(), mapConfig.isReadBackupData(),
   140|                 mapConfig.getCacheDeserializedValues().name(), mapConfig.getMergePolicy(), mapConfig.getInMemoryFormat().name(),
   141|                 listenerConfigs, partitionLostListenerConfigs, mapConfig.isStatisticsEnabled(), mapConfig.getQuorumName(),
   142|                 serializationService.toData(mapConfig.getMapEvictionPolicy()),
   143|                 mapConfig.getMaxSizeConfig().getMaxSizePolicy().name(), mapConfig.getMaxSizeConfig().getSize(),
   144|                 MapStoreConfigHolder.of(mapConfig.getMapStoreConfig(), serializationService),
   145|                 NearCacheConfigHolder.of(mapConfig.getNearCacheConfig(), serializationService),
   146|                 mapConfig.getWanReplicationRef(), mapConfig.getMapIndexConfigs(), mapConfig.getMapAttributeConfigs(),
   147|                 queryCacheConfigHolders, partitioningStrategyClassName, partitioningStrategy, mapConfig.getHotRestartConfig(),
   148|                 mapConfig.getMergePolicyConfig().getBatchSize());
   149|         invoke(request);
   150|         return this;
   151|     }
   152|     @Override
   153|     public Config addCacheConfig(CacheSimpleConfig cacheConfig) {
   154|         List<ListenerConfigHolder> partitionLostListenerConfigs =
   155|                 adaptListenerConfigs(cacheConfig.getPartitionLostListenerConfigs());
   156|         ClientMessage request = DynamicConfigAddCacheConfigCodec.encodeRequest(cacheConfig.getName(), cacheConfig.getKeyType(),
   157|                 cacheConfig.getValueType(), cacheConfig.isStatisticsEnabled(), cacheConfig.isManagementEnabled(),
   158|                 cacheConfig.isReadThrough(), cacheConfig.isWriteThrough(), cacheConfig.getCacheLoaderFactory(),
   159|                 cacheConfig.getCacheWriterFactory(), cacheConfig.getCacheLoader(), cacheConfig.getCacheWriter(),
   160|                 cacheConfig.getBackupCount(), cacheConfig.getAsyncBackupCount(), cacheConfig.getInMemoryFormat().name(),
   161|                 cacheConfig.getQuorumName(), cacheConfig.getMergePolicy(), cacheConfig.isDisablePerEntryInvalidationEvents(),
   162|                 partitionLostListenerConfigs,
   163|                 cacheConfig.getExpiryPolicyFactoryConfig() == null ? null
   164|                         : cacheConfig.getExpiryPolicyFactoryConfig().getClassName(),
   165|                 cacheConfig.getExpiryPolicyFactoryConfig() == null ? null
   166|                         : cacheConfig.getExpiryPolicyFactoryConfig().getTimedExpiryPolicyFactoryConfig(),
   167|                 cacheConfig.getCacheEntryListeners(),
   168|                 EvictionConfigHolder.of(cacheConfig.getEvictionConfig(), serializationService),
   169|                 cacheConfig.getWanReplicationRef(), cacheConfig.getHotRestartConfig());
   170|         invoke(request);
   171|         return this;
   172|     }
   173|     @Override
   174|     public Config addQueueConfig(QueueConfig queueConfig) {
   175|         List<ListenerConfigHolder> listenerConfigs = adaptListenerConfigs(queueConfig.getItemListenerConfigs());
   176|         QueueStoreConfigHolder queueStoreConfigHolder = QueueStoreConfigHolder.of(queueConfig.getQueueStoreConfig(),
   177|                 serializationService);
   178|         ClientMessage request = DynamicConfigAddQueueConfigCodec.encodeRequest(queueConfig.getName(), listenerConfigs,
   179|                 queueConfig.getBackupCount(), queueConfig.getAsyncBackupCount(), queueConfig.getMaxSize(),
   180|                 queueConfig.getEmptyQueueTtl(), queueConfig.isStatisticsEnabled(), queueConfig.getQuorumName(),
   181|                 queueStoreConfigHolder, queueConfig.getMergePolicyConfig().getPolicy(),
   182|                 queueConfig.getMergePolicyConfig().getBatchSize());
   183|         invoke(request);
   184|         return this;
   185|     }
   186|     @Override
   187|     public Config addLockConfig(LockConfig lockConfig) {
   188|         ClientMessage request = DynamicConfigAddLockConfigCodec.encodeRequest(lockConfig.getName(), lockConfig.getQuorumName());
   189|         invoke(request);
   190|         return this;
   191|     }
   192|     @Override
   193|     public Config addListConfig(ListConfig listConfig) {
   194|         List<ListenerConfigHolder> listenerConfigs = adaptListenerConfigs(listConfig.getItemListenerConfigs());
   195|         ClientMessage request = DynamicConfigAddListConfigCodec.encodeRequest(listConfig.getName(), listenerConfigs,
   196|                 listConfig.getBackupCount(), listConfig.getAsyncBackupCount(), listConfig.getMaxSize(),
   197|                 listConfig.isStatisticsEnabled(), listConfig.getQuorumName(), listConfig.getMergePolicyConfig().getPolicy(),
   198|                 listConfig.getMergePolicyConfig().getBatchSize());
   199|         invoke(request);
   200|         return this;
   201|     }
   202|     @Override
   203|     public Config addSetConfig(SetConfig setConfig) {
   204|         List<ListenerConfigHolder> listenerConfigs = adaptListenerConfigs(setConfig.getItemListenerConfigs());
   205|         ClientMessage request = DynamicConfigAddSetConfigCodec.encodeRequest(setConfig.getName(), listenerConfigs,
   206|                 setConfig.getBackupCount(), setConfig.getAsyncBackupCount(), setConfig.getMaxSize(),
   207|                 setConfig.isStatisticsEnabled(), setConfig.getQuorumName(), setConfig.getMergePolicyConfig().getPolicy(),
   208|                 setConfig.getMergePolicyConfig().getBatchSize());
   209|         invoke(request);
   210|         return this;
   211|     }
   212|     @Override
   213|     public Config addMultiMapConfig(MultiMapConfig multiMapConfig) {
   214|         List<ListenerConfigHolder> listenerConfigHolders = adaptListenerConfigs(multiMapConfig.getEntryListenerConfigs());
   215|         ClientMessage request = DynamicConfigAddMultiMapConfigCodec.encodeRequest(
   216|                 multiMapConfig.getName(), multiMapConfig.getValueCollectionType().toString(),
   217|                 listenerConfigHolders,
   218|                 multiMapConfig.isBinary(), multiMapConfig.getBackupCount(), multiMapConfig.getAsyncBackupCount(),
   219|                 multiMapConfig.isStatisticsEnabled(), multiMapConfig.getQuorumName(),
   220|                 multiMapConfig.getMergePolicyConfig().getPolicy(), multiMapConfig.getMergePolicyConfig().getBatchSize());
   221|         invoke(request);
   222|         return this;
   223|     }
   224|     @Override
   225|     public Config addReplicatedMapConfig(ReplicatedMapConfig replicatedMapConfig) {
   226|         List<ListenerConfigHolder> listenerConfigHolders = adaptListenerConfigs(replicatedMapConfig.getListenerConfigs());
   227|         ClientMessage request = DynamicConfigAddReplicatedMapConfigCodec.encodeRequest(
   228|                 replicatedMapConfig.getName(), replicatedMapConfig.getInMemoryFormat().name(),
   229|                 replicatedMapConfig.isAsyncFillup(), replicatedMapConfig.isStatisticsEnabled(),
   230|                 replicatedMapConfig.getMergePolicyConfig().getPolicy(),
   231|                 listenerConfigHolders, replicatedMapConfig.getQuorumName(),
   232|                 replicatedMapConfig.getMergePolicyConfig().getBatchSize());
   233|         invoke(request);
   234|         return this;
   235|     }
   236|     @Override
   237|     public Config addRingBufferConfig(RingbufferConfig ringbufferConfig) {
   238|         RingbufferStoreConfigHolder ringbufferStoreConfig = null;
   239|         if (ringbufferConfig.getRingbufferStoreConfig() != null
   240|                 && ringbufferConfig.getRingbufferStoreConfig().isEnabled()) {
   241|             RingbufferStoreConfig storeConfig = ringbufferConfig.getRingbufferStoreConfig();
   242|             ringbufferStoreConfig = RingbufferStoreConfigHolder.of(storeConfig, instance.getSerializationService());
   243|         }
   244|         ClientMessage request = DynamicConfigAddRingbufferConfigCodec.encodeRequest(
   245|                 ringbufferConfig.getName(), ringbufferConfig.getCapacity(), ringbufferConfig.getBackupCount(),
   246|                 ringbufferConfig.getAsyncBackupCount(), ringbufferConfig.getTimeToLiveSeconds(),
   247|                 ringbufferConfig.getInMemoryFormat().name(), ringbufferStoreConfig, ringbufferConfig.getQuorumName(),
   248|                 ringbufferConfig.getMergePolicyConfig().getPolicy(), ringbufferConfig.getMergePolicyConfig().getBatchSize());
   249|         invoke(request);
   250|         return this;
   251|     }
   252|     @Override
   253|     public Config addTopicConfig(TopicConfig topicConfig) {
   254|         List<ListenerConfigHolder> listenerConfigHolders = adaptListenerConfigs(topicConfig.getMessageListenerConfigs());
   255|         ClientMessage request = DynamicConfigAddTopicConfigCodec.encodeRequest(
   256|                 topicConfig.getName(), topicConfig.isGlobalOrderingEnabled(), topicConfig.isStatisticsEnabled(),
   257|                 topicConfig.isMultiThreadingEnabled(), listenerConfigHolders);
   258|         invoke(request);
   259|         return this;
   260|     }
   261|     @Override
   262|     public Config addReliableTopicConfig(ReliableTopicConfig config) {
   263|         List<ListenerConfigHolder> listenerConfigHolders = adaptListenerConfigs(config.getMessageListenerConfigs());
   264|         Data executorData = serializationService.toData(config.getExecutor());
   265|         ClientMessage request = DynamicConfigAddReliableTopicConfigCodec.encodeRequest(config.getName(),
   266|                 listenerConfigHolders, config.getReadBatchSize(), config.isStatisticsEnabled(),
   267|                 config.getTopicOverloadPolicy().name(), executorData);
   268|         invoke(request);
   269|         return this;
   270|     }
   271|     @Override
   272|     public Config addExecutorConfig(ExecutorConfig executorConfig) {
   273|         ClientMessage request = DynamicConfigAddExecutorConfigCodec.encodeRequest(
   274|                 executorConfig.getName(), executorConfig.getPoolSize(), executorConfig.getQueueCapacity(),
   275|                 executorConfig.isStatisticsEnabled(), executorConfig.getQuorumName());
   276|         invoke(request);
   277|         return this;
   278|     }
   279|     @Override
   280|     public Config addDurableExecutorConfig(DurableExecutorConfig durableExecutorConfig) {
   281|         ClientMessage request = DynamicConfigAddDurableExecutorConfigCodec.encodeRequest(
   282|                 durableExecutorConfig.getName(), durableExecutorConfig.getPoolSize(),
   283|                 durableExecutorConfig.getDurability(), durableExecutorConfig.getCapacity(),
   284|                 durableExecutorConfig.getQuorumName());
   285|         invoke(request);
   286|         return this;
   287|     }
   288|     @Override
   289|     public Config addScheduledExecutorConfig(ScheduledExecutorConfig scheduledExecutorConfig) {
   290|         ClientMessage request = DynamicConfigAddScheduledExecutorConfigCodec.encodeRequest(
   291|                 scheduledExecutorConfig.getName(), scheduledExecutorConfig.getPoolSize(),
   292|                 scheduledExecutorConfig.getDurability(), scheduledExecutorConfig.getCapacity(),
   293|                 scheduledExecutorConfig.getQuorumName(), scheduledExecutorConfig.getMergePolicyConfig().getPolicy(),
   294|                 scheduledExecutorConfig.getMergePolicyConfig().getBatchSize());
   295|         invoke(request);
   296|         return this;
   297|     }
   298|     @Override
   299|     public Config addCardinalityEstimatorConfig(CardinalityEstimatorConfig cardinalityEstimatorConfig) {
   300|         ClientMessage request = DynamicConfigAddCardinalityEstimatorConfigCodec.encodeRequest(
   301|                 cardinalityEstimatorConfig.getName(), cardinalityEstimatorConfig.getBackupCount(),
   302|                 cardinalityEstimatorConfig.getAsyncBackupCount(), cardinalityEstimatorConfig.getQuorumName(),
   303|                 cardinalityEstimatorConfig.getMergePolicyConfig().getPolicy(),
   304|                 cardinalityEstimatorConfig.getMergePolicyConfig().getBatchSize());
   305|         invoke(request);
   306|         return this;
   307|     }
   308|     @Override
   309|     public Config addSemaphoreConfig(SemaphoreConfig semaphoreConfig) {
   310|         ClientMessage request = DynamicConfigAddSemaphoreConfigCodec.encodeRequest(
   311|                 semaphoreConfig.getName(), semaphoreConfig.getInitialPermits(), semaphoreConfig.getBackupCount(),
   312|                 semaphoreConfig.getAsyncBackupCount(), semaphoreConfig.getQuorumName());
   313|         invoke(request);
   314|         return this;
   315|     }
   316|     @Override
   317|     public Config addPNCounterConfig(PNCounterConfig pnCounterConfig) {
   318|         ClientMessage request = DynamicConfigAddPNCounterConfigCodec.encodeRequest(
   319|                 pnCounterConfig.getName(), pnCounterConfig.getReplicaCount(),
   320|                 pnCounterConfig.isStatisticsEnabled(), pnCounterConfig.getQuorumName());
   321|         invoke(request);
   322|         return this;
   323|     }
   324|     @Override
   325|     public Config addAtomicReferenceConfig(AtomicReferenceConfig atomicReferenceConfig) {
   326|         ClientMessage request = DynamicConfigAddAtomicReferenceConfigCodec.encodeRequest(
   327|                 atomicReferenceConfig.getName(), atomicReferenceConfig.getQuorumName(),
   328|                 atomicReferenceConfig.getMergePolicyConfig().getPolicy(),
   329|                 atomicReferenceConfig.getMergePolicyConfig().getBatchSize());
   330|         invoke(request);
   331|         return this;
   332|     }
   333|     @Override
   334|     public Config addAtomicLongConfig(AtomicLongConfig atomicLongConfig) {
   335|         ClientMessage request = DynamicConfigAddAtomicLongConfigCodec.encodeRequest(
   336|                 atomicLongConfig.getName(), atomicLongConfig.getQuorumName(),
   337|                 atomicLongConfig.getMergePolicyConfig().getPolicy(), atomicLongConfig.getMergePolicyConfig().getBatchSize());
   338|         invoke(request);
   339|         return this;
   340|     }
   341|     @Override
   342|     public Config addCountDownLatchConfig(CountDownLatchConfig countDownLatchConfig) {
   343|         ClientMessage request = DynamicConfigAddCountDownLatchConfigCodec.encodeRequest(
   344|                 countDownLatchConfig.getName(), countDownLatchConfig.getQuorumName());
   345|         invoke(request);
   346|         return this;
   347|     }
   348|     @Override
   349|     public Config addWanReplicationConfig(WanReplicationConfig wanReplicationConfig) {
   350|         return super.addWanReplicationConfig(wanReplicationConfig);
   351|     }
   352|     @Override
   353|     public Config addJobTrackerConfig(JobTrackerConfig jobTrackerConfig) {
   354|         throw new UnsupportedOperationException("JobTracker is deprecated and will be removed in Hazelcast 4.0");
   355|     }
   356|     @Override
   357|     public Config addQuorumConfig(QuorumConfig quorumConfig) {
   358|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   359|     }
   360|     @Override
   361|     public Config addListenerConfig(ListenerConfig listenerConfig) {
   362|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   363|     }
   364|     @Override
   365|     public Config addEventJournalConfig(EventJournalConfig eventJournalConfig) {
   366|         String mapName = eventJournalConfig.getMapName();
   367|         String cacheName = eventJournalConfig.getCacheName();
   368|         if (StringUtil.isNullOrEmpty(mapName) && StringUtil.isNullOrEmpty(cacheName)) {
   369|             throw new IllegalArgumentException("Event journal config should have non-empty map name and/or cache name");
   370|         }
   371|         ClientMessage request = DynamicConfigAddEventJournalConfigCodec.encodeRequest(eventJournalConfig.getMapName(),
   372|                 eventJournalConfig.getCacheName(), eventJournalConfig.isEnabled(), eventJournalConfig.getCapacity(),
   373|                 eventJournalConfig.getTimeToLiveSeconds());
   374|         invoke(request);
   375|         return this;
   376|     }
   377|     @Override
   378|     public EventJournalConfig findMapEventJournalConfig(String name) {
   379|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   380|     }
   381|     @Override
   382|     public EventJournalConfig findCacheEventJournalConfig(String name) {
   383|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   384|     }
   385|     @Override
   386|     public EventJournalConfig getMapEventJournalConfig(String name) {
   387|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   388|     }
   389|     @Override
   390|     public EventJournalConfig getCacheEventJournalConfig(String name) {
   391|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   392|     }
   393|     @Override
   394|     public Map<String, EventJournalConfig> getMapEventJournalConfigs() {
   395|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   396|     }
   397|     @Override
   398|     public Map<String, EventJournalConfig> getCacheEventJournalConfigs() {
   399|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   400|     }
   401|     @Override
   402|     public Config setMapEventJournalConfigs(Map<String, EventJournalConfig> eventJournalConfigs) {
   403|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   404|     }
   405|     @Override
   406|     public Config setCacheEventJournalConfigs(Map<String, EventJournalConfig> eventJournalConfigs) {
   407|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   408|     }
   409|     @Override
   410|     public MerkleTreeConfig findMapMerkleTreeConfig(String name) {
   411|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   412|     }
   413|     @Override
   414|     public MerkleTreeConfig getMapMerkleTreeConfig(String name) {
   415|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   416|     }
   417|     @Override
   418|     public Config addMerkleTreeConfig(MerkleTreeConfig merkleTreeConfig) {
   419|         String mapName = merkleTreeConfig.getMapName();
   420|         Preconditions.checkHasText(mapName, "Merkle tree config must define a map name");
   421|         ClientMessage request = DynamicConfigAddMerkleTreeConfigCodec.encodeRequest(
   422|                 merkleTreeConfig.getMapName(), merkleTreeConfig.isEnabled(), merkleTreeConfig.getDepth());
   423|         invoke(request);
   424|         return this;
   425|     }
   426|     @Override
   427|     public Map<String, MerkleTreeConfig> getMapMerkleTreeConfigs() {
   428|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   429|     }
   430|     @Override
   431|     public Config setMapMerkleTreeConfigs(Map<String, MerkleTreeConfig> merkleTreeConfigs) {
   432|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   433|     }
   434|     @Override
   435|     public Config addFlakeIdGeneratorConfig(FlakeIdGeneratorConfig flakeIdGeneratorConfig) {
   436|         ClientMessage request = DynamicConfigAddFlakeIdGeneratorConfigCodec.encodeRequest(
   437|                 flakeIdGeneratorConfig.getName(),
   438|                 flakeIdGeneratorConfig.getPrefetchCount(),
   439|                 flakeIdGeneratorConfig.getPrefetchValidityMillis(),
   440|                 flakeIdGeneratorConfig.getIdOffset(),
   441|                 flakeIdGeneratorConfig.isStatisticsEnabled(),
   442|                 flakeIdGeneratorConfig.getNodeIdOffset());
   443|         invoke(request);
   444|         return this;
   445|     }
   446|     @Override
   447|     public ClassLoader getClassLoader() {
   448|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   449|     }
   450|     @Override
   451|     public Config setClassLoader(ClassLoader classLoader) {
   452|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   453|     }
   454|     @Override
   455|     public ConfigPatternMatcher getConfigPatternMatcher() {
   456|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   457|     }
   458|     @Override
   459|     public void setConfigPatternMatcher(ConfigPatternMatcher configPatternMatcher) {
   460|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   461|     }
   462|     @Override
   463|     public String getProperty(String name) {
   464|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   465|     }
   466|     @Override
   467|     public Config setProperty(String name, String value) {
   468|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   469|     }
   470|     @Override
   471|     public MemberAttributeConfig getMemberAttributeConfig() {
   472|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   473|     }
   474|     @Override
   475|     public void setMemberAttributeConfig(MemberAttributeConfig memberAttributeConfig) {
   476|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   477|     }
   478|     @Override
   479|     public Properties getProperties() {
   480|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   481|     }
   482|     @Override
   483|     public Config setProperties(Properties properties) {
   484|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   485|     }
   486|     @Override
   487|     public String getInstanceName() {
   488|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   489|     }
   490|     @Override
   491|     public Config setInstanceName(String instanceName) {
   492|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   493|     }
   494|     @Override
   495|     public GroupConfig getGroupConfig() {
   496|         return instance.getClientConfig().getGroupConfig();
   497|     }
   498|     @Override
   499|     public Config setGroupConfig(GroupConfig groupConfig) {
   500|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   501|     }
   502|     @Override
   503|     public NetworkConfig getNetworkConfig() {
   504|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   505|     }
   506|     @Override
   507|     public Config setNetworkConfig(NetworkConfig networkConfig) {
   508|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   509|     }
   510|     @Override
   511|     public MapConfig findMapConfig(String name) {
   512|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   513|     }
   514|     @Override
   515|     public MapConfig getMapConfig(String name) {
   516|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   517|     }
   518|     @Override
   519|     public Map<String, MapConfig> getMapConfigs() {
   520|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   521|     }
   522|     @Override
   523|     public Config setMapConfigs(Map<String, MapConfig> mapConfigs) {
   524|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   525|     }
   526|     @Override
   527|     public CacheSimpleConfig findCacheConfig(String name) {
   528|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   529|     }
   530|     @Override
   531|     public CacheSimpleConfig getCacheConfig(String name) {
   532|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   533|     }
   534|     @Override
   535|     public Map<String, CacheSimpleConfig> getCacheConfigs() {
   536|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   537|     }
   538|     @Override
   539|     public Config setCacheConfigs(Map<String, CacheSimpleConfig> cacheConfigs) {
   540|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   541|     }
   542|     @Override
   543|     public QueueConfig findQueueConfig(String name) {
   544|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   545|     }
   546|     @Override
   547|     public QueueConfig getQueueConfig(String name) {
   548|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   549|     }
   550|     @Override
   551|     public Map<String, QueueConfig> getQueueConfigs() {
   552|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   553|     }
   554|     @Override
   555|     public Config setQueueConfigs(Map<String, QueueConfig> queueConfigs) {
   556|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   557|     }
   558|     @Override
   559|     public LockConfig findLockConfig(String name) {
   560|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   561|     }
   562|     @Override
   563|     public LockConfig getLockConfig(String name) {
   564|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   565|     }
   566|     @Override
   567|     public Map<String, LockConfig> getLockConfigs() {
   568|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   569|     }
   570|     @Override
   571|     public Config setLockConfigs(Map<String, LockConfig> lockConfigs) {
   572|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   573|     }
   574|     @Override
   575|     public ListConfig findListConfig(String name) {
   576|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   577|     }
   578|     @Override
   579|     public ListConfig getListConfig(String name) {
   580|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   581|     }
   582|     @Override
   583|     public Map<String, ListConfig> getListConfigs() {
   584|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   585|     }
   586|     @Override
   587|     public Config setListConfigs(Map<String, ListConfig> listConfigs) {
   588|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   589|     }
   590|     @Override
   591|     public SetConfig findSetConfig(String name) {
   592|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   593|     }
   594|     @Override
   595|     public SetConfig getSetConfig(String name) {
   596|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   597|     }
   598|     @Override
   599|     public Map<String, SetConfig> getSetConfigs() {
   600|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   601|     }
   602|     @Override
   603|     public Config setSetConfigs(Map<String, SetConfig> setConfigs) {
   604|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   605|     }
   606|     @Override
   607|     public MultiMapConfig findMultiMapConfig(String name) {
   608|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   609|     }
   610|     @Override
   611|     public MultiMapConfig getMultiMapConfig(String name) {
   612|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   613|     }
   614|     @Override
   615|     public Map<String, MultiMapConfig> getMultiMapConfigs() {
   616|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   617|     }
   618|     @Override
   619|     public Config setMultiMapConfigs(Map<String, MultiMapConfig> multiMapConfigs) {
   620|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   621|     }
   622|     @Override
   623|     public ReplicatedMapConfig findReplicatedMapConfig(String name) {
   624|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   625|     }
   626|     @Override
   627|     public ReplicatedMapConfig getReplicatedMapConfig(String name) {
   628|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   629|     }
   630|     @Override
   631|     public Map<String, ReplicatedMapConfig> getReplicatedMapConfigs() {
   632|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   633|     }
   634|     @Override
   635|     public Config setReplicatedMapConfigs(Map<String, ReplicatedMapConfig> replicatedMapConfigs) {
   636|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   637|     }
   638|     @Override
   639|     public RingbufferConfig findRingbufferConfig(String name) {
   640|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   641|     }
   642|     @Override
   643|     public RingbufferConfig getRingbufferConfig(String name) {
   644|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   645|     }
   646|     @Override
   647|     public Map<String, RingbufferConfig> getRingbufferConfigs() {
   648|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   649|     }
   650|     @Override
   651|     public Config setRingbufferConfigs(Map<String, RingbufferConfig> ringbufferConfigs) {
   652|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   653|     }
   654|     @Override
   655|     public TopicConfig findTopicConfig(String name) {
   656|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   657|     }
   658|     @Override
   659|     public TopicConfig getTopicConfig(String name) {
   660|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   661|     }
   662|     @Override
   663|     public ReliableTopicConfig findReliableTopicConfig(String name) {
   664|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   665|     }
   666|     @Override
   667|     public ReliableTopicConfig getReliableTopicConfig(String name) {
   668|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   669|     }
   670|     @Override
   671|     public Map<String, ReliableTopicConfig> getReliableTopicConfigs() {
   672|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   673|     }
   674|     @Override
   675|     public Config setReliableTopicConfigs(Map<String, ReliableTopicConfig> reliableTopicConfigs) {
   676|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   677|     }
   678|     @Override
   679|     public Map<String, TopicConfig> getTopicConfigs() {
   680|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   681|     }
   682|     @Override
   683|     public Config setTopicConfigs(Map<String, TopicConfig> mapTopicConfigs) {
   684|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   685|     }
   686|     @Override
   687|     public ExecutorConfig findExecutorConfig(String name) {
   688|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   689|     }
   690|     @Override
   691|     public DurableExecutorConfig findDurableExecutorConfig(String name) {
   692|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   693|     }
   694|     @Override
   695|     public ScheduledExecutorConfig findScheduledExecutorConfig(String name) {
   696|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   697|     }
   698|     @Override
   699|     public CardinalityEstimatorConfig findCardinalityEstimatorConfig(String name) {
   700|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   701|     }
   702|     @Override
   703|     public ExecutorConfig getExecutorConfig(String name) {
   704|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   705|     }
   706|     @Override
   707|     public DurableExecutorConfig getDurableExecutorConfig(String name) {
   708|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   709|     }
   710|     @Override
   711|     public ScheduledExecutorConfig getScheduledExecutorConfig(String name) {
   712|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   713|     }
   714|     @Override
   715|     public CardinalityEstimatorConfig getCardinalityEstimatorConfig(String name) {
   716|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   717|     }
   718|     @Override
   719|     public Map<String, ExecutorConfig> getExecutorConfigs() {
   720|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   721|     }
   722|     @Override
   723|     public Config setExecutorConfigs(Map<String, ExecutorConfig> executorConfigs) {
   724|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   725|     }
   726|     @Override
   727|     public Map<String, DurableExecutorConfig> getDurableExecutorConfigs() {
   728|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   729|     }
   730|     @Override
   731|     public Config setDurableExecutorConfigs(Map<String, DurableExecutorConfig> durableExecutorConfigs) {
   732|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   733|     }
   734|     @Override
   735|     public Map<String, ScheduledExecutorConfig> getScheduledExecutorConfigs() {
   736|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   737|     }
   738|     @Override
   739|     public Config setScheduledExecutorConfigs(Map<String, ScheduledExecutorConfig> scheduledExecutorConfigs) {
   740|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   741|     }
   742|     @Override
   743|     public Map<String, CardinalityEstimatorConfig> getCardinalityEstimatorConfigs() {
   744|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   745|     }
   746|     @Override
   747|     public Config setCardinalityEstimatorConfigs(
   748|             Map<String, CardinalityEstimatorConfig> cardinalityEstimatorConfigs) {
   749|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   750|     }
   751|     @Override
   752|     public SemaphoreConfig findSemaphoreConfig(String name) {
   753|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   754|     }
   755|     @Override
   756|     public SemaphoreConfig getSemaphoreConfig(String name) {
   757|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   758|     }
   759|     @Override
   760|     public Collection<SemaphoreConfig> getSemaphoreConfigs() {
   761|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   762|     }
   763|     @Override
   764|     public Map<String, SemaphoreConfig> getSemaphoreConfigsAsMap() {
   765|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   766|     }
   767|     @Override
   768|     public Config setSemaphoreConfigs(Map<String, SemaphoreConfig> semaphoreConfigs) {
   769|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   770|     }
   771|     @Override
   772|     public AtomicReferenceConfig findAtomicReferenceConfig(String name) {
   773|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   774|     }
   775|     @Override
   776|     public AtomicReferenceConfig getAtomicReferenceConfig(String name) {
   777|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   778|     }
   779|     @Override
   780|     public Map<String, AtomicReferenceConfig> getAtomicReferenceConfigs() {
   781|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   782|     }
   783|     @Override
   784|     public Config setAtomicReferenceConfigs(Map<String, AtomicReferenceConfig> atomicReferenceConfigs) {
   785|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   786|     }
   787|     @Override
   788|     public AtomicLongConfig findAtomicLongConfig(String name) {
   789|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   790|     }
   791|     @Override
   792|     public AtomicLongConfig getAtomicLongConfig(String name) {
   793|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   794|     }
   795|     @Override
   796|     public Map<String, AtomicLongConfig> getAtomicLongConfigs() {
   797|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   798|     }
   799|     @Override
   800|     public Config setAtomicLongConfigs(Map<String, AtomicLongConfig> atomicLongConfigs) {
   801|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   802|     }
   803|     @Override
   804|     public CountDownLatchConfig findCountDownLatchConfig(String name) {
   805|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   806|     }
   807|     @Override
   808|     public CountDownLatchConfig getCountDownLatchConfig(String name) {
   809|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   810|     }
   811|     @Override
   812|     public Map<String, CountDownLatchConfig> getCountDownLatchConfigs() {
   813|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   814|     }
   815|     @Override
   816|     public Config setCountDownLatchConfigs(Map<String, CountDownLatchConfig> countDownLatchConfigs) {
   817|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   818|     }
   819|     @Override
   820|     public WanReplicationConfig getWanReplicationConfig(String name) {
   821|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   822|     }
   823|     @Override
   824|     public Map<String, WanReplicationConfig> getWanReplicationConfigs() {
   825|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   826|     }
   827|     @Override
   828|     public Config setWanReplicationConfigs(Map<String, WanReplicationConfig> wanReplicationConfigs) {
   829|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   830|     }
   831|     @Override
   832|     public JobTrackerConfig findJobTrackerConfig(String name) {
   833|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   834|     }
   835|     @Override
   836|     public JobTrackerConfig getJobTrackerConfig(String name) {
   837|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   838|     }
   839|     @Override
   840|     public Map<String, JobTrackerConfig> getJobTrackerConfigs() {
   841|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   842|     }
   843|     @Override
   844|     public Config setJobTrackerConfigs(Map<String, JobTrackerConfig> jobTrackerConfigs) {
   845|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   846|     }
   847|     @Override
   848|     public Map<String, QuorumConfig> getQuorumConfigs() {
   849|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   850|     }
   851|     @Override
   852|     public QuorumConfig getQuorumConfig(String name) {
   853|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   854|     }
   855|     @Override
   856|     public QuorumConfig findQuorumConfig(String name) {
   857|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   858|     }
   859|     @Override
   860|     public Config setQuorumConfigs(Map<String, QuorumConfig> quorumConfigs) {
   861|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   862|     }
   863|     @Override
   864|     public ManagementCenterConfig getManagementCenterConfig() {
   865|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   866|     }
   867|     @Override
   868|     public Config setManagementCenterConfig(ManagementCenterConfig managementCenterConfig) {
   869|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   870|     }
   871|     @Override
   872|     public ServicesConfig getServicesConfig() {
   873|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   874|     }
   875|     @Override
   876|     public Config setServicesConfig(ServicesConfig servicesConfig) {
   877|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   878|     }
   879|     @Override
   880|     public SecurityConfig getSecurityConfig() {
   881|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   882|     }
   883|     @Override
   884|     public Config setSecurityConfig(SecurityConfig securityConfig) {
   885|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   886|     }
   887|     @Override
   888|     public List<ListenerConfig> getListenerConfigs() {
   889|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   890|     }
   891|     @Override
   892|     public Config setListenerConfigs(List<ListenerConfig> listenerConfigs) {
   893|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   894|     }
   895|     @Override
   896|     public SerializationConfig getSerializationConfig() {
   897|         return instance.getClientConfig().getSerializationConfig();
   898|     }
   899|     @Override
   900|     public Config setSerializationConfig(SerializationConfig serializationConfig) {
   901|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   902|     }
   903|     @Override
   904|     public PartitionGroupConfig getPartitionGroupConfig() {
   905|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   906|     }
   907|     @Override
   908|     public Config setPartitionGroupConfig(PartitionGroupConfig partitionGroupConfig) {
   909|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   910|     }
   911|     @Override
   912|     public HotRestartPersistenceConfig getHotRestartPersistenceConfig() {
   913|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   914|     }
   915|     @Override
   916|     public Config setHotRestartPersistenceConfig(HotRestartPersistenceConfig hrConfig) {
   917|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   918|     }
   919|     @Override
   920|     public CRDTReplicationConfig getCRDTReplicationConfig() {
   921|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   922|     }
   923|     @Override
   924|     public Config setCRDTReplicationConfig(CRDTReplicationConfig crdtReplicationConfig) {
   925|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   926|     }
   927|     @Override
   928|     public ManagedContext getManagedContext() {
   929|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   930|     }
   931|     @Override
   932|     public Config setManagedContext(ManagedContext managedContext) {
   933|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   934|     }
   935|     @Override
   936|     public ConcurrentMap<String, Object> getUserContext() {
   937|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   938|     }
   939|     @Override
   940|     public Config setUserContext(ConcurrentMap<String, Object> userContext) {
   941|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   942|     }
   943|     @Override
   944|     public NativeMemoryConfig getNativeMemoryConfig() {
   945|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   946|     }
   947|     @Override
   948|     public Config setNativeMemoryConfig(NativeMemoryConfig nativeMemoryConfig) {
   949|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   950|     }
   951|     @Override
   952|     public URL getConfigurationUrl() {
   953|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   954|     }
   955|     @Override
   956|     public Config setConfigurationUrl(URL configurationUrl) {
   957|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   958|     }
   959|     @Override
   960|     public File getConfigurationFile() {
   961|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   962|     }
   963|     @Override
   964|     public Config setConfigurationFile(File configurationFile) {
   965|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   966|     }
   967|     @Override
   968|     public String getLicenseKey() {
   969|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   970|     }
   971|     @Override
   972|     public Config setLicenseKey(String licenseKey) {
   973|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   974|     }
   975|     @Override
   976|     public boolean isLiteMember() {
   977|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   978|     }
   979|     @Override
   980|     public Config setLiteMember(boolean liteMember) {
   981|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   982|     }
   983|     @Override
   984|     public UserCodeDeploymentConfig getUserCodeDeploymentConfig() {
   985|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   986|     }
   987|     @Override
   988|     public Config setUserCodeDeploymentConfig(UserCodeDeploymentConfig userCodeDeploymentConfig) {
   989|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   990|     }
   991|     @Override
   992|     public FlakeIdGeneratorConfig getFlakeIdGeneratorConfig(String name) {
   993|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   994|     }
   995|     @Override
   996|     public FlakeIdGeneratorConfig findFlakeIdGeneratorConfig(String name) {
   997|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
   998|     }
   999|     @Override
  1000|     public Map<String, FlakeIdGeneratorConfig> getFlakeIdGeneratorConfigs() {
  1001|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
  1002|     }
  1003|     @Override
  1004|     public Config setFlakeIdGeneratorConfigs(Map<String, FlakeIdGeneratorConfig> map) {
  1005|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
  1006|     }
  1007|     @Override
  1008|     public MapConfig getMapConfigOrNull(String name) {
  1009|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
  1010|     }
  1011|     @Override
  1012|     public CacheSimpleConfig findCacheConfigOrNull(String name) {
  1013|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
  1014|     }
  1015|     @Override
  1016|     public PNCounterConfig findPNCounterConfig(String name) {
  1017|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
  1018|     }
  1019|     @Override
  1020|     public Map<String, PNCounterConfig> getPNCounterConfigs() {
  1021|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
  1022|     }
  1023|     @Override
  1024|     public PNCounterConfig getPNCounterConfig(String name) {
  1025|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
  1026|     }
  1027|     @Override
  1028|     public Config setPNCounterConfigs(Map<String, PNCounterConfig> pnCounterConfigs) {
  1029|         throw new UnsupportedOperationException(UNSUPPORTED_ERROR_MESSAGE);
  1030|     }
  1031|     @Override
  1032|     public String toString() {
  1033|         return "DynamicClusterConfig{instance=" + instance + "}";
  1034|     }
  1035|     private void invoke(ClientMessage request) {
  1036|         try {
  1037|             ClientInvocation invocation = new ClientInvocation(instance, request, null);
  1038|             ClientInvocationFuture future = invocation.invoke();
  1039|             future.get();
  1040|         } catch (Exception e) {
  1041|             throw rethrow(e);
  1042|         }
  1043|     }
  1044|     private List<ListenerConfigHolder> adaptListenerConfigs(List<? extends ListenerConfig> listenerConfigs) {
  1045|         List<ListenerConfigHolder> listenerConfigHolders = null;
  1046|         if (listenerConfigs != null && !listenerConfigs.isEmpty()) {
  1047|             listenerConfigHolders = new ArrayList<ListenerConfigHolder>();
  1048|             for (ListenerConfig listenerConfig : listenerConfigs) {
  1049|                 listenerConfigHolders.add(ListenerConfigHolder.of(listenerConfig, serializationService));
  1050|             }
  1051|         }
  1052|         return listenerConfigHolders;
  1053|     }
  1054| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/ClientExceptionFactory.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-724 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.impl.clientside;
    17| import com.hazelcast.cache.CacheNotExistsException;
    18| import com.hazelcast.client.AuthenticationException;
    19| import com.hazelcast.client.UndefinedErrorCodeException;
    20| import com.hazelcast.client.impl.protocol.ClientMessage;
    21| import com.hazelcast.client.impl.protocol.ClientProtocolErrorCodes;
    22| import com.hazelcast.client.impl.protocol.codec.ErrorCodec;
    23| import com.hazelcast.client.impl.protocol.exception.MaxMessageSizeExceeded;
    24| import com.hazelcast.config.ConfigurationException;
    25| import com.hazelcast.config.InvalidConfigurationException;
    26| import com.hazelcast.core.ConsistencyLostException;
    27| import com.hazelcast.core.DuplicateInstanceNameException;
    28| import com.hazelcast.core.HazelcastException;
    29| import com.hazelcast.core.HazelcastInstanceNotActiveException;
    30| import com.hazelcast.core.HazelcastOverloadException;
    31| import com.hazelcast.core.IndeterminateOperationStateException;
    32| import com.hazelcast.core.LocalMemberResetException;
    33| import com.hazelcast.core.MemberLeftException;
    34| import com.hazelcast.core.OperationTimeoutException;
    35| import com.hazelcast.crdt.MutationDisallowedException;
    36| import com.hazelcast.crdt.TargetNotReplicaException;
    37| import com.hazelcast.durableexecutor.StaleTaskIdException;
    38| import com.hazelcast.flakeidgen.impl.NodeIdOutOfRangeException;
    39| import com.hazelcast.internal.cluster.impl.ConfigMismatchException;
    40| import com.hazelcast.map.QueryResultSizeExceededException;
    41| import com.hazelcast.map.ReachedMaxSizeException;
    42| import com.hazelcast.mapreduce.RemoteMapReduceException;
    43| import com.hazelcast.mapreduce.TopologyChangedException;
    44| import com.hazelcast.memory.NativeOutOfMemoryError;
    45| import com.hazelcast.nio.serialization.HazelcastSerializationException;
    46| import com.hazelcast.partition.NoDataMemberInClusterException;
    47| import com.hazelcast.query.QueryException;
    48| import com.hazelcast.quorum.QuorumException;
    49| import com.hazelcast.replicatedmap.ReplicatedMapCantBeCreatedOnLiteMemberException;
    50| import com.hazelcast.ringbuffer.StaleSequenceException;
    51| import com.hazelcast.scheduledexecutor.DuplicateTaskException;
    52| import com.hazelcast.scheduledexecutor.StaleTaskException;
    53| import com.hazelcast.spi.exception.CallerNotMemberException;
    54| import com.hazelcast.spi.exception.DistributedObjectDestroyedException;
    55| import com.hazelcast.spi.exception.PartitionMigratingException;
    56| import com.hazelcast.spi.exception.ResponseAlreadySentException;
    57| import com.hazelcast.spi.exception.RetryableHazelcastException;
    58| import com.hazelcast.spi.exception.RetryableIOException;
    59| import com.hazelcast.spi.exception.ServiceNotFoundException;
    60| import com.hazelcast.spi.exception.TargetDisconnectedException;
    61| import com.hazelcast.spi.exception.TargetNotMemberException;
    62| import com.hazelcast.spi.exception.WrongTargetException;
    63| import com.hazelcast.topic.TopicOverloadException;
    64| import com.hazelcast.transaction.TransactionException;
    65| import com.hazelcast.transaction.TransactionNotActiveException;
    66| import com.hazelcast.transaction.TransactionTimedOutException;
    67| import com.hazelcast.util.AddressUtil;
    68| import com.hazelcast.wan.WANReplicationQueueFullException;
    69| import javax.cache.CacheException;
    70| import javax.cache.integration.CacheLoaderException;
    71| import javax.cache.integration.CacheWriterException;
    72| import javax.cache.processor.EntryProcessorException;
    73| import javax.security.auth.callback.UnsupportedCallbackException;
    74| import javax.security.auth.login.LoginException;
    75| import javax.transaction.xa.XAException;
    76| import java.io.EOFException;
    77| import java.io.IOException;
    78| import java.io.NotSerializableException;
    79| import java.io.UTFDataFormatException;
    80| import java.net.SocketException;
    81| import java.net.URISyntaxException;
    82| import java.security.AccessControlException;
    83| import java.util.Arrays;
    84| import java.util.Collections;
    85| import java.util.ConcurrentModificationException;
    86| import java.util.HashMap;
    87| import java.util.Map;
    88| import java.util.NoSuchElementException;
    89| import java.util.concurrent.CancellationException;
    90| import java.util.concurrent.ExecutionException;
    91| import java.util.concurrent.RejectedExecutionException;
    92| import java.util.concurrent.TimeoutException;
    93| import java.util.regex.Matcher;
    94| import java.util.regex.Pattern;
    95| /**
    96|  * This class has the error codes and means of
    97|  * 1) creating exception from error code
    98|  * 2) getting the error code of given exception
    99|  */
   100| public class ClientExceptionFactory {
   101|     private static final String CAUSED_BY_STACKTRACE_MARKER = "###### Caused by:";
   102|     /**
   103|      * This pattern extracts errorCode and exception message from the encoded Caused-by marker.
   104|      * It has the form:
   105|      * <pre>    ###### Caused by: (&lt;errorCode>) &lt;cause.toString()> ------</pre>
   106|      *
   107|      * As per {@link Throwable#toString()}, this has the form
   108|      * <pre>&lt;exception class>: &lt;message></pre>
   109|      *
   110|      * if message is present, or just {@code &lt;exception class>}, if message is null.
   111|      *
   112|      * <p>Commonly, exceptions with causes are created like this:
   113|      * <pre>new RuntimeException("Additional message: " + e, e);</pre>
   114|      *
   115|      * Thus, this pattern matches the marker, error code in parentheses, text up to the semicolon
   116|      * (reluctantly, as to find the first one), and optional semicolon and the rest of message.
   117|      */
   118|     private static final Pattern CAUSED_BY_STACKTRACE_PARSER = Pattern.compile(Pattern.quote(CAUSED_BY_STACKTRACE_MARKER)
   119|             + " \\((-?[0-9]+)\\) (.+?)(: (.*))? ------", Pattern.DOTALL);
   120|     private static final int CAUSED_BY_STACKTRACE_PARSER_ERROR_CODE_GROUP = 1;
   121|     private static final int CAUSED_BY_STACKTRACE_PARSER_CLASS_NAME_GROUP = 2;
   122|     private static final int CAUSED_BY_STACKTRACE_PARSER_MESSAGE_GROUP = 4;
   123|     private final Map<Integer, ExceptionFactory> intToFactory = new HashMap<Integer, ExceptionFactory>();
   124|     public ClientExceptionFactory(boolean jcacheAvailable) {
   125|         if (jcacheAvailable) {
   126|             register(ClientProtocolErrorCodes.CACHE, CacheException.class, new ExceptionFactory() {
   127|                 @Override
   128|                 public Throwable createException(String message, Throwable cause) {
   129|                     return new CacheException(message, cause);
   130|                 }
   131|             });
   132|             register(ClientProtocolErrorCodes.CACHE_LOADER, CacheLoaderException.class, new ExceptionFactory() {
   133|                 @Override
   134|                 public Throwable createException(String message, Throwable cause) {
   135|                     return new CacheLoaderException(message, cause);
   136|                 }
   137|             });
   138|             register(ClientProtocolErrorCodes.CACHE_WRITER, CacheWriterException.class, new ExceptionFactory() {
   139|                 @Override
   140|                 public Throwable createException(String message, Throwable cause) {
   141|                     return new CacheWriterException(message, cause);
   142|                 }
   143|             });
   144|             register(ClientProtocolErrorCodes.ENTRY_PROCESSOR, EntryProcessorException.class, new ExceptionFactory() {
   145|                 @Override
   146|                 public Throwable createException(String message, Throwable cause) {
   147|                     return new EntryProcessorException(message, cause);
   148|                 }
   149|             });
   150|         }
   151|         register(ClientProtocolErrorCodes.ARRAY_INDEX_OUT_OF_BOUNDS, ArrayIndexOutOfBoundsException.class, new ExceptionFactory() {
   152|             @Override
   153|             public Throwable createException(String message, Throwable cause) {
   154|                 return new ArrayIndexOutOfBoundsException(message);
   155|             }
   156|         });
   157|         register(ClientProtocolErrorCodes.ARRAY_STORE, ArrayStoreException.class, new ExceptionFactory() {
   158|             @Override
   159|             public Throwable createException(String message, Throwable cause) {
   160|                 return new ArrayStoreException(message);
   161|             }
   162|         });
   163|         register(ClientProtocolErrorCodes.AUTHENTICATION, AuthenticationException.class, new ExceptionFactory() {
   164|             @Override
   165|             public Throwable createException(String message, Throwable cause) {
   166|                 return new AuthenticationException(message);
   167|             }
   168|         });
   169|         register(ClientProtocolErrorCodes.CACHE_NOT_EXISTS, CacheNotExistsException.class, new ExceptionFactory() {
   170|             @Override
   171|             public Throwable createException(String message, Throwable cause) {
   172|                 return new CacheNotExistsException(message);
   173|             }
   174|         });
   175|         register(ClientProtocolErrorCodes.CALLER_NOT_MEMBER, CallerNotMemberException.class, new ExceptionFactory() {
   176|             @Override
   177|             public Throwable createException(String message, Throwable cause) {
   178|                 return new CallerNotMemberException(message);
   179|             }
   180|         });
   181|         register(ClientProtocolErrorCodes.CANCELLATION, CancellationException.class, new ExceptionFactory() {
   182|             @Override
   183|             public Throwable createException(String message, Throwable cause) {
   184|                 return new CancellationException(message);
   185|             }
   186|         });
   187|         register(ClientProtocolErrorCodes.CLASS_CAST, ClassCastException.class, new ExceptionFactory() {
   188|             @Override
   189|             public Throwable createException(String message, Throwable cause) {
   190|                 return new ClassCastException(message);
   191|             }
   192|         });
   193|         register(ClientProtocolErrorCodes.CLASS_NOT_FOUND, ClassNotFoundException.class, new ExceptionFactory() {
   194|             @Override
   195|             public Throwable createException(String message, Throwable cause) {
   196|                 return new ClassNotFoundException(message, cause);
   197|             }
   198|         });
   199|         register(ClientProtocolErrorCodes.CONCURRENT_MODIFICATION, ConcurrentModificationException.class, new ExceptionFactory() {
   200|             @Override
   201|             public Throwable createException(String message, Throwable cause) {
   202|                 return new ConcurrentModificationException(message);
   203|             }
   204|         });
   205|         register(ClientProtocolErrorCodes.CONFIG_MISMATCH, ConfigMismatchException.class, new ExceptionFactory() {
   206|             @Override
   207|             public Throwable createException(String message, Throwable cause) {
   208|                 return new ConfigMismatchException(message);
   209|             }
   210|         });
   211|         register(ClientProtocolErrorCodes.CONFIGURATION, ConfigurationException.class, new ExceptionFactory() {
   212|             @Override
   213|             public Throwable createException(String message, Throwable cause) {
   214|                 return new ConfigurationException(message);
   215|             }
   216|         });
   217|         register(ClientProtocolErrorCodes.DISTRIBUTED_OBJECT_DESTROYED, DistributedObjectDestroyedException.class, new ExceptionFactory() {
   218|             @Override
   219|             public Throwable createException(String message, Throwable cause) {
   220|                 return new DistributedObjectDestroyedException(message);
   221|             }
   222|         });
   223|         register(ClientProtocolErrorCodes.DUPLICATE_INSTANCE_NAME, DuplicateInstanceNameException.class, new ExceptionFactory() {
   224|             @Override
   225|             public Throwable createException(String message, Throwable cause) {
   226|                 return new DuplicateInstanceNameException(message);
   227|             }
   228|         });
   229|         register(ClientProtocolErrorCodes.EOF, EOFException.class, new ExceptionFactory() {
   230|             @Override
   231|             public Throwable createException(String message, Throwable cause) {
   232|                 return new EOFException(message);
   233|             }
   234|         });
   235|         register(ClientProtocolErrorCodes.EXECUTION, ExecutionException.class, new ExceptionFactory() {
   236|             @Override
   237|             public Throwable createException(String message, Throwable cause) {
   238|                 return new ExecutionException(message, cause);
   239|             }
   240|         });
   241|         register(ClientProtocolErrorCodes.HAZELCAST, HazelcastException.class, new ExceptionFactory() {
   242|             @Override
   243|             public Throwable createException(String message, Throwable cause) {
   244|                 return new HazelcastException(message, cause);
   245|             }
   246|         });
   247|         register(ClientProtocolErrorCodes.HAZELCAST_INSTANCE_NOT_ACTIVE, HazelcastInstanceNotActiveException.class, new ExceptionFactory() {
   248|             @Override
   249|             public Throwable createException(String message, Throwable cause) {
   250|                 return new HazelcastInstanceNotActiveException(message);
   251|             }
   252|         });
   253|         register(ClientProtocolErrorCodes.HAZELCAST_OVERLOAD, HazelcastOverloadException.class, new ExceptionFactory() {
   254|             @Override
   255|             public Throwable createException(String message, Throwable cause) {
   256|                 return new HazelcastOverloadException(message);
   257|             }
   258|         });
   259|         register(ClientProtocolErrorCodes.HAZELCAST_SERIALIZATION, HazelcastSerializationException.class, new ExceptionFactory() {
   260|             @Override
   261|             public Throwable createException(String message, Throwable cause) {
   262|                 return new HazelcastSerializationException(message, cause);
   263|             }
   264|         });
   265|         register(ClientProtocolErrorCodes.IO, IOException.class, new ExceptionFactory() {
   266|             @Override
   267|             public Throwable createException(String message, Throwable cause) {
   268|                 return new IOException(message, cause);
   269|             }
   270|         });
   271|         register(ClientProtocolErrorCodes.ILLEGAL_ARGUMENT, IllegalArgumentException.class, new ExceptionFactory() {
   272|             @Override
   273|             public Throwable createException(String message, Throwable cause) {
   274|                 return new IllegalArgumentException(message, cause);
   275|             }
   276|         });
   277|         register(ClientProtocolErrorCodes.ILLEGAL_ACCESS_EXCEPTION, IllegalAccessException.class, new ExceptionFactory() {
   278|             @Override
   279|             public Throwable createException(String message, Throwable cause) {
   280|                 return new IllegalAccessException(message);
   281|             }
   282|         });
   283|         register(ClientProtocolErrorCodes.ILLEGAL_ACCESS_ERROR, IllegalAccessError.class, new ExceptionFactory() {
   284|             @Override
   285|             public Throwable createException(String message, Throwable cause) {
   286|                 return new IllegalAccessError(message);
   287|             }
   288|         });
   289|         register(ClientProtocolErrorCodes.ILLEGAL_MONITOR_STATE, IllegalMonitorStateException.class, new ExceptionFactory() {
   290|             @Override
   291|             public Throwable createException(String message, Throwable cause) {
   292|                 return new IllegalMonitorStateException(message);
   293|             }
   294|         });
   295|         register(ClientProtocolErrorCodes.ILLEGAL_STATE, IllegalStateException.class, new ExceptionFactory() {
   296|             @Override
   297|             public Throwable createException(String message, Throwable cause) {
   298|                 return new IllegalStateException(message, cause);
   299|             }
   300|         });
   301|         register(ClientProtocolErrorCodes.ILLEGAL_THREAD_STATE, IllegalThreadStateException.class, new ExceptionFactory() {
   302|             @Override
   303|             public Throwable createException(String message, Throwable cause) {
   304|                 return new IllegalThreadStateException(message);
   305|             }
   306|         });
   307|         register(ClientProtocolErrorCodes.INDEX_OUT_OF_BOUNDS, IndexOutOfBoundsException.class, new ExceptionFactory() {
   308|             @Override
   309|             public Throwable createException(String message, Throwable cause) {
   310|                 return new IndexOutOfBoundsException(message);
   311|             }
   312|         });
   313|         register(ClientProtocolErrorCodes.INTERRUPTED, InterruptedException.class, new ExceptionFactory() {
   314|             @Override
   315|             public Throwable createException(String message, Throwable cause) {
   316|                 return new InterruptedException(message);
   317|             }
   318|         });
   319|         register(ClientProtocolErrorCodes.INVALID_ADDRESS, AddressUtil.InvalidAddressException.class, new ExceptionFactory() {
   320|             @Override
   321|             public Throwable createException(String message, Throwable cause) {
   322|                 return new AddressUtil.InvalidAddressException(message, false);
   323|             }
   324|         });
   325|         register(ClientProtocolErrorCodes.INVALID_CONFIGURATION, InvalidConfigurationException.class, new ExceptionFactory() {
   326|             @Override
   327|             public Throwable createException(String message, Throwable cause) {
   328|                 return new InvalidConfigurationException(message, cause);
   329|             }
   330|         });
   331|         register(ClientProtocolErrorCodes.MEMBER_LEFT, MemberLeftException.class, new ExceptionFactory() {
   332|             @Override
   333|             public Throwable createException(String message, Throwable cause) {
   334|                 return new MemberLeftException(message);
   335|             }
   336|         });
   337|         register(ClientProtocolErrorCodes.NEGATIVE_ARRAY_SIZE, NegativeArraySizeException.class, new ExceptionFactory() {
   338|             @Override
   339|             public Throwable createException(String message, Throwable cause) {
   340|                 return new NegativeArraySizeException(message);
   341|             }
   342|         });
   343|         register(ClientProtocolErrorCodes.NO_SUCH_ELEMENT, NoSuchElementException.class, new ExceptionFactory() {
   344|             @Override
   345|             public Throwable createException(String message, Throwable cause) {
   346|                 return new NoSuchElementException(message);
   347|             }
   348|         });
   349|         register(ClientProtocolErrorCodes.NOT_SERIALIZABLE, NotSerializableException.class, new ExceptionFactory() {
   350|             @Override
   351|             public Throwable createException(String message, Throwable cause) {
   352|                 return new NotSerializableException(message);
   353|             }
   354|         });
   355|         register(ClientProtocolErrorCodes.NULL_POINTER, NullPointerException.class, new ExceptionFactory() {
   356|             @Override
   357|             public Throwable createException(String message, Throwable cause) {
   358|                 return new NullPointerException(message);
   359|             }
   360|         });
   361|         register(ClientProtocolErrorCodes.OPERATION_TIMEOUT, OperationTimeoutException.class, new ExceptionFactory() {
   362|             @Override
   363|             public Throwable createException(String message, Throwable cause) {
   364|                 return new OperationTimeoutException(message);
   365|             }
   366|         });
   367|         register(ClientProtocolErrorCodes.PARTITION_MIGRATING, PartitionMigratingException.class, new ExceptionFactory() {
   368|             @Override
   369|             public Throwable createException(String message, Throwable cause) {
   370|                 return new PartitionMigratingException(message);
   371|             }
   372|         });
   373|         register(ClientProtocolErrorCodes.QUERY, QueryException.class, new ExceptionFactory() {
   374|             @Override
   375|             public Throwable createException(String message, Throwable cause) {
   376|                 return new QueryException(message, cause);
   377|             }
   378|         });
   379|         register(ClientProtocolErrorCodes.QUERY_RESULT_SIZE_EXCEEDED, QueryResultSizeExceededException.class, new ExceptionFactory() {
   380|             @Override
   381|             public Throwable createException(String message, Throwable cause) {
   382|                 return new QueryResultSizeExceededException(message);
   383|             }
   384|         });
   385|         register(ClientProtocolErrorCodes.QUORUM, QuorumException.class, new ExceptionFactory() {
   386|             @Override
   387|             public Throwable createException(String message, Throwable cause) {
   388|                 return new QuorumException(message);
   389|             }
   390|         });
   391|         register(ClientProtocolErrorCodes.REACHED_MAX_SIZE, ReachedMaxSizeException.class, new ExceptionFactory() {
   392|             @Override
   393|             public Throwable createException(String message, Throwable cause) {
   394|                 return new ReachedMaxSizeException(message);
   395|             }
   396|         });
   397|         register(ClientProtocolErrorCodes.REJECTED_EXECUTION, RejectedExecutionException.class, new ExceptionFactory() {
   398|             @Override
   399|             public Throwable createException(String message, Throwable cause) {
   400|                 return new RejectedExecutionException(message, cause);
   401|             }
   402|         });
   403|         register(ClientProtocolErrorCodes.REMOTE_MAP_REDUCE, RemoteMapReduceException.class, new ExceptionFactory() {
   404|             @Override
   405|             public Throwable createException(String message, Throwable cause) {
   406|                 return new RemoteMapReduceException(message, Collections.<Exception>emptyList());
   407|             }
   408|         });
   409|         register(ClientProtocolErrorCodes.RESPONSE_ALREADY_SENT, ResponseAlreadySentException.class, new ExceptionFactory() {
   410|             @Override
   411|             public Throwable createException(String message, Throwable cause) {
   412|                 return new ResponseAlreadySentException(message);
   413|             }
   414|         });
   415|         register(ClientProtocolErrorCodes.RETRYABLE_HAZELCAST, RetryableHazelcastException.class, new ExceptionFactory() {
   416|             @Override
   417|             public Throwable createException(String message, Throwable cause) {
   418|                 return new RetryableHazelcastException(message, cause);
   419|             }
   420|         });
   421|         register(ClientProtocolErrorCodes.RETRYABLE_IO, RetryableIOException.class, new ExceptionFactory() {
   422|             @Override
   423|             public Throwable createException(String message, Throwable cause) {
   424|                 return new RetryableIOException(message, cause);
   425|             }
   426|         });
   427|         register(ClientProtocolErrorCodes.RUNTIME, RuntimeException.class, new ExceptionFactory() {
   428|             @Override
   429|             public Throwable createException(String message, Throwable cause) {
   430|                 return new RuntimeException(message, cause);
   431|             }
   432|         });
   433|         register(ClientProtocolErrorCodes.SECURITY, SecurityException.class, new ExceptionFactory() {
   434|             @Override
   435|             public Throwable createException(String message, Throwable cause) {
   436|                 return new SecurityException(message, cause);
   437|             }
   438|         });
   439|         register(ClientProtocolErrorCodes.SOCKET, SocketException.class, new ExceptionFactory() {
   440|             @Override
   441|             public Throwable createException(String message, Throwable cause) {
   442|                 return new SocketException(message);
   443|             }
   444|         });
   445|         register(ClientProtocolErrorCodes.STALE_SEQUENCE, StaleSequenceException.class, new ExceptionFactory() {
   446|             @Override
   447|             public Throwable createException(String message, Throwable cause) {
   448|                 return new StaleSequenceException(message, 0);
   449|             }
   450|         });
   451|         register(ClientProtocolErrorCodes.TARGET_DISCONNECTED, TargetDisconnectedException.class, new ExceptionFactory() {
   452|             @Override
   453|             public Throwable createException(String message, Throwable cause) {
   454|                 return new TargetDisconnectedException(message);
   455|             }
   456|         });
   457|         register(ClientProtocolErrorCodes.TARGET_NOT_MEMBER, TargetNotMemberException.class, new ExceptionFactory() {
   458|             @Override
   459|             public Throwable createException(String message, Throwable cause) {
   460|                 return new TargetNotMemberException(message);
   461|             }
   462|         });
   463|         register(ClientProtocolErrorCodes.TIMEOUT, TimeoutException.class, new ExceptionFactory() {
   464|             @Override
   465|             public Throwable createException(String message, Throwable cause) {
   466|                 return new TimeoutException(message);
   467|             }
   468|         });
   469|         register(ClientProtocolErrorCodes.TOPIC_OVERLOAD, TopicOverloadException.class, new ExceptionFactory() {
   470|             @Override
   471|             public Throwable createException(String message, Throwable cause) {
   472|                 return new TopicOverloadException(message);
   473|             }
   474|         });
   475|         register(ClientProtocolErrorCodes.TOPOLOGY_CHANGED, TopologyChangedException.class, new ExceptionFactory() {
   476|             @Override
   477|             public Throwable createException(String message, Throwable cause) {
   478|                 return new TopologyChangedException(message);
   479|             }
   480|         });
   481|         register(ClientProtocolErrorCodes.TRANSACTION, TransactionException.class, new ExceptionFactory() {
   482|             @Override
   483|             public Throwable createException(String message, Throwable cause) {
   484|                 return new TransactionException(message, cause);
   485|             }
   486|         });
   487|         register(ClientProtocolErrorCodes.TRANSACTION_NOT_ACTIVE, TransactionNotActiveException.class, new ExceptionFactory() {
   488|             @Override
   489|             public Throwable createException(String message, Throwable cause) {
   490|                 return new TransactionNotActiveException(message);
   491|             }
   492|         });
   493|         register(ClientProtocolErrorCodes.TRANSACTION_TIMED_OUT, TransactionTimedOutException.class, new ExceptionFactory() {
   494|             @Override
   495|             public Throwable createException(String message, Throwable cause) {
   496|                 return new TransactionTimedOutException(message, cause);
   497|             }
   498|         });
   499|         register(ClientProtocolErrorCodes.URI_SYNTAX, URISyntaxException.class, new ExceptionFactory() {
   500|             @Override
   501|             public Throwable createException(String message, Throwable cause) {
   502|                 return new URISyntaxException("not available", message);
   503|             }
   504|         });
   505|         register(ClientProtocolErrorCodes.UTF_DATA_FORMAT, UTFDataFormatException.class, new ExceptionFactory() {
   506|             @Override
   507|             public Throwable createException(String message, Throwable cause) {
   508|                 return new UTFDataFormatException(message);
   509|             }
   510|         });
   511|         register(ClientProtocolErrorCodes.UNSUPPORTED_OPERATION, UnsupportedOperationException.class, new ExceptionFactory() {
   512|             @Override
   513|             public Throwable createException(String message, Throwable cause) {
   514|                 return new UnsupportedOperationException(message, cause);
   515|             }
   516|         });
   517|         register(ClientProtocolErrorCodes.WRONG_TARGET, WrongTargetException.class, new ExceptionFactory() {
   518|             @Override
   519|             public Throwable createException(String message, Throwable cause) {
   520|                 return new WrongTargetException(message);
   521|             }
   522|         });
   523|         register(ClientProtocolErrorCodes.XA, XAException.class, new ExceptionFactory() {
   524|             @Override
   525|             public Throwable createException(String message, Throwable cause) {
   526|                 return new XAException(message);
   527|             }
   528|         });
   529|         register(ClientProtocolErrorCodes.ACCESS_CONTROL, AccessControlException.class, new ExceptionFactory() {
   530|             @Override
   531|             public Throwable createException(String message, Throwable cause) {
   532|                 return new AccessControlException(message);
   533|             }
   534|         });
   535|         register(ClientProtocolErrorCodes.LOGIN, LoginException.class, new ExceptionFactory() {
   536|             @Override
   537|             public Throwable createException(String message, Throwable cause) {
   538|                 return new LoginException(message);
   539|             }
   540|         });
   541|         register(ClientProtocolErrorCodes.UNSUPPORTED_CALLBACK, UnsupportedCallbackException.class, new ExceptionFactory() {
   542|             @Override
   543|             public Throwable createException(String message, Throwable cause) {
   544|                 return new UnsupportedCallbackException(null, message);
   545|             }
   546|         });
   547|         register(ClientProtocolErrorCodes.NO_DATA_MEMBER, NoDataMemberInClusterException.class, new ExceptionFactory() {
   548|             @Override
   549|             public Throwable createException(String message, Throwable cause) {
   550|                 return new NoDataMemberInClusterException(message);
   551|             }
   552|         });
   553|         register(ClientProtocolErrorCodes.REPLICATED_MAP_CANT_BE_CREATED, ReplicatedMapCantBeCreatedOnLiteMemberException.class, new ExceptionFactory() {
   554|             @Override
   555|             public Throwable createException(String message, Throwable cause) {
   556|                 return new ReplicatedMapCantBeCreatedOnLiteMemberException(message);
   557|             }
   558|         });
   559|         register(ClientProtocolErrorCodes.MAX_MESSAGE_SIZE_EXCEEDED, MaxMessageSizeExceeded.class, new ExceptionFactory() {
   560|             @Override
   561|             public Throwable createException(String message, Throwable cause) {
   562|                 return new MaxMessageSizeExceeded();
   563|             }
   564|         });
   565|         register(ClientProtocolErrorCodes.WAN_REPLICATION_QUEUE_FULL, WANReplicationQueueFullException.class, new ExceptionFactory() {
   566|             @Override
   567|             public Throwable createException(String message, Throwable cause) {
   568|                 return new WANReplicationQueueFullException(message);
   569|             }
   570|         });
   571|         register(ClientProtocolErrorCodes.ASSERTION_ERROR, AssertionError.class, new ExceptionFactory() {
   572|             @Override
   573|             public Throwable createException(String message, Throwable cause) {
   574|                 return new AssertionError(message);
   575|             }
   576|         });
   577|         register(ClientProtocolErrorCodes.OUT_OF_MEMORY_ERROR, OutOfMemoryError.class, new ExceptionFactory() {
   578|             @Override
   579|             public Throwable createException(String message, Throwable cause) {
   580|                 return new OutOfMemoryError(message);
   581|             }
   582|         });
   583|         register(ClientProtocolErrorCodes.STACK_OVERFLOW_ERROR, StackOverflowError.class, new ExceptionFactory() {
   584|             @Override
   585|             public Throwable createException(String message, Throwable cause) {
   586|                 return new StackOverflowError(message);
   587|             }
   588|         });
   589|         register(ClientProtocolErrorCodes.NATIVE_OUT_OF_MEMORY_ERROR, NativeOutOfMemoryError.class, new ExceptionFactory() {
   590|             @Override
   591|             public Throwable createException(String message, Throwable cause) {
   592|                 return new NativeOutOfMemoryError(message, cause);
   593|             }
   594|         });
   595|         register(ClientProtocolErrorCodes.SERVICE_NOT_FOUND, ServiceNotFoundException.class, new ExceptionFactory() {
   596|             @Override
   597|             public Throwable createException(String message, Throwable cause) {
   598|                 return new ServiceNotFoundException(message);
   599|             }
   600|         });
   601|         register(ClientProtocolErrorCodes.STALE_TASK_ID, StaleTaskIdException.class, new ExceptionFactory() {
   602|             @Override
   603|             public Throwable createException(String message, Throwable cause) {
   604|                 return new StaleTaskIdException(message);
   605|             }
   606|         });
   607|         register(ClientProtocolErrorCodes.DUPLICATE_TASK, DuplicateTaskException.class, new ExceptionFactory() {
   608|             @Override
   609|             public Throwable createException(String message, Throwable cause) {
   610|                 return new DuplicateTaskException(message);
   611|             }
   612|         });
   613|         register(ClientProtocolErrorCodes.STALE_TASK, StaleTaskException.class, new ExceptionFactory() {
   614|             @Override
   615|             public Throwable createException(String message, Throwable cause) {
   616|                 return new StaleTaskException(message);
   617|             }
   618|         });
   619|         register(ClientProtocolErrorCodes.LOCAL_MEMBER_RESET, LocalMemberResetException.class, new ExceptionFactory() {
   620|             @Override
   621|             public Throwable createException(String message, Throwable cause) {
   622|                 return new LocalMemberResetException(message);
   623|             }
   624|         });
   625|         register(ClientProtocolErrorCodes.INDETERMINATE_OPERATION_STATE, IndeterminateOperationStateException.class, new ExceptionFactory() {
   626|             @Override
   627|             public Throwable createException(String message, Throwable cause) {
   628|                 return new IndeterminateOperationStateException(message, cause);
   629|             }
   630|         });
   631|         register(ClientProtocolErrorCodes.FLAKE_ID_NODE_ID_OUT_OF_RANGE_EXCEPTION, NodeIdOutOfRangeException.class, new ExceptionFactory() {
   632|             @Override
   633|             public Throwable createException(String message, Throwable cause) {
   634|                 return new NodeIdOutOfRangeException(message);
   635|             }
   636|         });
   637|         register(ClientProtocolErrorCodes.TARGET_NOT_REPLICA_EXCEPTION, TargetNotReplicaException.class, new ExceptionFactory() {
   638|             @Override
   639|             public Throwable createException(String message, Throwable cause) {
   640|                 return new TargetNotReplicaException(message);
   641|             }
   642|         });
   643|         register(ClientProtocolErrorCodes.MUTATION_DISALLOWED_EXCEPTION, MutationDisallowedException.class, new ExceptionFactory() {
   644|             @Override
   645|             public Throwable createException(String message, Throwable cause) {
   646|                 return new MutationDisallowedException(message);
   647|             }
   648|         });
   649|         register(ClientProtocolErrorCodes.CONSISTENCY_LOST_EXCEPTION, ConsistencyLostException.class, new ExceptionFactory() {
   650|             @Override
   651|             public Throwable createException(String message, Throwable cause) {
   652|                 return new ConsistencyLostException(message);
   653|             }
   654|         });
   655|     }
   656|     public Throwable createException(ClientMessage clientMessage) {
   657|         ErrorCodec parameters = ErrorCodec.decode(clientMessage);
   658|         boolean causedByMarkerFound = false;
   659|         for (int i = 0; ! causedByMarkerFound && i < parameters.stackTrace.length; i++) {
   660|             causedByMarkerFound = parameters.stackTrace[i].getClassName().startsWith(CAUSED_BY_STACKTRACE_MARKER);
   661|         }
   662|         if (causedByMarkerFound) {
   663|             StackTraceElement[] st = parameters.stackTrace;
   664|             int pos = st.length;
   665|             int lastPos = pos;
   666|             Throwable t = null;
   667|             while (pos >= 0) {
   668|                 Throwable t1 = null;
   669|                 if (pos == 0) {
   670|                     t1 = createException(parameters.errorCode, parameters.className, parameters.message, t);
   671|                 } else if (st[pos - 1].getClassName().startsWith(CAUSED_BY_STACKTRACE_MARKER)) {
   672|                     Matcher matcher = CAUSED_BY_STACKTRACE_PARSER.matcher(st[pos - 1].getClassName());
   673|                     if (matcher.find()) {
   674|                         int errorCode = Integer.parseInt(matcher.group(CAUSED_BY_STACKTRACE_PARSER_ERROR_CODE_GROUP));
   675|                         String className = matcher.group(CAUSED_BY_STACKTRACE_PARSER_CLASS_NAME_GROUP);
   676|                         String message = matcher.group(CAUSED_BY_STACKTRACE_PARSER_MESSAGE_GROUP);
   677|                         t1 = createException(errorCode, className, message, t);
   678|                     } else {
   679|                         t1 = createException(ClientProtocolErrorCodes.UNDEFINED, st[pos - 1].toString(), null, t);
   680|                     }
   681|                 }
   682|                 if (t1 != null) {
   683|                     t1.setStackTrace(Arrays.copyOfRange(st, pos, lastPos));
   684|                     pos--;
   685|                     lastPos = pos;
   686|                     t = t1;
   687|                 }
   688|                 pos--;
   689|             }
   690|             return t;
   691|         } else {
   692|             Throwable cause = null;
   693|             if (parameters.causeClassName != null) {
   694|                 cause = createException(parameters.causeErrorCode, parameters.causeClassName, null, null);
   695|             }
   696|             Throwable throwable = createException(parameters.errorCode, parameters.className, parameters.message, cause);
   697|             throwable.setStackTrace(parameters.stackTrace);
   698|             return throwable;
   699|         }
   700|     }
   701|     private Throwable createException(int errorCode, String className, String message, Throwable cause) {
   702|         ExceptionFactory exceptionFactory = intToFactory.get(errorCode);
   703|         Throwable throwable;
   704|         if (exceptionFactory == null) {
   705|             throwable = new UndefinedErrorCodeException(message, className);
   706|         } else {
   707|             throwable = exceptionFactory.createException(message, cause);
   708|         }
   709|         return throwable;
   710|     }
   711|     @SuppressWarnings("WeakerAccess")
   712|     public void register(int errorCode, Class clazz, ExceptionFactory exceptionFactory) {
   713|         if (intToFactory.containsKey(errorCode)) {
   714|             throw new HazelcastException("Code " + errorCode + " already used");
   715|         }
   716|         if (!clazz.equals(exceptionFactory.createException("", null).getClass())) {
   717|             throw new HazelcastException("Exception factory did not produce an instance of expected class");
   718|         }
   719|         intToFactory.put(errorCode, exceptionFactory);
   720|     }
   721|     public interface ExceptionFactory {
   722|         Throwable createException(String message, Throwable cause);
   723|     }
   724| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/ClientICacheManager.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-56 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.impl.clientside;
    17| import com.hazelcast.cache.HazelcastCacheManager;
    18| import com.hazelcast.cache.ICache;
    19| import com.hazelcast.cache.impl.ICacheService;
    20| import com.hazelcast.client.spi.impl.ClientServiceNotFoundException;
    21| import com.hazelcast.core.HazelcastException;
    22| import com.hazelcast.core.HazelcastInstance;
    23| import com.hazelcast.core.ICacheManager;
    24| import com.hazelcast.spi.exception.ServiceNotFoundException;
    25| import static com.hazelcast.util.Preconditions.checkNotNull;
    26| /**
    27|  * Hazelcast instance cache manager provides a means to obtain JCache caches via HazelcastInstance API.
    28|  * Note that this is not a JCache {@code CacheManager}.
    29|  *
    30|  * @see ICacheManager
    31|  */
    32| public class ClientICacheManager implements ICacheManager {
    33|     private final HazelcastInstance instance;
    34|     ClientICacheManager(HazelcastInstance instance) {
    35|         this.instance = instance;
    36|     }
    37|     @Override
    38|     public <K, V> ICache<K, V> getCache(String name) {
    39|         checkNotNull(name, "Retrieving a cache instance with a null name is not allowed!");
    40|         return getCacheByFullName(HazelcastCacheManager.CACHE_MANAGER_PREFIX + name);
    41|     }
    42|     public <K, V> ICache<K, V> getCacheByFullName(String fullName) {
    43|         checkNotNull(fullName, "Retrieving a cache instance with a null name is not allowed!");
    44|         try {
    45|             return instance.getDistributedObject(ICacheService.SERVICE_NAME, fullName);
    46|         } catch (ClientServiceNotFoundException e) {
    47|             throw new IllegalStateException("At client, " + ICacheService.CACHE_SUPPORT_NOT_AVAILABLE_ERROR_MESSAGE);
    48|         } catch (HazelcastException e) {
    49|             if (e.getCause() instanceof ServiceNotFoundException) {
    50|                 throw new IllegalStateException("At server, " + ICacheService.CACHE_SUPPORT_NOT_AVAILABLE_ERROR_MESSAGE);
    51|             } else {
    52|                 throw e;
    53|             }
    54|         }
    55|     }
    56| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/ClientImpl.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-42 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.impl.clientside;
    17| import com.hazelcast.core.Client;
    18| import com.hazelcast.core.ClientType;
    19| import java.net.InetSocketAddress;
    20| /**
    21|  * Default {@link com.hazelcast.core.Client} implementation.
    22|  */
    23| public class ClientImpl implements Client {
    24|     private final String uuid;
    25|     private final InetSocketAddress socketAddress;
    26|     public ClientImpl(String uuid, InetSocketAddress socketAddress) {
    27|         this.uuid = uuid;
    28|         this.socketAddress = socketAddress;
    29|     }
    30|     @Override
    31|     public String getUuid() {
    32|         return uuid;
    33|     }
    34|     @Override
    35|     public InetSocketAddress getSocketAddress() {
    36|         return socketAddress;
    37|     }
    38|     @Override
    39|     public ClientType getClientType() {
    40|         return ClientType.JAVA;
    41|     }
    42| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/ClientLockReferenceIdGenerator.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-33 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.impl.clientside;
    17| import java.util.concurrent.atomic.AtomicLong;
    18| /**
    19|  * This class generates unique (per client) incrementing reference ID which is used during locking related requests.
    20|  * The server side uses this ID to match if any previous request with the same ID was issued and shall not re-do the lock related
    21|  * operation but it shall just return the previous result. Hence, this ID identifies the outstanding request sent to the server
    22|  * side for locking operations. Similarly, if the client resends the request to the server for some reason it will use the same
    23|  * reference ID to make sure that the operation is not executed more than once at the server side.
    24|  */
    25| public final class ClientLockReferenceIdGenerator {
    26|     private AtomicLong referenceIdCounter = new AtomicLong();
    27|     /**
    28|      * @return A per client unique reference ID
    29|      */
    30|     public long getNextReferenceId() {
    31|         return referenceIdCounter.incrementAndGet();
    32|     }
    33| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/ClientLoggingService.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-93 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.impl.clientside;
    17| import com.hazelcast.instance.BuildInfo;
    18| import com.hazelcast.instance.JetBuildInfo;
    19| import com.hazelcast.logging.AbstractLogger;
    20| import com.hazelcast.logging.ILogger;
    21| import com.hazelcast.logging.LogEvent;
    22| import com.hazelcast.logging.LogListener;
    23| import com.hazelcast.logging.Logger;
    24| import com.hazelcast.logging.LoggerFactory;
    25| import com.hazelcast.logging.LoggingService;
    26| import com.hazelcast.util.ConstructorFunction;
    27| import java.util.concurrent.ConcurrentHashMap;
    28| import java.util.concurrent.ConcurrentMap;
    29| import java.util.logging.Level;
    30| import static com.hazelcast.util.ConcurrencyUtil.getOrPutIfAbsent;
    31| public class ClientLoggingService implements LoggingService {
    32|     private final ConcurrentMap<String, ILogger> mapLoggers = new ConcurrentHashMap<String, ILogger>(100);
    33|     private final ConstructorFunction<String, ILogger> loggerConstructor
    34|             = new ConstructorFunction<String, ILogger>() {
    35|         @Override
    36|         public ILogger createNew(String key) {
    37|             return new DefaultLogger(key);
    38|         }
    39|     };
    40|     private final LoggerFactory loggerFactory;
    41|     private final String versionMessage;
    42|     public ClientLoggingService(String groupName, String loggingType, BuildInfo buildInfo, String clientName) {
    43|         this.loggerFactory = Logger.newLoggerFactory(loggingType);
    44|         JetBuildInfo jetBuildInfo = buildInfo.getJetBuildInfo();
    45|         this.versionMessage = clientName + " [" + groupName + "]"
    46|                 + (jetBuildInfo != null ? " [" + jetBuildInfo.getVersion() + "]" : "")
    47|                 + " [" + buildInfo.getVersion() + "] ";
    48|     }
    49|     @Override
    50|     public void addLogListener(Level level, LogListener logListener) {
    51|         throw new UnsupportedOperationException();
    52|     }
    53|     @Override
    54|     public void removeLogListener(LogListener logListener) {
    55|         throw new UnsupportedOperationException();
    56|     }
    57|     public ILogger getLogger(String name) {
    58|         return getOrPutIfAbsent(mapLoggers, name, loggerConstructor);
    59|     }
    60|     public ILogger getLogger(Class clazz) {
    61|         return getOrPutIfAbsent(mapLoggers, clazz.getName(), loggerConstructor);
    62|     }
    63|     private class DefaultLogger extends AbstractLogger {
    64|         final String name;
    65|         final ILogger logger;
    66|         DefaultLogger(String name) {
    67|             this.name = name;
    68|             this.logger = loggerFactory.getLogger(name);
    69|         }
    70|         @Override
    71|         public void log(Level level, String message) {
    72|             log(level, message, null);
    73|         }
    74|         @Override
    75|         public void log(Level level, String message, Throwable thrown) {
    76|             if (logger.isLoggable(level)) {
    77|                 String logMessage = versionMessage + message;
    78|                 logger.log(level, logMessage, thrown);
    79|             }
    80|         }
    81|         @Override
    82|         public void log(LogEvent logEvent) {
    83|         }
    84|         @Override
    85|         public Level getLevel() {
    86|             return logger.getLevel();
    87|         }
    88|         @Override
    89|         public boolean isLoggable(Level level) {
    90|             return logger.isLoggable(level);
    91|         }
    92|     }
    93| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/ClientMessageDecoder.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-23 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.impl.clientside;
    17| import com.hazelcast.client.impl.protocol.ClientMessage;
    18| /**
    19|  * Interface to pass specific decode methods to generic data structures that is dealing with client message
    20|  */
    21| public interface ClientMessageDecoder {
    22|     <T> T decodeClientMessage(ClientMessage clientMessage);
    23| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/DefaultClientConnectionManagerFactory.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-31 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.impl.clientside;
    17| import com.hazelcast.client.connection.AddressProvider;
    18| import com.hazelcast.client.connection.AddressTranslator;
    19| import com.hazelcast.client.connection.ClientConnectionManager;
    20| import com.hazelcast.client.connection.nio.ClientConnectionManagerImpl;
    21| import java.util.Collection;
    22| public class DefaultClientConnectionManagerFactory implements ClientConnectionManagerFactory {
    23|     public DefaultClientConnectionManagerFactory() {
    24|     }
    25|     @Override
    26|     public ClientConnectionManager createConnectionManager(HazelcastClientInstanceImpl client,
    27|                                                            AddressTranslator addressTranslator,
    28|                                                            Collection<AddressProvider> addressProviders) {
    29|         return new ClientConnectionManagerImpl(client, addressTranslator, addressProviders);
    30|     }
    31| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/DefaultClientExtension.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-161 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.impl.clientside;
    17| import com.hazelcast.client.ClientExtension;
    18| import com.hazelcast.client.HazelcastClientNotActiveException;
    19| import com.hazelcast.client.config.ClientConfig;
    20| import com.hazelcast.client.config.ClientNetworkConfig;
    21| import com.hazelcast.client.config.SocketOptions;
    22| import com.hazelcast.client.connection.nio.ClientPlainChannelInitializer;
    23| import com.hazelcast.client.proxy.ClientMapProxy;
    24| import com.hazelcast.client.proxy.NearCachedClientMapProxy;
    25| import com.hazelcast.client.spi.ClientContext;
    26| import com.hazelcast.client.spi.ClientExecutionService;
    27| import com.hazelcast.client.spi.ClientProxy;
    28| import com.hazelcast.client.spi.ClientProxyFactory;
    29| import com.hazelcast.client.spi.impl.ClientProxyFactoryWithContext;
    30| import com.hazelcast.config.NearCacheConfig;
    31| import com.hazelcast.config.SSLConfig;
    32| import com.hazelcast.config.SerializationConfig;
    33| import com.hazelcast.core.HazelcastInstance;
    34| import com.hazelcast.core.PartitioningStrategy;
    35| import com.hazelcast.instance.BuildInfoProvider;
    36| import com.hazelcast.internal.nearcache.NearCacheManager;
    37| import com.hazelcast.internal.nearcache.impl.DefaultNearCacheManager;
    38| import com.hazelcast.internal.networking.ChannelInitializer;
    39| import com.hazelcast.internal.serialization.InternalSerializationService;
    40| import com.hazelcast.internal.serialization.SerializationServiceBuilder;
    41| import com.hazelcast.internal.serialization.impl.DefaultSerializationServiceBuilder;
    42| import com.hazelcast.logging.ILogger;
    43| import com.hazelcast.logging.Logger;
    44| import com.hazelcast.map.impl.MapService;
    45| import com.hazelcast.memory.DefaultMemoryStats;
    46| import com.hazelcast.memory.MemoryStats;
    47| import com.hazelcast.nio.ClassLoaderUtil;
    48| import com.hazelcast.nio.SocketInterceptor;
    49| import com.hazelcast.partition.strategy.DefaultPartitioningStrategy;
    50| import com.hazelcast.spi.properties.GroupProperty;
    51| import com.hazelcast.spi.properties.HazelcastProperties;
    52| import com.hazelcast.spi.serialization.SerializationService;
    53| import com.hazelcast.util.function.Supplier;
    54| import static com.hazelcast.internal.config.ConfigValidator.checkNearCacheConfig;
    55| import static com.hazelcast.spi.properties.GroupProperty.SOCKET_CLIENT_BUFFER_DIRECT;
    56| import static com.hazelcast.util.ExceptionUtil.rethrow;
    57| @SuppressWarnings("WeakerAccess")
    58| public class DefaultClientExtension implements ClientExtension {
    59|     protected static final ILogger LOGGER = Logger.getLogger(ClientExtension.class);
    60|     protected volatile HazelcastClientInstanceImpl client;
    61|     private final MemoryStats memoryStats = new DefaultMemoryStats();
    62|     @Override
    63|     public void beforeStart(HazelcastClientInstanceImpl client) {
    64|         this.client = client;
    65|     }
    66|     @Override
    67|     public void afterStart(HazelcastClientInstanceImpl client) {
    68|     }
    69|     @Override
    70|     public InternalSerializationService createSerializationService(byte version) {
    71|         try {
    72|             ClientConfig config = client.getClientConfig();
    73|             ClassLoader configClassLoader = config.getClassLoader();
    74|             HazelcastInstance hazelcastInstance = client;
    75|             PartitioningStrategy partitioningStrategy = getPartitioningStrategy(configClassLoader);
    76|             SerializationConfig serializationConfig = config.getSerializationConfig() != null
    77|                     ? config.getSerializationConfig()
    78|                     : new SerializationConfig();
    79|             SerializationServiceBuilder builder = new DefaultSerializationServiceBuilder();
    80|             if (version > 0) {
    81|                 builder.setVersion(version);
    82|             }
    83|             return builder
    84|                     .setClassLoader(configClassLoader)
    85|                     .setConfig(serializationConfig)
    86|                     .setManagedContext(new HazelcastClientManagedContext(client, config.getManagedContext()))
    87|                     .setPartitioningStrategy(partitioningStrategy)
    88|                     .setHazelcastInstance(hazelcastInstance)
    89|                     .setNotActiveExceptionSupplier(new Supplier<RuntimeException>() {
    90|                         @Override
    91|                         public RuntimeException get() {
    92|                             return new HazelcastClientNotActiveException("Client is shutdown");
    93|                         }
    94|                     })
    95|                     .build();
    96|         } catch (Exception e) {
    97|             throw rethrow(e);
    98|         }
    99|     }
   100|     protected PartitioningStrategy getPartitioningStrategy(ClassLoader configClassLoader) throws Exception {
   101|         String partitioningStrategyClassName = GroupProperty.PARTITIONING_STRATEGY_CLASS.getSystemProperty();
   102|         if (partitioningStrategyClassName != null && partitioningStrategyClassName.length() > 0) {
   103|             return ClassLoaderUtil.newInstance(configClassLoader, partitioningStrategyClassName);
   104|         } else {
   105|             return new DefaultPartitioningStrategy();
   106|         }
   107|     }
   108|     @Override
   109|     public SocketInterceptor createSocketInterceptor() {
   110|         LOGGER.warning("SocketInterceptor feature is only available on Hazelcast Enterprise!");
   111|         return null;
   112|     }
   113|     @Override
   114|     public ChannelInitializer createChannelInitializer() {
   115|         ClientNetworkConfig networkConfig = client.getClientConfig().getNetworkConfig();
   116|         SSLConfig sslConfig = networkConfig.getSSLConfig();
   117|         if (sslConfig != null && sslConfig.isEnabled()) {
   118|             if (!BuildInfoProvider.getBuildInfo().isEnterprise()) {
   119|                 throw new IllegalStateException("SSL/TLS requires Hazelcast Enterprise Edition");
   120|             }
   121|         }
   122|         SocketOptions socketOptions = networkConfig.getSocketOptions();
   123|         HazelcastProperties properties = client.getProperties();
   124|         boolean directBuffer = properties.getBoolean(SOCKET_CLIENT_BUFFER_DIRECT);
   125|         return new ClientPlainChannelInitializer(socketOptions, directBuffer);
   126|     }
   127|     @Override
   128|     public <T> ClientProxyFactory createServiceProxyFactory(Class<T> service) {
   129|         if (MapService.class.isAssignableFrom(service)) {
   130|             return createClientMapProxyFactory();
   131|         }
   132|         throw new IllegalArgumentException("Proxy factory cannot be created. Unknown service: " + service);
   133|     }
   134|     @Override
   135|     public MemoryStats getMemoryStats() {
   136|         return memoryStats;
   137|     }
   138|     private ClientProxyFactory createClientMapProxyFactory() {
   139|         return new ClientProxyFactoryWithContext() {
   140|             @Override
   141|             public ClientProxy create(String id, ClientContext context) {
   142|                 ClientConfig clientConfig = client.getClientConfig();
   143|                 NearCacheConfig nearCacheConfig = clientConfig.getNearCacheConfig(id);
   144|                 if (nearCacheConfig != null) {
   145|                     checkNearCacheConfig(id, nearCacheConfig, clientConfig.getNativeMemoryConfig(), true);
   146|                     return new NearCachedClientMapProxy(MapService.SERVICE_NAME, id, context);
   147|                 } else {
   148|                     return new ClientMapProxy(MapService.SERVICE_NAME, id, context);
   149|                 }
   150|             }
   151|         };
   152|     }
   153|     @Override
   154|     public NearCacheManager createNearCacheManager() {
   155|         SerializationService ss = client.getSerializationService();
   156|         ClientExecutionService es = client.getClientExecutionService();
   157|         ClassLoader classLoader = client.getClientConfig().getClassLoader();
   158|         HazelcastProperties properties = client.getProperties();
   159|         return new DefaultNearCacheManager(ss, es, classLoader, properties);
   160|     }
   161| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/HazelcastClientInstanceImpl.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-855 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.impl.clientside;
    17| import com.hazelcast.cache.impl.JCacheDetector;
    18| import com.hazelcast.cardinality.CardinalityEstimator;
    19| import com.hazelcast.cardinality.impl.CardinalityEstimatorService;
    20| import com.hazelcast.client.ClientExtension;
    21| import com.hazelcast.client.HazelcastClient;
    22| import com.hazelcast.client.LoadBalancer;
    23| import com.hazelcast.client.config.ClientAliasedDiscoveryConfigUtils;
    24| import com.hazelcast.client.config.ClientCloudConfig;
    25| import com.hazelcast.client.config.ClientConfig;
    26| import com.hazelcast.client.config.ClientNetworkConfig;
    27| import com.hazelcast.client.config.ClientSecurityConfig;
    28| import com.hazelcast.client.connection.AddressProvider;
    29| import com.hazelcast.client.connection.AddressTranslator;
    30| import com.hazelcast.client.connection.ClientConnectionManager;
    31| import com.hazelcast.client.connection.nio.ClientConnectionManagerImpl;
    32| import com.hazelcast.client.connection.nio.DefaultCredentialsFactory;
    33| import com.hazelcast.client.impl.client.DistributedObjectInfo;
    34| import com.hazelcast.client.impl.protocol.ClientMessage;
    35| import com.hazelcast.client.impl.protocol.codec.ClientGetDistributedObjectsCodec;
    36| import com.hazelcast.client.impl.statistics.Statistics;
    37| import com.hazelcast.client.proxy.ClientClusterProxy;
    38| import com.hazelcast.client.proxy.PartitionServiceProxy;
    39| import com.hazelcast.client.spi.ClientClusterService;
    40| import com.hazelcast.client.spi.ClientContext;
    41| import com.hazelcast.client.spi.ClientExecutionService;
    42| import com.hazelcast.client.spi.ClientInvocationService;
    43| import com.hazelcast.client.spi.ClientListenerService;
    44| import com.hazelcast.client.spi.ClientPartitionService;
    45| import com.hazelcast.client.spi.ClientTransactionManagerService;
    46| import com.hazelcast.client.spi.ProxyManager;
    47| import com.hazelcast.client.spi.impl.AbstractClientInvocationService;
    48| import com.hazelcast.client.spi.impl.ClientClusterServiceImpl;
    49| import com.hazelcast.client.spi.impl.ClientExecutionServiceImpl;
    50| import com.hazelcast.client.spi.impl.ClientInvocation;
    51| import com.hazelcast.client.spi.impl.ClientPartitionServiceImpl;
    52| import com.hazelcast.client.spi.impl.ClientTransactionManagerServiceImpl;
    53| import com.hazelcast.client.spi.impl.ClientUserCodeDeploymentService;
    54| import com.hazelcast.client.spi.impl.DefaultAddressProvider;
    55| import com.hazelcast.client.spi.impl.DefaultAddressTranslator;
    56| import com.hazelcast.client.spi.impl.NonSmartClientInvocationService;
    57| import com.hazelcast.client.spi.impl.SmartClientInvocationService;
    58| import com.hazelcast.client.spi.impl.discovery.DiscoveryAddressProvider;
    59| import com.hazelcast.client.spi.impl.discovery.DiscoveryAddressTranslator;
    60| import com.hazelcast.client.spi.impl.discovery.HazelcastCloudAddressProvider;
    61| import com.hazelcast.client.spi.impl.discovery.HazelcastCloudAddressTranslator;
    62| import com.hazelcast.client.spi.impl.discovery.HazelcastCloudDiscovery;
    63| import com.hazelcast.client.spi.impl.listener.AbstractClientListenerService;
    64| import com.hazelcast.client.spi.impl.listener.NonSmartClientListenerService;
    65| import com.hazelcast.client.spi.impl.listener.SmartClientListenerService;
    66| import com.hazelcast.client.spi.properties.ClientProperty;
    67| import com.hazelcast.client.util.RoundRobinLB;
    68| import com.hazelcast.collection.impl.list.ListService;
    69| import com.hazelcast.collection.impl.queue.QueueService;
    70| import com.hazelcast.collection.impl.set.SetService;
    71| import com.hazelcast.concurrent.atomiclong.AtomicLongService;
    72| import com.hazelcast.concurrent.atomicreference.AtomicReferenceService;
    73| import com.hazelcast.concurrent.countdownlatch.CountDownLatchService;
    74| import com.hazelcast.concurrent.idgen.IdGeneratorService;
    75| import com.hazelcast.concurrent.lock.LockServiceImpl;
    76| import com.hazelcast.concurrent.semaphore.SemaphoreService;
    77| import com.hazelcast.config.Config;
    78| import com.hazelcast.config.CredentialsFactoryConfig;
    79| import com.hazelcast.config.DiscoveryConfig;
    80| import com.hazelcast.config.DiscoveryStrategyConfig;
    81| import com.hazelcast.config.GroupConfig;
    82| import com.hazelcast.core.Client;
    83| import com.hazelcast.core.ClientService;
    84| import com.hazelcast.core.Cluster;
    85| import com.hazelcast.core.DistributedObject;
    86| import com.hazelcast.core.DistributedObjectListener;
    87| import com.hazelcast.core.HazelcastInstance;
    88| import com.hazelcast.core.IAtomicLong;
    89| import com.hazelcast.core.IAtomicReference;
    90| import com.hazelcast.core.ICountDownLatch;
    91| import com.hazelcast.core.IExecutorService;
    92| import com.hazelcast.core.IList;
    93| import com.hazelcast.core.ILock;
    94| import com.hazelcast.core.IMap;
    95| import com.hazelcast.core.IQueue;
    96| import com.hazelcast.core.ISemaphore;
    97| import com.hazelcast.core.ISet;
    98| import com.hazelcast.core.ITopic;
    99| import com.hazelcast.core.IdGenerator;
   100| import com.hazelcast.core.LifecycleService;
   101| import com.hazelcast.core.MultiMap;
   102| import com.hazelcast.core.PartitionService;
   103| import com.hazelcast.core.ReplicatedMap;
   104| import com.hazelcast.crdt.pncounter.PNCounter;
   105| import com.hazelcast.crdt.pncounter.PNCounterService;
   106| import com.hazelcast.durableexecutor.DurableExecutorService;
   107| import com.hazelcast.durableexecutor.impl.DistributedDurableExecutorService;
   108| import com.hazelcast.executor.impl.DistributedExecutorService;
   109| import com.hazelcast.flakeidgen.FlakeIdGenerator;
   110| import com.hazelcast.flakeidgen.impl.FlakeIdGeneratorService;
   111| import com.hazelcast.instance.BuildInfoProvider;
   112| import com.hazelcast.internal.diagnostics.BuildInfoPlugin;
   113| import com.hazelcast.internal.diagnostics.ConfigPropertiesPlugin;
   114| import com.hazelcast.internal.diagnostics.Diagnostics;
   115| import com.hazelcast.internal.diagnostics.EventQueuePlugin;
   116| import com.hazelcast.internal.diagnostics.MetricsPlugin;
   117| import com.hazelcast.internal.diagnostics.NetworkingImbalancePlugin;
   118| import com.hazelcast.internal.diagnostics.SystemLogPlugin;
   119| import com.hazelcast.internal.diagnostics.SystemPropertiesPlugin;
   120| import com.hazelcast.internal.metrics.ProbeLevel;
   121| import com.hazelcast.internal.metrics.impl.MetricsRegistryImpl;
   122| import com.hazelcast.internal.metrics.metricsets.ClassLoadingMetricSet;
   123| import com.hazelcast.internal.metrics.metricsets.FileMetricSet;
   124| import com.hazelcast.internal.metrics.metricsets.GarbageCollectionMetricSet;
   125| import com.hazelcast.internal.metrics.metricsets.OperatingSystemMetricSet;
   126| import com.hazelcast.internal.metrics.metricsets.RuntimeMetricSet;
   127| import com.hazelcast.internal.metrics.metricsets.ThreadMetricSet;
   128| import com.hazelcast.internal.nearcache.NearCacheManager;
   129| import com.hazelcast.internal.serialization.InternalSerializationService;
   130| import com.hazelcast.logging.ILogger;
   131| import com.hazelcast.logging.LoggingService;
   132| import com.hazelcast.map.impl.MapService;
   133| import com.hazelcast.mapreduce.JobTracker;
   134| import com.hazelcast.mapreduce.impl.MapReduceService;
   135| import com.hazelcast.multimap.impl.MultiMapService;
   136| import com.hazelcast.nio.ClassLoaderUtil;
   137| import com.hazelcast.nio.Connection;
   138| import com.hazelcast.quorum.QuorumService;
   139| import com.hazelcast.replicatedmap.impl.ReplicatedMapService;
   140| import com.hazelcast.ringbuffer.Ringbuffer;
   141| import com.hazelcast.ringbuffer.impl.RingbufferService;
   142| import com.hazelcast.scheduledexecutor.IScheduledExecutorService;
   143| import com.hazelcast.scheduledexecutor.impl.DistributedScheduledExecutorService;
   144| import com.hazelcast.security.ICredentialsFactory;
   145| import com.hazelcast.spi.discovery.impl.DefaultDiscoveryServiceProvider;
   146| import com.hazelcast.spi.discovery.integration.DiscoveryMode;
   147| import com.hazelcast.spi.discovery.integration.DiscoveryService;
   148| import com.hazelcast.spi.discovery.integration.DiscoveryServiceProvider;
   149| import com.hazelcast.spi.discovery.integration.DiscoveryServiceSettings;
   150| import com.hazelcast.spi.impl.SerializationServiceSupport;
   151| import com.hazelcast.spi.properties.GroupProperty;
   152| import com.hazelcast.spi.properties.HazelcastProperties;
   153| import com.hazelcast.spi.serialization.SerializationService;
   154| import com.hazelcast.topic.impl.TopicService;
   155| import com.hazelcast.topic.impl.reliable.ReliableTopicService;
   156| import com.hazelcast.transaction.HazelcastXAResource;
   157| import com.hazelcast.transaction.TransactionContext;
   158| import com.hazelcast.transaction.TransactionException;
   159| import com.hazelcast.transaction.TransactionOptions;
   160| import com.hazelcast.transaction.TransactionalTask;
   161| import com.hazelcast.transaction.impl.xa.XAService;
   162| import com.hazelcast.util.ServiceLoader;
   163| import java.util.Collection;
   164| import java.util.HashSet;
   165| import java.util.Iterator;
   166| import java.util.LinkedList;
   167| import java.util.List;
   168| import java.util.Set;
   169| import java.util.concurrent.ConcurrentHashMap;
   170| import java.util.concurrent.ConcurrentMap;
   171| import java.util.concurrent.Future;
   172| import java.util.concurrent.atomic.AtomicInteger;
   173| import static com.hazelcast.client.spi.properties.ClientProperty.DISCOVERY_SPI_ENABLED;
   174| import static com.hazelcast.client.spi.properties.ClientProperty.HAZELCAST_CLOUD_DISCOVERY_TOKEN;
   175| import static com.hazelcast.config.AliasedDiscoveryConfigUtils.allUsePublicAddress;
   176| import static com.hazelcast.util.ExceptionUtil.rethrow;
   177| import static com.hazelcast.util.Preconditions.checkNotNull;
   178| import static com.hazelcast.util.StringUtil.isNullOrEmpty;
   179| import static java.lang.System.currentTimeMillis;
   180| public class HazelcastClientInstanceImpl implements HazelcastInstance, SerializationServiceSupport {
   181|     private static final AtomicInteger CLIENT_ID = new AtomicInteger();
   182|     private static final short PROTOCOL_VERSION = ClientMessage.VERSION;
   183|     private final HazelcastProperties properties;
   184|     private final int id = CLIENT_ID.getAndIncrement();
   185|     private final String instanceName;
   186|     private final ClientConfig config;
   187|     private final LifecycleServiceImpl lifecycleService;
   188|     private final ClientConnectionManagerImpl connectionManager;
   189|     private final ClientClusterServiceImpl clusterService;
   190|     private final ClientPartitionServiceImpl partitionService;
   191|     private final AbstractClientInvocationService invocationService;
   192|     private final ClientExecutionServiceImpl executionService;
   193|     private final AbstractClientListenerService listenerService;
   194|     private final ClientTransactionManagerServiceImpl transactionManager;
   195|     private final NearCacheManager nearCacheManager;
   196|     private final ProxyManager proxyManager;
   197|     private final ConcurrentMap<String, Object> userContext;
   198|     private final LoadBalancer loadBalancer;
   199|     private final ClientExtension clientExtension;
   200|     private final ICredentialsFactory credentialsFactory;
   201|     private final DiscoveryService discoveryService;
   202|     private final LoggingService loggingService;
   203|     private final MetricsRegistryImpl metricsRegistry;
   204|     private final Statistics statistics;
   205|     private final Diagnostics diagnostics;
   206|     private final SerializationService serializationService;
   207|     private final ClientICacheManager hazelcastCacheManager;
   208|     private final ClientLockReferenceIdGenerator lockReferenceIdGenerator;
   209|     private final ClientExceptionFactory clientExceptionFactory;
   210|     private final ClientUserCodeDeploymentService userCodeDeploymentService;
   211|     public HazelcastClientInstanceImpl(ClientConfig config,
   212|                                        ClientConnectionManagerFactory clientConnectionManagerFactory,
   213|                                        AddressProvider externalAddressProvider) {
   214|         this.config = config;
   215|         if (config.getInstanceName() != null) {
   216|             instanceName = config.getInstanceName();
   217|         } else {
   218|             instanceName = "hz.client_" + id;
   219|         }
   220|         GroupConfig groupConfig = config.getGroupConfig();
   221|         String loggingType = config.getProperty(GroupProperty.LOGGING_TYPE.getName());
   222|         loggingService = new ClientLoggingService(groupConfig.getName(),
   223|                 loggingType, BuildInfoProvider.getBuildInfo(), instanceName);
   224|         logGroupPasswordInfo();
   225|         ClassLoader classLoader = config.getClassLoader();
   226|         clientExtension = createClientInitializer(classLoader);
   227|         clientExtension.beforeStart(this);
   228|         credentialsFactory = initCredentialsFactory(config);
   229|         lifecycleService = new LifecycleServiceImpl(this);
   230|         properties = new HazelcastProperties(config.getProperties());
   231|         metricsRegistry = initMetricsRegistry();
   232|         serializationService = clientExtension.createSerializationService((byte) -1);
   233|         metricsRegistry.collectMetrics(clientExtension);
   234|         proxyManager = new ProxyManager(this);
   235|         executionService = initExecutionService();
   236|         metricsRegistry.collectMetrics(executionService);
   237|         loadBalancer = initLoadBalancer(config);
   238|         transactionManager = new ClientTransactionManagerServiceImpl(this, loadBalancer);
   239|         partitionService = new ClientPartitionServiceImpl(this);
   240|         discoveryService = initDiscoveryService(config);
   241|         Collection<AddressProvider> addressProviders = createAddressProviders(externalAddressProvider);
   242|         AddressTranslator addressTranslator = createAddressTranslator();
   243|         connectionManager = (ClientConnectionManagerImpl) clientConnectionManagerFactory
   244|                 .createConnectionManager(this, addressTranslator, addressProviders);
   245|         clusterService = new ClientClusterServiceImpl(this);
   246|         invocationService = initInvocationService();
   247|         listenerService = initListenerService();
   248|         userContext = new ConcurrentHashMap<String, Object>();
   249|         userContext.putAll(config.getUserContext());
   250|         diagnostics = initDiagnostics();
   251|         hazelcastCacheManager = new ClientICacheManager(this);
   252|         lockReferenceIdGenerator = new ClientLockReferenceIdGenerator();
   253|         nearCacheManager = clientExtension.createNearCacheManager();
   254|         clientExceptionFactory = initClientExceptionFactory();
   255|         statistics = new Statistics(this);
   256|         userCodeDeploymentService = new ClientUserCodeDeploymentService(config.getUserCodeDeploymentConfig(), classLoader);
   257|     }
   258|     private int getConnectionTimeoutMillis() {
   259|         ClientNetworkConfig networkConfig = config.getNetworkConfig();
   260|         int connTimeout = networkConfig.getConnectionTimeout();
   261|         return connTimeout == 0 ? Integer.MAX_VALUE : connTimeout;
   262|     }
   263|     private Diagnostics initDiagnostics() {
   264|         String name = "diagnostics-client-" + id + "-" + currentTimeMillis();
   265|         ILogger logger = loggingService.getLogger(Diagnostics.class);
   266|         return new Diagnostics(name, logger, instanceName, properties);
   267|     }
   268|     private MetricsRegistryImpl initMetricsRegistry() {
   269|         ProbeLevel probeLevel = properties.getEnum(Diagnostics.METRICS_LEVEL, ProbeLevel.class);
   270|         ILogger logger = loggingService.getLogger(MetricsRegistryImpl.class);
   271|         MetricsRegistryImpl metricsRegistry = new MetricsRegistryImpl(getName(), logger, probeLevel);
   272|         RuntimeMetricSet.register(metricsRegistry);
   273|         GarbageCollectionMetricSet.register(metricsRegistry);
   274|         OperatingSystemMetricSet.register(metricsRegistry);
   275|         ThreadMetricSet.register(metricsRegistry);
   276|         ClassLoadingMetricSet.register(metricsRegistry);
   277|         FileMetricSet.register(metricsRegistry);
   278|         metricsRegistry.scanAndRegister(clientExtension.getMemoryStats(), "memory");
   279|         return metricsRegistry;
   280|     }
   281|     private Collection<AddressProvider> createAddressProviders(AddressProvider externalAddressProvider) {
   282|         ClientNetworkConfig networkConfig = getClientConfig().getNetworkConfig();
   283|         Collection<AddressProvider> addressProviders = new LinkedList<AddressProvider>();
   284|         if (externalAddressProvider != null) {
   285|             addressProviders.add(externalAddressProvider);
   286|         }
   287|         if (discoveryService != null) {
   288|             addressProviders.add(new DiscoveryAddressProvider(discoveryService, loggingService));
   289|         }
   290|         ClientCloudConfig cloudConfig = networkConfig.getCloudConfig();
   291|         HazelcastCloudAddressProvider cloudAddressProvider = initCloudAddressProvider(cloudConfig);
   292|         if (cloudAddressProvider != null) {
   293|             addressProviders.add(cloudAddressProvider);
   294|         }
   295|         addressProviders.add(new DefaultAddressProvider(networkConfig, addressProviders.isEmpty()));
   296|         return addressProviders;
   297|     }
   298|     private HazelcastCloudAddressProvider initCloudAddressProvider(ClientCloudConfig cloudConfig) {
   299|         if (cloudConfig.isEnabled()) {
   300|             String discoveryToken = cloudConfig.getDiscoveryToken();
   301|             String urlEndpoint = HazelcastCloudDiscovery.createUrlEndpoint(getProperties(), discoveryToken);
   302|             return new HazelcastCloudAddressProvider(urlEndpoint, getConnectionTimeoutMillis(), loggingService);
   303|         }
   304|         String cloudToken = properties.getString(ClientProperty.HAZELCAST_CLOUD_DISCOVERY_TOKEN);
   305|         if (cloudToken != null) {
   306|             String urlEndpoint = HazelcastCloudDiscovery.createUrlEndpoint(getProperties(), cloudToken);
   307|             return new HazelcastCloudAddressProvider(urlEndpoint, getConnectionTimeoutMillis(), loggingService);
   308|         }
   309|         return null;
   310|     }
   311|     private AddressTranslator createAddressTranslator() {
   312|         ClientNetworkConfig networkConfig = getClientConfig().getNetworkConfig();
   313|         ClientCloudConfig cloudConfig = networkConfig.getCloudConfig();
   314|         List<String> addresses = networkConfig.getAddresses();
   315|         boolean addressListProvided = addresses.size() != 0;
   316|         boolean awsDiscoveryEnabled = networkConfig.getAwsConfig() != null && networkConfig.getAwsConfig().isEnabled();
   317|         boolean gcpDiscoveryEnabled = networkConfig.getGcpConfig() != null && networkConfig.getGcpConfig().isEnabled();
   318|         boolean azureDiscoveryEnabled = networkConfig.getAzureConfig() != null && networkConfig.getAzureConfig().isEnabled();
   319|         boolean kubernetesDiscoveryEnabled = networkConfig.getKubernetesConfig() != null
   320|                 && networkConfig.getKubernetesConfig().isEnabled();
   321|         boolean eurekaDiscoveryEnabled = networkConfig.getEurekaConfig() != null && networkConfig.getEurekaConfig().isEnabled();
   322|         boolean discoverySpiEnabled = discoverySpiEnabled(networkConfig);
   323|         String cloudDiscoveryToken = properties.getString(HAZELCAST_CLOUD_DISCOVERY_TOKEN);
   324|         if (cloudDiscoveryToken != null && cloudConfig.isEnabled()) {
   325|             throw new IllegalStateException("Ambiguous hazelcast.cloud configuration. "
   326|                     + "Both property based and client configuration based settings are provided for "
   327|                     + "Hazelcast cloud discovery together. Use only one.");
   328|         }
   329|         boolean hazelcastCloudEnabled = cloudDiscoveryToken != null || cloudConfig.isEnabled();
   330|         isDiscoveryConfigurationConsistent(addressListProvided, awsDiscoveryEnabled, gcpDiscoveryEnabled, azureDiscoveryEnabled,
   331|                 kubernetesDiscoveryEnabled, eurekaDiscoveryEnabled, discoverySpiEnabled, hazelcastCloudEnabled);
   332|         if (discoveryService != null) {
   333|             return new DiscoveryAddressTranslator(discoveryService, usePublicAddress(config));
   334|         } else if (hazelcastCloudEnabled) {
   335|             String discoveryToken;
   336|             if (cloudConfig.isEnabled()) {
   337|                 discoveryToken = cloudConfig.getDiscoveryToken();
   338|             } else {
   339|                 discoveryToken = cloudDiscoveryToken;
   340|             }
   341|             String urlEndpoint = HazelcastCloudDiscovery.createUrlEndpoint(getProperties(), discoveryToken);
   342|             return new HazelcastCloudAddressTranslator(urlEndpoint, getConnectionTimeoutMillis(), loggingService);
   343|         }
   344|         return new DefaultAddressTranslator();
   345|     }
   346|     private boolean discoverySpiEnabled(ClientNetworkConfig networkConfig) {
   347|         return (networkConfig.getDiscoveryConfig() != null && networkConfig.getDiscoveryConfig().isEnabled())
   348|                 || Boolean.parseBoolean(properties.getString(DISCOVERY_SPI_ENABLED));
   349|     }
   350|     private boolean usePublicAddress(ClientConfig config) {
   351|         return getProperties().getBoolean(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED)
   352|                 || allUsePublicAddress(ClientAliasedDiscoveryConfigUtils.aliasedDiscoveryConfigsFrom(config));
   353|     }
   354|     @SuppressWarnings({"checkstyle:booleanexpressioncomplexity", "checkstyle:npathcomplexity"})
   355|     private void isDiscoveryConfigurationConsistent(boolean addressListProvided, boolean awsDiscoveryEnabled,
   356|                                                     boolean gcpDiscoveryEnabled, boolean azureDiscoveryEnabled,
   357|                                                     boolean kubernetesDiscoveryEnabled, boolean eurekaDiscoveryEnabled,
   358|                                                     boolean discoverySpiEnabled, boolean hazelcastCloudEnabled) {
   359|         int count = 0;
   360|         if (addressListProvided) {
   361|             count++;
   362|         }
   363|         if (awsDiscoveryEnabled) {
   364|             count++;
   365|         }
   366|         if (gcpDiscoveryEnabled) {
   367|             count++;
   368|         }
   369|         if (azureDiscoveryEnabled) {
   370|             count++;
   371|         }
   372|         if (kubernetesDiscoveryEnabled) {
   373|             count++;
   374|         }
   375|         if (eurekaDiscoveryEnabled) {
   376|             count++;
   377|         }
   378|         if (discoverySpiEnabled) {
   379|             count++;
   380|         }
   381|         if (hazelcastCloudEnabled) {
   382|             count++;
   383|         }
   384|         if (count > 1) {
   385|             throw new IllegalStateException("Only one discovery method can be enabled at a time. "
   386|                     + "cluster members given explicitly : " + addressListProvided
   387|                     + ", aws discovery: " + awsDiscoveryEnabled
   388|                     + ", gcp discovery: " + gcpDiscoveryEnabled
   389|                     + ", azure discovery: " + azureDiscoveryEnabled
   390|                     + ", kubernetes discovery: " + kubernetesDiscoveryEnabled
   391|                     + ", eureka discovery: " + eurekaDiscoveryEnabled
   392|                     + ", discovery spi enabled : " + discoverySpiEnabled
   393|                     + ", hazelcast.cloud enabled : " + hazelcastCloudEnabled);
   394|         }
   395|     }
   396|     private DiscoveryService initDiscoveryService(ClientConfig config) {
   397|         List<DiscoveryStrategyConfig> aliasedDiscoveryConfigs =
   398|                 ClientAliasedDiscoveryConfigUtils.createDiscoveryStrategyConfigs(config);
   399|         if (!properties.getBoolean(ClientProperty.DISCOVERY_SPI_ENABLED) && aliasedDiscoveryConfigs.isEmpty()) {
   400|             return null;
   401|         }
   402|         ILogger logger = loggingService.getLogger(DiscoveryService.class);
   403|         ClientNetworkConfig networkConfig = config.getNetworkConfig();
   404|         DiscoveryConfig discoveryConfig = networkConfig.getDiscoveryConfig().getAsReadOnly();
   405|         DiscoveryServiceProvider factory = discoveryConfig.getDiscoveryServiceProvider();
   406|         if (factory == null) {
   407|             factory = new DefaultDiscoveryServiceProvider();
   408|         }
   409|         DiscoveryServiceSettings settings = new DiscoveryServiceSettings()
   410|                 .setConfigClassLoader(config.getClassLoader())
   411|                 .setLogger(logger)
   412|                 .setDiscoveryMode(DiscoveryMode.Client)
   413|                 .setAliasedDiscoveryConfigs(aliasedDiscoveryConfigs)
   414|                 .setDiscoveryConfig(discoveryConfig);
   415|         DiscoveryService discoveryService = factory.newDiscoveryService(settings);
   416|         discoveryService.start();
   417|         return discoveryService;
   418|     }
   419|     private LoadBalancer initLoadBalancer(ClientConfig config) {
   420|         LoadBalancer lb = config.getLoadBalancer();
   421|         if (lb == null) {
   422|             lb = new RoundRobinLB();
   423|         }
   424|         return lb;
   425|     }
   426|     private ICredentialsFactory initCredentialsFactory(ClientConfig config) {
   427|         ClientSecurityConfig securityConfig = config.getSecurityConfig();
   428|         validateSecurityConfig(securityConfig);
   429|         ICredentialsFactory c = getCredentialsFromFactory(config);
   430|         if (c == null) {
   431|             return new DefaultCredentialsFactory(securityConfig, config.getGroupConfig(), config.getClassLoader());
   432|         }
   433|         return c;
   434|     }
   435|     private void validateSecurityConfig(ClientSecurityConfig securityConfig) {
   436|         boolean configuredViaCredentials = securityConfig.getCredentials() != null
   437|                 || securityConfig.getCredentialsClassname() != null;
   438|         CredentialsFactoryConfig factoryConfig = securityConfig.getCredentialsFactoryConfig();
   439|         boolean configuredViaCredentialsFactory = factoryConfig.getClassName() != null
   440|                 || factoryConfig.getImplementation() != null;
   441|         if (configuredViaCredentials && configuredViaCredentialsFactory) {
   442|             throw new IllegalStateException("Ambiguous Credentials config. Set only one of Credentials or ICredentialsFactory");
   443|         }
   444|     }
   445|     private ICredentialsFactory getCredentialsFromFactory(ClientConfig config) {
   446|         CredentialsFactoryConfig credentialsFactoryConfig = config.getSecurityConfig().getCredentialsFactoryConfig();
   447|         ICredentialsFactory factory = credentialsFactoryConfig.getImplementation();
   448|         if (factory == null) {
   449|             String factoryClassName = credentialsFactoryConfig.getClassName();
   450|             if (factoryClassName != null) {
   451|                 try {
   452|                     factory = ClassLoaderUtil.newInstance(config.getClassLoader(), factoryClassName);
   453|                 } catch (Exception e) {
   454|                     throw rethrow(e);
   455|                 }
   456|             }
   457|         }
   458|         if (factory == null) {
   459|             return null;
   460|         }
   461|         factory.configure(config.getGroupConfig(), credentialsFactoryConfig.getProperties());
   462|         return factory;
   463|     }
   464|     @SuppressWarnings("checkstyle:illegaltype")
   465|     private AbstractClientInvocationService initInvocationService() {
   466|         final ClientNetworkConfig networkConfig = config.getNetworkConfig();
   467|         if (networkConfig.isSmartRouting()) {
   468|             return new SmartClientInvocationService(this, loadBalancer);
   469|         } else {
   470|             return new NonSmartClientInvocationService(this);
   471|         }
   472|     }
   473|     public int getId() {
   474|         return id;
   475|     }
   476|     private ClientExtension createClientInitializer(ClassLoader classLoader) {
   477|         try {
   478|             String factoryId = ClientExtension.class.getName();
   479|             Iterator<ClientExtension> iter = ServiceLoader.iterator(ClientExtension.class, factoryId, classLoader);
   480|             while (iter.hasNext()) {
   481|                 ClientExtension initializer = iter.next();
   482|                 if (!(initializer.getClass().equals(DefaultClientExtension.class))) {
   483|                     return initializer;
   484|                 }
   485|             }
   486|         } catch (Exception e) {
   487|             throw rethrow(e);
   488|         }
   489|         return new DefaultClientExtension();
   490|     }
   491|     @SuppressWarnings("checkstyle:illegaltype")
   492|     private AbstractClientListenerService initListenerService() {
   493|         int eventQueueCapacity = properties.getInteger(ClientProperty.EVENT_QUEUE_CAPACITY);
   494|         int eventThreadCount = properties.getInteger(ClientProperty.EVENT_THREAD_COUNT);
   495|         final ClientNetworkConfig networkConfig = config.getNetworkConfig();
   496|         if (networkConfig.isSmartRouting()) {
   497|             return new SmartClientListenerService(this, eventThreadCount, eventQueueCapacity);
   498|         } else {
   499|             return new NonSmartClientListenerService(this, eventThreadCount, eventQueueCapacity);
   500|         }
   501|     }
   502|     private ClientExecutionServiceImpl initExecutionService() {
   503|         return new ClientExecutionServiceImpl(instanceName,
   504|                 config.getClassLoader(), properties, config.getExecutorPoolSize(), loggingService);
   505|     }
   506|     private void logGroupPasswordInfo() {
   507|         if (!isNullOrEmpty(config.getGroupConfig().getPassword())) {
   508|             ILogger logger = loggingService.getLogger(HazelcastClient.class);
   509|             logger.info("A non-empty group password is configured for the Hazelcast client."
   510|                     + " Starting with Hazelcast version 3.11, clients with the same group name,"
   511|                     + " but with different group passwords (that do not use authentication) will be accepted to a cluster."
   512|                     + " The group password configuration will be removed completely in a future release.");
   513|         }
   514|     }
   515|     public void start() {
   516|         lifecycleService.setStarted();
   517|         invocationService.start();
   518|         clusterService.start();
   519|         ClientContext clientContext = new ClientContext(this);
   520|         try {
   521|             userCodeDeploymentService.start();
   522|             connectionManager.start(clientContext);
   523|         } catch (Exception e) {
   524|             throw rethrow(e);
   525|         }
   526|         diagnostics.start();
   527|         diagnostics.register(
   528|                 new BuildInfoPlugin(loggingService.getLogger(BuildInfoPlugin.class)));
   529|         diagnostics.register(
   530|                 new ConfigPropertiesPlugin(loggingService.getLogger(ConfigPropertiesPlugin.class), properties));
   531|         diagnostics.register(
   532|                 new SystemPropertiesPlugin(loggingService.getLogger(SystemPropertiesPlugin.class)));
   533|         diagnostics.register(
   534|                 new MetricsPlugin(loggingService.getLogger(MetricsPlugin.class), metricsRegistry, properties));
   535|         diagnostics.register(
   536|                 new SystemLogPlugin(properties, connectionManager, this, loggingService.getLogger(SystemLogPlugin.class)));
   537|         diagnostics.register(
   538|                 new NetworkingImbalancePlugin(properties, connectionManager.getNetworking(),
   539|                         loggingService.getLogger(NetworkingImbalancePlugin.class)));
   540|         diagnostics.register(
   541|                 new EventQueuePlugin(loggingService.getLogger(EventQueuePlugin.class), listenerService.getEventExecutor(),
   542|                         properties));
   543|         metricsRegistry.collectMetrics(listenerService);
   544|         proxyManager.init(config, clientContext);
   545|         listenerService.start();
   546|         loadBalancer.init(getCluster(), config);
   547|         partitionService.start();
   548|         statistics.start();
   549|         clientExtension.afterStart(this);
   550|     }
   551|     public void onClusterConnect(Connection ownerConnection) throws Exception {
   552|         partitionService.listenPartitionTable(ownerConnection);
   553|         clusterService.listenMembershipEvents(ownerConnection);
   554|         userCodeDeploymentService.deploy(this, ownerConnection);
   555|         proxyManager.createDistributedObjectsOnCluster(ownerConnection);
   556|     }
   557|     public MetricsRegistryImpl getMetricsRegistry() {
   558|         return metricsRegistry;
   559|     }
   560|     @Override
   561|     public HazelcastXAResource getXAResource() {
   562|         return getDistributedObject(XAService.SERVICE_NAME, XAService.SERVICE_NAME);
   563|     }
   564|     @Override
   565|     public Config getConfig() {
   566|         return new ClientDynamicClusterConfig(this);
   567|     }
   568|     public HazelcastProperties getProperties() {
   569|         return properties;
   570|     }
   571|     @Override
   572|     public String getName() {
   573|         return instanceName;
   574|     }
   575|     @Override
   576|     public <E> IQueue<E> getQueue(String name) {
   577|         checkNotNull(name, "Retrieving a queue instance with a null name is not allowed!");
   578|         return getDistributedObject(QueueService.SERVICE_NAME, name);
   579|     }
   580|     @Override
   581|     public <E> ITopic<E> getTopic(String name) {
   582|         checkNotNull(name, "Retrieving a topic instance with a null name is not allowed!");
   583|         return getDistributedObject(TopicService.SERVICE_NAME, name);
   584|     }
   585|     @Override
   586|     public <E> ISet<E> getSet(String name) {
   587|         checkNotNull(name, "Retrieving a set instance with a null name is not allowed!");
   588|         return getDistributedObject(SetService.SERVICE_NAME, name);
   589|     }
   590|     @Override
   591|     public <E> IList<E> getList(String name) {
   592|         checkNotNull(name, "Retrieving a list instance with a null name is not allowed!");
   593|         return getDistributedObject(ListService.SERVICE_NAME, name);
   594|     }
   595|     @Override
   596|     public <K, V> IMap<K, V> getMap(String name) {
   597|         checkNotNull(name, "Retrieving a map instance with a null name is not allowed!");
   598|         return getDistributedObject(MapService.SERVICE_NAME, name);
   599|     }
   600|     @Override
   601|     public <K, V> MultiMap<K, V> getMultiMap(String name) {
   602|         checkNotNull(name, "Retrieving a multi-map instance with a null name is not allowed!");
   603|         return getDistributedObject(MultiMapService.SERVICE_NAME, name);
   604|     }
   605|     @Override
   606|     public <K, V> ReplicatedMap<K, V> getReplicatedMap(String name) {
   607|         checkNotNull(name, "Retrieving a replicated map instance with a null name is not allowed!");
   608|         return getDistributedObject(ReplicatedMapService.SERVICE_NAME, name);
   609|     }
   610|     @Override
   611|     public JobTracker getJobTracker(String name) {
   612|         checkNotNull(name, "Retrieving a job tracker instance with a null name is not allowed!");
   613|         return getDistributedObject(MapReduceService.SERVICE_NAME, name);
   614|     }
   615|     @Override
   616|     public ILock getLock(String key) {
   617|         checkNotNull(key, "Retrieving a lock instance with a null key is not allowed!");
   618|         return getDistributedObject(LockServiceImpl.SERVICE_NAME, key);
   619|     }
   620|     @Override
   621|     public <E> ITopic<E> getReliableTopic(String name) {
   622|         checkNotNull(name, "Retrieving a topic instance with a null name is not allowed!");
   623|         return getDistributedObject(ReliableTopicService.SERVICE_NAME, name);
   624|     }
   625|     @Override
   626|     public <E> Ringbuffer<E> getRingbuffer(String name) {
   627|         checkNotNull(name, "Retrieving a ringbuffer instance with a null name is not allowed!");
   628|         return getDistributedObject(RingbufferService.SERVICE_NAME, name);
   629|     }
   630|     @Override
   631|     public ClientICacheManager getCacheManager() {
   632|         return hazelcastCacheManager;
   633|     }
   634|     @Override
   635|     public Cluster getCluster() {
   636|         return new ClientClusterProxy(clusterService);
   637|     }
   638|     @Override
   639|     public Client getLocalEndpoint() {
   640|         return clusterService.getLocalClient();
   641|     }
   642|     @Override
   643|     public IExecutorService getExecutorService(String name) {
   644|         checkNotNull(name, "Retrieving an executor instance with a null name is not allowed!");
   645|         return getDistributedObject(DistributedExecutorService.SERVICE_NAME, name);
   646|     }
   647|     @Override
   648|     public DurableExecutorService getDurableExecutorService(String name) {
   649|         checkNotNull(name, "Retrieving a durable executor instance with a null name is not allowed!");
   650|         return getDistributedObject(DistributedDurableExecutorService.SERVICE_NAME, name);
   651|     }
   652|     @Override
   653|     public <T> T executeTransaction(TransactionalTask<T> task) throws TransactionException {
   654|         return transactionManager.executeTransaction(task);
   655|     }
   656|     @Override
   657|     public <T> T executeTransaction(TransactionOptions options, TransactionalTask<T> task) throws TransactionException {
   658|         return transactionManager.executeTransaction(options, task);
   659|     }
   660|     @Override
   661|     public TransactionContext newTransactionContext() {
   662|         return transactionManager.newTransactionContext();
   663|     }
   664|     @Override
   665|     public TransactionContext newTransactionContext(TransactionOptions options) {
   666|         return transactionManager.newTransactionContext(options);
   667|     }
   668|     public ClientTransactionManagerService getTransactionManager() {
   669|         return transactionManager;
   670|     }
   671|     @Override
   672|     public IdGenerator getIdGenerator(String name) {
   673|         checkNotNull(name, "Retrieving an ID-generator instance with a null name is not allowed!");
   674|         return getDistributedObject(IdGeneratorService.SERVICE_NAME, name);
   675|     }
   676|     @Override
   677|     public FlakeIdGenerator getFlakeIdGenerator(String name) {
   678|         checkNotNull(name, "Retrieving a Flake ID-generator instance with a null name is not allowed!");
   679|         return getDistributedObject(FlakeIdGeneratorService.SERVICE_NAME, name);
   680|     }
   681|     @Override
   682|     public IAtomicLong getAtomicLong(String name) {
   683|         checkNotNull(name, "Retrieving an atomic-long instance with a null name is not allowed!");
   684|         return getDistributedObject(AtomicLongService.SERVICE_NAME, name);
   685|     }
   686|     @Override
   687|     public CardinalityEstimator getCardinalityEstimator(String name) {
   688|         checkNotNull(name, "Retrieving a cardinality estimator instance with a null name is not allowed!");
   689|         return getDistributedObject(CardinalityEstimatorService.SERVICE_NAME, name);
   690|     }
   691|     @Override
   692|     public PNCounter getPNCounter(String name) {
   693|         checkNotNull(name, "Retrieving a PN counter instance with a null name is not allowed!");
   694|         return getDistributedObject(PNCounterService.SERVICE_NAME, name);
   695|     }
   696|     @Override
   697|     public <E> IAtomicReference<E> getAtomicReference(String name) {
   698|         checkNotNull(name, "Retrieving an atomic-reference instance with a null name is not allowed!");
   699|         return getDistributedObject(AtomicReferenceService.SERVICE_NAME, name);
   700|     }
   701|     @Override
   702|     public ICountDownLatch getCountDownLatch(String name) {
   703|         checkNotNull(name, "Retrieving a countdown-latch instance with a null name is not allowed!");
   704|         return getDistributedObject(CountDownLatchService.SERVICE_NAME, name);
   705|     }
   706|     @Override
   707|     public ISemaphore getSemaphore(String name) {
   708|         checkNotNull(name, "Retrieving a semaphore instance with a null name is not allowed!");
   709|         return getDistributedObject(SemaphoreService.SERVICE_NAME, name);
   710|     }
   711|     @Override
   712|     public IScheduledExecutorService getScheduledExecutorService(String name) {
   713|         checkNotNull(name, "Retrieving a scheduled executor instance with a null name is not allowed!");
   714|         return getDistributedObject(DistributedScheduledExecutorService.SERVICE_NAME, name);
   715|     }
   716|     @Override
   717|     public Collection<DistributedObject> getDistributedObjects() {
   718|         try {
   719|             ClientMessage request = ClientGetDistributedObjectsCodec.encodeRequest();
   720|             final Future<ClientMessage> future = new ClientInvocation(this, request, getName()).invoke();
   721|             ClientMessage response = future.get();
   722|             ClientGetDistributedObjectsCodec.ResponseParameters resultParameters =
   723|                     ClientGetDistributedObjectsCodec.decodeResponse(response);
   724|             Collection<? extends DistributedObject> distributedObjects = proxyManager.getDistributedObjects();
   725|             Set<DistributedObjectInfo> localDistributedObjects = new HashSet<DistributedObjectInfo>();
   726|             for (DistributedObject localInfo : distributedObjects) {
   727|                 localDistributedObjects.add(new DistributedObjectInfo(localInfo.getServiceName(), localInfo.getName()));
   728|             }
   729|             Collection<DistributedObjectInfo> newDistributedObjectInfo = resultParameters.response;
   730|             for (DistributedObjectInfo distributedObjectInfo : newDistributedObjectInfo) {
   731|                 localDistributedObjects.remove(distributedObjectInfo);
   732|                 getDistributedObject(distributedObjectInfo.getServiceName(), distributedObjectInfo.getName());
   733|             }
   734|             for (DistributedObjectInfo distributedObjectInfo : localDistributedObjects) {
   735|                 proxyManager.destroyProxyLocally(distributedObjectInfo.getServiceName(), distributedObjectInfo.getName());
   736|             }
   737|             return (Collection<DistributedObject>) proxyManager.getDistributedObjects();
   738|         } catch (Exception e) {
   739|             throw rethrow(e);
   740|         }
   741|     }
   742|     @Override
   743|     public String addDistributedObjectListener(DistributedObjectListener distributedObjectListener) {
   744|         return proxyManager.addDistributedObjectListener(distributedObjectListener);
   745|     }
   746|     @Override
   747|     public boolean removeDistributedObjectListener(String registrationId) {
   748|         return proxyManager.removeDistributedObjectListener(registrationId);
   749|     }
   750|     @Override
   751|     public PartitionService getPartitionService() {
   752|         return new PartitionServiceProxy(partitionService, listenerService);
   753|     }
   754|     @Override
   755|     public QuorumService getQuorumService() {
   756|         throw new UnsupportedOperationException();
   757|     }
   758|     @Override
   759|     public ClientService getClientService() {
   760|         throw new UnsupportedOperationException();
   761|     }
   762|     @Override
   763|     public LoggingService getLoggingService() {
   764|         return loggingService;
   765|     }
   766|     @Override
   767|     public LifecycleService getLifecycleService() {
   768|         return lifecycleService;
   769|     }
   770|     @Override
   771|     public <T extends DistributedObject> T getDistributedObject(String serviceName, String name) {
   772|         return (T) proxyManager.getOrCreateProxy(serviceName, name);
   773|     }
   774|     @Override
   775|     public ConcurrentMap<String, Object> getUserContext() {
   776|         return userContext;
   777|     }
   778|     public ClientConfig getClientConfig() {
   779|         return config;
   780|     }
   781|     @Override
   782|     public SerializationService getSerializationService() {
   783|         return serializationService;
   784|     }
   785|     public ClientUserCodeDeploymentService getUserCodeDeploymentService() {
   786|         return userCodeDeploymentService;
   787|     }
   788|     public ProxyManager getProxyManager() {
   789|         return proxyManager;
   790|     }
   791|     public ClientConnectionManager getConnectionManager() {
   792|         return connectionManager;
   793|     }
   794|     public ClientClusterService getClientClusterService() {
   795|         return clusterService;
   796|     }
   797|     public ClientExecutionService getClientExecutionService() {
   798|         return executionService;
   799|     }
   800|     public ClientPartitionService getClientPartitionService() {
   801|         return partitionService;
   802|     }
   803|     public ClientInvocationService getInvocationService() {
   804|         return invocationService;
   805|     }
   806|     public ClientListenerService getListenerService() {
   807|         return listenerService;
   808|     }
   809|     public NearCacheManager getNearCacheManager() {
   810|         return nearCacheManager;
   811|     }
   812|     public LoadBalancer getLoadBalancer() {
   813|         return loadBalancer;
   814|     }
   815|     public ClientExtension getClientExtension() {
   816|         return clientExtension;
   817|     }
   818|     public ICredentialsFactory getCredentialsFactory() {
   819|         return credentialsFactory;
   820|     }
   821|     public short getProtocolVersion() {
   822|         return PROTOCOL_VERSION;
   823|     }
   824|     @Override
   825|     public void shutdown() {
   826|         getLifecycleService().shutdown();
   827|     }
   828|     public void doShutdown() {
   829|         proxyManager.destroy();
   830|         connectionManager.shutdown();
   831|         clusterService.shutdown();
   832|         partitionService.stop();
   833|         transactionManager.shutdown();
   834|         invocationService.shutdown();
   835|         executionService.shutdown();
   836|         listenerService.shutdown();
   837|         nearCacheManager.destroyAllNearCaches();
   838|         if (discoveryService != null) {
   839|             discoveryService.destroy();
   840|         }
   841|         metricsRegistry.shutdown();
   842|         diagnostics.shutdown();
   843|         ((InternalSerializationService) serializationService).dispose();
   844|     }
   845|     public ClientLockReferenceIdGenerator getLockReferenceIdGenerator() {
   846|         return lockReferenceIdGenerator;
   847|     }
   848|     private ClientExceptionFactory initClientExceptionFactory() {
   849|         boolean jCacheAvailable = JCacheDetector.isJCacheAvailable(getClientConfig().getClassLoader());
   850|         return new ClientExceptionFactory(jCacheAvailable);
   851|     }
   852|     public ClientExceptionFactory getClientExceptionFactory() {
   853|         return clientExceptionFactory;
   854|     }
   855| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/HazelcastClientManagedContext.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-43 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.impl.clientside;
    17| import com.hazelcast.core.HazelcastInstanceAware;
    18| import com.hazelcast.core.ManagedContext;
    19| import com.hazelcast.spi.serialization.SerializationServiceAware;
    20| final class HazelcastClientManagedContext implements ManagedContext {
    21|     private final HazelcastClientInstanceImpl instance;
    22|     private final ManagedContext externalContext;
    23|     private final boolean hasExternalContext;
    24|     public HazelcastClientManagedContext(HazelcastClientInstanceImpl instance, ManagedContext externalContext) {
    25|         this.instance = instance;
    26|         this.externalContext = externalContext;
    27|         this.hasExternalContext = externalContext != null;
    28|     }
    29|     @Override
    30|     public Object initialize(Object obj) {
    31|         Object object = obj;
    32|         if (object instanceof HazelcastInstanceAware) {
    33|             ((HazelcastInstanceAware) object).setHazelcastInstance(instance);
    34|         }
    35|         if (object instanceof SerializationServiceAware) {
    36|             ((SerializationServiceAware) object).setSerializationService(instance.getSerializationService());
    37|         }
    38|         if (hasExternalContext) {
    39|             object = externalContext.initialize(object);
    40|         }
    41|         return object;
    42|     }
    43| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/HazelcastClientProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-267 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.impl.clientside;
    17| import com.hazelcast.cardinality.CardinalityEstimator;
    18| import com.hazelcast.client.HazelcastClientNotActiveException;
    19| import com.hazelcast.client.config.ClientConfig;
    20| import com.hazelcast.config.Config;
    21| import com.hazelcast.core.Client;
    22| import com.hazelcast.core.ClientService;
    23| import com.hazelcast.core.Cluster;
    24| import com.hazelcast.core.DistributedObject;
    25| import com.hazelcast.core.DistributedObjectListener;
    26| import com.hazelcast.core.HazelcastInstance;
    27| import com.hazelcast.core.IAtomicLong;
    28| import com.hazelcast.core.IAtomicReference;
    29| import com.hazelcast.core.ICacheManager;
    30| import com.hazelcast.core.ICountDownLatch;
    31| import com.hazelcast.core.IExecutorService;
    32| import com.hazelcast.core.IList;
    33| import com.hazelcast.core.ILock;
    34| import com.hazelcast.core.IMap;
    35| import com.hazelcast.core.IQueue;
    36| import com.hazelcast.core.ISemaphore;
    37| import com.hazelcast.core.ISet;
    38| import com.hazelcast.core.ITopic;
    39| import com.hazelcast.core.IdGenerator;
    40| import com.hazelcast.core.LifecycleService;
    41| import com.hazelcast.core.MultiMap;
    42| import com.hazelcast.core.PartitionService;
    43| import com.hazelcast.core.ReplicatedMap;
    44| import com.hazelcast.crdt.pncounter.PNCounter;
    45| import com.hazelcast.durableexecutor.DurableExecutorService;
    46| import com.hazelcast.flakeidgen.FlakeIdGenerator;
    47| import com.hazelcast.instance.TerminatedLifecycleService;
    48| import com.hazelcast.logging.LoggingService;
    49| import com.hazelcast.mapreduce.JobTracker;
    50| import com.hazelcast.quorum.QuorumService;
    51| import com.hazelcast.ringbuffer.Ringbuffer;
    52| import com.hazelcast.scheduledexecutor.IScheduledExecutorService;
    53| import com.hazelcast.spi.impl.SerializationServiceSupport;
    54| import com.hazelcast.spi.serialization.SerializationService;
    55| import com.hazelcast.transaction.HazelcastXAResource;
    56| import com.hazelcast.transaction.TransactionContext;
    57| import com.hazelcast.transaction.TransactionException;
    58| import com.hazelcast.transaction.TransactionOptions;
    59| import com.hazelcast.transaction.TransactionalTask;
    60| import java.util.Collection;
    61| import java.util.concurrent.ConcurrentMap;
    62| /**
    63|  * A client-side proxy {@link com.hazelcast.core.HazelcastInstance} instance.
    64|  */
    65| @SuppressWarnings("checkstyle:classfanoutcomplexity")
    66| public class HazelcastClientProxy implements HazelcastInstance, SerializationServiceSupport {
    67|     public volatile HazelcastClientInstanceImpl client;
    68|     public HazelcastClientProxy(HazelcastClientInstanceImpl client) {
    69|         this.client = client;
    70|     }
    71|     @Override
    72|     public Config getConfig() {
    73|         return getClient().getConfig();
    74|     }
    75|     @Override
    76|     public String getName() {
    77|         return getClient().getName();
    78|     }
    79|     @Override
    80|     public <E> Ringbuffer<E> getRingbuffer(String name) {
    81|         return getClient().getRingbuffer(name);
    82|     }
    83|     @Override
    84|     public <E> IQueue<E> getQueue(String name) {
    85|         return getClient().getQueue(name);
    86|     }
    87|     @Override
    88|     public <E> ITopic<E> getTopic(String name) {
    89|         return getClient().getTopic(name);
    90|     }
    91|     @Override
    92|     public <E> ITopic<E> getReliableTopic(String name) {
    93|         return getClient().getReliableTopic(name);
    94|     }
    95|     @Override
    96|     public <E> ISet<E> getSet(String name) {
    97|         return getClient().getSet(name);
    98|     }
    99|     @Override
   100|     public <E> IList<E> getList(String name) {
   101|         return getClient().getList(name);
   102|     }
   103|     @Override
   104|     public <K, V> IMap<K, V> getMap(String name) {
   105|         return getClient().getMap(name);
   106|     }
   107|     @Override
   108|     public <K, V> MultiMap<K, V> getMultiMap(String name) {
   109|         return getClient().getMultiMap(name);
   110|     }
   111|     @Override
   112|     public <K, V> ReplicatedMap<K, V> getReplicatedMap(String name) {
   113|         return getClient().getReplicatedMap(name);
   114|     }
   115|     @Override
   116|     public JobTracker getJobTracker(String name) {
   117|         return getClient().getJobTracker(name);
   118|     }
   119|     @Override
   120|     public ILock getLock(String key) {
   121|         return getClient().getLock(key);
   122|     }
   123|     @Override
   124|     public ICacheManager getCacheManager() {
   125|         return getClient().getCacheManager();
   126|     }
   127|     @Override
   128|     public Cluster getCluster() {
   129|         return getClient().getCluster();
   130|     }
   131|     @Override
   132|     public Client getLocalEndpoint() {
   133|         return getClient().getLocalEndpoint();
   134|     }
   135|     @Override
   136|     public IExecutorService getExecutorService(String name) {
   137|         return getClient().getExecutorService(name);
   138|     }
   139|     @Override
   140|     public DurableExecutorService getDurableExecutorService(String name) {
   141|         return getClient().getDurableExecutorService(name);
   142|     }
   143|     @Override
   144|     public <T> T executeTransaction(TransactionalTask<T> task)
   145|             throws TransactionException {
   146|         return getClient().executeTransaction(task);
   147|     }
   148|     @Override
   149|     public <T> T executeTransaction(TransactionOptions options, TransactionalTask<T> task)
   150|             throws TransactionException {
   151|         return getClient().executeTransaction(options, task);
   152|     }
   153|     @Override
   154|     public TransactionContext newTransactionContext() {
   155|         return getClient().newTransactionContext();
   156|     }
   157|     @Override
   158|     public TransactionContext newTransactionContext(TransactionOptions options) {
   159|         return getClient().newTransactionContext(options);
   160|     }
   161|     @Override
   162|     public IdGenerator getIdGenerator(String name) {
   163|         return getClient().getIdGenerator(name);
   164|     }
   165|     @Override
   166|     public FlakeIdGenerator getFlakeIdGenerator(String name) {
   167|         return getClient().getFlakeIdGenerator(name);
   168|     }
   169|     @Override
   170|     public IAtomicLong getAtomicLong(String name) {
   171|         return getClient().getAtomicLong(name);
   172|     }
   173|     @Override
   174|     public <E> IAtomicReference<E> getAtomicReference(String name) {
   175|         return getClient().getAtomicReference(name);
   176|     }
   177|     @Override
   178|     public ICountDownLatch getCountDownLatch(String name) {
   179|         return getClient().getCountDownLatch(name);
   180|     }
   181|     @Override
   182|     public ISemaphore getSemaphore(String name) {
   183|         return getClient().getSemaphore(name);
   184|     }
   185|     @Override
   186|     public CardinalityEstimator getCardinalityEstimator(String name) {
   187|         return getClient().getCardinalityEstimator(name);
   188|     }
   189|     @Override
   190|     public PNCounter getPNCounter(String name) {
   191|         return getClient().getPNCounter(name);
   192|     }
   193|     @Override
   194|     public IScheduledExecutorService getScheduledExecutorService(String name) {
   195|         return getClient().getScheduledExecutorService(name);
   196|     }
   197|     @Override
   198|     public Collection<DistributedObject> getDistributedObjects() {
   199|         return getClient().getDistributedObjects();
   200|     }
   201|     @Override
   202|     public String addDistributedObjectListener(DistributedObjectListener distributedObjectListener) {
   203|         return getClient().addDistributedObjectListener(distributedObjectListener);
   204|     }
   205|     @Override
   206|     public boolean removeDistributedObjectListener(String registrationId) {
   207|         return getClient().removeDistributedObjectListener(registrationId);
   208|     }
   209|     @Override
   210|     public PartitionService getPartitionService() {
   211|         return getClient().getPartitionService();
   212|     }
   213|     @Override
   214|     public QuorumService getQuorumService() {
   215|         throw new UnsupportedOperationException();
   216|     }
   217|     @Override
   218|     public ClientService getClientService() {
   219|         return getClient().getClientService();
   220|     }
   221|     @Override
   222|     public LoggingService getLoggingService() {
   223|         return getClient().getLoggingService();
   224|     }
   225|     @Override
   226|     public LifecycleService getLifecycleService() {
   227|         final HazelcastClientInstanceImpl hz = client;
   228|         return hz != null ? hz.getLifecycleService() : new TerminatedLifecycleService();
   229|     }
   230|     @Override
   231|     public <T extends DistributedObject> T getDistributedObject(String serviceName, String name) {
   232|         return getClient().getDistributedObject(serviceName, name);
   233|     }
   234|     @Override
   235|     public ConcurrentMap<String, Object> getUserContext() {
   236|         return getClient().getUserContext();
   237|     }
   238|     public ClientConfig getClientConfig() {
   239|         return getClient().getClientConfig();
   240|     }
   241|     @Override
   242|     public HazelcastXAResource getXAResource() {
   243|         return getClient().getXAResource();
   244|     }
   245|     @Override
   246|     public void shutdown() {
   247|         getLifecycleService().shutdown();
   248|     }
   249|     @Override
   250|     public SerializationService getSerializationService() {
   251|         return getClient().getSerializationService();
   252|     }
   253|     protected HazelcastClientInstanceImpl getClient() {
   254|         final HazelcastClientInstanceImpl c = client;
   255|         if (c == null || !c.getLifecycleService().isRunning()) {
   256|             throw new HazelcastClientNotActiveException("Client is not active.");
   257|         }
   258|         return c;
   259|     }
   260|     public String toString() {
   261|         final HazelcastClientInstanceImpl hazelcastInstance = client;
   262|         if (hazelcastInstance != null) {
   263|             return hazelcastInstance.toString();
   264|         }
   265|         return "HazelcastClientInstance {NOT ACTIVE}";
   266|     }
   267| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/LifecycleServiceImpl.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-154 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.impl.clientside;
    17| import com.hazelcast.client.HazelcastClient;
    18| import com.hazelcast.config.ListenerConfig;
    19| import com.hazelcast.core.LifecycleEvent;
    20| import com.hazelcast.core.LifecycleListener;
    21| import com.hazelcast.core.LifecycleService;
    22| import com.hazelcast.instance.BuildInfo;
    23| import com.hazelcast.instance.BuildInfoProvider;
    24| import com.hazelcast.logging.ILogger;
    25| import com.hazelcast.nio.ClassLoaderUtil;
    26| import com.hazelcast.util.UuidUtil;
    27| import com.hazelcast.util.executor.PoolExecutorThreadFactory;
    28| import java.util.EventListener;
    29| import java.util.List;
    30| import java.util.concurrent.ConcurrentHashMap;
    31| import java.util.concurrent.ConcurrentMap;
    32| import java.util.concurrent.ExecutorService;
    33| import java.util.concurrent.Executors;
    34| import java.util.concurrent.TimeUnit;
    35| import java.util.concurrent.atomic.AtomicBoolean;
    36| import static com.hazelcast.core.LifecycleEvent.LifecycleState.SHUTDOWN;
    37| import static com.hazelcast.core.LifecycleEvent.LifecycleState.SHUTTING_DOWN;
    38| import static com.hazelcast.core.LifecycleEvent.LifecycleState.STARTED;
    39| import static com.hazelcast.core.LifecycleEvent.LifecycleState.STARTING;
    40| import static com.hazelcast.util.StringUtil.isNullOrEmpty;
    41| /**
    42|  * Default {@link com.hazelcast.core.LifecycleService} implementation for the client.
    43|  */
    44| public final class LifecycleServiceImpl implements LifecycleService {
    45|     private static final long TERMINATE_TIMEOUT_SECONDS = 30;
    46|     private final HazelcastClientInstanceImpl client;
    47|     private final ConcurrentMap<String, LifecycleListener> lifecycleListeners
    48|             = new ConcurrentHashMap<String, LifecycleListener>();
    49|     private final AtomicBoolean active = new AtomicBoolean(false);
    50|     private final BuildInfo buildInfo;
    51|     private final ExecutorService executor;
    52|     public LifecycleServiceImpl(HazelcastClientInstanceImpl client) {
    53|         this.client = client;
    54|         ClassLoader classLoader = client.getClientConfig().getClassLoader();
    55|         executor = Executors.newSingleThreadExecutor(
    56|                 new PoolExecutorThreadFactory(client.getName() + ".lifecycle-", classLoader));
    57|         final List<ListenerConfig> listenerConfigs = client.getClientConfig().getListenerConfigs();
    58|         if (listenerConfigs != null && !listenerConfigs.isEmpty()) {
    59|             for (ListenerConfig listenerConfig : listenerConfigs) {
    60|                 EventListener implementation = listenerConfig.getImplementation();
    61|                 if (implementation == null) {
    62|                     try {
    63|                         implementation = ClassLoaderUtil.newInstance(classLoader, listenerConfig.getClassName());
    64|                     } catch (Exception e) {
    65|                         getLogger().severe(e);
    66|                     }
    67|                 }
    68|                 if (implementation instanceof LifecycleListener) {
    69|                     addLifecycleListener((LifecycleListener) implementation);
    70|                 }
    71|             }
    72|         }
    73|         buildInfo = BuildInfoProvider.getBuildInfo();
    74|         fireLifecycleEvent(STARTING);
    75|     }
    76|     private ILogger getLogger() {
    77|         return client.getLoggingService().getLogger(LifecycleService.class);
    78|     }
    79|     @Override
    80|     public String addLifecycleListener(LifecycleListener lifecycleListener) {
    81|         final String id = UuidUtil.newUnsecureUuidString();
    82|         lifecycleListeners.put(id, lifecycleListener);
    83|         return id;
    84|     }
    85|     @Override
    86|     public boolean removeLifecycleListener(String registrationId) {
    87|         return lifecycleListeners.remove(registrationId) != null;
    88|     }
    89|     public void fireLifecycleEvent(LifecycleEvent.LifecycleState lifecycleState) {
    90|         final LifecycleEvent lifecycleEvent = new LifecycleEvent(lifecycleState);
    91|         String revision = buildInfo.getRevision();
    92|         if (isNullOrEmpty(revision)) {
    93|             revision = "";
    94|         } else {
    95|             revision = " - " + revision;
    96|             BuildInfo upstreamInfo = buildInfo.getUpstreamBuildInfo();
    97|             if (upstreamInfo != null) {
    98|                 String upstreamRevision = upstreamInfo.getRevision();
    99|                 if (!isNullOrEmpty(upstreamRevision)) {
   100|                     revision += ", " + upstreamRevision;
   101|                 }
   102|             }
   103|         }
   104|         getLogger().info("HazelcastClient " + buildInfo.getVersion() + " ("
   105|                 + buildInfo.getBuild() + revision + ") is "
   106|                 + lifecycleEvent.getState());
   107|         executor.execute(new Runnable() {
   108|             @Override
   109|             public void run() {
   110|                 for (LifecycleListener lifecycleListener : lifecycleListeners.values()) {
   111|                     lifecycleListener.stateChanged(lifecycleEvent);
   112|                 }
   113|             }
   114|         });
   115|     }
   116|     public void setStarted() {
   117|         active.set(true);
   118|         fireLifecycleEvent(STARTED);
   119|     }
   120|     @Override
   121|     public boolean isRunning() {
   122|         return active.get();
   123|     }
   124|     @Override
   125|     public void shutdown() {
   126|         if (!active.compareAndSet(true, false)) {
   127|             return;
   128|         }
   129|         fireLifecycleEvent(SHUTTING_DOWN);
   130|         HazelcastClient.shutdown(client.getName());
   131|         client.doShutdown();
   132|         fireLifecycleEvent(SHUTDOWN);
   133|         shutdownExecutor();
   134|     }
   135|     @Override
   136|     public void terminate() {
   137|         shutdown();
   138|     }
   139|     private void shutdownExecutor() {
   140|         executor.shutdown();
   141|         try {
   142|             boolean success = executor.awaitTermination(TERMINATE_TIMEOUT_SECONDS, TimeUnit.SECONDS);
   143|             if (!success) {
   144|                 getLogger().warning("LifecycleService executor awaitTermination could not completed gracefully in "
   145|                         + TERMINATE_TIMEOUT_SECONDS + " seconds. Terminating forcefully.");
   146|                 executor.shutdownNow();
   147|             }
   148|         } catch (InterruptedException e) {
   149|             Thread.currentThread().interrupt();
   150|             getLogger().warning("LifecycleService executor awaitTermination is interrupted. Terminating forcefully.", e);
   151|             executor.shutdownNow();
   152|         }
   153|     }
   154| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/impl/clientside/package-info.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-19 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| /**
    17|  * Contains most of the client side HazelcastInstance implementation functionality.
    18|  */
    19| package com.hazelcast.client.impl.clientside;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/impl/querycache/subscriber/ClientInvokerWrapper.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.impl.querycache.subscriber;
    17| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.spi.ClientContext;
    20| import com.hazelcast.client.spi.impl.ClientInvocation;
    21| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    22| import com.hazelcast.map.impl.querycache.InvokerWrapper;
    23| import com.hazelcast.map.impl.querycache.QueryCacheContext;
    24| import com.hazelcast.nio.Address;
    25| import com.hazelcast.spi.Operation;
    26| import java.util.concurrent.Future;
    27| import static com.hazelcast.util.ExceptionUtil.rethrow;
    28| import static com.hazelcast.util.Preconditions.checkNotNegative;
    29| import static com.hazelcast.util.Preconditions.checkNotNull;
    30| /**
    31|  * Invocation functionality for client-side {@link QueryCacheContext}.
    32|  *
    33|  * @see InvokerWrapper
    34|  */
    35| public class ClientInvokerWrapper implements InvokerWrapper {
    36|     private final QueryCacheContext context;
    37|     private final ClientContext clientContext;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/impl/querycache/subscriber/ClientQueryCacheEventService.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 173-217 ---
   173|         if (queryCacheToListenerMap != null) {
   174|             queryCacheToListenerMap.removeAllListeners(cacheId);
   175|         }
   176|     }
   177|     /**
   178|      * Query cache event handler.
   179|      */
   180|     private final class QueryCacheHandler extends ContinuousQueryAddListenerCodec.AbstractEventHandler
   181|             implements EventHandler<ClientMessage> {
   182|         private final ListenerAdapter adapter;
   183|         private QueryCacheHandler(ListenerAdapter adapter) {
   184|             this.adapter = adapter;
   185|         }
   186|         @Override
   187|         public void beforeListenerRegister() {
   188|         }
   189|         @Override
   190|         public void onListenerRegister() {
   191|         }
   192|         @Override
   193|         public void handleQueryCacheSingleEventV10(QueryCacheEventData data) {
   194|             adapter.onEvent(new SingleIMapEvent(data));
   195|         }
   196|         @Override
   197|         public void handleQueryCacheBatchEventV10(Collection<QueryCacheEventData> events, String source, int partitionId) {
   198|             adapter.onEvent(new BatchIMapEvent(new BatchEventData(events, source, partitionId)));
   199|         }
   200|     }
   201|     private Collection<ListenerInfo> getListeners(String mapName, String cacheName) {
   202|         QueryCacheToListenerMapper queryCacheToListenerMapper = registrations.get(mapName);
   203|         if (queryCacheToListenerMapper == null) {
   204|             return Collections.emptySet();
   205|         }
   206|         return queryCacheToListenerMapper.getListenerInfos(cacheName);
   207|     }
   208|     /**
   209|      * Dispatches an event to a listener.
   210|      */
   211|     private static class EventDispatcher implements StripedRunnable, TimeoutRunnable {
   212|         private final Object event;
   213|         private final ListenerInfo listenerInfo;
   214|         private final int orderKey;
   215|         private final long timeoutMs;
   216|         private final SerializationService serializationService;
   217|         public EventDispatcher(Object event, ListenerInfo listenerInfo, int orderKey,


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/impl/statistics/Statistics.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-53 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.impl.statistics;
    17| import com.hazelcast.client.connection.nio.ClientConnection;
    18| import com.hazelcast.client.connection.nio.ClientConnectionManagerImpl;
    19| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    20| import com.hazelcast.client.impl.protocol.ClientMessage;
    21| import com.hazelcast.client.impl.protocol.codec.ClientStatisticsCodec;
    22| import com.hazelcast.client.spi.impl.ClientInvocation;
    23| import com.hazelcast.core.ClientType;
    24| import com.hazelcast.instance.BuildInfo;
    25| import com.hazelcast.instance.BuildInfoProvider;
    26| import com.hazelcast.internal.metrics.Gauge;
    27| import com.hazelcast.internal.metrics.MetricsRegistry;
    28| import com.hazelcast.internal.nearcache.NearCache;
    29| import com.hazelcast.logging.ILogger;
    30| import com.hazelcast.logging.Logger;
    31| import com.hazelcast.monitor.impl.NearCacheStatsImpl;
    32| import com.hazelcast.nio.Address;
    33| import com.hazelcast.security.Credentials;
    34| import com.hazelcast.spi.properties.HazelcastProperties;
    35| import com.hazelcast.spi.properties.HazelcastProperty;
    36| import java.util.ArrayList;
    37| import java.util.List;
    38| import static java.lang.String.format;
    39| import static java.util.concurrent.TimeUnit.SECONDS;
    40| /**
    41|  * This class is the main entry point for collecting and sending the client
    42|  * statistics to the cluster. If the client statistics feature is enabled,
    43|  * it will be scheduled for periodic statistics collection and sent.
    44|  */
    45| public class Statistics {
    46|     /**
    47|      * Use to enable the client statistics collection.
    48|      * <p>
    49|      * The default is false.
    50|      */
    51|     public static final HazelcastProperty ENABLED = new HazelcastProperty("hazelcast.client.statistics.enabled", false);
    52|     /**
    53|      * The period in seconds the statistics run.

# --- HUNK 2: Lines 125-178 ---
   125|         client.getClientExecutionService().scheduleWithRepetition(new Runnable() {
   126|             @Override
   127|             public void run() {
   128|                 ClientConnection ownerConnection = getOwnerConnection();
   129|                 if (null == ownerConnection) {
   130|                     logger.finest("Can not send client statistics to the server. No owner connection.");
   131|                     return;
   132|                 }
   133|                 final StringBuilder stats = new StringBuilder();
   134|                 periodicStats.fillMetrics(stats, ownerConnection);
   135|                 addNearCacheStats(stats);
   136|                 sendStats(stats.toString(), ownerConnection);
   137|             }
   138|         }, 0, periodSeconds, SECONDS);
   139|     }
   140|     private void addNearCacheStats(final StringBuilder stats) {
   141|         for (NearCache nearCache : client.getNearCacheManager().listAllNearCaches()) {
   142|             String nearCacheName = nearCache.getName();
   143|             StringBuilder nearCacheNameWithPrefix = getNameWithPrefix(nearCacheName);
   144|             nearCacheNameWithPrefix.append('.');
   145|             NearCacheStatsImpl nearCacheStats = (NearCacheStatsImpl) nearCache.getNearCacheStats();
   146|             String prefix = nearCacheNameWithPrefix.toString();
   147|             addStat(stats, prefix, "creationTime", nearCacheStats.getCreationTime());
   148|             addStat(stats, prefix, "evictions", nearCacheStats.getEvictions());
   149|             addStat(stats, prefix, "hits", nearCacheStats.getHits());
   150|             addStat(stats, prefix, "lastPersistenceDuration", nearCacheStats.getLastPersistenceDuration());
   151|             addStat(stats, prefix, "lastPersistenceKeyCount", nearCacheStats.getLastPersistenceKeyCount());
   152|             addStat(stats, prefix, "lastPersistenceTime", nearCacheStats.getLastPersistenceTime());
   153|             addStat(stats, prefix, "lastPersistenceWrittenBytes", nearCacheStats.getLastPersistenceWrittenBytes());
   154|             addStat(stats, prefix, "misses", nearCacheStats.getMisses());
   155|             addStat(stats, prefix, "ownedEntryCount", nearCacheStats.getOwnedEntryCount());
   156|             addStat(stats, prefix, "expirations", nearCacheStats.getExpirations());
   157|             addStat(stats, prefix, "invalidations", nearCacheStats.getInvalidations());
   158|             addStat(stats, prefix, "invalidationRequests", nearCacheStats.getInvalidationRequests());
   159|             addStat(stats, prefix, "ownedEntryMemoryCost", nearCacheStats.getOwnedEntryMemoryCost());
   160|             String persistenceFailure = nearCacheStats.getLastPersistenceFailure();
   161|             if (persistenceFailure != null && !persistenceFailure.isEmpty()) {
   162|                 addStat(stats, prefix, "lastPersistenceFailure", persistenceFailure);
   163|             }
   164|         }
   165|     }
   166|     private void addStat(final StringBuilder stats, final String name, long value) {
   167|         addStat(stats, null, name, value);
   168|     }
   169|     private void addStat(final StringBuilder stats, final String keyPrefix, final String name, long value) {
   170|         stats.append(STAT_SEPARATOR);
   171|         if (null != keyPrefix) {
   172|             stats.append(keyPrefix);
   173|         }
   174|         stats.append(name).append(KEY_VALUE_SEPARATOR).append(value);
   175|     }
   176|     private void addStat(StringBuilder stats, String name, String value) {
   177|         addStat(stats, null, name, value);
   178|     }

# --- HUNK 3: Lines 292-323 ---
   292|                     metricsRegistry.newLongGauge("os.totalPhysicalMemorySize"),
   293|                     metricsRegistry.newLongGauge("os.totalSwapSpaceSize"),
   294|                     metricsRegistry.newLongGauge("runtime.availableProcessors"),
   295|                     metricsRegistry.newLongGauge("runtime.freeMemory"),
   296|                     metricsRegistry.newLongGauge("runtime.maxMemory"),
   297|                     metricsRegistry.newLongGauge("runtime.totalMemory"),
   298|                     metricsRegistry.newLongGauge("runtime.uptime"),
   299|                     metricsRegistry.newLongGauge("runtime.usedMemory"),
   300|                     metricsRegistry.newLongGauge("executionService.userExecutorQueueSize"),
   301|                 };
   302|         void fillMetrics(final StringBuilder stats, final ClientConnection ownerConnection) {
   303|             stats.append("lastStatisticsCollectionTime").append(KEY_VALUE_SEPARATOR).append(System.currentTimeMillis());
   304|             addStat(stats, "enterprise", enterprise);
   305|             addStat(stats, "clientType", ClientType.JAVA.toString());
   306|             addStat(stats, "clientVersion", BuildInfoProvider.getBuildInfo().getVersion());
   307|             addStat(stats, "clusterConnectionTimestamp", ownerConnection.getStartTime());
   308|             stats.append(STAT_SEPARATOR).append("clientAddress").append(KEY_VALUE_SEPARATOR)
   309|                  .append(ownerConnection.getLocalSocketAddress().getAddress().getHostAddress()).append(":")
   310|                  .append(ownerConnection.getLocalSocketAddress().getPort());
   311|             addStat(stats, "clientName", client.getName());
   312|             ClientConnectionManagerImpl connectionManager = (ClientConnectionManagerImpl) client.getConnectionManager();
   313|             Credentials credentials = connectionManager.getLastCredentials();
   314|             if (credentials != null) {
   315|                 addStat(stats, "credentials.principal", credentials.getPrincipal());
   316|             }
   317|             for (Gauge gauge : allGauges) {
   318|                 stats.append(STAT_SEPARATOR).append(gauge.getName()).append(KEY_VALUE_SEPARATOR);
   319|                 gauge.render(stats);
   320|             }
   321|         }
   322|     }
   323| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/map/impl/ClientMapPartitionIterator.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.map.impl;
    17| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.codec.MapFetchEntriesCodec;
    20| import com.hazelcast.client.impl.protocol.codec.MapFetchKeysCodec;
    21| import com.hazelcast.client.proxy.ClientMapProxy;
    22| import com.hazelcast.client.spi.ClientContext;
    23| import com.hazelcast.client.spi.impl.ClientInvocation;
    24| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    25| import com.hazelcast.core.IMap;
    26| import com.hazelcast.map.impl.iterator.AbstractMapPartitionIterator;
    27| import com.hazelcast.spi.serialization.SerializationService;
    28| import com.hazelcast.util.ExceptionUtil;
    29| import java.util.List;
    30| /**
    31|  * Iterator for iterating map entries in the {@code partitionId}. The values are not fetched one-by-one but rather in batches.
    32|  * <b>NOTE</b>
    33|  * Iterating the map should be done only when the {@link IMap} is not being
    34|  * mutated and the cluster is stable (there are no migrations or membership changes).
    35|  * In other cases, the iterator may not return some entries or may return an entry twice.
    36|  */
    37| public class ClientMapPartitionIterator<K, V> extends AbstractMapPartitionIterator<K, V> {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/map/impl/ClientMapQueryPartitionIterator.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.map.impl;
    17| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.codec.MapFetchWithQueryCodec;
    20| import com.hazelcast.client.proxy.ClientMapProxy;
    21| import com.hazelcast.client.spi.ClientContext;
    22| import com.hazelcast.client.spi.impl.ClientInvocation;
    23| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    24| import com.hazelcast.core.IMap;
    25| import com.hazelcast.map.impl.iterator.AbstractMapQueryPartitionIterator;
    26| import com.hazelcast.nio.serialization.Data;
    27| import com.hazelcast.projection.Projection;
    28| import com.hazelcast.query.Predicate;
    29| import com.hazelcast.spi.serialization.SerializationService;
    30| import com.hazelcast.util.ExceptionUtil;
    31| import java.util.Iterator;
    32| import java.util.List;
    33| import java.util.Map.Entry;
    34| /**
    35|  * Iterator for iterating map entries in the {@code partitionId}. The values are not fetched one-by-one but rather in batches.
    36|  * The {@link Iterator#remove()} method is not supported and will throw an {@link UnsupportedOperationException}.
    37|  * <b>NOTE</b>


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/map/impl/nearcache/invalidation/ClientMapInvalidationMetaDataFetcher.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-62 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.map.impl.nearcache.invalidation;
    17| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.codec.MapFetchNearCacheInvalidationMetadataCodec.ResponseParameters;
    20| import com.hazelcast.client.spi.ClientClusterService;
    21| import com.hazelcast.client.spi.ClientContext;
    22| import com.hazelcast.client.spi.impl.ClientInvocation;
    23| import com.hazelcast.core.Member;
    24| import com.hazelcast.internal.nearcache.impl.invalidation.InvalidationMetaDataFetcher;
    25| import com.hazelcast.nio.Address;
    26| import com.hazelcast.spi.InternalCompletableFuture;
    27| import java.util.Collection;
    28| import java.util.List;
    29| import static com.hazelcast.client.impl.protocol.codec.MapFetchNearCacheInvalidationMetadataCodec.decodeResponse;
    30| import static com.hazelcast.client.impl.protocol.codec.MapFetchNearCacheInvalidationMetadataCodec.encodeRequest;
    31| import static com.hazelcast.cluster.memberselector.MemberSelectors.DATA_MEMBER_SELECTOR;
    32| import static java.util.concurrent.TimeUnit.MINUTES;
    33| /**
    34|  * {@code InvalidationMetaDataFetcher} for client side usage
    35|  */
    36| public class ClientMapInvalidationMetaDataFetcher extends InvalidationMetaDataFetcher {
    37|     private final ClientClusterService clusterService;
    38|     private final HazelcastClientInstanceImpl clientImpl;
    39|     public ClientMapInvalidationMetaDataFetcher(ClientContext clientContext) {
    40|         super(clientContext.getLoggingService().getLogger(ClientMapInvalidationMetaDataFetcher.class));
    41|         this.clusterService = clientContext.getClusterService();
    42|         this.clientImpl = (HazelcastClientInstanceImpl) clientContext.getHazelcastInstance();
    43|     }
    44|     @Override
    45|     protected Collection<Member> getDataMembers() {
    46|         return clusterService.getMembers(DATA_MEMBER_SELECTOR);
    47|     }
    48|     @Override
    49|     protected InternalCompletableFuture fetchMetadataOf(Address address, List<String> names) {
    50|         ClientMessage message = encodeRequest(names, address);
    51|         ClientInvocation invocation = new ClientInvocation(clientImpl, message, null, address);
    52|         return invocation.invoke();
    53|     }
    54|     @Override
    55|     protected void extractMemberMetadata(Member member,
    56|                                          InternalCompletableFuture future,
    57|                                          MetadataHolder metadataHolder) throws Exception {
    58|         ClientMessage message = ((ClientMessage) future.get(ASYNC_RESULT_WAIT_TIMEOUT_MINUTES, MINUTES));
    59|         ResponseParameters response = decodeResponse(message);
    60|         metadataHolder.setMetadata(response.partitionUuidList, response.namePartitionSequenceList);
    61|     }
    62| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientAtomicLongProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.codec.AtomicLongAddAndGetCodec;
    20| import com.hazelcast.client.impl.protocol.codec.AtomicLongAlterAndGetCodec;
    21| import com.hazelcast.client.impl.protocol.codec.AtomicLongAlterCodec;
    22| import com.hazelcast.client.impl.protocol.codec.AtomicLongApplyCodec;
    23| import com.hazelcast.client.impl.protocol.codec.AtomicLongCompareAndSetCodec;
    24| import com.hazelcast.client.impl.protocol.codec.AtomicLongDecrementAndGetCodec;
    25| import com.hazelcast.client.impl.protocol.codec.AtomicLongGetAndAddCodec;
    26| import com.hazelcast.client.impl.protocol.codec.AtomicLongGetAndAlterCodec;
    27| import com.hazelcast.client.impl.protocol.codec.AtomicLongGetAndIncrementCodec;
    28| import com.hazelcast.client.impl.protocol.codec.AtomicLongGetAndSetCodec;
    29| import com.hazelcast.client.impl.protocol.codec.AtomicLongGetCodec;
    30| import com.hazelcast.client.impl.protocol.codec.AtomicLongIncrementAndGetCodec;
    31| import com.hazelcast.client.impl.protocol.codec.AtomicLongSetCodec;
    32| import com.hazelcast.client.spi.ClientContext;
    33| import com.hazelcast.core.IAtomicLong;
    34| import com.hazelcast.core.IFunction;
    35| import com.hazelcast.spi.InternalCompletableFuture;
    36| import static com.hazelcast.util.Preconditions.isNotNull;
    37| /**


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientAtomicReferenceProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.codec.AtomicReferenceAlterAndGetCodec;
    20| import com.hazelcast.client.impl.protocol.codec.AtomicReferenceAlterCodec;
    21| import com.hazelcast.client.impl.protocol.codec.AtomicReferenceApplyCodec;
    22| import com.hazelcast.client.impl.protocol.codec.AtomicReferenceClearCodec;
    23| import com.hazelcast.client.impl.protocol.codec.AtomicReferenceCompareAndSetCodec;
    24| import com.hazelcast.client.impl.protocol.codec.AtomicReferenceContainsCodec;
    25| import com.hazelcast.client.impl.protocol.codec.AtomicReferenceGetAndAlterCodec;
    26| import com.hazelcast.client.impl.protocol.codec.AtomicReferenceGetAndSetCodec;
    27| import com.hazelcast.client.impl.protocol.codec.AtomicReferenceGetCodec;
    28| import com.hazelcast.client.impl.protocol.codec.AtomicReferenceIsNullCodec;
    29| import com.hazelcast.client.impl.protocol.codec.AtomicReferenceSetAndGetCodec;
    30| import com.hazelcast.client.impl.protocol.codec.AtomicReferenceSetCodec;
    31| import com.hazelcast.client.spi.ClientContext;
    32| import com.hazelcast.core.IAtomicReference;
    33| import com.hazelcast.core.IFunction;
    34| import com.hazelcast.spi.InternalCompletableFuture;
    35| import static com.hazelcast.util.Preconditions.isNotNull;
    36| /**
    37|  * Proxy implementation of {@link IAtomicReference}.


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientCardinalityEstimatorProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.cardinality.CardinalityEstimator;
    18| import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
    19| import com.hazelcast.client.impl.protocol.ClientMessage;
    20| import com.hazelcast.client.impl.protocol.codec.CardinalityEstimatorAddCodec;
    21| import com.hazelcast.client.impl.protocol.codec.CardinalityEstimatorEstimateCodec;
    22| import com.hazelcast.client.spi.ClientContext;
    23| import com.hazelcast.nio.serialization.Data;
    24| import com.hazelcast.spi.InternalCompletableFuture;
    25| import static com.hazelcast.util.Preconditions.checkNotNull;
    26| /**
    27|  * Proxy implementation of {@link CardinalityEstimator}.
    28|  */
    29| public class ClientCardinalityEstimatorProxy
    30|         extends PartitionSpecificClientProxy implements CardinalityEstimator {
    31|     private static final ClientMessageDecoder ADD_DECODER = new ClientMessageDecoder() {
    32|         @Override
    33|         public Void decodeClientMessage(ClientMessage clientMessage) {
    34|             return null;
    35|         }
    36|     };
    37|     private static final ClientMessageDecoder ESTIMATE_DECODER = new ClientMessageDecoder() {
    38|         @Override


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientConditionProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.client.impl.clientside.ClientLockReferenceIdGenerator;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.codec.ConditionAwaitCodec;
    20| import com.hazelcast.client.impl.protocol.codec.ConditionBeforeAwaitCodec;
    21| import com.hazelcast.client.impl.protocol.codec.ConditionSignalAllCodec;
    22| import com.hazelcast.client.impl.protocol.codec.ConditionSignalCodec;
    23| import com.hazelcast.client.spi.ClientContext;
    24| import com.hazelcast.concurrent.lock.LockService;
    25| import com.hazelcast.core.ICondition;
    26| import com.hazelcast.util.Clock;
    27| import com.hazelcast.util.ThreadUtil;
    28| import java.util.Date;
    29| import java.util.concurrent.TimeUnit;
    30| import static com.hazelcast.util.ExceptionUtil.sneakyThrow;
    31| /**
    32|  * Proxy implementation of {@link ICondition}.
    33|  */
    34| public class ClientConditionProxy extends PartitionSpecificClientProxy implements ICondition {
    35|     private final String conditionId;
    36|     private ClientLockReferenceIdGenerator referenceIdGenerator;
    37|     public ClientConditionProxy(ClientLockProxy clientLockProxy, String name, ClientContext context) {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientDurableExecutorServiceProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.codec.DurableExecutorDisposeResultCodec;
    20| import com.hazelcast.client.impl.protocol.codec.DurableExecutorIsShutdownCodec;
    21| import com.hazelcast.client.impl.protocol.codec.DurableExecutorRetrieveAndDisposeResultCodec;
    22| import com.hazelcast.client.impl.protocol.codec.DurableExecutorRetrieveResultCodec;
    23| import com.hazelcast.client.impl.protocol.codec.DurableExecutorShutdownCodec;
    24| import com.hazelcast.client.impl.protocol.codec.DurableExecutorSubmitToPartitionCodec;
    25| import com.hazelcast.client.spi.ClientContext;
    26| import com.hazelcast.client.spi.ClientPartitionService;
    27| import com.hazelcast.client.spi.ClientProxy;
    28| import com.hazelcast.client.spi.impl.ClientInvocation;
    29| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    30| import com.hazelcast.client.util.ClientDelegatingFuture;
    31| import com.hazelcast.core.ExecutionCallback;
    32| import com.hazelcast.core.PartitionAware;
    33| import com.hazelcast.durableexecutor.DurableExecutorService;
    34| import com.hazelcast.durableexecutor.DurableExecutorServiceFuture;
    35| import com.hazelcast.executor.impl.RunnableAdapter;
    36| import com.hazelcast.nio.Bits;
    37| import com.hazelcast.spi.serialization.SerializationService;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientExecutorServiceProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.codec.ExecutorServiceIsShutdownCodec;
    20| import com.hazelcast.client.impl.protocol.codec.ExecutorServiceShutdownCodec;
    21| import com.hazelcast.client.impl.protocol.codec.ExecutorServiceSubmitToAddressCodec;
    22| import com.hazelcast.client.impl.protocol.codec.ExecutorServiceSubmitToPartitionCodec;
    23| import com.hazelcast.client.spi.ClientContext;
    24| import com.hazelcast.client.spi.ClientPartitionService;
    25| import com.hazelcast.client.spi.ClientProxy;
    26| import com.hazelcast.client.spi.impl.ClientInvocation;
    27| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    28| import com.hazelcast.client.util.ClientDelegatingFuture;
    29| import com.hazelcast.core.ExecutionCallback;
    30| import com.hazelcast.core.HazelcastException;
    31| import com.hazelcast.core.IExecutorService;
    32| import com.hazelcast.core.Member;
    33| import com.hazelcast.core.MemberSelector;
    34| import com.hazelcast.core.MultiExecutionCallback;
    35| import com.hazelcast.core.PartitionAware;
    36| import com.hazelcast.executor.impl.RunnableAdapter;
    37| import com.hazelcast.monitor.LocalExecutorStats;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientListProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 273-310 ---
   273|     }
   274|     @Override
   275|     public List<E> subList(int fromIndex, int toIndex) {
   276|         ClientMessage request = ListSubCodec.encodeRequest(name, fromIndex, toIndex);
   277|         ClientMessage response = invokeOnPartition(request);
   278|         ListSubCodec.ResponseParameters resultParameters = ListSubCodec.decodeResponse(response);
   279|         List<Data> resultCollection = resultParameters.response;
   280|         return new UnmodifiableLazyList<E>(resultCollection, getSerializationService());
   281|     }
   282|     @Override
   283|     public String toString() {
   284|         return "IList{" + "name='" + name + '\'' + '}';
   285|     }
   286|     private class ItemEventHandler extends ListAddListenerCodec.AbstractEventHandler
   287|             implements EventHandler<ClientMessage> {
   288|         private final ItemListener<E> listener;
   289|         public ItemEventHandler(ItemListener<E> listener) {
   290|             this.listener = listener;
   291|         }
   292|         @Override
   293|         public void handleItemEventV10(Data dataItem, String uuid, int eventType) {
   294|             Member member = getContext().getClusterService().getMember(uuid);
   295|             ItemEvent<E> itemEvent = new DataAwareItemEvent(name, ItemEventType.getByType(eventType),
   296|                     dataItem, member, getSerializationService());
   297|             if (eventType == ItemEventType.ADDED.getType()) {
   298|                 listener.itemAdded(itemEvent);
   299|             } else {
   300|                 listener.itemRemoved(itemEvent);
   301|             }
   302|         }
   303|         @Override
   304|         public void beforeListenerRegister() {
   305|         }
   306|         @Override
   307|         public void onListenerRegister() {
   308|         }
   309|     }
   310| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientLockProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.client.impl.clientside.ClientLockReferenceIdGenerator;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.codec.LockForceUnlockCodec;
    20| import com.hazelcast.client.impl.protocol.codec.LockGetLockCountCodec;
    21| import com.hazelcast.client.impl.protocol.codec.LockGetRemainingLeaseTimeCodec;
    22| import com.hazelcast.client.impl.protocol.codec.LockIsLockedByCurrentThreadCodec;
    23| import com.hazelcast.client.impl.protocol.codec.LockIsLockedCodec;
    24| import com.hazelcast.client.impl.protocol.codec.LockLockCodec;
    25| import com.hazelcast.client.impl.protocol.codec.LockTryLockCodec;
    26| import com.hazelcast.client.impl.protocol.codec.LockUnlockCodec;
    27| import com.hazelcast.client.spi.ClientContext;
    28| import com.hazelcast.core.ICondition;
    29| import com.hazelcast.core.ILock;
    30| import com.hazelcast.util.ThreadUtil;
    31| import java.util.concurrent.TimeUnit;
    32| import java.util.concurrent.locks.Condition;
    33| import static com.hazelcast.util.Preconditions.checkNotNull;
    34| import static com.hazelcast.util.Preconditions.checkPositive;
    35| import static java.lang.Thread.currentThread;
    36| /**
    37|  * Proxy implementation of {@link ILock}.


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientMapProxy.java
# Total hunks: 16
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.aggregation.Aggregator;
    18| import com.hazelcast.client.impl.clientside.ClientLockReferenceIdGenerator;
    19| import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
    20| import com.hazelcast.client.impl.protocol.ClientMessage;
    21| import com.hazelcast.client.impl.protocol.codec.MapAddEntryListenerCodec;
    22| import com.hazelcast.client.impl.protocol.codec.MapAddEntryListenerToKeyCodec;
    23| import com.hazelcast.client.impl.protocol.codec.MapAddEntryListenerToKeyWithPredicateCodec;
    24| import com.hazelcast.client.impl.protocol.codec.MapAddEntryListenerWithPredicateCodec;
    25| import com.hazelcast.client.impl.protocol.codec.MapAddIndexCodec;
    26| import com.hazelcast.client.impl.protocol.codec.MapAddInterceptorCodec;
    27| import com.hazelcast.client.impl.protocol.codec.MapAddPartitionLostListenerCodec;
    28| import com.hazelcast.client.impl.protocol.codec.MapAggregateCodec;
    29| import com.hazelcast.client.impl.protocol.codec.MapAggregateWithPredicateCodec;
    30| import com.hazelcast.client.impl.protocol.codec.MapClearCodec;
    31| import com.hazelcast.client.impl.protocol.codec.MapContainsKeyCodec;
    32| import com.hazelcast.client.impl.protocol.codec.MapContainsValueCodec;
    33| import com.hazelcast.client.impl.protocol.codec.MapDeleteCodec;
    34| import com.hazelcast.client.impl.protocol.codec.MapEntriesWithPagingPredicateCodec;
    35| import com.hazelcast.client.impl.protocol.codec.MapEntriesWithPredicateCodec;
    36| import com.hazelcast.client.impl.protocol.codec.MapEntrySetCodec;
    37| import com.hazelcast.client.impl.protocol.codec.MapEventJournalReadCodec;
    38| import com.hazelcast.client.impl.protocol.codec.MapEventJournalSubscribeCodec;
    39| import com.hazelcast.client.impl.protocol.codec.MapEventJournalSubscribeCodec.ResponseParameters;

# --- HUNK 2: Lines 44-135 ---
    44| import com.hazelcast.client.impl.protocol.codec.MapExecuteOnKeysCodec;
    45| import com.hazelcast.client.impl.protocol.codec.MapExecuteWithPredicateCodec;
    46| import com.hazelcast.client.impl.protocol.codec.MapFlushCodec;
    47| import com.hazelcast.client.impl.protocol.codec.MapForceUnlockCodec;
    48| import com.hazelcast.client.impl.protocol.codec.MapGetAllCodec;
    49| import com.hazelcast.client.impl.protocol.codec.MapGetCodec;
    50| import com.hazelcast.client.impl.protocol.codec.MapGetEntryViewCodec;
    51| import com.hazelcast.client.impl.protocol.codec.MapIsEmptyCodec;
    52| import com.hazelcast.client.impl.protocol.codec.MapIsLockedCodec;
    53| import com.hazelcast.client.impl.protocol.codec.MapKeySetCodec;
    54| import com.hazelcast.client.impl.protocol.codec.MapKeySetWithPagingPredicateCodec;
    55| import com.hazelcast.client.impl.protocol.codec.MapKeySetWithPredicateCodec;
    56| import com.hazelcast.client.impl.protocol.codec.MapLoadAllCodec;
    57| import com.hazelcast.client.impl.protocol.codec.MapLoadGivenKeysCodec;
    58| import com.hazelcast.client.impl.protocol.codec.MapLockCodec;
    59| import com.hazelcast.client.impl.protocol.codec.MapProjectCodec;
    60| import com.hazelcast.client.impl.protocol.codec.MapProjectWithPredicateCodec;
    61| import com.hazelcast.client.impl.protocol.codec.MapPutAllCodec;
    62| import com.hazelcast.client.impl.protocol.codec.MapPutCodec;
    63| import com.hazelcast.client.impl.protocol.codec.MapPutIfAbsentCodec;
    64| import com.hazelcast.client.impl.protocol.codec.MapPutIfAbsentWithMaxIdleCodec;
    65| import com.hazelcast.client.impl.protocol.codec.MapPutTransientCodec;
    66| import com.hazelcast.client.impl.protocol.codec.MapPutTransientWithMaxIdleCodec;
    67| import com.hazelcast.client.impl.protocol.codec.MapPutWithMaxIdleCodec;
    68| import com.hazelcast.client.impl.protocol.codec.MapRemoveAllCodec;
    69| import com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;
    70| import com.hazelcast.client.impl.protocol.codec.MapRemoveEntryListenerCodec;
    71| import com.hazelcast.client.impl.protocol.codec.MapRemoveIfSameCodec;
    72| import com.hazelcast.client.impl.protocol.codec.MapRemoveInterceptorCodec;
    73| import com.hazelcast.client.impl.protocol.codec.MapRemovePartitionLostListenerCodec;
    74| import com.hazelcast.client.impl.protocol.codec.MapReplaceCodec;
    75| import com.hazelcast.client.impl.protocol.codec.MapReplaceIfSameCodec;
    76| import com.hazelcast.client.impl.protocol.codec.MapSetCodec;
    77| import com.hazelcast.client.impl.protocol.codec.MapSetTtlCodec;
    78| import com.hazelcast.client.impl.protocol.codec.MapSetWithMaxIdleCodec;
    79| import com.hazelcast.client.impl.protocol.codec.MapSizeCodec;
    80| import com.hazelcast.client.impl.protocol.codec.MapSubmitToKeyCodec;
    81| import com.hazelcast.client.impl.protocol.codec.MapTryLockCodec;
    82| import com.hazelcast.client.impl.protocol.codec.MapTryPutCodec;
    83| import com.hazelcast.client.impl.protocol.codec.MapTryRemoveCodec;
    84| import com.hazelcast.client.impl.protocol.codec.MapUnlockCodec;
    85| import com.hazelcast.client.impl.protocol.codec.MapValuesCodec;
    86| import com.hazelcast.client.impl.protocol.codec.MapValuesWithPagingPredicateCodec;
    87| import com.hazelcast.client.impl.protocol.codec.MapValuesWithPredicateCodec;
    88| import com.hazelcast.client.impl.querycache.ClientQueryCacheContext;
    89| import com.hazelcast.client.impl.querycache.subscriber.ClientQueryCacheEndToEndConstructor;
    90| import com.hazelcast.client.map.impl.ClientMapPartitionIterator;
    91| import com.hazelcast.client.map.impl.ClientMapQueryPartitionIterator;
    92| import com.hazelcast.client.spi.ClientContext;
    93| import com.hazelcast.client.spi.ClientPartitionService;
    94| import com.hazelcast.client.spi.ClientProxy;
    95| import com.hazelcast.client.spi.EventHandler;
    96| import com.hazelcast.client.spi.impl.ClientInvocation;
    97| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    98| import com.hazelcast.client.spi.impl.ListenerMessageCodec;
    99| import com.hazelcast.client.util.ClientDelegatingFuture;
   100| import com.hazelcast.core.EntryEvent;
   101| import com.hazelcast.core.EntryEventType;
   102| import com.hazelcast.core.EntryListener;
   103| import com.hazelcast.core.EntryView;
   104| import com.hazelcast.core.ExecutionCallback;
   105| import com.hazelcast.core.HazelcastException;
   106| import com.hazelcast.core.ICompletableFuture;
   107| import com.hazelcast.core.IMap;
   108| import com.hazelcast.core.IMapEvent;
   109| import com.hazelcast.core.MapEvent;
   110| import com.hazelcast.core.Member;
   111| import com.hazelcast.core.ReadOnly;
   112| import com.hazelcast.internal.journal.EventJournalInitialSubscriberState;
   113| import com.hazelcast.internal.journal.EventJournalReader;
   114| import com.hazelcast.internal.serialization.InternalSerializationService;
   115| import com.hazelcast.internal.util.SimpleCompletedFuture;
   116| import com.hazelcast.map.EntryBackupProcessor;
   117| import com.hazelcast.map.EntryProcessor;
   118| import com.hazelcast.map.MapInterceptor;
   119| import com.hazelcast.map.MapPartitionLostEvent;
   120| import com.hazelcast.map.QueryCache;
   121| import com.hazelcast.map.impl.DataAwareEntryEvent;
   122| import com.hazelcast.map.impl.LazyMapEntry;
   123| import com.hazelcast.map.impl.ListenerAdapter;
   124| import com.hazelcast.map.impl.SimpleEntryView;
   125| import com.hazelcast.map.impl.querycache.subscriber.QueryCacheEndToEndProvider;
   126| import com.hazelcast.map.impl.querycache.subscriber.QueryCacheRequest;
   127| import com.hazelcast.map.impl.querycache.subscriber.SubscriberContext;
   128| import com.hazelcast.map.journal.EventJournalMapEvent;
   129| import com.hazelcast.map.listener.MapListener;
   130| import com.hazelcast.map.listener.MapPartitionLostListener;
   131| import com.hazelcast.mapreduce.Collator;
   132| import com.hazelcast.mapreduce.CombinerFactory;
   133| import com.hazelcast.mapreduce.Job;
   134| import com.hazelcast.mapreduce.JobTracker;
   135| import com.hazelcast.mapreduce.KeyValueSource;

# --- HUNK 3: Lines 140-203 ---
   140| import com.hazelcast.mapreduce.aggregation.Aggregation;
   141| import com.hazelcast.mapreduce.aggregation.Supplier;
   142| import com.hazelcast.monitor.LocalMapStats;
   143| import com.hazelcast.monitor.impl.LocalMapStatsImpl;
   144| import com.hazelcast.nio.serialization.Data;
   145| import com.hazelcast.projection.Projection;
   146| import com.hazelcast.query.PagingPredicate;
   147| import com.hazelcast.query.PartitionPredicate;
   148| import com.hazelcast.query.Predicate;
   149| import com.hazelcast.ringbuffer.ReadResultSet;
   150| import com.hazelcast.ringbuffer.impl.client.PortableReadResultSet;
   151| import com.hazelcast.spi.impl.UnmodifiableLazyList;
   152| import com.hazelcast.spi.serialization.SerializationService;
   153| import com.hazelcast.util.CollectionUtil;
   154| import com.hazelcast.util.IterationType;
   155| import com.hazelcast.util.Preconditions;
   156| import com.hazelcast.util.collection.InflatableSet;
   157| import java.util.AbstractMap;
   158| import java.util.ArrayList;
   159| import java.util.Collection;
   160| import java.util.Collections;
   161| import java.util.HashMap;
   162| import java.util.Iterator;
   163| import java.util.List;
   164| import java.util.Map;
   165| import java.util.Set;
   166| import java.util.concurrent.Future;
   167| import java.util.concurrent.TimeUnit;
   168| import static com.hazelcast.map.impl.ListenerAdapters.createListenerAdapter;
   169| import static com.hazelcast.map.impl.MapListenerFlagOperator.setAndGetListenerFlags;
   170| import static com.hazelcast.map.impl.querycache.subscriber.QueryCacheRequest.newQueryCacheRequest;
   171| import static com.hazelcast.map.impl.recordstore.RecordStore.DEFAULT_TTL;
   172| import static com.hazelcast.util.CollectionUtil.objectToDataCollection;
   173| import static com.hazelcast.util.ExceptionUtil.rethrow;
   174| import static com.hazelcast.util.MapUtil.createHashMap;
   175| import static com.hazelcast.util.Preconditions.checkNotInstanceOf;
   176| import static com.hazelcast.util.Preconditions.checkNotNull;
   177| import static com.hazelcast.util.SortingUtil.getSortedQueryResultSet;
   178| import static com.hazelcast.util.ThreadUtil.getThreadId;
   179| import static com.hazelcast.util.TimeUtil.timeInMsOrOneIfResultIsZero;
   180| import static com.hazelcast.util.TimeUtil.timeInMsOrTimeIfNullUnit;
   181| import static java.lang.Thread.currentThread;
   182| import static java.util.Collections.emptyMap;
   183| import static java.util.concurrent.TimeUnit.MILLISECONDS;
   184| /**
   185|  * Proxy implementation of {@link IMap}.
   186|  *
   187|  * @param <K> key
   188|  * @param <V> value
   189|  */
   190| @SuppressWarnings("checkstyle:classdataabstractioncoupling")
   191| public class ClientMapProxy<K, V> extends ClientProxy
   192|         implements IMap<K, V>, EventJournalReader<EventJournalMapEvent<K, V>> {
   193|     protected static final String NULL_LISTENER_IS_NOT_ALLOWED = "Null listener is not allowed!";
   194|     protected static final String NULL_KEY_IS_NOT_ALLOWED = "Null key is not allowed!";
   195|     protected static final String NULL_VALUE_IS_NOT_ALLOWED = "Null value is not allowed!";
   196|     protected static final String NULL_PREDICATE_IS_NOT_ALLOWED = "Predicate should not be null!";
   197|     protected static final String NULL_AGGREGATOR_IS_NOT_ALLOWED = "Aggregator should not be null!";
   198|     protected static final String NULL_PROJECTION_IS_NOT_ALLOWED = "Projection should not be null!";
   199|     @SuppressWarnings("unchecked")
   200|     private static final ClientMessageDecoder GET_ASYNC_RESPONSE_DECODER = new ClientMessageDecoder() {
   201|         @Override
   202|         public <T> T decodeClientMessage(ClientMessage clientMessage) {
   203|             return (T) MapGetCodec.decodeResponse(clientMessage).response;

# --- HUNK 4: Lines 214-260 ---
   214|     private static final ClientMessageDecoder SET_ASYNC_RESPONSE_DECODER = new ClientMessageDecoder() {
   215|         @Override
   216|         public <T> T decodeClientMessage(ClientMessage clientMessage) {
   217|             return null;
   218|         }
   219|     };
   220|     @SuppressWarnings("unchecked")
   221|     private static final ClientMessageDecoder REMOVE_ASYNC_RESPONSE_DECODER = new ClientMessageDecoder() {
   222|         @Override
   223|         public <T> T decodeClientMessage(ClientMessage clientMessage) {
   224|             return (T) MapRemoveCodec.decodeResponse(clientMessage).response;
   225|         }
   226|     };
   227|     @SuppressWarnings("unchecked")
   228|     private static final ClientMessageDecoder SUBMIT_TO_KEY_RESPONSE_DECODER = new ClientMessageDecoder() {
   229|         @Override
   230|         public <T> T decodeClientMessage(ClientMessage clientMessage) {
   231|             return (T) MapSubmitToKeyCodec.decodeResponse(clientMessage).response;
   232|         }
   233|     };
   234|     @SuppressWarnings("unchecked")
   235|     private final ClientMessageDecoder submitToKeysResponseDecoder = new ClientMessageDecoder() {
   236|         @Override
   237|         public <T> T decodeClientMessage(ClientMessage clientMessage) {
   238|             return (T) prepareResult(MapExecuteOnKeysCodec.decodeResponse(clientMessage).response);
   239|         }
   240|     };
   241|     private ClientMessageDecoder eventJournalReadResponseDecoder;
   242|     private ClientMessageDecoder eventJournalSubscribeResponseDecoder;
   243|     private ClientLockReferenceIdGenerator lockReferenceIdGenerator;
   244|     private ClientQueryCacheContext queryCacheContext;
   245|     public ClientMapProxy(String serviceName, String name, ClientContext context) {
   246|         super(serviceName, name, context);
   247|     }
   248|     @Override
   249|     protected void onInitialize() {
   250|         super.onInitialize();
   251|         lockReferenceIdGenerator = getClient().getLockReferenceIdGenerator();
   252|         queryCacheContext = getContext().getQueryCacheContext();
   253|         eventJournalReadResponseDecoder = new ClientMessageDecoder() {
   254|             @Override
   255|             public ReadResultSet<?> decodeClientMessage(ClientMessage message) {
   256|                 final MapEventJournalReadCodec.ResponseParameters params = MapEventJournalReadCodec.decodeResponse(message);
   257|                 final PortableReadResultSet<?> resultSet = new PortableReadResultSet<Object>(
   258|                         params.readCount, params.items, params.itemSeqs,
   259|                         params.nextSeqExist ? params.nextSeq : ReadResultSet.SEQUENCE_UNAVAILABLE);
   260|                 resultSet.setSerializationService(getSerializationService());

# --- HUNK 5: Lines 287-335 ---
   287|         Data valueData = toData(value);
   288|         ClientMessage request = MapContainsValueCodec.encodeRequest(name, valueData);
   289|         ClientMessage response = invoke(request);
   290|         MapContainsValueCodec.ResponseParameters resultParameters = MapContainsValueCodec.decodeResponse(response);
   291|         return resultParameters.response;
   292|     }
   293|     @Override
   294|     public V get(Object key) {
   295|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   296|         return toObject(getInternal(key));
   297|     }
   298|     protected Object getInternal(Object key) {
   299|         Data keyData = toData(key);
   300|         ClientMessage request = MapGetCodec.encodeRequest(name, keyData, getThreadId());
   301|         ClientMessage response = invoke(request, keyData);
   302|         MapGetCodec.ResponseParameters resultParameters = MapGetCodec.decodeResponse(response);
   303|         return resultParameters.response;
   304|     }
   305|     @Override
   306|     public V put(K key, V value) {
   307|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   308|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   309|         return putInternal(DEFAULT_TTL, MILLISECONDS, null, null, key, value);
   310|     }
   311|     @Override
   312|     public V put(K key, V value, long ttl, TimeUnit ttlUnit, long maxIdle, TimeUnit maxIdleUnit) {
   313|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   314|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   315|         return putInternal(ttl, ttlUnit, maxIdle, maxIdleUnit, key, value);
   316|     }
   317|     @Override
   318|     public V remove(Object key) {
   319|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   320|         MapRemoveCodec.ResponseParameters resultParameters = removeInternal(key);
   321|         return toObject(resultParameters.response);
   322|     }
   323|     protected MapRemoveCodec.ResponseParameters removeInternal(Object key) {
   324|         Data keyData = toData(key);
   325|         ClientMessage request = MapRemoveCodec.encodeRequest(name, keyData, getThreadId());
   326|         ClientMessage response = invoke(request, keyData);
   327|         return MapRemoveCodec.decodeResponse(response);
   328|     }
   329|     @Override
   330|     public boolean remove(Object key, Object value) {
   331|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   332|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   333|         return removeInternal(key, value);
   334|     }
   335|     protected boolean removeInternal(Object key, Object value) {

# --- HUNK 6: Lines 369-470 ---
   369|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   370|         return getAsyncInternal(key);
   371|     }
   372|     protected ICompletableFuture<V> getAsyncInternal(Object key) {
   373|         try {
   374|             Data keyData = toData(key);
   375|             ClientMessage request = MapGetCodec.encodeRequest(name, keyData, getThreadId());
   376|             ClientInvocationFuture future = invokeOnKeyOwner(request, keyData);
   377|             return new ClientDelegatingFuture<V>(future, getSerializationService(), GET_ASYNC_RESPONSE_DECODER);
   378|         } catch (Exception e) {
   379|             throw rethrow(e);
   380|         }
   381|     }
   382|     private ClientInvocationFuture invokeOnKeyOwner(ClientMessage request, Data keyData) {
   383|         int partitionId = getContext().getPartitionService().getPartitionId(keyData);
   384|         ClientInvocation clientInvocation = new ClientInvocation(getClient(), request, getName(), partitionId);
   385|         return clientInvocation.invoke();
   386|     }
   387|     @Override
   388|     public ICompletableFuture<V> putAsync(K key, V value) {
   389|         return putAsyncInternal(DEFAULT_TTL, MILLISECONDS, null, null, key, value);
   390|     }
   391|     @Override
   392|     public ICompletableFuture<V> putAsync(K key, V value, long ttl, TimeUnit timeunit) {
   393|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   394|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   395|         return putAsyncInternal(ttl, timeunit, null, null, key, value);
   396|     }
   397|     @Override
   398|     public ICompletableFuture<V> putAsync(K key, V value, long ttl, TimeUnit ttlUnit, long maxIdle, TimeUnit maxIdleUnit) {
   399|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   400|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   401|         return putAsyncInternal(ttl, ttlUnit, maxIdle, maxIdleUnit, key, value);
   402|     }
   403|     protected ICompletableFuture<V> putAsyncInternal(long ttl, TimeUnit timeunit, Long maxIdle, TimeUnit maxIdleUnit,
   404|                                                      Object key, Object value) {
   405|         try {
   406|             Data keyData = toData(key);
   407|             Data valueData = toData(value);
   408|             long ttlMillis = timeInMsOrOneIfResultIsZero(ttl, timeunit);
   409|             ClientMessage request;
   410|             if (maxIdle != null) {
   411|                 request = MapPutWithMaxIdleCodec.encodeRequest(name, keyData, valueData, getThreadId(),
   412|                         ttlMillis, timeInMsOrOneIfResultIsZero(maxIdle, maxIdleUnit));
   413|             } else {
   414|                 request = MapPutCodec.encodeRequest(name, keyData, valueData, getThreadId(), ttlMillis);
   415|             }
   416|             ClientInvocationFuture future = invokeOnKeyOwner(request, keyData);
   417|             return new ClientDelegatingFuture<V>(future, getSerializationService(), PUT_ASYNC_RESPONSE_DECODER);
   418|         } catch (Exception e) {
   419|             throw rethrow(e);
   420|         }
   421|     }
   422|     @Override
   423|     public ICompletableFuture<Void> setAsync(K key, V value) {
   424|         return setAsync(key, value, -1, MILLISECONDS);
   425|     }
   426|     @Override
   427|     public ICompletableFuture<Void> setAsync(K key, V value, long ttl, TimeUnit timeunit) {
   428|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   429|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   430|         return setAsyncInternal(ttl, timeunit, null, null, key, value);
   431|     }
   432|     @Override
   433|     public ICompletableFuture<Void> setAsync(K key, V value, long ttl, TimeUnit ttlUnit, long maxIdle, TimeUnit maxIdleUnit) {
   434|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   435|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   436|         return setAsyncInternal(ttl, ttlUnit, maxIdle, maxIdleUnit, key, value);
   437|     }
   438|     protected ICompletableFuture<Void> setAsyncInternal(long ttl, TimeUnit timeunit, Long maxIdle, TimeUnit maxIdleUnit,
   439|                                                         Object key, Object value) {
   440|         try {
   441|             Data keyData = toData(key);
   442|             Data valueData = toData(value);
   443|             long ttlMillis = timeInMsOrOneIfResultIsZero(ttl, timeunit);
   444|             ClientMessage request;
   445|             if (maxIdle != null) {
   446|                 request = MapSetWithMaxIdleCodec.encodeRequest(name, keyData, valueData, getThreadId(),
   447|                         ttlMillis, timeInMsOrOneIfResultIsZero(maxIdle, maxIdleUnit));
   448|             } else {
   449|                 request = MapSetCodec.encodeRequest(name, keyData, valueData, getThreadId(), ttlMillis);
   450|             }
   451|             ClientInvocationFuture future = invokeOnKeyOwner(request, keyData);
   452|             return new ClientDelegatingFuture<Void>(future, getSerializationService(), SET_ASYNC_RESPONSE_DECODER);
   453|         } catch (Exception e) {
   454|             throw rethrow(e);
   455|         }
   456|     }
   457|     @Override
   458|     public ICompletableFuture<V> removeAsync(K key) {
   459|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   460|         return removeAsyncInternal(key);
   461|     }
   462|     protected ICompletableFuture<V> removeAsyncInternal(Object key) {
   463|         try {
   464|             Data keyData = toData(key);
   465|             ClientMessage request = MapRemoveCodec.encodeRequest(name, keyData, getThreadId());
   466|             ClientInvocationFuture future = invokeOnKeyOwner(request, keyData);
   467|             return new ClientDelegatingFuture<V>(future, getSerializationService(), REMOVE_ASYNC_RESPONSE_DECODER);
   468|         } catch (Exception e) {
   469|             throw rethrow(e);
   470|         }

# --- HUNK 7: Lines 473-705 ---
   473|     public boolean tryRemove(K key, long timeout, TimeUnit timeunit) {
   474|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   475|         return tryRemoveInternal(timeout, timeunit, key);
   476|     }
   477|     protected boolean tryRemoveInternal(long timeout, TimeUnit timeunit, Object key) {
   478|         Data keyData = toData(key);
   479|         ClientMessage request = MapTryRemoveCodec.encodeRequest(name, keyData, getThreadId(), timeunit.toMillis(timeout));
   480|         ClientMessage response = invoke(request, keyData);
   481|         MapTryRemoveCodec.ResponseParameters resultParameters = MapTryRemoveCodec.decodeResponse(response);
   482|         return resultParameters.response;
   483|     }
   484|     @Override
   485|     public boolean tryPut(K key, V value, long timeout, TimeUnit timeunit) {
   486|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   487|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   488|         return tryPutInternal(timeout, timeunit, key, value);
   489|     }
   490|     protected boolean tryPutInternal(long timeout, TimeUnit timeunit, Object key, Object value) {
   491|         Data keyData = toData(key);
   492|         Data valueData = toData(value);
   493|         long timeoutMillis = timeInMsOrOneIfResultIsZero(timeout, timeunit);
   494|         ClientMessage request = MapTryPutCodec.encodeRequest(name, keyData, valueData, getThreadId(), timeoutMillis);
   495|         ClientMessage response = invoke(request, keyData);
   496|         MapTryPutCodec.ResponseParameters resultParameters = MapTryPutCodec.decodeResponse(response);
   497|         return resultParameters.response;
   498|     }
   499|     @Override
   500|     public V put(K key, V value, long ttl, TimeUnit timeunit) {
   501|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   502|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   503|         return putInternal(ttl, timeunit, null, null, key, value);
   504|     }
   505|     protected V putInternal(long ttl, TimeUnit ttlUnit, Long maxIdle, TimeUnit maxIdleUnit, Object key, Object value) {
   506|         Data keyData = toData(key);
   507|         Data valueData = toData(value);
   508|         long ttlMillis = timeInMsOrOneIfResultIsZero(ttl, ttlUnit);
   509|         ClientMessage request;
   510|         if (maxIdle != null) {
   511|             request = MapPutWithMaxIdleCodec.encodeRequest(name, keyData, valueData,
   512|                     getThreadId(), ttlMillis, timeInMsOrOneIfResultIsZero(maxIdle, maxIdleUnit));
   513|         } else {
   514|             request = MapPutCodec.encodeRequest(name, keyData, valueData, getThreadId(), ttlMillis);
   515|         }
   516|         ClientMessage response = invoke(request, keyData);
   517|         MapPutCodec.ResponseParameters resultParameters = MapPutCodec.decodeResponse(response);
   518|         return toObject(resultParameters.response);
   519|     }
   520|     @Override
   521|     public void putTransient(K key, V value, long ttl, TimeUnit timeunit) {
   522|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   523|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   524|         putTransientInternal(ttl, timeunit, null, null, key, value);
   525|     }
   526|     @Override
   527|     public void putTransient(K key, V value, long ttl, TimeUnit ttlUnit, long maxIdle, TimeUnit maxIdleUnit) {
   528|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   529|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   530|         putTransientInternal(ttl, ttlUnit, maxIdle, maxIdleUnit, key, value);
   531|     }
   532|     protected void putTransientInternal(long ttl, TimeUnit timeunit, Long maxIdle, TimeUnit maxIdleUnit,
   533|                                         Object key, Object value) {
   534|         Data keyData = toData(key);
   535|         Data valueData = toData(value);
   536|         long ttlMillis = timeInMsOrOneIfResultIsZero(ttl, timeunit);
   537|         ClientMessage request;
   538|         if (maxIdle != null) {
   539|             request = MapPutTransientWithMaxIdleCodec.encodeRequest(name, keyData, valueData,
   540|                     getThreadId(), ttlMillis, timeInMsOrOneIfResultIsZero(maxIdle, maxIdleUnit));
   541|         } else {
   542|             request = MapPutTransientCodec.encodeRequest(name, keyData, valueData, getThreadId(), ttlMillis);
   543|         }
   544|         invoke(request, keyData);
   545|     }
   546|     @Override
   547|     public V putIfAbsent(K key, V value) {
   548|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   549|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   550|         return putIfAbsentInternal(DEFAULT_TTL, MILLISECONDS, null, null, key, value);
   551|     }
   552|     @Override
   553|     public V putIfAbsent(K key, V value, long ttl, TimeUnit timeunit) {
   554|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   555|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   556|         return putIfAbsentInternal(ttl, timeunit, null, null, key, value);
   557|     }
   558|     @Override
   559|     public V putIfAbsent(K key, V value, long ttl, TimeUnit ttlUnit, long maxIdle, TimeUnit maxIdleUnit) {
   560|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   561|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   562|         return putIfAbsentInternal(ttl, ttlUnit, maxIdle, maxIdleUnit, key, value);
   563|     }
   564|     protected V putIfAbsentInternal(long ttl, TimeUnit timeunit, Long maxIdle, TimeUnit maxIdleUnit, Object key, Object value) {
   565|         Data keyData = toData(key);
   566|         Data valueData = toData(value);
   567|         long ttlMillis = timeInMsOrOneIfResultIsZero(ttl, timeunit);
   568|         ClientMessage request;
   569|         if (maxIdle != null) {
   570|             request = MapPutIfAbsentWithMaxIdleCodec.encodeRequest(name, keyData, valueData,
   571|                     getThreadId(), ttlMillis, timeInMsOrOneIfResultIsZero(maxIdle, maxIdleUnit));
   572|         } else {
   573|              request = MapPutIfAbsentCodec.encodeRequest(name, keyData, valueData,
   574|                     getThreadId(), ttlMillis);
   575|         }
   576|         ClientMessage result = invoke(request, keyData);
   577|         MapPutIfAbsentCodec.ResponseParameters resultParameters = MapPutIfAbsentCodec.decodeResponse(result);
   578|         return toObject(resultParameters.response);
   579|     }
   580|     @Override
   581|     public boolean replace(K key, V oldValue, V newValue) {
   582|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   583|         checkNotNull(oldValue, NULL_VALUE_IS_NOT_ALLOWED);
   584|         checkNotNull(newValue, NULL_VALUE_IS_NOT_ALLOWED);
   585|         return replaceIfSameInternal(key, oldValue, newValue);
   586|     }
   587|     protected boolean replaceIfSameInternal(Object key, Object oldValue, Object newValue) {
   588|         Data keyData = toData(key);
   589|         Data oldValueData = toData(oldValue);
   590|         Data newValueData = toData(newValue);
   591|         ClientMessage request = MapReplaceIfSameCodec.encodeRequest(name, keyData, oldValueData, newValueData, getThreadId());
   592|         ClientMessage response = invoke(request, keyData);
   593|         MapReplaceIfSameCodec.ResponseParameters resultParameters = MapReplaceIfSameCodec.decodeResponse(response);
   594|         return resultParameters.response;
   595|     }
   596|     @Override
   597|     public V replace(K key, V value) {
   598|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   599|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   600|         return replaceInternal(key, value);
   601|     }
   602|     protected V replaceInternal(Object key, Object value) {
   603|         Data keyData = toData(key);
   604|         Data valueData = toData(value);
   605|         ClientMessage request = MapReplaceCodec.encodeRequest(name, keyData, valueData, getThreadId());
   606|         ClientMessage response = invoke(request, keyData);
   607|         MapReplaceCodec.ResponseParameters resultParameters = MapReplaceCodec.decodeResponse(response);
   608|         return toObject(resultParameters.response);
   609|     }
   610|     @Override
   611|     public void set(K key, V value, long ttl, TimeUnit timeunit) {
   612|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   613|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   614|         setInternal(ttl, timeunit, null, null, key, value);
   615|     }
   616|     @Override
   617|     public void set(K key, V value, long ttl, TimeUnit ttlUnit, long maxIdle, TimeUnit maxIdleUnit) {
   618|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   619|         checkNotNull(value, NULL_VALUE_IS_NOT_ALLOWED);
   620|         setInternal(ttl, ttlUnit, maxIdle, maxIdleUnit, key, value);
   621|     }
   622|     protected void setInternal(long ttl, TimeUnit timeunit, Long maxIdle, TimeUnit maxIdleUnit, Object key, Object value) {
   623|         Data keyData = toData(key);
   624|         Data valueData = toData(value);
   625|         long ttlMillis = timeInMsOrOneIfResultIsZero(ttl, timeunit);
   626|         ClientMessage request;
   627|         if (maxIdle != null) {
   628|             request = MapSetWithMaxIdleCodec.encodeRequest(name, keyData, valueData, getThreadId(),
   629|                     ttlMillis, timeInMsOrOneIfResultIsZero(maxIdle, maxIdleUnit));
   630|         } else {
   631|             request = MapSetCodec.encodeRequest(name, keyData, valueData, getThreadId(), ttlMillis);
   632|         }
   633|         invoke(request, keyData);
   634|     }
   635|     @Override
   636|     public void lock(K key) {
   637|         lock(key, -1, MILLISECONDS);
   638|     }
   639|     @Override
   640|     public void lock(K key, long leaseTime, TimeUnit timeUnit) {
   641|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   642|         Data keyData = toData(key);
   643|         ClientMessage request = MapLockCodec.encodeRequest(name, keyData, getThreadId(),
   644|                 timeInMsOrTimeIfNullUnit(leaseTime, timeUnit), lockReferenceIdGenerator.getNextReferenceId());
   645|         invoke(request, keyData, Long.MAX_VALUE);
   646|     }
   647|     private <T> T invoke(ClientMessage clientMessage, Object key, long invocationTimeoutSeconds) {
   648|         final int partitionId = getContext().getPartitionService().getPartitionId(key);
   649|         try {
   650|             ClientInvocation clientInvocation = new ClientInvocation(getClient(), clientMessage, getName(), partitionId);
   651|             clientInvocation.setInvocationTimeoutMillis(invocationTimeoutSeconds);
   652|             final Future future = clientInvocation.invoke();
   653|             return (T) future.get();
   654|         } catch (Exception e) {
   655|             throw rethrow(e);
   656|         }
   657|     }
   658|     @Override
   659|     public boolean isLocked(K key) {
   660|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   661|         Data keyData = toData(key);
   662|         ClientMessage request = MapIsLockedCodec.encodeRequest(name, keyData);
   663|         ClientMessage response = invoke(request, keyData);
   664|         MapIsLockedCodec.ResponseParameters resultParameters = MapIsLockedCodec.decodeResponse(response);
   665|         return resultParameters.response;
   666|     }
   667|     @Override
   668|     public boolean tryLock(K key) {
   669|         try {
   670|             return tryLock(key, 0, null);
   671|         } catch (InterruptedException e) {
   672|             currentThread().interrupt();
   673|             return false;
   674|         }
   675|     }
   676|     @Override
   677|     public boolean tryLock(K key, long time, TimeUnit timeunit) throws InterruptedException {
   678|         return tryLock(key, time, timeunit, Long.MAX_VALUE, null);
   679|     }
   680|     @Override
   681|     public boolean tryLock(K key, long time, TimeUnit timeunit, long leaseTime, TimeUnit leaseUnit) throws InterruptedException {
   682|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   683|         Data keyData = toData(key);
   684|         long leaseTimeMillis = timeInMsOrTimeIfNullUnit(leaseTime, leaseUnit);
   685|         long timeoutMillis = timeInMsOrTimeIfNullUnit(time, timeunit);
   686|         ClientMessage request = MapTryLockCodec.encodeRequest(name, keyData, getThreadId(), leaseTimeMillis, timeoutMillis,
   687|                 lockReferenceIdGenerator.getNextReferenceId());
   688|         ClientMessage response = invoke(request, keyData, Long.MAX_VALUE);
   689|         MapTryLockCodec.ResponseParameters resultParameters = MapTryLockCodec.decodeResponse(response);
   690|         return resultParameters.response;
   691|     }
   692|     @Override
   693|     public void unlock(K key) {
   694|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   695|         Data keyData = toData(key);
   696|         ClientMessage request = MapUnlockCodec.encodeRequest(name, keyData, getThreadId(),
   697|                 lockReferenceIdGenerator.getNextReferenceId());
   698|         invoke(request, keyData);
   699|     }
   700|     @Override
   701|     public void forceUnlock(K key) {
   702|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   703|         Data keyData = toData(key);
   704|         ClientMessage request = MapForceUnlockCodec.encodeRequest(name, keyData, lockReferenceIdGenerator.getNextReferenceId());
   705|         invoke(request, keyData);

# --- HUNK 8: Lines 951-992 ---
   951|         Data keyData = toData(key);
   952|         ClientMessage request = MapGetEntryViewCodec.encodeRequest(name, keyData, getThreadId());
   953|         ClientMessage response = invoke(request, keyData);
   954|         MapGetEntryViewCodec.ResponseParameters parameters = MapGetEntryViewCodec.decodeResponse(response);
   955|         SimpleEntryView<Data, Data> dataEntryView = parameters.response;
   956|         if (dataEntryView == null) {
   957|             return null;
   958|         }
   959|         return new SimpleEntryView<K, V>()
   960|                 .withKey((K) toObject(dataEntryView.getKey()))
   961|                 .withValue((V) toObject(dataEntryView.getValue()))
   962|                 .withCost(dataEntryView.getCost())
   963|                 .withCreationTime(dataEntryView.getCreationTime())
   964|                 .withExpirationTime(dataEntryView.getExpirationTime())
   965|                 .withHits(dataEntryView.getHits())
   966|                 .withLastAccessTime(dataEntryView.getLastAccessTime())
   967|                 .withLastStoredTime(dataEntryView.getLastStoredTime())
   968|                 .withLastUpdateTime(dataEntryView.getLastUpdateTime())
   969|                 .withVersion(dataEntryView.getVersion())
   970|                 .withHits(dataEntryView.getHits())
   971|                 .withTtl(dataEntryView.getTtl())
   972|                 .withMaxIdle(parameters.maxIdle);
   973|     }
   974|     @Override
   975|     public boolean evict(K key) {
   976|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
   977|         return evictInternal(key);
   978|     }
   979|     protected boolean evictInternal(Object key) {
   980|         Data keyData = toData(key);
   981|         ClientMessage request = MapEvictCodec.encodeRequest(name, keyData, getThreadId());
   982|         ClientMessage response = invoke(request, keyData);
   983|         MapEvictCodec.ResponseParameters resultParameters = MapEvictCodec.decodeResponse(response);
   984|         return resultParameters.response;
   985|     }
   986|     @Override
   987|     public void evictAll() {
   988|         ClientMessage request = MapEvictAllCodec.encodeRequest(name);
   989|         invoke(request);
   990|     }
   991|     @Override
   992|     public void loadAll(boolean replaceExistingValues) {

# --- HUNK 9: Lines 1203-1256 ---
  1203|             resultList.add(new AbstractMap.SimpleImmutableEntry<K, V>(key, value));
  1204|         }
  1205|         return (Collection<V>) getSortedQueryResultSet(resultList, pagingPredicate, IterationType.VALUE);
  1206|     }
  1207|     @Override
  1208|     public Set<K> localKeySet() {
  1209|         throw new UnsupportedOperationException("Locality is ambiguous for client!");
  1210|     }
  1211|     @Override
  1212|     public Set<K> localKeySet(Predicate predicate) {
  1213|         throw new UnsupportedOperationException("Locality is ambiguous for client!");
  1214|     }
  1215|     @Override
  1216|     public void addIndex(String attribute, boolean ordered) {
  1217|         ClientMessage request = MapAddIndexCodec.encodeRequest(name, attribute, ordered);
  1218|         invoke(request);
  1219|     }
  1220|     @Override
  1221|     public LocalMapStats getLocalMapStats() {
  1222|         return new LocalMapStatsImpl();
  1223|     }
  1224|     @Override
  1225|     public boolean setTtl(K key, long ttl, TimeUnit timeunit) {
  1226|         checkNotNull(key);
  1227|         checkNotNull(timeunit);
  1228|         return setTtlInternal(key, ttl, timeunit);
  1229|     }
  1230|     protected boolean setTtlInternal(Object key, long ttl, TimeUnit timeUnit) {
  1231|         long ttlMillis = timeUnit.toMillis(ttl);
  1232|         Data keyData = toData(key);
  1233|         ClientMessage request = MapSetTtlCodec.encodeRequest(getName(), keyData, ttlMillis);
  1234|         ClientMessage result = invoke(request, keyData);
  1235|         MapSetTtlCodec.ResponseParameters resultParameters = MapSetTtlCodec.decodeResponse(result);
  1236|         return resultParameters.response;
  1237|     }
  1238|     @Override
  1239|     public Object executeOnKey(K key, EntryProcessor entryProcessor) {
  1240|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
  1241|         return executeOnKeyInternal(key, entryProcessor);
  1242|     }
  1243|     public Object executeOnKeyInternal(Object key, EntryProcessor entryProcessor) {
  1244|         validateEntryProcessorForSingleKeyProcessing(entryProcessor);
  1245|         Data keyData = toData(key);
  1246|         ClientMessage request = MapExecuteOnKeyCodec.encodeRequest(name, toData(entryProcessor), keyData, getThreadId());
  1247|         ClientMessage response = invoke(request, keyData);
  1248|         MapExecuteOnKeyCodec.ResponseParameters resultParameters = MapExecuteOnKeyCodec.decodeResponse(response);
  1249|         return toObject(resultParameters.response);
  1250|     }
  1251|     @Override
  1252|     public void submitToKey(K key, EntryProcessor entryProcessor, ExecutionCallback callback) {
  1253|         checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
  1254|         submitToKeyInternal(key, entryProcessor, callback);
  1255|     }
  1256|     @SuppressWarnings("unchecked")

# --- HUNK 10: Lines 1405-1460 ---
  1405|     }
  1406|     @SuppressWarnings("unchecked")
  1407|     private QueryCache<K, V> createQueryCache(QueryCacheRequest request) {
  1408|         SubscriberContext subscriberContext = queryCacheContext.getSubscriberContext();
  1409|         QueryCacheEndToEndProvider queryCacheEndToEndProvider = subscriberContext.getEndToEndQueryCacheProvider();
  1410|         return queryCacheEndToEndProvider.getOrCreateQueryCache(request.getMapName(), request.getCacheName(),
  1411|                 new ClientQueryCacheEndToEndConstructor(request));
  1412|     }
  1413|     @Override
  1414|     public Map<K, Object> executeOnKeys(Set<K> keys, EntryProcessor entryProcessor) {
  1415|         checkNotNull(keys, NULL_KEY_IS_NOT_ALLOWED);
  1416|         if (keys.isEmpty()) {
  1417|             return emptyMap();
  1418|         }
  1419|         Collection<Data> dataCollection = objectToDataCollection(keys, getSerializationService());
  1420|         ClientMessage request = MapExecuteOnKeysCodec.encodeRequest(name, toData(entryProcessor), dataCollection);
  1421|         ClientMessage response = invoke(request);
  1422|         MapExecuteOnKeysCodec.ResponseParameters resultParameters = MapExecuteOnKeysCodec.decodeResponse(response);
  1423|         return prepareResult(resultParameters.response);
  1424|     }
  1425|     /**
  1426|      * Async version of {@link #executeOnKeys}.
  1427|      */
  1428|     public ICompletableFuture<Map<K, Object>> submitToKeys(Set<K> keys, EntryProcessor entryProcessor) {
  1429|         checkNotNull(keys, NULL_KEY_IS_NOT_ALLOWED);
  1430|         if (keys.isEmpty()) {
  1431|             return new SimpleCompletedFuture<Map<K, Object>>(Collections.<K, Object>emptyMap());
  1432|         }
  1433|         Collection<Data> dataCollection = objectToDataCollection(keys, getSerializationService());
  1434|         ClientMessage request = MapExecuteOnKeysCodec.encodeRequest(name, toData(entryProcessor), dataCollection);
  1435|         ClientInvocationFuture future = new ClientInvocation(getClient(), request, getName()).invoke();
  1436|         return new ClientDelegatingFuture<Map<K, Object>>(future, getSerializationService(), submitToKeysResponseDecoder);
  1437|     }
  1438|     @Override
  1439|     public void set(K key, V value) {
  1440|         set(key, value, -1, MILLISECONDS);
  1441|     }
  1442|     @Override
  1443|     public int size() {
  1444|         ClientMessage request = MapSizeCodec.encodeRequest(name);
  1445|         ClientMessage response = invoke(request);
  1446|         MapSizeCodec.ResponseParameters resultParameters = MapSizeCodec.decodeResponse(response);
  1447|         return resultParameters.response;
  1448|     }
  1449|     @Override
  1450|     public boolean isEmpty() {
  1451|         ClientMessage request = MapIsEmptyCodec.encodeRequest(name);
  1452|         ClientMessage response = invoke(request);
  1453|         MapIsEmptyCodec.ResponseParameters resultParameters = MapIsEmptyCodec.decodeResponse(response);
  1454|         return resultParameters.response;
  1455|     }
  1456|     @Override
  1457|     public void putAll(Map<? extends K, ? extends V> map) {
  1458|         ClientPartitionService partitionService = getContext().getPartitionService();
  1459|         int partitionCount = partitionService.getPartitionCount();
  1460|         Map<Integer, List<Map.Entry<Data, Data>>> entryMap = new HashMap<Integer, List<Map.Entry<Data, Data>>>(partitionCount);

# --- HUNK 11: Lines 1570-1609 ---
  1570|             long startSequence,
  1571|             int minSize,
  1572|             int maxSize,
  1573|             int partitionId,
  1574|             com.hazelcast.util.function.Predicate<? super EventJournalMapEvent<K, V>> predicate,
  1575|             Projection<? super EventJournalMapEvent<K, V>, ? extends T> projection
  1576|     ) {
  1577|         if (maxSize < minSize) {
  1578|             throw new IllegalArgumentException("maxSize " + maxSize
  1579|                     + " must be greater or equal to minSize " + minSize);
  1580|         }
  1581|         final SerializationService ss = getSerializationService();
  1582|         final ClientMessage request = MapEventJournalReadCodec.encodeRequest(
  1583|                 name, startSequence, minSize, maxSize, ss.toData(predicate), ss.toData(projection));
  1584|         final ClientInvocationFuture fut = new ClientInvocation(getClient(), request, getName(), partitionId).invoke();
  1585|         return new ClientDelegatingFuture<ReadResultSet<T>>(fut, ss, eventJournalReadResponseDecoder);
  1586|     }
  1587|     public ClientQueryCacheContext getQueryCacheContext() {
  1588|         return queryCacheContext;
  1589|     }
  1590|     private EventHandler<ClientMessage> createHandler(ListenerAdapter<IMapEvent> listenerAdapter) {
  1591|         return new ClientMapEventHandler(listenerAdapter);
  1592|     }
  1593|     private static void validateEntryProcessorForSingleKeyProcessing(EntryProcessor entryProcessor) {
  1594|         if (entryProcessor instanceof ReadOnly) {
  1595|             EntryBackupProcessor backupProcessor = entryProcessor.getBackupProcessor();
  1596|             if (backupProcessor != null) {
  1597|                 throw new IllegalArgumentException(
  1598|                         "EntryProcessor.getBackupProcessor() should be null for a read-only EntryProcessor");
  1599|             }
  1600|         }
  1601|     }
  1602|     private static void checkNotPagingPredicate(Predicate predicate, String method) {
  1603|         if (predicate instanceof PagingPredicate) {
  1604|             throw new IllegalArgumentException("PagingPredicate not supported in " + method + " method");
  1605|         }
  1606|     }
  1607|     private static boolean containsPagingPredicate(Predicate predicate) {
  1608|         if (predicate instanceof PagingPredicate) {
  1609|             return true;

# --- HUNK 12: Lines 1612-1702 ---
  1612|             return false;
  1613|         }
  1614|         PartitionPredicate partitionPredicate = (PartitionPredicate) predicate;
  1615|         return partitionPredicate.getTarget() instanceof PagingPredicate;
  1616|     }
  1617|     private static PagingPredicate unwrapPagingPredicate(Predicate predicate) {
  1618|         if (predicate instanceof PagingPredicate) {
  1619|             return (PagingPredicate) predicate;
  1620|         }
  1621|         Predicate unwrappedPredicate = ((PartitionPredicate) predicate).getTarget();
  1622|         return (PagingPredicate) unwrappedPredicate;
  1623|     }
  1624|     private class ClientMapEventHandler
  1625|             extends MapAddEntryListenerCodec.AbstractEventHandler
  1626|             implements EventHandler<ClientMessage> {
  1627|         private ListenerAdapter<IMapEvent> listenerAdapter;
  1628|         ClientMapEventHandler(ListenerAdapter<IMapEvent> listenerAdapter) {
  1629|             this.listenerAdapter = listenerAdapter;
  1630|         }
  1631|         @Override
  1632|         public void handleEntryEventV10(Data key, Data value, Data oldValue, Data mergingValue, int eventType, String uuid,
  1633|                                         int numberOfAffectedEntries) {
  1634|             Member member = getContext().getClusterService().getMember(uuid);
  1635|             listenerAdapter.onEvent(createIMapEvent(key, value, oldValue, mergingValue, eventType, numberOfAffectedEntries,
  1636|                     member));
  1637|         }
  1638|         private IMapEvent createIMapEvent(Data key, Data value, Data oldValue, Data mergingValue, int eventType,
  1639|                                           int numberOfAffectedEntries, Member member) {
  1640|             EntryEventType entryEventType = EntryEventType.getByType(eventType);
  1641|             checkNotNull(entryEventType, "Unknown eventType: " + eventType);
  1642|             switch (entryEventType) {
  1643|                 case ADDED:
  1644|                 case REMOVED:
  1645|                 case UPDATED:
  1646|                 case EVICTED:
  1647|                 case EXPIRED:
  1648|                 case MERGED:
  1649|                 case LOADED:
  1650|                     return createEntryEvent(key, value, oldValue, mergingValue, eventType, member);
  1651|                 case EVICT_ALL:
  1652|                 case CLEAR_ALL:
  1653|                     return createMapEvent(eventType, numberOfAffectedEntries, member);
  1654|                 default:
  1655|                     throw new IllegalArgumentException("Not a known event type: " + entryEventType);
  1656|             }
  1657|         }
  1658|         private MapEvent createMapEvent(int eventType, int numberOfAffectedEntries, Member member) {
  1659|             return new MapEvent(name, member, eventType, numberOfAffectedEntries);
  1660|         }
  1661|         private EntryEvent<K, V> createEntryEvent(Data keyData, Data valueData, Data oldValueData, Data mergingValueData,
  1662|                                                   int eventType, Member member) {
  1663|             return new DataAwareEntryEvent<K, V>(member, eventType, name, keyData, valueData, oldValueData, mergingValueData,
  1664|                     getSerializationService());
  1665|         }
  1666|         @Override
  1667|         public void beforeListenerRegister() {
  1668|         }
  1669|         @Override
  1670|         public void onListenerRegister() {
  1671|         }
  1672|     }
  1673|     private class ClientMapPartitionLostEventHandler
  1674|             extends MapAddPartitionLostListenerCodec.AbstractEventHandler
  1675|             implements EventHandler<ClientMessage> {
  1676|         private MapPartitionLostListener listener;
  1677|         ClientMapPartitionLostEventHandler(MapPartitionLostListener listener) {
  1678|             this.listener = listener;
  1679|         }
  1680|         @Override
  1681|         public void beforeListenerRegister() {
  1682|         }
  1683|         @Override
  1684|         public void onListenerRegister() {
  1685|         }
  1686|         @Override
  1687|         public void handleMapPartitionLostEventV10(int partitionId, String uuid) {
  1688|             Member member = getContext().getClusterService().getMember(uuid);
  1689|             listener.partitionLost(new MapPartitionLostEvent(name, member, -1, partitionId));
  1690|         }
  1691|     }
  1692|     @Override
  1693|     protected void onDestroy() {
  1694|         try {
  1695|             SubscriberContext subscriberContext = queryCacheContext.getSubscriberContext();
  1696|             QueryCacheEndToEndProvider provider = subscriberContext.getEndToEndQueryCacheProvider();
  1697|             provider.destroyAllQueryCaches(name);
  1698|         } finally {
  1699|             super.onDestroy();
  1700|         }
  1701|     }
  1702| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientMapReduceProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 208-249 ---
   208|                     getContext().getLoggingService().getLogger(ClientCompletableFuture.class));
   209|             this.jobId = jobId;
   210|         }
   211|         @Override
   212|         public String getJobId() {
   213|             return jobId;
   214|         }
   215|         @Override
   216|         protected boolean shouldCancel(boolean mayInterruptIfRunning) {
   217|             boolean cancelled = false;
   218|             try {
   219|                 ClientMessage request = MapReduceCancelCodec.encodeRequest(name, jobId);
   220|                 ClientMessage response = invoke(request, jobId);
   221|                 cancelled = MapReduceCancelCodec.decodeResponse(response).response;
   222|             } catch (Exception ignore) {
   223|                 ignore(ignore);
   224|             }
   225|             return cancelled;
   226|         }
   227|         @Override
   228|         protected boolean setResult(Object result) {
   229|             return super.setResult(result);
   230|         }
   231|     }
   232|     private final class ClientTrackableJob<V>
   233|             implements TrackableJob<V> {
   234|         private final String jobId;
   235|         private final ClientInvocation clientInvocation;
   236|         private final AbstractCompletableFuture<V> completableFuture;
   237|         private ClientTrackableJob(String jobId, ClientInvocation clientInvocation,
   238|                                    AbstractCompletableFuture<V> completableFuture) {
   239|             this.jobId = jobId;
   240|             this.clientInvocation = clientInvocation;
   241|             this.completableFuture = completableFuture;
   242|         }
   243|         @Override
   244|         public JobTracker getJobTracker() {
   245|             return ClientMapReduceProxy.this;
   246|         }
   247|         @Override
   248|         public String getName() {
   249|             return ClientMapReduceProxy.this.name;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientMultiMapProxy.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.client.impl.clientside.ClientLockReferenceIdGenerator;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.codec.MultiMapAddEntryListenerCodec;
    20| import com.hazelcast.client.impl.protocol.codec.MultiMapAddEntryListenerToKeyCodec;
    21| import com.hazelcast.client.impl.protocol.codec.MultiMapClearCodec;
    22| import com.hazelcast.client.impl.protocol.codec.MultiMapContainsEntryCodec;
    23| import com.hazelcast.client.impl.protocol.codec.MultiMapContainsKeyCodec;
    24| import com.hazelcast.client.impl.protocol.codec.MultiMapContainsValueCodec;
    25| import com.hazelcast.client.impl.protocol.codec.MultiMapDeleteCodec;
    26| import com.hazelcast.client.impl.protocol.codec.MultiMapEntrySetCodec;
    27| import com.hazelcast.client.impl.protocol.codec.MultiMapForceUnlockCodec;
    28| import com.hazelcast.client.impl.protocol.codec.MultiMapGetCodec;
    29| import com.hazelcast.client.impl.protocol.codec.MultiMapIsLockedCodec;
    30| import com.hazelcast.client.impl.protocol.codec.MultiMapKeySetCodec;
    31| import com.hazelcast.client.impl.protocol.codec.MultiMapLockCodec;
    32| import com.hazelcast.client.impl.protocol.codec.MultiMapPutCodec;
    33| import com.hazelcast.client.impl.protocol.codec.MultiMapRemoveCodec;
    34| import com.hazelcast.client.impl.protocol.codec.MultiMapRemoveEntryCodec;
    35| import com.hazelcast.client.impl.protocol.codec.MultiMapRemoveEntryListenerCodec;
    36| import com.hazelcast.client.impl.protocol.codec.MultiMapSizeCodec;
    37| import com.hazelcast.client.impl.protocol.codec.MultiMapTryLockCodec;

# --- HUNK 2: Lines 401-441 ---
   401|     }
   402|     protected long getTimeInMillis(final long time, final TimeUnit timeunit) {
   403|         return timeunit != null ? timeunit.toMillis(time) : time;
   404|     }
   405|     @Override
   406|     protected void onInitialize() {
   407|         super.onInitialize();
   408|         lockReferenceIdGenerator = getClient().getLockReferenceIdGenerator();
   409|     }
   410|     private EventHandler<ClientMessage> createHandler(final Object listener) {
   411|         final ListenerAdapter listenerAdaptor = createListenerAdapter(listener);
   412|         return new ClientMultiMapEventHandler(listenerAdaptor);
   413|     }
   414|     private class ClientMultiMapEventHandler extends MultiMapAddEntryListenerCodec.AbstractEventHandler
   415|             implements EventHandler<ClientMessage> {
   416|         private final ListenerAdapter listenerAdapter;
   417|         public ClientMultiMapEventHandler(ListenerAdapter listenerAdapter) {
   418|             this.listenerAdapter = listenerAdapter;
   419|         }
   420|         @Override
   421|         public void handleEntryEventV10(Data key, Data value, Data oldValue, Data mergingValue,
   422|                            int eventType, String uuid, int numberOfAffectedEntries) {
   423|             Member member = getContext().getClusterService().getMember(uuid);
   424|             final IMapEvent iMapEvent = createIMapEvent(key, value, oldValue,
   425|                     mergingValue, eventType, numberOfAffectedEntries, member);
   426|             listenerAdapter.onEvent(iMapEvent);
   427|         }
   428|         private IMapEvent createIMapEvent(Data key, Data value, Data oldValue, Data mergingValue,
   429|                                           int eventType, int numberOfAffectedEntries, Member member) {
   430|             IMapEvent iMapEvent;
   431|             EntryEventType entryEventType = EntryEventType.getByType(eventType);
   432|             switch (entryEventType) {
   433|                 case ADDED:
   434|                 case REMOVED:
   435|                 case UPDATED:
   436|                 case EVICTED:
   437|                 case MERGED:
   438|                     iMapEvent = createEntryEvent(key, value, oldValue, mergingValue, eventType, member);
   439|                     break;
   440|                 case EVICT_ALL:
   441|                 case CLEAR_ALL:


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientQueueProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 84-124 ---
    84|             }
    85|             @Override
    86|             public ClientMessage encodeRemoveRequest(String realRegistrationId) {
    87|                 return QueueRemoveListenerCodec.encodeRequest(name, realRegistrationId);
    88|             }
    89|             @Override
    90|             public boolean decodeRemoveResponse(ClientMessage clientMessage) {
    91|                 return QueueRemoveListenerCodec.decodeResponse(clientMessage).response;
    92|             }
    93|         };
    94|     }
    95|     private class ItemEventHandler extends ListAddListenerCodec.AbstractEventHandler
    96|             implements EventHandler<ClientMessage> {
    97|         private final boolean includeValue;
    98|         private final ItemListener<E> listener;
    99|         public ItemEventHandler(boolean includeValue, ItemListener<E> listener) {
   100|             this.includeValue = includeValue;
   101|             this.listener = listener;
   102|         }
   103|         @Override
   104|         public void handleItemEventV10(Data dataItem, String uuid, int eventType) {
   105|             Member member = getContext().getClusterService().getMember(uuid);
   106|             ItemEvent<E> itemEvent = new DataAwareItemEvent(name, ItemEventType.getByType(eventType),
   107|                     dataItem, member, getSerializationService());
   108|             if (eventType == ItemEventType.ADDED.getType()) {
   109|                 listener.itemAdded(itemEvent);
   110|             } else {
   111|                 listener.itemRemoved(itemEvent);
   112|             }
   113|         }
   114|         @Override
   115|         public void beforeListenerRegister() {
   116|         }
   117|         @Override
   118|         public void onListenerRegister() {
   119|         }
   120|     }
   121|     @Override
   122|     public boolean removeItemListener(String registrationId) {
   123|         return deregisterListener(registrationId);
   124|     }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientReliableTopicProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.client.config.ClientReliableTopicConfig;
    18| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    19| import com.hazelcast.client.spi.ClientContext;
    20| import com.hazelcast.client.spi.ClientProxy;
    21| import com.hazelcast.core.ITopic;
    22| import com.hazelcast.core.MessageListener;
    23| import com.hazelcast.logging.ILogger;
    24| import com.hazelcast.monitor.LocalTopicStats;
    25| import com.hazelcast.nio.serialization.Data;
    26| import com.hazelcast.ringbuffer.OverflowPolicy;
    27| import com.hazelcast.ringbuffer.Ringbuffer;
    28| import com.hazelcast.spi.serialization.SerializationService;
    29| import com.hazelcast.topic.ReliableMessageListener;
    30| import com.hazelcast.topic.TopicOverloadException;
    31| import com.hazelcast.topic.TopicOverloadPolicy;
    32| import com.hazelcast.topic.impl.reliable.MessageRunner;
    33| import com.hazelcast.topic.impl.reliable.ReliableMessageListenerAdapter;
    34| import com.hazelcast.topic.impl.reliable.ReliableTopicMessage;
    35| import com.hazelcast.util.UuidUtil;
    36| import java.util.concurrent.ConcurrentHashMap;
    37| import java.util.concurrent.ConcurrentMap;
    38| import java.util.concurrent.Executor;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientReplicatedMapProxy.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 451-502 ---
   451|         return toObject(value);
   452|     }
   453|     private void tryPublishReserved(K key, V value, long reservationId) {
   454|         if (nearCache == null) {
   455|             return;
   456|         }
   457|         if (reservationId != NOT_RESERVED) {
   458|             nearCache.tryPublishReserved(key, value, reservationId, false);
   459|         }
   460|     }
   461|     private long tryReserveForUpdate(K key, Data keyData) {
   462|         if (nearCache == null) {
   463|             return NOT_RESERVED;
   464|         }
   465|         return nearCache.tryReserveForUpdate(key, keyData);
   466|     }
   467|     private void invalidate(K key) {
   468|         if (nearCache == null) {
   469|             return;
   470|         }
   471|         nearCache.invalidate(key);
   472|     }
   473|     private class ReplicatedMapEventHandler
   474|             extends ReplicatedMapAddEntryListenerCodec.AbstractEventHandler
   475|             implements EventHandler<ClientMessage> {
   476|         private final EntryListener<K, V> listener;
   477|         ReplicatedMapEventHandler(EntryListener<K, V> listener) {
   478|             this.listener = listener;
   479|         }
   480|         @Override
   481|         public void handleEntryEventV10(Data keyData, Data valueData, Data oldValueData, Data mergingValue,
   482|                                         int eventTypeId, String uuid, int numberOfAffectedEntries) {
   483|             Member member = getContext().getClusterService().getMember(uuid);
   484|             EntryEventType eventType = EntryEventType.getByType(eventTypeId);
   485|             EntryEvent<K, V> entryEvent = new DataAwareEntryEvent<K, V>(member, eventTypeId, name, keyData, valueData,
   486|                     oldValueData, null, getSerializationService());
   487|             switch (eventType) {
   488|                 case ADDED:
   489|                     listener.entryAdded(entryEvent);
   490|                     break;
   491|                 case REMOVED:
   492|                     listener.entryRemoved(entryEvent);
   493|                     break;
   494|                 case UPDATED:
   495|                     listener.entryUpdated(entryEvent);
   496|                     break;
   497|                 case EVICTED:
   498|                     listener.entryEvicted(entryEvent);
   499|                     break;
   500|                 case CLEAR_ALL:
   501|                     MapEvent mapEvent = new MapEvent(getName(), member, eventTypeId, numberOfAffectedEntries);
   502|                     listener.mapCleared(mapEvent);

# --- HUNK 2: Lines 511-550 ---
   511|         @Override
   512|         public void onListenerRegister() {
   513|         }
   514|     }
   515|     private class ReplicatedMapAddNearCacheEventHandler
   516|             extends ReplicatedMapAddNearCacheEntryListenerCodec.AbstractEventHandler
   517|             implements EventHandler<ClientMessage> {
   518|         @Override
   519|         public void beforeListenerRegister() {
   520|             if (nearCache != null) {
   521|                 nearCache.clear();
   522|             }
   523|         }
   524|         @Override
   525|         public void onListenerRegister() {
   526|             if (nearCache != null) {
   527|                 nearCache.clear();
   528|             }
   529|         }
   530|         @Override
   531|         public void handleEntryEventV10(Data dataKey, Data value, Data oldValue, Data mergingValue,
   532|                                         int eventType, String uuid, int numberOfAffectedEntries) {
   533|             EntryEventType entryEventType = EntryEventType.getByType(eventType);
   534|             switch (entryEventType) {
   535|                 case ADDED:
   536|                 case REMOVED:
   537|                 case UPDATED:
   538|                 case EVICTED:
   539|                     K key = toObject(dataKey);
   540|                     nearCache.invalidate(key);
   541|                     break;
   542|                 case CLEAR_ALL:
   543|                     nearCache.clear();
   544|                     break;
   545|                 default:
   546|                     throw new IllegalArgumentException("Not a known event type " + entryEventType);
   547|             }
   548|         }
   549|     }
   550| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientRingbufferProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.codec.RingbufferAddAllCodec;
    20| import com.hazelcast.client.impl.protocol.codec.RingbufferAddCodec;
    21| import com.hazelcast.client.impl.protocol.codec.RingbufferCapacityCodec;
    22| import com.hazelcast.client.impl.protocol.codec.RingbufferHeadSequenceCodec;
    23| import com.hazelcast.client.impl.protocol.codec.RingbufferReadManyCodec;
    24| import com.hazelcast.client.impl.protocol.codec.RingbufferReadOneCodec;
    25| import com.hazelcast.client.impl.protocol.codec.RingbufferRemainingCapacityCodec;
    26| import com.hazelcast.client.impl.protocol.codec.RingbufferSizeCodec;
    27| import com.hazelcast.client.impl.protocol.codec.RingbufferTailSequenceCodec;
    28| import com.hazelcast.client.spi.ClientContext;
    29| import com.hazelcast.client.spi.ClientProxy;
    30| import com.hazelcast.client.spi.impl.ClientInvocation;
    31| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    32| import com.hazelcast.client.util.ClientDelegatingFuture;
    33| import com.hazelcast.core.ICompletableFuture;
    34| import com.hazelcast.core.IFunction;
    35| import com.hazelcast.nio.serialization.Data;
    36| import com.hazelcast.partition.strategy.StringPartitioningStrategy;
    37| import com.hazelcast.ringbuffer.OverflowPolicy;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientScheduledExecutorProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.codec.ScheduledExecutorGetAllScheduledFuturesCodec;
    20| import com.hazelcast.client.impl.protocol.codec.ScheduledExecutorShutdownCodec;
    21| import com.hazelcast.client.impl.protocol.codec.ScheduledExecutorSubmitToAddressCodec;
    22| import com.hazelcast.client.impl.protocol.codec.ScheduledExecutorSubmitToPartitionCodec;
    23| import com.hazelcast.client.spi.ClientContext;
    24| import com.hazelcast.client.spi.impl.ClientInvocation;
    25| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    26| import com.hazelcast.client.util.ClientDelegatingFuture;
    27| import com.hazelcast.core.Member;
    28| import com.hazelcast.core.PartitionAware;
    29| import com.hazelcast.logging.ILogger;
    30| import com.hazelcast.logging.Logger;
    31| import com.hazelcast.nio.Address;
    32| import com.hazelcast.nio.serialization.Data;
    33| import com.hazelcast.quorum.QuorumException;
    34| import com.hazelcast.scheduledexecutor.IScheduledExecutorService;
    35| import com.hazelcast.scheduledexecutor.IScheduledFuture;
    36| import com.hazelcast.scheduledexecutor.NamedTask;
    37| import com.hazelcast.scheduledexecutor.ScheduledTaskHandler;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientSetProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 180-217 ---
   180|         return deregisterListener(registrationId);
   181|     }
   182|     private Collection<E> getAll() {
   183|         ClientMessage request = SetGetAllCodec.encodeRequest(name);
   184|         ClientMessage response = invokeOnPartition(request);
   185|         SetGetAllCodec.ResponseParameters resultParameters = SetGetAllCodec.decodeResponse(response);
   186|         List<Data> resultCollection = resultParameters.response;
   187|         return new UnmodifiableLazyList<E>(resultCollection, getSerializationService());
   188|     }
   189|     @Override
   190|     public String toString() {
   191|         return "ISet{" + "name='" + name + '\'' + '}';
   192|     }
   193|     private class ItemEventHandler extends ListAddListenerCodec.AbstractEventHandler
   194|             implements EventHandler<ClientMessage> {
   195|         private final ItemListener<E> listener;
   196|         public ItemEventHandler(ItemListener<E> listener) {
   197|             this.listener = listener;
   198|         }
   199|         @Override
   200|         public void handleItemEventV10(Data dataItem, String uuid, int eventType) {
   201|             Member member = getContext().getClusterService().getMember(uuid);
   202|             ItemEvent<E> itemEvent = new DataAwareItemEvent(name, ItemEventType.getByType(eventType),
   203|                     dataItem, member, getSerializationService());
   204|             if (eventType == ItemEventType.ADDED.getType()) {
   205|                 listener.itemAdded(itemEvent);
   206|             } else {
   207|                 listener.itemRemoved(itemEvent);
   208|             }
   209|         }
   210|         @Override
   211|         public void beforeListenerRegister() {
   212|         }
   213|         @Override
   214|         public void onListenerRegister() {
   215|         }
   216|     }
   217| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/ClientTopicProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 53-93 ---
    53|     }
    54|     @Override
    55|     public boolean removeMessageListener(String registrationId) {
    56|         return deregisterListener(registrationId);
    57|     }
    58|     @Override
    59|     public LocalTopicStats getLocalTopicStats() {
    60|         throw new UnsupportedOperationException("Locality is ambiguous for client!");
    61|     }
    62|     @Override
    63|     public String toString() {
    64|         return "ITopic{" + "name='" + name + '\'' + '}';
    65|     }
    66|     private final class TopicItemHandler extends TopicAddMessageListenerCodec.AbstractEventHandler
    67|             implements EventHandler<ClientMessage> {
    68|         private final MessageListener<E> listener;
    69|         private TopicItemHandler(MessageListener<E> listener) {
    70|             this.listener = listener;
    71|         }
    72|         @Override
    73|         public void handleTopicEventV10(Data item, long publishTime, String uuid) {
    74|             Member member = getContext().getClusterService().getMember(uuid);
    75|             Message message = new DataAwareMessage(name, item, publishTime, member, getSerializationService());
    76|             listener.onMessage(message);
    77|         }
    78|         @Override
    79|         public void beforeListenerRegister() {
    80|         }
    81|         @Override
    82|         public void onListenerRegister() {
    83|         }
    84|     }
    85|     private class Codec implements ListenerMessageCodec {
    86|         @Override
    87|         public ClientMessage encodeAddRequest(boolean localOnly) {
    88|             return TopicAddMessageListenerCodec.encodeRequest(name, localOnly);
    89|         }
    90|         @Override
    91|         public String decodeAddResponse(ClientMessage clientMessage) {
    92|             return TopicAddMessageListenerCodec.decodeResponse(clientMessage).response;
    93|         }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/IExecutorDelegatingFuture.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
    18| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    19| import com.hazelcast.client.impl.protocol.ClientMessage;
    20| import com.hazelcast.client.impl.protocol.codec.ExecutorServiceCancelOnAddressCodec;
    21| import com.hazelcast.client.impl.protocol.codec.ExecutorServiceCancelOnPartitionCodec;
    22| import com.hazelcast.client.spi.ClientContext;
    23| import com.hazelcast.client.spi.impl.ClientInvocation;
    24| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    25| import com.hazelcast.client.util.ClientDelegatingFuture;
    26| import com.hazelcast.core.ICompletableFuture;
    27| import com.hazelcast.nio.Address;
    28| import java.util.concurrent.CancellationException;
    29| import java.util.concurrent.ExecutionException;
    30| import static com.hazelcast.util.ExceptionUtil.rethrow;
    31| /**
    32|  * An Abstract DelegatingFuture that can cancel a Runnable/Callable that is executed by an
    33|  * {@link com.hazelcast.core.IExecutorService}.
    34|  * It does this by sending a Cancellation Request to the remote owning member and then cancelling the running task.
    35|  *
    36|  * @param <V> Type of returned object from the get method of this class.
    37|  */
    38| public final class IExecutorDelegatingFuture<V> extends ClientDelegatingFuture<V> {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/NearCachedClientMapProxy.java
# Total hunks: 6
# ====================================================================
# --- HUNK 1: Lines 99-147 ---
    99|     protected V getInternal(Object key) {
   100|         key = toNearCacheKey(key);
   101|         V value = (V) getCachedValue(key, true);
   102|         if (value != NOT_CACHED) {
   103|             return value;
   104|         }
   105|         try {
   106|             Data keyData = toData(key);
   107|             long reservationId = nearCache.tryReserveForUpdate(key, keyData);
   108|             value = (V) super.getInternal(keyData);
   109|             if (reservationId != NOT_RESERVED) {
   110|                 value = (V) tryPublishReserved(key, value, reservationId);
   111|             }
   112|             return value;
   113|         } catch (Throwable throwable) {
   114|             invalidateNearCache(key);
   115|             throw rethrow(throwable);
   116|         }
   117|     }
   118|     @Override
   119|     protected boolean setTtlInternal(Object key, long ttl, TimeUnit timeUnit) {
   120|         key = toNearCacheKey(key);
   121|         try {
   122|             return super.setTtlInternal(key, ttl, timeUnit);
   123|         } finally {
   124|             invalidateNearCache(key);
   125|         }
   126|     }
   127|     @Override
   128|     public ICompletableFuture<V> getAsyncInternal(Object keyParameter) {
   129|         final Object key = toNearCacheKey(keyParameter);
   130|         Object value = getCachedValue(key, false);
   131|         if (value != NOT_CACHED) {
   132|             ExecutorService executor = getContext().getExecutionService().getUserExecutor();
   133|             return new CompletedFuture<V>(getSerializationService(), value, executor);
   134|         }
   135|         Data keyData = toData(key);
   136|         final long reservationId = nearCache.tryReserveForUpdate(key, keyData);
   137|         ICompletableFuture<V> future;
   138|         try {
   139|             future = super.getAsyncInternal(keyData);
   140|         } catch (Throwable t) {
   141|             invalidateNearCache(key);
   142|             throw rethrow(t);
   143|         }
   144|         if (reservationId != NOT_RESERVED) {
   145|             ((ClientDelegatingFuture) future).andThenInternal(new ExecutionCallback<Object>() {
   146|                 @Override
   147|                 public void onResponse(Object value) {

# --- HUNK 2: Lines 178-334 ---
   178|         return removed;
   179|     }
   180|     @Override
   181|     protected void removeAllInternal(Predicate predicate) {
   182|         try {
   183|             super.removeAllInternal(predicate);
   184|         } finally {
   185|             nearCache.clear();
   186|         }
   187|     }
   188|     @Override
   189|     protected void deleteInternal(Object key) {
   190|         key = toNearCacheKey(key);
   191|         try {
   192|             super.deleteInternal(key);
   193|         } finally {
   194|             invalidateNearCache(key);
   195|         }
   196|     }
   197|     @Override
   198|     protected ICompletableFuture<V> putAsyncInternal(long ttl, TimeUnit timeunit, Long maxIdle, TimeUnit maxIdleUnit,
   199|                                                      Object key, Object value) {
   200|         key = toNearCacheKey(key);
   201|         ICompletableFuture<V> future;
   202|         try {
   203|             future = super.putAsyncInternal(ttl, timeunit, maxIdle, maxIdleUnit, key, value);
   204|         } finally {
   205|             invalidateNearCache(key);
   206|         }
   207|         return future;
   208|     }
   209|     @Override
   210|     protected ICompletableFuture<Void> setAsyncInternal(long ttl, TimeUnit timeunit, Long maxIdle, TimeUnit maxIdleUnit,
   211|                                                         Object key, Object value) {
   212|         key = toNearCacheKey(key);
   213|         ICompletableFuture<Void> future;
   214|         try {
   215|             future = super.setAsyncInternal(ttl, timeunit, maxIdle, maxIdleUnit, key, value);
   216|         } finally {
   217|             invalidateNearCache(key);
   218|         }
   219|         return future;
   220|     }
   221|     @Override
   222|     protected ICompletableFuture<V> removeAsyncInternal(Object key) {
   223|         key = toNearCacheKey(key);
   224|         ICompletableFuture<V> future;
   225|         try {
   226|             future = super.removeAsyncInternal(key);
   227|         } finally {
   228|             invalidateNearCache(key);
   229|         }
   230|         return future;
   231|     }
   232|     @Override
   233|     protected boolean tryRemoveInternal(long timeout, TimeUnit timeunit, Object key) {
   234|         key = toNearCacheKey(key);
   235|         boolean removed;
   236|         try {
   237|             removed = super.tryRemoveInternal(timeout, timeunit, key);
   238|         } finally {
   239|             invalidateNearCache(key);
   240|         }
   241|         return removed;
   242|     }
   243|     @Override
   244|     protected boolean tryPutInternal(long timeout, TimeUnit timeunit,
   245|                                      Object key, Object value) {
   246|         key = toNearCacheKey(key);
   247|         boolean putInternal;
   248|         try {
   249|             putInternal = super.tryPutInternal(timeout, timeunit, key, value);
   250|         } finally {
   251|             invalidateNearCache(key);
   252|         }
   253|         return putInternal;
   254|     }
   255|     @Override
   256|     protected V putInternal(long ttl, TimeUnit ttlUnit, Long maxIdle, TimeUnit maxIdleUnit, Object key, Object value) {
   257|         key = toNearCacheKey(key);
   258|         V previousValue;
   259|         try {
   260|             previousValue = super.putInternal(ttl, ttlUnit, maxIdle, maxIdleUnit, key, value);
   261|         } finally {
   262|             invalidateNearCache(key);
   263|         }
   264|         return previousValue;
   265|     }
   266|     @Override
   267|     protected void putTransientInternal(long ttl, TimeUnit timeunit, Long maxIdle, TimeUnit maxIdleUnit,
   268|                                         Object key, Object value) {
   269|         key = toNearCacheKey(key);
   270|         try {
   271|             super.putTransientInternal(ttl, timeunit, maxIdle, maxIdleUnit, key, value);
   272|         } finally {
   273|             invalidateNearCache(key);
   274|         }
   275|     }
   276|     @Override
   277|     protected V putIfAbsentInternal(long ttl, TimeUnit timeunit, Long maxIdle, TimeUnit maxIdleUnit,
   278|                                     Object key, Object value) {
   279|         key = toNearCacheKey(key);
   280|         V previousValue;
   281|         try {
   282|             previousValue = super.putIfAbsentInternal(ttl, timeunit, maxIdle, maxIdleUnit, key, value);
   283|         } finally {
   284|             invalidateNearCache(key);
   285|         }
   286|         return previousValue;
   287|     }
   288|     @Override
   289|     protected boolean replaceIfSameInternal(Object key, Object oldValue, Object newValue) {
   290|         key = toNearCacheKey(key);
   291|         boolean replaceIfSame;
   292|         try {
   293|             replaceIfSame = super.replaceIfSameInternal(key, oldValue, newValue);
   294|         } finally {
   295|             invalidateNearCache(key);
   296|         }
   297|         return replaceIfSame;
   298|     }
   299|     @Override
   300|     protected V replaceInternal(Object key, Object value) {
   301|         key = toNearCacheKey(key);
   302|         V v;
   303|         try {
   304|             v = super.replaceInternal(key, value);
   305|         } finally {
   306|             invalidateNearCache(key);
   307|         }
   308|         return v;
   309|     }
   310|     @Override
   311|     protected void setInternal(long ttl, TimeUnit timeunit, Long maxIdle, TimeUnit maxIdleUnit, Object key, Object value) {
   312|         key = toNearCacheKey(key);
   313|         try {
   314|             super.setInternal(ttl, timeunit, maxIdle, maxIdleUnit, key, value);
   315|         } finally {
   316|             invalidateNearCache(key);
   317|         }
   318|     }
   319|     @Override
   320|     protected boolean evictInternal(Object key) {
   321|         key = toNearCacheKey(key);
   322|         boolean evicted;
   323|         try {
   324|             evicted = super.evictInternal(key);
   325|         } finally {
   326|             invalidateNearCache(key);
   327|         }
   328|         return evicted;
   329|     }
   330|     @Override
   331|     public void evictAll() {
   332|         try {
   333|             super.evictAll();
   334|         } finally {

# --- HUNK 3: Lines 519-650 ---
   519|     }
   520|     private Object tryPublishReserved(Object key, Object value, long reservationId) {
   521|         assert value != NOT_CACHED;
   522|         Object cachedValue = nearCache.tryPublishReserved(key, value, reservationId, true);
   523|         return cachedValue != null ? cachedValue : value;
   524|     }
   525|     private Object getCachedValue(Object key, boolean deserializeValue) {
   526|         Object value = nearCache.get(key);
   527|         if (value == null) {
   528|             return NOT_CACHED;
   529|         }
   530|         if (value == CACHED_AS_NULL) {
   531|             return null;
   532|         }
   533|         return deserializeValue ? toObject(value) : value;
   534|     }
   535|     public NearCache<Object, Object> getNearCache() {
   536|         return nearCache;
   537|     }
   538|     private void invalidateNearCache(Object key) {
   539|         nearCache.invalidate(key);
   540|     }
   541|     public String addNearCacheInvalidationListener(EventHandler handler) {
   542|         return registerListener(createNearCacheEntryListenerCodec(), handler);
   543|     }
   544|     private void registerInvalidationListener() {
   545|         try {
   546|             invalidationListenerId = addNearCacheInvalidationListener(new NearCacheInvalidationEventHandler());
   547|         } catch (Exception e) {
   548|             ILogger logger = getContext().getLoggingService().getLogger(getClass());
   549|             logger.severe("-----------------\nNear Cache is not initialized!\n-----------------", e);
   550|         }
   551|     }
   552|     @SuppressWarnings("checkstyle:anoninnerlength")
   553|     private ListenerMessageCodec createNearCacheEntryListenerCodec() {
   554|         return new ListenerMessageCodec() {
   555|             @Override
   556|             public ClientMessage encodeAddRequest(boolean localOnly) {
   557|                 if (supportsRepairableNearCache()) {
   558|                     return MapAddNearCacheInvalidationListenerCodec.encodeRequest(name, INVALIDATION.getType(), localOnly);
   559|                 }
   560|                 return MapAddNearCacheEntryListenerCodec.encodeRequest(name, INVALIDATION.getType(), localOnly);
   561|             }
   562|             @Override
   563|             public String decodeAddResponse(ClientMessage clientMessage) {
   564|                 if (supportsRepairableNearCache()) {
   565|                     return MapAddNearCacheInvalidationListenerCodec.decodeResponse(clientMessage).response;
   566|                 }
   567|                 return MapAddNearCacheEntryListenerCodec.decodeResponse(clientMessage).response;
   568|             }
   569|             @Override
   570|             public ClientMessage encodeRemoveRequest(String realRegistrationId) {
   571|                 return MapRemoveEntryListenerCodec.encodeRequest(name, realRegistrationId);
   572|             }
   573|             @Override
   574|             public boolean decodeRemoveResponse(ClientMessage clientMessage) {
   575|                 return MapRemoveEntryListenerCodec.decodeResponse(clientMessage).response;
   576|             }
   577|         };
   578|     }
   579|     private void removeNearCacheInvalidationListener() {
   580|         String invalidationListenerId = this.invalidationListenerId;
   581|         if (invalidationListenerId == null) {
   582|             return;
   583|         }
   584|         getContext().getRepairingTask(getServiceName()).deregisterHandler(name);
   585|         deregisterListener(invalidationListenerId);
   586|     }
   587|     private boolean supportsRepairableNearCache() {
   588|         return getConnectedServerVersion() >= minConsistentNearCacheSupportingServerVersion;
   589|     }
   590|     /**
   591|      * Eventual consistency for Near Cache can be used with server versions >= 3.8
   592|      * For repairing functionality please see {@link RepairingHandler}
   593|      * handleCacheInvalidationEventV14 and handleCacheBatchInvalidationEventV14
   594|      *
   595|      * If server version is < 3.8 and client version is >= 3.8, eventual consistency is not supported
   596|      * Following methods handle the old behaviour:
   597|      * handleCacheBatchInvalidationEventV10 and handleCacheInvalidationEventV10
   598|      */
   599|     private final class NearCacheInvalidationEventHandler
   600|             extends MapAddNearCacheInvalidationListenerCodec.AbstractEventHandler
   601|             implements EventHandler<ClientMessage> {
   602|         private volatile RepairingHandler repairingHandler;
   603|         private volatile boolean supportsRepairableNearCache;
   604|         @Override
   605|         public void beforeListenerRegister() {
   606|             supportsRepairableNearCache = supportsRepairableNearCache();
   607|             if (supportsRepairableNearCache) {
   608|                 RepairingTask repairingTask = getContext().getRepairingTask(getServiceName());
   609|                 repairingHandler = repairingTask.registerAndGetHandler(name, nearCache);
   610|             } else {
   611|                 nearCache.clear();
   612|                 RepairingTask repairingTask = getContext().getRepairingTask(getServiceName());
   613|                 repairingTask.deregisterHandler(name);
   614|                 logger.warning(format("Near Cache for '%s' map is started in legacy mode", name));
   615|             }
   616|         }
   617|         @Override
   618|         public void onListenerRegister() {
   619|             if (!supportsRepairableNearCache) {
   620|                 nearCache.clear();
   621|             }
   622|         }
   623|         @Override
   624|         public void handleIMapInvalidationEventV10(Data key) {
   625|             if (key != null) {
   626|                 nearCache.invalidate(serializeKeys ? key : toObject(key));
   627|             } else {
   628|                 nearCache.clear();
   629|             }
   630|         }
   631|         @Override
   632|         public void handleIMapBatchInvalidationEventV10(Collection<Data> keys) {
   633|             for (Data key : keys) {
   634|                 nearCache.invalidate(serializeKeys ? key : toObject(key));
   635|             }
   636|         }
   637|         @Override
   638|         public void handleIMapInvalidationEventV14(Data key, String sourceUuid,
   639|                                                    UUID partitionUuid, long sequence) {
   640|             repairingHandler.handle(key, sourceUuid, partitionUuid, sequence);
   641|         }
   642|         @Override
   643|         public void handleIMapBatchInvalidationEventV14(Collection<Data> keys,
   644|                                                         Collection<String> sourceUuids,
   645|                                                         Collection<UUID> partitionUuids,
   646|                                                         Collection<Long> sequences) {
   647|             repairingHandler.handle(keys, sourceUuids, partitionUuids, sequences);
   648|         }
   649|     }
   650| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/PartitionServiceProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 105-135 ---
   105|     }
   106|     @Override
   107|     public boolean isMemberSafe(Member member) {
   108|         throw new UnsupportedOperationException();
   109|     }
   110|     @Override
   111|     public boolean isLocalMemberSafe() {
   112|         throw new UnsupportedOperationException();
   113|     }
   114|     @Override
   115|     public boolean forceLocalMemberToBeSafe(long timeout, TimeUnit unit) {
   116|         throw new UnsupportedOperationException();
   117|     }
   118|     private static class ClientPartitionLostEventHandler extends ClientAddPartitionLostListenerCodec.AbstractEventHandler
   119|             implements EventHandler<ClientMessage> {
   120|         private PartitionLostListener listener;
   121|         public ClientPartitionLostEventHandler(PartitionLostListener listener) {
   122|             this.listener = listener;
   123|         }
   124|         @Override
   125|         public void handlePartitionLostEventV10(int partitionId, int lostBackupCount, Address source) {
   126|             listener.partitionLost(new PartitionLostEvent(partitionId, lostBackupCount, source));
   127|         }
   128|         @Override
   129|         public void beforeListenerRegister() {
   130|         }
   131|         @Override
   132|         public void onListenerRegister() {
   133|         }
   134|     }
   135| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/PartitionSpecificClientProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy;
    17| import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.spi.ClientContext;
    20| import com.hazelcast.client.spi.ClientProxy;
    21| import com.hazelcast.client.spi.impl.ClientInvocation;
    22| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    23| import com.hazelcast.client.util.ClientDelegatingFuture;
    24| import com.hazelcast.partition.strategy.StringPartitioningStrategy;
    25| import com.hazelcast.util.ExceptionUtil;
    26| import java.util.concurrent.Future;
    27| import static com.hazelcast.util.ExceptionUtil.rethrow;
    28| /**
    29|  * Base class for proxies of distributed objects that lives in on partition.
    30|  */
    31| abstract class PartitionSpecificClientProxy extends ClientProxy {
    32|     private int partitionId;
    33|     protected PartitionSpecificClientProxy(String serviceName, String objectName, ClientContext context) {
    34|         super(serviceName, objectName, context);
    35|     }
    36|     @Override
    37|     protected void onInitialize() {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/txn/ClientTransactionUtil.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy.txn;
    17| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.spi.impl.ClientInvocation;
    20| import com.hazelcast.nio.Connection;
    21| import com.hazelcast.transaction.TransactionException;
    22| import com.hazelcast.util.ExceptionUtil.RuntimeExceptionFactory;
    23| import java.util.concurrent.Future;
    24| import static com.hazelcast.util.ExceptionUtil.rethrow;
    25| /**
    26|  * Contains static method that is used from client transaction classes.
    27|  */
    28| public final class ClientTransactionUtil {
    29|     private static final RuntimeExceptionFactory TRANSACTION_EXCEPTION_FACTORY =
    30|             new RuntimeExceptionFactory() {
    31|                 @Override
    32|                 public RuntimeException create(Throwable throwable, String message) {
    33|                     return new TransactionException(message, throwable);
    34|                 }
    35|             };
    36|     private ClientTransactionUtil() {
    37|     }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/txn/ClientTxnProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy.txn;
    17| import com.hazelcast.client.connection.nio.ClientConnection;
    18| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    19| import com.hazelcast.client.impl.protocol.ClientMessage;
    20| import com.hazelcast.client.impl.protocol.codec.ClientDestroyProxyCodec;
    21| import com.hazelcast.client.spi.ClientTransactionContext;
    22| import com.hazelcast.nio.serialization.Data;
    23| import com.hazelcast.partition.strategy.StringPartitioningStrategy;
    24| import com.hazelcast.spi.serialization.SerializationService;
    25| import com.hazelcast.transaction.TransactionalObject;
    26| abstract class ClientTxnProxy implements TransactionalObject {
    27|     final String name;
    28|     final ClientTransactionContext transactionContext;
    29|     ClientTxnProxy(String name, ClientTransactionContext transactionContext) {
    30|         this.name = name;
    31|         this.transactionContext = transactionContext;
    32|     }
    33|     @Override
    34|     public String getName() {
    35|         return name;
    36|     }
    37|     @Override
    38|     public String getPartitionKey() {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/txn/TransactionContextProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy.txn;
    17| import com.hazelcast.client.connection.nio.ClientConnection;
    18| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    19| import com.hazelcast.client.spi.ClientTransactionContext;
    20| import com.hazelcast.client.spi.impl.ClientTransactionManagerServiceImpl;
    21| import com.hazelcast.collection.impl.list.ListService;
    22| import com.hazelcast.collection.impl.queue.QueueService;
    23| import com.hazelcast.collection.impl.set.SetService;
    24| import com.hazelcast.core.TransactionalList;
    25| import com.hazelcast.core.TransactionalMap;
    26| import com.hazelcast.core.TransactionalMultiMap;
    27| import com.hazelcast.core.TransactionalQueue;
    28| import com.hazelcast.core.TransactionalSet;
    29| import com.hazelcast.map.impl.MapService;
    30| import com.hazelcast.multimap.impl.MultiMapService;
    31| import com.hazelcast.transaction.TransactionException;
    32| import com.hazelcast.transaction.TransactionNotActiveException;
    33| import com.hazelcast.transaction.TransactionOptions;
    34| import com.hazelcast.transaction.TransactionalObject;
    35| import com.hazelcast.transaction.impl.Transaction;
    36| import com.hazelcast.transaction.impl.TransactionalObjectKey;
    37| import javax.transaction.xa.XAResource;
    38| import java.util.HashMap;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/txn/TransactionProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy.txn;
    17| import com.hazelcast.client.connection.nio.ClientConnection;
    18| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    19| import com.hazelcast.client.impl.protocol.ClientMessage;
    20| import com.hazelcast.client.impl.protocol.codec.TransactionCommitCodec;
    21| import com.hazelcast.client.impl.protocol.codec.TransactionCreateCodec;
    22| import com.hazelcast.client.impl.protocol.codec.TransactionRollbackCodec;
    23| import com.hazelcast.logging.ILogger;
    24| import com.hazelcast.transaction.TransactionException;
    25| import com.hazelcast.transaction.TransactionNotActiveException;
    26| import com.hazelcast.transaction.TransactionOptions;
    27| import com.hazelcast.util.Clock;
    28| import com.hazelcast.util.ThreadUtil;
    29| import static com.hazelcast.transaction.impl.Transaction.State;
    30| import static com.hazelcast.transaction.impl.Transaction.State.ACTIVE;
    31| import static com.hazelcast.transaction.impl.Transaction.State.COMMITTED;
    32| import static com.hazelcast.transaction.impl.Transaction.State.COMMITTING;
    33| import static com.hazelcast.transaction.impl.Transaction.State.COMMIT_FAILED;
    34| import static com.hazelcast.transaction.impl.Transaction.State.NO_TXN;
    35| import static com.hazelcast.transaction.impl.Transaction.State.ROLLED_BACK;
    36| import static com.hazelcast.transaction.impl.Transaction.State.ROLLING_BACK;
    37| import static com.hazelcast.util.ExceptionUtil.rethrow;
    38| final class TransactionProxy {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/txn/xa/XATransactionContextProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy.txn.xa;
    17| import com.hazelcast.client.connection.nio.ClientConnection;
    18| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    19| import com.hazelcast.client.proxy.txn.ClientTxnListProxy;
    20| import com.hazelcast.client.proxy.txn.ClientTxnMapProxy;
    21| import com.hazelcast.client.proxy.txn.ClientTxnMultiMapProxy;
    22| import com.hazelcast.client.proxy.txn.ClientTxnQueueProxy;
    23| import com.hazelcast.client.proxy.txn.ClientTxnSetProxy;
    24| import com.hazelcast.client.spi.ClientTransactionContext;
    25| import com.hazelcast.client.spi.impl.ClientTransactionManagerServiceImpl;
    26| import com.hazelcast.collection.impl.list.ListService;
    27| import com.hazelcast.collection.impl.queue.QueueService;
    28| import com.hazelcast.collection.impl.set.SetService;
    29| import com.hazelcast.core.HazelcastException;
    30| import com.hazelcast.core.TransactionalList;
    31| import com.hazelcast.core.TransactionalMap;
    32| import com.hazelcast.core.TransactionalMultiMap;
    33| import com.hazelcast.core.TransactionalQueue;
    34| import com.hazelcast.core.TransactionalSet;
    35| import com.hazelcast.map.impl.MapService;
    36| import com.hazelcast.multimap.impl.MultiMapService;
    37| import com.hazelcast.transaction.TransactionException;
    38| import com.hazelcast.transaction.TransactionNotActiveException;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/proxy/txn/xa/XATransactionProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.proxy.txn.xa;
    17| import com.hazelcast.client.connection.nio.ClientConnection;
    18| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    19| import com.hazelcast.client.impl.protocol.ClientMessage;
    20| import com.hazelcast.client.impl.protocol.codec.XATransactionCommitCodec;
    21| import com.hazelcast.client.impl.protocol.codec.XATransactionCreateCodec;
    22| import com.hazelcast.client.impl.protocol.codec.XATransactionPrepareCodec;
    23| import com.hazelcast.client.impl.protocol.codec.XATransactionRollbackCodec;
    24| import com.hazelcast.client.proxy.txn.ClientTransactionUtil;
    25| import com.hazelcast.logging.ILogger;
    26| import com.hazelcast.transaction.TransactionException;
    27| import com.hazelcast.transaction.TransactionNotActiveException;
    28| import com.hazelcast.transaction.impl.Transaction;
    29| import com.hazelcast.transaction.impl.xa.SerializableXID;
    30| import com.hazelcast.util.Clock;
    31| import javax.transaction.xa.XAException;
    32| import javax.transaction.xa.Xid;
    33| import java.util.concurrent.TimeUnit;
    34| import static com.hazelcast.transaction.impl.Transaction.State.ACTIVE;
    35| import static com.hazelcast.transaction.impl.Transaction.State.COMMITTED;
    36| import static com.hazelcast.transaction.impl.Transaction.State.COMMITTING;
    37| import static com.hazelcast.transaction.impl.Transaction.State.COMMIT_FAILED;
    38| import static com.hazelcast.transaction.impl.Transaction.State.NO_TXN;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/ClientContext.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-47 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi;
    17| import com.hazelcast.cache.impl.CacheService;
    18| import com.hazelcast.client.cache.impl.nearcache.invalidation.ClientCacheInvalidationMetaDataFetcher;
    19| import com.hazelcast.client.config.ClientConfig;
    20| import com.hazelcast.client.connection.ClientConnectionManager;
    21| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    22| import com.hazelcast.client.impl.querycache.ClientQueryCacheContext;
    23| import com.hazelcast.client.map.impl.nearcache.invalidation.ClientMapInvalidationMetaDataFetcher;
    24| import com.hazelcast.core.HazelcastInstance;
    25| import com.hazelcast.core.LifecycleService;
    26| import com.hazelcast.internal.nearcache.NearCacheManager;
    27| import com.hazelcast.internal.nearcache.impl.invalidation.InvalidationMetaDataFetcher;
    28| import com.hazelcast.internal.nearcache.impl.invalidation.MinimalPartitionService;
    29| import com.hazelcast.internal.nearcache.impl.invalidation.RepairingTask;
    30| import com.hazelcast.logging.ILogger;
    31| import com.hazelcast.logging.LoggingService;
    32| import com.hazelcast.map.impl.MapService;
    33| import com.hazelcast.nio.serialization.Data;
    34| import com.hazelcast.spi.properties.HazelcastProperties;
    35| import com.hazelcast.spi.serialization.SerializationService;
    36| import com.hazelcast.util.ConstructorFunction;
    37| import java.util.concurrent.ConcurrentHashMap;
    38| import java.util.concurrent.ConcurrentMap;
    39| import static com.hazelcast.util.ConcurrencyUtil.getOrPutIfAbsent;
    40| import static java.lang.String.format;
    41| /**
    42|  * Context holding all the required services, managers and the configuration for a Hazelcast client.
    43|  */
    44| public final class ClientContext {
    45|     private String localUuid;
    46|     private final SerializationService serializationService;
    47|     private final ClientClusterService clusterService;

# --- HUNK 2: Lines 84-135 ---
    84|         this.loggingService = client.getLoggingService();
    85|         this.nearCacheManager = client.getNearCacheManager();
    86|         this.properties = client.getProperties();
    87|         this.localUuid = client.getLocalEndpoint().getUuid();
    88|         this.minimalPartitionService = new ClientMinimalPartitionService();
    89|         this.queryCacheContext = new ClientQueryCacheContext(this);
    90|     }
    91|     public ClientQueryCacheContext getQueryCacheContext() {
    92|         return queryCacheContext;
    93|     }
    94|     public RepairingTask getRepairingTask(String serviceName) {
    95|         return getOrPutIfAbsent(repairingTasks, serviceName, repairingTaskConstructor);
    96|     }
    97|     private String getLocalUuid() {
    98|         if (this.localUuid == null) {
    99|             this.localUuid = clusterService.getLocalClient().getUuid();
   100|         }
   101|         return this.localUuid;
   102|     }
   103|     private RepairingTask newRepairingTask(String serviceName) {
   104|         InvalidationMetaDataFetcher invalidationMetaDataFetcher = newMetaDataFetcher(serviceName);
   105|         ILogger logger = loggingService.getLogger(RepairingTask.class);
   106|         return new RepairingTask(properties, invalidationMetaDataFetcher,
   107|                 executionService, serializationService, minimalPartitionService,
   108|                 getLocalUuid(), logger);
   109|     }
   110|     private InvalidationMetaDataFetcher newMetaDataFetcher(String serviceName) {
   111|         if (MapService.SERVICE_NAME.equals(serviceName)) {
   112|             return new ClientMapInvalidationMetaDataFetcher(this);
   113|         }
   114|         if (CacheService.SERVICE_NAME.equals(serviceName)) {
   115|             return new ClientCacheInvalidationMetaDataFetcher(this);
   116|         }
   117|         throw new IllegalArgumentException(format("%s is not a known service-name to fetch metadata for", serviceName));
   118|     }
   119|     public String getName() {
   120|         return name;
   121|     }
   122|     /**
   123|      * Client side implementation of {@link MinimalPartitionService}
   124|      */
   125|     private class ClientMinimalPartitionService implements MinimalPartitionService {
   126|         @Override
   127|         public int getPartitionId(Data key) {
   128|             return partitionService.getPartitionId(key);
   129|         }
   130|         @Override
   131|         public int getPartitionId(Object key) {
   132|             return partitionService.getPartitionId(key);
   133|         }
   134|         @Override
   135|         public int getPartitionCount() {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/ClientProxy.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi;
    17| import com.hazelcast.client.connection.ClientConnectionManager;
    18| import com.hazelcast.client.connection.nio.ClientConnection;
    19| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    20| import com.hazelcast.client.impl.protocol.ClientMessage;
    21| import com.hazelcast.client.impl.protocol.codec.ClientDestroyProxyCodec;
    22| import com.hazelcast.client.spi.impl.ClientInvocation;
    23| import com.hazelcast.client.spi.impl.ListenerMessageCodec;
    24| import com.hazelcast.core.DistributedObject;
    25| import com.hazelcast.nio.Address;
    26| import com.hazelcast.nio.serialization.Data;
    27| import com.hazelcast.partition.strategy.StringPartitioningStrategy;
    28| import com.hazelcast.spi.serialization.SerializationService;
    29| import com.hazelcast.util.ExceptionUtil;
    30| import java.util.Collection;
    31| import java.util.concurrent.Future;
    32| import static com.hazelcast.instance.BuildInfo.UNKNOWN_HAZELCAST_VERSION;
    33| import static com.hazelcast.util.ExceptionUtil.rethrow;
    34| /**
    35|  * Base class for client proxies.
    36|  * <p>
    37|  * Allows the client to proxy operations through member nodes.
    38|  */
    39| public abstract class ClientProxy implements DistributedObject {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/ClientTransactionContext.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi;
    17| import com.hazelcast.client.connection.nio.ClientConnection;
    18| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    19| import com.hazelcast.transaction.TransactionContext;
    20| /**
    21|  * Provides a context to perform transactional operations: beginning/committing transactions, but also retrieving
    22|  * transactional data-structures like the {@link com.hazelcast.core.TransactionalMap}.
    23|  *
    24|  * Provides client instance and client connection proxies that need to be accessed for sending invocations.
    25|  */
    26| public interface ClientTransactionContext extends TransactionContext {
    27|     HazelcastClientInstanceImpl getClient();
    28|     ClientConnection getConnection();
    29| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/ProxyManager.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 6-46 ---
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi;
    17| import com.hazelcast.cache.impl.ICacheService;
    18| import com.hazelcast.cache.impl.JCacheDetector;
    19| import com.hazelcast.cardinality.impl.CardinalityEstimatorService;
    20| import com.hazelcast.client.ClientExtension;
    21| import com.hazelcast.client.HazelcastClientOfflineException;
    22| import com.hazelcast.client.LoadBalancer;
    23| import com.hazelcast.client.cache.impl.ClientCacheProxyFactory;
    24| import com.hazelcast.client.config.ClientConfig;
    25| import com.hazelcast.client.config.ProxyFactoryConfig;
    26| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    27| import com.hazelcast.client.impl.protocol.ClientMessage;
    28| import com.hazelcast.client.impl.protocol.codec.ClientAddDistributedObjectListenerCodec;
    29| import com.hazelcast.client.impl.protocol.codec.ClientCreateProxiesCodec;
    30| import com.hazelcast.client.impl.protocol.codec.ClientCreateProxyCodec;
    31| import com.hazelcast.client.impl.protocol.codec.ClientRemoveDistributedObjectListenerCodec;
    32| import com.hazelcast.client.proxy.ClientAtomicLongProxy;
    33| import com.hazelcast.client.proxy.ClientAtomicReferenceProxy;
    34| import com.hazelcast.client.proxy.ClientCardinalityEstimatorProxy;
    35| import com.hazelcast.client.proxy.ClientCountDownLatchProxy;
    36| import com.hazelcast.client.proxy.ClientDurableExecutorServiceProxy;
    37| import com.hazelcast.client.proxy.ClientExecutorServiceProxy;
    38| import com.hazelcast.client.proxy.ClientFlakeIdGeneratorProxy;
    39| import com.hazelcast.client.proxy.ClientIdGeneratorProxy;
    40| import com.hazelcast.client.proxy.ClientListProxy;
    41| import com.hazelcast.client.proxy.ClientLockProxy;
    42| import com.hazelcast.client.proxy.ClientMapReduceProxy;
    43| import com.hazelcast.client.proxy.ClientMultiMapProxy;
    44| import com.hazelcast.client.proxy.ClientPNCounterProxy;
    45| import com.hazelcast.client.proxy.ClientQueueProxy;
    46| import com.hazelcast.client.proxy.ClientReliableTopicProxy;

# --- HUNK 2: Lines 94-135 ---
    94| import com.hazelcast.topic.impl.reliable.ReliableTopicService;
    95| import com.hazelcast.transaction.impl.xa.XAService;
    96| import java.io.IOException;
    97| import java.lang.reflect.Constructor;
    98| import java.util.AbstractMap;
    99| import java.util.Collection;
   100| import java.util.Iterator;
   101| import java.util.LinkedList;
   102| import java.util.List;
   103| import java.util.Map;
   104| import java.util.concurrent.ConcurrentHashMap;
   105| import java.util.concurrent.ConcurrentMap;
   106| import java.util.concurrent.ExecutionException;
   107| import static com.hazelcast.util.ExceptionUtil.rethrow;
   108| import static com.hazelcast.util.ServiceLoader.classIterator;
   109| import static java.lang.Thread.currentThread;
   110| /**
   111|  * The ProxyManager handles client proxy instantiation and retrieval at start and runtime by registering
   112|  * corresponding service manager names and their {@link com.hazelcast.client.spi.ClientProxyFactory}s.
   113|  */
   114| @SuppressWarnings({"checkstyle:classfanoutcomplexity",
   115|         "checkstyle:classdataabstractioncoupling", "checkstyle:methodcount"})
   116| public final class ProxyManager {
   117|     private static final String PROVIDER_ID = ClientProxyDescriptorProvider.class.getCanonicalName();
   118|     private static final Class[] LEGACY_CONSTRUCTOR_ARGUMENT_TYPES = new Class[]{String.class, String.class};
   119|     private static final Class[] CONSTRUCTOR_ARGUMENT_TYPES = new Class[]{String.class, String.class, ClientContext.class};
   120|     private final ConcurrentMap<String, ClientProxyFactory> proxyFactories = new ConcurrentHashMap<String, ClientProxyFactory>();
   121|     private final ConcurrentMap<ObjectNamespace, ClientProxyFuture> proxies
   122|             = new ConcurrentHashMap<ObjectNamespace, ClientProxyFuture>();
   123|     private final ListenerMessageCodec distributedObjectListenerCodec = new ListenerMessageCodec() {
   124|         @Override
   125|         public ClientMessage encodeAddRequest(boolean localOnly) {
   126|             return ClientAddDistributedObjectListenerCodec.encodeRequest(localOnly);
   127|         }
   128|         @Override
   129|         public String decodeAddResponse(ClientMessage clientMessage) {
   130|             return ClientAddDistributedObjectListenerCodec.decodeResponse(clientMessage).response;
   131|         }
   132|         @Override
   133|         public ClientMessage encodeRemoveRequest(String realRegistrationId) {
   134|             return ClientRemoveDistributedObjectListenerCodec.encodeRequest(realRegistrationId);
   135|         }

# --- HUNK 3: Lines 435-475 ---
   435|         }
   436|         ClientMessage clientMessage = ClientCreateProxiesCodec.encodeRequest(proxyEntries);
   437|         new ClientInvocation(client, clientMessage, null, ownerConnection).invokeUrgent();
   438|         createCachesOnCluster();
   439|     }
   440|     private void createCachesOnCluster() {
   441|         ClientCacheProxyFactory proxyFactory = (ClientCacheProxyFactory) getClientProxyFactory(ICacheService.SERVICE_NAME);
   442|         if (proxyFactory != null) {
   443|             proxyFactory.recreateCachesOnCluster();
   444|         }
   445|     }
   446|     private final class DistributedObjectEventHandler extends ClientAddDistributedObjectListenerCodec.AbstractEventHandler
   447|             implements EventHandler<ClientMessage> {
   448|         private final DistributedObjectListener listener;
   449|         private ProxyManager proxyManager;
   450|         private DistributedObjectEventHandler(DistributedObjectListener listener, ProxyManager proxyManager) {
   451|             this.listener = listener;
   452|             this.proxyManager = proxyManager;
   453|         }
   454|         @Override
   455|         public void handleDistributedObjectEventV10(String name, String serviceName, String eventTypeName) {
   456|             final ObjectNamespace ns = new DistributedObjectNamespace(serviceName, name);
   457|             ClientProxyFuture future = proxies.get(ns);
   458|             ClientProxy proxy = future == null ? null : future.get();
   459|             DistributedObjectEvent.EventType eventType = DistributedObjectEvent.EventType.valueOf(eventTypeName);
   460|             LazyDistributedObjectEvent event = new LazyDistributedObjectEvent(eventType, serviceName, name, proxy,
   461|                     proxyManager);
   462|             if (DistributedObjectEvent.EventType.CREATED.equals(eventType)) {
   463|                 listener.distributedObjectCreated(event);
   464|             } else if (DistributedObjectEvent.EventType.DESTROYED.equals(eventType)) {
   465|                 listener.distributedObjectDestroyed(event);
   466|             }
   467|         }
   468|         @Override
   469|         public void beforeListenerRegister() {
   470|         }
   471|         @Override
   472|         public void onListenerRegister() {
   473|         }
   474|     }
   475|     public boolean removeDistributedObjectListener(String id) {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/AbstractClientInvocationService.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-189 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl;
    17| import com.hazelcast.client.HazelcastClientNotActiveException;
    18| import com.hazelcast.client.connection.ClientConnectionManager;
    19| import com.hazelcast.client.connection.nio.ClientConnection;
    20| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    21| import com.hazelcast.client.impl.protocol.ClientMessage;
    22| import com.hazelcast.client.spi.ClientExecutionService;
    23| import com.hazelcast.client.spi.ClientInvocationService;
    24| import com.hazelcast.client.spi.ClientPartitionService;
    25| import com.hazelcast.client.spi.EventHandler;
    26| import com.hazelcast.client.spi.impl.listener.AbstractClientListenerService;
    27| import com.hazelcast.internal.metrics.Probe;
    28| import com.hazelcast.logging.ILogger;
    29| import com.hazelcast.spi.exception.TargetDisconnectedException;
    30| import com.hazelcast.spi.impl.sequence.CallIdFactory;
    31| import com.hazelcast.spi.impl.sequence.CallIdSequence;
    32| import com.hazelcast.spi.properties.HazelcastProperties;
    33| import com.hazelcast.spi.properties.HazelcastProperty;
    34| import java.io.IOException;
    35| import java.util.Iterator;
    36| import java.util.Map;
    37| import java.util.concurrent.ConcurrentHashMap;
    38| import java.util.concurrent.ConcurrentMap;
    39| import static com.hazelcast.client.spi.properties.ClientProperty.BACKPRESSURE_BACKOFF_TIMEOUT_MILLIS;
    40| import static com.hazelcast.client.spi.properties.ClientProperty.INVOCATION_RETRY_PAUSE_MILLIS;
    41| import static com.hazelcast.client.spi.properties.ClientProperty.INVOCATION_TIMEOUT_SECONDS;
    42| import static com.hazelcast.client.spi.properties.ClientProperty.MAX_CONCURRENT_INVOCATIONS;
    43| import static com.hazelcast.internal.metrics.ProbeLevel.MANDATORY;
    44| import static java.util.concurrent.TimeUnit.MILLISECONDS;
    45| public abstract class AbstractClientInvocationService implements ClientInvocationService {
    46|     private static final HazelcastProperty CLEAN_RESOURCES_MILLIS
    47|             = new HazelcastProperty("hazelcast.client.internal.clean.resources.millis", 100, MILLISECONDS);
    48|     protected final HazelcastClientInstanceImpl client;
    49|     protected ClientConnectionManager connectionManager;
    50|     protected ClientPartitionService partitionService;
    51|     final ILogger invocationLogger;
    52|     private AbstractClientListenerService clientListenerService;
    53|     @Probe(name = "pendingCalls", level = MANDATORY)
    54|     private ConcurrentMap<Long, ClientInvocation> invocations = new ConcurrentHashMap<Long, ClientInvocation>();
    55|     private ClientResponseHandlerSupplier responseHandlerSupplier;
    56|     private volatile boolean isShutdown;
    57|     private final long invocationTimeoutMillis;
    58|     private final long invocationRetryPauseMillis;
    59|     private final CallIdSequence callIdSequence;
    60|     public AbstractClientInvocationService(HazelcastClientInstanceImpl client) {
    61|         this.client = client;
    62|         this.invocationLogger = client.getLoggingService().getLogger(ClientInvocationService.class);
    63|         this.invocationTimeoutMillis = initInvocationTimeoutMillis();
    64|         this.invocationRetryPauseMillis = initInvocationRetryPauseMillis();
    65|         this.responseHandlerSupplier = new ClientResponseHandlerSupplier(this);
    66|         HazelcastProperties properties = client.getProperties();
    67|         int maxAllowedConcurrentInvocations = properties.getInteger(MAX_CONCURRENT_INVOCATIONS);
    68|         long backofftimeoutMs = properties.getLong(BACKPRESSURE_BACKOFF_TIMEOUT_MILLIS);
    69|         boolean isBackPressureEnabled = maxAllowedConcurrentInvocations != Integer.MAX_VALUE;
    70|         callIdSequence = CallIdFactory
    71|                 .newCallIdSequence(isBackPressureEnabled, maxAllowedConcurrentInvocations, backofftimeoutMs);
    72|         client.getMetricsRegistry().scanAndRegister(this, "invocations");
    73|     }
    74|     private long initInvocationRetryPauseMillis() {
    75|         return client.getProperties().getPositiveMillisOrDefault(INVOCATION_RETRY_PAUSE_MILLIS);
    76|     }
    77|     private long initInvocationTimeoutMillis() {
    78|         return client.getProperties().getPositiveMillisOrDefault(INVOCATION_TIMEOUT_SECONDS);
    79|     }
    80|     @Probe(level = MANDATORY)
    81|     private long startedInvocations() {
    82|         return callIdSequence.getLastCallId();
    83|     }
    84|     @Probe(level = MANDATORY)
    85|     private long maxCurrentInvocations() {
    86|         return callIdSequence.getMaxConcurrentInvocations();
    87|     }
    88|     public long getInvocationTimeoutMillis() {
    89|         return invocationTimeoutMillis;
    90|     }
    91|     public long getInvocationRetryPauseMillis() {
    92|         return invocationRetryPauseMillis;
    93|     }
    94|     CallIdSequence getCallIdSequence() {
    95|         return callIdSequence;
    96|     }
    97|     public void start() {
    98|         connectionManager = client.getConnectionManager();
    99|         clientListenerService = (AbstractClientListenerService) client.getListenerService();
   100|         partitionService = client.getClientPartitionService();
   101|         responseHandlerSupplier.start();
   102|         ClientExecutionService executionService = client.getClientExecutionService();
   103|         long cleanResourcesMillis = client.getProperties().getPositiveMillisOrDefault(CLEAN_RESOURCES_MILLIS);
   104|         executionService.scheduleWithRepetition(new CleanResourcesTask(), cleanResourcesMillis,
   105|                 cleanResourcesMillis, MILLISECONDS);
   106|     }
   107|     @Override
   108|     public ClientResponseHandler getResponseHandler() {
   109|         return responseHandlerSupplier.get();
   110|     }
   111|     @Override
   112|     public boolean isRedoOperation() {
   113|         return client.getClientConfig().getNetworkConfig().isRedoOperation();
   114|     }
   115|     protected void send(ClientInvocation invocation, ClientConnection connection) throws IOException {
   116|         if (isShutdown) {
   117|             throw new HazelcastClientNotActiveException("Client is shut down");
   118|         }
   119|         registerInvocation(invocation);
   120|         ClientMessage clientMessage = invocation.getClientMessage();
   121|         if (!writeToConnection(connection, clientMessage)) {
   122|             final long callId = clientMessage.getCorrelationId();
   123|             ClientInvocation clientInvocation = deRegisterCallId(callId);
   124|             if (clientInvocation != null) {
   125|                 throw new IOException("Packet not sent to " + connection.getEndPoint());
   126|             } else {
   127|                 if (invocationLogger.isFinestEnabled()) {
   128|                     invocationLogger.finest("Invocation not found to deregister for call ID " + callId);
   129|                 }
   130|                 return;
   131|             }
   132|         }
   133|         invocation.setSendConnection(connection);
   134|     }
   135|     private boolean writeToConnection(ClientConnection connection, ClientMessage clientMessage) {
   136|         clientMessage.addFlag(ClientMessage.BEGIN_AND_END_FLAGS);
   137|         return connection.write(clientMessage);
   138|     }
   139|     private void registerInvocation(ClientInvocation clientInvocation) {
   140|         short protocolVersion = client.getProtocolVersion();
   141|         ClientMessage clientMessage = clientInvocation.getClientMessage();
   142|         clientMessage.setVersion(protocolVersion);
   143|         long correlationId = clientMessage.getCorrelationId();
   144|         invocations.put(correlationId, clientInvocation);
   145|         EventHandler handler = clientInvocation.getEventHandler();
   146|         if (handler != null) {
   147|             clientListenerService.addEventHandler(correlationId, handler);
   148|         }
   149|     }
   150|     ClientInvocation deRegisterCallId(long callId) {
   151|         return invocations.remove(callId);
   152|     }
   153|     public boolean isShutdown() {
   154|         return isShutdown;
   155|     }
   156|     public void shutdown() {
   157|         isShutdown = true;
   158|         responseHandlerSupplier.shutdown();
   159|         Iterator<ClientInvocation> iterator = invocations.values().iterator();
   160|         while (iterator.hasNext()) {
   161|             ClientInvocation invocation = iterator.next();
   162|             iterator.remove();
   163|             invocation.notifyException(new HazelcastClientNotActiveException("Client is shutting down"));
   164|         }
   165|     }
   166|     private class CleanResourcesTask implements Runnable {
   167|         @Override
   168|         public void run() {
   169|             Iterator<Map.Entry<Long, ClientInvocation>> iter = invocations.entrySet().iterator();
   170|             while (iter.hasNext()) {
   171|                 Map.Entry<Long, ClientInvocation> entry = iter.next();
   172|                 ClientInvocation invocation = entry.getValue();
   173|                 ClientConnection connection = invocation.getSendConnection();
   174|                 if (connection == null) {
   175|                     continue;
   176|                 }
   177|                 if (connection.isAlive()) {
   178|                     continue;
   179|                 }
   180|                 iter.remove();
   181|                 notifyException(invocation, connection);
   182|             }
   183|         }
   184|         private void notifyException(ClientInvocation invocation, ClientConnection connection) {
   185|             Exception ex = new TargetDisconnectedException(connection.getCloseReason(), connection.getCloseCause());
   186|             invocation.notifyException(ex);
   187|         }
   188|     }
   189| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientClusterServiceImpl.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-42 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl;
    17| import com.hazelcast.client.config.ClientConfig;
    18| import com.hazelcast.client.connection.ClientConnectionManager;
    19| import com.hazelcast.client.connection.nio.ClientConnection;
    20| import com.hazelcast.client.impl.client.ClientPrincipal;
    21| import com.hazelcast.client.impl.clientside.ClientImpl;
    22| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    23| import com.hazelcast.client.spi.ClientClusterService;
    24| import com.hazelcast.config.ListenerConfig;
    25| import com.hazelcast.core.Client;
    26| import com.hazelcast.core.Cluster;
    27| import com.hazelcast.core.InitialMembershipEvent;
    28| import com.hazelcast.core.InitialMembershipListener;
    29| import com.hazelcast.core.Member;
    30| import com.hazelcast.core.MemberAttributeEvent;
    31| import com.hazelcast.core.MemberSelector;
    32| import com.hazelcast.core.MembershipEvent;
    33| import com.hazelcast.core.MembershipListener;
    34| import com.hazelcast.internal.cluster.impl.MemberSelectingCollection;
    35| import com.hazelcast.logging.ILogger;
    36| import com.hazelcast.nio.Address;
    37| import com.hazelcast.nio.ClassLoaderUtil;
    38| import com.hazelcast.nio.Connection;
    39| import com.hazelcast.util.Clock;
    40| import com.hazelcast.util.UuidUtil;
    41| import java.net.InetSocketAddress;
    42| import java.util.Collection;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientInvocation.java
# Total hunks: 5
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl;
    17| import com.hazelcast.client.HazelcastClientNotActiveException;
    18| import com.hazelcast.client.connection.nio.ClientConnection;
    19| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    20| import com.hazelcast.client.impl.protocol.ClientMessage;
    21| import com.hazelcast.client.spi.ClientClusterService;
    22| import com.hazelcast.client.spi.ClientExecutionService;
    23| import com.hazelcast.client.spi.EventHandler;
    24| import com.hazelcast.core.HazelcastInstanceNotActiveException;
    25| import com.hazelcast.core.HazelcastOverloadException;
    26| import com.hazelcast.core.LifecycleService;
    27| import com.hazelcast.core.OperationTimeoutException;
    28| import com.hazelcast.logging.ILogger;
    29| import com.hazelcast.nio.Address;
    30| import com.hazelcast.nio.Connection;
    31| import com.hazelcast.spi.exception.RetryableException;
    32| import com.hazelcast.spi.exception.TargetDisconnectedException;
    33| import com.hazelcast.spi.exception.TargetNotMemberException;
    34| import com.hazelcast.spi.impl.sequence.CallIdSequence;
    35| import java.io.IOException;
    36| import java.util.concurrent.Executor;
    37| import java.util.concurrent.RejectedExecutionException;
    38| import java.util.concurrent.TimeUnit;
    39| import java.util.concurrent.atomic.AtomicLongFieldUpdater;

# --- HUNK 2: Lines 49-110 ---
    49| public class ClientInvocation implements Runnable {
    50|     private static final int MAX_FAST_INVOCATION_COUNT = 5;
    51|     private static final int UNASSIGNED_PARTITION = -1;
    52|     private static final AtomicLongFieldUpdater<ClientInvocation> INVOKE_COUNT
    53|             = AtomicLongFieldUpdater.newUpdater(ClientInvocation.class, "invokeCount");
    54|     private final ClientInvocationFuture clientInvocationFuture;
    55|     private final ILogger logger;
    56|     private final LifecycleService lifecycleService;
    57|     private final ClientClusterService clientClusterService;
    58|     private final AbstractClientInvocationService invocationService;
    59|     private final ClientExecutionService executionService;
    60|     private volatile ClientMessage clientMessage;
    61|     private final CallIdSequence callIdSequence;
    62|     private final Address address;
    63|     private final int partitionId;
    64|     private final Connection connection;
    65|     private final long startTimeMillis;
    66|     private final long retryPauseMillis;
    67|     private final String objectName;
    68|     private volatile ClientConnection sendConnection;
    69|     private EventHandler handler;
    70|     private volatile long invokeCount;
    71|     private volatile long invocationTimeoutMillis;
    72|     protected ClientInvocation(HazelcastClientInstanceImpl client,
    73|                                ClientMessage clientMessage,
    74|                                String objectName,
    75|                                int partitionId,
    76|                                Address address,
    77|                                Connection connection) {
    78|         this.clientClusterService = client.getClientClusterService();
    79|         this.lifecycleService = client.getLifecycleService();
    80|         this.invocationService = (AbstractClientInvocationService) client.getInvocationService();
    81|         this.executionService = client.getClientExecutionService();
    82|         this.objectName = objectName;
    83|         this.clientMessage = clientMessage;
    84|         this.partitionId = partitionId;
    85|         this.address = address;
    86|         this.connection = connection;
    87|         this.startTimeMillis = System.currentTimeMillis();
    88|         this.retryPauseMillis = invocationService.getInvocationRetryPauseMillis();
    89|         this.logger = invocationService.invocationLogger;
    90|         this.callIdSequence = invocationService.getCallIdSequence();
    91|         this.clientInvocationFuture = new ClientInvocationFuture(this, executionService,
    92|                 clientMessage, logger, callIdSequence);
    93|         this.invocationTimeoutMillis = invocationService.getInvocationTimeoutMillis();
    94|     }
    95|     /**
    96|      * Create an invocation that will be executed on random member.
    97|      */
    98|     public ClientInvocation(HazelcastClientInstanceImpl client, ClientMessage clientMessage, String objectName) {
    99|         this(client, clientMessage, objectName, UNASSIGNED_PARTITION, null, null);
   100|     }
   101|     /**
   102|      * Create an invocation that will be executed on owner of {@code partitionId}.
   103|      */
   104|     public ClientInvocation(HazelcastClientInstanceImpl client, ClientMessage clientMessage, String objectName,
   105|                             int partitionId) {
   106|         this(client, clientMessage, objectName, partitionId, null, null);
   107|     }
   108|     /**
   109|      * Create an invocation that will be executed on member with given {@code address}.
   110|      */

# --- HUNK 3: Lines 165-205 ---
   165|         clientMessage.setCorrelationId(callIdSequence.forceNext());
   166|         callIdSequence.complete();
   167|         try {
   168|             invokeOnSelection();
   169|         } catch (Throwable e) {
   170|             clientInvocationFuture.complete(e);
   171|         }
   172|     }
   173|     public void setInvocationTimeoutMillis(long invocationTimeoutMillis) {
   174|         this.invocationTimeoutMillis = invocationTimeoutMillis;
   175|     }
   176|     public void notify(ClientMessage clientMessage) {
   177|         if (clientMessage == null) {
   178|             throw new IllegalArgumentException("response can't be null");
   179|         }
   180|         clientInvocationFuture.complete(clientMessage);
   181|     }
   182|     public void notifyException(Throwable exception) {
   183|         logException(exception);
   184|         if (!lifecycleService.isRunning()) {
   185|             clientInvocationFuture.complete(new HazelcastClientNotActiveException("Client is shutting down", exception));
   186|             return;
   187|         }
   188|         if (isNotAllowedToRetryOnSelection(exception)) {
   189|             clientInvocationFuture.complete(exception);
   190|             return;
   191|         }
   192|         boolean retry = isRetrySafeException(exception)
   193|                 || invocationService.isRedoOperation()
   194|                 || (exception instanceof TargetDisconnectedException && clientMessage.isRetryable());
   195|         if (!retry) {
   196|             clientInvocationFuture.complete(exception);
   197|             return;
   198|         }
   199|         long timePassed = System.currentTimeMillis() - startTimeMillis;
   200|         if (timePassed > invocationTimeoutMillis) {
   201|             if (logger.isFinestEnabled()) {
   202|                 logger.finest("Exception will not be retried because invocation timed out", exception);
   203|             }
   204|             clientInvocationFuture.complete(newOperationTimeoutException(exception));
   205|             return;

# --- HUNK 4: Lines 229-268 ---
   229|     }
   230|     private boolean isNotAllowedToRetryOnSelection(Throwable exception) {
   231|         if (isBindToSingleConnection() && exception instanceof IOException) {
   232|             return true;
   233|         }
   234|         if (address != null
   235|                 && exception instanceof TargetNotMemberException
   236|                 && clientClusterService.getMember(address) == null) {
   237|             return true;
   238|         }
   239|         return false;
   240|     }
   241|     private boolean isBindToSingleConnection() {
   242|         return connection != null;
   243|     }
   244|     public EventHandler getEventHandler() {
   245|         return handler;
   246|     }
   247|     public void setEventHandler(EventHandler handler) {
   248|         this.handler = handler;
   249|     }
   250|     public void setSendConnection(ClientConnection connection) {
   251|         this.sendConnection = connection;
   252|     }
   253|     public ClientConnection getSendConnectionOrWait() throws InterruptedException {
   254|         while (sendConnection == null && !clientInvocationFuture.isDone()) {
   255|             Thread.sleep(retryPauseMillis);
   256|         }
   257|         return sendConnection;
   258|     }
   259|     public ClientConnection getSendConnection() {
   260|         return sendConnection;
   261|     }
   262|     public static boolean isRetrySafeException(Throwable t) {
   263|         return t instanceof IOException
   264|                 || t instanceof HazelcastInstanceNotActiveException
   265|                 || t instanceof RetryableException;
   266|     }
   267|     public Executor getUserExecutor() {
   268|         return executionService.getUserExecutor();


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientMembershipListener.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl;
    17| import com.hazelcast.client.connection.nio.ClientConnectionManagerImpl;
    18| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    19| import com.hazelcast.client.impl.protocol.ClientMessage;
    20| import com.hazelcast.client.impl.protocol.codec.ClientAddMembershipListenerCodec;
    21| import com.hazelcast.client.spi.EventHandler;
    22| import com.hazelcast.cluster.MemberAttributeOperationType;
    23| import com.hazelcast.core.InitialMembershipEvent;
    24| import com.hazelcast.core.Member;
    25| import com.hazelcast.core.MemberAttributeEvent;
    26| import com.hazelcast.core.MembershipEvent;
    27| import com.hazelcast.instance.AbstractMember;
    28| import com.hazelcast.logging.ILogger;
    29| import com.hazelcast.nio.Address;
    30| import com.hazelcast.nio.Connection;
    31| import com.hazelcast.spi.exception.TargetDisconnectedException;
    32| import java.util.Collection;
    33| import java.util.Collections;
    34| import java.util.HashMap;
    35| import java.util.LinkedHashSet;
    36| import java.util.LinkedList;
    37| import java.util.List;
    38| import java.util.Map;

# --- HUNK 2: Lines 41-120 ---
    41| import java.util.concurrent.TimeUnit;
    42| import static java.util.Collections.unmodifiableSet;
    43| class ClientMembershipListener extends ClientAddMembershipListenerCodec.AbstractEventHandler
    44|         implements EventHandler<ClientMessage> {
    45|     private static final int INITIAL_MEMBERS_TIMEOUT_SECONDS = 5;
    46|     private final ILogger logger;
    47|     private final Set<Member> members = new LinkedHashSet<Member>();
    48|     private final HazelcastClientInstanceImpl client;
    49|     private final ClientClusterServiceImpl clusterService;
    50|     private final ClientPartitionServiceImpl partitionService;
    51|     private final ClientConnectionManagerImpl connectionManager;
    52|     private volatile CountDownLatch initialListFetchedLatch;
    53|     public ClientMembershipListener(HazelcastClientInstanceImpl client) {
    54|         this.client = client;
    55|         logger = client.getLoggingService().getLogger(ClientMembershipListener.class);
    56|         connectionManager = (ClientConnectionManagerImpl) client.getConnectionManager();
    57|         partitionService = (ClientPartitionServiceImpl) client.getClientPartitionService();
    58|         clusterService = (ClientClusterServiceImpl) client.getClientClusterService();
    59|     }
    60|     @Override
    61|     public void handleMemberEventV10(Member member, int eventType) {
    62|         switch (eventType) {
    63|             case MembershipEvent.MEMBER_ADDED:
    64|                 memberAdded(member);
    65|                 break;
    66|             case MembershipEvent.MEMBER_REMOVED:
    67|                 memberRemoved(member);
    68|                 break;
    69|             default:
    70|                 logger.warning("Unknown event type: " + eventType);
    71|         }
    72|         partitionService.refreshPartitions();
    73|     }
    74|     @Override
    75|     public void handleMemberListEventV10(Collection<Member> initialMembers) {
    76|         Map<String, Member> prevMembers = Collections.emptyMap();
    77|         if (!members.isEmpty()) {
    78|             prevMembers = new HashMap<String, Member>(members.size());
    79|             for (Member member : members) {
    80|                 prevMembers.put(member.getUuid(), member);
    81|             }
    82|             members.clear();
    83|         }
    84|         for (Member initialMember : initialMembers) {
    85|             members.add(initialMember);
    86|         }
    87|         if (prevMembers.isEmpty()) {
    88|             logger.info(membersString());
    89|             clusterService.handleInitialMembershipEvent(
    90|                     new InitialMembershipEvent(client.getCluster(), unmodifiableSet(members)));
    91|             initialListFetchedLatch.countDown();
    92|             return;
    93|         }
    94|         List<MembershipEvent> events = detectMembershipEvents(prevMembers);
    95|         logger.info(membersString());
    96|         fireMembershipEvent(events);
    97|         initialListFetchedLatch.countDown();
    98|     }
    99|     @Override
   100|     public void handleMemberAttributeChangeEventV10(String uuid, String key, int opType, String value) {
   101|         Collection<Member> members = clusterService.getMemberList();
   102|         for (Member target : members) {
   103|             if (target.getUuid().equals(uuid)) {
   104|                 final MemberAttributeOperationType operationType = MemberAttributeOperationType.getValue(opType);
   105|                 ((AbstractMember) target).updateAttribute(operationType, key, value);
   106|                 MemberAttributeEvent memberAttributeEvent =
   107|                         new MemberAttributeEvent(client.getCluster(), target, operationType, key, value);
   108|                 clusterService.fireMemberAttributeEvent(memberAttributeEvent);
   109|                 break;
   110|             }
   111|         }
   112|     }
   113|     @Override
   114|     public void beforeListenerRegister() {
   115|     }
   116|     @Override
   117|     public void onListenerRegister() {
   118|     }
   119|     void listenMembershipEvents(Connection ownerConnection) throws Exception {
   120|         initialListFetchedLatch = new CountDownLatch(1);


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientPartitionServiceImpl.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl;
    17| import com.hazelcast.client.connection.ClientConnectionManager;
    18| import com.hazelcast.client.connection.nio.ClientConnection;
    19| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    20| import com.hazelcast.client.impl.protocol.ClientMessage;
    21| import com.hazelcast.client.impl.protocol.codec.ClientAddPartitionListenerCodec;
    22| import com.hazelcast.client.impl.protocol.codec.ClientGetPartitionsCodec;
    23| import com.hazelcast.client.spi.ClientClusterService;
    24| import com.hazelcast.client.spi.ClientPartitionService;
    25| import com.hazelcast.client.spi.EventHandler;
    26| import com.hazelcast.cluster.memberselector.MemberSelectors;
    27| import com.hazelcast.core.ExecutionCallback;
    28| import com.hazelcast.core.Member;
    29| import com.hazelcast.core.Partition;
    30| import com.hazelcast.instance.BuildInfo;
    31| import com.hazelcast.logging.ILogger;
    32| import com.hazelcast.nio.Address;
    33| import com.hazelcast.nio.Connection;
    34| import com.hazelcast.nio.serialization.Data;
    35| import com.hazelcast.partition.NoDataMemberInClusterException;
    36| import com.hazelcast.util.HashUtil;
    37| import java.util.Collection;
    38| import java.util.List;
    39| import java.util.Map;

# --- HUNK 2: Lines 65-105 ---
    65|     public void start() {
    66|         clientExecutionService.scheduleWithRepetition(new RefreshTask(), INITIAL_DELAY, PERIOD, TimeUnit.SECONDS);
    67|     }
    68|     public void listenPartitionTable(Connection ownerConnection) throws Exception {
    69|         lastPartitionStateVersion = -1;
    70|         if (((ClientConnection) ownerConnection).getConnectedServerVersion() >= BuildInfo.calculateVersion("3.9")) {
    71|             ClientMessage clientMessage = ClientAddPartitionListenerCodec.encodeRequest();
    72|             ClientInvocation invocation = new ClientInvocation(client, clientMessage, null, ownerConnection);
    73|             invocation.setEventHandler(this);
    74|             invocation.invokeUrgent().get();
    75|         }
    76|     }
    77|     public void refreshPartitions() {
    78|         try {
    79|             clientExecutionService.execute(new RefreshTask());
    80|         } catch (RejectedExecutionException ignored) {
    81|             ignore(ignored);
    82|         }
    83|     }
    84|     @Override
    85|     public void handlePartitionsEventV15(Collection<Map.Entry<Address, List<Integer>>> collection, int partitionStateVersion) {
    86|         processPartitionResponse(collection, partitionStateVersion, true);
    87|     }
    88|     @Override
    89|     public void beforeListenerRegister() {
    90|     }
    91|     @Override
    92|     public void onListenerRegister() {
    93|     }
    94|     private void waitForPartitionsFetchedOnce() {
    95|         while (partitionCount == 0 && client.getConnectionManager().isAlive()) {
    96|             if (isClusterFormedByOnlyLiteMembers()) {
    97|                 throw new NoDataMemberInClusterException(
    98|                         "Partitions can't be assigned since all nodes in the cluster are lite members");
    99|             }
   100|             ClientMessage requestMessage = ClientGetPartitionsCodec.encodeRequest();
   101|             ClientInvocationFuture future = new ClientInvocation(client, requestMessage, null).invokeUrgent();
   102|             try {
   103|                 ClientMessage responseMessage = future.get();
   104|                 ClientGetPartitionsCodec.ResponseParameters response =
   105|                         ClientGetPartitionsCodec.decodeResponse(responseMessage);


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientResponseHandler.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-23 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl;
    17| import com.hazelcast.client.impl.protocol.ClientMessage;
    18| /**
    19|  * Responsible for handling responses to invocations.
    20|  */
    21| public interface ClientResponseHandler {
    22|     void handle(ClientMessage message);
    23| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientResponseHandlerSupplier.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl;
    17| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.impl.protocol.codec.ErrorCodec;
    20| import com.hazelcast.internal.util.concurrent.MPSCQueue;
    21| import com.hazelcast.logging.ILogger;
    22| import com.hazelcast.spi.properties.HazelcastProperty;
    23| import com.hazelcast.util.MutableInteger;
    24| import com.hazelcast.util.function.Supplier;
    25| import java.util.concurrent.BlockingQueue;
    26| import static com.hazelcast.client.spi.properties.ClientProperty.RESPONSE_THREAD_COUNT;
    27| import static com.hazelcast.instance.OutOfMemoryErrorDispatcher.onOutOfMemory;
    28| import static com.hazelcast.spi.impl.operationservice.impl.InboundResponseHandlerSupplier.getIdleStrategy;
    29| import static com.hazelcast.util.HashUtil.hashToIndex;
    30| /**
    31|  * A {@link Supplier} for {@link ClientResponseHandler} instance.
    32|  *
    33|  * Depending on the configuration the supplier provides:
    34|  * <ol>
    35|  * <li>a on thread ClientResponseHandler (so no offloading to a different thread)</li>
    36|  * <li>a single threaded ClientResponseHandler that offloads the response processing
    37|  * a ResponseThread/li>

# --- HUNK 2: Lines 76-165 ---
    76|                 this.responseHandler = new AsyncSingleThreadedResponseHandler();
    77|                 break;
    78|             default:
    79|                 this.responseHandler = new AsyncMultiThreadedResponseHandler();
    80|         }
    81|     }
    82|     public void start() {
    83|         for (ResponseThread responseThread : responseThreads) {
    84|             responseThread.start();
    85|         }
    86|     }
    87|     public void shutdown() {
    88|         for (ResponseThread responseThread : responseThreads) {
    89|             responseThread.interrupt();
    90|         }
    91|     }
    92|     @Override
    93|     public ClientResponseHandler get() {
    94|         return responseHandler;
    95|     }
    96|     private void process(ClientMessage response) {
    97|         try {
    98|             handleResponse(response);
    99|         } catch (Exception e) {
   100|             logger.severe("Failed to process response: " + response
   101|                     + " on responseThread: " + Thread.currentThread().getName(), e);
   102|         }
   103|     }
   104|     private void handleResponse(ClientMessage clientMessage) {
   105|         long correlationId = clientMessage.getCorrelationId();
   106|         ClientInvocation future = invocationService.deRegisterCallId(correlationId);
   107|         if (future == null) {
   108|             logger.warning("No call for callId: " + correlationId + ", response: " + clientMessage);
   109|             return;
   110|         }
   111|         if (ErrorCodec.TYPE == clientMessage.getMessageType()) {
   112|             future.notifyException(client.getClientExceptionFactory().createException(clientMessage));
   113|         } else {
   114|             future.notify(clientMessage);
   115|         }
   116|     }
   117|     private class ResponseThread extends Thread {
   118|         private final BlockingQueue<ClientMessage> responseQueue;
   119|         ResponseThread(String name) {
   120|             super(name);
   121|             setContextClassLoader(client.getClientConfig().getClassLoader());
   122|             this.responseQueue = new MPSCQueue<ClientMessage>(this, getIdleStrategy(client.getProperties(), IDLE_STRATEGY));
   123|         }
   124|         @Override
   125|         public void run() {
   126|             try {
   127|                 doRun();
   128|             } catch (OutOfMemoryError e) {
   129|                 onOutOfMemory(e);
   130|             } catch (Throwable t) {
   131|                 invocationService.invocationLogger.severe(t);
   132|             }
   133|         }
   134|         private void doRun() {
   135|             while (!invocationService.isShutdown()) {
   136|                 ClientMessage response;
   137|                 try {
   138|                     response = responseQueue.take();
   139|                 } catch (InterruptedException e) {
   140|                     continue;
   141|                 }
   142|                 process(response);
   143|             }
   144|         }
   145|     }
   146|     class SyncResponseHandler implements ClientResponseHandler {
   147|         @Override
   148|         public void handle(ClientMessage message) {
   149|             process(message);
   150|         }
   151|     }
   152|     class AsyncSingleThreadedResponseHandler implements ClientResponseHandler {
   153|         @Override
   154|         public void handle(ClientMessage message) {
   155|             responseThreads[0].responseQueue.add(message);
   156|         }
   157|     }
   158|     class AsyncMultiThreadedResponseHandler implements ClientResponseHandler {
   159|         @Override
   160|         public void handle(ClientMessage message) {
   161|             int threadIndex = hashToIndex(INT_HOLDER.get().getAndInc(), responseThreads.length);
   162|             responseThreads[threadIndex].responseQueue.add(message);
   163|         }
   164|     }
   165| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientTransactionManagerServiceImpl.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 3-43 ---
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl;
    17| import com.hazelcast.client.HazelcastClientNotActiveException;
    18| import com.hazelcast.client.HazelcastClientOfflineException;
    19| import com.hazelcast.client.LoadBalancer;
    20| import com.hazelcast.client.config.ClientConfig;
    21| import com.hazelcast.client.config.ClientConnectionStrategyConfig;
    22| import com.hazelcast.client.connection.nio.ClientConnection;
    23| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    24| import com.hazelcast.client.proxy.txn.TransactionContextProxy;
    25| import com.hazelcast.client.proxy.txn.xa.XATransactionContextProxy;
    26| import com.hazelcast.client.spi.ClientTransactionManagerService;
    27| import com.hazelcast.config.GroupConfig;
    28| import com.hazelcast.core.Member;
    29| import com.hazelcast.core.OperationTimeoutException;
    30| import com.hazelcast.nio.Address;
    31| import com.hazelcast.transaction.TransactionContext;
    32| import com.hazelcast.transaction.TransactionException;
    33| import com.hazelcast.transaction.TransactionOptions;
    34| import com.hazelcast.transaction.TransactionalTask;
    35| import javax.transaction.xa.Xid;
    36| import java.io.IOException;
    37| import java.util.Set;
    38| import static com.hazelcast.util.Clock.currentTimeMillis;
    39| import static com.hazelcast.util.StringUtil.timeToString;
    40| public class ClientTransactionManagerServiceImpl implements ClientTransactionManagerService {
    41|     private final HazelcastClientInstanceImpl client;
    42|     private final LoadBalancer loadBalancer;
    43|     public ClientTransactionManagerServiceImpl(HazelcastClientInstanceImpl client, LoadBalancer loadBalancer) {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/ClientUserCodeDeploymentService.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl;
    17| import com.hazelcast.client.config.ClientUserCodeDeploymentConfig;
    18| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    19| import com.hazelcast.client.impl.protocol.ClientMessage;
    20| import com.hazelcast.client.impl.protocol.codec.ClientDeployClassesCodec;
    21| import com.hazelcast.nio.Connection;
    22| import java.io.ByteArrayOutputStream;
    23| import java.io.File;
    24| import java.io.FileInputStream;
    25| import java.io.FileNotFoundException;
    26| import java.io.IOException;
    27| import java.io.InputStream;
    28| import java.net.MalformedURLException;
    29| import java.net.URL;
    30| import java.util.AbstractMap;
    31| import java.util.ArrayList;
    32| import java.util.List;
    33| import java.util.Map;
    34| import java.util.concurrent.ExecutionException;
    35| import java.util.jar.JarEntry;
    36| import java.util.jar.JarInputStream;
    37| import java.util.regex.Matcher;
    38| import java.util.regex.Pattern;


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/NonSmartClientInvocationService.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl;
    17| import com.hazelcast.client.connection.nio.ClientConnection;
    18| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    19| import com.hazelcast.nio.Address;
    20| import java.io.IOException;
    21| public class NonSmartClientInvocationService extends AbstractClientInvocationService {
    22|     public NonSmartClientInvocationService(HazelcastClientInstanceImpl client) {
    23|         super(client);
    24|     }
    25|     @Override
    26|     public void invokeOnRandomTarget(ClientInvocation invocation) throws IOException {
    27|         send(invocation, getOwnerConnection());
    28|     }
    29|     @Override
    30|     public void invokeOnConnection(ClientInvocation invocation, ClientConnection connection) throws IOException {
    31|         assert connection != null;
    32|         send(invocation, connection);
    33|     }
    34|     @Override
    35|     public void invokeOnPartitionOwner(ClientInvocation invocation, int partitionId) throws IOException {
    36|         invocation.getClientMessage().setPartitionId(partitionId);
    37|         send(invocation, getOwnerConnection());
    38|     }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/SmartClientInvocationService.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl;
    17| import com.hazelcast.client.LoadBalancer;
    18| import com.hazelcast.client.connection.nio.ClientConnection;
    19| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    20| import com.hazelcast.core.Member;
    21| import com.hazelcast.nio.Address;
    22| import com.hazelcast.nio.Connection;
    23| import com.hazelcast.spi.exception.TargetNotMemberException;
    24| import java.io.IOException;
    25| public class SmartClientInvocationService extends AbstractClientInvocationService {
    26|     private final LoadBalancer loadBalancer;
    27|     public SmartClientInvocationService(HazelcastClientInstanceImpl client, LoadBalancer loadBalancer) {
    28|         super(client);
    29|         this.loadBalancer = loadBalancer;
    30|     }
    31|     @Override
    32|     public void invokeOnPartitionOwner(ClientInvocation invocation, int partitionId) throws IOException {
    33|         final Address owner = partitionService.getPartitionOwner(partitionId);
    34|         if (owner == null) {
    35|             throw new IOException("Partition does not have an owner. partitionId: " + partitionId);
    36|         }
    37|         if (!isMember(owner)) {
    38|             throw new TargetNotMemberException("Partition owner '" + owner + "' is not a member.");
    39|         }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/discovery/HazelcastCloudDiscovery.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl.discovery;
    17| import com.hazelcast.client.util.AddressHelper;
    18| import com.hazelcast.internal.json.Json;
    19| import com.hazelcast.internal.json.JsonValue;
    20| import com.hazelcast.nio.Address;
    21| import com.hazelcast.spi.properties.HazelcastProperties;
    22| import com.hazelcast.spi.properties.HazelcastProperty;
    23| import com.hazelcast.util.AddressUtil;
    24| import javax.net.ssl.HttpsURLConnection;
    25| import java.io.BufferedReader;
    26| import java.io.IOException;
    27| import java.io.InputStream;
    28| import java.io.InputStreamReader;
    29| import java.net.HttpURLConnection;
    30| import java.net.URL;
    31| import java.security.cert.Certificate;
    32| import java.security.cert.CertificateException;
    33| import java.security.cert.X509Certificate;
    34| import java.util.HashMap;
    35| import java.util.List;
    36| import java.util.Map;
    37| import java.util.Scanner;
    38| import static com.hazelcast.util.ExceptionUtil.rethrow;
    39| /**


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/listener/AbstractClientListenerService.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-309 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl.listener;
    17| import com.hazelcast.client.connection.ClientConnectionManager;
    18| import com.hazelcast.client.connection.nio.ClientConnection;
    19| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    20| import com.hazelcast.client.impl.protocol.ClientMessage;
    21| import com.hazelcast.client.spi.ClientListenerService;
    22| import com.hazelcast.client.spi.EventHandler;
    23| import com.hazelcast.client.spi.impl.AbstractClientInvocationService;
    24| import com.hazelcast.client.spi.impl.ClientExecutionServiceImpl;
    25| import com.hazelcast.client.spi.impl.ClientInvocation;
    26| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    27| import com.hazelcast.client.spi.impl.ListenerMessageCodec;
    28| import com.hazelcast.core.HazelcastException;
    29| import com.hazelcast.internal.metrics.MetricsProvider;
    30| import com.hazelcast.internal.metrics.MetricsRegistry;
    31| import com.hazelcast.internal.metrics.Probe;
    32| import com.hazelcast.logging.ILogger;
    33| import com.hazelcast.nio.Connection;
    34| import com.hazelcast.nio.ConnectionListener;
    35| import com.hazelcast.spi.serialization.SerializationService;
    36| import com.hazelcast.util.EmptyStatement;
    37| import com.hazelcast.util.ExceptionUtil;
    38| import com.hazelcast.util.UuidUtil;
    39| import com.hazelcast.util.executor.SingleExecutorThreadFactory;
    40| import com.hazelcast.util.executor.StripedExecutor;
    41| import com.hazelcast.util.executor.StripedRunnable;
    42| import java.util.Collection;
    43| import java.util.Collections;
    44| import java.util.Iterator;
    45| import java.util.LinkedList;
    46| import java.util.Map;
    47| import java.util.concurrent.Callable;
    48| import java.util.concurrent.ConcurrentHashMap;
    49| import java.util.concurrent.ConcurrentMap;
    50| import java.util.concurrent.Executors;
    51| import java.util.concurrent.Future;
    52| import java.util.concurrent.RejectedExecutionException;
    53| import java.util.concurrent.ScheduledExecutorService;
    54| import java.util.concurrent.ThreadFactory;
    55| import static com.hazelcast.internal.metrics.ProbeLevel.MANDATORY;
    56| public abstract class AbstractClientListenerService implements ClientListenerService, MetricsProvider, ConnectionListener {
    57|     protected final HazelcastClientInstanceImpl client;
    58|     protected final SerializationService serializationService;
    59|     protected final long invocationTimeoutMillis;
    60|     protected final long invocationRetryPauseMillis;
    61|     protected final Map<ClientRegistrationKey, Map<Connection, ClientEventRegistration>> registrations
    62|             = new ConcurrentHashMap<ClientRegistrationKey, Map<Connection, ClientEventRegistration>>();
    63|     final ScheduledExecutorService registrationExecutor;
    64|     final ClientConnectionManager clientConnectionManager;
    65|     private final ILogger logger;
    66|     @Probe(name = "eventHandlerCount", level = MANDATORY)
    67|     private final ConcurrentMap<Long, EventHandler> eventHandlerMap
    68|             = new ConcurrentHashMap<Long, EventHandler>();
    69|     private final StripedExecutor eventExecutor;
    70|     AbstractClientListenerService(HazelcastClientInstanceImpl client, int eventThreadCount, int eventQueueCapacity) {
    71|         this.client = client;
    72|         serializationService = client.getSerializationService();
    73|         logger = client.getLoggingService().getLogger(ClientListenerService.class);
    74|         String name = client.getName();
    75|         eventExecutor = new StripedExecutor(logger, name + ".event", eventThreadCount, eventQueueCapacity);
    76|         ClassLoader classLoader = client.getClientConfig().getClassLoader();
    77|         ThreadFactory threadFactory = new SingleExecutorThreadFactory(classLoader, name + ".eventRegistration-");
    78|         registrationExecutor = Executors.newSingleThreadScheduledExecutor(threadFactory);
    79|         clientConnectionManager = client.getConnectionManager();
    80|         AbstractClientInvocationService invocationService = (AbstractClientInvocationService) client.getInvocationService();
    81|         invocationTimeoutMillis = invocationService.getInvocationTimeoutMillis();
    82|         invocationRetryPauseMillis = invocationService.getInvocationRetryPauseMillis();
    83|     }
    84|     @Override
    85|     public String registerListener(final ListenerMessageCodec codec, final EventHandler handler) {
    86|         assert (!Thread.currentThread().getName().contains("eventRegistration"));
    87|         Future<String> future = registrationExecutor.submit(new Callable<String>() {
    88|             @Override
    89|             public String call() {
    90|                 String userRegistrationId = UuidUtil.newUnsecureUuidString();
    91|                 ClientRegistrationKey registrationKey = new ClientRegistrationKey(userRegistrationId, handler, codec);
    92|                 registrations.put(registrationKey, new ConcurrentHashMap<Connection, ClientEventRegistration>());
    93|                 Collection<ClientConnection> connections = clientConnectionManager.getActiveConnections();
    94|                 for (ClientConnection connection : connections) {
    95|                     try {
    96|                         invoke(registrationKey, connection);
    97|                     } catch (Exception e) {
    98|                         if (connection.isAlive()) {
    99|                             deregisterListenerInternal(userRegistrationId);
   100|                             throw new HazelcastException("Listener can not be added ", e);
   101|                         }
   102|                     }
   103|                 }
   104|                 return userRegistrationId;
   105|             }
   106|         });
   107|         try {
   108|             return future.get();
   109|         } catch (Exception e) {
   110|             throw ExceptionUtil.rethrow(e);
   111|         }
   112|     }
   113|     @Override
   114|     public boolean deregisterListener(final String userRegistrationId) {
   115|         assert (!Thread.currentThread().getName().contains("eventRegistration"));
   116|         try {
   117|             Future<Boolean> future = registrationExecutor.submit(new Callable<Boolean>() {
   118|                 @Override
   119|                 public Boolean call() {
   120|                     return deregisterListenerInternal(userRegistrationId);
   121|                 }
   122|             });
   123|             try {
   124|                 return future.get();
   125|             } catch (Exception e) {
   126|                 throw ExceptionUtil.rethrow(e);
   127|             }
   128|         } catch (RejectedExecutionException ignored) {
   129|             EmptyStatement.ignore(ignored);
   130|             return true;
   131|         }
   132|     }
   133|     @Override
   134|     public void provideMetrics(MetricsRegistry registry) {
   135|         registry.scanAndRegister(this, "listeners");
   136|     }
   137|     @Probe(level = MANDATORY)
   138|     private int eventQueueSize() {
   139|         return eventExecutor.getWorkQueueSize();
   140|     }
   141|     @Probe(level = MANDATORY)
   142|     private long eventsProcessed() {
   143|         return eventExecutor.processedCount();
   144|     }
   145|     public void addEventHandler(long callId, EventHandler handler) {
   146|         eventHandlerMap.put(callId, handler);
   147|     }
   148|     public void handleClientMessage(ClientMessage clientMessage) {
   149|         try {
   150|             eventExecutor.execute(new ClientEventProcessor(clientMessage));
   151|         } catch (RejectedExecutionException e) {
   152|             logger.warning("Event clientMessage could not be handled", e);
   153|         }
   154|     }
   155|     protected void invoke(ClientRegistrationKey registrationKey, Connection connection) throws Exception {
   156|         assert (Thread.currentThread().getName().contains("eventRegistration"));
   157|         Map<Connection, ClientEventRegistration> registrationMap = registrations.get(registrationKey);
   158|         if (registrationMap.containsKey(connection)) {
   159|             return;
   160|         }
   161|         ListenerMessageCodec codec = registrationKey.getCodec();
   162|         ClientMessage request = codec.encodeAddRequest(registersLocalOnly());
   163|         EventHandler handler = registrationKey.getHandler();
   164|         handler.beforeListenerRegister();
   165|         ClientInvocation invocation = new ClientInvocation(client, request, null, connection);
   166|         invocation.setEventHandler(handler);
   167|         ClientInvocationFuture future = invocation.invokeUrgent();
   168|         ClientMessage clientMessage;
   169|         try {
   170|             clientMessage = future.get();
   171|         } catch (Exception e) {
   172|             throw ExceptionUtil.rethrow(e, Exception.class);
   173|         }
   174|         String serverRegistrationId = codec.decodeAddResponse(clientMessage);
   175|         handler.onListenerRegister();
   176|         long correlationId = request.getCorrelationId();
   177|         ClientEventRegistration registration
   178|                 = new ClientEventRegistration(serverRegistrationId, correlationId, connection, codec);
   179|         registrationMap.put(connection, registration);
   180|     }
   181|     @Override
   182|     public void connectionAdded(final Connection connection) {
   183|         assert (!Thread.currentThread().getName().contains("eventRegistration"));
   184|         registrationExecutor.submit(new Runnable() {
   185|             @Override
   186|             public void run() {
   187|                 for (ClientRegistrationKey registrationKey : registrations.keySet()) {
   188|                     invokeFromInternalThread(registrationKey, connection);
   189|                 }
   190|             }
   191|         });
   192|     }
   193|     public void shutdown() {
   194|         eventExecutor.shutdown();
   195|         ClientExecutionServiceImpl.shutdownExecutor("registrationExecutor", registrationExecutor, logger);
   196|     }
   197|     public void start() {
   198|         clientConnectionManager.addConnectionListener(this);
   199|     }
   200|     @Override
   201|     public void connectionRemoved(final Connection connection) {
   202|         assert (!Thread.currentThread().getName().contains("eventRegistration"));
   203|         registrationExecutor.submit(new Runnable() {
   204|             @Override
   205|             public void run() {
   206|                 for (Map<Connection, ClientEventRegistration> registrationMap : registrations.values()) {
   207|                     ClientEventRegistration registration = registrationMap.remove(connection);
   208|                     if (registration != null) {
   209|                         removeEventHandler(registration.getCallId());
   210|                     }
   211|                 }
   212|             }
   213|         });
   214|     }
   215|     public StripedExecutor getEventExecutor() {
   216|         return eventExecutor;
   217|     }
   218|     public Collection<ClientEventRegistration> getActiveRegistrations(final String uuid) {
   219|         assert (!Thread.currentThread().getName().contains("eventRegistration"));
   220|         Future<Collection<ClientEventRegistration>> future = registrationExecutor.submit(
   221|                 new Callable<Collection<ClientEventRegistration>>() {
   222|                     @Override
   223|                     public Collection<ClientEventRegistration> call() {
   224|                         ClientRegistrationKey key = new ClientRegistrationKey(uuid);
   225|                         Map<Connection, ClientEventRegistration> registrationMap = registrations.get(key);
   226|                         if (registrationMap == null) {
   227|                             return Collections.EMPTY_LIST;
   228|                         }
   229|                         LinkedList<ClientEventRegistration> activeRegistrations = new LinkedList<ClientEventRegistration>();
   230|                         for (ClientEventRegistration registration : registrationMap.values()) {
   231|                             activeRegistrations.add(registration);
   232|                         }
   233|                         return activeRegistrations;
   234|                     }
   235|                 });
   236|         try {
   237|             return future.get();
   238|         } catch (Exception e) {
   239|             throw ExceptionUtil.rethrow(e);
   240|         }
   241|     }
   242|     public Map<ClientRegistrationKey, Map<Connection, ClientEventRegistration>> getRegistrations() {
   243|         return registrations;
   244|     }
   245|     private void invokeFromInternalThread(ClientRegistrationKey registrationKey, Connection connection) {
   246|         assert (Thread.currentThread().getName().contains("eventRegistration"));
   247|         try {
   248|             invoke(registrationKey, connection);
   249|         } catch (Exception e) {
   250|             logger.warning("Listener " + registrationKey + " can not be added to a new connection: "
   251|                     + connection + ", reason: " + e.getMessage());
   252|         }
   253|     }
   254|     abstract boolean registersLocalOnly();
   255|     private void removeEventHandler(long callId) {
   256|         eventHandlerMap.remove(callId);
   257|     }
   258|     private Boolean deregisterListenerInternal(String userRegistrationId) {
   259|         assert (Thread.currentThread().getName().contains("eventRegistration"));
   260|         ClientRegistrationKey key = new ClientRegistrationKey(userRegistrationId);
   261|         Map<Connection, ClientEventRegistration> registrationMap = registrations.get(key);
   262|         if (registrationMap == null) {
   263|             return false;
   264|         }
   265|         boolean successful = true;
   266|         for (Iterator<ClientEventRegistration> iterator = registrationMap.values().iterator(); iterator.hasNext(); ) {
   267|             ClientEventRegistration registration = iterator.next();
   268|             Connection subscriber = registration.getSubscriber();
   269|             try {
   270|                 ListenerMessageCodec listenerMessageCodec = registration.getCodec();
   271|                 String serverRegistrationId = registration.getServerRegistrationId();
   272|                 ClientMessage request = listenerMessageCodec.encodeRemoveRequest(serverRegistrationId);
   273|                 new ClientInvocation(client, request, null, subscriber).invoke().get();
   274|                 removeEventHandler(registration.getCallId());
   275|                 iterator.remove();
   276|             } catch (Exception e) {
   277|                 if (subscriber.isAlive()) {
   278|                     successful = false;
   279|                     logger.warning("Deregistration of listener with ID " + userRegistrationId
   280|                             + " has failed to address " + subscriber.getEndPoint(), e);
   281|                 }
   282|             }
   283|         }
   284|         if (successful) {
   285|             registrations.remove(key);
   286|         }
   287|         return successful;
   288|     }
   289|     private final class ClientEventProcessor implements StripedRunnable {
   290|         final ClientMessage clientMessage;
   291|         private ClientEventProcessor(ClientMessage clientMessage) {
   292|             this.clientMessage = clientMessage;
   293|         }
   294|         @Override
   295|         public void run() {
   296|             long correlationId = clientMessage.getCorrelationId();
   297|             final EventHandler eventHandler = eventHandlerMap.get(correlationId);
   298|             if (eventHandler == null) {
   299|                 logger.warning("No eventHandler for callId: " + correlationId + ", event: " + clientMessage);
   300|                 return;
   301|             }
   302|             eventHandler.handle(clientMessage);
   303|         }
   304|         @Override
   305|         public int getKey() {
   306|             return clientMessage.getPartitionId();
   307|         }
   308|     }
   309| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/listener/NonSmartClientListenerService.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-27 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl.listener;
    17| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    18| import com.hazelcast.nio.ConnectionListener;
    19| public class NonSmartClientListenerService extends AbstractClientListenerService implements ConnectionListener {
    20|     public NonSmartClientListenerService(HazelcastClientInstanceImpl client,
    21|                                          int eventThreadCount, int eventQueueCapacity) {
    22|         super(client, eventThreadCount, eventQueueCapacity);
    23|     }
    24|     boolean registersLocalOnly() {
    25|         return false;
    26|     }
    27| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/spi/impl/listener/SmartClientListenerService.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-107 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.spi.impl.listener;
    17| import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;
    18| import com.hazelcast.client.spi.ClientClusterService;
    19| import com.hazelcast.client.spi.EventHandler;
    20| import com.hazelcast.client.spi.impl.ListenerMessageCodec;
    21| import com.hazelcast.core.Member;
    22| import com.hazelcast.core.OperationTimeoutException;
    23| import com.hazelcast.util.ExceptionUtil;
    24| import java.io.IOException;
    25| import java.util.Collection;
    26| import java.util.concurrent.TimeUnit;
    27| import static com.hazelcast.util.StringUtil.timeToString;
    28| public class SmartClientListenerService extends AbstractClientListenerService  {
    29|     public SmartClientListenerService(HazelcastClientInstanceImpl client,
    30|                                       int eventThreadCount, int eventQueueCapacity) {
    31|         super(client, eventThreadCount, eventQueueCapacity);
    32|     }
    33|     @Override
    34|     public void start() {
    35|         super.start();
    36|         final ClientClusterService clientClusterService = client.getClientClusterService();
    37|         registrationExecutor.scheduleWithFixedDelay(new Runnable() {
    38|             @Override
    39|             public void run() {
    40|                 Collection<Member> memberList = clientClusterService.getMemberList();
    41|                 for (Member member : memberList) {
    42|                     try {
    43|                         clientConnectionManager.getOrTriggerConnect(member.getAddress(), false);
    44|                     } catch (IOException e) {
    45|                         return;
    46|                     }
    47|                 }
    48|             }
    49|         }, 1, 1, TimeUnit.SECONDS);
    50|     }
    51|     @Override
    52|     public String registerListener(final ListenerMessageCodec codec, final EventHandler handler) {
    53|         trySyncConnectToAllMembers();
    54|         return super.registerListener(codec, handler);
    55|     }
    56|     @Override
    57|     boolean registersLocalOnly() {
    58|         return true;
    59|     }
    60|     private void trySyncConnectToAllMembers() {
    61|         ClientClusterService clientClusterService = client.getClientClusterService();
    62|         long startMillis = System.currentTimeMillis();
    63|         do {
    64|             Member lastFailedMember = null;
    65|             Exception lastException = null;
    66|             for (Member member : clientClusterService.getMemberList()) {
    67|                 try {
    68|                     clientConnectionManager.getOrConnect(member.getAddress());
    69|                 } catch (Exception e) {
    70|                     lastFailedMember = member;
    71|                     lastException = e;
    72|                 }
    73|             }
    74|             if (lastException == null) {
    75|                 break;
    76|             }
    77|             timeOutOrSleepBeforeNextTry(startMillis, lastFailedMember, lastException);
    78|         } while (client.getLifecycleService().isRunning());
    79|     }
    80|     private void timeOutOrSleepBeforeNextTry(long startMillis, Member lastFailedMember, Exception lastException) {
    81|         long nowInMillis = System.currentTimeMillis();
    82|         long elapsedMillis = nowInMillis - startMillis;
    83|         boolean timedOut = elapsedMillis > invocationTimeoutMillis;
    84|         if (timedOut) {
    85|             throwOperationTimeoutException(startMillis, nowInMillis, elapsedMillis, lastFailedMember, lastException);
    86|         } else {
    87|             sleepBeforeNextTry();
    88|         }
    89|     }
    90|     private void sleepBeforeNextTry() {
    91|         try {
    92|             Thread.sleep(invocationRetryPauseMillis);
    93|         } catch (InterruptedException e) {
    94|             Thread.currentThread().interrupt();
    95|             throw ExceptionUtil.rethrow(e);
    96|         }
    97|     }
    98|     private void throwOperationTimeoutException(long startMillis, long nowInMillis,
    99|                                                 long elapsedMillis, Member lastFailedMember, Exception lastException) {
   100|         throw new OperationTimeoutException("Registering listeners is timed out."
   101|                 + " Last failed member : " + lastFailedMember + ", "
   102|                 + " Current time: " + timeToString(nowInMillis) + ", "
   103|                 + " Start time : " + timeToString(startMillis) + ", "
   104|                 + " Client invocation timeout : " + invocationTimeoutMillis + " ms, "
   105|                 + " Elapsed time : " + elapsedMillis + " ms. ", lastException);
   106|     }
   107| }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/util/AbstractLoadBalancer.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 11-60 ---
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.util;
    17| import com.hazelcast.client.LoadBalancer;
    18| import com.hazelcast.client.config.ClientConfig;
    19| import com.hazelcast.core.Cluster;
    20| import com.hazelcast.core.InitialMembershipEvent;
    21| import com.hazelcast.core.InitialMembershipListener;
    22| import com.hazelcast.core.Member;
    23| import com.hazelcast.core.MemberAttributeEvent;
    24| import com.hazelcast.core.MembershipEvent;
    25| import java.util.Set;
    26| import java.util.concurrent.atomic.AtomicReference;
    27| /**
    28|  * An abstract {@link com.hazelcast.client.LoadBalancer} implementation.
    29|  */
    30| public abstract class AbstractLoadBalancer implements LoadBalancer, InitialMembershipListener {
    31|     private final AtomicReference<Member[]> membersRef = new AtomicReference<Member[]>(new Member[0]);
    32|     private volatile Cluster clusterRef;
    33|     @Override
    34|     public final void init(Cluster cluster, ClientConfig config) {
    35|         this.clusterRef = cluster;
    36|         cluster.addMembershipListener(this);
    37|     }
    38|     private void setMembersRef() {
    39|         Set<Member> memberSet = clusterRef.getMembers();
    40|         Member[] members = memberSet.toArray(new Member[0]);
    41|         membersRef.set(members);
    42|     }
    43|     protected Member[] getMembers() {
    44|         return membersRef.get();
    45|     }
    46|     @Override
    47|     public final void init(InitialMembershipEvent event) {
    48|         setMembersRef();
    49|     }
    50|     @Override
    51|     public final void memberAdded(MembershipEvent membershipEvent) {
    52|         setMembersRef();
    53|     }
    54|     @Override
    55|     public final void memberRemoved(MembershipEvent membershipEvent) {
    56|         setMembersRef();
    57|     }
    58|     @Override
    59|     public final void memberAttributeChanged(MemberAttributeEvent memberAttributeEvent) {
    60|     }


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/util/ClientDelegatingFuture.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|  * Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| package com.hazelcast.client.util;
    17| import com.hazelcast.client.impl.clientside.ClientMessageDecoder;
    18| import com.hazelcast.client.impl.protocol.ClientMessage;
    19| import com.hazelcast.client.spi.impl.ClientInvocationFuture;
    20| import com.hazelcast.core.ExecutionCallback;
    21| import com.hazelcast.spi.InternalCompletableFuture;
    22| import com.hazelcast.spi.serialization.SerializationService;
    23| import com.hazelcast.util.ExceptionUtil;
    24| import java.util.concurrent.ExecutionException;
    25| import java.util.concurrent.Executor;
    26| import java.util.concurrent.TimeUnit;
    27| import java.util.concurrent.TimeoutException;
    28| import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
    29| /**
    30|  * The Client Delegating Future is used to delegate {@link
    31|  * ClientInvocationFuture} to a user type to be used with {@code andThen()} or
    32|  * {@code get()}. It converts {@link ClientMessage} coming from {@link
    33|  * ClientInvocationFuture} to a user object.
    34|  *
    35|  * @param <V> Value type that the user expects
    36|  */
    37| public class ClientDelegatingFuture<V> implements InternalCompletableFuture<V> {


# ====================================================================
# FILE: hazelcast-client/src/main/java/com/hazelcast/client/util/ClientStateListener.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 40-81 ---
    40|         implements LifecycleListener {
    41|     private LifecycleEvent.LifecycleState currentState = STARTING;
    42|     private final Lock lock = new ReentrantLock();
    43|     private final Condition connectedCondition = lock.newCondition();
    44|     private final Condition disconnectedCondition = lock.newCondition();
    45|     /**
    46|      * Registers this instance with the provided client configuration
    47|      *
    48|      * @param clientConfig The client configuration to which this listener will be registered
    49|      */
    50|     public ClientStateListener(ClientConfig clientConfig) {
    51|         clientConfig.addListenerConfig(new ListenerConfig(this));
    52|     }
    53|     @Override
    54|     public void stateChanged(LifecycleEvent event) {
    55|         lock.lock();
    56|         try {
    57|             currentState = event.getState();
    58|             if (currentState.equals(CLIENT_CONNECTED) || currentState.equals(SHUTTING_DOWN) || currentState.equals(SHUTDOWN)) {
    59|                 connectedCondition.signalAll();
    60|             }
    61|             if (currentState.equals(CLIENT_DISCONNECTED) || currentState.equals(SHUTTING_DOWN) || currentState
    62|                     .equals(SHUTDOWN)) {
    63|                 disconnectedCondition.signalAll();
    64|             }
    65|         } finally {
    66|             lock.unlock();
    67|         }
    68|     }
    69|     /**
    70|      * Waits until the client is connected to cluster or the timeout expires.
    71|      * Does not wait if the client is already shutting down or shutdown.
    72|      *
    73|      * @param timeout the maximum time to wait
    74|      * @param unit    the time unit of the {@code timeout} argument
    75|      * @return true if the client is connected to the cluster. On returning false,
    76|      * you can check if timeout occured or the client is shutdown using {@code isShutdown} {@code getCurrentState}
    77|      * @throws InterruptedException
    78|      */
    79|     public boolean awaitConnected(long timeout, TimeUnit unit)
    80|             throws InterruptedException {
    81|         lock.lock();

