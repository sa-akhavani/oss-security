--- a/jspwiki-api/src/main/java/org/apache/wiki/api/Release.java
+++ b/jspwiki-api/src/main/java/org/apache/wiki/api/Release.java
@@ -40,21 +40,21 @@
      *  it is a bleeding-edge version.  Other possible values are "-alpha-" and "-beta-" for alpha and beta versions, respectively.
      *  <p>
      *  If the POSTFIX is empty, it is not added to the version string.
      */
     private static final String    POSTFIX       = "";
     /** The JSPWiki major version. */
     public static final int        VERSION       = 2;
     /** The JSPWiki revision. */
     public static final int        REVISION      = 12;
     /** The minor revision.  */
-    public static final int        MINORREVISION = 3;
+    public static final int        MINORREVISION = 2;
     /** The build number/identifier.  This is a String as opposed to an integer, just so that people can add other identifiers to it.
      * The build number is incremented every time a committer checks in code, and reset when a release is made.
      *  <p>
      *  If you are a person who likes to build his own releases, we recommend that you add your initials to this
      *  identifier (e.g. "13-jj", or "49-aj").
      *  <p>
      *  If the build identifier is empty, it is not added.
      */
     public static final String     BUILD         = "";
     /**

--- a/jspwiki-bootstrap/src/main/java/org/apache/wiki/bootstrap/WikiBootstrapServletContextListener.java
+++ b/jspwiki-bootstrap/src/main/java/org/apache/wiki/bootstrap/WikiBootstrapServletContextListener.java
@@ -16,47 +16,48 @@
  */
 package org.apache.wiki.bootstrap;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.apache.logging.log4j.core.LoggerContext;
 import org.apache.logging.log4j.core.config.Configuration;
 import org.apache.logging.log4j.core.config.ConfigurationSource;
 import org.apache.logging.log4j.core.config.properties.PropertiesConfigurationFactory;
 import org.apache.wiki.api.spi.Wiki;
 import org.apache.wiki.util.TextUtil;
+import javax.servlet.ServletContext;
 import javax.servlet.ServletContextEvent;
 import javax.servlet.ServletContextListener;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
+import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Properties;
 public class WikiBootstrapServletContextListener implements ServletContextListener {
     private static final Logger LOG = LogManager.getLogger( WikiBootstrapServletContextListener.class );
-    private static final String[] LOG4J_CONF = new String[] { "appender", "logger", "rootLogger", "filter", "status", "dest", "name", "properties", "property", "log4j2" };
     /** {@inheritDoc} */
     @Override
     public void contextInitialized( final ServletContextEvent sce ) {
         final Properties properties = initWikiSPIs( sce );
         initWikiLoggingFramework( properties );
     }
     /**
      * Locate and init JSPWiki SPIs' implementations
      *
      * @param sce associated servlet context.
      * @return JSPWiki configuration properties.
      */
     Properties initWikiSPIs( final ServletContextEvent sce ) {
         return Wiki.init( sce.getServletContext() );
     }
     /**
-     * Initialize the logging framework(s). By default, we try to load the log config statements from jspwiki.properties,
+     * Initialize the logging framework(s). By default we try to load the log config statements from jspwiki.properties,
      * unless the property jspwiki.use.external.logconfig=true, in that case we let the logging framework figure out the
      * logging configuration.
      *
      * @param properties JSPWiki configuration properties.
      * @return {@code true} if configuration was read from jspwiki.properties, {@code false} otherwise.
      */
     boolean initWikiLoggingFramework( final Properties properties ) {
         final String useExternalLogConfig = TextUtil.getStringProperty( properties, "jspwiki.use.external.logconfig", "false" );
         if ( useExternalLogConfig.equals( "false" ) ) {
             final ConfigurationSource source = createConfigurationSource( properties );
@@ -67,29 +68,21 @@
                 conf.initialize();
                 ctx.setConfiguration( conf );
                 LOG.info( "Log configuration reloaded from Wiki properties" );
             }
         }
         return useExternalLogConfig.equals( "false" );
     }
     ConfigurationSource createConfigurationSource( final Properties properties ) {
         final ByteArrayOutputStream out = new ByteArrayOutputStream();
         try {
-            final Properties log4JProperties = new Properties();
-            properties.forEach( ( k, v ) -> {
-                for( final String log4JNsProp : LOG4J_CONF ) {
-                    if( k.toString().startsWith( log4JNsProp ) ) {
-                        log4JProperties.put( k, v );
-                    }
-                }
-            } );
-            log4JProperties.store( out, null );
+            properties.store( out, null );
             final InputStream in = new ByteArrayInputStream( out.toByteArray() );
             return new ConfigurationSource( in );
         } catch( final IOException ioe ) {
             LOG.error( "Unable to load the properties file into Log4j2, default Log4J2 configuration will be applied.", ioe );
             return null;
         }
     }
     /** {@inheritDoc} */
     @Override
     public void contextDestroyed( final ServletContextEvent sce ) {

--- a/jspwiki-cache/src/main/java/org/apache/wiki/cache/CachingManager.java
+++ b/jspwiki-cache/src/main/java/org/apache/wiki/cache/CachingManager.java
@@ -90,19 +90,11 @@
      * @param val item to insert in the cache.
      */
     void put( String cacheName, Serializable key, Object val );
     /**
      * Removes an item from a cache.
      *
      * @param cacheName The cache in which the item to be removed lives.
      * @param key item's identifier.
      */
     void remove( String cacheName, Serializable key );
-    /**
-     * Register a listener associated with the given cache and type of listener.
-     * @param cacheName the name of the cache where the listener will be registered.
-     * @param listener the kind of listener to be registered
-     * @param args arguments needed to instantiate and register the listener.
-     * @return {@code true} if the listener is created & registered, {@code false} otherwise.
-     */
-    default boolean registerListener( String cacheName, String listener, Object... args ) { return false; }
 }

--- a/jspwiki-cache/src/main/java/org/apache/wiki/cache/EhcacheCachingManager.java
+++ b/jspwiki-cache/src/main/java/org/apache/wiki/cache/EhcacheCachingManager.java
@@ -10,38 +10,35 @@
     Unless required by applicable law or agreed to in writing,
     software distributed under the License is distributed on an
     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
     KIND, either express or implied.  See the License for the
     specific language governing permissions and limitations
     under the License.
  */
 package org.apache.wiki.cache;
 import net.sf.ehcache.Cache;
 import net.sf.ehcache.CacheManager;
-import net.sf.ehcache.Ehcache;
 import net.sf.ehcache.Element;
-import net.sf.ehcache.event.CacheEventListenerAdapter;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.apache.wiki.api.core.Engine;
 import org.apache.wiki.api.engine.Initializable;
 import org.apache.wiki.api.exceptions.WikiException;
 import org.apache.wiki.util.CheckedSupplier;
 import org.apache.wiki.util.TextUtil;
 import java.io.Serializable;
 import java.net.URL;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.atomic.AtomicBoolean;
 /**
  * Ehcache-based {@link CachingManager}.
  */
 public class EhcacheCachingManager implements CachingManager, Initializable {
     private static final Logger LOG = LogManager.getLogger( EhcacheCachingManager.class );
     private static final int DEFAULT_CACHE_SIZE = 1_000;
     private static final int DEFAULT_CACHE_EXPIRY_PERIOD = 24*60*60;
     final Map< String, Cache > cacheMap = new ConcurrentHashMap<>();
     final Map< String, CacheInfo > cacheStats = new ConcurrentHashMap<>();
     CacheManager cacheManager;
@@ -136,29 +133,14 @@
             cacheMap.get( cacheName ).put( new Element( key, val ) );
         }
     }
     /** {@inheritDoc} */
     @Override
     public void remove( final String cacheName, final Serializable key ) {
         if( keyAndCacheAreNotNull( cacheName, key ) ) {
             cacheMap.get( cacheName ).remove( key );
         }
     }
-    /** {@inheritDoc} */
-    @Override
-    public boolean registerListener( final String cacheName, final String listener, final Object... args ) {
-        if( enabled( cacheName ) && "expired".equals( listener ) ) {
-            final AtomicBoolean allRequested = ( AtomicBoolean )args[0];
-            final CacheEventListenerAdapter expiredCacheListenerAdapter = new CacheEventListenerAdapter() {
-                @Override
-                public void notifyElementExpired( final Ehcache cache, final Element element ) {
-                    allRequested.set( false ); // signal that the cache no longer contains all elements...
-                }
-            };
-            return cacheMap.get( cacheName ).getCacheEventNotificationService().registerListener( expiredCacheListenerAdapter );
-        }
-        return false;
-    }
     boolean keyAndCacheAreNotNull( final String cacheName, final Serializable key ) {
         return enabled( cacheName ) && key != null;
     }
 }

--- a/jspwiki-main/src/main/java/org/apache/wiki/ajax/AjaxUtil.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/ajax/AjaxUtil.java
@@ -48,22 +48,20 @@
 	 * 
 	 * @param path the RequestURI to search usually done by calling request.getRequestUri().
 	 * @param lastPart the previousPart of the path to search after.
 	 * @return the next part of the path.
 	 * @throws ServletException if {@code path} does not contain {@code lastPart}
 	 */
 	public static String getNextPathPart( String path, String lastPart ) throws ServletException {
         if( StringUtils.isBlank( path ) ) {
 			return null;
 		}
-                if (path.endsWith(lastPart))
-                        return lastPart;
 		if( !lastPart.endsWith( "/" ) ) {
 			lastPart += "/";
 		}
 		final int lastPartLength =  lastPart.length();
 		int index = path.indexOf( lastPart );
 		if( index < 0 ) {
 			lastPart = lastPart.substring( 0, lastPartLength - 1 );
 			index = path.indexOf( lastPart );
 			if( index < 0 ) {
 				throw new ServletException( "Invalid path provided " + path + " does not contain '" + lastPart + "'" );

--- a/jspwiki-main/src/main/java/org/apache/wiki/attachment/DefaultAttachmentManager.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/attachment/DefaultAttachmentManager.java
@@ -8,21 +8,20 @@
     with the License.  You may obtain a copy of the License at
        http://www.apache.org/licenses/LICENSE-2.0
     Unless required by applicable law or agreed to in writing,
     software distributed under the License is distributed on an
     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
     KIND, either express or implied.  See the License for the
     specific language governing permissions and limitations
     under the License.
  */
 package org.apache.wiki.attachment;
-import org.apache.commons.lang3.StringUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.apache.wiki.api.core.Attachment;
 import org.apache.wiki.api.core.Context;
 import org.apache.wiki.api.core.Engine;
 import org.apache.wiki.api.core.Page;
 import org.apache.wiki.api.exceptions.NoRequiredPropertyException;
 import org.apache.wiki.api.exceptions.ProviderException;
 import org.apache.wiki.api.providers.AttachmentProvider;
 import org.apache.wiki.api.spi.Wiki;
@@ -82,21 +81,21 @@
         } catch( final ReflectiveOperationException e ) {
             LOG.error( "Attachment provider class could not be instantiated", e );
         } catch( final NoRequiredPropertyException e ) {
             LOG.error( "Attachment provider did not find a property that it needed: {}", e.getMessage(), e );
             m_provider = null; // No, it did not work.
         } catch( final IOException e ) {
             LOG.error( "Attachment provider reports IO error", e );
             m_provider = null;
         }
         final String forceDownload = TextUtil.getStringProperty( props, PROP_FORCEDOWNLOAD, null );
-        if( StringUtils.isNotEmpty( forceDownload ) ) {
+        if( forceDownload != null && !forceDownload.isEmpty() ) {
             m_forceDownloadPatterns = forceDownload.toLowerCase().split( "\\s" );
         } else {
             m_forceDownloadPatterns = new String[ 0 ];
         }
     }
     /** {@inheritDoc} */
     @Override
     public boolean attachmentsEnabled() {
         return m_provider != null;
     }
@@ -163,21 +162,21 @@
     @Override
     public boolean forceDownload( String name ) {
         if( name == null || name.isEmpty() ) {
             return false;
         }
         name = name.toLowerCase();
         if( name.indexOf( '.' ) == -1 ) {
             return true;  // force download on attachments without extension or type indication
         }
         for( final String forceDownloadPattern : m_forceDownloadPatterns ) {
-            if( ( name.endsWith( forceDownloadPattern ) && !forceDownloadPattern.isEmpty() ) || "*".equals( forceDownloadPattern ) ) {
+            if( name.endsWith( forceDownloadPattern ) && !forceDownloadPattern.isEmpty() ) {
                 return true;
             }
         }
         return false;
     }
     /** {@inheritDoc} */
     @Override
     public InputStream getAttachmentStream( final Context ctx, final Attachment att ) throws ProviderException, IOException {
         if( m_provider == null ) {
             return null;

--- a/jspwiki-main/src/main/java/org/apache/wiki/auth/DefaultUserManager.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/auth/DefaultUserManager.java
@@ -225,24 +225,24 @@
     }
     /** {@inheritDoc} */
     @Override
     public UserProfile parseProfile( final Context context ) {
         final UserProfile profile = getUserProfile( context.getWikiSession() );
         final HttpServletRequest request = context.getHttpRequest();
         String loginName = request.getParameter( PARAM_LOGINNAME );
         String password = request.getParameter( PARAM_PASSWORD );
         String fullname = request.getParameter( PARAM_FULLNAME );
         String email = request.getParameter( PARAM_EMAIL );
-        loginName = StringUtils.trim( loginName );
+        loginName = InputValidator.isBlank( loginName ) ? null : loginName;
         password = InputValidator.isBlank( password ) ? null : password;
-        fullname = StringUtils.trim( fullname );
-        email = StringUtils.trim( email );
+        fullname = InputValidator.isBlank( fullname ) ? null : fullname;
+        email = InputValidator.isBlank( email ) ? null : email;
         if ( m_engine.getManager( AuthenticationManager.class ).isContainerAuthenticated() && context.getWikiSession().isAuthenticated() ) {
             loginName = context.getWikiSession().getLoginPrincipal().getName();
         }
         profile.setLoginName( loginName );
         profile.setEmail( email );
         profile.setFullname( fullname );
         profile.setPassword( password );
         return profile;
     }
     /** {@inheritDoc} */

--- a/jspwiki-main/src/main/java/org/apache/wiki/parser/JSPWikiMarkupParser.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/parser/JSPWikiMarkupParser.java
@@ -1,11 +1,11 @@
-    /*
+/*
     Licensed to the Apache Software Foundation (ASF) under one
     or more contributor license agreements.  See the NOTICE file
     distributed with this work for additional information
     regarding copyright ownership.  The ASF licenses this file
     to you under the Apache License, Version 2.0 (the
     "License"); you may not use this file except in compliance
     with the License.  You may obtain a copy of the License at
        http://www.apache.org/licenses/LICENSE-2.0
     Unless required by applicable law or agreed to in writing,
     software distributed under the License is distributed on an
@@ -188,32 +188,33 @@
      * Calls the heading listeners.
      *
      * @param param A Heading object.
      */
     private void callHeadingListenerChain( final Heading param ) {
         for( final HeadingListener h : m_headingListenerChain ) {
             h.headingAdded( m_context, param );
         }
     }
     /**
-     *  Creates a JDOM anchor element.  Can be overridden to change the URL creation, if you really know what you are doing.
+     *  Creates a JDOM anchor element.  Can be overridden to change the URL creation,
+     *  if you really know what you are doing.
      *
      *  @param type One of the types above
      *  @param link URL to which to link to
      *  @param text Link text
      *  @param section If a particular section identifier is required.
-     *  @return An 'A' element.
+     *  @return An A element.
      *  @since 2.4.78
      */
     private Element createAnchor( final int type, final String link, String text, String section ) {
-        text = TextUtil.escapeHTMLEntities( text );
-        section = TextUtil.escapeHTMLEntities( section );
+        text = escapeHTMLEntities( text );
+        section = escapeHTMLEntities( section );
         final Element el = new Element( "a" );
         el.setAttribute( "class", CLASS_TYPES[ type ] );
         el.setAttribute( "href", link + section );
         el.addContent( text );
         return el;
     }
     private Element makeLink( int type, final String link, String text, String section, final Iterator< Attribute > attributes ) {
         Element el = null;
         if( text == null ) {
             text = link;
@@ -234,25 +235,21 @@
                 break;
             case EMPTY:
                 el = new Element("u").addContent(text);
                 break;
             case LOCALREF:
                 el = createAnchor( LOCALREF, "#ref-"+m_context.getName()+"-"+link, "["+text+"]", "" );
                 break;
             case LOCAL:
                 el = new Element( "a" ).setAttribute( "class", CLASS_FOOTNOTE );
                 el.setAttribute( "name", "ref-" + m_context.getName() + "-" + link.substring( 1 ) );
-                if( !m_allowHTML ) {
-                    el.addContent( "[" + TextUtil.escapeHTMLEntities( text ) + "]" );
-                } else {
-                    el.addContent( "[" + text + "]" );
-                }
+                el.addContent( "[" + text + "]" );
                 break;
             case IMAGE:
                 el = new Element( "img" ).setAttribute( "class", "inline" );
                 el.setAttribute( "src", link );
                 el.setAttribute( "alt", text );
                 break;
             case IMAGELINK:
                 el = new Element( "img" ).setAttribute( "class", "inline" );
                 el.setAttribute( "src", link );
                 el.setAttribute( "alt", text );
@@ -339,21 +336,21 @@
                 LOG.warn( "Pushback failed: the line is probably too long.  Attempting to recover." );
             }
         }
         return s;
     }
     private int flushPlainText() {
         final int numChars = m_plainTextBuf.length();
         if( numChars > 0 ) {
             String buf;
             if( !m_allowHTML ) {
-                buf = TextUtil.escapeHTMLEntities( m_plainTextBuf.toString() );
+                buf = escapeHTMLEntities(m_plainTextBuf.toString());
             } else {
                 buf = m_plainTextBuf.toString();
             }
             m_plainTextBuf = new StringBuilder(20);
             try {
                 if( m_camelCaseLinks && !m_isEscaping && buf.length() > 3 ) {
                     while( m_camelCaseMatcher.contains( buf, m_camelCasePattern ) ) {
                         final MatchResult result = m_camelCaseMatcher.getMatch();
                         final String firstPart = buf.substring( 0, result.beginOffset( 0 ) );
                         String prefix = result.group( 1 );
@@ -395,20 +392,65 @@
                     m_currentElement.addContent( buf );
                 } else {
                     m_currentElement.addContent( buf );
                 }
             } catch( final IllegalDataException e ) {
                 m_currentElement.addContent( makeError(cleanupSuspectData( e.getMessage() )) );
             }
         }
         return numChars;
     }
+    /**
+     *  Escapes XML entities in a HTML-compatible way (i.e. does not escape entities that are already escaped).
+     *
+     *  @param buf
+     *  @return An escaped string.
+     */
+    private String escapeHTMLEntities( final String buf ) {
+        final StringBuilder tmpBuf = new StringBuilder( buf.length() + 20 );
+        for( int i = 0; i < buf.length(); i++ ) {
+            final char ch = buf.charAt(i);
+            if( ch == '<' ) {
+                tmpBuf.append("&lt;");
+            } else if( ch == '>' ) {
+                tmpBuf.append("&gt;");
+            } else if( ch == '\"' ) {
+                tmpBuf.append("&quot;");
+            } else if( ch == '&' ) {
+                boolean isEntity = false;
+                final StringBuilder entityBuf = new StringBuilder();
+                if( i < buf.length() -1 ) {
+                    for( int j = i; j < buf.length(); j++ ) {
+                        final char ch2 = buf.charAt( j );
+                        if( Character.isLetterOrDigit( ch2 ) || (ch2 == '#' && j == i+1) || ch2 == ';' || ch2 == '&' ) {
+                            entityBuf.append(ch2);
+                            if( ch2 == ';' ) {
+                                isEntity = true;
+                                break;
+                            }
+                        } else {
+                            break;
+                        }
+                    }
+                }
+                if( isEntity ) {
+                    tmpBuf.append( entityBuf );
+                    i = i + entityBuf.length() - 1;
+                } else {
+                    tmpBuf.append( "&amp;" );
+                }
+            } else {
+                tmpBuf.append( ch );
+            }
+        }
+        return tmpBuf.toString();
+    }
     private Element pushElement( final Element e ) {
         flushPlainText();
         m_currentElement.addContent( e );
         m_currentElement = e;
         return e;
     }
     private Element addElement( final Content e ) {
         if( e != null ) {
             flushPlainText();
             m_currentElement.addContent( e );
@@ -765,21 +807,21 @@
                         urlReference = callMutatorChain( m_externalLinkMutatorChain, urlReference );
                         if( m_linkParsingOperations.isImageLink( urlReference, isImageInlining(), getInlineImagePatterns() ) ) {
                             handleImageLink( urlReference, linktext, link.hasReference() );
                         } else {
                             makeLink( INTERWIKI, urlReference, linktext, null, link.getAttributes() );
                         }
                         if( m_linkParsingOperations.isExternalLink( urlReference ) ) {
                             addElement( outlinkImage() );
                         }
                     } else {
-                        final Object[] args = { TextUtil.escapeHTMLEntities( extWiki ) };
+                        final Object[] args = { escapeHTMLEntities( extWiki ) };
                         addElement( makeError( MessageFormat.format( rb.getString( "markupparser.error.nointerwikiref" ), args ) ) );
                     }
                 }
             } else if( linkref.startsWith( "#" ) ) {
                 makeLink( LOCAL, linkref, linktext, null, link.getAttributes() );
             } else if( TextUtil.isNumber( linkref ) ) {
                 makeLink( LOCALREF, linkref, linktext, null, link.getAttributes() );
             } else {
                 final int hashMark;
                 String attachment = m_engine.getManager( AttachmentManager.class ).getAttachmentInfoName( m_context, linkref );

--- a/jspwiki-main/src/main/java/org/apache/wiki/plugin/Image.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/plugin/Image.java
@@ -16,21 +16,20 @@
  */
 package org.apache.wiki.plugin;
 import org.apache.wiki.api.core.Attachment;
 import org.apache.wiki.api.core.Context;
 import org.apache.wiki.api.core.ContextEnum;
 import org.apache.wiki.api.core.Engine;
 import org.apache.wiki.api.exceptions.PluginException;
 import org.apache.wiki.api.exceptions.ProviderException;
 import org.apache.wiki.api.plugin.Plugin;
 import org.apache.wiki.attachment.AttachmentManager;
-import org.apache.wiki.parser.MarkupParser;
 import org.apache.wiki.util.TextUtil;
 import java.util.Map;
 /**
  *  Provides an image plugin for better control than is possible with a simple image inclusion.
  *  <br> Most parameters are equivalents of the html image attributes.
  *
  *  <p>Parameters : </p>
  *  <ul>
  *  <li><b>src</b> - the source (a URL) of the image (required parameter)</li>
  *  <li><b>align</b> - the alignment of the image</li>
@@ -44,42 +43,42 @@
  *  <li><b>class</b> - the associated class for the image</li>
  *  <li><b>border</b> - the border for the image</li>
  *  <li><b>title</b> - the title for the image, can be presented as a tooltip to the user</li>
  *  </ul>
  *
  *  @since 2.1.4.
  */
 public class Image implements Plugin {
     /** The parameter name for setting the src.  Value is <tt>{@value}</tt>. */
     public static final String PARAM_SRC      = "src";
-    /** The parameter name for setting the align parameter.  Value is <tt>{@value}</tt>. */
+    /** The parameter name for setting the align.  Value is <tt>{@value}</tt>. */
     public static final String PARAM_ALIGN    = "align";
     /** The parameter name for setting the height.  Value is <tt>{@value}</tt>. */
     public static final String PARAM_HEIGHT   = "height";
     /** The parameter name for setting the width.  Value is <tt>{@value}</tt>. */
     public static final String PARAM_WIDTH    = "width";
     /** The parameter name for setting the alt.  Value is <tt>{@value}</tt>. */
     public static final String PARAM_ALT      = "alt";
     /** The parameter name for setting the caption.  Value is <tt>{@value}</tt>. */
     public static final String PARAM_CAPTION  = "caption";
     /** The parameter name for setting the link.  Value is <tt>{@value}</tt>. */
     public static final String PARAM_LINK     = "link";
     /** The parameter name for setting the target.  Value is <tt>{@value}</tt>. */
     public static final String PARAM_TARGET   = "target";
     /** The parameter name for setting the style.  Value is <tt>{@value}</tt>. */
     public static final String PARAM_STYLE    = "style";
     /** The parameter name for setting the class.  Value is <tt>{@value}</tt>. */
     public static final String PARAM_CLASS    = "class";
     /** The parameter name for setting the border.  Value is <tt>{@value}</tt>. */
     public static final String PARAM_BORDER   = "border";
     /** The parameter name for setting the title.  Value is <tt>{@value}</tt>. */
-    public static final String PARAM_TITLE    = "title";
+    public static final String PARAM_TITLE   = "title";
     /**
      *  This method is used to clean away things like quotation marks which
      *  a malicious user could use to stop processing and insert javascript.
      */
     private static String getCleanParameter( final Map< String, String > params, final String paramId ) {
         return TextUtil.replaceEntities( params.get( paramId ) );
     }
     /**
      *  {@inheritDoc}
      */
@@ -128,37 +127,30 @@
         result.append( ">\n" );
         if( caption != null ) {
             result.append( "<caption>" ).append( caption ).append( "</caption>\n" );
         }
         result.append( "<tr><td" );
         if( cssclass != null ) {
             result.append( " class=\"" ).append( cssclass ).append( "\"" );
         }
         if( style != null ) {
             result.append( " style=\"" ).append( style );
-            if( result.charAt( result.length()-1 ) != ';' ) {
-                result.append( ";" );
-            }
+            if( result.charAt( result.length()-1 ) != ';' ) result.append(";");
             result.append("\"");
         }
         result.append( ">" );
         if( link != null ) {
             result.append( "<a href=\"" ).append( link ).append( "\"" );
             if( target != null ) {
                 result.append( " target=\"" ).append( target ).append( "\"" );
             }
             result.append(">");
-        }
-        if( !context.getBooleanWikiProperty( MarkupParser.PROP_ALLOWHTML, false ) ) {
-            if( src.startsWith( "data:" ) || src.startsWith( "javascript:" ) ) {
-                src = "http://invalid_url" + src;
-            }
         }
         result.append( "<img src=\"" ).append( src ).append( "\"" );
         if( ht != null ) {
             result.append( " height=\"" ).append( ht ).append( "\"" );
         }
         if( wt != null ) {
             result.append( " width=\"" ).append( wt ).append( "\"" );
         }
         if( alt != null ) {
             result.append( " alt=\"" ).append( alt ).append( "\"" );
@@ -167,23 +159,27 @@
             result.append( " border=\"" ).append( border ).append( "\"" );
         }
         result.append(" />");
         if( link != null ) {
             result.append("</a>");
         }
         result.append("</td></tr>\n");
         result.append("</table>\n");
         return result.toString();
     }
-    private boolean validTargetValue( final String s ) {
+    private boolean validTargetValue( final String s )
+    {
         if( s.equals("_blank")
-            || s.equals("_self")
-            || s.equals("_parent")
-            || s.equals("_top") ) {
+                || s.equals("_self")
+                || s.equals("_parent")
+                || s.equals("_top") )
+        {
             return true;
-        } else if( !s.isEmpty() ) { // check [a-zA-z]
+        }
+        else if( !s.isEmpty() ) // check [a-zA-z]
+        {
             final char c = s.charAt(0);
             return Character.isLowerCase(c) || Character.isUpperCase(c);
         }
         return false;
     }
 }

--- a/jspwiki-main/src/main/java/org/apache/wiki/plugin/SampleAjaxPlugin.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/plugin/SampleAjaxPlugin.java
@@ -20,40 +20,29 @@
 import org.apache.wiki.api.exceptions.PluginException;
 import org.apache.wiki.api.plugin.Plugin;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.util.List;
 import java.util.Map;
 /**
  * @since 2.10.2-svn10
- *
- * updated according to https://issues.apache.org/jira/browse/JSPWIKI-1195
  */
 public class SampleAjaxPlugin implements Plugin, WikiAjaxServlet {
 	private static final String SERVLET_MAPPING = "SampleAjaxPlugin";
 	@Override
-	public String execute( final Context context, final Map<String, String> params) throws PluginException {
-    		var id = Long.toString(System.currentTimeMillis());
-		var url = "/" + SERVLET_MAPPING + "/ajaxAction";
-		var ajaxParams = params.get("params");
-		var js = String.format("$('result%s').value='Loadingâ€¦';"+
-			"var token = Wiki.CsrfProtection;"+
-			"new Request.HTML({"+
-				"url: Wiki.JsonUrl + '%s', "+
-				"update:$('result%s'),"+
-				"onSuccess: function(data){console.log('Success',data);},"+
-				"onError: function(err){console.log('Error',err);}"+
-			"}).post('params=%s&X-XSRF-TOKEN='+token)", id, url, id, ajaxParams);
-		return String.format("<div onclick='%s' style='color: blue; cursor: pointer'>Press Me</div><div id='result%s'></div>", js, id);
-	}
+    public String execute( final Context context, final Map<String, String> params) throws PluginException {
+    	final String id = Integer.toString(this.hashCode());
+        return "<div onclick='Wiki.ajaxHtmlCall(\"/"+SERVLET_MAPPING+"/ajaxAction\",[12,45],\"result"+id+"\",\"Loading...\")' style='color: blue; cursor: pointer'>Press Me</div>\n"+
+                        "<div id='result"+id+"'></div>";
+    }
 	@Override
 	public String getServletMapping() {
 		return SERVLET_MAPPING;
 	}
 	@Override
 	public void service( final HttpServletRequest request, final HttpServletResponse response, final String actionName, final List< String > params )
 			throws ServletException, IOException {
 		try {
 			Thread.sleep( 5000 ); // Wait 5 seconds
 		} catch( final Exception e ) {

--- a/jspwiki-main/src/main/java/org/apache/wiki/providers/AbstractFileProvider.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/providers/AbstractFileProvider.java
@@ -41,21 +41,20 @@
 import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Date;
 import java.util.Enumeration;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 import java.util.TreeSet;
-import org.apache.commons.lang3.SystemUtils;
 /**
  *  Provides a simple directory based repository for Wiki pages.
  *  <P>
  *  All files have ".txt" appended to make life easier for those who insist on using Windows or other software which makes assumptions
  *  on the files contents based on its name.
  *  <p>
  *  This class functions as a superclass to all file based providers.
  *
  *  @since 2.1.21.
  */
@@ -108,21 +107,24 @@
         } else {
             if( !f.isDirectory() ) {
                 throw new IOException( "Page directory is not a directory: " + f.getAbsolutePath() );
             }
             if( !f.canWrite() ) {
                 throw new IOException( "Page directory is not writable: " + f.getAbsolutePath() );
             }
         }
         m_engine = engine;
         m_encoding = properties.getProperty( Engine.PROP_ENCODING, DEFAULT_ENCODING );
-        m_windowsHackNeeded = SystemUtils.IS_OS_WINDOWS;
+        final String os = System.getProperty( "os.name" ).toLowerCase();
+        if( os.startsWith( "windows" ) || os.equals( "nt" ) ) {
+            m_windowsHackNeeded = true;
+        }
         MAX_PROPLIMIT = TextUtil.getIntegerProperty( properties, PROP_CUSTOMPROP_MAXLIMIT, DEFAULT_MAX_PROPLIMIT );
         MAX_PROPKEYLENGTH = TextUtil.getIntegerProperty( properties, PROP_CUSTOMPROP_MAXKEYLENGTH, DEFAULT_MAX_PROPKEYLENGTH );
         MAX_PROPVALUELENGTH = TextUtil.getIntegerProperty( properties, PROP_CUSTOMPROP_MAXVALUELENGTH, DEFAULT_MAX_PROPVALUELENGTH );
         LOG.info( "Wikipages are read from '" + m_pageDirectory + "'" );
     }
     String getPageDirectory()
     {
         return m_pageDirectory;
     }
     private static final String[] WINDOWS_DEVICE_NAMES = {

--- a/jspwiki-main/src/main/java/org/apache/wiki/providers/BasicAttachmentProvider.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/providers/BasicAttachmentProvider.java
@@ -310,49 +310,45 @@
                     if( attachmentName.endsWith( ATTDIR_EXTENSION ) ) {
                         attachmentName = attachmentName.substring( 0, attachmentName.length() - ATTDIR_EXTENSION.length() );
                     } else {
                         final File propFile = new File( f, PROPERTY_FILE );
                         if( !propFile.exists() ) {
                             continue;
                         }
                     }
                     final Attachment att = getAttachmentInfo( page, attachmentName, WikiProvider.LATEST_VERSION );
                     if( att == null ) {
-                        LOG.error( "Attachment disappeared while reading information:"
-                                + " if you did not touch the repository, there is a serious bug somewhere or perhaps it"
-                                + " was deleted by antivirus software, etc. " + "Attachment = " + attachment
+                        throw new ProviderException( "Attachment disappeared while reading information:"
+                                + " if you did not touch the repository, there is a serious bug somewhere. " + "Attachment = " + attachment
                                 + ", decoded = " + attachmentName );
-                    } else {
-                        result.add( att );
                     }
+                    result.add( att );
                 }
             }
         }
         return result;
     }
     /**
      *  {@inheritDoc}
      */
     @Override
     public Collection< Attachment > findAttachments( final QueryItem[] query ) {
         return new ArrayList<>();
     }
     /**
      *  {@inheritDoc}
      */
     @Override
     public List< Attachment > listAllChanged( final Date timestamp ) throws ProviderException {
         final File attDir = new File( m_storageDir );
         if( !attDir.exists() ) {
-            if (!attDir.mkdirs()) {
-                throw new ProviderException( "Specified attachment directory " + m_storageDir + " does not exist!" );
-            }
+            throw new ProviderException( "Specified attachment directory " + m_storageDir + " does not exist!" );
         }
         final ArrayList< Attachment > list = new ArrayList<>();
         final String[] pagesWithAttachments = attDir.list( new AttachmentFilter() );
         if( pagesWithAttachments != null ) {
             for( final String pagesWithAttachment : pagesWithAttachments ) {
                 String pageId = unmangleName( pagesWithAttachment );
                 pageId = pageId.substring( 0, pageId.length() - DIR_EXTENSION.length() );
                 final Collection< Attachment > c = listAttachments( Wiki.contents().page( m_engine, pageId ) );
                 for( final Attachment att : c ) {
                     if( att.getLastModified().after( timestamp ) ) {

--- a/jspwiki-main/src/main/java/org/apache/wiki/providers/CachingAttachmentProvider.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/providers/CachingAttachmentProvider.java
@@ -33,42 +33,40 @@
 import org.apache.wiki.util.TextUtil;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Date;
 import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.Properties;
-import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicLong;
 /**
  * Provides a caching attachment provider.  This class rests on top of a real provider class and provides a cache to speed things up.
  * Only the Attachment objects are cached; the actual attachment contents are fetched always from the provider.
  *
  *  @since 2.1.64.
  */
 public class CachingAttachmentProvider implements AttachmentProvider {
     private static final Logger LOG = LogManager.getLogger( CachingAttachmentProvider.class );
     private AttachmentProvider provider;
     private CachingManager cachingManager;
-    private final AtomicBoolean allRequested = new AtomicBoolean();
+    private boolean allRequested;
     private final AtomicLong attachments = new AtomicLong( 0L );
     /**
      * {@inheritDoc}
      */
     @Override
     public void initialize( final Engine engine, final Properties properties ) throws NoRequiredPropertyException, IOException {
         LOG.info( "Initing CachingAttachmentProvider" );
         cachingManager = engine.getManager( CachingManager.class );
-        cachingManager.registerListener( CachingManager.CACHE_ATTACHMENTS, "expired", allRequested );
         final String classname;
         try {
             classname = TextUtil.getRequiredProperty( properties, AttachmentManager.PROP_PROVIDER, AttachmentManager.PROP_PROVIDER_DEPRECATED );
         } catch( final NoSuchElementException e ) {
             throw new NoRequiredPropertyException( e.getMessage(), AttachmentManager.PROP_PROVIDER );
         }
         try {
             provider = ClassUtil.buildInstance( "org.apache.wiki.providers", classname );
             LOG.debug( "Initializing real provider class {}", provider );
             provider.initialize( engine, properties );
@@ -114,28 +112,28 @@
     @Override
     public Collection< Attachment > findAttachments( final QueryItem[] query ) {
         return provider.findAttachments( query );
     }
     /**
      * {@inheritDoc}
      */
     @Override
     public List< Attachment > listAllChanged( final Date timestamp ) throws ProviderException {
         final List< Attachment > all;
-        if ( !allRequested.get() ) {
+        if ( !allRequested ) {
             all = provider.listAllChanged( timestamp );
             synchronized( this ) {
                 for( final Attachment att : all ) {
                     cachingManager.put( CachingManager.CACHE_ATTACHMENTS, att.getName(), att );
                 }
                 if( timestamp.getTime() == 0L ) { // all attachments requested
-                    allRequested.set( true );
+                    allRequested = true;
                     attachments.set( all.size() );
                 }
             }
         } else {
             final List< String > keys = cachingManager.keys( CachingManager.CACHE_ATTACHMENTS );
             all = new ArrayList<>();
             for( final String key : keys) {
                 final Attachment cachedAttachment = cachingManager.get( CachingManager.CACHE_ATTACHMENTS, key, () -> null );
                 if( cachedAttachment != null ) {
                     all.add( cachedAttachment );

--- a/jspwiki-main/src/main/java/org/apache/wiki/providers/CachingProvider.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/providers/CachingProvider.java
@@ -33,50 +33,48 @@
 import org.apache.wiki.render.RenderingManager;
 import org.apache.wiki.util.ClassUtil;
 import org.apache.wiki.util.TextUtil;
 import java.io.IOException;
 import java.util.Collection;
 import java.util.Date;
 import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.Properties;
 import java.util.TreeSet;
-import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicLong;
 /**
  *  Provides a caching page provider.  This class rests on top of a real provider class and provides a cache to speed things up.  Only
  *  if the cache copy of the page text has expired, we fetch it from the provider.
  *  <p>
  *  This class does not detect if someone has modified the page externally, not through JSPWiki routines.
  *  <p>
  *  Heavily based on ideas by Chris Brooking.
  *  <p>
  *  Since 2.10 uses the Ehcache library.
  *
  *  @since 1.6.4
  */
 public class CachingProvider implements PageProvider {
     private static final Logger LOG = LogManager.getLogger( CachingProvider.class );
     private CachingManager cachingManager;
     private PageProvider provider;
     private Engine engine;
-    private final AtomicBoolean allRequested = new AtomicBoolean();
+    private boolean allRequested;
     private final AtomicLong pages = new AtomicLong( 0L );
     /**
      *  {@inheritDoc}
      */
     @Override
     public void initialize( final Engine engine, final Properties properties ) throws NoRequiredPropertyException, IOException {
         LOG.debug( "Initing CachingProvider" );
         this.engine = engine;
         cachingManager = this.engine.getManager( CachingManager.class );
-        cachingManager.registerListener( CachingManager.CACHE_PAGES, "expired", allRequested );
         final String classname;
         try {
             classname = TextUtil.getRequiredProperty( properties, PageManager.PROP_PAGEPROVIDER );
         } catch( final NoSuchElementException e ) {
             throw new NoRequiredPropertyException( e.getMessage(), PageManager.PROP_PAGEPROVIDER );
         }
         try {
             provider = ClassUtil.buildInstance( "org.apache.wiki.providers", classname );
             LOG.debug( "Initializing real provider class {}", provider );
             provider.initialize( engine, properties );
@@ -189,27 +187,27 @@
             getPageInfoFromCache( page.getName() );
         }
         pages.incrementAndGet();
     }
     /**
      *  {@inheritDoc}
      */
     @Override
     public Collection< Page > getAllPages() throws ProviderException {
         final Collection< Page > all;
-        if ( !allRequested.get() ) {
+        if ( !allRequested ) {
             all = provider.getAllPages();
             synchronized( this ) {
                 for( final Page p : all ) {
                     cachingManager.put( CachingManager.CACHE_PAGES,  p.getName(), p );
                 }
-                allRequested.set( true );
+                allRequested = true;
             }
             pages.set( all.size() );
         } else {
             final List< String > keys = cachingManager.keys( CachingManager.CACHE_PAGES );
             all = new TreeSet<>();
             for( final String key : keys ) {
                 final Page cachedPage = cachingManager.get( CachingManager.CACHE_PAGES, key, () -> null );
                 if( cachedPage != null ) {
                     all.add( cachedPage );
                 }

--- a/jspwiki-main/src/main/java/org/apache/wiki/tags/CalendarTag.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/tags/CalendarTag.java
@@ -27,38 +27,37 @@
 import javax.servlet.jsp.JspWriter;
 import java.io.IOException;
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
 import java.util.Calendar;
 import java.util.Date;
 /**
  *  Provides a nice calendar.  Responds to the following HTTP parameters:
  *  <ul>
  *  <li>calendar.date - If this parameter exists, then the calendar
- *  date is taken from the month and year.  The date must be in ddMMyy format.
+ *  date is taken from the month and year.  The date must be in ddMMyy
+ *  format.
  *  <li>weblog.startDate - If calendar.date parameter does not exist,
  *  we then check this date.
  *  </ul>
  *
  *  If neither calendar.date nor weblog.startDate parameters exist,
  *  then the calendar will default to the current month.
  *
  *  @since 2.0
  */
 public class CalendarTag extends WikiTagBase {
     private static final long serialVersionUID = 0L;
     private static final Logger LOG = LogManager.getLogger( CalendarTag.class );
-    private static final int NUM_PAGES_TO_CHECK = 3;
     private SimpleDateFormat m_pageFormat;
     private SimpleDateFormat m_urlFormat;
     private SimpleDateFormat m_monthUrlFormat;
-    private boolean m_addIndex;
     private SimpleDateFormat m_dateFormat = new SimpleDateFormat( "ddMMyy" );
     /**
      *  {@inheritDoc}
      */
     @Override
     public void initTag()
     {
         super.initTag();
         m_pageFormat = m_urlFormat = m_monthUrlFormat = null;
         m_dateFormat = new SimpleDateFormat( "ddMMyy" );
@@ -103,60 +102,37 @@
     /**
      *  Set the format to be used for links for the months.
      *  
      *  @param format The format to set in the SimpleDateFormat fashion.
      *  
      *  @see SimpleDateFormat
      */
     public void setMonthurlformat( final String format )
     {
         m_monthUrlFormat = new SimpleDateFormat( format );
-    }
-    /**
-     *  Sets whether or not the pageFormat contains a page index at the end.
-	 *  This is the case for the WeblogPlugin.
-     *
-     *  @param addindex Whether a page index should be appended to the pageFormat
-     *
-     *  @see org.apache.wiki.plugin.WeblogPlugin
-     */
-    public void setAddindex( final boolean addIndex )
-    {
-        m_addIndex = addIndex;
     }
     private String format( final String txt ) {
         final Page p = m_wikiContext.getPage();
         if( p != null ) {
             return TextUtil.replaceString( txt, "%p", p.getName() );
         }
         return txt;
     }
     /**
      *  Returns a link to the given day.
      */
     private String getDayLink( final Calendar day ) {
         final Engine engine = m_wikiContext.getEngine();
         final String result;
         if( m_pageFormat != null ) {
             final String pagename = m_pageFormat.format( day.getTime() );
-            var somePageExistsOnThisDay = false;
-            if (m_addIndex) {
-		    for (int pageIdx = 1; pageIdx <= NUM_PAGES_TO_CHECK; pageIdx++) {
-                        if( engine.getManager( PageManager.class ).wikiPageExists( pagename+pageIdx ) ) {
-                            somePageExistsOnThisDay = true;
-                            break;
-                        }
-                }
-            } else {
-                somePageExistsOnThisDay = engine.getManager( PageManager.class ).wikiPageExists( pagename );
-            }
-            if( somePageExistsOnThisDay ) {
+            if( engine.getManager( PageManager.class ).wikiPageExists( pagename ) ) {
                 if( m_urlFormat != null ) {
                     final String url = m_urlFormat.format( day.getTime() );
                     result = "<td class=\"link\"><a href=\""+url+"\">"+day.get( Calendar.DATE )+"</a></td>";
                 } else {
                     result = "<td class=\"link\"><a href=\""+m_wikiContext.getViewURL( pagename )+"\">"+
                              day.get( Calendar.DATE )+"</a></td>";
                 }
             } else {
                 result = "<td class=\"days\">"+day.get(Calendar.DATE)+"</td>";
             }

--- a/jspwiki-main/src/main/java/org/apache/wiki/ui/admin/DefaultAdminBeanManager.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/ui/admin/DefaultAdminBeanManager.java
@@ -43,29 +43,27 @@
 import java.util.Collection;
 import java.util.List;
 /**
  *  Provides a manager class for all AdminBeans within JSPWiki.  This class also manages registration for any
  *  AdminBean which is also a JMX bean.
  *
  *  @since  2.5.52
  */
 public class DefaultAdminBeanManager implements WikiEventListener, AdminBeanManager {
     private final Engine m_engine;
-    private final String applicationName;
     private ArrayList< AdminBean > m_allBeans;
     private final MBeanServer m_mbeanServer;
     private static final Logger LOG = LogManager.getLogger( DefaultAdminBeanManager.class );
     public DefaultAdminBeanManager( final Engine engine ) {
         LOG.info("Using JDK 1.5 Platform MBeanServer");
         m_mbeanServer = MBeanServerFactory15.getServer();
         m_engine = engine;
-        applicationName = m_engine.getWikiProperties().getProperty("jspwiki.applicationName").trim();
         if( m_mbeanServer != null ) {
             LOG.info( m_mbeanServer.getClass().getName() );
             LOG.info( m_mbeanServer.getDefaultDomain() );
         }
         m_engine.addWikiEventListener( this );
         initialize();
     }
     /** {@inheritDoc} */
     @Override
 	public void initialize() {
@@ -105,21 +103,21 @@
             LOG.error( "Your admin bean is not very good", e );
         } catch( final MalformedObjectNameException e ) {
             LOG.error( "Your admin bean name is not very good", e );
         } catch( final NullPointerException e ) {
             LOG.error( "Evil NPE occurred", e );
         }
     }
     private ObjectName getObjectName( final AdminBean ab ) throws MalformedObjectNameException {
         final String component = getJMXTitleString( ab.getType() );
         final String title     = ab.getTitle();
-        return new ObjectName(String.format("%s:component=%s,name=%s (%s)", Release.APPNAME, component, title, applicationName));
+        return new ObjectName( Release.APPNAME + ":component=" + component + ",name=" + title );
     }
     /**
      *  Registers all the beans from a collection of WikiModuleInfos.  If some of the beans fail, logs the message and keeps going to the
      *  next bean.
      *
      *  @param c Collection of WikiModuleInfo instances
      */
     private void registerBeans( final Collection< WikiModuleInfo > c ) {
         for( final WikiModuleInfo wikiModuleInfo : c ) {
             final String abname = wikiModuleInfo.getAdminBeanClass();

--- a/jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/ImageLinkNodePostProcessorState.java
+++ b/jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/ImageLinkNodePostProcessorState.java
@@ -8,20 +8,21 @@
     with the License.  You may obtain a copy of the License at
        http://www.apache.org/licenses/LICENSE-2.0
     Unless required by applicable law or agreed to in writing,
     software distributed under the License is distributed on an
     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
     KIND, either express or implied.  See the License for the
     specific language governing permissions and limitations
     under the License.
  */
 package org.apache.wiki.markdown.extensions.jspwikilinks.postprocessor;
+import com.vladsch.flexmark.ast.HtmlInline;
 import com.vladsch.flexmark.util.ast.Node;
 import com.vladsch.flexmark.util.ast.NodeTracker;
 import com.vladsch.flexmark.util.sequence.CharSubSequence;
 import org.apache.wiki.api.core.Context;
 import org.apache.wiki.markdown.nodes.JSPWikiLink;
 import org.apache.wiki.parser.LinkParsingOperations;
 /**
  * {@link NodePostProcessorState} which further post processes image links.
  */
 public class ImageLinkNodePostProcessorState implements NodePostProcessorState< JSPWikiLink > {
@@ -33,23 +34,23 @@
         this.urlRef = urlRef;
         this.linkOperations = new LinkParsingOperations( wikiContext );
     }
     /**
      * {@inheritDoc}
      *
      * @see NodePostProcessorState#process(NodeTracker, Node)
      */
     @Override
     public void process( final NodeTracker state, final JSPWikiLink link ) {
-        final WikiHtmlInline img = WikiHtmlInline.of( "<img class=\"inline\" " +
-                                                               "src=\"" + urlRef + "\" " +
-                                                               "alt=\"" + link.getText().toString() + "\" />" );
+        final HtmlInline img = new HtmlInline( CharSubSequence.of( "<img class=\"inline\" " +
+                                                                        "src=\"" + urlRef + "\" " +
+                                                                        "alt=\"" + link.getText().toString() + "\" />" ) );
         if( ( isLinkFromText && linkOperations.isExternalLink( link.getText().toString() ) ) ||
                 ( isLinkFromText && linkOperations.linkExists( link.getText().toString() ) ) ) {
             link.setUrl( CharSubSequence.of( urlRef ) );
             link.removeChildren();
             link.appendChild( img );
             state.nodeAdded( img );
         } else {
             NodePostProcessorStateCommonOperations.addContent( state, link, img );
         }
     }

--- a/jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/LocalLinkNodePostProcessorState.java
+++ b/jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/LocalLinkNodePostProcessorState.java
@@ -8,20 +8,21 @@
     with the License.  You may obtain a copy of the License at
        http://www.apache.org/licenses/LICENSE-2.0
     Unless required by applicable law or agreed to in writing,
     software distributed under the License is distributed on an
     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
     KIND, either express or implied.  See the License for the
     specific language governing permissions and limitations
     under the License.
  */
 package org.apache.wiki.markdown.extensions.jspwikilinks.postprocessor;
+import com.vladsch.flexmark.ast.HtmlInline;
 import com.vladsch.flexmark.util.ast.Node;
 import com.vladsch.flexmark.util.ast.NodeTracker;
 import com.vladsch.flexmark.util.sequence.CharSubSequence;
 import org.apache.oro.text.regex.Pattern;
 import org.apache.wiki.api.core.Context;
 import org.apache.wiki.api.core.ContextEnum;
 import org.apache.wiki.attachment.AttachmentManager;
 import org.apache.wiki.markdown.nodes.JSPWikiLink;
 import org.apache.wiki.parser.LinkParsingOperations;
 import org.apache.wiki.parser.MarkupParser;
@@ -49,46 +50,46 @@
      */
     @Override
     public void process( final NodeTracker state, final JSPWikiLink link ) {
         final int hashMark = link.getUrl().toString().indexOf( '#' );
         final String attachment = wikiContext.getEngine().getManager( AttachmentManager.class ).getAttachmentInfoName( wikiContext, link.getUrl().toString() );
         if( attachment != null  ) {
             if( !linkOperations.isImageLink( link.getUrl().toString(), isImageInlining, inlineImagePatterns ) ) {
                 final String attlink = wikiContext.getURL( ContextEnum.PAGE_ATTACH.getRequestContext(), link.getUrl().toString() );
                 link.setUrl( CharSubSequence.of( attlink ) );
                 link.removeChildren();
-                final WikiHtmlInline content = WikiHtmlInline.of( link.getText().toString(), wikiContext );
+                final HtmlInline content = new HtmlInline( CharSubSequence.of( link.getText().toString() ) );
                 link.appendChild( content );
                 state.nodeAddedWithChildren( content );
                 addAttachmentLink( state, link );
             } else {
                 new ImageLinkNodePostProcessorState( wikiContext, attachment, link.hasRef() ).process( state, link );
             }
         } else if( hashMark != -1 ) { // It's an internal Wiki link, but to a named section
             final String namedSection = link.getUrl().toString().substring( hashMark + 1 );
             link.setUrl( CharSubSequence.of( link.getUrl().toString().substring( 0, hashMark ) ) );
             final String matchedLink = linkOperations.linkIfExists( link.getUrl().toString() );
             if( matchedLink != null ) {
                 String sectref = "#section-" + wikiContext.getEngine().encodeName( matchedLink + "-" + MarkupParser.wikifyLink( namedSection ) );
-                sectref = sectref.replace( '%', '_' );
+                sectref = sectref.replace('%', '_');
                 link.setUrl( CharSubSequence.of( wikiContext.getURL( ContextEnum.PAGE_VIEW.getRequestContext(), link.getUrl().toString() + sectref ) ) );
             } else {
                 link.setUrl( CharSubSequence.of( wikiContext.getURL( ContextEnum.PAGE_EDIT.getRequestContext(), link.getUrl().toString() ) ) );
             }
         } else {
             if( linkOperations.linkExists( link.getUrl().toString() ) ) {
                 link.setUrl( CharSubSequence.of( wikiContext.getURL( ContextEnum.PAGE_VIEW.getRequestContext(), link.getUrl().toString() ) ) );
             } else {
                 link.setUrl( CharSubSequence.of( wikiContext.getURL( ContextEnum.PAGE_EDIT.getRequestContext(), link.getUrl().toString() ) ) );
             }
         }
     }
     void addAttachmentLink( final NodeTracker state, final JSPWikiLink link ) {
         final String infolink = wikiContext.getURL( ContextEnum.PAGE_INFO.getRequestContext(), link.getWikiLink() );
         final String imglink = wikiContext.getURL( ContextEnum.PAGE_NONE.getRequestContext(), "images/attachment_small.png" );
-        final WikiHtmlInline aimg = WikiHtmlInline.of( "<a href=\""+ infolink + "\" class=\"infolink\">" +
-                                                              "<img src=\""+ imglink + "\" border=\"0\" alt=\"(info)\" />" +
-                                                           "</a>" ) ;
+        final HtmlInline aimg = new HtmlInline( CharSubSequence.of( "<a href=\""+ infolink + "\" class=\"infolink\">" +
+                                                                       "<img src=\""+ imglink + "\" border=\"0\" alt=\"(info)\" />" +
+                                                                     "</a>" ) );
         link.insertAfter( aimg );
         state.nodeAdded( aimg );
     }
 }

--- a/jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/NodePostProcessorStateCommonOperations.java
+++ b/jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/NodePostProcessorStateCommonOperations.java
@@ -8,22 +8,24 @@
     with the License.  You may obtain a copy of the License at
        http://www.apache.org/licenses/LICENSE-2.0
     Unless required by applicable law or agreed to in writing,
     software distributed under the License is distributed on an
     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
     KIND, either express or implied.  See the License for the
     specific language governing permissions and limitations
     under the License.
  */
 package org.apache.wiki.markdown.extensions.jspwikilinks.postprocessor;
+import com.vladsch.flexmark.ast.HtmlInline;
 import com.vladsch.flexmark.util.ast.Node;
 import com.vladsch.flexmark.util.ast.NodeTracker;
+import com.vladsch.flexmark.util.sequence.CharSubSequence;
 import org.apache.wiki.api.core.Context;
 import org.apache.wiki.api.core.ContextEnum;
 import org.apache.wiki.markdown.nodes.JSPWikiLink;
 import org.apache.wiki.parser.MarkupParser;
 /**
  * Internal class with common post-processor operations.
  */
 class NodePostProcessorStateCommonOperations {
     static void addContent( final NodeTracker state, final Node node, final Node content ) {
         final Node previous = node.getPrevious() != null ? node.getPrevious() : node.getNext();
@@ -35,28 +37,31 @@
             state.nodeAddedWithChildren( content );
         } else {
             node.getParent().appendChild( content );
         }
     }
     static void addOutlinkImage( final NodeTracker state, final Node node, final Context wikiContext, final boolean useOutlinkImage ) {
         final Boolean wysiwygVariable = wikiContext.getVariable( Context.VAR_WYSIWYG_EDITOR_MODE );
         final boolean wysiwygEditorMode = wysiwygVariable != null && wysiwygVariable;
         if( useOutlinkImage && !wysiwygEditorMode ) {
             final String m_outlinkImageURL = wikiContext.getURL( ContextEnum.PAGE_NONE.getRequestContext(), MarkupParser.OUTLINK_IMAGE );
-            final WikiHtmlInline img = WikiHtmlInline.of( "<img class=\""+ MarkupParser.OUTLINK + "\" " + "alt=\"\" src=\""+ m_outlinkImageURL + "\" />" ) ;
+            final HtmlInline img = new HtmlInline( CharSubSequence.of( "<img class=\""+ MarkupParser.OUTLINK + "\" " +
+                                                                              "alt=\"\" src=\""+ m_outlinkImageURL + "\" />" ) );
             node.insertAfter( img );
             state.nodeAdded( img );
         }
     }
     static String inlineLinkTextOnWysiwyg( final NodeTracker state, final JSPWikiLink link, final boolean wysiwygEditorMode ) {
         final String line = link.getUrl().toString();
         if( wysiwygEditorMode ) {
-            final WikiHtmlInline content = WikiHtmlInline.of( "[" + line + "]()" );
+            final HtmlInline content = new HtmlInline( CharSubSequence.of( "[" + line + "]()" ) );
             addContent( state, link, content );
         }
         return line;
     }
     static void makeError( final NodeTracker state, final Node node, final String errMsg ) {
-        final WikiHtmlInline error = WikiHtmlInline.of( "<span class=\"error\">" + errMsg + "</span>" );
+        final HtmlInline error = new HtmlInline( CharSubSequence.of( "<span class=\"error\">" +
+                                                                     errMsg +
+                                                                     "</span>" ) );
         addContent( state, node, error );
     }
 }

--- a/jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/PluginLinkNodePostProcessorState.java
+++ b/jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/PluginLinkNodePostProcessorState.java
@@ -8,20 +8,21 @@
     with the License.  You may obtain a copy of the License at
        http://www.apache.org/licenses/LICENSE-2.0
     Unless required by applicable law or agreed to in writing,
     software distributed under the License is distributed on an
     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
     KIND, either express or implied.  See the License for the
     specific language governing permissions and limitations
     under the License.
  */
 package org.apache.wiki.markdown.extensions.jspwikilinks.postprocessor;
+import com.vladsch.flexmark.ast.HtmlInline;
 import com.vladsch.flexmark.ext.toc.TocBlock;
 import com.vladsch.flexmark.util.ast.Node;
 import com.vladsch.flexmark.util.ast.NodeTracker;
 import com.vladsch.flexmark.util.sequence.CharSubSequence;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.apache.wiki.api.core.Context;
 import org.apache.wiki.api.exceptions.PluginException;
 import org.apache.wiki.api.plugin.Plugin;
 import org.apache.wiki.markdown.nodes.JSPWikiLink;
@@ -50,21 +51,21 @@
     public void process( final NodeTracker state, final JSPWikiLink link ) {
         if( link.getText().toString().startsWith( "{TableOfContents" ) ) {
             handleTableOfContentsPlugin( state, link );
             return;
         }
         PluginContent pluginContent = null;
         try {
             pluginContent = PluginContent.parsePluginLine( wikiContext, link.getUrl().toString(), -1 ); // -1 == do not generate _bounds parameter
             if( pluginContent != null ) {
                 final String pluginInvocation = pluginInvocation( link.getText().toString(), pluginContent );
-                final WikiHtmlInline content = WikiHtmlInline.of( pluginInvocation );
+                final HtmlInline content = new HtmlInline( CharSubSequence.of( pluginInvocation ) );
                 pluginContent.executeParse( wikiContext );
                 NodePostProcessorStateCommonOperations.addContent( state, link, content );
             }
         } catch( final PluginException e ) {
             LOG.info( wikiContext.getRealPage().getWiki() + " : " + wikiContext.getRealPage().getName() + " - Failed to insert plugin: " + e.getMessage() );
             if( !m_wysiwygEditorMode ) {
                 final ResourceBundle rbPlugin = Preferences.getBundle( wikiContext, Plugin.CORE_PLUGINS_RESOURCEBUNDLE );
                 NodePostProcessorStateCommonOperations.makeError( state, link, MessageFormat.format( rbPlugin.getString( "plugin.error.insertionfailed" ),
                                                                                                                          wikiContext.getRealPage().getWiki(),
                                                                                                                          wikiContext.getRealPage().getName(),
@@ -87,26 +88,26 @@
         final String pluginInvocation = pluginContent.invoke( wikiContext );
         if( pluginMarkup.equals( pluginInvocation + "()" ) ) { // plugin line markup == plugin execution + "()" -> hasn't been executed
             return pluginMarkup;
         } else {
             return pluginInvocation;
         }
     }
     void handleTableOfContentsPlugin(final NodeTracker state, final JSPWikiLink link) {
         if( !m_wysiwygEditorMode ) {
             final ResourceBundle rb = Preferences.getBundle( wikiContext, Plugin.CORE_PLUGINS_RESOURCEBUNDLE );
-            final WikiHtmlInline divToc = WikiHtmlInline.of( "<div class=\"toc\">\n" );
-            final WikiHtmlInline divCollapseBox = WikiHtmlInline.of( "<div class=\"collapsebox\">\n" );
-            final WikiHtmlInline divsClosing = WikiHtmlInline.of( "</div>\n</div>\n" );
-            final WikiHtmlInline h4Title = WikiHtmlInline.of( "<h4 id=\"section-TOC\">" + // FIXME proper plugin parameters handling
-                                                                   rb.getString( "tableofcontents.title" ) +
-                                                                   "</h4>\n" );
+            final HtmlInline divToc = new HtmlInline( CharSubSequence.of( "<div class=\"toc\">\n" ) );
+            final HtmlInline divCollapseBox = new HtmlInline( CharSubSequence.of( "<div class=\"collapsebox\">\n" ) );
+            final HtmlInline divsClosing = new HtmlInline( CharSubSequence.of( "</div>\n</div>\n" ) );
+            final HtmlInline h4Title = new HtmlInline( CharSubSequence.of( "<h4 id=\"section-TOC\">" + // FIXME proper plugin parameters handling
+                                                                           rb.getString( "tableofcontents.title" ) +
+                                                                           "</h4>\n" ) );
             final TocBlock toc = new TocBlock( CharSubSequence.of( "[TOC]" ), CharSubSequence.of( "levels=1-3" ) );
             link.insertAfter( divToc );
             divToc.insertAfter( divCollapseBox );
             divCollapseBox.insertAfter( h4Title );
             h4Title.insertAfter( toc );
             toc.insertAfter( divsClosing );
         } else {
             NodePostProcessorStateCommonOperations.inlineLinkTextOnWysiwyg( state, link, m_wysiwygEditorMode );
         }
         removeLink( state, link );

--- a/jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/VariableLinkNodePostProcessorState.java
+++ b/jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/VariableLinkNodePostProcessorState.java
@@ -8,22 +8,25 @@
     with the License.  You may obtain a copy of the License at
        http://www.apache.org/licenses/LICENSE-2.0
     Unless required by applicable law or agreed to in writing,
     software distributed under the License is distributed on an
     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
     KIND, either express or implied.  See the License for the
     specific language governing permissions and limitations
     under the License.
  */
 package org.apache.wiki.markdown.extensions.jspwikilinks.postprocessor;
+import com.vladsch.flexmark.ast.HtmlInline;
 import com.vladsch.flexmark.util.ast.Node;
 import com.vladsch.flexmark.util.ast.NodeTracker;
+import com.vladsch.flexmark.util.sequence.CharSubSequence;
+import org.apache.commons.text.StringEscapeUtils;
 import org.apache.wiki.api.core.Context;
 import org.apache.wiki.api.exceptions.NoSuchVariableException;
 import org.apache.wiki.markdown.nodes.JSPWikiLink;
 import org.apache.wiki.variables.VariableManager;
 /**
  * {@link NodePostProcessorState} which further post processes WikiVariable links.
  */
 public class VariableLinkNodePostProcessorState implements NodePostProcessorState< JSPWikiLink > {
     private final Context wikiContext;
     private final boolean m_wysiwygEditorMode;
@@ -36,18 +39,18 @@
      * {@inheritDoc}
      *
      * @see NodePostProcessorState#process(NodeTracker, Node)
      */
     @Override
     public void process( final NodeTracker state, final JSPWikiLink link ) {
         final String variable = NodePostProcessorStateCommonOperations.inlineLinkTextOnWysiwyg( state, link, m_wysiwygEditorMode );
         if( !m_wysiwygEditorMode ) {
             try {
                 final String parsedVariable = wikiContext.getEngine().getManager( VariableManager.class ).parseAndGetValue( wikiContext, variable );
-                final WikiHtmlInline content = WikiHtmlInline.of( parsedVariable, wikiContext );
+                final HtmlInline content = new HtmlInline( CharSubSequence.of( StringEscapeUtils.escapeXml11( parsedVariable ) ) );
                 NodePostProcessorStateCommonOperations.addContent( state, link, content );
             } catch( final NoSuchVariableException e ) {
                 NodePostProcessorStateCommonOperations.makeError( state, link, "No such variable: " + variable + " (" + e.getMessage() + ")" );
             }
         }
     }
 }

--- a/jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/WikiHtmlInline.java
+++ b//dev/null
@@ -1,43 +0,0 @@
-/*
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-       http://www.apache.org/licenses/LICENSE-2.0
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
- */
-package org.apache.wiki.markdown.extensions.jspwikilinks.postprocessor;
-import com.vladsch.flexmark.ast.HtmlInline;
-import com.vladsch.flexmark.util.sequence.BasedSequence;
-import org.apache.wiki.api.core.Context;
-import org.apache.wiki.parser.MarkupParser;
-import org.apache.wiki.util.TextUtil;
-/**
- * <p>Regular {@link HtmlInline} get escaped depending on the value of the {@code MarkupParser.PROP_ALLOWHTML} property.</p>
- * <p>However, wikilink post processors inject additional HtmlInline that must not be escaped. Subclassing {@link HtmlInline}
- * allows us to register a custom {@code NodeRenderingHandler} at {@code JSPWikiLinkRenderer} to bypass this limitation.</p>
- */
-public class WikiHtmlInline extends HtmlInline {
-    private WikiHtmlInline( final BasedSequence chars ) {
-        super( chars );
-    }
-    public static WikiHtmlInline of( final String str ) {
-        return new WikiHtmlInline( BasedSequence.of( str ) );
-    }
-    public static WikiHtmlInline of( final String str, final Context context ) {
-        final boolean allowHtml = context.getBooleanWikiProperty( MarkupParser.PROP_ALLOWHTML, false );
-        if( allowHtml ) {
-            return WikiHtmlInline.of( str );
-        } else {
-            return new WikiHtmlInline( BasedSequence.of( TextUtil.escapeHTMLEntities( str ) ) );
-        }
-    }
-}

--- a/jspwiki-markdown/src/main/java/org/apache/wiki/markdown/renderer/JSPWikiLinkRenderer.java
+++ b/jspwiki-markdown/src/main/java/org/apache/wiki/markdown/renderer/JSPWikiLinkRenderer.java
@@ -14,58 +14,48 @@
     specific language governing permissions and limitations
     under the License.
 */
 package org.apache.wiki.markdown.renderer;
 import com.vladsch.flexmark.html.HtmlWriter;
 import com.vladsch.flexmark.html.renderer.LinkType;
 import com.vladsch.flexmark.html.renderer.NodeRenderer;
 import com.vladsch.flexmark.html.renderer.NodeRendererContext;
 import com.vladsch.flexmark.html.renderer.NodeRenderingHandler;
 import com.vladsch.flexmark.html.renderer.ResolvedLink;
-import org.apache.wiki.markdown.extensions.jspwikilinks.postprocessor.WikiHtmlInline;
 import org.apache.wiki.markdown.nodes.JSPWikiLink;
 import java.util.HashSet;
 import java.util.Set;
 /**
  * Flexmark {@link NodeRenderer} for {@link JSPWikiLink}s.
  */
 public class JSPWikiLinkRenderer implements NodeRenderer {
     /**
      * {@inheritDoc}
      *
      * @see com.vladsch.flexmark.html.renderer.NodeRenderer#getNodeRenderingHandlers()
      */
     @Override
     public Set< NodeRenderingHandler< ? > > getNodeRenderingHandlers() {
         final HashSet< NodeRenderingHandler< ? > > set = new HashSet<>();
         set.add( new NodeRenderingHandler<>( JSPWikiLink.class, new NodeRenderingHandler.CustomNodeRenderer<>() {
             /**
              * {@inheritDoc}
              */
             @Override
-            public void render( final JSPWikiLink node, final NodeRendererContext context, final HtmlWriter html ) {
+            public void render(final JSPWikiLink node, final NodeRendererContext context, final HtmlWriter html) {
                 if (context.isDoNotRenderLinks()) {
                     context.renderChildren(node);
                 } else {
                     final ResolvedLink resolvedLink = context.resolveLink(LinkType.LINK, node.getUrl().unescape(), null);
                     html.attr("href", resolvedLink.getUrl());
                     if (node.getTitle().isNotNull()) {
                         html.attr("title", node.getTitle().unescape());
                     }
                     html.srcPos(node.getChars()).withAttr(resolvedLink).tag("a");
                     context.renderChildren(node);
                     html.tag("/a");
                 }
             }
         } ) );
-        set.add( new NodeRenderingHandler<>( WikiHtmlInline.class, new NodeRenderingHandler.CustomNodeRenderer<>() {
-            /**
-             * {@inheritDoc}
-             */
-            @Override
-            public void render( final WikiHtmlInline node, final NodeRendererContext context, final HtmlWriter html ) {
-                html.raw( node.getChars().normalizeEOL() );
-            }
-        } ) );
         return set;
     }
 }

--- a/jspwiki-markdown/src/main/java/org/apache/wiki/parser/markdown/MarkdownDocument.java
+++ b/jspwiki-markdown/src/main/java/org/apache/wiki/parser/markdown/MarkdownDocument.java
@@ -13,31 +13,30 @@
     KIND, either express or implied.  See the License for the
     specific language governing permissions and limitations
     under the License.
  */
 package org.apache.wiki.parser.markdown;
 import com.vladsch.flexmark.ext.attributes.AttributesExtension;
 import com.vladsch.flexmark.ext.definition.DefinitionExtension;
 import com.vladsch.flexmark.ext.footnotes.FootnoteExtension;
 import com.vladsch.flexmark.ext.tables.TablesExtension;
 import com.vladsch.flexmark.ext.toc.TocExtension;
-import com.vladsch.flexmark.html.HtmlRenderer;
 import com.vladsch.flexmark.parser.Parser;
 import com.vladsch.flexmark.parser.ParserEmulationProfile;
 import com.vladsch.flexmark.util.ast.Node;
 import com.vladsch.flexmark.util.data.MutableDataSet;
 import com.vladsch.flexmark.util.misc.Extension;
 import org.apache.oro.text.regex.Pattern;
 import org.apache.wiki.api.core.Context;
 import org.apache.wiki.api.core.Page;
 import org.apache.wiki.markdown.MarkdownForJSPWikiExtension;
-import org.apache.wiki.parser.MarkupParser;
+import org.apache.wiki.parser.JSPWikiMarkupParser;
 import org.apache.wiki.parser.WikiDocument;
 import java.util.Arrays;
 import java.util.List;
 /**
  * Simple placeholder for Markdown Nodes
  */
 public class MarkdownDocument extends WikiDocument {
     private static final long serialVersionUID = 1L;
     private final Node md;
     public MarkdownDocument( final Page page, final Node md ) {
@@ -50,21 +49,20 @@
     /**
      * Configuration options for MarkdownRenderers.
      *
      * @param context current wiki context
      * @return configuration options for MarkdownRenderers.
      */
     public static MutableDataSet options( final Context context, final boolean isImageInlining, final List< Pattern > inlineImagePatterns ) {
         final MutableDataSet options = new MutableDataSet();
         options.setFrom( ParserEmulationProfile.COMMONMARK );
         options.set( AttributesExtension.ASSIGN_TEXT_ATTRIBUTES, true );
-        options.set( FootnoteExtension.FOOTNOTE_LINK_REF_CLASS, MarkupParser.CLASS_FOOTNOTE_REF );
-        options.set( HtmlRenderer.ESCAPE_HTML, !context.getBooleanWikiProperty( MarkupParser.PROP_ALLOWHTML, false ) );
+        options.set( FootnoteExtension.FOOTNOTE_LINK_REF_CLASS, JSPWikiMarkupParser.CLASS_FOOTNOTE_REF );
         options.set( Parser.EXTENSIONS, Arrays.asList( new Extension[] { new MarkdownForJSPWikiExtension( context, isImageInlining, inlineImagePatterns ),
                                                                          AttributesExtension.create(),
                                                                          DefinitionExtension.create(),
                                                                          FootnoteExtension.create(),
                                                                          TablesExtension.create(),
                                                                          TocExtension.create() } ) );
         return options;
     }
 }

--- a/jspwiki-util/src/main/java/org/apache/wiki/util/CryptoUtil.java
+++ b/jspwiki-util/src/main/java/org/apache/wiki/util/CryptoUtil.java
@@ -12,39 +12,43 @@
     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
     KIND, either express or implied.  See the License for the
     specific language governing permissions and limitations
     under the License.  
  */
 package org.apache.wiki.util;
 import java.nio.charset.StandardCharsets;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.security.SecureRandom;
+import java.util.Arrays;
 import java.util.Base64;
 import java.util.Random;
 /**
  * Hashes and verifies salted SHA-1 passwords, which are compliant with RFC
  * 2307.
  */
-public final class CryptoUtil {
+public final class CryptoUtil
+{
     private static final String SSHA = "{SSHA}";
     private static final String SHA1 = "{SHA-1}";
     private static final String SHA256 = "{SHA-256}";
     private static final Random RANDOM = new SecureRandom();
     private static final int DEFAULT_SALT_SIZE = 8;
     private static final Object HELP = "--help";
     private static final Object HASH = "--hash";
     private static final Object VERIFY = "--verify";
     /**
      * Private constructor to prevent direct instantiation.
      */
-    private CryptoUtil() {}
+    private CryptoUtil()
+    {
+    }
     /**
      * <p>
      * Convenience method for hashing and verifying salted SHA-1 or SHA-256 passwords from
      * the command line. This method requires <code>commons-codec-1.3.jar</code>
      * (or a newer version) to be on the classpath. Command line arguments are
      * as follows:
      * </p>
      * <ul>
      * <li><code>--hash <var>password</var> SSHA</code> - hashes <var>password</var></code>
      * and prints a password digest that looks like this: <blockquote><code>{SSHA}yfT8SRT/WoOuNuA6KbJeF10OznZmb28=</code></blockquote></li>
@@ -55,69 +59,80 @@
      * password supplied is the same as the one used to create the original
      * digest, <code>true</code> will be printed; otherwise <code>false</code></li>
      * </ul>
      * <p>For example, one way to use this utility is to change to JSPWiki's <code>build</code> directory
      * and type the following command:</p>
      * <blockquote><code>java -cp JSPWiki.jar:../lib/commons-codec-1.3.jar org.apache.wiki.util.CryptoUtil --hash mynewpassword</code></blockquote>
      * 
      * @param args arguments for this method as described above
      * @throws Exception Catches nothing; throws everything up.
      */
-    public static void main( final String[] args ) throws Exception {
-        if( args.length == 0 || ( args.length == 1 && HELP.equals( args[0] ) ) ) {
+    public static void main( final String[] args ) throws Exception
+    {
+        if( args.length == 0 || (args.length == 1 && HELP.equals( args[0] )) )
+        {
             System.out.println( "Usage: CryptoUtil [options] " );
             System.out.println( "   --hash   password algorithm             create hash for password" );
             System.out.println( "   --verify password digest algorithm      verify password for digest" );
             System.out.println( "Valid algorithm options are {SSHA} and {SHA-256}. If no algorithm is specified or an unsupported algorithm is specified, SHA-256 is used." );
         }
-        if( HASH.equals( args[0] ) ) {
-            if( args.length < 2 ) {
+        if( HASH.equals( args[0] ) )
+        {
+            if( args.length < 2 )
+            {
                 throw new IllegalArgumentException( "Error: --hash requires a 'password' argument." );
             }
             final String password = args[1].trim();
             final String algorithm = args.length > 2 ? args[2].trim() : SHA256;
             System.out.println( CryptoUtil.getSaltedPassword( password.getBytes( StandardCharsets.UTF_8 ), algorithm ) );
-        } else if( VERIFY.equals( args[0] ) ) {
-            if( args.length < 3 ) {
+        }
+        else if( VERIFY.equals( args[0] ) )
+        {
+            if( args.length < 3 )
+            {
                 throw new IllegalArgumentException( "Error: --hash requires 'password' and 'digest' arguments." );
             }
             final String password = args[1].trim();
             final String digest = args[2].trim();
             System.out.println( CryptoUtil.verifySaltedPassword( password.getBytes( StandardCharsets.UTF_8 ), digest ) );
-        } else {
+        }
+        else
+        {
             System.out.println( "Wrong usage. Try --help." );
         }
     }
     /**
      * <p>
      * Creates an RFC 2307-compliant salted, hashed password with the SHA1 or SHA-256
      * MessageDigest algorithm. After the password is digested, the first 20 or 32
      * bytes of the digest will be the actual password hash; the remaining bytes
      * will be a randomly generated salt of length {@link #DEFAULT_SALT_SIZE},
      * for example: <blockquote><code>{SSHA}3cGWem65NCEkF5Ew5AEk45ak8LHUWAwPVXAyyw==</code></blockquote>
      * </p>
      * <p>
      * In layman's terms, the formula is
-     * <code>digest( secret + salt ) + salt</code>. The resulting digest is Base64-encoded.
+     * <code>digest( secret + salt ) + salt</code>. The resulting digest is
+     * Base64-encoded.
      * </p>
      * <p>
      * Note that successive invocations of this method with the same password
      * will result in different hashes! (This, of course, is exactly the point.)
      * </p>
      * 
      * @param password the password to be digested
      * @return the Base64-encoded password hash, prepended by
      *         <code>{SSHA}</code> or <code>{SHA256}</code>.
      * @throws NoSuchAlgorithmException If your JVM does not supply the necessary algorithm. Should not happen.
      */
-    public static String getSaltedPassword( final byte[] password, final String algorithm ) throws NoSuchAlgorithmException {
-        final byte[] salt = new byte[ DEFAULT_SALT_SIZE ];
+    public static String getSaltedPassword(final byte[] password, final String algorithm ) throws NoSuchAlgorithmException
+    {
+        final byte[] salt = new byte[DEFAULT_SALT_SIZE];
         RANDOM.nextBytes( salt );
         return getSaltedPassword( password, salt, algorithm );
     }
     /**
      * <p>
      * Helper method that creates an RFC 2307-compliant salted, hashed password with the SHA1 or SHA256
      * MessageDigest algorithm. After the password is digested, the first 20 or 32
      * bytes of the digest will be the actual password hash; the remaining bytes
      * will be the salt. Thus, supplying a password <code>testing123</code>
      * and a random salt <code>foo</code> produces the hash when using SHA1:
@@ -125,75 +140,88 @@
      * <blockquote><code>{SSHA}yfT8SRT/WoOuNuA6KbJeF10OznZmb28=</code></blockquote>
      * <p>
      * In layman's terms, the formula is
      * <code>digest( secret + salt ) + salt</code>. The resulting digest is Base64-encoded.</p>
      * 
      * @param password the password to be digested
      * @param salt the random salt
      * @return the Base64-encoded password hash, prepended by <code>{SSHA}</code> or <code>{SHA256}</code>.
      * @throws NoSuchAlgorithmException If your JVM does not supply the necessary algorithm. Should not happen.
      */
-    static String getSaltedPassword( final byte[] password, final byte[] salt, final String algorithm ) throws NoSuchAlgorithmException {
+    static String getSaltedPassword(final byte[] password, final byte[] salt, final String algorithm ) throws NoSuchAlgorithmException
+    {
         final String algorithmToUse = algorithm.equals(SSHA) ? SHA1 : algorithm;
         final MessageDigest digest = MessageDigest.getInstance( algorithmToUse.substring( 1, algorithmToUse.length() -1 ) );
         digest.update( password );
         final byte[] hash = digest.digest( salt );
         final byte[] all = new byte[hash.length + salt.length];
         System.arraycopy(hash, 0, all, 0, hash.length);
         System.arraycopy(salt, 0, all, hash.length, salt.length);
         final byte[] base64 = Base64.getEncoder().encode( all );
         return algorithm + new String( base64, StandardCharsets.UTF_8 );
     }
     /**
      *  Compares a password to a given entry and returns true, if it matches.
      *
      *  @param password The password in bytes.
      *  @param entry The password entry, typically starting with {SSHA}.
      *  @return True, if the password matches.
      *  @throws NoSuchAlgorithmException If there is no SHA available.
      */
-    public static boolean verifySaltedPassword( final byte[] password, final String entry ) throws NoSuchAlgorithmException {
-        if( !entry.startsWith( SSHA ) && !entry.startsWith( SHA256 ) ) {
+    public static boolean verifySaltedPassword(final byte[] password, final String entry ) throws NoSuchAlgorithmException
+    {
+        if( !entry.startsWith( SSHA ) && !entry.startsWith( SHA256 ) )
+        {
             throw new IllegalArgumentException( "Hash not prefixed by expected algorithm; is it really a salted hash?" );
         }
         final String algorithm = entry.startsWith( SSHA ) ? SSHA : SHA256;
-        final byte[] challenge = Base64.getDecoder().decode( entry.substring( algorithm.length() ).getBytes( StandardCharsets.UTF_8 ) );
-        final byte[] passwordHash = extractPasswordHash( challenge, algorithm.equals( SSHA ) ? 20 : 32 );
-        final byte[] salt = extractSalt( challenge, algorithm.equals( SSHA ) ? 20 : 32  );
-        final String algorithmToUse = algorithm.equals( SSHA ) ? SHA1 : algorithm;
+        final byte[] challenge = Base64.getDecoder().decode( entry.substring( algorithm.length() )
+                .getBytes( StandardCharsets.UTF_8 ) );
+        final byte[] passwordHash = extractPasswordHash( challenge, algorithm.equals(SSHA) ? 20 : 32 );
+        final byte[] salt = extractSalt( challenge, algorithm.equals(SSHA) ? 20 : 32  );
+        final String algorithmToUse = algorithm.equals(SSHA) ? SHA1 : algorithm;
         final MessageDigest digest = MessageDigest.getInstance( algorithmToUse.substring( 1, algorithmToUse.length() -1 ) );
         digest.update( password );
         final byte[] hash = digest.digest( salt );
-        return MessageDigest.isEqual( passwordHash, hash );
+        return Arrays.equals( passwordHash, hash );
     }
     /**
      * Helper method that extracts the hashed password fragment from a supplied salted SHA-1 or SHA-256 digest
-     * by taking all the characters before position 20 or 32 depending on algorithm.
-     * 
-     * @param digest the salted digest, which is assumed to have been previously decoded from Base64.
+     * by taking all of the characters before position 20 or 32 depending on algorithm.
+     * 
+     * @param digest the salted digest, which is assumed to have been
+     *            previously decoded from Base64.
      * @return the password hash
-     * @throws IllegalArgumentException if the length of the supplied digest is less than or equal to 20 bytes
-     */
-    static byte[] extractPasswordHash( final byte[] digest, final int hashLength ) throws IllegalArgumentException {
-        if( digest.length < hashLength ) {
+     * @throws IllegalArgumentException if the length of the supplied digest is
+     *             less than or equal to 20 bytes
+     */
+    static byte[] extractPasswordHash(final byte[] digest, final int hashLength ) throws IllegalArgumentException
+    {
+        if( digest.length < hashLength )
+        {
             throw new IllegalArgumentException( "Hash was shorter than expected; could not extract password hash!" );
         }
-        final byte[] hash = new byte[ hashLength ];
-        System.arraycopy( digest, 0, hash, 0, hashLength );
+        final byte[] hash = new byte[hashLength];
+        System.arraycopy(digest, 0, hash, 0, hashLength);
         return hash;
     }
     /**
-     * Helper method that extracts the salt from supplied salted digest by taking all the characters after a given index.
-     * 
-     * @param digest the salted digest, which is assumed to have been previously decoded from Base64.
+     * Helper method that extracts the salt from supplied salted digest by taking all of the
+     * characters after a given index.
+     * 
+     * @param digest the salted digest, which is assumed to have been previously
+     *            decoded from Base64.
      * @return the salt
-     * @throws IllegalArgumentException if the length of the supplied digest is less than given length.
-     */
-    static byte[] extractSalt( final byte[] digest, final int hashLength ) throws IllegalArgumentException {
-        if( digest.length <= hashLength ) {
+     * @throws IllegalArgumentException if the length of the supplied digest is
+     *             less than given length.
+     */
+    static byte[] extractSalt(final byte[] digest, final int hashLength ) throws IllegalArgumentException
+    {
+        if( digest.length <= hashLength )
+        {
             throw new IllegalArgumentException( "Hash was shorter than expected; we found no salt!" );
         }
         final byte[] salt = new byte[digest.length - hashLength];
         System.arraycopy(digest, hashLength, salt, 0, digest.length - hashLength);
         return salt;
     }
 }

--- a/jspwiki-util/src/main/java/org/apache/wiki/util/TextUtil.java
+++ b/jspwiki-util/src/main/java/org/apache/wiki/util/TextUtil.java
@@ -585,65 +585,20 @@
                 }
                 clean.append( ch );
                 isWord = false;
             } else {
                 isWord = true;
             }
         }
         return clean.toString();
     }
     /**
-     *  Escapes XML entities in an HTML-compatible way (i.e. does not escape entities that are already escaped).
-     *
-     *  @param buf String to be escaped.
-     *  @return An escaped string.
-     */
-    public static String escapeHTMLEntities( final String buf ) {
-        final StringBuilder tmpBuf = new StringBuilder( buf.length() + 20 );
-        for( int i = 0; i < buf.length(); i++ ) {
-            final char ch = buf.charAt(i);
-            if( ch == '<' ) {
-                tmpBuf.append("&lt;");
-            } else if( ch == '>' ) {
-                tmpBuf.append("&gt;");
-            } else if( ch == '\"' ) {
-                tmpBuf.append("&quot;");
-            } else if( ch == '&' ) {
-                boolean isEntity = false;
-                final StringBuilder entityBuf = new StringBuilder();
-                if( i < buf.length() -1 ) {
-                    for( int j = i; j < buf.length(); j++ ) {
-                        final char ch2 = buf.charAt( j );
-                        if( Character.isLetterOrDigit( ch2 ) || (ch2 == '#' && j == i+1) || ch2 == ';' || ch2 == '&' ) {
-                            entityBuf.append(ch2);
-                            if( ch2 == ';' ) {
-                                isEntity = true;
-                                break;
-                            }
-                        } else {
-                            break;
-                        }
-                    }
-                }
-                if( isEntity ) {
-                    tmpBuf.append( entityBuf );
-                    i = i + entityBuf.length() - 1;
-                } else {
-                    tmpBuf.append( "&amp;" );
-                }
-            } else {
-                tmpBuf.append( ch );
-            }
-        }
-        return tmpBuf.toString();
-    }
-    /**
      *  Creates a Properties object based on an array which contains alternatively a key and a value.  It is useful
      *  for generating default mappings. For example:
      *  <pre>
      *     String[] properties = { "jspwiki.property1", "value1", "jspwiki.property2", "value2 };
      *     Properties props = TextUtil.createPropertes( values );
      *     System.out.println( props.getProperty("jspwiki.property1") );
      *  </pre>
      *  would output "value1".
      *
      *  @param values Alternating key and value pairs.
