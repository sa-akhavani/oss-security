# ====================================================================
# FILE: jspwiki-api/src/main/java/org/apache/wiki/api/Release.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 30-70 ---
    30|  *  @since  1.0
    31|  */
    32| public final class Release {
    33|     private static final String VERSION_SEPARATORS = ".-";
    34|     /**
    35|      *  This is the default application name.
    36|      */
    37|     public static final String     APPNAME       = "JSPWiki";
    38|     /**
    39|      *  This should be empty when doing a release - otherwise keep it as "-git-" so that whenever someone checks out the code, they know
    40|      *  it is a bleeding-edge version.  Other possible values are "-alpha-" and "-beta-" for alpha and beta versions, respectively.
    41|      *  <p>
    42|      *  If the POSTFIX is empty, it is not added to the version string.
    43|      */
    44|     private static final String    POSTFIX       = "";
    45|     /** The JSPWiki major version. */
    46|     public static final int        VERSION       = 2;
    47|     /** The JSPWiki revision. */
    48|     public static final int        REVISION      = 12;
    49|     /** The minor revision.  */
    50|     public static final int        MINORREVISION = 2;
    51|     /** The build number/identifier.  This is a String as opposed to an integer, just so that people can add other identifiers to it.
    52|      * The build number is incremented every time a committer checks in code, and reset when a release is made.
    53|      *  <p>
    54|      *  If you are a person who likes to build his own releases, we recommend that you add your initials to this
    55|      *  identifier (e.g. "13-jj", or "49-aj").
    56|      *  <p>
    57|      *  If the build identifier is empty, it is not added.
    58|      */
    59|     public static final String     BUILD         = "";
    60|     /**
    61|      *  This is the generic version string you should use when printing out the version.  It is of
    62|      *  the form "VERSION.REVISION.MINORREVISION[-POSTFIX][-BUILD]".
    63|      */
    64|     public static final String     VERSTR        = VERSION + "." +
    65|                                                    REVISION + "." +
    66|                                                    MINORREVISION +
    67|                                                    POSTFIX +
    68|                                                    BUILD;
    69|     /** Private constructor prevents instantiation. */
    70|     private Release() {


# ====================================================================
# FILE: jspwiki-bootstrap/src/main/java/org/apache/wiki/bootstrap/WikiBootstrapServletContextListener.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 6-90 ---
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.bootstrap;
    18| import org.apache.logging.log4j.LogManager;
    19| import org.apache.logging.log4j.Logger;
    20| import org.apache.logging.log4j.core.LoggerContext;
    21| import org.apache.logging.log4j.core.config.Configuration;
    22| import org.apache.logging.log4j.core.config.ConfigurationSource;
    23| import org.apache.logging.log4j.core.config.properties.PropertiesConfigurationFactory;
    24| import org.apache.wiki.api.spi.Wiki;
    25| import org.apache.wiki.util.TextUtil;
    26| import javax.servlet.ServletContext;
    27| import javax.servlet.ServletContextEvent;
    28| import javax.servlet.ServletContextListener;
    29| import java.io.ByteArrayInputStream;
    30| import java.io.ByteArrayOutputStream;
    31| import java.io.File;
    32| import java.io.IOException;
    33| import java.io.InputStream;
    34| import java.util.Properties;
    35| public class WikiBootstrapServletContextListener implements ServletContextListener {
    36|     private static final Logger LOG = LogManager.getLogger( WikiBootstrapServletContextListener.class );
    37|     /** {@inheritDoc} */
    38|     @Override
    39|     public void contextInitialized( final ServletContextEvent sce ) {
    40|         final Properties properties = initWikiSPIs( sce );
    41|         initWikiLoggingFramework( properties );
    42|     }
    43|     /**
    44|      * Locate and init JSPWiki SPIs' implementations
    45|      *
    46|      * @param sce associated servlet context.
    47|      * @return JSPWiki configuration properties.
    48|      */
    49|     Properties initWikiSPIs( final ServletContextEvent sce ) {
    50|         return Wiki.init( sce.getServletContext() );
    51|     }
    52|     /**
    53|      * Initialize the logging framework(s). By default we try to load the log config statements from jspwiki.properties,
    54|      * unless the property jspwiki.use.external.logconfig=true, in that case we let the logging framework figure out the
    55|      * logging configuration.
    56|      *
    57|      * @param properties JSPWiki configuration properties.
    58|      * @return {@code true} if configuration was read from jspwiki.properties, {@code false} otherwise.
    59|      */
    60|     boolean initWikiLoggingFramework( final Properties properties ) {
    61|         final String useExternalLogConfig = TextUtil.getStringProperty( properties, "jspwiki.use.external.logconfig", "false" );
    62|         if ( useExternalLogConfig.equals( "false" ) ) {
    63|             final ConfigurationSource source = createConfigurationSource( properties );
    64|             if( source != null ) {
    65|                 final PropertiesConfigurationFactory factory = new PropertiesConfigurationFactory();
    66|                 final LoggerContext ctx = ( LoggerContext ) LogManager.getContext( this.getClass().getClassLoader(), false );
    67|                 final Configuration conf = factory.getConfiguration( ctx, source );
    68|                 conf.initialize();
    69|                 ctx.setConfiguration( conf );
    70|                 LOG.info( "Log configuration reloaded from Wiki properties" );
    71|             }
    72|         }
    73|         return useExternalLogConfig.equals( "false" );
    74|     }
    75|     ConfigurationSource createConfigurationSource( final Properties properties ) {
    76|         final ByteArrayOutputStream out = new ByteArrayOutputStream();
    77|         try {
    78|             properties.store( out, null );
    79|             final InputStream in = new ByteArrayInputStream( out.toByteArray() );
    80|             return new ConfigurationSource( in );
    81|         } catch( final IOException ioe ) {
    82|             LOG.error( "Unable to load the properties file into Log4j2, default Log4J2 configuration will be applied.", ioe );
    83|             return null;
    84|         }
    85|     }
    86|     /** {@inheritDoc} */
    87|     @Override
    88|     public void contextDestroyed( final ServletContextEvent sce ) {
    89|     }
    90| }


# ====================================================================
# FILE: jspwiki-cache/src/main/java/org/apache/wiki/cache/CachingManager.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 80-100 ---
    80|      * @param supplier if the element is not cached, try to retrieve from the cached system.
    81|      * @throws E the supplier may throw a checked exception, which is propagated upwards.
    82|      * @return The requested item or {@code null} if either the cache is not enabled or the item is not present on the cache / cached service.
    83|      */
    84|     < T, E extends Exception > T get( String cacheName, Serializable key, CheckedSupplier< T, E > supplier ) throws E;
    85|     /**
    86|      * Puts an item on a cache.
    87|      *
    88|      * @param cacheName The cache in which the item will live.
    89|      * @param key item's identifier.
    90|      * @param val item to insert in the cache.
    91|      */
    92|     void put( String cacheName, Serializable key, Object val );
    93|     /**
    94|      * Removes an item from a cache.
    95|      *
    96|      * @param cacheName The cache in which the item to be removed lives.
    97|      * @param key item's identifier.
    98|      */
    99|     void remove( String cacheName, Serializable key );
   100| }


# ====================================================================
# FILE: jspwiki-cache/src/main/java/org/apache/wiki/cache/EhcacheCachingManager.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-54 ---
     1| /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.cache;
    18| import net.sf.ehcache.Cache;
    19| import net.sf.ehcache.CacheManager;
    20| import net.sf.ehcache.Element;
    21| import org.apache.logging.log4j.LogManager;
    22| import org.apache.logging.log4j.Logger;
    23| import org.apache.wiki.api.core.Engine;
    24| import org.apache.wiki.api.engine.Initializable;
    25| import org.apache.wiki.api.exceptions.WikiException;
    26| import org.apache.wiki.util.CheckedSupplier;
    27| import org.apache.wiki.util.TextUtil;
    28| import java.io.Serializable;
    29| import java.net.URL;
    30| import java.util.Collections;
    31| import java.util.List;
    32| import java.util.Map;
    33| import java.util.Properties;
    34| import java.util.concurrent.ConcurrentHashMap;
    35| /**
    36|  * Ehcache-based {@link CachingManager}.
    37|  */
    38| public class EhcacheCachingManager implements CachingManager, Initializable {
    39|     private static final Logger LOG = LogManager.getLogger( EhcacheCachingManager.class );
    40|     private static final int DEFAULT_CACHE_SIZE = 1_000;
    41|     private static final int DEFAULT_CACHE_EXPIRY_PERIOD = 24*60*60;
    42|     final Map< String, Cache > cacheMap = new ConcurrentHashMap<>();
    43|     final Map< String, CacheInfo > cacheStats = new ConcurrentHashMap<>();
    44|     CacheManager cacheManager;
    45|     /** {@inheritDoc} */
    46|     @Override
    47|     public void shutdown() {
    48|         if(!cacheMap.isEmpty()) {
    49|             CacheManager.getInstance().shutdown();
    50|             cacheMap.clear();
    51|             cacheStats.clear();
    52|         }
    53|     }
    54|     /** {@inheritDoc} */

# --- HUNK 2: Lines 123-146 ---
   123|                 }
   124|                 return value;
   125|             }
   126|         }
   127|         return null;
   128|     }
   129|     /** {@inheritDoc} */
   130|     @Override
   131|     public void put( final String cacheName, final Serializable key, final Object val ) {
   132|         if( keyAndCacheAreNotNull( cacheName, key ) ) {
   133|             cacheMap.get( cacheName ).put( new Element( key, val ) );
   134|         }
   135|     }
   136|     /** {@inheritDoc} */
   137|     @Override
   138|     public void remove( final String cacheName, final Serializable key ) {
   139|         if( keyAndCacheAreNotNull( cacheName, key ) ) {
   140|             cacheMap.get( cacheName ).remove( key );
   141|         }
   142|     }
   143|     boolean keyAndCacheAreNotNull( final String cacheName, final Serializable key ) {
   144|         return enabled( cacheName ) && key != null;
   145|     }
   146| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/ajax/AjaxUtil.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 38-77 ---
    38| 			return gson.toJson( input );
    39| 		}
    40| 		return "";
    41| 	}
    42| 	/**
    43| 	 * Given a requestUri path, find the next uri "fragment" after the "/lastPart/" one.
    44| 	 * E.g. given url "/test/abc/travel", and lastPart "abc", this will return "travel". Given lastPart "test" will return "abc".
    45| 	 * 
    46| 	 * This could be done better using a <a href="http://en.wikipedia.org/wiki/URL_Template">URITemplate</a>
    47| 	 * (as <a href="https://tools.ietf.org/html/rfc6570">RFC6570</a>) 
    48| 	 * 
    49| 	 * @param path the RequestURI to search usually done by calling request.getRequestUri().
    50| 	 * @param lastPart the previousPart of the path to search after.
    51| 	 * @return the next part of the path.
    52| 	 * @throws ServletException if {@code path} does not contain {@code lastPart}
    53| 	 */
    54| 	public static String getNextPathPart( String path, String lastPart ) throws ServletException {
    55|         if( StringUtils.isBlank( path ) ) {
    56| 			return null;
    57| 		}
    58| 		if( !lastPart.endsWith( "/" ) ) {
    59| 			lastPart += "/";
    60| 		}
    61| 		final int lastPartLength =  lastPart.length();
    62| 		int index = path.indexOf( lastPart );
    63| 		if( index < 0 ) {
    64| 			lastPart = lastPart.substring( 0, lastPartLength - 1 );
    65| 			index = path.indexOf( lastPart );
    66| 			if( index < 0 ) {
    67| 				throw new ServletException( "Invalid path provided " + path + " does not contain '" + lastPart + "'" );
    68| 			}
    69| 		}
    70| 		path = path.substring( index + lastPartLength );
    71| 		index = path.indexOf( "/" );
    72| 		if( index == -1 ) {
    73| 			index = path.indexOf( "#" );
    74| 			if( index == -1 ) {
    75| 				index = path.indexOf( "?" );
    76| 			}
    77| 		}


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/attachment/DefaultAttachmentManager.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.attachment;
    18| import org.apache.logging.log4j.LogManager;
    19| import org.apache.logging.log4j.Logger;
    20| import org.apache.wiki.api.core.Attachment;
    21| import org.apache.wiki.api.core.Context;
    22| import org.apache.wiki.api.core.Engine;
    23| import org.apache.wiki.api.core.Page;
    24| import org.apache.wiki.api.exceptions.NoRequiredPropertyException;
    25| import org.apache.wiki.api.exceptions.ProviderException;
    26| import org.apache.wiki.api.providers.AttachmentProvider;
    27| import org.apache.wiki.api.spi.Wiki;
    28| import org.apache.wiki.cache.CachingManager;
    29| import org.apache.wiki.pages.PageManager;
    30| import org.apache.wiki.parser.MarkupParser;
    31| import org.apache.wiki.references.ReferenceManager;
    32| import org.apache.wiki.search.SearchManager;
    33| import org.apache.wiki.util.ClassUtil;
    34| import org.apache.wiki.util.TextUtil;
    35| import java.io.IOException;
    36| import java.io.InputStream;
    37| import java.util.ArrayList;

# --- HUNK 2: Lines 71-111 ---
    71|         } else {
    72|             classname = TextUtil.getRequiredProperty( props, PROP_PROVIDER, PROP_PROVIDER_DEPRECATED );
    73|         }
    74|         if( classname == null ) {
    75|             LOG.info( "No attachment provider defined - disabling attachment support." );
    76|             return;
    77|         }
    78|         try {
    79|             m_provider = ClassUtil.buildInstance( "org.apache.wiki.providers", classname );
    80|             m_provider.initialize( m_engine, props );
    81|         } catch( final ReflectiveOperationException e ) {
    82|             LOG.error( "Attachment provider class could not be instantiated", e );
    83|         } catch( final NoRequiredPropertyException e ) {
    84|             LOG.error( "Attachment provider did not find a property that it needed: {}", e.getMessage(), e );
    85|             m_provider = null; // No, it did not work.
    86|         } catch( final IOException e ) {
    87|             LOG.error( "Attachment provider reports IO error", e );
    88|             m_provider = null;
    89|         }
    90|         final String forceDownload = TextUtil.getStringProperty( props, PROP_FORCEDOWNLOAD, null );
    91|         if( forceDownload != null && !forceDownload.isEmpty() ) {
    92|             m_forceDownloadPatterns = forceDownload.toLowerCase().split( "\\s" );
    93|         } else {
    94|             m_forceDownloadPatterns = new String[ 0 ];
    95|         }
    96|     }
    97|     /** {@inheritDoc} */
    98|     @Override
    99|     public boolean attachmentsEnabled() {
   100|         return m_provider != null;
   101|     }
   102|     /** {@inheritDoc} */
   103|     @Override
   104|     public String getAttachmentInfoName( final Context context, final String attachmentname ) {
   105|         final Attachment att;
   106|         try {
   107|             att = getAttachmentInfo( context, attachmentname );
   108|         } catch( final ProviderException e ) {
   109|             LOG.warn( "Finding attachments failed: ", e );
   110|             return null;
   111|         }

# --- HUNK 3: Lines 152-192 ---
   152|     @Override
   153|     public List< Attachment > listAttachments( final Page wikipage ) throws ProviderException {
   154|         if( m_provider == null ) {
   155|             return new ArrayList<>();
   156|         }
   157|         final List< Attachment > atts = new ArrayList<>( m_provider.listAttachments( wikipage ) );
   158|         atts.sort( Comparator.comparing( Attachment::getName, m_engine.getManager( PageManager.class ).getPageSorter() ) );
   159|         return atts;
   160|     }
   161|     /** {@inheritDoc} */
   162|     @Override
   163|     public boolean forceDownload( String name ) {
   164|         if( name == null || name.isEmpty() ) {
   165|             return false;
   166|         }
   167|         name = name.toLowerCase();
   168|         if( name.indexOf( '.' ) == -1 ) {
   169|             return true;  // force download on attachments without extension or type indication
   170|         }
   171|         for( final String forceDownloadPattern : m_forceDownloadPatterns ) {
   172|             if( name.endsWith( forceDownloadPattern ) && !forceDownloadPattern.isEmpty() ) {
   173|                 return true;
   174|             }
   175|         }
   176|         return false;
   177|     }
   178|     /** {@inheritDoc} */
   179|     @Override
   180|     public InputStream getAttachmentStream( final Context ctx, final Attachment att ) throws ProviderException, IOException {
   181|         if( m_provider == null ) {
   182|             return null;
   183|         }
   184|         if( att instanceof DynamicAttachment ) {
   185|             return ( ( DynamicAttachment )att ).getProvider().getAttachmentData( ctx, att );
   186|         }
   187|         return m_provider.getAttachmentData( att );
   188|     }
   189|     /** {@inheritDoc} */
   190|     @Override
   191|     public void storeDynamicAttachment( final Context ctx, final DynamicAttachment att ) {
   192|         cachingManager.put( CachingManager.CACHE_ATTACHMENTS_DYNAMIC, att.getName(), att );


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/auth/DefaultUserManager.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 215-258 ---
   215|                                                                  WorkflowManager.WF_UP_CREATE_SAVE_DECISION_MESSAGE_KEY,
   216|                                                                  facts,
   217|                                                                  completionTask,
   218|                                                                  null );
   219|         workflow.setAttribute( WorkflowManager.WF_UP_CREATE_SAVE_ATTR_SAVED_PROFILE, profile );
   220|         workflow.start( context );
   221|         final boolean approvalRequired = workflow.getCurrentStep() instanceof Decision;
   222|         if ( approvalRequired ) {
   223|             throw new DecisionRequiredException( "This profile must be approved before it becomes active" );
   224|         }
   225|     }
   226|     /** {@inheritDoc} */
   227|     @Override
   228|     public UserProfile parseProfile( final Context context ) {
   229|         final UserProfile profile = getUserProfile( context.getWikiSession() );
   230|         final HttpServletRequest request = context.getHttpRequest();
   231|         String loginName = request.getParameter( PARAM_LOGINNAME );
   232|         String password = request.getParameter( PARAM_PASSWORD );
   233|         String fullname = request.getParameter( PARAM_FULLNAME );
   234|         String email = request.getParameter( PARAM_EMAIL );
   235|         loginName = InputValidator.isBlank( loginName ) ? null : loginName;
   236|         password = InputValidator.isBlank( password ) ? null : password;
   237|         fullname = InputValidator.isBlank( fullname ) ? null : fullname;
   238|         email = InputValidator.isBlank( email ) ? null : email;
   239|         if ( m_engine.getManager( AuthenticationManager.class ).isContainerAuthenticated() && context.getWikiSession().isAuthenticated() ) {
   240|             loginName = context.getWikiSession().getLoginPrincipal().getName();
   241|         }
   242|         profile.setLoginName( loginName );
   243|         profile.setEmail( email );
   244|         profile.setFullname( fullname );
   245|         profile.setPassword( password );
   246|         return profile;
   247|     }
   248|     /** {@inheritDoc} */
   249|     @Override
   250|     public void validateProfile( final Context context, final UserProfile profile ) {
   251|         final Session session = context.getWikiSession();
   252|         final InputValidator validator = new InputValidator( SESSION_MESSAGES, context );
   253|         final ResourceBundle rb = Preferences.getBundle( context, InternationalizationManager.CORE_BUNDLE );
   254|         final FilterManager fm = m_engine.getManager( FilterManager.class );
   255|         final List< PageFilter > ls = fm.getFilterList();
   256|         for( final PageFilter pf : ls ) {
   257|             if( pf instanceof SpamFilter ) {
   258|                 if( !( ( SpamFilter )pf ).isValidUserProfile( context, profile ) ) {


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/parser/JSPWikiMarkupParser.java
# Total hunks: 6
# ====================================================================
# --- HUNK 1: Lines 1-21 ---
     1| /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.parser;
    18| import org.apache.commons.lang3.StringUtils;
    19| import org.apache.commons.text.StringEscapeUtils;
    20| import org.apache.logging.log4j.LogManager;
    21| import org.apache.logging.log4j.Logger;

# --- HUNK 2: Lines 178-265 ---
   178|     protected String callMutatorChain( final Collection< StringTransmutator > list, String text ) {
   179|         if( list == null || list.isEmpty()) {
   180|             return text;
   181|         }
   182|         for( final StringTransmutator m : list ) {
   183|             text = m.mutate( m_context, text );
   184|         }
   185|         return text;
   186|     }
   187|     /**
   188|      * Calls the heading listeners.
   189|      *
   190|      * @param param A Heading object.
   191|      */
   192|     private void callHeadingListenerChain( final Heading param ) {
   193|         for( final HeadingListener h : m_headingListenerChain ) {
   194|             h.headingAdded( m_context, param );
   195|         }
   196|     }
   197|     /**
   198|      *  Creates a JDOM anchor element.  Can be overridden to change the URL creation,
   199|      *  if you really know what you are doing.
   200|      *
   201|      *  @param type One of the types above
   202|      *  @param link URL to which to link to
   203|      *  @param text Link text
   204|      *  @param section If a particular section identifier is required.
   205|      *  @return An A element.
   206|      *  @since 2.4.78
   207|      */
   208|     private Element createAnchor( final int type, final String link, String text, String section ) {
   209|         text = escapeHTMLEntities( text );
   210|         section = escapeHTMLEntities( section );
   211|         final Element el = new Element( "a" );
   212|         el.setAttribute( "class", CLASS_TYPES[ type ] );
   213|         el.setAttribute( "href", link + section );
   214|         el.addContent( text );
   215|         return el;
   216|     }
   217|     private Element makeLink( int type, final String link, String text, String section, final Iterator< Attribute > attributes ) {
   218|         Element el = null;
   219|         if( text == null ) {
   220|             text = link;
   221|         }
   222|         text = callMutatorChain( m_linkMutators, text );
   223|         section = (section != null) ? ("#"+section) : "";
   224|         if( link.isEmpty() ) {
   225|             type = EMPTY;
   226|         }
   227|         final ResourceBundle rb = Preferences.getBundle( m_context, InternationalizationManager.CORE_BUNDLE );
   228|         switch( type ) {
   229|             case READ:
   230|                 el = createAnchor( READ, m_context.getURL( ContextEnum.PAGE_VIEW.getRequestContext(), link), text, section );
   231|                 break;
   232|             case EDIT:
   233|                 el = createAnchor( EDIT, m_context.getURL( ContextEnum.PAGE_EDIT.getRequestContext(),link), text, "" );
   234|                 el.setAttribute("title", MessageFormat.format( rb.getString( "markupparser.link.create" ), link ) );
   235|                 break;
   236|             case EMPTY:
   237|                 el = new Element("u").addContent(text);
   238|                 break;
   239|             case LOCALREF:
   240|                 el = createAnchor( LOCALREF, "#ref-"+m_context.getName()+"-"+link, "["+text+"]", "" );
   241|                 break;
   242|             case LOCAL:
   243|                 el = new Element( "a" ).setAttribute( "class", CLASS_FOOTNOTE );
   244|                 el.setAttribute( "name", "ref-" + m_context.getName() + "-" + link.substring( 1 ) );
   245|                 el.addContent( "[" + text + "]" );
   246|                 break;
   247|             case IMAGE:
   248|                 el = new Element( "img" ).setAttribute( "class", "inline" );
   249|                 el.setAttribute( "src", link );
   250|                 el.setAttribute( "alt", text );
   251|                 break;
   252|             case IMAGELINK:
   253|                 el = new Element( "img" ).setAttribute( "class", "inline" );
   254|                 el.setAttribute( "src", link );
   255|                 el.setAttribute( "alt", text );
   256|                 el = createAnchor( IMAGELINK, text, "", "" ).addContent( el );
   257|                 break;
   258|             case IMAGEWIKILINK:
   259|                 final String pagelink = m_context.getURL( ContextEnum.PAGE_VIEW.getRequestContext(), text );
   260|                 el = new Element( "img" ).setAttribute( "class", "inline" );
   261|                 el.setAttribute( "src", link );
   262|                 el.setAttribute( "alt", text );
   263|                 el = createAnchor( IMAGEWIKILINK, pagelink, "", "" ).addContent( el );
   264|                 break;
   265|             case EXTERNAL:

# --- HUNK 3: Lines 326-366 ---
   326|      */
   327|     private String peekAheadLine() throws IOException {
   328|         final String s = readUntilEOL().toString();
   329|         if( s.length() > PUSHBACK_BUFFER_SIZE ) {
   330|             LOG.warn( "Line is longer than maximum allowed size (" + PUSHBACK_BUFFER_SIZE + " characters.  Attempting to recover..." );
   331|             pushBack( s.substring( 0, PUSHBACK_BUFFER_SIZE - 1 ) );
   332|         } else {
   333|             try {
   334|                 pushBack( s );
   335|             } catch( final IOException e ) {
   336|                 LOG.warn( "Pushback failed: the line is probably too long.  Attempting to recover." );
   337|             }
   338|         }
   339|         return s;
   340|     }
   341|     private int flushPlainText() {
   342|         final int numChars = m_plainTextBuf.length();
   343|         if( numChars > 0 ) {
   344|             String buf;
   345|             if( !m_allowHTML ) {
   346|                 buf = escapeHTMLEntities(m_plainTextBuf.toString());
   347|             } else {
   348|                 buf = m_plainTextBuf.toString();
   349|             }
   350|             m_plainTextBuf = new StringBuilder(20);
   351|             try {
   352|                 if( m_camelCaseLinks && !m_isEscaping && buf.length() > 3 ) {
   353|                     while( m_camelCaseMatcher.contains( buf, m_camelCasePattern ) ) {
   354|                         final MatchResult result = m_camelCaseMatcher.getMatch();
   355|                         final String firstPart = buf.substring( 0, result.beginOffset( 0 ) );
   356|                         String prefix = result.group( 1 );
   357|                         if( prefix == null ) {
   358|                             prefix = "";
   359|                         }
   360|                         final String camelCase = result.group(2);
   361|                         final String protocol  = result.group(3);
   362|                         String uri       = protocol+result.group(4);
   363|                         buf              = buf.substring(result.endOffset(0));
   364|                         m_currentElement.addContent( firstPart );
   365|                         if( prefix.endsWith( "~" ) || prefix.indexOf( '[' ) != -1 ) {
   366|                             if( prefix.endsWith( "~" ) ) {

# --- HUNK 4: Lines 382-466 ---
   382|                                 uri = uri.substring( 0, uri.length() - 1 );
   383|                                 buf = c + buf;
   384|                             }
   385|                             m_currentElement.addContent( prefix );
   386|                             makeDirectURILink( uri );
   387|                         } else {
   388|                             m_currentElement.addContent( prefix );
   389|                             makeCamelCaseLink( camelCase );
   390|                         }
   391|                     }
   392|                     m_currentElement.addContent( buf );
   393|                 } else {
   394|                     m_currentElement.addContent( buf );
   395|                 }
   396|             } catch( final IllegalDataException e ) {
   397|                 m_currentElement.addContent( makeError(cleanupSuspectData( e.getMessage() )) );
   398|             }
   399|         }
   400|         return numChars;
   401|     }
   402|     /**
   403|      *  Escapes XML entities in a HTML-compatible way (i.e. does not escape entities that are already escaped).
   404|      *
   405|      *  @param buf
   406|      *  @return An escaped string.
   407|      */
   408|     private String escapeHTMLEntities( final String buf ) {
   409|         final StringBuilder tmpBuf = new StringBuilder( buf.length() + 20 );
   410|         for( int i = 0; i < buf.length(); i++ ) {
   411|             final char ch = buf.charAt(i);
   412|             if( ch == '<' ) {
   413|                 tmpBuf.append("&lt;");
   414|             } else if( ch == '>' ) {
   415|                 tmpBuf.append("&gt;");
   416|             } else if( ch == '\"' ) {
   417|                 tmpBuf.append("&quot;");
   418|             } else if( ch == '&' ) {
   419|                 boolean isEntity = false;
   420|                 final StringBuilder entityBuf = new StringBuilder();
   421|                 if( i < buf.length() -1 ) {
   422|                     for( int j = i; j < buf.length(); j++ ) {
   423|                         final char ch2 = buf.charAt( j );
   424|                         if( Character.isLetterOrDigit( ch2 ) || (ch2 == '#' && j == i+1) || ch2 == ';' || ch2 == '&' ) {
   425|                             entityBuf.append(ch2);
   426|                             if( ch2 == ';' ) {
   427|                                 isEntity = true;
   428|                                 break;
   429|                             }
   430|                         } else {
   431|                             break;
   432|                         }
   433|                     }
   434|                 }
   435|                 if( isEntity ) {
   436|                     tmpBuf.append( entityBuf );
   437|                     i = i + entityBuf.length() - 1;
   438|                 } else {
   439|                     tmpBuf.append( "&amp;" );
   440|                 }
   441|             } else {
   442|                 tmpBuf.append( ch );
   443|             }
   444|         }
   445|         return tmpBuf.toString();
   446|     }
   447|     private Element pushElement( final Element e ) {
   448|         flushPlainText();
   449|         m_currentElement.addContent( e );
   450|         m_currentElement = e;
   451|         return e;
   452|     }
   453|     private Element addElement( final Content e ) {
   454|         if( e != null ) {
   455|             flushPlainText();
   456|             m_currentElement.addContent( e );
   457|         }
   458|         return m_currentElement;
   459|     }
   460|     /**
   461|      *  All elements that can be empty by the HTML DTD.
   462|      */
   463|     private static final String[] EMPTY_ELEMENTS = {
   464|         "area", "base", "br", "col", "hr", "img", "input", "link", "meta", "p", "param"
   465|     };
   466|     /**

# --- HUNK 5: Lines 797-837 ---
   797|                 }
   798|             } else if( link.isInterwikiLink() ) {
   799|                 final String extWiki = link.getExternalWiki();
   800|                 final String wikiPage = link.getExternalWikiPage();
   801|                 if( m_wysiwygEditorMode ) {
   802|                     makeLink( INTERWIKI, extWiki + ":" + wikiPage, linktext, null, link.getAttributes() );
   803|                 } else {
   804|                     String urlReference = m_engine.getInterWikiURL( extWiki );
   805|                     if( urlReference != null ) {
   806|                         urlReference = TextUtil.replaceString( urlReference, "%s", wikiPage );
   807|                         urlReference = callMutatorChain( m_externalLinkMutatorChain, urlReference );
   808|                         if( m_linkParsingOperations.isImageLink( urlReference, isImageInlining(), getInlineImagePatterns() ) ) {
   809|                             handleImageLink( urlReference, linktext, link.hasReference() );
   810|                         } else {
   811|                             makeLink( INTERWIKI, urlReference, linktext, null, link.getAttributes() );
   812|                         }
   813|                         if( m_linkParsingOperations.isExternalLink( urlReference ) ) {
   814|                             addElement( outlinkImage() );
   815|                         }
   816|                     } else {
   817|                         final Object[] args = { escapeHTMLEntities( extWiki ) };
   818|                         addElement( makeError( MessageFormat.format( rb.getString( "markupparser.error.nointerwikiref" ), args ) ) );
   819|                     }
   820|                 }
   821|             } else if( linkref.startsWith( "#" ) ) {
   822|                 makeLink( LOCAL, linkref, linktext, null, link.getAttributes() );
   823|             } else if( TextUtil.isNumber( linkref ) ) {
   824|                 makeLink( LOCALREF, linkref, linktext, null, link.getAttributes() );
   825|             } else {
   826|                 final int hashMark;
   827|                 String attachment = m_engine.getManager( AttachmentManager.class ).getAttachmentInfoName( m_context, linkref );
   828|                 if( attachment != null ) {
   829|                     callMutatorChain( m_attachmentLinkMutatorChain, attachment );
   830|                     if( m_linkParsingOperations.isImageLink( linkref, isImageInlining(), getInlineImagePatterns() ) ) {
   831|                         attachment = m_context.getURL( ContextEnum.PAGE_ATTACH.getRequestContext(), attachment );
   832|                         sb.append( handleImageLink( attachment, linktext, link.hasReference() ) );
   833|                     } else {
   834|                         makeLink( ATTACHMENT, attachment, linktext, null, link.getAttributes() );
   835|                     }
   836|                 } else if( ( hashMark = linkref.indexOf( '#' ) ) != -1 ) {
   837|                     final String namedSection = linkref.substring( hashMark + 1 );


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/plugin/Image.java
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 6-94 ---
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.plugin;
    18| import org.apache.wiki.api.core.Attachment;
    19| import org.apache.wiki.api.core.Context;
    20| import org.apache.wiki.api.core.ContextEnum;
    21| import org.apache.wiki.api.core.Engine;
    22| import org.apache.wiki.api.exceptions.PluginException;
    23| import org.apache.wiki.api.exceptions.ProviderException;
    24| import org.apache.wiki.api.plugin.Plugin;
    25| import org.apache.wiki.attachment.AttachmentManager;
    26| import org.apache.wiki.util.TextUtil;
    27| import java.util.Map;
    28| /**
    29|  *  Provides an image plugin for better control than is possible with a simple image inclusion.
    30|  *  <br> Most parameters are equivalents of the html image attributes.
    31|  *
    32|  *  <p>Parameters : </p>
    33|  *  <ul>
    34|  *  <li><b>src</b> - the source (a URL) of the image (required parameter)</li>
    35|  *  <li><b>align</b> - the alignment of the image</li>
    36|  *  <li><b>height</b> - the height of the image</li>
    37|  *  <li><b>width</b> - the width of the image</li>
    38|  *  <li><b>alt</b> - alternate text</li>
    39|  *  <li><b>caption</b> - the caption for the image</li>
    40|  *  <li><b>link</b> - the hyperlink for the image</li>
    41|  *  <li><b>target</b> - the target (frame) to be used for opening the image</li>
    42|  *  <li><b>style</b> - the style attribute of the image</li>
    43|  *  <li><b>class</b> - the associated class for the image</li>
    44|  *  <li><b>border</b> - the border for the image</li>
    45|  *  <li><b>title</b> - the title for the image, can be presented as a tooltip to the user</li>
    46|  *  </ul>
    47|  *
    48|  *  @since 2.1.4.
    49|  */
    50| public class Image implements Plugin {
    51|     /** The parameter name for setting the src.  Value is <tt>{@value}</tt>. */
    52|     public static final String PARAM_SRC      = "src";
    53|     /** The parameter name for setting the align.  Value is <tt>{@value}</tt>. */
    54|     public static final String PARAM_ALIGN    = "align";
    55|     /** The parameter name for setting the height.  Value is <tt>{@value}</tt>. */
    56|     public static final String PARAM_HEIGHT   = "height";
    57|     /** The parameter name for setting the width.  Value is <tt>{@value}</tt>. */
    58|     public static final String PARAM_WIDTH    = "width";
    59|     /** The parameter name for setting the alt.  Value is <tt>{@value}</tt>. */
    60|     public static final String PARAM_ALT      = "alt";
    61|     /** The parameter name for setting the caption.  Value is <tt>{@value}</tt>. */
    62|     public static final String PARAM_CAPTION  = "caption";
    63|     /** The parameter name for setting the link.  Value is <tt>{@value}</tt>. */
    64|     public static final String PARAM_LINK     = "link";
    65|     /** The parameter name for setting the target.  Value is <tt>{@value}</tt>. */
    66|     public static final String PARAM_TARGET   = "target";
    67|     /** The parameter name for setting the style.  Value is <tt>{@value}</tt>. */
    68|     public static final String PARAM_STYLE    = "style";
    69|     /** The parameter name for setting the class.  Value is <tt>{@value}</tt>. */
    70|     public static final String PARAM_CLASS    = "class";
    71|     /** The parameter name for setting the border.  Value is <tt>{@value}</tt>. */
    72|     public static final String PARAM_BORDER   = "border";
    73|     /** The parameter name for setting the title.  Value is <tt>{@value}</tt>. */
    74|     public static final String PARAM_TITLE   = "title";
    75|     /**
    76|      *  This method is used to clean away things like quotation marks which
    77|      *  a malicious user could use to stop processing and insert javascript.
    78|      */
    79|     private static String getCleanParameter( final Map< String, String > params, final String paramId ) {
    80|         return TextUtil.replaceEntities( params.get( paramId ) );
    81|     }
    82|     /**
    83|      *  {@inheritDoc}
    84|      */
    85|     @Override
    86|     public String execute( final Context context, final Map<String, String> params ) throws PluginException {
    87|         final Engine engine  = context.getEngine();
    88|         String src           = getCleanParameter( params, PARAM_SRC );
    89|         final String align   = getCleanParameter( params, PARAM_ALIGN );
    90|         final String ht      = getCleanParameter( params, PARAM_HEIGHT );
    91|         final String wt      = getCleanParameter( params, PARAM_WIDTH );
    92|         final String alt     = getCleanParameter( params, PARAM_ALT );
    93|         final String caption = getCleanParameter( params, PARAM_CAPTION );
    94|         final String link    = getCleanParameter( params, PARAM_LINK );

# --- HUNK 2: Lines 117-185 ---
   117|         if( title != null ) {
   118|             result.append( " title=\"" ).append( title ).append( "\"" );
   119|         }
   120|         if( align != null ) {
   121|             if( align.equals( "center" ) ) {
   122|                 result.append( " style=\"margin-left: auto; margin-right: auto; text-align:center; vertical-align:middle;\"" );
   123|             } else {
   124|                 result.append( " style=\"float:" ).append( align ).append( ";\"" );
   125|             }
   126|         }
   127|         result.append( ">\n" );
   128|         if( caption != null ) {
   129|             result.append( "<caption>" ).append( caption ).append( "</caption>\n" );
   130|         }
   131|         result.append( "<tr><td" );
   132|         if( cssclass != null ) {
   133|             result.append( " class=\"" ).append( cssclass ).append( "\"" );
   134|         }
   135|         if( style != null ) {
   136|             result.append( " style=\"" ).append( style );
   137|             if( result.charAt( result.length()-1 ) != ';' ) result.append(";");
   138|             result.append("\"");
   139|         }
   140|         result.append( ">" );
   141|         if( link != null ) {
   142|             result.append( "<a href=\"" ).append( link ).append( "\"" );
   143|             if( target != null ) {
   144|                 result.append( " target=\"" ).append( target ).append( "\"" );
   145|             }
   146|             result.append(">");
   147|         }
   148|         result.append( "<img src=\"" ).append( src ).append( "\"" );
   149|         if( ht != null ) {
   150|             result.append( " height=\"" ).append( ht ).append( "\"" );
   151|         }
   152|         if( wt != null ) {
   153|             result.append( " width=\"" ).append( wt ).append( "\"" );
   154|         }
   155|         if( alt != null ) {
   156|             result.append( " alt=\"" ).append( alt ).append( "\"" );
   157|         }
   158|         if( border != null ) {
   159|             result.append( " border=\"" ).append( border ).append( "\"" );
   160|         }
   161|         result.append(" />");
   162|         if( link != null ) {
   163|             result.append("</a>");
   164|         }
   165|         result.append("</td></tr>\n");
   166|         result.append("</table>\n");
   167|         return result.toString();
   168|     }
   169|     private boolean validTargetValue( final String s )
   170|     {
   171|         if( s.equals("_blank")
   172|                 || s.equals("_self")
   173|                 || s.equals("_parent")
   174|                 || s.equals("_top") )
   175|         {
   176|             return true;
   177|         }
   178|         else if( !s.isEmpty() ) // check [a-zA-z]
   179|         {
   180|             final char c = s.charAt(0);
   181|             return Character.isLowerCase(c) || Character.isUpperCase(c);
   182|         }
   183|         return false;
   184|     }
   185| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/plugin/SampleAjaxPlugin.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 10-52 ---
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.plugin;
    18| import org.apache.wiki.ajax.WikiAjaxServlet;
    19| import org.apache.wiki.api.core.Context;
    20| import org.apache.wiki.api.exceptions.PluginException;
    21| import org.apache.wiki.api.plugin.Plugin;
    22| import javax.servlet.ServletException;
    23| import javax.servlet.http.HttpServletRequest;
    24| import javax.servlet.http.HttpServletResponse;
    25| import java.io.IOException;
    26| import java.util.List;
    27| import java.util.Map;
    28| /**
    29|  * @since 2.10.2-svn10
    30|  */
    31| public class SampleAjaxPlugin implements Plugin, WikiAjaxServlet {
    32| 	private static final String SERVLET_MAPPING = "SampleAjaxPlugin";
    33| 	@Override
    34|     public String execute( final Context context, final Map<String, String> params) throws PluginException {
    35|     	final String id = Integer.toString(this.hashCode());
    36|         return "<div onclick='Wiki.ajaxHtmlCall(\"/"+SERVLET_MAPPING+"/ajaxAction\",[12,45],\"result"+id+"\",\"Loading...\")' style='color: blue; cursor: pointer'>Press Me</div>\n"+
    37|                         "<div id='result"+id+"'></div>";
    38|     }
    39| 	@Override
    40| 	public String getServletMapping() {
    41| 		return SERVLET_MAPPING;
    42| 	}
    43| 	@Override
    44| 	public void service( final HttpServletRequest request, final HttpServletResponse response, final String actionName, final List< String > params )
    45| 			throws ServletException, IOException {
    46| 		try {
    47| 			Thread.sleep( 5000 ); // Wait 5 seconds
    48| 		} catch( final Exception e ) {
    49| 		}
    50| 		response.getWriter().print( "You called! actionName=" + actionName + " params=" + params );
    51| 	}
    52| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/providers/AbstractFileProvider.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 31-70 ---
    31| import org.apache.wiki.search.SearchResultComparator;
    32| import org.apache.wiki.util.FileUtil;
    33| import org.apache.wiki.util.TextUtil;
    34| import java.io.File;
    35| import java.io.FileNotFoundException;
    36| import java.io.FilenameFilter;
    37| import java.io.IOException;
    38| import java.io.InputStream;
    39| import java.io.OutputStreamWriter;
    40| import java.io.PrintWriter;
    41| import java.nio.charset.StandardCharsets;
    42| import java.nio.file.Files;
    43| import java.util.ArrayList;
    44| import java.util.Collection;
    45| import java.util.Date;
    46| import java.util.Enumeration;
    47| import java.util.List;
    48| import java.util.Map;
    49| import java.util.Properties;
    50| import java.util.TreeSet;
    51| /**
    52|  *  Provides a simple directory based repository for Wiki pages.
    53|  *  <P>
    54|  *  All files have ".txt" appended to make life easier for those who insist on using Windows or other software which makes assumptions
    55|  *  on the files contents based on its name.
    56|  *  <p>
    57|  *  This class functions as a superclass to all file based providers.
    58|  *
    59|  *  @since 2.1.21.
    60|  */
    61| public abstract class AbstractFileProvider implements PageProvider {
    62|     private static final Logger LOG = LogManager.getLogger(AbstractFileProvider.class);
    63|     private String m_pageDirectory = "/tmp/";
    64|     protected String m_encoding;
    65|     protected Engine m_engine;
    66|     public static final String PROP_CUSTOMPROP_MAXLIMIT = "custom.pageproperty.max.allowed";
    67|     public static final String PROP_CUSTOMPROP_MAXKEYLENGTH = "custom.pageproperty.key.length";
    68|     public static final String PROP_CUSTOMPROP_MAXVALUELENGTH = "custom.pageproperty.value.length";
    69|     public static final int DEFAULT_MAX_PROPLIMIT = 200;
    70|     public static final int DEFAULT_MAX_PROPKEYLENGTH = 255;

# --- HUNK 2: Lines 97-140 ---
    97|     @Override
    98|     public void initialize( final Engine engine, final Properties properties ) throws NoRequiredPropertyException, IOException, FileNotFoundException {
    99|         LOG.debug( "Initing FileSystemProvider" );
   100|         m_pageDirectory = TextUtil.getCanonicalFilePathProperty( properties, PROP_PAGEDIR,
   101|                                                           System.getProperty( "user.home" ) + File.separator + "jspwiki-files" );
   102|         final File f = new File( m_pageDirectory );
   103|         if( !f.exists() ) {
   104|             if( !f.mkdirs() ) {
   105|                 throw new IOException( "Failed to create page directory " + f.getAbsolutePath() + " , please check property " + PROP_PAGEDIR );
   106|             }
   107|         } else {
   108|             if( !f.isDirectory() ) {
   109|                 throw new IOException( "Page directory is not a directory: " + f.getAbsolutePath() );
   110|             }
   111|             if( !f.canWrite() ) {
   112|                 throw new IOException( "Page directory is not writable: " + f.getAbsolutePath() );
   113|             }
   114|         }
   115|         m_engine = engine;
   116|         m_encoding = properties.getProperty( Engine.PROP_ENCODING, DEFAULT_ENCODING );
   117|         final String os = System.getProperty( "os.name" ).toLowerCase();
   118|         if( os.startsWith( "windows" ) || os.equals( "nt" ) ) {
   119|             m_windowsHackNeeded = true;
   120|         }
   121|         MAX_PROPLIMIT = TextUtil.getIntegerProperty( properties, PROP_CUSTOMPROP_MAXLIMIT, DEFAULT_MAX_PROPLIMIT );
   122|         MAX_PROPKEYLENGTH = TextUtil.getIntegerProperty( properties, PROP_CUSTOMPROP_MAXKEYLENGTH, DEFAULT_MAX_PROPKEYLENGTH );
   123|         MAX_PROPVALUELENGTH = TextUtil.getIntegerProperty( properties, PROP_CUSTOMPROP_MAXVALUELENGTH, DEFAULT_MAX_PROPVALUELENGTH );
   124|         LOG.info( "Wikipages are read from '" + m_pageDirectory + "'" );
   125|     }
   126|     String getPageDirectory()
   127|     {
   128|         return m_pageDirectory;
   129|     }
   130|     private static final String[] WINDOWS_DEVICE_NAMES = {
   131|         "con", "prn", "nul", "aux", "lpt1", "lpt2", "lpt3", "lpt4", "lpt5", "lpt6", "lpt7", "lpt8", "lpt9",
   132|         "com1", "com2", "com3", "com4", "com5", "com6", "com7", "com8", "com9"
   133|     };
   134|     /**
   135|      *  This makes sure that the queried page name is still readable by the file system.  For example, all XML entities
   136|      *  and slashes are encoded with the percent notation.
   137|      *
   138|      *  @param pagename The name to mangle
   139|      *  @return The mangled name.
   140|      */


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/providers/BasicAttachmentProvider.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 300-364 ---
   300|     @Override
   301|     public List< Attachment > listAttachments( final Page page ) throws ProviderException {
   302|         final List< Attachment > result = new ArrayList<>();
   303|         final File dir = findPageDir( page.getName() );
   304|         final String[] attachments = dir.list();
   305|         if( attachments != null ) {
   306|             for( final String attachment : attachments ) {
   307|                 final File f = new File( dir, attachment );
   308|                 if( f.isDirectory() ) {
   309|                     String attachmentName = unmangleName( attachment );
   310|                     if( attachmentName.endsWith( ATTDIR_EXTENSION ) ) {
   311|                         attachmentName = attachmentName.substring( 0, attachmentName.length() - ATTDIR_EXTENSION.length() );
   312|                     } else {
   313|                         final File propFile = new File( f, PROPERTY_FILE );
   314|                         if( !propFile.exists() ) {
   315|                             continue;
   316|                         }
   317|                     }
   318|                     final Attachment att = getAttachmentInfo( page, attachmentName, WikiProvider.LATEST_VERSION );
   319|                     if( att == null ) {
   320|                         throw new ProviderException( "Attachment disappeared while reading information:"
   321|                                 + " if you did not touch the repository, there is a serious bug somewhere. " + "Attachment = " + attachment
   322|                                 + ", decoded = " + attachmentName );
   323|                     }
   324|                     result.add( att );
   325|                 }
   326|             }
   327|         }
   328|         return result;
   329|     }
   330|     /**
   331|      *  {@inheritDoc}
   332|      */
   333|     @Override
   334|     public Collection< Attachment > findAttachments( final QueryItem[] query ) {
   335|         return new ArrayList<>();
   336|     }
   337|     /**
   338|      *  {@inheritDoc}
   339|      */
   340|     @Override
   341|     public List< Attachment > listAllChanged( final Date timestamp ) throws ProviderException {
   342|         final File attDir = new File( m_storageDir );
   343|         if( !attDir.exists() ) {
   344|             throw new ProviderException( "Specified attachment directory " + m_storageDir + " does not exist!" );
   345|         }
   346|         final ArrayList< Attachment > list = new ArrayList<>();
   347|         final String[] pagesWithAttachments = attDir.list( new AttachmentFilter() );
   348|         if( pagesWithAttachments != null ) {
   349|             for( final String pagesWithAttachment : pagesWithAttachments ) {
   350|                 String pageId = unmangleName( pagesWithAttachment );
   351|                 pageId = pageId.substring( 0, pageId.length() - DIR_EXTENSION.length() );
   352|                 final Collection< Attachment > c = listAttachments( Wiki.contents().page( m_engine, pageId ) );
   353|                 for( final Attachment att : c ) {
   354|                     if( att.getLastModified().after( timestamp ) ) {
   355|                         list.add( att );
   356|                     }
   357|                 }
   358|             }
   359|         }
   360|         list.sort( new PageTimeComparator() );
   361|         return list;
   362|     }
   363|     /**
   364|      *  {@inheritDoc}


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/providers/CachingAttachmentProvider.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 23-82 ---
    23| import org.apache.wiki.api.exceptions.NoRequiredPropertyException;
    24| import org.apache.wiki.api.exceptions.ProviderException;
    25| import org.apache.wiki.api.providers.AttachmentProvider;
    26| import org.apache.wiki.api.providers.PageProvider;
    27| import org.apache.wiki.api.providers.WikiProvider;
    28| import org.apache.wiki.api.search.QueryItem;
    29| import org.apache.wiki.attachment.AttachmentManager;
    30| import org.apache.wiki.cache.CacheInfo;
    31| import org.apache.wiki.cache.CachingManager;
    32| import org.apache.wiki.util.ClassUtil;
    33| import org.apache.wiki.util.TextUtil;
    34| import java.io.IOException;
    35| import java.io.InputStream;
    36| import java.util.ArrayList;
    37| import java.util.Collection;
    38| import java.util.Collections;
    39| import java.util.Date;
    40| import java.util.List;
    41| import java.util.NoSuchElementException;
    42| import java.util.Properties;
    43| import java.util.concurrent.atomic.AtomicLong;
    44| /**
    45|  * Provides a caching attachment provider.  This class rests on top of a real provider class and provides a cache to speed things up.
    46|  * Only the Attachment objects are cached; the actual attachment contents are fetched always from the provider.
    47|  *
    48|  *  @since 2.1.64.
    49|  */
    50| public class CachingAttachmentProvider implements AttachmentProvider {
    51|     private static final Logger LOG = LogManager.getLogger( CachingAttachmentProvider.class );
    52|     private AttachmentProvider provider;
    53|     private CachingManager cachingManager;
    54|     private boolean allRequested;
    55|     private final AtomicLong attachments = new AtomicLong( 0L );
    56|     /**
    57|      * {@inheritDoc}
    58|      */
    59|     @Override
    60|     public void initialize( final Engine engine, final Properties properties ) throws NoRequiredPropertyException, IOException {
    61|         LOG.info( "Initing CachingAttachmentProvider" );
    62|         cachingManager = engine.getManager( CachingManager.class );
    63|         final String classname;
    64|         try {
    65|             classname = TextUtil.getRequiredProperty( properties, AttachmentManager.PROP_PROVIDER, AttachmentManager.PROP_PROVIDER_DEPRECATED );
    66|         } catch( final NoSuchElementException e ) {
    67|             throw new NoRequiredPropertyException( e.getMessage(), AttachmentManager.PROP_PROVIDER );
    68|         }
    69|         try {
    70|             provider = ClassUtil.buildInstance( "org.apache.wiki.providers", classname );
    71|             LOG.debug( "Initializing real provider class {}", provider );
    72|             provider.initialize( engine, properties );
    73|         } catch( final ReflectiveOperationException e ) {
    74|             LOG.error( "Unable to instantiate provider class {}", classname, e );
    75|             throw new IllegalArgumentException( "illegal provider class", e );
    76|         }
    77|     }
    78|     /**
    79|      * {@inheritDoc}
    80|      */
    81|     @Override
    82|     public void putAttachmentData( final Attachment att, final InputStream data ) throws ProviderException, IOException {

# --- HUNK 2: Lines 102-149 ---
   102|         final List< Attachment > atts = cachingManager.get( CachingManager.CACHE_ATTACHMENTS_COLLECTION, page.getName(),
   103|                                                             () -> provider.listAttachments( page ) );
   104|         return cloneCollection( atts );
   105|     }
   106|     private < T > List< T > cloneCollection( final Collection< T > c ) {
   107|         return c != null ? new ArrayList<>( c ) : Collections.emptyList();
   108|     }
   109|     /**
   110|      * {@inheritDoc}
   111|      */
   112|     @Override
   113|     public Collection< Attachment > findAttachments( final QueryItem[] query ) {
   114|         return provider.findAttachments( query );
   115|     }
   116|     /**
   117|      * {@inheritDoc}
   118|      */
   119|     @Override
   120|     public List< Attachment > listAllChanged( final Date timestamp ) throws ProviderException {
   121|         final List< Attachment > all;
   122|         if ( !allRequested ) {
   123|             all = provider.listAllChanged( timestamp );
   124|             synchronized( this ) {
   125|                 for( final Attachment att : all ) {
   126|                     cachingManager.put( CachingManager.CACHE_ATTACHMENTS, att.getName(), att );
   127|                 }
   128|                 if( timestamp.getTime() == 0L ) { // all attachments requested
   129|                     allRequested = true;
   130|                     attachments.set( all.size() );
   131|                 }
   132|             }
   133|         } else {
   134|             final List< String > keys = cachingManager.keys( CachingManager.CACHE_ATTACHMENTS );
   135|             all = new ArrayList<>();
   136|             for( final String key : keys) {
   137|                 final Attachment cachedAttachment = cachingManager.get( CachingManager.CACHE_ATTACHMENTS, key, () -> null );
   138|                 if( cachedAttachment != null ) {
   139|                     all.add( cachedAttachment );
   140|                 }
   141|             }
   142|         }
   143|         if( cachingManager.enabled( CachingManager.CACHE_ATTACHMENTS )
   144|                 && attachments.get() >= cachingManager.info( CachingManager.CACHE_ATTACHMENTS ).getMaxElementsAllowed() ) {
   145|             LOG.warn( "seems {} can't hold all attachments from your page repository, " +
   146|                     "so we're delegating on the underlying provider instead. Please consider increasing " +
   147|                     "your cache sizes on the ehcache configuration file to avoid this behaviour", CachingManager.CACHE_ATTACHMENTS );
   148|             return provider.listAllChanged( timestamp );
   149|         }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/providers/CachingProvider.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 23-90 ---
    23| import org.apache.wiki.api.exceptions.NoRequiredPropertyException;
    24| import org.apache.wiki.api.exceptions.ProviderException;
    25| import org.apache.wiki.api.providers.PageProvider;
    26| import org.apache.wiki.api.search.QueryItem;
    27| import org.apache.wiki.api.search.SearchResult;
    28| import org.apache.wiki.api.spi.Wiki;
    29| import org.apache.wiki.cache.CacheInfo;
    30| import org.apache.wiki.cache.CachingManager;
    31| import org.apache.wiki.pages.PageManager;
    32| import org.apache.wiki.parser.MarkupParser;
    33| import org.apache.wiki.render.RenderingManager;
    34| import org.apache.wiki.util.ClassUtil;
    35| import org.apache.wiki.util.TextUtil;
    36| import java.io.IOException;
    37| import java.util.Collection;
    38| import java.util.Date;
    39| import java.util.List;
    40| import java.util.NoSuchElementException;
    41| import java.util.Properties;
    42| import java.util.TreeSet;
    43| import java.util.concurrent.atomic.AtomicLong;
    44| /**
    45|  *  Provides a caching page provider.  This class rests on top of a real provider class and provides a cache to speed things up.  Only
    46|  *  if the cache copy of the page text has expired, we fetch it from the provider.
    47|  *  <p>
    48|  *  This class does not detect if someone has modified the page externally, not through JSPWiki routines.
    49|  *  <p>
    50|  *  Heavily based on ideas by Chris Brooking.
    51|  *  <p>
    52|  *  Since 2.10 uses the Ehcache library.
    53|  *
    54|  *  @since 1.6.4
    55|  */
    56| public class CachingProvider implements PageProvider {
    57|     private static final Logger LOG = LogManager.getLogger( CachingProvider.class );
    58|     private CachingManager cachingManager;
    59|     private PageProvider provider;
    60|     private Engine engine;
    61|     private boolean allRequested;
    62|     private final AtomicLong pages = new AtomicLong( 0L );
    63|     /**
    64|      *  {@inheritDoc}
    65|      */
    66|     @Override
    67|     public void initialize( final Engine engine, final Properties properties ) throws NoRequiredPropertyException, IOException {
    68|         LOG.debug( "Initing CachingProvider" );
    69|         this.engine = engine;
    70|         cachingManager = this.engine.getManager( CachingManager.class );
    71|         final String classname;
    72|         try {
    73|             classname = TextUtil.getRequiredProperty( properties, PageManager.PROP_PAGEPROVIDER );
    74|         } catch( final NoSuchElementException e ) {
    75|             throw new NoRequiredPropertyException( e.getMessage(), PageManager.PROP_PAGEPROVIDER );
    76|         }
    77|         try {
    78|             provider = ClassUtil.buildInstance( "org.apache.wiki.providers", classname );
    79|             LOG.debug( "Initializing real provider class {}", provider );
    80|             provider.initialize( engine, properties );
    81|         } catch( final ReflectiveOperationException e ) {
    82|             LOG.error( "Unable to instantiate provider class {}", classname, e );
    83|             throw new IllegalArgumentException( "illegal provider class", e );
    84|         }
    85|     }
    86|     private Page getPageInfoFromCache( final String name ) throws ProviderException {
    87|         if( name == null ) {
    88|             return null;
    89|         }
    90|         return cachingManager.get( CachingManager.CACHE_PAGES, name, () -> provider.getPageInfo( name, PageProvider.LATEST_VERSION ) );

# --- HUNK 2: Lines 177-223 ---
   177|      *  {@inheritDoc}
   178|      */
   179|     @Override
   180|     public void putPageText( final Page page, final String text ) throws ProviderException {
   181|         synchronized( this ) {
   182|             provider.putPageText( page, text );
   183|             page.setLastModified( new Date() );
   184|             cachingManager.remove( CachingManager.CACHE_PAGES, page.getName() );
   185|             cachingManager.remove( CachingManager.CACHE_PAGES_TEXT, page.getName() );
   186|             cachingManager.remove( CachingManager.CACHE_PAGES_HISTORY, page.getName() );
   187|             getPageInfoFromCache( page.getName() );
   188|         }
   189|         pages.incrementAndGet();
   190|     }
   191|     /**
   192|      *  {@inheritDoc}
   193|      */
   194|     @Override
   195|     public Collection< Page > getAllPages() throws ProviderException {
   196|         final Collection< Page > all;
   197|         if ( !allRequested ) {
   198|             all = provider.getAllPages();
   199|             synchronized( this ) {
   200|                 for( final Page p : all ) {
   201|                     cachingManager.put( CachingManager.CACHE_PAGES,  p.getName(), p );
   202|                 }
   203|                 allRequested = true;
   204|             }
   205|             pages.set( all.size() );
   206|         } else {
   207|             final List< String > keys = cachingManager.keys( CachingManager.CACHE_PAGES );
   208|             all = new TreeSet<>();
   209|             for( final String key : keys ) {
   210|                 final Page cachedPage = cachingManager.get( CachingManager.CACHE_PAGES, key, () -> null );
   211|                 if( cachedPage != null ) {
   212|                     all.add( cachedPage );
   213|                 }
   214|             }
   215|         }
   216|         if( cachingManager.enabled( CachingManager.CACHE_PAGES )
   217|                 && pages.get() >= cachingManager.info( CachingManager.CACHE_PAGES ).getMaxElementsAllowed() ) {
   218|             LOG.warn( "seems {} can't hold all pages from your page repository, " +
   219|                     "so we're delegating on the underlying provider instead. Please consider increasing " +
   220|                     "your cache sizes on the ehcache configuration file to avoid this behaviour", CachingManager.CACHE_PAGES );
   221|             return provider.getAllPages();
   222|         }
   223|         return all;


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/tags/CalendarTag.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 17-73 ---
    17| package org.apache.wiki.tags;
    18| import org.apache.logging.log4j.LogManager;
    19| import org.apache.logging.log4j.Logger;
    20| import org.apache.wiki.api.core.ContextEnum;
    21| import org.apache.wiki.api.core.Engine;
    22| import org.apache.wiki.api.core.Page;
    23| import org.apache.wiki.pages.PageManager;
    24| import org.apache.wiki.util.HttpUtil;
    25| import org.apache.wiki.util.TextUtil;
    26| import javax.servlet.http.HttpServletRequest;
    27| import javax.servlet.jsp.JspWriter;
    28| import java.io.IOException;
    29| import java.text.ParseException;
    30| import java.text.SimpleDateFormat;
    31| import java.util.Calendar;
    32| import java.util.Date;
    33| /**
    34|  *  Provides a nice calendar.  Responds to the following HTTP parameters:
    35|  *  <ul>
    36|  *  <li>calendar.date - If this parameter exists, then the calendar
    37|  *  date is taken from the month and year.  The date must be in ddMMyy
    38|  *  format.
    39|  *  <li>weblog.startDate - If calendar.date parameter does not exist,
    40|  *  we then check this date.
    41|  *  </ul>
    42|  *
    43|  *  If neither calendar.date nor weblog.startDate parameters exist,
    44|  *  then the calendar will default to the current month.
    45|  *
    46|  *  @since 2.0
    47|  */
    48| public class CalendarTag extends WikiTagBase {
    49|     private static final long serialVersionUID = 0L;
    50|     private static final Logger LOG = LogManager.getLogger( CalendarTag.class );
    51|     private SimpleDateFormat m_pageFormat;
    52|     private SimpleDateFormat m_urlFormat;
    53|     private SimpleDateFormat m_monthUrlFormat;
    54|     private SimpleDateFormat m_dateFormat = new SimpleDateFormat( "ddMMyy" );
    55|     /**
    56|      *  {@inheritDoc}
    57|      */
    58|     @Override
    59|     public void initTag()
    60|     {
    61|         super.initTag();
    62|         m_pageFormat = m_urlFormat = m_monthUrlFormat = null;
    63|         m_dateFormat = new SimpleDateFormat( "ddMMyy" );
    64|     }
    65|     /*
    66|     public void setYear( String year )
    67|     {
    68|         m_year = year;
    69|     }
    70|     public void setMonth( String month )
    71|     {
    72|         m_month = month;
    73|     }

# --- HUNK 2: Lines 92-148 ---
    92|      *  links to pages according to this format.  The pageformat
    93|      *  takes precedence.
    94|      *  
    95|      *  @param format The URL format in the SimpleDateFormat fashion.
    96|      *  @see SimpleDateFormat
    97|      */
    98|     public void setUrlformat( final String format )
    99|     {
   100|         m_urlFormat = new SimpleDateFormat( format );
   101|     }
   102|     /**
   103|      *  Set the format to be used for links for the months.
   104|      *  
   105|      *  @param format The format to set in the SimpleDateFormat fashion.
   106|      *  
   107|      *  @see SimpleDateFormat
   108|      */
   109|     public void setMonthurlformat( final String format )
   110|     {
   111|         m_monthUrlFormat = new SimpleDateFormat( format );
   112|     }
   113|     private String format( final String txt ) {
   114|         final Page p = m_wikiContext.getPage();
   115|         if( p != null ) {
   116|             return TextUtil.replaceString( txt, "%p", p.getName() );
   117|         }
   118|         return txt;
   119|     }
   120|     /**
   121|      *  Returns a link to the given day.
   122|      */
   123|     private String getDayLink( final Calendar day ) {
   124|         final Engine engine = m_wikiContext.getEngine();
   125|         final String result;
   126|         if( m_pageFormat != null ) {
   127|             final String pagename = m_pageFormat.format( day.getTime() );
   128|             if( engine.getManager( PageManager.class ).wikiPageExists( pagename ) ) {
   129|                 if( m_urlFormat != null ) {
   130|                     final String url = m_urlFormat.format( day.getTime() );
   131|                     result = "<td class=\"link\"><a href=\""+url+"\">"+day.get( Calendar.DATE )+"</a></td>";
   132|                 } else {
   133|                     result = "<td class=\"link\"><a href=\""+m_wikiContext.getViewURL( pagename )+"\">"+
   134|                              day.get( Calendar.DATE )+"</a></td>";
   135|                 }
   136|             } else {
   137|                 result = "<td class=\"days\">"+day.get(Calendar.DATE)+"</td>";
   138|             }
   139|         } else if( m_urlFormat != null ) {
   140|             final String url = m_urlFormat.format( day.getTime() );
   141|             result = "<td><a href=\""+url+"\">"+day.get( Calendar.DATE )+"</a></td>";
   142|         } else {
   143|             result = "<td class=\"days\">"+day.get(Calendar.DATE)+"</td>";
   144|         }
   145|         return format( result );
   146|     }
   147|     private String getMonthLink( final Calendar day ) {
   148|         final SimpleDateFormat monthfmt = new SimpleDateFormat( "MMMM yyyy" );


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/ui/admin/DefaultAdminBeanManager.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 33-79 ---
    33| import javax.management.DynamicMBean;
    34| import javax.management.InstanceAlreadyExistsException;
    35| import javax.management.InstanceNotFoundException;
    36| import javax.management.MBeanRegistrationException;
    37| import javax.management.MBeanServer;
    38| import javax.management.MalformedObjectNameException;
    39| import javax.management.NotCompliantMBeanException;
    40| import javax.management.ObjectName;
    41| import java.lang.management.ManagementFactory;
    42| import java.util.ArrayList;
    43| import java.util.Collection;
    44| import java.util.List;
    45| /**
    46|  *  Provides a manager class for all AdminBeans within JSPWiki.  This class also manages registration for any
    47|  *  AdminBean which is also a JMX bean.
    48|  *
    49|  *  @since  2.5.52
    50|  */
    51| public class DefaultAdminBeanManager implements WikiEventListener, AdminBeanManager {
    52|     private final Engine m_engine;
    53|     private ArrayList< AdminBean > m_allBeans;
    54|     private final MBeanServer m_mbeanServer;
    55|     private static final Logger LOG = LogManager.getLogger( DefaultAdminBeanManager.class );
    56|     public DefaultAdminBeanManager( final Engine engine ) {
    57|         LOG.info("Using JDK 1.5 Platform MBeanServer");
    58|         m_mbeanServer = MBeanServerFactory15.getServer();
    59|         m_engine = engine;
    60|         if( m_mbeanServer != null ) {
    61|             LOG.info( m_mbeanServer.getClass().getName() );
    62|             LOG.info( m_mbeanServer.getDefaultDomain() );
    63|         }
    64|         m_engine.addWikiEventListener( this );
    65|         initialize();
    66|     }
    67|     /** {@inheritDoc} */
    68|     @Override
    69| 	public void initialize() {
    70|         reload();
    71|     }
    72|     private String getJMXTitleString( final int title ) {
    73|         switch( title ) {
    74|             case AdminBean.CORE:
    75|                 return "Core";
    76|             case AdminBean.EDITOR:
    77|                 return "Editors";
    78|             case AdminBean.UNKNOWN:
    79|             default:

# --- HUNK 2: Lines 93-133 ---
    93|                     m_mbeanServer.registerMBean( ab, name );
    94|                 }
    95|             }
    96|             m_allBeans.add( ab );
    97|             LOG.info( "Registered new admin bean " + ab.getTitle() );
    98|         } catch( final InstanceAlreadyExistsException e ) {
    99|             LOG.error( "Admin bean already registered to JMX", e );
   100|         } catch( final MBeanRegistrationException e ) {
   101|             LOG.error( "Admin bean cannot be registered to JMX", e );
   102|         } catch( final NotCompliantMBeanException e ) {
   103|             LOG.error( "Your admin bean is not very good", e );
   104|         } catch( final MalformedObjectNameException e ) {
   105|             LOG.error( "Your admin bean name is not very good", e );
   106|         } catch( final NullPointerException e ) {
   107|             LOG.error( "Evil NPE occurred", e );
   108|         }
   109|     }
   110|     private ObjectName getObjectName( final AdminBean ab ) throws MalformedObjectNameException {
   111|         final String component = getJMXTitleString( ab.getType() );
   112|         final String title     = ab.getTitle();
   113|         return new ObjectName( Release.APPNAME + ":component=" + component + ",name=" + title );
   114|     }
   115|     /**
   116|      *  Registers all the beans from a collection of WikiModuleInfos.  If some of the beans fail, logs the message and keeps going to the
   117|      *  next bean.
   118|      *
   119|      *  @param c Collection of WikiModuleInfo instances
   120|      */
   121|     private void registerBeans( final Collection< WikiModuleInfo > c ) {
   122|         for( final WikiModuleInfo wikiModuleInfo : c ) {
   123|             final String abname = wikiModuleInfo.getAdminBeanClass();
   124|             try {
   125|                 if( abname != null && !abname.isEmpty() ) {
   126|                     final AdminBean ab = ClassUtil.buildInstance( abname );
   127|                     registerAdminBean( ab );
   128|                 }
   129|             } catch( final ReflectiveOperationException e ) {
   130|                 LOG.error( e.getMessage(), e );
   131|             }
   132|         }
   133|     }


# ====================================================================
# FILE: jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/ImageLinkNodePostProcessorState.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-57 ---
     1| /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.markdown.extensions.jspwikilinks.postprocessor;
    18| import com.vladsch.flexmark.ast.HtmlInline;
    19| import com.vladsch.flexmark.util.ast.Node;
    20| import com.vladsch.flexmark.util.ast.NodeTracker;
    21| import com.vladsch.flexmark.util.sequence.CharSubSequence;
    22| import org.apache.wiki.api.core.Context;
    23| import org.apache.wiki.markdown.nodes.JSPWikiLink;
    24| import org.apache.wiki.parser.LinkParsingOperations;
    25| /**
    26|  * {@link NodePostProcessorState} which further post processes image links.
    27|  */
    28| public class ImageLinkNodePostProcessorState implements NodePostProcessorState< JSPWikiLink > {
    29|     private final boolean isLinkFromText;
    30|     private final String urlRef;
    31|     private final LinkParsingOperations linkOperations;
    32|     public ImageLinkNodePostProcessorState( final Context wikiContext, final String urlRef, final boolean isLinkFromText ) {
    33|         this.isLinkFromText = isLinkFromText;
    34|         this.urlRef = urlRef;
    35|         this.linkOperations = new LinkParsingOperations( wikiContext );
    36|     }
    37|     /**
    38|      * {@inheritDoc}
    39|      *
    40|      * @see NodePostProcessorState#process(NodeTracker, Node)
    41|      */
    42|     @Override
    43|     public void process( final NodeTracker state, final JSPWikiLink link ) {
    44|         final HtmlInline img = new HtmlInline( CharSubSequence.of( "<img class=\"inline\" " +
    45|                                                                         "src=\"" + urlRef + "\" " +
    46|                                                                         "alt=\"" + link.getText().toString() + "\" />" ) );
    47|         if( ( isLinkFromText && linkOperations.isExternalLink( link.getText().toString() ) ) ||
    48|                 ( isLinkFromText && linkOperations.linkExists( link.getText().toString() ) ) ) {
    49|             link.setUrl( CharSubSequence.of( urlRef ) );
    50|             link.removeChildren();
    51|             link.appendChild( img );
    52|             state.nodeAdded( img );
    53|         } else {
    54|             NodePostProcessorStateCommonOperations.addContent( state, link, img );
    55|         }
    56|     }
    57| }


# ====================================================================
# FILE: jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/LocalLinkNodePostProcessorState.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.markdown.extensions.jspwikilinks.postprocessor;
    18| import com.vladsch.flexmark.ast.HtmlInline;
    19| import com.vladsch.flexmark.util.ast.Node;
    20| import com.vladsch.flexmark.util.ast.NodeTracker;
    21| import com.vladsch.flexmark.util.sequence.CharSubSequence;
    22| import org.apache.oro.text.regex.Pattern;
    23| import org.apache.wiki.api.core.Context;
    24| import org.apache.wiki.api.core.ContextEnum;
    25| import org.apache.wiki.attachment.AttachmentManager;
    26| import org.apache.wiki.markdown.nodes.JSPWikiLink;
    27| import org.apache.wiki.parser.LinkParsingOperations;
    28| import org.apache.wiki.parser.MarkupParser;
    29| import java.util.List;
    30| /**
    31|  * {@link NodePostProcessorState} which further post processes local links.
    32|  */
    33| public class LocalLinkNodePostProcessorState implements NodePostProcessorState< JSPWikiLink > {
    34|     private final Context wikiContext;
    35|     private final LinkParsingOperations linkOperations;
    36|     private final boolean isImageInlining;
    37|     private final List< Pattern > inlineImagePatterns;
    38|     public LocalLinkNodePostProcessorState( final Context wikiContext,

# --- HUNK 2: Lines 40-95 ---
    40|                                             final List< Pattern > inlineImagePatterns ) {
    41|         this.wikiContext = wikiContext;
    42|         this.linkOperations = new LinkParsingOperations( wikiContext );
    43|         this.isImageInlining = isImageInlining;
    44|         this.inlineImagePatterns = inlineImagePatterns;
    45|     }
    46|     /**
    47|      * {@inheritDoc}
    48|      *
    49|      * @see NodePostProcessorState#process(NodeTracker, Node) 
    50|      */
    51|     @Override
    52|     public void process( final NodeTracker state, final JSPWikiLink link ) {
    53|         final int hashMark = link.getUrl().toString().indexOf( '#' );
    54|         final String attachment = wikiContext.getEngine().getManager( AttachmentManager.class ).getAttachmentInfoName( wikiContext, link.getUrl().toString() );
    55|         if( attachment != null  ) {
    56|             if( !linkOperations.isImageLink( link.getUrl().toString(), isImageInlining, inlineImagePatterns ) ) {
    57|                 final String attlink = wikiContext.getURL( ContextEnum.PAGE_ATTACH.getRequestContext(), link.getUrl().toString() );
    58|                 link.setUrl( CharSubSequence.of( attlink ) );
    59|                 link.removeChildren();
    60|                 final HtmlInline content = new HtmlInline( CharSubSequence.of( link.getText().toString() ) );
    61|                 link.appendChild( content );
    62|                 state.nodeAddedWithChildren( content );
    63|                 addAttachmentLink( state, link );
    64|             } else {
    65|                 new ImageLinkNodePostProcessorState( wikiContext, attachment, link.hasRef() ).process( state, link );
    66|             }
    67|         } else if( hashMark != -1 ) { // It's an internal Wiki link, but to a named section
    68|             final String namedSection = link.getUrl().toString().substring( hashMark + 1 );
    69|             link.setUrl( CharSubSequence.of( link.getUrl().toString().substring( 0, hashMark ) ) );
    70|             final String matchedLink = linkOperations.linkIfExists( link.getUrl().toString() );
    71|             if( matchedLink != null ) {
    72|                 String sectref = "#section-" + wikiContext.getEngine().encodeName( matchedLink + "-" + MarkupParser.wikifyLink( namedSection ) );
    73|                 sectref = sectref.replace('%', '_');
    74|                 link.setUrl( CharSubSequence.of( wikiContext.getURL( ContextEnum.PAGE_VIEW.getRequestContext(), link.getUrl().toString() + sectref ) ) );
    75|             } else {
    76|                 link.setUrl( CharSubSequence.of( wikiContext.getURL( ContextEnum.PAGE_EDIT.getRequestContext(), link.getUrl().toString() ) ) );
    77|             }
    78|         } else {
    79|             if( linkOperations.linkExists( link.getUrl().toString() ) ) {
    80|                 link.setUrl( CharSubSequence.of( wikiContext.getURL( ContextEnum.PAGE_VIEW.getRequestContext(), link.getUrl().toString() ) ) );
    81|             } else {
    82|                 link.setUrl( CharSubSequence.of( wikiContext.getURL( ContextEnum.PAGE_EDIT.getRequestContext(), link.getUrl().toString() ) ) );
    83|             }
    84|         }
    85|     }
    86|     void addAttachmentLink( final NodeTracker state, final JSPWikiLink link ) {
    87|         final String infolink = wikiContext.getURL( ContextEnum.PAGE_INFO.getRequestContext(), link.getWikiLink() );
    88|         final String imglink = wikiContext.getURL( ContextEnum.PAGE_NONE.getRequestContext(), "images/attachment_small.png" );
    89|         final HtmlInline aimg = new HtmlInline( CharSubSequence.of( "<a href=\""+ infolink + "\" class=\"infolink\">" +
    90|                                                                        "<img src=\""+ imglink + "\" border=\"0\" alt=\"(info)\" />" +
    91|                                                                      "</a>" ) );
    92|         link.insertAfter( aimg );
    93|         state.nodeAdded( aimg );
    94|     }
    95| }


# ====================================================================
# FILE: jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/NodePostProcessorStateCommonOperations.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-67 ---
     1| /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.markdown.extensions.jspwikilinks.postprocessor;
    18| import com.vladsch.flexmark.ast.HtmlInline;
    19| import com.vladsch.flexmark.util.ast.Node;
    20| import com.vladsch.flexmark.util.ast.NodeTracker;
    21| import com.vladsch.flexmark.util.sequence.CharSubSequence;
    22| import org.apache.wiki.api.core.Context;
    23| import org.apache.wiki.api.core.ContextEnum;
    24| import org.apache.wiki.markdown.nodes.JSPWikiLink;
    25| import org.apache.wiki.parser.MarkupParser;
    26| /**
    27|  * Internal class with common post-processor operations.
    28|  */
    29| class NodePostProcessorStateCommonOperations {
    30|     static void addContent( final NodeTracker state, final Node node, final Node content ) {
    31|         final Node previous = node.getPrevious() != null ? node.getPrevious() : node.getNext();
    32|         if( previous != null ) {
    33|             previous.insertAfter( content );
    34|             node.unlink();
    35|             state.nodeRemoved( node );
    36|             content.takeChildren( node );
    37|             state.nodeAddedWithChildren( content );
    38|         } else {
    39|             node.getParent().appendChild( content );
    40|         }
    41|     }
    42|     static void addOutlinkImage( final NodeTracker state, final Node node, final Context wikiContext, final boolean useOutlinkImage ) {
    43|         final Boolean wysiwygVariable = wikiContext.getVariable( Context.VAR_WYSIWYG_EDITOR_MODE );
    44|         final boolean wysiwygEditorMode = wysiwygVariable != null && wysiwygVariable;
    45|         if( useOutlinkImage && !wysiwygEditorMode ) {
    46|             final String m_outlinkImageURL = wikiContext.getURL( ContextEnum.PAGE_NONE.getRequestContext(), MarkupParser.OUTLINK_IMAGE );
    47|             final HtmlInline img = new HtmlInline( CharSubSequence.of( "<img class=\""+ MarkupParser.OUTLINK + "\" " +
    48|                                                                               "alt=\"\" src=\""+ m_outlinkImageURL + "\" />" ) );
    49|             node.insertAfter( img );
    50|             state.nodeAdded( img );
    51|         }
    52|     }
    53|     static String inlineLinkTextOnWysiwyg( final NodeTracker state, final JSPWikiLink link, final boolean wysiwygEditorMode ) {
    54|         final String line = link.getUrl().toString();
    55|         if( wysiwygEditorMode ) {
    56|             final HtmlInline content = new HtmlInline( CharSubSequence.of( "[" + line + "]()" ) );
    57|             addContent( state, link, content );
    58|         }
    59|         return line;
    60|     }
    61|     static void makeError( final NodeTracker state, final Node node, final String errMsg ) {
    62|         final HtmlInline error = new HtmlInline( CharSubSequence.of( "<span class=\"error\">" +
    63|                                                                      errMsg +
    64|                                                                      "</span>" ) );
    65|         addContent( state, node, error );
    66|     }
    67| }


# ====================================================================
# FILE: jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/PluginLinkNodePostProcessorState.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.markdown.extensions.jspwikilinks.postprocessor;
    18| import com.vladsch.flexmark.ast.HtmlInline;
    19| import com.vladsch.flexmark.ext.toc.TocBlock;
    20| import com.vladsch.flexmark.util.ast.Node;
    21| import com.vladsch.flexmark.util.ast.NodeTracker;
    22| import com.vladsch.flexmark.util.sequence.CharSubSequence;
    23| import org.apache.logging.log4j.LogManager;
    24| import org.apache.logging.log4j.Logger;
    25| import org.apache.wiki.api.core.Context;
    26| import org.apache.wiki.api.exceptions.PluginException;
    27| import org.apache.wiki.api.plugin.Plugin;
    28| import org.apache.wiki.markdown.nodes.JSPWikiLink;
    29| import org.apache.wiki.parser.PluginContent;
    30| import org.apache.wiki.preferences.Preferences;
    31| import java.text.MessageFormat;
    32| import java.util.ResourceBundle;
    33| /**
    34|  * {@link NodePostProcessorState} which further post processes plugin links.
    35|  */
    36| public class PluginLinkNodePostProcessorState implements NodePostProcessorState< JSPWikiLink > {
    37|     private static final Logger LOG = LogManager.getLogger( PluginLinkNodePostProcessorState.class );
    38|     private final Context wikiContext;

# --- HUNK 2: Lines 41-119 ---
    41|         this.wikiContext = wikiContext;
    42|         final Boolean wysiwygVariable = wikiContext.getVariable( Context.VAR_WYSIWYG_EDITOR_MODE );
    43|         m_wysiwygEditorMode = wysiwygVariable != null ? wysiwygVariable : false;
    44|     }
    45|     /**
    46|      * {@inheritDoc}
    47|      *
    48|      * @see NodePostProcessorState#process(NodeTracker, Node) 
    49|      */
    50|     @Override
    51|     public void process( final NodeTracker state, final JSPWikiLink link ) {
    52|         if( link.getText().toString().startsWith( "{TableOfContents" ) ) {
    53|             handleTableOfContentsPlugin( state, link );
    54|             return;
    55|         }
    56|         PluginContent pluginContent = null;
    57|         try {
    58|             pluginContent = PluginContent.parsePluginLine( wikiContext, link.getUrl().toString(), -1 ); // -1 == do not generate _bounds parameter
    59|             if( pluginContent != null ) {
    60|                 final String pluginInvocation = pluginInvocation( link.getText().toString(), pluginContent );
    61|                 final HtmlInline content = new HtmlInline( CharSubSequence.of( pluginInvocation ) );
    62|                 pluginContent.executeParse( wikiContext );
    63|                 NodePostProcessorStateCommonOperations.addContent( state, link, content );
    64|             }
    65|         } catch( final PluginException e ) {
    66|             LOG.info( wikiContext.getRealPage().getWiki() + " : " + wikiContext.getRealPage().getName() + " - Failed to insert plugin: " + e.getMessage() );
    67|             if( !m_wysiwygEditorMode ) {
    68|                 final ResourceBundle rbPlugin = Preferences.getBundle( wikiContext, Plugin.CORE_PLUGINS_RESOURCEBUNDLE );
    69|                 NodePostProcessorStateCommonOperations.makeError( state, link, MessageFormat.format( rbPlugin.getString( "plugin.error.insertionfailed" ),
    70|                                                                                                                          wikiContext.getRealPage().getWiki(),
    71|                                                                                                                          wikiContext.getRealPage().getName(),
    72|                                                                                                                          e.getMessage() ) );
    73|             }
    74|         } finally {
    75|             if( pluginContent != null ) {
    76|                 removeLink( state, link );
    77|             }
    78|         }
    79|     }
    80|     /**
    81|      * Return plugin execution. As plugin execution may not fire the plugin (i.e., on WYSIWYG editors), on those cases, the plugin line is returned.
    82|      *
    83|      * @param pluginMarkup plugin markup line
    84|      * @param pluginContent the plugin content.
    85|      * @return plugin execution, or plugin markup line if it wasn't executed.
    86|      */
    87|     String pluginInvocation( final String pluginMarkup, final PluginContent pluginContent ) {
    88|         final String pluginInvocation = pluginContent.invoke( wikiContext );
    89|         if( pluginMarkup.equals( pluginInvocation + "()" ) ) { // plugin line markup == plugin execution + "()" -> hasn't been executed
    90|             return pluginMarkup;
    91|         } else {
    92|             return pluginInvocation;
    93|         }
    94|     }
    95|     void handleTableOfContentsPlugin(final NodeTracker state, final JSPWikiLink link) {
    96|         if( !m_wysiwygEditorMode ) {
    97|             final ResourceBundle rb = Preferences.getBundle( wikiContext, Plugin.CORE_PLUGINS_RESOURCEBUNDLE );
    98|             final HtmlInline divToc = new HtmlInline( CharSubSequence.of( "<div class=\"toc\">\n" ) );
    99|             final HtmlInline divCollapseBox = new HtmlInline( CharSubSequence.of( "<div class=\"collapsebox\">\n" ) );
   100|             final HtmlInline divsClosing = new HtmlInline( CharSubSequence.of( "</div>\n</div>\n" ) );
   101|             final HtmlInline h4Title = new HtmlInline( CharSubSequence.of( "<h4 id=\"section-TOC\">" + // FIXME proper plugin parameters handling
   102|                                                                            rb.getString( "tableofcontents.title" ) +
   103|                                                                            "</h4>\n" ) );
   104|             final TocBlock toc = new TocBlock( CharSubSequence.of( "[TOC]" ), CharSubSequence.of( "levels=1-3" ) );
   105|             link.insertAfter( divToc );
   106|             divToc.insertAfter( divCollapseBox );
   107|             divCollapseBox.insertAfter( h4Title );
   108|             h4Title.insertAfter( toc );
   109|             toc.insertAfter( divsClosing );
   110|         } else {
   111|             NodePostProcessorStateCommonOperations.inlineLinkTextOnWysiwyg( state, link, m_wysiwygEditorMode );
   112|         }
   113|         removeLink( state, link );
   114|     }
   115|     void removeLink(final NodeTracker state, final JSPWikiLink link) {
   116|         link.unlink();
   117|         state.nodeRemoved( link );
   118|     }
   119| }


# ====================================================================
# FILE: jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/VariableLinkNodePostProcessorState.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-56 ---
     1| /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.markdown.extensions.jspwikilinks.postprocessor;
    18| import com.vladsch.flexmark.ast.HtmlInline;
    19| import com.vladsch.flexmark.util.ast.Node;
    20| import com.vladsch.flexmark.util.ast.NodeTracker;
    21| import com.vladsch.flexmark.util.sequence.CharSubSequence;
    22| import org.apache.commons.text.StringEscapeUtils;
    23| import org.apache.wiki.api.core.Context;
    24| import org.apache.wiki.api.exceptions.NoSuchVariableException;
    25| import org.apache.wiki.markdown.nodes.JSPWikiLink;
    26| import org.apache.wiki.variables.VariableManager;
    27| /**
    28|  * {@link NodePostProcessorState} which further post processes WikiVariable links.
    29|  */
    30| public class VariableLinkNodePostProcessorState implements NodePostProcessorState< JSPWikiLink > {
    31|     private final Context wikiContext;
    32|     private final boolean m_wysiwygEditorMode;
    33|     public VariableLinkNodePostProcessorState( final Context wikiContext ) {
    34|         this.wikiContext = wikiContext;
    35|         final Boolean wysiwygVariable = wikiContext.getVariable( Context.VAR_WYSIWYG_EDITOR_MODE );
    36|         m_wysiwygEditorMode = wysiwygVariable != null && wysiwygVariable;
    37|     }
    38|     /**
    39|      * {@inheritDoc}
    40|      *
    41|      * @see NodePostProcessorState#process(NodeTracker, Node)
    42|      */
    43|     @Override
    44|     public void process( final NodeTracker state, final JSPWikiLink link ) {
    45|         final String variable = NodePostProcessorStateCommonOperations.inlineLinkTextOnWysiwyg( state, link, m_wysiwygEditorMode );
    46|         if( !m_wysiwygEditorMode ) {
    47|             try {
    48|                 final String parsedVariable = wikiContext.getEngine().getManager( VariableManager.class ).parseAndGetValue( wikiContext, variable );
    49|                 final HtmlInline content = new HtmlInline( CharSubSequence.of( StringEscapeUtils.escapeXml11( parsedVariable ) ) );
    50|                 NodePostProcessorStateCommonOperations.addContent( state, link, content );
    51|             } catch( final NoSuchVariableException e ) {
    52|                 NodePostProcessorStateCommonOperations.makeError( state, link, "No such variable: " + variable + " (" + e.getMessage() + ")" );
    53|             }
    54|         }
    55|     }
    56| }


# ====================================================================
# FILE: jspwiki-markdown/src/main/java/org/apache/wiki/markdown/renderer/JSPWikiLinkRenderer.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 4-61 ---
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16| */
    17| package org.apache.wiki.markdown.renderer;
    18| import com.vladsch.flexmark.html.HtmlWriter;
    19| import com.vladsch.flexmark.html.renderer.LinkType;
    20| import com.vladsch.flexmark.html.renderer.NodeRenderer;
    21| import com.vladsch.flexmark.html.renderer.NodeRendererContext;
    22| import com.vladsch.flexmark.html.renderer.NodeRenderingHandler;
    23| import com.vladsch.flexmark.html.renderer.ResolvedLink;
    24| import org.apache.wiki.markdown.nodes.JSPWikiLink;
    25| import java.util.HashSet;
    26| import java.util.Set;
    27| /**
    28|  * Flexmark {@link NodeRenderer} for {@link JSPWikiLink}s.
    29|  */
    30| public class JSPWikiLinkRenderer implements NodeRenderer {
    31|     /**
    32|      * {@inheritDoc}
    33|      *
    34|      * @see com.vladsch.flexmark.html.renderer.NodeRenderer#getNodeRenderingHandlers()
    35|      */
    36|     @Override
    37|     public Set< NodeRenderingHandler< ? > > getNodeRenderingHandlers() {
    38|         final HashSet< NodeRenderingHandler< ? > > set = new HashSet<>();
    39|         set.add( new NodeRenderingHandler<>( JSPWikiLink.class, new NodeRenderingHandler.CustomNodeRenderer<>() {
    40|             /**
    41|              * {@inheritDoc}
    42|              */
    43|             @Override
    44|             public void render(final JSPWikiLink node, final NodeRendererContext context, final HtmlWriter html) {
    45|                 if (context.isDoNotRenderLinks()) {
    46|                     context.renderChildren(node);
    47|                 } else {
    48|                     final ResolvedLink resolvedLink = context.resolveLink(LinkType.LINK, node.getUrl().unescape(), null);
    49|                     html.attr("href", resolvedLink.getUrl());
    50|                     if (node.getTitle().isNotNull()) {
    51|                         html.attr("title", node.getTitle().unescape());
    52|                     }
    53|                     html.srcPos(node.getChars()).withAttr(resolvedLink).tag("a");
    54|                     context.renderChildren(node);
    55|                     html.tag("/a");
    56|                 }
    57|             }
    58|         } ) );
    59|         return set;
    60|     }
    61| }


# ====================================================================
# FILE: jspwiki-markdown/src/main/java/org/apache/wiki/parser/markdown/MarkdownDocument.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 3-68 ---
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.parser.markdown;
    18| import com.vladsch.flexmark.ext.attributes.AttributesExtension;
    19| import com.vladsch.flexmark.ext.definition.DefinitionExtension;
    20| import com.vladsch.flexmark.ext.footnotes.FootnoteExtension;
    21| import com.vladsch.flexmark.ext.tables.TablesExtension;
    22| import com.vladsch.flexmark.ext.toc.TocExtension;
    23| import com.vladsch.flexmark.parser.Parser;
    24| import com.vladsch.flexmark.parser.ParserEmulationProfile;
    25| import com.vladsch.flexmark.util.ast.Node;
    26| import com.vladsch.flexmark.util.data.MutableDataSet;
    27| import com.vladsch.flexmark.util.misc.Extension;
    28| import org.apache.oro.text.regex.Pattern;
    29| import org.apache.wiki.api.core.Context;
    30| import org.apache.wiki.api.core.Page;
    31| import org.apache.wiki.markdown.MarkdownForJSPWikiExtension;
    32| import org.apache.wiki.parser.JSPWikiMarkupParser;
    33| import org.apache.wiki.parser.WikiDocument;
    34| import java.util.Arrays;
    35| import java.util.List;
    36| /**
    37|  * Simple placeholder for Markdown Nodes
    38|  */
    39| public class MarkdownDocument extends WikiDocument {
    40|     private static final long serialVersionUID = 1L;
    41|     private final Node md;
    42|     public MarkdownDocument( final Page page, final Node md ) {
    43|         super( page );
    44|         this.md = md;
    45|     }
    46|     public Node getMarkdownNode() {
    47|         return md;
    48|     }
    49|     /**
    50|      * Configuration options for MarkdownRenderers.
    51|      *
    52|      * @param context current wiki context
    53|      * @return configuration options for MarkdownRenderers.
    54|      */
    55|     public static MutableDataSet options( final Context context, final boolean isImageInlining, final List< Pattern > inlineImagePatterns ) {
    56|         final MutableDataSet options = new MutableDataSet();
    57|         options.setFrom( ParserEmulationProfile.COMMONMARK );
    58|         options.set( AttributesExtension.ASSIGN_TEXT_ATTRIBUTES, true );
    59|         options.set( FootnoteExtension.FOOTNOTE_LINK_REF_CLASS, JSPWikiMarkupParser.CLASS_FOOTNOTE_REF );
    60|         options.set( Parser.EXTENSIONS, Arrays.asList( new Extension[] { new MarkdownForJSPWikiExtension( context, isImageInlining, inlineImagePatterns ),
    61|                                                                          AttributesExtension.create(),
    62|                                                                          DefinitionExtension.create(),
    63|                                                                          FootnoteExtension.create(),
    64|                                                                          TablesExtension.create(),
    65|                                                                          TocExtension.create() } ) );
    66|         return options;
    67|     }
    68| }


# ====================================================================
# FILE: jspwiki-util/src/main/java/org/apache/wiki/util/CryptoUtil.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 2-227 ---
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.  
    16|  */
    17| package org.apache.wiki.util;
    18| import java.nio.charset.StandardCharsets;
    19| import java.security.MessageDigest;
    20| import java.security.NoSuchAlgorithmException;
    21| import java.security.SecureRandom;
    22| import java.util.Arrays;
    23| import java.util.Base64;
    24| import java.util.Random;
    25| /**
    26|  * Hashes and verifies salted SHA-1 passwords, which are compliant with RFC
    27|  * 2307.
    28|  */
    29| public final class CryptoUtil
    30| {
    31|     private static final String SSHA = "{SSHA}";
    32|     private static final String SHA1 = "{SHA-1}";
    33|     private static final String SHA256 = "{SHA-256}";
    34|     private static final Random RANDOM = new SecureRandom();
    35|     private static final int DEFAULT_SALT_SIZE = 8;
    36|     private static final Object HELP = "--help";
    37|     private static final Object HASH = "--hash";
    38|     private static final Object VERIFY = "--verify";
    39|     /**
    40|      * Private constructor to prevent direct instantiation.
    41|      */
    42|     private CryptoUtil()
    43|     {
    44|     }
    45|     /**
    46|      * <p>
    47|      * Convenience method for hashing and verifying salted SHA-1 or SHA-256 passwords from
    48|      * the command line. This method requires <code>commons-codec-1.3.jar</code>
    49|      * (or a newer version) to be on the classpath. Command line arguments are
    50|      * as follows:
    51|      * </p>
    52|      * <ul>
    53|      * <li><code>--hash <var>password</var> SSHA</code> - hashes <var>password</var></code>
    54|      * and prints a password digest that looks like this: <blockquote><code>{SSHA}yfT8SRT/WoOuNuA6KbJeF10OznZmb28=</code></blockquote></li>
    55|      * <li><code>--verify <var>password</var> <var>digest</var></code> -
    56|      * verifies <var>password</var> by extracting the salt from <var>digest</var>
    57|      * (which is identical to what is printed by <code>--hash</code>) and
    58|      * re-computing the digest again using the password and salt. If the
    59|      * password supplied is the same as the one used to create the original
    60|      * digest, <code>true</code> will be printed; otherwise <code>false</code></li>
    61|      * </ul>
    62|      * <p>For example, one way to use this utility is to change to JSPWiki's <code>build</code> directory
    63|      * and type the following command:</p>
    64|      * <blockquote><code>java -cp JSPWiki.jar:../lib/commons-codec-1.3.jar org.apache.wiki.util.CryptoUtil --hash mynewpassword</code></blockquote>
    65|      * 
    66|      * @param args arguments for this method as described above
    67|      * @throws Exception Catches nothing; throws everything up.
    68|      */
    69|     public static void main( final String[] args ) throws Exception
    70|     {
    71|         if( args.length == 0 || (args.length == 1 && HELP.equals( args[0] )) )
    72|         {
    73|             System.out.println( "Usage: CryptoUtil [options] " );
    74|             System.out.println( "   --hash   password algorithm             create hash for password" );
    75|             System.out.println( "   --verify password digest algorithm      verify password for digest" );
    76|             System.out.println( "Valid algorithm options are {SSHA} and {SHA-256}. If no algorithm is specified or an unsupported algorithm is specified, SHA-256 is used." );
    77|         }
    78|         if( HASH.equals( args[0] ) )
    79|         {
    80|             if( args.length < 2 )
    81|             {
    82|                 throw new IllegalArgumentException( "Error: --hash requires a 'password' argument." );
    83|             }
    84|             final String password = args[1].trim();
    85|             final String algorithm = args.length > 2 ? args[2].trim() : SHA256;
    86|             System.out.println( CryptoUtil.getSaltedPassword( password.getBytes( StandardCharsets.UTF_8 ), algorithm ) );
    87|         }
    88|         else if( VERIFY.equals( args[0] ) )
    89|         {
    90|             if( args.length < 3 )
    91|             {
    92|                 throw new IllegalArgumentException( "Error: --hash requires 'password' and 'digest' arguments." );
    93|             }
    94|             final String password = args[1].trim();
    95|             final String digest = args[2].trim();
    96|             System.out.println( CryptoUtil.verifySaltedPassword( password.getBytes( StandardCharsets.UTF_8 ), digest ) );
    97|         }
    98|         else
    99|         {
   100|             System.out.println( "Wrong usage. Try --help." );
   101|         }
   102|     }
   103|     /**
   104|      * <p>
   105|      * Creates an RFC 2307-compliant salted, hashed password with the SHA1 or SHA-256
   106|      * MessageDigest algorithm. After the password is digested, the first 20 or 32
   107|      * bytes of the digest will be the actual password hash; the remaining bytes
   108|      * will be a randomly generated salt of length {@link #DEFAULT_SALT_SIZE},
   109|      * for example: <blockquote><code>{SSHA}3cGWem65NCEkF5Ew5AEk45ak8LHUWAwPVXAyyw==</code></blockquote>
   110|      * </p>
   111|      * <p>
   112|      * In layman's terms, the formula is
   113|      * <code>digest( secret + salt ) + salt</code>. The resulting digest is
   114|      * Base64-encoded.
   115|      * </p>
   116|      * <p>
   117|      * Note that successive invocations of this method with the same password
   118|      * will result in different hashes! (This, of course, is exactly the point.)
   119|      * </p>
   120|      * 
   121|      * @param password the password to be digested
   122|      * @return the Base64-encoded password hash, prepended by
   123|      *         <code>{SSHA}</code> or <code>{SHA256}</code>.
   124|      * @throws NoSuchAlgorithmException If your JVM does not supply the necessary algorithm. Should not happen.
   125|      */
   126|     public static String getSaltedPassword(final byte[] password, final String algorithm ) throws NoSuchAlgorithmException
   127|     {
   128|         final byte[] salt = new byte[DEFAULT_SALT_SIZE];
   129|         RANDOM.nextBytes( salt );
   130|         return getSaltedPassword( password, salt, algorithm );
   131|     }
   132|     /**
   133|      * <p>
   134|      * Helper method that creates an RFC 2307-compliant salted, hashed password with the SHA1 or SHA256
   135|      * MessageDigest algorithm. After the password is digested, the first 20 or 32
   136|      * bytes of the digest will be the actual password hash; the remaining bytes
   137|      * will be the salt. Thus, supplying a password <code>testing123</code>
   138|      * and a random salt <code>foo</code> produces the hash when using SHA1:
   139|      * </p>
   140|      * <blockquote><code>{SSHA}yfT8SRT/WoOuNuA6KbJeF10OznZmb28=</code></blockquote>
   141|      * <p>
   142|      * In layman's terms, the formula is
   143|      * <code>digest( secret + salt ) + salt</code>. The resulting digest is Base64-encoded.</p>
   144|      * 
   145|      * @param password the password to be digested
   146|      * @param salt the random salt
   147|      * @return the Base64-encoded password hash, prepended by <code>{SSHA}</code> or <code>{SHA256}</code>.
   148|      * @throws NoSuchAlgorithmException If your JVM does not supply the necessary algorithm. Should not happen.
   149|      */
   150|     static String getSaltedPassword(final byte[] password, final byte[] salt, final String algorithm ) throws NoSuchAlgorithmException
   151|     {
   152|         final String algorithmToUse = algorithm.equals(SSHA) ? SHA1 : algorithm;
   153|         final MessageDigest digest = MessageDigest.getInstance( algorithmToUse.substring( 1, algorithmToUse.length() -1 ) );
   154|         digest.update( password );
   155|         final byte[] hash = digest.digest( salt );
   156|         final byte[] all = new byte[hash.length + salt.length];
   157|         System.arraycopy(hash, 0, all, 0, hash.length);
   158|         System.arraycopy(salt, 0, all, hash.length, salt.length);
   159|         final byte[] base64 = Base64.getEncoder().encode( all );
   160|         return algorithm + new String( base64, StandardCharsets.UTF_8 );
   161|     }
   162|     /**
   163|      *  Compares a password to a given entry and returns true, if it matches.
   164|      *
   165|      *  @param password The password in bytes.
   166|      *  @param entry The password entry, typically starting with {SSHA}.
   167|      *  @return True, if the password matches.
   168|      *  @throws NoSuchAlgorithmException If there is no SHA available.
   169|      */
   170|     public static boolean verifySaltedPassword(final byte[] password, final String entry ) throws NoSuchAlgorithmException
   171|     {
   172|         if( !entry.startsWith( SSHA ) && !entry.startsWith( SHA256 ) )
   173|         {
   174|             throw new IllegalArgumentException( "Hash not prefixed by expected algorithm; is it really a salted hash?" );
   175|         }
   176|         final String algorithm = entry.startsWith( SSHA ) ? SSHA : SHA256;
   177|         final byte[] challenge = Base64.getDecoder().decode( entry.substring( algorithm.length() )
   178|                 .getBytes( StandardCharsets.UTF_8 ) );
   179|         final byte[] passwordHash = extractPasswordHash( challenge, algorithm.equals(SSHA) ? 20 : 32 );
   180|         final byte[] salt = extractSalt( challenge, algorithm.equals(SSHA) ? 20 : 32  );
   181|         final String algorithmToUse = algorithm.equals(SSHA) ? SHA1 : algorithm;
   182|         final MessageDigest digest = MessageDigest.getInstance( algorithmToUse.substring( 1, algorithmToUse.length() -1 ) );
   183|         digest.update( password );
   184|         final byte[] hash = digest.digest( salt );
   185|         return Arrays.equals( passwordHash, hash );
   186|     }
   187|     /**
   188|      * Helper method that extracts the hashed password fragment from a supplied salted SHA-1 or SHA-256 digest
   189|      * by taking all of the characters before position 20 or 32 depending on algorithm.
   190|      * 
   191|      * @param digest the salted digest, which is assumed to have been
   192|      *            previously decoded from Base64.
   193|      * @return the password hash
   194|      * @throws IllegalArgumentException if the length of the supplied digest is
   195|      *             less than or equal to 20 bytes
   196|      */
   197|     static byte[] extractPasswordHash(final byte[] digest, final int hashLength ) throws IllegalArgumentException
   198|     {
   199|         if( digest.length < hashLength )
   200|         {
   201|             throw new IllegalArgumentException( "Hash was shorter than expected; could not extract password hash!" );
   202|         }
   203|         final byte[] hash = new byte[hashLength];
   204|         System.arraycopy(digest, 0, hash, 0, hashLength);
   205|         return hash;
   206|     }
   207|     /**
   208|      * Helper method that extracts the salt from supplied salted digest by taking all of the
   209|      * characters after a given index.
   210|      * 
   211|      * @param digest the salted digest, which is assumed to have been previously
   212|      *            decoded from Base64.
   213|      * @return the salt
   214|      * @throws IllegalArgumentException if the length of the supplied digest is
   215|      *             less than given length.
   216|      */
   217|     static byte[] extractSalt(final byte[] digest, final int hashLength ) throws IllegalArgumentException
   218|     {
   219|         if( digest.length <= hashLength )
   220|         {
   221|             throw new IllegalArgumentException( "Hash was shorter than expected; we found no salt!" );
   222|         }
   223|         final byte[] salt = new byte[digest.length - hashLength];
   224|         System.arraycopy(digest, hashLength, salt, 0, digest.length - hashLength);
   225|         return salt;
   226|     }
   227| }


# ====================================================================
# FILE: jspwiki-util/src/main/java/org/apache/wiki/util/TextUtil.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 575-614 ---
   575|                 if( wasSpace ) {
   576|                     continue;
   577|                 }
   578|                 wasSpace = true;
   579|             } else {
   580|                 wasSpace = false;
   581|             }
   582|             if( Character.isLetterOrDigit( ch ) || allowedChars.indexOf( ch ) != -1 ) {
   583|                 if( isWord ) {
   584|                     ch = Character.toUpperCase( ch );
   585|                 }
   586|                 clean.append( ch );
   587|                 isWord = false;
   588|             } else {
   589|                 isWord = true;
   590|             }
   591|         }
   592|         return clean.toString();
   593|     }
   594|     /**
   595|      *  Creates a Properties object based on an array which contains alternatively a key and a value.  It is useful
   596|      *  for generating default mappings. For example:
   597|      *  <pre>
   598|      *     String[] properties = { "jspwiki.property1", "value1", "jspwiki.property2", "value2 };
   599|      *     Properties props = TextUtil.createPropertes( values );
   600|      *     System.out.println( props.getProperty("jspwiki.property1") );
   601|      *  </pre>
   602|      *  would output "value1".
   603|      *
   604|      *  @param values Alternating key and value pairs.
   605|      *  @return Property object
   606|      *  @see java.util.Properties
   607|      *  @throws IllegalArgumentException if the property array is missing a value for a key.
   608|      *  @since 2.2.
   609|      */
   610|     public static Properties createProperties( final String[] values ) throws IllegalArgumentException {
   611|         if( values.length % 2 != 0 ) {
   612|         	throw new IllegalArgumentException( "One value is missing.");
   613|         }
   614|         final Properties props = new Properties();

