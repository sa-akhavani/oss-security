# ====================================================================
# FILE: jspwiki-api/src/main/java/org/apache/wiki/api/Release.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 30-70 ---
    30|  *  @since  1.0
    31|  */
    32| public final class Release {
    33|     private static final String VERSION_SEPARATORS = ".-";
    34|     /**
    35|      *  This is the default application name.
    36|      */
    37|     public static final String     APPNAME       = "JSPWiki";
    38|     /**
    39|      *  This should be empty when doing a release - otherwise keep it as "-git-" so that whenever someone checks out the code, they know
    40|      *  it is a bleeding-edge version.  Other possible values are "-alpha-" and "-beta-" for alpha and beta versions, respectively.
    41|      *  <p>
    42|      *  If the POSTFIX is empty, it is not added to the version string.
    43|      */
    44|     private static final String    POSTFIX       = "";
    45|     /** The JSPWiki major version. */
    46|     public static final int        VERSION       = 2;
    47|     /** The JSPWiki revision. */
    48|     public static final int        REVISION      = 12;
    49|     /** The minor revision.  */
    50|     public static final int        MINORREVISION = 3;
    51|     /** The build number/identifier.  This is a String as opposed to an integer, just so that people can add other identifiers to it.
    52|      * The build number is incremented every time a committer checks in code, and reset when a release is made.
    53|      *  <p>
    54|      *  If you are a person who likes to build his own releases, we recommend that you add your initials to this
    55|      *  identifier (e.g. "13-jj", or "49-aj").
    56|      *  <p>
    57|      *  If the build identifier is empty, it is not added.
    58|      */
    59|     public static final String     BUILD         = "";
    60|     /**
    61|      *  This is the generic version string you should use when printing out the version.  It is of
    62|      *  the form "VERSION.REVISION.MINORREVISION[-POSTFIX][-BUILD]".
    63|      */
    64|     public static final String     VERSTR        = VERSION + "." +
    65|                                                    REVISION + "." +
    66|                                                    MINORREVISION +
    67|                                                    POSTFIX +
    68|                                                    BUILD;
    69|     /** Private constructor prevents instantiation. */
    70|     private Release() {


# ====================================================================
# FILE: jspwiki-bootstrap/src/main/java/org/apache/wiki/bootstrap/WikiBootstrapServletContextListener.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 6-97 ---
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.bootstrap;
    18| import org.apache.logging.log4j.LogManager;
    19| import org.apache.logging.log4j.Logger;
    20| import org.apache.logging.log4j.core.LoggerContext;
    21| import org.apache.logging.log4j.core.config.Configuration;
    22| import org.apache.logging.log4j.core.config.ConfigurationSource;
    23| import org.apache.logging.log4j.core.config.properties.PropertiesConfigurationFactory;
    24| import org.apache.wiki.api.spi.Wiki;
    25| import org.apache.wiki.util.TextUtil;
    26| import javax.servlet.ServletContextEvent;
    27| import javax.servlet.ServletContextListener;
    28| import java.io.ByteArrayInputStream;
    29| import java.io.ByteArrayOutputStream;
    30| import java.io.IOException;
    31| import java.io.InputStream;
    32| import java.util.Properties;
    33| public class WikiBootstrapServletContextListener implements ServletContextListener {
    34|     private static final Logger LOG = LogManager.getLogger( WikiBootstrapServletContextListener.class );
    35|     private static final String[] LOG4J_CONF = new String[] { "appender", "logger", "rootLogger", "filter", "status", "dest", "name", "properties", "property", "log4j2" };
    36|     /** {@inheritDoc} */
    37|     @Override
    38|     public void contextInitialized( final ServletContextEvent sce ) {
    39|         final Properties properties = initWikiSPIs( sce );
    40|         initWikiLoggingFramework( properties );
    41|     }
    42|     /**
    43|      * Locate and init JSPWiki SPIs' implementations
    44|      *
    45|      * @param sce associated servlet context.
    46|      * @return JSPWiki configuration properties.
    47|      */
    48|     Properties initWikiSPIs( final ServletContextEvent sce ) {
    49|         return Wiki.init( sce.getServletContext() );
    50|     }
    51|     /**
    52|      * Initialize the logging framework(s). By default, we try to load the log config statements from jspwiki.properties,
    53|      * unless the property jspwiki.use.external.logconfig=true, in that case we let the logging framework figure out the
    54|      * logging configuration.
    55|      *
    56|      * @param properties JSPWiki configuration properties.
    57|      * @return {@code true} if configuration was read from jspwiki.properties, {@code false} otherwise.
    58|      */
    59|     boolean initWikiLoggingFramework( final Properties properties ) {
    60|         final String useExternalLogConfig = TextUtil.getStringProperty( properties, "jspwiki.use.external.logconfig", "false" );
    61|         if ( useExternalLogConfig.equals( "false" ) ) {
    62|             final ConfigurationSource source = createConfigurationSource( properties );
    63|             if( source != null ) {
    64|                 final PropertiesConfigurationFactory factory = new PropertiesConfigurationFactory();
    65|                 final LoggerContext ctx = ( LoggerContext ) LogManager.getContext( this.getClass().getClassLoader(), false );
    66|                 final Configuration conf = factory.getConfiguration( ctx, source );
    67|                 conf.initialize();
    68|                 ctx.setConfiguration( conf );
    69|                 LOG.info( "Log configuration reloaded from Wiki properties" );
    70|             }
    71|         }
    72|         return useExternalLogConfig.equals( "false" );
    73|     }
    74|     ConfigurationSource createConfigurationSource( final Properties properties ) {
    75|         final ByteArrayOutputStream out = new ByteArrayOutputStream();
    76|         try {
    77|             final Properties log4JProperties = new Properties();
    78|             properties.forEach( ( k, v ) -> {
    79|                 for( final String log4JNsProp : LOG4J_CONF ) {
    80|                     if( k.toString().startsWith( log4JNsProp ) ) {
    81|                         log4JProperties.put( k, v );
    82|                     }
    83|                 }
    84|             } );
    85|             log4JProperties.store( out, null );
    86|             final InputStream in = new ByteArrayInputStream( out.toByteArray() );
    87|             return new ConfigurationSource( in );
    88|         } catch( final IOException ioe ) {
    89|             LOG.error( "Unable to load the properties file into Log4j2, default Log4J2 configuration will be applied.", ioe );
    90|             return null;
    91|         }
    92|     }
    93|     /** {@inheritDoc} */
    94|     @Override
    95|     public void contextDestroyed( final ServletContextEvent sce ) {
    96|     }
    97| }


# ====================================================================
# FILE: jspwiki-cache/src/main/java/org/apache/wiki/cache/CachingManager.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 80-108 ---
    80|      * @param supplier if the element is not cached, try to retrieve from the cached system.
    81|      * @throws E the supplier may throw a checked exception, which is propagated upwards.
    82|      * @return The requested item or {@code null} if either the cache is not enabled or the item is not present on the cache / cached service.
    83|      */
    84|     < T, E extends Exception > T get( String cacheName, Serializable key, CheckedSupplier< T, E > supplier ) throws E;
    85|     /**
    86|      * Puts an item on a cache.
    87|      *
    88|      * @param cacheName The cache in which the item will live.
    89|      * @param key item's identifier.
    90|      * @param val item to insert in the cache.
    91|      */
    92|     void put( String cacheName, Serializable key, Object val );
    93|     /**
    94|      * Removes an item from a cache.
    95|      *
    96|      * @param cacheName The cache in which the item to be removed lives.
    97|      * @param key item's identifier.
    98|      */
    99|     void remove( String cacheName, Serializable key );
   100|     /**
   101|      * Register a listener associated with the given cache and type of listener.
   102|      * @param cacheName the name of the cache where the listener will be registered.
   103|      * @param listener the kind of listener to be registered
   104|      * @param args arguments needed to instantiate and register the listener.
   105|      * @return {@code true} if the listener is created & registered, {@code false} otherwise.
   106|      */
   107|     default boolean registerListener( String cacheName, String listener, Object... args ) { return false; }
   108| }


# ====================================================================
# FILE: jspwiki-cache/src/main/java/org/apache/wiki/cache/EhcacheCachingManager.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-57 ---
     1| /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.cache;
    18| import net.sf.ehcache.Cache;
    19| import net.sf.ehcache.CacheManager;
    20| import net.sf.ehcache.Ehcache;
    21| import net.sf.ehcache.Element;
    22| import net.sf.ehcache.event.CacheEventListenerAdapter;
    23| import org.apache.logging.log4j.LogManager;
    24| import org.apache.logging.log4j.Logger;
    25| import org.apache.wiki.api.core.Engine;
    26| import org.apache.wiki.api.engine.Initializable;
    27| import org.apache.wiki.api.exceptions.WikiException;
    28| import org.apache.wiki.util.CheckedSupplier;
    29| import org.apache.wiki.util.TextUtil;
    30| import java.io.Serializable;
    31| import java.net.URL;
    32| import java.util.Collections;
    33| import java.util.List;
    34| import java.util.Map;
    35| import java.util.Properties;
    36| import java.util.concurrent.ConcurrentHashMap;
    37| import java.util.concurrent.atomic.AtomicBoolean;
    38| /**
    39|  * Ehcache-based {@link CachingManager}.
    40|  */
    41| public class EhcacheCachingManager implements CachingManager, Initializable {
    42|     private static final Logger LOG = LogManager.getLogger( EhcacheCachingManager.class );
    43|     private static final int DEFAULT_CACHE_SIZE = 1_000;
    44|     private static final int DEFAULT_CACHE_EXPIRY_PERIOD = 24*60*60;
    45|     final Map< String, Cache > cacheMap = new ConcurrentHashMap<>();
    46|     final Map< String, CacheInfo > cacheStats = new ConcurrentHashMap<>();
    47|     CacheManager cacheManager;
    48|     /** {@inheritDoc} */
    49|     @Override
    50|     public void shutdown() {
    51|         if(!cacheMap.isEmpty()) {
    52|             CacheManager.getInstance().shutdown();
    53|             cacheMap.clear();
    54|             cacheStats.clear();
    55|         }
    56|     }
    57|     /** {@inheritDoc} */

# --- HUNK 2: Lines 126-164 ---
   126|                 }
   127|                 return value;
   128|             }
   129|         }
   130|         return null;
   131|     }
   132|     /** {@inheritDoc} */
   133|     @Override
   134|     public void put( final String cacheName, final Serializable key, final Object val ) {
   135|         if( keyAndCacheAreNotNull( cacheName, key ) ) {
   136|             cacheMap.get( cacheName ).put( new Element( key, val ) );
   137|         }
   138|     }
   139|     /** {@inheritDoc} */
   140|     @Override
   141|     public void remove( final String cacheName, final Serializable key ) {
   142|         if( keyAndCacheAreNotNull( cacheName, key ) ) {
   143|             cacheMap.get( cacheName ).remove( key );
   144|         }
   145|     }
   146|     /** {@inheritDoc} */
   147|     @Override
   148|     public boolean registerListener( final String cacheName, final String listener, final Object... args ) {
   149|         if( enabled( cacheName ) && "expired".equals( listener ) ) {
   150|             final AtomicBoolean allRequested = ( AtomicBoolean )args[0];
   151|             final CacheEventListenerAdapter expiredCacheListenerAdapter = new CacheEventListenerAdapter() {
   152|                 @Override
   153|                 public void notifyElementExpired( final Ehcache cache, final Element element ) {
   154|                     allRequested.set( false ); // signal that the cache no longer contains all elements...
   155|                 }
   156|             };
   157|             return cacheMap.get( cacheName ).getCacheEventNotificationService().registerListener( expiredCacheListenerAdapter );
   158|         }
   159|         return false;
   160|     }
   161|     boolean keyAndCacheAreNotNull( final String cacheName, final Serializable key ) {
   162|         return enabled( cacheName ) && key != null;
   163|     }
   164| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/ajax/AjaxUtil.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 38-79 ---
    38| 			return gson.toJson( input );
    39| 		}
    40| 		return "";
    41| 	}
    42| 	/**
    43| 	 * Given a requestUri path, find the next uri "fragment" after the "/lastPart/" one.
    44| 	 * E.g. given url "/test/abc/travel", and lastPart "abc", this will return "travel". Given lastPart "test" will return "abc".
    45| 	 * 
    46| 	 * This could be done better using a <a href="http://en.wikipedia.org/wiki/URL_Template">URITemplate</a>
    47| 	 * (as <a href="https://tools.ietf.org/html/rfc6570">RFC6570</a>) 
    48| 	 * 
    49| 	 * @param path the RequestURI to search usually done by calling request.getRequestUri().
    50| 	 * @param lastPart the previousPart of the path to search after.
    51| 	 * @return the next part of the path.
    52| 	 * @throws ServletException if {@code path} does not contain {@code lastPart}
    53| 	 */
    54| 	public static String getNextPathPart( String path, String lastPart ) throws ServletException {
    55|         if( StringUtils.isBlank( path ) ) {
    56| 			return null;
    57| 		}
    58|                 if (path.endsWith(lastPart))
    59|                         return lastPart;
    60| 		if( !lastPart.endsWith( "/" ) ) {
    61| 			lastPart += "/";
    62| 		}
    63| 		final int lastPartLength =  lastPart.length();
    64| 		int index = path.indexOf( lastPart );
    65| 		if( index < 0 ) {
    66| 			lastPart = lastPart.substring( 0, lastPartLength - 1 );
    67| 			index = path.indexOf( lastPart );
    68| 			if( index < 0 ) {
    69| 				throw new ServletException( "Invalid path provided " + path + " does not contain '" + lastPart + "'" );
    70| 			}
    71| 		}
    72| 		path = path.substring( index + lastPartLength );
    73| 		index = path.indexOf( "/" );
    74| 		if( index == -1 ) {
    75| 			index = path.indexOf( "#" );
    76| 			if( index == -1 ) {
    77| 				index = path.indexOf( "?" );
    78| 			}
    79| 		}


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/attachment/DefaultAttachmentManager.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.attachment;
    18| import org.apache.commons.lang3.StringUtils;
    19| import org.apache.logging.log4j.LogManager;
    20| import org.apache.logging.log4j.Logger;
    21| import org.apache.wiki.api.core.Attachment;
    22| import org.apache.wiki.api.core.Context;
    23| import org.apache.wiki.api.core.Engine;
    24| import org.apache.wiki.api.core.Page;
    25| import org.apache.wiki.api.exceptions.NoRequiredPropertyException;
    26| import org.apache.wiki.api.exceptions.ProviderException;
    27| import org.apache.wiki.api.providers.AttachmentProvider;
    28| import org.apache.wiki.api.spi.Wiki;
    29| import org.apache.wiki.cache.CachingManager;
    30| import org.apache.wiki.pages.PageManager;
    31| import org.apache.wiki.parser.MarkupParser;
    32| import org.apache.wiki.references.ReferenceManager;
    33| import org.apache.wiki.search.SearchManager;
    34| import org.apache.wiki.util.ClassUtil;
    35| import org.apache.wiki.util.TextUtil;
    36| import java.io.IOException;
    37| import java.io.InputStream;
    38| import java.util.ArrayList;

# --- HUNK 2: Lines 72-112 ---
    72|         } else {
    73|             classname = TextUtil.getRequiredProperty( props, PROP_PROVIDER, PROP_PROVIDER_DEPRECATED );
    74|         }
    75|         if( classname == null ) {
    76|             LOG.info( "No attachment provider defined - disabling attachment support." );
    77|             return;
    78|         }
    79|         try {
    80|             m_provider = ClassUtil.buildInstance( "org.apache.wiki.providers", classname );
    81|             m_provider.initialize( m_engine, props );
    82|         } catch( final ReflectiveOperationException e ) {
    83|             LOG.error( "Attachment provider class could not be instantiated", e );
    84|         } catch( final NoRequiredPropertyException e ) {
    85|             LOG.error( "Attachment provider did not find a property that it needed: {}", e.getMessage(), e );
    86|             m_provider = null; // No, it did not work.
    87|         } catch( final IOException e ) {
    88|             LOG.error( "Attachment provider reports IO error", e );
    89|             m_provider = null;
    90|         }
    91|         final String forceDownload = TextUtil.getStringProperty( props, PROP_FORCEDOWNLOAD, null );
    92|         if( StringUtils.isNotEmpty( forceDownload ) ) {
    93|             m_forceDownloadPatterns = forceDownload.toLowerCase().split( "\\s" );
    94|         } else {
    95|             m_forceDownloadPatterns = new String[ 0 ];
    96|         }
    97|     }
    98|     /** {@inheritDoc} */
    99|     @Override
   100|     public boolean attachmentsEnabled() {
   101|         return m_provider != null;
   102|     }
   103|     /** {@inheritDoc} */
   104|     @Override
   105|     public String getAttachmentInfoName( final Context context, final String attachmentname ) {
   106|         final Attachment att;
   107|         try {
   108|             att = getAttachmentInfo( context, attachmentname );
   109|         } catch( final ProviderException e ) {
   110|             LOG.warn( "Finding attachments failed: ", e );
   111|             return null;
   112|         }

# --- HUNK 3: Lines 153-193 ---
   153|     @Override
   154|     public List< Attachment > listAttachments( final Page wikipage ) throws ProviderException {
   155|         if( m_provider == null ) {
   156|             return new ArrayList<>();
   157|         }
   158|         final List< Attachment > atts = new ArrayList<>( m_provider.listAttachments( wikipage ) );
   159|         atts.sort( Comparator.comparing( Attachment::getName, m_engine.getManager( PageManager.class ).getPageSorter() ) );
   160|         return atts;
   161|     }
   162|     /** {@inheritDoc} */
   163|     @Override
   164|     public boolean forceDownload( String name ) {
   165|         if( name == null || name.isEmpty() ) {
   166|             return false;
   167|         }
   168|         name = name.toLowerCase();
   169|         if( name.indexOf( '.' ) == -1 ) {
   170|             return true;  // force download on attachments without extension or type indication
   171|         }
   172|         for( final String forceDownloadPattern : m_forceDownloadPatterns ) {
   173|             if( ( name.endsWith( forceDownloadPattern ) && !forceDownloadPattern.isEmpty() ) || "*".equals( forceDownloadPattern ) ) {
   174|                 return true;
   175|             }
   176|         }
   177|         return false;
   178|     }
   179|     /** {@inheritDoc} */
   180|     @Override
   181|     public InputStream getAttachmentStream( final Context ctx, final Attachment att ) throws ProviderException, IOException {
   182|         if( m_provider == null ) {
   183|             return null;
   184|         }
   185|         if( att instanceof DynamicAttachment ) {
   186|             return ( ( DynamicAttachment )att ).getProvider().getAttachmentData( ctx, att );
   187|         }
   188|         return m_provider.getAttachmentData( att );
   189|     }
   190|     /** {@inheritDoc} */
   191|     @Override
   192|     public void storeDynamicAttachment( final Context ctx, final DynamicAttachment att ) {
   193|         cachingManager.put( CachingManager.CACHE_ATTACHMENTS_DYNAMIC, att.getName(), att );


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/auth/DefaultUserManager.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 215-258 ---
   215|                                                                  WorkflowManager.WF_UP_CREATE_SAVE_DECISION_MESSAGE_KEY,
   216|                                                                  facts,
   217|                                                                  completionTask,
   218|                                                                  null );
   219|         workflow.setAttribute( WorkflowManager.WF_UP_CREATE_SAVE_ATTR_SAVED_PROFILE, profile );
   220|         workflow.start( context );
   221|         final boolean approvalRequired = workflow.getCurrentStep() instanceof Decision;
   222|         if ( approvalRequired ) {
   223|             throw new DecisionRequiredException( "This profile must be approved before it becomes active" );
   224|         }
   225|     }
   226|     /** {@inheritDoc} */
   227|     @Override
   228|     public UserProfile parseProfile( final Context context ) {
   229|         final UserProfile profile = getUserProfile( context.getWikiSession() );
   230|         final HttpServletRequest request = context.getHttpRequest();
   231|         String loginName = request.getParameter( PARAM_LOGINNAME );
   232|         String password = request.getParameter( PARAM_PASSWORD );
   233|         String fullname = request.getParameter( PARAM_FULLNAME );
   234|         String email = request.getParameter( PARAM_EMAIL );
   235|         loginName = StringUtils.trim( loginName );
   236|         password = InputValidator.isBlank( password ) ? null : password;
   237|         fullname = StringUtils.trim( fullname );
   238|         email = StringUtils.trim( email );
   239|         if ( m_engine.getManager( AuthenticationManager.class ).isContainerAuthenticated() && context.getWikiSession().isAuthenticated() ) {
   240|             loginName = context.getWikiSession().getLoginPrincipal().getName();
   241|         }
   242|         profile.setLoginName( loginName );
   243|         profile.setEmail( email );
   244|         profile.setFullname( fullname );
   245|         profile.setPassword( password );
   246|         return profile;
   247|     }
   248|     /** {@inheritDoc} */
   249|     @Override
   250|     public void validateProfile( final Context context, final UserProfile profile ) {
   251|         final Session session = context.getWikiSession();
   252|         final InputValidator validator = new InputValidator( SESSION_MESSAGES, context );
   253|         final ResourceBundle rb = Preferences.getBundle( context, InternationalizationManager.CORE_BUNDLE );
   254|         final FilterManager fm = m_engine.getManager( FilterManager.class );
   255|         final List< PageFilter > ls = fm.getFilterList();
   256|         for( final PageFilter pf : ls ) {
   257|             if( pf instanceof SpamFilter ) {
   258|                 if( !( ( SpamFilter )pf ).isValidUserProfile( context, profile ) ) {


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/parser/JSPWikiMarkupParser.java
# Total hunks: 6
# ====================================================================
# --- HUNK 1: Lines 1-21 ---
     1|     /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.parser;
    18| import org.apache.commons.lang3.StringUtils;
    19| import org.apache.commons.text.StringEscapeUtils;
    20| import org.apache.logging.log4j.LogManager;
    21| import org.apache.logging.log4j.Logger;

# --- HUNK 2: Lines 178-268 ---
   178|     protected String callMutatorChain( final Collection< StringTransmutator > list, String text ) {
   179|         if( list == null || list.isEmpty()) {
   180|             return text;
   181|         }
   182|         for( final StringTransmutator m : list ) {
   183|             text = m.mutate( m_context, text );
   184|         }
   185|         return text;
   186|     }
   187|     /**
   188|      * Calls the heading listeners.
   189|      *
   190|      * @param param A Heading object.
   191|      */
   192|     private void callHeadingListenerChain( final Heading param ) {
   193|         for( final HeadingListener h : m_headingListenerChain ) {
   194|             h.headingAdded( m_context, param );
   195|         }
   196|     }
   197|     /**
   198|      *  Creates a JDOM anchor element.  Can be overridden to change the URL creation, if you really know what you are doing.
   199|      *
   200|      *  @param type One of the types above
   201|      *  @param link URL to which to link to
   202|      *  @param text Link text
   203|      *  @param section If a particular section identifier is required.
   204|      *  @return An 'A' element.
   205|      *  @since 2.4.78
   206|      */
   207|     private Element createAnchor( final int type, final String link, String text, String section ) {
   208|         text = TextUtil.escapeHTMLEntities( text );
   209|         section = TextUtil.escapeHTMLEntities( section );
   210|         final Element el = new Element( "a" );
   211|         el.setAttribute( "class", CLASS_TYPES[ type ] );
   212|         el.setAttribute( "href", link + section );
   213|         el.addContent( text );
   214|         return el;
   215|     }
   216|     private Element makeLink( int type, final String link, String text, String section, final Iterator< Attribute > attributes ) {
   217|         Element el = null;
   218|         if( text == null ) {
   219|             text = link;
   220|         }
   221|         text = callMutatorChain( m_linkMutators, text );
   222|         section = (section != null) ? ("#"+section) : "";
   223|         if( link.isEmpty() ) {
   224|             type = EMPTY;
   225|         }
   226|         final ResourceBundle rb = Preferences.getBundle( m_context, InternationalizationManager.CORE_BUNDLE );
   227|         switch( type ) {
   228|             case READ:
   229|                 el = createAnchor( READ, m_context.getURL( ContextEnum.PAGE_VIEW.getRequestContext(), link), text, section );
   230|                 break;
   231|             case EDIT:
   232|                 el = createAnchor( EDIT, m_context.getURL( ContextEnum.PAGE_EDIT.getRequestContext(),link), text, "" );
   233|                 el.setAttribute("title", MessageFormat.format( rb.getString( "markupparser.link.create" ), link ) );
   234|                 break;
   235|             case EMPTY:
   236|                 el = new Element("u").addContent(text);
   237|                 break;
   238|             case LOCALREF:
   239|                 el = createAnchor( LOCALREF, "#ref-"+m_context.getName()+"-"+link, "["+text+"]", "" );
   240|                 break;
   241|             case LOCAL:
   242|                 el = new Element( "a" ).setAttribute( "class", CLASS_FOOTNOTE );
   243|                 el.setAttribute( "name", "ref-" + m_context.getName() + "-" + link.substring( 1 ) );
   244|                 if( !m_allowHTML ) {
   245|                     el.addContent( "[" + TextUtil.escapeHTMLEntities( text ) + "]" );
   246|                 } else {
   247|                     el.addContent( "[" + text + "]" );
   248|                 }
   249|                 break;
   250|             case IMAGE:
   251|                 el = new Element( "img" ).setAttribute( "class", "inline" );
   252|                 el.setAttribute( "src", link );
   253|                 el.setAttribute( "alt", text );
   254|                 break;
   255|             case IMAGELINK:
   256|                 el = new Element( "img" ).setAttribute( "class", "inline" );
   257|                 el.setAttribute( "src", link );
   258|                 el.setAttribute( "alt", text );
   259|                 el = createAnchor( IMAGELINK, text, "", "" ).addContent( el );
   260|                 break;
   261|             case IMAGEWIKILINK:
   262|                 final String pagelink = m_context.getURL( ContextEnum.PAGE_VIEW.getRequestContext(), text );
   263|                 el = new Element( "img" ).setAttribute( "class", "inline" );
   264|                 el.setAttribute( "src", link );
   265|                 el.setAttribute( "alt", text );
   266|                 el = createAnchor( IMAGEWIKILINK, pagelink, "", "" ).addContent( el );
   267|                 break;
   268|             case EXTERNAL:

# --- HUNK 3: Lines 329-369 ---
   329|      */
   330|     private String peekAheadLine() throws IOException {
   331|         final String s = readUntilEOL().toString();
   332|         if( s.length() > PUSHBACK_BUFFER_SIZE ) {
   333|             LOG.warn( "Line is longer than maximum allowed size (" + PUSHBACK_BUFFER_SIZE + " characters.  Attempting to recover..." );
   334|             pushBack( s.substring( 0, PUSHBACK_BUFFER_SIZE - 1 ) );
   335|         } else {
   336|             try {
   337|                 pushBack( s );
   338|             } catch( final IOException e ) {
   339|                 LOG.warn( "Pushback failed: the line is probably too long.  Attempting to recover." );
   340|             }
   341|         }
   342|         return s;
   343|     }
   344|     private int flushPlainText() {
   345|         final int numChars = m_plainTextBuf.length();
   346|         if( numChars > 0 ) {
   347|             String buf;
   348|             if( !m_allowHTML ) {
   349|                 buf = TextUtil.escapeHTMLEntities( m_plainTextBuf.toString() );
   350|             } else {
   351|                 buf = m_plainTextBuf.toString();
   352|             }
   353|             m_plainTextBuf = new StringBuilder(20);
   354|             try {
   355|                 if( m_camelCaseLinks && !m_isEscaping && buf.length() > 3 ) {
   356|                     while( m_camelCaseMatcher.contains( buf, m_camelCasePattern ) ) {
   357|                         final MatchResult result = m_camelCaseMatcher.getMatch();
   358|                         final String firstPart = buf.substring( 0, result.beginOffset( 0 ) );
   359|                         String prefix = result.group( 1 );
   360|                         if( prefix == null ) {
   361|                             prefix = "";
   362|                         }
   363|                         final String camelCase = result.group(2);
   364|                         final String protocol  = result.group(3);
   365|                         String uri       = protocol+result.group(4);
   366|                         buf              = buf.substring(result.endOffset(0));
   367|                         m_currentElement.addContent( firstPart );
   368|                         if( prefix.endsWith( "~" ) || prefix.indexOf( '[' ) != -1 ) {
   369|                             if( prefix.endsWith( "~" ) ) {

# --- HUNK 4: Lines 385-424 ---
   385|                                 uri = uri.substring( 0, uri.length() - 1 );
   386|                                 buf = c + buf;
   387|                             }
   388|                             m_currentElement.addContent( prefix );
   389|                             makeDirectURILink( uri );
   390|                         } else {
   391|                             m_currentElement.addContent( prefix );
   392|                             makeCamelCaseLink( camelCase );
   393|                         }
   394|                     }
   395|                     m_currentElement.addContent( buf );
   396|                 } else {
   397|                     m_currentElement.addContent( buf );
   398|                 }
   399|             } catch( final IllegalDataException e ) {
   400|                 m_currentElement.addContent( makeError(cleanupSuspectData( e.getMessage() )) );
   401|             }
   402|         }
   403|         return numChars;
   404|     }
   405|     private Element pushElement( final Element e ) {
   406|         flushPlainText();
   407|         m_currentElement.addContent( e );
   408|         m_currentElement = e;
   409|         return e;
   410|     }
   411|     private Element addElement( final Content e ) {
   412|         if( e != null ) {
   413|             flushPlainText();
   414|             m_currentElement.addContent( e );
   415|         }
   416|         return m_currentElement;
   417|     }
   418|     /**
   419|      *  All elements that can be empty by the HTML DTD.
   420|      */
   421|     private static final String[] EMPTY_ELEMENTS = {
   422|         "area", "base", "br", "col", "hr", "img", "input", "link", "meta", "p", "param"
   423|     };
   424|     /**

# --- HUNK 5: Lines 755-795 ---
   755|                 }
   756|             } else if( link.isInterwikiLink() ) {
   757|                 final String extWiki = link.getExternalWiki();
   758|                 final String wikiPage = link.getExternalWikiPage();
   759|                 if( m_wysiwygEditorMode ) {
   760|                     makeLink( INTERWIKI, extWiki + ":" + wikiPage, linktext, null, link.getAttributes() );
   761|                 } else {
   762|                     String urlReference = m_engine.getInterWikiURL( extWiki );
   763|                     if( urlReference != null ) {
   764|                         urlReference = TextUtil.replaceString( urlReference, "%s", wikiPage );
   765|                         urlReference = callMutatorChain( m_externalLinkMutatorChain, urlReference );
   766|                         if( m_linkParsingOperations.isImageLink( urlReference, isImageInlining(), getInlineImagePatterns() ) ) {
   767|                             handleImageLink( urlReference, linktext, link.hasReference() );
   768|                         } else {
   769|                             makeLink( INTERWIKI, urlReference, linktext, null, link.getAttributes() );
   770|                         }
   771|                         if( m_linkParsingOperations.isExternalLink( urlReference ) ) {
   772|                             addElement( outlinkImage() );
   773|                         }
   774|                     } else {
   775|                         final Object[] args = { TextUtil.escapeHTMLEntities( extWiki ) };
   776|                         addElement( makeError( MessageFormat.format( rb.getString( "markupparser.error.nointerwikiref" ), args ) ) );
   777|                     }
   778|                 }
   779|             } else if( linkref.startsWith( "#" ) ) {
   780|                 makeLink( LOCAL, linkref, linktext, null, link.getAttributes() );
   781|             } else if( TextUtil.isNumber( linkref ) ) {
   782|                 makeLink( LOCALREF, linkref, linktext, null, link.getAttributes() );
   783|             } else {
   784|                 final int hashMark;
   785|                 String attachment = m_engine.getManager( AttachmentManager.class ).getAttachmentInfoName( m_context, linkref );
   786|                 if( attachment != null ) {
   787|                     callMutatorChain( m_attachmentLinkMutatorChain, attachment );
   788|                     if( m_linkParsingOperations.isImageLink( linkref, isImageInlining(), getInlineImagePatterns() ) ) {
   789|                         attachment = m_context.getURL( ContextEnum.PAGE_ATTACH.getRequestContext(), attachment );
   790|                         sb.append( handleImageLink( attachment, linktext, link.hasReference() ) );
   791|                     } else {
   792|                         makeLink( ATTACHMENT, attachment, linktext, null, link.getAttributes() );
   793|                     }
   794|                 } else if( ( hashMark = linkref.indexOf( '#' ) ) != -1 ) {
   795|                     final String namedSection = linkref.substring( hashMark + 1 );


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/plugin/Image.java
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 6-95 ---
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.plugin;
    18| import org.apache.wiki.api.core.Attachment;
    19| import org.apache.wiki.api.core.Context;
    20| import org.apache.wiki.api.core.ContextEnum;
    21| import org.apache.wiki.api.core.Engine;
    22| import org.apache.wiki.api.exceptions.PluginException;
    23| import org.apache.wiki.api.exceptions.ProviderException;
    24| import org.apache.wiki.api.plugin.Plugin;
    25| import org.apache.wiki.attachment.AttachmentManager;
    26| import org.apache.wiki.parser.MarkupParser;
    27| import org.apache.wiki.util.TextUtil;
    28| import java.util.Map;
    29| /**
    30|  *  Provides an image plugin for better control than is possible with a simple image inclusion.
    31|  *  <br> Most parameters are equivalents of the html image attributes.
    32|  *
    33|  *  <p>Parameters : </p>
    34|  *  <ul>
    35|  *  <li><b>src</b> - the source (a URL) of the image (required parameter)</li>
    36|  *  <li><b>align</b> - the alignment of the image</li>
    37|  *  <li><b>height</b> - the height of the image</li>
    38|  *  <li><b>width</b> - the width of the image</li>
    39|  *  <li><b>alt</b> - alternate text</li>
    40|  *  <li><b>caption</b> - the caption for the image</li>
    41|  *  <li><b>link</b> - the hyperlink for the image</li>
    42|  *  <li><b>target</b> - the target (frame) to be used for opening the image</li>
    43|  *  <li><b>style</b> - the style attribute of the image</li>
    44|  *  <li><b>class</b> - the associated class for the image</li>
    45|  *  <li><b>border</b> - the border for the image</li>
    46|  *  <li><b>title</b> - the title for the image, can be presented as a tooltip to the user</li>
    47|  *  </ul>
    48|  *
    49|  *  @since 2.1.4.
    50|  */
    51| public class Image implements Plugin {
    52|     /** The parameter name for setting the src.  Value is <tt>{@value}</tt>. */
    53|     public static final String PARAM_SRC      = "src";
    54|     /** The parameter name for setting the align parameter.  Value is <tt>{@value}</tt>. */
    55|     public static final String PARAM_ALIGN    = "align";
    56|     /** The parameter name for setting the height.  Value is <tt>{@value}</tt>. */
    57|     public static final String PARAM_HEIGHT   = "height";
    58|     /** The parameter name for setting the width.  Value is <tt>{@value}</tt>. */
    59|     public static final String PARAM_WIDTH    = "width";
    60|     /** The parameter name for setting the alt.  Value is <tt>{@value}</tt>. */
    61|     public static final String PARAM_ALT      = "alt";
    62|     /** The parameter name for setting the caption.  Value is <tt>{@value}</tt>. */
    63|     public static final String PARAM_CAPTION  = "caption";
    64|     /** The parameter name for setting the link.  Value is <tt>{@value}</tt>. */
    65|     public static final String PARAM_LINK     = "link";
    66|     /** The parameter name for setting the target.  Value is <tt>{@value}</tt>. */
    67|     public static final String PARAM_TARGET   = "target";
    68|     /** The parameter name for setting the style.  Value is <tt>{@value}</tt>. */
    69|     public static final String PARAM_STYLE    = "style";
    70|     /** The parameter name for setting the class.  Value is <tt>{@value}</tt>. */
    71|     public static final String PARAM_CLASS    = "class";
    72|     /** The parameter name for setting the border.  Value is <tt>{@value}</tt>. */
    73|     public static final String PARAM_BORDER   = "border";
    74|     /** The parameter name for setting the title.  Value is <tt>{@value}</tt>. */
    75|     public static final String PARAM_TITLE    = "title";
    76|     /**
    77|      *  This method is used to clean away things like quotation marks which
    78|      *  a malicious user could use to stop processing and insert javascript.
    79|      */
    80|     private static String getCleanParameter( final Map< String, String > params, final String paramId ) {
    81|         return TextUtil.replaceEntities( params.get( paramId ) );
    82|     }
    83|     /**
    84|      *  {@inheritDoc}
    85|      */
    86|     @Override
    87|     public String execute( final Context context, final Map<String, String> params ) throws PluginException {
    88|         final Engine engine  = context.getEngine();
    89|         String src           = getCleanParameter( params, PARAM_SRC );
    90|         final String align   = getCleanParameter( params, PARAM_ALIGN );
    91|         final String ht      = getCleanParameter( params, PARAM_HEIGHT );
    92|         final String wt      = getCleanParameter( params, PARAM_WIDTH );
    93|         final String alt     = getCleanParameter( params, PARAM_ALT );
    94|         final String caption = getCleanParameter( params, PARAM_CAPTION );
    95|         final String link    = getCleanParameter( params, PARAM_LINK );

# --- HUNK 2: Lines 118-189 ---
   118|         if( title != null ) {
   119|             result.append( " title=\"" ).append( title ).append( "\"" );
   120|         }
   121|         if( align != null ) {
   122|             if( align.equals( "center" ) ) {
   123|                 result.append( " style=\"margin-left: auto; margin-right: auto; text-align:center; vertical-align:middle;\"" );
   124|             } else {
   125|                 result.append( " style=\"float:" ).append( align ).append( ";\"" );
   126|             }
   127|         }
   128|         result.append( ">\n" );
   129|         if( caption != null ) {
   130|             result.append( "<caption>" ).append( caption ).append( "</caption>\n" );
   131|         }
   132|         result.append( "<tr><td" );
   133|         if( cssclass != null ) {
   134|             result.append( " class=\"" ).append( cssclass ).append( "\"" );
   135|         }
   136|         if( style != null ) {
   137|             result.append( " style=\"" ).append( style );
   138|             if( result.charAt( result.length()-1 ) != ';' ) {
   139|                 result.append( ";" );
   140|             }
   141|             result.append("\"");
   142|         }
   143|         result.append( ">" );
   144|         if( link != null ) {
   145|             result.append( "<a href=\"" ).append( link ).append( "\"" );
   146|             if( target != null ) {
   147|                 result.append( " target=\"" ).append( target ).append( "\"" );
   148|             }
   149|             result.append(">");
   150|         }
   151|         if( !context.getBooleanWikiProperty( MarkupParser.PROP_ALLOWHTML, false ) ) {
   152|             if( src.startsWith( "data:" ) || src.startsWith( "javascript:" ) ) {
   153|                 src = "http://invalid_url" + src;
   154|             }
   155|         }
   156|         result.append( "<img src=\"" ).append( src ).append( "\"" );
   157|         if( ht != null ) {
   158|             result.append( " height=\"" ).append( ht ).append( "\"" );
   159|         }
   160|         if( wt != null ) {
   161|             result.append( " width=\"" ).append( wt ).append( "\"" );
   162|         }
   163|         if( alt != null ) {
   164|             result.append( " alt=\"" ).append( alt ).append( "\"" );
   165|         }
   166|         if( border != null ) {
   167|             result.append( " border=\"" ).append( border ).append( "\"" );
   168|         }
   169|         result.append(" />");
   170|         if( link != null ) {
   171|             result.append("</a>");
   172|         }
   173|         result.append("</td></tr>\n");
   174|         result.append("</table>\n");
   175|         return result.toString();
   176|     }
   177|     private boolean validTargetValue( final String s ) {
   178|         if( s.equals("_blank")
   179|             || s.equals("_self")
   180|             || s.equals("_parent")
   181|             || s.equals("_top") ) {
   182|             return true;
   183|         } else if( !s.isEmpty() ) { // check [a-zA-z]
   184|             final char c = s.charAt(0);
   185|             return Character.isLowerCase(c) || Character.isUpperCase(c);
   186|         }
   187|         return false;
   188|     }
   189| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/plugin/SampleAjaxPlugin.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 10-63 ---
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.plugin;
    18| import org.apache.wiki.ajax.WikiAjaxServlet;
    19| import org.apache.wiki.api.core.Context;
    20| import org.apache.wiki.api.exceptions.PluginException;
    21| import org.apache.wiki.api.plugin.Plugin;
    22| import javax.servlet.ServletException;
    23| import javax.servlet.http.HttpServletRequest;
    24| import javax.servlet.http.HttpServletResponse;
    25| import java.io.IOException;
    26| import java.util.List;
    27| import java.util.Map;
    28| /**
    29|  * @since 2.10.2-svn10
    30|  *
    31|  * updated according to https://issues.apache.org/jira/browse/JSPWIKI-1195
    32|  */
    33| public class SampleAjaxPlugin implements Plugin, WikiAjaxServlet {
    34| 	private static final String SERVLET_MAPPING = "SampleAjaxPlugin";
    35| 	@Override
    36| 	public String execute( final Context context, final Map<String, String> params) throws PluginException {
    37|     		var id = Long.toString(System.currentTimeMillis());
    38| 		var url = "/" + SERVLET_MAPPING + "/ajaxAction";
    39| 		var ajaxParams = params.get("params");
    40| 		var js = String.format("$('result%s').value='Loading';"+
    41| 			"var token = Wiki.CsrfProtection;"+
    42| 			"new Request.HTML({"+
    43| 				"url: Wiki.JsonUrl + '%s', "+
    44| 				"update:$('result%s'),"+
    45| 				"onSuccess: function(data){console.log('Success',data);},"+
    46| 				"onError: function(err){console.log('Error',err);}"+
    47| 			"}).post('params=%s&X-XSRF-TOKEN='+token)", id, url, id, ajaxParams);
    48| 		return String.format("<div onclick='%s' style='color: blue; cursor: pointer'>Press Me</div><div id='result%s'></div>", js, id);
    49| 	}
    50| 	@Override
    51| 	public String getServletMapping() {
    52| 		return SERVLET_MAPPING;
    53| 	}
    54| 	@Override
    55| 	public void service( final HttpServletRequest request, final HttpServletResponse response, final String actionName, final List< String > params )
    56| 			throws ServletException, IOException {
    57| 		try {
    58| 			Thread.sleep( 5000 ); // Wait 5 seconds
    59| 		} catch( final Exception e ) {
    60| 		}
    61| 		response.getWriter().print( "You called! actionName=" + actionName + " params=" + params );
    62| 	}
    63| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/providers/AbstractFileProvider.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 31-71 ---
    31| import org.apache.wiki.search.SearchResultComparator;
    32| import org.apache.wiki.util.FileUtil;
    33| import org.apache.wiki.util.TextUtil;
    34| import java.io.File;
    35| import java.io.FileNotFoundException;
    36| import java.io.FilenameFilter;
    37| import java.io.IOException;
    38| import java.io.InputStream;
    39| import java.io.OutputStreamWriter;
    40| import java.io.PrintWriter;
    41| import java.nio.charset.StandardCharsets;
    42| import java.nio.file.Files;
    43| import java.util.ArrayList;
    44| import java.util.Collection;
    45| import java.util.Date;
    46| import java.util.Enumeration;
    47| import java.util.List;
    48| import java.util.Map;
    49| import java.util.Properties;
    50| import java.util.TreeSet;
    51| import org.apache.commons.lang3.SystemUtils;
    52| /**
    53|  *  Provides a simple directory based repository for Wiki pages.
    54|  *  <P>
    55|  *  All files have ".txt" appended to make life easier for those who insist on using Windows or other software which makes assumptions
    56|  *  on the files contents based on its name.
    57|  *  <p>
    58|  *  This class functions as a superclass to all file based providers.
    59|  *
    60|  *  @since 2.1.21.
    61|  */
    62| public abstract class AbstractFileProvider implements PageProvider {
    63|     private static final Logger LOG = LogManager.getLogger(AbstractFileProvider.class);
    64|     private String m_pageDirectory = "/tmp/";
    65|     protected String m_encoding;
    66|     protected Engine m_engine;
    67|     public static final String PROP_CUSTOMPROP_MAXLIMIT = "custom.pageproperty.max.allowed";
    68|     public static final String PROP_CUSTOMPROP_MAXKEYLENGTH = "custom.pageproperty.key.length";
    69|     public static final String PROP_CUSTOMPROP_MAXVALUELENGTH = "custom.pageproperty.value.length";
    70|     public static final int DEFAULT_MAX_PROPLIMIT = 200;
    71|     public static final int DEFAULT_MAX_PROPKEYLENGTH = 255;

# --- HUNK 2: Lines 98-138 ---
    98|     @Override
    99|     public void initialize( final Engine engine, final Properties properties ) throws NoRequiredPropertyException, IOException, FileNotFoundException {
   100|         LOG.debug( "Initing FileSystemProvider" );
   101|         m_pageDirectory = TextUtil.getCanonicalFilePathProperty( properties, PROP_PAGEDIR,
   102|                                                           System.getProperty( "user.home" ) + File.separator + "jspwiki-files" );
   103|         final File f = new File( m_pageDirectory );
   104|         if( !f.exists() ) {
   105|             if( !f.mkdirs() ) {
   106|                 throw new IOException( "Failed to create page directory " + f.getAbsolutePath() + " , please check property " + PROP_PAGEDIR );
   107|             }
   108|         } else {
   109|             if( !f.isDirectory() ) {
   110|                 throw new IOException( "Page directory is not a directory: " + f.getAbsolutePath() );
   111|             }
   112|             if( !f.canWrite() ) {
   113|                 throw new IOException( "Page directory is not writable: " + f.getAbsolutePath() );
   114|             }
   115|         }
   116|         m_engine = engine;
   117|         m_encoding = properties.getProperty( Engine.PROP_ENCODING, DEFAULT_ENCODING );
   118|         m_windowsHackNeeded = SystemUtils.IS_OS_WINDOWS;
   119|         MAX_PROPLIMIT = TextUtil.getIntegerProperty( properties, PROP_CUSTOMPROP_MAXLIMIT, DEFAULT_MAX_PROPLIMIT );
   120|         MAX_PROPKEYLENGTH = TextUtil.getIntegerProperty( properties, PROP_CUSTOMPROP_MAXKEYLENGTH, DEFAULT_MAX_PROPKEYLENGTH );
   121|         MAX_PROPVALUELENGTH = TextUtil.getIntegerProperty( properties, PROP_CUSTOMPROP_MAXVALUELENGTH, DEFAULT_MAX_PROPVALUELENGTH );
   122|         LOG.info( "Wikipages are read from '" + m_pageDirectory + "'" );
   123|     }
   124|     String getPageDirectory()
   125|     {
   126|         return m_pageDirectory;
   127|     }
   128|     private static final String[] WINDOWS_DEVICE_NAMES = {
   129|         "con", "prn", "nul", "aux", "lpt1", "lpt2", "lpt3", "lpt4", "lpt5", "lpt6", "lpt7", "lpt8", "lpt9",
   130|         "com1", "com2", "com3", "com4", "com5", "com6", "com7", "com8", "com9"
   131|     };
   132|     /**
   133|      *  This makes sure that the queried page name is still readable by the file system.  For example, all XML entities
   134|      *  and slashes are encoded with the percent notation.
   135|      *
   136|      *  @param pagename The name to mangle
   137|      *  @return The mangled name.
   138|      */


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/providers/BasicAttachmentProvider.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 300-368 ---
   300|     @Override
   301|     public List< Attachment > listAttachments( final Page page ) throws ProviderException {
   302|         final List< Attachment > result = new ArrayList<>();
   303|         final File dir = findPageDir( page.getName() );
   304|         final String[] attachments = dir.list();
   305|         if( attachments != null ) {
   306|             for( final String attachment : attachments ) {
   307|                 final File f = new File( dir, attachment );
   308|                 if( f.isDirectory() ) {
   309|                     String attachmentName = unmangleName( attachment );
   310|                     if( attachmentName.endsWith( ATTDIR_EXTENSION ) ) {
   311|                         attachmentName = attachmentName.substring( 0, attachmentName.length() - ATTDIR_EXTENSION.length() );
   312|                     } else {
   313|                         final File propFile = new File( f, PROPERTY_FILE );
   314|                         if( !propFile.exists() ) {
   315|                             continue;
   316|                         }
   317|                     }
   318|                     final Attachment att = getAttachmentInfo( page, attachmentName, WikiProvider.LATEST_VERSION );
   319|                     if( att == null ) {
   320|                         LOG.error( "Attachment disappeared while reading information:"
   321|                                 + " if you did not touch the repository, there is a serious bug somewhere or perhaps it"
   322|                                 + " was deleted by antivirus software, etc. " + "Attachment = " + attachment
   323|                                 + ", decoded = " + attachmentName );
   324|                     } else {
   325|                         result.add( att );
   326|                     }
   327|                 }
   328|             }
   329|         }
   330|         return result;
   331|     }
   332|     /**
   333|      *  {@inheritDoc}
   334|      */
   335|     @Override
   336|     public Collection< Attachment > findAttachments( final QueryItem[] query ) {
   337|         return new ArrayList<>();
   338|     }
   339|     /**
   340|      *  {@inheritDoc}
   341|      */
   342|     @Override
   343|     public List< Attachment > listAllChanged( final Date timestamp ) throws ProviderException {
   344|         final File attDir = new File( m_storageDir );
   345|         if( !attDir.exists() ) {
   346|             if (!attDir.mkdirs()) {
   347|                 throw new ProviderException( "Specified attachment directory " + m_storageDir + " does not exist!" );
   348|             }
   349|         }
   350|         final ArrayList< Attachment > list = new ArrayList<>();
   351|         final String[] pagesWithAttachments = attDir.list( new AttachmentFilter() );
   352|         if( pagesWithAttachments != null ) {
   353|             for( final String pagesWithAttachment : pagesWithAttachments ) {
   354|                 String pageId = unmangleName( pagesWithAttachment );
   355|                 pageId = pageId.substring( 0, pageId.length() - DIR_EXTENSION.length() );
   356|                 final Collection< Attachment > c = listAttachments( Wiki.contents().page( m_engine, pageId ) );
   357|                 for( final Attachment att : c ) {
   358|                     if( att.getLastModified().after( timestamp ) ) {
   359|                         list.add( att );
   360|                     }
   361|                 }
   362|             }
   363|         }
   364|         list.sort( new PageTimeComparator() );
   365|         return list;
   366|     }
   367|     /**
   368|      *  {@inheritDoc}


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/providers/CachingAttachmentProvider.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 23-84 ---
    23| import org.apache.wiki.api.exceptions.NoRequiredPropertyException;
    24| import org.apache.wiki.api.exceptions.ProviderException;
    25| import org.apache.wiki.api.providers.AttachmentProvider;
    26| import org.apache.wiki.api.providers.PageProvider;
    27| import org.apache.wiki.api.providers.WikiProvider;
    28| import org.apache.wiki.api.search.QueryItem;
    29| import org.apache.wiki.attachment.AttachmentManager;
    30| import org.apache.wiki.cache.CacheInfo;
    31| import org.apache.wiki.cache.CachingManager;
    32| import org.apache.wiki.util.ClassUtil;
    33| import org.apache.wiki.util.TextUtil;
    34| import java.io.IOException;
    35| import java.io.InputStream;
    36| import java.util.ArrayList;
    37| import java.util.Collection;
    38| import java.util.Collections;
    39| import java.util.Date;
    40| import java.util.List;
    41| import java.util.NoSuchElementException;
    42| import java.util.Properties;
    43| import java.util.concurrent.atomic.AtomicBoolean;
    44| import java.util.concurrent.atomic.AtomicLong;
    45| /**
    46|  * Provides a caching attachment provider.  This class rests on top of a real provider class and provides a cache to speed things up.
    47|  * Only the Attachment objects are cached; the actual attachment contents are fetched always from the provider.
    48|  *
    49|  *  @since 2.1.64.
    50|  */
    51| public class CachingAttachmentProvider implements AttachmentProvider {
    52|     private static final Logger LOG = LogManager.getLogger( CachingAttachmentProvider.class );
    53|     private AttachmentProvider provider;
    54|     private CachingManager cachingManager;
    55|     private final AtomicBoolean allRequested = new AtomicBoolean();
    56|     private final AtomicLong attachments = new AtomicLong( 0L );
    57|     /**
    58|      * {@inheritDoc}
    59|      */
    60|     @Override
    61|     public void initialize( final Engine engine, final Properties properties ) throws NoRequiredPropertyException, IOException {
    62|         LOG.info( "Initing CachingAttachmentProvider" );
    63|         cachingManager = engine.getManager( CachingManager.class );
    64|         cachingManager.registerListener( CachingManager.CACHE_ATTACHMENTS, "expired", allRequested );
    65|         final String classname;
    66|         try {
    67|             classname = TextUtil.getRequiredProperty( properties, AttachmentManager.PROP_PROVIDER, AttachmentManager.PROP_PROVIDER_DEPRECATED );
    68|         } catch( final NoSuchElementException e ) {
    69|             throw new NoRequiredPropertyException( e.getMessage(), AttachmentManager.PROP_PROVIDER );
    70|         }
    71|         try {
    72|             provider = ClassUtil.buildInstance( "org.apache.wiki.providers", classname );
    73|             LOG.debug( "Initializing real provider class {}", provider );
    74|             provider.initialize( engine, properties );
    75|         } catch( final ReflectiveOperationException e ) {
    76|             LOG.error( "Unable to instantiate provider class {}", classname, e );
    77|             throw new IllegalArgumentException( "illegal provider class", e );
    78|         }
    79|     }
    80|     /**
    81|      * {@inheritDoc}
    82|      */
    83|     @Override
    84|     public void putAttachmentData( final Attachment att, final InputStream data ) throws ProviderException, IOException {

# --- HUNK 2: Lines 104-151 ---
   104|         final List< Attachment > atts = cachingManager.get( CachingManager.CACHE_ATTACHMENTS_COLLECTION, page.getName(),
   105|                                                             () -> provider.listAttachments( page ) );
   106|         return cloneCollection( atts );
   107|     }
   108|     private < T > List< T > cloneCollection( final Collection< T > c ) {
   109|         return c != null ? new ArrayList<>( c ) : Collections.emptyList();
   110|     }
   111|     /**
   112|      * {@inheritDoc}
   113|      */
   114|     @Override
   115|     public Collection< Attachment > findAttachments( final QueryItem[] query ) {
   116|         return provider.findAttachments( query );
   117|     }
   118|     /**
   119|      * {@inheritDoc}
   120|      */
   121|     @Override
   122|     public List< Attachment > listAllChanged( final Date timestamp ) throws ProviderException {
   123|         final List< Attachment > all;
   124|         if ( !allRequested.get() ) {
   125|             all = provider.listAllChanged( timestamp );
   126|             synchronized( this ) {
   127|                 for( final Attachment att : all ) {
   128|                     cachingManager.put( CachingManager.CACHE_ATTACHMENTS, att.getName(), att );
   129|                 }
   130|                 if( timestamp.getTime() == 0L ) { // all attachments requested
   131|                     allRequested.set( true );
   132|                     attachments.set( all.size() );
   133|                 }
   134|             }
   135|         } else {
   136|             final List< String > keys = cachingManager.keys( CachingManager.CACHE_ATTACHMENTS );
   137|             all = new ArrayList<>();
   138|             for( final String key : keys) {
   139|                 final Attachment cachedAttachment = cachingManager.get( CachingManager.CACHE_ATTACHMENTS, key, () -> null );
   140|                 if( cachedAttachment != null ) {
   141|                     all.add( cachedAttachment );
   142|                 }
   143|             }
   144|         }
   145|         if( cachingManager.enabled( CachingManager.CACHE_ATTACHMENTS )
   146|                 && attachments.get() >= cachingManager.info( CachingManager.CACHE_ATTACHMENTS ).getMaxElementsAllowed() ) {
   147|             LOG.warn( "seems {} can't hold all attachments from your page repository, " +
   148|                     "so we're delegating on the underlying provider instead. Please consider increasing " +
   149|                     "your cache sizes on the ehcache configuration file to avoid this behaviour", CachingManager.CACHE_ATTACHMENTS );
   150|             return provider.listAllChanged( timestamp );
   151|         }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/providers/CachingProvider.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 23-92 ---
    23| import org.apache.wiki.api.exceptions.NoRequiredPropertyException;
    24| import org.apache.wiki.api.exceptions.ProviderException;
    25| import org.apache.wiki.api.providers.PageProvider;
    26| import org.apache.wiki.api.search.QueryItem;
    27| import org.apache.wiki.api.search.SearchResult;
    28| import org.apache.wiki.api.spi.Wiki;
    29| import org.apache.wiki.cache.CacheInfo;
    30| import org.apache.wiki.cache.CachingManager;
    31| import org.apache.wiki.pages.PageManager;
    32| import org.apache.wiki.parser.MarkupParser;
    33| import org.apache.wiki.render.RenderingManager;
    34| import org.apache.wiki.util.ClassUtil;
    35| import org.apache.wiki.util.TextUtil;
    36| import java.io.IOException;
    37| import java.util.Collection;
    38| import java.util.Date;
    39| import java.util.List;
    40| import java.util.NoSuchElementException;
    41| import java.util.Properties;
    42| import java.util.TreeSet;
    43| import java.util.concurrent.atomic.AtomicBoolean;
    44| import java.util.concurrent.atomic.AtomicLong;
    45| /**
    46|  *  Provides a caching page provider.  This class rests on top of a real provider class and provides a cache to speed things up.  Only
    47|  *  if the cache copy of the page text has expired, we fetch it from the provider.
    48|  *  <p>
    49|  *  This class does not detect if someone has modified the page externally, not through JSPWiki routines.
    50|  *  <p>
    51|  *  Heavily based on ideas by Chris Brooking.
    52|  *  <p>
    53|  *  Since 2.10 uses the Ehcache library.
    54|  *
    55|  *  @since 1.6.4
    56|  */
    57| public class CachingProvider implements PageProvider {
    58|     private static final Logger LOG = LogManager.getLogger( CachingProvider.class );
    59|     private CachingManager cachingManager;
    60|     private PageProvider provider;
    61|     private Engine engine;
    62|     private final AtomicBoolean allRequested = new AtomicBoolean();
    63|     private final AtomicLong pages = new AtomicLong( 0L );
    64|     /**
    65|      *  {@inheritDoc}
    66|      */
    67|     @Override
    68|     public void initialize( final Engine engine, final Properties properties ) throws NoRequiredPropertyException, IOException {
    69|         LOG.debug( "Initing CachingProvider" );
    70|         this.engine = engine;
    71|         cachingManager = this.engine.getManager( CachingManager.class );
    72|         cachingManager.registerListener( CachingManager.CACHE_PAGES, "expired", allRequested );
    73|         final String classname;
    74|         try {
    75|             classname = TextUtil.getRequiredProperty( properties, PageManager.PROP_PAGEPROVIDER );
    76|         } catch( final NoSuchElementException e ) {
    77|             throw new NoRequiredPropertyException( e.getMessage(), PageManager.PROP_PAGEPROVIDER );
    78|         }
    79|         try {
    80|             provider = ClassUtil.buildInstance( "org.apache.wiki.providers", classname );
    81|             LOG.debug( "Initializing real provider class {}", provider );
    82|             provider.initialize( engine, properties );
    83|         } catch( final ReflectiveOperationException e ) {
    84|             LOG.error( "Unable to instantiate provider class {}", classname, e );
    85|             throw new IllegalArgumentException( "illegal provider class", e );
    86|         }
    87|     }
    88|     private Page getPageInfoFromCache( final String name ) throws ProviderException {
    89|         if( name == null ) {
    90|             return null;
    91|         }
    92|         return cachingManager.get( CachingManager.CACHE_PAGES, name, () -> provider.getPageInfo( name, PageProvider.LATEST_VERSION ) );

# --- HUNK 2: Lines 179-225 ---
   179|      *  {@inheritDoc}
   180|      */
   181|     @Override
   182|     public void putPageText( final Page page, final String text ) throws ProviderException {
   183|         synchronized( this ) {
   184|             provider.putPageText( page, text );
   185|             page.setLastModified( new Date() );
   186|             cachingManager.remove( CachingManager.CACHE_PAGES, page.getName() );
   187|             cachingManager.remove( CachingManager.CACHE_PAGES_TEXT, page.getName() );
   188|             cachingManager.remove( CachingManager.CACHE_PAGES_HISTORY, page.getName() );
   189|             getPageInfoFromCache( page.getName() );
   190|         }
   191|         pages.incrementAndGet();
   192|     }
   193|     /**
   194|      *  {@inheritDoc}
   195|      */
   196|     @Override
   197|     public Collection< Page > getAllPages() throws ProviderException {
   198|         final Collection< Page > all;
   199|         if ( !allRequested.get() ) {
   200|             all = provider.getAllPages();
   201|             synchronized( this ) {
   202|                 for( final Page p : all ) {
   203|                     cachingManager.put( CachingManager.CACHE_PAGES,  p.getName(), p );
   204|                 }
   205|                 allRequested.set( true );
   206|             }
   207|             pages.set( all.size() );
   208|         } else {
   209|             final List< String > keys = cachingManager.keys( CachingManager.CACHE_PAGES );
   210|             all = new TreeSet<>();
   211|             for( final String key : keys ) {
   212|                 final Page cachedPage = cachingManager.get( CachingManager.CACHE_PAGES, key, () -> null );
   213|                 if( cachedPage != null ) {
   214|                     all.add( cachedPage );
   215|                 }
   216|             }
   217|         }
   218|         if( cachingManager.enabled( CachingManager.CACHE_PAGES )
   219|                 && pages.get() >= cachingManager.info( CachingManager.CACHE_PAGES ).getMaxElementsAllowed() ) {
   220|             LOG.warn( "seems {} can't hold all pages from your page repository, " +
   221|                     "so we're delegating on the underlying provider instead. Please consider increasing " +
   222|                     "your cache sizes on the ehcache configuration file to avoid this behaviour", CachingManager.CACHE_PAGES );
   223|             return provider.getAllPages();
   224|         }
   225|         return all;


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/tags/CalendarTag.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 17-74 ---
    17| package org.apache.wiki.tags;
    18| import org.apache.logging.log4j.LogManager;
    19| import org.apache.logging.log4j.Logger;
    20| import org.apache.wiki.api.core.ContextEnum;
    21| import org.apache.wiki.api.core.Engine;
    22| import org.apache.wiki.api.core.Page;
    23| import org.apache.wiki.pages.PageManager;
    24| import org.apache.wiki.util.HttpUtil;
    25| import org.apache.wiki.util.TextUtil;
    26| import javax.servlet.http.HttpServletRequest;
    27| import javax.servlet.jsp.JspWriter;
    28| import java.io.IOException;
    29| import java.text.ParseException;
    30| import java.text.SimpleDateFormat;
    31| import java.util.Calendar;
    32| import java.util.Date;
    33| /**
    34|  *  Provides a nice calendar.  Responds to the following HTTP parameters:
    35|  *  <ul>
    36|  *  <li>calendar.date - If this parameter exists, then the calendar
    37|  *  date is taken from the month and year.  The date must be in ddMMyy format.
    38|  *  <li>weblog.startDate - If calendar.date parameter does not exist,
    39|  *  we then check this date.
    40|  *  </ul>
    41|  *
    42|  *  If neither calendar.date nor weblog.startDate parameters exist,
    43|  *  then the calendar will default to the current month.
    44|  *
    45|  *  @since 2.0
    46|  */
    47| public class CalendarTag extends WikiTagBase {
    48|     private static final long serialVersionUID = 0L;
    49|     private static final Logger LOG = LogManager.getLogger( CalendarTag.class );
    50|     private static final int NUM_PAGES_TO_CHECK = 3;
    51|     private SimpleDateFormat m_pageFormat;
    52|     private SimpleDateFormat m_urlFormat;
    53|     private SimpleDateFormat m_monthUrlFormat;
    54|     private boolean m_addIndex;
    55|     private SimpleDateFormat m_dateFormat = new SimpleDateFormat( "ddMMyy" );
    56|     /**
    57|      *  {@inheritDoc}
    58|      */
    59|     @Override
    60|     public void initTag()
    61|     {
    62|         super.initTag();
    63|         m_pageFormat = m_urlFormat = m_monthUrlFormat = null;
    64|         m_dateFormat = new SimpleDateFormat( "ddMMyy" );
    65|     }
    66|     /*
    67|     public void setYear( String year )
    68|     {
    69|         m_year = year;
    70|     }
    71|     public void setMonth( String month )
    72|     {
    73|         m_month = month;
    74|     }

# --- HUNK 2: Lines 93-172 ---
    93|      *  links to pages according to this format.  The pageformat
    94|      *  takes precedence.
    95|      *  
    96|      *  @param format The URL format in the SimpleDateFormat fashion.
    97|      *  @see SimpleDateFormat
    98|      */
    99|     public void setUrlformat( final String format )
   100|     {
   101|         m_urlFormat = new SimpleDateFormat( format );
   102|     }
   103|     /**
   104|      *  Set the format to be used for links for the months.
   105|      *  
   106|      *  @param format The format to set in the SimpleDateFormat fashion.
   107|      *  
   108|      *  @see SimpleDateFormat
   109|      */
   110|     public void setMonthurlformat( final String format )
   111|     {
   112|         m_monthUrlFormat = new SimpleDateFormat( format );
   113|     }
   114|     /**
   115|      *  Sets whether or not the pageFormat contains a page index at the end.
   116| 	 *  This is the case for the WeblogPlugin.
   117|      *
   118|      *  @param addindex Whether a page index should be appended to the pageFormat
   119|      *
   120|      *  @see org.apache.wiki.plugin.WeblogPlugin
   121|      */
   122|     public void setAddindex( final boolean addIndex )
   123|     {
   124|         m_addIndex = addIndex;
   125|     }
   126|     private String format( final String txt ) {
   127|         final Page p = m_wikiContext.getPage();
   128|         if( p != null ) {
   129|             return TextUtil.replaceString( txt, "%p", p.getName() );
   130|         }
   131|         return txt;
   132|     }
   133|     /**
   134|      *  Returns a link to the given day.
   135|      */
   136|     private String getDayLink( final Calendar day ) {
   137|         final Engine engine = m_wikiContext.getEngine();
   138|         final String result;
   139|         if( m_pageFormat != null ) {
   140|             final String pagename = m_pageFormat.format( day.getTime() );
   141|             var somePageExistsOnThisDay = false;
   142|             if (m_addIndex) {
   143| 		    for (int pageIdx = 1; pageIdx <= NUM_PAGES_TO_CHECK; pageIdx++) {
   144|                         if( engine.getManager( PageManager.class ).wikiPageExists( pagename+pageIdx ) ) {
   145|                             somePageExistsOnThisDay = true;
   146|                             break;
   147|                         }
   148|                 }
   149|             } else {
   150|                 somePageExistsOnThisDay = engine.getManager( PageManager.class ).wikiPageExists( pagename );
   151|             }
   152|             if( somePageExistsOnThisDay ) {
   153|                 if( m_urlFormat != null ) {
   154|                     final String url = m_urlFormat.format( day.getTime() );
   155|                     result = "<td class=\"link\"><a href=\""+url+"\">"+day.get( Calendar.DATE )+"</a></td>";
   156|                 } else {
   157|                     result = "<td class=\"link\"><a href=\""+m_wikiContext.getViewURL( pagename )+"\">"+
   158|                              day.get( Calendar.DATE )+"</a></td>";
   159|                 }
   160|             } else {
   161|                 result = "<td class=\"days\">"+day.get(Calendar.DATE)+"</td>";
   162|             }
   163|         } else if( m_urlFormat != null ) {
   164|             final String url = m_urlFormat.format( day.getTime() );
   165|             result = "<td><a href=\""+url+"\">"+day.get( Calendar.DATE )+"</a></td>";
   166|         } else {
   167|             result = "<td class=\"days\">"+day.get(Calendar.DATE)+"</td>";
   168|         }
   169|         return format( result );
   170|     }
   171|     private String getMonthLink( final Calendar day ) {
   172|         final SimpleDateFormat monthfmt = new SimpleDateFormat( "MMMM yyyy" );


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/ui/admin/DefaultAdminBeanManager.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 33-81 ---
    33| import javax.management.DynamicMBean;
    34| import javax.management.InstanceAlreadyExistsException;
    35| import javax.management.InstanceNotFoundException;
    36| import javax.management.MBeanRegistrationException;
    37| import javax.management.MBeanServer;
    38| import javax.management.MalformedObjectNameException;
    39| import javax.management.NotCompliantMBeanException;
    40| import javax.management.ObjectName;
    41| import java.lang.management.ManagementFactory;
    42| import java.util.ArrayList;
    43| import java.util.Collection;
    44| import java.util.List;
    45| /**
    46|  *  Provides a manager class for all AdminBeans within JSPWiki.  This class also manages registration for any
    47|  *  AdminBean which is also a JMX bean.
    48|  *
    49|  *  @since  2.5.52
    50|  */
    51| public class DefaultAdminBeanManager implements WikiEventListener, AdminBeanManager {
    52|     private final Engine m_engine;
    53|     private final String applicationName;
    54|     private ArrayList< AdminBean > m_allBeans;
    55|     private final MBeanServer m_mbeanServer;
    56|     private static final Logger LOG = LogManager.getLogger( DefaultAdminBeanManager.class );
    57|     public DefaultAdminBeanManager( final Engine engine ) {
    58|         LOG.info("Using JDK 1.5 Platform MBeanServer");
    59|         m_mbeanServer = MBeanServerFactory15.getServer();
    60|         m_engine = engine;
    61|         applicationName = m_engine.getWikiProperties().getProperty("jspwiki.applicationName").trim();
    62|         if( m_mbeanServer != null ) {
    63|             LOG.info( m_mbeanServer.getClass().getName() );
    64|             LOG.info( m_mbeanServer.getDefaultDomain() );
    65|         }
    66|         m_engine.addWikiEventListener( this );
    67|         initialize();
    68|     }
    69|     /** {@inheritDoc} */
    70|     @Override
    71| 	public void initialize() {
    72|         reload();
    73|     }
    74|     private String getJMXTitleString( final int title ) {
    75|         switch( title ) {
    76|             case AdminBean.CORE:
    77|                 return "Core";
    78|             case AdminBean.EDITOR:
    79|                 return "Editors";
    80|             case AdminBean.UNKNOWN:
    81|             default:

# --- HUNK 2: Lines 95-135 ---
    95|                     m_mbeanServer.registerMBean( ab, name );
    96|                 }
    97|             }
    98|             m_allBeans.add( ab );
    99|             LOG.info( "Registered new admin bean " + ab.getTitle() );
   100|         } catch( final InstanceAlreadyExistsException e ) {
   101|             LOG.error( "Admin bean already registered to JMX", e );
   102|         } catch( final MBeanRegistrationException e ) {
   103|             LOG.error( "Admin bean cannot be registered to JMX", e );
   104|         } catch( final NotCompliantMBeanException e ) {
   105|             LOG.error( "Your admin bean is not very good", e );
   106|         } catch( final MalformedObjectNameException e ) {
   107|             LOG.error( "Your admin bean name is not very good", e );
   108|         } catch( final NullPointerException e ) {
   109|             LOG.error( "Evil NPE occurred", e );
   110|         }
   111|     }
   112|     private ObjectName getObjectName( final AdminBean ab ) throws MalformedObjectNameException {
   113|         final String component = getJMXTitleString( ab.getType() );
   114|         final String title     = ab.getTitle();
   115|         return new ObjectName(String.format("%s:component=%s,name=%s (%s)", Release.APPNAME, component, title, applicationName));
   116|     }
   117|     /**
   118|      *  Registers all the beans from a collection of WikiModuleInfos.  If some of the beans fail, logs the message and keeps going to the
   119|      *  next bean.
   120|      *
   121|      *  @param c Collection of WikiModuleInfo instances
   122|      */
   123|     private void registerBeans( final Collection< WikiModuleInfo > c ) {
   124|         for( final WikiModuleInfo wikiModuleInfo : c ) {
   125|             final String abname = wikiModuleInfo.getAdminBeanClass();
   126|             try {
   127|                 if( abname != null && !abname.isEmpty() ) {
   128|                     final AdminBean ab = ClassUtil.buildInstance( abname );
   129|                     registerAdminBean( ab );
   130|                 }
   131|             } catch( final ReflectiveOperationException e ) {
   132|                 LOG.error( e.getMessage(), e );
   133|             }
   134|         }
   135|     }


# ====================================================================
# FILE: jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/ImageLinkNodePostProcessorState.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-56 ---
     1| /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.markdown.extensions.jspwikilinks.postprocessor;
    18| import com.vladsch.flexmark.util.ast.Node;
    19| import com.vladsch.flexmark.util.ast.NodeTracker;
    20| import com.vladsch.flexmark.util.sequence.CharSubSequence;
    21| import org.apache.wiki.api.core.Context;
    22| import org.apache.wiki.markdown.nodes.JSPWikiLink;
    23| import org.apache.wiki.parser.LinkParsingOperations;
    24| /**
    25|  * {@link NodePostProcessorState} which further post processes image links.
    26|  */
    27| public class ImageLinkNodePostProcessorState implements NodePostProcessorState< JSPWikiLink > {
    28|     private final boolean isLinkFromText;
    29|     private final String urlRef;
    30|     private final LinkParsingOperations linkOperations;
    31|     public ImageLinkNodePostProcessorState( final Context wikiContext, final String urlRef, final boolean isLinkFromText ) {
    32|         this.isLinkFromText = isLinkFromText;
    33|         this.urlRef = urlRef;
    34|         this.linkOperations = new LinkParsingOperations( wikiContext );
    35|     }
    36|     /**
    37|      * {@inheritDoc}
    38|      *
    39|      * @see NodePostProcessorState#process(NodeTracker, Node)
    40|      */
    41|     @Override
    42|     public void process( final NodeTracker state, final JSPWikiLink link ) {
    43|         final WikiHtmlInline img = WikiHtmlInline.of( "<img class=\"inline\" " +
    44|                                                                "src=\"" + urlRef + "\" " +
    45|                                                                "alt=\"" + link.getText().toString() + "\" />" );
    46|         if( ( isLinkFromText && linkOperations.isExternalLink( link.getText().toString() ) ) ||
    47|                 ( isLinkFromText && linkOperations.linkExists( link.getText().toString() ) ) ) {
    48|             link.setUrl( CharSubSequence.of( urlRef ) );
    49|             link.removeChildren();
    50|             link.appendChild( img );
    51|             state.nodeAdded( img );
    52|         } else {
    53|             NodePostProcessorStateCommonOperations.addContent( state, link, img );
    54|         }
    55|     }
    56| }


# ====================================================================
# FILE: jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/LocalLinkNodePostProcessorState.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.markdown.extensions.jspwikilinks.postprocessor;
    18| import com.vladsch.flexmark.util.ast.Node;
    19| import com.vladsch.flexmark.util.ast.NodeTracker;
    20| import com.vladsch.flexmark.util.sequence.CharSubSequence;
    21| import org.apache.oro.text.regex.Pattern;
    22| import org.apache.wiki.api.core.Context;
    23| import org.apache.wiki.api.core.ContextEnum;
    24| import org.apache.wiki.attachment.AttachmentManager;
    25| import org.apache.wiki.markdown.nodes.JSPWikiLink;
    26| import org.apache.wiki.parser.LinkParsingOperations;
    27| import org.apache.wiki.parser.MarkupParser;
    28| import java.util.List;
    29| /**
    30|  * {@link NodePostProcessorState} which further post processes local links.
    31|  */
    32| public class LocalLinkNodePostProcessorState implements NodePostProcessorState< JSPWikiLink > {
    33|     private final Context wikiContext;
    34|     private final LinkParsingOperations linkOperations;
    35|     private final boolean isImageInlining;
    36|     private final List< Pattern > inlineImagePatterns;
    37|     public LocalLinkNodePostProcessorState( final Context wikiContext,

# --- HUNK 2: Lines 39-94 ---
    39|                                             final List< Pattern > inlineImagePatterns ) {
    40|         this.wikiContext = wikiContext;
    41|         this.linkOperations = new LinkParsingOperations( wikiContext );
    42|         this.isImageInlining = isImageInlining;
    43|         this.inlineImagePatterns = inlineImagePatterns;
    44|     }
    45|     /**
    46|      * {@inheritDoc}
    47|      *
    48|      * @see NodePostProcessorState#process(NodeTracker, Node) 
    49|      */
    50|     @Override
    51|     public void process( final NodeTracker state, final JSPWikiLink link ) {
    52|         final int hashMark = link.getUrl().toString().indexOf( '#' );
    53|         final String attachment = wikiContext.getEngine().getManager( AttachmentManager.class ).getAttachmentInfoName( wikiContext, link.getUrl().toString() );
    54|         if( attachment != null  ) {
    55|             if( !linkOperations.isImageLink( link.getUrl().toString(), isImageInlining, inlineImagePatterns ) ) {
    56|                 final String attlink = wikiContext.getURL( ContextEnum.PAGE_ATTACH.getRequestContext(), link.getUrl().toString() );
    57|                 link.setUrl( CharSubSequence.of( attlink ) );
    58|                 link.removeChildren();
    59|                 final WikiHtmlInline content = WikiHtmlInline.of( link.getText().toString(), wikiContext );
    60|                 link.appendChild( content );
    61|                 state.nodeAddedWithChildren( content );
    62|                 addAttachmentLink( state, link );
    63|             } else {
    64|                 new ImageLinkNodePostProcessorState( wikiContext, attachment, link.hasRef() ).process( state, link );
    65|             }
    66|         } else if( hashMark != -1 ) { // It's an internal Wiki link, but to a named section
    67|             final String namedSection = link.getUrl().toString().substring( hashMark + 1 );
    68|             link.setUrl( CharSubSequence.of( link.getUrl().toString().substring( 0, hashMark ) ) );
    69|             final String matchedLink = linkOperations.linkIfExists( link.getUrl().toString() );
    70|             if( matchedLink != null ) {
    71|                 String sectref = "#section-" + wikiContext.getEngine().encodeName( matchedLink + "-" + MarkupParser.wikifyLink( namedSection ) );
    72|                 sectref = sectref.replace( '%', '_' );
    73|                 link.setUrl( CharSubSequence.of( wikiContext.getURL( ContextEnum.PAGE_VIEW.getRequestContext(), link.getUrl().toString() + sectref ) ) );
    74|             } else {
    75|                 link.setUrl( CharSubSequence.of( wikiContext.getURL( ContextEnum.PAGE_EDIT.getRequestContext(), link.getUrl().toString() ) ) );
    76|             }
    77|         } else {
    78|             if( linkOperations.linkExists( link.getUrl().toString() ) ) {
    79|                 link.setUrl( CharSubSequence.of( wikiContext.getURL( ContextEnum.PAGE_VIEW.getRequestContext(), link.getUrl().toString() ) ) );
    80|             } else {
    81|                 link.setUrl( CharSubSequence.of( wikiContext.getURL( ContextEnum.PAGE_EDIT.getRequestContext(), link.getUrl().toString() ) ) );
    82|             }
    83|         }
    84|     }
    85|     void addAttachmentLink( final NodeTracker state, final JSPWikiLink link ) {
    86|         final String infolink = wikiContext.getURL( ContextEnum.PAGE_INFO.getRequestContext(), link.getWikiLink() );
    87|         final String imglink = wikiContext.getURL( ContextEnum.PAGE_NONE.getRequestContext(), "images/attachment_small.png" );
    88|         final WikiHtmlInline aimg = WikiHtmlInline.of( "<a href=\""+ infolink + "\" class=\"infolink\">" +
    89|                                                               "<img src=\""+ imglink + "\" border=\"0\" alt=\"(info)\" />" +
    90|                                                            "</a>" ) ;
    91|         link.insertAfter( aimg );
    92|         state.nodeAdded( aimg );
    93|     }
    94| }


# ====================================================================
# FILE: jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/NodePostProcessorStateCommonOperations.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-62 ---
     1| /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.markdown.extensions.jspwikilinks.postprocessor;
    18| import com.vladsch.flexmark.util.ast.Node;
    19| import com.vladsch.flexmark.util.ast.NodeTracker;
    20| import org.apache.wiki.api.core.Context;
    21| import org.apache.wiki.api.core.ContextEnum;
    22| import org.apache.wiki.markdown.nodes.JSPWikiLink;
    23| import org.apache.wiki.parser.MarkupParser;
    24| /**
    25|  * Internal class with common post-processor operations.
    26|  */
    27| class NodePostProcessorStateCommonOperations {
    28|     static void addContent( final NodeTracker state, final Node node, final Node content ) {
    29|         final Node previous = node.getPrevious() != null ? node.getPrevious() : node.getNext();
    30|         if( previous != null ) {
    31|             previous.insertAfter( content );
    32|             node.unlink();
    33|             state.nodeRemoved( node );
    34|             content.takeChildren( node );
    35|             state.nodeAddedWithChildren( content );
    36|         } else {
    37|             node.getParent().appendChild( content );
    38|         }
    39|     }
    40|     static void addOutlinkImage( final NodeTracker state, final Node node, final Context wikiContext, final boolean useOutlinkImage ) {
    41|         final Boolean wysiwygVariable = wikiContext.getVariable( Context.VAR_WYSIWYG_EDITOR_MODE );
    42|         final boolean wysiwygEditorMode = wysiwygVariable != null && wysiwygVariable;
    43|         if( useOutlinkImage && !wysiwygEditorMode ) {
    44|             final String m_outlinkImageURL = wikiContext.getURL( ContextEnum.PAGE_NONE.getRequestContext(), MarkupParser.OUTLINK_IMAGE );
    45|             final WikiHtmlInline img = WikiHtmlInline.of( "<img class=\""+ MarkupParser.OUTLINK + "\" " + "alt=\"\" src=\""+ m_outlinkImageURL + "\" />" ) ;
    46|             node.insertAfter( img );
    47|             state.nodeAdded( img );
    48|         }
    49|     }
    50|     static String inlineLinkTextOnWysiwyg( final NodeTracker state, final JSPWikiLink link, final boolean wysiwygEditorMode ) {
    51|         final String line = link.getUrl().toString();
    52|         if( wysiwygEditorMode ) {
    53|             final WikiHtmlInline content = WikiHtmlInline.of( "[" + line + "]()" );
    54|             addContent( state, link, content );
    55|         }
    56|         return line;
    57|     }
    58|     static void makeError( final NodeTracker state, final Node node, final String errMsg ) {
    59|         final WikiHtmlInline error = WikiHtmlInline.of( "<span class=\"error\">" + errMsg + "</span>" );
    60|         addContent( state, node, error );
    61|     }
    62| }


# ====================================================================
# FILE: jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/PluginLinkNodePostProcessorState.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.markdown.extensions.jspwikilinks.postprocessor;
    18| import com.vladsch.flexmark.ext.toc.TocBlock;
    19| import com.vladsch.flexmark.util.ast.Node;
    20| import com.vladsch.flexmark.util.ast.NodeTracker;
    21| import com.vladsch.flexmark.util.sequence.CharSubSequence;
    22| import org.apache.logging.log4j.LogManager;
    23| import org.apache.logging.log4j.Logger;
    24| import org.apache.wiki.api.core.Context;
    25| import org.apache.wiki.api.exceptions.PluginException;
    26| import org.apache.wiki.api.plugin.Plugin;
    27| import org.apache.wiki.markdown.nodes.JSPWikiLink;
    28| import org.apache.wiki.parser.PluginContent;
    29| import org.apache.wiki.preferences.Preferences;
    30| import java.text.MessageFormat;
    31| import java.util.ResourceBundle;
    32| /**
    33|  * {@link NodePostProcessorState} which further post processes plugin links.
    34|  */
    35| public class PluginLinkNodePostProcessorState implements NodePostProcessorState< JSPWikiLink > {
    36|     private static final Logger LOG = LogManager.getLogger( PluginLinkNodePostProcessorState.class );
    37|     private final Context wikiContext;

# --- HUNK 2: Lines 40-118 ---
    40|         this.wikiContext = wikiContext;
    41|         final Boolean wysiwygVariable = wikiContext.getVariable( Context.VAR_WYSIWYG_EDITOR_MODE );
    42|         m_wysiwygEditorMode = wysiwygVariable != null ? wysiwygVariable : false;
    43|     }
    44|     /**
    45|      * {@inheritDoc}
    46|      *
    47|      * @see NodePostProcessorState#process(NodeTracker, Node) 
    48|      */
    49|     @Override
    50|     public void process( final NodeTracker state, final JSPWikiLink link ) {
    51|         if( link.getText().toString().startsWith( "{TableOfContents" ) ) {
    52|             handleTableOfContentsPlugin( state, link );
    53|             return;
    54|         }
    55|         PluginContent pluginContent = null;
    56|         try {
    57|             pluginContent = PluginContent.parsePluginLine( wikiContext, link.getUrl().toString(), -1 ); // -1 == do not generate _bounds parameter
    58|             if( pluginContent != null ) {
    59|                 final String pluginInvocation = pluginInvocation( link.getText().toString(), pluginContent );
    60|                 final WikiHtmlInline content = WikiHtmlInline.of( pluginInvocation );
    61|                 pluginContent.executeParse( wikiContext );
    62|                 NodePostProcessorStateCommonOperations.addContent( state, link, content );
    63|             }
    64|         } catch( final PluginException e ) {
    65|             LOG.info( wikiContext.getRealPage().getWiki() + " : " + wikiContext.getRealPage().getName() + " - Failed to insert plugin: " + e.getMessage() );
    66|             if( !m_wysiwygEditorMode ) {
    67|                 final ResourceBundle rbPlugin = Preferences.getBundle( wikiContext, Plugin.CORE_PLUGINS_RESOURCEBUNDLE );
    68|                 NodePostProcessorStateCommonOperations.makeError( state, link, MessageFormat.format( rbPlugin.getString( "plugin.error.insertionfailed" ),
    69|                                                                                                                          wikiContext.getRealPage().getWiki(),
    70|                                                                                                                          wikiContext.getRealPage().getName(),
    71|                                                                                                                          e.getMessage() ) );
    72|             }
    73|         } finally {
    74|             if( pluginContent != null ) {
    75|                 removeLink( state, link );
    76|             }
    77|         }
    78|     }
    79|     /**
    80|      * Return plugin execution. As plugin execution may not fire the plugin (i.e., on WYSIWYG editors), on those cases, the plugin line is returned.
    81|      *
    82|      * @param pluginMarkup plugin markup line
    83|      * @param pluginContent the plugin content.
    84|      * @return plugin execution, or plugin markup line if it wasn't executed.
    85|      */
    86|     String pluginInvocation( final String pluginMarkup, final PluginContent pluginContent ) {
    87|         final String pluginInvocation = pluginContent.invoke( wikiContext );
    88|         if( pluginMarkup.equals( pluginInvocation + "()" ) ) { // plugin line markup == plugin execution + "()" -> hasn't been executed
    89|             return pluginMarkup;
    90|         } else {
    91|             return pluginInvocation;
    92|         }
    93|     }
    94|     void handleTableOfContentsPlugin(final NodeTracker state, final JSPWikiLink link) {
    95|         if( !m_wysiwygEditorMode ) {
    96|             final ResourceBundle rb = Preferences.getBundle( wikiContext, Plugin.CORE_PLUGINS_RESOURCEBUNDLE );
    97|             final WikiHtmlInline divToc = WikiHtmlInline.of( "<div class=\"toc\">\n" );
    98|             final WikiHtmlInline divCollapseBox = WikiHtmlInline.of( "<div class=\"collapsebox\">\n" );
    99|             final WikiHtmlInline divsClosing = WikiHtmlInline.of( "</div>\n</div>\n" );
   100|             final WikiHtmlInline h4Title = WikiHtmlInline.of( "<h4 id=\"section-TOC\">" + // FIXME proper plugin parameters handling
   101|                                                                    rb.getString( "tableofcontents.title" ) +
   102|                                                                    "</h4>\n" );
   103|             final TocBlock toc = new TocBlock( CharSubSequence.of( "[TOC]" ), CharSubSequence.of( "levels=1-3" ) );
   104|             link.insertAfter( divToc );
   105|             divToc.insertAfter( divCollapseBox );
   106|             divCollapseBox.insertAfter( h4Title );
   107|             h4Title.insertAfter( toc );
   108|             toc.insertAfter( divsClosing );
   109|         } else {
   110|             NodePostProcessorStateCommonOperations.inlineLinkTextOnWysiwyg( state, link, m_wysiwygEditorMode );
   111|         }
   112|         removeLink( state, link );
   113|     }
   114|     void removeLink(final NodeTracker state, final JSPWikiLink link) {
   115|         link.unlink();
   116|         state.nodeRemoved( link );
   117|     }
   118| }


# ====================================================================
# FILE: jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/VariableLinkNodePostProcessorState.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-53 ---
     1| /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.markdown.extensions.jspwikilinks.postprocessor;
    18| import com.vladsch.flexmark.util.ast.Node;
    19| import com.vladsch.flexmark.util.ast.NodeTracker;
    20| import org.apache.wiki.api.core.Context;
    21| import org.apache.wiki.api.exceptions.NoSuchVariableException;
    22| import org.apache.wiki.markdown.nodes.JSPWikiLink;
    23| import org.apache.wiki.variables.VariableManager;
    24| /**
    25|  * {@link NodePostProcessorState} which further post processes WikiVariable links.
    26|  */
    27| public class VariableLinkNodePostProcessorState implements NodePostProcessorState< JSPWikiLink > {
    28|     private final Context wikiContext;
    29|     private final boolean m_wysiwygEditorMode;
    30|     public VariableLinkNodePostProcessorState( final Context wikiContext ) {
    31|         this.wikiContext = wikiContext;
    32|         final Boolean wysiwygVariable = wikiContext.getVariable( Context.VAR_WYSIWYG_EDITOR_MODE );
    33|         m_wysiwygEditorMode = wysiwygVariable != null && wysiwygVariable;
    34|     }
    35|     /**
    36|      * {@inheritDoc}
    37|      *
    38|      * @see NodePostProcessorState#process(NodeTracker, Node)
    39|      */
    40|     @Override
    41|     public void process( final NodeTracker state, final JSPWikiLink link ) {
    42|         final String variable = NodePostProcessorStateCommonOperations.inlineLinkTextOnWysiwyg( state, link, m_wysiwygEditorMode );
    43|         if( !m_wysiwygEditorMode ) {
    44|             try {
    45|                 final String parsedVariable = wikiContext.getEngine().getManager( VariableManager.class ).parseAndGetValue( wikiContext, variable );
    46|                 final WikiHtmlInline content = WikiHtmlInline.of( parsedVariable, wikiContext );
    47|                 NodePostProcessorStateCommonOperations.addContent( state, link, content );
    48|             } catch( final NoSuchVariableException e ) {
    49|                 NodePostProcessorStateCommonOperations.makeError( state, link, "No such variable: " + variable + " (" + e.getMessage() + ")" );
    50|             }
    51|         }
    52|     }
    53| }


# ====================================================================
# FILE: jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/WikiHtmlInline.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-43 ---
     1| /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.markdown.extensions.jspwikilinks.postprocessor;
    18| import com.vladsch.flexmark.ast.HtmlInline;
    19| import com.vladsch.flexmark.util.sequence.BasedSequence;
    20| import org.apache.wiki.api.core.Context;
    21| import org.apache.wiki.parser.MarkupParser;
    22| import org.apache.wiki.util.TextUtil;
    23| /**
    24|  * <p>Regular {@link HtmlInline} get escaped depending on the value of the {@code MarkupParser.PROP_ALLOWHTML} property.</p>
    25|  * <p>However, wikilink post processors inject additional HtmlInline that must not be escaped. Subclassing {@link HtmlInline}
    26|  * allows us to register a custom {@code NodeRenderingHandler} at {@code JSPWikiLinkRenderer} to bypass this limitation.</p>
    27|  */
    28| public class WikiHtmlInline extends HtmlInline {
    29|     private WikiHtmlInline( final BasedSequence chars ) {
    30|         super( chars );
    31|     }
    32|     public static WikiHtmlInline of( final String str ) {
    33|         return new WikiHtmlInline( BasedSequence.of( str ) );
    34|     }
    35|     public static WikiHtmlInline of( final String str, final Context context ) {
    36|         final boolean allowHtml = context.getBooleanWikiProperty( MarkupParser.PROP_ALLOWHTML, false );
    37|         if( allowHtml ) {
    38|             return WikiHtmlInline.of( str );
    39|         } else {
    40|             return new WikiHtmlInline( BasedSequence.of( TextUtil.escapeHTMLEntities( str ) ) );
    41|         }
    42|     }
    43| }


# ====================================================================
# FILE: jspwiki-markdown/src/main/java/org/apache/wiki/markdown/renderer/JSPWikiLinkRenderer.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 4-71 ---
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16| */
    17| package org.apache.wiki.markdown.renderer;
    18| import com.vladsch.flexmark.html.HtmlWriter;
    19| import com.vladsch.flexmark.html.renderer.LinkType;
    20| import com.vladsch.flexmark.html.renderer.NodeRenderer;
    21| import com.vladsch.flexmark.html.renderer.NodeRendererContext;
    22| import com.vladsch.flexmark.html.renderer.NodeRenderingHandler;
    23| import com.vladsch.flexmark.html.renderer.ResolvedLink;
    24| import org.apache.wiki.markdown.extensions.jspwikilinks.postprocessor.WikiHtmlInline;
    25| import org.apache.wiki.markdown.nodes.JSPWikiLink;
    26| import java.util.HashSet;
    27| import java.util.Set;
    28| /**
    29|  * Flexmark {@link NodeRenderer} for {@link JSPWikiLink}s.
    30|  */
    31| public class JSPWikiLinkRenderer implements NodeRenderer {
    32|     /**
    33|      * {@inheritDoc}
    34|      *
    35|      * @see com.vladsch.flexmark.html.renderer.NodeRenderer#getNodeRenderingHandlers()
    36|      */
    37|     @Override
    38|     public Set< NodeRenderingHandler< ? > > getNodeRenderingHandlers() {
    39|         final HashSet< NodeRenderingHandler< ? > > set = new HashSet<>();
    40|         set.add( new NodeRenderingHandler<>( JSPWikiLink.class, new NodeRenderingHandler.CustomNodeRenderer<>() {
    41|             /**
    42|              * {@inheritDoc}
    43|              */
    44|             @Override
    45|             public void render( final JSPWikiLink node, final NodeRendererContext context, final HtmlWriter html ) {
    46|                 if (context.isDoNotRenderLinks()) {
    47|                     context.renderChildren(node);
    48|                 } else {
    49|                     final ResolvedLink resolvedLink = context.resolveLink(LinkType.LINK, node.getUrl().unescape(), null);
    50|                     html.attr("href", resolvedLink.getUrl());
    51|                     if (node.getTitle().isNotNull()) {
    52|                         html.attr("title", node.getTitle().unescape());
    53|                     }
    54|                     html.srcPos(node.getChars()).withAttr(resolvedLink).tag("a");
    55|                     context.renderChildren(node);
    56|                     html.tag("/a");
    57|                 }
    58|             }
    59|         } ) );
    60|         set.add( new NodeRenderingHandler<>( WikiHtmlInline.class, new NodeRenderingHandler.CustomNodeRenderer<>() {
    61|             /**
    62|              * {@inheritDoc}
    63|              */
    64|             @Override
    65|             public void render( final WikiHtmlInline node, final NodeRendererContext context, final HtmlWriter html ) {
    66|                 html.raw( node.getChars().normalizeEOL() );
    67|             }
    68|         } ) );
    69|         return set;
    70|     }
    71| }


# ====================================================================
# FILE: jspwiki-markdown/src/main/java/org/apache/wiki/parser/markdown/MarkdownDocument.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 3-70 ---
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.parser.markdown;
    18| import com.vladsch.flexmark.ext.attributes.AttributesExtension;
    19| import com.vladsch.flexmark.ext.definition.DefinitionExtension;
    20| import com.vladsch.flexmark.ext.footnotes.FootnoteExtension;
    21| import com.vladsch.flexmark.ext.tables.TablesExtension;
    22| import com.vladsch.flexmark.ext.toc.TocExtension;
    23| import com.vladsch.flexmark.html.HtmlRenderer;
    24| import com.vladsch.flexmark.parser.Parser;
    25| import com.vladsch.flexmark.parser.ParserEmulationProfile;
    26| import com.vladsch.flexmark.util.ast.Node;
    27| import com.vladsch.flexmark.util.data.MutableDataSet;
    28| import com.vladsch.flexmark.util.misc.Extension;
    29| import org.apache.oro.text.regex.Pattern;
    30| import org.apache.wiki.api.core.Context;
    31| import org.apache.wiki.api.core.Page;
    32| import org.apache.wiki.markdown.MarkdownForJSPWikiExtension;
    33| import org.apache.wiki.parser.MarkupParser;
    34| import org.apache.wiki.parser.WikiDocument;
    35| import java.util.Arrays;
    36| import java.util.List;
    37| /**
    38|  * Simple placeholder for Markdown Nodes
    39|  */
    40| public class MarkdownDocument extends WikiDocument {
    41|     private static final long serialVersionUID = 1L;
    42|     private final Node md;
    43|     public MarkdownDocument( final Page page, final Node md ) {
    44|         super( page );
    45|         this.md = md;
    46|     }
    47|     public Node getMarkdownNode() {
    48|         return md;
    49|     }
    50|     /**
    51|      * Configuration options for MarkdownRenderers.
    52|      *
    53|      * @param context current wiki context
    54|      * @return configuration options for MarkdownRenderers.
    55|      */
    56|     public static MutableDataSet options( final Context context, final boolean isImageInlining, final List< Pattern > inlineImagePatterns ) {
    57|         final MutableDataSet options = new MutableDataSet();
    58|         options.setFrom( ParserEmulationProfile.COMMONMARK );
    59|         options.set( AttributesExtension.ASSIGN_TEXT_ATTRIBUTES, true );
    60|         options.set( FootnoteExtension.FOOTNOTE_LINK_REF_CLASS, MarkupParser.CLASS_FOOTNOTE_REF );
    61|         options.set( HtmlRenderer.ESCAPE_HTML, !context.getBooleanWikiProperty( MarkupParser.PROP_ALLOWHTML, false ) );
    62|         options.set( Parser.EXTENSIONS, Arrays.asList( new Extension[] { new MarkdownForJSPWikiExtension( context, isImageInlining, inlineImagePatterns ),
    63|                                                                          AttributesExtension.create(),
    64|                                                                          DefinitionExtension.create(),
    65|                                                                          FootnoteExtension.create(),
    66|                                                                          TablesExtension.create(),
    67|                                                                          TocExtension.create() } ) );
    68|         return options;
    69|     }
    70| }


# ====================================================================
# FILE: jspwiki-util/src/main/java/org/apache/wiki/util/CryptoUtil.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 2-199 ---
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.  
    16|  */
    17| package org.apache.wiki.util;
    18| import java.nio.charset.StandardCharsets;
    19| import java.security.MessageDigest;
    20| import java.security.NoSuchAlgorithmException;
    21| import java.security.SecureRandom;
    22| import java.util.Base64;
    23| import java.util.Random;
    24| /**
    25|  * Hashes and verifies salted SHA-1 passwords, which are compliant with RFC
    26|  * 2307.
    27|  */
    28| public final class CryptoUtil {
    29|     private static final String SSHA = "{SSHA}";
    30|     private static final String SHA1 = "{SHA-1}";
    31|     private static final String SHA256 = "{SHA-256}";
    32|     private static final Random RANDOM = new SecureRandom();
    33|     private static final int DEFAULT_SALT_SIZE = 8;
    34|     private static final Object HELP = "--help";
    35|     private static final Object HASH = "--hash";
    36|     private static final Object VERIFY = "--verify";
    37|     /**
    38|      * Private constructor to prevent direct instantiation.
    39|      */
    40|     private CryptoUtil() {}
    41|     /**
    42|      * <p>
    43|      * Convenience method for hashing and verifying salted SHA-1 or SHA-256 passwords from
    44|      * the command line. This method requires <code>commons-codec-1.3.jar</code>
    45|      * (or a newer version) to be on the classpath. Command line arguments are
    46|      * as follows:
    47|      * </p>
    48|      * <ul>
    49|      * <li><code>--hash <var>password</var> SSHA</code> - hashes <var>password</var></code>
    50|      * and prints a password digest that looks like this: <blockquote><code>{SSHA}yfT8SRT/WoOuNuA6KbJeF10OznZmb28=</code></blockquote></li>
    51|      * <li><code>--verify <var>password</var> <var>digest</var></code> -
    52|      * verifies <var>password</var> by extracting the salt from <var>digest</var>
    53|      * (which is identical to what is printed by <code>--hash</code>) and
    54|      * re-computing the digest again using the password and salt. If the
    55|      * password supplied is the same as the one used to create the original
    56|      * digest, <code>true</code> will be printed; otherwise <code>false</code></li>
    57|      * </ul>
    58|      * <p>For example, one way to use this utility is to change to JSPWiki's <code>build</code> directory
    59|      * and type the following command:</p>
    60|      * <blockquote><code>java -cp JSPWiki.jar:../lib/commons-codec-1.3.jar org.apache.wiki.util.CryptoUtil --hash mynewpassword</code></blockquote>
    61|      * 
    62|      * @param args arguments for this method as described above
    63|      * @throws Exception Catches nothing; throws everything up.
    64|      */
    65|     public static void main( final String[] args ) throws Exception {
    66|         if( args.length == 0 || ( args.length == 1 && HELP.equals( args[0] ) ) ) {
    67|             System.out.println( "Usage: CryptoUtil [options] " );
    68|             System.out.println( "   --hash   password algorithm             create hash for password" );
    69|             System.out.println( "   --verify password digest algorithm      verify password for digest" );
    70|             System.out.println( "Valid algorithm options are {SSHA} and {SHA-256}. If no algorithm is specified or an unsupported algorithm is specified, SHA-256 is used." );
    71|         }
    72|         if( HASH.equals( args[0] ) ) {
    73|             if( args.length < 2 ) {
    74|                 throw new IllegalArgumentException( "Error: --hash requires a 'password' argument." );
    75|             }
    76|             final String password = args[1].trim();
    77|             final String algorithm = args.length > 2 ? args[2].trim() : SHA256;
    78|             System.out.println( CryptoUtil.getSaltedPassword( password.getBytes( StandardCharsets.UTF_8 ), algorithm ) );
    79|         } else if( VERIFY.equals( args[0] ) ) {
    80|             if( args.length < 3 ) {
    81|                 throw new IllegalArgumentException( "Error: --hash requires 'password' and 'digest' arguments." );
    82|             }
    83|             final String password = args[1].trim();
    84|             final String digest = args[2].trim();
    85|             System.out.println( CryptoUtil.verifySaltedPassword( password.getBytes( StandardCharsets.UTF_8 ), digest ) );
    86|         } else {
    87|             System.out.println( "Wrong usage. Try --help." );
    88|         }
    89|     }
    90|     /**
    91|      * <p>
    92|      * Creates an RFC 2307-compliant salted, hashed password with the SHA1 or SHA-256
    93|      * MessageDigest algorithm. After the password is digested, the first 20 or 32
    94|      * bytes of the digest will be the actual password hash; the remaining bytes
    95|      * will be a randomly generated salt of length {@link #DEFAULT_SALT_SIZE},
    96|      * for example: <blockquote><code>{SSHA}3cGWem65NCEkF5Ew5AEk45ak8LHUWAwPVXAyyw==</code></blockquote>
    97|      * </p>
    98|      * <p>
    99|      * In layman's terms, the formula is
   100|      * <code>digest( secret + salt ) + salt</code>. The resulting digest is Base64-encoded.
   101|      * </p>
   102|      * <p>
   103|      * Note that successive invocations of this method with the same password
   104|      * will result in different hashes! (This, of course, is exactly the point.)
   105|      * </p>
   106|      * 
   107|      * @param password the password to be digested
   108|      * @return the Base64-encoded password hash, prepended by
   109|      *         <code>{SSHA}</code> or <code>{SHA256}</code>.
   110|      * @throws NoSuchAlgorithmException If your JVM does not supply the necessary algorithm. Should not happen.
   111|      */
   112|     public static String getSaltedPassword( final byte[] password, final String algorithm ) throws NoSuchAlgorithmException {
   113|         final byte[] salt = new byte[ DEFAULT_SALT_SIZE ];
   114|         RANDOM.nextBytes( salt );
   115|         return getSaltedPassword( password, salt, algorithm );
   116|     }
   117|     /**
   118|      * <p>
   119|      * Helper method that creates an RFC 2307-compliant salted, hashed password with the SHA1 or SHA256
   120|      * MessageDigest algorithm. After the password is digested, the first 20 or 32
   121|      * bytes of the digest will be the actual password hash; the remaining bytes
   122|      * will be the salt. Thus, supplying a password <code>testing123</code>
   123|      * and a random salt <code>foo</code> produces the hash when using SHA1:
   124|      * </p>
   125|      * <blockquote><code>{SSHA}yfT8SRT/WoOuNuA6KbJeF10OznZmb28=</code></blockquote>
   126|      * <p>
   127|      * In layman's terms, the formula is
   128|      * <code>digest( secret + salt ) + salt</code>. The resulting digest is Base64-encoded.</p>
   129|      * 
   130|      * @param password the password to be digested
   131|      * @param salt the random salt
   132|      * @return the Base64-encoded password hash, prepended by <code>{SSHA}</code> or <code>{SHA256}</code>.
   133|      * @throws NoSuchAlgorithmException If your JVM does not supply the necessary algorithm. Should not happen.
   134|      */
   135|     static String getSaltedPassword( final byte[] password, final byte[] salt, final String algorithm ) throws NoSuchAlgorithmException {
   136|         final String algorithmToUse = algorithm.equals(SSHA) ? SHA1 : algorithm;
   137|         final MessageDigest digest = MessageDigest.getInstance( algorithmToUse.substring( 1, algorithmToUse.length() -1 ) );
   138|         digest.update( password );
   139|         final byte[] hash = digest.digest( salt );
   140|         final byte[] all = new byte[hash.length + salt.length];
   141|         System.arraycopy(hash, 0, all, 0, hash.length);
   142|         System.arraycopy(salt, 0, all, hash.length, salt.length);
   143|         final byte[] base64 = Base64.getEncoder().encode( all );
   144|         return algorithm + new String( base64, StandardCharsets.UTF_8 );
   145|     }
   146|     /**
   147|      *  Compares a password to a given entry and returns true, if it matches.
   148|      *
   149|      *  @param password The password in bytes.
   150|      *  @param entry The password entry, typically starting with {SSHA}.
   151|      *  @return True, if the password matches.
   152|      *  @throws NoSuchAlgorithmException If there is no SHA available.
   153|      */
   154|     public static boolean verifySaltedPassword( final byte[] password, final String entry ) throws NoSuchAlgorithmException {
   155|         if( !entry.startsWith( SSHA ) && !entry.startsWith( SHA256 ) ) {
   156|             throw new IllegalArgumentException( "Hash not prefixed by expected algorithm; is it really a salted hash?" );
   157|         }
   158|         final String algorithm = entry.startsWith( SSHA ) ? SSHA : SHA256;
   159|         final byte[] challenge = Base64.getDecoder().decode( entry.substring( algorithm.length() ).getBytes( StandardCharsets.UTF_8 ) );
   160|         final byte[] passwordHash = extractPasswordHash( challenge, algorithm.equals( SSHA ) ? 20 : 32 );
   161|         final byte[] salt = extractSalt( challenge, algorithm.equals( SSHA ) ? 20 : 32  );
   162|         final String algorithmToUse = algorithm.equals( SSHA ) ? SHA1 : algorithm;
   163|         final MessageDigest digest = MessageDigest.getInstance( algorithmToUse.substring( 1, algorithmToUse.length() -1 ) );
   164|         digest.update( password );
   165|         final byte[] hash = digest.digest( salt );
   166|         return MessageDigest.isEqual( passwordHash, hash );
   167|     }
   168|     /**
   169|      * Helper method that extracts the hashed password fragment from a supplied salted SHA-1 or SHA-256 digest
   170|      * by taking all the characters before position 20 or 32 depending on algorithm.
   171|      * 
   172|      * @param digest the salted digest, which is assumed to have been previously decoded from Base64.
   173|      * @return the password hash
   174|      * @throws IllegalArgumentException if the length of the supplied digest is less than or equal to 20 bytes
   175|      */
   176|     static byte[] extractPasswordHash( final byte[] digest, final int hashLength ) throws IllegalArgumentException {
   177|         if( digest.length < hashLength ) {
   178|             throw new IllegalArgumentException( "Hash was shorter than expected; could not extract password hash!" );
   179|         }
   180|         final byte[] hash = new byte[ hashLength ];
   181|         System.arraycopy( digest, 0, hash, 0, hashLength );
   182|         return hash;
   183|     }
   184|     /**
   185|      * Helper method that extracts the salt from supplied salted digest by taking all the characters after a given index.
   186|      * 
   187|      * @param digest the salted digest, which is assumed to have been previously decoded from Base64.
   188|      * @return the salt
   189|      * @throws IllegalArgumentException if the length of the supplied digest is less than given length.
   190|      */
   191|     static byte[] extractSalt( final byte[] digest, final int hashLength ) throws IllegalArgumentException {
   192|         if( digest.length <= hashLength ) {
   193|             throw new IllegalArgumentException( "Hash was shorter than expected; we found no salt!" );
   194|         }
   195|         final byte[] salt = new byte[digest.length - hashLength];
   196|         System.arraycopy(digest, hashLength, salt, 0, digest.length - hashLength);
   197|         return salt;
   198|     }
   199| }


# ====================================================================
# FILE: jspwiki-util/src/main/java/org/apache/wiki/util/TextUtil.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 575-659 ---
   575|                 if( wasSpace ) {
   576|                     continue;
   577|                 }
   578|                 wasSpace = true;
   579|             } else {
   580|                 wasSpace = false;
   581|             }
   582|             if( Character.isLetterOrDigit( ch ) || allowedChars.indexOf( ch ) != -1 ) {
   583|                 if( isWord ) {
   584|                     ch = Character.toUpperCase( ch );
   585|                 }
   586|                 clean.append( ch );
   587|                 isWord = false;
   588|             } else {
   589|                 isWord = true;
   590|             }
   591|         }
   592|         return clean.toString();
   593|     }
   594|     /**
   595|      *  Escapes XML entities in an HTML-compatible way (i.e. does not escape entities that are already escaped).
   596|      *
   597|      *  @param buf String to be escaped.
   598|      *  @return An escaped string.
   599|      */
   600|     public static String escapeHTMLEntities( final String buf ) {
   601|         final StringBuilder tmpBuf = new StringBuilder( buf.length() + 20 );
   602|         for( int i = 0; i < buf.length(); i++ ) {
   603|             final char ch = buf.charAt(i);
   604|             if( ch == '<' ) {
   605|                 tmpBuf.append("&lt;");
   606|             } else if( ch == '>' ) {
   607|                 tmpBuf.append("&gt;");
   608|             } else if( ch == '\"' ) {
   609|                 tmpBuf.append("&quot;");
   610|             } else if( ch == '&' ) {
   611|                 boolean isEntity = false;
   612|                 final StringBuilder entityBuf = new StringBuilder();
   613|                 if( i < buf.length() -1 ) {
   614|                     for( int j = i; j < buf.length(); j++ ) {
   615|                         final char ch2 = buf.charAt( j );
   616|                         if( Character.isLetterOrDigit( ch2 ) || (ch2 == '#' && j == i+1) || ch2 == ';' || ch2 == '&' ) {
   617|                             entityBuf.append(ch2);
   618|                             if( ch2 == ';' ) {
   619|                                 isEntity = true;
   620|                                 break;
   621|                             }
   622|                         } else {
   623|                             break;
   624|                         }
   625|                     }
   626|                 }
   627|                 if( isEntity ) {
   628|                     tmpBuf.append( entityBuf );
   629|                     i = i + entityBuf.length() - 1;
   630|                 } else {
   631|                     tmpBuf.append( "&amp;" );
   632|                 }
   633|             } else {
   634|                 tmpBuf.append( ch );
   635|             }
   636|         }
   637|         return tmpBuf.toString();
   638|     }
   639|     /**
   640|      *  Creates a Properties object based on an array which contains alternatively a key and a value.  It is useful
   641|      *  for generating default mappings. For example:
   642|      *  <pre>
   643|      *     String[] properties = { "jspwiki.property1", "value1", "jspwiki.property2", "value2 };
   644|      *     Properties props = TextUtil.createPropertes( values );
   645|      *     System.out.println( props.getProperty("jspwiki.property1") );
   646|      *  </pre>
   647|      *  would output "value1".
   648|      *
   649|      *  @param values Alternating key and value pairs.
   650|      *  @return Property object
   651|      *  @see java.util.Properties
   652|      *  @throws IllegalArgumentException if the property array is missing a value for a key.
   653|      *  @since 2.2.
   654|      */
   655|     public static Properties createProperties( final String[] values ) throws IllegalArgumentException {
   656|         if( values.length % 2 != 0 ) {
   657|         	throw new IllegalArgumentException( "One value is missing.");
   658|         }
   659|         final Properties props = new Properties();

