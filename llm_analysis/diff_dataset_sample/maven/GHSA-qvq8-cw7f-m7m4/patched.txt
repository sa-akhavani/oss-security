# ====================================================================
# FILE: jspwiki-api/src/main/java/org/apache/wiki/api/Release.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 28-70 ---
    28|  *  changed much since.
    29|  *  </p>
    30|  *  @since  1.0
    31|  */
    32| public final class Release {
    33|     private static final String VERSION_SEPARATORS = ".-";
    34|     /**
    35|      *  This is the default application name.
    36|      */
    37|     public static final String     APPNAME       = "JSPWiki";
    38|     /**
    39|      *  This should be empty when doing a release - otherwise keep it as "-git-" so that whenever someone checks out the code, they know
    40|      *  it is a bleeding-edge version.  Other possible values are "-alpha-" and "-beta-" for alpha and beta versions, respectively.
    41|      *  <p>
    42|      *  If the POSTFIX is empty, it is not added to the version string.
    43|      */
    44|     private static final String    POSTFIX       = "";
    45|     /** The JSPWiki major version. */
    46|     public static final int        VERSION       = 2;
    47|     /** The JSPWiki revision. */
    48|     public static final int        REVISION      = 12;
    49|     /** The minor revision.  */
    50|     public static final int        MINORREVISION = 0;
    51|     /** The build number/identifier.  This is a String as opposed to an integer, just so that people can add other identifiers to it.
    52|      * The build number is incremented every time a committer checks in code, and reset when a release is made.
    53|      *  <p>
    54|      *  If you are a person who likes to build his own releases, we recommend that you add your initials to this
    55|      *  identifier (e.g. "13-jj", or "49-aj").
    56|      *  <p>
    57|      *  If the build identifier is empty, it is not added.
    58|      */
    59|     public static final String     BUILD         = "";
    60|     /**
    61|      *  This is the generic version string you should use when printing out the version.  It is of
    62|      *  the form "VERSION.REVISION.MINORREVISION[-POSTFIX][-BUILD]".
    63|      */
    64|     public static final String     VERSTR        = VERSION + "." +
    65|                                                    REVISION + "." +
    66|                                                    MINORREVISION +
    67|                                                    POSTFIX +
    68|                                                    BUILD;
    69|     /** Private constructor prevents instantiation. */
    70|     private Release() {


# ====================================================================
# FILE: jspwiki-api/src/main/java/org/apache/wiki/api/core/Engine.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 64-105 ---
    64|     /** Define the used encoding.  Currently supported are ISO-8859-1 and UTF-8 */
    65|     String PROP_ENCODING = "jspwiki.encoding";
    66|     /** Do not use encoding in WikiJSPFilter, default is false for most servers.
    67|      Double negative, cause for most servers you don't need the property */
    68|     String PROP_NO_FILTER_ENCODING = "jspwiki.nofilterencoding";
    69|     /** Property name for where the jspwiki work directory should be.
    70|      If not specified, reverts to ${java.tmpdir}. */
    71|     String PROP_WORKDIR = "jspwiki.workDir";
    72|     /** The name of the cookie that gets stored to the user browser. */
    73|     String PREFS_COOKIE_NAME = "JSPWikiUserProfile";
    74|     /** Property name for the "match english plurals" -hack. */
    75|     String PROP_MATCHPLURALS = "jspwiki.translatorReader.matchEnglishPlurals";
    76|     /** Property name for the template that is used. */
    77|     String PROP_TEMPLATEDIR = "jspwiki.templateDir";
    78|     /** Property name for the default front page. */
    79|     String PROP_FRONTPAGE = "jspwiki.frontPage";
    80|     /** Property name for setting the url generator instance */
    81|     String PROP_URLCONSTRUCTOR = "jspwiki.urlConstructor";
    82|     /** The name of the property containing the ACLManager implementing class. The value is {@value}. */
    83|     String PROP_ACL_MANAGER_IMPL = "jspwiki.aclManager";
    84|     /** The name of the property containing the ReferenceManager implementing class. The value is {@value}. */
    85|     String PROP_REF_MANAGER_IMPL = "jspwiki.refManager";
    86|     /** If this property is set to false, we don't allow the creation of empty pages */
    87|     String PROP_ALLOW_CREATION_OF_EMPTY_PAGES = "jspwiki.allowCreationOfEmptyPages";
    88|     /**
    89|      * Adapt Engine to a concrete type.
    90|      *
    91|      * @param cls class denoting the type to adapt to.
    92|      * @param <E> type to adapt to.
    93|      * @return engine instance adapted to the requested type. Might throw an unchecked exception if the instance cannot be adapted to requested type!
    94|      */
    95|     @SuppressWarnings( "unchecked" )
    96|     default < E extends Engine > E adapt( final Class< E > cls ) {
    97|         return ( E )this;
    98|     }
    99|     /**
   100|      * Retrieves the object instantiated by the Engine matching the requested type.
   101|      *
   102|      * @param manager requested object instantiated by the Engine.
   103|      * @param <T> type of the requested object.
   104|      * @return requested object instantiated by the Engine, {@code null} if not available.
   105|      */


# ====================================================================
# FILE: jspwiki-http/src/main/java/org/apache/wiki/http/filter/CsrfProtectionFilter.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-36 ---
     1| /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.http.filter;
    18| import org.apache.logging.log4j.LogManager;
    19| import org.apache.logging.log4j.Logger;
    20| import org.apache.wiki.api.core.Engine;
    21| import org.apache.wiki.api.core.Session;
    22| import org.apache.wiki.api.spi.Wiki;
    23| import javax.servlet.Filter;
    24| import javax.servlet.FilterChain;
    25| import javax.servlet.FilterConfig;
    26| import javax.servlet.ServletException;
    27| import javax.servlet.ServletRequest;
    28| import javax.servlet.ServletResponse;
    29| import javax.servlet.http.HttpServletRequest;
    30| import javax.servlet.http.HttpServletResponse;
    31| import java.io.IOException;
    32| /**
    33|  * CSRF protection Filter which uses the synchronizer token pattern â€“ an anti-CSRF token is created and stored in the
    34|  * user session and in a hidden field on subsequent form submits. At every submit the server checks the token from the
    35|  * session matches the one submitted from the form.
    36|  */


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/WikiEngine.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 383-424 ---
   383|                 }
   384|             }
   385|             if( !exists ) {
   386|                 LOG.warn( "{} template not found, updating WikiEngine's default template to {}", getTemplateDir(), DEFAULT_TEMPLATE_NAME );
   387|                 m_templateDir = DEFAULT_TEMPLATE_NAME;
   388|             }
   389|         }
   390|     }
   391|     /**
   392|      *  Initializes the reference manager. Scans all existing WikiPages for
   393|      *  internal links and adds them to the ReferenceManager object.
   394|      *
   395|      *  @throws WikiException If the reference manager initialization fails.
   396|      */
   397|     public void initReferenceManager() throws WikiException {
   398|         try {
   399|             if( getManager( ReferenceManager.class ) == null ) {
   400|                 final ArrayList< Page > pages = new ArrayList<>();
   401|                 pages.addAll( getManager( PageManager.class ).getAllPages() );
   402|                 pages.addAll( getManager( AttachmentManager.class ).getAllAttachments() );
   403|                 final String refMgrClassName = m_properties.getProperty( PROP_REF_MANAGER_IMPL, ClassUtil.getMappedClass( ReferenceManager.class.getName() ).getName() );
   404|                 initComponent( refMgrClassName, ReferenceManager.class, this );
   405|                 getManager( ReferenceManager.class ).initialize( pages );
   406|             }
   407|         } catch( final ProviderException e ) {
   408|             LOG.fatal( "PageProvider is unable to list pages: ", e );
   409|         } catch( final Exception e ) {
   410|             throw new WikiException( "Could not instantiate ReferenceManager: " + e.getMessage(), e );
   411|         }
   412|     }
   413|     /** {@inheritDoc} */
   414|     @Override
   415|     public Properties getWikiProperties() {
   416|         return m_properties;
   417|     }
   418|     /** {@inheritDoc} */
   419|     @Override
   420|     public String getWorkDir() {
   421|         return m_workDir;
   422|     }
   423|     /** {@inheritDoc} */
   424|     @Override


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/WikiSession.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 57-97 ---
    57|     private static final Logger LOG = LogManager.getLogger( WikiSession.class );
    58|     private static final String ALL = "*";
    59|     private static final ThreadLocal< Session > c_guestSession = new ThreadLocal<>();
    60|     private final Subject m_subject = new Subject();
    61|     private final Map< String, Set< String > > m_messages  = new ConcurrentHashMap<>();
    62|     /** The Engine that created this session. */
    63|     private Engine m_engine;
    64|     private String antiCsrfToken;
    65|     private String m_status            = ANONYMOUS;
    66|     private Principal m_userPrincipal  = WikiPrincipal.GUEST;
    67|     private Principal m_loginPrincipal = WikiPrincipal.GUEST;
    68|     private Locale m_cachedLocale      = Locale.getDefault();
    69|     /**
    70|      * Returns <code>true</code> if one of this WikiSession's user Principals can be shown to belong to a particular wiki group. If
    71|      * the user is not authenticated, this method will always return <code>false</code>.
    72|      *
    73|      * @param group the group to test
    74|      * @return the result
    75|      */
    76|     protected boolean isInGroup( final Group group ) {
    77|         return Arrays.stream(getPrincipals()).anyMatch(principal -> isAuthenticated() && group.isMember(principal));
    78|     }
    79|     /**
    80|      * Private constructor to prevent WikiSession from being instantiated directly.
    81|      */
    82|     private WikiSession() {
    83|     }
    84|     /** {@inheritDoc} */
    85|     @Override
    86|     public boolean isAsserted() {
    87|         return m_subject.getPrincipals().contains( Role.ASSERTED );
    88|     }
    89|     /** {@inheritDoc} */
    90|     @Override
    91|     public boolean isAuthenticated() {
    92|         if ( m_subject.getPrincipals().contains( Role.AUTHENTICATED ) ) {
    93|             return true;
    94|         }
    95|         if ( !isAnonymous() && !isAsserted() ) {
    96|             m_subject.getPrincipals().add( Role.AUTHENTICATED );
    97|             return true;

# --- HUNK 2: Lines 153-193 ---
   153|             m_messages.clear();
   154|         }
   155|     }
   156|     /** {@inheritDoc} */
   157|     @Override
   158|     public String[] getMessages() {
   159|         return getMessages( ALL );
   160|     }
   161|     /** {@inheritDoc} */
   162|     @Override
   163|     public String[] getMessages( final String topic ) {
   164|         final Set< String > messages = m_messages.get( topic );
   165|         if( messages == null || messages.size() == 0 ) {
   166|             return new String[ 0 ];
   167|         }
   168|         return messages.toArray( new String[0] );
   169|     }
   170|     /** {@inheritDoc} */
   171|     @Override
   172|     public Principal[] getPrincipals() {
   173|         return m_subject.getPrincipals().stream().filter(AuthenticationManager::isUserPrincipal).toArray(Principal[]::new);
   174|     }
   175|     /** {@inheritDoc} */
   176|     @Override
   177|     public Principal[] getRoles() {
   178|         final Set< Principal > roles = new HashSet<>();
   179|         roles.addAll( m_subject.getPrincipals( Role.class ) );
   180|         roles.addAll( m_subject.getPrincipals( GroupPrincipal.class ) );
   181|         final Principal[] roleArray = roles.toArray( new Principal[0] );
   182|         Arrays.sort( roleArray, WikiPrincipal.COMPARATOR );
   183|         return roleArray;
   184|     }
   185|     /** {@inheritDoc} */
   186|     @Override
   187|     public boolean hasPrincipal( final Principal principal ) {
   188|         return m_subject.getPrincipals().contains( principal );
   189|     }
   190|     /**
   191|      * Listens for WikiEvents generated by source objects such as the GroupManager, UserManager or AuthenticationManager. This method adds
   192|      * Principals to the private Subject managed by the WikiSession.
   193|      *


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/auth/AuthenticationManager.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 148-188 ---
   148|      */
   149|     static boolean isRolePrincipal( final Principal principal ) {
   150|         return principal instanceof Role || principal instanceof GroupPrincipal;
   151|     }
   152|     /**
   153|      * Determines whether the supplied Principal is a "user principal".
   154|      *
   155|      * @param principal the principal to test
   156|      * @return {@code false} if the Principal is of type {@link GroupPrincipal} or {@link Role}, {@code true} otherwise.
   157|      */
   158|     static boolean isUserPrincipal( final Principal principal ) {
   159|         return !isRolePrincipal( principal );
   160|     }
   161|     /**
   162|      * Returns the first Principal in a set that isn't a {@link Role} or {@link GroupPrincipal}.
   163|      *
   164|      * @param principals the principal set
   165|      * @return the login principal
   166|      */
   167|     default Principal getLoginPrincipal( final Set< Principal > principals ) {
   168|         return principals.stream().filter(AuthenticationManager::isUserPrincipal).findFirst().orElse(null);
   169|     }
   170|     /**
   171|      * Registers a WikiEventListener with this instance. This is a convenience method.
   172|      *
   173|      * @param listener the event listener
   174|      */
   175|     void addWikiEventListener( WikiEventListener listener );
   176|     /**
   177|      * Un-registers a WikiEventListener with this instance. This is a convenience method.
   178|      *
   179|      * @param listener the event listener
   180|      */
   181|     void removeWikiEventListener( final WikiEventListener listener );
   182|     /**
   183|      *  Fires a WikiSecurityEvent of the provided type, Principal and target Object to all registered listeners.
   184|      *
   185|      * @see org.apache.wiki.event.WikiSecurityEvent
   186|      * @param type       the event type to be fired
   187|      * @param principal  the subject of the event, which may be <code>null</code>
   188|      * @param target     the changed Object, which may be <code>null</code>


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/auth/DefaultAuthorizationManager.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 135-175 ---
   135|     /** {@inheritDoc} */
   136|     @Override
   137|     public Authorizer getAuthorizer() throws WikiSecurityException {
   138|         if ( m_authorizer != null ) {
   139|             return m_authorizer;
   140|         }
   141|         throw new WikiSecurityException( "Authorizer did not initialize properly. Check the logs." );
   142|     }
   143|     /** {@inheritDoc} */
   144|     @Override
   145|     public boolean hasRoleOrPrincipal( final Session session, final Principal principal ) {
   146|         if( session == null || principal == null ) {
   147|             return false;
   148|         }
   149|         if( AuthenticationManager.isRolePrincipal( principal ) ) {
   150|             return isUserInRole( session, principal );
   151|         }
   152|         if( session.isAuthenticated() && AuthenticationManager.isUserPrincipal( principal ) ) {
   153|             final String principalName = principal.getName();
   154|             final Principal[] userPrincipals = session.getPrincipals();
   155|             return Arrays.stream(userPrincipals).anyMatch(userPrincipal -> userPrincipal.getName().equals(principalName));
   156|         }
   157|         return false;
   158|     }
   159|     /** {@inheritDoc} */
   160|     @Override
   161|     public boolean hasAccess( final Context context, final HttpServletResponse response, final boolean redirect ) throws IOException {
   162|         final boolean allowed = checkPermission( context.getWikiSession(), context.requiredPermission() );
   163|         if ( context.getHttpRequest() != null && context.getHttpRequest().getAttribute( Context.ATTR_CONTEXT ) == null ) {
   164|             context.getHttpRequest().setAttribute( Context.ATTR_CONTEXT, context );
   165|         }
   166|         if( !allowed && redirect ) {
   167|             final ResourceBundle rb = Preferences.getBundle( context, InternationalizationManager.CORE_BUNDLE );
   168|             final Principal currentUser  = context.getWikiSession().getUserPrincipal();
   169|             final String pageurl = context.getPage().getName();
   170|             if( context.getWikiSession().isAuthenticated() ) {
   171|                 LOG.info( "User {} has no access - forbidden (permission={})", currentUser.getName(), context.requiredPermission() );
   172|                 context.getWikiSession().addMessage( MessageFormat.format( rb.getString( "security.error.noaccess.logged" ), context.getName()) );
   173|             } else {
   174|                 LOG.info( "User {} has no access - redirecting (permission={})", currentUser.getName(), context.requiredPermission() );
   175|                 context.getWikiSession().addMessage( MessageFormat.format( rb.getString( "security.error.noaccess" ), context.getName() ) );


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/auth/DefaultUserManager.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 340-380 ---
   340|      *  Even though this gets serialized whenever container shuts down/restarts, this gets reinstalled to the session when JSPWiki starts.
   341|      *  This means that it's not actually necessary to save anything.
   342|      */
   343|     public static final class JSONUserModule implements WikiAjaxServlet {
   344| 		private final DefaultUserManager m_manager;
   345|         /**
   346|          *  Create a new JSONUserModule.
   347|          *  @param mgr Manager
   348|          */
   349|         public JSONUserModule( final DefaultUserManager mgr )
   350|         {
   351|             m_manager = mgr;
   352|         }
   353|         @Override
   354|         public String getServletMapping() {
   355|         	return JSON_USERS;
   356|         }
   357|         @Override
   358|         public void service( final HttpServletRequest req, final HttpServletResponse resp, final String actionName, final List<String> params) throws ServletException, IOException {
   359|         	try {
   360|             	if( params.isEmpty() ) {
   361|             		return;
   362|             	}
   363|         		final String uid = params.get(0);
   364| 	        	LOG.debug("uid="+uid);
   365| 	        	if (StringUtils.isNotBlank(uid)) {
   366| 		            final UserProfile prof = getUserInfo(uid);
   367| 		            resp.getWriter().write(AjaxUtil.toJson(prof));
   368| 	        	}
   369|         	} catch (final NoSuchPrincipalException e) {
   370|         		throw new ServletException(e);
   371|         	}
   372|         }
   373|         /**
   374|          *  Directly returns the UserProfile object attached to an uid.
   375|          *
   376|          *  @param uid The user id (e.g. WikiName)
   377|          *  @return A UserProfile object
   378|          *  @throws NoSuchPrincipalException If such a name does not exist.
   379|          */
   380|         public UserProfile getUserInfo( final String uid ) throws NoSuchPrincipalException {


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/auth/SessionMonitor.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 18-58 ---
    18| import org.apache.logging.log4j.LogManager;
    19| import org.apache.logging.log4j.Logger;
    20| import org.apache.wiki.api.core.Engine;
    21| import org.apache.wiki.api.core.Session;
    22| import org.apache.wiki.api.spi.Wiki;
    23| import org.apache.wiki.event.WikiEventListener;
    24| import org.apache.wiki.event.WikiEventManager;
    25| import org.apache.wiki.event.WikiSecurityEvent;
    26| import org.apache.wiki.util.comparators.PrincipalComparator;
    27| import javax.servlet.http.HttpServletRequest;
    28| import javax.servlet.http.HttpSession;
    29| import javax.servlet.http.HttpSessionEvent;
    30| import javax.servlet.http.HttpSessionListener;
    31| import java.security.Principal;
    32| import java.util.ArrayList;
    33| import java.util.Arrays;
    34| import java.util.Collection;
    35| import java.util.Map;
    36| import java.util.WeakHashMap;
    37| import java.util.concurrent.ConcurrentHashMap;
    38| import java.util.stream.Collectors;
    39| /**
    40|  *  <p>Manages Sessions for different Engines.</p>
    41|  *  <p>The Sessions are stored both in the remote user HttpSession and in the SessionMonitor for the Engine.
    42|  *  This class must be configured as a session listener in the web.xml for the wiki web application.</p>
    43|  */
    44| public class SessionMonitor implements HttpSessionListener {
    45|     private static final Logger LOG = LogManager.getLogger( SessionMonitor.class );
    46|     /** Map with Engines as keys, and SessionMonitors as values. */
    47|     private static final ConcurrentHashMap< Engine, SessionMonitor > c_monitors = new ConcurrentHashMap<>();
    48|     /** Weak hashmap with HttpSessions as keys, and WikiSessions as values. */
    49|     private final Map< String, Session > m_sessions = new WeakHashMap<>();
    50|     private Engine m_engine;
    51|     private final PrincipalComparator m_comparator = new PrincipalComparator();
    52|     /**
    53|      * Returns the instance of the SessionMonitor for this wiki. Only one SessionMonitor exists per Engine.
    54|      *
    55|      * @param engine the wiki engine
    56|      * @return the session monitor
    57|      */
    58|     public static SessionMonitor getInstance( final Engine engine ) {

# --- HUNK 2: Lines 176-218 ---
   176|         }
   177|     }
   178|     /**
   179|      * Returns the current number of active wiki sessions.
   180|      * @return the number of sessions
   181|      */
   182|     public final int sessions()
   183|     {
   184|         return userPrincipals().length;
   185|     }
   186|     /**
   187|      * <p>Returns the current wiki users as a sorted array of Principal objects. The principals are those returned by
   188|      * each WikiSession's {@link Session#getUserPrincipal()}'s method.</p>
   189|      * <p>To obtain the list of current WikiSessions, we iterate through our session Map and obtain the list of values,
   190|      * which are WikiSessions wrapped in {@link java.lang.ref.WeakReference} objects. Those <code>WeakReference</code>s
   191|      * whose <code>get()</code> method returns non-<code>null</code> values are valid sessions.</p>
   192|      *
   193|      * @return the array of user principals
   194|      */
   195|     public final Principal[] userPrincipals() {
   196|         final Collection<Principal> principals;
   197|         synchronized ( m_sessions ) {
   198|             principals = m_sessions.values().stream().map(Session::getUserPrincipal).collect(Collectors.toList());
   199|         }
   200|         final Principal[] p = principals.toArray( new Principal[0] );
   201|         Arrays.sort( p, m_comparator );
   202|         return p;
   203|     }
   204|     /**
   205|      * Registers a WikiEventListener with this instance.
   206|      *
   207|      * @param listener the event listener
   208|      * @since 2.4.75
   209|      */
   210|     public final synchronized void addWikiEventListener( final WikiEventListener listener ) {
   211|         WikiEventManager.addWikiEventListener( this, listener );
   212|     }
   213|     /**
   214|      * Un-registers a WikiEventListener with this instance.
   215|      *
   216|      * @param listener the event listener
   217|      * @since 2.4.75
   218|      */


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/auth/acl/AclEntryImpl.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 4-44 ---
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.  
    16|  */
    17| package org.apache.wiki.auth.acl;
    18| import org.apache.wiki.auth.permissions.PagePermission;
    19| import java.io.Serializable;
    20| import java.security.Permission;
    21| import java.security.Principal;
    22| import java.util.Enumeration;
    23| import java.util.Vector;
    24| import java.util.stream.Collectors;
    25| /**
    26|  * Implementation of a JSPWiki AclEntry.
    27|  *
    28|  * @since 2.3
    29|  */
    30| public class AclEntryImpl implements AclEntry, Serializable {
    31|     private static final long serialVersionUID = 1L;
    32|     private final Vector< Permission > m_permissions = new Vector<>();
    33|     private Principal m_principal;
    34|     /**
    35|      * Constructs a new AclEntryImpl instance.
    36|      */
    37|     public AclEntryImpl() {
    38|     }
    39|     /**
    40|      * Adds the specified permission to this ACL entry. The permission <em>must</em> be of type
    41|      * {@link org.apache.wiki.auth.permissions.PagePermission}. Note: An entry can have multiple permissions.
    42|      *
    43|      * @param permission the permission to be associated with the principal in this entry
    44|      * @return <code>true</code> if the permission was added, <code>false</code> if the permission was

# --- HUNK 2: Lines 102-131 ---
   102|      *
   103|      * @param user the principal to be set for this entry
   104|      * @return true if the principal is set, false if there was already a
   105|      * principal set for this entry
   106|      */
   107|     @Override
   108|     public synchronized boolean setPrincipal(final Principal user ) {
   109|         if( m_principal != null || user == null ) {
   110|             return false;
   111|         }
   112|         m_principal = user;
   113|         return true;
   114|     }
   115|     /**
   116|      * Returns a string representation of the contents of this ACL entry.
   117|      *
   118|      * @return a string representation of the contents.
   119|      */
   120|     public String toString() {
   121|         final Principal p = getPrincipal();
   122|         return m_permissions.stream().map(pp -> pp.toString() + ",").collect(Collectors.joining("", "[AclEntry ALLOW " + (p != null ? p.getName() : "null") + " ", "]"));
   123|     }
   124|     /**
   125|      * Looks through the permission list and finds a permission that matches the
   126|      * permission.
   127|      */
   128|     private Permission findPermission( final Permission p ) {
   129|         return m_permissions.stream().filter(pp -> pp.implies(p)).findFirst().orElse(null);
   130|     }
   131| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/auth/acl/AclImpl.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 77-117 ---
    77|         }
    78|         if( hasEntry( entry ) ) {
    79|             return false;
    80|         }
    81|         m_entries.add( entry );
    82|         return true;
    83|     }
    84|     /** {@inheritDoc} */
    85|     @Override
    86|     public synchronized boolean removeEntry( final AclEntry entry ) {
    87|         return m_entries.remove( entry );
    88|     }
    89|     /** {@inheritDoc} */
    90|     @Override
    91|     public Enumeration< AclEntry > aclEntries() {
    92|         return m_entries.elements();
    93|     }
    94|     /** {@inheritDoc} */
    95|     @Override
    96|     public AclEntry getAclEntry( final Principal principal ) {
    97|         return m_entries.stream().filter(entry -> entry.getPrincipal().getName().equals(principal.getName())).findFirst().orElse(null);
    98|     }
    99|     /** {@inheritDoc} */
   100|     @Override
   101|     public boolean isEmpty() {
   102|         return m_entries.isEmpty();
   103|     }
   104|     /** {@inheritDoc} */
   105|     @Override
   106|     public String toString() {
   107|         final StringBuilder sb = new StringBuilder();
   108|         for( final AclEntry entry : m_entries ) {
   109|             final Principal pal = entry.getPrincipal();
   110|             if( pal != null ) {
   111|                 sb.append( "  user = " ).append( pal.getName() ).append( ": " );
   112|             } else {
   113|                 sb.append( "  user = null: " );
   114|             }
   115|             sb.append( "(" );
   116|             for( final Enumeration< Permission > perms = entry.permissions(); perms.hasMoreElements(); ) {
   117|                 final Permission perm = perms.nextElement();


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/auth/authorize/DefaultGroupManager.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 21-61 ---
    21| import org.apache.wiki.api.core.Context;
    22| import org.apache.wiki.api.core.Engine;
    23| import org.apache.wiki.api.core.Session;
    24| import org.apache.wiki.api.exceptions.NoRequiredPropertyException;
    25| import org.apache.wiki.api.exceptions.WikiException;
    26| import org.apache.wiki.auth.AuthenticationManager;
    27| import org.apache.wiki.auth.Authorizer;
    28| import org.apache.wiki.auth.GroupPrincipal;
    29| import org.apache.wiki.auth.NoSuchPrincipalException;
    30| import org.apache.wiki.auth.UserManager;
    31| import org.apache.wiki.auth.WikiPrincipal;
    32| import org.apache.wiki.auth.WikiSecurityException;
    33| import org.apache.wiki.auth.user.UserProfile;
    34| import org.apache.wiki.event.WikiEvent;
    35| import org.apache.wiki.event.WikiEventListener;
    36| import org.apache.wiki.event.WikiEventManager;
    37| import org.apache.wiki.event.WikiSecurityEvent;
    38| import org.apache.wiki.ui.InputValidator;
    39| import org.apache.wiki.util.ClassUtil;
    40| import java.security.Principal;
    41| import java.util.Arrays;
    42| import java.util.HashMap;
    43| import java.util.HashSet;
    44| import java.util.Map;
    45| import java.util.Properties;
    46| import java.util.Set;
    47| import java.util.StringTokenizer;
    48| /**
    49|  * <p>
    50|  * Facade class for storing, retrieving and managing wiki groups on behalf of AuthorizationManager, JSPs and other presentation-layer
    51|  * classes. GroupManager works in collaboration with a back-end {@link GroupDatabase}, which persists groups to permanent storage.
    52|  * </p>
    53|  * <p>
    54|  * <em>Note: prior to JSPWiki 2.4.19, GroupManager was an interface; it is now a concrete, final class. The aspects of GroupManager
    55|  * which previously extracted group information from storage (e.g., wiki pages) have been refactored into the GroupDatabase interface.</em>
    56|  * </p>
    57|  * @since 2.4.19
    58|  */
    59| public class DefaultGroupManager implements GroupManager, Authorizer, WikiEventListener {
    60|     private static final Logger LOG = LogManager.getLogger( DefaultGroupManager.class );
    61|     protected Engine m_engine;

# --- HUNK 2: Lines 132-172 ---
   132|         final Group[] groups = m_groupDatabase.groups();
   133|         synchronized( m_groups ) {
   134|             for( final Group group : groups ) {
   135|                 m_groups.put( group.getPrincipal(), group );
   136|                 fireEvent( WikiSecurityEvent.GROUP_ADD, group );
   137|             }
   138|         }
   139|         engine.getManager( UserManager.class ).addWikiEventListener( this );
   140|         LOG.info( "Authorizer GroupManager initialized successfully; loaded " + groups.length + " group(s)." );
   141|     }
   142|     /** {@inheritDoc} */
   143|     @Override
   144|     public boolean isUserInRole( final Session session, final Principal role ) {
   145|         if ( session == null || !( role instanceof GroupPrincipal ) || !session.isAuthenticated() ) {
   146|             return false;
   147|         }
   148|         final Group group = m_groups.get( role );
   149|         if( group == null ) {
   150|             return false;
   151|         }
   152|         return Arrays.stream(session.getPrincipals()).anyMatch(principal -> AuthenticationManager.isUserPrincipal(principal) && group.isMember(principal));
   153|     }
   154|     /** {@inheritDoc} */
   155|     @Override
   156|     public Group parseGroup( String name, String memberLine, final boolean create ) throws WikiSecurityException {
   157|         if( name == null ) {
   158|             if( create ) {
   159|                 name = "MyGroup";
   160|             } else {
   161|                 throw new WikiSecurityException( "Group name cannot be blank." );
   162|             }
   163|         } else if( ArrayUtils.contains( Group.RESTRICTED_GROUPNAMES, name ) ) {
   164|             throw new WikiSecurityException( "Illegal group name: " + name );
   165|         }
   166|         name = name.trim();
   167|         if( InputValidator.isBlank( memberLine ) ) {
   168|             memberLine = "";
   169|         }
   170|         memberLine = memberLine.trim();
   171|         final Group group = new Group( name, m_engine.getApplicationName() );
   172|         try {


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/auth/authorize/Group.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 98-147 ---
    98|     /**
    99|      * Two DefaultGroups are equal if they contain identical member Principals
   100|      * and have the same name.
   101|      * @param o the object to compare
   102|      * @return the comparison
   103|      */
   104|     @Override
   105|     public boolean equals( final Object o ) {
   106|         if( !( o instanceof Group ) ) {
   107|             return false;
   108|         }
   109|         final Group g = ( Group )o; // Just a shortcut.
   110|         if( g.m_members.size() != m_members.size() ) {
   111|             return false;
   112|         }
   113|         if( getName() != null && !getName().equals( g.getName() ) ) {
   114|             return false;
   115|         } else if( getName() == null && g.getName() != null ) {
   116|             return false;
   117|         }
   118|         return m_members.stream().allMatch(g::isMember);
   119|     }
   120|     /**
   121|      *  The hashcode is calculated as a XOR sum over all members of the Group.
   122|      *
   123|      *  @return the hash code
   124|      */
   125|     @Override
   126|     public int hashCode() {
   127|         return m_members.stream().mapToInt(Principal::hashCode).reduce(0, (a, b) -> a ^ b);
   128|     }
   129|     /**
   130|      * Returns the creation date.
   131|      *
   132|      * @return the creation date
   133|      */
   134|     public synchronized Date getCreated() {
   135|         return m_created;
   136|     }
   137|     /**
   138|      * Returns the creator of this Group.
   139|      *
   140|      * @return the creator
   141|      */
   142|     public final synchronized String getCreator() {
   143|         return m_creator;
   144|     }
   145|     /**
   146|      * Returns the last-modified date.
   147|      *

# --- HUNK 2: Lines 238-260 ---
   238|     }
   239|     /**
   240|      * Sets the name of the user who last modified this group.
   241|      *
   242|      * @param modifier the modifier
   243|      */
   244|     public final synchronized void setModifier( final String modifier ) {
   245|         this.m_modifier = modifier;
   246|     }
   247|     /**
   248|      * Returns a string representation of the Group.
   249|      *
   250|      * @return the string
   251|      * @see java.lang.Object#toString()
   252|      */
   253|     @Override
   254|     public String toString() {
   255|         return "(Group " + getName() + ")";
   256|     }
   257|     private Principal findMember( final String name ) {
   258|         return m_members.stream().filter(member -> member.getName().equals(name)).findFirst().orElse(null);
   259|     }
   260| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/auth/authorize/WebContainerAuthorizer.java
# Total hunks: 5
# ====================================================================
# --- HUNK 1: Lines 18-63 ---
    18| import org.apache.logging.log4j.LogManager;
    19| import org.apache.logging.log4j.Logger;
    20| import org.apache.wiki.InternalWikiException;
    21| import org.apache.wiki.api.core.Engine;
    22| import org.apache.wiki.api.core.Session;
    23| import org.jdom2.Document;
    24| import org.jdom2.Element;
    25| import org.jdom2.JDOMException;
    26| import org.jdom2.Namespace;
    27| import org.jdom2.filter.Filters;
    28| import org.jdom2.input.SAXBuilder;
    29| import org.jdom2.input.sax.XMLReaders;
    30| import org.jdom2.xpath.XPathFactory;
    31| import org.xml.sax.EntityResolver;
    32| import org.xml.sax.InputSource;
    33| import org.xml.sax.SAXException;
    34| import javax.servlet.http.HttpServletRequest;
    35| import java.io.IOException;
    36| import java.net.URL;
    37| import java.security.Principal;
    38| import java.util.Arrays;
    39| import java.util.HashSet;
    40| import java.util.List;
    41| import java.util.Properties;
    42| import java.util.Set;
    43| import java.util.stream.Collectors;
    44| /**
    45|  * Authorizes users by delegating role membership checks to the servlet container. In addition to implementing
    46|  * methods for the <code>Authorizer</code> interface, this class also provides a convenience method
    47|  * {@link #isContainerAuthorized()} that queries the web application descriptor to determine if the container
    48|  * manages authorization.
    49|  *
    50|  * @since 2.3
    51|  */
    52| public class WebContainerAuthorizer implements WebAuthorizer  {
    53|     private static final String J2EE_SCHEMA_25_NAMESPACE = "http://xmlns.jcp.org/xml/ns/javaee";
    54|     private static final Logger LOG = LogManager.getLogger( WebContainerAuthorizer.class );
    55|     protected Engine m_engine;
    56|     /**
    57|      * A lazily-initialized array of Roles that the container knows about. These
    58|      * are parsed from JSPWiki's <code>web.xml</code> web application
    59|      * deployment descriptor. If this file cannot be read for any reason, the
    60|      * role list will be empty. This is a hack designed to get around the fact
    61|      * that we have no direct way of querying the web container about which
    62|      * roles it manages.
    63|      */

# --- HUNK 2: Lines 84-124 ---
    84|         try {
    85|             m_webxml = getWebXml();
    86|             if( m_webxml != null ) {
    87|                 m_webxml.getRootElement().setNamespace( Namespace.getNamespace( J2EE_SCHEMA_25_NAMESPACE ) );
    88|                 m_containerAuthorized = isConstrained( "/Delete.jsp", Role.ALL ) && isConstrained( "/Login.jsp", Role.ALL );
    89|             }
    90|             if( m_containerAuthorized ) {
    91|                 m_containerRoles = getRoles( m_webxml );
    92|                 LOG.info( "JSPWiki is using container-managed authentication." );
    93|             } else {
    94|                 LOG.info( "JSPWiki is using custom authentication." );
    95|             }
    96|         } catch( final IOException e ) {
    97|             LOG.error( "Initialization failed: ", e );
    98|             throw new InternalWikiException( e.getClass().getName() + ": " + e.getMessage(), e );
    99|         } catch( final JDOMException e ) {
   100|             LOG.error( "Malformed XML in web.xml", e );
   101|             throw new InternalWikiException( e.getClass().getName() + ": " + e.getMessage(), e );
   102|         }
   103|         if( m_containerRoles.length > 0 ) {
   104|             final String roles = Arrays.stream(m_containerRoles).map(containerRole -> containerRole + " ").collect(Collectors.joining());
   105|             LOG.info( " JSPWiki determined the web container manages these roles: " + roles );
   106|         }
   107|         LOG.info( "Authorizer WebContainerAuthorizer initialized successfully." );
   108|     }
   109|     /**
   110|      * Determines whether a user associated with an HTTP request possesses
   111|      * a particular role. This method simply delegates to
   112|      * {@link javax.servlet.http.HttpServletRequest#isUserInRole(String)}
   113|      * by converting the Principal's name to a String.
   114|      * @param request the HTTP request
   115|      * @param role the role to check
   116|      * @return <code>true</code> if the user is considered to be in the role, <code>false</code> otherwise
   117|      */
   118|     @Override
   119|     public boolean isUserInRole( final HttpServletRequest request, final Principal role ) {
   120|         return request.isUserInRole( role.getName() );
   121|     }
   122|     /**
   123|      * Determines whether the Subject associated with a Session is in a
   124|      * particular role. This method takes two parameters: the Session

# --- HUNK 3: Lines 141-181 ---
   141|      * @return <code>true</code> if the user is considered to be in the role, <code>false</code> otherwise
   142|      * @see org.apache.wiki.auth.Authorizer#isUserInRole(org.apache.wiki.api.core.Session, java.security.Principal)
   143|      */
   144|     @Override
   145|     public boolean isUserInRole( final Session session, final Principal role ) {
   146|         if( session == null || role == null ) {
   147|             return false;
   148|         }
   149|         return session.hasPrincipal( role );
   150|     }
   151|     /**
   152|      * Looks up and returns a Role Principal matching a given String. If the
   153|      * Role does not match one of the container Roles identified during
   154|      * initialization, this method returns <code>null</code>.
   155|      * @param role the name of the Role to retrieve
   156|      * @return a Role Principal, or <code>null</code>
   157|      * @see org.apache.wiki.auth.Authorizer#initialize(Engine, Properties)
   158|      */
   159|     @Override
   160|     public Principal findRole( final String role ) {
   161|         return Arrays.stream(m_containerRoles).filter(containerRole -> containerRole.getName().equals(role)).findFirst().map(containerRole -> containerRole).orElse(null);
   162|     }
   163|     /**
   164|      * <p>
   165|      * Protected method that identifies whether a particular webapp URL is
   166|      * constrained to a particular Role. The resource is considered constrained
   167|      * if:
   168|      * </p>
   169|      * <ul>
   170|      * <li>the web application deployment descriptor contains a
   171|      * <code>security-constraint</code> with a child
   172|      * <code>web-resource-collection/url-pattern</code> element matching the
   173|      * URL, <em>and</em>:</li>
   174|      * <li>this constraint also contains an
   175|      * <code>auth-constraint/role-name</code> element equal to the supplied
   176|      * Role's <code>getName()</code> method. If the supplied Role is Role.ALL,
   177|      * it matches all roles</li>
   178|      * </ul>
   179|      * @param url the web resource
   180|      * @param role the role
   181|      * @return <code>true</code> if the resource is constrained to the role,

# --- HUNK 4: Lines 184-224 ---
   184|     public boolean isConstrained( final String url, final Role role ) {
   185|         final Element root = m_webxml.getRootElement();
   186|         final Namespace jeeNs = Namespace.getNamespace( "j", J2EE_SCHEMA_25_NAMESPACE );
   187|         final String constrainsSelector = "//j:web-app/j:security-constraint[j:web-resource-collection/j:url-pattern=\"" + url + "\"]";
   188|         final List< Element > constraints = XPathFactory.instance()
   189|                                                         .compile( constrainsSelector, Filters.element(), null, jeeNs )
   190|                                                         .evaluate( root );
   191|         final String rolesSelector = "//j:web-app/j:security-constraint[j:auth-constraint/j:role-name=\"" + role.getName() + "\"]";
   192|         final List< Element > roles = XPathFactory.instance()
   193|                                                   .compile( rolesSelector, Filters.element(), null, jeeNs )
   194|                                                   .evaluate( root );
   195|         if( constraints.size() == 0 ) {
   196|             return false;
   197|         }
   198|         if( role.equals( Role.ALL ) ) {
   199|             return true;
   200|         }
   201|         if( roles.size() == 0 ) {
   202|             return false;
   203|         }
   204|         return constraints.stream().anyMatch(constraint -> roles.stream().anyMatch(constraint::equals));
   205|     }
   206|     /**
   207|      * Returns <code>true</code> if the web container is configured to protect
   208|      * certain JSPWiki resources by requiring authentication. Specifically, this
   209|      * method parses JSPWiki's web application descriptor (<code>web.xml</code>)
   210|      * and identifies whether the string representation of
   211|      * {@link org.apache.wiki.auth.authorize.Role#AUTHENTICATED} is required
   212|      * to access <code>/Delete.jsp</code> and <code>LoginRedirect.jsp</code>.
   213|      * If the administrator has uncommented the large
   214|      * <code>&lt;security-constraint&gt;</code> section of <code>web.xml</code>,
   215|      * this will be true. This is admittedly an indirect way to go about it, but
   216|      * it should be an accurate test for default installations, and also in 99%
   217|      * of customized installations.
   218|      *
   219|      * @return <code>true</code> if the container protects resources, <code>false</code> otherwise
   220|      */
   221|     public boolean isContainerAuthorized()
   222|     {
   223|         return m_containerAuthorized;
   224|     }

# --- HUNK 5: Lines 228-275 ---
   228|      * the logical roles enumerated in the <code>web.xml</code>.
   229|      * This method actually returns a defensive copy of an internally stored
   230|      * array.
   231|      *
   232|      * @return an array of Principals representing the roles
   233|      */
   234|     @Override
   235|     public Principal[] getRoles()
   236|     {
   237|         return m_containerRoles.clone();
   238|     }
   239|     /**
   240|      * Protected method that extracts the roles from JSPWiki's web application
   241|      * deployment descriptor. Each Role is constructed by using the String
   242|      * representation of the Role, for example
   243|      * <code>new Role("Administrator")</code>.
   244|      * @param webxml the web application deployment descriptor
   245|      * @return an array of Role objects
   246|      */
   247|     protected Role[] getRoles( final Document webxml ) {
   248|         final Set<Role> roles;
   249|         final Element root = webxml.getRootElement();
   250|         final Namespace jeeNs = Namespace.getNamespace( "j", J2EE_SCHEMA_25_NAMESPACE );
   251|         final String constrainsSelector = "//j:web-app/j:security-constraint/j:auth-constraint/j:role-name";
   252|         final List< Element > constraints = XPathFactory.instance()
   253|                                                         .compile( constrainsSelector, Filters.element(), null, jeeNs )
   254|                                                         .evaluate( root );
   255|         roles = constraints.stream().map(Element::getTextTrim).map(Role::new).collect(Collectors.toSet());
   256|         final String rolesSelector = "//j:web-app/j:security-role/j:role-name";
   257|         final List< Element > nodes = XPathFactory.instance()
   258|                                                   .compile( rolesSelector, Filters.element(), null, jeeNs )
   259|                                                   .evaluate( root );
   260|         for( final Element node : nodes ) {
   261|             final String role = node.getTextTrim();
   262|             roles.add( new Role( role ) );
   263|         }
   264|         return roles.toArray( new Role[0] );
   265|     }
   266|     /**
   267|      * Returns an {@link org.jdom2.Document} representing JSPWiki's web
   268|      * application deployment descriptor. The document is obtained by calling
   269|      * the servlet context's <code>getResource()</code> method and requesting
   270|      * <code>/WEB-INF/web.xml</code>. For non-servlet applications, this
   271|      * method calls this class'
   272|      * {@link ClassLoader#getResource(java.lang.String)} and requesting
   273|      * <code>WEB-INF/web.xml</code>.
   274|      * @return the descriptor
   275|      * @throws IOException if the deployment descriptor cannot be found or opened


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/auth/permissions/GroupPermission.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 408-432 ---
   408|      *         GroupPrincipal matching the implied GroupPermission&#8217;s group;
   409|      *         <code>false</code> otherwise
   410|      */
   411|     boolean impliesMember(final Permission permission )
   412|     {
   413|         if ( !( permission instanceof GroupPermission ) )
   414|         {
   415|             return false;
   416|         }
   417|         final GroupPermission gp = (GroupPermission) permission;
   418|         if ( !MEMBER_TOKEN.equals( m_group ) )
   419|         {
   420|             return false;
   421|         }
   422|         final AccessControlContext acc = AccessController.getContext();
   423|         final DomainCombiner dc = acc.getDomainCombiner();
   424|         if ( dc != null && dc instanceof SubjectDomainCombiner )
   425|         {
   426|             final Subject subject = ( (SubjectDomainCombiner) dc ).getSubject();
   427|             final Set<GroupPrincipal> principals = subject.getPrincipals( GroupPrincipal.class );
   428|             return principals.stream().anyMatch(principal -> principal.getName().equals(gp.m_group));
   429|         }
   430|         return false;
   431|     }
   432| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/auth/user/XMLUserDatabase.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 31-72 ---
    31| import org.xml.sax.SAXException;
    32| import javax.xml.parsers.DocumentBuilderFactory;
    33| import javax.xml.parsers.ParserConfigurationException;
    34| import java.io.BufferedWriter;
    35| import java.io.File;
    36| import java.io.FileNotFoundException;
    37| import java.io.IOException;
    38| import java.io.OutputStreamWriter;
    39| import java.io.Serializable;
    40| import java.nio.charset.StandardCharsets;
    41| import java.nio.file.Files;
    42| import java.security.Principal;
    43| import java.text.DateFormat;
    44| import java.text.ParseException;
    45| import java.text.SimpleDateFormat;
    46| import java.util.Date;
    47| import java.util.Map;
    48| import java.util.Properties;
    49| import java.util.SortedSet;
    50| import java.util.TreeSet;
    51| import java.util.stream.Collectors;
    52| import java.util.stream.IntStream;
    53| /**
    54|  * <p>Manages {@link DefaultUserProfile} objects using XML files for persistence. Passwords are hashed using SHA1. User entries are simple
    55|  * <code>&lt;user&gt;</code> elements under the root. User profile properties are attributes of the element. For example:</p>
    56|  * <blockquote><code>
    57|  * &lt;users&gt;<br/>
    58|  * &nbsp;&nbsp;&lt;user loginName="janne" fullName="Janne Jalkanen"<br/>
    59|  * &nbsp;&nbsp;&nbsp;&nbsp;wikiName="JanneJalkanen" email="janne@ecyrd.com"<br/>
    60|  * &nbsp;&nbsp;&nbsp;&nbsp;password="{SHA}457b08e825da547c3b77fbc1ff906a1d00a7daee"/&gt;<br/>
    61|  * &lt;/users&gt;
    62|  * </code></blockquote>
    63|  * <p>In this example, the un-hashed password is <code>myP@5sw0rd</code>. Passwords are hashed without salt.</p>
    64|  * @since 2.3
    65|  */
    66| public class XMLUserDatabase extends AbstractUserDatabase {
    67|     /** The jspwiki.properties property specifying the file system location of the user database. */
    68|     public static final String  PROP_USERDATABASE = "jspwiki.xmlUserDatabaseFile";
    69|     private static final String DEFAULT_USERDATABASE = "userdatabase.xml";
    70|     private static final String ATTRIBUTES_TAG    = "attributes";
    71|     private static final String CREATED           = "created";
    72|     private static final String EMAIL             = "email";

# --- HUNK 2: Lines 303-343 ---
   303|                 setAttribute( user, LOGIN_NAME, newName );
   304|                 setAttribute( user, LAST_MODIFIED, c_format.format( modDate ) );
   305|                 profile.setLoginName( newName );
   306|                 profile.setLastModified( modDate );
   307|                 break;
   308|             }
   309|         }
   310|         saveDOM();
   311|     }
   312|     /** {@inheritDoc} */
   313|     @Override
   314|     public synchronized void save( final UserProfile profile ) throws WikiSecurityException {
   315|         if ( c_dom == null ) {
   316|             LOG.fatal( "Could not save profile " + profile + " database does not exist" );
   317|             throw new IllegalStateException( "FATAL: database does not exist" );
   318|         }
   319|         checkForRefresh();
   320|         final DateFormat c_format = new SimpleDateFormat( DATE_FORMAT );
   321|         final String index = profile.getLoginName();
   322|         final NodeList users = c_dom.getElementsByTagName( USER_TAG );
   323|         Element user = IntStream.range(0, users.getLength()).mapToObj(i -> (Element) users.item(i)).filter(currentUser -> currentUser.getAttribute(LOGIN_NAME).equals(index)).findFirst().orElse(null);
   324|         boolean isNew = false;
   325|         final Date modDate = new Date( System.currentTimeMillis() );
   326|         if( user == null ) {
   327|             profile.setCreated( modDate );
   328|             LOG.info( "Creating new user " + index );
   329|             user = c_dom.createElement( USER_TAG );
   330|             c_dom.getDocumentElement().appendChild( user );
   331|             setAttribute( user, CREATED, c_format.format( profile.getCreated() ) );
   332|             isNew = true;
   333|         } else {
   334|             final NodeList attributes = user.getElementsByTagName( ATTRIBUTES_TAG );
   335|             for( int i = 0; i < attributes.getLength(); i++ ) {
   336|                 user.removeChild( attributes.item( i ) );
   337|             }
   338|         }
   339|         setAttribute( user, UID, profile.getUid() );
   340|         setAttribute( user, LAST_MODIFIED, c_format.format( modDate ) );
   341|         setAttribute( user, LOGIN_NAME, profile.getLoginName() );
   342|         setAttribute( user, FULL_NAME, profile.getFullname() );
   343|         setAttribute( user, WIKI_NAME, profile.getWikiName() );

# --- HUNK 3: Lines 419-464 ---
   419|                     final String serializedMap = extractText( attribute );
   420|                     try {
   421|                         final Map< String, ? extends Serializable > map = Serializer.deserializeFromBase64( serializedMap );
   422|                         profile.getAttributes().putAll( map );
   423|                     } catch( final IOException e ) {
   424|                         LOG.error( "Could not parse user profile attributes!", e );
   425|                     }
   426|                 }
   427|                 return profile;
   428|             }
   429|         }
   430|         return null;
   431|     }
   432|     /**
   433|      * Extracts all the text nodes that are immediate children of an Element.
   434|      *
   435|      * @param element the base element
   436|      * @return the text nodes that are immediate children of the base element, concatenated together
   437|      */
   438|     private String extractText( final Element element ) {
   439|         String text = "";
   440|         if( element.getChildNodes().getLength() > 0 ) {
   441|             final NodeList children = element.getChildNodes();
   442|             text = IntStream.range(0, children.getLength()).mapToObj(children::item).filter(child -> child.getNodeType() == Node.TEXT_NODE).map(child -> ((Text) child).getData()).collect(Collectors.joining());
   443|         }
   444|         return text;
   445|     }
   446|     /**
   447|      *  Tries to parse a date using the default format - then, for backwards compatibility reasons, tries the platform default.
   448|      *
   449|      *  @param profile profile associated to the date.
   450|      *  @param date date to be parsed.
   451|      *  @return A parsed date, or null, if both parse attempts fail.
   452|      */
   453|     private Date parseDate( final UserProfile profile, final String date ) {
   454|         try {
   455|             final DateFormat c_format = new SimpleDateFormat( DATE_FORMAT );
   456|             return c_format.parse( date );
   457|         } catch( final ParseException e ) {
   458|             try {
   459|                 return DateFormat.getDateTimeInstance().parse( date );
   460|             } catch( final ParseException e2 ) {
   461|                 LOG.warn( "Could not parse 'created' or 'lastModified' attribute for profile '" + profile.getLoginName() + "'." +
   462|                           " It may have been tampered with.", e2 );
   463|             }
   464|         }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/content/DefaultPageRenamer.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 124-264 ---
   124|     }
   125|     /**
   126|      *  This method finds all the pages which have anything to do with the fromPage and
   127|      *  change any referrers it can figure out in that page.
   128|      *  
   129|      *  @param context WikiContext in which we operate
   130|      *  @param fromPage The old page
   131|      *  @param toPage The new page
   132|      */
   133|     private void updateReferrers( final Context context, final Page fromPage, final Page toPage, final Set< String > referrers ) {
   134|         if( referrers.isEmpty() ) { // No referrers
   135|             return;
   136|         }
   137|         final Engine engine = context.getEngine();
   138|         for( String pageName : referrers ) {
   139|             if( pageName.equals( fromPage.getName() ) ) {
   140|                 pageName = toPage.getName();
   141|             }
   142|             final Page p = engine.getManager( PageManager.class ).getPage( pageName );
   143|             final String sourceText = engine.getManager( PageManager.class ).getPureText( p );
   144|             String newText = replaceReferrerString(sourceText, fromPage.getName(), toPage.getName() );
   145|             m_camelCase = TextUtil.getBooleanProperty( engine.getWikiProperties(), MarkupParser.PROP_CAMELCASELINKS, m_camelCase );
   146|             if( m_camelCase ) {
   147|                 newText = replaceCCReferrerString(newText, fromPage.getName(), toPage.getName() );
   148|             }
   149|             if( !sourceText.equals( newText ) ) {
   150|                 p.setAttribute( Page.CHANGENOTE, fromPage.getName()+" ==> "+toPage.getName() );
   151|                 p.setAuthor( context.getCurrentUser().getName() );
   152|                 try {
   153|                     engine.getManager( PageManager.class ).putPageText( p, newText );
   154|                     engine.getManager( ReferenceManager.class ).updateReferences( p );
   155|                 } catch( final ProviderException e ) {
   156|                     LOG.error("Unable to perform rename.",e);
   157|                 }
   158|             }
   159|         }
   160|     }
   161|     private Set<String> getReferencesToChange( final Page fromPage, final Engine engine ) {
   162|         final Set< String > referrers = new TreeSet<>();
   163|         final Collection< String > r = engine.getManager( ReferenceManager.class ).findReferrers( fromPage.getName() );
   164|         if( r != null ) {
   165|             referrers.addAll( r );
   166|         }
   167|         try {
   168|             final List< Attachment > attachments = engine.getManager( AttachmentManager.class ).listAttachments( fromPage );
   169|             for( final Attachment att : attachments  ) {
   170|                 final Collection< String > c = engine.getManager( ReferenceManager.class ).findReferrers( att.getName() );
   171|                 if( c != null ) {
   172|                     referrers.addAll( c );
   173|                 }
   174|             }
   175|         } catch( final ProviderException e ) {
   176|             LOG.error( "Provider error while fetching attachments for rename", e );
   177|         }
   178|         return referrers;
   179|     }
   180|     /**
   181|      *  Replaces camelcase links.
   182|      */
   183|     private String replaceCCReferrerString( final String sourceText, final String from, final String to ) {
   184|         final StringBuilder sb = new StringBuilder( sourceText.length()+32 );
   185|         final Pattern linkPattern = Pattern.compile( "\\p{Lu}+\\p{Ll}+\\p{Lu}+[\\p{L}\\p{Digit}]*" );
   186|         final Matcher matcher = linkPattern.matcher( sourceText );
   187|         int start = 0;
   188|         while( matcher.find( start ) ) {
   189|             final String match = matcher.group();
   190|             sb.append( sourceText, start, matcher.start() );
   191|             final int lastOpenBrace = sourceText.lastIndexOf( '[', matcher.start() );
   192|             final int lastCloseBrace = sourceText.lastIndexOf( ']', matcher.start() );
   193|             if( match.equals( from ) && lastCloseBrace >= lastOpenBrace ) {
   194|                 sb.append( to );
   195|             } else {
   196|                 sb.append( match );
   197|             }
   198|             start = matcher.end();
   199|         }
   200|         sb.append( sourceText.substring( start ) );
   201|         return sb.toString();
   202|     }
   203|     private String replaceReferrerString(final String sourceText, final String from, final String to ) {
   204|         final StringBuilder sb = new StringBuilder( sourceText.length()+32 );
   205|         final Pattern linkPattern = Pattern.compile( "([\\[~]?)\\[([^|\\]]*)(\\|)?([^|\\]]*)(\\|)?([^|\\]]*)]" );
   206|         final Matcher matcher = linkPattern.matcher( sourceText );
   207|         int start = 0;
   208|         while( matcher.find( start ) ) {
   209|             char charBefore = (char)-1;
   210|             if( matcher.start() > 0 ) {
   211|                 charBefore = sourceText.charAt( matcher.start() - 1 );
   212|             }
   213|             if( !matcher.group(1).isEmpty() || charBefore == '~' || charBefore == '[' ) {
   214|                 sb.append( sourceText, start, matcher.end() );
   215|                 start = matcher.end();
   216|                 continue;
   217|             }
   218|             String text = matcher.group(2);
   219|             String link = matcher.group(4);
   220|             final String attr = matcher.group(6);
   221|             if( link.isEmpty() ) {
   222|                 text = replaceSingleLink(text, from, to );
   223|             } else {
   224|                 link = replaceSingleLink(link, from, to );
   225|                 text = TextUtil.replaceString( text, from, to );
   226|             }
   227|             sb.append( sourceText, start, matcher.start() );
   228|             sb.append( "[" ).append( text );
   229|             if( !link.isEmpty() ) {
   230|                 sb.append( "|" ).append( link );
   231|             }
   232|             if( !attr.isEmpty() ) {
   233|                 sb.append( "|" ).append( attr );
   234|             }
   235|             sb.append( "]" );
   236|             start = matcher.end();
   237|         }
   238|         sb.append( sourceText.substring( start ) );
   239|         return sb.toString();
   240|     }
   241|     /**
   242|      *  This method does a correct replacement of a single link, taking into account anchors and attachments.
   243|      */
   244|     private String replaceSingleLink(final String original, final String from, final String newlink ) {
   245|         final int hash = original.indexOf( '#' );
   246|         final int slash = original.indexOf( '/' );
   247|         String realLink = original;
   248|         if( hash != -1 ) {
   249|             realLink = original.substring( 0, hash );
   250|         }
   251|         if( slash != -1 ) {
   252|             realLink = original.substring( 0,slash );
   253|         }
   254|         realLink = MarkupParser.cleanLink( realLink );
   255|         final String oldStyleRealLink = MarkupParser.wikifyLink( realLink );
   256|         if( realLink.equals( from ) || original.equals( from ) || oldStyleRealLink.equals( from ) ) {
   257|             final int blank = realLink.indexOf( " ");
   258|             if( blank != -1 ) {
   259|                 return original + "|" + newlink;
   260|             }
   261|             return newlink + ( ( hash > 0 ) ? original.substring( hash ) : "" ) + ( ( slash > 0 ) ? original.substring( slash ) : "" ) ;
   262|         }
   263|         return original;
   264|     }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/diff/ContextualDiffProvider.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 16-60 ---
    16| */
    17| package org.apache.wiki.diff;
    18| import org.apache.logging.log4j.LogManager;
    19| import org.apache.logging.log4j.Logger;
    20| import org.apache.wiki.api.core.Context;
    21| import org.apache.wiki.api.core.Engine;
    22| import org.apache.wiki.api.exceptions.NoRequiredPropertyException;
    23| import org.apache.wiki.util.TextUtil;
    24| import org.suigeneris.jrcs.diff.Diff;
    25| import org.suigeneris.jrcs.diff.DifferentiationFailedException;
    26| import org.suigeneris.jrcs.diff.Revision;
    27| import org.suigeneris.jrcs.diff.RevisionVisitor;
    28| import org.suigeneris.jrcs.diff.delta.AddDelta;
    29| import org.suigeneris.jrcs.diff.delta.ChangeDelta;
    30| import org.suigeneris.jrcs.diff.delta.Chunk;
    31| import org.suigeneris.jrcs.diff.delta.DeleteDelta;
    32| import org.suigeneris.jrcs.diff.delta.Delta;
    33| import org.suigeneris.jrcs.diff.myers.MyersDiff;
    34| import java.io.IOException;
    35| import java.util.ArrayList;
    36| import java.util.Arrays;
    37| import java.util.List;
    38| import java.util.Properties;
    39| import java.util.StringTokenizer;
    40| import java.util.stream.Collectors;
    41| /**
    42|  * A seriously better diff provider, which highlights changes word-by-word using CSS.
    43|  *
    44|  * Suggested by John Volkar.
    45|  */
    46| public class ContextualDiffProvider implements DiffProvider {
    47|     private static final Logger LOG = LogManager.getLogger( ContextualDiffProvider.class );
    48|     /**
    49|      *  A jspwiki.properties value to define how many characters are shown around the change context.
    50|      *  The current value is <tt>{@value}</tt>.
    51|      */
    52|     public static final String PROP_UNCHANGED_CONTEXT_LIMIT = "jspwiki.contextualDiffProvider.unchangedContextLimit";
    53|     public boolean m_emitChangeNextPreviousHyperlinks = true;
    54|     public static String CHANGE_START_HTML = ""; //This could be a image '>' for a start marker
    55|     public static String CHANGE_END_HTML = ""; //and an image for an end '<' marker
    56|     public static String DIFF_START = "<div class=\"diff-wikitext\">";
    57|     public static String DIFF_END = "</div>";
    58|     public static String INSERTION_START_HTML = "<font color=\"#8000FF\"><span class=\"diff-insertion\">";
    59|     public static String INSERTION_END_HTML = "</span></font>";
    60|     public static String DELETION_START_HTML = "<strike><font color=\"red\"><span class=\"diff-deletion\">";

# --- HUNK 2: Lines 175-221 ---
   175|         /** Buffer to coalesce the changes together */
   176|         private StringBuffer m_origBuf;
   177|         private StringBuffer m_newBuf;
   178|         /** Reference to the source string array */
   179|         private final String[] m_origStrings;
   180|         private ChangeMerger( final StringBuffer sb, final String[] origStrings, final int max ) {
   181|             m_sb = sb;
   182|             m_origStrings = origStrings != null ? origStrings.clone() : null;
   183|             m_max = max;
   184|             m_origBuf = new StringBuffer();
   185|             m_newBuf = new StringBuffer();
   186|         }
   187|         private void updateState( final Delta delta ) {
   188|             m_index++;
   189|             final Chunk orig = delta.getOriginal();
   190|             if( orig.first() > m_firstElem ) {
   191|                 flushChanges();
   192|                 if( ( orig.first() - m_firstElem ) > 2 * m_unchangedContextLimit ) {
   193|                     if (m_firstElem > 0) {
   194|                         final int endIndex = Math.min( m_firstElem + m_unchangedContextLimit, m_origStrings.length -1 );
   195|                         m_sb.append(Arrays.stream(m_origStrings, m_firstElem, endIndex).collect(Collectors.joining("", "", ELIDED_TAIL_INDICATOR_HTML)));
   196|                     }
   197|                     m_sb.append( ELIDED_HEAD_INDICATOR_HTML );
   198|                     final int startIndex = Math.max(orig.first() - m_unchangedContextLimit, 0);
   199|                     m_sb.append(Arrays.stream(m_origStrings, startIndex, orig.first()).collect(Collectors.joining()));
   200|                 } else {
   201|                     m_sb.append(Arrays.stream(m_origStrings, m_firstElem, orig.first()).collect(Collectors.joining()));
   202|                 }
   203|             }
   204|             m_firstElem = orig.last() + 1;
   205|         }
   206|         @Override
   207|         public void visit( final Revision rev ) {
   208|         }
   209|         @Override
   210|         public void visit( final AddDelta delta ) {
   211|             updateState( delta );
   212|             if( m_mode == 1 ) {
   213|                 flushChanges();
   214|                 m_mode = -1;
   215|             }
   216|             if( m_mode == -1 ) {
   217|                 m_mode = 0;
   218|             }
   219|             if( m_mode == 0 || m_mode == 2 ) {
   220|                 addNew( delta.getRevised() );
   221|                 m_mode = 1;

# --- HUNK 3: Lines 234-276 ---
   234|         public void visit( final DeleteDelta delta ) {
   235|             updateState( delta );
   236|             if( m_mode == 0 ) {
   237|                 flushChanges();
   238|                 m_mode = -1;
   239|             }
   240|             if( m_mode == -1 ) {
   241|                 m_mode = 1;
   242|             }
   243|             if( m_mode == 1 || m_mode == 2 ) {
   244|                 addOrig( delta.getOriginal() );
   245|                 m_mode = 1;
   246|             }
   247|         }
   248|         public void shutdown() {
   249|             m_index = m_max + 1; // Make sure that no hyperlink gets created
   250|             flushChanges();
   251|             if( m_firstElem < m_origStrings.length ) {
   252|                 if( ( m_origStrings.length - m_firstElem ) > m_unchangedContextLimit ) {
   253|                     final int endIndex = Math.min( m_firstElem + m_unchangedContextLimit, m_origStrings.length -1 );
   254|                     m_sb.append(Arrays.stream(m_origStrings, m_firstElem, endIndex).collect(Collectors.joining("", "", ELIDED_TAIL_INDICATOR_HTML)));
   255|                 } else {
   256|                     m_sb.append(Arrays.stream(m_origStrings, m_firstElem, m_origStrings.length).collect(Collectors.joining()));
   257|                 }
   258|             }
   259|         }
   260|         private void addOrig( final Chunk chunk ) {
   261|             if( chunk != null ) {
   262|                 chunk.toString( m_origBuf );
   263|             }
   264|         }
   265|         private void addNew( final Chunk chunk ) {
   266|             if( chunk != null ) {
   267|                 chunk.toString( m_newBuf );
   268|             }
   269|         }
   270|         private void flushChanges() {
   271|             if( m_newBuf.length() + m_origBuf.length() > 0 ) {
   272|                 m_sb.append( CHANGE_START_HTML );
   273|                 if( m_emitChangeNextPreviousHyperlinks && m_count > 1 ) {
   274|                     m_sb.append( BACK_PRE_INDEX );
   275|                     m_sb.append( m_count - 1 );
   276|                     m_sb.append( BACK_POST_INDEX );


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/filters/ProfanityFilter.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 27-66 ---
    27| import java.util.ArrayList;
    28| import java.util.List;
    29| /**
    30|  *  This class is an example of how to have a simple filter.  It removes
    31|  *  all nasty words located at <code>profanity.properties</code> file, inside 
    32|  *  <code>org/apache/wiki/filters</code> package. The search of profanities
    33|  *  is case unsensitive.
    34|  *
    35|  */
    36| public class ProfanityFilter extends BasePageFilter {
    37|     private static final Logger LOG = LogManager.getLogger( ProfanityFilter.class );
    38|     private static final String PROPERTYFILE = "org/apache/wiki/filters/profanity.properties";
    39|     private static String[] c_profanities = new String[0];
    40|     static {
    41|         final ClassLoader loader = ProfanityFilter.class.getClassLoader();
    42|         try( final InputStream in = loader.getResourceAsStream( PROPERTYFILE ) ) {
    43|             if( in == null ) {
    44|                 throw new IOException( "No property file found! (Check the installation, it should be there.)" );
    45|             }
    46|             try( final BufferedReader br =  new BufferedReader( new InputStreamReader( in ) ) ) {
    47|                 c_profanities = br.lines().filter(str -> !str.isEmpty() && !str.startsWith("#")).toArray(String[]::new);
    48|             }
    49|         } catch( final IOException e ) {
    50|             LOG.error( "Unable to load profanities from " + PROPERTYFILE, e );
    51|         } catch( final Exception e ) {
    52|             LOG.error( "Unable to initialize Profanity Filter", e );
    53|         }
    54|     }
    55|     /**
    56|      *  {@inheritDoc}
    57|      */
    58|     @Override
    59|     public String preTranslate( final Context context, String content ) {
    60|         for( final String word : c_profanities ) {
    61|             final String replacement = word.charAt( 0 ) + "*" + word.charAt( word.length() - 1 );
    62|             content = TextUtil.replaceStringCaseUnsensitive( content, word, replacement );
    63|         }
    64|         return content;
    65|     }
    66| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/filters/SpamFilter.java
# Total hunks: 8
# ====================================================================
# --- HUNK 1: Lines 236-300 ---
   236|         switch( type ) {
   237|             case REJECT: reason = "REJECTED";
   238|                 break;
   239|             case ACCEPT: reason = "ACCEPTED";
   240|                 break;
   241|             case NOTE: reason = "NOTE";
   242|                 break;
   243|             default: throw new InternalWikiException( "Illegal type " + type );
   244|         }
   245|         C_SPAMLOG.info( reason + " " + source + " " + uid + " " + addr + " \"" + page + "\" " + message );
   246|         return uid;
   247|     }
   248|     /** {@inheritDoc} */
   249|     @Override
   250|     public String preSave( final Context context, final String content ) throws RedirectException {
   251|         cleanBanList();
   252|         refreshBlacklists( context );
   253|         final Change change = getChange( context, content );
   254|         if( !ignoreThisUser( context ) ) {
   255|             checkBanList( context, change );
   256|             checkSinglePageChange( context, change );
   257|             checkIPList( context );
   258|             checkPatternList( context, change );
   259|             checkPageName( context);
   260|         }
   261|         if( !m_stopAtFirstMatch ) {
   262|             final Integer score = context.getVariable( ATTR_SPAMFILTER_SCORE );
   263|             if( score != null && score >= m_scoreLimit ) {
   264|                 throw new RedirectException( "Herb says you got too many points", getRedirectPage( context ) );
   265|             }
   266|         }
   267|         log( context, ACCEPT, "-", change.toString() );
   268|         return content;
   269|     }
   270|     private void checkPageName(final Context context ) throws RedirectException {
   271|         final Page page = context.getPage();
   272|         final String pageName = page.getName();
   273|         final int maxlength = Integer.parseInt(m_pageNameMaxLength);
   274|         if ( pageName.length() > maxlength) {
   275|             final String uid = log( context, REJECT, REASON_PAGENAME_TOO_LONG + "(" + m_pageNameMaxLength + ")" , pageName);
   276|             LOG.info("SPAM:PageNameTooLong (" + uid + "). The length of the page name is too large (" + pageName.length() + " , limit is " + m_pageNameMaxLength + ")");
   277|             checkStrategy( context, "Herb says '" + pageName + "' is a bad pageName and I trust Herb! (Incident code " + uid + ")" );
   278|         }
   279|     }
   280|     private void checkStrategy(final Context context, final String message ) throws RedirectException {
   281|         if( m_stopAtFirstMatch ) {
   282|             throw new RedirectException( message, getRedirectPage( context ) );
   283|         }
   284|         Integer score = context.getVariable( ATTR_SPAMFILTER_SCORE );
   285|         if( score != null ) {
   286|             score = score + 1;
   287|         } else {
   288|             score = 1;
   289|         }
   290|         context.setVariable( ATTR_SPAMFILTER_SCORE, score );
   291|     }
   292|     /**
   293|      *  Parses a list of patterns and returns a Collection of compiled Pattern objects.
   294|      *
   295|      * @param source page containing the list of patterns.
   296|      * @param list list of patterns.
   297|      * @return A Collection of the Patterns that were found from the lists.
   298|      */
   299|     private Collection< Pattern > parseWordList( final Page source, final String list ) {
   300|         final ArrayList< Pattern > compiledpatterns = new ArrayList<>();

# --- HUNK 2: Lines 330-422 ---
   330|                     if( line.startsWith("#") ) continue; // It's a comment
   331|                     int ws = line.indexOf( ' ' );
   332|                     if( ws == -1 ) ws = line.indexOf( '\t' );
   333|                     if( ws != -1 ) line = line.substring( 0, ws );
   334|                     try {
   335|                         compiledpatterns.add( m_compiler.compile( line ) );
   336|                     } catch( final MalformedPatternException e ) {
   337|                         LOG.debug( "Malformed spam filter pattern " + line );
   338|                     }
   339|                 }
   340|             } catch( final IOException e ) {
   341|                 LOG.info( "Could not read patterns; returning what I got" , e );
   342|             }
   343|         }
   344|         return compiledpatterns;
   345|     }
   346|     /**
   347|      * Takes a single page change and performs a load of tests on the content change. An admin can modify anything.
   348|      *
   349|      * @param context page Context
   350|      * @param change page change
   351|      * @throws RedirectException spam filter rejects the page change.
   352|      */
   353|     private synchronized void checkSinglePageChange(final Context context, final Change change )
   354|     		throws RedirectException {
   355|         final HttpServletRequest req = context.getHttpRequest();
   356|         if( req != null ) {
   357|             final String addr = HttpUtil.getRemoteAddress( req );
   358|             int hostCounter = 0;
   359|             int changeCounter = 0;
   360|             LOG.debug( "Change is " + change.m_change );
   361|             final long time = System.currentTimeMillis() - 60*1000L; // 1 minute
   362|             for( final Iterator< Host > i = m_lastModifications.iterator(); i.hasNext(); ) {
   363|                 final Host host = i.next();
   364|                 if( host.getAddedTime() < time ) {
   365|                     LOG.debug( "Removed host " + host.getAddress() + " from modification queue (expired)" );
   366|                     i.remove();
   367|                     continue;
   368|                 }
   369|                 if( host.getAddress().equals( addr ) ) {
   370|                     hostCounter++;
   371|                 }
   372|                 if( host.getChange() != null && host.getChange().equals( change ) ) {
   373|                     changeCounter++;
   374|                 }
   375|             }
   376|             if( hostCounter >= m_limitSinglePageChanges ) {
   377|                 final Host host = new Host( addr, null );
   378|                 m_temporaryBanList.add( host );
   379|                 final String uid = log( context, REJECT, REASON_TOO_MANY_MODIFICATIONS, change.m_change );
   380|                 LOG.info( "SPAM:TooManyModifications (" + uid + "). Added host " + addr + " to temporary ban list for doing too many modifications/minute" );
   381|                 checkStrategy( context, "Herb says you look like a spammer, and I trust Herb! (Incident code " + uid + ")" );
   382|             }
   383|             if( changeCounter >= m_limitSimilarChanges ) {
   384|                 final Host host = new Host( addr, null );
   385|                 m_temporaryBanList.add( host );
   386|                 final String uid = log( context, REJECT, REASON_SIMILAR_MODIFICATIONS, change.m_change );
   387|                 LOG.info( "SPAM:SimilarModifications (" + uid + "). Added host " + addr + " to temporary ban list for doing too many similar modifications" );
   388|                 checkStrategy( context, "Herb says you look like a spammer, and I trust Herb! (Incident code "+uid+")");
   389|             }
   390|             String tstChange  = change.toString();
   391|             int urlCounter = 0;
   392|             while( m_matcher.contains( tstChange,m_urlPattern ) ) {
   393|                 final MatchResult m = m_matcher.getMatch();
   394|                 tstChange = tstChange.substring( m.endOffset(0) );
   395|                 urlCounter++;
   396|             }
   397|             if( urlCounter > m_maxUrls ) {
   398|                 final Host host = new Host( addr, null );
   399|                 m_temporaryBanList.add( host );
   400|                 final String uid = log( context, REJECT, REASON_TOO_MANY_URLS, change.toString() );
   401|                 LOG.info( "SPAM:TooManyUrls (" + uid + "). Added host " + addr + " to temporary ban list for adding too many URLs" );
   402|                 checkStrategy( context, "Herb says you look like a spammer, and I trust Herb! (Incident code " + uid + ")" );
   403|             }
   404|             checkBotTrap( context, change );
   405|             checkUTF8( context, change );
   406|             checkAkismet( context, change );
   407|             m_lastModifications.add( new Host( addr, change ) );
   408|         }
   409|     }
   410|     /**
   411|      *  Checks against the akismet system.
   412|      *
   413|      * @param context page Context
   414|      * @throws RedirectException spam filter rejects the page change.
   415|      */
   416|     private void checkAkismet( final Context context, final Change change ) throws RedirectException {
   417|         if( m_akismetAPIKey != null ) {
   418|             if( m_akismet == null ) {
   419|                 LOG.info( "Initializing Akismet spam protection." );
   420|                 m_akismet = new Akismet( m_akismetAPIKey, context.getEngine().getBaseURL() );
   421|                 if( !m_akismet.verifyAPIKey() ) {
   422|                     LOG.error( "Akismet API key cannot be verified.  Please check your config." );

# --- HUNK 3: Lines 438-546 ---
   438|                 final String permalink     = context.getViewURL( context.getPage().getName() );
   439|                 final String commentType   = context.getRequestContext().equals( ContextEnum.PAGE_COMMENT.getRequestContext() ) ? "comment" : "edit";
   440|                 final String commentAuthor = context.getCurrentUser().getName();
   441|                 final String commentAuthorEmail = null;
   442|                 final String commentAuthorURL   = null;
   443|                 final boolean isSpam = m_akismet.commentCheck( ipAddress,
   444|                                                                userAgent,
   445|                                                                referrer,
   446|                                                                permalink,
   447|                                                                commentType,
   448|                                                                commentAuthor,
   449|                                                                commentAuthorEmail,
   450|                                                                commentAuthorURL,
   451|                                                                change.toString(),
   452|                                                                null );
   453|                 sw.stop();
   454|                 LOG.debug( "Akismet request done in: " + sw );
   455|                 if( isSpam ) {
   456|                     final String uid = log( context, REJECT, REASON_AKISMET, change.toString() );
   457|                     LOG.info( "SPAM:Akismet (" + uid + "). Akismet thinks this change is spam; added host to temporary ban list." );
   458|                     checkStrategy( context, "Akismet tells Herb you're a spammer, Herb trusts Akismet, and I trust Herb! (Incident code " + uid + ")" );
   459|                 }
   460|             }
   461|         }
   462|     }
   463|     /**
   464|      * Returns a static string which can be used to detect spambots which just wildly fill in all the fields.
   465|      *
   466|      * @return A string
   467|      */
   468|     public static String getBotFieldName() {
   469|         return "submit_auth";
   470|     }
   471|     /**
   472|      * This checks whether an invisible field is available in the request, and whether it's contents are suspected spam.
   473|      *
   474|      * @param context page Context
   475|      * @param change page change
   476|      * @throws RedirectException spam filter rejects the page change.
   477|      */
   478|     private void checkBotTrap( final Context context, final Change change ) throws RedirectException {
   479|         final HttpServletRequest request = context.getHttpRequest();
   480|         if( request != null ) {
   481|             final String unspam = request.getParameter( getBotFieldName() );
   482|             if( unspam != null && !unspam.isEmpty() ) {
   483|                 final String uid = log( context, REJECT, REASON_BOT_TRAP, change.toString() );
   484|                 LOG.info( "SPAM:BotTrap (" + uid + ").  Wildly behaving bot detected." );
   485|                 checkStrategy( context, "Spamming attempt detected. (Incident code " + uid + ")" );
   486|             }
   487|         }
   488|     }
   489|     private void checkUTF8( final Context context, final Change change ) throws RedirectException {
   490|         final HttpServletRequest request = context.getHttpRequest();
   491|         if( request != null ) {
   492|             final String utf8field = request.getParameter( "encodingcheck" );
   493|             if( utf8field != null && !utf8field.equals( "\u3041" ) ) {
   494|                 final String uid = log( context, REJECT, REASON_UTF8_TRAP, change.toString() );
   495|                 LOG.info( "SPAM:UTF8Trap (" + uid + ").  Wildly posting dumb bot detected." );
   496|                 checkStrategy( context, "Spamming attempt detected. (Incident code " + uid + ")" );
   497|             }
   498|         }
   499|     }
   500|     /** Goes through the ban list and cleans away any host which has expired from it. */
   501|     private synchronized void cleanBanList() {
   502|         final long now = System.currentTimeMillis();
   503|         for( final Iterator< Host > i = m_temporaryBanList.iterator(); i.hasNext(); ) {
   504|             final Host host = i.next();
   505|             if( host.getReleaseTime() < now ) {
   506|                 LOG.debug( "Removed host " + host.getAddress() + " from temporary ban list (expired)" );
   507|                 i.remove();
   508|             }
   509|         }
   510|     }
   511|     /**
   512|      *  Checks the ban list if the IP address of the changer is already on it.
   513|      *
   514|      *  @param context page context
   515|      *  @throws RedirectException spam filter rejects the page change.
   516|      */
   517|     private void checkBanList( final Context context, final Change change ) throws RedirectException {
   518|         final HttpServletRequest req = context.getHttpRequest();
   519|         if( req != null ) {
   520|             final String remote = HttpUtil.getRemoteAddress(req);
   521|             final long now = System.currentTimeMillis();
   522|             for( final Host host : m_temporaryBanList ) {
   523|                 if( host.getAddress().equals( remote ) ) {
   524|                     final long timeleft = ( host.getReleaseTime() - now ) / 1000L;
   525|                     log( context, REJECT, REASON_IP_BANNED_TEMPORARILY, change.m_change );
   526|                     checkStrategy( context,
   527|                             "You have been temporarily banned from modifying this wiki. (" + timeleft + " seconds of ban left)" );
   528|                 }
   529|             }
   530|         }
   531|     }
   532|     /**
   533|      *  If the spam filter notices changes in the black list page, it will refresh them automatically.
   534|      *
   535|      *  @param context associated WikiContext
   536|      */
   537|     private void refreshBlacklists( final Context context ) {
   538|         try {
   539|             boolean rebuild = false;
   540|             final Page sourceSpam = context.getEngine().getManager( PageManager.class ).getPage( m_forbiddenWordsPage );
   541|             if( sourceSpam != null ) {
   542|                 if( m_spamPatterns == null || m_spamPatterns.isEmpty() || sourceSpam.getLastModified().after( m_lastRebuild ) ) {
   543|                     rebuild = true;
   544|                 }
   545|             }
   546|             final Attachment att = context.getEngine().getManager( AttachmentManager.class ).getAttachmentInfo( context, m_blacklist );

# --- HUNK 4: Lines 563-646 ---
   563|                 LOG.info( "IP filter reloaded - recognizing " + m_IPPatterns.size() + " patterns from page " + m_forbiddenIPsPage );
   564|                 if( att != null ) {
   565|                     final InputStream in = context.getEngine().getManager( AttachmentManager.class ).getAttachmentStream(att);
   566|                     final StringWriter out = new StringWriter();
   567|                     FileUtil.copyContents( new InputStreamReader( in, StandardCharsets.UTF_8 ), out );
   568|                     final Collection< Pattern > blackList = parseBlacklist( out.toString() );
   569|                     LOG.info( "...recognizing additional " + blackList.size() + " patterns from blacklist " + m_blacklist );
   570|                     m_spamPatterns.addAll( blackList );
   571|                 }
   572|             }
   573|         } catch( final IOException ex ) {
   574|             LOG.info( "Unable to read attachment data, continuing...", ex );
   575|         } catch( final ProviderException ex ) {
   576|             LOG.info( "Failed to read spam filter attachment, continuing...", ex );
   577|         }
   578|     }
   579|     /**
   580|      * Does a check against a known pattern list.
   581|      *
   582|      * @param context page Context
   583|      * @param change page change
   584|      * @throws RedirectException spam filter rejects the page change.
   585|      */
   586|     private void checkPatternList( final Context context, final Change change ) throws RedirectException {
   587|         if( m_spamPatterns == null || context.getPage().getName().equals( m_forbiddenWordsPage ) ) {
   588|             return;
   589|         }
   590|         String ch = change.toString();
   591|         if( context.getHttpRequest() != null ) {
   592|             ch += HttpUtil.getRemoteAddress( context.getHttpRequest() );
   593|         }
   594|         for( final Pattern p : m_spamPatterns ) {
   595|             if( m_matcher.contains( ch, p ) ) {
   596|                 final String uid = log( context, REJECT, REASON_REGEXP + "(" + p.getPattern() + ")", ch );
   597|                 LOG.info( "SPAM:Regexp (" + uid + "). Content matches the spam filter '" + p.getPattern() + "'" );
   598|                 checkStrategy( context, "Herb says '" + p.getPattern() + "' is a bad spam word and I trust Herb! (Incident code " + uid + ")" );
   599|             }
   600|         }
   601|     }
   602|     /**
   603|      *  Does a check against a pattern list of IPs.
   604|      *
   605|      *  @param context page context
   606|      *  @throws RedirectException spam filter rejects the page change.
   607|      */
   608|     private void checkIPList( final Context context ) throws RedirectException {
   609|         if( m_IPPatterns == null || context.getPage().getName().equals( m_forbiddenIPsPage ) ) {
   610|             return;
   611|         }
   612|         final String remoteIP = HttpUtil.getRemoteAddress( context.getHttpRequest() );
   613|         LOG.info("Attempting to match remoteIP " + remoteIP + " against " + m_IPPatterns.size() + " patterns");
   614|         for( final Pattern p : m_IPPatterns ) {
   615|              LOG.debug("Attempting to match remoteIP with " + p.getPattern());
   616|             if( m_matcher.contains( remoteIP, p ) ) {
   617|                 final String uid = log( context, REJECT, REASON_IP_BANNED_PERMANENTLY + "(" + p.getPattern() + ")", remoteIP );
   618|                 LOG.info( "SPAM:IPBanList (" + uid + "). remoteIP matches the IP filter '" + p.getPattern() + "'" );
   619|                 checkStrategy( context, "Herb says '" + p.getPattern() + "' is a banned IP and I trust Herb! (Incident code " + uid + ")" );
   620|             }
   621|         }
   622|     }
   623|     private void checkPatternList( final Context context, final String change ) throws RedirectException {
   624|         final Change c = new Change();
   625|         c.m_change = change;
   626|         checkPatternList( context, c );
   627|     }
   628|     /**
   629|      *  Creates a simple text string describing the added content.
   630|      *
   631|      *  @param context page context
   632|      *  @param newText added content
   633|      *  @return Empty string, if there is no change.
   634|      */
   635|     private static Change getChange( final Context context, final String newText ) {
   636|         final Page page = context.getPage();
   637|         final StringBuffer change = new StringBuffer();
   638|         final Engine engine = context.getEngine();
   639|         final Change ch = new Change();
   640|         try {
   641|             final String oldText = engine.getManager( PageManager.class ).getPureText( page.getName(), WikiProvider.LATEST_VERSION );
   642|             final String[] first  = Diff.stringToArray( oldText );
   643|             final String[] second = Diff.stringToArray( newText );
   644|             final Revision rev = Diff.diff( first, second, new MyersDiff() );
   645|             if( rev == null || rev.size() == 0 ) {
   646|                 return ch;

# --- HUNK 5: Lines 708-750 ---
   708|      *
   709|      *  @param ctx WikiContext
   710|      *  @return An URL to redirect to
   711|      */
   712|     private String getRedirectPage( final Context ctx ) {
   713|         if( m_useCaptcha ) {
   714|             return ctx.getURL( ContextEnum.PAGE_NONE.getRequestContext(), "Captcha.jsp", "page= " +ctx.getEngine().encodeName( ctx.getPage().getName() ) );
   715|         }
   716|         return ctx.getURL( ContextEnum.PAGE_VIEW.getRequestContext(), m_errorPage );
   717|     }
   718|     /**
   719|      *  Checks whether the UserProfile matches certain checks.
   720|      *
   721|      *  @param profile The profile to check
   722|      *  @param context The WikiContext
   723|      *  @return False, if this userprofile is suspect and should not be allowed to be added.
   724|      *  @since 2.6.1
   725|      */
   726|     public boolean isValidUserProfile( final Context context, final UserProfile profile ) {
   727|         try {
   728|             checkPatternList( context, profile.getEmail() );
   729|             checkPatternList( context, profile.getFullname() );
   730|             checkPatternList( context, profile.getLoginName() );
   731|         } catch( final RedirectException e ) {
   732|             LOG.info("Detected attempt to create a spammer user account (see above for rejection reason)");
   733|             return false;
   734|         }
   735|         return true;
   736|     }
   737|     /**
   738|      *  This method is used to calculate an unique code when submitting the page to detect edit conflicts.  
   739|      *  It currently incorporates the last-modified date of the page, and the IP address of the submitter.
   740|      *
   741|      *  @param page The WikiPage under edit
   742|      *  @param request The HTTP Request
   743|      *  @since 2.6
   744|      *  @return A hash value for this page and session
   745|      */
   746|     public static String getSpamHash( final Page page, final HttpServletRequest request ) {
   747|         long lastModified = 0;
   748|         if( page.getLastModified() != null ) {
   749|             lastModified = page.getLastModified().getTime();
   750|         }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/forms/FormOpen.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-46 ---
     1| /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.forms;
    18| import org.apache.logging.log4j.LogManager;
    19| import org.apache.logging.log4j.Logger;
    20| import org.apache.wiki.api.core.Context;
    21| import org.apache.wiki.api.core.ContextEnum;
    22| import org.apache.wiki.api.exceptions.PluginException;
    23| import org.apache.wiki.api.plugin.Plugin;
    24| import org.apache.wiki.http.filter.CsrfProtectionFilter;
    25| import org.apache.wiki.preferences.Preferences;
    26| import org.apache.wiki.util.TextUtil;
    27| import java.text.MessageFormat;
    28| import java.util.Map;
    29| import java.util.ResourceBundle;
    30| /**
    31|  *  Opens a WikiForm.
    32|  *
    33|  * Builds the HTML code for opening a FORM.
    34|  *
    35|  * <p>Since we're only providing an opening FORM tag, we can't use
    36|  * the ECS utilities.
    37|  *
    38|  * A Form plugin line that produces one looks like this:
    39|  * <p><pre>
    40|  *   [{FormOpen name='formname' handler='pluginname'
    41|  *          submit='submitservlet'
    42|  *          show='always'
    43|  *   }]
    44|  * </pre>
    45|  *
    46|  * <p>Mandatory parameters:

# --- HUNK 2: Lines 56-102 ---
    56|  * this Plugin.)
    57|  *
    58|  * <p>The <i>hide</i> parameter affects the visibility of this
    59|  * form. If left out, the form is always shown. If set to
    60|  * 'onsuccess', the form is not shown if it was submitted
    61|  * successfully. (Note that a reload of the page would cause the
    62|  * context to reset, and the form would be shown again. This may
    63|  * be a useless option.)
    64|  *
    65|  */
    66| public class FormOpen extends FormElement {
    67|     private static final Logger LOG = LogManager.getLogger( FormOpen.class );
    68|     /** Parameter name for setting the method (GET or POST).  Value is <tt>{@value}</tt>. */
    69|     public static final String PARAM_METHOD = "method";
    70|     /**
    71|      *  {@inheritDoc}
    72|      */
    73|     @Override
    74|     public String execute( final Context ctx, final Map< String, String > params ) throws PluginException {
    75|         final ResourceBundle rb = Preferences.getBundle( ctx, Plugin.CORE_PLUGINS_RESOURCEBUNDLE );
    76|         final String formName = TextUtil.replaceEntities( params.get( PARAM_FORM ) );
    77|         if( formName == null ) {
    78|             throw new PluginException( MessageFormat.format( rb.getString( "formopen.missingparam" ), PARAM_FORM ) );
    79|         }
    80|         final String hide     = params.get( PARAM_HIDEFORM );
    81|         final String sourcePage = ctx.getPage().getName();
    82|         String submitServlet = TextUtil.replaceEntities( params.get( PARAM_SUBMITHANDLER ) );
    83|         if( submitServlet == null )
    84|             submitServlet = ctx.getURL( ContextEnum.PAGE_VIEW.getRequestContext(), sourcePage );
    85|         String method = params.get( PARAM_METHOD );
    86|         if( method == null ) {
    87|             method="post";
    88|         }
    89|         if( !( method.equalsIgnoreCase( "get" ) || method.equalsIgnoreCase( "post" ) ) ) {
    90|             throw new PluginException( rb.getString( "formopen.postorgetonly" ) );
    91|         }
    92|         FormInfo info = getFormInfo( ctx );
    93|         if( info != null ) {
    94|             if( formName.equals( info.getName() ) ) {
    95|                 LOG.debug( "Previous FormInfo for this form was found in context." );
    96|                 if( HIDE_SUCCESS.equals( hide ) && info.getStatus() == FormInfo.EXECUTED ) {
    97|                     info.setHide( true );
    98|                     return "<p>" + rb.getString( "formopen.noneedtoshow" ) + "</p>";
    99|                 }
   100|             } else {
   101|                 info = new FormInfo();
   102|             }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/forms/FormOutput.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-85 ---
     1| /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.forms;
    18| import org.apache.wiki.api.core.Context;
    19| import org.apache.wiki.api.core.ContextEnum;
    20| import org.apache.wiki.api.exceptions.PluginException;
    21| import org.apache.wiki.api.plugin.Plugin;
    22| import org.apache.wiki.plugin.DefaultPluginManager;
    23| import org.apache.wiki.plugin.PluginManager;
    24| import org.apache.wiki.preferences.Preferences;
    25| import org.apache.wiki.util.FormUtil;
    26| import org.apache.wiki.util.TextUtil;
    27| import java.text.MessageFormat;
    28| import java.util.Map;
    29| import java.util.ResourceBundle;
    30| /**
    31|  */
    32| public class FormOutput extends FormElement {
    33|     /**
    34|      * Executes the FormHandler specified in a Form 'output' plugin,
    35|      * using entries provided in the HttpRequest as FormHandler
    36|      * parameters.
    37|      * <p>
    38|      * If the parameter 'populate' was given, the WikiPlugin it names
    39|      * is used to get default values. (It probably makes a lot of
    40|      * sense for this to be the same plugin as the handler.)
    41|      * Information for the populator can be given with the FormSet
    42|      * plugin. If 'populate' is not specified, the form is not
    43|      * displayed.
    44|      * <p>
    45|      * Should there be no HTTP request associated with this request,
    46|      * the method will return immediately with an empty string.
    47|      *
    48|      * @param ctx {@inheritDoc}
    49|      * @param params {@inheritDoc}
    50|      * @return {@inheritDoc}
    51|      */
    52|     @Override
    53|     public String execute( final Context ctx, final Map< String, String > params ) throws PluginException {
    54|         if( ctx.getHttpRequest() == null ) {
    55|             return "";
    56|         }
    57|         final ResourceBundle rb = Preferences.getBundle( ctx, Plugin.CORE_PLUGINS_RESOURCEBUNDLE );
    58|         final String formName   = TextUtil.replaceEntities( params.get( PARAM_FORM ) );
    59|         final String submitForm = ctx.getHttpParameter( PARAM_FORMNAMEHIDDEN );
    60|         final String populator  = params.get( PARAM_POPULATE );
    61|         if( formName == null || !formName.equals( submitForm ) ) {
    62|             if( !PARAM_HANDLER.equals( populator ) )
    63|                 return "";
    64|         }
    65|         final String handler = TextUtil.replaceEntities( params.get( PARAM_HANDLER ) );
    66|         if( handler == null || handler.isEmpty() ) {
    67|             return "<p class=\"error\">" + MessageFormat.format( rb.getString( "formoutput.missingargument" ), PARAM_HANDLER ) + "</p>";
    68|         }
    69|         final String sourcePage = ctx.getPage().getName();
    70|         final String submitServlet = ctx.getURL( ContextEnum.PAGE_VIEW.getRequestContext(), sourcePage );
    71|         FormInfo info = getFormInfo( ctx );
    72|         if( info == null ) {
    73|             info = new FormInfo();
    74|             info.setName( formName );
    75|         }
    76|         info.setHandler( handler );
    77|         info.setAction( submitServlet );
    78|         final Map< String, String > handlerParams = FormUtil.requestToMap( ctx.getHttpRequest(), HANDLERPARAM_PREFIX );
    79|         info.addSubmission( handlerParams );
    80|         info.getSubmission().put( DefaultPluginManager.PARAM_BODY, params.get(DefaultPluginManager.PARAM_BODY ) );
    81|         String handlerOutput = null;
    82|         String error = null;
    83|         try {
    84|             final PluginManager pm = ctx.getEngine().getManager( PluginManager.class );
    85|             handlerOutput = pm.execute( ctx, handler, info.getSubmission() );


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/modules/ModuleManager.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-36 ---
     1| /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.modules;
    18| import java.util.Collection;
    19| public interface ModuleManager {
    20|     /** Location of the property-files of plugins. (Each plugin should include this property-file in its jar-file) */
    21|     String PLUGIN_RESOURCE_LOCATION = "ini/jspwiki_module.xml";
    22|     /**
    23|      *  Returns true, if the given module is compatible with this version of JSPWiki.
    24|      *
    25|      *  @param info The module to check
    26|      *  @return True, if the module is compatible.
    27|      */
    28|     boolean checkCompatibility( WikiModuleInfo info );
    29|     /**
    30|      * Returns the {@link WikiModuleInfo} information about the provided moduleName.
    31|      *
    32|      * @param moduleName
    33|      * @return The wikiModuleInfo
    34|      */
    35|     WikiModuleInfo getModuleInfo( String moduleName );
    36|     /**


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/parser/JSPWikiMarkupParser.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1211-1254 ---
  1211|         final StringBuilder sb = new StringBuilder( 40 );
  1212|         int braceLevel = 1;
  1213|         int ch;
  1214|         while( ( ch = nextToken() ) != -1 ) {
  1215|             if( ch == '\\' ) {
  1216|                 continue;
  1217|             } else if( ch == opening ) {
  1218|                 braceLevel++;
  1219|             } else if( ch == closing ) {
  1220|                 braceLevel--;
  1221|                 if( braceLevel == 0 ) {
  1222|                     break;
  1223|                 }
  1224|             }
  1225|             sb.append( ( char ) ch );
  1226|         }
  1227|         return sb.toString();
  1228|     }
  1229|     /**
  1230|      * Handles constructs of type %%(style) and %%class
  1231|      * @return An Element containing the div or span, depending on the situation.
  1232|      * @throws IOException
  1233|      */
  1234|     private Element handleDiv( ) throws IOException {
  1235|         int ch = nextToken();
  1236|         Element el = null;
  1237|         if( ch == '%' ) {
  1238|             String style = null;
  1239|             String clazz = null;
  1240|             ch = nextToken();
  1241|             if( ch == '(' ) {
  1242|                 style = readBraceContent('(',')');
  1243|             } else if( Character.isLetter( (char) ch ) ) {
  1244|                 pushBack( ch );
  1245|                 clazz = readUntil( "( \t\n\r" );
  1246|                 if( clazz != null ) {
  1247|                     clazz = clazz.replace( '.', ' ' )
  1248|                                  .replaceAll( "[^\\s-_\\w\\x200-\\x377]+", "" );
  1249|                 }
  1250|                 ch = nextToken();
  1251|                 if( ch == '(' ) {
  1252|                     style = readBraceContent( '(', ')' );
  1253|                 } else if( ch == '\n' || ch == '\r' ) {
  1254|                     pushBack( ch );

# --- HUNK 2: Lines 1280-1324 ---
  1280|                 final ResourceBundle rb = Preferences.getBundle( m_context, InternationalizationManager.CORE_BUNDLE );
  1281|                 final String msg = MessageFormat.format( rb.getString( "markupparser.error.parserfailure"), e.getMessage() );
  1282|                 return addElement( makeError( msg ) );
  1283|             }
  1284|             final String eol = peekAheadLine();
  1285|             if( !eol.trim().isEmpty() ) {
  1286|                 el = new Element("span");
  1287|                 m_styleStack.push( Boolean.TRUE );
  1288|             } else {
  1289|                 startBlockLevel();
  1290|                 el = new Element("div");
  1291|                 m_styleStack.push( Boolean.FALSE );
  1292|             }
  1293|             if( style != null ) el.setAttribute("style", style);
  1294|             if( clazz != null ) el.setAttribute("class", clazz);
  1295|             return pushElement( el );
  1296|         }
  1297|         pushBack( ch );
  1298|         return el;
  1299|     }
  1300|     private Element handleSlash( ) throws IOException {
  1301|         final int ch = nextToken();
  1302|         pushBack( ch );
  1303|         if( ch == '%' && !m_styleStack.isEmpty() ) {
  1304|             return handleDiv();
  1305|         }
  1306|         return null;
  1307|     }
  1308|     private Element handleBar( final boolean newLine ) throws IOException {
  1309|         Element el;
  1310|         if( !m_istable && !newLine ) {
  1311|             return null;
  1312|         }
  1313|         if( newLine ) {
  1314|             if( !m_istable ) {
  1315|                 startBlockLevel();
  1316|                 el = pushElement( new Element("table").setAttribute("class","wikitable").setAttribute("border","1") );
  1317|                 m_istable = true;
  1318|                 m_rowNum = 0;
  1319|             }
  1320|             m_rowNum++;
  1321|             final Element tr = ( m_rowNum % 2 != 0 )
  1322|                        ? new Element("tr").setAttribute("class", "odd")
  1323|                        : new Element("tr");
  1324|             el = pushElement( tr );

# --- HUNK 3: Lines 1543-1586 ---
  1543|             break;
  1544|           case '*':
  1545|             if( m_newLine ) {
  1546|                 pushBack( '*' );
  1547|                 el = handleGeneralList();
  1548|             }
  1549|             break;
  1550|           case '#':
  1551|             if( m_newLine ) {
  1552|                 pushBack( '#' );
  1553|                 el = handleGeneralList();
  1554|             }
  1555|             break;
  1556|           case '|':
  1557|             el = handleBar( m_newLine );
  1558|             break;
  1559|           case '~':
  1560|             el = handleTilde();
  1561|             break;
  1562|           case '%':
  1563|             el = handleDiv();
  1564|             break;
  1565|           case '/':
  1566|             el = handleSlash();
  1567|             break;
  1568|           default:
  1569|             break;
  1570|         }
  1571|         return el != null ? ELEMENT : CHARACTER;
  1572|     }
  1573|     private void closeHeadings() {
  1574|         if( m_lastHeading != null && !m_wysiwygEditorMode ) {
  1575|             addElement( new Element("a").setAttribute( "class",HASHLINK )
  1576|                                               .setAttribute( "href","#" + m_lastHeading.m_titleAnchor )
  1577|                                               .setText( "#" ) );
  1578|             m_lastHeading = null;
  1579|         }
  1580|         popElement( "h2" );
  1581|         popElement( "h3" );
  1582|         popElement( "h4" );
  1583|     }
  1584|     /**
  1585|      *  Parses the entire document from the Reader given in the constructor or set by {@link #setInputReader(Reader)}.
  1586|      *


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/parser/LinkParser.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 4-44 ---
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.parser;
    18| import java.util.ArrayList;
    19| import java.util.Arrays;
    20| import java.util.Iterator;
    21| import java.util.List;
    22| import java.util.NoSuchElementException;
    23| import java.util.StringTokenizer;
    24| import java.util.stream.IntStream;
    25| import org.apache.logging.log4j.LogManager;
    26| import org.apache.logging.log4j.Logger;
    27| import org.jdom2.Attribute;
    28| /**
    29|  *  Parses JSPWiki-style "augmented" link markup into a Link object
    30|  *  containing the link text, link reference, and any optional link
    31|  *  attributes (as JDOM Attributes).
    32|  *  <p>
    33|  *  The parser recognizes three link forms:
    34|  *  </p>
    35|  *  <ol>
    36|  *    <li><tt> [Text] </tt></li>
    37|  *    <li><tt> [Text | Link] </tt></li>
    38|  *    <li><tt> [Text | Link | attributes] </tt></li>
    39|  *  </ol>
    40|  *  <p>
    41|  *  where the attributes are space-delimited, each in the form of
    42|  *  </p>
    43|  *  <pre>
    44|  *      name1='value1' name2='value2' name3='value3' (etc.) </pre>

# --- HUNK 2: Lines 270-310 ---
   270|     }
   271|     private String require(final StringTokenizer tok, final String required )
   272|             throws ParseException, NoSuchElementException
   273|     {
   274|         final String s = tok.nextToken(required);
   275|         if( !s.equals(required) )
   276|         {
   277|             throw new ParseException("expected '"+required+"' not '"+s+"'");
   278|         }
   279|         return s;
   280|     }
   281|     /**
   282|      *  Returns true if the String <tt>s</tt> is completely
   283|      *  composed of whitespace.
   284|      *
   285|      *  @param s The string to check
   286|      *  @return True, if "s" is all XML whitespace.
   287|      */
   288|     public static final boolean isSpace(final String s )
   289|     {
   290|         return IntStream.range(0, s.length()).allMatch(i -> isSpace(s.charAt(i)));
   291|     }
   292|     /**
   293|      *  Returns true if char <tt>c</tt> is a member of
   294|      *  <tt>S</tt> (space) [XML 1.1 production 3].
   295|      *
   296|      *  @param c Character to check.
   297|      *  @return True, if the character is an XML space.
   298|      */
   299|     public static final boolean isSpace(final char c )
   300|     {
   301|         return
   302|            0x20 == c
   303|         || 0x0A == c
   304|         || 0x0D == c
   305|         || 0x09 == c
   306|         || 0x85 == c
   307|         || 0x2028 == c;
   308|     }
   309|     /**
   310|      *  Inner class serving as a struct containing the parsed


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/plugin/AbstractReferralPlugin.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 31-71 ---
    31| import org.apache.wiki.api.exceptions.PluginException;
    32| import org.apache.wiki.api.plugin.Plugin;
    33| import org.apache.wiki.pages.PageManager;
    34| import org.apache.wiki.pages.PageSorter;
    35| import org.apache.wiki.parser.MarkupParser;
    36| import org.apache.wiki.parser.WikiDocument;
    37| import org.apache.wiki.preferences.Preferences;
    38| import org.apache.wiki.preferences.Preferences.TimeFormat;
    39| import org.apache.wiki.render.RenderingManager;
    40| import org.apache.wiki.util.TextUtil;
    41| import org.apache.wiki.util.comparators.CollatorComparator;
    42| import org.apache.wiki.util.comparators.HumanComparator;
    43| import org.apache.wiki.util.comparators.JavaNaturalComparator;
    44| import org.apache.wiki.util.comparators.LocaleComparator;
    45| import java.io.IOException;
    46| import java.text.Collator;
    47| import java.text.ParseException;
    48| import java.text.RuleBasedCollator;
    49| import java.text.SimpleDateFormat;
    50| import java.util.ArrayList;
    51| import java.util.Arrays;
    52| import java.util.Collection;
    53| import java.util.Date;
    54| import java.util.Iterator;
    55| import java.util.List;
    56| import java.util.Map;
    57| import java.util.stream.Collectors;
    58| /**
    59|  *  This is a base class for all plugins using referral things.
    60|  *
    61|  *  <p>Parameters (also valid for all subclasses of this class) : </p>
    62|  *  <ul>
    63|  *  <li><b>maxwidth</b> - maximum width of generated links</li>
    64|  *  <li><b>separator</b> - separator between generated links (wikitext)</li>
    65|  *  <li><b>after</b> - output after the link</li>
    66|  *  <li><b>before</b> - output before the link</li>
    67|  *  <li><b>exclude</b> -  a regular expression of pages to exclude from the list. </li>
    68|  *  <li><b>include</b> -  a regular expression of pages to include in the list. </li>
    69|  *  <li><b>show</b> - value is either "pages" (default) or "count".  When "count" is specified, shows only the count
    70|  *      of pages which match. (since 2.8)</li>
    71|  *  <li><b>columns</b> - How many columns should the output be displayed on.</li>

# --- HUNK 2: Lines 195-239 ---
   195|     protected List< Page > filterWikiPageCollection( final Collection< Page > pages ) {
   196|         final List< String > pageNames = filterCollection( pages.stream()
   197|                                                                 .map( Page::getName )
   198|                                                                 .collect( Collectors.toList() ) );
   199|         return pages.stream()
   200|                     .filter( wikiPage -> pageNames.contains( wikiPage.getName() ) )
   201|                     .collect( Collectors.toList() );
   202|     }
   203|     /**
   204|      *  Filters a collection according to the include and exclude parameters.
   205|      *
   206|      *  @param c The collection to filter.
   207|      *  @return A filtered collection.
   208|      */
   209|     protected List< String > filterCollection( final Collection< String > c ) {
   210|         final ArrayList< String > result = new ArrayList<>();
   211|         final PatternMatcher pm = new Perl5Matcher();
   212|         for( final String pageName : c ) {
   213|             boolean includeThis = m_include == null;
   214|             if( m_include != null ) {
   215|                 includeThis = Arrays.stream(m_include).anyMatch(pattern -> pm.matches(pageName, pattern)) ? true : m_include == null;
   216|             }
   217|             if( m_exclude != null ) {
   218|                 if (Arrays.stream(m_exclude).anyMatch(pattern -> pm.matches(pageName, pattern))) {
   219|                     includeThis = false;
   220|                 }
   221|             }
   222|             if( includeThis ) {
   223|                 result.add( pageName );
   224|                 final Page page;
   225|                 if( m_lastModified ) {
   226|                     page = m_engine.getManager( PageManager.class ).getPage( pageName );
   227|                     if( page != null ) {
   228|                         final Date lastModPage = page.getLastModified();
   229|                         LOG.debug( "lastModified Date of page {} : {}", pageName, m_dateLastModified );
   230|                         if( lastModPage.after( m_dateLastModified ) ) {
   231|                             m_dateLastModified = lastModPage;
   232|                         }
   233|                     }
   234|                 }
   235|             }
   236|         }
   237|         return result;
   238|     }
   239|     /**


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/plugin/BugReportHandler.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-51 ---
     1| /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.plugin;
    18| import org.apache.logging.log4j.LogManager;
    19| import org.apache.logging.log4j.Logger;
    20| import org.apache.wiki.api.core.Context;
    21| import org.apache.wiki.api.core.Engine;
    22| import org.apache.wiki.api.core.Page;
    23| import org.apache.wiki.api.exceptions.PluginException;
    24| import org.apache.wiki.api.exceptions.RedirectException;
    25| import org.apache.wiki.api.exceptions.WikiException;
    26| import org.apache.wiki.api.plugin.Plugin;
    27| import org.apache.wiki.api.spi.Wiki;
    28| import org.apache.wiki.pages.PageManager;
    29| import org.apache.wiki.parser.MarkupParser;
    30| import org.apache.wiki.preferences.Preferences;
    31| import org.apache.wiki.util.TextUtil;
    32| import java.io.PrintWriter;
    33| import java.io.StringWriter;
    34| import java.security.Principal;
    35| import java.text.MessageFormat;
    36| import java.text.SimpleDateFormat;
    37| import java.util.Date;
    38| import java.util.Map;
    39| import java.util.Properties;
    40| import java.util.ResourceBundle;
    41| import java.util.StringTokenizer;
    42| /**
    43|  *  Provides a handler for bug reports.  Still under construction.
    44|  *
    45|  *  <p>Parameters : </p>
    46|  *  <ul>
    47|  *  <li><b>title</b> -  title of the bug, this is required.  If it is empty (as in "")  it is a signal to the handler to return quietly.</li>
    48|  *  <li><b>description</b> - description of the bug.</li>
    49|  *  <li><b>version</b> - version</li>
    50|  *  <li><b>map</b> - I have no idea </li>
    51|  *  <li><b>page</b> - The name of the page to be created for this bug report </li>

# --- HUNK 2: Lines 103-143 ---
   103|             if( submitter != null ) {
   104|                 out.println("|"+mappings.getProperty("submitter","Submitter") + "|" + submitter );
   105|             }
   106|             for( final Map.Entry< String, String > entry : params.entrySet() ) {
   107|                 if( !( entry.getKey().equals( PARAM_TITLE ) ||
   108|                        entry.getKey().equals( PARAM_DESCRIPTION ) ||
   109|                        entry.getKey().equals( PARAM_VERSION ) ||
   110|                        entry.getKey().equals( PARAM_MAPPINGS ) ||
   111|                        entry.getKey().equals( PARAM_PAGE ) ||
   112|                        entry.getKey().startsWith( "_" )
   113|                      ) ) {
   114|                     final String head = mappings.getProperty( entry.getKey(), entry.getKey() );
   115|                     if( !head.isEmpty() ) {
   116|                         out.println( "|" + head + "|" + entry.getValue() );
   117|                     }
   118|                 }
   119|             }
   120|             out.println();
   121|             out.println( description );
   122|             out.close();
   123|             final String pageName = findNextPage( context, title, TextUtil.replaceEntities(params.get( PARAM_PAGE )) );
   124|             final Page newPage = Wiki.contents().page( context.getEngine(), pageName );
   125|             final Context newContext = context.clone();
   126|             newContext.setPage( newPage );
   127|             context.getEngine().getManager( PageManager.class ).saveText( newContext, str.toString() );
   128|             final MessageFormat formatter = new MessageFormat("");
   129|             formatter.applyPattern( rb.getString("bugreporthandler.new") );
   130|             final String[] args = { "<a href=\""+context.getViewURL(pageName)+"\">"+pageName+"</a>" };
   131|             return formatter.format( args );
   132|         } catch( final RedirectException e ) {
   133|             LOG.info("Saving not allowed, reason: '"+e.getMessage()+"', can't redirect to "+e.getRedirect());
   134|             throw new PluginException("Saving not allowed, reason: "+e.getMessage());
   135|         } catch( final WikiException e ) {
   136|             LOG.error( "Unable to save page!", e );
   137|             return rb.getString("bugreporthandler.unable" );
   138|         }
   139|     }
   140|     /**
   141|      *  Finds a free page name for adding the bug report.  Tries to construct a page, and if it's found, adds a number to it
   142|      *  and tries again.
   143|      */


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/plugin/CurrentTimePlugin.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-58 ---
     1| /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.plugin;
    18| import org.apache.wiki.api.core.Context;
    19| import org.apache.wiki.api.exceptions.PluginException;
    20| import org.apache.wiki.api.plugin.Plugin;
    21| import org.apache.wiki.preferences.Preferences;
    22| import org.apache.wiki.preferences.Preferences.TimeFormat;
    23| import org.apache.wiki.util.TextUtil;
    24| import java.text.SimpleDateFormat;
    25| import java.util.Date;
    26| import java.util.Map;
    27| import java.util.ResourceBundle;
    28| /**
    29|  *  Just displays the current date and time.
    30|  *  The time format is exactly like in the java.text.SimpleDateFormat class.
    31|  *
    32|  *  <p>Parameters : </p>
    33|  *  NONE
    34|  *  @since 1.7.8
    35|  *  @see java.text.SimpleDateFormat
    36|  */
    37| public class CurrentTimePlugin implements Plugin {
    38|     /**
    39|      *  {@inheritDoc}
    40|      */
    41|     @Override
    42|     public String execute( final Context context, final Map< String, String > params ) throws PluginException {
    43|         final String formatString = params.get( "format" );
    44|         try {
    45|             final SimpleDateFormat fmt;
    46|             if( formatString != null ) {
    47|                 fmt = new SimpleDateFormat( formatString );
    48|             } else {
    49|                 fmt = Preferences.getDateFormat( context, TimeFormat.DATETIME );
    50|             }
    51|             final Date d = new Date();  // Now.
    52|             return TextUtil.replaceEntities( fmt.format( d ) );
    53|         } catch( final IllegalArgumentException e ) {
    54|             final ResourceBundle rb = Preferences.getBundle( context, Plugin.CORE_PLUGINS_RESOURCEBUNDLE );
    55|             throw new PluginException( rb.getString( "currenttimeplugin.badformat" ) + e.getMessage() );
    56|         }
    57|     }
    58| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/plugin/Denounce.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 123-163 ---
   123|         }
   124|         if( linkAllowed ) {
   125|             return "<a href=\"" + link + "\">" + TextUtil.replaceEntities( text ) + "</a>";
   126|         }
   127|         return c_denounceText;
   128|     }
   129|     boolean isLinkValid( final String link ) {
   130|         try {
   131|             new URL( link ).toURI().parseServerAuthority();
   132|         } catch ( final Exception e ) {
   133|             LOG.debug( "invalid link {} - {}", link, e.getMessage() );
   134|             return false;
   135|         }
   136|         return true;
   137|     }
   138|     /**
   139|      *  Returns true, if the path is found among the referers.
   140|      */
   141|     private boolean matchPattern( final List< Pattern > list, final String path ) {
   142|         final PatternMatcher matcher = new Perl5Matcher();
   143|         return list.stream().anyMatch(pattern -> matcher.matches(path, pattern));
   144|     }
   145|     private boolean matchHeaders( final HttpServletRequest request ) {
   146|         final String userAgent = request.getHeader( "User-Agent" );
   147|         if( userAgent != null && matchPattern( c_agentPatterns, userAgent ) ) {
   148|             LOG.debug( "Matched user agent " + userAgent + " for denounce." );
   149|             return true;
   150|         }
   151|         final String refererPath = request.getHeader( "Referer" );
   152|         if( refererPath != null && matchPattern( c_refererPatterns, refererPath ) ) {
   153|             LOG.debug( "Matched referer " + refererPath + " for denounce." );
   154|             return true;
   155|         }
   156|         final String host = request.getRemoteHost();
   157|         if( host != null && matchPattern( c_hostPatterns, host ) ) {
   158|             LOG.debug( "Matched host " + host + " for denounce." );
   159|             return true;
   160|         }
   161|         return false;
   162|     }
   163| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/plugin/IndexPlugin.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 17-57 ---
    17| package org.apache.wiki.plugin;
    18| import org.apache.commons.lang3.StringUtils;
    19| import org.apache.logging.log4j.LogManager;
    20| import org.apache.logging.log4j.Logger;
    21| import org.apache.wiki.api.core.Context;
    22| import org.apache.wiki.api.core.ContextEnum;
    23| import org.apache.wiki.api.exceptions.PluginException;
    24| import org.apache.wiki.api.exceptions.ProviderException;
    25| import org.apache.wiki.api.plugin.Plugin;
    26| import org.apache.wiki.pages.PageManager;
    27| import org.apache.wiki.references.ReferenceManager;
    28| import org.jdom2.Element;
    29| import org.jdom2.Namespace;
    30| import org.jdom2.output.Format;
    31| import org.jdom2.output.XMLOutputter;
    32| import java.util.ArrayList;
    33| import java.util.List;
    34| import java.util.Map;
    35| import java.util.Set;
    36| import java.util.regex.Pattern;
    37| import java.util.stream.Collectors;
    38| /**
    39|  *  A Plugin that creates an index of pages according to a certain pattern.
    40|  *  <br />
    41|  *  The default is to include all pages.
    42|  *  <p>
    43|  *  This is a rewrite of the earlier JSPWiki IndexPlugin using JDOM2.
    44|  8  </p>
    45|  *  <p>
    46|  *  Parameters (from AbstractReferralPlugin):
    47|  *  </p>
    48|  *  <ul>
    49|  *    <li><b>include</b> - A regexp pattern for marking which pages should be included.</li>
    50|  *    <li><b>exclude</b> - A regexp pattern for marking which pages should be excluded.</li>
    51|  *  </ul>
    52|  *  
    53|  * @author Ichiro Furusato
    54|  */
    55| public class IndexPlugin extends AbstractReferralPlugin implements Plugin {
    56|     private static final Logger LOG = LogManager.getLogger(IndexPlugin.class);
    57|     private final Namespace xmlns_XHTML = Namespace.getNamespace("http://www.w3.org/1999/xhtml");

# --- HUNK 2: Lines 106-131 ---
   106|         span.addContent( a );
   107|         return span;
   108|     }
   109|     private Element getElement( final String gi, final String classValue ) {
   110|         final Element elt = new Element( gi, xmlns_XHTML );
   111|         elt.setAttribute( "class", classValue );
   112|         return elt;
   113|     }
   114|     /**
   115|      *  Grabs a list of all pages and filters them according to the include/exclude patterns.
   116|      *  
   117|      * @param context
   118|      * @param include
   119|      * @param exclude
   120|      * @return A list containing page names which matched the filters.
   121|      * @throws ProviderException
   122|      */
   123|     private List<String> listPages( final Context context, final String include, final String exclude ) throws ProviderException {
   124|         final Pattern includePtrn = include != null ? Pattern.compile( include ) : Pattern.compile(".*");
   125|         final Pattern excludePtrn = exclude != null ? Pattern.compile( exclude ) : Pattern.compile("\\p{Cntrl}"); // there are no control characters in page names
   126|         final List< String > result;
   127|         final Set< String > pages = context.getEngine().getManager( ReferenceManager.class ).findCreated();
   128|         result = pages.stream().filter(pageName -> !excludePtrn.matcher(pageName).matches()).filter(pageName -> includePtrn.matcher(pageName).matches()).collect(Collectors.toList());
   129|         return result;
   130|     }
   131| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/plugin/InsertPage.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 57-99 ---
    57|     public static final String PARAM_MAXLENGTH = "maxlength";
    58|     /** Parameter name for setting the class.  Value is <tt>{@value}</tt>. */
    59|     public static final String PARAM_CLASS     = "class";
    60|     /** Parameter name for setting the show option.  Value is <tt>{@value}</tt>. */
    61|     public static final String PARAM_SHOW   = "show";
    62|     /** Parameter name for setting the section.  Value is <tt>{@value}</tt>. */
    63|     public static final String PARAM_SECTION   = "section";
    64|     /** Parameter name for setting the default.  Value is <tt>{@value}</tt>. */
    65|     public static final String PARAM_DEFAULT   = "default";
    66|     private static final String DEFAULT_STYLE = "";
    67|     private static final String ONCE_COOKIE = "JSPWiki.Once.";
    68|     /** This attribute is stashed in the WikiContext to make sure that we don't have circular references. */
    69|     public static final String ATTR_RECURSE    = "org.apache.wiki.plugin.InsertPage.recurseCheck";
    70|     /**
    71|      *  {@inheritDoc}
    72|      */
    73|     @Override @SuppressWarnings("unchecked")
    74|     public String execute( final Context context, final Map<String, String> params ) throws PluginException {
    75|         final Engine engine = context.getEngine();
    76|         final StringBuilder res = new StringBuilder();
    77|         final String clazz        = TextUtil.replaceEntities(params.get( PARAM_CLASS ));
    78|         final String includedPage = TextUtil.replaceEntities(params.get( PARAM_PAGENAME ));
    79|         String style              = TextUtil.replaceEntities(params.get( PARAM_STYLE ));
    80|         final boolean showOnce    = "once".equals( params.get( PARAM_SHOW ) );
    81|         final String defaultstr   = params.get( PARAM_DEFAULT );
    82|         final int section         = TextUtil.parseIntParameter(params.get( PARAM_SECTION ), -1 );
    83|         int maxlen                = TextUtil.parseIntParameter(params.get( PARAM_MAXLENGTH ), -1 );
    84|         final ResourceBundle rb = Preferences.getBundle( context, Plugin.CORE_PLUGINS_RESOURCEBUNDLE );
    85|         if( style == null ) {
    86|             style = DEFAULT_STYLE;
    87|         }
    88|         if( maxlen == -1 ) {
    89|             maxlen = Integer.MAX_VALUE;
    90|         }
    91|         if( includedPage != null ) {
    92|             final Page page;
    93|             try {
    94|                 final String pageName = engine.getFinalPageName( includedPage );
    95|                 if( pageName != null ) {
    96|                     page = engine.getManager( PageManager.class ).getPage( pageName );
    97|                 } else {
    98|                     page = engine.getManager( PageManager.class ).getPage( includedPage );
    99|                 }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/plugin/ReferringUndefinedPagesPlugin.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 7-71 ---
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.plugin;
    18| import org.apache.wiki.api.core.Context;
    19| import org.apache.wiki.api.exceptions.PluginException;
    20| import org.apache.wiki.api.plugin.Plugin;
    21| import org.apache.wiki.preferences.Preferences;
    22| import org.apache.wiki.references.ReferenceManager;
    23| import org.apache.wiki.util.TextUtil;
    24| import java.text.MessageFormat;
    25| import java.util.Collection;
    26| import java.util.Map;
    27| import java.util.Objects;
    28| import java.util.ResourceBundle;
    29| import java.util.TreeMap;
    30| import java.util.stream.Collectors;
    31| /**
    32|  *  <p>Lists all pages containing links to Undefined Pages (pages containing dead links).</p>
    33|  *
    34|  *  An original idea from Gregor Hagedorn.
    35|  *
    36|  *  @since 2.10.0
    37|  */
    38| public class ReferringUndefinedPagesPlugin extends AbstractReferralPlugin {
    39|     /** Parameter name for setting the maximum items to show.  Value is <tt>{@value}</tt>. */
    40|     public static final String PARAM_MAX = "max";
    41|     /** Parameter name for setting the text to show when the maximum items is overruled. Value is <tt>{@value}</tt>. */
    42|     public static final String PARAM_EXTRAS = "extras";
    43|     @Override
    44|     public String execute( final Context context, final Map<String, String> params) throws PluginException {
    45|         final ResourceBundle rb = Preferences.getBundle(context, Plugin.CORE_PLUGINS_RESOURCEBUNDLE);
    46|         final ReferenceManager referenceManager = context.getEngine().getManager( ReferenceManager.class );
    47|         final int items = TextUtil.parseIntParameter(params.get(PARAM_MAX), ALL_ITEMS);
    48|         String extras = params.get(PARAM_EXTRAS);
    49|         if (extras == null) {
    50|             extras = rb.getString("referringundefinedpagesplugin.more");
    51|         }
    52|         final Collection< String > uncreatedPages = referenceManager.findUncreated();
    53|         super.initialize( context, params );
    54|         Collection< String > result = null;
    55|         final TreeMap< String, String > sortedMap;
    56|         if( uncreatedPages != null ) {
    57|             sortedMap = uncreatedPages.stream().map(referenceManager::findReferrers).filter(Objects::nonNull).flatMap(Collection::stream).collect(Collectors.toMap(referringPage -> referringPage, referringPage -> "", (a, b) -> b, TreeMap::new));
    58|             result = sortedMap.keySet();
    59|         }
    60|         result = super.filterAndSortCollection( result );
    61|         final String wikitext = wikitizeCollection( result, m_separator, items );
    62|         final StringBuilder resultHTML = new StringBuilder();
    63|         resultHTML.append( applyColumnsStyle( makeHTML( context, wikitext ) ) );
    64|         if( items < result.size() && items > 0 ) {
    65|             final Object[] args = { "" + ( result.size() - items ) };
    66|             extras = MessageFormat.format( extras, args );
    67|             resultHTML.append( "<br/>" ).append( extras ).append( "<br/>" );
    68|         }
    69|         return resultHTML.toString();
    70|     }
    71| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/plugin/Search.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 9-49 ---
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16| */
    17| package org.apache.wiki.plugin;
    18| import org.apache.logging.log4j.LogManager;
    19| import org.apache.logging.log4j.Logger;
    20| import org.apache.wiki.api.core.Context;
    21| import org.apache.wiki.api.core.ContextEnum;
    22| import org.apache.wiki.api.core.Engine;
    23| import org.apache.wiki.api.exceptions.PluginException;
    24| import org.apache.wiki.api.exceptions.ProviderException;
    25| import org.apache.wiki.api.plugin.Plugin;
    26| import org.apache.wiki.api.search.SearchResult;
    27| import org.apache.wiki.render.RenderingManager;
    28| import org.apache.wiki.search.SearchManager;
    29| import org.apache.wiki.util.TextUtil;
    30| import org.apache.wiki.util.XHTML;
    31| import org.apache.wiki.util.XhtmlUtil;
    32| import org.jdom2.Element;
    33| import java.io.IOException;
    34| import java.util.Collection;
    35| import java.util.Iterator;
    36| import java.util.Map;
    37| /**
    38|  *  The "Search" plugin allows you to access the JSPWiki search routines and show the displays in an array on your page.
    39|  *
    40|  *  <p>Parameters : </p>
    41|  *  <ul>
    42|  *  <li><b>query</b> - String. A standard JSPWiki search query.</li>
    43|  *  <li><b>set</b> - String. The JSPWiki context variable that will hold the results of the query. This allows you to pass your queries to other plugins on the same page as well. </li>
    44|  *  <li><b>max</b> - Integer. How many search results are shown at maximum.</li>
    45|  *  </ul>
    46|  *
    47|  *  @since
    48|  */
    49| public class Search implements Plugin {

# --- HUNK 2: Lines 58-98 ---
    58|     public static final String PARAM_MAX   = "max";
    59|     /**
    60|      * {@inheritDoc}
    61|      */
    62|     @Override
    63|     public String execute( final Context context, final Map<String, String> params ) throws PluginException {
    64|         int maxItems = Integer.MAX_VALUE;
    65|         final Collection< SearchResult > results;
    66|         final String queryString = params.get( PARAM_QUERY );
    67|         String set               = params.get( PARAM_SET );
    68|         final String max         = params.get( PARAM_MAX );
    69|         if ( set == null ) set = DEFAULT_SETNAME;
    70|         if ( max != null ) maxItems = Integer.parseInt( max );
    71|         if ( queryString == null ) {
    72|             results = context.getVariable( set );
    73|         } else {
    74|             try {
    75|                 results = doBasicQuery( context, queryString );
    76|                 context.setVariable( set, results );
    77|             } catch( final Exception e ) {
    78|                 return "<div class='error'>" + TextUtil.replaceEntities(e.getMessage()) + "</div>\n";
    79|             }
    80|         }
    81|         String res = "";
    82|         if ( results != null ) {
    83|             res = renderResults(results,context,maxItems);
    84|         }
    85|         return res;
    86|     }
    87|     private Collection<SearchResult> doBasicQuery( final Context context, final String query ) throws ProviderException, IOException {
    88|         LOG.debug( "Searching for string " + query );
    89|         return context.getEngine().getManager( SearchManager.class ).findPages( query, context );
    90|     }
    91|     private String renderResults( final Collection<SearchResult> results, final Context context, final int maxItems ) {
    92|         final Engine engine = context.getEngine();
    93|         final Element table = XhtmlUtil.element(XHTML.table);
    94|         table.setAttribute(XHTML.ATTR_class,"wikitable search-result");
    95|         Element row = XhtmlUtil.element(XHTML.tr);
    96|         table.addContent(row);
    97|         final Element th1 = XhtmlUtil.element(XHTML.th,"Page");
    98|         th1.setAttribute(XHTML.ATTR_width,"30%");


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/preferences/Preferences.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 62-102 ---
    62|      *  This method will remember if the user has already changed his prefs.
    63|      *
    64|      *  @param pageContext The JSP PageContext.
    65|      */
    66|     public static void setupPreferences( final PageContext pageContext ) {
    67|             reloadPreferences( pageContext );
    68|     }
    69|     /**
    70|      *  Reloads the preferences from the PageContext into the WikiContext.
    71|      *
    72|      *  @param pageContext The page context.
    73|      */
    74|     public static void reloadPreferences( final PageContext pageContext ) {
    75|         final Preferences prefs = new Preferences();
    76|         final Properties props = PropertyReader.loadWebAppProps( pageContext.getServletContext() );
    77|         final Context ctx = Context.findContext( pageContext );
    78|         final String dateFormat = ctx.getEngine().getManager( InternationalizationManager.class )
    79|                                            .get( InternationalizationManager.CORE_BUNDLE, getLocale( ctx ), "common.datetimeformat" );
    80|         prefs.put("SkinName", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.skinname", "PlainVanilla" ) );
    81|         prefs.put("DateFormat", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.dateformat", dateFormat ) );
    82|         prefs.put("TimeZone", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.timezone", TimeZone.getDefault().getID() ) );
    83|         prefs.put("Orientation", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.orientation", "fav-left" ) );
    84|         prefs.put("Sidebar", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.sidebar", "active" ) );
    85|         prefs.put("Layout", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.layout", "fluid" ) );
    86|         prefs.put("Language", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.language", getLocale( ctx ).toString() ) );
    87|         prefs.put("SectionEditing", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.sectionediting", "true" ) );
    88|         prefs.put("Appearance", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.appearance", "true" ) );
    89|         prefs.put("autosuggest", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.autosuggest", "true" ) );
    90|         prefs.put("tabcompletion", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.tabcompletion", "true" ) );
    91|         prefs.put("smartpairs", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.smartpairs", "false" ) );
    92|         prefs.put("livepreview", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.livepreview", "true" ) );
    93|         prefs.put("previewcolumn", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.previewcolumn", "true" ) );
    94|         prefs.put("editor", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.editor", "plain" ) );
    95|         parseJSONPreferences( (HttpServletRequest) pageContext.getRequest(), prefs );
    96|         pageContext.getSession().setAttribute( SESSIONPREFS, prefs );
    97|     }
    98|     /**
    99|      * Parses new-style preferences stored as JSON objects and stores them in the session.  Everything in the cookie is stored.
   100|      *
   101|      * @param request
   102|      * @param prefs The default hashmap of preferences


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/providers/CachingAttachmentProvider.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 140-180 ---
   140|                 }
   141|             }
   142|         }
   143|         if( cachingManager.enabled( CachingManager.CACHE_ATTACHMENTS )
   144|                 && attachments.get() >= cachingManager.info( CachingManager.CACHE_ATTACHMENTS ).getMaxElementsAllowed() ) {
   145|             LOG.warn( "seems {} can't hold all attachments from your page repository, " +
   146|                     "so we're delegating on the underlying provider instead. Please consider increasing " +
   147|                     "your cache sizes on the ehcache configuration file to avoid this behaviour", CachingManager.CACHE_ATTACHMENTS );
   148|             return provider.listAllChanged( timestamp );
   149|         }
   150|         return all;
   151|     }
   152|     /**
   153|      *  Simply goes through the collection and attempts to locate the
   154|      *  given attachment of that name.
   155|      *
   156|      *  @return null, if no such attachment was in this collection.
   157|      */
   158|     private Attachment findAttachmentFromCollection( final Collection< Attachment > c, final String name ) {
   159|         if( c != null ) {
   160|             return c.stream().filter(att -> name.equals(att.getFileName())).findFirst().orElse(null);
   161|         }
   162|         return null;
   163|     }
   164|     /**
   165|      * {@inheritDoc}
   166|      */
   167|     @Override
   168|     public Attachment getAttachmentInfo( final Page page, final String name, final int version ) throws ProviderException {
   169|         LOG.debug( "Getting attachments for {}, name={}, version={}", page, name, version );
   170|         if( version != WikiProvider.LATEST_VERSION ) {
   171|             LOG.debug( "...we don't cache old versions" );
   172|             return provider.getAttachmentInfo( page, name, version );
   173|         }
   174|         final Collection< Attachment > c = cachingManager.get( CachingManager.CACHE_ATTACHMENTS_COLLECTION, page.getName(),
   175|                                                                ()-> provider.listAttachments( page ) );
   176|         return findAttachmentFromCollection( c, name );
   177|     }
   178|     /**
   179|      * {@inheritDoc}
   180|      */


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/references/DefaultReferenceManager.java
# Total hunks: 5
# ====================================================================
# --- HUNK 1: Lines 26-66 ---
    26| import org.apache.wiki.api.core.Page;
    27| import org.apache.wiki.api.exceptions.ProviderException;
    28| import org.apache.wiki.api.filters.BasePageFilter;
    29| import org.apache.wiki.api.providers.PageProvider;
    30| import org.apache.wiki.api.providers.WikiProvider;
    31| import org.apache.wiki.api.spi.Wiki;
    32| import org.apache.wiki.attachment.AttachmentManager;
    33| import org.apache.wiki.event.WikiEvent;
    34| import org.apache.wiki.event.WikiEventManager;
    35| import org.apache.wiki.event.WikiPageEvent;
    36| import org.apache.wiki.pages.PageManager;
    37| import org.apache.wiki.render.RenderingManager;
    38| import org.apache.wiki.util.TextUtil;
    39| import java.io.*;
    40| import java.nio.charset.StandardCharsets;
    41| import java.nio.file.Files;
    42| import java.security.MessageDigest;
    43| import java.security.NoSuchAlgorithmException;
    44| import java.util.*;
    45| import java.util.concurrent.ConcurrentHashMap;
    46| import java.util.stream.Collectors;
    47| /*
    48|   BUGS
    49|   - if a wikilink is added to a page, then removed, RefMan still thinks that the page refers to the wikilink page. Hm.
    50|   - if a page is deleted, gets very confused.
    51|   - Serialization causes page attributes to be missing, when InitializablePlugins are not executed properly.  Thus,
    52|     serialization should really also mark whether a page is serializable or not...
    53|  */
    54| /*
    55|    A word about synchronizing:
    56|    I expect this object to be accessed in three situations:
    57|    - when an Engine is created, and it scans its wikipages
    58|    - when the Engine saves a page
    59|    - when a JSP page accesses one of the Engine's ReferenceManagers to display a list of (un)referenced pages.
    60|    So, access to this class is fairly rare, and usually triggered by user interaction. OTOH, the methods in this class use their storage
    61|    objects intensively (and, sorry to say, in an unoptimized manner =). My deduction: using unsynchronized HashMaps etc. and syncing methods
    62|    or code blocks is preferrable to using slow, synced storage objects. We don't have iterative code here, so I'm going to use synced
    63|    methods for now.
    64|    Please contact me if you notice problems with ReferenceManager, and especially with synchronization, or if you have suggestions about
    65|    syncing.
    66|    ebu@memecry.net

# --- HUNK 2: Lines 71-111 ---
    71|  *  <LI>What pages a given page refers to
    72|  *  <LI>What pages refer to a given page
    73|  *  </UL>
    74|  *
    75|  *  This is a quick'n'dirty approach without any finesse in storage and searching algorithms; we trust java.util.*.
    76|  *  <P>
    77|  *  This class contains two HashMaps, m_refersTo and m_referredBy. The first is indexed by WikiPage names and contains a Collection of all
    78|  *  WikiPages the page refers to. (Multiple references are not counted, naturally.) The second is indexed by WikiPage names and contains
    79|  *  a Set of all pages that refer to the indexing page. (Notice - the keys of both Maps should be kept in sync.)
    80|  *  <P>
    81|  *  When a page is added or edited, its references are parsed, a Collection is received, and we crudely replace anything previous with
    82|  *  this new Collection. We then check each referenced page name and make sure they know they are referred to by the new page.
    83|  *  <P>
    84|  *  Based on this information, we can perform non-optimal searches for e.g. unreferenced pages, top ten lists, etc.
    85|  *  <P>
    86|  *  The owning class must take responsibility of filling in any pre-existing information, probably by loading each and every WikiPage
    87|  *  and calling this class to update the references when created.
    88|  *
    89|  *  @since 1.6.1 (as of 2.11.0, moved to org.apache.wiki.references)
    90|  */
    91| public class DefaultReferenceManager extends BasePageFilter implements ReferenceManager, Serializable {
    92|     /**
    93|      *  Maps page wikiname to a Collection of pages it refers to. The Collection must contain Strings. The Collection may contain
    94|      *  names of non-existing pages.
    95|      */
    96|     private Map< String, Collection< String > > m_refersTo;
    97|     private Map< String, Collection< String > > m_unmutableRefersTo;
    98|     /**
    99|      *  Maps page wikiname to a Set of referring pages. The Set must contain Strings. Non-existing pages (a reference exists, but
   100|      *  not a file for the page contents) may have an empty Set in m_referredBy.
   101|      */
   102|     private Map< String, Set< String > > m_referredBy;
   103|     private Map< String, Set< String > > m_unmutableReferredBy;
   104|     private final boolean m_matchEnglishPlurals;
   105|     private static final Logger LOG = LogManager.getLogger( DefaultReferenceManager.class);
   106|     private static final String SERIALIZATION_FILE = "refmgr.ser";
   107|     private static final String SERIALIZATION_DIR  = "refmgr-attr";
   108|     /** We use this also a generic serialization id */
   109|     private static final long serialVersionUID = 4L;
   110|     /**
   111|      *  Builds a new ReferenceManager.

# --- HUNK 3: Lines 406-484 ---
   406|      *  @param references A Collection of Strings, each one pointing to a page this page references.
   407|      */
   408|     @Override
   409|     public void updateReferences( final String page, final Collection< String > references ) {
   410|         internalUpdateReferences( page, references );
   411|         serializeToDisk();
   412|     }
   413|     /**
   414|      *  Updates the referred pages of a new or edited WikiPage. If a refersTo entry for this page already exists, it is
   415|      *  removed and a new one is built from scratch. Also calls updateReferredBy() for each referenced page.
   416|      *  <p>
   417|      *  This method does not synchronize the database to disk.
   418|      *
   419|      *  @param page Name of the page to update.
   420|      *  @param references A Collection of Strings, each one pointing to a page this page references.
   421|      */
   422|     private void internalUpdateReferences( String page, final Collection< String > references) {
   423|         page = getFinalPageName( page );
   424|         final Collection< String > oldRefTo = m_refersTo.get( page );
   425|         m_refersTo.remove( page );
   426|         final TreeSet< String > cleanedRefs = references.stream().map(this::getFinalPageName).collect(Collectors.toCollection(TreeSet::new));
   427|         m_refersTo.put( page, cleanedRefs );
   428|         if( !m_referredBy.containsKey( page ) ) {
   429|             m_referredBy.put( page, new TreeSet<>() );
   430|         }
   431|         cleanReferredBy( page, oldRefTo);
   432|         for( final String referredPageName : cleanedRefs ) {
   433|             updateReferredBy( getFinalPageName( referredPageName ), page );
   434|         }
   435|     }
   436|     /**
   437|      * Returns the refers-to list. For debugging.
   438|      *
   439|      * @return The refers-to list.
   440|      */
   441|     protected Map< String, Collection< String > > getRefersTo() {
   442|         return m_refersTo;
   443|     }
   444|     /**
   445|      * Returns the referred-by list. For debugging.
   446|      *
   447|      * @return Referred-by lists.
   448|      */
   449|     protected Map< String, Set< String > > getReferredBy() {
   450|         return m_referredBy;
   451|     }
   452|     /**
   453|      * Cleans the 'referred by' list, removing references by 'referrer' to any other page. Called after 'referrer' is removed.
   454|      *
   455|      * Two ways to go about this. One is to look up all pages previously referred by referrer and remove referrer
   456|      * from their lists, and let the update put them back in (except possibly removed ones).
   457|      *
   458|      * The other is to get the old referred-to list, compare to the new, and tell the ones missing in the latter to remove referrer from
   459|      * their list.
   460|      *
   461|      * We'll just try the first for now. Need to come back and optimize this a bit.
   462|      */
   463|     private void cleanReferredBy( final String referrer,
   464|                                   final Collection< String > oldReferred ) {
   465|         if( oldReferred == null ) {
   466|             return;
   467|         }
   468|         for( final String referredPage : oldReferred ) {
   469|             final Set< String > oldRefBy = m_referredBy.get( referredPage );
   470|             if( oldRefBy != null ) {
   471|                 oldRefBy.remove( referrer );
   472|             }
   473|             if( ( oldRefBy == null || oldRefBy.isEmpty() ) && !m_engine.getManager( PageManager.class ).wikiPageExists( referredPage ) ) {
   474|                 m_referredBy.remove( referredPage );
   475|             }
   476|         }
   477|     }
   478|     /**
   479|      * When initially building a ReferenceManager from scratch, call this method BEFORE calling updateReferences() with
   480|      * a full list of existing page names. It builds the refersTo and referredBy key lists, thus enabling updateReferences()
   481|      * to function correctly.
   482|      * <P>
   483|      * This method should NEVER be called after initialization. It clears all mappings from the reference tables.
   484|      *

# --- HUNK 4: Lines 547-589 ---
   547|         final ArrayList< String > unref = new ArrayList<>();
   548|         for( final String key : m_referredBy.keySet() ) {
   549|             final Set< ? > refs = getReferenceList( m_referredBy, key );
   550|             if( refs == null || refs.isEmpty() ) {
   551|                 unref.add( key );
   552|             }
   553|         }
   554|         return unref;
   555|     }
   556|     /**
   557|      * Finds all references to non-existant pages. This requires a linear scan through m_refersTo values; each value
   558|      * must have a corresponding key entry in the reference Maps, otherwise such a page has never been created.
   559|      * <P>
   560|      * Returns a Collection containing Strings of unreferenced page names. Each non-existant page name is shown only
   561|      * once - we don't return information on who referred to it.
   562|      *
   563|      * @return A Collection of Strings
   564|      */
   565|     @Override
   566|     public Collection< String > findUncreated() {
   567|         final TreeSet< String > uncreated;
   568|         final Collection< Collection< String > > allReferences = m_refersTo.values();
   569|         uncreated = allReferences.stream().filter(Objects::nonNull).flatMap(Collection::stream).filter(aReference -> !m_engine.getManager(PageManager.class).wikiPageExists(aReference)).collect(Collectors.toCollection(TreeSet::new));
   570|         return uncreated;
   571|     }
   572|     /**
   573|      *  Searches for the given page in the given Map, and returns the set of references. This method also takes care of
   574|      *  English plural matching.
   575|      *
   576|      *  @param coll The Map to search in
   577|      *  @param pagename The name to find.
   578|      *  @return The references list.
   579|      */
   580|     private < T > Set< T > getReferenceList( final Map< String, Set< T > > coll, final String pagename ) {
   581|         Set< T > refs = coll.get( pagename );
   582|         if( m_matchEnglishPlurals ) {
   583|             final Set< T > refs2;
   584|             if( pagename.endsWith( "s" ) ) {
   585|                 refs2 = coll.get( pagename.substring( 0, pagename.length() - 1 ) );
   586|             } else {
   587|                 refs2 = coll.get( pagename + "s" );
   588|             }
   589|             if( refs2 != null ) {


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/render/CreoleRenderer.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 6-47 ---
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.render;
    18| import org.apache.wiki.api.core.Context;
    19| import org.apache.wiki.parser.PluginContent;
    20| import org.apache.wiki.parser.WikiDocument;
    21| import org.jdom2.Content;
    22| import org.jdom2.Element;
    23| import org.jdom2.Text;
    24| import java.util.ArrayList;
    25| import java.util.List;
    26| import java.util.stream.Collectors;
    27| import java.util.stream.IntStream;
    28| /**
    29|  *  Implements DOM-to-Creole rendering.
    30|  *  <p>
    31|  *  FIXME: This class is not yet completely done.
    32|  *
    33|  */
    34| public class CreoleRenderer extends WikiRenderer {
    35|     private static final String IMG_START = "{{";
    36|     private static final String IMG_END = "}}";
    37|     private static final String PLUGIN_START = "<<";
    38|     private static final String PLUGIN_END = ">>";
    39|     private static final String HREF_START = "[[";
    40|     private static final String HREF_DELIMITER = "|";
    41|     private static final String HREF_END = "]]";
    42|     private static final String PRE_START = "{{{";
    43|     private static final String PRE_END = "}}}";
    44|     private static final String PLUGIN_IMAGE = "Image";
    45|     private static final String PARAM_SRC = "src";
    46|     private static final String HREF_ATTRIBUTE = "href";
    47|     private static final String ONE_SPACE = " ";

# --- HUNK 2: Lines 78-118 ---
    78|     /**
    79|      * Renders an element into the StringBuilder given
    80|      * @param ce element to render
    81|      * @param sb stringbuilder holding the element render
    82|      */
    83|     private void renderElement( final Element ce, final StringBuilder sb ) {
    84|         String endEl = EMPTY_STRING;
    85|         for( int i = 0; i < ELEMENTS.length; i+=3 ) {
    86|             if( ELEMENTS[i].equals(ce.getName()) ) {
    87|                 sb.append( ELEMENTS[i+1] );
    88|                 endEl = ELEMENTS[i+2];
    89|             }
    90|         }
    91|         if( UL.equals(ce.getName()) ) {
    92|             m_listCount++;
    93|             m_listChar = '*';
    94|         } else if( OL.equals(ce.getName()) ) {
    95|             m_listCount++;
    96|             m_listChar = '#';
    97|         } else if( LI.equals(ce.getName()) ) {
    98|             sb.append(IntStream.range(0, m_listCount).mapToObj(i -> String.valueOf(m_listChar)).collect(Collectors.joining("", "", ONE_SPACE)));
    99|         } else if( A.equals( ce.getName() ) ) {
   100|             final String href = ce.getAttributeValue( HREF_ATTRIBUTE );
   101|             final String text = ce.getText();
   102|             if( href.equals( text ) ) {
   103|                 sb.append( HREF_START ).append( href ).append( HREF_END );
   104|             } else {
   105|                 sb.append( HREF_START ).append( href ).append( HREF_DELIMITER ).append( text ).append( HREF_END);
   106|             }
   107|             return;
   108|         } else if( PRE.equals( ce.getName() ) ) {
   109|             sb.append( PRE_START );
   110|             sb.append( ce.getText() );
   111|             sb.append( PRE_END );
   112|             return;
   113|         }
   114|         for( final Content c : ce.getContent() ) {
   115|             if( c instanceof PluginContent ) {
   116|                 final PluginContent pc = ( PluginContent )c;
   117|                 if( pc.getPluginName().equals( PLUGIN_IMAGE ) ) {
   118|                     sb.append( IMG_START ).append( pc.getParameter( PARAM_SRC ) ).append( IMG_END );


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/search/DefaultSearchManager.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 74-114 ---
    74|      *  Provides a JSON AJAX API to the JSPWiki Search Engine.
    75|      */
    76|     public class JSONSearch implements WikiAjaxServlet {
    77|         public static final String AJAX_ACTION_SUGGESTIONS = "suggestions";
    78|         public static final String AJAX_ACTION_PAGES = "pages";
    79|         public static final int DEFAULT_MAX_RESULTS = 20;
    80|         public int maxResults = DEFAULT_MAX_RESULTS;
    81|         /** {@inheritDoc} */
    82|         @Override
    83|         public String getServletMapping() {
    84|             return JSON_SEARCH;
    85|         }
    86|         /** {@inheritDoc} */
    87|         @Override
    88|         public void service( final HttpServletRequest req,
    89|                              final HttpServletResponse resp,
    90|                              final String actionName,
    91|                              final List< String > params ) throws IOException {
    92|             String result = "";
    93|             if( StringUtils.isNotBlank( actionName ) ) {
    94|                 if( params.isEmpty() ) {
    95|                     return;
    96|                 }
    97|                 final String itemId = params.get( 0 );
    98|                 LOG.debug( "itemId=" + itemId );
    99|                 if( params.size() > 1 ) {
   100|                     final String maxResultsParam = params.get( 1 );
   101|                     LOG.debug( "maxResultsParam=" + maxResultsParam );
   102|                     if( StringUtils.isNotBlank( maxResultsParam ) && StringUtils.isNumeric( maxResultsParam ) ) {
   103|                         maxResults = Integer.parseInt( maxResultsParam );
   104|                     }
   105|                 }
   106|                 if( actionName.equals( AJAX_ACTION_SUGGESTIONS ) ) {
   107|                     LOG.debug( "Calling getSuggestions() START" );
   108|                     final List< String > callResults = getSuggestions( itemId, maxResults );
   109|                     LOG.debug( "Calling getSuggestions() DONE. " + callResults.size() );
   110|                     result = AjaxUtil.toJson( callResults );
   111|                 } else if( actionName.equals( AJAX_ACTION_PAGES ) ) {
   112|                     LOG.debug("Calling findPages() START");
   113|                     final Context wikiContext = Wiki.context().create( m_engine, req, ContextEnum.PAGE_VIEW.getRequestContext() );
   114|                     final List< Map< String, Object > > callResults = findPages( itemId, maxResults, wikiContext );


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/search/LuceneSearchProvider.java
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 3-43 ---
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.    
    16|  */
    17| package org.apache.wiki.search;
    18| import org.apache.commons.lang3.StringUtils;
    19| import org.apache.logging.log4j.LogManager;
    20| import org.apache.logging.log4j.Logger;
    21| import org.apache.lucene.analysis.Analyzer;
    22| import org.apache.lucene.analysis.TokenStream;
    23| import org.apache.lucene.analysis.classic.ClassicAnalyzer;
    24| import org.apache.lucene.document.Document;
    25| import org.apache.lucene.document.Field;
    26| import org.apache.lucene.document.StringField;
    27| import org.apache.lucene.document.TextField;
    28| import org.apache.lucene.index.DirectoryReader;
    29| import org.apache.lucene.index.IndexReader;
    30| import org.apache.lucene.index.IndexWriter;
    31| import org.apache.lucene.index.IndexWriterConfig;
    32| import org.apache.lucene.index.IndexWriterConfig.OpenMode;
    33| import org.apache.lucene.index.Term;
    34| import org.apache.lucene.queryparser.classic.MultiFieldQueryParser;
    35| import org.apache.lucene.queryparser.classic.ParseException;
    36| import org.apache.lucene.queryparser.classic.QueryParser;
    37| import org.apache.lucene.search.IndexSearcher;
    38| import org.apache.lucene.search.Query;
    39| import org.apache.lucene.search.ScoreDoc;
    40| import org.apache.lucene.search.TermQuery;
    41| import org.apache.lucene.search.highlight.Highlighter;
    42| import org.apache.lucene.search.highlight.InvalidTokenOffsetsException;
    43| import org.apache.lucene.search.highlight.QueryScorer;

# --- HUNK 2: Lines 55-117 ---
    55| import org.apache.wiki.api.exceptions.NoRequiredPropertyException;
    56| import org.apache.wiki.api.exceptions.ProviderException;
    57| import org.apache.wiki.api.providers.PageProvider;
    58| import org.apache.wiki.api.providers.WikiProvider;
    59| import org.apache.wiki.api.search.SearchResult;
    60| import org.apache.wiki.api.spi.Wiki;
    61| import org.apache.wiki.attachment.AttachmentManager;
    62| import org.apache.wiki.auth.AuthorizationManager;
    63| import org.apache.wiki.auth.permissions.PagePermission;
    64| import org.apache.wiki.pages.PageManager;
    65| import org.apache.wiki.util.ClassUtil;
    66| import org.apache.wiki.util.FileUtil;
    67| import org.apache.wiki.util.TextUtil;
    68| import java.io.File;
    69| import java.io.IOException;
    70| import java.io.InputStream;
    71| import java.io.InputStreamReader;
    72| import java.io.StringReader;
    73| import java.io.StringWriter;
    74| import java.util.ArrayList;
    75| import java.util.Arrays;
    76| import java.util.Collection;
    77| import java.util.Collections;
    78| import java.util.Date;
    79| import java.util.List;
    80| import java.util.Properties;
    81| import java.util.concurrent.Executor;
    82| import java.util.concurrent.Executors;
    83| import java.util.stream.Collectors;
    84| /**
    85|  * Interface for the search providers that handle searching the Wiki
    86|  *
    87|  * @since 2.2.21.
    88|  */
    89| public class LuceneSearchProvider implements SearchProvider {
    90|     protected static final Logger LOG = LogManager.getLogger( LuceneSearchProvider.class );
    91|     private Engine m_engine;
    92|     private Executor searchExecutor;
    93|     /** Which analyzer to use.  Default is StandardAnalyzer. */
    94|     public static final String PROP_LUCENE_ANALYZER      = "jspwiki.lucene.analyzer";
    95|     private static final String PROP_LUCENE_INDEXDELAY   = "jspwiki.lucene.indexdelay";
    96|     private static final String PROP_LUCENE_INITIALDELAY = "jspwiki.lucene.initialdelay";
    97|     private String m_analyzerClass = ClassicAnalyzer.class.getName();
    98|     private static final String LUCENE_DIR = "lucene";
    99|     /** These attachment file suffixes will be indexed. */
   100|     public static final String[] SEARCHABLE_FILE_SUFFIXES = new String[] { ".txt", ".ini", ".xml", ".html", "htm", ".mm", ".htm",
   101|                                                                            ".xhtml", ".java", ".c", ".cpp", ".php", ".asm", ".sh",
   102|                                                                            ".properties", ".kml", ".gpx", ".loc", ".md", ".xml" };
   103|     protected static final String LUCENE_ID            = "id";
   104|     protected static final String LUCENE_PAGE_CONTENTS = "contents";
   105|     protected static final String LUCENE_AUTHOR        = "author";
   106|     protected static final String LUCENE_ATTACHMENTS   = "attachment";
   107|     protected static final String LUCENE_PAGE_NAME     = "name";
   108|     protected static final String LUCENE_PAGE_KEYWORDS = "keywords";
   109|     private String m_luceneDirectory;
   110|     protected final List< Object[] > m_updates = Collections.synchronizedList( new ArrayList<>() );
   111|     /** Maximum number of fragments from search matches. */
   112|     private static final int MAX_FRAGMENTS = 3;
   113|     /** The maximum number of hits to return from searches. */
   114|     public static final int MAX_SEARCH_HITS = 99_999;
   115|     private static final String PUNCTUATION_TO_SPACES = StringUtils.repeat( " ", TextUtil.PUNCTUATION_CHARS_ALLOWED.length() );
   116|     /** {@inheritDoc} */
   117|     @Override

# --- HUNK 3: Lines 218-258 ---
   218|         final AttachmentManager mgr = m_engine.getManager( AttachmentManager.class );
   219|         try {
   220|             final Attachment att = mgr.getAttachmentInfo( attachmentName, version );
   221|             if( att != null ) {
   222|                 return getAttachmentContent( att );
   223|             }
   224|         } catch( final ProviderException e ) {
   225|             LOG.error( "Attachment cannot be loaded", e );
   226|         }
   227|         return null;
   228|     }
   229|     /**
   230|      * @param att Attachment to get content for. Filename extension is used to determine the type of the attachment.
   231|      * @return String representing the content of the file.
   232|      * FIXME This is a very simple implementation of some text-based attachment, mainly used for testing.
   233|      * This should be replaced /moved to Attachment search providers or some other 'pluggable' way to search attachments
   234|      */
   235|     protected String getAttachmentContent( final Attachment att ) {
   236|         final AttachmentManager mgr = m_engine.getManager( AttachmentManager.class );
   237|         final String filename = att.getFileName();
   238|         boolean searchSuffix = Arrays.stream(SEARCHABLE_FILE_SUFFIXES).anyMatch(filename::endsWith);
   239|         String out = filename;
   240|         if( searchSuffix ) {
   241|             try( final InputStream attStream = mgr.getAttachmentStream( att ); final StringWriter sout = new StringWriter() ) {
   242|                 FileUtil.copyContents( new InputStreamReader( attStream ), sout );
   243|                 out = out + " " + sout;
   244|             } catch( final ProviderException | IOException e ) {
   245|                 LOG.error( "Attachment cannot be loaded", e );
   246|             }
   247|         }
   248|         return out;
   249|     }
   250|     /**
   251|      * Updates the lucene index for a single page.
   252|      *
   253|      * @param page The WikiPage to check
   254|      * @param text The page text to index.
   255|      */
   256|     protected synchronized void updateLuceneIndex( final Page page, final String text ) {
   257|         LOG.debug( "Updating Lucene index for page '{}'...", page.getName() );
   258|         pageRemoved( page );

# --- HUNK 4: Lines 287-328 ---
   287|     protected Document luceneIndexPage( final Page page, final String text, final IndexWriter writer ) throws IOException {
   288|         LOG.debug( "Indexing {}...", page.getName() );
   289|         final Document doc = new Document();
   290|         if( text == null ) {
   291|             return doc;
   292|         }
   293|         final String indexedText = text.replace( "__", " " ); // be nice to Language Analyzers - cfr. JSPWIKI-893
   294|         Field field = new Field( LUCENE_ID, page.getName(), StringField.TYPE_STORED );
   295|         doc.add( field );
   296|         field = new Field( LUCENE_PAGE_CONTENTS, indexedText, TextField.TYPE_STORED );
   297|         doc.add( field );
   298|         final String unTokenizedTitle = StringUtils.replaceChars( page.getName(), TextUtil.PUNCTUATION_CHARS_ALLOWED, PUNCTUATION_TO_SPACES );
   299|         field = new Field( LUCENE_PAGE_NAME, TextUtil.beautifyString( page.getName() ) + " " + unTokenizedTitle, TextField.TYPE_STORED );
   300|         doc.add( field );
   301|         if( page.getAuthor() != null ) {
   302|             field = new Field( LUCENE_AUTHOR, page.getAuthor(), TextField.TYPE_STORED );
   303|             doc.add( field );
   304|         }
   305|         try {
   306|             final List< Attachment > attachments = m_engine.getManager( AttachmentManager.class ).listAttachments( page );
   307|             final String attachmentNames = attachments.stream().map(att -> att.getName() + ";").collect(Collectors.joining());
   308|             field = new Field( LUCENE_ATTACHMENTS, attachmentNames, TextField.TYPE_STORED );
   309|             doc.add( field );
   310|         } catch( final ProviderException e ) {
   311|             LOG.error( "Failed to get attachments for page", e );
   312|         }
   313|         if( page.getAttribute( "keywords" ) != null ) {
   314|             field = new Field( LUCENE_PAGE_KEYWORDS, page.getAttribute( "keywords" ).toString(), TextField.TYPE_STORED );
   315|             doc.add( field );
   316|         }
   317|         synchronized( writer ) {
   318|             writer.addDocument( doc );
   319|         }
   320|         return doc;
   321|     }
   322|     /**
   323|      * {@inheritDoc}
   324|      */
   325|     @Override
   326|     public synchronized void pageRemoved( final Page page ) {
   327|         try( final Directory luceneDir = new NIOFSDirectory( new File( m_luceneDirectory ).toPath() );
   328|              final IndexWriter writer = getIndexWriter( luceneDir ) ) {


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/tags/AdminBeanIteratorTag.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 3-52 ---
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.  
    16|  */
    17| package org.apache.wiki.tags;
    18| import org.apache.wiki.api.core.Context;
    19| import org.apache.wiki.ui.admin.AdminBean;
    20| import org.apache.wiki.ui.admin.AdminBeanManager;
    21| import java.util.ArrayList;
    22| import java.util.Collection;
    23| import java.util.stream.Collectors;
    24| /**
    25|  *  Provides an iterator for all AdminBeans of a given type.
    26|  *
    27|  */
    28| public class AdminBeanIteratorTag extends IteratorTag {
    29|     private static final long serialVersionUID = 1L;
    30|     private int m_type;
    31|     /**
    32|      *  Set the type of the bean.
    33|      *  
    34|      *  @param type Type to set
    35|      */
    36|     public void setType( final String type ) {
    37|     	if (m_wikiContext == null) {
    38|     		m_wikiContext = Context.findContext(pageContext);
    39|     	}
    40|         m_type = m_wikiContext.getEngine().getManager( AdminBeanManager.class ).getTypeFromString( type );
    41|     }
    42|     /**
    43|      *  {@inheritDoc}
    44|      */
    45|     @Override
    46|     public void resetIterator() {
    47|         final AdminBeanManager mgr = m_wikiContext.getEngine().getManager( AdminBeanManager.class );
    48|         final Collection< AdminBean > beans = mgr.getAllBeans();
    49|         final ArrayList< AdminBean > typedBeans = beans.stream().filter(ab -> ab.getType() == m_type).collect(Collectors.toCollection(ArrayList::new));
    50|         setList( typedBeans );
    51|     }
    52| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/tags/EditorIteratorTag.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 3-44 ---
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.  
    16|  */
    17| package org.apache.wiki.tags;
    18| import org.apache.wiki.api.core.Context;
    19| import org.apache.wiki.api.core.Engine;
    20| import org.apache.wiki.ui.Editor;
    21| import org.apache.wiki.ui.EditorManager;
    22| import java.util.ArrayList;
    23| import java.util.Arrays;
    24| import java.util.Collection;
    25| import java.util.stream.Collectors;
    26| /**
    27|  *  Iterates through editors.
    28|  *
    29|  *  @since 2.4.12
    30|  */
    31| public class EditorIteratorTag extends IteratorTag  {
    32|     private static final long serialVersionUID = 0L;
    33|     /** {@inheritDoc} */
    34|     @Override
    35|     public final int doStartTag() {
    36|         m_wikiContext = Context.findContext(pageContext);
    37|         final Engine engine = m_wikiContext.getEngine();
    38|         final EditorManager mgr = engine.getManager( EditorManager.class );
    39|         final String[] editorList = mgr.getEditorList();
    40|         final Collection< Editor > editors = Arrays.stream(editorList).map(editor -> new Editor(m_wikiContext, editor)).collect(Collectors.toList());
    41|         setList( editors );
    42|         return super.doStartTag();
    43|     }
    44| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/tags/TabTag.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-152 ---
     1| /* 
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.  
    16|  */
    17| package org.apache.wiki.tags;
    18| import org.apache.wiki.util.TextUtil;
    19| import javax.servlet.jsp.JspTagException;
    20| import java.io.IOException;
    21| /**
    22|  *  Generates single tabbed page layout. Works together with the tabbedSection javascript.  Note that if you do not
    23|  *  specify an url, the body contents of the tag are loaded by the tag itself.
    24|  *
    25|  *  <P><B>Attributes</B></P>
    26|  *  <UL>
    27|  *    <LI>id - ID for this tab. (mandatory)
    28|  *    <LI>title - Title of this tab. (mandatory)
    29|  *    <LI>accesskey - Single char usable as quick accesskey (alt- or ctrl-) (optional)
    30|  *    <li>url - If you <i>don't</i> want to create a Javascript-enabled tag, you can use this
    31|  *              to make the tab look just the usual tag, but instead, it will actually link
    32|  *              to that page.  This can be useful in certain cases where you have something
    33|  *              that you want to look like a part of a tag, but for example, due to it being
    34|  *              very big in size, don't want to include it as a part of the page content
    35|  *              every time.
    36|  *  </UL>
    37|  *
    38|  *  @since v2.3.63
    39|  */
    40| public class TabTag extends WikiTagBase {
    41|     private static final long serialVersionUID = -8534125226484616489L;
    42|     private String m_accesskey;
    43|     private String m_tabTitle;
    44|     private String m_url;
    45|     /**
    46|      * {@inheritDoc}
    47|      */
    48|     @Override
    49|     public void doFinally() {
    50|         super.doFinally();
    51|         m_accesskey = null;
    52|         m_tabTitle  = null;
    53|         m_url       = null;
    54|     }
    55|     /**
    56|      * Sets the tab title.
    57|      * @param aTabTitle the tab title
    58|      */
    59|     public void setTitle( final String aTabTitle ) {
    60|         m_tabTitle = TextUtil.replaceEntities( aTabTitle );
    61|     }
    62|     /**
    63|      * Sets the tab access key.
    64|      *
    65|      * @param anAccesskey the access key
    66|      */
    67|     public void setAccesskey( final String anAccesskey ) {
    68|         m_accesskey = TextUtil.replaceEntities( anAccesskey ); //take only the first char
    69|     }
    70|     /**
    71|      * Sets the tab URL.
    72|      *
    73|      * @param url the URL
    74|      */
    75|     public void setUrl( final String url ) {
    76|         m_url = TextUtil.replaceEntities( url );
    77|     }
    78|     private boolean handleAccesskey() {
    79|         if( ( m_tabTitle == null ) || ( m_accesskey == null ) ) return false;
    80|         final int pos = m_tabTitle.toLowerCase().indexOf( m_accesskey.toLowerCase() );
    81|         if( pos > -1 ) {
    82|             m_tabTitle = m_tabTitle.substring( 0, pos ) + "<span class='accesskey'>"
    83|                     + m_tabTitle.charAt( pos ) + "</span>" + m_tabTitle.substring( pos + 1 );
    84|         }
    85|         return true;
    86|     }
    87|     /**
    88|      * {@inheritDoc}
    89|      */
    90|     @Override
    91|     public int doWikiStartTag() throws JspTagException {
    92|         final TabbedSectionTag parent = ( TabbedSectionTag ) findAncestorWithClass( this, TabbedSectionTag.class );
    93|         if( getId() == null ) {
    94|             throw new JspTagException( "Tab Tag without \"id\" attribute" );
    95|         }
    96|         if( m_tabTitle == null ) {
    97|             throw new JspTagException( "Tab Tag without \"tabTitle\" attribute" );
    98|         }
    99|         if( parent == null ) {
   100|             throw new JspTagException( "Tab Tag without parent \"TabbedSection\" Tag" );
   101|         }
   102|         if( !parent.isStateGenerateTabBody() ) {
   103|             return SKIP_BODY;
   104|         }
   105|         final StringBuilder sb = new StringBuilder( 32 );
   106|         sb.append( "<div id=\"" ).append( getId() ).append( "\"" );
   107|         if( !parent.validateDefaultTab( getId() ) ) {
   108|             sb.append( " class=\"hidetab\"" );
   109|         }
   110|         sb.append( " >\n" );
   111|         try {
   112|             pageContext.getOut().write( sb.toString() );
   113|         } catch( final IOException e ) {
   114|             throw new JspTagException( "IO Error: " + e.getMessage() );
   115|         }
   116|         return EVAL_BODY_INCLUDE;
   117|     }
   118|     /**
   119|      * {@inheritDoc}
   120|      */
   121|     @Override
   122|     public int doEndTag() throws JspTagException {
   123|         final TabbedSectionTag parent = ( TabbedSectionTag ) findAncestorWithClass( this, TabbedSectionTag.class );
   124|         final StringBuilder sb = new StringBuilder();
   125|         if( parent.isStateFindDefaultTab() ) {
   126|             parent.validateDefaultTab( getId() );
   127|         } else if( parent.isStateGenerateTabBody() ) {
   128|             sb.append( "</div>\n" );
   129|         } else if( parent.isStateGenerateTabMenu() ) {
   130|             sb.append( "<a" );
   131|             if( parent.validateDefaultTab( getId() ) ) {
   132|                 sb.append( " class=\"activetab\"" );
   133|             }
   134|             sb.append( " id=\"menu-" ).append( getId() ).append( "\"" );
   135|             if( m_url != null ) {
   136|                 sb.append( " href='" ).append( m_url ).append( "'" );
   137|             }
   138|             if( handleAccesskey() ) {
   139|                 sb.append( " accesskey=\"" ).append( m_accesskey ).append( "\"" );
   140|             }
   141|             sb.append( " >" );
   142|             sb.append( m_tabTitle );
   143|             sb.append( "</a>" );
   144|         }
   145|         try {
   146|             pageContext.getOut().write( sb.toString() );
   147|         } catch( final IOException e ) {
   148|             throw new JspTagException( "IO Error: " + e.getMessage() );
   149|         }
   150|         return EVAL_PAGE;
   151|     }
   152| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/tags/UserProfileTag.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 14-57 ---
    14|     specific language governing permissions and limitations
    15|     under the License.  
    16|  */
    17| package org.apache.wiki.tags;
    18| import org.apache.wiki.api.core.Context;
    19| import org.apache.wiki.api.core.Engine;
    20| import org.apache.wiki.api.core.Session;
    21| import org.apache.wiki.api.spi.Wiki;
    22| import org.apache.wiki.auth.AuthenticationManager;
    23| import org.apache.wiki.auth.GroupPrincipal;
    24| import org.apache.wiki.auth.UserManager;
    25| import org.apache.wiki.auth.authorize.Role;
    26| import org.apache.wiki.auth.user.UserProfile;
    27| import org.apache.wiki.i18n.InternationalizationManager;
    28| import org.apache.wiki.preferences.Preferences;
    29| import org.apache.wiki.util.TextUtil;
    30| import javax.servlet.http.HttpServletRequest;
    31| import java.io.IOException;
    32| import java.security.Principal;
    33| import java.util.ArrayList;
    34| import java.util.Arrays;
    35| import java.util.List;
    36| import java.util.ResourceBundle;
    37| import java.util.stream.Collectors;
    38| /**
    39|  * <p>
    40|  * Returns user profile attributes, or empty strings if the user has not been
    41|  * validated. This tag has a single attribute, "property."
    42|  * The <code>property</code> attribute may contain one of the following
    43|  * case-insensitive values:
    44|  * </p>
    45|  * <ul>
    46|  * <li><code>created</code> - creation date</li>
    47|  * <li><code>email</code> - user's e-mail address</li>
    48|  * <li><code>fullname</code> - user's full name</li>
    49|  * <li><code>groups</code> - a sorted list of the groups a user belongs to</li>
    50|  * <li><code>loginname</code> - user's login name. If the current user does not have a profile, the user's login principal (such as one
    51|  * provided by a container login module, user cookie, or anonyous IP address), will supply the login name property</li>
    52|  * <li><code>roles</code> - a sorted list of the roles a user possesses</li>
    53|  * <li><code>wikiname</code> - user's wiki name</li>
    54|  * <li><code>modified</code> - last modification date</li>
    55|  * <li><code>exists</code> - evaluates the body of the tag if user's profile exists in the user database</li>
    56|  * <li><code>new</code> - evaluates the body of the tag if user's profile does not exist in the user database</li>
    57|  * <li><code>canChangeLoginName</code> - always true if custom auth used; also true for container auth and current

# --- HUNK 2: Lines 135-198 ---
   135|             }
   136|         }
   137|         if( result != null ) {
   138|             pageContext.getOut().print( TextUtil.replaceEntities( result ) );
   139|         }
   140|         return SKIP_BODY;
   141|     }
   142|     public void setProperty( final String property )
   143|     {
   144|         m_prop = property.toLowerCase().trim();
   145|     }
   146|     /**
   147|      * Returns a sorted list of the {@link org.apache.wiki.auth.authorize.Group} objects a user possesses
   148|      * in his or her Session. The result is computed by consulting
   149|      * {@link org.apache.wiki.api.core.Session#getRoles()}
   150|      * and extracting those that are of type Group.
   151|      * @return the list of groups, sorted by name
   152|      */
   153|     public static String printGroups( final Context context ) {
   154|         final Principal[] roles = context.getWikiSession().getRoles();
   155|         final List< String > tempRoles;
   156|         final ResourceBundle rb = Preferences.getBundle( context, InternationalizationManager.CORE_BUNDLE );
   157|         tempRoles = Arrays.stream(roles).filter(role -> role instanceof GroupPrincipal).map(Principal::getName).collect(Collectors.toList());
   158|         if( tempRoles.size() == 0 ) {
   159|             return rb.getString( "userprofile.nogroups" );
   160|         }
   161|         final StringBuilder sb = new StringBuilder();
   162|         for( int i = 0; i < tempRoles.size(); i++ ) {
   163|             final String name = tempRoles.get( i );
   164|             sb.append( name );
   165|             if( i < ( tempRoles.size() - 1 ) ) {
   166|                 sb.append( ',' );
   167|                 sb.append( ' ' );
   168|             }
   169|         }
   170|         return sb.toString();
   171|     }
   172|     /**
   173|      * Returns a sorted list of the {@link org.apache.wiki.auth.authorize.Role} objects a user possesses
   174|      * in his or her Session. The result is computed by consulting
   175|      * {@link org.apache.wiki.api.core.Session#getRoles()}
   176|      * and extracting those that are of type Role.
   177|      * @return the list of roles, sorted by name
   178|      */
   179|     public static String printRoles( final Context context ) {
   180|         final Principal[] roles = context.getWikiSession().getRoles();
   181|         final List< String > tempRoles;
   182|         final ResourceBundle rb = Preferences.getBundle( context, InternationalizationManager.CORE_BUNDLE );
   183|         tempRoles = Arrays.stream(roles).filter(role -> role instanceof Role).map(Principal::getName).collect(Collectors.toList());
   184|         if( tempRoles.size() == 0 ) {
   185|             return rb.getString( "userprofile.noroles" );
   186|         }
   187|         final StringBuilder sb = new StringBuilder();
   188|         for( int i = 0; i < tempRoles.size(); i++ ) {
   189|             final String name = tempRoles.get( i );
   190|             sb.append( name );
   191|             if( i < ( tempRoles.size() - 1 ) ) {
   192|                 sb.append( ',' );
   193|                 sb.append( ' ' );
   194|             }
   195|         }
   196|         return sb.toString();
   197|     }
   198| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/tasks/auth/SaveUserProfileTask.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-36 ---
     1| /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.tasks.auth;
    18| import org.apache.logging.log4j.LogManager;
    19| import org.apache.logging.log4j.Logger;
    20| import org.apache.wiki.api.core.Context;
    21| import org.apache.wiki.api.core.ContextEnum;
    22| import org.apache.wiki.api.exceptions.WikiException;
    23| import org.apache.wiki.auth.UserManager;
    24| import org.apache.wiki.auth.user.UserProfile;
    25| import org.apache.wiki.i18n.InternationalizationManager;
    26| import org.apache.wiki.tasks.TasksManager;
    27| import org.apache.wiki.util.MailUtil;
    28| import org.apache.wiki.workflow.Outcome;
    29| import org.apache.wiki.workflow.Task;
    30| import org.apache.wiki.workflow.WorkflowManager;
    31| import javax.mail.MessagingException;
    32| import javax.mail.internet.AddressException;
    33| import java.util.Locale;
    34| /**
    35|  * Handles the actual profile save action. 
    36|  */


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/ui/Installer.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 24-64 ---
    24| import org.apache.wiki.auth.WikiPrincipal;
    25| import org.apache.wiki.auth.WikiSecurityException;
    26| import org.apache.wiki.auth.authorize.Group;
    27| import org.apache.wiki.auth.authorize.GroupManager;
    28| import org.apache.wiki.auth.user.UserDatabase;
    29| import org.apache.wiki.auth.user.UserProfile;
    30| import org.apache.wiki.i18n.InternationalizationManager;
    31| import org.apache.wiki.pages.PageManager;
    32| import org.apache.wiki.providers.FileSystemProvider;
    33| import org.apache.wiki.util.TextUtil;
    34| import javax.servlet.ServletConfig;
    35| import javax.servlet.http.HttpServletRequest;
    36| import java.io.File;
    37| import java.io.IOException;
    38| import java.io.OutputStream;
    39| import java.nio.file.Files;
    40| import java.text.MessageFormat;
    41| import java.util.Properties;
    42| import java.util.ResourceBundle;
    43| import java.util.Set;
    44| import java.util.stream.Collectors;
    45| /**
    46|  * Manages JSPWiki installation on behalf of <code>admin/Install.jsp</code>. The contents of this class were previously part of
    47|  * <code>Install.jsp</code>.
    48|  *
    49|  * @since 2.4.20
    50|  */
    51| public class Installer {
    52|     public static final String ADMIN_ID = "admin";
    53|     public static final String ADMIN_NAME = "Administrator";
    54|     public static final String INSTALL_INFO = "Installer.Info";
    55|     public static final String INSTALL_ERROR = "Installer.Error";
    56|     public static final String INSTALL_WARNING = "Installer.Warning";
    57|     public static final String APP_NAME = Engine.PROP_APPNAME;
    58|     public static final String STORAGE_DIR = AttachmentProvider.PROP_STORAGEDIR;
    59|     public static final String PAGE_DIR = FileSystemProvider.PROP_PAGEDIR;
    60|     public static final String WORK_DIR = Engine.PROP_WORKDIR;
    61|     public static final String ADMIN_GROUP = "Admin";
    62|     public static final String PROPFILENAME = "jspwiki-custom.properties" ;
    63|     public static final String TMP_DIR = System.getProperty("java.io.tmpdir");
    64|     private final Session m_session;

# --- HUNK 2: Lines 114-157 ---
   114|             profile.setFullname( ADMIN_NAME );
   115|             profile.setPassword( password );
   116|             userDb.save( profile );
   117|         }
   118|         final GroupManager groupMgr = m_engine.getManager( GroupManager.class );
   119|         Group group;
   120|         try {
   121|             group = groupMgr.getGroup( ADMIN_GROUP );
   122|             group.add( new WikiPrincipal( ADMIN_NAME ) );
   123|         } catch( final NoSuchPrincipalException e ) {
   124|             group = groupMgr.parseGroup( ADMIN_GROUP, ADMIN_NAME, true );
   125|         }
   126|         groupMgr.setGroup( m_session, group );
   127|         return password;
   128|     }
   129|     /**
   130|      * Returns the properties as a "key=value" string separated by newlines
   131|      * @return the string
   132|      */
   133|     public String getPropertiesList() {
   134|         final String result;
   135|         final Set< String > keys = m_props.stringPropertyNames();
   136|         result = keys.stream().map(key -> key + " = " + m_props.getProperty(key) + "\n").collect(Collectors.joining());
   137|         return result;
   138|     }
   139|     public String getPropertiesPath() {
   140|         return m_propertyFile.getAbsolutePath();
   141|     }
   142|     /**
   143|      * Returns a property from the Engine's properties.
   144|      * @param key the property key
   145|      * @return the property value
   146|      */
   147|     public String getProperty( final String key ) {
   148|         return m_props.getProperty( key );
   149|     }
   150|     public void parseProperties () {
   151|         final ResourceBundle rb = ResourceBundle.getBundle( InternationalizationManager.CORE_BUNDLE, m_session.getLocale() );
   152|         m_validated = false;
   153|         String nullValue = m_props.getProperty( APP_NAME, rb.getString( "install.installer.default.appname" ) );
   154|         parseProperty( APP_NAME, nullValue );
   155|         nullValue = m_props.getProperty( PAGE_DIR, rb.getString( "install.installer.default.pagedir" ) );
   156|         parseProperty( PAGE_DIR, nullValue );
   157|         sanitizePath( PAGE_DIR );


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/ui/WikiRequestWrapper.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 5-45 ---
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.    
    16|  */
    17| package org.apache.wiki.ui;
    18| import org.apache.wiki.api.core.Engine;
    19| import org.apache.wiki.api.core.Session;
    20| import org.apache.wiki.auth.SessionMonitor;
    21| import org.apache.wiki.auth.authorize.Role;
    22| import javax.servlet.http.HttpServletRequest;
    23| import javax.servlet.http.HttpServletRequestWrapper;
    24| import java.security.Principal;
    25| import java.util.Arrays;
    26| /**
    27|  * Servlet request wrapper that encapsulates an incoming HTTP request and overrides its security methods so that the request returns
    28|  * JSPWiki-specific values.
    29|  * 
    30|  * @since 2.8
    31|  */
    32| public class WikiRequestWrapper extends HttpServletRequestWrapper {
    33|     private final Session m_session;
    34|     /**
    35|      * Constructs a new wrapped request.
    36|      * 
    37|      * @param engine the wiki engine
    38|      * @param request the request to wrap
    39|      */
    40|     public WikiRequestWrapper( final Engine engine, final HttpServletRequest request ) {
    41|         super( request );
    42|         m_session = SessionMonitor.getInstance( engine ).find( request.getSession() );
    43|     }
    44|     /**
    45|      * Returns the remote user for the HTTP request, taking into account both container and JSPWiki custom authentication status.

# --- HUNK 2: Lines 69-91 ---
    69|             return super.getUserPrincipal();
    70|         }
    71|         if( m_session.isAuthenticated() ) {
    72|             return m_session.getLoginPrincipal();
    73|         }
    74|         return null;
    75|     }
    76|     /**
    77|      * Determines whether the current user possesses a supplied role, taking into account both container and JSPWIki custom authentication
    78|      * status. Specifically, if the wrapped request shows that the user possesses the role, this method returns <code>true</code>. If not,
    79|      * this method iterates through the built-in Role objects (<em>e.g.</em>, ANONYMOUS, ASSERTED, AUTHENTICATED) returned by
    80|      * {@link Session#getRoles()} and checks to see if any of these principals' names match the supplied role.
    81|      */
    82|     @Override
    83|     public boolean isUserInRole( final String role ) {
    84|         final boolean hasContainerRole = super.isUserInRole(role);
    85|         if( hasContainerRole ) {
    86|             return true;
    87|         }
    88|         final Principal[] principals = m_session.getRoles();
    89|         return Arrays.stream(principals).filter(value -> value instanceof Role).map(value -> (Role) value).anyMatch(principal -> Role.isBuiltInRole(principal) && principal.getName().equals(role));
    90|     }
    91| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/ui/admin/DefaultAdminBeanManager.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 144-184 ---
   144|         }
   145|         for( final ModuleManager moduleManager : m_engine.getManagers( ModuleManager.class ) ) {
   146|             registerBeans( moduleManager.modules() );
   147|         }
   148|     }
   149|     /* (non-Javadoc)
   150| 	 * @see org.apache.wiki.ui.admin.AdminBeanManager#getAllBeans()
   151| 	 */
   152|     @Override
   153| 	public List< AdminBean > getAllBeans() {
   154|         if( m_allBeans == null ) {
   155|         	reload();
   156|         }
   157|         return m_allBeans;
   158|     }
   159|     /* (non-Javadoc)
   160| 	 * @see org.apache.wiki.ui.admin.AdminBeanManager#findBean(java.lang.String)
   161| 	 */
   162|     @Override
   163| 	public AdminBean findBean( final String id ) {
   164|         return m_allBeans.stream().filter(ab -> ab.getId().equals(id)).findFirst().orElse(null);
   165|     }
   166|     /**
   167|      *  Provides a JDK 1.5-compliant version of the MBeanServerFactory. This will simply bind to the
   168|      *  platform MBeanServer.
   169|      */
   170|     private static final class MBeanServerFactory15 {
   171|         private MBeanServerFactory15()
   172|         {}
   173|         public static MBeanServer getServer() {
   174|             return ManagementFactory.getPlatformMBeanServer();
   175|         }
   176|     }
   177|     /**
   178|      *  Returns the type identifier for a string type.
   179|      *
   180|      *  @param type A type string.
   181|      *  @return A type value.
   182|      */
   183|     @Override
   184| 	public int getTypeFromString( final String type ) {


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/ui/progress/DefaultProgressManager.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 100-136 ---
   100|         /**
   101|          *  Returns upload progress in percents so far.
   102|          *
   103|          *  @param progressId The string representation of the progress ID that you want to know the progress of.
   104|          *  @return a value between 0 to 100 indicating the progress
   105|          */
   106|         public int getProgress( final String progressId )
   107|         {
   108|             return DefaultProgressManager.this.getProgress( progressId );
   109|         }
   110|         @Override
   111|         public String getServletMapping() {
   112|         	return JSON_PROGRESSTRACKER;
   113|         }
   114|         @Override
   115|         public void service( final HttpServletRequest req,
   116|                              final HttpServletResponse resp,
   117|                              final String actionName,
   118|                              final List< String > params ) throws IOException {
   119|         	LOG.debug( "ProgressManager.doGet() START" );
   120|         	if( params.isEmpty() ) {
   121|         		return;
   122|         	}
   123|         	final String progressId = params.get(0);
   124|         	LOG.debug( "progressId=" + progressId );
   125|         	String progressString = "";
   126|         	try {
   127|         		progressString = Integer.toString( getProgress( progressId ) );
   128|         	} catch( final IllegalArgumentException e ) { // ignore
   129|         		LOG.debug( "progressId " + progressId + " is no longer valid" );
   130|         	}
   131|         	LOG.debug( "progressString=" + progressString );
   132|         	resp.getWriter().write( progressString );
   133|         	LOG.debug( "ProgressManager.doGet() DONE" );
   134|         }
   135|     }
   136| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/variables/DefaultVariableManager.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 21-61 ---
    21| import org.apache.wiki.api.core.Context;
    22| import org.apache.wiki.api.core.Page;
    23| import org.apache.wiki.api.core.Session;
    24| import org.apache.wiki.api.exceptions.NoSuchVariableException;
    25| import org.apache.wiki.api.filters.PageFilter;
    26| import org.apache.wiki.api.providers.WikiProvider;
    27| import org.apache.wiki.attachment.AttachmentManager;
    28| import org.apache.wiki.filters.FilterManager;
    29| import org.apache.wiki.i18n.InternationalizationManager;
    30| import org.apache.wiki.modules.InternalModule;
    31| import org.apache.wiki.pages.PageManager;
    32| import org.apache.wiki.preferences.Preferences;
    33| import javax.servlet.http.HttpServletRequest;
    34| import javax.servlet.http.HttpSession;
    35| import java.lang.reflect.Method;
    36| import java.security.Principal;
    37| import java.util.Date;
    38| import java.util.List;
    39| import java.util.Properties;
    40| import java.util.ResourceBundle;
    41| import java.util.stream.Collectors;
    42| /**
    43|  *  Manages variables.  Variables are case-insensitive.  A list of all available variables is on a Wiki page called "WikiVariables".
    44|  *
    45|  *  @since 1.9.20.
    46|  */
    47| public class DefaultVariableManager implements VariableManager {
    48|     private static final Logger LOG = LogManager.getLogger( DefaultVariableManager.class );
    49|     /**
    50|      *  Contains a list of those properties that shall never be shown. Put names here in lower case.
    51|      */
    52|     static final String[] THE_BIG_NO_NO_LIST = {
    53|         "jspwiki.auth.masterpassword"
    54|     };
    55|     /**
    56|      *  Creates a VariableManager object using the property list given.
    57|      *  @param props The properties.
    58|      */
    59|     public DefaultVariableManager( final Properties props ) {
    60|     }
    61|     /**

# --- HUNK 2: Lines 230-273 ---
   230|             return m_context.getEngine().getContentEncoding().displayName();
   231|         }
   232|         public String getTotalpages() {
   233|             return Integer.toString( m_context.getEngine().getManager( PageManager.class ).getTotalPageCount() );
   234|         }
   235|         public String getPageprovider() {
   236|             return m_context.getEngine().getManager( PageManager.class ).getCurrentProvider();
   237|         }
   238|         public String getPageproviderdescription() {
   239|             return m_context.getEngine().getManager( PageManager.class ).getProviderDescription();
   240|         }
   241|         public String getAttachmentprovider() {
   242|             final WikiProvider p = m_context.getEngine().getManager( AttachmentManager.class ).getCurrentProvider();
   243|             return (p != null) ? p.getClass().getName() : "-";
   244|         }
   245|         public String getAttachmentproviderdescription() {
   246|             final WikiProvider p = m_context.getEngine().getManager( AttachmentManager.class ).getCurrentProvider();
   247|             return (p != null) ? p.getProviderInfo() : "-";
   248|         }
   249|         public String getInterwikilinks() {
   250|             return m_context.getEngine().getAllInterWikiLinks().stream().map(link -> link + " --> " + m_context.getEngine().getInterWikiURL(link)).collect(Collectors.joining(", "));
   251|         }
   252|         public String getInlinedimages() {
   253|             return m_context.getEngine().getAllInlinedImagePatterns().stream().collect(Collectors.joining(", "));
   254|         }
   255|         public String getPluginpath() {
   256|             final String s = m_context.getEngine().getPluginSearchPath();
   257|             return ( s == null ) ? "-" : s;
   258|         }
   259|         public String getBaseurl()
   260|         {
   261|             return m_context.getEngine().getBaseURL();
   262|         }
   263|         public String getUptime() {
   264|             final Date now = new Date();
   265|             long secondsRunning = ( now.getTime() - m_context.getEngine().getStartTime().getTime() ) / 1_000L;
   266|             final long seconds = secondsRunning % 60;
   267|             final long minutes = (secondsRunning /= 60) % 60;
   268|             final long hours = (secondsRunning /= 60) % 24;
   269|             final long days = secondsRunning /= 24;
   270|             return days + "d, " + hours + "h " + minutes + "m " + seconds + "s";
   271|         }
   272|         public String getLoginstatus() {
   273|             final Session session = m_context.getWikiSession();


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/workflow/DefaultWorkflowManager.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 24-64 ---
    24| import org.apache.wiki.api.core.Session;
    25| import org.apache.wiki.api.exceptions.WikiException;
    26| import org.apache.wiki.auth.AuthorizationManager;
    27| import org.apache.wiki.auth.acl.UnresolvedPrincipal;
    28| import org.apache.wiki.event.WikiEvent;
    29| import org.apache.wiki.event.WikiEventEmitter;
    30| import org.apache.wiki.event.WorkflowEvent;
    31| import org.apache.wiki.util.TextUtil;
    32| import java.io.*;
    33| import java.nio.file.Files;
    34| import java.security.Principal;
    35| import java.util.*;
    36| import java.util.concurrent.ConcurrentHashMap;
    37| import java.util.concurrent.CopyOnWriteArrayList;
    38| /**
    39|  * <p>
    40|  * Monitor class that tracks running Workflows. The WorkflowManager also keeps track of the names of
    41|  * users or groups expected to approve particular Workflows.
    42|  * </p>
    43|  */
    44| public class DefaultWorkflowManager implements WorkflowManager, Serializable {
    45|     private static final Logger LOG = LogManager.getLogger( DefaultWorkflowManager.class );
    46|     static final String SERIALIZATION_FILE = "wkflmgr.ser";
    47|     /** We use this also a generic serialization id */
    48|     private static final long serialVersionUID = 6L;
    49|     DecisionQueue m_queue;
    50|     Set< Workflow > m_workflows;
    51|     final Map< String, Principal > m_approvers;
    52|     Queue< Workflow > m_completed;
    53|     private Engine m_engine;
    54|     private int retainCompleted;
    55|     /**
    56|      * Constructs a new WorkflowManager, with an empty workflow cache.
    57|      */
    58|     public DefaultWorkflowManager() {
    59|         m_workflows = ConcurrentHashMap.newKeySet();
    60|         m_approvers = new ConcurrentHashMap<>();
    61|         m_queue = new DecisionQueue();
    62|         WikiEventEmitter.attach( this );
    63|     }
    64|     /**

# --- HUNK 2: Lines 190-231 ---
   190|     }
   191|     /**
   192|      * Returns the DecisionQueue associated with this WorkflowManager
   193|      *
   194|      * @return the decision queue
   195|      */
   196|     @Override
   197|     public DecisionQueue getDecisionQueue() {
   198|         return m_queue;
   199|     }
   200|     /**
   201|      * {@inheritDoc}
   202|      */
   203|     @Override
   204|     public List< Workflow > getOwnerWorkflows( final Session session ) {
   205|         final List< Workflow > workflows = new ArrayList<>();
   206|         if ( session.isAuthenticated() ) {
   207|             final Principal[] sessionPrincipals = session.getPrincipals();
   208|             for( final Workflow w : m_workflows ) {
   209|                 final Principal owner = w.getOwner();
   210|                 if (Arrays.stream(sessionPrincipals).anyMatch(sessionPrincipal -> sessionPrincipal.equals(owner))) {
   211|                     workflows.add(w);
   212|                 }
   213|             }
   214|         }
   215|         return workflows;
   216|     }
   217|     /**
   218|      * Listens for {@link WorkflowEvent} objects emitted by Workflows. In particular, this method listens for {@link WorkflowEvent#CREATED},
   219|      * {@link WorkflowEvent#ABORTED}, {@link WorkflowEvent#COMPLETED} and {@link WorkflowEvent#DQ_REMOVAL} events. If a workflow is created,
   220|      * it is automatically added to the cache. If one is aborted or completed, it is automatically removed. If a removal from decision queue
   221|      * is issued, the current step from workflow, which is assumed to be a {@link Decision}, is removed from the {@link DecisionQueue}.
   222|      * 
   223|      * @param event the event passed to this listener
   224|      */
   225|     @Override
   226|     public void actionPerformed( final WikiEvent event ) {
   227|         if( event instanceof WorkflowEvent ) {
   228|             if( event.getSrc() instanceof Workflow ) {
   229|                 final Workflow workflow = event.getSrc();
   230|                 switch( event.getType() ) {
   231|                 case WorkflowEvent.ABORTED   :


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/xmlrpc/RPCHandler.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 17-92 ---
    17| package org.apache.wiki.xmlrpc;
    18| import org.apache.wiki.LinkCollector;
    19| import org.apache.wiki.api.core.Attachment;
    20| import org.apache.wiki.api.core.Context;
    21| import org.apache.wiki.api.core.ContextEnum;
    22| import org.apache.wiki.api.core.Page;
    23| import org.apache.wiki.api.spi.Wiki;
    24| import org.apache.wiki.auth.permissions.PagePermission;
    25| import org.apache.wiki.auth.permissions.PermissionFactory;
    26| import org.apache.wiki.pages.PageManager;
    27| import org.apache.wiki.render.RenderingManager;
    28| import org.apache.wiki.util.TextUtil;
    29| import org.apache.xmlrpc.XmlRpcException;
    30| import java.nio.charset.StandardCharsets;
    31| import java.util.Calendar;
    32| import java.util.Collection;
    33| import java.util.Date;
    34| import java.util.Hashtable;
    35| import java.util.Set;
    36| import java.util.Vector;
    37| import java.util.stream.Collectors;
    38| /**
    39|  *  Provides handlers for all RPC routines.
    40|  *
    41|  *  @since 1.6.6
    42|  */
    43| public class RPCHandler extends AbstractRPCHandler {
    44|     /**
    45|      *  Converts Java string into RPC string.
    46|      */
    47|     private String toRPCString( final String src )
    48|     {
    49|         return TextUtil.urlEncodeUTF8( src );
    50|     }
    51|     /**
    52|      *  Converts RPC string (UTF-8, url encoded) into Java string.
    53|      */
    54|     private String fromRPCString( final String src )
    55|     {
    56|         return TextUtil.urlDecodeUTF8( src );
    57|     }
    58|     /**
    59|      *  Transforms a Java string into UTF-8.
    60|      */
    61|     private byte[] toRPCBase64( final String src )
    62|     {
    63|         return src.getBytes( StandardCharsets.UTF_8 );
    64|     }
    65|     public String getApplicationName() {
    66|         checkPermission( PagePermission.VIEW );
    67|         return toRPCString(m_engine.getApplicationName());
    68|     }
    69|     public Vector< String > getAllPages() {
    70|         checkPermission( PagePermission.VIEW );
    71|         final Collection< Page > pages = m_engine.getManager( PageManager.class ).getRecentChanges();
    72|         return pages.stream().filter(p -> !(p instanceof Attachment)).map(p -> toRPCString(p.getName())).collect(Collectors.toCollection(Vector::new));
    73|     }
    74|     /**
    75|      *  Encodes a single wiki page info into a Hashtable.
    76|      */
    77|     @Override
    78|     protected Hashtable<String,Object> encodeWikiPage( final Page page ) {
    79|         final Hashtable<String, Object> ht = new Hashtable<>();
    80|         ht.put( "name", toRPCString(page.getName()) );
    81|         final Date d = page.getLastModified();
    82|         final Calendar cal = Calendar.getInstance();
    83|         cal.setTime( d );
    84|         cal.add( Calendar.MILLISECOND,
    85|                  - (cal.get( Calendar.ZONE_OFFSET ) +
    86|                     (cal.getTimeZone().inDaylightTime( d ) ? cal.get( Calendar.DST_OFFSET ) : 0 ) ) );
    87|         ht.put( "lastModified", cal.getTime() );
    88|         ht.put( "version", page.getVersion() );
    89|         if( page.getAuthor() != null ) {
    90|             ht.put( "author", toRPCString( page.getAuthor() ) );
    91|         }
    92|         return ht;


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/xmlrpc/RPCHandlerUTF8.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 14-69 ---
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.xmlrpc;
    18| import org.apache.wiki.LinkCollector;
    19| import org.apache.wiki.api.core.Attachment;
    20| import org.apache.wiki.api.core.Context;
    21| import org.apache.wiki.api.core.ContextEnum;
    22| import org.apache.wiki.api.core.Page;
    23| import org.apache.wiki.api.spi.Wiki;
    24| import org.apache.wiki.auth.permissions.PagePermission;
    25| import org.apache.wiki.auth.permissions.PermissionFactory;
    26| import org.apache.wiki.pages.PageManager;
    27| import org.apache.wiki.render.RenderingManager;
    28| import org.apache.xmlrpc.XmlRpcException;
    29| import java.util.Calendar;
    30| import java.util.Date;
    31| import java.util.Hashtable;
    32| import java.util.Set;
    33| import java.util.Vector;
    34| import java.util.stream.Collectors;
    35| /**
    36|  *  Provides handlers for all RPC routines.  These routines are used by
    37|  *  the UTF-8 interface.
    38|  *
    39|  *  @since 1.6.13
    40|  */
    41| public class RPCHandlerUTF8 extends AbstractRPCHandler {
    42|     public String getApplicationName() {
    43|         checkPermission( PagePermission.VIEW );
    44|         return m_engine.getApplicationName();
    45|     }
    46|     public Vector< String > getAllPages() {
    47|         checkPermission( PagePermission.VIEW );
    48|         final Set< Page > pages = m_engine.getManager( PageManager.class ).getRecentChanges();
    49|         return pages.stream().filter(p -> !(p instanceof Attachment)).map(Page::getName).collect(Collectors.toCollection(Vector::new));
    50|     }
    51|     /**
    52|      *  Encodes a single wiki page info into a Hashtable.
    53|      */
    54|     @Override
    55|     protected Hashtable<String, Object> encodeWikiPage( final Page page ) {
    56|         final Hashtable<String, Object> ht = new Hashtable<>();
    57|         ht.put( "name", page.getName() );
    58|         final Date d = page.getLastModified();
    59|         final Calendar cal = Calendar.getInstance();
    60|         cal.setTime( d );
    61|         cal.add( Calendar.MILLISECOND,
    62|                  - (cal.get( Calendar.ZONE_OFFSET ) +
    63|                     (cal.getTimeZone().inDaylightTime( d ) ? cal.get( Calendar.DST_OFFSET ) : 0 )) );
    64|         ht.put( "lastModified", cal.getTime() );
    65|         ht.put( "version", page.getVersion() );
    66|         if( page.getAuthor() != null ) {
    67|             ht.put( "author", page.getAuthor() );
    68|         }
    69|         return ht;


# ====================================================================
# FILE: jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/LocalFootnoteLinkNodePostProcessorState.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-36 ---
     1| /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.markdown.extensions.jspwikilinks.postprocessor;
    18| import com.vladsch.flexmark.util.ast.Node;
    19| import com.vladsch.flexmark.util.ast.NodeTracker;
    20| import com.vladsch.flexmark.util.sequence.CharSubSequence;
    21| import org.apache.wiki.api.core.Context;
    22| import org.apache.wiki.api.core.ContextEnum;
    23| import org.apache.wiki.markdown.nodes.JSPWikiLink;
    24| /**
    25|  * {@link NodePostProcessorState} which further post processes local footnote links.
    26|  */
    27| public class LocalFootnoteLinkNodePostProcessorState implements NodePostProcessorState< JSPWikiLink > {
    28|     final Context wikiContext;
    29|     public LocalFootnoteLinkNodePostProcessorState( final Context wikiContext ) {
    30|         this.wikiContext = wikiContext;
    31|     }
    32|     /**
    33|      * {@inheritDoc}
    34|      *
    35|      * @see NodePostProcessorState#process(NodeTracker, Node) 
    36|      */


# ====================================================================
# FILE: jspwiki-util/src/main/java/org/apache/wiki/util/CommentedProperties.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 69-109 ---
    69|     @Override
    70|     public synchronized void load(final Reader in ) throws IOException
    71|     {
    72|         m_propertyString = FileUtil.readContents( in );
    73|         super.load( new ByteArrayInputStream( m_propertyString.getBytes(StandardCharsets.ISO_8859_1) ) );
    74|     }
    75|     /**
    76|      * {@inheritDoc}
    77|      */
    78|     @Override
    79|     public synchronized Object setProperty(final String key, final String value )
    80|     {
    81|         return put(key, value);
    82|     }
    83|     /**
    84|      * {@inheritDoc}
    85|      */
    86|     @Override
    87|     public synchronized void store(final OutputStream out, final String comments ) throws IOException
    88|     {
    89|         final byte[] bytes = m_propertyString.getBytes( StandardCharsets.ISO_8859_1 );
    90|         FileUtil.copyContents( new ByteArrayInputStream( bytes ), out );
    91|         out.flush();
    92|     }
    93|     /**
    94|      * {@inheritDoc}
    95|      */
    96|     @Override
    97|     public synchronized Object put(final Object arg0, final Object arg1 )
    98|     {
    99|         writeProperty( arg0, arg1 );
   100|         return super.put(arg0, arg1);
   101|     }
   102|     /**
   103|      * {@inheritDoc}
   104|      */
   105|     @Override
   106|     public synchronized void putAll(final Map< ? , ? > arg0 )
   107|     {
   108|         for (final Entry<?, ?> value : arg0.entrySet()) {
   109|             @SuppressWarnings("unchecked") final Entry<Object, Object> entry = (Entry<Object, Object>) value;


# ====================================================================
# FILE: jspwiki-util/src/main/java/org/apache/wiki/util/PropertyReader.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 4-44 ---
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.    
    16|  */
    17| package org.apache.wiki.util;
    18| import org.apache.commons.lang3.StringUtils;
    19| import org.apache.commons.lang3.Validate;
    20| import org.apache.logging.log4j.LogManager;
    21| import org.apache.logging.log4j.Logger;
    22| import javax.servlet.ServletContext;
    23| import java.io.*;
    24| import java.nio.file.Paths;
    25| import java.util.*;
    26| import java.util.stream.Collectors;
    27| import java.nio.file.Files;
    28| /**
    29|  * Property Reader for the WikiEngine. Reads the properties for the WikiEngine
    30|  * and implements the feature of cascading properties and variable substitution,
    31|  * which come in handy in a multi wiki installation environment: It reduces the
    32|  * need for (shell) scripting in order to generate different jspwiki.properties
    33|  * to a minimum.
    34|  *
    35|  * @since 2.5.x
    36|  */
    37| public final class PropertyReader {
    38| 	private static final Logger LOG = LogManager.getLogger( PropertyReader.class );
    39|     /**
    40|      * Path to the base property file, usually overridden by values provided in
    41|      * a jspwiki-custom.properties file {@value #DEFAULT_JSPWIKI_CONFIG}
    42|      */
    43|     public static final String DEFAULT_JSPWIKI_CONFIG = "/ini/jspwiki.properties";
    44|     /**

# --- HUNK 2: Lines 199-239 ---
   199|     }
   200|     /**
   201|      *  Implement the cascade functionality.
   202|      *
   203|      * @param context             where to read the cascade from
   204|      * @param defaultProperties   properties to merge the cascading properties to
   205|      * @since 2.5.x
   206|      */
   207|     private static void loadWebAppPropsCascade( final ServletContext context, final Properties defaultProperties ) {
   208|         if( getInitParameter( context, PARAM_CUSTOMCONFIG_CASCADEPREFIX + "1" ) == null ) {
   209|             LOG.debug( " No cascading properties defined for this context" );
   210|             return;
   211|         }
   212|         int depth = 0;
   213|         while( true ) {
   214|             depth++;
   215|             final String propertyFile = getInitParameter( context, PARAM_CUSTOMCONFIG_CASCADEPREFIX + depth );
   216|             if( propertyFile == null ) {
   217|                 break;
   218|             }
   219|             try( final InputStream propertyStream = Files.newInputStream(Paths.get(( propertyFile ) ))) {
   220|                 LOG.info( " Reading additional properties from " + propertyFile + " and merge to cascade." );
   221|                 final Properties additionalProps = new Properties();
   222|                 additionalProps.load( propertyStream );
   223|                 defaultProperties.putAll( additionalProps );
   224|             } catch( final Exception e ) {
   225|                 LOG.error( "JSPWiki: Unable to load and setup properties from " + propertyFile + "." + e.getMessage() );
   226|             }
   227|         }
   228|     }
   229|     /**
   230|      *  You define a property variable by using the prefix "var.x" as a property. In property values you can then use the "$x" identifier
   231|      *  to use this variable.
   232|      *
   233|      *  For example, you could declare a base directory for all your files like this and use it in all your other property definitions with
   234|      *  a "$basedir". Note that it does not matter if you define the variable before its usage.
   235|      *  <pre>
   236|      *  var.basedir = /p/mywiki;
   237|      *  jspwiki.fileSystemProvider.pageDir =         $basedir/www/
   238|      *  jspwiki.basicAttachmentProvider.storageDir = $basedir/www/
   239|      *  jspwiki.workDir =                            $basedir/wrk/


# ====================================================================
# FILE: jspwiki-util/src/main/java/org/apache/wiki/util/TextUtil.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 9-50 ---
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.util;
    18| import org.apache.commons.lang3.StringUtils;
    19| import org.apache.logging.log4j.LogManager;
    20| import org.apache.logging.log4j.Logger;
    21| import java.io.File;
    22| import java.io.IOException;
    23| import java.nio.charset.Charset;
    24| import java.nio.charset.StandardCharsets;
    25| import java.security.SecureRandom;
    26| import java.util.NoSuchElementException;
    27| import java.util.Properties;
    28| import java.util.Random;
    29| import java.util.stream.Collectors;
    30| import java.util.stream.IntStream;
    31| /**
    32|  *  Contains a number of static utility methods.
    33|  */
    34| public final class TextUtil {
    35|     private static final Logger LOG = LogManager.getLogger( TextUtil.class );
    36|     static final String HEX_DIGITS = "0123456789ABCDEF";
    37|     /** Pick from some letters that won't be easily mistaken for each other to compose passwords. So, for example, omit o, O and 0, or 1, l and L.*/
    38|     static final String PWD_BASE = "abcdefghjkmnpqrstuvwxyzABCDEFGHJKMNPQRSTUVWXYZ23456789+@";
    39|     /** Length of password. {@link #generateRandomPassword() */
    40|     public static final int PASSWORD_LENGTH = 8;
    41|     /** Lists all punctuation characters allowed in WikiMarkup. These will not be cleaned away. This is for compatibility for older versions
    42|      of JSPWiki. */
    43|     public static final String LEGACY_CHARS_ALLOWED = "._";
    44|     /** Lists all punctuation characters allowed in page names. */
    45|     public static final String PUNCTUATION_CHARS_ALLOWED = " ()&+,-=._$";
    46|     /** Private constructor prevents instantiation. */
    47|     private TextUtil() {}
    48|     /**
    49|      *  java.net.URLEncoder.encode() method in JDK < 1.4 is buggy.  This duplicates its functionality.
    50|      *

# --- HUNK 2: Lines 654-694 ---
   654|             start += 4; // Skip this "----"
   655|             while (start < pagedata.length() && pagedata.charAt( start ) == '-') {
   656|                 start++;
   657|             }
   658|             previous = start;
   659|         }
   660|         if( ++tags == section ) {
   661|             return pagedata.substring( previous );
   662|         }
   663|         throw new IllegalArgumentException( "There is no section no. " + section + " on the page." );
   664|     }
   665|     /**
   666|      *  A simple routine which just repeates the arguments.  This is useful for creating something like a line or something.
   667|      *
   668|      *  @param what String to repeat
   669|      *  @param times How many times to repeat the string.
   670|      *  @return Guess what?
   671|      *  @since 2.1.98.
   672|      */
   673|     public static String repeatString( final String what, final int times ) {
   674|         return IntStream.range(0, times).mapToObj(i -> what).collect(Collectors.joining());
   675|     }
   676|     /**
   677|      *  Converts a string from the Unicode representation into something that can be embedded in a java
   678|      *  properties file.  All references outside the ASCII range are replaced with \\uXXXX.
   679|      *
   680|      *  @param s The string to convert
   681|      *  @return the ASCII string
   682|      */
   683|     public static String native2Ascii( final String s ) {
   684|         final StringBuilder sb = new StringBuilder();
   685|         for( int i = 0; i < s.length(); i++ ) {
   686|             final char aChar = s.charAt(i);
   687|             if( ( aChar < 0x0020 ) || ( aChar > 0x007e ) ) {
   688|                 sb.append( '\\');
   689|                 sb.append( 'u');
   690|                 sb.append( toHex( ( aChar >> 12 ) & 0xF ) );
   691|                 sb.append( toHex( ( aChar >>  8 ) & 0xF ) );
   692|                 sb.append( toHex( ( aChar >>  4 ) & 0xF ) );
   693|                 sb.append( toHex( aChar        & 0xF ) );
   694|             } else {

# --- HUNK 3: Lines 732-754 ---
   732|         if( s == null ) {
   733|         	return false;
   734|         }
   735|         if( s.length() > 1 && s.charAt(0) == '-' ) {
   736|         	s = s.substring( 1 );
   737|         }
   738|         for( int i = 0; i < s.length(); i++ ) {
   739|             if( !Character.isDigit( s.charAt( i ) ) ) {
   740|             	return false;
   741|             }
   742|         }
   743|         return true;
   744|     }
   745|     /**
   746|      * Generate a random String suitable for use as a temporary password.
   747|      *
   748|      * @return String suitable for use as a temporary password
   749|      * @since 2.4
   750|      */
   751|     public static String generateRandomPassword() {
   752|         return IntStream.range(0, PASSWORD_LENGTH).map(i -> (int) (RANDOM.nextDouble() * PWD_BASE.length())).mapToObj(index -> String.valueOf(PWD_BASE.charAt(index))).collect(Collectors.joining());
   753|     }
   754| }


# ====================================================================
# FILE: jspwiki-util/src/main/java/org/apache/wiki/util/TimedCounterList.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 114-158 ---
   114|         T t;
   115|         try
   116|         {
   117|             t = m_list.remove( index ).m_obj;
   118|         }
   119|         finally
   120|         {
   121|             m_lock.writeLock().unlock();
   122|         }
   123|         return t;
   124|     }
   125|     /**
   126|      *  Returns the count how many times this object is available in
   127|      *  this list, using equals().
   128|      *  
   129|      *  @param obj The object to count.
   130|      *  @return The count of the objects.
   131|      */
   132|     public int count(final T obj )
   133|     {
   134|         int c;
   135|         m_lock.readLock().lock();
   136|         try
   137|         {
   138|             c = (int) m_list.stream().filter(i -> i.m_obj.equals(obj)).count();
   139|         }
   140|         finally
   141|         {
   142|             m_lock.readLock().unlock();
   143|         }
   144|         return c;
   145|     }
   146|     /**
   147|      *  Performs a cleanup of all items older than maxage.
   148|      *  
   149|      *  @param maxage The maximum age in milliseconds after an item is removed.
   150|      */
   151|     public void cleanup(final long maxage )
   152|     {
   153|         m_lock.writeLock().lock();
   154|         try
   155|         {
   156|             final long now = System.currentTimeMillis();
   157|             for(final Iterator<CounterItem<T>> i = m_list.iterator(); i.hasNext(); )
   158|             {


# ====================================================================
# FILE: jspwiki-util/src/main/java/org/apache/wiki/util/XmlUtil.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 18-58 ---
    18| import org.apache.commons.lang3.StringUtils;
    19| import org.apache.logging.log4j.LogManager;
    20| import org.apache.logging.log4j.Logger;
    21| import org.jdom2.Document;
    22| import org.jdom2.Element;
    23| import org.jdom2.JDOMException;
    24| import org.jdom2.Text;
    25| import org.jdom2.filter.Filters;
    26| import org.jdom2.input.SAXBuilder;
    27| import org.jdom2.xpath.XPathExpression;
    28| import org.jdom2.xpath.XPathFactory;
    29| import java.io.IOException;
    30| import java.io.InputStream;
    31| import java.net.URL;
    32| import java.util.ArrayList;
    33| import java.util.Collections;
    34| import java.util.Enumeration;
    35| import java.util.HashSet;
    36| import java.util.List;
    37| import java.util.Set;
    38| import java.util.stream.Collectors;
    39| /**
    40|  *  Utility class to parse XML files.
    41|  *  <p>
    42|  *  This uses JDOM2 as its backing implementation.
    43|  *  </p>
    44|  *  
    45|  * @since 2.10
    46|  */
    47| public final class XmlUtil  {
    48| 	private static final String ALL_TEXT_NODES = "//text()";
    49| 	private static final Logger LOG = LogManager.getLogger( XmlUtil.class );
    50| 	private XmlUtil() {}
    51| 	/**
    52| 	 * Parses the given XML file and returns the requested nodes. If there's an error accessing or parsing the file, an
    53| 	 * empty list is returned.
    54| 	 * 
    55| 	 * @param xml file to parse; matches all resources from classpath, filters repeated items.
    56| 	 * @param requestedNodes requested nodes on the xml file
    57| 	 * @return the requested nodes of the XML file.
    58| 	 */

# --- HUNK 2: Lines 96-129 ---
    96| 				final XPathExpression< Element > xp = xpfac.compile( requestedNodes, Filters.element() );
    97| 				return xp.evaluate( doc );
    98| 			} catch( final IOException ioe ) {
    99| 				LOG.error( "Couldn't load all {} resources", xmlStream, ioe );
   100| 			} catch( final JDOMException jdome ) {
   101| 				LOG.error( "error parsing {} resources", xmlStream,  jdome );
   102| 			}
   103| 		}		
   104| 		return Collections.emptyList();
   105| 	}
   106| 	/**
   107| 	 * Renders all the text() nodes from the DOM tree. This is very useful for cleaning away all the XHTML.
   108| 	 *
   109| 	 * @param doc Dom tree
   110| 	 * @return String containing only the text from the provided Dom tree.
   111| 	 */
   112| 	public static String extractTextFromDocument( final Document doc ) {
   113| 		if( doc == null ) {
   114| 			return "";
   115| 		}
   116| 		final String sb;
   117| 		final List< ? > nodes = XPathFactory.instance().compile( ALL_TEXT_NODES ).evaluate( doc );
   118|         sb = nodes.stream().filter(el -> el instanceof Text).map(el -> ((Text) el).getValue()).collect(Collectors.joining());
   119| 		return sb;
   120| 	}
   121| 	public static Element getXPathElement( final Element base, final String expression ) {
   122| 		final List< ? > nodes = XPathFactory.instance().compile( expression ).evaluate( base );
   123| 		if( nodes == null || nodes.size() == 0 ) {
   124| 			return null;
   125| 		} else {
   126| 			return ( Element )nodes.get( 0 );
   127| 		}
   128| 	}
   129| }


# ====================================================================
# FILE: jspwiki-war/src/main/scripts/util/extend-array.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-30 ---
     1| /*
     2|     JSPWiki - a JSP-based WikiWiki clone.
     3|     Licensed to the Apache Software Foundation (ASF) under one
     4|     or more contributor license agreements.  See the NOTICE file
     5|     distributed with this work for additional information
     6|     regarding copyright ownership.  The ASF licenses this file
     7|     to you under the Apache License, Version 2.0 (the
     8|     "License"); fyou may not use this file except in compliance
     9|     with the License.  You may obtain a copy of the License at
    10|        http://www.apache.org/licenses/LICENSE-2.0
    11|     Unless required by applicable law or agreed to in writing,
    12|     software distributed under the License is distributed on an
    13|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    14|     KIND, either express or implied.  See the License for the
    15|     specific language governing permissions and limitations
    16|     under the License.
    17| */
    18| /*eslint-env browser */
    19| /*global $ */
    20| $.last = function(arr){
    21|     return (arr.length) ? arr[arr.length - 1] : null;
    22| }
    23| /*
    24| $.Array.last = function(arr) {
    25| 	return(arr[arr.length -1]);
    26| }
    27| Array.prototype.last = function{
    28|     return(this[this.length-1]);
    29| }
    30| */


# ====================================================================
# FILE: jspwiki-war/src/main/scripts/util/extend-event.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-57 ---
     1| /*
     2|     JSPWiki - a JSP-based WikiWiki clone.
     3|     Licensed to the Apache Software Foundation (ASF) under one
     4|     or more contributor license agreements.  See the NOTICE file
     5|     distributed with this work for additional information
     6|     regarding copyright ownership.  The ASF licenses this file
     7|     to you under the Apache License, Version 2.0 (the
     8|     "License"); fyou may not use this file except in compliance
     9|     with the License.  You may obtain a copy of the License at
    10|        http://www.apache.org/licenses/LICENSE-2.0
    11|     Unless required by applicable law or agreed to in writing,
    12|     software distributed under the License is distributed on an
    13|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    14|     KIND, either express or implied.  See the License for the
    15|     specific language governing permissions and limitations
    16|     under the License.
    17| */
    18| /*eslint-env browser */
    19| /*global $, $$, getElement */
    20| /**
    21|  *
    22|  */
    23| $.bind = function(element, eventNames, callback) {
    24|     element.addEvent(eventNames, callback);
    25| };
    26| /**
    27|  *
    28|  */
    29| $.unbind = function(element, eventNames, callback) {
    30|     element.removeEvent(eventNames, callback);
    31| };
    32| /**
    33|  * Similar to $.bind(), but callback will be called only once
    34|  */
    35| $.once = function(element, eventNames, callback) {
    36|     function once() {
    37|         $.unbind(element, eventNames, once);
    38|         return callback.apply(element, arguments);
    39|     }
    40|     $.bind(element, eventNames, once);
    41| };
    42| /**
    43|  * Event delegation
    44|  * @param {HTMLElement} element
    45|  * @param {string} eventNames
    46|  * @param {string} targetSelector - the selector to match the target of the event
    47|  * @param {function} callback
    48|  * @example:
    49|  *   $.delegate($("ul"), "click", "li", handleListItem);
    50|  */
    51| $.delegate = function(element, eventNames, targetSelector, callback) {
    52|     $.bind(element, eventNames, function(event) {
    53|         if (event.target.closest(targetSelector)) {
    54|             callback.call(event.target, event);
    55|         }
    56|     });
    57| };


# ====================================================================
# FILE: jspwiki-war/src/main/scripts/util/extend-form.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-74 ---
     1| /*
     2|     JSPWiki - a JSP-based WikiWiki clone.
     3|     Licensed to the Apache Software Foundation (ASF) under one
     4|     or more contributor license agreements.  See the NOTICE file
     5|     distributed with this work for additional information
     6|     regarding copyright ownership.  The ASF licenses this file
     7|     to you under the Apache License, Version 2.0 (the
     8|     "License"); fyou may not use this file except in compliance
     9|     with the License.  You may obtain a copy of the License at
    10|        http://www.apache.org/licenses/LICENSE-2.0
    11|     Unless required by applicable law or agreed to in writing,
    12|     software distributed under the License is distributed on an
    13|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    14|     KIND, either express or implied.  See the License for the
    15|     specific language governing permissions and limitations
    16|     under the License.
    17| */
    18| /*eslint-env browser */
    19| /*global $, $$, getElement */
    20| /* FORM element support routines */
    21| /**
    22|  * Function: observe
    23|  *     Observe a dom element for changes, and trigger a callback function.
    24|  *
    25|  * @param {InputElement} element
    26|  * @param {Function} callback - this function is called when the dom element changed
    27|  * @param {Number} [delay=300] - timeout in ms, default = 300ms
    28|  * @param {String} [event="keyup"] - event-type to observe
    29|  *
    30|  * @example
    31|  *     $.observe(formInput, function(){
    32|  *         alert("my value changed to "+this.get("value") );
    33|  *     });
    34|  *
    35|  */
    36| $.observe = function(element, callback, delay, event) {
    37|     var refValue = element.value,
    38|         timer = null;
    39|     function hasChanged() {
    40|         var value = element.value;
    41|         if (value != refValue) {
    42|             refValue = value;
    43|             clearTimeout(timer);
    44|             timer = setTimeout(callback, delay);
    45|         }
    46|     }
    47|     if (isNaN(delay)) {
    48|         event = delay;
    49|         delay = 300;
    50|     }
    51|     event = event || 'keyup';
    52|     element.set({ autocomplete: 'off' }).addEvent(event, hasChanged);
    53|     return element;
    54| };
    55| /**
    56|  * FORM element
    57|  *   Function: getDefaultValue
    58|  *       Returns the default value of a form element.
    59|  *       Inspired by get("value") of mootools, v1.1
    60|  *
    61|  *   Note:
    62|  *       Checkboxes will return true/false depending on the default checked status.
    63|  *       ( input.checked to read actual value )
    64|  *       The value returned in a POST will be input.get("value")
    65|  *       and is depending on the value set by the "value" attribute (optional)
    66|  *
    67|  *   Returns:
    68|  *       (value) - the default value of the element; or false if not applicable.
    69|  *
    70|  *   Examples:
    71|  *   > $("thisElement").getDefaultValue();
    72|  *
    73|  */
    74| $.getDefaultValue = function(element) {};


# ====================================================================
# FILE: jspwiki-war/src/main/scripts/util/extend-number.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| /*
     2|     JSPWiki - a JSP-based WikiWiki clone.
     3|     Licensed to the Apache Software Foundation (ASF) under one
     4|     or more contributor license agreements.  See the NOTICE file
     5|     distributed with this work for additional information
     6|     regarding copyright ownership.  The ASF licenses this file
     7|     to you under the Apache License, Version 2.0 (the
     8|     "License"); fyou may not use this file except in compliance
     9|     with the License.  You may obtain a copy of the License at
    10|        http://www.apache.org/licenses/LICENSE-2.0
    11|     Unless required by applicable law or agreed to in writing,
    12|     software distributed under the License is distributed on an
    13|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    14|     KIND, either express or implied.  See the License for the
    15|     specific language governing permissions and limitations
    16|     under the License.
    17| */
    18| /*eslint-env browser */
    19| /*global $ */
    20| /**
    21|  * Returns a given number between two bounds.
    22|  * @param {number} value
    23|  * @param {number} min
    24|  * @param {number} max
    25|  * @returns {number}
    26|  */
    27| $.limit = function(value, min, max) {
    28|     return Math.min(max, Math.max(min, value));
    29| };


# ====================================================================
# FILE: jspwiki-war/src/main/scripts/util/extend.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-72 ---
     1| /*
     2|     JSPWiki - a JSP-based WikiWiki clone.
     3|     Licensed to the Apache Software Foundation (ASF) under one
     4|     or more contributor license agreements.  See the NOTICE file
     5|     distributed with this work for additional information
     6|     regarding copyright ownership.  The ASF licenses this file
     7|     to you under the Apache License, Version 2.0 (the
     8|     "License"); fyou may not use this file except in compliance
     9|     with the License.  You may obtain a copy of the License at
    10|        http://www.apache.org/licenses/LICENSE-2.0
    11|     Unless required by applicable law or agreed to in writing,
    12|     software distributed under the License is distributed on an
    13|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    14|     KIND, either express or implied.  See the License for the
    15|     specific language governing permissions and limitations
    16|     under the License.
    17| */
    18| /*eslint-env browser */
    19| /*global $ */
    20| /*
    21| Basic js helper routines, inspired on Bliss.js <url>
    22|     $.extend
    23|     $.overload
    24| */
    25| /**
    26|  * Extend
    27|  *    Returns extended objects
    28|  * @param {Object} target
    29|  * @param {Object} src1
    30|  * @returns {Object}
    31|  */
    32| $.extend = function(target, src1) {
    33| };
    34| /*
    35| Overload
    36| */
    37| $.overload = function() {};
    38| /**
    39|  * Returns the [[Class]] of an object in lowercase (eg. array, date, regexp, string etc)
    40|  * Inspired by: https://blissfuljs.com/docs.html#fn-type
    41|  * @param {any} obj
    42|  * @returns {string} type of the object in lowercase
    43|  */
    44| $.type = function(obj) {
    45|     var ret;
    46|     if (obj === null || obj === undefined) {
    47|         return '' + obj;
    48|     }
    49|     if (
    50|         (ret = (
    51|             Object.prototype.toString
    52|                 .call(obj)
    53|                 .match(/^\[object\s+(.*?)\]$/)[1] || ''
    54|         ).toLowerCase()) == 'number' &&
    55|         isNaN(obj)
    56|     ) {
    57|         return 'nan';
    58|     }
    59|     return ret;
    60| };
    61| /**
    62|  * Simple async wait to execute callback until after the DOM is ready
    63|  * @param {function} callback
    64|  */
    65| $.ready = function(callback) {
    66|     var context = document;
    67|     if (context.readyState !== 'loading') {
    68|         callback();
    69|     } else {
    70|         $.once(context, 'DOMContentLoaded', callback);
    71|     }
    72| };


# ====================================================================
# FILE: jspwiki-wysiwyg/src/main/java/org/apache/wiki/htmltowiki/XHtmlElementToWikiTranslator.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 17-57 ---
    17| package org.apache.wiki.htmltowiki;
    18| import org.apache.commons.lang3.StringUtils;
    19| import org.apache.logging.log4j.LogManager;
    20| import org.apache.logging.log4j.Logger;
    21| import org.apache.wiki.api.core.Engine;
    22| import org.apache.wiki.htmltowiki.syntax.MarkupHelper;
    23| import org.apache.wiki.util.ClassUtil;
    24| import org.apache.wiki.util.XmlUtil;
    25| import org.jdom2.Content;
    26| import org.jdom2.Element;
    27| import org.jdom2.JDOMException;
    28| import org.jdom2.Verifier;
    29| import org.jdom2.Text;
    30| import org.jdom2.xpath.XPathFactory;
    31| import java.io.PrintWriter;
    32| import java.util.ArrayDeque;
    33| import java.util.Arrays;
    34| import java.util.Deque;
    35| import java.util.LinkedHashMap;
    36| import java.util.Map;
    37| import java.util.stream.Collectors;
    38| /**
    39|  * Converting XHtml to Wiki Markup.  This is the class which orchestrates all the heavy loading.
    40|  */
    41| public class XHtmlElementToWikiTranslator {
    42|     private static final Logger LOG = LogManager.getLogger( XHtmlElementToWikiTranslator.class );
    43|     private static final String DEFAULT_SYNTAX_DECORATOR = "org.apache.wiki.htmltowiki.syntax.jspwiki.JSPWikiSyntaxDecorator";
    44|     private final Engine e;
    45|     private final XHtmlToWikiConfig config;
    46|     private final WhitespaceTrimWriter outTrimmer = new WhitespaceTrimWriter();
    47|     private final SyntaxDecorator syntax;
    48|     /**
    49|      *  Create a new translator using the default config.
    50|      *
    51|      *  @param base The base element from which to start translating.
    52|      *  @throws JDOMException If the DOM tree is faulty.
    53|      */
    54|     public XHtmlElementToWikiTranslator( final Engine e, final Element base ) throws JDOMException, ReflectiveOperationException {
    55|         this( e, base, new XHtmlToWikiConfig() );
    56|     }
    57|     /**

# --- HUNK 2: Lines 182-222 ---
   182|                     case "1": style += "font-size:xx-small;"; break;
   183|                     case "2": style += "font-size:x-small;"; break;
   184|                     case "3": style += "font-size:small;"; break;
   185|                     case "4": style += "font-size:medium;"; break;
   186|                     case "5": style += "font-size:large;"; break;
   187|                     case "6": style += "font-size:x-large;"; break;
   188|                     case "7": style += "font-size:xx-large;"; break;
   189|                 }
   190|             }
   191|         }
   192|         if( style.equals( "" ) ) {
   193|             return null;
   194|         }
   195|         final Map< Object, Object > m = new LinkedHashMap<>();
   196|         Arrays.stream( style.toLowerCase().split( ";" ) )
   197|               .filter( StringUtils::isNotEmpty )
   198|               .forEach( prop -> m.put( prop.split( ":" )[ 0 ].trim(), prop.split( ":" )[ 1 ].trim() ) );
   199|         return m;
   200|     }
   201|     private String propsToStyleString( final Map< Object, Object >  styleProps ) {
   202|         return styleProps.entrySet().stream().map(entry -> " " + entry.getKey() + ": " + entry.getValue() + ";").collect(Collectors.joining());
   203|     }
   204|     public void translateChildren( final Element base ) throws JDOMException {
   205|         for( final Content c : base.getContent() ) {
   206|             if( c instanceof Element ) {
   207|                 final Element e = ( Element )c;
   208|                 final String n = e.getName().toLowerCase();
   209|                 switch( n ) {
   210|                     case "h1": syntax.h1( e ); break;
   211|                     case "h2": syntax.h2( e ); break;
   212|                     case "h3": syntax.h3( e ); break;
   213|                     case "h4": syntax.h4( e ); break;
   214|                     case "p": syntax.p( e ); break;
   215|                     case "br": syntax.br( base, e ); break;
   216|                     case "hr": syntax.hr( e ); break;
   217|                     case "table": syntax.table( e ); break;
   218|                     case "tbody": syntax.tbody( e ); break;
   219|                     case "tr": syntax.tr( e ); break;
   220|                     case "td": syntax.td( e ); break;
   221|                     case "thead": syntax.thead( e ); break;
   222|                     case "th": syntax.th( e ); break;

