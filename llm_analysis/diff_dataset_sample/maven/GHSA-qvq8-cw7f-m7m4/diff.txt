--- a/jspwiki-api/src/main/java/org/apache/wiki/api/Release.java
+++ b/jspwiki-api/src/main/java/org/apache/wiki/api/Release.java
@@ -38,23 +38,23 @@
     /**
      *  This should be empty when doing a release - otherwise keep it as "-git-" so that whenever someone checks out the code, they know
      *  it is a bleeding-edge version.  Other possible values are "-alpha-" and "-beta-" for alpha and beta versions, respectively.
      *  <p>
      *  If the POSTFIX is empty, it is not added to the version string.
      */
     private static final String    POSTFIX       = "";
     /** The JSPWiki major version. */
     public static final int        VERSION       = 2;
     /** The JSPWiki revision. */
-    public static final int        REVISION      = 12;
+    public static final int        REVISION      = 11;
     /** The minor revision.  */
-    public static final int        MINORREVISION = 0;
+    public static final int        MINORREVISION = 3;
     /** The build number/identifier.  This is a String as opposed to an integer, just so that people can add other identifiers to it.
      * The build number is incremented every time a committer checks in code, and reset when a release is made.
      *  <p>
      *  If you are a person who likes to build his own releases, we recommend that you add your initials to this
      *  identifier (e.g. "13-jj", or "49-aj").
      *  <p>
      *  If the build identifier is empty, it is not added.
      */
     public static final String     BUILD         = "";
     /**

--- a/jspwiki-api/src/main/java/org/apache/wiki/api/core/Engine.java
+++ b/jspwiki-api/src/main/java/org/apache/wiki/api/core/Engine.java
@@ -74,22 +74,20 @@
     /** Property name for the "match english plurals" -hack. */
     String PROP_MATCHPLURALS = "jspwiki.translatorReader.matchEnglishPlurals";
     /** Property name for the template that is used. */
     String PROP_TEMPLATEDIR = "jspwiki.templateDir";
     /** Property name for the default front page. */
     String PROP_FRONTPAGE = "jspwiki.frontPage";
     /** Property name for setting the url generator instance */
     String PROP_URLCONSTRUCTOR = "jspwiki.urlConstructor";
     /** The name of the property containing the ACLManager implementing class. The value is {@value}. */
     String PROP_ACL_MANAGER_IMPL = "jspwiki.aclManager";
-    /** The name of the property containing the ReferenceManager implementing class. The value is {@value}. */
-    String PROP_REF_MANAGER_IMPL = "jspwiki.refManager";
     /** If this property is set to false, we don't allow the creation of empty pages */
     String PROP_ALLOW_CREATION_OF_EMPTY_PAGES = "jspwiki.allowCreationOfEmptyPages";
     /**
      * Adapt Engine to a concrete type.
      *
      * @param cls class denoting the type to adapt to.
      * @param <E> type to adapt to.
      * @return engine instance adapted to the requested type. Might throw an unchecked exception if the instance cannot be adapted to requested type!
      */
     @SuppressWarnings( "unchecked" )

--- a/jspwiki-http/src/main/java/org/apache/wiki/http/filter/CsrfProtectionFilter.java
+++ b/jspwiki-http/src/main/java/org/apache/wiki/http/filter/CsrfProtectionFilter.java
@@ -1,26 +1,10 @@
-/*
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-       http://www.apache.org/licenses/LICENSE-2.0
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
- */
 package org.apache.wiki.http.filter;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.apache.wiki.api.core.Engine;
 import org.apache.wiki.api.core.Session;
 import org.apache.wiki.api.spi.Wiki;
 import javax.servlet.Filter;
 import javax.servlet.FilterChain;
 import javax.servlet.FilterConfig;
 import javax.servlet.ServletException;

--- a/jspwiki-main/src/main/java/org/apache/wiki/WikiEngine.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/WikiEngine.java
@@ -393,22 +393,21 @@
      *  internal links and adds them to the ReferenceManager object.
      *
      *  @throws WikiException If the reference manager initialization fails.
      */
     public void initReferenceManager() throws WikiException {
         try {
             if( getManager( ReferenceManager.class ) == null ) {
                 final ArrayList< Page > pages = new ArrayList<>();
                 pages.addAll( getManager( PageManager.class ).getAllPages() );
                 pages.addAll( getManager( AttachmentManager.class ).getAllAttachments() );
-                final String refMgrClassName = m_properties.getProperty( PROP_REF_MANAGER_IMPL, ClassUtil.getMappedClass( ReferenceManager.class.getName() ).getName() );
-                initComponent( refMgrClassName, ReferenceManager.class, this );
+                initComponent( ReferenceManager.class, this );
                 getManager( ReferenceManager.class ).initialize( pages );
             }
         } catch( final ProviderException e ) {
             LOG.fatal( "PageProvider is unable to list pages: ", e );
         } catch( final Exception e ) {
             throw new WikiException( "Could not instantiate ReferenceManager: " + e.getMessage(), e );
         }
     }
     /** {@inheritDoc} */
     @Override

--- a/jspwiki-main/src/main/java/org/apache/wiki/WikiSession.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/WikiSession.java
@@ -67,21 +67,26 @@
     private Principal m_loginPrincipal = WikiPrincipal.GUEST;
     private Locale m_cachedLocale      = Locale.getDefault();
     /**
      * Returns <code>true</code> if one of this WikiSession's user Principals can be shown to belong to a particular wiki group. If
      * the user is not authenticated, this method will always return <code>false</code>.
      *
      * @param group the group to test
      * @return the result
      */
     protected boolean isInGroup( final Group group ) {
-        return Arrays.stream(getPrincipals()).anyMatch(principal -> isAuthenticated() && group.isMember(principal));
+        for( final Principal principal : getPrincipals() ) {
+            if( isAuthenticated() && group.isMember( principal ) ) {
+                return true;
+            }
+        }
+        return false;
     }
     /**
      * Private constructor to prevent WikiSession from being instantiated directly.
      */
     private WikiSession() {
     }
     /** {@inheritDoc} */
     @Override
     public boolean isAsserted() {
         return m_subject.getPrincipals().contains( Role.ASSERTED );
@@ -163,21 +168,27 @@
     public String[] getMessages( final String topic ) {
         final Set< String > messages = m_messages.get( topic );
         if( messages == null || messages.size() == 0 ) {
             return new String[ 0 ];
         }
         return messages.toArray( new String[0] );
     }
     /** {@inheritDoc} */
     @Override
     public Principal[] getPrincipals() {
-        return m_subject.getPrincipals().stream().filter(AuthenticationManager::isUserPrincipal).toArray(Principal[]::new);
+        final ArrayList< Principal > principals = new ArrayList<>();
+        for( final Principal principal : m_subject.getPrincipals() ) {
+            if ( AuthenticationManager.isUserPrincipal( principal ) ) {
+                principals.add( principal );
+            }
+        }
+        return principals.toArray( new Principal[0] );
     }
     /** {@inheritDoc} */
     @Override
     public Principal[] getRoles() {
         final Set< Principal > roles = new HashSet<>();
         roles.addAll( m_subject.getPrincipals( Role.class ) );
         roles.addAll( m_subject.getPrincipals( GroupPrincipal.class ) );
         final Principal[] roleArray = roles.toArray( new Principal[0] );
         Arrays.sort( roleArray, WikiPrincipal.COMPARATOR );
         return roleArray;

--- a/jspwiki-main/src/main/java/org/apache/wiki/auth/AuthenticationManager.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/auth/AuthenticationManager.java
@@ -158,21 +158,26 @@
     static boolean isUserPrincipal( final Principal principal ) {
         return !isRolePrincipal( principal );
     }
     /**
      * Returns the first Principal in a set that isn't a {@link Role} or {@link GroupPrincipal}.
      *
      * @param principals the principal set
      * @return the login principal
      */
     default Principal getLoginPrincipal( final Set< Principal > principals ) {
-        return principals.stream().filter(AuthenticationManager::isUserPrincipal).findFirst().orElse(null);
+        for( final Principal principal : principals ) {
+            if ( isUserPrincipal( principal ) ) {
+                return principal;
+            }
+        }
+        return null;
     }
     /**
      * Registers a WikiEventListener with this instance. This is a convenience method.
      *
      * @param listener the event listener
      */
     void addWikiEventListener( WikiEventListener listener );
     /**
      * Un-registers a WikiEventListener with this instance. This is a convenience method.
      *

--- a/jspwiki-main/src/main/java/org/apache/wiki/auth/DefaultAuthorizationManager.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/auth/DefaultAuthorizationManager.java
@@ -145,21 +145,25 @@
     public boolean hasRoleOrPrincipal( final Session session, final Principal principal ) {
         if( session == null || principal == null ) {
             return false;
         }
         if( AuthenticationManager.isRolePrincipal( principal ) ) {
             return isUserInRole( session, principal );
         }
         if( session.isAuthenticated() && AuthenticationManager.isUserPrincipal( principal ) ) {
             final String principalName = principal.getName();
             final Principal[] userPrincipals = session.getPrincipals();
-            return Arrays.stream(userPrincipals).anyMatch(userPrincipal -> userPrincipal.getName().equals(principalName));
+            for( final Principal userPrincipal : userPrincipals ) {
+                if( userPrincipal.getName().equals( principalName ) ) {
+                    return true;
+                }
+            }
         }
         return false;
     }
     /** {@inheritDoc} */
     @Override
     public boolean hasAccess( final Context context, final HttpServletResponse response, final boolean redirect ) throws IOException {
         final boolean allowed = checkPermission( context.getWikiSession(), context.requiredPermission() );
         if ( context.getHttpRequest() != null && context.getHttpRequest().getAttribute( Context.ATTR_CONTEXT ) == null ) {
             context.getHttpRequest().setAttribute( Context.ATTR_CONTEXT, context );
         }

--- a/jspwiki-main/src/main/java/org/apache/wiki/auth/DefaultUserManager.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/auth/DefaultUserManager.java
@@ -350,21 +350,21 @@
         {
             m_manager = mgr;
         }
         @Override
         public String getServletMapping() {
         	return JSON_USERS;
         }
         @Override
         public void service( final HttpServletRequest req, final HttpServletResponse resp, final String actionName, final List<String> params) throws ServletException, IOException {
         	try {
-            	if( params.isEmpty() ) {
+            	if( params.size() < 1 ) {
             		return;
             	}
         		final String uid = params.get(0);
 	        	LOG.debug("uid="+uid);
 	        	if (StringUtils.isNotBlank(uid)) {
 		            final UserProfile prof = getUserInfo(uid);
 		            resp.getWriter().write(AjaxUtil.toJson(prof));
 	        	}
         	} catch (final NoSuchPrincipalException e) {
         		throw new ServletException(e);

--- a/jspwiki-main/src/main/java/org/apache/wiki/auth/SessionMonitor.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/auth/SessionMonitor.java
@@ -28,21 +28,20 @@
 import javax.servlet.http.HttpSession;
 import javax.servlet.http.HttpSessionEvent;
 import javax.servlet.http.HttpSessionListener;
 import java.security.Principal;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Map;
 import java.util.WeakHashMap;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.stream.Collectors;
 /**
  *  <p>Manages Sessions for different Engines.</p>
  *  <p>The Sessions are stored both in the remote user HttpSession and in the SessionMonitor for the Engine.
  *  This class must be configured as a session listener in the web.xml for the wiki web application.</p>
  */
 public class SessionMonitor implements HttpSessionListener {
     private static final Logger LOG = LogManager.getLogger( SessionMonitor.class );
     /** Map with Engines as keys, and SessionMonitors as values. */
     private static final ConcurrentHashMap< Engine, SessionMonitor > c_monitors = new ConcurrentHashMap<>();
     /** Weak hashmap with HttpSessions as keys, and WikiSessions as values. */
@@ -186,23 +185,25 @@
     /**
      * <p>Returns the current wiki users as a sorted array of Principal objects. The principals are those returned by
      * each WikiSession's {@link Session#getUserPrincipal()}'s method.</p>
      * <p>To obtain the list of current WikiSessions, we iterate through our session Map and obtain the list of values,
      * which are WikiSessions wrapped in {@link java.lang.ref.WeakReference} objects. Those <code>WeakReference</code>s
      * whose <code>get()</code> method returns non-<code>null</code> values are valid sessions.</p>
      *
      * @return the array of user principals
      */
     public final Principal[] userPrincipals() {
-        final Collection<Principal> principals;
+        final Collection<Principal> principals = new ArrayList<>();
         synchronized ( m_sessions ) {
-            principals = m_sessions.values().stream().map(Session::getUserPrincipal).collect(Collectors.toList());
+            for ( final Session session : m_sessions.values()) {
+                principals.add( session.getUserPrincipal() );
+            }
         }
         final Principal[] p = principals.toArray( new Principal[0] );
         Arrays.sort( p, m_comparator );
         return p;
     }
     /**
      * Registers a WikiEventListener with this instance.
      *
      * @param listener the event listener
      * @since 2.4.75

--- a/jspwiki-main/src/main/java/org/apache/wiki/auth/acl/AclEntryImpl.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/auth/acl/AclEntryImpl.java
@@ -14,21 +14,20 @@
     specific language governing permissions and limitations
     under the License.  
  */
 package org.apache.wiki.auth.acl;
 import org.apache.wiki.auth.permissions.PagePermission;
 import java.io.Serializable;
 import java.security.Permission;
 import java.security.Principal;
 import java.util.Enumeration;
 import java.util.Vector;
-import java.util.stream.Collectors;
 /**
  * Implementation of a JSPWiki AclEntry.
  *
  * @since 2.3
  */
 public class AclEntryImpl implements AclEntry, Serializable {
     private static final long serialVersionUID = 1L;
     private final Vector< Permission > m_permissions = new Vector<>();
     private Principal m_principal;
     /**
@@ -112,20 +111,34 @@
         m_principal = user;
         return true;
     }
     /**
      * Returns a string representation of the contents of this ACL entry.
      *
      * @return a string representation of the contents.
      */
     public String toString() {
         final Principal p = getPrincipal();
-        return m_permissions.stream().map(pp -> pp.toString() + ",").collect(Collectors.joining("", "[AclEntry ALLOW " + (p != null ? p.getName() : "null") + " ", "]"));
+        final StringBuilder sb = new StringBuilder();
+        sb.append( "[AclEntry ALLOW " )
+          .append( p != null ? p.getName() : "null" )
+          .append( " " );
+        for( final Permission pp : m_permissions ) {
+            sb.append( pp.toString() );
+            sb.append( "," );
+        }
+        sb.append( "]" );
+        return sb.toString();
     }
     /**
      * Looks through the permission list and finds a permission that matches the
      * permission.
      */
     private Permission findPermission( final Permission p ) {
-        return m_permissions.stream().filter(pp -> pp.implies(p)).findFirst().orElse(null);
+        for( final Permission pp : m_permissions ) {
+            if( pp.implies( p ) ) {
+                return pp;
+            }
+        }
+        return null;
     }
 }

--- a/jspwiki-main/src/main/java/org/apache/wiki/auth/acl/AclImpl.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/auth/acl/AclImpl.java
@@ -87,21 +87,26 @@
         return m_entries.remove( entry );
     }
     /** {@inheritDoc} */
     @Override
     public Enumeration< AclEntry > aclEntries() {
         return m_entries.elements();
     }
     /** {@inheritDoc} */
     @Override
     public AclEntry getAclEntry( final Principal principal ) {
-        return m_entries.stream().filter(entry -> entry.getPrincipal().getName().equals(principal.getName())).findFirst().orElse(null);
+        for( final AclEntry entry : m_entries ) {
+            if( entry.getPrincipal().getName().equals( principal.getName() ) ) {
+                return entry;
+            }
+        }
+        return null;
     }
     /** {@inheritDoc} */
     @Override
     public boolean isEmpty() {
         return m_entries.isEmpty();
     }
     /** {@inheritDoc} */
     @Override
     public String toString() {
         final StringBuilder sb = new StringBuilder();

--- a/jspwiki-main/src/main/java/org/apache/wiki/auth/authorize/DefaultGroupManager.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/auth/authorize/DefaultGroupManager.java
@@ -31,21 +31,20 @@
 import org.apache.wiki.auth.WikiPrincipal;
 import org.apache.wiki.auth.WikiSecurityException;
 import org.apache.wiki.auth.user.UserProfile;
 import org.apache.wiki.event.WikiEvent;
 import org.apache.wiki.event.WikiEventListener;
 import org.apache.wiki.event.WikiEventManager;
 import org.apache.wiki.event.WikiSecurityEvent;
 import org.apache.wiki.ui.InputValidator;
 import org.apache.wiki.util.ClassUtil;
 import java.security.Principal;
-import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
 import java.util.StringTokenizer;
 /**
  * <p>
  * Facade class for storing, retrieving and managing wiki groups on behalf of AuthorizationManager, JSPs and other presentation-layer
  * classes. GroupManager works in collaboration with a back-end {@link GroupDatabase}, which persists groups to permanent storage.
@@ -142,21 +141,26 @@
     /** {@inheritDoc} */
     @Override
     public boolean isUserInRole( final Session session, final Principal role ) {
         if ( session == null || !( role instanceof GroupPrincipal ) || !session.isAuthenticated() ) {
             return false;
         }
         final Group group = m_groups.get( role );
         if( group == null ) {
             return false;
         }
-        return Arrays.stream(session.getPrincipals()).anyMatch(principal -> AuthenticationManager.isUserPrincipal(principal) && group.isMember(principal));
+        for( final Principal principal : session.getPrincipals() ) {
+            if( AuthenticationManager.isUserPrincipal( principal ) && group.isMember( principal ) ) {
+                return true;
+            }
+        }
+        return false;
     }
     /** {@inheritDoc} */
     @Override
     public Group parseGroup( String name, String memberLine, final boolean create ) throws WikiSecurityException {
         if( name == null ) {
             if( create ) {
                 name = "MyGroup";
             } else {
                 throw new WikiSecurityException( "Group name cannot be blank." );
             }

--- a/jspwiki-main/src/main/java/org/apache/wiki/auth/authorize/Group.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/auth/authorize/Group.java
@@ -108,30 +108,39 @@
         }
         final Group g = ( Group )o; // Just a shortcut.
         if( g.m_members.size() != m_members.size() ) {
             return false;
         }
         if( getName() != null && !getName().equals( g.getName() ) ) {
             return false;
         } else if( getName() == null && g.getName() != null ) {
             return false;
         }
-        return m_members.stream().allMatch(g::isMember);
+        for( final Principal principal : m_members ) {
+            if( !g.isMember( principal ) ) {
+                return false;
+            }
+        }
+        return true;
     }
     /**
      *  The hashcode is calculated as a XOR sum over all members of the Group.
      *
      *  @return the hash code
      */
     @Override
     public int hashCode() {
-        return m_members.stream().mapToInt(Principal::hashCode).reduce(0, (a, b) -> a ^ b);
+        int hc = 0;
+        for( final Principal member : m_members ) {
+            hc ^= member.hashCode();
+        }
+        return hc;
     }
     /**
      * Returns the creation date.
      *
      * @return the creation date
      */
     public synchronized Date getCreated() {
         return m_created;
     }
     /**
@@ -248,13 +257,18 @@
      * Returns a string representation of the Group.
      *
      * @return the string
      * @see java.lang.Object#toString()
      */
     @Override
     public String toString() {
         return "(Group " + getName() + ")";
     }
     private Principal findMember( final String name ) {
-        return m_members.stream().filter(member -> member.getName().equals(name)).findFirst().orElse(null);
+        for( final Principal member : m_members ) {
+            if( member.getName().equals( name ) ) {
+                return member;
+            }
+        }
+        return null;
     }
 }

--- a/jspwiki-main/src/main/java/org/apache/wiki/auth/authorize/WebContainerAuthorizer.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/auth/authorize/WebContainerAuthorizer.java
@@ -28,26 +28,24 @@
 import org.jdom2.input.SAXBuilder;
 import org.jdom2.input.sax.XMLReaders;
 import org.jdom2.xpath.XPathFactory;
 import org.xml.sax.EntityResolver;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
 import javax.servlet.http.HttpServletRequest;
 import java.io.IOException;
 import java.net.URL;
 import java.security.Principal;
-import java.util.Arrays;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Properties;
 import java.util.Set;
-import java.util.stream.Collectors;
 /**
  * Authorizes users by delegating role membership checks to the servlet container. In addition to implementing
  * methods for the <code>Authorizer</code> interface, this class also provides a convenience method
  * {@link #isContainerAuthorized()} that queries the web application descriptor to determine if the container
  * manages authorization.
  *
  * @since 2.3
  */
 public class WebContainerAuthorizer implements WebAuthorizer  {
     private static final String J2EE_SCHEMA_25_NAMESPACE = "http://xmlns.jcp.org/xml/ns/javaee";
@@ -94,21 +92,24 @@
                 LOG.info( "JSPWiki is using custom authentication." );
             }
         } catch( final IOException e ) {
             LOG.error( "Initialization failed: ", e );
             throw new InternalWikiException( e.getClass().getName() + ": " + e.getMessage(), e );
         } catch( final JDOMException e ) {
             LOG.error( "Malformed XML in web.xml", e );
             throw new InternalWikiException( e.getClass().getName() + ": " + e.getMessage(), e );
         }
         if( m_containerRoles.length > 0 ) {
-            final String roles = Arrays.stream(m_containerRoles).map(containerRole -> containerRole + " ").collect(Collectors.joining());
+            final StringBuilder roles = new StringBuilder();
+            for( final Role containerRole : m_containerRoles ) {
+                roles.append(containerRole).append(" ");
+            }
             LOG.info( " JSPWiki determined the web container manages these roles: " + roles );
         }
         LOG.info( "Authorizer WebContainerAuthorizer initialized successfully." );
     }
     /**
      * Determines whether a user associated with an HTTP request possesses
      * a particular role. This method simply delegates to
      * {@link javax.servlet.http.HttpServletRequest#isUserInRole(String)}
      * by converting the Principal's name to a String.
      * @param request the HTTP request
@@ -151,21 +152,26 @@
     /**
      * Looks up and returns a Role Principal matching a given String. If the
      * Role does not match one of the container Roles identified during
      * initialization, this method returns <code>null</code>.
      * @param role the name of the Role to retrieve
      * @return a Role Principal, or <code>null</code>
      * @see org.apache.wiki.auth.Authorizer#initialize(Engine, Properties)
      */
     @Override
     public Principal findRole( final String role ) {
-        return Arrays.stream(m_containerRoles).filter(containerRole -> containerRole.getName().equals(role)).findFirst().map(containerRole -> containerRole).orElse(null);
+        for( final Role containerRole : m_containerRoles ) {
+            if ( containerRole.getName().equals( role ) ) {
+                return containerRole;
+            }
+        }
+        return null;
     }
     /**
      * <p>
      * Protected method that identifies whether a particular webapp URL is
      * constrained to a particular Role. The resource is considered constrained
      * if:
      * </p>
      * <ul>
      * <li>the web application deployment descriptor contains a
      * <code>security-constraint</code> with a child
@@ -194,21 +200,28 @@
                                                   .evaluate( root );
         if( constraints.size() == 0 ) {
             return false;
         }
         if( role.equals( Role.ALL ) ) {
             return true;
         }
         if( roles.size() == 0 ) {
             return false;
         }
-        return constraints.stream().anyMatch(constraint -> roles.stream().anyMatch(constraint::equals));
+        for( final Element constraint : constraints ) {
+            for( final Element roleConstraint : roles ) {
+                if( constraint.equals( roleConstraint ) ) {
+                    return true;
+                }
+            }
+        }
+        return false;
     }
     /**
      * Returns <code>true</code> if the web container is configured to protect
      * certain JSPWiki resources by requiring authentication. Specifically, this
      * method parses JSPWiki's web application descriptor (<code>web.xml</code>)
      * and identifies whether the string representation of
      * {@link org.apache.wiki.auth.authorize.Role#AUTHENTICATED} is required
      * to access <code>/Delete.jsp</code> and <code>LoginRedirect.jsp</code>.
      * If the administrator has uncommented the large
      * <code>&lt;security-constraint&gt;</code> section of <code>web.xml</code>,
@@ -238,28 +251,31 @@
     }
     /**
      * Protected method that extracts the roles from JSPWiki's web application
      * deployment descriptor. Each Role is constructed by using the String
      * representation of the Role, for example
      * <code>new Role("Administrator")</code>.
      * @param webxml the web application deployment descriptor
      * @return an array of Role objects
      */
     protected Role[] getRoles( final Document webxml ) {
-        final Set<Role> roles;
+        final Set<Role> roles = new HashSet<>();
         final Element root = webxml.getRootElement();
         final Namespace jeeNs = Namespace.getNamespace( "j", J2EE_SCHEMA_25_NAMESPACE );
         final String constrainsSelector = "//j:web-app/j:security-constraint/j:auth-constraint/j:role-name";
         final List< Element > constraints = XPathFactory.instance()
                                                         .compile( constrainsSelector, Filters.element(), null, jeeNs )
                                                         .evaluate( root );
-        roles = constraints.stream().map(Element::getTextTrim).map(Role::new).collect(Collectors.toSet());
+        for( final Element constraint : constraints ) {
+            final String role = constraint.getTextTrim();
+            roles.add( new Role( role ) );
+        }
         final String rolesSelector = "//j:web-app/j:security-role/j:role-name";
         final List< Element > nodes = XPathFactory.instance()
                                                   .compile( rolesSelector, Filters.element(), null, jeeNs )
                                                   .evaluate( root );
         for( final Element node : nodes ) {
             final String role = node.getTextTrim();
             roles.add( new Role( role ) );
         }
         return roles.toArray( new Role[0] );
     }

--- a/jspwiki-main/src/main/java/org/apache/wiki/auth/permissions/GroupPermission.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/auth/permissions/GroupPermission.java
@@ -418,15 +418,21 @@
         if ( !MEMBER_TOKEN.equals( m_group ) )
         {
             return false;
         }
         final AccessControlContext acc = AccessController.getContext();
         final DomainCombiner dc = acc.getDomainCombiner();
         if ( dc != null && dc instanceof SubjectDomainCombiner )
         {
             final Subject subject = ( (SubjectDomainCombiner) dc ).getSubject();
             final Set<GroupPrincipal> principals = subject.getPrincipals( GroupPrincipal.class );
-            return principals.stream().anyMatch(principal -> principal.getName().equals(gp.m_group));
+            for( final Principal principal : principals )
+            {
+                if ( principal.getName().equals( gp.m_group ) )
+                {
+                    return true;
+                }
+            }
         }
         return false;
     }
 }

--- a/jspwiki-main/src/main/java/org/apache/wiki/auth/user/XMLUserDatabase.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/auth/user/XMLUserDatabase.java
@@ -41,22 +41,20 @@
 import java.nio.file.Files;
 import java.security.Principal;
 import java.text.DateFormat;
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Map;
 import java.util.Properties;
 import java.util.SortedSet;
 import java.util.TreeSet;
-import java.util.stream.Collectors;
-import java.util.stream.IntStream;
 /**
  * <p>Manages {@link DefaultUserProfile} objects using XML files for persistence. Passwords are hashed using SHA1. User entries are simple
  * <code>&lt;user&gt;</code> elements under the root. User profile properties are attributes of the element. For example:</p>
  * <blockquote><code>
  * &lt;users&gt;<br/>
  * &nbsp;&nbsp;&lt;user loginName="janne" fullName="Janne Jalkanen"<br/>
  * &nbsp;&nbsp;&nbsp;&nbsp;wikiName="JanneJalkanen" email="janne@ecyrd.com"<br/>
  * &nbsp;&nbsp;&nbsp;&nbsp;password="{SHA}457b08e825da547c3b77fbc1ff906a1d00a7daee"/&gt;<br/>
  * &lt;/users&gt;
  * </code></blockquote>
@@ -313,21 +311,28 @@
     @Override
     public synchronized void save( final UserProfile profile ) throws WikiSecurityException {
         if ( c_dom == null ) {
             LOG.fatal( "Could not save profile " + profile + " database does not exist" );
             throw new IllegalStateException( "FATAL: database does not exist" );
         }
         checkForRefresh();
         final DateFormat c_format = new SimpleDateFormat( DATE_FORMAT );
         final String index = profile.getLoginName();
         final NodeList users = c_dom.getElementsByTagName( USER_TAG );
-        Element user = IntStream.range(0, users.getLength()).mapToObj(i -> (Element) users.item(i)).filter(currentUser -> currentUser.getAttribute(LOGIN_NAME).equals(index)).findFirst().orElse(null);
+        Element user = null;
+        for( int i = 0; i < users.getLength(); i++ ) {
+            final Element currentUser = ( Element )users.item( i );
+            if( currentUser.getAttribute( LOGIN_NAME ).equals( index ) ) {
+                user = currentUser;
+                break;
+            }
+        }
         boolean isNew = false;
         final Date modDate = new Date( System.currentTimeMillis() );
         if( user == null ) {
             profile.setCreated( modDate );
             LOG.info( "Creating new user " + index );
             user = c_dom.createElement( USER_TAG );
             c_dom.getDocumentElement().appendChild( user );
             setAttribute( user, CREATED, c_format.format( profile.getCreated() ) );
             isNew = true;
         } else {
@@ -429,26 +434,31 @@
         }
         return null;
     }
     /**
      * Extracts all the text nodes that are immediate children of an Element.
      *
      * @param element the base element
      * @return the text nodes that are immediate children of the base element, concatenated together
      */
     private String extractText( final Element element ) {
-        String text = "";
+        final StringBuilder text = new StringBuilder();
         if( element.getChildNodes().getLength() > 0 ) {
             final NodeList children = element.getChildNodes();
-            text = IntStream.range(0, children.getLength()).mapToObj(children::item).filter(child -> child.getNodeType() == Node.TEXT_NODE).map(child -> ((Text) child).getData()).collect(Collectors.joining());
-        }
-        return text;
+            for( int k = 0; k < children.getLength(); k++ ) {
+                final Node child = children.item( k );
+                if( child.getNodeType() == Node.TEXT_NODE ) {
+                    text.append(((Text) child).getData());
+                }
+            }
+        }
+        return text.toString();
     }
     /**
      *  Tries to parse a date using the default format - then, for backwards compatibility reasons, tries the platform default.
      *
      *  @param profile profile associated to the date.
      *  @param date date to be parsed.
      *  @return A parsed date, or null, if both parse attempts fail.
      */
     private Date parseDate( final UserProfile profile, final String date ) {
         try {

--- a/jspwiki-main/src/main/java/org/apache/wiki/content/DefaultPageRenamer.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/content/DefaultPageRenamer.java
@@ -134,24 +134,24 @@
         if( referrers.isEmpty() ) { // No referrers
             return;
         }
         final Engine engine = context.getEngine();
         for( String pageName : referrers ) {
             if( pageName.equals( fromPage.getName() ) ) {
                 pageName = toPage.getName();
             }
             final Page p = engine.getManager( PageManager.class ).getPage( pageName );
             final String sourceText = engine.getManager( PageManager.class ).getPureText( p );
-            String newText = replaceReferrerString(sourceText, fromPage.getName(), toPage.getName() );
+            String newText = replaceReferrerString( context, sourceText, fromPage.getName(), toPage.getName() );
             m_camelCase = TextUtil.getBooleanProperty( engine.getWikiProperties(), MarkupParser.PROP_CAMELCASELINKS, m_camelCase );
             if( m_camelCase ) {
-                newText = replaceCCReferrerString(newText, fromPage.getName(), toPage.getName() );
+                newText = replaceCCReferrerString( context, newText, fromPage.getName(), toPage.getName() );
             }
             if( !sourceText.equals( newText ) ) {
                 p.setAttribute( Page.CHANGENOTE, fromPage.getName()+" ==> "+toPage.getName() );
                 p.setAuthor( context.getCurrentUser().getName() );
                 try {
                     engine.getManager( PageManager.class ).putPageText( p, newText );
                     engine.getManager( ReferenceManager.class ).updateReferences( p );
                 } catch( final ProviderException e ) {
                     LOG.error("Unable to perform rename.",e);
                 }
@@ -173,82 +173,82 @@
                 }
             }
         } catch( final ProviderException e ) {
             LOG.error( "Provider error while fetching attachments for rename", e );
         }
         return referrers;
     }
     /**
      *  Replaces camelcase links.
      */
-    private String replaceCCReferrerString( final String sourceText, final String from, final String to ) {
+    private String replaceCCReferrerString( final Context context, final String sourceText, final String from, final String to ) {
         final StringBuilder sb = new StringBuilder( sourceText.length()+32 );
         final Pattern linkPattern = Pattern.compile( "\\p{Lu}+\\p{Ll}+\\p{Lu}+[\\p{L}\\p{Digit}]*" );
         final Matcher matcher = linkPattern.matcher( sourceText );
         int start = 0;
         while( matcher.find( start ) ) {
             final String match = matcher.group();
             sb.append( sourceText, start, matcher.start() );
             final int lastOpenBrace = sourceText.lastIndexOf( '[', matcher.start() );
             final int lastCloseBrace = sourceText.lastIndexOf( ']', matcher.start() );
             if( match.equals( from ) && lastCloseBrace >= lastOpenBrace ) {
                 sb.append( to );
             } else {
                 sb.append( match );
             }
             start = matcher.end();
         }
         sb.append( sourceText.substring( start ) );
         return sb.toString();
     }
-    private String replaceReferrerString(final String sourceText, final String from, final String to ) {
+    private String replaceReferrerString( final Context context, final String sourceText, final String from, final String to ) {
         final StringBuilder sb = new StringBuilder( sourceText.length()+32 );
         final Pattern linkPattern = Pattern.compile( "([\\[~]?)\\[([^|\\]]*)(\\|)?([^|\\]]*)(\\|)?([^|\\]]*)]" );
         final Matcher matcher = linkPattern.matcher( sourceText );
         int start = 0;
         while( matcher.find( start ) ) {
             char charBefore = (char)-1;
             if( matcher.start() > 0 ) {
                 charBefore = sourceText.charAt( matcher.start() - 1 );
             }
             if( !matcher.group(1).isEmpty() || charBefore == '~' || charBefore == '[' ) {
                 sb.append( sourceText, start, matcher.end() );
                 start = matcher.end();
                 continue;
             }
             String text = matcher.group(2);
             String link = matcher.group(4);
             final String attr = matcher.group(6);
             if( link.isEmpty() ) {
-                text = replaceSingleLink(text, from, to );
+                text = replaceSingleLink( context, text, from, to );
             } else {
-                link = replaceSingleLink(link, from, to );
+                link = replaceSingleLink( context, link, from, to );
                 text = TextUtil.replaceString( text, from, to );
             }
             sb.append( sourceText, start, matcher.start() );
             sb.append( "[" ).append( text );
             if( !link.isEmpty() ) {
                 sb.append( "|" ).append( link );
             }
             if( !attr.isEmpty() ) {
                 sb.append( "|" ).append( attr );
             }
             sb.append( "]" );
             start = matcher.end();
         }
         sb.append( sourceText.substring( start ) );
         return sb.toString();
     }
     /**
      *  This method does a correct replacement of a single link, taking into account anchors and attachments.
      */
-    private String replaceSingleLink(final String original, final String from, final String newlink ) {
+    private String replaceSingleLink( final Context context, final String original, final String from, final String newlink ) {
         final int hash = original.indexOf( '#' );
         final int slash = original.indexOf( '/' );
         String realLink = original;
         if( hash != -1 ) {
             realLink = original.substring( 0, hash );
         }
         if( slash != -1 ) {
             realLink = original.substring( 0,slash );
         }
         realLink = MarkupParser.cleanLink( realLink );

--- a/jspwiki-main/src/main/java/org/apache/wiki/diff/ContextualDiffProvider.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/diff/ContextualDiffProvider.java
@@ -26,25 +26,23 @@
 import org.suigeneris.jrcs.diff.Revision;
 import org.suigeneris.jrcs.diff.RevisionVisitor;
 import org.suigeneris.jrcs.diff.delta.AddDelta;
 import org.suigeneris.jrcs.diff.delta.ChangeDelta;
 import org.suigeneris.jrcs.diff.delta.Chunk;
 import org.suigeneris.jrcs.diff.delta.DeleteDelta;
 import org.suigeneris.jrcs.diff.delta.Delta;
 import org.suigeneris.jrcs.diff.myers.MyersDiff;
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.List;
 import java.util.Properties;
 import java.util.StringTokenizer;
-import java.util.stream.Collectors;
 /**
  * A seriously better diff provider, which highlights changes word-by-word using CSS.
  *
  * Suggested by John Volkar.
  */
 public class ContextualDiffProvider implements DiffProvider {
     private static final Logger LOG = LogManager.getLogger( ContextualDiffProvider.class );
     /**
      *  A jspwiki.properties value to define how many characters are shown around the change context.
      *  The current value is <tt>{@value}</tt>.
@@ -185,27 +183,34 @@
             m_newBuf = new StringBuffer();
         }
         private void updateState( final Delta delta ) {
             m_index++;
             final Chunk orig = delta.getOriginal();
             if( orig.first() > m_firstElem ) {
                 flushChanges();
                 if( ( orig.first() - m_firstElem ) > 2 * m_unchangedContextLimit ) {
                     if (m_firstElem > 0) {
                         final int endIndex = Math.min( m_firstElem + m_unchangedContextLimit, m_origStrings.length -1 );
-                        m_sb.append(Arrays.stream(m_origStrings, m_firstElem, endIndex).collect(Collectors.joining("", "", ELIDED_TAIL_INDICATOR_HTML)));
+                        for( int j = m_firstElem; j < endIndex; j++ ) {
+                            m_sb.append( m_origStrings[ j ] );
+                        }
+                        m_sb.append( ELIDED_TAIL_INDICATOR_HTML );
                     }
                     m_sb.append( ELIDED_HEAD_INDICATOR_HTML );
                     final int startIndex = Math.max(orig.first() - m_unchangedContextLimit, 0);
-                    m_sb.append(Arrays.stream(m_origStrings, startIndex, orig.first()).collect(Collectors.joining()));
+                    for (int j = startIndex; j < orig.first(); j++) {
+                        m_sb.append( m_origStrings[ j ] );
+                    }
                 } else {
-                    m_sb.append(Arrays.stream(m_origStrings, m_firstElem, orig.first()).collect(Collectors.joining()));
+                    for( int j = m_firstElem; j < orig.first(); j++ ) {
+                        m_sb.append( m_origStrings[ j ] );
+                    }
                 }
             }
             m_firstElem = orig.last() + 1;
         }
         @Override
         public void visit( final Revision rev ) {
         }
         @Override
         public void visit( final AddDelta delta ) {
             updateState( delta );
@@ -244,23 +249,28 @@
                 addOrig( delta.getOriginal() );
                 m_mode = 1;
             }
         }
         public void shutdown() {
             m_index = m_max + 1; // Make sure that no hyperlink gets created
             flushChanges();
             if( m_firstElem < m_origStrings.length ) {
                 if( ( m_origStrings.length - m_firstElem ) > m_unchangedContextLimit ) {
                     final int endIndex = Math.min( m_firstElem + m_unchangedContextLimit, m_origStrings.length -1 );
-                    m_sb.append(Arrays.stream(m_origStrings, m_firstElem, endIndex).collect(Collectors.joining("", "", ELIDED_TAIL_INDICATOR_HTML)));
+                    for (int j = m_firstElem; j < endIndex; j++) {
+                        m_sb.append( m_origStrings[ j ] );
+                    }
+                    m_sb.append( ELIDED_TAIL_INDICATOR_HTML );
                 } else {
-                    m_sb.append(Arrays.stream(m_origStrings, m_firstElem, m_origStrings.length).collect(Collectors.joining()));
+                    for( int j = m_firstElem; j < m_origStrings.length; j++ ) {
+                        m_sb.append( m_origStrings[ j ] );
+                    }
                 }
             }
         }
         private void addOrig( final Chunk chunk ) {
             if( chunk != null ) {
                 chunk.toString( m_origBuf );
             }
         }
         private void addNew( final Chunk chunk ) {
             if( chunk != null ) {

--- a/jspwiki-main/src/main/java/org/apache/wiki/filters/ProfanityFilter.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/filters/ProfanityFilter.java
@@ -37,21 +37,28 @@
     private static final Logger LOG = LogManager.getLogger( ProfanityFilter.class );
     private static final String PROPERTYFILE = "org/apache/wiki/filters/profanity.properties";
     private static String[] c_profanities = new String[0];
     static {
         final ClassLoader loader = ProfanityFilter.class.getClassLoader();
         try( final InputStream in = loader.getResourceAsStream( PROPERTYFILE ) ) {
             if( in == null ) {
                 throw new IOException( "No property file found! (Check the installation, it should be there.)" );
             }
             try( final BufferedReader br =  new BufferedReader( new InputStreamReader( in ) ) ) {
-                c_profanities = br.lines().filter(str -> !str.isEmpty() && !str.startsWith("#")).toArray(String[]::new);
+                final List< String > profs = new ArrayList<>();
+                String str;
+                while ( ( str = br.readLine() ) != null ) {
+                    if( !str.isEmpty() && !str.startsWith( "#" ) ) { // allow comments on profanities file
+                        profs.add( str );
+                    }
+                }
+                c_profanities = profs.toArray( new String[0] );
             }
         } catch( final IOException e ) {
             LOG.error( "Unable to load profanities from " + PROPERTYFILE, e );
         } catch( final Exception e ) {
             LOG.error( "Unable to initialize Profanity Filter", e );
         }
     }
     /**
      *  {@inheritDoc}
      */

--- a/jspwiki-main/src/main/java/org/apache/wiki/filters/SpamFilter.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/filters/SpamFilter.java
@@ -246,45 +246,45 @@
         return uid;
     }
     /** {@inheritDoc} */
     @Override
     public String preSave( final Context context, final String content ) throws RedirectException {
         cleanBanList();
         refreshBlacklists( context );
         final Change change = getChange( context, content );
         if( !ignoreThisUser( context ) ) {
             checkBanList( context, change );
-            checkSinglePageChange( context, change );
+            checkSinglePageChange( context, content, change );
             checkIPList( context );
-            checkPatternList( context, change );
-            checkPageName( context);
+            checkPatternList( context, content, change );
+            checkPageName( context, content, change);
         }
         if( !m_stopAtFirstMatch ) {
             final Integer score = context.getVariable( ATTR_SPAMFILTER_SCORE );
             if( score != null && score >= m_scoreLimit ) {
                 throw new RedirectException( "Herb says you got too many points", getRedirectPage( context ) );
             }
         }
         log( context, ACCEPT, "-", change.toString() );
         return content;
     }
-    private void checkPageName(final Context context ) throws RedirectException {
+    private void checkPageName( final Context context, final String content, final Change change ) throws RedirectException {
         final Page page = context.getPage();
         final String pageName = page.getName();
         final int maxlength = Integer.parseInt(m_pageNameMaxLength);
         if ( pageName.length() > maxlength) {
             final String uid = log( context, REJECT, REASON_PAGENAME_TOO_LONG + "(" + m_pageNameMaxLength + ")" , pageName);
             LOG.info("SPAM:PageNameTooLong (" + uid + "). The length of the page name is too large (" + pageName.length() + " , limit is " + m_pageNameMaxLength + ")");
-            checkStrategy( context, "Herb says '" + pageName + "' is a bad pageName and I trust Herb! (Incident code " + uid + ")" );
-        }
-    }
-    private void checkStrategy(final Context context, final String message ) throws RedirectException {
+            checkStrategy( context, REASON_PAGENAME_TOO_LONG, "Herb says '" + pageName + "' is a bad pageName and I trust Herb! (Incident code " + uid + ")" );
+        }
+    }
+    private void checkStrategy( final Context context, final String error, final String message ) throws RedirectException {
         if( m_stopAtFirstMatch ) {
             throw new RedirectException( message, getRedirectPage( context ) );
         }
         Integer score = context.getVariable( ATTR_SPAMFILTER_SCORE );
         if( score != null ) {
             score = score + 1;
         } else {
             score = 1;
         }
         context.setVariable( ATTR_SPAMFILTER_SCORE, score );
@@ -340,24 +340,25 @@
             } catch( final IOException e ) {
                 LOG.info( "Could not read patterns; returning what I got" , e );
             }
         }
         return compiledpatterns;
     }
     /**
      * Takes a single page change and performs a load of tests on the content change. An admin can modify anything.
      *
      * @param context page Context
+     * @param content page content
      * @param change page change
      * @throws RedirectException spam filter rejects the page change.
      */
-    private synchronized void checkSinglePageChange(final Context context, final Change change )
+    private synchronized void checkSinglePageChange( final Context context, final String content, final Change change )
     		throws RedirectException {
         final HttpServletRequest req = context.getHttpRequest();
         if( req != null ) {
             final String addr = HttpUtil.getRemoteAddress( req );
             int hostCounter = 0;
             int changeCounter = 0;
             LOG.debug( "Change is " + change.m_change );
             final long time = System.currentTimeMillis() - 60*1000L; // 1 minute
             for( final Iterator< Host > i = m_lastModifications.iterator(); i.hasNext(); ) {
                 final Host host = i.next();
@@ -371,42 +372,42 @@
                 }
                 if( host.getChange() != null && host.getChange().equals( change ) ) {
                     changeCounter++;
                 }
             }
             if( hostCounter >= m_limitSinglePageChanges ) {
                 final Host host = new Host( addr, null );
                 m_temporaryBanList.add( host );
                 final String uid = log( context, REJECT, REASON_TOO_MANY_MODIFICATIONS, change.m_change );
                 LOG.info( "SPAM:TooManyModifications (" + uid + "). Added host " + addr + " to temporary ban list for doing too many modifications/minute" );
-                checkStrategy( context, "Herb says you look like a spammer, and I trust Herb! (Incident code " + uid + ")" );
+                checkStrategy( context, REASON_TOO_MANY_MODIFICATIONS, "Herb says you look like a spammer, and I trust Herb! (Incident code " + uid + ")" );
             }
             if( changeCounter >= m_limitSimilarChanges ) {
                 final Host host = new Host( addr, null );
                 m_temporaryBanList.add( host );
                 final String uid = log( context, REJECT, REASON_SIMILAR_MODIFICATIONS, change.m_change );
                 LOG.info( "SPAM:SimilarModifications (" + uid + "). Added host " + addr + " to temporary ban list for doing too many similar modifications" );
-                checkStrategy( context, "Herb says you look like a spammer, and I trust Herb! (Incident code "+uid+")");
+                checkStrategy( context, REASON_SIMILAR_MODIFICATIONS, "Herb says you look like a spammer, and I trust Herb! (Incident code "+uid+")");
             }
             String tstChange  = change.toString();
             int urlCounter = 0;
             while( m_matcher.contains( tstChange,m_urlPattern ) ) {
                 final MatchResult m = m_matcher.getMatch();
                 tstChange = tstChange.substring( m.endOffset(0) );
                 urlCounter++;
             }
             if( urlCounter > m_maxUrls ) {
                 final Host host = new Host( addr, null );
                 m_temporaryBanList.add( host );
                 final String uid = log( context, REJECT, REASON_TOO_MANY_URLS, change.toString() );
                 LOG.info( "SPAM:TooManyUrls (" + uid + "). Added host " + addr + " to temporary ban list for adding too many URLs" );
-                checkStrategy( context, "Herb says you look like a spammer, and I trust Herb! (Incident code " + uid + ")" );
+                checkStrategy( context, REASON_TOO_MANY_URLS, "Herb says you look like a spammer, and I trust Herb! (Incident code " + uid + ")" );
             }
             checkBotTrap( context, change );
             checkUTF8( context, change );
             checkAkismet( context, change );
             m_lastModifications.add( new Host( addr, change ) );
         }
     }
     /**
      *  Checks against the akismet system.
      *
@@ -448,21 +449,21 @@
                                                                commentAuthor,
                                                                commentAuthorEmail,
                                                                commentAuthorURL,
                                                                change.toString(),
                                                                null );
                 sw.stop();
                 LOG.debug( "Akismet request done in: " + sw );
                 if( isSpam ) {
                     final String uid = log( context, REJECT, REASON_AKISMET, change.toString() );
                     LOG.info( "SPAM:Akismet (" + uid + "). Akismet thinks this change is spam; added host to temporary ban list." );
-                    checkStrategy( context, "Akismet tells Herb you're a spammer, Herb trusts Akismet, and I trust Herb! (Incident code " + uid + ")" );
+                    checkStrategy( context, REASON_AKISMET, "Akismet tells Herb you're a spammer, Herb trusts Akismet, and I trust Herb! (Incident code " + uid + ")" );
                 }
             }
         }
     }
     /**
      * Returns a static string which can be used to detect spambots which just wildly fill in all the fields.
      *
      * @return A string
      */
     public static String getBotFieldName() {
@@ -475,32 +476,32 @@
      * @param change page change
      * @throws RedirectException spam filter rejects the page change.
      */
     private void checkBotTrap( final Context context, final Change change ) throws RedirectException {
         final HttpServletRequest request = context.getHttpRequest();
         if( request != null ) {
             final String unspam = request.getParameter( getBotFieldName() );
             if( unspam != null && !unspam.isEmpty() ) {
                 final String uid = log( context, REJECT, REASON_BOT_TRAP, change.toString() );
                 LOG.info( "SPAM:BotTrap (" + uid + ").  Wildly behaving bot detected." );
-                checkStrategy( context, "Spamming attempt detected. (Incident code " + uid + ")" );
+                checkStrategy( context, REASON_BOT_TRAP, "Spamming attempt detected. (Incident code " + uid + ")" );
             }
         }
     }
     private void checkUTF8( final Context context, final Change change ) throws RedirectException {
         final HttpServletRequest request = context.getHttpRequest();
         if( request != null ) {
             final String utf8field = request.getParameter( "encodingcheck" );
             if( utf8field != null && !utf8field.equals( "\u3041" ) ) {
                 final String uid = log( context, REJECT, REASON_UTF8_TRAP, change.toString() );
                 LOG.info( "SPAM:UTF8Trap (" + uid + ").  Wildly posting dumb bot detected." );
-                checkStrategy( context, "Spamming attempt detected. (Incident code " + uid + ")" );
+                checkStrategy( context, REASON_UTF8_TRAP, "Spamming attempt detected. (Incident code " + uid + ")" );
             }
         }
     }
     /** Goes through the ban list and cleans away any host which has expired from it. */
     private synchronized void cleanBanList() {
         final long now = System.currentTimeMillis();
         for( final Iterator< Host > i = m_temporaryBanList.iterator(); i.hasNext(); ) {
             final Host host = i.next();
             if( host.getReleaseTime() < now ) {
                 LOG.debug( "Removed host " + host.getAddress() + " from temporary ban list (expired)" );
@@ -516,21 +517,21 @@
      */
     private void checkBanList( final Context context, final Change change ) throws RedirectException {
         final HttpServletRequest req = context.getHttpRequest();
         if( req != null ) {
             final String remote = HttpUtil.getRemoteAddress(req);
             final long now = System.currentTimeMillis();
             for( final Host host : m_temporaryBanList ) {
                 if( host.getAddress().equals( remote ) ) {
                     final long timeleft = ( host.getReleaseTime() - now ) / 1000L;
                     log( context, REJECT, REASON_IP_BANNED_TEMPORARILY, change.m_change );
-                    checkStrategy( context,
+                    checkStrategy( context, REASON_IP_BANNED_TEMPORARILY,
                             "You have been temporarily banned from modifying this wiki. (" + timeleft + " seconds of ban left)" );
                 }
             }
         }
     }
     /**
      *  If the spam filter notices changes in the black list page, it will refresh them automatically.
      *
      *  @param context associated WikiContext
      */
@@ -573,64 +574,65 @@
         } catch( final IOException ex ) {
             LOG.info( "Unable to read attachment data, continuing...", ex );
         } catch( final ProviderException ex ) {
             LOG.info( "Failed to read spam filter attachment, continuing...", ex );
         }
     }
     /**
      * Does a check against a known pattern list.
      *
      * @param context page Context
+     * @param content page content
      * @param change page change
      * @throws RedirectException spam filter rejects the page change.
      */
-    private void checkPatternList( final Context context, final Change change ) throws RedirectException {
+    private void checkPatternList( final Context context, final String content, final Change change ) throws RedirectException {
         if( m_spamPatterns == null || context.getPage().getName().equals( m_forbiddenWordsPage ) ) {
             return;
         }
         String ch = change.toString();
         if( context.getHttpRequest() != null ) {
             ch += HttpUtil.getRemoteAddress( context.getHttpRequest() );
         }
         for( final Pattern p : m_spamPatterns ) {
             if( m_matcher.contains( ch, p ) ) {
                 final String uid = log( context, REJECT, REASON_REGEXP + "(" + p.getPattern() + ")", ch );
                 LOG.info( "SPAM:Regexp (" + uid + "). Content matches the spam filter '" + p.getPattern() + "'" );
-                checkStrategy( context, "Herb says '" + p.getPattern() + "' is a bad spam word and I trust Herb! (Incident code " + uid + ")" );
+                checkStrategy( context, REASON_REGEXP, "Herb says '" + p.getPattern() + "' is a bad spam word and I trust Herb! (Incident code " + uid + ")" );
             }
         }
     }
     /**
      *  Does a check against a pattern list of IPs.
      *
      *  @param context page context
      *  @throws RedirectException spam filter rejects the page change.
      */
     private void checkIPList( final Context context ) throws RedirectException {
         if( m_IPPatterns == null || context.getPage().getName().equals( m_forbiddenIPsPage ) ) {
             return;
         }
         final String remoteIP = HttpUtil.getRemoteAddress( context.getHttpRequest() );
         LOG.info("Attempting to match remoteIP " + remoteIP + " against " + m_IPPatterns.size() + " patterns");
         for( final Pattern p : m_IPPatterns ) {
              LOG.debug("Attempting to match remoteIP with " + p.getPattern());
             if( m_matcher.contains( remoteIP, p ) ) {
                 final String uid = log( context, REJECT, REASON_IP_BANNED_PERMANENTLY + "(" + p.getPattern() + ")", remoteIP );
                 LOG.info( "SPAM:IPBanList (" + uid + "). remoteIP matches the IP filter '" + p.getPattern() + "'" );
-                checkStrategy( context, "Herb says '" + p.getPattern() + "' is a banned IP and I trust Herb! (Incident code " + uid + ")" );
-            }
-        }
-    }
-    private void checkPatternList( final Context context, final String change ) throws RedirectException {
+                checkStrategy( context, REASON_IP_BANNED_PERMANENTLY, "Herb says '" + p.getPattern() + "' is a banned IP and I trust Herb! (Incident code " + uid + ")" );
+            }
+        }
+    }
+    private void checkPatternList( final Context context, final String content, final String change ) throws RedirectException {
         final Change c = new Change();
         c.m_change = change;
-        checkPatternList( context, c );
+        checkPatternList( context, content, c );
     }
     /**
      *  Creates a simple text string describing the added content.
      *
      *  @param context page context
      *  @param newText added content
      *  @return Empty string, if there is no change.
      */
     private static Change getChange( final Context context, final String newText ) {
         final Page page = context.getPage();
@@ -718,23 +720,23 @@
     /**
      *  Checks whether the UserProfile matches certain checks.
      *
      *  @param profile The profile to check
      *  @param context The WikiContext
      *  @return False, if this userprofile is suspect and should not be allowed to be added.
      *  @since 2.6.1
      */
     public boolean isValidUserProfile( final Context context, final UserProfile profile ) {
         try {
-            checkPatternList( context, profile.getEmail() );
-            checkPatternList( context, profile.getFullname() );
-            checkPatternList( context, profile.getLoginName() );
+            checkPatternList( context, profile.getEmail(), profile.getEmail() );
+            checkPatternList( context, profile.getFullname(), profile.getFullname() );
+            checkPatternList( context, profile.getLoginName(), profile.getLoginName() );
         } catch( final RedirectException e ) {
             LOG.info("Detected attempt to create a spammer user account (see above for rejection reason)");
             return false;
         }
         return true;
     }
     /**
      *  This method is used to calculate an unique code when submitting the page to detect edit conflicts.  
      *  It currently incorporates the last-modified date of the page, and the IP address of the submitter.
      *

--- a/jspwiki-main/src/main/java/org/apache/wiki/forms/FormOpen.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/forms/FormOpen.java
@@ -1,36 +1,35 @@
-/*
+/* 
     Licensed to the Apache Software Foundation (ASF) under one
     or more contributor license agreements.  See the NOTICE file
     distributed with this work for additional information
     regarding copyright ownership.  The ASF licenses this file
     to you under the Apache License, Version 2.0 (the
     "License"); you may not use this file except in compliance
     with the License.  You may obtain a copy of the License at
        http://www.apache.org/licenses/LICENSE-2.0
     Unless required by applicable law or agreed to in writing,
     software distributed under the License is distributed on an
     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
     KIND, either express or implied.  See the License for the
     specific language governing permissions and limitations
-    under the License.
+    under the License.  
  */
 package org.apache.wiki.forms;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.apache.wiki.api.core.Context;
 import org.apache.wiki.api.core.ContextEnum;
 import org.apache.wiki.api.exceptions.PluginException;
 import org.apache.wiki.api.plugin.Plugin;
 import org.apache.wiki.http.filter.CsrfProtectionFilter;
 import org.apache.wiki.preferences.Preferences;
-import org.apache.wiki.util.TextUtil;
 import java.text.MessageFormat;
 import java.util.Map;
 import java.util.ResourceBundle;
 /**
  *  Opens a WikiForm.
  *
  * Builds the HTML code for opening a FORM.
  *
  * <p>Since we're only providing an opening FORM tag, we can't use
  * the ECS utilities.
@@ -66,27 +65,27 @@
 public class FormOpen extends FormElement {
     private static final Logger LOG = LogManager.getLogger( FormOpen.class );
     /** Parameter name for setting the method (GET or POST).  Value is <tt>{@value}</tt>. */
     public static final String PARAM_METHOD = "method";
     /**
      *  {@inheritDoc}
      */
     @Override
     public String execute( final Context ctx, final Map< String, String > params ) throws PluginException {
         final ResourceBundle rb = Preferences.getBundle( ctx, Plugin.CORE_PLUGINS_RESOURCEBUNDLE );
-        final String formName = TextUtil.replaceEntities( params.get( PARAM_FORM ) );
+        final String formName = params.get( PARAM_FORM );
         if( formName == null ) {
             throw new PluginException( MessageFormat.format( rb.getString( "formopen.missingparam" ), PARAM_FORM ) );
         }
         final String hide     = params.get( PARAM_HIDEFORM );
         final String sourcePage = ctx.getPage().getName();
-        String submitServlet = TextUtil.replaceEntities( params.get( PARAM_SUBMITHANDLER ) );
+        String submitServlet = params.get( PARAM_SUBMITHANDLER );
         if( submitServlet == null )
             submitServlet = ctx.getURL( ContextEnum.PAGE_VIEW.getRequestContext(), sourcePage );
         String method = params.get( PARAM_METHOD );
         if( method == null ) {
             method="post";
         }
         if( !( method.equalsIgnoreCase( "get" ) || method.equalsIgnoreCase( "post" ) ) ) {
             throw new PluginException( rb.getString( "formopen.postorgetonly" ) );
         }
         FormInfo info = getFormInfo( ctx );

--- a/jspwiki-main/src/main/java/org/apache/wiki/forms/FormOutput.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/forms/FormOutput.java
@@ -1,75 +1,74 @@
-/*
+/* 
     Licensed to the Apache Software Foundation (ASF) under one
     or more contributor license agreements.  See the NOTICE file
     distributed with this work for additional information
     regarding copyright ownership.  The ASF licenses this file
     to you under the Apache License, Version 2.0 (the
     "License"); you may not use this file except in compliance
     with the License.  You may obtain a copy of the License at
        http://www.apache.org/licenses/LICENSE-2.0
     Unless required by applicable law or agreed to in writing,
     software distributed under the License is distributed on an
     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
     KIND, either express or implied.  See the License for the
     specific language governing permissions and limitations
-    under the License.
+    under the License.  
  */
 package org.apache.wiki.forms;
 import org.apache.wiki.api.core.Context;
 import org.apache.wiki.api.core.ContextEnum;
 import org.apache.wiki.api.exceptions.PluginException;
 import org.apache.wiki.api.plugin.Plugin;
 import org.apache.wiki.plugin.DefaultPluginManager;
 import org.apache.wiki.plugin.PluginManager;
 import org.apache.wiki.preferences.Preferences;
 import org.apache.wiki.util.FormUtil;
-import org.apache.wiki.util.TextUtil;
 import java.text.MessageFormat;
 import java.util.Map;
 import java.util.ResourceBundle;
 /**
  */
 public class FormOutput extends FormElement {
     /**
      * Executes the FormHandler specified in a Form 'output' plugin,
      * using entries provided in the HttpRequest as FormHandler
      * parameters.
      * <p>
      * If the parameter 'populate' was given, the WikiPlugin it names
      * is used to get default values. (It probably makes a lot of
-     * sense for this to be the same plugin as the handler.)
+     * sense for this to be the same plugin as the handler.) 
      * Information for the populator can be given with the FormSet
      * plugin. If 'populate' is not specified, the form is not
      * displayed.
      * <p>
      * Should there be no HTTP request associated with this request,
      * the method will return immediately with an empty string.
-     *
+     * 
      * @param ctx {@inheritDoc}
      * @param params {@inheritDoc}
      * @return {@inheritDoc}
      */
     @Override
     public String execute( final Context ctx, final Map< String, String > params ) throws PluginException {
         if( ctx.getHttpRequest() == null ) {
             return "";
         }
         final ResourceBundle rb = Preferences.getBundle( ctx, Plugin.CORE_PLUGINS_RESOURCEBUNDLE );
-        final String formName   = TextUtil.replaceEntities( params.get( PARAM_FORM ) );
+        final String formName   = params.get( PARAM_FORM );
         final String submitForm = ctx.getHttpParameter( PARAM_FORMNAMEHIDDEN );
         final String populator  = params.get( PARAM_POPULATE );
         if( formName == null || !formName.equals( submitForm ) ) {
             if( !PARAM_HANDLER.equals( populator ) )
                 return "";
         }
-        final String handler = TextUtil.replaceEntities( params.get( PARAM_HANDLER ) );
+        final String handler = params.get( PARAM_HANDLER );
         if( handler == null || handler.isEmpty() ) {
             return "<p class=\"error\">" + MessageFormat.format( rb.getString( "formoutput.missingargument" ), PARAM_HANDLER ) + "</p>";
         }
         final String sourcePage = ctx.getPage().getName();
         final String submitServlet = ctx.getURL( ContextEnum.PAGE_VIEW.getRequestContext(), sourcePage );
         FormInfo info = getFormInfo( ctx );
         if( info == null ) {
             info = new FormInfo();
             info.setName( formName );
         }

--- a/jspwiki-main/src/main/java/org/apache/wiki/modules/ModuleManager.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/modules/ModuleManager.java
@@ -1,26 +1,10 @@
-/*
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-       http://www.apache.org/licenses/LICENSE-2.0
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
- */
 package org.apache.wiki.modules;
 import java.util.Collection;
 public interface ModuleManager {
     /** Location of the property-files of plugins. (Each plugin should include this property-file in its jar-file) */
     String PLUGIN_RESOURCE_LOCATION = "ini/jspwiki_module.xml";
     /**
      *  Returns true, if the given module is compatible with this version of JSPWiki.
      *
      *  @param info The module to check
      *  @return True, if the module is compatible.

--- a/jspwiki-main/src/main/java/org/apache/wiki/parser/JSPWikiMarkupParser.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/parser/JSPWikiMarkupParser.java
@@ -1221,24 +1221,25 @@
                 if( braceLevel == 0 ) {
                     break;
                 }
             }
             sb.append( ( char ) ch );
         }
         return sb.toString();
     }
     /**
      * Handles constructs of type %%(style) and %%class
+     * @param newLine
      * @return An Element containing the div or span, depending on the situation.
      * @throws IOException
      */
-    private Element handleDiv( ) throws IOException {
+    private Element handleDiv( final boolean newLine ) throws IOException {
         int ch = nextToken();
         Element el = null;
         if( ch == '%' ) {
             String style = null;
             String clazz = null;
             ch = nextToken();
             if( ch == '(' ) {
                 style = readBraceContent('(',')');
             } else if( Character.isLetter( (char) ch ) ) {
                 pushBack( ch );
@@ -1290,25 +1291,25 @@
                 el = new Element("div");
                 m_styleStack.push( Boolean.FALSE );
             }
             if( style != null ) el.setAttribute("style", style);
             if( clazz != null ) el.setAttribute("class", clazz);
             return pushElement( el );
         }
         pushBack( ch );
         return el;
     }
-    private Element handleSlash( ) throws IOException {
+    private Element handleSlash( final boolean newLine ) throws IOException {
         final int ch = nextToken();
         pushBack( ch );
         if( ch == '%' && !m_styleStack.isEmpty() ) {
-            return handleDiv();
+            return handleDiv( newLine );
         }
         return null;
     }
     private Element handleBar( final boolean newLine ) throws IOException {
         Element el;
         if( !m_istable && !newLine ) {
             return null;
         }
         if( newLine ) {
             if( !m_istable ) {
@@ -1553,24 +1554,24 @@
                 el = handleGeneralList();
             }
             break;
           case '|':
             el = handleBar( m_newLine );
             break;
           case '~':
             el = handleTilde();
             break;
           case '%':
-            el = handleDiv();
+            el = handleDiv( m_newLine );
             break;
           case '/':
-            el = handleSlash();
+            el = handleSlash( m_newLine );
             break;
           default:
             break;
         }
         return el != null ? ELEMENT : CHARACTER;
     }
     private void closeHeadings() {
         if( m_lastHeading != null && !m_wysiwygEditorMode ) {
             addElement( new Element("a").setAttribute( "class",HASHLINK )
                                               .setAttribute( "href","#" + m_lastHeading.m_titleAnchor )

--- a/jspwiki-main/src/main/java/org/apache/wiki/parser/LinkParser.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/parser/LinkParser.java
@@ -14,21 +14,20 @@
     specific language governing permissions and limitations
     under the License.
  */
 package org.apache.wiki.parser;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.StringTokenizer;
-import java.util.stream.IntStream;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.jdom2.Attribute;
 /**
  *  Parses JSPWiki-style "augmented" link markup into a Link object
  *  containing the link text, link reference, and any optional link
  *  attributes (as JDOM Attributes).
  *  <p>
  *  The parser recognizes three link forms:
  *  </p>
@@ -280,21 +279,25 @@
     }
     /**
      *  Returns true if the String <tt>s</tt> is completely
      *  composed of whitespace.
      *
      *  @param s The string to check
      *  @return True, if "s" is all XML whitespace.
      */
     public static final boolean isSpace(final String s )
     {
-        return IntStream.range(0, s.length()).allMatch(i -> isSpace(s.charAt(i)));
+        for( int i = 0 ; i < s.length() ; i++ )
+        {
+            if( !isSpace( s.charAt(i)) ) return false;
+        }
+        return true;
     }
     /**
      *  Returns true if char <tt>c</tt> is a member of
      *  <tt>S</tt> (space) [XML 1.1 production 3].
      *
      *  @param c Character to check.
      *  @return True, if the character is an XML space.
      */
     public static final boolean isSpace(final char c )
     {

--- a/jspwiki-main/src/main/java/org/apache/wiki/plugin/AbstractReferralPlugin.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/plugin/AbstractReferralPlugin.java
@@ -41,21 +41,20 @@
 import org.apache.wiki.util.comparators.CollatorComparator;
 import org.apache.wiki.util.comparators.HumanComparator;
 import org.apache.wiki.util.comparators.JavaNaturalComparator;
 import org.apache.wiki.util.comparators.LocaleComparator;
 import java.io.IOException;
 import java.text.Collator;
 import java.text.ParseException;
 import java.text.RuleBasedCollator;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collection;
 import java.util.Date;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.stream.Collectors;
 /**
  *  This is a base class for all plugins using referral things.
  *
  *  <p>Parameters (also valid for all subclasses of this class) : </p>
@@ -205,25 +204,33 @@
      *
      *  @param c The collection to filter.
      *  @return A filtered collection.
      */
     protected List< String > filterCollection( final Collection< String > c ) {
         final ArrayList< String > result = new ArrayList<>();
         final PatternMatcher pm = new Perl5Matcher();
         for( final String pageName : c ) {
             boolean includeThis = m_include == null;
             if( m_include != null ) {
-                includeThis = Arrays.stream(m_include).anyMatch(pattern -> pm.matches(pageName, pattern)) ? true : m_include == null;
+                for( final Pattern pattern : m_include ) {
+                    if( pm.matches( pageName, pattern ) ) {
+                        includeThis = true;
+                        break;
+                    }
+                }
             }
             if( m_exclude != null ) {
-                if (Arrays.stream(m_exclude).anyMatch(pattern -> pm.matches(pageName, pattern))) {
-                    includeThis = false;
+                for( final Pattern pattern : m_exclude ) {
+                    if( pm.matches( pageName, pattern ) ) {
+                        includeThis = false;
+                        break; // The inner loop, continue on the next item
+                    }
                 }
             }
             if( includeThis ) {
                 result.add( pageName );
                 final Page page;
                 if( m_lastModified ) {
                     page = m_engine.getManager( PageManager.class ).getPage( pageName );
                     if( page != null ) {
                         final Date lastModPage = page.getLastModified();
                         LOG.debug( "lastModified Date of page {} : {}", pageName, m_dateLastModified );

--- a/jspwiki-main/src/main/java/org/apache/wiki/plugin/BugReportHandler.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/plugin/BugReportHandler.java
@@ -5,37 +5,36 @@
     regarding copyright ownership.  The ASF licenses this file
     to you under the Apache License, Version 2.0 (the
     "License"); you may not use this file except in compliance
     with the License.  You may obtain a copy of the License at
        http://www.apache.org/licenses/LICENSE-2.0
     Unless required by applicable law or agreed to in writing,
     software distributed under the License is distributed on an
     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
     KIND, either express or implied.  See the License for the
     specific language governing permissions and limitations
-    under the License.
+    under the License.  
  */
 package org.apache.wiki.plugin;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.apache.wiki.api.core.Context;
 import org.apache.wiki.api.core.Engine;
 import org.apache.wiki.api.core.Page;
 import org.apache.wiki.api.exceptions.PluginException;
 import org.apache.wiki.api.exceptions.RedirectException;
 import org.apache.wiki.api.exceptions.WikiException;
 import org.apache.wiki.api.plugin.Plugin;
 import org.apache.wiki.api.spi.Wiki;
 import org.apache.wiki.pages.PageManager;
 import org.apache.wiki.parser.MarkupParser;
 import org.apache.wiki.preferences.Preferences;
-import org.apache.wiki.util.TextUtil;
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.security.Principal;
 import java.text.MessageFormat;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Map;
 import java.util.Properties;
 import java.util.ResourceBundle;
 import java.util.StringTokenizer;
@@ -113,21 +112,21 @@
                      ) ) {
                     final String head = mappings.getProperty( entry.getKey(), entry.getKey() );
                     if( !head.isEmpty() ) {
                         out.println( "|" + head + "|" + entry.getValue() );
                     }
                 }
             }
             out.println();
             out.println( description );
             out.close();
-            final String pageName = findNextPage( context, title, TextUtil.replaceEntities(params.get( PARAM_PAGE )) );
+            final String pageName = findNextPage( context, title, params.get( PARAM_PAGE ) );
             final Page newPage = Wiki.contents().page( context.getEngine(), pageName );
             final Context newContext = context.clone();
             newContext.setPage( newPage );
             context.getEngine().getManager( PageManager.class ).saveText( newContext, str.toString() );
             final MessageFormat formatter = new MessageFormat("");
             formatter.applyPattern( rb.getString("bugreporthandler.new") );
             final String[] args = { "<a href=\""+context.getViewURL(pageName)+"\">"+pageName+"</a>" };
             return formatter.format( args );
         } catch( final RedirectException e ) {
             LOG.info("Saving not allowed, reason: '"+e.getMessage()+"', can't redirect to "+e.getRedirect());

--- a/jspwiki-main/src/main/java/org/apache/wiki/plugin/CurrentTimePlugin.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/plugin/CurrentTimePlugin.java
@@ -1,58 +1,57 @@
-/*
+/* 
     Licensed to the Apache Software Foundation (ASF) under one
     or more contributor license agreements.  See the NOTICE file
     distributed with this work for additional information
     regarding copyright ownership.  The ASF licenses this file
     to you under the Apache License, Version 2.0 (the
     "License"); you may not use this file except in compliance
     with the License.  You may obtain a copy of the License at
        http://www.apache.org/licenses/LICENSE-2.0
     Unless required by applicable law or agreed to in writing,
     software distributed under the License is distributed on an
     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
     KIND, either express or implied.  See the License for the
     specific language governing permissions and limitations
-    under the License.
+    under the License.  
  */
 package org.apache.wiki.plugin;
 import org.apache.wiki.api.core.Context;
 import org.apache.wiki.api.exceptions.PluginException;
 import org.apache.wiki.api.plugin.Plugin;
 import org.apache.wiki.preferences.Preferences;
 import org.apache.wiki.preferences.Preferences.TimeFormat;
-import org.apache.wiki.util.TextUtil;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Map;
 import java.util.ResourceBundle;
 /**
  *  Just displays the current date and time.
  *  The time format is exactly like in the java.text.SimpleDateFormat class.
- *
+ *  
  *  <p>Parameters : </p>
  *  NONE
  *  @since 1.7.8
  *  @see java.text.SimpleDateFormat
  */
 public class CurrentTimePlugin implements Plugin {
     /**
      *  {@inheritDoc}
      */
     @Override
     public String execute( final Context context, final Map< String, String > params ) throws PluginException {
         final String formatString = params.get( "format" );
         try {
             final SimpleDateFormat fmt;
             if( formatString != null ) {
                 fmt = new SimpleDateFormat( formatString );
             } else {
                 fmt = Preferences.getDateFormat( context, TimeFormat.DATETIME );
             }
             final Date d = new Date();  // Now.
-            return TextUtil.replaceEntities( fmt.format( d ) );
+            return fmt.format( d );
         } catch( final IllegalArgumentException e ) {
             final ResourceBundle rb = Preferences.getBundle( context, Plugin.CORE_PLUGINS_RESOURCEBUNDLE );
             throw new PluginException( rb.getString( "currenttimeplugin.badformat" ) + e.getMessage() );
         }
     }
 }

--- a/jspwiki-main/src/main/java/org/apache/wiki/plugin/Denounce.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/plugin/Denounce.java
@@ -133,21 +133,26 @@
             LOG.debug( "invalid link {} - {}", link, e.getMessage() );
             return false;
         }
         return true;
     }
     /**
      *  Returns true, if the path is found among the referers.
      */
     private boolean matchPattern( final List< Pattern > list, final String path ) {
         final PatternMatcher matcher = new Perl5Matcher();
-        return list.stream().anyMatch(pattern -> matcher.matches(path, pattern));
+        for( final Pattern pattern : list ) {
+            if( matcher.matches( path, pattern ) ) {
+                return true;
+            }
+        }
+        return false;
     }
     private boolean matchHeaders( final HttpServletRequest request ) {
         final String userAgent = request.getHeader( "User-Agent" );
         if( userAgent != null && matchPattern( c_agentPatterns, userAgent ) ) {
             LOG.debug( "Matched user agent " + userAgent + " for denounce." );
             return true;
         }
         final String refererPath = request.getHeader( "Referer" );
         if( refererPath != null && matchPattern( c_refererPatterns, refererPath ) ) {
             LOG.debug( "Matched referer " + refererPath + " for denounce." );

--- a/jspwiki-main/src/main/java/org/apache/wiki/plugin/IndexPlugin.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/plugin/IndexPlugin.java
@@ -27,21 +27,20 @@
 import org.apache.wiki.references.ReferenceManager;
 import org.jdom2.Element;
 import org.jdom2.Namespace;
 import org.jdom2.output.Format;
 import org.jdom2.output.XMLOutputter;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.regex.Pattern;
-import java.util.stream.Collectors;
 /**
  *  A Plugin that creates an index of pages according to a certain pattern.
  *  <br />
  *  The default is to include all pages.
  *  <p>
  *  This is a rewrite of the earlier JSPWiki IndexPlugin using JDOM2.
  8  </p>
  *  <p>
  *  Parameters (from AbstractReferralPlugin):
  *  </p>
@@ -116,16 +115,23 @@
      *  
      * @param context
      * @param include
      * @param exclude
      * @return A list containing page names which matched the filters.
      * @throws ProviderException
      */
     private List<String> listPages( final Context context, final String include, final String exclude ) throws ProviderException {
         final Pattern includePtrn = include != null ? Pattern.compile( include ) : Pattern.compile(".*");
         final Pattern excludePtrn = exclude != null ? Pattern.compile( exclude ) : Pattern.compile("\\p{Cntrl}"); // there are no control characters in page names
-        final List< String > result;
+        final List< String > result = new ArrayList<>();
         final Set< String > pages = context.getEngine().getManager( ReferenceManager.class ).findCreated();
-        result = pages.stream().filter(pageName -> !excludePtrn.matcher(pageName).matches()).filter(pageName -> includePtrn.matcher(pageName).matches()).collect(Collectors.toList());
+        for( final String pageName : pages ) {
+            if( excludePtrn.matcher( pageName ).matches() ) {
+                continue;
+            }
+            if( includePtrn.matcher( pageName ).matches() ) {
+                result.add( pageName );
+            }
+        }
         return result;
     }
 }

--- a/jspwiki-main/src/main/java/org/apache/wiki/plugin/InsertPage.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/plugin/InsertPage.java
@@ -67,23 +67,23 @@
     private static final String ONCE_COOKIE = "JSPWiki.Once.";
     /** This attribute is stashed in the WikiContext to make sure that we don't have circular references. */
     public static final String ATTR_RECURSE    = "org.apache.wiki.plugin.InsertPage.recurseCheck";
     /**
      *  {@inheritDoc}
      */
     @Override @SuppressWarnings("unchecked")
     public String execute( final Context context, final Map<String, String> params ) throws PluginException {
         final Engine engine = context.getEngine();
         final StringBuilder res = new StringBuilder();
-        final String clazz        = TextUtil.replaceEntities(params.get( PARAM_CLASS ));
-        final String includedPage = TextUtil.replaceEntities(params.get( PARAM_PAGENAME ));
-        String style              = TextUtil.replaceEntities(params.get( PARAM_STYLE ));
+        final String clazz        = params.get( PARAM_CLASS );
+        final String includedPage = params.get( PARAM_PAGENAME );
+        String style              = params.get( PARAM_STYLE );
         final boolean showOnce    = "once".equals( params.get( PARAM_SHOW ) );
         final String defaultstr   = params.get( PARAM_DEFAULT );
         final int section         = TextUtil.parseIntParameter(params.get( PARAM_SECTION ), -1 );
         int maxlen                = TextUtil.parseIntParameter(params.get( PARAM_MAXLENGTH ), -1 );
         final ResourceBundle rb = Preferences.getBundle( context, Plugin.CORE_PLUGINS_RESOURCEBUNDLE );
         if( style == null ) {
             style = DEFAULT_STYLE;
         }
         if( maxlen == -1 ) {
             maxlen = Integer.MAX_VALUE;

--- a/jspwiki-main/src/main/java/org/apache/wiki/plugin/ReferringUndefinedPagesPlugin.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/plugin/ReferringUndefinedPagesPlugin.java
@@ -17,24 +17,22 @@
 package org.apache.wiki.plugin;
 import org.apache.wiki.api.core.Context;
 import org.apache.wiki.api.exceptions.PluginException;
 import org.apache.wiki.api.plugin.Plugin;
 import org.apache.wiki.preferences.Preferences;
 import org.apache.wiki.references.ReferenceManager;
 import org.apache.wiki.util.TextUtil;
 import java.text.MessageFormat;
 import java.util.Collection;
 import java.util.Map;
-import java.util.Objects;
 import java.util.ResourceBundle;
 import java.util.TreeMap;
-import java.util.stream.Collectors;
 /**
  *  <p>Lists all pages containing links to Undefined Pages (pages containing dead links).</p>
  *
  *  An original idea from Gregor Hagedorn.
  *
  *  @since 2.10.0
  */
 public class ReferringUndefinedPagesPlugin extends AbstractReferralPlugin {
     /** Parameter name for setting the maximum items to show.  Value is <tt>{@value}</tt>. */
     public static final String PARAM_MAX = "max";
@@ -45,23 +43,30 @@
         final ResourceBundle rb = Preferences.getBundle(context, Plugin.CORE_PLUGINS_RESOURCEBUNDLE);
         final ReferenceManager referenceManager = context.getEngine().getManager( ReferenceManager.class );
         final int items = TextUtil.parseIntParameter(params.get(PARAM_MAX), ALL_ITEMS);
         String extras = params.get(PARAM_EXTRAS);
         if (extras == null) {
             extras = rb.getString("referringundefinedpagesplugin.more");
         }
         final Collection< String > uncreatedPages = referenceManager.findUncreated();
         super.initialize( context, params );
         Collection< String > result = null;
-        final TreeMap< String, String > sortedMap;
+        final TreeMap< String, String > sortedMap = new TreeMap<>();
         if( uncreatedPages != null ) {
-            sortedMap = uncreatedPages.stream().map(referenceManager::findReferrers).filter(Objects::nonNull).flatMap(Collection::stream).collect(Collectors.toMap(referringPage -> referringPage, referringPage -> "", (a, b) -> b, TreeMap::new));
+            for( final String uncreatedPageName : uncreatedPages ) {
+                final Collection< String > referrers = referenceManager.findReferrers( uncreatedPageName );
+                if( referrers != null ) {
+                    for( final String referringPage : referrers ) {
+                        sortedMap.put( referringPage, "" );
+                    }
+                }
+            }
             result = sortedMap.keySet();
         }
         result = super.filterAndSortCollection( result );
         final String wikitext = wikitizeCollection( result, m_separator, items );
         final StringBuilder resultHTML = new StringBuilder();
         resultHTML.append( applyColumnsStyle( makeHTML( context, wikitext ) ) );
         if( items < result.size() && items > 0 ) {
             final Object[] args = { "" + ( result.size() - items ) };
             extras = MessageFormat.format( extras, args );
             resultHTML.append( "<br/>" ).append( extras ).append( "<br/>" );

--- a/jspwiki-main/src/main/java/org/apache/wiki/plugin/Search.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/plugin/Search.java
@@ -19,21 +19,20 @@
 import org.apache.logging.log4j.Logger;
 import org.apache.wiki.api.core.Context;
 import org.apache.wiki.api.core.ContextEnum;
 import org.apache.wiki.api.core.Engine;
 import org.apache.wiki.api.exceptions.PluginException;
 import org.apache.wiki.api.exceptions.ProviderException;
 import org.apache.wiki.api.plugin.Plugin;
 import org.apache.wiki.api.search.SearchResult;
 import org.apache.wiki.render.RenderingManager;
 import org.apache.wiki.search.SearchManager;
-import org.apache.wiki.util.TextUtil;
 import org.apache.wiki.util.XHTML;
 import org.apache.wiki.util.XhtmlUtil;
 import org.jdom2.Element;
 import java.io.IOException;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.Map;
 /**
  *  The "Search" plugin allows you to access the JSPWiki search routines and show the displays in an array on your page.
  *
@@ -68,21 +67,21 @@
         final String max         = params.get( PARAM_MAX );
         if ( set == null ) set = DEFAULT_SETNAME;
         if ( max != null ) maxItems = Integer.parseInt( max );
         if ( queryString == null ) {
             results = context.getVariable( set );
         } else {
             try {
                 results = doBasicQuery( context, queryString );
                 context.setVariable( set, results );
             } catch( final Exception e ) {
-                return "<div class='error'>" + TextUtil.replaceEntities(e.getMessage()) + "</div>\n";
+                return "<div class='error'>" + e.getMessage() + "</div>\n";
             }
         }
         String res = "";
         if ( results != null ) {
             res = renderResults(results,context,maxItems);
         }
         return res;
     }
     private Collection<SearchResult> doBasicQuery( final Context context, final String query ) throws ProviderException, IOException {
         LOG.debug( "Searching for string " + query );

--- a/jspwiki-main/src/main/java/org/apache/wiki/preferences/Preferences.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/preferences/Preferences.java
@@ -72,21 +72,21 @@
      *  @param pageContext The page context.
      */
     public static void reloadPreferences( final PageContext pageContext ) {
         final Preferences prefs = new Preferences();
         final Properties props = PropertyReader.loadWebAppProps( pageContext.getServletContext() );
         final Context ctx = Context.findContext( pageContext );
         final String dateFormat = ctx.getEngine().getManager( InternationalizationManager.class )
                                            .get( InternationalizationManager.CORE_BUNDLE, getLocale( ctx ), "common.datetimeformat" );
         prefs.put("SkinName", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.skinname", "PlainVanilla" ) );
         prefs.put("DateFormat", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.dateformat", dateFormat ) );
-        prefs.put("TimeZone", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.timezone", TimeZone.getDefault().getID() ) );
+        prefs.put("TimeZone", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.timezone", java.util.TimeZone.getDefault().getID() ) );
         prefs.put("Orientation", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.orientation", "fav-left" ) );
         prefs.put("Sidebar", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.sidebar", "active" ) );
         prefs.put("Layout", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.layout", "fluid" ) );
         prefs.put("Language", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.language", getLocale( ctx ).toString() ) );
         prefs.put("SectionEditing", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.sectionediting", "true" ) );
         prefs.put("Appearance", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.appearance", "true" ) );
         prefs.put("autosuggest", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.autosuggest", "true" ) );
         prefs.put("tabcompletion", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.tabcompletion", "true" ) );
         prefs.put("smartpairs", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.smartpairs", "false" ) );
         prefs.put("livepreview", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.livepreview", "true" ) );

--- a/jspwiki-main/src/main/java/org/apache/wiki/providers/CachingAttachmentProvider.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/providers/CachingAttachmentProvider.java
@@ -150,21 +150,25 @@
         return all;
     }
     /**
      *  Simply goes through the collection and attempts to locate the
      *  given attachment of that name.
      *
      *  @return null, if no such attachment was in this collection.
      */
     private Attachment findAttachmentFromCollection( final Collection< Attachment > c, final String name ) {
         if( c != null ) {
-            return c.stream().filter(att -> name.equals(att.getFileName())).findFirst().orElse(null);
+            for( final Attachment att : c ) {
+                if( name.equals( att.getFileName() ) ) {
+                    return att;
+                }
+            }
         }
         return null;
     }
     /**
      * {@inheritDoc}
      */
     @Override
     public Attachment getAttachmentInfo( final Page page, final String name, final int version ) throws ProviderException {
         LOG.debug( "Getting attachments for {}, name={}, version={}", page, name, version );
         if( version != WikiProvider.LATEST_VERSION ) {

--- a/jspwiki-main/src/main/java/org/apache/wiki/references/DefaultReferenceManager.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/references/DefaultReferenceManager.java
@@ -36,21 +36,20 @@
 import org.apache.wiki.pages.PageManager;
 import org.apache.wiki.render.RenderingManager;
 import org.apache.wiki.util.TextUtil;
 import java.io.*;
 import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.util.*;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.stream.Collectors;
 /*
   BUGS
   - if a wikilink is added to a page, then removed, RefMan still thinks that the page refers to the wikilink page. Hm.
   - if a page is deleted, gets very confused.
   - Serialization causes page attributes to be missing, when InitializablePlugins are not executed properly.  Thus,
     serialization should really also mark whether a page is serializable or not...
  */
 /*
    A word about synchronizing:
    I expect this object to be accessed in three situations:
@@ -81,21 +80,21 @@
  *  When a page is added or edited, its references are parsed, a Collection is received, and we crudely replace anything previous with
  *  this new Collection. We then check each referenced page name and make sure they know they are referred to by the new page.
  *  <P>
  *  Based on this information, we can perform non-optimal searches for e.g. unreferenced pages, top ten lists, etc.
  *  <P>
  *  The owning class must take responsibility of filling in any pre-existing information, probably by loading each and every WikiPage
  *  and calling this class to update the references when created.
  *
  *  @since 1.6.1 (as of 2.11.0, moved to org.apache.wiki.references)
  */
-public class DefaultReferenceManager extends BasePageFilter implements ReferenceManager, Serializable {
+public class DefaultReferenceManager extends BasePageFilter implements ReferenceManager {
     /**
      *  Maps page wikiname to a Collection of pages it refers to. The Collection must contain Strings. The Collection may contain
      *  names of non-existing pages.
      */
     private Map< String, Collection< String > > m_refersTo;
     private Map< String, Collection< String > > m_unmutableRefersTo;
     /**
      *  Maps page wikiname to a Set of referring pages. The Set must contain Strings. Non-existing pages (a reference exists, but
      *  not a file for the page contents) may have an empty Set in m_referredBy.
      */
@@ -416,26 +415,30 @@
      *  <p>
      *  This method does not synchronize the database to disk.
      *
      *  @param page Name of the page to update.
      *  @param references A Collection of Strings, each one pointing to a page this page references.
      */
     private void internalUpdateReferences( String page, final Collection< String > references) {
         page = getFinalPageName( page );
         final Collection< String > oldRefTo = m_refersTo.get( page );
         m_refersTo.remove( page );
-        final TreeSet< String > cleanedRefs = references.stream().map(this::getFinalPageName).collect(Collectors.toCollection(TreeSet::new));
+        final TreeSet< String > cleanedRefs = new TreeSet<>();
+        for( final String ref : references ) {
+            final String reference = getFinalPageName( ref );
+            cleanedRefs.add( reference );
+        }
         m_refersTo.put( page, cleanedRefs );
         if( !m_referredBy.containsKey( page ) ) {
             m_referredBy.put( page, new TreeSet<>() );
         }
-        cleanReferredBy( page, oldRefTo);
+        cleanReferredBy( page, oldRefTo, cleanedRefs );
         for( final String referredPageName : cleanedRefs ) {
             updateReferredBy( getFinalPageName( referredPageName ), page );
         }
     }
     /**
      * Returns the refers-to list. For debugging.
      *
      * @return The refers-to list.
      */
     protected Map< String, Collection< String > > getRefersTo() {
@@ -454,21 +457,22 @@
      *
      * Two ways to go about this. One is to look up all pages previously referred by referrer and remove referrer
      * from their lists, and let the update put them back in (except possibly removed ones).
      *
      * The other is to get the old referred-to list, compare to the new, and tell the ones missing in the latter to remove referrer from
      * their list.
      *
      * We'll just try the first for now. Need to come back and optimize this a bit.
      */
     private void cleanReferredBy( final String referrer,
-                                  final Collection< String > oldReferred ) {
+                                  final Collection< String > oldReferred,
+                                  final Collection< String > newReferred ) {
         if( oldReferred == null ) {
             return;
         }
         for( final String referredPage : oldReferred ) {
             final Set< String > oldRefBy = m_referredBy.get( referredPage );
             if( oldRefBy != null ) {
                 oldRefBy.remove( referrer );
             }
             if( ( oldRefBy == null || oldRefBy.isEmpty() ) && !m_engine.getManager( PageManager.class ).wikiPageExists( referredPage ) ) {
                 m_referredBy.remove( referredPage );
@@ -557,23 +561,31 @@
      * Finds all references to non-existant pages. This requires a linear scan through m_refersTo values; each value
      * must have a corresponding key entry in the reference Maps, otherwise such a page has never been created.
      * <P>
      * Returns a Collection containing Strings of unreferenced page names. Each non-existant page name is shown only
      * once - we don't return information on who referred to it.
      *
      * @return A Collection of Strings
      */
     @Override
     public Collection< String > findUncreated() {
-        final TreeSet< String > uncreated;
+        final TreeSet< String > uncreated = new TreeSet<>();
         final Collection< Collection< String > > allReferences = m_refersTo.values();
-        uncreated = allReferences.stream().filter(Objects::nonNull).flatMap(Collection::stream).filter(aReference -> !m_engine.getManager(PageManager.class).wikiPageExists(aReference)).collect(Collectors.toCollection(TreeSet::new));
+        for( final Collection<String> refs : allReferences ) {
+            if( refs != null ) {
+                for( final String aReference : refs ) {
+                    if( !m_engine.getManager( PageManager.class ).wikiPageExists( aReference ) ) {
+                        uncreated.add( aReference );
+                    }
+                }
+            }
+        }
         return uncreated;
     }
     /**
      *  Searches for the given page in the given Map, and returns the set of references. This method also takes care of
      *  English plural matching.
      *
      *  @param coll The Map to search in
      *  @param pagename The name to find.
      *  @return The references list.
      */

--- a/jspwiki-main/src/main/java/org/apache/wiki/render/CreoleRenderer.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/render/CreoleRenderer.java
@@ -16,22 +16,20 @@
  */
 package org.apache.wiki.render;
 import org.apache.wiki.api.core.Context;
 import org.apache.wiki.parser.PluginContent;
 import org.apache.wiki.parser.WikiDocument;
 import org.jdom2.Content;
 import org.jdom2.Element;
 import org.jdom2.Text;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.stream.Collectors;
-import java.util.stream.IntStream;
 /**
  *  Implements DOM-to-Creole rendering.
  *  <p>
  *  FIXME: This class is not yet completely done.
  *
  */
 public class CreoleRenderer extends WikiRenderer {
     private static final String IMG_START = "{{";
     private static final String IMG_END = "}}";
     private static final String PLUGIN_START = "<<";
@@ -88,21 +86,22 @@
                 endEl = ELEMENTS[i+2];
             }
         }
         if( UL.equals(ce.getName()) ) {
             m_listCount++;
             m_listChar = '*';
         } else if( OL.equals(ce.getName()) ) {
             m_listCount++;
             m_listChar = '#';
         } else if( LI.equals(ce.getName()) ) {
-            sb.append(IntStream.range(0, m_listCount).mapToObj(i -> String.valueOf(m_listChar)).collect(Collectors.joining("", "", ONE_SPACE)));
+            for(int i = 0; i < m_listCount; i++ ) sb.append( m_listChar );
+            sb.append( ONE_SPACE );
         } else if( A.equals( ce.getName() ) ) {
             final String href = ce.getAttributeValue( HREF_ATTRIBUTE );
             final String text = ce.getText();
             if( href.equals( text ) ) {
                 sb.append( HREF_START ).append( href ).append( HREF_END );
             } else {
                 sb.append( HREF_START ).append( href ).append( HREF_DELIMITER ).append( text ).append( HREF_END);
             }
             return;
         } else if( PRE.equals( ce.getName() ) ) {

--- a/jspwiki-main/src/main/java/org/apache/wiki/search/DefaultSearchManager.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/search/DefaultSearchManager.java
@@ -84,21 +84,21 @@
             return JSON_SEARCH;
         }
         /** {@inheritDoc} */
         @Override
         public void service( final HttpServletRequest req,
                              final HttpServletResponse resp,
                              final String actionName,
                              final List< String > params ) throws IOException {
             String result = "";
             if( StringUtils.isNotBlank( actionName ) ) {
-                if( params.isEmpty() ) {
+                if( params.size() < 1 ) {
                     return;
                 }
                 final String itemId = params.get( 0 );
                 LOG.debug( "itemId=" + itemId );
                 if( params.size() > 1 ) {
                     final String maxResultsParam = params.get( 1 );
                     LOG.debug( "maxResultsParam=" + maxResultsParam );
                     if( StringUtils.isNotBlank( maxResultsParam ) && StringUtils.isNumeric( maxResultsParam ) ) {
                         maxResults = Integer.parseInt( maxResultsParam );
                     }

--- a/jspwiki-main/src/main/java/org/apache/wiki/search/LuceneSearchProvider.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/search/LuceneSearchProvider.java
@@ -13,21 +13,20 @@
     KIND, either express or implied.  See the License for the
     specific language governing permissions and limitations
     under the License.    
  */
 package org.apache.wiki.search;
 import org.apache.commons.lang3.StringUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.classic.ClassicAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.IndexWriterConfig;
 import org.apache.lucene.index.IndexWriterConfig.OpenMode;
 import org.apache.lucene.index.Term;
@@ -65,43 +64,41 @@
 import org.apache.wiki.util.ClassUtil;
 import org.apache.wiki.util.FileUtil;
 import org.apache.wiki.util.TextUtil;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.StringReader;
 import java.io.StringWriter;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Date;
 import java.util.List;
 import java.util.Properties;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
-import java.util.stream.Collectors;
 /**
  * Interface for the search providers that handle searching the Wiki
  *
  * @since 2.2.21.
  */
 public class LuceneSearchProvider implements SearchProvider {
     protected static final Logger LOG = LogManager.getLogger( LuceneSearchProvider.class );
     private Engine m_engine;
     private Executor searchExecutor;
     /** Which analyzer to use.  Default is StandardAnalyzer. */
     public static final String PROP_LUCENE_ANALYZER      = "jspwiki.lucene.analyzer";
     private static final String PROP_LUCENE_INDEXDELAY   = "jspwiki.lucene.indexdelay";
     private static final String PROP_LUCENE_INITIALDELAY = "jspwiki.lucene.initialdelay";
-    private String m_analyzerClass = ClassicAnalyzer.class.getName();
+    private String m_analyzerClass = "org.apache.lucene.analysis.standard.ClassicAnalyzer";
     private static final String LUCENE_DIR = "lucene";
     /** These attachment file suffixes will be indexed. */
     public static final String[] SEARCHABLE_FILE_SUFFIXES = new String[] { ".txt", ".ini", ".xml", ".html", "htm", ".mm", ".htm",
                                                                            ".xhtml", ".java", ".c", ".cpp", ".php", ".asm", ".sh",
                                                                            ".properties", ".kml", ".gpx", ".loc", ".md", ".xml" };
     protected static final String LUCENE_ID            = "id";
     protected static final String LUCENE_PAGE_CONTENTS = "contents";
     protected static final String LUCENE_AUTHOR        = "author";
     protected static final String LUCENE_ATTACHMENTS   = "attachment";
     protected static final String LUCENE_PAGE_NAME     = "name";
@@ -228,21 +225,27 @@
     }
     /**
      * @param att Attachment to get content for. Filename extension is used to determine the type of the attachment.
      * @return String representing the content of the file.
      * FIXME This is a very simple implementation of some text-based attachment, mainly used for testing.
      * This should be replaced /moved to Attachment search providers or some other 'pluggable' way to search attachments
      */
     protected String getAttachmentContent( final Attachment att ) {
         final AttachmentManager mgr = m_engine.getManager( AttachmentManager.class );
         final String filename = att.getFileName();
-        boolean searchSuffix = Arrays.stream(SEARCHABLE_FILE_SUFFIXES).anyMatch(filename::endsWith);
+        boolean searchSuffix = false;
+        for( final String suffix : SEARCHABLE_FILE_SUFFIXES ) {
+            if( filename.endsWith( suffix ) ) {
+                searchSuffix = true;
+                break;
+            }
+        }
         String out = filename;
         if( searchSuffix ) {
             try( final InputStream attStream = mgr.getAttachmentStream( att ); final StringWriter sout = new StringWriter() ) {
                 FileUtil.copyContents( new InputStreamReader( attStream ), sout );
                 out = out + " " + sout;
             } catch( final ProviderException | IOException e ) {
                 LOG.error( "Attachment cannot be loaded", e );
             }
         }
         return out;
@@ -297,22 +300,25 @@
         doc.add( field );
         final String unTokenizedTitle = StringUtils.replaceChars( page.getName(), TextUtil.PUNCTUATION_CHARS_ALLOWED, PUNCTUATION_TO_SPACES );
         field = new Field( LUCENE_PAGE_NAME, TextUtil.beautifyString( page.getName() ) + " " + unTokenizedTitle, TextField.TYPE_STORED );
         doc.add( field );
         if( page.getAuthor() != null ) {
             field = new Field( LUCENE_AUTHOR, page.getAuthor(), TextField.TYPE_STORED );
             doc.add( field );
         }
         try {
             final List< Attachment > attachments = m_engine.getManager( AttachmentManager.class ).listAttachments( page );
-            final String attachmentNames = attachments.stream().map(att -> att.getName() + ";").collect(Collectors.joining());
-            field = new Field( LUCENE_ATTACHMENTS, attachmentNames, TextField.TYPE_STORED );
+            final StringBuilder attachmentNames = new StringBuilder();
+            for( final Attachment att : attachments ) {
+                attachmentNames.append( att.getName() ).append( ";" );
+            }
+            field = new Field( LUCENE_ATTACHMENTS, attachmentNames.toString(), TextField.TYPE_STORED );
             doc.add( field );
         } catch( final ProviderException e ) {
             LOG.error( "Failed to get attachments for page", e );
         }
         if( page.getAttribute( "keywords" ) != null ) {
             field = new Field( LUCENE_PAGE_KEYWORDS, page.getAttribute( "keywords" ).toString(), TextField.TYPE_STORED );
             doc.add( field );
         }
         synchronized( writer ) {
             writer.addDocument( doc );

--- a/jspwiki-main/src/main/java/org/apache/wiki/tags/AdminBeanIteratorTag.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/tags/AdminBeanIteratorTag.java
@@ -13,21 +13,20 @@
     KIND, either express or implied.  See the License for the
     specific language governing permissions and limitations
     under the License.  
  */
 package org.apache.wiki.tags;
 import org.apache.wiki.api.core.Context;
 import org.apache.wiki.ui.admin.AdminBean;
 import org.apache.wiki.ui.admin.AdminBeanManager;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.stream.Collectors;
 /**
  *  Provides an iterator for all AdminBeans of a given type.
  *
  */
 public class AdminBeanIteratorTag extends IteratorTag {
     private static final long serialVersionUID = 1L;
     private int m_type;
     /**
      *  Set the type of the bean.
      *  
@@ -39,14 +38,19 @@
     	}
         m_type = m_wikiContext.getEngine().getManager( AdminBeanManager.class ).getTypeFromString( type );
     }
     /**
      *  {@inheritDoc}
      */
     @Override
     public void resetIterator() {
         final AdminBeanManager mgr = m_wikiContext.getEngine().getManager( AdminBeanManager.class );
         final Collection< AdminBean > beans = mgr.getAllBeans();
-        final ArrayList< AdminBean > typedBeans = beans.stream().filter(ab -> ab.getType() == m_type).collect(Collectors.toCollection(ArrayList::new));
+        final ArrayList< AdminBean > typedBeans = new ArrayList<>();
+        for( final AdminBean ab : beans ) {
+            if( ab.getType() == m_type ) {
+                typedBeans.add( ab );
+            }
+        }
         setList( typedBeans );
     }
 }

--- a/jspwiki-main/src/main/java/org/apache/wiki/tags/EditorIteratorTag.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/tags/EditorIteratorTag.java
@@ -13,32 +13,33 @@
     KIND, either express or implied.  See the License for the
     specific language governing permissions and limitations
     under the License.  
  */
 package org.apache.wiki.tags;
 import org.apache.wiki.api.core.Context;
 import org.apache.wiki.api.core.Engine;
 import org.apache.wiki.ui.Editor;
 import org.apache.wiki.ui.EditorManager;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collection;
-import java.util.stream.Collectors;
 /**
  *  Iterates through editors.
  *
  *  @since 2.4.12
  */
 public class EditorIteratorTag extends IteratorTag  {
     private static final long serialVersionUID = 0L;
     /** {@inheritDoc} */
     @Override
     public final int doStartTag() {
         m_wikiContext = Context.findContext(pageContext);
         final Engine engine = m_wikiContext.getEngine();
         final EditorManager mgr = engine.getManager( EditorManager.class );
         final String[] editorList = mgr.getEditorList();
-        final Collection< Editor > editors = Arrays.stream(editorList).map(editor -> new Editor(m_wikiContext, editor)).collect(Collectors.toList());
+        final Collection< Editor > editors = new ArrayList<>();
+        for( final String editor : editorList ) {
+            editors.add( new Editor( m_wikiContext, editor ) );
+        }
         setList( editors );
         return super.doStartTag();
     }
 }

--- a/jspwiki-main/src/main/java/org/apache/wiki/tags/TabTag.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/tags/TabTag.java
@@ -8,145 +8,169 @@
     with the License.  You may obtain a copy of the License at
        http://www.apache.org/licenses/LICENSE-2.0
     Unless required by applicable law or agreed to in writing,
     software distributed under the License is distributed on an
     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
     KIND, either express or implied.  See the License for the
     specific language governing permissions and limitations
     under the License.  
  */
 package org.apache.wiki.tags;
+import java.io.IOException;
+import javax.servlet.jsp.JspTagException;
 import org.apache.wiki.util.TextUtil;
-import javax.servlet.jsp.JspTagException;
-import java.io.IOException;
 /**
- *  Generates single tabbed page layout. Works together with the tabbedSection javascript.  Note that if you do not
+ *  Generates single tabbed page layout.
+ *  Works together with the tabbedSection javascript.  Note that if you do not
  *  specify an url, the body contents of the tag are loaded by the tag itself.
  *
  *  <P><B>Attributes</B></P>
  *  <UL>
  *    <LI>id - ID for this tab. (mandatory)
  *    <LI>title - Title of this tab. (mandatory)
  *    <LI>accesskey - Single char usable as quick accesskey (alt- or ctrl-) (optional)
  *    <li>url - If you <i>don't</i> want to create a Javascript-enabled tag, you can use this
  *              to make the tab look just the usual tag, but instead, it will actually link
  *              to that page.  This can be useful in certain cases where you have something
  *              that you want to look like a part of a tag, but for example, due to it being
  *              very big in size, don't want to include it as a part of the page content
  *              every time.
  *  </UL>
  *
  *  @since v2.3.63
  */
-public class TabTag extends WikiTagBase {
+public class TabTag extends WikiTagBase
+{
     private static final long serialVersionUID = -8534125226484616489L;
     private String m_accesskey;
     private String m_tabTitle;
     private String m_url;
     /**
      * {@inheritDoc}
      */
     @Override
-    public void doFinally() {
+    public void doFinally()
+    {
         super.doFinally();
         m_accesskey = null;
         m_tabTitle  = null;
         m_url       = null;
     }
     /**
      * Sets the tab title.
      * @param aTabTitle the tab title
      */
-    public void setTitle( final String aTabTitle ) {
+    public void setTitle(final String aTabTitle)
+    {
         m_tabTitle = TextUtil.replaceEntities( aTabTitle );
     }
     /**
      * Sets the tab access key.
-     *
      * @param anAccesskey the access key
      */
-    public void setAccesskey( final String anAccesskey ) {
+    public void setAccesskey(final String anAccesskey)
+    {
         m_accesskey = TextUtil.replaceEntities( anAccesskey ); //take only the first char
     }
     /**
      * Sets the tab URL.
-     *
      * @param url the URL
      */
-    public void setUrl( final String url ) {
+    public void setUrl(final String url )
+    {
         m_url = TextUtil.replaceEntities( url );
     }
-    private boolean handleAccesskey() {
-        if( ( m_tabTitle == null ) || ( m_accesskey == null ) ) return false;
+    private boolean handleAccesskey()
+    {
+        if( (m_tabTitle == null) || (m_accesskey == null) ) return false;
         final int pos = m_tabTitle.toLowerCase().indexOf( m_accesskey.toLowerCase() );
-        if( pos > -1 ) {
+        if( pos > -1 )
+        {
             m_tabTitle = m_tabTitle.substring( 0, pos ) + "<span class='accesskey'>"
-                    + m_tabTitle.charAt( pos ) + "</span>" + m_tabTitle.substring( pos + 1 );
+                       + m_tabTitle.charAt( pos ) + "</span>" + m_tabTitle.substring( pos+1 );
         }
         return true;
     }
     /**
      * {@inheritDoc}
      */
     @Override
-    public int doWikiStartTag() throws JspTagException {
-        final TabbedSectionTag parent = ( TabbedSectionTag ) findAncestorWithClass( this, TabbedSectionTag.class );
-        if( getId() == null ) {
-            throw new JspTagException( "Tab Tag without \"id\" attribute" );
+    public int doWikiStartTag() throws JspTagException
+    {
+        final TabbedSectionTag parent=(TabbedSectionTag)findAncestorWithClass( this, TabbedSectionTag.class );
+        if( getId() == null )
+        {
+            throw new JspTagException("Tab Tag without \"id\" attribute");
         }
-        if( m_tabTitle == null ) {
-            throw new JspTagException( "Tab Tag without \"tabTitle\" attribute" );
+        if( m_tabTitle == null )
+        {
+            throw new JspTagException("Tab Tag without \"tabTitle\" attribute");
         }
-        if( parent == null ) {
-            throw new JspTagException( "Tab Tag without parent \"TabbedSection\" Tag" );
+        if( parent == null )
+        {
+            throw new JspTagException("Tab Tag without parent \"TabbedSection\" Tag");
         }
-        if( !parent.isStateGenerateTabBody() ) {
-            return SKIP_BODY;
-        }
-        final StringBuilder sb = new StringBuilder( 32 );
+        if( !parent.isStateGenerateTabBody() ) return SKIP_BODY;
+        final StringBuilder sb = new StringBuilder(32);
         sb.append( "<div id=\"" ).append( getId() ).append( "\"" );
-        if( !parent.validateDefaultTab( getId() ) ) {
+        if( !parent.validateDefaultTab( getId()) )
+        {
             sb.append( " class=\"hidetab\"" );
         }
         sb.append( " >\n" );
-        try {
+        try
+        {
             pageContext.getOut().write( sb.toString() );
-        } catch( final IOException e ) {
+        }
+        catch( final java.io.IOException e )
+        {
             throw new JspTagException( "IO Error: " + e.getMessage() );
         }
         return EVAL_BODY_INCLUDE;
     }
     /**
      * {@inheritDoc}
      */
     @Override
-    public int doEndTag() throws JspTagException {
-        final TabbedSectionTag parent = ( TabbedSectionTag ) findAncestorWithClass( this, TabbedSectionTag.class );
+    public int doEndTag() throws JspTagException
+    {
+        final TabbedSectionTag parent=(TabbedSectionTag)findAncestorWithClass( this, TabbedSectionTag.class );
         final StringBuilder sb = new StringBuilder();
-        if( parent.isStateFindDefaultTab() ) {
+        if( parent.isStateFindDefaultTab() )
+        {
             parent.validateDefaultTab( getId() );
-        } else if( parent.isStateGenerateTabBody() ) {
+        }
+        else if( parent.isStateGenerateTabBody() )
+        {
             sb.append( "</div>\n" );
-        } else if( parent.isStateGenerateTabMenu() ) {
+        }
+        else if( parent.isStateGenerateTabMenu() )
+        {
             sb.append( "<a" );
-            if( parent.validateDefaultTab( getId() ) ) {
+            if( parent.validateDefaultTab( getId() ) )
+            {
                 sb.append( " class=\"activetab\"" );
             }
             sb.append( " id=\"menu-" ).append( getId() ).append( "\"" );
-            if( m_url != null ) {
+            if( m_url != null )
+            {
                 sb.append( " href='" ).append( m_url ).append( "'" );
             }
-            if( handleAccesskey() ) {
+            if( handleAccesskey() )
+            {
                 sb.append( " accesskey=\"" ).append( m_accesskey ).append( "\"" );
             }
             sb.append( " >" );
             sb.append( m_tabTitle );
             sb.append( "</a>" );
         }
-        try {
+        try
+        {
             pageContext.getOut().write( sb.toString() );
-        } catch( final IOException e ) {
+        }
+        catch( final IOException e )
+        {
             throw new JspTagException( "IO Error: " + e.getMessage() );
         }
         return EVAL_PAGE;
     }
 }

--- a/jspwiki-main/src/main/java/org/apache/wiki/tags/UserProfileTag.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/tags/UserProfileTag.java
@@ -24,24 +24,22 @@
 import org.apache.wiki.auth.UserManager;
 import org.apache.wiki.auth.authorize.Role;
 import org.apache.wiki.auth.user.UserProfile;
 import org.apache.wiki.i18n.InternationalizationManager;
 import org.apache.wiki.preferences.Preferences;
 import org.apache.wiki.util.TextUtil;
 import javax.servlet.http.HttpServletRequest;
 import java.io.IOException;
 import java.security.Principal;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.List;
 import java.util.ResourceBundle;
-import java.util.stream.Collectors;
 /**
  * <p>
  * Returns user profile attributes, or empty strings if the user has not been
  * validated. This tag has a single attribute, "property."
  * The <code>property</code> attribute may contain one of the following
  * case-insensitive values:
  * </p>
  * <ul>
  * <li><code>created</code> - creation date</li>
  * <li><code>email</code> - user's e-mail address</li>
@@ -145,23 +143,27 @@
     }
     /**
      * Returns a sorted list of the {@link org.apache.wiki.auth.authorize.Group} objects a user possesses
      * in his or her Session. The result is computed by consulting
      * {@link org.apache.wiki.api.core.Session#getRoles()}
      * and extracting those that are of type Group.
      * @return the list of groups, sorted by name
      */
     public static String printGroups( final Context context ) {
         final Principal[] roles = context.getWikiSession().getRoles();
-        final List< String > tempRoles;
+        final List< String > tempRoles = new ArrayList<>();
         final ResourceBundle rb = Preferences.getBundle( context, InternationalizationManager.CORE_BUNDLE );
-        tempRoles = Arrays.stream(roles).filter(role -> role instanceof GroupPrincipal).map(Principal::getName).collect(Collectors.toList());
+        for( final Principal role : roles ) {
+            if( role instanceof GroupPrincipal ) {
+                tempRoles.add( role.getName() );
+            }
+        }
         if( tempRoles.size() == 0 ) {
             return rb.getString( "userprofile.nogroups" );
         }
         final StringBuilder sb = new StringBuilder();
         for( int i = 0; i < tempRoles.size(); i++ ) {
             final String name = tempRoles.get( i );
             sb.append( name );
             if( i < ( tempRoles.size() - 1 ) ) {
                 sb.append( ',' );
                 sb.append( ' ' );
@@ -171,23 +173,27 @@
     }
     /**
      * Returns a sorted list of the {@link org.apache.wiki.auth.authorize.Role} objects a user possesses
      * in his or her Session. The result is computed by consulting
      * {@link org.apache.wiki.api.core.Session#getRoles()}
      * and extracting those that are of type Role.
      * @return the list of roles, sorted by name
      */
     public static String printRoles( final Context context ) {
         final Principal[] roles = context.getWikiSession().getRoles();
-        final List< String > tempRoles;
+        final List< String > tempRoles = new ArrayList<>();
         final ResourceBundle rb = Preferences.getBundle( context, InternationalizationManager.CORE_BUNDLE );
-        tempRoles = Arrays.stream(roles).filter(role -> role instanceof Role).map(Principal::getName).collect(Collectors.toList());
+        for( final Principal role : roles ) {
+            if( role instanceof Role ) {
+                tempRoles.add( role.getName() );
+            }
+        }
         if( tempRoles.size() == 0 ) {
             return rb.getString( "userprofile.noroles" );
         }
         final StringBuilder sb = new StringBuilder();
         for( int i = 0; i < tempRoles.size(); i++ ) {
             final String name = tempRoles.get( i );
             sb.append( name );
             if( i < ( tempRoles.size() - 1 ) ) {
                 sb.append( ',' );
                 sb.append( ' ' );

--- a/jspwiki-main/src/main/java/org/apache/wiki/tasks/auth/SaveUserProfileTask.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/tasks/auth/SaveUserProfileTask.java
@@ -1,26 +1,10 @@
-/*
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-       http://www.apache.org/licenses/LICENSE-2.0
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
- */
 package org.apache.wiki.tasks.auth;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.apache.wiki.api.core.Context;
 import org.apache.wiki.api.core.ContextEnum;
 import org.apache.wiki.api.exceptions.WikiException;
 import org.apache.wiki.auth.UserManager;
 import org.apache.wiki.auth.user.UserProfile;
 import org.apache.wiki.i18n.InternationalizationManager;
 import org.apache.wiki.tasks.TasksManager;

--- a/jspwiki-main/src/main/java/org/apache/wiki/ui/Installer.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/ui/Installer.java
@@ -34,21 +34,20 @@
 import javax.servlet.ServletConfig;
 import javax.servlet.http.HttpServletRequest;
 import java.io.File;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.nio.file.Files;
 import java.text.MessageFormat;
 import java.util.Properties;
 import java.util.ResourceBundle;
 import java.util.Set;
-import java.util.stream.Collectors;
 /**
  * Manages JSPWiki installation on behalf of <code>admin/Install.jsp</code>. The contents of this class were previously part of
  * <code>Install.jsp</code>.
  *
  * @since 2.4.20
  */
 public class Installer {
     public static final String ADMIN_ID = "admin";
     public static final String ADMIN_NAME = "Administrator";
     public static final String INSTALL_INFO = "Installer.Info";
@@ -124,24 +123,26 @@
             group = groupMgr.parseGroup( ADMIN_GROUP, ADMIN_NAME, true );
         }
         groupMgr.setGroup( m_session, group );
         return password;
     }
     /**
      * Returns the properties as a "key=value" string separated by newlines
      * @return the string
      */
     public String getPropertiesList() {
-        final String result;
+        final StringBuilder result = new StringBuilder();
         final Set< String > keys = m_props.stringPropertyNames();
-        result = keys.stream().map(key -> key + " = " + m_props.getProperty(key) + "\n").collect(Collectors.joining());
-        return result;
+        for( final String key : keys ) {
+            result.append(key ).append( " = " ).append( m_props.getProperty( key ) ).append( "\n" );
+        }
+        return result.toString();
     }
     public String getPropertiesPath() {
         return m_propertyFile.getAbsolutePath();
     }
     /**
      * Returns a property from the Engine's properties.
      * @param key the property key
      * @return the property value
      */
     public String getProperty( final String key ) {

--- a/jspwiki-main/src/main/java/org/apache/wiki/ui/WikiRequestWrapper.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/ui/WikiRequestWrapper.java
@@ -15,21 +15,20 @@
     under the License.    
  */
 package org.apache.wiki.ui;
 import org.apache.wiki.api.core.Engine;
 import org.apache.wiki.api.core.Session;
 import org.apache.wiki.auth.SessionMonitor;
 import org.apache.wiki.auth.authorize.Role;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletRequestWrapper;
 import java.security.Principal;
-import java.util.Arrays;
 /**
  * Servlet request wrapper that encapsulates an incoming HTTP request and overrides its security methods so that the request returns
  * JSPWiki-specific values.
  * 
  * @since 2.8
  */
 public class WikiRequestWrapper extends HttpServletRequestWrapper {
     private final Session m_session;
     /**
      * Constructs a new wrapped request.
@@ -79,13 +78,21 @@
      * this method iterates through the built-in Role objects (<em>e.g.</em>, ANONYMOUS, ASSERTED, AUTHENTICATED) returned by
      * {@link Session#getRoles()} and checks to see if any of these principals' names match the supplied role.
      */
     @Override
     public boolean isUserInRole( final String role ) {
         final boolean hasContainerRole = super.isUserInRole(role);
         if( hasContainerRole ) {
             return true;
         }
         final Principal[] principals = m_session.getRoles();
-        return Arrays.stream(principals).filter(value -> value instanceof Role).map(value -> (Role) value).anyMatch(principal -> Role.isBuiltInRole(principal) && principal.getName().equals(role));
+        for( final Principal value : principals ) {
+            if( value instanceof Role ) {
+                final Role principal = ( Role )value;
+                if( Role.isBuiltInRole( principal ) && principal.getName().equals( role ) ) {
+                    return true;
+                }
+            }
+        }
+        return false;
     }
 }

--- a/jspwiki-main/src/main/java/org/apache/wiki/ui/admin/DefaultAdminBeanManager.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/ui/admin/DefaultAdminBeanManager.java
@@ -154,21 +154,26 @@
         if( m_allBeans == null ) {
         	reload();
         }
         return m_allBeans;
     }
     /* (non-Javadoc)
 	 * @see org.apache.wiki.ui.admin.AdminBeanManager#findBean(java.lang.String)
 	 */
     @Override
 	public AdminBean findBean( final String id ) {
-        return m_allBeans.stream().filter(ab -> ab.getId().equals(id)).findFirst().orElse(null);
+        for( final AdminBean ab : m_allBeans ) {
+            if( ab.getId().equals( id ) ) {
+                return ab;
+            }
+        }
+        return null;
     }
     /**
      *  Provides a JDK 1.5-compliant version of the MBeanServerFactory. This will simply bind to the
      *  platform MBeanServer.
      */
     private static final class MBeanServerFactory15 {
         private MBeanServerFactory15()
         {}
         public static MBeanServer getServer() {
             return ManagementFactory.getPlatformMBeanServer();

--- a/jspwiki-main/src/main/java/org/apache/wiki/ui/progress/DefaultProgressManager.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/ui/progress/DefaultProgressManager.java
@@ -110,21 +110,21 @@
         @Override
         public String getServletMapping() {
         	return JSON_PROGRESSTRACKER;
         }
         @Override
         public void service( final HttpServletRequest req,
                              final HttpServletResponse resp,
                              final String actionName,
                              final List< String > params ) throws IOException {
         	LOG.debug( "ProgressManager.doGet() START" );
-        	if( params.isEmpty() ) {
+        	if( params.size() < 1 ) {
         		return;
         	}
         	final String progressId = params.get(0);
         	LOG.debug( "progressId=" + progressId );
         	String progressString = "";
         	try {
         		progressString = Integer.toString( getProgress( progressId ) );
         	} catch( final IllegalArgumentException e ) { // ignore
         		LOG.debug( "progressId " + progressId + " is no longer valid" );
         	}

--- a/jspwiki-main/src/main/java/org/apache/wiki/variables/DefaultVariableManager.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/variables/DefaultVariableManager.java
@@ -31,21 +31,20 @@
 import org.apache.wiki.pages.PageManager;
 import org.apache.wiki.preferences.Preferences;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpSession;
 import java.lang.reflect.Method;
 import java.security.Principal;
 import java.util.Date;
 import java.util.List;
 import java.util.Properties;
 import java.util.ResourceBundle;
-import java.util.stream.Collectors;
 /**
  *  Manages variables.  Variables are case-insensitive.  A list of all available variables is on a Wiki page called "WikiVariables".
  *
  *  @since 1.9.20.
  */
 public class DefaultVariableManager implements VariableManager {
     private static final Logger LOG = LogManager.getLogger( DefaultVariableManager.class );
     /**
      *  Contains a list of those properties that shall never be shown. Put names here in lower case.
      */
@@ -240,24 +239,40 @@
         }
         public String getAttachmentprovider() {
             final WikiProvider p = m_context.getEngine().getManager( AttachmentManager.class ).getCurrentProvider();
             return (p != null) ? p.getClass().getName() : "-";
         }
         public String getAttachmentproviderdescription() {
             final WikiProvider p = m_context.getEngine().getManager( AttachmentManager.class ).getCurrentProvider();
             return (p != null) ? p.getProviderInfo() : "-";
         }
         public String getInterwikilinks() {
-            return m_context.getEngine().getAllInterWikiLinks().stream().map(link -> link + " --> " + m_context.getEngine().getInterWikiURL(link)).collect(Collectors.joining(", "));
+            final StringBuilder res = new StringBuilder();
+            for( final String link : m_context.getEngine().getAllInterWikiLinks() ) {
+                if( res.length() > 0 ) {
+                    res.append( ", " );
+                }
+                res.append( link );
+                res.append( " --> " );
+                res.append( m_context.getEngine().getInterWikiURL( link ) );
+            }
+            return res.toString();
         }
         public String getInlinedimages() {
-            return m_context.getEngine().getAllInlinedImagePatterns().stream().collect(Collectors.joining(", "));
+            final StringBuilder res = new StringBuilder();
+            for( final String ptrn : m_context.getEngine().getAllInlinedImagePatterns() ) {
+                if( res.length() > 0 ) {
+                    res.append( ", " );
+                }
+                res.append( ptrn );
+            }
+            return res.toString();
         }
         public String getPluginpath() {
             final String s = m_context.getEngine().getPluginSearchPath();
             return ( s == null ) ? "-" : s;
         }
         public String getBaseurl()
         {
             return m_context.getEngine().getBaseURL();
         }
         public String getUptime() {

--- a/jspwiki-main/src/main/java/org/apache/wiki/workflow/DefaultWorkflowManager.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/workflow/DefaultWorkflowManager.java
@@ -34,21 +34,21 @@
 import java.security.Principal;
 import java.util.*;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CopyOnWriteArrayList;
 /**
  * <p>
  * Monitor class that tracks running Workflows. The WorkflowManager also keeps track of the names of
  * users or groups expected to approve particular Workflows.
  * </p>
  */
-public class DefaultWorkflowManager implements WorkflowManager, Serializable {
+public class DefaultWorkflowManager implements WorkflowManager {
     private static final Logger LOG = LogManager.getLogger( DefaultWorkflowManager.class );
     static final String SERIALIZATION_FILE = "wkflmgr.ser";
     /** We use this also a generic serialization id */
     private static final long serialVersionUID = 6L;
     DecisionQueue m_queue;
     Set< Workflow > m_workflows;
     final Map< String, Principal > m_approvers;
     Queue< Workflow > m_completed;
     private Engine m_engine;
     private int retainCompleted;
@@ -200,22 +200,25 @@
     /**
      * {@inheritDoc}
      */
     @Override
     public List< Workflow > getOwnerWorkflows( final Session session ) {
         final List< Workflow > workflows = new ArrayList<>();
         if ( session.isAuthenticated() ) {
             final Principal[] sessionPrincipals = session.getPrincipals();
             for( final Workflow w : m_workflows ) {
                 final Principal owner = w.getOwner();
-                if (Arrays.stream(sessionPrincipals).anyMatch(sessionPrincipal -> sessionPrincipal.equals(owner))) {
-                    workflows.add(w);
+                for ( final Principal sessionPrincipal : sessionPrincipals ) {
+                    if ( sessionPrincipal.equals( owner ) ) {
+                        workflows.add( w );
+                        break;
+                    }
                 }
             }
         }
         return workflows;
     }
     /**
      * Listens for {@link WorkflowEvent} objects emitted by Workflows. In particular, this method listens for {@link WorkflowEvent#CREATED},
      * {@link WorkflowEvent#ABORTED}, {@link WorkflowEvent#COMPLETED} and {@link WorkflowEvent#DQ_REMOVAL} events. If a workflow is created,
      * it is automatically added to the cache. If one is aborted or completed, it is automatically removed. If a removal from decision queue
      * is issued, the current step from workflow, which is assumed to be a {@link Decision}, is removed from the {@link DecisionQueue}.

--- a/jspwiki-main/src/main/java/org/apache/wiki/xmlrpc/RPCHandler.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/xmlrpc/RPCHandler.java
@@ -27,21 +27,20 @@
 import org.apache.wiki.render.RenderingManager;
 import org.apache.wiki.util.TextUtil;
 import org.apache.xmlrpc.XmlRpcException;
 import java.nio.charset.StandardCharsets;
 import java.util.Calendar;
 import java.util.Collection;
 import java.util.Date;
 import java.util.Hashtable;
 import java.util.Set;
 import java.util.Vector;
-import java.util.stream.Collectors;
 /**
  *  Provides handlers for all RPC routines.
  *
  *  @since 1.6.6
  */
 public class RPCHandler extends AbstractRPCHandler {
     /**
      *  Converts Java string into RPC string.
      */
     private String toRPCString( final String src )
@@ -62,21 +61,27 @@
     {
         return src.getBytes( StandardCharsets.UTF_8 );
     }
     public String getApplicationName() {
         checkPermission( PagePermission.VIEW );
         return toRPCString(m_engine.getApplicationName());
     }
     public Vector< String > getAllPages() {
         checkPermission( PagePermission.VIEW );
         final Collection< Page > pages = m_engine.getManager( PageManager.class ).getRecentChanges();
-        return pages.stream().filter(p -> !(p instanceof Attachment)).map(p -> toRPCString(p.getName())).collect(Collectors.toCollection(Vector::new));
+        final Vector< String > result = new Vector<>();
+        for( final Page p : pages ) {
+            if( !( p instanceof Attachment ) ) {
+                result.add( toRPCString( p.getName() ) );
+            }
+        }
+        return result;
     }
     /**
      *  Encodes a single wiki page info into a Hashtable.
      */
     @Override
     protected Hashtable<String,Object> encodeWikiPage( final Page page ) {
         final Hashtable<String, Object> ht = new Hashtable<>();
         ht.put( "name", toRPCString(page.getName()) );
         final Date d = page.getLastModified();
         final Calendar cal = Calendar.getInstance();

--- a/jspwiki-main/src/main/java/org/apache/wiki/xmlrpc/RPCHandlerUTF8.java
+++ b/jspwiki-main/src/main/java/org/apache/wiki/xmlrpc/RPCHandlerUTF8.java
@@ -24,36 +24,41 @@
 import org.apache.wiki.auth.permissions.PagePermission;
 import org.apache.wiki.auth.permissions.PermissionFactory;
 import org.apache.wiki.pages.PageManager;
 import org.apache.wiki.render.RenderingManager;
 import org.apache.xmlrpc.XmlRpcException;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.Hashtable;
 import java.util.Set;
 import java.util.Vector;
-import java.util.stream.Collectors;
 /**
  *  Provides handlers for all RPC routines.  These routines are used by
  *  the UTF-8 interface.
  *
  *  @since 1.6.13
  */
 public class RPCHandlerUTF8 extends AbstractRPCHandler {
     public String getApplicationName() {
         checkPermission( PagePermission.VIEW );
         return m_engine.getApplicationName();
     }
     public Vector< String > getAllPages() {
         checkPermission( PagePermission.VIEW );
         final Set< Page > pages = m_engine.getManager( PageManager.class ).getRecentChanges();
-        return pages.stream().filter(p -> !(p instanceof Attachment)).map(Page::getName).collect(Collectors.toCollection(Vector::new));
+        final Vector< String > result = new Vector<>();
+        for( final Page p : pages ) {
+            if( !( p instanceof Attachment ) ) {
+                result.add( p.getName() );
+            }
+        }
+        return result;
     }
     /**
      *  Encodes a single wiki page info into a Hashtable.
      */
     @Override
     protected Hashtable<String, Object> encodeWikiPage( final Page page ) {
         final Hashtable<String, Object> ht = new Hashtable<>();
         ht.put( "name", page.getName() );
         final Date d = page.getLastModified();
         final Calendar cal = Calendar.getInstance();

--- a/jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/LocalFootnoteLinkNodePostProcessorState.java
+++ b/jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/LocalFootnoteLinkNodePostProcessorState.java
@@ -1,26 +1,10 @@
-/*
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-       http://www.apache.org/licenses/LICENSE-2.0
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
- */
 package org.apache.wiki.markdown.extensions.jspwikilinks.postprocessor;
 import com.vladsch.flexmark.util.ast.Node;
 import com.vladsch.flexmark.util.ast.NodeTracker;
 import com.vladsch.flexmark.util.sequence.CharSubSequence;
 import org.apache.wiki.api.core.Context;
 import org.apache.wiki.api.core.ContextEnum;
 import org.apache.wiki.markdown.nodes.JSPWikiLink;
 /**
  * {@link NodePostProcessorState} which further post processes local footnote links.
  */

--- a/jspwiki-util/src/main/java/org/apache/wiki/util/CommentedProperties.java
+++ b/jspwiki-util/src/main/java/org/apache/wiki/util/CommentedProperties.java
@@ -79,21 +79,21 @@
     public synchronized Object setProperty(final String key, final String value )
     {
         return put(key, value);
     }
     /**
      * {@inheritDoc}
      */
     @Override
     public synchronized void store(final OutputStream out, final String comments ) throws IOException
     {
-        final byte[] bytes = m_propertyString.getBytes( StandardCharsets.ISO_8859_1 );
+        final byte[] bytes = m_propertyString.getBytes(StandardCharsets.ISO_8859_1.name());
         FileUtil.copyContents( new ByteArrayInputStream( bytes ), out );
         out.flush();
     }
     /**
      * {@inheritDoc}
      */
     @Override
     public synchronized Object put(final Object arg0, final Object arg1 )
     {
         writeProperty( arg0, arg1 );

--- a/jspwiki-util/src/main/java/org/apache/wiki/util/PropertyReader.java
+++ b/jspwiki-util/src/main/java/org/apache/wiki/util/PropertyReader.java
@@ -14,21 +14,20 @@
     specific language governing permissions and limitations
     under the License.    
  */
 package org.apache.wiki.util;
 import org.apache.commons.lang3.StringUtils;
 import org.apache.commons.lang3.Validate;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import javax.servlet.ServletContext;
 import java.io.*;
-import java.nio.file.Paths;
 import java.util.*;
 import java.util.stream.Collectors;
 import java.nio.file.Files;
 /**
  * Property Reader for the WikiEngine. Reads the properties for the WikiEngine
  * and implements the feature of cascading properties and variable substitution,
  * which come in handy in a multi wiki installation environment: It reduces the
  * need for (shell) scripting in order to generate different jspwiki.properties
  * to a minimum.
  *
@@ -209,21 +208,21 @@
             LOG.debug( " No cascading properties defined for this context" );
             return;
         }
         int depth = 0;
         while( true ) {
             depth++;
             final String propertyFile = getInitParameter( context, PARAM_CUSTOMCONFIG_CASCADEPREFIX + depth );
             if( propertyFile == null ) {
                 break;
             }
-            try( final InputStream propertyStream = Files.newInputStream(Paths.get(( propertyFile ) ))) {
+            try( final InputStream propertyStream = new FileInputStream( propertyFile ) ) {
                 LOG.info( " Reading additional properties from " + propertyFile + " and merge to cascade." );
                 final Properties additionalProps = new Properties();
                 additionalProps.load( propertyStream );
                 defaultProperties.putAll( additionalProps );
             } catch( final Exception e ) {
                 LOG.error( "JSPWiki: Unable to load and setup properties from " + propertyFile + "." + e.getMessage() );
             }
         }
     }
     /**

--- a/jspwiki-util/src/main/java/org/apache/wiki/util/TextUtil.java
+++ b/jspwiki-util/src/main/java/org/apache/wiki/util/TextUtil.java
@@ -19,22 +19,20 @@
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import java.io.File;
 import java.io.IOException;
 import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
 import java.security.SecureRandom;
 import java.util.NoSuchElementException;
 import java.util.Properties;
 import java.util.Random;
-import java.util.stream.Collectors;
-import java.util.stream.IntStream;
 /**
  *  Contains a number of static utility methods.
  */
 public final class TextUtil {
     private static final Logger LOG = LogManager.getLogger( TextUtil.class );
     static final String HEX_DIGITS = "0123456789ABCDEF";
     /** Pick from some letters that won't be easily mistaken for each other to compose passwords. So, for example, omit o, O and 0, or 1, l and L.*/
     static final String PWD_BASE = "abcdefghjkmnpqrstuvwxyzABCDEFGHJKMNPQRSTUVWXYZ23456789+@";
     /** Length of password. {@link #generateRandomPassword() */
     public static final int PASSWORD_LENGTH = 8;
@@ -664,21 +662,25 @@
     }
     /**
      *  A simple routine which just repeates the arguments.  This is useful for creating something like a line or something.
      *
      *  @param what String to repeat
      *  @param times How many times to repeat the string.
      *  @return Guess what?
      *  @since 2.1.98.
      */
     public static String repeatString( final String what, final int times ) {
-        return IntStream.range(0, times).mapToObj(i -> what).collect(Collectors.joining());
+        final StringBuilder sb = new StringBuilder();
+        for( int i = 0; i < times; i++ ) {
+            sb.append( what );
+        }
+        return sb.toString();
     }
     /**
      *  Converts a string from the Unicode representation into something that can be embedded in a java
      *  properties file.  All references outside the ASCII range are replaced with \\uXXXX.
      *
      *  @param s The string to convert
      *  @return the ASCII string
      */
     public static String native2Ascii( final String s ) {
         final StringBuilder sb = new StringBuilder();
@@ -742,13 +744,18 @@
         }
         return true;
     }
     /**
      * Generate a random String suitable for use as a temporary password.
      *
      * @return String suitable for use as a temporary password
      * @since 2.4
      */
     public static String generateRandomPassword() {
-        return IntStream.range(0, PASSWORD_LENGTH).map(i -> (int) (RANDOM.nextDouble() * PWD_BASE.length())).mapToObj(index -> String.valueOf(PWD_BASE.charAt(index))).collect(Collectors.joining());
+        final StringBuilder pw = new StringBuilder();
+        for( int i = 0; i < PASSWORD_LENGTH; i++ ) {
+            final int index = ( int )( RANDOM.nextDouble() * PWD_BASE.length() );
+            pw.append(PWD_BASE.charAt( index ));
+        }
+        return pw.toString();
     }
 }

--- a/jspwiki-util/src/main/java/org/apache/wiki/util/TimedCounterList.java
+++ b/jspwiki-util/src/main/java/org/apache/wiki/util/TimedCounterList.java
@@ -124,25 +124,31 @@
     }
     /**
      *  Returns the count how many times this object is available in
      *  this list, using equals().
      *  
      *  @param obj The object to count.
      *  @return The count of the objects.
      */
     public int count(final T obj )
     {
-        int c;
-        m_lock.readLock().lock();
-        try
-        {
-            c = (int) m_list.stream().filter(i -> i.m_obj.equals(obj)).count();
+        int c = 0;
+        m_lock.readLock().lock();
+        try
+        {
+            for( final CounterItem< T > i : m_list )
+            {
+                if( i.m_obj.equals( obj ) )
+                {
+                    c++;
+                }
+            }
         }
         finally
         {
             m_lock.readLock().unlock();
         }
         return c;
     }
     /**
      *  Performs a cleanup of all items older than maxage.
      *  

--- a/jspwiki-util/src/main/java/org/apache/wiki/util/XmlUtil.java
+++ b/jspwiki-util/src/main/java/org/apache/wiki/util/XmlUtil.java
@@ -28,21 +28,20 @@
 import org.jdom2.xpath.XPathFactory;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Enumeration;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
-import java.util.stream.Collectors;
 /**
  *  Utility class to parse XML files.
  *  <p>
  *  This uses JDOM2 as its backing implementation.
  *  </p>
  *  
  * @since 2.10
  */
 public final class XmlUtil  {
 	private static final String ALL_TEXT_NODES = "//text()";
@@ -106,24 +105,28 @@
 	/**
 	 * Renders all the text() nodes from the DOM tree. This is very useful for cleaning away all the XHTML.
 	 *
 	 * @param doc Dom tree
 	 * @return String containing only the text from the provided Dom tree.
 	 */
 	public static String extractTextFromDocument( final Document doc ) {
 		if( doc == null ) {
 			return "";
 		}
-		final String sb;
+		final StringBuilder sb = new StringBuilder();
 		final List< ? > nodes = XPathFactory.instance().compile( ALL_TEXT_NODES ).evaluate( doc );
-        sb = nodes.stream().filter(el -> el instanceof Text).map(el -> ((Text) el).getValue()).collect(Collectors.joining());
-		return sb;
+		for( final Object el : nodes ) {
+			if( el instanceof Text ) {
+				sb.append( ( ( Text )el ).getValue() );
+			}
+		}
+		return sb.toString();
 	}
 	public static Element getXPathElement( final Element base, final String expression ) {
 		final List< ? > nodes = XPathFactory.instance().compile( expression ).evaluate( base );
 		if( nodes == null || nodes.size() == 0 ) {
 			return null;
 		} else {
 			return ( Element )nodes.get( 0 );
 		}
 	}
 }

--- a/jspwiki-war/src/main/scripts/util/extend-array.js
+++ b//dev/null
@@ -1,30 +0,0 @@
-/*
-    JSPWiki - a JSP-based WikiWiki clone.
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); fyou may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-       http://www.apache.org/licenses/LICENSE-2.0
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-*/
-/*eslint-env browser */
-/*global $ */
-$.last = function(arr){
-    return (arr.length) ? arr[arr.length - 1] : null;
-}
-/*
-$.Array.last = function(arr) {
-	return(arr[arr.length -1]);
-}
-Array.prototype.last = function{
-    return(this[this.length-1]);
-}
-*/

--- a/jspwiki-war/src/main/scripts/util/extend-event.js
+++ b//dev/null
@@ -1,57 +0,0 @@
-/*
-    JSPWiki - a JSP-based WikiWiki clone.
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); fyou may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-       http://www.apache.org/licenses/LICENSE-2.0
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-*/
-/*eslint-env browser */
-/*global $, $$, getElement */
-/**
- *
- */
-$.bind = function(element, eventNames, callback) {
-    element.addEvent(eventNames, callback);
-};
-/**
- *
- */
-$.unbind = function(element, eventNames, callback) {
-    element.removeEvent(eventNames, callback);
-};
-/**
- * Similar to $.bind(), but callback will be called only once
- */
-$.once = function(element, eventNames, callback) {
-    function once() {
-        $.unbind(element, eventNames, once);
-        return callback.apply(element, arguments);
-    }
-    $.bind(element, eventNames, once);
-};
-/**
- * Event delegation
- * @param {HTMLElement} element
- * @param {string} eventNames
- * @param {string} targetSelector - the selector to match the target of the event
- * @param {function} callback
- * @example:
- *   $.delegate($("ul"), "click", "li", handleListItem);
- */
-$.delegate = function(element, eventNames, targetSelector, callback) {
-    $.bind(element, eventNames, function(event) {
-        if (event.target.closest(targetSelector)) {
-            callback.call(event.target, event);
-        }
-    });
-};

--- a/jspwiki-war/src/main/scripts/util/extend-form.js
+++ b//dev/null
@@ -1,74 +0,0 @@
-/*
-    JSPWiki - a JSP-based WikiWiki clone.
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); fyou may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-       http://www.apache.org/licenses/LICENSE-2.0
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-*/
-/*eslint-env browser */
-/*global $, $$, getElement */
-/* FORM element support routines */
-/**
- * Function: observe
- *     Observe a dom element for changes, and trigger a callback function.
- *
- * @param {InputElement} element
- * @param {Function} callback - this function is called when the dom element changed
- * @param {Number} [delay=300] - timeout in ms, default = 300ms
- * @param {String} [event="keyup"] - event-type to observe
- *
- * @example
- *     $.observe(formInput, function(){
- *         alert("my value changed to "+this.get("value") );
- *     });
- *
- */
-$.observe = function(element, callback, delay, event) {
-    var refValue = element.value,
-        timer = null;
-    function hasChanged() {
-        var value = element.value;
-        if (value != refValue) {
-            refValue = value;
-            clearTimeout(timer);
-            timer = setTimeout(callback, delay);
-        }
-    }
-    if (isNaN(delay)) {
-        event = delay;
-        delay = 300;
-    }
-    event = event || 'keyup';
-    element.set({ autocomplete: 'off' }).addEvent(event, hasChanged);
-    return element;
-};
-/**
- * FORM element
- *   Function: getDefaultValue
- *       Returns the default value of a form element.
- *       Inspired by get("value") of mootools, v1.1
- *
- *   Note:
- *       Checkboxes will return true/false depending on the default checked status.
- *       ( input.checked to read actual value )
- *       The value returned in a POST will be input.get("value")
- *       and is depending on the value set by the "value" attribute (optional)
- *
- *   Returns:
- *       (value) - the default value of the element; or false if not applicable.
- *
- *   Examples:
- *   > $("thisElement").getDefaultValue();
- *
- */
-$.getDefaultValue = function(element) {};

--- a/jspwiki-war/src/main/scripts/util/extend-number.js
+++ b//dev/null
@@ -1,29 +0,0 @@
-/*
-    JSPWiki - a JSP-based WikiWiki clone.
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); fyou may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-       http://www.apache.org/licenses/LICENSE-2.0
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-*/
-/*eslint-env browser */
-/*global $ */
-/**
- * Returns a given number between two bounds.
- * @param {number} value
- * @param {number} min
- * @param {number} max
- * @returns {number}
- */
-$.limit = function(value, min, max) {
-    return Math.min(max, Math.max(min, value));
-};

--- a/jspwiki-war/src/main/scripts/util/extend.js
+++ b//dev/null
@@ -1,72 +0,0 @@
-/*
-    JSPWiki - a JSP-based WikiWiki clone.
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); fyou may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-       http://www.apache.org/licenses/LICENSE-2.0
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-*/
-/*eslint-env browser */
-/*global $ */
-/*
-Basic js helper routines, inspired on Bliss.js <url>
-    $.extend
-    $.overload
-*/
-/**
- * Extend
- *    Returns extended objects
- * @param {Object} target
- * @param {Object} src1
- * @returns {Object}
- */
-$.extend = function(target, src1) {
-};
-/*
-Overload
-*/
-$.overload = function() {};
-/**
- * Returns the [[Class]] of an object in lowercase (eg. array, date, regexp, string etc)
- * Inspired by: https://blissfuljs.com/docs.html#fn-type
- * @param {any} obj
- * @returns {string} type of the object in lowercase
- */
-$.type = function(obj) {
-    var ret;
-    if (obj === null || obj === undefined) {
-        return '' + obj;
-    }
-    if (
-        (ret = (
-            Object.prototype.toString
-                .call(obj)
-                .match(/^\[object\s+(.*?)\]$/)[1] || ''
-        ).toLowerCase()) == 'number' &&
-        isNaN(obj)
-    ) {
-        return 'nan';
-    }
-    return ret;
-};
-/**
- * Simple async wait to execute callback until after the DOM is ready
- * @param {function} callback
- */
-$.ready = function(callback) {
-    var context = document;
-    if (context.readyState !== 'loading') {
-        callback();
-    } else {
-        $.once(context, 'DOMContentLoaded', callback);
-    }
-};

--- a/jspwiki-wysiwyg/src/main/java/org/apache/wiki/htmltowiki/XHtmlElementToWikiTranslator.java
+++ b/jspwiki-wysiwyg/src/main/java/org/apache/wiki/htmltowiki/XHtmlElementToWikiTranslator.java
@@ -27,21 +27,20 @@
 import org.jdom2.JDOMException;
 import org.jdom2.Verifier;
 import org.jdom2.Text;
 import org.jdom2.xpath.XPathFactory;
 import java.io.PrintWriter;
 import java.util.ArrayDeque;
 import java.util.Arrays;
 import java.util.Deque;
 import java.util.LinkedHashMap;
 import java.util.Map;
-import java.util.stream.Collectors;
 /**
  * Converting XHtml to Wiki Markup.  This is the class which orchestrates all the heavy loading.
  */
 public class XHtmlElementToWikiTranslator {
     private static final Logger LOG = LogManager.getLogger( XHtmlElementToWikiTranslator.class );
     private static final String DEFAULT_SYNTAX_DECORATOR = "org.apache.wiki.htmltowiki.syntax.jspwiki.JSPWikiSyntaxDecorator";
     private final Engine e;
     private final XHtmlToWikiConfig config;
     private final WhitespaceTrimWriter outTrimmer = new WhitespaceTrimWriter();
     private final SyntaxDecorator syntax;
@@ -192,21 +191,25 @@
         if( style.equals( "" ) ) {
             return null;
         }
         final Map< Object, Object > m = new LinkedHashMap<>();
         Arrays.stream( style.toLowerCase().split( ";" ) )
               .filter( StringUtils::isNotEmpty )
               .forEach( prop -> m.put( prop.split( ":" )[ 0 ].trim(), prop.split( ":" )[ 1 ].trim() ) );
         return m;
     }
     private String propsToStyleString( final Map< Object, Object >  styleProps ) {
-        return styleProps.entrySet().stream().map(entry -> " " + entry.getKey() + ": " + entry.getValue() + ";").collect(Collectors.joining());
+        final StringBuilder style = new StringBuilder();
+        for( final Map.Entry< Object, Object > entry : styleProps.entrySet() ) {
+            style.append( " " ).append( entry.getKey() ).append( ": " ).append( entry.getValue() ).append( ";" );
+        }
+        return style.toString();
     }
     public void translateChildren( final Element base ) throws JDOMException {
         for( final Content c : base.getContent() ) {
             if( c instanceof Element ) {
                 final Element e = ( Element )c;
                 final String n = e.getName().toLowerCase();
                 switch( n ) {
                     case "h1": syntax.h1( e ); break;
                     case "h2": syntax.h2( e ); break;
                     case "h3": syntax.h3( e ); break;
