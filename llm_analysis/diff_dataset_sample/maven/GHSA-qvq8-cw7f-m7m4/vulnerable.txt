# ====================================================================
# FILE: jspwiki-api/src/main/java/org/apache/wiki/api/Release.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 28-70 ---
    28|  *  changed much since.
    29|  *  </p>
    30|  *  @since  1.0
    31|  */
    32| public final class Release {
    33|     private static final String VERSION_SEPARATORS = ".-";
    34|     /**
    35|      *  This is the default application name.
    36|      */
    37|     public static final String     APPNAME       = "JSPWiki";
    38|     /**
    39|      *  This should be empty when doing a release - otherwise keep it as "-git-" so that whenever someone checks out the code, they know
    40|      *  it is a bleeding-edge version.  Other possible values are "-alpha-" and "-beta-" for alpha and beta versions, respectively.
    41|      *  <p>
    42|      *  If the POSTFIX is empty, it is not added to the version string.
    43|      */
    44|     private static final String    POSTFIX       = "";
    45|     /** The JSPWiki major version. */
    46|     public static final int        VERSION       = 2;
    47|     /** The JSPWiki revision. */
    48|     public static final int        REVISION      = 11;
    49|     /** The minor revision.  */
    50|     public static final int        MINORREVISION = 3;
    51|     /** The build number/identifier.  This is a String as opposed to an integer, just so that people can add other identifiers to it.
    52|      * The build number is incremented every time a committer checks in code, and reset when a release is made.
    53|      *  <p>
    54|      *  If you are a person who likes to build his own releases, we recommend that you add your initials to this
    55|      *  identifier (e.g. "13-jj", or "49-aj").
    56|      *  <p>
    57|      *  If the build identifier is empty, it is not added.
    58|      */
    59|     public static final String     BUILD         = "";
    60|     /**
    61|      *  This is the generic version string you should use when printing out the version.  It is of
    62|      *  the form "VERSION.REVISION.MINORREVISION[-POSTFIX][-BUILD]".
    63|      */
    64|     public static final String     VERSTR        = VERSION + "." +
    65|                                                    REVISION + "." +
    66|                                                    MINORREVISION +
    67|                                                    POSTFIX +
    68|                                                    BUILD;
    69|     /** Private constructor prevents instantiation. */
    70|     private Release() {


# ====================================================================
# FILE: jspwiki-api/src/main/java/org/apache/wiki/api/core/Engine.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 64-103 ---
    64|     /** Define the used encoding.  Currently supported are ISO-8859-1 and UTF-8 */
    65|     String PROP_ENCODING = "jspwiki.encoding";
    66|     /** Do not use encoding in WikiJSPFilter, default is false for most servers.
    67|      Double negative, cause for most servers you don't need the property */
    68|     String PROP_NO_FILTER_ENCODING = "jspwiki.nofilterencoding";
    69|     /** Property name for where the jspwiki work directory should be.
    70|      If not specified, reverts to ${java.tmpdir}. */
    71|     String PROP_WORKDIR = "jspwiki.workDir";
    72|     /** The name of the cookie that gets stored to the user browser. */
    73|     String PREFS_COOKIE_NAME = "JSPWikiUserProfile";
    74|     /** Property name for the "match english plurals" -hack. */
    75|     String PROP_MATCHPLURALS = "jspwiki.translatorReader.matchEnglishPlurals";
    76|     /** Property name for the template that is used. */
    77|     String PROP_TEMPLATEDIR = "jspwiki.templateDir";
    78|     /** Property name for the default front page. */
    79|     String PROP_FRONTPAGE = "jspwiki.frontPage";
    80|     /** Property name for setting the url generator instance */
    81|     String PROP_URLCONSTRUCTOR = "jspwiki.urlConstructor";
    82|     /** The name of the property containing the ACLManager implementing class. The value is {@value}. */
    83|     String PROP_ACL_MANAGER_IMPL = "jspwiki.aclManager";
    84|     /** If this property is set to false, we don't allow the creation of empty pages */
    85|     String PROP_ALLOW_CREATION_OF_EMPTY_PAGES = "jspwiki.allowCreationOfEmptyPages";
    86|     /**
    87|      * Adapt Engine to a concrete type.
    88|      *
    89|      * @param cls class denoting the type to adapt to.
    90|      * @param <E> type to adapt to.
    91|      * @return engine instance adapted to the requested type. Might throw an unchecked exception if the instance cannot be adapted to requested type!
    92|      */
    93|     @SuppressWarnings( "unchecked" )
    94|     default < E extends Engine > E adapt( final Class< E > cls ) {
    95|         return ( E )this;
    96|     }
    97|     /**
    98|      * Retrieves the object instantiated by the Engine matching the requested type.
    99|      *
   100|      * @param manager requested object instantiated by the Engine.
   101|      * @param <T> type of the requested object.
   102|      * @return requested object instantiated by the Engine, {@code null} if not available.
   103|      */


# ====================================================================
# FILE: jspwiki-http/src/main/java/org/apache/wiki/http/filter/CsrfProtectionFilter.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-20 ---
     1| package org.apache.wiki.http.filter;
     2| import org.apache.logging.log4j.LogManager;
     3| import org.apache.logging.log4j.Logger;
     4| import org.apache.wiki.api.core.Engine;
     5| import org.apache.wiki.api.core.Session;
     6| import org.apache.wiki.api.spi.Wiki;
     7| import javax.servlet.Filter;
     8| import javax.servlet.FilterChain;
     9| import javax.servlet.FilterConfig;
    10| import javax.servlet.ServletException;
    11| import javax.servlet.ServletRequest;
    12| import javax.servlet.ServletResponse;
    13| import javax.servlet.http.HttpServletRequest;
    14| import javax.servlet.http.HttpServletResponse;
    15| import java.io.IOException;
    16| /**
    17|  * CSRF protection Filter which uses the synchronizer token pattern â€“ an anti-CSRF token is created and stored in the
    18|  * user session and in a hidden field on subsequent form submits. At every submit the server checks the token from the
    19|  * session matches the one submitted from the form.
    20|  */


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/WikiEngine.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 383-423 ---
   383|                 }
   384|             }
   385|             if( !exists ) {
   386|                 LOG.warn( "{} template not found, updating WikiEngine's default template to {}", getTemplateDir(), DEFAULT_TEMPLATE_NAME );
   387|                 m_templateDir = DEFAULT_TEMPLATE_NAME;
   388|             }
   389|         }
   390|     }
   391|     /**
   392|      *  Initializes the reference manager. Scans all existing WikiPages for
   393|      *  internal links and adds them to the ReferenceManager object.
   394|      *
   395|      *  @throws WikiException If the reference manager initialization fails.
   396|      */
   397|     public void initReferenceManager() throws WikiException {
   398|         try {
   399|             if( getManager( ReferenceManager.class ) == null ) {
   400|                 final ArrayList< Page > pages = new ArrayList<>();
   401|                 pages.addAll( getManager( PageManager.class ).getAllPages() );
   402|                 pages.addAll( getManager( AttachmentManager.class ).getAllAttachments() );
   403|                 initComponent( ReferenceManager.class, this );
   404|                 getManager( ReferenceManager.class ).initialize( pages );
   405|             }
   406|         } catch( final ProviderException e ) {
   407|             LOG.fatal( "PageProvider is unable to list pages: ", e );
   408|         } catch( final Exception e ) {
   409|             throw new WikiException( "Could not instantiate ReferenceManager: " + e.getMessage(), e );
   410|         }
   411|     }
   412|     /** {@inheritDoc} */
   413|     @Override
   414|     public Properties getWikiProperties() {
   415|         return m_properties;
   416|     }
   417|     /** {@inheritDoc} */
   418|     @Override
   419|     public String getWorkDir() {
   420|         return m_workDir;
   421|     }
   422|     /** {@inheritDoc} */
   423|     @Override


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/WikiSession.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 57-102 ---
    57|     private static final Logger LOG = LogManager.getLogger( WikiSession.class );
    58|     private static final String ALL = "*";
    59|     private static final ThreadLocal< Session > c_guestSession = new ThreadLocal<>();
    60|     private final Subject m_subject = new Subject();
    61|     private final Map< String, Set< String > > m_messages  = new ConcurrentHashMap<>();
    62|     /** The Engine that created this session. */
    63|     private Engine m_engine;
    64|     private String antiCsrfToken;
    65|     private String m_status            = ANONYMOUS;
    66|     private Principal m_userPrincipal  = WikiPrincipal.GUEST;
    67|     private Principal m_loginPrincipal = WikiPrincipal.GUEST;
    68|     private Locale m_cachedLocale      = Locale.getDefault();
    69|     /**
    70|      * Returns <code>true</code> if one of this WikiSession's user Principals can be shown to belong to a particular wiki group. If
    71|      * the user is not authenticated, this method will always return <code>false</code>.
    72|      *
    73|      * @param group the group to test
    74|      * @return the result
    75|      */
    76|     protected boolean isInGroup( final Group group ) {
    77|         for( final Principal principal : getPrincipals() ) {
    78|             if( isAuthenticated() && group.isMember( principal ) ) {
    79|                 return true;
    80|             }
    81|         }
    82|         return false;
    83|     }
    84|     /**
    85|      * Private constructor to prevent WikiSession from being instantiated directly.
    86|      */
    87|     private WikiSession() {
    88|     }
    89|     /** {@inheritDoc} */
    90|     @Override
    91|     public boolean isAsserted() {
    92|         return m_subject.getPrincipals().contains( Role.ASSERTED );
    93|     }
    94|     /** {@inheritDoc} */
    95|     @Override
    96|     public boolean isAuthenticated() {
    97|         if ( m_subject.getPrincipals().contains( Role.AUTHENTICATED ) ) {
    98|             return true;
    99|         }
   100|         if ( !isAnonymous() && !isAsserted() ) {
   101|             m_subject.getPrincipals().add( Role.AUTHENTICATED );
   102|             return true;

# --- HUNK 2: Lines 158-204 ---
   158|             m_messages.clear();
   159|         }
   160|     }
   161|     /** {@inheritDoc} */
   162|     @Override
   163|     public String[] getMessages() {
   164|         return getMessages( ALL );
   165|     }
   166|     /** {@inheritDoc} */
   167|     @Override
   168|     public String[] getMessages( final String topic ) {
   169|         final Set< String > messages = m_messages.get( topic );
   170|         if( messages == null || messages.size() == 0 ) {
   171|             return new String[ 0 ];
   172|         }
   173|         return messages.toArray( new String[0] );
   174|     }
   175|     /** {@inheritDoc} */
   176|     @Override
   177|     public Principal[] getPrincipals() {
   178|         final ArrayList< Principal > principals = new ArrayList<>();
   179|         for( final Principal principal : m_subject.getPrincipals() ) {
   180|             if ( AuthenticationManager.isUserPrincipal( principal ) ) {
   181|                 principals.add( principal );
   182|             }
   183|         }
   184|         return principals.toArray( new Principal[0] );
   185|     }
   186|     /** {@inheritDoc} */
   187|     @Override
   188|     public Principal[] getRoles() {
   189|         final Set< Principal > roles = new HashSet<>();
   190|         roles.addAll( m_subject.getPrincipals( Role.class ) );
   191|         roles.addAll( m_subject.getPrincipals( GroupPrincipal.class ) );
   192|         final Principal[] roleArray = roles.toArray( new Principal[0] );
   193|         Arrays.sort( roleArray, WikiPrincipal.COMPARATOR );
   194|         return roleArray;
   195|     }
   196|     /** {@inheritDoc} */
   197|     @Override
   198|     public boolean hasPrincipal( final Principal principal ) {
   199|         return m_subject.getPrincipals().contains( principal );
   200|     }
   201|     /**
   202|      * Listens for WikiEvents generated by source objects such as the GroupManager, UserManager or AuthenticationManager. This method adds
   203|      * Principals to the private Subject managed by the WikiSession.
   204|      *


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/auth/AuthenticationManager.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 148-193 ---
   148|      */
   149|     static boolean isRolePrincipal( final Principal principal ) {
   150|         return principal instanceof Role || principal instanceof GroupPrincipal;
   151|     }
   152|     /**
   153|      * Determines whether the supplied Principal is a "user principal".
   154|      *
   155|      * @param principal the principal to test
   156|      * @return {@code false} if the Principal is of type {@link GroupPrincipal} or {@link Role}, {@code true} otherwise.
   157|      */
   158|     static boolean isUserPrincipal( final Principal principal ) {
   159|         return !isRolePrincipal( principal );
   160|     }
   161|     /**
   162|      * Returns the first Principal in a set that isn't a {@link Role} or {@link GroupPrincipal}.
   163|      *
   164|      * @param principals the principal set
   165|      * @return the login principal
   166|      */
   167|     default Principal getLoginPrincipal( final Set< Principal > principals ) {
   168|         for( final Principal principal : principals ) {
   169|             if ( isUserPrincipal( principal ) ) {
   170|                 return principal;
   171|             }
   172|         }
   173|         return null;
   174|     }
   175|     /**
   176|      * Registers a WikiEventListener with this instance. This is a convenience method.
   177|      *
   178|      * @param listener the event listener
   179|      */
   180|     void addWikiEventListener( WikiEventListener listener );
   181|     /**
   182|      * Un-registers a WikiEventListener with this instance. This is a convenience method.
   183|      *
   184|      * @param listener the event listener
   185|      */
   186|     void removeWikiEventListener( final WikiEventListener listener );
   187|     /**
   188|      *  Fires a WikiSecurityEvent of the provided type, Principal and target Object to all registered listeners.
   189|      *
   190|      * @see org.apache.wiki.event.WikiSecurityEvent
   191|      * @param type       the event type to be fired
   192|      * @param principal  the subject of the event, which may be <code>null</code>
   193|      * @param target     the changed Object, which may be <code>null</code>


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/auth/DefaultAuthorizationManager.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 135-179 ---
   135|     /** {@inheritDoc} */
   136|     @Override
   137|     public Authorizer getAuthorizer() throws WikiSecurityException {
   138|         if ( m_authorizer != null ) {
   139|             return m_authorizer;
   140|         }
   141|         throw new WikiSecurityException( "Authorizer did not initialize properly. Check the logs." );
   142|     }
   143|     /** {@inheritDoc} */
   144|     @Override
   145|     public boolean hasRoleOrPrincipal( final Session session, final Principal principal ) {
   146|         if( session == null || principal == null ) {
   147|             return false;
   148|         }
   149|         if( AuthenticationManager.isRolePrincipal( principal ) ) {
   150|             return isUserInRole( session, principal );
   151|         }
   152|         if( session.isAuthenticated() && AuthenticationManager.isUserPrincipal( principal ) ) {
   153|             final String principalName = principal.getName();
   154|             final Principal[] userPrincipals = session.getPrincipals();
   155|             for( final Principal userPrincipal : userPrincipals ) {
   156|                 if( userPrincipal.getName().equals( principalName ) ) {
   157|                     return true;
   158|                 }
   159|             }
   160|         }
   161|         return false;
   162|     }
   163|     /** {@inheritDoc} */
   164|     @Override
   165|     public boolean hasAccess( final Context context, final HttpServletResponse response, final boolean redirect ) throws IOException {
   166|         final boolean allowed = checkPermission( context.getWikiSession(), context.requiredPermission() );
   167|         if ( context.getHttpRequest() != null && context.getHttpRequest().getAttribute( Context.ATTR_CONTEXT ) == null ) {
   168|             context.getHttpRequest().setAttribute( Context.ATTR_CONTEXT, context );
   169|         }
   170|         if( !allowed && redirect ) {
   171|             final ResourceBundle rb = Preferences.getBundle( context, InternationalizationManager.CORE_BUNDLE );
   172|             final Principal currentUser  = context.getWikiSession().getUserPrincipal();
   173|             final String pageurl = context.getPage().getName();
   174|             if( context.getWikiSession().isAuthenticated() ) {
   175|                 LOG.info( "User {} has no access - forbidden (permission={})", currentUser.getName(), context.requiredPermission() );
   176|                 context.getWikiSession().addMessage( MessageFormat.format( rb.getString( "security.error.noaccess.logged" ), context.getName()) );
   177|             } else {
   178|                 LOG.info( "User {} has no access - redirecting (permission={})", currentUser.getName(), context.requiredPermission() );
   179|                 context.getWikiSession().addMessage( MessageFormat.format( rb.getString( "security.error.noaccess" ), context.getName() ) );


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/auth/DefaultUserManager.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 340-380 ---
   340|      *  Even though this gets serialized whenever container shuts down/restarts, this gets reinstalled to the session when JSPWiki starts.
   341|      *  This means that it's not actually necessary to save anything.
   342|      */
   343|     public static final class JSONUserModule implements WikiAjaxServlet {
   344| 		private final DefaultUserManager m_manager;
   345|         /**
   346|          *  Create a new JSONUserModule.
   347|          *  @param mgr Manager
   348|          */
   349|         public JSONUserModule( final DefaultUserManager mgr )
   350|         {
   351|             m_manager = mgr;
   352|         }
   353|         @Override
   354|         public String getServletMapping() {
   355|         	return JSON_USERS;
   356|         }
   357|         @Override
   358|         public void service( final HttpServletRequest req, final HttpServletResponse resp, final String actionName, final List<String> params) throws ServletException, IOException {
   359|         	try {
   360|             	if( params.size() < 1 ) {
   361|             		return;
   362|             	}
   363|         		final String uid = params.get(0);
   364| 	        	LOG.debug("uid="+uid);
   365| 	        	if (StringUtils.isNotBlank(uid)) {
   366| 		            final UserProfile prof = getUserInfo(uid);
   367| 		            resp.getWriter().write(AjaxUtil.toJson(prof));
   368| 	        	}
   369|         	} catch (final NoSuchPrincipalException e) {
   370|         		throw new ServletException(e);
   371|         	}
   372|         }
   373|         /**
   374|          *  Directly returns the UserProfile object attached to an uid.
   375|          *
   376|          *  @param uid The user id (e.g. WikiName)
   377|          *  @return A UserProfile object
   378|          *  @throws NoSuchPrincipalException If such a name does not exist.
   379|          */
   380|         public UserProfile getUserInfo( final String uid ) throws NoSuchPrincipalException {


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/auth/SessionMonitor.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 18-57 ---
    18| import org.apache.logging.log4j.LogManager;
    19| import org.apache.logging.log4j.Logger;
    20| import org.apache.wiki.api.core.Engine;
    21| import org.apache.wiki.api.core.Session;
    22| import org.apache.wiki.api.spi.Wiki;
    23| import org.apache.wiki.event.WikiEventListener;
    24| import org.apache.wiki.event.WikiEventManager;
    25| import org.apache.wiki.event.WikiSecurityEvent;
    26| import org.apache.wiki.util.comparators.PrincipalComparator;
    27| import javax.servlet.http.HttpServletRequest;
    28| import javax.servlet.http.HttpSession;
    29| import javax.servlet.http.HttpSessionEvent;
    30| import javax.servlet.http.HttpSessionListener;
    31| import java.security.Principal;
    32| import java.util.ArrayList;
    33| import java.util.Arrays;
    34| import java.util.Collection;
    35| import java.util.Map;
    36| import java.util.WeakHashMap;
    37| import java.util.concurrent.ConcurrentHashMap;
    38| /**
    39|  *  <p>Manages Sessions for different Engines.</p>
    40|  *  <p>The Sessions are stored both in the remote user HttpSession and in the SessionMonitor for the Engine.
    41|  *  This class must be configured as a session listener in the web.xml for the wiki web application.</p>
    42|  */
    43| public class SessionMonitor implements HttpSessionListener {
    44|     private static final Logger LOG = LogManager.getLogger( SessionMonitor.class );
    45|     /** Map with Engines as keys, and SessionMonitors as values. */
    46|     private static final ConcurrentHashMap< Engine, SessionMonitor > c_monitors = new ConcurrentHashMap<>();
    47|     /** Weak hashmap with HttpSessions as keys, and WikiSessions as values. */
    48|     private final Map< String, Session > m_sessions = new WeakHashMap<>();
    49|     private Engine m_engine;
    50|     private final PrincipalComparator m_comparator = new PrincipalComparator();
    51|     /**
    52|      * Returns the instance of the SessionMonitor for this wiki. Only one SessionMonitor exists per Engine.
    53|      *
    54|      * @param engine the wiki engine
    55|      * @return the session monitor
    56|      */
    57|     public static SessionMonitor getInstance( final Engine engine ) {

# --- HUNK 2: Lines 175-219 ---
   175|         }
   176|     }
   177|     /**
   178|      * Returns the current number of active wiki sessions.
   179|      * @return the number of sessions
   180|      */
   181|     public final int sessions()
   182|     {
   183|         return userPrincipals().length;
   184|     }
   185|     /**
   186|      * <p>Returns the current wiki users as a sorted array of Principal objects. The principals are those returned by
   187|      * each WikiSession's {@link Session#getUserPrincipal()}'s method.</p>
   188|      * <p>To obtain the list of current WikiSessions, we iterate through our session Map and obtain the list of values,
   189|      * which are WikiSessions wrapped in {@link java.lang.ref.WeakReference} objects. Those <code>WeakReference</code>s
   190|      * whose <code>get()</code> method returns non-<code>null</code> values are valid sessions.</p>
   191|      *
   192|      * @return the array of user principals
   193|      */
   194|     public final Principal[] userPrincipals() {
   195|         final Collection<Principal> principals = new ArrayList<>();
   196|         synchronized ( m_sessions ) {
   197|             for ( final Session session : m_sessions.values()) {
   198|                 principals.add( session.getUserPrincipal() );
   199|             }
   200|         }
   201|         final Principal[] p = principals.toArray( new Principal[0] );
   202|         Arrays.sort( p, m_comparator );
   203|         return p;
   204|     }
   205|     /**
   206|      * Registers a WikiEventListener with this instance.
   207|      *
   208|      * @param listener the event listener
   209|      * @since 2.4.75
   210|      */
   211|     public final synchronized void addWikiEventListener( final WikiEventListener listener ) {
   212|         WikiEventManager.addWikiEventListener( this, listener );
   213|     }
   214|     /**
   215|      * Un-registers a WikiEventListener with this instance.
   216|      *
   217|      * @param listener the event listener
   218|      * @since 2.4.75
   219|      */


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/auth/acl/AclEntryImpl.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 4-43 ---
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.  
    16|  */
    17| package org.apache.wiki.auth.acl;
    18| import org.apache.wiki.auth.permissions.PagePermission;
    19| import java.io.Serializable;
    20| import java.security.Permission;
    21| import java.security.Principal;
    22| import java.util.Enumeration;
    23| import java.util.Vector;
    24| /**
    25|  * Implementation of a JSPWiki AclEntry.
    26|  *
    27|  * @since 2.3
    28|  */
    29| public class AclEntryImpl implements AclEntry, Serializable {
    30|     private static final long serialVersionUID = 1L;
    31|     private final Vector< Permission > m_permissions = new Vector<>();
    32|     private Principal m_principal;
    33|     /**
    34|      * Constructs a new AclEntryImpl instance.
    35|      */
    36|     public AclEntryImpl() {
    37|     }
    38|     /**
    39|      * Adds the specified permission to this ACL entry. The permission <em>must</em> be of type
    40|      * {@link org.apache.wiki.auth.permissions.PagePermission}. Note: An entry can have multiple permissions.
    41|      *
    42|      * @param permission the permission to be associated with the principal in this entry
    43|      * @return <code>true</code> if the permission was added, <code>false</code> if the permission was

# --- HUNK 2: Lines 101-144 ---
   101|      *
   102|      * @param user the principal to be set for this entry
   103|      * @return true if the principal is set, false if there was already a
   104|      * principal set for this entry
   105|      */
   106|     @Override
   107|     public synchronized boolean setPrincipal(final Principal user ) {
   108|         if( m_principal != null || user == null ) {
   109|             return false;
   110|         }
   111|         m_principal = user;
   112|         return true;
   113|     }
   114|     /**
   115|      * Returns a string representation of the contents of this ACL entry.
   116|      *
   117|      * @return a string representation of the contents.
   118|      */
   119|     public String toString() {
   120|         final Principal p = getPrincipal();
   121|         final StringBuilder sb = new StringBuilder();
   122|         sb.append( "[AclEntry ALLOW " )
   123|           .append( p != null ? p.getName() : "null" )
   124|           .append( " " );
   125|         for( final Permission pp : m_permissions ) {
   126|             sb.append( pp.toString() );
   127|             sb.append( "," );
   128|         }
   129|         sb.append( "]" );
   130|         return sb.toString();
   131|     }
   132|     /**
   133|      * Looks through the permission list and finds a permission that matches the
   134|      * permission.
   135|      */
   136|     private Permission findPermission( final Permission p ) {
   137|         for( final Permission pp : m_permissions ) {
   138|             if( pp.implies( p ) ) {
   139|                 return pp;
   140|             }
   141|         }
   142|         return null;
   143|     }
   144| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/auth/acl/AclImpl.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 77-122 ---
    77|         }
    78|         if( hasEntry( entry ) ) {
    79|             return false;
    80|         }
    81|         m_entries.add( entry );
    82|         return true;
    83|     }
    84|     /** {@inheritDoc} */
    85|     @Override
    86|     public synchronized boolean removeEntry( final AclEntry entry ) {
    87|         return m_entries.remove( entry );
    88|     }
    89|     /** {@inheritDoc} */
    90|     @Override
    91|     public Enumeration< AclEntry > aclEntries() {
    92|         return m_entries.elements();
    93|     }
    94|     /** {@inheritDoc} */
    95|     @Override
    96|     public AclEntry getAclEntry( final Principal principal ) {
    97|         for( final AclEntry entry : m_entries ) {
    98|             if( entry.getPrincipal().getName().equals( principal.getName() ) ) {
    99|                 return entry;
   100|             }
   101|         }
   102|         return null;
   103|     }
   104|     /** {@inheritDoc} */
   105|     @Override
   106|     public boolean isEmpty() {
   107|         return m_entries.isEmpty();
   108|     }
   109|     /** {@inheritDoc} */
   110|     @Override
   111|     public String toString() {
   112|         final StringBuilder sb = new StringBuilder();
   113|         for( final AclEntry entry : m_entries ) {
   114|             final Principal pal = entry.getPrincipal();
   115|             if( pal != null ) {
   116|                 sb.append( "  user = " ).append( pal.getName() ).append( ": " );
   117|             } else {
   118|                 sb.append( "  user = null: " );
   119|             }
   120|             sb.append( "(" );
   121|             for( final Enumeration< Permission > perms = entry.permissions(); perms.hasMoreElements(); ) {
   122|                 final Permission perm = perms.nextElement();


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/auth/authorize/DefaultGroupManager.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 21-60 ---
    21| import org.apache.wiki.api.core.Context;
    22| import org.apache.wiki.api.core.Engine;
    23| import org.apache.wiki.api.core.Session;
    24| import org.apache.wiki.api.exceptions.NoRequiredPropertyException;
    25| import org.apache.wiki.api.exceptions.WikiException;
    26| import org.apache.wiki.auth.AuthenticationManager;
    27| import org.apache.wiki.auth.Authorizer;
    28| import org.apache.wiki.auth.GroupPrincipal;
    29| import org.apache.wiki.auth.NoSuchPrincipalException;
    30| import org.apache.wiki.auth.UserManager;
    31| import org.apache.wiki.auth.WikiPrincipal;
    32| import org.apache.wiki.auth.WikiSecurityException;
    33| import org.apache.wiki.auth.user.UserProfile;
    34| import org.apache.wiki.event.WikiEvent;
    35| import org.apache.wiki.event.WikiEventListener;
    36| import org.apache.wiki.event.WikiEventManager;
    37| import org.apache.wiki.event.WikiSecurityEvent;
    38| import org.apache.wiki.ui.InputValidator;
    39| import org.apache.wiki.util.ClassUtil;
    40| import java.security.Principal;
    41| import java.util.HashMap;
    42| import java.util.HashSet;
    43| import java.util.Map;
    44| import java.util.Properties;
    45| import java.util.Set;
    46| import java.util.StringTokenizer;
    47| /**
    48|  * <p>
    49|  * Facade class for storing, retrieving and managing wiki groups on behalf of AuthorizationManager, JSPs and other presentation-layer
    50|  * classes. GroupManager works in collaboration with a back-end {@link GroupDatabase}, which persists groups to permanent storage.
    51|  * </p>
    52|  * <p>
    53|  * <em>Note: prior to JSPWiki 2.4.19, GroupManager was an interface; it is now a concrete, final class. The aspects of GroupManager
    54|  * which previously extracted group information from storage (e.g., wiki pages) have been refactored into the GroupDatabase interface.</em>
    55|  * </p>
    56|  * @since 2.4.19
    57|  */
    58| public class DefaultGroupManager implements GroupManager, Authorizer, WikiEventListener {
    59|     private static final Logger LOG = LogManager.getLogger( DefaultGroupManager.class );
    60|     protected Engine m_engine;

# --- HUNK 2: Lines 131-176 ---
   131|         final Group[] groups = m_groupDatabase.groups();
   132|         synchronized( m_groups ) {
   133|             for( final Group group : groups ) {
   134|                 m_groups.put( group.getPrincipal(), group );
   135|                 fireEvent( WikiSecurityEvent.GROUP_ADD, group );
   136|             }
   137|         }
   138|         engine.getManager( UserManager.class ).addWikiEventListener( this );
   139|         LOG.info( "Authorizer GroupManager initialized successfully; loaded " + groups.length + " group(s)." );
   140|     }
   141|     /** {@inheritDoc} */
   142|     @Override
   143|     public boolean isUserInRole( final Session session, final Principal role ) {
   144|         if ( session == null || !( role instanceof GroupPrincipal ) || !session.isAuthenticated() ) {
   145|             return false;
   146|         }
   147|         final Group group = m_groups.get( role );
   148|         if( group == null ) {
   149|             return false;
   150|         }
   151|         for( final Principal principal : session.getPrincipals() ) {
   152|             if( AuthenticationManager.isUserPrincipal( principal ) && group.isMember( principal ) ) {
   153|                 return true;
   154|             }
   155|         }
   156|         return false;
   157|     }
   158|     /** {@inheritDoc} */
   159|     @Override
   160|     public Group parseGroup( String name, String memberLine, final boolean create ) throws WikiSecurityException {
   161|         if( name == null ) {
   162|             if( create ) {
   163|                 name = "MyGroup";
   164|             } else {
   165|                 throw new WikiSecurityException( "Group name cannot be blank." );
   166|             }
   167|         } else if( ArrayUtils.contains( Group.RESTRICTED_GROUPNAMES, name ) ) {
   168|             throw new WikiSecurityException( "Illegal group name: " + name );
   169|         }
   170|         name = name.trim();
   171|         if( InputValidator.isBlank( memberLine ) ) {
   172|             memberLine = "";
   173|         }
   174|         memberLine = memberLine.trim();
   175|         final Group group = new Group( name, m_engine.getApplicationName() );
   176|         try {


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/auth/authorize/Group.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 98-156 ---
    98|     /**
    99|      * Two DefaultGroups are equal if they contain identical member Principals
   100|      * and have the same name.
   101|      * @param o the object to compare
   102|      * @return the comparison
   103|      */
   104|     @Override
   105|     public boolean equals( final Object o ) {
   106|         if( !( o instanceof Group ) ) {
   107|             return false;
   108|         }
   109|         final Group g = ( Group )o; // Just a shortcut.
   110|         if( g.m_members.size() != m_members.size() ) {
   111|             return false;
   112|         }
   113|         if( getName() != null && !getName().equals( g.getName() ) ) {
   114|             return false;
   115|         } else if( getName() == null && g.getName() != null ) {
   116|             return false;
   117|         }
   118|         for( final Principal principal : m_members ) {
   119|             if( !g.isMember( principal ) ) {
   120|                 return false;
   121|             }
   122|         }
   123|         return true;
   124|     }
   125|     /**
   126|      *  The hashcode is calculated as a XOR sum over all members of the Group.
   127|      *
   128|      *  @return the hash code
   129|      */
   130|     @Override
   131|     public int hashCode() {
   132|         int hc = 0;
   133|         for( final Principal member : m_members ) {
   134|             hc ^= member.hashCode();
   135|         }
   136|         return hc;
   137|     }
   138|     /**
   139|      * Returns the creation date.
   140|      *
   141|      * @return the creation date
   142|      */
   143|     public synchronized Date getCreated() {
   144|         return m_created;
   145|     }
   146|     /**
   147|      * Returns the creator of this Group.
   148|      *
   149|      * @return the creator
   150|      */
   151|     public final synchronized String getCreator() {
   152|         return m_creator;
   153|     }
   154|     /**
   155|      * Returns the last-modified date.
   156|      *

# --- HUNK 2: Lines 247-274 ---
   247|     }
   248|     /**
   249|      * Sets the name of the user who last modified this group.
   250|      *
   251|      * @param modifier the modifier
   252|      */
   253|     public final synchronized void setModifier( final String modifier ) {
   254|         this.m_modifier = modifier;
   255|     }
   256|     /**
   257|      * Returns a string representation of the Group.
   258|      *
   259|      * @return the string
   260|      * @see java.lang.Object#toString()
   261|      */
   262|     @Override
   263|     public String toString() {
   264|         return "(Group " + getName() + ")";
   265|     }
   266|     private Principal findMember( final String name ) {
   267|         for( final Principal member : m_members ) {
   268|             if( member.getName().equals( name ) ) {
   269|                 return member;
   270|             }
   271|         }
   272|         return null;
   273|     }
   274| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/auth/authorize/WebContainerAuthorizer.java
# Total hunks: 5
# ====================================================================
# --- HUNK 1: Lines 18-61 ---
    18| import org.apache.logging.log4j.LogManager;
    19| import org.apache.logging.log4j.Logger;
    20| import org.apache.wiki.InternalWikiException;
    21| import org.apache.wiki.api.core.Engine;
    22| import org.apache.wiki.api.core.Session;
    23| import org.jdom2.Document;
    24| import org.jdom2.Element;
    25| import org.jdom2.JDOMException;
    26| import org.jdom2.Namespace;
    27| import org.jdom2.filter.Filters;
    28| import org.jdom2.input.SAXBuilder;
    29| import org.jdom2.input.sax.XMLReaders;
    30| import org.jdom2.xpath.XPathFactory;
    31| import org.xml.sax.EntityResolver;
    32| import org.xml.sax.InputSource;
    33| import org.xml.sax.SAXException;
    34| import javax.servlet.http.HttpServletRequest;
    35| import java.io.IOException;
    36| import java.net.URL;
    37| import java.security.Principal;
    38| import java.util.HashSet;
    39| import java.util.List;
    40| import java.util.Properties;
    41| import java.util.Set;
    42| /**
    43|  * Authorizes users by delegating role membership checks to the servlet container. In addition to implementing
    44|  * methods for the <code>Authorizer</code> interface, this class also provides a convenience method
    45|  * {@link #isContainerAuthorized()} that queries the web application descriptor to determine if the container
    46|  * manages authorization.
    47|  *
    48|  * @since 2.3
    49|  */
    50| public class WebContainerAuthorizer implements WebAuthorizer  {
    51|     private static final String J2EE_SCHEMA_25_NAMESPACE = "http://xmlns.jcp.org/xml/ns/javaee";
    52|     private static final Logger LOG = LogManager.getLogger( WebContainerAuthorizer.class );
    53|     protected Engine m_engine;
    54|     /**
    55|      * A lazily-initialized array of Roles that the container knows about. These
    56|      * are parsed from JSPWiki's <code>web.xml</code> web application
    57|      * deployment descriptor. If this file cannot be read for any reason, the
    58|      * role list will be empty. This is a hack designed to get around the fact
    59|      * that we have no direct way of querying the web container about which
    60|      * roles it manages.
    61|      */

# --- HUNK 2: Lines 82-125 ---
    82|         try {
    83|             m_webxml = getWebXml();
    84|             if( m_webxml != null ) {
    85|                 m_webxml.getRootElement().setNamespace( Namespace.getNamespace( J2EE_SCHEMA_25_NAMESPACE ) );
    86|                 m_containerAuthorized = isConstrained( "/Delete.jsp", Role.ALL ) && isConstrained( "/Login.jsp", Role.ALL );
    87|             }
    88|             if( m_containerAuthorized ) {
    89|                 m_containerRoles = getRoles( m_webxml );
    90|                 LOG.info( "JSPWiki is using container-managed authentication." );
    91|             } else {
    92|                 LOG.info( "JSPWiki is using custom authentication." );
    93|             }
    94|         } catch( final IOException e ) {
    95|             LOG.error( "Initialization failed: ", e );
    96|             throw new InternalWikiException( e.getClass().getName() + ": " + e.getMessage(), e );
    97|         } catch( final JDOMException e ) {
    98|             LOG.error( "Malformed XML in web.xml", e );
    99|             throw new InternalWikiException( e.getClass().getName() + ": " + e.getMessage(), e );
   100|         }
   101|         if( m_containerRoles.length > 0 ) {
   102|             final StringBuilder roles = new StringBuilder();
   103|             for( final Role containerRole : m_containerRoles ) {
   104|                 roles.append(containerRole).append(" ");
   105|             }
   106|             LOG.info( " JSPWiki determined the web container manages these roles: " + roles );
   107|         }
   108|         LOG.info( "Authorizer WebContainerAuthorizer initialized successfully." );
   109|     }
   110|     /**
   111|      * Determines whether a user associated with an HTTP request possesses
   112|      * a particular role. This method simply delegates to
   113|      * {@link javax.servlet.http.HttpServletRequest#isUserInRole(String)}
   114|      * by converting the Principal's name to a String.
   115|      * @param request the HTTP request
   116|      * @param role the role to check
   117|      * @return <code>true</code> if the user is considered to be in the role, <code>false</code> otherwise
   118|      */
   119|     @Override
   120|     public boolean isUserInRole( final HttpServletRequest request, final Principal role ) {
   121|         return request.isUserInRole( role.getName() );
   122|     }
   123|     /**
   124|      * Determines whether the Subject associated with a Session is in a
   125|      * particular role. This method takes two parameters: the Session

# --- HUNK 3: Lines 142-187 ---
   142|      * @return <code>true</code> if the user is considered to be in the role, <code>false</code> otherwise
   143|      * @see org.apache.wiki.auth.Authorizer#isUserInRole(org.apache.wiki.api.core.Session, java.security.Principal)
   144|      */
   145|     @Override
   146|     public boolean isUserInRole( final Session session, final Principal role ) {
   147|         if( session == null || role == null ) {
   148|             return false;
   149|         }
   150|         return session.hasPrincipal( role );
   151|     }
   152|     /**
   153|      * Looks up and returns a Role Principal matching a given String. If the
   154|      * Role does not match one of the container Roles identified during
   155|      * initialization, this method returns <code>null</code>.
   156|      * @param role the name of the Role to retrieve
   157|      * @return a Role Principal, or <code>null</code>
   158|      * @see org.apache.wiki.auth.Authorizer#initialize(Engine, Properties)
   159|      */
   160|     @Override
   161|     public Principal findRole( final String role ) {
   162|         for( final Role containerRole : m_containerRoles ) {
   163|             if ( containerRole.getName().equals( role ) ) {
   164|                 return containerRole;
   165|             }
   166|         }
   167|         return null;
   168|     }
   169|     /**
   170|      * <p>
   171|      * Protected method that identifies whether a particular webapp URL is
   172|      * constrained to a particular Role. The resource is considered constrained
   173|      * if:
   174|      * </p>
   175|      * <ul>
   176|      * <li>the web application deployment descriptor contains a
   177|      * <code>security-constraint</code> with a child
   178|      * <code>web-resource-collection/url-pattern</code> element matching the
   179|      * URL, <em>and</em>:</li>
   180|      * <li>this constraint also contains an
   181|      * <code>auth-constraint/role-name</code> element equal to the supplied
   182|      * Role's <code>getName()</code> method. If the supplied Role is Role.ALL,
   183|      * it matches all roles</li>
   184|      * </ul>
   185|      * @param url the web resource
   186|      * @param role the role
   187|      * @return <code>true</code> if the resource is constrained to the role,

# --- HUNK 4: Lines 190-237 ---
   190|     public boolean isConstrained( final String url, final Role role ) {
   191|         final Element root = m_webxml.getRootElement();
   192|         final Namespace jeeNs = Namespace.getNamespace( "j", J2EE_SCHEMA_25_NAMESPACE );
   193|         final String constrainsSelector = "//j:web-app/j:security-constraint[j:web-resource-collection/j:url-pattern=\"" + url + "\"]";
   194|         final List< Element > constraints = XPathFactory.instance()
   195|                                                         .compile( constrainsSelector, Filters.element(), null, jeeNs )
   196|                                                         .evaluate( root );
   197|         final String rolesSelector = "//j:web-app/j:security-constraint[j:auth-constraint/j:role-name=\"" + role.getName() + "\"]";
   198|         final List< Element > roles = XPathFactory.instance()
   199|                                                   .compile( rolesSelector, Filters.element(), null, jeeNs )
   200|                                                   .evaluate( root );
   201|         if( constraints.size() == 0 ) {
   202|             return false;
   203|         }
   204|         if( role.equals( Role.ALL ) ) {
   205|             return true;
   206|         }
   207|         if( roles.size() == 0 ) {
   208|             return false;
   209|         }
   210|         for( final Element constraint : constraints ) {
   211|             for( final Element roleConstraint : roles ) {
   212|                 if( constraint.equals( roleConstraint ) ) {
   213|                     return true;
   214|                 }
   215|             }
   216|         }
   217|         return false;
   218|     }
   219|     /**
   220|      * Returns <code>true</code> if the web container is configured to protect
   221|      * certain JSPWiki resources by requiring authentication. Specifically, this
   222|      * method parses JSPWiki's web application descriptor (<code>web.xml</code>)
   223|      * and identifies whether the string representation of
   224|      * {@link org.apache.wiki.auth.authorize.Role#AUTHENTICATED} is required
   225|      * to access <code>/Delete.jsp</code> and <code>LoginRedirect.jsp</code>.
   226|      * If the administrator has uncommented the large
   227|      * <code>&lt;security-constraint&gt;</code> section of <code>web.xml</code>,
   228|      * this will be true. This is admittedly an indirect way to go about it, but
   229|      * it should be an accurate test for default installations, and also in 99%
   230|      * of customized installations.
   231|      *
   232|      * @return <code>true</code> if the container protects resources, <code>false</code> otherwise
   233|      */
   234|     public boolean isContainerAuthorized()
   235|     {
   236|         return m_containerAuthorized;
   237|     }

# --- HUNK 5: Lines 241-291 ---
   241|      * the logical roles enumerated in the <code>web.xml</code>.
   242|      * This method actually returns a defensive copy of an internally stored
   243|      * array.
   244|      *
   245|      * @return an array of Principals representing the roles
   246|      */
   247|     @Override
   248|     public Principal[] getRoles()
   249|     {
   250|         return m_containerRoles.clone();
   251|     }
   252|     /**
   253|      * Protected method that extracts the roles from JSPWiki's web application
   254|      * deployment descriptor. Each Role is constructed by using the String
   255|      * representation of the Role, for example
   256|      * <code>new Role("Administrator")</code>.
   257|      * @param webxml the web application deployment descriptor
   258|      * @return an array of Role objects
   259|      */
   260|     protected Role[] getRoles( final Document webxml ) {
   261|         final Set<Role> roles = new HashSet<>();
   262|         final Element root = webxml.getRootElement();
   263|         final Namespace jeeNs = Namespace.getNamespace( "j", J2EE_SCHEMA_25_NAMESPACE );
   264|         final String constrainsSelector = "//j:web-app/j:security-constraint/j:auth-constraint/j:role-name";
   265|         final List< Element > constraints = XPathFactory.instance()
   266|                                                         .compile( constrainsSelector, Filters.element(), null, jeeNs )
   267|                                                         .evaluate( root );
   268|         for( final Element constraint : constraints ) {
   269|             final String role = constraint.getTextTrim();
   270|             roles.add( new Role( role ) );
   271|         }
   272|         final String rolesSelector = "//j:web-app/j:security-role/j:role-name";
   273|         final List< Element > nodes = XPathFactory.instance()
   274|                                                   .compile( rolesSelector, Filters.element(), null, jeeNs )
   275|                                                   .evaluate( root );
   276|         for( final Element node : nodes ) {
   277|             final String role = node.getTextTrim();
   278|             roles.add( new Role( role ) );
   279|         }
   280|         return roles.toArray( new Role[0] );
   281|     }
   282|     /**
   283|      * Returns an {@link org.jdom2.Document} representing JSPWiki's web
   284|      * application deployment descriptor. The document is obtained by calling
   285|      * the servlet context's <code>getResource()</code> method and requesting
   286|      * <code>/WEB-INF/web.xml</code>. For non-servlet applications, this
   287|      * method calls this class'
   288|      * {@link ClassLoader#getResource(java.lang.String)} and requesting
   289|      * <code>WEB-INF/web.xml</code>.
   290|      * @return the descriptor
   291|      * @throws IOException if the deployment descriptor cannot be found or opened


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/auth/permissions/GroupPermission.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 408-438 ---
   408|      *         GroupPrincipal matching the implied GroupPermission&#8217;s group;
   409|      *         <code>false</code> otherwise
   410|      */
   411|     boolean impliesMember(final Permission permission )
   412|     {
   413|         if ( !( permission instanceof GroupPermission ) )
   414|         {
   415|             return false;
   416|         }
   417|         final GroupPermission gp = (GroupPermission) permission;
   418|         if ( !MEMBER_TOKEN.equals( m_group ) )
   419|         {
   420|             return false;
   421|         }
   422|         final AccessControlContext acc = AccessController.getContext();
   423|         final DomainCombiner dc = acc.getDomainCombiner();
   424|         if ( dc != null && dc instanceof SubjectDomainCombiner )
   425|         {
   426|             final Subject subject = ( (SubjectDomainCombiner) dc ).getSubject();
   427|             final Set<GroupPrincipal> principals = subject.getPrincipals( GroupPrincipal.class );
   428|             for( final Principal principal : principals )
   429|             {
   430|                 if ( principal.getName().equals( gp.m_group ) )
   431|                 {
   432|                     return true;
   433|                 }
   434|             }
   435|         }
   436|         return false;
   437|     }
   438| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/auth/user/XMLUserDatabase.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 31-70 ---
    31| import org.xml.sax.SAXException;
    32| import javax.xml.parsers.DocumentBuilderFactory;
    33| import javax.xml.parsers.ParserConfigurationException;
    34| import java.io.BufferedWriter;
    35| import java.io.File;
    36| import java.io.FileNotFoundException;
    37| import java.io.IOException;
    38| import java.io.OutputStreamWriter;
    39| import java.io.Serializable;
    40| import java.nio.charset.StandardCharsets;
    41| import java.nio.file.Files;
    42| import java.security.Principal;
    43| import java.text.DateFormat;
    44| import java.text.ParseException;
    45| import java.text.SimpleDateFormat;
    46| import java.util.Date;
    47| import java.util.Map;
    48| import java.util.Properties;
    49| import java.util.SortedSet;
    50| import java.util.TreeSet;
    51| /**
    52|  * <p>Manages {@link DefaultUserProfile} objects using XML files for persistence. Passwords are hashed using SHA1. User entries are simple
    53|  * <code>&lt;user&gt;</code> elements under the root. User profile properties are attributes of the element. For example:</p>
    54|  * <blockquote><code>
    55|  * &lt;users&gt;<br/>
    56|  * &nbsp;&nbsp;&lt;user loginName="janne" fullName="Janne Jalkanen"<br/>
    57|  * &nbsp;&nbsp;&nbsp;&nbsp;wikiName="JanneJalkanen" email="janne@ecyrd.com"<br/>
    58|  * &nbsp;&nbsp;&nbsp;&nbsp;password="{SHA}457b08e825da547c3b77fbc1ff906a1d00a7daee"/&gt;<br/>
    59|  * &lt;/users&gt;
    60|  * </code></blockquote>
    61|  * <p>In this example, the un-hashed password is <code>myP@5sw0rd</code>. Passwords are hashed without salt.</p>
    62|  * @since 2.3
    63|  */
    64| public class XMLUserDatabase extends AbstractUserDatabase {
    65|     /** The jspwiki.properties property specifying the file system location of the user database. */
    66|     public static final String  PROP_USERDATABASE = "jspwiki.xmlUserDatabaseFile";
    67|     private static final String DEFAULT_USERDATABASE = "userdatabase.xml";
    68|     private static final String ATTRIBUTES_TAG    = "attributes";
    69|     private static final String CREATED           = "created";
    70|     private static final String EMAIL             = "email";

# --- HUNK 2: Lines 301-348 ---
   301|                 setAttribute( user, LOGIN_NAME, newName );
   302|                 setAttribute( user, LAST_MODIFIED, c_format.format( modDate ) );
   303|                 profile.setLoginName( newName );
   304|                 profile.setLastModified( modDate );
   305|                 break;
   306|             }
   307|         }
   308|         saveDOM();
   309|     }
   310|     /** {@inheritDoc} */
   311|     @Override
   312|     public synchronized void save( final UserProfile profile ) throws WikiSecurityException {
   313|         if ( c_dom == null ) {
   314|             LOG.fatal( "Could not save profile " + profile + " database does not exist" );
   315|             throw new IllegalStateException( "FATAL: database does not exist" );
   316|         }
   317|         checkForRefresh();
   318|         final DateFormat c_format = new SimpleDateFormat( DATE_FORMAT );
   319|         final String index = profile.getLoginName();
   320|         final NodeList users = c_dom.getElementsByTagName( USER_TAG );
   321|         Element user = null;
   322|         for( int i = 0; i < users.getLength(); i++ ) {
   323|             final Element currentUser = ( Element )users.item( i );
   324|             if( currentUser.getAttribute( LOGIN_NAME ).equals( index ) ) {
   325|                 user = currentUser;
   326|                 break;
   327|             }
   328|         }
   329|         boolean isNew = false;
   330|         final Date modDate = new Date( System.currentTimeMillis() );
   331|         if( user == null ) {
   332|             profile.setCreated( modDate );
   333|             LOG.info( "Creating new user " + index );
   334|             user = c_dom.createElement( USER_TAG );
   335|             c_dom.getDocumentElement().appendChild( user );
   336|             setAttribute( user, CREATED, c_format.format( profile.getCreated() ) );
   337|             isNew = true;
   338|         } else {
   339|             final NodeList attributes = user.getElementsByTagName( ATTRIBUTES_TAG );
   340|             for( int i = 0; i < attributes.getLength(); i++ ) {
   341|                 user.removeChild( attributes.item( i ) );
   342|             }
   343|         }
   344|         setAttribute( user, UID, profile.getUid() );
   345|         setAttribute( user, LAST_MODIFIED, c_format.format( modDate ) );
   346|         setAttribute( user, LOGIN_NAME, profile.getLoginName() );
   347|         setAttribute( user, FULL_NAME, profile.getFullname() );
   348|         setAttribute( user, WIKI_NAME, profile.getWikiName() );

# --- HUNK 3: Lines 424-474 ---
   424|                     final String serializedMap = extractText( attribute );
   425|                     try {
   426|                         final Map< String, ? extends Serializable > map = Serializer.deserializeFromBase64( serializedMap );
   427|                         profile.getAttributes().putAll( map );
   428|                     } catch( final IOException e ) {
   429|                         LOG.error( "Could not parse user profile attributes!", e );
   430|                     }
   431|                 }
   432|                 return profile;
   433|             }
   434|         }
   435|         return null;
   436|     }
   437|     /**
   438|      * Extracts all the text nodes that are immediate children of an Element.
   439|      *
   440|      * @param element the base element
   441|      * @return the text nodes that are immediate children of the base element, concatenated together
   442|      */
   443|     private String extractText( final Element element ) {
   444|         final StringBuilder text = new StringBuilder();
   445|         if( element.getChildNodes().getLength() > 0 ) {
   446|             final NodeList children = element.getChildNodes();
   447|             for( int k = 0; k < children.getLength(); k++ ) {
   448|                 final Node child = children.item( k );
   449|                 if( child.getNodeType() == Node.TEXT_NODE ) {
   450|                     text.append(((Text) child).getData());
   451|                 }
   452|             }
   453|         }
   454|         return text.toString();
   455|     }
   456|     /**
   457|      *  Tries to parse a date using the default format - then, for backwards compatibility reasons, tries the platform default.
   458|      *
   459|      *  @param profile profile associated to the date.
   460|      *  @param date date to be parsed.
   461|      *  @return A parsed date, or null, if both parse attempts fail.
   462|      */
   463|     private Date parseDate( final UserProfile profile, final String date ) {
   464|         try {
   465|             final DateFormat c_format = new SimpleDateFormat( DATE_FORMAT );
   466|             return c_format.parse( date );
   467|         } catch( final ParseException e ) {
   468|             try {
   469|                 return DateFormat.getDateTimeInstance().parse( date );
   470|             } catch( final ParseException e2 ) {
   471|                 LOG.warn( "Could not parse 'created' or 'lastModified' attribute for profile '" + profile.getLoginName() + "'." +
   472|                           " It may have been tampered with.", e2 );
   473|             }
   474|         }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/content/DefaultPageRenamer.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 124-264 ---
   124|     }
   125|     /**
   126|      *  This method finds all the pages which have anything to do with the fromPage and
   127|      *  change any referrers it can figure out in that page.
   128|      *  
   129|      *  @param context WikiContext in which we operate
   130|      *  @param fromPage The old page
   131|      *  @param toPage The new page
   132|      */
   133|     private void updateReferrers( final Context context, final Page fromPage, final Page toPage, final Set< String > referrers ) {
   134|         if( referrers.isEmpty() ) { // No referrers
   135|             return;
   136|         }
   137|         final Engine engine = context.getEngine();
   138|         for( String pageName : referrers ) {
   139|             if( pageName.equals( fromPage.getName() ) ) {
   140|                 pageName = toPage.getName();
   141|             }
   142|             final Page p = engine.getManager( PageManager.class ).getPage( pageName );
   143|             final String sourceText = engine.getManager( PageManager.class ).getPureText( p );
   144|             String newText = replaceReferrerString( context, sourceText, fromPage.getName(), toPage.getName() );
   145|             m_camelCase = TextUtil.getBooleanProperty( engine.getWikiProperties(), MarkupParser.PROP_CAMELCASELINKS, m_camelCase );
   146|             if( m_camelCase ) {
   147|                 newText = replaceCCReferrerString( context, newText, fromPage.getName(), toPage.getName() );
   148|             }
   149|             if( !sourceText.equals( newText ) ) {
   150|                 p.setAttribute( Page.CHANGENOTE, fromPage.getName()+" ==> "+toPage.getName() );
   151|                 p.setAuthor( context.getCurrentUser().getName() );
   152|                 try {
   153|                     engine.getManager( PageManager.class ).putPageText( p, newText );
   154|                     engine.getManager( ReferenceManager.class ).updateReferences( p );
   155|                 } catch( final ProviderException e ) {
   156|                     LOG.error("Unable to perform rename.",e);
   157|                 }
   158|             }
   159|         }
   160|     }
   161|     private Set<String> getReferencesToChange( final Page fromPage, final Engine engine ) {
   162|         final Set< String > referrers = new TreeSet<>();
   163|         final Collection< String > r = engine.getManager( ReferenceManager.class ).findReferrers( fromPage.getName() );
   164|         if( r != null ) {
   165|             referrers.addAll( r );
   166|         }
   167|         try {
   168|             final List< Attachment > attachments = engine.getManager( AttachmentManager.class ).listAttachments( fromPage );
   169|             for( final Attachment att : attachments  ) {
   170|                 final Collection< String > c = engine.getManager( ReferenceManager.class ).findReferrers( att.getName() );
   171|                 if( c != null ) {
   172|                     referrers.addAll( c );
   173|                 }
   174|             }
   175|         } catch( final ProviderException e ) {
   176|             LOG.error( "Provider error while fetching attachments for rename", e );
   177|         }
   178|         return referrers;
   179|     }
   180|     /**
   181|      *  Replaces camelcase links.
   182|      */
   183|     private String replaceCCReferrerString( final Context context, final String sourceText, final String from, final String to ) {
   184|         final StringBuilder sb = new StringBuilder( sourceText.length()+32 );
   185|         final Pattern linkPattern = Pattern.compile( "\\p{Lu}+\\p{Ll}+\\p{Lu}+[\\p{L}\\p{Digit}]*" );
   186|         final Matcher matcher = linkPattern.matcher( sourceText );
   187|         int start = 0;
   188|         while( matcher.find( start ) ) {
   189|             final String match = matcher.group();
   190|             sb.append( sourceText, start, matcher.start() );
   191|             final int lastOpenBrace = sourceText.lastIndexOf( '[', matcher.start() );
   192|             final int lastCloseBrace = sourceText.lastIndexOf( ']', matcher.start() );
   193|             if( match.equals( from ) && lastCloseBrace >= lastOpenBrace ) {
   194|                 sb.append( to );
   195|             } else {
   196|                 sb.append( match );
   197|             }
   198|             start = matcher.end();
   199|         }
   200|         sb.append( sourceText.substring( start ) );
   201|         return sb.toString();
   202|     }
   203|     private String replaceReferrerString( final Context context, final String sourceText, final String from, final String to ) {
   204|         final StringBuilder sb = new StringBuilder( sourceText.length()+32 );
   205|         final Pattern linkPattern = Pattern.compile( "([\\[~]?)\\[([^|\\]]*)(\\|)?([^|\\]]*)(\\|)?([^|\\]]*)]" );
   206|         final Matcher matcher = linkPattern.matcher( sourceText );
   207|         int start = 0;
   208|         while( matcher.find( start ) ) {
   209|             char charBefore = (char)-1;
   210|             if( matcher.start() > 0 ) {
   211|                 charBefore = sourceText.charAt( matcher.start() - 1 );
   212|             }
   213|             if( !matcher.group(1).isEmpty() || charBefore == '~' || charBefore == '[' ) {
   214|                 sb.append( sourceText, start, matcher.end() );
   215|                 start = matcher.end();
   216|                 continue;
   217|             }
   218|             String text = matcher.group(2);
   219|             String link = matcher.group(4);
   220|             final String attr = matcher.group(6);
   221|             if( link.isEmpty() ) {
   222|                 text = replaceSingleLink( context, text, from, to );
   223|             } else {
   224|                 link = replaceSingleLink( context, link, from, to );
   225|                 text = TextUtil.replaceString( text, from, to );
   226|             }
   227|             sb.append( sourceText, start, matcher.start() );
   228|             sb.append( "[" ).append( text );
   229|             if( !link.isEmpty() ) {
   230|                 sb.append( "|" ).append( link );
   231|             }
   232|             if( !attr.isEmpty() ) {
   233|                 sb.append( "|" ).append( attr );
   234|             }
   235|             sb.append( "]" );
   236|             start = matcher.end();
   237|         }
   238|         sb.append( sourceText.substring( start ) );
   239|         return sb.toString();
   240|     }
   241|     /**
   242|      *  This method does a correct replacement of a single link, taking into account anchors and attachments.
   243|      */
   244|     private String replaceSingleLink( final Context context, final String original, final String from, final String newlink ) {
   245|         final int hash = original.indexOf( '#' );
   246|         final int slash = original.indexOf( '/' );
   247|         String realLink = original;
   248|         if( hash != -1 ) {
   249|             realLink = original.substring( 0, hash );
   250|         }
   251|         if( slash != -1 ) {
   252|             realLink = original.substring( 0,slash );
   253|         }
   254|         realLink = MarkupParser.cleanLink( realLink );
   255|         final String oldStyleRealLink = MarkupParser.wikifyLink( realLink );
   256|         if( realLink.equals( from ) || original.equals( from ) || oldStyleRealLink.equals( from ) ) {
   257|             final int blank = realLink.indexOf( " ");
   258|             if( blank != -1 ) {
   259|                 return original + "|" + newlink;
   260|             }
   261|             return newlink + ( ( hash > 0 ) ? original.substring( hash ) : "" ) + ( ( slash > 0 ) ? original.substring( slash ) : "" ) ;
   262|         }
   263|         return original;
   264|     }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/diff/ContextualDiffProvider.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 16-58 ---
    16| */
    17| package org.apache.wiki.diff;
    18| import org.apache.logging.log4j.LogManager;
    19| import org.apache.logging.log4j.Logger;
    20| import org.apache.wiki.api.core.Context;
    21| import org.apache.wiki.api.core.Engine;
    22| import org.apache.wiki.api.exceptions.NoRequiredPropertyException;
    23| import org.apache.wiki.util.TextUtil;
    24| import org.suigeneris.jrcs.diff.Diff;
    25| import org.suigeneris.jrcs.diff.DifferentiationFailedException;
    26| import org.suigeneris.jrcs.diff.Revision;
    27| import org.suigeneris.jrcs.diff.RevisionVisitor;
    28| import org.suigeneris.jrcs.diff.delta.AddDelta;
    29| import org.suigeneris.jrcs.diff.delta.ChangeDelta;
    30| import org.suigeneris.jrcs.diff.delta.Chunk;
    31| import org.suigeneris.jrcs.diff.delta.DeleteDelta;
    32| import org.suigeneris.jrcs.diff.delta.Delta;
    33| import org.suigeneris.jrcs.diff.myers.MyersDiff;
    34| import java.io.IOException;
    35| import java.util.ArrayList;
    36| import java.util.List;
    37| import java.util.Properties;
    38| import java.util.StringTokenizer;
    39| /**
    40|  * A seriously better diff provider, which highlights changes word-by-word using CSS.
    41|  *
    42|  * Suggested by John Volkar.
    43|  */
    44| public class ContextualDiffProvider implements DiffProvider {
    45|     private static final Logger LOG = LogManager.getLogger( ContextualDiffProvider.class );
    46|     /**
    47|      *  A jspwiki.properties value to define how many characters are shown around the change context.
    48|      *  The current value is <tt>{@value}</tt>.
    49|      */
    50|     public static final String PROP_UNCHANGED_CONTEXT_LIMIT = "jspwiki.contextualDiffProvider.unchangedContextLimit";
    51|     public boolean m_emitChangeNextPreviousHyperlinks = true;
    52|     public static String CHANGE_START_HTML = ""; //This could be a image '>' for a start marker
    53|     public static String CHANGE_END_HTML = ""; //and an image for an end '<' marker
    54|     public static String DIFF_START = "<div class=\"diff-wikitext\">";
    55|     public static String DIFF_END = "</div>";
    56|     public static String INSERTION_START_HTML = "<font color=\"#8000FF\"><span class=\"diff-insertion\">";
    57|     public static String INSERTION_END_HTML = "</span></font>";
    58|     public static String DELETION_START_HTML = "<strike><font color=\"red\"><span class=\"diff-deletion\">";

# --- HUNK 2: Lines 173-226 ---
   173|         /** Buffer to coalesce the changes together */
   174|         private StringBuffer m_origBuf;
   175|         private StringBuffer m_newBuf;
   176|         /** Reference to the source string array */
   177|         private final String[] m_origStrings;
   178|         private ChangeMerger( final StringBuffer sb, final String[] origStrings, final int max ) {
   179|             m_sb = sb;
   180|             m_origStrings = origStrings != null ? origStrings.clone() : null;
   181|             m_max = max;
   182|             m_origBuf = new StringBuffer();
   183|             m_newBuf = new StringBuffer();
   184|         }
   185|         private void updateState( final Delta delta ) {
   186|             m_index++;
   187|             final Chunk orig = delta.getOriginal();
   188|             if( orig.first() > m_firstElem ) {
   189|                 flushChanges();
   190|                 if( ( orig.first() - m_firstElem ) > 2 * m_unchangedContextLimit ) {
   191|                     if (m_firstElem > 0) {
   192|                         final int endIndex = Math.min( m_firstElem + m_unchangedContextLimit, m_origStrings.length -1 );
   193|                         for( int j = m_firstElem; j < endIndex; j++ ) {
   194|                             m_sb.append( m_origStrings[ j ] );
   195|                         }
   196|                         m_sb.append( ELIDED_TAIL_INDICATOR_HTML );
   197|                     }
   198|                     m_sb.append( ELIDED_HEAD_INDICATOR_HTML );
   199|                     final int startIndex = Math.max(orig.first() - m_unchangedContextLimit, 0);
   200|                     for (int j = startIndex; j < orig.first(); j++) {
   201|                         m_sb.append( m_origStrings[ j ] );
   202|                     }
   203|                 } else {
   204|                     for( int j = m_firstElem; j < orig.first(); j++ ) {
   205|                         m_sb.append( m_origStrings[ j ] );
   206|                     }
   207|                 }
   208|             }
   209|             m_firstElem = orig.last() + 1;
   210|         }
   211|         @Override
   212|         public void visit( final Revision rev ) {
   213|         }
   214|         @Override
   215|         public void visit( final AddDelta delta ) {
   216|             updateState( delta );
   217|             if( m_mode == 1 ) {
   218|                 flushChanges();
   219|                 m_mode = -1;
   220|             }
   221|             if( m_mode == -1 ) {
   222|                 m_mode = 0;
   223|             }
   224|             if( m_mode == 0 || m_mode == 2 ) {
   225|                 addNew( delta.getRevised() );
   226|                 m_mode = 1;

# --- HUNK 3: Lines 239-286 ---
   239|         public void visit( final DeleteDelta delta ) {
   240|             updateState( delta );
   241|             if( m_mode == 0 ) {
   242|                 flushChanges();
   243|                 m_mode = -1;
   244|             }
   245|             if( m_mode == -1 ) {
   246|                 m_mode = 1;
   247|             }
   248|             if( m_mode == 1 || m_mode == 2 ) {
   249|                 addOrig( delta.getOriginal() );
   250|                 m_mode = 1;
   251|             }
   252|         }
   253|         public void shutdown() {
   254|             m_index = m_max + 1; // Make sure that no hyperlink gets created
   255|             flushChanges();
   256|             if( m_firstElem < m_origStrings.length ) {
   257|                 if( ( m_origStrings.length - m_firstElem ) > m_unchangedContextLimit ) {
   258|                     final int endIndex = Math.min( m_firstElem + m_unchangedContextLimit, m_origStrings.length -1 );
   259|                     for (int j = m_firstElem; j < endIndex; j++) {
   260|                         m_sb.append( m_origStrings[ j ] );
   261|                     }
   262|                     m_sb.append( ELIDED_TAIL_INDICATOR_HTML );
   263|                 } else {
   264|                     for( int j = m_firstElem; j < m_origStrings.length; j++ ) {
   265|                         m_sb.append( m_origStrings[ j ] );
   266|                     }
   267|                 }
   268|             }
   269|         }
   270|         private void addOrig( final Chunk chunk ) {
   271|             if( chunk != null ) {
   272|                 chunk.toString( m_origBuf );
   273|             }
   274|         }
   275|         private void addNew( final Chunk chunk ) {
   276|             if( chunk != null ) {
   277|                 chunk.toString( m_newBuf );
   278|             }
   279|         }
   280|         private void flushChanges() {
   281|             if( m_newBuf.length() + m_origBuf.length() > 0 ) {
   282|                 m_sb.append( CHANGE_START_HTML );
   283|                 if( m_emitChangeNextPreviousHyperlinks && m_count > 1 ) {
   284|                     m_sb.append( BACK_PRE_INDEX );
   285|                     m_sb.append( m_count - 1 );
   286|                     m_sb.append( BACK_POST_INDEX );


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/filters/ProfanityFilter.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 27-73 ---
    27| import java.util.ArrayList;
    28| import java.util.List;
    29| /**
    30|  *  This class is an example of how to have a simple filter.  It removes
    31|  *  all nasty words located at <code>profanity.properties</code> file, inside 
    32|  *  <code>org/apache/wiki/filters</code> package. The search of profanities
    33|  *  is case unsensitive.
    34|  *
    35|  */
    36| public class ProfanityFilter extends BasePageFilter {
    37|     private static final Logger LOG = LogManager.getLogger( ProfanityFilter.class );
    38|     private static final String PROPERTYFILE = "org/apache/wiki/filters/profanity.properties";
    39|     private static String[] c_profanities = new String[0];
    40|     static {
    41|         final ClassLoader loader = ProfanityFilter.class.getClassLoader();
    42|         try( final InputStream in = loader.getResourceAsStream( PROPERTYFILE ) ) {
    43|             if( in == null ) {
    44|                 throw new IOException( "No property file found! (Check the installation, it should be there.)" );
    45|             }
    46|             try( final BufferedReader br =  new BufferedReader( new InputStreamReader( in ) ) ) {
    47|                 final List< String > profs = new ArrayList<>();
    48|                 String str;
    49|                 while ( ( str = br.readLine() ) != null ) {
    50|                     if( !str.isEmpty() && !str.startsWith( "#" ) ) { // allow comments on profanities file
    51|                         profs.add( str );
    52|                     }
    53|                 }
    54|                 c_profanities = profs.toArray( new String[0] );
    55|             }
    56|         } catch( final IOException e ) {
    57|             LOG.error( "Unable to load profanities from " + PROPERTYFILE, e );
    58|         } catch( final Exception e ) {
    59|             LOG.error( "Unable to initialize Profanity Filter", e );
    60|         }
    61|     }
    62|     /**
    63|      *  {@inheritDoc}
    64|      */
    65|     @Override
    66|     public String preTranslate( final Context context, String content ) {
    67|         for( final String word : c_profanities ) {
    68|             final String replacement = word.charAt( 0 ) + "*" + word.charAt( word.length() - 1 );
    69|             content = TextUtil.replaceStringCaseUnsensitive( content, word, replacement );
    70|         }
    71|         return content;
    72|     }
    73| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/filters/SpamFilter.java
# Total hunks: 8
# ====================================================================
# --- HUNK 1: Lines 236-300 ---
   236|         switch( type ) {
   237|             case REJECT: reason = "REJECTED";
   238|                 break;
   239|             case ACCEPT: reason = "ACCEPTED";
   240|                 break;
   241|             case NOTE: reason = "NOTE";
   242|                 break;
   243|             default: throw new InternalWikiException( "Illegal type " + type );
   244|         }
   245|         C_SPAMLOG.info( reason + " " + source + " " + uid + " " + addr + " \"" + page + "\" " + message );
   246|         return uid;
   247|     }
   248|     /** {@inheritDoc} */
   249|     @Override
   250|     public String preSave( final Context context, final String content ) throws RedirectException {
   251|         cleanBanList();
   252|         refreshBlacklists( context );
   253|         final Change change = getChange( context, content );
   254|         if( !ignoreThisUser( context ) ) {
   255|             checkBanList( context, change );
   256|             checkSinglePageChange( context, content, change );
   257|             checkIPList( context );
   258|             checkPatternList( context, content, change );
   259|             checkPageName( context, content, change);
   260|         }
   261|         if( !m_stopAtFirstMatch ) {
   262|             final Integer score = context.getVariable( ATTR_SPAMFILTER_SCORE );
   263|             if( score != null && score >= m_scoreLimit ) {
   264|                 throw new RedirectException( "Herb says you got too many points", getRedirectPage( context ) );
   265|             }
   266|         }
   267|         log( context, ACCEPT, "-", change.toString() );
   268|         return content;
   269|     }
   270|     private void checkPageName( final Context context, final String content, final Change change ) throws RedirectException {
   271|         final Page page = context.getPage();
   272|         final String pageName = page.getName();
   273|         final int maxlength = Integer.parseInt(m_pageNameMaxLength);
   274|         if ( pageName.length() > maxlength) {
   275|             final String uid = log( context, REJECT, REASON_PAGENAME_TOO_LONG + "(" + m_pageNameMaxLength + ")" , pageName);
   276|             LOG.info("SPAM:PageNameTooLong (" + uid + "). The length of the page name is too large (" + pageName.length() + " , limit is " + m_pageNameMaxLength + ")");
   277|             checkStrategy( context, REASON_PAGENAME_TOO_LONG, "Herb says '" + pageName + "' is a bad pageName and I trust Herb! (Incident code " + uid + ")" );
   278|         }
   279|     }
   280|     private void checkStrategy( final Context context, final String error, final String message ) throws RedirectException {
   281|         if( m_stopAtFirstMatch ) {
   282|             throw new RedirectException( message, getRedirectPage( context ) );
   283|         }
   284|         Integer score = context.getVariable( ATTR_SPAMFILTER_SCORE );
   285|         if( score != null ) {
   286|             score = score + 1;
   287|         } else {
   288|             score = 1;
   289|         }
   290|         context.setVariable( ATTR_SPAMFILTER_SCORE, score );
   291|     }
   292|     /**
   293|      *  Parses a list of patterns and returns a Collection of compiled Pattern objects.
   294|      *
   295|      * @param source page containing the list of patterns.
   296|      * @param list list of patterns.
   297|      * @return A Collection of the Patterns that were found from the lists.
   298|      */
   299|     private Collection< Pattern > parseWordList( final Page source, final String list ) {
   300|         final ArrayList< Pattern > compiledpatterns = new ArrayList<>();

# --- HUNK 2: Lines 330-423 ---
   330|                     if( line.startsWith("#") ) continue; // It's a comment
   331|                     int ws = line.indexOf( ' ' );
   332|                     if( ws == -1 ) ws = line.indexOf( '\t' );
   333|                     if( ws != -1 ) line = line.substring( 0, ws );
   334|                     try {
   335|                         compiledpatterns.add( m_compiler.compile( line ) );
   336|                     } catch( final MalformedPatternException e ) {
   337|                         LOG.debug( "Malformed spam filter pattern " + line );
   338|                     }
   339|                 }
   340|             } catch( final IOException e ) {
   341|                 LOG.info( "Could not read patterns; returning what I got" , e );
   342|             }
   343|         }
   344|         return compiledpatterns;
   345|     }
   346|     /**
   347|      * Takes a single page change and performs a load of tests on the content change. An admin can modify anything.
   348|      *
   349|      * @param context page Context
   350|      * @param content page content
   351|      * @param change page change
   352|      * @throws RedirectException spam filter rejects the page change.
   353|      */
   354|     private synchronized void checkSinglePageChange( final Context context, final String content, final Change change )
   355|     		throws RedirectException {
   356|         final HttpServletRequest req = context.getHttpRequest();
   357|         if( req != null ) {
   358|             final String addr = HttpUtil.getRemoteAddress( req );
   359|             int hostCounter = 0;
   360|             int changeCounter = 0;
   361|             LOG.debug( "Change is " + change.m_change );
   362|             final long time = System.currentTimeMillis() - 60*1000L; // 1 minute
   363|             for( final Iterator< Host > i = m_lastModifications.iterator(); i.hasNext(); ) {
   364|                 final Host host = i.next();
   365|                 if( host.getAddedTime() < time ) {
   366|                     LOG.debug( "Removed host " + host.getAddress() + " from modification queue (expired)" );
   367|                     i.remove();
   368|                     continue;
   369|                 }
   370|                 if( host.getAddress().equals( addr ) ) {
   371|                     hostCounter++;
   372|                 }
   373|                 if( host.getChange() != null && host.getChange().equals( change ) ) {
   374|                     changeCounter++;
   375|                 }
   376|             }
   377|             if( hostCounter >= m_limitSinglePageChanges ) {
   378|                 final Host host = new Host( addr, null );
   379|                 m_temporaryBanList.add( host );
   380|                 final String uid = log( context, REJECT, REASON_TOO_MANY_MODIFICATIONS, change.m_change );
   381|                 LOG.info( "SPAM:TooManyModifications (" + uid + "). Added host " + addr + " to temporary ban list for doing too many modifications/minute" );
   382|                 checkStrategy( context, REASON_TOO_MANY_MODIFICATIONS, "Herb says you look like a spammer, and I trust Herb! (Incident code " + uid + ")" );
   383|             }
   384|             if( changeCounter >= m_limitSimilarChanges ) {
   385|                 final Host host = new Host( addr, null );
   386|                 m_temporaryBanList.add( host );
   387|                 final String uid = log( context, REJECT, REASON_SIMILAR_MODIFICATIONS, change.m_change );
   388|                 LOG.info( "SPAM:SimilarModifications (" + uid + "). Added host " + addr + " to temporary ban list for doing too many similar modifications" );
   389|                 checkStrategy( context, REASON_SIMILAR_MODIFICATIONS, "Herb says you look like a spammer, and I trust Herb! (Incident code "+uid+")");
   390|             }
   391|             String tstChange  = change.toString();
   392|             int urlCounter = 0;
   393|             while( m_matcher.contains( tstChange,m_urlPattern ) ) {
   394|                 final MatchResult m = m_matcher.getMatch();
   395|                 tstChange = tstChange.substring( m.endOffset(0) );
   396|                 urlCounter++;
   397|             }
   398|             if( urlCounter > m_maxUrls ) {
   399|                 final Host host = new Host( addr, null );
   400|                 m_temporaryBanList.add( host );
   401|                 final String uid = log( context, REJECT, REASON_TOO_MANY_URLS, change.toString() );
   402|                 LOG.info( "SPAM:TooManyUrls (" + uid + "). Added host " + addr + " to temporary ban list for adding too many URLs" );
   403|                 checkStrategy( context, REASON_TOO_MANY_URLS, "Herb says you look like a spammer, and I trust Herb! (Incident code " + uid + ")" );
   404|             }
   405|             checkBotTrap( context, change );
   406|             checkUTF8( context, change );
   407|             checkAkismet( context, change );
   408|             m_lastModifications.add( new Host( addr, change ) );
   409|         }
   410|     }
   411|     /**
   412|      *  Checks against the akismet system.
   413|      *
   414|      * @param context page Context
   415|      * @throws RedirectException spam filter rejects the page change.
   416|      */
   417|     private void checkAkismet( final Context context, final Change change ) throws RedirectException {
   418|         if( m_akismetAPIKey != null ) {
   419|             if( m_akismet == null ) {
   420|                 LOG.info( "Initializing Akismet spam protection." );
   421|                 m_akismet = new Akismet( m_akismetAPIKey, context.getEngine().getBaseURL() );
   422|                 if( !m_akismet.verifyAPIKey() ) {
   423|                     LOG.error( "Akismet API key cannot be verified.  Please check your config." );

# --- HUNK 3: Lines 439-547 ---
   439|                 final String permalink     = context.getViewURL( context.getPage().getName() );
   440|                 final String commentType   = context.getRequestContext().equals( ContextEnum.PAGE_COMMENT.getRequestContext() ) ? "comment" : "edit";
   441|                 final String commentAuthor = context.getCurrentUser().getName();
   442|                 final String commentAuthorEmail = null;
   443|                 final String commentAuthorURL   = null;
   444|                 final boolean isSpam = m_akismet.commentCheck( ipAddress,
   445|                                                                userAgent,
   446|                                                                referrer,
   447|                                                                permalink,
   448|                                                                commentType,
   449|                                                                commentAuthor,
   450|                                                                commentAuthorEmail,
   451|                                                                commentAuthorURL,
   452|                                                                change.toString(),
   453|                                                                null );
   454|                 sw.stop();
   455|                 LOG.debug( "Akismet request done in: " + sw );
   456|                 if( isSpam ) {
   457|                     final String uid = log( context, REJECT, REASON_AKISMET, change.toString() );
   458|                     LOG.info( "SPAM:Akismet (" + uid + "). Akismet thinks this change is spam; added host to temporary ban list." );
   459|                     checkStrategy( context, REASON_AKISMET, "Akismet tells Herb you're a spammer, Herb trusts Akismet, and I trust Herb! (Incident code " + uid + ")" );
   460|                 }
   461|             }
   462|         }
   463|     }
   464|     /**
   465|      * Returns a static string which can be used to detect spambots which just wildly fill in all the fields.
   466|      *
   467|      * @return A string
   468|      */
   469|     public static String getBotFieldName() {
   470|         return "submit_auth";
   471|     }
   472|     /**
   473|      * This checks whether an invisible field is available in the request, and whether it's contents are suspected spam.
   474|      *
   475|      * @param context page Context
   476|      * @param change page change
   477|      * @throws RedirectException spam filter rejects the page change.
   478|      */
   479|     private void checkBotTrap( final Context context, final Change change ) throws RedirectException {
   480|         final HttpServletRequest request = context.getHttpRequest();
   481|         if( request != null ) {
   482|             final String unspam = request.getParameter( getBotFieldName() );
   483|             if( unspam != null && !unspam.isEmpty() ) {
   484|                 final String uid = log( context, REJECT, REASON_BOT_TRAP, change.toString() );
   485|                 LOG.info( "SPAM:BotTrap (" + uid + ").  Wildly behaving bot detected." );
   486|                 checkStrategy( context, REASON_BOT_TRAP, "Spamming attempt detected. (Incident code " + uid + ")" );
   487|             }
   488|         }
   489|     }
   490|     private void checkUTF8( final Context context, final Change change ) throws RedirectException {
   491|         final HttpServletRequest request = context.getHttpRequest();
   492|         if( request != null ) {
   493|             final String utf8field = request.getParameter( "encodingcheck" );
   494|             if( utf8field != null && !utf8field.equals( "\u3041" ) ) {
   495|                 final String uid = log( context, REJECT, REASON_UTF8_TRAP, change.toString() );
   496|                 LOG.info( "SPAM:UTF8Trap (" + uid + ").  Wildly posting dumb bot detected." );
   497|                 checkStrategy( context, REASON_UTF8_TRAP, "Spamming attempt detected. (Incident code " + uid + ")" );
   498|             }
   499|         }
   500|     }
   501|     /** Goes through the ban list and cleans away any host which has expired from it. */
   502|     private synchronized void cleanBanList() {
   503|         final long now = System.currentTimeMillis();
   504|         for( final Iterator< Host > i = m_temporaryBanList.iterator(); i.hasNext(); ) {
   505|             final Host host = i.next();
   506|             if( host.getReleaseTime() < now ) {
   507|                 LOG.debug( "Removed host " + host.getAddress() + " from temporary ban list (expired)" );
   508|                 i.remove();
   509|             }
   510|         }
   511|     }
   512|     /**
   513|      *  Checks the ban list if the IP address of the changer is already on it.
   514|      *
   515|      *  @param context page context
   516|      *  @throws RedirectException spam filter rejects the page change.
   517|      */
   518|     private void checkBanList( final Context context, final Change change ) throws RedirectException {
   519|         final HttpServletRequest req = context.getHttpRequest();
   520|         if( req != null ) {
   521|             final String remote = HttpUtil.getRemoteAddress(req);
   522|             final long now = System.currentTimeMillis();
   523|             for( final Host host : m_temporaryBanList ) {
   524|                 if( host.getAddress().equals( remote ) ) {
   525|                     final long timeleft = ( host.getReleaseTime() - now ) / 1000L;
   526|                     log( context, REJECT, REASON_IP_BANNED_TEMPORARILY, change.m_change );
   527|                     checkStrategy( context, REASON_IP_BANNED_TEMPORARILY,
   528|                             "You have been temporarily banned from modifying this wiki. (" + timeleft + " seconds of ban left)" );
   529|                 }
   530|             }
   531|         }
   532|     }
   533|     /**
   534|      *  If the spam filter notices changes in the black list page, it will refresh them automatically.
   535|      *
   536|      *  @param context associated WikiContext
   537|      */
   538|     private void refreshBlacklists( final Context context ) {
   539|         try {
   540|             boolean rebuild = false;
   541|             final Page sourceSpam = context.getEngine().getManager( PageManager.class ).getPage( m_forbiddenWordsPage );
   542|             if( sourceSpam != null ) {
   543|                 if( m_spamPatterns == null || m_spamPatterns.isEmpty() || sourceSpam.getLastModified().after( m_lastRebuild ) ) {
   544|                     rebuild = true;
   545|                 }
   546|             }
   547|             final Attachment att = context.getEngine().getManager( AttachmentManager.class ).getAttachmentInfo( context, m_blacklist );

# --- HUNK 4: Lines 564-648 ---
   564|                 LOG.info( "IP filter reloaded - recognizing " + m_IPPatterns.size() + " patterns from page " + m_forbiddenIPsPage );
   565|                 if( att != null ) {
   566|                     final InputStream in = context.getEngine().getManager( AttachmentManager.class ).getAttachmentStream(att);
   567|                     final StringWriter out = new StringWriter();
   568|                     FileUtil.copyContents( new InputStreamReader( in, StandardCharsets.UTF_8 ), out );
   569|                     final Collection< Pattern > blackList = parseBlacklist( out.toString() );
   570|                     LOG.info( "...recognizing additional " + blackList.size() + " patterns from blacklist " + m_blacklist );
   571|                     m_spamPatterns.addAll( blackList );
   572|                 }
   573|             }
   574|         } catch( final IOException ex ) {
   575|             LOG.info( "Unable to read attachment data, continuing...", ex );
   576|         } catch( final ProviderException ex ) {
   577|             LOG.info( "Failed to read spam filter attachment, continuing...", ex );
   578|         }
   579|     }
   580|     /**
   581|      * Does a check against a known pattern list.
   582|      *
   583|      * @param context page Context
   584|      * @param content page content
   585|      * @param change page change
   586|      * @throws RedirectException spam filter rejects the page change.
   587|      */
   588|     private void checkPatternList( final Context context, final String content, final Change change ) throws RedirectException {
   589|         if( m_spamPatterns == null || context.getPage().getName().equals( m_forbiddenWordsPage ) ) {
   590|             return;
   591|         }
   592|         String ch = change.toString();
   593|         if( context.getHttpRequest() != null ) {
   594|             ch += HttpUtil.getRemoteAddress( context.getHttpRequest() );
   595|         }
   596|         for( final Pattern p : m_spamPatterns ) {
   597|             if( m_matcher.contains( ch, p ) ) {
   598|                 final String uid = log( context, REJECT, REASON_REGEXP + "(" + p.getPattern() + ")", ch );
   599|                 LOG.info( "SPAM:Regexp (" + uid + "). Content matches the spam filter '" + p.getPattern() + "'" );
   600|                 checkStrategy( context, REASON_REGEXP, "Herb says '" + p.getPattern() + "' is a bad spam word and I trust Herb! (Incident code " + uid + ")" );
   601|             }
   602|         }
   603|     }
   604|     /**
   605|      *  Does a check against a pattern list of IPs.
   606|      *
   607|      *  @param context page context
   608|      *  @throws RedirectException spam filter rejects the page change.
   609|      */
   610|     private void checkIPList( final Context context ) throws RedirectException {
   611|         if( m_IPPatterns == null || context.getPage().getName().equals( m_forbiddenIPsPage ) ) {
   612|             return;
   613|         }
   614|         final String remoteIP = HttpUtil.getRemoteAddress( context.getHttpRequest() );
   615|         LOG.info("Attempting to match remoteIP " + remoteIP + " against " + m_IPPatterns.size() + " patterns");
   616|         for( final Pattern p : m_IPPatterns ) {
   617|              LOG.debug("Attempting to match remoteIP with " + p.getPattern());
   618|             if( m_matcher.contains( remoteIP, p ) ) {
   619|                 final String uid = log( context, REJECT, REASON_IP_BANNED_PERMANENTLY + "(" + p.getPattern() + ")", remoteIP );
   620|                 LOG.info( "SPAM:IPBanList (" + uid + "). remoteIP matches the IP filter '" + p.getPattern() + "'" );
   621|                 checkStrategy( context, REASON_IP_BANNED_PERMANENTLY, "Herb says '" + p.getPattern() + "' is a banned IP and I trust Herb! (Incident code " + uid + ")" );
   622|             }
   623|         }
   624|     }
   625|     private void checkPatternList( final Context context, final String content, final String change ) throws RedirectException {
   626|         final Change c = new Change();
   627|         c.m_change = change;
   628|         checkPatternList( context, content, c );
   629|     }
   630|     /**
   631|      *  Creates a simple text string describing the added content.
   632|      *
   633|      *  @param context page context
   634|      *  @param newText added content
   635|      *  @return Empty string, if there is no change.
   636|      */
   637|     private static Change getChange( final Context context, final String newText ) {
   638|         final Page page = context.getPage();
   639|         final StringBuffer change = new StringBuffer();
   640|         final Engine engine = context.getEngine();
   641|         final Change ch = new Change();
   642|         try {
   643|             final String oldText = engine.getManager( PageManager.class ).getPureText( page.getName(), WikiProvider.LATEST_VERSION );
   644|             final String[] first  = Diff.stringToArray( oldText );
   645|             final String[] second = Diff.stringToArray( newText );
   646|             final Revision rev = Diff.diff( first, second, new MyersDiff() );
   647|             if( rev == null || rev.size() == 0 ) {
   648|                 return ch;

# --- HUNK 5: Lines 710-752 ---
   710|      *
   711|      *  @param ctx WikiContext
   712|      *  @return An URL to redirect to
   713|      */
   714|     private String getRedirectPage( final Context ctx ) {
   715|         if( m_useCaptcha ) {
   716|             return ctx.getURL( ContextEnum.PAGE_NONE.getRequestContext(), "Captcha.jsp", "page= " +ctx.getEngine().encodeName( ctx.getPage().getName() ) );
   717|         }
   718|         return ctx.getURL( ContextEnum.PAGE_VIEW.getRequestContext(), m_errorPage );
   719|     }
   720|     /**
   721|      *  Checks whether the UserProfile matches certain checks.
   722|      *
   723|      *  @param profile The profile to check
   724|      *  @param context The WikiContext
   725|      *  @return False, if this userprofile is suspect and should not be allowed to be added.
   726|      *  @since 2.6.1
   727|      */
   728|     public boolean isValidUserProfile( final Context context, final UserProfile profile ) {
   729|         try {
   730|             checkPatternList( context, profile.getEmail(), profile.getEmail() );
   731|             checkPatternList( context, profile.getFullname(), profile.getFullname() );
   732|             checkPatternList( context, profile.getLoginName(), profile.getLoginName() );
   733|         } catch( final RedirectException e ) {
   734|             LOG.info("Detected attempt to create a spammer user account (see above for rejection reason)");
   735|             return false;
   736|         }
   737|         return true;
   738|     }
   739|     /**
   740|      *  This method is used to calculate an unique code when submitting the page to detect edit conflicts.  
   741|      *  It currently incorporates the last-modified date of the page, and the IP address of the submitter.
   742|      *
   743|      *  @param page The WikiPage under edit
   744|      *  @param request The HTTP Request
   745|      *  @since 2.6
   746|      *  @return A hash value for this page and session
   747|      */
   748|     public static String getSpamHash( final Page page, final HttpServletRequest request ) {
   749|         long lastModified = 0;
   750|         if( page.getLastModified() != null ) {
   751|             lastModified = page.getLastModified().getTime();
   752|         }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/forms/FormOpen.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-45 ---
     1| /* 
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.  
    16|  */
    17| package org.apache.wiki.forms;
    18| import org.apache.logging.log4j.LogManager;
    19| import org.apache.logging.log4j.Logger;
    20| import org.apache.wiki.api.core.Context;
    21| import org.apache.wiki.api.core.ContextEnum;
    22| import org.apache.wiki.api.exceptions.PluginException;
    23| import org.apache.wiki.api.plugin.Plugin;
    24| import org.apache.wiki.http.filter.CsrfProtectionFilter;
    25| import org.apache.wiki.preferences.Preferences;
    26| import java.text.MessageFormat;
    27| import java.util.Map;
    28| import java.util.ResourceBundle;
    29| /**
    30|  *  Opens a WikiForm.
    31|  *
    32|  * Builds the HTML code for opening a FORM.
    33|  *
    34|  * <p>Since we're only providing an opening FORM tag, we can't use
    35|  * the ECS utilities.
    36|  *
    37|  * A Form plugin line that produces one looks like this:
    38|  * <p><pre>
    39|  *   [{FormOpen name='formname' handler='pluginname'
    40|  *          submit='submitservlet'
    41|  *          show='always'
    42|  *   }]
    43|  * </pre>
    44|  *
    45|  * <p>Mandatory parameters:

# --- HUNK 2: Lines 55-101 ---
    55|  * this Plugin.)
    56|  *
    57|  * <p>The <i>hide</i> parameter affects the visibility of this
    58|  * form. If left out, the form is always shown. If set to
    59|  * 'onsuccess', the form is not shown if it was submitted
    60|  * successfully. (Note that a reload of the page would cause the
    61|  * context to reset, and the form would be shown again. This may
    62|  * be a useless option.)
    63|  *
    64|  */
    65| public class FormOpen extends FormElement {
    66|     private static final Logger LOG = LogManager.getLogger( FormOpen.class );
    67|     /** Parameter name for setting the method (GET or POST).  Value is <tt>{@value}</tt>. */
    68|     public static final String PARAM_METHOD = "method";
    69|     /**
    70|      *  {@inheritDoc}
    71|      */
    72|     @Override
    73|     public String execute( final Context ctx, final Map< String, String > params ) throws PluginException {
    74|         final ResourceBundle rb = Preferences.getBundle( ctx, Plugin.CORE_PLUGINS_RESOURCEBUNDLE );
    75|         final String formName = params.get( PARAM_FORM );
    76|         if( formName == null ) {
    77|             throw new PluginException( MessageFormat.format( rb.getString( "formopen.missingparam" ), PARAM_FORM ) );
    78|         }
    79|         final String hide     = params.get( PARAM_HIDEFORM );
    80|         final String sourcePage = ctx.getPage().getName();
    81|         String submitServlet = params.get( PARAM_SUBMITHANDLER );
    82|         if( submitServlet == null )
    83|             submitServlet = ctx.getURL( ContextEnum.PAGE_VIEW.getRequestContext(), sourcePage );
    84|         String method = params.get( PARAM_METHOD );
    85|         if( method == null ) {
    86|             method="post";
    87|         }
    88|         if( !( method.equalsIgnoreCase( "get" ) || method.equalsIgnoreCase( "post" ) ) ) {
    89|             throw new PluginException( rb.getString( "formopen.postorgetonly" ) );
    90|         }
    91|         FormInfo info = getFormInfo( ctx );
    92|         if( info != null ) {
    93|             if( formName.equals( info.getName() ) ) {
    94|                 LOG.debug( "Previous FormInfo for this form was found in context." );
    95|                 if( HIDE_SUCCESS.equals( hide ) && info.getStatus() == FormInfo.EXECUTED ) {
    96|                     info.setHide( true );
    97|                     return "<p>" + rb.getString( "formopen.noneedtoshow" ) + "</p>";
    98|                 }
    99|             } else {
   100|                 info = new FormInfo();
   101|             }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/forms/FormOutput.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-84 ---
     1| /* 
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.  
    16|  */
    17| package org.apache.wiki.forms;
    18| import org.apache.wiki.api.core.Context;
    19| import org.apache.wiki.api.core.ContextEnum;
    20| import org.apache.wiki.api.exceptions.PluginException;
    21| import org.apache.wiki.api.plugin.Plugin;
    22| import org.apache.wiki.plugin.DefaultPluginManager;
    23| import org.apache.wiki.plugin.PluginManager;
    24| import org.apache.wiki.preferences.Preferences;
    25| import org.apache.wiki.util.FormUtil;
    26| import java.text.MessageFormat;
    27| import java.util.Map;
    28| import java.util.ResourceBundle;
    29| /**
    30|  */
    31| public class FormOutput extends FormElement {
    32|     /**
    33|      * Executes the FormHandler specified in a Form 'output' plugin,
    34|      * using entries provided in the HttpRequest as FormHandler
    35|      * parameters.
    36|      * <p>
    37|      * If the parameter 'populate' was given, the WikiPlugin it names
    38|      * is used to get default values. (It probably makes a lot of
    39|      * sense for this to be the same plugin as the handler.) 
    40|      * Information for the populator can be given with the FormSet
    41|      * plugin. If 'populate' is not specified, the form is not
    42|      * displayed.
    43|      * <p>
    44|      * Should there be no HTTP request associated with this request,
    45|      * the method will return immediately with an empty string.
    46|      * 
    47|      * @param ctx {@inheritDoc}
    48|      * @param params {@inheritDoc}
    49|      * @return {@inheritDoc}
    50|      */
    51|     @Override
    52|     public String execute( final Context ctx, final Map< String, String > params ) throws PluginException {
    53|         if( ctx.getHttpRequest() == null ) {
    54|             return "";
    55|         }
    56|         final ResourceBundle rb = Preferences.getBundle( ctx, Plugin.CORE_PLUGINS_RESOURCEBUNDLE );
    57|         final String formName   = params.get( PARAM_FORM );
    58|         final String submitForm = ctx.getHttpParameter( PARAM_FORMNAMEHIDDEN );
    59|         final String populator  = params.get( PARAM_POPULATE );
    60|         if( formName == null || !formName.equals( submitForm ) ) {
    61|             if( !PARAM_HANDLER.equals( populator ) )
    62|                 return "";
    63|         }
    64|         final String handler = params.get( PARAM_HANDLER );
    65|         if( handler == null || handler.isEmpty() ) {
    66|             return "<p class=\"error\">" + MessageFormat.format( rb.getString( "formoutput.missingargument" ), PARAM_HANDLER ) + "</p>";
    67|         }
    68|         final String sourcePage = ctx.getPage().getName();
    69|         final String submitServlet = ctx.getURL( ContextEnum.PAGE_VIEW.getRequestContext(), sourcePage );
    70|         FormInfo info = getFormInfo( ctx );
    71|         if( info == null ) {
    72|             info = new FormInfo();
    73|             info.setName( formName );
    74|         }
    75|         info.setHandler( handler );
    76|         info.setAction( submitServlet );
    77|         final Map< String, String > handlerParams = FormUtil.requestToMap( ctx.getHttpRequest(), HANDLERPARAM_PREFIX );
    78|         info.addSubmission( handlerParams );
    79|         info.getSubmission().put( DefaultPluginManager.PARAM_BODY, params.get(DefaultPluginManager.PARAM_BODY ) );
    80|         String handlerOutput = null;
    81|         String error = null;
    82|         try {
    83|             final PluginManager pm = ctx.getEngine().getManager( PluginManager.class );
    84|             handlerOutput = pm.execute( ctx, handler, info.getSubmission() );


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/modules/ModuleManager.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-20 ---
     1| package org.apache.wiki.modules;
     2| import java.util.Collection;
     3| public interface ModuleManager {
     4|     /** Location of the property-files of plugins. (Each plugin should include this property-file in its jar-file) */
     5|     String PLUGIN_RESOURCE_LOCATION = "ini/jspwiki_module.xml";
     6|     /**
     7|      *  Returns true, if the given module is compatible with this version of JSPWiki.
     8|      *
     9|      *  @param info The module to check
    10|      *  @return True, if the module is compatible.
    11|      */
    12|     boolean checkCompatibility( WikiModuleInfo info );
    13|     /**
    14|      * Returns the {@link WikiModuleInfo} information about the provided moduleName.
    15|      *
    16|      * @param moduleName
    17|      * @return The wikiModuleInfo
    18|      */
    19|     WikiModuleInfo getModuleInfo( String moduleName );
    20|     /**


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/parser/JSPWikiMarkupParser.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1211-1255 ---
  1211|         final StringBuilder sb = new StringBuilder( 40 );
  1212|         int braceLevel = 1;
  1213|         int ch;
  1214|         while( ( ch = nextToken() ) != -1 ) {
  1215|             if( ch == '\\' ) {
  1216|                 continue;
  1217|             } else if( ch == opening ) {
  1218|                 braceLevel++;
  1219|             } else if( ch == closing ) {
  1220|                 braceLevel--;
  1221|                 if( braceLevel == 0 ) {
  1222|                     break;
  1223|                 }
  1224|             }
  1225|             sb.append( ( char ) ch );
  1226|         }
  1227|         return sb.toString();
  1228|     }
  1229|     /**
  1230|      * Handles constructs of type %%(style) and %%class
  1231|      * @param newLine
  1232|      * @return An Element containing the div or span, depending on the situation.
  1233|      * @throws IOException
  1234|      */
  1235|     private Element handleDiv( final boolean newLine ) throws IOException {
  1236|         int ch = nextToken();
  1237|         Element el = null;
  1238|         if( ch == '%' ) {
  1239|             String style = null;
  1240|             String clazz = null;
  1241|             ch = nextToken();
  1242|             if( ch == '(' ) {
  1243|                 style = readBraceContent('(',')');
  1244|             } else if( Character.isLetter( (char) ch ) ) {
  1245|                 pushBack( ch );
  1246|                 clazz = readUntil( "( \t\n\r" );
  1247|                 if( clazz != null ) {
  1248|                     clazz = clazz.replace( '.', ' ' )
  1249|                                  .replaceAll( "[^\\s-_\\w\\x200-\\x377]+", "" );
  1250|                 }
  1251|                 ch = nextToken();
  1252|                 if( ch == '(' ) {
  1253|                     style = readBraceContent( '(', ')' );
  1254|                 } else if( ch == '\n' || ch == '\r' ) {
  1255|                     pushBack( ch );

# --- HUNK 2: Lines 1281-1325 ---
  1281|                 final ResourceBundle rb = Preferences.getBundle( m_context, InternationalizationManager.CORE_BUNDLE );
  1282|                 final String msg = MessageFormat.format( rb.getString( "markupparser.error.parserfailure"), e.getMessage() );
  1283|                 return addElement( makeError( msg ) );
  1284|             }
  1285|             final String eol = peekAheadLine();
  1286|             if( !eol.trim().isEmpty() ) {
  1287|                 el = new Element("span");
  1288|                 m_styleStack.push( Boolean.TRUE );
  1289|             } else {
  1290|                 startBlockLevel();
  1291|                 el = new Element("div");
  1292|                 m_styleStack.push( Boolean.FALSE );
  1293|             }
  1294|             if( style != null ) el.setAttribute("style", style);
  1295|             if( clazz != null ) el.setAttribute("class", clazz);
  1296|             return pushElement( el );
  1297|         }
  1298|         pushBack( ch );
  1299|         return el;
  1300|     }
  1301|     private Element handleSlash( final boolean newLine ) throws IOException {
  1302|         final int ch = nextToken();
  1303|         pushBack( ch );
  1304|         if( ch == '%' && !m_styleStack.isEmpty() ) {
  1305|             return handleDiv( newLine );
  1306|         }
  1307|         return null;
  1308|     }
  1309|     private Element handleBar( final boolean newLine ) throws IOException {
  1310|         Element el;
  1311|         if( !m_istable && !newLine ) {
  1312|             return null;
  1313|         }
  1314|         if( newLine ) {
  1315|             if( !m_istable ) {
  1316|                 startBlockLevel();
  1317|                 el = pushElement( new Element("table").setAttribute("class","wikitable").setAttribute("border","1") );
  1318|                 m_istable = true;
  1319|                 m_rowNum = 0;
  1320|             }
  1321|             m_rowNum++;
  1322|             final Element tr = ( m_rowNum % 2 != 0 )
  1323|                        ? new Element("tr").setAttribute("class", "odd")
  1324|                        : new Element("tr");
  1325|             el = pushElement( tr );

# --- HUNK 3: Lines 1544-1587 ---
  1544|             break;
  1545|           case '*':
  1546|             if( m_newLine ) {
  1547|                 pushBack( '*' );
  1548|                 el = handleGeneralList();
  1549|             }
  1550|             break;
  1551|           case '#':
  1552|             if( m_newLine ) {
  1553|                 pushBack( '#' );
  1554|                 el = handleGeneralList();
  1555|             }
  1556|             break;
  1557|           case '|':
  1558|             el = handleBar( m_newLine );
  1559|             break;
  1560|           case '~':
  1561|             el = handleTilde();
  1562|             break;
  1563|           case '%':
  1564|             el = handleDiv( m_newLine );
  1565|             break;
  1566|           case '/':
  1567|             el = handleSlash( m_newLine );
  1568|             break;
  1569|           default:
  1570|             break;
  1571|         }
  1572|         return el != null ? ELEMENT : CHARACTER;
  1573|     }
  1574|     private void closeHeadings() {
  1575|         if( m_lastHeading != null && !m_wysiwygEditorMode ) {
  1576|             addElement( new Element("a").setAttribute( "class",HASHLINK )
  1577|                                               .setAttribute( "href","#" + m_lastHeading.m_titleAnchor )
  1578|                                               .setText( "#" ) );
  1579|             m_lastHeading = null;
  1580|         }
  1581|         popElement( "h2" );
  1582|         popElement( "h3" );
  1583|         popElement( "h4" );
  1584|     }
  1585|     /**
  1586|      *  Parses the entire document from the Reader given in the constructor or set by {@link #setInputReader(Reader)}.
  1587|      *


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/parser/LinkParser.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 4-43 ---
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.parser;
    18| import java.util.ArrayList;
    19| import java.util.Arrays;
    20| import java.util.Iterator;
    21| import java.util.List;
    22| import java.util.NoSuchElementException;
    23| import java.util.StringTokenizer;
    24| import org.apache.logging.log4j.LogManager;
    25| import org.apache.logging.log4j.Logger;
    26| import org.jdom2.Attribute;
    27| /**
    28|  *  Parses JSPWiki-style "augmented" link markup into a Link object
    29|  *  containing the link text, link reference, and any optional link
    30|  *  attributes (as JDOM Attributes).
    31|  *  <p>
    32|  *  The parser recognizes three link forms:
    33|  *  </p>
    34|  *  <ol>
    35|  *    <li><tt> [Text] </tt></li>
    36|  *    <li><tt> [Text | Link] </tt></li>
    37|  *    <li><tt> [Text | Link | attributes] </tt></li>
    38|  *  </ol>
    39|  *  <p>
    40|  *  where the attributes are space-delimited, each in the form of
    41|  *  </p>
    42|  *  <pre>
    43|  *      name1='value1' name2='value2' name3='value3' (etc.) </pre>

# --- HUNK 2: Lines 269-313 ---
   269|     }
   270|     private String require(final StringTokenizer tok, final String required )
   271|             throws ParseException, NoSuchElementException
   272|     {
   273|         final String s = tok.nextToken(required);
   274|         if( !s.equals(required) )
   275|         {
   276|             throw new ParseException("expected '"+required+"' not '"+s+"'");
   277|         }
   278|         return s;
   279|     }
   280|     /**
   281|      *  Returns true if the String <tt>s</tt> is completely
   282|      *  composed of whitespace.
   283|      *
   284|      *  @param s The string to check
   285|      *  @return True, if "s" is all XML whitespace.
   286|      */
   287|     public static final boolean isSpace(final String s )
   288|     {
   289|         for( int i = 0 ; i < s.length() ; i++ )
   290|         {
   291|             if( !isSpace( s.charAt(i)) ) return false;
   292|         }
   293|         return true;
   294|     }
   295|     /**
   296|      *  Returns true if char <tt>c</tt> is a member of
   297|      *  <tt>S</tt> (space) [XML 1.1 production 3].
   298|      *
   299|      *  @param c Character to check.
   300|      *  @return True, if the character is an XML space.
   301|      */
   302|     public static final boolean isSpace(final char c )
   303|     {
   304|         return
   305|            0x20 == c
   306|         || 0x0A == c
   307|         || 0x0D == c
   308|         || 0x09 == c
   309|         || 0x85 == c
   310|         || 0x2028 == c;
   311|     }
   312|     /**
   313|      *  Inner class serving as a struct containing the parsed


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/plugin/AbstractReferralPlugin.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 31-70 ---
    31| import org.apache.wiki.api.exceptions.PluginException;
    32| import org.apache.wiki.api.plugin.Plugin;
    33| import org.apache.wiki.pages.PageManager;
    34| import org.apache.wiki.pages.PageSorter;
    35| import org.apache.wiki.parser.MarkupParser;
    36| import org.apache.wiki.parser.WikiDocument;
    37| import org.apache.wiki.preferences.Preferences;
    38| import org.apache.wiki.preferences.Preferences.TimeFormat;
    39| import org.apache.wiki.render.RenderingManager;
    40| import org.apache.wiki.util.TextUtil;
    41| import org.apache.wiki.util.comparators.CollatorComparator;
    42| import org.apache.wiki.util.comparators.HumanComparator;
    43| import org.apache.wiki.util.comparators.JavaNaturalComparator;
    44| import org.apache.wiki.util.comparators.LocaleComparator;
    45| import java.io.IOException;
    46| import java.text.Collator;
    47| import java.text.ParseException;
    48| import java.text.RuleBasedCollator;
    49| import java.text.SimpleDateFormat;
    50| import java.util.ArrayList;
    51| import java.util.Collection;
    52| import java.util.Date;
    53| import java.util.Iterator;
    54| import java.util.List;
    55| import java.util.Map;
    56| import java.util.stream.Collectors;
    57| /**
    58|  *  This is a base class for all plugins using referral things.
    59|  *
    60|  *  <p>Parameters (also valid for all subclasses of this class) : </p>
    61|  *  <ul>
    62|  *  <li><b>maxwidth</b> - maximum width of generated links</li>
    63|  *  <li><b>separator</b> - separator between generated links (wikitext)</li>
    64|  *  <li><b>after</b> - output after the link</li>
    65|  *  <li><b>before</b> - output before the link</li>
    66|  *  <li><b>exclude</b> -  a regular expression of pages to exclude from the list. </li>
    67|  *  <li><b>include</b> -  a regular expression of pages to include in the list. </li>
    68|  *  <li><b>show</b> - value is either "pages" (default) or "count".  When "count" is specified, shows only the count
    69|  *      of pages which match. (since 2.8)</li>
    70|  *  <li><b>columns</b> - How many columns should the output be displayed on.</li>

# --- HUNK 2: Lines 194-246 ---
   194|     protected List< Page > filterWikiPageCollection( final Collection< Page > pages ) {
   195|         final List< String > pageNames = filterCollection( pages.stream()
   196|                                                                 .map( Page::getName )
   197|                                                                 .collect( Collectors.toList() ) );
   198|         return pages.stream()
   199|                     .filter( wikiPage -> pageNames.contains( wikiPage.getName() ) )
   200|                     .collect( Collectors.toList() );
   201|     }
   202|     /**
   203|      *  Filters a collection according to the include and exclude parameters.
   204|      *
   205|      *  @param c The collection to filter.
   206|      *  @return A filtered collection.
   207|      */
   208|     protected List< String > filterCollection( final Collection< String > c ) {
   209|         final ArrayList< String > result = new ArrayList<>();
   210|         final PatternMatcher pm = new Perl5Matcher();
   211|         for( final String pageName : c ) {
   212|             boolean includeThis = m_include == null;
   213|             if( m_include != null ) {
   214|                 for( final Pattern pattern : m_include ) {
   215|                     if( pm.matches( pageName, pattern ) ) {
   216|                         includeThis = true;
   217|                         break;
   218|                     }
   219|                 }
   220|             }
   221|             if( m_exclude != null ) {
   222|                 for( final Pattern pattern : m_exclude ) {
   223|                     if( pm.matches( pageName, pattern ) ) {
   224|                         includeThis = false;
   225|                         break; // The inner loop, continue on the next item
   226|                     }
   227|                 }
   228|             }
   229|             if( includeThis ) {
   230|                 result.add( pageName );
   231|                 final Page page;
   232|                 if( m_lastModified ) {
   233|                     page = m_engine.getManager( PageManager.class ).getPage( pageName );
   234|                     if( page != null ) {
   235|                         final Date lastModPage = page.getLastModified();
   236|                         LOG.debug( "lastModified Date of page {} : {}", pageName, m_dateLastModified );
   237|                         if( lastModPage.after( m_dateLastModified ) ) {
   238|                             m_dateLastModified = lastModPage;
   239|                         }
   240|                     }
   241|                 }
   242|             }
   243|         }
   244|         return result;
   245|     }
   246|     /**


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/plugin/BugReportHandler.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-50 ---
     1| /*
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.  
    16|  */
    17| package org.apache.wiki.plugin;
    18| import org.apache.logging.log4j.LogManager;
    19| import org.apache.logging.log4j.Logger;
    20| import org.apache.wiki.api.core.Context;
    21| import org.apache.wiki.api.core.Engine;
    22| import org.apache.wiki.api.core.Page;
    23| import org.apache.wiki.api.exceptions.PluginException;
    24| import org.apache.wiki.api.exceptions.RedirectException;
    25| import org.apache.wiki.api.exceptions.WikiException;
    26| import org.apache.wiki.api.plugin.Plugin;
    27| import org.apache.wiki.api.spi.Wiki;
    28| import org.apache.wiki.pages.PageManager;
    29| import org.apache.wiki.parser.MarkupParser;
    30| import org.apache.wiki.preferences.Preferences;
    31| import java.io.PrintWriter;
    32| import java.io.StringWriter;
    33| import java.security.Principal;
    34| import java.text.MessageFormat;
    35| import java.text.SimpleDateFormat;
    36| import java.util.Date;
    37| import java.util.Map;
    38| import java.util.Properties;
    39| import java.util.ResourceBundle;
    40| import java.util.StringTokenizer;
    41| /**
    42|  *  Provides a handler for bug reports.  Still under construction.
    43|  *
    44|  *  <p>Parameters : </p>
    45|  *  <ul>
    46|  *  <li><b>title</b> -  title of the bug, this is required.  If it is empty (as in "")  it is a signal to the handler to return quietly.</li>
    47|  *  <li><b>description</b> - description of the bug.</li>
    48|  *  <li><b>version</b> - version</li>
    49|  *  <li><b>map</b> - I have no idea </li>
    50|  *  <li><b>page</b> - The name of the page to be created for this bug report </li>

# --- HUNK 2: Lines 102-142 ---
   102|             if( submitter != null ) {
   103|                 out.println("|"+mappings.getProperty("submitter","Submitter") + "|" + submitter );
   104|             }
   105|             for( final Map.Entry< String, String > entry : params.entrySet() ) {
   106|                 if( !( entry.getKey().equals( PARAM_TITLE ) ||
   107|                        entry.getKey().equals( PARAM_DESCRIPTION ) ||
   108|                        entry.getKey().equals( PARAM_VERSION ) ||
   109|                        entry.getKey().equals( PARAM_MAPPINGS ) ||
   110|                        entry.getKey().equals( PARAM_PAGE ) ||
   111|                        entry.getKey().startsWith( "_" )
   112|                      ) ) {
   113|                     final String head = mappings.getProperty( entry.getKey(), entry.getKey() );
   114|                     if( !head.isEmpty() ) {
   115|                         out.println( "|" + head + "|" + entry.getValue() );
   116|                     }
   117|                 }
   118|             }
   119|             out.println();
   120|             out.println( description );
   121|             out.close();
   122|             final String pageName = findNextPage( context, title, params.get( PARAM_PAGE ) );
   123|             final Page newPage = Wiki.contents().page( context.getEngine(), pageName );
   124|             final Context newContext = context.clone();
   125|             newContext.setPage( newPage );
   126|             context.getEngine().getManager( PageManager.class ).saveText( newContext, str.toString() );
   127|             final MessageFormat formatter = new MessageFormat("");
   128|             formatter.applyPattern( rb.getString("bugreporthandler.new") );
   129|             final String[] args = { "<a href=\""+context.getViewURL(pageName)+"\">"+pageName+"</a>" };
   130|             return formatter.format( args );
   131|         } catch( final RedirectException e ) {
   132|             LOG.info("Saving not allowed, reason: '"+e.getMessage()+"', can't redirect to "+e.getRedirect());
   133|             throw new PluginException("Saving not allowed, reason: "+e.getMessage());
   134|         } catch( final WikiException e ) {
   135|             LOG.error( "Unable to save page!", e );
   136|             return rb.getString("bugreporthandler.unable" );
   137|         }
   138|     }
   139|     /**
   140|      *  Finds a free page name for adding the bug report.  Tries to construct a page, and if it's found, adds a number to it
   141|      *  and tries again.
   142|      */


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/plugin/CurrentTimePlugin.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-57 ---
     1| /* 
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.  
    16|  */
    17| package org.apache.wiki.plugin;
    18| import org.apache.wiki.api.core.Context;
    19| import org.apache.wiki.api.exceptions.PluginException;
    20| import org.apache.wiki.api.plugin.Plugin;
    21| import org.apache.wiki.preferences.Preferences;
    22| import org.apache.wiki.preferences.Preferences.TimeFormat;
    23| import java.text.SimpleDateFormat;
    24| import java.util.Date;
    25| import java.util.Map;
    26| import java.util.ResourceBundle;
    27| /**
    28|  *  Just displays the current date and time.
    29|  *  The time format is exactly like in the java.text.SimpleDateFormat class.
    30|  *  
    31|  *  <p>Parameters : </p>
    32|  *  NONE
    33|  *  @since 1.7.8
    34|  *  @see java.text.SimpleDateFormat
    35|  */
    36| public class CurrentTimePlugin implements Plugin {
    37|     /**
    38|      *  {@inheritDoc}
    39|      */
    40|     @Override
    41|     public String execute( final Context context, final Map< String, String > params ) throws PluginException {
    42|         final String formatString = params.get( "format" );
    43|         try {
    44|             final SimpleDateFormat fmt;
    45|             if( formatString != null ) {
    46|                 fmt = new SimpleDateFormat( formatString );
    47|             } else {
    48|                 fmt = Preferences.getDateFormat( context, TimeFormat.DATETIME );
    49|             }
    50|             final Date d = new Date();  // Now.
    51|             return fmt.format( d );
    52|         } catch( final IllegalArgumentException e ) {
    53|             final ResourceBundle rb = Preferences.getBundle( context, Plugin.CORE_PLUGINS_RESOURCEBUNDLE );
    54|             throw new PluginException( rb.getString( "currenttimeplugin.badformat" ) + e.getMessage() );
    55|         }
    56|     }
    57| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/plugin/Denounce.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 123-168 ---
   123|         }
   124|         if( linkAllowed ) {
   125|             return "<a href=\"" + link + "\">" + TextUtil.replaceEntities( text ) + "</a>";
   126|         }
   127|         return c_denounceText;
   128|     }
   129|     boolean isLinkValid( final String link ) {
   130|         try {
   131|             new URL( link ).toURI().parseServerAuthority();
   132|         } catch ( final Exception e ) {
   133|             LOG.debug( "invalid link {} - {}", link, e.getMessage() );
   134|             return false;
   135|         }
   136|         return true;
   137|     }
   138|     /**
   139|      *  Returns true, if the path is found among the referers.
   140|      */
   141|     private boolean matchPattern( final List< Pattern > list, final String path ) {
   142|         final PatternMatcher matcher = new Perl5Matcher();
   143|         for( final Pattern pattern : list ) {
   144|             if( matcher.matches( path, pattern ) ) {
   145|                 return true;
   146|             }
   147|         }
   148|         return false;
   149|     }
   150|     private boolean matchHeaders( final HttpServletRequest request ) {
   151|         final String userAgent = request.getHeader( "User-Agent" );
   152|         if( userAgent != null && matchPattern( c_agentPatterns, userAgent ) ) {
   153|             LOG.debug( "Matched user agent " + userAgent + " for denounce." );
   154|             return true;
   155|         }
   156|         final String refererPath = request.getHeader( "Referer" );
   157|         if( refererPath != null && matchPattern( c_refererPatterns, refererPath ) ) {
   158|             LOG.debug( "Matched referer " + refererPath + " for denounce." );
   159|             return true;
   160|         }
   161|         final String host = request.getRemoteHost();
   162|         if( host != null && matchPattern( c_hostPatterns, host ) ) {
   163|             LOG.debug( "Matched host " + host + " for denounce." );
   164|             return true;
   165|         }
   166|         return false;
   167|     }
   168| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/plugin/IndexPlugin.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 17-56 ---
    17| package org.apache.wiki.plugin;
    18| import org.apache.commons.lang3.StringUtils;
    19| import org.apache.logging.log4j.LogManager;
    20| import org.apache.logging.log4j.Logger;
    21| import org.apache.wiki.api.core.Context;
    22| import org.apache.wiki.api.core.ContextEnum;
    23| import org.apache.wiki.api.exceptions.PluginException;
    24| import org.apache.wiki.api.exceptions.ProviderException;
    25| import org.apache.wiki.api.plugin.Plugin;
    26| import org.apache.wiki.pages.PageManager;
    27| import org.apache.wiki.references.ReferenceManager;
    28| import org.jdom2.Element;
    29| import org.jdom2.Namespace;
    30| import org.jdom2.output.Format;
    31| import org.jdom2.output.XMLOutputter;
    32| import java.util.ArrayList;
    33| import java.util.List;
    34| import java.util.Map;
    35| import java.util.Set;
    36| import java.util.regex.Pattern;
    37| /**
    38|  *  A Plugin that creates an index of pages according to a certain pattern.
    39|  *  <br />
    40|  *  The default is to include all pages.
    41|  *  <p>
    42|  *  This is a rewrite of the earlier JSPWiki IndexPlugin using JDOM2.
    43|  8  </p>
    44|  *  <p>
    45|  *  Parameters (from AbstractReferralPlugin):
    46|  *  </p>
    47|  *  <ul>
    48|  *    <li><b>include</b> - A regexp pattern for marking which pages should be included.</li>
    49|  *    <li><b>exclude</b> - A regexp pattern for marking which pages should be excluded.</li>
    50|  *  </ul>
    51|  *  
    52|  * @author Ichiro Furusato
    53|  */
    54| public class IndexPlugin extends AbstractReferralPlugin implements Plugin {
    55|     private static final Logger LOG = LogManager.getLogger(IndexPlugin.class);
    56|     private final Namespace xmlns_XHTML = Namespace.getNamespace("http://www.w3.org/1999/xhtml");

# --- HUNK 2: Lines 105-137 ---
   105|         span.addContent( a );
   106|         return span;
   107|     }
   108|     private Element getElement( final String gi, final String classValue ) {
   109|         final Element elt = new Element( gi, xmlns_XHTML );
   110|         elt.setAttribute( "class", classValue );
   111|         return elt;
   112|     }
   113|     /**
   114|      *  Grabs a list of all pages and filters them according to the include/exclude patterns.
   115|      *  
   116|      * @param context
   117|      * @param include
   118|      * @param exclude
   119|      * @return A list containing page names which matched the filters.
   120|      * @throws ProviderException
   121|      */
   122|     private List<String> listPages( final Context context, final String include, final String exclude ) throws ProviderException {
   123|         final Pattern includePtrn = include != null ? Pattern.compile( include ) : Pattern.compile(".*");
   124|         final Pattern excludePtrn = exclude != null ? Pattern.compile( exclude ) : Pattern.compile("\\p{Cntrl}"); // there are no control characters in page names
   125|         final List< String > result = new ArrayList<>();
   126|         final Set< String > pages = context.getEngine().getManager( ReferenceManager.class ).findCreated();
   127|         for( final String pageName : pages ) {
   128|             if( excludePtrn.matcher( pageName ).matches() ) {
   129|                 continue;
   130|             }
   131|             if( includePtrn.matcher( pageName ).matches() ) {
   132|                 result.add( pageName );
   133|             }
   134|         }
   135|         return result;
   136|     }
   137| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/plugin/InsertPage.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 57-99 ---
    57|     public static final String PARAM_MAXLENGTH = "maxlength";
    58|     /** Parameter name for setting the class.  Value is <tt>{@value}</tt>. */
    59|     public static final String PARAM_CLASS     = "class";
    60|     /** Parameter name for setting the show option.  Value is <tt>{@value}</tt>. */
    61|     public static final String PARAM_SHOW   = "show";
    62|     /** Parameter name for setting the section.  Value is <tt>{@value}</tt>. */
    63|     public static final String PARAM_SECTION   = "section";
    64|     /** Parameter name for setting the default.  Value is <tt>{@value}</tt>. */
    65|     public static final String PARAM_DEFAULT   = "default";
    66|     private static final String DEFAULT_STYLE = "";
    67|     private static final String ONCE_COOKIE = "JSPWiki.Once.";
    68|     /** This attribute is stashed in the WikiContext to make sure that we don't have circular references. */
    69|     public static final String ATTR_RECURSE    = "org.apache.wiki.plugin.InsertPage.recurseCheck";
    70|     /**
    71|      *  {@inheritDoc}
    72|      */
    73|     @Override @SuppressWarnings("unchecked")
    74|     public String execute( final Context context, final Map<String, String> params ) throws PluginException {
    75|         final Engine engine = context.getEngine();
    76|         final StringBuilder res = new StringBuilder();
    77|         final String clazz        = params.get( PARAM_CLASS );
    78|         final String includedPage = params.get( PARAM_PAGENAME );
    79|         String style              = params.get( PARAM_STYLE );
    80|         final boolean showOnce    = "once".equals( params.get( PARAM_SHOW ) );
    81|         final String defaultstr   = params.get( PARAM_DEFAULT );
    82|         final int section         = TextUtil.parseIntParameter(params.get( PARAM_SECTION ), -1 );
    83|         int maxlen                = TextUtil.parseIntParameter(params.get( PARAM_MAXLENGTH ), -1 );
    84|         final ResourceBundle rb = Preferences.getBundle( context, Plugin.CORE_PLUGINS_RESOURCEBUNDLE );
    85|         if( style == null ) {
    86|             style = DEFAULT_STYLE;
    87|         }
    88|         if( maxlen == -1 ) {
    89|             maxlen = Integer.MAX_VALUE;
    90|         }
    91|         if( includedPage != null ) {
    92|             final Page page;
    93|             try {
    94|                 final String pageName = engine.getFinalPageName( includedPage );
    95|                 if( pageName != null ) {
    96|                     page = engine.getManager( PageManager.class ).getPage( pageName );
    97|                 } else {
    98|                     page = engine.getManager( PageManager.class ).getPage( includedPage );
    99|                 }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/plugin/ReferringUndefinedPagesPlugin.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 7-76 ---
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.plugin;
    18| import org.apache.wiki.api.core.Context;
    19| import org.apache.wiki.api.exceptions.PluginException;
    20| import org.apache.wiki.api.plugin.Plugin;
    21| import org.apache.wiki.preferences.Preferences;
    22| import org.apache.wiki.references.ReferenceManager;
    23| import org.apache.wiki.util.TextUtil;
    24| import java.text.MessageFormat;
    25| import java.util.Collection;
    26| import java.util.Map;
    27| import java.util.ResourceBundle;
    28| import java.util.TreeMap;
    29| /**
    30|  *  <p>Lists all pages containing links to Undefined Pages (pages containing dead links).</p>
    31|  *
    32|  *  An original idea from Gregor Hagedorn.
    33|  *
    34|  *  @since 2.10.0
    35|  */
    36| public class ReferringUndefinedPagesPlugin extends AbstractReferralPlugin {
    37|     /** Parameter name for setting the maximum items to show.  Value is <tt>{@value}</tt>. */
    38|     public static final String PARAM_MAX = "max";
    39|     /** Parameter name for setting the text to show when the maximum items is overruled. Value is <tt>{@value}</tt>. */
    40|     public static final String PARAM_EXTRAS = "extras";
    41|     @Override
    42|     public String execute( final Context context, final Map<String, String> params) throws PluginException {
    43|         final ResourceBundle rb = Preferences.getBundle(context, Plugin.CORE_PLUGINS_RESOURCEBUNDLE);
    44|         final ReferenceManager referenceManager = context.getEngine().getManager( ReferenceManager.class );
    45|         final int items = TextUtil.parseIntParameter(params.get(PARAM_MAX), ALL_ITEMS);
    46|         String extras = params.get(PARAM_EXTRAS);
    47|         if (extras == null) {
    48|             extras = rb.getString("referringundefinedpagesplugin.more");
    49|         }
    50|         final Collection< String > uncreatedPages = referenceManager.findUncreated();
    51|         super.initialize( context, params );
    52|         Collection< String > result = null;
    53|         final TreeMap< String, String > sortedMap = new TreeMap<>();
    54|         if( uncreatedPages != null ) {
    55|             for( final String uncreatedPageName : uncreatedPages ) {
    56|                 final Collection< String > referrers = referenceManager.findReferrers( uncreatedPageName );
    57|                 if( referrers != null ) {
    58|                     for( final String referringPage : referrers ) {
    59|                         sortedMap.put( referringPage, "" );
    60|                     }
    61|                 }
    62|             }
    63|             result = sortedMap.keySet();
    64|         }
    65|         result = super.filterAndSortCollection( result );
    66|         final String wikitext = wikitizeCollection( result, m_separator, items );
    67|         final StringBuilder resultHTML = new StringBuilder();
    68|         resultHTML.append( applyColumnsStyle( makeHTML( context, wikitext ) ) );
    69|         if( items < result.size() && items > 0 ) {
    70|             final Object[] args = { "" + ( result.size() - items ) };
    71|             extras = MessageFormat.format( extras, args );
    72|             resultHTML.append( "<br/>" ).append( extras ).append( "<br/>" );
    73|         }
    74|         return resultHTML.toString();
    75|     }
    76| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/plugin/Search.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 9-48 ---
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16| */
    17| package org.apache.wiki.plugin;
    18| import org.apache.logging.log4j.LogManager;
    19| import org.apache.logging.log4j.Logger;
    20| import org.apache.wiki.api.core.Context;
    21| import org.apache.wiki.api.core.ContextEnum;
    22| import org.apache.wiki.api.core.Engine;
    23| import org.apache.wiki.api.exceptions.PluginException;
    24| import org.apache.wiki.api.exceptions.ProviderException;
    25| import org.apache.wiki.api.plugin.Plugin;
    26| import org.apache.wiki.api.search.SearchResult;
    27| import org.apache.wiki.render.RenderingManager;
    28| import org.apache.wiki.search.SearchManager;
    29| import org.apache.wiki.util.XHTML;
    30| import org.apache.wiki.util.XhtmlUtil;
    31| import org.jdom2.Element;
    32| import java.io.IOException;
    33| import java.util.Collection;
    34| import java.util.Iterator;
    35| import java.util.Map;
    36| /**
    37|  *  The "Search" plugin allows you to access the JSPWiki search routines and show the displays in an array on your page.
    38|  *
    39|  *  <p>Parameters : </p>
    40|  *  <ul>
    41|  *  <li><b>query</b> - String. A standard JSPWiki search query.</li>
    42|  *  <li><b>set</b> - String. The JSPWiki context variable that will hold the results of the query. This allows you to pass your queries to other plugins on the same page as well. </li>
    43|  *  <li><b>max</b> - Integer. How many search results are shown at maximum.</li>
    44|  *  </ul>
    45|  *
    46|  *  @since
    47|  */
    48| public class Search implements Plugin {

# --- HUNK 2: Lines 57-97 ---
    57|     public static final String PARAM_MAX   = "max";
    58|     /**
    59|      * {@inheritDoc}
    60|      */
    61|     @Override
    62|     public String execute( final Context context, final Map<String, String> params ) throws PluginException {
    63|         int maxItems = Integer.MAX_VALUE;
    64|         final Collection< SearchResult > results;
    65|         final String queryString = params.get( PARAM_QUERY );
    66|         String set               = params.get( PARAM_SET );
    67|         final String max         = params.get( PARAM_MAX );
    68|         if ( set == null ) set = DEFAULT_SETNAME;
    69|         if ( max != null ) maxItems = Integer.parseInt( max );
    70|         if ( queryString == null ) {
    71|             results = context.getVariable( set );
    72|         } else {
    73|             try {
    74|                 results = doBasicQuery( context, queryString );
    75|                 context.setVariable( set, results );
    76|             } catch( final Exception e ) {
    77|                 return "<div class='error'>" + e.getMessage() + "</div>\n";
    78|             }
    79|         }
    80|         String res = "";
    81|         if ( results != null ) {
    82|             res = renderResults(results,context,maxItems);
    83|         }
    84|         return res;
    85|     }
    86|     private Collection<SearchResult> doBasicQuery( final Context context, final String query ) throws ProviderException, IOException {
    87|         LOG.debug( "Searching for string " + query );
    88|         return context.getEngine().getManager( SearchManager.class ).findPages( query, context );
    89|     }
    90|     private String renderResults( final Collection<SearchResult> results, final Context context, final int maxItems ) {
    91|         final Engine engine = context.getEngine();
    92|         final Element table = XhtmlUtil.element(XHTML.table);
    93|         table.setAttribute(XHTML.ATTR_class,"wikitable search-result");
    94|         Element row = XhtmlUtil.element(XHTML.tr);
    95|         table.addContent(row);
    96|         final Element th1 = XhtmlUtil.element(XHTML.th,"Page");
    97|         th1.setAttribute(XHTML.ATTR_width,"30%");


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/preferences/Preferences.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 62-102 ---
    62|      *  This method will remember if the user has already changed his prefs.
    63|      *
    64|      *  @param pageContext The JSP PageContext.
    65|      */
    66|     public static void setupPreferences( final PageContext pageContext ) {
    67|             reloadPreferences( pageContext );
    68|     }
    69|     /**
    70|      *  Reloads the preferences from the PageContext into the WikiContext.
    71|      *
    72|      *  @param pageContext The page context.
    73|      */
    74|     public static void reloadPreferences( final PageContext pageContext ) {
    75|         final Preferences prefs = new Preferences();
    76|         final Properties props = PropertyReader.loadWebAppProps( pageContext.getServletContext() );
    77|         final Context ctx = Context.findContext( pageContext );
    78|         final String dateFormat = ctx.getEngine().getManager( InternationalizationManager.class )
    79|                                            .get( InternationalizationManager.CORE_BUNDLE, getLocale( ctx ), "common.datetimeformat" );
    80|         prefs.put("SkinName", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.skinname", "PlainVanilla" ) );
    81|         prefs.put("DateFormat", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.dateformat", dateFormat ) );
    82|         prefs.put("TimeZone", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.timezone", java.util.TimeZone.getDefault().getID() ) );
    83|         prefs.put("Orientation", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.orientation", "fav-left" ) );
    84|         prefs.put("Sidebar", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.sidebar", "active" ) );
    85|         prefs.put("Layout", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.layout", "fluid" ) );
    86|         prefs.put("Language", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.language", getLocale( ctx ).toString() ) );
    87|         prefs.put("SectionEditing", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.sectionediting", "true" ) );
    88|         prefs.put("Appearance", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.appearance", "true" ) );
    89|         prefs.put("autosuggest", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.autosuggest", "true" ) );
    90|         prefs.put("tabcompletion", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.tabcompletion", "true" ) );
    91|         prefs.put("smartpairs", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.smartpairs", "false" ) );
    92|         prefs.put("livepreview", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.livepreview", "true" ) );
    93|         prefs.put("previewcolumn", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.previewcolumn", "true" ) );
    94|         prefs.put("editor", TextUtil.getStringProperty( props, "jspwiki.defaultprefs.template.editor", "plain" ) );
    95|         parseJSONPreferences( (HttpServletRequest) pageContext.getRequest(), prefs );
    96|         pageContext.getSession().setAttribute( SESSIONPREFS, prefs );
    97|     }
    98|     /**
    99|      * Parses new-style preferences stored as JSON objects and stores them in the session.  Everything in the cookie is stored.
   100|      *
   101|      * @param request
   102|      * @param prefs The default hashmap of preferences


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/providers/CachingAttachmentProvider.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 140-184 ---
   140|                 }
   141|             }
   142|         }
   143|         if( cachingManager.enabled( CachingManager.CACHE_ATTACHMENTS )
   144|                 && attachments.get() >= cachingManager.info( CachingManager.CACHE_ATTACHMENTS ).getMaxElementsAllowed() ) {
   145|             LOG.warn( "seems {} can't hold all attachments from your page repository, " +
   146|                     "so we're delegating on the underlying provider instead. Please consider increasing " +
   147|                     "your cache sizes on the ehcache configuration file to avoid this behaviour", CachingManager.CACHE_ATTACHMENTS );
   148|             return provider.listAllChanged( timestamp );
   149|         }
   150|         return all;
   151|     }
   152|     /**
   153|      *  Simply goes through the collection and attempts to locate the
   154|      *  given attachment of that name.
   155|      *
   156|      *  @return null, if no such attachment was in this collection.
   157|      */
   158|     private Attachment findAttachmentFromCollection( final Collection< Attachment > c, final String name ) {
   159|         if( c != null ) {
   160|             for( final Attachment att : c ) {
   161|                 if( name.equals( att.getFileName() ) ) {
   162|                     return att;
   163|                 }
   164|             }
   165|         }
   166|         return null;
   167|     }
   168|     /**
   169|      * {@inheritDoc}
   170|      */
   171|     @Override
   172|     public Attachment getAttachmentInfo( final Page page, final String name, final int version ) throws ProviderException {
   173|         LOG.debug( "Getting attachments for {}, name={}, version={}", page, name, version );
   174|         if( version != WikiProvider.LATEST_VERSION ) {
   175|             LOG.debug( "...we don't cache old versions" );
   176|             return provider.getAttachmentInfo( page, name, version );
   177|         }
   178|         final Collection< Attachment > c = cachingManager.get( CachingManager.CACHE_ATTACHMENTS_COLLECTION, page.getName(),
   179|                                                                ()-> provider.listAttachments( page ) );
   180|         return findAttachmentFromCollection( c, name );
   181|     }
   182|     /**
   183|      * {@inheritDoc}
   184|      */


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/references/DefaultReferenceManager.java
# Total hunks: 5
# ====================================================================
# --- HUNK 1: Lines 26-65 ---
    26| import org.apache.wiki.api.core.Page;
    27| import org.apache.wiki.api.exceptions.ProviderException;
    28| import org.apache.wiki.api.filters.BasePageFilter;
    29| import org.apache.wiki.api.providers.PageProvider;
    30| import org.apache.wiki.api.providers.WikiProvider;
    31| import org.apache.wiki.api.spi.Wiki;
    32| import org.apache.wiki.attachment.AttachmentManager;
    33| import org.apache.wiki.event.WikiEvent;
    34| import org.apache.wiki.event.WikiEventManager;
    35| import org.apache.wiki.event.WikiPageEvent;
    36| import org.apache.wiki.pages.PageManager;
    37| import org.apache.wiki.render.RenderingManager;
    38| import org.apache.wiki.util.TextUtil;
    39| import java.io.*;
    40| import java.nio.charset.StandardCharsets;
    41| import java.nio.file.Files;
    42| import java.security.MessageDigest;
    43| import java.security.NoSuchAlgorithmException;
    44| import java.util.*;
    45| import java.util.concurrent.ConcurrentHashMap;
    46| /*
    47|   BUGS
    48|   - if a wikilink is added to a page, then removed, RefMan still thinks that the page refers to the wikilink page. Hm.
    49|   - if a page is deleted, gets very confused.
    50|   - Serialization causes page attributes to be missing, when InitializablePlugins are not executed properly.  Thus,
    51|     serialization should really also mark whether a page is serializable or not...
    52|  */
    53| /*
    54|    A word about synchronizing:
    55|    I expect this object to be accessed in three situations:
    56|    - when an Engine is created, and it scans its wikipages
    57|    - when the Engine saves a page
    58|    - when a JSP page accesses one of the Engine's ReferenceManagers to display a list of (un)referenced pages.
    59|    So, access to this class is fairly rare, and usually triggered by user interaction. OTOH, the methods in this class use their storage
    60|    objects intensively (and, sorry to say, in an unoptimized manner =). My deduction: using unsynchronized HashMaps etc. and syncing methods
    61|    or code blocks is preferrable to using slow, synced storage objects. We don't have iterative code here, so I'm going to use synced
    62|    methods for now.
    63|    Please contact me if you notice problems with ReferenceManager, and especially with synchronization, or if you have suggestions about
    64|    syncing.
    65|    ebu@memecry.net

# --- HUNK 2: Lines 70-110 ---
    70|  *  <LI>What pages a given page refers to
    71|  *  <LI>What pages refer to a given page
    72|  *  </UL>
    73|  *
    74|  *  This is a quick'n'dirty approach without any finesse in storage and searching algorithms; we trust java.util.*.
    75|  *  <P>
    76|  *  This class contains two HashMaps, m_refersTo and m_referredBy. The first is indexed by WikiPage names and contains a Collection of all
    77|  *  WikiPages the page refers to. (Multiple references are not counted, naturally.) The second is indexed by WikiPage names and contains
    78|  *  a Set of all pages that refer to the indexing page. (Notice - the keys of both Maps should be kept in sync.)
    79|  *  <P>
    80|  *  When a page is added or edited, its references are parsed, a Collection is received, and we crudely replace anything previous with
    81|  *  this new Collection. We then check each referenced page name and make sure they know they are referred to by the new page.
    82|  *  <P>
    83|  *  Based on this information, we can perform non-optimal searches for e.g. unreferenced pages, top ten lists, etc.
    84|  *  <P>
    85|  *  The owning class must take responsibility of filling in any pre-existing information, probably by loading each and every WikiPage
    86|  *  and calling this class to update the references when created.
    87|  *
    88|  *  @since 1.6.1 (as of 2.11.0, moved to org.apache.wiki.references)
    89|  */
    90| public class DefaultReferenceManager extends BasePageFilter implements ReferenceManager {
    91|     /**
    92|      *  Maps page wikiname to a Collection of pages it refers to. The Collection must contain Strings. The Collection may contain
    93|      *  names of non-existing pages.
    94|      */
    95|     private Map< String, Collection< String > > m_refersTo;
    96|     private Map< String, Collection< String > > m_unmutableRefersTo;
    97|     /**
    98|      *  Maps page wikiname to a Set of referring pages. The Set must contain Strings. Non-existing pages (a reference exists, but
    99|      *  not a file for the page contents) may have an empty Set in m_referredBy.
   100|      */
   101|     private Map< String, Set< String > > m_referredBy;
   102|     private Map< String, Set< String > > m_unmutableReferredBy;
   103|     private final boolean m_matchEnglishPlurals;
   104|     private static final Logger LOG = LogManager.getLogger( DefaultReferenceManager.class);
   105|     private static final String SERIALIZATION_FILE = "refmgr.ser";
   106|     private static final String SERIALIZATION_DIR  = "refmgr-attr";
   107|     /** We use this also a generic serialization id */
   108|     private static final long serialVersionUID = 4L;
   109|     /**
   110|      *  Builds a new ReferenceManager.

# --- HUNK 3: Lines 405-488 ---
   405|      *  @param references A Collection of Strings, each one pointing to a page this page references.
   406|      */
   407|     @Override
   408|     public void updateReferences( final String page, final Collection< String > references ) {
   409|         internalUpdateReferences( page, references );
   410|         serializeToDisk();
   411|     }
   412|     /**
   413|      *  Updates the referred pages of a new or edited WikiPage. If a refersTo entry for this page already exists, it is
   414|      *  removed and a new one is built from scratch. Also calls updateReferredBy() for each referenced page.
   415|      *  <p>
   416|      *  This method does not synchronize the database to disk.
   417|      *
   418|      *  @param page Name of the page to update.
   419|      *  @param references A Collection of Strings, each one pointing to a page this page references.
   420|      */
   421|     private void internalUpdateReferences( String page, final Collection< String > references) {
   422|         page = getFinalPageName( page );
   423|         final Collection< String > oldRefTo = m_refersTo.get( page );
   424|         m_refersTo.remove( page );
   425|         final TreeSet< String > cleanedRefs = new TreeSet<>();
   426|         for( final String ref : references ) {
   427|             final String reference = getFinalPageName( ref );
   428|             cleanedRefs.add( reference );
   429|         }
   430|         m_refersTo.put( page, cleanedRefs );
   431|         if( !m_referredBy.containsKey( page ) ) {
   432|             m_referredBy.put( page, new TreeSet<>() );
   433|         }
   434|         cleanReferredBy( page, oldRefTo, cleanedRefs );
   435|         for( final String referredPageName : cleanedRefs ) {
   436|             updateReferredBy( getFinalPageName( referredPageName ), page );
   437|         }
   438|     }
   439|     /**
   440|      * Returns the refers-to list. For debugging.
   441|      *
   442|      * @return The refers-to list.
   443|      */
   444|     protected Map< String, Collection< String > > getRefersTo() {
   445|         return m_refersTo;
   446|     }
   447|     /**
   448|      * Returns the referred-by list. For debugging.
   449|      *
   450|      * @return Referred-by lists.
   451|      */
   452|     protected Map< String, Set< String > > getReferredBy() {
   453|         return m_referredBy;
   454|     }
   455|     /**
   456|      * Cleans the 'referred by' list, removing references by 'referrer' to any other page. Called after 'referrer' is removed.
   457|      *
   458|      * Two ways to go about this. One is to look up all pages previously referred by referrer and remove referrer
   459|      * from their lists, and let the update put them back in (except possibly removed ones).
   460|      *
   461|      * The other is to get the old referred-to list, compare to the new, and tell the ones missing in the latter to remove referrer from
   462|      * their list.
   463|      *
   464|      * We'll just try the first for now. Need to come back and optimize this a bit.
   465|      */
   466|     private void cleanReferredBy( final String referrer,
   467|                                   final Collection< String > oldReferred,
   468|                                   final Collection< String > newReferred ) {
   469|         if( oldReferred == null ) {
   470|             return;
   471|         }
   472|         for( final String referredPage : oldReferred ) {
   473|             final Set< String > oldRefBy = m_referredBy.get( referredPage );
   474|             if( oldRefBy != null ) {
   475|                 oldRefBy.remove( referrer );
   476|             }
   477|             if( ( oldRefBy == null || oldRefBy.isEmpty() ) && !m_engine.getManager( PageManager.class ).wikiPageExists( referredPage ) ) {
   478|                 m_referredBy.remove( referredPage );
   479|             }
   480|         }
   481|     }
   482|     /**
   483|      * When initially building a ReferenceManager from scratch, call this method BEFORE calling updateReferences() with
   484|      * a full list of existing page names. It builds the refersTo and referredBy key lists, thus enabling updateReferences()
   485|      * to function correctly.
   486|      * <P>
   487|      * This method should NEVER be called after initialization. It clears all mappings from the reference tables.
   488|      *

# --- HUNK 4: Lines 551-601 ---
   551|         final ArrayList< String > unref = new ArrayList<>();
   552|         for( final String key : m_referredBy.keySet() ) {
   553|             final Set< ? > refs = getReferenceList( m_referredBy, key );
   554|             if( refs == null || refs.isEmpty() ) {
   555|                 unref.add( key );
   556|             }
   557|         }
   558|         return unref;
   559|     }
   560|     /**
   561|      * Finds all references to non-existant pages. This requires a linear scan through m_refersTo values; each value
   562|      * must have a corresponding key entry in the reference Maps, otherwise such a page has never been created.
   563|      * <P>
   564|      * Returns a Collection containing Strings of unreferenced page names. Each non-existant page name is shown only
   565|      * once - we don't return information on who referred to it.
   566|      *
   567|      * @return A Collection of Strings
   568|      */
   569|     @Override
   570|     public Collection< String > findUncreated() {
   571|         final TreeSet< String > uncreated = new TreeSet<>();
   572|         final Collection< Collection< String > > allReferences = m_refersTo.values();
   573|         for( final Collection<String> refs : allReferences ) {
   574|             if( refs != null ) {
   575|                 for( final String aReference : refs ) {
   576|                     if( !m_engine.getManager( PageManager.class ).wikiPageExists( aReference ) ) {
   577|                         uncreated.add( aReference );
   578|                     }
   579|                 }
   580|             }
   581|         }
   582|         return uncreated;
   583|     }
   584|     /**
   585|      *  Searches for the given page in the given Map, and returns the set of references. This method also takes care of
   586|      *  English plural matching.
   587|      *
   588|      *  @param coll The Map to search in
   589|      *  @param pagename The name to find.
   590|      *  @return The references list.
   591|      */
   592|     private < T > Set< T > getReferenceList( final Map< String, Set< T > > coll, final String pagename ) {
   593|         Set< T > refs = coll.get( pagename );
   594|         if( m_matchEnglishPlurals ) {
   595|             final Set< T > refs2;
   596|             if( pagename.endsWith( "s" ) ) {
   597|                 refs2 = coll.get( pagename.substring( 0, pagename.length() - 1 ) );
   598|             } else {
   599|                 refs2 = coll.get( pagename + "s" );
   600|             }
   601|             if( refs2 != null ) {


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/render/CreoleRenderer.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 6-45 ---
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.render;
    18| import org.apache.wiki.api.core.Context;
    19| import org.apache.wiki.parser.PluginContent;
    20| import org.apache.wiki.parser.WikiDocument;
    21| import org.jdom2.Content;
    22| import org.jdom2.Element;
    23| import org.jdom2.Text;
    24| import java.util.ArrayList;
    25| import java.util.List;
    26| /**
    27|  *  Implements DOM-to-Creole rendering.
    28|  *  <p>
    29|  *  FIXME: This class is not yet completely done.
    30|  *
    31|  */
    32| public class CreoleRenderer extends WikiRenderer {
    33|     private static final String IMG_START = "{{";
    34|     private static final String IMG_END = "}}";
    35|     private static final String PLUGIN_START = "<<";
    36|     private static final String PLUGIN_END = ">>";
    37|     private static final String HREF_START = "[[";
    38|     private static final String HREF_DELIMITER = "|";
    39|     private static final String HREF_END = "]]";
    40|     private static final String PRE_START = "{{{";
    41|     private static final String PRE_END = "}}}";
    42|     private static final String PLUGIN_IMAGE = "Image";
    43|     private static final String PARAM_SRC = "src";
    44|     private static final String HREF_ATTRIBUTE = "href";
    45|     private static final String ONE_SPACE = " ";

# --- HUNK 2: Lines 76-117 ---
    76|     /**
    77|      * Renders an element into the StringBuilder given
    78|      * @param ce element to render
    79|      * @param sb stringbuilder holding the element render
    80|      */
    81|     private void renderElement( final Element ce, final StringBuilder sb ) {
    82|         String endEl = EMPTY_STRING;
    83|         for( int i = 0; i < ELEMENTS.length; i+=3 ) {
    84|             if( ELEMENTS[i].equals(ce.getName()) ) {
    85|                 sb.append( ELEMENTS[i+1] );
    86|                 endEl = ELEMENTS[i+2];
    87|             }
    88|         }
    89|         if( UL.equals(ce.getName()) ) {
    90|             m_listCount++;
    91|             m_listChar = '*';
    92|         } else if( OL.equals(ce.getName()) ) {
    93|             m_listCount++;
    94|             m_listChar = '#';
    95|         } else if( LI.equals(ce.getName()) ) {
    96|             for(int i = 0; i < m_listCount; i++ ) sb.append( m_listChar );
    97|             sb.append( ONE_SPACE );
    98|         } else if( A.equals( ce.getName() ) ) {
    99|             final String href = ce.getAttributeValue( HREF_ATTRIBUTE );
   100|             final String text = ce.getText();
   101|             if( href.equals( text ) ) {
   102|                 sb.append( HREF_START ).append( href ).append( HREF_END );
   103|             } else {
   104|                 sb.append( HREF_START ).append( href ).append( HREF_DELIMITER ).append( text ).append( HREF_END);
   105|             }
   106|             return;
   107|         } else if( PRE.equals( ce.getName() ) ) {
   108|             sb.append( PRE_START );
   109|             sb.append( ce.getText() );
   110|             sb.append( PRE_END );
   111|             return;
   112|         }
   113|         for( final Content c : ce.getContent() ) {
   114|             if( c instanceof PluginContent ) {
   115|                 final PluginContent pc = ( PluginContent )c;
   116|                 if( pc.getPluginName().equals( PLUGIN_IMAGE ) ) {
   117|                     sb.append( IMG_START ).append( pc.getParameter( PARAM_SRC ) ).append( IMG_END );


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/search/DefaultSearchManager.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 74-114 ---
    74|      *  Provides a JSON AJAX API to the JSPWiki Search Engine.
    75|      */
    76|     public class JSONSearch implements WikiAjaxServlet {
    77|         public static final String AJAX_ACTION_SUGGESTIONS = "suggestions";
    78|         public static final String AJAX_ACTION_PAGES = "pages";
    79|         public static final int DEFAULT_MAX_RESULTS = 20;
    80|         public int maxResults = DEFAULT_MAX_RESULTS;
    81|         /** {@inheritDoc} */
    82|         @Override
    83|         public String getServletMapping() {
    84|             return JSON_SEARCH;
    85|         }
    86|         /** {@inheritDoc} */
    87|         @Override
    88|         public void service( final HttpServletRequest req,
    89|                              final HttpServletResponse resp,
    90|                              final String actionName,
    91|                              final List< String > params ) throws IOException {
    92|             String result = "";
    93|             if( StringUtils.isNotBlank( actionName ) ) {
    94|                 if( params.size() < 1 ) {
    95|                     return;
    96|                 }
    97|                 final String itemId = params.get( 0 );
    98|                 LOG.debug( "itemId=" + itemId );
    99|                 if( params.size() > 1 ) {
   100|                     final String maxResultsParam = params.get( 1 );
   101|                     LOG.debug( "maxResultsParam=" + maxResultsParam );
   102|                     if( StringUtils.isNotBlank( maxResultsParam ) && StringUtils.isNumeric( maxResultsParam ) ) {
   103|                         maxResults = Integer.parseInt( maxResultsParam );
   104|                     }
   105|                 }
   106|                 if( actionName.equals( AJAX_ACTION_SUGGESTIONS ) ) {
   107|                     LOG.debug( "Calling getSuggestions() START" );
   108|                     final List< String > callResults = getSuggestions( itemId, maxResults );
   109|                     LOG.debug( "Calling getSuggestions() DONE. " + callResults.size() );
   110|                     result = AjaxUtil.toJson( callResults );
   111|                 } else if( actionName.equals( AJAX_ACTION_PAGES ) ) {
   112|                     LOG.debug("Calling findPages() START");
   113|                     final Context wikiContext = Wiki.context().create( m_engine, req, ContextEnum.PAGE_VIEW.getRequestContext() );
   114|                     final List< Map< String, Object > > callResults = findPages( itemId, maxResults, wikiContext );


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/search/LuceneSearchProvider.java
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 3-42 ---
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.    
    16|  */
    17| package org.apache.wiki.search;
    18| import org.apache.commons.lang3.StringUtils;
    19| import org.apache.logging.log4j.LogManager;
    20| import org.apache.logging.log4j.Logger;
    21| import org.apache.lucene.analysis.Analyzer;
    22| import org.apache.lucene.analysis.TokenStream;
    23| import org.apache.lucene.document.Document;
    24| import org.apache.lucene.document.Field;
    25| import org.apache.lucene.document.StringField;
    26| import org.apache.lucene.document.TextField;
    27| import org.apache.lucene.index.DirectoryReader;
    28| import org.apache.lucene.index.IndexReader;
    29| import org.apache.lucene.index.IndexWriter;
    30| import org.apache.lucene.index.IndexWriterConfig;
    31| import org.apache.lucene.index.IndexWriterConfig.OpenMode;
    32| import org.apache.lucene.index.Term;
    33| import org.apache.lucene.queryparser.classic.MultiFieldQueryParser;
    34| import org.apache.lucene.queryparser.classic.ParseException;
    35| import org.apache.lucene.queryparser.classic.QueryParser;
    36| import org.apache.lucene.search.IndexSearcher;
    37| import org.apache.lucene.search.Query;
    38| import org.apache.lucene.search.ScoreDoc;
    39| import org.apache.lucene.search.TermQuery;
    40| import org.apache.lucene.search.highlight.Highlighter;
    41| import org.apache.lucene.search.highlight.InvalidTokenOffsetsException;
    42| import org.apache.lucene.search.highlight.QueryScorer;

# --- HUNK 2: Lines 54-114 ---
    54| import org.apache.wiki.api.exceptions.NoRequiredPropertyException;
    55| import org.apache.wiki.api.exceptions.ProviderException;
    56| import org.apache.wiki.api.providers.PageProvider;
    57| import org.apache.wiki.api.providers.WikiProvider;
    58| import org.apache.wiki.api.search.SearchResult;
    59| import org.apache.wiki.api.spi.Wiki;
    60| import org.apache.wiki.attachment.AttachmentManager;
    61| import org.apache.wiki.auth.AuthorizationManager;
    62| import org.apache.wiki.auth.permissions.PagePermission;
    63| import org.apache.wiki.pages.PageManager;
    64| import org.apache.wiki.util.ClassUtil;
    65| import org.apache.wiki.util.FileUtil;
    66| import org.apache.wiki.util.TextUtil;
    67| import java.io.File;
    68| import java.io.IOException;
    69| import java.io.InputStream;
    70| import java.io.InputStreamReader;
    71| import java.io.StringReader;
    72| import java.io.StringWriter;
    73| import java.util.ArrayList;
    74| import java.util.Collection;
    75| import java.util.Collections;
    76| import java.util.Date;
    77| import java.util.List;
    78| import java.util.Properties;
    79| import java.util.concurrent.Executor;
    80| import java.util.concurrent.Executors;
    81| /**
    82|  * Interface for the search providers that handle searching the Wiki
    83|  *
    84|  * @since 2.2.21.
    85|  */
    86| public class LuceneSearchProvider implements SearchProvider {
    87|     protected static final Logger LOG = LogManager.getLogger( LuceneSearchProvider.class );
    88|     private Engine m_engine;
    89|     private Executor searchExecutor;
    90|     /** Which analyzer to use.  Default is StandardAnalyzer. */
    91|     public static final String PROP_LUCENE_ANALYZER      = "jspwiki.lucene.analyzer";
    92|     private static final String PROP_LUCENE_INDEXDELAY   = "jspwiki.lucene.indexdelay";
    93|     private static final String PROP_LUCENE_INITIALDELAY = "jspwiki.lucene.initialdelay";
    94|     private String m_analyzerClass = "org.apache.lucene.analysis.standard.ClassicAnalyzer";
    95|     private static final String LUCENE_DIR = "lucene";
    96|     /** These attachment file suffixes will be indexed. */
    97|     public static final String[] SEARCHABLE_FILE_SUFFIXES = new String[] { ".txt", ".ini", ".xml", ".html", "htm", ".mm", ".htm",
    98|                                                                            ".xhtml", ".java", ".c", ".cpp", ".php", ".asm", ".sh",
    99|                                                                            ".properties", ".kml", ".gpx", ".loc", ".md", ".xml" };
   100|     protected static final String LUCENE_ID            = "id";
   101|     protected static final String LUCENE_PAGE_CONTENTS = "contents";
   102|     protected static final String LUCENE_AUTHOR        = "author";
   103|     protected static final String LUCENE_ATTACHMENTS   = "attachment";
   104|     protected static final String LUCENE_PAGE_NAME     = "name";
   105|     protected static final String LUCENE_PAGE_KEYWORDS = "keywords";
   106|     private String m_luceneDirectory;
   107|     protected final List< Object[] > m_updates = Collections.synchronizedList( new ArrayList<>() );
   108|     /** Maximum number of fragments from search matches. */
   109|     private static final int MAX_FRAGMENTS = 3;
   110|     /** The maximum number of hits to return from searches. */
   111|     public static final int MAX_SEARCH_HITS = 99_999;
   112|     private static final String PUNCTUATION_TO_SPACES = StringUtils.repeat( " ", TextUtil.PUNCTUATION_CHARS_ALLOWED.length() );
   113|     /** {@inheritDoc} */
   114|     @Override

# --- HUNK 3: Lines 215-261 ---
   215|         final AttachmentManager mgr = m_engine.getManager( AttachmentManager.class );
   216|         try {
   217|             final Attachment att = mgr.getAttachmentInfo( attachmentName, version );
   218|             if( att != null ) {
   219|                 return getAttachmentContent( att );
   220|             }
   221|         } catch( final ProviderException e ) {
   222|             LOG.error( "Attachment cannot be loaded", e );
   223|         }
   224|         return null;
   225|     }
   226|     /**
   227|      * @param att Attachment to get content for. Filename extension is used to determine the type of the attachment.
   228|      * @return String representing the content of the file.
   229|      * FIXME This is a very simple implementation of some text-based attachment, mainly used for testing.
   230|      * This should be replaced /moved to Attachment search providers or some other 'pluggable' way to search attachments
   231|      */
   232|     protected String getAttachmentContent( final Attachment att ) {
   233|         final AttachmentManager mgr = m_engine.getManager( AttachmentManager.class );
   234|         final String filename = att.getFileName();
   235|         boolean searchSuffix = false;
   236|         for( final String suffix : SEARCHABLE_FILE_SUFFIXES ) {
   237|             if( filename.endsWith( suffix ) ) {
   238|                 searchSuffix = true;
   239|                 break;
   240|             }
   241|         }
   242|         String out = filename;
   243|         if( searchSuffix ) {
   244|             try( final InputStream attStream = mgr.getAttachmentStream( att ); final StringWriter sout = new StringWriter() ) {
   245|                 FileUtil.copyContents( new InputStreamReader( attStream ), sout );
   246|                 out = out + " " + sout;
   247|             } catch( final ProviderException | IOException e ) {
   248|                 LOG.error( "Attachment cannot be loaded", e );
   249|             }
   250|         }
   251|         return out;
   252|     }
   253|     /**
   254|      * Updates the lucene index for a single page.
   255|      *
   256|      * @param page The WikiPage to check
   257|      * @param text The page text to index.
   258|      */
   259|     protected synchronized void updateLuceneIndex( final Page page, final String text ) {
   260|         LOG.debug( "Updating Lucene index for page '{}'...", page.getName() );
   261|         pageRemoved( page );

# --- HUNK 4: Lines 290-334 ---
   290|     protected Document luceneIndexPage( final Page page, final String text, final IndexWriter writer ) throws IOException {
   291|         LOG.debug( "Indexing {}...", page.getName() );
   292|         final Document doc = new Document();
   293|         if( text == null ) {
   294|             return doc;
   295|         }
   296|         final String indexedText = text.replace( "__", " " ); // be nice to Language Analyzers - cfr. JSPWIKI-893
   297|         Field field = new Field( LUCENE_ID, page.getName(), StringField.TYPE_STORED );
   298|         doc.add( field );
   299|         field = new Field( LUCENE_PAGE_CONTENTS, indexedText, TextField.TYPE_STORED );
   300|         doc.add( field );
   301|         final String unTokenizedTitle = StringUtils.replaceChars( page.getName(), TextUtil.PUNCTUATION_CHARS_ALLOWED, PUNCTUATION_TO_SPACES );
   302|         field = new Field( LUCENE_PAGE_NAME, TextUtil.beautifyString( page.getName() ) + " " + unTokenizedTitle, TextField.TYPE_STORED );
   303|         doc.add( field );
   304|         if( page.getAuthor() != null ) {
   305|             field = new Field( LUCENE_AUTHOR, page.getAuthor(), TextField.TYPE_STORED );
   306|             doc.add( field );
   307|         }
   308|         try {
   309|             final List< Attachment > attachments = m_engine.getManager( AttachmentManager.class ).listAttachments( page );
   310|             final StringBuilder attachmentNames = new StringBuilder();
   311|             for( final Attachment att : attachments ) {
   312|                 attachmentNames.append( att.getName() ).append( ";" );
   313|             }
   314|             field = new Field( LUCENE_ATTACHMENTS, attachmentNames.toString(), TextField.TYPE_STORED );
   315|             doc.add( field );
   316|         } catch( final ProviderException e ) {
   317|             LOG.error( "Failed to get attachments for page", e );
   318|         }
   319|         if( page.getAttribute( "keywords" ) != null ) {
   320|             field = new Field( LUCENE_PAGE_KEYWORDS, page.getAttribute( "keywords" ).toString(), TextField.TYPE_STORED );
   321|             doc.add( field );
   322|         }
   323|         synchronized( writer ) {
   324|             writer.addDocument( doc );
   325|         }
   326|         return doc;
   327|     }
   328|     /**
   329|      * {@inheritDoc}
   330|      */
   331|     @Override
   332|     public synchronized void pageRemoved( final Page page ) {
   333|         try( final Directory luceneDir = new NIOFSDirectory( new File( m_luceneDirectory ).toPath() );
   334|              final IndexWriter writer = getIndexWriter( luceneDir ) ) {


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/tags/AdminBeanIteratorTag.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 3-56 ---
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.  
    16|  */
    17| package org.apache.wiki.tags;
    18| import org.apache.wiki.api.core.Context;
    19| import org.apache.wiki.ui.admin.AdminBean;
    20| import org.apache.wiki.ui.admin.AdminBeanManager;
    21| import java.util.ArrayList;
    22| import java.util.Collection;
    23| /**
    24|  *  Provides an iterator for all AdminBeans of a given type.
    25|  *
    26|  */
    27| public class AdminBeanIteratorTag extends IteratorTag {
    28|     private static final long serialVersionUID = 1L;
    29|     private int m_type;
    30|     /**
    31|      *  Set the type of the bean.
    32|      *  
    33|      *  @param type Type to set
    34|      */
    35|     public void setType( final String type ) {
    36|     	if (m_wikiContext == null) {
    37|     		m_wikiContext = Context.findContext(pageContext);
    38|     	}
    39|         m_type = m_wikiContext.getEngine().getManager( AdminBeanManager.class ).getTypeFromString( type );
    40|     }
    41|     /**
    42|      *  {@inheritDoc}
    43|      */
    44|     @Override
    45|     public void resetIterator() {
    46|         final AdminBeanManager mgr = m_wikiContext.getEngine().getManager( AdminBeanManager.class );
    47|         final Collection< AdminBean > beans = mgr.getAllBeans();
    48|         final ArrayList< AdminBean > typedBeans = new ArrayList<>();
    49|         for( final AdminBean ab : beans ) {
    50|             if( ab.getType() == m_type ) {
    51|                 typedBeans.add( ab );
    52|             }
    53|         }
    54|         setList( typedBeans );
    55|     }
    56| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/tags/EditorIteratorTag.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 3-45 ---
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.  
    16|  */
    17| package org.apache.wiki.tags;
    18| import org.apache.wiki.api.core.Context;
    19| import org.apache.wiki.api.core.Engine;
    20| import org.apache.wiki.ui.Editor;
    21| import org.apache.wiki.ui.EditorManager;
    22| import java.util.ArrayList;
    23| import java.util.Collection;
    24| /**
    25|  *  Iterates through editors.
    26|  *
    27|  *  @since 2.4.12
    28|  */
    29| public class EditorIteratorTag extends IteratorTag  {
    30|     private static final long serialVersionUID = 0L;
    31|     /** {@inheritDoc} */
    32|     @Override
    33|     public final int doStartTag() {
    34|         m_wikiContext = Context.findContext(pageContext);
    35|         final Engine engine = m_wikiContext.getEngine();
    36|         final EditorManager mgr = engine.getManager( EditorManager.class );
    37|         final String[] editorList = mgr.getEditorList();
    38|         final Collection< Editor > editors = new ArrayList<>();
    39|         for( final String editor : editorList ) {
    40|             editors.add( new Editor( m_wikiContext, editor ) );
    41|         }
    42|         setList( editors );
    43|         return super.doStartTag();
    44|     }
    45| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/tags/TabTag.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-176 ---
     1| /* 
     2|     Licensed to the Apache Software Foundation (ASF) under one
     3|     or more contributor license agreements.  See the NOTICE file
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.  
    16|  */
    17| package org.apache.wiki.tags;
    18| import java.io.IOException;
    19| import javax.servlet.jsp.JspTagException;
    20| import org.apache.wiki.util.TextUtil;
    21| /**
    22|  *  Generates single tabbed page layout.
    23|  *  Works together with the tabbedSection javascript.  Note that if you do not
    24|  *  specify an url, the body contents of the tag are loaded by the tag itself.
    25|  *
    26|  *  <P><B>Attributes</B></P>
    27|  *  <UL>
    28|  *    <LI>id - ID for this tab. (mandatory)
    29|  *    <LI>title - Title of this tab. (mandatory)
    30|  *    <LI>accesskey - Single char usable as quick accesskey (alt- or ctrl-) (optional)
    31|  *    <li>url - If you <i>don't</i> want to create a Javascript-enabled tag, you can use this
    32|  *              to make the tab look just the usual tag, but instead, it will actually link
    33|  *              to that page.  This can be useful in certain cases where you have something
    34|  *              that you want to look like a part of a tag, but for example, due to it being
    35|  *              very big in size, don't want to include it as a part of the page content
    36|  *              every time.
    37|  *  </UL>
    38|  *
    39|  *  @since v2.3.63
    40|  */
    41| public class TabTag extends WikiTagBase
    42| {
    43|     private static final long serialVersionUID = -8534125226484616489L;
    44|     private String m_accesskey;
    45|     private String m_tabTitle;
    46|     private String m_url;
    47|     /**
    48|      * {@inheritDoc}
    49|      */
    50|     @Override
    51|     public void doFinally()
    52|     {
    53|         super.doFinally();
    54|         m_accesskey = null;
    55|         m_tabTitle  = null;
    56|         m_url       = null;
    57|     }
    58|     /**
    59|      * Sets the tab title.
    60|      * @param aTabTitle the tab title
    61|      */
    62|     public void setTitle(final String aTabTitle)
    63|     {
    64|         m_tabTitle = TextUtil.replaceEntities( aTabTitle );
    65|     }
    66|     /**
    67|      * Sets the tab access key.
    68|      * @param anAccesskey the access key
    69|      */
    70|     public void setAccesskey(final String anAccesskey)
    71|     {
    72|         m_accesskey = TextUtil.replaceEntities( anAccesskey ); //take only the first char
    73|     }
    74|     /**
    75|      * Sets the tab URL.
    76|      * @param url the URL
    77|      */
    78|     public void setUrl(final String url )
    79|     {
    80|         m_url = TextUtil.replaceEntities( url );
    81|     }
    82|     private boolean handleAccesskey()
    83|     {
    84|         if( (m_tabTitle == null) || (m_accesskey == null) ) return false;
    85|         final int pos = m_tabTitle.toLowerCase().indexOf( m_accesskey.toLowerCase() );
    86|         if( pos > -1 )
    87|         {
    88|             m_tabTitle = m_tabTitle.substring( 0, pos ) + "<span class='accesskey'>"
    89|                        + m_tabTitle.charAt( pos ) + "</span>" + m_tabTitle.substring( pos+1 );
    90|         }
    91|         return true;
    92|     }
    93|     /**
    94|      * {@inheritDoc}
    95|      */
    96|     @Override
    97|     public int doWikiStartTag() throws JspTagException
    98|     {
    99|         final TabbedSectionTag parent=(TabbedSectionTag)findAncestorWithClass( this, TabbedSectionTag.class );
   100|         if( getId() == null )
   101|         {
   102|             throw new JspTagException("Tab Tag without \"id\" attribute");
   103|         }
   104|         if( m_tabTitle == null )
   105|         {
   106|             throw new JspTagException("Tab Tag without \"tabTitle\" attribute");
   107|         }
   108|         if( parent == null )
   109|         {
   110|             throw new JspTagException("Tab Tag without parent \"TabbedSection\" Tag");
   111|         }
   112|         if( !parent.isStateGenerateTabBody() ) return SKIP_BODY;
   113|         final StringBuilder sb = new StringBuilder(32);
   114|         sb.append( "<div id=\"" ).append( getId() ).append( "\"" );
   115|         if( !parent.validateDefaultTab( getId()) )
   116|         {
   117|             sb.append( " class=\"hidetab\"" );
   118|         }
   119|         sb.append( " >\n" );
   120|         try
   121|         {
   122|             pageContext.getOut().write( sb.toString() );
   123|         }
   124|         catch( final java.io.IOException e )
   125|         {
   126|             throw new JspTagException( "IO Error: " + e.getMessage() );
   127|         }
   128|         return EVAL_BODY_INCLUDE;
   129|     }
   130|     /**
   131|      * {@inheritDoc}
   132|      */
   133|     @Override
   134|     public int doEndTag() throws JspTagException
   135|     {
   136|         final TabbedSectionTag parent=(TabbedSectionTag)findAncestorWithClass( this, TabbedSectionTag.class );
   137|         final StringBuilder sb = new StringBuilder();
   138|         if( parent.isStateFindDefaultTab() )
   139|         {
   140|             parent.validateDefaultTab( getId() );
   141|         }
   142|         else if( parent.isStateGenerateTabBody() )
   143|         {
   144|             sb.append( "</div>\n" );
   145|         }
   146|         else if( parent.isStateGenerateTabMenu() )
   147|         {
   148|             sb.append( "<a" );
   149|             if( parent.validateDefaultTab( getId() ) )
   150|             {
   151|                 sb.append( " class=\"activetab\"" );
   152|             }
   153|             sb.append( " id=\"menu-" ).append( getId() ).append( "\"" );
   154|             if( m_url != null )
   155|             {
   156|                 sb.append( " href='" ).append( m_url ).append( "'" );
   157|             }
   158|             if( handleAccesskey() )
   159|             {
   160|                 sb.append( " accesskey=\"" ).append( m_accesskey ).append( "\"" );
   161|             }
   162|             sb.append( " >" );
   163|             sb.append( m_tabTitle );
   164|             sb.append( "</a>" );
   165|         }
   166|         try
   167|         {
   168|             pageContext.getOut().write( sb.toString() );
   169|         }
   170|         catch( final IOException e )
   171|         {
   172|             throw new JspTagException( "IO Error: " + e.getMessage() );
   173|         }
   174|         return EVAL_PAGE;
   175|     }
   176| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/tags/UserProfileTag.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 14-55 ---
    14|     specific language governing permissions and limitations
    15|     under the License.  
    16|  */
    17| package org.apache.wiki.tags;
    18| import org.apache.wiki.api.core.Context;
    19| import org.apache.wiki.api.core.Engine;
    20| import org.apache.wiki.api.core.Session;
    21| import org.apache.wiki.api.spi.Wiki;
    22| import org.apache.wiki.auth.AuthenticationManager;
    23| import org.apache.wiki.auth.GroupPrincipal;
    24| import org.apache.wiki.auth.UserManager;
    25| import org.apache.wiki.auth.authorize.Role;
    26| import org.apache.wiki.auth.user.UserProfile;
    27| import org.apache.wiki.i18n.InternationalizationManager;
    28| import org.apache.wiki.preferences.Preferences;
    29| import org.apache.wiki.util.TextUtil;
    30| import javax.servlet.http.HttpServletRequest;
    31| import java.io.IOException;
    32| import java.security.Principal;
    33| import java.util.ArrayList;
    34| import java.util.List;
    35| import java.util.ResourceBundle;
    36| /**
    37|  * <p>
    38|  * Returns user profile attributes, or empty strings if the user has not been
    39|  * validated. This tag has a single attribute, "property."
    40|  * The <code>property</code> attribute may contain one of the following
    41|  * case-insensitive values:
    42|  * </p>
    43|  * <ul>
    44|  * <li><code>created</code> - creation date</li>
    45|  * <li><code>email</code> - user's e-mail address</li>
    46|  * <li><code>fullname</code> - user's full name</li>
    47|  * <li><code>groups</code> - a sorted list of the groups a user belongs to</li>
    48|  * <li><code>loginname</code> - user's login name. If the current user does not have a profile, the user's login principal (such as one
    49|  * provided by a container login module, user cookie, or anonyous IP address), will supply the login name property</li>
    50|  * <li><code>roles</code> - a sorted list of the roles a user possesses</li>
    51|  * <li><code>wikiname</code> - user's wiki name</li>
    52|  * <li><code>modified</code> - last modification date</li>
    53|  * <li><code>exists</code> - evaluates the body of the tag if user's profile exists in the user database</li>
    54|  * <li><code>new</code> - evaluates the body of the tag if user's profile does not exist in the user database</li>
    55|  * <li><code>canChangeLoginName</code> - always true if custom auth used; also true for container auth and current

# --- HUNK 2: Lines 133-204 ---
   133|             }
   134|         }
   135|         if( result != null ) {
   136|             pageContext.getOut().print( TextUtil.replaceEntities( result ) );
   137|         }
   138|         return SKIP_BODY;
   139|     }
   140|     public void setProperty( final String property )
   141|     {
   142|         m_prop = property.toLowerCase().trim();
   143|     }
   144|     /**
   145|      * Returns a sorted list of the {@link org.apache.wiki.auth.authorize.Group} objects a user possesses
   146|      * in his or her Session. The result is computed by consulting
   147|      * {@link org.apache.wiki.api.core.Session#getRoles()}
   148|      * and extracting those that are of type Group.
   149|      * @return the list of groups, sorted by name
   150|      */
   151|     public static String printGroups( final Context context ) {
   152|         final Principal[] roles = context.getWikiSession().getRoles();
   153|         final List< String > tempRoles = new ArrayList<>();
   154|         final ResourceBundle rb = Preferences.getBundle( context, InternationalizationManager.CORE_BUNDLE );
   155|         for( final Principal role : roles ) {
   156|             if( role instanceof GroupPrincipal ) {
   157|                 tempRoles.add( role.getName() );
   158|             }
   159|         }
   160|         if( tempRoles.size() == 0 ) {
   161|             return rb.getString( "userprofile.nogroups" );
   162|         }
   163|         final StringBuilder sb = new StringBuilder();
   164|         for( int i = 0; i < tempRoles.size(); i++ ) {
   165|             final String name = tempRoles.get( i );
   166|             sb.append( name );
   167|             if( i < ( tempRoles.size() - 1 ) ) {
   168|                 sb.append( ',' );
   169|                 sb.append( ' ' );
   170|             }
   171|         }
   172|         return sb.toString();
   173|     }
   174|     /**
   175|      * Returns a sorted list of the {@link org.apache.wiki.auth.authorize.Role} objects a user possesses
   176|      * in his or her Session. The result is computed by consulting
   177|      * {@link org.apache.wiki.api.core.Session#getRoles()}
   178|      * and extracting those that are of type Role.
   179|      * @return the list of roles, sorted by name
   180|      */
   181|     public static String printRoles( final Context context ) {
   182|         final Principal[] roles = context.getWikiSession().getRoles();
   183|         final List< String > tempRoles = new ArrayList<>();
   184|         final ResourceBundle rb = Preferences.getBundle( context, InternationalizationManager.CORE_BUNDLE );
   185|         for( final Principal role : roles ) {
   186|             if( role instanceof Role ) {
   187|                 tempRoles.add( role.getName() );
   188|             }
   189|         }
   190|         if( tempRoles.size() == 0 ) {
   191|             return rb.getString( "userprofile.noroles" );
   192|         }
   193|         final StringBuilder sb = new StringBuilder();
   194|         for( int i = 0; i < tempRoles.size(); i++ ) {
   195|             final String name = tempRoles.get( i );
   196|             sb.append( name );
   197|             if( i < ( tempRoles.size() - 1 ) ) {
   198|                 sb.append( ',' );
   199|                 sb.append( ' ' );
   200|             }
   201|         }
   202|         return sb.toString();
   203|     }
   204| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/tasks/auth/SaveUserProfileTask.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-20 ---
     1| package org.apache.wiki.tasks.auth;
     2| import org.apache.logging.log4j.LogManager;
     3| import org.apache.logging.log4j.Logger;
     4| import org.apache.wiki.api.core.Context;
     5| import org.apache.wiki.api.core.ContextEnum;
     6| import org.apache.wiki.api.exceptions.WikiException;
     7| import org.apache.wiki.auth.UserManager;
     8| import org.apache.wiki.auth.user.UserProfile;
     9| import org.apache.wiki.i18n.InternationalizationManager;
    10| import org.apache.wiki.tasks.TasksManager;
    11| import org.apache.wiki.util.MailUtil;
    12| import org.apache.wiki.workflow.Outcome;
    13| import org.apache.wiki.workflow.Task;
    14| import org.apache.wiki.workflow.WorkflowManager;
    15| import javax.mail.MessagingException;
    16| import javax.mail.internet.AddressException;
    17| import java.util.Locale;
    18| /**
    19|  * Handles the actual profile save action. 
    20|  */


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/ui/Installer.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 24-63 ---
    24| import org.apache.wiki.auth.WikiPrincipal;
    25| import org.apache.wiki.auth.WikiSecurityException;
    26| import org.apache.wiki.auth.authorize.Group;
    27| import org.apache.wiki.auth.authorize.GroupManager;
    28| import org.apache.wiki.auth.user.UserDatabase;
    29| import org.apache.wiki.auth.user.UserProfile;
    30| import org.apache.wiki.i18n.InternationalizationManager;
    31| import org.apache.wiki.pages.PageManager;
    32| import org.apache.wiki.providers.FileSystemProvider;
    33| import org.apache.wiki.util.TextUtil;
    34| import javax.servlet.ServletConfig;
    35| import javax.servlet.http.HttpServletRequest;
    36| import java.io.File;
    37| import java.io.IOException;
    38| import java.io.OutputStream;
    39| import java.nio.file.Files;
    40| import java.text.MessageFormat;
    41| import java.util.Properties;
    42| import java.util.ResourceBundle;
    43| import java.util.Set;
    44| /**
    45|  * Manages JSPWiki installation on behalf of <code>admin/Install.jsp</code>. The contents of this class were previously part of
    46|  * <code>Install.jsp</code>.
    47|  *
    48|  * @since 2.4.20
    49|  */
    50| public class Installer {
    51|     public static final String ADMIN_ID = "admin";
    52|     public static final String ADMIN_NAME = "Administrator";
    53|     public static final String INSTALL_INFO = "Installer.Info";
    54|     public static final String INSTALL_ERROR = "Installer.Error";
    55|     public static final String INSTALL_WARNING = "Installer.Warning";
    56|     public static final String APP_NAME = Engine.PROP_APPNAME;
    57|     public static final String STORAGE_DIR = AttachmentProvider.PROP_STORAGEDIR;
    58|     public static final String PAGE_DIR = FileSystemProvider.PROP_PAGEDIR;
    59|     public static final String WORK_DIR = Engine.PROP_WORKDIR;
    60|     public static final String ADMIN_GROUP = "Admin";
    61|     public static final String PROPFILENAME = "jspwiki-custom.properties" ;
    62|     public static final String TMP_DIR = System.getProperty("java.io.tmpdir");
    63|     private final Session m_session;

# --- HUNK 2: Lines 113-158 ---
   113|             profile.setFullname( ADMIN_NAME );
   114|             profile.setPassword( password );
   115|             userDb.save( profile );
   116|         }
   117|         final GroupManager groupMgr = m_engine.getManager( GroupManager.class );
   118|         Group group;
   119|         try {
   120|             group = groupMgr.getGroup( ADMIN_GROUP );
   121|             group.add( new WikiPrincipal( ADMIN_NAME ) );
   122|         } catch( final NoSuchPrincipalException e ) {
   123|             group = groupMgr.parseGroup( ADMIN_GROUP, ADMIN_NAME, true );
   124|         }
   125|         groupMgr.setGroup( m_session, group );
   126|         return password;
   127|     }
   128|     /**
   129|      * Returns the properties as a "key=value" string separated by newlines
   130|      * @return the string
   131|      */
   132|     public String getPropertiesList() {
   133|         final StringBuilder result = new StringBuilder();
   134|         final Set< String > keys = m_props.stringPropertyNames();
   135|         for( final String key : keys ) {
   136|             result.append(key ).append( " = " ).append( m_props.getProperty( key ) ).append( "\n" );
   137|         }
   138|         return result.toString();
   139|     }
   140|     public String getPropertiesPath() {
   141|         return m_propertyFile.getAbsolutePath();
   142|     }
   143|     /**
   144|      * Returns a property from the Engine's properties.
   145|      * @param key the property key
   146|      * @return the property value
   147|      */
   148|     public String getProperty( final String key ) {
   149|         return m_props.getProperty( key );
   150|     }
   151|     public void parseProperties () {
   152|         final ResourceBundle rb = ResourceBundle.getBundle( InternationalizationManager.CORE_BUNDLE, m_session.getLocale() );
   153|         m_validated = false;
   154|         String nullValue = m_props.getProperty( APP_NAME, rb.getString( "install.installer.default.appname" ) );
   155|         parseProperty( APP_NAME, nullValue );
   156|         nullValue = m_props.getProperty( PAGE_DIR, rb.getString( "install.installer.default.pagedir" ) );
   157|         parseProperty( PAGE_DIR, nullValue );
   158|         sanitizePath( PAGE_DIR );


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/ui/WikiRequestWrapper.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 5-44 ---
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.    
    16|  */
    17| package org.apache.wiki.ui;
    18| import org.apache.wiki.api.core.Engine;
    19| import org.apache.wiki.api.core.Session;
    20| import org.apache.wiki.auth.SessionMonitor;
    21| import org.apache.wiki.auth.authorize.Role;
    22| import javax.servlet.http.HttpServletRequest;
    23| import javax.servlet.http.HttpServletRequestWrapper;
    24| import java.security.Principal;
    25| /**
    26|  * Servlet request wrapper that encapsulates an incoming HTTP request and overrides its security methods so that the request returns
    27|  * JSPWiki-specific values.
    28|  * 
    29|  * @since 2.8
    30|  */
    31| public class WikiRequestWrapper extends HttpServletRequestWrapper {
    32|     private final Session m_session;
    33|     /**
    34|      * Constructs a new wrapped request.
    35|      * 
    36|      * @param engine the wiki engine
    37|      * @param request the request to wrap
    38|      */
    39|     public WikiRequestWrapper( final Engine engine, final HttpServletRequest request ) {
    40|         super( request );
    41|         m_session = SessionMonitor.getInstance( engine ).find( request.getSession() );
    42|     }
    43|     /**
    44|      * Returns the remote user for the HTTP request, taking into account both container and JSPWiki custom authentication status.

# --- HUNK 2: Lines 68-98 ---
    68|             return super.getUserPrincipal();
    69|         }
    70|         if( m_session.isAuthenticated() ) {
    71|             return m_session.getLoginPrincipal();
    72|         }
    73|         return null;
    74|     }
    75|     /**
    76|      * Determines whether the current user possesses a supplied role, taking into account both container and JSPWIki custom authentication
    77|      * status. Specifically, if the wrapped request shows that the user possesses the role, this method returns <code>true</code>. If not,
    78|      * this method iterates through the built-in Role objects (<em>e.g.</em>, ANONYMOUS, ASSERTED, AUTHENTICATED) returned by
    79|      * {@link Session#getRoles()} and checks to see if any of these principals' names match the supplied role.
    80|      */
    81|     @Override
    82|     public boolean isUserInRole( final String role ) {
    83|         final boolean hasContainerRole = super.isUserInRole(role);
    84|         if( hasContainerRole ) {
    85|             return true;
    86|         }
    87|         final Principal[] principals = m_session.getRoles();
    88|         for( final Principal value : principals ) {
    89|             if( value instanceof Role ) {
    90|                 final Role principal = ( Role )value;
    91|                 if( Role.isBuiltInRole( principal ) && principal.getName().equals( role ) ) {
    92|                     return true;
    93|                 }
    94|             }
    95|         }
    96|         return false;
    97|     }
    98| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/ui/admin/DefaultAdminBeanManager.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 144-189 ---
   144|         }
   145|         for( final ModuleManager moduleManager : m_engine.getManagers( ModuleManager.class ) ) {
   146|             registerBeans( moduleManager.modules() );
   147|         }
   148|     }
   149|     /* (non-Javadoc)
   150| 	 * @see org.apache.wiki.ui.admin.AdminBeanManager#getAllBeans()
   151| 	 */
   152|     @Override
   153| 	public List< AdminBean > getAllBeans() {
   154|         if( m_allBeans == null ) {
   155|         	reload();
   156|         }
   157|         return m_allBeans;
   158|     }
   159|     /* (non-Javadoc)
   160| 	 * @see org.apache.wiki.ui.admin.AdminBeanManager#findBean(java.lang.String)
   161| 	 */
   162|     @Override
   163| 	public AdminBean findBean( final String id ) {
   164|         for( final AdminBean ab : m_allBeans ) {
   165|             if( ab.getId().equals( id ) ) {
   166|                 return ab;
   167|             }
   168|         }
   169|         return null;
   170|     }
   171|     /**
   172|      *  Provides a JDK 1.5-compliant version of the MBeanServerFactory. This will simply bind to the
   173|      *  platform MBeanServer.
   174|      */
   175|     private static final class MBeanServerFactory15 {
   176|         private MBeanServerFactory15()
   177|         {}
   178|         public static MBeanServer getServer() {
   179|             return ManagementFactory.getPlatformMBeanServer();
   180|         }
   181|     }
   182|     /**
   183|      *  Returns the type identifier for a string type.
   184|      *
   185|      *  @param type A type string.
   186|      *  @return A type value.
   187|      */
   188|     @Override
   189| 	public int getTypeFromString( final String type ) {


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/ui/progress/DefaultProgressManager.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 100-136 ---
   100|         /**
   101|          *  Returns upload progress in percents so far.
   102|          *
   103|          *  @param progressId The string representation of the progress ID that you want to know the progress of.
   104|          *  @return a value between 0 to 100 indicating the progress
   105|          */
   106|         public int getProgress( final String progressId )
   107|         {
   108|             return DefaultProgressManager.this.getProgress( progressId );
   109|         }
   110|         @Override
   111|         public String getServletMapping() {
   112|         	return JSON_PROGRESSTRACKER;
   113|         }
   114|         @Override
   115|         public void service( final HttpServletRequest req,
   116|                              final HttpServletResponse resp,
   117|                              final String actionName,
   118|                              final List< String > params ) throws IOException {
   119|         	LOG.debug( "ProgressManager.doGet() START" );
   120|         	if( params.size() < 1 ) {
   121|         		return;
   122|         	}
   123|         	final String progressId = params.get(0);
   124|         	LOG.debug( "progressId=" + progressId );
   125|         	String progressString = "";
   126|         	try {
   127|         		progressString = Integer.toString( getProgress( progressId ) );
   128|         	} catch( final IllegalArgumentException e ) { // ignore
   129|         		LOG.debug( "progressId " + progressId + " is no longer valid" );
   130|         	}
   131|         	LOG.debug( "progressString=" + progressString );
   132|         	resp.getWriter().write( progressString );
   133|         	LOG.debug( "ProgressManager.doGet() DONE" );
   134|         }
   135|     }
   136| }


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/variables/DefaultVariableManager.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 21-60 ---
    21| import org.apache.wiki.api.core.Context;
    22| import org.apache.wiki.api.core.Page;
    23| import org.apache.wiki.api.core.Session;
    24| import org.apache.wiki.api.exceptions.NoSuchVariableException;
    25| import org.apache.wiki.api.filters.PageFilter;
    26| import org.apache.wiki.api.providers.WikiProvider;
    27| import org.apache.wiki.attachment.AttachmentManager;
    28| import org.apache.wiki.filters.FilterManager;
    29| import org.apache.wiki.i18n.InternationalizationManager;
    30| import org.apache.wiki.modules.InternalModule;
    31| import org.apache.wiki.pages.PageManager;
    32| import org.apache.wiki.preferences.Preferences;
    33| import javax.servlet.http.HttpServletRequest;
    34| import javax.servlet.http.HttpSession;
    35| import java.lang.reflect.Method;
    36| import java.security.Principal;
    37| import java.util.Date;
    38| import java.util.List;
    39| import java.util.Properties;
    40| import java.util.ResourceBundle;
    41| /**
    42|  *  Manages variables.  Variables are case-insensitive.  A list of all available variables is on a Wiki page called "WikiVariables".
    43|  *
    44|  *  @since 1.9.20.
    45|  */
    46| public class DefaultVariableManager implements VariableManager {
    47|     private static final Logger LOG = LogManager.getLogger( DefaultVariableManager.class );
    48|     /**
    49|      *  Contains a list of those properties that shall never be shown. Put names here in lower case.
    50|      */
    51|     static final String[] THE_BIG_NO_NO_LIST = {
    52|         "jspwiki.auth.masterpassword"
    53|     };
    54|     /**
    55|      *  Creates a VariableManager object using the property list given.
    56|      *  @param props The properties.
    57|      */
    58|     public DefaultVariableManager( final Properties props ) {
    59|     }
    60|     /**

# --- HUNK 2: Lines 229-288 ---
   229|             return m_context.getEngine().getContentEncoding().displayName();
   230|         }
   231|         public String getTotalpages() {
   232|             return Integer.toString( m_context.getEngine().getManager( PageManager.class ).getTotalPageCount() );
   233|         }
   234|         public String getPageprovider() {
   235|             return m_context.getEngine().getManager( PageManager.class ).getCurrentProvider();
   236|         }
   237|         public String getPageproviderdescription() {
   238|             return m_context.getEngine().getManager( PageManager.class ).getProviderDescription();
   239|         }
   240|         public String getAttachmentprovider() {
   241|             final WikiProvider p = m_context.getEngine().getManager( AttachmentManager.class ).getCurrentProvider();
   242|             return (p != null) ? p.getClass().getName() : "-";
   243|         }
   244|         public String getAttachmentproviderdescription() {
   245|             final WikiProvider p = m_context.getEngine().getManager( AttachmentManager.class ).getCurrentProvider();
   246|             return (p != null) ? p.getProviderInfo() : "-";
   247|         }
   248|         public String getInterwikilinks() {
   249|             final StringBuilder res = new StringBuilder();
   250|             for( final String link : m_context.getEngine().getAllInterWikiLinks() ) {
   251|                 if( res.length() > 0 ) {
   252|                     res.append( ", " );
   253|                 }
   254|                 res.append( link );
   255|                 res.append( " --> " );
   256|                 res.append( m_context.getEngine().getInterWikiURL( link ) );
   257|             }
   258|             return res.toString();
   259|         }
   260|         public String getInlinedimages() {
   261|             final StringBuilder res = new StringBuilder();
   262|             for( final String ptrn : m_context.getEngine().getAllInlinedImagePatterns() ) {
   263|                 if( res.length() > 0 ) {
   264|                     res.append( ", " );
   265|                 }
   266|                 res.append( ptrn );
   267|             }
   268|             return res.toString();
   269|         }
   270|         public String getPluginpath() {
   271|             final String s = m_context.getEngine().getPluginSearchPath();
   272|             return ( s == null ) ? "-" : s;
   273|         }
   274|         public String getBaseurl()
   275|         {
   276|             return m_context.getEngine().getBaseURL();
   277|         }
   278|         public String getUptime() {
   279|             final Date now = new Date();
   280|             long secondsRunning = ( now.getTime() - m_context.getEngine().getStartTime().getTime() ) / 1_000L;
   281|             final long seconds = secondsRunning % 60;
   282|             final long minutes = (secondsRunning /= 60) % 60;
   283|             final long hours = (secondsRunning /= 60) % 24;
   284|             final long days = secondsRunning /= 24;
   285|             return days + "d, " + hours + "h " + minutes + "m " + seconds + "s";
   286|         }
   287|         public String getLoginstatus() {
   288|             final Session session = m_context.getWikiSession();


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/workflow/DefaultWorkflowManager.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 24-64 ---
    24| import org.apache.wiki.api.core.Session;
    25| import org.apache.wiki.api.exceptions.WikiException;
    26| import org.apache.wiki.auth.AuthorizationManager;
    27| import org.apache.wiki.auth.acl.UnresolvedPrincipal;
    28| import org.apache.wiki.event.WikiEvent;
    29| import org.apache.wiki.event.WikiEventEmitter;
    30| import org.apache.wiki.event.WorkflowEvent;
    31| import org.apache.wiki.util.TextUtil;
    32| import java.io.*;
    33| import java.nio.file.Files;
    34| import java.security.Principal;
    35| import java.util.*;
    36| import java.util.concurrent.ConcurrentHashMap;
    37| import java.util.concurrent.CopyOnWriteArrayList;
    38| /**
    39|  * <p>
    40|  * Monitor class that tracks running Workflows. The WorkflowManager also keeps track of the names of
    41|  * users or groups expected to approve particular Workflows.
    42|  * </p>
    43|  */
    44| public class DefaultWorkflowManager implements WorkflowManager {
    45|     private static final Logger LOG = LogManager.getLogger( DefaultWorkflowManager.class );
    46|     static final String SERIALIZATION_FILE = "wkflmgr.ser";
    47|     /** We use this also a generic serialization id */
    48|     private static final long serialVersionUID = 6L;
    49|     DecisionQueue m_queue;
    50|     Set< Workflow > m_workflows;
    51|     final Map< String, Principal > m_approvers;
    52|     Queue< Workflow > m_completed;
    53|     private Engine m_engine;
    54|     private int retainCompleted;
    55|     /**
    56|      * Constructs a new WorkflowManager, with an empty workflow cache.
    57|      */
    58|     public DefaultWorkflowManager() {
    59|         m_workflows = ConcurrentHashMap.newKeySet();
    60|         m_approvers = new ConcurrentHashMap<>();
    61|         m_queue = new DecisionQueue();
    62|         WikiEventEmitter.attach( this );
    63|     }
    64|     /**

# --- HUNK 2: Lines 190-234 ---
   190|     }
   191|     /**
   192|      * Returns the DecisionQueue associated with this WorkflowManager
   193|      *
   194|      * @return the decision queue
   195|      */
   196|     @Override
   197|     public DecisionQueue getDecisionQueue() {
   198|         return m_queue;
   199|     }
   200|     /**
   201|      * {@inheritDoc}
   202|      */
   203|     @Override
   204|     public List< Workflow > getOwnerWorkflows( final Session session ) {
   205|         final List< Workflow > workflows = new ArrayList<>();
   206|         if ( session.isAuthenticated() ) {
   207|             final Principal[] sessionPrincipals = session.getPrincipals();
   208|             for( final Workflow w : m_workflows ) {
   209|                 final Principal owner = w.getOwner();
   210|                 for ( final Principal sessionPrincipal : sessionPrincipals ) {
   211|                     if ( sessionPrincipal.equals( owner ) ) {
   212|                         workflows.add( w );
   213|                         break;
   214|                     }
   215|                 }
   216|             }
   217|         }
   218|         return workflows;
   219|     }
   220|     /**
   221|      * Listens for {@link WorkflowEvent} objects emitted by Workflows. In particular, this method listens for {@link WorkflowEvent#CREATED},
   222|      * {@link WorkflowEvent#ABORTED}, {@link WorkflowEvent#COMPLETED} and {@link WorkflowEvent#DQ_REMOVAL} events. If a workflow is created,
   223|      * it is automatically added to the cache. If one is aborted or completed, it is automatically removed. If a removal from decision queue
   224|      * is issued, the current step from workflow, which is assumed to be a {@link Decision}, is removed from the {@link DecisionQueue}.
   225|      * 
   226|      * @param event the event passed to this listener
   227|      */
   228|     @Override
   229|     public void actionPerformed( final WikiEvent event ) {
   230|         if( event instanceof WorkflowEvent ) {
   231|             if( event.getSrc() instanceof Workflow ) {
   232|                 final Workflow workflow = event.getSrc();
   233|                 switch( event.getType() ) {
   234|                 case WorkflowEvent.ABORTED   :


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/xmlrpc/RPCHandler.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 17-97 ---
    17| package org.apache.wiki.xmlrpc;
    18| import org.apache.wiki.LinkCollector;
    19| import org.apache.wiki.api.core.Attachment;
    20| import org.apache.wiki.api.core.Context;
    21| import org.apache.wiki.api.core.ContextEnum;
    22| import org.apache.wiki.api.core.Page;
    23| import org.apache.wiki.api.spi.Wiki;
    24| import org.apache.wiki.auth.permissions.PagePermission;
    25| import org.apache.wiki.auth.permissions.PermissionFactory;
    26| import org.apache.wiki.pages.PageManager;
    27| import org.apache.wiki.render.RenderingManager;
    28| import org.apache.wiki.util.TextUtil;
    29| import org.apache.xmlrpc.XmlRpcException;
    30| import java.nio.charset.StandardCharsets;
    31| import java.util.Calendar;
    32| import java.util.Collection;
    33| import java.util.Date;
    34| import java.util.Hashtable;
    35| import java.util.Set;
    36| import java.util.Vector;
    37| /**
    38|  *  Provides handlers for all RPC routines.
    39|  *
    40|  *  @since 1.6.6
    41|  */
    42| public class RPCHandler extends AbstractRPCHandler {
    43|     /**
    44|      *  Converts Java string into RPC string.
    45|      */
    46|     private String toRPCString( final String src )
    47|     {
    48|         return TextUtil.urlEncodeUTF8( src );
    49|     }
    50|     /**
    51|      *  Converts RPC string (UTF-8, url encoded) into Java string.
    52|      */
    53|     private String fromRPCString( final String src )
    54|     {
    55|         return TextUtil.urlDecodeUTF8( src );
    56|     }
    57|     /**
    58|      *  Transforms a Java string into UTF-8.
    59|      */
    60|     private byte[] toRPCBase64( final String src )
    61|     {
    62|         return src.getBytes( StandardCharsets.UTF_8 );
    63|     }
    64|     public String getApplicationName() {
    65|         checkPermission( PagePermission.VIEW );
    66|         return toRPCString(m_engine.getApplicationName());
    67|     }
    68|     public Vector< String > getAllPages() {
    69|         checkPermission( PagePermission.VIEW );
    70|         final Collection< Page > pages = m_engine.getManager( PageManager.class ).getRecentChanges();
    71|         final Vector< String > result = new Vector<>();
    72|         for( final Page p : pages ) {
    73|             if( !( p instanceof Attachment ) ) {
    74|                 result.add( toRPCString( p.getName() ) );
    75|             }
    76|         }
    77|         return result;
    78|     }
    79|     /**
    80|      *  Encodes a single wiki page info into a Hashtable.
    81|      */
    82|     @Override
    83|     protected Hashtable<String,Object> encodeWikiPage( final Page page ) {
    84|         final Hashtable<String, Object> ht = new Hashtable<>();
    85|         ht.put( "name", toRPCString(page.getName()) );
    86|         final Date d = page.getLastModified();
    87|         final Calendar cal = Calendar.getInstance();
    88|         cal.setTime( d );
    89|         cal.add( Calendar.MILLISECOND,
    90|                  - (cal.get( Calendar.ZONE_OFFSET ) +
    91|                     (cal.getTimeZone().inDaylightTime( d ) ? cal.get( Calendar.DST_OFFSET ) : 0 ) ) );
    92|         ht.put( "lastModified", cal.getTime() );
    93|         ht.put( "version", page.getVersion() );
    94|         if( page.getAuthor() != null ) {
    95|             ht.put( "author", toRPCString( page.getAuthor() ) );
    96|         }
    97|         return ht;


# ====================================================================
# FILE: jspwiki-main/src/main/java/org/apache/wiki/xmlrpc/RPCHandlerUTF8.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 14-74 ---
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.xmlrpc;
    18| import org.apache.wiki.LinkCollector;
    19| import org.apache.wiki.api.core.Attachment;
    20| import org.apache.wiki.api.core.Context;
    21| import org.apache.wiki.api.core.ContextEnum;
    22| import org.apache.wiki.api.core.Page;
    23| import org.apache.wiki.api.spi.Wiki;
    24| import org.apache.wiki.auth.permissions.PagePermission;
    25| import org.apache.wiki.auth.permissions.PermissionFactory;
    26| import org.apache.wiki.pages.PageManager;
    27| import org.apache.wiki.render.RenderingManager;
    28| import org.apache.xmlrpc.XmlRpcException;
    29| import java.util.Calendar;
    30| import java.util.Date;
    31| import java.util.Hashtable;
    32| import java.util.Set;
    33| import java.util.Vector;
    34| /**
    35|  *  Provides handlers for all RPC routines.  These routines are used by
    36|  *  the UTF-8 interface.
    37|  *
    38|  *  @since 1.6.13
    39|  */
    40| public class RPCHandlerUTF8 extends AbstractRPCHandler {
    41|     public String getApplicationName() {
    42|         checkPermission( PagePermission.VIEW );
    43|         return m_engine.getApplicationName();
    44|     }
    45|     public Vector< String > getAllPages() {
    46|         checkPermission( PagePermission.VIEW );
    47|         final Set< Page > pages = m_engine.getManager( PageManager.class ).getRecentChanges();
    48|         final Vector< String > result = new Vector<>();
    49|         for( final Page p : pages ) {
    50|             if( !( p instanceof Attachment ) ) {
    51|                 result.add( p.getName() );
    52|             }
    53|         }
    54|         return result;
    55|     }
    56|     /**
    57|      *  Encodes a single wiki page info into a Hashtable.
    58|      */
    59|     @Override
    60|     protected Hashtable<String, Object> encodeWikiPage( final Page page ) {
    61|         final Hashtable<String, Object> ht = new Hashtable<>();
    62|         ht.put( "name", page.getName() );
    63|         final Date d = page.getLastModified();
    64|         final Calendar cal = Calendar.getInstance();
    65|         cal.setTime( d );
    66|         cal.add( Calendar.MILLISECOND,
    67|                  - (cal.get( Calendar.ZONE_OFFSET ) +
    68|                     (cal.getTimeZone().inDaylightTime( d ) ? cal.get( Calendar.DST_OFFSET ) : 0 )) );
    69|         ht.put( "lastModified", cal.getTime() );
    70|         ht.put( "version", page.getVersion() );
    71|         if( page.getAuthor() != null ) {
    72|             ht.put( "author", page.getAuthor() );
    73|         }
    74|         return ht;


# ====================================================================
# FILE: jspwiki-markdown/src/main/java/org/apache/wiki/markdown/extensions/jspwikilinks/postprocessor/LocalFootnoteLinkNodePostProcessorState.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-20 ---
     1| package org.apache.wiki.markdown.extensions.jspwikilinks.postprocessor;
     2| import com.vladsch.flexmark.util.ast.Node;
     3| import com.vladsch.flexmark.util.ast.NodeTracker;
     4| import com.vladsch.flexmark.util.sequence.CharSubSequence;
     5| import org.apache.wiki.api.core.Context;
     6| import org.apache.wiki.api.core.ContextEnum;
     7| import org.apache.wiki.markdown.nodes.JSPWikiLink;
     8| /**
     9|  * {@link NodePostProcessorState} which further post processes local footnote links.
    10|  */
    11| public class LocalFootnoteLinkNodePostProcessorState implements NodePostProcessorState< JSPWikiLink > {
    12|     final Context wikiContext;
    13|     public LocalFootnoteLinkNodePostProcessorState( final Context wikiContext ) {
    14|         this.wikiContext = wikiContext;
    15|     }
    16|     /**
    17|      * {@inheritDoc}
    18|      *
    19|      * @see NodePostProcessorState#process(NodeTracker, Node) 
    20|      */


# ====================================================================
# FILE: jspwiki-util/src/main/java/org/apache/wiki/util/CommentedProperties.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 69-109 ---
    69|     @Override
    70|     public synchronized void load(final Reader in ) throws IOException
    71|     {
    72|         m_propertyString = FileUtil.readContents( in );
    73|         super.load( new ByteArrayInputStream( m_propertyString.getBytes(StandardCharsets.ISO_8859_1) ) );
    74|     }
    75|     /**
    76|      * {@inheritDoc}
    77|      */
    78|     @Override
    79|     public synchronized Object setProperty(final String key, final String value )
    80|     {
    81|         return put(key, value);
    82|     }
    83|     /**
    84|      * {@inheritDoc}
    85|      */
    86|     @Override
    87|     public synchronized void store(final OutputStream out, final String comments ) throws IOException
    88|     {
    89|         final byte[] bytes = m_propertyString.getBytes(StandardCharsets.ISO_8859_1.name());
    90|         FileUtil.copyContents( new ByteArrayInputStream( bytes ), out );
    91|         out.flush();
    92|     }
    93|     /**
    94|      * {@inheritDoc}
    95|      */
    96|     @Override
    97|     public synchronized Object put(final Object arg0, final Object arg1 )
    98|     {
    99|         writeProperty( arg0, arg1 );
   100|         return super.put(arg0, arg1);
   101|     }
   102|     /**
   103|      * {@inheritDoc}
   104|      */
   105|     @Override
   106|     public synchronized void putAll(final Map< ? , ? > arg0 )
   107|     {
   108|         for (final Entry<?, ?> value : arg0.entrySet()) {
   109|             @SuppressWarnings("unchecked") final Entry<Object, Object> entry = (Entry<Object, Object>) value;


# ====================================================================
# FILE: jspwiki-util/src/main/java/org/apache/wiki/util/PropertyReader.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 4-43 ---
     4|     distributed with this work for additional information
     5|     regarding copyright ownership.  The ASF licenses this file
     6|     to you under the Apache License, Version 2.0 (the
     7|     "License"); you may not use this file except in compliance
     8|     with the License.  You may obtain a copy of the License at
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.    
    16|  */
    17| package org.apache.wiki.util;
    18| import org.apache.commons.lang3.StringUtils;
    19| import org.apache.commons.lang3.Validate;
    20| import org.apache.logging.log4j.LogManager;
    21| import org.apache.logging.log4j.Logger;
    22| import javax.servlet.ServletContext;
    23| import java.io.*;
    24| import java.util.*;
    25| import java.util.stream.Collectors;
    26| import java.nio.file.Files;
    27| /**
    28|  * Property Reader for the WikiEngine. Reads the properties for the WikiEngine
    29|  * and implements the feature of cascading properties and variable substitution,
    30|  * which come in handy in a multi wiki installation environment: It reduces the
    31|  * need for (shell) scripting in order to generate different jspwiki.properties
    32|  * to a minimum.
    33|  *
    34|  * @since 2.5.x
    35|  */
    36| public final class PropertyReader {
    37| 	private static final Logger LOG = LogManager.getLogger( PropertyReader.class );
    38|     /**
    39|      * Path to the base property file, usually overridden by values provided in
    40|      * a jspwiki-custom.properties file {@value #DEFAULT_JSPWIKI_CONFIG}
    41|      */
    42|     public static final String DEFAULT_JSPWIKI_CONFIG = "/ini/jspwiki.properties";
    43|     /**

# --- HUNK 2: Lines 198-238 ---
   198|     }
   199|     /**
   200|      *  Implement the cascade functionality.
   201|      *
   202|      * @param context             where to read the cascade from
   203|      * @param defaultProperties   properties to merge the cascading properties to
   204|      * @since 2.5.x
   205|      */
   206|     private static void loadWebAppPropsCascade( final ServletContext context, final Properties defaultProperties ) {
   207|         if( getInitParameter( context, PARAM_CUSTOMCONFIG_CASCADEPREFIX + "1" ) == null ) {
   208|             LOG.debug( " No cascading properties defined for this context" );
   209|             return;
   210|         }
   211|         int depth = 0;
   212|         while( true ) {
   213|             depth++;
   214|             final String propertyFile = getInitParameter( context, PARAM_CUSTOMCONFIG_CASCADEPREFIX + depth );
   215|             if( propertyFile == null ) {
   216|                 break;
   217|             }
   218|             try( final InputStream propertyStream = new FileInputStream( propertyFile ) ) {
   219|                 LOG.info( " Reading additional properties from " + propertyFile + " and merge to cascade." );
   220|                 final Properties additionalProps = new Properties();
   221|                 additionalProps.load( propertyStream );
   222|                 defaultProperties.putAll( additionalProps );
   223|             } catch( final Exception e ) {
   224|                 LOG.error( "JSPWiki: Unable to load and setup properties from " + propertyFile + "." + e.getMessage() );
   225|             }
   226|         }
   227|     }
   228|     /**
   229|      *  You define a property variable by using the prefix "var.x" as a property. In property values you can then use the "$x" identifier
   230|      *  to use this variable.
   231|      *
   232|      *  For example, you could declare a base directory for all your files like this and use it in all your other property definitions with
   233|      *  a "$basedir". Note that it does not matter if you define the variable before its usage.
   234|      *  <pre>
   235|      *  var.basedir = /p/mywiki;
   236|      *  jspwiki.fileSystemProvider.pageDir =         $basedir/www/
   237|      *  jspwiki.basicAttachmentProvider.storageDir = $basedir/www/
   238|      *  jspwiki.workDir =                            $basedir/wrk/


# ====================================================================
# FILE: jspwiki-util/src/main/java/org/apache/wiki/util/TextUtil.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 9-48 ---
     9|        http://www.apache.org/licenses/LICENSE-2.0
    10|     Unless required by applicable law or agreed to in writing,
    11|     software distributed under the License is distributed on an
    12|     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    13|     KIND, either express or implied.  See the License for the
    14|     specific language governing permissions and limitations
    15|     under the License.
    16|  */
    17| package org.apache.wiki.util;
    18| import org.apache.commons.lang3.StringUtils;
    19| import org.apache.logging.log4j.LogManager;
    20| import org.apache.logging.log4j.Logger;
    21| import java.io.File;
    22| import java.io.IOException;
    23| import java.nio.charset.Charset;
    24| import java.nio.charset.StandardCharsets;
    25| import java.security.SecureRandom;
    26| import java.util.NoSuchElementException;
    27| import java.util.Properties;
    28| import java.util.Random;
    29| /**
    30|  *  Contains a number of static utility methods.
    31|  */
    32| public final class TextUtil {
    33|     private static final Logger LOG = LogManager.getLogger( TextUtil.class );
    34|     static final String HEX_DIGITS = "0123456789ABCDEF";
    35|     /** Pick from some letters that won't be easily mistaken for each other to compose passwords. So, for example, omit o, O and 0, or 1, l and L.*/
    36|     static final String PWD_BASE = "abcdefghjkmnpqrstuvwxyzABCDEFGHJKMNPQRSTUVWXYZ23456789+@";
    37|     /** Length of password. {@link #generateRandomPassword() */
    38|     public static final int PASSWORD_LENGTH = 8;
    39|     /** Lists all punctuation characters allowed in WikiMarkup. These will not be cleaned away. This is for compatibility for older versions
    40|      of JSPWiki. */
    41|     public static final String LEGACY_CHARS_ALLOWED = "._";
    42|     /** Lists all punctuation characters allowed in page names. */
    43|     public static final String PUNCTUATION_CHARS_ALLOWED = " ()&+,-=._$";
    44|     /** Private constructor prevents instantiation. */
    45|     private TextUtil() {}
    46|     /**
    47|      *  java.net.URLEncoder.encode() method in JDK < 1.4 is buggy.  This duplicates its functionality.
    48|      *

# --- HUNK 2: Lines 652-696 ---
   652|             start += 4; // Skip this "----"
   653|             while (start < pagedata.length() && pagedata.charAt( start ) == '-') {
   654|                 start++;
   655|             }
   656|             previous = start;
   657|         }
   658|         if( ++tags == section ) {
   659|             return pagedata.substring( previous );
   660|         }
   661|         throw new IllegalArgumentException( "There is no section no. " + section + " on the page." );
   662|     }
   663|     /**
   664|      *  A simple routine which just repeates the arguments.  This is useful for creating something like a line or something.
   665|      *
   666|      *  @param what String to repeat
   667|      *  @param times How many times to repeat the string.
   668|      *  @return Guess what?
   669|      *  @since 2.1.98.
   670|      */
   671|     public static String repeatString( final String what, final int times ) {
   672|         final StringBuilder sb = new StringBuilder();
   673|         for( int i = 0; i < times; i++ ) {
   674|             sb.append( what );
   675|         }
   676|         return sb.toString();
   677|     }
   678|     /**
   679|      *  Converts a string from the Unicode representation into something that can be embedded in a java
   680|      *  properties file.  All references outside the ASCII range are replaced with \\uXXXX.
   681|      *
   682|      *  @param s The string to convert
   683|      *  @return the ASCII string
   684|      */
   685|     public static String native2Ascii( final String s ) {
   686|         final StringBuilder sb = new StringBuilder();
   687|         for( int i = 0; i < s.length(); i++ ) {
   688|             final char aChar = s.charAt(i);
   689|             if( ( aChar < 0x0020 ) || ( aChar > 0x007e ) ) {
   690|                 sb.append( '\\');
   691|                 sb.append( 'u');
   692|                 sb.append( toHex( ( aChar >> 12 ) & 0xF ) );
   693|                 sb.append( toHex( ( aChar >>  8 ) & 0xF ) );
   694|                 sb.append( toHex( ( aChar >>  4 ) & 0xF ) );
   695|                 sb.append( toHex( aChar        & 0xF ) );
   696|             } else {

# --- HUNK 3: Lines 734-761 ---
   734|         if( s == null ) {
   735|         	return false;
   736|         }
   737|         if( s.length() > 1 && s.charAt(0) == '-' ) {
   738|         	s = s.substring( 1 );
   739|         }
   740|         for( int i = 0; i < s.length(); i++ ) {
   741|             if( !Character.isDigit( s.charAt( i ) ) ) {
   742|             	return false;
   743|             }
   744|         }
   745|         return true;
   746|     }
   747|     /**
   748|      * Generate a random String suitable for use as a temporary password.
   749|      *
   750|      * @return String suitable for use as a temporary password
   751|      * @since 2.4
   752|      */
   753|     public static String generateRandomPassword() {
   754|         final StringBuilder pw = new StringBuilder();
   755|         for( int i = 0; i < PASSWORD_LENGTH; i++ ) {
   756|             final int index = ( int )( RANDOM.nextDouble() * PWD_BASE.length() );
   757|             pw.append(PWD_BASE.charAt( index ));
   758|         }
   759|         return pw.toString();
   760|     }
   761| }


# ====================================================================
# FILE: jspwiki-util/src/main/java/org/apache/wiki/util/TimedCounterList.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 114-164 ---
   114|         T t;
   115|         try
   116|         {
   117|             t = m_list.remove( index ).m_obj;
   118|         }
   119|         finally
   120|         {
   121|             m_lock.writeLock().unlock();
   122|         }
   123|         return t;
   124|     }
   125|     /**
   126|      *  Returns the count how many times this object is available in
   127|      *  this list, using equals().
   128|      *  
   129|      *  @param obj The object to count.
   130|      *  @return The count of the objects.
   131|      */
   132|     public int count(final T obj )
   133|     {
   134|         int c = 0;
   135|         m_lock.readLock().lock();
   136|         try
   137|         {
   138|             for( final CounterItem< T > i : m_list )
   139|             {
   140|                 if( i.m_obj.equals( obj ) )
   141|                 {
   142|                     c++;
   143|                 }
   144|             }
   145|         }
   146|         finally
   147|         {
   148|             m_lock.readLock().unlock();
   149|         }
   150|         return c;
   151|     }
   152|     /**
   153|      *  Performs a cleanup of all items older than maxage.
   154|      *  
   155|      *  @param maxage The maximum age in milliseconds after an item is removed.
   156|      */
   157|     public void cleanup(final long maxage )
   158|     {
   159|         m_lock.writeLock().lock();
   160|         try
   161|         {
   162|             final long now = System.currentTimeMillis();
   163|             for(final Iterator<CounterItem<T>> i = m_list.iterator(); i.hasNext(); )
   164|             {


# ====================================================================
# FILE: jspwiki-util/src/main/java/org/apache/wiki/util/XmlUtil.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 18-57 ---
    18| import org.apache.commons.lang3.StringUtils;
    19| import org.apache.logging.log4j.LogManager;
    20| import org.apache.logging.log4j.Logger;
    21| import org.jdom2.Document;
    22| import org.jdom2.Element;
    23| import org.jdom2.JDOMException;
    24| import org.jdom2.Text;
    25| import org.jdom2.filter.Filters;
    26| import org.jdom2.input.SAXBuilder;
    27| import org.jdom2.xpath.XPathExpression;
    28| import org.jdom2.xpath.XPathFactory;
    29| import java.io.IOException;
    30| import java.io.InputStream;
    31| import java.net.URL;
    32| import java.util.ArrayList;
    33| import java.util.Collections;
    34| import java.util.Enumeration;
    35| import java.util.HashSet;
    36| import java.util.List;
    37| import java.util.Set;
    38| /**
    39|  *  Utility class to parse XML files.
    40|  *  <p>
    41|  *  This uses JDOM2 as its backing implementation.
    42|  *  </p>
    43|  *  
    44|  * @since 2.10
    45|  */
    46| public final class XmlUtil  {
    47| 	private static final String ALL_TEXT_NODES = "//text()";
    48| 	private static final Logger LOG = LogManager.getLogger( XmlUtil.class );
    49| 	private XmlUtil() {}
    50| 	/**
    51| 	 * Parses the given XML file and returns the requested nodes. If there's an error accessing or parsing the file, an
    52| 	 * empty list is returned.
    53| 	 * 
    54| 	 * @param xml file to parse; matches all resources from classpath, filters repeated items.
    55| 	 * @param requestedNodes requested nodes on the xml file
    56| 	 * @return the requested nodes of the XML file.
    57| 	 */

# --- HUNK 2: Lines 95-132 ---
    95| 				final XPathExpression< Element > xp = xpfac.compile( requestedNodes, Filters.element() );
    96| 				return xp.evaluate( doc );
    97| 			} catch( final IOException ioe ) {
    98| 				LOG.error( "Couldn't load all {} resources", xmlStream, ioe );
    99| 			} catch( final JDOMException jdome ) {
   100| 				LOG.error( "error parsing {} resources", xmlStream,  jdome );
   101| 			}
   102| 		}		
   103| 		return Collections.emptyList();
   104| 	}
   105| 	/**
   106| 	 * Renders all the text() nodes from the DOM tree. This is very useful for cleaning away all the XHTML.
   107| 	 *
   108| 	 * @param doc Dom tree
   109| 	 * @return String containing only the text from the provided Dom tree.
   110| 	 */
   111| 	public static String extractTextFromDocument( final Document doc ) {
   112| 		if( doc == null ) {
   113| 			return "";
   114| 		}
   115| 		final StringBuilder sb = new StringBuilder();
   116| 		final List< ? > nodes = XPathFactory.instance().compile( ALL_TEXT_NODES ).evaluate( doc );
   117| 		for( final Object el : nodes ) {
   118| 			if( el instanceof Text ) {
   119| 				sb.append( ( ( Text )el ).getValue() );
   120| 			}
   121| 		}
   122| 		return sb.toString();
   123| 	}
   124| 	public static Element getXPathElement( final Element base, final String expression ) {
   125| 		final List< ? > nodes = XPathFactory.instance().compile( expression ).evaluate( base );
   126| 		if( nodes == null || nodes.size() == 0 ) {
   127| 			return null;
   128| 		} else {
   129| 			return ( Element )nodes.get( 0 );
   130| 		}
   131| 	}
   132| }


# ====================================================================
# FILE: jspwiki-wysiwyg/src/main/java/org/apache/wiki/htmltowiki/XHtmlElementToWikiTranslator.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 17-56 ---
    17| package org.apache.wiki.htmltowiki;
    18| import org.apache.commons.lang3.StringUtils;
    19| import org.apache.logging.log4j.LogManager;
    20| import org.apache.logging.log4j.Logger;
    21| import org.apache.wiki.api.core.Engine;
    22| import org.apache.wiki.htmltowiki.syntax.MarkupHelper;
    23| import org.apache.wiki.util.ClassUtil;
    24| import org.apache.wiki.util.XmlUtil;
    25| import org.jdom2.Content;
    26| import org.jdom2.Element;
    27| import org.jdom2.JDOMException;
    28| import org.jdom2.Verifier;
    29| import org.jdom2.Text;
    30| import org.jdom2.xpath.XPathFactory;
    31| import java.io.PrintWriter;
    32| import java.util.ArrayDeque;
    33| import java.util.Arrays;
    34| import java.util.Deque;
    35| import java.util.LinkedHashMap;
    36| import java.util.Map;
    37| /**
    38|  * Converting XHtml to Wiki Markup.  This is the class which orchestrates all the heavy loading.
    39|  */
    40| public class XHtmlElementToWikiTranslator {
    41|     private static final Logger LOG = LogManager.getLogger( XHtmlElementToWikiTranslator.class );
    42|     private static final String DEFAULT_SYNTAX_DECORATOR = "org.apache.wiki.htmltowiki.syntax.jspwiki.JSPWikiSyntaxDecorator";
    43|     private final Engine e;
    44|     private final XHtmlToWikiConfig config;
    45|     private final WhitespaceTrimWriter outTrimmer = new WhitespaceTrimWriter();
    46|     private final SyntaxDecorator syntax;
    47|     /**
    48|      *  Create a new translator using the default config.
    49|      *
    50|      *  @param base The base element from which to start translating.
    51|      *  @throws JDOMException If the DOM tree is faulty.
    52|      */
    53|     public XHtmlElementToWikiTranslator( final Engine e, final Element base ) throws JDOMException, ReflectiveOperationException {
    54|         this( e, base, new XHtmlToWikiConfig() );
    55|     }
    56|     /**

# --- HUNK 2: Lines 181-225 ---
   181|                     case "1": style += "font-size:xx-small;"; break;
   182|                     case "2": style += "font-size:x-small;"; break;
   183|                     case "3": style += "font-size:small;"; break;
   184|                     case "4": style += "font-size:medium;"; break;
   185|                     case "5": style += "font-size:large;"; break;
   186|                     case "6": style += "font-size:x-large;"; break;
   187|                     case "7": style += "font-size:xx-large;"; break;
   188|                 }
   189|             }
   190|         }
   191|         if( style.equals( "" ) ) {
   192|             return null;
   193|         }
   194|         final Map< Object, Object > m = new LinkedHashMap<>();
   195|         Arrays.stream( style.toLowerCase().split( ";" ) )
   196|               .filter( StringUtils::isNotEmpty )
   197|               .forEach( prop -> m.put( prop.split( ":" )[ 0 ].trim(), prop.split( ":" )[ 1 ].trim() ) );
   198|         return m;
   199|     }
   200|     private String propsToStyleString( final Map< Object, Object >  styleProps ) {
   201|         final StringBuilder style = new StringBuilder();
   202|         for( final Map.Entry< Object, Object > entry : styleProps.entrySet() ) {
   203|             style.append( " " ).append( entry.getKey() ).append( ": " ).append( entry.getValue() ).append( ";" );
   204|         }
   205|         return style.toString();
   206|     }
   207|     public void translateChildren( final Element base ) throws JDOMException {
   208|         for( final Content c : base.getContent() ) {
   209|             if( c instanceof Element ) {
   210|                 final Element e = ( Element )c;
   211|                 final String n = e.getName().toLowerCase();
   212|                 switch( n ) {
   213|                     case "h1": syntax.h1( e ); break;
   214|                     case "h2": syntax.h2( e ); break;
   215|                     case "h3": syntax.h3( e ); break;
   216|                     case "h4": syntax.h4( e ); break;
   217|                     case "p": syntax.p( e ); break;
   218|                     case "br": syntax.br( base, e ); break;
   219|                     case "hr": syntax.hr( e ); break;
   220|                     case "table": syntax.table( e ); break;
   221|                     case "tbody": syntax.tbody( e ); break;
   222|                     case "tr": syntax.tr( e ); break;
   223|                     case "td": syntax.td( e ); break;
   224|                     case "thead": syntax.thead( e ); break;
   225|                     case "th": syntax.th( e ); break;

