--- a/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/FluentIterable.java
+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/FluentIterable.java
@@ -174,24 +174,24 @@
   }
   /**
    * Applies {@code function} to each element of this fluent iterable and returns
    * a fluent iterable with the concatenated combination of results.  {@code function}
    * returns an Iterable of results.
    *
    * <p>The returned fluent iterable's iterator supports {@code remove()} if this
    * function-returned iterables' iterator does. After a successful {@code remove()} call,
    * the returned fluent iterable no longer contains the corresponding element.
    *
-   * @since 13.0 (required {@code Function<E, Iterable<T>>} until 14.0)
+   * @since 13.0
    */
   public <T> FluentIterable<T> transformAndConcat(
-      Function<? super E, ? extends Iterable<? extends T>> function) {
+      Function<? super E, ? extends Iterable<T>> function) {
     return from(Iterables.concat(transform(function)));
   }
   /**
    * Returns an {@link Optional} containing the first element in this fluent iterable.
    * If the iterable is empty, {@code Optional.absent()} is returned.
    *
    * @throws NullPointerException if the first element is null; if this is a possibility, use
    *     {@code iterator().next()} or {@link Iterables#getFirst} instead.
    */
   public final Optional<E> first() {

--- a/guava/src/com/google/common/collect/FluentIterable.java
+++ b/guava/src/com/google/common/collect/FluentIterable.java
@@ -184,24 +184,24 @@
   }
   /**
    * Applies {@code function} to each element of this fluent iterable and returns
    * a fluent iterable with the concatenated combination of results.  {@code function}
    * returns an Iterable of results.
    *
    * <p>The returned fluent iterable's iterator supports {@code remove()} if this
    * function-returned iterables' iterator does. After a successful {@code remove()} call,
    * the returned fluent iterable no longer contains the corresponding element.
    *
-   * @since 13.0 (required {@code Function<E, Iterable<T>>} until 14.0)
+   * @since 13.0
    */
   public <T> FluentIterable<T> transformAndConcat(
-      Function<? super E, ? extends Iterable<? extends T>> function) {
+      Function<? super E, ? extends Iterable<T>> function) {
     return from(Iterables.concat(transform(function)));
   }
   /**
    * Returns an {@link Optional} containing the first element in this fluent iterable.
    * If the iterable is empty, {@code Optional.absent()} is returned.
    *
    * @throws NullPointerException if the first element is null; if this is a possibility, use
    *     {@code iterator().next()} or {@link Iterables#getFirst} instead.
    */
   public final Optional<E> first() {

--- a/guava/src/com/google/common/eventbus/EventBus.java
+++ b/guava/src/com/google/common/eventbus/EventBus.java
@@ -263,21 +263,20 @@
     }
     isDispatching.set(true);
     try {
       Queue<EventWithHandler> events = eventsToDispatch.get();
       EventWithHandler eventWithHandler;
       while ((eventWithHandler = events.poll()) != null) {
         dispatch(eventWithHandler.event, eventWithHandler.handler);
       }
     } finally {
       isDispatching.remove();
-      eventsToDispatch.remove();
     }
   }
   /**
    * Dispatches {@code event} to the handler in {@code wrapper}.  This method
    * is an appropriate override point for subclasses that wish to make
    * event delivery asynchronous.
    *
    * @param event  event to dispatch.
    * @param wrapper  wrapper that will call the handler.
    */

--- a/guava/src/com/google/common/util/concurrent/Futures.java
+++ b/guava/src/com/google/common/util/concurrent/Futures.java
@@ -51,35 +51,35 @@
  * <p>Many of these methods use the {@link ListenableFuture} API; consult the
  * Guava User Guide article on <a href=
  * "http://code.google.com/p/guava-libraries/wiki/ListenableFutureExplained">
  * {@code ListenableFuture}</a>.
  *
  * @author Kevin Bourrillion
  * @author Nishant Thakkar
  * @author Sven Mawson
  * @since 1.0
  */
-@Beta
 public final class Futures {
   private Futures() {}
   /**
    * Creates a {@link CheckedFuture} out of a normal {@link ListenableFuture}
    * and a {@link Function} that maps from {@link Exception} instances into the
    * appropriate checked type.
    *
    * <p>The given mapping function will be applied to an
    * {@link InterruptedException}, a {@link CancellationException}, or an
    * {@link ExecutionException}.
    * See {@link Future#get()} for details on the exceptions thrown.
    *
    * @since 9.0 (source-compatible since 1.0)
    */
+  @Beta
   public static <V, X extends Exception> CheckedFuture<V, X> makeChecked(
       ListenableFuture<V> future, Function<Exception, X> mapper) {
     return new MappingCheckedFuture<V, X>(checkNotNull(future), mapper);
   }
   private abstract static class ImmediateFuture<V>
       implements ListenableFuture<V> {
     private static final Logger log =
         Logger.getLogger(ImmediateFuture.class.getName());
     @Override
     public void addListener(Runnable listener, Executor executor) {
@@ -197,20 +197,21 @@
     return new ImmediateSuccessfulFuture<V>(value);
   }
   /**
    * Returns a {@code CheckedFuture} which has its value set immediately upon
    * construction.
    *
    * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()}
    * method always returns {@code true}. Calling {@code get()} or {@code
    * checkedGet()} will immediately return the provided value.
    */
+  @Beta
   public static <V, X extends Exception> CheckedFuture<V, X>
       immediateCheckedFuture(@Nullable V value) {
     return new ImmediateSuccessfulCheckedFuture<V, X>(value);
   }
   /**
    * Returns a {@code ListenableFuture} which has an exception set immediately
    * upon construction.
    *
    * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()}
    * method always returns {@code true}. Calling {@code get()} will immediately
@@ -221,33 +222,35 @@
       Throwable throwable) {
     checkNotNull(throwable);
     return new ImmediateFailedFuture<V>(throwable);
   }
   /**
    * Creates a {@code ListenableFuture} which is cancelled immediately upon
    * construction, so that {@code isCancelled()} always returns {@code true}.
    *
    * @since 14.0
    */
+  @Beta
   public static <V> ListenableFuture<V> immediateCancelledFuture() {
     return new ImmediateCancelledFuture<V>();
   }
   /**
    * Returns a {@code CheckedFuture} which has an exception set immediately upon
    * construction.
    *
    * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()}
    * method always returns {@code true}. Calling {@code get()} will immediately
    * throw the provided {@code Exception} wrapped in an {@code
    * ExecutionException}, and calling {@code checkedGet()} will throw the
    * provided exception itself.
    */
+  @Beta
   public static <V, X extends Exception> CheckedFuture<V, X>
       immediateFailedCheckedFuture(X exception) {
     checkNotNull(exception);
     return new ImmediateFailedCheckedFuture<V, X>(exception);
   }
   /**
    * Returns a {@code Future} whose result is taken from the given primary
    * {@code input} or, if the primary input fails, from the {@code Future}
    * provided by the {@code fallback}. {@link FutureFallback#create} is not
    * invoked until the primary input has failed, so if the primary input
@@ -313,20 +316,21 @@
    * Also note that, regardless of which thread executes {@code
    * fallback.create}, all other registered but unexecuted listeners are
    * prevented from running during its execution, even if those listeners are
    * to run in other executors.
    *
    * @param input the primary input {@code Future}
    * @param fallback the {@link FutureFallback} implementation to be called if
    *     {@code input} fails
    * @since 14.0
    */
+  @Beta
   public static <V> ListenableFuture<V> withFallback(
       ListenableFuture<? extends V> input,
       FutureFallback<? extends V> fallback) {
     return withFallback(input, fallback, sameThreadExecutor());
   }
   /**
    * Returns a {@code Future} whose result is taken from the given primary
    * {@code input} or, if the primary input fails, from the {@code Future}
    * provided by the {@code fallback}. {@link FutureFallback#create} is not
    * invoked until the primary input has failed, so if the primary input
@@ -378,20 +382,21 @@
    * sameThreadExecutor}. However, be aware of the caveats documented in the
    * link above.
    *
    * @param input the primary input {@code Future}
    * @param fallback the {@link FutureFallback} implementation to be called if
    *     {@code input} fails
    * @param executor the executor that runs {@code fallback} if {@code input}
    *     fails
    * @since 14.0
    */
+  @Beta
   public static <V> ListenableFuture<V> withFallback(
       ListenableFuture<? extends V> input,
       FutureFallback<? extends V> fallback, Executor executor) {
     checkNotNull(fallback);
     return new FallbackFuture<V>(input, fallback, executor);
   }
   /**
    * A future that falls back on a second, generated future, in case its
    * original future fails.
    */
