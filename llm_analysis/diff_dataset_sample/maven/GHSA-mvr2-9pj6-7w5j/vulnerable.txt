# ====================================================================
# FILE: guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/FluentIterable.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 164-207 ---
   164|   /**
   165|    * Returns a fluent iterable that applies {@code function} to each element of this
   166|    * fluent iterable.
   167|    *
   168|    * <p>The returned fluent iterable's iterator supports {@code remove()} if this iterable's
   169|    * iterator does. After a successful {@code remove()} call, this fluent iterable no longer
   170|    * contains the corresponding element.
   171|    */
   172|   public final <T> FluentIterable<T> transform(Function<? super E, T> function) {
   173|     return from(Iterables.transform(iterable, function));
   174|   }
   175|   /**
   176|    * Applies {@code function} to each element of this fluent iterable and returns
   177|    * a fluent iterable with the concatenated combination of results.  {@code function}
   178|    * returns an Iterable of results.
   179|    *
   180|    * <p>The returned fluent iterable's iterator supports {@code remove()} if this
   181|    * function-returned iterables' iterator does. After a successful {@code remove()} call,
   182|    * the returned fluent iterable no longer contains the corresponding element.
   183|    *
   184|    * @since 13.0
   185|    */
   186|   public <T> FluentIterable<T> transformAndConcat(
   187|       Function<? super E, ? extends Iterable<T>> function) {
   188|     return from(Iterables.concat(transform(function)));
   189|   }
   190|   /**
   191|    * Returns an {@link Optional} containing the first element in this fluent iterable.
   192|    * If the iterable is empty, {@code Optional.absent()} is returned.
   193|    *
   194|    * @throws NullPointerException if the first element is null; if this is a possibility, use
   195|    *     {@code iterator().next()} or {@link Iterables#getFirst} instead.
   196|    */
   197|   public final Optional<E> first() {
   198|     Iterator<E> iterator = iterable.iterator();
   199|     return iterator.hasNext()
   200|         ? Optional.of(iterator.next())
   201|         : Optional.<E>absent();
   202|   }
   203|   /**
   204|    * Returns an {@link Optional} containing the last element in this fluent iterable.
   205|    * If the iterable is empty, {@code Optional.absent()} is returned.
   206|    *
   207|    * @throws NullPointerException if the last element is null; if this is a possibility, use


# ====================================================================
# FILE: guava/src/com/google/common/collect/FluentIterable.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 174-217 ---
   174|   /**
   175|    * Returns a fluent iterable that applies {@code function} to each element of this
   176|    * fluent iterable.
   177|    *
   178|    * <p>The returned fluent iterable's iterator supports {@code remove()} if this iterable's
   179|    * iterator does. After a successful {@code remove()} call, this fluent iterable no longer
   180|    * contains the corresponding element.
   181|    */
   182|   public final <T> FluentIterable<T> transform(Function<? super E, T> function) {
   183|     return from(Iterables.transform(iterable, function));
   184|   }
   185|   /**
   186|    * Applies {@code function} to each element of this fluent iterable and returns
   187|    * a fluent iterable with the concatenated combination of results.  {@code function}
   188|    * returns an Iterable of results.
   189|    *
   190|    * <p>The returned fluent iterable's iterator supports {@code remove()} if this
   191|    * function-returned iterables' iterator does. After a successful {@code remove()} call,
   192|    * the returned fluent iterable no longer contains the corresponding element.
   193|    *
   194|    * @since 13.0
   195|    */
   196|   public <T> FluentIterable<T> transformAndConcat(
   197|       Function<? super E, ? extends Iterable<T>> function) {
   198|     return from(Iterables.concat(transform(function)));
   199|   }
   200|   /**
   201|    * Returns an {@link Optional} containing the first element in this fluent iterable.
   202|    * If the iterable is empty, {@code Optional.absent()} is returned.
   203|    *
   204|    * @throws NullPointerException if the first element is null; if this is a possibility, use
   205|    *     {@code iterator().next()} or {@link Iterables#getFirst} instead.
   206|    */
   207|   public final Optional<E> first() {
   208|     Iterator<E> iterator = iterable.iterator();
   209|     return iterator.hasNext()
   210|         ? Optional.of(iterator.next())
   211|         : Optional.<E>absent();
   212|   }
   213|   /**
   214|    * Returns an {@link Optional} containing the last element in this fluent iterable.
   215|    * If the iterable is empty, {@code Optional.absent()} is returned.
   216|    *
   217|    * @throws NullPointerException if the last element is null; if this is a possibility, use


# ====================================================================
# FILE: guava/src/com/google/common/eventbus/EventBus.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 253-292 ---
   253|   void enqueueEvent(Object event, EventHandler handler) {
   254|     eventsToDispatch.get().offer(new EventWithHandler(event, handler));
   255|   }
   256|   /**
   257|    * Drain the queue of events to be dispatched. As the queue is being drained,
   258|    * new events may be posted to the end of the queue.
   259|    */
   260|   void dispatchQueuedEvents() {
   261|     if (isDispatching.get()) {
   262|       return;
   263|     }
   264|     isDispatching.set(true);
   265|     try {
   266|       Queue<EventWithHandler> events = eventsToDispatch.get();
   267|       EventWithHandler eventWithHandler;
   268|       while ((eventWithHandler = events.poll()) != null) {
   269|         dispatch(eventWithHandler.event, eventWithHandler.handler);
   270|       }
   271|     } finally {
   272|       isDispatching.remove();
   273|     }
   274|   }
   275|   /**
   276|    * Dispatches {@code event} to the handler in {@code wrapper}.  This method
   277|    * is an appropriate override point for subclasses that wish to make
   278|    * event delivery asynchronous.
   279|    *
   280|    * @param event  event to dispatch.
   281|    * @param wrapper  wrapper that will call the handler.
   282|    */
   283|   void dispatch(Object event, EventHandler wrapper) {
   284|     try {
   285|       wrapper.handleEvent(event);
   286|     } catch (InvocationTargetException e) {
   287|       logger.log(Level.SEVERE,
   288|           "Could not dispatch event: " + event + " to handler " + wrapper, e);
   289|     }
   290|   }
   291|   /**
   292|    * Flattens a class's type hierarchy into a set of Class objects.  The set


# ====================================================================
# FILE: guava/src/com/google/common/util/concurrent/Futures.java
# Total hunks: 5
# ====================================================================
# --- HUNK 1: Lines 41-95 ---
    41| import java.util.concurrent.Future;
    42| import java.util.concurrent.TimeUnit;
    43| import java.util.concurrent.TimeoutException;
    44| import java.util.concurrent.atomic.AtomicInteger;
    45| import java.util.logging.Level;
    46| import java.util.logging.Logger;
    47| import javax.annotation.Nullable;
    48| /**
    49|  * Static utility methods pertaining to the {@link Future} interface.
    50|  *
    51|  * <p>Many of these methods use the {@link ListenableFuture} API; consult the
    52|  * Guava User Guide article on <a href=
    53|  * "http://code.google.com/p/guava-libraries/wiki/ListenableFutureExplained">
    54|  * {@code ListenableFuture}</a>.
    55|  *
    56|  * @author Kevin Bourrillion
    57|  * @author Nishant Thakkar
    58|  * @author Sven Mawson
    59|  * @since 1.0
    60|  */
    61| public final class Futures {
    62|   private Futures() {}
    63|   /**
    64|    * Creates a {@link CheckedFuture} out of a normal {@link ListenableFuture}
    65|    * and a {@link Function} that maps from {@link Exception} instances into the
    66|    * appropriate checked type.
    67|    *
    68|    * <p>The given mapping function will be applied to an
    69|    * {@link InterruptedException}, a {@link CancellationException}, or an
    70|    * {@link ExecutionException}.
    71|    * See {@link Future#get()} for details on the exceptions thrown.
    72|    *
    73|    * @since 9.0 (source-compatible since 1.0)
    74|    */
    75|   @Beta
    76|   public static <V, X extends Exception> CheckedFuture<V, X> makeChecked(
    77|       ListenableFuture<V> future, Function<Exception, X> mapper) {
    78|     return new MappingCheckedFuture<V, X>(checkNotNull(future), mapper);
    79|   }
    80|   private abstract static class ImmediateFuture<V>
    81|       implements ListenableFuture<V> {
    82|     private static final Logger log =
    83|         Logger.getLogger(ImmediateFuture.class.getName());
    84|     @Override
    85|     public void addListener(Runnable listener, Executor executor) {
    86|       checkNotNull(listener, "Runnable was null.");
    87|       checkNotNull(executor, "Executor was null.");
    88|       try {
    89|         executor.execute(listener);
    90|       } catch (RuntimeException e) {
    91|         log.log(Level.SEVERE, "RuntimeException while executing runnable "
    92|             + listener + " with executor " + executor, e);
    93|       }
    94|     }
    95|     @Override

# --- HUNK 2: Lines 187-266 ---
   187|       throw thrown;
   188|     }
   189|   }
   190|   /**
   191|    * Creates a {@code ListenableFuture} which has its value set immediately upon
   192|    * construction. The getters just return the value. This {@code Future} can't
   193|    * be canceled or timed out and its {@code isDone()} method always returns
   194|    * {@code true}.
   195|    */
   196|   public static <V> ListenableFuture<V> immediateFuture(@Nullable V value) {
   197|     return new ImmediateSuccessfulFuture<V>(value);
   198|   }
   199|   /**
   200|    * Returns a {@code CheckedFuture} which has its value set immediately upon
   201|    * construction.
   202|    *
   203|    * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()}
   204|    * method always returns {@code true}. Calling {@code get()} or {@code
   205|    * checkedGet()} will immediately return the provided value.
   206|    */
   207|   @Beta
   208|   public static <V, X extends Exception> CheckedFuture<V, X>
   209|       immediateCheckedFuture(@Nullable V value) {
   210|     return new ImmediateSuccessfulCheckedFuture<V, X>(value);
   211|   }
   212|   /**
   213|    * Returns a {@code ListenableFuture} which has an exception set immediately
   214|    * upon construction.
   215|    *
   216|    * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()}
   217|    * method always returns {@code true}. Calling {@code get()} will immediately
   218|    * throw the provided {@code Throwable} wrapped in an {@code
   219|    * ExecutionException}.
   220|    */
   221|   public static <V> ListenableFuture<V> immediateFailedFuture(
   222|       Throwable throwable) {
   223|     checkNotNull(throwable);
   224|     return new ImmediateFailedFuture<V>(throwable);
   225|   }
   226|   /**
   227|    * Creates a {@code ListenableFuture} which is cancelled immediately upon
   228|    * construction, so that {@code isCancelled()} always returns {@code true}.
   229|    *
   230|    * @since 14.0
   231|    */
   232|   @Beta
   233|   public static <V> ListenableFuture<V> immediateCancelledFuture() {
   234|     return new ImmediateCancelledFuture<V>();
   235|   }
   236|   /**
   237|    * Returns a {@code CheckedFuture} which has an exception set immediately upon
   238|    * construction.
   239|    *
   240|    * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()}
   241|    * method always returns {@code true}. Calling {@code get()} will immediately
   242|    * throw the provided {@code Exception} wrapped in an {@code
   243|    * ExecutionException}, and calling {@code checkedGet()} will throw the
   244|    * provided exception itself.
   245|    */
   246|   @Beta
   247|   public static <V, X extends Exception> CheckedFuture<V, X>
   248|       immediateFailedCheckedFuture(X exception) {
   249|     checkNotNull(exception);
   250|     return new ImmediateFailedCheckedFuture<V, X>(exception);
   251|   }
   252|   /**
   253|    * Returns a {@code Future} whose result is taken from the given primary
   254|    * {@code input} or, if the primary input fails, from the {@code Future}
   255|    * provided by the {@code fallback}. {@link FutureFallback#create} is not
   256|    * invoked until the primary input has failed, so if the primary input
   257|    * succeeds, it is never invoked. If, during the invocation of {@code
   258|    * fallback}, an exception is thrown, this exception is used as the result of
   259|    * the output {@code Future}.
   260|    *
   261|    * <p>Below is an example of a fallback that returns a default value if an
   262|    * exception occurs:
   263|    *
   264|    * <pre>   {@code
   265|    *   ListenableFuture<Integer> fetchCounterFuture = ...;
   266|    *

# --- HUNK 3: Lines 306-346 ---
   306|    *
   307|    * <ul>
   308|    * <li>If the input {@code Future} is done at the time {@code withFallback}
   309|    * is called, {@code withFallback} will call {@code fallback.create} inline.
   310|    * <li>If the input {@code Future} is not yet done, {@code withFallback} will
   311|    * schedule {@code fallback.create} to be run by the thread that completes
   312|    * the input {@code Future}, which may be an internal system thread such as
   313|    * an RPC network thread.
   314|    * </ul>
   315|    *
   316|    * Also note that, regardless of which thread executes {@code
   317|    * fallback.create}, all other registered but unexecuted listeners are
   318|    * prevented from running during its execution, even if those listeners are
   319|    * to run in other executors.
   320|    *
   321|    * @param input the primary input {@code Future}
   322|    * @param fallback the {@link FutureFallback} implementation to be called if
   323|    *     {@code input} fails
   324|    * @since 14.0
   325|    */
   326|   @Beta
   327|   public static <V> ListenableFuture<V> withFallback(
   328|       ListenableFuture<? extends V> input,
   329|       FutureFallback<? extends V> fallback) {
   330|     return withFallback(input, fallback, sameThreadExecutor());
   331|   }
   332|   /**
   333|    * Returns a {@code Future} whose result is taken from the given primary
   334|    * {@code input} or, if the primary input fails, from the {@code Future}
   335|    * provided by the {@code fallback}. {@link FutureFallback#create} is not
   336|    * invoked until the primary input has failed, so if the primary input
   337|    * succeeds, it is never invoked. If, during the invocation of {@code
   338|    * fallback}, an exception is thrown, this exception is used as the result of
   339|    * the output {@code Future}.
   340|    *
   341|    * <p>Below is an example of a fallback that returns a default value if an
   342|    * exception occurs:
   343|    *
   344|    * <pre>   {@code
   345|    *   ListenableFuture<Integer> fetchCounterFuture = ...;
   346|    *

# --- HUNK 4: Lines 372-412 ---
   372|    *           }
   373|    *           return immediateFailedFuture(t);
   374|    *         }
   375|    *       }, sameThreadExecutor());
   376|    * }</pre>
   377|    *
   378|    * When the execution of {@code fallback.create} is fast and lightweight
   379|    * (though the {@code Future} it returns need not meet these criteria),
   380|    * consider {@linkplain #withFallback(ListenableFuture, FutureFallback)
   381|    * omitting the executor} or explicitly specifying {@code
   382|    * sameThreadExecutor}. However, be aware of the caveats documented in the
   383|    * link above.
   384|    *
   385|    * @param input the primary input {@code Future}
   386|    * @param fallback the {@link FutureFallback} implementation to be called if
   387|    *     {@code input} fails
   388|    * @param executor the executor that runs {@code fallback} if {@code input}
   389|    *     fails
   390|    * @since 14.0
   391|    */
   392|   @Beta
   393|   public static <V> ListenableFuture<V> withFallback(
   394|       ListenableFuture<? extends V> input,
   395|       FutureFallback<? extends V> fallback, Executor executor) {
   396|     checkNotNull(fallback);
   397|     return new FallbackFuture<V>(input, fallback, executor);
   398|   }
   399|   /**
   400|    * A future that falls back on a second, generated future, in case its
   401|    * original future fails.
   402|    */
   403|   private static class FallbackFuture<V> extends AbstractFuture<V> {
   404|     private volatile ListenableFuture<? extends V> running;
   405|     FallbackFuture(ListenableFuture<? extends V> input,
   406|         final FutureFallback<? extends V> fallback,
   407|         final Executor executor) {
   408|       running = input;
   409|       addCallback(running, new FutureCallback<V>() {
   410|         @Override
   411|         public void onSuccess(V value) {
   412|           set(value);

