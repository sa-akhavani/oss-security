# ====================================================================
# FILE: guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/FluentIterable.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 164-207 ---
   164|   /**
   165|    * Returns a fluent iterable that applies {@code function} to each element of this
   166|    * fluent iterable.
   167|    *
   168|    * <p>The returned fluent iterable's iterator supports {@code remove()} if this iterable's
   169|    * iterator does. After a successful {@code remove()} call, this fluent iterable no longer
   170|    * contains the corresponding element.
   171|    */
   172|   public final <T> FluentIterable<T> transform(Function<? super E, T> function) {
   173|     return from(Iterables.transform(iterable, function));
   174|   }
   175|   /**
   176|    * Applies {@code function} to each element of this fluent iterable and returns
   177|    * a fluent iterable with the concatenated combination of results.  {@code function}
   178|    * returns an Iterable of results.
   179|    *
   180|    * <p>The returned fluent iterable's iterator supports {@code remove()} if this
   181|    * function-returned iterables' iterator does. After a successful {@code remove()} call,
   182|    * the returned fluent iterable no longer contains the corresponding element.
   183|    *
   184|    * @since 13.0 (required {@code Function<E, Iterable<T>>} until 14.0)
   185|    */
   186|   public <T> FluentIterable<T> transformAndConcat(
   187|       Function<? super E, ? extends Iterable<? extends T>> function) {
   188|     return from(Iterables.concat(transform(function)));
   189|   }
   190|   /**
   191|    * Returns an {@link Optional} containing the first element in this fluent iterable.
   192|    * If the iterable is empty, {@code Optional.absent()} is returned.
   193|    *
   194|    * @throws NullPointerException if the first element is null; if this is a possibility, use
   195|    *     {@code iterator().next()} or {@link Iterables#getFirst} instead.
   196|    */
   197|   public final Optional<E> first() {
   198|     Iterator<E> iterator = iterable.iterator();
   199|     return iterator.hasNext()
   200|         ? Optional.of(iterator.next())
   201|         : Optional.<E>absent();
   202|   }
   203|   /**
   204|    * Returns an {@link Optional} containing the last element in this fluent iterable.
   205|    * If the iterable is empty, {@code Optional.absent()} is returned.
   206|    *
   207|    * @throws NullPointerException if the last element is null; if this is a possibility, use


# ====================================================================
# FILE: guava/src/com/google/common/collect/FluentIterable.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 174-217 ---
   174|   /**
   175|    * Returns a fluent iterable that applies {@code function} to each element of this
   176|    * fluent iterable.
   177|    *
   178|    * <p>The returned fluent iterable's iterator supports {@code remove()} if this iterable's
   179|    * iterator does. After a successful {@code remove()} call, this fluent iterable no longer
   180|    * contains the corresponding element.
   181|    */
   182|   public final <T> FluentIterable<T> transform(Function<? super E, T> function) {
   183|     return from(Iterables.transform(iterable, function));
   184|   }
   185|   /**
   186|    * Applies {@code function} to each element of this fluent iterable and returns
   187|    * a fluent iterable with the concatenated combination of results.  {@code function}
   188|    * returns an Iterable of results.
   189|    *
   190|    * <p>The returned fluent iterable's iterator supports {@code remove()} if this
   191|    * function-returned iterables' iterator does. After a successful {@code remove()} call,
   192|    * the returned fluent iterable no longer contains the corresponding element.
   193|    *
   194|    * @since 13.0 (required {@code Function<E, Iterable<T>>} until 14.0)
   195|    */
   196|   public <T> FluentIterable<T> transformAndConcat(
   197|       Function<? super E, ? extends Iterable<? extends T>> function) {
   198|     return from(Iterables.concat(transform(function)));
   199|   }
   200|   /**
   201|    * Returns an {@link Optional} containing the first element in this fluent iterable.
   202|    * If the iterable is empty, {@code Optional.absent()} is returned.
   203|    *
   204|    * @throws NullPointerException if the first element is null; if this is a possibility, use
   205|    *     {@code iterator().next()} or {@link Iterables#getFirst} instead.
   206|    */
   207|   public final Optional<E> first() {
   208|     Iterator<E> iterator = iterable.iterator();
   209|     return iterator.hasNext()
   210|         ? Optional.of(iterator.next())
   211|         : Optional.<E>absent();
   212|   }
   213|   /**
   214|    * Returns an {@link Optional} containing the last element in this fluent iterable.
   215|    * If the iterable is empty, {@code Optional.absent()} is returned.
   216|    *
   217|    * @throws NullPointerException if the last element is null; if this is a possibility, use


# ====================================================================
# FILE: guava/src/com/google/common/eventbus/EventBus.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 253-293 ---
   253|   void enqueueEvent(Object event, EventHandler handler) {
   254|     eventsToDispatch.get().offer(new EventWithHandler(event, handler));
   255|   }
   256|   /**
   257|    * Drain the queue of events to be dispatched. As the queue is being drained,
   258|    * new events may be posted to the end of the queue.
   259|    */
   260|   void dispatchQueuedEvents() {
   261|     if (isDispatching.get()) {
   262|       return;
   263|     }
   264|     isDispatching.set(true);
   265|     try {
   266|       Queue<EventWithHandler> events = eventsToDispatch.get();
   267|       EventWithHandler eventWithHandler;
   268|       while ((eventWithHandler = events.poll()) != null) {
   269|         dispatch(eventWithHandler.event, eventWithHandler.handler);
   270|       }
   271|     } finally {
   272|       isDispatching.remove();
   273|       eventsToDispatch.remove();
   274|     }
   275|   }
   276|   /**
   277|    * Dispatches {@code event} to the handler in {@code wrapper}.  This method
   278|    * is an appropriate override point for subclasses that wish to make
   279|    * event delivery asynchronous.
   280|    *
   281|    * @param event  event to dispatch.
   282|    * @param wrapper  wrapper that will call the handler.
   283|    */
   284|   void dispatch(Object event, EventHandler wrapper) {
   285|     try {
   286|       wrapper.handleEvent(event);
   287|     } catch (InvocationTargetException e) {
   288|       logger.log(Level.SEVERE,
   289|           "Could not dispatch event: " + event + " to handler " + wrapper, e);
   290|     }
   291|   }
   292|   /**
   293|    * Flattens a class's type hierarchy into a set of Class objects.  The set


# ====================================================================
# FILE: guava/src/com/google/common/util/concurrent/Futures.java
# Total hunks: 5
# ====================================================================
# --- HUNK 1: Lines 41-95 ---
    41| import java.util.concurrent.Future;
    42| import java.util.concurrent.TimeUnit;
    43| import java.util.concurrent.TimeoutException;
    44| import java.util.concurrent.atomic.AtomicInteger;
    45| import java.util.logging.Level;
    46| import java.util.logging.Logger;
    47| import javax.annotation.Nullable;
    48| /**
    49|  * Static utility methods pertaining to the {@link Future} interface.
    50|  *
    51|  * <p>Many of these methods use the {@link ListenableFuture} API; consult the
    52|  * Guava User Guide article on <a href=
    53|  * "http://code.google.com/p/guava-libraries/wiki/ListenableFutureExplained">
    54|  * {@code ListenableFuture}</a>.
    55|  *
    56|  * @author Kevin Bourrillion
    57|  * @author Nishant Thakkar
    58|  * @author Sven Mawson
    59|  * @since 1.0
    60|  */
    61| @Beta
    62| public final class Futures {
    63|   private Futures() {}
    64|   /**
    65|    * Creates a {@link CheckedFuture} out of a normal {@link ListenableFuture}
    66|    * and a {@link Function} that maps from {@link Exception} instances into the
    67|    * appropriate checked type.
    68|    *
    69|    * <p>The given mapping function will be applied to an
    70|    * {@link InterruptedException}, a {@link CancellationException}, or an
    71|    * {@link ExecutionException}.
    72|    * See {@link Future#get()} for details on the exceptions thrown.
    73|    *
    74|    * @since 9.0 (source-compatible since 1.0)
    75|    */
    76|   public static <V, X extends Exception> CheckedFuture<V, X> makeChecked(
    77|       ListenableFuture<V> future, Function<Exception, X> mapper) {
    78|     return new MappingCheckedFuture<V, X>(checkNotNull(future), mapper);
    79|   }
    80|   private abstract static class ImmediateFuture<V>
    81|       implements ListenableFuture<V> {
    82|     private static final Logger log =
    83|         Logger.getLogger(ImmediateFuture.class.getName());
    84|     @Override
    85|     public void addListener(Runnable listener, Executor executor) {
    86|       checkNotNull(listener, "Runnable was null.");
    87|       checkNotNull(executor, "Executor was null.");
    88|       try {
    89|         executor.execute(listener);
    90|       } catch (RuntimeException e) {
    91|         log.log(Level.SEVERE, "RuntimeException while executing runnable "
    92|             + listener + " with executor " + executor, e);
    93|       }
    94|     }
    95|     @Override

# --- HUNK 2: Lines 187-263 ---
   187|       throw thrown;
   188|     }
   189|   }
   190|   /**
   191|    * Creates a {@code ListenableFuture} which has its value set immediately upon
   192|    * construction. The getters just return the value. This {@code Future} can't
   193|    * be canceled or timed out and its {@code isDone()} method always returns
   194|    * {@code true}.
   195|    */
   196|   public static <V> ListenableFuture<V> immediateFuture(@Nullable V value) {
   197|     return new ImmediateSuccessfulFuture<V>(value);
   198|   }
   199|   /**
   200|    * Returns a {@code CheckedFuture} which has its value set immediately upon
   201|    * construction.
   202|    *
   203|    * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()}
   204|    * method always returns {@code true}. Calling {@code get()} or {@code
   205|    * checkedGet()} will immediately return the provided value.
   206|    */
   207|   public static <V, X extends Exception> CheckedFuture<V, X>
   208|       immediateCheckedFuture(@Nullable V value) {
   209|     return new ImmediateSuccessfulCheckedFuture<V, X>(value);
   210|   }
   211|   /**
   212|    * Returns a {@code ListenableFuture} which has an exception set immediately
   213|    * upon construction.
   214|    *
   215|    * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()}
   216|    * method always returns {@code true}. Calling {@code get()} will immediately
   217|    * throw the provided {@code Throwable} wrapped in an {@code
   218|    * ExecutionException}.
   219|    */
   220|   public static <V> ListenableFuture<V> immediateFailedFuture(
   221|       Throwable throwable) {
   222|     checkNotNull(throwable);
   223|     return new ImmediateFailedFuture<V>(throwable);
   224|   }
   225|   /**
   226|    * Creates a {@code ListenableFuture} which is cancelled immediately upon
   227|    * construction, so that {@code isCancelled()} always returns {@code true}.
   228|    *
   229|    * @since 14.0
   230|    */
   231|   public static <V> ListenableFuture<V> immediateCancelledFuture() {
   232|     return new ImmediateCancelledFuture<V>();
   233|   }
   234|   /**
   235|    * Returns a {@code CheckedFuture} which has an exception set immediately upon
   236|    * construction.
   237|    *
   238|    * <p>The returned {@code Future} can't be cancelled, and its {@code isDone()}
   239|    * method always returns {@code true}. Calling {@code get()} will immediately
   240|    * throw the provided {@code Exception} wrapped in an {@code
   241|    * ExecutionException}, and calling {@code checkedGet()} will throw the
   242|    * provided exception itself.
   243|    */
   244|   public static <V, X extends Exception> CheckedFuture<V, X>
   245|       immediateFailedCheckedFuture(X exception) {
   246|     checkNotNull(exception);
   247|     return new ImmediateFailedCheckedFuture<V, X>(exception);
   248|   }
   249|   /**
   250|    * Returns a {@code Future} whose result is taken from the given primary
   251|    * {@code input} or, if the primary input fails, from the {@code Future}
   252|    * provided by the {@code fallback}. {@link FutureFallback#create} is not
   253|    * invoked until the primary input has failed, so if the primary input
   254|    * succeeds, it is never invoked. If, during the invocation of {@code
   255|    * fallback}, an exception is thrown, this exception is used as the result of
   256|    * the output {@code Future}.
   257|    *
   258|    * <p>Below is an example of a fallback that returns a default value if an
   259|    * exception occurs:
   260|    *
   261|    * <pre>   {@code
   262|    *   ListenableFuture<Integer> fetchCounterFuture = ...;
   263|    *

# --- HUNK 3: Lines 303-342 ---
   303|    *
   304|    * <ul>
   305|    * <li>If the input {@code Future} is done at the time {@code withFallback}
   306|    * is called, {@code withFallback} will call {@code fallback.create} inline.
   307|    * <li>If the input {@code Future} is not yet done, {@code withFallback} will
   308|    * schedule {@code fallback.create} to be run by the thread that completes
   309|    * the input {@code Future}, which may be an internal system thread such as
   310|    * an RPC network thread.
   311|    * </ul>
   312|    *
   313|    * Also note that, regardless of which thread executes {@code
   314|    * fallback.create}, all other registered but unexecuted listeners are
   315|    * prevented from running during its execution, even if those listeners are
   316|    * to run in other executors.
   317|    *
   318|    * @param input the primary input {@code Future}
   319|    * @param fallback the {@link FutureFallback} implementation to be called if
   320|    *     {@code input} fails
   321|    * @since 14.0
   322|    */
   323|   public static <V> ListenableFuture<V> withFallback(
   324|       ListenableFuture<? extends V> input,
   325|       FutureFallback<? extends V> fallback) {
   326|     return withFallback(input, fallback, sameThreadExecutor());
   327|   }
   328|   /**
   329|    * Returns a {@code Future} whose result is taken from the given primary
   330|    * {@code input} or, if the primary input fails, from the {@code Future}
   331|    * provided by the {@code fallback}. {@link FutureFallback#create} is not
   332|    * invoked until the primary input has failed, so if the primary input
   333|    * succeeds, it is never invoked. If, during the invocation of {@code
   334|    * fallback}, an exception is thrown, this exception is used as the result of
   335|    * the output {@code Future}.
   336|    *
   337|    * <p>Below is an example of a fallback that returns a default value if an
   338|    * exception occurs:
   339|    *
   340|    * <pre>   {@code
   341|    *   ListenableFuture<Integer> fetchCounterFuture = ...;
   342|    *

# --- HUNK 4: Lines 368-407 ---
   368|    *           }
   369|    *           return immediateFailedFuture(t);
   370|    *         }
   371|    *       }, sameThreadExecutor());
   372|    * }</pre>
   373|    *
   374|    * When the execution of {@code fallback.create} is fast and lightweight
   375|    * (though the {@code Future} it returns need not meet these criteria),
   376|    * consider {@linkplain #withFallback(ListenableFuture, FutureFallback)
   377|    * omitting the executor} or explicitly specifying {@code
   378|    * sameThreadExecutor}. However, be aware of the caveats documented in the
   379|    * link above.
   380|    *
   381|    * @param input the primary input {@code Future}
   382|    * @param fallback the {@link FutureFallback} implementation to be called if
   383|    *     {@code input} fails
   384|    * @param executor the executor that runs {@code fallback} if {@code input}
   385|    *     fails
   386|    * @since 14.0
   387|    */
   388|   public static <V> ListenableFuture<V> withFallback(
   389|       ListenableFuture<? extends V> input,
   390|       FutureFallback<? extends V> fallback, Executor executor) {
   391|     checkNotNull(fallback);
   392|     return new FallbackFuture<V>(input, fallback, executor);
   393|   }
   394|   /**
   395|    * A future that falls back on a second, generated future, in case its
   396|    * original future fails.
   397|    */
   398|   private static class FallbackFuture<V> extends AbstractFuture<V> {
   399|     private volatile ListenableFuture<? extends V> running;
   400|     FallbackFuture(ListenableFuture<? extends V> input,
   401|         final FutureFallback<? extends V> fallback,
   402|         final Executor executor) {
   403|       running = input;
   404|       addCallback(running, new FutureCallback<V>() {
   405|         @Override
   406|         public void onSuccess(V value) {
   407|           set(value);

