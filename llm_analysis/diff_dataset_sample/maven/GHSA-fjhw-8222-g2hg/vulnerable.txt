# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/Version.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 4-33 ---
     4|  *
     5|  * Licensed under the Apache License, Version 2.0 (the "License");
     6|  * you may not use this file except in compliance with the License.
     7|  * You may obtain a copy of the License at
     8|  *
     9|  *       http://www.apache.org/licenses/LICENSE-2.0
    10|  *
    11|  * Unless required by applicable law or agreed to in writing, software
    12|  * distributed under the License is distributed on an "AS IS" BASIS,
    13|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    14|  * See the License for the specific language governing permissions and
    15|  * limitations under the License.
    16|  */
    17| /**
    18|  * Class holding the version of this agent and the protocol.
    19|  *
    20|  * @author roland
    21|  * @since Jun 11, 2009
    22|  */
    23| public final class Version {
    24|     private static final String VERSION = "1.2.0";
    25|     private static final String PROTOCOL = "7.1";
    26|     private Version() {}
    27|     public static String getAgentVersion() {
    28|         return VERSION;
    29|     }
    30|     public static String getProtocolVersion() {
    31|         return PROTOCOL;
    32|     }
    33| }


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/backend/BackendManager.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 151-194 ---
   151|         try {
   152|             localDispatcher.destroy();
   153|         } catch (JMException e) {
   154|             error("Cannot unregister MBean: " + e,e);
   155|         }
   156|     }
   157|     /**
   158|      * Check whether remote access from the given client is allowed.
   159|      *
   160|      * @param pRemoteHost remote host to check against
   161|      * @param pRemoteAddr alternative IP address
   162|      * @return true if remote access is allowed
   163|      */
   164|     public boolean isRemoteAccessAllowed(String pRemoteHost, String pRemoteAddr) {
   165|         return restrictor.isRemoteAccessAllowed(pRemoteHost, pRemoteAddr);
   166|     }
   167|     /**
   168|      * Check whether CORS access is allowed for the given origin.
   169|      *
   170|      * @param pOrigin origin URL which needs to be checked
   171|      * @return true if icors access is allowed
   172|      */
   173|     public boolean isCorsAccessAllowed(String pOrigin) {
   174|         return restrictor.isCorsAccessAllowed(pOrigin);
   175|     }
   176|     /**
   177|      * Log at info level
   178|      *
   179|      * @param msg to log
   180|      */
   181|     public void info(String msg) {
   182|         logHandler.info(msg);
   183|         if (debugStore != null) {
   184|             debugStore.log(msg);
   185|         }
   186|     }
   187|     /**
   188|      * Log at debug level
   189|      *
   190|      * @param msg message to log
   191|      */
   192|     public void debug(String msg) {
   193|         logHandler.debug(msg);
   194|         if (debugStore != null) {


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/config/ConfigKey.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 105-144 ---
   105|      * <code>application/json</code>, too. A request parameter overrides a global
   106|      * configuration.
   107|      */
   108|     MIME_TYPE("mimeType", true, true, "text/plain"),
   109|     /**
   110|      * For LIST requests, this option can be used to return
   111|      * the result only if they set of registered MBeans has
   112|      * been changed since the timestamp given in this option.
   113|      * The timestamp has to be given in seconds since 1.1.1970
   114|      * (epoch time).
   115|      */
   116|     IF_MODIFIED_SINCE("ifModifiedSince",false,true),
   117|     /**
   118|      * Whether to enable listening and responding to discovery multicast requests
   119|      * for discovering agent details.
   120|      */
   121|     DISCOVERY_ENABLED("discoveryEnabled",true,false),
   122|     /**
   123|      * Specify the agent URL to return for an discovery multicast request. If this option
   124|      * is given {@link #DISCOVERY_ENABLED} is set to <code>true</code> automatically.
   125|      */
   126|     DISCOVERY_AGENT_URL("discoveryAgentUrl",true,false),
   127|     /**
   128|      *  User for authentication purposes. Used by OSGi and JDK agent.
   129|      */
   130|     USER("user", true, false),
   131|     /**
   132|      *  Password for authentication purposes. Used by OSGi and JDK agent
   133|      */
   134|     PASSWORD("password", true, false),
   135|     /**
   136|      * Custom authenticator to be used instead of default user/password one
   137|      */
   138|     AUTHENTICATOR_CLASS("authenticatorClass", true, false),
   139|     /**
   140|      * Context used for agent, used e.g. in the OSGi activator
   141|      * (but not for the servlet, this is done in web.xml)
   142|      */
   143|     AGENT_CONTEXT("agentContext", true, false, "/jolokia"),
   144|     /**


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/detector/ServerDetector.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 13-46 ---
    13|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    14|  * See the License for the specific language governing permissions and
    15|  * limitations under the License.
    16|  */
    17| import java.util.Set;
    18| import javax.management.MBeanServerConnection;
    19| import org.jolokia.backend.executor.MBeanServerExecutor;
    20| /**
    21|  * A detector identifies a specific server. This is typically done by inspecting
    22|  * the runtime environment e.g. for the existance of certain classes. If a detector
    23|  * successfully detect 'its' server, it return a {@link ServerHandle} containing type, version
    24|  * and some optional information
    25|  * @author roland
    26|  * @since 05.11.10
    27|  */
    28| public interface ServerDetector {
    29|     /**
    30|      * Detect the server. A {@link ServerHandle} descriptor is returned
    31|      * in case of a successful detection, <code>null</code> otherwise.
    32|      *
    33|      *
    34|      *
    35|      *
    36|      * @param pMBeanServerExecutor a set of MBeanServers which can be used for detecting server informations
    37|      * @return the server descriptor or <code>null</code> it this implementation cant detect 'its' server.
    38|      */
    39|     ServerHandle detect(MBeanServerExecutor pMBeanServerExecutor);
    40|     /**
    41|      * Add server specific MBeanServers
    42|      *
    43|      * @param pMBeanServers set to add detected MBeanServers to
    44|      */
    45|     void addMBeanServers(Set<MBeanServerConnection> pMBeanServers);
    46| }


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/detector/WeblogicDetector.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 26-56 ---
    26|  * @author roland
    27|  * @since 05.12.10
    28|  */
    29| public class WeblogicDetector extends AbstractServerDetector {
    30|     /** {@inheritDoc}
    31|      * @param pMBeanServerExecutor*/
    32|     public ServerHandle detect(MBeanServerExecutor pMBeanServerExecutor) {
    33|         String domainConfigMBean = getSingleStringAttribute(pMBeanServerExecutor,"*:Name=RuntimeService,*","DomainConfiguration");
    34|         if (domainConfigMBean != null) {
    35|             String version = getSingleStringAttribute(pMBeanServerExecutor,domainConfigMBean,"ConfigurationVersion");
    36|             return new ServerHandle("Oracle","weblogic",version, null);
    37|         }
    38|         return null;
    39|     }
    40|     /**
    41|      * Adde Weblogic specific runtime MBeanServer
    42|      * @param servers set to add own MBean servers
    43|      */
    44|     @Override
    45|     public void addMBeanServers(Set<MBeanServerConnection> servers) {
    46|         InitialContext ctx;
    47|         try {
    48|             ctx = new InitialContext();
    49|             MBeanServer server = (MBeanServer) ctx.lookup("java:comp/env/jmx/runtime");
    50|             if (server != null) {
    51|                 servers.add(server);
    52|             }
    53|         } catch (NamingException e) {
    54|         }
    55|     }
    56| }


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/discovery/DiscoveryMulticastResponder.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 44-84 ---
    44|                                        AgentDetailsHolder pDetailsHolder,
    45|                                        Restrictor pRestrictor,
    46|                                        LogHandler pLogHandler) {
    47|         hostAddress = pHostAddress;
    48|         detailsHolder = pDetailsHolder;
    49|         restrictor = pRestrictor;
    50|         logHandler = pLogHandler;
    51|         listenerThreads = new ArrayList<MulticastSocketListenerThread>();
    52|     }
    53|     /**
    54|      * Start the responder (if not already started)
    55|      */
    56|     public synchronized void start() throws IOException {
    57|         if (listenerThreads.size() == 0) {
    58|             List<InetAddress> addresses = hostAddress == null ? NetworkUtil.getMulticastAddresses() : Arrays.asList(hostAddress);
    59|             if (addresses.size() == 0) {
    60|                 logHandler.info("No suitable address found for listening on multicast discovery requests");
    61|                 return;
    62|             }
    63|             for (InetAddress addr : addresses) {
    64|                 MulticastSocketListenerThread thread = new MulticastSocketListenerThread(addr,
    65|                                                                                          detailsHolder,
    66|                                                                                          restrictor,
    67|                                                                                          logHandler);
    68|                 thread.start();
    69|                 listenerThreads.add(thread);
    70|             }
    71|         }
    72|     }
    73|     /**
    74|      * Stop the responder (if not already stopped). Can be restarted aftewards.
    75|      */
    76|     public synchronized void stop() {
    77|         if (listenerThreads.size() > 0) {
    78|             for (MulticastSocketListenerThread thread : listenerThreads) {
    79|                 thread.shutdown();
    80|             }
    81|         }
    82|         listenerThreads.clear();
    83|     }
    84| }


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/discovery/MulticastSocketListenerThread.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 16-57 ---
    16|     private final Restrictor restrictor;
    17|     private final LogHandler logHandler;
    18|     private final InetAddress address;
    19|     private boolean running;
    20|     private MulticastSocket socket;
    21|     /**
    22|      * Constructor, used internally.
    23|      *
    24|      * @param pHostAddress host address for creating a socket to listen to
    25|      * @param pAgentDetailsHolder the holder which has the agent details
    26|      * @param pRestrictor restrictor to check whether an incoming package should be answered which
    27|      *                    is done only when {@link Restrictor#isRemoteAccessAllowed(String...)} returns true for
    28|      *                    the address from which the packet was received.
    29|      * @param pLogHandler log handler used for logging
    30|      */
    31|     MulticastSocketListenerThread(InetAddress pHostAddress, AgentDetailsHolder pAgentDetailsHolder, Restrictor pRestrictor, LogHandler pLogHandler) throws IOException {
    32|         address = pHostAddress != null ? pHostAddress : NetworkUtil.getLocalAddressWithMulticast();
    33|         agentDetailsHolder = pAgentDetailsHolder;
    34|         restrictor = pRestrictor;
    35|         logHandler = pLogHandler;
    36|         logHandler.debug(address + "<-- Listening for queries");
    37|         socket = MulticastUtil.newMulticastSocket(address);
    38|     }
    39|     /** {@inheritDoc} */
    40|     public void run() {
    41|         setRunning(true);
    42|         try {
    43|             while (isRunning()) {
    44|                 refreshSocket();
    45|                 logHandler.debug(address + "<-- Waiting");
    46|                 DiscoveryIncomingMessage msg = receiveMessage();
    47|                 if (shouldMessageBeProcessed(msg)) {
    48|                     handleQuery(msg);
    49|                 }
    50|             }
    51|         }
    52|         catch (IllegalStateException e) {
    53|             logHandler.error(address + "<-- Cannot reopen socket, exiting listener thread: " + e.getCause(),e.getCause());
    54|         } finally {
    55|             if (socket != null) {
    56|                 socket.close();
    57|             }

# --- HUNK 2: Lines 76-117 ---
    76|     }
    77|     private DiscoveryIncomingMessage receiveMessage() {
    78|         byte buf[] = new byte[AbstractDiscoveryMessage.MAX_MSG_SIZE];
    79|         DatagramPacket packet = new DatagramPacket(buf, buf.length);
    80|         try {
    81|             packet.setLength(buf.length);
    82|             socket.receive(packet);
    83|             return new DiscoveryIncomingMessage(packet);
    84|         }  catch (IOException e) {
    85|             if (!socket.isClosed()) {
    86|                 logHandler.info("Error while handling discovery request" + (packet.getAddress() != null ? " from " + packet.getAddress() : "") +
    87|                                 ". Ignoring this request. --> " + e);
    88|             }
    89|             return null;
    90|         }
    91|     }
    92|     private void refreshSocket() {
    93|         if (socket.isClosed()) {
    94|             logHandler.info(address + "<-- Socket closed, reopening it");
    95|             try {
    96|                 socket = MulticastUtil.newMulticastSocket(address);
    97|             } catch (IOException exp) {
    98|                 throw new SocketVerificationFailedException(exp);
    99|             }
   100|         }
   101|     }
   102|     private void handleQuery(DiscoveryIncomingMessage pMsg) {
   103|         DiscoveryOutgoingMessage answer =
   104|                 new DiscoveryOutgoingMessage.Builder(RESPONSE)
   105|                         .respondTo(pMsg)
   106|                         .agentDetails(agentDetailsHolder.getAgentDetails())
   107|                         .build();
   108|         logHandler.debug(address + "<-- Discovery request from " + pMsg.getSourceAddress() + ":" + pMsg.getSourcePort());
   109|         send(answer);
   110|     }
   111|     private void send(DiscoveryOutgoingMessage pAnswer) {
   112|         byte[] message = pAnswer.getData();
   113|         final DatagramPacket packet =
   114|                 new DatagramPacket(message, message.length,
   115|                                    pAnswer.getTargetAddress(),pAnswer.getTargetPort());
   116|         if (!socket.isClosed()) {
   117|             try {


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/discovery/MulticastUtil.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-46 ---
     1| package org.jolokia.discovery;
     2| import java.io.IOException;
     3| import java.net.*;
     4| import java.util.*;
     5| import java.util.concurrent.*;
     6| import org.jolokia.util.LogHandler;
     7| import org.jolokia.util.NetworkUtil;
     8| /**
     9|  * Utility class for handling multicast stuff
    10|  *
    11|  * @author roland
    12|  * @since 28.01.14
    13|  */
    14| public final class MulticastUtil {
    15|     public static final String JOLOKIA_MULTICAST_GROUP = "239.192.48.84";
    16|     public static final int JOLOKIA_MULTICAST_PORT = 24884;
    17|     private MulticastUtil() {
    18|     }
    19|     static MulticastSocket newMulticastSocket(InetAddress pAddress) throws IOException {
    20|         InetSocketAddress socketAddress =
    21|                 new InetSocketAddress(JOLOKIA_MULTICAST_GROUP, JOLOKIA_MULTICAST_PORT);
    22|         MulticastSocket socket = new MulticastSocket(JOLOKIA_MULTICAST_PORT);
    23|         socket.setReuseAddress(true);
    24|         setOutgoingInterfaceForMulticastRequest(pAddress, socket);
    25|         socket.setTimeToLive(255);
    26|         joinMcGroupsOnAllNetworkInterfaces(socket, socketAddress);
    27|         return socket;
    28|     }
    29|     /**
    30|      * Sent out a message to Jolokia's multicast group over all network interfaces supporting multicast request (and no
    31|      * logging is used)
    32|      *
    33|      * @param pOutMsg  the message to send
    34|      * @param pTimeout timeout used for how long to wait for discovery messages
    35|      * @return list of received answers, never null
    36|      * @throws IOException if something fails during the discovery request
    37|      */
    38|     public static List<DiscoveryIncomingMessage> sendQueryAndCollectAnswers(DiscoveryOutgoingMessage pOutMsg, int pTimeout) throws IOException {
    39|         return sendQueryAndCollectAnswers(pOutMsg, pTimeout, LogHandler.QUIET);
    40|     }
    41|     /**
    42|      * Sent out a message to Jolokia's multicast group over all network interfaces supporting multicasts
    43|      *
    44|      * @param pOutMsg     the message to send
    45|      * @param pTimeout    timeout used for how long to wait for discovery messages
    46|      * @param pLogHandler a log handler for printing out logging information

# --- HUNK 2: Lines 79-126 ---
    79|         Set<String> seen = new HashSet<String>();
    80|         for (Future<List<DiscoveryIncomingMessage>> future : pFutures) {
    81|             try {
    82|                 List<DiscoveryIncomingMessage> inMsgs = future.get(pTimeout + 500 /* some additional buffer */, TimeUnit.MILLISECONDS);
    83|                 for (DiscoveryIncomingMessage inMsg : inMsgs) {
    84|                     AgentDetails details = inMsg.getAgentDetails();
    85|                     String id = details.getAgentId();
    86|                     if (!seen.contains(id)) {
    87|                         ret.add(inMsg);
    88|                         seen.add(id);
    89|                     }
    90|                 }
    91|             } catch (InterruptedException exp) {
    92|             } catch (ExecutionException e) {
    93|                 pLogHandler.debug("--> Exception during lookup: " + e);
    94|             } catch (TimeoutException e) {
    95|             }
    96|         }
    97|         return ret;
    98|     }
    99|     private static void joinMcGroupsOnAllNetworkInterfaces(MulticastSocket pSocket, InetSocketAddress pSocketAddress) throws IOException {
   100|         Enumeration<NetworkInterface> nifs = NetworkInterface.getNetworkInterfaces();
   101|         while (nifs.hasMoreElements()) {
   102|             NetworkInterface n = nifs.nextElement();
   103|             if (NetworkUtil.isMulticastSupported(n)) {
   104|                 pSocket.joinGroup(pSocketAddress, n);
   105|             }
   106|         }
   107|     }
   108|     private static void setOutgoingInterfaceForMulticastRequest(InetAddress pAddress, MulticastSocket pSocket) throws SocketException, UnknownHostException {
   109|         NetworkInterface nif = NetworkInterface.getByInetAddress(pAddress);
   110|         if (nif != null) {
   111|             pSocket.setNetworkInterface(nif);
   112|         }
   113|     }
   114|     private static final class FindAgentsCallable implements Callable<List<DiscoveryIncomingMessage>> {
   115|         private final InetAddress address;
   116|         private final DatagramPacket outPacket;
   117|         private final int timeout;
   118|         private final LogHandler logHandler;
   119|         private FindAgentsCallable(InetAddress pAddress, DatagramPacket pOutPacket, int pTimeout, LogHandler pLogHandler) {
   120|             address = pAddress;
   121|             outPacket = pOutPacket;
   122|             timeout = pTimeout;
   123|             logHandler = pLogHandler;
   124|         }
   125|         public List<DiscoveryIncomingMessage> call() throws SocketException {
   126|             final DatagramSocket socket = new DatagramSocket(0, address);


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/handler/ReadHandler.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 51-91 ---
    51|                 }
    52|             };
    53|     /**
    54|      * Read handler constructor
    55|      *
    56|      * @param pRestrictor access restriction to apply
    57|      */
    58|     public ReadHandler(Restrictor pRestrictor) {
    59|         super(pRestrictor);
    60|     }
    61|     @Override
    62|     /** {@inheritDoc} */
    63|     public RequestType getType() {
    64|         return RequestType.READ;
    65|     }
    66|     /**
    67|      * For a simple requests (one MBean, one attribute) we let the dispatching of the servers
    68|      * done by the upper level. If the request is for an MBean pattern or multiple attributes
    69|      * are required, we try multiple requests for multiple server.
    70|      *
    71|      *
    72|      * @param pRequest request to decide on whether to handle all request at once
    73|      * @return true if this is a multi attribute request, has an MBean pattern to look for or is a request for
    74|      *         all attributes.
    75|      */
    76|     @Override
    77|     public boolean handleAllServersAtOnce(JmxReadRequest pRequest) {
    78|         return pRequest.getObjectName().isPattern() || pRequest.isMultiAttributeMode() || !pRequest.hasAttribute();
    79|     }
    80|     /**
    81|      * Used for a request to a single attribute from a single MBean. Merging of MBeanServers is done
    82|      * one layer above.
    83|      *
    84|      *
    85|      * @param pServer server on which to request the attribute
    86|      * @param pRequest the request itself.
    87|      * @return the attribute's value
    88|      */
    89|     @Override
    90|     public Object doHandleRequest(MBeanServerConnection pServer, JmxReadRequest pRequest)
    91|             throws InstanceNotFoundException, AttributeNotFoundException, ReflectionException, MBeanException, IOException {

# --- HUNK 2: Lines 169-213 ---
   169|                 ret.put(attribute, pFaultHandler.handleException(e));
   170|             } catch (ReflectionException e) {
   171|                 ret.put(attribute, pFaultHandler.handleException(e));
   172|             } catch (IOException e) {
   173|                 ret.put(attribute, pFaultHandler.handleException(e));
   174|             } catch (RuntimeException e) {
   175|                 ret.put(attribute, pFaultHandler.handleException(e));
   176|             }
   177|         }
   178|         return ret;
   179|     }
   180|     private List<String> resolveAttributes(MBeanServerExecutor pServers, ObjectName pMBeanName, List<String> pAttributeNames)
   181|             throws IOException, ReflectionException, MBeanException, AttributeNotFoundException, InstanceNotFoundException {
   182|         List<String> attributes = pAttributeNames;
   183|         if (shouldAllAttributesBeFetched(pAttributeNames)) {
   184|             attributes = getAllAttributesNames(pServers,pMBeanName);
   185|         }
   186|         return attributes;
   187|     }
   188|     private boolean shouldAllAttributesBeFetched(List<String> pAttributeNames) {
   189|        if (pAttributeNames == null || pAttributeNames.size() == 0) {
   190|            return true;
   191|        } else {
   192|            return pAttributeNames.size() == 1 && pAttributeNames.get(0) == null;
   193|        }
   194|     }
   195|     private MBeanInfo getMBeanInfo(MBeanServerExecutor pServerManager, ObjectName pObjectName)
   196|             throws IOException, ReflectionException, MBeanException, AttributeNotFoundException, InstanceNotFoundException {
   197|         return pServerManager.call(pObjectName, MBEAN_INFO_HANDLER);
   198|     }
   199|     private Object getAttribute(MBeanServerExecutor pServerManager, ObjectName pMBeanName, String attribute)
   200|             throws MBeanException, ReflectionException, IOException, AttributeNotFoundException, InstanceNotFoundException {
   201|         return pServerManager.call(pMBeanName, MBEAN_ATTRIBUTE_READ_HANDLER, attribute);
   202|     }
   203|     private List<String> getAllAttributesNames(MBeanServerExecutor pServerManager, ObjectName pObjectName)
   204|             throws IOException, ReflectionException, MBeanException, AttributeNotFoundException, InstanceNotFoundException {
   205|         MBeanInfo mBeanInfo = getMBeanInfo(pServerManager, pObjectName);
   206|         List<String> ret = new ArrayList<String>();
   207|         for (MBeanAttributeInfo attrInfo : mBeanInfo.getAttributes()) {
   208|             if (attrInfo.isReadable()) {
   209|                 ret.add(attrInfo.getName());
   210|             }
   211|         }
   212|         return ret;
   213|     }


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/http/AgentServlet.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 134-174 ---
   134|             } else {
   135|                 initAgentUrlFromRequest = false;
   136|                 backendManager.getAgentDetails().updateAgentParameters(url, null);
   137|             }
   138|             try {
   139|                 discoveryMulticastResponder = new DiscoveryMulticastResponder(backendManager,restrictor,logHandler);
   140|                 discoveryMulticastResponder.start();
   141|             } catch (IOException e) {
   142|                 logHandler.error("Cannot start discovery multicast handler: " + e,e);
   143|             }
   144|         }
   145|     }
   146|     private String findAgentUrl(Configuration pConfig) {
   147|         String url = System.getProperty("jolokia." + ConfigKey.DISCOVERY_AGENT_URL.getKeyValue());
   148|         if (url == null) {
   149|             url = System.getenv("JOLOKIA_DISCOVERY_AGENT_URL");
   150|             if (url == null) {
   151|                 url = pConfig.get(ConfigKey.DISCOVERY_AGENT_URL);
   152|             }
   153|         }
   154|         return url;
   155|     }
   156|     private boolean listenForDiscoveryMcRequests(Configuration pConfig) {
   157|         boolean sysProp = System.getProperty("jolokia." + ConfigKey.DISCOVERY_ENABLED.getKeyValue()) != null;
   158|         boolean env     = System.getenv("JOLOKIA_DISCOVERY") != null;
   159|         boolean config  = pConfig.getAsBoolean(ConfigKey.DISCOVERY_ENABLED);
   160|         return sysProp || env || config;
   161|     }
   162|     /**
   163|      * Create a log handler using this servlet's logging facility for logging. This method can be overridden
   164|      * to provide a custom log handler. This method is called before {@link #createRestrictor(String)} so the log handler
   165|      * can already be used when building up the restrictor.
   166|      *
   167|      * @return a default log handler
   168|      * @param pServletConfig servlet config from where to get information to build up the log handler
   169|      * @param pDebug whether to print out  debug information.
   170|      */
   171|     protected LogHandler createLogHandler(ServletConfig pServletConfig, final boolean pDebug) {
   172|         return new LogHandler() {
   173|             /** {@inheritDoc} */
   174|             public void debug(String message) {

# --- HUNK 2: Lines 211-269 ---
   211|     /**
   212|      * OPTION requests are treated as CORS preflight requests
   213|      *
   214|      * @param req the original request
   215|      * @param resp the response the answer are written to
   216|      * */
   217|     @Override
   218|     protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
   219|         Map<String,String> responseHeaders =
   220|                 requestHandler.handleCorsPreflightRequest(
   221|                         req.getHeader("Origin"),
   222|                         req.getHeader("Access-Control-Request-Headers"));
   223|         for (Map.Entry<String,String> entry : responseHeaders.entrySet()) {
   224|             resp.setHeader(entry.getKey(),entry.getValue());
   225|         }
   226|     }
   227|     @SuppressWarnings({ "PMD.AvoidCatchingThrowable", "PMD.AvoidInstanceofChecksInCatchClause" })
   228|     private void handle(ServletRequestHandler pReqHandler,HttpServletRequest pReq, HttpServletResponse pResp) throws IOException {
   229|         JSONAware json = null;
   230|         try {
   231|             requestHandler.checkClientIPAccess(pReq.getRemoteHost(),pReq.getRemoteAddr());
   232|             updateAgentUrlIfNeeded(pReq);
   233|             json = pReqHandler.handleRequest(pReq,pResp);
   234|         } catch (Throwable exp) {
   235|             json = requestHandler.handleThrowable(
   236|                     exp instanceof RuntimeMBeanException ? ((RuntimeMBeanException) exp).getTargetException() : exp);
   237|         } finally {
   238|             setCorsHeader(pReq, pResp);
   239|             String callback = pReq.getParameter(ConfigKey.CALLBACK.getKeyValue());
   240|             String answer = json != null ?
   241|                     json.toJSONString() :
   242|                     requestHandler.handleThrowable(new Exception("Internal error while handling an exception")).toJSONString();
   243|             if (callback != null) {
   244|                 sendResponse(pResp, "text/javascript", callback + "(" + answer + ");");
   245|             } else {
   246|                 sendResponse(pResp, getMimeType(pReq),answer);
   247|             }
   248|         }
   249|     }
   250|     private void updateAgentUrlIfNeeded(HttpServletRequest pReq) {
   251|         if (initAgentUrlFromRequest) {
   252|             updateAgentUrl(NetworkUtil.sanitizeLocalUrl(pReq.getRequestURL().toString()), extractServletPath(pReq),pReq.getAuthType() != null);
   253|             initAgentUrlFromRequest = false;
   254|         }
   255|     }
   256|     private String extractServletPath(HttpServletRequest pReq) {
   257|         return pReq.getRequestURI().substring(0,pReq.getContextPath().length());
   258|     }
   259|     private void updateAgentUrl(String pRequestUrl, String pServletPath, boolean pIsAuthenticated) {
   260|         String url = getBaseUrl(pRequestUrl, pServletPath);
   261|         backendManager.getAgentDetails().updateAgentParameters(url,pIsAuthenticated);
   262|     }
   263|     private String getBaseUrl(String pUrl, String pServletPath) {
   264|         String sUrl;
   265|         try {
   266|             URL url = new URL(pUrl);
   267|             String host = getIpIfPossible(url.getHost());
   268|             sUrl = new URL(url.getProtocol(),host,url.getPort(),pServletPath).toExternalForm();
   269|         } catch (MalformedURLException exp) {


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/http/HttpRequestHandler.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 114-154 ---
   114|         } else if (jsonRequest instanceof JSONObject) {
   115|             JmxRequest jmxReq = JmxRequestFactory.createPostRequest((Map<String, ?>) jsonRequest,getProcessingParameter(pParameterMap));
   116|             return executeRequest(jmxReq);
   117|         } else {
   118|             throw new IllegalArgumentException("Invalid JSON Request " + jsonRequest);
   119|         }
   120|     }
   121|     /**
   122|      * Handling an option request which is used for preflight checks before a CORS based browser request is
   123|      * sent (for certain circumstances).
   124|      *
   125|      * See the <a href="http://www.w3.org/TR/cors/">CORS specification</a>
   126|      * (section 'preflight checks') for more details.
   127|      *
   128|      * @param pOrigin the origin to check. If <code>null</code>, no headers are returned
   129|      * @param pRequestHeaders extra headers to check against
   130|      * @return headers to set
   131|      */
   132|     public Map<String, String> handleCorsPreflightRequest(String pOrigin, String pRequestHeaders) {
   133|         Map<String,String> ret = new HashMap<String, String>();
   134|         if (pOrigin != null && backendManager.isCorsAccessAllowed(pOrigin)) {
   135|             ret.put("Access-Control-Allow-Origin","null".equals(pOrigin) ? "*" : pOrigin);
   136|             if (pRequestHeaders != null) {
   137|                 ret.put("Access-Control-Allow-Headers",pRequestHeaders);
   138|             }
   139|             ret.put("Access-Control-Allow-Credentials","true");
   140|             ret.put("Access-Control-Allow-Max-Age","" + 3600 * 24 * 365);
   141|         }
   142|         return ret;
   143|     }
   144|     private Object extractJsonRequest(InputStream pInputStream, String pEncoding) throws IOException {
   145|         InputStreamReader reader = null;
   146|         try {
   147|             reader =
   148|                     pEncoding != null ?
   149|                             new InputStreamReader(pInputStream, pEncoding) :
   150|                             new InputStreamReader(pInputStream);
   151|             JSONParser parser = new JSONParser();
   152|             return parser.parse(reader);
   153|         } catch (ParseException exp) {
   154|             throw new IllegalArgumentException("Invalid JSON request " + reader,exp);

# --- HUNK 2: Lines 221-278 ---
   221|      */
   222|     public JSONObject getErrorJSON(int pErrorCode, Throwable pExp, JmxRequest pJmxReq) {
   223|         JSONObject jsonObject = new JSONObject();
   224|         jsonObject.put("status",pErrorCode);
   225|         jsonObject.put("error",getExceptionMessage(pExp));
   226|         jsonObject.put("error_type", pExp.getClass().getName());
   227|         addErrorInfo(jsonObject, pExp, pJmxReq);
   228|         if (backendManager.isDebug()) {
   229|             backendManager.error("Error " + pErrorCode,pExp);
   230|         }
   231|         if (pJmxReq != null) {
   232|             jsonObject.put("request",pJmxReq.toJSON());
   233|         }
   234|         return jsonObject;
   235|     }
   236|     /**
   237|      * Check whether the given host and/or address is allowed to access this agent.
   238|      *
   239|      * @param pHost host to check
   240|      * @param pAddress address to check
   241|      */
   242|     public void checkClientIPAccess(String pHost, String pAddress) {
   243|         if (!backendManager.isRemoteAccessAllowed(pHost,pAddress)) {
   244|             throw new SecurityException("No access from client " + pAddress + " allowed");
   245|         }
   246|     }
   247|     /**
   248|      * Check whether for the given host is a cross-browser request allowed. This check is deligated to the
   249|      * backendmanager which is responsible for the security configuration.
   250|      * Also, some sanity checks are applied.
   251|      *
   252|      * @param pOrigin the origin URL to check against
   253|      * @return the origin to put in the response header or null if none is to be set
   254|      */
   255|     public String extractCorsOrigin(String pOrigin) {
   256|         if (pOrigin != null) {
   257|             String origin  = pOrigin.replaceAll("[\\n\\r]*","");
   258|             if (backendManager.isCorsAccessAllowed(origin)) {
   259|                 return "null".equals(origin) ? "*" : origin;
   260|             } else {
   261|                 return null;
   262|             }
   263|         }
   264|         return null;
   265|     }
   266|     private void addErrorInfo(JSONObject pErrorResp, Throwable pExp, JmxRequest pJmxReq) {
   267|         String includeStackTrace = pJmxReq != null ?
   268|                 pJmxReq.getParameter(ConfigKey.INCLUDE_STACKTRACE) : "true";
   269|         if (includeStackTrace.equalsIgnoreCase("true") ||
   270|             (includeStackTrace.equalsIgnoreCase("runtime") && pExp instanceof RuntimeException)) {
   271|             StringWriter writer = new StringWriter();
   272|             pExp.printStackTrace(new PrintWriter(writer));
   273|             pErrorResp.put("stacktrace",writer.toString());
   274|         }
   275|         if (pJmxReq != null && pJmxReq.getParameterAsBool(ConfigKey.SERIALIZE_EXCEPTION)) {
   276|             pErrorResp.put("error_value",backendManager.convertExceptionToJson(pExp,pJmxReq));
   277|         }
   278|     }


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/request/JmxObjectNameRequest.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 72-112 ---
    72|         return ret.toString();
    73|     }
    74|     /**
    75|      * Get object name of MBean
    76|      *
    77|      * @return the object name
    78|      */
    79|     public ObjectName getObjectName() {
    80|         return objectName;
    81|     }
    82|     /**
    83|      * String representation of the object name for this request.
    84|      *
    85|      * @return the object name a string representation
    86|      */
    87|     public String getObjectNameAsString() {
    88|         return objectName.getCanonicalName();
    89|     }
    90|     /**
    91|      * Name prepared according to requested formatting note. The key ordering can be influenced by the
    92|      * proccesing parameter {@link ConfigKey#CANONICAL_NAMING}. If not given or set to "true",
    93|      * then the canonical order is used, if set to "initial" the name is given to construction time
    94|      * is used.
    95|      *
    96|      * @param pName name to format
    97|      * @return formatted string
    98|      */
    99|     public String getOrderedObjectName(ObjectName pName) {
   100|         if (pName.isPattern()) {
   101|             return pName.getCanonicalName();
   102|         }
   103|         if (getParameterAsBool(ConfigKey.CANONICAL_NAMING)) {
   104|             return pName.getCanonicalName();
   105|         } else {
   106|             return pName.getDomain() + ":" + pName.getKeyPropertyListString();
   107|         }
   108|     }
   109|     private void initObjectName(String pObjectName) throws MalformedObjectNameException {
   110|         if (pObjectName == null) {
   111|             throw new IllegalArgumentException("Objectname can not be null");
   112|         }


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/request/JmxReadRequest.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 72-113 ---
    72|                                             "" + attributeNames + "). Use getAttributeNames() instead.");
    73|         }
    74|         return attributeNames.get(0);
    75|     }
    76|     /**
    77|      * Get the list of all attribute names.
    78|      *
    79|      * @return list of attributes names or null
    80|      */
    81|     public List<String> getAttributeNames() {
    82|         return attributeNames;
    83|     }
    84|     /**
    85|      * Whether this is a multi-attribute request, i.e. whether it contains one ore more attributes to fetch
    86|      * @return true if this is a multi attribute request, false otherwise.
    87|      */
    88|     public boolean isMultiAttributeMode() {
    89|         return multiAttributeMode;
    90|     }
    91|     /**
    92|      * Whether this request has no attribute names associated  (which normally means, that all attributes should be fetched).
    93|      * @return true if no attribute name is stored.
    94|      */
    95|     public boolean hasAttribute() {
    96|         return isMultiAttributeMode() || getAttributeName() != null;
    97|     }
    98|     /** {@inheritDoc} */
    99|     public JSONObject toJSON() {
   100|         JSONObject ret = super.toJSON();
   101|         if (attributeNames != null && attributeNames.size() > 0) {
   102|             if (attributeNames.size() > 1) {
   103|                 ret.put("attribute", attributeNames);
   104|             } else {
   105|                 ret.put("attribute", attributeNames.get(0));
   106|             }
   107|         }
   108|         if (getPathParts() != null && getPathParts().size() > 0) {
   109|             ret.put("path", getPath());
   110|         }
   111|         return ret;
   112|     }
   113|     /** {@inheritDoc} */


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/restrictor/AbstractConstantRestrictor.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 43-66 ---
    43|     public final boolean isTypeAllowed(RequestType pType) {
    44|         return isAllowed;
    45|     }
    46|     /** {@inheritDoc} */
    47|     public final boolean isAttributeReadAllowed(ObjectName pName, String pAttribute) {
    48|         return isAllowed;
    49|     }
    50|     /** {@inheritDoc} */
    51|     public final boolean isAttributeWriteAllowed(ObjectName pName, String pAttribute) {
    52|         return isAllowed;
    53|     }
    54|     /** {@inheritDoc} */
    55|     public final boolean isOperationAllowed(ObjectName pName, String pOperation) {
    56|         return isAllowed;
    57|     }
    58|     /** {@inheritDoc} */
    59|     public final boolean isRemoteAccessAllowed(String... pHostOrAddress) {
    60|         return isAllowed;
    61|     }
    62|     /** {@inheritDoc} */
    63|     public boolean isCorsAccessAllowed(String pOrigin) {
    64|         return isAllowed;
    65|     }
    66| }


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/restrictor/PolicyRestrictor.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 60-99 ---
    60|         catch (IOException e) { exp = e; }
    61|         catch (ParserConfigurationException e) { exp = e; }
    62|         catch (MalformedObjectNameException e) { exp = e; }
    63|         if (exp != null) {
    64|             throw new SecurityException("Cannot parse policy file: " + exp,exp);
    65|         }
    66|     }
    67|     /** {@inheritDoc} */
    68|     public boolean isHttpMethodAllowed(HttpMethod method) {
    69|         return httpChecker.check(method);
    70|     }
    71|     /** {@inheritDoc} */
    72|     public boolean isTypeAllowed(RequestType pType) {
    73|         return requestTypeChecker.check(pType);
    74|     }
    75|     /** {@inheritDoc} */
    76|     public boolean isRemoteAccessAllowed(String ... pHostOrAddress) {
    77|         return networkChecker.check(pHostOrAddress);
    78|     }
    79|     /** {@inheritDoc} */
    80|     public boolean isCorsAccessAllowed(String pOrigin) {
    81|         return corsChecker.check(pOrigin);
    82|     }
    83|     /** {@inheritDoc} */
    84|     public boolean isAttributeReadAllowed(ObjectName pName, String pAttribute) {
    85|         return check(RequestType.READ,pName,pAttribute);
    86|     }
    87|     /** {@inheritDoc} */
    88|     public boolean isAttributeWriteAllowed(ObjectName pName, String pAttribute) {
    89|         return check(RequestType.WRITE,pName, pAttribute);
    90|     }
    91|     /** {@inheritDoc} */
    92|     public boolean isOperationAllowed(ObjectName pName, String pOperation) {
    93|         return check(RequestType.EXEC,pName, pOperation);
    94|     }
    95|     /** {@inheritDoc} */
    96|     private boolean check(RequestType pType, ObjectName pName, String pValue) {
    97|         return mbeanAccessChecker.check(new MBeanAccessChecker.Arg(isTypeAllowed(pType), pType, pName, pValue));
    98|     }
    99| }


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/restrictor/Restrictor.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 61-85 ---
    61|      * Check whether execution of an operation is allowed
    62|      *
    63|      * @param pName MBean name
    64|      * @param pOperation attribute to check
    65|      * @return true if access is allowed
    66|      */
    67|     boolean isOperationAllowed(ObjectName pName,String pOperation);
    68|     /**
    69|      * Check whether access from the connected client is allowed. If at least
    70|      * one of the given parameters matches, then this method returns true.
    71|      *
    72|      * @return true is access is allowed
    73|      * @param pHostOrAddress one or more host or address names
    74|      */
    75|     boolean isRemoteAccessAllowed(String ... pHostOrAddress);
    76|     /**
    77|      * Check whether cross browser access via CORS is allowed. See the
    78|      * <a href="https://developer.mozilla.org/en/http_access_control">CORS</a> specification
    79|      * for details
    80|      *
    81|      * @param pOrigin the "Origin:" URL provided within the request
    82|      * @return true if this cross browser request allowed, false otherwise
    83|      */
    84|     boolean isCorsAccessAllowed(String pOrigin);
    85| }


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/restrictor/policy/CorsChecker.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 8-74 ---
     8|  *
     9|  *       http://www.apache.org/licenses/LICENSE-2.0
    10|  *
    11|  * Unless required by applicable law or agreed to in writing, software
    12|  * distributed under the License is distributed on an "AS IS" BASIS,
    13|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    14|  * See the License for the specific language governing permissions and
    15|  * limitations under the License.
    16|  */
    17| import java.util.ArrayList;
    18| import java.util.List;
    19| import java.util.regex.Pattern;
    20| import org.w3c.dom.*;
    21| /**
    22|  * Check for location restrictions for CORS based cross browser platform requests
    23|  *
    24|  * @author roland
    25|  * @since 07.04.12
    26|  */
    27| public class CorsChecker extends AbstractChecker<String> {
    28|     private List<Pattern> patterns;
    29|     /**
    30|      * Constructor buiilding up this checker from the XML document provided.
    31|      * CORS sections look like
    32|      * <pre>
    33|      *     &lt;cors&gt;
    34|      *       &lt;allow-origin&gt;http://jolokia.org&lt;allow-origin&gt;
    35|      *       &lt;allow-origin&gt;*://*.jmx4perl.org&gt;
    36|      *     &lt;/cors&gt;
    37|      * </pre>
    38|      *
    39|      * @param pDoc the overall policy documents
    40|      */
    41|     public CorsChecker(Document pDoc) {
    42|         NodeList corsNodes = pDoc.getElementsByTagName("cors");
    43|         if (corsNodes.getLength() > 0) {
    44|             patterns = new ArrayList<Pattern>();
    45|             for (int i = 0; i < corsNodes.getLength(); i++) {
    46|                 Node corsNode = corsNodes.item(i);
    47|                 NodeList nodes = corsNode.getChildNodes();
    48|                 for (int j = 0;j <nodes.getLength();j++) {
    49|                     Node node = nodes.item(j);
    50|                     if (node.getNodeType() != Node.ELEMENT_NODE) {
    51|                         continue;
    52|                     }
    53|                     assertNodeName(node,"allow-origin");
    54|                     String p = node.getTextContent().trim().toLowerCase();
    55|                     p = Pattern.quote(p).replace("*","\\E.*\\Q");
    56|                     patterns.add(Pattern.compile("^" + p + "$"));
    57|                 }
    58|             }
    59|         }
    60|     }
    61|     /** {@inheritDoc} */
    62|     @Override
    63|     public boolean check(String pArg) {
    64|         if (patterns == null || patterns.size() == 0) {
    65|             return true;
    66|         }
    67|         for (Pattern pattern : patterns) {
    68|             if (pattern.matcher(pArg).matches()) {
    69|                 return true;
    70|             }
    71|         }
    72|         return false;
    73|     }
    74| }


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/util/LogHandler.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 49-75 ---
    49|         public void error(String message, Throwable t) { }
    50|     };
    51|     /**
    52|      * Loghandler for printing to stdout
    53|      */
    54|     class StdoutLogHandler implements LogHandler {
    55|         private boolean doDebug;
    56|         public StdoutLogHandler(boolean pDoDebug) {
    57|             doDebug = pDoDebug;
    58|         }
    59|         public void debug(String message) {
    60|             if (doDebug) {
    61|                 log("D> " + message);
    62|             }
    63|         }
    64|         public void info(String message) {
    65|             log("I> " + message);
    66|         }
    67|         public void error(String message, Throwable t) {
    68|             log("E> " + message);
    69|             t.printStackTrace();
    70|         }
    71|         private void log(String message) {
    72|             System.out.println(message); //NOSONAR
    73|         }
    74|     }
    75| }


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/util/NetworkUtil.java
# Total hunks: 6
# ====================================================================
# --- HUNK 1: Lines 1-282 ---
     1| package org.jolokia.util;
     2| import java.io.IOException;
     3| import java.lang.management.ManagementFactory;
     4| import java.lang.reflect.InvocationTargetException;
     5| import java.lang.reflect.Method;
     6| import java.net.*;
     7| import java.util.*;
     8| /**
     9|  * Utility class for network related stuff
    10|  *
    11|  * @author roland
    12|  * @since 05.02.14
    13|  */
    14| public final class NetworkUtil {
    15|     private static Method isUp;
    16|     private static Method supportsMulticast;
    17|     static {
    18|         try {
    19|             isUp = NetworkInterface.class.getMethod("isUp", (Class<?>[]) null);
    20|             supportsMulticast = NetworkInterface.class.getMethod("supportsMulticast", (Class<?>[]) null);
    21|         } catch (NoSuchMethodException e) {
    22|             isUp = null;
    23|             supportsMulticast = null;
    24|         }
    25|     }
    26|     private NetworkUtil() {}
    27|     public static void main(String[] args) throws UnknownHostException, SocketException {
    28|         System.out.println(dumpLocalNetworkInfo()); // NOSONAR
    29|     }
    30|     /**
    31|      * Get a local, IP4 Address, preferable a non-loopback address which is bound to an interface.
    32|      * @return
    33|      * @throws UnknownHostException
    34|      * @throws SocketException
    35|      */
    36|     public static InetAddress getLocalAddress() throws UnknownHostException, SocketException {
    37|         InetAddress addr = InetAddress.getLocalHost();
    38|         NetworkInterface nif = NetworkInterface.getByInetAddress(addr);
    39|         if (addr.isLoopbackAddress() || addr instanceof Inet6Address || nif == null) {
    40|             InetAddress lookedUpAddr = findLocalAddressViaNetworkInterface();
    41|             addr = lookedUpAddr != null ? lookedUpAddr : InetAddress.getByName("127.0.0.1");
    42|         }
    43|         return addr;
    44|     }
    45|     /**
    46|      * Get a local address which supports multicast. A loopback adress is returned, but only if not
    47|      * another is available
    48|      *
    49|      * @return a multicast enabled address of null if none could be found
    50|      *
    51|      * @throws UnknownHostException
    52|      * @throws SocketException
    53|      */
    54|     public static InetAddress getLocalAddressWithMulticast() throws UnknownHostException, SocketException {
    55|         InetAddress addr = InetAddress.getLocalHost();
    56|         NetworkInterface nif = NetworkInterface.getByInetAddress(addr);
    57|         if (addr.isLoopbackAddress() || addr instanceof Inet6Address || !isMulticastSupported(nif)) {
    58|             InetAddress lookedUpAddr = findLocalAddressViaNetworkInterface();
    59|             if (lookedUpAddr != null) {
    60|                 return lookedUpAddr;
    61|             }
    62|             addr = InetAddress.getByName("127.0.0.1");
    63|         }
    64|         if (isMulticastSupported(addr)) {
    65|             return addr;
    66|         } else {
    67|             throw new UnknownHostException("Cannot find address of local host which can be used for multicasting");
    68|         }
    69|     }
    70|     public static InetAddress findLocalAddressViaNetworkInterface() {
    71|         Enumeration<NetworkInterface> networkInterfaces;
    72|         try {
    73|             networkInterfaces = NetworkInterface.getNetworkInterfaces();
    74|         } catch (SocketException e) {
    75|             return null;
    76|         }
    77|         while (networkInterfaces.hasMoreElements()) {
    78|             NetworkInterface nif = networkInterfaces.nextElement();
    79|             for (Enumeration<InetAddress> addrEnum = nif.getInetAddresses(); addrEnum.hasMoreElements();) {
    80|                 InetAddress interfaceAddress = addrEnum.nextElement();
    81|                 if (useInetAddress(nif, interfaceAddress)) {
    82|                     return interfaceAddress;
    83|                 }
    84|             }
    85|         }
    86|         return null;
    87|     }
    88|     /**
    89|      * Check, whether multicast is supported at all by at least one interface
    90|      *
    91|      * @return true if at least one network interface supports multicast
    92|      */
    93|     public static boolean isMulticastSupported() throws SocketException {
    94|         return getMulticastAddresses().size() != 0;
    95|     }
    96|     /**
    97|      * Check whether the given interface supports multicast and is up
    98|      *
    99|      * @param pNif check whether the given interface supports multicast
   100|      * @return true if multicast is supported and the interface is up
   101|      */
   102|     public static boolean isMulticastSupported(NetworkInterface pNif) {
   103|         return pNif != null && checkMethod(pNif, isUp) && checkMethod(pNif,supportsMulticast);
   104|     }
   105|     /**
   106|      * Check whether the given address' interface supports multicast
   107|      *
   108|      * @param pAddr address to check
   109|      * @return true if the underlying networkinterface is up and supports multicast
   110|      * @throws SocketException
   111|      */
   112|     public static boolean isMulticastSupported(InetAddress pAddr) throws SocketException {
   113|         return isMulticastSupported(NetworkInterface.getByInetAddress(pAddr));
   114|     }
   115|     /**
   116|      * Get all local addresses on which a multicast can be send
   117|      * @return list of all multi cast capable addresses
   118|      */
   119|     public static List<InetAddress> getMulticastAddresses() throws SocketException {
   120|         Enumeration<NetworkInterface> nifs = NetworkInterface.getNetworkInterfaces();
   121|         List<InetAddress> ret = new ArrayList<InetAddress>();
   122|         while (nifs.hasMoreElements()) {
   123|             NetworkInterface nif = nifs.nextElement();
   124|             if (checkMethod(nif, supportsMulticast) && checkMethod(nif,isUp)) {
   125|                 Enumeration<InetAddress> addresses = nif.getInetAddresses();
   126|                 while (addresses.hasMoreElements()) {
   127|                     InetAddress addr = addresses.nextElement();
   128|                     if (!(addr instanceof Inet6Address)) {
   129|                         ret.add(addr);
   130|                     }
   131|                 }
   132|             }
   133|         }
   134|         return ret;
   135|     }
   136|     public static String getAgentId(int objectId, String type) {
   137|         String address;
   138|         try {
   139|             address = getLocalAddress().getHostAddress();
   140|         } catch (IOException exp) {
   141|             address = "local";
   142|         }
   143|         return address + "-" + getProcessId() + "-" + Integer.toHexString(objectId) + "-" + type;
   144|     }
   145|     /**
   146|      * Examine the given URL and replace the host with a non-loopback host if possible. It is checked,
   147|      * whether the port is open as well.
   148|      *
   149|      * A replaced host uses the  IP address instead of a (possibly non resolvable) name.
   150|      *
   151|      * @param pRequestURL url to examine and to update
   152|      * @return the 'sane' URL (or the original one if no san
   153|      */
   154|     public static String sanitizeLocalUrl(String pRequestURL) {
   155|         try {
   156|             URL url = new URL(pRequestURL);
   157|             String host = url.getHost();
   158|             InetAddress address = findLocalAddressListeningOnPort(host,url.getPort());
   159|             return new URL(url.getProtocol(),address.getHostAddress(),url.getPort(),url.getFile()).toExternalForm();
   160|         } catch (IOException e) {
   161|             return pRequestURL;
   162|         }
   163|     }
   164|     private static boolean useInetAddress(NetworkInterface networkInterface, InetAddress interfaceAddress) {
   165|         return checkMethod(networkInterface, isUp) &&
   166|                checkMethod(networkInterface, supportsMulticast) &&
   167|                ! (interfaceAddress instanceof Inet6Address) &&
   168|                !interfaceAddress.isLoopbackAddress();
   169|     }
   170|     private static Boolean checkMethod(NetworkInterface iface, Method toCheck) {
   171|         if (toCheck != null) {
   172|             try {
   173|                 return (Boolean) toCheck.invoke(iface, (Object[]) null);
   174|             } catch (IllegalAccessException e) {
   175|                 return false;
   176|             } catch (InvocationTargetException e) {
   177|                 return false;
   178|             }
   179|         }
   180|         return true;
   181|     }
   182|     private static InetAddress findLocalAddressListeningOnPort(String pHost, int pPort) throws UnknownHostException, SocketException {
   183|         InetAddress address = InetAddress.getByName(pHost);
   184|         if (address.isLoopbackAddress()) {
   185|             InetAddress localAddress = getLocalAddress();
   186|             if (!localAddress.isLoopbackAddress() && isPortOpen(localAddress, pPort)) {
   187|                 return localAddress;
   188|             }
   189|             localAddress = getLocalAddressFromNetworkInterfacesListeningOnPort(pPort);
   190|             if (localAddress != null) {
   191|                 return localAddress;
   192|             }
   193|         }
   194|         return address;
   195|     }
   196|     private static InetAddress getLocalAddressFromNetworkInterfacesListeningOnPort(int pPort) {
   197|         try {
   198|             Enumeration<NetworkInterface> networkInterfaces;
   199|             networkInterfaces = NetworkInterface.getNetworkInterfaces();
   200|             while (networkInterfaces.hasMoreElements()) {
   201|                 NetworkInterface nif = networkInterfaces.nextElement();
   202|                 for (Enumeration<InetAddress> addrEnum = nif.getInetAddresses(); addrEnum.hasMoreElements();) {
   203|                     InetAddress interfaceAddress = addrEnum.nextElement();
   204|                     if (!interfaceAddress.isLoopbackAddress() && checkMethod(nif, isUp) && isPortOpen(interfaceAddress, pPort)) {
   205|                         return interfaceAddress;
   206|                     }
   207|                 }
   208|             }
   209|         } catch (SocketException e) {
   210|             return null;
   211|         }
   212|         return null;
   213|     }
   214|     private static boolean isPortOpen(InetAddress pAddress, int pPort) {
   215|         Socket socket = null;
   216|         try {
   217|             socket = new Socket();
   218|             socket.setReuseAddress(true);
   219|             SocketAddress sa = new InetSocketAddress(pAddress, pPort);
   220|             socket.connect(sa, 200);
   221|             return socket.isConnected();
   222|         } catch (IOException e) {
   223|             return false;
   224|         } finally {
   225|             if (socket != null) {
   226|                 try {
   227|                     socket.close();
   228|                 } catch (IOException e) {
   229|                 }
   230|             }
   231|         }
   232|     }
   233|     private static String getProcessId() {
   234|         final String jvmName = ManagementFactory.getRuntimeMXBean().getName();
   235|         final int index = jvmName.indexOf('@');
   236|         return index < 0 ? jvmName : jvmName.substring(0, index);
   237|     }
   238|     /**
   239|      * Get the local network info as a string
   240|      *
   241|      * @return return a description of the current network setup of the local host.
   242|      *
   243|      * @throws UnknownHostException
   244|      * @throws SocketException
   245|      */
   246|     public static String dumpLocalNetworkInfo() throws UnknownHostException, SocketException {
   247|         StringBuffer buffer = new StringBuffer();
   248|         InetAddress addr = InetAddress.getLocalHost();
   249|         buffer.append("Localhost: " + getAddrInfo(addr) + "\n");
   250|         Enumeration<NetworkInterface> nifs = NetworkInterface.getNetworkInterfaces();
   251|         buffer.append("Network interfaces:\n");
   252|         while (nifs.hasMoreElements()) {
   253|             NetworkInterface nif = nifs.nextElement();
   254|             buffer.append("  - " + getNetworkInterfaceInfo(nif) + "\n");
   255|             Enumeration<InetAddress> addresses = nif.getInetAddresses();
   256|             while (addresses.hasMoreElements()) {
   257|                 addr = addresses.nextElement();
   258|                 buffer.append("    " + getAddrInfo(addr) + "\n");
   259|             }
   260|         }
   261|         return buffer.toString();
   262|     }
   263|     private static String getAddrInfo(InetAddress pAddr) throws SocketException {
   264|         String ret = pAddr.getHostName() != null ? pAddr.getHostName() + " (" + pAddr.getHostAddress() + ")" : pAddr.getHostAddress();
   265|         ret += " [site-local: " + pAddr.isSiteLocalAddress() + ", link-local: " + pAddr.isLinkLocalAddress() + ", lb: " + pAddr.isLoopbackAddress() + "]";
   266|         NetworkInterface nif = NetworkInterface.getByInetAddress(pAddr);
   267|         ret += " -- nif: " + getNetworkInterfaceInfo(nif);
   268|         return ret;
   269|     }
   270|     private static String getNetworkInterfaceInfo(NetworkInterface pNif) throws SocketException {
   271|         if (pNif == null) {
   272|             return "[null]";
   273|         }
   274|         return pNif.getDisplayName() + " [up: " + pNif.isUp() + ", mc: " + pNif.supportsMulticast() +
   275|                ", lb: " + pNif.isLoopback() + ", hw: " + formatHwAddress(pNif.getHardwareAddress()) + "]";
   276|     }
   277|     private static String formatHwAddress(byte[] pHardwareAddress) {
   278|         if (pHardwareAddress == null) {
   279|             return "[none]";
   280|         }
   281|         StringBuilder sb = new StringBuilder(18);
   282|         for (byte b : pHardwareAddress) {


# ====================================================================
# FILE: agent/jvm/src/main/java/org/jolokia/jvmagent/JolokiaHttpHandler.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 117-192 ---
   117|         requestHandler = null;
   118|     }
   119|     /**
   120|      * Handler a request. If the handler is not yet started, an exception is thrown
   121|      *
   122|      * @param pExchange the request/response object
   123|      * @throws IOException if something fails during handling
   124|      * @throws IllegalStateException if the handler has not yet been started
   125|      */
   126|     @Override
   127|     @SuppressWarnings({"PMD.AvoidCatchingThrowable", "PMD.AvoidInstanceofChecksInCatchClause"})
   128|     public void handle(HttpExchange pExchange) throws IOException {
   129|         if (requestHandler == null) {
   130|             throw new IllegalStateException("Handler not yet started");
   131|         }
   132|         JSONAware json = null;
   133|         URI uri = pExchange.getRequestURI();
   134|         ParsedUri parsedUri = new ParsedUri(uri,context);
   135|         try {
   136|             InetSocketAddress address = pExchange.getRemoteAddress();
   137|             requestHandler.checkClientIPAccess(address.getHostName(),address.getAddress().getHostAddress());
   138|             String method = pExchange.getRequestMethod();
   139|             if ("GET".equalsIgnoreCase(method)) {
   140|                 setHeaders(pExchange);
   141|                 json = executeGetRequest(parsedUri);
   142|             } else if ("POST".equalsIgnoreCase(method)) {
   143|                 setHeaders(pExchange);
   144|                 json = executePostRequest(pExchange, parsedUri);
   145|             } else if ("OPTIONS".equalsIgnoreCase(method)) {
   146|                 performCorsPreflightCheck(pExchange);
   147|             } else {
   148|                 throw new IllegalArgumentException("HTTP Method " + method + " is not supported.");
   149|             }
   150|         } catch (Throwable exp) {
   151|             json = requestHandler.handleThrowable(
   152|                     exp instanceof RuntimeMBeanException ? ((RuntimeMBeanException) exp).getTargetException() : exp);
   153|         } finally {
   154|             sendResponse(pExchange,parsedUri,json);
   155|         }
   156|     }
   157|     private Restrictor createRestrictor(Configuration pConfig) {
   158|         String location = pConfig.get(ConfigKey.POLICY_LOCATION);
   159|         try {
   160|             Restrictor ret = RestrictorFactory.lookupPolicyRestrictor(location);
   161|             if (ret != null) {
   162|                 logHandler.info("Using access restrictor " + location);
   163|                 return ret;
   164|             } else {
   165|                 logHandler.info("No access restrictor found, access to all MBean is allowed");
   166|                 return new AllowAllRestrictor();
   167|             }
   168|         } catch (IOException e) {
   169|             logHandler.error("Error while accessing access restrictor at " + location +
   170|                              ". Denying all access to MBeans for security reasons. Exception: " + e, e);
   171|             return new DenyAllRestrictor();
   172|         }
   173|     }
   174|     private JSONAware executeGetRequest(ParsedUri parsedUri) {
   175|         return requestHandler.handleGetRequest(parsedUri.getUri().toString(),parsedUri.getPathInfo(), parsedUri.getParameterMap());
   176|     }
   177|     private JSONAware executePostRequest(HttpExchange pExchange, ParsedUri pUri) throws MalformedObjectNameException, IOException {
   178|         String encoding = null;
   179|         Headers headers = pExchange.getRequestHeaders();
   180|         String cType =  headers.getFirst("Content-Type");
   181|         if (cType != null) {
   182|             Matcher matcher = contentTypePattern.matcher(cType);
   183|             if (matcher.matches()) {
   184|                 encoding = matcher.group(1);
   185|             }
   186|         }
   187|         InputStream is = pExchange.getRequestBody();
   188|         return requestHandler.handlePostRequest(pUri.toString(),is, encoding, pUri.getParameterMap());
   189|     }
   190|     private void performCorsPreflightCheck(HttpExchange pExchange) {
   191|         Headers requestHeaders = pExchange.getRequestHeaders();
   192|         Map<String,String> respHeaders =

# --- HUNK 2: Lines 234-277 ---
   234|             }
   235|         }
   236|     }
   237|     private String getMimeType(ParsedUri pParsedUri) {
   238|         if (pParsedUri.getParameter(ConfigKey.CALLBACK.getKeyValue()) != null) {
   239|             return "text/javascript";
   240|         } else {
   241|             String mimeType = pParsedUri.getParameter(ConfigKey.MIME_TYPE.getKeyValue());
   242|             if (mimeType != null) {
   243|                 return mimeType;
   244|             }
   245|             mimeType = configuration.get(ConfigKey.MIME_TYPE);
   246|             return mimeType != null ? mimeType : ConfigKey.MIME_TYPE.getDefaultValue();
   247|         }
   248|     }
   249|     private LogHandler createLogHandler(String pLogHandlerClass, String pDebug) {
   250|         if (pLogHandlerClass != null) {
   251|             return ClassUtil.newInstance(pLogHandlerClass);
   252|         } else {
   253|             final boolean debug = Boolean.valueOf(pDebug);
   254|             return new PlainLogHandler(debug);
   255|         }
   256|     }
   257|     private static class PlainLogHandler implements LogHandler {
   258|         private final boolean debug;
   259|         public PlainLogHandler(boolean pDebug) {
   260|             debug = pDebug;
   261|         }
   262|         @Override
   263|         public final void debug(String message) {
   264|             if (debug) {
   265|                 System.err.println("D> " + message);
   266|             }
   267|         }
   268|         @Override
   269|         public final void info(String message) {
   270|             System.err.println("I> " + message);
   271|         }
   272|         @Override
   273|         public final void error(String message, Throwable t) {
   274|             System.err.println("E> " + message + " (Exception: " + t + ")");
   275|         }
   276|     }
   277| }


# ====================================================================
# FILE: agent/jvm/src/main/java/org/jolokia/jvmagent/JolokiaServer.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 58-98 ---
    58|      *
    59|      * @param pServer HttpServer to use
    60|      * @param pConfig configuration for this server
    61|      * @param pLazy lazy initialisation if true. This is required for agents
    62|      *              configured via startup options since at this early boot time
    63|      *              the JVM is not fully setup for the server detectors to work
    64|      */
    65|     public JolokiaServer(HttpServer pServer,JolokiaServerConfig pConfig, boolean pLazy) {
    66|         init(pServer,pConfig,pLazy);
    67|     }
    68|     /**
    69|      * No arg constructor usable by subclasses. The {@link #init(JolokiaServerConfig, boolean)} must be called later on
    70|      * for initialization
    71|      */
    72|     protected JolokiaServer() {}
    73|     /**
    74|      * Start this server. If we manage an own HttpServer, then the HttpServer will
    75|      * be started as well.
    76|      */
    77|     public void start() {
    78|         String configUrl = config.getJolokiaConfig().get(ConfigKey.DISCOVERY_AGENT_URL);
    79|         jolokiaHttpHandler.start(lazy,configUrl != null ? configUrl : url, config.getAuthenticator() != null);
    80|         if (httpServer != null) {
    81|             ThreadGroup threadGroup = new ThreadGroup("jolokia");
    82|             threadGroup.setDaemon(false);
    83|             Thread starterThread = new Thread(threadGroup,new Runnable() {
    84|             @Override
    85|             public void run() {
    86|                 httpServer.start();
    87|             }
    88|         });
    89|             starterThread.start();
    90|             cleaner = new CleanupThread(httpServer,threadGroup);
    91|             cleaner.start();
    92|         }
    93|     }
    94|     /**
    95|      * Stop the HTTP server
    96|      */
    97|     public void stop() {
    98|         jolokiaHttpHandler.stop();


# ====================================================================
# FILE: agent/osgi/src/main/java/org/jolokia/osgi/DelegatingRestrictor.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 112-151 ---
   112|     public boolean isOperationAllowed(ObjectName pName, String pOperation) {
   113|         return checkRestrictorService(OPERATION_CHECK,pName,pOperation);
   114|     }
   115|     private static final RestrictorCheck REMOTE_CHECK = new RestrictorCheck() {
   116|         /** {@inheritDoc} */
   117|         public boolean check(Restrictor restrictor,Object ... args) {
   118|             String[] argsS = new String[args.length];
   119|             for (int i = 0; i < args.length; i++) {
   120|                 argsS[i] = (String) args[i];
   121|             }
   122|             return restrictor.isRemoteAccessAllowed(argsS);
   123|         }
   124|     };
   125|     /** {@inheritDoc} */
   126|     public boolean isRemoteAccessAllowed(String... pHostOrAddress) {
   127|         return checkRestrictorService(REMOTE_CHECK,pHostOrAddress);
   128|     }
   129|     private static final RestrictorCheck CORS_CHECK = new RestrictorCheck() {
   130|         /** {@inheritDoc} */
   131|         public boolean check(Restrictor restrictor, Object... args) {
   132|             return restrictor.isCorsAccessAllowed((String) args[0]);
   133|         }
   134|     };
   135|     /** {@inheritDoc} */
   136|     public boolean isCorsAccessAllowed(String pOrigin) {
   137|         return checkRestrictorService(CORS_CHECK,pOrigin);
   138|     }
   139|     /**
   140|      * Internal interface for restrictor delegation
   141|      */
   142|     private interface RestrictorCheck {
   143|         /**
   144|          * Run check specifically for the restrictor to delegate to
   145|          * @param restrictor the restrictor on which the check should be run
   146|          * @param args context dependent arguments
   147|          * @return result of the check
   148|          */
   149|         boolean check(Restrictor restrictor,Object ... args);
   150|     }
   151| }


# ====================================================================
# FILE: client/java/src/main/java/org/jolokia/client/J4pClient.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-92 ---
     1| package org.jolokia.client;
     2| /*
     3|  * Copyright 2009-2013 Roland Huss
     4|  *
     5|  * Licensed under the Apache License, Version 2.0 (the "License");
     6|  * you may not use this file except in compliance with the License.
     7|  * You may obtain a copy of the License at
     8|  *
     9|  *       http://www.apache.org/licenses/LICENSE-2.0
    10|  *
    11|  * Unless required by applicable law or agreed to in writing, software
    12|  * distributed under the License is distributed on an "AS IS" BASIS,
    13|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    14|  * See the License for the specific language governing permissions and
    15|  * limitations under the License.
    16|  */
    17| import java.io.IOException;
    18| import java.net.*;
    19| import java.util.*;
    20| import org.apache.http.*;
    21| import org.apache.http.client.HttpClient;
    22| import org.apache.http.conn.*;
    23| import org.apache.http.impl.client.DefaultHttpClient;
    24| import org.apache.http.params.HttpParams;
    25| import org.jolokia.client.exception.*;
    26| import org.jolokia.client.request.*;
    27| import org.jolokia.client.request.J4pResponse;
    28| import org.json.simple.*;
    29| import org.json.simple.parser.ParseException;
    30| /**
    31|  * Client class for accessing the j4p agent
    32|  *
    33|  * @author roland
    34|  * @since Apr 24, 2010
    35|  */
    36| public class J4pClient extends J4pClientBuilderFactory {
    37|     private HttpClient httpClient;
    38|     private J4pRequestHandler requestHandler;
    39|     /**
    40|      * Construct a new client for a given server url
    41|      *
    42|      * @param pJ4pServerUrl the agent URL for how to contact the server.
    43|      */
    44|     public J4pClient(String pJ4pServerUrl) {
    45|         this(pJ4pServerUrl,null);
    46|     }
    47|     /**
    48|      * Constructor for a given agent URl and a given HttpClient
    49|      *
    50|      * @param pJ4pServerUrl the agent URL for how to contact the server.
    51|      * @param pHttpClient HTTP client to use for the connecting to the agent
    52|      */
    53|     public J4pClient(String pJ4pServerUrl, HttpClient pHttpClient) {
    54|         this(pJ4pServerUrl,pHttpClient,null);
    55|     }
    56|     /**
    57|      * Constructor using a given Agent URL, HttpClient and a proxy target config. If the HttpClient is null,
    58|      * a default client is used. If no target config is given, a plain request is performed
    59|      *
    60|      * @param pJ4pServerUrl the agent URL for how to contact the server.
    61|      * @param pHttpClient HTTP client to use for the connecting to the agent
    62|      * @param pTargetConfig optional target
    63|      */
    64|     public J4pClient(String pJ4pServerUrl, HttpClient pHttpClient,J4pTargetConfig pTargetConfig) {
    65|         requestHandler = new J4pRequestHandler(pJ4pServerUrl,pTargetConfig);
    66|         if (pHttpClient != null) {
    67|             httpClient = pHttpClient;
    68|         } else {
    69|             J4pClientBuilder builder = new J4pClientBuilder();
    70|             HttpParams params = builder.getHttpParams();
    71|             ClientConnectionManager cm = builder.createClientConnectionManager();
    72|             httpClient = new DefaultHttpClient(cm, params);
    73|         }
    74|     }
    75|     /**
    76|      * Execute a single J4pRequest returning a single response.
    77|      * The HTTP Method used is determined automatically.
    78|      *
    79|      * @param pRequest request to execute
    80|      * @param <R> response type
    81|      * @param <T> request type
    82|      * @return the response as returned by the server
    83|      */
    84|     public <R extends J4pResponse<T>,T extends J4pRequest> R execute(T pRequest)
    85|             throws J4pException {
    86|         return this.<R,T>execute(pRequest,null,null);
    87|     }
    88|     /**
    89|      * Execute a single J4pRequest returning a single response.
    90|      * The HTTP Method used is determined automatically.
    91|      *
    92|      * @param pRequest request to execute


# ====================================================================
# FILE: client/java/src/main/java/org/jolokia/client/J4pClientBuilder.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-85 ---
     1| package org.jolokia.client;
     2| /*
     3|  * Copyright 2009-2013 Roland Huss
     4|  *
     5|  * Licensed under the Apache License, Version 2.0 (the "License");
     6|  * you may not use this file except in compliance with the License.
     7|  * You may obtain a copy of the License at
     8|  *
     9|  *       http://www.apache.org/licenses/LICENSE-2.0
    10|  *
    11|  * Unless required by applicable law or agreed to in writing, software
    12|  * distributed under the License is distributed on an "AS IS" BASIS,
    13|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    14|  * See the License for the specific language governing permissions and
    15|  * limitations under the License.
    16|  */
    17| import org.apache.http.HttpVersion;
    18| import org.apache.http.auth.AuthScope;
    19| import org.apache.http.auth.UsernamePasswordCredentials;
    20| import org.apache.http.conn.ClientConnectionManager;
    21| import org.apache.http.conn.params.ConnManagerParams;
    22| import org.apache.http.conn.scheme.*;
    23| import org.apache.http.conn.ssl.SSLSocketFactory;
    24| import org.apache.http.impl.client.DefaultHttpClient;
    25| import org.apache.http.impl.conn.SingleClientConnManager;
    26| import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
    27| import org.apache.http.params.*;
    28| import org.apache.http.protocol.HTTP;
    29| import org.apache.http.util.VersionInfo;
    30| import org.jolokia.client.request.J4pTargetConfig;
    31| /**
    32|  * A builder for a {@link org.jolokia.client.J4pClient}.
    33|  *
    34|  * @author roland
    35|  * @since 26.11.10
    36|  */
    37| public class J4pClientBuilder {
    38|     private HttpParams params;
    39|     private boolean pooledConnections;
    40|     private String url;
    41|     private String user;
    42|     private String password;
    43|     private String targetUrl;
    44|     private String targetUser;
    45|     private String targetPassword;
    46|     /**
    47|      * Package access constructor, use static method on J4pClient for creating
    48|      * the builder.
    49|      */
    50|     public J4pClientBuilder() {
    51|         params = new BasicHttpParams();
    52|         connectionTimeout(20 * 1000);
    53|         maxTotalConnections(20);
    54|         maxConnectionPoolTimeout(500);
    55|         contentCharset(HTTP.DEFAULT_CONTENT_CHARSET);
    56|         expectContinue(true);
    57|         tcpNoDelay(true);
    58|         socketBufferSize(8192);
    59|         pooledConnections();
    60|         user = null;
    61|         password = null;
    62|         HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
    63|         final VersionInfo vi = VersionInfo.loadVersionInfo("org.apache.http.client", getClass().getClassLoader());
    64|         final String release = (vi != null) ? vi.getRelease() : VersionInfo.UNAVAILABLE;
    65|         HttpProtocolParams.setUserAgent(params,"Jolokia JMX-Client (using Apache-HttpClient/" + release +")");
    66|     }
    67|     /**
    68|      * The Agent URL to connect to
    69|      *
    70|      * @param pUrl agent URL
    71|      */
    72|     public final J4pClientBuilder url(String pUrl) {
    73|         url = pUrl;
    74|         return this;
    75|     }
    76|     /**
    77|      * User to use for authentication
    78|      *
    79|      * @param pUser user name
    80|      */
    81|     public final J4pClientBuilder user(String pUser) {
    82|         user  = pUser;
    83|         return this;
    84|     }
    85|     /**

# --- HUNK 2: Lines 103-250 ---
   103|     /**
   104|      * Target user for proxy mode. This parameter takes only effect when a target is set.
   105|      *
   106|      * @param pUser User to be used for authentication in JSR-160 proxy communication
   107|      */
   108|     public final J4pClientBuilder targetUser(String pUser) {
   109|         targetUser = pUser;
   110|         return this;
   111|     }
   112|     /**
   113|      * Target password for proxy mode. This parameter takes only effect when a target is set and the target user is
   114|      * not null
   115|      *
   116|      * @param pPassword Password to be used for authentication in JSR-160 proxy communication
   117|      */
   118|     public final J4pClientBuilder targetPassword(String pPassword) {
   119|         targetPassword = pPassword;
   120|         return this;
   121|     }
   122|     /**
   123|      * Use a {@link org.apache.http.impl.conn.SingleClientConnManager} for connecting to the agent. This
   124|      * is not very suitable in multithreaded environements
   125|      */
   126|     public final J4pClientBuilder singleConnection() {
   127|         pooledConnections = false;
   128|         return this;
   129|     }
   130|     /**
   131|      * Use a {@link org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager} for connecting to the agent, which
   132|      * uses a pool of connections (see {@link #maxTotalConnections(int) and {@link #maxConnectionPoolTimeout(int)} for
   133|      * tuning the pool}
   134|      */
   135|     public final J4pClientBuilder pooledConnections() {
   136|         pooledConnections = true;
   137|         return this;
   138|     }
   139|     /**
   140|      * Determines the timeout in milliseconds until a connection is established. A timeout value of zero is
   141|      * interpreted as an infinite timeout.
   142|      * @param pTimeOut timeout in milliseconds
   143|      */
   144|     public final J4pClientBuilder connectionTimeout(int pTimeOut) {
   145|         HttpConnectionParams.setConnectionTimeout(params,pTimeOut);
   146|         return this;
   147|     }
   148|     /**
   149|      * Defines the socket timeout (<code>SO_TIMEOUT</code>) in milliseconds,
   150|      * which is the timeout for waiting for data  or, put differently,
   151|      * a maximum period inactivity between two consecutive data packets).
   152|      * A timeout value of zero is interpreted as an infinite timeout.
   153|      *
   154|      * @param pTimeOut SO_TIMEOUT value in milliseconds, 0 mean no timeout at all.
   155|      */
   156|     public final J4pClientBuilder socketTimeout(int pTimeOut) {
   157|         HttpConnectionParams.setSoTimeout(params,pTimeOut);
   158|         return this;
   159|     }
   160|     /**
   161|      * Sets the maximum number of connections allowed when using {@link #pooledConnections()}.
   162|      * @param pConnections number of max. simultaneous connections
   163|      */
   164|     public final J4pClientBuilder maxTotalConnections(int pConnections) {
   165|         ConnManagerParams.setMaxTotalConnections(params, pConnections);
   166|         return this;
   167|     }
   168|     /**
   169|      * Sets the timeout in milliseconds used when retrieving a connection
   170|      * from the {@link org.apache.http.conn.ClientConnectionManager}.
   171|      *
   172|      * @param pConnectionPoolTimeout timeout in milliseconds
   173|      */
   174|     public final J4pClientBuilder maxConnectionPoolTimeout(int pConnectionPoolTimeout) {
   175|         ConnManagerParams.setTimeout(params,pConnectionPoolTimeout);
   176|         return this;
   177|     }
   178|     /**
   179|      * Defines the charset to be used per default for encoding content body.
   180|      * @param pContentCharset the charset to use
   181|      */
   182|     public final J4pClientBuilder contentCharset(String pContentCharset) {
   183|         HttpProtocolParams.setContentCharset(params, pContentCharset);
   184|         return this;
   185|     }
   186|     /**
   187|      * Activates 'Expect: 100-Continue' handshake for the entity enclosing methods.
   188|      * The purpose of the 'Expect: 100-Continue' handshake to allow a client that is
   189|      * sending a request message with a request body to determine if the origin server
   190|      * is willing to accept the request (based on the request headers) before the client
   191|      * sends the request body.
   192|      * The use of the 'Expect: 100-continue' handshake can result in noticable peformance
   193|      * improvement for entity enclosing requests that require the target server's authentication.
   194|      *
   195|      * @param pUse whether to use this algorithm or not
   196|      */
   197|     public final J4pClientBuilder expectContinue(boolean pUse) {
   198|         HttpProtocolParams.setUseExpectContinue(params,pUse);
   199|         return this;
   200|     }
   201|     /**
   202|      * Determines whether Nagle's algorithm is to be used. The Nagle's algorithm tries to conserve
   203|      * bandwidth by minimizing the number of segments that are sent. When applications wish to
   204|      * decrease network latency and increase performance, they can disable Nagle's
   205|      * algorithm (that is enable TCP_NODELAY). Data will be sent earlier, at the cost
   206|      * of an increase in bandwidth consumption.
   207|      * @param pUse whether to use NO_DELAY or not
   208|      */
   209|     public final J4pClientBuilder tcpNoDelay(boolean pUse) {
   210|         HttpConnectionParams.setTcpNoDelay(params,pUse);
   211|         return this;
   212|     }
   213|     /**
   214|      * Determines the size of the internal socket buffer used to buffer data while receiving /
   215|      * transmitting HTTP messages.
   216|      * @param pSize size of socket buffer
   217|      */
   218|     public final J4pClientBuilder socketBufferSize(int pSize) {
   219|         HttpConnectionParams.setSocketBufferSize(params,pSize);
   220|         return this;
   221|     }
   222|     /**
   223|      * Build the agent with the information given before
   224|      *
   225|      * @return a new J4pClient
   226|      */
   227|     public J4pClient build() {
   228|         ClientConnectionManager cm = createClientConnectionManager();
   229|         DefaultHttpClient httpClient = new DefaultHttpClient(cm, getHttpParams());
   230|         if (user != null) {
   231|             httpClient.getCredentialsProvider().setCredentials(AuthScope.ANY,
   232|                                                                new UsernamePasswordCredentials(user,password));
   233|         }
   234|         return new J4pClient(url,httpClient,targetUrl != null ? new J4pTargetConfig(targetUrl,targetUser,targetPassword) : null);
   235|     }
   236|     ClientConnectionManager createClientConnectionManager() {
   237|         return pooledConnections ?
   238|                 new ThreadSafeClientConnManager(getHttpParams(), getSchemeRegistry()) :
   239|                 new SingleClientConnManager(getSchemeRegistry());
   240|     }
   241|     HttpParams getHttpParams() {
   242|         return params;
   243|     }
   244|     private SchemeRegistry getSchemeRegistry() {
   245|         SchemeRegistry schemeRegistry = new SchemeRegistry();
   246|         schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
   247|         schemeRegistry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
   248|         return schemeRegistry;
   249|     }
   250| }


# ====================================================================
# FILE: client/javascript/src/main/javascript/jolokia-cubism.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 3-43 ---
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| /**
    17|  * Jolokia integration into cubism (http://square.github.com/cubism/)
    18|  *
    19|  * This integration requires the following
    20|  */
    21| (function () {
    22|     var builder = function (cubism,Jolokia) {
    23|         var VERSION = "1.2.0";
    24|         var ctx_jolokia = function (url, opts) {
    25|             var source = {},
    26|                 context = this,
    27|                 j4p = createAgent(url, opts),
    28|                 step = 5e3;                    // 5 seconds by default
    29|             try
    30|             {
    31|                 context.on("start",function() {
    32|                     j4p.start();
    33|                 });
    34|                 context.on("stop",function() {
    35|                     j4p.stop();
    36|                 });
    37|             }
    38|             catch(err)
    39|             {
    40|             }
    41|             /**
    42|              * Factory method for create a metric objects which has various variants.
    43|              *


# ====================================================================
# FILE: client/javascript/src/main/javascript/jolokia.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 34-74 ---
    34|             type:"POST",
    35|             processData:false,
    36|             dataType:"json",
    37|             contentType:"text/json"
    38|         };
    39|         var PROCESSING_PARAMS = ["maxDepth", "maxCollectionSize", "maxObjects", "ignoreErrors", "canonicalNaming",
    40|                                  "serializeException", "includeStackTrace", "ifModifiedSince"];
    41|         /**
    42|          * Constructor for creating a client to the Jolokia agent.
    43|          *
    44|          * An object containing the default parameters can be provided as argument. For the possible parameters
    45|          * see {@link #request()}.
    46|          *
    47|          * @param param either a string in which case it is used as the URL to the agent or
    48|          *              an object with the default parameters as key-value pairs
    49|          */
    50|         function Jolokia(param) {
    51|             if (!(this instanceof arguments.callee)) {
    52|                 return new Jolokia(param);
    53|             }
    54|             this.CLIENT_VERSION = "1.2.0";
    55|             var jobs = [];
    56|             var agentOptions = {};
    57|             var pollerIsRunning = false;
    58|             if (typeof param === "string") {
    59|                 param = {url:param};
    60|             }
    61|             $.extend(agentOptions, DEFAULT_CLIENT_PARAMS, param);
    62|             /**
    63|              * The request method using one or more JSON requests and sending it to the agent. Beside the
    64|              * request a bunch of options can be given, which are merged with the options provided
    65|              * at the constructor (where the options given here take precedence).
    66|              *
    67|              * Known options are:
    68|              *
    69|              * <dl>
    70|              *   <dt>url</dt>
    71|              *   <dd>Agent URL, which is mandatory</dd>
    72|              *   <dt>method</dt>
    73|              *   <dd>
    74|              *     Either "post" or "get" depending on the desired HTTP method (case does not matter).

