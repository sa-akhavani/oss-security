# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/Version.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 4-33 ---
     4|  *
     5|  * Licensed under the Apache License, Version 2.0 (the "License");
     6|  * you may not use this file except in compliance with the License.
     7|  * You may obtain a copy of the License at
     8|  *
     9|  *       http://www.apache.org/licenses/LICENSE-2.0
    10|  *
    11|  * Unless required by applicable law or agreed to in writing, software
    12|  * distributed under the License is distributed on an "AS IS" BASIS,
    13|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    14|  * See the License for the specific language governing permissions and
    15|  * limitations under the License.
    16|  */
    17| /**
    18|  * Class holding the version of this agent and the protocol.
    19|  *
    20|  * @author roland
    21|  * @since Jun 11, 2009
    22|  */
    23| public final class Version {
    24|     private static final String VERSION = "1.2.1";
    25|     private static final String PROTOCOL = "7.1";
    26|     private Version() {}
    27|     public static String getAgentVersion() {
    28|         return VERSION;
    29|     }
    30|     public static String getProtocolVersion() {
    31|         return PROTOCOL;
    32|     }
    33| }


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/backend/BackendManager.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 151-195 ---
   151|         try {
   152|             localDispatcher.destroy();
   153|         } catch (JMException e) {
   154|             error("Cannot unregister MBean: " + e,e);
   155|         }
   156|     }
   157|     /**
   158|      * Check whether remote access from the given client is allowed.
   159|      *
   160|      * @param pRemoteHost remote host to check against
   161|      * @param pRemoteAddr alternative IP address
   162|      * @return true if remote access is allowed
   163|      */
   164|     public boolean isRemoteAccessAllowed(String pRemoteHost, String pRemoteAddr) {
   165|         return restrictor.isRemoteAccessAllowed(pRemoteHost, pRemoteAddr);
   166|     }
   167|     /**
   168|      * Check whether CORS access is allowed for the given origin.
   169|      *
   170|      * @param pOrigin origin URL which needs to be checked
   171|      * @param pStrictChecking whether to a strict check (i.e. server side check)
   172|      * @return true if if cors access is allowed
   173|      */
   174|     public boolean isOriginAllowed(String pOrigin,boolean pStrictChecking) {
   175|         return restrictor.isOriginAllowed(pOrigin, pStrictChecking);
   176|     }
   177|     /**
   178|      * Log at info level
   179|      *
   180|      * @param msg to log
   181|      */
   182|     public void info(String msg) {
   183|         logHandler.info(msg);
   184|         if (debugStore != null) {
   185|             debugStore.log(msg);
   186|         }
   187|     }
   188|     /**
   189|      * Log at debug level
   190|      *
   191|      * @param msg message to log
   192|      */
   193|     public void debug(String msg) {
   194|         logHandler.debug(msg);
   195|         if (debugStore != null) {


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/config/ConfigKey.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 105-151 ---
   105|      * <code>application/json</code>, too. A request parameter overrides a global
   106|      * configuration.
   107|      */
   108|     MIME_TYPE("mimeType", true, true, "text/plain"),
   109|     /**
   110|      * For LIST requests, this option can be used to return
   111|      * the result only if they set of registered MBeans has
   112|      * been changed since the timestamp given in this option.
   113|      * The timestamp has to be given in seconds since 1.1.1970
   114|      * (epoch time).
   115|      */
   116|     IF_MODIFIED_SINCE("ifModifiedSince",false,true),
   117|     /**
   118|      * Whether to enable listening and responding to discovery multicast requests
   119|      * for discovering agent details.
   120|      */
   121|     DISCOVERY_ENABLED("discoveryEnabled",true,false),
   122|     /**
   123|      * Specify the agent URL to return for an discovery multicast request. If this option
   124|      * is given {@link #DISCOVERY_ENABLED} is set to <code>true</code> automatically.
   125|      * The URL given can contain placeholders:
   126|      * <ul>
   127|      *    <li>$host or ${host} : Host name (if possible), otherwise address</li>
   128|      *    <li>$ip or ${ip} : IP Address</li>
   129|      *    <li>${prop:foo} : System property foo</li>
   130|      *    <li>${env:FOO} : Environment variable FOO</li>
   131|      * </ul>
   132|      */
   133|     DISCOVERY_AGENT_URL("discoveryAgentUrl",true,false),
   134|     /**
   135|      *  User for authentication purposes. Used by OSGi and JDK agent.
   136|      */
   137|     USER("user", true, false),
   138|     /**
   139|      *  Password for authentication purposes. Used by OSGi and JDK agent
   140|      */
   141|     PASSWORD("password", true, false),
   142|     /**
   143|      * Custom authenticator to be used instead of default user/password one
   144|      */
   145|     AUTHENTICATOR_CLASS("authenticatorClass", true, false),
   146|     /**
   147|      * Context used for agent, used e.g. in the OSGi activator
   148|      * (but not for the servlet, this is done in web.xml)
   149|      */
   150|     AGENT_CONTEXT("agentContext", true, false, "/jolokia"),
   151|     /**


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/detector/ActiveMQDetector.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-18 ---
     1| package org.jolokia.detector;
     2| import org.jolokia.backend.executor.MBeanServerExecutor;
     3| /**
     4|  * Detector for ActiveMQ
     5|  *
     6|  * @author roland
     7|  * @since 27.03.14
     8|  */
     9| public class ActiveMQDetector extends AbstractServerDetector {
    10|     /** {@inheritDoc} */
    11|     public ServerHandle detect(MBeanServerExecutor pMBeanServerExecutor) {
    12|         String version = getSingleStringAttribute(pMBeanServerExecutor, "org.apache.activemq:type=Broker,*", "BrokerVersion");
    13|         if (version == null) {
    14|             return null;
    15|         }
    16|         return new ServerHandle("Apache","activemq",version, null);
    17|     }
    18| }


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/detector/ServerDetector.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 13-43 ---
    13|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    14|  * See the License for the specific language governing permissions and
    15|  * limitations under the License.
    16|  */
    17| import java.util.Set;
    18| import javax.management.MBeanServerConnection;
    19| import org.jolokia.backend.executor.MBeanServerExecutor;
    20| /**
    21|  * A detector identifies a specific server. This is typically done by inspecting
    22|  * the runtime environment e.g. for the existance of certain classes. If a detector
    23|  * successfully detect 'its' server, it return a {@link ServerHandle} containing type, version
    24|  * and some optional information
    25|  * @author roland
    26|  * @since 05.11.10
    27|  */
    28| public interface ServerDetector {
    29|     /**
    30|      * Detect the server. A {@link ServerHandle} descriptor is returned
    31|      * in case of a successful detection, <code>null</code> otherwise.
    32|      *
    33|      * @param pMBeanServerExecutor a set of MBeanServers which can be used for detecting server informations
    34|      * @return the server descriptor or <code>null</code> it this implementation cant detect 'its' server.
    35|      */
    36|     ServerHandle detect(MBeanServerExecutor pMBeanServerExecutor);
    37|     /**
    38|      * Add server specific MBeanServers
    39|      *
    40|      * @param pMBeanServers set to add detected MBeanServers to
    41|      */
    42|     void addMBeanServers(Set<MBeanServerConnection> pMBeanServers);
    43| }


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/detector/WeblogicDetector.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 26-65 ---
    26|  * @author roland
    27|  * @since 05.12.10
    28|  */
    29| public class WeblogicDetector extends AbstractServerDetector {
    30|     /** {@inheritDoc}
    31|      * @param pMBeanServerExecutor*/
    32|     public ServerHandle detect(MBeanServerExecutor pMBeanServerExecutor) {
    33|         String domainConfigMBean = getSingleStringAttribute(pMBeanServerExecutor,"*:Name=RuntimeService,*","DomainConfiguration");
    34|         if (domainConfigMBean != null) {
    35|             String version = getSingleStringAttribute(pMBeanServerExecutor,domainConfigMBean,"ConfigurationVersion");
    36|             return new ServerHandle("Oracle","weblogic",version, null);
    37|         }
    38|         return null;
    39|     }
    40|     /**
    41|      * Adde Weblogic specific runtime MBeanServer
    42|      * @param servers set to add own MBean servers
    43|      */
    44|     @Override
    45|     public void addMBeanServers(Set<MBeanServerConnection> servers) {
    46|         if (!isJBoss()) {
    47|             InitialContext ctx;
    48|             try {
    49|                 ctx = new InitialContext();
    50|                 MBeanServer server = (MBeanServer) ctx.lookup("java:comp/env/jmx/runtime");
    51|                 if (server != null) {
    52|                     servers.add(server);
    53|                 }
    54|             } catch (NamingException e) {
    55|             }
    56|         }
    57|     }
    58|     private boolean isJBoss() {
    59|         try {
    60|             return Class.forName("org.jboss.mx.util.MBeanServerLocator") != null;
    61|         } catch (ClassNotFoundException e) {
    62|             return false;
    63|         }
    64|     }
    65| }


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/discovery/DiscoveryMulticastResponder.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 44-88 ---
    44|                                        AgentDetailsHolder pDetailsHolder,
    45|                                        Restrictor pRestrictor,
    46|                                        LogHandler pLogHandler) {
    47|         hostAddress = pHostAddress;
    48|         detailsHolder = pDetailsHolder;
    49|         restrictor = pRestrictor;
    50|         logHandler = pLogHandler;
    51|         listenerThreads = new ArrayList<MulticastSocketListenerThread>();
    52|     }
    53|     /**
    54|      * Start the responder (if not already started)
    55|      */
    56|     public synchronized void start() throws IOException {
    57|         if (listenerThreads.size() == 0) {
    58|             List<InetAddress> addresses = hostAddress == null ? NetworkUtil.getMulticastAddresses() : Arrays.asList(hostAddress);
    59|             if (addresses.size() == 0) {
    60|                 logHandler.info("No suitable address found for listening on multicast discovery requests");
    61|                 return;
    62|             }
    63|             for (InetAddress addr : addresses) {
    64|                 try {
    65|                     MulticastSocketListenerThread thread = new MulticastSocketListenerThread(addr,
    66|                                                                                              detailsHolder,
    67|                                                                                              restrictor,
    68|                                                                                              logHandler);
    69|                     thread.start();
    70|                     listenerThreads.add(thread);
    71|                 } catch (IOException exp) {
    72|                     logHandler.info("Couldn't start discovery thread for " + addr + ": " + exp);
    73|                 }
    74|             }
    75|         }
    76|     }
    77|     /**
    78|      * Stop the responder (if not already stopped). Can be restarted aftewards.
    79|      */
    80|     public synchronized void stop() {
    81|         if (listenerThreads.size() > 0) {
    82|             for (MulticastSocketListenerThread thread : listenerThreads) {
    83|                 thread.shutdown();
    84|             }
    85|         }
    86|         listenerThreads.clear();
    87|     }
    88| }


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/discovery/MulticastSocketListenerThread.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 16-57 ---
    16|     private final Restrictor restrictor;
    17|     private final LogHandler logHandler;
    18|     private final InetAddress address;
    19|     private boolean running;
    20|     private MulticastSocket socket;
    21|     /**
    22|      * Constructor, used internally.
    23|      *
    24|      * @param pHostAddress host address for creating a socket to listen to
    25|      * @param pAgentDetailsHolder the holder which has the agent details
    26|      * @param pRestrictor restrictor to check whether an incoming package should be answered which
    27|      *                    is done only when {@link Restrictor#isRemoteAccessAllowed(String...)} returns true for
    28|      *                    the address from which the packet was received.
    29|      * @param pLogHandler log handler used for logging
    30|      */
    31|     MulticastSocketListenerThread(InetAddress pHostAddress, AgentDetailsHolder pAgentDetailsHolder, Restrictor pRestrictor, LogHandler pLogHandler) throws IOException {
    32|         address = pHostAddress != null ? pHostAddress : NetworkUtil.getLocalAddressWithMulticast();
    33|         agentDetailsHolder = pAgentDetailsHolder;
    34|         restrictor = pRestrictor;
    35|         logHandler = pLogHandler;
    36|         socket = MulticastUtil.newMulticastSocket(address,logHandler);
    37|         logHandler.debug(address + "<-- Listening for queries");
    38|     }
    39|     /** {@inheritDoc} */
    40|     public void run() {
    41|         setRunning(true);
    42|         try {
    43|             while (isRunning()) {
    44|                 refreshSocket();
    45|                 logHandler.debug(address + "<-- Waiting");
    46|                 DiscoveryIncomingMessage msg = receiveMessage();
    47|                 if (shouldMessageBeProcessed(msg)) {
    48|                     handleQuery(msg);
    49|                 }
    50|             }
    51|         }
    52|         catch (IllegalStateException e) {
    53|             logHandler.error(address + "<-- Cannot reopen socket, exiting listener thread: " + e.getCause(),e.getCause());
    54|         } finally {
    55|             if (socket != null) {
    56|                 socket.close();
    57|             }

# --- HUNK 2: Lines 76-118 ---
    76|     }
    77|     private DiscoveryIncomingMessage receiveMessage() {
    78|         byte buf[] = new byte[AbstractDiscoveryMessage.MAX_MSG_SIZE];
    79|         DatagramPacket packet = new DatagramPacket(buf, buf.length);
    80|         try {
    81|             packet.setLength(buf.length);
    82|             socket.receive(packet);
    83|             return new DiscoveryIncomingMessage(packet);
    84|         }  catch (IOException e) {
    85|             if (!socket.isClosed()) {
    86|                 logHandler.info("Error while handling discovery request" + (packet.getAddress() != null ? " from " + packet.getAddress() : "") +
    87|                                 ". Ignoring this request. --> " + e);
    88|             }
    89|             return null;
    90|         }
    91|     }
    92|     private void refreshSocket() {
    93|         if (socket.isClosed()) {
    94|             logHandler.info(address + "<-- Socket closed, reopening it");
    95|             try {
    96|                 socket = MulticastUtil.newMulticastSocket(address, logHandler);
    97|             } catch (IOException exp) {
    98|                 logHandler.error("Cannot reopen socket. Exiting multicast listener thread ...",exp);
    99|                 throw new SocketVerificationFailedException(exp);
   100|             }
   101|         }
   102|     }
   103|     private void handleQuery(DiscoveryIncomingMessage pMsg) {
   104|         DiscoveryOutgoingMessage answer =
   105|                 new DiscoveryOutgoingMessage.Builder(RESPONSE)
   106|                         .respondTo(pMsg)
   107|                         .agentDetails(agentDetailsHolder.getAgentDetails())
   108|                         .build();
   109|         logHandler.debug(address + "<-- Discovery request from " + pMsg.getSourceAddress() + ":" + pMsg.getSourcePort());
   110|         send(answer);
   111|     }
   112|     private void send(DiscoveryOutgoingMessage pAnswer) {
   113|         byte[] message = pAnswer.getData();
   114|         final DatagramPacket packet =
   115|                 new DatagramPacket(message, message.length,
   116|                                    pAnswer.getTargetAddress(),pAnswer.getTargetPort());
   117|         if (!socket.isClosed()) {
   118|             try {


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/discovery/MulticastUtil.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-48 ---
     1| package org.jolokia.discovery;
     2| import java.io.IOException;
     3| import java.net.*;
     4| import java.util.*;
     5| import java.util.concurrent.*;
     6| import org.jolokia.util.LogHandler;
     7| import org.jolokia.util.NetworkUtil;
     8| /**
     9|  * Utility class for handling multicast stuff
    10|  *
    11|  * @author roland
    12|  * @since 28.01.14
    13|  */
    14| public final class MulticastUtil {
    15|     public static final String JOLOKIA_MULTICAST_GROUP = "239.192.48.84";
    16|     public static final int JOLOKIA_MULTICAST_PORT = 24884;
    17|     private MulticastUtil() {
    18|     }
    19|     static MulticastSocket newMulticastSocket(InetAddress pAddress, LogHandler pLogHandler) throws IOException {
    20|         InetSocketAddress socketAddress =
    21|                 new InetSocketAddress(JOLOKIA_MULTICAST_GROUP, JOLOKIA_MULTICAST_PORT);
    22|         MulticastSocket socket = new MulticastSocket(JOLOKIA_MULTICAST_PORT);
    23|         socket.setReuseAddress(true);
    24|         setOutgoingInterfaceForMulticastRequest(pAddress, socket);
    25|         socket.setTimeToLive(255);
    26|         if (joinMcGroupsOnAllNetworkInterfaces(socket, socketAddress, pLogHandler) == 0) {
    27|             throw new IOException("Couldn't join multicast group " + socketAddress + " on any network interfaces");
    28|         }
    29|         return socket;
    30|     }
    31|     /**
    32|      * Sent out a message to Jolokia's multicast group over all network interfaces supporting multicast request (and no
    33|      * logging is used)
    34|      *
    35|      * @param pOutMsg  the message to send
    36|      * @param pTimeout timeout used for how long to wait for discovery messages
    37|      * @return list of received answers, never null
    38|      * @throws IOException if something fails during the discovery request
    39|      */
    40|     public static List<DiscoveryIncomingMessage> sendQueryAndCollectAnswers(DiscoveryOutgoingMessage pOutMsg, int pTimeout) throws IOException {
    41|         return sendQueryAndCollectAnswers(pOutMsg, pTimeout, LogHandler.QUIET);
    42|     }
    43|     /**
    44|      * Sent out a message to Jolokia's multicast group over all network interfaces supporting multicasts
    45|      *
    46|      * @param pOutMsg     the message to send
    47|      * @param pTimeout    timeout used for how long to wait for discovery messages
    48|      * @param pLogHandler a log handler for printing out logging information

# --- HUNK 2: Lines 81-135 ---
    81|         Set<String> seen = new HashSet<String>();
    82|         for (Future<List<DiscoveryIncomingMessage>> future : pFutures) {
    83|             try {
    84|                 List<DiscoveryIncomingMessage> inMsgs = future.get(pTimeout + 500 /* some additional buffer */, TimeUnit.MILLISECONDS);
    85|                 for (DiscoveryIncomingMessage inMsg : inMsgs) {
    86|                     AgentDetails details = inMsg.getAgentDetails();
    87|                     String id = details.getAgentId();
    88|                     if (!seen.contains(id)) {
    89|                         ret.add(inMsg);
    90|                         seen.add(id);
    91|                     }
    92|                 }
    93|             } catch (InterruptedException exp) {
    94|             } catch (ExecutionException e) {
    95|                 pLogHandler.debug("--> Exception during lookup: " + e);
    96|             } catch (TimeoutException e) {
    97|             }
    98|         }
    99|         return ret;
   100|     }
   101|     private static int joinMcGroupsOnAllNetworkInterfaces(MulticastSocket pSocket, InetSocketAddress pSocketAddress, LogHandler pLogHandler) throws IOException {
   102|         Enumeration<NetworkInterface> nifs = NetworkInterface.getNetworkInterfaces();
   103|         int interfacesJoined = 0;
   104|         while (nifs.hasMoreElements()) {
   105|             NetworkInterface n = nifs.nextElement();
   106|             if (NetworkUtil.isMulticastSupported(n)) {
   107|                 try {
   108|                     pSocket.joinGroup(pSocketAddress, n);
   109|                     interfacesJoined++;
   110|                 } catch (IOException exp) {
   111|                     pLogHandler.info("Cannot join multicast group on NIF " + n.getDisplayName() + ": " + exp.getMessage());
   112|                 }
   113|             }
   114|         }
   115|         return interfacesJoined;
   116|     }
   117|     private static void setOutgoingInterfaceForMulticastRequest(InetAddress pAddress, MulticastSocket pSocket) throws SocketException, UnknownHostException {
   118|         NetworkInterface nif = NetworkInterface.getByInetAddress(pAddress);
   119|         if (nif != null) {
   120|             pSocket.setNetworkInterface(nif);
   121|         }
   122|     }
   123|     private static final class FindAgentsCallable implements Callable<List<DiscoveryIncomingMessage>> {
   124|         private final InetAddress address;
   125|         private final DatagramPacket outPacket;
   126|         private final int timeout;
   127|         private final LogHandler logHandler;
   128|         private FindAgentsCallable(InetAddress pAddress, DatagramPacket pOutPacket, int pTimeout, LogHandler pLogHandler) {
   129|             address = pAddress;
   130|             outPacket = pOutPacket;
   131|             timeout = pTimeout;
   132|             logHandler = pLogHandler;
   133|         }
   134|         public List<DiscoveryIncomingMessage> call() throws SocketException {
   135|             final DatagramSocket socket = new DatagramSocket(0, address);


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/handler/ReadHandler.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 51-90 ---
    51|                 }
    52|             };
    53|     /**
    54|      * Read handler constructor
    55|      *
    56|      * @param pRestrictor access restriction to apply
    57|      */
    58|     public ReadHandler(Restrictor pRestrictor) {
    59|         super(pRestrictor);
    60|     }
    61|     @Override
    62|     /** {@inheritDoc} */
    63|     public RequestType getType() {
    64|         return RequestType.READ;
    65|     }
    66|     /**
    67|      * For a simple requests (one MBean, one attribute) we let the dispatching of the servers
    68|      * done by the upper level. If the request is for an MBean pattern or multiple attributes
    69|      * are required, we try multiple requests for multiple server.
    70|      *
    71|      * @param pRequest request to decide on whether to handle all request at once
    72|      * @return true if this is a multi attribute request, has an MBean pattern to look for or is a request for
    73|      *         all attributes.
    74|      */
    75|     @Override
    76|     public boolean handleAllServersAtOnce(JmxReadRequest pRequest) {
    77|         return pRequest.getObjectName().isPattern() || pRequest.isMultiAttributeMode() || !pRequest.hasAttribute();
    78|     }
    79|     /**
    80|      * Used for a request to a single attribute from a single MBean. Merging of MBeanServers is done
    81|      * one layer above.
    82|      *
    83|      *
    84|      * @param pServer server on which to request the attribute
    85|      * @param pRequest the request itself.
    86|      * @return the attribute's value
    87|      */
    88|     @Override
    89|     public Object doHandleRequest(MBeanServerConnection pServer, JmxReadRequest pRequest)
    90|             throws InstanceNotFoundException, AttributeNotFoundException, ReflectionException, MBeanException, IOException {

# --- HUNK 2: Lines 168-208 ---
   168|                 ret.put(attribute, pFaultHandler.handleException(e));
   169|             } catch (ReflectionException e) {
   170|                 ret.put(attribute, pFaultHandler.handleException(e));
   171|             } catch (IOException e) {
   172|                 ret.put(attribute, pFaultHandler.handleException(e));
   173|             } catch (RuntimeException e) {
   174|                 ret.put(attribute, pFaultHandler.handleException(e));
   175|             }
   176|         }
   177|         return ret;
   178|     }
   179|     private List<String> resolveAttributes(MBeanServerExecutor pServers, ObjectName pMBeanName, List<String> pAttributeNames)
   180|             throws IOException, ReflectionException, MBeanException, AttributeNotFoundException, InstanceNotFoundException {
   181|         List<String> attributes = pAttributeNames;
   182|         if (shouldAllAttributesBeFetched(pAttributeNames)) {
   183|             attributes = getAllAttributesNames(pServers,pMBeanName);
   184|         }
   185|         return attributes;
   186|     }
   187|     private boolean shouldAllAttributesBeFetched(List<String> pAttributeNames) {
   188|         return pAttributeNames == null || pAttributeNames.size() == 0 || pAttributeNames.size() == 1 && pAttributeNames.get(0) == null;
   189|     }
   190|     private MBeanInfo getMBeanInfo(MBeanServerExecutor pServerManager, ObjectName pObjectName)
   191|             throws IOException, ReflectionException, MBeanException, AttributeNotFoundException, InstanceNotFoundException {
   192|         return pServerManager.call(pObjectName, MBEAN_INFO_HANDLER);
   193|     }
   194|     private Object getAttribute(MBeanServerExecutor pServerManager, ObjectName pMBeanName, String attribute)
   195|             throws MBeanException, ReflectionException, IOException, AttributeNotFoundException, InstanceNotFoundException {
   196|         return pServerManager.call(pMBeanName, MBEAN_ATTRIBUTE_READ_HANDLER, attribute);
   197|     }
   198|     private List<String> getAllAttributesNames(MBeanServerExecutor pServerManager, ObjectName pObjectName)
   199|             throws IOException, ReflectionException, MBeanException, AttributeNotFoundException, InstanceNotFoundException {
   200|         MBeanInfo mBeanInfo = getMBeanInfo(pServerManager, pObjectName);
   201|         List<String> ret = new ArrayList<String>();
   202|         for (MBeanAttributeInfo attrInfo : mBeanInfo.getAttributes()) {
   203|             if (attrInfo.isReadable()) {
   204|                 ret.add(attrInfo.getName());
   205|             }
   206|         }
   207|         return ret;
   208|     }


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/http/AgentServlet.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 134-174 ---
   134|             } else {
   135|                 initAgentUrlFromRequest = false;
   136|                 backendManager.getAgentDetails().updateAgentParameters(url, null);
   137|             }
   138|             try {
   139|                 discoveryMulticastResponder = new DiscoveryMulticastResponder(backendManager,restrictor,logHandler);
   140|                 discoveryMulticastResponder.start();
   141|             } catch (IOException e) {
   142|                 logHandler.error("Cannot start discovery multicast handler: " + e,e);
   143|             }
   144|         }
   145|     }
   146|     private String findAgentUrl(Configuration pConfig) {
   147|         String url = System.getProperty("jolokia." + ConfigKey.DISCOVERY_AGENT_URL.getKeyValue());
   148|         if (url == null) {
   149|             url = System.getenv("JOLOKIA_DISCOVERY_AGENT_URL");
   150|             if (url == null) {
   151|                 url = pConfig.get(ConfigKey.DISCOVERY_AGENT_URL);
   152|             }
   153|         }
   154|         return NetworkUtil.replaceExpression(url);
   155|     }
   156|     private boolean listenForDiscoveryMcRequests(Configuration pConfig) {
   157|         boolean sysProp = System.getProperty("jolokia." + ConfigKey.DISCOVERY_ENABLED.getKeyValue()) != null;
   158|         boolean env     = System.getenv("JOLOKIA_DISCOVERY") != null;
   159|         boolean config  = pConfig.getAsBoolean(ConfigKey.DISCOVERY_ENABLED);
   160|         return sysProp || env || config;
   161|     }
   162|     /**
   163|      * Create a log handler using this servlet's logging facility for logging. This method can be overridden
   164|      * to provide a custom log handler. This method is called before {@link #createRestrictor(String)} so the log handler
   165|      * can already be used when building up the restrictor.
   166|      *
   167|      * @return a default log handler
   168|      * @param pServletConfig servlet config from where to get information to build up the log handler
   169|      * @param pDebug whether to print out  debug information.
   170|      */
   171|     protected LogHandler createLogHandler(ServletConfig pServletConfig, final boolean pDebug) {
   172|         return new LogHandler() {
   173|             /** {@inheritDoc} */
   174|             public void debug(String message) {

# --- HUNK 2: Lines 211-277 ---
   211|     /**
   212|      * OPTION requests are treated as CORS preflight requests
   213|      *
   214|      * @param req the original request
   215|      * @param resp the response the answer are written to
   216|      * */
   217|     @Override
   218|     protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
   219|         Map<String,String> responseHeaders =
   220|                 requestHandler.handleCorsPreflightRequest(
   221|                         req.getHeader("Origin"),
   222|                         req.getHeader("Access-Control-Request-Headers"));
   223|         for (Map.Entry<String,String> entry : responseHeaders.entrySet()) {
   224|             resp.setHeader(entry.getKey(),entry.getValue());
   225|         }
   226|     }
   227|     @SuppressWarnings({ "PMD.AvoidCatchingThrowable", "PMD.AvoidInstanceofChecksInCatchClause" })
   228|     private void handle(ServletRequestHandler pReqHandler,HttpServletRequest pReq, HttpServletResponse pResp) throws IOException {
   229|         JSONAware json = null;
   230|         try {
   231|             requestHandler.checkAccess(pReq.getRemoteHost(), pReq.getRemoteAddr(),
   232|                                        getOriginOrReferer(pReq));
   233|             updateAgentUrlIfNeeded(pReq);
   234|             json = pReqHandler.handleRequest(pReq,pResp);
   235|         } catch (Throwable exp) {
   236|             json = requestHandler.handleThrowable(
   237|                     exp instanceof RuntimeMBeanException ? ((RuntimeMBeanException) exp).getTargetException() : exp);
   238|         } finally {
   239|             setCorsHeader(pReq, pResp);
   240|             String callback = pReq.getParameter(ConfigKey.CALLBACK.getKeyValue());
   241|             String answer = json != null ?
   242|                     json.toJSONString() :
   243|                     requestHandler.handleThrowable(new Exception("Internal error while handling an exception")).toJSONString();
   244|             if (callback != null) {
   245|                 sendResponse(pResp, "text/javascript", callback + "(" + answer + ");");
   246|             } else {
   247|                 sendResponse(pResp, getMimeType(pReq),answer);
   248|             }
   249|         }
   250|     }
   251|     private String getOriginOrReferer(HttpServletRequest pReq) {
   252|         String origin = pReq.getHeader("Origin");
   253|         if (origin == null) {
   254|             origin = pReq.getHeader("Referer");
   255|         }
   256|         return origin != null ? origin.replaceAll("[\\n\\r]*","") : null;
   257|     }
   258|     private void updateAgentUrlIfNeeded(HttpServletRequest pReq) {
   259|         if (initAgentUrlFromRequest) {
   260|             updateAgentUrl(NetworkUtil.sanitizeLocalUrl(pReq.getRequestURL().toString()), extractServletPath(pReq),pReq.getAuthType() != null);
   261|             initAgentUrlFromRequest = false;
   262|         }
   263|     }
   264|     private String extractServletPath(HttpServletRequest pReq) {
   265|         return pReq.getRequestURI().substring(0,pReq.getContextPath().length());
   266|     }
   267|     private void updateAgentUrl(String pRequestUrl, String pServletPath, boolean pIsAuthenticated) {
   268|         String url = getBaseUrl(pRequestUrl, pServletPath);
   269|         backendManager.getAgentDetails().updateAgentParameters(url,pIsAuthenticated);
   270|     }
   271|     private String getBaseUrl(String pUrl, String pServletPath) {
   272|         String sUrl;
   273|         try {
   274|             URL url = new URL(pUrl);
   275|             String host = getIpIfPossible(url.getHost());
   276|             sUrl = new URL(url.getProtocol(),host,url.getPort(),pServletPath).toExternalForm();
   277|         } catch (MalformedURLException exp) {


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/http/HttpRequestHandler.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 114-154 ---
   114|         } else if (jsonRequest instanceof JSONObject) {
   115|             JmxRequest jmxReq = JmxRequestFactory.createPostRequest((Map<String, ?>) jsonRequest,getProcessingParameter(pParameterMap));
   116|             return executeRequest(jmxReq);
   117|         } else {
   118|             throw new IllegalArgumentException("Invalid JSON Request " + jsonRequest);
   119|         }
   120|     }
   121|     /**
   122|      * Handling an option request which is used for preflight checks before a CORS based browser request is
   123|      * sent (for certain circumstances).
   124|      *
   125|      * See the <a href="http://www.w3.org/TR/cors/">CORS specification</a>
   126|      * (section 'preflight checks') for more details.
   127|      *
   128|      * @param pOrigin the origin to check. If <code>null</code>, no headers are returned
   129|      * @param pRequestHeaders extra headers to check against
   130|      * @return headers to set
   131|      */
   132|     public Map<String, String> handleCorsPreflightRequest(String pOrigin, String pRequestHeaders) {
   133|         Map<String,String> ret = new HashMap<String, String>();
   134|         if (pOrigin != null && backendManager.isOriginAllowed(pOrigin,false)) {
   135|             ret.put("Access-Control-Allow-Origin","null".equals(pOrigin) ? "*" : pOrigin);
   136|             if (pRequestHeaders != null) {
   137|                 ret.put("Access-Control-Allow-Headers",pRequestHeaders);
   138|             }
   139|             ret.put("Access-Control-Allow-Credentials","true");
   140|             ret.put("Access-Control-Allow-Max-Age","" + 3600 * 24 * 365);
   141|         }
   142|         return ret;
   143|     }
   144|     private Object extractJsonRequest(InputStream pInputStream, String pEncoding) throws IOException {
   145|         InputStreamReader reader = null;
   146|         try {
   147|             reader =
   148|                     pEncoding != null ?
   149|                             new InputStreamReader(pInputStream, pEncoding) :
   150|                             new InputStreamReader(pInputStream);
   151|             JSONParser parser = new JSONParser();
   152|             return parser.parse(reader);
   153|         } catch (ParseException exp) {
   154|             throw new IllegalArgumentException("Invalid JSON request " + reader,exp);

# --- HUNK 2: Lines 221-282 ---
   221|      */
   222|     public JSONObject getErrorJSON(int pErrorCode, Throwable pExp, JmxRequest pJmxReq) {
   223|         JSONObject jsonObject = new JSONObject();
   224|         jsonObject.put("status",pErrorCode);
   225|         jsonObject.put("error",getExceptionMessage(pExp));
   226|         jsonObject.put("error_type", pExp.getClass().getName());
   227|         addErrorInfo(jsonObject, pExp, pJmxReq);
   228|         if (backendManager.isDebug()) {
   229|             backendManager.error("Error " + pErrorCode,pExp);
   230|         }
   231|         if (pJmxReq != null) {
   232|             jsonObject.put("request",pJmxReq.toJSON());
   233|         }
   234|         return jsonObject;
   235|     }
   236|     /**
   237|      * Check whether the given host and/or address is allowed to access this agent.
   238|      *
   239|      * @param pHost host to check
   240|      * @param pAddress address to check
   241|      * @param pOrigin (optional) origin header to check also.
   242|      */
   243|     public void checkAccess(String pHost, String pAddress, String pOrigin) {
   244|         if (!backendManager.isRemoteAccessAllowed(pHost,pAddress)) {
   245|             throw new SecurityException("No access from client " + pAddress + " allowed");
   246|         }
   247|         if (pOrigin != null && !backendManager.isOriginAllowed(pOrigin,true)) {
   248|             throw new SecurityException("Origin " + pOrigin + " is not allowed to call this agent");
   249|         }
   250|     }
   251|     /**
   252|      * Check whether for the given host is a cross-browser request allowed. This check is delegated to the
   253|      * backendmanager which is responsible for the security configuration.
   254|      * Also, some sanity checks are applied.
   255|      *
   256|      * @param pOrigin the origin URL to check against
   257|      * @return the origin to put in the response header or null if none is to be set
   258|      */
   259|     public String extractCorsOrigin(String pOrigin) {
   260|         if (pOrigin != null) {
   261|             String origin  = pOrigin.replaceAll("[\\n\\r]*","");
   262|             if (backendManager.isOriginAllowed(origin,false)) {
   263|                 return "null".equals(origin) ? "*" : origin;
   264|             } else {
   265|                 return null;
   266|             }
   267|         }
   268|         return null;
   269|     }
   270|     private void addErrorInfo(JSONObject pErrorResp, Throwable pExp, JmxRequest pJmxReq) {
   271|         String includeStackTrace = pJmxReq != null ?
   272|                 pJmxReq.getParameter(ConfigKey.INCLUDE_STACKTRACE) : "true";
   273|         if (includeStackTrace.equalsIgnoreCase("true") ||
   274|             (includeStackTrace.equalsIgnoreCase("runtime") && pExp instanceof RuntimeException)) {
   275|             StringWriter writer = new StringWriter();
   276|             pExp.printStackTrace(new PrintWriter(writer));
   277|             pErrorResp.put("stacktrace",writer.toString());
   278|         }
   279|         if (pJmxReq != null && pJmxReq.getParameterAsBool(ConfigKey.SERIALIZE_EXCEPTION)) {
   280|             pErrorResp.put("error_value",backendManager.convertExceptionToJson(pExp,pJmxReq));
   281|         }
   282|     }


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/request/JmxObjectNameRequest.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 72-112 ---
    72|         return ret.toString();
    73|     }
    74|     /**
    75|      * Get object name of MBean
    76|      *
    77|      * @return the object name
    78|      */
    79|     public ObjectName getObjectName() {
    80|         return objectName;
    81|     }
    82|     /**
    83|      * String representation of the object name for this request.
    84|      *
    85|      * @return the object name a string representation
    86|      */
    87|     public String getObjectNameAsString() {
    88|         return objectName.getCanonicalName();
    89|     }
    90|     /**
    91|      * Name prepared according to requested formatting note. The key ordering can be influenced by the
    92|      * processing parameter {@link ConfigKey#CANONICAL_NAMING}. If not given or set to "true",
    93|      * then the canonical order is used, if set to "initial" the name is given to construction time
    94|      * is used.
    95|      *
    96|      * @param pName name to format
    97|      * @return formatted string
    98|      */
    99|     public String getOrderedObjectName(ObjectName pName) {
   100|         if (pName.isPattern()) {
   101|             return pName.getCanonicalName();
   102|         }
   103|         if (getParameterAsBool(ConfigKey.CANONICAL_NAMING)) {
   104|             return pName.getCanonicalName();
   105|         } else {
   106|             return pName.getDomain() + ":" + pName.getKeyPropertyListString();
   107|         }
   108|     }
   109|     private void initObjectName(String pObjectName) throws MalformedObjectNameException {
   110|         if (pObjectName == null) {
   111|             throw new IllegalArgumentException("Objectname can not be null");
   112|         }


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/request/JmxReadRequest.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 72-113 ---
    72|                                             "" + attributeNames + "). Use getAttributeNames() instead.");
    73|         }
    74|         return attributeNames.get(0);
    75|     }
    76|     /**
    77|      * Get the list of all attribute names.
    78|      *
    79|      * @return list of attributes names or null
    80|      */
    81|     public List<String> getAttributeNames() {
    82|         return attributeNames;
    83|     }
    84|     /**
    85|      * Whether this is a multi-attribute request, i.e. whether it contains one ore more attributes to fetch
    86|      * @return true if this is a multi attribute request, false otherwise.
    87|      */
    88|     public boolean isMultiAttributeMode() {
    89|         return multiAttributeMode;
    90|     }
    91|     /**
    92|      * Whether this request has not multiple attribute names associated  (which normally means, that all attributes should be fetched).
    93|      * @return true if not multiple attribute names are contained.
    94|      */
    95|     public boolean hasAttribute() {
    96|         return isMultiAttributeMode() || getAttributeName() != null;
    97|     }
    98|     /** {@inheritDoc} */
    99|     public JSONObject toJSON() {
   100|         JSONObject ret = super.toJSON();
   101|         if (attributeNames != null && attributeNames.size() > 0) {
   102|             if (attributeNames.size() > 1) {
   103|                 ret.put("attribute", attributeNames);
   104|             } else {
   105|                 ret.put("attribute", attributeNames.get(0));
   106|             }
   107|         }
   108|         if (getPathParts() != null && getPathParts().size() > 0) {
   109|             ret.put("path", getPath());
   110|         }
   111|         return ret;
   112|     }
   113|     /** {@inheritDoc} */


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/restrictor/AbstractConstantRestrictor.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 43-66 ---
    43|     public final boolean isTypeAllowed(RequestType pType) {
    44|         return isAllowed;
    45|     }
    46|     /** {@inheritDoc} */
    47|     public final boolean isAttributeReadAllowed(ObjectName pName, String pAttribute) {
    48|         return isAllowed;
    49|     }
    50|     /** {@inheritDoc} */
    51|     public final boolean isAttributeWriteAllowed(ObjectName pName, String pAttribute) {
    52|         return isAllowed;
    53|     }
    54|     /** {@inheritDoc} */
    55|     public final boolean isOperationAllowed(ObjectName pName, String pOperation) {
    56|         return isAllowed;
    57|     }
    58|     /** {@inheritDoc} */
    59|     public final boolean isRemoteAccessAllowed(String... pHostOrAddress) {
    60|         return isAllowed;
    61|     }
    62|     /** {@inheritDoc} */
    63|     public boolean isOriginAllowed(String pOrigin, boolean pIsStrictCheck) {
    64|         return isAllowed;
    65|     }
    66| }


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/restrictor/PolicyRestrictor.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 60-99 ---
    60|         catch (IOException e) { exp = e; }
    61|         catch (ParserConfigurationException e) { exp = e; }
    62|         catch (MalformedObjectNameException e) { exp = e; }
    63|         if (exp != null) {
    64|             throw new SecurityException("Cannot parse policy file: " + exp,exp);
    65|         }
    66|     }
    67|     /** {@inheritDoc} */
    68|     public boolean isHttpMethodAllowed(HttpMethod method) {
    69|         return httpChecker.check(method);
    70|     }
    71|     /** {@inheritDoc} */
    72|     public boolean isTypeAllowed(RequestType pType) {
    73|         return requestTypeChecker.check(pType);
    74|     }
    75|     /** {@inheritDoc} */
    76|     public boolean isRemoteAccessAllowed(String ... pHostOrAddress) {
    77|         return networkChecker.check(pHostOrAddress);
    78|     }
    79|     /** {@inheritDoc} */
    80|     public boolean isOriginAllowed(String pOrigin, boolean pIsStrictCheck) {
    81|         return corsChecker.check(pOrigin,pIsStrictCheck);
    82|     }
    83|     /** {@inheritDoc} */
    84|     public boolean isAttributeReadAllowed(ObjectName pName, String pAttribute) {
    85|         return check(RequestType.READ,pName,pAttribute);
    86|     }
    87|     /** {@inheritDoc} */
    88|     public boolean isAttributeWriteAllowed(ObjectName pName, String pAttribute) {
    89|         return check(RequestType.WRITE,pName, pAttribute);
    90|     }
    91|     /** {@inheritDoc} */
    92|     public boolean isOperationAllowed(ObjectName pName, String pOperation) {
    93|         return check(RequestType.EXEC,pName, pOperation);
    94|     }
    95|     /** {@inheritDoc} */
    96|     private boolean check(RequestType pType, ObjectName pName, String pValue) {
    97|         return mbeanAccessChecker.check(new MBeanAccessChecker.Arg(isTypeAllowed(pType), pType, pName, pValue));
    98|     }
    99| }


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/restrictor/Restrictor.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 61-86 ---
    61|      * Check whether execution of an operation is allowed
    62|      *
    63|      * @param pName MBean name
    64|      * @param pOperation attribute to check
    65|      * @return true if access is allowed
    66|      */
    67|     boolean isOperationAllowed(ObjectName pName,String pOperation);
    68|     /**
    69|      * Check whether access from the connected client is allowed. If at least
    70|      * one of the given parameters matches, then this method returns true.
    71|      *
    72|      * @return true is access is allowed
    73|      * @param pHostOrAddress one or more host or address names
    74|      */
    75|     boolean isRemoteAccessAllowed(String ... pHostOrAddress);
    76|     /**
    77|      * Check whether cross browser access via CORS is allowed. See the
    78|      * <a href="https://developer.mozilla.org/en/http_access_control">CORS</a> specification
    79|      * for details
    80|      *
    81|      * @param pOrigin the "Origin:" header provided within the request
    82|      * @param pIsStrictCheck whether doing a strict check
    83|      * @return true if this cross browser request allowed, false otherwise
    84|      */
    85|     boolean isOriginAllowed(String pOrigin, boolean pIsStrictCheck);
    86| }


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/restrictor/policy/CorsChecker.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 8-87 ---
     8|  *
     9|  *       http://www.apache.org/licenses/LICENSE-2.0
    10|  *
    11|  * Unless required by applicable law or agreed to in writing, software
    12|  * distributed under the License is distributed on an "AS IS" BASIS,
    13|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    14|  * See the License for the specific language governing permissions and
    15|  * limitations under the License.
    16|  */
    17| import java.util.ArrayList;
    18| import java.util.List;
    19| import java.util.regex.Pattern;
    20| import org.w3c.dom.*;
    21| /**
    22|  * Check for location restrictions for CORS based cross browser platform requests
    23|  *
    24|  * @author roland
    25|  * @since 07.04.12
    26|  */
    27| public class CorsChecker extends AbstractChecker<String> {
    28|     private boolean strictChecking = false;
    29|     private List<Pattern> patterns;
    30|     /**
    31|      * Constructor buiilding up this checker from the XML document provided.
    32|      * CORS sections look like
    33|      * <pre>
    34|      *     &lt;cors&gt;
    35|      *       &lt;allow-origin&gt;http://jolokia.org&lt;allow-origin&gt;
    36|      *       &lt;allow-origin&gt;*://*.jmx4perl.org&gt;
    37|      *
    38|      *       &lt;strict-checking/&gt;
    39|      *     &lt;/cors&gt;
    40|      * </pre>
    41|      *
    42|      * @param pDoc the overall policy documents
    43|      */
    44|     public CorsChecker(Document pDoc) {
    45|         NodeList corsNodes = pDoc.getElementsByTagName("cors");
    46|         if (corsNodes.getLength() > 0) {
    47|             patterns = new ArrayList<Pattern>();
    48|             for (int i = 0; i < corsNodes.getLength(); i++) {
    49|                 Node corsNode = corsNodes.item(i);
    50|                 NodeList nodes = corsNode.getChildNodes();
    51|                 for (int j = 0;j <nodes.getLength();j++) {
    52|                     Node node = nodes.item(j);
    53|                     if (node.getNodeType() != Node.ELEMENT_NODE) {
    54|                         continue;
    55|                     }
    56|                     assertNodeName(node,"allow-origin","strict-checking");
    57|                     if (node.getNodeName().equals("allow-origin")) {
    58|                         String p = node.getTextContent().trim().toLowerCase();
    59|                         p = Pattern.quote(p).replace("*", "\\E.*\\Q");
    60|                         patterns.add(Pattern.compile("^" + p + "$"));
    61|                     } else if (node.getNodeName().equals("strict-checking")) {
    62|                         strictChecking = true;
    63|                     }
    64|                 }
    65|             }
    66|         }
    67|     }
    68|     /** {@inheritDoc} */
    69|     @Override
    70|     public boolean check(String pArg) {
    71|         return check(pArg,false);
    72|     }
    73|     public boolean check(String pOrigin, boolean pIsStrictCheck) {
    74|         if (pIsStrictCheck && !strictChecking) {
    75|             return true;
    76|         }
    77|         if (patterns == null || patterns.size() == 0) {
    78|             return true;
    79|         }
    80|         for (Pattern pattern : patterns) {
    81|             if (pattern.matcher(pOrigin).matches()) {
    82|                 return true;
    83|             }
    84|         }
    85|         return false;
    86|     }
    87| }


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/util/LogHandler.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 49-77 ---
    49|         public void error(String message, Throwable t) { }
    50|     };
    51|     /**
    52|      * Loghandler for printing to stdout
    53|      */
    54|     class StdoutLogHandler implements LogHandler {
    55|         private boolean doDebug;
    56|         public StdoutLogHandler(boolean pDoDebug) {
    57|             doDebug = pDoDebug;
    58|         }
    59|         public void debug(String message) {
    60|             if (doDebug) {
    61|                 log("D> " + message);
    62|             }
    63|         }
    64|         public void info(String message) {
    65|             log("I> " + message);
    66|         }
    67|         public void error(String message, Throwable t) {
    68|             log("E> " + message);
    69|             if (t != null) {
    70|                 t.printStackTrace();
    71|             }
    72|         }
    73|         private void log(String message) {
    74|             System.out.println(message); //NOSONAR
    75|         }
    76|     }
    77| }


# ====================================================================
# FILE: agent/core/src/main/java/org/jolokia/util/NetworkUtil.java
# Total hunks: 6
# ====================================================================
# --- HUNK 1: Lines 1-340 ---
     1| package org.jolokia.util;
     2| import java.io.IOException;
     3| import java.lang.management.ManagementFactory;
     4| import java.lang.reflect.InvocationTargetException;
     5| import java.lang.reflect.Method;
     6| import java.net.*;
     7| import java.util.*;
     8| import java.util.regex.Matcher;
     9| import java.util.regex.Pattern;
    10| /**
    11|  * Utility class for network related stuff
    12|  *
    13|  * @author roland
    14|  * @since 05.02.14
    15|  */
    16| public final class NetworkUtil {
    17|     private static Method isUp;
    18|     private static Method supportsMulticast;
    19|     static {
    20|         try {
    21|             isUp = NetworkInterface.class.getMethod("isUp", (Class<?>[]) null);
    22|             supportsMulticast = NetworkInterface.class.getMethod("supportsMulticast", (Class<?>[]) null);
    23|         } catch (NoSuchMethodException e) {
    24|             isUp = null;
    25|             supportsMulticast = null;
    26|         }
    27|     }
    28|     private NetworkUtil() {
    29|     }
    30|     public static void main(String[] args) throws UnknownHostException, SocketException {
    31|         System.out.println(dumpLocalNetworkInfo()); // NOSONAR
    32|     }
    33|     /**
    34|      * Get a local, IP4 Address, preferable a non-loopback address which is bound to an interface.
    35|      *
    36|      * @return
    37|      * @throws UnknownHostException
    38|      * @throws SocketException
    39|      */
    40|     public static InetAddress getLocalAddress() throws UnknownHostException, SocketException {
    41|         InetAddress addr = InetAddress.getLocalHost();
    42|         NetworkInterface nif = NetworkInterface.getByInetAddress(addr);
    43|         if (addr.isLoopbackAddress() || addr instanceof Inet6Address || nif == null) {
    44|             InetAddress lookedUpAddr = findLocalAddressViaNetworkInterface();
    45|             addr = lookedUpAddr != null ? lookedUpAddr : InetAddress.getByName("127.0.0.1");
    46|         }
    47|         return addr;
    48|     }
    49|     /**
    50|      * Get a local address which supports multicast. A loopback adress is returned, but only if not
    51|      * another is available
    52|      *
    53|      * @return a multicast enabled address of null if none could be found
    54|      * @throws UnknownHostException
    55|      * @throws SocketException
    56|      */
    57|     public static InetAddress getLocalAddressWithMulticast() throws UnknownHostException, SocketException {
    58|         InetAddress addr = InetAddress.getLocalHost();
    59|         NetworkInterface nif = NetworkInterface.getByInetAddress(addr);
    60|         if (addr.isLoopbackAddress() || addr instanceof Inet6Address || !isMulticastSupported(nif)) {
    61|             InetAddress lookedUpAddr = findLocalAddressViaNetworkInterface();
    62|             if (lookedUpAddr != null) {
    63|                 return lookedUpAddr;
    64|             }
    65|             addr = InetAddress.getByName("127.0.0.1");
    66|         }
    67|         if (isMulticastSupported(addr)) {
    68|             return addr;
    69|         } else {
    70|             throw new UnknownHostException("Cannot find address of local host which can be used for multicasting");
    71|         }
    72|     }
    73|     public static InetAddress findLocalAddressViaNetworkInterface() {
    74|         Enumeration<NetworkInterface> networkInterfaces;
    75|         try {
    76|             networkInterfaces = NetworkInterface.getNetworkInterfaces();
    77|         } catch (SocketException e) {
    78|             return null;
    79|         }
    80|         while (networkInterfaces.hasMoreElements()) {
    81|             NetworkInterface nif = networkInterfaces.nextElement();
    82|             for (Enumeration<InetAddress> addrEnum = nif.getInetAddresses(); addrEnum.hasMoreElements(); ) {
    83|                 InetAddress interfaceAddress = addrEnum.nextElement();
    84|                 if (useInetAddress(nif, interfaceAddress)) {
    85|                     return interfaceAddress;
    86|                 }
    87|             }
    88|         }
    89|         return null;
    90|     }
    91|     /**
    92|      * Check, whether multicast is supported at all by at least one interface
    93|      *
    94|      * @return true if at least one network interface supports multicast
    95|      */
    96|     public static boolean isMulticastSupported() throws SocketException {
    97|         return getMulticastAddresses().size() != 0;
    98|     }
    99|     /**
   100|      * Check whether the given interface supports multicast and is up
   101|      *
   102|      * @param pNif check whether the given interface supports multicast
   103|      * @return true if multicast is supported and the interface is up
   104|      */
   105|     public static boolean isMulticastSupported(NetworkInterface pNif) {
   106|         return pNif != null && checkMethod(pNif, isUp) && checkMethod(pNif, supportsMulticast);
   107|     }
   108|     /**
   109|      * Check whether the given address' interface supports multicast
   110|      *
   111|      * @param pAddr address to check
   112|      * @return true if the underlying networkinterface is up and supports multicast
   113|      * @throws SocketException
   114|      */
   115|     public static boolean isMulticastSupported(InetAddress pAddr) throws SocketException {
   116|         return isMulticastSupported(NetworkInterface.getByInetAddress(pAddr));
   117|     }
   118|     /**
   119|      * Get all local addresses on which a multicast can be send
   120|      *
   121|      * @return list of all multi cast capable addresses
   122|      */
   123|     public static List<InetAddress> getMulticastAddresses() throws SocketException {
   124|         Enumeration<NetworkInterface> nifs = NetworkInterface.getNetworkInterfaces();
   125|         List<InetAddress> ret = new ArrayList<InetAddress>();
   126|         while (nifs.hasMoreElements()) {
   127|             NetworkInterface nif = nifs.nextElement();
   128|             if (checkMethod(nif, supportsMulticast) && checkMethod(nif, isUp)) {
   129|                 Enumeration<InetAddress> addresses = nif.getInetAddresses();
   130|                 while (addresses.hasMoreElements()) {
   131|                     InetAddress addr = addresses.nextElement();
   132|                     if (!(addr instanceof Inet6Address)) {
   133|                         ret.add(addr);
   134|                     }
   135|                 }
   136|             }
   137|         }
   138|         return ret;
   139|     }
   140|     public static String getAgentId(int objectId, String type) {
   141|         String address;
   142|         try {
   143|             address = getLocalAddress().getHostAddress();
   144|         } catch (IOException exp) {
   145|             address = "local";
   146|         }
   147|         return address + "-" + getProcessId() + "-" + Integer.toHexString(objectId) + "-" + type;
   148|     }
   149|     /**
   150|      * Examine the given URL and replace the host with a non-loopback host if possible. It is checked,
   151|      * whether the port is open as well.
   152|      * <p/>
   153|      * A replaced host uses the  IP address instead of a (possibly non resolvable) name.
   154|      *
   155|      * @param pRequestURL url to examine and to update
   156|      * @return the 'sane' URL (or the original one if no san
   157|      */
   158|     public static String sanitizeLocalUrl(String pRequestURL) {
   159|         try {
   160|             URL url = new URL(pRequestURL);
   161|             String host = url.getHost();
   162|             InetAddress address = findLocalAddressListeningOnPort(host, url.getPort());
   163|             return new URL(url.getProtocol(), address.getHostAddress(), url.getPort(), url.getFile()).toExternalForm();
   164|         } catch (IOException e) {
   165|             return pRequestURL;
   166|         }
   167|     }
   168|     private static boolean useInetAddress(NetworkInterface networkInterface, InetAddress interfaceAddress) {
   169|         return checkMethod(networkInterface, isUp) &&
   170|                checkMethod(networkInterface, supportsMulticast) &&
   171|                !(interfaceAddress instanceof Inet6Address) &&
   172|                !interfaceAddress.isLoopbackAddress();
   173|     }
   174|     private static Boolean checkMethod(NetworkInterface iface, Method toCheck) {
   175|         if (toCheck != null) {
   176|             try {
   177|                 return (Boolean) toCheck.invoke(iface, (Object[]) null);
   178|             } catch (IllegalAccessException e) {
   179|                 return false;
   180|             } catch (InvocationTargetException e) {
   181|                 return false;
   182|             }
   183|         }
   184|         return true;
   185|     }
   186|     private static InetAddress findLocalAddressListeningOnPort(String pHost, int pPort) throws UnknownHostException, SocketException {
   187|         InetAddress address = InetAddress.getByName(pHost);
   188|         if (address.isLoopbackAddress()) {
   189|             InetAddress localAddress = getLocalAddress();
   190|             if (!localAddress.isLoopbackAddress() && isPortOpen(localAddress, pPort)) {
   191|                 return localAddress;
   192|             }
   193|             localAddress = getLocalAddressFromNetworkInterfacesListeningOnPort(pPort);
   194|             if (localAddress != null) {
   195|                 return localAddress;
   196|             }
   197|         }
   198|         return address;
   199|     }
   200|     private static InetAddress getLocalAddressFromNetworkInterfacesListeningOnPort(int pPort) {
   201|         try {
   202|             Enumeration<NetworkInterface> networkInterfaces;
   203|             networkInterfaces = NetworkInterface.getNetworkInterfaces();
   204|             while (networkInterfaces.hasMoreElements()) {
   205|                 NetworkInterface nif = networkInterfaces.nextElement();
   206|                 for (Enumeration<InetAddress> addrEnum = nif.getInetAddresses(); addrEnum.hasMoreElements(); ) {
   207|                     InetAddress interfaceAddress = addrEnum.nextElement();
   208|                     if (!interfaceAddress.isLoopbackAddress() && checkMethod(nif, isUp) && isPortOpen(interfaceAddress, pPort)) {
   209|                         return interfaceAddress;
   210|                     }
   211|                 }
   212|             }
   213|         } catch (SocketException e) {
   214|             return null;
   215|         }
   216|         return null;
   217|     }
   218|     private static boolean isPortOpen(InetAddress pAddress, int pPort) {
   219|         Socket socket = null;
   220|         try {
   221|             socket = new Socket();
   222|             socket.setReuseAddress(true);
   223|             SocketAddress sa = new InetSocketAddress(pAddress, pPort);
   224|             socket.connect(sa, 200);
   225|             return socket.isConnected();
   226|         } catch (IOException e) {
   227|             return false;
   228|         } finally {
   229|             if (socket != null) {
   230|                 try {
   231|                     socket.close();
   232|                 } catch (IOException e) {
   233|                 }
   234|             }
   235|         }
   236|     }
   237|     private static String getProcessId() {
   238|         final String jvmName = ManagementFactory.getRuntimeMXBean().getName();
   239|         final int index = jvmName.indexOf('@');
   240|         return index < 0 ? jvmName : jvmName.substring(0, index);
   241|     }
   242|     /**
   243|      * Get the local network info as a string
   244|      *
   245|      * @return return a description of the current network setup of the local host.
   246|      * @throws UnknownHostException
   247|      * @throws SocketException
   248|      */
   249|     public static String dumpLocalNetworkInfo() throws UnknownHostException, SocketException {
   250|         StringBuffer buffer = new StringBuffer();
   251|         InetAddress addr = InetAddress.getLocalHost();
   252|         buffer.append("Localhost: " + getAddrInfo(addr) + "\n");
   253|         Enumeration<NetworkInterface> nifs = NetworkInterface.getNetworkInterfaces();
   254|         buffer.append("Network interfaces:\n");
   255|         while (nifs.hasMoreElements()) {
   256|             NetworkInterface nif = nifs.nextElement();
   257|             buffer.append("  - " + getNetworkInterfaceInfo(nif) + "\n");
   258|             Enumeration<InetAddress> addresses = nif.getInetAddresses();
   259|             while (addresses.hasMoreElements()) {
   260|                 addr = addresses.nextElement();
   261|                 buffer.append("    " + getAddrInfo(addr) + "\n");
   262|             }
   263|         }
   264|         return buffer.toString();
   265|     }
   266|     private static final Pattern EXPRESSION_EXTRACTOR = Pattern.compile("\\$\\{?\\s*([\\w:-_.]+)\\s*}?");
   267|     /**
   268|      * Replace expression ${host} and ${ip} with the localhost name or IP in the given string.
   269|      * In addition the notation ${env:ENV_VAR} and ${prop:sysprop} can be used to refer to environment
   270|      * and system properties respectively.
   271|      *
   272|      * @param pValue value to examine
   273|      * @return the value with the variables replaced.
   274|      * @throws IllegalArgumentException when the expression is unknown or an error occurs when extracting the host name
   275|      */
   276|     public static String replaceExpression(String pValue) {
   277|         if (pValue == null) {
   278|             return null;
   279|         }
   280|         Matcher matcher = EXPRESSION_EXTRACTOR.matcher(pValue);
   281|         StringBuffer ret = new StringBuffer();
   282|         try {
   283|             while (matcher.find()) {
   284|                 String var = matcher.group(1);
   285|                 String value;
   286|                 if (var.equalsIgnoreCase("host")) {
   287|                     value = getLocalAddress().getHostName();
   288|                 } else if (var.equalsIgnoreCase("ip")) {
   289|                     value = getLocalAddress().getHostAddress();
   290|                 } else {
   291|                     String key = extractKey(var,"env");
   292|                     if (key != null)  {
   293|                         value = System.getenv(key).trim();
   294|                     } else {
   295|                         key = extractKey(var,"prop");
   296|                         if (key != null) {
   297|                             value = System.getProperty(key).trim();
   298|                         } else {
   299|                             throw new IllegalArgumentException("Unknown expression " + var + " in " + pValue);
   300|                         }
   301|                     }
   302|                 }
   303|                 matcher.appendReplacement(ret, value);
   304|             }
   305|             matcher.appendTail(ret);
   306|         } catch (IOException e) {
   307|             throw new IllegalArgumentException("Cannot lookup host" + e, e);
   308|         }
   309|         return ret.toString();
   310|     }
   311|     private static String extractKey(String pVar, String pPrefix) {
   312|         if (pVar.toLowerCase().startsWith(pPrefix + ":")) {
   313|             String ret = pVar.substring(pPrefix.length() + 1);
   314|             if (ret.length() == 0) {
   315|                 throw new IllegalArgumentException("Expression with " + pPrefix + ": must not contain spaces");
   316|             }
   317|             return ret;
   318|         }
   319|         return null;
   320|     }
   321|     private static String getAddrInfo(InetAddress pAddr) throws SocketException {
   322|         String ret = pAddr.getHostName() != null ? pAddr.getHostName() + " (" + pAddr.getHostAddress() + ")" : pAddr.getHostAddress();
   323|         ret += " [site-local: " + pAddr.isSiteLocalAddress() + ", link-local: " + pAddr.isLinkLocalAddress() + ", lb: " + pAddr.isLoopbackAddress() + "]";
   324|         NetworkInterface nif = NetworkInterface.getByInetAddress(pAddr);
   325|         ret += " -- nif: " + getNetworkInterfaceInfo(nif);
   326|         return ret;
   327|     }
   328|     private static String getNetworkInterfaceInfo(NetworkInterface pNif) throws SocketException {
   329|         if (pNif == null) {
   330|             return "[null]";
   331|         }
   332|         return pNif.getDisplayName() + " [up: " + pNif.isUp() + ", mc: " + pNif.supportsMulticast() +
   333|                ", lb: " + pNif.isLoopback() + ", hw: " + formatHwAddress(pNif.getHardwareAddress()) + "]";
   334|     }
   335|     private static String formatHwAddress(byte[] pHardwareAddress) {
   336|         if (pHardwareAddress == null) {
   337|             return "[none]";
   338|         }
   339|         StringBuilder sb = new StringBuilder(18);
   340|         for (byte b : pHardwareAddress) {


# ====================================================================
# FILE: agent/jvm/src/main/java/org/jolokia/jvmagent/JolokiaHttpHandler.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 117-201 ---
   117|         requestHandler = null;
   118|     }
   119|     /**
   120|      * Handler a request. If the handler is not yet started, an exception is thrown
   121|      *
   122|      * @param pExchange the request/response object
   123|      * @throws IOException if something fails during handling
   124|      * @throws IllegalStateException if the handler has not yet been started
   125|      */
   126|     @Override
   127|     @SuppressWarnings({"PMD.AvoidCatchingThrowable", "PMD.AvoidInstanceofChecksInCatchClause"})
   128|     public void handle(HttpExchange pExchange) throws IOException {
   129|         if (requestHandler == null) {
   130|             throw new IllegalStateException("Handler not yet started");
   131|         }
   132|         JSONAware json = null;
   133|         URI uri = pExchange.getRequestURI();
   134|         ParsedUri parsedUri = new ParsedUri(uri,context);
   135|         try {
   136|             InetSocketAddress address = pExchange.getRemoteAddress();
   137|             requestHandler.checkAccess(address.getHostName(), address.getAddress().getHostAddress(),
   138|                                        extractOriginOrReferer(pExchange));
   139|             String method = pExchange.getRequestMethod();
   140|             if ("GET".equalsIgnoreCase(method)) {
   141|                 setHeaders(pExchange);
   142|                 json = executeGetRequest(parsedUri);
   143|             } else if ("POST".equalsIgnoreCase(method)) {
   144|                 setHeaders(pExchange);
   145|                 json = executePostRequest(pExchange, parsedUri);
   146|             } else if ("OPTIONS".equalsIgnoreCase(method)) {
   147|                 performCorsPreflightCheck(pExchange);
   148|             } else {
   149|                 throw new IllegalArgumentException("HTTP Method " + method + " is not supported.");
   150|             }
   151|         } catch (Throwable exp) {
   152|             json = requestHandler.handleThrowable(
   153|                     exp instanceof RuntimeMBeanException ? ((RuntimeMBeanException) exp).getTargetException() : exp);
   154|         } finally {
   155|             sendResponse(pExchange,parsedUri,json);
   156|         }
   157|     }
   158|     private Restrictor createRestrictor(Configuration pConfig) {
   159|         String location = pConfig.get(ConfigKey.POLICY_LOCATION);
   160|         try {
   161|             Restrictor ret = RestrictorFactory.lookupPolicyRestrictor(location);
   162|             if (ret != null) {
   163|                 logHandler.info("Using access restrictor " + location);
   164|                 return ret;
   165|             } else {
   166|                 logHandler.info("No access restrictor found, access to all MBean is allowed");
   167|                 return new AllowAllRestrictor();
   168|             }
   169|         } catch (IOException e) {
   170|             logHandler.error("Error while accessing access restrictor at " + location +
   171|                              ". Denying all access to MBeans for security reasons. Exception: " + e, e);
   172|             return new DenyAllRestrictor();
   173|         }
   174|     }
   175|     private String extractOriginOrReferer(HttpExchange pExchange) {
   176|         Headers headers = pExchange.getRequestHeaders();
   177|         String origin = headers.getFirst("Origin");
   178|         if (origin == null) {
   179|             origin = headers.getFirst("Referer");
   180|         }
   181|         return origin != null ? origin.replaceAll("[\\n\\r]*","") : null;
   182|     }
   183|     private JSONAware executeGetRequest(ParsedUri parsedUri) {
   184|         return requestHandler.handleGetRequest(parsedUri.getUri().toString(),parsedUri.getPathInfo(), parsedUri.getParameterMap());
   185|     }
   186|     private JSONAware executePostRequest(HttpExchange pExchange, ParsedUri pUri) throws MalformedObjectNameException, IOException {
   187|         String encoding = null;
   188|         Headers headers = pExchange.getRequestHeaders();
   189|         String cType =  headers.getFirst("Content-Type");
   190|         if (cType != null) {
   191|             Matcher matcher = contentTypePattern.matcher(cType);
   192|             if (matcher.matches()) {
   193|                 encoding = matcher.group(1);
   194|             }
   195|         }
   196|         InputStream is = pExchange.getRequestBody();
   197|         return requestHandler.handlePostRequest(pUri.toString(),is, encoding, pUri.getParameterMap());
   198|     }
   199|     private void performCorsPreflightCheck(HttpExchange pExchange) {
   200|         Headers requestHeaders = pExchange.getRequestHeaders();
   201|         Map<String,String> respHeaders =

# --- HUNK 2: Lines 243-266 ---
   243|             }
   244|         }
   245|     }
   246|     private String getMimeType(ParsedUri pParsedUri) {
   247|         if (pParsedUri.getParameter(ConfigKey.CALLBACK.getKeyValue()) != null) {
   248|             return "text/javascript";
   249|         } else {
   250|             String mimeType = pParsedUri.getParameter(ConfigKey.MIME_TYPE.getKeyValue());
   251|             if (mimeType != null) {
   252|                 return mimeType;
   253|             }
   254|             mimeType = configuration.get(ConfigKey.MIME_TYPE);
   255|             return mimeType != null ? mimeType : ConfigKey.MIME_TYPE.getDefaultValue();
   256|         }
   257|     }
   258|     private LogHandler createLogHandler(String pLogHandlerClass, String pDebug) {
   259|         if (pLogHandlerClass != null) {
   260|             return ClassUtil.newInstance(pLogHandlerClass);
   261|         } else {
   262|             final boolean debug = Boolean.valueOf(pDebug);
   263|             return new LogHandler.StdoutLogHandler(debug);
   264|         }
   265|     }
   266| }


# ====================================================================
# FILE: agent/jvm/src/main/java/org/jolokia/jvmagent/JolokiaServer.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 58-98 ---
    58|      *
    59|      * @param pServer HttpServer to use
    60|      * @param pConfig configuration for this server
    61|      * @param pLazy lazy initialisation if true. This is required for agents
    62|      *              configured via startup options since at this early boot time
    63|      *              the JVM is not fully setup for the server detectors to work
    64|      */
    65|     public JolokiaServer(HttpServer pServer,JolokiaServerConfig pConfig, boolean pLazy) {
    66|         init(pServer,pConfig,pLazy);
    67|     }
    68|     /**
    69|      * No arg constructor usable by subclasses. The {@link #init(JolokiaServerConfig, boolean)} must be called later on
    70|      * for initialization
    71|      */
    72|     protected JolokiaServer() {}
    73|     /**
    74|      * Start this server. If we manage an own HttpServer, then the HttpServer will
    75|      * be started as well.
    76|      */
    77|     public void start() {
    78|         String configUrl = NetworkUtil.replaceExpression(config.getJolokiaConfig().get(ConfigKey.DISCOVERY_AGENT_URL));
    79|         jolokiaHttpHandler.start(lazy,configUrl != null ? configUrl : url, config.getAuthenticator() != null);
    80|         if (httpServer != null) {
    81|             ThreadGroup threadGroup = new ThreadGroup("jolokia");
    82|             threadGroup.setDaemon(false);
    83|             Thread starterThread = new Thread(threadGroup,new Runnable() {
    84|             @Override
    85|             public void run() {
    86|                 httpServer.start();
    87|             }
    88|         });
    89|             starterThread.start();
    90|             cleaner = new CleanupThread(httpServer,threadGroup);
    91|             cleaner.start();
    92|         }
    93|     }
    94|     /**
    95|      * Stop the HTTP server
    96|      */
    97|     public void stop() {
    98|         jolokiaHttpHandler.stop();


# ====================================================================
# FILE: agent/osgi/src/main/java/org/jolokia/osgi/DelegatingRestrictor.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 112-151 ---
   112|     public boolean isOperationAllowed(ObjectName pName, String pOperation) {
   113|         return checkRestrictorService(OPERATION_CHECK,pName,pOperation);
   114|     }
   115|     private static final RestrictorCheck REMOTE_CHECK = new RestrictorCheck() {
   116|         /** {@inheritDoc} */
   117|         public boolean check(Restrictor restrictor,Object ... args) {
   118|             String[] argsS = new String[args.length];
   119|             for (int i = 0; i < args.length; i++) {
   120|                 argsS[i] = (String) args[i];
   121|             }
   122|             return restrictor.isRemoteAccessAllowed(argsS);
   123|         }
   124|     };
   125|     /** {@inheritDoc} */
   126|     public boolean isRemoteAccessAllowed(String... pHostOrAddress) {
   127|         return checkRestrictorService(REMOTE_CHECK,pHostOrAddress);
   128|     }
   129|     private static final RestrictorCheck CORS_CHECK = new RestrictorCheck() {
   130|         /** {@inheritDoc} */
   131|         public boolean check(Restrictor restrictor, Object... args) {
   132|             return restrictor.isOriginAllowed((String) args[0], (Boolean) args[1]);
   133|         }
   134|     };
   135|     /** {@inheritDoc} */
   136|     public boolean isOriginAllowed(String pOrigin, boolean pIsStrictCheck) {
   137|         return checkRestrictorService(CORS_CHECK,pOrigin,pIsStrictCheck);
   138|     }
   139|     /**
   140|      * Internal interface for restrictor delegation
   141|      */
   142|     private interface RestrictorCheck {
   143|         /**
   144|          * Run check specifically for the restrictor to delegate to
   145|          * @param restrictor the restrictor on which the check should be run
   146|          * @param args context dependent arguments
   147|          * @return result of the check
   148|          */
   149|         boolean check(Restrictor restrictor,Object ... args);
   150|     }
   151| }


# ====================================================================
# FILE: client/java/src/main/java/org/jolokia/client/J4pClient.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-95 ---
     1| package org.jolokia.client;
     2| /*
     3|  * Copyright 2009-2013 Roland Huss
     4|  *
     5|  * Licensed under the Apache License, Version 2.0 (the "License");
     6|  * you may not use this file except in compliance with the License.
     7|  * You may obtain a copy of the License at
     8|  *
     9|  *       http://www.apache.org/licenses/LICENSE-2.0
    10|  *
    11|  * Unless required by applicable law or agreed to in writing, software
    12|  * distributed under the License is distributed on an "AS IS" BASIS,
    13|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    14|  * See the License for the specific language governing permissions and
    15|  * limitations under the License.
    16|  */
    17| import org.apache.http.HttpResponse;
    18| import org.apache.http.HttpStatus;
    19| import org.apache.http.StatusLine;
    20| import org.apache.http.client.HttpClient;
    21| import org.apache.http.conn.ConnectTimeoutException;
    22| import org.jolokia.client.exception.*;
    23| import org.jolokia.client.request.*;
    24| import org.json.simple.JSONArray;
    25| import org.json.simple.JSONAware;
    26| import org.json.simple.JSONObject;
    27| import org.json.simple.parser.ParseException;
    28| import java.io.IOException;
    29| import java.net.ConnectException;
    30| import java.net.URISyntaxException;
    31| import java.util.ArrayList;
    32| import java.util.Arrays;
    33| import java.util.List;
    34| import java.util.Map;
    35| /**
    36|  * Client class for accessing the j4p agent
    37|  *
    38|  * @author roland
    39|  * @since Apr 24, 2010
    40|  */
    41| public class J4pClient extends J4pClientBuilderFactory {
    42|     private HttpClient httpClient;
    43|     private J4pRequestHandler requestHandler;
    44|     /**
    45|      * Construct a new client for a given server url
    46|      *
    47|      * @param pJ4pServerUrl the agent URL for how to contact the server.
    48|      */
    49|     public J4pClient(String pJ4pServerUrl) {
    50|         this(pJ4pServerUrl,null);
    51|     }
    52|     /**
    53|      * Constructor for a given agent URl and a given HttpClient
    54|      *
    55|      * @param pJ4pServerUrl the agent URL for how to contact the server.
    56|      * @param pHttpClient HTTP client to use for the connecting to the agent
    57|      */
    58|     public J4pClient(String pJ4pServerUrl, HttpClient pHttpClient) {
    59|         this(pJ4pServerUrl,pHttpClient,null);
    60|     }
    61|     /**
    62|      * Constructor using a given Agent URL, HttpClient and a proxy target config. If the HttpClient is null,
    63|      * a default client is used. If no target config is given, a plain request is performed
    64|      *
    65|      * @param pJ4pServerUrl the agent URL for how to contact the server.
    66|      * @param pHttpClient HTTP client to use for the connecting to the agent
    67|      * @param pTargetConfig optional target
    68|      */
    69|     public J4pClient(String pJ4pServerUrl, HttpClient pHttpClient,J4pTargetConfig pTargetConfig) {
    70|         requestHandler = new J4pRequestHandler(pJ4pServerUrl,pTargetConfig);
    71|         if (pHttpClient != null) {
    72|             httpClient = pHttpClient;
    73|         } else {
    74|             J4pClientBuilder builder = new J4pClientBuilder();
    75|             httpClient = builder.createHttpClient();
    76|         }
    77|     }
    78|     /**
    79|      * Execute a single J4pRequest returning a single response.
    80|      * The HTTP Method used is determined automatically.
    81|      *
    82|      * @param pRequest request to execute
    83|      * @param <R> response type
    84|      * @param <T> request type
    85|      * @return the response as returned by the server
    86|      */
    87|     public <R extends J4pResponse<T>,T extends J4pRequest> R execute(T pRequest)
    88|             throws J4pException {
    89|         return this.<R,T>execute(pRequest,null,null);
    90|     }
    91|     /**
    92|      * Execute a single J4pRequest returning a single response.
    93|      * The HTTP Method used is determined automatically.
    94|      *
    95|      * @param pRequest request to execute


# ====================================================================
# FILE: client/java/src/main/java/org/jolokia/client/J4pClientBuilder.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-94 ---
     1| package org.jolokia.client;
     2| /*
     3|  * Copyright 2009-2013 Roland Huss
     4|  *
     5|  * Licensed under the Apache License, Version 2.0 (the "License");
     6|  * you may not use this file except in compliance with the License.
     7|  * You may obtain a copy of the License at
     8|  *
     9|  *       http://www.apache.org/licenses/LICENSE-2.0
    10|  *
    11|  * Unless required by applicable law or agreed to in writing, software
    12|  * distributed under the License is distributed on an "AS IS" BASIS,
    13|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    14|  * See the License for the specific language governing permissions and
    15|  * limitations under the License.
    16|  */
    17| import java.nio.charset.Charset;
    18| import javax.net.ssl.SSLContext;
    19| import org.apache.http.auth.AuthScope;
    20| import org.apache.http.auth.UsernamePasswordCredentials;
    21| import org.apache.http.client.CredentialsProvider;
    22| import org.apache.http.client.HttpClient;
    23| import org.apache.http.client.config.RequestConfig;
    24| import org.apache.http.config.*;
    25| import org.apache.http.conn.*;
    26| import org.apache.http.conn.routing.HttpRoute;
    27| import org.apache.http.conn.socket.ConnectionSocketFactory;
    28| import org.apache.http.conn.socket.PlainConnectionSocketFactory;
    29| import org.apache.http.conn.ssl.*;
    30| import org.apache.http.impl.client.*;
    31| import org.apache.http.impl.conn.*;
    32| import org.apache.http.impl.io.DefaultHttpRequestWriterFactory;
    33| import org.apache.http.impl.io.DefaultHttpResponseParserFactory;
    34| import org.apache.http.protocol.HTTP;
    35| import org.apache.http.util.VersionInfo;
    36| import org.jolokia.client.request.J4pTargetConfig;
    37| /**
    38|  * A builder for a {@link org.jolokia.client.J4pClient}.
    39|  *
    40|  * @author roland
    41|  * @since 26.11.10
    42|  */
    43| public class J4pClientBuilder {
    44|     private int connectionTimeout;
    45|     private int socketTimeout;
    46|     private int maxTotalConnections;
    47|     private int maxConnectionPoolTimeout;
    48|     private Charset contentCharset;
    49|     private boolean expectContinue;
    50|     private boolean tcpNoDelay;
    51|     private int socketBufferSize;
    52|     private boolean pooledConnections;
    53|     private String url;
    54|     private String user;
    55|     private String password;
    56|     private String targetUrl;
    57|     private String targetUser;
    58|     private String targetPassword;
    59|     /**
    60|      * Package access constructor, use static method on J4pClient for creating
    61|      * the builder.
    62|      */
    63|     public J4pClientBuilder() {
    64|         connectionTimeout(20 * 1000);
    65|         socketTimeout(-1);
    66|         maxTotalConnections(20);
    67|         maxConnectionPoolTimeout(500);
    68|         contentCharset(HTTP.DEF_CONTENT_CHARSET.name());
    69|         expectContinue(true);
    70|         tcpNoDelay(true);
    71|         socketBufferSize(8192);
    72|         pooledConnections();
    73|         user = null;
    74|         password = null;
    75|     }
    76|     /**
    77|      * The Agent URL to connect to
    78|      *
    79|      * @param pUrl agent URL
    80|      */
    81|     public final J4pClientBuilder url(String pUrl) {
    82|         url = pUrl;
    83|         return this;
    84|     }
    85|     /**
    86|      * User to use for authentication
    87|      *
    88|      * @param pUser user name
    89|      */
    90|     public final J4pClientBuilder user(String pUser) {
    91|         user  = pUser;
    92|         return this;
    93|     }
    94|     /**

# --- HUNK 2: Lines 112-325 ---
   112|     /**
   113|      * Target user for proxy mode. This parameter takes only effect when a target is set.
   114|      *
   115|      * @param pUser User to be used for authentication in JSR-160 proxy communication
   116|      */
   117|     public final J4pClientBuilder targetUser(String pUser) {
   118|         targetUser = pUser;
   119|         return this;
   120|     }
   121|     /**
   122|      * Target password for proxy mode. This parameter takes only effect when a target is set and the target user is
   123|      * not null
   124|      *
   125|      * @param pPassword Password to be used for authentication in JSR-160 proxy communication
   126|      */
   127|     public final J4pClientBuilder targetPassword(String pPassword) {
   128|         targetPassword = pPassword;
   129|         return this;
   130|     }
   131|     /**
   132|      * Use a single threaded client for connecting to the agent. This
   133|      * is not very suitable in multithreaded environments
   134|      */
   135|     public final J4pClientBuilder singleConnection() {
   136|         pooledConnections = false;
   137|         return this;
   138|     }
   139|     /**
   140|      * Use a pooled connection manager for connecting to the agent, which
   141|      * uses a pool of connections (see {@link #maxTotalConnections(int) and {@link #maxConnectionPoolTimeout(int)} for
   142|      * tuning the pool}
   143|      */
   144|     public final J4pClientBuilder pooledConnections() {
   145|         pooledConnections = true;
   146|         return this;
   147|     }
   148|     /**
   149|      * Determines the timeout in milliseconds until a connection is established. A timeout value of zero is
   150|      * interpreted as an infinite timeout. Default is 20 seconds.
   151|      *
   152|      * @param pTimeOut timeout in milliseconds
   153|      */
   154|     public final J4pClientBuilder connectionTimeout(int pTimeOut) {
   155|         connectionTimeout = pTimeOut;
   156|         return this;
   157|     }
   158|     /**
   159|      * Defines the socket timeout (<code>SO_TIMEOUT</code>) in milliseconds,
   160|      * which is the timeout for waiting for data  or, put differently,
   161|      * a maximum period inactivity between two consecutive data packets).
   162|      * A timeout value of zero is interpreted as an infinite timeout, a negative value means the system default.
   163|      *
   164|      * @param pTimeOut SO_TIMEOUT value in milliseconds, 0 mean no timeout at all.
   165|      */
   166|     public final J4pClientBuilder socketTimeout(int pTimeOut) {
   167|         socketTimeout = pTimeOut;
   168|         return this;
   169|     }
   170|     /**
   171|      * Sets the maximum number of connections allowed when using {@link #pooledConnections()}.
   172|      * @param pConnections number of max. simultaneous connections.
   173|      */
   174|     public final J4pClientBuilder maxTotalConnections(int pConnections) {
   175|         maxTotalConnections = pConnections;
   176|         return this;
   177|     }
   178|     /**
   179|      * Sets the timeout in milliseconds used when retrieving a connection
   180|      * from the connection manager. Default is 500ms, if set to -1 the system default is used. Use
   181|      * 0 for an infinite timeout.
   182|      *
   183|      * @param pConnectionPoolTimeout timeout in milliseconds
   184|      */
   185|     public final J4pClientBuilder maxConnectionPoolTimeout(int pConnectionPoolTimeout) {
   186|         maxConnectionPoolTimeout = pConnectionPoolTimeout;
   187|         return this;
   188|     }
   189|     /**
   190|      * Defines the charset to be used per default for encoding content body.
   191|      * @param pContentCharset the charset to use
   192|      */
   193|     public final J4pClientBuilder contentCharset(String pContentCharset) {
   194|         return contentCharset(Charset.forName(pContentCharset));
   195|     }
   196|     /**
   197|      * Defines the charset to be used per default for encoding content body.
   198|      * @param pContentCharset the charset to use
   199|      */
   200|     public final J4pClientBuilder contentCharset(Charset pContentCharset) {
   201|         contentCharset = pContentCharset;
   202|         return this;
   203|     }
   204|     /**
   205|      * Activates 'Expect: 100-Continue' handshake for the entity enclosing methods.
   206|      * The purpose of the 'Expect: 100-Continue' handshake to allow a client that is
   207|      * sending a request message with a request body to determine if the origin server
   208|      * is willing to accept the request (based on the request headers) before the client
   209|      * sends the request body.
   210|      * The use of the 'Expect: 100-continue' handshake can result in noticable peformance
   211|      * improvement for entity enclosing requests that require the target server's authentication.
   212|      *
   213|      * @param pUse whether to use this algorithm or not
   214|      */
   215|     public final J4pClientBuilder expectContinue(boolean pUse) {
   216|         expectContinue = pUse;
   217|         return this;
   218|     }
   219|     /**
   220|      * Determines whether Nagle's algorithm is to be used. The Nagle's algorithm tries to conserve
   221|      * bandwidth by minimizing the number of segments that are sent. When applications wish to
   222|      * decrease network latency and increase performance, they can disable Nagle's
   223|      * algorithm (that is enable TCP_NODELAY). Data will be sent earlier, at the cost
   224|      * of an increase in bandwidth consumption.
   225|      * @param pUse whether to use NO_DELAY or not
   226|      */
   227|     public final J4pClientBuilder tcpNoDelay(boolean pUse) {
   228|         tcpNoDelay = pUse;
   229|         return this;
   230|     }
   231|     /**
   232|      * Determines the size of the internal socket buffer used to buffer data while receiving /
   233|      * transmitting HTTP messages.
   234|      * @param pSize size of socket buffer
   235|      */
   236|     public final J4pClientBuilder socketBufferSize(int pSize) {
   237|         socketBufferSize = pSize;
   238|         return this;
   239|     }
   240|     /**
   241|      * Build the agent with the information given before
   242|      *
   243|      * @return a new J4pClient
   244|      */
   245|     public J4pClient build() {
   246|         return new J4pClient(url,createHttpClient(),targetUrl != null ? new J4pTargetConfig(targetUrl,targetUser,targetPassword) : null);
   247|     }
   248|     public HttpClient createHttpClient() {
   249|         HttpClientConnectionManager connManager =
   250|                 pooledConnections ? createPoolingConnectionManager() : createBasicConnectionManager();
   251|         HttpClientBuilder builder = HttpClients.custom()
   252|                 .setConnectionManager(connManager)
   253|                 .setUserAgent("Jolokia JMX-Client (using Apache-HttpClient/" + getVersionInfo() + ")")
   254|                 .setDefaultRequestConfig(createRequestConfig());
   255|         if (user != null) {
   256|             CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
   257|             credentialsProvider.setCredentials(
   258|                     new AuthScope(AuthScope.ANY),
   259|                     new UsernamePasswordCredentials(user, password));
   260|             builder.setDefaultCredentialsProvider(credentialsProvider);
   261|         }
   262|         return builder.build();
   263|     }
   264|     private String getVersionInfo() {
   265|         final VersionInfo vi = VersionInfo.loadVersionInfo("org.apache.http.client", getClass().getClassLoader());
   266|         return (vi != null) ? vi.getRelease() : VersionInfo.UNAVAILABLE;
   267|     }
   268|     private RequestConfig createRequestConfig() {
   269|         RequestConfig.Builder requestConfigB = RequestConfig.custom();
   270|         requestConfigB.setExpectContinueEnabled(expectContinue);
   271|         if (socketTimeout > -1) {
   272|             requestConfigB.setSocketTimeout(socketTimeout);
   273|         }
   274|         if (connectionTimeout > -1) {
   275|             requestConfigB.setConnectTimeout(connectionTimeout);
   276|         }
   277|         if (maxConnectionPoolTimeout > -1) {
   278|             requestConfigB.setConnectionRequestTimeout(maxConnectionPoolTimeout);
   279|         }
   280|         return requestConfigB.build();
   281|     }
   282|     private BasicHttpClientConnectionManager createBasicConnectionManager() {
   283|         BasicHttpClientConnectionManager connManager =
   284|                 new BasicHttpClientConnectionManager(getSocketFactoryRegistry(),getConnectionFactory());
   285|         connManager.setSocketConfig(createSocketConfig());
   286|         connManager.setConnectionConfig(createConnectionConfig());
   287|         return connManager;
   288|     }
   289|     private PoolingHttpClientConnectionManager createPoolingConnectionManager() {
   290|         PoolingHttpClientConnectionManager connManager =
   291|             new PoolingHttpClientConnectionManager(getSocketFactoryRegistry(), getConnectionFactory());
   292|         connManager.setDefaultSocketConfig(createSocketConfig());
   293|         connManager.setDefaultConnectionConfig(createConnectionConfig());
   294|         if (maxTotalConnections != 0) {
   295|             connManager.setMaxTotal(maxTotalConnections);
   296|         }
   297|         return connManager;
   298|     }
   299|     private ConnectionConfig createConnectionConfig() {
   300|         return ConnectionConfig.custom()
   301|                 .setBufferSize(socketBufferSize)
   302|                 .setCharset(contentCharset)
   303|                 .build();
   304|     }
   305|     private SocketConfig createSocketConfig() {
   306|         SocketConfig.Builder socketConfigB = SocketConfig.custom();
   307|         if (socketTimeout >= 0) {
   308|             socketConfigB.setSoTimeout(socketTimeout);
   309|         }
   310|         socketConfigB.setTcpNoDelay(tcpNoDelay);
   311|         return socketConfigB.build();
   312|     }
   313|     private Registry<ConnectionSocketFactory> getSocketFactoryRegistry() {
   314|         SSLContext sslcontext = SSLContexts.createSystemDefault();
   315|         X509HostnameVerifier hostnameVerifier = new BrowserCompatHostnameVerifier();
   316|         return RegistryBuilder.<ConnectionSocketFactory>create()
   317|                               .register("http", PlainConnectionSocketFactory.INSTANCE)
   318|                               .register("https", new SSLConnectionSocketFactory(sslcontext, hostnameVerifier))
   319|                               .build();
   320|     }
   321|     private HttpConnectionFactory<HttpRoute, ManagedHttpClientConnection> getConnectionFactory() {
   322|         return new ManagedHttpClientConnectionFactory(new DefaultHttpRequestWriterFactory(),
   323|                                                       new DefaultHttpResponseParserFactory());
   324|     }
   325| }


# ====================================================================
# FILE: client/javascript/src/main/javascript/jolokia-cubism.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 3-43 ---
     3|  *
     4|  * Licensed under the Apache License, Version 2.0 (the "License");
     5|  * you may not use this file except in compliance with the License.
     6|  * You may obtain a copy of the License at
     7|  *
     8|  * http://www.apache.org/licenses/LICENSE-2.0
     9|  *
    10|  * Unless required by applicable law or agreed to in writing, software
    11|  * distributed under the License is distributed on an "AS IS" BASIS,
    12|  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    13|  * See the License for the specific language governing permissions and
    14|  * limitations under the License.
    15|  */
    16| /**
    17|  * Jolokia integration into cubism (http://square.github.com/cubism/)
    18|  *
    19|  * This integration requires the following
    20|  */
    21| (function () {
    22|     var builder = function (cubism,Jolokia) {
    23|         var VERSION = "1.2.1";
    24|         var ctx_jolokia = function (url, opts) {
    25|             var source = {},
    26|                 context = this,
    27|                 j4p = createAgent(url, opts),
    28|                 step = 5e3;                    // 5 seconds by default
    29|             try
    30|             {
    31|                 context.on("start",function() {
    32|                     j4p.start();
    33|                 });
    34|                 context.on("stop",function() {
    35|                     j4p.stop();
    36|                 });
    37|             }
    38|             catch(err)
    39|             {
    40|             }
    41|             /**
    42|              * Factory method for create a metric objects which has various variants.
    43|              *


# ====================================================================
# FILE: client/javascript/src/main/javascript/jolokia.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 34-74 ---
    34|             type:"POST",
    35|             processData:false,
    36|             dataType:"json",
    37|             contentType:"text/json"
    38|         };
    39|         var PROCESSING_PARAMS = ["maxDepth", "maxCollectionSize", "maxObjects", "ignoreErrors", "canonicalNaming",
    40|                                  "serializeException", "includeStackTrace", "ifModifiedSince"];
    41|         /**
    42|          * Constructor for creating a client to the Jolokia agent.
    43|          *
    44|          * An object containing the default parameters can be provided as argument. For the possible parameters
    45|          * see {@link #request()}.
    46|          *
    47|          * @param param either a string in which case it is used as the URL to the agent or
    48|          *              an object with the default parameters as key-value pairs
    49|          */
    50|         function Jolokia(param) {
    51|             if (!(this instanceof arguments.callee)) {
    52|                 return new Jolokia(param);
    53|             }
    54|             this.CLIENT_VERSION = "1.2.1";
    55|             var jobs = [];
    56|             var agentOptions = {};
    57|             var pollerIsRunning = false;
    58|             if (typeof param === "string") {
    59|                 param = {url:param};
    60|             }
    61|             $.extend(agentOptions, DEFAULT_CLIENT_PARAMS, param);
    62|             /**
    63|              * The request method using one or more JSON requests and sending it to the agent. Beside the
    64|              * request a bunch of options can be given, which are merged with the options provided
    65|              * at the constructor (where the options given here take precedence).
    66|              *
    67|              * Known options are:
    68|              *
    69|              * <dl>
    70|              *   <dt>url</dt>
    71|              *   <dd>Agent URL, which is mandatory</dd>
    72|              *   <dt>method</dt>
    73|              *   <dd>
    74|              *     Either "post" or "get" depending on the desired HTTP method (case does not matter).

