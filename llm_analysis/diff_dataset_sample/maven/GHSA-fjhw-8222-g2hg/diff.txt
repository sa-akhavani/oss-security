--- a/agent/core/src/main/java/org/jolokia/Version.java
+++ b/agent/core/src/main/java/org/jolokia/Version.java
@@ -14,20 +14,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 /**
  * Class holding the version of this agent and the protocol.
  *
  * @author roland
  * @since Jun 11, 2009
  */
 public final class Version {
-    private static final String VERSION = "1.2.1";
+    private static final String VERSION = "1.2.0";
     private static final String PROTOCOL = "7.1";
     private Version() {}
     public static String getAgentVersion() {
         return VERSION;
     }
     public static String getProtocolVersion() {
         return PROTOCOL;
     }
 }

--- a/agent/core/src/main/java/org/jolokia/backend/BackendManager.java
+++ b/agent/core/src/main/java/org/jolokia/backend/BackendManager.java
@@ -161,25 +161,24 @@
      * @param pRemoteAddr alternative IP address
      * @return true if remote access is allowed
      */
     public boolean isRemoteAccessAllowed(String pRemoteHost, String pRemoteAddr) {
         return restrictor.isRemoteAccessAllowed(pRemoteHost, pRemoteAddr);
     }
     /**
      * Check whether CORS access is allowed for the given origin.
      *
      * @param pOrigin origin URL which needs to be checked
-     * @param pStrictChecking whether to a strict check (i.e. server side check)
-     * @return true if if cors access is allowed
-     */
-    public boolean isOriginAllowed(String pOrigin,boolean pStrictChecking) {
-        return restrictor.isOriginAllowed(pOrigin, pStrictChecking);
+     * @return true if icors access is allowed
+     */
+    public boolean isCorsAccessAllowed(String pOrigin) {
+        return restrictor.isCorsAccessAllowed(pOrigin);
     }
     /**
      * Log at info level
      *
      * @param msg to log
      */
     public void info(String msg) {
         logHandler.info(msg);
         if (debugStore != null) {
             debugStore.log(msg);

--- a/agent/core/src/main/java/org/jolokia/config/ConfigKey.java
+++ b/agent/core/src/main/java/org/jolokia/config/ConfigKey.java
@@ -115,27 +115,20 @@
      */
     IF_MODIFIED_SINCE("ifModifiedSince",false,true),
     /**
      * Whether to enable listening and responding to discovery multicast requests
      * for discovering agent details.
      */
     DISCOVERY_ENABLED("discoveryEnabled",true,false),
     /**
      * Specify the agent URL to return for an discovery multicast request. If this option
      * is given {@link #DISCOVERY_ENABLED} is set to <code>true</code> automatically.
-     * The URL given can contain placeholders:
-     * <ul>
-     *    <li>$host or ${host} : Host name (if possible), otherwise address</li>
-     *    <li>$ip or ${ip} : IP Address</li>
-     *    <li>${prop:foo} : System property foo</li>
-     *    <li>${env:FOO} : Environment variable FOO</li>
-     * </ul>
      */
     DISCOVERY_AGENT_URL("discoveryAgentUrl",true,false),
     /**
      *  User for authentication purposes. Used by OSGi and JDK agent.
      */
     USER("user", true, false),
     /**
      *  Password for authentication purposes. Used by OSGi and JDK agent
      */
     PASSWORD("password", true, false),

--- a/agent/core/src/main/java/org/jolokia/detector/ActiveMQDetector.java
+++ b//dev/null
@@ -1,18 +0,0 @@
-package org.jolokia.detector;
-import org.jolokia.backend.executor.MBeanServerExecutor;
-/**
- * Detector for ActiveMQ
- *
- * @author roland
- * @since 27.03.14
- */
-public class ActiveMQDetector extends AbstractServerDetector {
-    /** {@inheritDoc} */
-    public ServerHandle detect(MBeanServerExecutor pMBeanServerExecutor) {
-        String version = getSingleStringAttribute(pMBeanServerExecutor, "org.apache.activemq:type=Broker,*", "BrokerVersion");
-        if (version == null) {
-            return null;
-        }
-        return new ServerHandle("Apache","activemq",version, null);
-    }
-}

--- a/agent/core/src/main/java/org/jolokia/detector/ServerDetector.java
+++ b/agent/core/src/main/java/org/jolokia/detector/ServerDetector.java
@@ -23,20 +23,23 @@
  * successfully detect 'its' server, it return a {@link ServerHandle} containing type, version
  * and some optional information
  * @author roland
  * @since 05.11.10
  */
 public interface ServerDetector {
     /**
      * Detect the server. A {@link ServerHandle} descriptor is returned
      * in case of a successful detection, <code>null</code> otherwise.
      *
+     *
+     *
+     *
      * @param pMBeanServerExecutor a set of MBeanServers which can be used for detecting server informations
      * @return the server descriptor or <code>null</code> it this implementation cant detect 'its' server.
      */
     ServerHandle detect(MBeanServerExecutor pMBeanServerExecutor);
     /**
      * Add server specific MBeanServers
      *
      * @param pMBeanServers set to add detected MBeanServers to
      */
     void addMBeanServers(Set<MBeanServerConnection> pMBeanServers);

--- a/agent/core/src/main/java/org/jolokia/detector/WeblogicDetector.java
+++ b/agent/core/src/main/java/org/jolokia/detector/WeblogicDetector.java
@@ -36,30 +36,21 @@
             return new ServerHandle("Oracle","weblogic",version, null);
         }
         return null;
     }
     /**
      * Adde Weblogic specific runtime MBeanServer
      * @param servers set to add own MBean servers
      */
     @Override
     public void addMBeanServers(Set<MBeanServerConnection> servers) {
-        if (!isJBoss()) {
-            InitialContext ctx;
-            try {
-                ctx = new InitialContext();
-                MBeanServer server = (MBeanServer) ctx.lookup("java:comp/env/jmx/runtime");
-                if (server != null) {
-                    servers.add(server);
-                }
-            } catch (NamingException e) {
+        InitialContext ctx;
+        try {
+            ctx = new InitialContext();
+            MBeanServer server = (MBeanServer) ctx.lookup("java:comp/env/jmx/runtime");
+            if (server != null) {
+                servers.add(server);
             }
-        }
-    }
-    private boolean isJBoss() {
-        try {
-            return Class.forName("org.jboss.mx.util.MBeanServerLocator") != null;
-        } catch (ClassNotFoundException e) {
-            return false;
+        } catch (NamingException e) {
         }
     }
 }

--- a/agent/core/src/main/java/org/jolokia/discovery/DiscoveryMulticastResponder.java
+++ b/agent/core/src/main/java/org/jolokia/discovery/DiscoveryMulticastResponder.java
@@ -54,30 +54,26 @@
      * Start the responder (if not already started)
      */
     public synchronized void start() throws IOException {
         if (listenerThreads.size() == 0) {
             List<InetAddress> addresses = hostAddress == null ? NetworkUtil.getMulticastAddresses() : Arrays.asList(hostAddress);
             if (addresses.size() == 0) {
                 logHandler.info("No suitable address found for listening on multicast discovery requests");
                 return;
             }
             for (InetAddress addr : addresses) {
-                try {
-                    MulticastSocketListenerThread thread = new MulticastSocketListenerThread(addr,
-                                                                                             detailsHolder,
-                                                                                             restrictor,
-                                                                                             logHandler);
-                    thread.start();
-                    listenerThreads.add(thread);
-                } catch (IOException exp) {
-                    logHandler.info("Couldn't start discovery thread for " + addr + ": " + exp);
-                }
+                MulticastSocketListenerThread thread = new MulticastSocketListenerThread(addr,
+                                                                                         detailsHolder,
+                                                                                         restrictor,
+                                                                                         logHandler);
+                thread.start();
+                listenerThreads.add(thread);
             }
         }
     }
     /**
      * Stop the responder (if not already stopped). Can be restarted aftewards.
      */
     public synchronized void stop() {
         if (listenerThreads.size() > 0) {
             for (MulticastSocketListenerThread thread : listenerThreads) {
                 thread.shutdown();

--- a/agent/core/src/main/java/org/jolokia/discovery/MulticastSocketListenerThread.java
+++ b/agent/core/src/main/java/org/jolokia/discovery/MulticastSocketListenerThread.java
@@ -26,22 +26,22 @@
      * @param pRestrictor restrictor to check whether an incoming package should be answered which
      *                    is done only when {@link Restrictor#isRemoteAccessAllowed(String...)} returns true for
      *                    the address from which the packet was received.
      * @param pLogHandler log handler used for logging
      */
     MulticastSocketListenerThread(InetAddress pHostAddress, AgentDetailsHolder pAgentDetailsHolder, Restrictor pRestrictor, LogHandler pLogHandler) throws IOException {
         address = pHostAddress != null ? pHostAddress : NetworkUtil.getLocalAddressWithMulticast();
         agentDetailsHolder = pAgentDetailsHolder;
         restrictor = pRestrictor;
         logHandler = pLogHandler;
-        socket = MulticastUtil.newMulticastSocket(address,logHandler);
         logHandler.debug(address + "<-- Listening for queries");
+        socket = MulticastUtil.newMulticastSocket(address);
     }
     /** {@inheritDoc} */
     public void run() {
         setRunning(true);
         try {
             while (isRunning()) {
                 refreshSocket();
                 logHandler.debug(address + "<-- Waiting");
                 DiscoveryIncomingMessage msg = receiveMessage();
                 if (shouldMessageBeProcessed(msg)) {
@@ -86,23 +86,22 @@
                 logHandler.info("Error while handling discovery request" + (packet.getAddress() != null ? " from " + packet.getAddress() : "") +
                                 ". Ignoring this request. --> " + e);
             }
             return null;
         }
     }
     private void refreshSocket() {
         if (socket.isClosed()) {
             logHandler.info(address + "<-- Socket closed, reopening it");
             try {
-                socket = MulticastUtil.newMulticastSocket(address, logHandler);
+                socket = MulticastUtil.newMulticastSocket(address);
             } catch (IOException exp) {
-                logHandler.error("Cannot reopen socket. Exiting multicast listener thread ...",exp);
                 throw new SocketVerificationFailedException(exp);
             }
         }
     }
     private void handleQuery(DiscoveryIncomingMessage pMsg) {
         DiscoveryOutgoingMessage answer =
                 new DiscoveryOutgoingMessage.Builder(RESPONSE)
                         .respondTo(pMsg)
                         .agentDetails(agentDetailsHolder.getAgentDetails())
                         .build();

--- a/agent/core/src/main/java/org/jolokia/discovery/MulticastUtil.java
+++ b/agent/core/src/main/java/org/jolokia/discovery/MulticastUtil.java
@@ -9,30 +9,28 @@
  * Utility class for handling multicast stuff
  *
  * @author roland
  * @since 28.01.14
  */
 public final class MulticastUtil {
     public static final String JOLOKIA_MULTICAST_GROUP = "239.192.48.84";
     public static final int JOLOKIA_MULTICAST_PORT = 24884;
     private MulticastUtil() {
     }
-    static MulticastSocket newMulticastSocket(InetAddress pAddress, LogHandler pLogHandler) throws IOException {
+    static MulticastSocket newMulticastSocket(InetAddress pAddress) throws IOException {
         InetSocketAddress socketAddress =
                 new InetSocketAddress(JOLOKIA_MULTICAST_GROUP, JOLOKIA_MULTICAST_PORT);
         MulticastSocket socket = new MulticastSocket(JOLOKIA_MULTICAST_PORT);
         socket.setReuseAddress(true);
         setOutgoingInterfaceForMulticastRequest(pAddress, socket);
         socket.setTimeToLive(255);
-        if (joinMcGroupsOnAllNetworkInterfaces(socket, socketAddress, pLogHandler) == 0) {
-            throw new IOException("Couldn't join multicast group " + socketAddress + " on any network interfaces");
-        }
+        joinMcGroupsOnAllNetworkInterfaces(socket, socketAddress);
         return socket;
     }
     /**
      * Sent out a message to Jolokia's multicast group over all network interfaces supporting multicast request (and no
      * logging is used)
      *
      * @param pOutMsg  the message to send
      * @param pTimeout timeout used for how long to wait for discovery messages
      * @return list of received answers, never null
      * @throws IOException if something fails during the discovery request
@@ -91,35 +89,28 @@
                     }
                 }
             } catch (InterruptedException exp) {
             } catch (ExecutionException e) {
                 pLogHandler.debug("--> Exception during lookup: " + e);
             } catch (TimeoutException e) {
             }
         }
         return ret;
     }
-    private static int joinMcGroupsOnAllNetworkInterfaces(MulticastSocket pSocket, InetSocketAddress pSocketAddress, LogHandler pLogHandler) throws IOException {
+    private static void joinMcGroupsOnAllNetworkInterfaces(MulticastSocket pSocket, InetSocketAddress pSocketAddress) throws IOException {
         Enumeration<NetworkInterface> nifs = NetworkInterface.getNetworkInterfaces();
-        int interfacesJoined = 0;
         while (nifs.hasMoreElements()) {
             NetworkInterface n = nifs.nextElement();
             if (NetworkUtil.isMulticastSupported(n)) {
-                try {
-                    pSocket.joinGroup(pSocketAddress, n);
-                    interfacesJoined++;
-                } catch (IOException exp) {
-                    pLogHandler.info("Cannot join multicast group on NIF " + n.getDisplayName() + ": " + exp.getMessage());
-                }
+                pSocket.joinGroup(pSocketAddress, n);
             }
         }
-        return interfacesJoined;
     }
     private static void setOutgoingInterfaceForMulticastRequest(InetAddress pAddress, MulticastSocket pSocket) throws SocketException, UnknownHostException {
         NetworkInterface nif = NetworkInterface.getByInetAddress(pAddress);
         if (nif != null) {
             pSocket.setNetworkInterface(nif);
         }
     }
     private static final class FindAgentsCallable implements Callable<List<DiscoveryIncomingMessage>> {
         private final InetAddress address;
         private final DatagramPacket outPacket;

--- a/agent/core/src/main/java/org/jolokia/handler/ReadHandler.java
+++ b/agent/core/src/main/java/org/jolokia/handler/ReadHandler.java
@@ -61,20 +61,21 @@
     @Override
     /** {@inheritDoc} */
     public RequestType getType() {
         return RequestType.READ;
     }
     /**
      * For a simple requests (one MBean, one attribute) we let the dispatching of the servers
      * done by the upper level. If the request is for an MBean pattern or multiple attributes
      * are required, we try multiple requests for multiple server.
      *
+     *
      * @param pRequest request to decide on whether to handle all request at once
      * @return true if this is a multi attribute request, has an MBean pattern to look for or is a request for
      *         all attributes.
      */
     @Override
     public boolean handleAllServersAtOnce(JmxReadRequest pRequest) {
         return pRequest.getObjectName().isPattern() || pRequest.isMultiAttributeMode() || !pRequest.hasAttribute();
     }
     /**
      * Used for a request to a single attribute from a single MBean. Merging of MBeanServers is done
@@ -178,21 +179,25 @@
     }
     private List<String> resolveAttributes(MBeanServerExecutor pServers, ObjectName pMBeanName, List<String> pAttributeNames)
             throws IOException, ReflectionException, MBeanException, AttributeNotFoundException, InstanceNotFoundException {
         List<String> attributes = pAttributeNames;
         if (shouldAllAttributesBeFetched(pAttributeNames)) {
             attributes = getAllAttributesNames(pServers,pMBeanName);
         }
         return attributes;
     }
     private boolean shouldAllAttributesBeFetched(List<String> pAttributeNames) {
-        return pAttributeNames == null || pAttributeNames.size() == 0 || pAttributeNames.size() == 1 && pAttributeNames.get(0) == null;
+       if (pAttributeNames == null || pAttributeNames.size() == 0) {
+           return true;
+       } else {
+           return pAttributeNames.size() == 1 && pAttributeNames.get(0) == null;
+       }
     }
     private MBeanInfo getMBeanInfo(MBeanServerExecutor pServerManager, ObjectName pObjectName)
             throws IOException, ReflectionException, MBeanException, AttributeNotFoundException, InstanceNotFoundException {
         return pServerManager.call(pObjectName, MBEAN_INFO_HANDLER);
     }
     private Object getAttribute(MBeanServerExecutor pServerManager, ObjectName pMBeanName, String attribute)
             throws MBeanException, ReflectionException, IOException, AttributeNotFoundException, InstanceNotFoundException {
         return pServerManager.call(pMBeanName, MBEAN_ATTRIBUTE_READ_HANDLER, attribute);
     }
     private List<String> getAllAttributesNames(MBeanServerExecutor pServerManager, ObjectName pObjectName)

--- a/agent/core/src/main/java/org/jolokia/http/AgentServlet.java
+++ b/agent/core/src/main/java/org/jolokia/http/AgentServlet.java
@@ -144,21 +144,21 @@
         }
     }
     private String findAgentUrl(Configuration pConfig) {
         String url = System.getProperty("jolokia." + ConfigKey.DISCOVERY_AGENT_URL.getKeyValue());
         if (url == null) {
             url = System.getenv("JOLOKIA_DISCOVERY_AGENT_URL");
             if (url == null) {
                 url = pConfig.get(ConfigKey.DISCOVERY_AGENT_URL);
             }
         }
-        return NetworkUtil.replaceExpression(url);
+        return url;
     }
     private boolean listenForDiscoveryMcRequests(Configuration pConfig) {
         boolean sysProp = System.getProperty("jolokia." + ConfigKey.DISCOVERY_ENABLED.getKeyValue()) != null;
         boolean env     = System.getenv("JOLOKIA_DISCOVERY") != null;
         boolean config  = pConfig.getAsBoolean(ConfigKey.DISCOVERY_ENABLED);
         return sysProp || env || config;
     }
     /**
      * Create a log handler using this servlet's logging facility for logging. This method can be overridden
      * to provide a custom log handler. This method is called before {@link #createRestrictor(String)} so the log handler
@@ -221,47 +221,39 @@
                         req.getHeader("Origin"),
                         req.getHeader("Access-Control-Request-Headers"));
         for (Map.Entry<String,String> entry : responseHeaders.entrySet()) {
             resp.setHeader(entry.getKey(),entry.getValue());
         }
     }
     @SuppressWarnings({ "PMD.AvoidCatchingThrowable", "PMD.AvoidInstanceofChecksInCatchClause" })
     private void handle(ServletRequestHandler pReqHandler,HttpServletRequest pReq, HttpServletResponse pResp) throws IOException {
         JSONAware json = null;
         try {
-            requestHandler.checkAccess(pReq.getRemoteHost(), pReq.getRemoteAddr(),
-                                       getOriginOrReferer(pReq));
+            requestHandler.checkClientIPAccess(pReq.getRemoteHost(),pReq.getRemoteAddr());
             updateAgentUrlIfNeeded(pReq);
             json = pReqHandler.handleRequest(pReq,pResp);
         } catch (Throwable exp) {
             json = requestHandler.handleThrowable(
                     exp instanceof RuntimeMBeanException ? ((RuntimeMBeanException) exp).getTargetException() : exp);
         } finally {
             setCorsHeader(pReq, pResp);
             String callback = pReq.getParameter(ConfigKey.CALLBACK.getKeyValue());
             String answer = json != null ?
                     json.toJSONString() :
                     requestHandler.handleThrowable(new Exception("Internal error while handling an exception")).toJSONString();
             if (callback != null) {
                 sendResponse(pResp, "text/javascript", callback + "(" + answer + ");");
             } else {
                 sendResponse(pResp, getMimeType(pReq),answer);
             }
         }
     }
-    private String getOriginOrReferer(HttpServletRequest pReq) {
-        String origin = pReq.getHeader("Origin");
-        if (origin == null) {
-            origin = pReq.getHeader("Referer");
-        }
-        return origin != null ? origin.replaceAll("[\\n\\r]*","") : null;
-    }
     private void updateAgentUrlIfNeeded(HttpServletRequest pReq) {
         if (initAgentUrlFromRequest) {
             updateAgentUrl(NetworkUtil.sanitizeLocalUrl(pReq.getRequestURL().toString()), extractServletPath(pReq),pReq.getAuthType() != null);
             initAgentUrlFromRequest = false;
         }
     }
     private String extractServletPath(HttpServletRequest pReq) {
         return pReq.getRequestURI().substring(0,pReq.getContextPath().length());
     }
     private void updateAgentUrl(String pRequestUrl, String pServletPath, boolean pIsAuthenticated) {

--- a/agent/core/src/main/java/org/jolokia/http/HttpRequestHandler.java
+++ b/agent/core/src/main/java/org/jolokia/http/HttpRequestHandler.java
@@ -124,21 +124,21 @@
      *
      * See the <a href="http://www.w3.org/TR/cors/">CORS specification</a>
      * (section 'preflight checks') for more details.
      *
      * @param pOrigin the origin to check. If <code>null</code>, no headers are returned
      * @param pRequestHeaders extra headers to check against
      * @return headers to set
      */
     public Map<String, String> handleCorsPreflightRequest(String pOrigin, String pRequestHeaders) {
         Map<String,String> ret = new HashMap<String, String>();
-        if (pOrigin != null && backendManager.isOriginAllowed(pOrigin,false)) {
+        if (pOrigin != null && backendManager.isCorsAccessAllowed(pOrigin)) {
             ret.put("Access-Control-Allow-Origin","null".equals(pOrigin) ? "*" : pOrigin);
             if (pRequestHeaders != null) {
                 ret.put("Access-Control-Allow-Headers",pRequestHeaders);
             }
             ret.put("Access-Control-Allow-Credentials","true");
             ret.put("Access-Control-Allow-Max-Age","" + 3600 * 24 * 365);
         }
         return ret;
     }
     private Object extractJsonRequest(InputStream pInputStream, String pEncoding) throws IOException {
@@ -231,42 +231,38 @@
         if (pJmxReq != null) {
             jsonObject.put("request",pJmxReq.toJSON());
         }
         return jsonObject;
     }
     /**
      * Check whether the given host and/or address is allowed to access this agent.
      *
      * @param pHost host to check
      * @param pAddress address to check
-     * @param pOrigin (optional) origin header to check also.
-     */
-    public void checkAccess(String pHost, String pAddress, String pOrigin) {
+     */
+    public void checkClientIPAccess(String pHost, String pAddress) {
         if (!backendManager.isRemoteAccessAllowed(pHost,pAddress)) {
             throw new SecurityException("No access from client " + pAddress + " allowed");
         }
-        if (pOrigin != null && !backendManager.isOriginAllowed(pOrigin,true)) {
-            throw new SecurityException("Origin " + pOrigin + " is not allowed to call this agent");
-        }
-    }
-    /**
-     * Check whether for the given host is a cross-browser request allowed. This check is delegated to the
+    }
+    /**
+     * Check whether for the given host is a cross-browser request allowed. This check is deligated to the
      * backendmanager which is responsible for the security configuration.
      * Also, some sanity checks are applied.
      *
      * @param pOrigin the origin URL to check against
      * @return the origin to put in the response header or null if none is to be set
      */
     public String extractCorsOrigin(String pOrigin) {
         if (pOrigin != null) {
             String origin  = pOrigin.replaceAll("[\\n\\r]*","");
-            if (backendManager.isOriginAllowed(origin,false)) {
+            if (backendManager.isCorsAccessAllowed(origin)) {
                 return "null".equals(origin) ? "*" : origin;
             } else {
                 return null;
             }
         }
         return null;
     }
     private void addErrorInfo(JSONObject pErrorResp, Throwable pExp, JmxRequest pJmxReq) {
         String includeStackTrace = pJmxReq != null ?
                 pJmxReq.getParameter(ConfigKey.INCLUDE_STACKTRACE) : "true";

--- a/agent/core/src/main/java/org/jolokia/request/JmxObjectNameRequest.java
+++ b/agent/core/src/main/java/org/jolokia/request/JmxObjectNameRequest.java
@@ -82,21 +82,21 @@
     /**
      * String representation of the object name for this request.
      *
      * @return the object name a string representation
      */
     public String getObjectNameAsString() {
         return objectName.getCanonicalName();
     }
     /**
      * Name prepared according to requested formatting note. The key ordering can be influenced by the
-     * processing parameter {@link ConfigKey#CANONICAL_NAMING}. If not given or set to "true",
+     * proccesing parameter {@link ConfigKey#CANONICAL_NAMING}. If not given or set to "true",
      * then the canonical order is used, if set to "initial" the name is given to construction time
      * is used.
      *
      * @param pName name to format
      * @return formatted string
      */
     public String getOrderedObjectName(ObjectName pName) {
         if (pName.isPattern()) {
             return pName.getCanonicalName();
         }

--- a/agent/core/src/main/java/org/jolokia/request/JmxReadRequest.java
+++ b/agent/core/src/main/java/org/jolokia/request/JmxReadRequest.java
@@ -82,22 +82,22 @@
         return attributeNames;
     }
     /**
      * Whether this is a multi-attribute request, i.e. whether it contains one ore more attributes to fetch
      * @return true if this is a multi attribute request, false otherwise.
      */
     public boolean isMultiAttributeMode() {
         return multiAttributeMode;
     }
     /**
-     * Whether this request has not multiple attribute names associated  (which normally means, that all attributes should be fetched).
-     * @return true if not multiple attribute names are contained.
+     * Whether this request has no attribute names associated  (which normally means, that all attributes should be fetched).
+     * @return true if no attribute name is stored.
      */
     public boolean hasAttribute() {
         return isMultiAttributeMode() || getAttributeName() != null;
     }
     /** {@inheritDoc} */
     public JSONObject toJSON() {
         JSONObject ret = super.toJSON();
         if (attributeNames != null && attributeNames.size() > 0) {
             if (attributeNames.size() > 1) {
                 ret.put("attribute", attributeNames);

--- a/agent/core/src/main/java/org/jolokia/restrictor/AbstractConstantRestrictor.java
+++ b/agent/core/src/main/java/org/jolokia/restrictor/AbstractConstantRestrictor.java
@@ -53,14 +53,14 @@
     }
     /** {@inheritDoc} */
     public final boolean isOperationAllowed(ObjectName pName, String pOperation) {
         return isAllowed;
     }
     /** {@inheritDoc} */
     public final boolean isRemoteAccessAllowed(String... pHostOrAddress) {
         return isAllowed;
     }
     /** {@inheritDoc} */
-    public boolean isOriginAllowed(String pOrigin, boolean pIsStrictCheck) {
+    public boolean isCorsAccessAllowed(String pOrigin) {
         return isAllowed;
     }
 }

--- a/agent/core/src/main/java/org/jolokia/restrictor/PolicyRestrictor.java
+++ b/agent/core/src/main/java/org/jolokia/restrictor/PolicyRestrictor.java
@@ -70,22 +70,22 @@
     }
     /** {@inheritDoc} */
     public boolean isTypeAllowed(RequestType pType) {
         return requestTypeChecker.check(pType);
     }
     /** {@inheritDoc} */
     public boolean isRemoteAccessAllowed(String ... pHostOrAddress) {
         return networkChecker.check(pHostOrAddress);
     }
     /** {@inheritDoc} */
-    public boolean isOriginAllowed(String pOrigin, boolean pIsStrictCheck) {
-        return corsChecker.check(pOrigin,pIsStrictCheck);
+    public boolean isCorsAccessAllowed(String pOrigin) {
+        return corsChecker.check(pOrigin);
     }
     /** {@inheritDoc} */
     public boolean isAttributeReadAllowed(ObjectName pName, String pAttribute) {
         return check(RequestType.READ,pName,pAttribute);
     }
     /** {@inheritDoc} */
     public boolean isAttributeWriteAllowed(ObjectName pName, String pAttribute) {
         return check(RequestType.WRITE,pName, pAttribute);
     }
     /** {@inheritDoc} */

--- a/agent/core/src/main/java/org/jolokia/restrictor/Restrictor.java
+++ b/agent/core/src/main/java/org/jolokia/restrictor/Restrictor.java
@@ -71,16 +71,15 @@
      *
      * @return true is access is allowed
      * @param pHostOrAddress one or more host or address names
      */
     boolean isRemoteAccessAllowed(String ... pHostOrAddress);
     /**
      * Check whether cross browser access via CORS is allowed. See the
      * <a href="https://developer.mozilla.org/en/http_access_control">CORS</a> specification
      * for details
      *
-     * @param pOrigin the "Origin:" header provided within the request
-     * @param pIsStrictCheck whether doing a strict check
+     * @param pOrigin the "Origin:" URL provided within the request
      * @return true if this cross browser request allowed, false otherwise
      */
-    boolean isOriginAllowed(String pOrigin, boolean pIsStrictCheck);
+    boolean isCorsAccessAllowed(String pOrigin);
 }

--- a/agent/core/src/main/java/org/jolokia/restrictor/policy/CorsChecker.java
+++ b/agent/core/src/main/java/org/jolokia/restrictor/policy/CorsChecker.java
@@ -18,70 +18,57 @@
 import java.util.List;
 import java.util.regex.Pattern;
 import org.w3c.dom.*;
 /**
  * Check for location restrictions for CORS based cross browser platform requests
  *
  * @author roland
  * @since 07.04.12
  */
 public class CorsChecker extends AbstractChecker<String> {
-    private boolean strictChecking = false;
     private List<Pattern> patterns;
     /**
      * Constructor buiilding up this checker from the XML document provided.
      * CORS sections look like
      * <pre>
      *     &lt;cors&gt;
      *       &lt;allow-origin&gt;http://jolokia.org&lt;allow-origin&gt;
      *       &lt;allow-origin&gt;*://*.jmx4perl.org&gt;
-     *
-     *       &lt;strict-checking/&gt;
      *     &lt;/cors&gt;
      * </pre>
      *
      * @param pDoc the overall policy documents
      */
     public CorsChecker(Document pDoc) {
         NodeList corsNodes = pDoc.getElementsByTagName("cors");
         if (corsNodes.getLength() > 0) {
             patterns = new ArrayList<Pattern>();
             for (int i = 0; i < corsNodes.getLength(); i++) {
                 Node corsNode = corsNodes.item(i);
                 NodeList nodes = corsNode.getChildNodes();
                 for (int j = 0;j <nodes.getLength();j++) {
                     Node node = nodes.item(j);
                     if (node.getNodeType() != Node.ELEMENT_NODE) {
                         continue;
                     }
-                    assertNodeName(node,"allow-origin","strict-checking");
-                    if (node.getNodeName().equals("allow-origin")) {
-                        String p = node.getTextContent().trim().toLowerCase();
-                        p = Pattern.quote(p).replace("*", "\\E.*\\Q");
-                        patterns.add(Pattern.compile("^" + p + "$"));
-                    } else if (node.getNodeName().equals("strict-checking")) {
-                        strictChecking = true;
-                    }
+                    assertNodeName(node,"allow-origin");
+                    String p = node.getTextContent().trim().toLowerCase();
+                    p = Pattern.quote(p).replace("*","\\E.*\\Q");
+                    patterns.add(Pattern.compile("^" + p + "$"));
                 }
             }
         }
     }
     /** {@inheritDoc} */
     @Override
     public boolean check(String pArg) {
-        return check(pArg,false);
-    }
-    public boolean check(String pOrigin, boolean pIsStrictCheck) {
-        if (pIsStrictCheck && !strictChecking) {
-            return true;
-        }
         if (patterns == null || patterns.size() == 0) {
             return true;
         }
         for (Pattern pattern : patterns) {
-            if (pattern.matcher(pOrigin).matches()) {
+            if (pattern.matcher(pArg).matches()) {
                 return true;
             }
         }
         return false;
     }
 }

--- a/agent/core/src/main/java/org/jolokia/util/LogHandler.java
+++ b/agent/core/src/main/java/org/jolokia/util/LogHandler.java
@@ -59,19 +59,17 @@
         public void debug(String message) {
             if (doDebug) {
                 log("D> " + message);
             }
         }
         public void info(String message) {
             log("I> " + message);
         }
         public void error(String message, Throwable t) {
             log("E> " + message);
-            if (t != null) {
-                t.printStackTrace();
-            }
+            t.printStackTrace();
         }
         private void log(String message) {
             System.out.println(message); //NOSONAR
         }
     }
 }

--- a/agent/core/src/main/java/org/jolokia/util/NetworkUtil.java
+++ b/agent/core/src/main/java/org/jolokia/util/NetworkUtil.java
@@ -1,63 +1,60 @@
 package org.jolokia.util;
 import java.io.IOException;
 import java.lang.management.ManagementFactory;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.net.*;
 import java.util.*;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 /**
  * Utility class for network related stuff
  *
  * @author roland
  * @since 05.02.14
  */
 public final class NetworkUtil {
     private static Method isUp;
     private static Method supportsMulticast;
     static {
         try {
             isUp = NetworkInterface.class.getMethod("isUp", (Class<?>[]) null);
             supportsMulticast = NetworkInterface.class.getMethod("supportsMulticast", (Class<?>[]) null);
         } catch (NoSuchMethodException e) {
             isUp = null;
             supportsMulticast = null;
         }
     }
-    private NetworkUtil() {
-    }
+    private NetworkUtil() {}
     public static void main(String[] args) throws UnknownHostException, SocketException {
         System.out.println(dumpLocalNetworkInfo()); // NOSONAR
     }
     /**
      * Get a local, IP4 Address, preferable a non-loopback address which is bound to an interface.
-     *
      * @return
      * @throws UnknownHostException
      * @throws SocketException
      */
     public static InetAddress getLocalAddress() throws UnknownHostException, SocketException {
         InetAddress addr = InetAddress.getLocalHost();
         NetworkInterface nif = NetworkInterface.getByInetAddress(addr);
         if (addr.isLoopbackAddress() || addr instanceof Inet6Address || nif == null) {
             InetAddress lookedUpAddr = findLocalAddressViaNetworkInterface();
             addr = lookedUpAddr != null ? lookedUpAddr : InetAddress.getByName("127.0.0.1");
         }
         return addr;
     }
     /**
      * Get a local address which supports multicast. A loopback adress is returned, but only if not
      * another is available
      *
      * @return a multicast enabled address of null if none could be found
+     *
      * @throws UnknownHostException
      * @throws SocketException
      */
     public static InetAddress getLocalAddressWithMulticast() throws UnknownHostException, SocketException {
         InetAddress addr = InetAddress.getLocalHost();
         NetworkInterface nif = NetworkInterface.getByInetAddress(addr);
         if (addr.isLoopbackAddress() || addr instanceof Inet6Address || !isMulticastSupported(nif)) {
             InetAddress lookedUpAddr = findLocalAddressViaNetworkInterface();
             if (lookedUpAddr != null) {
                 return lookedUpAddr;
@@ -72,21 +69,21 @@
     }
     public static InetAddress findLocalAddressViaNetworkInterface() {
         Enumeration<NetworkInterface> networkInterfaces;
         try {
             networkInterfaces = NetworkInterface.getNetworkInterfaces();
         } catch (SocketException e) {
             return null;
         }
         while (networkInterfaces.hasMoreElements()) {
             NetworkInterface nif = networkInterfaces.nextElement();
-            for (Enumeration<InetAddress> addrEnum = nif.getInetAddresses(); addrEnum.hasMoreElements(); ) {
+            for (Enumeration<InetAddress> addrEnum = nif.getInetAddresses(); addrEnum.hasMoreElements();) {
                 InetAddress interfaceAddress = addrEnum.nextElement();
                 if (useInetAddress(nif, interfaceAddress)) {
                     return interfaceAddress;
                 }
             }
         }
         return null;
     }
     /**
      * Check, whether multicast is supported at all by at least one interface
@@ -96,43 +93,42 @@
     public static boolean isMulticastSupported() throws SocketException {
         return getMulticastAddresses().size() != 0;
     }
     /**
      * Check whether the given interface supports multicast and is up
      *
      * @param pNif check whether the given interface supports multicast
      * @return true if multicast is supported and the interface is up
      */
     public static boolean isMulticastSupported(NetworkInterface pNif) {
-        return pNif != null && checkMethod(pNif, isUp) && checkMethod(pNif, supportsMulticast);
+        return pNif != null && checkMethod(pNif, isUp) && checkMethod(pNif,supportsMulticast);
     }
     /**
      * Check whether the given address' interface supports multicast
      *
      * @param pAddr address to check
      * @return true if the underlying networkinterface is up and supports multicast
      * @throws SocketException
      */
     public static boolean isMulticastSupported(InetAddress pAddr) throws SocketException {
         return isMulticastSupported(NetworkInterface.getByInetAddress(pAddr));
     }
     /**
      * Get all local addresses on which a multicast can be send
-     *
      * @return list of all multi cast capable addresses
      */
     public static List<InetAddress> getMulticastAddresses() throws SocketException {
         Enumeration<NetworkInterface> nifs = NetworkInterface.getNetworkInterfaces();
         List<InetAddress> ret = new ArrayList<InetAddress>();
         while (nifs.hasMoreElements()) {
             NetworkInterface nif = nifs.nextElement();
-            if (checkMethod(nif, supportsMulticast) && checkMethod(nif, isUp)) {
+            if (checkMethod(nif, supportsMulticast) && checkMethod(nif,isUp)) {
                 Enumeration<InetAddress> addresses = nif.getInetAddresses();
                 while (addresses.hasMoreElements()) {
                     InetAddress addr = addresses.nextElement();
                     if (!(addr instanceof Inet6Address)) {
                         ret.add(addr);
                     }
                 }
             }
         }
         return ret;
@@ -142,40 +138,40 @@
         try {
             address = getLocalAddress().getHostAddress();
         } catch (IOException exp) {
             address = "local";
         }
         return address + "-" + getProcessId() + "-" + Integer.toHexString(objectId) + "-" + type;
     }
     /**
      * Examine the given URL and replace the host with a non-loopback host if possible. It is checked,
      * whether the port is open as well.
-     * <p/>
+     *
      * A replaced host uses the  IP address instead of a (possibly non resolvable) name.
      *
      * @param pRequestURL url to examine and to update
      * @return the 'sane' URL (or the original one if no san
      */
     public static String sanitizeLocalUrl(String pRequestURL) {
         try {
             URL url = new URL(pRequestURL);
             String host = url.getHost();
-            InetAddress address = findLocalAddressListeningOnPort(host, url.getPort());
-            return new URL(url.getProtocol(), address.getHostAddress(), url.getPort(), url.getFile()).toExternalForm();
+            InetAddress address = findLocalAddressListeningOnPort(host,url.getPort());
+            return new URL(url.getProtocol(),address.getHostAddress(),url.getPort(),url.getFile()).toExternalForm();
         } catch (IOException e) {
             return pRequestURL;
         }
     }
     private static boolean useInetAddress(NetworkInterface networkInterface, InetAddress interfaceAddress) {
         return checkMethod(networkInterface, isUp) &&
                checkMethod(networkInterface, supportsMulticast) &&
-               !(interfaceAddress instanceof Inet6Address) &&
+               ! (interfaceAddress instanceof Inet6Address) &&
                !interfaceAddress.isLoopbackAddress();
     }
     private static Boolean checkMethod(NetworkInterface iface, Method toCheck) {
         if (toCheck != null) {
             try {
                 return (Boolean) toCheck.invoke(iface, (Object[]) null);
             } catch (IllegalAccessException e) {
                 return false;
             } catch (InvocationTargetException e) {
                 return false;
@@ -196,21 +192,21 @@
             }
         }
         return address;
     }
     private static InetAddress getLocalAddressFromNetworkInterfacesListeningOnPort(int pPort) {
         try {
             Enumeration<NetworkInterface> networkInterfaces;
             networkInterfaces = NetworkInterface.getNetworkInterfaces();
             while (networkInterfaces.hasMoreElements()) {
                 NetworkInterface nif = networkInterfaces.nextElement();
-                for (Enumeration<InetAddress> addrEnum = nif.getInetAddresses(); addrEnum.hasMoreElements(); ) {
+                for (Enumeration<InetAddress> addrEnum = nif.getInetAddresses(); addrEnum.hasMoreElements();) {
                     InetAddress interfaceAddress = addrEnum.nextElement();
                     if (!interfaceAddress.isLoopbackAddress() && checkMethod(nif, isUp) && isPortOpen(interfaceAddress, pPort)) {
                         return interfaceAddress;
                     }
                 }
             }
         } catch (SocketException e) {
             return null;
         }
         return null;
@@ -236,95 +232,41 @@
     }
     private static String getProcessId() {
         final String jvmName = ManagementFactory.getRuntimeMXBean().getName();
         final int index = jvmName.indexOf('@');
         return index < 0 ? jvmName : jvmName.substring(0, index);
     }
     /**
      * Get the local network info as a string
      *
      * @return return a description of the current network setup of the local host.
+     *
      * @throws UnknownHostException
      * @throws SocketException
      */
     public static String dumpLocalNetworkInfo() throws UnknownHostException, SocketException {
         StringBuffer buffer = new StringBuffer();
         InetAddress addr = InetAddress.getLocalHost();
         buffer.append("Localhost: " + getAddrInfo(addr) + "\n");
         Enumeration<NetworkInterface> nifs = NetworkInterface.getNetworkInterfaces();
         buffer.append("Network interfaces:\n");
         while (nifs.hasMoreElements()) {
             NetworkInterface nif = nifs.nextElement();
             buffer.append("  - " + getNetworkInterfaceInfo(nif) + "\n");
             Enumeration<InetAddress> addresses = nif.getInetAddresses();
             while (addresses.hasMoreElements()) {
                 addr = addresses.nextElement();
                 buffer.append("    " + getAddrInfo(addr) + "\n");
             }
         }
         return buffer.toString();
     }
-    private static final Pattern EXPRESSION_EXTRACTOR = Pattern.compile("\\$\\{?\\s*([\\w:-_.]+)\\s*}?");
-    /**
-     * Replace expression ${host} and ${ip} with the localhost name or IP in the given string.
-     * In addition the notation ${env:ENV_VAR} and ${prop:sysprop} can be used to refer to environment
-     * and system properties respectively.
-     *
-     * @param pValue value to examine
-     * @return the value with the variables replaced.
-     * @throws IllegalArgumentException when the expression is unknown or an error occurs when extracting the host name
-     */
-    public static String replaceExpression(String pValue) {
-        if (pValue == null) {
-            return null;
-        }
-        Matcher matcher = EXPRESSION_EXTRACTOR.matcher(pValue);
-        StringBuffer ret = new StringBuffer();
-        try {
-            while (matcher.find()) {
-                String var = matcher.group(1);
-                String value;
-                if (var.equalsIgnoreCase("host")) {
-                    value = getLocalAddress().getHostName();
-                } else if (var.equalsIgnoreCase("ip")) {
-                    value = getLocalAddress().getHostAddress();
-                } else {
-                    String key = extractKey(var,"env");
-                    if (key != null)  {
-                        value = System.getenv(key).trim();
-                    } else {
-                        key = extractKey(var,"prop");
-                        if (key != null) {
-                            value = System.getProperty(key).trim();
-                        } else {
-                            throw new IllegalArgumentException("Unknown expression " + var + " in " + pValue);
-                        }
-                    }
-                }
-                matcher.appendReplacement(ret, value);
-            }
-            matcher.appendTail(ret);
-        } catch (IOException e) {
-            throw new IllegalArgumentException("Cannot lookup host" + e, e);
-        }
-        return ret.toString();
-    }
-    private static String extractKey(String pVar, String pPrefix) {
-        if (pVar.toLowerCase().startsWith(pPrefix + ":")) {
-            String ret = pVar.substring(pPrefix.length() + 1);
-            if (ret.length() == 0) {
-                throw new IllegalArgumentException("Expression with " + pPrefix + ": must not contain spaces");
-            }
-            return ret;
-        }
-        return null;
-    }
     private static String getAddrInfo(InetAddress pAddr) throws SocketException {
         String ret = pAddr.getHostName() != null ? pAddr.getHostName() + " (" + pAddr.getHostAddress() + ")" : pAddr.getHostAddress();
         ret += " [site-local: " + pAddr.isSiteLocalAddress() + ", link-local: " + pAddr.isLinkLocalAddress() + ", lb: " + pAddr.isLoopbackAddress() + "]";
         NetworkInterface nif = NetworkInterface.getByInetAddress(pAddr);
         ret += " -- nif: " + getNetworkInterfaceInfo(nif);
         return ret;
     }
     private static String getNetworkInterfaceInfo(NetworkInterface pNif) throws SocketException {
         if (pNif == null) {
             return "[null]";

--- a/agent/jvm/src/main/java/org/jolokia/jvmagent/JolokiaHttpHandler.java
+++ b/agent/jvm/src/main/java/org/jolokia/jvmagent/JolokiaHttpHandler.java
@@ -127,22 +127,21 @@
     @SuppressWarnings({"PMD.AvoidCatchingThrowable", "PMD.AvoidInstanceofChecksInCatchClause"})
     public void handle(HttpExchange pExchange) throws IOException {
         if (requestHandler == null) {
             throw new IllegalStateException("Handler not yet started");
         }
         JSONAware json = null;
         URI uri = pExchange.getRequestURI();
         ParsedUri parsedUri = new ParsedUri(uri,context);
         try {
             InetSocketAddress address = pExchange.getRemoteAddress();
-            requestHandler.checkAccess(address.getHostName(), address.getAddress().getHostAddress(),
-                                       extractOriginOrReferer(pExchange));
+            requestHandler.checkClientIPAccess(address.getHostName(),address.getAddress().getHostAddress());
             String method = pExchange.getRequestMethod();
             if ("GET".equalsIgnoreCase(method)) {
                 setHeaders(pExchange);
                 json = executeGetRequest(parsedUri);
             } else if ("POST".equalsIgnoreCase(method)) {
                 setHeaders(pExchange);
                 json = executePostRequest(pExchange, parsedUri);
             } else if ("OPTIONS".equalsIgnoreCase(method)) {
                 performCorsPreflightCheck(pExchange);
             } else {
@@ -164,28 +163,20 @@
                 return ret;
             } else {
                 logHandler.info("No access restrictor found, access to all MBean is allowed");
                 return new AllowAllRestrictor();
             }
         } catch (IOException e) {
             logHandler.error("Error while accessing access restrictor at " + location +
                              ". Denying all access to MBeans for security reasons. Exception: " + e, e);
             return new DenyAllRestrictor();
         }
-    }
-    private String extractOriginOrReferer(HttpExchange pExchange) {
-        Headers headers = pExchange.getRequestHeaders();
-        String origin = headers.getFirst("Origin");
-        if (origin == null) {
-            origin = headers.getFirst("Referer");
-        }
-        return origin != null ? origin.replaceAll("[\\n\\r]*","") : null;
     }
     private JSONAware executeGetRequest(ParsedUri parsedUri) {
         return requestHandler.handleGetRequest(parsedUri.getUri().toString(),parsedUri.getPathInfo(), parsedUri.getParameterMap());
     }
     private JSONAware executePostRequest(HttpExchange pExchange, ParsedUri pUri) throws MalformedObjectNameException, IOException {
         String encoding = null;
         Headers headers = pExchange.getRequestHeaders();
         String cType =  headers.getFirst("Content-Type");
         if (cType != null) {
             Matcher matcher = contentTypePattern.matcher(cType);
@@ -253,14 +244,34 @@
             }
             mimeType = configuration.get(ConfigKey.MIME_TYPE);
             return mimeType != null ? mimeType : ConfigKey.MIME_TYPE.getDefaultValue();
         }
     }
     private LogHandler createLogHandler(String pLogHandlerClass, String pDebug) {
         if (pLogHandlerClass != null) {
             return ClassUtil.newInstance(pLogHandlerClass);
         } else {
             final boolean debug = Boolean.valueOf(pDebug);
-            return new LogHandler.StdoutLogHandler(debug);
+            return new PlainLogHandler(debug);
+        }
+    }
+    private static class PlainLogHandler implements LogHandler {
+        private final boolean debug;
+        public PlainLogHandler(boolean pDebug) {
+            debug = pDebug;
+        }
+        @Override
+        public final void debug(String message) {
+            if (debug) {
+                System.err.println("D> " + message);
+            }
+        }
+        @Override
+        public final void info(String message) {
+            System.err.println("I> " + message);
+        }
+        @Override
+        public final void error(String message, Throwable t) {
+            System.err.println("E> " + message + " (Exception: " + t + ")");
         }
     }
 }

--- a/agent/jvm/src/main/java/org/jolokia/jvmagent/JolokiaServer.java
+++ b/agent/jvm/src/main/java/org/jolokia/jvmagent/JolokiaServer.java
@@ -68,21 +68,21 @@
     /**
      * No arg constructor usable by subclasses. The {@link #init(JolokiaServerConfig, boolean)} must be called later on
      * for initialization
      */
     protected JolokiaServer() {}
     /**
      * Start this server. If we manage an own HttpServer, then the HttpServer will
      * be started as well.
      */
     public void start() {
-        String configUrl = NetworkUtil.replaceExpression(config.getJolokiaConfig().get(ConfigKey.DISCOVERY_AGENT_URL));
+        String configUrl = config.getJolokiaConfig().get(ConfigKey.DISCOVERY_AGENT_URL);
         jolokiaHttpHandler.start(lazy,configUrl != null ? configUrl : url, config.getAuthenticator() != null);
         if (httpServer != null) {
             ThreadGroup threadGroup = new ThreadGroup("jolokia");
             threadGroup.setDaemon(false);
             Thread starterThread = new Thread(threadGroup,new Runnable() {
             @Override
             public void run() {
                 httpServer.start();
             }
         });

--- a/agent/osgi/src/main/java/org/jolokia/osgi/DelegatingRestrictor.java
+++ b/agent/osgi/src/main/java/org/jolokia/osgi/DelegatingRestrictor.java
@@ -122,26 +122,26 @@
             return restrictor.isRemoteAccessAllowed(argsS);
         }
     };
     /** {@inheritDoc} */
     public boolean isRemoteAccessAllowed(String... pHostOrAddress) {
         return checkRestrictorService(REMOTE_CHECK,pHostOrAddress);
     }
     private static final RestrictorCheck CORS_CHECK = new RestrictorCheck() {
         /** {@inheritDoc} */
         public boolean check(Restrictor restrictor, Object... args) {
-            return restrictor.isOriginAllowed((String) args[0], (Boolean) args[1]);
+            return restrictor.isCorsAccessAllowed((String) args[0]);
         }
     };
     /** {@inheritDoc} */
-    public boolean isOriginAllowed(String pOrigin, boolean pIsStrictCheck) {
-        return checkRestrictorService(CORS_CHECK,pOrigin,pIsStrictCheck);
+    public boolean isCorsAccessAllowed(String pOrigin) {
+        return checkRestrictorService(CORS_CHECK,pOrigin);
     }
     /**
      * Internal interface for restrictor delegation
      */
     private interface RestrictorCheck {
         /**
          * Run check specifically for the restrictor to delegate to
          * @param restrictor the restrictor on which the check should be run
          * @param args context dependent arguments
          * @return result of the check

--- a/client/java/src/main/java/org/jolokia/client/J4pClient.java
+++ b/client/java/src/main/java/org/jolokia/client/J4pClient.java
@@ -7,38 +7,33 @@
  * You may obtain a copy of the License at
  *
  *       http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-import org.apache.http.HttpResponse;
-import org.apache.http.HttpStatus;
-import org.apache.http.StatusLine;
+import java.io.IOException;
+import java.net.*;
+import java.util.*;
+import org.apache.http.*;
 import org.apache.http.client.HttpClient;
-import org.apache.http.conn.ConnectTimeoutException;
+import org.apache.http.conn.*;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.params.HttpParams;
 import org.jolokia.client.exception.*;
 import org.jolokia.client.request.*;
-import org.json.simple.JSONArray;
-import org.json.simple.JSONAware;
-import org.json.simple.JSONObject;
+import org.jolokia.client.request.J4pResponse;
+import org.json.simple.*;
 import org.json.simple.parser.ParseException;
-import java.io.IOException;
-import java.net.ConnectException;
-import java.net.URISyntaxException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
 /**
  * Client class for accessing the j4p agent
  *
  * @author roland
  * @since Apr 24, 2010
  */
 public class J4pClient extends J4pClientBuilderFactory {
     private HttpClient httpClient;
     private J4pRequestHandler requestHandler;
     /**
@@ -65,21 +60,23 @@
      * @param pJ4pServerUrl the agent URL for how to contact the server.
      * @param pHttpClient HTTP client to use for the connecting to the agent
      * @param pTargetConfig optional target
      */
     public J4pClient(String pJ4pServerUrl, HttpClient pHttpClient,J4pTargetConfig pTargetConfig) {
         requestHandler = new J4pRequestHandler(pJ4pServerUrl,pTargetConfig);
         if (pHttpClient != null) {
             httpClient = pHttpClient;
         } else {
             J4pClientBuilder builder = new J4pClientBuilder();
-            httpClient = builder.createHttpClient();
+            HttpParams params = builder.getHttpParams();
+            ClientConnectionManager cm = builder.createClientConnectionManager();
+            httpClient = new DefaultHttpClient(cm, params);
         }
     }
     /**
      * Execute a single J4pRequest returning a single response.
      * The HTTP Method used is determined automatically.
      *
      * @param pRequest request to execute
      * @param <R> response type
      * @param <T> request type
      * @return the response as returned by the server

--- a/client/java/src/main/java/org/jolokia/client/J4pClientBuilder.java
+++ b/client/java/src/main/java/org/jolokia/client/J4pClientBuilder.java
@@ -7,78 +7,69 @@
  * You may obtain a copy of the License at
  *
  *       http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-import java.nio.charset.Charset;
-import javax.net.ssl.SSLContext;
+import org.apache.http.HttpVersion;
 import org.apache.http.auth.AuthScope;
 import org.apache.http.auth.UsernamePasswordCredentials;
-import org.apache.http.client.CredentialsProvider;
-import org.apache.http.client.HttpClient;
-import org.apache.http.client.config.RequestConfig;
-import org.apache.http.config.*;
-import org.apache.http.conn.*;
-import org.apache.http.conn.routing.HttpRoute;
-import org.apache.http.conn.socket.ConnectionSocketFactory;
-import org.apache.http.conn.socket.PlainConnectionSocketFactory;
-import org.apache.http.conn.ssl.*;
-import org.apache.http.impl.client.*;
-import org.apache.http.impl.conn.*;
-import org.apache.http.impl.io.DefaultHttpRequestWriterFactory;
-import org.apache.http.impl.io.DefaultHttpResponseParserFactory;
+import org.apache.http.conn.ClientConnectionManager;
+import org.apache.http.conn.params.ConnManagerParams;
+import org.apache.http.conn.scheme.*;
+import org.apache.http.conn.ssl.SSLSocketFactory;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.impl.conn.SingleClientConnManager;
+import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
+import org.apache.http.params.*;
 import org.apache.http.protocol.HTTP;
 import org.apache.http.util.VersionInfo;
 import org.jolokia.client.request.J4pTargetConfig;
 /**
  * A builder for a {@link org.jolokia.client.J4pClient}.
  *
  * @author roland
  * @since 26.11.10
  */
 public class J4pClientBuilder {
-    private int connectionTimeout;
-    private int socketTimeout;
-    private int maxTotalConnections;
-    private int maxConnectionPoolTimeout;
-    private Charset contentCharset;
-    private boolean expectContinue;
-    private boolean tcpNoDelay;
-    private int socketBufferSize;
+    private HttpParams params;
     private boolean pooledConnections;
     private String url;
     private String user;
     private String password;
     private String targetUrl;
     private String targetUser;
     private String targetPassword;
     /**
      * Package access constructor, use static method on J4pClient for creating
      * the builder.
      */
     public J4pClientBuilder() {
+        params = new BasicHttpParams();
         connectionTimeout(20 * 1000);
-        socketTimeout(-1);
         maxTotalConnections(20);
         maxConnectionPoolTimeout(500);
-        contentCharset(HTTP.DEF_CONTENT_CHARSET.name());
+        contentCharset(HTTP.DEFAULT_CONTENT_CHARSET);
         expectContinue(true);
         tcpNoDelay(true);
         socketBufferSize(8192);
         pooledConnections();
         user = null;
         password = null;
+        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
+        final VersionInfo vi = VersionInfo.loadVersionInfo("org.apache.http.client", getClass().getClassLoader());
+        final String release = (vi != null) ? vi.getRelease() : VersionInfo.UNAVAILABLE;
+        HttpProtocolParams.setUserAgent(params,"Jolokia JMX-Client (using Apache-HttpClient/" + release +")");
     }
     /**
      * The Agent URL to connect to
      *
      * @param pUrl agent URL
      */
     public final J4pClientBuilder url(String pUrl) {
         url = pUrl;
         return this;
     }
@@ -122,204 +113,138 @@
      * Target password for proxy mode. This parameter takes only effect when a target is set and the target user is
      * not null
      *
      * @param pPassword Password to be used for authentication in JSR-160 proxy communication
      */
     public final J4pClientBuilder targetPassword(String pPassword) {
         targetPassword = pPassword;
         return this;
     }
     /**
-     * Use a single threaded client for connecting to the agent. This
-     * is not very suitable in multithreaded environments
+     * Use a {@link org.apache.http.impl.conn.SingleClientConnManager} for connecting to the agent. This
+     * is not very suitable in multithreaded environements
      */
     public final J4pClientBuilder singleConnection() {
         pooledConnections = false;
         return this;
     }
     /**
-     * Use a pooled connection manager for connecting to the agent, which
+     * Use a {@link org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager} for connecting to the agent, which
      * uses a pool of connections (see {@link #maxTotalConnections(int) and {@link #maxConnectionPoolTimeout(int)} for
      * tuning the pool}
      */
     public final J4pClientBuilder pooledConnections() {
         pooledConnections = true;
         return this;
     }
     /**
      * Determines the timeout in milliseconds until a connection is established. A timeout value of zero is
-     * interpreted as an infinite timeout. Default is 20 seconds.
-     *
+     * interpreted as an infinite timeout.
      * @param pTimeOut timeout in milliseconds
      */
     public final J4pClientBuilder connectionTimeout(int pTimeOut) {
-        connectionTimeout = pTimeOut;
+        HttpConnectionParams.setConnectionTimeout(params,pTimeOut);
         return this;
     }
     /**
      * Defines the socket timeout (<code>SO_TIMEOUT</code>) in milliseconds,
      * which is the timeout for waiting for data  or, put differently,
      * a maximum period inactivity between two consecutive data packets).
-     * A timeout value of zero is interpreted as an infinite timeout, a negative value means the system default.
+     * A timeout value of zero is interpreted as an infinite timeout.
      *
      * @param pTimeOut SO_TIMEOUT value in milliseconds, 0 mean no timeout at all.
      */
     public final J4pClientBuilder socketTimeout(int pTimeOut) {
-        socketTimeout = pTimeOut;
+        HttpConnectionParams.setSoTimeout(params,pTimeOut);
         return this;
     }
     /**
      * Sets the maximum number of connections allowed when using {@link #pooledConnections()}.
-     * @param pConnections number of max. simultaneous connections.
+     * @param pConnections number of max. simultaneous connections
      */
     public final J4pClientBuilder maxTotalConnections(int pConnections) {
-        maxTotalConnections = pConnections;
+        ConnManagerParams.setMaxTotalConnections(params, pConnections);
         return this;
     }
     /**
      * Sets the timeout in milliseconds used when retrieving a connection
-     * from the connection manager. Default is 500ms, if set to -1 the system default is used. Use
-     * 0 for an infinite timeout.
+     * from the {@link org.apache.http.conn.ClientConnectionManager}.
      *
      * @param pConnectionPoolTimeout timeout in milliseconds
      */
     public final J4pClientBuilder maxConnectionPoolTimeout(int pConnectionPoolTimeout) {
-        maxConnectionPoolTimeout = pConnectionPoolTimeout;
+        ConnManagerParams.setTimeout(params,pConnectionPoolTimeout);
         return this;
     }
     /**
      * Defines the charset to be used per default for encoding content body.
      * @param pContentCharset the charset to use
      */
     public final J4pClientBuilder contentCharset(String pContentCharset) {
-        return contentCharset(Charset.forName(pContentCharset));
-    }
-    /**
-     * Defines the charset to be used per default for encoding content body.
-     * @param pContentCharset the charset to use
-     */
-    public final J4pClientBuilder contentCharset(Charset pContentCharset) {
-        contentCharset = pContentCharset;
+        HttpProtocolParams.setContentCharset(params, pContentCharset);
         return this;
     }
     /**
      * Activates 'Expect: 100-Continue' handshake for the entity enclosing methods.
      * The purpose of the 'Expect: 100-Continue' handshake to allow a client that is
      * sending a request message with a request body to determine if the origin server
      * is willing to accept the request (based on the request headers) before the client
      * sends the request body.
      * The use of the 'Expect: 100-continue' handshake can result in noticable peformance
      * improvement for entity enclosing requests that require the target server's authentication.
      *
      * @param pUse whether to use this algorithm or not
      */
     public final J4pClientBuilder expectContinue(boolean pUse) {
-        expectContinue = pUse;
+        HttpProtocolParams.setUseExpectContinue(params,pUse);
         return this;
     }
     /**
      * Determines whether Nagle's algorithm is to be used. The Nagle's algorithm tries to conserve
      * bandwidth by minimizing the number of segments that are sent. When applications wish to
      * decrease network latency and increase performance, they can disable Nagle's
      * algorithm (that is enable TCP_NODELAY). Data will be sent earlier, at the cost
      * of an increase in bandwidth consumption.
      * @param pUse whether to use NO_DELAY or not
      */
     public final J4pClientBuilder tcpNoDelay(boolean pUse) {
-        tcpNoDelay = pUse;
+        HttpConnectionParams.setTcpNoDelay(params,pUse);
         return this;
     }
     /**
      * Determines the size of the internal socket buffer used to buffer data while receiving /
      * transmitting HTTP messages.
      * @param pSize size of socket buffer
      */
     public final J4pClientBuilder socketBufferSize(int pSize) {
-        socketBufferSize = pSize;
+        HttpConnectionParams.setSocketBufferSize(params,pSize);
         return this;
     }
     /**
      * Build the agent with the information given before
      *
      * @return a new J4pClient
      */
     public J4pClient build() {
-        return new J4pClient(url,createHttpClient(),targetUrl != null ? new J4pTargetConfig(targetUrl,targetUser,targetPassword) : null);
-    }
-    public HttpClient createHttpClient() {
-        HttpClientConnectionManager connManager =
-                pooledConnections ? createPoolingConnectionManager() : createBasicConnectionManager();
-        HttpClientBuilder builder = HttpClients.custom()
-                .setConnectionManager(connManager)
-                .setUserAgent("Jolokia JMX-Client (using Apache-HttpClient/" + getVersionInfo() + ")")
-                .setDefaultRequestConfig(createRequestConfig());
+        ClientConnectionManager cm = createClientConnectionManager();
+        DefaultHttpClient httpClient = new DefaultHttpClient(cm, getHttpParams());
         if (user != null) {
-            CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
-            credentialsProvider.setCredentials(
-                    new AuthScope(AuthScope.ANY),
-                    new UsernamePasswordCredentials(user, password));
-            builder.setDefaultCredentialsProvider(credentialsProvider);
+            httpClient.getCredentialsProvider().setCredentials(AuthScope.ANY,
+                                                               new UsernamePasswordCredentials(user,password));
         }
-        return builder.build();
-    }
-    private String getVersionInfo() {
-        final VersionInfo vi = VersionInfo.loadVersionInfo("org.apache.http.client", getClass().getClassLoader());
-        return (vi != null) ? vi.getRelease() : VersionInfo.UNAVAILABLE;
-    }
-    private RequestConfig createRequestConfig() {
-        RequestConfig.Builder requestConfigB = RequestConfig.custom();
-        requestConfigB.setExpectContinueEnabled(expectContinue);
-        if (socketTimeout > -1) {
-            requestConfigB.setSocketTimeout(socketTimeout);
-        }
-        if (connectionTimeout > -1) {
-            requestConfigB.setConnectTimeout(connectionTimeout);
-        }
-        if (maxConnectionPoolTimeout > -1) {
-            requestConfigB.setConnectionRequestTimeout(maxConnectionPoolTimeout);
-        }
-        return requestConfigB.build();
-    }
-    private BasicHttpClientConnectionManager createBasicConnectionManager() {
-        BasicHttpClientConnectionManager connManager =
-                new BasicHttpClientConnectionManager(getSocketFactoryRegistry(),getConnectionFactory());
-        connManager.setSocketConfig(createSocketConfig());
-        connManager.setConnectionConfig(createConnectionConfig());
-        return connManager;
-    }
-    private PoolingHttpClientConnectionManager createPoolingConnectionManager() {
-        PoolingHttpClientConnectionManager connManager =
-            new PoolingHttpClientConnectionManager(getSocketFactoryRegistry(), getConnectionFactory());
-        connManager.setDefaultSocketConfig(createSocketConfig());
-        connManager.setDefaultConnectionConfig(createConnectionConfig());
-        if (maxTotalConnections != 0) {
-            connManager.setMaxTotal(maxTotalConnections);
-        }
-        return connManager;
-    }
-    private ConnectionConfig createConnectionConfig() {
-        return ConnectionConfig.custom()
-                .setBufferSize(socketBufferSize)
-                .setCharset(contentCharset)
-                .build();
-    }
-    private SocketConfig createSocketConfig() {
-        SocketConfig.Builder socketConfigB = SocketConfig.custom();
-        if (socketTimeout >= 0) {
-            socketConfigB.setSoTimeout(socketTimeout);
-        }
-        socketConfigB.setTcpNoDelay(tcpNoDelay);
-        return socketConfigB.build();
-    }
-    private Registry<ConnectionSocketFactory> getSocketFactoryRegistry() {
-        SSLContext sslcontext = SSLContexts.createSystemDefault();
-        X509HostnameVerifier hostnameVerifier = new BrowserCompatHostnameVerifier();
-        return RegistryBuilder.<ConnectionSocketFactory>create()
-                              .register("http", PlainConnectionSocketFactory.INSTANCE)
-                              .register("https", new SSLConnectionSocketFactory(sslcontext, hostnameVerifier))
-                              .build();
-    }
-    private HttpConnectionFactory<HttpRoute, ManagedHttpClientConnection> getConnectionFactory() {
-        return new ManagedHttpClientConnectionFactory(new DefaultHttpRequestWriterFactory(),
-                                                      new DefaultHttpResponseParserFactory());
+        return new J4pClient(url,httpClient,targetUrl != null ? new J4pTargetConfig(targetUrl,targetUser,targetPassword) : null);
+    }
+    ClientConnectionManager createClientConnectionManager() {
+        return pooledConnections ?
+                new ThreadSafeClientConnManager(getHttpParams(), getSchemeRegistry()) :
+                new SingleClientConnManager(getSchemeRegistry());
+    }
+    HttpParams getHttpParams() {
+        return params;
+    }
+    private SchemeRegistry getSchemeRegistry() {
+        SchemeRegistry schemeRegistry = new SchemeRegistry();
+        schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
+        schemeRegistry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
+        return schemeRegistry;
     }
 }

--- a/client/javascript/src/main/javascript/jolokia-cubism.js
+++ b/client/javascript/src/main/javascript/jolokia-cubism.js
@@ -13,21 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 /**
  * Jolokia integration into cubism (http://square.github.com/cubism/)
  *
  * This integration requires the following
  */
 (function () {
     var builder = function (cubism,Jolokia) {
-        var VERSION = "1.2.1";
+        var VERSION = "1.2.0";
         var ctx_jolokia = function (url, opts) {
             var source = {},
                 context = this,
                 j4p = createAgent(url, opts),
                 step = 5e3;                    // 5 seconds by default
             try
             {
                 context.on("start",function() {
                     j4p.start();
                 });

--- a/client/javascript/src/main/javascript/jolokia.js
+++ b/client/javascript/src/main/javascript/jolokia.js
@@ -44,21 +44,21 @@
          * An object containing the default parameters can be provided as argument. For the possible parameters
          * see {@link #request()}.
          *
          * @param param either a string in which case it is used as the URL to the agent or
          *              an object with the default parameters as key-value pairs
          */
         function Jolokia(param) {
             if (!(this instanceof arguments.callee)) {
                 return new Jolokia(param);
             }
-            this.CLIENT_VERSION = "1.2.1";
+            this.CLIENT_VERSION = "1.2.0";
             var jobs = [];
             var agentOptions = {};
             var pollerIsRunning = false;
             if (typeof param === "string") {
                 param = {url:param};
             }
             $.extend(agentOptions, DEFAULT_CLIENT_PARAMS, param);
             /**
              * The request method using one or more JSON requests and sending it to the agent. Beside the
              * request a bunch of options can be given, which are merged with the options provided
