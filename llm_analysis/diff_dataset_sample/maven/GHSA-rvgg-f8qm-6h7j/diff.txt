--- a/vertx-web-api-contract/src/main/java/io/vertx/ext/web/api/contract/openapi3/impl/OpenAPI3PathResolver.java
+++ b/vertx-web-api-contract/src/main/java/io/vertx/ext/web/api/contract/openapi3/impl/OpenAPI3PathResolver.java
@@ -71,99 +71,99 @@
             | simple | true    | n/a    | blue        | blue,black,brown                    | R=100,G=200,B=150        |
             +--------+---------+--------+-------------+-------------------------------------+--------------------------+
             RFC 3986 section 2.2 Reserved Characters (January 2005)
             !	*	'	(	)	;	:	@	&	=	+	$	,	/	?	#	[	]
            */
           if (style.equals("simple")) {
             regex.append(
               RegexBuilder.create().namedGroup(
                 groupName,
                 RegexBuilder.create().notCharactersClass(
-                  "!",	"*",	"'", "(",	")",	";",	"@",	"&",	"+",	"$",	"/",	"?",	"#",	"[",	"]", (shouldThreatDotAsReserved) ? "." : null
+                  "!",	"*",	"'", "(",	")",	";",	":",	"@",	"&",	"+",	"$",	"/",	"?",	"#",	"[",	"]", (shouldThreatDotAsReserved) ? "." : null
                 ).zeroOrMore()
               ).zeroOrOne()
             );
             mappedGroups.put(groupName, paramName);
           } else if (style.equals("label")) {
             if (isObject && explode) {
               Map<String, OpenApi3Utils.ObjectField> properties = OpenApi3Utils.solveObjectParameters(parameter.getSchema());
               for (Map.Entry<String, OpenApi3Utils.ObjectField> entry : properties.entrySet()) {
                 groupName = "p" + i;
                 regex.append(
                   RegexBuilder.create().optionalGroup(
                     RegexBuilder.create()
                       .escapeCharacter(".").zeroOrOne().quote(entry.getKey()).append("=")
                       .namedGroup(groupName,
                         RegexBuilder.create().notCharactersClass(
-                          "!",	"*",	"'", "(",	")",	";",	"@",	"&",	"+",	"$",	"/",	"?",	"#",	"[",	"]", ".", "="
+                          "!",	"*",	"'", "(",	")",	";",	":",	"@",	"&",	"+",	"$",	"/",	"?",	"#",	"[",	"]", ".", "="
                         ).zeroOrMore()
                       )
                   )
                 );
                 mappedGroups.put(groupName, entry.getKey());
                 i++;
               }
             } else {
               regex.append(
                 RegexBuilder.create()
                   .escapeCharacter(".").zeroOrOne()
                   .namedGroup(groupName,
                     RegexBuilder.create().notCharactersClass(
-                      "!",	"*",	"'",	"(",	")",	";",	"@",	"&",	"=",	"+",	"$",	",",	"/",	"?",	"#",	"[",	"]"
+                      "!",	"*",	"'",	"(",	")",	";",	":",	"@",	"&",	"=",	"+",	"$",	",",	"/",	"?",	"#",	"[",	"]"
                     ).zeroOrMore()
                   ).zeroOrOne()
               );
               mappedGroups.put(groupName, paramName);
             }
           } else if (style.equals("matrix")) {
             if (isObject && explode) {
               Map<String, OpenApi3Utils.ObjectField> properties = OpenApi3Utils.solveObjectParameters(parameter.getSchema());
               for (Map.Entry<String, OpenApi3Utils.ObjectField> entry : properties.entrySet()) {
                 groupName = "p" + i;
                 regex.append(
                   RegexBuilder.create().optionalGroup(
                     RegexBuilder.create()
                       .escapeCharacter(";").quote(entry.getKey()).append("=")
                       .namedGroup(groupName,
                         RegexBuilder.create().notCharactersClass(
-                          "!",	"*",	"'",	"(",	")",	";",	"@",	"&",	"=",	"+",	"$",	",",	"/",	"?",	"#",	"[",	"]",
+                          "!",	"*",	"'",	"(",	")",	";",	":",	"@",	"&",	"=",	"+",	"$",	",",	"/",	"?",	"#",	"[",	"]",
                           (shouldThreatDotAsReserved) ? "." : null
                         ).zeroOrMore()
                       )
                   )
                 );
                 mappedGroups.put(groupName, entry.getKey());
                 i++;
               }
             } else if (isArray && explode) {
               regex.append(
                 RegexBuilder.create().namedGroup(
                   groupName,
                   RegexBuilder.create().atomicGroup(
                     RegexBuilder.create()
                       .append(";").quote(paramName).append("=")
                       .notCharactersClass(
-                        "!",	"*",	"'",	"(",	")",	";",	"@",	"&",	"=",	"+",	"$",	",",	"/",	"?",	"#",	"[",	"]",
+                        "!",	"*",	"'",	"(",	")",	";",	":",	"@",	"&",	"=",	"+",	"$",	",",	"/",	"?",	"#",	"[",	"]",
                         (shouldThreatDotAsReserved) ? "." : null
                     ).zeroOrMore()
                   ).oneOrMore()
                 )
               );
               mappedGroups.put(groupName, paramName);
             } else {
               regex.append(
                 RegexBuilder.create()
                   .append(";").quote(paramName).append("=")
                   .namedGroup(
                     groupName,
                     RegexBuilder.create().notCharactersClass(
-                      "!",	"*",	"'",	"(",	")",	";",	"@",	"&",	"=",	"+",	"$",	"/",	"?",	"#",	"[",	"]",
+                      "!",	"*",	"'",	"(",	")",	";",	":",	"@",	"&",	"=",	"+",	"$",	"/",	"?",	"#",	"[",	"]",
                       (shouldThreatDotAsReserved) ? "." : null
                     ).zeroOrMore()
                   ).zeroOrOne()
               );
               mappedGroups.put(groupName, paramName);
             }
           }
         } else {
           throw RouterFactoryException.createSpecInvalidException("Missing parameter description for parameter name: " + paramName);
         }

--- a/vertx-web-api-contract/src/main/java/io/vertx/ext/web/api/contract/openapi3/impl/OpenAPI3RouterFactoryImpl.java
+++ b/vertx-web-api-contract/src/main/java/io/vertx/ext/web/api/contract/openapi3/impl/OpenAPI3RouterFactoryImpl.java
@@ -170,28 +170,25 @@
     for (Handler<RoutingContext> globalHandler: globalHandlers) {
       globalRoute.handler(globalHandler);
     }
     List<Handler<RoutingContext>> globalSecurityHandlers = securityHandlers
       .solveSecurityHandlers(spec.getSecurity(), this.getOptions().isRequireSecurityHandlers());
     for (OperationValue operation : operations.values()) {
       if (!options.isMountNotImplementedHandler() && !operation.isConfigured())
         continue;
       List<Handler> handlersToLoad = new ArrayList<>();
       List<Handler> failureHandlersToLoad = new ArrayList<>();
-      if (operation.getOperationModel().getSecurity() != null) {
-        handlersToLoad.addAll(securityHandlers.solveSecurityHandlers(
-          operation.getOperationModel().getSecurity(),
-          this.getOptions().isRequireSecurityHandlers()
-        ));
-      } else {
-        handlersToLoad.addAll(globalSecurityHandlers);
-      }
+      handlersToLoad.addAll(globalSecurityHandlers);
+      handlersToLoad.addAll(securityHandlers.solveSecurityHandlers(
+        operation.getOperationModel().getSecurity(),
+        this.getOptions().isRequireSecurityHandlers()
+      ));
       Handler<RoutingContext> validationHandler = new OpenAPI3RequestValidationHandlerImpl(operation
         .getOperationModel(), operation.getParameters(), this.spec, refsCache);
       handlersToLoad.add(validationHandler);
       if (this.options.isMountValidationFailureHandler()) failureHandlersToLoad.add(this.options.getValidationFailureHandler());
       if (operation.isConfigured()) {
         handlersToLoad.addAll(operation.getUserHandlers());
         failureHandlersToLoad.addAll(operation.getUserFailureHandlers());
       } else {
         handlersToLoad.add(this.options.getNotImplementedFailureHandler());
       }

--- a/vertx-web-api-contract/src/main/java/io/vertx/ext/web/api/validation/impl/RegularExpressions.java
+++ b/vertx-web-api-contract/src/main/java/io/vertx/ext/web/api/validation/impl/RegularExpressions.java
@@ -2,21 +2,21 @@
 /**
  * @author Francesco Guardiani @slinkydeveloper
  */
 public class RegularExpressions {
   public static final String EMAIL = "^(?:[\\w!#\\$%&'\\*\\+\\-/=\\?\\^`\\{\\|\\}~]+\\.)" +
     "*[\\w!#\\$%&'\\*\\+\\-/=\\?\\^`\\{\\|\\}~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!\\.)){0,61}[a-zA-Z0-9]?\\.)"
     + "+[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\\[(?:(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\.){3}" +
     "(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\]))$";
   public static final String URI = "^[a-zA-Z][a-zA-Z0-9+-.]*:[^\\s]*$";
   public static final String DATE = "^\\d{4}-(?:0[0-9]|1[0-2])-[0-9]{2}$";
-  public static final String DATETIME = "^\\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])T([01]\\d|2[0-3]):([0-5]\\d):([0-5]\\d|60)(\\.\\d+)?(Z|(\\+|-)([01]\\d|2[0-3]):([0-5]\\d))$";
+  public static final String DATETIME = "^\\d{4}-(?:0[0-9]|1[0-2])-[0-9]{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d{3})?Z$";
   public static final String TIME = "^\\d{2}:\\d{2}:\\d{2}$";
   public static final String BASE64 = "^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{4}|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)$";
   public static final String IPV4 = "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}" + "" +
     "(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";
   public static final String IPV6 = "^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}" + "" +
     "(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(" +
     "([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\." + "" +
     "(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|(" + "" +
     "(:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|" +
     "(" + "([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:(" + "" +

--- a/vertx-web/src/main/java/io/vertx/ext/web/handler/impl/CSRFHandlerImpl.java
+++ b/vertx-web/src/main/java/io/vertx/ext/web/handler/impl/CSRFHandlerImpl.java
@@ -80,22 +80,22 @@
     this.responseBody = responseBody;
     return this;
   }
   private String generateToken() {
     byte[] salt = new byte[32];
     RAND.nextBytes(salt);
     String saltPlusToken = BASE64.encodeToString(salt) + "." + Long.toString(System.currentTimeMillis());
     String signature = BASE64.encodeToString(mac.doFinal(saltPlusToken.getBytes()));
     return saltPlusToken + "." + signature;
   }
-  private boolean validateToken(String header, Cookie cookie) {
-    if (header == null || cookie == null || !header.equals(cookie.getValue())) {
+  private boolean validateToken(String header) {
+    if (header == null) {
       return false;
     }
     String[] tokens = header.split("\\.");
     if (tokens.length != 3) {
       return false;
     }
     String saltPlusToken = tokens[0] + "." + tokens[1];
     String signature = BASE64.encodeToString(mac.doFinal(saltPlusToken.getBytes()));
     if(!signature.equals(tokens[2])) {
       return false;
@@ -130,22 +130,21 @@
         final String token = generateToken();
         ctx.put(headerName, token);
         ctx.addCookie(Cookie.cookie(cookieName, token).setPath(cookiePath));
         ctx.next();
         break;
       case POST:
       case PUT:
       case DELETE:
       case PATCH:
         final String header = ctx.request().getHeader(headerName);
-        final Cookie cookie = ctx.getCookie(cookieName);
-        if (validateToken(header == null ? ctx.request().getFormAttribute(headerName) : header, cookie)) {
+        if (validateToken(header == null ? ctx.request().getFormAttribute(headerName) : header)) {
           ctx.next();
         } else {
           forbidden(ctx);
         }
         break;
       default:
         ctx.next();
         break;
     }
   }
