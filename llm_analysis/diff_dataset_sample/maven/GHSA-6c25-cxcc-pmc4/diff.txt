--- a/docs/js/version.js
+++ b/docs/js/version.js
@@ -1 +1 @@
-var version = '5.8.21'
+var version = '5.8.20'

--- a/hutool-core/src/main/java/cn/hutool/core/bean/BeanUtil.java
+++ b/hutool-core/src/main/java/cn/hutool/core/bean/BeanUtil.java
@@ -895,24 +895,22 @@
 	 * @author Takak11
 	 * @since 5.8.4
 	 */
 	public static boolean isCommonFieldsEqual(Object source, Object target, String... ignoreProperties) {
 		if (null == source && null == target) {
 			return true;
 		}
 		if (null == source || null == target) {
 			return false;
 		}
-		final Map<String, Object> sourceFieldsMap = BeanUtil.beanToMap(source);
-		final Map<String, Object> targetFieldsMap = BeanUtil.beanToMap(target);
-		final Set<String> sourceFields = sourceFieldsMap.keySet();
+		Map<String, Object> sourceFieldsMap = BeanUtil.beanToMap(source);
+		Map<String, Object> targetFieldsMap = BeanUtil.beanToMap(target);
+		Set<String> sourceFields = sourceFieldsMap.keySet();
 		sourceFields.removeAll(Arrays.asList(ignoreProperties));
 		for (String field : sourceFields) {
-			if(sourceFieldsMap.containsKey(field) && targetFieldsMap.containsKey(field)){
-				if (ObjectUtil.notEqual(sourceFieldsMap.get(field), targetFieldsMap.get(field))) {
-					return false;
-				}
+			if (ObjectUtil.notEqual(sourceFieldsMap.get(field), targetFieldsMap.get(field))) {
+				return false;
 			}
 		}
 		return true;
 	}
 }

--- a/hutool-core/src/main/java/cn/hutool/core/collection/CollUtil.java
+++ b/hutool-core/src/main/java/cn/hutool/core/collection/CollUtil.java
@@ -2634,33 +2634,33 @@
 	/**
 	 * 取最大值
 	 *
 	 * @param <T>  元素类型
 	 * @param coll 集合
 	 * @return 最大值
 	 * @see Collections#max(Collection)
 	 * @since 4.6.5
 	 */
 	public static <T extends Comparable<? super T>> T max(Collection<T> coll) {
-		return isEmpty(coll) ? null : Collections.max(coll);
+		return Collections.max(coll);
 	}
 	/**
 	 * 取最小值
 	 *
 	 * @param <T>  元素类型
 	 * @param coll 集合
 	 * @return 最小值
 	 * @see Collections#min(Collection)
 	 * @since 4.6.5
 	 */
 	public static <T extends Comparable<? super T>> T min(Collection<T> coll) {
-		return isEmpty(coll) ? null : Collections.min(coll);
+		return Collections.min(coll);
 	}
 	/**
 	 * 转为只读集合
 	 *
 	 * @param <T> 元素类型
 	 * @param c   集合
 	 * @return 只读集合
 	 * @since 5.2.6
 	 */
 	public static <T> Collection<T> unmodifiable(Collection<? extends T> c) {

--- a/hutool-core/src/main/java/cn/hutool/core/comparator/VersionComparator.java
+++ b/hutool-core/src/main/java/cn/hutool/core/comparator/VersionComparator.java
@@ -1,16 +1,13 @@
 package cn.hutool.core.comparator;
-import cn.hutool.core.convert.Convert;
-import cn.hutool.core.lang.PatternPool;
 import cn.hutool.core.util.CharUtil;
 import cn.hutool.core.util.ObjectUtil;
-import cn.hutool.core.util.ReUtil;
 import cn.hutool.core.util.StrUtil;
 import java.io.Serializable;
 import java.util.Comparator;
 import java.util.List;
 /**
  * 版本比较器<br>
  * 比较两个版本的大小<br>
  * 排序时版本从小到大排序，即比较时小版本在前，大版本在后<br>
  * 支持如：1.3.20.8，6.82.20160101，8.5a/8.5c等版本形式<br>
  * 参考：https://www.cnblogs.com/shihaiming/p/6286575.html
@@ -30,21 +27,20 @@
 	/**
 	 * 比较两个版本<br>
 	 * null版本排在最小：即：
 	 * <pre>
 	 * compare(null, "v1") &lt; 0
 	 * compare("v1", "v1")  = 0
 	 * compare(null, null)   = 0
 	 * compare("v1", null) &gt; 0
 	 * compare("1.0.0", "1.0.2") &lt; 0
 	 * compare("1.0.2", "1.0.2a") &lt; 0
-	 * compare("1.0.3", "1.0.2a") &gt; 0
 	 * compare("1.13.0", "1.12.1c") &gt; 0
 	 * compare("V0.0.20170102", "V0.0.20170101") &gt; 0
 	 * </pre>
 	 *
 	 * @param version1 版本1
 	 * @param version2 版本2
 	 */
 	@Override
 	public int compare(String version1, String version2) {
 		if(ObjectUtil.equal(version1, version2)) {
@@ -62,25 +58,18 @@
 		int diff = 0;
 		int minLength = Math.min(v1s.size(), v2s.size());// 取最小长度值
 		String v1;
 		String v2;
 		for (int i = 0; i < minLength; i++) {
 			v1 = v1s.get(i);
 			v2 = v2s.get(i);
 			diff = v1.length() - v2.length();
 			if (0 == diff) {
 				diff = v1.compareTo(v2);
-			}else {
-				int v1Num = Convert.toInt(ReUtil.get(PatternPool.NUMBERS, v1, 0), 0);
-				int v2Num = Convert.toInt(ReUtil.get(PatternPool.NUMBERS, v2, 0), 0);
-				int diff1 = v1Num - v2Num;
-				if (diff1 != 0) {
-					diff = diff1;
-				}
 			}
 			if(diff != 0) {
 				break;
 			}
 		}
 		return (diff != 0) ? diff : v1s.size() - v2s.size();
 	}
 }

--- a/hutool-core/src/main/java/cn/hutool/core/compress/ZipReader.java
+++ b/hutool-core/src/main/java/cn/hutool/core/compress/ZipReader.java
@@ -16,28 +16,24 @@
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 import java.util.zip.ZipInputStream;
 /**
  * Zip文件或流读取器，一般用于Zip文件解压
  *
  * @author looly
  * @since 5.7.8
  */
 public class ZipReader implements Closeable {
-	private static final int DEFAULT_MAX_SIZE_DIFF = 100;
+	private static final int MAX_SIZE_DIFF = 100;
 	private ZipFile zipFile;
 	private ZipInputStream in;
 	/**
-	 * 检查ZipBomb文件差异倍数，-1表示不检查ZipBomb
-	 */
-	private int maxSizeDiff = DEFAULT_MAX_SIZE_DIFF;
-	/**
 	 * 创建ZipReader
 	 *
 	 * @param zipFile 生成的Zip文件
 	 * @param charset 编码
 	 * @return ZipReader
 	 */
 	public static ZipReader of(File zipFile, Charset charset) {
 		return new ZipReader(zipFile, charset);
 	}
 	/**
@@ -76,31 +72,20 @@
 	public ZipReader(InputStream in, Charset charset) {
 		this.in = new ZipInputStream(in, charset);
 	}
 	/**
 	 * 构造
 	 *
 	 * @param zin 读取的的Zip文件流
 	 */
 	public ZipReader(ZipInputStream zin) {
 		this.in = zin;
-	}
-	/**
-	 * 设置检查ZipBomb文件差异倍数，-1表示不检查ZipBomb
-	 *
-	 * @param maxSizeDiff 检查ZipBomb文件差异倍数，-1表示不检查ZipBomb
-	 * @return this
-	 * @since 6.0.0
-	 */
-	public ZipReader setMaxSizeDiff(final int maxSizeDiff) {
-		this.maxSizeDiff = maxSizeDiff;
-		return this;
 	}
 	/**
 	 * 获取指定路径的文件流<br>
 	 * 如果是文件模式，则直接获取Entry对应的流，如果是流模式，则遍历entry后，找到对应流返回
 	 *
 	 * @param path 路径
 	 * @return 文件流
 	 */
 	public InputStream get(String path) {
 		if (null != this.zipFile) {
@@ -215,27 +200,24 @@
 		} catch (IOException e) {
 			throw new IORuntimeException(e);
 		}
 	}
 	/**
 	 * 检查Zip bomb漏洞
 	 *
 	 * @param entry {@link ZipEntry}
 	 * @return 检查后的{@link ZipEntry}
 	 */
-	private ZipEntry checkZipBomb(ZipEntry entry) {
-		if(maxSizeDiff < 0){
-			return entry;
-		}
+	private static ZipEntry checkZipBomb(ZipEntry entry) {
 		if (null == entry) {
 			return null;
 		}
 		final long compressedSize = entry.getCompressedSize();
 		final long uncompressedSize = entry.getSize();
 		if (compressedSize < 0 || uncompressedSize < 0 ||
-				compressedSize * maxSizeDiff < uncompressedSize) {
+				compressedSize * MAX_SIZE_DIFF < uncompressedSize) {
 			throw new UtilException("Zip bomb attack detected, invalid sizes: compressed {}, uncompressed {}, name {}",
 					compressedSize, uncompressedSize, entry.getName());
 		}
 		return entry;
 	}
 }

--- a/hutool-core/src/main/java/cn/hutool/core/convert/ConverterRegistry.java
+++ b/hutool-core/src/main/java/cn/hutool/core/convert/ConverterRegistry.java
@@ -1,15 +1,14 @@
 package cn.hutool.core.convert;
 import cn.hutool.core.bean.BeanUtil;
 import cn.hutool.core.convert.impl.*;
 import cn.hutool.core.date.DateTime;
-import cn.hutool.core.lang.Console;
 import cn.hutool.core.lang.Opt;
 import cn.hutool.core.lang.Pair;
 import cn.hutool.core.lang.TypeReference;
 import cn.hutool.core.map.SafeConcurrentHashMap;
 import cn.hutool.core.util.*;
 import java.io.Serializable;
 import java.lang.ref.SoftReference;
 import java.lang.ref.WeakReference;
 import java.lang.reflect.Type;
 import java.math.BigDecimal;
@@ -31,21 +30,21 @@
  * 在此类中，存放着默认转换器和自定义转换器，默认转换器是Hutool中预定义的一些转换器，自定义转换器存放用户自定的转换器。
  * </p>
  *
  * @author Looly
  */
 public class ConverterRegistry implements Serializable {
 	private static final long serialVersionUID = 1L;
 	/**
 	 * 默认类型转换器
 	 */
-	private Map<Class<?>, Converter<?>> defaultConverterMap;
+	private Map<Type, Converter<?>> defaultConverterMap;
 	/**
 	 * 用户自定义类型转换器
 	 */
 	private volatile Map<Type, Converter<?>> customConverterMap;
 	/**
 	 * 类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例 没有绑定关系，而且只有被调用到才会装载，从而实现了延迟加载
 	 */
 	private static class SingletonHolder {
 		/**
 		 * 静态初始化器，由JVM来保证线程安全
@@ -134,21 +133,21 @@
 	}
 	/**
 	 * 获得默认转换器
 	 *
 	 * @param <T>  转换的目标类型（转换器转换到的类型）
 	 * @param type 类型
 	 * @return 转换器
 	 */
 	@SuppressWarnings("unchecked")
 	public <T> Converter<T> getDefaultConverter(Type type) {
-		return (null == defaultConverterMap) ? null : (Converter<T>) defaultConverterMap.get(TypeUtil.getClass(type));
+		return (null == defaultConverterMap) ? null : (Converter<T>) defaultConverterMap.get(type);
 	}
 	/**
 	 * 获得自定义转换器
 	 *
 	 * @param <T>  转换的目标类型（转换器转换到的类型）
 	 * @param type 类型
 	 * @return 转换器
 	 */
 	@SuppressWarnings("unchecked")
 	public <T> Converter<T> getCustomConverter(Type type) {
@@ -265,24 +264,20 @@
 		}
 		if (rowType.isInstance(value)) {
 			return (T) value;
 		}
 		if (rowType.isEnum()) {
 			return (T) new EnumConverter(rowType).convert(value, defaultValue);
 		}
 		if (rowType.isArray()) {
 			final ArrayConverter arrayConverter = new ArrayConverter(rowType);
 			return (T) arrayConverter.convert(value, defaultValue);
-		}
-		if("java.lang.Class".equals(rowType.getName())){
-			final ClassConverter converter = new ClassConverter();
-			return (T) converter.convert(value, (Class<?>) defaultValue);
 		}
 		return null;
 	}
 	/**
 	 * 注册默认转换器
 	 *
 	 * @return 转换器
 	 */
 	private ConverterRegistry defaultConverter() {
 		defaultConverterMap = new SafeConcurrentHashMap<>();
@@ -331,20 +326,21 @@
 		defaultConverterMap.put(DayOfWeek.class, new TemporalAccessorConverter(DayOfWeek.class));
 		defaultConverterMap.put(Month.class, new TemporalAccessorConverter(Month.class));
 		defaultConverterMap.put(MonthDay.class, new TemporalAccessorConverter(MonthDay.class));
 		defaultConverterMap.put(Period.class, new PeriodConverter());
 		defaultConverterMap.put(Duration.class, new DurationConverter());
 		defaultConverterMap.put(WeakReference.class, new ReferenceConverter(WeakReference.class));// since 3.0.8
 		defaultConverterMap.put(SoftReference.class, new ReferenceConverter(SoftReference.class));// since 3.0.8
 		defaultConverterMap.put(AtomicReference.class, new AtomicReferenceConverter());// since 3.0.8
 		defaultConverterMap.put(AtomicIntegerArray.class, new AtomicIntegerArrayConverter());
 		defaultConverterMap.put(AtomicLongArray.class, new AtomicLongArrayConverter());
+		defaultConverterMap.put(Class.class, new ClassConverter());
 		defaultConverterMap.put(TimeZone.class, new TimeZoneConverter());
 		defaultConverterMap.put(Locale.class, new LocaleConverter());
 		defaultConverterMap.put(Charset.class, new CharsetConverter());
 		defaultConverterMap.put(Path.class, new PathConverter());
 		defaultConverterMap.put(Currency.class, new CurrencyConverter());// since 3.0.8
 		defaultConverterMap.put(UUID.class, new UUIDConverter());// since 4.0.10
 		defaultConverterMap.put(StackTraceElement.class, new StackTraceElementConverter());// since 4.5.2
 		defaultConverterMap.put(Optional.class, new OptionalConverter());// since 5.0.0
 		defaultConverterMap.put(Opt.class, new OptConverter());// since 5.7.16
 		defaultConverterMap.put(Pair.class, new PairConverter(Pair.class));// since 5.8.17

--- a/hutool-core/src/main/java/cn/hutool/core/convert/impl/BeanConverter.java
+++ b/hutool-core/src/main/java/cn/hutool/core/convert/impl/BeanConverter.java
@@ -1,18 +1,17 @@
 package cn.hutool.core.convert.impl;
 import cn.hutool.core.bean.BeanUtil;
 import cn.hutool.core.bean.copier.BeanCopier;
 import cn.hutool.core.bean.copier.CopyOptions;
 import cn.hutool.core.bean.copier.ValueProvider;
 import cn.hutool.core.convert.AbstractConverter;
 import cn.hutool.core.convert.ConvertException;
-import cn.hutool.core.lang.Console;
 import cn.hutool.core.map.MapProxy;
 import cn.hutool.core.util.ObjectUtil;
 import cn.hutool.core.util.ReflectUtil;
 import cn.hutool.core.util.StrUtil;
 import cn.hutool.core.util.TypeUtil;
 import java.lang.reflect.Type;
 import java.util.Map;
 /**
  * Bean转换器，支持：
  * <pre>
@@ -53,28 +52,20 @@
 	 * @param copyOptions Bean转换选项参数
 	 */
 	@SuppressWarnings("unchecked")
 	public BeanConverter(Type beanType, CopyOptions copyOptions) {
 		this.beanType = beanType;
 		this.beanClass = (Class<T>) TypeUtil.getClass(beanType);
 		this.copyOptions = copyOptions;
 	}
 	@Override
 	protected T convertInternal(Object value) {
-		final Class<?>[] interfaces = this.beanClass.getInterfaces();
-		for (Class<?> anInterface : interfaces) {
-			if("cn.hutool.json.JSONBeanParser".equals(anInterface.getName())){
-				final T obj = ReflectUtil.newInstanceIfPossible(this.beanClass);
-				ReflectUtil.invoke(obj, "parse", value);
-				return obj;
-			}
-		}
 		if(value instanceof Map ||
 				value instanceof ValueProvider ||
 				BeanUtil.isBean(value.getClass())) {
 			if(value instanceof Map && this.beanClass.isInterface()) {
 				return MapProxy.create((Map<?, ?>)value).toProxyBean(this.beanClass);
 			}
 			return BeanCopier.create(value, ReflectUtil.newInstanceIfPossible(this.beanClass), this.beanType, this.copyOptions).copy();
 		} else if(value instanceof byte[]){
 			return ObjectUtil.deserialize((byte[])value);
 		} else if(StrUtil.isEmptyIfStr(value)){

--- a/hutool-core/src/main/java/cn/hutool/core/date/DateUtil.java
+++ b/hutool-core/src/main/java/cn/hutool/core/date/DateUtil.java
@@ -756,21 +756,21 @@
 	public static DateTime parseUTC(String utcString) {
 		if (utcString == null) {
 			return null;
 		}
 		final int length = utcString.length();
 		if (StrUtil.contains(utcString, 'Z')) {
 			if (length == DatePattern.UTC_PATTERN.length() - 4) {
 				return parse(utcString, DatePattern.UTC_FORMAT);
 			}
 			final int patternLength = DatePattern.UTC_MS_PATTERN.length();
-			if (length <= patternLength && length >= patternLength - 6) {
+			if (length <= patternLength - 4 && length >= patternLength - 6) {
 				return parse(utcString, DatePattern.UTC_MS_FORMAT);
 			}
 		} else if (StrUtil.contains(utcString, '+')) {
 			utcString = utcString.replace(" +", "+");
 			final String zoneOffset = StrUtil.subAfter(utcString, '+', true);
 			if (StrUtil.isBlank(zoneOffset)) {
 				throw new DateException("Invalid format: [{}]", utcString);
 			}
 			if (false == StrUtil.contains(zoneOffset, ':')) {
 				final String pre = StrUtil.subBefore(utcString, '+', true);

--- a/hutool-core/src/main/java/cn/hutool/core/io/FileTypeUtil.java
+++ b/hutool-core/src/main/java/cn/hutool/core/io/FileTypeUtil.java
@@ -62,65 +62,65 @@
 	 * @param in 文件流
 	 * @param fileHeadSize 自定义读取文件头部的大小
 	 * @return 文件类型，未找到为{@code null}
 	 */
 	public static String getType(InputStream in,int fileHeadSize) throws IORuntimeException  {
 		return getType((IoUtil.readHex(in, fileHeadSize,false)));
 	}
 	/**
 	 * 根据文件流的头部信息获得文件类型<br>
 	 * 注意此方法会读取头部一些bytes，造成此流接下来读取时缺少部分bytes<br>
-	 * 因此如果想复用此流，流需支持{@link InputStream#reset()}方法。
+	 * 因此如果想服用此流，流需支持{@link InputStream#reset()}方法。
 	 * @param in {@link InputStream}
 	 * @param isExact 是否精确匹配，如果为false，使用前64个bytes匹配，如果为true，使用前8192bytes匹配
 	 * @return 类型，文件的扩展名，未找到为{@code null}
 	 * @throws IORuntimeException  读取流引起的异常
 	 */
 	public static String getType(InputStream in,boolean isExact) throws  IORuntimeException  {
 		return isExact
 				?getType(IoUtil.readHex8192Upper(in))
 				:getType(IoUtil.readHex64Upper(in));
 	}
 	/**
 	 * 根据文件流的头部信息获得文件类型<br>
 	 * 注意此方法会读取头部64个bytes，造成此流接下来读取时缺少部分bytes<br>
-	 * 因此如果想复用此流，流需支持{@link InputStream#reset()}方法。
+	 * 因此如果想服用此流，流需支持{@link InputStream#reset()}方法。
 	 * @param in {@link InputStream}
 	 * @return 类型，文件的扩展名，未找到为{@code null}
 	 * @throws IORuntimeException  读取流引起的异常
 	 */
 	public static String getType(InputStream in) throws IORuntimeException  {
 		return getType(in,false);
 	}
 	/**
 	 * 根据文件流的头部信息获得文件类型
 	 * 注意此方法会读取头部64个bytes，造成此流接下来读取时缺少部分bytes<br>
-	 * 因此如果想复用此流，流需支持{@link InputStream#reset()}方法。
+	 * 因此如果想服用此流，流需支持{@link InputStream#reset()}方法。
 	 *
 	 * <pre>
 	 *     1、无法识别类型默认按照扩展名识别
 	 *     2、xls、doc、msi头信息无法区分，按照扩展名区分
 	 *     3、zip可能为docx、xlsx、pptx、jar、war、ofd头信息无法区分，按照扩展名区分
 	 * </pre>
 	 *
 	 * @param in       {@link InputStream}
 	 * @param filename 文件名
 	 * @return 类型，文件的扩展名，未找到为{@code null}
 	 * @throws IORuntimeException  读取流引起的异常
 	 */
 	public static String getType(InputStream in, String filename) throws IORuntimeException  {
 		return getType(in,filename,false);
 	}
 	/**
 	 * 根据文件流的头部信息获得文件类型
 	 * 注意此方法会读取头部一些bytes，造成此流接下来读取时缺少部分bytes<br>
-	 * 因此如果想复用此流，流需支持{@link InputStream#reset()}方法。
+	 * 因此如果想服用此流，流需支持{@link InputStream#reset()}方法。
 	 *
 	 * <pre>
 	 *     1、无法识别类型默认按照扩展名识别
 	 *     2、xls、doc、msi头信息无法区分，按照扩展名区分
 	 *     3、zip可能为docx、xlsx、pptx、jar、war、ofd头信息无法区分，按照扩展名区分
 	 * </pre>
 	 * @param in       {@link InputStream}
 	 * @param filename 文件名
 	 * @param isExact 是否精确匹配，如果为false，使用前64个bytes匹配，如果为true，使用前8192bytes匹配
 	 * @return 类型，文件的扩展名，未找到为{@code null}

--- a/hutool-core/src/main/java/cn/hutool/core/io/file/PathUtil.java
+++ b/hutool-core/src/main/java/cn/hutool/core/io/file/PathUtil.java
@@ -563,22 +563,22 @@
 	 * 获得文件的MimeType
 	 *
 	 * @param file 文件
 	 * @return MimeType
 	 * @see Files#probeContentType(Path)
 	 * @since 5.5.5
 	 */
 	public static String getMimeType(Path file) {
 		try {
 			return Files.probeContentType(file);
-		} catch (IOException ignore) {
-			return null;
+		} catch (IOException e) {
+			throw new IORuntimeException(e);
 		}
 	}
 	/**
 	 * 创建所给目录及其父目录
 	 *
 	 * @param dir 目录
 	 * @return 目录
 	 * @since 5.5.7
 	 */
 	public static Path mkdir(Path dir) {

--- a/hutool-core/src/main/java/cn/hutool/core/io/resource/UrlResource.java
+++ b/hutool-core/src/main/java/cn/hutool/core/io/resource/UrlResource.java
@@ -1,19 +1,19 @@
 package cn.hutool.core.io.resource;
 import cn.hutool.core.io.FileUtil;
-import cn.hutool.core.io.IORuntimeException;
 import cn.hutool.core.util.ObjectUtil;
 import cn.hutool.core.util.URLUtil;
-import java.io.*;
+import java.io.File;
+import java.io.InputStream;
+import java.io.Serializable;
 import java.net.URI;
 import java.net.URL;
-import java.net.URLConnection;
 /**
  * URL资源访问类
  * @author Looly
  *
  */
 public class UrlResource implements Resource, Serializable{
 	private static final long serialVersionUID = 1L;
 	protected URL url;
 	private long lastModified = 0;
 	protected String name;
@@ -80,20 +80,11 @@
 		return FileUtil.file(this.url);
 	}
 	/**
 	 * 返回路径
 	 * @return 返回URL路径
 	 */
 	@Override
 	public String toString() {
 		return (null == this.url) ? "null" : this.url.toString();
 	}
-	/**
-	 * 获取资源长度
-	 *
-	 * @return 资源长度
-	 * @since 5.8.21
-	 */
-	public long size() {
-		return URLUtil.size(this.url);
-	}
 }

--- a/hutool-core/src/main/java/cn/hutool/core/map/MapUtil.java
+++ b/hutool-core/src/main/java/cn/hutool/core/map/MapUtil.java
@@ -1,15 +1,18 @@
 package cn.hutool.core.map;
 import cn.hutool.core.collection.CollUtil;
 import cn.hutool.core.convert.Convert;
 import cn.hutool.core.exceptions.UtilException;
-import cn.hutool.core.lang.*;
+import cn.hutool.core.lang.Editor;
+import cn.hutool.core.lang.Filter;
+import cn.hutool.core.lang.Pair;
+import cn.hutool.core.lang.TypeReference;
 import cn.hutool.core.stream.CollectorUtil;
 import cn.hutool.core.util.ArrayUtil;
 import cn.hutool.core.util.JdkUtil;
 import cn.hutool.core.util.ReflectUtil;
 import cn.hutool.core.util.StrUtil;
 import java.util.AbstractMap;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.Date;
@@ -626,23 +629,20 @@
 		if (null == map || null == editor) {
 			return map;
 		}
 		Map<K, V> map2 = ReflectUtil.newInstanceIfPossible(map.getClass());
 		if (null == map2) {
 			map2 = new HashMap<>(map.size(), 1f);
 		}
 		if (isEmpty(map)) {
 			return map2;
 		}
-		if(false == map2.isEmpty()){
-			map2.clear();
-		}
 		Entry<K, V> modified;
 		for (Entry<K, V> entry : map.entrySet()) {
 			modified = editor.edit(entry);
 			if (null != modified) {
 				map2.put(modified.getKey(), modified.getValue());
 			}
 		}
 		return map2;
 	}
 	/**
@@ -698,23 +698,20 @@
 	public static <K, V> Map<K, V> filter(Map<K, V> map, K... keys) {
 		if (null == map || null == keys) {
 			return map;
 		}
 		Map<K, V> map2 = ReflectUtil.newInstanceIfPossible(map.getClass());
 		if (null == map2) {
 			map2 = new HashMap<>(map.size(), 1f);
 		}
 		if (isEmpty(map)) {
 			return map2;
-		}
-		if(false == map2.isEmpty()){
-			map2.clear();
 		}
 		for (K key : keys) {
 			if (map.containsKey(key)) {
 				map2.put(key, map.get(key));
 			}
 		}
 		return map2;
 	}
 	/**
 	 * Map的键和值互换

--- a/hutool-core/src/main/java/cn/hutool/core/math/Calculator.java
+++ b/hutool-core/src/main/java/cn/hutool/core/math/Calculator.java
@@ -1,11 +1,12 @@
 package cn.hutool.core.math;
+import cn.hutool.core.lang.Console;
 import cn.hutool.core.util.NumberUtil;
 import cn.hutool.core.util.StrUtil;
 import java.math.BigDecimal;
 import java.util.Collections;
 import java.util.Stack;
 /**
  * 数学表达式计算工具类<br>
  * 见：https://github.com/dromara/hutool/issues/1090#issuecomment-693750140
  *
  * @author trainliang, looly

--- a/hutool-core/src/main/java/cn/hutool/core/net/Ipv4Util.java
+++ b/hutool-core/src/main/java/cn/hutool/core/net/Ipv4Util.java
@@ -1,18 +1,17 @@
 package cn.hutool.core.net;
 import cn.hutool.core.collection.ListUtil;
 import cn.hutool.core.convert.Convert;
 import cn.hutool.core.lang.Assert;
 import cn.hutool.core.lang.PatternPool;
 import cn.hutool.core.lang.Validator;
 import cn.hutool.core.util.CharUtil;
-import cn.hutool.core.util.ReUtil;
 import cn.hutool.core.util.StrUtil;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Objects;
 import java.util.regex.Matcher;
 /**
  * IPV4地址工具类
  *
  * <p>pr自：https://gitee.com/loolly/hutool/pulls/161</p>
  *
@@ -311,44 +310,20 @@
 		long aBegin = ipv4ToLong("10.0.0.0");
 		long aEnd = ipv4ToLong("10.255.255.255");
 		long bBegin = ipv4ToLong("172.16.0.0");
 		long bEnd = ipv4ToLong("172.31.255.255");
 		long cBegin = ipv4ToLong("192.168.0.0");
 		long cEnd = ipv4ToLong("192.168.255.255");
 		isInnerIp = isInner(ipNum, aBegin, aEnd) || isInner(ipNum, bBegin, bEnd) || isInner(ipNum, cBegin, cEnd) || LOCAL_IP.equals(ipAddress);
 		return isInnerIp;
 	}
 	/**
-	 * 检测指定 IP 地址是否匹配通配符 wildcard
-	 *
-	 * @param wildcard   通配符，如 192.168.*.1
-	 * @param ipAddress 待检测的 IP 地址
-	 * @return 是否匹配
-	 */
-	public static boolean matches(String wildcard, String ipAddress) {
-		if (false == ReUtil.isMatch(PatternPool.IPV4, ipAddress)) {
-			return false;
-		}
-		final String[] wildcardSegments = wildcard.split("\\.");
-		final String[] ipSegments = ipAddress.split("\\.");
-		if (wildcardSegments.length != ipSegments.length) {
-			return false;
-		}
-		for (int i = 0; i < wildcardSegments.length; i++) {
-			if (false == "*".equals(wildcardSegments[i])
-				&& false == wildcardSegments[i].equals(ipSegments[i])) {
-				return false;
-			}
-		}
-		return true;
-	}
-	/**
 	 * 根据 ip/掩码位 计算IP段的终止IP（Long型）
 	 * 注：此接口返回负数，请使用转成字符串后再转Long型
 	 *
 	 * @param ip      给定的IP，如218.240.38.69
 	 * @param maskBit 给定的掩码位，如30
 	 * @return 终止IP的长整型表示
 	 */
 	public static Long getEndIpLong(String ip, int maskBit) {
 		return getBeginIpLong(ip, maskBit)
 				+ ~ipv4ToLong(getMaskByMaskBit(maskBit));

--- a/hutool-core/src/main/java/cn/hutool/core/util/DesensitizedUtil.java
+++ b/hutool-core/src/main/java/cn/hutool/core/util/DesensitizedUtil.java
@@ -281,52 +281,46 @@
 			return StrUtil.EMPTY;
 		}
 		if (carLicense.length() == 7) {
 			carLicense = StrUtil.hide(carLicense, 3, 6);
 		} else if (carLicense.length() == 8) {
 			carLicense = StrUtil.hide(carLicense, 3, 7);
 		}
 		return carLicense;
 	}
 	/**
-	 * 【银行卡号脱敏】由于银行卡号长度不定，所以只展示前4位，后面的位数根据卡号决定展示1-4位
-	 *  例如：
-	 *  <pre>{@code
-	 *      1. "1234 2222 3333 4444 6789 9"    ->   "1234 **** **** **** **** 9"
-	 *      2. "1234 2222 3333 4444 6789 91"   ->   "1234 **** **** **** **** 91"
-	 *      3. "1234 2222 3333 4444 678"       ->    "1234 **** **** **** 678"
-	 *      4. "1234 2222 3333 4444 6789"      ->    "1234 **** **** **** 6789"
-	 *  }</pre>
+	 * 银行卡号脱敏
+	 * eg: 1101 **** **** **** 3256
 	 *
 	 * @param bankCardNo 银行卡号
 	 * @return 脱敏之后的银行卡号
+	 * @since 5.6.3
 	 */
 	public static String bankCard(String bankCardNo) {
 		if (StrUtil.isBlank(bankCardNo)) {
 			return bankCardNo;
 		}
-		bankCardNo = StrUtil.cleanBlank(bankCardNo);
+		bankCardNo = StrUtil.trim(bankCardNo);
 		if (bankCardNo.length() < 9) {
 			return bankCardNo;
 		}
 		final int length = bankCardNo.length();
-		final int endLength= length % 4 == 0 ? 4 : length % 4;
-		final int midLength = length - 4 - endLength;
+		final int midLength = length - 8;
 		final StringBuilder buf = new StringBuilder();
 		buf.append(bankCardNo, 0, 4);
 		for (int i = 0; i < midLength; ++i) {
 			if (i % 4 == 0) {
 				buf.append(CharUtil.SPACE);
 			}
 			buf.append('*');
 		}
-		buf.append(CharUtil.SPACE).append(bankCardNo, length - endLength, length);
+		buf.append(CharUtil.SPACE).append(bankCardNo, length - 4, length);
 		return buf.toString();
 	}
 	/**
 	 * IPv4脱敏，如：脱敏前：192.0.2.1；脱敏后：192.*.*.*。
 	 *
 	 * @param ipv4 IPv4地址
 	 * @return 脱敏后的地址
 	 */
 	public static String ipv4(String ipv4) {
 		return StrUtil.subBefore(ipv4, '.', false) + ".*.*.*";

--- a/hutool-core/src/main/java/cn/hutool/core/util/IdcardUtil.java
+++ b/hutool-core/src/main/java/cn/hutool/core/util/IdcardUtil.java
@@ -246,23 +246,20 @@
 	 * <li>余数只可能有0 1 2 3 4 5 6 7 8 9 10这11个数字。其分别对应的最后一位身份证的号码为1 0 X 9 8 7 6 5 4 3 2</li>
 	 * <li>通过上面得知如果余数是2，就会在身份证的第18位数字上出现罗马数字的Ⅹ。如果余数是10，身份证的最后一位号码就是2</li>
 	 * </ol>
 	 *
 	 * @param idcard     待验证的身份证
 	 * @param ignoreCase 是否忽略大小写。{@code true}则忽略X大小写，否则严格匹配大写。
 	 * @return 是否有效的18位身份证
 	 * @since 5.5.7
 	 */
 	public static boolean isValidCard18(String idcard, boolean ignoreCase) {
-		if (idcard == null) {
-			return false;
-		}
 		if (CHINA_ID_MAX_LENGTH != idcard.length()) {
 			return false;
 		}
 		final String proCode = idcard.substring(0, 2);
 		if (null == CITY_CODES.get(proCode)) {
 			return false;
 		}
 		if (false == Validator.isBirthday(idcard.substring(6, 14))) {
 			return false;
 		}
@@ -273,23 +270,20 @@
 		}
 		return false;
 	}
 	/**
 	 * 验证15位身份编码是否合法
 	 *
 	 * @param idcard 身份编码
 	 * @return 是否合法
 	 */
 	public static boolean isValidCard15(String idcard) {
-		if (idcard == null) {
-			return false;
-		}
 		if (CHINA_ID_MIN_LENGTH != idcard.length()) {
 			return false;
 		}
 		if (ReUtil.isMatch(PatternPool.NUMBERS, idcard)) {
 			String proCode = idcard.substring(0, 2);
 			if (null == CITY_CODES.get(proCode)) {
 				return false;
 			}
 			return false != Validator.isBirthday("19" + idcard.substring(6, 12));
 		} else {

--- a/hutool-core/src/main/java/cn/hutool/core/util/RandomUtil.java
+++ b/hutool-core/src/main/java/cn/hutool/core/util/RandomUtil.java
@@ -1,47 +1,50 @@
 package cn.hutool.core.util;
 import cn.hutool.core.collection.CollUtil;
 import cn.hutool.core.collection.ListUtil;
 import cn.hutool.core.date.DateField;
 import cn.hutool.core.date.DateTime;
 import cn.hutool.core.date.DateUtil;
 import cn.hutool.core.exceptions.UtilException;
 import cn.hutool.core.lang.WeightRandom;
 import cn.hutool.core.lang.WeightRandom.WeightObj;
+import java.awt.Color;
 import java.math.BigDecimal;
 import java.math.RoundingMode;
 import java.security.NoSuchAlgorithmException;
 import java.security.SecureRandom;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Date;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Random;
+import java.util.Set;
 import java.util.concurrent.ThreadLocalRandom;
 /**
  * 随机工具类
  *
  * @author xiaoleilu
  */
 public class RandomUtil {
 	/**
 	 * 用于随机选的数字
 	 */
 	public static final String BASE_NUMBER = "0123456789";
 	/**
 	 * 用于随机选的字符
 	 */
 	public static final String BASE_CHAR = "abcdefghijklmnopqrstuvwxyz";
 	/**
-	 * 用于随机选的字符和数字（小写）
-	 */
-	public static final String BASE_CHAR_NUMBER_LOWER = BASE_CHAR + BASE_NUMBER;
-	/**
-	 * 用于随机选的字符和数字（包括大写和小写字母）
-	 */
-	public static final String BASE_CHAR_NUMBER = BASE_CHAR.toUpperCase() + BASE_CHAR_NUMBER_LOWER;
+	 * 用于随机选的字符和数字
+	 */
+	public static final String BASE_CHAR_NUMBER = BASE_CHAR + BASE_NUMBER;
 	/**
 	 * 获取随机数生成器对象<br>
 	 * ThreadLocalRandom是JDK 7之后提供并发产生随机数，能够解决多个线程发生的竞争争夺。
 	 *
 	 * <p>
 	 * 注意：此方法返回的{@link ThreadLocalRandom}不可以在多线程环境下共享对象，否则有重复随机数问题。
 	 * 见：https://www.jianshu.com/p/89dfe990295c
 	 * </p>
 	 *
 	 * @return {@link ThreadLocalRandom}
@@ -50,21 +53,21 @@
 	public static ThreadLocalRandom getRandom() {
 		return ThreadLocalRandom.current();
 	}
 	/**
 	 * 创建{@link SecureRandom}，类提供加密的强随机数生成器 (RNG)<br>
 	 *
 	 * @param seed 自定义随机种子
 	 * @return {@link SecureRandom}
 	 * @since 4.6.5
 	 */
-	public static SecureRandom createSecureRandom(final byte[] seed) {
+	public static SecureRandom createSecureRandom(byte[] seed) {
 		return (null == seed) ? new SecureRandom() : new SecureRandom(seed);
 	}
 	/**
 	 * 获取SHA1PRNG的{@link SecureRandom}，类提供加密的强随机数生成器 (RNG)<br>
 	 * 注意：此方法获取的是伪随机序列发生器PRNG（pseudo-random number generator）
 	 *
 	 * <p>
 	 * 相关说明见：https://stackoverflow.com/questions/137212/how-to-solve-slow-java-securerandom
 	 *
 	 * @return {@link SecureRandom}
@@ -78,516 +81,446 @@
 	 * 注意：此方法获取的是伪随机序列发生器PRNG（pseudo-random number generator）
 	 *
 	 * <p>
 	 * 相关说明见：https://stackoverflow.com/questions/137212/how-to-solve-slow-java-securerandom
 	 *
 	 * @param seed 随机数种子
 	 * @return {@link SecureRandom}
 	 * @see #createSecureRandom(byte[])
 	 * @since 5.5.2
 	 */
-	public static SecureRandom getSecureRandom(final byte[] seed) {
+	public static SecureRandom getSecureRandom(byte[] seed) {
 		return createSecureRandom(seed);
 	}
 	/**
 	 * 获取SHA1PRNG的{@link SecureRandom}，类提供加密的强随机数生成器 (RNG)<br>
 	 * 注意：此方法获取的是伪随机序列发生器PRNG（pseudo-random number generator）,在Linux下噪声生成时可能造成较长时间停顿。<br>
 	 * see: http://ifeve.com/jvm-random-and-entropy-source/
 	 *
 	 * <p>
 	 * 相关说明见：https://stackoverflow.com/questions/137212/how-to-solve-slow-java-securerandom
 	 *
 	 * @param seed 随机数种子
 	 * @return {@link SecureRandom}
 	 * @since 5.5.8
 	 */
-	public static SecureRandom getSHA1PRNGRandom(final byte[] seed) {
-		final SecureRandom random;
+	public static SecureRandom getSHA1PRNGRandom(byte[] seed) {
+		SecureRandom random;
 		try {
 			random = SecureRandom.getInstance("SHA1PRNG");
-		} catch (final NoSuchAlgorithmException e) {
+		} catch (NoSuchAlgorithmException e) {
 			throw new UtilException(e);
 		}
 		if (null != seed) {
 			random.setSeed(seed);
 		}
 		return random;
 	}
 	/**
 	 * 获取algorithms/providers中提供的强安全随机生成器<br>
 	 * 注意：此方法可能造成阻塞或性能问题
 	 *
 	 * @return {@link SecureRandom}
 	 * @since 5.7.12
 	 */
 	public static SecureRandom getSecureRandomStrong() {
 		try {
 			return SecureRandom.getInstanceStrong();
-		} catch (final NoSuchAlgorithmException e) {
+		} catch (NoSuchAlgorithmException e) {
 			throw new UtilException(e);
 		}
 	}
 	/**
 	 * 获取随机数产生器
 	 *
 	 * @param isSecure 是否为强随机数生成器 (RNG)
 	 * @return {@link Random}
 	 * @see #getSecureRandom()
 	 * @see #getRandom()
 	 * @since 4.1.15
 	 */
-	public static Random getRandom(final boolean isSecure) {
+	public static Random getRandom(boolean isSecure) {
 		return isSecure ? getSecureRandom() : getRandom();
 	}
 	/**
 	 * 获得随机Boolean值
 	 *
 	 * @return true or false
 	 * @since 4.5.9
 	 */
 	public static boolean randomBoolean() {
 		return 0 == randomInt(2);
 	}
 	/**
-	 * 随机bytes
-	 *
-	 * @param length 长度
-	 * @return bytes
-	 */
-	public static byte[] randomBytes(final int length) {
-		final byte[] bytes = new byte[length];
-		getRandom().nextBytes(bytes);
-		return bytes;
+	 * 随机汉字（'\u4E00'-'\u9FFF'）
+	 *
+	 * @return 随机的汉字字符
+	 * @since 5.7.15
+	 */
+	public static char randomChinese() {
+		return (char) randomInt('\u4E00', '\u9FFF');
+	}
+	/**
+	 * 获得指定范围内的随机数
+	 *
+	 * @param min 最小数（包含）
+	 * @param max 最大数（不包含）
+	 * @return 随机数
+	 */
+	public static int randomInt(int min, int max) {
+		return getRandom().nextInt(min, max);
 	}
 	/**
 	 * 获得随机数int值
 	 *
 	 * @return 随机数
 	 * @see Random#nextInt()
 	 */
 	public static int randomInt() {
 		return getRandom().nextInt();
 	}
 	/**
 	 * 获得指定范围内的随机数 [0,limit)
 	 *
-	 * @param limitExclude 限制随机数的范围，不包括这个数
+	 * @param limit 限制随机数的范围，不包括这个数
 	 * @return 随机数
 	 * @see Random#nextInt(int)
 	 */
-	public static int randomInt(final int limitExclude) {
-		return getRandom().nextInt(limitExclude);
-	}
-	/**
-	 * 获得指定范围内的随机数
-	 *
-	 * @param minInclude 最小数（包含）
-	 * @param maxExclude 最大数（不包含）
-	 * @return 随机数
-	 */
-	public static int randomInt(final int minInclude, final int maxExclude) {
-		return randomInt(minInclude, maxExclude, true, false);
-	}
-	/**
-	 * 获得指定范围内的随机数
-	 *
-	 * @param min        最小数
-	 * @param max        最大数
-	 * @param includeMin 是否包含最小值
-	 * @param includeMax 是否包含最大值
-	 * @return 随机数
-	 */
-	public static int randomInt(int min, int max, final boolean includeMin, final boolean includeMax) {
-		if (!includeMin) {
-			min++;
-		}
-		if (includeMax) {
-			max--;
-		}
-		return getRandom().nextInt(min, max);
-	}
-	/**
-	 * 创建指定长度的随机索引
-	 *
-	 * @param length 长度
-	 * @return 随机索引
-	 * @since 5.2.1
-	 */
-	public static int[] randomInts(final int length) {
-		final int[] range = ArrayUtil.range(length);
-		for (int i = 0; i < length; i++) {
-			final int random = randomInt(i, length);
-			ArrayUtil.swap(range, i, random);
-		}
-		return range;
+	public static int randomInt(int limit) {
+		return getRandom().nextInt(limit);
+	}
+	/**
+	 * 获得指定范围内的随机数[min, max)
+	 *
+	 * @param min 最小数（包含）
+	 * @param max 最大数（不包含）
+	 * @return 随机数
+	 * @see ThreadLocalRandom#nextLong(long, long)
+	 * @since 3.3.0
+	 */
+	public static long randomLong(long min, long max) {
+		return getRandom().nextLong(min, max);
 	}
 	/**
 	 * 获得随机数
 	 *
 	 * @return 随机数
 	 * @see ThreadLocalRandom#nextLong()
 	 * @since 3.3.0
 	 */
 	public static long randomLong() {
 		return getRandom().nextLong();
 	}
 	/**
 	 * 获得指定范围内的随机数 [0,limit)
 	 *
-	 * @param limitExclude 限制随机数的范围，不包括这个数
+	 * @param limit 限制随机数的范围，不包括这个数
 	 * @return 随机数
 	 * @see ThreadLocalRandom#nextLong(long)
 	 */
-	public static long randomLong(final long limitExclude) {
-		return getRandom().nextLong(limitExclude);
-	}
-	/**
-	 * 获得指定范围内的随机数[min, max)
-	 *
-	 * @param minInclude 最小数（包含）
-	 * @param maxExclude 最大数（不包含）
-	 * @return 随机数
-	 * @see ThreadLocalRandom#nextLong(long, long)
-	 * @since 3.3.0
-	 */
-	public static long randomLong(final long minInclude, final long maxExclude) {
-		return randomLong(minInclude, maxExclude, true, false);
+	public static long randomLong(long limit) {
+		return getRandom().nextLong(limit);
 	}
 	/**
 	 * 获得指定范围内的随机数
 	 *
-	 * @param min        最小数
-	 * @param max        最大数
-	 * @param includeMin 是否包含最小值
-	 * @param includeMax 是否包含最大值
-	 * @return 随机数
-	 */
-	public static long randomLong(long min, long max, final boolean includeMin, final boolean includeMax) {
-		if (!includeMin) {
-			min++;
-		}
-		if (includeMax) {
-			max--;
-		}
-		return getRandom().nextLong(min, max);
-	}
-	/**
-	 * 获得随机数[0, 1)
-	 *
-	 * @return 随机数
-	 * @see ThreadLocalRandom#nextFloat()
-	 */
-	public static float randomFloat() {
-		return getRandom().nextFloat();
-	}
-	/**
-	 * 获得指定范围内的随机数 [0,limit)
-	 *
-	 * @param limitExclude 限制随机数的范围，不包括这个数
-	 * @return 随机数
-	 */
-	public static float randomFloat(final float limitExclude) {
-		return randomFloat(0, limitExclude);
-	}
-	/**
-	 * 获得指定范围内的随机数[min, max)
-	 *
-	 * @param minInclude 最小数（包含）
-	 * @param maxExclude 最大数（不包含）
-	 * @return 随机数
-	 * @see ThreadLocalRandom#nextFloat()
-	 */
-	public static float randomFloat(final float minInclude, final float maxExclude) {
-		if (minInclude == maxExclude) {
-			return minInclude;
-		}
-		return minInclude + ((maxExclude - minInclude) * getRandom().nextFloat());
-	}
-	/**
-	 * 获得指定范围内的随机数
-	 *
-	 * @param minInclude 最小数（包含）
-	 * @param maxExclude 最大数（不包含）
+	 * @param min 最小数（包含）
+	 * @param max 最大数（不包含）
 	 * @return 随机数
 	 * @see ThreadLocalRandom#nextDouble(double, double)
 	 * @since 3.3.0
 	 */
-	public static double randomDouble(final double minInclude, final double maxExclude) {
-		return getRandom().nextDouble(minInclude, maxExclude);
+	public static double randomDouble(double min, double max) {
+		return getRandom().nextDouble(min, max);
 	}
 	/**
 	 * 获得指定范围内的随机数
 	 *
-	 * @param minInclude   最小数（包含）
-	 * @param maxExclude   最大数（不包含）
+	 * @param min          最小数（包含）
+	 * @param max          最大数（不包含）
 	 * @param scale        保留小数位数
 	 * @param roundingMode 保留小数的模式 {@link RoundingMode}
 	 * @return 随机数
 	 * @since 4.0.8
 	 */
-	public static double randomDouble(final double minInclude, final double maxExclude, final int scale,
-									  final RoundingMode roundingMode) {
-		return NumberUtil.round(randomDouble(minInclude, maxExclude), scale, roundingMode).doubleValue();
+	public static double randomDouble(double min, double max, int scale, RoundingMode roundingMode) {
+		return NumberUtil.round(randomDouble(min, max), scale, roundingMode).doubleValue();
 	}
 	/**
 	 * 获得随机数[0, 1)
 	 *
 	 * @return 随机数
 	 * @see ThreadLocalRandom#nextDouble()
 	 * @since 3.3.0
 	 */
 	public static double randomDouble() {
 		return getRandom().nextDouble();
 	}
 	/**
 	 * 获得指定范围内的随机数
 	 *
 	 * @param scale        保留小数位数
 	 * @param roundingMode 保留小数的模式 {@link RoundingMode}
 	 * @return 随机数
 	 * @since 4.0.8
 	 */
-	public static double randomDouble(final int scale, final RoundingMode roundingMode) {
+	public static double randomDouble(int scale, RoundingMode roundingMode) {
 		return NumberUtil.round(randomDouble(), scale, roundingMode).doubleValue();
 	}
 	/**
 	 * 获得指定范围内的随机数 [0,limit)
 	 *
 	 * @param limit 限制随机数的范围，不包括这个数
 	 * @return 随机数
 	 * @see ThreadLocalRandom#nextDouble(double)
 	 * @since 3.3.0
 	 */
-	public static double randomDouble(final double limit) {
+	public static double randomDouble(double limit) {
 		return getRandom().nextDouble(limit);
 	}
 	/**
 	 * 获得指定范围内的随机数
 	 *
 	 * @param limit        限制随机数的范围，不包括这个数
 	 * @param scale        保留小数位数
 	 * @param roundingMode 保留小数的模式 {@link RoundingMode}
 	 * @return 随机数
 	 * @since 4.0.8
 	 */
-	public static double randomDouble(final double limit, final int scale, final RoundingMode roundingMode) {
+	public static double randomDouble(double limit, int scale, RoundingMode roundingMode) {
 		return NumberUtil.round(randomDouble(limit), scale, roundingMode).doubleValue();
 	}
 	/**
 	 * 获得指定范围内的随机数[0, 1)
 	 *
 	 * @return 随机数
 	 * @since 4.0.9
 	 */
 	public static BigDecimal randomBigDecimal() {
 		return NumberUtil.toBigDecimal(getRandom().nextDouble());
 	}
 	/**
 	 * 获得指定范围内的随机数 [0,limit)
 	 *
 	 * @param limit 最大数（不包含）
 	 * @return 随机数
 	 * @since 4.0.9
 	 */
-	public static BigDecimal randomBigDecimal(final BigDecimal limit) {
+	public static BigDecimal randomBigDecimal(BigDecimal limit) {
 		return NumberUtil.toBigDecimal(getRandom().nextDouble(limit.doubleValue()));
 	}
 	/**
 	 * 获得指定范围内的随机数
 	 *
-	 * @param minInclude 最小数（包含）
-	 * @param maxExclude 最大数（不包含）
+	 * @param min 最小数（包含）
+	 * @param max 最大数（不包含）
 	 * @return 随机数
 	 * @since 4.0.9
 	 */
-	public static BigDecimal randomBigDecimal(final BigDecimal minInclude, final BigDecimal maxExclude) {
-		return NumberUtil.toBigDecimal(getRandom().nextDouble(minInclude.doubleValue(), maxExclude.doubleValue()));
+	public static BigDecimal randomBigDecimal(BigDecimal min, BigDecimal max) {
+		return NumberUtil.toBigDecimal(getRandom().nextDouble(min.doubleValue(), max.doubleValue()));
+	}
+	/**
+	 * 随机bytes
+	 *
+	 * @param length 长度
+	 * @return bytes
+	 */
+	public static byte[] randomBytes(int length) {
+		byte[] bytes = new byte[length];
+		getRandom().nextBytes(bytes);
+		return bytes;
 	}
 	/**
 	 * 随机获得列表中的元素
 	 *
 	 * @param <T>  元素类型
 	 * @param list 列表
 	 * @return 随机元素
 	 */
-	public static <T> T randomEle(final List<T> list) {
+	public static <T> T randomEle(List<T> list) {
 		return randomEle(list, list.size());
 	}
 	/**
 	 * 随机获得列表中的元素
 	 *
 	 * @param <T>   元素类型
 	 * @param list  列表
 	 * @param limit 限制列表的前N项
 	 * @return 随机元素
 	 */
-	public static <T> T randomEle(final List<T> list, int limit) {
+	public static <T> T randomEle(List<T> list, int limit) {
 		if (list.size() < limit) {
 			limit = list.size();
 		}
 		return list.get(randomInt(limit));
 	}
 	/**
 	 * 随机获得数组中的元素
 	 *
 	 * @param <T>   元素类型
 	 * @param array 列表
 	 * @return 随机元素
 	 * @since 3.3.0
 	 */
-	public static <T> T randomEle(final T[] array) {
+	public static <T> T randomEle(T[] array) {
 		return randomEle(array, array.length);
 	}
 	/**
 	 * 随机获得数组中的元素
 	 *
 	 * @param <T>   元素类型
 	 * @param array 列表
 	 * @param limit 限制列表的前N项
 	 * @return 随机元素
 	 * @since 3.3.0
 	 */
-	public static <T> T randomEle(final T[] array, int limit) {
+	public static <T> T randomEle(T[] array, int limit) {
 		if (array.length < limit) {
 			limit = array.length;
 		}
 		return array[randomInt(limit)];
 	}
 	/**
 	 * 随机获得列表中的一定量元素
 	 *
 	 * @param <T>   元素类型
 	 * @param list  列表
 	 * @param count 随机取出的个数
 	 * @return 随机元素
 	 */
-	public static <T> List<T> randomEles(final List<T> list, final int count) {
+	public static <T> List<T> randomEles(List<T> list, int count) {
 		final List<T> result = new ArrayList<>(count);
-		final int limit = list.size();
+		int limit = list.size();
 		while (result.size() < count) {
 			result.add(randomEle(list, limit));
 		}
 		return result;
 	}
 	/**
 	 * 随机获得列表中的一定量的元素，返回List<br>
 	 * 此方法与{@link #randomEles(List, int)} 不同点在于，不会获取重复位置的元素
 	 *
 	 * @param source 列表
 	 * @param count  随机取出的个数
 	 * @param <T>    元素类型
 	 * @return 随机列表
 	 * @since 5.2.1
 	 */
-	public static <T> List<T> randomEleList(final List<T> source, final int count) {
+	public static <T> List<T> randomEleList(List<T> source, int count) {
 		if (count >= source.size()) {
 			return ListUtil.toList(source);
 		}
 		final int[] randomList = ArrayUtil.sub(randomInts(source.size()), 0, count);
-		final List<T> result = new ArrayList<>();
-		for (final int e : randomList) {
+		List<T> result = new ArrayList<>();
+		for (int e : randomList) {
 			result.add(source.get(e));
 		}
 		return result;
 	}
 	/**
 	 * 随机获得列表中的一定量的不重复元素，返回Set
 	 *
 	 * @param <T>        元素类型
 	 * @param collection 列表
 	 * @param count      随机取出的个数
 	 * @return 随机元素
 	 * @throws IllegalArgumentException 需要的长度大于给定集合非重复总数
 	 */
-	public static <T> Set<T> randomEleSet(final Collection<T> collection, final int count) {
+	public static <T> Set<T> randomEleSet(Collection<T> collection, int count) {
 		final ArrayList<T> source = CollUtil.distinct(collection);
 		if (count > source.size()) {
 			throw new IllegalArgumentException("Count is larger than collection distinct size !");
 		}
 		final Set<T> result = new LinkedHashSet<>(count);
-		final int limit = source.size();
+		int limit = source.size();
 		while (result.size() < count) {
 			result.add(randomEle(source, limit));
 		}
 		return result;
 	}
 	/**
+	 * 创建指定长度的随机索引
+	 *
+	 * @param length 长度
+	 * @return 随机索引
+	 * @since 5.2.1
+	 */
+	public static int[] randomInts(int length) {
+		final int[] range = ArrayUtil.range(length);
+		for (int i = 0; i < length; i++) {
+			int random = randomInt(i, length);
+			ArrayUtil.swap(range, i, random);
+		}
+		return range;
+	}
+	/**
 	 * 获得一个随机的字符串（只包含数字和字符）
 	 *
 	 * @param length 字符串的长度
 	 * @return 随机字符串
 	 */
-	public static String randomString(final int length) {
+	public static String randomString(int length) {
 		return randomString(BASE_CHAR_NUMBER, length);
 	}
 	/**
 	 * 获得一个随机的字符串（只包含数字和大写字符）
 	 *
 	 * @param length 字符串的长度
 	 * @return 随机字符串
 	 * @since 4.0.13
 	 */
-	public static String randomStringUpper(final int length) {
+	public static String randomStringUpper(int length) {
 		return randomString(BASE_CHAR_NUMBER, length).toUpperCase();
 	}
 	/**
 	 * 获得一个随机的字符串（只包含数字和小写字母） 并排除指定字符串
 	 *
 	 * @param length   字符串的长度
 	 * @param elemData 要排除的字符串,如：去重容易混淆的字符串，oO0、lL1、q9Q、pP，不区分大小写
 	 * @return 随机字符串
 	 */
-	public static String randomStringWithoutStr(final int length, final String elemData) {
+	public static String randomStringWithoutStr(int length, String elemData) {
 		String baseStr = BASE_CHAR_NUMBER;
 		baseStr = StrUtil.removeAll(baseStr, elemData.toLowerCase().toCharArray());
 		return randomString(baseStr, length);
 	}
 	/**
 	 * 获得一个只包含数字的字符串
 	 *
 	 * @param length 字符串的长度
 	 * @return 随机字符串
 	 */
-	public static String randomNumbers(final int length) {
+	public static String randomNumbers(int length) {
 		return randomString(BASE_NUMBER, length);
 	}
 	/**
 	 * 获得一个随机的字符串
 	 *
 	 * @param baseString 随机字符选取的样本
 	 * @param length     字符串的长度
 	 * @return 随机字符串
 	 */
-	public static String randomString(final String baseString, int length) {
+	public static String randomString(String baseString, int length) {
 		if (StrUtil.isEmpty(baseString)) {
 			return StrUtil.EMPTY;
 		}
 		if (length < 1) {
 			length = 1;
 		}
 		final StringBuilder sb = new StringBuilder(length);
-		final int baseLength = baseString.length();
+		int baseLength = baseString.length();
 		for (int i = 0; i < length; i++) {
-			final int number = randomInt(baseLength);
+			int number = randomInt(baseLength);
 			sb.append(baseString.charAt(number));
 		}
 		return sb.toString();
-	}
-	/**
-	 * 随机汉字（'\u4E00'-'\u9FFF'）
-	 *
-	 * @return 随机的汉字字符
-	 * @since 5.7.15
-	 */
-	@SuppressWarnings("UnnecessaryUnicodeEscape")
-	public static char randomChinese() {
-		return (char) randomInt('\u4E00', '\u9FFF');
 	}
 	/**
 	 * 随机数字，数字为0~9单个数字
 	 *
 	 * @return 随机数字字符
 	 * @since 3.1.2
 	 */
 	public static char randomNumber() {
 		return randomChar(BASE_NUMBER);
 	}
@@ -600,63 +533,75 @@
 	public static char randomChar() {
 		return randomChar(BASE_CHAR_NUMBER);
 	}
 	/**
 	 * 随机字符
 	 *
 	 * @param baseString 随机字符选取的样本
 	 * @return 随机字符
 	 * @since 3.1.2
 	 */
-	public static char randomChar(final String baseString) {
+	public static char randomChar(String baseString) {
 		return baseString.charAt(randomInt(baseString.length()));
+	}
+	/**
+	 * 生成随机颜色
+	 *
+	 * @return 随机颜色
+	 * @since 4.1.5
+	 * @deprecated 使用ImgUtil.randomColor()
+	 */
+	@Deprecated
+	public static Color randomColor() {
+		final Random random = getRandom();
+		return new Color(random.nextInt(256), random.nextInt(256), random.nextInt(256));
 	}
 	/**
 	 * 带有权重的随机生成器
 	 *
 	 * @param <T>        随机对象类型
 	 * @param weightObjs 带有权重的对象列表
 	 * @return {@link WeightRandom}
 	 * @since 4.0.3
 	 */
-	public static <T> WeightRandom<T> weightRandom(final WeightObj<T>[] weightObjs) {
+	public static <T> WeightRandom<T> weightRandom(WeightObj<T>[] weightObjs) {
 		return new WeightRandom<>(weightObjs);
 	}
 	/**
 	 * 带有权重的随机生成器
 	 *
 	 * @param <T>        随机对象类型
 	 * @param weightObjs 带有权重的对象列表
 	 * @return {@link WeightRandom}
 	 * @since 4.0.3
 	 */
-	public static <T> WeightRandom<T> weightRandom(final Iterable<WeightObj<T>> weightObjs) {
+	public static <T> WeightRandom<T> weightRandom(Iterable<WeightObj<T>> weightObjs) {
 		return new WeightRandom<>(weightObjs);
 	}
 	/**
 	 * 以当天为基准，随机产生一个日期
 	 *
 	 * @param min 偏移最小天，可以为负数表示过去的时间（包含）
 	 * @param max 偏移最大天，可以为负数表示过去的时间（不包含）
 	 * @return 随机日期（随机天，其它时间不变）
 	 * @since 4.0.8
 	 */
-	public static DateTime randomDay(final int min, final int max) {
+	public static DateTime randomDay(int min, int max) {
 		return randomDate(DateUtil.date(), DateField.DAY_OF_YEAR, min, max);
 	}
 	/**
 	 * 以给定日期为基准，随机产生一个日期
 	 *
 	 * @param baseDate  基准日期
 	 * @param dateField 偏移的时间字段，例如时、分、秒等
 	 * @param min       偏移最小量，可以为负数表示过去的时间（包含）
 	 * @param max       偏移最大量，可以为负数表示过去的时间（不包含）
 	 * @return 随机日期
 	 * @since 4.5.8
 	 */
-	public static DateTime randomDate(Date baseDate, final DateField dateField, final int min, final int max) {
+	public static DateTime randomDate(Date baseDate, DateField dateField, int min, int max) {
 		if (null == baseDate) {
 			baseDate = DateUtil.date();
 		}
 		return DateUtil.offset(baseDate, dateField, randomInt(min, max));
 	}
 }

--- a/hutool-core/src/main/java/cn/hutool/core/util/StrUtil.java
+++ b/hutool-core/src/main/java/cn/hutool/core/util/StrUtil.java
@@ -1,25 +1,21 @@
 package cn.hutool.core.util;
-import java.io.StringReader;
-import java.io.StringWriter;
-import java.nio.ByteBuffer;
-import java.nio.CharBuffer;
-import java.nio.charset.Charset;
-import java.nio.charset.CharsetDecoder;
-import java.nio.charset.CodingErrorAction;
-import java.nio.charset.StandardCharsets;
-import java.util.Map;
 import cn.hutool.core.text.CharSequenceUtil;
 import cn.hutool.core.text.StrBuilder;
 import cn.hutool.core.text.StrFormatter;
 import cn.hutool.core.text.StrPool;
 import cn.hutool.core.text.TextSimilarity;
+import java.io.StringReader;
+import java.io.StringWriter;
+import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
+import java.util.Map;
 /**
  * 字符串工具类
  *
  * @author xiaoleilu
  */
 public class StrUtil extends CharSequenceUtil implements StrPool {
 	/**
 	 * <p>如果对象是字符串是否为空白，空白的定义如下：</p>
 	 * <ol>
 	 *     <li>{@code null}</li>
@@ -235,22 +231,22 @@
 		if (null == charset) {
 			charset = Charset.defaultCharset();
 		}
 		return charset.decode(data).toString();
 	}
 	/**
 	 * 调用对象的toString方法，null会返回“null”
 	 *
 	 * @param obj 对象
 	 * @return 字符串
+	 * @since 4.1.3
 	 * @see String#valueOf(Object)
-	 * @since 4.1.3
 	 */
 	public static String toString(Object obj) {
 		return String.valueOf(obj);
 	}
 	/**
 	 * 调用对象的toString方法，null会返回{@code null}
 	 *
 	 * @param obj 对象
 	 * @return 字符串 or {@code null}
 	 * @since 5.7.17
@@ -419,60 +415,11 @@
 	 *
 	 * @param template   文本模板，被替换的部分用 {key} 表示
 	 * @param map        参数值对
 	 * @param ignoreNull 是否忽略 {@code null} 值，忽略则 {@code null} 值对应的变量不被替换，否则替换为""
 	 * @return 格式化后的文本
 	 * @since 5.4.3
 	 */
 	public static String format(CharSequence template, Map<?, ?> map, boolean ignoreNull) {
 		return StrFormatter.format(template, map, ignoreNull);
 	}
-	/**
-	 * 截断字符串，使用其按照UTF-8编码为字节后不超过maxBytes长度。截断后自动追加省略号(...)
-	 * 用于存储数据库varchar且编码为UTF-8的字段
-	 *
-	 * @param str      java字符串
-	 * @param maxBytes 最大字节长度
-	 * @return 截断后的字符
-	 */
-	public static String truncateUtf8(String str, int maxBytes) {
-		Charset charset = StandardCharsets.UTF_8;
-		return truncateByByteLength(str, charset, maxBytes, 4, true);
-	}
-	/**
-	 * 截断字符串，使用其按照指定编码为字节后不超过maxBytes长度
-	 *
-	 * @param str        原始字符串
-	 * @param charset    指定编码
-	 * @param maxBytes   最大字节数
-	 * @param factor     速算因子，取该编码下单个字符的最大可能字节数
-	 * @param appendDots 截断后是否追加省略号(...)
-	 * @return 截断后的字符串
-	 */
-	public static String truncateByByteLength(String str, Charset charset, int maxBytes, int factor,
-			boolean appendDots) {
-		if (str == null || str.length() * factor <= maxBytes) {
-			return str;
-		}
-		final byte[] sba = str.getBytes(charset);
-		if (sba.length <= maxBytes) {
-			return str;
-		}
-		final int limitBytes;
-		if (appendDots) {
-			limitBytes = maxBytes - "...".getBytes(charset).length;
-		} else {
-			limitBytes = maxBytes;
-		}
-		final ByteBuffer bb = ByteBuffer.wrap(sba, 0, limitBytes);
-		final CharBuffer cb = CharBuffer.allocate(limitBytes);
-		final CharsetDecoder decoder = charset.newDecoder();
-		decoder.onMalformedInput(CodingErrorAction.IGNORE);
-		decoder.decode(bb, cb, true);
-		decoder.flush(cb);
-		final String result = new String(cb.array(), 0, cb.position());
-		if (appendDots) {
-			return result + "...";
-		}
-		return result;
-	}
 }

--- a/hutool-core/src/main/java/cn/hutool/core/util/TypeUtil.java
+++ b/hutool-core/src/main/java/cn/hutool/core/util/TypeUtil.java
@@ -1,22 +1,19 @@
 package cn.hutool.core.util;
-import cn.hutool.core.collection.ListUtil;
 import cn.hutool.core.lang.ParameterizedTypeImpl;
 import cn.hutool.core.lang.reflect.ActualTypeMapperPool;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
 import java.lang.reflect.WildcardType;
-import java.util.ArrayList;
-import java.util.List;
 import java.util.Map;
 /**
  * 针对 {@link Type} 的工具类封装<br>
  * 最主要功能包括：
  *
  * <pre>
  * 1. 获取方法的参数和返回值类型（包括Type和Class）
  * 2. 获取泛型参数类型（包括对象的泛型参数或集合元素的泛型类型）
  * </pre>
  *
@@ -233,77 +230,36 @@
 	 * class A&lt;T&gt;
 	 * class B extends A&lt;String&gt;
 	 * </pre>
 	 * <p>
 	 * 通过此方法，传入B.class即可得到B{@link ParameterizedType}，从而获取到String
 	 *
 	 * @param type {@link Type}
 	 * @return {@link ParameterizedType}
 	 * @since 4.5.2
 	 */
-	public static ParameterizedType toParameterizedType(final Type type) {
-		return toParameterizedType(type, 0);
-	}
-	/**
-	 * 将{@link Type} 转换为{@link ParameterizedType}<br>
-	 * {@link ParameterizedType}用于获取当前类或父类中泛型参数化后的类型<br>
-	 * 一般用于获取泛型参数具体的参数类型，例如：
-	 *
-	 * <pre>{@code
-	 *   class A<T>
-	 *   class B extends A<String>;
-	 * }</pre>
-	 * <p>
-	 * 通过此方法，传入B.class即可得到B对应的{@link ParameterizedType}，从而获取到String
-	 *
-	 * @param type           {@link Type}
-	 * @param interfaceIndex 实现的第几个接口
-	 * @return {@link ParameterizedType}
-	 * @since 4.5.2
-	 */
-	public static ParameterizedType toParameterizedType(final Type type, final int interfaceIndex) {
+	public static ParameterizedType toParameterizedType(Type type) {
+		ParameterizedType result = null;
 		if (type instanceof ParameterizedType) {
-			return (ParameterizedType) type;
-		}
-		if (type instanceof Class) {
-			final ParameterizedType[] generics = getGenerics((Class<?>) type);
-			if(generics.length > interfaceIndex){
-				return generics[interfaceIndex];
-			}
-		}
-		return null;
-	}
-	/**
-	 * 获取指定类所有泛型父类和泛型接口
-	 *
-	 * @param clazz 类
-	 * @return 泛型父类或接口数组
-	 * @since 6.0.0
-	 */
-	public static ParameterizedType[] getGenerics(final Class<?> clazz) {
-		final List<ParameterizedType> result = new ArrayList<>();
-		final Type genericSuper = clazz.getGenericSuperclass();
-		if(null != genericSuper && !Object.class.equals(genericSuper)){
-			final ParameterizedType parameterizedType = toParameterizedType(genericSuper);
-			if(null != parameterizedType){
-				result.add(parameterizedType);
-			}
-		}
-		final Type[] genericInterfaces = clazz.getGenericInterfaces();
-		if (ArrayUtil.isNotEmpty(genericInterfaces)) {
-			for (final Type genericInterface : genericInterfaces) {
-				if (genericInterface instanceof ParameterizedType) {
-					result.add((ParameterizedType) genericInterface);
+			result = (ParameterizedType) type;
+		} else if (type instanceof Class) {
+			final Class<?> clazz = (Class<?>) type;
+			Type genericSuper = clazz.getGenericSuperclass();
+			if (null == genericSuper || Object.class.equals(genericSuper)) {
+				final Type[] genericInterfaces = clazz.getGenericInterfaces();
+				if (ArrayUtil.isNotEmpty(genericInterfaces)) {
+					genericSuper = genericInterfaces[0];
 				}
 			}
-		}
-		return result.toArray(new ParameterizedType[0]);
+			result = toParameterizedType(genericSuper);
+		}
+		return result;
 	}
 	/**
 	 * 是否未知类型<br>
 	 * type为null或者{@link TypeVariable} 都视为未知类型
 	 *
 	 * @param type Type类型
 	 * @return 是否未知类型
 	 * @since 4.5.2
 	 */
 	public static boolean isUnknown(Type type) {

--- a/hutool-core/src/main/java/cn/hutool/core/util/URLUtil.java
+++ b/hutool-core/src/main/java/cn/hutool/core/util/URLUtil.java
@@ -705,53 +705,11 @@
 		}
 		if (null != charset) {
 			builder.append(";charset=").append(charset.name());
 		}
 		if (StrUtil.isNotBlank(encoding)) {
 			builder.append(';').append(encoding);
 		}
 		builder.append(',').append(data);
 		return builder.toString();
 	}
-	/**
-	 * 获取URL对应数据长度
-	 * <ul>
-	 *     <li>如果URL为文件，转换为文件获取文件长度。</li>
-	 *     <li>其它情况获取{@link URLConnection#getContentLengthLong()}</li>
-	 * </ul>
-	 *
-	 * @param url URL
-	 * @return 长度
-	 * @since 6.0.0
-	 */
-	public static long size(final URL url) {
-		if (URLUtil.isFileURL(url)) {
-			final File file = FileUtil.file(url);
-			final long length = file.length();
-			if (length == 0L && !file.exists()) {
-				throw new IORuntimeException("File not exist or size is zero!");
-			}
-			return length;
-		} else {
-			try {
-				final URLConnection con = url.openConnection();
-				useCachesIfNecessary(con);
-				if (con instanceof HttpURLConnection) {
-					final HttpURLConnection httpCon = (HttpURLConnection) con;
-					httpCon.setRequestMethod("HEAD");
-				}
-				return con.getContentLengthLong();
-			} catch (final IOException e) {
-				throw new IORuntimeException(e);
-			}
-		}
-	}
-	/**
-	 * 如果连接为JNLP方式，则打开缓存
-	 *
-	 * @param con {@link URLConnection}
-	 * @since 6.0.0
-	 */
-	public static void useCachesIfNecessary(final URLConnection con) {
-		con.setUseCaches(con.getClass().getSimpleName().startsWith("JNLP"));
-	}
 }

--- a/hutool-db/src/main/java/cn/hutool/db/dialect/DriverNamePool.java
+++ b/hutool-db/src/main/java/cn/hutool/db/dialect/DriverNamePool.java
@@ -66,21 +66,21 @@
 	 * JDBC 驱动 人大金仓
 	 */
 	String DRIVER_KINGBASE8 = "com.kingbase8.Driver";
 	/**
 	 * JDBC 驱动 Ignite thin
 	 */
 	String DRIVER_IGNITE_THIN = "org.apache.ignite.IgniteJdbcThinDriver";
 	/**
 	 * JDBC 驱动 ClickHouse
 	 */
-	String DRIVER_CLICK_HOUSE = "com.clickhouse.jdbc.ClickHouseDriver";
+	String DRIVER_CLICK_HOUSE = "ru.yandex.clickhouse.ClickHouseDriver";
 	/**
 	 * JDBC 驱动 瀚高数据库
 	 */
 	String DRIVER_HIGHGO = "com.highgo.jdbc.Driver";
 	/**
 	 * JDBC 驱动 DB2
 	 */
 	String DRIVER_DB2 = "com.ibm.db2.jdbc.app.DB2Driver";
 	/**
 	 * JDBC 驱动 虚谷数据库

--- a/hutool-db/src/main/java/cn/hutool/db/sql/Query.java
+++ b/hutool-db/src/main/java/cn/hutool/db/sql/Query.java
@@ -1,177 +1,170 @@
 package cn.hutool.db.sql;
-import cn.hutool.core.collection.CollUtil;
 import cn.hutool.core.collection.CollectionUtil;
 import cn.hutool.core.util.ArrayUtil;
 import cn.hutool.db.DbRuntimeException;
 import cn.hutool.db.Entity;
 import cn.hutool.db.Page;
 import java.util.Collection;
-import java.util.Set;
 /**
  * 查询对象，用于传递查询所需的字段值<br>
  * 查询对象根据表名（可以多个），多个条件 {@link Condition} 构建查询对象完成查询。<br>
  * 如果想自定义返回结果，则可在查询对象中自定义要查询的字段名，分页{@link Page}信息来自定义结果。
- *
+ * 
  * @author Looly
  *
  */
 public class Query {
 	/** 查询的字段名列表 */
 	Collection<String> fields;
 	/** 查询的表名 */
 	String[] tableNames;
 	/** 查询的条件语句 */
 	Condition[] where;
 	/** 分页对象 */
 	Page page;
 	/**
 	 * 从{@link Entity}构建Query
 	 * @param where 条件查询{@link Entity}，包含条件Map和表名
 	 * @return Query
 	 * @since 5.5.3
 	 */
 	public static Query of(Entity where){
-		final Query query = new Query(SqlUtil.buildConditions(where), where.getTableName());
-		final Set<String> fieldNames = where.getFieldNames();
-		if(CollUtil.isNotEmpty(fieldNames)){
-			query.setFields(fieldNames);
-		}
-		return query;
+		return new Query(SqlUtil.buildConditions(where), where.getTableName());
 	}
 	/**
 	 * 构造
-	 *
+	 * 
 	 * @param tableNames 表名
 	 */
 	public Query(String... tableNames) {
 		this(null, tableNames);
 		this.tableNames = tableNames;
 	}
 	/**
 	 * 构造
-	 *
+	 * 
 	 * @param where 条件语句
 	 * @param tableNames 表名
 	 */
 	public Query(Condition[] where, String... tableNames) {
 		this(where, null, tableNames);
 	}
 	/**
 	 * 构造
-	 *
+	 * 
 	 * @param where 条件语句
 	 * @param page 分页
 	 * @param tableNames 表名
 	 */
 	public Query(Condition[] where, Page page, String... tableNames) {
 		this(null, tableNames, where, page);
 	}
 	/**
 	 * 构造
-	 *
+	 * 
 	 * @param fields 字段
 	 * @param tableNames 表名
 	 * @param where 条件
 	 * @param page 分页
 	 */
 	public Query(Collection<String> fields, String[] tableNames, Condition[] where, Page page) {
 		this.fields = fields;
 		this.tableNames = tableNames;
 		this.where = where;
 		this.page = page;
 	}
 	/**
 	 * 获得查询的字段名列表
-	 *
+	 * 
 	 * @return 查询的字段名列表
 	 */
 	public Collection<String> getFields() {
 		return fields;
 	}
 	/**
 	 * 设置查询的字段名列表
-	 *
+	 * 
 	 * @param fields 查询的字段名列表
 	 * @return this
 	 */
 	public Query setFields(Collection<String> fields) {
 		this.fields = fields;
 		return this;
 	}
 	/**
 	 * 设置查询的字段名列表
-	 *
+	 * 
 	 * @param fields 查询的字段名列表
 	 * @return this
 	 */
 	public Query setFields(String... fields) {
 		this.fields = CollectionUtil.newArrayList(fields);
 		return this;
 	}
 	/**
 	 * 获得表名数组
-	 *
+	 * 
 	 * @return 表名数组
 	 */
 	public String[] getTableNames() {
 		return tableNames;
 	}
 	/**
 	 * 设置表名
-	 *
+	 * 
 	 * @param tableNames 表名
 	 * @return this
 	 */
 	public Query setTableNames(String... tableNames) {
 		this.tableNames = tableNames;
 		return this;
 	}
 	/**
 	 * 获得条件语句
-	 *
+	 * 
 	 * @return 条件语句
 	 */
 	public Condition[] getWhere() {
 		return where;
 	}
 	/**
 	 * 设置条件语句
-	 *
+	 * 
 	 * @param where 条件语句
 	 * @return this
 	 */
 	public Query setWhere(Condition... where) {
 		this.where = where;
 		return this;
 	}
 	/**
 	 * 获得分页对象，无分页返回{@code null}
-	 *
+	 * 
 	 * @return 分页对象 or {@code null}
 	 */
 	public Page getPage() {
 		return page;
 	}
 	/**
 	 * 设置分页对象
-	 *
+	 * 
 	 * @param page 分页对象
 	 * @return this
 	 */
 	public Query setPage(Page page) {
 		this.page = page;
 		return this;
 	}
 	/**
 	 * 获得第一个表名
-	 *
+	 * 
 	 * @return 表名
 	 * @throws DbRuntimeException 没有表
 	 */
 	public String getFirstTableName() throws DbRuntimeException {
 		if (ArrayUtil.isEmpty(this.tableNames)) {
 			throw new DbRuntimeException("No tableName!");
 		}
 		return this.tableNames[0];
 	}
 }

--- a/hutool-extra/src/main/java/cn/hutool/extra/compress/archiver/StreamArchiver.java
+++ b/hutool-extra/src/main/java/cn/hutool/extra/compress/archiver/StreamArchiver.java
@@ -70,27 +70,27 @@
 	 * @param archiverName 归档类型名称，见{@link ArchiveStreamFactory}
 	 * @param targetStream 归档输出的流
 	 */
 	public StreamArchiver(Charset charset, String archiverName, OutputStream targetStream) {
 		if("tgz".equalsIgnoreCase(archiverName) || "tar.gz".equalsIgnoreCase(archiverName)){
 			try {
 				this.out = new TarArchiveOutputStream(new GzipCompressorOutputStream(targetStream));
 			} catch (IOException e) {
 				throw new IORuntimeException(e);
 			}
-		} else {
-			final ArchiveStreamFactory factory = new ArchiveStreamFactory(charset.name());
-			try {
-				this.out = factory.createArchiveOutputStream(archiverName, targetStream);
-			} catch (ArchiveException e) {
-				throw new CompressException(e);
-			}
+			return;
+		}
+		final ArchiveStreamFactory factory = new ArchiveStreamFactory(charset.name());
+		try {
+			this.out = factory.createArchiveOutputStream(archiverName, targetStream);
+		} catch (ArchiveException e) {
+			throw new CompressException(e);
 		}
 		if(this.out instanceof TarArchiveOutputStream){
 			((TarArchiveOutputStream)out).setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);
 		} else if(this.out instanceof ArArchiveOutputStream){
 			((ArArchiveOutputStream)out).setLongFileMode(ArArchiveOutputStream.LONGFILE_BSD);
 		}
 	}
 	/**
 	 * 将文件或目录加入归档包，目录采取递归读取方式按照层级加入
 	 *

--- a/hutool-extra/src/main/java/cn/hutool/extra/expression/ExpressionEngine.java
+++ b/hutool-extra/src/main/java/cn/hutool/extra/expression/ExpressionEngine.java
@@ -1,20 +1,17 @@
 package cn.hutool.extra.expression;
-import java.util.Collection;
 import java.util.Map;
 /**
  * 表达式引擎API接口，通过实现此接口，完成表达式的解析和执行
  *
- * @author looll, independenter
+ * @author looll,independenter
  * @since 5.5.0
  */
 public interface ExpressionEngine {
 	/**
 	 * 执行表达式
-	 *
-	 * @param expression    表达式
-	 * @param context       表达式上下文，用于存储表达式中所需的变量值等
-	 * @param allowClassSet 允许的Class白名单
+	 * @param expression 表达式
+	 * @param context 表达式上下文，用于存储表达式中所需的变量值等
 	 * @return 执行结果
 	 */
-	Object eval(String expression, Map<String, Object> context, Collection<Class<?>> allowClassSet);
+	Object eval(String expression, Map<String, Object> context);
 }

--- a/hutool-extra/src/main/java/cn/hutool/extra/expression/ExpressionUtil.java
+++ b/hutool-extra/src/main/java/cn/hutool/extra/expression/ExpressionUtil.java
@@ -1,14 +1,12 @@
 package cn.hutool.extra.expression;
-import cn.hutool.core.collection.ListUtil;
 import cn.hutool.extra.expression.engine.ExpressionFactory;
-import java.util.Collection;
 import java.util.Map;
 /**
  * 表达式引擎工具类
  *
  * @author looly
  * @since 5.5.0
  */
 public class ExpressionUtil {
 	/**
 	 * 获得全局单例的表达式引擎
@@ -19,25 +17,13 @@
 		return ExpressionFactory.get();
 	}
 	/**
 	 * 执行表达式
 	 *
 	 * @param expression 表达式
 	 * @param context    表达式上下文，用于存储表达式中所需的变量值等
 	 * @return 执行结果
 	 */
 	public static Object eval(String expression, Map<String, Object> context) {
-		return eval(expression, context, ListUtil.empty());
-	}
-	/**
-	 * 执行表达式
-	 *
-	 * @param expression 表达式
-	 * @param context    表达式上下文，用于存储表达式中所需的变量值等
-	 * @param allowClassSet 允许的Class白名单
-	 * @return 执行结果
-	 * @since 5.8.21
-	 */
-	public static Object eval(String expression, Map<String, Object> context, Collection<Class<?>> allowClassSet) {
-		return getEngine().eval(expression, context, allowClassSet);
+		return getEngine().eval(expression, context);
 	}
 }

--- a/hutool-extra/src/main/java/cn/hutool/extra/expression/engine/aviator/AviatorEngine.java
+++ b/hutool-extra/src/main/java/cn/hutool/extra/expression/engine/aviator/AviatorEngine.java
@@ -1,38 +1,32 @@
 package cn.hutool.extra.expression.engine.aviator;
-import cn.hutool.core.collection.CollUtil;
 import cn.hutool.extra.expression.ExpressionEngine;
 import com.googlecode.aviator.AviatorEvaluator;
 import com.googlecode.aviator.AviatorEvaluatorInstance;
-import com.googlecode.aviator.Options;
-import java.util.Collection;
-import java.util.Collections;
 import java.util.Map;
 /**
  * Aviator引擎封装<br>
  * 见：https://github.com/killme2008/aviatorscript
  *
  * @author looly
  * @since 5.5.0
  */
 public class AviatorEngine implements ExpressionEngine {
 	private final AviatorEvaluatorInstance engine;
 	/**
 	 * 构造
 	 */
 	public AviatorEngine() {
 		engine = AviatorEvaluator.getInstance();
 	}
 	@Override
-	public Object eval(String expression, Map<String, Object> context, Collection<Class<?>> allowClassSet) {
-		engine.setOption(Options.ALLOWED_CLASS_SET,
-			CollUtil.isEmpty(allowClassSet) ? Collections.emptySet() : CollUtil.newHashSet(allowClassSet));
+	public Object eval(String expression, Map<String, Object> context) {
 		return engine.execute(expression, context);
 	}
 	/**
 	 * 获取{@link AviatorEvaluatorInstance}
 	 *
 	 * @return {@link AviatorEvaluatorInstance}
 	 */
 	public AviatorEvaluatorInstance getEngine() {
 		return this.engine;
 	}

--- a/hutool-extra/src/main/java/cn/hutool/extra/expression/engine/jexl/JexlEngine.java
+++ b/hutool-extra/src/main/java/cn/hutool/extra/expression/engine/jexl/JexlEngine.java
@@ -1,30 +1,29 @@
 package cn.hutool.extra.expression.engine.jexl;
 import cn.hutool.extra.expression.ExpressionEngine;
 import org.apache.commons.jexl3.JexlBuilder;
 import org.apache.commons.jexl3.MapContext;
-import java.util.Collection;
 import java.util.Map;
 /**
  * Jexl3引擎封装<br>
  * 见：https://github.com/apache/commons-jexl
  *
  * @since 5.5.0
  * @author looly
  */
 public class JexlEngine implements ExpressionEngine {
 	private final org.apache.commons.jexl3.JexlEngine engine;
 	public JexlEngine(){
 		engine = (new JexlBuilder()).cache(512).strict(true).silent(false).create();
 	}
 	@Override
-	public Object eval(String expression, Map<String, Object> context, Collection<Class<?>> allowClassSet) {
+	public Object eval(String expression, Map<String, Object> context) {
 		final MapContext mapContext = new MapContext(context);
 		try{
 			return engine.createExpression(expression).evaluate(mapContext);
 		} catch (Exception ignore){
 			return engine.createScript(expression).execute(mapContext);
 		}
 	}
 	/**
 	 * 获取{@link org.apache.commons.jexl3.JexlEngine}
 	 *

--- a/hutool-extra/src/main/java/cn/hutool/extra/expression/engine/jfireel/JfireELEngine.java
+++ b/hutool-extra/src/main/java/cn/hutool/extra/expression/engine/jfireel/JfireELEngine.java
@@ -1,28 +1,22 @@
 package cn.hutool.extra.expression.engine.jfireel;
 import cn.hutool.extra.expression.ExpressionEngine;
 import com.jfirer.jfireel.expression.Expression;
-import java.util.Collection;
 import java.util.Map;
 /**
  * JfireEL引擎封装<br>
  * 见：https://gitee.com/eric_ds/jfireEL
  *
  * @since 5.5.0
  * @author looly
  */
 public class JfireELEngine implements ExpressionEngine {
-	static {
-		checkEngineExist(Expression.class);
-	}
 	/**
 	 * 构造
 	 */
 	public JfireELEngine(){
 	}
 	@Override
-	public Object eval(String expression, Map<String, Object> context, Collection<Class<?>> allowClassSet) {
+	public Object eval(String expression, Map<String, Object> context) {
 		return Expression.parse(expression).calculate(context);
 	}
-	private static void checkEngineExist(Class<?> clazz){
-	}
 }

--- a/hutool-extra/src/main/java/cn/hutool/extra/expression/engine/mvel/MvelEngine.java
+++ b/hutool-extra/src/main/java/cn/hutool/extra/expression/engine/mvel/MvelEngine.java
@@ -1,28 +1,22 @@
 package cn.hutool.extra.expression.engine.mvel;
 import cn.hutool.extra.expression.ExpressionEngine;
 import org.mvel2.MVEL;
-import java.util.Collection;
 import java.util.Map;
 /**
  * MVEL (MVFLEX Expression Language)引擎封装<br>
  * 见：https://github.com/mvel/mvel
  *
  * @since 5.5.0
  * @author looly
  */
 public class MvelEngine implements ExpressionEngine {
-	static {
-		checkEngineExist(MVEL.class);
-	}
 	/**
 	 * 构造
 	 */
 	public MvelEngine(){
 	}
 	@Override
-	public Object eval(String expression, Map<String, Object> context, Collection<Class<?>> allowClassSet) {
+	public Object eval(String expression, Map<String, Object> context) {
 		return MVEL.eval(expression, context);
 	}
-	private static void checkEngineExist(Class<?> clazz){
-	}
 }

--- a/hutool-extra/src/main/java/cn/hutool/extra/expression/engine/qlexpress/QLExpressEngine.java
+++ b/hutool-extra/src/main/java/cn/hutool/extra/expression/engine/qlexpress/QLExpressEngine.java
@@ -1,33 +1,32 @@
 package cn.hutool.extra.expression.engine.qlexpress;
 import cn.hutool.extra.expression.ExpressionEngine;
 import cn.hutool.extra.expression.ExpressionException;
 import com.ql.util.express.DefaultContext;
 import com.ql.util.express.ExpressRunner;
-import java.util.Collection;
 import java.util.Map;
 /**
  * QLExpress引擎封装<br>
  * 见：https://github.com/alibaba/QLExpress
  *
  * @author looly
  * @since 5.8.9
  */
 public class QLExpressEngine implements ExpressionEngine {
 	private final ExpressRunner engine;
 	/**
 	 * 构造
 	 */
 	public QLExpressEngine() {
 		engine = new ExpressRunner();
 	}
 	@Override
-	public Object eval(final String expression, final Map<String, Object> context, Collection<Class<?>> allowClassSet) {
+	public Object eval(final String expression, final Map<String, Object> context) {
 		final DefaultContext<String, Object> defaultContext = new DefaultContext<>();
 		defaultContext.putAll(context);
 		try {
 			return engine.execute(expression, defaultContext, null, true, false);
 		} catch (final Exception e) {
 			throw new ExpressionException(e);
 		}
 	}
 }

--- a/hutool-extra/src/main/java/cn/hutool/extra/expression/engine/rhino/RhinoEngine.java
+++ b/hutool-extra/src/main/java/cn/hutool/extra/expression/engine/rhino/RhinoEngine.java
@@ -1,35 +1,29 @@
 package cn.hutool.extra.expression.engine.rhino;
 import cn.hutool.core.map.MapUtil;
 import cn.hutool.extra.expression.ExpressionEngine;
 import org.mozilla.javascript.Context;
 import org.mozilla.javascript.Scriptable;
 import org.mozilla.javascript.ScriptableObject;
-import java.util.Collection;
 import java.util.Map;
 /**
  * rhino引擎封装<br>
  * 见：https://github.com/mozilla/rhino
  *
  * @author lzpeng
  * @since 5.5.2
  */
 public class RhinoEngine implements ExpressionEngine {
-	static {
-		checkEngineExist(Context.class);
-	}
 	@Override
-	public Object eval(String expression, Map<String, Object> context, Collection<Class<?>> allowClassSet) {
+	public Object eval(String expression, Map<String, Object> context) {
 		final Context ctx = Context.enter();
 		final Scriptable scope = ctx.initStandardObjects();
 		if (MapUtil.isNotEmpty(context)) {
 			context.forEach((key, value)->{
 				ScriptableObject.putProperty(scope, key, Context.javaToJS(value, scope));
 			});
 		}
 		final Object result = ctx.evaluateString(scope, expression, "rhino.js", 1, null);
 		Context.exit();
 		return result;
 	}
-	private static void checkEngineExist(Class<?> clazz){
-	}
 }

--- a/hutool-extra/src/main/java/cn/hutool/extra/expression/engine/spel/SpELEngine.java
+++ b/hutool-extra/src/main/java/cn/hutool/extra/expression/engine/spel/SpELEngine.java
@@ -1,30 +1,29 @@
 package cn.hutool.extra.expression.engine.spel;
 import cn.hutool.extra.expression.ExpressionEngine;
 import org.springframework.expression.EvaluationContext;
 import org.springframework.expression.ExpressionParser;
 import org.springframework.expression.spel.standard.SpelExpressionParser;
 import org.springframework.expression.spel.support.StandardEvaluationContext;
-import java.util.Collection;
 import java.util.Map;
 /**
  * Spring-Expression引擎封装<br>
  * 见：https://github.com/spring-projects/spring-framework/tree/master/spring-expression
  *
  * @since 5.5.0
  * @author looly
  */
 public class SpELEngine implements ExpressionEngine {
 	private final ExpressionParser parser;
 	/**
 	 * 构造
 	 */
 	public SpELEngine(){
 		parser = new SpelExpressionParser();
 	}
 	@Override
-	public Object eval(String expression, Map<String, Object> context, Collection<Class<?>> allowClassSet) {
+	public Object eval(String expression, Map<String, Object> context) {
 		final EvaluationContext evaluationContext = new StandardEvaluationContext();
 		context.forEach(evaluationContext::setVariable);
 		return parser.parseExpression(expression).getValue(evaluationContext);
 	}
 }

--- a/hutool-extra/src/main/java/cn/hutool/extra/ssh/Sftp.java
+++ b/hutool-extra/src/main/java/cn/hutool/extra/ssh/Sftp.java
@@ -203,47 +203,44 @@
 		}
 		return this;
 	}
 	/**
 	 * 获取SFTP通道客户端
 	 *
 	 * @return 通道客户端
 	 * @since 4.1.14
 	 */
 	public ChannelSftp getClient() {
-		if(false == this.channel.isConnected()){
-			init();
-		}
 		return this.channel;
 	}
 	/**
 	 * 远程当前目录
 	 *
 	 * @return 远程当前目录
 	 */
 	@Override
 	public String pwd() {
 		try {
-			return getClient().pwd();
+			return channel.pwd();
 		} catch (SftpException e) {
 			throw new JschRuntimeException(e);
 		}
 	}
 	/**
 	 * 获取HOME路径
 	 *
 	 * @return HOME路径
 	 * @since 4.0.5
 	 */
 	public String home() {
 		try {
-			return getClient().getHome();
+			return channel.getHome();
 		} catch (SftpException e) {
 			throw new JschRuntimeException(e);
 		}
 	}
 	/**
 	 * 遍历某个目录下所有文件或目录，不会递归遍历
 	 *
 	 * @param path 遍历某个目录下所有文件或目录
 	 * @return 目录或文件名列表
 	 * @since 4.0.5
@@ -304,21 +301,21 @@
 	 * 此方法自动过滤"."和".."两种目录
 	 *
 	 * @param path   遍历某个目录下所有文件或目录
 	 * @param filter 文件或目录过滤器，可以实现过滤器返回自己需要的文件或目录名列表
 	 * @return 目录或文件名列表
 	 * @since 5.3.5
 	 */
 	public List<LsEntry> lsEntries(String path, Filter<LsEntry> filter) {
 		final List<LsEntry> entryList = new ArrayList<>();
 		try {
-			getClient().ls(path, entry -> {
+			channel.ls(path, entry -> {
 				final String fileName = entry.getFilename();
 				if (false == StrUtil.equals(".", fileName) && false == StrUtil.equals("..", fileName)) {
 					if (null == filter || filter.accept(entry)) {
 						entryList.add(entry);
 					}
 				}
 				return LsEntrySelector.CONTINUE;
 			});
 		} catch (SftpException e) {
 			if (false == StrUtil.startWithIgnoreCase(e.getMessage(), "No such file")) {
@@ -326,31 +323,31 @@
 			}
 		}
 		return entryList;
 	}
 	@Override
 	public boolean mkdir(String dir) {
 		if (isDir(dir)) {
 			return true;
 		}
 		try {
-			getClient().mkdir(dir);
+			this.channel.mkdir(dir);
 			return true;
 		} catch (SftpException e) {
 			throw new JschRuntimeException(e);
 		}
 	}
 	@Override
 	public boolean isDir(String dir) {
 		final SftpATTRS sftpATTRS;
 		try {
-			sftpATTRS = getClient().stat(dir);
+			sftpATTRS = this.channel.stat(dir);
 		} catch (SftpException e) {
 			final String msg = e.getMessage();
 			if (StrUtil.containsAnyIgnoreCase(msg, "No such file", "does not exist")) {
 				return false;
 			}
 			throw new FtpException(e);
 		}
 		return sftpATTRS.isDir();
 	}
 	/**
@@ -359,53 +356,52 @@
 	 * @param directory directory
 	 * @return 是否打开目录
 	 * @throws FtpException 进入目录失败异常
 	 */
 	@Override
 	synchronized public boolean cd(String directory) throws FtpException {
 		if (StrUtil.isBlank(directory)) {
 			return true;
 		}
 		try {
-			getClient().cd(directory.replace('\\', '/'));
+			channel.cd(directory.replace('\\', '/'));
 			return true;
 		} catch (SftpException e) {
 			throw new FtpException(e);
 		}
 	}
 	/**
 	 * 删除文件
 	 *
 	 * @param filePath 要删除的文件绝对路径
 	 */
 	@Override
 	public boolean delFile(String filePath) {
 		try {
-			getClient().rm(filePath);
+			channel.rm(filePath);
 		} catch (SftpException e) {
 			throw new JschRuntimeException(e);
 		}
 		return true;
 	}
 	/**
 	 * 删除文件夹及其文件夹下的所有文件
 	 *
 	 * @param dirPath 文件夹路径
 	 * @return boolean 是否删除成功
 	 */
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean delDir(String dirPath) {
 		if (false == cd(dirPath)) {
 			return false;
 		}
-		final ChannelSftp channel = getClient();
 		Vector<LsEntry> list;
 		try {
 			list = channel.ls(channel.pwd());
 		} catch (SftpException e) {
 			throw new JschRuntimeException(e);
 		}
 		String fileName;
 		for (LsEntry entry : list) {
 			fileName = entry.getFilename();
 			if (false == ".".equals(fileName) && false == "..".equals(fileName)) {
@@ -506,39 +502,39 @@
 	 *
 	 * @param srcFilePath 本地文件路径
 	 * @param destPath    目标路径，
 	 * @param monitor     上传进度监控，通过实现此接口完成进度显示
 	 * @param mode        {@link Mode} 模式
 	 * @return this
 	 * @since 4.6.5
 	 */
 	public Sftp put(String srcFilePath, String destPath, SftpProgressMonitor monitor, Mode mode) {
 		try {
-			getClient().put(srcFilePath, destPath, monitor, mode.ordinal());
+			channel.put(srcFilePath, destPath, monitor, mode.ordinal());
 		} catch (SftpException e) {
 			throw new JschRuntimeException(e);
 		}
 		return this;
 	}
 	/**
 	 * 将本地数据流上传到目标服务器，目标文件名为destPath，目标必须为文件
 	 *
 	 * @param srcStream 本地的数据流
 	 * @param destPath  目标路径，
 	 * @param monitor   上传进度监控，通过实现此接口完成进度显示
 	 * @param mode      {@link Mode} 模式
 	 * @return this
 	 * @since 5.7.16
 	 */
 	public Sftp put(InputStream srcStream, String destPath, SftpProgressMonitor monitor, Mode mode) {
 		try {
-			getClient().put(srcStream, destPath, monitor, mode.ordinal());
+			channel.put(srcStream, destPath, monitor, mode.ordinal());
 		} catch (SftpException e) {
 			throw new JschRuntimeException(e);
 		}
 		return this;
 	}
 	@Override
 	public void download(String src, File destFile) {
 		get(src, FileUtil.getAbsolutePath(destFile));
 	}
 	/**
@@ -579,37 +575,37 @@
 	}
 	/**
 	 * 获取远程文件
 	 *
 	 * @param src  远程文件路径
 	 * @param dest 目标文件路径
 	 * @return this
 	 */
 	public Sftp get(String src, String dest) {
 		try {
-			getClient().get(src, dest);
+			channel.get(src, dest);
 		} catch (SftpException e) {
 			throw new JschRuntimeException(e);
 		}
 		return this;
 	}
 	/**
 	 * 获取远程文件
 	 *
 	 * @param src 远程文件路径
 	 * @param out 目标流
 	 * @return this
 	 * @since 5.7.0
 	 */
 	public Sftp get(String src, OutputStream out) {
 		try {
-			getClient().get(src, out);
+			channel.get(src, out);
 		} catch (SftpException e) {
 			throw new JschRuntimeException(e);
 		}
 		return this;
 	}
 	@Override
 	public void close() {
 		JschUtil.close(this.channel);
 		JschUtil.close(this.session);
 	}

--- a/hutool-http/src/main/java/cn/hutool/http/HttpRequest.java
+++ b/hutool-http/src/main/java/cn/hutool/http/HttpRequest.java
@@ -1198,29 +1198,23 @@
 			return FormUrlEncodedBody.create(this.form, this.charset);
 		}
 	}
 	/**
 	 * 发送多组件请求（例如包含文件的表单）<br>
 	 * 发送数据后自动关闭输出流
 	 *
 	 * @throws IOException IO异常
 	 */
 	private void sendMultipart() throws IOException {
-		final RequestBody body;
-		if(null == form && null != this.body) {
-			body = ResourceBody.create(this.body);
-		}else{
-			final MultipartBody multipartBody = MultipartBody.create(this.form, this.charset);
-			this.httpConnection.header(Header.CONTENT_TYPE, multipartBody.getContentType(), true);
-			body = multipartBody;
-		}
-		body.writeClose(this.httpConnection.getOutputStream());
+		final MultipartBody multipartBody = MultipartBody.create(this.form, this.charset);
+		this.httpConnection.header(Header.CONTENT_TYPE, multipartBody.getContentType(), true);
+		multipartBody.writeClose(this.httpConnection.getOutputStream());
 	}
 	/**
 	 * 是否忽略读取响应body部分<br>
 	 * HEAD、CONNECT、OPTIONS、TRACE方法将不读取响应体
 	 *
 	 * @return 是否需要忽略响应body部分
 	 * @since 3.1.2
 	 */
 	private boolean isIgnoreResponseBody() {
 		return Method.HEAD == this.method //

--- a/hutool-http/src/main/java/cn/hutool/http/useragent/Browser.java
+++ b/hutool-http/src/main/java/cn/hutool/http/useragent/Browser.java
@@ -29,21 +29,21 @@
 			new Browser("QQBrowser", "MQQBrowser", "MQQBrowser\\/([\\d\\w\\.\\-]+)"),
 			new Browser("DingTalk-win", "dingtalk-win", "DingTalk\\(([\\d\\w\\.\\-]+)\\)"),
 			new Browser("DingTalk", "DingTalk", "AliApp\\(DingTalk\\/([\\d\\w\\.\\-]+)\\)"),
 			new Browser("Alipay", "AlipayClient", "AliApp\\(AP\\/([\\d\\w\\.\\-]+)\\)"),
 			new Browser("Taobao", "taobao", "AliApp\\(TB\\/([\\d\\w\\.\\-]+)\\)"),
 			new Browser("UCBrowser", "UC?Browser", "UC?Browser\\/([\\d\\w\\.\\-]+)"),
 			new Browser("MiuiBrowser", "MiuiBrowser|mibrowser", "MiuiBrowser\\/([\\d\\w\\.\\-]+)"),
 			new Browser("Quark", "Quark", Other_Version),
 			new Browser("Lenovo", "SLBrowser", "SLBrowser/([\\d\\w\\.\\-]+)"),
 			new Browser("MSEdge", "Edge|Edg", "(?:edge|Edg|EdgA)\\/([\\d\\w\\.\\-]+)"),
-			new Browser("Chrome", "chrome|(iphone.*crios.*safari)", "(?:Chrome|CriOS)\\/([\\d\\w\\.\\-]+)"),
+			new Browser("Chrome", "chrome", Other_Version),
 			new Browser("Firefox", "firefox", Other_Version),
 			new Browser("IEMobile", "iemobile", Other_Version),
 			new Browser("Android Browser", "android", "version\\/([\\d\\w\\.\\-]+)"),
 			new Browser("Safari", "safari", "version\\/([\\d\\w\\.\\-]+)"),
 			new Browser("Opera", "opera", Other_Version),
 			new Browser("Konqueror", "konqueror", Other_Version),
 			new Browser("PS3", "playstation 3", "([\\d\\w\\.\\-]+)\\)\\s*$"),
 			new Browser("PSP", "playstation portable", "([\\d\\w\\.\\-]+)\\)?\\s*$"),
 			new Browser("Lotus", "lotus.notes", "Lotus-Notes\\/([\\w.]+)"),
 			new Browser("Thunderbird", "thunderbird", Other_Version),

--- a/hutool-json/src/main/java/cn/hutool/json/JSONBeanParser.java
+++ b/hutool-json/src/main/java/cn/hutool/json/JSONBeanParser.java
@@ -1,17 +1,16 @@
 package cn.hutool.json;
 /**
  * 实现此接口的类可以通过实现{@code parse(value)}方法来将JSON中的值解析为此对象的值
  *
  * @author Looly
  * @since 5.7.8
- * @param <T> 参数类型
  */
 public interface JSONBeanParser<T> {
 	/**
 	 * value转Bean<br>
 	 * 通过实现此接口，将JSON中的值填充到当前对象的字段值中，即对象自行实现JSON反序列化逻辑
 	 *
 	 * @param value 被解析的对象类型，可能为JSON或者普通String、Number等
 	 */
 	void parse(T value);
 }

--- a/hutool-jwt/src/main/java/cn/hutool/jwt/signers/AsymmetricJWTSigner.java
+++ b/hutool-jwt/src/main/java/cn/hutool/jwt/signers/AsymmetricJWTSigner.java
@@ -42,43 +42,23 @@
 	 *
 	 * @param charset 编码
 	 * @return 编码
 	 */
 	public AsymmetricJWTSigner setCharset(Charset charset) {
 		this.charset = charset;
 		return this;
 	}
 	@Override
 	public String sign(String headerBase64, String payloadBase64) {
-		final String dataStr = StrUtil.format("{}.{}", headerBase64, payloadBase64);
-		return Base64.encodeUrlSafe(sign(StrUtil.bytes(dataStr, charset)));
-	}
-	/**
-	 * 签名字符串数据
-	 *
-	 * @param data 数据
-	 * @return 签名
-	 */
-	protected byte[] sign(byte[] data) {
-		return sign.sign(data);
+		return Base64.encodeUrlSafe(sign.sign(StrUtil.format("{}.{}", headerBase64, payloadBase64)));
 	}
 	@Override
 	public boolean verify(String headerBase64, String payloadBase64, String signBase64) {
-		return verify(
-			StrUtil.bytes(StrUtil.format("{}.{}", headerBase64, payloadBase64), charset),
-			Base64.decode(signBase64));
-	}
-	/**
-	 * 验签数据
-	 *
-	 * @param data   数据
-	 * @param signed 签名
-	 * @return 是否通过
-	 */
-	protected boolean verify(byte[] data, byte[] signed) {
-		return sign.verify(data, signed);
+		return sign.verify(
+				StrUtil.bytes(StrUtil.format("{}.{}", headerBase64, payloadBase64), charset),
+				Base64.decode(signBase64));
 	}
 	@Override
 	public String getAlgorithm() {
 		return this.sign.getSignature().getAlgorithm();
 	}
 }

--- a/hutool-jwt/src/main/java/cn/hutool/jwt/signers/EllipticCurveJWTSigner.java
+++ b//dev/null
@@ -1,139 +0,0 @@
-package cn.hutool.jwt.signers;
-import cn.hutool.jwt.JWTException;
-import java.security.Key;
-import java.security.KeyPair;
-/**
- * 椭圆曲线（Elliptic Curve）的JWT签名器。<br>
- * 按照https://datatracker.ietf.org/doc/html/rfc7518#section-3.4,<br>
- * Elliptic Curve Digital Signature Algorithm (ECDSA)算法签名需要转换DER格式为pair (R, S)
- *
- * @author looly
- * @since 5.8.21
- */
-public class EllipticCurveJWTSigner extends AsymmetricJWTSigner {
-	/**
-	 * 构造
-	 *
-	 * @param algorithm 算法
-	 * @param key       密钥
-	 */
-	public EllipticCurveJWTSigner(String algorithm, Key key) {
-		super(algorithm, key);
-	}
-	/**
-	 * 构造
-	 *
-	 * @param algorithm 算法
-	 * @param keyPair   密钥对
-	 */
-	public EllipticCurveJWTSigner(String algorithm, KeyPair keyPair) {
-		super(algorithm, keyPair);
-	}
-	@Override
-	protected byte[] sign(final byte[] data) {
-		return derToConcat(super.sign(data), getSignatureByteArrayLength(getAlgorithm()));
-	}
-	@Override
-	protected boolean verify(final byte[] data, final byte[] signed) {
-		return super.verify(data, concatToDER(signed));
-	}
-	/**
-	 * 获取签名长度
-	 * @param alg 算法
-	 * @return 长度
-	 * @throws JWTException JWT异常
-	 */
-	private static int getSignatureByteArrayLength(final String alg) throws JWTException {
-		switch (alg) {
-			case "ES256":
-			case "SHA256withECDSA":
-				return 64;
-			case "ES384":
-			case "SHA384withECDSA":
-				return 96;
-			case "ES512":
-			case "SHA512withECDSA":
-				return 132;
-			default:
-				throw new JWTException("Unsupported Algorithm: {}", alg);
-		}
-	}
-	private static byte[] derToConcat(final byte[] derSignature, int outputLength) throws JWTException {
-		if (derSignature.length < 8 || derSignature[0] != 48) {
-			throw new JWTException("Invalid ECDSA signature format");
-		}
-		final int offset;
-		if (derSignature[1] > 0) {
-			offset = 2;
-		} else if (derSignature[1] == (byte) 0x81) {
-			offset = 3;
-		} else {
-			throw new JWTException("Invalid ECDSA signature format");
-		}
-		final byte rLength = derSignature[offset + 1];
-		int i = rLength;
-		while ((i > 0) && (derSignature[(offset + 2 + rLength) - i] == 0)) {
-			i--;
-		}
-		final byte sLength = derSignature[offset + 2 + rLength + 1];
-		int j = sLength;
-		while ((j > 0) && (derSignature[(offset + 2 + rLength + 2 + sLength) - j] == 0)) {
-			j--;
-		}
-		int rawLen = Math.max(i, j);
-		rawLen = Math.max(rawLen, outputLength / 2);
-		if ((derSignature[offset - 1] & 0xff) != derSignature.length - offset
-			|| (derSignature[offset - 1] & 0xff) != 2 + rLength + 2 + sLength
-			|| derSignature[offset] != 2
-			|| derSignature[offset + 2 + rLength] != 2) {
-			throw new JWTException("Invalid ECDSA signature format");
-		}
-		final byte[] concatSignature = new byte[2 * rawLen];
-		System.arraycopy(derSignature, (offset + 2 + rLength) - i, concatSignature, rawLen - i, i);
-		System.arraycopy(derSignature, (offset + 2 + rLength + 2 + sLength) - j, concatSignature, 2 * rawLen - j, j);
-		return concatSignature;
-	}
-	private static byte[] concatToDER(byte[] jwsSignature) throws ArrayIndexOutOfBoundsException {
-		int rawLen = jwsSignature.length / 2;
-		int i = rawLen;
-		while ((i > 0) && (jwsSignature[rawLen - i] == 0)) {
-			i--;
-		}
-		int j = i;
-		if (jwsSignature[rawLen - i] < 0) {
-			j += 1;
-		}
-		int k = rawLen;
-		while ((k > 0) && (jwsSignature[2 * rawLen - k] == 0)) {
-			k--;
-		}
-		int l = k;
-		if (jwsSignature[2 * rawLen - k] < 0) {
-			l += 1;
-		}
-		int len = 2 + j + 2 + l;
-		if (len > 255) {
-			throw new JWTException("Invalid ECDSA signature format");
-		}
-		int offset;
-		final byte[] derSignature;
-		if (len < 128) {
-			derSignature = new byte[2 + 2 + j + 2 + l];
-			offset = 1;
-		} else {
-			derSignature = new byte[3 + 2 + j + 2 + l];
-			derSignature[1] = (byte) 0x81;
-			offset = 2;
-		}
-		derSignature[0] = 48;
-		derSignature[offset++] = (byte) len;
-		derSignature[offset++] = 2;
-		derSignature[offset++] = (byte) j;
-		System.arraycopy(jwsSignature, rawLen - i, derSignature, (offset + j) - i, i);
-		offset += j;
-		derSignature[offset++] = 2;
-		derSignature[offset++] = (byte) l;
-		System.arraycopy(jwsSignature, 2 * rawLen - k, derSignature, (offset + l) - k, k);
-		return derSignature;
-	}
-}

--- a/hutool-jwt/src/main/java/cn/hutool/jwt/signers/JWTSignerUtil.java
+++ b/hutool-jwt/src/main/java/cn/hutool/jwt/signers/JWTSignerUtil.java
@@ -1,13 +1,12 @@
 package cn.hutool.jwt.signers;
 import cn.hutool.core.lang.Assert;
-import cn.hutool.core.util.ReUtil;
 import java.security.Key;
 import java.security.KeyPair;
 import java.security.PrivateKey;
 import java.security.PublicKey;
 /**
  * JWT签名器工具类
  *
  * @author looly
  * @since 5.7.0
  */
@@ -210,36 +209,30 @@
 	 *
 	 * @param algorithmId 算法ID，见{@link AlgorithmUtil}
 	 * @param keyPair     密钥对
 	 * @return 签名器
 	 */
 	public static JWTSigner createSigner(String algorithmId, KeyPair keyPair) {
 		Assert.notNull(keyPair, "Signer key pair must be not null!");
 		if (null == algorithmId || NoneJWTSigner.ID_NONE.equals(algorithmId)) {
 			return none();
 		}
-		if(ReUtil.isMatch("es\\d{3}", algorithmId.toLowerCase())){
-			return new EllipticCurveJWTSigner(AlgorithmUtil.getAlgorithm(algorithmId), keyPair);
-		}
 		return new AsymmetricJWTSigner(AlgorithmUtil.getAlgorithm(algorithmId), keyPair);
 	}
 	/**
 	 * 创建签名器
 	 *
 	 * @param algorithmId 算法ID，见{@link AlgorithmUtil}
 	 * @param key         密钥
 	 * @return 签名器
 	 */
 	public static JWTSigner createSigner(String algorithmId, Key key) {
 		Assert.notNull(key, "Signer key must be not null!");
 		if (null == algorithmId || NoneJWTSigner.ID_NONE.equals(algorithmId)) {
 			return NoneJWTSigner.NONE;
 		}
 		if (key instanceof PrivateKey || key instanceof PublicKey) {
-			if(ReUtil.isMatch("ES\\d{3}", algorithmId)){
-				return new EllipticCurveJWTSigner(algorithmId, key);
-			}
 			return new AsymmetricJWTSigner(AlgorithmUtil.getAlgorithm(algorithmId), key);
 		}
 		return new HMacJWTSigner(AlgorithmUtil.getAlgorithm(algorithmId), key);
 	}
 }

--- a/hutool-poi/src/main/java/cn/hutool/poi/excel/ExcelReader.java
+++ b/hutool-poi/src/main/java/cn/hutool/poi/excel/ExcelReader.java
@@ -367,33 +367,27 @@
 	 * @param x X坐标，从0计数，即列号
 	 * @param y Y坐标，从0计数，即行号
 	 * @return 值，如果单元格无值返回null
 	 * @since 4.0.3
 	 */
 	public Object readCellValue(int x, int y) {
 		return CellUtil.getCellValue(getCell(x, y), this.cellEditor);
 	}
 	/**
 	 * 获取Excel写出器<br>
-	 * 在读取Excel并做一定编辑后，获取写出器写出，规则如下：
-	 * <ul>
-	 *     <li>1. 当从流中读取时，转换为Writer直接使用Sheet对象，此时修改不会影响源文件，Writer中flush需要指定新的路径。</li>
-	 *     <li>2. 当从文件读取时，直接获取文件及sheet名称，此时可以修改原文件。</li>
-	 * </ul>
+	 * 在读取Excel并做一定编辑后，获取写出器写出<br>
+	 * 注意，只读方式下，此方法无效
 	 *
 	 * @return {@link ExcelWriter}
 	 * @since 4.0.6
 	 */
 	public ExcelWriter getWriter() {
-		if(null == this.destFile){
-			return new ExcelWriter(this.sheet);
-		}
 		return ExcelUtil.getWriter(this.destFile, this.sheet.getSheetName());
 	}
 	/**
 	 * 读取一行
 	 *
 	 * @param row 行
 	 * @return 单元格值列表
 	 */
 	private List<Object> readRow(Row row) {
 		return RowUtil.readRow(row, this.cellEditor);

--- a/hutool-setting/src/main/java/cn/hutool/setting/SettingLoader.java
+++ b/hutool-setting/src/main/java/cn/hutool/setting/SettingLoader.java
@@ -95,37 +95,37 @@
 		BufferedReader reader = null;
 		try {
 			reader = IoUtil.getReader(settingStream, this.charset);
 			String group = null;
 			String line;
 			while (true) {
 				line = reader.readLine();
 				if (line == null) {
 					break;
 				}
-				line = StrUtil.trim(line);
+				line = line.trim();
 				if (StrUtil.isBlank(line) || StrUtil.startWith(line, COMMENT_FLAG_PRE)) {
 					continue;
 				}
 				if (StrUtil.isSurround(line, CharUtil.BRACKET_START, CharUtil.BRACKET_END)) {
-					group = StrUtil.trim(line.substring(1, line.length() - 1));
+					group = line.substring(1, line.length() - 1).trim();
 					continue;
 				}
 				final String[] keyValue = StrUtil.splitToArray(line, this.assignFlag, 2);
 				if (keyValue.length < 2) {
 					continue;
 				}
-				String value = StrUtil.trim(keyValue[1]);
+				String value = keyValue[1].trim();
 				if (this.isUseVariable) {
 					value = replaceVar(group, value);
 				}
-				this.groupedMap.put(group, StrUtil.trim(keyValue[0]), value);
+				this.groupedMap.put(group, keyValue[0].trim(), value);
 			}
 		} finally {
 			IoUtil.close(reader);
 		}
 		return true;
 	}
 	/**
 	 * 设置变量的正则<br>
 	 * 正则只能有一个group表示变量本身，剩余为字符 例如 \$\{(name)\}表示${name}变量名为name的一个变量表示
 	 *

--- a/hutool-system/src/main/java/cn/hutool/system/UserInfo.java
+++ b/hutool-system/src/main/java/cn/hutool/system/UserInfo.java
@@ -14,21 +14,21 @@
 	private final String USER_LANGUAGE;
 	private final String USER_COUNTRY;
 	public UserInfo(){
 		USER_NAME = fixPath(SystemUtil.get("user.name", false));
 		USER_HOME = fixPath(SystemUtil.get("user.home", false));
 		USER_DIR = fixPath(SystemUtil.get("user.dir", false));
 		JAVA_IO_TMPDIR = fixPath(SystemUtil.get("java.io.tmpdir", false));
 		USER_LANGUAGE = SystemUtil.get("user.language", false);
 		String userCountry = SystemUtil.get("user.country", false);
 		if(null == userCountry){
-			userCountry = SystemUtil.get("user.region", false);
+			userCountry = SystemUtil.get("user.country", false);
 		}
 		USER_COUNTRY = userCountry;
 	}
 	/**
 	 * 取得当前登录用户的名字（取自系统属性：{@code user.name}）。
 	 *
 	 * <p>
 	 * 例如：{@code "admin"}
 	 * </p>
 	 *
