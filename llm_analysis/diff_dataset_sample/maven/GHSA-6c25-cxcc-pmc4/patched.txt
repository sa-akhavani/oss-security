# ====================================================================
# FILE: docs/js/version.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1 ---
     1| var version = '5.8.21'


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/bean/BeanUtil.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 885-918 ---
   885| 			throw new IllegalArgumentException("Invalid Getter or Setter name: " + getterOrSetterName);
   886| 		}
   887| 	}
   888| 	/**
   889| 	 * 判断source与target的所有公共字段的值是否相同
   890| 	 *
   891| 	 * @param source           待检测对象1
   892| 	 * @param target           待检测对象2
   893| 	 * @param ignoreProperties 不需要检测的字段
   894| 	 * @return 判断结果，如果为true则证明所有字段的值都相同
   895| 	 * @author Takak11
   896| 	 * @since 5.8.4
   897| 	 */
   898| 	public static boolean isCommonFieldsEqual(Object source, Object target, String... ignoreProperties) {
   899| 		if (null == source && null == target) {
   900| 			return true;
   901| 		}
   902| 		if (null == source || null == target) {
   903| 			return false;
   904| 		}
   905| 		final Map<String, Object> sourceFieldsMap = BeanUtil.beanToMap(source);
   906| 		final Map<String, Object> targetFieldsMap = BeanUtil.beanToMap(target);
   907| 		final Set<String> sourceFields = sourceFieldsMap.keySet();
   908| 		sourceFields.removeAll(Arrays.asList(ignoreProperties));
   909| 		for (String field : sourceFields) {
   910| 			if(sourceFieldsMap.containsKey(field) && targetFieldsMap.containsKey(field)){
   911| 				if (ObjectUtil.notEqual(sourceFieldsMap.get(field), targetFieldsMap.get(field))) {
   912| 					return false;
   913| 				}
   914| 			}
   915| 		}
   916| 		return true;
   917| 	}
   918| }


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/collection/CollUtil.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 2624-2676 ---
  2624| 	 * @return Value集合
  2625| 	 * @since 4.5.12
  2626| 	 */
  2627| 	public static <V> List<V> values(Collection<Map<?, V>> mapCollection) {
  2628| 		final List<V> values = new ArrayList<>();
  2629| 		for (Map<?, V> map : mapCollection) {
  2630| 			values.addAll(map.values());
  2631| 		}
  2632| 		return values;
  2633| 	}
  2634| 	/**
  2635| 	 * 取最大值
  2636| 	 *
  2637| 	 * @param <T>  元素类型
  2638| 	 * @param coll 集合
  2639| 	 * @return 最大值
  2640| 	 * @see Collections#max(Collection)
  2641| 	 * @since 4.6.5
  2642| 	 */
  2643| 	public static <T extends Comparable<? super T>> T max(Collection<T> coll) {
  2644| 		return isEmpty(coll) ? null : Collections.max(coll);
  2645| 	}
  2646| 	/**
  2647| 	 * 取最小值
  2648| 	 *
  2649| 	 * @param <T>  元素类型
  2650| 	 * @param coll 集合
  2651| 	 * @return 最小值
  2652| 	 * @see Collections#min(Collection)
  2653| 	 * @since 4.6.5
  2654| 	 */
  2655| 	public static <T extends Comparable<? super T>> T min(Collection<T> coll) {
  2656| 		return isEmpty(coll) ? null : Collections.min(coll);
  2657| 	}
  2658| 	/**
  2659| 	 * 转为只读集合
  2660| 	 *
  2661| 	 * @param <T> 元素类型
  2662| 	 * @param c   集合
  2663| 	 * @return 只读集合
  2664| 	 * @since 5.2.6
  2665| 	 */
  2666| 	public static <T> Collection<T> unmodifiable(Collection<? extends T> c) {
  2667| 		return Collections.unmodifiableCollection(c);
  2668| 	}
  2669| 	/**
  2670| 	 * 根据给定的集合类型，返回对应的空集合，支持类型包括：
  2671| 	 * *
  2672| 	 * <pre>
  2673| 	 *     1. NavigableSet
  2674| 	 *     2. SortedSet
  2675| 	 *     3. Set
  2676| 	 *     4. List


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/comparator/VersionComparator.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-86 ---
     1| package cn.hutool.core.comparator;
     2| import cn.hutool.core.convert.Convert;
     3| import cn.hutool.core.lang.PatternPool;
     4| import cn.hutool.core.util.CharUtil;
     5| import cn.hutool.core.util.ObjectUtil;
     6| import cn.hutool.core.util.ReUtil;
     7| import cn.hutool.core.util.StrUtil;
     8| import java.io.Serializable;
     9| import java.util.Comparator;
    10| import java.util.List;
    11| /**
    12|  * 版本比较器<br>
    13|  * 比较两个版本的大小<br>
    14|  * 排序时版本从小到大排序，即比较时小版本在前，大版本在后<br>
    15|  * 支持如：1.3.20.8，6.82.20160101，8.5a/8.5c等版本形式<br>
    16|  * 参考：https://www.cnblogs.com/shihaiming/p/6286575.html
    17|  *
    18|  * @author Looly
    19|  * @since 4.0.2
    20|  */
    21| public class VersionComparator implements Comparator<String>, Serializable {
    22| 	private static final long serialVersionUID = 8083701245147495562L;
    23| 	/** 单例 */
    24| 	public static final VersionComparator INSTANCE = new VersionComparator();
    25| 	/**
    26| 	 * 默认构造
    27| 	 */
    28| 	public VersionComparator() {
    29| 	}
    30| 	/**
    31| 	 * 比较两个版本<br>
    32| 	 * null版本排在最小：即：
    33| 	 * <pre>
    34| 	 * compare(null, "v1") &lt; 0
    35| 	 * compare("v1", "v1")  = 0
    36| 	 * compare(null, null)   = 0
    37| 	 * compare("v1", null) &gt; 0
    38| 	 * compare("1.0.0", "1.0.2") &lt; 0
    39| 	 * compare("1.0.2", "1.0.2a") &lt; 0
    40| 	 * compare("1.0.3", "1.0.2a") &gt; 0
    41| 	 * compare("1.13.0", "1.12.1c") &gt; 0
    42| 	 * compare("V0.0.20170102", "V0.0.20170101") &gt; 0
    43| 	 * </pre>
    44| 	 *
    45| 	 * @param version1 版本1
    46| 	 * @param version2 版本2
    47| 	 */
    48| 	@Override
    49| 	public int compare(String version1, String version2) {
    50| 		if(ObjectUtil.equal(version1, version2)) {
    51| 			return 0;
    52| 		}
    53| 		if (version1 == null && version2 == null) {
    54| 			return 0;
    55| 		} else if (version1 == null) {// null视为最小版本，排在前
    56| 			return -1;
    57| 		} else if (version2 == null) {
    58| 			return 1;
    59| 		}
    60| 		final List<String> v1s = StrUtil.split(version1, CharUtil.DOT);
    61| 		final List<String> v2s = StrUtil.split(version2, CharUtil.DOT);
    62| 		int diff = 0;
    63| 		int minLength = Math.min(v1s.size(), v2s.size());// 取最小长度值
    64| 		String v1;
    65| 		String v2;
    66| 		for (int i = 0; i < minLength; i++) {
    67| 			v1 = v1s.get(i);
    68| 			v2 = v2s.get(i);
    69| 			diff = v1.length() - v2.length();
    70| 			if (0 == diff) {
    71| 				diff = v1.compareTo(v2);
    72| 			}else {
    73| 				int v1Num = Convert.toInt(ReUtil.get(PatternPool.NUMBERS, v1, 0), 0);
    74| 				int v2Num = Convert.toInt(ReUtil.get(PatternPool.NUMBERS, v2, 0), 0);
    75| 				int diff1 = v1Num - v2Num;
    76| 				if (diff1 != 0) {
    77| 					diff = diff1;
    78| 				}
    79| 			}
    80| 			if(diff != 0) {
    81| 				break;
    82| 			}
    83| 		}
    84| 		return (diff != 0) ? diff : v1s.size() - v2s.size();
    85| 	}
    86| }


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/compress/ZipReader.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 6-53 ---
     6| import cn.hutool.core.lang.Filter;
     7| import cn.hutool.core.util.StrUtil;
     8| import cn.hutool.core.util.ZipUtil;
     9| import java.io.Closeable;
    10| import java.io.File;
    11| import java.io.IOException;
    12| import java.io.InputStream;
    13| import java.nio.charset.Charset;
    14| import java.util.Enumeration;
    15| import java.util.function.Consumer;
    16| import java.util.zip.ZipEntry;
    17| import java.util.zip.ZipFile;
    18| import java.util.zip.ZipInputStream;
    19| /**
    20|  * Zip文件或流读取器，一般用于Zip文件解压
    21|  *
    22|  * @author looly
    23|  * @since 5.7.8
    24|  */
    25| public class ZipReader implements Closeable {
    26| 	private static final int DEFAULT_MAX_SIZE_DIFF = 100;
    27| 	private ZipFile zipFile;
    28| 	private ZipInputStream in;
    29| 	/**
    30| 	 * 检查ZipBomb文件差异倍数，-1表示不检查ZipBomb
    31| 	 */
    32| 	private int maxSizeDiff = DEFAULT_MAX_SIZE_DIFF;
    33| 	/**
    34| 	 * 创建ZipReader
    35| 	 *
    36| 	 * @param zipFile 生成的Zip文件
    37| 	 * @param charset 编码
    38| 	 * @return ZipReader
    39| 	 */
    40| 	public static ZipReader of(File zipFile, Charset charset) {
    41| 		return new ZipReader(zipFile, charset);
    42| 	}
    43| 	/**
    44| 	 * 创建ZipReader
    45| 	 *
    46| 	 * @param in      Zip输入的流，一般为输入文件流
    47| 	 * @param charset 编码
    48| 	 * @return ZipReader
    49| 	 */
    50| 	public static ZipReader of(InputStream in, Charset charset) {
    51| 		return new ZipReader(in, charset);
    52| 	}
    53| 	/**

# --- HUNK 2: Lines 66-116 ---
    66| 	 */
    67| 	public ZipReader(ZipFile zipFile) {
    68| 		this.zipFile = zipFile;
    69| 	}
    70| 	/**
    71| 	 * 构造
    72| 	 *
    73| 	 * @param in      读取的的Zip文件流
    74| 	 * @param charset 编码
    75| 	 */
    76| 	public ZipReader(InputStream in, Charset charset) {
    77| 		this.in = new ZipInputStream(in, charset);
    78| 	}
    79| 	/**
    80| 	 * 构造
    81| 	 *
    82| 	 * @param zin 读取的的Zip文件流
    83| 	 */
    84| 	public ZipReader(ZipInputStream zin) {
    85| 		this.in = zin;
    86| 	}
    87| 	/**
    88| 	 * 设置检查ZipBomb文件差异倍数，-1表示不检查ZipBomb
    89| 	 *
    90| 	 * @param maxSizeDiff 检查ZipBomb文件差异倍数，-1表示不检查ZipBomb
    91| 	 * @return this
    92| 	 * @since 6.0.0
    93| 	 */
    94| 	public ZipReader setMaxSizeDiff(final int maxSizeDiff) {
    95| 		this.maxSizeDiff = maxSizeDiff;
    96| 		return this;
    97| 	}
    98| 	/**
    99| 	 * 获取指定路径的文件流<br>
   100| 	 * 如果是文件模式，则直接获取Entry对应的流，如果是流模式，则遍历entry后，找到对应流返回
   101| 	 *
   102| 	 * @param path 路径
   103| 	 * @return 文件流
   104| 	 */
   105| 	public InputStream get(String path) {
   106| 		if (null != this.zipFile) {
   107| 			final ZipFile zipFile = this.zipFile;
   108| 			final ZipEntry entry = zipFile.getEntry(path);
   109| 			if (null != entry) {
   110| 				return ZipUtil.getStream(zipFile, entry);
   111| 			}
   112| 		} else {
   113| 			try {
   114| 				ZipEntry zipEntry;
   115| 				while (null != (zipEntry = in.getNextEntry())) {
   116| 					if (zipEntry.getName().equals(path)) {

# --- HUNK 3: Lines 205-241 ---
   205| 	 * @param consumer {@link ZipEntry}处理器
   206| 	 * @throws IORuntimeException IO异常
   207| 	 */
   208| 	private void readFromStream(Consumer<ZipEntry> consumer) throws IORuntimeException {
   209| 		try {
   210| 			ZipEntry zipEntry;
   211| 			while (null != (zipEntry = in.getNextEntry())) {
   212| 				consumer.accept(zipEntry);
   213| 				checkZipBomb(zipEntry);
   214| 			}
   215| 		} catch (IOException e) {
   216| 			throw new IORuntimeException(e);
   217| 		}
   218| 	}
   219| 	/**
   220| 	 * 检查Zip bomb漏洞
   221| 	 *
   222| 	 * @param entry {@link ZipEntry}
   223| 	 * @return 检查后的{@link ZipEntry}
   224| 	 */
   225| 	private ZipEntry checkZipBomb(ZipEntry entry) {
   226| 		if(maxSizeDiff < 0){
   227| 			return entry;
   228| 		}
   229| 		if (null == entry) {
   230| 			return null;
   231| 		}
   232| 		final long compressedSize = entry.getCompressedSize();
   233| 		final long uncompressedSize = entry.getSize();
   234| 		if (compressedSize < 0 || uncompressedSize < 0 ||
   235| 				compressedSize * maxSizeDiff < uncompressedSize) {
   236| 			throw new UtilException("Zip bomb attack detected, invalid sizes: compressed {}, uncompressed {}, name {}",
   237| 					compressedSize, uncompressedSize, entry.getName());
   238| 		}
   239| 		return entry;
   240| 	}
   241| }


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/convert/ConverterRegistry.java
# Total hunks: 5
# ====================================================================
# --- HUNK 1: Lines 1-61 ---
     1| package cn.hutool.core.convert;
     2| import cn.hutool.core.bean.BeanUtil;
     3| import cn.hutool.core.convert.impl.*;
     4| import cn.hutool.core.date.DateTime;
     5| import cn.hutool.core.lang.Console;
     6| import cn.hutool.core.lang.Opt;
     7| import cn.hutool.core.lang.Pair;
     8| import cn.hutool.core.lang.TypeReference;
     9| import cn.hutool.core.map.SafeConcurrentHashMap;
    10| import cn.hutool.core.util.*;
    11| import java.io.Serializable;
    12| import java.lang.ref.SoftReference;
    13| import java.lang.ref.WeakReference;
    14| import java.lang.reflect.Type;
    15| import java.math.BigDecimal;
    16| import java.math.BigInteger;
    17| import java.net.URI;
    18| import java.net.URL;
    19| import java.nio.charset.Charset;
    20| import java.nio.file.Path;
    21| import java.time.*;
    22| import java.time.temporal.TemporalAccessor;
    23| import java.util.*;
    24| import java.util.concurrent.atomic.*;
    25| /**
    26|  * 转换器登记中心
    27|  * <p>
    28|  * 将各种类型Convert对象放入登记中心，通过convert方法查找目标类型对应的转换器，将被转换对象转换之。
    29|  * </p>
    30|  * <p>
    31|  * 在此类中，存放着默认转换器和自定义转换器，默认转换器是Hutool中预定义的一些转换器，自定义转换器存放用户自定的转换器。
    32|  * </p>
    33|  *
    34|  * @author Looly
    35|  */
    36| public class ConverterRegistry implements Serializable {
    37| 	private static final long serialVersionUID = 1L;
    38| 	/**
    39| 	 * 默认类型转换器
    40| 	 */
    41| 	private Map<Class<?>, Converter<?>> defaultConverterMap;
    42| 	/**
    43| 	 * 用户自定义类型转换器
    44| 	 */
    45| 	private volatile Map<Type, Converter<?>> customConverterMap;
    46| 	/**
    47| 	 * 类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例 没有绑定关系，而且只有被调用到才会装载，从而实现了延迟加载
    48| 	 */
    49| 	private static class SingletonHolder {
    50| 		/**
    51| 		 * 静态初始化器，由JVM来保证线程安全
    52| 		 */
    53| 		private static final ConverterRegistry INSTANCE = new ConverterRegistry();
    54| 	}
    55| 	/**
    56| 	 * 获得单例的 ConverterRegistry
    57| 	 *
    58| 	 * @return ConverterRegistry
    59| 	 */
    60| 	public static ConverterRegistry getInstance() {
    61| 		return SingletonHolder.INSTANCE;

# --- HUNK 2: Lines 124-164 ---
   124| 			if (null == converter) {
   125| 				converter = this.getDefaultConverter(type);
   126| 			}
   127| 		} else {
   128| 			converter = this.getDefaultConverter(type);
   129| 			if (null == converter) {
   130| 				converter = this.getCustomConverter(type);
   131| 			}
   132| 		}
   133| 		return converter;
   134| 	}
   135| 	/**
   136| 	 * 获得默认转换器
   137| 	 *
   138| 	 * @param <T>  转换的目标类型（转换器转换到的类型）
   139| 	 * @param type 类型
   140| 	 * @return 转换器
   141| 	 */
   142| 	@SuppressWarnings("unchecked")
   143| 	public <T> Converter<T> getDefaultConverter(Type type) {
   144| 		return (null == defaultConverterMap) ? null : (Converter<T>) defaultConverterMap.get(TypeUtil.getClass(type));
   145| 	}
   146| 	/**
   147| 	 * 获得自定义转换器
   148| 	 *
   149| 	 * @param <T>  转换的目标类型（转换器转换到的类型）
   150| 	 * @param type 类型
   151| 	 * @return 转换器
   152| 	 */
   153| 	@SuppressWarnings("unchecked")
   154| 	public <T> Converter<T> getCustomConverter(Type type) {
   155| 		return (null == customConverterMap) ? null : (Converter<T>) customConverterMap.get(type);
   156| 	}
   157| 	/**
   158| 	 * 转换值为指定类型
   159| 	 *
   160| 	 * @param <T>           转换的目标类型（转换器转换到的类型）
   161| 	 * @param type          类型目标
   162| 	 * @param value         被转换值
   163| 	 * @param defaultValue  默认值
   164| 	 * @param isCustomFirst 是否自定义转换器优先

# --- HUNK 3: Lines 255-298 ---
   255| 			final CollectionConverter collectionConverter = new CollectionConverter(type);
   256| 			return (T) collectionConverter.convert(value, (Collection<?>) defaultValue);
   257| 		}
   258| 		if (Map.class.isAssignableFrom(rowType)) {
   259| 			final MapConverter mapConverter = new MapConverter(type);
   260| 			return (T) mapConverter.convert(value, (Map<?, ?>) defaultValue);
   261| 		}
   262| 		if (Map.Entry.class.isAssignableFrom(rowType)) {
   263| 			final EntryConverter mapConverter = new EntryConverter(type);
   264| 			return (T) mapConverter.convert(value, (Map.Entry<?, ?>) defaultValue);
   265| 		}
   266| 		if (rowType.isInstance(value)) {
   267| 			return (T) value;
   268| 		}
   269| 		if (rowType.isEnum()) {
   270| 			return (T) new EnumConverter(rowType).convert(value, defaultValue);
   271| 		}
   272| 		if (rowType.isArray()) {
   273| 			final ArrayConverter arrayConverter = new ArrayConverter(rowType);
   274| 			return (T) arrayConverter.convert(value, defaultValue);
   275| 		}
   276| 		if("java.lang.Class".equals(rowType.getName())){
   277| 			final ClassConverter converter = new ClassConverter();
   278| 			return (T) converter.convert(value, (Class<?>) defaultValue);
   279| 		}
   280| 		return null;
   281| 	}
   282| 	/**
   283| 	 * 注册默认转换器
   284| 	 *
   285| 	 * @return 转换器
   286| 	 */
   287| 	private ConverterRegistry defaultConverter() {
   288| 		defaultConverterMap = new SafeConcurrentHashMap<>();
   289| 		defaultConverterMap.put(int.class, new PrimitiveConverter(int.class));
   290| 		defaultConverterMap.put(long.class, new PrimitiveConverter(long.class));
   291| 		defaultConverterMap.put(byte.class, new PrimitiveConverter(byte.class));
   292| 		defaultConverterMap.put(short.class, new PrimitiveConverter(short.class));
   293| 		defaultConverterMap.put(float.class, new PrimitiveConverter(float.class));
   294| 		defaultConverterMap.put(double.class, new PrimitiveConverter(double.class));
   295| 		defaultConverterMap.put(char.class, new PrimitiveConverter(char.class));
   296| 		defaultConverterMap.put(boolean.class, new PrimitiveConverter(boolean.class));
   297| 		defaultConverterMap.put(Number.class, new NumberConverter());
   298| 		defaultConverterMap.put(Integer.class, new NumberConverter(Integer.class));

# --- HUNK 4: Lines 321-353 ---
   321| 		defaultConverterMap.put(java.sql.Time.class, new DateConverter(java.sql.Time.class));
   322| 		defaultConverterMap.put(java.sql.Timestamp.class, new DateConverter(java.sql.Timestamp.class));
   323| 		defaultConverterMap.put(TemporalAccessor.class, new TemporalAccessorConverter(Instant.class));
   324| 		defaultConverterMap.put(Instant.class, new TemporalAccessorConverter(Instant.class));
   325| 		defaultConverterMap.put(LocalDateTime.class, new TemporalAccessorConverter(LocalDateTime.class));
   326| 		defaultConverterMap.put(LocalDate.class, new TemporalAccessorConverter(LocalDate.class));
   327| 		defaultConverterMap.put(LocalTime.class, new TemporalAccessorConverter(LocalTime.class));
   328| 		defaultConverterMap.put(ZonedDateTime.class, new TemporalAccessorConverter(ZonedDateTime.class));
   329| 		defaultConverterMap.put(OffsetDateTime.class, new TemporalAccessorConverter(OffsetDateTime.class));
   330| 		defaultConverterMap.put(OffsetTime.class, new TemporalAccessorConverter(OffsetTime.class));
   331| 		defaultConverterMap.put(DayOfWeek.class, new TemporalAccessorConverter(DayOfWeek.class));
   332| 		defaultConverterMap.put(Month.class, new TemporalAccessorConverter(Month.class));
   333| 		defaultConverterMap.put(MonthDay.class, new TemporalAccessorConverter(MonthDay.class));
   334| 		defaultConverterMap.put(Period.class, new PeriodConverter());
   335| 		defaultConverterMap.put(Duration.class, new DurationConverter());
   336| 		defaultConverterMap.put(WeakReference.class, new ReferenceConverter(WeakReference.class));// since 3.0.8
   337| 		defaultConverterMap.put(SoftReference.class, new ReferenceConverter(SoftReference.class));// since 3.0.8
   338| 		defaultConverterMap.put(AtomicReference.class, new AtomicReferenceConverter());// since 3.0.8
   339| 		defaultConverterMap.put(AtomicIntegerArray.class, new AtomicIntegerArrayConverter());
   340| 		defaultConverterMap.put(AtomicLongArray.class, new AtomicLongArrayConverter());
   341| 		defaultConverterMap.put(TimeZone.class, new TimeZoneConverter());
   342| 		defaultConverterMap.put(Locale.class, new LocaleConverter());
   343| 		defaultConverterMap.put(Charset.class, new CharsetConverter());
   344| 		defaultConverterMap.put(Path.class, new PathConverter());
   345| 		defaultConverterMap.put(Currency.class, new CurrencyConverter());// since 3.0.8
   346| 		defaultConverterMap.put(UUID.class, new UUIDConverter());// since 4.0.10
   347| 		defaultConverterMap.put(StackTraceElement.class, new StackTraceElementConverter());// since 4.5.2
   348| 		defaultConverterMap.put(Optional.class, new OptionalConverter());// since 5.0.0
   349| 		defaultConverterMap.put(Opt.class, new OptConverter());// since 5.7.16
   350| 		defaultConverterMap.put(Pair.class, new PairConverter(Pair.class));// since 5.8.17
   351| 		return this;
   352| 	}
   353| }


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/convert/impl/BeanConverter.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-28 ---
     1| package cn.hutool.core.convert.impl;
     2| import cn.hutool.core.bean.BeanUtil;
     3| import cn.hutool.core.bean.copier.BeanCopier;
     4| import cn.hutool.core.bean.copier.CopyOptions;
     5| import cn.hutool.core.bean.copier.ValueProvider;
     6| import cn.hutool.core.convert.AbstractConverter;
     7| import cn.hutool.core.convert.ConvertException;
     8| import cn.hutool.core.lang.Console;
     9| import cn.hutool.core.map.MapProxy;
    10| import cn.hutool.core.util.ObjectUtil;
    11| import cn.hutool.core.util.ReflectUtil;
    12| import cn.hutool.core.util.StrUtil;
    13| import cn.hutool.core.util.TypeUtil;
    14| import java.lang.reflect.Type;
    15| import java.util.Map;
    16| /**
    17|  * Bean转换器，支持：
    18|  * <pre>
    19|  * Map =》 Bean
    20|  * Bean =》 Bean
    21|  * ValueProvider =》 Bean
    22|  * </pre>
    23|  *
    24|  * @param <T> Bean类型
    25|  * @author Looly
    26|  * @since 4.0.2
    27|  */
    28| public class BeanConverter<T> extends AbstractConverter<T> {

# --- HUNK 2: Lines 43-89 ---
    43| 	 *
    44| 	 * @param beanClass 转换成的目标Bean类
    45| 	 */
    46| 	public BeanConverter(Class<T> beanClass) {
    47| 		this(beanClass, CopyOptions.create().setIgnoreError(true));
    48| 	}
    49| 	/**
    50| 	 * 构造
    51| 	 *
    52| 	 * @param beanType 转换成的目标Bean类
    53| 	 * @param copyOptions Bean转换选项参数
    54| 	 */
    55| 	@SuppressWarnings("unchecked")
    56| 	public BeanConverter(Type beanType, CopyOptions copyOptions) {
    57| 		this.beanType = beanType;
    58| 		this.beanClass = (Class<T>) TypeUtil.getClass(beanType);
    59| 		this.copyOptions = copyOptions;
    60| 	}
    61| 	@Override
    62| 	protected T convertInternal(Object value) {
    63| 		final Class<?>[] interfaces = this.beanClass.getInterfaces();
    64| 		for (Class<?> anInterface : interfaces) {
    65| 			if("cn.hutool.json.JSONBeanParser".equals(anInterface.getName())){
    66| 				final T obj = ReflectUtil.newInstanceIfPossible(this.beanClass);
    67| 				ReflectUtil.invoke(obj, "parse", value);
    68| 				return obj;
    69| 			}
    70| 		}
    71| 		if(value instanceof Map ||
    72| 				value instanceof ValueProvider ||
    73| 				BeanUtil.isBean(value.getClass())) {
    74| 			if(value instanceof Map && this.beanClass.isInterface()) {
    75| 				return MapProxy.create((Map<?, ?>)value).toProxyBean(this.beanClass);
    76| 			}
    77| 			return BeanCopier.create(value, ReflectUtil.newInstanceIfPossible(this.beanClass), this.beanType, this.copyOptions).copy();
    78| 		} else if(value instanceof byte[]){
    79| 			return ObjectUtil.deserialize((byte[])value);
    80| 		} else if(StrUtil.isEmptyIfStr(value)){
    81| 			return null;
    82| 		}
    83| 		throw new ConvertException("Unsupported source type: {}", value.getClass());
    84| 	}
    85| 	@Override
    86| 	public Class<T> getTargetType() {
    87| 		return this.beanClass;
    88| 	}
    89| }


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/date/DateUtil.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 746-786 ---
   746| 	 * <li>yyyy-MM-dd'T'HH:mm:ssZ</li>
   747| 	 * <li>yyyy-MM-dd'T'HH:mm:ss.SSSZ</li>
   748| 	 * <li>yyyy-MM-dd'T'HH:mm:ss+0800</li>
   749| 	 * <li>yyyy-MM-dd'T'HH:mm:ss+08:00</li>
   750| 	 * </ol>
   751| 	 *
   752| 	 * @param utcString UTC时间
   753| 	 * @return 日期对象
   754| 	 * @since 4.1.14
   755| 	 */
   756| 	public static DateTime parseUTC(String utcString) {
   757| 		if (utcString == null) {
   758| 			return null;
   759| 		}
   760| 		final int length = utcString.length();
   761| 		if (StrUtil.contains(utcString, 'Z')) {
   762| 			if (length == DatePattern.UTC_PATTERN.length() - 4) {
   763| 				return parse(utcString, DatePattern.UTC_FORMAT);
   764| 			}
   765| 			final int patternLength = DatePattern.UTC_MS_PATTERN.length();
   766| 			if (length <= patternLength && length >= patternLength - 6) {
   767| 				return parse(utcString, DatePattern.UTC_MS_FORMAT);
   768| 			}
   769| 		} else if (StrUtil.contains(utcString, '+')) {
   770| 			utcString = utcString.replace(" +", "+");
   771| 			final String zoneOffset = StrUtil.subAfter(utcString, '+', true);
   772| 			if (StrUtil.isBlank(zoneOffset)) {
   773| 				throw new DateException("Invalid format: [{}]", utcString);
   774| 			}
   775| 			if (false == StrUtil.contains(zoneOffset, ':')) {
   776| 				final String pre = StrUtil.subBefore(utcString, '+', true);
   777| 				utcString = pre + "+" + zoneOffset.substring(0, 2) + ":" + "00";
   778| 			}
   779| 			if (StrUtil.contains(utcString, CharUtil.DOT)) {
   780| 				utcString = normalizeMillSeconds(utcString, ".", "+");
   781| 				return parse(utcString, DatePattern.UTC_MS_WITH_XXX_OFFSET_FORMAT);
   782| 			} else {
   783| 				return parse(utcString, DatePattern.UTC_WITH_XXX_OFFSET_FORMAT);
   784| 			}
   785| 		} else if(ReUtil.contains("-\\d{2}:?00", utcString)){
   786| 			utcString = utcString.replace(" -", "-");


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/io/FileTypeUtil.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 52-136 ---
    52| 					return fileTypeEntry.getValue();
    53| 				}
    54| 			}
    55| 		}
    56| 		byte[] bytes = (HexUtil.decodeHex(fileStreamHexHead));
    57| 		return FileMagicNumber.getMagicNumber(bytes).getExtension();
    58| 	}
    59| 	/**
    60| 	 * 根据文件流的头部信息获得文件类型
    61| 	 *
    62| 	 * @param in 文件流
    63| 	 * @param fileHeadSize 自定义读取文件头部的大小
    64| 	 * @return 文件类型，未找到为{@code null}
    65| 	 */
    66| 	public static String getType(InputStream in,int fileHeadSize) throws IORuntimeException  {
    67| 		return getType((IoUtil.readHex(in, fileHeadSize,false)));
    68| 	}
    69| 	/**
    70| 	 * 根据文件流的头部信息获得文件类型<br>
    71| 	 * 注意此方法会读取头部一些bytes，造成此流接下来读取时缺少部分bytes<br>
    72| 	 * 因此如果想复用此流，流需支持{@link InputStream#reset()}方法。
    73| 	 * @param in {@link InputStream}
    74| 	 * @param isExact 是否精确匹配，如果为false，使用前64个bytes匹配，如果为true，使用前8192bytes匹配
    75| 	 * @return 类型，文件的扩展名，未找到为{@code null}
    76| 	 * @throws IORuntimeException  读取流引起的异常
    77| 	 */
    78| 	public static String getType(InputStream in,boolean isExact) throws  IORuntimeException  {
    79| 		return isExact
    80| 				?getType(IoUtil.readHex8192Upper(in))
    81| 				:getType(IoUtil.readHex64Upper(in));
    82| 	}
    83| 	/**
    84| 	 * 根据文件流的头部信息获得文件类型<br>
    85| 	 * 注意此方法会读取头部64个bytes，造成此流接下来读取时缺少部分bytes<br>
    86| 	 * 因此如果想复用此流，流需支持{@link InputStream#reset()}方法。
    87| 	 * @param in {@link InputStream}
    88| 	 * @return 类型，文件的扩展名，未找到为{@code null}
    89| 	 * @throws IORuntimeException  读取流引起的异常
    90| 	 */
    91| 	public static String getType(InputStream in) throws IORuntimeException  {
    92| 		return getType(in,false);
    93| 	}
    94| 	/**
    95| 	 * 根据文件流的头部信息获得文件类型
    96| 	 * 注意此方法会读取头部64个bytes，造成此流接下来读取时缺少部分bytes<br>
    97| 	 * 因此如果想复用此流，流需支持{@link InputStream#reset()}方法。
    98| 	 *
    99| 	 * <pre>
   100| 	 *     1、无法识别类型默认按照扩展名识别
   101| 	 *     2、xls、doc、msi头信息无法区分，按照扩展名区分
   102| 	 *     3、zip可能为docx、xlsx、pptx、jar、war、ofd头信息无法区分，按照扩展名区分
   103| 	 * </pre>
   104| 	 *
   105| 	 * @param in       {@link InputStream}
   106| 	 * @param filename 文件名
   107| 	 * @return 类型，文件的扩展名，未找到为{@code null}
   108| 	 * @throws IORuntimeException  读取流引起的异常
   109| 	 */
   110| 	public static String getType(InputStream in, String filename) throws IORuntimeException  {
   111| 		return getType(in,filename,false);
   112| 	}
   113| 	/**
   114| 	 * 根据文件流的头部信息获得文件类型
   115| 	 * 注意此方法会读取头部一些bytes，造成此流接下来读取时缺少部分bytes<br>
   116| 	 * 因此如果想复用此流，流需支持{@link InputStream#reset()}方法。
   117| 	 *
   118| 	 * <pre>
   119| 	 *     1、无法识别类型默认按照扩展名识别
   120| 	 *     2、xls、doc、msi头信息无法区分，按照扩展名区分
   121| 	 *     3、zip可能为docx、xlsx、pptx、jar、war、ofd头信息无法区分，按照扩展名区分
   122| 	 * </pre>
   123| 	 * @param in       {@link InputStream}
   124| 	 * @param filename 文件名
   125| 	 * @param isExact 是否精确匹配，如果为false，使用前64个bytes匹配，如果为true，使用前8192bytes匹配
   126| 	 * @return 类型，文件的扩展名，未找到为{@code null}
   127| 	 * @throws IORuntimeException  读取流引起的异常
   128| 	 */
   129| 	public static String getType(InputStream in, String filename,boolean isExact) throws IORuntimeException  {
   130| 		String typeName = getType(in,isExact);
   131| 		if (null == typeName) {
   132| 			typeName = FileUtil.extName(filename);
   133| 		} else if ("zip".equals(typeName)) {
   134| 			final String extName = FileUtil.extName(filename);
   135| 			if ("docx".equalsIgnoreCase(extName)) {
   136| 				typeName = "docx";


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/io/file/PathUtil.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 553-594 ---
   553| 	 *
   554| 	 * @param path 文件或目录Path
   555| 	 * @return 转换后的Path
   556| 	 * @since 5.5.5
   557| 	 */
   558| 	public static Path toAbsNormal(Path path) {
   559| 		Assert.notNull(path);
   560| 		return path.toAbsolutePath().normalize();
   561| 	}
   562| 	/**
   563| 	 * 获得文件的MimeType
   564| 	 *
   565| 	 * @param file 文件
   566| 	 * @return MimeType
   567| 	 * @see Files#probeContentType(Path)
   568| 	 * @since 5.5.5
   569| 	 */
   570| 	public static String getMimeType(Path file) {
   571| 		try {
   572| 			return Files.probeContentType(file);
   573| 		} catch (IOException ignore) {
   574| 			return null;
   575| 		}
   576| 	}
   577| 	/**
   578| 	 * 创建所给目录及其父目录
   579| 	 *
   580| 	 * @param dir 目录
   581| 	 * @return 目录
   582| 	 * @since 5.5.7
   583| 	 */
   584| 	public static Path mkdir(Path dir) {
   585| 		if (null != dir && false == exists(dir, false)) {
   586| 			try {
   587| 				Files.createDirectories(dir);
   588| 			} catch (IOException e) {
   589| 				throw new IORuntimeException(e);
   590| 			}
   591| 		}
   592| 		return dir;
   593| 	}
   594| 	/**


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/io/resource/UrlResource.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| package cn.hutool.core.io.resource;
     2| import cn.hutool.core.io.FileUtil;
     3| import cn.hutool.core.io.IORuntimeException;
     4| import cn.hutool.core.util.ObjectUtil;
     5| import cn.hutool.core.util.URLUtil;
     6| import java.io.*;
     7| import java.net.URI;
     8| import java.net.URL;
     9| import java.net.URLConnection;
    10| /**
    11|  * URL资源访问类
    12|  * @author Looly
    13|  *
    14|  */
    15| public class UrlResource implements Resource, Serializable{
    16| 	private static final long serialVersionUID = 1L;
    17| 	protected URL url;
    18| 	private long lastModified = 0;
    19| 	protected String name;
    20| 	/**
    21| 	 * 构造
    22| 	 * @param uri URI
    23| 	 * @since 5.7.21
    24| 	 */
    25| 	public UrlResource(URI uri) {
    26| 		this(URLUtil.url(uri), null);
    27| 	}
    28| 	/**
    29| 	 * 构造

# --- HUNK 2: Lines 70-99 ---
    70| 	}
    71| 	@Override
    72| 	public boolean isModified() {
    73| 		return (0 != this.lastModified) && this.lastModified != getFile().lastModified();
    74| 	}
    75| 	/**
    76| 	 * 获得File
    77| 	 * @return {@link File}
    78| 	 */
    79| 	public File getFile(){
    80| 		return FileUtil.file(this.url);
    81| 	}
    82| 	/**
    83| 	 * 返回路径
    84| 	 * @return 返回URL路径
    85| 	 */
    86| 	@Override
    87| 	public String toString() {
    88| 		return (null == this.url) ? "null" : this.url.toString();
    89| 	}
    90| 	/**
    91| 	 * 获取资源长度
    92| 	 *
    93| 	 * @return 资源长度
    94| 	 * @since 5.8.21
    95| 	 */
    96| 	public long size() {
    97| 		return URLUtil.size(this.url);
    98| 	}
    99| }


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/map/MapUtil.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| package cn.hutool.core.map;
     2| import cn.hutool.core.collection.CollUtil;
     3| import cn.hutool.core.convert.Convert;
     4| import cn.hutool.core.exceptions.UtilException;
     5| import cn.hutool.core.lang.*;
     6| import cn.hutool.core.stream.CollectorUtil;
     7| import cn.hutool.core.util.ArrayUtil;
     8| import cn.hutool.core.util.JdkUtil;
     9| import cn.hutool.core.util.ReflectUtil;
    10| import cn.hutool.core.util.StrUtil;
    11| import java.util.AbstractMap;
    12| import java.util.ArrayList;
    13| import java.util.Collections;
    14| import java.util.Comparator;
    15| import java.util.Date;
    16| import java.util.HashMap;
    17| import java.util.IdentityHashMap;
    18| import java.util.Iterator;
    19| import java.util.LinkedHashMap;
    20| import java.util.List;
    21| import java.util.Map;
    22| import java.util.Map.Entry;
    23| import java.util.NavigableMap;
    24| import java.util.Set;
    25| import java.util.SortedMap;

# --- HUNK 2: Lines 616-658 ---
   616| 	 * </pre>
   617| 	 *
   618| 	 * @param <K>    Key类型
   619| 	 * @param <V>    Value类型
   620| 	 * @param map    Map
   621| 	 * @param editor 编辑器接口
   622| 	 * @return 编辑后的Map
   623| 	 */
   624| 	@SuppressWarnings("unchecked")
   625| 	public static <K, V> Map<K, V> edit(Map<K, V> map, Editor<Entry<K, V>> editor) {
   626| 		if (null == map || null == editor) {
   627| 			return map;
   628| 		}
   629| 		Map<K, V> map2 = ReflectUtil.newInstanceIfPossible(map.getClass());
   630| 		if (null == map2) {
   631| 			map2 = new HashMap<>(map.size(), 1f);
   632| 		}
   633| 		if (isEmpty(map)) {
   634| 			return map2;
   635| 		}
   636| 		if(false == map2.isEmpty()){
   637| 			map2.clear();
   638| 		}
   639| 		Entry<K, V> modified;
   640| 		for (Entry<K, V> entry : map.entrySet()) {
   641| 			modified = editor.edit(entry);
   642| 			if (null != modified) {
   643| 				map2.put(modified.getKey(), modified.getValue());
   644| 			}
   645| 		}
   646| 		return map2;
   647| 	}
   648| 	/**
   649| 	 * 过滤<br>
   650| 	 * 过滤过程通过传入的Editor实现来返回需要的元素内容，这个Filter实现可以实现以下功能：
   651| 	 *
   652| 	 * <pre>
   653| 	 * 1、过滤出需要的对象，如果返回null表示这个元素对象抛弃
   654| 	 * </pre>
   655| 	 *
   656| 	 * @param <K>    Key类型
   657| 	 * @param <V>    Value类型
   658| 	 * @param map    Map

# --- HUNK 3: Lines 688-730 ---
   688| 	 * 过滤Map保留指定键值对，如果键不存在跳过
   689| 	 *
   690| 	 * @param <K>  Key类型
   691| 	 * @param <V>  Value类型
   692| 	 * @param map  原始Map
   693| 	 * @param keys 键列表，{@code null}返回原Map
   694| 	 * @return Map 结果，结果的Map类型与原Map保持一致
   695| 	 * @since 4.0.10
   696| 	 */
   697| 	@SuppressWarnings("unchecked")
   698| 	public static <K, V> Map<K, V> filter(Map<K, V> map, K... keys) {
   699| 		if (null == map || null == keys) {
   700| 			return map;
   701| 		}
   702| 		Map<K, V> map2 = ReflectUtil.newInstanceIfPossible(map.getClass());
   703| 		if (null == map2) {
   704| 			map2 = new HashMap<>(map.size(), 1f);
   705| 		}
   706| 		if (isEmpty(map)) {
   707| 			return map2;
   708| 		}
   709| 		if(false == map2.isEmpty()){
   710| 			map2.clear();
   711| 		}
   712| 		for (K key : keys) {
   713| 			if (map.containsKey(key)) {
   714| 				map2.put(key, map.get(key));
   715| 			}
   716| 		}
   717| 		return map2;
   718| 	}
   719| 	/**
   720| 	 * Map的键和值互换
   721| 	 * 互换键值对不检查值是否有重复，如果有则后加入的元素替换先加入的元素<br>
   722| 	 * 值的顺序在HashMap中不确定，所以谁覆盖谁也不确定，在有序的Map中按照先后顺序覆盖，保留最后的值
   723| 	 *
   724| 	 * @param <T> 键和值类型
   725| 	 * @param map Map对象，键值类型必须一致
   726| 	 * @return 互换后的Map
   727| 	 * @see #inverse(Map)
   728| 	 * @since 3.2.2
   729| 	 */
   730| 	public static <T> Map<T, T> reverse(Map<T, T> map) {


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/math/Calculator.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-21 ---
     1| package cn.hutool.core.math;
     2| import cn.hutool.core.util.NumberUtil;
     3| import cn.hutool.core.util.StrUtil;
     4| import java.math.BigDecimal;
     5| import java.util.Collections;
     6| import java.util.Stack;
     7| /**
     8|  * 数学表达式计算工具类<br>
     9|  * 见：https://github.com/dromara/hutool/issues/1090#issuecomment-693750140
    10|  *
    11|  * @author trainliang, looly
    12|  * @since 5.4.3
    13|  */
    14| public class Calculator {
    15| 	private final Stack<String> postfixStack = new Stack<>();// 后缀式栈
    16| 	private final int[] operatPriority = new int[]{0, 3, 2, 1, -1, 1, 0, 2};// 运用运算符ASCII码-40做索引的运算符优先级
    17| 	/**
    18| 	 * 计算表达式的值
    19| 	 *
    20| 	 * @param expression 表达式
    21| 	 * @return 计算结果


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/net/Ipv4Util.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-28 ---
     1| package cn.hutool.core.net;
     2| import cn.hutool.core.collection.ListUtil;
     3| import cn.hutool.core.convert.Convert;
     4| import cn.hutool.core.lang.Assert;
     5| import cn.hutool.core.lang.PatternPool;
     6| import cn.hutool.core.lang.Validator;
     7| import cn.hutool.core.util.CharUtil;
     8| import cn.hutool.core.util.ReUtil;
     9| import cn.hutool.core.util.StrUtil;
    10| import java.util.ArrayList;
    11| import java.util.List;
    12| import java.util.Objects;
    13| import java.util.regex.Matcher;
    14| /**
    15|  * IPV4地址工具类
    16|  *
    17|  * <p>pr自：https://gitee.com/loolly/hutool/pulls/161</p>
    18|  *
    19|  * @author ZhuKun
    20|  * @since 5.4.1
    21|  */
    22| public class Ipv4Util {
    23| 	public static final String LOCAL_IP = "127.0.0.1";
    24| 	/**
    25| 	 * IP段的分割符
    26| 	 */
    27| 	public static final String IP_SPLIT_MARK = "-";
    28| 	/**

# --- HUNK 2: Lines 301-364 ---
   301| 	 * </pre>
   302| 	 * 当然，还有127这个网段是环回地址
   303| 	 *
   304| 	 * @param ipAddress IP地址
   305| 	 * @return 是否为内网IP
   306| 	 * @since 5.7.18
   307| 	 */
   308| 	public static boolean isInnerIP(String ipAddress) {
   309| 		boolean isInnerIp;
   310| 		long ipNum = ipv4ToLong(ipAddress);
   311| 		long aBegin = ipv4ToLong("10.0.0.0");
   312| 		long aEnd = ipv4ToLong("10.255.255.255");
   313| 		long bBegin = ipv4ToLong("172.16.0.0");
   314| 		long bEnd = ipv4ToLong("172.31.255.255");
   315| 		long cBegin = ipv4ToLong("192.168.0.0");
   316| 		long cEnd = ipv4ToLong("192.168.255.255");
   317| 		isInnerIp = isInner(ipNum, aBegin, aEnd) || isInner(ipNum, bBegin, bEnd) || isInner(ipNum, cBegin, cEnd) || LOCAL_IP.equals(ipAddress);
   318| 		return isInnerIp;
   319| 	}
   320| 	/**
   321| 	 * 检测指定 IP 地址是否匹配通配符 wildcard
   322| 	 *
   323| 	 * @param wildcard   通配符，如 192.168.*.1
   324| 	 * @param ipAddress 待检测的 IP 地址
   325| 	 * @return 是否匹配
   326| 	 */
   327| 	public static boolean matches(String wildcard, String ipAddress) {
   328| 		if (false == ReUtil.isMatch(PatternPool.IPV4, ipAddress)) {
   329| 			return false;
   330| 		}
   331| 		final String[] wildcardSegments = wildcard.split("\\.");
   332| 		final String[] ipSegments = ipAddress.split("\\.");
   333| 		if (wildcardSegments.length != ipSegments.length) {
   334| 			return false;
   335| 		}
   336| 		for (int i = 0; i < wildcardSegments.length; i++) {
   337| 			if (false == "*".equals(wildcardSegments[i])
   338| 				&& false == wildcardSegments[i].equals(ipSegments[i])) {
   339| 				return false;
   340| 			}
   341| 		}
   342| 		return true;
   343| 	}
   344| 	/**
   345| 	 * 根据 ip/掩码位 计算IP段的终止IP（Long型）
   346| 	 * 注：此接口返回负数，请使用转成字符串后再转Long型
   347| 	 *
   348| 	 * @param ip      给定的IP，如218.240.38.69
   349| 	 * @param maskBit 给定的掩码位，如30
   350| 	 * @return 终止IP的长整型表示
   351| 	 */
   352| 	public static Long getEndIpLong(String ip, int maskBit) {
   353| 		return getBeginIpLong(ip, maskBit)
   354| 				+ ~ipv4ToLong(getMaskByMaskBit(maskBit));
   355| 	}
   356| 	/**
   357| 	 * 将匹配到的Ipv4地址的4个分组分别处理
   358| 	 *
   359| 	 * @param matcher 匹配到的Ipv4正则
   360| 	 * @return ipv4对应long
   361| 	 */
   362| 	private static long matchAddress(Matcher matcher) {
   363| 		long addr = 0;
   364| 		for (int i = 1; i <= 4; ++i) {


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/util/DesensitizedUtil.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 271-342 ---
   271| 	 * eg1：""         -》 ""
   272| 	 * eg3：苏D40000   -》 苏D4***0
   273| 	 * eg4：陕A12345D  -》 陕A1****D
   274| 	 * eg5：京A123     -》 京A123     如果是错误的车牌，不处理
   275| 	 *
   276| 	 * @param carLicense 完整的车牌号
   277| 	 * @return 脱敏后的车牌
   278| 	 */
   279| 	public static String carLicense(String carLicense) {
   280| 		if (StrUtil.isBlank(carLicense)) {
   281| 			return StrUtil.EMPTY;
   282| 		}
   283| 		if (carLicense.length() == 7) {
   284| 			carLicense = StrUtil.hide(carLicense, 3, 6);
   285| 		} else if (carLicense.length() == 8) {
   286| 			carLicense = StrUtil.hide(carLicense, 3, 7);
   287| 		}
   288| 		return carLicense;
   289| 	}
   290| 	/**
   291| 	 * 【银行卡号脱敏】由于银行卡号长度不定，所以只展示前4位，后面的位数根据卡号决定展示1-4位
   292| 	 *  例如：
   293| 	 *  <pre>{@code
   294| 	 *      1. "1234 2222 3333 4444 6789 9"    ->   "1234 **** **** **** **** 9"
   295| 	 *      2. "1234 2222 3333 4444 6789 91"   ->   "1234 **** **** **** **** 91"
   296| 	 *      3. "1234 2222 3333 4444 678"       ->    "1234 **** **** **** 678"
   297| 	 *      4. "1234 2222 3333 4444 6789"      ->    "1234 **** **** **** 6789"
   298| 	 *  }</pre>
   299| 	 *
   300| 	 * @param bankCardNo 银行卡号
   301| 	 * @return 脱敏之后的银行卡号
   302| 	 */
   303| 	public static String bankCard(String bankCardNo) {
   304| 		if (StrUtil.isBlank(bankCardNo)) {
   305| 			return bankCardNo;
   306| 		}
   307| 		bankCardNo = StrUtil.cleanBlank(bankCardNo);
   308| 		if (bankCardNo.length() < 9) {
   309| 			return bankCardNo;
   310| 		}
   311| 		final int length = bankCardNo.length();
   312| 		final int endLength= length % 4 == 0 ? 4 : length % 4;
   313| 		final int midLength = length - 4 - endLength;
   314| 		final StringBuilder buf = new StringBuilder();
   315| 		buf.append(bankCardNo, 0, 4);
   316| 		for (int i = 0; i < midLength; ++i) {
   317| 			if (i % 4 == 0) {
   318| 				buf.append(CharUtil.SPACE);
   319| 			}
   320| 			buf.append('*');
   321| 		}
   322| 		buf.append(CharUtil.SPACE).append(bankCardNo, length - endLength, length);
   323| 		return buf.toString();
   324| 	}
   325| 	/**
   326| 	 * IPv4脱敏，如：脱敏前：192.0.2.1；脱敏后：192.*.*.*。
   327| 	 *
   328| 	 * @param ipv4 IPv4地址
   329| 	 * @return 脱敏后的地址
   330| 	 */
   331| 	public static String ipv4(String ipv4) {
   332| 		return StrUtil.subBefore(ipv4, '.', false) + ".*.*.*";
   333| 	}
   334| 	/**
   335| 	 * IPv4脱敏，如：脱敏前：2001:0db8:86a3:08d3:1319:8a2e:0370:7344；脱敏后：2001:*:*:*:*:*:*:*
   336| 	 *
   337| 	 * @param ipv6 IPv4地址
   338| 	 * @return 脱敏后的地址
   339| 	 */
   340| 	public static String ipv6(String ipv6) {
   341| 		return StrUtil.subBefore(ipv6, ':', false) + ":*:*:*:*:*:*:*";
   342| 	}


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/util/IdcardUtil.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 236-305 ---
   236| 	 * <li>第15、16位数字表示：所在地的派出所的代码</li>
   237| 	 * <li>第17位数字表示性别：奇数表示男性，偶数表示女性</li>
   238| 	 * <li>第18位数字是校检码，用来检验身份证的正确性。校检码可以是0~9的数字，有时也用x表示</li>
   239| 	 * </ol>
   240| 	 * <p>
   241| 	 * 第十八位数字(校验码)的计算方法为：
   242| 	 * <ol>
   243| 	 * <li>将前面的身份证号码17位数分别乘以不同的系数。从第一位到第十七位的系数分别为：7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2</li>
   244| 	 * <li>将这17位数字和系数相乘的结果相加</li>
   245| 	 * <li>用加出来和除以11，看余数是多少</li>
   246| 	 * <li>余数只可能有0 1 2 3 4 5 6 7 8 9 10这11个数字。其分别对应的最后一位身份证的号码为1 0 X 9 8 7 6 5 4 3 2</li>
   247| 	 * <li>通过上面得知如果余数是2，就会在身份证的第18位数字上出现罗马数字的Ⅹ。如果余数是10，身份证的最后一位号码就是2</li>
   248| 	 * </ol>
   249| 	 *
   250| 	 * @param idcard     待验证的身份证
   251| 	 * @param ignoreCase 是否忽略大小写。{@code true}则忽略X大小写，否则严格匹配大写。
   252| 	 * @return 是否有效的18位身份证
   253| 	 * @since 5.5.7
   254| 	 */
   255| 	public static boolean isValidCard18(String idcard, boolean ignoreCase) {
   256| 		if (idcard == null) {
   257| 			return false;
   258| 		}
   259| 		if (CHINA_ID_MAX_LENGTH != idcard.length()) {
   260| 			return false;
   261| 		}
   262| 		final String proCode = idcard.substring(0, 2);
   263| 		if (null == CITY_CODES.get(proCode)) {
   264| 			return false;
   265| 		}
   266| 		if (false == Validator.isBirthday(idcard.substring(6, 14))) {
   267| 			return false;
   268| 		}
   269| 		final String code17 = idcard.substring(0, 17);
   270| 		if (ReUtil.isMatch(PatternPool.NUMBERS, code17)) {
   271| 			char val = getCheckCode18(code17);
   272| 			return CharUtil.equals(val, idcard.charAt(17), ignoreCase);
   273| 		}
   274| 		return false;
   275| 	}
   276| 	/**
   277| 	 * 验证15位身份编码是否合法
   278| 	 *
   279| 	 * @param idcard 身份编码
   280| 	 * @return 是否合法
   281| 	 */
   282| 	public static boolean isValidCard15(String idcard) {
   283| 		if (idcard == null) {
   284| 			return false;
   285| 		}
   286| 		if (CHINA_ID_MIN_LENGTH != idcard.length()) {
   287| 			return false;
   288| 		}
   289| 		if (ReUtil.isMatch(PatternPool.NUMBERS, idcard)) {
   290| 			String proCode = idcard.substring(0, 2);
   291| 			if (null == CITY_CODES.get(proCode)) {
   292| 				return false;
   293| 			}
   294| 			return false != Validator.isBirthday("19" + idcard.substring(6, 12));
   295| 		} else {
   296| 			return false;
   297| 		}
   298| 	}
   299| 	/**
   300| 	 * 验证10位身份编码是否合法
   301| 	 *
   302| 	 * @param idcard 身份编码
   303| 	 * @return 身份证信息数组
   304| 	 * <p>
   305| 	 * [0] - 台湾、澳门、香港 [1] - 性别(男M,女F,未知N) [2] - 是否合法(合法true,不合法false) 若不是身份证件号码则返回null


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/util/RandomUtil.java
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 1-662 ---
     1| package cn.hutool.core.util;
     2| import cn.hutool.core.collection.CollUtil;
     3| import cn.hutool.core.collection.ListUtil;
     4| import cn.hutool.core.date.DateField;
     5| import cn.hutool.core.date.DateTime;
     6| import cn.hutool.core.date.DateUtil;
     7| import cn.hutool.core.exceptions.UtilException;
     8| import cn.hutool.core.lang.WeightRandom;
     9| import cn.hutool.core.lang.WeightRandom.WeightObj;
    10| import java.math.BigDecimal;
    11| import java.math.RoundingMode;
    12| import java.security.NoSuchAlgorithmException;
    13| import java.security.SecureRandom;
    14| import java.util.*;
    15| import java.util.concurrent.ThreadLocalRandom;
    16| /**
    17|  * 随机工具类
    18|  *
    19|  * @author xiaoleilu
    20|  */
    21| public class RandomUtil {
    22| 	/**
    23| 	 * 用于随机选的数字
    24| 	 */
    25| 	public static final String BASE_NUMBER = "0123456789";
    26| 	/**
    27| 	 * 用于随机选的字符
    28| 	 */
    29| 	public static final String BASE_CHAR = "abcdefghijklmnopqrstuvwxyz";
    30| 	/**
    31| 	 * 用于随机选的字符和数字（小写）
    32| 	 */
    33| 	public static final String BASE_CHAR_NUMBER_LOWER = BASE_CHAR + BASE_NUMBER;
    34| 	/**
    35| 	 * 用于随机选的字符和数字（包括大写和小写字母）
    36| 	 */
    37| 	public static final String BASE_CHAR_NUMBER = BASE_CHAR.toUpperCase() + BASE_CHAR_NUMBER_LOWER;
    38| 	/**
    39| 	 * 获取随机数生成器对象<br>
    40| 	 * ThreadLocalRandom是JDK 7之后提供并发产生随机数，能够解决多个线程发生的竞争争夺。
    41| 	 *
    42| 	 * <p>
    43| 	 * 注意：此方法返回的{@link ThreadLocalRandom}不可以在多线程环境下共享对象，否则有重复随机数问题。
    44| 	 * 见：https://www.jianshu.com/p/89dfe990295c
    45| 	 * </p>
    46| 	 *
    47| 	 * @return {@link ThreadLocalRandom}
    48| 	 * @since 3.1.2
    49| 	 */
    50| 	public static ThreadLocalRandom getRandom() {
    51| 		return ThreadLocalRandom.current();
    52| 	}
    53| 	/**
    54| 	 * 创建{@link SecureRandom}，类提供加密的强随机数生成器 (RNG)<br>
    55| 	 *
    56| 	 * @param seed 自定义随机种子
    57| 	 * @return {@link SecureRandom}
    58| 	 * @since 4.6.5
    59| 	 */
    60| 	public static SecureRandom createSecureRandom(final byte[] seed) {
    61| 		return (null == seed) ? new SecureRandom() : new SecureRandom(seed);
    62| 	}
    63| 	/**
    64| 	 * 获取SHA1PRNG的{@link SecureRandom}，类提供加密的强随机数生成器 (RNG)<br>
    65| 	 * 注意：此方法获取的是伪随机序列发生器PRNG（pseudo-random number generator）
    66| 	 *
    67| 	 * <p>
    68| 	 * 相关说明见：https://stackoverflow.com/questions/137212/how-to-solve-slow-java-securerandom
    69| 	 *
    70| 	 * @return {@link SecureRandom}
    71| 	 * @since 3.1.2
    72| 	 */
    73| 	public static SecureRandom getSecureRandom() {
    74| 		return getSecureRandom(null);
    75| 	}
    76| 	/**
    77| 	 * 获取SHA1PRNG的{@link SecureRandom}，类提供加密的强随机数生成器 (RNG)<br>
    78| 	 * 注意：此方法获取的是伪随机序列发生器PRNG（pseudo-random number generator）
    79| 	 *
    80| 	 * <p>
    81| 	 * 相关说明见：https://stackoverflow.com/questions/137212/how-to-solve-slow-java-securerandom
    82| 	 *
    83| 	 * @param seed 随机数种子
    84| 	 * @return {@link SecureRandom}
    85| 	 * @see #createSecureRandom(byte[])
    86| 	 * @since 5.5.2
    87| 	 */
    88| 	public static SecureRandom getSecureRandom(final byte[] seed) {
    89| 		return createSecureRandom(seed);
    90| 	}
    91| 	/**
    92| 	 * 获取SHA1PRNG的{@link SecureRandom}，类提供加密的强随机数生成器 (RNG)<br>
    93| 	 * 注意：此方法获取的是伪随机序列发生器PRNG（pseudo-random number generator）,在Linux下噪声生成时可能造成较长时间停顿。<br>
    94| 	 * see: http://ifeve.com/jvm-random-and-entropy-source/
    95| 	 *
    96| 	 * <p>
    97| 	 * 相关说明见：https://stackoverflow.com/questions/137212/how-to-solve-slow-java-securerandom
    98| 	 *
    99| 	 * @param seed 随机数种子
   100| 	 * @return {@link SecureRandom}
   101| 	 * @since 5.5.8
   102| 	 */
   103| 	public static SecureRandom getSHA1PRNGRandom(final byte[] seed) {
   104| 		final SecureRandom random;
   105| 		try {
   106| 			random = SecureRandom.getInstance("SHA1PRNG");
   107| 		} catch (final NoSuchAlgorithmException e) {
   108| 			throw new UtilException(e);
   109| 		}
   110| 		if (null != seed) {
   111| 			random.setSeed(seed);
   112| 		}
   113| 		return random;
   114| 	}
   115| 	/**
   116| 	 * 获取algorithms/providers中提供的强安全随机生成器<br>
   117| 	 * 注意：此方法可能造成阻塞或性能问题
   118| 	 *
   119| 	 * @return {@link SecureRandom}
   120| 	 * @since 5.7.12
   121| 	 */
   122| 	public static SecureRandom getSecureRandomStrong() {
   123| 		try {
   124| 			return SecureRandom.getInstanceStrong();
   125| 		} catch (final NoSuchAlgorithmException e) {
   126| 			throw new UtilException(e);
   127| 		}
   128| 	}
   129| 	/**
   130| 	 * 获取随机数产生器
   131| 	 *
   132| 	 * @param isSecure 是否为强随机数生成器 (RNG)
   133| 	 * @return {@link Random}
   134| 	 * @see #getSecureRandom()
   135| 	 * @see #getRandom()
   136| 	 * @since 4.1.15
   137| 	 */
   138| 	public static Random getRandom(final boolean isSecure) {
   139| 		return isSecure ? getSecureRandom() : getRandom();
   140| 	}
   141| 	/**
   142| 	 * 获得随机Boolean值
   143| 	 *
   144| 	 * @return true or false
   145| 	 * @since 4.5.9
   146| 	 */
   147| 	public static boolean randomBoolean() {
   148| 		return 0 == randomInt(2);
   149| 	}
   150| 	/**
   151| 	 * 随机bytes
   152| 	 *
   153| 	 * @param length 长度
   154| 	 * @return bytes
   155| 	 */
   156| 	public static byte[] randomBytes(final int length) {
   157| 		final byte[] bytes = new byte[length];
   158| 		getRandom().nextBytes(bytes);
   159| 		return bytes;
   160| 	}
   161| 	/**
   162| 	 * 获得随机数int值
   163| 	 *
   164| 	 * @return 随机数
   165| 	 * @see Random#nextInt()
   166| 	 */
   167| 	public static int randomInt() {
   168| 		return getRandom().nextInt();
   169| 	}
   170| 	/**
   171| 	 * 获得指定范围内的随机数 [0,limit)
   172| 	 *
   173| 	 * @param limitExclude 限制随机数的范围，不包括这个数
   174| 	 * @return 随机数
   175| 	 * @see Random#nextInt(int)
   176| 	 */
   177| 	public static int randomInt(final int limitExclude) {
   178| 		return getRandom().nextInt(limitExclude);
   179| 	}
   180| 	/**
   181| 	 * 获得指定范围内的随机数
   182| 	 *
   183| 	 * @param minInclude 最小数（包含）
   184| 	 * @param maxExclude 最大数（不包含）
   185| 	 * @return 随机数
   186| 	 */
   187| 	public static int randomInt(final int minInclude, final int maxExclude) {
   188| 		return randomInt(minInclude, maxExclude, true, false);
   189| 	}
   190| 	/**
   191| 	 * 获得指定范围内的随机数
   192| 	 *
   193| 	 * @param min        最小数
   194| 	 * @param max        最大数
   195| 	 * @param includeMin 是否包含最小值
   196| 	 * @param includeMax 是否包含最大值
   197| 	 * @return 随机数
   198| 	 */
   199| 	public static int randomInt(int min, int max, final boolean includeMin, final boolean includeMax) {
   200| 		if (!includeMin) {
   201| 			min++;
   202| 		}
   203| 		if (includeMax) {
   204| 			max--;
   205| 		}
   206| 		return getRandom().nextInt(min, max);
   207| 	}
   208| 	/**
   209| 	 * 创建指定长度的随机索引
   210| 	 *
   211| 	 * @param length 长度
   212| 	 * @return 随机索引
   213| 	 * @since 5.2.1
   214| 	 */
   215| 	public static int[] randomInts(final int length) {
   216| 		final int[] range = ArrayUtil.range(length);
   217| 		for (int i = 0; i < length; i++) {
   218| 			final int random = randomInt(i, length);
   219| 			ArrayUtil.swap(range, i, random);
   220| 		}
   221| 		return range;
   222| 	}
   223| 	/**
   224| 	 * 获得随机数
   225| 	 *
   226| 	 * @return 随机数
   227| 	 * @see ThreadLocalRandom#nextLong()
   228| 	 * @since 3.3.0
   229| 	 */
   230| 	public static long randomLong() {
   231| 		return getRandom().nextLong();
   232| 	}
   233| 	/**
   234| 	 * 获得指定范围内的随机数 [0,limit)
   235| 	 *
   236| 	 * @param limitExclude 限制随机数的范围，不包括这个数
   237| 	 * @return 随机数
   238| 	 * @see ThreadLocalRandom#nextLong(long)
   239| 	 */
   240| 	public static long randomLong(final long limitExclude) {
   241| 		return getRandom().nextLong(limitExclude);
   242| 	}
   243| 	/**
   244| 	 * 获得指定范围内的随机数[min, max)
   245| 	 *
   246| 	 * @param minInclude 最小数（包含）
   247| 	 * @param maxExclude 最大数（不包含）
   248| 	 * @return 随机数
   249| 	 * @see ThreadLocalRandom#nextLong(long, long)
   250| 	 * @since 3.3.0
   251| 	 */
   252| 	public static long randomLong(final long minInclude, final long maxExclude) {
   253| 		return randomLong(minInclude, maxExclude, true, false);
   254| 	}
   255| 	/**
   256| 	 * 获得指定范围内的随机数
   257| 	 *
   258| 	 * @param min        最小数
   259| 	 * @param max        最大数
   260| 	 * @param includeMin 是否包含最小值
   261| 	 * @param includeMax 是否包含最大值
   262| 	 * @return 随机数
   263| 	 */
   264| 	public static long randomLong(long min, long max, final boolean includeMin, final boolean includeMax) {
   265| 		if (!includeMin) {
   266| 			min++;
   267| 		}
   268| 		if (includeMax) {
   269| 			max--;
   270| 		}
   271| 		return getRandom().nextLong(min, max);
   272| 	}
   273| 	/**
   274| 	 * 获得随机数[0, 1)
   275| 	 *
   276| 	 * @return 随机数
   277| 	 * @see ThreadLocalRandom#nextFloat()
   278| 	 */
   279| 	public static float randomFloat() {
   280| 		return getRandom().nextFloat();
   281| 	}
   282| 	/**
   283| 	 * 获得指定范围内的随机数 [0,limit)
   284| 	 *
   285| 	 * @param limitExclude 限制随机数的范围，不包括这个数
   286| 	 * @return 随机数
   287| 	 */
   288| 	public static float randomFloat(final float limitExclude) {
   289| 		return randomFloat(0, limitExclude);
   290| 	}
   291| 	/**
   292| 	 * 获得指定范围内的随机数[min, max)
   293| 	 *
   294| 	 * @param minInclude 最小数（包含）
   295| 	 * @param maxExclude 最大数（不包含）
   296| 	 * @return 随机数
   297| 	 * @see ThreadLocalRandom#nextFloat()
   298| 	 */
   299| 	public static float randomFloat(final float minInclude, final float maxExclude) {
   300| 		if (minInclude == maxExclude) {
   301| 			return minInclude;
   302| 		}
   303| 		return minInclude + ((maxExclude - minInclude) * getRandom().nextFloat());
   304| 	}
   305| 	/**
   306| 	 * 获得指定范围内的随机数
   307| 	 *
   308| 	 * @param minInclude 最小数（包含）
   309| 	 * @param maxExclude 最大数（不包含）
   310| 	 * @return 随机数
   311| 	 * @see ThreadLocalRandom#nextDouble(double, double)
   312| 	 * @since 3.3.0
   313| 	 */
   314| 	public static double randomDouble(final double minInclude, final double maxExclude) {
   315| 		return getRandom().nextDouble(minInclude, maxExclude);
   316| 	}
   317| 	/**
   318| 	 * 获得指定范围内的随机数
   319| 	 *
   320| 	 * @param minInclude   最小数（包含）
   321| 	 * @param maxExclude   最大数（不包含）
   322| 	 * @param scale        保留小数位数
   323| 	 * @param roundingMode 保留小数的模式 {@link RoundingMode}
   324| 	 * @return 随机数
   325| 	 * @since 4.0.8
   326| 	 */
   327| 	public static double randomDouble(final double minInclude, final double maxExclude, final int scale,
   328| 									  final RoundingMode roundingMode) {
   329| 		return NumberUtil.round(randomDouble(minInclude, maxExclude), scale, roundingMode).doubleValue();
   330| 	}
   331| 	/**
   332| 	 * 获得随机数[0, 1)
   333| 	 *
   334| 	 * @return 随机数
   335| 	 * @see ThreadLocalRandom#nextDouble()
   336| 	 * @since 3.3.0
   337| 	 */
   338| 	public static double randomDouble() {
   339| 		return getRandom().nextDouble();
   340| 	}
   341| 	/**
   342| 	 * 获得指定范围内的随机数
   343| 	 *
   344| 	 * @param scale        保留小数位数
   345| 	 * @param roundingMode 保留小数的模式 {@link RoundingMode}
   346| 	 * @return 随机数
   347| 	 * @since 4.0.8
   348| 	 */
   349| 	public static double randomDouble(final int scale, final RoundingMode roundingMode) {
   350| 		return NumberUtil.round(randomDouble(), scale, roundingMode).doubleValue();
   351| 	}
   352| 	/**
   353| 	 * 获得指定范围内的随机数 [0,limit)
   354| 	 *
   355| 	 * @param limit 限制随机数的范围，不包括这个数
   356| 	 * @return 随机数
   357| 	 * @see ThreadLocalRandom#nextDouble(double)
   358| 	 * @since 3.3.0
   359| 	 */
   360| 	public static double randomDouble(final double limit) {
   361| 		return getRandom().nextDouble(limit);
   362| 	}
   363| 	/**
   364| 	 * 获得指定范围内的随机数
   365| 	 *
   366| 	 * @param limit        限制随机数的范围，不包括这个数
   367| 	 * @param scale        保留小数位数
   368| 	 * @param roundingMode 保留小数的模式 {@link RoundingMode}
   369| 	 * @return 随机数
   370| 	 * @since 4.0.8
   371| 	 */
   372| 	public static double randomDouble(final double limit, final int scale, final RoundingMode roundingMode) {
   373| 		return NumberUtil.round(randomDouble(limit), scale, roundingMode).doubleValue();
   374| 	}
   375| 	/**
   376| 	 * 获得指定范围内的随机数[0, 1)
   377| 	 *
   378| 	 * @return 随机数
   379| 	 * @since 4.0.9
   380| 	 */
   381| 	public static BigDecimal randomBigDecimal() {
   382| 		return NumberUtil.toBigDecimal(getRandom().nextDouble());
   383| 	}
   384| 	/**
   385| 	 * 获得指定范围内的随机数 [0,limit)
   386| 	 *
   387| 	 * @param limit 最大数（不包含）
   388| 	 * @return 随机数
   389| 	 * @since 4.0.9
   390| 	 */
   391| 	public static BigDecimal randomBigDecimal(final BigDecimal limit) {
   392| 		return NumberUtil.toBigDecimal(getRandom().nextDouble(limit.doubleValue()));
   393| 	}
   394| 	/**
   395| 	 * 获得指定范围内的随机数
   396| 	 *
   397| 	 * @param minInclude 最小数（包含）
   398| 	 * @param maxExclude 最大数（不包含）
   399| 	 * @return 随机数
   400| 	 * @since 4.0.9
   401| 	 */
   402| 	public static BigDecimal randomBigDecimal(final BigDecimal minInclude, final BigDecimal maxExclude) {
   403| 		return NumberUtil.toBigDecimal(getRandom().nextDouble(minInclude.doubleValue(), maxExclude.doubleValue()));
   404| 	}
   405| 	/**
   406| 	 * 随机获得列表中的元素
   407| 	 *
   408| 	 * @param <T>  元素类型
   409| 	 * @param list 列表
   410| 	 * @return 随机元素
   411| 	 */
   412| 	public static <T> T randomEle(final List<T> list) {
   413| 		return randomEle(list, list.size());
   414| 	}
   415| 	/**
   416| 	 * 随机获得列表中的元素
   417| 	 *
   418| 	 * @param <T>   元素类型
   419| 	 * @param list  列表
   420| 	 * @param limit 限制列表的前N项
   421| 	 * @return 随机元素
   422| 	 */
   423| 	public static <T> T randomEle(final List<T> list, int limit) {
   424| 		if (list.size() < limit) {
   425| 			limit = list.size();
   426| 		}
   427| 		return list.get(randomInt(limit));
   428| 	}
   429| 	/**
   430| 	 * 随机获得数组中的元素
   431| 	 *
   432| 	 * @param <T>   元素类型
   433| 	 * @param array 列表
   434| 	 * @return 随机元素
   435| 	 * @since 3.3.0
   436| 	 */
   437| 	public static <T> T randomEle(final T[] array) {
   438| 		return randomEle(array, array.length);
   439| 	}
   440| 	/**
   441| 	 * 随机获得数组中的元素
   442| 	 *
   443| 	 * @param <T>   元素类型
   444| 	 * @param array 列表
   445| 	 * @param limit 限制列表的前N项
   446| 	 * @return 随机元素
   447| 	 * @since 3.3.0
   448| 	 */
   449| 	public static <T> T randomEle(final T[] array, int limit) {
   450| 		if (array.length < limit) {
   451| 			limit = array.length;
   452| 		}
   453| 		return array[randomInt(limit)];
   454| 	}
   455| 	/**
   456| 	 * 随机获得列表中的一定量元素
   457| 	 *
   458| 	 * @param <T>   元素类型
   459| 	 * @param list  列表
   460| 	 * @param count 随机取出的个数
   461| 	 * @return 随机元素
   462| 	 */
   463| 	public static <T> List<T> randomEles(final List<T> list, final int count) {
   464| 		final List<T> result = new ArrayList<>(count);
   465| 		final int limit = list.size();
   466| 		while (result.size() < count) {
   467| 			result.add(randomEle(list, limit));
   468| 		}
   469| 		return result;
   470| 	}
   471| 	/**
   472| 	 * 随机获得列表中的一定量的元素，返回List<br>
   473| 	 * 此方法与{@link #randomEles(List, int)} 不同点在于，不会获取重复位置的元素
   474| 	 *
   475| 	 * @param source 列表
   476| 	 * @param count  随机取出的个数
   477| 	 * @param <T>    元素类型
   478| 	 * @return 随机列表
   479| 	 * @since 5.2.1
   480| 	 */
   481| 	public static <T> List<T> randomEleList(final List<T> source, final int count) {
   482| 		if (count >= source.size()) {
   483| 			return ListUtil.toList(source);
   484| 		}
   485| 		final int[] randomList = ArrayUtil.sub(randomInts(source.size()), 0, count);
   486| 		final List<T> result = new ArrayList<>();
   487| 		for (final int e : randomList) {
   488| 			result.add(source.get(e));
   489| 		}
   490| 		return result;
   491| 	}
   492| 	/**
   493| 	 * 随机获得列表中的一定量的不重复元素，返回Set
   494| 	 *
   495| 	 * @param <T>        元素类型
   496| 	 * @param collection 列表
   497| 	 * @param count      随机取出的个数
   498| 	 * @return 随机元素
   499| 	 * @throws IllegalArgumentException 需要的长度大于给定集合非重复总数
   500| 	 */
   501| 	public static <T> Set<T> randomEleSet(final Collection<T> collection, final int count) {
   502| 		final ArrayList<T> source = CollUtil.distinct(collection);
   503| 		if (count > source.size()) {
   504| 			throw new IllegalArgumentException("Count is larger than collection distinct size !");
   505| 		}
   506| 		final Set<T> result = new LinkedHashSet<>(count);
   507| 		final int limit = source.size();
   508| 		while (result.size() < count) {
   509| 			result.add(randomEle(source, limit));
   510| 		}
   511| 		return result;
   512| 	}
   513| 	/**
   514| 	 * 获得一个随机的字符串（只包含数字和字符）
   515| 	 *
   516| 	 * @param length 字符串的长度
   517| 	 * @return 随机字符串
   518| 	 */
   519| 	public static String randomString(final int length) {
   520| 		return randomString(BASE_CHAR_NUMBER, length);
   521| 	}
   522| 	/**
   523| 	 * 获得一个随机的字符串（只包含数字和大写字符）
   524| 	 *
   525| 	 * @param length 字符串的长度
   526| 	 * @return 随机字符串
   527| 	 * @since 4.0.13
   528| 	 */
   529| 	public static String randomStringUpper(final int length) {
   530| 		return randomString(BASE_CHAR_NUMBER, length).toUpperCase();
   531| 	}
   532| 	/**
   533| 	 * 获得一个随机的字符串（只包含数字和小写字母） 并排除指定字符串
   534| 	 *
   535| 	 * @param length   字符串的长度
   536| 	 * @param elemData 要排除的字符串,如：去重容易混淆的字符串，oO0、lL1、q9Q、pP，不区分大小写
   537| 	 * @return 随机字符串
   538| 	 */
   539| 	public static String randomStringWithoutStr(final int length, final String elemData) {
   540| 		String baseStr = BASE_CHAR_NUMBER;
   541| 		baseStr = StrUtil.removeAll(baseStr, elemData.toLowerCase().toCharArray());
   542| 		return randomString(baseStr, length);
   543| 	}
   544| 	/**
   545| 	 * 获得一个只包含数字的字符串
   546| 	 *
   547| 	 * @param length 字符串的长度
   548| 	 * @return 随机字符串
   549| 	 */
   550| 	public static String randomNumbers(final int length) {
   551| 		return randomString(BASE_NUMBER, length);
   552| 	}
   553| 	/**
   554| 	 * 获得一个随机的字符串
   555| 	 *
   556| 	 * @param baseString 随机字符选取的样本
   557| 	 * @param length     字符串的长度
   558| 	 * @return 随机字符串
   559| 	 */
   560| 	public static String randomString(final String baseString, int length) {
   561| 		if (StrUtil.isEmpty(baseString)) {
   562| 			return StrUtil.EMPTY;
   563| 		}
   564| 		if (length < 1) {
   565| 			length = 1;
   566| 		}
   567| 		final StringBuilder sb = new StringBuilder(length);
   568| 		final int baseLength = baseString.length();
   569| 		for (int i = 0; i < length; i++) {
   570| 			final int number = randomInt(baseLength);
   571| 			sb.append(baseString.charAt(number));
   572| 		}
   573| 		return sb.toString();
   574| 	}
   575| 	/**
   576| 	 * 随机汉字（'\u4E00'-'\u9FFF'）
   577| 	 *
   578| 	 * @return 随机的汉字字符
   579| 	 * @since 5.7.15
   580| 	 */
   581| 	@SuppressWarnings("UnnecessaryUnicodeEscape")
   582| 	public static char randomChinese() {
   583| 		return (char) randomInt('\u4E00', '\u9FFF');
   584| 	}
   585| 	/**
   586| 	 * 随机数字，数字为0~9单个数字
   587| 	 *
   588| 	 * @return 随机数字字符
   589| 	 * @since 3.1.2
   590| 	 */
   591| 	public static char randomNumber() {
   592| 		return randomChar(BASE_NUMBER);
   593| 	}
   594| 	/**
   595| 	 * 随机字母或数字，小写
   596| 	 *
   597| 	 * @return 随机字符
   598| 	 * @since 3.1.2
   599| 	 */
   600| 	public static char randomChar() {
   601| 		return randomChar(BASE_CHAR_NUMBER);
   602| 	}
   603| 	/**
   604| 	 * 随机字符
   605| 	 *
   606| 	 * @param baseString 随机字符选取的样本
   607| 	 * @return 随机字符
   608| 	 * @since 3.1.2
   609| 	 */
   610| 	public static char randomChar(final String baseString) {
   611| 		return baseString.charAt(randomInt(baseString.length()));
   612| 	}
   613| 	/**
   614| 	 * 带有权重的随机生成器
   615| 	 *
   616| 	 * @param <T>        随机对象类型
   617| 	 * @param weightObjs 带有权重的对象列表
   618| 	 * @return {@link WeightRandom}
   619| 	 * @since 4.0.3
   620| 	 */
   621| 	public static <T> WeightRandom<T> weightRandom(final WeightObj<T>[] weightObjs) {
   622| 		return new WeightRandom<>(weightObjs);
   623| 	}
   624| 	/**
   625| 	 * 带有权重的随机生成器
   626| 	 *
   627| 	 * @param <T>        随机对象类型
   628| 	 * @param weightObjs 带有权重的对象列表
   629| 	 * @return {@link WeightRandom}
   630| 	 * @since 4.0.3
   631| 	 */
   632| 	public static <T> WeightRandom<T> weightRandom(final Iterable<WeightObj<T>> weightObjs) {
   633| 		return new WeightRandom<>(weightObjs);
   634| 	}
   635| 	/**
   636| 	 * 以当天为基准，随机产生一个日期
   637| 	 *
   638| 	 * @param min 偏移最小天，可以为负数表示过去的时间（包含）
   639| 	 * @param max 偏移最大天，可以为负数表示过去的时间（不包含）
   640| 	 * @return 随机日期（随机天，其它时间不变）
   641| 	 * @since 4.0.8
   642| 	 */
   643| 	public static DateTime randomDay(final int min, final int max) {
   644| 		return randomDate(DateUtil.date(), DateField.DAY_OF_YEAR, min, max);
   645| 	}
   646| 	/**
   647| 	 * 以给定日期为基准，随机产生一个日期
   648| 	 *
   649| 	 * @param baseDate  基准日期
   650| 	 * @param dateField 偏移的时间字段，例如时、分、秒等
   651| 	 * @param min       偏移最小量，可以为负数表示过去的时间（包含）
   652| 	 * @param max       偏移最大量，可以为负数表示过去的时间（不包含）
   653| 	 * @return 随机日期
   654| 	 * @since 4.5.8
   655| 	 */
   656| 	public static DateTime randomDate(Date baseDate, final DateField dateField, final int min, final int max) {
   657| 		if (null == baseDate) {
   658| 			baseDate = DateUtil.date();
   659| 		}
   660| 		return DateUtil.offset(baseDate, dateField, randomInt(min, max));
   661| 	}
   662| }


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/util/StrUtil.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-35 ---
     1| package cn.hutool.core.util;
     2| import java.io.StringReader;
     3| import java.io.StringWriter;
     4| import java.nio.ByteBuffer;
     5| import java.nio.CharBuffer;
     6| import java.nio.charset.Charset;
     7| import java.nio.charset.CharsetDecoder;
     8| import java.nio.charset.CodingErrorAction;
     9| import java.nio.charset.StandardCharsets;
    10| import java.util.Map;
    11| import cn.hutool.core.text.CharSequenceUtil;
    12| import cn.hutool.core.text.StrBuilder;
    13| import cn.hutool.core.text.StrFormatter;
    14| import cn.hutool.core.text.StrPool;
    15| import cn.hutool.core.text.TextSimilarity;
    16| /**
    17|  * 字符串工具类
    18|  *
    19|  * @author xiaoleilu
    20|  */
    21| public class StrUtil extends CharSequenceUtil implements StrPool {
    22| 	/**
    23| 	 * <p>如果对象是字符串是否为空白，空白的定义如下：</p>
    24| 	 * <ol>
    25| 	 *     <li>{@code null}</li>
    26| 	 *     <li>空字符串：{@code ""}</li>
    27| 	 *     <li>空格、全角空格、制表符、换行符，等不可见字符</li>
    28| 	 * </ol>
    29| 	 *
    30| 	 * <p>例：</p>
    31| 	 * <ul>
    32| 	 *     <li>{@code StrUtil.isBlankIfStr(null)     // true}</li>
    33| 	 *     <li>{@code StrUtil.isBlankIfStr("")       // true}</li>
    34| 	 *     <li>{@code StrUtil.isBlankIfStr(" \t\n")  // true}</li>
    35| 	 *     <li>{@code StrUtil.isBlankIfStr("abc")    // false}</li>

# --- HUNK 2: Lines 225-266 ---
   225| 		return str(data, CharsetUtil.charset(charset));
   226| 	}
   227| 	/**
   228| 	 * 将编码的byteBuffer数据转换为字符串
   229| 	 *
   230| 	 * @param data    数据
   231| 	 * @param charset 字符集，如果为空使用当前系统字符集
   232| 	 * @return 字符串
   233| 	 */
   234| 	public static String str(ByteBuffer data, Charset charset) {
   235| 		if (null == charset) {
   236| 			charset = Charset.defaultCharset();
   237| 		}
   238| 		return charset.decode(data).toString();
   239| 	}
   240| 	/**
   241| 	 * 调用对象的toString方法，null会返回“null”
   242| 	 *
   243| 	 * @param obj 对象
   244| 	 * @return 字符串
   245| 	 * @see String#valueOf(Object)
   246| 	 * @since 4.1.3
   247| 	 */
   248| 	public static String toString(Object obj) {
   249| 		return String.valueOf(obj);
   250| 	}
   251| 	/**
   252| 	 * 调用对象的toString方法，null会返回{@code null}
   253| 	 *
   254| 	 * @param obj 对象
   255| 	 * @return 字符串 or {@code null}
   256| 	 * @since 5.7.17
   257| 	 */
   258| 	public static String toStringOrNull(Object obj) {
   259| 		return null == obj ? null : obj.toString();
   260| 	}
   261| 	/**
   262| 	 * 创建StringBuilder对象
   263| 	 *
   264| 	 * @return StringBuilder对象
   265| 	 */
   266| 	public static StringBuilder builder() {

# --- HUNK 3: Lines 409-478 ---
   409| 	 * @param template 文本模板，被替换的部分用 {key} 表示
   410| 	 * @param map      参数值对
   411| 	 * @return 格式化后的文本
   412| 	 */
   413| 	public static String format(CharSequence template, Map<?, ?> map) {
   414| 		return format(template, map, true);
   415| 	}
   416| 	/**
   417| 	 * 格式化文本，使用 {varName} 占位<br>
   418| 	 * map = {a: "aValue", b: "bValue"} format("{a} and {b}", map) ---=》 aValue and bValue
   419| 	 *
   420| 	 * @param template   文本模板，被替换的部分用 {key} 表示
   421| 	 * @param map        参数值对
   422| 	 * @param ignoreNull 是否忽略 {@code null} 值，忽略则 {@code null} 值对应的变量不被替换，否则替换为""
   423| 	 * @return 格式化后的文本
   424| 	 * @since 5.4.3
   425| 	 */
   426| 	public static String format(CharSequence template, Map<?, ?> map, boolean ignoreNull) {
   427| 		return StrFormatter.format(template, map, ignoreNull);
   428| 	}
   429| 	/**
   430| 	 * 截断字符串，使用其按照UTF-8编码为字节后不超过maxBytes长度。截断后自动追加省略号(...)
   431| 	 * 用于存储数据库varchar且编码为UTF-8的字段
   432| 	 *
   433| 	 * @param str      java字符串
   434| 	 * @param maxBytes 最大字节长度
   435| 	 * @return 截断后的字符
   436| 	 */
   437| 	public static String truncateUtf8(String str, int maxBytes) {
   438| 		Charset charset = StandardCharsets.UTF_8;
   439| 		return truncateByByteLength(str, charset, maxBytes, 4, true);
   440| 	}
   441| 	/**
   442| 	 * 截断字符串，使用其按照指定编码为字节后不超过maxBytes长度
   443| 	 *
   444| 	 * @param str        原始字符串
   445| 	 * @param charset    指定编码
   446| 	 * @param maxBytes   最大字节数
   447| 	 * @param factor     速算因子，取该编码下单个字符的最大可能字节数
   448| 	 * @param appendDots 截断后是否追加省略号(...)
   449| 	 * @return 截断后的字符串
   450| 	 */
   451| 	public static String truncateByByteLength(String str, Charset charset, int maxBytes, int factor,
   452| 			boolean appendDots) {
   453| 		if (str == null || str.length() * factor <= maxBytes) {
   454| 			return str;
   455| 		}
   456| 		final byte[] sba = str.getBytes(charset);
   457| 		if (sba.length <= maxBytes) {
   458| 			return str;
   459| 		}
   460| 		final int limitBytes;
   461| 		if (appendDots) {
   462| 			limitBytes = maxBytes - "...".getBytes(charset).length;
   463| 		} else {
   464| 			limitBytes = maxBytes;
   465| 		}
   466| 		final ByteBuffer bb = ByteBuffer.wrap(sba, 0, limitBytes);
   467| 		final CharBuffer cb = CharBuffer.allocate(limitBytes);
   468| 		final CharsetDecoder decoder = charset.newDecoder();
   469| 		decoder.onMalformedInput(CodingErrorAction.IGNORE);
   470| 		decoder.decode(bb, cb, true);
   471| 		decoder.flush(cb);
   472| 		final String result = new String(cb.array(), 0, cb.position());
   473| 		if (appendDots) {
   474| 			return result + "...";
   475| 		}
   476| 		return result;
   477| 	}
   478| }


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/util/TypeUtil.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-32 ---
     1| package cn.hutool.core.util;
     2| import cn.hutool.core.collection.ListUtil;
     3| import cn.hutool.core.lang.ParameterizedTypeImpl;
     4| import cn.hutool.core.lang.reflect.ActualTypeMapperPool;
     5| import java.lang.reflect.Field;
     6| import java.lang.reflect.Method;
     7| import java.lang.reflect.ParameterizedType;
     8| import java.lang.reflect.Type;
     9| import java.lang.reflect.TypeVariable;
    10| import java.lang.reflect.WildcardType;
    11| import java.util.ArrayList;
    12| import java.util.List;
    13| import java.util.Map;
    14| /**
    15|  * 针对 {@link Type} 的工具类封装<br>
    16|  * 最主要功能包括：
    17|  *
    18|  * <pre>
    19|  * 1. 获取方法的参数和返回值类型（包括Type和Class）
    20|  * 2. 获取泛型参数类型（包括对象的泛型参数或集合元素的泛型类型）
    21|  * </pre>
    22|  *
    23|  * @author Looly
    24|  * @since 3.0.8
    25|  */
    26| public class TypeUtil {
    27| 	/**
    28| 	 * 获得Type对应的原始类
    29| 	 *
    30| 	 * @param type {@link Type}
    31| 	 * @return 原始类，如果无法获取原始类，返回{@code null}
    32| 	 */

# --- HUNK 2: Lines 223-319 ---
   223| 		}
   224| 		final ParameterizedType parameterizedType = toParameterizedType(type);
   225| 		return (null == parameterizedType) ? null : parameterizedType.getActualTypeArguments();
   226| 	}
   227| 	/**
   228| 	 * 将{@link Type} 转换为{@link ParameterizedType}<br>
   229| 	 * {@link ParameterizedType}用于获取当前类或父类中泛型参数化后的类型<br>
   230| 	 * 一般用于获取泛型参数具体的参数类型，例如：
   231| 	 *
   232| 	 * <pre>
   233| 	 * class A&lt;T&gt;
   234| 	 * class B extends A&lt;String&gt;
   235| 	 * </pre>
   236| 	 * <p>
   237| 	 * 通过此方法，传入B.class即可得到B{@link ParameterizedType}，从而获取到String
   238| 	 *
   239| 	 * @param type {@link Type}
   240| 	 * @return {@link ParameterizedType}
   241| 	 * @since 4.5.2
   242| 	 */
   243| 	public static ParameterizedType toParameterizedType(final Type type) {
   244| 		return toParameterizedType(type, 0);
   245| 	}
   246| 	/**
   247| 	 * 将{@link Type} 转换为{@link ParameterizedType}<br>
   248| 	 * {@link ParameterizedType}用于获取当前类或父类中泛型参数化后的类型<br>
   249| 	 * 一般用于获取泛型参数具体的参数类型，例如：
   250| 	 *
   251| 	 * <pre>{@code
   252| 	 *   class A<T>
   253| 	 *   class B extends A<String>;
   254| 	 * }</pre>
   255| 	 * <p>
   256| 	 * 通过此方法，传入B.class即可得到B对应的{@link ParameterizedType}，从而获取到String
   257| 	 *
   258| 	 * @param type           {@link Type}
   259| 	 * @param interfaceIndex 实现的第几个接口
   260| 	 * @return {@link ParameterizedType}
   261| 	 * @since 4.5.2
   262| 	 */
   263| 	public static ParameterizedType toParameterizedType(final Type type, final int interfaceIndex) {
   264| 		if (type instanceof ParameterizedType) {
   265| 			return (ParameterizedType) type;
   266| 		}
   267| 		if (type instanceof Class) {
   268| 			final ParameterizedType[] generics = getGenerics((Class<?>) type);
   269| 			if(generics.length > interfaceIndex){
   270| 				return generics[interfaceIndex];
   271| 			}
   272| 		}
   273| 		return null;
   274| 	}
   275| 	/**
   276| 	 * 获取指定类所有泛型父类和泛型接口
   277| 	 *
   278| 	 * @param clazz 类
   279| 	 * @return 泛型父类或接口数组
   280| 	 * @since 6.0.0
   281| 	 */
   282| 	public static ParameterizedType[] getGenerics(final Class<?> clazz) {
   283| 		final List<ParameterizedType> result = new ArrayList<>();
   284| 		final Type genericSuper = clazz.getGenericSuperclass();
   285| 		if(null != genericSuper && !Object.class.equals(genericSuper)){
   286| 			final ParameterizedType parameterizedType = toParameterizedType(genericSuper);
   287| 			if(null != parameterizedType){
   288| 				result.add(parameterizedType);
   289| 			}
   290| 		}
   291| 		final Type[] genericInterfaces = clazz.getGenericInterfaces();
   292| 		if (ArrayUtil.isNotEmpty(genericInterfaces)) {
   293| 			for (final Type genericInterface : genericInterfaces) {
   294| 				if (genericInterface instanceof ParameterizedType) {
   295| 					result.add((ParameterizedType) genericInterface);
   296| 				}
   297| 			}
   298| 		}
   299| 		return result.toArray(new ParameterizedType[0]);
   300| 	}
   301| 	/**
   302| 	 * 是否未知类型<br>
   303| 	 * type为null或者{@link TypeVariable} 都视为未知类型
   304| 	 *
   305| 	 * @param type Type类型
   306| 	 * @return 是否未知类型
   307| 	 * @since 4.5.2
   308| 	 */
   309| 	public static boolean isUnknown(Type type) {
   310| 		return null == type || type instanceof TypeVariable;
   311| 	}
   312| 	/**
   313| 	 * 指定泛型数组中是否含有泛型变量
   314| 	 *
   315| 	 * @param types 泛型数组
   316| 	 * @return 是否含有泛型变量
   317| 	 * @since 4.5.7
   318| 	 */
   319| 	public static boolean hasTypeVariable(Type... types) {


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/util/URLUtil.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 695-757 ---
   695| 	 * @param charset  可选项（null表示无），源文本的字符集编码方式
   696| 	 * @param encoding 数据编码方式（US-ASCII，BASE64等）
   697| 	 * @param data     编码后的数据
   698| 	 * @return Data URI字符串
   699| 	 * @since 5.3.6
   700| 	 */
   701| 	public static String getDataUri(String mimeType, Charset charset, String encoding, String data) {
   702| 		final StringBuilder builder = StrUtil.builder("data:");
   703| 		if (StrUtil.isNotBlank(mimeType)) {
   704| 			builder.append(mimeType);
   705| 		}
   706| 		if (null != charset) {
   707| 			builder.append(";charset=").append(charset.name());
   708| 		}
   709| 		if (StrUtil.isNotBlank(encoding)) {
   710| 			builder.append(';').append(encoding);
   711| 		}
   712| 		builder.append(',').append(data);
   713| 		return builder.toString();
   714| 	}
   715| 	/**
   716| 	 * 获取URL对应数据长度
   717| 	 * <ul>
   718| 	 *     <li>如果URL为文件，转换为文件获取文件长度。</li>
   719| 	 *     <li>其它情况获取{@link URLConnection#getContentLengthLong()}</li>
   720| 	 * </ul>
   721| 	 *
   722| 	 * @param url URL
   723| 	 * @return 长度
   724| 	 * @since 6.0.0
   725| 	 */
   726| 	public static long size(final URL url) {
   727| 		if (URLUtil.isFileURL(url)) {
   728| 			final File file = FileUtil.file(url);
   729| 			final long length = file.length();
   730| 			if (length == 0L && !file.exists()) {
   731| 				throw new IORuntimeException("File not exist or size is zero!");
   732| 			}
   733| 			return length;
   734| 		} else {
   735| 			try {
   736| 				final URLConnection con = url.openConnection();
   737| 				useCachesIfNecessary(con);
   738| 				if (con instanceof HttpURLConnection) {
   739| 					final HttpURLConnection httpCon = (HttpURLConnection) con;
   740| 					httpCon.setRequestMethod("HEAD");
   741| 				}
   742| 				return con.getContentLengthLong();
   743| 			} catch (final IOException e) {
   744| 				throw new IORuntimeException(e);
   745| 			}
   746| 		}
   747| 	}
   748| 	/**
   749| 	 * 如果连接为JNLP方式，则打开缓存
   750| 	 *
   751| 	 * @param con {@link URLConnection}
   752| 	 * @since 6.0.0
   753| 	 */
   754| 	public static void useCachesIfNecessary(final URLConnection con) {
   755| 		con.setUseCaches(con.getClass().getSimpleName().startsWith("JNLP"));
   756| 	}
   757| }


# ====================================================================
# FILE: hutool-db/src/main/java/cn/hutool/db/dialect/DriverNamePool.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 56-96 ---
    56| 	String DRIVER_DERBY = "org.apache.derby.jdbc.AutoloadedDriver";
    57| 	/**
    58| 	 * JDBC 驱动 HSQLDB
    59| 	 */
    60| 	String DRIVER_HSQLDB = "org.hsqldb.jdbc.JDBCDriver";
    61| 	/**
    62| 	 * JDBC 驱动 达梦7
    63| 	 */
    64| 	String DRIVER_DM7 = "dm.jdbc.driver.DmDriver";
    65| 	/**
    66| 	 * JDBC 驱动 人大金仓
    67| 	 */
    68| 	String DRIVER_KINGBASE8 = "com.kingbase8.Driver";
    69| 	/**
    70| 	 * JDBC 驱动 Ignite thin
    71| 	 */
    72| 	String DRIVER_IGNITE_THIN = "org.apache.ignite.IgniteJdbcThinDriver";
    73| 	/**
    74| 	 * JDBC 驱动 ClickHouse
    75| 	 */
    76| 	String DRIVER_CLICK_HOUSE = "com.clickhouse.jdbc.ClickHouseDriver";
    77| 	/**
    78| 	 * JDBC 驱动 瀚高数据库
    79| 	 */
    80| 	String DRIVER_HIGHGO = "com.highgo.jdbc.Driver";
    81| 	/**
    82| 	 * JDBC 驱动 DB2
    83| 	 */
    84| 	String DRIVER_DB2 = "com.ibm.db2.jdbc.app.DB2Driver";
    85| 	/**
    86| 	 * JDBC 驱动 虚谷数据库
    87| 	 */
    88| 	String DRIVER_XUGU = "com.xugu.cloudjdbc.Driver";
    89| 	/**
    90| 	 * JDBC 驱动 Apache Phoenix
    91| 	 */
    92| 	String DRIVER_PHOENIX = "org.apache.phoenix.jdbc.PhoenixDriver";
    93| 	/**
    94| 	 * JDBC 驱动 华为高斯
    95| 	 */
    96| 	String DRIVER_GAUSS = "com.huawei.gauss.jdbc.ZenithDriver";


# ====================================================================
# FILE: hutool-db/src/main/java/cn/hutool/db/sql/Query.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-177 ---
     1| package cn.hutool.db.sql;
     2| import cn.hutool.core.collection.CollUtil;
     3| import cn.hutool.core.collection.CollectionUtil;
     4| import cn.hutool.core.util.ArrayUtil;
     5| import cn.hutool.db.DbRuntimeException;
     6| import cn.hutool.db.Entity;
     7| import cn.hutool.db.Page;
     8| import java.util.Collection;
     9| import java.util.Set;
    10| /**
    11|  * 查询对象，用于传递查询所需的字段值<br>
    12|  * 查询对象根据表名（可以多个），多个条件 {@link Condition} 构建查询对象完成查询。<br>
    13|  * 如果想自定义返回结果，则可在查询对象中自定义要查询的字段名，分页{@link Page}信息来自定义结果。
    14|  *
    15|  * @author Looly
    16|  *
    17|  */
    18| public class Query {
    19| 	/** 查询的字段名列表 */
    20| 	Collection<String> fields;
    21| 	/** 查询的表名 */
    22| 	String[] tableNames;
    23| 	/** 查询的条件语句 */
    24| 	Condition[] where;
    25| 	/** 分页对象 */
    26| 	Page page;
    27| 	/**
    28| 	 * 从{@link Entity}构建Query
    29| 	 * @param where 条件查询{@link Entity}，包含条件Map和表名
    30| 	 * @return Query
    31| 	 * @since 5.5.3
    32| 	 */
    33| 	public static Query of(Entity where){
    34| 		final Query query = new Query(SqlUtil.buildConditions(where), where.getTableName());
    35| 		final Set<String> fieldNames = where.getFieldNames();
    36| 		if(CollUtil.isNotEmpty(fieldNames)){
    37| 			query.setFields(fieldNames);
    38| 		}
    39| 		return query;
    40| 	}
    41| 	/**
    42| 	 * 构造
    43| 	 *
    44| 	 * @param tableNames 表名
    45| 	 */
    46| 	public Query(String... tableNames) {
    47| 		this(null, tableNames);
    48| 		this.tableNames = tableNames;
    49| 	}
    50| 	/**
    51| 	 * 构造
    52| 	 *
    53| 	 * @param where 条件语句
    54| 	 * @param tableNames 表名
    55| 	 */
    56| 	public Query(Condition[] where, String... tableNames) {
    57| 		this(where, null, tableNames);
    58| 	}
    59| 	/**
    60| 	 * 构造
    61| 	 *
    62| 	 * @param where 条件语句
    63| 	 * @param page 分页
    64| 	 * @param tableNames 表名
    65| 	 */
    66| 	public Query(Condition[] where, Page page, String... tableNames) {
    67| 		this(null, tableNames, where, page);
    68| 	}
    69| 	/**
    70| 	 * 构造
    71| 	 *
    72| 	 * @param fields 字段
    73| 	 * @param tableNames 表名
    74| 	 * @param where 条件
    75| 	 * @param page 分页
    76| 	 */
    77| 	public Query(Collection<String> fields, String[] tableNames, Condition[] where, Page page) {
    78| 		this.fields = fields;
    79| 		this.tableNames = tableNames;
    80| 		this.where = where;
    81| 		this.page = page;
    82| 	}
    83| 	/**
    84| 	 * 获得查询的字段名列表
    85| 	 *
    86| 	 * @return 查询的字段名列表
    87| 	 */
    88| 	public Collection<String> getFields() {
    89| 		return fields;
    90| 	}
    91| 	/**
    92| 	 * 设置查询的字段名列表
    93| 	 *
    94| 	 * @param fields 查询的字段名列表
    95| 	 * @return this
    96| 	 */
    97| 	public Query setFields(Collection<String> fields) {
    98| 		this.fields = fields;
    99| 		return this;
   100| 	}
   101| 	/**
   102| 	 * 设置查询的字段名列表
   103| 	 *
   104| 	 * @param fields 查询的字段名列表
   105| 	 * @return this
   106| 	 */
   107| 	public Query setFields(String... fields) {
   108| 		this.fields = CollectionUtil.newArrayList(fields);
   109| 		return this;
   110| 	}
   111| 	/**
   112| 	 * 获得表名数组
   113| 	 *
   114| 	 * @return 表名数组
   115| 	 */
   116| 	public String[] getTableNames() {
   117| 		return tableNames;
   118| 	}
   119| 	/**
   120| 	 * 设置表名
   121| 	 *
   122| 	 * @param tableNames 表名
   123| 	 * @return this
   124| 	 */
   125| 	public Query setTableNames(String... tableNames) {
   126| 		this.tableNames = tableNames;
   127| 		return this;
   128| 	}
   129| 	/**
   130| 	 * 获得条件语句
   131| 	 *
   132| 	 * @return 条件语句
   133| 	 */
   134| 	public Condition[] getWhere() {
   135| 		return where;
   136| 	}
   137| 	/**
   138| 	 * 设置条件语句
   139| 	 *
   140| 	 * @param where 条件语句
   141| 	 * @return this
   142| 	 */
   143| 	public Query setWhere(Condition... where) {
   144| 		this.where = where;
   145| 		return this;
   146| 	}
   147| 	/**
   148| 	 * 获得分页对象，无分页返回{@code null}
   149| 	 *
   150| 	 * @return 分页对象 or {@code null}
   151| 	 */
   152| 	public Page getPage() {
   153| 		return page;
   154| 	}
   155| 	/**
   156| 	 * 设置分页对象
   157| 	 *
   158| 	 * @param page 分页对象
   159| 	 * @return this
   160| 	 */
   161| 	public Query setPage(Page page) {
   162| 		this.page = page;
   163| 		return this;
   164| 	}
   165| 	/**
   166| 	 * 获得第一个表名
   167| 	 *
   168| 	 * @return 表名
   169| 	 * @throws DbRuntimeException 没有表
   170| 	 */
   171| 	public String getFirstTableName() throws DbRuntimeException {
   172| 		if (ArrayUtil.isEmpty(this.tableNames)) {
   173| 			throw new DbRuntimeException("No tableName!");
   174| 		}
   175| 		return this.tableNames[0];
   176| 	}
   177| }


# ====================================================================
# FILE: hutool-extra/src/main/java/cn/hutool/extra/compress/archiver/StreamArchiver.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 60-106 ---
    60| 	 * @param archiverName 归档类型名称，见{@link ArchiveStreamFactory}
    61| 	 * @param file         归档输出的文件
    62| 	 */
    63| 	public StreamArchiver(Charset charset, String archiverName, File file) {
    64| 		this(charset, archiverName, FileUtil.getOutputStream(file));
    65| 	}
    66| 	/**
    67| 	 * 构造
    68| 	 *
    69| 	 * @param charset      编码
    70| 	 * @param archiverName 归档类型名称，见{@link ArchiveStreamFactory}
    71| 	 * @param targetStream 归档输出的流
    72| 	 */
    73| 	public StreamArchiver(Charset charset, String archiverName, OutputStream targetStream) {
    74| 		if("tgz".equalsIgnoreCase(archiverName) || "tar.gz".equalsIgnoreCase(archiverName)){
    75| 			try {
    76| 				this.out = new TarArchiveOutputStream(new GzipCompressorOutputStream(targetStream));
    77| 			} catch (IOException e) {
    78| 				throw new IORuntimeException(e);
    79| 			}
    80| 		} else {
    81| 			final ArchiveStreamFactory factory = new ArchiveStreamFactory(charset.name());
    82| 			try {
    83| 				this.out = factory.createArchiveOutputStream(archiverName, targetStream);
    84| 			} catch (ArchiveException e) {
    85| 				throw new CompressException(e);
    86| 			}
    87| 		}
    88| 		if(this.out instanceof TarArchiveOutputStream){
    89| 			((TarArchiveOutputStream)out).setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);
    90| 		} else if(this.out instanceof ArArchiveOutputStream){
    91| 			((ArArchiveOutputStream)out).setLongFileMode(ArArchiveOutputStream.LONGFILE_BSD);
    92| 		}
    93| 	}
    94| 	/**
    95| 	 * 将文件或目录加入归档包，目录采取递归读取方式按照层级加入
    96| 	 *
    97| 	 * @param file   文件或目录
    98| 	 * @param path   文件或目录的初始路径，null表示位于根路径
    99| 	 * @param filter 文件过滤器，指定哪些文件或目录可以加入，当{@link Filter#accept(Object)}为true时加入。
   100| 	 * @return this
   101| 	 * @throws IORuntimeException IO异常
   102| 	 */
   103| 	@Override
   104| 	public StreamArchiver add(File file, String path, Filter<File> filter) throws IORuntimeException {
   105| 		try {
   106| 			addInternal(file, path, filter);


# ====================================================================
# FILE: hutool-extra/src/main/java/cn/hutool/extra/expression/ExpressionEngine.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-20 ---
     1| package cn.hutool.extra.expression;
     2| import java.util.Collection;
     3| import java.util.Map;
     4| /**
     5|  * 表达式引擎API接口，通过实现此接口，完成表达式的解析和执行
     6|  *
     7|  * @author looll, independenter
     8|  * @since 5.5.0
     9|  */
    10| public interface ExpressionEngine {
    11| 	/**
    12| 	 * 执行表达式
    13| 	 *
    14| 	 * @param expression    表达式
    15| 	 * @param context       表达式上下文，用于存储表达式中所需的变量值等
    16| 	 * @param allowClassSet 允许的Class白名单
    17| 	 * @return 执行结果
    18| 	 */
    19| 	Object eval(String expression, Map<String, Object> context, Collection<Class<?>> allowClassSet);
    20| }


# ====================================================================
# FILE: hutool-extra/src/main/java/cn/hutool/extra/expression/ExpressionUtil.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-43 ---
     1| package cn.hutool.extra.expression;
     2| import cn.hutool.core.collection.ListUtil;
     3| import cn.hutool.extra.expression.engine.ExpressionFactory;
     4| import java.util.Collection;
     5| import java.util.Map;
     6| /**
     7|  * 表达式引擎工具类
     8|  *
     9|  * @author looly
    10|  * @since 5.5.0
    11|  */
    12| public class ExpressionUtil {
    13| 	/**
    14| 	 * 获得全局单例的表达式引擎
    15| 	 *
    16| 	 * @return 全局单例的表达式引擎
    17| 	 */
    18| 	public static ExpressionEngine getEngine() {
    19| 		return ExpressionFactory.get();
    20| 	}
    21| 	/**
    22| 	 * 执行表达式
    23| 	 *
    24| 	 * @param expression 表达式
    25| 	 * @param context    表达式上下文，用于存储表达式中所需的变量值等
    26| 	 * @return 执行结果
    27| 	 */
    28| 	public static Object eval(String expression, Map<String, Object> context) {
    29| 		return eval(expression, context, ListUtil.empty());
    30| 	}
    31| 	/**
    32| 	 * 执行表达式
    33| 	 *
    34| 	 * @param expression 表达式
    35| 	 * @param context    表达式上下文，用于存储表达式中所需的变量值等
    36| 	 * @param allowClassSet 允许的Class白名单
    37| 	 * @return 执行结果
    38| 	 * @since 5.8.21
    39| 	 */
    40| 	public static Object eval(String expression, Map<String, Object> context, Collection<Class<?>> allowClassSet) {
    41| 		return getEngine().eval(expression, context, allowClassSet);
    42| 	}
    43| }


# ====================================================================
# FILE: hutool-extra/src/main/java/cn/hutool/extra/expression/engine/aviator/AviatorEngine.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| package cn.hutool.extra.expression.engine.aviator;
     2| import cn.hutool.core.collection.CollUtil;
     3| import cn.hutool.extra.expression.ExpressionEngine;
     4| import com.googlecode.aviator.AviatorEvaluator;
     5| import com.googlecode.aviator.AviatorEvaluatorInstance;
     6| import com.googlecode.aviator.Options;
     7| import java.util.Collection;
     8| import java.util.Collections;
     9| import java.util.Map;
    10| /**
    11|  * Aviator引擎封装<br>
    12|  * 见：https://github.com/killme2008/aviatorscript
    13|  *
    14|  * @author looly
    15|  * @since 5.5.0
    16|  */
    17| public class AviatorEngine implements ExpressionEngine {
    18| 	private final AviatorEvaluatorInstance engine;
    19| 	/**
    20| 	 * 构造
    21| 	 */
    22| 	public AviatorEngine() {
    23| 		engine = AviatorEvaluator.getInstance();
    24| 	}
    25| 	@Override
    26| 	public Object eval(String expression, Map<String, Object> context, Collection<Class<?>> allowClassSet) {
    27| 		engine.setOption(Options.ALLOWED_CLASS_SET,
    28| 			CollUtil.isEmpty(allowClassSet) ? Collections.emptySet() : CollUtil.newHashSet(allowClassSet));
    29| 		return engine.execute(expression, context);
    30| 	}
    31| 	/**
    32| 	 * 获取{@link AviatorEvaluatorInstance}
    33| 	 *
    34| 	 * @return {@link AviatorEvaluatorInstance}
    35| 	 */
    36| 	public AviatorEvaluatorInstance getEngine() {
    37| 		return this.engine;
    38| 	}
    39| }


# ====================================================================
# FILE: hutool-extra/src/main/java/cn/hutool/extra/expression/engine/jexl/JexlEngine.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-36 ---
     1| package cn.hutool.extra.expression.engine.jexl;
     2| import cn.hutool.extra.expression.ExpressionEngine;
     3| import org.apache.commons.jexl3.JexlBuilder;
     4| import org.apache.commons.jexl3.MapContext;
     5| import java.util.Collection;
     6| import java.util.Map;
     7| /**
     8|  * Jexl3引擎封装<br>
     9|  * 见：https://github.com/apache/commons-jexl
    10|  *
    11|  * @since 5.5.0
    12|  * @author looly
    13|  */
    14| public class JexlEngine implements ExpressionEngine {
    15| 	private final org.apache.commons.jexl3.JexlEngine engine;
    16| 	public JexlEngine(){
    17| 		engine = (new JexlBuilder()).cache(512).strict(true).silent(false).create();
    18| 	}
    19| 	@Override
    20| 	public Object eval(String expression, Map<String, Object> context, Collection<Class<?>> allowClassSet) {
    21| 		final MapContext mapContext = new MapContext(context);
    22| 		try{
    23| 			return engine.createExpression(expression).evaluate(mapContext);
    24| 		} catch (Exception ignore){
    25| 			return engine.createScript(expression).execute(mapContext);
    26| 		}
    27| 	}
    28| 	/**
    29| 	 * 获取{@link org.apache.commons.jexl3.JexlEngine}
    30| 	 *
    31| 	 * @return {@link org.apache.commons.jexl3.JexlEngine}
    32| 	 */
    33| 	public org.apache.commons.jexl3.JexlEngine getEngine() {
    34| 		return this.engine;
    35| 	}
    36| }


# ====================================================================
# FILE: hutool-extra/src/main/java/cn/hutool/extra/expression/engine/jfireel/JfireELEngine.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-28 ---
     1| package cn.hutool.extra.expression.engine.jfireel;
     2| import cn.hutool.extra.expression.ExpressionEngine;
     3| import com.jfirer.jfireel.expression.Expression;
     4| import java.util.Collection;
     5| import java.util.Map;
     6| /**
     7|  * JfireEL引擎封装<br>
     8|  * 见：https://gitee.com/eric_ds/jfireEL
     9|  *
    10|  * @since 5.5.0
    11|  * @author looly
    12|  */
    13| public class JfireELEngine implements ExpressionEngine {
    14| 	static {
    15| 		checkEngineExist(Expression.class);
    16| 	}
    17| 	/**
    18| 	 * 构造
    19| 	 */
    20| 	public JfireELEngine(){
    21| 	}
    22| 	@Override
    23| 	public Object eval(String expression, Map<String, Object> context, Collection<Class<?>> allowClassSet) {
    24| 		return Expression.parse(expression).calculate(context);
    25| 	}
    26| 	private static void checkEngineExist(Class<?> clazz){
    27| 	}
    28| }


# ====================================================================
# FILE: hutool-extra/src/main/java/cn/hutool/extra/expression/engine/mvel/MvelEngine.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-28 ---
     1| package cn.hutool.extra.expression.engine.mvel;
     2| import cn.hutool.extra.expression.ExpressionEngine;
     3| import org.mvel2.MVEL;
     4| import java.util.Collection;
     5| import java.util.Map;
     6| /**
     7|  * MVEL (MVFLEX Expression Language)引擎封装<br>
     8|  * 见：https://github.com/mvel/mvel
     9|  *
    10|  * @since 5.5.0
    11|  * @author looly
    12|  */
    13| public class MvelEngine implements ExpressionEngine {
    14| 	static {
    15| 		checkEngineExist(MVEL.class);
    16| 	}
    17| 	/**
    18| 	 * 构造
    19| 	 */
    20| 	public MvelEngine(){
    21| 	}
    22| 	@Override
    23| 	public Object eval(String expression, Map<String, Object> context, Collection<Class<?>> allowClassSet) {
    24| 		return MVEL.eval(expression, context);
    25| 	}
    26| 	private static void checkEngineExist(Class<?> clazz){
    27| 	}
    28| }


# ====================================================================
# FILE: hutool-extra/src/main/java/cn/hutool/extra/expression/engine/qlexpress/QLExpressEngine.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-33 ---
     1| package cn.hutool.extra.expression.engine.qlexpress;
     2| import cn.hutool.extra.expression.ExpressionEngine;
     3| import cn.hutool.extra.expression.ExpressionException;
     4| import com.ql.util.express.DefaultContext;
     5| import com.ql.util.express.ExpressRunner;
     6| import java.util.Collection;
     7| import java.util.Map;
     8| /**
     9|  * QLExpress引擎封装<br>
    10|  * 见：https://github.com/alibaba/QLExpress
    11|  *
    12|  * @author looly
    13|  * @since 5.8.9
    14|  */
    15| public class QLExpressEngine implements ExpressionEngine {
    16| 	private final ExpressRunner engine;
    17| 	/**
    18| 	 * 构造
    19| 	 */
    20| 	public QLExpressEngine() {
    21| 		engine = new ExpressRunner();
    22| 	}
    23| 	@Override
    24| 	public Object eval(final String expression, final Map<String, Object> context, Collection<Class<?>> allowClassSet) {
    25| 		final DefaultContext<String, Object> defaultContext = new DefaultContext<>();
    26| 		defaultContext.putAll(context);
    27| 		try {
    28| 			return engine.execute(expression, defaultContext, null, true, false);
    29| 		} catch (final Exception e) {
    30| 			throw new ExpressionException(e);
    31| 		}
    32| 	}
    33| }


# ====================================================================
# FILE: hutool-extra/src/main/java/cn/hutool/extra/expression/engine/rhino/RhinoEngine.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-35 ---
     1| package cn.hutool.extra.expression.engine.rhino;
     2| import cn.hutool.core.map.MapUtil;
     3| import cn.hutool.extra.expression.ExpressionEngine;
     4| import org.mozilla.javascript.Context;
     5| import org.mozilla.javascript.Scriptable;
     6| import org.mozilla.javascript.ScriptableObject;
     7| import java.util.Collection;
     8| import java.util.Map;
     9| /**
    10|  * rhino引擎封装<br>
    11|  * 见：https://github.com/mozilla/rhino
    12|  *
    13|  * @author lzpeng
    14|  * @since 5.5.2
    15|  */
    16| public class RhinoEngine implements ExpressionEngine {
    17| 	static {
    18| 		checkEngineExist(Context.class);
    19| 	}
    20| 	@Override
    21| 	public Object eval(String expression, Map<String, Object> context, Collection<Class<?>> allowClassSet) {
    22| 		final Context ctx = Context.enter();
    23| 		final Scriptable scope = ctx.initStandardObjects();
    24| 		if (MapUtil.isNotEmpty(context)) {
    25| 			context.forEach((key, value)->{
    26| 				ScriptableObject.putProperty(scope, key, Context.javaToJS(value, scope));
    27| 			});
    28| 		}
    29| 		final Object result = ctx.evaluateString(scope, expression, "rhino.js", 1, null);
    30| 		Context.exit();
    31| 		return result;
    32| 	}
    33| 	private static void checkEngineExist(Class<?> clazz){
    34| 	}
    35| }


# ====================================================================
# FILE: hutool-extra/src/main/java/cn/hutool/extra/expression/engine/spel/SpELEngine.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-30 ---
     1| package cn.hutool.extra.expression.engine.spel;
     2| import cn.hutool.extra.expression.ExpressionEngine;
     3| import org.springframework.expression.EvaluationContext;
     4| import org.springframework.expression.ExpressionParser;
     5| import org.springframework.expression.spel.standard.SpelExpressionParser;
     6| import org.springframework.expression.spel.support.StandardEvaluationContext;
     7| import java.util.Collection;
     8| import java.util.Map;
     9| /**
    10|  * Spring-Expression引擎封装<br>
    11|  * 见：https://github.com/spring-projects/spring-framework/tree/master/spring-expression
    12|  *
    13|  * @since 5.5.0
    14|  * @author looly
    15|  */
    16| public class SpELEngine implements ExpressionEngine {
    17| 	private final ExpressionParser parser;
    18| 	/**
    19| 	 * 构造
    20| 	 */
    21| 	public SpELEngine(){
    22| 		parser = new SpelExpressionParser();
    23| 	}
    24| 	@Override
    25| 	public Object eval(String expression, Map<String, Object> context, Collection<Class<?>> allowClassSet) {
    26| 		final EvaluationContext evaluationContext = new StandardEvaluationContext();
    27| 		context.forEach(evaluationContext::setVariable);
    28| 		return parser.parseExpression(expression).getValue(evaluationContext);
    29| 	}
    30| }


# ====================================================================
# FILE: hutool-extra/src/main/java/cn/hutool/extra/ssh/Sftp.java
# Total hunks: 6
# ====================================================================
# --- HUNK 1: Lines 193-259 ---
   193| 	@Override
   194| 	public Sftp reconnectIfTimeout() {
   195| 		if (StrUtil.isBlank(this.ftpConfig.getHost())) {
   196| 			throw new FtpException("Host is blank!");
   197| 		}
   198| 		try {
   199| 			this.cd(StrUtil.SLASH);
   200| 		} catch (FtpException e) {
   201| 			close();
   202| 			init();
   203| 		}
   204| 		return this;
   205| 	}
   206| 	/**
   207| 	 * 获取SFTP通道客户端
   208| 	 *
   209| 	 * @return 通道客户端
   210| 	 * @since 4.1.14
   211| 	 */
   212| 	public ChannelSftp getClient() {
   213| 		if(false == this.channel.isConnected()){
   214| 			init();
   215| 		}
   216| 		return this.channel;
   217| 	}
   218| 	/**
   219| 	 * 远程当前目录
   220| 	 *
   221| 	 * @return 远程当前目录
   222| 	 */
   223| 	@Override
   224| 	public String pwd() {
   225| 		try {
   226| 			return getClient().pwd();
   227| 		} catch (SftpException e) {
   228| 			throw new JschRuntimeException(e);
   229| 		}
   230| 	}
   231| 	/**
   232| 	 * 获取HOME路径
   233| 	 *
   234| 	 * @return HOME路径
   235| 	 * @since 4.0.5
   236| 	 */
   237| 	public String home() {
   238| 		try {
   239| 			return getClient().getHome();
   240| 		} catch (SftpException e) {
   241| 			throw new JschRuntimeException(e);
   242| 		}
   243| 	}
   244| 	/**
   245| 	 * 遍历某个目录下所有文件或目录，不会递归遍历
   246| 	 *
   247| 	 * @param path 遍历某个目录下所有文件或目录
   248| 	 * @return 目录或文件名列表
   249| 	 * @since 4.0.5
   250| 	 */
   251| 	@Override
   252| 	public List<String> ls(String path) {
   253| 		return ls(path, null);
   254| 	}
   255| 	/**
   256| 	 * 遍历某个目录下所有目录，不会递归遍历
   257| 	 *
   258| 	 * @param path 遍历某个目录下所有目录
   259| 	 * @return 目录名列表

# --- HUNK 2: Lines 294-421 ---
   294| 	 *
   295| 	 * @param path 遍历某个目录下所有文件或目录
   296| 	 * @return 目录或文件名列表
   297| 	 * @since 5.3.5
   298| 	 */
   299| 	public List<LsEntry> lsEntries(String path) {
   300| 		return lsEntries(path, null);
   301| 	}
   302| 	/**
   303| 	 * 遍历某个目录下所有文件或目录，生成LsEntry列表，不会递归遍历<br>
   304| 	 * 此方法自动过滤"."和".."两种目录
   305| 	 *
   306| 	 * @param path   遍历某个目录下所有文件或目录
   307| 	 * @param filter 文件或目录过滤器，可以实现过滤器返回自己需要的文件或目录名列表
   308| 	 * @return 目录或文件名列表
   309| 	 * @since 5.3.5
   310| 	 */
   311| 	public List<LsEntry> lsEntries(String path, Filter<LsEntry> filter) {
   312| 		final List<LsEntry> entryList = new ArrayList<>();
   313| 		try {
   314| 			getClient().ls(path, entry -> {
   315| 				final String fileName = entry.getFilename();
   316| 				if (false == StrUtil.equals(".", fileName) && false == StrUtil.equals("..", fileName)) {
   317| 					if (null == filter || filter.accept(entry)) {
   318| 						entryList.add(entry);
   319| 					}
   320| 				}
   321| 				return LsEntrySelector.CONTINUE;
   322| 			});
   323| 		} catch (SftpException e) {
   324| 			if (false == StrUtil.startWithIgnoreCase(e.getMessage(), "No such file")) {
   325| 				throw new JschRuntimeException(e);
   326| 			}
   327| 		}
   328| 		return entryList;
   329| 	}
   330| 	@Override
   331| 	public boolean mkdir(String dir) {
   332| 		if (isDir(dir)) {
   333| 			return true;
   334| 		}
   335| 		try {
   336| 			getClient().mkdir(dir);
   337| 			return true;
   338| 		} catch (SftpException e) {
   339| 			throw new JschRuntimeException(e);
   340| 		}
   341| 	}
   342| 	@Override
   343| 	public boolean isDir(String dir) {
   344| 		final SftpATTRS sftpATTRS;
   345| 		try {
   346| 			sftpATTRS = getClient().stat(dir);
   347| 		} catch (SftpException e) {
   348| 			final String msg = e.getMessage();
   349| 			if (StrUtil.containsAnyIgnoreCase(msg, "No such file", "does not exist")) {
   350| 				return false;
   351| 			}
   352| 			throw new FtpException(e);
   353| 		}
   354| 		return sftpATTRS.isDir();
   355| 	}
   356| 	/**
   357| 	 * 打开指定目录，如果指定路径非目录或不存在抛出异常
   358| 	 *
   359| 	 * @param directory directory
   360| 	 * @return 是否打开目录
   361| 	 * @throws FtpException 进入目录失败异常
   362| 	 */
   363| 	@Override
   364| 	synchronized public boolean cd(String directory) throws FtpException {
   365| 		if (StrUtil.isBlank(directory)) {
   366| 			return true;
   367| 		}
   368| 		try {
   369| 			getClient().cd(directory.replace('\\', '/'));
   370| 			return true;
   371| 		} catch (SftpException e) {
   372| 			throw new FtpException(e);
   373| 		}
   374| 	}
   375| 	/**
   376| 	 * 删除文件
   377| 	 *
   378| 	 * @param filePath 要删除的文件绝对路径
   379| 	 */
   380| 	@Override
   381| 	public boolean delFile(String filePath) {
   382| 		try {
   383| 			getClient().rm(filePath);
   384| 		} catch (SftpException e) {
   385| 			throw new JschRuntimeException(e);
   386| 		}
   387| 		return true;
   388| 	}
   389| 	/**
   390| 	 * 删除文件夹及其文件夹下的所有文件
   391| 	 *
   392| 	 * @param dirPath 文件夹路径
   393| 	 * @return boolean 是否删除成功
   394| 	 */
   395| 	@Override
   396| 	@SuppressWarnings("unchecked")
   397| 	public boolean delDir(String dirPath) {
   398| 		if (false == cd(dirPath)) {
   399| 			return false;
   400| 		}
   401| 		final ChannelSftp channel = getClient();
   402| 		Vector<LsEntry> list;
   403| 		try {
   404| 			list = channel.ls(channel.pwd());
   405| 		} catch (SftpException e) {
   406| 			throw new JschRuntimeException(e);
   407| 		}
   408| 		String fileName;
   409| 		for (LsEntry entry : list) {
   410| 			fileName = entry.getFilename();
   411| 			if (false == ".".equals(fileName) && false == "..".equals(fileName)) {
   412| 				if (entry.getAttrs().isDir()) {
   413| 					delDir(fileName);
   414| 				} else {
   415| 					delFile(fileName);
   416| 				}
   417| 			}
   418| 		}
   419| 		if (false == cd("..")) {
   420| 			return false;
   421| 		}

# --- HUNK 3: Lines 496-554 ---
   496| 	 * @param srcFilePath 本地文件路径
   497| 	 * @param destPath    目标路径，
   498| 	 * @param mode        {@link Mode} 模式
   499| 	 * @return this
   500| 	 */
   501| 	public Sftp put(String srcFilePath, String destPath, Mode mode) {
   502| 		return put(srcFilePath, destPath, null, mode);
   503| 	}
   504| 	/**
   505| 	 * 将本地文件上传到目标服务器，目标文件名为destPath，若destPath为目录，则目标文件名将与srcFilePath文件名相同。
   506| 	 *
   507| 	 * @param srcFilePath 本地文件路径
   508| 	 * @param destPath    目标路径，
   509| 	 * @param monitor     上传进度监控，通过实现此接口完成进度显示
   510| 	 * @param mode        {@link Mode} 模式
   511| 	 * @return this
   512| 	 * @since 4.6.5
   513| 	 */
   514| 	public Sftp put(String srcFilePath, String destPath, SftpProgressMonitor monitor, Mode mode) {
   515| 		try {
   516| 			getClient().put(srcFilePath, destPath, monitor, mode.ordinal());
   517| 		} catch (SftpException e) {
   518| 			throw new JschRuntimeException(e);
   519| 		}
   520| 		return this;
   521| 	}
   522| 	/**
   523| 	 * 将本地数据流上传到目标服务器，目标文件名为destPath，目标必须为文件
   524| 	 *
   525| 	 * @param srcStream 本地的数据流
   526| 	 * @param destPath  目标路径，
   527| 	 * @param monitor   上传进度监控，通过实现此接口完成进度显示
   528| 	 * @param mode      {@link Mode} 模式
   529| 	 * @return this
   530| 	 * @since 5.7.16
   531| 	 */
   532| 	public Sftp put(InputStream srcStream, String destPath, SftpProgressMonitor monitor, Mode mode) {
   533| 		try {
   534| 			getClient().put(srcStream, destPath, monitor, mode.ordinal());
   535| 		} catch (SftpException e) {
   536| 			throw new JschRuntimeException(e);
   537| 		}
   538| 		return this;
   539| 	}
   540| 	@Override
   541| 	public void download(String src, File destFile) {
   542| 		get(src, FileUtil.getAbsolutePath(destFile));
   543| 	}
   544| 	/**
   545| 	 * 下载文件到{@link OutputStream}中
   546| 	 *
   547| 	 * @param src 源文件路径，包括文件名
   548| 	 * @param out 目标流
   549| 	 * @see #get(String, OutputStream)
   550| 	 */
   551| 	public void download(String src, OutputStream out) {
   552| 		get(src, out);
   553| 	}
   554| 	/**

# --- HUNK 4: Lines 569-625 ---
   569| 			if (false == item.getAttrs().isDir()) {
   570| 				if (false == FileUtil.exist(destFile)
   571| 						|| (item.getAttrs().getMTime() > (destFile.lastModified() / 1000))) {
   572| 					download(srcFile, destFile);
   573| 				}
   574| 			} else {
   575| 				FileUtil.mkdir(destFile);
   576| 				recursiveDownloadFolder(srcFile, destFile);
   577| 			}
   578| 		}
   579| 	}
   580| 	/**
   581| 	 * 获取远程文件
   582| 	 *
   583| 	 * @param src  远程文件路径
   584| 	 * @param dest 目标文件路径
   585| 	 * @return this
   586| 	 */
   587| 	public Sftp get(String src, String dest) {
   588| 		try {
   589| 			getClient().get(src, dest);
   590| 		} catch (SftpException e) {
   591| 			throw new JschRuntimeException(e);
   592| 		}
   593| 		return this;
   594| 	}
   595| 	/**
   596| 	 * 获取远程文件
   597| 	 *
   598| 	 * @param src 远程文件路径
   599| 	 * @param out 目标流
   600| 	 * @return this
   601| 	 * @since 5.7.0
   602| 	 */
   603| 	public Sftp get(String src, OutputStream out) {
   604| 		try {
   605| 			getClient().get(src, out);
   606| 		} catch (SftpException e) {
   607| 			throw new JschRuntimeException(e);
   608| 		}
   609| 		return this;
   610| 	}
   611| 	@Override
   612| 	public void close() {
   613| 		JschUtil.close(this.channel);
   614| 		JschUtil.close(this.session);
   615| 	}
   616| 	@Override
   617| 	public String toString() {
   618| 		return "Sftp{" +
   619| 				"host='" + this.ftpConfig.getHost() + '\'' +
   620| 				", port=" + this.ftpConfig.getPort() +
   621| 				", user='" + this.ftpConfig.getUser() + '\'' +
   622| 				'}';
   623| 	}
   624| 	/**
   625| 	 * JSch支持的三种文件传输模式


# ====================================================================
# FILE: hutool-http/src/main/java/cn/hutool/http/HttpRequest.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1188-1236 ---
  1188| 	}
  1189| 	/**
  1190| 	 * 创建body
  1191| 	 *
  1192| 	 * @return body
  1193| 	 */
  1194| 	private RequestBody createBody(){
  1195| 		if (null != this.body) {
  1196| 			return ResourceBody.create(this.body);
  1197| 		} else {
  1198| 			return FormUrlEncodedBody.create(this.form, this.charset);
  1199| 		}
  1200| 	}
  1201| 	/**
  1202| 	 * 发送多组件请求（例如包含文件的表单）<br>
  1203| 	 * 发送数据后自动关闭输出流
  1204| 	 *
  1205| 	 * @throws IOException IO异常
  1206| 	 */
  1207| 	private void sendMultipart() throws IOException {
  1208| 		final RequestBody body;
  1209| 		if(null == form && null != this.body) {
  1210| 			body = ResourceBody.create(this.body);
  1211| 		}else{
  1212| 			final MultipartBody multipartBody = MultipartBody.create(this.form, this.charset);
  1213| 			this.httpConnection.header(Header.CONTENT_TYPE, multipartBody.getContentType(), true);
  1214| 			body = multipartBody;
  1215| 		}
  1216| 		body.writeClose(this.httpConnection.getOutputStream());
  1217| 	}
  1218| 	/**
  1219| 	 * 是否忽略读取响应body部分<br>
  1220| 	 * HEAD、CONNECT、OPTIONS、TRACE方法将不读取响应体
  1221| 	 *
  1222| 	 * @return 是否需要忽略响应body部分
  1223| 	 * @since 3.1.2
  1224| 	 */
  1225| 	private boolean isIgnoreResponseBody() {
  1226| 		return Method.HEAD == this.method //
  1227| 				|| Method.CONNECT == this.method //
  1228| 				|| Method.OPTIONS == this.method //
  1229| 				|| Method.TRACE == this.method;
  1230| 	}
  1231| 	/**
  1232| 	 * 判断是否为multipart/form-data表单，条件如下：
  1233| 	 *
  1234| 	 * <pre>
  1235| 	 *     1. 存在资源对象（fileForm非空）
  1236| 	 *     2. 用户自定义头为multipart/form-data开头


# ====================================================================
# FILE: hutool-http/src/main/java/cn/hutool/http/useragent/Browser.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 19-59 ---
    19| 	 * 其它版本
    20| 	 */
    21| 	public static final String Other_Version = "[\\/ ]([\\d\\w\\.\\-]+)";
    22| 	/**
    23| 	 * 支持的浏览器类型
    24| 	 */
    25| 	public static final List<Browser> browers = CollUtil.newArrayList(
    26| 			new Browser("wxwork", "wxwork", "wxwork\\/([\\d\\w\\.\\-]+)"),
    27| 			new Browser("MicroMessenger", "MicroMessenger", Other_Version),
    28| 			new Browser("miniProgram", "miniProgram", Other_Version),
    29| 			new Browser("QQBrowser", "MQQBrowser", "MQQBrowser\\/([\\d\\w\\.\\-]+)"),
    30| 			new Browser("DingTalk-win", "dingtalk-win", "DingTalk\\(([\\d\\w\\.\\-]+)\\)"),
    31| 			new Browser("DingTalk", "DingTalk", "AliApp\\(DingTalk\\/([\\d\\w\\.\\-]+)\\)"),
    32| 			new Browser("Alipay", "AlipayClient", "AliApp\\(AP\\/([\\d\\w\\.\\-]+)\\)"),
    33| 			new Browser("Taobao", "taobao", "AliApp\\(TB\\/([\\d\\w\\.\\-]+)\\)"),
    34| 			new Browser("UCBrowser", "UC?Browser", "UC?Browser\\/([\\d\\w\\.\\-]+)"),
    35| 			new Browser("MiuiBrowser", "MiuiBrowser|mibrowser", "MiuiBrowser\\/([\\d\\w\\.\\-]+)"),
    36| 			new Browser("Quark", "Quark", Other_Version),
    37| 			new Browser("Lenovo", "SLBrowser", "SLBrowser/([\\d\\w\\.\\-]+)"),
    38| 			new Browser("MSEdge", "Edge|Edg", "(?:edge|Edg|EdgA)\\/([\\d\\w\\.\\-]+)"),
    39| 			new Browser("Chrome", "chrome|(iphone.*crios.*safari)", "(?:Chrome|CriOS)\\/([\\d\\w\\.\\-]+)"),
    40| 			new Browser("Firefox", "firefox", Other_Version),
    41| 			new Browser("IEMobile", "iemobile", Other_Version),
    42| 			new Browser("Android Browser", "android", "version\\/([\\d\\w\\.\\-]+)"),
    43| 			new Browser("Safari", "safari", "version\\/([\\d\\w\\.\\-]+)"),
    44| 			new Browser("Opera", "opera", Other_Version),
    45| 			new Browser("Konqueror", "konqueror", Other_Version),
    46| 			new Browser("PS3", "playstation 3", "([\\d\\w\\.\\-]+)\\)\\s*$"),
    47| 			new Browser("PSP", "playstation portable", "([\\d\\w\\.\\-]+)\\)?\\s*$"),
    48| 			new Browser("Lotus", "lotus.notes", "Lotus-Notes\\/([\\w.]+)"),
    49| 			new Browser("Thunderbird", "thunderbird", Other_Version),
    50| 			new Browser("Netscape", "netscape", Other_Version),
    51| 			new Browser("Seamonkey", "seamonkey", Other_Version),
    52| 			new Browser("Outlook", "microsoft.outlook", Other_Version),
    53| 			new Browser("Evolution", "evolution", Other_Version),
    54| 			new Browser("MSIE", "msie", "msie ([\\d\\w\\.\\-]+)"),
    55| 			new Browser("MSIE11", "rv:11", "rv:([\\d\\w\\.\\-]+)"),
    56| 			new Browser("Gabble", "Gabble", Other_Version),
    57| 			new Browser("Yammer Desktop", "AdobeAir", "([\\d\\w\\.\\-]+)\\/Yammer"),
    58| 			new Browser("Yammer Mobile", "Yammer[\\s]+([\\d\\w\\.\\-]+)", "Yammer[\\s]+([\\d\\w\\.\\-]+)"),
    59| 			new Browser("Apache HTTP Client", "Apache\\\\-HttpClient", "Apache\\-HttpClient\\/([\\d\\w\\.\\-]+)"),


# ====================================================================
# FILE: hutool-json/src/main/java/cn/hutool/json/JSONBeanParser.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-17 ---
     1| package cn.hutool.json;
     2| /**
     3|  * 实现此接口的类可以通过实现{@code parse(value)}方法来将JSON中的值解析为此对象的值
     4|  *
     5|  * @author Looly
     6|  * @since 5.7.8
     7|  * @param <T> 参数类型
     8|  */
     9| public interface JSONBeanParser<T> {
    10| 	/**
    11| 	 * value转Bean<br>
    12| 	 * 通过实现此接口，将JSON中的值填充到当前对象的字段值中，即对象自行实现JSON反序列化逻辑
    13| 	 *
    14| 	 * @param value 被解析的对象类型，可能为JSON或者普通String、Number等
    15| 	 */
    16| 	void parse(T value);
    17| }


# ====================================================================
# FILE: hutool-jwt/src/main/java/cn/hutool/jwt/signers/AsymmetricJWTSigner.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 32-84 ---
    32| 	 * 构造
    33| 	 *
    34| 	 * @param algorithm 算法字符串表示
    35| 	 * @param keyPair   密钥对
    36| 	 */
    37| 	public AsymmetricJWTSigner(String algorithm, KeyPair keyPair) {
    38| 		this.sign = new Sign(algorithm, keyPair);
    39| 	}
    40| 	/**
    41| 	 * 设置编码
    42| 	 *
    43| 	 * @param charset 编码
    44| 	 * @return 编码
    45| 	 */
    46| 	public AsymmetricJWTSigner setCharset(Charset charset) {
    47| 		this.charset = charset;
    48| 		return this;
    49| 	}
    50| 	@Override
    51| 	public String sign(String headerBase64, String payloadBase64) {
    52| 		final String dataStr = StrUtil.format("{}.{}", headerBase64, payloadBase64);
    53| 		return Base64.encodeUrlSafe(sign(StrUtil.bytes(dataStr, charset)));
    54| 	}
    55| 	/**
    56| 	 * 签名字符串数据
    57| 	 *
    58| 	 * @param data 数据
    59| 	 * @return 签名
    60| 	 */
    61| 	protected byte[] sign(byte[] data) {
    62| 		return sign.sign(data);
    63| 	}
    64| 	@Override
    65| 	public boolean verify(String headerBase64, String payloadBase64, String signBase64) {
    66| 		return verify(
    67| 			StrUtil.bytes(StrUtil.format("{}.{}", headerBase64, payloadBase64), charset),
    68| 			Base64.decode(signBase64));
    69| 	}
    70| 	/**
    71| 	 * 验签数据
    72| 	 *
    73| 	 * @param data   数据
    74| 	 * @param signed 签名
    75| 	 * @return 是否通过
    76| 	 */
    77| 	protected boolean verify(byte[] data, byte[] signed) {
    78| 		return sign.verify(data, signed);
    79| 	}
    80| 	@Override
    81| 	public String getAlgorithm() {
    82| 		return this.sign.getSignature().getAlgorithm();
    83| 	}
    84| }


# ====================================================================
# FILE: hutool-jwt/src/main/java/cn/hutool/jwt/signers/EllipticCurveJWTSigner.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-139 ---
     1| package cn.hutool.jwt.signers;
     2| import cn.hutool.jwt.JWTException;
     3| import java.security.Key;
     4| import java.security.KeyPair;
     5| /**
     6|  * 椭圆曲线（Elliptic Curve）的JWT签名器。<br>
     7|  * 按照https://datatracker.ietf.org/doc/html/rfc7518#section-3.4,<br>
     8|  * Elliptic Curve Digital Signature Algorithm (ECDSA)算法签名需要转换DER格式为pair (R, S)
     9|  *
    10|  * @author looly
    11|  * @since 5.8.21
    12|  */
    13| public class EllipticCurveJWTSigner extends AsymmetricJWTSigner {
    14| 	/**
    15| 	 * 构造
    16| 	 *
    17| 	 * @param algorithm 算法
    18| 	 * @param key       密钥
    19| 	 */
    20| 	public EllipticCurveJWTSigner(String algorithm, Key key) {
    21| 		super(algorithm, key);
    22| 	}
    23| 	/**
    24| 	 * 构造
    25| 	 *
    26| 	 * @param algorithm 算法
    27| 	 * @param keyPair   密钥对
    28| 	 */
    29| 	public EllipticCurveJWTSigner(String algorithm, KeyPair keyPair) {
    30| 		super(algorithm, keyPair);
    31| 	}
    32| 	@Override
    33| 	protected byte[] sign(final byte[] data) {
    34| 		return derToConcat(super.sign(data), getSignatureByteArrayLength(getAlgorithm()));
    35| 	}
    36| 	@Override
    37| 	protected boolean verify(final byte[] data, final byte[] signed) {
    38| 		return super.verify(data, concatToDER(signed));
    39| 	}
    40| 	/**
    41| 	 * 获取签名长度
    42| 	 * @param alg 算法
    43| 	 * @return 长度
    44| 	 * @throws JWTException JWT异常
    45| 	 */
    46| 	private static int getSignatureByteArrayLength(final String alg) throws JWTException {
    47| 		switch (alg) {
    48| 			case "ES256":
    49| 			case "SHA256withECDSA":
    50| 				return 64;
    51| 			case "ES384":
    52| 			case "SHA384withECDSA":
    53| 				return 96;
    54| 			case "ES512":
    55| 			case "SHA512withECDSA":
    56| 				return 132;
    57| 			default:
    58| 				throw new JWTException("Unsupported Algorithm: {}", alg);
    59| 		}
    60| 	}
    61| 	private static byte[] derToConcat(final byte[] derSignature, int outputLength) throws JWTException {
    62| 		if (derSignature.length < 8 || derSignature[0] != 48) {
    63| 			throw new JWTException("Invalid ECDSA signature format");
    64| 		}
    65| 		final int offset;
    66| 		if (derSignature[1] > 0) {
    67| 			offset = 2;
    68| 		} else if (derSignature[1] == (byte) 0x81) {
    69| 			offset = 3;
    70| 		} else {
    71| 			throw new JWTException("Invalid ECDSA signature format");
    72| 		}
    73| 		final byte rLength = derSignature[offset + 1];
    74| 		int i = rLength;
    75| 		while ((i > 0) && (derSignature[(offset + 2 + rLength) - i] == 0)) {
    76| 			i--;
    77| 		}
    78| 		final byte sLength = derSignature[offset + 2 + rLength + 1];
    79| 		int j = sLength;
    80| 		while ((j > 0) && (derSignature[(offset + 2 + rLength + 2 + sLength) - j] == 0)) {
    81| 			j--;
    82| 		}
    83| 		int rawLen = Math.max(i, j);
    84| 		rawLen = Math.max(rawLen, outputLength / 2);
    85| 		if ((derSignature[offset - 1] & 0xff) != derSignature.length - offset
    86| 			|| (derSignature[offset - 1] & 0xff) != 2 + rLength + 2 + sLength
    87| 			|| derSignature[offset] != 2
    88| 			|| derSignature[offset + 2 + rLength] != 2) {
    89| 			throw new JWTException("Invalid ECDSA signature format");
    90| 		}
    91| 		final byte[] concatSignature = new byte[2 * rawLen];
    92| 		System.arraycopy(derSignature, (offset + 2 + rLength) - i, concatSignature, rawLen - i, i);
    93| 		System.arraycopy(derSignature, (offset + 2 + rLength + 2 + sLength) - j, concatSignature, 2 * rawLen - j, j);
    94| 		return concatSignature;
    95| 	}
    96| 	private static byte[] concatToDER(byte[] jwsSignature) throws ArrayIndexOutOfBoundsException {
    97| 		int rawLen = jwsSignature.length / 2;
    98| 		int i = rawLen;
    99| 		while ((i > 0) && (jwsSignature[rawLen - i] == 0)) {
   100| 			i--;
   101| 		}
   102| 		int j = i;
   103| 		if (jwsSignature[rawLen - i] < 0) {
   104| 			j += 1;
   105| 		}
   106| 		int k = rawLen;
   107| 		while ((k > 0) && (jwsSignature[2 * rawLen - k] == 0)) {
   108| 			k--;
   109| 		}
   110| 		int l = k;
   111| 		if (jwsSignature[2 * rawLen - k] < 0) {
   112| 			l += 1;
   113| 		}
   114| 		int len = 2 + j + 2 + l;
   115| 		if (len > 255) {
   116| 			throw new JWTException("Invalid ECDSA signature format");
   117| 		}
   118| 		int offset;
   119| 		final byte[] derSignature;
   120| 		if (len < 128) {
   121| 			derSignature = new byte[2 + 2 + j + 2 + l];
   122| 			offset = 1;
   123| 		} else {
   124| 			derSignature = new byte[3 + 2 + j + 2 + l];
   125| 			derSignature[1] = (byte) 0x81;
   126| 			offset = 2;
   127| 		}
   128| 		derSignature[0] = 48;
   129| 		derSignature[offset++] = (byte) len;
   130| 		derSignature[offset++] = 2;
   131| 		derSignature[offset++] = (byte) j;
   132| 		System.arraycopy(jwsSignature, rawLen - i, derSignature, (offset + j) - i, i);
   133| 		offset += j;
   134| 		derSignature[offset++] = 2;
   135| 		derSignature[offset++] = (byte) l;
   136| 		System.arraycopy(jwsSignature, 2 * rawLen - k, derSignature, (offset + l) - k, k);
   137| 		return derSignature;
   138| 	}
   139| }


# ====================================================================
# FILE: hutool-jwt/src/main/java/cn/hutool/jwt/signers/JWTSignerUtil.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-23 ---
     1| package cn.hutool.jwt.signers;
     2| import cn.hutool.core.lang.Assert;
     3| import cn.hutool.core.util.ReUtil;
     4| import java.security.Key;
     5| import java.security.KeyPair;
     6| import java.security.PrivateKey;
     7| import java.security.PublicKey;
     8| /**
     9|  * JWT签名器工具类
    10|  *
    11|  * @author looly
    12|  * @since 5.7.0
    13|  */
    14| public class JWTSignerUtil {
    15| 	/**
    16| 	 * 无签名
    17| 	 *
    18| 	 * @return 无签名的签名器
    19| 	 */
    20| 	public static JWTSigner none() {
    21| 		return NoneJWTSigner.NONE;
    22| 	}
    23| 	/**

# --- HUNK 2: Lines 200-245 ---
   200| 	 */
   201| 	public static JWTSigner createSigner(String algorithmId, byte[] key) {
   202| 		Assert.notNull(key, "Signer key must be not null!");
   203| 		if (null == algorithmId || NoneJWTSigner.ID_NONE.equals(algorithmId)) {
   204| 			return none();
   205| 		}
   206| 		return new HMacJWTSigner(AlgorithmUtil.getAlgorithm(algorithmId), key);
   207| 	}
   208| 	/**
   209| 	 * 创建签名器
   210| 	 *
   211| 	 * @param algorithmId 算法ID，见{@link AlgorithmUtil}
   212| 	 * @param keyPair     密钥对
   213| 	 * @return 签名器
   214| 	 */
   215| 	public static JWTSigner createSigner(String algorithmId, KeyPair keyPair) {
   216| 		Assert.notNull(keyPair, "Signer key pair must be not null!");
   217| 		if (null == algorithmId || NoneJWTSigner.ID_NONE.equals(algorithmId)) {
   218| 			return none();
   219| 		}
   220| 		if(ReUtil.isMatch("es\\d{3}", algorithmId.toLowerCase())){
   221| 			return new EllipticCurveJWTSigner(AlgorithmUtil.getAlgorithm(algorithmId), keyPair);
   222| 		}
   223| 		return new AsymmetricJWTSigner(AlgorithmUtil.getAlgorithm(algorithmId), keyPair);
   224| 	}
   225| 	/**
   226| 	 * 创建签名器
   227| 	 *
   228| 	 * @param algorithmId 算法ID，见{@link AlgorithmUtil}
   229| 	 * @param key         密钥
   230| 	 * @return 签名器
   231| 	 */
   232| 	public static JWTSigner createSigner(String algorithmId, Key key) {
   233| 		Assert.notNull(key, "Signer key must be not null!");
   234| 		if (null == algorithmId || NoneJWTSigner.ID_NONE.equals(algorithmId)) {
   235| 			return NoneJWTSigner.NONE;
   236| 		}
   237| 		if (key instanceof PrivateKey || key instanceof PublicKey) {
   238| 			if(ReUtil.isMatch("ES\\d{3}", algorithmId)){
   239| 				return new EllipticCurveJWTSigner(algorithmId, key);
   240| 			}
   241| 			return new AsymmetricJWTSigner(AlgorithmUtil.getAlgorithm(algorithmId), key);
   242| 		}
   243| 		return new HMacJWTSigner(AlgorithmUtil.getAlgorithm(algorithmId), key);
   244| 	}
   245| }


# ====================================================================
# FILE: hutool-poi/src/main/java/cn/hutool/poi/excel/ExcelReader.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 357-407 ---
   357| 	 * @param rowIndex 行号，从0开始
   358| 	 * @return 一行数据
   359| 	 * @since 4.0.3
   360| 	 */
   361| 	public List<Object> readRow(int rowIndex) {
   362| 		return readRow(this.sheet.getRow(rowIndex));
   363| 	}
   364| 	/**
   365| 	 * 读取某个单元格的值
   366| 	 *
   367| 	 * @param x X坐标，从0计数，即列号
   368| 	 * @param y Y坐标，从0计数，即行号
   369| 	 * @return 值，如果单元格无值返回null
   370| 	 * @since 4.0.3
   371| 	 */
   372| 	public Object readCellValue(int x, int y) {
   373| 		return CellUtil.getCellValue(getCell(x, y), this.cellEditor);
   374| 	}
   375| 	/**
   376| 	 * 获取Excel写出器<br>
   377| 	 * 在读取Excel并做一定编辑后，获取写出器写出，规则如下：
   378| 	 * <ul>
   379| 	 *     <li>1. 当从流中读取时，转换为Writer直接使用Sheet对象，此时修改不会影响源文件，Writer中flush需要指定新的路径。</li>
   380| 	 *     <li>2. 当从文件读取时，直接获取文件及sheet名称，此时可以修改原文件。</li>
   381| 	 * </ul>
   382| 	 *
   383| 	 * @return {@link ExcelWriter}
   384| 	 * @since 4.0.6
   385| 	 */
   386| 	public ExcelWriter getWriter() {
   387| 		if(null == this.destFile){
   388| 			return new ExcelWriter(this.sheet);
   389| 		}
   390| 		return ExcelUtil.getWriter(this.destFile, this.sheet.getSheetName());
   391| 	}
   392| 	/**
   393| 	 * 读取一行
   394| 	 *
   395| 	 * @param row 行
   396| 	 * @return 单元格值列表
   397| 	 */
   398| 	private List<Object> readRow(Row row) {
   399| 		return RowUtil.readRow(row, this.cellEditor);
   400| 	}
   401| 	/**
   402| 	 * 检查是否未关闭状态
   403| 	 */
   404| 	private void checkNotClosed() {
   405| 		Assert.isFalse(this.isClosed, "ExcelReader has been closed!");
   406| 	}
   407| }


# ====================================================================
# FILE: hutool-setting/src/main/java/cn/hutool/setting/SettingLoader.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 85-141 ---
    85| 	}
    86| 	/**
    87| 	 * 加载设置文件。 此方法不会关闭流对象
    88| 	 *
    89| 	 * @param settingStream 文件流
    90| 	 * @return 加载成功与否
    91| 	 * @throws IOException IO异常
    92| 	 */
    93| 	synchronized public boolean load(InputStream settingStream) throws IOException {
    94| 		this.groupedMap.clear();
    95| 		BufferedReader reader = null;
    96| 		try {
    97| 			reader = IoUtil.getReader(settingStream, this.charset);
    98| 			String group = null;
    99| 			String line;
   100| 			while (true) {
   101| 				line = reader.readLine();
   102| 				if (line == null) {
   103| 					break;
   104| 				}
   105| 				line = StrUtil.trim(line);
   106| 				if (StrUtil.isBlank(line) || StrUtil.startWith(line, COMMENT_FLAG_PRE)) {
   107| 					continue;
   108| 				}
   109| 				if (StrUtil.isSurround(line, CharUtil.BRACKET_START, CharUtil.BRACKET_END)) {
   110| 					group = StrUtil.trim(line.substring(1, line.length() - 1));
   111| 					continue;
   112| 				}
   113| 				final String[] keyValue = StrUtil.splitToArray(line, this.assignFlag, 2);
   114| 				if (keyValue.length < 2) {
   115| 					continue;
   116| 				}
   117| 				String value = StrUtil.trim(keyValue[1]);
   118| 				if (this.isUseVariable) {
   119| 					value = replaceVar(group, value);
   120| 				}
   121| 				this.groupedMap.put(group, StrUtil.trim(keyValue[0]), value);
   122| 			}
   123| 		} finally {
   124| 			IoUtil.close(reader);
   125| 		}
   126| 		return true;
   127| 	}
   128| 	/**
   129| 	 * 设置变量的正则<br>
   130| 	 * 正则只能有一个group表示变量本身，剩余为字符 例如 \$\{(name)\}表示${name}变量名为name的一个变量表示
   131| 	 *
   132| 	 * @param regex 正则
   133| 	 */
   134| 	public void setVarRegex(String regex) {
   135| 		this.varRegex = regex;
   136| 	}
   137| 	/**
   138| 	 * 赋值分隔符（用于分隔键值对）
   139| 	 *
   140| 	 * @param assignFlag 正则
   141| 	 * @since 4.6.5


# ====================================================================
# FILE: hutool-system/src/main/java/cn/hutool/system/UserInfo.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 4-44 ---
     4| import java.io.Serializable;
     5| /**
     6|  * 代表当前用户的信息。
     7|  */
     8| public class UserInfo implements Serializable{
     9| 	private static final long serialVersionUID = 1L;
    10| 	private final String USER_NAME;
    11| 	private final String USER_HOME;
    12| 	private final String USER_DIR;
    13| 	private final String JAVA_IO_TMPDIR;
    14| 	private final String USER_LANGUAGE;
    15| 	private final String USER_COUNTRY;
    16| 	public UserInfo(){
    17| 		USER_NAME = fixPath(SystemUtil.get("user.name", false));
    18| 		USER_HOME = fixPath(SystemUtil.get("user.home", false));
    19| 		USER_DIR = fixPath(SystemUtil.get("user.dir", false));
    20| 		JAVA_IO_TMPDIR = fixPath(SystemUtil.get("java.io.tmpdir", false));
    21| 		USER_LANGUAGE = SystemUtil.get("user.language", false);
    22| 		String userCountry = SystemUtil.get("user.country", false);
    23| 		if(null == userCountry){
    24| 			userCountry = SystemUtil.get("user.region", false);
    25| 		}
    26| 		USER_COUNTRY = userCountry;
    27| 	}
    28| 	/**
    29| 	 * 取得当前登录用户的名字（取自系统属性：{@code user.name}）。
    30| 	 *
    31| 	 * <p>
    32| 	 * 例如：{@code "admin"}
    33| 	 * </p>
    34| 	 *
    35| 	 * @return 属性值，如果不能取得（因为Java安全限制）或值不存在，则返回{@code null}。
    36| 	 *
    37| 	 * @since Java 1.1
    38| 	 */
    39| 	public final String getName() {
    40| 		return USER_NAME;
    41| 	}
    42| 	/**
    43| 	 * 取得当前登录用户的home目录（取自系统属性：{@code user.home}）。
    44| 	 *

