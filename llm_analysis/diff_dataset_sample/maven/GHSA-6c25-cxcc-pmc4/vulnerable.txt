# ====================================================================
# FILE: docs/js/version.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1 ---
     1| var version = '5.8.20'


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/bean/BeanUtil.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 885-916 ---
   885| 			throw new IllegalArgumentException("Invalid Getter or Setter name: " + getterOrSetterName);
   886| 		}
   887| 	}
   888| 	/**
   889| 	 * 判断source与target的所有公共字段的值是否相同
   890| 	 *
   891| 	 * @param source           待检测对象1
   892| 	 * @param target           待检测对象2
   893| 	 * @param ignoreProperties 不需要检测的字段
   894| 	 * @return 判断结果，如果为true则证明所有字段的值都相同
   895| 	 * @author Takak11
   896| 	 * @since 5.8.4
   897| 	 */
   898| 	public static boolean isCommonFieldsEqual(Object source, Object target, String... ignoreProperties) {
   899| 		if (null == source && null == target) {
   900| 			return true;
   901| 		}
   902| 		if (null == source || null == target) {
   903| 			return false;
   904| 		}
   905| 		Map<String, Object> sourceFieldsMap = BeanUtil.beanToMap(source);
   906| 		Map<String, Object> targetFieldsMap = BeanUtil.beanToMap(target);
   907| 		Set<String> sourceFields = sourceFieldsMap.keySet();
   908| 		sourceFields.removeAll(Arrays.asList(ignoreProperties));
   909| 		for (String field : sourceFields) {
   910| 			if (ObjectUtil.notEqual(sourceFieldsMap.get(field), targetFieldsMap.get(field))) {
   911| 				return false;
   912| 			}
   913| 		}
   914| 		return true;
   915| 	}
   916| }


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/collection/CollUtil.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 2624-2676 ---
  2624| 	 * @return Value集合
  2625| 	 * @since 4.5.12
  2626| 	 */
  2627| 	public static <V> List<V> values(Collection<Map<?, V>> mapCollection) {
  2628| 		final List<V> values = new ArrayList<>();
  2629| 		for (Map<?, V> map : mapCollection) {
  2630| 			values.addAll(map.values());
  2631| 		}
  2632| 		return values;
  2633| 	}
  2634| 	/**
  2635| 	 * 取最大值
  2636| 	 *
  2637| 	 * @param <T>  元素类型
  2638| 	 * @param coll 集合
  2639| 	 * @return 最大值
  2640| 	 * @see Collections#max(Collection)
  2641| 	 * @since 4.6.5
  2642| 	 */
  2643| 	public static <T extends Comparable<? super T>> T max(Collection<T> coll) {
  2644| 		return Collections.max(coll);
  2645| 	}
  2646| 	/**
  2647| 	 * 取最小值
  2648| 	 *
  2649| 	 * @param <T>  元素类型
  2650| 	 * @param coll 集合
  2651| 	 * @return 最小值
  2652| 	 * @see Collections#min(Collection)
  2653| 	 * @since 4.6.5
  2654| 	 */
  2655| 	public static <T extends Comparable<? super T>> T min(Collection<T> coll) {
  2656| 		return Collections.min(coll);
  2657| 	}
  2658| 	/**
  2659| 	 * 转为只读集合
  2660| 	 *
  2661| 	 * @param <T> 元素类型
  2662| 	 * @param c   集合
  2663| 	 * @return 只读集合
  2664| 	 * @since 5.2.6
  2665| 	 */
  2666| 	public static <T> Collection<T> unmodifiable(Collection<? extends T> c) {
  2667| 		return Collections.unmodifiableCollection(c);
  2668| 	}
  2669| 	/**
  2670| 	 * 根据给定的集合类型，返回对应的空集合，支持类型包括：
  2671| 	 * *
  2672| 	 * <pre>
  2673| 	 *     1. NavigableSet
  2674| 	 *     2. SortedSet
  2675| 	 *     3. Set
  2676| 	 *     4. List


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/comparator/VersionComparator.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-75 ---
     1| package cn.hutool.core.comparator;
     2| import cn.hutool.core.util.CharUtil;
     3| import cn.hutool.core.util.ObjectUtil;
     4| import cn.hutool.core.util.StrUtil;
     5| import java.io.Serializable;
     6| import java.util.Comparator;
     7| import java.util.List;
     8| /**
     9|  * 版本比较器<br>
    10|  * 比较两个版本的大小<br>
    11|  * 排序时版本从小到大排序，即比较时小版本在前，大版本在后<br>
    12|  * 支持如：1.3.20.8，6.82.20160101，8.5a/8.5c等版本形式<br>
    13|  * 参考：https://www.cnblogs.com/shihaiming/p/6286575.html
    14|  *
    15|  * @author Looly
    16|  * @since 4.0.2
    17|  */
    18| public class VersionComparator implements Comparator<String>, Serializable {
    19| 	private static final long serialVersionUID = 8083701245147495562L;
    20| 	/** 单例 */
    21| 	public static final VersionComparator INSTANCE = new VersionComparator();
    22| 	/**
    23| 	 * 默认构造
    24| 	 */
    25| 	public VersionComparator() {
    26| 	}
    27| 	/**
    28| 	 * 比较两个版本<br>
    29| 	 * null版本排在最小：即：
    30| 	 * <pre>
    31| 	 * compare(null, "v1") &lt; 0
    32| 	 * compare("v1", "v1")  = 0
    33| 	 * compare(null, null)   = 0
    34| 	 * compare("v1", null) &gt; 0
    35| 	 * compare("1.0.0", "1.0.2") &lt; 0
    36| 	 * compare("1.0.2", "1.0.2a") &lt; 0
    37| 	 * compare("1.13.0", "1.12.1c") &gt; 0
    38| 	 * compare("V0.0.20170102", "V0.0.20170101") &gt; 0
    39| 	 * </pre>
    40| 	 *
    41| 	 * @param version1 版本1
    42| 	 * @param version2 版本2
    43| 	 */
    44| 	@Override
    45| 	public int compare(String version1, String version2) {
    46| 		if(ObjectUtil.equal(version1, version2)) {
    47| 			return 0;
    48| 		}
    49| 		if (version1 == null && version2 == null) {
    50| 			return 0;
    51| 		} else if (version1 == null) {// null视为最小版本，排在前
    52| 			return -1;
    53| 		} else if (version2 == null) {
    54| 			return 1;
    55| 		}
    56| 		final List<String> v1s = StrUtil.split(version1, CharUtil.DOT);
    57| 		final List<String> v2s = StrUtil.split(version2, CharUtil.DOT);
    58| 		int diff = 0;
    59| 		int minLength = Math.min(v1s.size(), v2s.size());// 取最小长度值
    60| 		String v1;
    61| 		String v2;
    62| 		for (int i = 0; i < minLength; i++) {
    63| 			v1 = v1s.get(i);
    64| 			v2 = v2s.get(i);
    65| 			diff = v1.length() - v2.length();
    66| 			if (0 == diff) {
    67| 				diff = v1.compareTo(v2);
    68| 			}
    69| 			if(diff != 0) {
    70| 				break;
    71| 			}
    72| 		}
    73| 		return (diff != 0) ? diff : v1s.size() - v2s.size();
    74| 	}
    75| }


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/compress/ZipReader.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 6-49 ---
     6| import cn.hutool.core.lang.Filter;
     7| import cn.hutool.core.util.StrUtil;
     8| import cn.hutool.core.util.ZipUtil;
     9| import java.io.Closeable;
    10| import java.io.File;
    11| import java.io.IOException;
    12| import java.io.InputStream;
    13| import java.nio.charset.Charset;
    14| import java.util.Enumeration;
    15| import java.util.function.Consumer;
    16| import java.util.zip.ZipEntry;
    17| import java.util.zip.ZipFile;
    18| import java.util.zip.ZipInputStream;
    19| /**
    20|  * Zip文件或流读取器，一般用于Zip文件解压
    21|  *
    22|  * @author looly
    23|  * @since 5.7.8
    24|  */
    25| public class ZipReader implements Closeable {
    26| 	private static final int MAX_SIZE_DIFF = 100;
    27| 	private ZipFile zipFile;
    28| 	private ZipInputStream in;
    29| 	/**
    30| 	 * 创建ZipReader
    31| 	 *
    32| 	 * @param zipFile 生成的Zip文件
    33| 	 * @param charset 编码
    34| 	 * @return ZipReader
    35| 	 */
    36| 	public static ZipReader of(File zipFile, Charset charset) {
    37| 		return new ZipReader(zipFile, charset);
    38| 	}
    39| 	/**
    40| 	 * 创建ZipReader
    41| 	 *
    42| 	 * @param in      Zip输入的流，一般为输入文件流
    43| 	 * @param charset 编码
    44| 	 * @return ZipReader
    45| 	 */
    46| 	public static ZipReader of(InputStream in, Charset charset) {
    47| 		return new ZipReader(in, charset);
    48| 	}
    49| 	/**

# --- HUNK 2: Lines 62-101 ---
    62| 	 */
    63| 	public ZipReader(ZipFile zipFile) {
    64| 		this.zipFile = zipFile;
    65| 	}
    66| 	/**
    67| 	 * 构造
    68| 	 *
    69| 	 * @param in      读取的的Zip文件流
    70| 	 * @param charset 编码
    71| 	 */
    72| 	public ZipReader(InputStream in, Charset charset) {
    73| 		this.in = new ZipInputStream(in, charset);
    74| 	}
    75| 	/**
    76| 	 * 构造
    77| 	 *
    78| 	 * @param zin 读取的的Zip文件流
    79| 	 */
    80| 	public ZipReader(ZipInputStream zin) {
    81| 		this.in = zin;
    82| 	}
    83| 	/**
    84| 	 * 获取指定路径的文件流<br>
    85| 	 * 如果是文件模式，则直接获取Entry对应的流，如果是流模式，则遍历entry后，找到对应流返回
    86| 	 *
    87| 	 * @param path 路径
    88| 	 * @return 文件流
    89| 	 */
    90| 	public InputStream get(String path) {
    91| 		if (null != this.zipFile) {
    92| 			final ZipFile zipFile = this.zipFile;
    93| 			final ZipEntry entry = zipFile.getEntry(path);
    94| 			if (null != entry) {
    95| 				return ZipUtil.getStream(zipFile, entry);
    96| 			}
    97| 		} else {
    98| 			try {
    99| 				ZipEntry zipEntry;
   100| 				while (null != (zipEntry = in.getNextEntry())) {
   101| 					if (zipEntry.getName().equals(path)) {

# --- HUNK 3: Lines 190-223 ---
   190| 	 * @param consumer {@link ZipEntry}处理器
   191| 	 * @throws IORuntimeException IO异常
   192| 	 */
   193| 	private void readFromStream(Consumer<ZipEntry> consumer) throws IORuntimeException {
   194| 		try {
   195| 			ZipEntry zipEntry;
   196| 			while (null != (zipEntry = in.getNextEntry())) {
   197| 				consumer.accept(zipEntry);
   198| 				checkZipBomb(zipEntry);
   199| 			}
   200| 		} catch (IOException e) {
   201| 			throw new IORuntimeException(e);
   202| 		}
   203| 	}
   204| 	/**
   205| 	 * 检查Zip bomb漏洞
   206| 	 *
   207| 	 * @param entry {@link ZipEntry}
   208| 	 * @return 检查后的{@link ZipEntry}
   209| 	 */
   210| 	private static ZipEntry checkZipBomb(ZipEntry entry) {
   211| 		if (null == entry) {
   212| 			return null;
   213| 		}
   214| 		final long compressedSize = entry.getCompressedSize();
   215| 		final long uncompressedSize = entry.getSize();
   216| 		if (compressedSize < 0 || uncompressedSize < 0 ||
   217| 				compressedSize * MAX_SIZE_DIFF < uncompressedSize) {
   218| 			throw new UtilException("Zip bomb attack detected, invalid sizes: compressed {}, uncompressed {}, name {}",
   219| 					compressedSize, uncompressedSize, entry.getName());
   220| 		}
   221| 		return entry;
   222| 	}
   223| }


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/convert/ConverterRegistry.java
# Total hunks: 5
# ====================================================================
# --- HUNK 1: Lines 1-60 ---
     1| package cn.hutool.core.convert;
     2| import cn.hutool.core.bean.BeanUtil;
     3| import cn.hutool.core.convert.impl.*;
     4| import cn.hutool.core.date.DateTime;
     5| import cn.hutool.core.lang.Opt;
     6| import cn.hutool.core.lang.Pair;
     7| import cn.hutool.core.lang.TypeReference;
     8| import cn.hutool.core.map.SafeConcurrentHashMap;
     9| import cn.hutool.core.util.*;
    10| import java.io.Serializable;
    11| import java.lang.ref.SoftReference;
    12| import java.lang.ref.WeakReference;
    13| import java.lang.reflect.Type;
    14| import java.math.BigDecimal;
    15| import java.math.BigInteger;
    16| import java.net.URI;
    17| import java.net.URL;
    18| import java.nio.charset.Charset;
    19| import java.nio.file.Path;
    20| import java.time.*;
    21| import java.time.temporal.TemporalAccessor;
    22| import java.util.*;
    23| import java.util.concurrent.atomic.*;
    24| /**
    25|  * 转换器登记中心
    26|  * <p>
    27|  * 将各种类型Convert对象放入登记中心，通过convert方法查找目标类型对应的转换器，将被转换对象转换之。
    28|  * </p>
    29|  * <p>
    30|  * 在此类中，存放着默认转换器和自定义转换器，默认转换器是Hutool中预定义的一些转换器，自定义转换器存放用户自定的转换器。
    31|  * </p>
    32|  *
    33|  * @author Looly
    34|  */
    35| public class ConverterRegistry implements Serializable {
    36| 	private static final long serialVersionUID = 1L;
    37| 	/**
    38| 	 * 默认类型转换器
    39| 	 */
    40| 	private Map<Type, Converter<?>> defaultConverterMap;
    41| 	/**
    42| 	 * 用户自定义类型转换器
    43| 	 */
    44| 	private volatile Map<Type, Converter<?>> customConverterMap;
    45| 	/**
    46| 	 * 类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例 没有绑定关系，而且只有被调用到才会装载，从而实现了延迟加载
    47| 	 */
    48| 	private static class SingletonHolder {
    49| 		/**
    50| 		 * 静态初始化器，由JVM来保证线程安全
    51| 		 */
    52| 		private static final ConverterRegistry INSTANCE = new ConverterRegistry();
    53| 	}
    54| 	/**
    55| 	 * 获得单例的 ConverterRegistry
    56| 	 *
    57| 	 * @return ConverterRegistry
    58| 	 */
    59| 	public static ConverterRegistry getInstance() {
    60| 		return SingletonHolder.INSTANCE;

# --- HUNK 2: Lines 123-163 ---
   123| 			if (null == converter) {
   124| 				converter = this.getDefaultConverter(type);
   125| 			}
   126| 		} else {
   127| 			converter = this.getDefaultConverter(type);
   128| 			if (null == converter) {
   129| 				converter = this.getCustomConverter(type);
   130| 			}
   131| 		}
   132| 		return converter;
   133| 	}
   134| 	/**
   135| 	 * 获得默认转换器
   136| 	 *
   137| 	 * @param <T>  转换的目标类型（转换器转换到的类型）
   138| 	 * @param type 类型
   139| 	 * @return 转换器
   140| 	 */
   141| 	@SuppressWarnings("unchecked")
   142| 	public <T> Converter<T> getDefaultConverter(Type type) {
   143| 		return (null == defaultConverterMap) ? null : (Converter<T>) defaultConverterMap.get(type);
   144| 	}
   145| 	/**
   146| 	 * 获得自定义转换器
   147| 	 *
   148| 	 * @param <T>  转换的目标类型（转换器转换到的类型）
   149| 	 * @param type 类型
   150| 	 * @return 转换器
   151| 	 */
   152| 	@SuppressWarnings("unchecked")
   153| 	public <T> Converter<T> getCustomConverter(Type type) {
   154| 		return (null == customConverterMap) ? null : (Converter<T>) customConverterMap.get(type);
   155| 	}
   156| 	/**
   157| 	 * 转换值为指定类型
   158| 	 *
   159| 	 * @param <T>           转换的目标类型（转换器转换到的类型）
   160| 	 * @param type          类型目标
   161| 	 * @param value         被转换值
   162| 	 * @param defaultValue  默认值
   163| 	 * @param isCustomFirst 是否自定义转换器优先

# --- HUNK 3: Lines 254-293 ---
   254| 			final CollectionConverter collectionConverter = new CollectionConverter(type);
   255| 			return (T) collectionConverter.convert(value, (Collection<?>) defaultValue);
   256| 		}
   257| 		if (Map.class.isAssignableFrom(rowType)) {
   258| 			final MapConverter mapConverter = new MapConverter(type);
   259| 			return (T) mapConverter.convert(value, (Map<?, ?>) defaultValue);
   260| 		}
   261| 		if (Map.Entry.class.isAssignableFrom(rowType)) {
   262| 			final EntryConverter mapConverter = new EntryConverter(type);
   263| 			return (T) mapConverter.convert(value, (Map.Entry<?, ?>) defaultValue);
   264| 		}
   265| 		if (rowType.isInstance(value)) {
   266| 			return (T) value;
   267| 		}
   268| 		if (rowType.isEnum()) {
   269| 			return (T) new EnumConverter(rowType).convert(value, defaultValue);
   270| 		}
   271| 		if (rowType.isArray()) {
   272| 			final ArrayConverter arrayConverter = new ArrayConverter(rowType);
   273| 			return (T) arrayConverter.convert(value, defaultValue);
   274| 		}
   275| 		return null;
   276| 	}
   277| 	/**
   278| 	 * 注册默认转换器
   279| 	 *
   280| 	 * @return 转换器
   281| 	 */
   282| 	private ConverterRegistry defaultConverter() {
   283| 		defaultConverterMap = new SafeConcurrentHashMap<>();
   284| 		defaultConverterMap.put(int.class, new PrimitiveConverter(int.class));
   285| 		defaultConverterMap.put(long.class, new PrimitiveConverter(long.class));
   286| 		defaultConverterMap.put(byte.class, new PrimitiveConverter(byte.class));
   287| 		defaultConverterMap.put(short.class, new PrimitiveConverter(short.class));
   288| 		defaultConverterMap.put(float.class, new PrimitiveConverter(float.class));
   289| 		defaultConverterMap.put(double.class, new PrimitiveConverter(double.class));
   290| 		defaultConverterMap.put(char.class, new PrimitiveConverter(char.class));
   291| 		defaultConverterMap.put(boolean.class, new PrimitiveConverter(boolean.class));
   292| 		defaultConverterMap.put(Number.class, new NumberConverter());
   293| 		defaultConverterMap.put(Integer.class, new NumberConverter(Integer.class));

# --- HUNK 4: Lines 316-349 ---
   316| 		defaultConverterMap.put(java.sql.Time.class, new DateConverter(java.sql.Time.class));
   317| 		defaultConverterMap.put(java.sql.Timestamp.class, new DateConverter(java.sql.Timestamp.class));
   318| 		defaultConverterMap.put(TemporalAccessor.class, new TemporalAccessorConverter(Instant.class));
   319| 		defaultConverterMap.put(Instant.class, new TemporalAccessorConverter(Instant.class));
   320| 		defaultConverterMap.put(LocalDateTime.class, new TemporalAccessorConverter(LocalDateTime.class));
   321| 		defaultConverterMap.put(LocalDate.class, new TemporalAccessorConverter(LocalDate.class));
   322| 		defaultConverterMap.put(LocalTime.class, new TemporalAccessorConverter(LocalTime.class));
   323| 		defaultConverterMap.put(ZonedDateTime.class, new TemporalAccessorConverter(ZonedDateTime.class));
   324| 		defaultConverterMap.put(OffsetDateTime.class, new TemporalAccessorConverter(OffsetDateTime.class));
   325| 		defaultConverterMap.put(OffsetTime.class, new TemporalAccessorConverter(OffsetTime.class));
   326| 		defaultConverterMap.put(DayOfWeek.class, new TemporalAccessorConverter(DayOfWeek.class));
   327| 		defaultConverterMap.put(Month.class, new TemporalAccessorConverter(Month.class));
   328| 		defaultConverterMap.put(MonthDay.class, new TemporalAccessorConverter(MonthDay.class));
   329| 		defaultConverterMap.put(Period.class, new PeriodConverter());
   330| 		defaultConverterMap.put(Duration.class, new DurationConverter());
   331| 		defaultConverterMap.put(WeakReference.class, new ReferenceConverter(WeakReference.class));// since 3.0.8
   332| 		defaultConverterMap.put(SoftReference.class, new ReferenceConverter(SoftReference.class));// since 3.0.8
   333| 		defaultConverterMap.put(AtomicReference.class, new AtomicReferenceConverter());// since 3.0.8
   334| 		defaultConverterMap.put(AtomicIntegerArray.class, new AtomicIntegerArrayConverter());
   335| 		defaultConverterMap.put(AtomicLongArray.class, new AtomicLongArrayConverter());
   336| 		defaultConverterMap.put(Class.class, new ClassConverter());
   337| 		defaultConverterMap.put(TimeZone.class, new TimeZoneConverter());
   338| 		defaultConverterMap.put(Locale.class, new LocaleConverter());
   339| 		defaultConverterMap.put(Charset.class, new CharsetConverter());
   340| 		defaultConverterMap.put(Path.class, new PathConverter());
   341| 		defaultConverterMap.put(Currency.class, new CurrencyConverter());// since 3.0.8
   342| 		defaultConverterMap.put(UUID.class, new UUIDConverter());// since 4.0.10
   343| 		defaultConverterMap.put(StackTraceElement.class, new StackTraceElementConverter());// since 4.5.2
   344| 		defaultConverterMap.put(Optional.class, new OptionalConverter());// since 5.0.0
   345| 		defaultConverterMap.put(Opt.class, new OptConverter());// since 5.7.16
   346| 		defaultConverterMap.put(Pair.class, new PairConverter(Pair.class));// since 5.8.17
   347| 		return this;
   348| 	}
   349| }


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/convert/impl/BeanConverter.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-27 ---
     1| package cn.hutool.core.convert.impl;
     2| import cn.hutool.core.bean.BeanUtil;
     3| import cn.hutool.core.bean.copier.BeanCopier;
     4| import cn.hutool.core.bean.copier.CopyOptions;
     5| import cn.hutool.core.bean.copier.ValueProvider;
     6| import cn.hutool.core.convert.AbstractConverter;
     7| import cn.hutool.core.convert.ConvertException;
     8| import cn.hutool.core.map.MapProxy;
     9| import cn.hutool.core.util.ObjectUtil;
    10| import cn.hutool.core.util.ReflectUtil;
    11| import cn.hutool.core.util.StrUtil;
    12| import cn.hutool.core.util.TypeUtil;
    13| import java.lang.reflect.Type;
    14| import java.util.Map;
    15| /**
    16|  * Bean转换器，支持：
    17|  * <pre>
    18|  * Map =》 Bean
    19|  * Bean =》 Bean
    20|  * ValueProvider =》 Bean
    21|  * </pre>
    22|  *
    23|  * @param <T> Bean类型
    24|  * @author Looly
    25|  * @since 4.0.2
    26|  */
    27| public class BeanConverter<T> extends AbstractConverter<T> {

# --- HUNK 2: Lines 42-80 ---
    42| 	 *
    43| 	 * @param beanClass 转换成的目标Bean类
    44| 	 */
    45| 	public BeanConverter(Class<T> beanClass) {
    46| 		this(beanClass, CopyOptions.create().setIgnoreError(true));
    47| 	}
    48| 	/**
    49| 	 * 构造
    50| 	 *
    51| 	 * @param beanType 转换成的目标Bean类
    52| 	 * @param copyOptions Bean转换选项参数
    53| 	 */
    54| 	@SuppressWarnings("unchecked")
    55| 	public BeanConverter(Type beanType, CopyOptions copyOptions) {
    56| 		this.beanType = beanType;
    57| 		this.beanClass = (Class<T>) TypeUtil.getClass(beanType);
    58| 		this.copyOptions = copyOptions;
    59| 	}
    60| 	@Override
    61| 	protected T convertInternal(Object value) {
    62| 		if(value instanceof Map ||
    63| 				value instanceof ValueProvider ||
    64| 				BeanUtil.isBean(value.getClass())) {
    65| 			if(value instanceof Map && this.beanClass.isInterface()) {
    66| 				return MapProxy.create((Map<?, ?>)value).toProxyBean(this.beanClass);
    67| 			}
    68| 			return BeanCopier.create(value, ReflectUtil.newInstanceIfPossible(this.beanClass), this.beanType, this.copyOptions).copy();
    69| 		} else if(value instanceof byte[]){
    70| 			return ObjectUtil.deserialize((byte[])value);
    71| 		} else if(StrUtil.isEmptyIfStr(value)){
    72| 			return null;
    73| 		}
    74| 		throw new ConvertException("Unsupported source type: {}", value.getClass());
    75| 	}
    76| 	@Override
    77| 	public Class<T> getTargetType() {
    78| 		return this.beanClass;
    79| 	}
    80| }


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/date/DateUtil.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 746-786 ---
   746| 	 * <li>yyyy-MM-dd'T'HH:mm:ssZ</li>
   747| 	 * <li>yyyy-MM-dd'T'HH:mm:ss.SSSZ</li>
   748| 	 * <li>yyyy-MM-dd'T'HH:mm:ss+0800</li>
   749| 	 * <li>yyyy-MM-dd'T'HH:mm:ss+08:00</li>
   750| 	 * </ol>
   751| 	 *
   752| 	 * @param utcString UTC时间
   753| 	 * @return 日期对象
   754| 	 * @since 4.1.14
   755| 	 */
   756| 	public static DateTime parseUTC(String utcString) {
   757| 		if (utcString == null) {
   758| 			return null;
   759| 		}
   760| 		final int length = utcString.length();
   761| 		if (StrUtil.contains(utcString, 'Z')) {
   762| 			if (length == DatePattern.UTC_PATTERN.length() - 4) {
   763| 				return parse(utcString, DatePattern.UTC_FORMAT);
   764| 			}
   765| 			final int patternLength = DatePattern.UTC_MS_PATTERN.length();
   766| 			if (length <= patternLength - 4 && length >= patternLength - 6) {
   767| 				return parse(utcString, DatePattern.UTC_MS_FORMAT);
   768| 			}
   769| 		} else if (StrUtil.contains(utcString, '+')) {
   770| 			utcString = utcString.replace(" +", "+");
   771| 			final String zoneOffset = StrUtil.subAfter(utcString, '+', true);
   772| 			if (StrUtil.isBlank(zoneOffset)) {
   773| 				throw new DateException("Invalid format: [{}]", utcString);
   774| 			}
   775| 			if (false == StrUtil.contains(zoneOffset, ':')) {
   776| 				final String pre = StrUtil.subBefore(utcString, '+', true);
   777| 				utcString = pre + "+" + zoneOffset.substring(0, 2) + ":" + "00";
   778| 			}
   779| 			if (StrUtil.contains(utcString, CharUtil.DOT)) {
   780| 				utcString = normalizeMillSeconds(utcString, ".", "+");
   781| 				return parse(utcString, DatePattern.UTC_MS_WITH_XXX_OFFSET_FORMAT);
   782| 			} else {
   783| 				return parse(utcString, DatePattern.UTC_WITH_XXX_OFFSET_FORMAT);
   784| 			}
   785| 		} else if(ReUtil.contains("-\\d{2}:?00", utcString)){
   786| 			utcString = utcString.replace(" -", "-");


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/io/FileTypeUtil.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 52-136 ---
    52| 					return fileTypeEntry.getValue();
    53| 				}
    54| 			}
    55| 		}
    56| 		byte[] bytes = (HexUtil.decodeHex(fileStreamHexHead));
    57| 		return FileMagicNumber.getMagicNumber(bytes).getExtension();
    58| 	}
    59| 	/**
    60| 	 * 根据文件流的头部信息获得文件类型
    61| 	 *
    62| 	 * @param in 文件流
    63| 	 * @param fileHeadSize 自定义读取文件头部的大小
    64| 	 * @return 文件类型，未找到为{@code null}
    65| 	 */
    66| 	public static String getType(InputStream in,int fileHeadSize) throws IORuntimeException  {
    67| 		return getType((IoUtil.readHex(in, fileHeadSize,false)));
    68| 	}
    69| 	/**
    70| 	 * 根据文件流的头部信息获得文件类型<br>
    71| 	 * 注意此方法会读取头部一些bytes，造成此流接下来读取时缺少部分bytes<br>
    72| 	 * 因此如果想服用此流，流需支持{@link InputStream#reset()}方法。
    73| 	 * @param in {@link InputStream}
    74| 	 * @param isExact 是否精确匹配，如果为false，使用前64个bytes匹配，如果为true，使用前8192bytes匹配
    75| 	 * @return 类型，文件的扩展名，未找到为{@code null}
    76| 	 * @throws IORuntimeException  读取流引起的异常
    77| 	 */
    78| 	public static String getType(InputStream in,boolean isExact) throws  IORuntimeException  {
    79| 		return isExact
    80| 				?getType(IoUtil.readHex8192Upper(in))
    81| 				:getType(IoUtil.readHex64Upper(in));
    82| 	}
    83| 	/**
    84| 	 * 根据文件流的头部信息获得文件类型<br>
    85| 	 * 注意此方法会读取头部64个bytes，造成此流接下来读取时缺少部分bytes<br>
    86| 	 * 因此如果想服用此流，流需支持{@link InputStream#reset()}方法。
    87| 	 * @param in {@link InputStream}
    88| 	 * @return 类型，文件的扩展名，未找到为{@code null}
    89| 	 * @throws IORuntimeException  读取流引起的异常
    90| 	 */
    91| 	public static String getType(InputStream in) throws IORuntimeException  {
    92| 		return getType(in,false);
    93| 	}
    94| 	/**
    95| 	 * 根据文件流的头部信息获得文件类型
    96| 	 * 注意此方法会读取头部64个bytes，造成此流接下来读取时缺少部分bytes<br>
    97| 	 * 因此如果想服用此流，流需支持{@link InputStream#reset()}方法。
    98| 	 *
    99| 	 * <pre>
   100| 	 *     1、无法识别类型默认按照扩展名识别
   101| 	 *     2、xls、doc、msi头信息无法区分，按照扩展名区分
   102| 	 *     3、zip可能为docx、xlsx、pptx、jar、war、ofd头信息无法区分，按照扩展名区分
   103| 	 * </pre>
   104| 	 *
   105| 	 * @param in       {@link InputStream}
   106| 	 * @param filename 文件名
   107| 	 * @return 类型，文件的扩展名，未找到为{@code null}
   108| 	 * @throws IORuntimeException  读取流引起的异常
   109| 	 */
   110| 	public static String getType(InputStream in, String filename) throws IORuntimeException  {
   111| 		return getType(in,filename,false);
   112| 	}
   113| 	/**
   114| 	 * 根据文件流的头部信息获得文件类型
   115| 	 * 注意此方法会读取头部一些bytes，造成此流接下来读取时缺少部分bytes<br>
   116| 	 * 因此如果想服用此流，流需支持{@link InputStream#reset()}方法。
   117| 	 *
   118| 	 * <pre>
   119| 	 *     1、无法识别类型默认按照扩展名识别
   120| 	 *     2、xls、doc、msi头信息无法区分，按照扩展名区分
   121| 	 *     3、zip可能为docx、xlsx、pptx、jar、war、ofd头信息无法区分，按照扩展名区分
   122| 	 * </pre>
   123| 	 * @param in       {@link InputStream}
   124| 	 * @param filename 文件名
   125| 	 * @param isExact 是否精确匹配，如果为false，使用前64个bytes匹配，如果为true，使用前8192bytes匹配
   126| 	 * @return 类型，文件的扩展名，未找到为{@code null}
   127| 	 * @throws IORuntimeException  读取流引起的异常
   128| 	 */
   129| 	public static String getType(InputStream in, String filename,boolean isExact) throws IORuntimeException  {
   130| 		String typeName = getType(in,isExact);
   131| 		if (null == typeName) {
   132| 			typeName = FileUtil.extName(filename);
   133| 		} else if ("zip".equals(typeName)) {
   134| 			final String extName = FileUtil.extName(filename);
   135| 			if ("docx".equalsIgnoreCase(extName)) {
   136| 				typeName = "docx";


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/io/file/PathUtil.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 553-594 ---
   553| 	 *
   554| 	 * @param path 文件或目录Path
   555| 	 * @return 转换后的Path
   556| 	 * @since 5.5.5
   557| 	 */
   558| 	public static Path toAbsNormal(Path path) {
   559| 		Assert.notNull(path);
   560| 		return path.toAbsolutePath().normalize();
   561| 	}
   562| 	/**
   563| 	 * 获得文件的MimeType
   564| 	 *
   565| 	 * @param file 文件
   566| 	 * @return MimeType
   567| 	 * @see Files#probeContentType(Path)
   568| 	 * @since 5.5.5
   569| 	 */
   570| 	public static String getMimeType(Path file) {
   571| 		try {
   572| 			return Files.probeContentType(file);
   573| 		} catch (IOException e) {
   574| 			throw new IORuntimeException(e);
   575| 		}
   576| 	}
   577| 	/**
   578| 	 * 创建所给目录及其父目录
   579| 	 *
   580| 	 * @param dir 目录
   581| 	 * @return 目录
   582| 	 * @since 5.5.7
   583| 	 */
   584| 	public static Path mkdir(Path dir) {
   585| 		if (null != dir && false == exists(dir, false)) {
   586| 			try {
   587| 				Files.createDirectories(dir);
   588| 			} catch (IOException e) {
   589| 				throw new IORuntimeException(e);
   590| 			}
   591| 		}
   592| 		return dir;
   593| 	}
   594| 	/**


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/io/resource/UrlResource.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| package cn.hutool.core.io.resource;
     2| import cn.hutool.core.io.FileUtil;
     3| import cn.hutool.core.util.ObjectUtil;
     4| import cn.hutool.core.util.URLUtil;
     5| import java.io.File;
     6| import java.io.InputStream;
     7| import java.io.Serializable;
     8| import java.net.URI;
     9| import java.net.URL;
    10| /**
    11|  * URL资源访问类
    12|  * @author Looly
    13|  *
    14|  */
    15| public class UrlResource implements Resource, Serializable{
    16| 	private static final long serialVersionUID = 1L;
    17| 	protected URL url;
    18| 	private long lastModified = 0;
    19| 	protected String name;
    20| 	/**
    21| 	 * 构造
    22| 	 * @param uri URI
    23| 	 * @since 5.7.21
    24| 	 */
    25| 	public UrlResource(URI uri) {
    26| 		this(URLUtil.url(uri), null);
    27| 	}
    28| 	/**
    29| 	 * 构造

# --- HUNK 2: Lines 70-90 ---
    70| 	}
    71| 	@Override
    72| 	public boolean isModified() {
    73| 		return (0 != this.lastModified) && this.lastModified != getFile().lastModified();
    74| 	}
    75| 	/**
    76| 	 * 获得File
    77| 	 * @return {@link File}
    78| 	 */
    79| 	public File getFile(){
    80| 		return FileUtil.file(this.url);
    81| 	}
    82| 	/**
    83| 	 * 返回路径
    84| 	 * @return 返回URL路径
    85| 	 */
    86| 	@Override
    87| 	public String toString() {
    88| 		return (null == this.url) ? "null" : this.url.toString();
    89| 	}
    90| }


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/map/MapUtil.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-28 ---
     1| package cn.hutool.core.map;
     2| import cn.hutool.core.collection.CollUtil;
     3| import cn.hutool.core.convert.Convert;
     4| import cn.hutool.core.exceptions.UtilException;
     5| import cn.hutool.core.lang.Editor;
     6| import cn.hutool.core.lang.Filter;
     7| import cn.hutool.core.lang.Pair;
     8| import cn.hutool.core.lang.TypeReference;
     9| import cn.hutool.core.stream.CollectorUtil;
    10| import cn.hutool.core.util.ArrayUtil;
    11| import cn.hutool.core.util.JdkUtil;
    12| import cn.hutool.core.util.ReflectUtil;
    13| import cn.hutool.core.util.StrUtil;
    14| import java.util.AbstractMap;
    15| import java.util.ArrayList;
    16| import java.util.Collections;
    17| import java.util.Comparator;
    18| import java.util.Date;
    19| import java.util.HashMap;
    20| import java.util.IdentityHashMap;
    21| import java.util.Iterator;
    22| import java.util.LinkedHashMap;
    23| import java.util.List;
    24| import java.util.Map;
    25| import java.util.Map.Entry;
    26| import java.util.NavigableMap;
    27| import java.util.Set;
    28| import java.util.SortedMap;

# --- HUNK 2: Lines 619-658 ---
   619| 	 * </pre>
   620| 	 *
   621| 	 * @param <K>    Key类型
   622| 	 * @param <V>    Value类型
   623| 	 * @param map    Map
   624| 	 * @param editor 编辑器接口
   625| 	 * @return 编辑后的Map
   626| 	 */
   627| 	@SuppressWarnings("unchecked")
   628| 	public static <K, V> Map<K, V> edit(Map<K, V> map, Editor<Entry<K, V>> editor) {
   629| 		if (null == map || null == editor) {
   630| 			return map;
   631| 		}
   632| 		Map<K, V> map2 = ReflectUtil.newInstanceIfPossible(map.getClass());
   633| 		if (null == map2) {
   634| 			map2 = new HashMap<>(map.size(), 1f);
   635| 		}
   636| 		if (isEmpty(map)) {
   637| 			return map2;
   638| 		}
   639| 		Entry<K, V> modified;
   640| 		for (Entry<K, V> entry : map.entrySet()) {
   641| 			modified = editor.edit(entry);
   642| 			if (null != modified) {
   643| 				map2.put(modified.getKey(), modified.getValue());
   644| 			}
   645| 		}
   646| 		return map2;
   647| 	}
   648| 	/**
   649| 	 * 过滤<br>
   650| 	 * 过滤过程通过传入的Editor实现来返回需要的元素内容，这个Filter实现可以实现以下功能：
   651| 	 *
   652| 	 * <pre>
   653| 	 * 1、过滤出需要的对象，如果返回null表示这个元素对象抛弃
   654| 	 * </pre>
   655| 	 *
   656| 	 * @param <K>    Key类型
   657| 	 * @param <V>    Value类型
   658| 	 * @param map    Map

# --- HUNK 3: Lines 688-727 ---
   688| 	 * 过滤Map保留指定键值对，如果键不存在跳过
   689| 	 *
   690| 	 * @param <K>  Key类型
   691| 	 * @param <V>  Value类型
   692| 	 * @param map  原始Map
   693| 	 * @param keys 键列表，{@code null}返回原Map
   694| 	 * @return Map 结果，结果的Map类型与原Map保持一致
   695| 	 * @since 4.0.10
   696| 	 */
   697| 	@SuppressWarnings("unchecked")
   698| 	public static <K, V> Map<K, V> filter(Map<K, V> map, K... keys) {
   699| 		if (null == map || null == keys) {
   700| 			return map;
   701| 		}
   702| 		Map<K, V> map2 = ReflectUtil.newInstanceIfPossible(map.getClass());
   703| 		if (null == map2) {
   704| 			map2 = new HashMap<>(map.size(), 1f);
   705| 		}
   706| 		if (isEmpty(map)) {
   707| 			return map2;
   708| 		}
   709| 		for (K key : keys) {
   710| 			if (map.containsKey(key)) {
   711| 				map2.put(key, map.get(key));
   712| 			}
   713| 		}
   714| 		return map2;
   715| 	}
   716| 	/**
   717| 	 * Map的键和值互换
   718| 	 * 互换键值对不检查值是否有重复，如果有则后加入的元素替换先加入的元素<br>
   719| 	 * 值的顺序在HashMap中不确定，所以谁覆盖谁也不确定，在有序的Map中按照先后顺序覆盖，保留最后的值
   720| 	 *
   721| 	 * @param <T> 键和值类型
   722| 	 * @param map Map对象，键值类型必须一致
   723| 	 * @return 互换后的Map
   724| 	 * @see #inverse(Map)
   725| 	 * @since 3.2.2
   726| 	 */
   727| 	public static <T> Map<T, T> reverse(Map<T, T> map) {


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/math/Calculator.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-22 ---
     1| package cn.hutool.core.math;
     2| import cn.hutool.core.lang.Console;
     3| import cn.hutool.core.util.NumberUtil;
     4| import cn.hutool.core.util.StrUtil;
     5| import java.math.BigDecimal;
     6| import java.util.Collections;
     7| import java.util.Stack;
     8| /**
     9|  * 数学表达式计算工具类<br>
    10|  * 见：https://github.com/dromara/hutool/issues/1090#issuecomment-693750140
    11|  *
    12|  * @author trainliang, looly
    13|  * @since 5.4.3
    14|  */
    15| public class Calculator {
    16| 	private final Stack<String> postfixStack = new Stack<>();// 后缀式栈
    17| 	private final int[] operatPriority = new int[]{0, 3, 2, 1, -1, 1, 0, 2};// 运用运算符ASCII码-40做索引的运算符优先级
    18| 	/**
    19| 	 * 计算表达式的值
    20| 	 *
    21| 	 * @param expression 表达式
    22| 	 * @return 计算结果


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/net/Ipv4Util.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-27 ---
     1| package cn.hutool.core.net;
     2| import cn.hutool.core.collection.ListUtil;
     3| import cn.hutool.core.convert.Convert;
     4| import cn.hutool.core.lang.Assert;
     5| import cn.hutool.core.lang.PatternPool;
     6| import cn.hutool.core.lang.Validator;
     7| import cn.hutool.core.util.CharUtil;
     8| import cn.hutool.core.util.StrUtil;
     9| import java.util.ArrayList;
    10| import java.util.List;
    11| import java.util.Objects;
    12| import java.util.regex.Matcher;
    13| /**
    14|  * IPV4地址工具类
    15|  *
    16|  * <p>pr自：https://gitee.com/loolly/hutool/pulls/161</p>
    17|  *
    18|  * @author ZhuKun
    19|  * @since 5.4.1
    20|  */
    21| public class Ipv4Util {
    22| 	public static final String LOCAL_IP = "127.0.0.1";
    23| 	/**
    24| 	 * IP段的分割符
    25| 	 */
    26| 	public static final String IP_SPLIT_MARK = "-";
    27| 	/**

# --- HUNK 2: Lines 300-339 ---
   300| 	 * </pre>
   301| 	 * 当然，还有127这个网段是环回地址
   302| 	 *
   303| 	 * @param ipAddress IP地址
   304| 	 * @return 是否为内网IP
   305| 	 * @since 5.7.18
   306| 	 */
   307| 	public static boolean isInnerIP(String ipAddress) {
   308| 		boolean isInnerIp;
   309| 		long ipNum = ipv4ToLong(ipAddress);
   310| 		long aBegin = ipv4ToLong("10.0.0.0");
   311| 		long aEnd = ipv4ToLong("10.255.255.255");
   312| 		long bBegin = ipv4ToLong("172.16.0.0");
   313| 		long bEnd = ipv4ToLong("172.31.255.255");
   314| 		long cBegin = ipv4ToLong("192.168.0.0");
   315| 		long cEnd = ipv4ToLong("192.168.255.255");
   316| 		isInnerIp = isInner(ipNum, aBegin, aEnd) || isInner(ipNum, bBegin, bEnd) || isInner(ipNum, cBegin, cEnd) || LOCAL_IP.equals(ipAddress);
   317| 		return isInnerIp;
   318| 	}
   319| 	/**
   320| 	 * 根据 ip/掩码位 计算IP段的终止IP（Long型）
   321| 	 * 注：此接口返回负数，请使用转成字符串后再转Long型
   322| 	 *
   323| 	 * @param ip      给定的IP，如218.240.38.69
   324| 	 * @param maskBit 给定的掩码位，如30
   325| 	 * @return 终止IP的长整型表示
   326| 	 */
   327| 	public static Long getEndIpLong(String ip, int maskBit) {
   328| 		return getBeginIpLong(ip, maskBit)
   329| 				+ ~ipv4ToLong(getMaskByMaskBit(maskBit));
   330| 	}
   331| 	/**
   332| 	 * 将匹配到的Ipv4地址的4个分组分别处理
   333| 	 *
   334| 	 * @param matcher 匹配到的Ipv4正则
   335| 	 * @return ipv4对应long
   336| 	 */
   337| 	private static long matchAddress(Matcher matcher) {
   338| 		long addr = 0;
   339| 		for (int i = 1; i <= 4; ++i) {


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/util/DesensitizedUtil.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 271-336 ---
   271| 	 * eg1：""         -》 ""
   272| 	 * eg3：苏D40000   -》 苏D4***0
   273| 	 * eg4：陕A12345D  -》 陕A1****D
   274| 	 * eg5：京A123     -》 京A123     如果是错误的车牌，不处理
   275| 	 *
   276| 	 * @param carLicense 完整的车牌号
   277| 	 * @return 脱敏后的车牌
   278| 	 */
   279| 	public static String carLicense(String carLicense) {
   280| 		if (StrUtil.isBlank(carLicense)) {
   281| 			return StrUtil.EMPTY;
   282| 		}
   283| 		if (carLicense.length() == 7) {
   284| 			carLicense = StrUtil.hide(carLicense, 3, 6);
   285| 		} else if (carLicense.length() == 8) {
   286| 			carLicense = StrUtil.hide(carLicense, 3, 7);
   287| 		}
   288| 		return carLicense;
   289| 	}
   290| 	/**
   291| 	 * 银行卡号脱敏
   292| 	 * eg: 1101 **** **** **** 3256
   293| 	 *
   294| 	 * @param bankCardNo 银行卡号
   295| 	 * @return 脱敏之后的银行卡号
   296| 	 * @since 5.6.3
   297| 	 */
   298| 	public static String bankCard(String bankCardNo) {
   299| 		if (StrUtil.isBlank(bankCardNo)) {
   300| 			return bankCardNo;
   301| 		}
   302| 		bankCardNo = StrUtil.trim(bankCardNo);
   303| 		if (bankCardNo.length() < 9) {
   304| 			return bankCardNo;
   305| 		}
   306| 		final int length = bankCardNo.length();
   307| 		final int midLength = length - 8;
   308| 		final StringBuilder buf = new StringBuilder();
   309| 		buf.append(bankCardNo, 0, 4);
   310| 		for (int i = 0; i < midLength; ++i) {
   311| 			if (i % 4 == 0) {
   312| 				buf.append(CharUtil.SPACE);
   313| 			}
   314| 			buf.append('*');
   315| 		}
   316| 		buf.append(CharUtil.SPACE).append(bankCardNo, length - 4, length);
   317| 		return buf.toString();
   318| 	}
   319| 	/**
   320| 	 * IPv4脱敏，如：脱敏前：192.0.2.1；脱敏后：192.*.*.*。
   321| 	 *
   322| 	 * @param ipv4 IPv4地址
   323| 	 * @return 脱敏后的地址
   324| 	 */
   325| 	public static String ipv4(String ipv4) {
   326| 		return StrUtil.subBefore(ipv4, '.', false) + ".*.*.*";
   327| 	}
   328| 	/**
   329| 	 * IPv4脱敏，如：脱敏前：2001:0db8:86a3:08d3:1319:8a2e:0370:7344；脱敏后：2001:*:*:*:*:*:*:*
   330| 	 *
   331| 	 * @param ipv6 IPv4地址
   332| 	 * @return 脱敏后的地址
   333| 	 */
   334| 	public static String ipv6(String ipv6) {
   335| 		return StrUtil.subBefore(ipv6, ':', false) + ":*:*:*:*:*:*:*";
   336| 	}


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/util/IdcardUtil.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 236-299 ---
   236| 	 * <li>第15、16位数字表示：所在地的派出所的代码</li>
   237| 	 * <li>第17位数字表示性别：奇数表示男性，偶数表示女性</li>
   238| 	 * <li>第18位数字是校检码，用来检验身份证的正确性。校检码可以是0~9的数字，有时也用x表示</li>
   239| 	 * </ol>
   240| 	 * <p>
   241| 	 * 第十八位数字(校验码)的计算方法为：
   242| 	 * <ol>
   243| 	 * <li>将前面的身份证号码17位数分别乘以不同的系数。从第一位到第十七位的系数分别为：7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2</li>
   244| 	 * <li>将这17位数字和系数相乘的结果相加</li>
   245| 	 * <li>用加出来和除以11，看余数是多少</li>
   246| 	 * <li>余数只可能有0 1 2 3 4 5 6 7 8 9 10这11个数字。其分别对应的最后一位身份证的号码为1 0 X 9 8 7 6 5 4 3 2</li>
   247| 	 * <li>通过上面得知如果余数是2，就会在身份证的第18位数字上出现罗马数字的Ⅹ。如果余数是10，身份证的最后一位号码就是2</li>
   248| 	 * </ol>
   249| 	 *
   250| 	 * @param idcard     待验证的身份证
   251| 	 * @param ignoreCase 是否忽略大小写。{@code true}则忽略X大小写，否则严格匹配大写。
   252| 	 * @return 是否有效的18位身份证
   253| 	 * @since 5.5.7
   254| 	 */
   255| 	public static boolean isValidCard18(String idcard, boolean ignoreCase) {
   256| 		if (CHINA_ID_MAX_LENGTH != idcard.length()) {
   257| 			return false;
   258| 		}
   259| 		final String proCode = idcard.substring(0, 2);
   260| 		if (null == CITY_CODES.get(proCode)) {
   261| 			return false;
   262| 		}
   263| 		if (false == Validator.isBirthday(idcard.substring(6, 14))) {
   264| 			return false;
   265| 		}
   266| 		final String code17 = idcard.substring(0, 17);
   267| 		if (ReUtil.isMatch(PatternPool.NUMBERS, code17)) {
   268| 			char val = getCheckCode18(code17);
   269| 			return CharUtil.equals(val, idcard.charAt(17), ignoreCase);
   270| 		}
   271| 		return false;
   272| 	}
   273| 	/**
   274| 	 * 验证15位身份编码是否合法
   275| 	 *
   276| 	 * @param idcard 身份编码
   277| 	 * @return 是否合法
   278| 	 */
   279| 	public static boolean isValidCard15(String idcard) {
   280| 		if (CHINA_ID_MIN_LENGTH != idcard.length()) {
   281| 			return false;
   282| 		}
   283| 		if (ReUtil.isMatch(PatternPool.NUMBERS, idcard)) {
   284| 			String proCode = idcard.substring(0, 2);
   285| 			if (null == CITY_CODES.get(proCode)) {
   286| 				return false;
   287| 			}
   288| 			return false != Validator.isBirthday("19" + idcard.substring(6, 12));
   289| 		} else {
   290| 			return false;
   291| 		}
   292| 	}
   293| 	/**
   294| 	 * 验证10位身份编码是否合法
   295| 	 *
   296| 	 * @param idcard 身份编码
   297| 	 * @return 身份证信息数组
   298| 	 * <p>
   299| 	 * [0] - 台湾、澳门、香港 [1] - 性别(男M,女F,未知N) [2] - 是否合法(合法true,不合法false) 若不是身份证件号码则返回null


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/util/RandomUtil.java
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 1-607 ---
     1| package cn.hutool.core.util;
     2| import cn.hutool.core.collection.CollUtil;
     3| import cn.hutool.core.collection.ListUtil;
     4| import cn.hutool.core.date.DateField;
     5| import cn.hutool.core.date.DateTime;
     6| import cn.hutool.core.date.DateUtil;
     7| import cn.hutool.core.exceptions.UtilException;
     8| import cn.hutool.core.lang.WeightRandom;
     9| import cn.hutool.core.lang.WeightRandom.WeightObj;
    10| import java.awt.Color;
    11| import java.math.BigDecimal;
    12| import java.math.RoundingMode;
    13| import java.security.NoSuchAlgorithmException;
    14| import java.security.SecureRandom;
    15| import java.util.ArrayList;
    16| import java.util.Collection;
    17| import java.util.Date;
    18| import java.util.LinkedHashSet;
    19| import java.util.List;
    20| import java.util.Random;
    21| import java.util.Set;
    22| import java.util.concurrent.ThreadLocalRandom;
    23| /**
    24|  * 随机工具类
    25|  *
    26|  * @author xiaoleilu
    27|  */
    28| public class RandomUtil {
    29| 	/**
    30| 	 * 用于随机选的数字
    31| 	 */
    32| 	public static final String BASE_NUMBER = "0123456789";
    33| 	/**
    34| 	 * 用于随机选的字符
    35| 	 */
    36| 	public static final String BASE_CHAR = "abcdefghijklmnopqrstuvwxyz";
    37| 	/**
    38| 	 * 用于随机选的字符和数字
    39| 	 */
    40| 	public static final String BASE_CHAR_NUMBER = BASE_CHAR + BASE_NUMBER;
    41| 	/**
    42| 	 * 获取随机数生成器对象<br>
    43| 	 * ThreadLocalRandom是JDK 7之后提供并发产生随机数，能够解决多个线程发生的竞争争夺。
    44| 	 *
    45| 	 * <p>
    46| 	 * 注意：此方法返回的{@link ThreadLocalRandom}不可以在多线程环境下共享对象，否则有重复随机数问题。
    47| 	 * 见：https://www.jianshu.com/p/89dfe990295c
    48| 	 * </p>
    49| 	 *
    50| 	 * @return {@link ThreadLocalRandom}
    51| 	 * @since 3.1.2
    52| 	 */
    53| 	public static ThreadLocalRandom getRandom() {
    54| 		return ThreadLocalRandom.current();
    55| 	}
    56| 	/**
    57| 	 * 创建{@link SecureRandom}，类提供加密的强随机数生成器 (RNG)<br>
    58| 	 *
    59| 	 * @param seed 自定义随机种子
    60| 	 * @return {@link SecureRandom}
    61| 	 * @since 4.6.5
    62| 	 */
    63| 	public static SecureRandom createSecureRandom(byte[] seed) {
    64| 		return (null == seed) ? new SecureRandom() : new SecureRandom(seed);
    65| 	}
    66| 	/**
    67| 	 * 获取SHA1PRNG的{@link SecureRandom}，类提供加密的强随机数生成器 (RNG)<br>
    68| 	 * 注意：此方法获取的是伪随机序列发生器PRNG（pseudo-random number generator）
    69| 	 *
    70| 	 * <p>
    71| 	 * 相关说明见：https://stackoverflow.com/questions/137212/how-to-solve-slow-java-securerandom
    72| 	 *
    73| 	 * @return {@link SecureRandom}
    74| 	 * @since 3.1.2
    75| 	 */
    76| 	public static SecureRandom getSecureRandom() {
    77| 		return getSecureRandom(null);
    78| 	}
    79| 	/**
    80| 	 * 获取SHA1PRNG的{@link SecureRandom}，类提供加密的强随机数生成器 (RNG)<br>
    81| 	 * 注意：此方法获取的是伪随机序列发生器PRNG（pseudo-random number generator）
    82| 	 *
    83| 	 * <p>
    84| 	 * 相关说明见：https://stackoverflow.com/questions/137212/how-to-solve-slow-java-securerandom
    85| 	 *
    86| 	 * @param seed 随机数种子
    87| 	 * @return {@link SecureRandom}
    88| 	 * @see #createSecureRandom(byte[])
    89| 	 * @since 5.5.2
    90| 	 */
    91| 	public static SecureRandom getSecureRandom(byte[] seed) {
    92| 		return createSecureRandom(seed);
    93| 	}
    94| 	/**
    95| 	 * 获取SHA1PRNG的{@link SecureRandom}，类提供加密的强随机数生成器 (RNG)<br>
    96| 	 * 注意：此方法获取的是伪随机序列发生器PRNG（pseudo-random number generator）,在Linux下噪声生成时可能造成较长时间停顿。<br>
    97| 	 * see: http://ifeve.com/jvm-random-and-entropy-source/
    98| 	 *
    99| 	 * <p>
   100| 	 * 相关说明见：https://stackoverflow.com/questions/137212/how-to-solve-slow-java-securerandom
   101| 	 *
   102| 	 * @param seed 随机数种子
   103| 	 * @return {@link SecureRandom}
   104| 	 * @since 5.5.8
   105| 	 */
   106| 	public static SecureRandom getSHA1PRNGRandom(byte[] seed) {
   107| 		SecureRandom random;
   108| 		try {
   109| 			random = SecureRandom.getInstance("SHA1PRNG");
   110| 		} catch (NoSuchAlgorithmException e) {
   111| 			throw new UtilException(e);
   112| 		}
   113| 		if (null != seed) {
   114| 			random.setSeed(seed);
   115| 		}
   116| 		return random;
   117| 	}
   118| 	/**
   119| 	 * 获取algorithms/providers中提供的强安全随机生成器<br>
   120| 	 * 注意：此方法可能造成阻塞或性能问题
   121| 	 *
   122| 	 * @return {@link SecureRandom}
   123| 	 * @since 5.7.12
   124| 	 */
   125| 	public static SecureRandom getSecureRandomStrong() {
   126| 		try {
   127| 			return SecureRandom.getInstanceStrong();
   128| 		} catch (NoSuchAlgorithmException e) {
   129| 			throw new UtilException(e);
   130| 		}
   131| 	}
   132| 	/**
   133| 	 * 获取随机数产生器
   134| 	 *
   135| 	 * @param isSecure 是否为强随机数生成器 (RNG)
   136| 	 * @return {@link Random}
   137| 	 * @see #getSecureRandom()
   138| 	 * @see #getRandom()
   139| 	 * @since 4.1.15
   140| 	 */
   141| 	public static Random getRandom(boolean isSecure) {
   142| 		return isSecure ? getSecureRandom() : getRandom();
   143| 	}
   144| 	/**
   145| 	 * 获得随机Boolean值
   146| 	 *
   147| 	 * @return true or false
   148| 	 * @since 4.5.9
   149| 	 */
   150| 	public static boolean randomBoolean() {
   151| 		return 0 == randomInt(2);
   152| 	}
   153| 	/**
   154| 	 * 随机汉字（'\u4E00'-'\u9FFF'）
   155| 	 *
   156| 	 * @return 随机的汉字字符
   157| 	 * @since 5.7.15
   158| 	 */
   159| 	public static char randomChinese() {
   160| 		return (char) randomInt('\u4E00', '\u9FFF');
   161| 	}
   162| 	/**
   163| 	 * 获得指定范围内的随机数
   164| 	 *
   165| 	 * @param min 最小数（包含）
   166| 	 * @param max 最大数（不包含）
   167| 	 * @return 随机数
   168| 	 */
   169| 	public static int randomInt(int min, int max) {
   170| 		return getRandom().nextInt(min, max);
   171| 	}
   172| 	/**
   173| 	 * 获得随机数int值
   174| 	 *
   175| 	 * @return 随机数
   176| 	 * @see Random#nextInt()
   177| 	 */
   178| 	public static int randomInt() {
   179| 		return getRandom().nextInt();
   180| 	}
   181| 	/**
   182| 	 * 获得指定范围内的随机数 [0,limit)
   183| 	 *
   184| 	 * @param limit 限制随机数的范围，不包括这个数
   185| 	 * @return 随机数
   186| 	 * @see Random#nextInt(int)
   187| 	 */
   188| 	public static int randomInt(int limit) {
   189| 		return getRandom().nextInt(limit);
   190| 	}
   191| 	/**
   192| 	 * 获得指定范围内的随机数[min, max)
   193| 	 *
   194| 	 * @param min 最小数（包含）
   195| 	 * @param max 最大数（不包含）
   196| 	 * @return 随机数
   197| 	 * @see ThreadLocalRandom#nextLong(long, long)
   198| 	 * @since 3.3.0
   199| 	 */
   200| 	public static long randomLong(long min, long max) {
   201| 		return getRandom().nextLong(min, max);
   202| 	}
   203| 	/**
   204| 	 * 获得随机数
   205| 	 *
   206| 	 * @return 随机数
   207| 	 * @see ThreadLocalRandom#nextLong()
   208| 	 * @since 3.3.0
   209| 	 */
   210| 	public static long randomLong() {
   211| 		return getRandom().nextLong();
   212| 	}
   213| 	/**
   214| 	 * 获得指定范围内的随机数 [0,limit)
   215| 	 *
   216| 	 * @param limit 限制随机数的范围，不包括这个数
   217| 	 * @return 随机数
   218| 	 * @see ThreadLocalRandom#nextLong(long)
   219| 	 */
   220| 	public static long randomLong(long limit) {
   221| 		return getRandom().nextLong(limit);
   222| 	}
   223| 	/**
   224| 	 * 获得指定范围内的随机数
   225| 	 *
   226| 	 * @param min 最小数（包含）
   227| 	 * @param max 最大数（不包含）
   228| 	 * @return 随机数
   229| 	 * @see ThreadLocalRandom#nextDouble(double, double)
   230| 	 * @since 3.3.0
   231| 	 */
   232| 	public static double randomDouble(double min, double max) {
   233| 		return getRandom().nextDouble(min, max);
   234| 	}
   235| 	/**
   236| 	 * 获得指定范围内的随机数
   237| 	 *
   238| 	 * @param min          最小数（包含）
   239| 	 * @param max          最大数（不包含）
   240| 	 * @param scale        保留小数位数
   241| 	 * @param roundingMode 保留小数的模式 {@link RoundingMode}
   242| 	 * @return 随机数
   243| 	 * @since 4.0.8
   244| 	 */
   245| 	public static double randomDouble(double min, double max, int scale, RoundingMode roundingMode) {
   246| 		return NumberUtil.round(randomDouble(min, max), scale, roundingMode).doubleValue();
   247| 	}
   248| 	/**
   249| 	 * 获得随机数[0, 1)
   250| 	 *
   251| 	 * @return 随机数
   252| 	 * @see ThreadLocalRandom#nextDouble()
   253| 	 * @since 3.3.0
   254| 	 */
   255| 	public static double randomDouble() {
   256| 		return getRandom().nextDouble();
   257| 	}
   258| 	/**
   259| 	 * 获得指定范围内的随机数
   260| 	 *
   261| 	 * @param scale        保留小数位数
   262| 	 * @param roundingMode 保留小数的模式 {@link RoundingMode}
   263| 	 * @return 随机数
   264| 	 * @since 4.0.8
   265| 	 */
   266| 	public static double randomDouble(int scale, RoundingMode roundingMode) {
   267| 		return NumberUtil.round(randomDouble(), scale, roundingMode).doubleValue();
   268| 	}
   269| 	/**
   270| 	 * 获得指定范围内的随机数 [0,limit)
   271| 	 *
   272| 	 * @param limit 限制随机数的范围，不包括这个数
   273| 	 * @return 随机数
   274| 	 * @see ThreadLocalRandom#nextDouble(double)
   275| 	 * @since 3.3.0
   276| 	 */
   277| 	public static double randomDouble(double limit) {
   278| 		return getRandom().nextDouble(limit);
   279| 	}
   280| 	/**
   281| 	 * 获得指定范围内的随机数
   282| 	 *
   283| 	 * @param limit        限制随机数的范围，不包括这个数
   284| 	 * @param scale        保留小数位数
   285| 	 * @param roundingMode 保留小数的模式 {@link RoundingMode}
   286| 	 * @return 随机数
   287| 	 * @since 4.0.8
   288| 	 */
   289| 	public static double randomDouble(double limit, int scale, RoundingMode roundingMode) {
   290| 		return NumberUtil.round(randomDouble(limit), scale, roundingMode).doubleValue();
   291| 	}
   292| 	/**
   293| 	 * 获得指定范围内的随机数[0, 1)
   294| 	 *
   295| 	 * @return 随机数
   296| 	 * @since 4.0.9
   297| 	 */
   298| 	public static BigDecimal randomBigDecimal() {
   299| 		return NumberUtil.toBigDecimal(getRandom().nextDouble());
   300| 	}
   301| 	/**
   302| 	 * 获得指定范围内的随机数 [0,limit)
   303| 	 *
   304| 	 * @param limit 最大数（不包含）
   305| 	 * @return 随机数
   306| 	 * @since 4.0.9
   307| 	 */
   308| 	public static BigDecimal randomBigDecimal(BigDecimal limit) {
   309| 		return NumberUtil.toBigDecimal(getRandom().nextDouble(limit.doubleValue()));
   310| 	}
   311| 	/**
   312| 	 * 获得指定范围内的随机数
   313| 	 *
   314| 	 * @param min 最小数（包含）
   315| 	 * @param max 最大数（不包含）
   316| 	 * @return 随机数
   317| 	 * @since 4.0.9
   318| 	 */
   319| 	public static BigDecimal randomBigDecimal(BigDecimal min, BigDecimal max) {
   320| 		return NumberUtil.toBigDecimal(getRandom().nextDouble(min.doubleValue(), max.doubleValue()));
   321| 	}
   322| 	/**
   323| 	 * 随机bytes
   324| 	 *
   325| 	 * @param length 长度
   326| 	 * @return bytes
   327| 	 */
   328| 	public static byte[] randomBytes(int length) {
   329| 		byte[] bytes = new byte[length];
   330| 		getRandom().nextBytes(bytes);
   331| 		return bytes;
   332| 	}
   333| 	/**
   334| 	 * 随机获得列表中的元素
   335| 	 *
   336| 	 * @param <T>  元素类型
   337| 	 * @param list 列表
   338| 	 * @return 随机元素
   339| 	 */
   340| 	public static <T> T randomEle(List<T> list) {
   341| 		return randomEle(list, list.size());
   342| 	}
   343| 	/**
   344| 	 * 随机获得列表中的元素
   345| 	 *
   346| 	 * @param <T>   元素类型
   347| 	 * @param list  列表
   348| 	 * @param limit 限制列表的前N项
   349| 	 * @return 随机元素
   350| 	 */
   351| 	public static <T> T randomEle(List<T> list, int limit) {
   352| 		if (list.size() < limit) {
   353| 			limit = list.size();
   354| 		}
   355| 		return list.get(randomInt(limit));
   356| 	}
   357| 	/**
   358| 	 * 随机获得数组中的元素
   359| 	 *
   360| 	 * @param <T>   元素类型
   361| 	 * @param array 列表
   362| 	 * @return 随机元素
   363| 	 * @since 3.3.0
   364| 	 */
   365| 	public static <T> T randomEle(T[] array) {
   366| 		return randomEle(array, array.length);
   367| 	}
   368| 	/**
   369| 	 * 随机获得数组中的元素
   370| 	 *
   371| 	 * @param <T>   元素类型
   372| 	 * @param array 列表
   373| 	 * @param limit 限制列表的前N项
   374| 	 * @return 随机元素
   375| 	 * @since 3.3.0
   376| 	 */
   377| 	public static <T> T randomEle(T[] array, int limit) {
   378| 		if (array.length < limit) {
   379| 			limit = array.length;
   380| 		}
   381| 		return array[randomInt(limit)];
   382| 	}
   383| 	/**
   384| 	 * 随机获得列表中的一定量元素
   385| 	 *
   386| 	 * @param <T>   元素类型
   387| 	 * @param list  列表
   388| 	 * @param count 随机取出的个数
   389| 	 * @return 随机元素
   390| 	 */
   391| 	public static <T> List<T> randomEles(List<T> list, int count) {
   392| 		final List<T> result = new ArrayList<>(count);
   393| 		int limit = list.size();
   394| 		while (result.size() < count) {
   395| 			result.add(randomEle(list, limit));
   396| 		}
   397| 		return result;
   398| 	}
   399| 	/**
   400| 	 * 随机获得列表中的一定量的元素，返回List<br>
   401| 	 * 此方法与{@link #randomEles(List, int)} 不同点在于，不会获取重复位置的元素
   402| 	 *
   403| 	 * @param source 列表
   404| 	 * @param count  随机取出的个数
   405| 	 * @param <T>    元素类型
   406| 	 * @return 随机列表
   407| 	 * @since 5.2.1
   408| 	 */
   409| 	public static <T> List<T> randomEleList(List<T> source, int count) {
   410| 		if (count >= source.size()) {
   411| 			return ListUtil.toList(source);
   412| 		}
   413| 		final int[] randomList = ArrayUtil.sub(randomInts(source.size()), 0, count);
   414| 		List<T> result = new ArrayList<>();
   415| 		for (int e : randomList) {
   416| 			result.add(source.get(e));
   417| 		}
   418| 		return result;
   419| 	}
   420| 	/**
   421| 	 * 随机获得列表中的一定量的不重复元素，返回Set
   422| 	 *
   423| 	 * @param <T>        元素类型
   424| 	 * @param collection 列表
   425| 	 * @param count      随机取出的个数
   426| 	 * @return 随机元素
   427| 	 * @throws IllegalArgumentException 需要的长度大于给定集合非重复总数
   428| 	 */
   429| 	public static <T> Set<T> randomEleSet(Collection<T> collection, int count) {
   430| 		final ArrayList<T> source = CollUtil.distinct(collection);
   431| 		if (count > source.size()) {
   432| 			throw new IllegalArgumentException("Count is larger than collection distinct size !");
   433| 		}
   434| 		final Set<T> result = new LinkedHashSet<>(count);
   435| 		int limit = source.size();
   436| 		while (result.size() < count) {
   437| 			result.add(randomEle(source, limit));
   438| 		}
   439| 		return result;
   440| 	}
   441| 	/**
   442| 	 * 创建指定长度的随机索引
   443| 	 *
   444| 	 * @param length 长度
   445| 	 * @return 随机索引
   446| 	 * @since 5.2.1
   447| 	 */
   448| 	public static int[] randomInts(int length) {
   449| 		final int[] range = ArrayUtil.range(length);
   450| 		for (int i = 0; i < length; i++) {
   451| 			int random = randomInt(i, length);
   452| 			ArrayUtil.swap(range, i, random);
   453| 		}
   454| 		return range;
   455| 	}
   456| 	/**
   457| 	 * 获得一个随机的字符串（只包含数字和字符）
   458| 	 *
   459| 	 * @param length 字符串的长度
   460| 	 * @return 随机字符串
   461| 	 */
   462| 	public static String randomString(int length) {
   463| 		return randomString(BASE_CHAR_NUMBER, length);
   464| 	}
   465| 	/**
   466| 	 * 获得一个随机的字符串（只包含数字和大写字符）
   467| 	 *
   468| 	 * @param length 字符串的长度
   469| 	 * @return 随机字符串
   470| 	 * @since 4.0.13
   471| 	 */
   472| 	public static String randomStringUpper(int length) {
   473| 		return randomString(BASE_CHAR_NUMBER, length).toUpperCase();
   474| 	}
   475| 	/**
   476| 	 * 获得一个随机的字符串（只包含数字和小写字母） 并排除指定字符串
   477| 	 *
   478| 	 * @param length   字符串的长度
   479| 	 * @param elemData 要排除的字符串,如：去重容易混淆的字符串，oO0、lL1、q9Q、pP，不区分大小写
   480| 	 * @return 随机字符串
   481| 	 */
   482| 	public static String randomStringWithoutStr(int length, String elemData) {
   483| 		String baseStr = BASE_CHAR_NUMBER;
   484| 		baseStr = StrUtil.removeAll(baseStr, elemData.toLowerCase().toCharArray());
   485| 		return randomString(baseStr, length);
   486| 	}
   487| 	/**
   488| 	 * 获得一个只包含数字的字符串
   489| 	 *
   490| 	 * @param length 字符串的长度
   491| 	 * @return 随机字符串
   492| 	 */
   493| 	public static String randomNumbers(int length) {
   494| 		return randomString(BASE_NUMBER, length);
   495| 	}
   496| 	/**
   497| 	 * 获得一个随机的字符串
   498| 	 *
   499| 	 * @param baseString 随机字符选取的样本
   500| 	 * @param length     字符串的长度
   501| 	 * @return 随机字符串
   502| 	 */
   503| 	public static String randomString(String baseString, int length) {
   504| 		if (StrUtil.isEmpty(baseString)) {
   505| 			return StrUtil.EMPTY;
   506| 		}
   507| 		if (length < 1) {
   508| 			length = 1;
   509| 		}
   510| 		final StringBuilder sb = new StringBuilder(length);
   511| 		int baseLength = baseString.length();
   512| 		for (int i = 0; i < length; i++) {
   513| 			int number = randomInt(baseLength);
   514| 			sb.append(baseString.charAt(number));
   515| 		}
   516| 		return sb.toString();
   517| 	}
   518| 	/**
   519| 	 * 随机数字，数字为0~9单个数字
   520| 	 *
   521| 	 * @return 随机数字字符
   522| 	 * @since 3.1.2
   523| 	 */
   524| 	public static char randomNumber() {
   525| 		return randomChar(BASE_NUMBER);
   526| 	}
   527| 	/**
   528| 	 * 随机字母或数字，小写
   529| 	 *
   530| 	 * @return 随机字符
   531| 	 * @since 3.1.2
   532| 	 */
   533| 	public static char randomChar() {
   534| 		return randomChar(BASE_CHAR_NUMBER);
   535| 	}
   536| 	/**
   537| 	 * 随机字符
   538| 	 *
   539| 	 * @param baseString 随机字符选取的样本
   540| 	 * @return 随机字符
   541| 	 * @since 3.1.2
   542| 	 */
   543| 	public static char randomChar(String baseString) {
   544| 		return baseString.charAt(randomInt(baseString.length()));
   545| 	}
   546| 	/**
   547| 	 * 生成随机颜色
   548| 	 *
   549| 	 * @return 随机颜色
   550| 	 * @since 4.1.5
   551| 	 * @deprecated 使用ImgUtil.randomColor()
   552| 	 */
   553| 	@Deprecated
   554| 	public static Color randomColor() {
   555| 		final Random random = getRandom();
   556| 		return new Color(random.nextInt(256), random.nextInt(256), random.nextInt(256));
   557| 	}
   558| 	/**
   559| 	 * 带有权重的随机生成器
   560| 	 *
   561| 	 * @param <T>        随机对象类型
   562| 	 * @param weightObjs 带有权重的对象列表
   563| 	 * @return {@link WeightRandom}
   564| 	 * @since 4.0.3
   565| 	 */
   566| 	public static <T> WeightRandom<T> weightRandom(WeightObj<T>[] weightObjs) {
   567| 		return new WeightRandom<>(weightObjs);
   568| 	}
   569| 	/**
   570| 	 * 带有权重的随机生成器
   571| 	 *
   572| 	 * @param <T>        随机对象类型
   573| 	 * @param weightObjs 带有权重的对象列表
   574| 	 * @return {@link WeightRandom}
   575| 	 * @since 4.0.3
   576| 	 */
   577| 	public static <T> WeightRandom<T> weightRandom(Iterable<WeightObj<T>> weightObjs) {
   578| 		return new WeightRandom<>(weightObjs);
   579| 	}
   580| 	/**
   581| 	 * 以当天为基准，随机产生一个日期
   582| 	 *
   583| 	 * @param min 偏移最小天，可以为负数表示过去的时间（包含）
   584| 	 * @param max 偏移最大天，可以为负数表示过去的时间（不包含）
   585| 	 * @return 随机日期（随机天，其它时间不变）
   586| 	 * @since 4.0.8
   587| 	 */
   588| 	public static DateTime randomDay(int min, int max) {
   589| 		return randomDate(DateUtil.date(), DateField.DAY_OF_YEAR, min, max);
   590| 	}
   591| 	/**
   592| 	 * 以给定日期为基准，随机产生一个日期
   593| 	 *
   594| 	 * @param baseDate  基准日期
   595| 	 * @param dateField 偏移的时间字段，例如时、分、秒等
   596| 	 * @param min       偏移最小量，可以为负数表示过去的时间（包含）
   597| 	 * @param max       偏移最大量，可以为负数表示过去的时间（不包含）
   598| 	 * @return 随机日期
   599| 	 * @since 4.5.8
   600| 	 */
   601| 	public static DateTime randomDate(Date baseDate, DateField dateField, int min, int max) {
   602| 		if (null == baseDate) {
   603| 			baseDate = DateUtil.date();
   604| 		}
   605| 		return DateUtil.offset(baseDate, dateField, randomInt(min, max));
   606| 	}
   607| }


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/util/StrUtil.java
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-31 ---
     1| package cn.hutool.core.util;
     2| import cn.hutool.core.text.CharSequenceUtil;
     3| import cn.hutool.core.text.StrBuilder;
     4| import cn.hutool.core.text.StrFormatter;
     5| import cn.hutool.core.text.StrPool;
     6| import cn.hutool.core.text.TextSimilarity;
     7| import java.io.StringReader;
     8| import java.io.StringWriter;
     9| import java.nio.ByteBuffer;
    10| import java.nio.charset.Charset;
    11| import java.util.Map;
    12| /**
    13|  * 字符串工具类
    14|  *
    15|  * @author xiaoleilu
    16|  */
    17| public class StrUtil extends CharSequenceUtil implements StrPool {
    18| 	/**
    19| 	 * <p>如果对象是字符串是否为空白，空白的定义如下：</p>
    20| 	 * <ol>
    21| 	 *     <li>{@code null}</li>
    22| 	 *     <li>空字符串：{@code ""}</li>
    23| 	 *     <li>空格、全角空格、制表符、换行符，等不可见字符</li>
    24| 	 * </ol>
    25| 	 *
    26| 	 * <p>例：</p>
    27| 	 * <ul>
    28| 	 *     <li>{@code StrUtil.isBlankIfStr(null)     // true}</li>
    29| 	 *     <li>{@code StrUtil.isBlankIfStr("")       // true}</li>
    30| 	 *     <li>{@code StrUtil.isBlankIfStr(" \t\n")  // true}</li>
    31| 	 *     <li>{@code StrUtil.isBlankIfStr("abc")    // false}</li>

# --- HUNK 2: Lines 221-262 ---
   221| 		return str(data, CharsetUtil.charset(charset));
   222| 	}
   223| 	/**
   224| 	 * 将编码的byteBuffer数据转换为字符串
   225| 	 *
   226| 	 * @param data    数据
   227| 	 * @param charset 字符集，如果为空使用当前系统字符集
   228| 	 * @return 字符串
   229| 	 */
   230| 	public static String str(ByteBuffer data, Charset charset) {
   231| 		if (null == charset) {
   232| 			charset = Charset.defaultCharset();
   233| 		}
   234| 		return charset.decode(data).toString();
   235| 	}
   236| 	/**
   237| 	 * 调用对象的toString方法，null会返回“null”
   238| 	 *
   239| 	 * @param obj 对象
   240| 	 * @return 字符串
   241| 	 * @since 4.1.3
   242| 	 * @see String#valueOf(Object)
   243| 	 */
   244| 	public static String toString(Object obj) {
   245| 		return String.valueOf(obj);
   246| 	}
   247| 	/**
   248| 	 * 调用对象的toString方法，null会返回{@code null}
   249| 	 *
   250| 	 * @param obj 对象
   251| 	 * @return 字符串 or {@code null}
   252| 	 * @since 5.7.17
   253| 	 */
   254| 	public static String toStringOrNull(Object obj) {
   255| 		return null == obj ? null : obj.toString();
   256| 	}
   257| 	/**
   258| 	 * 创建StringBuilder对象
   259| 	 *
   260| 	 * @return StringBuilder对象
   261| 	 */
   262| 	public static StringBuilder builder() {

# --- HUNK 3: Lines 405-425 ---
   405| 	 * @param template 文本模板，被替换的部分用 {key} 表示
   406| 	 * @param map      参数值对
   407| 	 * @return 格式化后的文本
   408| 	 */
   409| 	public static String format(CharSequence template, Map<?, ?> map) {
   410| 		return format(template, map, true);
   411| 	}
   412| 	/**
   413| 	 * 格式化文本，使用 {varName} 占位<br>
   414| 	 * map = {a: "aValue", b: "bValue"} format("{a} and {b}", map) ---=》 aValue and bValue
   415| 	 *
   416| 	 * @param template   文本模板，被替换的部分用 {key} 表示
   417| 	 * @param map        参数值对
   418| 	 * @param ignoreNull 是否忽略 {@code null} 值，忽略则 {@code null} 值对应的变量不被替换，否则替换为""
   419| 	 * @return 格式化后的文本
   420| 	 * @since 5.4.3
   421| 	 */
   422| 	public static String format(CharSequence template, Map<?, ?> map, boolean ignoreNull) {
   423| 		return StrFormatter.format(template, map, ignoreNull);
   424| 	}
   425| }


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/util/TypeUtil.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| package cn.hutool.core.util;
     2| import cn.hutool.core.lang.ParameterizedTypeImpl;
     3| import cn.hutool.core.lang.reflect.ActualTypeMapperPool;
     4| import java.lang.reflect.Field;
     5| import java.lang.reflect.Method;
     6| import java.lang.reflect.ParameterizedType;
     7| import java.lang.reflect.Type;
     8| import java.lang.reflect.TypeVariable;
     9| import java.lang.reflect.WildcardType;
    10| import java.util.Map;
    11| /**
    12|  * 针对 {@link Type} 的工具类封装<br>
    13|  * 最主要功能包括：
    14|  *
    15|  * <pre>
    16|  * 1. 获取方法的参数和返回值类型（包括Type和Class）
    17|  * 2. 获取泛型参数类型（包括对象的泛型参数或集合元素的泛型类型）
    18|  * </pre>
    19|  *
    20|  * @author Looly
    21|  * @since 3.0.8
    22|  */
    23| public class TypeUtil {
    24| 	/**
    25| 	 * 获得Type对应的原始类
    26| 	 *
    27| 	 * @param type {@link Type}
    28| 	 * @return 原始类，如果无法获取原始类，返回{@code null}
    29| 	 */

# --- HUNK 2: Lines 220-275 ---
   220| 		}
   221| 		final ParameterizedType parameterizedType = toParameterizedType(type);
   222| 		return (null == parameterizedType) ? null : parameterizedType.getActualTypeArguments();
   223| 	}
   224| 	/**
   225| 	 * 将{@link Type} 转换为{@link ParameterizedType}<br>
   226| 	 * {@link ParameterizedType}用于获取当前类或父类中泛型参数化后的类型<br>
   227| 	 * 一般用于获取泛型参数具体的参数类型，例如：
   228| 	 *
   229| 	 * <pre>
   230| 	 * class A&lt;T&gt;
   231| 	 * class B extends A&lt;String&gt;
   232| 	 * </pre>
   233| 	 * <p>
   234| 	 * 通过此方法，传入B.class即可得到B{@link ParameterizedType}，从而获取到String
   235| 	 *
   236| 	 * @param type {@link Type}
   237| 	 * @return {@link ParameterizedType}
   238| 	 * @since 4.5.2
   239| 	 */
   240| 	public static ParameterizedType toParameterizedType(Type type) {
   241| 		ParameterizedType result = null;
   242| 		if (type instanceof ParameterizedType) {
   243| 			result = (ParameterizedType) type;
   244| 		} else if (type instanceof Class) {
   245| 			final Class<?> clazz = (Class<?>) type;
   246| 			Type genericSuper = clazz.getGenericSuperclass();
   247| 			if (null == genericSuper || Object.class.equals(genericSuper)) {
   248| 				final Type[] genericInterfaces = clazz.getGenericInterfaces();
   249| 				if (ArrayUtil.isNotEmpty(genericInterfaces)) {
   250| 					genericSuper = genericInterfaces[0];
   251| 				}
   252| 			}
   253| 			result = toParameterizedType(genericSuper);
   254| 		}
   255| 		return result;
   256| 	}
   257| 	/**
   258| 	 * 是否未知类型<br>
   259| 	 * type为null或者{@link TypeVariable} 都视为未知类型
   260| 	 *
   261| 	 * @param type Type类型
   262| 	 * @return 是否未知类型
   263| 	 * @since 4.5.2
   264| 	 */
   265| 	public static boolean isUnknown(Type type) {
   266| 		return null == type || type instanceof TypeVariable;
   267| 	}
   268| 	/**
   269| 	 * 指定泛型数组中是否含有泛型变量
   270| 	 *
   271| 	 * @param types 泛型数组
   272| 	 * @return 是否含有泛型变量
   273| 	 * @since 4.5.7
   274| 	 */
   275| 	public static boolean hasTypeVariable(Type... types) {


# ====================================================================
# FILE: hutool-core/src/main/java/cn/hutool/core/util/URLUtil.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 695-715 ---
   695| 	 * @param charset  可选项（null表示无），源文本的字符集编码方式
   696| 	 * @param encoding 数据编码方式（US-ASCII，BASE64等）
   697| 	 * @param data     编码后的数据
   698| 	 * @return Data URI字符串
   699| 	 * @since 5.3.6
   700| 	 */
   701| 	public static String getDataUri(String mimeType, Charset charset, String encoding, String data) {
   702| 		final StringBuilder builder = StrUtil.builder("data:");
   703| 		if (StrUtil.isNotBlank(mimeType)) {
   704| 			builder.append(mimeType);
   705| 		}
   706| 		if (null != charset) {
   707| 			builder.append(";charset=").append(charset.name());
   708| 		}
   709| 		if (StrUtil.isNotBlank(encoding)) {
   710| 			builder.append(';').append(encoding);
   711| 		}
   712| 		builder.append(',').append(data);
   713| 		return builder.toString();
   714| 	}
   715| }


# ====================================================================
# FILE: hutool-db/src/main/java/cn/hutool/db/dialect/DriverNamePool.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 56-96 ---
    56| 	String DRIVER_DERBY = "org.apache.derby.jdbc.AutoloadedDriver";
    57| 	/**
    58| 	 * JDBC 驱动 HSQLDB
    59| 	 */
    60| 	String DRIVER_HSQLDB = "org.hsqldb.jdbc.JDBCDriver";
    61| 	/**
    62| 	 * JDBC 驱动 达梦7
    63| 	 */
    64| 	String DRIVER_DM7 = "dm.jdbc.driver.DmDriver";
    65| 	/**
    66| 	 * JDBC 驱动 人大金仓
    67| 	 */
    68| 	String DRIVER_KINGBASE8 = "com.kingbase8.Driver";
    69| 	/**
    70| 	 * JDBC 驱动 Ignite thin
    71| 	 */
    72| 	String DRIVER_IGNITE_THIN = "org.apache.ignite.IgniteJdbcThinDriver";
    73| 	/**
    74| 	 * JDBC 驱动 ClickHouse
    75| 	 */
    76| 	String DRIVER_CLICK_HOUSE = "ru.yandex.clickhouse.ClickHouseDriver";
    77| 	/**
    78| 	 * JDBC 驱动 瀚高数据库
    79| 	 */
    80| 	String DRIVER_HIGHGO = "com.highgo.jdbc.Driver";
    81| 	/**
    82| 	 * JDBC 驱动 DB2
    83| 	 */
    84| 	String DRIVER_DB2 = "com.ibm.db2.jdbc.app.DB2Driver";
    85| 	/**
    86| 	 * JDBC 驱动 虚谷数据库
    87| 	 */
    88| 	String DRIVER_XUGU = "com.xugu.cloudjdbc.Driver";
    89| 	/**
    90| 	 * JDBC 驱动 Apache Phoenix
    91| 	 */
    92| 	String DRIVER_PHOENIX = "org.apache.phoenix.jdbc.PhoenixDriver";
    93| 	/**
    94| 	 * JDBC 驱动 华为高斯
    95| 	 */
    96| 	String DRIVER_GAUSS = "com.huawei.gauss.jdbc.ZenithDriver";


# ====================================================================
# FILE: hutool-db/src/main/java/cn/hutool/db/sql/Query.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-170 ---
     1| package cn.hutool.db.sql;
     2| import cn.hutool.core.collection.CollectionUtil;
     3| import cn.hutool.core.util.ArrayUtil;
     4| import cn.hutool.db.DbRuntimeException;
     5| import cn.hutool.db.Entity;
     6| import cn.hutool.db.Page;
     7| import java.util.Collection;
     8| /**
     9|  * 查询对象，用于传递查询所需的字段值<br>
    10|  * 查询对象根据表名（可以多个），多个条件 {@link Condition} 构建查询对象完成查询。<br>
    11|  * 如果想自定义返回结果，则可在查询对象中自定义要查询的字段名，分页{@link Page}信息来自定义结果。
    12|  * 
    13|  * @author Looly
    14|  *
    15|  */
    16| public class Query {
    17| 	/** 查询的字段名列表 */
    18| 	Collection<String> fields;
    19| 	/** 查询的表名 */
    20| 	String[] tableNames;
    21| 	/** 查询的条件语句 */
    22| 	Condition[] where;
    23| 	/** 分页对象 */
    24| 	Page page;
    25| 	/**
    26| 	 * 从{@link Entity}构建Query
    27| 	 * @param where 条件查询{@link Entity}，包含条件Map和表名
    28| 	 * @return Query
    29| 	 * @since 5.5.3
    30| 	 */
    31| 	public static Query of(Entity where){
    32| 		return new Query(SqlUtil.buildConditions(where), where.getTableName());
    33| 	}
    34| 	/**
    35| 	 * 构造
    36| 	 * 
    37| 	 * @param tableNames 表名
    38| 	 */
    39| 	public Query(String... tableNames) {
    40| 		this(null, tableNames);
    41| 		this.tableNames = tableNames;
    42| 	}
    43| 	/**
    44| 	 * 构造
    45| 	 * 
    46| 	 * @param where 条件语句
    47| 	 * @param tableNames 表名
    48| 	 */
    49| 	public Query(Condition[] where, String... tableNames) {
    50| 		this(where, null, tableNames);
    51| 	}
    52| 	/**
    53| 	 * 构造
    54| 	 * 
    55| 	 * @param where 条件语句
    56| 	 * @param page 分页
    57| 	 * @param tableNames 表名
    58| 	 */
    59| 	public Query(Condition[] where, Page page, String... tableNames) {
    60| 		this(null, tableNames, where, page);
    61| 	}
    62| 	/**
    63| 	 * 构造
    64| 	 * 
    65| 	 * @param fields 字段
    66| 	 * @param tableNames 表名
    67| 	 * @param where 条件
    68| 	 * @param page 分页
    69| 	 */
    70| 	public Query(Collection<String> fields, String[] tableNames, Condition[] where, Page page) {
    71| 		this.fields = fields;
    72| 		this.tableNames = tableNames;
    73| 		this.where = where;
    74| 		this.page = page;
    75| 	}
    76| 	/**
    77| 	 * 获得查询的字段名列表
    78| 	 * 
    79| 	 * @return 查询的字段名列表
    80| 	 */
    81| 	public Collection<String> getFields() {
    82| 		return fields;
    83| 	}
    84| 	/**
    85| 	 * 设置查询的字段名列表
    86| 	 * 
    87| 	 * @param fields 查询的字段名列表
    88| 	 * @return this
    89| 	 */
    90| 	public Query setFields(Collection<String> fields) {
    91| 		this.fields = fields;
    92| 		return this;
    93| 	}
    94| 	/**
    95| 	 * 设置查询的字段名列表
    96| 	 * 
    97| 	 * @param fields 查询的字段名列表
    98| 	 * @return this
    99| 	 */
   100| 	public Query setFields(String... fields) {
   101| 		this.fields = CollectionUtil.newArrayList(fields);
   102| 		return this;
   103| 	}
   104| 	/**
   105| 	 * 获得表名数组
   106| 	 * 
   107| 	 * @return 表名数组
   108| 	 */
   109| 	public String[] getTableNames() {
   110| 		return tableNames;
   111| 	}
   112| 	/**
   113| 	 * 设置表名
   114| 	 * 
   115| 	 * @param tableNames 表名
   116| 	 * @return this
   117| 	 */
   118| 	public Query setTableNames(String... tableNames) {
   119| 		this.tableNames = tableNames;
   120| 		return this;
   121| 	}
   122| 	/**
   123| 	 * 获得条件语句
   124| 	 * 
   125| 	 * @return 条件语句
   126| 	 */
   127| 	public Condition[] getWhere() {
   128| 		return where;
   129| 	}
   130| 	/**
   131| 	 * 设置条件语句
   132| 	 * 
   133| 	 * @param where 条件语句
   134| 	 * @return this
   135| 	 */
   136| 	public Query setWhere(Condition... where) {
   137| 		this.where = where;
   138| 		return this;
   139| 	}
   140| 	/**
   141| 	 * 获得分页对象，无分页返回{@code null}
   142| 	 * 
   143| 	 * @return 分页对象 or {@code null}
   144| 	 */
   145| 	public Page getPage() {
   146| 		return page;
   147| 	}
   148| 	/**
   149| 	 * 设置分页对象
   150| 	 * 
   151| 	 * @param page 分页对象
   152| 	 * @return this
   153| 	 */
   154| 	public Query setPage(Page page) {
   155| 		this.page = page;
   156| 		return this;
   157| 	}
   158| 	/**
   159| 	 * 获得第一个表名
   160| 	 * 
   161| 	 * @return 表名
   162| 	 * @throws DbRuntimeException 没有表
   163| 	 */
   164| 	public String getFirstTableName() throws DbRuntimeException {
   165| 		if (ArrayUtil.isEmpty(this.tableNames)) {
   166| 			throw new DbRuntimeException("No tableName!");
   167| 		}
   168| 		return this.tableNames[0];
   169| 	}
   170| }


# ====================================================================
# FILE: hutool-extra/src/main/java/cn/hutool/extra/compress/archiver/StreamArchiver.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 60-106 ---
    60| 	 * @param archiverName 归档类型名称，见{@link ArchiveStreamFactory}
    61| 	 * @param file         归档输出的文件
    62| 	 */
    63| 	public StreamArchiver(Charset charset, String archiverName, File file) {
    64| 		this(charset, archiverName, FileUtil.getOutputStream(file));
    65| 	}
    66| 	/**
    67| 	 * 构造
    68| 	 *
    69| 	 * @param charset      编码
    70| 	 * @param archiverName 归档类型名称，见{@link ArchiveStreamFactory}
    71| 	 * @param targetStream 归档输出的流
    72| 	 */
    73| 	public StreamArchiver(Charset charset, String archiverName, OutputStream targetStream) {
    74| 		if("tgz".equalsIgnoreCase(archiverName) || "tar.gz".equalsIgnoreCase(archiverName)){
    75| 			try {
    76| 				this.out = new TarArchiveOutputStream(new GzipCompressorOutputStream(targetStream));
    77| 			} catch (IOException e) {
    78| 				throw new IORuntimeException(e);
    79| 			}
    80| 			return;
    81| 		}
    82| 		final ArchiveStreamFactory factory = new ArchiveStreamFactory(charset.name());
    83| 		try {
    84| 			this.out = factory.createArchiveOutputStream(archiverName, targetStream);
    85| 		} catch (ArchiveException e) {
    86| 			throw new CompressException(e);
    87| 		}
    88| 		if(this.out instanceof TarArchiveOutputStream){
    89| 			((TarArchiveOutputStream)out).setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);
    90| 		} else if(this.out instanceof ArArchiveOutputStream){
    91| 			((ArArchiveOutputStream)out).setLongFileMode(ArArchiveOutputStream.LONGFILE_BSD);
    92| 		}
    93| 	}
    94| 	/**
    95| 	 * 将文件或目录加入归档包，目录采取递归读取方式按照层级加入
    96| 	 *
    97| 	 * @param file   文件或目录
    98| 	 * @param path   文件或目录的初始路径，null表示位于根路径
    99| 	 * @param filter 文件过滤器，指定哪些文件或目录可以加入，当{@link Filter#accept(Object)}为true时加入。
   100| 	 * @return this
   101| 	 * @throws IORuntimeException IO异常
   102| 	 */
   103| 	@Override
   104| 	public StreamArchiver add(File file, String path, Filter<File> filter) throws IORuntimeException {
   105| 		try {
   106| 			addInternal(file, path, filter);


# ====================================================================
# FILE: hutool-extra/src/main/java/cn/hutool/extra/expression/ExpressionEngine.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-17 ---
     1| package cn.hutool.extra.expression;
     2| import java.util.Map;
     3| /**
     4|  * 表达式引擎API接口，通过实现此接口，完成表达式的解析和执行
     5|  *
     6|  * @author looll,independenter
     7|  * @since 5.5.0
     8|  */
     9| public interface ExpressionEngine {
    10| 	/**
    11| 	 * 执行表达式
    12| 	 * @param expression 表达式
    13| 	 * @param context 表达式上下文，用于存储表达式中所需的变量值等
    14| 	 * @return 执行结果
    15| 	 */
    16| 	Object eval(String expression, Map<String, Object> context);
    17| }


# ====================================================================
# FILE: hutool-extra/src/main/java/cn/hutool/extra/expression/ExpressionUtil.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| package cn.hutool.extra.expression;
     2| import cn.hutool.extra.expression.engine.ExpressionFactory;
     3| import java.util.Map;
     4| /**
     5|  * 表达式引擎工具类
     6|  *
     7|  * @author looly
     8|  * @since 5.5.0
     9|  */
    10| public class ExpressionUtil {
    11| 	/**
    12| 	 * 获得全局单例的表达式引擎
    13| 	 *
    14| 	 * @return 全局单例的表达式引擎
    15| 	 */
    16| 	public static ExpressionEngine getEngine() {
    17| 		return ExpressionFactory.get();
    18| 	}
    19| 	/**
    20| 	 * 执行表达式
    21| 	 *
    22| 	 * @param expression 表达式
    23| 	 * @param context    表达式上下文，用于存储表达式中所需的变量值等
    24| 	 * @return 执行结果
    25| 	 */
    26| 	public static Object eval(String expression, Map<String, Object> context) {
    27| 		return getEngine().eval(expression, context);
    28| 	}
    29| }


# ====================================================================
# FILE: hutool-extra/src/main/java/cn/hutool/extra/expression/engine/aviator/AviatorEngine.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-33 ---
     1| package cn.hutool.extra.expression.engine.aviator;
     2| import cn.hutool.extra.expression.ExpressionEngine;
     3| import com.googlecode.aviator.AviatorEvaluator;
     4| import com.googlecode.aviator.AviatorEvaluatorInstance;
     5| import java.util.Map;
     6| /**
     7|  * Aviator引擎封装<br>
     8|  * 见：https://github.com/killme2008/aviatorscript
     9|  *
    10|  * @author looly
    11|  * @since 5.5.0
    12|  */
    13| public class AviatorEngine implements ExpressionEngine {
    14| 	private final AviatorEvaluatorInstance engine;
    15| 	/**
    16| 	 * 构造
    17| 	 */
    18| 	public AviatorEngine() {
    19| 		engine = AviatorEvaluator.getInstance();
    20| 	}
    21| 	@Override
    22| 	public Object eval(String expression, Map<String, Object> context) {
    23| 		return engine.execute(expression, context);
    24| 	}
    25| 	/**
    26| 	 * 获取{@link AviatorEvaluatorInstance}
    27| 	 *
    28| 	 * @return {@link AviatorEvaluatorInstance}
    29| 	 */
    30| 	public AviatorEvaluatorInstance getEngine() {
    31| 		return this.engine;
    32| 	}
    33| }


# ====================================================================
# FILE: hutool-extra/src/main/java/cn/hutool/extra/expression/engine/jexl/JexlEngine.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-35 ---
     1| package cn.hutool.extra.expression.engine.jexl;
     2| import cn.hutool.extra.expression.ExpressionEngine;
     3| import org.apache.commons.jexl3.JexlBuilder;
     4| import org.apache.commons.jexl3.MapContext;
     5| import java.util.Map;
     6| /**
     7|  * Jexl3引擎封装<br>
     8|  * 见：https://github.com/apache/commons-jexl
     9|  *
    10|  * @since 5.5.0
    11|  * @author looly
    12|  */
    13| public class JexlEngine implements ExpressionEngine {
    14| 	private final org.apache.commons.jexl3.JexlEngine engine;
    15| 	public JexlEngine(){
    16| 		engine = (new JexlBuilder()).cache(512).strict(true).silent(false).create();
    17| 	}
    18| 	@Override
    19| 	public Object eval(String expression, Map<String, Object> context) {
    20| 		final MapContext mapContext = new MapContext(context);
    21| 		try{
    22| 			return engine.createExpression(expression).evaluate(mapContext);
    23| 		} catch (Exception ignore){
    24| 			return engine.createScript(expression).execute(mapContext);
    25| 		}
    26| 	}
    27| 	/**
    28| 	 * 获取{@link org.apache.commons.jexl3.JexlEngine}
    29| 	 *
    30| 	 * @return {@link org.apache.commons.jexl3.JexlEngine}
    31| 	 */
    32| 	public org.apache.commons.jexl3.JexlEngine getEngine() {
    33| 		return this.engine;
    34| 	}
    35| }


# ====================================================================
# FILE: hutool-extra/src/main/java/cn/hutool/extra/expression/engine/jfireel/JfireELEngine.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-22 ---
     1| package cn.hutool.extra.expression.engine.jfireel;
     2| import cn.hutool.extra.expression.ExpressionEngine;
     3| import com.jfirer.jfireel.expression.Expression;
     4| import java.util.Map;
     5| /**
     6|  * JfireEL引擎封装<br>
     7|  * 见：https://gitee.com/eric_ds/jfireEL
     8|  *
     9|  * @since 5.5.0
    10|  * @author looly
    11|  */
    12| public class JfireELEngine implements ExpressionEngine {
    13| 	/**
    14| 	 * 构造
    15| 	 */
    16| 	public JfireELEngine(){
    17| 	}
    18| 	@Override
    19| 	public Object eval(String expression, Map<String, Object> context) {
    20| 		return Expression.parse(expression).calculate(context);
    21| 	}
    22| }


# ====================================================================
# FILE: hutool-extra/src/main/java/cn/hutool/extra/expression/engine/mvel/MvelEngine.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-22 ---
     1| package cn.hutool.extra.expression.engine.mvel;
     2| import cn.hutool.extra.expression.ExpressionEngine;
     3| import org.mvel2.MVEL;
     4| import java.util.Map;
     5| /**
     6|  * MVEL (MVFLEX Expression Language)引擎封装<br>
     7|  * 见：https://github.com/mvel/mvel
     8|  *
     9|  * @since 5.5.0
    10|  * @author looly
    11|  */
    12| public class MvelEngine implements ExpressionEngine {
    13| 	/**
    14| 	 * 构造
    15| 	 */
    16| 	public MvelEngine(){
    17| 	}
    18| 	@Override
    19| 	public Object eval(String expression, Map<String, Object> context) {
    20| 		return MVEL.eval(expression, context);
    21| 	}
    22| }


# ====================================================================
# FILE: hutool-extra/src/main/java/cn/hutool/extra/expression/engine/qlexpress/QLExpressEngine.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-32 ---
     1| package cn.hutool.extra.expression.engine.qlexpress;
     2| import cn.hutool.extra.expression.ExpressionEngine;
     3| import cn.hutool.extra.expression.ExpressionException;
     4| import com.ql.util.express.DefaultContext;
     5| import com.ql.util.express.ExpressRunner;
     6| import java.util.Map;
     7| /**
     8|  * QLExpress引擎封装<br>
     9|  * 见：https://github.com/alibaba/QLExpress
    10|  *
    11|  * @author looly
    12|  * @since 5.8.9
    13|  */
    14| public class QLExpressEngine implements ExpressionEngine {
    15| 	private final ExpressRunner engine;
    16| 	/**
    17| 	 * 构造
    18| 	 */
    19| 	public QLExpressEngine() {
    20| 		engine = new ExpressRunner();
    21| 	}
    22| 	@Override
    23| 	public Object eval(final String expression, final Map<String, Object> context) {
    24| 		final DefaultContext<String, Object> defaultContext = new DefaultContext<>();
    25| 		defaultContext.putAll(context);
    26| 		try {
    27| 			return engine.execute(expression, defaultContext, null, true, false);
    28| 		} catch (final Exception e) {
    29| 			throw new ExpressionException(e);
    30| 		}
    31| 	}
    32| }


# ====================================================================
# FILE: hutool-extra/src/main/java/cn/hutool/extra/expression/engine/rhino/RhinoEngine.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| package cn.hutool.extra.expression.engine.rhino;
     2| import cn.hutool.core.map.MapUtil;
     3| import cn.hutool.extra.expression.ExpressionEngine;
     4| import org.mozilla.javascript.Context;
     5| import org.mozilla.javascript.Scriptable;
     6| import org.mozilla.javascript.ScriptableObject;
     7| import java.util.Map;
     8| /**
     9|  * rhino引擎封装<br>
    10|  * 见：https://github.com/mozilla/rhino
    11|  *
    12|  * @author lzpeng
    13|  * @since 5.5.2
    14|  */
    15| public class RhinoEngine implements ExpressionEngine {
    16| 	@Override
    17| 	public Object eval(String expression, Map<String, Object> context) {
    18| 		final Context ctx = Context.enter();
    19| 		final Scriptable scope = ctx.initStandardObjects();
    20| 		if (MapUtil.isNotEmpty(context)) {
    21| 			context.forEach((key, value)->{
    22| 				ScriptableObject.putProperty(scope, key, Context.javaToJS(value, scope));
    23| 			});
    24| 		}
    25| 		final Object result = ctx.evaluateString(scope, expression, "rhino.js", 1, null);
    26| 		Context.exit();
    27| 		return result;
    28| 	}
    29| }


# ====================================================================
# FILE: hutool-extra/src/main/java/cn/hutool/extra/expression/engine/spel/SpELEngine.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| package cn.hutool.extra.expression.engine.spel;
     2| import cn.hutool.extra.expression.ExpressionEngine;
     3| import org.springframework.expression.EvaluationContext;
     4| import org.springframework.expression.ExpressionParser;
     5| import org.springframework.expression.spel.standard.SpelExpressionParser;
     6| import org.springframework.expression.spel.support.StandardEvaluationContext;
     7| import java.util.Map;
     8| /**
     9|  * Spring-Expression引擎封装<br>
    10|  * 见：https://github.com/spring-projects/spring-framework/tree/master/spring-expression
    11|  *
    12|  * @since 5.5.0
    13|  * @author looly
    14|  */
    15| public class SpELEngine implements ExpressionEngine {
    16| 	private final ExpressionParser parser;
    17| 	/**
    18| 	 * 构造
    19| 	 */
    20| 	public SpELEngine(){
    21| 		parser = new SpelExpressionParser();
    22| 	}
    23| 	@Override
    24| 	public Object eval(String expression, Map<String, Object> context) {
    25| 		final EvaluationContext evaluationContext = new StandardEvaluationContext();
    26| 		context.forEach(evaluationContext::setVariable);
    27| 		return parser.parseExpression(expression).getValue(evaluationContext);
    28| 	}
    29| }


# ====================================================================
# FILE: hutool-extra/src/main/java/cn/hutool/extra/ssh/Sftp.java
# Total hunks: 6
# ====================================================================
# --- HUNK 1: Lines 193-256 ---
   193| 	@Override
   194| 	public Sftp reconnectIfTimeout() {
   195| 		if (StrUtil.isBlank(this.ftpConfig.getHost())) {
   196| 			throw new FtpException("Host is blank!");
   197| 		}
   198| 		try {
   199| 			this.cd(StrUtil.SLASH);
   200| 		} catch (FtpException e) {
   201| 			close();
   202| 			init();
   203| 		}
   204| 		return this;
   205| 	}
   206| 	/**
   207| 	 * 获取SFTP通道客户端
   208| 	 *
   209| 	 * @return 通道客户端
   210| 	 * @since 4.1.14
   211| 	 */
   212| 	public ChannelSftp getClient() {
   213| 		return this.channel;
   214| 	}
   215| 	/**
   216| 	 * 远程当前目录
   217| 	 *
   218| 	 * @return 远程当前目录
   219| 	 */
   220| 	@Override
   221| 	public String pwd() {
   222| 		try {
   223| 			return channel.pwd();
   224| 		} catch (SftpException e) {
   225| 			throw new JschRuntimeException(e);
   226| 		}
   227| 	}
   228| 	/**
   229| 	 * 获取HOME路径
   230| 	 *
   231| 	 * @return HOME路径
   232| 	 * @since 4.0.5
   233| 	 */
   234| 	public String home() {
   235| 		try {
   236| 			return channel.getHome();
   237| 		} catch (SftpException e) {
   238| 			throw new JschRuntimeException(e);
   239| 		}
   240| 	}
   241| 	/**
   242| 	 * 遍历某个目录下所有文件或目录，不会递归遍历
   243| 	 *
   244| 	 * @param path 遍历某个目录下所有文件或目录
   245| 	 * @return 目录或文件名列表
   246| 	 * @since 4.0.5
   247| 	 */
   248| 	@Override
   249| 	public List<String> ls(String path) {
   250| 		return ls(path, null);
   251| 	}
   252| 	/**
   253| 	 * 遍历某个目录下所有目录，不会递归遍历
   254| 	 *
   255| 	 * @param path 遍历某个目录下所有目录
   256| 	 * @return 目录名列表

# --- HUNK 2: Lines 291-417 ---
   291| 	 *
   292| 	 * @param path 遍历某个目录下所有文件或目录
   293| 	 * @return 目录或文件名列表
   294| 	 * @since 5.3.5
   295| 	 */
   296| 	public List<LsEntry> lsEntries(String path) {
   297| 		return lsEntries(path, null);
   298| 	}
   299| 	/**
   300| 	 * 遍历某个目录下所有文件或目录，生成LsEntry列表，不会递归遍历<br>
   301| 	 * 此方法自动过滤"."和".."两种目录
   302| 	 *
   303| 	 * @param path   遍历某个目录下所有文件或目录
   304| 	 * @param filter 文件或目录过滤器，可以实现过滤器返回自己需要的文件或目录名列表
   305| 	 * @return 目录或文件名列表
   306| 	 * @since 5.3.5
   307| 	 */
   308| 	public List<LsEntry> lsEntries(String path, Filter<LsEntry> filter) {
   309| 		final List<LsEntry> entryList = new ArrayList<>();
   310| 		try {
   311| 			channel.ls(path, entry -> {
   312| 				final String fileName = entry.getFilename();
   313| 				if (false == StrUtil.equals(".", fileName) && false == StrUtil.equals("..", fileName)) {
   314| 					if (null == filter || filter.accept(entry)) {
   315| 						entryList.add(entry);
   316| 					}
   317| 				}
   318| 				return LsEntrySelector.CONTINUE;
   319| 			});
   320| 		} catch (SftpException e) {
   321| 			if (false == StrUtil.startWithIgnoreCase(e.getMessage(), "No such file")) {
   322| 				throw new JschRuntimeException(e);
   323| 			}
   324| 		}
   325| 		return entryList;
   326| 	}
   327| 	@Override
   328| 	public boolean mkdir(String dir) {
   329| 		if (isDir(dir)) {
   330| 			return true;
   331| 		}
   332| 		try {
   333| 			this.channel.mkdir(dir);
   334| 			return true;
   335| 		} catch (SftpException e) {
   336| 			throw new JschRuntimeException(e);
   337| 		}
   338| 	}
   339| 	@Override
   340| 	public boolean isDir(String dir) {
   341| 		final SftpATTRS sftpATTRS;
   342| 		try {
   343| 			sftpATTRS = this.channel.stat(dir);
   344| 		} catch (SftpException e) {
   345| 			final String msg = e.getMessage();
   346| 			if (StrUtil.containsAnyIgnoreCase(msg, "No such file", "does not exist")) {
   347| 				return false;
   348| 			}
   349| 			throw new FtpException(e);
   350| 		}
   351| 		return sftpATTRS.isDir();
   352| 	}
   353| 	/**
   354| 	 * 打开指定目录，如果指定路径非目录或不存在抛出异常
   355| 	 *
   356| 	 * @param directory directory
   357| 	 * @return 是否打开目录
   358| 	 * @throws FtpException 进入目录失败异常
   359| 	 */
   360| 	@Override
   361| 	synchronized public boolean cd(String directory) throws FtpException {
   362| 		if (StrUtil.isBlank(directory)) {
   363| 			return true;
   364| 		}
   365| 		try {
   366| 			channel.cd(directory.replace('\\', '/'));
   367| 			return true;
   368| 		} catch (SftpException e) {
   369| 			throw new FtpException(e);
   370| 		}
   371| 	}
   372| 	/**
   373| 	 * 删除文件
   374| 	 *
   375| 	 * @param filePath 要删除的文件绝对路径
   376| 	 */
   377| 	@Override
   378| 	public boolean delFile(String filePath) {
   379| 		try {
   380| 			channel.rm(filePath);
   381| 		} catch (SftpException e) {
   382| 			throw new JschRuntimeException(e);
   383| 		}
   384| 		return true;
   385| 	}
   386| 	/**
   387| 	 * 删除文件夹及其文件夹下的所有文件
   388| 	 *
   389| 	 * @param dirPath 文件夹路径
   390| 	 * @return boolean 是否删除成功
   391| 	 */
   392| 	@Override
   393| 	@SuppressWarnings("unchecked")
   394| 	public boolean delDir(String dirPath) {
   395| 		if (false == cd(dirPath)) {
   396| 			return false;
   397| 		}
   398| 		Vector<LsEntry> list;
   399| 		try {
   400| 			list = channel.ls(channel.pwd());
   401| 		} catch (SftpException e) {
   402| 			throw new JschRuntimeException(e);
   403| 		}
   404| 		String fileName;
   405| 		for (LsEntry entry : list) {
   406| 			fileName = entry.getFilename();
   407| 			if (false == ".".equals(fileName) && false == "..".equals(fileName)) {
   408| 				if (entry.getAttrs().isDir()) {
   409| 					delDir(fileName);
   410| 				} else {
   411| 					delFile(fileName);
   412| 				}
   413| 			}
   414| 		}
   415| 		if (false == cd("..")) {
   416| 			return false;
   417| 		}

# --- HUNK 3: Lines 492-550 ---
   492| 	 * @param srcFilePath 本地文件路径
   493| 	 * @param destPath    目标路径，
   494| 	 * @param mode        {@link Mode} 模式
   495| 	 * @return this
   496| 	 */
   497| 	public Sftp put(String srcFilePath, String destPath, Mode mode) {
   498| 		return put(srcFilePath, destPath, null, mode);
   499| 	}
   500| 	/**
   501| 	 * 将本地文件上传到目标服务器，目标文件名为destPath，若destPath为目录，则目标文件名将与srcFilePath文件名相同。
   502| 	 *
   503| 	 * @param srcFilePath 本地文件路径
   504| 	 * @param destPath    目标路径，
   505| 	 * @param monitor     上传进度监控，通过实现此接口完成进度显示
   506| 	 * @param mode        {@link Mode} 模式
   507| 	 * @return this
   508| 	 * @since 4.6.5
   509| 	 */
   510| 	public Sftp put(String srcFilePath, String destPath, SftpProgressMonitor monitor, Mode mode) {
   511| 		try {
   512| 			channel.put(srcFilePath, destPath, monitor, mode.ordinal());
   513| 		} catch (SftpException e) {
   514| 			throw new JschRuntimeException(e);
   515| 		}
   516| 		return this;
   517| 	}
   518| 	/**
   519| 	 * 将本地数据流上传到目标服务器，目标文件名为destPath，目标必须为文件
   520| 	 *
   521| 	 * @param srcStream 本地的数据流
   522| 	 * @param destPath  目标路径，
   523| 	 * @param monitor   上传进度监控，通过实现此接口完成进度显示
   524| 	 * @param mode      {@link Mode} 模式
   525| 	 * @return this
   526| 	 * @since 5.7.16
   527| 	 */
   528| 	public Sftp put(InputStream srcStream, String destPath, SftpProgressMonitor monitor, Mode mode) {
   529| 		try {
   530| 			channel.put(srcStream, destPath, monitor, mode.ordinal());
   531| 		} catch (SftpException e) {
   532| 			throw new JschRuntimeException(e);
   533| 		}
   534| 		return this;
   535| 	}
   536| 	@Override
   537| 	public void download(String src, File destFile) {
   538| 		get(src, FileUtil.getAbsolutePath(destFile));
   539| 	}
   540| 	/**
   541| 	 * 下载文件到{@link OutputStream}中
   542| 	 *
   543| 	 * @param src 源文件路径，包括文件名
   544| 	 * @param out 目标流
   545| 	 * @see #get(String, OutputStream)
   546| 	 */
   547| 	public void download(String src, OutputStream out) {
   548| 		get(src, out);
   549| 	}
   550| 	/**

# --- HUNK 4: Lines 565-621 ---
   565| 			if (false == item.getAttrs().isDir()) {
   566| 				if (false == FileUtil.exist(destFile)
   567| 						|| (item.getAttrs().getMTime() > (destFile.lastModified() / 1000))) {
   568| 					download(srcFile, destFile);
   569| 				}
   570| 			} else {
   571| 				FileUtil.mkdir(destFile);
   572| 				recursiveDownloadFolder(srcFile, destFile);
   573| 			}
   574| 		}
   575| 	}
   576| 	/**
   577| 	 * 获取远程文件
   578| 	 *
   579| 	 * @param src  远程文件路径
   580| 	 * @param dest 目标文件路径
   581| 	 * @return this
   582| 	 */
   583| 	public Sftp get(String src, String dest) {
   584| 		try {
   585| 			channel.get(src, dest);
   586| 		} catch (SftpException e) {
   587| 			throw new JschRuntimeException(e);
   588| 		}
   589| 		return this;
   590| 	}
   591| 	/**
   592| 	 * 获取远程文件
   593| 	 *
   594| 	 * @param src 远程文件路径
   595| 	 * @param out 目标流
   596| 	 * @return this
   597| 	 * @since 5.7.0
   598| 	 */
   599| 	public Sftp get(String src, OutputStream out) {
   600| 		try {
   601| 			channel.get(src, out);
   602| 		} catch (SftpException e) {
   603| 			throw new JschRuntimeException(e);
   604| 		}
   605| 		return this;
   606| 	}
   607| 	@Override
   608| 	public void close() {
   609| 		JschUtil.close(this.channel);
   610| 		JschUtil.close(this.session);
   611| 	}
   612| 	@Override
   613| 	public String toString() {
   614| 		return "Sftp{" +
   615| 				"host='" + this.ftpConfig.getHost() + '\'' +
   616| 				", port=" + this.ftpConfig.getPort() +
   617| 				", user='" + this.ftpConfig.getUser() + '\'' +
   618| 				'}';
   619| 	}
   620| 	/**
   621| 	 * JSch支持的三种文件传输模式


# ====================================================================
# FILE: hutool-http/src/main/java/cn/hutool/http/HttpRequest.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1188-1230 ---
  1188| 	}
  1189| 	/**
  1190| 	 * 创建body
  1191| 	 *
  1192| 	 * @return body
  1193| 	 */
  1194| 	private RequestBody createBody(){
  1195| 		if (null != this.body) {
  1196| 			return ResourceBody.create(this.body);
  1197| 		} else {
  1198| 			return FormUrlEncodedBody.create(this.form, this.charset);
  1199| 		}
  1200| 	}
  1201| 	/**
  1202| 	 * 发送多组件请求（例如包含文件的表单）<br>
  1203| 	 * 发送数据后自动关闭输出流
  1204| 	 *
  1205| 	 * @throws IOException IO异常
  1206| 	 */
  1207| 	private void sendMultipart() throws IOException {
  1208| 		final MultipartBody multipartBody = MultipartBody.create(this.form, this.charset);
  1209| 		this.httpConnection.header(Header.CONTENT_TYPE, multipartBody.getContentType(), true);
  1210| 		multipartBody.writeClose(this.httpConnection.getOutputStream());
  1211| 	}
  1212| 	/**
  1213| 	 * 是否忽略读取响应body部分<br>
  1214| 	 * HEAD、CONNECT、OPTIONS、TRACE方法将不读取响应体
  1215| 	 *
  1216| 	 * @return 是否需要忽略响应body部分
  1217| 	 * @since 3.1.2
  1218| 	 */
  1219| 	private boolean isIgnoreResponseBody() {
  1220| 		return Method.HEAD == this.method //
  1221| 				|| Method.CONNECT == this.method //
  1222| 				|| Method.OPTIONS == this.method //
  1223| 				|| Method.TRACE == this.method;
  1224| 	}
  1225| 	/**
  1226| 	 * 判断是否为multipart/form-data表单，条件如下：
  1227| 	 *
  1228| 	 * <pre>
  1229| 	 *     1. 存在资源对象（fileForm非空）
  1230| 	 *     2. 用户自定义头为multipart/form-data开头


# ====================================================================
# FILE: hutool-http/src/main/java/cn/hutool/http/useragent/Browser.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 19-59 ---
    19| 	 * 其它版本
    20| 	 */
    21| 	public static final String Other_Version = "[\\/ ]([\\d\\w\\.\\-]+)";
    22| 	/**
    23| 	 * 支持的浏览器类型
    24| 	 */
    25| 	public static final List<Browser> browers = CollUtil.newArrayList(
    26| 			new Browser("wxwork", "wxwork", "wxwork\\/([\\d\\w\\.\\-]+)"),
    27| 			new Browser("MicroMessenger", "MicroMessenger", Other_Version),
    28| 			new Browser("miniProgram", "miniProgram", Other_Version),
    29| 			new Browser("QQBrowser", "MQQBrowser", "MQQBrowser\\/([\\d\\w\\.\\-]+)"),
    30| 			new Browser("DingTalk-win", "dingtalk-win", "DingTalk\\(([\\d\\w\\.\\-]+)\\)"),
    31| 			new Browser("DingTalk", "DingTalk", "AliApp\\(DingTalk\\/([\\d\\w\\.\\-]+)\\)"),
    32| 			new Browser("Alipay", "AlipayClient", "AliApp\\(AP\\/([\\d\\w\\.\\-]+)\\)"),
    33| 			new Browser("Taobao", "taobao", "AliApp\\(TB\\/([\\d\\w\\.\\-]+)\\)"),
    34| 			new Browser("UCBrowser", "UC?Browser", "UC?Browser\\/([\\d\\w\\.\\-]+)"),
    35| 			new Browser("MiuiBrowser", "MiuiBrowser|mibrowser", "MiuiBrowser\\/([\\d\\w\\.\\-]+)"),
    36| 			new Browser("Quark", "Quark", Other_Version),
    37| 			new Browser("Lenovo", "SLBrowser", "SLBrowser/([\\d\\w\\.\\-]+)"),
    38| 			new Browser("MSEdge", "Edge|Edg", "(?:edge|Edg|EdgA)\\/([\\d\\w\\.\\-]+)"),
    39| 			new Browser("Chrome", "chrome", Other_Version),
    40| 			new Browser("Firefox", "firefox", Other_Version),
    41| 			new Browser("IEMobile", "iemobile", Other_Version),
    42| 			new Browser("Android Browser", "android", "version\\/([\\d\\w\\.\\-]+)"),
    43| 			new Browser("Safari", "safari", "version\\/([\\d\\w\\.\\-]+)"),
    44| 			new Browser("Opera", "opera", Other_Version),
    45| 			new Browser("Konqueror", "konqueror", Other_Version),
    46| 			new Browser("PS3", "playstation 3", "([\\d\\w\\.\\-]+)\\)\\s*$"),
    47| 			new Browser("PSP", "playstation portable", "([\\d\\w\\.\\-]+)\\)?\\s*$"),
    48| 			new Browser("Lotus", "lotus.notes", "Lotus-Notes\\/([\\w.]+)"),
    49| 			new Browser("Thunderbird", "thunderbird", Other_Version),
    50| 			new Browser("Netscape", "netscape", Other_Version),
    51| 			new Browser("Seamonkey", "seamonkey", Other_Version),
    52| 			new Browser("Outlook", "microsoft.outlook", Other_Version),
    53| 			new Browser("Evolution", "evolution", Other_Version),
    54| 			new Browser("MSIE", "msie", "msie ([\\d\\w\\.\\-]+)"),
    55| 			new Browser("MSIE11", "rv:11", "rv:([\\d\\w\\.\\-]+)"),
    56| 			new Browser("Gabble", "Gabble", Other_Version),
    57| 			new Browser("Yammer Desktop", "AdobeAir", "([\\d\\w\\.\\-]+)\\/Yammer"),
    58| 			new Browser("Yammer Mobile", "Yammer[\\s]+([\\d\\w\\.\\-]+)", "Yammer[\\s]+([\\d\\w\\.\\-]+)"),
    59| 			new Browser("Apache HTTP Client", "Apache\\\\-HttpClient", "Apache\\-HttpClient\\/([\\d\\w\\.\\-]+)"),


# ====================================================================
# FILE: hutool-json/src/main/java/cn/hutool/json/JSONBeanParser.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-16 ---
     1| package cn.hutool.json;
     2| /**
     3|  * 实现此接口的类可以通过实现{@code parse(value)}方法来将JSON中的值解析为此对象的值
     4|  *
     5|  * @author Looly
     6|  * @since 5.7.8
     7|  */
     8| public interface JSONBeanParser<T> {
     9| 	/**
    10| 	 * value转Bean<br>
    11| 	 * 通过实现此接口，将JSON中的值填充到当前对象的字段值中，即对象自行实现JSON反序列化逻辑
    12| 	 *
    13| 	 * @param value 被解析的对象类型，可能为JSON或者普通String、Number等
    14| 	 */
    15| 	void parse(T value);
    16| }


# ====================================================================
# FILE: hutool-jwt/src/main/java/cn/hutool/jwt/signers/AsymmetricJWTSigner.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 32-64 ---
    32| 	 * 构造
    33| 	 *
    34| 	 * @param algorithm 算法字符串表示
    35| 	 * @param keyPair   密钥对
    36| 	 */
    37| 	public AsymmetricJWTSigner(String algorithm, KeyPair keyPair) {
    38| 		this.sign = new Sign(algorithm, keyPair);
    39| 	}
    40| 	/**
    41| 	 * 设置编码
    42| 	 *
    43| 	 * @param charset 编码
    44| 	 * @return 编码
    45| 	 */
    46| 	public AsymmetricJWTSigner setCharset(Charset charset) {
    47| 		this.charset = charset;
    48| 		return this;
    49| 	}
    50| 	@Override
    51| 	public String sign(String headerBase64, String payloadBase64) {
    52| 		return Base64.encodeUrlSafe(sign.sign(StrUtil.format("{}.{}", headerBase64, payloadBase64)));
    53| 	}
    54| 	@Override
    55| 	public boolean verify(String headerBase64, String payloadBase64, String signBase64) {
    56| 		return sign.verify(
    57| 				StrUtil.bytes(StrUtil.format("{}.{}", headerBase64, payloadBase64), charset),
    58| 				Base64.decode(signBase64));
    59| 	}
    60| 	@Override
    61| 	public String getAlgorithm() {
    62| 		return this.sign.getSignature().getAlgorithm();
    63| 	}
    64| }


# ====================================================================
# FILE: hutool-jwt/src/main/java/cn/hutool/jwt/signers/JWTSignerUtil.java
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-22 ---
     1| package cn.hutool.jwt.signers;
     2| import cn.hutool.core.lang.Assert;
     3| import java.security.Key;
     4| import java.security.KeyPair;
     5| import java.security.PrivateKey;
     6| import java.security.PublicKey;
     7| /**
     8|  * JWT签名器工具类
     9|  *
    10|  * @author looly
    11|  * @since 5.7.0
    12|  */
    13| public class JWTSignerUtil {
    14| 	/**
    15| 	 * 无签名
    16| 	 *
    17| 	 * @return 无签名的签名器
    18| 	 */
    19| 	public static JWTSigner none() {
    20| 		return NoneJWTSigner.NONE;
    21| 	}
    22| 	/**

# --- HUNK 2: Lines 199-238 ---
   199| 	 */
   200| 	public static JWTSigner createSigner(String algorithmId, byte[] key) {
   201| 		Assert.notNull(key, "Signer key must be not null!");
   202| 		if (null == algorithmId || NoneJWTSigner.ID_NONE.equals(algorithmId)) {
   203| 			return none();
   204| 		}
   205| 		return new HMacJWTSigner(AlgorithmUtil.getAlgorithm(algorithmId), key);
   206| 	}
   207| 	/**
   208| 	 * 创建签名器
   209| 	 *
   210| 	 * @param algorithmId 算法ID，见{@link AlgorithmUtil}
   211| 	 * @param keyPair     密钥对
   212| 	 * @return 签名器
   213| 	 */
   214| 	public static JWTSigner createSigner(String algorithmId, KeyPair keyPair) {
   215| 		Assert.notNull(keyPair, "Signer key pair must be not null!");
   216| 		if (null == algorithmId || NoneJWTSigner.ID_NONE.equals(algorithmId)) {
   217| 			return none();
   218| 		}
   219| 		return new AsymmetricJWTSigner(AlgorithmUtil.getAlgorithm(algorithmId), keyPair);
   220| 	}
   221| 	/**
   222| 	 * 创建签名器
   223| 	 *
   224| 	 * @param algorithmId 算法ID，见{@link AlgorithmUtil}
   225| 	 * @param key         密钥
   226| 	 * @return 签名器
   227| 	 */
   228| 	public static JWTSigner createSigner(String algorithmId, Key key) {
   229| 		Assert.notNull(key, "Signer key must be not null!");
   230| 		if (null == algorithmId || NoneJWTSigner.ID_NONE.equals(algorithmId)) {
   231| 			return NoneJWTSigner.NONE;
   232| 		}
   233| 		if (key instanceof PrivateKey || key instanceof PublicKey) {
   234| 			return new AsymmetricJWTSigner(AlgorithmUtil.getAlgorithm(algorithmId), key);
   235| 		}
   236| 		return new HMacJWTSigner(AlgorithmUtil.getAlgorithm(algorithmId), key);
   237| 	}
   238| }


# ====================================================================
# FILE: hutool-poi/src/main/java/cn/hutool/poi/excel/ExcelReader.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 357-401 ---
   357| 	 * @param rowIndex 行号，从0开始
   358| 	 * @return 一行数据
   359| 	 * @since 4.0.3
   360| 	 */
   361| 	public List<Object> readRow(int rowIndex) {
   362| 		return readRow(this.sheet.getRow(rowIndex));
   363| 	}
   364| 	/**
   365| 	 * 读取某个单元格的值
   366| 	 *
   367| 	 * @param x X坐标，从0计数，即列号
   368| 	 * @param y Y坐标，从0计数，即行号
   369| 	 * @return 值，如果单元格无值返回null
   370| 	 * @since 4.0.3
   371| 	 */
   372| 	public Object readCellValue(int x, int y) {
   373| 		return CellUtil.getCellValue(getCell(x, y), this.cellEditor);
   374| 	}
   375| 	/**
   376| 	 * 获取Excel写出器<br>
   377| 	 * 在读取Excel并做一定编辑后，获取写出器写出<br>
   378| 	 * 注意，只读方式下，此方法无效
   379| 	 *
   380| 	 * @return {@link ExcelWriter}
   381| 	 * @since 4.0.6
   382| 	 */
   383| 	public ExcelWriter getWriter() {
   384| 		return ExcelUtil.getWriter(this.destFile, this.sheet.getSheetName());
   385| 	}
   386| 	/**
   387| 	 * 读取一行
   388| 	 *
   389| 	 * @param row 行
   390| 	 * @return 单元格值列表
   391| 	 */
   392| 	private List<Object> readRow(Row row) {
   393| 		return RowUtil.readRow(row, this.cellEditor);
   394| 	}
   395| 	/**
   396| 	 * 检查是否未关闭状态
   397| 	 */
   398| 	private void checkNotClosed() {
   399| 		Assert.isFalse(this.isClosed, "ExcelReader has been closed!");
   400| 	}
   401| }


# ====================================================================
# FILE: hutool-setting/src/main/java/cn/hutool/setting/SettingLoader.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 85-141 ---
    85| 	}
    86| 	/**
    87| 	 * 加载设置文件。 此方法不会关闭流对象
    88| 	 *
    89| 	 * @param settingStream 文件流
    90| 	 * @return 加载成功与否
    91| 	 * @throws IOException IO异常
    92| 	 */
    93| 	synchronized public boolean load(InputStream settingStream) throws IOException {
    94| 		this.groupedMap.clear();
    95| 		BufferedReader reader = null;
    96| 		try {
    97| 			reader = IoUtil.getReader(settingStream, this.charset);
    98| 			String group = null;
    99| 			String line;
   100| 			while (true) {
   101| 				line = reader.readLine();
   102| 				if (line == null) {
   103| 					break;
   104| 				}
   105| 				line = line.trim();
   106| 				if (StrUtil.isBlank(line) || StrUtil.startWith(line, COMMENT_FLAG_PRE)) {
   107| 					continue;
   108| 				}
   109| 				if (StrUtil.isSurround(line, CharUtil.BRACKET_START, CharUtil.BRACKET_END)) {
   110| 					group = line.substring(1, line.length() - 1).trim();
   111| 					continue;
   112| 				}
   113| 				final String[] keyValue = StrUtil.splitToArray(line, this.assignFlag, 2);
   114| 				if (keyValue.length < 2) {
   115| 					continue;
   116| 				}
   117| 				String value = keyValue[1].trim();
   118| 				if (this.isUseVariable) {
   119| 					value = replaceVar(group, value);
   120| 				}
   121| 				this.groupedMap.put(group, keyValue[0].trim(), value);
   122| 			}
   123| 		} finally {
   124| 			IoUtil.close(reader);
   125| 		}
   126| 		return true;
   127| 	}
   128| 	/**
   129| 	 * 设置变量的正则<br>
   130| 	 * 正则只能有一个group表示变量本身，剩余为字符 例如 \$\{(name)\}表示${name}变量名为name的一个变量表示
   131| 	 *
   132| 	 * @param regex 正则
   133| 	 */
   134| 	public void setVarRegex(String regex) {
   135| 		this.varRegex = regex;
   136| 	}
   137| 	/**
   138| 	 * 赋值分隔符（用于分隔键值对）
   139| 	 *
   140| 	 * @param assignFlag 正则
   141| 	 * @since 4.6.5


# ====================================================================
# FILE: hutool-system/src/main/java/cn/hutool/system/UserInfo.java
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 4-44 ---
     4| import java.io.Serializable;
     5| /**
     6|  * 代表当前用户的信息。
     7|  */
     8| public class UserInfo implements Serializable{
     9| 	private static final long serialVersionUID = 1L;
    10| 	private final String USER_NAME;
    11| 	private final String USER_HOME;
    12| 	private final String USER_DIR;
    13| 	private final String JAVA_IO_TMPDIR;
    14| 	private final String USER_LANGUAGE;
    15| 	private final String USER_COUNTRY;
    16| 	public UserInfo(){
    17| 		USER_NAME = fixPath(SystemUtil.get("user.name", false));
    18| 		USER_HOME = fixPath(SystemUtil.get("user.home", false));
    19| 		USER_DIR = fixPath(SystemUtil.get("user.dir", false));
    20| 		JAVA_IO_TMPDIR = fixPath(SystemUtil.get("java.io.tmpdir", false));
    21| 		USER_LANGUAGE = SystemUtil.get("user.language", false);
    22| 		String userCountry = SystemUtil.get("user.country", false);
    23| 		if(null == userCountry){
    24| 			userCountry = SystemUtil.get("user.country", false);
    25| 		}
    26| 		USER_COUNTRY = userCountry;
    27| 	}
    28| 	/**
    29| 	 * 取得当前登录用户的名字（取自系统属性：{@code user.name}）。
    30| 	 *
    31| 	 * <p>
    32| 	 * 例如：{@code "admin"}
    33| 	 * </p>
    34| 	 *
    35| 	 * @return 属性值，如果不能取得（因为Java安全限制）或值不存在，则返回{@code null}。
    36| 	 *
    37| 	 * @since Java 1.1
    38| 	 */
    39| 	public final String getName() {
    40| 		return USER_NAME;
    41| 	}
    42| 	/**
    43| 	 * 取得当前登录用户的home目录（取自系统属性：{@code user.home}）。
    44| 	 *

