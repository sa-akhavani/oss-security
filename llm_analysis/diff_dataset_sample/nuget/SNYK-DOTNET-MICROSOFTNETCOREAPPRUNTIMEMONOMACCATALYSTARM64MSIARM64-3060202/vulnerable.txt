# ====================================================================
# FILE: src/coreclr/debug/daccess/dacdbiimpl.cpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 3145-3184 ---
  3145|     return TargetBuffer(PTR_TO_CORDB_ADDRESS(pVACookie->signature.GetRawSig()),
  3146|                         pVACookie->signature.GetRawSigLen());
  3147| }
  3148| BOOL DacDbiInterfaceImpl::RequiresAlign8(VMPTR_TypeHandle thExact)
  3149| {
  3150|     DD_ENTER_MAY_THROW;
  3151| #ifdef FEATURE_64BIT_ALIGNMENT
  3152|     TypeHandle th = TypeHandle::FromPtr(thExact.GetDacPtr());
  3153|     PTR_MethodTable mt = th.AsMethodTable();
  3154|     return mt->RequiresAlign8();
  3155| #else
  3156|     ThrowHR(E_NOTIMPL);
  3157| #endif
  3158| }
  3159| GENERICS_TYPE_TOKEN DacDbiInterfaceImpl::ResolveExactGenericArgsToken(DWORD               dwExactGenericArgsTokenIndex,
  3160|                                                                       GENERICS_TYPE_TOKEN rawToken)
  3161| {
  3162|     DD_ENTER_MAY_THROW;
  3163|     if (dwExactGenericArgsTokenIndex == 0)
  3164|     {
  3165|         TADDR addrObjThis = CORDB_ADDRESS_TO_TADDR(rawToken);
  3166|         PTR_Object pObjThis = dac_cast<PTR_Object>(addrObjThis);
  3167|         PTR_MethodTable pMT = pObjThis->GetMethodTable();
  3168|         TADDR addrMT = dac_cast<TADDR>(pMT);
  3169|         GENERICS_TYPE_TOKEN realToken = (GENERICS_TYPE_TOKEN) addrMT;
  3170|         return realToken;
  3171|     }
  3172|     else if (dwExactGenericArgsTokenIndex == (DWORD)ICorDebugInfo::TYPECTXT_ILNUM)
  3173|     {
  3174|         return  rawToken;
  3175|     }
  3176|     _ASSERTE(!"DDII::REGAT - Unexpected generics type token index.");
  3177|     ThrowHR(CORDBG_E_TARGET_INCONSISTENT);
  3178| }
  3179| IDacDbiInterface::DynamicMethodType DacDbiInterfaceImpl::IsILStubOrLCGMethod(VMPTR_MethodDesc vmMethodDesc)
  3180| {
  3181|     DD_ENTER_MAY_THROW;
  3182|     MethodDesc * pMD = vmMethodDesc.GetDacPtr();
  3183|     if (pMD->IsILStub())
  3184|     {


# ====================================================================
# FILE: src/coreclr/pal/src/exception/machexception.cpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 243-297 ---
   243|         CHECK_MACH("mach_port_deallocate", MachRetDeallocate);
   244|         if (MachRet != KERN_SUCCESS)
   245|             break;
   246|     }
   247|     if (MachRet != KERN_SUCCESS)
   248|     {
   249|         ASSERT("thread_set_exception_ports failed: %d\n", MachRet);
   250|         palError = UTIL_MachErrorToPalError(MachRet);
   251|     }
   252|     return palError;
   253| }
   254| #if defined(HOST_AMD64)
   255| extern "C"
   256| void PAL_DispatchException(DWORD64 dwRDI, DWORD64 dwRSI, DWORD64 dwRDX, DWORD64 dwRCX, DWORD64 dwR8, DWORD64 dwR9, PCONTEXT pContext, PEXCEPTION_RECORD pExRecord, MachExceptionInfo *pMachExceptionInfo)
   257| #elif defined(HOST_ARM64)
   258| extern "C"
   259| void PAL_DispatchException(PCONTEXT pContext, PEXCEPTION_RECORD pExRecord, MachExceptionInfo *pMachExceptionInfo)
   260| #endif
   261| {
   262|     CPalThread *pThread = InternalGetCurrentThread();
   263|     CONTEXT *contextRecord;
   264|     EXCEPTION_RECORD *exceptionRecord;
   265|     AllocateExceptionRecords(&exceptionRecord, &contextRecord);
   266|     *contextRecord = *pContext;
   267|     *exceptionRecord = *pExRecord;
   268|     contextRecord->ContextFlags |= CONTEXT_EXCEPTION_ACTIVE;
   269|     bool continueExecution;
   270|     {
   271|         PAL_SEHException exception(exceptionRecord, contextRecord);
   272|         TRACE("PAL_DispatchException(EC %08x EA %p)\n", pExRecord->ExceptionCode, pExRecord->ExceptionAddress);
   273|         continueExecution = SEHProcessException(&exception);
   274|         if (continueExecution)
   275|         {
   276|             *pContext = *contextRecord;
   277|             *pExRecord = *exceptionRecord;
   278|         }
   279|     }
   280|     if (continueExecution)
   281|     {
   282| #if defined(HOST_ARM64)
   283|         MachSetThreadContext(pContext);
   284| #else
   285|         RtlRestoreContext(pContext, pExRecord);
   286| #endif
   287|     }
   288|     MachMessage sSendMessage;
   289|     sSendMessage.SendForwardException(s_ExceptionPort, pMachExceptionInfo, pThread);
   290|     while (TRUE)
   291|     {
   292|         sched_yield();
   293|     }
   294| }
   295| extern "C" void PAL_DispatchExceptionWrapper();
   296| extern "C" int PAL_DispatchExceptionReturnOffset;
   297| /*++


# ====================================================================
# FILE: src/coreclr/pal/src/exception/seh-unwind.cpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 405-459 ---
   405|     GetContextPointer(cursor, unwContext, UNW_AARCH64_V12, &contextPointers->D12);
   406|     GetContextPointer(cursor, unwContext, UNW_AARCH64_V13, &contextPointers->D13);
   407|     GetContextPointer(cursor, unwContext, UNW_AARCH64_V14, &contextPointers->D14);
   408|     GetContextPointer(cursor, unwContext, UNW_AARCH64_V15, &contextPointers->D15);
   409| #elif (defined(HOST_UNIX) && defined(HOST_S390X))
   410|     GetContextPointer(cursor, unwContext, UNW_S390X_R6, &contextPointers->R6);
   411|     GetContextPointer(cursor, unwContext, UNW_S390X_R7, &contextPointers->R7);
   412|     GetContextPointer(cursor, unwContext, UNW_S390X_R8, &contextPointers->R8);
   413|     GetContextPointer(cursor, unwContext, UNW_S390X_R9, &contextPointers->R9);
   414|     GetContextPointer(cursor, unwContext, UNW_S390X_R10, &contextPointers->R10);
   415|     GetContextPointer(cursor, unwContext, UNW_S390X_R11, &contextPointers->R11);
   416|     GetContextPointer(cursor, unwContext, UNW_S390X_R12, &contextPointers->R12);
   417|     GetContextPointer(cursor, unwContext, UNW_S390X_R13, &contextPointers->R13);
   418|     GetContextPointer(cursor, unwContext, UNW_S390X_R14, &contextPointers->R14);
   419|     GetContextPointer(cursor, unwContext, UNW_S390X_R15, &contextPointers->R15);
   420| #else
   421| #error unsupported architecture
   422| #endif
   423| }
   424| #ifndef HOST_WINDOWS
   425| extern int g_common_signal_handler_context_locvar_offset;
   426| BOOL PAL_VirtualUnwind(CONTEXT *context, KNONVOLATILE_CONTEXT_POINTERS *contextPointers)
   427| {
   428|     int st;
   429|     unw_context_t unwContext;
   430|     unw_cursor_t cursor;
   431|     DWORD64 curPc = CONTEXTGetPC(context);
   432| #ifndef __APPLE__
   433|     if ((void*)curPc == g_SEHProcessExceptionReturnAddress)
   434|     {
   435|         CONTEXT* signalContext = (CONTEXT*)(CONTEXTGetFP(context) + g_common_signal_handler_context_locvar_offset);
   436|         memcpy_s(context, sizeof(CONTEXT), signalContext, sizeof(CONTEXT));
   437|         return TRUE;
   438|     }
   439| #endif
   440|     if ((context->ContextFlags & CONTEXT_EXCEPTION_ACTIVE) != 0)
   441|     {
   442|         CONTEXTSetPC(context, curPc + 1);
   443|     }
   444| #if !UNWIND_CONTEXT_IS_UCONTEXT_T
   445| #if defined(__llvm__) && defined(TARGET_ARM)
   446| #pragma clang diagnostic push
   447| #pragma clang diagnostic ignored "-Winline-asm"
   448| #endif
   449|     st = unw_getcontext(&unwContext);
   450| #if defined(__llvm__) && defined(TARGET_ARM)
   451| #pragma clang diagnostic pop
   452| #endif
   453|     if (st < 0)
   454|     {
   455|         return FALSE;
   456|     }
   457| #endif
   458|     WinContextToUnwindContext(context, &unwContext);
   459|     st = unw_init_local(&cursor, &unwContext);


# ====================================================================
# FILE: src/coreclr/pal/src/exception/signal.cpp
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 60-100 ---
    60| /* internal data declarations *********************************************/
    61| bool g_registered_signal_handlers = false;
    62| #if !HAVE_MACH_EXCEPTIONS
    63| bool g_enable_alternate_stack_check = false;
    64| #endif // !HAVE_MACH_EXCEPTIONS
    65| static bool g_registered_sigterm_handler = false;
    66| static bool g_registered_activation_handler = false;
    67| struct sigaction g_previous_sigterm;
    68| #ifdef INJECT_ACTIVATION_SIGNAL
    69| struct sigaction g_previous_activation;
    70| #endif
    71| struct sigaction g_previous_sigill;
    72| struct sigaction g_previous_sigtrap;
    73| struct sigaction g_previous_sigfpe;
    74| struct sigaction g_previous_sigbus;
    75| struct sigaction g_previous_sigsegv;
    76| struct sigaction g_previous_sigint;
    77| struct sigaction g_previous_sigquit;
    78| struct sigaction g_previous_sigabrt;
    79| #if !HAVE_MACH_EXCEPTIONS
    80| int g_common_signal_handler_context_locvar_offset = 0;
    81| volatile void* g_stackOverflowHandlerStack = NULL;
    82| const int StackOverflowFlag = 0x40000000;
    83| #endif // !HAVE_MACH_EXCEPTIONS
    84| /* public function definitions ************************************************/
    85| /*++
    86| Function :
    87|     SEHInitializeSignals
    88|     Set up signal handlers to catch signals and translate them to exceptions
    89| Parameters :
    90|     None
    91| Return :
    92|     TRUE in case of a success, FALSE otherwise
    93| --*/
    94| BOOL SEHInitializeSignals(CorUnix::CPalThread *pthrCurrent, DWORD flags)
    95| {
    96|     TRACE("Initializing signal handlers %04x\n", flags);
    97| #if !HAVE_MACH_EXCEPTIONS
    98|     char* enableAlternateStackCheck = getenv("COMPlus_EnableAlternateStackCheck");
    99|     g_enable_alternate_stack_check = enableAlternateStackCheck && (strtoul(enableAlternateStackCheck, NULL, 10) != 0);
   100| #endif

# --- HUNK 2: Lines 656-699 ---
   656| Function :
   657|     common_signal_handler
   658|     common code for all signal handlers
   659| Parameters :
   660|     int code : signal received
   661|     siginfo_t *siginfo : siginfo passed to the signal handler
   662|     void *context : context structure passed to the signal handler
   663|     int numParams : number of variable parameters of the exception
   664|     ... : variable parameters of the exception (each of size_t type)
   665|     Returns true if the execution should continue or false if the exception was unhandled
   666| Note:
   667|     the "pointers" parameter should contain a valid exception record pointer,
   668|     but the ContextRecord pointer will be overwritten.
   669| --*/
   670| __attribute__((noinline))
   671| static bool common_signal_handler(int code, siginfo_t *siginfo, void *sigcontext, int numParams, ...)
   672| {
   673| #if !HAVE_MACH_EXCEPTIONS
   674|     sigset_t signal_set;
   675|     CONTEXT signalContextRecord;
   676|     EXCEPTION_RECORD exceptionRecord;
   677|     native_context_t *ucontext;
   678|     ucontext = (native_context_t *)sigcontext;
   679|     g_common_signal_handler_context_locvar_offset = (int)((char*)&signalContextRecord - (char*)__builtin_frame_address(0));
   680|     if (code == (SIGSEGV | StackOverflowFlag))
   681|     {
   682|         exceptionRecord.ExceptionCode = EXCEPTION_STACK_OVERFLOW;
   683|         code &= ~StackOverflowFlag;
   684|     }
   685|     else
   686|     {
   687|         exceptionRecord.ExceptionCode = CONTEXTGetExceptionCodeForSignal(siginfo, ucontext);
   688|     }
   689|     exceptionRecord.ExceptionFlags = EXCEPTION_IS_SIGNAL;
   690|     exceptionRecord.ExceptionRecord = NULL;
   691|     exceptionRecord.ExceptionAddress = GetNativeContextPC(ucontext);
   692|     exceptionRecord.NumberParameters = numParams;
   693|     va_list params;
   694|     va_start(params, numParams);
   695|     for (int i = 0; i < numParams; i++)
   696|     {
   697|         exceptionRecord.ExceptionInformation[i] = va_arg(params, size_t);
   698|     }
   699|     RtlCaptureContext(&signalContextRecord);


# ====================================================================
# FILE: src/coreclr/pal/src/include/pal/seh.hpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 80-100 ---
    80|     Enable SEH-related stuff on this thread
    81| Parameters:
    82|     CPalThread * pthrCurrent : reference to the current thread.
    83| Return value :
    84|     ERROR_SUCCESS, if enabling succeeded
    85|     an error code, otherwise
    86| --*/
    87| CorUnix::PAL_ERROR SEHEnable(CorUnix::CPalThread *pthrCurrent);
    88| /*++
    89| Function :
    90|     SEHDisable
    91|     Disable SEH-related stuff on this thread
    92| Parameters:
    93|     CPalThread * pthrCurrent : reference to the current thread.
    94| Return value :
    95|     ERROR_SUCCESS, if enabling succeeded
    96|     an error code, otherwise
    97| --*/
    98| CorUnix::PAL_ERROR SEHDisable(CorUnix::CPalThread *pthrCurrent);
    99| }
   100| #endif /* _PAL_SEH_HPP_ */


# ====================================================================
# FILE: src/coreclr/tools/aot/ILCompiler.ReadyToRun/Compiler/ReadyToRunHashCode.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-44 ---
     1| using System;
     2| using System.Diagnostics;
     3| using System.Numerics;
     4| using System.Text;
     5| using Internal.TypeSystem;
     6| namespace ILCompiler
     7| {
     8|     public static class ReadyToRunHashCode
     9|     {
    10|         public static int NameHashCode(string name)
    11|         {
    12|             if (string.IsNullOrEmpty(name))
    13|             {
    14|                 return 0;
    15|             }
    16|             int hash1 = 0x6DA3B944;
    17|             int hash2 = 0;
    18|             byte[] src = Encoding.UTF8.GetBytes(name);
    19|             for (int i = 0; i < src.Length; i += 2)
    20|             {
    21|                 hash1 = unchecked(hash1 + RotateLeft(hash1, 5)) ^ src[i];
    22|                 if (i + 1 < src.Length)
    23|                 {
    24|                     hash2 = unchecked(hash2 + RotateLeft(hash2, 5)) ^ src[i + 1];
    25|                 }
    26|                 else
    27|                 {
    28|                     break;
    29|                 }
    30|             }
    31|             hash1 = unchecked(hash1 + RotateLeft(hash1, 8));
    32|             hash2 = unchecked(hash2 + RotateLeft(hash2, 8));
    33|             return unchecked((int)(hash1 ^ hash2));
    34|         }
    35|         public static int NameHashCode(string namespacePart, string namePart)
    36|         {
    37|             return NameHashCode(namespacePart) ^ NameHashCode(namePart);
    38|         }
    39|         public static int TypeTableHashCode(DefType type)
    40|         {
    41|             int hashcode = 0;
    42|             do
    43|             {
    44|                 hashcode ^= NameHashCode(type.Namespace, type.Name);


# ====================================================================
# FILE: src/coreclr/vm/proftoeeinterfaceimpl.cpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 682-722 ---
   682| #endif // FEATURE_EVENT_TRACE
   683|     if ((arrObjRef != NULL) && !bOnStack)
   684|     {
   685|         delete [] arrObjRef;
   686|     }
   687|     return (pProfilerWalkHeapContext->fProfilerPinned) ? SUCCEEDED(hr) : TRUE;
   688| }
   689| #endif // defined(GC_PROFILING) || defined(FEATURE_EVENT_TRACING)
   690| #ifdef PROFILING_SUPPORTED
   691| bool AllocByClassHelper(Object * pBO, void * pv)
   692| {
   693|     CONTRACTL
   694|     {
   695|         NOTHROW;
   696|         GC_NOTRIGGER;
   697|         MODE_ANY;
   698|     }
   699|     CONTRACTL_END;
   700|     _ASSERTE(pv != NULL);
   701|     {
   702|         BEGIN_PROFILER_CALLBACK(CORProfilerTrackAllocations());
   703|         g_profControlBlock.AllocByClass(
   704|             (ObjectID) pBO,
   705|             SafeGetClassIDFromObject(pBO),
   706|             pv);
   707|         END_PROFILER_CALLBACK();
   708|     }
   709|     return TRUE;
   710| }
   711| #endif // PROFILING_SUPPORTED
   712| #if defined(GC_PROFILING) || defined(FEATURE_EVENT_TRACE)
   713| void ScanRootsHelper(Object* pObj, Object ** ppRoot, ScanContext *pSC, uint32_t dwFlags)
   714| {
   715|     CONTRACTL
   716|     {
   717|         NOTHROW;
   718|         GC_NOTRIGGER;
   719|         MODE_ANY;
   720|     }
   721|     CONTRACTL_END;
   722|     FAULT_NOT_FATAL();


# ====================================================================
# FILE: src/coreclr/vm/syncblk.h
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 371-410 ---
   371| class ComCallWrapper;
   372| class ComClassFactory;
   373| struct RCW;
   374| class RCWHolder;
   375| typedef DPTR(class ComCallWrapper)        PTR_ComCallWrapper;
   376| #include "shash.h"
   377| #endif // FEATURE_COMINTEROP
   378| using ManagedObjectComWrapperByIdMap = MapSHash<INT64, void*>;
   379| class InteropSyncBlockInfo
   380| {
   381|     friend class RCWHolder;
   382|     friend class ClrDataAccess;
   383| public:
   384| #ifndef TARGET_UNIX
   385|     static SLIST_HEADER s_InteropInfoStandbyList;
   386| #endif // !TARGET_UNIX
   387|     InteropSyncBlockInfo()
   388|     {
   389|         LIMITED_METHOD_CONTRACT;
   390|         ZeroMemory(this, sizeof(InteropSyncBlockInfo));
   391|     }
   392| #ifndef DACCESS_COMPILE
   393|     ~InteropSyncBlockInfo();
   394| #endif
   395| #ifndef TARGET_UNIX
   396|     static void FlushStandbyList();
   397| #endif // !TARGET_UNIX
   398| #ifdef FEATURE_COMINTEROP
   399| #ifndef DACCESS_COMPILE
   400|     RCW* GetRawRCW()
   401|     {
   402|         LIMITED_METHOD_CONTRACT;
   403|         return (RCW *)((size_t)m_pRCW & ~1);
   404|     }
   405|     RCW* GetRCWAndIncrementUseCount();
   406|     void SetRawRCW(RCW* pRCW);
   407|     bool RCWWasUsed()
   408|     {
   409|         LIMITED_METHOD_CONTRACT;
   410|         return (m_pRCW != NULL);

# --- HUNK 2: Lines 495-535 ---
   495| public:
   496|     bool TryGetManagedObjectComWrapper(_In_ INT64 wrapperId, _Out_ void** mocw)
   497|     {
   498|         LIMITED_METHOD_DAC_CONTRACT;
   499|         *mocw = NULL;
   500|         if (m_managedObjectComWrapperMap == NULL)
   501|             return false;
   502|         CrstHolder lock(&m_managedObjectComWrapperLock);
   503|         return m_managedObjectComWrapperMap->Lookup(wrapperId, mocw);
   504|     }
   505| #ifndef DACCESS_COMPILE
   506|     bool TrySetManagedObjectComWrapper(_In_ INT64 wrapperId, _In_ void* mocw, _In_ void* curr = NULL)
   507|     {
   508|         LIMITED_METHOD_CONTRACT;
   509|         if (m_managedObjectComWrapperMap == NULL)
   510|         {
   511|             NewHolder<ManagedObjectComWrapperByIdMap> map = new ManagedObjectComWrapperByIdMap();
   512|             if (FastInterlockCompareExchangePointer((ManagedObjectComWrapperByIdMap**)&m_managedObjectComWrapperMap, (ManagedObjectComWrapperByIdMap *)map, NULL) == NULL)
   513|             {
   514|                 map.SuppressRelease();
   515|                 m_managedObjectComWrapperLock.Init(CrstManagedObjectWrapperMap, CRST_UNSAFE_COOPGC);
   516|             }
   517|             _ASSERTE(m_managedObjectComWrapperMap != NULL);
   518|         }
   519|         CrstHolder lock(&m_managedObjectComWrapperLock);
   520|         if (m_managedObjectComWrapperMap->LookupPtr(wrapperId) != curr)
   521|             return false;
   522|         m_managedObjectComWrapperMap->Add(wrapperId, mocw);
   523|         return true;
   524|     }
   525|     using ClearWrappersCallback = void(void* mocw);
   526|     void ClearManagedObjectComWrappers(ClearWrappersCallback* callback)
   527|     {
   528|         LIMITED_METHOD_CONTRACT;
   529|         if (m_managedObjectComWrapperMap == NULL)
   530|             return;
   531|         CQuickArrayList<void*> localList;
   532|         {
   533|             CrstHolder lock(&m_managedObjectComWrapperLock);
   534|             if (callback != NULL)
   535|             {


# ====================================================================
# FILE: src/libraries/Common/src/Interop/OSX/Interop.libproc.cs
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-36 ---
     1| using System;
     2| using System.Collections.Generic;
     3| using System.ComponentModel;
     4| using System.Diagnostics;
     5| using System.Runtime.InteropServices;
     6| #pragma warning disable CA1823 // analyzer incorrectly flags fixed buffer length const (https://github.com/dotnet/roslyn/issues/37593)
     7| internal static partial class Interop
     8| {
     9|     internal static partial class libproc
    10|     {
    11|         private const int MAXPATHLEN = 1024;
    12|         private const int MAXTHREADNAMESIZE = 64;
    13|         private const int PROC_PIDTHREADINFO = 5;
    14|         private const int PROC_PIDLISTTHREADS = 6;
    15|         private const int PROC_PIDPATHINFO_MAXSIZE = 4 * MAXPATHLEN;
    16|         private const int RUSAGE_INFO_V3 = 3;
    17|         internal enum ThreadRunState
    18|         {
    19|             TH_STATE_RUNNING            = 1,
    20|             TH_STATE_STOPPED            = 2,
    21|             TH_STATE_WAITING            = 3,
    22|             TH_STATE_UNINTERRUPTIBLE    = 4,
    23|             TH_STATE_HALTED             = 5
    24|         }
    25|         [Flags]
    26|         internal enum ThreadFlags
    27|         {
    28|             TH_FLAGS_SWAPPED    = 0x1,
    29|             TH_FLAGS_IDLE       = 0x2
    30|         }
    31|         [StructLayout(LayoutKind.Sequential)]
    32|         internal unsafe struct rusage_info_v3
    33|         {
    34|             internal fixed byte     ri_uuid[16];
    35|             internal ulong          ri_user_time;
    36|             internal ulong          ri_system_time;

# --- HUNK 2: Lines 71-111 ---
    71|             internal int        pth_flags;
    72|             internal int        pth_sleep_time;
    73|             internal int        pth_curpri;
    74|             internal int        pth_priority;
    75|             internal int        pth_maxpriority;
    76|             internal fixed byte pth_name[MAXTHREADNAMESIZE];
    77|         }
    78|         [StructLayout(LayoutKind.Sequential)]
    79|         internal struct proc_fdinfo
    80|         {
    81|             internal int proc_fd;
    82|             internal uint proc_fdtype;
    83|         }
    84|         [DllImport(Interop.Libraries.libproc, SetLastError = true)]
    85|         private static extern unsafe int proc_listallpids(
    86|             int*    pBuffer,
    87|             int     buffersize);
    88|         internal static unsafe int[] proc_listallpids()
    89|         {
    90|             int numProcesses = proc_listallpids(null, 0);
    91|             if (numProcesses <= 0)
    92|             {
    93|                 throw new Win32Exception(SR.CantGetAllPids);
    94|             }
    95|             int[] processes;
    96|             do
    97|             {
    98|                 processes = new int[(int)(numProcesses * 1.10)];
    99|                 fixed (int* pBuffer = &processes[0])
   100|                 {
   101|                     numProcesses = proc_listallpids(pBuffer, processes.Length * sizeof(int));
   102|                     if (numProcesses <= 0)
   103|                     {
   104|                         throw new Win32Exception(SR.CantGetAllPids);
   105|                     }
   106|                 }
   107|             }
   108|             while (numProcesses == processes.Length);
   109|             Array.Resize<int>(ref processes, numProcesses);
   110|             return processes;
   111|         }


# ====================================================================
# FILE: src/libraries/Common/src/Interop/Unix/System.Security.Cryptography.Native/Interop.EvpPkey.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 65-113 ---
    65|         internal static unsafe SafeEvpPKeyHandle DecodePkcs8PrivateKey(
    66|             ReadOnlySpan<byte> source,
    67|             EvpAlgorithmId algorithmId)
    68|         {
    69|             SafeEvpPKeyHandle handle;
    70|             fixed (byte* sourcePtr = source)
    71|             {
    72|                 handle = CryptoNative_DecodePkcs8PrivateKey(
    73|                     sourcePtr,
    74|                     source.Length,
    75|                     (int)algorithmId);
    76|             }
    77|             if (handle.IsInvalid)
    78|             {
    79|                 handle.Dispose();
    80|                 throw CreateOpenSslCryptographicException();
    81|             }
    82|             return handle;
    83|         }
    84|         [DllImport(Libraries.CryptoNative)]
    85|         private static extern int CryptoNative_GetPkcs8PrivateKeySize(IntPtr pkey);
    86|         private static int GetPkcs8PrivateKeySize(IntPtr pkey)
    87|         {
    88|             int ret = CryptoNative_GetPkcs8PrivateKeySize(pkey);
    89|             if (ret < 0)
    90|             {
    91|                 throw CreateOpenSslCryptographicException();
    92|             }
    93|             return ret;
    94|         }
    95|         [DllImport(Libraries.CryptoNative)]
    96|         private static extern unsafe int CryptoNative_EncodePkcs8PrivateKey(IntPtr pkey, byte* buf);
    97|         internal static ArraySegment<byte> RentEncodePkcs8PrivateKey(SafeEvpPKeyHandle pkey)
    98|         {
    99|             bool addedRef = false;
   100|             try
   101|             {
   102|                 pkey.DangerousAddRef(ref addedRef);
   103|                 IntPtr handle = pkey.DangerousGetHandle();
   104|                 int size = GetPkcs8PrivateKeySize(handle);
   105|                 byte[] rented = CryptoPool.Rent(size);
   106|                 int written;
   107|                 unsafe
   108|                 {
   109|                     fixed (byte* buf = rented)
   110|                     {
   111|                         written = CryptoNative_EncodePkcs8PrivateKey(handle, buf);
   112|                     }
   113|                 }


# ====================================================================
# FILE: src/libraries/Common/src/Interop/Unix/System.Security.Cryptography.Native/Interop.OpenSsl.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 27-67 ---
    27|             {
    28|                 case ChannelBindingKind.Unique:
    29|                     bindingHandle = new SafeChannelBindingHandle(bindingType);
    30|                     QueryUniqueChannelBinding(context, bindingHandle);
    31|                     break;
    32|                 default:
    33|                     bindingHandle = null;
    34|                     break;
    35|             }
    36|             return bindingHandle;
    37|         }
    38|         internal static SafeSslHandle AllocateSslContext(SslProtocols protocols, SafeX509Handle? certHandle, SafeEvpPKeyHandle? certKeyHandle, EncryptionPolicy policy, SslAuthenticationOptions sslAuthenticationOptions)
    39|         {
    40|             SafeSslHandle? context = null;
    41|             using (SafeSslContextHandle innerContext = Ssl.SslCtxCreate(Ssl.SslMethods.SSLv23_method))
    42|             {
    43|                 if (innerContext.IsInvalid)
    44|                 {
    45|                     throw CreateSslException(SR.net_allocate_ssl_context_failed);
    46|                 }
    47|                 if (!Interop.Ssl.Tls13Supported)
    48|                 {
    49|                     if (protocols != SslProtocols.None &&
    50|                         CipherSuitesPolicyPal.WantsTls13(protocols))
    51|                     {
    52|                         protocols = protocols & (~SslProtocols.Tls13);
    53|                     }
    54|                 }
    55|                 else if (CipherSuitesPolicyPal.WantsTls13(protocols) &&
    56|                     CipherSuitesPolicyPal.ShouldOptOutOfTls13(sslAuthenticationOptions.CipherSuitesPolicy, policy))
    57|                 {
    58|                     if (protocols == SslProtocols.None)
    59|                     {
    60|                         protocols = SslProtocols.Tls | SslProtocols.Tls11 | SslProtocols.Tls12;
    61|                     }
    62|                     else
    63|                     {
    64|                         throw new SslException(
    65|                             SR.Format(SR.net_ssl_encryptionpolicy_notsupported, policy));
    66|                     }
    67|                 }


# ====================================================================
# FILE: src/libraries/Common/src/Interop/Unix/System.Security.Cryptography.Native/Interop.Ssl.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 82-124 ---
    82|         internal static extern int SslGetFinished(SafeSslHandle ssl, IntPtr buf, int count);
    83|         [DllImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSessionReused")]
    84|         [return: MarshalAs(UnmanagedType.Bool)]
    85|         internal static extern bool SslSessionReused(SafeSslHandle ssl);
    86|         [DllImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslAddExtraChainCert")]
    87|         internal static extern bool SslAddExtraChainCert(SafeSslHandle ssl, SafeX509Handle x509);
    88|         [DllImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetClientCAList")]
    89|         private static extern SafeSharedX509NameStackHandle SslGetClientCAList_private(SafeSslHandle ssl);
    90|         [DllImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetCurrentCipherId")]
    91|         [return: MarshalAs(UnmanagedType.Bool)]
    92|         internal static extern bool SslGetCurrentCipherId(SafeSslHandle ssl, out int cipherId);
    93|         [DllImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_GetOpenSslCipherSuiteName")]
    94|         private static extern IntPtr GetOpenSslCipherSuiteName(SafeSslHandle ssl, int cipherSuite, out int isTls12OrLower);
    95|         internal static string? GetOpenSslCipherSuiteName(SafeSslHandle ssl, TlsCipherSuite cipherSuite, out bool isTls12OrLower)
    96|         {
    97|             string? ret = Marshal.PtrToStringAnsi(GetOpenSslCipherSuiteName(ssl, (int)cipherSuite, out int isTls12OrLowerInt));
    98|             isTls12OrLower = isTls12OrLowerInt != 0;
    99|             return ret;
   100|         }
   101|         [DllImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_Tls13Supported")]
   102|         [return: MarshalAs(UnmanagedType.Bool)]
   103|         private static extern bool Tls13SupportedImpl();
   104|         internal static readonly bool Tls13Supported = Tls13SupportedImpl();
   105|         internal static SafeSharedX509NameStackHandle SslGetClientCAList(SafeSslHandle ssl)
   106|         {
   107|             Crypto.CheckValidOpenSslHandle(ssl);
   108|             SafeSharedX509NameStackHandle handle = SslGetClientCAList_private(ssl);
   109|             if (!handle.IsInvalid)
   110|             {
   111|                 handle.SetParent(ssl);
   112|             }
   113|             return handle;
   114|         }
   115|         internal static bool AddExtraChainCertificates(SafeSslHandle sslContext, X509Chain chain)
   116|         {
   117|             Debug.Assert(chain != null, "X509Chain should not be null");
   118|             Debug.Assert(chain.ChainElements.Count > 0, "chain.Build should have already been called");
   119|             int stop = chain.ChainElements.Count - 1;
   120|             foreach (X509ChainStatus s in chain.ChainStatus)
   121|             {
   122|                 if ((s.Status & X509ChainStatusFlags.PartialChain) != 0)
   123|                 {
   124|                     stop++;


# ====================================================================
# FILE: src/libraries/Microsoft.Extensions.Configuration/src/ConfigurationManager.cs
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-152 ---
     1| using System;
     2| using System.Collections;
     3| using System.Collections.Generic;
     4| using System.Linq;
     5| using System.Threading;
     6| using Microsoft.Extensions.Primitives;
     7| namespace Microsoft.Extensions.Configuration
     8| {
     9|     public sealed class ConfigurationManager : IConfigurationBuilder, IConfigurationRoot, IDisposable
    10|     {
    11|         private readonly ConfigurationSources _sources;
    12|         private readonly ConfigurationBuilderProperties _properties;
    13|         private readonly object _providerLock = new();
    14|         private readonly List<IConfigurationProvider> _providers = new();
    15|         private readonly List<IDisposable> _changeTokenRegistrations = new();
    16|         private ConfigurationReloadToken _changeToken = new();
    17|         public ConfigurationManager()
    18|         {
    19|             _sources = new ConfigurationSources(this);
    20|             _properties = new ConfigurationBuilderProperties(this);
    21|             this.AddInMemoryCollection();
    22|             AddSource(_sources[0]);
    23|         }
    24|         public string this[string key]
    25|         {
    26|             get
    27|             {
    28|                 lock (_providerLock)
    29|                 {
    30|                     return ConfigurationRoot.GetConfiguration(_providers, key);
    31|                 }
    32|             }
    33|             set
    34|             {
    35|                 lock (_providerLock)
    36|                 {
    37|                     ConfigurationRoot.SetConfiguration(_providers, key, value);
    38|                 }
    39|             }
    40|         }
    41|         public IConfigurationSection GetSection(string key) => new ConfigurationSection(this, key);
    42|         public IEnumerable<IConfigurationSection> GetChildren()
    43|         {
    44|             lock (_providerLock)
    45|             {
    46|                 return this.GetChildrenImplementation(null).ToList();
    47|             }
    48|         }
    49|         IDictionary<string, object> IConfigurationBuilder.Properties => _properties;
    50|         IList<IConfigurationSource> IConfigurationBuilder.Sources => _sources;
    51|         IEnumerable<IConfigurationProvider> IConfigurationRoot.Providers
    52|         {
    53|             get
    54|             {
    55|                 lock (_providerLock)
    56|                 {
    57|                     return new List<IConfigurationProvider>(_providers);
    58|                 }
    59|             }
    60|         }
    61|         public void Dispose()
    62|         {
    63|             lock (_providerLock)
    64|             {
    65|                 DisposeRegistrationsAndProvidersUnsynchronized();
    66|             }
    67|         }
    68|         IConfigurationBuilder IConfigurationBuilder.Add(IConfigurationSource source)
    69|         {
    70|             _sources.Add(source ?? throw new ArgumentNullException(nameof(source)));
    71|             return this;
    72|         }
    73|         IConfigurationRoot IConfigurationBuilder.Build() => this;
    74|         IChangeToken IConfiguration.GetReloadToken() => _changeToken;
    75|         void IConfigurationRoot.Reload()
    76|         {
    77|             lock (_providerLock)
    78|             {
    79|                 foreach (var provider in _providers)
    80|                 {
    81|                     provider.Load();
    82|                 }
    83|             }
    84|             RaiseChanged();
    85|         }
    86|         private void RaiseChanged()
    87|         {
    88|             var previousToken = Interlocked.Exchange(ref _changeToken, new ConfigurationReloadToken());
    89|             previousToken.OnReload();
    90|         }
    91|         private void AddSource(IConfigurationSource source)
    92|         {
    93|             lock (_providerLock)
    94|             {
    95|                 var provider = source.Build(this);
    96|                 _providers.Add(provider);
    97|                 provider.Load();
    98|                 _changeTokenRegistrations.Add(ChangeToken.OnChange(() => provider.GetReloadToken(), () => RaiseChanged()));
    99|             }
   100|             RaiseChanged();
   101|         }
   102|         private void ReloadSources()
   103|         {
   104|             lock (_providerLock)
   105|             {
   106|                 DisposeRegistrationsAndProvidersUnsynchronized();
   107|                 _changeTokenRegistrations.Clear();
   108|                 _providers.Clear();
   109|                 foreach (var source in _sources)
   110|                 {
   111|                     _providers.Add(source.Build(this));
   112|                 }
   113|                 foreach (var p in _providers)
   114|                 {
   115|                     p.Load();
   116|                     _changeTokenRegistrations.Add(ChangeToken.OnChange(() => p.GetReloadToken(), () => RaiseChanged()));
   117|                 }
   118|             }
   119|             RaiseChanged();
   120|         }
   121|         private void DisposeRegistrationsAndProvidersUnsynchronized()
   122|         {
   123|             foreach (var registration in _changeTokenRegistrations)
   124|             {
   125|                 registration.Dispose();
   126|             }
   127|             foreach (var provider in _providers)
   128|             {
   129|                 (provider as IDisposable)?.Dispose();
   130|             }
   131|         }
   132|         private class ConfigurationSources : IList<IConfigurationSource>
   133|         {
   134|             private readonly List<IConfigurationSource> _sources = new();
   135|             private readonly ConfigurationManager _config;
   136|             public ConfigurationSources(ConfigurationManager config)
   137|             {
   138|                 _config = config;
   139|             }
   140|             public IConfigurationSource this[int index]
   141|             {
   142|                 get => _sources[index];
   143|                 set
   144|                 {
   145|                     _sources[index] = value;
   146|                     _config.ReloadSources();
   147|                 }
   148|             }
   149|             public int Count => _sources.Count;
   150|             public bool IsReadOnly => false;
   151|             public void Add(IConfigurationSource source)
   152|             {

# --- HUNK 2: Lines 178-218 ---
   178|             {
   179|                 _sources.Insert(index, source);
   180|                 _config.ReloadSources();
   181|             }
   182|             public bool Remove(IConfigurationSource source)
   183|             {
   184|                 var removed = _sources.Remove(source);
   185|                 _config.ReloadSources();
   186|                 return removed;
   187|             }
   188|             public void RemoveAt(int index)
   189|             {
   190|                 _sources.RemoveAt(index);
   191|                 _config.ReloadSources();
   192|             }
   193|             IEnumerator IEnumerable.GetEnumerator()
   194|             {
   195|                 return GetEnumerator();
   196|             }
   197|         }
   198|         private class ConfigurationBuilderProperties : IDictionary<string, object>
   199|         {
   200|             private readonly Dictionary<string, object> _properties = new();
   201|             private readonly ConfigurationManager _config;
   202|             public ConfigurationBuilderProperties(ConfigurationManager config)
   203|             {
   204|                 _config = config;
   205|             }
   206|             public object this[string key]
   207|             {
   208|                 get => _properties[key];
   209|                 set
   210|                 {
   211|                     _properties[key] = value;
   212|                     _config.ReloadSources();
   213|                 }
   214|             }
   215|             public ICollection<string> Keys => _properties.Keys;
   216|             public ICollection<object> Values => _properties.Values;
   217|             public int Count => _properties.Count;
   218|             public bool IsReadOnly => false;


# ====================================================================
# FILE: src/libraries/Microsoft.Extensions.Configuration/src/InternalConfigurationRootExtensions.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-17 ---
     1| using System;
     2| using System.Collections.Generic;
     3| using System.Linq;
     4| namespace Microsoft.Extensions.Configuration
     5| {
     6|     internal static class InternalConfigurationRootExtensions
     7|     {
     8|         internal static IEnumerable<IConfigurationSection> GetChildrenImplementation(this IConfigurationRoot root, string path)
     9|         {
    10|             return root.Providers
    11|                 .Aggregate(Enumerable.Empty<string>(),
    12|                     (seed, source) => source.GetChildKeys(seed, path))
    13|                 .Distinct(StringComparer.OrdinalIgnoreCase)
    14|                 .Select(key => root.GetSection(path == null ? key : ConfigurationPath.Combine(path, key)));
    15|         }
    16|     }
    17| }


# ====================================================================
# FILE: src/libraries/Microsoft.Extensions.Logging.Abstractions/gen/LoggerMessageGenerator.Emitter.cs
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 44-95 ---
    44|                         {
    45|                             return false;
    46|                         }
    47|                     }
    48|                 }
    49|                 return result;
    50|             }
    51|             private void GenType(LoggerClass lc)
    52|             {
    53|                 string nestedIndentation = "";
    54|                 if (!string.IsNullOrWhiteSpace(lc.Namespace))
    55|                 {
    56|                     _builder.Append($@"
    57| namespace {lc.Namespace}
    58| {{");
    59|                 }
    60|                 LoggerClass parent = lc.ParentClass;
    61|                 var parentClasses = new List<string>();
    62|                 while (parent != null)
    63|                 {
    64|                     parentClasses.Add($"partial {parent.Keyword} {parent.Name} {parent.Constraints}");
    65|                     parent = parent.ParentClass;
    66|                 }
    67|                 for (int i = parentClasses.Count - 1; i >= 0; i--)
    68|                 {
    69|                     _builder.Append($@"
    70|     {nestedIndentation}{parentClasses[i]}
    71|     {nestedIndentation}{{");
    72|                     nestedIndentation += "    ";
    73|                 }
    74|                 _builder.Append($@"
    75|     {nestedIndentation}partial {lc.Keyword} {lc.Name} {lc.Constraints}
    76|     {nestedIndentation}{{");
    77|                 foreach (LoggerMethod lm in lc.Methods)
    78|                 {
    79|                     if (!UseLoggerMessageDefine(lm))
    80|                     {
    81|                         GenStruct(lm, nestedIndentation);
    82|                     }
    83|                     GenLogMethod(lm, nestedIndentation);
    84|                 }
    85|                 _builder.Append($@"
    86|     {nestedIndentation}}}");
    87|                 parent = lc.ParentClass;
    88|                 while (parent != null)
    89|                 {
    90|                     nestedIndentation = new String(' ', nestedIndentation.Length - 4);
    91|                     _builder.Append($@"
    92|     {nestedIndentation}}}");
    93|                     parent = parent.ParentClass;
    94|                 }
    95|                 if (!string.IsNullOrWhiteSpace(lc.Namespace))

# --- HUNK 2: Lines 145-185 ---
   145|                 {nestedIndentation}for (int i = 0; i < {lm.TemplateParameters.Count + 1}; i++)
   146|                 {nestedIndentation}{{
   147|                     {nestedIndentation}yield return this[i];
   148|                 {nestedIndentation}}}
   149|             {nestedIndentation}}}
   150|             {nestedIndentation}global::System.Collections.IEnumerator global::System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();
   151|         {nestedIndentation}}}
   152| ");
   153|             }
   154|             private void GenFields(LoggerMethod lm, string nestedIndentation)
   155|             {
   156|                 foreach (LoggerParameter p in lm.TemplateParameters)
   157|                 {
   158|                     _builder.AppendLine($"            {nestedIndentation}private readonly {p.Type} _{p.Name};");
   159|                 }
   160|             }
   161|             private void GenFieldAssignments(LoggerMethod lm, string nestedIndentation)
   162|             {
   163|                 foreach (LoggerParameter p in lm.TemplateParameters)
   164|                 {
   165|                     _builder.AppendLine($"                {nestedIndentation}this._{p.Name} = {p.Name};");
   166|                 }
   167|             }
   168|             private void GenVariableAssignments(LoggerMethod lm, string nestedIndentation)
   169|             {
   170|                 foreach (KeyValuePair<string, string> t in lm.TemplateMap)
   171|                 {
   172|                     int index = 0;
   173|                     foreach (LoggerParameter p in lm.TemplateParameters)
   174|                     {
   175|                         if (t.Key.Equals(p.Name, System.StringComparison.OrdinalIgnoreCase))
   176|                         {
   177|                             break;
   178|                         }
   179|                         index++;
   180|                     }
   181|                     if (index < lm.TemplateParameters.Count)
   182|                     {
   183|                         if (lm.TemplateParameters[index].IsEnumerable)
   184|                         {
   185|                             _builder.AppendLine($"                {nestedIndentation}var {t.Key} = "

# --- HUNK 3: Lines 194-234 ---
   194|                 }
   195|             }
   196|             private void GenCases(LoggerMethod lm, string nestedIndentation)
   197|             {
   198|                 int index = 0;
   199|                 foreach (LoggerParameter p in lm.TemplateParameters)
   200|                 {
   201|                     string name = p.Name;
   202|                     if (lm.TemplateMap.ContainsKey(name))
   203|                     {
   204|                         name = lm.TemplateMap[name];
   205|                     }
   206|                     _builder.AppendLine($"                    {nestedIndentation}{index++} => new global::System.Collections.Generic.KeyValuePair<string, object?>(\"{name}\", this._{p.Name}),");
   207|                 }
   208|                 _builder.AppendLine($"                    {nestedIndentation}{index++} => new global::System.Collections.Generic.KeyValuePair<string, object?>(\"{{OriginalFormat}}\", \"{ConvertEndOfLineAndQuotationCharactersToEscapeForm(lm.Message)}\"),");
   209|             }
   210|             private void GenCallbackArguments(LoggerMethod lm)
   211|             {
   212|                 foreach (LoggerParameter p in lm.TemplateParameters)
   213|                 {
   214|                     _builder.Append($"{p.Name}, ");
   215|                 }
   216|             }
   217|             private void GenDefineTypes(LoggerMethod lm, bool brackets)
   218|             {
   219|                 if (lm.TemplateParameters.Count == 0)
   220|                 {
   221|                     return;
   222|                 }
   223|                 if (brackets)
   224|                 {
   225|                     _builder.Append('<');
   226|                 }
   227|                 bool firstItem = true;
   228|                 foreach (LoggerParameter p in lm.TemplateParameters)
   229|                 {
   230|                     if (firstItem)
   231|                     {
   232|                         firstItem = false;
   233|                     }
   234|                     else

# --- HUNK 4: Lines 242-311 ---
   242|                     _builder.Append('>');
   243|                 }
   244|                 else
   245|                 {
   246|                     _builder.Append(", ");
   247|                 }
   248|             }
   249|             private void GenParameters(LoggerMethod lm)
   250|             {
   251|                 bool firstItem = true;
   252|                 foreach (LoggerParameter p in lm.AllParameters)
   253|                 {
   254|                     if (firstItem)
   255|                     {
   256|                         firstItem = false;
   257|                     }
   258|                     else
   259|                     {
   260|                         _builder.Append(", ");
   261|                     }
   262|                     _builder.Append($"{p.Type} {p.Name}");
   263|                 }
   264|             }
   265|             private void GenArguments(LoggerMethod lm)
   266|             {
   267|                 bool firstItem = true;
   268|                 foreach (LoggerParameter p in lm.TemplateParameters)
   269|                 {
   270|                     if (firstItem)
   271|                     {
   272|                         firstItem = false;
   273|                     }
   274|                     else
   275|                     {
   276|                         _builder.Append(", ");
   277|                     }
   278|                     _builder.Append($"{p.Type} {p.Name}");
   279|                 }
   280|             }
   281|             private void GenHolder(LoggerMethod lm)
   282|             {
   283|                 string typeName = $"__{lm.Name}Struct";
   284|                 _builder.Append($"new {typeName}(");
   285|                 foreach (LoggerParameter p in lm.TemplateParameters)
   286|                 {
   287|                     if (p != lm.TemplateParameters[0])
   288|                     {
   289|                         _builder.Append(", ");
   290|                     }
   291|                     _builder.Append(p.Name);
   292|                 }
   293|                 _builder.Append(')');
   294|             }
   295|             private void GenLogMethod(LoggerMethod lm, string nestedIndentation)
   296|             {
   297|                 string level = GetLogLevel(lm);
   298|                 string extension = lm.IsExtensionMethod ? "this " : string.Empty;
   299|                 string eventName = string.IsNullOrWhiteSpace(lm.EventName) ? $"nameof({lm.Name})" : $"\"{lm.EventName}\"";
   300|                 string exceptionArg = GetException(lm);
   301|                 string logger = GetLogger(lm);
   302|                 if (UseLoggerMessageDefine(lm))
   303|                 {
   304|                     _builder.Append($@"
   305|         {nestedIndentation}[{s_generatedCodeAttribute}]
   306|         {nestedIndentation}private static readonly global::System.Action<global::Microsoft.Extensions.Logging.ILogger, ");
   307|                     GenDefineTypes(lm, brackets: false);
   308|                     _builder.Append($@"global::System.Exception?> __{lm.Name}Callback =
   309|             {nestedIndentation}global::Microsoft.Extensions.Logging.LoggerMessage.Define");
   310|                     GenDefineTypes(lm, brackets: true);
   311|                     _builder.Append(@$"({level}, new global::Microsoft.Extensions.Logging.EventId({lm.EventId}, {eventName}), ""{ConvertEndOfLineAndQuotationCharactersToEscapeForm(lm.Message)}"", new global::Microsoft.Extensions.Logging.LogDefineOptions() {{ SkipEnabledCheck = true }}); 


# ====================================================================
# FILE: src/libraries/Microsoft.Extensions.Logging.Abstractions/gen/LoggerMessageGenerator.Parser.cs
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 230-287 ---
   230|                                         else
   231|                                         {
   232|                                             _ = ids.Add(lm.EventId);
   233|                                         }
   234|                                         string msg = lm.Message;
   235|                                         if (msg.StartsWith("INFORMATION:", StringComparison.OrdinalIgnoreCase)
   236|                                             || msg.StartsWith("INFO:", StringComparison.OrdinalIgnoreCase)
   237|                                             || msg.StartsWith("WARNING:", StringComparison.OrdinalIgnoreCase)
   238|                                             || msg.StartsWith("WARN:", StringComparison.OrdinalIgnoreCase)
   239|                                             || msg.StartsWith("ERROR:", StringComparison.OrdinalIgnoreCase)
   240|                                             || msg.StartsWith("ERR:", StringComparison.OrdinalIgnoreCase))
   241|                                         {
   242|                                             Diag(DiagnosticDescriptors.RedundantQualifierInMessage, ma.GetLocation(), method.Identifier.ToString());
   243|                                         }
   244|                                         bool foundLogger = false;
   245|                                         bool foundException = false;
   246|                                         bool foundLogLevel = level != null;
   247|                                         foreach (IParameterSymbol paramSymbol in methodSymbol.Parameters)
   248|                                         {
   249|                                             string paramName = paramSymbol.Name;
   250|                                             if (string.IsNullOrWhiteSpace(paramName))
   251|                                             {
   252|                                                 keepMethod = false;
   253|                                                 break;
   254|                                             }
   255|                                             ITypeSymbol paramTypeSymbol = paramSymbol!.Type;
   256|                                             if (paramTypeSymbol is IErrorTypeSymbol)
   257|                                             {
   258|                                                 keepMethod = false;
   259|                                                 break;
   260|                                             }
   261|                                             string typeName = paramTypeSymbol.ToDisplayString(
   262|                                                 SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(
   263|                                                     SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
   264|                                             var lp = new LoggerParameter
   265|                                             {
   266|                                                 Name = paramName,
   267|                                                 Type = typeName,
   268|                                                 IsLogger = !foundLogger && IsBaseOrIdentity(paramTypeSymbol!, loggerSymbol),
   269|                                                 IsException = !foundException && IsBaseOrIdentity(paramTypeSymbol!, exceptionSymbol),
   270|                                                 IsLogLevel = !foundLogLevel && IsBaseOrIdentity(paramTypeSymbol!, logLevelSymbol),
   271|                                                 IsEnumerable = IsBaseOrIdentity(paramTypeSymbol!, enumerableSymbol) && !IsBaseOrIdentity(paramTypeSymbol!, stringSymbol),
   272|                                             };
   273|                                             foundLogger |= lp.IsLogger;
   274|                                             foundException |= lp.IsException;
   275|                                             foundLogLevel |= lp.IsLogLevel;
   276|                                             if (lp.IsLogger && lm.TemplateMap.ContainsKey(paramName))
   277|                                             {
   278|                                                 Diag(DiagnosticDescriptors.ShouldntMentionLoggerInMessage, paramSymbol.Locations[0], paramName);
   279|                                             }
   280|                                             else if (lp.IsException && lm.TemplateMap.ContainsKey(paramName))
   281|                                             {
   282|                                                 Diag(DiagnosticDescriptors.ShouldntMentionExceptionInMessage, paramSymbol.Locations[0], paramName);
   283|                                             }
   284|                                             else if (lp.IsLogLevel && lm.TemplateMap.ContainsKey(paramName))
   285|                                             {
   286|                                                 Diag(DiagnosticDescriptors.ShouldntMentionLogLevelInMessage, paramSymbol.Locations[0], paramName);
   287|                                             }

# --- HUNK 2: Lines 377-433 ---
   377|                                             {
   378|                                                 nspace = namespaceParent.Name.ToString();
   379|                                                 while (true)
   380|                                                 {
   381|                                                     namespaceParent = namespaceParent.Parent as NamespaceDeclarationSyntax;
   382|                                                     if (namespaceParent == null)
   383|                                                     {
   384|                                                         break;
   385|                                                     }
   386|                                                     nspace = $"{namespaceParent.Name}.{nspace}";
   387|                                                 }
   388|                                             }
   389|                                         }
   390|                                         if (keepMethod)
   391|                                         {
   392|                                             lc ??= new LoggerClass
   393|                                             {
   394|                                                 Keyword = classDec.Keyword.ValueText,
   395|                                                 Namespace = nspace,
   396|                                                 Name = classDec.Identifier.ToString() + classDec.TypeParameterList,
   397|                                                 Constraints = classDec.ConstraintClauses.ToString(),
   398|                                                 ParentClass = null,
   399|                                             };
   400|                                             LoggerClass currentLoggerClass = lc;
   401|                                             var parentLoggerClass = (classDec.Parent as TypeDeclarationSyntax);
   402|                                             bool IsAllowedKind(SyntaxKind kind) =>
   403|                                                 kind == SyntaxKind.ClassDeclaration ||
   404|                                                 kind == SyntaxKind.StructDeclaration ||
   405|                                                 kind == SyntaxKind.RecordDeclaration;
   406|                                             while (parentLoggerClass != null && IsAllowedKind(parentLoggerClass.Kind()))
   407|                                             {
   408|                                                 currentLoggerClass.ParentClass = new LoggerClass
   409|                                                 {
   410|                                                     Keyword = parentLoggerClass.Keyword.ValueText,
   411|                                                     Namespace = nspace,
   412|                                                     Name = parentLoggerClass.Identifier.ToString() + parentLoggerClass.TypeParameterList,
   413|                                                     Constraints = parentLoggerClass.ConstraintClauses.ToString(),
   414|                                                     ParentClass = null,
   415|                                                 };
   416|                                                 currentLoggerClass = currentLoggerClass.ParentClass;
   417|                                                 parentLoggerClass = (parentLoggerClass.Parent as TypeDeclarationSyntax);
   418|                                             }
   419|                                             lc.Methods.Add(lm);
   420|                                         }
   421|                                     }
   422|                                 }
   423|                             }
   424|                         }
   425|                         if (lc != null)
   426|                         {
   427|                             results.Add(lc);
   428|                         }
   429|                     }
   430|                 }
   431|                 return results;
   432|             }
   433|             private (string? loggerField, bool multipleLoggerFields) FindLoggerField(SemanticModel sm, TypeDeclarationSyntax classDec, ITypeSymbol loggerSymbol)

# --- HUNK 3: Lines 542-592 ---
   542|             {
   543|                 Optional<object?> optional = sm.GetConstantValue(expr, _cancellationToken);
   544|                 if (optional.HasValue)
   545|                 {
   546|                     object o = optional.Value;
   547|                     if (o != null)
   548|                     {
   549|                         return o.ToString();
   550|                     }
   551|                 }
   552|                 return string.Empty;
   553|             }
   554|             private static object GetItem(TypedConstant arg) => arg.Kind == TypedConstantKind.Array ? arg.Values : arg.Value;
   555|         }
   556|         internal class LoggerClass
   557|         {
   558|             public readonly List<LoggerMethod> Methods = new ();
   559|             public string Keyword = string.Empty;
   560|             public string Namespace = string.Empty;
   561|             public string Name = string.Empty;
   562|             public string Constraints = string.Empty;
   563|             public LoggerClass? ParentClass;
   564|         }
   565|         internal class LoggerMethod
   566|         {
   567|             public readonly List<LoggerParameter> AllParameters = new ();
   568|             public readonly List<LoggerParameter> TemplateParameters = new ();
   569|             public readonly Dictionary<string, string> TemplateMap = new (StringComparer.OrdinalIgnoreCase);
   570|             public readonly List<string> TemplateList = new ();
   571|             public string Name = string.Empty;
   572|             public string Message = string.Empty;
   573|             public int? Level;
   574|             public int EventId;
   575|             public string? EventName;
   576|             public bool IsExtensionMethod;
   577|             public string Modifiers = string.Empty;
   578|             public string LoggerField = string.Empty;
   579|             public bool SkipEnabledCheck;
   580|         }
   581|         internal class LoggerParameter
   582|         {
   583|             public string Name = string.Empty;
   584|             public string Type = string.Empty;
   585|             public bool IsLogger;
   586|             public bool IsException;
   587|             public bool IsLogLevel;
   588|             public bool IsEnumerable;
   589|             public bool IsTemplateParameter => !IsLogger && !IsException && !IsLogLevel;
   590|         }
   591|     }
   592| }


# ====================================================================
# FILE: src/libraries/Native/AnyOS/zlib/pal_zlib.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| #include <assert.h>
     2| #include <stdlib.h>
     3| #include "pal_zlib.h"
     4| #ifdef  _WIN32
     5|     #define c_static_assert(e) static_assert((e),"")
     6|     #include "../../Windows/System.IO.Compression.Native/zlib/zlib.h"
     7| #else
     8|     #include "pal_utilities.h"
     9|     #include <zlib.h>
    10| #endif
    11| c_static_assert(PAL_Z_NOFLUSH == Z_NO_FLUSH);
    12| c_static_assert(PAL_Z_FINISH == Z_FINISH);
    13| c_static_assert(PAL_Z_OK == Z_OK);
    14| c_static_assert(PAL_Z_STREAMEND == Z_STREAM_END);
    15| c_static_assert(PAL_Z_STREAMERROR == Z_STREAM_ERROR);
    16| c_static_assert(PAL_Z_DATAERROR == Z_DATA_ERROR);
    17| c_static_assert(PAL_Z_MEMERROR == Z_MEM_ERROR);
    18| c_static_assert(PAL_Z_BUFERROR == Z_BUF_ERROR);
    19| c_static_assert(PAL_Z_VERSIONERROR == Z_VERSION_ERROR);
    20| c_static_assert(PAL_Z_NOCOMPRESSION == Z_NO_COMPRESSION);
    21| c_static_assert(PAL_Z_BESTSPEED == Z_BEST_SPEED);
    22| c_static_assert(PAL_Z_DEFAULTCOMPRESSION == Z_DEFAULT_COMPRESSION);
    23| c_static_assert(PAL_Z_DEFAULTSTRATEGY == Z_DEFAULT_STRATEGY);
    24| c_static_assert(PAL_Z_DEFLATED == Z_DEFLATED);
    25| /*


# ====================================================================
# FILE: src/libraries/Native/Unix/System.Native/pal_interfaceaddresses.c
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 1-105 ---
     1| #include "pal_config.h"
     2| #include "pal_interfaceaddresses.h"
     3| #include "pal_maphardwaretype.h"
     4| #include "pal_utilities.h"
     5| #include "pal_safecrt.h"
     6| #include "pal_networking.h"
     7| #include <stdlib.h>
     8| #include <sys/types.h>
     9| #include <assert.h>
    10| #include <ifaddrs.h>
    11| #include <net/if.h>
    12| #include <netinet/in.h>
    13| #include <string.h>
    14| #include <sys/socket.h>
    15| #if HAVE_SYS_SYSCTL_H
    16| #include <sys/sysctl.h>
    17| #endif
    18| #if HAVE_SYS_IOCTL_H
    19| #include <sys/ioctl.h>
    20| #endif
    21| #if HAVE_ETHTOOL_H
    22| #include <linux/ethtool.h>
    23| #include <linux/sockios.h>
    24| #include <arpa/inet.h>
    25| #endif
    26| #if HAVE_NET_IFMEDIA_H
    27| #include <net/if_media.h>
    28| #elif HAVE_IOS_NET_IFMEDIA_H
    29| #include "ios/net/if_media.h"
    30| #endif
    31| #if defined(AF_PACKET)
    32| #include <sys/ioctl.h>
    33| #if HAVE_NETPACKET_PACKET_H
    34| #include <netpacket/packet.h>
    35| #else
    36| #include <linux/if_packet.h>
    37| #endif
    38| #elif defined(AF_LINK)
    39| #include <net/if_dl.h>
    40| #include <net/if_types.h>
    41| #else
    42| #error System must have AF_PACKET or AF_LINK.
    43| #endif
    44| #if HAVE_RT_MSGHDR
    45| #if HAVE_IOS_NET_ROUTE_H
    46| #include "ios/net/route.h"
    47| #else
    48| #include <net/route.h>
    49| #endif
    50| #endif
    51| #if HAVE_GETIFADDRS
    52| static inline uint8_t mask2prefix(uint8_t* mask, int length)
    53| {
    54|     uint8_t len = 0;
    55|     uint8_t* end = mask + length;
    56|     if (mask == NULL)
    57|     {
    58|         return (uint8_t)length * 8;
    59|     }
    60|     while ((mask < end) && (*mask == 0xff))
    61|     {
    62|         len += 8;
    63|         mask++;
    64|     }
    65|     if (mask < end)
    66|     {
    67|         while (*mask)
    68|         {
    69|             len++;
    70|             *mask <<= 1;
    71|         }
    72|     }
    73|     if (len == 0 && length == 4)
    74|     {
    75|         len = 32;
    76|     }
    77|     return len;
    78| }
    79| #endif
    80| int32_t SystemNative_EnumerateInterfaceAddresses(void* context,
    81|                                                IPv4AddressFound onIpv4Found,
    82|                                                IPv6AddressFound onIpv6Found,
    83|                                                LinkLayerAddressFound onLinkLayerFound)
    84| {
    85| #if HAVE_GETIFADDRS
    86|     struct ifaddrs* headAddr;
    87|     if (getifaddrs(&headAddr) == -1)
    88|     {
    89|         return -1;
    90|     }
    91|     for (struct ifaddrs* current = headAddr; current != NULL; current = current->ifa_next)
    92|     {
    93|         if (current->ifa_addr == NULL)
    94|         {
    95|             continue;
    96|         }
    97|         uint32_t interfaceIndex = if_nametoindex(current->ifa_name);
    98|         char actualName[IF_NAMESIZE];
    99|         char* result = if_indextoname(interfaceIndex, actualName);
   100|         if (result == NULL)
   101|         {
   102|             freeifaddrs(headAddr);
   103|             return -1;
   104|         }
   105|         assert(result == actualName);

# --- HUNK 2: Lines 184-224 ---
   184| #endif
   185|                 memcpy_s(&lla.AddressBytes, sizeof_member(LinkLayerAddressInfo, AddressBytes), (uint8_t*)LLADDR(sadl), sadl->sdl_alen);
   186|                 onLinkLayerFound(context, current->ifa_name, &lla);
   187|             }
   188|         }
   189| #endif
   190|     }
   191|     freeifaddrs(headAddr);
   192|     return 0;
   193| #else
   194|     (void)context;
   195|     (void)onIpv4Found;
   196|     (void)onIpv6Found;
   197|     (void)onLinkLayerFound;
   198|     errno = ENOTSUP;
   199|     return -1;
   200| #endif
   201| }
   202| int32_t SystemNative_GetNetworkInterfaces(int32_t * interfaceCount, NetworkInterfaceInfo **interfaceList, int32_t * addressCount, IpAddressInfo **addressList )
   203| {
   204| #if HAVE_GETIFADDRS
   205|     struct ifaddrs* head;   // Pointer to block allocated by getifaddrs().
   206|     struct ifaddrs* ifaddrsEntry;
   207|     IpAddressInfo *ai;
   208|     int count = 0;       // Count of entries returned by getifaddrs().
   209|     int ip4count = 0;    // Total number of IPv4 addresses.
   210|     int ip6count = 0;    // Total number of IPv6 addresses.
   211|     int ifcount = 0;     // Total number of unique network interface.
   212|     int index;
   213|     int socketfd = -1;
   214|     NetworkInterfaceInfo *nii;
   215|     if (getifaddrs(&head) == -1)
   216|     {
   217|         assert(errno != 0);
   218|         return -1;
   219|     }
   220|     ifaddrsEntry = head;
   221|     while (ifaddrsEntry != NULL)
   222|     {
   223|         count ++;
   224|         if (ifaddrsEntry->ifa_addr != NULL && ifaddrsEntry->ifa_addr->sa_family == AF_INET)


# ====================================================================
# FILE: src/libraries/Native/Unix/System.Native/pal_io.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 248-287 ---
   248| }
   249| intptr_t SystemNative_Dup(intptr_t oldfd)
   250| {
   251|     int result;
   252| #if HAVE_F_DUPFD_CLOEXEC
   253|     while ((result = fcntl(ToFileDescriptor(oldfd), F_DUPFD_CLOEXEC, 0)) < 0 && errno == EINTR);
   254| #else
   255|     while ((result = fcntl(ToFileDescriptor(oldfd), F_DUPFD, 0)) < 0 && errno == EINTR);
   256|     fcntl(result, F_SETFD, FD_CLOEXEC);
   257| #endif
   258|     return result;
   259| }
   260| int32_t SystemNative_Unlink(const char* path)
   261| {
   262|     int32_t result;
   263|     while ((result = unlink(path)) < 0 && errno == EINTR);
   264|     return result;
   265| }
   266| intptr_t SystemNative_ShmOpen(const char* name, int32_t flags, int32_t mode)
   267| {
   268| #if HAVE_SHM_OPEN_THAT_WORKS_WELL_ENOUGH_WITH_MMAP
   269|     flags = ConvertOpenFlags(flags);
   270|     if (flags == -1)
   271|     {
   272|         errno = EINVAL;
   273|         return -1;
   274|     }
   275|     return shm_open(name, flags, (mode_t)mode);
   276| #else
   277|     (void)name, (void)flags, (void)mode;
   278|     errno = ENOTSUP;
   279|     return -1;
   280| #endif
   281| }
   282| int32_t SystemNative_ShmUnlink(const char* name)
   283| {
   284| #if HAVE_SHM_OPEN_THAT_WORKS_WELL_ENOUGH_WITH_MMAP
   285|     int32_t result;
   286|     while ((result = shm_unlink(name)) < 0 && errno == EINTR);
   287|     return result;


# ====================================================================
# FILE: src/libraries/Native/Unix/System.Security.Cryptography.Native.Android/pal_sslstream.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 418-464 ---
   418|     {
   419|         IGNORE_RETURN((*env)->CallObjectMethod(env, sslStream->appInBuffer, g_ByteBufferCompact));
   420|         ON_EXCEPTION_PRINT_AND_GOTO(cleanup);
   421|         int handshakeStatus;
   422|         PAL_SSLStreamStatus unwrapStatus = DoUnwrap(env, sslStream, &handshakeStatus);
   423|         if (unwrapStatus != SSLStreamStatus_OK)
   424|         {
   425|             ret = unwrapStatus;
   426|             goto cleanup;
   427|         }
   428|         IGNORE_RETURN((*env)->CallObjectMethod(env, sslStream->appInBuffer, g_ByteBufferFlip));
   429|         if (IsHandshaking(handshakeStatus))
   430|         {
   431|             ret = SSLStreamStatus_Renegotiate;
   432|             goto cleanup;
   433|         }
   434|         rem = (*env)->CallIntMethod(env, sslStream->appInBuffer, g_ByteBufferRemaining);
   435|     }
   436|     if (rem > 0)
   437|     {
   438|         data = make_java_byte_array(env, rem);
   439|         IGNORE_RETURN((*env)->CallObjectMethod(env, sslStream->appInBuffer, g_ByteBufferGet, data));
   440|         ON_EXCEPTION_PRINT_AND_GOTO(cleanup);
   441|         IGNORE_RETURN((*env)->CallObjectMethod(env, sslStream->appInBuffer, g_ByteBufferCompact));
   442|         ON_EXCEPTION_PRINT_AND_GOTO(cleanup);
   443|         (*env)->GetByteArrayRegion(env, data, 0, rem, (jbyte*)buffer);
   444|         *read = rem;
   445|         ret = SSLStreamStatus_OK;
   446|     }
   447|     else
   448|     {
   449|         ret = SSLStreamStatus_NeedData;
   450|     }
   451| cleanup:
   452|     ReleaseLRef(env, data);
   453|     return ret;
   454| }
   455| PAL_SSLStreamStatus AndroidCryptoNative_SSLStreamWrite(SSLStream* sslStream, uint8_t* buffer, int32_t length)
   456| {
   457|     abort_if_invalid_pointer_argument (sslStream);
   458|     JNIEnv* env = GetJNIEnv();
   459|     PAL_SSLStreamStatus ret = SSLStreamStatus_Error;
   460|     int32_t remaining = (*env)->CallIntMethod(env, sslStream->appOutBuffer, g_ByteBufferRemaining);
   461|     int32_t arraySize = length > remaining ? remaining : length;
   462|     jbyteArray data = make_java_byte_array(env, arraySize);
   463|     int32_t written = 0;
   464|     while (written < length)


# ====================================================================
# FILE: src/libraries/Native/Unix/System.Security.Cryptography.Native/opensslshim.h
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 213-252 ---
   213|     REQUIRED_FUNCTION(EC_KEY_get0_public_key) \
   214|     REQUIRED_FUNCTION(EC_KEY_new) \
   215|     REQUIRED_FUNCTION(EC_KEY_new_by_curve_name) \
   216|     REQUIRED_FUNCTION(EC_KEY_set_group) \
   217|     REQUIRED_FUNCTION(EC_KEY_set_private_key) \
   218|     REQUIRED_FUNCTION(EC_KEY_set_public_key) \
   219|     REQUIRED_FUNCTION(EC_KEY_set_public_key_affine_coordinates) \
   220|     REQUIRED_FUNCTION(EC_KEY_up_ref) \
   221|     REQUIRED_FUNCTION(EC_METHOD_get_field_type) \
   222|     REQUIRED_FUNCTION(EC_POINT_free) \
   223|     REQUIRED_FUNCTION(EC_POINT_get_affine_coordinates_GFp) \
   224|     REQUIRED_FUNCTION(EC_POINT_mul) \
   225|     REQUIRED_FUNCTION(EC_POINT_new) \
   226|     REQUIRED_FUNCTION(EC_POINT_set_affine_coordinates_GFp) \
   227|     REQUIRED_FUNCTION(ERR_clear_error) \
   228|     REQUIRED_FUNCTION(ERR_error_string_n) \
   229|     REQUIRED_FUNCTION(ERR_get_error) \
   230|     LEGACY_FUNCTION(ERR_load_crypto_strings) \
   231|     LIGHTUP_FUNCTION(ERR_new) \
   232|     REQUIRED_FUNCTION(ERR_peek_error) \
   233|     REQUIRED_FUNCTION(ERR_peek_last_error) \
   234|     FALLBACK_FUNCTION(ERR_put_error) \
   235|     REQUIRED_FUNCTION(ERR_reason_error_string) \
   236|     LIGHTUP_FUNCTION(ERR_set_debug) \
   237|     LIGHTUP_FUNCTION(ERR_set_error) \
   238|     REQUIRED_FUNCTION(EVP_aes_128_cbc) \
   239|     REQUIRED_FUNCTION(EVP_aes_128_ccm) \
   240|     REQUIRED_FUNCTION(EVP_aes_128_cfb128) \
   241|     REQUIRED_FUNCTION(EVP_aes_128_cfb8) \
   242|     REQUIRED_FUNCTION(EVP_aes_128_ecb) \
   243|     REQUIRED_FUNCTION(EVP_aes_128_gcm) \
   244|     REQUIRED_FUNCTION(EVP_aes_192_cbc) \
   245|     REQUIRED_FUNCTION(EVP_aes_192_ccm) \
   246|     REQUIRED_FUNCTION(EVP_aes_192_cfb128) \
   247|     REQUIRED_FUNCTION(EVP_aes_192_cfb8) \
   248|     REQUIRED_FUNCTION(EVP_aes_192_ecb) \
   249|     REQUIRED_FUNCTION(EVP_aes_192_gcm) \
   250|     REQUIRED_FUNCTION(EVP_aes_256_cbc) \
   251|     REQUIRED_FUNCTION(EVP_aes_256_ccm) \
   252|     REQUIRED_FUNCTION(EVP_aes_256_cfb128) \

# --- HUNK 2: Lines 657-696 ---
   657| #define EC_KEY_get0_public_key EC_KEY_get0_public_key_ptr
   658| #define EC_KEY_new EC_KEY_new_ptr
   659| #define EC_KEY_new_by_curve_name EC_KEY_new_by_curve_name_ptr
   660| #define EC_KEY_set_group EC_KEY_set_group_ptr
   661| #define EC_KEY_set_private_key EC_KEY_set_private_key_ptr
   662| #define EC_KEY_set_public_key EC_KEY_set_public_key_ptr
   663| #define EC_KEY_set_public_key_affine_coordinates EC_KEY_set_public_key_affine_coordinates_ptr
   664| #define EC_KEY_up_ref EC_KEY_up_ref_ptr
   665| #define EC_METHOD_get_field_type EC_METHOD_get_field_type_ptr
   666| #define EC_POINT_free EC_POINT_free_ptr
   667| #define EC_POINT_get_affine_coordinates_GFp EC_POINT_get_affine_coordinates_GFp_ptr
   668| #define EC_POINT_mul EC_POINT_mul_ptr
   669| #define EC_POINT_new EC_POINT_new_ptr
   670| #define EC_POINT_set_affine_coordinates_GFp EC_POINT_set_affine_coordinates_GFp_ptr
   671| #define ERR_clear_error ERR_clear_error_ptr
   672| #define ERR_error_string_n ERR_error_string_n_ptr
   673| #define ERR_get_error ERR_get_error_ptr
   674| #define ERR_load_crypto_strings ERR_load_crypto_strings_ptr
   675| #define ERR_new ERR_new_ptr
   676| #define ERR_peek_error ERR_peek_error_ptr
   677| #define ERR_peek_last_error ERR_peek_last_error_ptr
   678| #define ERR_put_error ERR_put_error_ptr
   679| #define ERR_reason_error_string ERR_reason_error_string_ptr
   680| #define ERR_set_debug ERR_set_debug_ptr
   681| #define ERR_set_error ERR_set_error_ptr
   682| #define EVP_aes_128_cbc EVP_aes_128_cbc_ptr
   683| #define EVP_aes_128_cfb8 EVP_aes_128_cfb8_ptr
   684| #define EVP_aes_128_cfb128 EVP_aes_128_cfb128_ptr
   685| #define EVP_aes_128_ecb EVP_aes_128_ecb_ptr
   686| #define EVP_aes_128_gcm EVP_aes_128_gcm_ptr
   687| #define EVP_aes_128_ccm EVP_aes_128_ccm_ptr
   688| #define EVP_aes_192_cbc EVP_aes_192_cbc_ptr
   689| #define EVP_aes_192_cfb8 EVP_aes_192_cfb8_ptr
   690| #define EVP_aes_192_cfb128 EVP_aes_192_cfb128_ptr
   691| #define EVP_aes_192_ecb EVP_aes_192_ecb_ptr
   692| #define EVP_aes_192_gcm EVP_aes_192_gcm_ptr
   693| #define EVP_aes_192_ccm EVP_aes_192_ccm_ptr
   694| #define EVP_aes_256_cbc EVP_aes_256_cbc_ptr
   695| #define EVP_aes_256_cfb8 EVP_aes_256_cfb8_ptr
   696| #define EVP_aes_256_cfb128 EVP_aes_256_cfb128_ptr


# ====================================================================
# FILE: src/libraries/Native/Unix/System.Security.Cryptography.Native/pal_evp_pkey.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 96-146 ---
    96|     return key;
    97| }
    98| EVP_PKEY* CryptoNative_DecodePkcs8PrivateKey(const uint8_t* buf, int32_t len, int32_t algId)
    99| {
   100|     assert(buf != NULL);
   101|     assert(len > 0);
   102|     PKCS8_PRIV_KEY_INFO* p8info = d2i_PKCS8_PRIV_KEY_INFO(NULL, &buf, len);
   103|     if (p8info == NULL)
   104|     {
   105|         return NULL;
   106|     }
   107|     EVP_PKEY* key = EVP_PKCS82PKEY(p8info);
   108|     PKCS8_PRIV_KEY_INFO_free(p8info);
   109|     if (key != NULL && !CheckKey(key, algId, EVP_PKEY_check))
   110|     {
   111|         EVP_PKEY_free(key);
   112|         key = NULL;
   113|     }
   114|     return key;
   115| }
   116| int32_t CryptoNative_GetPkcs8PrivateKeySize(EVP_PKEY* pkey)
   117| {
   118|     assert(pkey != NULL);
   119|     PKCS8_PRIV_KEY_INFO* p8 = EVP_PKEY2PKCS8(pkey);
   120|     if (p8 == NULL)
   121|     {
   122|         return -1;
   123|     }
   124|     int ret = i2d_PKCS8_PRIV_KEY_INFO(p8, NULL);
   125|     PKCS8_PRIV_KEY_INFO_free(p8);
   126|     return ret;
   127| }
   128| int32_t CryptoNative_EncodePkcs8PrivateKey(EVP_PKEY* pkey, uint8_t* buf)
   129| {
   130|     assert(pkey != NULL);
   131|     assert(buf != NULL);
   132|     PKCS8_PRIV_KEY_INFO* p8 = EVP_PKEY2PKCS8(pkey);
   133|     if (p8 == NULL)
   134|     {
   135|         return -1;
   136|     }
   137|     int ret = i2d_PKCS8_PRIV_KEY_INFO(p8, &buf);
   138|     PKCS8_PRIV_KEY_INFO_free(p8);
   139|     return ret;
   140| }
   141| int32_t CryptoNative_GetSubjectPublicKeyInfoSize(EVP_PKEY* pkey)
   142| {
   143|     assert(pkey != NULL);
   144|     return i2d_PUBKEY(pkey, NULL);
   145| }
   146| int32_t CryptoNative_EncodeSubjectPublicKeyInfo(EVP_PKEY* pkey, uint8_t* buf)


# ====================================================================
# FILE: src/libraries/Native/Unix/System.Security.Cryptography.Native/pal_evp_pkey.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 24-62 ---
    24| */
    25| PALEXPORT int32_t CryptoNative_EvpPKeySize(EVP_PKEY* pkey);
    26| /*
    27| Used by System.Security.Cryptography.X509Certificates' OpenSslX509CertificateReader when
    28| duplicating a private key context as part of duplicating the Pal object.
    29| Returns the number (as of this call) of references to the EVP_PKEY. Anything less than
    30| 2 is an error, because the key is already in the process of being freed.
    31| */
    32| PALEXPORT int32_t CryptoNative_UpRefEvpPkey(EVP_PKEY* pkey);
    33| /*
    34| Decodes an X.509 SubjectPublicKeyInfo into an EVP_PKEY*, verifying the interpreted algorithm type.
    35| Requres a non-null buf, and len > 0.
    36| */
    37| PALEXPORT EVP_PKEY* CryptoNative_DecodeSubjectPublicKeyInfo(const uint8_t* buf, int32_t len, int32_t algId);
    38| /*
    39| Decodes an Pkcs8PrivateKeyInfo into an EVP_PKEY*, verifying the interpreted algorithm type.
    40| Requres a non-null buf, and len > 0.
    41| */
    42| PALEXPORT EVP_PKEY* CryptoNative_DecodePkcs8PrivateKey(const uint8_t* buf, int32_t len, int32_t algId);
    43| /*
    44| Reports the number of bytes rqeuired to encode an EVP_PKEY* as a Pkcs8PrivateKeyInfo, or a negative value on error.
    45| */
    46| PALEXPORT int32_t CryptoNative_GetPkcs8PrivateKeySize(EVP_PKEY* pkey);
    47| /*
    48| Encodes the EVP_PKEY* as a Pkcs8PrivateKeyInfo, writing the encoded value to buf.
    49| buf must be big enough, or an out of bounds write may occur.
    50| Returns the number of bytes written.
    51| */
    52| PALEXPORT int32_t CryptoNative_EncodePkcs8PrivateKey(EVP_PKEY* pkey, uint8_t* buf);
    53| /*
    54| Reports the number of bytes rqeuired to encode an EVP_PKEY* as an X.509 SubjectPublicKeyInfo, or a negative value on error.
    55| */
    56| PALEXPORT int32_t CryptoNative_GetSubjectPublicKeyInfoSize(EVP_PKEY* pkey);
    57| /*
    58| Encodes the EVP_PKEY* as an X.509 SubjectPublicKeyInfo, writing the encoded value to buf.
    59| buf must be big enough, or an out of bounds write may occur.
    60| Returns the number of bytes written.
    61| */
    62| PALEXPORT int32_t CryptoNative_EncodeSubjectPublicKeyInfo(EVP_PKEY* pkey, uint8_t* buf);


# ====================================================================
# FILE: src/libraries/System.Diagnostics.Process/ref/System.Diagnostics.Process.cs
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 20-149 ---
    20|     {
    21|         public MonitoringDescriptionAttribute(string description) { }
    22|         public override string Description { get { throw null; } }
    23|     }
    24|     [System.ComponentModel.DesignerAttribute("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
    25|     public partial class Process : System.ComponentModel.Component, System.IDisposable
    26|     {
    27|         public Process() { }
    28|         public int BasePriority { get { throw null; } }
    29|         public bool EnableRaisingEvents { get { throw null; } set { } }
    30|         public int ExitCode { get { throw null; } }
    31|         public System.DateTime ExitTime { get { throw null; } }
    32|         public System.IntPtr Handle { get { throw null; } }
    33|         public int HandleCount { get { throw null; } }
    34|         public bool HasExited { get { throw null; } }
    35|         public int Id { get { throw null; } }
    36|         public string MachineName { get { throw null; } }
    37|         public System.Diagnostics.ProcessModule? MainModule { get { throw null; } }
    38|         public System.IntPtr MainWindowHandle { get { throw null; } }
    39|         public string MainWindowTitle { get { throw null; } }
    40|         public System.IntPtr MaxWorkingSet { [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios"), System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")] get { throw null; } [System.Runtime.Versioning.SupportedOSPlatformAttribute("freebsd"), System.Runtime.Versioning.SupportedOSPlatformAttribute("macos"), System.Runtime.Versioning.SupportedOSPlatformAttribute("windows")] set { } }
    41|         public System.IntPtr MinWorkingSet { [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios"), System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")] get { throw null; } [System.Runtime.Versioning.SupportedOSPlatformAttribute("freebsd"), System.Runtime.Versioning.SupportedOSPlatformAttribute("macos"), System.Runtime.Versioning.SupportedOSPlatformAttribute("windows")] set { } }
    42|         public System.Diagnostics.ProcessModuleCollection Modules { get { throw null; } }
    43|         [System.ObsoleteAttribute("Process.NonpagedSystemMemorySize has been deprecated because the type of the property can't represent all valid results. Use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.")]
    44|         public int NonpagedSystemMemorySize { get { throw null; } }
    45|         public long NonpagedSystemMemorySize64 { get { throw null; } }
    46|         [System.ObsoleteAttribute("Process.PagedMemorySize has been deprecated because the type of the property can't represent all valid results. Use System.Diagnostics.Process.PagedMemorySize64 instead.")]
    47|         public int PagedMemorySize { get { throw null; } }
    48|         public long PagedMemorySize64 { get { throw null; } }
    49|         [System.ObsoleteAttribute("Process.PagedSystemMemorySize has been deprecated because the type of the property can't represent all valid results. Use System.Diagnostics.Process.PagedSystemMemorySize64 instead.")]
    50|         public int PagedSystemMemorySize { get { throw null; } }
    51|         public long PagedSystemMemorySize64 { get { throw null; } }
    52|         [System.ObsoleteAttribute("Process.PeakPagedMemorySize has been deprecated because the type of the property can't represent all valid results. Use System.Diagnostics.Process.PeakPagedMemorySize64 instead.")]
    53|         public int PeakPagedMemorySize { get { throw null; } }
    54|         public long PeakPagedMemorySize64 { get { throw null; } }
    55|         [System.ObsoleteAttribute("Process.PeakVirtualMemorySize has been deprecated because the type of the property can't represent all valid results. Use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.")]
    56|         public int PeakVirtualMemorySize { get { throw null; } }
    57|         public long PeakVirtualMemorySize64 { get { throw null; } }
    58|         [System.ObsoleteAttribute("Process.PeakWorkingSet has been deprecated because the type of the property can't represent all valid results. Use System.Diagnostics.Process.PeakWorkingSet64 instead.")]
    59|         public int PeakWorkingSet { get { throw null; } }
    60|         public long PeakWorkingSet64 { get { throw null; } }
    61|         public bool PriorityBoostEnabled { get { throw null; } set { } }
    62|         public System.Diagnostics.ProcessPriorityClass PriorityClass { get { throw null; } set { } }
    63|         [System.ObsoleteAttribute("Process.PrivateMemorySize has been deprecated because the type of the property can't represent all valid results. Use System.Diagnostics.Process.PrivateMemorySize64 instead.")]
    64|         public int PrivateMemorySize { get { throw null; } }
    65|         public long PrivateMemorySize64 { get { throw null; } }
    66|         public System.TimeSpan PrivilegedProcessorTime { get { throw null; } }
    67|         public string ProcessName { get { throw null; } }
    68|         [System.Runtime.Versioning.SupportedOSPlatform("windows")]
    69|         [System.Runtime.Versioning.SupportedOSPlatform("linux")]
    70|         public System.IntPtr ProcessorAffinity { get { throw null; } set { } }
    71|         public bool Responding { get { throw null; } }
    72|         public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get { throw null; } }
    73|         public int SessionId { get { throw null; } }
    74|         public System.IO.StreamReader StandardError { get { throw null; } }
    75|         public System.IO.StreamWriter StandardInput { get { throw null; } }
    76|         public System.IO.StreamReader StandardOutput { get { throw null; } }
    77|         public System.Diagnostics.ProcessStartInfo StartInfo { get { throw null; } set { } }
    78|         public System.DateTime StartTime { get { throw null; } }
    79|         public System.ComponentModel.ISynchronizeInvoke? SynchronizingObject { get { throw null; } set { } }
    80|         public System.Diagnostics.ProcessThreadCollection Threads { get { throw null; } }
    81|         public System.TimeSpan TotalProcessorTime { get { throw null; } }
    82|         public System.TimeSpan UserProcessorTime { get { throw null; } }
    83|         [System.ObsoleteAttribute("Process.VirtualMemorySize has been deprecated because the type of the property can't represent all valid results. Use System.Diagnostics.Process.VirtualMemorySize64 instead.")]
    84|         public int VirtualMemorySize { get { throw null; } }
    85|         public long VirtualMemorySize64 { get { throw null; } }
    86|         [System.ObsoleteAttribute("Process.WorkingSet has been deprecated because the type of the property can't represent all valid results. Use System.Diagnostics.Process.WorkingSet64 instead.")]
    87|         public int WorkingSet { get { throw null; } }
    88|         public long WorkingSet64 { get { throw null; } }
    89|         public event System.Diagnostics.DataReceivedEventHandler? ErrorDataReceived { add { } remove { } }
    90|         public event System.EventHandler Exited { add { } remove { } }
    91|         public event System.Diagnostics.DataReceivedEventHandler? OutputDataReceived { add { } remove { } }
    92|         public void BeginErrorReadLine() { }
    93|         public void BeginOutputReadLine() { }
    94|         public void CancelErrorRead() { }
    95|         public void CancelOutputRead() { }
    96|         public void Close() { }
    97|         public bool CloseMainWindow() { throw null; }
    98|         protected override void Dispose(bool disposing) { }
    99|         public static void EnterDebugMode() { }
   100|         public static System.Diagnostics.Process GetCurrentProcess() { throw null; }
   101|         public static System.Diagnostics.Process GetProcessById(int processId) { throw null; }
   102|         public static System.Diagnostics.Process GetProcessById(int processId, string machineName) { throw null; }
   103|         public static System.Diagnostics.Process[] GetProcesses() { throw null; }
   104|         public static System.Diagnostics.Process[] GetProcesses(string machineName) { throw null; }
   105|         public static System.Diagnostics.Process[] GetProcessesByName(string? processName) { throw null; }
   106|         public static System.Diagnostics.Process[] GetProcessesByName(string? processName, string machineName) { throw null; }
   107|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
   108|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
   109|         public void Kill() { }
   110|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
   111|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
   112|         public void Kill(bool entireProcessTree) { }
   113|         public static void LeaveDebugMode() { }
   114|         protected void OnExited() { }
   115|         public void Refresh() { }
   116|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
   117|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
   118|         public bool Start() { throw null; }
   119|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
   120|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
   121|         public static System.Diagnostics.Process? Start(System.Diagnostics.ProcessStartInfo startInfo) { throw null; }
   122|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
   123|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
   124|         public static System.Diagnostics.Process Start(string fileName) { throw null; }
   125|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
   126|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
   127|         public static System.Diagnostics.Process Start(string fileName, string arguments) { throw null; }
   128|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
   129|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
   130|         public static System.Diagnostics.Process Start(string fileName, System.Collections.Generic.IEnumerable<string> arguments) { throw null; }
   131|         [System.CLSCompliantAttribute(false)]
   132|         [System.Runtime.Versioning.SupportedOSPlatformAttribute("windows")]
   133|         public static System.Diagnostics.Process? Start(string fileName, string userName, System.Security.SecureString password, string domain) { throw null; }
   134|         [System.CLSCompliantAttribute(false)]
   135|         [System.Runtime.Versioning.SupportedOSPlatformAttribute("windows")]
   136|         public static System.Diagnostics.Process? Start(string fileName, string arguments, string userName, System.Security.SecureString password, string domain) { throw null; }
   137|         public override string ToString() { throw null; }
   138|         public void WaitForExit() { }
   139|         public bool WaitForExit(int milliseconds) { throw null; }
   140|         public System.Threading.Tasks.Task WaitForExitAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
   141|         public bool WaitForInputIdle() { throw null; }
   142|         public bool WaitForInputIdle(int milliseconds) { throw null; }
   143|     }
   144|     [System.ComponentModel.DesignerAttribute("System.Diagnostics.Design.ProcessModuleDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
   145|     public partial class ProcessModule : System.ComponentModel.Component
   146|     {
   147|         internal ProcessModule() { }
   148|         public System.IntPtr BaseAddress { get { throw null; } }
   149|         public System.IntPtr EntryPointAddress { get { throw null; } }

# --- HUNK 2: Lines 210-258 ---
   210|         [System.ComponentModel.DefaultValueAttribute("")]
   211|         [System.Diagnostics.CodeAnalysis.AllowNullAttribute]
   212|         public string Verb { get { throw null; } set { } }
   213|         public string[] Verbs { get { throw null; } }
   214|         [System.ComponentModel.DefaultValueAttribute(System.Diagnostics.ProcessWindowStyle.Normal)]
   215|         public System.Diagnostics.ProcessWindowStyle WindowStyle { get { throw null; } set { } }
   216|         [System.ComponentModel.EditorAttribute("System.Diagnostics.Design.WorkingDirectoryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
   217|         [System.Diagnostics.CodeAnalysis.AllowNullAttribute]
   218|         public string WorkingDirectory { get { throw null; } set { } }
   219|     }
   220|     [System.ComponentModel.DesignerAttribute("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
   221|     public partial class ProcessThread : System.ComponentModel.Component
   222|     {
   223|         internal ProcessThread() { }
   224|         public int BasePriority { get { throw null; } }
   225|         public int CurrentPriority { get { throw null; } }
   226|         public int Id { get { throw null; } }
   227|         public int IdealProcessor { set { } }
   228|         public bool PriorityBoostEnabled { get { throw null; } set { } }
   229|         public System.Diagnostics.ThreadPriorityLevel PriorityLevel { [System.Runtime.Versioning.SupportedOSPlatform("windows")] [System.Runtime.Versioning.SupportedOSPlatform("linux")] [System.Runtime.Versioning.SupportedOSPlatform("freebsd")] get { throw null; } [System.Runtime.Versioning.SupportedOSPlatformAttribute("windows")] set { } }
   230|         public System.TimeSpan PrivilegedProcessorTime { get { throw null; } }
   231|         [System.Runtime.Versioning.SupportedOSPlatformAttribute("windows")]
   232|         public System.IntPtr ProcessorAffinity { set { } }
   233|         public System.IntPtr StartAddress { get { throw null; } }
   234|         [System.Runtime.Versioning.SupportedOSPlatform("windows")]
   235|         [System.Runtime.Versioning.SupportedOSPlatform("linux")]
   236|         public System.DateTime StartTime { get { throw null; } }
   237|         public System.Diagnostics.ThreadState ThreadState { get { throw null; } }
   238|         public System.TimeSpan TotalProcessorTime { get { throw null; } }
   239|         public System.TimeSpan UserProcessorTime { get { throw null; } }
   240|         public System.Diagnostics.ThreadWaitReason WaitReason { get { throw null; } }
   241|         public void ResetIdealProcessor() { }
   242|     }
   243|     public partial class ProcessThreadCollection : System.Collections.ReadOnlyCollectionBase
   244|     {
   245|         protected ProcessThreadCollection() { }
   246|         public ProcessThreadCollection(System.Diagnostics.ProcessThread[] processThreads) { }
   247|         public System.Diagnostics.ProcessThread this[int index] { get { throw null; } }
   248|         public int Add(System.Diagnostics.ProcessThread thread) { throw null; }
   249|         public bool Contains(System.Diagnostics.ProcessThread thread) { throw null; }
   250|         public void CopyTo(System.Diagnostics.ProcessThread[] array, int index) { }
   251|         public int IndexOf(System.Diagnostics.ProcessThread thread) { throw null; }
   252|         public void Insert(int index, System.Diagnostics.ProcessThread thread) { }
   253|         public void Remove(System.Diagnostics.ProcessThread thread) { }
   254|     }
   255|     public enum ProcessWindowStyle
   256|     {
   257|         Normal = 0,
   258|         Hidden = 1,


# ====================================================================
# FILE: src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.BSD.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| using System.Collections.Generic;
     2| using System.ComponentModel;
     3| namespace System.Diagnostics
     4| {
     5|     public partial class Process
     6|     {
     7|         public static Process[] GetProcessesByName(string? processName, string machineName)
     8|         {
     9|             if (processName == null)
    10|             {
    11|                 processName = string.Empty;
    12|             }
    13|             Process[] procs = GetProcesses(machineName);
    14|             var list = new List<Process>();
    15|             for (int i = 0; i < procs.Length; i++)
    16|             {
    17|                 if (string.Equals(processName, procs[i].ProcessName, StringComparison.OrdinalIgnoreCase))
    18|                 {
    19|                     list.Add(procs[i]);
    20|                 }
    21|                 else
    22|                 {
    23|                     procs[i].Dispose();
    24|                 }
    25|             }
    26|             return list.ToArray();


# ====================================================================
# FILE: src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.Linux.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-31 ---
     1| using System;
     2| using System.Buffers;
     3| using System.Collections.Generic;
     4| using System.ComponentModel;
     5| using System.Globalization;
     6| using System.IO;
     7| using System.Text;
     8| namespace System.Diagnostics
     9| {
    10|     public partial class Process : IDisposable
    11|     {
    12|         public static Process[] GetProcessesByName(string? processName, string machineName)
    13|         {
    14|             ProcessManager.ThrowIfRemoteMachine(machineName);
    15|             if (processName == null)
    16|             {
    17|                 processName = string.Empty;
    18|             }
    19|             var processes = new List<Process>();
    20|             foreach (int pid in ProcessManager.EnumerateProcessIds())
    21|             {
    22|                 if (Interop.procfs.TryReadStatFile(pid, out Interop.procfs.ParsedStat parsedStat) &&
    23|                     string.Equals(processName, Process.GetUntruncatedProcessName(ref parsedStat), StringComparison.OrdinalIgnoreCase) &&
    24|                     Interop.procfs.TryReadStatusFile(pid, out Interop.procfs.ParsedStatus parsedStatus))
    25|                 {
    26|                     ProcessInfo processInfo = ProcessManager.CreateProcessInfo(ref parsedStat, ref parsedStatus, processName);
    27|                     processes.Add(new Process(machineName, false, processInfo.ProcessId, processInfo));
    28|                 }
    29|             }
    30|             return processes.ToArray();
    31|         }


# ====================================================================
# FILE: src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.NonUap.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| using System.Collections.Generic;
     2| using System.ComponentModel;
     3| using System.Runtime.Versioning;
     4| namespace System.Diagnostics
     5| {
     6|     public partial class Process : IDisposable
     7|     {
     8|         [UnsupportedOSPlatform("ios")]
     9|         [UnsupportedOSPlatform("tvos")]
    10|         public void Kill(bool entireProcessTree)
    11|         {
    12|             if (!entireProcessTree)
    13|             {
    14|                 Kill();
    15|             }
    16|             else
    17|             {
    18|                 EnsureState(State.Associated | State.IsLocal);
    19|                 if (IsSelfOrDescendantOf(GetCurrentProcess()))
    20|                     throw new InvalidOperationException(SR.KillEntireProcessTree_DisallowedBecauseTreeContainsCallingProcess);
    21|                 List<Exception>? result = KillTree();
    22|                 if (result != null && result.Count != 0)
    23|                     throw new AggregateException(SR.KillEntireProcessTree_TerminationIncomplete, result);
    24|             }
    25|         }
    26|         private bool IsSelfOrDescendantOf(Process processOfInterest)
    27|         {
    28|             if (Equals(processOfInterest))
    29|                 return true;


# ====================================================================
# FILE: src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.Unix.cs
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 21-63 ---
    21|         public static void EnterDebugMode()
    22|         {
    23|         }
    24|         public static void LeaveDebugMode()
    25|         {
    26|         }
    27|         [CLSCompliant(false)]
    28|         [SupportedOSPlatform("windows")]
    29|         public static Process Start(string fileName, string userName, SecureString password, string domain)
    30|         {
    31|             throw new PlatformNotSupportedException(SR.ProcessStartWithPasswordAndDomainNotSupported);
    32|         }
    33|         [CLSCompliant(false)]
    34|         [SupportedOSPlatform("windows")]
    35|         public static Process Start(string fileName, string arguments, string userName, SecureString password, string domain)
    36|         {
    37|             throw new PlatformNotSupportedException(SR.ProcessStartWithPasswordAndDomainNotSupported);
    38|         }
    39|         [UnsupportedOSPlatform("ios")]
    40|         [UnsupportedOSPlatform("tvos")]
    41|         public void Kill()
    42|         {
    43|             if (OperatingSystem.IsIOS() || OperatingSystem.IsTvOS())
    44|             {
    45|                 throw new PlatformNotSupportedException();
    46|             }
    47|             EnsureState(State.HaveId);
    48|             if (GetHasExited(refresh: false))
    49|             {
    50|                 return;
    51|             }
    52|             int killResult = Interop.Sys.Kill(_processId, Interop.Sys.Signals.SIGKILL);
    53|             if (killResult != 0)
    54|             {
    55|                 Interop.Error error = Interop.Sys.GetLastError();
    56|                 if (error == Interop.Error.ESRCH)
    57|                 {
    58|                     return;
    59|                 }
    60|                 throw new Win32Exception(); // same exception as on Windows
    61|             }
    62|         }
    63|         private bool GetHasExited(bool refresh)

# --- HUNK 2: Lines 252-292 ---
   252|             {
   253|                 return;
   254|             }
   255|             if (GetHasExited(refresh))
   256|             {
   257|                 throw new InvalidOperationException(SR.Format(SR.ProcessHasExited, _processId.ToString()));
   258|             }
   259|         }
   260|         private SafeProcessHandle GetProcessHandle()
   261|         {
   262|             if (_haveProcessHandle)
   263|             {
   264|                 ThrowIfExited(refresh: true);
   265|                 return _processHandle!;
   266|             }
   267|             EnsureState(State.HaveNonExitedId | State.IsLocal);
   268|             return new SafeProcessHandle(_processId, GetSafeWaitHandle());
   269|         }
   270|         private bool StartCore(ProcessStartInfo startInfo)
   271|         {
   272|             if (OperatingSystem.IsIOS() || OperatingSystem.IsTvOS())
   273|             {
   274|                 throw new PlatformNotSupportedException();
   275|             }
   276|             EnsureInitialized();
   277|             string? filename;
   278|             string[] argv;
   279|             if (startInfo.UseShellExecute)
   280|             {
   281|                 if (startInfo.RedirectStandardInput || startInfo.RedirectStandardOutput || startInfo.RedirectStandardError)
   282|                 {
   283|                     throw new InvalidOperationException(SR.CantRedirectStreams);
   284|                 }
   285|             }
   286|             int stdinFd = -1, stdoutFd = -1, stderrFd = -1;
   287|             string[] envp = CreateEnvp(startInfo);
   288|             string? cwd = !string.IsNullOrWhiteSpace(startInfo.WorkingDirectory) ? startInfo.WorkingDirectory : null;
   289|             bool setCredentials = !string.IsNullOrEmpty(startInfo.UserName);
   290|             uint userId = 0;
   291|             uint groupId = 0;
   292|             uint[]? groups = null;

# --- HUNK 3: Lines 767-788 ---
   767|                     s_initialized = true;
   768|                 }
   769|             }
   770|         }
   771|         [UnmanagedCallersOnly]
   772|         private static int OnSigChild(int reapAll, int configureConsole)
   773|         {
   774|             s_processStartLock.EnterWriteLock();
   775|             try
   776|             {
   777|                 bool childrenUsingTerminalPre = AreChildrenUsingTerminal;
   778|                 ProcessWaitState.CheckChildren(reapAll != 0, configureConsole != 0);
   779|                 bool childrenUsingTerminalPost = AreChildrenUsingTerminal;
   780|                 return childrenUsingTerminalPre && !childrenUsingTerminalPost && configureConsole == 0 ? 1 : 0;
   781|             }
   782|             finally
   783|             {
   784|                 s_processStartLock.ExitWriteLock();
   785|             }
   786|         }
   787|     }
   788| }


# ====================================================================
# FILE: src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.UnknownUnix.cs
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-45 ---
     1| namespace System.Diagnostics
     2| {
     3|     public partial class Process : IDisposable
     4|     {
     5|         public static Process[] GetProcessesByName(string processName, string machineName)
     6|         {
     7|             throw new PlatformNotSupportedException();
     8|         }
     9|         public TimeSpan PrivilegedProcessorTime
    10|         {
    11|             get { throw new PlatformNotSupportedException(); }
    12|         }
    13|         internal DateTime StartTimeCore
    14|         {
    15|             get { throw new PlatformNotSupportedException(); }
    16|         }
    17|         public TimeSpan TotalProcessorTime
    18|         {
    19|             get { throw new PlatformNotSupportedException(); }
    20|         }
    21|         public TimeSpan UserProcessorTime
    22|         {
    23|             get { throw new PlatformNotSupportedException(); }
    24|         }
    25|         private int GetParentProcessId =>
    26|             throw new PlatformNotSupportedException();
    27|         private IntPtr ProcessorAffinityCore
    28|         {
    29|             get { throw new PlatformNotSupportedException(); }
    30|             set { throw new PlatformNotSupportedException(); }
    31|         }
    32|         private void GetWorkingSetLimits(out IntPtr minWorkingSet, out IntPtr maxWorkingSet)
    33|         {
    34|             throw new PlatformNotSupportedException();
    35|         }
    36|         private void SetWorkingSetLimitsCore(IntPtr? newMin, IntPtr? newMax, out IntPtr resultingMin, out IntPtr resultingMax)
    37|         {
    38|             throw new PlatformNotSupportedException();
    39|         }
    40|         private string GetPathToOpenFile()
    41|         {
    42|             throw new PlatformNotSupportedException();
    43|         }
    44|     }
    45| }


# ====================================================================
# FILE: src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.Windows.cs
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-34 ---
     1| using Microsoft.Win32.SafeHandles;
     2| using System.Collections.Generic;
     3| using System.ComponentModel;
     4| using System.IO;
     5| using System.Runtime.InteropServices;
     6| using System.Runtime.Versioning;
     7| using System.Security;
     8| using System.Text;
     9| using System.Threading;
    10| namespace System.Diagnostics
    11| {
    12|     public partial class Process : IDisposable
    13|     {
    14|         private static readonly object s_createProcessLock = new object();
    15|         public static Process[] GetProcessesByName(string? processName, string machineName)
    16|         {
    17|             if (processName == null)
    18|             {
    19|                 processName = string.Empty;
    20|             }
    21|             Process[] procs = GetProcesses(machineName);
    22|             var list = new List<Process>();
    23|             for (int i = 0; i < procs.Length; i++)
    24|             {
    25|                 if (string.Equals(processName, procs[i].ProcessName, StringComparison.OrdinalIgnoreCase))
    26|                 {
    27|                     list.Add(procs[i]);
    28|                 }
    29|                 else
    30|                 {
    31|                     procs[i].Dispose();
    32|                 }
    33|             }
    34|             return list.ToArray();

# --- HUNK 2: Lines 48-87 ---
    48|         [SupportedOSPlatform("windows")]
    49|         public static Process? Start(string fileName, string arguments, string userName, SecureString password, string domain)
    50|         {
    51|             ProcessStartInfo startInfo = new ProcessStartInfo(fileName, arguments);
    52|             startInfo.UserName = userName;
    53|             startInfo.Password = password;
    54|             startInfo.Domain = domain;
    55|             startInfo.UseShellExecute = false;
    56|             return Start(startInfo);
    57|         }
    58|         public static void EnterDebugMode()
    59|         {
    60|             SetPrivilege(Interop.Advapi32.SeDebugPrivilege, (int)Interop.Advapi32.SEPrivileges.SE_PRIVILEGE_ENABLED);
    61|         }
    62|         public static void LeaveDebugMode()
    63|         {
    64|             SetPrivilege(Interop.Advapi32.SeDebugPrivilege, 0);
    65|         }
    66|         [UnsupportedOSPlatform("ios")]
    67|         [UnsupportedOSPlatform("tvos")]
    68|         public void Kill()
    69|         {
    70|             using (SafeProcessHandle handle = GetProcessHandle(Interop.Advapi32.ProcessOptions.PROCESS_TERMINATE | Interop.Advapi32.ProcessOptions.PROCESS_QUERY_LIMITED_INFORMATION, throwIfExited: false))
    71|             {
    72|                 if (handle.IsInvalid)
    73|                     return;
    74|                 if (!Interop.Kernel32.TerminateProcess(handle, -1))
    75|                 {
    76|                     var exception = new Win32Exception();
    77|                     if (exception.NativeErrorCode == Interop.Errors.ERROR_ACCESS_DENIED &&
    78|                         Interop.Kernel32.GetExitCodeProcess(handle, out int localExitCode) && localExitCode != Interop.Kernel32.HandleOptions.STILL_ACTIVE)
    79|                     {
    80|                         return;
    81|                     }
    82|                     throw exception;
    83|                 }
    84|             }
    85|         }
    86|         private void RefreshCore()
    87|         {


# ====================================================================
# FILE: src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
# Total hunks: 5
# ====================================================================
# --- HUNK 1: Lines 107-146 ---
   107|                 EnsureState(State.Exited);
   108|                 return _exitCode;
   109|             }
   110|         }
   111|         public bool HasExited
   112|         {
   113|             get
   114|             {
   115|                 if (!_exited)
   116|                 {
   117|                     EnsureState(State.Associated);
   118|                     UpdateHasExited();
   119|                     if (_exited)
   120|                     {
   121|                         RaiseOnExited();
   122|                     }
   123|                 }
   124|                 return _exited;
   125|             }
   126|         }
   127|         public DateTime StartTime
   128|         {
   129|             get
   130|             {
   131|                 if (!_startTime.HasValue)
   132|                 {
   133|                     _startTime = StartTimeCore;
   134|                 }
   135|                 return _startTime.Value;
   136|             }
   137|         }
   138|         public DateTime ExitTime
   139|         {
   140|             get
   141|             {
   142|                 if (!_haveExitTime)
   143|                 {
   144|                     EnsureState(State.Exited);
   145|                     _exitTime = ExitTimeCore;
   146|                     _haveExitTime = true;

# --- HUNK 2: Lines 151-215 ---
   151|         public int Id
   152|         {
   153|             get
   154|             {
   155|                 EnsureState(State.HaveId);
   156|                 return _processId;
   157|             }
   158|         }
   159|         public string MachineName
   160|         {
   161|             get
   162|             {
   163|                 EnsureState(State.Associated);
   164|                 return _machineName;
   165|             }
   166|         }
   167|         public IntPtr MaxWorkingSet
   168|         {
   169|             [UnsupportedOSPlatform("ios")]
   170|             [UnsupportedOSPlatform("tvos")]
   171|             get
   172|             {
   173|                 EnsureWorkingSetLimits();
   174|                 return _maxWorkingSet;
   175|             }
   176|             [SupportedOSPlatform("windows")]
   177|             [SupportedOSPlatform("macos")]
   178|             [SupportedOSPlatform("freebsd")]
   179|             set
   180|             {
   181|                 SetWorkingSetLimits(null, value);
   182|             }
   183|         }
   184|         public IntPtr MinWorkingSet
   185|         {
   186|             [UnsupportedOSPlatform("ios")]
   187|             [UnsupportedOSPlatform("tvos")]
   188|             get
   189|             {
   190|                 EnsureWorkingSetLimits();
   191|                 return _minWorkingSet;
   192|             }
   193|             [SupportedOSPlatform("windows")]
   194|             [SupportedOSPlatform("macos")]
   195|             [SupportedOSPlatform("freebsd")]
   196|             set
   197|             {
   198|                 SetWorkingSetLimits(value, null);
   199|             }
   200|         }
   201|         public ProcessModuleCollection Modules
   202|         {
   203|             get
   204|             {
   205|                 if (_modules == null)
   206|                 {
   207|                     EnsureState(State.HaveNonExitedId | State.IsLocal);
   208|                     _modules = ProcessManager.GetModules(_processId);
   209|                 }
   210|                 return _modules;
   211|             }
   212|         }
   213|         public long NonpagedSystemMemorySize64
   214|         {
   215|             get

# --- HUNK 3: Lines 740-787 ---
   740|                 _haveWorkingSetLimits = true;
   741|             }
   742|         }
   743|         private void SetWorkingSetLimits(IntPtr? min, IntPtr? max)
   744|         {
   745|             SetWorkingSetLimitsCore(min, max, out _minWorkingSet, out _maxWorkingSet);
   746|             _haveWorkingSetLimits = true;
   747|         }
   748|         public static Process GetProcessById(int processId, string machineName)
   749|         {
   750|             if (!ProcessManager.IsProcessRunning(processId, machineName))
   751|             {
   752|                 throw new ArgumentException(SR.Format(SR.MissingProccess, processId.ToString()));
   753|             }
   754|             return new Process(machineName, ProcessManager.IsRemoteMachine(machineName), processId, null);
   755|         }
   756|         public static Process GetProcessById(int processId)
   757|         {
   758|             return GetProcessById(processId, ".");
   759|         }
   760|         public static Process[] GetProcessesByName(string? processName)
   761|         {
   762|             return GetProcessesByName(processName, ".");
   763|         }
   764|         public static Process[] GetProcesses()
   765|         {
   766|             return GetProcesses(".");
   767|         }
   768|         public static Process[] GetProcesses(string machineName)
   769|         {
   770|             bool isRemoteMachine = ProcessManager.IsRemoteMachine(machineName);
   771|             ProcessInfo[] processInfos = ProcessManager.GetProcessInfos(machineName);
   772|             Process[] processes = new Process[processInfos.Length];
   773|             for (int i = 0; i < processInfos.Length; i++)
   774|             {
   775|                 ProcessInfo processInfo = processInfos[i];
   776|                 processes[i] = new Process(machineName, isRemoteMachine, processInfo.ProcessId, processInfo);
   777|             }
   778|             return processes;
   779|         }
   780|         public static Process GetCurrentProcess()
   781|         {
   782|             return new Process(".", false, Environment.ProcessId, null);
   783|         }
   784|         protected void OnExited()
   785|         {
   786|             EventHandler? exited = _onExited;
   787|             if (exited != null)

# --- HUNK 4: Lines 835-931 ---
   835|             return _processHandle!;
   836|         }
   837|         private void SetProcessHandle(SafeProcessHandle processHandle)
   838|         {
   839|             _processHandle = processHandle;
   840|             _haveProcessHandle = true;
   841|             if (_watchForExit)
   842|             {
   843|                 EnsureWatchingForExit();
   844|             }
   845|         }
   846|         private void SetProcessId(int processId)
   847|         {
   848|             _processId = processId;
   849|             _haveProcessId = true;
   850|             ConfigureAfterProcessIdSet();
   851|         }
   852|         partial void ConfigureAfterProcessIdSet();
   853|         [UnsupportedOSPlatform("ios")]
   854|         [UnsupportedOSPlatform("tvos")]
   855|         public bool Start()
   856|         {
   857|             Close();
   858|             ProcessStartInfo startInfo = StartInfo;
   859|             if (startInfo.FileName.Length == 0)
   860|             {
   861|                 throw new InvalidOperationException(SR.FileNameMissing);
   862|             }
   863|             if (startInfo.StandardInputEncoding != null && !startInfo.RedirectStandardInput)
   864|             {
   865|                 throw new InvalidOperationException(SR.StandardInputEncodingNotAllowed);
   866|             }
   867|             if (startInfo.StandardOutputEncoding != null && !startInfo.RedirectStandardOutput)
   868|             {
   869|                 throw new InvalidOperationException(SR.StandardOutputEncodingNotAllowed);
   870|             }
   871|             if (startInfo.StandardErrorEncoding != null && !startInfo.RedirectStandardError)
   872|             {
   873|                 throw new InvalidOperationException(SR.StandardErrorEncodingNotAllowed);
   874|             }
   875|             if (!string.IsNullOrEmpty(startInfo.Arguments) && startInfo.HasArgumentList)
   876|             {
   877|                 throw new InvalidOperationException(SR.ArgumentAndArgumentListInitialized);
   878|             }
   879|             CheckDisposed();
   880|             SerializationGuard.ThrowIfDeserializationInProgress("AllowProcessCreation", ref s_cachedSerializationSwitch);
   881|             return StartCore(startInfo);
   882|         }
   883|         [UnsupportedOSPlatform("ios")]
   884|         [UnsupportedOSPlatform("tvos")]
   885|         public static Process Start(string fileName)
   886|         {
   887|             return Start(new ProcessStartInfo(fileName))!;
   888|         }
   889|         [UnsupportedOSPlatform("ios")]
   890|         [UnsupportedOSPlatform("tvos")]
   891|         public static Process Start(string fileName, string arguments)
   892|         {
   893|             return Start(new ProcessStartInfo(fileName, arguments))!;
   894|         }
   895|         [UnsupportedOSPlatform("ios")]
   896|         [UnsupportedOSPlatform("tvos")]
   897|         public static Process Start(string fileName, IEnumerable<string> arguments)
   898|         {
   899|             if (fileName == null)
   900|                 throw new ArgumentNullException(nameof(fileName));
   901|             if (arguments == null)
   902|                 throw new ArgumentNullException(nameof(arguments));
   903|             var startInfo = new ProcessStartInfo(fileName);
   904|             foreach (string argument in arguments)
   905|             {
   906|                 startInfo.ArgumentList.Add(argument);
   907|             }
   908|             return Start(startInfo)!;
   909|         }
   910|         [UnsupportedOSPlatform("ios")]
   911|         [UnsupportedOSPlatform("tvos")]
   912|         public static Process? Start(ProcessStartInfo startInfo)
   913|         {
   914|             Process process = new Process();
   915|             if (startInfo == null)
   916|                 throw new ArgumentNullException(nameof(startInfo));
   917|             process.StartInfo = startInfo;
   918|             return process.Start() ?
   919|                 process :
   920|                 null;
   921|         }
   922|         private void StopWatchingForExit()
   923|         {
   924|             if (_watchingForExit)
   925|             {
   926|                 RegisteredWaitHandle? rwh = null;
   927|                 WaitHandle? wh = null;
   928|                 lock (this)
   929|                 {
   930|                     if (_watchingForExit)
   931|                     {


# ====================================================================
# FILE: src/libraries/System.Diagnostics.Process/src/System/Diagnostics/ProcessManager.Unix.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-42 ---
     1| using Microsoft.Win32.SafeHandles;
     2| using System.Collections.Generic;
     3| using System.Text;
     4| namespace System.Diagnostics
     5| {
     6|     internal static partial class ProcessManager
     7|     {
     8|         public static bool IsProcessRunning(int processId, string machineName)
     9|         {
    10|             ThrowIfRemoteMachine(machineName);
    11|             return IsProcessRunning(processId);
    12|         }
    13|         public static bool IsProcessRunning(int processId)
    14|         {
    15|             int output = Interop.Sys.Kill(processId, Interop.Sys.Signals.None);
    16|             return 0 == output || (-1 == output && Interop.Error.EPERM == Interop.Sys.GetLastError());
    17|         }
    18|         public static ProcessInfo? GetProcessInfo(int processId, string machineName)
    19|         {
    20|             ThrowIfRemoteMachine(machineName);
    21|             return CreateProcessInfo(processId);
    22|         }
    23|         public static int[] GetProcessIds(string machineName)
    24|         {
    25|             ThrowIfRemoteMachine(machineName);
    26|             return GetProcessIds();
    27|         }
    28|         public static int GetProcessIdFromHandle(SafeProcessHandle processHandle)
    29|         {
    30|             return processHandle.ProcessId;
    31|         }
    32|         private static bool IsRemoteMachineCore(string machineName)
    33|         {
    34|             return
    35|                 machineName != "." &&
    36|                 machineName != Interop.Sys.GetHostName();
    37|         }
    38|         internal static void ThrowIfRemoteMachine(string machineName)
    39|         {
    40|             if (IsRemoteMachine(machineName))
    41|             {
    42|                 throw new PlatformNotSupportedException(SR.RemoteMachinesNotSupported);


# ====================================================================
# FILE: src/libraries/System.Diagnostics.Process/src/System/Diagnostics/ThreadInfo.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-13 ---
     1| namespace System.Diagnostics
     2| {
     3|     internal sealed class ThreadInfo
     4|     {
     5|         internal ulong _threadId;
     6|         internal int _processId;
     7|         internal int _basePriority;
     8|         internal int _currentPriority;
     9|         internal IntPtr _startAddress;
    10|         internal ThreadState _threadState;
    11|         internal ThreadWaitReason _threadWaitReason;
    12|     }
    13| }


# ====================================================================
# FILE: src/libraries/System.IO.Compression.ZipFile/src/System/IO/Compression/ZipFileExtensions.ZipArchiveEntry.Extract.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 4-44 ---
     4|     {
     5|         public static void ExtractToFile(this ZipArchiveEntry source, string destinationFileName) =>
     6|             ExtractToFile(source, destinationFileName, false);
     7|         public static void ExtractToFile(this ZipArchiveEntry source, string destinationFileName, bool overwrite)
     8|         {
     9|             if (source == null)
    10|                 throw new ArgumentNullException(nameof(source));
    11|             if (destinationFileName == null)
    12|                 throw new ArgumentNullException(nameof(destinationFileName));
    13|             FileMode fMode = overwrite ? FileMode.Create : FileMode.CreateNew;
    14|             using (FileStream fs = new FileStream(destinationFileName, fMode, FileAccess.Write, FileShare.None, bufferSize: 0x1000, useAsync: false))
    15|             {
    16|                 using (Stream es = source.Open())
    17|                     es.CopyTo(fs);
    18|                 ExtractExternalAttributes(fs, source);
    19|             }
    20|             try
    21|             {
    22|                 File.SetLastWriteTime(destinationFileName, source.LastWriteTime.DateTime);
    23|             }
    24|             catch (UnauthorizedAccessException)
    25|             {
    26|             }
    27|         }
    28|         static partial void ExtractExternalAttributes(FileStream fs, ZipArchiveEntry entry);
    29|         internal static void ExtractRelativeToDirectory(this ZipArchiveEntry source, string destinationDirectoryName) =>
    30|             ExtractRelativeToDirectory(source, destinationDirectoryName, overwrite: false);
    31|         internal static void ExtractRelativeToDirectory(this ZipArchiveEntry source, string destinationDirectoryName, bool overwrite)
    32|         {
    33|             if (source == null)
    34|                 throw new ArgumentNullException(nameof(source));
    35|             if (destinationDirectoryName == null)
    36|                 throw new ArgumentNullException(nameof(destinationDirectoryName));
    37|             DirectoryInfo di = Directory.CreateDirectory(destinationDirectoryName);
    38|             string destinationDirectoryFullPath = di.FullName;
    39|             if (!destinationDirectoryFullPath.EndsWith(Path.DirectorySeparatorChar))
    40|                 destinationDirectoryFullPath += Path.DirectorySeparatorChar;
    41|             string fileDestinationPath = Path.GetFullPath(Path.Combine(destinationDirectoryFullPath, source.FullName));
    42|             if (!fileDestinationPath.StartsWith(destinationDirectoryFullPath, PathInternal.StringComparison))
    43|                 throw new IOException(SR.IO_ExtractingResultsInOutside);
    44|             if (Path.GetFileName(fileDestinationPath).Length == 0)


# ====================================================================
# FILE: src/libraries/System.IO.MemoryMappedFiles/src/System/IO/MemoryMappedFiles/MemoryMappedFile.Unix.cs
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-20 ---
     1| using Microsoft.Win32.SafeHandles;
     2| namespace System.IO.MemoryMappedFiles
     3| {
     4|     public partial class MemoryMappedFile
     5|     {
     6|         private static void VerifyMemoryMappedFileAccess(MemoryMappedFileAccess access, long capacity, FileStream? fileStream, out long fileSize)
     7|         {
     8|             fileSize = -1;
     9|             if (fileStream != null)
    10|             {
    11|                 Interop.Sys.FileStatus status;
    12|                 int result = Interop.Sys.FStat(fileStream.SafeFileHandle, out status);
    13|                 if (result != 0)
    14|                 {
    15|                     Interop.ErrorInfo errorInfo = Interop.Sys.GetLastErrorInfo();
    16|                     throw Interop.GetExceptionForIoErrno(errorInfo);
    17|                 }
    18|                 bool isRegularFile = (status.Mode & Interop.Sys.FileTypes.S_IFCHR) == 0;
    19|                 if (isRegularFile)
    20|                 {

# --- HUNK 2: Lines 89-165 ---
    89|         }
    90|         private static Exception CreateNamedMapsNotSupportedException()
    91|         {
    92|             return new PlatformNotSupportedException(SR.PlatformNotSupported_NamedMaps);
    93|         }
    94|         private static FileAccess TranslateProtectionsToFileAccess(Interop.Sys.MemoryMappedProtections protections)
    95|         {
    96|             return
    97|                 (protections & (Interop.Sys.MemoryMappedProtections.PROT_READ | Interop.Sys.MemoryMappedProtections.PROT_WRITE)) != 0 ? FileAccess.ReadWrite :
    98|                 (protections & (Interop.Sys.MemoryMappedProtections.PROT_WRITE)) != 0 ? FileAccess.Write :
    99|                 FileAccess.Read;
   100|         }
   101|         private static FileStream CreateSharedBackingObject(Interop.Sys.MemoryMappedProtections protections, long capacity, HandleInheritability inheritability)
   102|         {
   103|             return CreateSharedBackingObjectUsingMemory(protections, capacity, inheritability)
   104|                 ?? CreateSharedBackingObjectUsingFile(protections, capacity, inheritability);
   105|         }
   106|         private static FileStream? CreateSharedBackingObjectUsingMemory(
   107|            Interop.Sys.MemoryMappedProtections protections, long capacity, HandleInheritability inheritability)
   108|         {
   109|             string mapName = string.Create(null, stackalloc char[128], $"/corefx_map_{Guid.NewGuid():N}");
   110|             Interop.Sys.OpenFlags flags = (protections & Interop.Sys.MemoryMappedProtections.PROT_WRITE) != 0 ?
   111|                 Interop.Sys.OpenFlags.O_RDWR :
   112|                 Interop.Sys.OpenFlags.O_RDONLY;
   113|             flags |= Interop.Sys.OpenFlags.O_CREAT | Interop.Sys.OpenFlags.O_EXCL; // CreateNew
   114|             Interop.Sys.Permissions perms = default(Interop.Sys.Permissions);
   115|             if ((protections & Interop.Sys.MemoryMappedProtections.PROT_READ) != 0)
   116|                 perms |= Interop.Sys.Permissions.S_IRUSR;
   117|             if ((protections & Interop.Sys.MemoryMappedProtections.PROT_WRITE) != 0)
   118|                 perms |= Interop.Sys.Permissions.S_IWUSR;
   119|             if ((protections & Interop.Sys.MemoryMappedProtections.PROT_EXEC) != 0)
   120|                 perms |= Interop.Sys.Permissions.S_IXUSR;
   121|             SafeFileHandle fd = Interop.Sys.ShmOpen(mapName, flags, (int)perms);
   122|             if (fd.IsInvalid)
   123|             {
   124|                 Interop.ErrorInfo errorInfo = Interop.Sys.GetLastErrorInfo();
   125|                 if (errorInfo.Error == Interop.Error.ENOTSUP)
   126|                 {
   127|                     return null;
   128|                 }
   129|                 throw Interop.GetExceptionForIoErrno(errorInfo);
   130|             }
   131|             try
   132|             {
   133|                 Interop.CheckIo(Interop.Sys.ShmUnlink(mapName));
   134|                 Interop.CheckIo(Interop.Sys.FTruncate(fd, capacity));
   135|                 if (inheritability == HandleInheritability.Inheritable &&
   136|                     Interop.Sys.Fcntl.SetFD(fd, 0) == -1)
   137|                 {
   138|                     throw Interop.GetExceptionForIoErrno(Interop.Sys.GetLastErrorInfo());
   139|                 }
   140|                 return new FileStream(fd, TranslateProtectionsToFileAccess(protections));
   141|             }
   142|             catch
   143|             {
   144|                 fd.Dispose();
   145|                 throw;
   146|             }
   147|         }
   148|         private static FileStream CreateSharedBackingObjectUsingFile(Interop.Sys.MemoryMappedProtections protections, long capacity, HandleInheritability inheritability)
   149|         {
   150|             string path = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString("N"));
   151|             FileShare share = inheritability == HandleInheritability.None ?
   152|                 FileShare.ReadWrite :
   153|                 FileShare.ReadWrite | FileShare.Inheritable;
   154|             const int DefaultBufferSize = 0x1000;
   155|             var fs = new FileStream(path, FileMode.CreateNew, TranslateProtectionsToFileAccess(protections), share, DefaultBufferSize);
   156|             try
   157|             {
   158|                 Interop.CheckIo(Interop.Sys.Unlink(path));
   159|                 fs.SetLength(capacity);
   160|             }
   161|             catch
   162|             {
   163|                 fs.Dispose();
   164|                 throw;
   165|             }


# ====================================================================
# FILE: src/libraries/System.Net.Http/src/System/Net/Http/HttpClientHandler.AnyMobile.InvokeNativeHandler.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-48 ---
     1| using System;
     2| using System.Collections.Generic;
     3| using System.Diagnostics.CodeAnalysis;
     4| using System.Net.Security;
     5| using System.Reflection;
     6| using System.Security.Authentication;
     7| using System.Security.Cryptography.X509Certificates;
     8| namespace System.Net.Http
     9| {
    10|     public partial class HttpClientHandler : HttpMessageHandler
    11|     {
    12|         private static MethodInfo? _nativeHandlerMethod;
    13| #if TARGET_ANDROID
    14|         private const string NativeHandlerType = "Xamarin.Android.Net.AndroidMessageHandler";
    15|         private const string AssemblyName = "Mono.Android";
    16|         private const string GetHttpMessageHandlerType = "Android.Runtime.AndroidEnvironment, Mono.Android";
    17| #elif TARGET_IOS
    18|         private const string NativeHandlerType = "System.Net.Http.NSUrlSessionHandler";
    19|         private const string AssemblyName = "Xamarin.iOS";
    20|         private const string GetHttpMessageHandlerType = "ObjCRuntime.RuntimeOptions, Xamarin.iOS";
    21| #elif TARGET_MACCATALYST
    22|         private const string NativeHandlerType = "System.Net.Http.NSUrlSessionHandler";
    23|         private const string AssemblyName = "Xamarin.MacCatalyst";
    24|         private const string GetHttpMessageHandlerType = "ObjCRuntime.RuntimeOptions, Xamarin.MacCatalyst";
    25| #elif TARGET_TVOS
    26|         private const string NativeHandlerType = "System.Net.Http.NSUrlSessionHandler";
    27|         private const string AssemblyName = "Xamarin.TVOS";
    28|         private const string GetHttpMessageHandlerType = "ObjCRuntime.RuntimeOptions, Xamarin.TVOS";
    29| #else
    30| #error Unknown target
    31| #endif
    32|         [DynamicDependency("get_DefaultProxyCredentials", NativeHandlerType, AssemblyName)]
    33|         private ICredentials? GetDefaultProxyCredentials() => (ICredentials?)InvokeNativeHandlerMethod("get_DefaultProxyCredentials");
    34|         [DynamicDependency("set_DefaultProxyCredentials", NativeHandlerType, AssemblyName)]
    35|         private void SetDefaultProxyCredentials(ICredentials? value) => InvokeNativeHandlerMethod("set_DefaultProxyCredentials", value);
    36|         [DynamicDependency("get_MaxConnectionsPerServer", NativeHandlerType, AssemblyName)]
    37|         private int GetMaxConnectionsPerServer() => (int)InvokeNativeHandlerMethod("get_MaxConnectionsPerServer");
    38|         [DynamicDependency("set_MaxConnectionsPerServer", NativeHandlerType, AssemblyName)]
    39|         private void SetMaxConnectionsPerServer(int value) => InvokeNativeHandlerMethod("set_MaxConnectionsPerServer", value);
    40|         [DynamicDependency("get_MaxResponseHeadersLength", NativeHandlerType, AssemblyName)]
    41|         private int GetMaxResponseHeadersLength() => (int)InvokeNativeHandlerMethod("get_MaxResponseHeadersLength");
    42|         [DynamicDependency("set_MaxResponseHeadersLength", NativeHandlerType, AssemblyName)]
    43|         private void SetMaxResponseHeadersLength(int value) => InvokeNativeHandlerMethod("set_MaxResponseHeadersLength", value);
    44|         [DynamicDependency("get_ClientCertificateOptions", NativeHandlerType, AssemblyName)]
    45|         private ClientCertificateOption GetClientCertificateOptions() => (ClientCertificateOption)InvokeNativeHandlerMethod("get_ClientCertificateOptions");
    46|         [DynamicDependency("set_ClientCertificateOptions", NativeHandlerType, AssemblyName)]
    47|         private void SetClientCertificateOptions(ClientCertificateOption value) => InvokeNativeHandlerMethod("set_ClientCertificateOptions", value);
    48|         [DynamicDependency("get_ClientCertificates", NativeHandlerType, AssemblyName)]


# ====================================================================
# FILE: src/libraries/System.Net.NetworkInformation/ref/System.Net.NetworkInformation.cs
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 100-233 ---
   100|         public abstract bool IsDnsEligible { get; }
   101|         public abstract bool IsTransient { get; }
   102|     }
   103|     public partial class IPAddressInformationCollection : System.Collections.Generic.ICollection<System.Net.NetworkInformation.IPAddressInformation>, System.Collections.Generic.IEnumerable<System.Net.NetworkInformation.IPAddressInformation>, System.Collections.IEnumerable
   104|     {
   105|         internal IPAddressInformationCollection() { }
   106|         public virtual int Count { get { throw null; } }
   107|         public virtual bool IsReadOnly { get { throw null; } }
   108|         public virtual System.Net.NetworkInformation.IPAddressInformation this[int index] { get { throw null; } }
   109|         public virtual void Add(System.Net.NetworkInformation.IPAddressInformation address) { }
   110|         public virtual void Clear() { }
   111|         public virtual bool Contains(System.Net.NetworkInformation.IPAddressInformation address) { throw null; }
   112|         public virtual void CopyTo(System.Net.NetworkInformation.IPAddressInformation[] array, int offset) { }
   113|         public virtual System.Collections.Generic.IEnumerator<System.Net.NetworkInformation.IPAddressInformation> GetEnumerator() { throw null; }
   114|         public virtual bool Remove(System.Net.NetworkInformation.IPAddressInformation address) { throw null; }
   115|         System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { throw null; }
   116|     }
   117|     public abstract partial class IPGlobalProperties
   118|     {
   119|         protected IPGlobalProperties() { }
   120|         public abstract string DhcpScopeName { get; }
   121|         public abstract string DomainName { get; }
   122|         public abstract string HostName { get; }
   123|         public abstract bool IsWinsProxy { get; }
   124|         public abstract System.Net.NetworkInformation.NetBiosNodeType NodeType { get; }
   125|         public virtual System.IAsyncResult BeginGetUnicastAddresses(System.AsyncCallback? callback, object? state) { throw null; }
   126|         public virtual System.Net.NetworkInformation.UnicastIPAddressInformationCollection EndGetUnicastAddresses(System.IAsyncResult asyncResult) { throw null; }
   127|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   128|         public abstract System.Net.NetworkInformation.TcpConnectionInformation[] GetActiveTcpConnections();
   129|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   130|         public abstract System.Net.IPEndPoint[] GetActiveTcpListeners();
   131|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   132|         public abstract System.Net.IPEndPoint[] GetActiveUdpListeners();
   133|         public abstract System.Net.NetworkInformation.IcmpV4Statistics GetIcmpV4Statistics();
   134|         public abstract System.Net.NetworkInformation.IcmpV6Statistics GetIcmpV6Statistics();
   135|         [System.Runtime.Versioning.UnsupportedOSPlatform("illumos")]
   136|         [System.Runtime.Versioning.UnsupportedOSPlatform("solaris")]
   137|         public static System.Net.NetworkInformation.IPGlobalProperties GetIPGlobalProperties() { throw null; }
   138|         public abstract System.Net.NetworkInformation.IPGlobalStatistics GetIPv4GlobalStatistics();
   139|         public abstract System.Net.NetworkInformation.IPGlobalStatistics GetIPv6GlobalStatistics();
   140|         public abstract System.Net.NetworkInformation.TcpStatistics GetTcpIPv4Statistics();
   141|         public abstract System.Net.NetworkInformation.TcpStatistics GetTcpIPv6Statistics();
   142|         public abstract System.Net.NetworkInformation.UdpStatistics GetUdpIPv4Statistics();
   143|         public abstract System.Net.NetworkInformation.UdpStatistics GetUdpIPv6Statistics();
   144|         public virtual System.Net.NetworkInformation.UnicastIPAddressInformationCollection GetUnicastAddresses() { throw null; }
   145|         public virtual System.Threading.Tasks.Task<System.Net.NetworkInformation.UnicastIPAddressInformationCollection> GetUnicastAddressesAsync() { throw null; }
   146|     }
   147|     public abstract partial class IPGlobalStatistics
   148|     {
   149|         protected IPGlobalStatistics() { }
   150|         public abstract int DefaultTtl { get; }
   151|         public abstract bool ForwardingEnabled { get; }
   152|         public abstract int NumberOfInterfaces { get; }
   153|         public abstract int NumberOfIPAddresses { get; }
   154|         public abstract int NumberOfRoutes { get; }
   155|         public abstract long OutputPacketRequests { get; }
   156|         public abstract long OutputPacketRoutingDiscards { get; }
   157|         public abstract long OutputPacketsDiscarded { get; }
   158|         public abstract long OutputPacketsWithNoRoute { get; }
   159|         public abstract long PacketFragmentFailures { get; }
   160|         public abstract long PacketReassembliesRequired { get; }
   161|         public abstract long PacketReassemblyFailures { get; }
   162|         public abstract long PacketReassemblyTimeout { get; }
   163|         public abstract long PacketsFragmented { get; }
   164|         public abstract long PacketsReassembled { get; }
   165|         public abstract long ReceivedPackets { get; }
   166|         public abstract long ReceivedPacketsDelivered { get; }
   167|         public abstract long ReceivedPacketsDiscarded { get; }
   168|         public abstract long ReceivedPacketsForwarded { get; }
   169|         public abstract long ReceivedPacketsWithAddressErrors { get; }
   170|         public abstract long ReceivedPacketsWithHeadersErrors { get; }
   171|         public abstract long ReceivedPacketsWithUnknownProtocol { get; }
   172|     }
   173|     public abstract partial class IPInterfaceProperties
   174|     {
   175|         protected IPInterfaceProperties() { }
   176|         public abstract System.Net.NetworkInformation.IPAddressInformationCollection AnycastAddresses { get; }
   177|         public abstract System.Net.NetworkInformation.IPAddressCollection DhcpServerAddresses { get; }
   178|         public abstract System.Net.NetworkInformation.IPAddressCollection DnsAddresses { get; }
   179|         public abstract string DnsSuffix { get; }
   180|         public abstract System.Net.NetworkInformation.GatewayIPAddressInformationCollection GatewayAddresses { get; }
   181|         public abstract bool IsDnsEnabled { get; }
   182|         public abstract bool IsDynamicDnsEnabled { get; }
   183|         public abstract System.Net.NetworkInformation.MulticastIPAddressInformationCollection MulticastAddresses { get; }
   184|         public abstract System.Net.NetworkInformation.UnicastIPAddressInformationCollection UnicastAddresses { get; }
   185|         public abstract System.Net.NetworkInformation.IPAddressCollection WinsServersAddresses { get; }
   186|         public abstract System.Net.NetworkInformation.IPv4InterfaceProperties GetIPv4Properties();
   187|         public abstract System.Net.NetworkInformation.IPv6InterfaceProperties GetIPv6Properties();
   188|     }
   189|     public abstract partial class IPInterfaceStatistics
   190|     {
   191|         protected IPInterfaceStatistics() { }
   192|         public abstract long BytesReceived { get; }
   193|         public abstract long BytesSent { get; }
   194|         public abstract long IncomingPacketsDiscarded { get; }
   195|         public abstract long IncomingPacketsWithErrors { get; }
   196|         public abstract long IncomingUnknownProtocolPackets { get; }
   197|         public abstract long NonUnicastPacketsReceived { get; }
   198|         public abstract long NonUnicastPacketsSent { get; }
   199|         public abstract long OutgoingPacketsDiscarded { get; }
   200|         public abstract long OutgoingPacketsWithErrors { get; }
   201|         public abstract long OutputQueueLength { get; }
   202|         public abstract long UnicastPacketsReceived { get; }
   203|         public abstract long UnicastPacketsSent { get; }
   204|     }
   205|     public abstract partial class IPv4InterfaceProperties
   206|     {
   207|         protected IPv4InterfaceProperties() { }
   208|         public abstract int Index { get; }
   209|         public abstract bool IsAutomaticPrivateAddressingActive { get; }
   210|         public abstract bool IsAutomaticPrivateAddressingEnabled { get; }
   211|         public abstract bool IsDhcpEnabled { get; }
   212|         public abstract bool IsForwardingEnabled { get; }
   213|         public abstract int Mtu { get; }
   214|         public abstract bool UsesWins { get; }
   215|     }
   216|     public abstract partial class IPv4InterfaceStatistics
   217|     {
   218|         protected IPv4InterfaceStatistics() { }
   219|         public abstract long BytesReceived { get; }
   220|         public abstract long BytesSent { get; }
   221|         public abstract long IncomingPacketsDiscarded { get; }
   222|         public abstract long IncomingPacketsWithErrors { get; }
   223|         public abstract long IncomingUnknownProtocolPackets { get; }
   224|         public abstract long NonUnicastPacketsReceived { get; }
   225|         public abstract long NonUnicastPacketsSent { get; }
   226|         public abstract long OutgoingPacketsDiscarded { get; }
   227|         public abstract long OutgoingPacketsWithErrors { get; }
   228|         public abstract long OutputQueueLength { get; }
   229|         public abstract long UnicastPacketsReceived { get; }
   230|         public abstract long UnicastPacketsSent { get; }
   231|     }
   232|     public abstract partial class IPv6InterfaceProperties
   233|     {

# --- HUNK 2: Lines 293-333 ---
   293|         protected NetworkInformationException(System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext) { }
   294|         public override int ErrorCode { get { throw null; } }
   295|     }
   296|     public abstract partial class NetworkInterface
   297|     {
   298|         protected NetworkInterface() { }
   299|         public virtual string Description { get { throw null; } }
   300|         public virtual string Id { get { throw null; } }
   301|         public static int IPv6LoopbackInterfaceIndex { get { throw null; } }
   302|         public virtual bool IsReceiveOnly { get { throw null; } }
   303|         public static int LoopbackInterfaceIndex { get { throw null; } }
   304|         public virtual string Name { get { throw null; } }
   305|         public virtual System.Net.NetworkInformation.NetworkInterfaceType NetworkInterfaceType { get { throw null; } }
   306|         public virtual System.Net.NetworkInformation.OperationalStatus OperationalStatus { get { throw null; } }
   307|         public virtual long Speed { get { throw null; } }
   308|         public virtual bool SupportsMulticast { get { throw null; } }
   309|         [System.Runtime.Versioning.UnsupportedOSPlatform("illumos")]
   310|         [System.Runtime.Versioning.UnsupportedOSPlatform("solaris")]
   311|         public static System.Net.NetworkInformation.NetworkInterface[] GetAllNetworkInterfaces() { throw null; }
   312|         public virtual System.Net.NetworkInformation.IPInterfaceProperties GetIPProperties() { throw null; }
   313|         public virtual System.Net.NetworkInformation.IPInterfaceStatistics GetIPStatistics() { throw null; }
   314|         public virtual System.Net.NetworkInformation.IPv4InterfaceStatistics GetIPv4Statistics() { throw null; }
   315|         [System.Runtime.Versioning.UnsupportedOSPlatform("illumos")]
   316|         [System.Runtime.Versioning.UnsupportedOSPlatform("solaris")]
   317|         public static bool GetIsNetworkAvailable() { throw null; }
   318|         public virtual System.Net.NetworkInformation.PhysicalAddress GetPhysicalAddress() { throw null; }
   319|         public virtual bool Supports(System.Net.NetworkInformation.NetworkInterfaceComponent networkInterfaceComponent) { throw null; }
   320|     }
   321|     public enum NetworkInterfaceComponent
   322|     {
   323|         IPv4 = 0,
   324|         IPv6 = 1,
   325|     }
   326|     public enum NetworkInterfaceType
   327|     {
   328|         Unknown = 1,
   329|         Ethernet = 6,
   330|         TokenRing = 9,
   331|         Fddi = 15,
   332|         BasicIsdn = 20,
   333|         PrimaryIsdn = 21,


# ====================================================================
# FILE: src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/IPGlobalProperties.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-49 ---
     1| using System.Runtime.Versioning;
     2| using System.Threading.Tasks;
     3| namespace System.Net.NetworkInformation
     4| {
     5|     public abstract class IPGlobalProperties
     6|     {
     7|         [UnsupportedOSPlatform("illumos")]
     8|         [UnsupportedOSPlatform("solaris")]
     9|         public static IPGlobalProperties GetIPGlobalProperties()
    10|         {
    11|             return IPGlobalPropertiesPal.GetIPGlobalProperties();
    12|         }
    13|         [UnsupportedOSPlatform("android")]
    14|         public abstract IPEndPoint[] GetActiveUdpListeners();
    15|         [UnsupportedOSPlatform("android")]
    16|         public abstract IPEndPoint[] GetActiveTcpListeners();
    17|         [UnsupportedOSPlatform("android")]
    18|         public abstract TcpConnectionInformation[] GetActiveTcpConnections();
    19|         public abstract string DhcpScopeName { get; }
    20|         public abstract string DomainName { get; }
    21|         public abstract string HostName { get; }
    22|         public abstract bool IsWinsProxy { get; }
    23|         public abstract NetBiosNodeType NodeType { get; }
    24|         public virtual IAsyncResult BeginGetUnicastAddresses(AsyncCallback? callback, object? state)
    25|         {
    26|             throw NotImplemented.ByDesignWithMessage(SR.net_MethodNotImplementedException);
    27|         }
    28|         public virtual UnicastIPAddressInformationCollection EndGetUnicastAddresses(IAsyncResult asyncResult)
    29|         {
    30|             throw NotImplemented.ByDesignWithMessage(SR.net_MethodNotImplementedException);
    31|         }
    32|         public abstract TcpStatistics GetTcpIPv4Statistics();
    33|         public abstract TcpStatistics GetTcpIPv6Statistics();
    34|         public abstract UdpStatistics GetUdpIPv4Statistics();
    35|         public abstract UdpStatistics GetUdpIPv6Statistics();
    36|         public abstract IcmpV4Statistics GetIcmpV4Statistics();
    37|         public abstract IcmpV6Statistics GetIcmpV6Statistics();
    38|         public abstract IPGlobalStatistics GetIPv4GlobalStatistics();
    39|         public abstract IPGlobalStatistics GetIPv6GlobalStatistics();
    40|         public virtual UnicastIPAddressInformationCollection GetUnicastAddresses()
    41|         {
    42|             throw NotImplemented.ByDesignWithMessage(SR.net_MethodNotImplementedException);
    43|         }
    44|         public virtual Task<UnicastIPAddressInformationCollection> GetUnicastAddressesAsync()
    45|         {
    46|             throw NotImplemented.ByDesignWithMessage(SR.net_MethodNotImplementedException);
    47|         }
    48|     }
    49| }


# ====================================================================
# FILE: src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/IPGlobalStatistics.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-28 ---
     1| namespace System.Net.NetworkInformation
     2| {
     3|     public abstract class IPGlobalStatistics
     4|     {
     5|         public abstract int DefaultTtl { get; }
     6|         public abstract bool ForwardingEnabled { get; }
     7|         public abstract int NumberOfInterfaces { get; }
     8|         public abstract int NumberOfIPAddresses { get; }
     9|         public abstract long OutputPacketRequests { get; }
    10|         public abstract long OutputPacketRoutingDiscards { get; }
    11|         public abstract long OutputPacketsDiscarded { get; }
    12|         public abstract long OutputPacketsWithNoRoute { get; }
    13|         public abstract long PacketFragmentFailures { get; }
    14|         public abstract long PacketReassembliesRequired { get; }
    15|         public abstract long PacketReassemblyFailures { get; }
    16|         public abstract long PacketReassemblyTimeout { get; }
    17|         public abstract long PacketsFragmented { get; }
    18|         public abstract long PacketsReassembled { get; }
    19|         public abstract long ReceivedPackets { get; }
    20|         public abstract long ReceivedPacketsDelivered { get; }
    21|         public abstract long ReceivedPacketsDiscarded { get; }
    22|         public abstract long ReceivedPacketsForwarded { get; }
    23|         public abstract long ReceivedPacketsWithAddressErrors { get; }
    24|         public abstract long ReceivedPacketsWithHeadersErrors { get; }
    25|         public abstract long ReceivedPacketsWithUnknownProtocol { get; }
    26|         public abstract int NumberOfRoutes { get; }
    27|     }
    28| }


# ====================================================================
# FILE: src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/IPInterfaceProperties.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-18 ---
     1| namespace System.Net.NetworkInformation
     2| {
     3|     public abstract class IPInterfaceProperties
     4|     {
     5|         public abstract bool IsDnsEnabled { get; }
     6|         public abstract string DnsSuffix { get; }
     7|         public abstract bool IsDynamicDnsEnabled { get; }
     8|         public abstract UnicastIPAddressInformationCollection UnicastAddresses { get; }
     9|         public abstract MulticastIPAddressInformationCollection MulticastAddresses { get; }
    10|         public abstract IPAddressInformationCollection AnycastAddresses { get; }
    11|         public abstract IPAddressCollection DnsAddresses { get; }
    12|         public abstract GatewayIPAddressInformationCollection GatewayAddresses { get; }
    13|         public abstract IPAddressCollection DhcpServerAddresses { get; }
    14|         public abstract IPAddressCollection WinsServersAddresses { get; }
    15|         public abstract IPv4InterfaceProperties GetIPv4Properties();
    16|         public abstract IPv6InterfaceProperties GetIPv6Properties();
    17|     }
    18| }


# ====================================================================
# FILE: src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/IPv4InterfaceProperties.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-13 ---
     1| namespace System.Net.NetworkInformation
     2| {
     3|     public abstract class IPv4InterfaceProperties
     4|     {
     5|         public abstract bool UsesWins { get; }
     6|         public abstract bool IsDhcpEnabled { get; }
     7|         public abstract bool IsAutomaticPrivateAddressingActive { get; }
     8|         public abstract bool IsAutomaticPrivateAddressingEnabled { get; }
     9|         public abstract int Index { get; }
    10|         public abstract bool IsForwardingEnabled { get; }
    11|         public abstract int Mtu { get; }
    12|     }
    13| }


# ====================================================================
# FILE: src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/NetworkInterface.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 23-65 ---
    23|             {
    24|                 return NetworkInterfacePal.IPv6LoopbackInterfaceIndex;
    25|             }
    26|         }
    27|         [UnsupportedOSPlatform("illumos")]
    28|         [UnsupportedOSPlatform("solaris")]
    29|         public static int LoopbackInterfaceIndex
    30|         {
    31|             get
    32|             {
    33|                 return NetworkInterfacePal.LoopbackInterfaceIndex;
    34|             }
    35|         }
    36|         public virtual string Id { get { throw NotImplemented.ByDesignWithMessage(SR.net_PropertyNotImplementedException); } }
    37|         public virtual string Name { get { throw NotImplemented.ByDesignWithMessage(SR.net_PropertyNotImplementedException); } }
    38|         public virtual string Description { get { throw NotImplemented.ByDesignWithMessage(SR.net_PropertyNotImplementedException); } }
    39|         public virtual IPInterfaceProperties GetIPProperties()
    40|         {
    41|             throw NotImplemented.ByDesignWithMessage(SR.net_MethodNotImplementedException);
    42|         }
    43|         public virtual IPInterfaceStatistics GetIPStatistics()
    44|         {
    45|             throw NotImplemented.ByDesignWithMessage(SR.net_MethodNotImplementedException);
    46|         }
    47|         public virtual IPv4InterfaceStatistics GetIPv4Statistics()
    48|         {
    49|             throw NotImplemented.ByDesignWithMessage(SR.net_MethodNotImplementedException);
    50|         }
    51|         public virtual OperationalStatus OperationalStatus { get { throw NotImplemented.ByDesignWithMessage(SR.net_PropertyNotImplementedException); } }
    52|         public virtual long Speed { get { throw NotImplemented.ByDesignWithMessage(SR.net_PropertyNotImplementedException); } }
    53|         public virtual bool IsReceiveOnly { get { throw NotImplemented.ByDesignWithMessage(SR.net_PropertyNotImplementedException); } }
    54|         public virtual bool SupportsMulticast { get { throw NotImplemented.ByDesignWithMessage(SR.net_PropertyNotImplementedException); } }
    55|         public virtual PhysicalAddress GetPhysicalAddress()
    56|         {
    57|             throw NotImplemented.ByDesignWithMessage(SR.net_MethodNotImplementedException);
    58|         }
    59|         public virtual NetworkInterfaceType NetworkInterfaceType { get { throw NotImplemented.ByDesignWithMessage(SR.net_PropertyNotImplementedException); } }
    60|         public virtual bool Supports(NetworkInterfaceComponent networkInterfaceComponent)
    61|         {
    62|             throw NotImplemented.ByDesignWithMessage(SR.net_MethodNotImplementedException);
    63|         }
    64|     }
    65| }


# ====================================================================
# FILE: src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/UnixIPGlobalProperties.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-41 ---
     1| using System.Collections.Generic;
     2| using System.Runtime.CompilerServices;
     3| using System.Runtime.InteropServices;
     4| using System.Runtime.Versioning;
     5| using System.Threading;
     6| using System.Threading.Tasks;
     7| namespace System.Net.NetworkInformation
     8| {
     9|     internal abstract class UnixIPGlobalProperties : IPGlobalProperties
    10|     {
    11|         [UnsupportedOSPlatform("linux")]
    12|         [UnsupportedOSPlatform("osx")]
    13|         [UnsupportedOSPlatform("ios")]
    14|         [UnsupportedOSPlatform("tvos")]
    15|         [UnsupportedOSPlatform("freebsd")]
    16|         [UnsupportedOSPlatform("illumos")]
    17|         [UnsupportedOSPlatform("solaris")]
    18|         public override string DhcpScopeName { get { throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform); } }
    19|         public override string DomainName { get { return HostInformation.DomainName; } }
    20|         public override string HostName { get { return HostInformation.HostName; } }
    21|         [UnsupportedOSPlatform("linux")]
    22|         [UnsupportedOSPlatform("osx")]
    23|         [UnsupportedOSPlatform("ios")]
    24|         [UnsupportedOSPlatform("tvos")]
    25|         [UnsupportedOSPlatform("freebsd")]
    26|         [UnsupportedOSPlatform("illumos")]
    27|         [UnsupportedOSPlatform("solaris")]
    28|         public override bool IsWinsProxy { get { throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform); } }
    29|         public override NetBiosNodeType NodeType { get { return NetBiosNodeType.Unknown; } }
    30|         public override IAsyncResult BeginGetUnicastAddresses(AsyncCallback? callback, object? state)
    31|         {
    32|             Task<UnicastIPAddressInformationCollection> t = GetUnicastAddressesAsync();
    33|             return TaskToApm.Begin(t, callback, state);
    34|         }
    35|         public override UnicastIPAddressInformationCollection EndGetUnicastAddresses(IAsyncResult asyncResult)
    36|         {
    37|             return TaskToApm.End<UnicastIPAddressInformationCollection>(asyncResult);
    38|         }
    39|         public sealed override Task<UnicastIPAddressInformationCollection> GetUnicastAddressesAsync()
    40|         {
    41|             return Task.Factory.StartNew(s => ((UnixIPGlobalProperties)s!).GetUnicastAddresses(), this,


# ====================================================================
# FILE: src/libraries/System.Net.Security/src/System/Net/Security/CipherSuitesPolicyPal.Linux.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 3-43 ---
     3| using System.Diagnostics;
     4| using System.IO;
     5| using System.Security.Authentication;
     6| using System.Text;
     7| using Ssl = Interop.Ssl;
     8| using OpenSsl = Interop.OpenSsl;
     9| namespace System.Net.Security
    10| {
    11|     internal sealed class CipherSuitesPolicyPal
    12|     {
    13|         private static readonly byte[] AllowNoEncryptionDefault =
    14|             Encoding.ASCII.GetBytes("ALL:eNULL\0");
    15|         private static readonly byte[] NoEncryptionDefault =
    16|             Encoding.ASCII.GetBytes("eNULL\0");
    17|         private byte[] _cipherSuites;
    18|         private byte[] _tls13CipherSuites;
    19|         private List<TlsCipherSuite> _tlsCipherSuites = new List<TlsCipherSuite>();
    20|         internal IEnumerable<TlsCipherSuite> GetCipherSuites() => _tlsCipherSuites;
    21|         internal CipherSuitesPolicyPal(IEnumerable<TlsCipherSuite> allowedCipherSuites)
    22|         {
    23|             if (!Interop.Ssl.Tls13Supported)
    24|             {
    25|                 throw new PlatformNotSupportedException(SR.net_ssl_ciphersuites_policy_not_supported);
    26|             }
    27|             using (SafeSslContextHandle innerContext = Ssl.SslCtxCreate(Ssl.SslMethods.SSLv23_method))
    28|             {
    29|                 if (innerContext.IsInvalid)
    30|                 {
    31|                     throw OpenSsl.CreateSslException(SR.net_allocate_ssl_context_failed);
    32|                 }
    33|                 using (SafeSslHandle ssl = SafeSslHandle.Create(innerContext, false))
    34|                 {
    35|                     if (ssl.IsInvalid)
    36|                     {
    37|                         throw OpenSsl.CreateSslException(SR.net_allocate_ssl_context_failed);
    38|                     }
    39|                     using (var tls13CipherSuites = new OpenSslStringBuilder())
    40|                     using (var cipherSuites = new OpenSslStringBuilder())
    41|                     {
    42|                         foreach (TlsCipherSuite cs in allowedCipherSuites)
    43|                         {


# ====================================================================
# FILE: src/libraries/System.Private.CoreLib/src/System/DateOnly.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 343-390 ---
   343|                         }
   344|                         charsWritten = 10;
   345|                         return true;
   346|                     case 'r':
   347|                     case 'R':
   348|                         if (!DateTimeFormat.TryFormatDateOnlyR(DayOfWeek, Year, Month, Day, destination))
   349|                         {
   350|                             charsWritten = 0;
   351|                             return false;
   352|                         }
   353|                         charsWritten = 16;
   354|                         return true;
   355|                     case 'm':
   356|                     case 'M':
   357|                     case 'd':
   358|                     case 'D':
   359|                     case 'y':
   360|                     case 'Y':
   361|                         return DateTimeFormat.TryFormat(GetEquivalentDateTime(), destination, out charsWritten, format, provider);
   362|                     default:
   363|                         charsWritten = 0;
   364|                         return false;
   365|                 }
   366|             }
   367|             if (!DateTimeFormat.IsValidCustomDateFormat(format, throwOnError: false))
   368|             {
   369|                 charsWritten = 0;
   370|                 return false;
   371|             }
   372|             return DateTimeFormat.TryFormat(GetEquivalentDateTime(), destination, out charsWritten, format, provider);
   373|         }
   374| #if FEATURE_GENERIC_MATH
   375|         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]
   376|         static bool IComparisonOperators<DateOnly, DateOnly>.operator <(DateOnly left, DateOnly right)
   377|             => left < right;
   378|         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]
   379|         static bool IComparisonOperators<DateOnly, DateOnly>.operator <=(DateOnly left, DateOnly right)
   380|             => left <= right;
   381|         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]
   382|         static bool IComparisonOperators<DateOnly, DateOnly>.operator >(DateOnly left, DateOnly right)
   383|             => left > right;
   384|         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]
   385|         static bool IComparisonOperators<DateOnly, DateOnly>.operator >=(DateOnly left, DateOnly right)
   386|             => left >= right;
   387|         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]
   388|         static bool IEqualityOperators<DateOnly, DateOnly>.operator ==(DateOnly left, DateOnly right)
   389|             => left == right;
   390|         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]


# ====================================================================
# FILE: src/libraries/System.Private.CoreLib/src/System/Globalization/DateTimeFormat.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 31-72 ---
    31|         "ffffff"    "000000"    second fraction (6 digit)
    32|         "fffffff"   "0000000"   second fraction (7 digit)
    33|         "F"     "0"         second fraction (up to 1 digit)
    34|         "FF"    "00"        second fraction (up to 2 digit)
    35|         "FFF"   "000"       second fraction (up to 3 digit)
    36|         "FFFF"  "0000"      second fraction (up to 4 digit)
    37|         "FFFFF" "00000"         second fraction (up to 5 digit)
    38|         "FFFFFF"    "000000"    second fraction (up to 6 digit)
    39|         "FFFFFFF"   "0000000"   second fraction (up to 7 digit)
    40|         "t"                 first character of AM/PM designator   A
    41|         "tt"                AM/PM designator                      AM
    42|         "tt*"               AM/PM designator                      PM
    43|         "d"     "0"         day w/o leading zero                  1
    44|         "dd"    "00"        day with leading zero                 01
    45|         "ddd"               short weekday name (abbreviation)     Mon
    46|         "dddd"              full weekday name                     Monday
    47|         "dddd*"             full weekday name                     Monday
    48|         "M"     "0"         month w/o leading zero                2
    49|         "MM"    "00"        month with leading zero               02
    50|         "MMM"               short month name (abbreviation)       Feb
    51|         "MMMM"              full month name                       Febuary
    52|         "MMMM*"             full month name                       Febuary
    53|         "y"     "0"         two digit year (year % 100) w/o leading zero           0
    54|         "yy"    "00"        two digit year (year % 100) with leading zero          00
    55|         "yyy"   "D3"        year                                  2000
    56|         "yyyy"  "D4"        year                                  2000
    57|         "yyyyy" "D5"        year                                  2000
    58|         ...
    59|         "z"     "+0;-0"     timezone offset w/o leading zero      -8
    60|         "zz"    "+00;-00"   timezone offset with leading zero     -08
    61|         "zzz"      "+00;-00" for hour offset, "00" for minute offset  full timezone offset   -07:30
    62|         "zzz*"  "+00;-00" for hour offset, "00" for minute offset   full timezone offset   -08:00
    63|         "K"    -Local       "zzz", e.g. -08:00
    64|                -Utc         "'Z'", representing UTC
    65|                -Unspecified ""
    66|                -DateTimeOffset      "zzzzz" e.g -07:30:15
    67|         "g*"                the current era name                  A.D.
    68|         ":"                 time separator                        : -- DEPRECATED - Insert separator directly into pattern (eg: "H.mm.ss")
    69|         "/"                 date separator                        /-- DEPRECATED - Insert separator directly into pattern (eg: "M-dd-yyyy")
    70|         "'"                 quoted string                         'ABC' will insert ABC into the formatted string.
    71|         '"'                 quoted string                         "ABC" will insert ABC into the formatted string.
    72|         "%"                 used to quote a single pattern characters      E.g.The format character "%y" is to print two digit year.


# ====================================================================
# FILE: src/libraries/System.Private.CoreLib/src/System/Number.BigInteger.cs
# Total hunks: 9
# ====================================================================
# --- HUNK 1: Lines 1-36 ---
     1| using System.Diagnostics;
     2| using System.Numerics;
     3| using System.Runtime.InteropServices;
     4| using Internal.Runtime.CompilerServices;
     5| namespace System
     6| {
     7|     internal static partial class Number
     8|     {
     9|         [StructLayout(LayoutKind.Sequential, Pack = 1)]
    10|         internal unsafe ref struct BigInteger
    11|         {
    12|             private const int BitsForLongestBinaryMantissa = 1074;
    13|             private const int BitsForLongestDigitSequence = 2552;
    14|             private const int MaxBits = BitsForLongestBinaryMantissa + BitsForLongestDigitSequence + BitsPerBlock;
    15|             private const int BitsPerBlock = sizeof(int) * 8;
    16|             private const int MaxBlockCount = (MaxBits + (BitsPerBlock - 1)) / BitsPerBlock;
    17|             private static readonly uint[] s_Pow10UInt32Table = new uint[]
    18|             {
    19|                 1,          // 10^0
    20|                 10,         // 10^1
    21|                 100,        // 10^2
    22|                 1000,       // 10^3
    23|                 10000,      // 10^4
    24|                 100000,     // 10^5
    25|                 1000000,    // 10^6
    26|                 10000000,   // 10^7
    27|                 100000000,  // 10^8
    28|                 1000000000  // 10^9
    29|             };
    30|             private static readonly int[] s_Pow10BigNumTableIndices = new int[]
    31|             {
    32|                 0,          // 10^8
    33|                 2,          // 10^16
    34|                 5,          // 10^32
    35|                 10,         // 10^64
    36|                 18,         // 10^128

# --- HUNK 2: Lines 256-330 ---
   256|                 0xA7E6BD2A,
   257|                 0xC1A6970C,
   258|                 0x47187094,
   259|                 0xD2DB49EF,
   260|                 0x926C3F5B,
   261|                 0xAE6209D4,
   262|                 0x2D433949,
   263|                 0x34F4A3C6,
   264|                 0xD4305D94,
   265|                 0xD9D61A05,
   266|                 0x00000325,
   267|                 0x00000000,
   268|                 0x00000000,
   269|                 0x00000000,
   270|                 0x00000000,
   271|                 0x00000000,
   272|                 0x00000000,
   273|                 0x00000000,
   274|                 0x00000000,
   275|                 0x00000000,
   276|             };
   277|             private int _length;
   278|             private fixed uint _blocks[MaxBlockCount];
   279|             public static void Add(ref BigInteger lhs, ref BigInteger rhs, out BigInteger result)
   280|             {
   281|                 ref BigInteger large = ref (lhs._length < rhs._length) ? ref rhs : ref lhs;
   282|                 ref BigInteger small = ref (lhs._length < rhs._length) ? ref lhs : ref rhs;
   283|                 int largeLength = large._length;
   284|                 int smallLength = small._length;
   285|                 result._length = largeLength;
   286|                 ulong carry = 0;
   287|                 int largeIndex = 0;
   288|                 int smallIndex = 0;
   289|                 int resultIndex = 0;
   290|                 while (smallIndex < smallLength)
   291|                 {
   292|                     ulong sum = carry + large._blocks[largeIndex] + small._blocks[smallIndex];
   293|                     carry = sum >> 32;
   294|                     result._blocks[resultIndex] = (uint)(sum);
   295|                     largeIndex++;
   296|                     smallIndex++;
   297|                     resultIndex++;
   298|                 }
   299|                 while (largeIndex < largeLength)
   300|                 {
   301|                     ulong sum = carry + large._blocks[largeIndex];
   302|                     carry = sum >> 32;
   303|                     result._blocks[resultIndex] = (uint)(sum);
   304|                     largeIndex++;
   305|                     resultIndex++;
   306|                 }
   307|                 if (carry != 0)
   308|                 {
   309|                     Debug.Assert(carry == 1);
   310|                     Debug.Assert((resultIndex == largeLength) && (largeLength < MaxBlockCount));
   311|                     result._blocks[resultIndex] = 1;
   312|                     result._length++;
   313|                 }
   314|             }
   315|             public static int Compare(ref BigInteger lhs, ref BigInteger rhs)
   316|             {
   317|                 Debug.Assert(unchecked((uint)(lhs._length)) <= MaxBlockCount);
   318|                 Debug.Assert(unchecked((uint)(rhs._length)) <= MaxBlockCount);
   319|                 int lhsLength = lhs._length;
   320|                 int rhsLength = rhs._length;
   321|                 int lengthDelta = (lhsLength - rhsLength);
   322|                 if (lengthDelta != 0)
   323|                 {
   324|                     return lengthDelta;
   325|                 }
   326|                 if (lhsLength == 0)
   327|                 {
   328|                     Debug.Assert(rhsLength == 0);
   329|                     return 0;
   330|                 }

# --- HUNK 3: Lines 545-655 ---
   545|                     if (value == 0)
   546|                     {
   547|                         SetZero(out result);
   548|                     }
   549|                     else
   550|                     {
   551|                         SetValue(out result, ref lhs);
   552|                     }
   553|                     return;
   554|                 }
   555|                 int lhsLength = lhs._length;
   556|                 int index = 0;
   557|                 uint carry = 0;
   558|                 while (index < lhsLength)
   559|                 {
   560|                     ulong product = ((ulong)(lhs._blocks[index]) * value) + carry;
   561|                     result._blocks[index] = (uint)(product);
   562|                     carry = (uint)(product >> 32);
   563|                     index++;
   564|                 }
   565|                 if (carry != 0)
   566|                 {
   567|                     Debug.Assert(unchecked((uint)(lhsLength)) + 1 <= MaxBlockCount);
   568|                     result._blocks[index] = carry;
   569|                     result._length = (lhsLength + 1);
   570|                 }
   571|                 else
   572|                 {
   573|                     result._length = lhsLength;
   574|                 }
   575|             }
   576|             public static void Multiply(ref BigInteger lhs, ref BigInteger rhs, out BigInteger result)
   577|             {
   578|                 if (lhs._length <= 1)
   579|                 {
   580|                     Multiply(ref rhs, lhs.ToUInt32(), out result);
   581|                     return;
   582|                 }
   583|                 if (rhs._length <= 1)
   584|                 {
   585|                     Multiply(ref lhs, rhs.ToUInt32(), out result);
   586|                     return;
   587|                 }
   588|                 ref readonly BigInteger large = ref lhs;
   589|                 int largeLength = lhs._length;
   590|                 ref readonly BigInteger small = ref rhs;
   591|                 int smallLength = rhs._length;
   592|                 if (largeLength < smallLength)
   593|                 {
   594|                     large = ref rhs;
   595|                     largeLength = rhs._length;
   596|                     small = ref lhs;
   597|                     smallLength = lhs._length;
   598|                 }
   599|                 int maxResultLength = smallLength + largeLength;
   600|                 Debug.Assert(unchecked((uint)(maxResultLength)) <= MaxBlockCount);
   601|                 result._length = maxResultLength;
   602|                 result.Clear((uint)maxResultLength);
   603|                 int smallIndex = 0;
   604|                 int resultStartIndex = 0;
   605|                 while (smallIndex < smallLength)
   606|                 {
   607|                     if (small._blocks[smallIndex] != 0)
   608|                     {
   609|                         int largeIndex = 0;
   610|                         int resultIndex = resultStartIndex;
   611|                         ulong carry = 0;
   612|                         do
   613|                         {
   614|                             ulong product = result._blocks[resultIndex] + ((ulong)(small._blocks[smallIndex]) * large._blocks[largeIndex]) + carry;
   615|                             carry = product >> 32;
   616|                             result._blocks[resultIndex] = (uint)(product);
   617|                             resultIndex++;
   618|                             largeIndex++;
   619|                         }
   620|                         while (largeIndex < largeLength);
   621|                         result._blocks[resultIndex] = (uint)(carry);
   622|                     }
   623|                     smallIndex++;
   624|                     resultStartIndex++;
   625|                 }
   626|                 if ((maxResultLength > 0) && (result._blocks[maxResultLength - 1] == 0))
   627|                 {
   628|                     result._length--;
   629|                 }
   630|             }
   631|             public static void Pow2(uint exponent, out BigInteger result)
   632|             {
   633|                 uint blocksToShift = DivRem32(exponent, out uint remainingBitsToShift);
   634|                 result._length = (int)blocksToShift + 1;
   635|                 Debug.Assert(unchecked((uint)result._length) <= MaxBlockCount);
   636|                 if (blocksToShift > 0)
   637|                 {
   638|                     result.Clear(blocksToShift);
   639|                 }
   640|                 result._blocks[blocksToShift] = 1U << (int)(remainingBitsToShift);
   641|             }
   642|             public static void Pow10(uint exponent, out BigInteger result)
   643|             {
   644|                 Debug.Assert((s_Pow10BigNumTableIndices[^1] + MaxBlockCount + 2) == s_Pow10BigNumTable.Length);
   645|                 SetUInt32(out BigInteger temp1, s_Pow10UInt32Table[exponent & 0x7]);
   646|                 ref BigInteger lhs = ref temp1;
   647|                 SetZero(out BigInteger temp2);
   648|                 ref BigInteger product = ref temp2;
   649|                 exponent >>= 3;
   650|                 uint index = 0;
   651|                 while (exponent != 0)
   652|                 {
   653|                     if ((exponent & 1) != 0)
   654|                     {
   655|                         fixed (uint* pBigNumEntry = &s_Pow10BigNumTable[s_Pow10BigNumTableIndices[index]])

# --- HUNK 4: Lines 727-767 ---
   727|             {
   728|                 int length = _length;
   729|                 if (length == 0)
   730|                 {
   731|                     SetUInt32(out this, value);
   732|                     return;
   733|                 }
   734|                 _blocks[0] += value;
   735|                 if (_blocks[0] >= value)
   736|                 {
   737|                     return;
   738|                 }
   739|                 for (int index = 1; index < length; index++)
   740|                 {
   741|                     _blocks[index]++;
   742|                     if (_blocks[index] > 0)
   743|                     {
   744|                         return;
   745|                     }
   746|                 }
   747|                 Debug.Assert(unchecked((uint)(length)) + 1 <= MaxBlockCount);
   748|                 _blocks[length] = 1;
   749|                 _length = length + 1;
   750|             }
   751|             public uint GetBlock(uint index)
   752|             {
   753|                 Debug.Assert(index < _length);
   754|                 return _blocks[index];
   755|             }
   756|             public int GetLength()
   757|             {
   758|                 return _length;
   759|             }
   760|             public bool IsZero()
   761|             {
   762|                 return _length == 0;
   763|             }
   764|             public void Multiply(uint value)
   765|             {
   766|                 Multiply(ref this, value, out this);
   767|             }

# --- HUNK 5: Lines 779-821 ---
   779|             }
   780|             public void Multiply10()
   781|             {
   782|                 if (IsZero())
   783|                 {
   784|                     return;
   785|                 }
   786|                 int index = 0;
   787|                 int length = _length;
   788|                 ulong carry = 0;
   789|                 do
   790|                 {
   791|                     ulong block = (ulong)(_blocks[index]);
   792|                     ulong product = (block << 3) + (block << 1) + carry;
   793|                     carry = product >> 32;
   794|                     _blocks[index] = (uint)(product);
   795|                     index++;
   796|                 } while (index < length);
   797|                 if (carry != 0)
   798|                 {
   799|                     Debug.Assert(unchecked((uint)(_length)) + 1 <= MaxBlockCount);
   800|                     _blocks[index] = (uint)carry;
   801|                     _length++;
   802|                 }
   803|             }
   804|             public void MultiplyPow10(uint exponent)
   805|             {
   806|                 if (exponent <= 9)
   807|                 {
   808|                     Multiply(s_Pow10UInt32Table[exponent]);
   809|                 }
   810|                 else if (!IsZero())
   811|                 {
   812|                     Pow10(exponent, out BigInteger poweredValue);
   813|                     Multiply(ref poweredValue);
   814|                 }
   815|             }
   816|             public static void SetUInt32(out BigInteger result, uint value)
   817|             {
   818|                 if (value == 0)
   819|                 {
   820|                     SetZero(out result);
   821|                 }

# --- HUNK 6: Lines 843-896 ---
   843|                 int rhsLength = value._length;
   844|                 result._length = rhsLength;
   845|                 Buffer.Memmove(ref result._blocks[0], ref value._blocks[0], (nuint)rhsLength);
   846|             }
   847|             public static void SetZero(out BigInteger result)
   848|             {
   849|                 result._length = 0;
   850|             }
   851|             public void ShiftLeft(uint shift)
   852|             {
   853|                 int length = _length;
   854|                 if ((length == 0) || (shift == 0))
   855|                 {
   856|                     return;
   857|                 }
   858|                 uint blocksToShift = DivRem32(shift, out uint remainingBitsToShift);
   859|                 int readIndex = (length - 1);
   860|                 int writeIndex = readIndex + (int)(blocksToShift);
   861|                 if (remainingBitsToShift == 0)
   862|                 {
   863|                     Debug.Assert(writeIndex < MaxBlockCount);
   864|                     while (readIndex >= 0)
   865|                     {
   866|                         _blocks[writeIndex] = _blocks[readIndex];
   867|                         readIndex--;
   868|                         writeIndex--;
   869|                     }
   870|                     _length += (int)(blocksToShift);
   871|                     Clear(blocksToShift);
   872|                 }
   873|                 else
   874|                 {
   875|                     writeIndex++;
   876|                     Debug.Assert(writeIndex < MaxBlockCount);
   877|                     _length = writeIndex + 1;
   878|                     uint lowBitsShift = (32 - remainingBitsToShift);
   879|                     uint highBits = 0;
   880|                     uint block = _blocks[readIndex];
   881|                     uint lowBits = block >> (int)(lowBitsShift);
   882|                     while (readIndex > 0)
   883|                     {
   884|                         _blocks[writeIndex] = highBits | lowBits;
   885|                         highBits = block << (int)(remainingBitsToShift);
   886|                         --readIndex;
   887|                         --writeIndex;
   888|                         block = _blocks[readIndex];
   889|                         lowBits = block >> (int)lowBitsShift;
   890|                     }
   891|                     _blocks[writeIndex] = highBits | lowBits;
   892|                     _blocks[writeIndex - 1] = block << (int)(remainingBitsToShift);
   893|                     Clear(blocksToShift);
   894|                     if (_blocks[_length - 1] == 0)
   895|                     {
   896|                         _length--;


# ====================================================================
# FILE: src/libraries/System.Private.CoreLib/src/System/Runtime/InteropServices/NFloat.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| using System.Diagnostics.CodeAnalysis;
     2| using System.Runtime.CompilerServices;
     3| #pragma warning disable SA1121 // We use our own aliases since they differ per platform
     4| #if TARGET_32BIT
     5| using NativeType = System.Single;
     6| #else
     7| using NativeType = System.Double;
     8| #endif
     9| namespace System.Runtime.InteropServices
    10| {
    11|     [Intrinsic]
    12|     public readonly struct NFloat : IEquatable<NFloat>
    13|     {
    14|         private readonly NativeType _value;
    15|         public NFloat(float value)
    16|         {
    17|             _value = value;
    18|         }
    19|         public NFloat(double value)
    20|         {
    21|             _value = (NativeType)value;
    22|         }
    23|         public double Value => _value;
    24|         public override bool Equals([NotNullWhen(true)] object? o) => o is NFloat other && Equals(other);
    25|         public bool Equals(NFloat other) => _value.Equals(other._value);
    26|         public override int GetHashCode() => _value.GetHashCode();
    27|         public override string ToString() => _value.ToString();
    28|     }
    29| }


# ====================================================================
# FILE: src/libraries/System.Private.CoreLib/src/System/TimeOnly.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 359-406 ---
   359|                         if (!DateTimeFormat.TryFormatTimeOnlyO(Hour, Minute, Second, _ticks % TimeSpan.TicksPerSecond, destination))
   360|                         {
   361|                             charsWritten = 0;
   362|                             return false;
   363|                         }
   364|                         charsWritten = 16;
   365|                         return true;
   366|                     case 'r':
   367|                     case 'R':
   368|                         if (!DateTimeFormat.TryFormatTimeOnlyR(Hour, Minute, Second, destination))
   369|                         {
   370|                             charsWritten = 0;
   371|                             return false;
   372|                         }
   373|                         charsWritten = 8;
   374|                         return true;
   375|                     case 't':
   376|                     case 'T':
   377|                         return DateTimeFormat.TryFormat(ToDateTime(), destination, out charsWritten, format, provider);
   378|                     default:
   379|                         charsWritten = 0;
   380|                         return false;
   381|                 }
   382|             }
   383|             if (!DateTimeFormat.IsValidCustomTimeFormat(format, throwOnError: false))
   384|             {
   385|                 charsWritten = 0;
   386|                 return false;
   387|             }
   388|             return DateTimeFormat.TryFormat(ToDateTime(), destination, out charsWritten, format, provider);
   389|         }
   390| #if FEATURE_GENERIC_MATH
   391|         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]
   392|         static bool IComparisonOperators<TimeOnly, TimeOnly>.operator <(TimeOnly left, TimeOnly right)
   393|             => left < right;
   394|         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]
   395|         static bool IComparisonOperators<TimeOnly, TimeOnly>.operator <=(TimeOnly left, TimeOnly right)
   396|             => left <= right;
   397|         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]
   398|         static bool IComparisonOperators<TimeOnly, TimeOnly>.operator >(TimeOnly left, TimeOnly right)
   399|             => left > right;
   400|         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]
   401|         static bool IComparisonOperators<TimeOnly, TimeOnly>.operator >=(TimeOnly left, TimeOnly right)
   402|             => left >= right;
   403|         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]
   404|         static bool IEqualityOperators<TimeOnly, TimeOnly>.operator ==(TimeOnly left, TimeOnly right)
   405|             => left == right;
   406|         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]


# ====================================================================
# FILE: src/libraries/System.Private.CoreLib/src/System/TimeZoneInfo.Unix.Android.cs
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 147-288 ---
   147|         * data offset - 4 bytes that denotes the offset at which the data of the tzdata file starts
   148|         * final offset - 4 bytes that used to denote the final offset, which we don't use but will note.
   149|         *
   150|         * Each Data Entry (52 bytes) can be used to generate a TimeZoneInfo and contain the following information
   151|         * id - 40 bytes that contain the id of the time zone data entry timezone<id>
   152|         * byte offset - 4 bytes that denote the offset from the data offset timezone<id> data can be found
   153|         * length - 4 bytes that denote the length of the data for timezone<id>
   154|         * unused - 4 bytes that used to be raw GMT offset, but now is always 0 since tzdata2014f (L).
   155|         *
   156|         * This is needed in order to read Android v4.3 tzdata files.
   157|         *
   158|         * Android 10+ moved the up-to-date tzdata location to a module updatable via the Google Play Store and the
   159|         * database location changed (https://source.android.com/devices/architecture/modular-system/runtime#time-zone-data-interactions)
   160|         * The older locations still exist (at least the `/system/usr/share/zoneinfo` one) but they won't be updated.
   161|         */
   162|         private sealed class AndroidTzData
   163|         {
   164|             private string[] _ids;
   165|             private int[] _byteOffsets;
   166|             private int[] _lengths;
   167|             private string _tzFileDir;
   168|             private string _tzFilePath;
   169|             private static string GetApexTimeDataRoot()
   170|             {
   171|                 string? ret = Environment.GetEnvironmentVariable("ANDROID_TZDATA_ROOT");
   172|                 if (!string.IsNullOrEmpty(ret))
   173|                 {
   174|                     return ret;
   175|                 }
   176|                 return "/apex/com.android.tzdata";
   177|             }
   178|             private static string GetApexRuntimeRoot()
   179|             {
   180|                 string? ret = Environment.GetEnvironmentVariable("ANDROID_RUNTIME_ROOT");
   181|                 if (!string.IsNullOrEmpty(ret))
   182|                 {
   183|                     return ret;
   184|                 }
   185|                 return "/apex/com.android.runtime";
   186|             }
   187|             public AndroidTzData()
   188|             {
   189|                 string[] tzFileDirList = new string[] {GetApexTimeDataRoot() + "/etc/tz/", // Android 10+, TimeData module where the updates land
   190|                                                        GetApexRuntimeRoot() + "/etc/tz/", // Android 10+, Fallback location if the above isn't found or corrupted
   191|                                                        Environment.GetEnvironmentVariable("ANDROID_DATA") + "/misc/zoneinfo/",
   192|                                                        Environment.GetEnvironmentVariable("ANDROID_ROOT") + DefaultTimeZoneDirectory};
   193|                 foreach (var tzFileDir in tzFileDirList)
   194|                 {
   195|                     string tzFilePath = Path.Combine(tzFileDir, TimeZoneFileName);
   196|                     if (LoadData(tzFilePath))
   197|                     {
   198|                         _tzFileDir = tzFileDir;
   199|                         _tzFilePath = tzFilePath;
   200|                         return;
   201|                     }
   202|                 }
   203|                 throw new TimeZoneNotFoundException(SR.TimeZoneNotFound_ValidTimeZoneFileMissing);
   204|             }
   205|             [MemberNotNullWhen(true, nameof(_ids))]
   206|             [MemberNotNullWhen(true, nameof(_byteOffsets))]
   207|             [MemberNotNullWhen(true, nameof(_lengths))]
   208|             private bool LoadData(string path)
   209|             {
   210|                 if (!File.Exists(path))
   211|                 {
   212|                     return false;
   213|                 }
   214|                 try
   215|                 {
   216|                     using (FileStream fs = File.OpenRead(path))
   217|                     {
   218|                         LoadTzFile(fs);
   219|                     }
   220|                     return true;
   221|                 }
   222|                 catch {}
   223|                 return false;
   224|             }
   225|             [MemberNotNull(nameof(_ids))]
   226|             [MemberNotNull(nameof(_byteOffsets))]
   227|             [MemberNotNull(nameof(_lengths))]
   228|             private void LoadTzFile(Stream fs)
   229|             {
   230|                 const int HeaderSize = 24;
   231|                 Span<byte> buffer = stackalloc byte[HeaderSize];
   232|                 ReadTzDataIntoBuffer(fs, 0, buffer);
   233|                 LoadHeader(buffer, out int indexOffset, out int dataOffset);
   234|                 ReadIndex(fs, indexOffset, dataOffset);
   235|             }
   236|             private void LoadHeader(Span<byte> buffer, out int indexOffset, out int dataOffset)
   237|             {
   238|                 var tz = (ushort)TZif_ToInt16(buffer.Slice(0, 2));
   239|                 var data = (uint)TZif_ToInt32(buffer.Slice(2, 4));
   240|                 if (tz != 0x747A || data != 0x64617461 || buffer[11] != 0)
   241|                 {
   242|                     var b = new StringBuilder(buffer.Length);
   243|                     for (int i = 0; i < 12; ++i)
   244|                     {
   245|                         b.Append(' ').Append(HexConverter.ToCharLower(buffer[i]));
   246|                     }
   247|                     throw new InvalidOperationException(SR.Format(SR.InvalidOperation_BadTZHeader, TimeZoneFileName, b.ToString()));
   248|                 }
   249|                 indexOffset = TZif_ToInt32(buffer.Slice(12, 4));
   250|                 dataOffset = TZif_ToInt32(buffer.Slice(16, 4));
   251|             }
   252|             [MemberNotNull(nameof(_ids))]
   253|             [MemberNotNull(nameof(_byteOffsets))]
   254|             [MemberNotNull(nameof(_lengths))]
   255|             private void ReadIndex(Stream fs, int indexOffset, int dataOffset)
   256|             {
   257|                 int indexSize = dataOffset - indexOffset;
   258|                 const int entrySize = 52; // Data entry size
   259|                 int entryCount = indexSize / entrySize;
   260|                 _byteOffsets = new int[entryCount];
   261|                 _ids = new string[entryCount];
   262|                 _lengths = new int[entryCount];
   263|                 for (int i = 0; i < entryCount; ++i)
   264|                 {
   265|                     LoadEntryAt(fs, indexOffset + (entrySize*i), out string id, out int byteOffset, out int length);
   266|                     _byteOffsets[i] = byteOffset + dataOffset;
   267|                     _ids[i] = id;
   268|                     _lengths[i] = length;
   269|                     if (length < 24) // Header Size
   270|                     {
   271|                         throw new InvalidOperationException(SR.InvalidOperation_BadIndexLength);
   272|                     }
   273|                 }
   274|             }
   275|             private void ReadTzDataIntoBuffer(Stream fs, long position, Span<byte> buffer)
   276|             {
   277|                 fs.Position = position;
   278|                 int bytesRead = 0;
   279|                 int bytesLeft = buffer.Length;
   280|                 while (bytesLeft > 0)
   281|                 {
   282|                     int b = fs.Read(buffer.Slice(bytesRead));
   283|                     if (b == 0)
   284|                     {
   285|                         break;
   286|                     }
   287|                     bytesRead += b;
   288|                     bytesLeft -= b;

# --- HUNK 2: Lines 291-331 ---
   291|                 {
   292|                     throw new InvalidOperationException(SR.Format(SR.InvalidOperation_ReadTZError, _tzFilePath, position, buffer.Length, bytesRead, buffer.Length));
   293|                 }
   294|             }
   295|             private void LoadEntryAt(Stream fs, long position, out string id, out int byteOffset, out int length)
   296|             {
   297|                 const int size = 52; // data entry size
   298|                 Span<byte> entryBuffer = stackalloc byte[size];
   299|                 ReadTzDataIntoBuffer(fs, position, entryBuffer);
   300|                 int index = 0;
   301|                 while (entryBuffer[index] != 0 && index < 40)
   302|                 {
   303|                     index += 1;
   304|                 }
   305|                 id = Encoding.UTF8.GetString(entryBuffer.Slice(0, index));
   306|                 byteOffset = TZif_ToInt32(entryBuffer.Slice(40, 4));
   307|                 length = TZif_ToInt32(entryBuffer.Slice(44, 4));
   308|             }
   309|             public string[] GetTimeZoneIds()
   310|             {
   311|                 return _ids;
   312|             }
   313|             public string GetTimeZoneDirectory()
   314|             {
   315|                 return _tzFilePath;
   316|             }
   317|             public byte[] GetTimeZoneData(string id)
   318|             {
   319|                 int i = Array.BinarySearch(_ids, id, StringComparer.Ordinal);
   320|                 if (i < 0)
   321|                 {
   322|                     throw new InvalidOperationException(SR.Format(SR.TimeZoneNotFound_MissingData, id));
   323|                 }
   324|                 int offset = _byteOffsets[i];
   325|                 int length = _lengths[i];
   326|                 byte[] buffer = new byte[length];
   327|                 using (FileStream fs = File.OpenRead(_tzFilePath))
   328|                 {
   329|                     ReadTzDataIntoBuffer(fs, offset, buffer);
   330|                 }
   331|                 return buffer;


# ====================================================================
# FILE: src/libraries/System.Reflection.Metadata/src/System/Reflection/PortableExecutable/ManagedTextSection.cs
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 37-86 ---
    37|         public bool Is32Bit => !Requires64bits;
    38|         public const int ManagedResourcesDataAlignment = 8;
    39|         private const string CorEntryPointDll = "mscoree.dll";
    40|         private string CorEntryPointName => (ImageCharacteristics & Characteristics.Dll) != 0 ? "_CorDllMain" : "_CorExeMain";
    41|         private int SizeOfImportAddressTable => RequiresStartupStub ? (Is32Bit ? 2 * sizeof(uint) : 2 * sizeof(ulong)) : 0;
    42|         private int SizeOfImportTable =>
    43|             sizeof(uint) + // RVA
    44|             sizeof(uint) + // 0
    45|             sizeof(uint) + // 0
    46|             sizeof(uint) + // name RVA
    47|             sizeof(uint) + // import address table RVA
    48|             20 +           // ?
    49|             (Is32Bit ? 3 * sizeof(uint) : 2 * sizeof(ulong)) + // import lookup table
    50|             sizeof(ushort) + // hint
    51|             CorEntryPointName.Length +
    52|             1;    // NUL
    53|         private static int SizeOfNameTable =>
    54|             CorEntryPointDll.Length + 1 + sizeof(ushort);
    55|         private int SizeOfRuntimeStartupStub => Is32Bit ? 8 : 16;
    56|         public const int MappedFieldDataAlignment = 8;
    57|         public int CalculateOffsetToMappedFieldDataStream()
    58|         {
    59|             int result = ComputeOffsetToImportTable();
    60|             if (RequiresStartupStub)
    61|             {
    62|                 result += SizeOfImportTable + SizeOfNameTable;
    63|                 result = BitArithmetic.Align(result, Is32Bit ? 4 : 8); //optional padding to make startup stub's target address align on word or double word boundary
    64|                 result += SizeOfRuntimeStartupStub;
    65|             }
    66|             return result;
    67|         }
    68|         internal int ComputeOffsetToDebugDirectory()
    69|         {
    70|             Debug.Assert(MetadataSize % 4 == 0);
    71|             Debug.Assert(ResourceDataSize % 4 == 0);
    72|             return
    73|                 ComputeOffsetToMetadata() +
    74|                 MetadataSize +
    75|                 ResourceDataSize +
    76|                 StrongNameSignatureSize;
    77|         }
    78|         private int ComputeOffsetToImportTable()
    79|         {
    80|             return
    81|                 ComputeOffsetToDebugDirectory() +
    82|                 DebugDataSize;
    83|         }
    84|         private const int CorHeaderSize =
    85|             sizeof(int) +    // header size
    86|             sizeof(short) +  // major runtime version

# --- HUNK 2: Lines 90-130 ---
    90|             sizeof(int) +    // entry point
    91|             sizeof(long) +   // resources directory
    92|             sizeof(long) +   // strong name signature directory
    93|             sizeof(long) +   // code manager table directory
    94|             sizeof(long) +   // vtable fixups directory
    95|             sizeof(long) +   // export address table jumps directory
    96|             sizeof(long);   // managed-native header directory
    97|         public int OffsetToILStream => SizeOfImportAddressTable + CorHeaderSize;
    98|         private int ComputeOffsetToMetadata()
    99|         {
   100|             return OffsetToILStream + BitArithmetic.Align(ILStreamSize, 4);
   101|         }
   102|         public int ComputeSizeOfTextSection()
   103|         {
   104|             Debug.Assert(MappedFieldDataSize % MappedFieldDataAlignment == 0);
   105|             return CalculateOffsetToMappedFieldDataStream() + MappedFieldDataSize;
   106|         }
   107|         public int GetEntryPointAddress(int rva)
   108|         {
   109|             return RequiresStartupStub ?
   110|                 rva + CalculateOffsetToMappedFieldDataStream() - (Is32Bit ? 6 : 10) :
   111|                 0;
   112|         }
   113|         public DirectoryEntry GetImportAddressTableDirectoryEntry(int rva)
   114|         {
   115|             return RequiresStartupStub ?
   116|                 new DirectoryEntry(rva, SizeOfImportAddressTable) :
   117|                 default(DirectoryEntry);
   118|         }
   119|         public DirectoryEntry GetImportTableDirectoryEntry(int rva)
   120|         {
   121|             return RequiresStartupStub ?
   122|                 new DirectoryEntry(rva + ComputeOffsetToImportTable(), (Is32Bit ? 66 : 70) + 13) :
   123|                 default(DirectoryEntry);
   124|         }
   125|         public DirectoryEntry GetCorHeaderDirectoryEntry(int rva)
   126|         {
   127|             return new DirectoryEntry(rva + SizeOfImportAddressTable, CorHeaderSize);
   128|         }
   129|         #region Serialization
   130|         public void Serialize(

# --- HUNK 3: Lines 158-197 ---
   158|             builder.LinkSuffix(ilBuilder);
   159|             builder.LinkSuffix(metadataBuilder);
   160|             if (resourceBuilderOpt != null)
   161|             {
   162|                 builder.LinkSuffix(resourceBuilderOpt);
   163|             }
   164|             strongNameSignature = builder.ReserveBytes(StrongNameSignatureSize);
   165|             new BlobWriter(strongNameSignature).WriteBytes(0, StrongNameSignatureSize);
   166|             if (debugDataBuilderOpt != null)
   167|             {
   168|                 builder.LinkSuffix(debugDataBuilderOpt);
   169|             }
   170|             if (RequiresStartupStub)
   171|             {
   172|                 WriteImportTable(builder, importTableRva, importAddressTableRva);
   173|                 WriteNameTable(builder);
   174|                 WriteRuntimeStartupStub(builder, importAddressTableRva, baseAddress);
   175|             }
   176|             if (mappedFieldDataBuilderOpt != null)
   177|             {
   178|                 builder.LinkSuffix(mappedFieldDataBuilderOpt);
   179|             }
   180|             Debug.Assert(builder.Count == ComputeSizeOfTextSection());
   181|         }
   182|         private void WriteImportAddressTable(BlobBuilder builder, int importTableRva)
   183|         {
   184|             int start = builder.Count;
   185|             int ilRva = importTableRva + 40;
   186|             int hintRva = ilRva + (Is32Bit ? 12 : 16);
   187|             if (Is32Bit)
   188|             {
   189|                 builder.WriteUInt32((uint)hintRva); // 4
   190|                 builder.WriteUInt32(0); // 8
   191|             }
   192|             else
   193|             {
   194|                 builder.WriteUInt64((uint)hintRva); // 8
   195|                 builder.WriteUInt64(0); // 16
   196|             }
   197|             Debug.Assert(builder.Count - start == SizeOfImportAddressTable);


# ====================================================================
# FILE: src/libraries/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 134-180 ---
   134|         FastCall = 5,
   135|     }
   136|     [System.AttributeUsageAttribute(System.AttributeTargets.Assembly | System.AttributeTargets.Class, Inherited=false)]
   137|     public sealed partial class ClassInterfaceAttribute : System.Attribute
   138|     {
   139|         public ClassInterfaceAttribute(short classInterfaceType) { }
   140|         public ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType classInterfaceType) { }
   141|         public System.Runtime.InteropServices.ClassInterfaceType Value { get { throw null; } }
   142|     }
   143|     public enum ClassInterfaceType
   144|     {
   145|         None = 0,
   146|         [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
   147|         [System.ObsoleteAttribute("Support for IDispatch may be unavailable in future releases.")]
   148|         AutoDispatch = 1,
   149|         [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
   150|         [System.ObsoleteAttribute("Support for IDispatch may be unavailable in future releases.")]
   151|         AutoDual = 2,
   152|     }
   153|     [System.CLSCompliantAttribute(false)]
   154|     public readonly struct CLong : IEquatable<CLong>
   155|     {
   156|         public CLong(int value) { }
   157|         public CLong(nint value) { }
   158|         public nint Value { get { throw null; } }
   159|         public override bool Equals([System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] object? o) { throw null; }
   160|         public bool Equals(CLong other) { throw null; }
   161|         public override int GetHashCode() { throw null; }
   162|         public override string ToString() { throw null; }
   163|     }
   164|     [System.AttributeUsageAttribute(System.AttributeTargets.Interface, Inherited=false)]
   165|     public sealed partial class CoClassAttribute : System.Attribute
   166|     {
   167|         public CoClassAttribute(System.Type coClass) { }
   168|         public System.Type CoClass { get { throw null; } }
   169|     }
   170|     public static partial class CollectionsMarshal
   171|     {
   172|         public static System.Span<T> AsSpan<T>(System.Collections.Generic.List<T>? list) { throw null; }
   173|         public static ref TValue GetValueRefOrNullRef<TKey, TValue>(System.Collections.Generic.Dictionary<TKey, TValue> dictionary, TKey key) where TKey : notnull { throw null; }
   174|         public static ref TValue? GetValueRefOrAddDefault<TKey, TValue>(System.Collections.Generic.Dictionary<TKey, TValue> dictionary, TKey key, out bool exists) where TKey : notnull { throw null; }
   175|     }
   176|     [System.AttributeUsageAttribute(System.AttributeTargets.Field | System.AttributeTargets.Parameter | System.AttributeTargets.Property | System.AttributeTargets.ReturnValue, Inherited=false)]
   177|     public sealed partial class ComAliasNameAttribute : System.Attribute
   178|     {
   179|         public ComAliasNameAttribute(string alias) { }
   180|         public string Value { get { throw null; } }

# --- HUNK 2: Lines 271-317 ---
   271|     {
   272|         public ComRegisterFunctionAttribute() { }
   273|     }
   274|     [System.AttributeUsageAttribute(System.AttributeTargets.Class, Inherited=true)]
   275|     [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
   276|     public sealed partial class ComSourceInterfacesAttribute : System.Attribute
   277|     {
   278|         public ComSourceInterfacesAttribute(string sourceInterfaces) { }
   279|         public ComSourceInterfacesAttribute(System.Type sourceInterface) { }
   280|         public ComSourceInterfacesAttribute(System.Type sourceInterface1, System.Type sourceInterface2) { }
   281|         public ComSourceInterfacesAttribute(System.Type sourceInterface1, System.Type sourceInterface2, System.Type sourceInterface3) { }
   282|         public ComSourceInterfacesAttribute(System.Type sourceInterface1, System.Type sourceInterface2, System.Type sourceInterface3, System.Type sourceInterface4) { }
   283|         public string Value { get { throw null; } }
   284|     }
   285|     [System.AttributeUsageAttribute(System.AttributeTargets.Method, Inherited=false)]
   286|     public sealed partial class ComUnregisterFunctionAttribute : System.Attribute
   287|     {
   288|         public ComUnregisterFunctionAttribute() { }
   289|     }
   290|     [System.CLSCompliantAttribute(false)]
   291|     public readonly struct CULong : IEquatable<CULong>
   292|     {
   293|         public CULong(uint value) { }
   294|         public CULong(nuint value) { }
   295|         public nuint Value { get { throw null; } }
   296|         public override bool Equals([System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] object? o) { throw null; }
   297|         public bool Equals(CULong other) { throw null; }
   298|         public override int GetHashCode() { throw null; }
   299|         public override string ToString() { throw null; }
   300|     }
   301|     [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
   302|     [System.ObsoleteAttribute("CurrencyWrapper and support for marshalling to the VARIANT type may be unavailable in future releases.")]
   303|     public sealed partial class CurrencyWrapper
   304|     {
   305|         public CurrencyWrapper(decimal obj) { }
   306|         public CurrencyWrapper(object obj) { }
   307|         public decimal WrappedObject { get { throw null; } }
   308|     }
   309|     [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
   310|     public enum CustomQueryInterfaceMode
   311|     {
   312|         Ignore = 0,
   313|         Allow = 1,
   314|     }
   315|     [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
   316|     public enum CustomQueryInterfaceResult
   317|     {

# --- HUNK 3: Lines 759-807 ---
   759|     {
   760|         [System.CLSCompliantAttribute(false)]
   761|         public static void* AlignedAlloc(nuint byteCount, nuint alignment) { throw null; }
   762|         [System.CLSCompliantAttribute(false)]
   763|         public static void AlignedFree(void* ptr) { }
   764|         [System.CLSCompliantAttribute(false)]
   765|         public static void* AlignedRealloc(void* ptr, nuint byteCount, nuint alignment) { throw null; }
   766|         [System.CLSCompliantAttribute(false)]
   767|         public static void* Alloc(nuint byteCount) { throw null; }
   768|         [System.CLSCompliantAttribute(false)]
   769|         public static void* Alloc(nuint elementCount, nuint elementSize) { throw null; }
   770|         [System.CLSCompliantAttribute(false)]
   771|         public static void* AllocZeroed(nuint byteCount) { throw null; }
   772|         [System.CLSCompliantAttribute(false)]
   773|         public static void* AllocZeroed(nuint elementCount, nuint elementSize) { throw null; }
   774|         [System.CLSCompliantAttribute(false)]
   775|         public static void Free(void* ptr) { }
   776|         [System.CLSCompliantAttribute(false)]
   777|         public static void* Realloc(void* ptr, nuint byteCount) { throw null; }
   778|     }
   779|     public readonly struct NFloat : IEquatable<NFloat>
   780|     {
   781|         public NFloat(float value) { }
   782|         public NFloat(double value) { }
   783|         public double Value { get { throw null; } }
   784|         public override bool Equals([System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] object? o) { throw null; }
   785|         public bool Equals(NFloat other) { throw null; }
   786|         public override int GetHashCode() { throw null; }
   787|         public override string ToString() { throw null; }
   788|     }
   789|     [System.AttributeUsageAttribute(System.AttributeTargets.Parameter, Inherited=false)]
   790|     public sealed partial class OptionalAttribute : System.Attribute
   791|     {
   792|         public OptionalAttribute() { }
   793|     }
   794|     public enum PosixSignal
   795|     {
   796|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("windows")]
   797|         SIGTSTP = -10,
   798|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("windows")]
   799|         SIGTTOU = -9,
   800|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("windows")]
   801|         SIGTTIN = -8,
   802|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("windows")]
   803|         SIGWINCH = -7,
   804|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("windows")]
   805|         SIGCONT = -6,
   806|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("windows")]
   807|         SIGCHLD = -5,


# ====================================================================
# FILE: src/mono/System.Private.CoreLib/src/System/Array.Mono.cs
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 107-177 ---
   107|             if (sourceIndex < 0)
   108|                 throw new ArgumentOutOfRangeException(nameof(sourceIndex), "Value has to be >= 0.");
   109|             if (destinationIndex < 0)
   110|                 throw new ArgumentOutOfRangeException(nameof(destinationIndex), "Value has to be >= 0.");
   111|             if (FastCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length))
   112|                 return;
   113|             int source_pos = sourceIndex - sourceArray.GetLowerBound(0);
   114|             int dest_pos = destinationIndex - destinationArray.GetLowerBound(0);
   115|             if (source_pos < 0)
   116|                 throw new ArgumentOutOfRangeException(nameof(sourceIndex), "Index was less than the array's lower bound in the first dimension.");
   117|             if (dest_pos < 0)
   118|                 throw new ArgumentOutOfRangeException(nameof(destinationIndex), "Index was less than the array's lower bound in the first dimension.");
   119|             if (source_pos > sourceArray.Length - length)
   120|                 throw new ArgumentException(SR.Arg_LongerThanSrcArray, nameof(sourceArray));
   121|             if (dest_pos > destinationArray.Length - length)
   122|             {
   123|                 throw new ArgumentException("Destination array was not long enough. Check destIndex and length, and the array's lower bounds", nameof(destinationArray));
   124|             }
   125|             Type src_type = sourceArray.GetType().GetElementType()!;
   126|             Type dst_type = destinationArray.GetType().GetElementType()!;
   127|             bool dst_type_vt = dst_type.IsValueType && Nullable.GetUnderlyingType(dst_type) == null;
   128|             bool src_is_enum = src_type.IsEnum;
   129|             bool dst_is_enum = dst_type.IsEnum;
   130|             if (src_is_enum)
   131|                 src_type = Enum.GetUnderlyingType(src_type);
   132|             if (dst_is_enum)
   133|                 dst_type = Enum.GetUnderlyingType(dst_type);
   134|             if (reliable)
   135|             {
   136|                 if (!dst_type.Equals(src_type) &&
   137|                     !(dst_type.IsPrimitive && src_type.IsPrimitive && CanChangePrimitive(ref dst_type, ref src_type, true)))
   138|                 {
   139|                     throw new ArrayTypeMismatchException(SR.ArrayTypeMismatch_CantAssignType);
   140|                 }
   141|             }
   142|             else
   143|             {
   144|                 if (!CanAssignArrayElement(src_type, dst_type))
   145|                 {
   146|                     throw new ArrayTypeMismatchException(SR.ArrayTypeMismatch_CantAssignType);
   147|                 }
   148|             }
   149|             if (!ReferenceEquals(sourceArray, destinationArray) || source_pos > dest_pos)
   150|             {
   151|                 for (int i = 0; i < length; i++)
   152|                 {
   153|                     object srcval = sourceArray.GetValueImpl(source_pos + i);
   154|                     if (!src_type.IsValueType && dst_is_enum)
   155|                         throw new InvalidCastException(SR.InvalidCast_DownCastArrayElement);
   156|                     if (dst_type_vt && (srcval == null || (src_type == typeof(object) && srcval.GetType() != dst_type)))
   157|                         throw new InvalidCastException();
   158|                     try
   159|                     {
   160|                         destinationArray.SetValueRelaxedImpl(srcval, dest_pos + i);
   161|                     }
   162|                     catch (ArgumentException)
   163|                     {
   164|                         throw CreateArrayTypeMismatchException();
   165|                     }
   166|                 }
   167|             }
   168|             else
   169|             {
   170|                 for (int i = length - 1; i >= 0; i--)
   171|                 {
   172|                     object srcval = sourceArray.GetValueImpl(source_pos + i);
   173|                     try
   174|                     {
   175|                         destinationArray.SetValueRelaxedImpl(srcval, dest_pos + i);
   176|                     }
   177|                     catch (ArgumentException)


# ====================================================================
# FILE: src/mono/mono/component/debugger-agent.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 4609-4649 ---
  4609| 				if (CHECK_PROTOCOL_VERSION (2, 59)) {
  4610| 					decode_byte (buf, &buf, limit);
  4611| 					decode_int (buf, &buf, limit); //not used
  4612| 				}
  4613| 				*(MonoObject**)addr = NULL;
  4614| 			} else if (type == MONO_TYPE_VALUETYPE) {
  4615| 				ERROR_DECL (error);
  4616| 				guint8 *buf2;
  4617| 				gboolean is_enum;
  4618| 				MonoClass *klass;
  4619| 				MonoDomain *d;
  4620| 				guint8 *vtype_buf;
  4621| 				int vtype_buf_size;
  4622| 				/* This can happen when round-tripping boxed vtypes */
  4623| 				/*
  4624| 				* Obtain vtype class.
  4625| 				* Same as the beginning of the handle_vtype case above.
  4626| 				*/
  4627| 				buf2 = buf;
  4628| 				is_enum = decode_byte (buf, &buf, limit);
  4629| 				decode_byte (buf, &buf, limit); //ignore is boxed
  4630| 				klass = decode_typeid (buf, &buf, limit, &d, &err);
  4631| 				if (err != ERR_NONE)
  4632| 					return err;
  4633| 				/* Decode the vtype into a temporary buffer, then box it. */
  4634| 				vtype_buf_size = mono_class_value_size (klass, NULL);
  4635| 				vtype_buf = (guint8 *)g_malloc0 (vtype_buf_size);
  4636| 				g_assert (vtype_buf);
  4637| 				buf = buf2;
  4638| 				err = decode_vtype (NULL, domain, vtype_buf, buf, &buf, limit, check_field_datatype);
  4639| 				if (err != ERR_NONE) {
  4640| 					g_free (vtype_buf);
  4641| 					return err;
  4642| 				}
  4643| 				*(MonoObject**)addr = mono_value_box_checked (klass, vtype_buf, error);
  4644| 				mono_error_cleanup (error);
  4645| 				g_free (vtype_buf);
  4646| 			} else {
  4647| 				char *name = mono_type_full_name (t);
  4648| 				PRINT_DEBUG_MSG (1, "[%p] Expected value of type %s, got 0x%0x.\n", (gpointer) (gsize) mono_native_thread_id_get (), name, type);
  4649| 				g_free (name);


# ====================================================================
# FILE: src/mono/mono/eventpipe/ep-rt-mono.c
# Total hunks: 7
# ====================================================================
# --- HUNK 1: Lines 2426-2539 ---
  2426| 	MonoImage *image,
  2427| 	ModuleEventData *module_data)
  2428| {
  2429| 	if (module_data) {
  2430| 		memset (module_data->module_il_pdb_signature, 0, EP_GUID_SIZE);
  2431| 		memset (module_data->module_native_pdb_signature, 0, EP_GUID_SIZE);
  2432| 		MonoDomain *root_domain = mono_get_root_domain ();
  2433| 		module_data->domain_id = (uint64_t)root_domain;
  2434| 		module_data->module_id = (uint64_t)image;
  2435| 		module_data->assembly_id = image ? (uint64_t)image->assembly : 0;
  2436| 		module_data->module_native_path = "";
  2437| 		module_data->module_native_pdb_path = "";
  2438| 		module_data->module_native_pdb_age = 0;
  2439| 		module_data->reserved_flags = 0;
  2440| 		module_data->module_flags = MODULE_FLAGS_MANIFEST_MODULE;
  2441| 		if (image && image->dynamic)
  2442| 			module_data->module_flags |= MODULE_FLAGS_DYNAMIC_MODULE;
  2443| 		if (image && image->aot_module)
  2444| 			module_data->module_flags |= MODULE_FLAGS_NATIVE_MODULE;
  2445| 		module_data->module_il_path = image && image->filename ? image->filename : "";
  2446| 		if (image && image->image_info) {
  2447| 			MonoPEDirEntry *debug_dir_entry = (MonoPEDirEntry *)&image->image_info->cli_header.datadir.pe_debug;
  2448| 			if (debug_dir_entry->size) {
  2449| 				ImageDebugDirectory debug_dir;
  2450| 				memset (&debug_dir, 0, sizeof (debug_dir));
  2451| 				uint32_t offset = mono_cli_rva_image_map (image, debug_dir_entry->rva);
  2452| 				for (uint32_t idx = 0; idx < debug_dir_entry->size / sizeof (ImageDebugDirectory); ++idx) {
  2453| 					uint8_t *data = (uint8_t *) ((ImageDebugDirectory *) (image->raw_data + offset) + idx);
  2454| 					debug_dir.major_version = read16 (data + 8);
  2455| 					debug_dir.minor_version = read16 (data + 10);
  2456| 					debug_dir.type = read32 (data + 12);
  2457| 					debug_dir.pointer = read32 (data + 24);
  2458| 					if (debug_dir.type == DEBUG_DIR_ENTRY_CODEVIEW && debug_dir.major_version == 0x100 && debug_dir.minor_version == 0x504d) {
  2459| 						data  = (uint8_t *)(image->raw_data + debug_dir.pointer);
  2460| 						int32_t signature = read32 (data);
  2461| 						if (signature == 0x53445352) {
  2462| 							memcpy (module_data->module_il_pdb_signature, data + 4, EP_GUID_SIZE);
  2463| 							module_data->module_il_pdb_age = read32 (data + 20);
  2464| 							module_data->module_il_pdb_path = (const char *)(data + 24);
  2465| 							break;
  2466| 						}
  2467| 					}
  2468| 				}
  2469| 			}
  2470| 		}
  2471| 	}
  2472| 	return true;
  2473| }
  2474| bool
  2475| ep_rt_mono_write_event_module_load (MonoImage *image)
  2476| {
  2477| 	if (!EventEnabledModuleLoad_V2 () && !EventEnabledDomainModuleLoad_V1 ())
  2478| 		return true;
  2479| 	if (image) {
  2480| 		ModuleEventData module_data;
  2481| 		if (get_module_event_data (image, &module_data)) {
  2482| 			FireEtwModuleLoad_V2 (
  2483| 				module_data.module_id,
  2484| 				module_data.assembly_id,
  2485| 				module_data.module_flags,
  2486| 				module_data.reserved_flags,
  2487| 				module_data.module_il_path,
  2488| 				module_data.module_native_path,
  2489| 				clr_instance_get_id (),
  2490| 				module_data.module_il_pdb_signature,
  2491| 				module_data.module_il_pdb_age,
  2492| 				module_data.module_il_pdb_path,
  2493| 				module_data.module_native_pdb_signature,
  2494| 				module_data.module_native_pdb_age,
  2495| 				module_data.module_native_pdb_path,
  2496| 				NULL,
  2497| 				NULL);
  2498| 			FireEtwDomainModuleLoad_V1 (
  2499| 				module_data.module_id,
  2500| 				module_data.assembly_id,
  2501| 				module_data.domain_id,
  2502| 				module_data.module_flags,
  2503| 				module_data.reserved_flags,
  2504| 				module_data.module_il_path,
  2505| 				module_data.module_native_path,
  2506| 				clr_instance_get_id (),
  2507| 				NULL,
  2508| 				NULL);
  2509| 		}
  2510| 	}
  2511| 	return true;
  2512| }
  2513| bool
  2514| ep_rt_mono_write_event_module_unload (MonoImage *image)
  2515| {
  2516| 	if (!EventEnabledModuleUnload_V2())
  2517| 		return true;
  2518| 	if (image) {
  2519| 		ModuleEventData module_data;
  2520| 		if (get_module_event_data (image, &module_data)) {
  2521| 			FireEtwModuleUnload_V2 (
  2522| 				module_data.module_id,
  2523| 				module_data.assembly_id,
  2524| 				module_data.module_flags,
  2525| 				module_data.reserved_flags,
  2526| 				module_data.module_il_path,
  2527| 				module_data.module_native_path,
  2528| 				clr_instance_get_id (),
  2529| 				module_data.module_il_pdb_signature,
  2530| 				module_data.module_il_pdb_age,
  2531| 				module_data.module_il_pdb_path,
  2532| 				module_data.module_native_pdb_signature,
  2533| 				module_data.module_native_pdb_age,
  2534| 				module_data.module_native_pdb_path,
  2535| 				NULL,
  2536| 				NULL);
  2537| 		}
  2538| 	}
  2539| 	return true;

# --- HUNK 2: Lines 2548-2609 ---
  2548| 		MonoDomain *root_domain = mono_get_root_domain ();
  2549| 		assembly_data->domain_id = (uint64_t)root_domain;
  2550| 		assembly_data->assembly_id = (uint64_t)assembly;
  2551| 		assembly_data->binding_id = 0;
  2552| 		assembly_data->assembly_flags = 0;
  2553| 		if (assembly->dynamic)
  2554| 			assembly_data->assembly_flags |= ASSEMBLY_FLAGS_DYNAMIC_ASSEMBLY;
  2555| 		if (assembly->image && assembly->image->aot_module)
  2556| 			assembly_data->assembly_flags |= ASSEMBLY_FLAGS_NATIVE_ASSEMBLY;
  2557| 		assembly_data->assembly_name = mono_stringify_assembly_name (&assembly->aname);
  2558| 	}
  2559| 	return true;
  2560| }
  2561| bool
  2562| ep_rt_mono_write_event_assembly_load (MonoAssembly *assembly)
  2563| {
  2564| 	if (!EventEnabledAssemblyLoad_V1 ())
  2565| 		return true;
  2566| 	if (assembly) {
  2567| 		AssemblyEventData assembly_data;
  2568| 		if (get_assembly_event_data (assembly, &assembly_data)) {
  2569| 			FireEtwAssemblyLoad_V1 (
  2570| 				assembly_data.assembly_id,
  2571| 				assembly_data.domain_id,
  2572| 				assembly_data.binding_id,
  2573| 				assembly_data.assembly_flags,
  2574| 				assembly_data.assembly_name,
  2575| 				clr_instance_get_id (),
  2576| 				NULL,
  2577| 				NULL);
  2578| 			g_free (assembly_data.assembly_name);
  2579| 		}
  2580| 	}
  2581| 	return true;
  2582| }
  2583| bool
  2584| ep_rt_mono_write_event_assembly_unload (MonoAssembly *assembly)
  2585| {
  2586| 	if (!EventEnabledAssemblyUnload_V1 ())
  2587| 		return true;
  2588| 	if (assembly) {
  2589| 		AssemblyEventData assembly_data;
  2590| 		if (get_assembly_event_data (assembly, &assembly_data)) {
  2591| 			FireEtwAssemblyUnload_V1 (
  2592| 				assembly_data.assembly_id,
  2593| 				assembly_data.domain_id,
  2594| 				assembly_data.binding_id,
  2595| 				assembly_data.assembly_flags,
  2596| 				assembly_data.assembly_name,
  2597| 				clr_instance_get_id (),
  2598| 				NULL,
  2599| 				NULL);
  2600| 			g_free (assembly_data.assembly_name);
  2601| 		}
  2602| 	}
  2603| 	return true;
  2604| }
  2605| bool
  2606| ep_rt_mono_write_event_thread_created (ep_rt_thread_id_t tid)
  2607| {
  2608| 	if (!EventEnabledThreadCreated ())
  2609| 		return true;

# --- HUNK 3: Lines 4497-4536 ---
  4497| 	mono_profiler_fire_event_enter ();
  4498| 	FireEtwMonoProfilerModuleFailed (
  4499| 		(uint64_t)image,
  4500| 		NULL,
  4501| 		NULL);
  4502| 	mono_profiler_fire_event_exit ();
  4503| }
  4504| static
  4505| void
  4506| mono_profiler_module_loaded (
  4507| 	MonoProfiler *prof,
  4508| 	MonoImage *image)
  4509| {
  4510| 	if (!EventEnabledMonoProfilerModuleLoaded ())
  4511| 		return;
  4512| 	uint64_t module_id = (uint64_t)image;
  4513| 	const ep_char8_t *module_path = NULL;
  4514| 	const ep_char8_t *module_guid = NULL;
  4515| 	if (image) {
  4516| 		ModuleEventData module_data;
  4517| 		if (get_module_event_data (image, &module_data))
  4518| 			module_path = (const ep_char8_t *)module_data.module_il_path;
  4519| 		module_guid = (const ep_char8_t *)mono_image_get_guid (image);
  4520| 	}
  4521| 	mono_profiler_fire_event_enter ();
  4522| 	FireEtwMonoProfilerModuleLoaded (
  4523| 		module_id,
  4524| 		module_path ? module_path : "",
  4525| 		module_guid ? module_guid : "",
  4526| 		NULL,
  4527| 		NULL);
  4528| 	mono_profiler_fire_event_exit ();
  4529| }
  4530| static
  4531| void
  4532| mono_profiler_module_unloading (
  4533| 	MonoProfiler *prof,
  4534| 	MonoImage *image)
  4535| {
  4536| 	if (!EventEnabledMonoProfilerModuleUnloading ())

# --- HUNK 4: Lines 4538-4577 ---
  4538| 	mono_profiler_fire_event_enter ();
  4539| 	FireEtwMonoProfilerModuleUnloading (
  4540| 		(uint64_t)image,
  4541| 		NULL,
  4542| 		NULL);
  4543| 	mono_profiler_fire_event_exit ();
  4544| }
  4545| static
  4546| void
  4547| mono_profiler_module_unloaded (
  4548| 	MonoProfiler *prof,
  4549| 	MonoImage *image)
  4550| {
  4551| 	if (!EventEnabledMonoProfilerModuleUnloaded ())
  4552| 		return;
  4553| 	uint64_t module_id = (uint64_t)image;
  4554| 	const ep_char8_t *module_path = NULL;
  4555| 	const ep_char8_t *module_guid = NULL;
  4556| 	if (image) {
  4557| 		ModuleEventData module_data;
  4558| 		if (get_module_event_data (image, &module_data))
  4559| 			module_path = (const ep_char8_t *)module_data.module_il_path;
  4560| 		module_guid = (const ep_char8_t *)mono_image_get_guid (image);
  4561| 	}
  4562| 	mono_profiler_fire_event_enter ();
  4563| 	FireEtwMonoProfilerModuleUnloaded (
  4564| 		module_id,
  4565| 		module_path ? module_path : "",
  4566| 		module_guid ? module_guid : "",
  4567| 		NULL,
  4568| 		NULL);
  4569| 	mono_profiler_fire_event_exit ();
  4570| }
  4571| static
  4572| inline
  4573| void
  4574| get_assembly_data (
  4575| 	MonoAssembly *assembly,
  4576| 	uint64_t *assembly_id,
  4577| 	uint64_t *module_id,


# ====================================================================
# FILE: src/mono/mono/mini/image-writer.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 50-90 ---
    50| #if (defined(TARGET_AMD64) || defined(TARGET_POWERPC64)) && !defined(MONO_ARCH_ILP32)
    51| #define AS_POINTER_DIRECTIVE ".quad"
    52| #elif defined(TARGET_ARM64)
    53| #ifdef MONO_ARCH_ILP32
    54| #define AS_POINTER_DIRECTIVE AS_INT32_DIRECTIVE
    55| #else
    56| #ifdef TARGET_ASM_APPLE
    57| #define AS_POINTER_DIRECTIVE ".quad"
    58| #else
    59| #define AS_POINTER_DIRECTIVE ".xword"
    60| #endif
    61| #endif
    62| #else
    63| #define AS_POINTER_DIRECTIVE ".long"
    64| #endif
    65| #if defined(TARGET_ASM_APPLE)
    66| #define AS_INT16_DIRECTIVE ".short"
    67| #elif defined(TARGET_ASM_GAS) && defined(TARGET_WIN32)
    68| #define AS_INT16_DIRECTIVE ".word"
    69| #elif defined(TARGET_ASM_GAS)
    70| #define AS_INT16_DIRECTIVE ".hword"
    71| #else
    72| #define AS_INT16_DIRECTIVE ".word"
    73| #endif
    74| #if defined(TARGET_ASM_APPLE)
    75| #define AS_SKIP_DIRECTIVE ".space"
    76| #else
    77| #define AS_SKIP_DIRECTIVE ".skip"
    78| #endif
    79| #if defined(TARGET_ASM_APPLE)
    80| #define AS_GLOBAL_PREFIX "_"
    81| #else
    82| #define AS_GLOBAL_PREFIX ""
    83| #endif
    84| #ifdef TARGET_ASM_APPLE
    85| #define AS_TEMP_LABEL_PREFIX "L"
    86| #else
    87| #define AS_TEMP_LABEL_PREFIX ".L"
    88| #endif
    89| #define ROUND_DOWN(VALUE,SIZE)	((VALUE) & ~((SIZE) - 1))
    90| /* emit mode */


# ====================================================================
# FILE: src/mono/mono/mini/interp/interp.c
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 4316-4356 ---
  4316| 			ip += 3;
  4317| 			MINT_IN_BREAK;
  4318| 		MINT_IN_CASE(MINT_CONV_I4_R4)
  4319| 			LOCAL_VAR (ip [1], gint32) = (gint32) LOCAL_VAR (ip [2], float);
  4320| 			ip += 3;
  4321| 			MINT_IN_BREAK;
  4322| 		MINT_IN_CASE(MINT_CONV_I4_R8)
  4323| 			LOCAL_VAR (ip [1], gint32) = (gint32) LOCAL_VAR (ip [2], double);
  4324| 			ip += 3;
  4325| 			MINT_IN_BREAK;
  4326| 		MINT_IN_CASE(MINT_CONV_U4_R4)
  4327| #ifdef MONO_ARCH_EMULATE_FCONV_TO_U4
  4328| 			LOCAL_VAR (ip [1], gint32) = mono_rconv_u4 (LOCAL_VAR (ip [2], float));
  4329| #else
  4330| 			LOCAL_VAR (ip [1], gint32) = (guint32) LOCAL_VAR (ip [2], float);
  4331| #endif
  4332| 			ip += 3;
  4333| 			MINT_IN_BREAK;
  4334| 		MINT_IN_CASE(MINT_CONV_U4_R8)
  4335| #ifdef MONO_ARCH_EMULATE_FCONV_TO_U4
  4336| 			LOCAL_VAR (ip [1], gint32) = mono_fconv_u4_2 (LOCAL_VAR (ip [2], double));
  4337| #else
  4338| 			LOCAL_VAR (ip [1], gint32) = (guint32) LOCAL_VAR (ip [2], double);
  4339| #endif
  4340| 			ip += 3;
  4341| 			MINT_IN_BREAK;
  4342| 		MINT_IN_CASE(MINT_CONV_I8_I4)
  4343| 			LOCAL_VAR (ip [1], gint64) = LOCAL_VAR (ip [2], gint32);
  4344| 			ip += 3;
  4345| 			MINT_IN_BREAK;
  4346| 		MINT_IN_CASE(MINT_CONV_I8_U4)
  4347| 			LOCAL_VAR (ip [1], gint64) = (guint32) LOCAL_VAR (ip [2], gint32);
  4348| 			ip += 3;
  4349| 			MINT_IN_BREAK;
  4350| 		MINT_IN_CASE(MINT_CONV_I8_R4)
  4351| 			LOCAL_VAR (ip [1], gint64) = (gint64) LOCAL_VAR (ip [2], float);
  4352| 			ip += 3;
  4353| 			MINT_IN_BREAK;
  4354| 		MINT_IN_CASE(MINT_CONV_I8_R8)
  4355| 			LOCAL_VAR (ip [1], gint64) = (gint64) LOCAL_VAR (ip [2], double);
  4356| 			ip += 3;

# --- HUNK 2: Lines 4372-4412 ---
  4372| 			ip += 3;
  4373| 			MINT_IN_BREAK;
  4374| 		MINT_IN_CASE(MINT_CONV_R8_I8)
  4375| 			LOCAL_VAR (ip [1], double) = (double) LOCAL_VAR (ip [2], gint64);
  4376| 			ip += 3;
  4377| 			MINT_IN_BREAK;
  4378| 		MINT_IN_CASE(MINT_CONV_R8_R4)
  4379| 			LOCAL_VAR (ip [1], double) = (double) LOCAL_VAR (ip [2], float);
  4380| 			ip += 3;
  4381| 			MINT_IN_BREAK;
  4382| 		MINT_IN_CASE(MINT_CONV_U8_R4)
  4383| #ifdef MONO_ARCH_EMULATE_FCONV_TO_U8
  4384| 			LOCAL_VAR (ip [1], gint64) = mono_rconv_u8 (LOCAL_VAR (ip [2], float));
  4385| #else
  4386| 			LOCAL_VAR (ip [1], gint64) = (guint64) LOCAL_VAR (ip [2], float);
  4387| #endif
  4388| 			ip += 3;
  4389| 			MINT_IN_BREAK;
  4390| 		MINT_IN_CASE(MINT_CONV_U8_R8)
  4391| #ifdef MONO_ARCH_EMULATE_FCONV_TO_U8
  4392| 			LOCAL_VAR (ip [1], gint64) = mono_fconv_u8_2 (LOCAL_VAR (ip [2], double));
  4393| #else
  4394| 			LOCAL_VAR (ip [1], gint64) = (guint64) LOCAL_VAR (ip [2], double);
  4395| #endif
  4396| 			ip += 3;
  4397| 			MINT_IN_BREAK;
  4398| 		MINT_IN_CASE(MINT_CPOBJ) {
  4399| 			MonoClass* const c = (MonoClass*)frame->imethod->data_items[ip [3]];
  4400| 			g_assert (m_class_is_valuetype (c));
  4401| 			/* if this assertion fails, we need to add a write barrier */
  4402| 			g_assert (!MONO_TYPE_IS_REFERENCE (m_class_get_byval_arg (c)));
  4403| 			stackval_from_data (m_class_get_byval_arg (c), (stackval*)LOCAL_VAR (ip [1], gpointer), LOCAL_VAR (ip [2], gpointer), FALSE);
  4404| 			ip += 4;
  4405| 			MINT_IN_BREAK;
  4406| 		}
  4407| 		MINT_IN_CASE(MINT_CPOBJ_VT) {
  4408| 			MonoClass* const c = (MonoClass*)frame->imethod->data_items[ip [3]];
  4409| 			mono_value_copy_internal (LOCAL_VAR (ip [1], gpointer), LOCAL_VAR (ip [2], gpointer), c);
  4410| 			ip += 4;
  4411| 			MINT_IN_BREAK;
  4412| 		}


# ====================================================================
# FILE: src/mono/mono/mini/interp/transform.c
# Total hunks: 7
# ====================================================================
# --- HUNK 1: Lines 1233-1339 ---
  1233| 		}
  1234| 	case MintOpPair2:
  1235| 		g_string_append_printf (str, " %u <- %u, %u <- %u", data [0], data [1], data [2], data [3]);
  1236| 		break;
  1237| 	case MintOpPair3:
  1238| 		g_string_append_printf (str, " %u <- %u, %u <- %u, %u <- %u", data [0], data [1], data [2], data [3], data [4], data [5]);
  1239| 		break;
  1240| 	case MintOpPair4:
  1241| 		g_string_append_printf (str, " %u <- %u, %u <- %u, %u <- %u, %u <- %u", data [0], data [1], data [2], data [3], data [4], data [5], data [6], data [7]);
  1242| 		break;
  1243| 	default:
  1244| 		g_string_append_printf (str, "unknown arg type\n");
  1245| 	}
  1246| 	return g_string_free (str, FALSE);
  1247| }
  1248| static void
  1249| dump_interp_compacted_ins (const guint16 *ip, const guint16 *start)
  1250| {
  1251| 	int opcode = *ip;
  1252| 	int ins_offset = ip - start;
  1253| 	g_print ("IR_%04x: %-14s", ins_offset, mono_interp_opname (opcode));
  1254| 	ip++;
  1255|         if (mono_interp_op_dregs [opcode] > 0)
  1256|                 g_print (" [%d <-", *ip++);
  1257|         else
  1258|                 g_print (" [nil <-");
  1259|         if (mono_interp_op_sregs [opcode] > 0) {
  1260|                 for (int i = 0; i < mono_interp_op_sregs [opcode]; i++)
  1261|                         g_print (" %d", *ip++);
  1262|                 g_print ("],");
  1263|         } else {
  1264|                 g_print (" nil],");
  1265|         }
  1266| 	char *ins = dump_interp_ins_data (NULL, ins_offset, ip, opcode);
  1267| 	g_print ("%s\n", ins);
  1268| 	g_free (ins);
  1269| }
  1270| static void
  1271| dump_interp_code (const guint16 *start, const guint16* end)
  1272| {
  1273| 	const guint16 *p = start;
  1274| 	while (p < end) {
  1275| 		dump_interp_compacted_ins (p, start);
  1276| 		p = mono_interp_dis_mintop_len (p);
  1277| 	}
  1278| }
  1279| static void
  1280| dump_interp_inst_no_newline (InterpInst *ins)
  1281| {
  1282| 	int opcode = ins->opcode;
  1283| 	g_print ("IL_%04x: %-14s", ins->il_offset, mono_interp_opname (opcode));
  1284| 	if (mono_interp_op_dregs [opcode] > 0)
  1285| 		g_print (" [%d <-", ins->dreg);
  1286| 	else
  1287| 		g_print (" [nil <-");
  1288| 	if (mono_interp_op_sregs [opcode] > 0) {
  1289| 		for (int i = 0; i < mono_interp_op_sregs [opcode]; i++) {
  1290| 			if (ins->sregs [i] == MINT_CALL_ARGS_SREG) {
  1291| 				g_print (" c:");
  1292| 				int *call_args = ins->info.call_args;
  1293| 				if (call_args) {
  1294| 					while (*call_args != -1) {
  1295| 						g_print (" %d", *call_args);
  1296| 						call_args++;
  1297| 					}
  1298| 				}
  1299| 			} else {
  1300| 				g_print (" %d", ins->sregs [i]);
  1301| 			}
  1302| 		}
  1303| 		g_print ("],");
  1304| 	} else {
  1305| 		g_print (" nil],");
  1306| 	}
  1307| 	if (opcode == MINT_LDLOCA_S) {
  1308| 		g_print (" %d", ins->sregs [0]);
  1309| 	} else {
  1310| 		char *descr = dump_interp_ins_data (ins, ins->il_offset, &ins->data [0], ins->opcode);
  1311| 		g_print ("%s", descr);
  1312| 		g_free (descr);
  1313| 	}
  1314| }
  1315| static void
  1316| dump_interp_inst (InterpInst *ins)
  1317| {
  1318| 	dump_interp_inst_no_newline (ins);
  1319| 	g_print ("\n");
  1320| }
  1321| static G_GNUC_UNUSED void
  1322| dump_interp_bb (InterpBasicBlock *bb)
  1323| {
  1324| 	g_print ("BB%d:\n", bb->index);
  1325| 	for (InterpInst *ins = bb->first_ins; ins != NULL; ins = ins->next)
  1326| 		dump_interp_inst (ins);
  1327| }
  1328| /* For debug use */
  1329| void
  1330| mono_interp_print_code (InterpMethod *imethod)
  1331| {
  1332| 	MonoJitInfo *jinfo = imethod->jinfo;
  1333| 	const guint8 *start;
  1334| 	if (!jinfo)
  1335| 		return;
  1336| 	char *name = mono_method_full_name (imethod->method, 1);
  1337| 	g_print ("Method : %s\n", name);
  1338| 	g_free (name);
  1339| 	start = (guint8*) jinfo->code_start;

# --- HUNK 2: Lines 1346-1397 ---
  1346| 	InterpInst *ins = td->first_ins;
  1347| 	char *name = mono_method_full_name (td->method, TRUE);
  1348| 	g_print ("IR for \"%s\"\n", name);
  1349| 	g_free (name);
  1350| 	while (ins) {
  1351| 		dump_interp_inst (ins);
  1352| 		ins = ins->next;
  1353| 	}
  1354| }
  1355| static MonoMethodHeader*
  1356| interp_method_get_header (MonoMethod* method, MonoError *error)
  1357| {
  1358| 	/* An explanation: mono_method_get_header_internal returns an error if
  1359| 	 * called on a method with no body (e.g. an abstract method, or an
  1360| 	 * icall).  We don't want that.
  1361| 	 */
  1362| 	if (mono_method_has_no_body (method))
  1363| 		return NULL;
  1364| 	else
  1365| 		return mono_method_get_header_internal (method, error);
  1366| }
  1367| /* stores top of stack as local and pushes address of it on stack */
  1368| static void
  1369| emit_store_value_as_local (TransformData *td, MonoType *src)
  1370| {
  1371| 	int local = create_interp_local (td, mini_native_type_replace_type (src));
  1372| 	store_local (td, local);
  1373| 	interp_add_ins (td, MINT_LDLOCA_S);
  1374| 	push_simple_type (td, STACK_TYPE_MP);
  1375| 	interp_ins_set_dreg (td->last_ins, td->sp [-1].local);
  1376| 	interp_ins_set_sreg (td->last_ins, local);
  1377| 	td->locals [local].indirects++;
  1378| }
  1379| static gboolean
  1380| interp_ip_in_cbb (TransformData *td, int il_offset)
  1381| {
  1382| 	InterpBasicBlock *bb = td->offset_to_bb [il_offset];
  1383| 	return bb == NULL || bb == td->cbb;
  1384| }
  1385| static gboolean
  1386| interp_ins_is_ldc (InterpInst *ins)
  1387| {
  1388| 	return ins->opcode >= MINT_LDC_I4_M1 && ins->opcode <= MINT_LDC_I8;
  1389| }
  1390| static gint32
  1391| interp_get_const_from_ldc_i4 (InterpInst *ins)
  1392| {
  1393| 	switch (ins->opcode) {
  1394| 	case MINT_LDC_I4_M1: return -1;
  1395| 	case MINT_LDC_I4_0: return 0;
  1396| 	case MINT_LDC_I4_1: return 1;
  1397| 	case MINT_LDC_I4_2: return 2;

# --- HUNK 3: Lines 1638-1705 ---
  1638| #endif
  1639| 			break;
  1640| 		case 2:
  1641| #if SIZEOF_VOID_P == 4
  1642| 			interp_add_ins (td, MINT_STIND_R4);
  1643| #else
  1644| 			interp_add_ins (td, MINT_STIND_R8);
  1645| #endif
  1646| 			break;
  1647| 		}
  1648| 		td->sp -= 2;
  1649| 		interp_ins_set_sregs2 (td->last_ins, td->sp [0].local, td->sp [1].local);
  1650| 		td->ip += 5;
  1651| 		return TRUE;
  1652| 	} else if (!strcmp ("op_Implicit", tm ) || !strcmp ("op_Explicit", tm)) {
  1653| 		MonoType *src = csignature->params [0];
  1654| 		MonoType *dst = csignature->ret;
  1655| 		MonoClass *src_klass = mono_class_from_mono_type_internal (src);
  1656| 		int src_size = mini_magic_type_size (NULL, src);
  1657| 		int dst_size = mini_magic_type_size (NULL, dst);
  1658| 		gboolean store_value_as_local = FALSE;
  1659| 		switch (type_index) {
  1660| 		case 0: case 1:
  1661| 			if (!mini_magic_is_int_type (src) || !mini_magic_is_int_type (dst)) {
  1662| 				if (mini_magic_is_int_type (src))
  1663| 					store_value_as_local = TRUE;
  1664| 				else if (mono_class_is_magic_float (src_klass))
  1665| 					store_value_as_local = TRUE;
  1666| 				else
  1667| 					return FALSE;
  1668| 			}
  1669| 			break;
  1670| 		case 2:
  1671| 			if (!mini_magic_is_float_type (src) || !mini_magic_is_float_type (dst)) {
  1672| 				if (mini_magic_is_float_type (src))
  1673| 					store_value_as_local = TRUE;
  1674| 				else if (mono_class_is_magic_int (src_klass))
  1675| 					store_value_as_local = TRUE;
  1676| 				else
  1677| 					return FALSE;
  1678| 			}
  1679| 			break;
  1680| 		}
  1681| 		if (store_value_as_local) {
  1682| 			emit_store_value_as_local (td, src);
  1683| 			/* emit call to managed conversion method */
  1684| 			return FALSE;
  1685| 		}
  1686| 		if (src_size > dst_size) { // 8 -> 4
  1687| 			switch (type_index) {
  1688| 			case 0: case 1:
  1689| 				interp_add_conv (td, td->sp - 1, NULL, STACK_TYPE_I4, MINT_MOV_8);
  1690| 				break;
  1691| 			case 2:
  1692| 				interp_add_conv (td, td->sp - 1, NULL, STACK_TYPE_R4, MINT_CONV_R4_R8);
  1693| 				break;
  1694| 			}
  1695| 		}
  1696| 		if (src_size < dst_size) { // 4 -> 8
  1697| 			switch (type_index) {
  1698| 			case 0:
  1699| 				interp_add_conv (td, td->sp - 1, NULL, STACK_TYPE_I8, MINT_CONV_I8_I4);
  1700| 				break;
  1701| 			case 1:
  1702| 				interp_add_conv (td, td->sp - 1, NULL, STACK_TYPE_I8, MINT_CONV_I8_U4);
  1703| 				break;
  1704| 			case 2:
  1705| 				interp_add_conv (td, td->sp - 1, NULL, STACK_TYPE_R8, MINT_CONV_R8_R4);

# --- HUNK 4: Lines 1719-1765 ---
  1719| 		td->sp--;
  1720| 		interp_ins_set_sreg (td->last_ins, td->sp [0].local);
  1721| 		push_type (td, stack_type [mt], magic_class);
  1722| 		interp_ins_set_dreg (td->last_ins, td->sp [-1].local);
  1723| 		td->ip += 5;
  1724| 		return TRUE;
  1725| 	} else if (!strcmp ("op_Decrement", tm)) {
  1726| 		g_assert (type_index != 2); // no nfloat
  1727| #if SIZEOF_VOID_P == 8
  1728| 		interp_add_ins (td, MINT_SUB1_I8);
  1729| #else
  1730| 		interp_add_ins (td, MINT_SUB1_I4);
  1731| #endif
  1732| 		td->sp--;
  1733| 		interp_ins_set_sreg (td->last_ins, td->sp [0].local);
  1734| 		push_type (td, stack_type [mt], magic_class);
  1735| 		interp_ins_set_dreg (td->last_ins, td->sp [-1].local);
  1736| 		td->ip += 5;
  1737| 		return TRUE;
  1738| 	} else if (!strcmp ("CompareTo", tm) || !strcmp ("Equals", tm)) {
  1739| 		MonoType *arg = csignature->params [0];
  1740| 		int mt = mint_type (arg);
  1741| 		/* on 'System.n*::{CompareTo,Equals} (System.n*)' variant we need to push managed
  1742| 		 * pointer instead of value */
  1743| 		if (mt != MINT_TYPE_O)
  1744| 			emit_store_value_as_local (td, arg);
  1745| 		/* emit call to managed conversion method */
  1746| 		return FALSE;
  1747| 	} else if (!strcmp (".cctor", tm)) {
  1748| 		return FALSE;
  1749| 	} else if (!strcmp ("Parse", tm)) {
  1750| 		return FALSE;
  1751| 	} else if (!strcmp ("ToString", tm)) {
  1752| 		return FALSE;
  1753| 	} else if (!strcmp ("GetHashCode", tm)) {
  1754| 		return FALSE;
  1755| 	} else if (!strcmp ("IsNaN", tm) || !strcmp ("IsInfinity", tm) || !strcmp ("IsNegativeInfinity", tm) || !strcmp ("IsPositiveInfinity", tm)) {
  1756| 		g_assert (type_index == 2); // nfloat only
  1757| 		return FALSE;
  1758| 	}
  1759| 	for (i = 0; i < sizeof (int_unnop) / sizeof  (MagicIntrinsic); ++i) {
  1760| 		if (!strcmp (int_unnop [i].op_name, tm)) {
  1761| 			interp_add_ins (td, int_unnop [i].insn [type_index]);
  1762| 			td->sp--;
  1763| 			interp_ins_set_sreg (td->last_ins, td->sp [0].local);
  1764| 			push_type (td, stack_type [mt], magic_class);
  1765| 			interp_ins_set_dreg (td->last_ins, td->sp [-1].local);

# --- HUNK 5: Lines 2480-2521 ---
  2480| 		return FALSE;
  2481| 	if (header.code_size >= INLINE_LENGTH_LIMIT && !(method->iflags & METHOD_IMPL_ATTRIBUTE_AGGRESSIVE_INLINING))
  2482| 		return FALSE;
  2483| 	if (mono_class_needs_cctor_run (method->klass, NULL)) {
  2484| 		MonoVTable *vtable;
  2485| 		ERROR_DECL (error);
  2486| 		if (!m_class_get_runtime_vtable (method->klass))
  2487| 			/* No vtable created yet */
  2488| 			return FALSE;
  2489| 		vtable = mono_class_vtable_checked (method->klass, error);
  2490| 		if (!is_ok (error)) {
  2491| 			mono_interp_error_cleanup (error);
  2492| 			return FALSE;
  2493| 		}
  2494| 		if (!vtable->initialized)
  2495| 			return FALSE;
  2496| 	}
  2497| 	/* We currently access at runtime the wrapper data */
  2498| 	if (method->wrapper_type != MONO_WRAPPER_NONE)
  2499| 		return FALSE;
  2500| 	/* Our usage of `emit_store_value_as_local ()` for nint, nuint and nfloat
  2501| 	 * is kinda hacky, and doesn't work with the inliner */
  2502| 	if (mono_class_get_magic_index (method->klass) >= 0)
  2503| 		return FALSE;
  2504| 	if (td->prof_coverage)
  2505| 		return FALSE;
  2506| 	if (!is_metadata_update_disabled () && mono_metadata_update_no_inline (td->method, method))
  2507| 		return FALSE;
  2508| 	if (g_list_find (td->dont_inline, method))
  2509| 		return FALSE;
  2510| 	return TRUE;
  2511| }
  2512| static gboolean
  2513| interp_inline_method (TransformData *td, MonoMethod *target_method, MonoMethodHeader *header, MonoError *error)
  2514| {
  2515| 	const unsigned char *prev_ip, *prev_il_code, *prev_in_start;
  2516| 	int *prev_in_offsets;
  2517| 	gboolean ret;
  2518| 	unsigned int prev_max_stack_height, prev_locals_size;
  2519| 	int prev_n_data_items;
  2520| 	int i; 
  2521| 	int prev_sp_offset;

# --- HUNK 6: Lines 3838-3877 ---
  3838| 	InterpMethod *rtm = td->rtm;
  3839| 	MonoMethodSignature *signature = mono_method_signature_internal (method);
  3840| 	int num_args = signature->hasthis + signature->param_count;
  3841| 	int arglist_local = -1;
  3842| 	gboolean ret = TRUE;
  3843| 	gboolean emitted_funccall_seq_point = FALSE;
  3844| 	guint32 *arg_locals = NULL;
  3845| 	guint32 *local_locals = NULL;
  3846| 	InterpInst *last_seq_point = NULL;
  3847| 	gboolean save_last_error = FALSE;
  3848| 	gboolean link_bblocks = TRUE;
  3849| 	gboolean inlining = td->method != method;
  3850| 	InterpBasicBlock *exit_bb = NULL;
  3851| 	original_bb = bb = mono_basic_block_split (method, error, header);
  3852| 	goto_if_nok (error, exit);
  3853| 	g_assert (bb);
  3854| 	td->il_code = header->code;
  3855| 	td->in_start = td->ip = header->code;
  3856| 	end = td->ip + header->code_size;
  3857| 	td->cbb = td->entry_bb = (InterpBasicBlock*)mono_mempool_alloc0 (td->mempool, sizeof (InterpBasicBlock));
  3858| 	td->cbb->index = td->bb_count++;
  3859| 	td->cbb->native_offset = -1;
  3860| 	td->cbb->stack_height = td->sp - td->stack;
  3861| 	if (inlining) {
  3862| 		exit_bb = (InterpBasicBlock*)mono_mempool_alloc0 (td->mempool, sizeof (InterpBasicBlock));
  3863| 		exit_bb->index = td->bb_count++;
  3864| 		exit_bb->native_offset = -1;
  3865| 		exit_bb->stack_height = -1;
  3866| 	}
  3867| 	get_basic_blocks (td, header, td->gen_sdb_seq_points);
  3868| 	if (!inlining)
  3869| 		initialize_clause_bblocks (td);
  3870| 	if (td->gen_sdb_seq_points && !inlining) {
  3871| 		MonoDebugMethodInfo *minfo;
  3872| 		minfo = mono_debug_lookup_method (method);
  3873| 		if (minfo) {
  3874| 			MonoSymSeqPoint *sps;
  3875| 			int i, n_il_offsets;
  3876| 			mono_debug_get_seq_points (minfo, NULL, NULL, NULL, &sps, &n_il_offsets);
  3877| 			seq_point_locs = mono_bitset_mem_new (mono_mempool_alloc0 (td->mempool, mono_bitset_alloc_size (header->code_size, 0)), header->code_size, 0);

# --- HUNK 7: Lines 5336-5375 ---
  5336| 			break;
  5337| 		}
  5338| 		case CEE_LDFLD: {
  5339| 			CHECK_STACK (td, 1);
  5340| 			token = read32 (td->ip + 1);
  5341| 			field = interp_field_from_token (method, token, &klass, generic_context, error);
  5342| 			goto_if_nok (error, exit);
  5343| 			MonoType *ftype = mono_field_get_type_internal (field);
  5344| 			gboolean is_static = !!(ftype->attrs & FIELD_ATTRIBUTE_STATIC);
  5345| 			mono_class_init_internal (klass);
  5346| 			MonoClass *field_klass = mono_class_from_mono_type_internal (ftype);
  5347| 			mt = mint_type (m_class_get_byval_arg (field_klass));
  5348| 			int field_size = mono_class_value_size (field_klass, NULL);
  5349| 			int obj_size = mono_class_value_size (klass, NULL);
  5350| 			obj_size = ALIGN_TO (obj_size, MINT_VT_ALIGNMENT);
  5351| 			{
  5352| 				if (is_static) {
  5353| 					td->sp--;
  5354| 					interp_emit_sfld_access (td, field, field_klass, mt, TRUE, error);
  5355| 					goto_if_nok (error, exit);
  5356| 				} else if (td->sp [-1].type == STACK_TYPE_VT) {
  5357| 					int size = 0;
  5358| 					/* First we pop the vt object from the stack. Then we push the field */
  5359| #ifdef NO_UNALIGNED_ACCESS
  5360| 					if (field->offset % SIZEOF_VOID_P != 0) {
  5361| 						if (mt == MINT_TYPE_I8 || mt == MINT_TYPE_R8)
  5362| 							size = 8;
  5363| 					}
  5364| #endif
  5365| 					interp_add_ins (td, MINT_MOV_OFF);
  5366| 					g_assert (m_class_is_valuetype (klass));
  5367| 					td->sp--;
  5368| 					interp_ins_set_sreg (td->last_ins, td->sp [0].local);
  5369| 					td->last_ins->data [0] = field->offset - MONO_ABI_SIZEOF (MonoObject);
  5370| 					td->last_ins->data [1] = mt;
  5371| 					if (mt == MINT_TYPE_VT)
  5372| 						size = field_size;
  5373| 					td->last_ins->data [2] = size;
  5374| 					if (mt == MINT_TYPE_VT)
  5375| 						push_type_vt (td, field_klass, field_size);


# ====================================================================
# FILE: src/mono/mono/mini/intrinsics.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1577-1622 ---
  1577| 				NULLIFY_INS (args [0]);
  1578| 				return ins;
  1579| 			}
  1580| 		}
  1581| 	} else if (cmethod->klass == mono_defaults.systemtype_class && !strcmp (cmethod->name, "op_Equality") &&
  1582| 			args [0]->klass == mono_defaults.runtimetype_class && args [1]->klass == mono_defaults.runtimetype_class) {
  1583| 		EMIT_NEW_BIALU (cfg, ins, OP_COMPARE, -1, args [0]->dreg, args [1]->dreg);
  1584| 		MONO_INST_NEW (cfg, ins, OP_PCEQ);
  1585| 		ins->dreg = alloc_preg (cfg);
  1586| 		ins->type = STACK_I4;
  1587| 		MONO_ADD_INS (cfg->cbb, ins);
  1588| 		return ins;
  1589| 	} else if (cmethod->klass == mono_defaults.systemtype_class && !strcmp (cmethod->name, "op_Inequality") &&
  1590| 			args [0]->klass == mono_defaults.runtimetype_class && args [1]->klass == mono_defaults.runtimetype_class) {
  1591| 		EMIT_NEW_BIALU (cfg, ins, OP_COMPARE, -1, args [0]->dreg, args [1]->dreg);
  1592| 		MONO_INST_NEW (cfg, ins, OP_ICNEQ);
  1593| 		ins->dreg = alloc_preg (cfg);
  1594| 		ins->type = STACK_I4;
  1595| 		MONO_ADD_INS (cfg->cbb, ins);
  1596| 		return ins;
  1597| 	} else if (((!strcmp (cmethod_klass_image->assembly->aname.name, "MonoMac") ||
  1598| 	            !strcmp (cmethod_klass_image->assembly->aname.name, "monotouch")) &&
  1599| 				!strcmp (cmethod_klass_name_space, "XamCore.ObjCRuntime") &&
  1600| 				!strcmp (cmethod_klass_name, "Selector")) ||
  1601| 			   ((!strcmp (cmethod_klass_image->assembly->aname.name, "Xamarin.iOS") ||
  1602| 				 !strcmp (cmethod_klass_image->assembly->aname.name, "Xamarin.Mac")) &&
  1603| 				!strcmp (cmethod_klass_name_space, "ObjCRuntime") &&
  1604| 				!strcmp (cmethod_klass_name, "Selector"))
  1605| 			   ) {
  1606| 		if ((cfg->backend->have_objc_get_selector || cfg->compile_llvm) &&
  1607| 			!strcmp (cmethod->name, "GetHandle") && fsig->param_count == 1 &&
  1608| 		    (args [0]->opcode == OP_GOT_ENTRY || args [0]->opcode == OP_AOTCONST) &&
  1609| 		    cfg->compile_aot) {
  1610| 			MonoInst *pi;
  1611| 			MonoJumpInfoToken *ji;
  1612| 			char *s;
  1613| 			if (args [0]->opcode == OP_GOT_ENTRY) {
  1614| 				pi = (MonoInst *)args [0]->inst_p1;
  1615| 				g_assert (pi->opcode == OP_PATCH_INFO);
  1616| 				g_assert (GPOINTER_TO_INT (pi->inst_p1) == MONO_PATCH_INFO_LDSTR);
  1617| 				ji = (MonoJumpInfoToken *)pi->inst_p0;
  1618| 			} else {
  1619| 				g_assert (GPOINTER_TO_INT (args [0]->inst_p1) == MONO_PATCH_INFO_LDSTR);
  1620| 				ji = (MonoJumpInfoToken *)args [0]->inst_p0;
  1621| 			}
  1622| 			NULLIFY_INS (args [0]);


# ====================================================================
# FILE: src/mono/mono/mini/jit-icalls.c
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 707-805 ---
   707| 		mono_error_set_pending_exception (error);
   708| 		return NULL;
   709| 	}
   710| 	mono_class_init_internal (handle_class);
   711| 	return res;
   712| }
   713| gpointer
   714| mono_ldtoken_wrapper_generic_shared (MonoImage *image, int token, MonoMethod *method)
   715| {
   716| 	MonoMethodSignature *sig = mono_method_signature_internal (method);
   717| 	MonoGenericContext *generic_context;
   718| 	if (sig->is_inflated) {
   719| 		generic_context = mono_method_get_context (method);
   720| 	} else {
   721| 		MonoGenericContainer *generic_container = mono_method_get_generic_container (method);
   722| 		g_assert (generic_container);
   723| 		generic_context = &generic_container->context;
   724| 	}
   725| 	return mono_ldtoken_wrapper (image, token, generic_context);
   726| }
   727| guint64
   728| mono_fconv_u8 (double v)
   729| {
   730| #if defined(TARGET_X86) || defined(TARGET_AMD64)
   731| 	const double two63 = 2147483648.0 * 4294967296.0;
   732| 	if (v < two63) {
   733| 		return (gint64)v;
   734| 	} else {
   735| 		return (gint64)(v - two63) + ((guint64)1 << 63);
   736| 	}
   737| #else
   738| 	if (mono_isinf (v) || mono_isnan (v))
   739| 		return 0;
   740| 	return (guint64)v;
   741| #endif
   742| }
   743| #ifdef MONO_ARCH_EMULATE_FCONV_TO_U8
   744| guint64
   745| mono_fconv_u8_2 (double v)
   746| {
   747| 	return mono_fconv_u8 (v);
   748| }
   749| guint64
   750| mono_rconv_u8 (float v)
   751| {
   752| #if defined(TARGET_X86) || defined(TARGET_AMD64)
   753| 	const float two63 = 2147483648.0 * 4294967296.0;
   754| 	if (v < two63) {
   755| 		return (gint64)v;
   756| 	} else {
   757| 		return (gint64)(v - two63) + ((guint64)1 << 63);
   758| 	}
   759| #else
   760| 	if (mono_isinf (v) || mono_isnan (v))
   761| 		return 0;
   762| 	return (guint64)v;
   763| #endif
   764| }
   765| #endif
   766| #ifdef MONO_ARCH_EMULATE_FCONV_TO_I8
   767| gint64
   768| mono_fconv_i8 (double v)
   769| {
   770| 	return (gint64)v;
   771| }
   772| #endif
   773| guint32
   774| mono_fconv_u4 (double v)
   775| {
   776| 	/* MS.NET behaves like this for some reason */
   777| 	if (mono_isinf (v) || mono_isnan (v))
   778| 		return 0;
   779| 	return (guint32)v;
   780| }
   781| #ifdef MONO_ARCH_EMULATE_FCONV_TO_U4
   782| guint32
   783| mono_fconv_u4_2 (double v)
   784| {
   785| 	return mono_fconv_u4 (v);
   786| }
   787| guint32
   788| mono_rconv_u4 (float v)
   789| {
   790| 	if (mono_isinf (v) || mono_isnan (v))
   791| 		return 0;
   792| 	return (guint32) v;
   793| }
   794| #endif
   795| gint64
   796| mono_fconv_ovf_i8 (double v)
   797| {
   798| 	const gint64 res = (gint64)v;
   799| 	if (mono_isnan (v) || mono_trunc (v) != res) {
   800| 		ERROR_DECL (error);
   801| 		mono_error_set_overflow (error);
   802| 		mono_error_set_pending_exception (error);
   803| 		return 0;
   804| 	}
   805| 	return res;


# ====================================================================
# FILE: src/mono/mono/mini/jit-icalls.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 21-65 ---
    21| ICALL_EXPORT gint32 mono_imul_ovf (gint32 a, gint32 b);
    22| ICALL_EXPORT gint32 mono_imul_ovf_un (guint32 a, guint32 b);
    23| ICALL_EXPORT double mono_fdiv (double a, double b);
    24| ICALL_EXPORT gint64 mono_lldiv (gint64 a, gint64 b);
    25| ICALL_EXPORT gint64 mono_llrem (gint64 a, gint64 b);
    26| ICALL_EXPORT guint64 mono_lldiv_un (guint64 a, guint64 b);
    27| ICALL_EXPORT guint64 mono_llrem_un (guint64 a, guint64 b);
    28| ICALL_EXPORT guint64 mono_lshl (guint64 a, gint32 shamt);
    29| ICALL_EXPORT guint64 mono_lshr_un (guint64 a, gint32 shamt);
    30| ICALL_EXPORT gint64 mono_lshr (gint64 a, gint32 shamt);
    31| ICALL_EXPORT MonoArray *mono_array_new_n_icall (MonoMethod *cm, gint32 param_count, intptr_t *params);
    32| ICALL_EXPORT MonoArray *mono_array_new_2_jagged (MonoMethod *cm, guint32 length1, guint32 length2);
    33| ICALL_EXPORT MonoArray *mono_array_new_1 (MonoMethod *cm, guint32 length);
    34| ICALL_EXPORT MonoArray *mono_array_new_2 (MonoMethod *cm, guint32 length1, guint32 length2);
    35| ICALL_EXPORT MonoArray *mono_array_new_3 (MonoMethod *cm, guint32 length1, guint32 length2, guint32 length3);
    36| ICALL_EXPORT MonoArray *mono_array_new_4 (MonoMethod *cm, guint32 length1, guint32 length2, guint32 length3, guint32 length4);
    37| ICALL_EXPORT gpointer mono_class_static_field_address (MonoClassField *field);
    38| ICALL_EXPORT gpointer mono_ldtoken_wrapper (MonoImage *image, int token, MonoGenericContext *context);
    39| ICALL_EXPORT gpointer mono_ldtoken_wrapper_generic_shared (MonoImage *image, int token, MonoMethod *method);
    40| ICALL_EXPORT guint64 mono_fconv_u8 (double v);
    41| ICALL_EXPORT guint64 mono_fconv_u8_2 (double v);
    42| ICALL_EXPORT guint64 mono_rconv_u8 (float v);
    43| ICALL_EXPORT gint64 mono_fconv_i8 (double v);
    44| ICALL_EXPORT guint32 mono_fconv_u4 (double v);
    45| ICALL_EXPORT guint32 mono_fconv_u4_2 (double v);
    46| ICALL_EXPORT guint32 mono_rconv_u4 (float v);
    47| ICALL_EXPORT gint64 mono_fconv_ovf_i8 (double v);
    48| ICALL_EXPORT guint64 mono_fconv_ovf_u8 (double v);
    49| ICALL_EXPORT gint64 mono_rconv_i8 (float v);
    50| ICALL_EXPORT gint64 mono_rconv_ovf_i8 (float v);
    51| ICALL_EXPORT guint64 mono_rconv_ovf_u8 (float v);
    52| ICALL_EXPORT double mono_lconv_to_r8 (gint64 a);
    53| ICALL_EXPORT double mono_conv_to_r8 (gint32 a);
    54| ICALL_EXPORT double mono_conv_to_r4 (gint32 a);
    55| ICALL_EXPORT float mono_lconv_to_r4 (gint64 a);
    56| ICALL_EXPORT double mono_conv_to_r8_un (guint32 a);
    57| ICALL_EXPORT double mono_lconv_to_r8_un (guint64 a);
    58| ICALL_EXPORT gpointer mono_helper_compile_generic_method (MonoObject *obj, MonoMethod *method, gpointer *this_arg);
    59| ICALL_EXPORT MonoString *mono_helper_ldstr (MonoImage *image, guint32 idx);
    60| ICALL_EXPORT MonoString *mono_helper_ldstr_mscorlib (guint32 idx);
    61| ICALL_EXPORT MonoObject *mono_helper_newobj_mscorlib (guint32 idx);
    62| ICALL_EXPORT double mono_fsub (double a, double b);
    63| ICALL_EXPORT double mono_fadd (double a, double b);
    64| ICALL_EXPORT double mono_fmul (double a, double b);
    65| ICALL_EXPORT double mono_fneg (double a);


# ====================================================================
# FILE: src/mono/mono/mini/method-to-ir.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1016-1056 ---
  1016| 		break;
  1017| 	case MONO_CEE_CONV_U:
  1018| 		ins->type = STACK_PTR;
  1019| 		switch (src1->type) {
  1020| 		case STACK_I4:
  1021| 			ins->opcode = OP_ICONV_TO_U;
  1022| 			break;
  1023| 		case STACK_PTR:
  1024| 		case STACK_MP:
  1025| 		case STACK_OBJ:
  1026| #if TARGET_SIZEOF_VOID_P == 8
  1027| 			ins->opcode = OP_LCONV_TO_U;
  1028| #else
  1029| 			ins->opcode = OP_MOVE;
  1030| #endif
  1031| 			break;
  1032| 		case STACK_I8:
  1033| 			ins->opcode = OP_LCONV_TO_U;
  1034| 			break;
  1035| 		case STACK_R8:
  1036| 			ins->opcode = OP_FCONV_TO_U;
  1037| 			break;
  1038| 		case STACK_R4:
  1039| 			if (TARGET_SIZEOF_VOID_P == 8)
  1040| 				ins->opcode = OP_RCONV_TO_U8;
  1041| 			else
  1042| 				ins->opcode = OP_RCONV_TO_U4;
  1043| 			break;
  1044| 		}
  1045| 		break;
  1046| 	case MONO_CEE_CONV_I8:
  1047| 	case MONO_CEE_CONV_U8:
  1048| 		ins->type = STACK_I8;
  1049| 		ins->opcode += unops_op_map [src1->type];
  1050| 		break;
  1051| 	case MONO_CEE_CONV_OVF_I8:
  1052| 	case MONO_CEE_CONV_OVF_U8:
  1053| 		ins->type = STACK_I8;
  1054| 		ins->opcode += ovf3ops_op_map [src1->type];
  1055| 		break;
  1056| 	case MONO_CEE_CONV_OVF_U8_UN:


# ====================================================================
# FILE: src/mono/mono/mini/mini-arm.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 5077-5117 ---
  5077| 			}
  5078| 			break;
  5079| 		}
  5080| 		case OP_FCONV_TO_I1:
  5081| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 1, TRUE);
  5082| 			break;
  5083| 		case OP_FCONV_TO_U1:
  5084| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 1, FALSE);
  5085| 			break;
  5086| 		case OP_FCONV_TO_I2:
  5087| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 2, TRUE);
  5088| 			break;
  5089| 		case OP_FCONV_TO_U2:
  5090| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 2, FALSE);
  5091| 			break;
  5092| 		case OP_FCONV_TO_I4:
  5093| 		case OP_FCONV_TO_I:
  5094| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 4, TRUE);
  5095| 			break;
  5096| 		case OP_FCONV_TO_U4:
  5097| 		case OP_FCONV_TO_U:
  5098| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 4, FALSE);
  5099| 			break;
  5100| 		case OP_FCONV_TO_I8:
  5101| 		case OP_FCONV_TO_U8:
  5102| 			g_assert_not_reached ();
  5103| 			/* Implemented as helper calls */
  5104| 			break;
  5105| 		case OP_LCONV_TO_R_UN:
  5106| 			g_assert_not_reached ();
  5107| 			/* Implemented as helper calls */
  5108| 			break;
  5109| 		case OP_LCONV_TO_OVF_I4_2: {
  5110| 			guint8 *high_bit_not_set, *valid_negative, *invalid_negative, *valid_positive;
  5111| 			/* 
  5112| 			 * Valid ints: 0xffffffff:8000000 to 00000000:0x7f000000
  5113| 			 */
  5114| 			ARM_CMP_REG_IMM8 (code, ins->sreg1, 0);
  5115| 			high_bit_not_set = code;
  5116| 			ARM_B_COND (code, ARMCOND_GE, 0); /*branch if bit 31 of the lower part is not set*/
  5117| 			ARM_CMN_REG_IMM8 (code, ins->sreg2, 1); /*This have the same effect as CMP reg, 0xFFFFFFFF */


# ====================================================================
# FILE: src/mono/mono/mini/mini-llvm.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 871-911 ---
   871| 		return LLVMInt32Type ();
   872| 	case OP_FCONV_TO_I8:
   873| 		return LLVMInt64Type ();
   874| 	case OP_FCONV_TO_I1:
   875| 	case OP_FCONV_TO_U1:
   876| 	case OP_RCONV_TO_I1:
   877| 	case OP_RCONV_TO_U1:
   878| 		return LLVMInt8Type ();
   879| 	case OP_FCONV_TO_I2:
   880| 	case OP_FCONV_TO_U2:
   881| 	case OP_RCONV_TO_I2:
   882| 	case OP_RCONV_TO_U2:
   883| 		return LLVMInt16Type ();
   884| 	case OP_FCONV_TO_U4:
   885| 	case OP_RCONV_TO_U4:
   886| 		return LLVMInt32Type ();
   887| 	case OP_FCONV_TO_U8:
   888| 	case OP_RCONV_TO_U8:
   889| 		return LLVMInt64Type ();
   890| 	case OP_FCONV_TO_I:
   891| 	case OP_FCONV_TO_U:
   892| 		return TARGET_SIZEOF_VOID_P == 8 ? LLVMInt64Type () : LLVMInt32Type ();
   893| 	case OP_IADD_OVF:
   894| 	case OP_IADD_OVF_UN:
   895| 	case OP_ISUB_OVF:
   896| 	case OP_ISUB_OVF_UN:
   897| 	case OP_IMUL_OVF:
   898| 	case OP_IMUL_OVF_UN:
   899| 		return LLVMInt32Type ();
   900| 	case OP_LADD_OVF:
   901| 	case OP_LADD_OVF_UN:
   902| 	case OP_LSUB_OVF:
   903| 	case OP_LSUB_OVF_UN:
   904| 	case OP_LMUL_OVF:
   905| 	case OP_LMUL_OVF_UN:
   906| 		return LLVMInt64Type ();
   907| 	default:
   908| 		printf ("%s\n", mono_inst_name (opcode));
   909| 		g_assert_not_reached ();
   910| 		return NULL;
   911| 	}


# ====================================================================
# FILE: src/mono/mono/mini/mini-mips.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 3829-3869 ---
  3829| 			mips_mtc1 (code, mips_ftemp, ins->sreg1);
  3830| 			mips_cvtdw (code, ins->dreg, mips_ftemp);
  3831| 			break;
  3832| 		case OP_FCONV_TO_I1:
  3833| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 1, TRUE);
  3834| 			break;
  3835| 		case OP_FCONV_TO_U1:
  3836| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 1, FALSE);
  3837| 			break;
  3838| 		case OP_FCONV_TO_I2:
  3839| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 2, TRUE);
  3840| 			break;
  3841| 		case OP_FCONV_TO_U2:
  3842| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 2, FALSE);
  3843| 			break;
  3844| 		case OP_FCONV_TO_I4:
  3845| 		case OP_FCONV_TO_I:
  3846| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 4, TRUE);
  3847| 			break;
  3848| 		case OP_FCONV_TO_U4:
  3849| 		case OP_FCONV_TO_U:
  3850| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 4, FALSE);
  3851| 			break;
  3852| 		case OP_SQRT:
  3853| 			mips_fsqrtd (code, ins->dreg, ins->sreg1);
  3854| 			break;
  3855| 		case OP_FADD:
  3856| 			mips_faddd (code, ins->dreg, ins->sreg1, ins->sreg2);
  3857| 			break;
  3858| 		case OP_FSUB:
  3859| 			mips_fsubd (code, ins->dreg, ins->sreg1, ins->sreg2);
  3860| 			break;		
  3861| 		case OP_FMUL:
  3862| 			mips_fmuld (code, ins->dreg, ins->sreg1, ins->sreg2);
  3863| 			break;		
  3864| 		case OP_FDIV:
  3865| 			mips_fdivd (code, ins->dreg, ins->sreg1, ins->sreg2);
  3866| 			break;		
  3867| 		case OP_FNEG:
  3868| 			mips_fnegd (code, ins->dreg, ins->sreg1);
  3869| 			break;		


# ====================================================================
# FILE: src/mono/mono/mini/mini-native-types.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 295-334 ---
   295| 			return emit_intrinsics (cfg, cmethod, fsig, args, &type_info [1]);
   296| 	} else if (mono_class_is_magic_float (cmethod->klass))
   297| 		return emit_intrinsics (cfg, cmethod, fsig, args, &type_info [2]);
   298| 	return NULL;
   299| }
   300| #endif /* !DISABLE_JIT */
   301| static gboolean
   302| mono_class_is_magic_assembly (MonoClass *klass)
   303| {
   304| 	const char *aname = m_class_get_image (klass)->assembly_name;
   305| 	if (!aname)
   306| 		return FALSE;
   307| 	if (!strcmp ("Xamarin.iOS", aname))
   308| 		return TRUE;
   309| 	if (!strcmp ("Xamarin.Mac", aname))
   310| 		return TRUE;
   311| 	if (!strcmp ("Xamarin.WatchOS", aname))
   312| 		return TRUE;
   313| 	if (!strcmp ("Xamarin.MacCatalyst", aname))
   314| 		return TRUE;
   315| 	/* regression test suite */
   316| 	if (!strcmp ("builtin-types", aname))
   317| 		return TRUE;
   318| 	if (!strcmp ("mini_tests", aname))
   319| 		return TRUE;
   320| 	return FALSE;
   321| }
   322| gboolean
   323| mono_class_is_magic_int (MonoClass *klass)
   324| {
   325| 	static MonoClass *magic_nint_class;
   326| 	static MonoClass *magic_nuint_class;
   327| 	if (klass == magic_nint_class)
   328| 		return TRUE;
   329| 	if (klass == magic_nuint_class)
   330| 		return TRUE;
   331| 	if (magic_nint_class && magic_nuint_class)
   332| 		return FALSE;
   333| 	if (!mono_class_is_magic_assembly (klass))
   334| 		return FALSE;


# ====================================================================
# FILE: src/mono/mono/mini/mini-ops.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 508-548 ---
   508| MINI_OP(OP_FCONV_TO_OVF_I2,"float_conv_to_ovf_i2", IREG, FREG, NONE)
   509| MINI_OP(OP_FCONV_TO_OVF_U2,"float_conv_to_ovf_u2", IREG, FREG, NONE)
   510| MINI_OP(OP_FCONV_TO_OVF_I4,"float_conv_to_ovf_i4", IREG, FREG, NONE)
   511| MINI_OP(OP_FCONV_TO_OVF_U4,"float_conv_to_ovf_u4", IREG, FREG, NONE)
   512| MINI_OP(OP_FCONV_TO_OVF_I8,"float_conv_to_ovf_i8", LREG, FREG, NONE)
   513| MINI_OP(OP_FCONV_TO_OVF_U8,"float_conv_to_ovf_u8", LREG, FREG, NONE)
   514| /* These do the comparison too */
   515| MINI_OP(OP_FCEQ,   "float_ceq", IREG, FREG, FREG)
   516| MINI_OP(OP_FCGT,   "float_cgt", IREG, FREG, FREG)
   517| MINI_OP(OP_FCGT_UN,"float_cgt_un", IREG, FREG, FREG)
   518| MINI_OP(OP_FCLT,   "float_clt", IREG, FREG, FREG)
   519| MINI_OP(OP_FCLT_UN,"float_clt_un", IREG, FREG, FREG)
   520| MINI_OP(OP_FCNEQ,  "float_cneq", IREG, FREG, FREG)
   521| MINI_OP(OP_FCGE,   "float_cge", IREG, FREG, FREG)
   522| MINI_OP(OP_FCLE,   "float_cle", IREG, FREG, FREG)
   523| MINI_OP(OP_FCEQ_MEMBASE,   "float_ceq_membase", IREG, FREG, IREG)
   524| MINI_OP(OP_FCGT_MEMBASE,   "float_cgt_membase", IREG, FREG, IREG)
   525| MINI_OP(OP_FCGT_UN_MEMBASE,"float_cgt_un_membase", IREG, FREG, IREG)
   526| MINI_OP(OP_FCLT_MEMBASE,   "float_clt_membase", IREG, FREG, IREG)
   527| MINI_OP(OP_FCLT_UN_MEMBASE,"float_clt_un_membase", IREG, FREG, IREG)
   528| MINI_OP(OP_FCONV_TO_U,	"float_conv_to_u", IREG, FREG, NONE)
   529| MINI_OP(OP_CKFINITE, "ckfinite", FREG, FREG, NONE)
   530| /* r4 opcodes: must be in the same order as the matching CEE_ opcodes: ovfops_op_map */
   531| MINI_OP(OP_RCONV_TO_U2,   "r4_conv_to_u2", IREG, FREG, NONE)
   532| MINI_OP(OP_RCONV_TO_U1,   "r4_conv_to_u1", IREG, FREG, NONE)
   533| MINI_OP(OP_RCONV_TO_I,    "r4_conv_to_i", IREG, FREG, NONE)
   534| MINI_OP(OP_RCONV_TO_OVF_I,"r4_conv_to_ovf_i", IREG, FREG, NONE)
   535| MINI_OP(OP_RCONV_TO_OVF_U,"r4_conv_to_ovd_u", IREG, FREG, NONE)
   536| /* r4 opcodes: must be in the same order as the matching CEE_ opcodes: ovfops_op_map */
   537| MINI_OP(OP_RADD_OVF,      "r4_add_ovf", FREG, FREG, FREG)
   538| MINI_OP(OP_RADD_OVF_UN,   "r4_add_ovf_un", FREG, FREG, FREG)
   539| MINI_OP(OP_RMUL_OVF,      "r4_mul_ovf", FREG, FREG, FREG)
   540| MINI_OP(OP_RMUL_OVF_UN,   "r4_mul_ovf_un", FREG, FREG, FREG)
   541| MINI_OP(OP_RSUB_OVF,      "r4_sub_ovf", FREG, FREG, FREG)
   542| MINI_OP(OP_RSUB_OVF_UN,   "r4_sub_ovf_un", FREG, FREG, FREG)
   543| MINI_OP(OP_RCONV_TO_OVF_I1_UN,"r4_conv_to_ovf_i1_un", IREG, FREG, NONE)
   544| MINI_OP(OP_RCONV_TO_OVF_I2_UN,"r4_conv_to_ovf_i2_un", IREG, FREG, NONE)
   545| MINI_OP(OP_RCONV_TO_OVF_I4_UN,"r4_conv_to_ovf_i4_un", IREG, FREG, NONE)
   546| MINI_OP(OP_RCONV_TO_OVF_I8_UN,"r4_conv_to_ovf_i8_un", IREG, FREG, NONE)
   547| MINI_OP(OP_RCONV_TO_OVF_U1_UN,"r4_conv_to_ovf_u1_un", IREG, FREG, NONE)
   548| MINI_OP(OP_RCONV_TO_OVF_U2_UN,"r4_conv_to_ovf_u2_un", IREG, FREG, NONE)


# ====================================================================
# FILE: src/mono/mono/mini/mini-ppc.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 3802-3842 ---
  3802| 		case CEE_CONV_R4: /* FIXME: change precision */
  3803| 		case CEE_CONV_R8:
  3804| 			g_assert_not_reached ();
  3805| 		case OP_FCONV_TO_I1:
  3806| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 1, TRUE);
  3807| 			break;
  3808| 		case OP_FCONV_TO_U1:
  3809| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 1, FALSE);
  3810| 			break;
  3811| 		case OP_FCONV_TO_I2:
  3812| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 2, TRUE);
  3813| 			break;
  3814| 		case OP_FCONV_TO_U2:
  3815| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 2, FALSE);
  3816| 			break;
  3817| 		case OP_FCONV_TO_I4:
  3818| 		case OP_FCONV_TO_I:
  3819| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 4, TRUE);
  3820| 			break;
  3821| 		case OP_FCONV_TO_U4:
  3822| 		case OP_FCONV_TO_U:
  3823| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 4, FALSE);
  3824| 			break;
  3825| 		case OP_LCONV_TO_R_UN:
  3826| 			g_assert_not_reached ();
  3827| 			/* Implemented as helper calls */
  3828| 			break;
  3829| 		case OP_LCONV_TO_OVF_I4_2:
  3830| 		case OP_LCONV_TO_OVF_I: {
  3831| #ifdef __mono_ppc64__
  3832| 			NOT_IMPLEMENTED;
  3833| #else
  3834| 			guint8 *negative_branch, *msword_positive_branch, *msword_negative_branch, *ovf_ex_target;
  3835| 			ppc_cmpi (code, 0, 0, ins->sreg1, 0);
  3836| 			negative_branch = code;
  3837| 			ppc_bc (code, PPC_BR_TRUE, PPC_BR_LT, 0);
  3838| 			ppc_cmpi (code, 0, 0, ins->sreg2, 0);
  3839| 			msword_positive_branch = code;
  3840| 			ppc_bc (code, PPC_BR_TRUE, PPC_BR_EQ, 0);
  3841| 			ovf_ex_target = code;
  3842| 			EMIT_COND_SYSTEM_EXCEPTION_FLAGS (PPC_BR_ALWAYS, 0, "OverflowException");


# ====================================================================
# FILE: src/mono/mono/mini/mini-runtime.c
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 3972-4016 ---
  3972| 	register_opcode_emulation (OP_LSHR, __emul_lshr, mono_icall_sig_long_long_int32, mono_lshr, TRUE);
  3973| 	register_opcode_emulation (OP_LSHR_UN, __emul_lshr_un, mono_icall_sig_long_long_int32, mono_lshr_un, TRUE);
  3974| #endif
  3975| #if defined(MONO_ARCH_EMULATE_MUL_DIV) || defined(MONO_ARCH_EMULATE_DIV)
  3976| 	register_opcode_emulation (OP_IDIV, __emul_op_idiv, mono_icall_sig_int32_int32_int32, mono_idiv, FALSE);
  3977| 	register_opcode_emulation (OP_IDIV_UN, __emul_op_idiv_un, mono_icall_sig_int32_int32_int32, mono_idiv_un, FALSE);
  3978| 	register_opcode_emulation (OP_IREM, __emul_op_irem, mono_icall_sig_int32_int32_int32, mono_irem, FALSE);
  3979| 	register_opcode_emulation (OP_IREM_UN, __emul_op_irem_un, mono_icall_sig_int32_int32_int32, mono_irem_un, FALSE);
  3980| #endif
  3981| #ifdef MONO_ARCH_EMULATE_MUL_DIV
  3982| 	register_opcode_emulation (OP_IMUL, __emul_op_imul, mono_icall_sig_int32_int32_int32, mono_imul, TRUE);
  3983| #endif
  3984| #if defined(MONO_ARCH_EMULATE_MUL_DIV) || defined(MONO_ARCH_EMULATE_MUL_OVF)
  3985| 	register_opcode_emulation (OP_IMUL_OVF, __emul_op_imul_ovf, mono_icall_sig_int32_int32_int32, mono_imul_ovf, FALSE);
  3986| 	register_opcode_emulation (OP_IMUL_OVF_UN, __emul_op_imul_ovf_un, mono_icall_sig_int32_int32_int32, mono_imul_ovf_un, FALSE);
  3987| #endif
  3988| #if defined(MONO_ARCH_EMULATE_MUL_DIV) || defined(MONO_ARCH_SOFT_FLOAT_FALLBACK)
  3989| 	register_opcode_emulation (OP_FDIV, __emul_fdiv, mono_icall_sig_double_double_double, mono_fdiv, FALSE);
  3990| #endif
  3991| #ifdef MONO_ARCH_EMULATE_FCONV_TO_U8
  3992| 	register_opcode_emulation (OP_FCONV_TO_U8, __emul_fconv_to_u8, mono_icall_sig_ulong_double, mono_fconv_u8_2, FALSE);
  3993| 	register_opcode_emulation (OP_RCONV_TO_U8, __emul_rconv_to_u8, mono_icall_sig_ulong_float, mono_rconv_u8, FALSE);
  3994| #endif
  3995| #ifdef MONO_ARCH_EMULATE_FCONV_TO_U4
  3996| 	register_opcode_emulation (OP_FCONV_TO_U4, __emul_fconv_to_u4, mono_icall_sig_uint32_double, mono_fconv_u4_2, FALSE);
  3997| 	register_opcode_emulation (OP_RCONV_TO_U4, __emul_rconv_to_u4, mono_icall_sig_uint32_float, mono_rconv_u4, FALSE);
  3998| #endif
  3999| 	register_opcode_emulation (OP_FCONV_TO_OVF_I8, __emul_fconv_to_ovf_i8, mono_icall_sig_long_double, mono_fconv_ovf_i8, FALSE);
  4000| 	register_opcode_emulation (OP_FCONV_TO_OVF_U8, __emul_fconv_to_ovf_u8, mono_icall_sig_ulong_double, mono_fconv_ovf_u8, FALSE);
  4001| 	register_opcode_emulation (OP_RCONV_TO_OVF_I8, __emul_rconv_to_ovf_i8, mono_icall_sig_long_float, mono_rconv_ovf_i8, FALSE);
  4002| 	register_opcode_emulation (OP_RCONV_TO_OVF_U8, __emul_rconv_to_ovf_u8, mono_icall_sig_ulong_float, mono_rconv_ovf_u8, FALSE);
  4003| #ifdef MONO_ARCH_EMULATE_FCONV_TO_I8
  4004| 	register_opcode_emulation (OP_FCONV_TO_I8, __emul_fconv_to_i8, mono_icall_sig_long_double, mono_fconv_i8, FALSE);
  4005| 	register_opcode_emulation (OP_RCONV_TO_I8, __emul_rconv_to_i8, mono_icall_sig_long_float, mono_rconv_i8, FALSE);
  4006| #endif
  4007| #ifdef MONO_ARCH_EMULATE_CONV_R8_UN
  4008| 	register_opcode_emulation (OP_ICONV_TO_R_UN, __emul_iconv_to_r_un, mono_icall_sig_double_int32, mono_conv_to_r8_un, FALSE);
  4009| #endif
  4010| #ifdef MONO_ARCH_EMULATE_LCONV_TO_R8
  4011| 	register_opcode_emulation (OP_LCONV_TO_R8, __emul_lconv_to_r8, mono_icall_sig_double_long, mono_lconv_to_r8, FALSE);
  4012| #endif
  4013| #ifdef MONO_ARCH_EMULATE_LCONV_TO_R4
  4014| 	register_opcode_emulation (OP_LCONV_TO_R4, __emul_lconv_to_r4, mono_icall_sig_float_long, mono_lconv_to_r4, FALSE);
  4015| #endif
  4016| #ifdef MONO_ARCH_EMULATE_LCONV_TO_R8_UN

# --- HUNK 2: Lines 4044-4088 ---
  4044| 		register_opcode_emulation (OP_FBGE, __emul_fcmp_ge, mono_icall_sig_uint32_double_double, mono_fcmp_ge, FALSE);
  4045| 		register_opcode_emulation (OP_FBNE_UN, __emul_fcmp_ne_un, mono_icall_sig_uint32_double_double, mono_fcmp_ne_un, FALSE);
  4046| 		register_opcode_emulation (OP_FBLT_UN, __emul_fcmp_lt_un, mono_icall_sig_uint32_double_double, mono_fcmp_lt_un, FALSE);
  4047| 		register_opcode_emulation (OP_FBGT_UN, __emul_fcmp_gt_un, mono_icall_sig_uint32_double_double, mono_fcmp_gt_un, FALSE);
  4048| 		register_opcode_emulation (OP_FBLE_UN, __emul_fcmp_le_un, mono_icall_sig_uint32_double_double, mono_fcmp_le_un, FALSE);
  4049| 		register_opcode_emulation (OP_FBGE_UN, __emul_fcmp_ge_un, mono_icall_sig_uint32_double_double, mono_fcmp_ge_un, FALSE);
  4050| 		register_opcode_emulation (OP_FCEQ, __emul_fcmp_ceq, mono_icall_sig_uint32_double_double, mono_fceq, FALSE);
  4051| 		register_opcode_emulation (OP_FCGT, __emul_fcmp_cgt, mono_icall_sig_uint32_double_double, mono_fcgt, FALSE);
  4052| 		register_opcode_emulation (OP_FCGT_UN, __emul_fcmp_cgt_un, mono_icall_sig_uint32_double_double, mono_fcgt_un, FALSE);
  4053| 		register_opcode_emulation (OP_FCLT, __emul_fcmp_clt, mono_icall_sig_uint32_double_double, mono_fclt, FALSE);
  4054| 		register_opcode_emulation (OP_FCLT_UN, __emul_fcmp_clt_un, mono_icall_sig_uint32_double_double, mono_fclt_un, FALSE);
  4055| 		register_icall (mono_fload_r4, mono_icall_sig_double_ptr, FALSE);
  4056| 		register_icall (mono_fstore_r4, mono_icall_sig_void_double_ptr, FALSE);
  4057| 		register_icall (mono_fload_r4_arg, mono_icall_sig_uint32_double, FALSE);
  4058| 		register_icall (mono_isfinite_double, mono_icall_sig_int32_double, FALSE);
  4059| 	}
  4060| #endif
  4061| 	register_icall (mono_ckfinite, mono_icall_sig_double_double, FALSE);
  4062| #ifdef COMPRESSED_INTERFACE_BITMAP
  4063| 	register_icall (mono_class_interface_match, mono_icall_sig_uint32_ptr_int32, TRUE);
  4064| #endif
  4065| #if SIZEOF_REGISTER == 4
  4066| 	register_opcode_emulation (OP_FCONV_TO_U, __emul_fconv_to_u, mono_icall_sig_uint32_double, mono_fconv_u4, TRUE);
  4067| #else
  4068| 	register_opcode_emulation (OP_FCONV_TO_U, __emul_fconv_to_u, mono_icall_sig_ulong_double, mono_fconv_u8, TRUE);
  4069| #endif
  4070| 	/* other jit icalls */
  4071| 	register_icall (ves_icall_mono_delegate_ctor, mono_icall_sig_void_object_object_ptr, FALSE);
  4072| 	register_icall (ves_icall_mono_delegate_ctor_interp, mono_icall_sig_void_object_object_ptr, FALSE);
  4073| 	register_icall (mono_class_static_field_address,
  4074| 				 mono_icall_sig_ptr_ptr, FALSE);
  4075| 	register_icall (mono_ldtoken_wrapper, mono_icall_sig_ptr_ptr_ptr_ptr, FALSE);
  4076| 	register_icall (mono_ldtoken_wrapper_generic_shared,
  4077| 		mono_icall_sig_ptr_ptr_ptr_ptr, FALSE);
  4078| 	register_icall (mono_get_special_static_data, mono_icall_sig_ptr_int, FALSE);
  4079| 	register_icall (mono_helper_stelem_ref_check, mono_icall_sig_void_object_object, FALSE);
  4080| 	register_icall (ves_icall_object_new, mono_icall_sig_object_ptr, FALSE);
  4081| 	register_icall (ves_icall_object_new_specific, mono_icall_sig_object_ptr, FALSE);
  4082| 	register_icall (ves_icall_array_new_specific, mono_icall_sig_object_ptr_int32, FALSE);
  4083| 	register_icall (ves_icall_runtime_class_init, mono_icall_sig_void_ptr, FALSE);
  4084| 	register_icall (mono_ldftn, mono_icall_sig_ptr_ptr, FALSE);
  4085| 	register_icall (mono_ldvirtfn, mono_icall_sig_ptr_object_ptr, FALSE);
  4086| 	register_icall (mono_ldvirtfn_gshared, mono_icall_sig_ptr_object_ptr, FALSE);
  4087| 	register_icall (mono_helper_compile_generic_method, mono_icall_sig_ptr_object_ptr_ptr, FALSE);
  4088| 	register_icall (mono_helper_ldstr, mono_icall_sig_object_ptr_int, FALSE);


# ====================================================================
# FILE: src/mono/mono/mini/mini-s390x.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 3928-3968 ---
  3928| 			s390_ltgr  (code, ins->dreg, ins->dreg);
  3929| 			s390_jnl   (code, 4);
  3930| 			s390_oill  (code, ins->dreg, 0x8000);
  3931| 			s390_llill (code, s390_r0, 0xffff);
  3932| 			s390_ngr   (code, ins->dreg, s390_r0);
  3933| 			break;
  3934| 		case OP_FCONV_TO_U2:
  3935| 			if (mono_hwcap_s390x_has_fpe) {
  3936| 				s390_clgdbr (code, ins->dreg, 5, ins->sreg1, 0);
  3937| 				s390_llill  (code, s390_r0, 0xffff);
  3938| 				s390_ngr    (code, ins->dreg, s390_r0);
  3939| 			} else {
  3940| 				code = emit_double_to_int (cfg, code, ins->dreg, ins->sreg1, 2, FALSE);
  3941| 			}
  3942| 			break;
  3943| 		case OP_FCONV_TO_I4:
  3944| 		case OP_FCONV_TO_I:
  3945| 			s390_cfdbr (code, ins->dreg, 5, ins->sreg1);
  3946| 			break;
  3947| 		case OP_FCONV_TO_U4:
  3948| 		case OP_FCONV_TO_U:
  3949| 			if (mono_hwcap_s390x_has_fpe) {
  3950| 				s390_clgdbr (code, ins->dreg, 5, ins->sreg1, 0);
  3951| 			} else {
  3952| 				code = emit_double_to_int (cfg, code, ins->dreg, ins->sreg1, 4, FALSE);
  3953| 			}
  3954| 			break;
  3955| 		case OP_FCONV_TO_I8:
  3956| 			s390_cgdbr (code, ins->dreg, 5, ins->sreg1);
  3957| 			break;
  3958| 		case OP_FCONV_TO_U8:
  3959| 			if (mono_hwcap_s390x_has_fpe) {
  3960| 				s390_clgdbr (code, ins->dreg, 5, ins->sreg1, 0);
  3961| 			} else {
  3962| 				code = emit_double_to_int (cfg, code, ins->dreg, ins->sreg1, 8, FALSE);
  3963| 			}
  3964| 			break;
  3965| 		case OP_RCONV_TO_I1:
  3966| 			s390_cgebr (code, ins->dreg, 5, ins->sreg1);
  3967| 			s390_ltgr  (code, ins->dreg, ins->dreg);
  3968| 			s390_jnl   (code, 4);


# ====================================================================
# FILE: src/mono/mono/mini/mini-sparc.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 3060-3100 ---
  3060| 			sparc_fxtod (code, FP_SCRATCH_REG, ins->dreg);
  3061| #else
  3062| 			if (!sparc_is_imm13 (offset)) {
  3063| 				sparc_set (code, offset, sparc_o7);
  3064| 				sparc_st (code, ins->sreg1, reg, sparc_o7);
  3065| 				sparc_ldf (code, reg, sparc_o7, FP_SCRATCH_REG);
  3066| 			} else {
  3067| 				sparc_st_imm (code, ins->sreg1, reg, offset);
  3068| 				sparc_ldf_imm (code, reg, offset, FP_SCRATCH_REG);
  3069| 			}
  3070| 			sparc_fitod (code, FP_SCRATCH_REG, ins->dreg);
  3071| #endif
  3072| 			break;
  3073| 		}
  3074| 		case OP_FCONV_TO_I1:
  3075| 		case OP_FCONV_TO_U1:
  3076| 		case OP_FCONV_TO_I2:
  3077| 		case OP_FCONV_TO_U2:
  3078| #ifndef SPARCV9
  3079| 		case OP_FCONV_TO_I:
  3080| 		case OP_FCONV_TO_U:
  3081| #endif
  3082| 		case OP_FCONV_TO_I4:
  3083| 		case OP_FCONV_TO_U4: {
  3084| 			MonoInst *spill = cfg->arch.float_spill_slot;
  3085| 			gint32 reg = spill->inst_basereg;
  3086| 			gint32 offset = spill->inst_offset;
  3087| 			g_assert (spill->opcode == OP_REGOFFSET);
  3088| 			sparc_fdtoi (code, ins->sreg1, FP_SCRATCH_REG);
  3089| 			if (!sparc_is_imm13 (offset)) {
  3090| 				sparc_set (code, offset, sparc_o7);
  3091| 				sparc_stdf (code, FP_SCRATCH_REG, reg, sparc_o7);
  3092| 				sparc_ld (code, reg, sparc_o7, ins->dreg);
  3093| 			} else {
  3094| 				sparc_stdf_imm (code, FP_SCRATCH_REG, reg, offset);
  3095| 				sparc_ld_imm (code, reg, offset, ins->dreg);
  3096| 			}
  3097| 			switch (ins->opcode) {
  3098| 			case OP_FCONV_TO_I1:
  3099| 			case OP_FCONV_TO_U1:
  3100| 				sparc_and_imm (code, 0, ins->dreg, 0xff, ins->dreg);


# ====================================================================
# FILE: src/mono/mono/sgen/sgen-cardtable.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 481-523 ---
   481| 			return (guint8*)cards + find_card_offset (card);
   482| 		++cards;
   483| 	}
   484| 	card_data = (guint8*)cards_end;
   485| 	while (card_data < end) {
   486| 		if (*card_data)
   487| 			return card_data;
   488| 		++card_data;
   489| 	}
   490| 	return end;
   491| }
   492| void
   493| sgen_cardtable_scan_object (GCObject *obj, mword block_obj_size, guint8 *cards, ScanCopyContext ctx)
   494| {
   495| 	HEAVY_STAT (++large_objects);
   496| 	if (sgen_client_cardtable_scan_object (obj, cards, ctx))
   497| 		return;
   498| 	HEAVY_STAT (++bloby_objects);
   499| 	if (cards) {
   500| 		if (sgen_card_table_is_range_marked (cards, (mword)obj, block_obj_size))
   501| 			ctx.ops->scan_object (obj, sgen_obj_get_descriptor (obj), ctx.queue);
   502| 	} else if (sgen_card_table_region_begin_scanning ((mword)obj, block_obj_size)) {
   503| 		ctx.ops->scan_object (obj, sgen_obj_get_descriptor (obj), ctx.queue);
   504| 	}
   505| 	sgen_binary_protocol_card_scan (obj, sgen_safe_object_get_size (obj));
   506| }
   507| void
   508| sgen_card_table_init (SgenRememberedSet *remset)
   509| {
   510| 	sgen_cardtable = (guint8 *)sgen_alloc_os_memory (CARD_COUNT_IN_BYTES, (SgenAllocFlags)(SGEN_ALLOC_INTERNAL | SGEN_ALLOC_ACTIVATE), "card table", MONO_MEM_ACCOUNT_SGEN_CARD_TABLE);
   511| #ifdef SGEN_HAVE_OVERLAPPING_CARDS
   512| 	sgen_shadow_cardtable = (guint8 *)sgen_alloc_os_memory (CARD_COUNT_IN_BYTES, (SgenAllocFlags)(SGEN_ALLOC_INTERNAL | SGEN_ALLOC_ACTIVATE), "shadow card table", MONO_MEM_ACCOUNT_SGEN_SHADOW_CARD_TABLE);
   513| #endif
   514| #ifdef HEAVY_STATISTICS
   515| 	mono_counters_register ("marked cards", MONO_COUNTER_GC | MONO_COUNTER_ULONG, &marked_cards);
   516| 	mono_counters_register ("scanned cards", MONO_COUNTER_GC | MONO_COUNTER_ULONG, &scanned_cards);
   517| 	mono_counters_register ("remarked cards", MONO_COUNTER_GC | MONO_COUNTER_ULONG, &remarked_cards);
   518| 	mono_counters_register ("cardtable scanned objects", MONO_COUNTER_GC | MONO_COUNTER_ULONG, &scanned_objects);
   519| 	mono_counters_register ("cardtable large objects", MONO_COUNTER_GC | MONO_COUNTER_ULONG, &large_objects);
   520| 	mono_counters_register ("cardtable bloby objects", MONO_COUNTER_GC | MONO_COUNTER_ULONG, &bloby_objects);
   521| #endif
   522| 	remset->wbarrier_set_field = sgen_card_table_wbarrier_set_field;
   523| 	remset->wbarrier_arrayref_copy = sgen_card_table_wbarrier_arrayref_copy;


# ====================================================================
# FILE: src/mono/mono/sgen/sgen-marksweep.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 2215-2255 ---
  2215| 		if (card_index <= (MS_BLOCK_SKIP >> CARD_BITS))
  2216| 			first_object_index = 0;
  2217| 		else
  2218| 			first_object_index = MS_BLOCK_OBJ_INDEX_FAST (start, block_start, block_obj_size);
  2219| 		obj = first_obj = (char*)MS_BLOCK_OBJ_FAST (block_start, block_obj_size, first_object_index);
  2220| 		sgen_binary_protocol_card_scan (first_obj, end - first_obj);
  2221| 		while (obj < end) {
  2222| 			if (obj < scan_front || !MS_OBJ_ALLOCED_FAST (obj, block_start))
  2223| 				goto next_object;
  2224| 			if (scan_type & CARDTABLE_SCAN_MOD_UNION) {
  2225| 				/* FIXME: do this more efficiently */
  2226| 				int w, b;
  2227| 				MS_CALC_MARK_BIT (w, b, obj);
  2228| 				if (!MS_MARK_BIT (block, w, b))
  2229| 					goto next_object;
  2230| 			}
  2231| 			GCObject *object;
  2232| 			object = (GCObject*)obj;
  2233| 			if (small_objects) {
  2234| 				HEAVY_STAT (++scanned_objects);
  2235| 				scan_func (object, sgen_obj_get_descriptor (object), queue);
  2236| 			} else {
  2237| 				size_t offset = sgen_card_table_get_card_offset (obj, block_start);
  2238| 				sgen_cardtable_scan_object (object, block_obj_size, card_base + offset, ctx);
  2239| 			}
  2240| 		next_object:
  2241| 			obj += block_obj_size;
  2242| 			g_assert (scan_front <= obj);
  2243| 			scan_front = obj;
  2244| 		}
  2245| 		HEAVY_STAT (if (*card_data) ++remarked_cards);
  2246| 		if (small_objects)
  2247| 			++card_data;
  2248| 		else
  2249| 			card_data = card_base + sgen_card_table_get_card_offset (obj, block_start);
  2250| 	}
  2251| }
  2252| static void
  2253| major_scan_card_table (CardTableScanType scan_type, ScanCopyContext ctx, int job_index, int job_split_count, int block_count)
  2254| {
  2255| 	MSBlockInfo *block;


# ====================================================================
# FILE: src/mono/wasm/debugger/BrowserDebugProxy/DebugStore.cs
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 399-470 ---
   399|         public string FullName { get; }
   400|         public List<MethodInfo> Methods => methods;
   401|         public override string ToString() => "TypeInfo('" + FullName + "')";
   402|     }
   403|     internal class AssemblyInfo
   404|     {
   405|         private static int next_id;
   406|         private readonly int id;
   407|         private readonly ILogger logger;
   408|         private Dictionary<int, MethodInfo> methods = new Dictionary<int, MethodInfo>();
   409|         private Dictionary<string, string> sourceLinkMappings = new Dictionary<string, string>();
   410|         private readonly List<SourceFile> sources = new List<SourceFile>();
   411|         internal string Url { get; }
   412|         internal MetadataReader asmMetadataReader { get; }
   413|         internal MetadataReader pdbMetadataReader { get; set; }
   414|         internal List<MemoryStream> enCMemoryStream  = new List<MemoryStream>();
   415|         internal List<MetadataReader> enCMetadataReader  = new List<MetadataReader>();
   416|         internal PEReader peReader;
   417|         internal MemoryStream asmStream;
   418|         internal MemoryStream pdbStream;
   419|         public int DebugId { get; set; }
   420|         public bool TriedToLoadSymbolsOnDemand { get; set; }
   421|         public unsafe AssemblyInfo(string url, byte[] assembly, byte[] pdb)
   422|         {
   423|             this.id = Interlocked.Increment(ref next_id);
   424|             asmStream = new MemoryStream(assembly);
   425|             peReader = new PEReader(asmStream);
   426|             asmMetadataReader = PEReaderExtensions.GetMetadataReader(peReader);
   427|             Name = asmMetadataReader.GetAssemblyDefinition().GetAssemblyName().Name + ".dll";
   428|             AssemblyNameUnqualified = Name;
   429|             if (pdb != null)
   430|             {
   431|                 pdbStream = new MemoryStream(pdb);
   432|                 try
   433|                 {
   434|                     pdbMetadataReader = MetadataReaderProvider.FromPortablePdbStream(pdbStream).GetMetadataReader();
   435|                 }
   436|                 catch (BadImageFormatException)
   437|                 {
   438|                     Console.WriteLine($"Warning: Unable to read debug information of: {Name} (use DebugType=Portable/Embedded)");
   439|                 }
   440|             }
   441|             else
   442|             {
   443|                 var entries = peReader.ReadDebugDirectory();
   444|                 var embeddedPdbEntry = entries.FirstOrDefault(e => e.Type == DebugDirectoryEntryType.EmbeddedPortablePdb);
   445|                 if (embeddedPdbEntry.DataSize != 0)
   446|                 {
   447|                     pdbMetadataReader = peReader.ReadEmbeddedPortablePdbDebugDirectoryData(embeddedPdbEntry).GetMetadataReader();
   448|                 }
   449|             }
   450|             Populate();
   451|         }
   452|         public bool EnC(byte[] meta, byte[] pdb)
   453|         {
   454|             var asmStream = new MemoryStream(meta);
   455|             MetadataReader asmMetadataReader = MetadataReaderProvider.FromMetadataStream(asmStream).GetMetadataReader();
   456|             var pdbStream = new MemoryStream(pdb);
   457|             MetadataReader pdbMetadataReader = MetadataReaderProvider.FromPortablePdbStream(pdbStream).GetMetadataReader();
   458|             enCMemoryStream.Add(asmStream);
   459|             enCMemoryStream.Add(pdbStream);
   460|             enCMetadataReader.Add(asmMetadataReader);
   461|             enCMetadataReader.Add(pdbMetadataReader);
   462|             PopulateEnC(asmMetadataReader, pdbMetadataReader);
   463|             return true;
   464|         }
   465|         public AssemblyInfo(ILogger logger)
   466|         {
   467|             this.logger = logger;
   468|         }
   469|         private void PopulateEnC(MetadataReader asmMetadataReaderParm, MetadataReader pdbMetadataReaderParm)
   470|         {


# ====================================================================
# FILE: src/mono/wasm/debugger/BrowserDebugProxy/MemberReferenceResolver.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 97-137 ---
    97|                             var valueRet = await sdbHelper.GetFieldValue(sessionId, typeId, field.Id, token);
    98|                             return await GetValueFromObject(valueRet, token);
    99|                         }
   100|                     }
   101|                     var methodId = await sdbHelper.GetPropertyMethodIdByName(sessionId, typeId, part.Trim(), token);
   102|                     if (methodId != -1)
   103|                     {
   104|                         var commandParamsObj = new MemoryStream();
   105|                         var commandParamsObjWriter = new MonoBinaryWriter(commandParamsObj);
   106|                         commandParamsObjWriter.Write(0); //param count
   107|                         var retMethod = await sdbHelper.InvokeMethod(sessionId, commandParamsObj.ToArray(), methodId, "methodRet", token);
   108|                         return await GetValueFromObject(retMethod, token);
   109|                     }
   110|                 }
   111|                 var store = await proxy.LoadStore(sessionId, token);
   112|                 foreach (var asm in store.assemblies)
   113|                 {
   114|                     var type = asm.GetTypeByName(classNameToFind);
   115|                     if (type != null)
   116|                     {
   117|                         typeId = await sdbHelper.GetTypeIdFromToken(sessionId, asm.DebugId, type.Token, token);
   118|                     }
   119|                 }
   120|             }
   121|             return null;
   122|         }
   123|         public async Task<JObject> Resolve(string varName, CancellationToken token)
   124|         {
   125|             if (varName.Contains('('))
   126|                 return null;
   127|             string[] parts = varName.Split(".");
   128|             JObject rootObject = null;
   129|             if (scopeCache.MemberReferences.TryGetValue(varName, out JObject ret)) {
   130|                 return ret;
   131|             }
   132|             if (scopeCache.ObjectFields.TryGetValue(varName, out JObject valueRet)) {
   133|                 return await GetValueFromObject(valueRet, token);
   134|             }
   135|             foreach (string part in parts)
   136|             {
   137|                 string partTrimmed = part.Trim();


# ====================================================================
# FILE: src/mono/wasm/debugger/BrowserDebugProxy/MonoProxy.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1007-1065 ---
  1007|         private async Task OnSourceFileAdded(SessionId sessionId, SourceFile source, ExecutionContext context, CancellationToken token)
  1008|         {
  1009|             JObject scriptSource = JObject.FromObject(source.ToScriptSource(context.Id, context.AuxData));
  1010|             Log("debug", $"sending {source.Url} {context.Id} {sessionId.sessionId}");
  1011|             SendEvent(sessionId, "Debugger.scriptParsed", scriptSource, token);
  1012|             foreach (var req in context.BreakpointRequests.Values)
  1013|             {
  1014|                 if (req.TryResolve(source))
  1015|                 {
  1016|                     await SetBreakpoint(sessionId, context.store, req, true, token);
  1017|                 }
  1018|             }
  1019|         }
  1020|         internal async Task<DebugStore> LoadStore(SessionId sessionId, CancellationToken token)
  1021|         {
  1022|             ExecutionContext context = GetContext(sessionId);
  1023|             if (Interlocked.CompareExchange(ref context.store, new DebugStore(logger), null) != null)
  1024|                 return await context.Source.Task;
  1025|             try
  1026|             {
  1027|                 string[] loaded_files = context.LoadedFiles;
  1028|                 if (loaded_files == null)
  1029|                 {
  1030|                     Result loaded = await SendMonoCommand(sessionId, MonoCommands.GetLoadedFiles(), token);
  1031|                     loaded_files = loaded.Value?["result"]?["value"]?.ToObject<string[]>();
  1032|                 }
  1033|                 await
  1034|                 foreach (SourceFile source in context.store.Load(sessionId, loaded_files, token).WithCancellation(token))
  1035|                 {
  1036|                     await OnSourceFileAdded(sessionId, source, context, token);
  1037|                 }
  1038|             }
  1039|             catch (Exception e)
  1040|             {
  1041|                 context.Source.SetException(e);
  1042|             }
  1043|             if (!context.Source.Task.IsCompleted)
  1044|                 context.Source.SetResult(context.store);
  1045|             return context.store;
  1046|         }
  1047|         private async Task<DebugStore> RuntimeReady(SessionId sessionId, CancellationToken token)
  1048|         {
  1049|             ExecutionContext context = GetContext(sessionId);
  1050|             if (Interlocked.CompareExchange(ref context.ready, new TaskCompletionSource<DebugStore>(), null) != null)
  1051|                 return await context.ready.Task;
  1052|             var commandParams = new MemoryStream();
  1053|             await SdbHelper.SendDebuggerAgentCommand<CmdEventRequest>(sessionId, CmdEventRequest.ClearAllBreakpoints, commandParams, token);
  1054|             if (context.PauseOnExceptions != PauseOnExceptionsKind.None && context.PauseOnExceptions != PauseOnExceptionsKind.Unset)
  1055|                 await SdbHelper.EnableExceptions(sessionId, context.PauseOnExceptions, token);
  1056|             await SdbHelper.SetProtocolVersion(sessionId, token);
  1057|             await SdbHelper.EnableReceiveRequests(sessionId, EventKind.UserBreak, token);
  1058|             await SdbHelper.EnableReceiveRequests(sessionId, EventKind.EnC, token);
  1059|             await SdbHelper.EnableReceiveRequests(sessionId, EventKind.MethodUpdate, token);
  1060|             DebugStore store = await LoadStore(sessionId, token);
  1061|             context.ready.SetResult(store);
  1062|             SendEvent(sessionId, "Mono.runtimeReady", new JObject(), token);
  1063|             SdbHelper.ResetStore(store);
  1064|             return store;
  1065|         }


# ====================================================================
# FILE: src/mono/wasm/debugger/BrowserDebugProxy/MonoSDBHelper.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 675-715 ---
   675|         }
   676|         public async Task<AssemblyInfo> GetAssemblyInfo(SessionId sessionId, int assemblyId, CancellationToken token)
   677|         {
   678|             AssemblyInfo asm = null;
   679|             if (assemblies.TryGetValue(assemblyId, out asm))
   680|             {
   681|                 return asm;
   682|             }
   683|             var assemblyName = await GetAssemblyName(sessionId, assemblyId, token);
   684|             asm = store.GetAssemblyByName(assemblyName);
   685|             if (asm == null)
   686|             {
   687|                 assemblyName = await GetAssemblyFileNameFromId(sessionId, assemblyId, token); //maybe is a lazy loaded assembly
   688|                 asm = store.GetAssemblyByName(assemblyName);
   689|                 if (asm == null)
   690|                 {
   691|                     logger.LogDebug($"Unable to find assembly: {assemblyName}");
   692|                     return null;
   693|                 }
   694|             }
   695|             asm.DebugId = assemblyId;
   696|             assemblies[assemblyId] = asm;
   697|             return asm;
   698|         }
   699|         public async Task<MethodInfoWithDebugInformation> GetMethodInfo(SessionId sessionId, int methodId, CancellationToken token)
   700|         {
   701|             MethodInfoWithDebugInformation methodDebugInfo = null;
   702|             if (methods.TryGetValue(methodId, out methodDebugInfo))
   703|             {
   704|                 return methodDebugInfo;
   705|             }
   706|             var methodToken = await GetMethodToken(sessionId, methodId, token);
   707|             var assemblyId = await GetAssemblyIdFromMethod(sessionId, methodId, token);
   708|             var asm = await GetAssemblyInfo(sessionId, assemblyId, token);
   709|             if (asm == null)
   710|             {
   711|                 logger.LogDebug($"Unable to find assembly: {assemblyId}");
   712|                 return null;
   713|             }
   714|             var method = asm.GetMethodByToken(methodToken);
   715|             if (method == null && !asm.HasSymbols)


# ====================================================================
# FILE: src/tasks/AotCompilerTask/MonoAOTCompiler.cs
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 31-97 ---
    31|     public bool UseLLVM { get; set; }
    32|     public bool UseAotDataFile { get; set; } = true;
    33|     public bool UseStaticLinking { get; set; }
    34|     public bool UseDirectIcalls { get; set; }
    35|     public bool UseDirectPInvoke { get; set; }
    36|     public bool UseDwarfDebug { get; set; }
    37|     public string[]? AotProfilePath { get; set; }
    38|     public string[]? Profilers { get; set; }
    39|     public string? AotModulesTablePath { get; set; }
    40|     public string? AotModulesTableLanguage { get; set; } = nameof(MonoAotModulesTableLanguage.C);
    41|     public string Mode { get; set; } = nameof(MonoAotMode.Normal);
    42|     public string OutputType { get; set; } = nameof(MonoAotOutputType.ObjectFile);
    43|     public string? LibraryFormat { get; set; }
    44|     public string LibraryFilePrefix { get; set; } = "";
    45|     public string? LLVMPath { get; set; }
    46|     public string? ToolPrefix { get; set; }
    47|     public string? MsymPath { get; set; }
    48|     public string? DedupAssembly { get; set; }
    49|     public string? LLVMDebug { get; set; } = "nodebug";
    50|     public string? CacheFilePath { get; set; }
    51|     [Required]
    52|     public string IntermediateOutputPath { get; set; } = string.Empty;
    53|     [Output]
    54|     public string[]? FileWrites { get; private set; }
    55|     private List<string> _fileWrites = new();
    56|     private IList<ITaskItem>? _assembliesToCompile;
    57|     private ConcurrentDictionary<string, ITaskItem> compiledAssemblies = new();
    58|     private MonoAotMode parsedAotMode;
    59|     private MonoAotOutputType parsedOutputType;
    60|     private MonoAotLibraryFormat parsedLibraryFormat;
    61|     private MonoAotModulesTableLanguage parsedAotModulesTableLanguage;
    62|     private FileCache? _cache;
    63|     private int _numCompiled;
    64|     private int _totalNumAssemblies;
    65|     private bool ProcessAndValidateArguments()
    66|     {
    67|         if (!File.Exists(CompilerBinaryPath))
    68|         {
    69|             Log.LogError($"{nameof(CompilerBinaryPath)}='{CompilerBinaryPath}' doesn't exist.");
    70|             return false;
    71|         }
    72|         if (Assemblies.Length == 0)
    73|         {
    74|             Log.LogError($"'{nameof(Assemblies)}' is required.");
    75|             return false;
    76|         }
    77|         if (!Path.IsPathRooted(OutputDir))
    78|             OutputDir = Path.GetFullPath(OutputDir);
    79|         if (!Directory.Exists(OutputDir))
    80|         {
    81|             Log.LogError($"OutputDir={OutputDir} doesn't exist");
    82|             return false;
    83|         }
    84|         if (!Directory.Exists(IntermediateOutputPath))
    85|             Directory.CreateDirectory(IntermediateOutputPath);
    86|         if (AotProfilePath != null)
    87|         {
    88|             foreach (var path in AotProfilePath)
    89|             {
    90|                 if (!File.Exists(path))
    91|                 {
    92|                     Log.LogError($"AotProfilePath '{path}' doesn't exist.");
    93|                     return false;
    94|                 }
    95|             }
    96|         }
    97|         if (UseLLVM)

# --- HUNK 2: Lines 431-518 ---
   431|             }
   432|         }
   433|         if (MsymPath != null)
   434|         {
   435|             aotArgs.Add($"msym-dir={MsymPath}");
   436|         }
   437|         if (UseAotDataFile)
   438|         {
   439|             string aotDataFile = Path.ChangeExtension(assembly, ".aotdata");
   440|             aotArgs.Add($"data-outfile={aotDataFile}");
   441|             aotAssembly.SetMetadata("AotDataFile", aotDataFile);
   442|         }
   443|         if (AotProfilePath?.Length > 0)
   444|         {
   445|             aotArgs.Add("profile-only");
   446|             foreach (var path in AotProfilePath)
   447|             {
   448|                 aotArgs.Add($"profile={path}");
   449|             }
   450|         }
   451|         processArgs.Add($"\"--aot={string.Join(",", aotArgs)}\"");
   452|         if (isDedup)
   453|         {
   454|             foreach (var aItem in _assembliesToCompile!)
   455|                 processArgs.Add(aItem.ItemSpec);
   456|         }
   457|         else
   458|         {
   459|             processArgs.Add('"' + assemblyFilename + '"');
   460|         }
   461|         monoPaths = $"{assemblyDir}{Path.PathSeparator}{monoPaths}";
   462|         var envVariables = new Dictionary<string, string>
   463|         {
   464|             {"MONO_PATH", monoPaths },
   465|             {"MONO_ENV_OPTIONS", string.Empty} // we do not want options to be provided out of band to the cross compilers
   466|         };
   467|         var responseFileContent = string.Join(" ", processArgs);
   468|         var responseFilePath = Path.GetTempFileName();
   469|         using (var sw = new StreamWriter(responseFilePath, append: false, encoding: new UTF8Encoding(false)))
   470|         {
   471|             sw.WriteLine(responseFileContent);
   472|         }
   473|         return new PrecompileArguments(ResponseFilePath: responseFilePath,
   474|                                         EnvironmentVariables: envVariables,
   475|                                         WorkingDir: assemblyDir,
   476|                                         AOTAssembly: aotAssembly,
   477|                                         ProxyFiles: proxyFiles);
   478|     }
   479|     private bool PrecompileLibrary(PrecompileArguments args)
   480|     {
   481|         string assembly = args.AOTAssembly.GetMetadata("FullPath");
   482|         try
   483|         {
   484|             string msgPrefix = $"[{Path.GetFileName(assembly)}] ";
   485|             (int exitCode, string output) = Utils.TryRunProcess(Log,
   486|                                                                 CompilerBinaryPath,
   487|                                                                 $"--response=\"{args.ResponseFilePath}\"",
   488|                                                                 args.EnvironmentVariables,
   489|                                                                 args.WorkingDir,
   490|                                                                 silent: true,
   491|                                                                 debugMessageImportance: MessageImportance.Low,
   492|                                                                 label: Path.GetFileName(assembly));
   493|             var importance = exitCode == 0 ? MessageImportance.Low : MessageImportance.High;
   494|             {
   495|                 StringBuilder envStr = new StringBuilder(string.Empty);
   496|                 foreach (KeyValuePair<string, string> kvp in args.EnvironmentVariables)
   497|                     envStr.Append($"{kvp.Key}={kvp.Value} ");
   498|                 Log.LogMessage(importance, $"{msgPrefix}Exec (with response file contents expanded) in {args.WorkingDir}: {envStr}{CompilerBinaryPath} {File.ReadAllText(args.ResponseFilePath)}");
   499|             }
   500|             if (exitCode != 0)
   501|             {
   502|                 Log.LogError($"Precompiling failed for {assembly}.{Environment.NewLine}{output}");
   503|                 return false;
   504|             }
   505|             Log.LogMessage(importance, output);
   506|         }
   507|         catch (Exception ex)
   508|         {
   509|             Log.LogMessage(MessageImportance.Low, ex.ToString());
   510|             Log.LogError($"Precompiling failed for {assembly}: {ex.Message}");
   511|             return false;
   512|         }
   513|         finally
   514|         {
   515|             File.Delete(args.ResponseFilePath);
   516|         }
   517|         bool copied = false;
   518|         foreach (var proxyFile in args.ProxyFiles)


# ====================================================================
# FILE: src/tasks/AppleAppBuilder/AppleAppBuilder.cs
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 35-74 ---
    35|     public string Arch { get; set; } = ""!;
    36|     [Output]
    37|     public string AppBundlePath { get; set; } = ""!;
    38|     [Output]
    39|     public string XcodeProjectPath { get; set; } = ""!;
    40|     public string? OutputDirectory { get; set; }
    41|     public bool Optimized { get; set; }
    42|     public string? DevTeamProvisioning { get; set; }
    43|     public bool BuildAppBundle { get; set; }
    44|     public bool GenerateXcodeProject { get; set; }
    45|     public bool GenerateCMakeProject { get; set; }
    46|     public ITaskItem[]? ExcludeFromAppDir { get; set; }
    47|     public string? NativeMainSource { get; set; }
    48|     public bool UseConsoleUITemplate { get; set; }
    49|     public bool ForceAOT { get; set; }
    50|     public string? RuntimeComponents { get; set; } = ""!;
    51|     public string? DiagnosticPorts { get; set; } = ""!;
    52|     public bool InvariantGlobalization { get; set; }
    53|     public bool ForceInterpreter { get; set; }
    54|     public bool EnableRuntimeLogging { get; set; }
    55|     public override bool Execute()
    56|     {
    57|         bool isDevice = (TargetOS == TargetNames.iOS || TargetOS == TargetNames.tvOS);
    58|         if (!string.IsNullOrEmpty(MainLibraryFileName))
    59|         {
    60|             if (!File.Exists(Path.Combine(AppDir, MainLibraryFileName)))
    61|             {
    62|                 throw new ArgumentException($"MainLibraryFileName='{MainLibraryFileName}' was not found in AppDir='{AppDir}'");
    63|             }
    64|         }
    65|         if (ProjectName.Contains(' '))
    66|         {
    67|             throw new ArgumentException($"ProjectName='{ProjectName}' should not contain spaces");
    68|         }
    69|         string[] excludes = Array.Empty<string>();
    70|         if (ExcludeFromAppDir != null)
    71|         {
    72|             excludes = ExcludeFromAppDir
    73|                 .Where(i => !string.IsNullOrEmpty(i.ItemSpec))
    74|                 .Select(i => i.ItemSpec)

# --- HUNK 2: Lines 94-138 ---
    94|             {
    95|                 assemblerFilesToLink.Add(llvmObj);
    96|             }
    97|         }
    98|         if (((!ForceInterpreter && (isDevice || ForceAOT)) && !assemblerFiles.Any()))
    99|         {
   100|             throw new InvalidOperationException("Need list of AOT files for device builds.");
   101|         }
   102|         if (!string.IsNullOrEmpty(DiagnosticPorts))
   103|         {
   104|             bool validDiagnosticsConfig = false;
   105|             if (string.IsNullOrEmpty(RuntimeComponents))
   106|                 validDiagnosticsConfig = false;
   107|             else if (RuntimeComponents.Equals("*", StringComparison.OrdinalIgnoreCase))
   108|                 validDiagnosticsConfig = true;
   109|             else if (RuntimeComponents.Contains("diagnostics_tracing", StringComparison.OrdinalIgnoreCase))
   110|                 validDiagnosticsConfig = true;
   111|             if (!validDiagnosticsConfig)
   112|                 throw new ArgumentException("Using DiagnosticPorts require diagnostics_tracing runtime component.");
   113|         }
   114|         var generator = new Xcode(Log, TargetOS, Arch);
   115|         if (GenerateXcodeProject)
   116|         {
   117|             XcodeProjectPath = generator.GenerateXCode(ProjectName, MainLibraryFileName, assemblerFiles, assemblerFilesToLink,
   118|                 AppDir, binDir, MonoRuntimeHeaders, !isDevice, UseConsoleUITemplate, ForceAOT, ForceInterpreter, InvariantGlobalization, Optimized, EnableRuntimeLogging, DiagnosticPorts, RuntimeComponents, NativeMainSource);
   119|             if (BuildAppBundle)
   120|             {
   121|                 if (isDevice && string.IsNullOrEmpty(DevTeamProvisioning))
   122|                 {
   123|                     Log.LogMessage(MessageImportance.High, "DevTeamProvisioning is not set, BuildAppBundle step is skipped.");
   124|                 }
   125|                 else
   126|                 {
   127|                     AppBundlePath = generator.BuildAppBundle(XcodeProjectPath, Optimized, DevTeamProvisioning);
   128|                 }
   129|             }
   130|         }
   131|         else if (GenerateCMakeProject)
   132|         {
   133|              generator.GenerateCMake(ProjectName, MainLibraryFileName, assemblerFiles, assemblerFilesToLink,
   134|                 AppDir, binDir, MonoRuntimeHeaders, !isDevice, UseConsoleUITemplate, ForceAOT, ForceInterpreter, InvariantGlobalization, Optimized, EnableRuntimeLogging, DiagnosticPorts, RuntimeComponents, NativeMainSource);
   135|         }
   136|         return true;
   137|     }
   138| }


# ====================================================================
# FILE: src/tasks/AppleAppBuilder/Xcode.cs
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 75-119 ---
    75|             "x64" => "x86_64",
    76|             "arm" => "armv7",
    77|             _ => arch
    78|         };
    79|     }
    80|     public string GenerateXCode(
    81|         string projectName,
    82|         string entryPointLib,
    83|         IEnumerable<string> asmFiles,
    84|         IEnumerable<string> asmLinkFiles,
    85|         string workspace,
    86|         string binDir,
    87|         string monoInclude,
    88|         bool preferDylibs,
    89|         bool useConsoleUiTemplate,
    90|         bool forceAOT,
    91|         bool forceInterpreter,
    92|         bool invariantGlobalization,
    93|         bool optimized,
    94|         bool enableRuntimeLogging,
    95|         string? diagnosticPorts,
    96|         string? runtimeComponents=null,
    97|         string? nativeMainSource = null)
    98|     {
    99|         var cmakeDirectoryPath = GenerateCMake(projectName, entryPointLib, asmFiles, asmLinkFiles, workspace, binDir, monoInclude, preferDylibs, useConsoleUiTemplate, forceAOT, forceInterpreter, invariantGlobalization, optimized, enableRuntimeLogging, diagnosticPorts, runtimeComponents, nativeMainSource);
   100|         CreateXcodeProject(projectName, cmakeDirectoryPath);
   101|         return Path.Combine(binDir, projectName, projectName + ".xcodeproj");
   102|     }
   103|     public void CreateXcodeProject(string projectName, string cmakeDirectoryPath)
   104|     {
   105|         string targetName;
   106|         switch (Target)
   107|         {
   108|             case TargetNames.MacCatalyst:
   109|                 targetName = "Darwin";
   110|                 break;
   111|             case TargetNames.iOS:
   112|             case TargetNames.iOSsim:
   113|                 targetName = "iOS";
   114|                 break;
   115|             case TargetNames.tvOS:
   116|             case TargetNames.tvOSsim:
   117|                 targetName = "tvOS";
   118|                 break;
   119|             default:

# --- HUNK 2: Lines 128-202 ---
   128|             .Append(" -GXcode")
   129|             .Append(" -DCMAKE_SYSTEM_NAME=").Append(targetName)
   130|             .Append(deployTarget);
   131|         Utils.RunProcess(Logger, "cmake", cmakeArgs.ToString(), workingDir: cmakeDirectoryPath);
   132|     }
   133|     public string GenerateCMake(
   134|         string projectName,
   135|         string entryPointLib,
   136|         IEnumerable<string> asmFiles,
   137|         IEnumerable<string> asmLinkFiles,
   138|         string workspace,
   139|         string binDir,
   140|         string monoInclude,
   141|         bool preferDylibs,
   142|         bool useConsoleUiTemplate,
   143|         bool forceAOT,
   144|         bool forceInterpreter,
   145|         bool invariantGlobalization,
   146|         bool optimized,
   147|         bool enableRuntimeLogging,
   148|         string? diagnosticPorts,
   149|         string? runtimeComponents=null,
   150|         string? nativeMainSource = null)
   151|     {
   152|         var excludes = new List<string> { ".dll.o", ".dll.s", ".dwarf", ".m", ".h", ".a", ".bc", "libmonosgen-2.0.dylib", "libcoreclr.dylib" };
   153|         if (optimized)
   154|         {
   155|             excludes.Add(".pdb");
   156|         }
   157|         string[] resources = Directory.GetFileSystemEntries(workspace, "", SearchOption.TopDirectoryOnly)
   158|             .Where(f => !excludes.Any(e => f.EndsWith(e, StringComparison.InvariantCultureIgnoreCase)))
   159|             .Concat(Directory.GetFiles(binDir, "*.aotdata"))
   160|             .ToArray();
   161|         if (string.IsNullOrEmpty(nativeMainSource))
   162|         {
   163|             nativeMainSource = Path.Combine(binDir, "main.m");
   164|             File.WriteAllText(nativeMainSource, Utils.GetEmbeddedResource(useConsoleUiTemplate ? "main-console.m" : "main-simple.m"));
   165|         }
   166|         else
   167|         {
   168|             string newMainPath = Path.Combine(binDir, "main.m");
   169|             if (nativeMainSource != newMainPath)
   170|             {
   171|                 File.Copy(nativeMainSource, Path.Combine(binDir, "main.m"), true);
   172|                 nativeMainSource = newMainPath;
   173|             }
   174|         }
   175|         var entitlements = new List<KeyValuePair<string, string>>();
   176|         bool hardenedRuntime = false;
   177|         if (Target == TargetNames.MacCatalyst && !forceAOT) {
   178|             hardenedRuntime = true;
   179|             /* for mmmap MAP_JIT */
   180|             entitlements.Add (KeyValuePair.Create ("com.apple.security.cs.allow-jit", "<true/>"));
   181|             /* for loading unsigned dylibs like libicu from outside the bundle or libSystem.Native.dylib from inside */
   182|             entitlements.Add (KeyValuePair.Create ("com.apple.security.cs.disable-library-validation", "<true/>"));
   183|         }
   184|         string cmakeLists = Utils.GetEmbeddedResource("CMakeLists.txt.template")
   185|             .Replace("%ProjectName%", projectName)
   186|             .Replace("%AppResources%", string.Join(Environment.NewLine, resources.Where(r => !r.EndsWith("-llvm.o")).Select(r => "    " + Path.GetRelativePath(binDir, r))))
   187|             .Replace("%MainSource%", nativeMainSource)
   188|             .Replace("%MonoInclude%", monoInclude)
   189|             .Replace("%HardenedRuntime%", hardenedRuntime ? "TRUE" : "FALSE");
   190|         string toLink = "";
   191|         string[] allComponentLibs = Directory.GetFiles(workspace, "libmono-component-*-static.a");
   192|         string[] staticComponentStubLibs = Directory.GetFiles(workspace, "libmono-component-*-stub-static.a");
   193|         bool staticLinkAllComponents = false;
   194|         string[] staticLinkedComponents = Array.Empty<string>();
   195|         if (!string.IsNullOrEmpty(runtimeComponents) && runtimeComponents.Equals("*", StringComparison.OrdinalIgnoreCase))
   196|             staticLinkAllComponents = true;
   197|         else if (!string.IsNullOrEmpty(runtimeComponents))
   198|             staticLinkedComponents = runtimeComponents.Split(";");
   199|         foreach (string staticComponentStubLib in staticComponentStubLibs)
   200|         {
   201|             string componentLibToLink = staticComponentStubLib;
   202|             if (staticLinkAllComponents)


# ====================================================================
# FILE: src/tasks/WorkloadBuildTasks/InstallWorkloadFromArtifacts.cs
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 52-92 ---
    52|                                                     Log,
    53|                                                     Path.Combine(SdkDir, "dotnet"),
    54|                                                     $"workload install --skip-manifest-update --no-cache --configfile \"{nugetConfigPath}\" {WorkloadId.ItemSpec}",
    55|                                                     workingDir: Path.GetTempPath(),
    56|                                                     silent: false,
    57|                                                     debugMessageImportance: MessageImportance.High);
    58|             if (exitCode != 0)
    59|             {
    60|                 Log.LogError($"workload install failed: {output}");
    61|                 foreach (var dir in Directory.EnumerateDirectories(Path.Combine(SdkDir, "sdk-manifests"), "*", SearchOption.AllDirectories))
    62|                     Log.LogMessage(MessageImportance.Low, $"\t{Path.Combine(SdkDir, "sdk-manifests", dir)}");
    63|                 foreach (var dir in Directory.EnumerateDirectories(Path.Combine(SdkDir, "packs"), "*", SearchOption.AllDirectories))
    64|                     Log.LogMessage(MessageImportance.Low, $"\t{Path.Combine(SdkDir, "packs", dir)}");
    65|                 return false;
    66|             }
    67|             return !Log.HasLoggedErrors;
    68|         }
    69|         private string GetNuGetConfig() => File.ReadAllText(NuGetConfigFile);
    70|         private bool InstallWorkloadManifest(string name, string version, string nugetConfigContents, bool stopOnMissing)
    71|         {
    72|             Log.LogMessage(MessageImportance.High, $"Installing workload manifest for {name}/{version}");
    73|             string outputDir = FindSubDirIgnoringCase(Path.Combine(SdkDir, "sdk-manifests", VersionBand), name);
    74|             PackageReference pkgRef = new(Name: $"{name}.Manifest-{VersionBand}",
    75|                                           Version: version,
    76|                                           OutputDir: outputDir,
    77|                                           relativeSourceDir: "data");
    78|             if (!PackageInstaller.Install(new[]{ pkgRef }, nugetConfigContents, Log, stopOnMissing))
    79|                 return false;
    80|             string manifestDir = pkgRef.OutputDir;
    81|             string jsonPath = Path.Combine(manifestDir, "WorkloadManifest.json");
    82|             if (!File.Exists(jsonPath))
    83|             {
    84|                 Log.LogError($"Could not find WorkloadManifest.json at {jsonPath}");
    85|                 return false;
    86|             }
    87|             ManifestInformation? manifest;
    88|             try
    89|             {
    90|                 manifest = JsonSerializer.Deserialize<ManifestInformation>(
    91|                                                     File.ReadAllBytes(jsonPath),
    92|                                                     new JsonSerializerOptions(JsonSerializerDefaults.Web)

# --- HUNK 2: Lines 94-134 ---
    94|                                                         AllowTrailingCommas = true,
    95|                                                         ReadCommentHandling = JsonCommentHandling.Skip
    96|                                                     });
    97|                 if (manifest == null)
    98|                 {
    99|                     Log.LogError($"Could not parse manifest from {jsonPath}.");
   100|                     return false;
   101|                 }
   102|             }
   103|             catch (JsonException je)
   104|             {
   105|                 Log.LogError($"Failed to read from {jsonPath}: {je.Message}");
   106|                 return false;
   107|             }
   108|             if (manifest.DependsOn != null)
   109|             {
   110|                 foreach ((string depName, string depVersion) in manifest.DependsOn)
   111|                 {
   112|                     if (!InstallWorkloadManifest(depName, depVersion, nugetConfigContents, stopOnMissing: false))
   113|                     {
   114|                         Log.LogWarning($"Could not install manifest {depName}/{depVersion}. This can be ignored if the workload {WorkloadId.ItemSpec} doesn't depend on it.");
   115|                         continue;
   116|                     }
   117|                 }
   118|             }
   119|             return true;
   120|         }
   121|         private bool HasMetadata(ITaskItem item, string itemName, string metadataName)
   122|         {
   123|             if (!string.IsNullOrEmpty(item.GetMetadata(metadataName)))
   124|                 return true;
   125|             Log.LogError($"{itemName} item ({item.ItemSpec}) is missing Name metadata");
   126|             return false;
   127|         }
   128|         private string FindSubDirIgnoringCase(string parentDir, string dirName)
   129|         {
   130|             IEnumerable<string> matchingDirs = Directory.EnumerateDirectories(parentDir,
   131|                                                             dirName,
   132|                                                             new EnumerationOptions { MatchCasing = MatchCasing.CaseInsensitive });
   133|             string? first = matchingDirs.FirstOrDefault();
   134|             if (matchingDirs.Count() > 1)


# ====================================================================
# FILE: src/tasks/WorkloadBuildTasks/PackageInstaller.cs
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 30-93 ---
    30|         }
    31|         private bool InstallActual(PackageReference[] references, bool stopOnMissing)
    32|         {
    33|             if (Directory.Exists(_packagesDir))
    34|             {
    35|                 _logger.LogMessage(MessageImportance.Low, $"Deleting {_packagesDir}");
    36|                 Directory.Delete(_packagesDir, recursive: true);
    37|             }
    38|             var projecDir = Path.Combine(_tempDir, "restore");
    39|             var projectPath = Path.Combine(projecDir, "Restore.csproj");
    40|             Directory.CreateDirectory(projecDir);
    41|             File.WriteAllText(Path.Combine(projecDir, "Directory.Build.props"), "<Project />");
    42|             File.WriteAllText(Path.Combine(projecDir, "Directory.Build.targets"), "<Project />");
    43|             File.WriteAllText(projectPath, GenerateProject(references));
    44|             File.WriteAllText(Path.Combine(projecDir, "nuget.config"), _nugetConfigContents);
    45|             _logger.LogMessage(MessageImportance.Low, $"Restoring packages: {string.Join(", ", references.Select(r => $"{r.Name}/{r.Version}"))}");
    46|             string args = $"restore \"{projectPath}\" /p:RestorePackagesPath=\"{_packagesDir}\"";
    47|             (int exitCode, string output) = Utils.TryRunProcess(_logger, "dotnet", args, silent: false, debugMessageImportance: MessageImportance.Low);
    48|             if (exitCode != 0)
    49|             {
    50|                 LogErrorOrWarning($"Restoring packages failed with exit code: {exitCode}. Output:{Environment.NewLine}{output}", stopOnMissing);
    51|                 return false;
    52|             }
    53|             IList<(PackageReference, string)> failedToRestore = references
    54|                                                              .Select(r => (r, Path.Combine(_packagesDir, r.Name.ToLower(), r.Version)))
    55|                                                              .Where(tuple => !Directory.Exists(tuple.Item2))
    56|                                                              .ToList();
    57|             if (failedToRestore.Count > 0)
    58|             {
    59|                 _logger.LogMessage(MessageImportance.Normal, output);
    60|                 foreach ((PackageReference pkgRef, string pkgDir) in failedToRestore)
    61|                     LogErrorOrWarning($"Could not restore {pkgRef.Name}/{pkgRef.Version} (can't find {pkgDir})", stopOnMissing);
    62|                 return false;
    63|             }
    64|             return LayoutPackages(references, stopOnMissing);
    65|         }
    66|         private bool LayoutPackages(IEnumerable<PackageReference> references, bool stopOnMissing)
    67|         {
    68|             foreach (var pkgRef in references)
    69|             {
    70|                 var source = Path.Combine(_packagesDir, pkgRef.Name.ToLower(), pkgRef.Version, pkgRef.relativeSourceDir);
    71|                 if (!Directory.Exists(source))
    72|                 {
    73|                     LogErrorOrWarning($"Failed to restore {pkgRef.Name}/{pkgRef.Version} (could not find {source})", stopOnMissing);
    74|                     if (stopOnMissing)
    75|                         return false;
    76|                 }
    77|                 else
    78|                 {
    79|                     if (!CopyDirectoryAfresh(source, pkgRef.OutputDir) && stopOnMissing)
    80|                         return false;
    81|                 }
    82|             }
    83|             return true;
    84|         }
    85|         private static string GenerateProject(IEnumerable<PackageReference> references)
    86|         {
    87|             StringBuilder projectFileBuilder = new();
    88|             projectFileBuilder.Append(@"
    89| <Project Sdk=""Microsoft.NET.Sdk"">
    90|     <PropertyGroup>
    91|         <TargetFramework>net6.0</TargetFramework>
    92|     </PropertyGroup>
    93|     <ItemGroup>");

# --- HUNK 2: Lines 104-132 ---
   104|             try
   105|             {
   106|                 if (Directory.Exists(destDir))
   107|                 {
   108|                     _logger.LogMessage(MessageImportance.Low, $"Deleting {destDir}");
   109|                     Directory.Delete(destDir, recursive: true);
   110|                 }
   111|                 _logger.LogMessage(MessageImportance.Low, $"Copying {srcDir} to {destDir}");
   112|                 Directory.CreateDirectory(destDir);
   113|                 Utils.DirectoryCopy(srcDir, destDir);
   114|                 return true;
   115|             }
   116|             catch (Exception ex)
   117|             {
   118|                 _logger.LogError($"Failed while copying {srcDir} => {destDir}: {ex.Message}");
   119|                 if (ex is IOException)
   120|                     return false;
   121|                 throw;
   122|             }
   123|         }
   124|         private void LogErrorOrWarning(string msg, bool stopOnMissing)
   125|         {
   126|             if (stopOnMissing)
   127|                 _logger.LogError(msg);
   128|             else
   129|                 _logger.LogWarning(msg);
   130|         }
   131|     }
   132| }

