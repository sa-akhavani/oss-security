# ====================================================================
# FILE: src/coreclr/debug/daccess/dacdbiimpl.cpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 3145-3188 ---
  3145|     return TargetBuffer(PTR_TO_CORDB_ADDRESS(pVACookie->signature.GetRawSig()),
  3146|                         pVACookie->signature.GetRawSigLen());
  3147| }
  3148| BOOL DacDbiInterfaceImpl::RequiresAlign8(VMPTR_TypeHandle thExact)
  3149| {
  3150|     DD_ENTER_MAY_THROW;
  3151| #ifdef FEATURE_64BIT_ALIGNMENT
  3152|     TypeHandle th = TypeHandle::FromPtr(thExact.GetDacPtr());
  3153|     PTR_MethodTable mt = th.AsMethodTable();
  3154|     return mt->RequiresAlign8();
  3155| #else
  3156|     ThrowHR(E_NOTIMPL);
  3157| #endif
  3158| }
  3159| GENERICS_TYPE_TOKEN DacDbiInterfaceImpl::ResolveExactGenericArgsToken(DWORD               dwExactGenericArgsTokenIndex,
  3160|                                                                       GENERICS_TYPE_TOKEN rawToken)
  3161| {
  3162|     DD_ENTER_MAY_THROW;
  3163|     if (dwExactGenericArgsTokenIndex == 0)
  3164|     {
  3165|         if (rawToken == 0)
  3166|         {
  3167|             return rawToken;
  3168|         }
  3169|         TADDR addrObjThis = CORDB_ADDRESS_TO_TADDR(rawToken);
  3170|         PTR_Object pObjThis = dac_cast<PTR_Object>(addrObjThis);
  3171|         PTR_MethodTable pMT = pObjThis->GetMethodTable();
  3172|         TADDR addrMT = dac_cast<TADDR>(pMT);
  3173|         GENERICS_TYPE_TOKEN realToken = (GENERICS_TYPE_TOKEN) addrMT;
  3174|         return realToken;
  3175|     }
  3176|     else if (dwExactGenericArgsTokenIndex == (DWORD)ICorDebugInfo::TYPECTXT_ILNUM)
  3177|     {
  3178|         return  rawToken;
  3179|     }
  3180|     _ASSERTE(!"DDII::REGAT - Unexpected generics type token index.");
  3181|     ThrowHR(CORDBG_E_TARGET_INCONSISTENT);
  3182| }
  3183| IDacDbiInterface::DynamicMethodType DacDbiInterfaceImpl::IsILStubOrLCGMethod(VMPTR_MethodDesc vmMethodDesc)
  3184| {
  3185|     DD_ENTER_MAY_THROW;
  3186|     MethodDesc * pMD = vmMethodDesc.GetDacPtr();
  3187|     if (pMD->IsILStub())
  3188|     {


# ====================================================================
# FILE: src/coreclr/pal/src/exception/machexception.cpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 243-294 ---
   243|         CHECK_MACH("mach_port_deallocate", MachRetDeallocate);
   244|         if (MachRet != KERN_SUCCESS)
   245|             break;
   246|     }
   247|     if (MachRet != KERN_SUCCESS)
   248|     {
   249|         ASSERT("thread_set_exception_ports failed: %d\n", MachRet);
   250|         palError = UTIL_MachErrorToPalError(MachRet);
   251|     }
   252|     return palError;
   253| }
   254| #if defined(HOST_AMD64)
   255| extern "C"
   256| void PAL_DispatchException(DWORD64 dwRDI, DWORD64 dwRSI, DWORD64 dwRDX, DWORD64 dwRCX, DWORD64 dwR8, DWORD64 dwR9, PCONTEXT pContext, PEXCEPTION_RECORD pExRecord, MachExceptionInfo *pMachExceptionInfo)
   257| #elif defined(HOST_ARM64)
   258| extern "C"
   259| void PAL_DispatchException(PCONTEXT pContext, PEXCEPTION_RECORD pExRecord, MachExceptionInfo *pMachExceptionInfo)
   260| #endif
   261| {
   262|     CPalThread *pThread = InternalGetCurrentThread();
   263|     CONTEXT *contextRecord = pContext;
   264|     g_hardware_exception_context_locvar_offset = (int)((char*)&contextRecord - (char*)__builtin_frame_address(0));
   265|     pContext->ContextFlags |= CONTEXT_EXCEPTION_ACTIVE;
   266|     bool continueExecution;
   267|     {
   268|         PAL_SEHException exception(pExRecord, pContext, true);
   269|         TRACE("PAL_DispatchException(EC %08x EA %p)\n", pExRecord->ExceptionCode, pExRecord->ExceptionAddress);
   270|         continueExecution = SEHProcessException(&exception);
   271|         if (continueExecution)
   272|         {
   273|             *pContext = *exception.ExceptionPointers.ContextRecord;
   274|             *pExRecord = *exception.ExceptionPointers.ExceptionRecord;
   275|         }
   276|     }
   277|     if (continueExecution)
   278|     {
   279| #if defined(HOST_ARM64)
   280|         MachSetThreadContext(pContext);
   281| #else
   282|         RtlRestoreContext(pContext, pExRecord);
   283| #endif
   284|     }
   285|     MachMessage sSendMessage;
   286|     sSendMessage.SendForwardException(s_ExceptionPort, pMachExceptionInfo, pThread);
   287|     while (TRUE)
   288|     {
   289|         sched_yield();
   290|     }
   291| }
   292| extern "C" void PAL_DispatchExceptionWrapper();
   293| extern "C" int PAL_DispatchExceptionReturnOffset;
   294| /*++


# ====================================================================
# FILE: src/coreclr/pal/src/exception/seh-unwind.cpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 405-457 ---
   405|     GetContextPointer(cursor, unwContext, UNW_AARCH64_V12, &contextPointers->D12);
   406|     GetContextPointer(cursor, unwContext, UNW_AARCH64_V13, &contextPointers->D13);
   407|     GetContextPointer(cursor, unwContext, UNW_AARCH64_V14, &contextPointers->D14);
   408|     GetContextPointer(cursor, unwContext, UNW_AARCH64_V15, &contextPointers->D15);
   409| #elif (defined(HOST_UNIX) && defined(HOST_S390X))
   410|     GetContextPointer(cursor, unwContext, UNW_S390X_R6, &contextPointers->R6);
   411|     GetContextPointer(cursor, unwContext, UNW_S390X_R7, &contextPointers->R7);
   412|     GetContextPointer(cursor, unwContext, UNW_S390X_R8, &contextPointers->R8);
   413|     GetContextPointer(cursor, unwContext, UNW_S390X_R9, &contextPointers->R9);
   414|     GetContextPointer(cursor, unwContext, UNW_S390X_R10, &contextPointers->R10);
   415|     GetContextPointer(cursor, unwContext, UNW_S390X_R11, &contextPointers->R11);
   416|     GetContextPointer(cursor, unwContext, UNW_S390X_R12, &contextPointers->R12);
   417|     GetContextPointer(cursor, unwContext, UNW_S390X_R13, &contextPointers->R13);
   418|     GetContextPointer(cursor, unwContext, UNW_S390X_R14, &contextPointers->R14);
   419|     GetContextPointer(cursor, unwContext, UNW_S390X_R15, &contextPointers->R15);
   420| #else
   421| #error unsupported architecture
   422| #endif
   423| }
   424| #ifndef HOST_WINDOWS
   425| int g_hardware_exception_context_locvar_offset = 0;
   426| BOOL PAL_VirtualUnwind(CONTEXT *context, KNONVOLATILE_CONTEXT_POINTERS *contextPointers)
   427| {
   428|     int st;
   429|     unw_context_t unwContext;
   430|     unw_cursor_t cursor;
   431|     DWORD64 curPc = CONTEXTGetPC(context);
   432|     if ((void*)curPc == g_SEHProcessExceptionReturnAddress)
   433|     {
   434|         CONTEXT* exceptionContext = *(CONTEXT**)(CONTEXTGetFP(context) + g_hardware_exception_context_locvar_offset);
   435|         memcpy_s(context, sizeof(CONTEXT), exceptionContext, sizeof(CONTEXT));
   436|         return TRUE;
   437|     }
   438|     if ((context->ContextFlags & CONTEXT_EXCEPTION_ACTIVE) != 0)
   439|     {
   440|         CONTEXTSetPC(context, curPc + 1);
   441|     }
   442| #if !UNWIND_CONTEXT_IS_UCONTEXT_T
   443| #if defined(__llvm__) && defined(TARGET_ARM)
   444| #pragma clang diagnostic push
   445| #pragma clang diagnostic ignored "-Winline-asm"
   446| #endif
   447|     st = unw_getcontext(&unwContext);
   448| #if defined(__llvm__) && defined(TARGET_ARM)
   449| #pragma clang diagnostic pop
   450| #endif
   451|     if (st < 0)
   452|     {
   453|         return FALSE;
   454|     }
   455| #endif
   456|     WinContextToUnwindContext(context, &unwContext);
   457|     st = unw_init_local(&cursor, &unwContext);


# ====================================================================
# FILE: src/coreclr/pal/src/exception/signal.cpp
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 60-99 ---
    60| /* internal data declarations *********************************************/
    61| bool g_registered_signal_handlers = false;
    62| #if !HAVE_MACH_EXCEPTIONS
    63| bool g_enable_alternate_stack_check = false;
    64| #endif // !HAVE_MACH_EXCEPTIONS
    65| static bool g_registered_sigterm_handler = false;
    66| static bool g_registered_activation_handler = false;
    67| struct sigaction g_previous_sigterm;
    68| #ifdef INJECT_ACTIVATION_SIGNAL
    69| struct sigaction g_previous_activation;
    70| #endif
    71| struct sigaction g_previous_sigill;
    72| struct sigaction g_previous_sigtrap;
    73| struct sigaction g_previous_sigfpe;
    74| struct sigaction g_previous_sigbus;
    75| struct sigaction g_previous_sigsegv;
    76| struct sigaction g_previous_sigint;
    77| struct sigaction g_previous_sigquit;
    78| struct sigaction g_previous_sigabrt;
    79| #if !HAVE_MACH_EXCEPTIONS
    80| volatile void* g_stackOverflowHandlerStack = NULL;
    81| const int StackOverflowFlag = 0x40000000;
    82| #endif // !HAVE_MACH_EXCEPTIONS
    83| /* public function definitions ************************************************/
    84| /*++
    85| Function :
    86|     SEHInitializeSignals
    87|     Set up signal handlers to catch signals and translate them to exceptions
    88| Parameters :
    89|     None
    90| Return :
    91|     TRUE in case of a success, FALSE otherwise
    92| --*/
    93| BOOL SEHInitializeSignals(CorUnix::CPalThread *pthrCurrent, DWORD flags)
    94| {
    95|     TRACE("Initializing signal handlers %04x\n", flags);
    96| #if !HAVE_MACH_EXCEPTIONS
    97|     char* enableAlternateStackCheck = getenv("COMPlus_EnableAlternateStackCheck");
    98|     g_enable_alternate_stack_check = enableAlternateStackCheck && (strtoul(enableAlternateStackCheck, NULL, 10) != 0);
    99| #endif

# --- HUNK 2: Lines 655-699 ---
   655| Function :
   656|     common_signal_handler
   657|     common code for all signal handlers
   658| Parameters :
   659|     int code : signal received
   660|     siginfo_t *siginfo : siginfo passed to the signal handler
   661|     void *context : context structure passed to the signal handler
   662|     int numParams : number of variable parameters of the exception
   663|     ... : variable parameters of the exception (each of size_t type)
   664|     Returns true if the execution should continue or false if the exception was unhandled
   665| Note:
   666|     the "pointers" parameter should contain a valid exception record pointer,
   667|     but the ContextRecord pointer will be overwritten.
   668| --*/
   669| __attribute__((noinline))
   670| static bool common_signal_handler(int code, siginfo_t *siginfo, void *sigcontext, int numParams, ...)
   671| {
   672| #if !HAVE_MACH_EXCEPTIONS
   673|     sigset_t signal_set;
   674|     CONTEXT signalContextRecord;
   675|     CONTEXT* signalContextRecordPtr = &signalContextRecord;
   676|     EXCEPTION_RECORD exceptionRecord;
   677|     native_context_t *ucontext;
   678|     ucontext = (native_context_t *)sigcontext;
   679|     g_hardware_exception_context_locvar_offset = (int)((char*)&signalContextRecordPtr - (char*)__builtin_frame_address(0));
   680|     if (code == (SIGSEGV | StackOverflowFlag))
   681|     {
   682|         exceptionRecord.ExceptionCode = EXCEPTION_STACK_OVERFLOW;
   683|         code &= ~StackOverflowFlag;
   684|     }
   685|     else
   686|     {
   687|         exceptionRecord.ExceptionCode = CONTEXTGetExceptionCodeForSignal(siginfo, ucontext);
   688|     }
   689|     exceptionRecord.ExceptionFlags = EXCEPTION_IS_SIGNAL;
   690|     exceptionRecord.ExceptionRecord = NULL;
   691|     exceptionRecord.ExceptionAddress = GetNativeContextPC(ucontext);
   692|     exceptionRecord.NumberParameters = numParams;
   693|     va_list params;
   694|     va_start(params, numParams);
   695|     for (int i = 0; i < numParams; i++)
   696|     {
   697|         exceptionRecord.ExceptionInformation[i] = va_arg(params, size_t);
   698|     }
   699|     RtlCaptureContext(&signalContextRecord);


# ====================================================================
# FILE: src/coreclr/pal/src/include/pal/seh.hpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 80-101 ---
    80|     Enable SEH-related stuff on this thread
    81| Parameters:
    82|     CPalThread * pthrCurrent : reference to the current thread.
    83| Return value :
    84|     ERROR_SUCCESS, if enabling succeeded
    85|     an error code, otherwise
    86| --*/
    87| CorUnix::PAL_ERROR SEHEnable(CorUnix::CPalThread *pthrCurrent);
    88| /*++
    89| Function :
    90|     SEHDisable
    91|     Disable SEH-related stuff on this thread
    92| Parameters:
    93|     CPalThread * pthrCurrent : reference to the current thread.
    94| Return value :
    95|     ERROR_SUCCESS, if enabling succeeded
    96|     an error code, otherwise
    97| --*/
    98| CorUnix::PAL_ERROR SEHDisable(CorUnix::CPalThread *pthrCurrent);
    99| }
   100| extern int g_hardware_exception_context_locvar_offset;
   101| #endif /* _PAL_SEH_HPP_ */


# ====================================================================
# FILE: src/coreclr/tools/aot/ILCompiler.ReadyToRun/Compiler/ReadyToRunHashCode.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-44 ---
     1| using System;
     2| using System.Diagnostics;
     3| using System.Numerics;
     4| using System.Text;
     5| using Internal.TypeSystem;
     6| namespace ILCompiler
     7| {
     8|     public static class ReadyToRunHashCode
     9|     {
    10|         public static int NameHashCode(string name)
    11|         {
    12|             if (string.IsNullOrEmpty(name))
    13|             {
    14|                 return 0;
    15|             }
    16|             int hash1 = 0x6DA3B944;
    17|             int hash2 = 0;
    18|             byte[] src = Encoding.UTF8.GetBytes(name);
    19|             for (int i = 0; i < src.Length; i += 2)
    20|             {
    21|                 hash1 = unchecked(hash1 + RotateLeft(hash1, 5)) ^ (int)unchecked((sbyte)src[i]);
    22|                 if (i + 1 < src.Length)
    23|                 {
    24|                     hash2 = unchecked(hash2 + RotateLeft(hash2, 5)) ^ (int)unchecked((sbyte)src[i + 1]);
    25|                 }
    26|                 else
    27|                 {
    28|                     break;
    29|                 }
    30|             }
    31|             hash1 = unchecked(hash1 + RotateLeft(hash1, 8));
    32|             hash2 = unchecked(hash2 + RotateLeft(hash2, 8));
    33|             return unchecked((int)(hash1 ^ hash2));
    34|         }
    35|         public static int NameHashCode(string namespacePart, string namePart)
    36|         {
    37|             return NameHashCode(namespacePart) ^ NameHashCode(namePart);
    38|         }
    39|         public static int TypeTableHashCode(DefType type)
    40|         {
    41|             int hashcode = 0;
    42|             do
    43|             {
    44|                 hashcode ^= NameHashCode(type.Namespace, type.Name);


# ====================================================================
# FILE: src/coreclr/vm/proftoeeinterfaceimpl.cpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 682-722 ---
   682| #endif // FEATURE_EVENT_TRACE
   683|     if ((arrObjRef != NULL) && !bOnStack)
   684|     {
   685|         delete [] arrObjRef;
   686|     }
   687|     return (pProfilerWalkHeapContext->fProfilerPinned) ? SUCCEEDED(hr) : TRUE;
   688| }
   689| #endif // defined(GC_PROFILING) || defined(FEATURE_EVENT_TRACING)
   690| #ifdef PROFILING_SUPPORTED
   691| bool AllocByClassHelper(Object * pBO, void * pv)
   692| {
   693|     CONTRACTL
   694|     {
   695|         NOTHROW;
   696|         GC_NOTRIGGER;
   697|         MODE_ANY;
   698|     }
   699|     CONTRACTL_END;
   700|     _ASSERTE(pv != NULL);
   701|     {
   702|         BEGIN_PROFILER_CALLBACK(CORProfilerTrackGC());
   703|         g_profControlBlock.AllocByClass(
   704|             (ObjectID) pBO,
   705|             SafeGetClassIDFromObject(pBO),
   706|             pv);
   707|         END_PROFILER_CALLBACK();
   708|     }
   709|     return TRUE;
   710| }
   711| #endif // PROFILING_SUPPORTED
   712| #if defined(GC_PROFILING) || defined(FEATURE_EVENT_TRACE)
   713| void ScanRootsHelper(Object* pObj, Object ** ppRoot, ScanContext *pSC, uint32_t dwFlags)
   714| {
   715|     CONTRACTL
   716|     {
   717|         NOTHROW;
   718|         GC_NOTRIGGER;
   719|         MODE_ANY;
   720|     }
   721|     CONTRACTL_END;
   722|     FAULT_NOT_FATAL();


# ====================================================================
# FILE: src/coreclr/vm/syncblk.h
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 371-413 ---
   371| class ComCallWrapper;
   372| class ComClassFactory;
   373| struct RCW;
   374| class RCWHolder;
   375| typedef DPTR(class ComCallWrapper)        PTR_ComCallWrapper;
   376| #include "shash.h"
   377| #endif // FEATURE_COMINTEROP
   378| using ManagedObjectComWrapperByIdMap = MapSHash<INT64, void*>;
   379| class InteropSyncBlockInfo
   380| {
   381|     friend class RCWHolder;
   382|     friend class ClrDataAccess;
   383| public:
   384| #ifndef TARGET_UNIX
   385|     static SLIST_HEADER s_InteropInfoStandbyList;
   386| #endif // !TARGET_UNIX
   387|     InteropSyncBlockInfo()
   388|     {
   389|         LIMITED_METHOD_CONTRACT;
   390|         ZeroMemory(this, sizeof(InteropSyncBlockInfo));
   391| #if defined(FEATURE_COMWRAPPERS)
   392|         m_managedObjectComWrapperLock.Init(CrstManagedObjectWrapperMap, CRST_UNSAFE_COOPGC);
   393| #endif // FEATURE_COMWRAPPERS
   394|     }
   395| #ifndef DACCESS_COMPILE
   396|     ~InteropSyncBlockInfo();
   397| #endif
   398| #ifndef TARGET_UNIX
   399|     static void FlushStandbyList();
   400| #endif // !TARGET_UNIX
   401| #ifdef FEATURE_COMINTEROP
   402| #ifndef DACCESS_COMPILE
   403|     RCW* GetRawRCW()
   404|     {
   405|         LIMITED_METHOD_CONTRACT;
   406|         return (RCW *)((size_t)m_pRCW & ~1);
   407|     }
   408|     RCW* GetRCWAndIncrementUseCount();
   409|     void SetRawRCW(RCW* pRCW);
   410|     bool RCWWasUsed()
   411|     {
   412|         LIMITED_METHOD_CONTRACT;
   413|         return (m_pRCW != NULL);

# --- HUNK 2: Lines 498-537 ---
   498| public:
   499|     bool TryGetManagedObjectComWrapper(_In_ INT64 wrapperId, _Out_ void** mocw)
   500|     {
   501|         LIMITED_METHOD_DAC_CONTRACT;
   502|         *mocw = NULL;
   503|         if (m_managedObjectComWrapperMap == NULL)
   504|             return false;
   505|         CrstHolder lock(&m_managedObjectComWrapperLock);
   506|         return m_managedObjectComWrapperMap->Lookup(wrapperId, mocw);
   507|     }
   508| #ifndef DACCESS_COMPILE
   509|     bool TrySetManagedObjectComWrapper(_In_ INT64 wrapperId, _In_ void* mocw, _In_ void* curr = NULL)
   510|     {
   511|         LIMITED_METHOD_CONTRACT;
   512|         if (m_managedObjectComWrapperMap == NULL)
   513|         {
   514|             NewHolder<ManagedObjectComWrapperByIdMap> map = new ManagedObjectComWrapperByIdMap();
   515|             if (FastInterlockCompareExchangePointer((ManagedObjectComWrapperByIdMap**)&m_managedObjectComWrapperMap, (ManagedObjectComWrapperByIdMap *)map, NULL) == NULL)
   516|             {
   517|                 map.SuppressRelease();
   518|             }
   519|             _ASSERTE(m_managedObjectComWrapperMap != NULL);
   520|         }
   521|         CrstHolder lock(&m_managedObjectComWrapperLock);
   522|         if (m_managedObjectComWrapperMap->LookupPtr(wrapperId) != curr)
   523|             return false;
   524|         m_managedObjectComWrapperMap->Add(wrapperId, mocw);
   525|         return true;
   526|     }
   527|     using ClearWrappersCallback = void(void* mocw);
   528|     void ClearManagedObjectComWrappers(ClearWrappersCallback* callback)
   529|     {
   530|         LIMITED_METHOD_CONTRACT;
   531|         if (m_managedObjectComWrapperMap == NULL)
   532|             return;
   533|         CQuickArrayList<void*> localList;
   534|         {
   535|             CrstHolder lock(&m_managedObjectComWrapperLock);
   536|             if (callback != NULL)
   537|             {


# ====================================================================
# FILE: src/libraries/Common/src/Interop/OSX/Interop.libproc.cs
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| using System;
     2| using System.Collections.Generic;
     3| using System.ComponentModel;
     4| using System.Diagnostics;
     5| using System.Runtime.InteropServices;
     6| #pragma warning disable CA1823 // analyzer incorrectly flags fixed buffer length const (https://github.com/dotnet/roslyn/issues/37593)
     7| internal static partial class Interop
     8| {
     9|     internal static partial class libproc
    10|     {
    11|         private const int MAXPATHLEN = 1024;
    12|         private const int MAXTHREADNAMESIZE = 64;
    13|         private const int PROC_PIDTHREADINFO = 5;
    14|         private const int PROC_PIDLISTTHREADS = 6;
    15|         private const int PROC_PIDPATHINFO_MAXSIZE = 4 * MAXPATHLEN;
    16|         private const int RUSAGE_INFO_V3 = 3;
    17|         private const int EPERM = 1;
    18|         internal enum ThreadRunState
    19|         {
    20|             TH_STATE_RUNNING            = 1,
    21|             TH_STATE_STOPPED            = 2,
    22|             TH_STATE_WAITING            = 3,
    23|             TH_STATE_UNINTERRUPTIBLE    = 4,
    24|             TH_STATE_HALTED             = 5
    25|         }
    26|         [Flags]
    27|         internal enum ThreadFlags
    28|         {
    29|             TH_FLAGS_SWAPPED    = 0x1,
    30|             TH_FLAGS_IDLE       = 0x2
    31|         }
    32|         [StructLayout(LayoutKind.Sequential)]
    33|         internal unsafe struct rusage_info_v3
    34|         {
    35|             internal fixed byte     ri_uuid[16];
    36|             internal ulong          ri_user_time;
    37|             internal ulong          ri_system_time;

# --- HUNK 2: Lines 72-116 ---
    72|             internal int        pth_flags;
    73|             internal int        pth_sleep_time;
    74|             internal int        pth_curpri;
    75|             internal int        pth_priority;
    76|             internal int        pth_maxpriority;
    77|             internal fixed byte pth_name[MAXTHREADNAMESIZE];
    78|         }
    79|         [StructLayout(LayoutKind.Sequential)]
    80|         internal struct proc_fdinfo
    81|         {
    82|             internal int proc_fd;
    83|             internal uint proc_fdtype;
    84|         }
    85|         [DllImport(Interop.Libraries.libproc, SetLastError = true)]
    86|         private static extern unsafe int proc_listallpids(
    87|             int*    pBuffer,
    88|             int     buffersize);
    89|         internal static unsafe int[] proc_listallpids()
    90|         {
    91|             int numProcesses = proc_listallpids(null, 0);
    92|             if (numProcesses == 0 && Marshal.GetLastPInvokeError() == EPERM)
    93|             {
    94|                 return new[] { Environment.ProcessId };
    95|             }
    96|             else if (numProcesses <= 0)
    97|             {
    98|                 throw new Win32Exception(SR.CantGetAllPids);
    99|             }
   100|             int[] processes;
   101|             do
   102|             {
   103|                 processes = new int[(int)(numProcesses * 1.10)];
   104|                 fixed (int* pBuffer = &processes[0])
   105|                 {
   106|                     numProcesses = proc_listallpids(pBuffer, processes.Length * sizeof(int));
   107|                     if (numProcesses <= 0)
   108|                     {
   109|                         throw new Win32Exception(SR.CantGetAllPids);
   110|                     }
   111|                 }
   112|             }
   113|             while (numProcesses == processes.Length);
   114|             Array.Resize<int>(ref processes, numProcesses);
   115|             return processes;
   116|         }


# ====================================================================
# FILE: src/libraries/Common/src/Interop/Unix/System.Security.Cryptography.Native/Interop.EvpPkey.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 65-123 ---
    65|         internal static unsafe SafeEvpPKeyHandle DecodePkcs8PrivateKey(
    66|             ReadOnlySpan<byte> source,
    67|             EvpAlgorithmId algorithmId)
    68|         {
    69|             SafeEvpPKeyHandle handle;
    70|             fixed (byte* sourcePtr = source)
    71|             {
    72|                 handle = CryptoNative_DecodePkcs8PrivateKey(
    73|                     sourcePtr,
    74|                     source.Length,
    75|                     (int)algorithmId);
    76|             }
    77|             if (handle.IsInvalid)
    78|             {
    79|                 handle.Dispose();
    80|                 throw CreateOpenSslCryptographicException();
    81|             }
    82|             return handle;
    83|         }
    84|         [DllImport(Libraries.CryptoNative)]
    85|         private static extern int CryptoNative_GetPkcs8PrivateKeySize(IntPtr pkey, out int p8size);
    86|         private static int GetPkcs8PrivateKeySize(IntPtr pkey)
    87|         {
    88|             const int Success = 1;
    89|             const int Error = -1;
    90|             const int MissingPrivateKey = -2;
    91|             int ret = CryptoNative_GetPkcs8PrivateKeySize(pkey, out int p8size);
    92|             switch (ret)
    93|             {
    94|                 case Success:
    95|                     return p8size;
    96|                 case Error:
    97|                     throw CreateOpenSslCryptographicException();
    98|                 case MissingPrivateKey:
    99|                     throw new CryptographicException(SR.Cryptography_CSP_NoPrivateKey);
   100|                 default:
   101|                     Debug.Fail($"Unexpected return '{ret}' value from {nameof(CryptoNative_GetPkcs8PrivateKeySize)}.");
   102|                     throw new CryptographicException();
   103|             }
   104|         }
   105|         [DllImport(Libraries.CryptoNative)]
   106|         private static extern unsafe int CryptoNative_EncodePkcs8PrivateKey(IntPtr pkey, byte* buf);
   107|         internal static ArraySegment<byte> RentEncodePkcs8PrivateKey(SafeEvpPKeyHandle pkey)
   108|         {
   109|             bool addedRef = false;
   110|             try
   111|             {
   112|                 pkey.DangerousAddRef(ref addedRef);
   113|                 IntPtr handle = pkey.DangerousGetHandle();
   114|                 int size = GetPkcs8PrivateKeySize(handle);
   115|                 byte[] rented = CryptoPool.Rent(size);
   116|                 int written;
   117|                 unsafe
   118|                 {
   119|                     fixed (byte* buf = rented)
   120|                     {
   121|                         written = CryptoNative_EncodePkcs8PrivateKey(handle, buf);
   122|                     }
   123|                 }


# ====================================================================
# FILE: src/libraries/Common/src/Interop/Unix/System.Security.Cryptography.Native/Interop.OpenSsl.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 27-67 ---
    27|             {
    28|                 case ChannelBindingKind.Unique:
    29|                     bindingHandle = new SafeChannelBindingHandle(bindingType);
    30|                     QueryUniqueChannelBinding(context, bindingHandle);
    31|                     break;
    32|                 default:
    33|                     bindingHandle = null;
    34|                     break;
    35|             }
    36|             return bindingHandle;
    37|         }
    38|         internal static SafeSslHandle AllocateSslContext(SslProtocols protocols, SafeX509Handle? certHandle, SafeEvpPKeyHandle? certKeyHandle, EncryptionPolicy policy, SslAuthenticationOptions sslAuthenticationOptions)
    39|         {
    40|             SafeSslHandle? context = null;
    41|             using (SafeSslContextHandle innerContext = Ssl.SslCtxCreate(Ssl.SslMethods.SSLv23_method))
    42|             {
    43|                 if (innerContext.IsInvalid)
    44|                 {
    45|                     throw CreateSslException(SR.net_allocate_ssl_context_failed);
    46|                 }
    47|                 if (!Interop.Ssl.Capabilities.Tls13Supported)
    48|                 {
    49|                     if (protocols != SslProtocols.None &&
    50|                         CipherSuitesPolicyPal.WantsTls13(protocols))
    51|                     {
    52|                         protocols = protocols & (~SslProtocols.Tls13);
    53|                     }
    54|                 }
    55|                 else if (CipherSuitesPolicyPal.WantsTls13(protocols) &&
    56|                     CipherSuitesPolicyPal.ShouldOptOutOfTls13(sslAuthenticationOptions.CipherSuitesPolicy, policy))
    57|                 {
    58|                     if (protocols == SslProtocols.None)
    59|                     {
    60|                         protocols = SslProtocols.Tls | SslProtocols.Tls11 | SslProtocols.Tls12;
    61|                     }
    62|                     else
    63|                     {
    64|                         throw new SslException(
    65|                             SR.Format(SR.net_ssl_encryptionpolicy_notsupported, policy));
    66|                     }
    67|                 }


# ====================================================================
# FILE: src/libraries/Common/src/Interop/Unix/System.Security.Cryptography.Native/Interop.Ssl.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 82-126 ---
    82|         internal static extern int SslGetFinished(SafeSslHandle ssl, IntPtr buf, int count);
    83|         [DllImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSessionReused")]
    84|         [return: MarshalAs(UnmanagedType.Bool)]
    85|         internal static extern bool SslSessionReused(SafeSslHandle ssl);
    86|         [DllImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslAddExtraChainCert")]
    87|         internal static extern bool SslAddExtraChainCert(SafeSslHandle ssl, SafeX509Handle x509);
    88|         [DllImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetClientCAList")]
    89|         private static extern SafeSharedX509NameStackHandle SslGetClientCAList_private(SafeSslHandle ssl);
    90|         [DllImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetCurrentCipherId")]
    91|         [return: MarshalAs(UnmanagedType.Bool)]
    92|         internal static extern bool SslGetCurrentCipherId(SafeSslHandle ssl, out int cipherId);
    93|         [DllImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_GetOpenSslCipherSuiteName")]
    94|         private static extern IntPtr GetOpenSslCipherSuiteName(SafeSslHandle ssl, int cipherSuite, out int isTls12OrLower);
    95|         internal static string? GetOpenSslCipherSuiteName(SafeSslHandle ssl, TlsCipherSuite cipherSuite, out bool isTls12OrLower)
    96|         {
    97|             string? ret = Marshal.PtrToStringAnsi(GetOpenSslCipherSuiteName(ssl, (int)cipherSuite, out int isTls12OrLowerInt));
    98|             isTls12OrLower = isTls12OrLowerInt != 0;
    99|             return ret;
   100|         }
   101|         [DllImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_Tls13Supported")]
   102|         private static extern int Tls13SupportedImpl();
   103|         internal static class Capabilities
   104|         {
   105|             internal static readonly bool Tls13Supported = Tls13SupportedImpl() != 0;
   106|         }
   107|         internal static SafeSharedX509NameStackHandle SslGetClientCAList(SafeSslHandle ssl)
   108|         {
   109|             Crypto.CheckValidOpenSslHandle(ssl);
   110|             SafeSharedX509NameStackHandle handle = SslGetClientCAList_private(ssl);
   111|             if (!handle.IsInvalid)
   112|             {
   113|                 handle.SetParent(ssl);
   114|             }
   115|             return handle;
   116|         }
   117|         internal static bool AddExtraChainCertificates(SafeSslHandle sslContext, X509Chain chain)
   118|         {
   119|             Debug.Assert(chain != null, "X509Chain should not be null");
   120|             Debug.Assert(chain.ChainElements.Count > 0, "chain.Build should have already been called");
   121|             int stop = chain.ChainElements.Count - 1;
   122|             foreach (X509ChainStatus s in chain.ChainStatus)
   123|             {
   124|                 if ((s.Status & X509ChainStatusFlags.PartialChain) != 0)
   125|                 {
   126|                     stop++;


# ====================================================================
# FILE: src/libraries/Microsoft.Extensions.Configuration/src/ConfigurationManager.cs
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-122 ---
     1| using System;
     2| using System.Collections;
     3| using System.Collections.Generic;
     4| using System.Linq;
     5| using System.Threading;
     6| using Microsoft.Extensions.Primitives;
     7| namespace Microsoft.Extensions.Configuration
     8| {
     9|     public sealed class ConfigurationManager : IConfigurationBuilder, IConfigurationRoot, IDisposable
    10|     {
    11|         private readonly ConfigurationSources _sources;
    12|         private readonly ConfigurationBuilderProperties _properties;
    13|         private readonly ReferenceCountedProviderManager _providerManager = new();
    14|         private readonly List<IDisposable> _changeTokenRegistrations = new();
    15|         private ConfigurationReloadToken _changeToken = new();
    16|         public ConfigurationManager()
    17|         {
    18|             _sources = new ConfigurationSources(this);
    19|             _properties = new ConfigurationBuilderProperties(this);
    20|             this.AddInMemoryCollection();
    21|             AddSource(_sources[0]);
    22|         }
    23|         public string this[string key]
    24|         {
    25|             get
    26|             {
    27|                 using ReferenceCountedProviders reference = _providerManager.GetReference();
    28|                 return ConfigurationRoot.GetConfiguration(reference.Providers, key);
    29|             }
    30|             set
    31|             {
    32|                 using ReferenceCountedProviders reference = _providerManager.GetReference();
    33|                 ConfigurationRoot.SetConfiguration(reference.Providers, key, value);
    34|             }
    35|         }
    36|         public IConfigurationSection GetSection(string key) => new ConfigurationSection(this, key);
    37|         public IEnumerable<IConfigurationSection> GetChildren() => this.GetChildrenImplementation(null);
    38|         IDictionary<string, object> IConfigurationBuilder.Properties => _properties;
    39|         IList<IConfigurationSource> IConfigurationBuilder.Sources => _sources;
    40|         IEnumerable<IConfigurationProvider> IConfigurationRoot.Providers => _providerManager.NonReferenceCountedProviders;
    41|         public void Dispose()
    42|         {
    43|             DisposeRegistrations();
    44|             _providerManager.Dispose();
    45|         }
    46|         IConfigurationBuilder IConfigurationBuilder.Add(IConfigurationSource source)
    47|         {
    48|             _sources.Add(source ?? throw new ArgumentNullException(nameof(source)));
    49|             return this;
    50|         }
    51|         IConfigurationRoot IConfigurationBuilder.Build() => this;
    52|         IChangeToken IConfiguration.GetReloadToken() => _changeToken;
    53|         void IConfigurationRoot.Reload()
    54|         {
    55|             using (ReferenceCountedProviders reference = _providerManager.GetReference())
    56|             {
    57|                 foreach (IConfigurationProvider provider in reference.Providers)
    58|                 {
    59|                     provider.Load();
    60|                 }
    61|             }
    62|             RaiseChanged();
    63|         }
    64|         internal ReferenceCountedProviders GetProvidersReference() => _providerManager.GetReference();
    65|         private void RaiseChanged()
    66|         {
    67|             var previousToken = Interlocked.Exchange(ref _changeToken, new ConfigurationReloadToken());
    68|             previousToken.OnReload();
    69|         }
    70|         private void AddSource(IConfigurationSource source)
    71|         {
    72|             IConfigurationProvider provider = source.Build(this);
    73|             provider.Load();
    74|             _changeTokenRegistrations.Add(ChangeToken.OnChange(() => provider.GetReloadToken(), () => RaiseChanged()));
    75|             _providerManager.AddProvider(provider);
    76|             RaiseChanged();
    77|         }
    78|         private void ReloadSources()
    79|         {
    80|             DisposeRegistrations();
    81|             _changeTokenRegistrations.Clear();
    82|             var newProvidersList = new List<IConfigurationProvider>();
    83|             foreach (IConfigurationSource source in _sources)
    84|             {
    85|                 newProvidersList.Add(source.Build(this));
    86|             }
    87|             foreach (IConfigurationProvider p in newProvidersList)
    88|             {
    89|                 p.Load();
    90|                 _changeTokenRegistrations.Add(ChangeToken.OnChange(() => p.GetReloadToken(), () => RaiseChanged()));
    91|             }
    92|             _providerManager.ReplaceProviders(newProvidersList);
    93|             RaiseChanged();
    94|         }
    95|         private void DisposeRegistrations()
    96|         {
    97|             foreach (IDisposable registration in _changeTokenRegistrations)
    98|             {
    99|                 registration.Dispose();
   100|             }
   101|         }
   102|         private sealed class ConfigurationSources : IList<IConfigurationSource>
   103|         {
   104|             private readonly List<IConfigurationSource> _sources = new();
   105|             private readonly ConfigurationManager _config;
   106|             public ConfigurationSources(ConfigurationManager config)
   107|             {
   108|                 _config = config;
   109|             }
   110|             public IConfigurationSource this[int index]
   111|             {
   112|                 get => _sources[index];
   113|                 set
   114|                 {
   115|                     _sources[index] = value;
   116|                     _config.ReloadSources();
   117|                 }
   118|             }
   119|             public int Count => _sources.Count;
   120|             public bool IsReadOnly => false;
   121|             public void Add(IConfigurationSource source)
   122|             {

# --- HUNK 2: Lines 148-188 ---
   148|             {
   149|                 _sources.Insert(index, source);
   150|                 _config.ReloadSources();
   151|             }
   152|             public bool Remove(IConfigurationSource source)
   153|             {
   154|                 var removed = _sources.Remove(source);
   155|                 _config.ReloadSources();
   156|                 return removed;
   157|             }
   158|             public void RemoveAt(int index)
   159|             {
   160|                 _sources.RemoveAt(index);
   161|                 _config.ReloadSources();
   162|             }
   163|             IEnumerator IEnumerable.GetEnumerator()
   164|             {
   165|                 return GetEnumerator();
   166|             }
   167|         }
   168|         private sealed class ConfigurationBuilderProperties : IDictionary<string, object>
   169|         {
   170|             private readonly Dictionary<string, object> _properties = new();
   171|             private readonly ConfigurationManager _config;
   172|             public ConfigurationBuilderProperties(ConfigurationManager config)
   173|             {
   174|                 _config = config;
   175|             }
   176|             public object this[string key]
   177|             {
   178|                 get => _properties[key];
   179|                 set
   180|                 {
   181|                     _properties[key] = value;
   182|                     _config.ReloadSources();
   183|                 }
   184|             }
   185|             public ICollection<string> Keys => _properties.Keys;
   186|             public ICollection<object> Values => _properties.Values;
   187|             public int Count => _properties.Count;
   188|             public bool IsReadOnly => false;


# ====================================================================
# FILE: src/libraries/Microsoft.Extensions.Configuration/src/InternalConfigurationRootExtensions.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-27 ---
     1| using System;
     2| using System.Collections.Generic;
     3| using System.Linq;
     4| namespace Microsoft.Extensions.Configuration
     5| {
     6|     internal static class InternalConfigurationRootExtensions
     7|     {
     8|         internal static IEnumerable<IConfigurationSection> GetChildrenImplementation(this IConfigurationRoot root, string path)
     9|         {
    10|             using ReferenceCountedProviders? reference = (root as ConfigurationManager)?.GetProvidersReference();
    11|             IEnumerable<IConfigurationProvider> providers = reference?.Providers ?? root.Providers;
    12|             IEnumerable<IConfigurationSection> children = providers
    13|                 .Aggregate(Enumerable.Empty<string>(),
    14|                     (seed, source) => source.GetChildKeys(seed, path))
    15|                 .Distinct(StringComparer.OrdinalIgnoreCase)
    16|                 .Select(key => root.GetSection(path == null ? key : ConfigurationPath.Combine(path, key)));
    17|             if (reference is null)
    18|             {
    19|                 return children;
    20|             }
    21|             else
    22|             {
    23|                 return children.ToList();
    24|             }
    25|         }
    26|     }
    27| }


# ====================================================================
# FILE: src/libraries/Microsoft.Extensions.Configuration/src/ReferenceCountedProviders.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-66 ---
     1| ﻿// Licensed to the .NET Foundation under one or more agreements.
     2| using System;
     3| using System.Collections.Generic;
     4| using System.Diagnostics;
     5| using System.Threading;
     6| namespace Microsoft.Extensions.Configuration
     7| {
     8|     internal abstract class ReferenceCountedProviders : IDisposable
     9|     {
    10|         public static ReferenceCountedProviders Create(List<IConfigurationProvider> providers) => new ActiveReferenceCountedProviders(providers);
    11|         public static ReferenceCountedProviders CreateDisposed(List<IConfigurationProvider> providers) => new DisposedReferenceCountedProviders(providers);
    12|         public abstract List<IConfigurationProvider> Providers { get; set; }
    13|         public abstract List<IConfigurationProvider> NonReferenceCountedProviders { get; }
    14|         public abstract void AddReference();
    15|         public abstract void Dispose();
    16|         private sealed class ActiveReferenceCountedProviders : ReferenceCountedProviders
    17|         {
    18|             private long _refCount = 1;
    19|             private volatile List<IConfigurationProvider> _providers;
    20|             public ActiveReferenceCountedProviders(List<IConfigurationProvider> providers)
    21|             {
    22|                 _providers = providers;
    23|             }
    24|             public override List<IConfigurationProvider> Providers
    25|             {
    26|                 get
    27|                 {
    28|                     Debug.Assert(_refCount > 0);
    29|                     return _providers;
    30|                 }
    31|                 set
    32|                 {
    33|                     Debug.Assert(_refCount > 0);
    34|                     _providers = value;
    35|                 }
    36|             }
    37|             public override List<IConfigurationProvider> NonReferenceCountedProviders => _providers;
    38|             public override void AddReference()
    39|             {
    40|                 Debug.Assert(_refCount > 0);
    41|                 Interlocked.Increment(ref _refCount);
    42|             }
    43|             public override void Dispose()
    44|             {
    45|                 if (Interlocked.Decrement(ref _refCount) == 0)
    46|                 {
    47|                     foreach (IConfigurationProvider provider in _providers)
    48|                     {
    49|                         (provider as IDisposable)?.Dispose();
    50|                     }
    51|                 }
    52|             }
    53|         }
    54|         private sealed class DisposedReferenceCountedProviders : ReferenceCountedProviders
    55|         {
    56|             public DisposedReferenceCountedProviders(List<IConfigurationProvider> providers)
    57|             {
    58|                 Providers = providers;
    59|             }
    60|             public override List<IConfigurationProvider> Providers { get; set; }
    61|             public override List<IConfigurationProvider> NonReferenceCountedProviders => Providers;
    62|             public override void AddReference() { }
    63|             public override void Dispose() { }
    64|         }
    65|     }
    66| }


# ====================================================================
# FILE: src/libraries/Microsoft.Extensions.Configuration/src/ReferenceCountedProvidersManager.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-61 ---
     1| ﻿// Licensed to the .NET Foundation under one or more agreements.
     2| using System;
     3| using System.Collections.Generic;
     4| namespace Microsoft.Extensions.Configuration
     5| {
     6|     internal sealed class ReferenceCountedProviderManager : IDisposable
     7|     {
     8|         private readonly object _replaceProvidersLock = new object();
     9|         private ReferenceCountedProviders _refCountedProviders = ReferenceCountedProviders.Create(new List<IConfigurationProvider>());
    10|         private bool _disposed;
    11|         public IEnumerable<IConfigurationProvider> NonReferenceCountedProviders => _refCountedProviders.NonReferenceCountedProviders;
    12|         public ReferenceCountedProviders GetReference()
    13|         {
    14|             lock (_replaceProvidersLock)
    15|             {
    16|                 if (_disposed)
    17|                 {
    18|                     return ReferenceCountedProviders.CreateDisposed(_refCountedProviders.NonReferenceCountedProviders);
    19|                 }
    20|                 _refCountedProviders.AddReference();
    21|                 return _refCountedProviders;
    22|             }
    23|         }
    24|         public void ReplaceProviders(List<IConfigurationProvider> providers)
    25|         {
    26|             ReferenceCountedProviders oldRefCountedProviders = _refCountedProviders;
    27|             lock (_replaceProvidersLock)
    28|             {
    29|                 if (_disposed)
    30|                 {
    31|                     throw new ObjectDisposedException(nameof(ConfigurationManager));
    32|                 }
    33|                 _refCountedProviders = ReferenceCountedProviders.Create(providers);
    34|             }
    35|             oldRefCountedProviders.Dispose();
    36|         }
    37|         public void AddProvider(IConfigurationProvider provider)
    38|         {
    39|             lock (_replaceProvidersLock)
    40|             {
    41|                 if (_disposed)
    42|                 {
    43|                     throw new ObjectDisposedException(nameof(ConfigurationManager));
    44|                 }
    45|                 _refCountedProviders.Providers = new List<IConfigurationProvider>(_refCountedProviders.Providers)
    46|                 {
    47|                     provider
    48|                 };
    49|             }
    50|         }
    51|         public void Dispose()
    52|         {
    53|             ReferenceCountedProviders oldRefCountedProviders = _refCountedProviders;
    54|             lock (_replaceProvidersLock)
    55|             {
    56|                 _disposed = true;
    57|             }
    58|             oldRefCountedProviders.Dispose();
    59|         }
    60|     }
    61| }


# ====================================================================
# FILE: src/libraries/Microsoft.Extensions.Logging.Abstractions/gen/LoggerMessageGenerator.Emitter.cs
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 44-95 ---
    44|                         {
    45|                             return false;
    46|                         }
    47|                     }
    48|                 }
    49|                 return result;
    50|             }
    51|             private void GenType(LoggerClass lc)
    52|             {
    53|                 string nestedIndentation = "";
    54|                 if (!string.IsNullOrWhiteSpace(lc.Namespace))
    55|                 {
    56|                     _builder.Append($@"
    57| namespace {lc.Namespace}
    58| {{");
    59|                 }
    60|                 LoggerClass parent = lc.ParentClass;
    61|                 var parentClasses = new List<string>();
    62|                 while (parent != null)
    63|                 {
    64|                     parentClasses.Add($"partial {parent.Keyword} {parent.Name} ");
    65|                     parent = parent.ParentClass;
    66|                 }
    67|                 for (int i = parentClasses.Count - 1; i >= 0; i--)
    68|                 {
    69|                     _builder.Append($@"
    70|     {nestedIndentation}{parentClasses[i]}
    71|     {nestedIndentation}{{");
    72|                     nestedIndentation += "    ";
    73|                 }
    74|                 _builder.Append($@"
    75|     {nestedIndentation}partial {lc.Keyword} {lc.Name} 
    76|     {nestedIndentation}{{");
    77|                 foreach (LoggerMethod lm in lc.Methods)
    78|                 {
    79|                     if (!UseLoggerMessageDefine(lm))
    80|                     {
    81|                         GenStruct(lm, nestedIndentation);
    82|                     }
    83|                     GenLogMethod(lm, nestedIndentation);
    84|                 }
    85|                 _builder.Append($@"
    86|     {nestedIndentation}}}");
    87|                 parent = lc.ParentClass;
    88|                 while (parent != null)
    89|                 {
    90|                     nestedIndentation = new String(' ', nestedIndentation.Length - 4);
    91|                     _builder.Append($@"
    92|     {nestedIndentation}}}");
    93|                     parent = parent.ParentClass;
    94|                 }
    95|                 if (!string.IsNullOrWhiteSpace(lc.Namespace))

# --- HUNK 2: Lines 145-185 ---
   145|                 {nestedIndentation}for (int i = 0; i < {lm.TemplateParameters.Count + 1}; i++)
   146|                 {nestedIndentation}{{
   147|                     {nestedIndentation}yield return this[i];
   148|                 {nestedIndentation}}}
   149|             {nestedIndentation}}}
   150|             {nestedIndentation}global::System.Collections.IEnumerator global::System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();
   151|         {nestedIndentation}}}
   152| ");
   153|             }
   154|             private void GenFields(LoggerMethod lm, string nestedIndentation)
   155|             {
   156|                 foreach (LoggerParameter p in lm.TemplateParameters)
   157|                 {
   158|                     _builder.AppendLine($"            {nestedIndentation}private readonly {p.Type} _{p.Name};");
   159|                 }
   160|             }
   161|             private void GenFieldAssignments(LoggerMethod lm, string nestedIndentation)
   162|             {
   163|                 foreach (LoggerParameter p in lm.TemplateParameters)
   164|                 {
   165|                     _builder.AppendLine($"                {nestedIndentation}this._{p.Name} = {p.CodeName};");
   166|                 }
   167|             }
   168|             private void GenVariableAssignments(LoggerMethod lm, string nestedIndentation)
   169|             {
   170|                 foreach (KeyValuePair<string, string> t in lm.TemplateMap)
   171|                 {
   172|                     int index = 0;
   173|                     foreach (LoggerParameter p in lm.TemplateParameters)
   174|                     {
   175|                         if (t.Key.Equals(p.Name, System.StringComparison.OrdinalIgnoreCase))
   176|                         {
   177|                             break;
   178|                         }
   179|                         index++;
   180|                     }
   181|                     if (index < lm.TemplateParameters.Count)
   182|                     {
   183|                         if (lm.TemplateParameters[index].IsEnumerable)
   184|                         {
   185|                             _builder.AppendLine($"                {nestedIndentation}var {t.Key} = "

# --- HUNK 3: Lines 194-234 ---
   194|                 }
   195|             }
   196|             private void GenCases(LoggerMethod lm, string nestedIndentation)
   197|             {
   198|                 int index = 0;
   199|                 foreach (LoggerParameter p in lm.TemplateParameters)
   200|                 {
   201|                     string name = p.Name;
   202|                     if (lm.TemplateMap.ContainsKey(name))
   203|                     {
   204|                         name = lm.TemplateMap[name];
   205|                     }
   206|                     _builder.AppendLine($"                    {nestedIndentation}{index++} => new global::System.Collections.Generic.KeyValuePair<string, object?>(\"{name}\", this._{p.Name}),");
   207|                 }
   208|                 _builder.AppendLine($"                    {nestedIndentation}{index++} => new global::System.Collections.Generic.KeyValuePair<string, object?>(\"{{OriginalFormat}}\", \"{ConvertEndOfLineAndQuotationCharactersToEscapeForm(lm.Message)}\"),");
   209|             }
   210|             private void GenCallbackArguments(LoggerMethod lm)
   211|             {
   212|                 foreach (LoggerParameter p in lm.TemplateParameters)
   213|                 {
   214|                     _builder.Append($"{p.CodeName}, ");
   215|                 }
   216|             }
   217|             private void GenDefineTypes(LoggerMethod lm, bool brackets)
   218|             {
   219|                 if (lm.TemplateParameters.Count == 0)
   220|                 {
   221|                     return;
   222|                 }
   223|                 if (brackets)
   224|                 {
   225|                     _builder.Append('<');
   226|                 }
   227|                 bool firstItem = true;
   228|                 foreach (LoggerParameter p in lm.TemplateParameters)
   229|                 {
   230|                     if (firstItem)
   231|                     {
   232|                         firstItem = false;
   233|                     }
   234|                     else

# --- HUNK 4: Lines 242-315 ---
   242|                     _builder.Append('>');
   243|                 }
   244|                 else
   245|                 {
   246|                     _builder.Append(", ");
   247|                 }
   248|             }
   249|             private void GenParameters(LoggerMethod lm)
   250|             {
   251|                 bool firstItem = true;
   252|                 foreach (LoggerParameter p in lm.AllParameters)
   253|                 {
   254|                     if (firstItem)
   255|                     {
   256|                         firstItem = false;
   257|                     }
   258|                     else
   259|                     {
   260|                         _builder.Append(", ");
   261|                     }
   262|                     if (p.Qualifier != null)
   263|                     {
   264|                         _builder.Append($"{p.Qualifier} ");
   265|                     }
   266|                     _builder.Append($"{p.Type} {p.CodeName}");
   267|                 }
   268|             }
   269|             private void GenArguments(LoggerMethod lm)
   270|             {
   271|                 bool firstItem = true;
   272|                 foreach (LoggerParameter p in lm.TemplateParameters)
   273|                 {
   274|                     if (firstItem)
   275|                     {
   276|                         firstItem = false;
   277|                     }
   278|                     else
   279|                     {
   280|                         _builder.Append(", ");
   281|                     }
   282|                     _builder.Append($"{p.Type} {p.CodeName}");
   283|                 }
   284|             }
   285|             private void GenHolder(LoggerMethod lm)
   286|             {
   287|                 string typeName = $"__{lm.Name}Struct";
   288|                 _builder.Append($"new {typeName}(");
   289|                 foreach (LoggerParameter p in lm.TemplateParameters)
   290|                 {
   291|                     if (p != lm.TemplateParameters[0])
   292|                     {
   293|                         _builder.Append(", ");
   294|                     }
   295|                     _builder.Append(p.CodeName);
   296|                 }
   297|                 _builder.Append(')');
   298|             }
   299|             private void GenLogMethod(LoggerMethod lm, string nestedIndentation)
   300|             {
   301|                 string level = GetLogLevel(lm);
   302|                 string extension = lm.IsExtensionMethod ? "this " : string.Empty;
   303|                 string eventName = string.IsNullOrWhiteSpace(lm.EventName) ? $"nameof({lm.Name})" : $"\"{lm.EventName}\"";
   304|                 string exceptionArg = GetException(lm);
   305|                 string logger = GetLogger(lm);
   306|                 if (UseLoggerMessageDefine(lm))
   307|                 {
   308|                     _builder.Append($@"
   309|         {nestedIndentation}[{s_generatedCodeAttribute}]
   310|         {nestedIndentation}private static readonly global::System.Action<global::Microsoft.Extensions.Logging.ILogger, ");
   311|                     GenDefineTypes(lm, brackets: false);
   312|                     _builder.Append($@"global::System.Exception?> __{lm.Name}Callback =
   313|             {nestedIndentation}global::Microsoft.Extensions.Logging.LoggerMessage.Define");
   314|                     GenDefineTypes(lm, brackets: true);
   315|                     _builder.Append(@$"({level}, new global::Microsoft.Extensions.Logging.EventId({lm.EventId}, {eventName}), ""{ConvertEndOfLineAndQuotationCharactersToEscapeForm(lm.Message)}"", new global::Microsoft.Extensions.Logging.LogDefineOptions() {{ SkipEnabledCheck = true }}); 


# ====================================================================
# FILE: src/libraries/Microsoft.Extensions.Logging.Abstractions/gen/LoggerMessageGenerator.Parser.cs
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 230-307 ---
   230|                                         else
   231|                                         {
   232|                                             _ = ids.Add(lm.EventId);
   233|                                         }
   234|                                         string msg = lm.Message;
   235|                                         if (msg.StartsWith("INFORMATION:", StringComparison.OrdinalIgnoreCase)
   236|                                             || msg.StartsWith("INFO:", StringComparison.OrdinalIgnoreCase)
   237|                                             || msg.StartsWith("WARNING:", StringComparison.OrdinalIgnoreCase)
   238|                                             || msg.StartsWith("WARN:", StringComparison.OrdinalIgnoreCase)
   239|                                             || msg.StartsWith("ERROR:", StringComparison.OrdinalIgnoreCase)
   240|                                             || msg.StartsWith("ERR:", StringComparison.OrdinalIgnoreCase))
   241|                                         {
   242|                                             Diag(DiagnosticDescriptors.RedundantQualifierInMessage, ma.GetLocation(), method.Identifier.ToString());
   243|                                         }
   244|                                         bool foundLogger = false;
   245|                                         bool foundException = false;
   246|                                         bool foundLogLevel = level != null;
   247|                                         foreach (IParameterSymbol paramSymbol in methodSymbol.Parameters)
   248|                                         {
   249|                                             string paramName = paramSymbol.Name;
   250|                                             bool needsAtSign = false;
   251|                                             if (paramSymbol.DeclaringSyntaxReferences.Length > 0)
   252|                                             {
   253|                                                 ParameterSyntax paramSyntax = paramSymbol.DeclaringSyntaxReferences[0].GetSyntax(_cancellationToken) as ParameterSyntax;
   254|                                                 if (paramSyntax != null && !string.IsNullOrEmpty(paramSyntax.Identifier.Text))
   255|                                                 {
   256|                                                     needsAtSign = paramSyntax.Identifier.Text[0] == '@';
   257|                                                 }
   258|                                             }
   259|                                             if (string.IsNullOrWhiteSpace(paramName))
   260|                                             {
   261|                                                 keepMethod = false;
   262|                                                 break;
   263|                                             }
   264|                                             ITypeSymbol paramTypeSymbol = paramSymbol!.Type;
   265|                                             if (paramTypeSymbol is IErrorTypeSymbol)
   266|                                             {
   267|                                                 keepMethod = false;
   268|                                                 break;
   269|                                             }
   270|                                             string? qualifier = null;
   271|                                             if (paramSymbol.RefKind == RefKind.In)
   272|                                             {
   273|                                                 qualifier = "in";
   274|                                             }
   275|                                             else if (paramSymbol.RefKind == RefKind.Ref)
   276|                                             {
   277|                                                 qualifier = "ref";
   278|                                             }
   279|                                             string typeName = paramTypeSymbol.ToDisplayString(
   280|                                                 SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(
   281|                                                     SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
   282|                                             var lp = new LoggerParameter
   283|                                             {
   284|                                                 Name = paramName,
   285|                                                 Type = typeName,
   286|                                                 Qualifier = qualifier,
   287|                                                 CodeName = needsAtSign ? "@" + paramName : paramName,
   288|                                                 IsLogger = !foundLogger && IsBaseOrIdentity(paramTypeSymbol!, loggerSymbol),
   289|                                                 IsException = !foundException && IsBaseOrIdentity(paramTypeSymbol!, exceptionSymbol),
   290|                                                 IsLogLevel = !foundLogLevel && IsBaseOrIdentity(paramTypeSymbol!, logLevelSymbol),
   291|                                                 IsEnumerable = IsBaseOrIdentity(paramTypeSymbol!, enumerableSymbol) && !IsBaseOrIdentity(paramTypeSymbol!, stringSymbol),
   292|                                             };
   293|                                             foundLogger |= lp.IsLogger;
   294|                                             foundException |= lp.IsException;
   295|                                             foundLogLevel |= lp.IsLogLevel;
   296|                                             if (lp.IsLogger && lm.TemplateMap.ContainsKey(paramName))
   297|                                             {
   298|                                                 Diag(DiagnosticDescriptors.ShouldntMentionLoggerInMessage, paramSymbol.Locations[0], paramName);
   299|                                             }
   300|                                             else if (lp.IsException && lm.TemplateMap.ContainsKey(paramName))
   301|                                             {
   302|                                                 Diag(DiagnosticDescriptors.ShouldntMentionExceptionInMessage, paramSymbol.Locations[0], paramName);
   303|                                             }
   304|                                             else if (lp.IsLogLevel && lm.TemplateMap.ContainsKey(paramName))
   305|                                             {
   306|                                                 Diag(DiagnosticDescriptors.ShouldntMentionLogLevelInMessage, paramSymbol.Locations[0], paramName);
   307|                                             }

# --- HUNK 2: Lines 397-451 ---
   397|                                             {
   398|                                                 nspace = namespaceParent.Name.ToString();
   399|                                                 while (true)
   400|                                                 {
   401|                                                     namespaceParent = namespaceParent.Parent as NamespaceDeclarationSyntax;
   402|                                                     if (namespaceParent == null)
   403|                                                     {
   404|                                                         break;
   405|                                                     }
   406|                                                     nspace = $"{namespaceParent.Name}.{nspace}";
   407|                                                 }
   408|                                             }
   409|                                         }
   410|                                         if (keepMethod)
   411|                                         {
   412|                                             lc ??= new LoggerClass
   413|                                             {
   414|                                                 Keyword = classDec.Keyword.ValueText,
   415|                                                 Namespace = nspace,
   416|                                                 Name = classDec.Identifier.ToString() + classDec.TypeParameterList,
   417|                                                 ParentClass = null,
   418|                                             };
   419|                                             LoggerClass currentLoggerClass = lc;
   420|                                             var parentLoggerClass = (classDec.Parent as TypeDeclarationSyntax);
   421|                                             bool IsAllowedKind(SyntaxKind kind) =>
   422|                                                 kind == SyntaxKind.ClassDeclaration ||
   423|                                                 kind == SyntaxKind.StructDeclaration ||
   424|                                                 kind == SyntaxKind.RecordDeclaration;
   425|                                             while (parentLoggerClass != null && IsAllowedKind(parentLoggerClass.Kind()))
   426|                                             {
   427|                                                 currentLoggerClass.ParentClass = new LoggerClass
   428|                                                 {
   429|                                                     Keyword = parentLoggerClass.Keyword.ValueText,
   430|                                                     Namespace = nspace,
   431|                                                     Name = parentLoggerClass.Identifier.ToString() + parentLoggerClass.TypeParameterList,
   432|                                                     ParentClass = null,
   433|                                                 };
   434|                                                 currentLoggerClass = currentLoggerClass.ParentClass;
   435|                                                 parentLoggerClass = (parentLoggerClass.Parent as TypeDeclarationSyntax);
   436|                                             }
   437|                                             lc.Methods.Add(lm);
   438|                                         }
   439|                                     }
   440|                                 }
   441|                             }
   442|                         }
   443|                         if (lc != null)
   444|                         {
   445|                             results.Add(lc);
   446|                         }
   447|                     }
   448|                 }
   449|                 return results;
   450|             }
   451|             private (string? loggerField, bool multipleLoggerFields) FindLoggerField(SemanticModel sm, TypeDeclarationSyntax classDec, ITypeSymbol loggerSymbol)

# --- HUNK 3: Lines 560-611 ---
   560|             {
   561|                 Optional<object?> optional = sm.GetConstantValue(expr, _cancellationToken);
   562|                 if (optional.HasValue)
   563|                 {
   564|                     object o = optional.Value;
   565|                     if (o != null)
   566|                     {
   567|                         return o.ToString();
   568|                     }
   569|                 }
   570|                 return string.Empty;
   571|             }
   572|             private static object GetItem(TypedConstant arg) => arg.Kind == TypedConstantKind.Array ? arg.Values : arg.Value;
   573|         }
   574|         internal class LoggerClass
   575|         {
   576|             public readonly List<LoggerMethod> Methods = new ();
   577|             public string Keyword = string.Empty;
   578|             public string Namespace = string.Empty;
   579|             public string Name = string.Empty;
   580|             public LoggerClass? ParentClass;
   581|         }
   582|         internal class LoggerMethod
   583|         {
   584|             public readonly List<LoggerParameter> AllParameters = new ();
   585|             public readonly List<LoggerParameter> TemplateParameters = new ();
   586|             public readonly Dictionary<string, string> TemplateMap = new (StringComparer.OrdinalIgnoreCase);
   587|             public readonly List<string> TemplateList = new ();
   588|             public string Name = string.Empty;
   589|             public string Message = string.Empty;
   590|             public int? Level;
   591|             public int EventId;
   592|             public string? EventName;
   593|             public bool IsExtensionMethod;
   594|             public string Modifiers = string.Empty;
   595|             public string LoggerField = string.Empty;
   596|             public bool SkipEnabledCheck;
   597|         }
   598|         internal class LoggerParameter
   599|         {
   600|             public string Name = string.Empty;
   601|             public string Type = string.Empty;
   602|             public string CodeName = string.Empty;
   603|             public string? Qualifier;
   604|             public bool IsLogger;
   605|             public bool IsException;
   606|             public bool IsLogLevel;
   607|             public bool IsEnumerable;
   608|             public bool IsTemplateParameter => !IsLogger && !IsException && !IsLogLevel;
   609|         }
   610|     }
   611| }


# ====================================================================
# FILE: src/libraries/Native/AnyOS/zlib/pal_zlib.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-27 ---
     1| #include <assert.h>
     2| #include <stdlib.h>
     3| #include "pal_zlib.h"
     4| #ifdef  _WIN32
     5|     #define c_static_assert(e) static_assert((e),"")
     6| #endif
     7| #if defined(_WIN32) || defined(__EMSCRIPTEN__)
     8|     #include "../../Windows/System.IO.Compression.Native/zlib/zlib.h"
     9| #else
    10|     #include "pal_utilities.h"
    11|     #include <zlib.h>
    12| #endif
    13| c_static_assert(PAL_Z_NOFLUSH == Z_NO_FLUSH);
    14| c_static_assert(PAL_Z_FINISH == Z_FINISH);
    15| c_static_assert(PAL_Z_OK == Z_OK);
    16| c_static_assert(PAL_Z_STREAMEND == Z_STREAM_END);
    17| c_static_assert(PAL_Z_STREAMERROR == Z_STREAM_ERROR);
    18| c_static_assert(PAL_Z_DATAERROR == Z_DATA_ERROR);
    19| c_static_assert(PAL_Z_MEMERROR == Z_MEM_ERROR);
    20| c_static_assert(PAL_Z_BUFERROR == Z_BUF_ERROR);
    21| c_static_assert(PAL_Z_VERSIONERROR == Z_VERSION_ERROR);
    22| c_static_assert(PAL_Z_NOCOMPRESSION == Z_NO_COMPRESSION);
    23| c_static_assert(PAL_Z_BESTSPEED == Z_BEST_SPEED);
    24| c_static_assert(PAL_Z_DEFAULTCOMPRESSION == Z_DEFAULT_COMPRESSION);
    25| c_static_assert(PAL_Z_DEFAULTSTRATEGY == Z_DEFAULT_STRATEGY);
    26| c_static_assert(PAL_Z_DEFLATED == Z_DEFLATED);
    27| /*


# ====================================================================
# FILE: src/libraries/Native/Unix/System.Native/pal_interfaceaddresses.c
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 1-151 ---
     1| #include "pal_config.h"
     2| #include "pal_interfaceaddresses.h"
     3| #include "pal_maphardwaretype.h"
     4| #include "pal_utilities.h"
     5| #include "pal_safecrt.h"
     6| #include "pal_networking.h"
     7| #include <stdlib.h>
     8| #include <sys/types.h>
     9| #include <assert.h>
    10| #if HAVE_IFADDRS || HAVE_GETIFADDRS
    11| #include <ifaddrs.h>
    12| #endif
    13| #if !HAVE_GETIFADDRS && TARGET_ANDROID
    14| #include <dlfcn.h>
    15| #include <pthread.h>
    16| #endif
    17| #include <net/if.h>
    18| #include <netinet/in.h>
    19| #include <string.h>
    20| #include <sys/socket.h>
    21| #if HAVE_SYS_SYSCTL_H
    22| #include <sys/sysctl.h>
    23| #endif
    24| #if HAVE_SYS_IOCTL_H
    25| #include <sys/ioctl.h>
    26| #endif
    27| #if HAVE_ETHTOOL_H
    28| #include <linux/ethtool.h>
    29| #include <linux/sockios.h>
    30| #include <arpa/inet.h>
    31| #endif
    32| #if HAVE_NET_IFMEDIA_H
    33| #include <net/if_media.h>
    34| #elif HAVE_IOS_NET_IFMEDIA_H
    35| #include "ios/net/if_media.h"
    36| #endif
    37| #if defined(AF_PACKET)
    38| #include <sys/ioctl.h>
    39| #if HAVE_NETPACKET_PACKET_H
    40| #include <netpacket/packet.h>
    41| #else
    42| #include <linux/if_packet.h>
    43| #endif
    44| #elif defined(AF_LINK)
    45| #include <net/if_dl.h>
    46| #include <net/if_types.h>
    47| #else
    48| #error System must have AF_PACKET or AF_LINK.
    49| #endif
    50| #if HAVE_RT_MSGHDR
    51| #if HAVE_IOS_NET_ROUTE_H
    52| #include "ios/net/route.h"
    53| #else
    54| #include <net/route.h>
    55| #endif
    56| #endif
    57| static inline uint8_t mask2prefix(uint8_t* mask, int length)
    58| {
    59|     uint8_t len = 0;
    60|     uint8_t* end = mask + length;
    61|     if (mask == NULL)
    62|     {
    63|         return (uint8_t)length * 8;
    64|     }
    65|     while ((mask < end) && (*mask == 0xff))
    66|     {
    67|         len += 8;
    68|         mask++;
    69|     }
    70|     if (mask < end)
    71|     {
    72|         while (*mask)
    73|         {
    74|             len++;
    75|             *mask <<= 1;
    76|         }
    77|     }
    78|     if (len == 0 && length == 4)
    79|     {
    80|         len = 32;
    81|     }
    82|     return len;
    83| }
    84| #if !HAVE_IFADDRS && TARGET_ANDROID
    85| struct ifaddrs
    86| {
    87| 	struct ifaddrs *ifa_next;
    88| 	char *ifa_name;
    89| 	unsigned int ifa_flags;
    90| 	struct sockaddr *ifa_addr;
    91| 	struct sockaddr *ifa_netmask;
    92| 	union
    93| 	{
    94| 		struct sockaddr *ifu_broadaddr;
    95| 		struct sockaddr *ifu_dstaddr;
    96| 	} ifa_ifu;
    97| 	void *ifa_data;
    98| };
    99| #endif
   100| #if !HAVE_GETIFADDRS && TARGET_ANDROID
   101| static int (*getifaddrs)(struct ifaddrs**) = NULL;
   102| static void (*freeifaddrs)(struct ifaddrs*) = NULL;
   103| static void try_loading_getifaddrs()
   104| {
   105|     void *libc = dlopen("libc.so", RTLD_NOW);
   106|     if (libc)
   107|     {
   108|         getifaddrs = (int (*)(struct ifaddrs**)) dlsym(libc, "getifaddrs");
   109|         freeifaddrs = (void (*)(struct ifaddrs*)) dlsym(libc, "freeifaddrs");
   110|     }
   111| }
   112| static bool ensure_getifaddrs_is_loaded()
   113| {
   114|     static pthread_once_t getifaddrs_is_loaded = PTHREAD_ONCE_INIT;
   115|     pthread_once(&getifaddrs_is_loaded, try_loading_getifaddrs);
   116|     return getifaddrs != NULL && freeifaddrs != NULL;
   117| }
   118| #endif
   119| int32_t SystemNative_EnumerateInterfaceAddresses(void* context,
   120|                                                IPv4AddressFound onIpv4Found,
   121|                                                IPv6AddressFound onIpv6Found,
   122|                                                LinkLayerAddressFound onLinkLayerFound)
   123| {
   124| #if !HAVE_GETIFADDRS && TARGET_ANDROID
   125|     if (!ensure_getifaddrs_is_loaded())
   126|     {
   127|         errno = ENOTSUP;
   128|         return -1;
   129|     }
   130| #endif
   131| #if HAVE_GETIFADDRS || TARGET_ANDROID
   132|     struct ifaddrs* headAddr;
   133|     if (getifaddrs(&headAddr) == -1)
   134|     {
   135|         return -1;
   136|     }
   137|     for (struct ifaddrs* current = headAddr; current != NULL; current = current->ifa_next)
   138|     {
   139|         if (current->ifa_addr == NULL)
   140|         {
   141|             continue;
   142|         }
   143|         uint32_t interfaceIndex = if_nametoindex(current->ifa_name);
   144|         char actualName[IF_NAMESIZE];
   145|         char* result = if_indextoname(interfaceIndex, actualName);
   146|         if (result == NULL)
   147|         {
   148|             freeifaddrs(headAddr);
   149|             return -1;
   150|         }
   151|         assert(result == actualName);

# --- HUNK 2: Lines 230-277 ---
   230| #endif
   231|                 memcpy_s(&lla.AddressBytes, sizeof_member(LinkLayerAddressInfo, AddressBytes), (uint8_t*)LLADDR(sadl), sadl->sdl_alen);
   232|                 onLinkLayerFound(context, current->ifa_name, &lla);
   233|             }
   234|         }
   235| #endif
   236|     }
   237|     freeifaddrs(headAddr);
   238|     return 0;
   239| #else
   240|     (void)context;
   241|     (void)onIpv4Found;
   242|     (void)onIpv6Found;
   243|     (void)onLinkLayerFound;
   244|     errno = ENOTSUP;
   245|     return -1;
   246| #endif
   247| }
   248| int32_t SystemNative_GetNetworkInterfaces(int32_t * interfaceCount, NetworkInterfaceInfo **interfaceList, int32_t * addressCount, IpAddressInfo **addressList )
   249| {
   250| #if !HAVE_GETIFADDRS && TARGET_ANDROID
   251|     if (!ensure_getifaddrs_is_loaded())
   252|     {
   253|         errno = ENOTSUP;
   254|         return -1;
   255|     }
   256| #endif
   257| #if HAVE_GETIFADDRS || TARGET_ANDROID
   258|     struct ifaddrs* head;   // Pointer to block allocated by getifaddrs().
   259|     struct ifaddrs* ifaddrsEntry;
   260|     IpAddressInfo *ai;
   261|     int count = 0;       // Count of entries returned by getifaddrs().
   262|     int ip4count = 0;    // Total number of IPv4 addresses.
   263|     int ip6count = 0;    // Total number of IPv6 addresses.
   264|     int ifcount = 0;     // Total number of unique network interface.
   265|     int index;
   266|     int socketfd = -1;
   267|     NetworkInterfaceInfo *nii;
   268|     if (getifaddrs(&head) == -1)
   269|     {
   270|         assert(errno != 0);
   271|         return -1;
   272|     }
   273|     ifaddrsEntry = head;
   274|     while (ifaddrsEntry != NULL)
   275|     {
   276|         count ++;
   277|         if (ifaddrsEntry->ifa_addr != NULL && ifaddrsEntry->ifa_addr->sa_family == AF_INET)


# ====================================================================
# FILE: src/libraries/Native/Unix/System.Native/pal_io.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 248-292 ---
   248| }
   249| intptr_t SystemNative_Dup(intptr_t oldfd)
   250| {
   251|     int result;
   252| #if HAVE_F_DUPFD_CLOEXEC
   253|     while ((result = fcntl(ToFileDescriptor(oldfd), F_DUPFD_CLOEXEC, 0)) < 0 && errno == EINTR);
   254| #else
   255|     while ((result = fcntl(ToFileDescriptor(oldfd), F_DUPFD, 0)) < 0 && errno == EINTR);
   256|     fcntl(result, F_SETFD, FD_CLOEXEC);
   257| #endif
   258|     return result;
   259| }
   260| int32_t SystemNative_Unlink(const char* path)
   261| {
   262|     int32_t result;
   263|     while ((result = unlink(path)) < 0 && errno == EINTR);
   264|     return result;
   265| }
   266| intptr_t SystemNative_ShmOpen(const char* name, int32_t flags, int32_t mode)
   267| {
   268| #if defined(SHM_NAME_MAX) // macOS
   269|     assert(strlen(name) <= SHM_NAME_MAX);
   270| #elif defined(PATH_MAX) // other Unixes
   271|     assert(strlen(name) <= PATH_MAX);
   272| #endif
   273| #if HAVE_SHM_OPEN_THAT_WORKS_WELL_ENOUGH_WITH_MMAP
   274|     flags = ConvertOpenFlags(flags);
   275|     if (flags == -1)
   276|     {
   277|         errno = EINVAL;
   278|         return -1;
   279|     }
   280|     return shm_open(name, flags, (mode_t)mode);
   281| #else
   282|     (void)name, (void)flags, (void)mode;
   283|     errno = ENOTSUP;
   284|     return -1;
   285| #endif
   286| }
   287| int32_t SystemNative_ShmUnlink(const char* name)
   288| {
   289| #if HAVE_SHM_OPEN_THAT_WORKS_WELL_ENOUGH_WITH_MMAP
   290|     int32_t result;
   291|     while ((result = shm_unlink(name)) < 0 && errno == EINTR);
   292|     return result;


# ====================================================================
# FILE: src/libraries/Native/Unix/System.Security.Cryptography.Native.Android/pal_sslstream.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 418-465 ---
   418|     {
   419|         IGNORE_RETURN((*env)->CallObjectMethod(env, sslStream->appInBuffer, g_ByteBufferCompact));
   420|         ON_EXCEPTION_PRINT_AND_GOTO(cleanup);
   421|         int handshakeStatus;
   422|         PAL_SSLStreamStatus unwrapStatus = DoUnwrap(env, sslStream, &handshakeStatus);
   423|         if (unwrapStatus != SSLStreamStatus_OK)
   424|         {
   425|             ret = unwrapStatus;
   426|             goto cleanup;
   427|         }
   428|         IGNORE_RETURN((*env)->CallObjectMethod(env, sslStream->appInBuffer, g_ByteBufferFlip));
   429|         if (IsHandshaking(handshakeStatus))
   430|         {
   431|             ret = SSLStreamStatus_Renegotiate;
   432|             goto cleanup;
   433|         }
   434|         rem = (*env)->CallIntMethod(env, sslStream->appInBuffer, g_ByteBufferRemaining);
   435|     }
   436|     if (rem > 0)
   437|     {
   438|         int32_t bytes_to_read = rem < length ? rem : length;
   439|         data = make_java_byte_array(env, bytes_to_read);
   440|         IGNORE_RETURN((*env)->CallObjectMethod(env, sslStream->appInBuffer, g_ByteBufferGet, data));
   441|         ON_EXCEPTION_PRINT_AND_GOTO(cleanup);
   442|         IGNORE_RETURN((*env)->CallObjectMethod(env, sslStream->appInBuffer, g_ByteBufferCompact));
   443|         ON_EXCEPTION_PRINT_AND_GOTO(cleanup);
   444|         (*env)->GetByteArrayRegion(env, data, 0, bytes_to_read, (jbyte*)buffer);
   445|         *read = bytes_to_read;
   446|         ret = SSLStreamStatus_OK;
   447|     }
   448|     else
   449|     {
   450|         ret = SSLStreamStatus_NeedData;
   451|     }
   452| cleanup:
   453|     ReleaseLRef(env, data);
   454|     return ret;
   455| }
   456| PAL_SSLStreamStatus AndroidCryptoNative_SSLStreamWrite(SSLStream* sslStream, uint8_t* buffer, int32_t length)
   457| {
   458|     abort_if_invalid_pointer_argument (sslStream);
   459|     JNIEnv* env = GetJNIEnv();
   460|     PAL_SSLStreamStatus ret = SSLStreamStatus_Error;
   461|     int32_t remaining = (*env)->CallIntMethod(env, sslStream->appOutBuffer, g_ByteBufferRemaining);
   462|     int32_t arraySize = length > remaining ? remaining : length;
   463|     jbyteArray data = make_java_byte_array(env, arraySize);
   464|     int32_t written = 0;
   465|     while (written < length)


# ====================================================================
# FILE: src/libraries/Native/Unix/System.Security.Cryptography.Native/opensslshim.h
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 213-253 ---
   213|     REQUIRED_FUNCTION(EC_KEY_get0_public_key) \
   214|     REQUIRED_FUNCTION(EC_KEY_new) \
   215|     REQUIRED_FUNCTION(EC_KEY_new_by_curve_name) \
   216|     REQUIRED_FUNCTION(EC_KEY_set_group) \
   217|     REQUIRED_FUNCTION(EC_KEY_set_private_key) \
   218|     REQUIRED_FUNCTION(EC_KEY_set_public_key) \
   219|     REQUIRED_FUNCTION(EC_KEY_set_public_key_affine_coordinates) \
   220|     REQUIRED_FUNCTION(EC_KEY_up_ref) \
   221|     REQUIRED_FUNCTION(EC_METHOD_get_field_type) \
   222|     REQUIRED_FUNCTION(EC_POINT_free) \
   223|     REQUIRED_FUNCTION(EC_POINT_get_affine_coordinates_GFp) \
   224|     REQUIRED_FUNCTION(EC_POINT_mul) \
   225|     REQUIRED_FUNCTION(EC_POINT_new) \
   226|     REQUIRED_FUNCTION(EC_POINT_set_affine_coordinates_GFp) \
   227|     REQUIRED_FUNCTION(ERR_clear_error) \
   228|     REQUIRED_FUNCTION(ERR_error_string_n) \
   229|     REQUIRED_FUNCTION(ERR_get_error) \
   230|     LEGACY_FUNCTION(ERR_load_crypto_strings) \
   231|     LIGHTUP_FUNCTION(ERR_new) \
   232|     REQUIRED_FUNCTION(ERR_peek_error) \
   233|     REQUIRED_FUNCTION(ERR_peek_error_line) \
   234|     REQUIRED_FUNCTION(ERR_peek_last_error) \
   235|     FALLBACK_FUNCTION(ERR_put_error) \
   236|     REQUIRED_FUNCTION(ERR_reason_error_string) \
   237|     LIGHTUP_FUNCTION(ERR_set_debug) \
   238|     LIGHTUP_FUNCTION(ERR_set_error) \
   239|     REQUIRED_FUNCTION(EVP_aes_128_cbc) \
   240|     REQUIRED_FUNCTION(EVP_aes_128_ccm) \
   241|     REQUIRED_FUNCTION(EVP_aes_128_cfb128) \
   242|     REQUIRED_FUNCTION(EVP_aes_128_cfb8) \
   243|     REQUIRED_FUNCTION(EVP_aes_128_ecb) \
   244|     REQUIRED_FUNCTION(EVP_aes_128_gcm) \
   245|     REQUIRED_FUNCTION(EVP_aes_192_cbc) \
   246|     REQUIRED_FUNCTION(EVP_aes_192_ccm) \
   247|     REQUIRED_FUNCTION(EVP_aes_192_cfb128) \
   248|     REQUIRED_FUNCTION(EVP_aes_192_cfb8) \
   249|     REQUIRED_FUNCTION(EVP_aes_192_ecb) \
   250|     REQUIRED_FUNCTION(EVP_aes_192_gcm) \
   251|     REQUIRED_FUNCTION(EVP_aes_256_cbc) \
   252|     REQUIRED_FUNCTION(EVP_aes_256_ccm) \
   253|     REQUIRED_FUNCTION(EVP_aes_256_cfb128) \

# --- HUNK 2: Lines 658-698 ---
   658| #define EC_KEY_get0_public_key EC_KEY_get0_public_key_ptr
   659| #define EC_KEY_new EC_KEY_new_ptr
   660| #define EC_KEY_new_by_curve_name EC_KEY_new_by_curve_name_ptr
   661| #define EC_KEY_set_group EC_KEY_set_group_ptr
   662| #define EC_KEY_set_private_key EC_KEY_set_private_key_ptr
   663| #define EC_KEY_set_public_key EC_KEY_set_public_key_ptr
   664| #define EC_KEY_set_public_key_affine_coordinates EC_KEY_set_public_key_affine_coordinates_ptr
   665| #define EC_KEY_up_ref EC_KEY_up_ref_ptr
   666| #define EC_METHOD_get_field_type EC_METHOD_get_field_type_ptr
   667| #define EC_POINT_free EC_POINT_free_ptr
   668| #define EC_POINT_get_affine_coordinates_GFp EC_POINT_get_affine_coordinates_GFp_ptr
   669| #define EC_POINT_mul EC_POINT_mul_ptr
   670| #define EC_POINT_new EC_POINT_new_ptr
   671| #define EC_POINT_set_affine_coordinates_GFp EC_POINT_set_affine_coordinates_GFp_ptr
   672| #define ERR_clear_error ERR_clear_error_ptr
   673| #define ERR_error_string_n ERR_error_string_n_ptr
   674| #define ERR_get_error ERR_get_error_ptr
   675| #define ERR_load_crypto_strings ERR_load_crypto_strings_ptr
   676| #define ERR_new ERR_new_ptr
   677| #define ERR_peek_error ERR_peek_error_ptr
   678| #define ERR_peek_error_line ERR_peek_error_line_ptr
   679| #define ERR_peek_last_error ERR_peek_last_error_ptr
   680| #define ERR_put_error ERR_put_error_ptr
   681| #define ERR_reason_error_string ERR_reason_error_string_ptr
   682| #define ERR_set_debug ERR_set_debug_ptr
   683| #define ERR_set_error ERR_set_error_ptr
   684| #define EVP_aes_128_cbc EVP_aes_128_cbc_ptr
   685| #define EVP_aes_128_cfb8 EVP_aes_128_cfb8_ptr
   686| #define EVP_aes_128_cfb128 EVP_aes_128_cfb128_ptr
   687| #define EVP_aes_128_ecb EVP_aes_128_ecb_ptr
   688| #define EVP_aes_128_gcm EVP_aes_128_gcm_ptr
   689| #define EVP_aes_128_ccm EVP_aes_128_ccm_ptr
   690| #define EVP_aes_192_cbc EVP_aes_192_cbc_ptr
   691| #define EVP_aes_192_cfb8 EVP_aes_192_cfb8_ptr
   692| #define EVP_aes_192_cfb128 EVP_aes_192_cfb128_ptr
   693| #define EVP_aes_192_ecb EVP_aes_192_ecb_ptr
   694| #define EVP_aes_192_gcm EVP_aes_192_gcm_ptr
   695| #define EVP_aes_192_ccm EVP_aes_192_ccm_ptr
   696| #define EVP_aes_256_cbc EVP_aes_256_cbc_ptr
   697| #define EVP_aes_256_cfb8 EVP_aes_256_cfb8_ptr
   698| #define EVP_aes_256_cfb128 EVP_aes_256_cfb128_ptr


# ====================================================================
# FILE: src/libraries/Native/Unix/System.Security.Cryptography.Native/pal_evp_pkey.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 96-159 ---
    96|     return key;
    97| }
    98| EVP_PKEY* CryptoNative_DecodePkcs8PrivateKey(const uint8_t* buf, int32_t len, int32_t algId)
    99| {
   100|     assert(buf != NULL);
   101|     assert(len > 0);
   102|     PKCS8_PRIV_KEY_INFO* p8info = d2i_PKCS8_PRIV_KEY_INFO(NULL, &buf, len);
   103|     if (p8info == NULL)
   104|     {
   105|         return NULL;
   106|     }
   107|     EVP_PKEY* key = EVP_PKCS82PKEY(p8info);
   108|     PKCS8_PRIV_KEY_INFO_free(p8info);
   109|     if (key != NULL && !CheckKey(key, algId, EVP_PKEY_check))
   110|     {
   111|         EVP_PKEY_free(key);
   112|         key = NULL;
   113|     }
   114|     return key;
   115| }
   116| int32_t CryptoNative_GetPkcs8PrivateKeySize(EVP_PKEY* pkey, int32_t* p8size)
   117| {
   118|     assert(pkey != NULL);
   119|     assert(p8size != NULL);
   120|     *p8size = 0;
   121|     ERR_clear_error();
   122|     PKCS8_PRIV_KEY_INFO* p8 = EVP_PKEY2PKCS8(pkey);
   123|     if (p8 == NULL)
   124|     {
   125|         const char* file = NULL;
   126|         int line = 0;
   127|         unsigned long error = ERR_peek_error_line(&file, &line);
   128|         if (ERR_GET_REASON(error) != ERR_R_MALLOC_FAILURE)
   129|         {
   130|             ERR_clear_error();
   131|             return -2;
   132|         }
   133|         ERR_clear_error();
   134|         ERR_put_error(ERR_GET_LIB(error), 0, ERR_R_MALLOC_FAILURE, file, line);
   135|         return -1;
   136|     }
   137|     *p8size = i2d_PKCS8_PRIV_KEY_INFO(p8, NULL);
   138|     PKCS8_PRIV_KEY_INFO_free(p8);
   139|     return *p8size < 0 ? -1 : 1;
   140| }
   141| int32_t CryptoNative_EncodePkcs8PrivateKey(EVP_PKEY* pkey, uint8_t* buf)
   142| {
   143|     assert(pkey != NULL);
   144|     assert(buf != NULL);
   145|     PKCS8_PRIV_KEY_INFO* p8 = EVP_PKEY2PKCS8(pkey);
   146|     if (p8 == NULL)
   147|     {
   148|         return -1;
   149|     }
   150|     int ret = i2d_PKCS8_PRIV_KEY_INFO(p8, &buf);
   151|     PKCS8_PRIV_KEY_INFO_free(p8);
   152|     return ret;
   153| }
   154| int32_t CryptoNative_GetSubjectPublicKeyInfoSize(EVP_PKEY* pkey)
   155| {
   156|     assert(pkey != NULL);
   157|     return i2d_PUBKEY(pkey, NULL);
   158| }
   159| int32_t CryptoNative_EncodeSubjectPublicKeyInfo(EVP_PKEY* pkey, uint8_t* buf)


# ====================================================================
# FILE: src/libraries/Native/Unix/System.Security.Cryptography.Native/pal_evp_pkey.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 24-65 ---
    24| */
    25| PALEXPORT int32_t CryptoNative_EvpPKeySize(EVP_PKEY* pkey);
    26| /*
    27| Used by System.Security.Cryptography.X509Certificates' OpenSslX509CertificateReader when
    28| duplicating a private key context as part of duplicating the Pal object.
    29| Returns the number (as of this call) of references to the EVP_PKEY. Anything less than
    30| 2 is an error, because the key is already in the process of being freed.
    31| */
    32| PALEXPORT int32_t CryptoNative_UpRefEvpPkey(EVP_PKEY* pkey);
    33| /*
    34| Decodes an X.509 SubjectPublicKeyInfo into an EVP_PKEY*, verifying the interpreted algorithm type.
    35| Requres a non-null buf, and len > 0.
    36| */
    37| PALEXPORT EVP_PKEY* CryptoNative_DecodeSubjectPublicKeyInfo(const uint8_t* buf, int32_t len, int32_t algId);
    38| /*
    39| Decodes an Pkcs8PrivateKeyInfo into an EVP_PKEY*, verifying the interpreted algorithm type.
    40| Requres a non-null buf, and len > 0.
    41| */
    42| PALEXPORT EVP_PKEY* CryptoNative_DecodePkcs8PrivateKey(const uint8_t* buf, int32_t len, int32_t algId);
    43| /*
    44| Gets the number of bytes rqeuired to encode an EVP_PKEY* as a Pkcs8PrivateKeyInfo.
    45| On success, 1 is returned and p8size contains the size of the Pkcs8PrivateKeyInfo.
    46| On failure, -1 is used to indicate the openssl error queue contains the error.
    47| On failure, -2 is used to indcate that the supplied EVP_PKEY* is possibly missing a private key.
    48| */
    49| PALEXPORT int32_t CryptoNative_GetPkcs8PrivateKeySize(EVP_PKEY* pkey, int32_t* p8size);
    50| /*
    51| Encodes the EVP_PKEY* as a Pkcs8PrivateKeyInfo, writing the encoded value to buf.
    52| buf must be big enough, or an out of bounds write may occur.
    53| Returns the number of bytes written.
    54| */
    55| PALEXPORT int32_t CryptoNative_EncodePkcs8PrivateKey(EVP_PKEY* pkey, uint8_t* buf);
    56| /*
    57| Reports the number of bytes rqeuired to encode an EVP_PKEY* as an X.509 SubjectPublicKeyInfo, or a negative value on error.
    58| */
    59| PALEXPORT int32_t CryptoNative_GetSubjectPublicKeyInfoSize(EVP_PKEY* pkey);
    60| /*
    61| Encodes the EVP_PKEY* as an X.509 SubjectPublicKeyInfo, writing the encoded value to buf.
    62| buf must be big enough, or an out of bounds write may occur.
    63| Returns the number of bytes written.
    64| */
    65| PALEXPORT int32_t CryptoNative_EncodeSubjectPublicKeyInfo(EVP_PKEY* pkey, uint8_t* buf);


# ====================================================================
# FILE: src/libraries/System.Diagnostics.Process/ref/System.Diagnostics.Process.cs
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 20-174 ---
    20|     {
    21|         public MonitoringDescriptionAttribute(string description) { }
    22|         public override string Description { get { throw null; } }
    23|     }
    24|     [System.ComponentModel.DesignerAttribute("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
    25|     public partial class Process : System.ComponentModel.Component, System.IDisposable
    26|     {
    27|         public Process() { }
    28|         public int BasePriority { get { throw null; } }
    29|         public bool EnableRaisingEvents { get { throw null; } set { } }
    30|         public int ExitCode { get { throw null; } }
    31|         public System.DateTime ExitTime { get { throw null; } }
    32|         public System.IntPtr Handle { get { throw null; } }
    33|         public int HandleCount { get { throw null; } }
    34|         public bool HasExited { get { throw null; } }
    35|         public int Id { get { throw null; } }
    36|         public string MachineName { get { throw null; } }
    37|         public System.Diagnostics.ProcessModule? MainModule { get { throw null; } }
    38|         public System.IntPtr MainWindowHandle { get { throw null; } }
    39|         public string MainWindowTitle { get { throw null; } }
    40|         public System.IntPtr MaxWorkingSet { [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios"), System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos"), System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")] get { throw null; } [System.Runtime.Versioning.SupportedOSPlatformAttribute("freebsd"), System.Runtime.Versioning.SupportedOSPlatformAttribute("macos"), System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst"), System.Runtime.Versioning.SupportedOSPlatformAttribute("windows")] set { } }
    41|         public System.IntPtr MinWorkingSet { [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios"), System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos"), System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")] get { throw null; } [System.Runtime.Versioning.SupportedOSPlatformAttribute("freebsd"), System.Runtime.Versioning.SupportedOSPlatformAttribute("macos"), System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst"), System.Runtime.Versioning.SupportedOSPlatformAttribute("windows")] set { } }
    42|         public System.Diagnostics.ProcessModuleCollection Modules { get { throw null; } }
    43|         [System.ObsoleteAttribute("Process.NonpagedSystemMemorySize has been deprecated because the type of the property can't represent all valid results. Use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.")]
    44|         public int NonpagedSystemMemorySize { get { throw null; } }
    45|         public long NonpagedSystemMemorySize64 { get { throw null; } }
    46|         [System.ObsoleteAttribute("Process.PagedMemorySize has been deprecated because the type of the property can't represent all valid results. Use System.Diagnostics.Process.PagedMemorySize64 instead.")]
    47|         public int PagedMemorySize { get { throw null; } }
    48|         public long PagedMemorySize64 { get { throw null; } }
    49|         [System.ObsoleteAttribute("Process.PagedSystemMemorySize has been deprecated because the type of the property can't represent all valid results. Use System.Diagnostics.Process.PagedSystemMemorySize64 instead.")]
    50|         public int PagedSystemMemorySize { get { throw null; } }
    51|         public long PagedSystemMemorySize64 { get { throw null; } }
    52|         [System.ObsoleteAttribute("Process.PeakPagedMemorySize has been deprecated because the type of the property can't represent all valid results. Use System.Diagnostics.Process.PeakPagedMemorySize64 instead.")]
    53|         public int PeakPagedMemorySize { get { throw null; } }
    54|         public long PeakPagedMemorySize64 { get { throw null; } }
    55|         [System.ObsoleteAttribute("Process.PeakVirtualMemorySize has been deprecated because the type of the property can't represent all valid results. Use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.")]
    56|         public int PeakVirtualMemorySize { get { throw null; } }
    57|         public long PeakVirtualMemorySize64 { get { throw null; } }
    58|         [System.ObsoleteAttribute("Process.PeakWorkingSet has been deprecated because the type of the property can't represent all valid results. Use System.Diagnostics.Process.PeakWorkingSet64 instead.")]
    59|         public int PeakWorkingSet { get { throw null; } }
    60|         public long PeakWorkingSet64 { get { throw null; } }
    61|         public bool PriorityBoostEnabled { get { throw null; } set { } }
    62|         public System.Diagnostics.ProcessPriorityClass PriorityClass { get { throw null; } set { } }
    63|         [System.ObsoleteAttribute("Process.PrivateMemorySize has been deprecated because the type of the property can't represent all valid results. Use System.Diagnostics.Process.PrivateMemorySize64 instead.")]
    64|         public int PrivateMemorySize { get { throw null; } }
    65|         public long PrivateMemorySize64 { get { throw null; } }
    66|         public System.TimeSpan PrivilegedProcessorTime { get { throw null; } }
    67|         public string ProcessName { get { throw null; } }
    68|         [System.Runtime.Versioning.SupportedOSPlatform("windows")]
    69|         [System.Runtime.Versioning.SupportedOSPlatform("linux")]
    70|         public System.IntPtr ProcessorAffinity { get { throw null; } set { } }
    71|         public bool Responding { get { throw null; } }
    72|         public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get { throw null; } }
    73|         public int SessionId { get { throw null; } }
    74|         public System.IO.StreamReader StandardError { get { throw null; } }
    75|         public System.IO.StreamWriter StandardInput { get { throw null; } }
    76|         public System.IO.StreamReader StandardOutput { get { throw null; } }
    77|         public System.Diagnostics.ProcessStartInfo StartInfo { get { throw null; } set { } }
    78|         public System.DateTime StartTime { get { throw null; } }
    79|         public System.ComponentModel.ISynchronizeInvoke? SynchronizingObject { get { throw null; } set { } }
    80|         public System.Diagnostics.ProcessThreadCollection Threads { get { throw null; } }
    81|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
    82|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
    83|         [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
    84|         public System.TimeSpan TotalProcessorTime { get { throw null; } }
    85|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
    86|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
    87|         [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
    88|         public System.TimeSpan UserProcessorTime { get { throw null; } }
    89|         [System.ObsoleteAttribute("Process.VirtualMemorySize has been deprecated because the type of the property can't represent all valid results. Use System.Diagnostics.Process.VirtualMemorySize64 instead.")]
    90|         public int VirtualMemorySize { get { throw null; } }
    91|         public long VirtualMemorySize64 { get { throw null; } }
    92|         [System.ObsoleteAttribute("Process.WorkingSet has been deprecated because the type of the property can't represent all valid results. Use System.Diagnostics.Process.WorkingSet64 instead.")]
    93|         public int WorkingSet { get { throw null; } }
    94|         public long WorkingSet64 { get { throw null; } }
    95|         public event System.Diagnostics.DataReceivedEventHandler? ErrorDataReceived { add { } remove { } }
    96|         public event System.EventHandler Exited { add { } remove { } }
    97|         public event System.Diagnostics.DataReceivedEventHandler? OutputDataReceived { add { } remove { } }
    98|         public void BeginErrorReadLine() { }
    99|         public void BeginOutputReadLine() { }
   100|         public void CancelErrorRead() { }
   101|         public void CancelOutputRead() { }
   102|         public void Close() { }
   103|         public bool CloseMainWindow() { throw null; }
   104|         protected override void Dispose(bool disposing) { }
   105|         public static void EnterDebugMode() { }
   106|         public static System.Diagnostics.Process GetCurrentProcess() { throw null; }
   107|         public static System.Diagnostics.Process GetProcessById(int processId) { throw null; }
   108|         public static System.Diagnostics.Process GetProcessById(int processId, string machineName) { throw null; }
   109|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
   110|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
   111|         [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
   112|         public static System.Diagnostics.Process[] GetProcesses() { throw null; }
   113|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
   114|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
   115|         [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
   116|         public static System.Diagnostics.Process[] GetProcesses(string machineName) { throw null; }
   117|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
   118|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
   119|         [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
   120|         public static System.Diagnostics.Process[] GetProcessesByName(string? processName) { throw null; }
   121|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
   122|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
   123|         [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
   124|         public static System.Diagnostics.Process[] GetProcessesByName(string? processName, string machineName) { throw null; }
   125|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
   126|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
   127|         [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
   128|         public void Kill() { }
   129|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
   130|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
   131|         [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
   132|         public void Kill(bool entireProcessTree) { }
   133|         public static void LeaveDebugMode() { }
   134|         protected void OnExited() { }
   135|         public void Refresh() { }
   136|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
   137|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
   138|         [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
   139|         public bool Start() { throw null; }
   140|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
   141|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
   142|         [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
   143|         public static System.Diagnostics.Process? Start(System.Diagnostics.ProcessStartInfo startInfo) { throw null; }
   144|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
   145|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
   146|         [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
   147|         public static System.Diagnostics.Process Start(string fileName) { throw null; }
   148|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
   149|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
   150|         [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
   151|         public static System.Diagnostics.Process Start(string fileName, string arguments) { throw null; }
   152|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
   153|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
   154|         [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
   155|         public static System.Diagnostics.Process Start(string fileName, System.Collections.Generic.IEnumerable<string> arguments) { throw null; }
   156|         [System.CLSCompliantAttribute(false)]
   157|         [System.Runtime.Versioning.SupportedOSPlatformAttribute("windows")]
   158|         public static System.Diagnostics.Process? Start(string fileName, string userName, System.Security.SecureString password, string domain) { throw null; }
   159|         [System.CLSCompliantAttribute(false)]
   160|         [System.Runtime.Versioning.SupportedOSPlatformAttribute("windows")]
   161|         public static System.Diagnostics.Process? Start(string fileName, string arguments, string userName, System.Security.SecureString password, string domain) { throw null; }
   162|         public override string ToString() { throw null; }
   163|         public void WaitForExit() { }
   164|         public bool WaitForExit(int milliseconds) { throw null; }
   165|         public System.Threading.Tasks.Task WaitForExitAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
   166|         public bool WaitForInputIdle() { throw null; }
   167|         public bool WaitForInputIdle(int milliseconds) { throw null; }
   168|     }
   169|     [System.ComponentModel.DesignerAttribute("System.Diagnostics.Design.ProcessModuleDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
   170|     public partial class ProcessModule : System.ComponentModel.Component
   171|     {
   172|         internal ProcessModule() { }
   173|         public System.IntPtr BaseAddress { get { throw null; } }
   174|         public System.IntPtr EntryPointAddress { get { throw null; } }

# --- HUNK 2: Lines 235-292 ---
   235|         [System.ComponentModel.DefaultValueAttribute("")]
   236|         [System.Diagnostics.CodeAnalysis.AllowNullAttribute]
   237|         public string Verb { get { throw null; } set { } }
   238|         public string[] Verbs { get { throw null; } }
   239|         [System.ComponentModel.DefaultValueAttribute(System.Diagnostics.ProcessWindowStyle.Normal)]
   240|         public System.Diagnostics.ProcessWindowStyle WindowStyle { get { throw null; } set { } }
   241|         [System.ComponentModel.EditorAttribute("System.Diagnostics.Design.WorkingDirectoryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
   242|         [System.Diagnostics.CodeAnalysis.AllowNullAttribute]
   243|         public string WorkingDirectory { get { throw null; } set { } }
   244|     }
   245|     [System.ComponentModel.DesignerAttribute("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
   246|     public partial class ProcessThread : System.ComponentModel.Component
   247|     {
   248|         internal ProcessThread() { }
   249|         public int BasePriority { get { throw null; } }
   250|         public int CurrentPriority { get { throw null; } }
   251|         public int Id { get { throw null; } }
   252|         public int IdealProcessor { set { } }
   253|         public bool PriorityBoostEnabled { get { throw null; } set { } }
   254|         public System.Diagnostics.ThreadPriorityLevel PriorityLevel { [System.Runtime.Versioning.SupportedOSPlatform("windows")] [System.Runtime.Versioning.SupportedOSPlatform("linux")] [System.Runtime.Versioning.SupportedOSPlatform("freebsd")] get { throw null; } [System.Runtime.Versioning.SupportedOSPlatformAttribute("windows")] set { } }
   255|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
   256|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
   257|         [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
   258|         public System.TimeSpan PrivilegedProcessorTime { get { throw null; } }
   259|         [System.Runtime.Versioning.SupportedOSPlatformAttribute("windows")]
   260|         public System.IntPtr ProcessorAffinity { set { } }
   261|         public System.IntPtr StartAddress { get { throw null; } }
   262|         [System.Runtime.Versioning.SupportedOSPlatform("windows")]
   263|         [System.Runtime.Versioning.SupportedOSPlatform("linux")]
   264|         public System.DateTime StartTime { get { throw null; } }
   265|         public System.Diagnostics.ThreadState ThreadState { get { throw null; } }
   266|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
   267|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
   268|         [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
   269|         public System.TimeSpan TotalProcessorTime { get { throw null; } }
   270|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
   271|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
   272|         [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
   273|         public System.TimeSpan UserProcessorTime { get { throw null; } }
   274|         public System.Diagnostics.ThreadWaitReason WaitReason { get { throw null; } }
   275|         public void ResetIdealProcessor() { }
   276|     }
   277|     public partial class ProcessThreadCollection : System.Collections.ReadOnlyCollectionBase
   278|     {
   279|         protected ProcessThreadCollection() { }
   280|         public ProcessThreadCollection(System.Diagnostics.ProcessThread[] processThreads) { }
   281|         public System.Diagnostics.ProcessThread this[int index] { get { throw null; } }
   282|         public int Add(System.Diagnostics.ProcessThread thread) { throw null; }
   283|         public bool Contains(System.Diagnostics.ProcessThread thread) { throw null; }
   284|         public void CopyTo(System.Diagnostics.ProcessThread[] array, int index) { }
   285|         public int IndexOf(System.Diagnostics.ProcessThread thread) { throw null; }
   286|         public void Insert(int index, System.Diagnostics.ProcessThread thread) { }
   287|         public void Remove(System.Diagnostics.ProcessThread thread) { }
   288|     }
   289|     public enum ProcessWindowStyle
   290|     {
   291|         Normal = 0,
   292|         Hidden = 1,


# ====================================================================
# FILE: src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.BSD.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-30 ---
     1| using System.Collections.Generic;
     2| using System.ComponentModel;
     3| using System.Runtime.Versioning;
     4| namespace System.Diagnostics
     5| {
     6|     public partial class Process
     7|     {
     8|         [UnsupportedOSPlatform("ios")]
     9|         [UnsupportedOSPlatform("tvos")]
    10|         [SupportedOSPlatform("maccatalyst")]
    11|         public static Process[] GetProcessesByName(string? processName, string machineName)
    12|         {
    13|             if (processName == null)
    14|             {
    15|                 processName = string.Empty;
    16|             }
    17|             Process[] procs = GetProcesses(machineName);
    18|             var list = new List<Process>();
    19|             for (int i = 0; i < procs.Length; i++)
    20|             {
    21|                 if (string.Equals(processName, procs[i].ProcessName, StringComparison.OrdinalIgnoreCase))
    22|                 {
    23|                     list.Add(procs[i]);
    24|                 }
    25|                 else
    26|                 {
    27|                     procs[i].Dispose();
    28|                 }
    29|             }
    30|             return list.ToArray();


# ====================================================================
# FILE: src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.Linux.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-35 ---
     1| using System;
     2| using System.Buffers;
     3| using System.Collections.Generic;
     4| using System.ComponentModel;
     5| using System.Globalization;
     6| using System.IO;
     7| using System.Runtime.Versioning;
     8| using System.Text;
     9| namespace System.Diagnostics
    10| {
    11|     public partial class Process : IDisposable
    12|     {
    13|         [UnsupportedOSPlatform("ios")]
    14|         [UnsupportedOSPlatform("tvos")]
    15|         [SupportedOSPlatform("maccatalyst")]
    16|         public static Process[] GetProcessesByName(string? processName, string machineName)
    17|         {
    18|             ProcessManager.ThrowIfRemoteMachine(machineName);
    19|             if (processName == null)
    20|             {
    21|                 processName = string.Empty;
    22|             }
    23|             var processes = new List<Process>();
    24|             foreach (int pid in ProcessManager.EnumerateProcessIds())
    25|             {
    26|                 if (Interop.procfs.TryReadStatFile(pid, out Interop.procfs.ParsedStat parsedStat) &&
    27|                     string.Equals(processName, Process.GetUntruncatedProcessName(ref parsedStat), StringComparison.OrdinalIgnoreCase) &&
    28|                     Interop.procfs.TryReadStatusFile(pid, out Interop.procfs.ParsedStatus parsedStatus))
    29|                 {
    30|                     ProcessInfo processInfo = ProcessManager.CreateProcessInfo(ref parsedStat, ref parsedStatus, processName);
    31|                     processes.Add(new Process(machineName, false, processInfo.ProcessId, processInfo));
    32|                 }
    33|             }
    34|             return processes.ToArray();
    35|         }


# ====================================================================
# FILE: src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.NonUap.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-30 ---
     1| using System.Collections.Generic;
     2| using System.ComponentModel;
     3| using System.Runtime.Versioning;
     4| namespace System.Diagnostics
     5| {
     6|     public partial class Process : IDisposable
     7|     {
     8|         [UnsupportedOSPlatform("ios")]
     9|         [UnsupportedOSPlatform("tvos")]
    10|         [SupportedOSPlatform("maccatalyst")]
    11|         public void Kill(bool entireProcessTree)
    12|         {
    13|             if (!entireProcessTree)
    14|             {
    15|                 Kill();
    16|             }
    17|             else
    18|             {
    19|                 EnsureState(State.Associated | State.IsLocal);
    20|                 if (IsSelfOrDescendantOf(GetCurrentProcess()))
    21|                     throw new InvalidOperationException(SR.KillEntireProcessTree_DisallowedBecauseTreeContainsCallingProcess);
    22|                 List<Exception>? result = KillTree();
    23|                 if (result != null && result.Count != 0)
    24|                     throw new AggregateException(SR.KillEntireProcessTree_TerminationIncomplete, result);
    25|             }
    26|         }
    27|         private bool IsSelfOrDescendantOf(Process processOfInterest)
    28|         {
    29|             if (Equals(processOfInterest))
    30|                 return true;


# ====================================================================
# FILE: src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.Unix.cs
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 21-64 ---
    21|         public static void EnterDebugMode()
    22|         {
    23|         }
    24|         public static void LeaveDebugMode()
    25|         {
    26|         }
    27|         [CLSCompliant(false)]
    28|         [SupportedOSPlatform("windows")]
    29|         public static Process Start(string fileName, string userName, SecureString password, string domain)
    30|         {
    31|             throw new PlatformNotSupportedException(SR.ProcessStartWithPasswordAndDomainNotSupported);
    32|         }
    33|         [CLSCompliant(false)]
    34|         [SupportedOSPlatform("windows")]
    35|         public static Process Start(string fileName, string arguments, string userName, SecureString password, string domain)
    36|         {
    37|             throw new PlatformNotSupportedException(SR.ProcessStartWithPasswordAndDomainNotSupported);
    38|         }
    39|         [UnsupportedOSPlatform("ios")]
    40|         [UnsupportedOSPlatform("tvos")]
    41|         [SupportedOSPlatform("maccatalyst")]
    42|         public void Kill()
    43|         {
    44|             if (PlatformDoesNotSupportProcessStartAndKill)
    45|             {
    46|                 throw new PlatformNotSupportedException();
    47|             }
    48|             EnsureState(State.HaveId);
    49|             if (GetHasExited(refresh: false))
    50|             {
    51|                 return;
    52|             }
    53|             int killResult = Interop.Sys.Kill(_processId, Interop.Sys.Signals.SIGKILL);
    54|             if (killResult != 0)
    55|             {
    56|                 Interop.Error error = Interop.Sys.GetLastError();
    57|                 if (error == Interop.Error.ESRCH)
    58|                 {
    59|                     return;
    60|                 }
    61|                 throw new Win32Exception(); // same exception as on Windows
    62|             }
    63|         }
    64|         private bool GetHasExited(bool refresh)

# --- HUNK 2: Lines 253-293 ---
   253|             {
   254|                 return;
   255|             }
   256|             if (GetHasExited(refresh))
   257|             {
   258|                 throw new InvalidOperationException(SR.Format(SR.ProcessHasExited, _processId.ToString()));
   259|             }
   260|         }
   261|         private SafeProcessHandle GetProcessHandle()
   262|         {
   263|             if (_haveProcessHandle)
   264|             {
   265|                 ThrowIfExited(refresh: true);
   266|                 return _processHandle!;
   267|             }
   268|             EnsureState(State.HaveNonExitedId | State.IsLocal);
   269|             return new SafeProcessHandle(_processId, GetSafeWaitHandle());
   270|         }
   271|         private bool StartCore(ProcessStartInfo startInfo)
   272|         {
   273|             if (PlatformDoesNotSupportProcessStartAndKill)
   274|             {
   275|                 throw new PlatformNotSupportedException();
   276|             }
   277|             EnsureInitialized();
   278|             string? filename;
   279|             string[] argv;
   280|             if (startInfo.UseShellExecute)
   281|             {
   282|                 if (startInfo.RedirectStandardInput || startInfo.RedirectStandardOutput || startInfo.RedirectStandardError)
   283|                 {
   284|                     throw new InvalidOperationException(SR.CantRedirectStreams);
   285|                 }
   286|             }
   287|             int stdinFd = -1, stdoutFd = -1, stderrFd = -1;
   288|             string[] envp = CreateEnvp(startInfo);
   289|             string? cwd = !string.IsNullOrWhiteSpace(startInfo.WorkingDirectory) ? startInfo.WorkingDirectory : null;
   290|             bool setCredentials = !string.IsNullOrEmpty(startInfo.UserName);
   291|             uint userId = 0;
   292|             uint groupId = 0;
   293|             uint[]? groups = null;

# --- HUNK 3: Lines 768-791 ---
   768|                     s_initialized = true;
   769|                 }
   770|             }
   771|         }
   772|         [UnmanagedCallersOnly]
   773|         private static int OnSigChild(int reapAll, int configureConsole)
   774|         {
   775|             s_processStartLock.EnterWriteLock();
   776|             try
   777|             {
   778|                 bool childrenUsingTerminalPre = AreChildrenUsingTerminal;
   779|                 ProcessWaitState.CheckChildren(reapAll != 0, configureConsole != 0);
   780|                 bool childrenUsingTerminalPost = AreChildrenUsingTerminal;
   781|                 return childrenUsingTerminalPre && !childrenUsingTerminalPost && configureConsole == 0 ? 1 : 0;
   782|             }
   783|             finally
   784|             {
   785|                 s_processStartLock.ExitWriteLock();
   786|             }
   787|         }
   788|         private static bool PlatformDoesNotSupportProcessStartAndKill
   789|             => (OperatingSystem.IsIOS() && !OperatingSystem.IsMacCatalyst()) || OperatingSystem.IsTvOS();
   790|     }
   791| }


# ====================================================================
# FILE: src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.UnknownUnix.cs
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-49 ---
     1| namespace System.Diagnostics
     2| {
     3|     public partial class Process : IDisposable
     4|     {
     5|         [UnsupportedOSPlatform("ios")]
     6|         [UnsupportedOSPlatform("tvos")]
     7|         [SupportedOSPlatform("maccatalyst")]
     8|         public static Process[] GetProcessesByName(string? processName, string machineName)
     9|         {
    10|             throw new PlatformNotSupportedException();
    11|         }
    12|         public TimeSpan PrivilegedProcessorTime
    13|         {
    14|             get { throw new PlatformNotSupportedException(); }
    15|         }
    16|         internal DateTime StartTimeCore
    17|         {
    18|             get { throw new PlatformNotSupportedException(); }
    19|         }
    20|         public TimeSpan TotalProcessorTime
    21|         {
    22|             get { throw new PlatformNotSupportedException(); }
    23|         }
    24|         public TimeSpan UserProcessorTime
    25|         {
    26|             get { throw new PlatformNotSupportedException(); }
    27|         }
    28|         private int GetParentProcessId =>
    29|             throw new PlatformNotSupportedException();
    30|         private IntPtr ProcessorAffinityCore
    31|         {
    32|             get { throw new PlatformNotSupportedException(); }
    33|             set { throw new PlatformNotSupportedException(); }
    34|         }
    35|         private void GetWorkingSetLimits(out IntPtr minWorkingSet, out IntPtr maxWorkingSet)
    36|         {
    37|             throw new PlatformNotSupportedException();
    38|         }
    39|         private void SetWorkingSetLimitsCore(IntPtr? newMin, IntPtr? newMax, out IntPtr resultingMin, out IntPtr resultingMax)
    40|         {
    41|             throw new PlatformNotSupportedException();
    42|         }
    43|         private string GetPathToOpenFile()
    44|         {
    45|             throw new PlatformNotSupportedException();
    46|         }
    47|         private int ParentProcessId => throw new PlatformNotSupportedException();
    48|     }
    49| }


# ====================================================================
# FILE: src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.Windows.cs
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| using Microsoft.Win32.SafeHandles;
     2| using System.Collections.Generic;
     3| using System.ComponentModel;
     4| using System.IO;
     5| using System.Runtime.InteropServices;
     6| using System.Runtime.Versioning;
     7| using System.Security;
     8| using System.Text;
     9| using System.Threading;
    10| namespace System.Diagnostics
    11| {
    12|     public partial class Process : IDisposable
    13|     {
    14|         private static readonly object s_createProcessLock = new object();
    15|         [UnsupportedOSPlatform("ios")]
    16|         [UnsupportedOSPlatform("tvos")]
    17|         [SupportedOSPlatform("maccatalyst")]
    18|         public static Process[] GetProcessesByName(string? processName, string machineName)
    19|         {
    20|             if (processName == null)
    21|             {
    22|                 processName = string.Empty;
    23|             }
    24|             Process[] procs = GetProcesses(machineName);
    25|             var list = new List<Process>();
    26|             for (int i = 0; i < procs.Length; i++)
    27|             {
    28|                 if (string.Equals(processName, procs[i].ProcessName, StringComparison.OrdinalIgnoreCase))
    29|                 {
    30|                     list.Add(procs[i]);
    31|                 }
    32|                 else
    33|                 {
    34|                     procs[i].Dispose();
    35|                 }
    36|             }
    37|             return list.ToArray();

# --- HUNK 2: Lines 51-91 ---
    51|         [SupportedOSPlatform("windows")]
    52|         public static Process? Start(string fileName, string arguments, string userName, SecureString password, string domain)
    53|         {
    54|             ProcessStartInfo startInfo = new ProcessStartInfo(fileName, arguments);
    55|             startInfo.UserName = userName;
    56|             startInfo.Password = password;
    57|             startInfo.Domain = domain;
    58|             startInfo.UseShellExecute = false;
    59|             return Start(startInfo);
    60|         }
    61|         public static void EnterDebugMode()
    62|         {
    63|             SetPrivilege(Interop.Advapi32.SeDebugPrivilege, (int)Interop.Advapi32.SEPrivileges.SE_PRIVILEGE_ENABLED);
    64|         }
    65|         public static void LeaveDebugMode()
    66|         {
    67|             SetPrivilege(Interop.Advapi32.SeDebugPrivilege, 0);
    68|         }
    69|         [UnsupportedOSPlatform("ios")]
    70|         [UnsupportedOSPlatform("tvos")]
    71|         [SupportedOSPlatform("maccatalyst")]
    72|         public void Kill()
    73|         {
    74|             using (SafeProcessHandle handle = GetProcessHandle(Interop.Advapi32.ProcessOptions.PROCESS_TERMINATE | Interop.Advapi32.ProcessOptions.PROCESS_QUERY_LIMITED_INFORMATION, throwIfExited: false))
    75|             {
    76|                 if (handle.IsInvalid)
    77|                     return;
    78|                 if (!Interop.Kernel32.TerminateProcess(handle, -1))
    79|                 {
    80|                     var exception = new Win32Exception();
    81|                     if (exception.NativeErrorCode == Interop.Errors.ERROR_ACCESS_DENIED &&
    82|                         Interop.Kernel32.GetExitCodeProcess(handle, out int localExitCode) && localExitCode != Interop.Kernel32.HandleOptions.STILL_ACTIVE)
    83|                     {
    84|                         return;
    85|                     }
    86|                     throw exception;
    87|                 }
    88|             }
    89|         }
    90|         private void RefreshCore()
    91|         {


# ====================================================================
# FILE: src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
# Total hunks: 5
# ====================================================================
# --- HUNK 1: Lines 107-149 ---
   107|                 EnsureState(State.Exited);
   108|                 return _exitCode;
   109|             }
   110|         }
   111|         public bool HasExited
   112|         {
   113|             get
   114|             {
   115|                 if (!_exited)
   116|                 {
   117|                     EnsureState(State.Associated);
   118|                     UpdateHasExited();
   119|                     if (_exited)
   120|                     {
   121|                         RaiseOnExited();
   122|                     }
   123|                 }
   124|                 return _exited;
   125|             }
   126|         }
   127|         [UnsupportedOSPlatform("ios")]
   128|         [UnsupportedOSPlatform("tvos")]
   129|         [SupportedOSPlatform("maccatalyst")]
   130|         public DateTime StartTime
   131|         {
   132|             get
   133|             {
   134|                 if (!_startTime.HasValue)
   135|                 {
   136|                     _startTime = StartTimeCore;
   137|                 }
   138|                 return _startTime.Value;
   139|             }
   140|         }
   141|         public DateTime ExitTime
   142|         {
   143|             get
   144|             {
   145|                 if (!_haveExitTime)
   146|                 {
   147|                     EnsureState(State.Exited);
   148|                     _exitTime = ExitTimeCore;
   149|                     _haveExitTime = true;

# --- HUNK 2: Lines 154-222 ---
   154|         public int Id
   155|         {
   156|             get
   157|             {
   158|                 EnsureState(State.HaveId);
   159|                 return _processId;
   160|             }
   161|         }
   162|         public string MachineName
   163|         {
   164|             get
   165|             {
   166|                 EnsureState(State.Associated);
   167|                 return _machineName;
   168|             }
   169|         }
   170|         public IntPtr MaxWorkingSet
   171|         {
   172|             [UnsupportedOSPlatform("ios")]
   173|             [UnsupportedOSPlatform("tvos")]
   174|             [SupportedOSPlatform("maccatalyst")]
   175|             get
   176|             {
   177|                 EnsureWorkingSetLimits();
   178|                 return _maxWorkingSet;
   179|             }
   180|             [SupportedOSPlatform("freebsd")]
   181|             [SupportedOSPlatform("macos")]
   182|             [SupportedOSPlatform("maccatalyst")]
   183|             [SupportedOSPlatform("windows")]
   184|             set
   185|             {
   186|                 SetWorkingSetLimits(null, value);
   187|             }
   188|         }
   189|         public IntPtr MinWorkingSet
   190|         {
   191|             [UnsupportedOSPlatform("ios")]
   192|             [UnsupportedOSPlatform("tvos")]
   193|             [SupportedOSPlatform("maccatalyst")]
   194|             get
   195|             {
   196|                 EnsureWorkingSetLimits();
   197|                 return _minWorkingSet;
   198|             }
   199|             [SupportedOSPlatform("freebsd")]
   200|             [SupportedOSPlatform("macos")]
   201|             [SupportedOSPlatform("maccatalyst")]
   202|             [SupportedOSPlatform("windows")]
   203|             set
   204|             {
   205|                 SetWorkingSetLimits(value, null);
   206|             }
   207|         }
   208|         public ProcessModuleCollection Modules
   209|         {
   210|             get
   211|             {
   212|                 if (_modules == null)
   213|                 {
   214|                     EnsureState(State.HaveNonExitedId | State.IsLocal);
   215|                     _modules = ProcessManager.GetModules(_processId);
   216|                 }
   217|                 return _modules;
   218|             }
   219|         }
   220|         public long NonpagedSystemMemorySize64
   221|         {
   222|             get

# --- HUNK 3: Lines 747-803 ---
   747|                 _haveWorkingSetLimits = true;
   748|             }
   749|         }
   750|         private void SetWorkingSetLimits(IntPtr? min, IntPtr? max)
   751|         {
   752|             SetWorkingSetLimitsCore(min, max, out _minWorkingSet, out _maxWorkingSet);
   753|             _haveWorkingSetLimits = true;
   754|         }
   755|         public static Process GetProcessById(int processId, string machineName)
   756|         {
   757|             if (!ProcessManager.IsProcessRunning(processId, machineName))
   758|             {
   759|                 throw new ArgumentException(SR.Format(SR.MissingProccess, processId.ToString()));
   760|             }
   761|             return new Process(machineName, ProcessManager.IsRemoteMachine(machineName), processId, null);
   762|         }
   763|         public static Process GetProcessById(int processId)
   764|         {
   765|             return GetProcessById(processId, ".");
   766|         }
   767|         [UnsupportedOSPlatform("ios")]
   768|         [UnsupportedOSPlatform("tvos")]
   769|         [SupportedOSPlatform("maccatalyst")]
   770|         public static Process[] GetProcessesByName(string? processName)
   771|         {
   772|             return GetProcessesByName(processName, ".");
   773|         }
   774|         [UnsupportedOSPlatform("ios")]
   775|         [UnsupportedOSPlatform("tvos")]
   776|         [SupportedOSPlatform("maccatalyst")]
   777|         public static Process[] GetProcesses()
   778|         {
   779|             return GetProcesses(".");
   780|         }
   781|         [UnsupportedOSPlatform("ios")]
   782|         [UnsupportedOSPlatform("tvos")]
   783|         [SupportedOSPlatform("maccatalyst")]
   784|         public static Process[] GetProcesses(string machineName)
   785|         {
   786|             bool isRemoteMachine = ProcessManager.IsRemoteMachine(machineName);
   787|             ProcessInfo[] processInfos = ProcessManager.GetProcessInfos(machineName);
   788|             Process[] processes = new Process[processInfos.Length];
   789|             for (int i = 0; i < processInfos.Length; i++)
   790|             {
   791|                 ProcessInfo processInfo = processInfos[i];
   792|                 processes[i] = new Process(machineName, isRemoteMachine, processInfo.ProcessId, processInfo);
   793|             }
   794|             return processes;
   795|         }
   796|         public static Process GetCurrentProcess()
   797|         {
   798|             return new Process(".", false, Environment.ProcessId, null);
   799|         }
   800|         protected void OnExited()
   801|         {
   802|             EventHandler? exited = _onExited;
   803|             if (exited != null)

# --- HUNK 4: Lines 851-952 ---
   851|             return _processHandle!;
   852|         }
   853|         private void SetProcessHandle(SafeProcessHandle processHandle)
   854|         {
   855|             _processHandle = processHandle;
   856|             _haveProcessHandle = true;
   857|             if (_watchForExit)
   858|             {
   859|                 EnsureWatchingForExit();
   860|             }
   861|         }
   862|         private void SetProcessId(int processId)
   863|         {
   864|             _processId = processId;
   865|             _haveProcessId = true;
   866|             ConfigureAfterProcessIdSet();
   867|         }
   868|         partial void ConfigureAfterProcessIdSet();
   869|         [UnsupportedOSPlatform("ios")]
   870|         [UnsupportedOSPlatform("tvos")]
   871|         [SupportedOSPlatform("maccatalyst")]
   872|         public bool Start()
   873|         {
   874|             Close();
   875|             ProcessStartInfo startInfo = StartInfo;
   876|             if (startInfo.FileName.Length == 0)
   877|             {
   878|                 throw new InvalidOperationException(SR.FileNameMissing);
   879|             }
   880|             if (startInfo.StandardInputEncoding != null && !startInfo.RedirectStandardInput)
   881|             {
   882|                 throw new InvalidOperationException(SR.StandardInputEncodingNotAllowed);
   883|             }
   884|             if (startInfo.StandardOutputEncoding != null && !startInfo.RedirectStandardOutput)
   885|             {
   886|                 throw new InvalidOperationException(SR.StandardOutputEncodingNotAllowed);
   887|             }
   888|             if (startInfo.StandardErrorEncoding != null && !startInfo.RedirectStandardError)
   889|             {
   890|                 throw new InvalidOperationException(SR.StandardErrorEncodingNotAllowed);
   891|             }
   892|             if (!string.IsNullOrEmpty(startInfo.Arguments) && startInfo.HasArgumentList)
   893|             {
   894|                 throw new InvalidOperationException(SR.ArgumentAndArgumentListInitialized);
   895|             }
   896|             CheckDisposed();
   897|             SerializationGuard.ThrowIfDeserializationInProgress("AllowProcessCreation", ref s_cachedSerializationSwitch);
   898|             return StartCore(startInfo);
   899|         }
   900|         [UnsupportedOSPlatform("ios")]
   901|         [UnsupportedOSPlatform("tvos")]
   902|         [SupportedOSPlatform("maccatalyst")]
   903|         public static Process Start(string fileName)
   904|         {
   905|             return Start(new ProcessStartInfo(fileName))!;
   906|         }
   907|         [UnsupportedOSPlatform("ios")]
   908|         [UnsupportedOSPlatform("tvos")]
   909|         [SupportedOSPlatform("maccatalyst")]
   910|         public static Process Start(string fileName, string arguments)
   911|         {
   912|             return Start(new ProcessStartInfo(fileName, arguments))!;
   913|         }
   914|         [UnsupportedOSPlatform("ios")]
   915|         [UnsupportedOSPlatform("tvos")]
   916|         [SupportedOSPlatform("maccatalyst")]
   917|         public static Process Start(string fileName, IEnumerable<string> arguments)
   918|         {
   919|             if (fileName == null)
   920|                 throw new ArgumentNullException(nameof(fileName));
   921|             if (arguments == null)
   922|                 throw new ArgumentNullException(nameof(arguments));
   923|             var startInfo = new ProcessStartInfo(fileName);
   924|             foreach (string argument in arguments)
   925|             {
   926|                 startInfo.ArgumentList.Add(argument);
   927|             }
   928|             return Start(startInfo)!;
   929|         }
   930|         [UnsupportedOSPlatform("ios")]
   931|         [UnsupportedOSPlatform("tvos")]
   932|         [SupportedOSPlatform("maccatalyst")]
   933|         public static Process? Start(ProcessStartInfo startInfo)
   934|         {
   935|             Process process = new Process();
   936|             if (startInfo == null)
   937|                 throw new ArgumentNullException(nameof(startInfo));
   938|             process.StartInfo = startInfo;
   939|             return process.Start() ?
   940|                 process :
   941|                 null;
   942|         }
   943|         private void StopWatchingForExit()
   944|         {
   945|             if (_watchingForExit)
   946|             {
   947|                 RegisteredWaitHandle? rwh = null;
   948|                 WaitHandle? wh = null;
   949|                 lock (this)
   950|                 {
   951|                     if (_watchingForExit)
   952|                     {


# ====================================================================
# FILE: src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.iOS.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-73 ---
     1| using System.Collections.Generic;
     2| using System.ComponentModel;
     3| using System.Runtime.Versioning;
     4| namespace System.Diagnostics
     5| {
     6|     public partial class Process : IDisposable
     7|     {
     8|         [UnsupportedOSPlatform("ios")]
     9|         [UnsupportedOSPlatform("tvos")]
    10|         [SupportedOSPlatform("maccatalyst")]
    11|         public void Kill(bool entireProcessTree)
    12|         {
    13|             throw new PlatformNotSupportedException();
    14|         }
    15|         [UnsupportedOSPlatform("ios")]
    16|         [UnsupportedOSPlatform("tvos")]
    17|         [SupportedOSPlatform("maccatalyst")]
    18|         public static Process[] GetProcessesByName(string? processName, string machineName)
    19|         {
    20|             throw new PlatformNotSupportedException();
    21|         }
    22|         [UnsupportedOSPlatform("ios")]
    23|         [UnsupportedOSPlatform("tvos")]
    24|         public TimeSpan PrivilegedProcessorTime
    25|         {
    26|             get { throw new PlatformNotSupportedException(); }
    27|         }
    28|         [UnsupportedOSPlatform("ios")]
    29|         [UnsupportedOSPlatform("tvos")]
    30|         internal DateTime StartTimeCore
    31|         {
    32|             get { throw new PlatformNotSupportedException(); }
    33|         }
    34|         [UnsupportedOSPlatform("ios")]
    35|         [UnsupportedOSPlatform("tvos")]
    36|         public TimeSpan TotalProcessorTime
    37|         {
    38|             get { throw new PlatformNotSupportedException(); }
    39|         }
    40|         [UnsupportedOSPlatform("ios")]
    41|         [UnsupportedOSPlatform("tvos")]
    42|         public TimeSpan UserProcessorTime
    43|         {
    44|             get { throw new PlatformNotSupportedException(); }
    45|         }
    46|         private IReadOnlyList<Process> GetChildProcesses(Process[]? processes = null)
    47|         {
    48|             throw new PlatformNotSupportedException();
    49|         }
    50|         private int GetParentProcessId =>
    51|             throw new PlatformNotSupportedException();
    52|         private IntPtr ProcessorAffinityCore
    53|         {
    54|             get { throw new PlatformNotSupportedException(); }
    55|             set { throw new PlatformNotSupportedException(); }
    56|         }
    57|         private void GetWorkingSetLimits(out IntPtr minWorkingSet, out IntPtr maxWorkingSet)
    58|         {
    59|             throw new PlatformNotSupportedException();
    60|         }
    61|         private void SetWorkingSetLimitsCore(IntPtr? newMin, IntPtr? newMax, out IntPtr resultingMin, out IntPtr resultingMax)
    62|         {
    63|             throw new PlatformNotSupportedException();
    64|         }
    65|         private string GetPathToOpenFile()
    66|         {
    67|             throw new PlatformNotSupportedException();
    68|         }
    69|         private int ParentProcessId => throw new PlatformNotSupportedException();
    70|         private static bool IsProcessInvalidException(Exception e) =>
    71|             e is InvalidOperationException || e is Win32Exception;
    72|     }
    73| }


# ====================================================================
# FILE: src/libraries/System.Diagnostics.Process/src/System/Diagnostics/ProcessManager.Unix.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-46 ---
     1| using Microsoft.Win32.SafeHandles;
     2| using System.Collections.Generic;
     3| using System.Runtime.Versioning;
     4| using System.Text;
     5| namespace System.Diagnostics
     6| {
     7|     internal static partial class ProcessManager
     8|     {
     9|         public static bool IsProcessRunning(int processId, string machineName)
    10|         {
    11|             ThrowIfRemoteMachine(machineName);
    12|             return IsProcessRunning(processId);
    13|         }
    14|         public static bool IsProcessRunning(int processId)
    15|         {
    16|             int output = Interop.Sys.Kill(processId, Interop.Sys.Signals.None);
    17|             return 0 == output || (-1 == output && Interop.Error.EPERM == Interop.Sys.GetLastError());
    18|         }
    19|         public static ProcessInfo? GetProcessInfo(int processId, string machineName)
    20|         {
    21|             ThrowIfRemoteMachine(machineName);
    22|             return CreateProcessInfo(processId);
    23|         }
    24|         [UnsupportedOSPlatform("ios")]
    25|         [UnsupportedOSPlatform("tvos")]
    26|         [SupportedOSPlatform("maccatalyst")]
    27|         public static int[] GetProcessIds(string machineName)
    28|         {
    29|             ThrowIfRemoteMachine(machineName);
    30|             return GetProcessIds();
    31|         }
    32|         public static int GetProcessIdFromHandle(SafeProcessHandle processHandle)
    33|         {
    34|             return processHandle.ProcessId;
    35|         }
    36|         private static bool IsRemoteMachineCore(string machineName)
    37|         {
    38|             return
    39|                 machineName != "." &&
    40|                 machineName != Interop.Sys.GetHostName();
    41|         }
    42|         internal static void ThrowIfRemoteMachine(string machineName)
    43|         {
    44|             if (IsRemoteMachine(machineName))
    45|             {
    46|                 throw new PlatformNotSupportedException(SR.RemoteMachinesNotSupported);


# ====================================================================
# FILE: src/libraries/System.Diagnostics.Process/src/System/Diagnostics/ProcessManager.iOS.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| using System.Runtime.Versioning;
     2| namespace System.Diagnostics
     3| {
     4|     internal static partial class ProcessManager
     5|     {
     6|         public static int[] GetProcessIds()
     7|         {
     8|             throw new PlatformNotSupportedException();
     9|         }
    10|         [UnsupportedOSPlatform("ios")]
    11|         [UnsupportedOSPlatform("tvos")]
    12|         public static ProcessInfo[] GetProcessInfos(string machineName)
    13|         {
    14|             throw new PlatformNotSupportedException();
    15|         }
    16|         internal static ProcessModuleCollection GetModules(int processId)
    17|         {
    18|             return new ProcessModuleCollection(0);
    19|         }
    20|         private static ProcessInfo CreateProcessInfo(int pid)
    21|         {
    22|             throw new PlatformNotSupportedException();
    23|         }
    24|     }
    25| }


# ====================================================================
# FILE: src/libraries/System.Diagnostics.Process/src/System/Diagnostics/ProcessThread.iOS.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-31 ---
     1| using System.Runtime.Versioning;
     2| namespace System.Diagnostics
     3| {
     4|     public partial class ProcessThread
     5|     {
     6|         private ThreadPriorityLevel PriorityLevelCore
     7|         {
     8|             get { throw new PlatformNotSupportedException(); }
     9|             set { throw new PlatformNotSupportedException(); }
    10|         }
    11|         [UnsupportedOSPlatform("ios")]
    12|         [UnsupportedOSPlatform("tvos")]
    13|         public TimeSpan PrivilegedProcessorTime
    14|         {
    15|             get { throw new PlatformNotSupportedException(); }
    16|         }
    17|         private DateTime GetStartTime() => throw new PlatformNotSupportedException();
    18|         [UnsupportedOSPlatform("ios")]
    19|         [UnsupportedOSPlatform("tvos")]
    20|         public TimeSpan TotalProcessorTime
    21|         {
    22|             get { throw new PlatformNotSupportedException(); }
    23|         }
    24|         [UnsupportedOSPlatform("ios")]
    25|         [UnsupportedOSPlatform("tvos")]
    26|         public TimeSpan UserProcessorTime
    27|         {
    28|             get { throw new PlatformNotSupportedException(); }
    29|         }
    30|     }
    31| }


# ====================================================================
# FILE: src/libraries/System.Diagnostics.Process/src/System/Diagnostics/ThreadInfo.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-15 ---
     1| namespace System.Diagnostics
     2| {
     3|     internal sealed class ThreadInfo
     4|     {
     5| #pragma warning disable CS0649 // The fields are unused on iOS/tvOS as the respective managed logic (mostly around libproc) is excluded.
     6|         internal ulong _threadId;
     7|         internal int _processId;
     8|         internal int _basePriority;
     9|         internal int _currentPriority;
    10|         internal IntPtr _startAddress;
    11|         internal ThreadState _threadState;
    12|         internal ThreadWaitReason _threadWaitReason;
    13| #pragma warning restore CS0649
    14|     }
    15| }


# ====================================================================
# FILE: src/libraries/System.IO.Compression.ZipFile/src/System/IO/Compression/ZipFileExtensions.ZipArchiveEntry.Extract.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 4-44 ---
     4|     {
     5|         public static void ExtractToFile(this ZipArchiveEntry source, string destinationFileName) =>
     6|             ExtractToFile(source, destinationFileName, false);
     7|         public static void ExtractToFile(this ZipArchiveEntry source, string destinationFileName, bool overwrite)
     8|         {
     9|             if (source == null)
    10|                 throw new ArgumentNullException(nameof(source));
    11|             if (destinationFileName == null)
    12|                 throw new ArgumentNullException(nameof(destinationFileName));
    13|             FileMode fMode = overwrite ? FileMode.Create : FileMode.CreateNew;
    14|             using (FileStream fs = new FileStream(destinationFileName, fMode, FileAccess.Write, FileShare.None, bufferSize: 0x1000, useAsync: false))
    15|             {
    16|                 using (Stream es = source.Open())
    17|                     es.CopyTo(fs);
    18|                 ExtractExternalAttributes(fs, source);
    19|             }
    20|             try
    21|             {
    22|                 File.SetLastWriteTime(destinationFileName, source.LastWriteTime.DateTime);
    23|             }
    24|             catch
    25|             {
    26|             }
    27|         }
    28|         static partial void ExtractExternalAttributes(FileStream fs, ZipArchiveEntry entry);
    29|         internal static void ExtractRelativeToDirectory(this ZipArchiveEntry source, string destinationDirectoryName) =>
    30|             ExtractRelativeToDirectory(source, destinationDirectoryName, overwrite: false);
    31|         internal static void ExtractRelativeToDirectory(this ZipArchiveEntry source, string destinationDirectoryName, bool overwrite)
    32|         {
    33|             if (source == null)
    34|                 throw new ArgumentNullException(nameof(source));
    35|             if (destinationDirectoryName == null)
    36|                 throw new ArgumentNullException(nameof(destinationDirectoryName));
    37|             DirectoryInfo di = Directory.CreateDirectory(destinationDirectoryName);
    38|             string destinationDirectoryFullPath = di.FullName;
    39|             if (!destinationDirectoryFullPath.EndsWith(Path.DirectorySeparatorChar))
    40|                 destinationDirectoryFullPath += Path.DirectorySeparatorChar;
    41|             string fileDestinationPath = Path.GetFullPath(Path.Combine(destinationDirectoryFullPath, source.FullName));
    42|             if (!fileDestinationPath.StartsWith(destinationDirectoryFullPath, PathInternal.StringComparison))
    43|                 throw new IOException(SR.IO_ExtractingResultsInOutside);
    44|             if (Path.GetFileName(fileDestinationPath).Length == 0)


# ====================================================================
# FILE: src/libraries/System.IO.MemoryMappedFiles/src/System/IO/MemoryMappedFiles/MemoryMappedFile.Unix.cs
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-21 ---
     1| using System.Diagnostics;
     2| using Microsoft.Win32.SafeHandles;
     3| namespace System.IO.MemoryMappedFiles
     4| {
     5|     public partial class MemoryMappedFile
     6|     {
     7|         private static void VerifyMemoryMappedFileAccess(MemoryMappedFileAccess access, long capacity, FileStream? fileStream, out long fileSize)
     8|         {
     9|             fileSize = -1;
    10|             if (fileStream != null)
    11|             {
    12|                 Interop.Sys.FileStatus status;
    13|                 int result = Interop.Sys.FStat(fileStream.SafeFileHandle, out status);
    14|                 if (result != 0)
    15|                 {
    16|                     Interop.ErrorInfo errorInfo = Interop.Sys.GetLastErrorInfo();
    17|                     throw Interop.GetExceptionForIoErrno(errorInfo);
    18|                 }
    19|                 bool isRegularFile = (status.Mode & Interop.Sys.FileTypes.S_IFCHR) == 0;
    20|                 if (isRegularFile)
    21|                 {

# --- HUNK 2: Lines 90-185 ---
    90|         }
    91|         private static Exception CreateNamedMapsNotSupportedException()
    92|         {
    93|             return new PlatformNotSupportedException(SR.PlatformNotSupported_NamedMaps);
    94|         }
    95|         private static FileAccess TranslateProtectionsToFileAccess(Interop.Sys.MemoryMappedProtections protections)
    96|         {
    97|             return
    98|                 (protections & (Interop.Sys.MemoryMappedProtections.PROT_READ | Interop.Sys.MemoryMappedProtections.PROT_WRITE)) != 0 ? FileAccess.ReadWrite :
    99|                 (protections & (Interop.Sys.MemoryMappedProtections.PROT_WRITE)) != 0 ? FileAccess.Write :
   100|                 FileAccess.Read;
   101|         }
   102|         private static FileStream CreateSharedBackingObject(Interop.Sys.MemoryMappedProtections protections, long capacity, HandleInheritability inheritability)
   103|         {
   104|             return CreateSharedBackingObjectUsingMemory(protections, capacity, inheritability)
   105|                 ?? CreateSharedBackingObjectUsingFile(protections, capacity, inheritability);
   106|         }
   107|         private static FileStream? CreateSharedBackingObjectUsingMemory(
   108|            Interop.Sys.MemoryMappedProtections protections, long capacity, HandleInheritability inheritability)
   109|         {
   110|             Interop.Sys.OpenFlags flags = (protections & Interop.Sys.MemoryMappedProtections.PROT_WRITE) != 0 ?
   111|                 Interop.Sys.OpenFlags.O_RDWR :
   112|                 Interop.Sys.OpenFlags.O_RDONLY;
   113|             flags |= Interop.Sys.OpenFlags.O_CREAT | Interop.Sys.OpenFlags.O_EXCL; // CreateNew
   114|             Interop.Sys.Permissions perms = default(Interop.Sys.Permissions);
   115|             if ((protections & Interop.Sys.MemoryMappedProtections.PROT_READ) != 0)
   116|                 perms |= Interop.Sys.Permissions.S_IRUSR;
   117|             if ((protections & Interop.Sys.MemoryMappedProtections.PROT_WRITE) != 0)
   118|                 perms |= Interop.Sys.Permissions.S_IWUSR;
   119|             if ((protections & Interop.Sys.MemoryMappedProtections.PROT_EXEC) != 0)
   120|                 perms |= Interop.Sys.Permissions.S_IXUSR;
   121|             string mapName;
   122|             SafeFileHandle fd;
   123|             do
   124|             {
   125|                 mapName = GenerateMapName();
   126|                 fd = Interop.Sys.ShmOpen(mapName, flags, (int)perms); // Create the shared memory object.
   127|                 if (fd.IsInvalid)
   128|                 {
   129|                     Interop.ErrorInfo errorInfo = Interop.Sys.GetLastErrorInfo();
   130|                     fd.Dispose();
   131|                     if (errorInfo.Error == Interop.Error.ENOTSUP)
   132|                     {
   133|                         return null;
   134|                     }
   135|                     else if (errorInfo.Error != Interop.Error.EEXIST) // map with same name already existed
   136|                     {
   137|                         throw Interop.GetExceptionForIoErrno(errorInfo);
   138|                     }
   139|                 }
   140|             } while (fd.IsInvalid);
   141|             try
   142|             {
   143|                 Interop.CheckIo(Interop.Sys.ShmUnlink(mapName));
   144|                 Interop.CheckIo(Interop.Sys.FTruncate(fd, capacity));
   145|                 if (inheritability == HandleInheritability.Inheritable &&
   146|                     Interop.Sys.Fcntl.SetFD(fd, 0) == -1)
   147|                 {
   148|                     throw Interop.GetExceptionForIoErrno(Interop.Sys.GetLastErrorInfo());
   149|                 }
   150|                 return new FileStream(fd, TranslateProtectionsToFileAccess(protections));
   151|             }
   152|             catch
   153|             {
   154|                 fd.Dispose();
   155|                 throw;
   156|             }
   157|             static string GenerateMapName()
   158|             {
   159|                 const int MaxSharedMemoryObjectNameLength = 32; // SHM_NAME_MAX on OSX ARM64, on other systems it's equal PATH_MAX (250)
   160|                 return string.Create(MaxSharedMemoryObjectNameLength, 0, (span, state) =>
   161|                 {
   162|                     Guid.NewGuid().TryFormat(span, out int charsWritten, "N");
   163|                     Debug.Assert(charsWritten == MaxSharedMemoryObjectNameLength);
   164|                     "/dotnet_".CopyTo(span);
   165|                 });
   166|             }
   167|         }
   168|         private static FileStream CreateSharedBackingObjectUsingFile(Interop.Sys.MemoryMappedProtections protections, long capacity, HandleInheritability inheritability)
   169|         {
   170|             string path = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString("N"));
   171|             FileShare share = inheritability == HandleInheritability.None ?
   172|                 FileShare.ReadWrite :
   173|                 FileShare.ReadWrite | FileShare.Inheritable;
   174|             const int DefaultBufferSize = 0x1000;
   175|             var fs = new FileStream(path, FileMode.CreateNew, TranslateProtectionsToFileAccess(protections), share, DefaultBufferSize);
   176|             try
   177|             {
   178|                 Interop.CheckIo(Interop.Sys.Unlink(path));
   179|                 fs.SetLength(capacity);
   180|             }
   181|             catch
   182|             {
   183|                 fs.Dispose();
   184|                 throw;
   185|             }


# ====================================================================
# FILE: src/libraries/System.Net.Http/src/System/Net/Http/HttpClientHandler.AnyMobile.InvokeNativeHandler.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-48 ---
     1| using System;
     2| using System.Collections.Generic;
     3| using System.Diagnostics.CodeAnalysis;
     4| using System.Net.Security;
     5| using System.Reflection;
     6| using System.Security.Authentication;
     7| using System.Security.Cryptography.X509Certificates;
     8| namespace System.Net.Http
     9| {
    10|     public partial class HttpClientHandler : HttpMessageHandler
    11|     {
    12|         private static MethodInfo? _nativeHandlerMethod;
    13| #if TARGET_ANDROID
    14|         private const string NativeHandlerType = "Xamarin.Android.Net.AndroidMessageHandler";
    15|         private const string AssemblyName = "Mono.Android";
    16|         private const string GetHttpMessageHandlerType = "Android.Runtime.AndroidEnvironment, Mono.Android";
    17| #elif TARGET_IOS
    18|         private const string NativeHandlerType = "System.Net.Http.NSUrlSessionHandler";
    19|         private const string AssemblyName = "Microsoft.iOS";
    20|         private const string GetHttpMessageHandlerType = "ObjCRuntime.RuntimeOptions, Microsoft.iOS";
    21| #elif TARGET_MACCATALYST
    22|         private const string NativeHandlerType = "System.Net.Http.NSUrlSessionHandler";
    23|         private const string AssemblyName = "Microsoft.MacCatalyst";
    24|         private const string GetHttpMessageHandlerType = "ObjCRuntime.RuntimeOptions, Microsoft.MacCatalyst";
    25| #elif TARGET_TVOS
    26|         private const string NativeHandlerType = "System.Net.Http.NSUrlSessionHandler";
    27|         private const string AssemblyName = "Microsoft.tvOS";
    28|         private const string GetHttpMessageHandlerType = "ObjCRuntime.RuntimeOptions, Microsoft.tvOS";
    29| #else
    30| #error Unknown target
    31| #endif
    32|         [DynamicDependency("get_DefaultProxyCredentials", NativeHandlerType, AssemblyName)]
    33|         private ICredentials? GetDefaultProxyCredentials() => (ICredentials?)InvokeNativeHandlerMethod("get_DefaultProxyCredentials");
    34|         [DynamicDependency("set_DefaultProxyCredentials", NativeHandlerType, AssemblyName)]
    35|         private void SetDefaultProxyCredentials(ICredentials? value) => InvokeNativeHandlerMethod("set_DefaultProxyCredentials", value);
    36|         [DynamicDependency("get_MaxConnectionsPerServer", NativeHandlerType, AssemblyName)]
    37|         private int GetMaxConnectionsPerServer() => (int)InvokeNativeHandlerMethod("get_MaxConnectionsPerServer");
    38|         [DynamicDependency("set_MaxConnectionsPerServer", NativeHandlerType, AssemblyName)]
    39|         private void SetMaxConnectionsPerServer(int value) => InvokeNativeHandlerMethod("set_MaxConnectionsPerServer", value);
    40|         [DynamicDependency("get_MaxResponseHeadersLength", NativeHandlerType, AssemblyName)]
    41|         private int GetMaxResponseHeadersLength() => (int)InvokeNativeHandlerMethod("get_MaxResponseHeadersLength");
    42|         [DynamicDependency("set_MaxResponseHeadersLength", NativeHandlerType, AssemblyName)]
    43|         private void SetMaxResponseHeadersLength(int value) => InvokeNativeHandlerMethod("set_MaxResponseHeadersLength", value);
    44|         [DynamicDependency("get_ClientCertificateOptions", NativeHandlerType, AssemblyName)]
    45|         private ClientCertificateOption GetClientCertificateOptions() => (ClientCertificateOption)InvokeNativeHandlerMethod("get_ClientCertificateOptions");
    46|         [DynamicDependency("set_ClientCertificateOptions", NativeHandlerType, AssemblyName)]
    47|         private void SetClientCertificateOptions(ClientCertificateOption value) => InvokeNativeHandlerMethod("set_ClientCertificateOptions", value);
    48|         [DynamicDependency("get_ClientCertificates", NativeHandlerType, AssemblyName)]


# ====================================================================
# FILE: src/libraries/System.Net.NetworkInformation/ref/System.Net.NetworkInformation.cs
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 100-274 ---
   100|         public abstract bool IsDnsEligible { get; }
   101|         public abstract bool IsTransient { get; }
   102|     }
   103|     public partial class IPAddressInformationCollection : System.Collections.Generic.ICollection<System.Net.NetworkInformation.IPAddressInformation>, System.Collections.Generic.IEnumerable<System.Net.NetworkInformation.IPAddressInformation>, System.Collections.IEnumerable
   104|     {
   105|         internal IPAddressInformationCollection() { }
   106|         public virtual int Count { get { throw null; } }
   107|         public virtual bool IsReadOnly { get { throw null; } }
   108|         public virtual System.Net.NetworkInformation.IPAddressInformation this[int index] { get { throw null; } }
   109|         public virtual void Add(System.Net.NetworkInformation.IPAddressInformation address) { }
   110|         public virtual void Clear() { }
   111|         public virtual bool Contains(System.Net.NetworkInformation.IPAddressInformation address) { throw null; }
   112|         public virtual void CopyTo(System.Net.NetworkInformation.IPAddressInformation[] array, int offset) { }
   113|         public virtual System.Collections.Generic.IEnumerator<System.Net.NetworkInformation.IPAddressInformation> GetEnumerator() { throw null; }
   114|         public virtual bool Remove(System.Net.NetworkInformation.IPAddressInformation address) { throw null; }
   115|         System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { throw null; }
   116|     }
   117|     public abstract partial class IPGlobalProperties
   118|     {
   119|         protected IPGlobalProperties() { }
   120|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   121|         public abstract string DhcpScopeName { get; }
   122|         public abstract string DomainName { get; }
   123|         public abstract string HostName { get; }
   124|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   125|         public abstract bool IsWinsProxy { get; }
   126|         public abstract System.Net.NetworkInformation.NetBiosNodeType NodeType { get; }
   127|         public virtual System.IAsyncResult BeginGetUnicastAddresses(System.AsyncCallback? callback, object? state) { throw null; }
   128|         public virtual System.Net.NetworkInformation.UnicastIPAddressInformationCollection EndGetUnicastAddresses(System.IAsyncResult asyncResult) { throw null; }
   129|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   130|         public abstract System.Net.NetworkInformation.TcpConnectionInformation[] GetActiveTcpConnections();
   131|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   132|         public abstract System.Net.IPEndPoint[] GetActiveTcpListeners();
   133|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   134|         public abstract System.Net.IPEndPoint[] GetActiveUdpListeners();
   135|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   136|         public abstract System.Net.NetworkInformation.IcmpV4Statistics GetIcmpV4Statistics();
   137|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   138|         public abstract System.Net.NetworkInformation.IcmpV6Statistics GetIcmpV6Statistics();
   139|         [System.Runtime.Versioning.UnsupportedOSPlatform("illumos")]
   140|         [System.Runtime.Versioning.UnsupportedOSPlatform("solaris")]
   141|         public static System.Net.NetworkInformation.IPGlobalProperties GetIPGlobalProperties() { throw null; }
   142|         public abstract System.Net.NetworkInformation.IPGlobalStatistics GetIPv4GlobalStatistics();
   143|         public abstract System.Net.NetworkInformation.IPGlobalStatistics GetIPv6GlobalStatistics();
   144|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   145|         public abstract System.Net.NetworkInformation.TcpStatistics GetTcpIPv4Statistics();
   146|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   147|         public abstract System.Net.NetworkInformation.TcpStatistics GetTcpIPv6Statistics();
   148|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   149|         public abstract System.Net.NetworkInformation.UdpStatistics GetUdpIPv4Statistics();
   150|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   151|         public abstract System.Net.NetworkInformation.UdpStatistics GetUdpIPv6Statistics();
   152|         public virtual System.Net.NetworkInformation.UnicastIPAddressInformationCollection GetUnicastAddresses() { throw null; }
   153|         public virtual System.Threading.Tasks.Task<System.Net.NetworkInformation.UnicastIPAddressInformationCollection> GetUnicastAddressesAsync() { throw null; }
   154|     }
   155|     public abstract partial class IPGlobalStatistics
   156|     {
   157|         protected IPGlobalStatistics() { }
   158|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   159|         public abstract int DefaultTtl { get; }
   160|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   161|         public abstract bool ForwardingEnabled { get; }
   162|         public abstract int NumberOfInterfaces { get; }
   163|         public abstract int NumberOfIPAddresses { get; }
   164|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   165|         public abstract int NumberOfRoutes { get; }
   166|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   167|         public abstract long OutputPacketRequests { get; }
   168|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   169|         public abstract long OutputPacketRoutingDiscards { get; }
   170|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   171|         public abstract long OutputPacketsDiscarded { get; }
   172|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   173|         public abstract long OutputPacketsWithNoRoute { get; }
   174|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   175|         public abstract long PacketFragmentFailures { get; }
   176|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   177|         public abstract long PacketReassembliesRequired { get; }
   178|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   179|         public abstract long PacketReassemblyFailures { get; }
   180|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   181|         public abstract long PacketReassemblyTimeout { get; }
   182|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   183|         public abstract long PacketsFragmented { get; }
   184|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   185|         public abstract long PacketsReassembled { get; }
   186|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   187|         public abstract long ReceivedPackets { get; }
   188|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   189|         public abstract long ReceivedPacketsDelivered { get; }
   190|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   191|         public abstract long ReceivedPacketsDiscarded { get; }
   192|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   193|         public abstract long ReceivedPacketsForwarded { get; }
   194|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   195|         public abstract long ReceivedPacketsWithAddressErrors { get; }
   196|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   197|         public abstract long ReceivedPacketsWithHeadersErrors { get; }
   198|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   199|         public abstract long ReceivedPacketsWithUnknownProtocol { get; }
   200|     }
   201|     public abstract partial class IPInterfaceProperties
   202|     {
   203|         protected IPInterfaceProperties() { }
   204|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   205|         public abstract System.Net.NetworkInformation.IPAddressInformationCollection AnycastAddresses { get; }
   206|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   207|         public abstract System.Net.NetworkInformation.IPAddressCollection DhcpServerAddresses { get; }
   208|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   209|         public abstract System.Net.NetworkInformation.IPAddressCollection DnsAddresses { get; }
   210|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   211|         public abstract string DnsSuffix { get; }
   212|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   213|         public abstract System.Net.NetworkInformation.GatewayIPAddressInformationCollection GatewayAddresses { get; }
   214|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   215|         public abstract bool IsDnsEnabled { get; }
   216|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   217|         public abstract bool IsDynamicDnsEnabled { get; }
   218|         public abstract System.Net.NetworkInformation.MulticastIPAddressInformationCollection MulticastAddresses { get; }
   219|         public abstract System.Net.NetworkInformation.UnicastIPAddressInformationCollection UnicastAddresses { get; }
   220|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   221|         public abstract System.Net.NetworkInformation.IPAddressCollection WinsServersAddresses { get; }
   222|         public abstract System.Net.NetworkInformation.IPv4InterfaceProperties GetIPv4Properties();
   223|         public abstract System.Net.NetworkInformation.IPv6InterfaceProperties GetIPv6Properties();
   224|     }
   225|     public abstract partial class IPInterfaceStatistics
   226|     {
   227|         protected IPInterfaceStatistics() { }
   228|         public abstract long BytesReceived { get; }
   229|         public abstract long BytesSent { get; }
   230|         public abstract long IncomingPacketsDiscarded { get; }
   231|         public abstract long IncomingPacketsWithErrors { get; }
   232|         public abstract long IncomingUnknownProtocolPackets { get; }
   233|         public abstract long NonUnicastPacketsReceived { get; }
   234|         public abstract long NonUnicastPacketsSent { get; }
   235|         public abstract long OutgoingPacketsDiscarded { get; }
   236|         public abstract long OutgoingPacketsWithErrors { get; }
   237|         public abstract long OutputQueueLength { get; }
   238|         public abstract long UnicastPacketsReceived { get; }
   239|         public abstract long UnicastPacketsSent { get; }
   240|     }
   241|     public abstract partial class IPv4InterfaceProperties
   242|     {
   243|         protected IPv4InterfaceProperties() { }
   244|         public abstract int Index { get; }
   245|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   246|         public abstract bool IsAutomaticPrivateAddressingActive { get; }
   247|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   248|         public abstract bool IsAutomaticPrivateAddressingEnabled { get; }
   249|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   250|         public abstract bool IsDhcpEnabled { get; }
   251|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   252|         public abstract bool IsForwardingEnabled { get; }
   253|         public abstract int Mtu { get; }
   254|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   255|         public abstract bool UsesWins { get; }
   256|     }
   257|     public abstract partial class IPv4InterfaceStatistics
   258|     {
   259|         protected IPv4InterfaceStatistics() { }
   260|         public abstract long BytesReceived { get; }
   261|         public abstract long BytesSent { get; }
   262|         public abstract long IncomingPacketsDiscarded { get; }
   263|         public abstract long IncomingPacketsWithErrors { get; }
   264|         public abstract long IncomingUnknownProtocolPackets { get; }
   265|         public abstract long NonUnicastPacketsReceived { get; }
   266|         public abstract long NonUnicastPacketsSent { get; }
   267|         public abstract long OutgoingPacketsDiscarded { get; }
   268|         public abstract long OutgoingPacketsWithErrors { get; }
   269|         public abstract long OutputQueueLength { get; }
   270|         public abstract long UnicastPacketsReceived { get; }
   271|         public abstract long UnicastPacketsSent { get; }
   272|     }
   273|     public abstract partial class IPv6InterfaceProperties
   274|     {

# --- HUNK 2: Lines 334-376 ---
   334|         protected NetworkInformationException(System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext) { }
   335|         public override int ErrorCode { get { throw null; } }
   336|     }
   337|     public abstract partial class NetworkInterface
   338|     {
   339|         protected NetworkInterface() { }
   340|         public virtual string Description { get { throw null; } }
   341|         public virtual string Id { get { throw null; } }
   342|         public static int IPv6LoopbackInterfaceIndex { get { throw null; } }
   343|         public virtual bool IsReceiveOnly { get { throw null; } }
   344|         public static int LoopbackInterfaceIndex { get { throw null; } }
   345|         public virtual string Name { get { throw null; } }
   346|         public virtual System.Net.NetworkInformation.NetworkInterfaceType NetworkInterfaceType { get { throw null; } }
   347|         public virtual System.Net.NetworkInformation.OperationalStatus OperationalStatus { get { throw null; } }
   348|         public virtual long Speed { get { throw null; } }
   349|         public virtual bool SupportsMulticast { get { throw null; } }
   350|         [System.Runtime.Versioning.UnsupportedOSPlatform("illumos")]
   351|         [System.Runtime.Versioning.UnsupportedOSPlatform("solaris")]
   352|         public static System.Net.NetworkInformation.NetworkInterface[] GetAllNetworkInterfaces() { throw null; }
   353|         public virtual System.Net.NetworkInformation.IPInterfaceProperties GetIPProperties() { throw null; }
   354|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   355|         public virtual System.Net.NetworkInformation.IPInterfaceStatistics GetIPStatistics() { throw null; }
   356|         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
   357|         public virtual System.Net.NetworkInformation.IPv4InterfaceStatistics GetIPv4Statistics() { throw null; }
   358|         [System.Runtime.Versioning.UnsupportedOSPlatform("illumos")]
   359|         [System.Runtime.Versioning.UnsupportedOSPlatform("solaris")]
   360|         public static bool GetIsNetworkAvailable() { throw null; }
   361|         public virtual System.Net.NetworkInformation.PhysicalAddress GetPhysicalAddress() { throw null; }
   362|         public virtual bool Supports(System.Net.NetworkInformation.NetworkInterfaceComponent networkInterfaceComponent) { throw null; }
   363|     }
   364|     public enum NetworkInterfaceComponent
   365|     {
   366|         IPv4 = 0,
   367|         IPv6 = 1,
   368|     }
   369|     public enum NetworkInterfaceType
   370|     {
   371|         Unknown = 1,
   372|         Ethernet = 6,
   373|         TokenRing = 9,
   374|         Fddi = 15,
   375|         BasicIsdn = 20,
   376|         PrimaryIsdn = 21,


# ====================================================================
# FILE: src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/AndroidIPGlobalProperties.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-19 ---
     1| namespace System.Net.NetworkInformation
     2| {
     3|     internal sealed class AndroidIPGlobalProperties : UnixIPGlobalProperties
     4|     {
     5|         public override TcpConnectionInformation[] GetActiveTcpConnections() => throw new PlatformNotSupportedException();
     6|         public override IPEndPoint[] GetActiveTcpListeners() => throw new PlatformNotSupportedException();
     7|         public override IPEndPoint[] GetActiveUdpListeners() => throw new PlatformNotSupportedException();
     8|         public override IcmpV4Statistics GetIcmpV4Statistics() => throw new PlatformNotSupportedException();
     9|         public override IcmpV6Statistics GetIcmpV6Statistics() => throw new PlatformNotSupportedException();
    10|         public override IPGlobalStatistics GetIPv4GlobalStatistics()
    11|             => new AndroidIPGlobalStatistics(ipv4: true);
    12|         public override IPGlobalStatistics GetIPv6GlobalStatistics()
    13|             => new AndroidIPGlobalStatistics(ipv4: false);
    14|         public override TcpStatistics GetTcpIPv4Statistics() => throw new PlatformNotSupportedException();
    15|         public override TcpStatistics GetTcpIPv6Statistics() => throw new PlatformNotSupportedException();
    16|         public override UdpStatistics GetUdpIPv4Statistics() => throw new PlatformNotSupportedException();
    17|         public override UdpStatistics GetUdpIPv6Statistics() => throw new PlatformNotSupportedException();
    18|     }
    19| }


# ====================================================================
# FILE: src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/AndroidIPGlobalStatistics.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-64 ---
     1| using System.Diagnostics;
     2| using System.IO;
     3| using System.Runtime.InteropServices;
     4| using System.Runtime.Versioning;
     5| using System.Net.Sockets;
     6| namespace System.Net.NetworkInformation
     7| {
     8|     internal sealed class AndroidIPGlobalStatistics : IPGlobalStatistics
     9|     {
    10|         public AndroidIPGlobalStatistics(bool ipv4)
    11|         {
    12|             AndroidNetworkInterface[] networkInterfaces = NetworkInterfacePal.GetAndroidNetworkInterfaces();
    13|             foreach (var networkInterface in networkInterfaces)
    14|             {
    15|                 var component = ipv4 ? NetworkInterfaceComponent.IPv4 : NetworkInterfaceComponent.IPv6;
    16|                 if (networkInterface.Supports(component))
    17|                 {
    18|                     NumberOfInterfaces++;
    19|                 }
    20|                 foreach (UnixUnicastIPAddressInformation addressInformation in networkInterface.UnicastAddress)
    21|                 {
    22|                     bool isIPv4 = addressInformation.Address.AddressFamily == AddressFamily.InterNetwork;
    23|                     if (isIPv4 == ipv4)
    24|                     {
    25|                         NumberOfIPAddresses++;
    26|                     }
    27|                 }
    28|                 if (networkInterface.MulticastAddresess != null)
    29|                 {
    30|                     foreach (IPAddress address in networkInterface.MulticastAddresess)
    31|                     {
    32|                         bool isIPv4 = address.AddressFamily == AddressFamily.InterNetwork;
    33|                         if (isIPv4 == ipv4)
    34|                         {
    35|                             NumberOfIPAddresses++;
    36|                         }
    37|                     }
    38|                 }
    39|             }
    40|         }
    41|         public override int NumberOfInterfaces { get; }
    42|         public override int NumberOfIPAddresses { get; }
    43|         public override int DefaultTtl => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    44|         public override bool ForwardingEnabled => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    45|         public override int NumberOfRoutes => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    46|         public override long OutputPacketRequests => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    47|         public override long OutputPacketRoutingDiscards => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    48|         public override long OutputPacketsDiscarded => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    49|         public override long OutputPacketsWithNoRoute => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    50|         public override long PacketFragmentFailures => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    51|         public override long PacketReassembliesRequired => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    52|         public override long PacketReassemblyFailures => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    53|         public override long PacketReassemblyTimeout => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    54|         public override long PacketsFragmented => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    55|         public override long PacketsReassembled => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    56|         public override long ReceivedPackets => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    57|         public override long ReceivedPacketsDelivered => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    58|         public override long ReceivedPacketsDiscarded => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    59|         public override long ReceivedPacketsForwarded => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    60|         public override long ReceivedPacketsWithAddressErrors => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    61|         public override long ReceivedPacketsWithHeadersErrors => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    62|         public override long ReceivedPacketsWithUnknownProtocol => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    63|     }
    64| }


# ====================================================================
# FILE: src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/AndroidIPInterfaceProperties.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-23 ---
     1| using System.Collections.Generic;
     2| using System.IO;
     3| namespace System.Net.NetworkInformation
     4| {
     5|     internal sealed class AndroidIPInterfaceProperties : UnixIPInterfaceProperties
     6|     {
     7|         private readonly AndroidIPv4InterfaceProperties _ipv4Properties;
     8|         private readonly AndroidIPv6InterfaceProperties _ipv6Properties;
     9|         public AndroidIPInterfaceProperties(AndroidNetworkInterface ani)
    10|             : base(ani, globalConfig: true)
    11|         {
    12|             _ipv4Properties = new AndroidIPv4InterfaceProperties(ani);
    13|             _ipv6Properties = new AndroidIPv6InterfaceProperties(ani);
    14|         }
    15|         public override IPv4InterfaceProperties GetIPv4Properties() => _ipv4Properties;
    16|         public override IPv6InterfaceProperties GetIPv6Properties() => _ipv6Properties;
    17|         public override bool IsDynamicDnsEnabled => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    18|         public override IPAddressInformationCollection AnycastAddresses => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    19|         public override GatewayIPAddressInformationCollection GatewayAddresses => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    20|         public override IPAddressCollection DhcpServerAddresses => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    21|         public override IPAddressCollection WinsServersAddresses => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    22|     }
    23| }


# ====================================================================
# FILE: src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/AndroidIPv4InterfaceProperties.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-18 ---
     1| using System.IO;
     2| namespace System.Net.NetworkInformation
     3| {
     4|     internal sealed class AndroidIPv4InterfaceProperties : UnixIPv4InterfaceProperties
     5|     {
     6|         public AndroidIPv4InterfaceProperties(AndroidNetworkInterface androidNetworkInterface)
     7|             : base(androidNetworkInterface)
     8|         {
     9|             Mtu = androidNetworkInterface._mtu;
    10|         }
    11|         public override int Mtu { get; }
    12|         public override bool IsAutomaticPrivateAddressingActive => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    13|         public override bool IsAutomaticPrivateAddressingEnabled => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    14|         public override bool IsDhcpEnabled => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    15|         public override bool IsForwardingEnabled => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    16|         public override bool UsesWins => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    17|     }
    18| }


# ====================================================================
# FILE: src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/AndroidIPv6InterfaceProperties.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-23 ---
     1| using System.IO;
     2| namespace System.Net.NetworkInformation
     3| {
     4|     internal sealed class AndroidIPv6InterfaceProperties : UnixIPv6InterfaceProperties
     5|     {
     6|         private readonly AndroidNetworkInterface _androidNetworkInterface;
     7|         public AndroidIPv6InterfaceProperties(AndroidNetworkInterface androidNetworkInterface)
     8|             : base(androidNetworkInterface)
     9|         {
    10|             _androidNetworkInterface = androidNetworkInterface;
    11|         }
    12|         public override int Mtu => _androidNetworkInterface._mtu;
    13|         public override long GetScopeId(ScopeLevel scopeLevel)
    14|         {
    15|             if (scopeLevel == ScopeLevel.None || scopeLevel == ScopeLevel.Interface ||
    16|                 scopeLevel == ScopeLevel.Link || scopeLevel == ScopeLevel.Subnet)
    17|             {
    18|                 return _androidNetworkInterface.Index;
    19|             }
    20|             return 0;
    21|         }
    22|     }
    23| }


# ====================================================================
# FILE: src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/AndroidNetworkInterface.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-41 ---
     1| using System.Net;
     2| namespace System.Net.NetworkInformation
     3| {
     4|     internal sealed class AndroidNetworkInterface : UnixNetworkInterface
     5|     {
     6|         internal readonly int _mtu;
     7|         private readonly AndroidIPInterfaceProperties _ipProperties;
     8|         internal unsafe AndroidNetworkInterface(string name, Interop.Sys.NetworkInterfaceInfo *networkInterfaceInfo)
     9|             : base(name)
    10|         {
    11|             _index = networkInterfaceInfo->InterfaceIndex;
    12|             if (networkInterfaceInfo->NumAddressBytes > 0)
    13|             {
    14|                 _physicalAddress = new PhysicalAddress(new ReadOnlySpan<byte>(networkInterfaceInfo->AddressBytes, networkInterfaceInfo->NumAddressBytes).ToArray());
    15|             }
    16|             _mtu = networkInterfaceInfo->Mtu;
    17|             _ipProperties = new AndroidIPInterfaceProperties(this);
    18|             OperationalStatus = (OperationalStatus)networkInterfaceInfo->OperationalState;
    19|             Speed = networkInterfaceInfo->Speed;
    20|             SupportsMulticast = networkInterfaceInfo->SupportsMulticast != 0;
    21|             NetworkInterfaceType = (NetworkInterfaceType)networkInterfaceInfo->HardwareType;
    22|         }
    23|         internal unsafe void AddAddress(Interop.Sys.IpAddressInfo *addressInfo)
    24|         {
    25|             var address = new IPAddress(new ReadOnlySpan<byte>(addressInfo->AddressBytes, addressInfo->NumAddressBytes));
    26|             if (address.IsIPv6LinkLocal)
    27|             {
    28|                 address.ScopeId = addressInfo->InterfaceIndex;
    29|             }
    30|             AddAddress(address, addressInfo->PrefixLength);
    31|         }
    32|         public override bool SupportsMulticast { get; }
    33|         public override IPInterfaceProperties GetIPProperties() => _ipProperties;
    34|         public override IPInterfaceStatistics GetIPStatistics() => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    35|         public override IPv4InterfaceStatistics GetIPv4Statistics() => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
    36|         public override OperationalStatus OperationalStatus { get; }
    37|         public override NetworkInterfaceType NetworkInterfaceType { get; }
    38|         public override long Speed { get; }
    39|         public override bool IsReceiveOnly => false;
    40|     }
    41| }


# ====================================================================
# FILE: src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/IPGlobalProperties.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-57 ---
     1| using System.Runtime.Versioning;
     2| using System.Threading.Tasks;
     3| namespace System.Net.NetworkInformation
     4| {
     5|     public abstract class IPGlobalProperties
     6|     {
     7|         [UnsupportedOSPlatform("illumos")]
     8|         [UnsupportedOSPlatform("solaris")]
     9|         public static IPGlobalProperties GetIPGlobalProperties()
    10|         {
    11|             return IPGlobalPropertiesPal.GetIPGlobalProperties();
    12|         }
    13|         [UnsupportedOSPlatform("android")]
    14|         public abstract IPEndPoint[] GetActiveUdpListeners();
    15|         [UnsupportedOSPlatform("android")]
    16|         public abstract IPEndPoint[] GetActiveTcpListeners();
    17|         [UnsupportedOSPlatform("android")]
    18|         public abstract TcpConnectionInformation[] GetActiveTcpConnections();
    19|         [UnsupportedOSPlatform("android")]
    20|         public abstract string DhcpScopeName { get; }
    21|         public abstract string DomainName { get; }
    22|         public abstract string HostName { get; }
    23|         [UnsupportedOSPlatform("android")]
    24|         public abstract bool IsWinsProxy { get; }
    25|         public abstract NetBiosNodeType NodeType { get; }
    26|         public virtual IAsyncResult BeginGetUnicastAddresses(AsyncCallback? callback, object? state)
    27|         {
    28|             throw NotImplemented.ByDesignWithMessage(SR.net_MethodNotImplementedException);
    29|         }
    30|         public virtual UnicastIPAddressInformationCollection EndGetUnicastAddresses(IAsyncResult asyncResult)
    31|         {
    32|             throw NotImplemented.ByDesignWithMessage(SR.net_MethodNotImplementedException);
    33|         }
    34|         [UnsupportedOSPlatform("android")]
    35|         public abstract TcpStatistics GetTcpIPv4Statistics();
    36|         [UnsupportedOSPlatform("android")]
    37|         public abstract TcpStatistics GetTcpIPv6Statistics();
    38|         [UnsupportedOSPlatform("android")]
    39|         public abstract UdpStatistics GetUdpIPv4Statistics();
    40|         [UnsupportedOSPlatform("android")]
    41|         public abstract UdpStatistics GetUdpIPv6Statistics();
    42|         [UnsupportedOSPlatform("android")]
    43|         public abstract IcmpV4Statistics GetIcmpV4Statistics();
    44|         [UnsupportedOSPlatform("android")]
    45|         public abstract IcmpV6Statistics GetIcmpV6Statistics();
    46|         public abstract IPGlobalStatistics GetIPv4GlobalStatistics();
    47|         public abstract IPGlobalStatistics GetIPv6GlobalStatistics();
    48|         public virtual UnicastIPAddressInformationCollection GetUnicastAddresses()
    49|         {
    50|             throw NotImplemented.ByDesignWithMessage(SR.net_MethodNotImplementedException);
    51|         }
    52|         public virtual Task<UnicastIPAddressInformationCollection> GetUnicastAddressesAsync()
    53|         {
    54|             throw NotImplemented.ByDesignWithMessage(SR.net_MethodNotImplementedException);
    55|         }
    56|     }
    57| }


# ====================================================================
# FILE: src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/IPGlobalPropertiesPal.Android.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-10 ---
     1| namespace System.Net.NetworkInformation
     2| {
     3|     internal static class IPGlobalPropertiesPal
     4|     {
     5|         public static IPGlobalProperties GetIPGlobalProperties()
     6|         {
     7|             return new AndroidIPGlobalProperties();
     8|         }
     9|     }
    10| }


# ====================================================================
# FILE: src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/IPGlobalStatistics.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-49 ---
     1| using System.Runtime.Versioning;
     2| namespace System.Net.NetworkInformation
     3| {
     4|     public abstract class IPGlobalStatistics
     5|     {
     6|         [UnsupportedOSPlatform("android")]
     7|         public abstract int DefaultTtl { get; }
     8|         [UnsupportedOSPlatform("android")]
     9|         public abstract bool ForwardingEnabled { get; }
    10|         public abstract int NumberOfInterfaces { get; }
    11|         public abstract int NumberOfIPAddresses { get; }
    12|         [UnsupportedOSPlatform("android")]
    13|         public abstract long OutputPacketRequests { get; }
    14|         [UnsupportedOSPlatform("android")]
    15|         public abstract long OutputPacketRoutingDiscards { get; }
    16|         [UnsupportedOSPlatform("android")]
    17|         public abstract long OutputPacketsDiscarded { get; }
    18|         [UnsupportedOSPlatform("android")]
    19|         public abstract long OutputPacketsWithNoRoute { get; }
    20|         [UnsupportedOSPlatform("android")]
    21|         public abstract long PacketFragmentFailures { get; }
    22|         [UnsupportedOSPlatform("android")]
    23|         public abstract long PacketReassembliesRequired { get; }
    24|         [UnsupportedOSPlatform("android")]
    25|         public abstract long PacketReassemblyFailures { get; }
    26|         [UnsupportedOSPlatform("android")]
    27|         public abstract long PacketReassemblyTimeout { get; }
    28|         [UnsupportedOSPlatform("android")]
    29|         public abstract long PacketsFragmented { get; }
    30|         [UnsupportedOSPlatform("android")]
    31|         public abstract long PacketsReassembled { get; }
    32|         [UnsupportedOSPlatform("android")]
    33|         public abstract long ReceivedPackets { get; }
    34|         [UnsupportedOSPlatform("android")]
    35|         public abstract long ReceivedPacketsDelivered { get; }
    36|         [UnsupportedOSPlatform("android")]
    37|         public abstract long ReceivedPacketsDiscarded { get; }
    38|         [UnsupportedOSPlatform("android")]
    39|         public abstract long ReceivedPacketsForwarded { get; }
    40|         [UnsupportedOSPlatform("android")]
    41|         public abstract long ReceivedPacketsWithAddressErrors { get; }
    42|         [UnsupportedOSPlatform("android")]
    43|         public abstract long ReceivedPacketsWithHeadersErrors { get; }
    44|         [UnsupportedOSPlatform("android")]
    45|         public abstract long ReceivedPacketsWithUnknownProtocol { get; }
    46|         [UnsupportedOSPlatform("android")]
    47|         public abstract int NumberOfRoutes { get; }
    48|     }
    49| }


# ====================================================================
# FILE: src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/IPInterfaceProperties.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-27 ---
     1| using System.Runtime.Versioning;
     2| namespace System.Net.NetworkInformation
     3| {
     4|     public abstract class IPInterfaceProperties
     5|     {
     6|         [UnsupportedOSPlatform("android")]
     7|         public abstract bool IsDnsEnabled { get; }
     8|         [UnsupportedOSPlatform("android")]
     9|         public abstract string DnsSuffix { get; }
    10|         [UnsupportedOSPlatform("android")]
    11|         public abstract bool IsDynamicDnsEnabled { get; }
    12|         public abstract UnicastIPAddressInformationCollection UnicastAddresses { get; }
    13|         public abstract MulticastIPAddressInformationCollection MulticastAddresses { get; }
    14|         [UnsupportedOSPlatform("android")]
    15|         public abstract IPAddressInformationCollection AnycastAddresses { get; }
    16|         [UnsupportedOSPlatform("android")]
    17|         public abstract IPAddressCollection DnsAddresses { get; }
    18|         [UnsupportedOSPlatform("android")]
    19|         public abstract GatewayIPAddressInformationCollection GatewayAddresses { get; }
    20|         [UnsupportedOSPlatform("android")]
    21|         public abstract IPAddressCollection DhcpServerAddresses { get; }
    22|         [UnsupportedOSPlatform("android")]
    23|         public abstract IPAddressCollection WinsServersAddresses { get; }
    24|         public abstract IPv4InterfaceProperties GetIPv4Properties();
    25|         public abstract IPv6InterfaceProperties GetIPv6Properties();
    26|     }
    27| }


# ====================================================================
# FILE: src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/IPv4InterfaceProperties.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-19 ---
     1| using System.Runtime.Versioning;
     2| namespace System.Net.NetworkInformation
     3| {
     4|     public abstract class IPv4InterfaceProperties
     5|     {
     6|         [UnsupportedOSPlatform("android")]
     7|         public abstract bool UsesWins { get; }
     8|         [UnsupportedOSPlatform("android")]
     9|         public abstract bool IsDhcpEnabled { get; }
    10|         [UnsupportedOSPlatform("android")]
    11|         public abstract bool IsAutomaticPrivateAddressingActive { get; }
    12|         [UnsupportedOSPlatform("android")]
    13|         public abstract bool IsAutomaticPrivateAddressingEnabled { get; }
    14|         public abstract int Index { get; }
    15|         [UnsupportedOSPlatform("android")]
    16|         public abstract bool IsForwardingEnabled { get; }
    17|         public abstract int Mtu { get; }
    18|     }
    19| }


# ====================================================================
# FILE: src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/NetworkInterface.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 23-67 ---
    23|             {
    24|                 return NetworkInterfacePal.IPv6LoopbackInterfaceIndex;
    25|             }
    26|         }
    27|         [UnsupportedOSPlatform("illumos")]
    28|         [UnsupportedOSPlatform("solaris")]
    29|         public static int LoopbackInterfaceIndex
    30|         {
    31|             get
    32|             {
    33|                 return NetworkInterfacePal.LoopbackInterfaceIndex;
    34|             }
    35|         }
    36|         public virtual string Id { get { throw NotImplemented.ByDesignWithMessage(SR.net_PropertyNotImplementedException); } }
    37|         public virtual string Name { get { throw NotImplemented.ByDesignWithMessage(SR.net_PropertyNotImplementedException); } }
    38|         public virtual string Description { get { throw NotImplemented.ByDesignWithMessage(SR.net_PropertyNotImplementedException); } }
    39|         public virtual IPInterfaceProperties GetIPProperties()
    40|         {
    41|             throw NotImplemented.ByDesignWithMessage(SR.net_MethodNotImplementedException);
    42|         }
    43|         [UnsupportedOSPlatform("android")]
    44|         public virtual IPInterfaceStatistics GetIPStatistics()
    45|         {
    46|             throw NotImplemented.ByDesignWithMessage(SR.net_MethodNotImplementedException);
    47|         }
    48|         [UnsupportedOSPlatform("android")]
    49|         public virtual IPv4InterfaceStatistics GetIPv4Statistics()
    50|         {
    51|             throw NotImplemented.ByDesignWithMessage(SR.net_MethodNotImplementedException);
    52|         }
    53|         public virtual OperationalStatus OperationalStatus { get { throw NotImplemented.ByDesignWithMessage(SR.net_PropertyNotImplementedException); } }
    54|         public virtual long Speed { get { throw NotImplemented.ByDesignWithMessage(SR.net_PropertyNotImplementedException); } }
    55|         public virtual bool IsReceiveOnly { get { throw NotImplemented.ByDesignWithMessage(SR.net_PropertyNotImplementedException); } }
    56|         public virtual bool SupportsMulticast { get { throw NotImplemented.ByDesignWithMessage(SR.net_PropertyNotImplementedException); } }
    57|         public virtual PhysicalAddress GetPhysicalAddress()
    58|         {
    59|             throw NotImplemented.ByDesignWithMessage(SR.net_MethodNotImplementedException);
    60|         }
    61|         public virtual NetworkInterfaceType NetworkInterfaceType { get { throw NotImplemented.ByDesignWithMessage(SR.net_PropertyNotImplementedException); } }
    62|         public virtual bool Supports(NetworkInterfaceComponent networkInterfaceComponent)
    63|         {
    64|             throw NotImplemented.ByDesignWithMessage(SR.net_MethodNotImplementedException);
    65|         }
    66|     }
    67| }


# ====================================================================
# FILE: src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/NetworkInterfacePal.Android.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-86 ---
     1| using System.Runtime.InteropServices;
     2| namespace System.Net.NetworkInformation
     3| {
     4|     internal static class NetworkInterfacePal
     5|     {
     6|         public static NetworkInterface[] GetAllNetworkInterfaces() => GetAndroidNetworkInterfaces();
     7|         public static bool GetIsNetworkAvailable() => TransformNetworkInterfacess(IsSomeNetworkUp);
     8|         public static int IPv6LoopbackInterfaceIndex => LoopbackInterfaceIndex;
     9|         public static int LoopbackInterfaceIndex => TransformNetworkInterfacess(FindLoopbackInterfaceIndex);
    10|         internal static unsafe AndroidNetworkInterface[] GetAndroidNetworkInterfaces()
    11|             => TransformNetworkInterfacess(ToAndroidNetworkInterfaceArray);
    12|         private static unsafe T TransformNetworkInterfacess<T>(Func<int, IntPtr, int, IntPtr, T> transform)
    13|         {
    14|             int interfaceCount = 0;
    15|             int addressCount = 0;
    16|             Interop.Sys.NetworkInterfaceInfo *networkInterfaceInfo = null;
    17|             Interop.Sys.IpAddressInfo *addressInfo = null;
    18|             if (Interop.Sys.GetNetworkInterfaces(ref interfaceCount, ref networkInterfaceInfo, ref addressCount, ref addressInfo) != 0)
    19|             {
    20|                 string message = Interop.Sys.GetLastErrorInfo().GetErrorMessage();
    21|                 throw new NetworkInformationException(message);
    22|             }
    23|             var globalMemory = (IntPtr)networkInterfaceInfo;
    24|             try
    25|             {
    26|                 return transform(interfaceCount, (IntPtr)networkInterfaceInfo, addressCount, (IntPtr)addressInfo);
    27|             }
    28|             finally
    29|             {
    30|                 Marshal.FreeHGlobal(globalMemory);
    31|             }
    32|         }
    33|         private static unsafe AndroidNetworkInterface[] ToAndroidNetworkInterfaceArray(int interfaceCount, IntPtr networkInterfacesPtr, int addressCount, IntPtr addressPtr)
    34|         {
    35|             var networkInterfaces = new AndroidNetworkInterface[interfaceCount];
    36|             var networkInterfaceInfo = (Interop.Sys.NetworkInterfaceInfo*)networkInterfacesPtr;
    37|             for (int i = 0; i < interfaceCount; i++, networkInterfaceInfo++)
    38|             {
    39|                 var name = Marshal.PtrToStringAnsi((IntPtr)networkInterfaceInfo->Name);
    40|                 networkInterfaces[i] = new AndroidNetworkInterface(name!, networkInterfaceInfo);
    41|             }
    42|             var addressInfo = (Interop.Sys.IpAddressInfo*)addressPtr;
    43|             for (int i = 0; i < addressCount; i++, addressInfo++)
    44|             {
    45|                 foreach (var networkInterface in networkInterfaces)
    46|                 {
    47|                     if (networkInterface.Index == addressInfo->InterfaceIndex)
    48|                     {
    49|                         networkInterface.AddAddress(addressInfo);
    50|                         break;
    51|                     }
    52|                 }
    53|             }
    54|             return networkInterfaces;
    55|         }
    56|         private static unsafe int FindLoopbackInterfaceIndex(int interfaceCount, IntPtr networkInterfacesPtr, int addressCount, IntPtr addressPtr)
    57|         {
    58|             var networkInterfaceInfo = (Interop.Sys.NetworkInterfaceInfo*)networkInterfacesPtr;
    59|             for (int i = 0; i < interfaceCount; i++, networkInterfaceInfo++)
    60|             {
    61|                 if (networkInterfaceInfo->HardwareType == (int)NetworkInterfaceType.Loopback)
    62|                 {
    63|                     return networkInterfaceInfo->InterfaceIndex;
    64|                 }
    65|             }
    66|             throw new NetworkInformationException(SR.net_NoLoopback);
    67|         }
    68|         private static unsafe bool IsSomeNetworkUp(int interfaceCount, IntPtr networkInterfacesPtr, int addressCount, IntPtr addressPtr)
    69|         {
    70|             var networkInterfaceInfo = (Interop.Sys.NetworkInterfaceInfo*)networkInterfacesPtr;
    71|             for (int i = 0; i < interfaceCount; i++, networkInterfaceInfo++)
    72|             {
    73|                 if (networkInterfaceInfo->HardwareType == (int)NetworkInterfaceType.Loopback
    74|                     || networkInterfaceInfo->HardwareType == (int)NetworkInterfaceType.Tunnel)
    75|                 {
    76|                     continue;
    77|                 }
    78|                 if (networkInterfaceInfo->OperationalState == (int)OperationalStatus.Up)
    79|                 {
    80|                     return true;
    81|                 }
    82|             }
    83|             return false;
    84|         }
    85|     }
    86| }


# ====================================================================
# FILE: src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/UnixIPGlobalProperties.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-43 ---
     1| using System.Collections.Generic;
     2| using System.Runtime.CompilerServices;
     3| using System.Runtime.InteropServices;
     4| using System.Runtime.Versioning;
     5| using System.Threading;
     6| using System.Threading.Tasks;
     7| namespace System.Net.NetworkInformation
     8| {
     9|     internal abstract class UnixIPGlobalProperties : IPGlobalProperties
    10|     {
    11|         [UnsupportedOSPlatform("linux")]
    12|         [UnsupportedOSPlatform("android")]
    13|         [UnsupportedOSPlatform("osx")]
    14|         [UnsupportedOSPlatform("ios")]
    15|         [UnsupportedOSPlatform("tvos")]
    16|         [UnsupportedOSPlatform("freebsd")]
    17|         [UnsupportedOSPlatform("illumos")]
    18|         [UnsupportedOSPlatform("solaris")]
    19|         public override string DhcpScopeName { get { throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform); } }
    20|         public override string DomainName { get { return HostInformation.DomainName; } }
    21|         public override string HostName { get { return HostInformation.HostName; } }
    22|         [UnsupportedOSPlatform("linux")]
    23|         [UnsupportedOSPlatform("android")]
    24|         [UnsupportedOSPlatform("osx")]
    25|         [UnsupportedOSPlatform("ios")]
    26|         [UnsupportedOSPlatform("tvos")]
    27|         [UnsupportedOSPlatform("freebsd")]
    28|         [UnsupportedOSPlatform("illumos")]
    29|         [UnsupportedOSPlatform("solaris")]
    30|         public override bool IsWinsProxy { get { throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform); } }
    31|         public override NetBiosNodeType NodeType { get { return NetBiosNodeType.Unknown; } }
    32|         public override IAsyncResult BeginGetUnicastAddresses(AsyncCallback? callback, object? state)
    33|         {
    34|             Task<UnicastIPAddressInformationCollection> t = GetUnicastAddressesAsync();
    35|             return TaskToApm.Begin(t, callback, state);
    36|         }
    37|         public override UnicastIPAddressInformationCollection EndGetUnicastAddresses(IAsyncResult asyncResult)
    38|         {
    39|             return TaskToApm.End<UnicastIPAddressInformationCollection>(asyncResult);
    40|         }
    41|         public sealed override Task<UnicastIPAddressInformationCollection> GetUnicastAddressesAsync()
    42|         {
    43|             return Task.Factory.StartNew(s => ((UnixIPGlobalProperties)s!).GetUnicastAddresses(), this,


# ====================================================================
# FILE: src/libraries/System.Net.Security/src/System/Net/Security/CipherSuitesPolicyPal.Linux.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 3-43 ---
     3| using System.Diagnostics;
     4| using System.IO;
     5| using System.Security.Authentication;
     6| using System.Text;
     7| using Ssl = Interop.Ssl;
     8| using OpenSsl = Interop.OpenSsl;
     9| namespace System.Net.Security
    10| {
    11|     internal sealed class CipherSuitesPolicyPal
    12|     {
    13|         private static readonly byte[] AllowNoEncryptionDefault =
    14|             Encoding.ASCII.GetBytes("ALL:eNULL\0");
    15|         private static readonly byte[] NoEncryptionDefault =
    16|             Encoding.ASCII.GetBytes("eNULL\0");
    17|         private byte[] _cipherSuites;
    18|         private byte[] _tls13CipherSuites;
    19|         private List<TlsCipherSuite> _tlsCipherSuites = new List<TlsCipherSuite>();
    20|         internal IEnumerable<TlsCipherSuite> GetCipherSuites() => _tlsCipherSuites;
    21|         internal CipherSuitesPolicyPal(IEnumerable<TlsCipherSuite> allowedCipherSuites)
    22|         {
    23|             if (!Interop.Ssl.Capabilities.Tls13Supported)
    24|             {
    25|                 throw new PlatformNotSupportedException(SR.net_ssl_ciphersuites_policy_not_supported);
    26|             }
    27|             using (SafeSslContextHandle innerContext = Ssl.SslCtxCreate(Ssl.SslMethods.SSLv23_method))
    28|             {
    29|                 if (innerContext.IsInvalid)
    30|                 {
    31|                     throw OpenSsl.CreateSslException(SR.net_allocate_ssl_context_failed);
    32|                 }
    33|                 using (SafeSslHandle ssl = SafeSslHandle.Create(innerContext, false))
    34|                 {
    35|                     if (ssl.IsInvalid)
    36|                     {
    37|                         throw OpenSsl.CreateSslException(SR.net_allocate_ssl_context_failed);
    38|                     }
    39|                     using (var tls13CipherSuites = new OpenSslStringBuilder())
    40|                     using (var cipherSuites = new OpenSslStringBuilder())
    41|                     {
    42|                         foreach (TlsCipherSuite cs in allowedCipherSuites)
    43|                         {


# ====================================================================
# FILE: src/libraries/System.Private.CoreLib/src/System/DateOnly.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 343-388 ---
   343|                         }
   344|                         charsWritten = 10;
   345|                         return true;
   346|                     case 'r':
   347|                     case 'R':
   348|                         if (!DateTimeFormat.TryFormatDateOnlyR(DayOfWeek, Year, Month, Day, destination))
   349|                         {
   350|                             charsWritten = 0;
   351|                             return false;
   352|                         }
   353|                         charsWritten = 16;
   354|                         return true;
   355|                     case 'm':
   356|                     case 'M':
   357|                     case 'd':
   358|                     case 'D':
   359|                     case 'y':
   360|                     case 'Y':
   361|                         return DateTimeFormat.TryFormat(GetEquivalentDateTime(), destination, out charsWritten, format, provider);
   362|                     default:
   363|                         throw new FormatException(SR.Argument_BadFormatSpecifier);
   364|                 }
   365|             }
   366|             if (!DateTimeFormat.IsValidCustomDateFormat(format, throwOnError: false))
   367|             {
   368|                 throw new FormatException(SR.Format(SR.Format_DateTimeOnlyContainsNoneDateParts, format.ToString(), nameof(DateOnly)));
   369|             }
   370|             return DateTimeFormat.TryFormat(GetEquivalentDateTime(), destination, out charsWritten, format, provider);
   371|         }
   372| #if FEATURE_GENERIC_MATH
   373|         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]
   374|         static bool IComparisonOperators<DateOnly, DateOnly>.operator <(DateOnly left, DateOnly right)
   375|             => left < right;
   376|         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]
   377|         static bool IComparisonOperators<DateOnly, DateOnly>.operator <=(DateOnly left, DateOnly right)
   378|             => left <= right;
   379|         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]
   380|         static bool IComparisonOperators<DateOnly, DateOnly>.operator >(DateOnly left, DateOnly right)
   381|             => left > right;
   382|         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]
   383|         static bool IComparisonOperators<DateOnly, DateOnly>.operator >=(DateOnly left, DateOnly right)
   384|             => left >= right;
   385|         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]
   386|         static bool IEqualityOperators<DateOnly, DateOnly>.operator ==(DateOnly left, DateOnly right)
   387|             => left == right;
   388|         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]


# ====================================================================
# FILE: src/libraries/System.Private.CoreLib/src/System/Environment.iOS.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-8 ---
     1| using System.Runtime.InteropServices;
     2| namespace System
     3| {
     4|     public static partial class Environment
     5|     {
     6|         public static long WorkingSet => 0;
     7|     }
     8| }


# ====================================================================
# FILE: src/libraries/System.Private.CoreLib/src/System/Globalization/DateTimeFormat.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 31-72 ---
    31|         "ffffff"    "000000"    second fraction (6 digit)
    32|         "fffffff"   "0000000"   second fraction (7 digit)
    33|         "F"     "0"         second fraction (up to 1 digit)
    34|         "FF"    "00"        second fraction (up to 2 digit)
    35|         "FFF"   "000"       second fraction (up to 3 digit)
    36|         "FFFF"  "0000"      second fraction (up to 4 digit)
    37|         "FFFFF" "00000"         second fraction (up to 5 digit)
    38|         "FFFFFF"    "000000"    second fraction (up to 6 digit)
    39|         "FFFFFFF"   "0000000"   second fraction (up to 7 digit)
    40|         "t"                 first character of AM/PM designator   A
    41|         "tt"                AM/PM designator                      AM
    42|         "tt*"               AM/PM designator                      PM
    43|         "d"     "0"         day w/o leading zero                  1
    44|         "dd"    "00"        day with leading zero                 01
    45|         "ddd"               short weekday name (abbreviation)     Mon
    46|         "dddd"              full weekday name                     Monday
    47|         "dddd*"             full weekday name                     Monday
    48|         "M"     "0"         month w/o leading zero                2
    49|         "MM"    "00"        month with leading zero               02
    50|         "MMM"               short month name (abbreviation)       Feb
    51|         "MMMM"              full month name                       February
    52|         "MMMM*"             full month name                       February
    53|         "y"     "0"         two digit year (year % 100) w/o leading zero           0
    54|         "yy"    "00"        two digit year (year % 100) with leading zero          00
    55|         "yyy"   "D3"        year                                  2000
    56|         "yyyy"  "D4"        year                                  2000
    57|         "yyyyy" "D5"        year                                  2000
    58|         ...
    59|         "z"     "+0;-0"     timezone offset w/o leading zero      -8
    60|         "zz"    "+00;-00"   timezone offset with leading zero     -08
    61|         "zzz"      "+00;-00" for hour offset, "00" for minute offset  full timezone offset   -07:30
    62|         "zzz*"  "+00;-00" for hour offset, "00" for minute offset   full timezone offset   -08:00
    63|         "K"    -Local       "zzz", e.g. -08:00
    64|                -Utc         "'Z'", representing UTC
    65|                -Unspecified ""
    66|                -DateTimeOffset      "zzzzz" e.g -07:30:15
    67|         "g*"                the current era name                  A.D.
    68|         ":"                 time separator                        : -- DEPRECATED - Insert separator directly into pattern (eg: "H.mm.ss")
    69|         "/"                 date separator                        /-- DEPRECATED - Insert separator directly into pattern (eg: "M-dd-yyyy")
    70|         "'"                 quoted string                         'ABC' will insert ABC into the formatted string.
    71|         '"'                 quoted string                         "ABC" will insert ABC into the formatted string.
    72|         "%"                 used to quote a single pattern characters      E.g.The format character "%y" is to print two digit year.


# ====================================================================
# FILE: src/libraries/System.Private.CoreLib/src/System/Number.BigInteger.cs
# Total hunks: 9
# ====================================================================
# --- HUNK 1: Lines 1-36 ---
     1| using System.Diagnostics;
     2| using System.Numerics;
     3| using System.Runtime.InteropServices;
     4| using Internal.Runtime.CompilerServices;
     5| namespace System
     6| {
     7|     internal static partial class Number
     8|     {
     9|         [StructLayout(LayoutKind.Sequential, Pack = 1)]
    10|         internal unsafe ref struct BigInteger
    11|         {
    12|             private const int BitsForLongestBinaryMantissa = 1074;
    13|             private const int BitsForLongestDigitSequence = 2552;
    14|             private const int MaxBits = BitsForLongestBinaryMantissa + BitsForLongestDigitSequence + BitsPerBlock;
    15|             private const int BitsPerBlock = sizeof(int) * 8;
    16|             private const int MaxBlockCount = ((MaxBits + (BitsPerBlock - 1)) / BitsPerBlock) + 1;
    17|             private static readonly uint[] s_Pow10UInt32Table = new uint[]
    18|             {
    19|                 1,          // 10^0
    20|                 10,         // 10^1
    21|                 100,        // 10^2
    22|                 1000,       // 10^3
    23|                 10000,      // 10^4
    24|                 100000,     // 10^5
    25|                 1000000,    // 10^6
    26|                 10000000,   // 10^7
    27|                 100000000,  // 10^8
    28|                 1000000000  // 10^9
    29|             };
    30|             private static readonly int[] s_Pow10BigNumTableIndices = new int[]
    31|             {
    32|                 0,          // 10^8
    33|                 2,          // 10^16
    34|                 5,          // 10^32
    35|                 10,         // 10^64
    36|                 18,         // 10^128

# --- HUNK 2: Lines 256-338 ---
   256|                 0xA7E6BD2A,
   257|                 0xC1A6970C,
   258|                 0x47187094,
   259|                 0xD2DB49EF,
   260|                 0x926C3F5B,
   261|                 0xAE6209D4,
   262|                 0x2D433949,
   263|                 0x34F4A3C6,
   264|                 0xD4305D94,
   265|                 0xD9D61A05,
   266|                 0x00000325,
   267|                 0x00000000,
   268|                 0x00000000,
   269|                 0x00000000,
   270|                 0x00000000,
   271|                 0x00000000,
   272|                 0x00000000,
   273|                 0x00000000,
   274|                 0x00000000,
   275|                 0x00000000,
   276|                 0x00000000,
   277|             };
   278|             private int _length;
   279|             private fixed uint _blocks[MaxBlockCount];
   280|             public static void Add(ref BigInteger lhs, ref BigInteger rhs, out BigInteger result)
   281|             {
   282|                 ref BigInteger large = ref (lhs._length < rhs._length) ? ref rhs : ref lhs;
   283|                 ref BigInteger small = ref (lhs._length < rhs._length) ? ref lhs : ref rhs;
   284|                 int largeLength = large._length;
   285|                 int smallLength = small._length;
   286|                 result._length = largeLength;
   287|                 ulong carry = 0;
   288|                 int largeIndex = 0;
   289|                 int smallIndex = 0;
   290|                 int resultIndex = 0;
   291|                 while (smallIndex < smallLength)
   292|                 {
   293|                     ulong sum = carry + large._blocks[largeIndex] + small._blocks[smallIndex];
   294|                     carry = sum >> 32;
   295|                     result._blocks[resultIndex] = (uint)(sum);
   296|                     largeIndex++;
   297|                     smallIndex++;
   298|                     resultIndex++;
   299|                 }
   300|                 while (largeIndex < largeLength)
   301|                 {
   302|                     ulong sum = carry + large._blocks[largeIndex];
   303|                     carry = sum >> 32;
   304|                     result._blocks[resultIndex] = (uint)(sum);
   305|                     largeIndex++;
   306|                     resultIndex++;
   307|                 }
   308|                 int resultLength = largeLength;
   309|                 if (carry != 0)
   310|                 {
   311|                     Debug.Assert(carry == 1);
   312|                     Debug.Assert(resultIndex == resultLength);
   313|                     Debug.Assert(unchecked((uint)(resultLength)) < MaxBlockCount);
   314|                     if (unchecked((uint)(resultLength)) >= MaxBlockCount)
   315|                     {
   316|                         SetZero(out result);
   317|                         return;
   318|                     }
   319|                     result._blocks[resultIndex] = 1;
   320|                     result._length++;
   321|                 }
   322|             }
   323|             public static int Compare(ref BigInteger lhs, ref BigInteger rhs)
   324|             {
   325|                 Debug.Assert(unchecked((uint)(lhs._length)) <= MaxBlockCount);
   326|                 Debug.Assert(unchecked((uint)(rhs._length)) <= MaxBlockCount);
   327|                 int lhsLength = lhs._length;
   328|                 int rhsLength = rhs._length;
   329|                 int lengthDelta = (lhsLength - rhsLength);
   330|                 if (lengthDelta != 0)
   331|                 {
   332|                     return lengthDelta;
   333|                 }
   334|                 if (lhsLength == 0)
   335|                 {
   336|                     Debug.Assert(rhsLength == 0);
   337|                     return 0;
   338|                 }

# --- HUNK 3: Lines 553-676 ---
   553|                     if (value == 0)
   554|                     {
   555|                         SetZero(out result);
   556|                     }
   557|                     else
   558|                     {
   559|                         SetValue(out result, ref lhs);
   560|                     }
   561|                     return;
   562|                 }
   563|                 int lhsLength = lhs._length;
   564|                 int index = 0;
   565|                 uint carry = 0;
   566|                 while (index < lhsLength)
   567|                 {
   568|                     ulong product = ((ulong)(lhs._blocks[index]) * value) + carry;
   569|                     result._blocks[index] = (uint)(product);
   570|                     carry = (uint)(product >> 32);
   571|                     index++;
   572|                 }
   573|                 int resultLength = lhsLength;
   574|                 if (carry != 0)
   575|                 {
   576|                     Debug.Assert(unchecked((uint)(resultLength)) < MaxBlockCount);
   577|                     if (unchecked((uint)(resultLength)) >= MaxBlockCount)
   578|                     {
   579|                         SetZero(out result);
   580|                         return;
   581|                     }
   582|                     result._blocks[index] = carry;
   583|                     resultLength += 1;
   584|                 }
   585|                 result._length = resultLength;
   586|             }
   587|             public static void Multiply(ref BigInteger lhs, ref BigInteger rhs, out BigInteger result)
   588|             {
   589|                 if (lhs._length <= 1)
   590|                 {
   591|                     Multiply(ref rhs, lhs.ToUInt32(), out result);
   592|                     return;
   593|                 }
   594|                 if (rhs._length <= 1)
   595|                 {
   596|                     Multiply(ref lhs, rhs.ToUInt32(), out result);
   597|                     return;
   598|                 }
   599|                 ref readonly BigInteger large = ref lhs;
   600|                 int largeLength = lhs._length;
   601|                 ref readonly BigInteger small = ref rhs;
   602|                 int smallLength = rhs._length;
   603|                 if (largeLength < smallLength)
   604|                 {
   605|                     large = ref rhs;
   606|                     largeLength = rhs._length;
   607|                     small = ref lhs;
   608|                     smallLength = lhs._length;
   609|                 }
   610|                 int maxResultLength = smallLength + largeLength;
   611|                 Debug.Assert(unchecked((uint)(maxResultLength)) <= MaxBlockCount);
   612|                 if (unchecked((uint)(maxResultLength)) > MaxBlockCount)
   613|                 {
   614|                     SetZero(out result);
   615|                     return;
   616|                 }
   617|                 result._length = maxResultLength;
   618|                 result.Clear((uint)maxResultLength);
   619|                 int smallIndex = 0;
   620|                 int resultStartIndex = 0;
   621|                 while (smallIndex < smallLength)
   622|                 {
   623|                     if (small._blocks[smallIndex] != 0)
   624|                     {
   625|                         int largeIndex = 0;
   626|                         int resultIndex = resultStartIndex;
   627|                         ulong carry = 0;
   628|                         do
   629|                         {
   630|                             ulong product = result._blocks[resultIndex] + ((ulong)(small._blocks[smallIndex]) * large._blocks[largeIndex]) + carry;
   631|                             carry = product >> 32;
   632|                             result._blocks[resultIndex] = (uint)(product);
   633|                             resultIndex++;
   634|                             largeIndex++;
   635|                         }
   636|                         while (largeIndex < largeLength);
   637|                         result._blocks[resultIndex] = (uint)(carry);
   638|                     }
   639|                     smallIndex++;
   640|                     resultStartIndex++;
   641|                 }
   642|                 if ((maxResultLength > 0) && (result._blocks[maxResultLength - 1] == 0))
   643|                 {
   644|                     result._length--;
   645|                 }
   646|             }
   647|             public static void Pow2(uint exponent, out BigInteger result)
   648|             {
   649|                 uint blocksToShift = DivRem32(exponent, out uint remainingBitsToShift);
   650|                 result._length = (int)blocksToShift + 1;
   651|                 Debug.Assert(unchecked((uint)result._length) <= MaxBlockCount);
   652|                 if (unchecked((uint)result._length) > MaxBlockCount)
   653|                 {
   654|                     SetZero(out result);
   655|                     return;
   656|                 }
   657|                 if (blocksToShift > 0)
   658|                 {
   659|                     result.Clear(blocksToShift);
   660|                 }
   661|                 result._blocks[blocksToShift] = 1U << (int)(remainingBitsToShift);
   662|             }
   663|             public static void Pow10(uint exponent, out BigInteger result)
   664|             {
   665|                 Debug.Assert((s_Pow10BigNumTableIndices[^1] + MaxBlockCount + 2) == s_Pow10BigNumTable.Length);
   666|                 SetUInt32(out BigInteger temp1, s_Pow10UInt32Table[exponent & 0x7]);
   667|                 ref BigInteger lhs = ref temp1;
   668|                 SetZero(out BigInteger temp2);
   669|                 ref BigInteger product = ref temp2;
   670|                 exponent >>= 3;
   671|                 uint index = 0;
   672|                 while (exponent != 0)
   673|                 {
   674|                     if ((exponent & 1) != 0)
   675|                     {
   676|                         fixed (uint* pBigNumEntry = &s_Pow10BigNumTable[s_Pow10BigNumTableIndices[index]])

# --- HUNK 4: Lines 748-793 ---
   748|             {
   749|                 int length = _length;
   750|                 if (length == 0)
   751|                 {
   752|                     SetUInt32(out this, value);
   753|                     return;
   754|                 }
   755|                 _blocks[0] += value;
   756|                 if (_blocks[0] >= value)
   757|                 {
   758|                     return;
   759|                 }
   760|                 for (int index = 1; index < length; index++)
   761|                 {
   762|                     _blocks[index]++;
   763|                     if (_blocks[index] > 0)
   764|                     {
   765|                         return;
   766|                     }
   767|                 }
   768|                 Debug.Assert(unchecked((uint)(length)) < MaxBlockCount);
   769|                 if (unchecked((uint)(length)) >= MaxBlockCount)
   770|                 {
   771|                     SetZero(out this);
   772|                     return;
   773|                 }
   774|                 _blocks[length] = 1;
   775|                 _length = length + 1;
   776|             }
   777|             public uint GetBlock(uint index)
   778|             {
   779|                 Debug.Assert(index < _length);
   780|                 return _blocks[index];
   781|             }
   782|             public int GetLength()
   783|             {
   784|                 return _length;
   785|             }
   786|             public bool IsZero()
   787|             {
   788|                 return _length == 0;
   789|             }
   790|             public void Multiply(uint value)
   791|             {
   792|                 Multiply(ref this, value, out this);
   793|             }

# --- HUNK 5: Lines 805-852 ---
   805|             }
   806|             public void Multiply10()
   807|             {
   808|                 if (IsZero())
   809|                 {
   810|                     return;
   811|                 }
   812|                 int index = 0;
   813|                 int length = _length;
   814|                 ulong carry = 0;
   815|                 do
   816|                 {
   817|                     ulong block = (ulong)(_blocks[index]);
   818|                     ulong product = (block << 3) + (block << 1) + carry;
   819|                     carry = product >> 32;
   820|                     _blocks[index] = (uint)(product);
   821|                     index++;
   822|                 } while (index < length);
   823|                 if (carry != 0)
   824|                 {
   825|                     Debug.Assert(unchecked((uint)(length)) < MaxBlockCount);
   826|                     if (unchecked((uint)(length)) >= MaxBlockCount)
   827|                     {
   828|                         SetZero(out this);
   829|                         return;
   830|                     }
   831|                     _blocks[index] = (uint)carry;
   832|                     _length = length + 1;
   833|                 }
   834|             }
   835|             public void MultiplyPow10(uint exponent)
   836|             {
   837|                 if (exponent <= 9)
   838|                 {
   839|                     Multiply(s_Pow10UInt32Table[exponent]);
   840|                 }
   841|                 else if (!IsZero())
   842|                 {
   843|                     Pow10(exponent, out BigInteger poweredValue);
   844|                     Multiply(ref poweredValue);
   845|                 }
   846|             }
   847|             public static void SetUInt32(out BigInteger result, uint value)
   848|             {
   849|                 if (value == 0)
   850|                 {
   851|                     SetZero(out result);
   852|                 }

# --- HUNK 6: Lines 874-937 ---
   874|                 int rhsLength = value._length;
   875|                 result._length = rhsLength;
   876|                 Buffer.Memmove(ref result._blocks[0], ref value._blocks[0], (nuint)rhsLength);
   877|             }
   878|             public static void SetZero(out BigInteger result)
   879|             {
   880|                 result._length = 0;
   881|             }
   882|             public void ShiftLeft(uint shift)
   883|             {
   884|                 int length = _length;
   885|                 if ((length == 0) || (shift == 0))
   886|                 {
   887|                     return;
   888|                 }
   889|                 uint blocksToShift = DivRem32(shift, out uint remainingBitsToShift);
   890|                 int readIndex = (length - 1);
   891|                 int writeIndex = readIndex + (int)(blocksToShift);
   892|                 if (remainingBitsToShift == 0)
   893|                 {
   894|                     Debug.Assert(unchecked((uint)(length)) < MaxBlockCount);
   895|                     if (unchecked((uint)(length)) >= MaxBlockCount)
   896|                     {
   897|                         SetZero(out this);
   898|                         return;
   899|                     }
   900|                     while (readIndex >= 0)
   901|                     {
   902|                         _blocks[writeIndex] = _blocks[readIndex];
   903|                         readIndex--;
   904|                         writeIndex--;
   905|                     }
   906|                     _length += (int)(blocksToShift);
   907|                     Clear(blocksToShift);
   908|                 }
   909|                 else
   910|                 {
   911|                     writeIndex++;
   912|                     Debug.Assert(unchecked((uint)(length)) < MaxBlockCount);
   913|                     if (unchecked((uint)(length)) >= MaxBlockCount)
   914|                     {
   915|                         SetZero(out this);
   916|                         return;
   917|                     }
   918|                     _length = writeIndex + 1;
   919|                     uint lowBitsShift = (32 - remainingBitsToShift);
   920|                     uint highBits = 0;
   921|                     uint block = _blocks[readIndex];
   922|                     uint lowBits = block >> (int)(lowBitsShift);
   923|                     while (readIndex > 0)
   924|                     {
   925|                         _blocks[writeIndex] = highBits | lowBits;
   926|                         highBits = block << (int)(remainingBitsToShift);
   927|                         --readIndex;
   928|                         --writeIndex;
   929|                         block = _blocks[readIndex];
   930|                         lowBits = block >> (int)lowBitsShift;
   931|                     }
   932|                     _blocks[writeIndex] = highBits | lowBits;
   933|                     _blocks[writeIndex - 1] = block << (int)(remainingBitsToShift);
   934|                     Clear(blocksToShift);
   935|                     if (_blocks[_length - 1] == 0)
   936|                     {
   937|                         _length--;


# ====================================================================
# FILE: src/libraries/System.Private.CoreLib/src/System/Runtime/InteropServices/NFloat.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-262 ---
     1| using System.Diagnostics.CodeAnalysis;
     2| using System.Globalization;
     3| using System.Runtime.CompilerServices;
     4| using System.Runtime.InteropServices;
     5| using System.Runtime.Versioning;
     6| using Internal.Runtime.CompilerServices;
     7| #pragma warning disable SA1121 // We use our own aliases since they differ per platform
     8| #if TARGET_32BIT
     9| using NativeType = System.Single;
    10| #else
    11| using NativeType = System.Double;
    12| #endif
    13| namespace System.Runtime.InteropServices
    14| {
    15|     [Intrinsic]
    16|     public readonly struct NFloat
    17|         : IComparable,
    18|           IComparable<NFloat>,
    19|           IEquatable<NFloat>,
    20|           ISpanFormattable
    21|     {
    22|         private const NumberStyles DefaultNumberStyles = NumberStyles.Float | NumberStyles.AllowThousands;
    23|         private readonly NativeType _value;
    24|         [NonVersionable]
    25|         public NFloat(float value)
    26|         {
    27|             _value = value;
    28|         }
    29|         [NonVersionable]
    30|         public NFloat(double value)
    31|         {
    32|             _value = (NativeType)value;
    33|         }
    34|         public static NFloat Epsilon
    35|         {
    36|             [NonVersionable]
    37|             get => new NFloat(NativeType.Epsilon);
    38|         }
    39|         public static NFloat MaxValue
    40|         {
    41|             [NonVersionable]
    42|             get => new NFloat(NativeType.MaxValue);
    43|         }
    44|         public static NFloat MinValue
    45|         {
    46|             [NonVersionable]
    47|             get => new NFloat(NativeType.MinValue);
    48|         }
    49|         public static NFloat NaN
    50|         {
    51|             [NonVersionable]
    52|             get => new NFloat(NativeType.NaN);
    53|         }
    54|         public static NFloat NegativeInfinity
    55|         {
    56|             [NonVersionable]
    57|             get => new NFloat(NativeType.NegativeInfinity);
    58|         }
    59|         public static NFloat PositiveInfinity
    60|         {
    61|             [NonVersionable]
    62|             get => new NFloat(NativeType.PositiveInfinity);
    63|         }
    64|         public static int Size
    65|         {
    66|             [NonVersionable]
    67|             get => sizeof(NativeType);
    68|         }
    69|         public double Value
    70|         {
    71|             [NonVersionable]
    72|             get => _value;
    73|         }
    74|         [NonVersionable]
    75|         public static NFloat operator +(NFloat value) => value;
    76|         [NonVersionable]
    77|         public static NFloat operator -(NFloat value) => new NFloat(-value._value);
    78|         [NonVersionable]
    79|         public static NFloat operator ++(NFloat value) => new NFloat(value._value + 1);
    80|         [NonVersionable]
    81|         public static NFloat operator --(NFloat value) => new NFloat(value._value - 1);
    82|         [NonVersionable]
    83|         public static NFloat operator +(NFloat left, NFloat right) => new NFloat(left._value + right._value);
    84|         [NonVersionable]
    85|         public static NFloat operator -(NFloat left, NFloat right) => new NFloat(left._value - right._value);
    86|         [NonVersionable]
    87|         public static NFloat operator *(NFloat left, NFloat right) => new NFloat(left._value * right._value);
    88|         [NonVersionable]
    89|         public static NFloat operator /(NFloat left, NFloat right) => new NFloat(left._value / right._value);
    90|         [NonVersionable]
    91|         public static NFloat operator %(NFloat left, NFloat right) => new NFloat(left._value % right._value);
    92|         [NonVersionable]
    93|         public static bool operator ==(NFloat left, NFloat right) => left._value == right._value;
    94|         [NonVersionable]
    95|         public static bool operator !=(NFloat left, NFloat right) => left._value != right._value;
    96|         [NonVersionable]
    97|         public static bool operator <(NFloat left, NFloat right) => left._value < right._value;
    98|         [NonVersionable]
    99|         public static bool operator <=(NFloat left, NFloat right) => left._value <= right._value;
   100|         [NonVersionable]
   101|         public static bool operator >(NFloat left, NFloat right) => left._value > right._value;
   102|         [NonVersionable]
   103|         public static bool operator >=(NFloat left, NFloat right) => left._value >= right._value;
   104|         [NonVersionable]
   105|         public static explicit operator NFloat(decimal value) => new NFloat((NativeType)value);
   106|         [NonVersionable]
   107|         public static explicit operator NFloat(double value) => new NFloat((NativeType)value);
   108|         [NonVersionable]
   109|         public static explicit operator byte(NFloat value) => (byte)(value._value);
   110|         [NonVersionable]
   111|         public static explicit operator char(NFloat value) => (char)(value._value);
   112|         [NonVersionable]
   113|         public static explicit operator decimal(NFloat value) => (decimal)(value._value);
   114|         [NonVersionable]
   115|         public static explicit operator short(NFloat value) => (short)(value._value);
   116|         [NonVersionable]
   117|         public static explicit operator int(NFloat value) => (int)(value._value);
   118|         [NonVersionable]
   119|         public static explicit operator long(NFloat value) => (long)(value._value);
   120|         [NonVersionable]
   121|         public static explicit operator nint(NFloat value) => (nint)(value._value);
   122|         [NonVersionable]
   123|         [CLSCompliant(false)]
   124|         public static explicit operator sbyte(NFloat value) => (sbyte)(value._value);
   125|         [NonVersionable]
   126|         public static explicit operator float(NFloat value) => (float)(value._value);
   127|         [NonVersionable]
   128|         [CLSCompliant(false)]
   129|         public static explicit operator ushort(NFloat value) => (ushort)(value._value);
   130|         [NonVersionable]
   131|         [CLSCompliant(false)]
   132|         public static explicit operator uint(NFloat value) => (uint)(value._value);
   133|         [NonVersionable]
   134|         [CLSCompliant(false)]
   135|         public static explicit operator ulong(NFloat value) => (ulong)(value._value);
   136|         [NonVersionable]
   137|         [CLSCompliant(false)]
   138|         public static explicit operator nuint(NFloat value) => (nuint)(value._value);
   139|         [NonVersionable]
   140|         public static implicit operator NFloat(byte value) => new NFloat((NativeType)value);
   141|         [NonVersionable]
   142|         public static implicit operator NFloat(char value) => new NFloat((NativeType)value);
   143|         [NonVersionable]
   144|         public static implicit operator NFloat(short value) => new NFloat((NativeType)value);
   145|         [NonVersionable]
   146|         public static implicit operator NFloat(int value) => new NFloat((NativeType)value);
   147|         [NonVersionable]
   148|         public static implicit operator NFloat(long value) => new NFloat((NativeType)value);
   149|         [NonVersionable]
   150|         public static implicit operator NFloat(nint value) => new NFloat((NativeType)value);
   151|         [NonVersionable]
   152|         [CLSCompliant(false)]
   153|         public static implicit operator NFloat(sbyte value) => new NFloat((NativeType)value);
   154|         [NonVersionable]
   155|         public static implicit operator NFloat(float value) => new NFloat((NativeType)value);
   156|         [NonVersionable]
   157|         [CLSCompliant(false)]
   158|         public static implicit operator NFloat(ushort value) => new NFloat((NativeType)value);
   159|         [NonVersionable]
   160|         [CLSCompliant(false)]
   161|         public static implicit operator NFloat(uint value) => new NFloat((NativeType)value);
   162|         [NonVersionable]
   163|         [CLSCompliant(false)]
   164|         public static implicit operator NFloat(ulong value) => new NFloat((NativeType)value);
   165|         [NonVersionable]
   166|         [CLSCompliant(false)]
   167|         public static implicit operator NFloat(nuint value) => new NFloat((NativeType)value);
   168|         public static implicit operator double(NFloat value) => (double)(value._value);
   169|         [NonVersionable]
   170|         public static bool IsFinite(NFloat value) => NativeType.IsFinite(value._value);
   171|         [NonVersionable]
   172|         public static bool IsInfinity(NFloat value) => NativeType.IsInfinity(value._value);
   173|         [NonVersionable]
   174|         public static bool IsNaN(NFloat value) => NativeType.IsNaN(value._value);
   175|         [NonVersionable]
   176|         public static bool IsNegative(NFloat value) => NativeType.IsNegative(value._value);
   177|         [NonVersionable]
   178|         public static bool IsNegativeInfinity(NFloat value) => NativeType.IsNegativeInfinity(value._value);
   179|         [NonVersionable]
   180|         public static bool IsNormal(NFloat value) => NativeType.IsNormal(value._value);
   181|         [NonVersionable]
   182|         public static bool IsPositiveInfinity(NFloat value) => NativeType.IsPositiveInfinity(value._value);
   183|         [NonVersionable]
   184|         public static bool IsSubnormal(NFloat value) => NativeType.IsSubnormal(value._value);
   185|         public static NFloat Parse(string s)
   186|         {
   187|             var result = NativeType.Parse(s);
   188|             return new NFloat(result);
   189|         }
   190|         public static NFloat Parse(string s, NumberStyles style)
   191|         {
   192|             var result = NativeType.Parse(s, style);
   193|             return new NFloat(result);
   194|         }
   195|         public static NFloat Parse(string s, IFormatProvider? provider)
   196|         {
   197|             var result = NativeType.Parse(s, provider);
   198|             return new NFloat(result);
   199|         }
   200|         public static NFloat Parse(string s, NumberStyles style, IFormatProvider? provider)
   201|         {
   202|             var result = NativeType.Parse(s, style, provider);
   203|             return new NFloat(result);
   204|         }
   205|         public static NFloat Parse(ReadOnlySpan<char> s, NumberStyles style = DefaultNumberStyles, IFormatProvider? provider = null)
   206|         {
   207|             var result = NativeType.Parse(s, style, provider);
   208|             return new NFloat(result);
   209|         }
   210|         public static bool TryParse([NotNullWhen(true)] string? s, out NFloat result)
   211|         {
   212|             Unsafe.SkipInit(out result);
   213|             return NativeType.TryParse(s, out Unsafe.As<NFloat, NativeType>(ref result));
   214|         }
   215|         public static bool TryParse(ReadOnlySpan<char> s, out NFloat result)
   216|         {
   217|             Unsafe.SkipInit(out result);
   218|             return NativeType.TryParse(s, out Unsafe.As<NFloat, NativeType>(ref result));
   219|         }
   220|         public static bool TryParse([NotNullWhen(true)] string? s, NumberStyles style, IFormatProvider? provider, out NFloat result)
   221|         {
   222|             Unsafe.SkipInit(out result);
   223|             return NativeType.TryParse(s, style, provider, out Unsafe.As<NFloat, NativeType>(ref result));
   224|         }
   225|         public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider, out NFloat result)
   226|         {
   227|             Unsafe.SkipInit(out result);
   228|             return NativeType.TryParse(s, style, provider, out Unsafe.As<NFloat, NativeType>(ref result));
   229|         }
   230|         public int CompareTo(object? obj)
   231|         {
   232|             if (obj is NFloat other)
   233|             {
   234|                 if (_value < other._value) return -1;
   235|                 if (_value > other._value) return 1;
   236|                 if (_value == other._value) return 0;
   237|                 if (NativeType.IsNaN(_value))
   238|                 {
   239|                     return NativeType.IsNaN(other._value) ? 0 : -1;
   240|                 }
   241|                 else
   242|                 {
   243|                     return 1;
   244|                 }
   245|             }
   246|             else if (obj is null)
   247|             {
   248|                 return 1;
   249|             }
   250|             throw new ArgumentException(SR.Arg_MustBeNFloat);
   251|         }
   252|         public int CompareTo(NFloat other) => _value.CompareTo(other._value);
   253|         public override bool Equals([NotNullWhen(true)] object? obj) => (obj is NFloat other) && Equals(other);
   254|         public bool Equals(NFloat other) => _value.Equals(other._value);
   255|         public override int GetHashCode() => _value.GetHashCode();
   256|         public override string ToString() => _value.ToString();
   257|         public string ToString(string? format) => _value.ToString(format);
   258|         public string ToString(IFormatProvider? provider)=> _value.ToString(provider);
   259|         public string ToString(string? format, IFormatProvider? provider) => _value.ToString(format, provider);
   260|         public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default, IFormatProvider? provider = null) => _value.TryFormat(destination, out charsWritten, format, provider);
   261|     }
   262| }


# ====================================================================
# FILE: src/libraries/System.Private.CoreLib/src/System/TimeOnly.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 359-404 ---
   359|                         if (!DateTimeFormat.TryFormatTimeOnlyO(Hour, Minute, Second, _ticks % TimeSpan.TicksPerSecond, destination))
   360|                         {
   361|                             charsWritten = 0;
   362|                             return false;
   363|                         }
   364|                         charsWritten = 16;
   365|                         return true;
   366|                     case 'r':
   367|                     case 'R':
   368|                         if (!DateTimeFormat.TryFormatTimeOnlyR(Hour, Minute, Second, destination))
   369|                         {
   370|                             charsWritten = 0;
   371|                             return false;
   372|                         }
   373|                         charsWritten = 8;
   374|                         return true;
   375|                     case 't':
   376|                     case 'T':
   377|                         return DateTimeFormat.TryFormat(ToDateTime(), destination, out charsWritten, format, provider);
   378|                     default:
   379|                         throw new FormatException(SR.Argument_BadFormatSpecifier);
   380|                 }
   381|             }
   382|             if (!DateTimeFormat.IsValidCustomTimeFormat(format, throwOnError: false))
   383|             {
   384|                 throw new FormatException(SR.Format(SR.Format_DateTimeOnlyContainsNoneDateParts, format.ToString(), nameof(TimeOnly)));
   385|             }
   386|             return DateTimeFormat.TryFormat(ToDateTime(), destination, out charsWritten, format, provider);
   387|         }
   388| #if FEATURE_GENERIC_MATH
   389|         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]
   390|         static bool IComparisonOperators<TimeOnly, TimeOnly>.operator <(TimeOnly left, TimeOnly right)
   391|             => left < right;
   392|         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]
   393|         static bool IComparisonOperators<TimeOnly, TimeOnly>.operator <=(TimeOnly left, TimeOnly right)
   394|             => left <= right;
   395|         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]
   396|         static bool IComparisonOperators<TimeOnly, TimeOnly>.operator >(TimeOnly left, TimeOnly right)
   397|             => left > right;
   398|         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]
   399|         static bool IComparisonOperators<TimeOnly, TimeOnly>.operator >=(TimeOnly left, TimeOnly right)
   400|             => left >= right;
   401|         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]
   402|         static bool IEqualityOperators<TimeOnly, TimeOnly>.operator ==(TimeOnly left, TimeOnly right)
   403|             => left == right;
   404|         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]


# ====================================================================
# FILE: src/libraries/System.Private.CoreLib/src/System/TimeZoneInfo.Unix.Android.cs
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 147-320 ---
   147|         * data offset - 4 bytes that denotes the offset at which the data of the tzdata file starts
   148|         * final offset - 4 bytes that used to denote the final offset, which we don't use but will note.
   149|         *
   150|         * Each Data Entry (52 bytes) can be used to generate a TimeZoneInfo and contain the following information
   151|         * id - 40 bytes that contain the id of the time zone data entry timezone<id>
   152|         * byte offset - 4 bytes that denote the offset from the data offset timezone<id> data can be found
   153|         * length - 4 bytes that denote the length of the data for timezone<id>
   154|         * unused - 4 bytes that used to be raw GMT offset, but now is always 0 since tzdata2014f (L).
   155|         *
   156|         * This is needed in order to read Android v4.3 tzdata files.
   157|         *
   158|         * Android 10+ moved the up-to-date tzdata location to a module updatable via the Google Play Store and the
   159|         * database location changed (https://source.android.com/devices/architecture/modular-system/runtime#time-zone-data-interactions)
   160|         * The older locations still exist (at least the `/system/usr/share/zoneinfo` one) but they won't be updated.
   161|         */
   162|         private sealed class AndroidTzData
   163|         {
   164|             private string[] _ids;
   165|             private int[] _byteOffsets;
   166|             private int[] _lengths;
   167|             private bool[] _isBackwards;
   168|             private string _tzFileDir;
   169|             private string _tzFilePath;
   170|             private static string GetApexTimeDataRoot()
   171|             {
   172|                 string? ret = Environment.GetEnvironmentVariable("ANDROID_TZDATA_ROOT");
   173|                 if (!string.IsNullOrEmpty(ret))
   174|                 {
   175|                     return ret;
   176|                 }
   177|                 return "/apex/com.android.tzdata";
   178|             }
   179|             private static string GetApexRuntimeRoot()
   180|             {
   181|                 string? ret = Environment.GetEnvironmentVariable("ANDROID_RUNTIME_ROOT");
   182|                 if (!string.IsNullOrEmpty(ret))
   183|                 {
   184|                     return ret;
   185|                 }
   186|                 return "/apex/com.android.runtime";
   187|             }
   188|             public AndroidTzData()
   189|             {
   190|                 string[] tzFileDirList = new string[] {GetApexTimeDataRoot() + "/etc/tz/", // Android 10+, TimeData module where the updates land
   191|                                                        GetApexRuntimeRoot() + "/etc/tz/", // Android 10+, Fallback location if the above isn't found or corrupted
   192|                                                        Environment.GetEnvironmentVariable("ANDROID_DATA") + "/misc/zoneinfo/",
   193|                                                        Environment.GetEnvironmentVariable("ANDROID_ROOT") + DefaultTimeZoneDirectory};
   194|                 foreach (var tzFileDir in tzFileDirList)
   195|                 {
   196|                     string tzFilePath = Path.Combine(tzFileDir, TimeZoneFileName);
   197|                     if (LoadData(tzFileDir, tzFilePath))
   198|                     {
   199|                         _tzFileDir = tzFileDir;
   200|                         _tzFilePath = tzFilePath;
   201|                         return;
   202|                     }
   203|                 }
   204|                 throw new TimeZoneNotFoundException(SR.TimeZoneNotFound_ValidTimeZoneFileMissing);
   205|             }
   206|             private void FilterBackwardIDs(string tzFileDir, out HashSet<string> tzLookupIDs)
   207|             {
   208|                 tzLookupIDs = new HashSet<string>();
   209|                 try
   210|                 {
   211|                     using (StreamReader sr = File.OpenText(Path.Combine(tzFileDir, "tzlookup.xml")))
   212|                     {
   213|                         string? tzLookupLine;
   214|                         while (sr.Peek() >= 0)
   215|                         {
   216|                             if (!(tzLookupLine = sr.ReadLine())!.AsSpan().TrimStart().StartsWith("<id", StringComparison.Ordinal))
   217|                                 continue;
   218|                             int idStart = tzLookupLine!.IndexOf('>') + 1;
   219|                             int idLength = tzLookupLine.LastIndexOf("</", StringComparison.Ordinal) - idStart;
   220|                             if (idStart <= 0 || idLength < 0)
   221|                             {
   222|                                 continue;
   223|                             }
   224|                             string id = tzLookupLine.Substring(idStart, idLength);
   225|                             tzLookupIDs.Add(id);
   226|                         }
   227|                     }
   228|                 }
   229|                 catch {}
   230|             }
   231|             [MemberNotNullWhen(true, nameof(_ids))]
   232|             [MemberNotNullWhen(true, nameof(_byteOffsets))]
   233|             [MemberNotNullWhen(true, nameof(_lengths))]
   234|             [MemberNotNullWhen(true, nameof(_isBackwards))]
   235|             private bool LoadData(string tzFileDir, string path)
   236|             {
   237|                 if (!File.Exists(path))
   238|                 {
   239|                     return false;
   240|                 }
   241|                 try
   242|                 {
   243|                     using (FileStream fs = File.OpenRead(path))
   244|                     {
   245|                         LoadTzFile(tzFileDir, fs);
   246|                     }
   247|                     return true;
   248|                 }
   249|                 catch {}
   250|                 return false;
   251|             }
   252|             [MemberNotNull(nameof(_ids))]
   253|             [MemberNotNull(nameof(_byteOffsets))]
   254|             [MemberNotNull(nameof(_lengths))]
   255|             [MemberNotNull(nameof(_isBackwards))]
   256|             private void LoadTzFile(string tzFileDir, Stream fs)
   257|             {
   258|                 const int HeaderSize = 24;
   259|                 Span<byte> buffer = stackalloc byte[HeaderSize];
   260|                 ReadTzDataIntoBuffer(fs, 0, buffer);
   261|                 LoadHeader(buffer, out int indexOffset, out int dataOffset);
   262|                 ReadIndex(tzFileDir, fs, indexOffset, dataOffset);
   263|             }
   264|             private void LoadHeader(Span<byte> buffer, out int indexOffset, out int dataOffset)
   265|             {
   266|                 var tz = (ushort)TZif_ToInt16(buffer.Slice(0, 2));
   267|                 var data = (uint)TZif_ToInt32(buffer.Slice(2, 4));
   268|                 if (tz != 0x747A || data != 0x64617461 || buffer[11] != 0)
   269|                 {
   270|                     var b = new StringBuilder(buffer.Length);
   271|                     for (int i = 0; i < 12; ++i)
   272|                     {
   273|                         b.Append(' ').Append(HexConverter.ToCharLower(buffer[i]));
   274|                     }
   275|                     throw new InvalidOperationException(SR.Format(SR.InvalidOperation_BadTZHeader, TimeZoneFileName, b.ToString()));
   276|                 }
   277|                 indexOffset = TZif_ToInt32(buffer.Slice(12, 4));
   278|                 dataOffset = TZif_ToInt32(buffer.Slice(16, 4));
   279|             }
   280|             [MemberNotNull(nameof(_ids))]
   281|             [MemberNotNull(nameof(_byteOffsets))]
   282|             [MemberNotNull(nameof(_lengths))]
   283|             [MemberNotNull(nameof(_isBackwards))]
   284|             private void ReadIndex(string tzFileDir, Stream fs, int indexOffset, int dataOffset)
   285|             {
   286|                 int indexSize = dataOffset - indexOffset;
   287|                 const int entrySize = 52; // Data entry size
   288|                 int entryCount = indexSize / entrySize;
   289|                 _byteOffsets = new int[entryCount];
   290|                 _ids = new string[entryCount];
   291|                 _lengths = new int[entryCount];
   292|                 _isBackwards = new bool[entryCount];
   293|                 FilterBackwardIDs(tzFileDir, out HashSet<string> tzLookupIDs);
   294|                 for (int i = 0; i < entryCount; ++i)
   295|                 {
   296|                     LoadEntryAt(fs, indexOffset + (entrySize*i), out string id, out int byteOffset, out int length);
   297|                     _byteOffsets[i] = byteOffset + dataOffset;
   298|                     _ids[i] = id;
   299|                     _lengths[i] = length;
   300|                     _isBackwards[i] = !tzLookupIDs.Contains(id);
   301|                     if (length < 24) // Header Size
   302|                     {
   303|                         throw new InvalidOperationException(SR.InvalidOperation_BadIndexLength);
   304|                     }
   305|                 }
   306|             }
   307|             private void ReadTzDataIntoBuffer(Stream fs, long position, Span<byte> buffer)
   308|             {
   309|                 fs.Position = position;
   310|                 int bytesRead = 0;
   311|                 int bytesLeft = buffer.Length;
   312|                 while (bytesLeft > 0)
   313|                 {
   314|                     int b = fs.Read(buffer.Slice(bytesRead));
   315|                     if (b == 0)
   316|                     {
   317|                         break;
   318|                     }
   319|                     bytesRead += b;
   320|                     bytesLeft -= b;

# --- HUNK 2: Lines 323-381 ---
   323|                 {
   324|                     throw new InvalidOperationException(SR.Format(SR.InvalidOperation_ReadTZError, _tzFilePath, position, buffer.Length, bytesRead, buffer.Length));
   325|                 }
   326|             }
   327|             private void LoadEntryAt(Stream fs, long position, out string id, out int byteOffset, out int length)
   328|             {
   329|                 const int size = 52; // data entry size
   330|                 Span<byte> entryBuffer = stackalloc byte[size];
   331|                 ReadTzDataIntoBuffer(fs, position, entryBuffer);
   332|                 int index = 0;
   333|                 while (entryBuffer[index] != 0 && index < 40)
   334|                 {
   335|                     index += 1;
   336|                 }
   337|                 id = Encoding.UTF8.GetString(entryBuffer.Slice(0, index));
   338|                 byteOffset = TZif_ToInt32(entryBuffer.Slice(40, 4));
   339|                 length = TZif_ToInt32(entryBuffer.Slice(44, 4));
   340|             }
   341|             public string[] GetTimeZoneIds()
   342|             {
   343|                 int numTimeZoneIDs = 0;
   344|                 for (int i = 0; i < _ids.Length; i++)
   345|                 {
   346|                     if (!_isBackwards[i])
   347|                     {
   348|                         numTimeZoneIDs++;
   349|                     }
   350|                 }
   351|                 string[] nonBackwardsTZIDs = new string[numTimeZoneIDs];
   352|                 var index = 0;
   353|                 for (int i = 0; i < _ids.Length; i++)
   354|                 {
   355|                     if (!_isBackwards[i])
   356|                     {
   357|                         nonBackwardsTZIDs[index] = _ids[i];
   358|                         index++;
   359|                     }
   360|                 }
   361|                 return nonBackwardsTZIDs;
   362|             }
   363|             public string GetTimeZoneDirectory()
   364|             {
   365|                 return _tzFilePath;
   366|             }
   367|             public byte[] GetTimeZoneData(string id)
   368|             {
   369|                 int i = Array.BinarySearch(_ids, id, StringComparer.Ordinal);
   370|                 if (i < 0)
   371|                 {
   372|                     throw new InvalidOperationException(SR.Format(SR.TimeZoneNotFound_MissingData, id));
   373|                 }
   374|                 int offset = _byteOffsets[i];
   375|                 int length = _lengths[i];
   376|                 byte[] buffer = new byte[length];
   377|                 using (FileStream fs = File.OpenRead(_tzFilePath))
   378|                 {
   379|                     ReadTzDataIntoBuffer(fs, offset, buffer);
   380|                 }
   381|                 return buffer;


# ====================================================================
# FILE: src/libraries/System.Reflection.Metadata/src/System/Reflection/PortableExecutable/ManagedTextSection.cs
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 37-95 ---
    37|         public bool Is32Bit => !Requires64bits;
    38|         public const int ManagedResourcesDataAlignment = 8;
    39|         private const string CorEntryPointDll = "mscoree.dll";
    40|         private string CorEntryPointName => (ImageCharacteristics & Characteristics.Dll) != 0 ? "_CorDllMain" : "_CorExeMain";
    41|         private int SizeOfImportAddressTable => RequiresStartupStub ? (Is32Bit ? 2 * sizeof(uint) : 2 * sizeof(ulong)) : 0;
    42|         private int SizeOfImportTable =>
    43|             sizeof(uint) + // RVA
    44|             sizeof(uint) + // 0
    45|             sizeof(uint) + // 0
    46|             sizeof(uint) + // name RVA
    47|             sizeof(uint) + // import address table RVA
    48|             20 +           // ?
    49|             (Is32Bit ? 3 * sizeof(uint) : 2 * sizeof(ulong)) + // import lookup table
    50|             sizeof(ushort) + // hint
    51|             CorEntryPointName.Length +
    52|             1;    // NUL
    53|         private static int SizeOfNameTable =>
    54|             CorEntryPointDll.Length + 1 + sizeof(ushort);
    55|         private int SizeOfRuntimeStartupStub => Is32Bit ? 8 : 16;
    56|         public const int MappedFieldDataAlignment = 8;
    57|         internal int CalculateOffsetToMappedFieldDataStreamUnaligned()
    58|         {
    59|             int result = ComputeOffsetToImportTable();
    60|             if (RequiresStartupStub)
    61|             {
    62|                 result += SizeOfImportTable + SizeOfNameTable;
    63|                 result = BitArithmetic.Align(result, Is32Bit ? 4 : 8); //optional padding to make startup stub's target address align on word or double word boundary
    64|                 result += SizeOfRuntimeStartupStub;
    65|             }
    66|             return result;
    67|         }
    68|         public int CalculateOffsetToMappedFieldDataStream()
    69|         {
    70|              int result = CalculateOffsetToMappedFieldDataStreamUnaligned();
    71|              if (MappedFieldDataSize != 0)
    72|              {
    73|                  result = BitArithmetic.Align(result, MappedFieldDataAlignment);
    74|              }
    75|              return result;
    76|         }
    77|         internal int ComputeOffsetToDebugDirectory()
    78|         {
    79|             Debug.Assert(MetadataSize % 4 == 0);
    80|             Debug.Assert(ResourceDataSize % 4 == 0);
    81|             return
    82|                 ComputeOffsetToMetadata() +
    83|                 MetadataSize +
    84|                 ResourceDataSize +
    85|                 StrongNameSignatureSize;
    86|         }
    87|         private int ComputeOffsetToImportTable()
    88|         {
    89|             return
    90|                 ComputeOffsetToDebugDirectory() +
    91|                 DebugDataSize;
    92|         }
    93|         private const int CorHeaderSize =
    94|             sizeof(int) +    // header size
    95|             sizeof(short) +  // major runtime version

# --- HUNK 2: Lines 99-139 ---
    99|             sizeof(int) +    // entry point
   100|             sizeof(long) +   // resources directory
   101|             sizeof(long) +   // strong name signature directory
   102|             sizeof(long) +   // code manager table directory
   103|             sizeof(long) +   // vtable fixups directory
   104|             sizeof(long) +   // export address table jumps directory
   105|             sizeof(long);   // managed-native header directory
   106|         public int OffsetToILStream => SizeOfImportAddressTable + CorHeaderSize;
   107|         private int ComputeOffsetToMetadata()
   108|         {
   109|             return OffsetToILStream + BitArithmetic.Align(ILStreamSize, 4);
   110|         }
   111|         public int ComputeSizeOfTextSection()
   112|         {
   113|             Debug.Assert(MappedFieldDataSize % MappedFieldDataAlignment == 0);
   114|             return CalculateOffsetToMappedFieldDataStream() + MappedFieldDataSize;
   115|         }
   116|         public int GetEntryPointAddress(int rva)
   117|         {
   118|             return RequiresStartupStub ?
   119|                 rva + CalculateOffsetToMappedFieldDataStreamUnaligned() - (Is32Bit ? 6 : 10) :
   120|                 0;
   121|         }
   122|         public DirectoryEntry GetImportAddressTableDirectoryEntry(int rva)
   123|         {
   124|             return RequiresStartupStub ?
   125|                 new DirectoryEntry(rva, SizeOfImportAddressTable) :
   126|                 default(DirectoryEntry);
   127|         }
   128|         public DirectoryEntry GetImportTableDirectoryEntry(int rva)
   129|         {
   130|             return RequiresStartupStub ?
   131|                 new DirectoryEntry(rva + ComputeOffsetToImportTable(), (Is32Bit ? 66 : 70) + 13) :
   132|                 default(DirectoryEntry);
   133|         }
   134|         public DirectoryEntry GetCorHeaderDirectoryEntry(int rva)
   135|         {
   136|             return new DirectoryEntry(rva + SizeOfImportAddressTable, CorHeaderSize);
   137|         }
   138|         #region Serialization
   139|         public void Serialize(

# --- HUNK 3: Lines 167-208 ---
   167|             builder.LinkSuffix(ilBuilder);
   168|             builder.LinkSuffix(metadataBuilder);
   169|             if (resourceBuilderOpt != null)
   170|             {
   171|                 builder.LinkSuffix(resourceBuilderOpt);
   172|             }
   173|             strongNameSignature = builder.ReserveBytes(StrongNameSignatureSize);
   174|             new BlobWriter(strongNameSignature).WriteBytes(0, StrongNameSignatureSize);
   175|             if (debugDataBuilderOpt != null)
   176|             {
   177|                 builder.LinkSuffix(debugDataBuilderOpt);
   178|             }
   179|             if (RequiresStartupStub)
   180|             {
   181|                 WriteImportTable(builder, importTableRva, importAddressTableRva);
   182|                 WriteNameTable(builder);
   183|                 WriteRuntimeStartupStub(builder, importAddressTableRva, baseAddress);
   184|             }
   185|             if (mappedFieldDataBuilderOpt != null)
   186|             {
   187|                 if (mappedFieldDataBuilderOpt.Count != 0)
   188|                     builder.Align(MappedFieldDataAlignment);
   189|                 builder.LinkSuffix(mappedFieldDataBuilderOpt);
   190|             }
   191|             Debug.Assert(builder.Count == ComputeSizeOfTextSection());
   192|         }
   193|         private void WriteImportAddressTable(BlobBuilder builder, int importTableRva)
   194|         {
   195|             int start = builder.Count;
   196|             int ilRva = importTableRva + 40;
   197|             int hintRva = ilRva + (Is32Bit ? 12 : 16);
   198|             if (Is32Bit)
   199|             {
   200|                 builder.WriteUInt32((uint)hintRva); // 4
   201|                 builder.WriteUInt32(0); // 8
   202|             }
   203|             else
   204|             {
   205|                 builder.WriteUInt64((uint)hintRva); // 8
   206|                 builder.WriteUInt64(0); // 16
   207|             }
   208|             Debug.Assert(builder.Count - start == SizeOfImportAddressTable);


# ====================================================================
# FILE: src/libraries/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 134-181 ---
   134|         FastCall = 5,
   135|     }
   136|     [System.AttributeUsageAttribute(System.AttributeTargets.Assembly | System.AttributeTargets.Class, Inherited=false)]
   137|     public sealed partial class ClassInterfaceAttribute : System.Attribute
   138|     {
   139|         public ClassInterfaceAttribute(short classInterfaceType) { }
   140|         public ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType classInterfaceType) { }
   141|         public System.Runtime.InteropServices.ClassInterfaceType Value { get { throw null; } }
   142|     }
   143|     public enum ClassInterfaceType
   144|     {
   145|         None = 0,
   146|         [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
   147|         [System.ObsoleteAttribute("Support for IDispatch may be unavailable in future releases.")]
   148|         AutoDispatch = 1,
   149|         [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
   150|         [System.ObsoleteAttribute("Support for IDispatch may be unavailable in future releases.")]
   151|         AutoDual = 2,
   152|     }
   153|     [System.CLSCompliantAttribute(false)]
   154|     public readonly partial struct CLong : System.IEquatable<System.Runtime.InteropServices.CLong>
   155|     {
   156|         private readonly int _dummyPrimitive;
   157|         public CLong(int value) { throw null; }
   158|         public CLong(nint value) { throw null; }
   159|         public nint Value { get { throw null; } }
   160|         public override bool Equals([System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] object? o) { throw null; }
   161|         public bool Equals(System.Runtime.InteropServices.CLong other) { throw null; }
   162|         public override int GetHashCode() { throw null; }
   163|         public override string ToString() { throw null; }
   164|     }
   165|     [System.AttributeUsageAttribute(System.AttributeTargets.Interface, Inherited=false)]
   166|     public sealed partial class CoClassAttribute : System.Attribute
   167|     {
   168|         public CoClassAttribute(System.Type coClass) { }
   169|         public System.Type CoClass { get { throw null; } }
   170|     }
   171|     public static partial class CollectionsMarshal
   172|     {
   173|         public static System.Span<T> AsSpan<T>(System.Collections.Generic.List<T>? list) { throw null; }
   174|         public static ref TValue GetValueRefOrNullRef<TKey, TValue>(System.Collections.Generic.Dictionary<TKey, TValue> dictionary, TKey key) where TKey : notnull { throw null; }
   175|         public static ref TValue? GetValueRefOrAddDefault<TKey, TValue>(System.Collections.Generic.Dictionary<TKey, TValue> dictionary, TKey key, out bool exists) where TKey : notnull { throw null; }
   176|     }
   177|     [System.AttributeUsageAttribute(System.AttributeTargets.Field | System.AttributeTargets.Parameter | System.AttributeTargets.Property | System.AttributeTargets.ReturnValue, Inherited=false)]
   178|     public sealed partial class ComAliasNameAttribute : System.Attribute
   179|     {
   180|         public ComAliasNameAttribute(string alias) { }
   181|         public string Value { get { throw null; } }

# --- HUNK 2: Lines 272-319 ---
   272|     {
   273|         public ComRegisterFunctionAttribute() { }
   274|     }
   275|     [System.AttributeUsageAttribute(System.AttributeTargets.Class, Inherited=true)]
   276|     [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
   277|     public sealed partial class ComSourceInterfacesAttribute : System.Attribute
   278|     {
   279|         public ComSourceInterfacesAttribute(string sourceInterfaces) { }
   280|         public ComSourceInterfacesAttribute(System.Type sourceInterface) { }
   281|         public ComSourceInterfacesAttribute(System.Type sourceInterface1, System.Type sourceInterface2) { }
   282|         public ComSourceInterfacesAttribute(System.Type sourceInterface1, System.Type sourceInterface2, System.Type sourceInterface3) { }
   283|         public ComSourceInterfacesAttribute(System.Type sourceInterface1, System.Type sourceInterface2, System.Type sourceInterface3, System.Type sourceInterface4) { }
   284|         public string Value { get { throw null; } }
   285|     }
   286|     [System.AttributeUsageAttribute(System.AttributeTargets.Method, Inherited=false)]
   287|     public sealed partial class ComUnregisterFunctionAttribute : System.Attribute
   288|     {
   289|         public ComUnregisterFunctionAttribute() { }
   290|     }
   291|     [System.CLSCompliantAttribute(false)]
   292|     public readonly partial struct CULong : System.IEquatable<System.Runtime.InteropServices.CULong>
   293|     {
   294|         private readonly int _dummyPrimitive;
   295|         public CULong(uint value) { throw null; }
   296|         public CULong(nuint value) { throw null; }
   297|         public nuint Value { get { throw null; } }
   298|         public override bool Equals([System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] object? o) { throw null; }
   299|         public bool Equals(System.Runtime.InteropServices.CULong other) { throw null; }
   300|         public override int GetHashCode() { throw null; }
   301|         public override string ToString() { throw null; }
   302|     }
   303|     [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
   304|     [System.ObsoleteAttribute("CurrencyWrapper and support for marshalling to the VARIANT type may be unavailable in future releases.")]
   305|     public sealed partial class CurrencyWrapper
   306|     {
   307|         public CurrencyWrapper(decimal obj) { }
   308|         public CurrencyWrapper(object obj) { }
   309|         public decimal WrappedObject { get { throw null; } }
   310|     }
   311|     [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
   312|     public enum CustomQueryInterfaceMode
   313|     {
   314|         Ignore = 0,
   315|         Allow = 1,
   316|     }
   317|     [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
   318|     public enum CustomQueryInterfaceResult
   319|     {

# --- HUNK 3: Lines 761-903 ---
   761|     {
   762|         [System.CLSCompliantAttribute(false)]
   763|         public static void* AlignedAlloc(nuint byteCount, nuint alignment) { throw null; }
   764|         [System.CLSCompliantAttribute(false)]
   765|         public static void AlignedFree(void* ptr) { }
   766|         [System.CLSCompliantAttribute(false)]
   767|         public static void* AlignedRealloc(void* ptr, nuint byteCount, nuint alignment) { throw null; }
   768|         [System.CLSCompliantAttribute(false)]
   769|         public static void* Alloc(nuint byteCount) { throw null; }
   770|         [System.CLSCompliantAttribute(false)]
   771|         public static void* Alloc(nuint elementCount, nuint elementSize) { throw null; }
   772|         [System.CLSCompliantAttribute(false)]
   773|         public static void* AllocZeroed(nuint byteCount) { throw null; }
   774|         [System.CLSCompliantAttribute(false)]
   775|         public static void* AllocZeroed(nuint elementCount, nuint elementSize) { throw null; }
   776|         [System.CLSCompliantAttribute(false)]
   777|         public static void Free(void* ptr) { }
   778|         [System.CLSCompliantAttribute(false)]
   779|         public static void* Realloc(void* ptr, nuint byteCount) { throw null; }
   780|     }
   781|     public readonly partial struct NFloat : System.IEquatable<System.Runtime.InteropServices.NFloat>
   782| #if FEATURE_NFLOAT
   783| #pragma warning disable SA1001
   784|         , System.IComparable,
   785|           System.IComparable<System.Runtime.InteropServices.NFloat>,
   786|           System.IFormattable,
   787|           System.ISpanFormattable
   788| #pragma warning restore SA1001
   789| #endif // FEATURE_NFLOAT
   790|     {
   791|         private readonly int _dummyPrimitive;
   792|         public NFloat(double value) { throw null; }
   793|         public NFloat(float value) { throw null; }
   794|         public double Value { get { throw null; } }
   795|         public override bool Equals([System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] object? obj) { throw null; }
   796|         public bool Equals(System.Runtime.InteropServices.NFloat other) { throw null; }
   797|         public override int GetHashCode() { throw null; }
   798|         public override string ToString() { throw null; }
   799| #if FEATURE_NFLOAT
   800|         public static System.Runtime.InteropServices.NFloat Epsilon { get { throw null; } }
   801|         public static System.Runtime.InteropServices.NFloat MaxValue { get { throw null; } }
   802|         public static System.Runtime.InteropServices.NFloat MinValue { get { throw null; } }
   803|         public static System.Runtime.InteropServices.NFloat NaN { get { throw null; } }
   804|         public static System.Runtime.InteropServices.NFloat NegativeInfinity { get { throw null; } }
   805|         public static System.Runtime.InteropServices.NFloat PositiveInfinity { get { throw null; } }
   806|         public static int Size { get { throw null; } }
   807|         public int CompareTo(object? obj) { throw null; }
   808|         public int CompareTo(System.Runtime.InteropServices.NFloat other) { throw null; }
   809|         public static bool IsFinite(System.Runtime.InteropServices.NFloat value) { throw null; }
   810|         public static bool IsInfinity(System.Runtime.InteropServices.NFloat value) { throw null; }
   811|         public static bool IsNaN(System.Runtime.InteropServices.NFloat value) { throw null; }
   812|         public static bool IsNegative(System.Runtime.InteropServices.NFloat value) { throw null; }
   813|         public static bool IsNegativeInfinity(System.Runtime.InteropServices.NFloat value) { throw null; }
   814|         public static bool IsNormal(System.Runtime.InteropServices.NFloat value) { throw null; }
   815|         public static bool IsPositiveInfinity(System.Runtime.InteropServices.NFloat value) { throw null; }
   816|         public static bool IsSubnormal(System.Runtime.InteropServices.NFloat value) { throw null; }
   817|         public static System.Runtime.InteropServices.NFloat operator +(System.Runtime.InteropServices.NFloat left, System.Runtime.InteropServices.NFloat right) { throw null; }
   818|         public static System.Runtime.InteropServices.NFloat operator --(System.Runtime.InteropServices.NFloat value) { throw null; }
   819|         public static System.Runtime.InteropServices.NFloat operator /(System.Runtime.InteropServices.NFloat left, System.Runtime.InteropServices.NFloat right) { throw null; }
   820|         public static bool operator ==(System.Runtime.InteropServices.NFloat left, System.Runtime.InteropServices.NFloat right) { throw null; }
   821|         public static explicit operator System.Runtime.InteropServices.NFloat (decimal value) { throw null; }
   822|         public static explicit operator System.Runtime.InteropServices.NFloat (double value) { throw null; }
   823|         public static explicit operator byte (System.Runtime.InteropServices.NFloat value) { throw null; }
   824|         public static explicit operator char (System.Runtime.InteropServices.NFloat value) { throw null; }
   825|         public static explicit operator decimal (System.Runtime.InteropServices.NFloat value) { throw null; }
   826|         public static explicit operator short (System.Runtime.InteropServices.NFloat value) { throw null; }
   827|         public static explicit operator int (System.Runtime.InteropServices.NFloat value) { throw null; }
   828|         public static explicit operator long (System.Runtime.InteropServices.NFloat value) { throw null; }
   829|         public static explicit operator nint (System.Runtime.InteropServices.NFloat value) { throw null; }
   830|         [System.CLSCompliantAttribute(false)]
   831|         public static explicit operator sbyte (System.Runtime.InteropServices.NFloat value) { throw null; }
   832|         public static explicit operator float (System.Runtime.InteropServices.NFloat value) { throw null; }
   833|         [System.CLSCompliantAttribute(false)]
   834|         public static explicit operator ushort (System.Runtime.InteropServices.NFloat value) { throw null; }
   835|         [System.CLSCompliantAttribute(false)]
   836|         public static explicit operator uint (System.Runtime.InteropServices.NFloat value) { throw null; }
   837|         [System.CLSCompliantAttribute(false)]
   838|         public static explicit operator ulong (System.Runtime.InteropServices.NFloat value) { throw null; }
   839|         [System.CLSCompliantAttribute(false)]
   840|         public static explicit operator nuint (System.Runtime.InteropServices.NFloat value) { throw null; }
   841|         public static bool operator >(System.Runtime.InteropServices.NFloat left, System.Runtime.InteropServices.NFloat right) { throw null; }
   842|         public static bool operator >=(System.Runtime.InteropServices.NFloat left, System.Runtime.InteropServices.NFloat right) { throw null; }
   843|         public static implicit operator System.Runtime.InteropServices.NFloat (byte value) { throw null; }
   844|         public static implicit operator System.Runtime.InteropServices.NFloat (char value) { throw null; }
   845|         public static implicit operator System.Runtime.InteropServices.NFloat (short value) { throw null; }
   846|         public static implicit operator System.Runtime.InteropServices.NFloat (int value) { throw null; }
   847|         public static implicit operator System.Runtime.InteropServices.NFloat (long value) { throw null; }
   848|         public static implicit operator System.Runtime.InteropServices.NFloat (nint value) { throw null; }
   849|         public static implicit operator double (System.Runtime.InteropServices.NFloat value) { throw null; }
   850|         [System.CLSCompliantAttribute(false)]
   851|         public static implicit operator System.Runtime.InteropServices.NFloat (sbyte value) { throw null; }
   852|         public static implicit operator System.Runtime.InteropServices.NFloat (float value) { throw null; }
   853|         [System.CLSCompliantAttribute(false)]
   854|         public static implicit operator System.Runtime.InteropServices.NFloat (ushort value) { throw null; }
   855|         [System.CLSCompliantAttribute(false)]
   856|         public static implicit operator System.Runtime.InteropServices.NFloat (uint value) { throw null; }
   857|         [System.CLSCompliantAttribute(false)]
   858|         public static implicit operator System.Runtime.InteropServices.NFloat (ulong value) { throw null; }
   859|         [System.CLSCompliantAttribute(false)]
   860|         public static implicit operator System.Runtime.InteropServices.NFloat (nuint value) { throw null; }
   861|         public static System.Runtime.InteropServices.NFloat operator ++(System.Runtime.InteropServices.NFloat value) { throw null; }
   862|         public static bool operator !=(System.Runtime.InteropServices.NFloat left, System.Runtime.InteropServices.NFloat right) { throw null; }
   863|         public static bool operator <(System.Runtime.InteropServices.NFloat left, System.Runtime.InteropServices.NFloat right) { throw null; }
   864|         public static bool operator <=(System.Runtime.InteropServices.NFloat left, System.Runtime.InteropServices.NFloat right) { throw null; }
   865|         public static System.Runtime.InteropServices.NFloat operator %(System.Runtime.InteropServices.NFloat left, System.Runtime.InteropServices.NFloat right) { throw null; }
   866|         public static System.Runtime.InteropServices.NFloat operator *(System.Runtime.InteropServices.NFloat left, System.Runtime.InteropServices.NFloat right) { throw null; }
   867|         public static System.Runtime.InteropServices.NFloat operator -(System.Runtime.InteropServices.NFloat left, System.Runtime.InteropServices.NFloat right) { throw null; }
   868|         public static System.Runtime.InteropServices.NFloat operator -(System.Runtime.InteropServices.NFloat value) { throw null; }
   869|         public static System.Runtime.InteropServices.NFloat operator +(System.Runtime.InteropServices.NFloat value) { throw null; }
   870|         public static System.Runtime.InteropServices.NFloat Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite, System.IFormatProvider? provider = null) { throw null; }
   871|         public static System.Runtime.InteropServices.NFloat Parse(string s) { throw null; }
   872|         public static System.Runtime.InteropServices.NFloat Parse(string s, System.Globalization.NumberStyles style) { throw null; }
   873|         public static System.Runtime.InteropServices.NFloat Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider? provider) { throw null; }
   874|         public static System.Runtime.InteropServices.NFloat Parse(string s, System.IFormatProvider? provider) { throw null; }
   875|         public string ToString(System.IFormatProvider? provider) { throw null; }
   876|         public string ToString(string? format) { throw null; }
   877|         public string ToString(string? format, System.IFormatProvider? provider) { throw null; }
   878|         public bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider? provider = null) { throw null; }
   879|         public static bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider? provider, out System.Runtime.InteropServices.NFloat result) { throw null; }
   880|         public static bool TryParse(System.ReadOnlySpan<char> s, out System.Runtime.InteropServices.NFloat result) { throw null; }
   881|         public static bool TryParse([System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] string? s, System.Globalization.NumberStyles style, System.IFormatProvider? provider, out System.Runtime.InteropServices.NFloat result) { throw null; }
   882|         public static bool TryParse([System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] string? s, out System.Runtime.InteropServices.NFloat result) { throw null; }
   883| #endif // FEATURE_NFLOAT
   884|     }
   885|     [System.AttributeUsageAttribute(System.AttributeTargets.Parameter, Inherited=false)]
   886|     public sealed partial class OptionalAttribute : System.Attribute
   887|     {
   888|         public OptionalAttribute() { }
   889|     }
   890|     public enum PosixSignal
   891|     {
   892|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("windows")]
   893|         SIGTSTP = -10,
   894|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("windows")]
   895|         SIGTTOU = -9,
   896|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("windows")]
   897|         SIGTTIN = -8,
   898|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("windows")]
   899|         SIGWINCH = -7,
   900|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("windows")]
   901|         SIGCONT = -6,
   902|         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("windows")]
   903|         SIGCHLD = -5,


# ====================================================================
# FILE: src/mono/System.Private.CoreLib/src/System/Array.Mono.cs
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 107-176 ---
   107|             if (sourceIndex < 0)
   108|                 throw new ArgumentOutOfRangeException(nameof(sourceIndex), "Value has to be >= 0.");
   109|             if (destinationIndex < 0)
   110|                 throw new ArgumentOutOfRangeException(nameof(destinationIndex), "Value has to be >= 0.");
   111|             if (FastCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length))
   112|                 return;
   113|             int source_pos = sourceIndex - sourceArray.GetLowerBound(0);
   114|             int dest_pos = destinationIndex - destinationArray.GetLowerBound(0);
   115|             if (source_pos < 0)
   116|                 throw new ArgumentOutOfRangeException(nameof(sourceIndex), "Index was less than the array's lower bound in the first dimension.");
   117|             if (dest_pos < 0)
   118|                 throw new ArgumentOutOfRangeException(nameof(destinationIndex), "Index was less than the array's lower bound in the first dimension.");
   119|             if (source_pos > sourceArray.Length - length)
   120|                 throw new ArgumentException(SR.Arg_LongerThanSrcArray, nameof(sourceArray));
   121|             if (dest_pos > destinationArray.Length - length)
   122|             {
   123|                 throw new ArgumentException("Destination array was not long enough. Check destIndex and length, and the array's lower bounds", nameof(destinationArray));
   124|             }
   125|             Type src_type = sourceArray.GetType().GetElementType()!;
   126|             Type dst_type = destinationArray.GetType().GetElementType()!;
   127|             Type dst_elem_type = dst_type;
   128|             bool dst_type_vt = dst_type.IsValueType && Nullable.GetUnderlyingType(dst_type) == null;
   129|             bool src_is_enum = src_type.IsEnum;
   130|             bool dst_is_enum = dst_type.IsEnum;
   131|             if (src_is_enum)
   132|                 src_type = Enum.GetUnderlyingType(src_type);
   133|             if (dst_is_enum)
   134|                 dst_type = Enum.GetUnderlyingType(dst_type);
   135|             if (reliable)
   136|             {
   137|                 if (!dst_type.Equals(src_type) &&
   138|                     !(dst_type.IsPrimitive && src_type.IsPrimitive && CanChangePrimitive(ref dst_type, ref src_type, true)))
   139|                 {
   140|                     throw new ArrayTypeMismatchException(SR.ArrayTypeMismatch_CantAssignType);
   141|                 }
   142|             }
   143|             else
   144|             {
   145|                 if (!CanAssignArrayElement(src_type, dst_type))
   146|                 {
   147|                     throw new ArrayTypeMismatchException(SR.ArrayTypeMismatch_CantAssignType);
   148|                 }
   149|             }
   150|             if (!ReferenceEquals(sourceArray, destinationArray) || source_pos > dest_pos)
   151|             {
   152|                 for (int i = 0; i < length; i++)
   153|                 {
   154|                     object srcval = sourceArray.GetValueImpl(source_pos + i);
   155|                     if (dst_type_vt && (srcval == null || (src_type == typeof(object) && !dst_elem_type.IsAssignableFrom (srcval.GetType()))))
   156|                         throw new InvalidCastException(SR.InvalidCast_DownCastArrayElement);
   157|                     try
   158|                     {
   159|                         destinationArray.SetValueRelaxedImpl(srcval, dest_pos + i);
   160|                     }
   161|                     catch (ArgumentException)
   162|                     {
   163|                         throw CreateArrayTypeMismatchException();
   164|                     }
   165|                 }
   166|             }
   167|             else
   168|             {
   169|                 for (int i = length - 1; i >= 0; i--)
   170|                 {
   171|                     object srcval = sourceArray.GetValueImpl(source_pos + i);
   172|                     try
   173|                     {
   174|                         destinationArray.SetValueRelaxedImpl(srcval, dest_pos + i);
   175|                     }
   176|                     catch (ArgumentException)


# ====================================================================
# FILE: src/mono/mono/component/debugger-agent.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 4609-4650 ---
  4609| 				if (CHECK_PROTOCOL_VERSION (2, 59)) {
  4610| 					decode_byte (buf, &buf, limit);
  4611| 					decode_int (buf, &buf, limit); //not used
  4612| 				}
  4613| 				*(MonoObject**)addr = NULL;
  4614| 			} else if (type == MONO_TYPE_VALUETYPE) {
  4615| 				ERROR_DECL (error);
  4616| 				guint8 *buf2;
  4617| 				gboolean is_enum;
  4618| 				MonoClass *klass;
  4619| 				MonoDomain *d;
  4620| 				guint8 *vtype_buf;
  4621| 				int vtype_buf_size;
  4622| 				/* This can happen when round-tripping boxed vtypes */
  4623| 				/*
  4624| 				* Obtain vtype class.
  4625| 				* Same as the beginning of the handle_vtype case above.
  4626| 				*/
  4627| 				buf2 = buf;
  4628| 				is_enum = decode_byte (buf, &buf, limit);
  4629| 				if (CHECK_PROTOCOL_VERSION(2, 61))
  4630| 					decode_byte (buf, &buf, limit); //ignore is boxed
  4631| 				klass = decode_typeid (buf, &buf, limit, &d, &err);
  4632| 				if (err != ERR_NONE)
  4633| 					return err;
  4634| 				/* Decode the vtype into a temporary buffer, then box it. */
  4635| 				vtype_buf_size = mono_class_value_size (klass, NULL);
  4636| 				vtype_buf = (guint8 *)g_malloc0 (vtype_buf_size);
  4637| 				g_assert (vtype_buf);
  4638| 				buf = buf2;
  4639| 				err = decode_vtype (NULL, domain, vtype_buf, buf, &buf, limit, check_field_datatype);
  4640| 				if (err != ERR_NONE) {
  4641| 					g_free (vtype_buf);
  4642| 					return err;
  4643| 				}
  4644| 				*(MonoObject**)addr = mono_value_box_checked (klass, vtype_buf, error);
  4645| 				mono_error_cleanup (error);
  4646| 				g_free (vtype_buf);
  4647| 			} else {
  4648| 				char *name = mono_type_full_name (t);
  4649| 				PRINT_DEBUG_MSG (1, "[%p] Expected value of type %s, got 0x%0x.\n", (gpointer) (gsize) mono_native_thread_id_get (), name, type);
  4650| 				g_free (name);


# ====================================================================
# FILE: src/mono/mono/eventpipe/ep-rt-mono.c
# Total hunks: 7
# ====================================================================
# --- HUNK 1: Lines 2426-2543 ---
  2426| 	MonoImage *image,
  2427| 	ModuleEventData *module_data)
  2428| {
  2429| 	if (module_data) {
  2430| 		memset (module_data->module_il_pdb_signature, 0, EP_GUID_SIZE);
  2431| 		memset (module_data->module_native_pdb_signature, 0, EP_GUID_SIZE);
  2432| 		MonoDomain *root_domain = mono_get_root_domain ();
  2433| 		module_data->domain_id = (uint64_t)root_domain;
  2434| 		module_data->module_id = (uint64_t)image;
  2435| 		module_data->assembly_id = image ? (uint64_t)image->assembly : 0;
  2436| 		module_data->module_native_path = "";
  2437| 		module_data->module_native_pdb_path = "";
  2438| 		module_data->module_native_pdb_age = 0;
  2439| 		module_data->reserved_flags = 0;
  2440| 		module_data->module_flags = MODULE_FLAGS_MANIFEST_MODULE;
  2441| 		if (image && image->dynamic)
  2442| 			module_data->module_flags |= MODULE_FLAGS_DYNAMIC_MODULE;
  2443| 		if (image && image->aot_module)
  2444| 			module_data->module_flags |= MODULE_FLAGS_NATIVE_MODULE;
  2445| 		module_data->module_il_path = image && image->filename ? image->filename : "";
  2446| 		module_data->module_il_pdb_path = "";
  2447| 		module_data->module_il_pdb_age = 0;
  2448| 		if (image && image->image_info) {
  2449| 			MonoPEDirEntry *debug_dir_entry = (MonoPEDirEntry *)&image->image_info->cli_header.datadir.pe_debug;
  2450| 			if (debug_dir_entry->size) {
  2451| 				ImageDebugDirectory debug_dir;
  2452| 				memset (&debug_dir, 0, sizeof (debug_dir));
  2453| 				uint32_t offset = mono_cli_rva_image_map (image, debug_dir_entry->rva);
  2454| 				for (uint32_t idx = 0; idx < debug_dir_entry->size / sizeof (ImageDebugDirectory); ++idx) {
  2455| 					uint8_t *data = (uint8_t *) ((ImageDebugDirectory *) (image->raw_data + offset) + idx);
  2456| 					debug_dir.major_version = read16 (data + 8);
  2457| 					debug_dir.minor_version = read16 (data + 10);
  2458| 					debug_dir.type = read32 (data + 12);
  2459| 					debug_dir.pointer = read32 (data + 24);
  2460| 					if (debug_dir.type == DEBUG_DIR_ENTRY_CODEVIEW && debug_dir.major_version == 0x100 && debug_dir.minor_version == 0x504d) {
  2461| 						data  = (uint8_t *)(image->raw_data + debug_dir.pointer);
  2462| 						int32_t signature = read32 (data);
  2463| 						if (signature == 0x53445352) {
  2464| 							memcpy (module_data->module_il_pdb_signature, data + 4, EP_GUID_SIZE);
  2465| 							module_data->module_il_pdb_age = read32 (data + 20);
  2466| 							module_data->module_il_pdb_path = (const char *)(data + 24);
  2467| 							break;
  2468| 						}
  2469| 					}
  2470| 				}
  2471| 			}
  2472| 		}
  2473| 	}
  2474| 	return true;
  2475| }
  2476| bool
  2477| ep_rt_mono_write_event_module_load (MonoImage *image)
  2478| {
  2479| 	if (!EventEnabledModuleLoad_V2 () && !EventEnabledDomainModuleLoad_V1 ())
  2480| 		return true;
  2481| 	if (image) {
  2482| 		ModuleEventData module_data;
  2483| 		memset (&module_data, 0, sizeof (module_data));
  2484| 		if (get_module_event_data (image, &module_data)) {
  2485| 			FireEtwModuleLoad_V2 (
  2486| 				module_data.module_id,
  2487| 				module_data.assembly_id,
  2488| 				module_data.module_flags,
  2489| 				module_data.reserved_flags,
  2490| 				module_data.module_il_path,
  2491| 				module_data.module_native_path,
  2492| 				clr_instance_get_id (),
  2493| 				module_data.module_il_pdb_signature,
  2494| 				module_data.module_il_pdb_age,
  2495| 				module_data.module_il_pdb_path,
  2496| 				module_data.module_native_pdb_signature,
  2497| 				module_data.module_native_pdb_age,
  2498| 				module_data.module_native_pdb_path,
  2499| 				NULL,
  2500| 				NULL);
  2501| 			FireEtwDomainModuleLoad_V1 (
  2502| 				module_data.module_id,
  2503| 				module_data.assembly_id,
  2504| 				module_data.domain_id,
  2505| 				module_data.module_flags,
  2506| 				module_data.reserved_flags,
  2507| 				module_data.module_il_path,
  2508| 				module_data.module_native_path,
  2509| 				clr_instance_get_id (),
  2510| 				NULL,
  2511| 				NULL);
  2512| 		}
  2513| 	}
  2514| 	return true;
  2515| }
  2516| bool
  2517| ep_rt_mono_write_event_module_unload (MonoImage *image)
  2518| {
  2519| 	if (!EventEnabledModuleUnload_V2())
  2520| 		return true;
  2521| 	if (image) {
  2522| 		ModuleEventData module_data;
  2523| 		memset (&module_data, 0, sizeof (module_data));
  2524| 		if (get_module_event_data (image, &module_data)) {
  2525| 			FireEtwModuleUnload_V2 (
  2526| 				module_data.module_id,
  2527| 				module_data.assembly_id,
  2528| 				module_data.module_flags,
  2529| 				module_data.reserved_flags,
  2530| 				module_data.module_il_path,
  2531| 				module_data.module_native_path,
  2532| 				clr_instance_get_id (),
  2533| 				module_data.module_il_pdb_signature,
  2534| 				module_data.module_il_pdb_age,
  2535| 				module_data.module_il_pdb_path,
  2536| 				module_data.module_native_pdb_signature,
  2537| 				module_data.module_native_pdb_age,
  2538| 				module_data.module_native_pdb_path,
  2539| 				NULL,
  2540| 				NULL);
  2541| 		}
  2542| 	}
  2543| 	return true;

# --- HUNK 2: Lines 2552-2615 ---
  2552| 		MonoDomain *root_domain = mono_get_root_domain ();
  2553| 		assembly_data->domain_id = (uint64_t)root_domain;
  2554| 		assembly_data->assembly_id = (uint64_t)assembly;
  2555| 		assembly_data->binding_id = 0;
  2556| 		assembly_data->assembly_flags = 0;
  2557| 		if (assembly->dynamic)
  2558| 			assembly_data->assembly_flags |= ASSEMBLY_FLAGS_DYNAMIC_ASSEMBLY;
  2559| 		if (assembly->image && assembly->image->aot_module)
  2560| 			assembly_data->assembly_flags |= ASSEMBLY_FLAGS_NATIVE_ASSEMBLY;
  2561| 		assembly_data->assembly_name = mono_stringify_assembly_name (&assembly->aname);
  2562| 	}
  2563| 	return true;
  2564| }
  2565| bool
  2566| ep_rt_mono_write_event_assembly_load (MonoAssembly *assembly)
  2567| {
  2568| 	if (!EventEnabledAssemblyLoad_V1 ())
  2569| 		return true;
  2570| 	if (assembly) {
  2571| 		AssemblyEventData assembly_data;
  2572| 		memset (&assembly_data, 0, sizeof (assembly_data));
  2573| 		if (get_assembly_event_data (assembly, &assembly_data)) {
  2574| 			FireEtwAssemblyLoad_V1 (
  2575| 				assembly_data.assembly_id,
  2576| 				assembly_data.domain_id,
  2577| 				assembly_data.binding_id,
  2578| 				assembly_data.assembly_flags,
  2579| 				assembly_data.assembly_name,
  2580| 				clr_instance_get_id (),
  2581| 				NULL,
  2582| 				NULL);
  2583| 			g_free (assembly_data.assembly_name);
  2584| 		}
  2585| 	}
  2586| 	return true;
  2587| }
  2588| bool
  2589| ep_rt_mono_write_event_assembly_unload (MonoAssembly *assembly)
  2590| {
  2591| 	if (!EventEnabledAssemblyUnload_V1 ())
  2592| 		return true;
  2593| 	if (assembly) {
  2594| 		AssemblyEventData assembly_data;
  2595| 		memset (&assembly_data, 0, sizeof (assembly_data));
  2596| 		if (get_assembly_event_data (assembly, &assembly_data)) {
  2597| 			FireEtwAssemblyUnload_V1 (
  2598| 				assembly_data.assembly_id,
  2599| 				assembly_data.domain_id,
  2600| 				assembly_data.binding_id,
  2601| 				assembly_data.assembly_flags,
  2602| 				assembly_data.assembly_name,
  2603| 				clr_instance_get_id (),
  2604| 				NULL,
  2605| 				NULL);
  2606| 			g_free (assembly_data.assembly_name);
  2607| 		}
  2608| 	}
  2609| 	return true;
  2610| }
  2611| bool
  2612| ep_rt_mono_write_event_thread_created (ep_rt_thread_id_t tid)
  2613| {
  2614| 	if (!EventEnabledThreadCreated ())
  2615| 		return true;

# --- HUNK 3: Lines 4503-4543 ---
  4503| 	mono_profiler_fire_event_enter ();
  4504| 	FireEtwMonoProfilerModuleFailed (
  4505| 		(uint64_t)image,
  4506| 		NULL,
  4507| 		NULL);
  4508| 	mono_profiler_fire_event_exit ();
  4509| }
  4510| static
  4511| void
  4512| mono_profiler_module_loaded (
  4513| 	MonoProfiler *prof,
  4514| 	MonoImage *image)
  4515| {
  4516| 	if (!EventEnabledMonoProfilerModuleLoaded ())
  4517| 		return;
  4518| 	uint64_t module_id = (uint64_t)image;
  4519| 	const ep_char8_t *module_path = NULL;
  4520| 	const ep_char8_t *module_guid = NULL;
  4521| 	if (image) {
  4522| 		ModuleEventData module_data;
  4523| 		memset (&module_data, 0, sizeof (module_data));
  4524| 		if (get_module_event_data (image, &module_data))
  4525| 			module_path = (const ep_char8_t *)module_data.module_il_path;
  4526| 		module_guid = (const ep_char8_t *)mono_image_get_guid (image);
  4527| 	}
  4528| 	mono_profiler_fire_event_enter ();
  4529| 	FireEtwMonoProfilerModuleLoaded (
  4530| 		module_id,
  4531| 		module_path ? module_path : "",
  4532| 		module_guid ? module_guid : "",
  4533| 		NULL,
  4534| 		NULL);
  4535| 	mono_profiler_fire_event_exit ();
  4536| }
  4537| static
  4538| void
  4539| mono_profiler_module_unloading (
  4540| 	MonoProfiler *prof,
  4541| 	MonoImage *image)
  4542| {
  4543| 	if (!EventEnabledMonoProfilerModuleUnloading ())

# --- HUNK 4: Lines 4545-4585 ---
  4545| 	mono_profiler_fire_event_enter ();
  4546| 	FireEtwMonoProfilerModuleUnloading (
  4547| 		(uint64_t)image,
  4548| 		NULL,
  4549| 		NULL);
  4550| 	mono_profiler_fire_event_exit ();
  4551| }
  4552| static
  4553| void
  4554| mono_profiler_module_unloaded (
  4555| 	MonoProfiler *prof,
  4556| 	MonoImage *image)
  4557| {
  4558| 	if (!EventEnabledMonoProfilerModuleUnloaded ())
  4559| 		return;
  4560| 	uint64_t module_id = (uint64_t)image;
  4561| 	const ep_char8_t *module_path = NULL;
  4562| 	const ep_char8_t *module_guid = NULL;
  4563| 	if (image) {
  4564| 		ModuleEventData module_data;
  4565| 		memset (&module_data, 0, sizeof (module_data));
  4566| 		if (get_module_event_data (image, &module_data))
  4567| 			module_path = (const ep_char8_t *)module_data.module_il_path;
  4568| 		module_guid = (const ep_char8_t *)mono_image_get_guid (image);
  4569| 	}
  4570| 	mono_profiler_fire_event_enter ();
  4571| 	FireEtwMonoProfilerModuleUnloaded (
  4572| 		module_id,
  4573| 		module_path ? module_path : "",
  4574| 		module_guid ? module_guid : "",
  4575| 		NULL,
  4576| 		NULL);
  4577| 	mono_profiler_fire_event_exit ();
  4578| }
  4579| static
  4580| inline
  4581| void
  4582| get_assembly_data (
  4583| 	MonoAssembly *assembly,
  4584| 	uint64_t *assembly_id,
  4585| 	uint64_t *module_id,


# ====================================================================
# FILE: src/mono/mono/mini/image-writer.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 50-90 ---
    50| #if (defined(TARGET_AMD64) || defined(TARGET_POWERPC64)) && !defined(MONO_ARCH_ILP32)
    51| #define AS_POINTER_DIRECTIVE ".quad"
    52| #elif defined(TARGET_ARM64)
    53| #ifdef MONO_ARCH_ILP32
    54| #define AS_POINTER_DIRECTIVE AS_INT32_DIRECTIVE
    55| #else
    56| #ifdef TARGET_ASM_APPLE
    57| #define AS_POINTER_DIRECTIVE ".quad"
    58| #else
    59| #define AS_POINTER_DIRECTIVE ".xword"
    60| #endif
    61| #endif
    62| #else
    63| #define AS_POINTER_DIRECTIVE ".long"
    64| #endif
    65| #if defined(TARGET_ASM_APPLE)
    66| #define AS_INT16_DIRECTIVE ".short"
    67| #elif defined(TARGET_ASM_GAS) && defined(TARGET_WIN32)
    68| #define AS_INT16_DIRECTIVE ".word"
    69| #elif defined(TARGET_ASM_GAS)
    70| #define AS_INT16_DIRECTIVE ".short"
    71| #else
    72| #define AS_INT16_DIRECTIVE ".word"
    73| #endif
    74| #if defined(TARGET_ASM_APPLE)
    75| #define AS_SKIP_DIRECTIVE ".space"
    76| #else
    77| #define AS_SKIP_DIRECTIVE ".skip"
    78| #endif
    79| #if defined(TARGET_ASM_APPLE)
    80| #define AS_GLOBAL_PREFIX "_"
    81| #else
    82| #define AS_GLOBAL_PREFIX ""
    83| #endif
    84| #ifdef TARGET_ASM_APPLE
    85| #define AS_TEMP_LABEL_PREFIX "L"
    86| #else
    87| #define AS_TEMP_LABEL_PREFIX ".L"
    88| #endif
    89| #define ROUND_DOWN(VALUE,SIZE)	((VALUE) & ~((SIZE) - 1))
    90| /* emit mode */


# ====================================================================
# FILE: src/mono/mono/mini/interp/interp.c
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 4316-4356 ---
  4316| 			ip += 3;
  4317| 			MINT_IN_BREAK;
  4318| 		MINT_IN_CASE(MINT_CONV_I4_R4)
  4319| 			LOCAL_VAR (ip [1], gint32) = (gint32) LOCAL_VAR (ip [2], float);
  4320| 			ip += 3;
  4321| 			MINT_IN_BREAK;
  4322| 		MINT_IN_CASE(MINT_CONV_I4_R8)
  4323| 			LOCAL_VAR (ip [1], gint32) = (gint32) LOCAL_VAR (ip [2], double);
  4324| 			ip += 3;
  4325| 			MINT_IN_BREAK;
  4326| 		MINT_IN_CASE(MINT_CONV_U4_R4)
  4327| #ifdef MONO_ARCH_EMULATE_FCONV_TO_U4
  4328| 			LOCAL_VAR (ip [1], gint32) = mono_rconv_u4 (LOCAL_VAR (ip [2], float));
  4329| #else
  4330| 			LOCAL_VAR (ip [1], gint32) = (guint32) LOCAL_VAR (ip [2], float);
  4331| #endif
  4332| 			ip += 3;
  4333| 			MINT_IN_BREAK;
  4334| 		MINT_IN_CASE(MINT_CONV_U4_R8)
  4335| #ifdef MONO_ARCH_EMULATE_FCONV_TO_U4
  4336| 			LOCAL_VAR (ip [1], gint32) = mono_fconv_u4 (LOCAL_VAR (ip [2], double));
  4337| #else
  4338| 			LOCAL_VAR (ip [1], gint32) = (guint32) LOCAL_VAR (ip [2], double);
  4339| #endif
  4340| 			ip += 3;
  4341| 			MINT_IN_BREAK;
  4342| 		MINT_IN_CASE(MINT_CONV_I8_I4)
  4343| 			LOCAL_VAR (ip [1], gint64) = LOCAL_VAR (ip [2], gint32);
  4344| 			ip += 3;
  4345| 			MINT_IN_BREAK;
  4346| 		MINT_IN_CASE(MINT_CONV_I8_U4)
  4347| 			LOCAL_VAR (ip [1], gint64) = (guint32) LOCAL_VAR (ip [2], gint32);
  4348| 			ip += 3;
  4349| 			MINT_IN_BREAK;
  4350| 		MINT_IN_CASE(MINT_CONV_I8_R4)
  4351| 			LOCAL_VAR (ip [1], gint64) = (gint64) LOCAL_VAR (ip [2], float);
  4352| 			ip += 3;
  4353| 			MINT_IN_BREAK;
  4354| 		MINT_IN_CASE(MINT_CONV_I8_R8)
  4355| 			LOCAL_VAR (ip [1], gint64) = (gint64) LOCAL_VAR (ip [2], double);
  4356| 			ip += 3;

# --- HUNK 2: Lines 4372-4412 ---
  4372| 			ip += 3;
  4373| 			MINT_IN_BREAK;
  4374| 		MINT_IN_CASE(MINT_CONV_R8_I8)
  4375| 			LOCAL_VAR (ip [1], double) = (double) LOCAL_VAR (ip [2], gint64);
  4376| 			ip += 3;
  4377| 			MINT_IN_BREAK;
  4378| 		MINT_IN_CASE(MINT_CONV_R8_R4)
  4379| 			LOCAL_VAR (ip [1], double) = (double) LOCAL_VAR (ip [2], float);
  4380| 			ip += 3;
  4381| 			MINT_IN_BREAK;
  4382| 		MINT_IN_CASE(MINT_CONV_U8_R4)
  4383| #ifdef MONO_ARCH_EMULATE_FCONV_TO_U8
  4384| 			LOCAL_VAR (ip [1], gint64) = mono_rconv_u8 (LOCAL_VAR (ip [2], float));
  4385| #else
  4386| 			LOCAL_VAR (ip [1], gint64) = (guint64) LOCAL_VAR (ip [2], float);
  4387| #endif
  4388| 			ip += 3;
  4389| 			MINT_IN_BREAK;
  4390| 		MINT_IN_CASE(MINT_CONV_U8_R8)
  4391| #ifdef MONO_ARCH_EMULATE_FCONV_TO_U8
  4392| 			LOCAL_VAR (ip [1], gint64) = mono_fconv_u8 (LOCAL_VAR (ip [2], double));
  4393| #else
  4394| 			LOCAL_VAR (ip [1], gint64) = (guint64) LOCAL_VAR (ip [2], double);
  4395| #endif
  4396| 			ip += 3;
  4397| 			MINT_IN_BREAK;
  4398| 		MINT_IN_CASE(MINT_CPOBJ) {
  4399| 			MonoClass* const c = (MonoClass*)frame->imethod->data_items[ip [3]];
  4400| 			g_assert (m_class_is_valuetype (c));
  4401| 			/* if this assertion fails, we need to add a write barrier */
  4402| 			g_assert (!MONO_TYPE_IS_REFERENCE (m_class_get_byval_arg (c)));
  4403| 			stackval_from_data (m_class_get_byval_arg (c), (stackval*)LOCAL_VAR (ip [1], gpointer), LOCAL_VAR (ip [2], gpointer), FALSE);
  4404| 			ip += 4;
  4405| 			MINT_IN_BREAK;
  4406| 		}
  4407| 		MINT_IN_CASE(MINT_CPOBJ_VT) {
  4408| 			MonoClass* const c = (MonoClass*)frame->imethod->data_items[ip [3]];
  4409| 			mono_value_copy_internal (LOCAL_VAR (ip [1], gpointer), LOCAL_VAR (ip [2], gpointer), c);
  4410| 			ip += 4;
  4411| 			MINT_IN_BREAK;
  4412| 		}


# ====================================================================
# FILE: src/mono/mono/mini/interp/transform.c
# Total hunks: 7
# ====================================================================
# --- HUNK 1: Lines 1233-1338 ---
  1233| 		}
  1234| 	case MintOpPair2:
  1235| 		g_string_append_printf (str, " %u <- %u, %u <- %u", data [0], data [1], data [2], data [3]);
  1236| 		break;
  1237| 	case MintOpPair3:
  1238| 		g_string_append_printf (str, " %u <- %u, %u <- %u, %u <- %u", data [0], data [1], data [2], data [3], data [4], data [5]);
  1239| 		break;
  1240| 	case MintOpPair4:
  1241| 		g_string_append_printf (str, " %u <- %u, %u <- %u, %u <- %u, %u <- %u", data [0], data [1], data [2], data [3], data [4], data [5], data [6], data [7]);
  1242| 		break;
  1243| 	default:
  1244| 		g_string_append_printf (str, "unknown arg type\n");
  1245| 	}
  1246| 	return g_string_free (str, FALSE);
  1247| }
  1248| static void
  1249| dump_interp_compacted_ins (const guint16 *ip, const guint16 *start)
  1250| {
  1251| 	int opcode = *ip;
  1252| 	int ins_offset = ip - start;
  1253| 	GString *str = g_string_new ("");
  1254| 	g_string_append_printf (str, "IR_%04x: %-14s", ins_offset, mono_interp_opname (opcode));
  1255| 	ip++;
  1256|         if (mono_interp_op_dregs [opcode] > 0)
  1257|                 g_string_append_printf (str, " [%d <-", *ip++);
  1258|         else
  1259|                 g_string_append_printf (str, " [nil <-");
  1260|         if (mono_interp_op_sregs [opcode] > 0) {
  1261|                 for (int i = 0; i < mono_interp_op_sregs [opcode]; i++)
  1262|                         g_string_append_printf (str, " %d", *ip++);
  1263|                 g_string_append_printf (str, "],");
  1264|         } else {
  1265|                 g_string_append_printf (str, " nil],");
  1266|         }
  1267| 	char *ins_data = dump_interp_ins_data (NULL, ins_offset, ip, opcode);
  1268| 	g_print ("%s%s\n", str->str, ins_data);
  1269| 	g_string_free (str, TRUE);
  1270| 	g_free (ins_data);
  1271| }
  1272| static void
  1273| dump_interp_code (const guint16 *start, const guint16* end)
  1274| {
  1275| 	const guint16 *p = start;
  1276| 	while (p < end) {
  1277| 		dump_interp_compacted_ins (p, start);
  1278| 		p = mono_interp_dis_mintop_len (p);
  1279| 	}
  1280| }
  1281| static void
  1282| dump_interp_inst (InterpInst *ins)
  1283| {
  1284| 	int opcode = ins->opcode;
  1285| 	GString *str = g_string_new ("");
  1286| 	g_string_append_printf (str, "IL_%04x: %-14s", ins->il_offset, mono_interp_opname (opcode));
  1287| 	if (mono_interp_op_dregs [opcode] > 0)
  1288| 		g_string_append_printf (str, " [%d <-", ins->dreg);
  1289| 	else
  1290| 		g_string_append_printf (str, " [nil <-");
  1291| 	if (mono_interp_op_sregs [opcode] > 0) {
  1292| 		for (int i = 0; i < mono_interp_op_sregs [opcode]; i++) {
  1293| 			if (ins->sregs [i] == MINT_CALL_ARGS_SREG) {
  1294| 				g_string_append_printf (str, " c:");
  1295| 				int *call_args = ins->info.call_args;
  1296| 				if (call_args) {
  1297| 					while (*call_args != -1) {
  1298| 						g_string_append_printf (str, " %d", *call_args);
  1299| 						call_args++;
  1300| 					}
  1301| 				}
  1302| 			} else {
  1303| 				g_string_append_printf (str, " %d", ins->sregs [i]);
  1304| 			}
  1305| 		}
  1306| 		g_string_append_printf (str, "],");
  1307| 	} else {
  1308| 		g_string_append_printf (str, " nil],");
  1309| 	}
  1310| 	if (opcode == MINT_LDLOCA_S) {
  1311| 		g_string_append_printf (str, " %d", ins->sregs [0]);
  1312| 	} else {
  1313| 		char *descr = dump_interp_ins_data (ins, ins->il_offset, &ins->data [0], ins->opcode);
  1314| 		g_string_append_printf (str, "%s", descr);
  1315| 		g_free (descr);
  1316| 	}
  1317| 	g_print ("%s\n", str->str);
  1318| 	g_string_free (str, TRUE);
  1319| }
  1320| static G_GNUC_UNUSED void
  1321| dump_interp_bb (InterpBasicBlock *bb)
  1322| {
  1323| 	g_print ("BB%d:\n", bb->index);
  1324| 	for (InterpInst *ins = bb->first_ins; ins != NULL; ins = ins->next)
  1325| 		dump_interp_inst (ins);
  1326| }
  1327| /* For debug use */
  1328| void
  1329| mono_interp_print_code (InterpMethod *imethod)
  1330| {
  1331| 	MonoJitInfo *jinfo = imethod->jinfo;
  1332| 	const guint8 *start;
  1333| 	if (!jinfo)
  1334| 		return;
  1335| 	char *name = mono_method_full_name (imethod->method, 1);
  1336| 	g_print ("Method : %s\n", name);
  1337| 	g_free (name);
  1338| 	start = (guint8*) jinfo->code_start;

# --- HUNK 2: Lines 1345-1384 ---
  1345| 	InterpInst *ins = td->first_ins;
  1346| 	char *name = mono_method_full_name (td->method, TRUE);
  1347| 	g_print ("IR for \"%s\"\n", name);
  1348| 	g_free (name);
  1349| 	while (ins) {
  1350| 		dump_interp_inst (ins);
  1351| 		ins = ins->next;
  1352| 	}
  1353| }
  1354| static MonoMethodHeader*
  1355| interp_method_get_header (MonoMethod* method, MonoError *error)
  1356| {
  1357| 	/* An explanation: mono_method_get_header_internal returns an error if
  1358| 	 * called on a method with no body (e.g. an abstract method, or an
  1359| 	 * icall).  We don't want that.
  1360| 	 */
  1361| 	if (mono_method_has_no_body (method))
  1362| 		return NULL;
  1363| 	else
  1364| 		return mono_method_get_header_internal (method, error);
  1365| }
  1366| static gboolean
  1367| interp_ip_in_cbb (TransformData *td, int il_offset)
  1368| {
  1369| 	InterpBasicBlock *bb = td->offset_to_bb [il_offset];
  1370| 	return bb == NULL || bb == td->cbb;
  1371| }
  1372| static gboolean
  1373| interp_ins_is_ldc (InterpInst *ins)
  1374| {
  1375| 	return ins->opcode >= MINT_LDC_I4_M1 && ins->opcode <= MINT_LDC_I8;
  1376| }
  1377| static gint32
  1378| interp_get_const_from_ldc_i4 (InterpInst *ins)
  1379| {
  1380| 	switch (ins->opcode) {
  1381| 	case MINT_LDC_I4_M1: return -1;
  1382| 	case MINT_LDC_I4_0: return 0;
  1383| 	case MINT_LDC_I4_1: return 1;
  1384| 	case MINT_LDC_I4_2: return 2;

# --- HUNK 3: Lines 1625-1689 ---
  1625| #endif
  1626| 			break;
  1627| 		case 2:
  1628| #if SIZEOF_VOID_P == 4
  1629| 			interp_add_ins (td, MINT_STIND_R4);
  1630| #else
  1631| 			interp_add_ins (td, MINT_STIND_R8);
  1632| #endif
  1633| 			break;
  1634| 		}
  1635| 		td->sp -= 2;
  1636| 		interp_ins_set_sregs2 (td->last_ins, td->sp [0].local, td->sp [1].local);
  1637| 		td->ip += 5;
  1638| 		return TRUE;
  1639| 	} else if (!strcmp ("op_Implicit", tm ) || !strcmp ("op_Explicit", tm)) {
  1640| 		MonoType *src = csignature->params [0];
  1641| 		MonoType *dst = csignature->ret;
  1642| 		MonoClass *src_klass = mono_class_from_mono_type_internal (src);
  1643| 		int src_size = mini_magic_type_size (NULL, src);
  1644| 		int dst_size = mini_magic_type_size (NULL, dst);
  1645| 		gboolean managed_fallback = FALSE;
  1646| 		switch (type_index) {
  1647| 		case 0: case 1:
  1648| 			if (!mini_magic_is_int_type (src) || !mini_magic_is_int_type (dst)) {
  1649| 				if (mini_magic_is_int_type (src))
  1650| 					managed_fallback = TRUE;
  1651| 				else if (mono_class_is_magic_float (src_klass))
  1652| 					managed_fallback = TRUE;
  1653| 				else
  1654| 					return FALSE;
  1655| 			}
  1656| 			break;
  1657| 		case 2:
  1658| 			if (!mini_magic_is_float_type (src) || !mini_magic_is_float_type (dst)) {
  1659| 				if (mini_magic_is_float_type (src))
  1660| 					managed_fallback = TRUE;
  1661| 				else if (mono_class_is_magic_int (src_klass))
  1662| 					managed_fallback = TRUE;
  1663| 				else
  1664| 					return FALSE;
  1665| 			}
  1666| 			break;
  1667| 		}
  1668| 		if (managed_fallback)
  1669| 			return FALSE;
  1670| 		if (src_size > dst_size) { // 8 -> 4
  1671| 			switch (type_index) {
  1672| 			case 0: case 1:
  1673| 				interp_add_conv (td, td->sp - 1, NULL, STACK_TYPE_I4, MINT_MOV_8);
  1674| 				break;
  1675| 			case 2:
  1676| 				interp_add_conv (td, td->sp - 1, NULL, STACK_TYPE_R4, MINT_CONV_R4_R8);
  1677| 				break;
  1678| 			}
  1679| 		}
  1680| 		if (src_size < dst_size) { // 4 -> 8
  1681| 			switch (type_index) {
  1682| 			case 0:
  1683| 				interp_add_conv (td, td->sp - 1, NULL, STACK_TYPE_I8, MINT_CONV_I8_I4);
  1684| 				break;
  1685| 			case 1:
  1686| 				interp_add_conv (td, td->sp - 1, NULL, STACK_TYPE_I8, MINT_CONV_I8_U4);
  1687| 				break;
  1688| 			case 2:
  1689| 				interp_add_conv (td, td->sp - 1, NULL, STACK_TYPE_R8, MINT_CONV_R8_R4);

# --- HUNK 4: Lines 1703-1742 ---
  1703| 		td->sp--;
  1704| 		interp_ins_set_sreg (td->last_ins, td->sp [0].local);
  1705| 		push_type (td, stack_type [mt], magic_class);
  1706| 		interp_ins_set_dreg (td->last_ins, td->sp [-1].local);
  1707| 		td->ip += 5;
  1708| 		return TRUE;
  1709| 	} else if (!strcmp ("op_Decrement", tm)) {
  1710| 		g_assert (type_index != 2); // no nfloat
  1711| #if SIZEOF_VOID_P == 8
  1712| 		interp_add_ins (td, MINT_SUB1_I8);
  1713| #else
  1714| 		interp_add_ins (td, MINT_SUB1_I4);
  1715| #endif
  1716| 		td->sp--;
  1717| 		interp_ins_set_sreg (td->last_ins, td->sp [0].local);
  1718| 		push_type (td, stack_type [mt], magic_class);
  1719| 		interp_ins_set_dreg (td->last_ins, td->sp [-1].local);
  1720| 		td->ip += 5;
  1721| 		return TRUE;
  1722| 	} else if (!strcmp ("CompareTo", tm) || !strcmp ("Equals", tm)) {
  1723| 		return FALSE;
  1724| 	} else if (!strcmp (".cctor", tm)) {
  1725| 		return FALSE;
  1726| 	} else if (!strcmp ("Parse", tm)) {
  1727| 		return FALSE;
  1728| 	} else if (!strcmp ("ToString", tm)) {
  1729| 		return FALSE;
  1730| 	} else if (!strcmp ("GetHashCode", tm)) {
  1731| 		return FALSE;
  1732| 	} else if (!strcmp ("IsNaN", tm) || !strcmp ("IsInfinity", tm) || !strcmp ("IsNegativeInfinity", tm) || !strcmp ("IsPositiveInfinity", tm)) {
  1733| 		g_assert (type_index == 2); // nfloat only
  1734| 		return FALSE;
  1735| 	}
  1736| 	for (i = 0; i < sizeof (int_unnop) / sizeof  (MagicIntrinsic); ++i) {
  1737| 		if (!strcmp (int_unnop [i].op_name, tm)) {
  1738| 			interp_add_ins (td, int_unnop [i].insn [type_index]);
  1739| 			td->sp--;
  1740| 			interp_ins_set_sreg (td->last_ins, td->sp [0].local);
  1741| 			push_type (td, stack_type [mt], magic_class);
  1742| 			interp_ins_set_dreg (td->last_ins, td->sp [-1].local);

# --- HUNK 5: Lines 2457-2496 ---
  2457| 		return FALSE;
  2458| 	if (header.code_size >= INLINE_LENGTH_LIMIT && !(method->iflags & METHOD_IMPL_ATTRIBUTE_AGGRESSIVE_INLINING))
  2459| 		return FALSE;
  2460| 	if (mono_class_needs_cctor_run (method->klass, NULL)) {
  2461| 		MonoVTable *vtable;
  2462| 		ERROR_DECL (error);
  2463| 		if (!m_class_get_runtime_vtable (method->klass))
  2464| 			/* No vtable created yet */
  2465| 			return FALSE;
  2466| 		vtable = mono_class_vtable_checked (method->klass, error);
  2467| 		if (!is_ok (error)) {
  2468| 			mono_interp_error_cleanup (error);
  2469| 			return FALSE;
  2470| 		}
  2471| 		if (!vtable->initialized)
  2472| 			return FALSE;
  2473| 	}
  2474| 	/* We currently access at runtime the wrapper data */
  2475| 	if (method->wrapper_type != MONO_WRAPPER_NONE)
  2476| 		return FALSE;
  2477| 	if (mono_class_get_magic_index (method->klass) >= 0)
  2478| 		return FALSE;
  2479| 	if (td->prof_coverage)
  2480| 		return FALSE;
  2481| 	if (!is_metadata_update_disabled () && mono_metadata_update_no_inline (td->method, method))
  2482| 		return FALSE;
  2483| 	if (g_list_find (td->dont_inline, method))
  2484| 		return FALSE;
  2485| 	return TRUE;
  2486| }
  2487| static gboolean
  2488| interp_inline_method (TransformData *td, MonoMethod *target_method, MonoMethodHeader *header, MonoError *error)
  2489| {
  2490| 	const unsigned char *prev_ip, *prev_il_code, *prev_in_start;
  2491| 	int *prev_in_offsets;
  2492| 	gboolean ret;
  2493| 	unsigned int prev_max_stack_height, prev_locals_size;
  2494| 	int prev_n_data_items;
  2495| 	int i; 
  2496| 	int prev_sp_offset;

# --- HUNK 6: Lines 3813-3854 ---
  3813| 	InterpMethod *rtm = td->rtm;
  3814| 	MonoMethodSignature *signature = mono_method_signature_internal (method);
  3815| 	int num_args = signature->hasthis + signature->param_count;
  3816| 	int arglist_local = -1;
  3817| 	gboolean ret = TRUE;
  3818| 	gboolean emitted_funccall_seq_point = FALSE;
  3819| 	guint32 *arg_locals = NULL;
  3820| 	guint32 *local_locals = NULL;
  3821| 	InterpInst *last_seq_point = NULL;
  3822| 	gboolean save_last_error = FALSE;
  3823| 	gboolean link_bblocks = TRUE;
  3824| 	gboolean inlining = td->method != method;
  3825| 	InterpBasicBlock *exit_bb = NULL;
  3826| 	original_bb = bb = mono_basic_block_split (method, error, header);
  3827| 	goto_if_nok (error, exit);
  3828| 	g_assert (bb);
  3829| 	td->il_code = header->code;
  3830| 	td->in_start = td->ip = header->code;
  3831| 	end = td->ip + header->code_size;
  3832| 	td->cbb = td->entry_bb = (InterpBasicBlock*)mono_mempool_alloc0 (td->mempool, sizeof (InterpBasicBlock));
  3833| 	if (td->gen_sdb_seq_points)
  3834| 		td->basic_blocks = g_list_prepend_mempool (td->mempool, td->basic_blocks, td->cbb);
  3835| 	td->cbb->index = td->bb_count++;
  3836| 	td->cbb->native_offset = -1;
  3837| 	td->cbb->stack_height = td->sp - td->stack;
  3838| 	if (inlining) {
  3839| 		exit_bb = (InterpBasicBlock*)mono_mempool_alloc0 (td->mempool, sizeof (InterpBasicBlock));
  3840| 		exit_bb->index = td->bb_count++;
  3841| 		exit_bb->native_offset = -1;
  3842| 		exit_bb->stack_height = -1;
  3843| 	}
  3844| 	get_basic_blocks (td, header, td->gen_sdb_seq_points);
  3845| 	if (!inlining)
  3846| 		initialize_clause_bblocks (td);
  3847| 	if (td->gen_sdb_seq_points && !inlining) {
  3848| 		MonoDebugMethodInfo *minfo;
  3849| 		minfo = mono_debug_lookup_method (method);
  3850| 		if (minfo) {
  3851| 			MonoSymSeqPoint *sps;
  3852| 			int i, n_il_offsets;
  3853| 			mono_debug_get_seq_points (minfo, NULL, NULL, NULL, &sps, &n_il_offsets);
  3854| 			seq_point_locs = mono_bitset_mem_new (mono_mempool_alloc0 (td->mempool, mono_bitset_alloc_size (header->code_size, 0)), header->code_size, 0);

# --- HUNK 7: Lines 5313-5353 ---
  5313| 			break;
  5314| 		}
  5315| 		case CEE_LDFLD: {
  5316| 			CHECK_STACK (td, 1);
  5317| 			token = read32 (td->ip + 1);
  5318| 			field = interp_field_from_token (method, token, &klass, generic_context, error);
  5319| 			goto_if_nok (error, exit);
  5320| 			MonoType *ftype = mono_field_get_type_internal (field);
  5321| 			gboolean is_static = !!(ftype->attrs & FIELD_ATTRIBUTE_STATIC);
  5322| 			mono_class_init_internal (klass);
  5323| 			MonoClass *field_klass = mono_class_from_mono_type_internal (ftype);
  5324| 			mt = mint_type (m_class_get_byval_arg (field_klass));
  5325| 			int field_size = mono_class_value_size (field_klass, NULL);
  5326| 			int obj_size = mono_class_value_size (klass, NULL);
  5327| 			obj_size = ALIGN_TO (obj_size, MINT_VT_ALIGNMENT);
  5328| 			{
  5329| 				if (is_static) {
  5330| 					td->sp--;
  5331| 					interp_emit_sfld_access (td, field, field_klass, mt, TRUE, error);
  5332| 					goto_if_nok (error, exit);
  5333| 				} else if (td->sp [-1].type != STACK_TYPE_O && td->sp [-1].type != STACK_TYPE_MP && (mono_class_is_magic_int (klass) || mono_class_is_magic_float (klass))) {
  5334| 				} else if (td->sp [-1].type == STACK_TYPE_VT) {
  5335| 					int size = 0;
  5336| 					/* First we pop the vt object from the stack. Then we push the field */
  5337| #ifdef NO_UNALIGNED_ACCESS
  5338| 					if (field->offset % SIZEOF_VOID_P != 0) {
  5339| 						if (mt == MINT_TYPE_I8 || mt == MINT_TYPE_R8)
  5340| 							size = 8;
  5341| 					}
  5342| #endif
  5343| 					interp_add_ins (td, MINT_MOV_OFF);
  5344| 					g_assert (m_class_is_valuetype (klass));
  5345| 					td->sp--;
  5346| 					interp_ins_set_sreg (td->last_ins, td->sp [0].local);
  5347| 					td->last_ins->data [0] = field->offset - MONO_ABI_SIZEOF (MonoObject);
  5348| 					td->last_ins->data [1] = mt;
  5349| 					if (mt == MINT_TYPE_VT)
  5350| 						size = field_size;
  5351| 					td->last_ins->data [2] = size;
  5352| 					if (mt == MINT_TYPE_VT)
  5353| 						push_type_vt (td, field_klass, field_size);


# ====================================================================
# FILE: src/mono/mono/mini/intrinsics.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1577-1624 ---
  1577| 				NULLIFY_INS (args [0]);
  1578| 				return ins;
  1579| 			}
  1580| 		}
  1581| 	} else if (cmethod->klass == mono_defaults.systemtype_class && !strcmp (cmethod->name, "op_Equality") &&
  1582| 			args [0]->klass == mono_defaults.runtimetype_class && args [1]->klass == mono_defaults.runtimetype_class) {
  1583| 		EMIT_NEW_BIALU (cfg, ins, OP_COMPARE, -1, args [0]->dreg, args [1]->dreg);
  1584| 		MONO_INST_NEW (cfg, ins, OP_PCEQ);
  1585| 		ins->dreg = alloc_preg (cfg);
  1586| 		ins->type = STACK_I4;
  1587| 		MONO_ADD_INS (cfg->cbb, ins);
  1588| 		return ins;
  1589| 	} else if (cmethod->klass == mono_defaults.systemtype_class && !strcmp (cmethod->name, "op_Inequality") &&
  1590| 			args [0]->klass == mono_defaults.runtimetype_class && args [1]->klass == mono_defaults.runtimetype_class) {
  1591| 		EMIT_NEW_BIALU (cfg, ins, OP_COMPARE, -1, args [0]->dreg, args [1]->dreg);
  1592| 		MONO_INST_NEW (cfg, ins, OP_ICNEQ);
  1593| 		ins->dreg = alloc_preg (cfg);
  1594| 		ins->type = STACK_I4;
  1595| 		MONO_ADD_INS (cfg->cbb, ins);
  1596| 		return ins;
  1597| 	} else if (((!strcmp (cmethod_klass_image->assembly->aname.name, "Xamarin.iOS") ||
  1598| 				 !strcmp (cmethod_klass_image->assembly->aname.name, "Xamarin.TVOS") ||
  1599| 				 !strcmp (cmethod_klass_image->assembly->aname.name, "Xamarin.MacCatalyst") ||
  1600| 				 !strcmp (cmethod_klass_image->assembly->aname.name, "Xamarin.Mac") ||
  1601| 				 !strcmp (cmethod_klass_image->assembly->aname.name, "Microsoft.iOS") ||
  1602| 				 !strcmp (cmethod_klass_image->assembly->aname.name, "Microsoft.tvOS") ||
  1603| 				 !strcmp (cmethod_klass_image->assembly->aname.name, "Microsoft.MacCatalyst") ||
  1604| 				 !strcmp (cmethod_klass_image->assembly->aname.name, "Microsoft.macOS")) &&
  1605| 				!strcmp (cmethod_klass_name_space, "ObjCRuntime") &&
  1606| 				!strcmp (cmethod_klass_name, "Selector"))
  1607| 			   ) {
  1608| 		if ((cfg->backend->have_objc_get_selector || cfg->compile_llvm) &&
  1609| 			!strcmp (cmethod->name, "GetHandle") && fsig->param_count == 1 &&
  1610| 		    (args [0]->opcode == OP_GOT_ENTRY || args [0]->opcode == OP_AOTCONST) &&
  1611| 		    cfg->compile_aot) {
  1612| 			MonoInst *pi;
  1613| 			MonoJumpInfoToken *ji;
  1614| 			char *s;
  1615| 			if (args [0]->opcode == OP_GOT_ENTRY) {
  1616| 				pi = (MonoInst *)args [0]->inst_p1;
  1617| 				g_assert (pi->opcode == OP_PATCH_INFO);
  1618| 				g_assert (GPOINTER_TO_INT (pi->inst_p1) == MONO_PATCH_INFO_LDSTR);
  1619| 				ji = (MonoJumpInfoToken *)pi->inst_p0;
  1620| 			} else {
  1621| 				g_assert (GPOINTER_TO_INT (args [0]->inst_p1) == MONO_PATCH_INFO_LDSTR);
  1622| 				ji = (MonoJumpInfoToken *)args [0]->inst_p0;
  1623| 			}
  1624| 			NULLIFY_INS (args [0]);


# ====================================================================
# FILE: src/mono/mono/mini/jit-icalls.c
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 707-795 ---
   707| 		mono_error_set_pending_exception (error);
   708| 		return NULL;
   709| 	}
   710| 	mono_class_init_internal (handle_class);
   711| 	return res;
   712| }
   713| gpointer
   714| mono_ldtoken_wrapper_generic_shared (MonoImage *image, int token, MonoMethod *method)
   715| {
   716| 	MonoMethodSignature *sig = mono_method_signature_internal (method);
   717| 	MonoGenericContext *generic_context;
   718| 	if (sig->is_inflated) {
   719| 		generic_context = mono_method_get_context (method);
   720| 	} else {
   721| 		MonoGenericContainer *generic_container = mono_method_get_generic_container (method);
   722| 		g_assert (generic_container);
   723| 		generic_context = &generic_container->context;
   724| 	}
   725| 	return mono_ldtoken_wrapper (image, token, generic_context);
   726| }
   727| #ifdef MONO_ARCH_EMULATE_FCONV_TO_U8
   728| guint64
   729| mono_fconv_u8 (double v)
   730| {
   731| #if defined(TARGET_X86) || defined(TARGET_AMD64)
   732| 	const double two63 = 2147483648.0 * 4294967296.0;
   733| 	if (v < two63) {
   734| 		return (gint64)v;
   735| 	} else {
   736| 		return (gint64)(v - two63) + ((guint64)1 << 63);
   737| 	}
   738| #else
   739| 	if (mono_isinf (v) || mono_isnan (v))
   740| 		return 0;
   741| 	return (guint64)v;
   742| #endif
   743| }
   744| guint64
   745| mono_rconv_u8 (float v)
   746| {
   747| #if defined(TARGET_X86) || defined(TARGET_AMD64)
   748| 	const float two63 = 2147483648.0 * 4294967296.0;
   749| 	if (v < two63) {
   750| 		return (gint64)v;
   751| 	} else {
   752| 		return (gint64)(v - two63) + ((guint64)1 << 63);
   753| 	}
   754| #else
   755| 	if (mono_isinf (v) || mono_isnan (v))
   756| 		return 0;
   757| 	return (guint64)v;
   758| #endif
   759| }
   760| #endif
   761| #ifdef MONO_ARCH_EMULATE_FCONV_TO_I8
   762| gint64
   763| mono_fconv_i8 (double v)
   764| {
   765| 	return (gint64)v;
   766| }
   767| #endif
   768| #ifdef MONO_ARCH_EMULATE_FCONV_TO_U4
   769| guint32
   770| mono_fconv_u4 (double v)
   771| {
   772| 	/* MS.NET behaves like this for some reason */
   773| 	if (mono_isinf (v) || mono_isnan (v))
   774| 		return 0;
   775| 	return (guint32)v;
   776| }
   777| guint32
   778| mono_rconv_u4 (float v)
   779| {
   780| 	if (mono_isinf (v) || mono_isnan (v))
   781| 		return 0;
   782| 	return (guint32) v;
   783| }
   784| #endif
   785| gint64
   786| mono_fconv_ovf_i8 (double v)
   787| {
   788| 	const gint64 res = (gint64)v;
   789| 	if (mono_isnan (v) || mono_trunc (v) != res) {
   790| 		ERROR_DECL (error);
   791| 		mono_error_set_overflow (error);
   792| 		mono_error_set_pending_exception (error);
   793| 		return 0;
   794| 	}
   795| 	return res;


# ====================================================================
# FILE: src/mono/mono/mini/jit-icalls.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 21-63 ---
    21| ICALL_EXPORT gint32 mono_imul_ovf (gint32 a, gint32 b);
    22| ICALL_EXPORT gint32 mono_imul_ovf_un (guint32 a, guint32 b);
    23| ICALL_EXPORT double mono_fdiv (double a, double b);
    24| ICALL_EXPORT gint64 mono_lldiv (gint64 a, gint64 b);
    25| ICALL_EXPORT gint64 mono_llrem (gint64 a, gint64 b);
    26| ICALL_EXPORT guint64 mono_lldiv_un (guint64 a, guint64 b);
    27| ICALL_EXPORT guint64 mono_llrem_un (guint64 a, guint64 b);
    28| ICALL_EXPORT guint64 mono_lshl (guint64 a, gint32 shamt);
    29| ICALL_EXPORT guint64 mono_lshr_un (guint64 a, gint32 shamt);
    30| ICALL_EXPORT gint64 mono_lshr (gint64 a, gint32 shamt);
    31| ICALL_EXPORT MonoArray *mono_array_new_n_icall (MonoMethod *cm, gint32 param_count, intptr_t *params);
    32| ICALL_EXPORT MonoArray *mono_array_new_2_jagged (MonoMethod *cm, guint32 length1, guint32 length2);
    33| ICALL_EXPORT MonoArray *mono_array_new_1 (MonoMethod *cm, guint32 length);
    34| ICALL_EXPORT MonoArray *mono_array_new_2 (MonoMethod *cm, guint32 length1, guint32 length2);
    35| ICALL_EXPORT MonoArray *mono_array_new_3 (MonoMethod *cm, guint32 length1, guint32 length2, guint32 length3);
    36| ICALL_EXPORT MonoArray *mono_array_new_4 (MonoMethod *cm, guint32 length1, guint32 length2, guint32 length3, guint32 length4);
    37| ICALL_EXPORT gpointer mono_class_static_field_address (MonoClassField *field);
    38| ICALL_EXPORT gpointer mono_ldtoken_wrapper (MonoImage *image, int token, MonoGenericContext *context);
    39| ICALL_EXPORT gpointer mono_ldtoken_wrapper_generic_shared (MonoImage *image, int token, MonoMethod *method);
    40| ICALL_EXPORT guint64 mono_fconv_u8 (double v);
    41| ICALL_EXPORT guint64 mono_rconv_u8 (float v);
    42| ICALL_EXPORT gint64 mono_fconv_i8 (double v);
    43| ICALL_EXPORT guint32 mono_fconv_u4 (double v);
    44| ICALL_EXPORT guint32 mono_rconv_u4 (float v);
    45| ICALL_EXPORT gint64 mono_fconv_ovf_i8 (double v);
    46| ICALL_EXPORT guint64 mono_fconv_ovf_u8 (double v);
    47| ICALL_EXPORT gint64 mono_rconv_i8 (float v);
    48| ICALL_EXPORT gint64 mono_rconv_ovf_i8 (float v);
    49| ICALL_EXPORT guint64 mono_rconv_ovf_u8 (float v);
    50| ICALL_EXPORT double mono_lconv_to_r8 (gint64 a);
    51| ICALL_EXPORT double mono_conv_to_r8 (gint32 a);
    52| ICALL_EXPORT double mono_conv_to_r4 (gint32 a);
    53| ICALL_EXPORT float mono_lconv_to_r4 (gint64 a);
    54| ICALL_EXPORT double mono_conv_to_r8_un (guint32 a);
    55| ICALL_EXPORT double mono_lconv_to_r8_un (guint64 a);
    56| ICALL_EXPORT gpointer mono_helper_compile_generic_method (MonoObject *obj, MonoMethod *method, gpointer *this_arg);
    57| ICALL_EXPORT MonoString *mono_helper_ldstr (MonoImage *image, guint32 idx);
    58| ICALL_EXPORT MonoString *mono_helper_ldstr_mscorlib (guint32 idx);
    59| ICALL_EXPORT MonoObject *mono_helper_newobj_mscorlib (guint32 idx);
    60| ICALL_EXPORT double mono_fsub (double a, double b);
    61| ICALL_EXPORT double mono_fadd (double a, double b);
    62| ICALL_EXPORT double mono_fmul (double a, double b);
    63| ICALL_EXPORT double mono_fneg (double a);


# ====================================================================
# FILE: src/mono/mono/mini/method-to-ir.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1016-1059 ---
  1016| 		break;
  1017| 	case MONO_CEE_CONV_U:
  1018| 		ins->type = STACK_PTR;
  1019| 		switch (src1->type) {
  1020| 		case STACK_I4:
  1021| 			ins->opcode = OP_ICONV_TO_U;
  1022| 			break;
  1023| 		case STACK_PTR:
  1024| 		case STACK_MP:
  1025| 		case STACK_OBJ:
  1026| #if TARGET_SIZEOF_VOID_P == 8
  1027| 			ins->opcode = OP_LCONV_TO_U;
  1028| #else
  1029| 			ins->opcode = OP_MOVE;
  1030| #endif
  1031| 			break;
  1032| 		case STACK_I8:
  1033| 			ins->opcode = OP_LCONV_TO_U;
  1034| 			break;
  1035| 		case STACK_R8:
  1036| 			if (TARGET_SIZEOF_VOID_P == 8)
  1037| 				ins->opcode = OP_FCONV_TO_U8;
  1038| 			else
  1039| 				ins->opcode = OP_FCONV_TO_U4;
  1040| 			break;
  1041| 		case STACK_R4:
  1042| 			if (TARGET_SIZEOF_VOID_P == 8)
  1043| 				ins->opcode = OP_RCONV_TO_U8;
  1044| 			else
  1045| 				ins->opcode = OP_RCONV_TO_U4;
  1046| 			break;
  1047| 		}
  1048| 		break;
  1049| 	case MONO_CEE_CONV_I8:
  1050| 	case MONO_CEE_CONV_U8:
  1051| 		ins->type = STACK_I8;
  1052| 		ins->opcode += unops_op_map [src1->type];
  1053| 		break;
  1054| 	case MONO_CEE_CONV_OVF_I8:
  1055| 	case MONO_CEE_CONV_OVF_U8:
  1056| 		ins->type = STACK_I8;
  1057| 		ins->opcode += ovf3ops_op_map [src1->type];
  1058| 		break;
  1059| 	case MONO_CEE_CONV_OVF_U8_UN:


# ====================================================================
# FILE: src/mono/mono/mini/mini-arm.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 5077-5116 ---
  5077| 			}
  5078| 			break;
  5079| 		}
  5080| 		case OP_FCONV_TO_I1:
  5081| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 1, TRUE);
  5082| 			break;
  5083| 		case OP_FCONV_TO_U1:
  5084| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 1, FALSE);
  5085| 			break;
  5086| 		case OP_FCONV_TO_I2:
  5087| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 2, TRUE);
  5088| 			break;
  5089| 		case OP_FCONV_TO_U2:
  5090| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 2, FALSE);
  5091| 			break;
  5092| 		case OP_FCONV_TO_I4:
  5093| 		case OP_FCONV_TO_I:
  5094| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 4, TRUE);
  5095| 			break;
  5096| 		case OP_FCONV_TO_U4:
  5097| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 4, FALSE);
  5098| 			break;
  5099| 		case OP_FCONV_TO_I8:
  5100| 		case OP_FCONV_TO_U8:
  5101| 			g_assert_not_reached ();
  5102| 			/* Implemented as helper calls */
  5103| 			break;
  5104| 		case OP_LCONV_TO_R_UN:
  5105| 			g_assert_not_reached ();
  5106| 			/* Implemented as helper calls */
  5107| 			break;
  5108| 		case OP_LCONV_TO_OVF_I4_2: {
  5109| 			guint8 *high_bit_not_set, *valid_negative, *invalid_negative, *valid_positive;
  5110| 			/* 
  5111| 			 * Valid ints: 0xffffffff:8000000 to 00000000:0x7f000000
  5112| 			 */
  5113| 			ARM_CMP_REG_IMM8 (code, ins->sreg1, 0);
  5114| 			high_bit_not_set = code;
  5115| 			ARM_B_COND (code, ARMCOND_GE, 0); /*branch if bit 31 of the lower part is not set*/
  5116| 			ARM_CMN_REG_IMM8 (code, ins->sreg2, 1); /*This have the same effect as CMP reg, 0xFFFFFFFF */


# ====================================================================
# FILE: src/mono/mono/mini/mini-llvm.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 871-910 ---
   871| 		return LLVMInt32Type ();
   872| 	case OP_FCONV_TO_I8:
   873| 		return LLVMInt64Type ();
   874| 	case OP_FCONV_TO_I1:
   875| 	case OP_FCONV_TO_U1:
   876| 	case OP_RCONV_TO_I1:
   877| 	case OP_RCONV_TO_U1:
   878| 		return LLVMInt8Type ();
   879| 	case OP_FCONV_TO_I2:
   880| 	case OP_FCONV_TO_U2:
   881| 	case OP_RCONV_TO_I2:
   882| 	case OP_RCONV_TO_U2:
   883| 		return LLVMInt16Type ();
   884| 	case OP_FCONV_TO_U4:
   885| 	case OP_RCONV_TO_U4:
   886| 		return LLVMInt32Type ();
   887| 	case OP_FCONV_TO_U8:
   888| 	case OP_RCONV_TO_U8:
   889| 		return LLVMInt64Type ();
   890| 	case OP_FCONV_TO_I:
   891| 		return TARGET_SIZEOF_VOID_P == 8 ? LLVMInt64Type () : LLVMInt32Type ();
   892| 	case OP_IADD_OVF:
   893| 	case OP_IADD_OVF_UN:
   894| 	case OP_ISUB_OVF:
   895| 	case OP_ISUB_OVF_UN:
   896| 	case OP_IMUL_OVF:
   897| 	case OP_IMUL_OVF_UN:
   898| 		return LLVMInt32Type ();
   899| 	case OP_LADD_OVF:
   900| 	case OP_LADD_OVF_UN:
   901| 	case OP_LSUB_OVF:
   902| 	case OP_LSUB_OVF_UN:
   903| 	case OP_LMUL_OVF:
   904| 	case OP_LMUL_OVF_UN:
   905| 		return LLVMInt64Type ();
   906| 	default:
   907| 		printf ("%s\n", mono_inst_name (opcode));
   908| 		g_assert_not_reached ();
   909| 		return NULL;
   910| 	}


# ====================================================================
# FILE: src/mono/mono/mini/mini-mips.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 3829-3868 ---
  3829| 			mips_mtc1 (code, mips_ftemp, ins->sreg1);
  3830| 			mips_cvtdw (code, ins->dreg, mips_ftemp);
  3831| 			break;
  3832| 		case OP_FCONV_TO_I1:
  3833| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 1, TRUE);
  3834| 			break;
  3835| 		case OP_FCONV_TO_U1:
  3836| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 1, FALSE);
  3837| 			break;
  3838| 		case OP_FCONV_TO_I2:
  3839| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 2, TRUE);
  3840| 			break;
  3841| 		case OP_FCONV_TO_U2:
  3842| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 2, FALSE);
  3843| 			break;
  3844| 		case OP_FCONV_TO_I4:
  3845| 		case OP_FCONV_TO_I:
  3846| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 4, TRUE);
  3847| 			break;
  3848| 		case OP_FCONV_TO_U4:
  3849| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 4, FALSE);
  3850| 			break;
  3851| 		case OP_SQRT:
  3852| 			mips_fsqrtd (code, ins->dreg, ins->sreg1);
  3853| 			break;
  3854| 		case OP_FADD:
  3855| 			mips_faddd (code, ins->dreg, ins->sreg1, ins->sreg2);
  3856| 			break;
  3857| 		case OP_FSUB:
  3858| 			mips_fsubd (code, ins->dreg, ins->sreg1, ins->sreg2);
  3859| 			break;		
  3860| 		case OP_FMUL:
  3861| 			mips_fmuld (code, ins->dreg, ins->sreg1, ins->sreg2);
  3862| 			break;		
  3863| 		case OP_FDIV:
  3864| 			mips_fdivd (code, ins->dreg, ins->sreg1, ins->sreg2);
  3865| 			break;		
  3866| 		case OP_FNEG:
  3867| 			mips_fnegd (code, ins->dreg, ins->sreg1);
  3868| 			break;		


# ====================================================================
# FILE: src/mono/mono/mini/mini-native-types.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 295-342 ---
   295| 			return emit_intrinsics (cfg, cmethod, fsig, args, &type_info [1]);
   296| 	} else if (mono_class_is_magic_float (cmethod->klass))
   297| 		return emit_intrinsics (cfg, cmethod, fsig, args, &type_info [2]);
   298| 	return NULL;
   299| }
   300| #endif /* !DISABLE_JIT */
   301| static gboolean
   302| mono_class_is_magic_assembly (MonoClass *klass)
   303| {
   304| 	const char *aname = m_class_get_image (klass)->assembly_name;
   305| 	if (!aname)
   306| 		return FALSE;
   307| 	if (!strcmp ("Xamarin.iOS", aname))
   308| 		return TRUE;
   309| 	if (!strcmp ("Xamarin.Mac", aname))
   310| 		return TRUE;
   311| 	if (!strcmp ("Xamarin.WatchOS", aname))
   312| 		return TRUE;
   313| 	if (!strcmp ("Xamarin.MacCatalyst", aname))
   314| 		return TRUE;
   315| 	if (!strcmp ("Microsoft.iOS", aname))
   316| 		return TRUE;
   317| 	if (!strcmp ("Microsoft.macOS", aname))
   318| 		return TRUE;
   319| 	if (!strcmp ("Microsoft.watchOS", aname))
   320| 		return TRUE;
   321| 	if (!strcmp ("Microsoft.MacCatalyst", aname))
   322| 		return TRUE;
   323| 	/* regression test suite */
   324| 	if (!strcmp ("builtin-types", aname))
   325| 		return TRUE;
   326| 	if (!strcmp ("mini_tests", aname))
   327| 		return TRUE;
   328| 	return FALSE;
   329| }
   330| gboolean
   331| mono_class_is_magic_int (MonoClass *klass)
   332| {
   333| 	static MonoClass *magic_nint_class;
   334| 	static MonoClass *magic_nuint_class;
   335| 	if (klass == magic_nint_class)
   336| 		return TRUE;
   337| 	if (klass == magic_nuint_class)
   338| 		return TRUE;
   339| 	if (magic_nint_class && magic_nuint_class)
   340| 		return FALSE;
   341| 	if (!mono_class_is_magic_assembly (klass))
   342| 		return FALSE;


# ====================================================================
# FILE: src/mono/mono/mini/mini-ops.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 508-547 ---
   508| MINI_OP(OP_FCONV_TO_OVF_I2,"float_conv_to_ovf_i2", IREG, FREG, NONE)
   509| MINI_OP(OP_FCONV_TO_OVF_U2,"float_conv_to_ovf_u2", IREG, FREG, NONE)
   510| MINI_OP(OP_FCONV_TO_OVF_I4,"float_conv_to_ovf_i4", IREG, FREG, NONE)
   511| MINI_OP(OP_FCONV_TO_OVF_U4,"float_conv_to_ovf_u4", IREG, FREG, NONE)
   512| MINI_OP(OP_FCONV_TO_OVF_I8,"float_conv_to_ovf_i8", LREG, FREG, NONE)
   513| MINI_OP(OP_FCONV_TO_OVF_U8,"float_conv_to_ovf_u8", LREG, FREG, NONE)
   514| /* These do the comparison too */
   515| MINI_OP(OP_FCEQ,   "float_ceq", IREG, FREG, FREG)
   516| MINI_OP(OP_FCGT,   "float_cgt", IREG, FREG, FREG)
   517| MINI_OP(OP_FCGT_UN,"float_cgt_un", IREG, FREG, FREG)
   518| MINI_OP(OP_FCLT,   "float_clt", IREG, FREG, FREG)
   519| MINI_OP(OP_FCLT_UN,"float_clt_un", IREG, FREG, FREG)
   520| MINI_OP(OP_FCNEQ,  "float_cneq", IREG, FREG, FREG)
   521| MINI_OP(OP_FCGE,   "float_cge", IREG, FREG, FREG)
   522| MINI_OP(OP_FCLE,   "float_cle", IREG, FREG, FREG)
   523| MINI_OP(OP_FCEQ_MEMBASE,   "float_ceq_membase", IREG, FREG, IREG)
   524| MINI_OP(OP_FCGT_MEMBASE,   "float_cgt_membase", IREG, FREG, IREG)
   525| MINI_OP(OP_FCGT_UN_MEMBASE,"float_cgt_un_membase", IREG, FREG, IREG)
   526| MINI_OP(OP_FCLT_MEMBASE,   "float_clt_membase", IREG, FREG, IREG)
   527| MINI_OP(OP_FCLT_UN_MEMBASE,"float_clt_un_membase", IREG, FREG, IREG)
   528| MINI_OP(OP_CKFINITE, "ckfinite", FREG, FREG, NONE)
   529| /* r4 opcodes: must be in the same order as the matching CEE_ opcodes: ovfops_op_map */
   530| MINI_OP(OP_RCONV_TO_U2,   "r4_conv_to_u2", IREG, FREG, NONE)
   531| MINI_OP(OP_RCONV_TO_U1,   "r4_conv_to_u1", IREG, FREG, NONE)
   532| MINI_OP(OP_RCONV_TO_I,    "r4_conv_to_i", IREG, FREG, NONE)
   533| MINI_OP(OP_RCONV_TO_OVF_I,"r4_conv_to_ovf_i", IREG, FREG, NONE)
   534| MINI_OP(OP_RCONV_TO_OVF_U,"r4_conv_to_ovd_u", IREG, FREG, NONE)
   535| /* r4 opcodes: must be in the same order as the matching CEE_ opcodes: ovfops_op_map */
   536| MINI_OP(OP_RADD_OVF,      "r4_add_ovf", FREG, FREG, FREG)
   537| MINI_OP(OP_RADD_OVF_UN,   "r4_add_ovf_un", FREG, FREG, FREG)
   538| MINI_OP(OP_RMUL_OVF,      "r4_mul_ovf", FREG, FREG, FREG)
   539| MINI_OP(OP_RMUL_OVF_UN,   "r4_mul_ovf_un", FREG, FREG, FREG)
   540| MINI_OP(OP_RSUB_OVF,      "r4_sub_ovf", FREG, FREG, FREG)
   541| MINI_OP(OP_RSUB_OVF_UN,   "r4_sub_ovf_un", FREG, FREG, FREG)
   542| MINI_OP(OP_RCONV_TO_OVF_I1_UN,"r4_conv_to_ovf_i1_un", IREG, FREG, NONE)
   543| MINI_OP(OP_RCONV_TO_OVF_I2_UN,"r4_conv_to_ovf_i2_un", IREG, FREG, NONE)
   544| MINI_OP(OP_RCONV_TO_OVF_I4_UN,"r4_conv_to_ovf_i4_un", IREG, FREG, NONE)
   545| MINI_OP(OP_RCONV_TO_OVF_I8_UN,"r4_conv_to_ovf_i8_un", IREG, FREG, NONE)
   546| MINI_OP(OP_RCONV_TO_OVF_U1_UN,"r4_conv_to_ovf_u1_un", IREG, FREG, NONE)
   547| MINI_OP(OP_RCONV_TO_OVF_U2_UN,"r4_conv_to_ovf_u2_un", IREG, FREG, NONE)


# ====================================================================
# FILE: src/mono/mono/mini/mini-ppc.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 3802-3841 ---
  3802| 		case CEE_CONV_R4: /* FIXME: change precision */
  3803| 		case CEE_CONV_R8:
  3804| 			g_assert_not_reached ();
  3805| 		case OP_FCONV_TO_I1:
  3806| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 1, TRUE);
  3807| 			break;
  3808| 		case OP_FCONV_TO_U1:
  3809| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 1, FALSE);
  3810| 			break;
  3811| 		case OP_FCONV_TO_I2:
  3812| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 2, TRUE);
  3813| 			break;
  3814| 		case OP_FCONV_TO_U2:
  3815| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 2, FALSE);
  3816| 			break;
  3817| 		case OP_FCONV_TO_I4:
  3818| 		case OP_FCONV_TO_I:
  3819| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 4, TRUE);
  3820| 			break;
  3821| 		case OP_FCONV_TO_U4:
  3822| 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 4, FALSE);
  3823| 			break;
  3824| 		case OP_LCONV_TO_R_UN:
  3825| 			g_assert_not_reached ();
  3826| 			/* Implemented as helper calls */
  3827| 			break;
  3828| 		case OP_LCONV_TO_OVF_I4_2:
  3829| 		case OP_LCONV_TO_OVF_I: {
  3830| #ifdef __mono_ppc64__
  3831| 			NOT_IMPLEMENTED;
  3832| #else
  3833| 			guint8 *negative_branch, *msword_positive_branch, *msword_negative_branch, *ovf_ex_target;
  3834| 			ppc_cmpi (code, 0, 0, ins->sreg1, 0);
  3835| 			negative_branch = code;
  3836| 			ppc_bc (code, PPC_BR_TRUE, PPC_BR_LT, 0);
  3837| 			ppc_cmpi (code, 0, 0, ins->sreg2, 0);
  3838| 			msword_positive_branch = code;
  3839| 			ppc_bc (code, PPC_BR_TRUE, PPC_BR_EQ, 0);
  3840| 			ovf_ex_target = code;
  3841| 			EMIT_COND_SYSTEM_EXCEPTION_FLAGS (PPC_BR_ALWAYS, 0, "OverflowException");


# ====================================================================
# FILE: src/mono/mono/mini/mini-runtime.c
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 3972-4016 ---
  3972| 	register_opcode_emulation (OP_LSHR, __emul_lshr, mono_icall_sig_long_long_int32, mono_lshr, TRUE);
  3973| 	register_opcode_emulation (OP_LSHR_UN, __emul_lshr_un, mono_icall_sig_long_long_int32, mono_lshr_un, TRUE);
  3974| #endif
  3975| #if defined(MONO_ARCH_EMULATE_MUL_DIV) || defined(MONO_ARCH_EMULATE_DIV)
  3976| 	register_opcode_emulation (OP_IDIV, __emul_op_idiv, mono_icall_sig_int32_int32_int32, mono_idiv, FALSE);
  3977| 	register_opcode_emulation (OP_IDIV_UN, __emul_op_idiv_un, mono_icall_sig_int32_int32_int32, mono_idiv_un, FALSE);
  3978| 	register_opcode_emulation (OP_IREM, __emul_op_irem, mono_icall_sig_int32_int32_int32, mono_irem, FALSE);
  3979| 	register_opcode_emulation (OP_IREM_UN, __emul_op_irem_un, mono_icall_sig_int32_int32_int32, mono_irem_un, FALSE);
  3980| #endif
  3981| #ifdef MONO_ARCH_EMULATE_MUL_DIV
  3982| 	register_opcode_emulation (OP_IMUL, __emul_op_imul, mono_icall_sig_int32_int32_int32, mono_imul, TRUE);
  3983| #endif
  3984| #if defined(MONO_ARCH_EMULATE_MUL_DIV) || defined(MONO_ARCH_EMULATE_MUL_OVF)
  3985| 	register_opcode_emulation (OP_IMUL_OVF, __emul_op_imul_ovf, mono_icall_sig_int32_int32_int32, mono_imul_ovf, FALSE);
  3986| 	register_opcode_emulation (OP_IMUL_OVF_UN, __emul_op_imul_ovf_un, mono_icall_sig_int32_int32_int32, mono_imul_ovf_un, FALSE);
  3987| #endif
  3988| #if defined(MONO_ARCH_EMULATE_MUL_DIV) || defined(MONO_ARCH_SOFT_FLOAT_FALLBACK)
  3989| 	register_opcode_emulation (OP_FDIV, __emul_fdiv, mono_icall_sig_double_double_double, mono_fdiv, FALSE);
  3990| #endif
  3991| #ifdef MONO_ARCH_EMULATE_FCONV_TO_U8
  3992| 	register_opcode_emulation (OP_FCONV_TO_U8, __emul_fconv_to_u8, mono_icall_sig_ulong_double, mono_fconv_u8, FALSE);
  3993| 	register_opcode_emulation (OP_RCONV_TO_U8, __emul_rconv_to_u8, mono_icall_sig_ulong_float, mono_rconv_u8, FALSE);
  3994| #endif
  3995| #ifdef MONO_ARCH_EMULATE_FCONV_TO_U4
  3996| 	register_opcode_emulation (OP_FCONV_TO_U4, __emul_fconv_to_u4, mono_icall_sig_uint32_double, mono_fconv_u4, FALSE);
  3997| 	register_opcode_emulation (OP_RCONV_TO_U4, __emul_rconv_to_u4, mono_icall_sig_uint32_float, mono_rconv_u4, FALSE);
  3998| #endif
  3999| 	register_opcode_emulation (OP_FCONV_TO_OVF_I8, __emul_fconv_to_ovf_i8, mono_icall_sig_long_double, mono_fconv_ovf_i8, FALSE);
  4000| 	register_opcode_emulation (OP_FCONV_TO_OVF_U8, __emul_fconv_to_ovf_u8, mono_icall_sig_ulong_double, mono_fconv_ovf_u8, FALSE);
  4001| 	register_opcode_emulation (OP_RCONV_TO_OVF_I8, __emul_rconv_to_ovf_i8, mono_icall_sig_long_float, mono_rconv_ovf_i8, FALSE);
  4002| 	register_opcode_emulation (OP_RCONV_TO_OVF_U8, __emul_rconv_to_ovf_u8, mono_icall_sig_ulong_float, mono_rconv_ovf_u8, FALSE);
  4003| #ifdef MONO_ARCH_EMULATE_FCONV_TO_I8
  4004| 	register_opcode_emulation (OP_FCONV_TO_I8, __emul_fconv_to_i8, mono_icall_sig_long_double, mono_fconv_i8, FALSE);
  4005| 	register_opcode_emulation (OP_RCONV_TO_I8, __emul_rconv_to_i8, mono_icall_sig_long_float, mono_rconv_i8, FALSE);
  4006| #endif
  4007| #ifdef MONO_ARCH_EMULATE_CONV_R8_UN
  4008| 	register_opcode_emulation (OP_ICONV_TO_R_UN, __emul_iconv_to_r_un, mono_icall_sig_double_int32, mono_conv_to_r8_un, FALSE);
  4009| #endif
  4010| #ifdef MONO_ARCH_EMULATE_LCONV_TO_R8
  4011| 	register_opcode_emulation (OP_LCONV_TO_R8, __emul_lconv_to_r8, mono_icall_sig_double_long, mono_lconv_to_r8, FALSE);
  4012| #endif
  4013| #ifdef MONO_ARCH_EMULATE_LCONV_TO_R4
  4014| 	register_opcode_emulation (OP_LCONV_TO_R4, __emul_lconv_to_r4, mono_icall_sig_float_long, mono_lconv_to_r4, FALSE);
  4015| #endif
  4016| #ifdef MONO_ARCH_EMULATE_LCONV_TO_R8_UN

# --- HUNK 2: Lines 4044-4083 ---
  4044| 		register_opcode_emulation (OP_FBGE, __emul_fcmp_ge, mono_icall_sig_uint32_double_double, mono_fcmp_ge, FALSE);
  4045| 		register_opcode_emulation (OP_FBNE_UN, __emul_fcmp_ne_un, mono_icall_sig_uint32_double_double, mono_fcmp_ne_un, FALSE);
  4046| 		register_opcode_emulation (OP_FBLT_UN, __emul_fcmp_lt_un, mono_icall_sig_uint32_double_double, mono_fcmp_lt_un, FALSE);
  4047| 		register_opcode_emulation (OP_FBGT_UN, __emul_fcmp_gt_un, mono_icall_sig_uint32_double_double, mono_fcmp_gt_un, FALSE);
  4048| 		register_opcode_emulation (OP_FBLE_UN, __emul_fcmp_le_un, mono_icall_sig_uint32_double_double, mono_fcmp_le_un, FALSE);
  4049| 		register_opcode_emulation (OP_FBGE_UN, __emul_fcmp_ge_un, mono_icall_sig_uint32_double_double, mono_fcmp_ge_un, FALSE);
  4050| 		register_opcode_emulation (OP_FCEQ, __emul_fcmp_ceq, mono_icall_sig_uint32_double_double, mono_fceq, FALSE);
  4051| 		register_opcode_emulation (OP_FCGT, __emul_fcmp_cgt, mono_icall_sig_uint32_double_double, mono_fcgt, FALSE);
  4052| 		register_opcode_emulation (OP_FCGT_UN, __emul_fcmp_cgt_un, mono_icall_sig_uint32_double_double, mono_fcgt_un, FALSE);
  4053| 		register_opcode_emulation (OP_FCLT, __emul_fcmp_clt, mono_icall_sig_uint32_double_double, mono_fclt, FALSE);
  4054| 		register_opcode_emulation (OP_FCLT_UN, __emul_fcmp_clt_un, mono_icall_sig_uint32_double_double, mono_fclt_un, FALSE);
  4055| 		register_icall (mono_fload_r4, mono_icall_sig_double_ptr, FALSE);
  4056| 		register_icall (mono_fstore_r4, mono_icall_sig_void_double_ptr, FALSE);
  4057| 		register_icall (mono_fload_r4_arg, mono_icall_sig_uint32_double, FALSE);
  4058| 		register_icall (mono_isfinite_double, mono_icall_sig_int32_double, FALSE);
  4059| 	}
  4060| #endif
  4061| 	register_icall (mono_ckfinite, mono_icall_sig_double_double, FALSE);
  4062| #ifdef COMPRESSED_INTERFACE_BITMAP
  4063| 	register_icall (mono_class_interface_match, mono_icall_sig_uint32_ptr_int32, TRUE);
  4064| #endif
  4065| 	/* other jit icalls */
  4066| 	register_icall (ves_icall_mono_delegate_ctor, mono_icall_sig_void_object_object_ptr, FALSE);
  4067| 	register_icall (ves_icall_mono_delegate_ctor_interp, mono_icall_sig_void_object_object_ptr, FALSE);
  4068| 	register_icall (mono_class_static_field_address,
  4069| 				 mono_icall_sig_ptr_ptr, FALSE);
  4070| 	register_icall (mono_ldtoken_wrapper, mono_icall_sig_ptr_ptr_ptr_ptr, FALSE);
  4071| 	register_icall (mono_ldtoken_wrapper_generic_shared,
  4072| 		mono_icall_sig_ptr_ptr_ptr_ptr, FALSE);
  4073| 	register_icall (mono_get_special_static_data, mono_icall_sig_ptr_int, FALSE);
  4074| 	register_icall (mono_helper_stelem_ref_check, mono_icall_sig_void_object_object, FALSE);
  4075| 	register_icall (ves_icall_object_new, mono_icall_sig_object_ptr, FALSE);
  4076| 	register_icall (ves_icall_object_new_specific, mono_icall_sig_object_ptr, FALSE);
  4077| 	register_icall (ves_icall_array_new_specific, mono_icall_sig_object_ptr_int32, FALSE);
  4078| 	register_icall (ves_icall_runtime_class_init, mono_icall_sig_void_ptr, FALSE);
  4079| 	register_icall (mono_ldftn, mono_icall_sig_ptr_ptr, FALSE);
  4080| 	register_icall (mono_ldvirtfn, mono_icall_sig_ptr_object_ptr, FALSE);
  4081| 	register_icall (mono_ldvirtfn_gshared, mono_icall_sig_ptr_object_ptr, FALSE);
  4082| 	register_icall (mono_helper_compile_generic_method, mono_icall_sig_ptr_object_ptr_ptr, FALSE);
  4083| 	register_icall (mono_helper_ldstr, mono_icall_sig_object_ptr_int, FALSE);


# ====================================================================
# FILE: src/mono/mono/mini/mini-s390x.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 3928-3967 ---
  3928| 			s390_ltgr  (code, ins->dreg, ins->dreg);
  3929| 			s390_jnl   (code, 4);
  3930| 			s390_oill  (code, ins->dreg, 0x8000);
  3931| 			s390_llill (code, s390_r0, 0xffff);
  3932| 			s390_ngr   (code, ins->dreg, s390_r0);
  3933| 			break;
  3934| 		case OP_FCONV_TO_U2:
  3935| 			if (mono_hwcap_s390x_has_fpe) {
  3936| 				s390_clgdbr (code, ins->dreg, 5, ins->sreg1, 0);
  3937| 				s390_llill  (code, s390_r0, 0xffff);
  3938| 				s390_ngr    (code, ins->dreg, s390_r0);
  3939| 			} else {
  3940| 				code = emit_double_to_int (cfg, code, ins->dreg, ins->sreg1, 2, FALSE);
  3941| 			}
  3942| 			break;
  3943| 		case OP_FCONV_TO_I4:
  3944| 		case OP_FCONV_TO_I:
  3945| 			s390_cfdbr (code, ins->dreg, 5, ins->sreg1);
  3946| 			break;
  3947| 		case OP_FCONV_TO_U4:
  3948| 			if (mono_hwcap_s390x_has_fpe) {
  3949| 				s390_clgdbr (code, ins->dreg, 5, ins->sreg1, 0);
  3950| 			} else {
  3951| 				code = emit_double_to_int (cfg, code, ins->dreg, ins->sreg1, 4, FALSE);
  3952| 			}
  3953| 			break;
  3954| 		case OP_FCONV_TO_I8:
  3955| 			s390_cgdbr (code, ins->dreg, 5, ins->sreg1);
  3956| 			break;
  3957| 		case OP_FCONV_TO_U8:
  3958| 			if (mono_hwcap_s390x_has_fpe) {
  3959| 				s390_clgdbr (code, ins->dreg, 5, ins->sreg1, 0);
  3960| 			} else {
  3961| 				code = emit_double_to_int (cfg, code, ins->dreg, ins->sreg1, 8, FALSE);
  3962| 			}
  3963| 			break;
  3964| 		case OP_RCONV_TO_I1:
  3965| 			s390_cgebr (code, ins->dreg, 5, ins->sreg1);
  3966| 			s390_ltgr  (code, ins->dreg, ins->dreg);
  3967| 			s390_jnl   (code, 4);


# ====================================================================
# FILE: src/mono/mono/mini/mini-sparc.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 3060-3099 ---
  3060| 			sparc_fxtod (code, FP_SCRATCH_REG, ins->dreg);
  3061| #else
  3062| 			if (!sparc_is_imm13 (offset)) {
  3063| 				sparc_set (code, offset, sparc_o7);
  3064| 				sparc_st (code, ins->sreg1, reg, sparc_o7);
  3065| 				sparc_ldf (code, reg, sparc_o7, FP_SCRATCH_REG);
  3066| 			} else {
  3067| 				sparc_st_imm (code, ins->sreg1, reg, offset);
  3068| 				sparc_ldf_imm (code, reg, offset, FP_SCRATCH_REG);
  3069| 			}
  3070| 			sparc_fitod (code, FP_SCRATCH_REG, ins->dreg);
  3071| #endif
  3072| 			break;
  3073| 		}
  3074| 		case OP_FCONV_TO_I1:
  3075| 		case OP_FCONV_TO_U1:
  3076| 		case OP_FCONV_TO_I2:
  3077| 		case OP_FCONV_TO_U2:
  3078| #ifndef SPARCV9
  3079| 		case OP_FCONV_TO_I:
  3080| #endif
  3081| 		case OP_FCONV_TO_I4:
  3082| 		case OP_FCONV_TO_U4: {
  3083| 			MonoInst *spill = cfg->arch.float_spill_slot;
  3084| 			gint32 reg = spill->inst_basereg;
  3085| 			gint32 offset = spill->inst_offset;
  3086| 			g_assert (spill->opcode == OP_REGOFFSET);
  3087| 			sparc_fdtoi (code, ins->sreg1, FP_SCRATCH_REG);
  3088| 			if (!sparc_is_imm13 (offset)) {
  3089| 				sparc_set (code, offset, sparc_o7);
  3090| 				sparc_stdf (code, FP_SCRATCH_REG, reg, sparc_o7);
  3091| 				sparc_ld (code, reg, sparc_o7, ins->dreg);
  3092| 			} else {
  3093| 				sparc_stdf_imm (code, FP_SCRATCH_REG, reg, offset);
  3094| 				sparc_ld_imm (code, reg, offset, ins->dreg);
  3095| 			}
  3096| 			switch (ins->opcode) {
  3097| 			case OP_FCONV_TO_I1:
  3098| 			case OP_FCONV_TO_U1:
  3099| 				sparc_and_imm (code, 0, ins->dreg, 0xff, ins->dreg);


# ====================================================================
# FILE: src/mono/mono/sgen/sgen-cardtable.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 481-523 ---
   481| 			return (guint8*)cards + find_card_offset (card);
   482| 		++cards;
   483| 	}
   484| 	card_data = (guint8*)cards_end;
   485| 	while (card_data < end) {
   486| 		if (*card_data)
   487| 			return card_data;
   488| 		++card_data;
   489| 	}
   490| 	return end;
   491| }
   492| void
   493| sgen_cardtable_scan_object (GCObject *obj, mword block_obj_size, guint8 *cards, ScanCopyContext ctx)
   494| {
   495| 	HEAVY_STAT (++large_objects);
   496| 	if (sgen_client_cardtable_scan_object (obj, cards, ctx))
   497| 		return;
   498| 	HEAVY_STAT (++bloby_objects);
   499| 	if (cards) {
   500| 		if (sgen_card_table_is_range_marked (cards, (mword)obj, block_obj_size))
   501| 			ctx.ops->scan_object (obj, sgen_obj_get_descriptor_safe (obj), ctx.queue);
   502| 	} else if (sgen_card_table_region_begin_scanning ((mword)obj, block_obj_size)) {
   503| 		ctx.ops->scan_object (obj, sgen_obj_get_descriptor_safe (obj), ctx.queue);
   504| 	}
   505| 	sgen_binary_protocol_card_scan (obj, sgen_safe_object_get_size (obj));
   506| }
   507| void
   508| sgen_card_table_init (SgenRememberedSet *remset)
   509| {
   510| 	sgen_cardtable = (guint8 *)sgen_alloc_os_memory (CARD_COUNT_IN_BYTES, (SgenAllocFlags)(SGEN_ALLOC_INTERNAL | SGEN_ALLOC_ACTIVATE), "card table", MONO_MEM_ACCOUNT_SGEN_CARD_TABLE);
   511| #ifdef SGEN_HAVE_OVERLAPPING_CARDS
   512| 	sgen_shadow_cardtable = (guint8 *)sgen_alloc_os_memory (CARD_COUNT_IN_BYTES, (SgenAllocFlags)(SGEN_ALLOC_INTERNAL | SGEN_ALLOC_ACTIVATE), "shadow card table", MONO_MEM_ACCOUNT_SGEN_SHADOW_CARD_TABLE);
   513| #endif
   514| #ifdef HEAVY_STATISTICS
   515| 	mono_counters_register ("marked cards", MONO_COUNTER_GC | MONO_COUNTER_ULONG, &marked_cards);
   516| 	mono_counters_register ("scanned cards", MONO_COUNTER_GC | MONO_COUNTER_ULONG, &scanned_cards);
   517| 	mono_counters_register ("remarked cards", MONO_COUNTER_GC | MONO_COUNTER_ULONG, &remarked_cards);
   518| 	mono_counters_register ("cardtable scanned objects", MONO_COUNTER_GC | MONO_COUNTER_ULONG, &scanned_objects);
   519| 	mono_counters_register ("cardtable large objects", MONO_COUNTER_GC | MONO_COUNTER_ULONG, &large_objects);
   520| 	mono_counters_register ("cardtable bloby objects", MONO_COUNTER_GC | MONO_COUNTER_ULONG, &bloby_objects);
   521| #endif
   522| 	remset->wbarrier_set_field = sgen_card_table_wbarrier_set_field;
   523| 	remset->wbarrier_arrayref_copy = sgen_card_table_wbarrier_arrayref_copy;


# ====================================================================
# FILE: src/mono/mono/sgen/sgen-marksweep.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 2215-2255 ---
  2215| 		if (card_index <= (MS_BLOCK_SKIP >> CARD_BITS))
  2216| 			first_object_index = 0;
  2217| 		else
  2218| 			first_object_index = MS_BLOCK_OBJ_INDEX_FAST (start, block_start, block_obj_size);
  2219| 		obj = first_obj = (char*)MS_BLOCK_OBJ_FAST (block_start, block_obj_size, first_object_index);
  2220| 		sgen_binary_protocol_card_scan (first_obj, end - first_obj);
  2221| 		while (obj < end) {
  2222| 			if (obj < scan_front || !MS_OBJ_ALLOCED_FAST (obj, block_start))
  2223| 				goto next_object;
  2224| 			if (scan_type & CARDTABLE_SCAN_MOD_UNION) {
  2225| 				/* FIXME: do this more efficiently */
  2226| 				int w, b;
  2227| 				MS_CALC_MARK_BIT (w, b, obj);
  2228| 				if (!MS_MARK_BIT (block, w, b))
  2229| 					goto next_object;
  2230| 			}
  2231| 			GCObject *object;
  2232| 			object = (GCObject*)obj;
  2233| 			if (small_objects) {
  2234| 				HEAVY_STAT (++scanned_objects);
  2235| 				scan_func (object, sgen_obj_get_descriptor_safe (object), queue);
  2236| 			} else {
  2237| 				size_t offset = sgen_card_table_get_card_offset (obj, block_start);
  2238| 				sgen_cardtable_scan_object (object, block_obj_size, card_base + offset, ctx);
  2239| 			}
  2240| 		next_object:
  2241| 			obj += block_obj_size;
  2242| 			g_assert (scan_front <= obj);
  2243| 			scan_front = obj;
  2244| 		}
  2245| 		HEAVY_STAT (if (*card_data) ++remarked_cards);
  2246| 		if (small_objects)
  2247| 			++card_data;
  2248| 		else
  2249| 			card_data = card_base + sgen_card_table_get_card_offset (obj, block_start);
  2250| 	}
  2251| }
  2252| static void
  2253| major_scan_card_table (CardTableScanType scan_type, ScanCopyContext ctx, int job_index, int job_split_count, int block_count)
  2254| {
  2255| 	MSBlockInfo *block;


# ====================================================================
# FILE: src/mono/wasm/debugger/BrowserDebugProxy/DebugStore.cs
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 399-483 ---
   399|         public string FullName { get; }
   400|         public List<MethodInfo> Methods => methods;
   401|         public override string ToString() => "TypeInfo('" + FullName + "')";
   402|     }
   403|     internal class AssemblyInfo
   404|     {
   405|         private static int next_id;
   406|         private readonly int id;
   407|         private readonly ILogger logger;
   408|         private Dictionary<int, MethodInfo> methods = new Dictionary<int, MethodInfo>();
   409|         private Dictionary<string, string> sourceLinkMappings = new Dictionary<string, string>();
   410|         private readonly List<SourceFile> sources = new List<SourceFile>();
   411|         internal string Url { get; }
   412|         internal MetadataReader asmMetadataReader { get; }
   413|         internal MetadataReader pdbMetadataReader { get; set; }
   414|         internal List<MemoryStream> enCMemoryStream  = new List<MemoryStream>();
   415|         internal List<MetadataReader> enCMetadataReader  = new List<MetadataReader>();
   416|         internal PEReader peReader;
   417|         internal MemoryStream asmStream;
   418|         internal MemoryStream pdbStream;
   419|         private int debugId;
   420|         public bool TriedToLoadSymbolsOnDemand { get; set; }
   421|         public unsafe AssemblyInfo(string url, byte[] assembly, byte[] pdb)
   422|         {
   423|             debugId = -1;
   424|             this.id = Interlocked.Increment(ref next_id);
   425|             asmStream = new MemoryStream(assembly);
   426|             peReader = new PEReader(asmStream);
   427|             asmMetadataReader = PEReaderExtensions.GetMetadataReader(peReader);
   428|             Name = asmMetadataReader.GetAssemblyDefinition().GetAssemblyName().Name + ".dll";
   429|             AssemblyNameUnqualified = Name;
   430|             if (pdb != null)
   431|             {
   432|                 pdbStream = new MemoryStream(pdb);
   433|                 try
   434|                 {
   435|                     pdbMetadataReader = MetadataReaderProvider.FromPortablePdbStream(pdbStream).GetMetadataReader();
   436|                 }
   437|                 catch (BadImageFormatException)
   438|                 {
   439|                     Console.WriteLine($"Warning: Unable to read debug information of: {Name} (use DebugType=Portable/Embedded)");
   440|                 }
   441|             }
   442|             else
   443|             {
   444|                 var entries = peReader.ReadDebugDirectory();
   445|                 var embeddedPdbEntry = entries.FirstOrDefault(e => e.Type == DebugDirectoryEntryType.EmbeddedPortablePdb);
   446|                 if (embeddedPdbEntry.DataSize != 0)
   447|                 {
   448|                     pdbMetadataReader = peReader.ReadEmbeddedPortablePdbDebugDirectoryData(embeddedPdbEntry).GetMetadataReader();
   449|                 }
   450|             }
   451|             Populate();
   452|         }
   453|         public async Task<int> GetDebugId(SessionId sessionId, MonoSDBHelper sdbAgent, CancellationToken token)
   454|         {
   455|             if (debugId > 0)
   456|                 return debugId;
   457|             debugId = await sdbAgent.GetAssemblyId(sessionId, Name, token);
   458|             return debugId;
   459|         }
   460|         public void SetDebugId(int id)
   461|         {
   462|             if (debugId <= 0 && debugId != id)
   463|                 debugId = id;
   464|         }
   465|         public bool EnC(byte[] meta, byte[] pdb)
   466|         {
   467|             var asmStream = new MemoryStream(meta);
   468|             MetadataReader asmMetadataReader = MetadataReaderProvider.FromMetadataStream(asmStream).GetMetadataReader();
   469|             var pdbStream = new MemoryStream(pdb);
   470|             MetadataReader pdbMetadataReader = MetadataReaderProvider.FromPortablePdbStream(pdbStream).GetMetadataReader();
   471|             enCMemoryStream.Add(asmStream);
   472|             enCMemoryStream.Add(pdbStream);
   473|             enCMetadataReader.Add(asmMetadataReader);
   474|             enCMetadataReader.Add(pdbMetadataReader);
   475|             PopulateEnC(asmMetadataReader, pdbMetadataReader);
   476|             return true;
   477|         }
   478|         public AssemblyInfo(ILogger logger)
   479|         {
   480|             this.logger = logger;
   481|         }
   482|         private void PopulateEnC(MetadataReader asmMetadataReaderParm, MetadataReader pdbMetadataReaderParm)
   483|         {


# ====================================================================
# FILE: src/mono/wasm/debugger/BrowserDebugProxy/MemberReferenceResolver.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 97-137 ---
    97|                             var valueRet = await sdbHelper.GetFieldValue(sessionId, typeId, field.Id, token);
    98|                             return await GetValueFromObject(valueRet, token);
    99|                         }
   100|                     }
   101|                     var methodId = await sdbHelper.GetPropertyMethodIdByName(sessionId, typeId, part.Trim(), token);
   102|                     if (methodId != -1)
   103|                     {
   104|                         var commandParamsObj = new MemoryStream();
   105|                         var commandParamsObjWriter = new MonoBinaryWriter(commandParamsObj);
   106|                         commandParamsObjWriter.Write(0); //param count
   107|                         var retMethod = await sdbHelper.InvokeMethod(sessionId, commandParamsObj.ToArray(), methodId, "methodRet", token);
   108|                         return await GetValueFromObject(retMethod, token);
   109|                     }
   110|                 }
   111|                 var store = await proxy.LoadStore(sessionId, token);
   112|                 foreach (var asm in store.assemblies)
   113|                 {
   114|                     var type = asm.GetTypeByName(classNameToFind);
   115|                     if (type != null)
   116|                     {
   117|                         typeId = await sdbHelper.GetTypeIdFromToken(sessionId, await asm.GetDebugId(sessionId, sdbHelper, token), type.Token, token);
   118|                     }
   119|                 }
   120|             }
   121|             return null;
   122|         }
   123|         public async Task<JObject> Resolve(string varName, CancellationToken token)
   124|         {
   125|             if (varName.Contains('('))
   126|                 return null;
   127|             string[] parts = varName.Split(".");
   128|             JObject rootObject = null;
   129|             if (scopeCache.MemberReferences.TryGetValue(varName, out JObject ret)) {
   130|                 return ret;
   131|             }
   132|             if (scopeCache.ObjectFields.TryGetValue(varName, out JObject valueRet)) {
   133|                 return await GetValueFromObject(valueRet, token);
   134|             }
   135|             foreach (string part in parts)
   136|             {
   137|                 string partTrimmed = part.Trim();


# ====================================================================
# FILE: src/mono/wasm/debugger/BrowserDebugProxy/MonoProxy.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1007-1081 ---
  1007|         private async Task OnSourceFileAdded(SessionId sessionId, SourceFile source, ExecutionContext context, CancellationToken token)
  1008|         {
  1009|             JObject scriptSource = JObject.FromObject(source.ToScriptSource(context.Id, context.AuxData));
  1010|             Log("debug", $"sending {source.Url} {context.Id} {sessionId.sessionId}");
  1011|             SendEvent(sessionId, "Debugger.scriptParsed", scriptSource, token);
  1012|             foreach (var req in context.BreakpointRequests.Values)
  1013|             {
  1014|                 if (req.TryResolve(source))
  1015|                 {
  1016|                     await SetBreakpoint(sessionId, context.store, req, true, token);
  1017|                 }
  1018|             }
  1019|         }
  1020|         internal async Task<DebugStore> LoadStore(SessionId sessionId, CancellationToken token)
  1021|         {
  1022|             ExecutionContext context = GetContext(sessionId);
  1023|             if (Interlocked.CompareExchange(ref context.store, new DebugStore(logger), null) != null)
  1024|                 return await context.Source.Task;
  1025|             try
  1026|             {
  1027|                 string[] loaded_files = await GetLoadedFiles(sessionId, context, token);
  1028|                 if (loaded_files == null)
  1029|                 {
  1030|                     Console.WriteLine($"Failed to get the list of loaded files. Managed code debugging won't work due to this.");
  1031|                 }
  1032|                 else
  1033|                 {
  1034|                     await foreach (SourceFile source in context.store.Load(sessionId, loaded_files, token).WithCancellation(token))
  1035|                     {
  1036|                         await OnSourceFileAdded(sessionId, source, context, token);
  1037|                     }
  1038|                 }
  1039|             }
  1040|             catch (Exception e)
  1041|             {
  1042|                 context.Source.SetException(e);
  1043|             }
  1044|             if (!context.Source.Task.IsCompleted)
  1045|                 context.Source.SetResult(context.store);
  1046|             return context.store;
  1047|             async Task<string[]> GetLoadedFiles(SessionId sessionId, ExecutionContext context, CancellationToken token)
  1048|             {
  1049|                 if (context.LoadedFiles != null)
  1050|                     return context.LoadedFiles;
  1051|                 Result loaded = await SendMonoCommand(sessionId, MonoCommands.GetLoadedFiles(), token);
  1052|                 if (!loaded.IsOk)
  1053|                 {
  1054|                     Console.WriteLine($"Error on mono_wasm_get_loaded_files {loaded}");
  1055|                     return null;
  1056|                 }
  1057|                 string[] files = loaded.Value?["result"]?["value"]?.ToObject<string[]>();
  1058|                 if (files == null)
  1059|                     Console.WriteLine($"Error extracting the list of loaded_files from the result of mono_wasm_get_loaded_files: {loaded}");
  1060|                 return files;
  1061|             }
  1062|         }
  1063|         private async Task<DebugStore> RuntimeReady(SessionId sessionId, CancellationToken token)
  1064|         {
  1065|             ExecutionContext context = GetContext(sessionId);
  1066|             if (Interlocked.CompareExchange(ref context.ready, new TaskCompletionSource<DebugStore>(), null) != null)
  1067|                 return await context.ready.Task;
  1068|             var commandParams = new MemoryStream();
  1069|             await SdbHelper.SendDebuggerAgentCommand<CmdEventRequest>(sessionId, CmdEventRequest.ClearAllBreakpoints, commandParams, token);
  1070|             if (context.PauseOnExceptions != PauseOnExceptionsKind.None && context.PauseOnExceptions != PauseOnExceptionsKind.Unset)
  1071|                 await SdbHelper.EnableExceptions(sessionId, context.PauseOnExceptions, token);
  1072|             await SdbHelper.SetProtocolVersion(sessionId, token);
  1073|             await SdbHelper.EnableReceiveRequests(sessionId, EventKind.UserBreak, token);
  1074|             await SdbHelper.EnableReceiveRequests(sessionId, EventKind.EnC, token);
  1075|             await SdbHelper.EnableReceiveRequests(sessionId, EventKind.MethodUpdate, token);
  1076|             DebugStore store = await LoadStore(sessionId, token);
  1077|             context.ready.SetResult(store);
  1078|             SendEvent(sessionId, "Mono.runtimeReady", new JObject(), token);
  1079|             SdbHelper.ResetStore(store);
  1080|             return store;
  1081|         }


# ====================================================================
# FILE: src/mono/wasm/debugger/BrowserDebugProxy/MonoSDBHelper.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 675-715 ---
   675|         }
   676|         public async Task<AssemblyInfo> GetAssemblyInfo(SessionId sessionId, int assemblyId, CancellationToken token)
   677|         {
   678|             AssemblyInfo asm = null;
   679|             if (assemblies.TryGetValue(assemblyId, out asm))
   680|             {
   681|                 return asm;
   682|             }
   683|             var assemblyName = await GetAssemblyName(sessionId, assemblyId, token);
   684|             asm = store.GetAssemblyByName(assemblyName);
   685|             if (asm == null)
   686|             {
   687|                 assemblyName = await GetAssemblyFileNameFromId(sessionId, assemblyId, token); //maybe is a lazy loaded assembly
   688|                 asm = store.GetAssemblyByName(assemblyName);
   689|                 if (asm == null)
   690|                 {
   691|                     logger.LogDebug($"Unable to find assembly: {assemblyName}");
   692|                     return null;
   693|                 }
   694|             }
   695|             asm.SetDebugId(assemblyId);
   696|             assemblies[assemblyId] = asm;
   697|             return asm;
   698|         }
   699|         public async Task<MethodInfoWithDebugInformation> GetMethodInfo(SessionId sessionId, int methodId, CancellationToken token)
   700|         {
   701|             MethodInfoWithDebugInformation methodDebugInfo = null;
   702|             if (methods.TryGetValue(methodId, out methodDebugInfo))
   703|             {
   704|                 return methodDebugInfo;
   705|             }
   706|             var methodToken = await GetMethodToken(sessionId, methodId, token);
   707|             var assemblyId = await GetAssemblyIdFromMethod(sessionId, methodId, token);
   708|             var asm = await GetAssemblyInfo(sessionId, assemblyId, token);
   709|             if (asm == null)
   710|             {
   711|                 logger.LogDebug($"Unable to find assembly: {assemblyId}");
   712|                 return null;
   713|             }
   714|             var method = asm.GetMethodByToken(methodToken);
   715|             if (method == null && !asm.HasSymbols)


# ====================================================================
# FILE: src/tasks/AotCompilerTask/MonoAOTCompiler.cs
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 31-103 ---
    31|     public bool UseLLVM { get; set; }
    32|     public bool UseAotDataFile { get; set; } = true;
    33|     public bool UseStaticLinking { get; set; }
    34|     public bool UseDirectIcalls { get; set; }
    35|     public bool UseDirectPInvoke { get; set; }
    36|     public bool UseDwarfDebug { get; set; }
    37|     public string[]? AotProfilePath { get; set; }
    38|     public string[]? Profilers { get; set; }
    39|     public string? AotModulesTablePath { get; set; }
    40|     public string? AotModulesTableLanguage { get; set; } = nameof(MonoAotModulesTableLanguage.C);
    41|     public string Mode { get; set; } = nameof(MonoAotMode.Normal);
    42|     public string OutputType { get; set; } = nameof(MonoAotOutputType.ObjectFile);
    43|     public string? LibraryFormat { get; set; }
    44|     public string LibraryFilePrefix { get; set; } = "";
    45|     public string? LLVMPath { get; set; }
    46|     public string? ToolPrefix { get; set; }
    47|     public string? MsymPath { get; set; }
    48|     public string? DedupAssembly { get; set; }
    49|     public string? LLVMDebug { get; set; } = "nodebug";
    50|     public string? CacheFilePath { get; set; }
    51|     public string? AotArguments { get; set; }
    52|     public string? TempPath { get; set; }
    53|     public string? LdName { get; set; }
    54|     public string? LdFlags { get; set; }
    55|     public string? WorkingDirectory { get; set; }
    56|     [Required]
    57|     public string IntermediateOutputPath { get; set; } = string.Empty;
    58|     [Output]
    59|     public string[]? FileWrites { get; private set; }
    60|     private static readonly Encoding s_utf8Encoding = new UTF8Encoding(false);
    61|     private List<string> _fileWrites = new();
    62|     private IList<ITaskItem>? _assembliesToCompile;
    63|     private ConcurrentDictionary<string, ITaskItem> compiledAssemblies = new();
    64|     private MonoAotMode parsedAotMode;
    65|     private MonoAotOutputType parsedOutputType;
    66|     private MonoAotLibraryFormat parsedLibraryFormat;
    67|     private MonoAotModulesTableLanguage parsedAotModulesTableLanguage;
    68|     private FileCache? _cache;
    69|     private int _numCompiled;
    70|     private int _totalNumAssemblies;
    71|     private bool ProcessAndValidateArguments()
    72|     {
    73|         if (!File.Exists(CompilerBinaryPath))
    74|         {
    75|             Log.LogError($"{nameof(CompilerBinaryPath)}='{CompilerBinaryPath}' doesn't exist.");
    76|             return false;
    77|         }
    78|         if (Assemblies.Length == 0)
    79|         {
    80|             Log.LogError($"'{nameof(Assemblies)}' is required.");
    81|             return false;
    82|         }
    83|         if (string.IsNullOrEmpty(WorkingDirectory) && !Path.IsPathRooted(OutputDir))
    84|             OutputDir = Path.GetFullPath(OutputDir);
    85|         if (!Directory.Exists(OutputDir))
    86|         {
    87|             Log.LogError($"OutputDir={OutputDir} doesn't exist");
    88|             return false;
    89|         }
    90|         if (!Directory.Exists(IntermediateOutputPath))
    91|             Directory.CreateDirectory(IntermediateOutputPath);
    92|         if (AotProfilePath != null)
    93|         {
    94|             foreach (var path in AotProfilePath)
    95|             {
    96|                 if (!File.Exists(path))
    97|                 {
    98|                     Log.LogError($"AotProfilePath '{path}' doesn't exist.");
    99|                     return false;
   100|                 }
   101|             }
   102|         }
   103|         if (UseLLVM)

# --- HUNK 2: Lines 437-547 ---
   437|             }
   438|         }
   439|         if (MsymPath != null)
   440|         {
   441|             aotArgs.Add($"msym-dir={MsymPath}");
   442|         }
   443|         if (UseAotDataFile)
   444|         {
   445|             string aotDataFile = Path.ChangeExtension(assembly, ".aotdata");
   446|             aotArgs.Add($"data-outfile={aotDataFile}");
   447|             aotAssembly.SetMetadata("AotDataFile", aotDataFile);
   448|         }
   449|         if (AotProfilePath?.Length > 0)
   450|         {
   451|             aotArgs.Add("profile-only");
   452|             foreach (var path in AotProfilePath)
   453|             {
   454|                 aotArgs.Add($"profile={path}");
   455|             }
   456|         }
   457|         if (!string.IsNullOrEmpty(AotArguments))
   458|         {
   459|             aotArgs.Add(AotArguments);
   460|         }
   461|         if (!string.IsNullOrEmpty(TempPath))
   462|         {
   463|             aotArgs.Add($"temp-path={TempPath}");
   464|         }
   465|         if (!string.IsNullOrEmpty(LdName))
   466|         {
   467|             aotArgs.Add($"ld-name={LdName}");
   468|         }
   469|         if (!string.IsNullOrEmpty(LdFlags))
   470|         {
   471|             aotArgs.Add($"ld-flags={LdFlags}");
   472|         }
   473|         processArgs.Add($"\"--aot={string.Join(",", aotArgs)}\"");
   474|         if (isDedup)
   475|         {
   476|             foreach (var aItem in _assembliesToCompile!)
   477|                 processArgs.Add(aItem.ItemSpec);
   478|         }
   479|         else
   480|         {
   481|             if (string.IsNullOrEmpty(WorkingDirectory))
   482|             {
   483|                 processArgs.Add('"' + assemblyFilename + '"');
   484|             }
   485|             else
   486|             {
   487|                 processArgs.Add('"' + assemblyItem.ItemSpec + '"');
   488|             }
   489|         }
   490|         monoPaths = $"{assemblyDir}{Path.PathSeparator}{monoPaths}";
   491|         var envVariables = new Dictionary<string, string>
   492|         {
   493|             {"MONO_PATH", monoPaths },
   494|             {"MONO_ENV_OPTIONS", string.Empty} // we do not want options to be provided out of band to the cross compilers
   495|         };
   496|         var responseFileContent = string.Join(" ", processArgs);
   497|         var responseFilePath = Path.GetTempFileName();
   498|         using (var sw = new StreamWriter(responseFilePath, append: false, encoding: s_utf8Encoding))
   499|         {
   500|             sw.WriteLine(responseFileContent);
   501|         }
   502|         return new PrecompileArguments(ResponseFilePath: responseFilePath,
   503|                                         EnvironmentVariables: envVariables,
   504|                                         WorkingDir: string.IsNullOrEmpty(WorkingDirectory) ? assemblyDir : WorkingDirectory,
   505|                                         AOTAssembly: aotAssembly,
   506|                                         ProxyFiles: proxyFiles);
   507|     }
   508|     private bool PrecompileLibrary(PrecompileArguments args)
   509|     {
   510|         string assembly = args.AOTAssembly.GetMetadata("FullPath");
   511|         try
   512|         {
   513|             string msgPrefix = $"[{Path.GetFileName(assembly)}] ";
   514|             (int exitCode, string output) = Utils.TryRunProcess(Log,
   515|                                                                 CompilerBinaryPath,
   516|                                                                 $"--response=\"{args.ResponseFilePath}\"",
   517|                                                                 args.EnvironmentVariables,
   518|                                                                 args.WorkingDir,
   519|                                                                 silent: true,
   520|                                                                 debugMessageImportance: MessageImportance.Low,
   521|                                                                 label: Path.GetFileName(assembly));
   522|             var importance = exitCode == 0 ? MessageImportance.Low : MessageImportance.High;
   523|             {
   524|                 StringBuilder envStr = new StringBuilder(string.Empty);
   525|                 foreach (KeyValuePair<string, string> kvp in args.EnvironmentVariables)
   526|                     envStr.Append($"{kvp.Key}={kvp.Value} ");
   527|                 Log.LogMessage(importance, $"{msgPrefix}Exec (with response file contents expanded) in {args.WorkingDir}: {envStr}{CompilerBinaryPath} {File.ReadAllText(args.ResponseFilePath, s_utf8Encoding)}");
   528|             }
   529|             if (exitCode != 0)
   530|             {
   531|                 Log.LogError($"Precompiling failed for {assembly}.{Environment.NewLine}{output}");
   532|                 return false;
   533|             }
   534|             Log.LogMessage(importance, output);
   535|         }
   536|         catch (Exception ex)
   537|         {
   538|             Log.LogMessage(MessageImportance.Low, ex.ToString());
   539|             Log.LogError($"Precompiling failed for {assembly}: {ex.Message}");
   540|             return false;
   541|         }
   542|         finally
   543|         {
   544|             File.Delete(args.ResponseFilePath);
   545|         }
   546|         bool copied = false;
   547|         foreach (var proxyFile in args.ProxyFiles)


# ====================================================================
# FILE: src/tasks/AppleAppBuilder/AppleAppBuilder.cs
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 35-75 ---
    35|     public string Arch { get; set; } = ""!;
    36|     [Output]
    37|     public string AppBundlePath { get; set; } = ""!;
    38|     [Output]
    39|     public string XcodeProjectPath { get; set; } = ""!;
    40|     public string? OutputDirectory { get; set; }
    41|     public bool Optimized { get; set; }
    42|     public string? DevTeamProvisioning { get; set; }
    43|     public bool BuildAppBundle { get; set; }
    44|     public bool GenerateXcodeProject { get; set; }
    45|     public bool GenerateCMakeProject { get; set; }
    46|     public ITaskItem[]? ExcludeFromAppDir { get; set; }
    47|     public string? NativeMainSource { get; set; }
    48|     public bool UseConsoleUITemplate { get; set; }
    49|     public bool ForceAOT { get; set; }
    50|     public string? RuntimeComponents { get; set; } = ""!;
    51|     public string? DiagnosticPorts { get; set; } = ""!;
    52|     public bool InvariantGlobalization { get; set; }
    53|     public bool ForceInterpreter { get; set; }
    54|     public bool EnableRuntimeLogging { get; set; }
    55|     public bool EnableAppSandbox { get; set; }
    56|     public override bool Execute()
    57|     {
    58|         bool isDevice = (TargetOS == TargetNames.iOS || TargetOS == TargetNames.tvOS);
    59|         if (!string.IsNullOrEmpty(MainLibraryFileName))
    60|         {
    61|             if (!File.Exists(Path.Combine(AppDir, MainLibraryFileName)))
    62|             {
    63|                 throw new ArgumentException($"MainLibraryFileName='{MainLibraryFileName}' was not found in AppDir='{AppDir}'");
    64|             }
    65|         }
    66|         if (ProjectName.Contains(' '))
    67|         {
    68|             throw new ArgumentException($"ProjectName='{ProjectName}' should not contain spaces");
    69|         }
    70|         string[] excludes = Array.Empty<string>();
    71|         if (ExcludeFromAppDir != null)
    72|         {
    73|             excludes = ExcludeFromAppDir
    74|                 .Where(i => !string.IsNullOrEmpty(i.ItemSpec))
    75|                 .Select(i => i.ItemSpec)

# --- HUNK 2: Lines 95-143 ---
    95|             {
    96|                 assemblerFilesToLink.Add(llvmObj);
    97|             }
    98|         }
    99|         if (((!ForceInterpreter && (isDevice || ForceAOT)) && !assemblerFiles.Any()))
   100|         {
   101|             throw new InvalidOperationException("Need list of AOT files for device builds.");
   102|         }
   103|         if (!string.IsNullOrEmpty(DiagnosticPorts))
   104|         {
   105|             bool validDiagnosticsConfig = false;
   106|             if (string.IsNullOrEmpty(RuntimeComponents))
   107|                 validDiagnosticsConfig = false;
   108|             else if (RuntimeComponents.Equals("*", StringComparison.OrdinalIgnoreCase))
   109|                 validDiagnosticsConfig = true;
   110|             else if (RuntimeComponents.Contains("diagnostics_tracing", StringComparison.OrdinalIgnoreCase))
   111|                 validDiagnosticsConfig = true;
   112|             if (!validDiagnosticsConfig)
   113|                 throw new ArgumentException("Using DiagnosticPorts require diagnostics_tracing runtime component.");
   114|         }
   115|         if (EnableAppSandbox && (string.IsNullOrEmpty(DevTeamProvisioning) || DevTeamProvisioning == "-"))
   116|         {
   117|             throw new ArgumentException("DevTeamProvisioning must be set to a valid value when App Sandbox is enabled, using '-' is not supported.");
   118|         }
   119|         var generator = new Xcode(Log, TargetOS, Arch);
   120|         if (GenerateXcodeProject)
   121|         {
   122|             XcodeProjectPath = generator.GenerateXCode(ProjectName, MainLibraryFileName, assemblerFiles, assemblerFilesToLink,
   123|                 AppDir, binDir, MonoRuntimeHeaders, !isDevice, UseConsoleUITemplate, ForceAOT, ForceInterpreter, InvariantGlobalization, Optimized, EnableRuntimeLogging, EnableAppSandbox, DiagnosticPorts, RuntimeComponents, NativeMainSource);
   124|             if (BuildAppBundle)
   125|             {
   126|                 if (isDevice && string.IsNullOrEmpty(DevTeamProvisioning))
   127|                 {
   128|                     Log.LogMessage(MessageImportance.High, "DevTeamProvisioning is not set, BuildAppBundle step is skipped.");
   129|                 }
   130|                 else
   131|                 {
   132|                     AppBundlePath = generator.BuildAppBundle(XcodeProjectPath, Optimized, DevTeamProvisioning);
   133|                 }
   134|             }
   135|         }
   136|         else if (GenerateCMakeProject)
   137|         {
   138|              generator.GenerateCMake(ProjectName, MainLibraryFileName, assemblerFiles, assemblerFilesToLink,
   139|                 AppDir, binDir, MonoRuntimeHeaders, !isDevice, UseConsoleUITemplate, ForceAOT, ForceInterpreter, InvariantGlobalization, Optimized, EnableRuntimeLogging, EnableAppSandbox, DiagnosticPorts, RuntimeComponents, NativeMainSource);
   140|         }
   141|         return true;
   142|     }
   143| }


# ====================================================================
# FILE: src/tasks/AppleAppBuilder/Xcode.cs
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 75-120 ---
    75|             "x64" => "x86_64",
    76|             "arm" => "armv7",
    77|             _ => arch
    78|         };
    79|     }
    80|     public string GenerateXCode(
    81|         string projectName,
    82|         string entryPointLib,
    83|         IEnumerable<string> asmFiles,
    84|         IEnumerable<string> asmLinkFiles,
    85|         string workspace,
    86|         string binDir,
    87|         string monoInclude,
    88|         bool preferDylibs,
    89|         bool useConsoleUiTemplate,
    90|         bool forceAOT,
    91|         bool forceInterpreter,
    92|         bool invariantGlobalization,
    93|         bool optimized,
    94|         bool enableRuntimeLogging,
    95|         bool enableAppSandbox,
    96|         string? diagnosticPorts,
    97|         string? runtimeComponents=null,
    98|         string? nativeMainSource = null)
    99|     {
   100|         var cmakeDirectoryPath = GenerateCMake(projectName, entryPointLib, asmFiles, asmLinkFiles, workspace, binDir, monoInclude, preferDylibs, useConsoleUiTemplate, forceAOT, forceInterpreter, invariantGlobalization, optimized, enableRuntimeLogging, enableAppSandbox, diagnosticPorts, runtimeComponents, nativeMainSource);
   101|         CreateXcodeProject(projectName, cmakeDirectoryPath);
   102|         return Path.Combine(binDir, projectName, projectName + ".xcodeproj");
   103|     }
   104|     public void CreateXcodeProject(string projectName, string cmakeDirectoryPath)
   105|     {
   106|         string targetName;
   107|         switch (Target)
   108|         {
   109|             case TargetNames.MacCatalyst:
   110|                 targetName = "Darwin";
   111|                 break;
   112|             case TargetNames.iOS:
   113|             case TargetNames.iOSsim:
   114|                 targetName = "iOS";
   115|                 break;
   116|             case TargetNames.tvOS:
   117|             case TargetNames.tvOSsim:
   118|                 targetName = "tvOS";
   119|                 break;
   120|             default:

# --- HUNK 2: Lines 129-211 ---
   129|             .Append(" -GXcode")
   130|             .Append(" -DCMAKE_SYSTEM_NAME=").Append(targetName)
   131|             .Append(deployTarget);
   132|         Utils.RunProcess(Logger, "cmake", cmakeArgs.ToString(), workingDir: cmakeDirectoryPath);
   133|     }
   134|     public string GenerateCMake(
   135|         string projectName,
   136|         string entryPointLib,
   137|         IEnumerable<string> asmFiles,
   138|         IEnumerable<string> asmLinkFiles,
   139|         string workspace,
   140|         string binDir,
   141|         string monoInclude,
   142|         bool preferDylibs,
   143|         bool useConsoleUiTemplate,
   144|         bool forceAOT,
   145|         bool forceInterpreter,
   146|         bool invariantGlobalization,
   147|         bool optimized,
   148|         bool enableRuntimeLogging,
   149|         bool enableAppSandbox,
   150|         string? diagnosticPorts,
   151|         string? runtimeComponents=null,
   152|         string? nativeMainSource = null)
   153|     {
   154|         var excludes = new List<string> { ".dll.o", ".dll.s", ".dwarf", ".m", ".h", ".a", ".bc", "libmonosgen-2.0.dylib", "libcoreclr.dylib" };
   155|         if (optimized)
   156|         {
   157|             excludes.Add(".pdb");
   158|         }
   159|         string[] resources = Directory.GetFileSystemEntries(workspace, "", SearchOption.TopDirectoryOnly)
   160|             .Where(f => !excludes.Any(e => f.EndsWith(e, StringComparison.InvariantCultureIgnoreCase)))
   161|             .Concat(Directory.GetFiles(binDir, "*.aotdata"))
   162|             .ToArray();
   163|         if (string.IsNullOrEmpty(nativeMainSource))
   164|         {
   165|             nativeMainSource = Path.Combine(binDir, "main.m");
   166|             File.WriteAllText(nativeMainSource, Utils.GetEmbeddedResource(useConsoleUiTemplate ? "main-console.m" : "main-simple.m"));
   167|         }
   168|         else
   169|         {
   170|             string newMainPath = Path.Combine(binDir, "main.m");
   171|             if (nativeMainSource != newMainPath)
   172|             {
   173|                 File.Copy(nativeMainSource, Path.Combine(binDir, "main.m"), true);
   174|                 nativeMainSource = newMainPath;
   175|             }
   176|         }
   177|         var entitlements = new List<KeyValuePair<string, string>>();
   178|         bool hardenedRuntime = false;
   179|         if (Target == TargetNames.MacCatalyst && !forceAOT)
   180|         {
   181|             hardenedRuntime = true;
   182|             /* for mmmap MAP_JIT */
   183|             entitlements.Add (KeyValuePair.Create ("com.apple.security.cs.allow-jit", "<true/>"));
   184|             /* for loading unsigned dylibs like libicu from outside the bundle or libSystem.Native.dylib from inside */
   185|             entitlements.Add (KeyValuePair.Create ("com.apple.security.cs.disable-library-validation", "<true/>"));
   186|         }
   187|         if (enableAppSandbox)
   188|         {
   189|             hardenedRuntime = true;
   190|             entitlements.Add (KeyValuePair.Create ("com.apple.security.app-sandbox", "<true/>"));
   191|             entitlements.Add (KeyValuePair.Create ("com.apple.security.network.client", "<true/>"));
   192|         }
   193|         string cmakeLists = Utils.GetEmbeddedResource("CMakeLists.txt.template")
   194|             .Replace("%ProjectName%", projectName)
   195|             .Replace("%AppResources%", string.Join(Environment.NewLine, resources.Where(r => !r.EndsWith("-llvm.o")).Select(r => "    " + Path.GetRelativePath(binDir, r))))
   196|             .Replace("%MainSource%", nativeMainSource)
   197|             .Replace("%MonoInclude%", monoInclude)
   198|             .Replace("%HardenedRuntime%", hardenedRuntime ? "TRUE" : "FALSE");
   199|         string toLink = "";
   200|         string[] allComponentLibs = Directory.GetFiles(workspace, "libmono-component-*-static.a");
   201|         string[] staticComponentStubLibs = Directory.GetFiles(workspace, "libmono-component-*-stub-static.a");
   202|         bool staticLinkAllComponents = false;
   203|         string[] staticLinkedComponents = Array.Empty<string>();
   204|         if (!string.IsNullOrEmpty(runtimeComponents) && runtimeComponents.Equals("*", StringComparison.OrdinalIgnoreCase))
   205|             staticLinkAllComponents = true;
   206|         else if (!string.IsNullOrEmpty(runtimeComponents))
   207|             staticLinkedComponents = runtimeComponents.Split(";");
   208|         foreach (string staticComponentStubLib in staticComponentStubLibs)
   209|         {
   210|             string componentLibToLink = staticComponentStubLib;
   211|             if (staticLinkAllComponents)


# ====================================================================
# FILE: src/tasks/WorkloadBuildTasks/InstallWorkloadFromArtifacts.cs
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 52-92 ---
    52|                                                     Log,
    53|                                                     Path.Combine(SdkDir, "dotnet"),
    54|                                                     $"workload install --skip-manifest-update --no-cache --configfile \"{nugetConfigPath}\" {WorkloadId.ItemSpec}",
    55|                                                     workingDir: Path.GetTempPath(),
    56|                                                     silent: false,
    57|                                                     debugMessageImportance: MessageImportance.High);
    58|             if (exitCode != 0)
    59|             {
    60|                 Log.LogError($"workload install failed: {output}");
    61|                 foreach (var dir in Directory.EnumerateDirectories(Path.Combine(SdkDir, "sdk-manifests"), "*", SearchOption.AllDirectories))
    62|                     Log.LogMessage(MessageImportance.Low, $"\t{Path.Combine(SdkDir, "sdk-manifests", dir)}");
    63|                 foreach (var dir in Directory.EnumerateDirectories(Path.Combine(SdkDir, "packs"), "*", SearchOption.AllDirectories))
    64|                     Log.LogMessage(MessageImportance.Low, $"\t{Path.Combine(SdkDir, "packs", dir)}");
    65|                 return false;
    66|             }
    67|             return !Log.HasLoggedErrors;
    68|         }
    69|         private string GetNuGetConfig() => File.ReadAllText(NuGetConfigFile);
    70|         private bool InstallWorkloadManifest(string name, string version, string nugetConfigContents, bool stopOnMissing)
    71|         {
    72|             Log.LogMessage(MessageImportance.High, $"Installing workload manifest for {name}/{version} for sdk band {VersionBand}");
    73|             string outputDir = FindSubDirIgnoringCase(Path.Combine(SdkDir, "sdk-manifests", VersionBand), name);
    74|             PackageReference pkgRef = new(Name: $"{name}.Manifest-{VersionBand}",
    75|                                           Version: version,
    76|                                           OutputDir: outputDir,
    77|                                           relativeSourceDir: "data");
    78|             if (!PackageInstaller.Install(new[]{ pkgRef }, nugetConfigContents, Log, stopOnMissing))
    79|                 return false;
    80|             string manifestDir = pkgRef.OutputDir;
    81|             string jsonPath = Path.Combine(manifestDir, "WorkloadManifest.json");
    82|             if (!File.Exists(jsonPath))
    83|             {
    84|                 Log.LogError($"Could not find WorkloadManifest.json at {jsonPath}");
    85|                 return false;
    86|             }
    87|             ManifestInformation? manifest;
    88|             try
    89|             {
    90|                 manifest = JsonSerializer.Deserialize<ManifestInformation>(
    91|                                                     File.ReadAllBytes(jsonPath),
    92|                                                     new JsonSerializerOptions(JsonSerializerDefaults.Web)

# --- HUNK 2: Lines 94-142 ---
    94|                                                         AllowTrailingCommas = true,
    95|                                                         ReadCommentHandling = JsonCommentHandling.Skip
    96|                                                     });
    97|                 if (manifest == null)
    98|                 {
    99|                     Log.LogError($"Could not parse manifest from {jsonPath}.");
   100|                     return false;
   101|                 }
   102|             }
   103|             catch (JsonException je)
   104|             {
   105|                 Log.LogError($"Failed to read from {jsonPath}: {je.Message}");
   106|                 return false;
   107|             }
   108|             if (manifest.DependsOn != null)
   109|             {
   110|                 foreach ((string depName, string depVersion) in manifest.DependsOn)
   111|                 {
   112|                     if (!InstallWorkloadManifest(depName, depVersion, nugetConfigContents, stopOnMissing: false))
   113|                     {
   114|                         Log.LogMessage(MessageImportance.High,
   115|                                                 $" ***** warning ******{Environment.NewLine}" +
   116|                                                 Environment.NewLine +
   117|                                                 $"Could not install a dependent manifest {depName}/{depVersion} for sdk band {VersionBand}.{Environment.NewLine}" +
   118|                                                 $"If this is because this manifest doesn't have a package for sdk band {VersionBand}, " +
   119|                                                 $"then the workload resolver will automatically fallback to the older one, and this message can be ignored.{Environment.NewLine}" +
   120|                                                 $"This can also be safely ignored if the workload {WorkloadId.ItemSpec} doesn't use the dependency.{Environment.NewLine}" +
   121|                                                 Environment.NewLine +
   122|                                                 $" ********************{Environment.NewLine}");
   123|                         continue;
   124|                     }
   125|                 }
   126|             }
   127|             return true;
   128|         }
   129|         private bool HasMetadata(ITaskItem item, string itemName, string metadataName)
   130|         {
   131|             if (!string.IsNullOrEmpty(item.GetMetadata(metadataName)))
   132|                 return true;
   133|             Log.LogError($"{itemName} item ({item.ItemSpec}) is missing Name metadata");
   134|             return false;
   135|         }
   136|         private string FindSubDirIgnoringCase(string parentDir, string dirName)
   137|         {
   138|             IEnumerable<string> matchingDirs = Directory.EnumerateDirectories(parentDir,
   139|                                                             dirName,
   140|                                                             new EnumerationOptions { MatchCasing = MatchCasing.CaseInsensitive });
   141|             string? first = matchingDirs.FirstOrDefault();
   142|             if (matchingDirs.Count() > 1)


# ====================================================================
# FILE: src/tasks/WorkloadBuildTasks/PackageInstaller.cs
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 30-93 ---
    30|         }
    31|         private bool InstallActual(PackageReference[] references, bool stopOnMissing)
    32|         {
    33|             if (Directory.Exists(_packagesDir))
    34|             {
    35|                 _logger.LogMessage(MessageImportance.Low, $"Deleting {_packagesDir}");
    36|                 Directory.Delete(_packagesDir, recursive: true);
    37|             }
    38|             var projecDir = Path.Combine(_tempDir, "restore");
    39|             var projectPath = Path.Combine(projecDir, "Restore.csproj");
    40|             Directory.CreateDirectory(projecDir);
    41|             File.WriteAllText(Path.Combine(projecDir, "Directory.Build.props"), "<Project />");
    42|             File.WriteAllText(Path.Combine(projecDir, "Directory.Build.targets"), "<Project />");
    43|             File.WriteAllText(projectPath, GenerateProject(references));
    44|             File.WriteAllText(Path.Combine(projecDir, "nuget.config"), _nugetConfigContents);
    45|             _logger.LogMessage(MessageImportance.Low, $"Restoring packages: {string.Join(", ", references.Select(r => $"{r.Name}/{r.Version}"))}");
    46|             string args = $"restore \"{projectPath}\" /p:RestorePackagesPath=\"{_packagesDir}\"";
    47|             (int exitCode, string output) = Utils.TryRunProcess(_logger, "dotnet", args, silent: false, debugMessageImportance: MessageImportance.Low);
    48|             if (exitCode != 0)
    49|             {
    50|                 LogFailure($"Restoring packages failed with exit code: {exitCode}. Output:{Environment.NewLine}{output}", stopOnMissing);
    51|                 return false;
    52|             }
    53|             IList<(PackageReference, string)> failedToRestore = references
    54|                                                              .Select(r => (r, Path.Combine(_packagesDir, r.Name.ToLower(), r.Version)))
    55|                                                              .Where(tuple => !Directory.Exists(tuple.Item2))
    56|                                                              .ToList();
    57|             if (failedToRestore.Count > 0)
    58|             {
    59|                 _logger.LogMessage(MessageImportance.Normal, output);
    60|                 foreach ((PackageReference pkgRef, string pkgDir) in failedToRestore)
    61|                     LogFailure($"Could not restore {pkgRef.Name}/{pkgRef.Version} (can't find {pkgDir})", stopOnMissing);
    62|                 return false;
    63|             }
    64|             return LayoutPackages(references, stopOnMissing);
    65|         }
    66|         private bool LayoutPackages(IEnumerable<PackageReference> references, bool stopOnMissing)
    67|         {
    68|             foreach (var pkgRef in references)
    69|             {
    70|                 var source = Path.Combine(_packagesDir, pkgRef.Name.ToLower(), pkgRef.Version, pkgRef.relativeSourceDir);
    71|                 if (!Directory.Exists(source))
    72|                 {
    73|                     LogFailure($"Failed to restore {pkgRef.Name}/{pkgRef.Version} (could not find {source})", stopOnMissing);
    74|                     if (stopOnMissing)
    75|                         return false;
    76|                 }
    77|                 else
    78|                 {
    79|                     if (!CopyDirectoryAfresh(source, pkgRef.OutputDir) && stopOnMissing)
    80|                         return false;
    81|                 }
    82|             }
    83|             return true;
    84|         }
    85|         private static string GenerateProject(IEnumerable<PackageReference> references)
    86|         {
    87|             StringBuilder projectFileBuilder = new();
    88|             projectFileBuilder.Append(@"
    89| <Project Sdk=""Microsoft.NET.Sdk"">
    90|     <PropertyGroup>
    91|         <TargetFramework>net6.0</TargetFramework>
    92|     </PropertyGroup>
    93|     <ItemGroup>");

# --- HUNK 2: Lines 104-132 ---
   104|             try
   105|             {
   106|                 if (Directory.Exists(destDir))
   107|                 {
   108|                     _logger.LogMessage(MessageImportance.Low, $"Deleting {destDir}");
   109|                     Directory.Delete(destDir, recursive: true);
   110|                 }
   111|                 _logger.LogMessage(MessageImportance.Low, $"Copying {srcDir} to {destDir}");
   112|                 Directory.CreateDirectory(destDir);
   113|                 Utils.DirectoryCopy(srcDir, destDir);
   114|                 return true;
   115|             }
   116|             catch (Exception ex)
   117|             {
   118|                 _logger.LogError($"Failed while copying {srcDir} => {destDir}: {ex.Message}");
   119|                 if (ex is IOException)
   120|                     return false;
   121|                 throw;
   122|             }
   123|         }
   124|         private void LogFailure(string msg, bool asError)
   125|         {
   126|             if (asError)
   127|                 _logger.LogError(msg);
   128|             else
   129|                 _logger.LogMessage(MessageImportance.High, $"warning: {msg}");
   130|         }
   131|     }
   132| }

