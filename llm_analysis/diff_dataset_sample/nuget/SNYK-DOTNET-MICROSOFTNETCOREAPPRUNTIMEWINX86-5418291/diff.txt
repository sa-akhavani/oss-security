--- a//dev/null
+++ b/.devcontainer/scripts/onCreateCommand.sh
@@ -0,0 +1,8 @@
+set -e
+./build.sh libs+clr -rc Release
+./build.sh libs.tests -restore
+make -C src/mono/wasm provision-wasm
+export EMSDK_PATH=$PWD/src/mono/wasm/emsdk
+./build.sh mono+libs -os Browser -c release
+./dotnet.sh tool install dotnet-serve --tool-path ./.dotnet-tools-global
+git rev-parse HEAD > ./artifacts/prebuild.sha

--- a//dev/null
+++ b/.devcontainer/scripts/postCreateCommand.sh
@@ -0,0 +1,2 @@
+set -e
+git reset --hard $(cat ./artifacts/prebuild.sha)

--- a//dev/null
+++ b/docs/design/coreclr/profiling/davbr-blog-archive/samples/sigformat.cpp
@@ -0,0 +1,320 @@
+#include "SigParse.cpp"
+ #define dimensionof(a) (sizeof(a)/sizeof(*(a)))
+ #define MAKE_CASE(__elt) case __elt: return #__elt;
+ #define MAKE_CASE_OR(__elt) case __elt: return #__elt "|";
+class SigFormat : public SigParser
+{
+private:
+	UINT nIndentLevel;
+public:
+	SigFormat() {nIndentLevel = 0; }
+	UINT GetIndentLevel() { return nIndentLevel;}
+protected:
+	LPCSTR SigIndexTypeToString(sig_index_type sit)
+	{
+		switch(sit)
+		{
+			default:
+			DebugBreak();
+			return "unknown index type";
+			MAKE_CASE(SIG_INDEX_TYPE_TYPEDEF)
+			MAKE_CASE(SIG_INDEX_TYPE_TYPEREF)
+			MAKE_CASE(SIG_INDEX_TYPE_TYPESPEC)
+		}
+	}
+	LPCSTR SigMemberTypeOptionToString(sig_elem_type set)
+	{
+		switch(set & 0xf0)
+		{
+			default:
+			DebugBreak();
+			return "unknown element type";
+			case 0:
+			return "";
+			MAKE_CASE_OR(SIG_GENERIC)
+			MAKE_CASE_OR(SIG_HASTHIS)
+			MAKE_CASE_OR(SIG_EXPLICITTHIS)
+		}
+	}
+	LPCSTR SigMemberTypeToString(sig_elem_type set)
+	{
+		switch(set & 0xf)
+		{
+			default:
+			DebugBreak();
+			return "unknown element type";
+			MAKE_CASE(SIG_METHOD_DEFAULT)
+			MAKE_CASE(SIG_METHOD_C)
+			MAKE_CASE(SIG_METHOD_STDCALL)
+			MAKE_CASE(SIG_METHOD_THISCALL)
+			MAKE_CASE(SIG_METHOD_FASTCALL)
+			MAKE_CASE(SIG_METHOD_VARARG)
+			MAKE_CASE(SIG_FIELD)
+			MAKE_CASE(SIG_LOCAL_SIG)
+			MAKE_CASE(SIG_PROPERTY)
+		}
+	}
+	LPCSTR SigElementTypeToString(sig_elem_type set)
+	{
+		switch(set)
+		{
+			default:
+			DebugBreak();
+			return "unknown element type";
+			MAKE_CASE(ELEMENT_TYPE_END)
+			MAKE_CASE(ELEMENT_TYPE_VOID)
+			MAKE_CASE(ELEMENT_TYPE_BOOLEAN)
+			MAKE_CASE(ELEMENT_TYPE_CHAR)
+			MAKE_CASE(ELEMENT_TYPE_I1)
+			MAKE_CASE(ELEMENT_TYPE_U1)
+			MAKE_CASE(ELEMENT_TYPE_I2)
+			MAKE_CASE(ELEMENT_TYPE_U2)
+			MAKE_CASE(ELEMENT_TYPE_I4)
+			MAKE_CASE(ELEMENT_TYPE_U4)
+			MAKE_CASE(ELEMENT_TYPE_I8)
+			MAKE_CASE(ELEMENT_TYPE_U8)
+			MAKE_CASE(ELEMENT_TYPE_R4)
+			MAKE_CASE(ELEMENT_TYPE_R8)
+			MAKE_CASE(ELEMENT_TYPE_STRING)
+			MAKE_CASE(ELEMENT_TYPE_PTR)
+			MAKE_CASE(ELEMENT_TYPE_BYREF)
+			MAKE_CASE(ELEMENT_TYPE_VALUETYPE)
+			MAKE_CASE(ELEMENT_TYPE_CLASS)
+			MAKE_CASE(ELEMENT_TYPE_VAR)
+			MAKE_CASE(ELEMENT_TYPE_ARRAY)
+			MAKE_CASE(ELEMENT_TYPE_GENERICINST)
+			MAKE_CASE(ELEMENT_TYPE_TYPEDBYREF)
+			MAKE_CASE(ELEMENT_TYPE_I)
+			MAKE_CASE(ELEMENT_TYPE_U)
+			MAKE_CASE(ELEMENT_TYPE_FNPTR)
+			MAKE_CASE(ELEMENT_TYPE_OBJECT)
+			MAKE_CASE(ELEMENT_TYPE_SZARRAY)
+			MAKE_CASE(ELEMENT_TYPE_MVAR)
+			MAKE_CASE(ELEMENT_TYPE_CMOD_REQD)
+			MAKE_CASE(ELEMENT_TYPE_CMOD_OPT)
+			MAKE_CASE(ELEMENT_TYPE_INTERNAL)
+			MAKE_CASE(ELEMENT_TYPE_MODIFIER)
+			MAKE_CASE(ELEMENT_TYPE_SENTINEL)
+			MAKE_CASE(ELEMENT_TYPE_PINNED)
+		}
+	}
+	void PrintIndent()
+	{
+		const char k_szSpaces[] = " ";
+		printf(k_szSpaces + ((dimensionof(k_szSpaces)-1) - nIndentLevel));
+	}
+	void IncIndent()
+	{
+		nIndentLevel += 2;
+	}
+	void DecIndent()
+	{
+		nIndentLevel -= 2;
+	}
+	void Print(const char* format, ...)
+	{
+		va_list argList;
+		va_start(argList, format);
+		PrintIndent();
+		vprintf(format, argList);
+	}
+	virtual void NotifyBeginMethod(sig_elem_type elem_type)
+	{
+		Print("BEGIN METHOD\n");
+		IncIndent();
+	}
+	virtual void NotifyEndMethod()
+	{
+		DecIndent();
+		Print("END METHOD\n");
+	}
+	virtual void NotifyParamCount(sig_count count)
+	{
+		Print("Param count = '%d'\n", count);
+	}
+	virtual void NotifyBeginRetType()
+	{
+		Print("BEGIN RET TYPE\n");
+		IncIndent();
+	}
+	virtual void NotifyEndRetType()
+	{
+		DecIndent();
+		Print("END RET TYPE\n");
+	}
+	virtual void NotifyBeginParam()
+	{
+		Print("BEGIN PARAM\n");
+		IncIndent();
+	}
+	virtual void NotifyEndParam()
+	{
+		DecIndent();
+		Print("END PARAM\n");
+	}
+	virtual void NotifySentinel()
+	{
+		Print("...\n");
+	}
+	virtual void NotifyGenericParamCount(sig_count count)
+	{
+		Print("Generic param count = '%d'\n", count);
+	}
+	virtual void NotifyBeginField(sig_elem_type elem_type)
+	{
+		Print("BEGIN FIELD: '%s%s'\n", SigMemberTypeOptionToString(elem_type), SigMemberTypeToString(elem_type));
+		IncIndent();
+	}
+	virtual void NotifyEndField()
+	{
+		DecIndent();
+		Print("END FIELD\n");
+	}
+	virtual void NotifyBeginLocals(sig_elem_type elem_type)
+	{
+		Print("BEGIN LOCALS: '%s%s'\n", SigMemberTypeOptionToString(elem_type), SigMemberTypeToString(elem_type));
+		IncIndent();
+	}
+	virtual void NotifyEndLocals()
+	{
+		DecIndent();
+		Print("END LOCALS\n");
+	}
+	virtual void NotifyLocalsCount(sig_count count)
+	{
+		Print("Locals count: '%d'\n", count);
+	}
+	virtual void NotifyBeginLocal()
+	{
+		Print("BEGIN LOCAL\n");
+		IncIndent();
+	}
+	virtual void NotifyEndLocal()
+	{
+		DecIndent();
+		Print("END LOCAL\n");
+	}
+	virtual void NotifyConstraint(sig_elem_type elem_type)
+	{
+		Print("Constraint: '%s%s'\n", SigMemberTypeOptionToString(elem_type), SigMemberTypeToString(elem_type));
+	}
+	virtual void NotifyBeginProperty(sig_elem_type elem_type)
+	{
+		Print("BEGIN PROPERTY: '%s%s'\n", SigMemberTypeOptionToString(elem_type), SigMemberTypeToString(elem_type));
+		IncIndent();
+	}
+	virtual void NotifyEndProperty()
+	{
+		DecIndent();
+		Print("END PROPERTY\n");
+	}
+	virtual void NotifyBeginArrayShape()
+	{
+		Print("BEGIN ARRAY SHAPE\n");
+		IncIndent();
+	}
+	virtual void NotifyEndArrayShape()
+	{
+		DecIndent();
+		Print("END ARRAY SHAPE\n");
+	}
+	virtual void NotifyRank(sig_count count)
+	{
+		Print("Rank: '%d'\n", count);
+	}
+	virtual void NotifyNumSizes(sig_count count)
+	{
+		Print("Num Sizes: '%d'\n", count);
+	}
+	virtual void NotifySize(sig_count count)
+	{
+		Print("Size: '%d'\n", count);
+	}
+	virtual void NotifyNumLoBounds(sig_count count)
+	{
+		Print("Num Low Bounds: '%d'\n", count);
+	}
+	virtual void NotifyLoBound(sig_count count)
+	{
+		Print("Low Bound: '%d'\n", count);
+	}
+	virtual void NotifyBeginType()
+	{
+		Print("BEGIN TYPE\n");
+		IncIndent();
+	}
+	virtual void NotifyEndType()
+	{
+		DecIndent();
+		Print("END TYPE\n");
+	}
+	virtual void NotifyTypedByref()
+	{
+		Print("Typed byref\n");
+	}
+	virtual void NotifyByref()
+	{
+		Print("Byref\n");
+	}
+	virtual void NotifyVoid()
+	{
+		Print("Void\n");
+	}
+	virtual void NotifyCustomMod(sig_elem_type cmod, sig_index_type indexType, sig_index index)
+	{
+		Print(
+			"Custom modifiers: '%s', index type: '%s', index: '0x%x'\n",
+			SigElementTypeToString(cmod),
+			SigIndexTypeToString(indexType),
+			index);
+	}
+	virtual void NotifyTypeSimple(sig_elem_type elem_type)
+	{
+		Print("Type simple: '%s'\n", SigElementTypeToString(elem_type));
+	}
+	virtual void NotifyTypeDefOrRef(sig_index_type indexType, int index)
+	{
+		Print("Type def or ref: '%s', index: '0x%x'\n", SigIndexTypeToString(indexType), index);
+	}
+	virtual void NotifyTypeGenericInst(sig_elem_type elem_type, sig_index_type indexType, sig_index index, sig_mem_number number)
+	{
+		Print(
+			"Type generic instance: '%s', index type: '%s', index: '0x%x', member number: '%d'\n",
+			SigElementTypeToString(elem_type),
+			SigIndexTypeToString(indexType),
+			index,
+			number);
+	}
+	virtual void NotifyTypeGenericTypeVariable(sig_mem_number number)
+	{
+		Print("Type generic type variable: number: '%d'\n", number);
+	}
+	virtual void NotifyTypeGenericMemberVariable(sig_mem_number number)
+	{
+		Print("Type generic member variable: number: '%d'\n", number);
+	}
+	virtual void NotifyTypeValueType()
+	{
+		Print("Type value type\n");
+	}
+	virtual void NotifyTypeClass()
+	{
+		Print("Type class\n");
+	}
+	virtual void NotifyTypePointer()
+	{
+		Print("Type pointer\n");
+	}
+	virtual void NotifyTypeFunctionPointer()
+	{
+		Print("Type function pointer\n");
+	}
+	virtual void NotifyTypeArray()
+	{
+		Print("Type array\n");
+	}
+	virtual void NotifyTypeSzArray()
+	{
+		Print("Type sz array\n");
+	}
+};

--- a//dev/null
+++ b/docs/design/coreclr/profiling/davbr-blog-archive/samples/sigparse.cpp
@@ -0,0 +1,680 @@
+ #define ELEMENT_TYPE_END 0x00 //Marks end of a list
+ #define ELEMENT_TYPE_VOID 0x01
+ #define ELEMENT_TYPE_BOOLEAN 0x02
+ #define ELEMENT_TYPE_CHAR 0x03
+ #define ELEMENT_TYPE_I1 0x04
+ #define ELEMENT_TYPE_U1 0x05
+ #define ELEMENT_TYPE_I2 0x06
+ #define ELEMENT_TYPE_U2 0x07
+ #define ELEMENT_TYPE_I4 0x08
+ #define ELEMENT_TYPE_U4 0x09
+ #define ELEMENT_TYPE_I8 0x0a
+ #define ELEMENT_TYPE_U8 0x0b
+ #define ELEMENT_TYPE_R4 0x0c
+ #define ELEMENT_TYPE_R8 0x0d
+ #define ELEMENT_TYPE_STRING 0x0e
+ #define ELEMENT_TYPE_PTR 0x0f // Followed by type
+ #define ELEMENT_TYPE_BYREF 0x10 // Followed by type
+ #define ELEMENT_TYPE_VALUETYPE 0x11 // Followed by TypeDef or TypeRef token
+ #define ELEMENT_TYPE_CLASS 0x12 // Followed by TypeDef or TypeRef token
+ #define ELEMENT_TYPE_VAR 0x13 // Generic parameter in a generic type definition, represented as number
+ #define ELEMENT_TYPE_ARRAY 0x14 // type rank boundsCount bound1 … loCount lo1 …
+ #define ELEMENT_TYPE_GENERICINST 0x15 // Generic type instantiation. Followed by type type-arg-count type-1 ... type-n
+ #define ELEMENT_TYPE_TYPEDBYREF 0x16
+ #define ELEMENT_TYPE_I 0x18 // System.IntPtr
+ #define ELEMENT_TYPE_U 0x19 // System.UIntPtr
+ #define ELEMENT_TYPE_FNPTR 0x1b // Followed by full method signature
+ #define ELEMENT_TYPE_OBJECT 0x1c // System.Object
+ #define ELEMENT_TYPE_SZARRAY 0x1d // Single-dim array with 0 lower bound
+ #define ELEMENT_TYPE_MVAR 0x1e // Generic parameter in a generic method definition,represented as number
+ #define ELEMENT_TYPE_CMOD_REQD 0x1f // Required modifier : followed by a TypeDef or TypeRef token
+ #define ELEMENT_TYPE_CMOD_OPT 0x20 // Optional modifier : followed by a TypeDef or TypeRef token
+ #define ELEMENT_TYPE_INTERNAL 0x21 // Implemented within the CLI
+ #define ELEMENT_TYPE_MODIFIER 0x40 // Or’d with following element types
+ #define ELEMENT_TYPE_SENTINEL 0x41 // Sentinel for vararg method signature
+ #define ELEMENT_TYPE_PINNED 0x45 // Denotes a local variable that points at a pinned object
+ #define SIG_METHOD_DEFAULT 0x0 // default calling convention
+ #define SIG_METHOD_C 0x1 // C calling convention
+ #define SIG_METHOD_STDCALL 0x2 // Stdcall calling convention
+ #define SIG_METHOD_THISCALL 0x3 // thiscall calling convention
+ #define SIG_METHOD_FASTCALL 0x4 // fastcall calling convention
+ #define SIG_METHOD_VARARG 0x5 // vararg calling convention
+ #define SIG_FIELD 0x6 // encodes a field
+ #define SIG_LOCAL_SIG 0x7 // used for the .locals directive
+ #define SIG_PROPERTY 0x8 // used to encode a property
+ #define SIG_GENERIC 0x10 // used to indicate that the method has one or more generic parameters.
+ #define SIG_HASTHIS 0x20 // used to encode the keyword instance in the calling convention
+ #define SIG_EXPLICITTHIS 0x40 // used to encode the keyword explicit in the calling convention
+ #define SIG_INDEX_TYPE_TYPEDEF 0 // ParseTypeDefOrRefEncoded returns this as the out index type for typedefs
+ #define SIG_INDEX_TYPE_TYPEREF 1 // ParseTypeDefOrRefEncoded returns this as the out index type for typerefs
+ #define SIG_INDEX_TYPE_TYPESPEC 2 // ParseTypeDefOrRefEncoded returns this as the out index type for typespecs
+typedef unsigned char sig_byte;
+typedef unsigned char sig_elem_type;
+typedef unsigned char sig_index_type;
+typedef unsigned int sig_index;
+typedef unsigned int sig_count;
+typedef unsigned int sig_mem_number;
+class SigParser
+{
+private:
+	sig_byte *pbBase;
+	sig_byte *pbCur;
+	sig_byte *pbEnd;
+public:
+	bool Parse(sig_byte *blob, sig_count len);
+private:
+	bool ParseByte(sig_byte *pbOut);
+	bool ParseNumber(sig_count *pOut);
+	bool ParseTypeDefOrRefEncoded(sig_index_type *pOutIndexType, sig_index *pOutIndex);
+	bool ParseMethod(sig_elem_type);
+	bool ParseField(sig_elem_type);
+	bool ParseProperty(sig_elem_type);
+	bool ParseLocals(sig_elem_type);
+	bool ParseLocal();
+	bool ParseOptionalCustomMods();
+	bool ParseOptionalCustomModsOrConstraint();
+	bool ParseCustomMod();
+	bool ParseRetType();
+	bool ParseType();
+	bool ParseParam();
+	bool ParseArrayShape();
+protected:
+	virtual void NotifyBeginMethod(sig_elem_type elem_type) {}
+	virtual void NotifyEndMethod() {}
+	virtual void NotifyParamCount(sig_count) {}
+	virtual void NotifyBeginRetType() {}
+	virtual void NotifyEndRetType() {}
+	virtual void NotifyBeginParam() {}
+	virtual void NotifyEndParam() {}
+	virtual void NotifySentinel() {}
+	virtual void NotifyGenericParamCount(sig_count) {}
+	virtual void NotifyBeginField(sig_elem_type elem_type) {}
+	virtual void NotifyEndField() {}
+	virtual void NotifyBeginLocals(sig_elem_type elem_type) {}
+	virtual void NotifyEndLocals() {}
+	virtual void NotifyLocalsCount(sig_count) {}
+	virtual void NotifyBeginLocal() {}
+	virtual void NotifyEndLocal() {}
+	virtual void NotifyConstraint(sig_elem_type elem_type) {}
+	virtual void NotifyBeginProperty(sig_elem_type elem_type) {}
+	virtual void NotifyEndProperty() {}
+	virtual void NotifyBeginArrayShape() {}
+	virtual void NotifyEndArrayShape() {}
+	virtual void NotifyRank(sig_count) {}
+	virtual void NotifyNumSizes(sig_count) {}
+	virtual void NotifySize(sig_count) {}
+	virtual void NotifyNumLoBounds(sig_count) {}
+	virtual void NotifyLoBound(sig_count) {}
+	virtual void NotifyBeginType() {};
+	virtual void NotifyEndType() {};
+	virtual void NotifyTypedByref() {}
+	virtual void NotifyByref() {}
+	virtual void NotifyVoid() {}
+	virtual void NotifyCustomMod(sig_elem_type cmod, sig_index_type indexType, sig_index index) {}
+	virtual void NotifyTypeSimple(sig_elem_type elem_type) {}
+	virtual void NotifyTypeDefOrRef(sig_index_type indexType, int index) {}
+	virtual void NotifyTypeGenericInst(sig_elem_type elem_type, sig_index_type indexType, sig_index index, sig_mem_number number) {}
+	virtual void NotifyTypeGenericTypeVariable(sig_mem_number number) {}
+	virtual void NotifyTypeGenericMemberVariable(sig_mem_number number) {}
+	virtual void NotifyTypeValueType() {}
+	virtual void NotifyTypeClass() {}
+	virtual void NotifyTypePointer() {}
+	virtual void NotifyTypeFunctionPointer() {}
+	virtual void NotifyTypeArray() {}
+	virtual void NotifyTypeSzArray() {}
+};
+bool SigParser::Parse(sig_byte *pb, sig_count cbBuffer)
+{
+	pbBase = pb;
+	pbCur = pb;
+	pbEnd = pbBase + cbBuffer;
+	sig_elem_type elem_type;
+	if (!ParseByte(&elem_type))
+		return false;
+	switch (elem_type & 0xf)
+	{
+		case SIG_METHOD_DEFAULT: // default calling convention
+		case SIG_METHOD_C: // C calling convention
+		case SIG_METHOD_STDCALL: // Stdcall calling convention
+		case SIG_METHOD_THISCALL: // thiscall calling convention
+		case SIG_METHOD_FASTCALL: // fastcall calling convention
+		case SIG_METHOD_VARARG: // vararg calling convention
+			return ParseMethod(elem_type);
+			break;
+ 		case SIG_FIELD: // encodes a field
+ 			return ParseField(elem_type);
+ 			break;
+ 		case SIG_LOCAL_SIG: // used for the .locals directive
+ 			return ParseLocals(elem_type);
+ 			break;
+		case SIG_PROPERTY: // used to encode a property
+ 			return ParseProperty(elem_type);
+ 			break;
+ 		default:
+ 			break;
+	}
+	return false;
+}
+bool SigParser::ParseByte(sig_byte *pbOut)
+{
+	if (pbCur < pbEnd)
+	{
+		*pbOut = *pbCur;
+		pbCur++;
+		return true;
+	}
+	return false;
+}
+bool SigParser::ParseMethod(sig_elem_type elem_type)
+{
+	NotifyBeginMethod(elem_type);
+	sig_count gen_param_count;
+	sig_count param_count;
+	if (elem_type & SIG_GENERIC)
+	{
+		if (!ParseNumber(&gen_param_count))
+		{
+			return false;
+		}
+		NotifyGenericParamCount(gen_param_count);
+	}
+	if (!ParseNumber(¶m_count))
+	{
+		return false;
+	}
+	NotifyParamCount(param_count);
+	if (!ParseRetType())
+	{
+		return false;
+	}
+	bool fEncounteredSentinel = false;
+	for (sig_count i = 0; i < param_count; i++)
+	{
+		if (pbCur >= pbEnd)
+		{
+			return false;
+		}
+		if (*pbCur == ELEMENT_TYPE_SENTINEL)
+		{
+			if (fEncounteredSentinel)
+			{
+				return false;
+			}
+			fEncounteredSentinel = true;
+			NotifySentinel();
+			pbCur++;
+		}
+		if (!ParseParam())
+		{
+			return false;
+		}
+	}
+	NotifyEndMethod();
+	return true;
+}
+bool SigParser::ParseField(sig_elem_type elem_type)
+{
+	NotifyBeginField(elem_type);
+	if (!ParseOptionalCustomMods())
+	{
+		return false;
+	}
+	if (!ParseType())
+	{
+		return false;
+	}
+	NotifyEndField();
+	return true;
+}
+bool SigParser::ParseProperty(sig_elem_type elem_type)
+{
+	NotifyBeginProperty(elem_type);
+	sig_count param_count;
+	if (!ParseNumber(&param_count))
+	{
+		return false;
+	}
+	NotifyParamCount(param_count);
+	if (!ParseOptionalCustomMods())
+	{
+		return false;
+	}
+	if (!ParseType())
+	{
+		return false;
+	}
+	for (sig_count i = 0; i < param_count; i++)
+	{
+		if (!ParseParam())
+		{
+			return false;
+		}
+	}
+	NotifyEndProperty();
+	return true;
+}
+bool SigParser::ParseLocals(sig_elem_type elem_type)
+{
+	NotifyBeginLocals(elem_type);
+	sig_count local_count;
+	if (!ParseNumber(&local_count))
+	{
+		return false;
+	}
+	NotifyLocalsCount(local_count);
+	for (sig_count i = 0; i < local_count; i++)
+	{
+		if (!ParseLocal())
+		{
+			return false;
+		}
+	}
+	NotifyEndLocals();
+	return true;
+}
+bool SigParser::ParseLocal()
+{
+	NotifyBeginLocal();
+	if (pbCur >= pbEnd)
+	{
+		return false;
+	}
+	if (*pbCur == ELEMENT_TYPE_TYPEDBYREF)
+	{
+		NotifyTypedByref();
+		pbCur++;
+		goto Success;
+	}
+	if (!ParseOptionalCustomModsOrConstraint())
+	{
+		return false;
+	}
+	if (pbCur >= pbEnd)
+	{
+		return false;
+	}
+	if (*pbCur == ELEMENT_TYPE_BYREF)
+	{
+		NotifyByref();
+		pbCur++;
+	}
+	if (!ParseType())
+	{
+		return false;
+	}
+	Success:
+	NotifyEndLocal();
+	return true;
+}
+bool SigParser::ParseOptionalCustomModsOrConstraint()
+{
+	for (;;)
+	{
+		if (pbCur >= pbEnd)
+		{
+			return true;
+		}
+		switch (*pbCur)
+		{
+			case ELEMENT_TYPE_CMOD_OPT:
+			case ELEMENT_TYPE_CMOD_REQD:
+				if (!ParseCustomMod())
+				{
+					return false;
+				}
+			break;
+			case ELEMENT_TYPE_PINNED:
+				NotifyConstraint(*pbCur);
+				pbCur++;
+				break;
+			default:
+				return true;
+		}
+	}
+	return false;
+}
+bool SigParser::ParseOptionalCustomMods()
+{
+	for (;;)
+	{
+		if (pbCur >= pbEnd)
+		{
+			return true;
+		}
+		switch (*pbCur)
+		{
+			case ELEMENT_TYPE_CMOD_OPT:
+			case ELEMENT_TYPE_CMOD_REQD:
+				if (!ParseCustomMod())
+				{
+					return false;
+				}
+				break;
+			default:
+				return true;
+		}
+	}
+	return false;
+}
+bool SigParser::ParseCustomMod()
+{
+	sig_elem_type cmod = 0;
+	sig_index index;
+	sig_index_type indexType;
+	if (!ParseByte(&cmod))
+	{
+		return false;
+	}
+	if (cmod == ELEMENT_TYPE_CMOD_OPT || cmod == ELEMENT_TYPE_CMOD_REQD)
+	{
+		if (!ParseTypeDefOrRefEncoded(&indexType, &index))
+		{
+			return false;
+		}
+		NotifyCustomMod(cmod, indexType, index);
+		return true;
+	}
+	return false;
+}
+bool SigParser::ParseParam()
+{
+	NotifyBeginParam();
+	if (!ParseOptionalCustomMods())
+	{
+		return false;
+	}
+	if (pbCur >= pbEnd)
+	{
+		return false;
+	}
+	if (*pbCur == ELEMENT_TYPE_TYPEDBYREF)
+	{
+		NotifyTypedByref();
+		pbCur++;
+		goto Success;
+	}
+	if (*pbCur == ELEMENT_TYPE_BYREF)
+	{
+		NotifyByref();
+		pbCur++;
+	}
+	if (!ParseType())
+	{
+		return false;
+	}
+	Success:
+	NotifyEndParam();
+	return true;
+}
+bool SigParser::ParseRetType()
+{
+	NotifyBeginRetType();
+	if (!ParseOptionalCustomMods())
+	{
+		return false;
+	}
+	if (pbCur >= pbEnd)
+	{
+		return false;
+	}
+	if (*pbCur == ELEMENT_TYPE_TYPEDBYREF)
+	{
+		NotifyTypedByref();
+		pbCur++;
+		goto Success;
+	}
+	if (*pbCur == ELEMENT_TYPE_VOID)
+	{
+		NotifyVoid();
+		pbCur++;
+		goto Success;
+	}
+	if (*pbCur == ELEMENT_TYPE_BYREF)
+	{
+		NotifyByref();
+		pbCur++;
+	}
+	if (!ParseType())
+	{
+		return false;
+	}
+	Success:
+	NotifyEndRetType();
+	return true;
+}
+bool SigParser::ParseArrayShape()
+{
+	sig_count rank;
+	sig_count numsizes;
+	sig_count size;
+	NotifyBeginArrayShape();
+	if (!ParseNumber(&rank))
+	{
+		return false;
+	}
+	NotifyRank(rank);
+	if (!ParseNumber(&numsizes))
+	{
+		return false;
+	}
+	NotifyNumSizes(numsizes);
+	for (sig_count i = 0; i < numsizes; i++)
+	{
+		if (!ParseNumber(&size))
+		{
+			return false;
+		}
+		NotifySize(size);
+	}
+	if (!ParseNumber(&numsizes))
+	{
+		return false;
+	}
+	NotifyNumLoBounds(numsizes);
+	for (sig_count i = 0; i < numsizes; i++)
+	{
+		if (!ParseNumber(&size))
+		{
+			return false;
+		}
+		NotifyLoBound(size);
+	}
+	NotifyEndArrayShape();
+	return true;
+}
+bool SigParser::ParseType()
+{
+	NotifyBeginType();
+	sig_elem_type elem_type;
+	sig_index index;
+	sig_mem_number number;
+	sig_index_type indexType;
+	if (!ParseByte(&elem_type))
+		return false;
+	switch (elem_type)
+	{
+		case ELEMENT_TYPE_BOOLEAN:
+		case ELEMENT_TYPE_CHAR:
+		case ELEMENT_TYPE_I1:
+		case ELEMENT_TYPE_U1:
+		case ELEMENT_TYPE_U2:
+		case ELEMENT_TYPE_I2:
+		case ELEMENT_TYPE_I4:
+		case ELEMENT_TYPE_U4:
+		case ELEMENT_TYPE_I8:
+		case ELEMENT_TYPE_U8:
+		case ELEMENT_TYPE_R4:
+		case ELEMENT_TYPE_R8:
+		case ELEMENT_TYPE_I:
+		case ELEMENT_TYPE_U:
+		case ELEMENT_TYPE_STRING:
+		case ELEMENT_TYPE_OBJECT:
+			NotifyTypeSimple(elem_type);
+			break;
+		case ELEMENT_TYPE_PTR:
+			NotifyTypePointer();
+			if (!ParseOptionalCustomMods())
+			{
+				return false;
+			}
+			if (pbCur >= pbEnd)
+			{
+				return false;
+			}
+			if (*pbCur == ELEMENT_TYPE_VOID)
+			{
+				pbCur++;
+				NotifyVoid();
+				break;
+			}
+			if (!ParseType())
+			{
+				return false;
+			}
+			break;
+		case ELEMENT_TYPE_CLASS:
+			NotifyTypeClass();
+			if (!ParseTypeDefOrRefEncoded(&indexType, &index))
+			{
+				return false;
+			}
+			NotifyTypeDefOrRef(indexType, index);
+			break;
+		case ELEMENT_TYPE_VALUETYPE:
+			NotifyTypeValueType();
+			if (!ParseTypeDefOrRefEncoded(&indexType, &index))
+			{
+				return false;
+			}
+			NotifyTypeDefOrRef(indexType, index);
+			break;
+		case ELEMENT_TYPE_FNPTR:
+			NotifyTypeFunctionPointer();
+			if (!ParseByte(&elem_type))
+			{
+				return false;
+			}
+			if (!ParseMethod(elem_type))
+			{
+				return false;
+			}
+			break;
+		case ELEMENT_TYPE_ARRAY:
+			NotifyTypeArray();
+			if (!ParseType())
+			{
+				return false;
+			}
+			if (!ParseArrayShape())
+			{
+				return false;
+			}
+			break;
+		case ELEMENT_TYPE_SZARRAY:
+			NotifyTypeSzArray();
+			if (!ParseOptionalCustomMods())
+			{
+				return false;
+			}
+			if (!ParseType())
+			{
+				return false;
+			}
+			break;
+		case ELEMENT_TYPE_GENERICINST:
+			if (!ParseByte(&elem_type))
+			{
+				return false;
+			}
+			if (elem_type != ELEMENT_TYPE_CLASS && elem_type != ELEMENT_TYPE_VALUETYPE)
+			{
+				return false;
+			}
+			if (!ParseTypeDefOrRefEncoded(&indexType, &index))
+			{
+				return false;
+			}
+			if (!ParseNumber(&number))
+			{
+				return false;
+			}
+			NotifyTypeGenericInst(elem_type, indexType, index, number);
+			{
+				for (sig_mem_number i=0; i < number; i++)
+				{
+					if (!ParseType())
+					{
+						return false;
+					}
+				}
+			}
+			break;
+		case ELEMENT_TYPE_VAR:
+			if (!ParseNumber(&number))
+			{
+				return false;
+			}
+			NotifyTypeGenericTypeVariable(number);
+			break;
+		case ELEMENT_TYPE_MVAR:
+			if (!ParseNumber(&number))
+			{
+				return false;
+			}
+			NotifyTypeGenericMemberVariable(number);
+			break;
+	}
+	NotifyEndType();
+	return true;
+}
+bool SigParser::ParseTypeDefOrRefEncoded(sig_index_type *pIndexTypeOut, sig_index *pIndexOut)
+{
+	sig_count encoded = 0;
+	if (!ParseNumber(&encoded))
+	{
+		return false;
+	}
+	*pIndexTypeOut = (sig_index_type) (encoded & 0x3);
+	*pIndexOut = (encoded >> 2);
+	return true;
+}
+bool SigParser::ParseNumber(sig_count *pOut)
+{
+	sig_byte b1 = 0, b2 = 0, b3 = 0, b4 = 0;
+	if (!ParseByte(&b1))
+	{
+		return false;
+	}
+	if (b1 == 0xff)
+	{
+		return false;
+	}
+	if ( (b1 & 0x80) == 0)
+	{
+		*pOut = (int)b1;
+		return true;
+	}
+	if (!ParseByte(&b2))
+	{
+		return false;
+	}
+	if ( (b1 & 0x40) == 0)
+	{
+		*pOut = (((b1 & 0x3f) << 8) | b2);
+		return true;
+	}
+	if ( (b1 & 0x20) != 0)
+	{
+		return false;
+	}
+	if (!ParseByte(&b3))
+	{
+		return false;
+	}
+	if (!ParseByte(&b4))
+	{
+		return false;
+	}
+	*pOut = ((b1 & 0x1f) << 24) | (b2 << 16) | (b3 << 8) | b4;
+	return true;
+}

--- a//dev/null
+++ b/eng/actions/backport/index.js
@@ -0,0 +1,116 @@
+function BackportException(message, postToGitHub = true) {
+  this.message = message;
+  this.postToGitHub = postToGitHub;
+}
+async function run() {
+  const util = require("util");
+  const jsExec = util.promisify(require("child_process").exec);
+  console.log("Installing npm dependencies");
+  const { stdout, stderr } = await jsExec("npm install @actions/core @actions/github @actions/exec");
+  console.log("npm-install stderr:\n\n" + stderr);
+  console.log("npm-install stdout:\n\n" + stdout);
+  console.log("Finished installing npm dependencies");
+  const core = require("@actions/core");
+  const github = require("@actions/github");
+  const exec = require("@actions/exec");
+  const repo_owner = github.context.payload.repository.owner.login;
+  const repo_name = github.context.payload.repository.name;
+  const pr_number = github.context.payload.issue.number;
+  const comment_user = github.context.payload.comment.user.login;
+  let octokit = github.getOctokit(core.getInput("auth_token", { required: true }));
+  let target_branch = core.getInput("target_branch", { required: true });
+  try {
+    try {
+      await octokit.rest.repos.checkCollaborator({
+        owner: repo_owner,
+        repo: repo_name,
+        username: comment_user
+      });
+      console.log(`Verified ${comment_user} is a repo collaborator.`);
+    } catch (error) {
+      console.log(error);
+      throw new BackportException(`Error: @${comment_user} is not a repo collaborator, backporting is not allowed. If you're a collaborator please make sure your ${repo_owner} team membership visibility is set to Public on https://github.com/orgs/${repo_owner}/people?query=${comment_user}`);
+    }
+    try { await exec.exec(`git ls-remote --exit-code --heads origin ${target_branch}`) } catch { throw new BackportException(`Error: The specified backport target branch ${target_branch} wasn't found in the repo.`); }
+    console.log(`Backport target branch: ${target_branch}`);
+    console.log("Applying backport patch");
+    await exec.exec(`git checkout ${target_branch}`);
+    await exec.exec(`git clean -xdff`);
+    await exec.exec(`git config user.name "github-actions"`);
+    await exec.exec(`git config user.email "github-actions@github.com"`);
+    const temp_branch = `backport/pr-${pr_number}-to-${target_branch}`;
+    await exec.exec(`git checkout -b ${temp_branch}`);
+    let should_open_pull_request = true;
+    try {
+      await exec.exec(`git ls-remote --exit-code --heads origin ${temp_branch}`);
+      should_open_pull_request = false;
+    } catch { }
+    await exec.exec(`curl -sSL "${github.context.payload.issue.pull_request.patch_url}" --output changes.patch`);
+    const git_am_command = "git am --3way --ignore-whitespace --keep-non-patch changes.patch";
+    let git_am_output = `$ ${git_am_command}\n\n`;
+    let git_am_failed = false;
+    try {
+      await exec.exec(git_am_command, [], {
+        listeners: {
+          stdout: function stdout(data) { git_am_output += data; },
+          stderr: function stderr(data) { git_am_output += data; }
+        }
+      });
+    } catch (error) {
+      git_am_output += error;
+      git_am_failed = true;
+    }
+    if (git_am_failed) {
+      const git_am_failed_body = `@${github.context.payload.comment.user.login} backporting to ${target_branch} failed, the patch most likely resulted in conflicts:\n\n\`\`\`shell\n${git_am_output}\n\`\`\`\n\nPlease backport manually!`;
+      await octokit.rest.issues.createComment({
+        owner: repo_owner,
+        repo: repo_name,
+        issue_number: pr_number,
+        body: git_am_failed_body
+      });
+      throw new BackportException("Error: git am failed, most likely due to a merge conflict.", false);
+    }
+    else {
+      await exec.exec(`git push --force --set-upstream origin HEAD:${temp_branch}`);
+    }
+    if (!should_open_pull_request) {
+      console.log("Backport temp branch already exists, skipping opening a PR.");
+      return;
+    }
+    let backport_pr_title = core.getInput("pr_title_template");
+    let backport_pr_description = core.getInput("pr_description_template");
+    let cc_users = `@${comment_user}`;
+    if (comment_user != github.context.payload.issue.user.login) cc_users += ` @${github.context.payload.issue.user.login}`;
+    backport_pr_title = backport_pr_title
+      .replace(/%target_branch%/g, target_branch)
+      .replace(/%source_pr_title%/g, github.context.payload.issue.title)
+      .replace(/%source_pr_number%/g, github.context.payload.issue.number)
+      .replace(/%cc_users%/g, cc_users);
+    backport_pr_description = backport_pr_description
+      .replace(/%target_branch%/g, target_branch)
+      .replace(/%source_pr_title%/g, github.context.payload.issue.title)
+      .replace(/%source_pr_number%/g, github.context.payload.issue.number)
+      .replace(/%cc_users%/g, cc_users);
+    await octokit.rest.pulls.create({
+      owner: repo_owner,
+      repo: repo_name,
+      title: backport_pr_title,
+      body: backport_pr_description,
+      head: temp_branch,
+      base: target_branch
+    });
+    console.log("Successfully opened the GitHub PR.");
+  } catch (error) {
+    core.setFailed(error);
+    if (error.postToGitHub === undefined || error.postToGitHub == true) {
+      const unknown_error_body = `@${comment_user} an error occurred while backporting to ${target_branch}, please check the run log for details!\n\n${error.message}`;
+      await octokit.rest.issues.createComment({
+        owner: repo_owner,
+        repo: repo_name,
+        issue_number: pr_number,
+        body: unknown_error_body
+      });
+    }
+  }
+}
+run();

--- a//dev/null
+++ b/eng/build.sh
@@ -0,0 +1,422 @@
+set -ue
+source="${BASH_SOURCE[0]}"
+while [[ -h "$source" ]]; do
+  scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+  source="$(readlink "$source")"
+  [[ $source != /* ]] && source="$scriptroot/$source"
+done
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+usage()
+{
+  echo "Common settings:"
+  echo "  --arch (-a)                     Target platform: x86, x64, arm, armv6, armel, arm64, loongarch64, riscv64, s390x, ppc64le or wasm."
+  echo "                                  [Default: Your machine's architecture.]"
+  echo "  --binaryLog (-bl)               Output binary log."
+  echo "  --cross                         Optional argument to signify cross compilation."
+  echo "  --configuration (-c)            Build configuration: Debug, Release or Checked."
+  echo "                                  Checked is exclusive to the CLR subset. It is the same as Debug, except code is"
+  echo "                                  compiled with optimizations enabled."
+  echo "                                  [Default: Debug]"
+  echo "  --help (-h)                     Print help and exit."
+  echo "  --librariesConfiguration (-lc)  Libraries build configuration: Debug or Release."
+  echo "                                  [Default: Debug]"
+  echo "  --os                            Target operating system: windows, Linux, FreeBSD, OSX, MacCatalyst, tvOS,"
+  echo "                                  tvOSSimulator, iOS, iOSSimulator, Android, Browser, NetBSD, illumos or Solaris."
+  echo "                                  [Default: Your machine's OS.]"
+  echo "  --projects <value>              Project or solution file(s) to build."
+  echo "  --runtimeConfiguration (-rc)    Runtime build configuration: Debug, Release or Checked."
+  echo "                                  Checked is exclusive to the CLR runtime. It is the same as Debug, except code is"
+  echo "                                  compiled with optimizations enabled."
+  echo "                                  [Default: Debug]"
+  echo "  -runtimeFlavor (-rf)            Runtime flavor: CoreCLR or Mono."
+  echo "                                  [Default: CoreCLR]"
+  echo "  --subset (-s)                   Build a subset, print available subsets with -subset help."
+  echo "                                 '--subset' can be omitted if the subset is given as the first argument."
+  echo "                                  [Default: Builds the entire repo.]"
+  echo "  --verbosity (-v)                MSBuild verbosity: q[uiet], m[inimal], n[ormal], d[etailed], and diag[nostic]."
+  echo "                                  [Default: Minimal]"
+  echo ""
+  echo "Actions (defaults to --restore --build):"
+  echo "  --build (-b)               Build all source projects."
+  echo "                             This assumes --restore has been run already."
+  echo "  --clean                    Clean the solution."
+  echo "  --pack                     Package build outputs into NuGet packages."
+  echo "  --publish                  Publish artifacts (e.g. symbols)."
+  echo "                             This assumes --build has been run already."
+  echo "  --rebuild                  Rebuild all source projects."
+  echo "  --restore (-r)             Restore dependencies."
+  echo "  --sign                     Sign build outputs."
+  echo "  --test (-t)                Incrementally builds and runs tests."
+  echo "                             Use in conjunction with --testnobuild to only run tests."
+  echo ""
+  echo "Libraries settings:"
+  echo "  --allconfigurations        Build packages for all build configurations."
+  echo "  --coverage                 Collect code coverage when testing."
+  echo "  --framework (-f)           Build framework: net7.0 or net48."
+  echo "                             [Default: net7.0]"
+  echo "  --testnobuild              Skip building tests when invoking -test."
+  echo "  --testscope                Test scope, allowed values: innerloop, outerloop, all."
+  echo ""
+  echo "Native build settings:"
+  echo "  --clang                    Optional argument to build using clang in PATH (default)."
+  echo "  --clangx                   Optional argument to build using clang version x (used for Clang 7 and newer)."
+  echo "  --clangx.y                 Optional argument to build using clang version x.y (used for Clang 6 and older)."
+  echo "  --cmakeargs                User-settable additional arguments passed to CMake."
+  echo "  --gcc                      Optional argument to build using gcc in PATH (default)."
+  echo "  --gccx.y                   Optional argument to build using gcc version x.y."
+  echo "  --portablebuild            Optional argument: set to false to force a non-portable build."
+  echo "  --keepnativesymbols        Optional argument: set to true to keep native symbols/debuginfo in generated binaries."
+  echo "  --ninja                    Optional argument: set to true to use Ninja instead of Make to run the native build."
+  echo "  --pgoinstrument            Optional argument: build PGO-instrumented runtime"
+  echo ""
+  echo "Command line arguments starting with '/p:' are passed through to MSBuild."
+  echo "Arguments can also be passed in with a single hyphen."
+  echo ""
+  echo "Here are some quick examples. These assume you are on a Linux x64 machine:"
+  echo ""
+  echo "* Build CoreCLR for Linux x64 on Release configuration:"
+  echo "./build.sh clr -c release"
+  echo ""
+  echo "* Build Debug libraries with a Release runtime for Linux x64."
+  echo "./build.sh clr+libs -rc release"
+  echo ""
+  echo "* Build Release libraries and their tests with a Checked runtime for Linux x64, and run the tests."
+  echo "./build.sh clr+libs+libs.tests -rc checked -lc release -test"
+  echo ""
+  echo "* Build CoreCLR for Linux x64 on Debug configuration using Clang 9."
+  echo "./build.sh clr -clang9"
+  echo ""
+  echo "* Build CoreCLR for Linux x64 on Debug configuration using GCC 8.4."
+  echo "./build.sh clr -gcc8.4"
+  echo ""
+  echo "* Build CoreCLR for Linux x64 using extra compiler flags (-fstack-clash-protection)."
+  echo "EXTRA_CFLAGS=-fstack-clash-protection EXTRA_CXXFLAGS=-fstack-clash-protection ./build.sh clr"
+  echo ""
+  echo "* Cross-compile CoreCLR runtime for Linux ARM64 on Release configuration."
+  echo "./build.sh clr.runtime -arch arm64 -c release -cross"
+  echo ""
+  echo "However, for this example, you need to already have ROOTFS_DIR set up."
+  echo "Further information on this can be found here:"
+  echo "https://github.com/dotnet/runtime/blob/main/docs/workflow/building/coreclr/linux-instructions.md"
+  echo ""
+  echo "* Build Mono runtime for Linux x64 on Release configuration."
+  echo "./build.sh mono -c release"
+  echo ""
+  echo "* Build Release coreclr corelib, crossgen corelib and update Debug libraries testhost to run test on an updated corelib."
+  echo "./build.sh clr.corelib+clr.nativecorelib+libs.pretest -rc release"
+  echo ""
+  echo "* Build Debug mono corelib and update Release libraries testhost to run test on an updated corelib."
+  echo "./build.sh mono.corelib+libs.pretest -rc debug -c release"
+  echo ""
+  echo ""
+  echo "For more general information, check out https://github.com/dotnet/runtime/blob/main/docs/workflow/README.md"
+}
+initDistroRid()
+{
+    source "$scriptroot"/native/init-distro-rid.sh
+    local passedRootfsDir=""
+    local targetOs="$1"
+    local buildArch="$2"
+    local isCrossBuild="$3"
+    local isPortableBuild="$4"
+    if [[ $isCrossBuild == 1 && "$targetOs" != "OSX" ]]; then
+        passedRootfsDir=${ROOTFS_DIR}
+    fi
+    initDistroRidGlobal ${targetOs} ${buildArch} ${isPortableBuild} ${passedRootfsDir}
+}
+showSubsetHelp()
+{
+  "$scriptroot/common/build.sh" "-restore" "-build" "/p:Subset=help" "/clp:nosummary"
+}
+arguments=''
+cmakeargs=''
+extraargs=''
+crossBuild=0
+portableBuild=1
+source $scriptroot/native/init-os-and-arch.sh
+hostArch=$arch
+declare -a actions=("b" "build" "r" "restore" "rebuild" "testnobuild" "sign" "publish" "clean")
+actInt=($(comm -12 <(printf '%s\n' "${actions[@]/#/-}" | sort) <(printf '%s\n' "${@/#--/-}" | sort)))
+firstArgumentChecked=0
+while [[ $# > 0 ]]; do
+  opt="$(echo "${1/#--/-}" | tr "[:upper:]" "[:lower:]")"
+  if [[ $firstArgumentChecked -eq 0 && $opt =~ ^[a-zA-Z.+]+$ ]]; then
+    if [[ "$opt" == "help" ]]; then
+      showSubsetHelp
+      exit 0
+    fi
+    arguments="$arguments /p:Subset=$1"
+    shift 1
+    continue
+  fi
+  firstArgumentChecked=1
+  case "$opt" in
+     -help|-h|-\?|/?)
+      usage
+      exit 0
+      ;;
+     -subset|-s)
+      if [ -z ${2+x} ]; then
+        showSubsetHelp
+        exit 0
+      else
+        passedSubset="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+        if [[ "$passedSubset" == "help" ]]; then
+          showSubsetHelp
+          exit 0
+        fi
+        arguments="$arguments /p:Subset=$2"
+        shift 2
+      fi
+      ;;
+     -arch|-a)
+      if [ -z ${2+x} ]; then
+        echo "No architecture supplied. See help (--help) for supported architectures." 1>&2
+        exit 1
+      fi
+      passedArch="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      case "$passedArch" in
+        x64|x86|arm|armv6|armel|arm64|loongarch64|riscv64|s390x|ppc64le|wasm)
+          arch=$passedArch
+          ;;
+        *)
+          echo "Unsupported target architecture '$2'."
+          echo "The allowed values are x86, x64, arm, armv6, armel, arm64, loongarch64, riscv64, s390x, ppc64le and wasm."
+          exit 1
+          ;;
+      esac
+      shift 2
+      ;;
+     -configuration|-c)
+      if [ -z ${2+x} ]; then
+        echo "No configuration supplied. See help (--help) for supported configurations." 1>&2
+        exit 1
+      fi
+      passedConfig="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      case "$passedConfig" in
+        debug|release|checked)
+          val="$(tr '[:lower:]' '[:upper:]' <<< ${passedConfig:0:1})${passedConfig:1}"
+          ;;
+        *)
+          echo "Unsupported target configuration '$2'."
+          echo "The allowed values are Debug, Release, and Checked."
+          exit 1
+          ;;
+      esac
+      arguments="$arguments -configuration $val"
+      shift 2
+      ;;
+     -framework|-f)
+      if [ -z ${2+x} ]; then
+        echo "No framework supplied. See help (--help) for supported frameworks." 1>&2
+        exit 1
+      fi
+      val="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      arguments="$arguments /p:BuildTargetFramework=$val"
+      shift 2
+      ;;
+     -os)
+      if [ -z ${2+x} ]; then
+        echo "No target operating system supplied. See help (--help) for supported target operating systems." 1>&2
+        exit 1
+      fi
+      passedOS="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      case "$passedOS" in
+        windows)
+          os="windows" ;;
+        linux)
+          os="Linux" ;;
+        freebsd)
+          os="FreeBSD" ;;
+        osx)
+          os="OSX" ;;
+        maccatalyst)
+          os="MacCatalyst" ;;
+        tvos)
+          os="tvOS" ;;
+        tvossimulator)
+          os="tvOSSimulator" ;;
+        ios)
+          os="iOS" ;;
+        iossimulator)
+          os="iOSSimulator" ;;
+        android)
+          os="Android" ;;
+        browser)
+          os="Browser" ;;
+        illumos)
+          os="illumos" ;;
+        solaris)
+          os="Solaris" ;;
+        *)
+          echo "Unsupported target OS '$2'."
+          echo "The allowed values are windows, Linux, FreeBSD, OSX, MacCatalyst, tvOS, tvOSSimulator, iOS, iOSSimulator, Android, Browser, illumos and Solaris."
+          exit 1
+          ;;
+      esac
+      arguments="$arguments /p:TargetOS=$os"
+      shift 2
+      ;;
+     -allconfigurations)
+      arguments="$arguments /p:BuildAllConfigurations=true"
+      shift 1
+      ;;
+     -testscope)
+      if [ -z ${2+x} ]; then
+        echo "No test scope supplied. See help (--help) for supported test scope values." 1>&2
+        exit 1
+      fi
+      arguments="$arguments /p:TestScope=$2"
+      shift 2
+      ;;
+     -testnobuild)
+      arguments="$arguments /p:TestNoBuild=true"
+      shift 1
+      ;;
+     -coverage)
+      arguments="$arguments /p:Coverage=true"
+      shift 1
+      ;;
+     -runtimeconfiguration|-rc)
+      if [ -z ${2+x} ]; then
+        echo "No runtime configuration supplied. See help (--help) for supported runtime configurations." 1>&2
+        exit 1
+      fi
+      passedRuntimeConf="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      case "$passedRuntimeConf" in
+        debug|release|checked)
+          val="$(tr '[:lower:]' '[:upper:]' <<< ${passedRuntimeConf:0:1})${passedRuntimeConf:1}"
+          ;;
+        *)
+          echo "Unsupported runtime configuration '$2'."
+          echo "The allowed values are Debug, Release, and Checked."
+          exit 1
+          ;;
+      esac
+      arguments="$arguments /p:RuntimeConfiguration=$val"
+      shift 2
+      ;;
+     -runtimeflavor|-rf)
+      if [ -z ${2+x} ]; then
+        echo "No runtime flavor supplied. See help (--help) for supported runtime flavors." 1>&2
+        exit 1
+      fi
+      passedRuntimeFlav="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      case "$passedRuntimeFlav" in
+        coreclr|mono)
+          val="$(tr '[:lower:]' '[:upper:]' <<< ${passedRuntimeFlav:0:1})${passedRuntimeFlav:1}"
+          ;;
+        *)
+          echo "Unsupported runtime flavor '$2'."
+          echo "The allowed values are CoreCLR and Mono."
+          exit 1
+          ;;
+      esac
+      arguments="$arguments /p:RuntimeFlavor=$val"
+      shift 2
+      ;;
+     -librariesconfiguration|-lc)
+      if [ -z ${2+x} ]; then
+        echo "No libraries configuration supplied. See help (--help) for supported libraries configurations." 1>&2
+        exit 1
+      fi
+      passedLibConf="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      case "$passedLibConf" in
+        debug|release)
+          val="$(tr '[:lower:]' '[:upper:]' <<< ${passedLibConf:0:1})${passedLibConf:1}"
+          ;;
+        *)
+          echo "Unsupported libraries configuration '$2'."
+          echo "The allowed values are Debug and Release."
+          exit 1
+          ;;
+      esac
+      arguments="$arguments /p:LibrariesConfiguration=$val"
+      shift 2
+      ;;
+     -cross)
+      crossBuild=1
+      arguments="$arguments /p:CrossBuild=True"
+      shift 1
+      ;;
+     -clang*)
+      compiler="${opt/#-/}" # -clang-9 => clang-9 or clang-9 => (unchanged)
+      arguments="$arguments /p:Compiler=$compiler /p:CppCompilerAndLinker=$compiler"
+      shift 1
+      ;;
+     -cmakeargs)
+      if [ -z ${2+x} ]; then
+        echo "No cmake args supplied." 1>&2
+        exit 1
+      fi
+      cmakeargs="${cmakeargs} $2"
+      shift 2
+      ;;
+     -gcc*)
+      compiler="${opt/#-/}" # -gcc-9 => gcc-9 or gcc-9 => (unchanged)
+      arguments="$arguments /p:Compiler=$compiler /p:CppCompilerAndLinker=$compiler"
+      shift 1
+      ;;
+     -portablebuild)
+      if [ -z ${2+x} ]; then
+        echo "No value for portablebuild is supplied. See help (--help) for supported values." 1>&2
+        exit 1
+      fi
+      passedPortable="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      if [ "$passedPortable" = false ]; then
+        portableBuild=0
+        arguments="$arguments /p:PortableBuild=false"
+      fi
+      shift 2
+      ;;
+     -keepnativesymbols)
+      if [ -z ${2+x} ]; then
+        echo "No value for keepNativeSymbols is supplied. See help (--help) for supported values." 1>&2
+        exit 1
+      fi
+      passedKeepNativeSymbols="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      if [ "$passedKeepNativeSymbols" = true ]; then
+        arguments="$arguments /p:KeepNativeSymbols=true"
+      fi
+      shift 2
+      ;;
+      -ninja)
+      if [ -z ${2+x} ]; then
+        arguments="$arguments /p:Ninja=true"
+        shift 1
+      else
+        ninja="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+        if [ "$ninja" = true ]; then
+          arguments="$arguments /p:Ninja=true"
+          shift 2
+        elif [ "$ninja" = false ]; then
+          arguments="$arguments /p:Ninja=false"
+          shift 2
+        else
+          arguments="$arguments /p:Ninja=true"
+          shift 1
+        fi
+      fi
+      ;;
+      -pgoinstrument)
+      arguments="$arguments /p:PgoInstrument=true"
+      shift 1
+      ;;
+      *)
+      extraargs="$extraargs $1"
+      shift 1
+      ;;
+  esac
+done
+if [ ${#actInt[@]} -eq 0 ]; then
+    arguments="-restore -build $arguments"
+fi
+if [[ "$os" == "Browser" && "$arch" != "wasm" ]]; then
+    arch=wasm
+fi
+initDistroRid $os $arch $crossBuild $portableBuild
+export DOTNETSDK_ALLOW_TARGETING_PACK_CACHING=0
+cmakeargs="${cmakeargs// /%20}"
+arguments="$arguments /p:TargetArchitecture=$arch /p:BuildArchitecture=$hostArch"
+arguments="$arguments /p:CMakeArgs=\"$cmakeargs\" $extraargs"
+"$scriptroot/common/build.sh" $arguments

--- a//dev/null
+++ b/eng/common/SetupNugetSources.sh
@@ -0,0 +1,110 @@
+ConfigFile=$1
+CredToken=$2
+NL='\n'
+TB='    '
+source="${BASH_SOURCE[0]}"
+while [[ -h "$source" ]]; do
+  scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+  source="$(readlink "$source")"
+  [[ $source != /* ]] && source="$scriptroot/$source"
+done
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+. "$scriptroot/tools.sh"
+if [ ! -f "$ConfigFile" ]; then
+    Write-PipelineTelemetryError -Category 'Build' "Error: Eng/common/SetupNugetSources.sh returned a non-zero exit code. Couldn't find the NuGet config file: $ConfigFile"
+    ExitWithExitCode 1
+fi
+if [ -z "$CredToken" ]; then
+    Write-PipelineTelemetryError -category 'Build' "Error: Eng/common/SetupNugetSources.sh returned a non-zero exit code. Please supply a valid PAT"
+    ExitWithExitCode 1
+fi
+if [[ `uname -s` == "Darwin" ]]; then
+    NL=$'\\\n'
+    TB=''
+fi
+grep -i "<packageSources>" $ConfigFile
+if [ "$?" != "0" ]; then
+    echo "Adding <packageSources>...</packageSources> section."
+    ConfigNodeHeader="<configuration>"
+    PackageSourcesTemplate="${TB}<packageSources>${NL}${TB}</packageSources>"
+    sed -i.bak "s|$ConfigNodeHeader|$ConfigNodeHeader${NL}$PackageSourcesTemplate|" $ConfigFile
+fi
+grep -i "<packageSourceCredentials>" $ConfigFile
+if [ "$?" != "0" ]; then
+    echo "Adding <packageSourceCredentials>...</packageSourceCredentials> section."
+    PackageSourcesNodeFooter="</packageSources>"
+    PackageSourceCredentialsTemplate="${TB}<packageSourceCredentials>${NL}${TB}</packageSourceCredentials>"
+    sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourcesNodeFooter${NL}$PackageSourceCredentialsTemplate|" $ConfigFile
+fi
+PackageSources=()
+grep -i "<add key=\"dotnet3.1\"" $ConfigFile
+if [ "$?" == "0" ]; then
+    grep -i "<add key=\"dotnet3.1-internal\"" $ConfigFile
+    if [ "$?" != "0" ]; then
+        echo "Adding dotnet3.1-internal to the packageSources."
+        PackageSourcesNodeFooter="</packageSources>"
+        PackageSourceTemplate="${TB}<add key=\"dotnet3.1-internal\" value=\"https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal/nuget/v2\" />"
+        sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
+    fi
+    PackageSources+=('dotnet3.1-internal')
+    grep -i "<add key=\"dotnet3.1-internal-transport\">" $ConfigFile
+    if [ "$?" != "0" ]; then
+        echo "Adding dotnet3.1-internal-transport to the packageSources."
+        PackageSourcesNodeFooter="</packageSources>"
+        PackageSourceTemplate="${TB}<add key=\"dotnet3.1-internal-transport\" value=\"https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-transport/nuget/v2\" />"
+        sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
+    fi
+    PackageSources+=('dotnet3.1-internal-transport')
+fi
+DotNetVersions=('5' '6' '7')
+for DotNetVersion in ${DotNetVersions[@]} ; do
+    FeedPrefix="dotnet${DotNetVersion}";
+    grep -i "<add key=\"$FeedPrefix\"" $ConfigFile
+    if [ "$?" == "0" ]; then
+        grep -i "<add key=\"$FeedPrefix-internal\"" $ConfigFile
+        if [ "$?" != "0" ]; then
+            echo "Adding $FeedPrefix-internal to the packageSources."
+            PackageSourcesNodeFooter="</packageSources>"
+            PackageSourceTemplate="${TB}<add key=\"$FeedPrefix-internal\" value=\"https://pkgs.dev.azure.com/dnceng/internal/_packaging/$FeedPrefix-internal/nuget/v2\" />"
+            sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
+        fi
+        PackageSources+=("$FeedPrefix-internal")
+        grep -i "<add key=\"$FeedPrefix-internal-transport\">" $ConfigFile
+        if [ "$?" != "0" ]; then
+            echo "Adding $FeedPrefix-internal-transport to the packageSources."
+            PackageSourcesNodeFooter="</packageSources>"
+            PackageSourceTemplate="${TB}<add key=\"$FeedPrefix-internal-transport\" value=\"https://pkgs.dev.azure.com/dnceng/internal/_packaging/$FeedPrefix-internal-transport/nuget/v2\" />"
+            sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
+        fi
+        PackageSources+=("$FeedPrefix-internal-transport")
+    fi
+done
+PrevIFS=$IFS
+IFS=$'\n'
+PackageSources+="$IFS"
+PackageSources+=$(grep -oh '"darc-int-[^"]*"' $ConfigFile | tr -d '"')
+IFS=$PrevIFS
+for FeedName in ${PackageSources[@]} ; do
+    grep -i "<$FeedName>" $ConfigFile 
+    if [ "$?" != "0" ]; then
+        echo "Adding credentials for $FeedName."
+        PackageSourceCredentialsNodeFooter="</packageSourceCredentials>"
+        NewCredential="${TB}${TB}<$FeedName>${NL}<add key=\"Username\" value=\"dn-bot\" />${NL}<add key=\"ClearTextPassword\" value=\"$CredToken\" />${NL}</$FeedName>"
+        sed -i.bak "s|$PackageSourceCredentialsNodeFooter|$NewCredential${NL}$PackageSourceCredentialsNodeFooter|" $ConfigFile
+    fi
+done
+grep -i "<disabledPackageSources>" $ConfigFile
+if [ "$?" == "0" ]; then
+    DisabledDarcIntSources=()
+    echo "Re-enabling any disabled \"darc-int\" package sources in $ConfigFile"
+    DisabledDarcIntSources+=$(grep -oh '"darc-int-[^"]*" value="true"' $ConfigFile  | tr -d '"')
+    for DisabledSourceName in ${DisabledDarcIntSources[@]} ; do
+        if [[ $DisabledSourceName == darc-int* ]]
+            then
+                OldDisableValue="<add key=\"$DisabledSourceName\" value=\"true\" />"
+                NewDisableValue="<!-- Reenabled for build : $DisabledSourceName -->"
+                sed -i.bak "s|$OldDisableValue|$NewDisableValue|" $ConfigFile
+                echo "Neutralized disablePackageSources entry for '$DisabledSourceName'"
+        fi
+    done
+fi

--- a//dev/null
+++ b/eng/common/build.sh
@@ -0,0 +1,215 @@
+set -u
+set -e
+usage()
+{
+  echo "Common settings:"
+  echo "  --configuration <value>    Build configuration: 'Debug' or 'Release' (short: -c)"
+  echo "  --verbosity <value>        Msbuild verbosity: q[uiet], m[inimal], n[ormal], d[etailed], and diag[nostic] (short: -v)"
+  echo "  --binaryLog                Create MSBuild binary log (short: -bl)"
+  echo "  --help                     Print help and exit (short: -h)"
+  echo ""
+  echo "Actions:"
+  echo "  --restore                  Restore dependencies (short: -r)"
+  echo "  --build                    Build solution (short: -b)"
+  echo "  --sourceBuild              Source-build the solution (short: -sb)"
+  echo "                             Will additionally trigger the following actions: --restore, --build, --pack"
+  echo "                             If --configuration is not set explicitly, will also set it to 'Release'"
+  echo "  --rebuild                  Rebuild solution"
+  echo "  --test                     Run all unit tests in the solution (short: -t)"
+  echo "  --integrationTest          Run all integration tests in the solution"
+  echo "  --performanceTest          Run all performance tests in the solution"
+  echo "  --pack                     Package build outputs into NuGet packages and Willow components"
+  echo "  --sign                     Sign build outputs"
+  echo "  --publish                  Publish artifacts (e.g. symbols)"
+  echo "  --clean                    Clean the solution"
+  echo ""
+  echo "Advanced settings:"
+  echo "  --projects <value>       Project or solution file(s) to build"
+  echo "  --ci                     Set when running on CI server"
+  echo "  --excludeCIBinarylog     Don't output binary log (short: -nobl)"
+  echo "  --prepareMachine         Prepare machine for CI run, clean up processes after build"
+  echo "  --nodeReuse <value>      Sets nodereuse msbuild parameter ('true' or 'false')"
+  echo "  --warnAsError <value>    Sets warnaserror msbuild parameter ('true' or 'false')"
+  echo ""
+  echo "Command line arguments not listed above are passed thru to msbuild."
+  echo "Arguments can also be passed in with a single hyphen."
+}
+source="${BASH_SOURCE[0]}"
+while [[ -h "$source" ]]; do
+  scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+  source="$(readlink "$source")"
+  [[ $source != /* ]] && source="$scriptroot/$source"
+done
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+restore=false
+build=false
+source_build=false
+rebuild=false
+test=false
+integration_test=false
+performance_test=false
+pack=false
+publish=false
+sign=false
+public=false
+ci=false
+clean=false
+warn_as_error=true
+node_reuse=true
+binary_log=false
+exclude_ci_binary_log=false
+pipelines_log=false
+projects=''
+configuration=''
+prepare_machine=false
+verbosity='minimal'
+runtime_source_feed=''
+runtime_source_feed_key=''
+properties=''
+while [[ $# > 0 ]]; do
+  opt="$(echo "${1/#--/-}" | tr "[:upper:]" "[:lower:]")"
+  case "$opt" in
+    -help|-h)
+      usage
+      exit 0
+      ;;
+    -clean)
+      clean=true
+      ;;
+    -configuration|-c)
+      configuration=$2
+      shift
+      ;;
+    -verbosity|-v)
+      verbosity=$2
+      shift
+      ;;
+    -binarylog|-bl)
+      binary_log=true
+      ;;
+    -excludeCIBinarylog|-nobl)
+      exclude_ci_binary_log=true
+      ;;
+    -pipelineslog|-pl)
+      pipelines_log=true
+      ;;
+    -restore|-r)
+      restore=true
+      ;;
+    -build|-b)
+      build=true
+      ;;
+    -rebuild)
+      rebuild=true
+      ;;
+    -pack)
+      pack=true
+      ;;
+    -sourcebuild|-sb)
+      build=true
+      source_build=true
+      restore=true
+      pack=true
+      ;;
+    -test|-t)
+      test=true
+      ;;
+    -integrationtest)
+      integration_test=true
+      ;;
+    -performancetest)
+      performance_test=true
+      ;;
+    -sign)
+      sign=true
+      ;;
+    -publish)
+      publish=true
+      ;;
+    -preparemachine)
+      prepare_machine=true
+      ;;
+    -projects)
+      projects=$2
+      shift
+      ;;
+    -ci)
+      ci=true
+      ;;
+    -warnaserror)
+      warn_as_error=$2
+      shift
+      ;;
+    -nodereuse)
+      node_reuse=$2
+      shift
+      ;;
+    -runtimesourcefeed)
+      runtime_source_feed=$2
+      shift
+      ;;
+     -runtimesourcefeedkey)
+      runtime_source_feed_key=$2
+      shift
+      ;;
+    *)
+      properties="$properties $1"
+      ;;
+  esac
+  shift
+done
+if [[ -z "$configuration" ]]; then
+  if [[ "$source_build" = true ]]; then configuration="Release"; else configuration="Debug"; fi
+fi
+if [[ "$ci" == true ]]; then
+  pipelines_log=true
+  node_reuse=false
+  if [[ "$exclude_ci_binary_log" == false ]]; then
+    binary_log=true
+  fi
+fi
+. "$scriptroot/tools.sh"
+function InitializeCustomToolset {
+  local script="$eng_root/restore-toolset.sh"
+  if [[ -a "$script" ]]; then
+    . "$script"
+  fi
+}
+function Build {
+  InitializeToolset
+  InitializeCustomToolset
+  if [[ ! -z "$projects" ]]; then
+    properties="$properties /p:Projects=$projects"
+  fi
+  local bl=""
+  if [[ "$binary_log" == true ]]; then
+    bl="/bl:\"$log_dir/Build.binlog\""
+  fi
+  MSBuild $_InitializeToolset \
+    $bl \
+    /p:Configuration=$configuration \
+    /p:RepoRoot="$repo_root" \
+    /p:Restore=$restore \
+    /p:Build=$build \
+    /p:ArcadeBuildFromSource=$source_build \
+    /p:Rebuild=$rebuild \
+    /p:Test=$test \
+    /p:Pack=$pack \
+    /p:IntegrationTest=$integration_test \
+    /p:PerformanceTest=$performance_test \
+    /p:Sign=$sign \
+    /p:Publish=$publish \
+    $properties
+  ExitWithExitCode 0
+}
+if [[ "$clean" == true ]]; then
+  if [ -d "$artifacts_dir" ]; then
+    rm -rf $artifacts_dir
+    echo "Artifacts directory deleted."
+  fi
+  exit 0
+fi
+if [[ "$restore" == true ]]; then
+  InitializeNativeTools
+fi
+Build

--- a//dev/null
+++ b/eng/common/cross/arm/tizen-build-rootfs.sh
@@ -0,0 +1,24 @@
+set -e
+__ARM_HARDFP_CrossDir=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
+__TIZEN_CROSSDIR="$__ARM_HARDFP_CrossDir/tizen"
+if [[ -z "$ROOTFS_DIR" ]]; then
+    echo "ROOTFS_DIR is not defined."
+    exit 1;
+fi
+TIZEN_TMP_DIR=$ROOTFS_DIR/tizen_tmp
+mkdir -p $TIZEN_TMP_DIR
+echo ">>Start downloading files"
+VERBOSE=1 $__ARM_HARDFP_CrossDir/tizen-fetch.sh $TIZEN_TMP_DIR
+echo "<<Finish downloading files"
+echo ">>Start constructing Tizen rootfs"
+TIZEN_RPM_FILES=`ls $TIZEN_TMP_DIR/*.rpm`
+cd $ROOTFS_DIR
+for f in $TIZEN_RPM_FILES; do
+    rpm2cpio $f  | cpio -idm --quiet
+done
+echo "<<Finish constructing Tizen rootfs"
+rm -rf $TIZEN_TMP_DIR
+echo ">>Start configuring Tizen rootfs"
+ln -sfn asm-arm ./usr/include/asm
+patch -p1 < $__TIZEN_CROSSDIR/tizen.patch
+echo "<<Finish configuring Tizen rootfs"

--- a//dev/null
+++ b/eng/common/cross/arm/tizen-fetch.sh
@@ -0,0 +1,134 @@
+set -e
+if [[ -z "${VERBOSE// }" ]] || [ "$VERBOSE" -ne "$VERBOSE" ] 2>/dev/null; then
+	VERBOSE=0
+fi
+Log()
+{
+	if [ $VERBOSE -ge $1 ]; then
+		echo ${@:2}
+	fi
+}
+Inform()
+{
+	Log 1 -e "\x1B[0;34m$@\x1B[m"
+}
+Debug()
+{
+	Log 2 -e "\x1B[0;32m$@\x1B[m"
+}
+Error()
+{
+	>&2 Log 0 -e "\x1B[0;31m$@\x1B[m"
+}
+Fetch()
+{
+	URL=$1
+	FILE=$2
+	PROGRESS=$3
+	if [ $VERBOSE -ge 1 ] && [ $PROGRESS ]; then
+		CURL_OPT="--progress-bar"
+	else
+		CURL_OPT="--silent"
+	fi
+	curl $CURL_OPT $URL > $FILE
+}
+hash curl 2> /dev/null || { Error "Require 'curl' Aborting."; exit 1; }
+hash xmllint 2> /dev/null || { Error "Require 'xmllint' Aborting."; exit 1; }
+hash sha256sum 2> /dev/null || { Error "Require 'sha256sum' Aborting."; exit 1; }
+TMPDIR=$1
+if [ ! -d $TMPDIR ]; then
+	TMPDIR=./tizen_tmp
+	Debug "Create temporary directory : $TMPDIR"
+	mkdir -p $TMPDIR 
+fi
+TIZEN_URL=http://download.tizen.org/snapshots/tizen
+BUILD_XML=build.xml
+REPOMD_XML=repomd.xml
+PRIMARY_XML=primary.xml
+TARGET_URL="http://__not_initialized"
+Xpath_get()
+{
+	XPATH_RESULT=''
+	XPATH=$1
+	XML_FILE=$2
+	RESULT=$(xmllint --xpath $XPATH $XML_FILE)
+	if [[ -z ${RESULT// } ]]; then
+		Error "Can not find target from $XML_FILE"
+		Debug "Xpath = $XPATH"
+		exit 1
+	fi
+	XPATH_RESULT=$RESULT
+}
+fetch_tizen_pkgs_init()
+{
+	TARGET=$1
+	PROFILE=$2
+	Debug "Initialize TARGET=$TARGET, PROFILE=$PROFILE"
+	TMP_PKG_DIR=$TMPDIR/tizen_${PROFILE}_pkgs
+	if [ -d $TMP_PKG_DIR ]; then rm -rf $TMP_PKG_DIR; fi
+	mkdir -p $TMP_PKG_DIR
+	PKG_URL=$TIZEN_URL/$PROFILE/latest
+	BUILD_XML_URL=$PKG_URL/$BUILD_XML
+	TMP_BUILD=$TMP_PKG_DIR/$BUILD_XML
+	TMP_REPOMD=$TMP_PKG_DIR/$REPOMD_XML
+	TMP_PRIMARY=$TMP_PKG_DIR/$PRIMARY_XML
+	TMP_PRIMARYGZ=${TMP_PRIMARY}.gz
+	Fetch $BUILD_XML_URL $TMP_BUILD
+	Debug "fetch $BUILD_XML_URL to $TMP_BUILD"
+	TARGET_XPATH="//build/buildtargets/buildtarget[@name=\"$TARGET\"]/repo[@type=\"binary\"]/text()"
+	Xpath_get $TARGET_XPATH $TMP_BUILD
+	TARGET_PATH=$XPATH_RESULT
+	TARGET_URL=$PKG_URL/$TARGET_PATH
+	REPOMD_URL=$TARGET_URL/repodata/repomd.xml
+	PRIMARY_XPATH='string(//*[local-name()="data"][@type="primary"]/*[local-name()="location"]/@href)'
+	Fetch $REPOMD_URL $TMP_REPOMD
+	Debug "fetch $REPOMD_URL to $TMP_REPOMD"
+	Xpath_get $PRIMARY_XPATH $TMP_REPOMD
+	PRIMARY_XML_PATH=$XPATH_RESULT
+	PRIMARY_URL=$TARGET_URL/$PRIMARY_XML_PATH
+	Fetch $PRIMARY_URL $TMP_PRIMARYGZ
+	Debug "fetch $PRIMARY_URL to $TMP_PRIMARYGZ"
+	gunzip $TMP_PRIMARYGZ 
+	Debug "unzip $TMP_PRIMARYGZ to $TMP_PRIMARY" 
+}
+fetch_tizen_pkgs()
+{
+	ARCH=$1
+	PACKAGE_XPATH_TPL='string(//*[local-name()="metadata"]/*[local-name()="package"][*[local-name()="name"][text()="_PKG_"]][*[local-name()="arch"][text()="_ARCH_"]]/*[local-name()="location"]/@href)'
+	PACKAGE_CHECKSUM_XPATH_TPL='string(//*[local-name()="metadata"]/*[local-name()="package"][*[local-name()="name"][text()="_PKG_"]][*[local-name()="arch"][text()="_ARCH_"]]/*[local-name()="checksum"]/text())'
+	for pkg in ${@:2}
+	do
+		Inform "Fetching... $pkg"
+		XPATH=${PACKAGE_XPATH_TPL/_PKG_/$pkg}
+		XPATH=${XPATH/_ARCH_/$ARCH}
+		Xpath_get $XPATH $TMP_PRIMARY
+		PKG_PATH=$XPATH_RESULT
+		XPATH=${PACKAGE_CHECKSUM_XPATH_TPL/_PKG_/$pkg}
+		XPATH=${XPATH/_ARCH_/$ARCH}
+		Xpath_get $XPATH $TMP_PRIMARY
+		CHECKSUM=$XPATH_RESULT
+		PKG_URL=$TARGET_URL/$PKG_PATH
+		PKG_FILE=$(basename $PKG_PATH)
+		PKG_PATH=$TMPDIR/$PKG_FILE
+		Debug "Download $PKG_URL to $PKG_PATH"
+		Fetch $PKG_URL $PKG_PATH true
+		echo "$CHECKSUM $PKG_PATH" | sha256sum -c - > /dev/null
+		if [ $? -ne 0 ]; then
+			Error "Fail to fetch $PKG_URL to $PKG_PATH"
+			Debug "Checksum = $CHECKSUM"
+			exit 1
+		fi
+	done
+}
+Inform "Initialize arm base"
+fetch_tizen_pkgs_init standard base
+Inform "fetch common packages"
+fetch_tizen_pkgs armv7hl gcc gcc-devel-static glibc glibc-devel libicu libicu-devel libatomic linux-glibc-devel keyutils keyutils-devel libkeyutils
+Inform "fetch coreclr packages"
+fetch_tizen_pkgs armv7hl lldb lldb-devel libgcc libstdc++ libstdc++-devel libunwind libunwind-devel lttng-ust-devel lttng-ust userspace-rcu-devel userspace-rcu
+Inform "fetch corefx packages"
+fetch_tizen_pkgs armv7hl libcom_err libcom_err-devel zlib zlib-devel libopenssl11 libopenssl1.1-devel krb5 krb5-devel
+Inform "Initialize standard unified"
+fetch_tizen_pkgs_init standard unified
+Inform "fetch corefx packages"
+fetch_tizen_pkgs armv7hl gssdp gssdp-devel tizen-release

--- a//dev/null
+++ b/eng/common/cross/build-rootfs.sh
@@ -0,0 +1,443 @@
+set -e
+usage()
+{
+    echo "Usage: $0 [BuildArch] [CodeName] [lldbx.y] [llvmx[.y]] [--skipunmount] --rootfsdir <directory>]"
+    echo "BuildArch can be: arm(default), arm64, armel, armv6, ppc64le, riscv64, s390x, x64, x86"
+    echo "CodeName - optional, Code name for Linux, can be: xenial(default), zesty, bionic, alpine, alpine3.13 or alpine3.14. If BuildArch is armel, LinuxCodeName is jessie(default) or tizen."
+    echo "                              for FreeBSD can be: freebsd12, freebsd13"
+    echo "                              for illumos can be: illumos"
+    echo "                                for Haiku can be: haiku."
+    echo "lldbx.y - optional, LLDB version, can be: lldb3.9(default), lldb4.0, lldb5.0, lldb6.0 no-lldb. Ignored for alpine and FreeBSD"
+    echo "llvmx[.y] - optional, LLVM version for LLVM related packages."
+    echo "--skipunmount - optional, will skip the unmount of rootfs folder."
+    echo "--use-mirror - optional, use mirror URL to fetch resources, when available."
+    echo "--jobs N - optional, restrict to N jobs."
+    exit 1
+}
+__CodeName=xenial
+__CrossDir=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
+__BuildArch=arm
+__AlpineArch=armv7
+__FreeBSDArch=arm
+__FreeBSDMachineArch=armv7
+__IllumosArch=arm7
+__QEMUArch=arm
+__UbuntuArch=armhf
+__UbuntuRepo="http://ports.ubuntu.com/"
+__LLDB_Package="liblldb-3.9-dev"
+__SkipUnmount=0
+__UbuntuPackages="build-essential"
+__AlpinePackages="alpine-base"
+__AlpinePackages+=" build-base"
+__AlpinePackages+=" linux-headers"
+__AlpinePackages+=" lldb-dev"
+__AlpinePackages+=" python3"
+__AlpinePackages+=" libedit"
+__UbuntuPackages+=" symlinks"
+__UbuntuPackages+=" libicu-dev"
+__UbuntuPackages+=" liblttng-ust-dev"
+__UbuntuPackages+=" libunwind8-dev"
+__AlpinePackages+=" gettext-dev"
+__AlpinePackages+=" icu-dev"
+__AlpinePackages+=" libunwind-dev"
+__AlpinePackages+=" lttng-ust-dev"
+__AlpinePackages+=" compiler-rt-static"
+__UbuntuPackages+=" libcurl4-openssl-dev"
+__UbuntuPackages+=" libkrb5-dev"
+__UbuntuPackages+=" libssl-dev"
+__UbuntuPackages+=" zlib1g-dev"
+__AlpinePackages+=" curl-dev"
+__AlpinePackages+=" krb5-dev"
+__AlpinePackages+=" openssl-dev"
+__AlpinePackages+=" zlib-dev"
+__FreeBSDBase="12.3-RELEASE"
+__FreeBSDPkg="1.17.0"
+__FreeBSDABI="12"
+__FreeBSDPackages="libunwind"
+__FreeBSDPackages+=" icu"
+__FreeBSDPackages+=" libinotify"
+__FreeBSDPackages+=" openssl"
+__FreeBSDPackages+=" krb5"
+__FreeBSDPackages+=" terminfo-db"
+__IllumosPackages="icu"
+__IllumosPackages+=" mit-krb5"
+__IllumosPackages+=" openssl"
+__IllumosPackages+=" zlib"
+__HaikuPackages="gmp"
+__HaikuPackages+=" gmp_devel"
+__HaikuPackages+=" krb5"
+__HaikuPackages+=" krb5_devel"
+__HaikuPackages+=" libiconv"
+__HaikuPackages+=" libiconv_devel"
+__HaikuPackages+=" llvm12_libunwind"
+__HaikuPackages+=" llvm12_libunwind_devel"
+__HaikuPackages+=" mpfr"
+__HaikuPackages+=" mpfr_devel"
+__UbuntuPackages+=" libomp5"
+__UbuntuPackages+=" libomp-dev"
+__Keyring=
+__UseMirror=0
+__UnprocessedBuildArgs=
+while :; do
+    if [[ "$#" -le 0 ]]; then
+        break
+    fi
+    lowerI="$(echo "$1" | tr "[:upper:]" "[:lower:]")"
+    case $lowerI in
+        -\?|-h|--help)
+            usage
+            exit 1
+            ;;
+        arm)
+            __BuildArch=arm
+            __UbuntuArch=armhf
+            __AlpineArch=armv7
+            __QEMUArch=arm
+            ;;
+        arm64)
+            __BuildArch=arm64
+            __UbuntuArch=arm64
+            __AlpineArch=aarch64
+            __QEMUArch=aarch64
+            __FreeBSDArch=arm64
+            __FreeBSDMachineArch=aarch64
+            ;;
+        armel)
+            __BuildArch=armel
+            __UbuntuArch=armel
+            __UbuntuRepo="http://ftp.debian.org/debian/"
+            __CodeName=jessie
+            ;;
+        armv6)
+            __BuildArch=armv6
+            __UbuntuArch=armhf
+            __QEMUArch=arm
+            __UbuntuRepo="http://raspbian.raspberrypi.org/raspbian/"
+            __CodeName=buster
+            __LLDB_Package="liblldb-6.0-dev"
+            if [[ -e "/usr/share/keyrings/raspbian-archive-keyring.gpg" ]]; then
+                __Keyring="--keyring /usr/share/keyrings/raspbian-archive-keyring.gpg"
+            fi
+            ;;
+        ppc64le)
+            __BuildArch=ppc64le
+            __UbuntuArch=ppc64el
+            __UbuntuRepo="http://ports.ubuntu.com/ubuntu-ports/"
+            __UbuntuPackages=$(echo ${__UbuntuPackages} | sed 's/ libunwind8-dev//')
+            __UbuntuPackages=$(echo ${__UbuntuPackages} | sed 's/ libomp-dev//')
+            __UbuntuPackages=$(echo ${__UbuntuPackages} | sed 's/ libomp5//')
+            unset __LLDB_Package
+            ;;
+        riscv64)
+            __BuildArch=riscv64
+            __UbuntuArch=riscv64
+            __UbuntuRepo="http://deb.debian.org/debian-ports"
+            __CodeName=sid
+            __UbuntuPackages=$(echo ${__UbuntuPackages} | sed 's/ libunwind8-dev//')
+            unset __LLDB_Package
+            if [[ -e "/usr/share/keyrings/debian-ports-archive-keyring.gpg" ]]; then
+                __Keyring="--keyring /usr/share/keyrings/debian-ports-archive-keyring.gpg --include=debian-ports-archive-keyring"
+            fi
+            ;;
+        s390x)
+            __BuildArch=s390x
+            __UbuntuArch=s390x
+            __UbuntuRepo="http://ports.ubuntu.com/ubuntu-ports/"
+            __UbuntuPackages=$(echo ${__UbuntuPackages} | sed 's/ libunwind8-dev//')
+            __UbuntuPackages=$(echo ${__UbuntuPackages} | sed 's/ libomp-dev//')
+            __UbuntuPackages=$(echo ${__UbuntuPackages} | sed 's/ libomp5//')
+            unset __LLDB_Package
+            ;;
+        x64)
+            __BuildArch=x64
+            __UbuntuArch=amd64
+            __FreeBSDArch=amd64
+            __FreeBSDMachineArch=amd64
+            __illumosArch=x86_64
+            __UbuntuRepo=
+            ;;
+        x86)
+            __BuildArch=x86
+            __UbuntuArch=i386
+            __UbuntuRepo="http://archive.ubuntu.com/ubuntu/"
+            ;;
+        lldb*)
+            version="${lowerI/lldb/}"
+            parts=(${version//./ })
+            if [[ "${parts[0]}" -gt 6 ]]; then
+                version="${parts[0]}"
+            fi
+            __LLDB_Package="liblldb-${version}-dev"
+            ;;
+        no-lldb)
+            unset __LLDB_Package
+            ;;
+        llvm*)
+            version="${lowerI/llvm/}"
+            parts=(${version//./ })
+            __LLVM_MajorVersion="${parts[0]}"
+            __LLVM_MinorVersion="${parts[1]}"
+            if [[ -z "$__LLVM_MinorVersion" && "$__LLVM_MajorVersion" -le 6 ]]; then
+                __LLVM_MinorVersion=0;
+            fi
+            ;;
+        xenial) # Ubuntu 16.04
+            if [[ "$__CodeName" != "jessie" ]]; then
+                __CodeName=xenial
+            fi
+            ;;
+        zesty) # Ubuntu 17.04
+            if [[ "$__CodeName" != "jessie" ]]; then
+                __CodeName=zesty
+            fi
+            ;;
+        bionic) # Ubuntu 18.04
+            if [[ "$__CodeName" != "jessie" ]]; then
+                __CodeName=bionic
+            fi
+            ;;
+        focal) # Ubuntu 20.04
+            if [[ "$__CodeName" != "jessie" ]]; then
+                __CodeName=focal
+            fi
+            ;;
+        jammy) # Ubuntu 22.04
+            if [[ "$__CodeName" != "jessie" ]]; then
+                __CodeName=jammy
+            fi
+            ;;
+        jessie) # Debian 8
+            __CodeName=jessie
+            __UbuntuRepo="http://ftp.debian.org/debian/"
+            ;;
+        stretch) # Debian 9
+            __CodeName=stretch
+            __UbuntuRepo="http://ftp.debian.org/debian/"
+            __LLDB_Package="liblldb-6.0-dev"
+            ;;
+        buster) # Debian 10
+            __CodeName=buster
+            __UbuntuRepo="http://ftp.debian.org/debian/"
+            __LLDB_Package="liblldb-6.0-dev"
+            ;;
+        tizen)
+            __CodeName=
+            __UbuntuRepo=
+            __Tizen=tizen
+            ;;
+        alpine|alpine3.13)
+            __CodeName=alpine
+            __UbuntuRepo=
+            __AlpineVersion=3.13
+            __AlpinePackages+=" llvm10-libs"
+            ;;
+        alpine3.14)
+            __CodeName=alpine
+            __UbuntuRepo=
+            __AlpineVersion=3.14
+            __AlpinePackages+=" llvm11-libs"
+            ;;
+        freebsd12)
+            __CodeName=freebsd
+            __SkipUnmount=1
+            ;;
+        freebsd13)
+            __CodeName=freebsd
+            __FreeBSDBase="13.0-RELEASE"
+            __FreeBSDABI="13"
+            __SkipUnmount=1
+            ;;
+        illumos)
+            __CodeName=illumos
+            __SkipUnmount=1
+            ;;
+        haiku)
+            __CodeName=haiku
+            __BuildArch=x64
+            __SkipUnmount=1
+            ;;
+        --skipunmount)
+            __SkipUnmount=1
+            ;;
+        --rootfsdir|-rootfsdir)
+            shift
+            __RootfsDir="$1"
+            ;;
+        --use-mirror)
+            __UseMirror=1
+            ;;
+        --use-jobs)
+            shift
+            MAXJOBS=$1
+            ;;
+        *)
+            __UnprocessedBuildArgs="$__UnprocessedBuildArgs $1"
+            ;;
+    esac
+    shift
+done
+if [[ "$__BuildArch" == "armel" ]]; then
+    __LLDB_Package="lldb-3.5-dev"
+fi
+__UbuntuPackages+=" ${__LLDB_Package:-}"
+if [[ -n "$__LLVM_MajorVersion" ]]; then
+    __UbuntuPackages+=" libclang-common-${__LLVM_MajorVersion}${__LLVM_MinorVersion:+.$__LLVM_MinorVersion}-dev"
+fi
+if [[ -z "$__RootfsDir" && -n "$ROOTFS_DIR" ]]; then
+    __RootfsDir="$ROOTFS_DIR"
+fi
+if [[ -z "$__RootfsDir" ]]; then
+    __RootfsDir="$__CrossDir/../../../.tools/rootfs/$__BuildArch"
+fi
+if [[ -d "$__RootfsDir" ]]; then
+    if [[ "$__SkipUnmount" == "0" ]]; then
+        umount "$__RootfsDir"/* || true
+    fi
+    rm -rf "$__RootfsDir"
+fi
+mkdir -p "$__RootfsDir"
+__RootfsDir="$( cd "$__RootfsDir" && pwd )"
+if [[ "$__CodeName" == "alpine" ]]; then
+    __ApkToolsVersion=2.9.1
+    __ApkToolsDir="$(mktemp -d)"
+    wget "https://github.com/alpinelinux/apk-tools/releases/download/v$__ApkToolsVersion/apk-tools-$__ApkToolsVersion-x86_64-linux.tar.gz" -P "$__ApkToolsDir"
+    tar -xf "$__ApkToolsDir/apk-tools-$__ApkToolsVersion-x86_64-linux.tar.gz" -C "$__ApkToolsDir"
+    mkdir -p "$__RootfsDir"/usr/bin
+    cp -v "/usr/bin/qemu-$__QEMUArch-static" "$__RootfsDir/usr/bin"
+    "$__ApkToolsDir/apk-tools-$__ApkToolsVersion/apk" \
+      -X "http://dl-cdn.alpinelinux.org/alpine/v$__AlpineVersion/main" \
+      -X "http://dl-cdn.alpinelinux.org/alpine/v$__AlpineVersion/community" \
+      -U --allow-untrusted --root "$__RootfsDir" --arch "$__AlpineArch" --initdb \
+      add $__AlpinePackages
+    rm -r "$__ApkToolsDir"
+elif [[ "$__CodeName" == "freebsd" ]]; then
+    mkdir -p "$__RootfsDir"/usr/local/etc
+    JOBS=${MAXJOBS:="$(getconf _NPROCESSORS_ONLN)"}
+    wget -O - "https://download.freebsd.org/ftp/releases/${__FreeBSDArch}/${__FreeBSDMachineArch}/${__FreeBSDBase}/base.txz" | tar -C "$__RootfsDir" -Jxf - ./lib ./usr/lib ./usr/libdata ./usr/include ./usr/share/keys ./etc ./bin/freebsd-version
+    echo "ABI = \"FreeBSD:${__FreeBSDABI}:${__FreeBSDMachineArch}\"; FINGERPRINTS = \"${__RootfsDir}/usr/share/keys\"; REPOS_DIR = [\"${__RootfsDir}/etc/pkg\"]; REPO_AUTOUPDATE = NO; RUN_SCRIPTS = NO;" > "${__RootfsDir}"/usr/local/etc/pkg.conf
+    echo "FreeBSD: { url: \"pkg+http://pkg.FreeBSD.org/\${ABI}/quarterly\", mirror_type: \"srv\", signature_type: \"fingerprints\", fingerprints: \"${__RootfsDir}/usr/share/keys/pkg\", enabled: yes }" > "${__RootfsDir}"/etc/pkg/FreeBSD.conf
+    mkdir -p "$__RootfsDir"/tmp
+    wget -O - "https://github.com/freebsd/pkg/archive/${__FreeBSDPkg}.tar.gz" | tar -C "$__RootfsDir"/tmp -zxf -
+    cd "$__RootfsDir/tmp/pkg-${__FreeBSDPkg}"
+    mkdir -p "$__RootfsDir"/host/etc
+    ./autogen.sh && ./configure --prefix="$__RootfsDir"/host && make -j "$JOBS" && make install
+    rm -rf "$__RootfsDir/tmp/pkg-${__FreeBSDPkg}"
+    INSTALL_AS_USER=$(whoami) "$__RootfsDir"/host/sbin/pkg -r "$__RootfsDir" -C "$__RootfsDir"/usr/local/etc/pkg.conf update
+    INSTALL_AS_USER=$(whoami) "$__RootfsDir"/host/sbin/pkg -r "$__RootfsDir" -C "$__RootfsDir"/usr/local/etc/pkg.conf install --yes $__FreeBSDPackages
+elif [[ "$__CodeName" == "illumos" ]]; then
+    mkdir "$__RootfsDir/tmp"
+    pushd "$__RootfsDir/tmp"
+    JOBS=${MAXJOBS:="$(getconf _NPROCESSORS_ONLN)"}
+    echo "Downloading sysroot."
+    wget -O - https://github.com/illumos/sysroot/releases/download/20181213-de6af22ae73b-v1/illumos-sysroot-i386-20181213-de6af22ae73b-v1.tar.gz | tar -C "$__RootfsDir" -xzf -
+    echo "Building binutils. Please wait.."
+    wget -O - https://ftp.gnu.org/gnu/binutils/binutils-2.33.1.tar.bz2 | tar -xjf -
+    mkdir build-binutils && cd build-binutils
+    ../binutils-2.33.1/configure --prefix="$__RootfsDir" --target="${__illumosArch}-sun-solaris2.10" --program-prefix="${__illumosArch}-illumos-" --with-sysroot="$__RootfsDir"
+    make -j "$JOBS" && make install && cd ..
+    echo "Building gcc. Please wait.."
+    wget -O - https://ftp.gnu.org/gnu/gcc/gcc-8.4.0/gcc-8.4.0.tar.xz | tar -xJf -
+    CFLAGS="-fPIC"
+    CXXFLAGS="-fPIC"
+    CXXFLAGS_FOR_TARGET="-fPIC"
+    CFLAGS_FOR_TARGET="-fPIC"
+    export CFLAGS CXXFLAGS CXXFLAGS_FOR_TARGET CFLAGS_FOR_TARGET
+    mkdir build-gcc && cd build-gcc
+    ../gcc-8.4.0/configure --prefix="$__RootfsDir" --target="${__illumosArch}-sun-solaris2.10" --program-prefix="${__illumosArch}-illumos-" --with-sysroot="$__RootfsDir" --with-gnu-as       \
+        --with-gnu-ld --disable-nls --disable-libgomp --disable-libquadmath --disable-libssp --disable-libvtv --disable-libcilkrts --disable-libada --disable-libsanitizer \
+        --disable-libquadmath-support --disable-shared --enable-tls
+    make -j "$JOBS" && make install && cd ..
+    BaseUrl=https://pkgsrc.joyent.com
+    if [[ "$__UseMirror" == 1 ]]; then
+        BaseUrl=http://pkgsrc.smartos.skylime.net
+    fi
+    BaseUrl="$BaseUrl/packages/SmartOS/trunk/${__illumosArch}/All"
+    echo "Downloading manifest"
+    wget "$BaseUrl"
+    echo "Downloading dependencies."
+    read -ra array <<<"$__IllumosPackages"
+    for package in "${array[@]}"; do
+        echo "Installing '$package'"
+        package="$(grep ">$package-[0-9]" All | sed -En 's/.*href="(.*)\.tgz".*/\1/p')"
+        echo "Resolved name '$package'"
+        wget "$BaseUrl"/"$package".tgz
+        ar -x "$package".tgz
+        tar --skip-old-files -xzf "$package".tmp.tg* -C "$__RootfsDir" 2>/dev/null
+    done
+    echo "Cleaning up temporary files."
+    popd
+    rm -rf "$__RootfsDir"/{tmp,+*}
+    mkdir -p "$__RootfsDir"/usr/include/net
+    mkdir -p "$__RootfsDir"/usr/include/netpacket
+    wget -P "$__RootfsDir"/usr/include/net https://raw.githubusercontent.com/illumos/illumos-gate/master/usr/src/uts/common/io/bpf/net/bpf.h
+    wget -P "$__RootfsDir"/usr/include/net https://raw.githubusercontent.com/illumos/illumos-gate/master/usr/src/uts/common/io/bpf/net/dlt.h
+    wget -P "$__RootfsDir"/usr/include/netpacket https://raw.githubusercontent.com/illumos/illumos-gate/master/usr/src/uts/common/inet/sockmods/netpacket/packet.h
+    wget -P "$__RootfsDir"/usr/include/sys https://raw.githubusercontent.com/illumos/illumos-gate/master/usr/src/uts/common/sys/sdt.h
+elif [[ "$__CodeName" == "haiku" ]]; then
+    JOBS=${MAXJOBS:="$(getconf _NPROCESSORS_ONLN)"}
+    echo "Building Haiku sysroot for x86_64"
+    mkdir -p "$__RootfsDir/tmp"
+    cd "$__RootfsDir/tmp"
+    git clone -b hrev56235  https://review.haiku-os.org/haiku
+    git clone -b btrev43195 https://review.haiku-os.org/buildtools
+    cd "$__RootfsDir/tmp/buildtools" && git checkout 7487388f5110021d400b9f3b88e1a7f310dc066d
+    cd "$__RootfsDir/tmp/haiku"
+    git fetch origin refs/changes/64/4164/1 && git -c commit.gpgsign=false cherry-pick FETCH_HEAD
+    cd "$__RootfsDir/tmp/buildtools/jam"
+    make
+    echo "Building cross-compiler"
+    mkdir -p "$__RootfsDir/generated"
+    cd "$__RootfsDir/generated"
+    "$__RootfsDir/tmp/haiku/configure" -j"$JOBS" --sysroot "$__RootfsDir" --cross-tools-source "$__RootfsDir/tmp/buildtools" --build-cross-tools x86_64
+    echo "Building Haiku"
+    echo 'HAIKU_BUILD_PROFILE = "development-raw" ;' > UserProfileConfig
+    "$__RootfsDir/tmp/buildtools/jam/jam0" -j"$JOBS" -q '<build>package' '<repository>Haiku'
+    BaseUrl="https://depot.haiku-os.org/__api/v2/pkg/get-pkg"
+    echo "Downloading additional required packages"
+    read -ra array <<<"$__HaikuPackages"
+    for package in "${array[@]}"; do
+        echo "Downloading $package..."
+        hpkgDownloadUrl="$(wget -qO- --post-data='{"name":"'"$package"'","repositorySourceCode":"haikuports_x86_64","versionType":"LATEST","naturalLanguageCode":"en"}' \
+            --header='Content-Type:application/json' "$BaseUrl" | jq -r '.result.versions[].hpkgDownloadURL')"
+        wget -P "$__RootfsDir/generated/download" "$hpkgDownloadUrl"
+    done
+    echo "Setting up sysroot and extracting needed packages"
+    mkdir -p "$__RootfsDir/boot/system"
+    for file in "$__RootfsDir/generated/objects/haiku/x86_64/packaging/packages/"*.hpkg; do
+        "$__RootfsDir/generated/objects/linux/x86_64/release/tools/package/package" extract -C "$__RootfsDir/boot/system" "$file"
+    done
+    for file in "$__RootfsDir/generated/download/"*.hpkg; do
+        "$__RootfsDir/generated/objects/linux/x86_64/release/tools/package/package" extract -C "$__RootfsDir/boot/system" "$file"
+    done
+    echo "Cleaning up temporary files"
+    rm -rf "$__RootfsDir/tmp"
+    for name in "$__RootfsDir/generated/"*; do
+        if [[ "$name" =~ "cross-tools-" ]]; then
+            : # Keep the cross-compiler
+        else
+            rm -rf "$name"
+        fi
+    done
+elif [[ -n "$__CodeName" ]]; then
+    qemu-debootstrap $__Keyring --arch "$__UbuntuArch" "$__CodeName" "$__RootfsDir" "$__UbuntuRepo"
+    cp "$__CrossDir/$__BuildArch/sources.list.$__CodeName" "$__RootfsDir/etc/apt/sources.list"
+    chroot "$__RootfsDir" apt-get update
+    chroot "$__RootfsDir" apt-get -f -y install
+    chroot "$__RootfsDir" apt-get -y install $__UbuntuPackages
+    chroot "$__RootfsDir" symlinks -cr /usr
+    chroot "$__RootfsDir" apt-get clean
+    if [[ "$__SkipUnmount" == "0" ]]; then
+        umount "$__RootfsDir"/* || true
+    fi
+    if [[ "$__BuildArch" == "armel" && "$__CodeName" == "jessie" ]]; then
+        pushd "$__RootfsDir"
+        patch -p1 < "$__CrossDir/$__BuildArch/armel.jessie.patch"
+        popd
+    fi
+elif [[ "$__Tizen" == "tizen" ]]; then
+    ROOTFS_DIR="$__RootfsDir" "$__CrossDir/$__BuildArch/tizen-build-rootfs.sh"
+else
+    echo "Unsupported target platform."
+    usage;
+    exit 1
+fi

--- a//dev/null
+++ b/eng/common/cross/x86/tizen-build-rootfs.sh
@@ -0,0 +1,24 @@
+set -e
+__X86_CrossDir=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
+__TIZEN_CROSSDIR="$__X86_CrossDir/tizen"
+if [[ -z "$ROOTFS_DIR" ]]; then
+    echo "ROOTFS_DIR is not defined."
+    exit 1;
+fi
+TIZEN_TMP_DIR=$ROOTFS_DIR/tizen_tmp
+mkdir -p $TIZEN_TMP_DIR
+echo ">>Start downloading files"
+VERBOSE=1 $__X86_CrossDir/tizen-fetch.sh $TIZEN_TMP_DIR
+echo "<<Finish downloading files"
+echo ">>Start constructing Tizen rootfs"
+TIZEN_RPM_FILES=`ls $TIZEN_TMP_DIR/*.rpm`
+cd $ROOTFS_DIR
+for f in $TIZEN_RPM_FILES; do
+    rpm2cpio $f  | cpio -idm --quiet
+done
+echo "<<Finish constructing Tizen rootfs"
+rm -rf $TIZEN_TMP_DIR
+echo ">>Start configuring Tizen rootfs"
+ln -sfn asm-x86 ./usr/include/asm
+patch -p1 < $__TIZEN_CROSSDIR/tizen.patch
+echo "<<Finish configuring Tizen rootfs"

--- a//dev/null
+++ b/eng/common/cross/x86/tizen-fetch.sh
@@ -0,0 +1,134 @@
+set -e
+if [[ -z "${VERBOSE// }" ]] || [ "$VERBOSE" -ne "$VERBOSE" ] 2>/dev/null; then
+	VERBOSE=0
+fi
+Log()
+{
+	if [ $VERBOSE -ge $1 ]; then
+		echo ${@:2}
+	fi
+}
+Inform()
+{
+	Log 1 -e "\x1B[0;34m$@\x1B[m"
+}
+Debug()
+{
+	Log 2 -e "\x1B[0;32m$@\x1B[m"
+}
+Error()
+{
+	>&2 Log 0 -e "\x1B[0;31m$@\x1B[m"
+}
+Fetch()
+{
+	URL=$1
+	FILE=$2
+	PROGRESS=$3
+	if [ $VERBOSE -ge 1 ] && [ $PROGRESS ]; then
+		CURL_OPT="--progress-bar"
+	else
+		CURL_OPT="--silent"
+	fi
+	curl $CURL_OPT $URL > $FILE
+}
+hash curl 2> /dev/null || { Error "Require 'curl' Aborting."; exit 1; }
+hash xmllint 2> /dev/null || { Error "Require 'xmllint' Aborting."; exit 1; }
+hash sha256sum 2> /dev/null || { Error "Require 'sha256sum' Aborting."; exit 1; }
+TMPDIR=$1
+if [ ! -d $TMPDIR ]; then
+	TMPDIR=./tizen_tmp
+	Debug "Create temporary directory : $TMPDIR"
+	mkdir -p $TMPDIR 
+fi
+TIZEN_URL=http://download.tizen.org/snapshots/tizen
+BUILD_XML=build.xml
+REPOMD_XML=repomd.xml
+PRIMARY_XML=primary.xml
+TARGET_URL="http://__not_initialized"
+Xpath_get()
+{
+	XPATH_RESULT=''
+	XPATH=$1
+	XML_FILE=$2
+	RESULT=$(xmllint --xpath $XPATH $XML_FILE)
+	if [[ -z ${RESULT// } ]]; then
+		Error "Can not find target from $XML_FILE"
+		Debug "Xpath = $XPATH"
+		exit 1
+	fi
+	XPATH_RESULT=$RESULT
+}
+fetch_tizen_pkgs_init()
+{
+	TARGET=$1
+	PROFILE=$2
+	Debug "Initialize TARGET=$TARGET, PROFILE=$PROFILE"
+	TMP_PKG_DIR=$TMPDIR/tizen_${PROFILE}_pkgs
+	if [ -d $TMP_PKG_DIR ]; then rm -rf $TMP_PKG_DIR; fi
+	mkdir -p $TMP_PKG_DIR
+	PKG_URL=$TIZEN_URL/$PROFILE/latest
+	BUILD_XML_URL=$PKG_URL/$BUILD_XML
+	TMP_BUILD=$TMP_PKG_DIR/$BUILD_XML
+	TMP_REPOMD=$TMP_PKG_DIR/$REPOMD_XML
+	TMP_PRIMARY=$TMP_PKG_DIR/$PRIMARY_XML
+	TMP_PRIMARYGZ=${TMP_PRIMARY}.gz
+	Fetch $BUILD_XML_URL $TMP_BUILD
+	Debug "fetch $BUILD_XML_URL to $TMP_BUILD"
+	TARGET_XPATH="//build/buildtargets/buildtarget[@name=\"$TARGET\"]/repo[@type=\"binary\"]/text()"
+	Xpath_get $TARGET_XPATH $TMP_BUILD
+	TARGET_PATH=$XPATH_RESULT
+	TARGET_URL=$PKG_URL/$TARGET_PATH
+	REPOMD_URL=$TARGET_URL/repodata/repomd.xml
+	PRIMARY_XPATH='string(//*[local-name()="data"][@type="primary"]/*[local-name()="location"]/@href)'
+	Fetch $REPOMD_URL $TMP_REPOMD
+	Debug "fetch $REPOMD_URL to $TMP_REPOMD"
+	Xpath_get $PRIMARY_XPATH $TMP_REPOMD
+	PRIMARY_XML_PATH=$XPATH_RESULT
+	PRIMARY_URL=$TARGET_URL/$PRIMARY_XML_PATH
+	Fetch $PRIMARY_URL $TMP_PRIMARYGZ
+	Debug "fetch $PRIMARY_URL to $TMP_PRIMARYGZ"
+	gunzip $TMP_PRIMARYGZ 
+	Debug "unzip $TMP_PRIMARYGZ to $TMP_PRIMARY" 
+}
+fetch_tizen_pkgs()
+{
+	ARCH=$1
+	PACKAGE_XPATH_TPL='string(//*[local-name()="metadata"]/*[local-name()="package"][*[local-name()="name"][text()="_PKG_"]][*[local-name()="arch"][text()="_ARCH_"]]/*[local-name()="location"]/@href)'
+	PACKAGE_CHECKSUM_XPATH_TPL='string(//*[local-name()="metadata"]/*[local-name()="package"][*[local-name()="name"][text()="_PKG_"]][*[local-name()="arch"][text()="_ARCH_"]]/*[local-name()="checksum"]/text())'
+	for pkg in ${@:2}
+	do
+		Inform "Fetching... $pkg"
+		XPATH=${PACKAGE_XPATH_TPL/_PKG_/$pkg}
+		XPATH=${XPATH/_ARCH_/$ARCH}
+		Xpath_get $XPATH $TMP_PRIMARY
+		PKG_PATH=$XPATH_RESULT
+		XPATH=${PACKAGE_CHECKSUM_XPATH_TPL/_PKG_/$pkg}
+		XPATH=${XPATH/_ARCH_/$ARCH}
+		Xpath_get $XPATH $TMP_PRIMARY
+		CHECKSUM=$XPATH_RESULT
+		PKG_URL=$TARGET_URL/$PKG_PATH
+		PKG_FILE=$(basename $PKG_PATH)
+		PKG_PATH=$TMPDIR/$PKG_FILE
+		Debug "Download $PKG_URL to $PKG_PATH"
+		Fetch $PKG_URL $PKG_PATH true
+		echo "$CHECKSUM $PKG_PATH" | sha256sum -c - > /dev/null
+		if [ $? -ne 0 ]; then
+			Error "Fail to fetch $PKG_URL to $PKG_PATH"
+			Debug "Checksum = $CHECKSUM"
+			exit 1
+		fi
+	done
+}
+Inform "Initialize i686 base"
+fetch_tizen_pkgs_init standard base
+Inform "fetch common packages"
+fetch_tizen_pkgs i686 gcc gcc-devel-static glibc glibc-devel libicu libicu-devel libatomic linux-glibc-devel keyutils keyutils-devel libkeyutils
+Inform "fetch coreclr packages"
+fetch_tizen_pkgs i686 lldb lldb-devel libgcc libstdc++ libstdc++-devel libunwind libunwind-devel lttng-ust-devel lttng-ust userspace-rcu-devel userspace-rcu
+Inform "fetch corefx packages"
+fetch_tizen_pkgs i686 libcom_err libcom_err-devel zlib zlib-devel libopenssl11 libopenssl1.1-devel krb5 krb5-devel
+Inform "Initialize standard unified"
+fetch_tizen_pkgs_init standard unified
+Inform "fetch corefx packages"
+fetch_tizen_pkgs i686 gssdp gssdp-devel tizen-release

--- a//dev/null
+++ b/eng/common/darc-init.sh
@@ -0,0 +1,66 @@
+source="${BASH_SOURCE[0]}"
+darcVersion=''
+versionEndpoint='https://maestro-prod.westus2.cloudapp.azure.com/api/assets/darc-version?api-version=2019-01-16'
+verbosity='minimal'
+while [[ $# > 0 ]]; do
+  opt="$(echo "$1" | tr "[:upper:]" "[:lower:]")"
+  case "$opt" in
+    --darcversion)
+      darcVersion=$2
+      shift
+      ;;
+    --versionendpoint)
+      versionEndpoint=$2
+      shift
+      ;;
+    --verbosity)
+      verbosity=$2
+      shift
+      ;;
+    --toolpath)
+      toolpath=$2
+      shift
+      ;;
+    *)
+      echo "Invalid argument: $1"
+      usage
+      exit 1
+      ;;
+  esac
+  shift
+done
+while [[ -h "$source" ]]; do
+  scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+  source="$(readlink "$source")"
+  [[ $source != /* ]] && source="$scriptroot/$source"
+done
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+. "$scriptroot/tools.sh"
+if [ -z "$darcVersion" ]; then
+  darcVersion=$(curl -X GET "$versionEndpoint" -H "accept: text/plain")
+fi
+function InstallDarcCli {
+  local darc_cli_package_name="microsoft.dotnet.darc"
+  InitializeDotNetCli true
+  local dotnet_root=$_InitializeDotNetCli
+  if [ -z "$toolpath" ]; then
+    local tool_list=$($dotnet_root/dotnet tool list -g)
+    if [[ $tool_list = *$darc_cli_package_name* ]]; then
+      echo $($dotnet_root/dotnet tool uninstall $darc_cli_package_name -g)
+    fi
+  else
+    local tool_list=$($dotnet_root/dotnet tool list --tool-path "$toolpath")
+    if [[ $tool_list = *$darc_cli_package_name* ]]; then
+      echo $($dotnet_root/dotnet tool uninstall $darc_cli_package_name --tool-path "$toolpath")
+    fi
+  fi
+  local arcadeServicesSource="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json"
+  echo "Installing Darc CLI version $darcVersion..."
+  echo "You may need to restart your command shell if this is the first dotnet tool you have installed."
+  if [ -z "$toolpath" ]; then
+    echo $($dotnet_root/dotnet tool install $darc_cli_package_name --version $darcVersion --add-source "$arcadeServicesSource" -v $verbosity -g)
+  else
+    echo $($dotnet_root/dotnet tool install $darc_cli_package_name --version $darcVersion --add-source "$arcadeServicesSource" -v $verbosity --tool-path "$toolpath")
+  fi
+}
+InstallDarcCli

--- a//dev/null
+++ b/eng/common/dotnet-install.sh
@@ -0,0 +1,75 @@
+source="${BASH_SOURCE[0]}"
+while [[ -h "$source" ]]; do
+  scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+  source="$(readlink "$source")"
+  [[ $source != /* ]] && source="$scriptroot/$source"
+done
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+. "$scriptroot/tools.sh"
+version='Latest'
+architecture=''
+runtime='dotnet'
+runtimeSourceFeed=''
+runtimeSourceFeedKey=''
+while [[ $# > 0 ]]; do
+  opt="$(echo "$1" | tr "[:upper:]" "[:lower:]")"
+  case "$opt" in
+    -version|-v)
+      shift
+      version="$1"
+      ;;
+    -architecture|-a)
+      shift
+      architecture="$1"
+      ;;
+    -runtime|-r)
+      shift
+      runtime="$1"
+      ;;
+    -runtimesourcefeed)
+      shift
+      runtimeSourceFeed="$1"
+      ;;
+    -runtimesourcefeedkey)
+      shift
+      runtimeSourceFeedKey="$1"
+      ;;
+    *)
+      Write-PipelineTelemetryError -Category 'Build' -Message "Invalid argument: $1"
+      exit 1
+      ;;
+  esac
+  shift
+done
+cpuname=$(uname -m)
+case $cpuname in
+  arm64|aarch64)
+    buildarch=arm64
+    ;;
+  loongarch64)
+    buildarch=loongarch64
+    ;;
+  amd64|x86_64)
+    buildarch=x64
+    ;;
+  armv*l)
+    buildarch=arm
+    ;;
+  i[3-6]86)
+    buildarch=x86
+    ;;
+  *)
+    echo "Unknown CPU $cpuname detected, treating it as x64"
+    buildarch=x64
+    ;;
+esac
+dotnetRoot="${repo_root}.dotnet"
+if [[ $architecture != "" ]] && [[ $architecture != $buildarch ]]; then
+  dotnetRoot="$dotnetRoot/$architecture"
+fi
+InstallDotNet $dotnetRoot $version "$architecture" $runtime true $runtimeSourceFeed $runtimeSourceFeedKey || {
+  local exit_code=$?
+  Write-PipelineTelemetryError -Category 'InitializeToolset' -Message "dotnet-install.sh failed (exit code '$exit_code')." >&2
+  ExitWithExitCode $exit_code
+}
+ExitWithExitCode 0

--- a//dev/null
+++ b/eng/common/generate-sbom-prep.sh
@@ -0,0 +1,22 @@
+source="${BASH_SOURCE[0]}"
+while [[ -h $source ]]; do
+  scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+  source="$(readlink "$source")"
+  [[ $source != /* ]] && source="$scriptroot/$source"
+done
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+. $scriptroot/pipeline-logging-functions.sh
+manifest_dir=$1
+if [ ! -d "$manifest_dir" ] ; then
+  mkdir -p "$manifest_dir"
+  echo "Sbom directory created." $manifest_dir
+else
+  Write-PipelineTelemetryError -category 'Build'  "Unable to create sbom folder."
+fi
+artifact_name=$SYSTEM_STAGENAME"_"$AGENT_JOBNAME"_SBOM"
+echo "Artifact name before : "$artifact_name
+safe_artifact_name="${artifact_name//["/:<>\\|?@*$" ]/_}"
+echo "Artifact name after : "$safe_artifact_name
+export ARTIFACT_NAME=$safe_artifact_name
+echo "##vso[task.setvariable variable=ARTIFACT_NAME]$safe_artifact_name"
+exit 0

--- a//dev/null
+++ b/eng/common/init-tools-native.sh
@@ -0,0 +1,192 @@
+source="${BASH_SOURCE[0]}"
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+base_uri='https://netcorenativeassets.blob.core.windows.net/resource-packages/external'
+install_directory=''
+clean=false
+force=false
+download_retries=5
+retry_wait_time_seconds=30
+global_json_file="$(dirname "$(dirname "${scriptroot}")")/global.json"
+declare -a native_assets
+. $scriptroot/pipeline-logging-functions.sh
+. $scriptroot/native/common-library.sh
+while (($# > 0)); do
+  lowerI="$(echo $1 | tr "[:upper:]" "[:lower:]")"
+  case $lowerI in
+    --baseuri)
+      base_uri=$2
+      shift 2
+      ;;
+    --installdirectory)
+      install_directory=$2
+      shift 2
+      ;;
+    --clean)
+      clean=true
+      shift 1
+      ;;
+    --force)
+      force=true
+      shift 1
+      ;;
+    --donotabortonfailure)
+      donotabortonfailure=true
+      shift 1
+      ;;
+    --donotdisplaywarnings)
+      donotdisplaywarnings=true
+      shift 1
+      ;;
+    --downloadretries)
+      download_retries=$2
+      shift 2
+      ;;
+    --retrywaittimeseconds)
+      retry_wait_time_seconds=$2
+      shift 2
+      ;;
+    --help)
+      echo "Common settings:"
+      echo "  --installdirectory                  Directory to install native toolset."
+      echo "                                      This is a command-line override for the default"
+      echo "                                      Install directory precedence order:"
+      echo "                                          - InstallDirectory command-line override"
+      echo "                                          - NETCOREENG_INSTALL_DIRECTORY environment variable"
+      echo "                                          - (default) %USERPROFILE%/.netcoreeng/native"
+      echo ""
+      echo "  --clean                             Switch specifying not to install anything, but cleanup native asset folders"
+      echo "  --donotabortonfailure               Switch specifiying whether to abort native tools installation on failure"
+      echo "  --donotdisplaywarnings              Switch specifiying whether to display warnings during native tools installation on failure"
+      echo "  --force                             Clean and then install tools"
+      echo "  --help                              Print help and exit"
+      echo ""
+      echo "Advanced settings:"
+      echo "  --baseuri <value>                   Base URI for where to download native tools from"
+      echo "  --downloadretries <value>           Number of times a download should be attempted"
+      echo "  --retrywaittimeseconds <value>      Wait time between download attempts"
+      echo ""
+      exit 0
+      ;;
+  esac
+done
+function ReadGlobalJsonNativeTools {
+  if command -v jq &> /dev/null; then
+    while IFS= read -rd '' line; do
+      native_assets+=("$line")
+    done < <(jq -r '. |
+        select(has("native-tools")) |
+        ."native-tools" |
+        keys[] as $k |
+        @sh "KEY=\($k) VALUE=\(.[$k])\u0000"' "$global_json_file")
+    return
+  fi
+  if [[ ! "$(cat "$global_json_file")" =~ \"native-tools\"[[:space:]\:\{]*([^\}]+) ]]; then
+    return
+  fi
+  section="${BASH_REMATCH[1]}"
+  parseStarted=0
+  possibleEnd=0
+  escaping=0
+  escaped=0
+  isKey=1
+  for (( i=0; i<${#section}; i++ )); do
+    char="${section:$i:1}"
+    if ! ((parseStarted)) && [[ "$char" =~ [[:space:],:] ]]; then continue; fi
+    if ! ((escaping)) && [[ "$char" == "\\" ]]; then
+      escaping=1
+    elif ((escaping)) && ! ((escaped)); then
+      escaped=1
+    fi
+    if ! ((parseStarted)) && [[ "$char" == "\"" ]]; then
+      parseStarted=1
+      possibleEnd=0
+    elif [[ "$char" == "'" ]]; then
+      token="$token'\\\''"
+      possibleEnd=0
+    elif ((escaping)) || [[ "$char" != "\"" ]]; then
+      token="$token$char"
+      possibleEnd=1
+    fi
+    if ((possibleEnd)) && ! ((escaping)) && [[ "$char" == "\"" ]]; then
+      printf -v token "'$token'"
+      if ((isKey)); then
+        KEY="$token"
+        isKey=0
+      else
+        line="KEY=$KEY VALUE=$token"
+        native_assets+=("$line")
+        isKey=1
+      fi
+      parseStarted=0
+      token=
+    elif ((escaping)) && ((escaped)); then
+      escaping=0
+      escaped=0
+    fi
+  done
+}
+native_base_dir=$install_directory
+if [[ -z $install_directory ]]; then
+  native_base_dir=$(GetNativeInstallDirectory)
+fi
+install_bin="${native_base_dir}/bin"
+installed_any=false
+ReadGlobalJsonNativeTools
+if [[ ${#native_assets[@]} -eq 0 ]]; then
+  echo "No native tools defined in global.json"
+  exit 0;
+else
+  native_installer_dir="$scriptroot/native"
+  for index in "${!native_assets[@]}"; do
+    eval "${native_assets["$index"]}"
+    installer_path="$native_installer_dir/install-$KEY.sh"
+    installer_command="$installer_path"
+    installer_command+=" --baseuri $base_uri"
+    installer_command+=" --installpath $install_bin"
+    installer_command+=" --version $VALUE"
+    echo $installer_command
+    if [[ $force = true ]]; then
+      installer_command+=" --force"
+    fi
+    if [[ $clean = true ]]; then
+      installer_command+=" --clean"
+    fi
+    if [[ -a $installer_path ]]; then
+      $installer_command
+      if [[ $? != 0 ]]; then
+        if [[ $donotabortonfailure = true ]]; then
+          if [[ $donotdisplaywarnings != true ]]; then
+            Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Execution Failed"
+          fi
+        else
+          Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Execution Failed"
+          exit 1
+        fi
+      else
+        $installed_any = true
+      fi
+    else
+      if [[ $donotabortonfailure == true ]]; then
+        if [[ $donotdisplaywarnings != true ]]; then
+          Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Execution Failed: no install script"
+        fi
+      else
+        Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Execution Failed: no install script"
+        exit 1
+      fi
+    fi
+  done
+fi
+if [[ $clean = true ]]; then
+  exit 0
+fi
+if [[ -d $install_bin ]]; then
+  echo "Native tools are available from $install_bin"
+  echo "##vso[task.prependpath]$install_bin"
+else
+  if [[ $installed_any = true ]]; then
+    Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Native tools install directory does not exist, installation failed"
+    exit 1
+  fi
+fi
+exit 0

--- a//dev/null
+++ b/eng/common/native/common-library.sh
@@ -0,0 +1,132 @@
+function GetNativeInstallDirectory {
+  local install_dir
+  if [[ -z $NETCOREENG_INSTALL_DIRECTORY ]]; then
+    install_dir=$HOME/.netcoreeng/native/
+  else
+    install_dir=$NETCOREENG_INSTALL_DIRECTORY
+  fi
+  echo $install_dir
+  return 0
+}
+function GetTempDirectory {
+  echo $(GetNativeInstallDirectory)temp/
+  return 0
+}
+function ExpandZip {
+  local zip_path=$1
+  local output_directory=$2
+  local force=${3:-false}
+  echo "Extracting $zip_path to $output_directory"
+  if [[ -d $output_directory ]] && [[ $force = false ]]; then
+    echo "Directory '$output_directory' already exists, skipping extract"
+    return 0
+  fi
+  if [[ -d $output_directory ]]; then
+    echo "'Force flag enabled, but '$output_directory' exists. Removing directory"
+    rm -rf $output_directory
+    if [[ $? != 0 ]]; then
+      Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Unable to remove '$output_directory'"
+      return 1
+    fi
+  fi
+  echo "Creating directory: '$output_directory'"
+  mkdir -p $output_directory
+  echo "Extracting archive"
+  tar -xf $zip_path -C $output_directory
+  if [[ $? != 0 ]]; then
+    Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Unable to extract '$zip_path'"
+    return 1
+  fi
+  return 0
+}
+function GetCurrentOS {
+  local unameOut="$(uname -s)"
+  case $unameOut in
+    Linux*)     echo "Linux";;
+    Darwin*)    echo "MacOS";;
+  esac
+  return 0
+}
+function GetFile {
+  local uri=$1
+  local path=$2
+  local force=${3:-false}
+  local download_retries=${4:-5}
+  local retry_wait_time_seconds=${5:-30}
+  if [[ -f $path ]]; then
+    if [[ $force = false ]]; then
+      echo "File '$path' already exists. Skipping download"
+      return 0
+    else
+      rm -rf $path
+    fi
+  fi
+  if [[ -f $uri ]]; then
+    echo "'$uri' is a file path, copying file to '$path'"
+    cp $uri $path
+    return $?
+  fi
+  echo "Downloading $uri"
+  if command -v curl > /dev/null; then
+    curl "$uri" -sSL --retry $download_retries --retry-delay $retry_wait_time_seconds --create-dirs -o "$path" --fail
+  else
+    wget -q -O "$path" "$uri" --tries="$download_retries"
+  fi
+  return $?
+}
+function GetTempPathFileName {
+  local path=$1
+  local temp_dir=$(GetTempDirectory)
+  local temp_file_name=$(basename $path)
+  echo $temp_dir$temp_file_name
+  return 0
+}
+function DownloadAndExtract {
+  local uri=$1
+  local installDir=$2
+  local force=${3:-false}
+  local download_retries=${4:-5}
+  local retry_wait_time_seconds=${5:-30}
+  local temp_tool_path=$(GetTempPathFileName $uri)
+  echo "downloading to: $temp_tool_path"
+  GetFile "$uri" "$temp_tool_path" $force $download_retries $retry_wait_time_seconds
+  if [[ $? != 0 ]]; then
+    Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Failed to download '$uri' to '$temp_tool_path'."
+    return 1
+  fi
+  echo "extracting from  $temp_tool_path to $installDir"
+  ExpandZip "$temp_tool_path" "$installDir" $force $download_retries $retry_wait_time_seconds
+  if [[ $? != 0 ]]; then
+    Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Failed to extract '$temp_tool_path' to '$installDir'."
+    return 1
+  fi
+  return 0
+}
+function NewScriptShim {
+  local shimpath=$1
+  local tool_file_path=$2
+  local force=${3:-false}
+  echo "Generating '$shimpath' shim"
+  if [[ -f $shimpath ]]; then
+    if [[ $force = false ]]; then
+      echo "File '$shimpath' already exists." >&2
+      return 1
+    else
+      rm -rf $shimpath
+    fi
+  fi
+  if [[ ! -f $tool_file_path ]]; then
+    tool_file_path="$(echo $tool_file_path | tr "[:upper:]" "[:lower:]")" 
+    if [[ ! -f $tool_file_path ]]; then
+      Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Specified tool file path:'$tool_file_path' does not exist"
+      return 1
+    fi
+  fi
+  local shim_contents=$'#!/usr/bin/env bash\n'
+  shim_contents+="SHIMARGS="$'$1\n'
+  shim_contents+="$tool_file_path"$' $SHIMARGS\n'
+  echo "$shim_contents" > $shimpath
+  chmod +x $shimpath
+  echo "Finished generating shim '$shimpath'"
+  return $?
+}

--- a//dev/null
+++ b/eng/common/native/init-compiler.sh
@@ -0,0 +1,112 @@
+if [[ "$#" -lt 3 ]]; then
+  echo "Usage..."
+  echo "init-compiler.sh <script directory> <Architecture> <compiler>"
+  echo "Specify the script directory."
+  echo "Specify the target architecture."
+  echo "Specify the name of compiler (clang or gcc)."
+  exit 1
+fi
+nativescriptroot="$1"
+build_arch="$2"
+compiler="$3"
+case "$compiler" in
+    clang*|-clang*|--clang*)
+        version="$(echo "$compiler" | tr -d '[:alpha:]-=')"
+        parts=(${version//./ })
+        majorVersion="${parts[0]}"
+        minorVersion="${parts[1]}"
+        if [[ -z "$minorVersion" && "$majorVersion" -le 6 ]]; then
+            minorVersion=0;
+        fi
+        compiler=clang
+        ;;
+    gcc*|-gcc*|--gcc*)
+        version="$(echo "$compiler" | tr -d '[:alpha:]-=')"
+        parts=(${version//./ })
+        majorVersion="${parts[0]}"
+        minorVersion="${parts[1]}"
+        compiler=gcc
+        ;;
+esac
+cxxCompiler="$compiler++"
+. "$nativescriptroot"/../pipeline-logging-functions.sh
+CC=
+CXX=
+LDFLAGS=
+if [[ "$compiler" == "gcc" ]]; then cxxCompiler="g++"; fi
+check_version_exists() {
+    desired_version=-1
+    if command -v "$compiler-$1.$2" > /dev/null; then
+        desired_version="-$1.$2"
+    elif command -v "$compiler$1$2" > /dev/null; then
+        desired_version="$1$2"
+    elif command -v "$compiler-$1$2" > /dev/null; then
+        desired_version="-$1$2"
+    fi
+    echo "$desired_version"
+}
+if [[ -z "$CLR_CC" ]]; then
+    if [[ -z "$majorVersion" ]]; then
+        if [[ "$compiler" == "clang" ]]; then versions=( 15 14 13 12 11 10 9 8 7 6.0 5.0 4.0 3.9 3.8 3.7 3.6 3.5 )
+        elif [[ "$compiler" == "gcc" ]]; then versions=( 12 11 10 9 8 7 6 5 4.9 ); fi
+        for version in "${versions[@]}"; do
+            parts=(${version//./ })
+            desired_version="$(check_version_exists "${parts[0]}" "${parts[1]}")"
+            if [[ "$desired_version" != "-1" ]]; then majorVersion="${parts[0]}"; break; fi
+        done
+        if [[ -z "$majorVersion" ]]; then
+            if command -v "$compiler" > /dev/null; then
+                if [[ "$(uname)" != "Darwin" ]]; then
+                    Write-PipelineTelemetryError -category "Build" -type "warning" "Specific version of $compiler not found, falling back to use the one in PATH."
+                fi
+                CC="$(command -v "$compiler")"
+                CXX="$(command -v "$cxxCompiler")"
+            else
+                Write-PipelineTelemetryError -category "Build" "No usable version of $compiler found."
+                exit 1
+            fi
+        else
+            if [[ "$compiler" == "clang" && "$majorVersion" -lt 5 ]]; then
+                if [[ "$build_arch" == "arm" || "$build_arch" == "armel" ]]; then
+                    if command -v "$compiler" > /dev/null; then
+                        Write-PipelineTelemetryError -category "Build" -type "warning" "Found clang version $majorVersion which is not supported on arm/armel architectures, falling back to use clang from PATH."
+                        CC="$(command -v "$compiler")"
+                        CXX="$(command -v "$cxxCompiler")"
+                    else
+                        Write-PipelineTelemetryError -category "Build" "Found clang version $majorVersion which is not supported on arm/armel architectures, and there is no clang in PATH."
+                        exit 1
+                    fi
+                fi
+            fi
+        fi
+    else
+        desired_version="$(check_version_exists "$majorVersion" "$minorVersion")"
+        if [[ "$desired_version" == "-1" ]]; then
+            Write-PipelineTelemetryError -category "Build" "Could not find specific version of $compiler: $majorVersion $minorVersion."
+            exit 1
+        fi
+    fi
+    if [[ -z "$CC" ]]; then
+        CC="$(command -v "$compiler$desired_version")"
+        CXX="$(command -v "$cxxCompiler$desired_version")"
+        if [[ -z "$CXX" ]]; then CXX="$(command -v "$cxxCompiler")"; fi
+    fi
+else
+    if [[ ! -f "$CLR_CC" ]]; then
+        Write-PipelineTelemetryError -category "Build" "CLR_CC is set but path '$CLR_CC' does not exist"
+        exit 1
+    fi
+    CC="$CLR_CC"
+    CXX="$CLR_CXX"
+fi
+if [[ -z "$CC" ]]; then
+    Write-PipelineTelemetryError -category "Build" "Unable to find $compiler."
+    exit 1
+fi
+if [[ "$compiler" == "clang" && "$majorVersion" -ge 9 ]]; then
+    if "$CC" -fuse-ld=lld -Wl,--version >/dev/null 2>&1; then
+        LDFLAGS="-fuse-ld=lld"
+    fi
+fi
+SCAN_BUILD_COMMAND="$(command -v "scan-build$desired_version")"
+export CC CXX LDFLAGS SCAN_BUILD_COMMAND

--- a//dev/null
+++ b/eng/common/tools.sh
@@ -0,0 +1,390 @@
+ci=${ci:-false}
+if [[ "$ci" == true ]]; then
+  pipelines_log=${pipelines_log:-true}
+else
+  pipelines_log=${pipelines_log:-false}
+fi
+configuration=${configuration:-'Debug'}
+exclude_ci_binary_log=${exclude_ci_binary_log:-false}
+if [[ "$ci" == true && "$exclude_ci_binary_log" == false ]]; then
+  binary_log_default=true
+else
+  binary_log_default=false
+fi
+binary_log=${binary_log:-$binary_log_default}
+prepare_machine=${prepare_machine:-false}
+restore=${restore:-true}
+verbosity=${verbosity:-'minimal'}
+if [[ "$ci" == true ]]; then
+  node_reuse=${node_reuse:-false}
+else
+  node_reuse=${node_reuse:-true}
+fi
+warn_as_error=${warn_as_error:-true}
+use_installed_dotnet_cli=${use_installed_dotnet_cli:-true}
+dotnetInstallScriptVersion=${dotnetInstallScriptVersion:-'v1'}
+if [[ "$ci" == true ]]; then
+  use_global_nuget_cache=${use_global_nuget_cache:-false}
+else
+  use_global_nuget_cache=${use_global_nuget_cache:-true}
+fi
+runtime_source_feed=${runtime_source_feed:-''}
+runtime_source_feed_key=${runtime_source_feed_key:-''}
+function ResolvePath {
+  local path=$1
+  while [[ -h $path ]]; do
+    local dir="$( cd -P "$( dirname "$path" )" && pwd )"
+    path="$(readlink "$path")"
+    [[ $path != /* ]] && path="$dir/$path"
+  done
+  _ResolvePath="$path"
+}
+function ReadGlobalVersion {
+  local key=$1
+  if command -v jq &> /dev/null; then
+    _ReadGlobalVersion="$(jq -r ".[] | select(has(\"$key\")) | .\"$key\"" "$global_json_file")"
+  elif [[ "$(cat "$global_json_file")" =~ \"$key\"[[:space:]\:]*\"([^\"]+) ]]; then
+    _ReadGlobalVersion=${BASH_REMATCH[1]}
+  fi
+  if [[ -z "$_ReadGlobalVersion" ]]; then
+    Write-PipelineTelemetryError -category 'Build' "Error: Cannot find \"$key\" in $global_json_file"
+    ExitWithExitCode 1
+  fi
+}
+function InitializeDotNetCli {
+  if [[ -n "${_InitializeDotNetCli:-}" ]]; then
+    return
+  fi
+  local install=$1
+  export DOTNET_MULTILEVEL_LOOKUP=0
+  export DOTNET_SKIP_FIRST_TIME_EXPERIENCE=1
+  if [[ $ci == true ]]; then
+    export DOTNET_CLI_TELEMETRY_OPTOUT=1
+  fi
+  export LTTNG_HOME="$HOME"
+  if [[ -n "${DotNetCoreSdkDir:-}" ]]; then
+    export DOTNET_INSTALL_DIR="$DotNetCoreSdkDir"
+  fi
+  if [[ "$use_installed_dotnet_cli" == true && $global_json_has_runtimes == false && -z "${DOTNET_INSTALL_DIR:-}" ]]; then
+    local dotnet_path=`command -v dotnet`
+    if [[ -n "$dotnet_path" ]]; then
+      ResolvePath "$dotnet_path"
+      export DOTNET_INSTALL_DIR=`dirname "$_ResolvePath"`
+    fi
+  fi
+  ReadGlobalVersion "dotnet"
+  local dotnet_sdk_version=$_ReadGlobalVersion
+  local dotnet_root=""
+  if [[ $global_json_has_runtimes == false && -n "${DOTNET_INSTALL_DIR:-}" && -d "$DOTNET_INSTALL_DIR/sdk/$dotnet_sdk_version" ]]; then
+    dotnet_root="$DOTNET_INSTALL_DIR"
+  else
+    dotnet_root="$repo_root/.dotnet"
+    export DOTNET_INSTALL_DIR="$dotnet_root"
+    if [[ ! -d "$DOTNET_INSTALL_DIR/sdk/$dotnet_sdk_version" ]]; then
+      if [[ "$install" == true ]]; then
+        InstallDotNetSdk "$dotnet_root" "$dotnet_sdk_version"
+      else
+        Write-PipelineTelemetryError -category 'InitializeToolset' "Unable to find dotnet with SDK version '$dotnet_sdk_version'"
+        ExitWithExitCode 1
+      fi
+    fi
+  fi
+  Write-PipelinePrependPath -path "$dotnet_root"
+  Write-PipelineSetVariable -name "DOTNET_MULTILEVEL_LOOKUP" -value "0"
+  Write-PipelineSetVariable -name "DOTNET_SKIP_FIRST_TIME_EXPERIENCE" -value "1"
+  _InitializeDotNetCli="$dotnet_root"
+}
+function InstallDotNetSdk {
+  local root=$1
+  local version=$2
+  local architecture="unset"
+  if [[ $# -ge 3 ]]; then
+    architecture=$3
+  fi
+  InstallDotNet "$root" "$version" $architecture 'sdk' 'true' $runtime_source_feed $runtime_source_feed_key
+}
+function InstallDotNet {
+  local root=$1
+  local version=$2
+  GetDotNetInstallScript "$root"
+  local install_script=$_GetDotNetInstallScript
+  local installParameters=(--version $version --install-dir "$root")
+  if [[ -n "${3:-}" ]] && [ "$3" != 'unset' ]; then
+    installParameters+=(--architecture $3)
+  fi
+  if [[ -n "${4:-}" ]] && [ "$4" != 'sdk' ]; then
+    installParameters+=(--runtime $4)
+  fi
+  if [[ "$#" -ge "5" ]] && [[ "$5" != 'false' ]]; then
+    installParameters+=(--skip-non-versioned-files)
+  fi
+  local variations=() # list of variable names with parameter arrays in them
+  local public_location=("${installParameters[@]}")
+  variations+=(public_location)
+  local dotnetbuilds=("${installParameters[@]}" --azure-feed "https://dotnetbuilds.azureedge.net/public")
+  variations+=(dotnetbuilds)
+  if [[ -n "${6:-}" ]]; then
+    variations+=(private_feed)
+    local private_feed=("${installParameters[@]}" --azure-feed $6)
+    if [[ -n "${7:-}" ]]; then
+      decodeArg="--decode"
+      if base64 --help 2>&1 | grep -q "BusyBox"; then
+          decodeArg="-d"
+      fi
+      decodedFeedKey=`echo $7 | base64 $decodeArg`
+      private_feed+=(--feed-credential $decodedFeedKey)
+    fi
+  fi
+  local installSuccess=0
+  for variationName in "${variations[@]}"; do
+    local name="$variationName[@]"
+    local variation=("${!name}")
+    echo "Attempting to install dotnet from $variationName."
+    bash "$install_script" "${variation[@]}" && installSuccess=1
+    if [[ "$installSuccess" -eq 1 ]]; then
+      break
+    fi
+    echo "Failed to install dotnet from $variationName."
+  done
+  if [[ "$installSuccess" -eq 0 ]]; then
+    Write-PipelineTelemetryError -category 'InitializeToolset' "Failed to install dotnet SDK from any of the specified locations."
+    ExitWithExitCode 1
+  fi
+}
+function with_retries {
+  local maxRetries=5
+  local retries=1
+  echo "Trying to run '$@' for maximum of $maxRetries attempts."
+  while [[ $((retries++)) -le $maxRetries ]]; do
+    "$@"
+    if [[ $? == 0 ]]; then
+      echo "Ran '$@' successfully."
+      return 0
+    fi
+    timeout=$((3**$retries-1))
+    echo "Failed to execute '$@'. Waiting $timeout seconds before next attempt ($retries out of $maxRetries)." 1>&2
+    sleep $timeout
+  done
+  echo "Failed to execute '$@' for $maxRetries times." 1>&2
+  return 1
+}
+function GetDotNetInstallScript {
+  local root=$1
+  local install_script="$root/dotnet-install.sh"
+  local install_script_url="https://dotnet.microsoft.com/download/dotnet/scripts/$dotnetInstallScriptVersion/dotnet-install.sh"
+  if [[ ! -a "$install_script" ]]; then
+    mkdir -p "$root"
+    echo "Downloading '$install_script_url'"
+    if command -v curl > /dev/null; then
+      curl "$install_script_url" -sSL --retry 10 --create-dirs -o "$install_script" || {
+        if command -v openssl &> /dev/null; then
+          echo "Curl failed; dumping some information about dotnet.microsoft.com for later investigation"
+          echo | openssl s_client -showcerts -servername dotnet.microsoft.com  -connect dotnet.microsoft.com:443
+        fi
+        echo "Will now retry the same URL with verbose logging."
+        with_retries curl "$install_script_url" -sSL --verbose --retry 10 --create-dirs -o "$install_script" || {
+          local exit_code=$?
+          Write-PipelineTelemetryError -category 'InitializeToolset' "Failed to acquire dotnet install script (exit code '$exit_code')."
+          ExitWithExitCode $exit_code
+        }
+      }
+    else
+      with_retries wget -v -O "$install_script" "$install_script_url" || {
+        local exit_code=$?
+        Write-PipelineTelemetryError -category 'InitializeToolset' "Failed to acquire dotnet install script (exit code '$exit_code')."
+        ExitWithExitCode $exit_code
+      }
+    fi
+  fi
+  _GetDotNetInstallScript="$install_script"
+}
+function InitializeBuildTool {
+  if [[ -n "${_InitializeBuildTool:-}" ]]; then
+    return
+  fi
+  InitializeDotNetCli $restore
+  _InitializeBuildTool="$_InitializeDotNetCli/dotnet"
+  _InitializeBuildToolCommand="msbuild"
+  _InitializeBuildToolFramework="net7.0"
+}
+function GetNuGetPackageCachePath {
+  if [[ -z ${NUGET_PACKAGES:-} ]]; then
+    if [[ "$use_global_nuget_cache" == true ]]; then
+      export NUGET_PACKAGES="$HOME/.nuget/packages"
+    else
+      export NUGET_PACKAGES="$repo_root/.packages"
+      export RESTORENOCACHE=true
+    fi
+  fi
+  _GetNuGetPackageCachePath=$NUGET_PACKAGES
+}
+function InitializeNativeTools() {
+  if [[ -n "${DisableNativeToolsetInstalls:-}" ]]; then
+    return
+  fi
+  if grep -Fq "native-tools" $global_json_file
+  then
+    local nativeArgs=""
+    if [[ "$ci" == true ]]; then
+      nativeArgs="--installDirectory $tools_dir"
+    fi
+    "$_script_dir/init-tools-native.sh" $nativeArgs
+  fi
+}
+function InitializeToolset {
+  if [[ -n "${_InitializeToolset:-}" ]]; then
+    return
+  fi
+  GetNuGetPackageCachePath
+  ReadGlobalVersion "Microsoft.DotNet.Arcade.Sdk"
+  local toolset_version=$_ReadGlobalVersion
+  local toolset_location_file="$toolset_dir/$toolset_version.txt"
+  if [[ -a "$toolset_location_file" ]]; then
+    local path=`cat "$toolset_location_file"`
+    if [[ -a "$path" ]]; then
+      _InitializeToolset="$path"
+      return
+    fi
+  fi
+  if [[ "$restore" != true ]]; then
+    Write-PipelineTelemetryError -category 'InitializeToolset' "Toolset version $toolset_version has not been restored."
+    ExitWithExitCode 2
+  fi
+  local proj="$toolset_dir/restore.proj"
+  local bl=""
+  if [[ "$binary_log" == true ]]; then
+    bl="/bl:$log_dir/ToolsetRestore.binlog"
+  fi
+  echo '<Project Sdk="Microsoft.DotNet.Arcade.Sdk"/>' > "$proj"
+  MSBuild-Core "$proj" $bl /t:__WriteToolsetLocation /clp:ErrorsOnly\;NoSummary /p:__ToolsetLocationOutputFile="$toolset_location_file"
+  local toolset_build_proj=`cat "$toolset_location_file"`
+  if [[ ! -a "$toolset_build_proj" ]]; then
+    Write-PipelineTelemetryError -category 'Build' "Invalid toolset path: $toolset_build_proj"
+    ExitWithExitCode 3
+  fi
+  _InitializeToolset="$toolset_build_proj"
+}
+function ExitWithExitCode {
+  if [[ "$ci" == true && "$prepare_machine" == true ]]; then
+    StopProcesses
+  fi
+  exit $1
+}
+function StopProcesses {
+  echo "Killing running build processes..."
+  pkill -9 "dotnet" || true
+  pkill -9 "vbcscompiler" || true
+  return 0
+}
+function MSBuild {
+  local args=$@
+  if [[ "$pipelines_log" == true ]]; then
+    InitializeBuildTool
+    InitializeToolset
+    if [[ "$ci" == true ]]; then
+      export NUGET_PLUGIN_HANDSHAKE_TIMEOUT_IN_SECONDS=20
+      export NUGET_PLUGIN_REQUEST_TIMEOUT_IN_SECONDS=20
+      Write-PipelineSetVariable -name "NUGET_PLUGIN_HANDSHAKE_TIMEOUT_IN_SECONDS" -value "20"
+      Write-PipelineSetVariable -name "NUGET_PLUGIN_REQUEST_TIMEOUT_IN_SECONDS" -value "20"
+      export NUGET_ENABLE_EXPERIMENTAL_HTTP_RETRY=true
+      export NUGET_EXPERIMENTAL_MAX_NETWORK_TRY_COUNT=6
+      export NUGET_EXPERIMENTAL_NETWORK_RETRY_DELAY_MILLISECONDS=1000
+      Write-PipelineSetVariable -name "NUGET_ENABLE_EXPERIMENTAL_HTTP_RETRY" -value "true"
+      Write-PipelineSetVariable -name "NUGET_EXPERIMENTAL_MAX_NETWORK_TRY_COUNT" -value "6"
+      Write-PipelineSetVariable -name "NUGET_EXPERIMENTAL_NETWORK_RETRY_DELAY_MILLISECONDS" -value "1000"
+    fi
+    local toolset_dir="${_InitializeToolset%/*}"
+    local selectedPath=
+    local possiblePaths=()
+    possiblePaths+=( "$toolset_dir/$_InitializeBuildToolFramework/Microsoft.DotNet.ArcadeLogging.dll" )
+    possiblePaths+=( "$toolset_dir/$_InitializeBuildToolFramework/Microsoft.DotNet.Arcade.Sdk.dll" )
+    possiblePaths+=( "$toolset_dir/netcoreapp2.1/Microsoft.DotNet.ArcadeLogging.dll" )
+    possiblePaths+=( "$toolset_dir/netcoreapp2.1/Microsoft.DotNet.Arcade.Sdk.dll" )
+    possiblePaths+=( "$toolset_dir/netcoreapp3.1/Microsoft.DotNet.ArcadeLogging.dll" )
+    possiblePaths+=( "$toolset_dir/netcoreapp3.1/Microsoft.DotNet.Arcade.Sdk.dll" )
+    for path in "${possiblePaths[@]}"; do
+      if [[ -f $path ]]; then
+        selectedPath=$path
+        break
+      fi
+    done
+    if [[ -z "$selectedPath" ]]; then
+      Write-PipelineTelemetryError -category 'Build'  "Unable to find arcade sdk logger assembly."
+      ExitWithExitCode 1
+    fi
+    args+=( "-logger:$selectedPath" )
+  fi
+  MSBuild-Core ${args[@]}
+}
+function MSBuild-Core {
+  if [[ "$ci" == true ]]; then
+    if [[ "$binary_log" != true && "$exclude_ci_binary_log" != true ]]; then
+      Write-PipelineTelemetryError -category 'Build'  "Binary log must be enabled in CI build, or explicitly opted-out from with the -noBinaryLog switch."
+      ExitWithExitCode 1
+    fi
+    if [[ "$node_reuse" == true ]]; then
+      Write-PipelineTelemetryError -category 'Build'  "Node reuse must be disabled in CI build."
+      ExitWithExitCode 1
+    fi
+  fi
+  InitializeBuildTool
+  local warnaserror_switch=""
+  if [[ $warn_as_error == true ]]; then
+    warnaserror_switch="/warnaserror"
+  fi
+  function RunBuildTool {
+    export ARCADE_BUILD_TOOL_COMMAND="$_InitializeBuildTool $@"
+    "$_InitializeBuildTool" "$@" || {
+      local exit_code=$?
+      echo "Build failed with exit code $exit_code. Check errors above."
+      if [[ "$ci" == "true" ]]; then
+        Write-PipelineSetResult -result "Failed" -message "msbuild execution failed."
+        ExitWithExitCode 0
+      else
+        ExitWithExitCode $exit_code
+      fi
+    }
+  }
+  RunBuildTool "$_InitializeBuildToolCommand" /m /nologo /clp:Summary /v:$verbosity /nr:$node_reuse $warnaserror_switch /p:TreatWarningsAsErrors=$warn_as_error /p:ContinuousIntegrationBuild=$ci "$@"
+}
+ResolvePath "${BASH_SOURCE[0]}"
+_script_dir=`dirname "$_ResolvePath"`
+. "$_script_dir/pipeline-logging-functions.sh"
+eng_root=`cd -P "$_script_dir/.." && pwd`
+repo_root=`cd -P "$_script_dir/../.." && pwd`
+repo_root="${repo_root}/"
+artifacts_dir="${repo_root}artifacts"
+toolset_dir="$artifacts_dir/toolset"
+tools_dir="${repo_root}.tools"
+log_dir="$artifacts_dir/log/$configuration"
+temp_dir="$artifacts_dir/tmp/$configuration"
+global_json_file="${repo_root}global.json"
+global_json_has_runtimes=false
+if command -v jq &> /dev/null; then
+  if jq -er '. | select(has("runtimes"))' "$global_json_file" &> /dev/null; then
+    global_json_has_runtimes=true
+  fi
+elif [[ "$(cat "$global_json_file")" =~ \"runtimes\"[[:space:]\:]*\{ ]]; then
+  global_json_has_runtimes=true
+fi
+if [[ -z $HOME ]]; then
+  export HOME="${repo_root}artifacts/.home/"
+  mkdir -p "$HOME"
+fi
+mkdir -p "$toolset_dir"
+mkdir -p "$temp_dir"
+mkdir -p "$log_dir"
+Write-PipelineSetVariable -name "Artifacts" -value "$artifacts_dir"
+Write-PipelineSetVariable -name "Artifacts.Toolset" -value "$toolset_dir"
+Write-PipelineSetVariable -name "Artifacts.Log" -value "$log_dir"
+Write-PipelineSetVariable -name "Temp" -value "$temp_dir"
+Write-PipelineSetVariable -name "TMP" -value "$temp_dir"
+if [ -z "${disable_configure_toolset_import:-}" ]; then
+  configure_toolset_script="$eng_root/configure-toolset.sh"
+  if [[ -a "$configure_toolset_script" ]]; then
+    . "$configure_toolset_script"
+  fi
+fi
+if [[ -n "${useInstalledDotNetCli:-}" ]]; then
+  use_installed_dotnet_cli="$useInstalledDotNetCli"
+fi

--- a//dev/null
+++ b/eng/docker/build-docker-sdk.sh
@@ -0,0 +1,34 @@
+set -u
+set -e
+source="${BASH_SOURCE[0]}"
+while [[ -h "$source" ]]; do
+  scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+  source="$(readlink "$source")"
+  [[ $source != /* ]] && source="$scriptroot/$source"
+done
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+imagename="dotnet-sdk-libs-current"
+configuration="Release"
+while [[ $# > 0 ]]; do
+  opt="$(echo "${1/#--/-}" | tr "[:upper:]" "[:lower:]")"
+  case "$opt" in
+    -imagename|-t)
+      imagename=$2
+      shift 2
+      ;;
+    -configuration|-c)
+      configuration=$2
+      shift 2
+      ;;
+    *)
+      shift 1
+      ;;
+  esac
+done
+repo_root=$(git rev-parse --show-toplevel)
+docker_file="$scriptroot/libraries-sdk.linux.Dockerfile"
+docker build --tag $imagename \
+    --build-arg CONFIGURATION=$configuration \
+    --file $docker_file \
+    $repo_root
+exit $?

--- a//dev/null
+++ b/eng/formatting/download-tools.sh
@@ -0,0 +1,30 @@
+set -ue
+source="${BASH_SOURCE[0]}"
+while [[ -h "$source" ]]; do
+  scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+  source="$(readlink "$source")"
+  [[ $source != /* ]] && source="$scriptroot/$source"
+done
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+function DownloadClangTool {
+    targetPlatform=$(dotnet --info |grep RID:)
+    targetPlatform=${targetPlatform##*RID:* }
+    toolUrl=https://clrjit.blob.core.windows.net/clang-tools/${targetPlatform}/$1
+    toolOutput=$2/$1
+    if [[ ! -x "$toolOutput" ]]; then
+        curl --retry 5 -o "${toolOutput}" "$toolUrl"
+        chmod 751 $toolOutput
+    fi
+    if [[ ! -x "$toolOutput" ]]; then
+        echo "Failed to download $1"
+        exit 1
+    fi
+}
+engFolder="$(cd -P "$( dirname "$scriptroot" )" && pwd )"
+downloadPathFolder="$(cd -P "$( dirname "$engFolder" )" && pwd )/artifacts/tools"
+mkdir -p "$downloadPathFolder"
+. "$scriptroot/../common/tools.sh"
+InitializeDotNetCli true
+DownloadClangTool "clang-format" "$downloadPathFolder"
+DownloadClangTool "clang-tidy" "$downloadPathFolder"
+export PATH=$downloadPathFolder:$PATH

--- a/eng/install-native-dependencies.sh
+++ b//dev/null
@@ -1,31 +0,0 @@
-set -e
-os="$(echo "$1" | tr "[:upper:]" "[:lower:]")"
-if [ -z "$os" ]; then
-    . "$(dirname "$0")"/native/init-os-and-arch.sh
-    os="$(echo "$os" | tr "[:upper:]" "[:lower:]")"
-fi
-case "$os" in
-    linux)
-        if [ -e /etc/os-release ]; then
-            . /etc/os-release
-        fi
-        if [ "$ID" != "debian" ] && [ "$ID_LIKE" != "debian" ]; then
-            echo "Unsupported distro. distro: $ID"
-            exit 1
-        fi
-        apt update
-        apt install -y build-essential gettext locales cmake llvm clang lldb liblldb-dev libunwind8-dev libicu-dev liblttng-ust-dev \
-            libssl-dev libkrb5-dev libnuma-dev zlib1g-dev
-        localedef -i en_US -c -f UTF-8 -A /usr/share/locale/locale.alias en_US.UTF-8
-        ;;
-    osx|mac*|ios*|tvos*)
-        echo "Installed xcode version: $(xcode-select -p)"
-        export HOMEBREW_NO_INSTALL_CLEANUP=1
-        export HOMEBREW_NO_INSTALLED_DEPENDENTS_CHECK=1
-        brew bundle --no-upgrade --no-lock --file "$(dirname "$0")/Brewfile"
-        ;;
-    *)
-        echo "Unsupported platform. OS: $os"
-        exit 1
-        ;;
-esac

--- a/src/coreclr/debug/createdump/crashinfo.cpp
+++ b//dev/null
@@ -1,708 +0,0 @@
-#include "createdump.h"
-#include <clrconfignocache.h>
-CrashInfo* g_crashInfo;
-static bool ModuleInfoCompare(const ModuleInfo* lhs, const ModuleInfo* rhs) { return lhs->BaseAddress() < rhs->BaseAddress(); }
-CrashInfo::CrashInfo(const CreateDumpOptions& options) :
-    m_ref(1),
-    m_pid(options.Pid),
-    m_ppid(-1),
-    m_hdac(nullptr),
-    m_pClrDataEnumRegions(nullptr),
-    m_pClrDataProcess(nullptr),
-    m_gatherFrames(options.CrashReport),
-    m_crashThread(options.CrashThread),
-    m_signal(options.Signal),
-    m_moduleInfos(&ModuleInfoCompare),
-    m_mainModule(nullptr),
-    m_cbModuleMappings(0),
-    m_dataTargetPagesAdded(0),
-    m_enumMemoryPagesAdded(0)
-{
-    g_crashInfo = this;
-#ifdef __APPLE__
-    m_task = 0;
-#else
-    m_auxvValues.fill(0);
-    m_fd = -1;
-    memset(&m_siginfo, 0, sizeof(m_siginfo));
-    m_siginfo.si_signo = options.Signal;
-    m_siginfo.si_code = options.SignalCode;
-    m_siginfo.si_errno = options.SignalErrno;
-    m_siginfo.si_addr = options.SignalAddress;
-#endif
-}
-CrashInfo::~CrashInfo()
-{
-    for (ThreadInfo* thread : m_threads)
-    {
-        delete thread;
-    }
-    m_threads.clear();
-    for (ModuleInfo* module : m_moduleInfos)
-    {
-        delete module;
-    }
-    m_moduleInfos.clear();
-    if (m_pClrDataEnumRegions != nullptr)
-    {
-        m_pClrDataEnumRegions->Release();
-    }
-    if (m_pClrDataProcess != nullptr)
-    {
-        m_pClrDataProcess->Release();
-    }
-    if (m_hdac != nullptr)
-    {
-        FreeLibrary(m_hdac);
-        m_hdac = nullptr;
-    }
-#ifdef __APPLE__
-    if (m_task != 0)
-    {
-        kern_return_t result = ::mach_port_deallocate(mach_task_self(), m_task);
-        if (result != KERN_SUCCESS)
-        {
-            printf_error("Internal error: mach_port_deallocate FAILED %s (%x)\n", mach_error_string(result), result);
-        }
-    }
-#endif
-}
-STDMETHODIMP
-CrashInfo::QueryInterface(
-    ___in REFIID InterfaceId,
-    ___out PVOID* Interface)
-{
-    if (InterfaceId == IID_IUnknown ||
-        InterfaceId == IID_ICLRDataEnumMemoryRegionsCallback)
-    {
-        *Interface = (ICLRDataEnumMemoryRegionsCallback*)this;
-        AddRef();
-        return S_OK;
-    }
-    else if (InterfaceId == IID_ICLRDataLoggingCallback)
-    {
-        *Interface = (ICLRDataLoggingCallback*)this;
-        AddRef();
-        return S_OK;
-    }
-    else
-    {
-        *Interface = nullptr;
-        return E_NOINTERFACE;
-    }
-}
-STDMETHODIMP_(ULONG)
-CrashInfo::AddRef()
-{
-    LONG ref = InterlockedIncrement(&m_ref);
-    return ref;
-}
-STDMETHODIMP_(ULONG)
-CrashInfo::Release()
-{
-    LONG ref = InterlockedDecrement(&m_ref);
-    if (ref == 0)
-    {
-        delete this;
-    }
-    return ref;
-}
-HRESULT STDMETHODCALLTYPE
-CrashInfo::EnumMemoryRegion(
-    /* [in] */ CLRDATA_ADDRESS address,
-    /* [in] */ ULONG32 size)
-{
-    m_enumMemoryPagesAdded += InsertMemoryRegion((ULONG_PTR)address, size);
-    return S_OK;
-}
-HRESULT STDMETHODCALLTYPE
-CrashInfo::LogMessage(
-    /* [in] */ LPCSTR message)
-{
-    Trace("%s", message);
-    return S_OK;
-}
-bool
-CrashInfo::GatherCrashInfo(MINIDUMP_TYPE minidumpType)
-{
-    for (ThreadInfo* thread : m_threads)
-    {
-        if (!thread->Initialize())
-        {
-            return false;
-        }
-    }
-#ifdef __APPLE__
-    if (!EnumerateMemoryRegions())
-    {
-        return false;
-    }
-#else
-    if (!GetAuxvEntries())
-    {
-        return false;
-    }
-    if (!EnumerateMemoryRegions())
-    {
-        return false;
-    }
-    if (!GetDSOInfo())
-    {
-        return false;
-    }
-#endif
-    if (!InitializeDAC())
-    {
-        return false;
-    }
-    if (!EnumerateManagedModules())
-    {
-        return false;
-    }
-#ifdef __APPLE__
-    InitializeOtherMappings();
-#endif
-    if (!UnwindAllThreads())
-    {
-        return false;
-    }
-    if (g_diagnosticsVerbose)
-    {
-        TRACE("Module addresses:\n");
-        for (const MemoryRegion& region : m_moduleAddresses)
-        {
-            region.Trace();
-        }
-    }
-    if (minidumpType & MiniDumpWithFullMemory)
-    {
-        for (const MemoryRegion& region : m_moduleMappings)
-        {
-            InsertMemoryRegion(region);
-        }
-        for (const MemoryRegion& region : m_otherMappings)
-        {
-            if ((region.Permissions() & (PF_R | PF_W | PF_X)) != 0)
-            {
-                InsertMemoryRegion(region);
-            }
-        }
-    }
-    else
-    {
-        if (minidumpType & MiniDumpWithPrivateReadWriteMemory)
-        {
-            for (const MemoryRegion& region : m_otherMappings)
-            {
-                uint32_t permissions = region.Permissions();
-#ifdef __APPLE__
-                if (permissions == (PF_R | PF_W))
-#else
-                if (permissions == (PF_R | PF_W) || permissions == (PF_R | PF_W | PF_X))
-#endif
-                {
-                    InsertMemoryRegion(region);
-                }
-            }
-        }
-        for (ThreadInfo* thread : m_threads)
-        {
-            thread->GetThreadStack();
-        }
-    }
-    return true;
-}
-static const char*
-GetHResultString(HRESULT hr)
-{
-    switch (hr)
-    {
-        case E_FAIL:
-            return "The operation has failed";
-        case E_INVALIDARG:
-            return "Invalid argument";
-        case E_OUTOFMEMORY:
-            return "Out of memory";
-        case CORDBG_E_INCOMPATIBLE_PLATFORMS:
-            return "The operation failed because debuggee and debugger are on incompatible platforms";
-        case CORDBG_E_MISSING_DEBUGGER_EXPORTS:
-            return "The debuggee memory space does not have the expected debugging export table";
-        case CORDBG_E_UNSUPPORTED:
-            return "The specified action is unsupported by this version of the runtime";
-    }
-    return "";
-}
-bool
-CrashInfo::InitializeDAC()
-{
-    ReleaseHolder<DumpDataTarget> dataTarget = new DumpDataTarget(*this);
-    PFN_CLRDataCreateInstance pfnCLRDataCreateInstance = nullptr;
-    bool result = false;
-    HRESULT hr = S_OK;
-    if (!m_coreclrPath.empty())
-    {
-        std::string dacPath;
-        dacPath.append(m_coreclrPath);
-        dacPath.append(MAKEDLLNAME_A("mscordaccore"));
-        m_hdac = LoadLibraryA(dacPath.c_str());
-        if (m_hdac == nullptr)
-        {
-            printf_error("InitializeDAC: LoadLibraryA(%s) FAILED %s\n", dacPath.c_str(), GetLastErrorString().c_str());
-            goto exit;
-        }
-        pfnCLRDataCreateInstance = (PFN_CLRDataCreateInstance)GetProcAddress(m_hdac, "CLRDataCreateInstance");
-        if (pfnCLRDataCreateInstance == nullptr)
-        {
-            printf_error("InitializeDAC: GetProcAddress(CLRDataCreateInstance) FAILED %s\n", GetLastErrorString().c_str());
-            goto exit;
-        }
-        hr = pfnCLRDataCreateInstance(__uuidof(ICLRDataEnumMemoryRegions), dataTarget, (void**)&m_pClrDataEnumRegions);
-        if (FAILED(hr))
-        {
-            printf_error("InitializeDAC: CLRDataCreateInstance(ICLRDataEnumMemoryRegions) FAILED %s (%08x)\n", GetHResultString(hr), hr);
-            goto exit;
-        }
-        hr = pfnCLRDataCreateInstance(__uuidof(IXCLRDataProcess), dataTarget, (void**)&m_pClrDataProcess);
-        if (FAILED(hr))
-        {
-            printf_error("InitializeDAC: CLRDataCreateInstance(IXCLRDataProcess) FAILED %s (%08x)\n", GetHResultString(hr), hr);
-            goto exit;
-        }
-    }
-    else
-    {
-        printf_error("InitializeDAC: coreclr not found; not using DAC\n");
-    }
-    result = true;
-exit:
-    return result;
-}
-bool
-CrashInfo::EnumerateMemoryRegionsWithDAC(MINIDUMP_TYPE minidumpType)
-{
-    if (m_pClrDataEnumRegions != nullptr && (minidumpType & MiniDumpWithFullMemory) == 0)
-    {
-        TRACE("EnumerateMemoryRegionsWithDAC: Memory enumeration STARTED (%d %d)\n", m_enumMemoryPagesAdded, m_dataTargetPagesAdded);
-        CLRDataEnumMemoryFlags flags = CLRDATA_ENUM_MEM_DEFAULT;
-        if (minidumpType & MiniDumpWithPrivateReadWriteMemory)
-        {
-            CLRConfigNoCache fastHeapDumps = CLRConfigNoCache::Get("DbgEnableFastHeapDumps", /*noprefix*/ false, &getenv);
-            DWORD val = 0;
-            if (fastHeapDumps.IsSet() && fastHeapDumps.TryAsInteger(10, val) && val == 1)
-            {
-                minidumpType = MiniDumpNormal;
-            }
-            fastHeapDumps = CLRConfigNoCache::Get("EnableFastHeapDumps", /*noprefix*/ false, &getenv);
-            if (fastHeapDumps.IsSet() && fastHeapDumps.TryAsInteger(10, val) && val == 1)
-            {
-                flags = CLRDATA_ENUM_MEM_HEAP2;
-            }
-        }
-        HRESULT hr = m_pClrDataEnumRegions->EnumMemoryRegions(this, minidumpType, flags);
-        if (FAILED(hr))
-        {
-            printf_error("EnumMemoryRegions FAILED %s (%08x)\n", GetHResultString(hr), hr);
-            return false;
-        }
-        TRACE("EnumerateMemoryRegionsWithDAC: Memory enumeration FINISHED (%d %d)\n", m_enumMemoryPagesAdded, m_dataTargetPagesAdded);
-    }
-    return true;
-}
-bool
-CrashInfo::EnumerateManagedModules()
-{
-    CLRDATA_ENUM enumModules = 0;
-    HRESULT hr = S_OK;
-    if (m_pClrDataProcess != nullptr)
-    {
-        TRACE("EnumerateManagedModules: Module enumeration STARTED (%d)\n", m_dataTargetPagesAdded);
-        if (FAILED(hr = m_pClrDataProcess->StartEnumModules(&enumModules))) {
-            printf_error("StartEnumModules FAILED %s (%08x)\n", GetHResultString(hr), hr);
-            return false;
-        }
-        while (true)
-        {
-            ReleaseHolder<IXCLRDataModule> pClrDataModule;
-            if ((hr = m_pClrDataProcess->EnumModule(&enumModules, &pClrDataModule)) != S_OK) {
-                break;
-            }
-            ULONG32 flags;
-            if ((hr = pClrDataModule->GetFlags(&flags)) != S_OK) {
-                TRACE("MODULE: GetFlags FAILED %08x\n", hr);
-                continue;
-            }
-            if (flags & CLRDATA_MODULE_IS_DYNAMIC) {
-                TRACE("MODULE: Skipping dynamic module\n");
-                continue;
-            }
-            DacpGetModuleData moduleData;
-            if (SUCCEEDED(hr = moduleData.Request(pClrDataModule.GetPtr())))
-            {
-                TRACE("MODULE: %" PRIA PRIx64 " dyn %d inmem %d file %d pe %" PRIA PRIx64 " pdb %" PRIA PRIx64, (uint64_t)moduleData.LoadedPEAddress, moduleData.IsDynamic,
-                    moduleData.IsInMemory, moduleData.IsFileLayout, (uint64_t)moduleData.PEAssembly, (uint64_t)moduleData.InMemoryPdbAddress);
-                if (!moduleData.IsDynamic && moduleData.LoadedPEAddress != 0)
-                {
-                    ArrayHolder<WCHAR> wszUnicodeName = new WCHAR[MAX_LONGPATH + 1];
-                    if (SUCCEEDED(hr = pClrDataModule->GetFileName(MAX_LONGPATH, nullptr, wszUnicodeName)))
-                    {
-                        std::string moduleName = FormatString("%S", wszUnicodeName.GetPtr());
-                        AddOrReplaceModuleMapping(moduleData.LoadedPEAddress, moduleData.LoadedPESize, moduleName);
-                        AddModuleInfo(true, moduleData.LoadedPEAddress, pClrDataModule, moduleName);
-                    }
-                    else {
-                        TRACE("\nModule.GetFileName FAILED %08x\n", hr);
-                    }
-                }
-                else {
-                    TRACE("\n");
-                }
-            }
-            else {
-                TRACE("moduleData.Request FAILED %08x\n", hr);
-            }
-        }
-        if (enumModules != 0) {
-            m_pClrDataProcess->EndEnumModules(enumModules);
-        }
-        TRACE("EnumerateManagedModules: Module enumeration FINISHED (%d) ModuleMappings %06llx\n", m_dataTargetPagesAdded, m_cbModuleMappings / PAGE_SIZE);
-    }
-    return true;
-}
-bool
-CrashInfo::UnwindAllThreads()
-{
-    TRACE("UnwindAllThreads: STARTED (%d)\n", m_dataTargetPagesAdded);
-    ReleaseHolder<ISOSDacInterface> pSos = nullptr;
-    if (m_pClrDataProcess != nullptr) {
-        m_pClrDataProcess->QueryInterface(__uuidof(ISOSDacInterface), (void**)&pSos);
-    }
-    for (ThreadInfo* thread : m_threads)
-    {
-        if (!thread->UnwindThread(m_pClrDataProcess, pSos)) {
-            return false;
-        }
-    }
-    TRACE("UnwindAllThreads: FINISHED (%d)\n", m_dataTargetPagesAdded);
-    return true;
-}
-void
-CrashInfo::AddOrReplaceModuleMapping(CLRDATA_ADDRESS baseAddress, ULONG64 size, const std::string& name)
-{
-    ULONG_PTR start = ((ULONG_PTR)baseAddress) & PAGE_MASK;
-    assert(start > 0);
-    ULONG_PTR end = ((baseAddress + size) + (PAGE_SIZE - 1)) & PAGE_MASK;
-    assert(end > 0);
-    uint32_t flags = GetMemoryRegionFlags((ULONG_PTR)baseAddress);
-    MemoryRegion header(flags, start, start + PAGE_SIZE);
-    InsertMemoryRegion(header);
-    const auto& found = m_moduleMappings.find(header);
-    if (found == m_moduleMappings.end())
-    {
-        MemoryRegion newRegion(flags, start, end, 0, name);
-        m_moduleMappings.insert(newRegion);
-        m_cbModuleMappings += newRegion.Size();
-        if (g_diagnostics) {
-            newRegion.Trace("MODULE: ADD ");
-        }
-    }
-    else if (found->FileName().compare(name) != 0)
-    {
-        MemoryRegion newRegion(*found, name);
-        m_moduleMappings.erase(found);
-        m_cbModuleMappings -= found->Size();
-        m_moduleMappings.insert(newRegion);
-        m_cbModuleMappings += newRegion.Size();
-        if (g_diagnostics) {
-            newRegion.Trace("MODULE: REPLACE ");
-        }
-    }
-}
-uint64_t
-CrashInfo::GetBaseAddressFromAddress(uint64_t address)
-{
-    MemoryRegion search(0, address, address, 0);
-    const MemoryRegion* found = SearchMemoryRegions(m_moduleAddresses, search);
-    if (found == nullptr) {
-        return 0;
-    }
-    return found->Offset();
-}
-uint64_t
-CrashInfo::GetBaseAddressFromName(const char* moduleName)
-{
-    for (const ModuleInfo* moduleInfo : m_moduleInfos)
-    {
-        std::string name = GetFileName(moduleInfo->ModuleName());
-#ifdef __APPLE__
-        if (strcasecmp(name.c_str(), moduleName) == 0)
-#else
-        if (name.compare(moduleName) == 0)
-#endif
-        {
-            return moduleInfo->BaseAddress();
-        }
-    }
-    return 0;
-}
-ModuleInfo*
-CrashInfo::GetModuleInfoFromBaseAddress(uint64_t baseAddress)
-{
-    ModuleInfo search(baseAddress);
-    const auto& found = m_moduleInfos.find(&search);
-    if (found != m_moduleInfos.end())
-    {
-        return *found;
-    }
-    return nullptr;
-}
-void
-CrashInfo::AddModuleAddressRange(uint64_t startAddress, uint64_t endAddress, uint64_t baseAddress)
-{
-    MemoryRegion region(0, startAddress, endAddress, baseAddress);
-    m_moduleAddresses.insert(region);
-}
-void
-CrashInfo::AddModuleInfo(bool isManaged, uint64_t baseAddress, IXCLRDataModule* pClrDataModule, const std::string& moduleName)
-{
-    ModuleInfo moduleInfo(baseAddress);
-    const auto& found = m_moduleInfos.find(&moduleInfo);
-    if (found == m_moduleInfos.end())
-    {
-        uint32_t timeStamp = 0;
-        uint32_t imageSize = 0;
-        bool isMainModule = false;
-        GUID mvid;
-        if (isManaged)
-        {
-            IMAGE_DOS_HEADER dosHeader;
-            if (ReadMemory((void*)baseAddress, &dosHeader, sizeof(dosHeader)))
-            {
-                WORD magic;
-                if (ReadMemory((void*)(baseAddress + dosHeader.e_lfanew + offsetof(IMAGE_NT_HEADERS, OptionalHeader.Magic)), &magic, sizeof(magic)))
-                {
-                    if (magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
-                    {
-                        IMAGE_NT_HEADERS32 header;
-                        if (ReadMemory((void*)(baseAddress + dosHeader.e_lfanew), &header, sizeof(header)))
-                        {
-                            imageSize = header.OptionalHeader.SizeOfImage;
-                            timeStamp = header.FileHeader.TimeDateStamp;
-                        }
-                    }
-                    else if (magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
-                    {
-                        IMAGE_NT_HEADERS64 header;
-                        if (ReadMemory((void*)(baseAddress + dosHeader.e_lfanew), &header, sizeof(header)))
-                        {
-                            imageSize = header.OptionalHeader.SizeOfImage;
-                            timeStamp = header.FileHeader.TimeDateStamp;
-                        }
-                    }
-                }
-            }
-            if (pClrDataModule != nullptr)
-            {
-                ULONG32 flags = 0;
-                pClrDataModule->GetFlags(&flags);
-                isMainModule = (flags & CLRDATA_MODULE_IS_MAIN_MODULE) != 0;
-                pClrDataModule->GetVersionId(&mvid);
-            }
-            TRACE("MODULE: timestamp %08x size %08x %s %s%s\n", timeStamp, imageSize, FormatGuid(&mvid).c_str(), isMainModule ? "*" : "", moduleName.c_str());
-        }
-        ModuleInfo* moduleInfo = new ModuleInfo(isManaged, baseAddress, timeStamp, imageSize, &mvid, moduleName);
-        if (isMainModule) {
-            m_mainModule = moduleInfo;
-        }
-        m_moduleInfos.insert(moduleInfo);
-    }
-}
-bool
-CrashInfo::ReadMemory(void* address, void* buffer, size_t size)
-{
-    size_t read = 0;
-    if (!ReadProcessMemory(address, buffer, size, &read))
-    {
-        return false;
-    }
-    assert(read == size);
-    InsertMemoryRegion(reinterpret_cast<uint64_t>(address), read);
-    return true;
-}
-int
-CrashInfo::InsertMemoryRegion(uint64_t address, size_t size)
-{
-    assert(size < UINT_MAX);
-    uint64_t start = address & PAGE_MASK;
-    assert(start > 0);
-    uint64_t end = ((address + size) + (PAGE_SIZE - 1)) & PAGE_MASK;
-    assert(end > 0);
-    return InsertMemoryRegion(MemoryRegion(GetMemoryRegionFlags(start), start, end));
-}
-int
-CrashInfo::InsertMemoryRegion(const MemoryRegion& region)
-{
-    const auto& found = m_memoryRegions.find(region);
-    if (found == m_memoryRegions.end())
-    {
-        if (ValidRegion(region))
-        {
-            m_memoryRegions.insert(region);
-            return region.SizeInPages();
-        }
-    }
-    else
-    {
-        if (found->Contains(region))
-        {
-            return 0;
-        }
-    }
-    uint64_t start = region.StartAddress();
-    uint64_t numberPages = region.SizeInPages();
-    int pagesAdded = 0;
-    for (size_t p = 0; p < numberPages; p++, start += PAGE_SIZE)
-    {
-        MemoryRegion memoryRegionPage(region.Flags(), start, start + PAGE_SIZE);
-        const auto& found = m_memoryRegions.find(memoryRegionPage);
-        if (found == m_memoryRegions.end())
-        {
-            if (ValidRegion(memoryRegionPage))
-            {
-                m_memoryRegions.insert(memoryRegionPage);
-                pagesAdded++;
-            }
-        }
-    }
-    return pagesAdded;
-}
-bool
-CrashInfo::ValidRegion(const MemoryRegion& region)
-{
-    uint64_t start = region.StartAddress();
-    uint64_t numberPages = region.SizeInPages();
-    for (size_t p = 0; p < numberPages; p++, start += PAGE_SIZE)
-    {
-        BYTE buffer[1];
-        size_t read;
-        if (!ReadProcessMemory((void*)start, buffer, 1, &read))
-        {
-            return false;
-        }
-    }
-    return true;
-}
-void
-CrashInfo::CombineMemoryRegions()
-{
-    TRACE("CombineMemoryRegions: STARTED\n");
-    assert(!m_memoryRegions.empty());
-    std::set<MemoryRegion> memoryRegionsNew;
-    uint32_t flags = m_memoryRegions.begin()->Flags() & MEMORY_REGION_FLAG_PERMISSIONS_MASK;
-    uint64_t start = m_memoryRegions.begin()->StartAddress();
-    uint64_t end = start;
-    for (const MemoryRegion& region : m_memoryRegions)
-    {
-        if ((end == region.StartAddress()) &&
-            (flags == (region.Flags() & MEMORY_REGION_FLAG_PERMISSIONS_MASK)))
-        {
-            end = region.EndAddress();
-        }
-        else
-        {
-            MemoryRegion memoryRegion(flags, start, end);
-            assert(memoryRegionsNew.find(memoryRegion) == memoryRegionsNew.end());
-            memoryRegionsNew.insert(memoryRegion);
-            flags = region.Flags() & MEMORY_REGION_FLAG_PERMISSIONS_MASK;
-            start = region.StartAddress();
-            end = region.EndAddress();
-        }
-    }
-    assert(start != end);
-    MemoryRegion memoryRegion(flags, start, end);
-    assert(memoryRegionsNew.find(memoryRegion) == memoryRegionsNew.end());
-    memoryRegionsNew.insert(memoryRegion);
-    m_memoryRegions = memoryRegionsNew;
-    TRACE("CombineMemoryRegions: FINISHED\n");
-    if (g_diagnosticsVerbose)
-    {
-        TRACE("Final Memory Regions:\n");
-        for (const MemoryRegion& region : m_memoryRegions)
-        {
-            region.Trace();
-        }
-    }
-}
-const MemoryRegion*
-CrashInfo::SearchMemoryRegions(const std::set<MemoryRegion>& regions, const MemoryRegion& search)
-{
-    std::set<MemoryRegion>::iterator found = regions.find(search);
-    for (; found != regions.end(); found++)
-    {
-        if (search.StartAddress() >= found->StartAddress() && search.StartAddress() < found->EndAddress())
-        {
-            return &*found;
-        }
-    }
-    return nullptr;
-}
-const char*
-ModuleInfo::GetSymbolName(uint64_t address)
-{
-    LoadModule();
-    if (m_localBaseAddress != 0)
-    {
-        uint64_t localAddress = m_localBaseAddress + (address - m_baseAddress);
-        Dl_info info;
-        if (dladdr((void*)localAddress, &info) != 0)
-        {
-            if (info.dli_sname != nullptr)
-            {
-                int status = -1;
-                char *demangled = abi::__cxa_demangle(info.dli_sname, nullptr, 0, &status);
-                return status == 0 ? demangled : strdup(info.dli_sname);
-            }
-        }
-    }
-    return nullptr;
-}
-const std::string
-GetFileName(const std::string& fileName)
-{
-    size_t last = fileName.rfind(DIRECTORY_SEPARATOR_STR_A);
-    if (last != std::string::npos) {
-        last++;
-    }
-    else {
-        last = 0;
-    }
-    return fileName.substr(last);
-}
-const std::string
-GetDirectory(const std::string& fileName)
-{
-    size_t last = fileName.rfind(DIRECTORY_SEPARATOR_STR_A);
-    if (last != std::string::npos) {
-        last++;
-    }
-    else {
-        last = 0;
-    }
-    return fileName.substr(0, last);
-}
-std::string
-FormatString(const char* format, ...)
-{
-    ArrayHolder<char> buffer = new char[MAX_LONGPATH + 1];
-    va_list args;
-    va_start(args, format);
-    int result = vsprintf_s(buffer, MAX_LONGPATH, format, args);
-    va_end(args);
-    return result > 0 ? std::string(buffer) : std::string();
-}
-std::string
-FormatGuid(const GUID* guid)
-{
-    uint8_t* bytes = (uint8_t*)guid;
-    return FormatString("%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
-        bytes[3], bytes[2], bytes[1], bytes[0], bytes[5], bytes[4], bytes[7], bytes[6], bytes[8], bytes[9], bytes[10], bytes[11], bytes[12], bytes[13], bytes[14], bytes[15]);
-}

--- a/src/coreclr/debug/createdump/crashinfo.h
+++ b//dev/null
@@ -1,140 +0,0 @@
-#ifdef __APPLE__
-#include "../dbgutil/machoreader.h"
-#else
-#include "../dbgutil/elfreader.h"
-#if TARGET_64BIT
-typedef Elf64_auxv_t elf_aux_entry;
-#define PRIx PRIx64
-#define PRIu PRIu64
-#define PRId PRId64
-#define PRIA "016"
-#define PRIxA PRIA PRIx
-#else
-typedef Elf32_auxv_t elf_aux_entry;
-#define PRIx PRIx32
-#define PRIu PRIu32
-#define PRId PRId32
-#define PRIA "08"
-#define PRIxA PRIA PRIx
-#endif
-typedef __typeof__(((elf_aux_entry*) 0)->a_un.a_val) elf_aux_val_t;
-#define AT_MAX (AT_SYSINFO_EHDR + 1)
-#endif
-extern const std::string GetFileName(const std::string& fileName);
-extern const std::string GetDirectory(const std::string& fileName);
-extern std::string FormatString(const char* format, ...);
-extern std::string FormatGuid(const GUID* guid);
-class CrashInfo : public ICLRDataEnumMemoryRegionsCallback, public ICLRDataLoggingCallback,
-#ifdef __APPLE__
-    public MachOReader
-#else
-    public ElfReader
-#endif
-{
-private:
-    LONG m_ref;                                     // reference count
-    pid_t m_pid;                                    // pid
-    pid_t m_ppid;                                   // parent pid
-    pid_t m_tgid;                                   // process group
-    HMODULE m_hdac;                                 // dac module handle when loaded
-    ICLRDataEnumMemoryRegions* m_pClrDataEnumRegions; // dac enumerate memory interface instance
-    IXCLRDataProcess* m_pClrDataProcess;            // dac process interface instance
-    bool m_gatherFrames;                            // if true, add the native and managed stack frames to the thread info
-    pid_t m_crashThread;                            // crashing thread id or 0 if none
-    uint32_t m_signal;                              // crash signal code or 0 if none
-    std::string m_name;                             // exe name
-#ifdef __APPLE__
-    vm_map_t m_task;                                // the mach task for the process
-#else
-    siginfo_t m_siginfo;                            // signal info (if any)
-    bool m_canUseProcVmReadSyscall;
-    int m_fd;                                       // /proc/<pid>/mem handle
-#endif
-    std::string m_coreclrPath;                      // the path of the coreclr module or empty if none
-    uint64_t m_runtimeBaseAddress;
-#ifdef __APPLE__
-    std::set<MemoryRegion> m_allMemoryRegions;      // all memory regions on MacOS
-#else
-    std::array<elf_aux_val_t, AT_MAX> m_auxvValues; // auxv values
-    std::vector<elf_aux_entry> m_auxvEntries;       // full auxv entries
-#endif
-    std::vector<ThreadInfo*> m_threads;             // threads found and suspended
-    std::set<MemoryRegion> m_moduleMappings;        // module memory mappings
-    std::set<MemoryRegion> m_otherMappings;         // other memory mappings
-    std::set<MemoryRegion> m_memoryRegions;         // memory regions from DAC, etc.
-    std::set<MemoryRegion> m_moduleAddresses;       // memory region to module base address
-    std::set<ModuleInfo*, bool (*)(const ModuleInfo* lhs, const ModuleInfo* rhs)> m_moduleInfos; // module infos (base address and module name)
-    ModuleInfo* m_mainModule;                       // the module containing "Main"
-    CrashInfo(const CrashInfo&) = delete;
-    void operator=(const CrashInfo&) = delete;
-public:
-    CrashInfo(const CreateDumpOptions& options);
-    virtual ~CrashInfo();
-    uint64_t m_cbModuleMappings;
-    int m_dataTargetPagesAdded;
-    int m_enumMemoryPagesAdded;
-    bool Initialize();
-    void CleanupAndResumeProcess();
-    bool EnumerateAndSuspendThreads();
-    bool GatherCrashInfo(MINIDUMP_TYPE minidumpType);
-    void CombineMemoryRegions();
-    bool EnumerateMemoryRegionsWithDAC(MINIDUMP_TYPE minidumpType);
-    bool ReadMemory(void* address, void* buffer, size_t size);                          // read memory and add to dump
-    bool ReadProcessMemory(void* address, void* buffer, size_t size, size_t* read);     // read raw memory
-    uint64_t GetBaseAddressFromAddress(uint64_t address);
-    uint64_t GetBaseAddressFromName(const char* moduleName);
-    ModuleInfo* GetModuleInfoFromBaseAddress(uint64_t baseAddress);
-    void AddModuleAddressRange(uint64_t startAddress, uint64_t endAddress, uint64_t baseAddress);
-    void AddModuleInfo(bool isManaged, uint64_t baseAddress, IXCLRDataModule* pClrDataModule, const std::string& moduleName);
-    int InsertMemoryRegion(uint64_t address, size_t size);
-    static const MemoryRegion* SearchMemoryRegions(const std::set<MemoryRegion>& regions, const MemoryRegion& search);
-    inline pid_t Pid() const { return m_pid; }
-    inline pid_t Ppid() const { return m_ppid; }
-    inline pid_t Tgid() const { return m_tgid; }
-#ifdef __APPLE__
-    inline vm_map_t Task() const { return m_task; }
-#endif
-    inline const bool GatherFrames() const { return m_gatherFrames; }
-    inline const pid_t CrashThread() const { return m_crashThread; }
-    inline const uint32_t Signal() const { return m_signal; }
-    inline const std::string& Name() const { return m_name; }
-    inline const ModuleInfo* MainModule() const { return m_mainModule; }
-    inline const uint64_t RuntimeBaseAddress() const { return m_runtimeBaseAddress; }
-    inline const std::vector<ThreadInfo*>& Threads() const { return m_threads; }
-    inline const std::set<MemoryRegion>& ModuleMappings() const { return m_moduleMappings; }
-    inline const std::set<MemoryRegion>& OtherMappings() const { return m_otherMappings; }
-    inline const std::set<MemoryRegion>& MemoryRegions() const { return m_memoryRegions; }
-#ifndef __APPLE__
-    inline const std::vector<elf_aux_entry>& AuxvEntries() const { return m_auxvEntries; }
-    inline size_t GetAuxvSize() const { return m_auxvEntries.size() * sizeof(elf_aux_entry); }
-    inline const siginfo_t* SigInfo() const { return &m_siginfo; }
-#endif
-    STDMETHOD(QueryInterface)(___in REFIID InterfaceId, ___out PVOID* Interface);
-    STDMETHOD_(ULONG, AddRef)();
-    STDMETHOD_(ULONG, Release)();
-    virtual HRESULT STDMETHODCALLTYPE EnumMemoryRegion(/* [in] */ CLRDATA_ADDRESS address, /* [in] */ ULONG32 size);
-    virtual HRESULT STDMETHODCALLTYPE LogMessage( /* [in] */ LPCSTR message);
-private:
-#ifdef __APPLE__
-    bool EnumerateMemoryRegions();
-    void InitializeOtherMappings();
-    void VisitModule(MachOModule& module);
-    void VisitSegment(MachOModule& module, const segment_command_64& segment);
-    void VisitSection(MachOModule& module, const section_64& section);
-#else
-    bool GetAuxvEntries();
-    bool GetDSOInfo();
-    void VisitModule(uint64_t baseAddress, std::string& moduleName);
-    void VisitProgramHeader(uint64_t loadbias, uint64_t baseAddress, ElfW(Phdr)* phdr);
-    bool EnumerateMemoryRegions();
-#endif
-    bool InitializeDAC();
-    bool EnumerateManagedModules();
-    bool UnwindAllThreads();
-    void AddOrReplaceModuleMapping(CLRDATA_ADDRESS baseAddress, ULONG64 size, const std::string& pszName);
-    int InsertMemoryRegion(const MemoryRegion& region);
-    uint32_t GetMemoryRegionFlags(uint64_t start);
-    bool ValidRegion(const MemoryRegion& region);
-    void Trace(const char* format, ...);
-    void TraceVerbose(const char* format, ...);
-};

--- a/src/coreclr/debug/createdump/crashreportwriter.cpp
+++ b//dev/null
@@ -1,366 +0,0 @@
-#include "createdump.h"
-#include "_version.c"
-CrashReportWriter::CrashReportWriter(CrashInfo& crashInfo) :
-    m_crashInfo(crashInfo)
-{
-    m_fd = -1;
-    m_indent = JSON_INDENT_VALUE;
-    m_comma = false;
-    m_crashInfo.AddRef();
-}
-CrashReportWriter::~CrashReportWriter()
-{
-    m_crashInfo.Release();
-    if (m_fd != -1)
-    {
-        close(m_fd);
-        m_fd = -1;
-    }
-}
-void
-CrashReportWriter::WriteCrashReport(const std::string& dumpFileName)
-{
-    std::string crashReportFile(dumpFileName);
-    crashReportFile.append(".crashreport.json");
-    printf_status("Writing crash report to file %s\n", crashReportFile.c_str());
-    try
-    {
-        if (!OpenWriter(crashReportFile.c_str())) {
-            return;
-        }
-        WriteCrashReport();
-        CloseWriter();
-        printf_status("Crash report successfully written\n");
-    }
-    catch (const std::exception& e)
-    {
-        printf_error("Writing the crash report file FAILED\n");
-        remove(crashReportFile.c_str());
-    }
-}
-void
-CrashReportWriter::WriteCrashReport()
-{
-    OpenObject("payload");
-    WriteValue("protocol_version", "1.0.0");
-    OpenObject("configuration");
-#if defined(__x86_64__)
-    WriteValue("architecture", "amd64");
-#elif defined(__aarch64__)
-    WriteValue("architecture", "arm64");
-#elif defined(__arm__)
-    WriteValue("architecture", "arm");
-#endif
-    std::string version;
-    assert(strncmp(sccsid, "@(#)Version ", 12) == 0);
-    version.append(sccsid + 12);    // skip "@(#)Version "
-    version.append(" ");            // the analyzer requires a space after the version
-    WriteValue("version", version.c_str());
-    CloseObject();                  // configuration
-    const ModuleInfo* mainModule = m_crashInfo.MainModule();
-    if (mainModule != nullptr && mainModule->BaseAddress() != 0)
-    {
-        WriteValue("process_name", GetFileName(mainModule->ModuleName()).c_str());
-    }
-    const char* exceptionType = nullptr;
-    OpenArray("threads");
-    for (const ThreadInfo* thread : m_crashInfo.Threads())
-    {
-        OpenObject();
-        bool crashed = false;
-        if (thread->Tid() == m_crashInfo.CrashThread())
-        {
-            crashed = true;
-            if (thread->ManagedExceptionObject() != 0)
-            {
-                exceptionType = "0x05000000";   // ManagedException
-            }
-            else
-            {
-                switch (m_crashInfo.Signal())
-                {
-                case 0:
-                    break;
-                case SIGILL:
-                    exceptionType = "0x50000000";
-                    break;
-                case SIGFPE:
-                    exceptionType = "0x70000000";
-                    break;
-                case SIGBUS:
-                    exceptionType = "0x60000000";
-                    break;
-                case SIGTRAP:
-                    exceptionType = "0x03000000";
-                    break;
-                case SIGSEGV:
-                    exceptionType = "0x20000000";
-                    break;
-                case SIGTERM:
-                    exceptionType = "0x02000000";
-                    break;
-                case SIGABRT:
-                    exceptionType = "0x30000000";
-                    break;
-                default:
-                    exceptionType = "0x00000000";
-                    break;
-                }
-            }
-        }
-        WriteValueBool("is_managed", thread->IsManaged());
-        WriteValueBool("crashed", crashed);
-        if (thread->ManagedExceptionObject() != 0)
-        {
-            WriteValue64("managed_exception_object", thread->ManagedExceptionObject());
-        }
-        if (!thread->ManagedExceptionType().empty())
-        {
-            WriteValue("managed_exception_type", thread->ManagedExceptionType().c_str());
-        }
-        if (thread->ManagedExceptionHResult() != 0)
-        {
-            WriteValue32("managed_exception_hresult", thread->ManagedExceptionHResult());
-        }
-        WriteValue64("native_thread_id", thread->Tid());
-        OpenObject("ctx");
-        WriteValue64("IP", thread->GetInstructionPointer());
-        WriteValue64("SP", thread->GetStackPointer());
-        WriteValue64("BP", thread->GetFramePointer());
-        CloseObject();          // ctx
-        OpenArray("stack_frames");
-        for (auto iterator = thread->StackFrames().cbegin(); iterator != thread->StackFrames().cend(); ++iterator)
-        {
-            if (thread->IsBeginRepeat(iterator))
-            {
-                OpenObject();
-                WriteValue32("repeated", thread->NumRepeatedFrames());
-                OpenArray("repeated_frames");
-            }
-            if (thread->IsEndRepeat(iterator))
-            {
-                CloseArray();   // repeated_frames
-                CloseObject();
-            }
-            WriteStackFrame(*iterator);
-        }
-        CloseArray();           // stack_frames
-        CloseObject();
-    }
-    CloseArray();               // threads
-    CloseObject();              // payload
-    OpenObject("parameters");
-    if (exceptionType != nullptr)
-    {
-        WriteValue("ExceptionType", exceptionType);
-    }
-#ifdef __APPLE__
-    WriteSysctl("kern.osproductversion", "OSVersion");
-    WriteSysctl("hw.model", "SystemModel");
-    WriteValue("SystemManufacturer", "apple");
-#endif // __APPLE__
-    CloseObject();              // parameters
-}
-#ifdef __APPLE__
-void
-CrashReportWriter::WriteSysctl(const char* sysctlname, const char* valueName)
-{
-    size_t size = 0;
-    if (sysctlbyname(sysctlname, nullptr, &size, NULL, 0) >= 0)
-    {
-        ArrayHolder<char> buffer = new char[size];
-        if (sysctlbyname(sysctlname, buffer, &size, NULL, 0) >= 0)
-        {
-            WriteValue(valueName, buffer);
-        }
-        else
-        {
-            TRACE("sysctlbyname(%s) 1 FAILED %s\n", sysctlname, strerror(errno));
-        }
-    }
-    else
-    {
-        TRACE("sysctlbyname(%s) 2 FAILED %s\n", sysctlname, strerror(errno));
-    }
-}
-#endif // __APPLE__
-void
-CrashReportWriter::WriteStackFrame(const StackFrame& frame)
-{
-    OpenObject();
-    WriteValueBool("is_managed", frame.IsManaged());
-    WriteValue64("module_address", frame.ModuleAddress());
-    WriteValue64("stack_pointer", frame.StackPointer());
-    WriteValue64("native_address", frame.InstructionPointer());
-    WriteValue64("native_offset", frame.NativeOffset());
-    if (frame.IsManaged())
-    {
-        WriteValue32("token", frame.Token());
-        WriteValue32("il_offset", frame.ILOffset());
-    }
-    IXCLRDataMethodInstance* pMethod = frame.GetMethod();
-    if (pMethod != nullptr)
-    {
-        ArrayHolder<WCHAR> wszUnicodeName = new WCHAR[MAX_LONGPATH + 1];
-        if (SUCCEEDED(pMethod->GetName(0, MAX_LONGPATH, nullptr, wszUnicodeName)))
-        {
-            std::string methodName = FormatString("%S", wszUnicodeName.GetPtr());
-            WriteValue("method_name", methodName.c_str());
-        }
-    }
-    if (frame.ModuleAddress() != 0)
-    {
-        ModuleInfo* moduleInfo = m_crashInfo.GetModuleInfoFromBaseAddress(frame.ModuleAddress());
-        if (moduleInfo != nullptr)
-        {
-            std::string moduleName = GetFileName(moduleInfo->ModuleName());
-            if (frame.IsManaged())
-            {
-                WriteValue32("timestamp", moduleInfo->TimeStamp());
-                WriteValue32("sizeofimage", moduleInfo->ImageSize());
-                WriteValue("filename", moduleName.c_str());
-                WriteValue("guid", FormatGuid(moduleInfo->Mvid()).c_str());
-            }
-            else
-            {
-                const char* symbol = moduleInfo->GetSymbolName(frame.InstructionPointer());
-                if (symbol != nullptr)
-                {
-                    WriteValue("unmanaged_name", symbol);
-                    free((void*)symbol);
-                }
-                WriteValue("native_module", moduleName.c_str());
-            }
-        }
-    }
-    CloseObject();
-}
-bool
-CrashReportWriter::OpenWriter(const char* fileName)
-{
-    m_fd = open(fileName, O_WRONLY|O_CREAT|O_TRUNC, S_IWUSR | S_IRUSR);
-    if (m_fd == -1)
-    {
-        printf_error("Could not create json file '%s': %s (%d)\n", fileName, strerror(errno), errno);
-        return false;
-    }
-    Write("{\n");
-    return true;
-}
-void
-CrashReportWriter::CloseWriter()
-{
-    assert(m_indent == JSON_INDENT_VALUE);
-    Write("\n}\n");
-}
-void
-CrashReportWriter::Write(const std::string& text)
-{
-    if (!DumpWriter::WriteData(m_fd, (void*)text.c_str(), text.length()))
-    {
-        throw std::exception();
-    }
-}
-void
-CrashReportWriter::Write(const char* buffer)
-{
-    std::string text(buffer);
-    Write(text);
-}
-void
-CrashReportWriter::Indent(std::string& text)
-{
-    assert(m_indent >= 0);
-    text.append(m_indent, ' ');
-}
-void
-CrashReportWriter::WriteSeparator(std::string& text)
-{
-    if (m_comma)
-    {
-        text.append(1, ',');
-        text.append(1, '\n');
-    }
-    Indent(text);
-}
-void
-CrashReportWriter::OpenValue(const char* key, char marker)
-{
-    std::string text;
-    WriteSeparator(text);
-    if (key != nullptr)
-    {
-        text.append("\"");
-        text.append(key);
-        text.append("\" : ");
-    }
-    text.append(1, marker);
-    text.append(1, '\n');
-    m_comma = false;
-    m_indent += JSON_INDENT_VALUE;
-    Write(text);
-}
-void
-CrashReportWriter::CloseValue(char marker)
-{
-    std::string text;
-    text.append(1, '\n');
-    assert(m_indent >= JSON_INDENT_VALUE);
-    m_indent -= JSON_INDENT_VALUE;
-    Indent(text);
-    text.append(1, marker);
-    m_comma = true;
-    Write(text);
-}
-void
-CrashReportWriter::WriteValue(const char* key, const char* value)
-{
-    std::string text;
-    WriteSeparator(text);
-    text.append("\"");
-    text.append(key);
-    text.append("\" : \"");
-    text.append(value);
-    text.append("\"");
-    m_comma = true;
-    Write(text);
-}
-void
-CrashReportWriter::WriteValueBool(const char* key, bool value)
-{
-    WriteValue(key, value ? "true" : "false");
-}
-void
-CrashReportWriter::WriteValue32(const char* key, uint32_t value)
-{
-    char buffer[16];
-    snprintf(buffer, sizeof(buffer), "0x%x", value);
-    WriteValue(key, buffer);
-}
-void
-CrashReportWriter::WriteValue64(const char* key, uint64_t value)
-{
-    char buffer[32];
-    snprintf(buffer, sizeof(buffer), "0x%" PRIx64, value);
-    WriteValue(key, buffer);
-}
-void
-CrashReportWriter::OpenObject(const char* key)
-{
-    OpenValue(key, '{');
-}
-void
-CrashReportWriter::CloseObject()
-{
-    CloseValue('}');
-}
-void
-CrashReportWriter::OpenArray(const char* key)
-{
-    OpenValue(key, '[');
-}
-void
-CrashReportWriter::CloseArray()
-{
-    CloseValue(']');
-}

--- a/src/coreclr/debug/createdump/createdump.h
+++ b//dev/null
@@ -1,119 +0,0 @@
-#pragma once
-#define ___in       _SAL1_Source_(__in, (), _In_)
-#define ___out      _SAL1_Source_(__out, (), _Out_)
-extern bool g_diagnostics;
-extern bool g_diagnosticsVerbose;
-#ifdef HOST_UNIX
-extern bool g_checkForSingleFile;
-extern void trace_printf(const char* format, ...);
-extern void trace_verbose_printf(const char* format, ...);
-#define TRACE(args...) trace_printf(args)
-#define TRACE_VERBOSE(args...) trace_verbose_printf(args)
-#else
-#define TRACE(args, ...)
-#define TRACE_VERBOSE(args, ...)
-#endif
-#define DACCESS_TABLE_SYMBOL "g_dacTable"
-#ifdef HOST_64BIT
-#define PRIA "016"
-#else
-#define PRIA "08"
-#endif
-#ifdef HOST_UNIX
-#include "config.h"
-#endif
-#include <windows.h>
-#include <winternl.h>
-#include <winver.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <stddef.h>
-#include <string.h>
-#include <corhdr.h>
-#include <cor.h>
-#include <corsym.h>
-#include <clrdata.h>
-#include <xclrdata.h>
-#include <corerror.h>
-#include <cordebug.h>
-#include <xcordebug.h>
-#include <mscoree.h>
-typedef int T_CONTEXT;
-#include <dacprivate.h>
-#include <arrayholder.h>
-#include <releaseholder.h>
-#ifdef HOST_UNIX
-#include <dumpcommon.h>
-#include <unistd.h>
-#include <signal.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/ptrace.h>
-#include <sys/user.h>
-#include <sys/wait.h>
-#ifndef __APPLE__
-#include <sys/procfs.h>
-#include <asm/ptrace.h>
-#endif
-#ifdef HAVE_PROCESS_VM_READV
-#include <sys/uio.h>
-#endif
-#include <dirent.h>
-#include <fcntl.h>
-#include <dlfcn.h>
-#include <cxxabi.h>
-#ifdef __APPLE__
-#include <ELF.h>
-#else
-#include <elf.h>
-#include <link.h>
-#endif
-#define __STDC_FORMAT_MACROS
-#include <inttypes.h>
-#else
-#include <dbghelp.h>
-#endif
-#include <map>
-#include <set>
-#include <vector>
-#include <array>
-#include <string>
-typedef struct
-{
-    const char* DumpPathTemplate;
-    const char* DumpType;
-    MINIDUMP_TYPE MinidumpType;
-    bool CreateDump;
-    bool CrashReport;
-    int Pid;
-    int CrashThread;
-    int Signal;
-#if defined(HOST_UNIX) && !defined(HOST_OSX)
-    int SignalCode;
-    int SignalErrno;
-    void* SignalAddress;
-#endif
-} CreateDumpOptions;
-#ifdef HOST_UNIX
-#ifdef __APPLE__
-#include <mach/mach.h>
-#include <mach/mach_vm.h>
-#endif
-#include "moduleinfo.h"
-#include "datatarget.h"
-#include "stackframe.h"
-#include "threadinfo.h"
-#include "memoryregion.h"
-#include "crashinfo.h"
-#include "crashreportwriter.h"
-#include "dumpwriter.h"
-#include "runtimeinfo.h"
-#endif
-#ifndef MAX_LONGPATH
-#define MAX_LONGPATH   1024
-#endif
-extern bool CreateDump(const CreateDumpOptions& options);
-extern bool FormatDumpName(std::string& name, const char* pattern, const char* exename, int pid);
-extern std::string GetLastErrorString();
-extern void printf_status(const char* format, ...);
-extern void printf_error(const char* format, ...);

--- a/src/coreclr/debug/createdump/createdumpunix.cpp
+++ b//dev/null
@@ -1,81 +0,0 @@
-#include "createdump.h"
-#if defined(__arm__) || defined(__aarch64__) || defined(__loongarch64)
-long g_pageSize = 0;
-#endif
-bool
-CreateDump(const CreateDumpOptions& options)
-{
-    ReleaseHolder<CrashInfo> crashInfo = new CrashInfo(options);
-    DumpWriter dumpWriter(*crashInfo);
-    std::string dumpPath;
-    bool result = false;
-#if defined(__arm__) || defined(__aarch64__) || defined(__loongarch64)
-    g_pageSize = sysconf(_SC_PAGESIZE);
-#endif
-    TRACE("PAGE_SIZE %d\n", PAGE_SIZE);
-    if (!crashInfo->Initialize())
-    {
-        goto exit;
-    }
-    printf_status("Gathering state for process %d %s\n", options.Pid, crashInfo->Name().c_str());
-    if (options.Signal != 0 || options.CrashThread != 0)
-    {
-        printf_status("Crashing thread %04x signal %d (%04x)\n", options.CrashThread, options.Signal, options.Signal);
-    }
-    if (!crashInfo->EnumerateAndSuspendThreads())
-    {
-        goto exit;
-    }
-    if (!crashInfo->GatherCrashInfo(options.MinidumpType))
-    {
-        goto exit;
-    }
-    if (!FormatDumpName(dumpPath, options.DumpPathTemplate, crashInfo->Name().c_str(), options.Pid))
-    {
-        goto exit;
-    }
-    if (options.CrashReport)
-    {
-        CrashReportWriter crashReportWriter(*crashInfo);
-        crashReportWriter.WriteCrashReport(dumpPath);
-    }
-    if (options.CreateDump)
-    {
-        if (!crashInfo->EnumerateMemoryRegionsWithDAC(options.MinidumpType))
-        {
-            goto exit;
-        }
-        crashInfo->CombineMemoryRegions();
-        printf_status("Writing %s to file %s\n", options.DumpType, dumpPath.c_str());
-        if (!dumpWriter.OpenDump(dumpPath.c_str()))
-        {
-            goto exit;
-        }
-        if (!dumpWriter.WriteDump())
-        {
-            printf_error("Writing dump FAILED\n");
-            remove(dumpPath.c_str());
-            goto exit;
-        }
-    }
-    result = true;
-exit:
-    if (kill(options.Pid, 0) == 0)
-    {
-        printf_status("Target process is alive\n");
-    }
-    else
-    {
-        int err = errno;
-        if (err == ESRCH)
-        {
-            printf_error("Target process terminated\n");
-        }
-        else
-        {
-            printf_error("kill(%d, 0) FAILED %s (%d)\n", options.Pid, strerror(err), err);
-        }
-    }
-    crashInfo->CleanupAndResumeProcess();
-    return result;
-}

--- a/src/coreclr/debug/createdump/createdumpwindows.cpp
+++ b//dev/null
@@ -1,78 +0,0 @@
-#include "createdump.h"
-#include <psapi.h>
-typedef struct _PROCESS_BASIC_INFORMATION_ {
-    NTSTATUS ExitStatus;
-    PPEB PebBaseAddress;
-    ULONG_PTR AffinityMask;
-    KPRIORITY BasePriority;
-    ULONG_PTR UniqueProcessId;
-    ULONG_PTR InheritedFromUniqueProcessId;
-} PROCESS_BASIC_INFORMATION_;
-bool
-CreateDump(const CreateDumpOptions& options)
-{
-    HANDLE hFile = INVALID_HANDLE_VALUE;
-    HANDLE hProcess = NULL;
-    bool result = false;
-    _ASSERTE(options.CreateDump);
-    _ASSERTE(!options.CrashReport);
-    ArrayHolder<char> pszName = new char[MAX_LONGPATH + 1];
-    std::string dumpPath;
-    PROCESS_BASIC_INFORMATION_ processInformation;
-    NTSTATUS status = NtQueryInformationProcess(GetCurrentProcess(), PROCESSINFOCLASS::ProcessBasicInformation, &processInformation, sizeof(processInformation), NULL);
-    if (status != 0)
-    {
-        printf_error("Failed to get parent process id status %d\n", status);
-        goto exit;
-    }
-    int pid = (int)processInformation.InheritedFromUniqueProcessId;
-    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
-    if (hProcess == NULL)
-    {
-        printf_error("Invalid process id '%d' - %s\n", pid, GetLastErrorString().c_str());
-        goto exit;
-    }
-    if (GetModuleBaseNameA(hProcess, NULL, pszName, MAX_LONGPATH) <= 0)
-    {
-        printf_error("Get process name FAILED - %s\n", GetLastErrorString().c_str());
-        goto exit;
-    }
-    if (!FormatDumpName(dumpPath, options.DumpPathTemplate, pszName, pid))
-    {
-        goto exit;
-    }
-    printf_status("Writing %s for process %d to file %s\n", options.DumpType, pid, dumpPath.c_str());
-    hFile = CreateFileA(dumpPath.c_str(), GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
-    if (hFile == INVALID_HANDLE_VALUE)
-    {
-        printf_error("Invalid dump path '%s' - %s\n", dumpPath.c_str(), GetLastErrorString().c_str());
-        goto exit;
-    }
-    for (int i = 0; i < 5; i++)
-    {
-        if (MiniDumpWriteDump(hProcess, pid, hFile, options.MinidumpType, NULL, NULL, NULL))
-        {
-            result = true;
-            break;
-        }
-        else
-        {
-            int err = GetLastError();
-            if (err != ERROR_PARTIAL_COPY)
-            {
-                printf_error("MiniDumpWriteDump - %s\n", GetLastErrorString().c_str());
-                break;
-            }
-        }
-    }
-exit:
-    if (hProcess != NULL)
-    {
-        CloseHandle(hProcess);
-    }
-    if (hFile != INVALID_HANDLE_VALUE)
-    {
-        CloseHandle(hFile);
-    }
-    return result;
-}

--- a/src/coreclr/debug/createdump/dumpwriterelf.cpp
+++ b//dev/null
@@ -1,312 +0,0 @@
-#include "createdump.h"
-extern int g_readProcessMemoryErrno;
-bool
-DumpWriter::WriteDump()
-{
-    Ehdr ehdr;
-    memset(&ehdr, 0, sizeof(Ehdr));
-    ehdr.e_ident[0] = ELFMAG0;
-    ehdr.e_ident[1] = ELFMAG1;
-    ehdr.e_ident[2] = ELFMAG2;
-    ehdr.e_ident[3] = ELFMAG3;
-    ehdr.e_ident[EI_CLASS] = ELF_CLASS;
-    ehdr.e_ident[EI_DATA] = ELFDATA2LSB;
-    ehdr.e_ident[EI_VERSION] = EV_CURRENT;
-    ehdr.e_ident[EI_OSABI] = ELFOSABI_LINUX;
-    ehdr.e_type = ET_CORE;
-    ehdr.e_machine = ELF_ARCH;
-    ehdr.e_version = EV_CURRENT;
-    ehdr.e_phoff = sizeof(Ehdr);
-    ehdr.e_ehsize = sizeof(Ehdr);
-    ehdr.e_phentsize = sizeof(Phdr);
-    uint64_t phnum = 1;
-    for (const MemoryRegion& memoryRegion : m_crashInfo.MemoryRegions())
-    {
-        phnum++;
-    }
-    if (phnum < PH_HDR_CANARY) {
-        ehdr.e_phnum = phnum;
-    }
-    else {
-        ehdr.e_phnum = PH_HDR_CANARY;
-        ehdr.e_phoff = sizeof(Ehdr) + sizeof(Shdr);
-        ehdr.e_shnum = 1;
-        ehdr.e_shoff = sizeof(Ehdr);
-        ehdr.e_shentsize = sizeof(Shdr);
-    }
-    if (!WriteData(&ehdr, sizeof(Ehdr))) {
-        return false;
-    }
-    size_t offset = sizeof(Ehdr) + (phnum * sizeof(Phdr));
-    size_t filesz = GetProcessInfoSize() + GetAuxvInfoSize() + GetThreadInfoSize() + GetNTFileInfoSize();
-    if (ehdr.e_phnum == PH_HDR_CANARY)
-    {
-        Shdr shdr;
-        memset(&shdr, 0, sizeof(shdr));
-        shdr.sh_info = phnum;
-        shdr.sh_size = 1;
-        offset += sizeof(Shdr);
-        if (!WriteData(&shdr, sizeof(shdr))) {
-            return false;
-        }
-    }
-    Phdr phdr;
-    memset(&phdr, 0, sizeof(Phdr));
-    phdr.p_type = PT_NOTE;
-    phdr.p_offset = offset;
-    phdr.p_filesz = filesz;
-    if (!WriteData(&phdr, sizeof(phdr))) {
-        return false;
-    }
-    phdr.p_type = PT_LOAD;
-    phdr.p_align = 4096;
-    size_t finalNoteAlignment = phdr.p_align - ((offset + filesz) % phdr.p_align);
-    if (finalNoteAlignment == phdr.p_align) {
-        finalNoteAlignment = 0;
-    }
-    offset += finalNoteAlignment;
-    TRACE("Writing memory region headers to core file\n");
-    for (const MemoryRegion& memoryRegion : m_crashInfo.MemoryRegions())
-    {
-        phdr.p_flags = memoryRegion.Permissions();
-        phdr.p_vaddr = memoryRegion.StartAddress();
-        phdr.p_memsz = memoryRegion.Size();
-        offset += filesz;
-        phdr.p_filesz = filesz = memoryRegion.Size();
-        phdr.p_offset = offset;
-        if (!WriteData(&phdr, sizeof(phdr))) {
-            return false;
-        }
-    }
-    if (!WriteProcessInfo()) {
-        return false;
-    }
-    if (!WriteAuxv()) {
-        return false;
-    }
-    if (!WriteNTFileInfo()) {
-        return false;
-    }
-    TRACE("Writing %zd thread entries to core file\n", m_crashInfo.Threads().size());
-    for (const ThreadInfo* thread : m_crashInfo.Threads())
-    {
-        if (!WriteThread(*thread)) {
-            return false;
-        }
-    }
-    if (finalNoteAlignment > 0) {
-        if (finalNoteAlignment > sizeof(m_tempBuffer)) {
-            printf_error("Internal error: finalNoteAlignment %zu > sizeof(m_tempBuffer)\n", finalNoteAlignment);
-            return false;
-        }
-        memset(m_tempBuffer, 0, finalNoteAlignment);
-        if (!WriteData(m_tempBuffer, finalNoteAlignment)) {
-            return false;
-        }
-    }
-    TRACE("Writing %" PRIu64 " memory regions to core file\n", phnum - 1);
-    uint64_t total = 0;
-    for (const MemoryRegion& memoryRegion : m_crashInfo.MemoryRegions())
-    {
-        uint64_t address = memoryRegion.StartAddress();
-        size_t size = memoryRegion.Size();
-        total += size;
-        while (size > 0)
-        {
-            size_t bytesToRead = std::min(size, sizeof(m_tempBuffer));
-            size_t read = 0;
-            if (!m_crashInfo.ReadProcessMemory((void*)address, m_tempBuffer, bytesToRead, &read)) {
-                printf_error("Error reading memory at %" PRIA PRIx64 " size %08zx FAILED %s (%d)\n", address, bytesToRead, strerror(g_readProcessMemoryErrno), g_readProcessMemoryErrno);
-                return false;
-            }
-            if (read == 0) {
-                printf_error("Error reading memory at %" PRIA PRIx64 " size %08zx returned 0 bytes read: %s (%d)\n", address, bytesToRead, strerror(g_readProcessMemoryErrno), g_readProcessMemoryErrno);
-                return false;
-            }
-            if (!WriteData(m_tempBuffer, read)) {
-                return false;
-            }
-            address += read;
-            size -= read;
-        }
-    }
-    printf_status("Written %" PRId64 " bytes (%" PRId64 " pages) to core file\n", total, total / PAGE_SIZE);
-    return true;
-}
-bool
-DumpWriter::WriteProcessInfo()
-{
-    prpsinfo_t processInfo;
-    memset(&processInfo, 0, sizeof(processInfo));
-    processInfo.pr_sname = 'R';
-    processInfo.pr_pid = m_crashInfo.Pid();
-    processInfo.pr_ppid = m_crashInfo.Ppid();
-    processInfo.pr_pgrp = m_crashInfo.Tgid();
-    m_crashInfo.Name().copy(processInfo.pr_fname, sizeof(processInfo.pr_fname));
-    Nhdr nhdr;
-    memset(&nhdr, 0, sizeof(nhdr));
-    nhdr.n_namesz = 5;
-    nhdr.n_descsz = sizeof(prpsinfo_t);
-    nhdr.n_type = NT_PRPSINFO;
-    TRACE("Writing process information to core file\n");
-    if (!WriteData(&nhdr, sizeof(nhdr)) ||
-        !WriteData("CORE\0PRP", 8) ||
-        !WriteData(&processInfo, sizeof(prpsinfo_t))) {
-        return false;
-    }
-    return true;
-}
-bool
-DumpWriter::WriteAuxv()
-{
-    Nhdr nhdr;
-    memset(&nhdr, 0, sizeof(nhdr));
-    nhdr.n_namesz = 5;
-    nhdr.n_descsz = m_crashInfo.GetAuxvSize();
-    nhdr.n_type = NT_AUXV;
-    TRACE("Writing %zd auxv entries to core file\n", m_crashInfo.AuxvEntries().size());
-    if (!WriteData(&nhdr, sizeof(nhdr)) ||
-        !WriteData("CORE\0AUX", 8)) {
-        return false;
-    }
-    for (const auto& auxvEntry : m_crashInfo.AuxvEntries())
-    {
-        if (!WriteData(&auxvEntry, sizeof(auxvEntry))) {
-            return false;
-        }
-    }
-    return true;
-}
-struct NTFileEntry
-{
-    unsigned long StartAddress;
-    unsigned long EndAddress;
-    unsigned long Offset;
-};
-size_t
-DumpWriter::GetNTFileInfoSize(size_t* alignmentBytes)
-{
-    size_t count = m_crashInfo.ModuleMappings().size();
-    size_t size = 0;
-    size = sizeof(Nhdr) + 8 + sizeof(count) + sizeof(size);
-    size += count * sizeof(NTFileEntry);
-    size += count;
-    for (const MemoryRegion& image : m_crashInfo.ModuleMappings()) {
-        size += image.FileName().length();
-    }
-    size_t alignmentBytesNeeded = 4 - (size % 4);
-    size += alignmentBytesNeeded;
-    if (alignmentBytes != nullptr) {
-        *alignmentBytes = alignmentBytesNeeded;
-    }
-    return size;
-}
-bool
-DumpWriter::WriteNTFileInfo()
-{
-    Nhdr nhdr;
-    memset(&nhdr, 0, sizeof(nhdr));
-    nhdr.n_namesz = 5;
-    nhdr.n_type = NT_FILE;  // "FILE"
-    size_t alignmentBytesNeeded = 0;
-    nhdr.n_descsz = GetNTFileInfoSize(&alignmentBytesNeeded) - sizeof(nhdr) - 8;
-    size_t count = m_crashInfo.ModuleMappings().size();
-    size_t pageSize = PAGE_SIZE;
-    TRACE("Writing %zd NT_FILE entries to core file\n", m_crashInfo.ModuleMappings().size());
-    if (!WriteData(&nhdr, sizeof(nhdr)) ||
-        !WriteData("CORE\0FIL", 8) ||
-        !WriteData(&count, sizeof(count)) ||
-        !WriteData(&pageSize, sizeof(pageSize))) {
-        return false;
-    }
-    for (const MemoryRegion& image : m_crashInfo.ModuleMappings())
-    {
-        struct NTFileEntry entry { (unsigned long)image.StartAddress(), (unsigned long)image.EndAddress(), (unsigned long)(image.Offset() / pageSize) };
-        if (!WriteData(&entry, sizeof(entry))) {
-            return false;
-        }
-    }
-    for (const MemoryRegion& image : m_crashInfo.ModuleMappings())
-    {
-        if (!WriteData(image.FileName().c_str(), image.FileName().length()) ||
-            !WriteData("\0", 1)) {
-            return false;
-        }
-    }
-    if (alignmentBytesNeeded) {
-        if (!WriteData("\0\0\0\0", alignmentBytesNeeded)) {
-            return false;
-        }
-    }
-    return true;
-}
-bool
-DumpWriter::WriteThread(const ThreadInfo& thread)
-{
-    prstatus_t pr;
-    memset(&pr, 0, sizeof(pr));
-    const siginfo_t* siginfo = nullptr;
-    if (m_crashInfo.Signal() != 0 && thread.IsCrashThread())
-    {
-        siginfo = m_crashInfo.SigInfo();
-        pr.pr_info.si_signo = siginfo->si_signo;
-        pr.pr_info.si_code = siginfo->si_code;
-        pr.pr_info.si_errno = siginfo->si_errno;
-        pr.pr_cursig = siginfo->si_signo;
-    }
-    pr.pr_pid = thread.Tid();
-    pr.pr_ppid = thread.Ppid();
-    pr.pr_pgrp = thread.Tgid();
-    memcpy(&pr.pr_reg, thread.GPRegisters(), sizeof(user_regs_struct));
-    Nhdr nhdr;
-    memset(&nhdr, 0, sizeof(nhdr));
-    nhdr.n_namesz = 5;
-    nhdr.n_descsz = sizeof(prstatus_t);
-    nhdr.n_type = NT_PRSTATUS;
-    if (!WriteData(&nhdr, sizeof(nhdr)) ||
-        !WriteData("CORE\0THR", 8) ||
-        !WriteData(&pr, sizeof(prstatus_t))) {
-        return false;
-    }
-    nhdr.n_descsz = sizeof(user_fpregs_struct);
-    nhdr.n_type = NT_FPREGSET;
-    if (!WriteData(&nhdr, sizeof(nhdr)) ||
-        !WriteData("CORE\0FLT", 8) ||
-        !WriteData(thread.FPRegisters(), sizeof(user_fpregs_struct))) {
-        return false;
-    }
-#if defined(__i386__)
-    nhdr.n_namesz = 6;
-    nhdr.n_descsz = sizeof(user_fpxregs_struct);
-    nhdr.n_type = NT_PRXFPREG;
-    if (!WriteData(&nhdr, sizeof(nhdr)) ||
-        !WriteData("LINUX\0\0\0", 8) ||
-        !WriteData(thread.FPXRegisters(), sizeof(user_fpxregs_struct))) {
-        return false;
-    }
-#endif
-#if defined(__arm__) && defined(__VFP_FP__) && !defined(__SOFTFP__)
-    nhdr.n_namesz = 6;
-    nhdr.n_descsz = sizeof(user_vfpregs_struct);
-    nhdr.n_type = NT_ARM_VFP;
-    if (!WriteData(&nhdr, sizeof(nhdr)) ||
-        !WriteData("LINUX\0\0\0", 8) ||
-        !WriteData(thread.VFPRegisters(), sizeof(user_vfpregs_struct))) {
-        return false;
-    }
-#endif
-    if (siginfo != nullptr)
-    {
-        TRACE("Writing NT_SIGINFO tid %04x signo %d (%04x) code %04x errno %04x addr %p\n",
-            thread.Tid(), siginfo->si_signo, siginfo->si_signo, siginfo->si_code, siginfo->si_errno, siginfo->si_addr);
-        nhdr.n_namesz = 5;
-        nhdr.n_descsz = sizeof(siginfo_t);
-        nhdr.n_type = NT_SIGINFO;
-        if (!WriteData(&nhdr, sizeof(nhdr)) ||
-            !WriteData("CORE\0SIG", 8) ||
-            !WriteData(siginfo, sizeof(siginfo_t))) {
-            return false;
-        }
-    }
-    return true;
-}

--- a/src/coreclr/debug/createdump/dumpwriterelf.h
+++ b//dev/null
@@ -1,65 +0,0 @@
-#ifdef HOST_64BIT
-#define ELF_CLASS ELFCLASS64
-#else
-#define ELF_CLASS ELFCLASS32
-#endif
-#define Ehdr   ElfW(Ehdr)
-#define Phdr   ElfW(Phdr)
-#define Shdr   ElfW(Shdr)
-#define Nhdr   ElfW(Nhdr)
-#define auxv_t ElfW(auxv_t)
-#if defined(__x86_64__)
-#define ELF_ARCH  EM_X86_64
-#elif defined(__i386__)
-#define ELF_ARCH  EM_386
-#elif defined(__aarch64__)
-#define ELF_ARCH  EM_AARCH64
-#elif defined(__arm__)
-#define ELF_ARCH  EM_ARM
-#elif defined(__loongarch64)
-#define ELF_ARCH  EM_LOONGARCH
-#endif
-#define PH_HDR_CANARY 0xFFFF
-#ifndef NT_FILE
-#define NT_FILE		0x46494c45
-#endif
-#ifndef NT_SIGINFO	
-#define NT_SIGINFO	0x53494749
-#endif
-class DumpWriter
-{
-private:
-    int m_fd;
-    CrashInfo& m_crashInfo;
-    BYTE m_tempBuffer[0x4000];
-    DumpWriter(const DumpWriter&) = delete;
-    void operator=(const DumpWriter&) = delete;
-public:
-    DumpWriter(CrashInfo& crashInfo);
-    virtual ~DumpWriter();
-    bool OpenDump(const char* dumpFileName);
-    bool WriteDump();
-    static bool WriteData(int fd, const void* buffer, size_t length);
-private:
-    bool WriteProcessInfo();
-    bool WriteAuxv();
-    size_t GetNTFileInfoSize(size_t* alignmentBytes = nullptr);
-    bool WriteNTFileInfo();
-    bool WriteThread(const ThreadInfo& thread);
-    bool WriteData(const void* buffer, size_t length) { return WriteData(m_fd, buffer, length); }
-    size_t GetProcessInfoSize() const { return sizeof(Nhdr) + 8 + sizeof(prpsinfo_t); }
-    size_t GetAuxvInfoSize() const { return sizeof(Nhdr) + 8 + m_crashInfo.GetAuxvSize(); }
-    size_t GetThreadInfoSize() const
-    {
-        return (m_crashInfo.Signal() != 0 ? (sizeof(Nhdr) + 8 + sizeof(siginfo_t)) : 0)
-              + (m_crashInfo.Threads().size() * ((sizeof(Nhdr) + 8 + sizeof(prstatus_t))
-              + (sizeof(Nhdr) + 8 + sizeof(user_fpregs_struct))
-#if defined(__i386__)
-              + (sizeof(Nhdr) + 8 + sizeof(user_fpxregs_struct))
-#endif
-#if defined(__arm__) && defined(__VFP_FP__) && !defined(__SOFTFP__)
-              + (sizeof(Nhdr) + 8 + sizeof(user_vfpregs_struct))
-#endif
-        ));
-    }
-};

--- a/src/coreclr/debug/createdump/main.cpp
+++ b//dev/null
@@ -1,391 +0,0 @@
-#include "createdump.h"
-#ifdef HOST_WINDOWS
-#define DEFAULT_DUMP_PATH "%TEMP%\\"
-#define DEFAULT_DUMP_TEMPLATE "dump.%p.dmp"
-#else
-#define DEFAULT_DUMP_PATH "/tmp/"
-#define DEFAULT_DUMP_TEMPLATE "coredump.%p"
-#endif
-#ifdef HOST_UNIX
-const char* g_help = "createdump [options] pid\n"
-#else
-const char* g_help = "createdump [options]\n"
-#endif
-"-f, --name - dump path and file name. The default is '" DEFAULT_DUMP_PATH DEFAULT_DUMP_TEMPLATE "'. These specifiers are substituted with following values:\n"
-"   %p  PID of dumped process.\n"
-"   %e  The process executable filename.\n"
-"   %h  Hostname return by gethostname().\n"
-"   %t  Time of dump, expressed as seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).\n"
-"-n, --normal - create minidump.\n"
-"-h, --withheap - create minidump with heap (default).\n"
-"-t, --triage - create triage minidump.\n"
-"-u, --full - create full core dump.\n"
-"-d, --diag - enable diagnostic messages.\n"
-"-v, --verbose - enable verbose diagnostic messages.\n"
-"-l, --logtofile - file path and name to log diagnostic messages.\n"
-#ifdef HOST_UNIX
-"--crashreport - write crash report file (dump file path + .crashreport.json).\n"
-"--crashreportonly - write crash report file only (no dump).\n"
-"--crashthread <id> - the thread id of the crashing thread.\n"
-"--signal <code> - the signal code of the crash.\n"
-"--singlefile - enable single-file app check.\n"
-#endif
-;
-FILE *g_logfile = nullptr;
-FILE *g_stdout = stdout;
-bool g_diagnostics = false;
-bool g_diagnosticsVerbose = false;
-uint64_t g_ticksPerMS = 0;
-uint64_t g_startTime = 0;
-uint64_t GetTickFrequency();
-uint64_t GetTimeStamp();
-#ifdef HOST_UNIX
-bool g_checkForSingleFile = false;
-#endif
-int __cdecl main(const int argc, const char* argv[])
-{
-    CreateDumpOptions options;
-    options.MinidumpType = (MINIDUMP_TYPE)(MiniDumpWithPrivateReadWriteMemory |
-                                           MiniDumpWithDataSegs |
-                                           MiniDumpWithHandleData |
-                                           MiniDumpWithUnloadedModules |
-                                           MiniDumpWithFullMemoryInfo |
-                                           MiniDumpWithThreadInfo |
-                                           MiniDumpWithTokenInformation);
-    options.DumpType = "minidump with heap";
-    options.DumpPathTemplate = nullptr;
-    options.CrashReport = false;
-    options.CreateDump = true;
-    options.Signal = 0;
-    options.CrashThread = 0;
-    options.Pid = 0;
-#if defined(HOST_UNIX) && !defined(HOST_OSX)
-    options.SignalCode = 0;
-    options.SignalErrno = 0;
-    options.SignalAddress = nullptr;
-#endif
-    bool help = false;
-    int exitCode = 0;
-#ifdef HOST_UNIX
-    exitCode = PAL_InitializeDLL();
-    if (exitCode != 0)
-    {
-        printf_error("PAL initialization FAILED %d\n", exitCode);
-        return exitCode;
-    }
-#endif
-    argv++;
-    for (int i = 1; i < argc; i++)
-    {
-        if (*argv != nullptr)
-        {
-            if ((strcmp(*argv, "-f") == 0) || (strcmp(*argv, "--name") == 0))
-            {
-                options.DumpPathTemplate = *++argv;
-            }
-            else if ((strcmp(*argv, "-n") == 0) || (strcmp(*argv, "--normal") == 0))
-            {
-                options.DumpType = "minidump";
-                options.MinidumpType = (MINIDUMP_TYPE)(MiniDumpNormal |
-                                                       MiniDumpWithDataSegs |
-                                                       MiniDumpWithHandleData |
-                                                       MiniDumpWithThreadInfo);
-            }
-            else if ((strcmp(*argv, "-h") == 0) || (strcmp(*argv, "--withheap") == 0))
-            {
-                options.DumpType = "minidump with heap";
-                options.MinidumpType = (MINIDUMP_TYPE)(MiniDumpWithPrivateReadWriteMemory |
-                                                       MiniDumpWithDataSegs |
-                                                       MiniDumpWithHandleData |
-                                                       MiniDumpWithUnloadedModules |
-                                                       MiniDumpWithFullMemoryInfo |
-                                                       MiniDumpWithThreadInfo |
-                                                       MiniDumpWithTokenInformation);
-            }
-            else if ((strcmp(*argv, "-t") == 0) || (strcmp(*argv, "--triage") == 0))
-            {
-                options.DumpType = "triage minidump";
-                options.MinidumpType = (MINIDUMP_TYPE)(MiniDumpFilterTriage |
-                                                       MiniDumpIgnoreInaccessibleMemory |
-                                                       MiniDumpWithoutOptionalData |
-                                                       MiniDumpWithProcessThreadData |
-                                                       MiniDumpFilterModulePaths |
-                                                       MiniDumpWithUnloadedModules |
-                                                       MiniDumpFilterMemory |
-                                                       MiniDumpWithHandleData);
-            }
-            else if ((strcmp(*argv, "-u") == 0) || (strcmp(*argv, "--full") == 0))
-            {
-                options.DumpType = "full dump";
-                options.MinidumpType = (MINIDUMP_TYPE)(MiniDumpWithFullMemory |
-                                                       MiniDumpWithDataSegs |
-                                                       MiniDumpWithHandleData |
-                                                       MiniDumpWithUnloadedModules |
-                                                       MiniDumpWithFullMemoryInfo |
-                                                       MiniDumpWithThreadInfo |
-                                                       MiniDumpWithTokenInformation);
-            }
-#ifdef HOST_UNIX
-            else if (strcmp(*argv, "--crashreport") == 0)
-            {
-                options.CrashReport = true;
-            }
-            else if (strcmp(*argv, "--crashreportonly") == 0)
-            {
-                options.CrashReport = true;
-                options.CreateDump = false;
-            }
-            else if (strcmp(*argv, "--crashthread") == 0)
-            {
-                options.CrashThread = atoi(*++argv);
-            }
-            else if (strcmp(*argv, "--signal") == 0)
-            {
-                options.Signal = atoi(*++argv);
-            }
-            else if (strcmp(*argv, "--singlefile") == 0)
-            {
-                g_checkForSingleFile = true;
-            }
-#ifndef HOST_OSX
-            else if (strcmp(*argv, "--code") == 0)
-            {
-                options.SignalCode = atoi(*++argv);
-            }
-            else if (strcmp(*argv, "--errno") == 0)
-            {
-                options.SignalErrno = atoi(*++argv);
-            }
-            else if (strcmp(*argv, "--address") == 0)
-            {
-                options.SignalAddress = (void*)atoll(*++argv);
-            }
-#endif
-#endif
-            else if ((strcmp(*argv, "-d") == 0) || (strcmp(*argv, "--diag") == 0))
-            {
-                g_diagnostics = true;
-            }
-            else if ((strcmp(*argv, "-v") == 0) || (strcmp(*argv, "--verbose") == 0))
-            {
-                g_diagnostics = true;
-                g_diagnosticsVerbose = true;
-            }
-            else if ((strcmp(*argv, "-l") == 0) || (strcmp(*argv, "--logtofile") == 0))
-            {
-                const char* logFilePath = *++argv;
-                g_logfile = fopen(logFilePath, "w");
-                if (g_logfile == nullptr)
-                {
-                    printf_error("Can not create log file '%s': %s (%d)\n", logFilePath, strerror(errno), errno);
-                    return errno;
-                }
-                g_stdout = g_logfile;
-            }
-            else if ((strcmp(*argv, "-?") == 0) || (strcmp(*argv, "--help") == 0))
-            {
-                help = true;
-            }
-            else
-            {
-#ifdef HOST_UNIX
-                options.Pid = atoi(*argv);
-#else
-                printf_error("The pid argument is no longer supported\n");
-                return -1;
-#endif
-            }
-            argv++;
-        }
-    }
-#ifdef HOST_UNIX
-    if (options.Pid == 0)
-    {
-        help = true;
-    }
-#endif
-    if (help)
-    {
-        printf_error("%s", g_help);
-        return -1;
-    }
-    g_ticksPerMS = GetTickFrequency() / 1000UL;
-    g_startTime = GetTimeStamp();
-    TRACE("TickFrequency: %d ticks per ms\n", g_ticksPerMS);
-    ArrayHolder<char> tmpPath = new char[MAX_LONGPATH];
-    if (options.DumpPathTemplate == nullptr)
-    {
-        if (::GetTempPathA(MAX_LONGPATH, tmpPath) == 0)
-        {
-            printf_error("GetTempPath failed %s", GetLastErrorString().c_str());
-            return ::GetLastError();
-        }
-        exitCode = strcat_s(tmpPath, MAX_LONGPATH, DEFAULT_DUMP_TEMPLATE);
-        if (exitCode != 0)
-        {
-            printf_error("strcat_s failed (%d)", exitCode);
-            return exitCode;
-        }
-        options.DumpPathTemplate = tmpPath;
-    }
-    if (CreateDump(options))
-    {
-        printf_status("Dump successfully written in %llums\n", GetTimeStamp() - g_startTime);
-    }
-    else
-    {
-        printf_error("Failure took %llums\n", GetTimeStamp() - g_startTime);
-        exitCode = -1;
-    }
-    fflush(g_stdout);
-    if (g_logfile != nullptr)
-    {
-        fflush(g_logfile);
-        fclose(g_logfile);
-    }
-#ifdef HOST_UNIX
-    PAL_TerminateEx(exitCode);
-#endif
-    return exitCode;
-}
-std::string
-GetLastErrorString()
-{
-    DWORD error = GetLastError();
-    std::string result;
-#ifdef HOST_WINDOWS
-    LPSTR messageBuffer;
-    DWORD length = FormatMessage(
-        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
-        NULL,
-        error,
-        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
-        (LPTSTR)&messageBuffer,
-        0,
-        NULL);
-    if (length > 0)
-    {
-        result.append(messageBuffer, length);
-        LocalFree(messageBuffer);
-        size_t found = result.find_last_of('\r');
-        if (found != std::string::npos)
-        {
-            result.erase(found);
-        }
-        result.append(" ");
-    }
-#endif
-    char buffer[64];
-    snprintf(buffer, sizeof(buffer), "(%d)", error);
-    result.append(buffer);
-    return result;
-}
-void
-printf_status(const char* format, ...)
-{
-    va_list args;
-    va_start(args, format);
-    if (g_logfile == nullptr)
-    {
-        fprintf(g_stdout, "[createdump] ");
-    }
-    vfprintf(g_stdout, format, args);
-    fflush(g_stdout);
-    va_end(args);
-}
-void
-printf_error(const char* format, ...)
-{
-    va_list args;
-    va_start(args, format);
-    if (g_logfile != nullptr)
-    {
-        va_list args2;
-        va_copy(args2, args);
-        vfprintf(g_logfile, format, args2);
-        fflush(g_logfile);
-    }
-    fprintf(stderr, "[createdump] ");
-    vfprintf(stderr, format, args);
-    fflush(stderr);
-    va_end(args);
-}
-uint64_t
-GetTickFrequency()
-{
-    LARGE_INTEGER ret;
-    ZeroMemory(&ret, sizeof(LARGE_INTEGER));
-    QueryPerformanceFrequency(&ret);
-    return ret.QuadPart;
-}
-uint64_t
-GetTimeStamp()
-{
-    LARGE_INTEGER ret;
-    ZeroMemory(&ret, sizeof(LARGE_INTEGER));
-    QueryPerformanceCounter(&ret);
-    return ret.QuadPart / g_ticksPerMS;
-}
-#ifdef HOST_UNIX
-static void
-trace_prefix()
-{
-    if (g_logfile == nullptr)
-    {
-        fprintf(g_stdout, "[createdump] ");
-    }
-    fprintf(g_stdout, "%08" PRIx64 " ", GetTimeStamp());
-}
-void
-trace_printf(const char* format, ...)
-{
-    if (g_diagnostics)
-    {
-        va_list args;
-        va_start(args, format);
-        trace_prefix();
-        vfprintf(g_stdout, format, args);
-        fflush(g_stdout);
-        va_end(args);
-    }
-}
-void
-trace_verbose_printf(const char* format, ...)
-{
-    if (g_diagnosticsVerbose)
-    {
-        va_list args;
-        va_start(args, format);
-        trace_prefix();
-        vfprintf(g_stdout, format, args);
-        fflush(g_stdout);
-        va_end(args);
-    }
-}
-void
-CrashInfo::Trace(const char* format, ...)
-{
-    if (g_diagnostics)
-    {
-        va_list args;
-        va_start(args, format);
-        trace_prefix();
-        vfprintf(g_stdout, format, args);
-        fflush(g_stdout);
-        va_end(args);
-    }
-}
-void
-CrashInfo::TraceVerbose(const char* format, ...)
-{
-    if (g_diagnosticsVerbose)
-    {
-        va_list args;
-        va_start(args, format);
-        trace_prefix();
-        vfprintf(g_stdout, format, args);
-        fflush(g_stdout);
-        va_end(args);
-    }
-}
-#endif // HOST_UNIX

--- a/src/coreclr/debug/createdump/threadinfo.cpp
+++ b//dev/null
@@ -1,304 +0,0 @@
-#include "createdump.h"
-#ifndef THUMB_CODE
-#define THUMB_CODE 1
-#endif
-#ifndef __GLIBC__
-typedef int __ptrace_request;
-#endif
-extern CrashInfo* g_crashInfo;
-static void
-GetFrameLocation(CONTEXT* pContext, uint64_t* ip, uint64_t* sp)
-{
-#if defined(__x86_64__)
-    *ip = pContext->Rip;
-    *sp = pContext->Rsp;
-#elif defined(__i386__)
-    *ip = pContext->Eip;
-    *sp = pContext->Esp;
-#elif defined(__aarch64__)
-    *ip = pContext->Pc;
-    *sp = pContext->Sp;
-#elif defined(__arm__)
-    *ip = pContext->Pc & ~THUMB_CODE;
-    *sp = pContext->Sp;
-#endif
-}
-static BOOL
-ReadMemoryAdapter(PVOID address, PVOID buffer, SIZE_T size)
-{
-    return g_crashInfo->ReadMemory(address, buffer, size);
-}
-void
-ThreadInfo::UnwindNativeFrames(CONTEXT* pContext)
-{
-    uint64_t previousSp = 0;
-    uint64_t previousIp = 0;
-    int ipMatchCount = 0;
-    while (true)
-    {
-        uint64_t ip = 0, sp = 0;
-        GetFrameLocation(pContext, &ip, &sp);
-#if defined(__aarch64__)
-        if (sp == previousSp && ip != previousIp)
-        {
-            sp++;
-        }
-#endif
-        if (ip == 0 || sp <= previousSp) {
-            TRACE_VERBOSE("Unwind: sp not increasing or ip == 0 sp %p ip %p\n", (void*)sp, (void*)ip);
-            break;
-        }
-        if (ip == previousIp)
-        {
-            if (ipMatchCount++ > 1000)
-            {
-                TRACE("Unwind: same ip %p over 1000 times\n", (void*)ip);
-                break;
-            }
-        }
-        else
-        {
-            ipMatchCount = 0;
-        }
-        m_crashInfo.InsertMemoryRegion(ip - PAGE_SIZE, PAGE_SIZE * 2);
-        uint64_t baseAddress = m_crashInfo.GetBaseAddressFromAddress(ip);
-        if (baseAddress == 0) {
-            TRACE_VERBOSE("Unwind: module base not found ip %p\n", (void*)ip);
-            break;
-        }
-        ULONG64 functionStart;
-        if (!PAL_VirtualUnwindOutOfProc(pContext, nullptr, &functionStart, baseAddress, ReadMemoryAdapter)) {
-            TRACE("Unwind: PAL_VirtualUnwindOutOfProc returned false\n");
-            break;
-        }
-        if (m_crashInfo.GatherFrames())
-        {
-            StackFrame frame(baseAddress, ip, sp, ip - functionStart);
-            AddStackFrame(frame);
-        }
-        previousSp = sp;
-        previousIp = ip;
-    }
-}
-bool
-ThreadInfo::UnwindThread(IXCLRDataProcess* pClrDataProcess, ISOSDacInterface* pSos)
-{
-    TRACE("Unwind: thread %04x\n", Tid());
-    CONTEXT context;
-    GetThreadContext(CONTEXT_ALL, &context);
-    UnwindNativeFrames(&context);
-    if (pClrDataProcess != nullptr)
-    {
-        ReleaseHolder<IXCLRDataTask> pTask;
-        ReleaseHolder<IXCLRDataStackWalk> pStackwalk;
-        if (SUCCEEDED(pClrDataProcess->GetTaskByOSThreadID(Tid(), &pTask)))
-        {
-            pTask->CreateStackWalk(
-                CLRDATA_SIMPFRAME_UNRECOGNIZED |
-                CLRDATA_SIMPFRAME_MANAGED_METHOD |
-                CLRDATA_SIMPFRAME_RUNTIME_MANAGED_CODE |
-                CLRDATA_SIMPFRAME_RUNTIME_UNMANAGED_CODE,
-                &pStackwalk);
-        }
-        if (pStackwalk != nullptr)
-        {
-            TRACE("Unwind: managed frames\n");
-            m_managed = true;
-            ReleaseHolder<IXCLRDataExceptionState> pException;
-            HRESULT hr = pTask->GetCurrentExceptionState(&pException);
-            if (FAILED(hr))
-            {
-                hr = pTask->GetLastExceptionState(&pException);
-            }
-            if (SUCCEEDED(hr))
-            {
-                TRACE("Unwind: found managed exception\n");
-                ReleaseHolder<IXCLRDataValue> pExceptionValue;
-                if (SUCCEEDED(pException->GetManagedObject(&pExceptionValue)))
-                {
-                    CLRDATA_ADDRESS exceptionObject;
-                    if (SUCCEEDED(pExceptionValue->GetAddress(&exceptionObject)))
-                    {
-                        m_exceptionObject = exceptionObject;
-                        if (pSos != nullptr)
-                        {
-                            DacpExceptionObjectData exceptionData;
-                            if (SUCCEEDED(exceptionData.Request(pSos, exceptionObject)))
-                            {
-                                m_exceptionHResult = exceptionData.HResult;
-                            }
-                        }
-                        TRACE("Unwind: exception object %p exception hresult %08x\n", (void*)m_exceptionObject, m_exceptionHResult);
-                    }
-                    ReleaseHolder<IXCLRDataTypeInstance> pExceptionType;
-                    if (SUCCEEDED(pExceptionValue->GetType(&pExceptionType)))
-                    {
-                        ArrayHolder<WCHAR> typeName = new WCHAR[MAX_LONGPATH + 1];
-                        if (SUCCEEDED(pExceptionType->GetName(0, MAX_LONGPATH, nullptr, typeName.GetPtr())))
-                        {
-                            m_exceptionType = FormatString("%S", typeName.GetPtr());
-                            TRACE("Unwind: exception type %s\n", m_exceptionType.c_str());
-                        }
-                    }
-                }
-            }
-            do
-            {
-                if (pStackwalk->GetContext(CONTEXT_ALL, sizeof(context), nullptr, (BYTE *)&context) != S_OK) {
-                    TRACE("Unwind: stack walker GetContext FAILED\n");
-                    break;
-                }
-                if (m_crashInfo.GatherFrames())
-                {
-                    GatherStackFrames(&context, pStackwalk);
-                }
-                UnwindNativeFrames(&context);
-            } while (pStackwalk->Next() == S_OK);
-        }
-    }
-    return true;
-}
-void
-ThreadInfo::GatherStackFrames(CONTEXT* pContext, IXCLRDataStackWalk* pStackwalk)
-{
-    uint64_t ip = 0, sp = 0;
-    GetFrameLocation(pContext, &ip, &sp);
-    uint64_t moduleAddress = 0;
-    mdMethodDef token = 0;
-    uint32_t nativeOffset = 0;
-    uint32_t ilOffset = 0;
-    ReleaseHolder<IXCLRDataMethodInstance> pMethod;
-    ReleaseHolder<IXCLRDataFrame> pFrame;
-    if (SUCCEEDED(pStackwalk->GetFrame(&pFrame)))
-    {
-        CLRDataSimpleFrameType simpleType;
-        CLRDataDetailedFrameType detailedType;
-        pFrame->GetFrameType(&simpleType, &detailedType);
-        if ((simpleType & (CLRDATA_SIMPFRAME_MANAGED_METHOD | CLRDATA_SIMPFRAME_RUNTIME_MANAGED_CODE)) != 0)
-        {
-            if (SUCCEEDED(pFrame->GetMethodInstance(&pMethod)))
-            {
-                ReleaseHolder<IXCLRDataModule> pModule;
-                if (SUCCEEDED(pMethod->GetTokenAndScope(&token, &pModule)))
-                {
-                    DacpGetModuleData moduleData;
-                    if (SUCCEEDED(moduleData.Request(pModule)))
-                    {
-                        moduleAddress = moduleData.LoadedPEAddress;
-                    }
-                    else
-                    {
-                        TRACE("Unwind: DacpGetModuleData.Request sp %p ip %p FAILED\n", (void*)sp, (void*)ip);
-                    }
-                }
-                else
-                {
-                    TRACE("Unwind: GetTokenAndScope sp %p ip %p FAILED\n", (void*)sp, (void*)ip);
-                }
-                if (FAILED(pMethod->GetILOffsetsByAddress(ip, 1, NULL, &ilOffset)))
-                {
-                    TRACE("Unwind: GetILOffsetsByAddress sp %p ip %p FAILED\n", (void*)sp, (void*)ip);
-                }
-                CLRDATA_ADDRESS startAddress;
-                if (SUCCEEDED(pMethod->GetRepresentativeEntryAddress(&startAddress)))
-                {
-                    nativeOffset = ip - startAddress;
-                }
-                else
-                {
-                    TRACE("Unwind: GetRepresentativeEntryAddress sp %p ip %p FAILED\n", (void*)sp, (void*)ip);
-                }
-            }
-            else
-            {
-                TRACE("Unwind: GetMethodInstance sp %p ip %p FAILED\n", (void*)sp, (void*)ip);
-            }
-        }
-        else
-        {
-            TRACE("Unwind: simpleType %08x detailedType %08x\n", simpleType, detailedType);
-        }
-    }
-    StackFrame frame(moduleAddress, ip, sp, pMethod.Detach(), nativeOffset, token, ilOffset);
-    AddStackFrame(frame);
-}
-void
-ThreadInfo::AddStackFrame(const StackFrame& frame)
-{
-    const std::set<StackFrame>::iterator& found = m_frames.find(frame);
-    if (found == m_frames.end())
-    {
-        if (m_exceptionHResult == STACK_OVERFLOW_EXCEPTION)
-        {
-            if (m_beginRepeat == m_frames.end())
-            {
-                for (auto iterator = m_frames.cbegin(); iterator != m_frames.cend(); ++iterator)
-                {
-                    if (frame.InstructionPointer() == iterator->InstructionPointer())
-                    {
-                        m_repeatedFrames++;
-                        m_beginRepeat = iterator;
-                        TRACE("Unwind: begin repeat sp %p ip %p\n", (void*)frame.StackPointer(), (void*)frame.InstructionPointer());
-                        return;
-                    }
-                }
-            }
-            if (m_endRepeat == m_frames.end())
-            {
-                for (auto iterator = m_beginRepeat; iterator != m_endRepeat; ++iterator)
-                {
-                    if (frame.InstructionPointer() == iterator->InstructionPointer())
-                    {
-                        m_repeatedFrames++;
-                        return;
-                    }
-                }
-            }
-        }
-        std::pair<std::set<StackFrame>::iterator, bool> result = m_frames.insert(frame);
-        assert(result.second);
-        TRACE("Unwind: sp %p ip %p off %08x mod %p%c\n",
-            (void*)frame.StackPointer(), (void*)frame.InstructionPointer(), frame.NativeOffset(), (void*)frame.ModuleAddress(), frame.IsManaged() ? '*' : ' ');
-        if (m_beginRepeat != m_frames.end() && m_endRepeat == m_frames.end())
-        {
-            TRACE("Unwind: end repeat sp %p ip %p\n", (void*)frame.StackPointer(), (void*)frame.InstructionPointer());
-            m_endRepeat = result.first;
-            int framesRepeated = 0;
-            for (auto iterator = m_beginRepeat; iterator != m_endRepeat; ++iterator)
-            {
-                framesRepeated++;
-            }
-            m_repeatedFrames = framesRepeated > 0 && m_repeatedFrames >= framesRepeated ? (m_repeatedFrames / framesRepeated) + 1 : 0;
-        }
-    }
-}
-void
-ThreadInfo::GetThreadStack()
-{
-    uint64_t startAddress = GetStackPointer() & PAGE_MASK;
-    size_t size = 4 * PAGE_SIZE;
-    if (startAddress != 0)
-    {
-        MemoryRegion search(0, startAddress, startAddress + PAGE_SIZE);
-        const MemoryRegion* region = CrashInfo::SearchMemoryRegions(m_crashInfo.OtherMappings(), search);
-        if (region != nullptr)
-        {
-            size = region->EndAddress() - startAddress;
-            if (g_diagnostics)
-            {
-                TRACE("Thread %04x stack found in other mapping (size %08zx): ", m_tid, size);
-                region->Trace();
-            }
-        }
-        m_crashInfo.InsertMemoryRegion(startAddress, size);
-    }
-    else
-    {
-        TRACE("Thread %04x null stack pointer\n", m_tid);
-    }
-}
-bool
-ThreadInfo::IsCrashThread() const
-{
-    return m_tid == m_crashInfo.CrashThread();
-}

--- a/src/coreclr/debug/createdump/threadinfo.h
+++ b//dev/null
@@ -1,146 +0,0 @@
-class CrashInfo;
-#if defined(__aarch64__)
-#define MCREG_Fp(mc)      ((mc).regs[29])
-#define MCREG_Lr(mc)      ((mc).regs[30])
-#define MCREG_Sp(mc)      ((mc).sp)
-#define MCREG_Pc(mc)      ((mc).pc)
-#define MCREG_Cpsr(mc)    ((mc).pstate)
-#endif
-#if defined(__loongarch64)
-#define MCREG_Ra(mc)      ((mc).gpr[1])
-#define MCREG_Fp(mc)      ((mc).gpr[22])
-#define MCREG_Sp(mc)      ((mc).gpr[3])
-#define MCREG_Pc(mc)      ((mc).pc)
-#endif
-#define FPREG_ErrorOffset(fpregs) *(DWORD*)&((fpregs).rip)
-#define FPREG_ErrorSelector(fpregs) *(((WORD*)&((fpregs).rip)) + 2)
-#define FPREG_DataOffset(fpregs) *(DWORD*)&((fpregs).rdp)
-#define FPREG_DataSelector(fpregs) *(((WORD*)&((fpregs).rdp)) + 2)
-#if defined(__arm__)
-#define user_regs_struct user_regs
-#define user_fpregs_struct user_fpregs
-#elif defined(__loongarch64)
-struct user_fpregs_struct
-{
-  unsigned long long  fpregs[32];
-  unsigned long       fpscr;
-} __attribute__((__packed__));
-#endif
-#if defined(__aarch64__)
-#define user_fpregs_struct user_fpsimd_struct
-#endif
-#if defined(__arm__) && defined(__VFP_FP__) && !defined(__SOFTFP__)
-struct user_vfpregs_struct
-{
-  unsigned long long  fpregs[32];
-  unsigned long       fpscr;
-} __attribute__((__packed__));
-#endif
-#define STACK_OVERFLOW_EXCEPTION    0x800703e9
-class ThreadInfo
-{
-private:
-    CrashInfo& m_crashInfo;                     // crashinfo instance
-    pid_t m_tid;                                // thread id
-    pid_t m_ppid;                               // parent process
-    pid_t m_tgid;                               // thread group
-    bool m_managed;                             // if true, thread has managed code running
-    uint64_t m_exceptionObject;                 // exception object address
-    std::string m_exceptionType;                // exception type
-    uint32_t m_exceptionHResult;                // exception HRESULT
-    std::set<StackFrame> m_frames;              // stack frames
-    int m_repeatedFrames;                       // number of repeated frames
-    std::set<StackFrame>::const_iterator m_beginRepeat;   // beginning of stack overflow repeated frame sequence
-    std::set<StackFrame>::const_iterator m_endRepeat;     // end of repeated frame sequence
-#ifdef __APPLE__
-    mach_port_t m_port;                         // MacOS thread port
-#if defined(__x86_64__)
-    x86_thread_state64_t m_gpRegisters;         // MacOS general purpose registers
-    x86_float_state64_t m_fpRegisters;          // MacOS floating point registers
-#elif defined(__aarch64__)
-    arm_thread_state64_t m_gpRegisters;         // MacOS general purpose arm64 registers
-    arm_neon_state64_t m_fpRegisters;           // MacOS floating point arm64 registers
-#endif
-#else // __APPLE__
-    struct user_regs_struct m_gpRegisters;      // general purpose registers
-    struct user_fpregs_struct m_fpRegisters;    // floating point registers
-#if defined(__i386__)
-    struct user_fpxregs_struct m_fpxRegisters;  // x86 floating point registers
-#elif defined(__arm__) && defined(__VFP_FP__) && !defined(__SOFTFP__)
-    struct user_vfpregs_struct m_vfpRegisters;  // ARM VFP/NEON registers
-#endif
-#endif // __APPLE__
-    ThreadInfo(const ThreadInfo&) = delete;
-    void operator=(const ThreadInfo&) = delete;
-public:
-#ifdef __APPLE__
-    ThreadInfo(CrashInfo& crashInfo, pid_t tid, mach_port_t port);
-    inline mach_port_t Port() const { return m_port; }
-#else
-    ThreadInfo(CrashInfo& crashInfo, pid_t tid);
-#endif
-    ~ThreadInfo();
-    bool Initialize();
-    bool UnwindThread(IXCLRDataProcess* pClrDataProcess, ISOSDacInterface* pSos);
-    void GetThreadStack();
-    void GetThreadContext(uint32_t flags, CONTEXT* context) const;
-    inline pid_t Tid() const { return m_tid; }
-    inline pid_t Ppid() const { return m_ppid; }
-    inline pid_t Tgid() const { return m_tgid; }
-    inline bool IsManaged() const { return m_managed; }
-    inline uint64_t ManagedExceptionObject() const { return m_exceptionObject; }
-    inline uint32_t ManagedExceptionHResult() const { return m_exceptionHResult; }
-    inline std::string ManagedExceptionType() const { return m_exceptionType; }
-    inline const std::set<StackFrame>& StackFrames() const { return m_frames; }
-    inline int NumRepeatedFrames() const { return m_repeatedFrames;  }
-    inline bool IsBeginRepeat(std::set<StackFrame>::const_iterator& iterator) const { return m_repeatedFrames > 0 && iterator == m_beginRepeat; }
-    inline bool IsEndRepeat(std::set<StackFrame>::const_iterator& iterator) const { return  m_repeatedFrames > 0 && iterator == m_endRepeat; }
-#ifdef __APPLE__
-#if defined(__x86_64__)
-    inline const x86_thread_state64_t* GPRegisters() const { return &m_gpRegisters; }
-    inline const x86_float_state64_t* FPRegisters() const { return &m_fpRegisters; }
-    inline const uint64_t GetInstructionPointer() const { return m_gpRegisters.__rip; }
-    inline const uint64_t GetFramePointer() const { return m_gpRegisters.__rbp; }
-    inline const uint64_t GetStackPointer() const { return m_gpRegisters.__rsp; }
-#elif defined(__aarch64__)
-    inline const arm_thread_state64_t* GPRegisters() const { return &m_gpRegisters; }
-    inline const arm_neon_state64_t* FPRegisters() const { return &m_fpRegisters; }
-    inline const uint64_t GetInstructionPointer() const { return arm_thread_state64_get_pc(m_gpRegisters); }
-    inline const uint64_t GetFramePointer() const { return arm_thread_state64_get_fp(m_gpRegisters); }
-    inline const uint64_t GetStackPointer() const { return arm_thread_state64_get_sp(m_gpRegisters); }
-#endif
-#else // __APPLE__
-    inline const user_regs_struct* GPRegisters() const { return &m_gpRegisters; }
-    inline const user_fpregs_struct* FPRegisters() const { return &m_fpRegisters; }
-#if defined(__i386__)
-    inline const user_fpxregs_struct* FPXRegisters() const { return &m_fpxRegisters; }
-#elif defined(__arm__) && defined(__VFP_FP__) && !defined(__SOFTFP__)
-    inline const user_vfpregs_struct* VFPRegisters() const { return &m_vfpRegisters; }
-#endif
-#if defined(__x86_64__)
-    inline const uint64_t GetInstructionPointer() const { return m_gpRegisters.rip; }
-    inline const uint64_t GetStackPointer() const { return m_gpRegisters.rsp; }
-    inline const uint64_t GetFramePointer() const { return m_gpRegisters.rbp; }
-#elif defined(__aarch64__)
-    inline const uint64_t GetInstructionPointer() const { return MCREG_Pc(m_gpRegisters); }
-    inline const uint64_t GetStackPointer() const { return MCREG_Sp(m_gpRegisters); }
-    inline const uint64_t GetFramePointer() const { return MCREG_Fp(m_gpRegisters); }
-#elif defined(__loongarch64)
-    inline const uint64_t GetInstructionPointer() const { return MCREG_Pc(m_gpRegisters); }
-    inline const uint64_t GetStackPointer() const { return MCREG_Sp(m_gpRegisters); }
-    inline const uint64_t GetFramePointer() const { return MCREG_Fp(m_gpRegisters); }
-#elif defined(__arm__)
-    inline const uint64_t GetInstructionPointer() const { return m_gpRegisters.ARM_pc; }
-    inline const uint64_t GetStackPointer() const { return m_gpRegisters.ARM_sp; }
-    inline const uint64_t GetFramePointer() const { return m_gpRegisters.ARM_fp; }
-#endif
-#endif // __APPLE__
-    bool IsCrashThread() const;
-private:
-    void UnwindNativeFrames(CONTEXT* pContext);
-    void GatherStackFrames(CONTEXT* pContext, IXCLRDataStackWalk* pStackwalk);
-    void AddStackFrame(const StackFrame& frame);
-#ifndef __APPLE__
-    bool GetRegistersWithPTrace();
-#endif
-};

--- a/src/coreclr/gc/unix/events.cpp
+++ b//dev/null
@@ -1,245 +0,0 @@
-#include <cstdint>
-#include <cstddef>
-#include <cassert>
-#include <memory>
-#include <mutex>
-#include <pthread.h>
-#include <errno.h>
-#include "config.gc.h"
-#include "common.h"
-#include "gcenv.structs.h"
-#include "gcenv.base.h"
-#include "gcenv.os.h"
-#include "globals.h"
-namespace
-{
-#if HAVE_PTHREAD_CONDATTR_SETCLOCK
-void TimeSpecAdd(timespec* time, uint32_t milliseconds)
-{
-    uint64_t nsec = time->tv_nsec + (uint64_t)milliseconds * tccMilliSecondsToNanoSeconds;
-    if (nsec >= tccSecondsToNanoSeconds)
-    {
-        time->tv_sec += nsec / tccSecondsToNanoSeconds;
-        nsec %= tccSecondsToNanoSeconds;
-    }
-    time->tv_nsec = nsec;
-}
-#endif // HAVE_PTHREAD_CONDATTR_SETCLOCK
-#if HAVE_CLOCK_GETTIME_NSEC_NP
-void NanosecondsToTimeSpec(uint64_t nanoseconds, timespec* t)
-{
-    t->tv_sec = nanoseconds / tccSecondsToNanoSeconds;
-    t->tv_nsec = nanoseconds % tccSecondsToNanoSeconds;
-}
-#endif // HAVE_CLOCK_GETTIME_NSEC_NP
-} // anonymous namespace
-class GCEvent::Impl
-{
-    pthread_cond_t m_condition;
-    pthread_mutex_t m_mutex;
-    bool m_manualReset;
-    bool m_state;
-    bool m_isValid;
-public:
-    Impl(bool manualReset, bool initialState)
-    : m_manualReset(manualReset),
-      m_state(initialState),
-      m_isValid(false)
-    {
-    }
-    bool Initialize()
-    {
-        pthread_condattr_t attrs;
-        int st = pthread_condattr_init(&attrs);
-        if (st != 0)
-        {
-            assert(!"Failed to initialize UnixEvent condition attribute");
-            return false;
-        }
-#if HAVE_PTHREAD_CONDATTR_SETCLOCK && !HAVE_CLOCK_GETTIME_NSEC_NP
-        st = pthread_condattr_setclock(&attrs, CLOCK_MONOTONIC);
-        if (st != 0)
-        {
-            assert(!"Failed to set UnixEvent condition variable wait clock");
-            return false;
-        }
-#endif // HAVE_PTHREAD_CONDATTR_SETCLOCK && !HAVE_CLOCK_GETTIME_NSEC_NP
-        st = pthread_mutex_init(&m_mutex, NULL);
-        if (st != 0)
-        {
-            assert(!"Failed to initialize UnixEvent mutex");
-            return false;
-        }
-        st = pthread_cond_init(&m_condition, &attrs);
-        if (st != 0)
-        {
-            assert(!"Failed to initialize UnixEvent condition variable");
-            st = pthread_mutex_destroy(&m_mutex);
-            assert(st == 0 && "Failed to destroy UnixEvent mutex");
-            return false;
-        }
-        m_isValid = true;
-        return true;
-    }
-    void CloseEvent()
-    {
-        if (m_isValid)
-        {
-            int st = pthread_mutex_destroy(&m_mutex);
-            assert(st == 0 && "Failed to destroy UnixEvent mutex");
-            st = pthread_cond_destroy(&m_condition);
-            assert(st == 0 && "Failed to destroy UnixEvent condition variable");
-        }
-    }
-    uint32_t Wait(uint32_t milliseconds, bool alertable)
-    {
-        UNREFERENCED_PARAMETER(alertable);
-        timespec endTime;
-#if HAVE_CLOCK_GETTIME_NSEC_NP
-        uint64_t endMachTime;
-        if (milliseconds != INFINITE)
-        {
-            uint64_t nanoseconds = (uint64_t)milliseconds * tccMilliSecondsToNanoSeconds;
-            NanosecondsToTimeSpec(nanoseconds, &endTime);
-            endMachTime = clock_gettime_nsec_np(CLOCK_UPTIME_RAW) + nanoseconds;
-        }
-#elif HAVE_PTHREAD_CONDATTR_SETCLOCK
-        if (milliseconds != INFINITE)
-        {
-            clock_gettime(CLOCK_MONOTONIC, &endTime);
-            TimeSpecAdd(&endTime, milliseconds);
-        }
-#else
-#error "Don't know how to perform timed wait on this platform"
-#endif
-        int st = 0;
-        pthread_mutex_lock(&m_mutex);
-        while (!m_state)
-        {
-            if (milliseconds == INFINITE)
-            {
-                st = pthread_cond_wait(&m_condition, &m_mutex);
-            }
-            else
-            {
-#if HAVE_CLOCK_GETTIME_NSEC_NP
-                st = pthread_cond_timedwait_relative_np(&m_condition, &m_mutex, &endTime);
-                if ((st == 0) && !m_state)
-                {
-                    uint64_t machTime = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
-                    if (machTime < endMachTime)
-                    {
-                        uint64_t remainingNanoseconds = endMachTime - machTime;
-                        NanosecondsToTimeSpec(remainingNanoseconds, &endTime);
-                    }
-                    else
-                    {
-                        st = ETIMEDOUT;
-                    }
-                }
-#else // HAVE_CLOCK_GETTIME_NSEC_NP
-                st = pthread_cond_timedwait(&m_condition, &m_mutex, &endTime);
-#endif // HAVE_CLOCK_GETTIME_NSEC_NP
-                assert((st != ETIMEDOUT) || !m_state);
-            }
-            if (st != 0)
-            {
-                break;
-            }
-        }
-        if ((st == 0) && !m_manualReset)
-        {
-            m_state = false;
-        }
-        pthread_mutex_unlock(&m_mutex);
-        uint32_t waitStatus;
-        if (st == 0)
-        {
-            waitStatus = WAIT_OBJECT_0;
-        }
-        else if (st == ETIMEDOUT)
-        {
-            waitStatus = WAIT_TIMEOUT;
-        }
-        else
-        {
-            waitStatus = WAIT_FAILED;
-        }
-        return waitStatus;
-    }
-    void Set()
-    {
-        pthread_mutex_lock(&m_mutex);
-        m_state = true;
-        pthread_cond_broadcast(&m_condition);
-        pthread_mutex_unlock(&m_mutex);
-    }
-    void Reset()
-    {
-        pthread_mutex_lock(&m_mutex);
-        m_state = false;
-        pthread_mutex_unlock(&m_mutex);
-    }
-};
-GCEvent::GCEvent()
-  : m_impl(nullptr)
-{
-}
-void GCEvent::CloseEvent()
-{
-    assert(m_impl != nullptr);
-    m_impl->CloseEvent();
-}
-void GCEvent::Set()
-{
-    assert(m_impl != nullptr);
-    m_impl->Set();
-}
-void GCEvent::Reset()
-{
-    assert(m_impl != nullptr);
-    m_impl->Reset();
-}
-uint32_t GCEvent::Wait(uint32_t timeout, bool alertable)
-{
-    assert(m_impl != nullptr);
-    return m_impl->Wait(timeout, alertable);
-}
-bool GCEvent::CreateAutoEventNoThrow(bool initialState)
-{
-    return CreateOSAutoEventNoThrow(initialState);
-}
-bool GCEvent::CreateManualEventNoThrow(bool initialState)
-{
-    return CreateOSManualEventNoThrow(initialState);
-}
-bool GCEvent::CreateOSAutoEventNoThrow(bool initialState)
-{
-    assert(m_impl == nullptr);
-    std::unique_ptr<GCEvent::Impl> event(new (std::nothrow) GCEvent::Impl(false, initialState));
-    if (!event)
-    {
-        return false;
-    }
-    if (!event->Initialize())
-    {
-        return false;
-    }
-    m_impl = event.release();
-    return true;
-}
-bool GCEvent::CreateOSManualEventNoThrow(bool initialState)
-{
-    assert(m_impl == nullptr);
-    std::unique_ptr<GCEvent::Impl> event(new (std::nothrow) GCEvent::Impl(true, initialState));
-    if (!event)
-    {
-        return false;
-    }
-    if (!event->Initialize())
-    {
-        return false;
-    }
-    m_impl = event.release();
-    return true;
-}

--- a/src/coreclr/inc/clrconfigvalues.h
+++ b//dev/null
@@ -1,539 +0,0 @@
-CONFIG_DWORD_INFO(INTERNAL_EnableFullDebug, W("EnableFullDebug"), 0, "Heavy-weight checking for AD boundary violations (AD leaks)")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchEnabled, W("JitPitchEnabled"), (DWORD)0, "Set it to 1 to enable Jit Pitching")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchMemThreshold, W("JitPitchMemThreshold"), (DWORD)0, "Do Jit Pitching when code heap usage is larger than this (in bytes)")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchMethodSizeThreshold, W("JitPitchMethodSizeThreshold"), (DWORD)0, "Do Jit Pitching for methods whose native code size larger than this (in bytes)")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchTimeInterval, W("JitPitchTimeInterval"), (DWORD)0, "Time interval between Jit Pitchings in ms")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchPrintStat, W("JitPitchPrintStat"), (DWORD)0, "Print statistics about Jit Pitching")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchMinVal, W("JitPitchMinVal"), (DWORD)0, "Do Jit Pitching if the value of the inner counter greater than this value (for debugging purpose only)")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchMaxVal, W("JitPitchMaxVal"), (DWORD)0xffffffff, "Do Jit Pitching the value of the inner counter less then this value (for debuggin purpose only)")
-CONFIG_DWORD_INFO(INTERNAL_GetAssemblyIfLoadedIgnoreRidMap, W("GetAssemblyIfLoadedIgnoreRidMap"), 0, "Used to force loader to ignore assemblies cached in the rid-map")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_BreakOnBadExit, W("BreakOnBadExit"), 0, "")
-CONFIG_STRING_INFO(INTERNAL_BreakOnClassBuild, W("BreakOnClassBuild"), "Very useful for debugging class layout code.")
-CONFIG_STRING_INFO(INTERNAL_BreakOnClassLoad, W("BreakOnClassLoad"), "Very useful for debugging class loading code.")
-CONFIG_STRING_INFO(INTERNAL_BreakOnComToClrNativeInfoInit, W("BreakOnComToClrNativeInfoInit"), "Throws an assert when native information about a COM -> CLR call are about to be gathered.")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnDebugBreak, W("BreakOnDebugBreak"), 0, "Allows an assert in debug builds when a user break is hit")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnDILoad, W("BreakOnDILoad"), 0, "Allows an assert when the DI is loaded")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnDumpToken, W("BreakOnDumpToken"), 0xffffffff, "Breaks when using internal logging on a particular token value.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_BreakOnEELoad, W("BreakOnEELoad"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnEEShutdown, W("BreakOnEEShutdown"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnExceptionInGetThrowable, W("BreakOnExceptionInGetThrowable"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnFindMethod, W("BreakOnFindMethod"), 0, "Breaks in findMethodInternal when it searches for the specified token.")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnFirstPass, W("BreakOnFirstPass"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnHR, W("BreakOnHR"), 0, "Debug.cpp, IfFailxxx use this macro to stop if hr matches ")
-CONFIG_STRING_INFO(INTERNAL_BreakOnInstantiation, W("BreakOnInstantiation"), "Very useful for debugging generic class instantiation.")
-CONFIG_STRING_INFO(INTERNAL_BreakOnInteropStubSetup, W("BreakOnInteropStubSetup"), "Throws an assert when marshaling stub for the given method is about to be built.")
-CONFIG_STRING_INFO(INTERNAL_BreakOnInteropVTableBuild, W("BreakOnInteropVTableBuild"), "Specifies a type name for which an assert should be thrown when building interop v-table.")
-CONFIG_STRING_INFO(INTERNAL_BreakOnMethodName, W("BreakOnMethodName"), "Very useful for debugging method override placement code.")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnNotify, W("BreakOnNotify"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnSecondPass, W("BreakOnSecondPass"), 0, "")
-CONFIG_STRING_INFO(INTERNAL_BreakOnStructMarshalSetup, W("BreakOnStructMarshalSetup"), "Throws an assert when field marshalers for the given type with layout are about to be created.")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnUEF, W("BreakOnUEF"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnUncaughtException, W("BreakOnUncaughtException"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableDiagnostics, W("EnableDiagnostics"), 1, "Allows the debugger, profiler, and EventPipe diagnostics to be disabled")
-CONFIG_DWORD_INFO(INTERNAL_D__FCE, W("D::FCE"), 0, "Allows an assert when crawling the managed stack for an exception handler")
-CONFIG_DWORD_INFO(INTERNAL_DbgBreakIfLocksUnavailable, W("DbgBreakIfLocksUnavailable"), 0, "Allows an assert when the debugger can't take a lock ")
-CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnErr, W("DbgBreakOnErr"), 0, "Allows an assert when we get a failing hresult")
-CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnMapPatchToDJI, W("DbgBreakOnMapPatchToDJI"), 0, "Allows an assert when mapping a patch to an address")
-CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnRawInt3, W("DbgBreakOnRawInt3"), 0, "Allows an assert for test coverage for debug break or other int3 breaks")
-CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnSendBreakpoint, W("DbgBreakOnSendBreakpoint"), 0, "Allows an assert when sending a breakpoint to the right side")
-CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnSetIP, W("DbgBreakOnSetIP"), 0, "Allows an assert when setting the IP")
-CONFIG_DWORD_INFO(INTERNAL_DbgCheckInt3, W("DbgCheckInt3"), 0, "Asserts if the debugger explicitly writes int3 instead of calling SetUnmanagedBreakpoint")
-CONFIG_DWORD_INFO(INTERNAL_DbgDACAssertOnMismatch, W("DbgDACAssertOnMismatch"), 0, "Allows an assert when the mscordacwks and mscorwks dll versions don't match")
-CONFIG_DWORD_INFO(INTERNAL_DbgDACEnableAssert, W("DbgDACEnableAssert"), 0, "Enables extra validity checking in DAC - assumes target isn't corrupt")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgDACSkipVerifyDlls, W("DbgDACSkipVerifyDlls"), 0, "Allows disabling the check to ensure mscordacwks and mscorwks dll versions match")
-CONFIG_DWORD_INFO(INTERNAL_DbgDelayHelper, W("DbgDelayHelper"), 0, "Varies the wait in the helper thread startup for testing race between threads")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgDisableDynamicSymsCompat, W("DbgDisableDynamicSymsCompat"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_DbgDisableTargetConsistencyAsserts, W("DbgDisableTargetConsistencyAsserts"), 0, "Allows explicitly testing with corrupt targets")
-CONFIG_DWORD_INFO(INTERNAL_DbgExtraThreads, W("DbgExtraThreads"), 0, "Allows extra unmanaged threads to run and throw debug events for stress testing")
-CONFIG_DWORD_INFO(INTERNAL_DbgExtraThreadsCantStop, W("DbgExtraThreadsCantStop"), 0, "Allows extra unmanaged threads in can't stop region to run and throw debug events for stress testing")
-CONFIG_DWORD_INFO(INTERNAL_DbgExtraThreadsIB, W("DbgExtraThreadsIB"), 0, "Allows extra in-band unmanaged threads to run and throw debug events for stress testing")
-CONFIG_DWORD_INFO(INTERNAL_DbgExtraThreadsOOB, W("DbgExtraThreadsOOB"), 0, "Allows extra out of band unmanaged threads to run and throw debug events for stress testing")
-CONFIG_DWORD_INFO(INTERNAL_DbgFaultInHandleIPCEvent, W("DbgFaultInHandleIPCEvent"), 0, "Allows testing the unhandled event filter")
-CONFIG_DWORD_INFO(INTERNAL_DbgInjectFEE, W("DbgInjectFEE"), 0, "Allows injecting a fatal execution error for testing Watson")
-CONFIG_DWORD_INFO(INTERNAL_DbgLeakCheck, W("DbgLeakCheck"), 0, "Allows checking for leaked Cordb objects")
-CONFIG_DWORD_INFO(INTERNAL_DbgNo2ndChance, W("DbgNo2ndChance"), 0, "Allows breaking on (and catching bogus) 2nd chance exceptions")
-CONFIG_DWORD_INFO(INTERNAL_DbgNoDebugger, W("DbgNoDebugger"), 0, "Allows breaking if we don't want to lazily initialize the debugger")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgNoForceContinue, W("DbgNoForceContinue"), 1, "Used to force a continue on longhorn")
-CONFIG_DWORD_INFO(INTERNAL_DbgNoOpenMDByFile, W("DbgNoOpenMDByFile"), 0, "Allows opening MD by memory for perf testing")
-CONFIG_DWORD_INFO(INTERNAL_DbgOOBinFEEE, W("DbgOOBinFEEE"), 0, "Allows forcing oob breakpoints when a fatal error occurs")
-CONFIG_DWORD_INFO(INTERNAL_DbgPingInterop, W("DbgPingInterop"), 0, "Allows checking for deadlocks in interop debugging")
-CONFIG_DWORD_INFO(INTERNAL_DbgRace, W("DbgRace"), 0, "Allows pausing for native debug events to get hijicked")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgRedirect, W("DbgRedirect"), 0, "Allows for redirecting the event pipeline")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_DbgRedirectApplication, W("DbgRedirectApplication"), "Specifies the auxiliary debugger application to launch.")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_DbgRedirectAttachCmd, W("DbgRedirectAttachCmd"), "Specifies command parameters for attaching the auxiliary debugger.")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_DbgRedirectCommonCmd, W("DbgRedirectCommonCmd"), "Specifies a command line format string for the auxiliary debugger.")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_DbgRedirectCreateCmd, W("DbgRedirectCreateCmd"), "Specifies command parameters when creating the auxiliary debugger.")
-CONFIG_DWORD_INFO(INTERNAL_DbgShortcutCanary, W("DbgShortcutCanary"), 0, "Allows a way to force canary to fail to be able to test failure paths")
-CONFIG_DWORD_INFO(INTERNAL_DbgSkipMEOnStep, W("DbgSkipMEOnStep"), 0, "Turns off MethodEnter checks")
-CONFIG_DWORD_INFO(INTERNAL_DbgSkipVerCheck, W("DbgSkipVerCheck"), 0, "Allows different RS and LS versions (for servicing work)")
-CONFIG_DWORD_INFO(INTERNAL_DbgTC, W("DbgTC"), 0, "Allows checking boundary compression for offset mappings")
-CONFIG_DWORD_INFO(INTERNAL_DbgTransportFaultInject, W("DbgTransportFaultInject"), 0, "Allows injecting a fault for testing the debug transport")
-CONFIG_DWORD_INFO(INTERNAL_DbgTransportLog, W("DbgTransportLog"), 0 /* LE_None */, "Turns on logging for the debug transport")
-CONFIG_DWORD_INFO(INTERNAL_DbgTransportLogClass, W("DbgTransportLogClass"), (DWORD)-1 /* LC_All */, "Mask to control what is logged in DbgTransportLog")
-RETAIL_CONFIG_STRING_INFO(UNSUPPORTED_DbgTransportProxyAddress, W("DbgTransportProxyAddress"), "Allows specifying the transport proxy address")
-CONFIG_DWORD_INFO(INTERNAL_DbgTrapOnSkip, W("DbgTrapOnSkip"), 0, "Allows breaking when we skip a breakpoint")
-CONFIG_DWORD_INFO(INTERNAL_DbgWaitTimeout, W("DbgWaitTimeout"), 1, "Specifies the timeout value for waits")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgWFDETimeout, W("DbgWFDETimeout"), 25, "Specifies the timeout value for wait when waiting for a debug event")
-CONFIG_DWORD_INFO(INTERNAL_RaiseExceptionOnAssert, W("RaiseExceptionOnAssert"), 0, "Raise a first chance (if set to 1) or second chance (if set to 2) exception on asserts.")
-CONFIG_DWORD_INFO(INTERNAL_DebugBreakOnVerificationFailure, W("DebugBreakOnVerificationFailure"), 0, "Halts the jit on verification failure")
-CONFIG_STRING_INFO(INTERNAL_DebuggerBreakPoint, W("DebuggerBreakPoint"), "Allows counting various debug events")
-CONFIG_STRING_INFO(INTERNAL_DebugVerify, W("DebugVerify"), "Control for tracing in peverify")
-CONFIG_DWORD_INFO(INTERNAL_EncApplyChanges, W("EncApplyChanges"), 0, "Allows breaking when ApplyEditAndContinue is called")
-CONFIG_DWORD_INFO(INTERNAL_EnCBreakOnRemapComplete, W("EnCBreakOnRemapComplete"), 0, "Allows breaking after N RemapCompletes")
-CONFIG_DWORD_INFO(INTERNAL_EnCBreakOnRemapOpportunity, W("EnCBreakOnRemapOpportunity"), 0, "Allows breaking after N RemapOpportunities")
-CONFIG_DWORD_INFO(INTERNAL_EncDumpApplyChanges, W("EncDumpApplyChanges"), 0, "Allows dumping edits in delta metadata and il files")
-CONFIG_DWORD_INFO(INTERNAL_EncFixupFieldBreak, W("EncFixupFieldBreak"), 0, "Unlikely that this is used anymore.")
-CONFIG_DWORD_INFO(INTERNAL_EncJitUpdatedFunction, W("EncJitUpdatedFunction"), 0, "Allows breaking when an updated function is jitted")
-CONFIG_DWORD_INFO(INTERNAL_EnCResolveField, W("EnCResolveField"), 0, "Allows breaking when computing the address of an EnC-added field")
-CONFIG_DWORD_INFO(INTERNAL_EncResumeInUpdatedFunction, W("EncResumeInUpdatedFunction"), 0, "Allows breaking when execution resumes in a new EnC version of a function")
-CONFIG_DWORD_INFO(INTERNAL_DbgAssertOnDebuggeeDebugBreak, W("DbgAssertOnDebuggeeDebugBreak"), 0, "If non-zero causes the managed-only debugger to assert on unhandled breakpoints in the debuggee")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgDontResumeThreadsOnUnhandledException, W("UNSUPPORTED_DbgDontResumeThreadsOnUnhandledException"), 0, "If non-zero, then don't try to unsuspend threads after continuing a 2nd-chance native exception")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgSkipStackCheck, W("DbgSkipStackCheck"), 0, "Skip the stack pointer check during stackwalking")
-#ifdef DACCESS_COMPILE
-CONFIG_DWORD_INFO(INTERNAL_DumpGeneration_IntentionallyCorruptDataFromTarget, W("IntentionallyCorruptDataFromTarget"), 0, "Intentionally fakes bad data retrieved from target to try and break dump generation.")
-#endif
-CONFIG_DWORD_INFO(UNSUPPORTED_Debugging_RequiredVersion, W("UNSUPPORTED_Debugging_RequiredVersion"), 0, "The lowest ICorDebug version we should attempt to emulate, or 0 for default policy.  Use 2 for CLRv2, 4 for CLRv4, etc.")
-#ifdef FEATURE_MINIMETADATA_IN_TRIAGEDUMPS
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_MiniMdBufferCapacity, W("MiniMdBufferCapacity"), 64 * 1024, "The max size of the buffer to store mini metadata information for triage- and mini-dumps.")
-#endif // FEATURE_MINIMETADATA_IN_TRIAGEDUMPS
-CONFIG_DWORD_INFO(INTERNAL_DbgNativeCodeBpBindsAcrossVersions, W("DbgNativeCodeBpBindsAcrossVersions"), 0, "If non-zero causes native breakpoints at offset 0 to bind in all tiered compilation versions of the given method")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_RichDebugInfo, W("RichDebugInfo"), 0, "If non-zero store some additional debug information for each jitted method")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_OutOfProcessSetContext, W("OutOfProcessSetContext"), 0, "If enabled the debugger will not modify thread contexts in-process.  Enabled by default when CET is enabled for the process.")
-CONFIG_DWORD_INFO(INTERNAL_ConditionalContracts, W("ConditionalContracts"), 0, "If ENABLE_CONTRACTS_IMPL is defined, sets whether contracts are conditional. (?)")
-CONFIG_DWORD_INFO(INTERNAL_ConsistencyCheck, W("ConsistencyCheck"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_ContinueOnAssert, W("ContinueOnAssert"), 0, "If set, doesn't break on asserts.")
-CONFIG_DWORD_INFO(INTERNAL_InjectFatalError, W("InjectFatalError"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_InjectFault, W("InjectFault"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_SuppressChecks, W("SuppressChecks"),0,  "")
-#ifdef FEATURE_EH_FUNCLETS
-CONFIG_DWORD_INFO(INTERNAL_SuppressLockViolationsOnReentryFromOS, W("SuppressLockViolationsOnReentryFromOS"), 0, "64 bit OOM tests re-enter the CLR via RtlVirtualUnwind.  This indicates whether to suppress resulting locking violations.")
-#endif // FEATURE_EH_FUNCLETS
-CONFIG_DWORD_INFO(INTERNAL_AssertOnFailFast, W("AssertOnFailFast"), 1, "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_legacyCorruptedStateExceptionsPolicy, W("legacyCorruptedStateExceptionsPolicy"), 0, "Enabled Pre-V4 CSE behavior")
-CONFIG_DWORD_INFO(INTERNAL_SuppressLostExceptionTypeAssert, W("SuppressLostExceptionTypeAssert"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_UseEntryPointFilter, W("UseEntryPointFilter"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_Corhost_Swallow_Uncaught_Exceptions, W("Corhost_Swallow_Uncaught_Exceptions"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_FastGCCheckStack, W("FastGCCheckStack"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_FastGCStress, W("FastGCStress"), 0, "Reduce the number of GCs done by enabling GCStress")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_GCBreakOnOOM, W("GCBreakOnOOM"), 0, "Does a DebugBreak at the soonest time we detect an OOM")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_gcConcurrent, W("gcConcurrent"), (DWORD)-1, "Enables/Disables concurrent GC")
-#ifdef FEATURE_CONSERVATIVE_GC
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_gcConservative, W("gcConservative"), 0, "Enables/Disables conservative GC")
-#endif
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_gcServer, W("gcServer"), 0, "Enables server GC")
-CONFIG_STRING_INFO(INTERNAL_GcCoverage, W("GcCoverage"), "Specify a method or regular expression of method names to run with GCStress")
-CONFIG_STRING_INFO(INTERNAL_SkipGCCoverage, W("SkipGcCoverage"), "Specify a list of assembly names to skip with GC Coverage")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StatsUpdatePeriod, W("StatsUpdatePeriod"), 60, "Specifies the interval, in seconds, at which to update the statistics")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_GCRetainVM, W("GCRetainVM"), 0, "When set we put the segments that should be deleted on a standby list (instead of releasing them back to the OS) which will be considered to satisfy new segment requests (note that the same thing can be specified via API which is the supported way)")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCLOHThreshold, W("GCLOHThreshold"), 0, "Specifies the size that will make objects go on LOH")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_gcAllowVeryLargeObjects, W("gcAllowVeryLargeObjects"), 1, "Allow allocation of 2GB+ objects on GC heap")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCStress, W("GCStress"), 0, "Trigger GCs at regular intervals")
-CONFIG_DWORD_INFO(INTERNAL_GcStressOnDirectCalls, W("GcStressOnDirectCalls"), 0, "Whether to trigger a GC on direct calls")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_HeapVerify, W("HeapVerify"), 0, "When set verifies the integrity of the managed heap on entry and exit of each GC")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_GCNumaAware, W("GCNumaAware"), 1, "Specifies if to enable GC NUMA aware")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCCpuGroup, W("GCCpuGroup"), 0, "Specifies if to enable GC to support CPU groups")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_GCName, W("GCName"), "")
-/**
- * This flag allows us to force the runtime to use global allocation context on Windows x86/amd64 instead of thread allocation context just for testing purpose.
- * The flag is unsafe for a subtle reason. Although the access to the g_global_alloc_context is protected under a lock. The implementation of
- * that lock in the JIT helpers are not multi-core safe (in particular, it used and inc instruction without using the LOCK prefix). This is
- * only useful for ad-hoc testing.
- */
-CONFIG_DWORD_INFO(INTERNAL_GCUseGlobalAllocationContext, W("GCUseGlobalAllocationContext"), 0, "Force using the global allocation context for testing only")
-CONFIG_DWORD_INFO(INTERNAL_JitBreakEmit, W("JitBreakEmit"), (DWORD)-1, "")
-CONFIG_DWORD_INFO(INTERNAL_JitDebuggable, W("JitDebuggable"), 0, "")
-#if !defined(DEBUG) && !defined(_DEBUG)
-#define INTERNAL_JitEnableNoWayAssert_Default 0
-#else
-#define INTERNAL_JitEnableNoWayAssert_Default 1
-#endif
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitEnableNoWayAssert, W("JitEnableNoWayAssert"), INTERNAL_JitEnableNoWayAssert_Default, "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_JitFramed, W("JitFramed"), 0, "Forces EBP frames")
-CONFIG_DWORD_INFO(INTERNAL_JitThrowOnAssertionFailure, W("JitThrowOnAssertionFailure"), 0, "Throw managed exception on assertion failures during JIT instead of failfast")
-CONFIG_DWORD_INFO(INTERNAL_JitGCStress, W("JitGCStress"), 0, "GC stress mode for jit")
-CONFIG_DWORD_INFO(INTERNAL_JitHeartbeat, W("JitHeartbeat"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_JitHelperLogging, W("JitHelperLogging"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_JITMinOpts, W("JITMinOpts"), 0, "Forces MinOpts")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_JitName, W("JitName"), "Primary jit to use")
-CONFIG_STRING_INFO(INTERNAL_JitPath, W("JitPath"), "Full path to primary jit to use")
-#if defined(ALLOW_SXS_JIT)
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_AltJitName, W("AltJitName"), "Alternative jit to use, will fall back to primary jit.")
-CONFIG_STRING_INFO(INTERNAL_AltJitPath, W("AltJitPath"), "Full path to alternative jit to use")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_AltJit, W("AltJit"), "Enables AltJit and selectively limits it to the specified methods.")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_AltJitOs, W("AltJitOS"), "Sets target OS for AltJit or uses native one by default. Only applicable for ARM/AMR64 at the moment.")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_AltJitExcludeAssemblies, W("AltJitExcludeAssemblies"), "Do not use AltJit on this semicolon-delimited list of assemblies.")
-#endif // defined(ALLOW_SXS_JIT)
-#if defined(FEATURE_STACK_SAMPLING)
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StackSamplingEnabled, W("StackSamplingEnabled"), 0, "Is stack sampling based tracking of evolving hot methods enabled.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StackSamplingAfter, W("StackSamplingAfter"), 0, "When to start sampling (for some sort of app steady state), i.e., initial delay for sampling start in milliseconds.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StackSamplingEvery, W("StackSamplingEvery"), 100, "How frequent should thread stacks be sampled in milliseconds.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StackSamplingNumMethods, W("StackSamplingNumMethods"), 32, "Number of evolving methods to track as hot and JIT them in the background at a given point of execution.")
-#endif // defined(FEATURE_JIT_SAMPLING)
-#if defined(ALLOW_SXS_JIT_NGEN)
-RETAIL_CONFIG_STRING_INFO(INTERNAL_AltJitNgen, W("AltJitNgen"), "Enables AltJit for NGEN and selectively limits it to the specified methods.")
-#endif // defined(ALLOW_SXS_JIT_NGEN)
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitHostMaxSlabCache, W("JitHostMaxSlabCache"), 0x1000000, "Sets jit host max slab cache size, 16MB default")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitOptimizeType, W("JitOptimizeType"), 0 /* OPT_DEFAULT */, "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitPrintInlinedMethods, W("JitPrintInlinedMethods"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitTelemetry, W("JitTelemetry"), 1, "If non-zero, gather JIT telemetry data")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_JitTimeLogFile, W("JitTimeLogFile"), "If set, gather JIT throughput data and write to this file.")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_JitTimeLogCsv, W("JitTimeLogCsv"), "If set, gather JIT throughput data and write to a CSV file. This mode must be used in internal retail builds.")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_JitFuncInfoLogFile, W("JitFuncInfoLogFile"), "If set, gather JIT function info and write to this file.")
-CONFIG_DWORD_INFO(INTERNAL_JitVerificationDisable, W("JitVerificationDisable"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitLockWrite, W("JitLockWrite"), 0, "Force all volatile writes to be 'locked'")
-CONFIG_STRING_INFO(INTERNAL_TailCallMax, W("TailCallMax"), "")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_TailCallOpt, W("TailCallOpt"), "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TailCallLoopOpt, W("TailCallLoopOpt"), 1, "Convert recursive tail calls to loops")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_Jit_NetFx40PInvokeStackResilience, W("NetFx40_PInvokeStackResilience"), (DWORD)-1, "Makes P/Invoke resilient against mismatched signature and calling convention (significant perf penalty).")
-#if defined(TARGET_X86)
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_AltJitAssertOnNYI, W("AltJitAssertOnNYI"), 0, "Controls the AltJit behavior of NYI stuff")
-#else
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_AltJitAssertOnNYI, W("AltJitAssertOnNYI"), 1, "Controls the AltJit behavior of NYI stuff")
-#endif
-CONFIG_DWORD_INFO(INTERNAL_JitLargeBranches, W("JitLargeBranches"), 0, "Force using the largest conditional branch format")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitRegisterFP, W("JitRegisterFP"), 3, "Control FP enregistration")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitELTHookEnabled, W("JitELTHookEnabled"), 0, "On ARM, setting this will emit Enter/Leave/TailCall callbacks")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitMemStats, W("JitMemStats"), 0, "Display JIT memory usage statistics")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitVNMapSelBudget, W("JitVNMapSelBudget"), 100, "Max # of MapSelect's considered for a particular top-level invocation.")
-#if defined(TARGET_AMD64) || defined(TARGET_X86) || defined(TARGET_ARM64)
-#define EXTERNAL_FeatureSIMD_Default 1
-#else // !(defined(TARGET_AMD64) || defined(TARGET_X86) || defined(TARGET_ARM64))
-#define EXTERNAL_FeatureSIMD_Default 0
-#endif // !(defined(TARGET_AMD64) || defined(TARGET_X86) || defined(TARGET_ARM64))
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_SIMD16ByteOnly, W("SIMD16ByteOnly"), 0, "Limit maximum SIMD vector length to 16 bytes (used by x64_arm64_altjit)")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TrackDynamicMethodDebugInfo, W("TrackDynamicMethodDebugInfo"), 0, "Specifies whether debug info should be generated and tracked for dynamic methods")
-#ifdef FEATURE_MULTICOREJIT
-RETAIL_CONFIG_STRING_INFO(INTERNAL_MultiCoreJitProfile, W("MultiCoreJitProfile"), "If set, use the file to store/control multi-core JIT.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_MultiCoreJitProfileWriteDelay, W("MultiCoreJitProfileWriteDelay"), 12, "Set the delay after which the multi-core JIT profile will be written to disk.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_MultiCoreJitMinNumCpus, W("MultiCoreJitMinNumCpus"), 2, "Minimum number of cpus that must be present to allow MultiCoreJit usage.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_MultiCoreJitNoProfileGather, W("MultiCoreJitNoProfileGather"), 0, "Set to 1 to disable profile gathering (but leave possibly enabled profile usage).")
-#endif
-#ifdef FEATURE_INTERPRETER
-RETAIL_CONFIG_STRING_INFO(INTERNAL_Interpret, W("Interpret"), "Selectively uses the interpreter to execute the specified methods")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_InterpretExclude, W("InterpretExclude"), "Excludes the specified methods from the set selected by 'Interpret'")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterMethHashMin, W("InterpreterMethHashMin"), 0, "Only interpret methods selected by 'Interpret' whose hash is at least this value. or after nth")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterMethHashMax, W("InterpreterMethHashMax"), UINT32_MAX, "If non-zero, only interpret methods selected by 'Interpret' whose hash is at most this value")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterStubMin, W("InterpreterStubMin"), 0, "Only interpret methods selected by 'Interpret' whose stub num is at least this value.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterStubMax, W("InterpreterStubMax"), UINT32_MAX, "If non-zero, only interpret methods selected by 'Interpret' whose stub number is at most this value.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterJITThreshold, W("InterpreterJITThreshold"), 10, "The number of times a method should be interpreted before being JITted")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterDoLoopMethods, W("InterpreterDoLoopMethods"), 0, "If set, don't check for loops, start by interpreting *all* methods")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterUseCaching, W("InterpreterUseCaching"), 1, "If non-zero, use the caching mechanism.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterLooseRules, W("InterpreterLooseRules"), 1, "If non-zero, allow ECMA spec violations required by managed C++.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterPrintPostMortem, W("InterpreterPrintPostMortem"), 0, "Prints summary information about the execution to the console")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_InterpreterLogFile, W("InterpreterLogFile"), "If non-null, append interpreter logging to this file, else use stdout")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_DumpInterpreterStubs, W("DumpInterpreterStubs"), 0, "Prints all interpreter stubs that are created to the console")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterEntries, W("TraceInterpreterEntries"), 0, "Logs entries to interpreted methods to the console")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterIL, W("TraceInterpreterIL"), 0, "Logs individual instructions of interpreted methods to the console")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterOstack, W("TraceInterpreterOstack"), 0, "Logs operand stack after each IL instruction of interpreted methods to the console")
-CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterVerbose, W("TraceInterpreterVerbose"), 0, "Logs interpreter progress with detailed messages to the console")
-CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterJITTransition, W("TraceInterpreterJITTransition"), 0, "Logs when the interpreter determines a method should be JITted")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ForceInterpreter, W("ForceInterpreter"), 0, "If non-zero, force the interpreter to be used")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterHWIntrinsicsIsSupportedFalse, W("InterpreterHWIntrinsicsIsSupportedFalse"), 0, "If non-zero, force get_IsSupported to return false for hardware intrinsics") // for internal testing purposes
-#endif
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterFallback, W("InterpreterFallback"), 0, "Fallback to the interpreter when the JIT compiler fails")
-CONFIG_DWORD_INFO(INTERNAL_LoaderHeapCallTracing, W("LoaderHeapCallTracing"), 0, "Loader heap troubleshooting")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_CodeHeapReserveForJumpStubs, W("CodeHeapReserveForJumpStubs"), 1, "Percentage of code heap to reserve for jump stubs")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_NGenReserveForJumpStubs, W("NGenReserveForJumpStubs"), 0, "Percentage of ngen image size to reserve for jump stubs")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_BreakOnOutOfMemoryWithinRange, W("BreakOnOutOfMemoryWithinRange"), 0, "Break before out of memory within range exception is thrown")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_LogEnable, W("LogEnable"), 0, "Turns on the traditional CLR log.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_LogFacility,  W("LogFacility"), 0, "Specifies a facility mask for CLR log. (See 'loglf.h'; VM interprets string value as hex number.) Also used by stresslog.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_LogFacility2, W("LogFacility2"), 0, "Specifies a facility mask for CLR log. (See 'loglf.h'; VM interprets string value as hex number.) Also used by stresslog.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_logFatalError, W("logFatalError"), 1, "Specifies whether EventReporter logs fatal errors in the Windows event log.")
-CONFIG_STRING_INFO(INTERNAL_LogFile, W("LogFile"), "Specifies a file name for the CLR log.")
-CONFIG_DWORD_INFO(INTERNAL_LogFileAppend, W("LogFileAppend"), 0 , "Specifies whether to append to or replace the CLR log file.")
-CONFIG_DWORD_INFO(INTERNAL_LogFlushFile, W("LogFlushFile"), 0 , "Specifies whether to flush the CLR log file on each write.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_LogLevel, W("LogLevel"), 0 , "4=10 msgs, 9=1000000, 10=everything")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_LogToConsole, W("LogToConsole"), 0 , "Writes the CLR log to console.")
-CONFIG_DWORD_INFO(INTERNAL_LogToDebugger, W("LogToDebugger"), 0 , "Writes the CLR log to debugger (OutputDebugStringA).")
-CONFIG_DWORD_INFO(INTERNAL_LogToFile, W("LogToFile"), 0 , "Writes the CLR log to a file.")
-CONFIG_DWORD_INFO(INTERNAL_LogWithPid, W("LogWithPid"), FALSE, "Appends pid to filename for the CLR log.")
-CONFIG_DWORD_INFO(INTERNAL_MD_ApplyDeltaBreak, W("MD_ApplyDeltaBreak"), 0, "ASSERT when applying EnC")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_AssertOnBadImageFormat, W("AssertOnBadImageFormat"), 0, "ASSERT when invalid MD read")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_MD_DeltaCheck, W("MD_DeltaCheck"), 1, "Some checks of GUID when applying EnC (?)")
-CONFIG_DWORD_INFO(INTERNAL_MD_EncDelta, W("MD_EncDelta"), 0, "Forces EnC Delta format in MD (?)")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_MD_ForceNoColDesSharing, W("MD_ForceNoColDesSharing"), 0, "Don't know - the only usage I could find is #if 0 (?)")
-CONFIG_DWORD_INFO(INTERNAL_MD_KeepKnownCA, W("MD_KeepKnownCA"), 0, "Something with known CAs (?)")
-CONFIG_DWORD_INFO(INTERNAL_MD_MiniMDBreak, W("MD_MiniMDBreak"), 0, "ASSERT when creating CMiniMdRw class")
-CONFIG_DWORD_INFO(INTERNAL_MD_PreSaveBreak, W("MD_PreSaveBreak"), 0, "ASSERT when calling CMiniMdRw::PreSave")
-CONFIG_DWORD_INFO(INTERNAL_MD_RegMetaBreak, W("MD_RegMetaBreak"), 0, "ASSERT when creating RegMeta class")
-CONFIG_DWORD_INFO(INTERNAL_MD_RegMetaDump, W("MD_RegMetaDump"), 0, "Dump MD in 4 functions (?)")
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_DOTNET_MODIFIABLE_ASSEMBLIES, W("MODIFIABLE_ASSEMBLIES"), "Enables hot reload on debug built assemblies with the 'debug' keyword", CLRConfig::LookupOptions::TrimWhiteSpaceFromStringValue);
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_MD_PreserveDebuggerMetadataMemory, W("MD_PreserveDebuggerMetadataMemory"), 0, "Save all versions of metadata memory in the debugger when debuggee metadata is updated")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinInitialDuration, W("SpinInitialDuration"), 0x32, "Hex value specifying the first spin duration")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinBackoffFactor, W("SpinBackoffFactor"), 0x3, "Hex value specifying the growth of each successive spin duration")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinLimitProcCap, W("SpinLimitProcCap"), 0xFFFFFFFF, "Hex value specifying the largest value of NumProcs to use when calculating the maximum spin duration")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinLimitProcFactor, W("SpinLimitProcFactor"), 0x4E20, "Hex value specifying the multiplier on NumProcs to use when calculating the maximum spin duration")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinLimitConstant, W("SpinLimitConstant"), 0x0, "Hex value specifying the constant to add when calculating the maximum spin duration")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinRetryCount, W("SpinRetryCount"), 0xA, "Hex value specifying the number of times the entire spin process is repeated (when applicable)")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_Monitor_SpinCount, W("Monitor_SpinCount"), 0x1e, "Hex value specifying the maximum number of spin iterations Monitor may perform upon contention on acquiring the lock before waiting.")
-CONFIG_DWORD_INFO(INTERNAL_SymDiffDump, W("SymDiffDump"), 0, "Used to create the map file while binding the assembly. Used by SemanticDiffer")
-RETAIL_CONFIG_DWORD_INFO_EX(EXTERNAL_CORECLR_ENABLE_PROFILING, W("CORECLR_ENABLE_PROFILING"), 0, "CoreCLR only: Flag to indicate whether profiling should be enabled for the currently running process.", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER, W("CORECLR_PROFILER"), "CoreCLR only: Specifies GUID of profiler to load into currently running process", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH, W("CORECLR_PROFILER_PATH"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running process", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH_32, W("CORECLR_PROFILER_PATH_32"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running 32 process", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH_64, W("CORECLR_PROFILER_PATH_64"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running 64 process", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH_ARM32, W("CORECLR_PROFILER_PATH_ARM32"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running ARM32 process", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH_ARM64, W("CORECLR_PROFILER_PATH_ARM64"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running ARM64 process", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_DWORD_INFO_EX(EXTERNAL_CORECLR_ENABLE_NOTIFICATION_PROFILERS, W("CORECLR_ENABLE_NOTIFICATION_PROFILERS"), 0, "Set to 0 to disable loading notification profilers.", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS, W("CORECLR_NOTIFICATION_PROFILERS"), "A semi-colon separated list of notification profilers to load into currently running process in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS_32, W("CORECLR_NOTIFICATION_PROFILERS_32"), "A semi-colon separated list of notification profilers to load into currently running 32 process in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS_64, W("CORECLR_NOTIFICATION_PROFILERS_64"), "A semi-colon separated list of notification profilers to load into currently running 64 process in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS_ARM32, W("CORECLR_NOTIFICATION_PROFILERS_ARM32"), "A semi-colon separated list of notification profilers to load into currently running ARM32 process in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS_ARM64, W("CORECLR_NOTIFICATION_PROFILERS_ARM64"), "A semi-colon separated list of notification profilers to load into currently running ARM64 process in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_ProfAPI_ProfilerCompatibilitySetting, W("ProfAPI_ProfilerCompatibilitySetting"), "Specifies the profiler loading policy (the default is not to load a V2 profiler in V4)", CLRConfig::LookupOptions::TrimWhiteSpaceFromStringValue)
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ProfAPI_DetachMinSleepMs, W("ProfAPI_DetachMinSleepMs"), 0, "The minimum time, in milliseconds, the CLR will wait before checking whether a profiler that is in the process of detaching is ready to be unloaded.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ProfAPI_DetachMaxSleepMs, W("ProfAPI_DetachMaxSleepMs"), 0, "The maximum time, in milliseconds, the CLR will wait before checking whether a profiler that is in the process of detaching is ready to be unloaded.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ProfAPI_RejitOnAttach, W("ProfApi_RejitOnAttach"), 1, "Enables the ability for profilers to rejit methods on attach.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ProfAPI_InliningTracking, W("ProfApi_InliningTracking"), 1, "Enables the runtime's tracking of inlining for profiler ReJIT.")
-CONFIG_DWORD_INFO(INTERNAL_ProfAPI_EnableRejitDiagnostics, W("ProfAPI_EnableRejitDiagnostics"), 0, "Enable extra dumping to stdout of rejit structures")
-CONFIG_DWORD_INFO(INTERNAL_ProfAPIFault, W("ProfAPIFault"), 0, "Test-only bitmask to inject various types of faults in the profapi code")
-CONFIG_DWORD_INFO(INTERNAL_TestOnlyAllowedEventMask, W("TestOnlyAllowedEventMask"), 0, "Test-only bitmask to allow profiler tests to override CLR enforcement of COR_PRF_ALLOWABLE_AFTER_ATTACH and COR_PRF_MONITOR_IMMUTABLE")
-CONFIG_DWORD_INFO(INTERNAL_TestOnlyEnableICorProfilerInfo, W("ProfAPI_TestOnlyEnableICorProfilerInfo"), 0, "Test-only flag to allow attaching profiler tests to call ICorProfilerInfo interface, which would otherwise be disallowed for attaching profilers")
-CONFIG_DWORD_INFO(INTERNAL_TestOnlyEnableObjectAllocatedHook, W("TestOnlyEnableObjectAllocatedHook"), 0, "Test-only flag that forces CLR to initialize on startup as if ObjectAllocated callback were requested, to enable post-attach ObjectAllocated functionality.")
-CONFIG_DWORD_INFO(INTERNAL_TestOnlyEnableSlowELTHooks, W("TestOnlyEnableSlowELTHooks"), 0, "Test-only flag that forces CLR to initialize on startup as if slow-ELT were requested, to enable post-attach ELT functionality.")
-RETAIL_CONFIG_STRING_INFO(UNSUPPORTED_ETW_ObjectAllocationEventsPerTypePerSec, W("ETW_ObjectAllocationEventsPerTypePerSec"), "Desired number of GCSampledObjectAllocation ETW events to be logged per type per second.  If 0, then the default built in to the implementation for the enabled event (e.g., High, Low), will be used.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_ProfAPI_ValidateNGENInstrumentation, W("ProfAPI_ValidateNGENInstrumentation"), 0, "This flag enables additional validations when using the IMetaDataEmit APIs for NGEN'ed images to ensure only supported edits are made.")
-#ifdef FEATURE_PERFMAP
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_PerfMapEnabled, W("PerfMapEnabled"), 0, "This flag is used on Linux to enable writing /tmp/perf-$pid.map. It is disabled by default")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_PerfMapJitDumpPath, W("PerfMapJitDumpPath"), "Specifies a path to write the perf jitdump file. Defaults to GetTempPathA()")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_PerfMapIgnoreSignal, W("PerfMapIgnoreSignal"), 0, "When perf map is enabled, this option will configure the specified signal to be accepted and ignored as a marker in the perf logs.  It is disabled by default")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_PerfMapShowOptimizationTiers, W("PerfMapShowOptimizationTiers"), 1, "Shows optimization tiers in the perf map for methods, as part of the symbol name. Useful for seeing separate stack frames for different optimization tiers of each method.")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_NativeImagePerfMapFormat, W("NativeImagePerfMapFormat"), "Specifies the format of native image perfmap files generated by crossgen.  Valid options are RVA or OFFSET.")
-#endif
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_StartupDelayMS, W("StartupDelayMS"), "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StressLog, W("StressLog"), 0, "Turns on the stress log.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_ForceEnc, W("ForceEnc"), 0, "Forces Edit and Continue to be on for all eligible modules.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StressLogSize, W("StressLogSize"), 0, "Stress log size in bytes per thread.")
-RETAIL_CONFIG_STRING_INFO(UNSUPPORTED_StressLogFilename, W("StressLogFilename"), "Stress log filename for memory mapped stress log.")
-CONFIG_DWORD_INFO(INTERNAL_stressSynchronized, W("stressSynchronized"), 0, "Unknown if or where this is used; unless a test is specifically depending on this, it can be removed.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TotalStressLogSize, W("TotalStressLogSize"), 0, "Total stress log size in bytes.")
-CONFIG_DWORD_INFO(INTERNAL_DiagnosticSuspend, W("DiagnosticSuspend"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_SuspendDeadlockTimeout, W("SuspendDeadlockTimeout"), 40000, "")
-CONFIG_DWORD_INFO(INTERNAL_SuspendThreadDeadlockTimeoutMs, W("SuspendThreadDeadlockTimeoutMs"), 2000, "")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadSuspendInjection, W("INTERNAL_ThreadSuspendInjection"), 1, "Specifies whether to inject activations for thread suspension on Unix")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_DefaultStackSize, W("DefaultStackSize"), 0, "Stack size to use for new VM threads when thread is created with default stack size (dwStackSize == 0).")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_Thread_DeadThreadCountThresholdForGCTrigger, W("Thread_DeadThreadCountThresholdForGCTrigger"), 75, "In the heuristics to clean up dead threads, this threshold must be reached before triggering a GC will be considered. Set to 0 to disable triggering a GC based on dead threads.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_Thread_DeadThreadGCTriggerPeriodMilliseconds, W("Thread_DeadThreadGCTriggerPeriodMilliseconds"), 1000 * 60 * 30, "In the heuristics to clean up dead threads, this much time must have elapsed since the previous max-generation GC before triggering another GC will be considered")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_Thread_UseAllCpuGroups, W("Thread_UseAllCpuGroups"), 0, "Specifies whether to query and use CPU group information for determining the processor count.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_Thread_AssignCpuGroups, W("Thread_AssignCpuGroups"), 1, "Specifies whether to automatically distribute threads created by the CLR across CPU Groups. Effective only when Thread_UseAllCpuGroups and GCCpuGroup are enabled.")
-RETAIL_CONFIG_DWORD_INFO_EX(EXTERNAL_ProcessorCount, W("PROCESSOR_COUNT"), 0, "Specifies the number of processors available for the process, which is returned by Environment.ProcessorCount", CLRConfig::LookupOptions::ParseIntegerAsBase10)
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_UsePortableThreadPool, W("ThreadPool_UsePortableThreadPool"), 1, "Uses the managed portable thread pool implementation instead of the unmanaged one.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_UsePortableThreadPoolForIO, W("ThreadPool_UsePortableThreadPoolForIO"), 1, "Uses the managed portable thread pool implementation instead of the unmanaged one for async IO.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_ForceMinWorkerThreads, W("ThreadPool_ForceMinWorkerThreads"), 0, "Overrides the MinThreads setting for the ThreadPool worker pool")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_ForceMaxWorkerThreads, W("ThreadPool_ForceMaxWorkerThreads"), 0, "Overrides the MaxThreads setting for the ThreadPool worker pool")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_DisableStarvationDetection, W("ThreadPool_DisableStarvationDetection"), 0, "Disables the ThreadPool feature that forces new threads to be added when workitems run for too long")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_DebugBreakOnWorkerStarvation, W("ThreadPool_DebugBreakOnWorkerStarvation"), 0, "Breaks into the debugger if the ThreadPool detects work queue starvation")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_EnableWorkerTracking, W("ThreadPool_EnableWorkerTracking"), 0, "Enables extra expensive tracking of how many workers threads are working simultaneously")
-#ifdef TARGET_ARM64
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_UnfairSemaphoreSpinLimit, W("ThreadPool_UnfairSemaphoreSpinLimit"), 0x32, "Maximum number of spins per processor a thread pool worker thread performs before waiting for work")
-#else // !TARGET_ARM64
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_UnfairSemaphoreSpinLimit, W("ThreadPool_UnfairSemaphoreSpinLimit"), 0x46, "Maximum number of spins a thread pool worker thread performs before waiting for work")
-#endif // TARGET_ARM64
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_Disable,                             W("HillClimbing_Disable"),                            0, "Disables hill climbing for thread adjustments in the thread pool");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_WavePeriod,                          W("HillClimbing_WavePeriod"),                         4, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_TargetSignalToNoiseRatio,            W("HillClimbing_TargetSignalToNoiseRatio"),           300, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_ErrorSmoothingFactor,                W("HillClimbing_ErrorSmoothingFactor"),               1, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_WaveMagnitudeMultiplier,             W("HillClimbing_WaveMagnitudeMultiplier"),            100, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_MaxWaveMagnitude,                    W("HillClimbing_MaxWaveMagnitude"),                   20, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_WaveHistorySize,                     W("HillClimbing_WaveHistorySize"),                    8, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_Bias,                                W("HillClimbing_Bias"),                               15, "The 'cost' of a thread.  0 means drive for increased throughput regardless of thread count; higher values bias more against higher thread counts.");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_MaxChangePerSecond,                  W("HillClimbing_MaxChangePerSecond"),                 4, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_MaxChangePerSample,                  W("HillClimbing_MaxChangePerSample"),                 20, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_MaxSampleErrorPercent,               W("HillClimbing_MaxSampleErrorPercent"),              15, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_SampleIntervalLow,                   W("HillClimbing_SampleIntervalLow"),                  10, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_SampleIntervalHigh,                  W("HillClimbing_SampleIntervalHigh"),                 200, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_GainExponent,                        W("HillClimbing_GainExponent"),                       200, "The exponent to apply to the gain, times 100.  100 means to use linear gain, higher values will enhance large moves and damp small ones.");
-#ifdef FEATURE_TIERED_COMPILATION
-#ifdef _DEBUG
-#define TC_BackgroundWorkerTimeoutMs (100)
-#define TC_CallCountThreshold (2)
-#define TC_CallCountingDelayMs (1)
-#define TC_DelaySingleProcMultiplier (2)
-#else // !_DEBUG
-#define TC_BackgroundWorkerTimeoutMs (4000)
-#define TC_CallCountThreshold (30)
-#define TC_CallCountingDelayMs (100)
-#define TC_DelaySingleProcMultiplier (10)
-#endif // _DEBUG
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TieredCompilation, W("TieredCompilation"), 1, "Enables tiered compilation")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TC_QuickJit, W("TC_QuickJit"), 1, "For methods that would be jitted, enable using quick JIT when appropriate.")
-#if defined(TARGET_AMD64) || defined(TARGET_ARM64)
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TC_QuickJitForLoops, W("TC_QuickJitForLoops"), 1, "When quick JIT is enabled, quick JIT may also be used for methods that contain loops.")
-#else // !(defined(TARGET_AMD64) || defined(TARGET_ARM64))
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TC_QuickJitForLoops, W("TC_QuickJitForLoops"), 0, "When quick JIT is enabled, quick JIT may also be used for methods that contain loops.")
-#endif // defined(TARGET_AMD64) || defined(TARGET_ARM64)
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TC_AggressiveTiering, W("TC_AggressiveTiering"), 0, "Transition through tiers aggressively.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_BackgroundWorkerTimeoutMs, W("TC_BackgroundWorkerTimeoutMs"), TC_BackgroundWorkerTimeoutMs, "How long in milliseconds the background worker thread may remain idle before exiting.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_CallCountThreshold, W("TC_CallCountThreshold"), TC_CallCountThreshold, "Number of times a method must be called in tier 0 after which it is promoted to the next tier.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_CallCountingDelayMs, W("TC_CallCountingDelayMs"), TC_CallCountingDelayMs, "A perpetual delay in milliseconds that is applied to call counting in tier 0 and jitting at higher tiers, while there is startup-like activity.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_DelaySingleProcMultiplier, W("TC_DelaySingleProcMultiplier"), TC_DelaySingleProcMultiplier, "Multiplier for TC_CallCountingDelayMs that is applied on a single-processor machine or when the process is affinitized to a single processor.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_CallCounting, W("TC_CallCounting"), 1, "Enabled by default (only activates when TieredCompilation is also enabled). If disabled immediately backpatches prestub, and likely prevents any promotion to higher tiers")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_UseCallCountingStubs, W("TC_UseCallCountingStubs"), 1, "Uses call counting stubs for faster call counting.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_DeleteCallCountingStubsAfter, W("TC_DeleteCallCountingStubsAfter"), 0, "Deletes call counting stubs after this many have completed. Zero to disable deleting.")
-#undef TC_BackgroundWorkerTimeoutMs
-#undef TC_CallCountThreshold
-#undef TC_CallCountingDelayMs
-#undef TC_DelaySingleProcMultiplier
-#undef TC_DeleteCallCountingStubsAfter
-#endif // FEATURE_TIERED_COMPILATION
-#ifdef FEATURE_ON_STACK_REPLACEMENT
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_OSR_CounterBump, W("OSR_CounterBump"), 1000, "Counter reload value when a patchpoint is hit")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_OSR_HitLimit, W("OSR_HitLimit"), 10, "Number of times a patchpoint must call back to trigger an OSR transition")
-CONFIG_DWORD_INFO(INTERNAL_OSR_LowId, W("OSR_LowId"), (DWORD)-1, "Low end of enabled patchpoint range (inclusive)");
-CONFIG_DWORD_INFO(INTERNAL_OSR_HighId, W("OSR_HighId"), 10000000, "High end of enabled patchpoint range (inclusive)");
-#endif
-#ifdef FEATURE_PGO
-RETAIL_CONFIG_STRING_INFO(INTERNAL_PGODataPath, W("PGODataPath"), "Read/Write PGO data from/to the indicated file.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ReadPGOData, W("ReadPGOData"), 0, "Read PGO data")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_WritePGOData, W("WritePGOData"), 0, "Write PGO data")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TieredPGO, W("TieredPGO"), 0, "Instrument Tier0 code and make counts available to Tier1")
-#endif
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_BackpatchEntryPointSlots, W("BackpatchEntryPointSlots"), 1, "Indicates whether to enable entry point slot backpatching, for instance to avoid making virtual calls through a precode and instead to patch virtual slots for a method when its entry point changes.")
-CONFIG_DWORD_INFO(INTERNAL_TypeLoader_InjectInterfaceDuplicates, W("INTERNAL_TypeLoader_InjectInterfaceDuplicates"), 0, "Injects duplicates in interface map for all types.")
-CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubCollideMonoPct, W("VirtualCallStubCollideMonoPct"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
-CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubCollideWritePct, W("VirtualCallStubCollideWritePct"), 100, "Used only when STUB_LOGGING is defined, which by default is not.")
-CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubDumpLogCounter, W("VirtualCallStubDumpLogCounter"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
-CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubDumpLogIncr, W("VirtualCallStubDumpLogIncr"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_VirtualCallStubLogging, W("VirtualCallStubLogging"), 0, "Worth keeping, but should be moved into \"#ifdef STUB_LOGGING\" blocks. This goes for most (or all) of the stub logging infrastructure.")
-CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubMissCount, W("VirtualCallStubMissCount"), 100, "Used only when STUB_LOGGING is defined, which by default is not.")
-CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubResetCacheCounter, W("VirtualCallStubResetCacheCounter"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
-CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubResetCacheIncr, W("VirtualCallStubResetCacheIncr"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_DisableWatsonForManagedExceptions, W("DisableWatsonForManagedExceptions"), 0, "Disable Watson and debugger launching for managed exceptions")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgEnableMiniDump, W("DbgEnableMiniDump"), 0, "Enable unhandled exception crash dump generation")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_DbgMiniDumpName, W("DbgMiniDumpName"), "Crash dump name")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgMiniDumpType, W("DbgMiniDumpType"), 0, "Crash dump type: 1 normal, 2 withheap, 3 triage, 4 full")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_CreateDumpDiagnostics, W("CreateDumpDiagnostics"), 0, "Enable crash dump generation diagnostic logging")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EnableDumpOnSigTerm, W("EnableDumpOnSigTerm"), 0, "Enable crash dump generation on SIGTERM")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_ZapBBInstr, W("ZapBBInstr"), "")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_ZapBBInstrDir, W("ZapBBInstrDir"), "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ZapDisable, W("ZapDisable"), 0, "")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_NativeImageSearchPaths, W("NativeImageSearchPaths"), "Extra search paths for native composite R2R images")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ReadyToRun, W("ReadyToRun"), 1, "Enable/disable use of ReadyToRun native code") // On by default for CoreCLR
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_ReadyToRunExcludeList, W("ReadyToRunExcludeList"), "List of assemblies that cannot use Ready to Run images")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_ReadyToRunLogFile, W("ReadyToRunLogFile"), "Name of file to log success/failure of using Ready to Run images")
-#if defined(FEATURE_EVENT_TRACE) || defined(FEATURE_EVENTSOURCE_XPLAT)
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableEventLog, W("EnableEventLog"), 0, "Enable/disable use of EnableEventLogging mechanism ") // Off by default
-RETAIL_CONFIG_STRING_INFO(INTERNAL_EventSourceFilter, W("EventSourceFilter"), "")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_EventNameFilter, W("EventNameFilter"), "")
-#endif //defined(FEATURE_EVENT_TRACE) || defined(FEATURE_EVENTSOURCE_XPLAT)
-CONFIG_DWORD_INFO(INTERNAL_ExposeExceptionsInCOM, W("ExposeExceptionsInCOM"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_InteropValidatePinnedObjects, W("InteropValidatePinnedObjects"), 0, "After returning from a managed-to-unmanaged interop call, validate GC heap around objects pinned by IL stubs.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_InteropLogArguments, W("InteropLogArguments"), 0, "Log all pinned arguments passed to an interop call")
-RETAIL_CONFIG_STRING_INFO(UNSUPPORTED_LogCCWRefCountChange, W("LogCCWRefCountChange"), "Outputs debug information and calls LogCCWRefCountChange_BREAKPOINT when AddRef or Release is called on a CCW.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EnableRCWCleanupOnSTAShutdown, W("EnableRCWCleanupOnSTAShutdown"), 0, "Performs RCW cleanup when STA shutdown is detected using IInitializeSpy in classic processes.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EnableEventPipe, W("EnableEventPipe"), 0, "Enable/disable event pipe.  Non-zero values enable tracing.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeNetTraceFormat, W("EventPipeNetTraceFormat"), 1, "Enable/disable using the newer nettrace file format.")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_EventPipeOutputPath, W("EventPipeOutputPath"), "The full path excluding file name for the trace file that will be written when COMPlus_EnableEventPipe=1")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_EventPipeConfig, W("EventPipeConfig"), "Configuration for EventPipe.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeRundown, W("EventPipeRundown"), 1, "Enable/disable eventpipe rundown.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeCircularMB, W("EventPipeCircularMB"), 1024, "The EventPipe circular buffer size in megabytes.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeProcNumbers, W("EventPipeProcNumbers"), 0, "Enable/disable capturing processor numbers in EventPipe event headers")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeOutputStreaming, W("EventPipeOutputStreaming"), 0, "Enable/disable streaming for trace file set in COMPlus_EventPipeOutputPath.  Non-zero values enable streaming.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeEnableStackwalk, W("EventPipeEnableStackwalk"), 1, "Set to 0 to disable collecting stacks for EventPipe events.")
-#ifdef FEATURE_AUTO_TRACE
-RETAIL_CONFIG_DWORD_INFO_EX(INTERNAL_AutoTrace_N_Tracers, W("AutoTrace_N_Tracers"), 0, "", CLRConfig::LookupOptions::ParseIntegerAsBase10)
-RETAIL_CONFIG_STRING_INFO(INTERNAL_AutoTrace_Command, W("AutoTrace_Command"), "")
-#endif // FEATURE_AUTO_TRACE
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisGen, W("GCGenAnalysisGen"), 0, "The generation to trigger generational aware analysis")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisBytes, W("GCGenAnalysisBytes"), 0, "The number of bytes to trigger generational aware analysis")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisTimeUSec, W("GCGenAnalysisTimeUSec"), 0, "The number of microseconds to trigger generational aware analysis")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisTimeMSec, W("GCGenAnalysisTimeMSec"), 0, "The number of milliseconds to trigger generational aware analysis")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisIndex, W("GCGenAnalysisIndex"), 0, "The gc index to trigger generational aware analysis")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_GCGenAnalysisCmd, W("GCGenAnalysisCmd"), "An optional filter to match with the command line used to spawn the process")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisTrace, W("GCGenAnalysisTrace"), 1, "Enable/Disable capturing a trace")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisDump, W("GCGenAnalysisDump"), 0, "Enable/Disable capturing a dump")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_DOTNET_DefaultDiagnosticPortSuspend, W("DefaultDiagnosticPortSuspend"), 0, "This sets the deafult diagnostic port to suspend causing the runtime to pause during startup before major subsystems are started.  Resume using the Diagnostics IPC ResumeStartup command on the default diagnostic port.");
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_DOTNET_DiagnosticPorts, W("DiagnosticPorts"), "A semicolon delimited list of additional Diagnostic Ports, where a Diagnostic Port is a NamedPipe path without '\\\\.\\pipe\\' on Windows or the full path of Unix Domain Socket on Linux/Unix followed by optional tags, e.g., '<path>,connect,nosuspend;<path>'");
-RETAIL_CONFIG_STRING_INFO(INTERNAL_LTTngConfig, W("LTTngConfig"), "Configuration for LTTng.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_LTTng, W("LTTng"), 1, "If COMPlus_LTTng is set to 0, this will prevent the LTTng library from being loaded at runtime")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableWriteXorExecute, W("EnableWriteXorExecute"), 1, "Enable W^X for executable memory.");
-#ifdef FEATURE_GDBJIT
-CONFIG_STRING_INFO(INTERNAL_GDBJitElfDump, W("GDBJitElfDump"), "Dump ELF for specified method")
-#ifdef FEATURE_GDBJIT_FRAME
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_GDBJitEmitDebugFrame, W("GDBJitEmitDebugFrame"), TRUE, "Enable .debug_frame generation")
-#endif
-#endif
-#if defined(TARGET_LOONGARCH64)
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableHWIntrinsic,  W("EnableHWIntrinsic"),  0, "Allows Base+ hardware intrinsics to be disabled")
-#else
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableHWIntrinsic,  W("EnableHWIntrinsic"),  1, "Allows Base+ hardware intrinsics to be disabled")
-#endif // defined(TARGET_LOONGARCH64)
-#if defined(TARGET_AMD64) || defined(TARGET_X86)
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableAES,          W("EnableAES"),          1, "Allows AES+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableAVX,          W("EnableAVX"),          1, "Allows AVX+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableAVX2,         W("EnableAVX2"),         1, "Allows AVX2+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableAVXVNNI,      W("EnableAVXVNNI"),      1, "Allows AVX VNNI+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableBMI1,         W("EnableBMI1"),         1, "Allows BMI1+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableBMI2,         W("EnableBMI2"),         1, "Allows BMI2+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableFMA,          W("EnableFMA"),          1, "Allows FMA+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableLZCNT,        W("EnableLZCNT"),        1, "Allows LZCNT+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnablePCLMULQDQ,    W("EnablePCLMULQDQ"),    1, "Allows PCLMULQDQ+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableMOVBE,        W("EnableMOVBE"),        1, "Allows MOVBE+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnablePOPCNT,       W("EnablePOPCNT"),       1, "Allows POPCNT+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSE,          W("EnableSSE"),          1, "Allows SSE+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSE2,         W("EnableSSE2"),         1, "Allows SSE2+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSE3,         W("EnableSSE3"),         1, "Allows SSE3+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSE3_4,       W("EnableSSE3_4"),       1, "Allows SSE3+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSE41,        W("EnableSSE41"),        1, "Allows SSE4.1+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSE42,        W("EnableSSE42"),        1, "Allows SSE4.2+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSSE3,        W("EnableSSSE3"),        1, "Allows SSSE3+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableX86Serialize, W("EnableX86Serialize"), 1, "Allows X86Serialize+ hardware intrinsics to be disabled")
-#elif defined(TARGET_ARM64)
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64AdvSimd, W("EnableArm64AdvSimd"), 1, "Allows Arm64 AdvSimd+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Aes,     W("EnableArm64Aes"),     1, "Allows Arm64 Aes+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Atomics, W("EnableArm64Atomics"), 1, "Allows Arm64 Atomics+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Crc32,   W("EnableArm64Crc32"),   1, "Allows Arm64 Crc32+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Dczva,   W("EnableArm64Dczva"),   1, "Allows Arm64 Dczva+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Dp,      W("EnableArm64Dp"),      1, "Allows Arm64 Dp+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Rdm,     W("EnableArm64Rdm"),     1, "Allows Arm64 Rdm+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Sha1,    W("EnableArm64Sha1"),    1, "Allows Arm64 Sha1+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Sha256,  W("EnableArm64Sha256"),  1, "Allows Arm64 Sha256+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Rcpc,    W("EnableArm64Rcpc"),    1, "Allows Arm64 Rcpc+ hardware intrinsics to be disabled")
-#endif
-CONFIG_DWORD_INFO(INTERNAL_ActivatePatchSkip, W("ActivatePatchSkip"), 0, "Allows an assert when ActivatePatchSkip is called")
-CONFIG_DWORD_INFO(INTERNAL_AlwaysUseMetadataInterfaceMapLayout, W("AlwaysUseMetadataInterfaceMapLayout"), 0, "Used for debugging generic interface map layout.")
-CONFIG_DWORD_INFO(INTERNAL_AssertOnUnneededThis, W("AssertOnUnneededThis"), 0, "While the ConfigDWORD is unnecessary, the contained ASSERT should be kept. This may result in some work tracking down violating MethodDescCallSites.")
-CONFIG_DWORD_INFO(INTERNAL_AssertStacktrace, W("AssertStacktrace"), 1, "")
-CONFIG_DWORD_INFO(INTERNAL_clearNativeImageStress, W("clearNativeImageStress"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_CPUFamily, W("CPUFamily"), 0xFFFFFFFF, "")
-CONFIG_DWORD_INFO(INTERNAL_CPUFeatures, W("CPUFeatures"), 0xFFFFFFFF, "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_DisableConfigCache, W("DisableConfigCache"), 0, "Used to disable the \"probabilistic\" config cache, which walks through the appropriate config registry keys on init and probabilistically keeps track of which exist.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_DisableStackwalkCache, W("DisableStackwalkCache"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DoubleArrayToLargeObjectHeap, W("DoubleArrayToLargeObjectHeap"), 0, "Controls double[] placement")
-CONFIG_STRING_INFO(INTERNAL_DumpOnClassLoad, W("DumpOnClassLoad"), "Dumps information about loaded class to log.")
-CONFIG_DWORD_INFO(INTERNAL_ExpandAllOnLoad, W("ExpandAllOnLoad"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_ForceRelocs, W("ForceRelocs"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_GenerateLongJumpDispatchStubRatio, W("GenerateLongJumpDispatchStubRatio"), 0, "Useful for testing VSD on AMD64")
-CONFIG_DWORD_INFO(INTERNAL_HashStack, W("HashStack"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_HostManagerConfig, W("HostManagerConfig"), (DWORD)-1, "")
-CONFIG_DWORD_INFO(INTERNAL_HostTestThreadAbort, W("HostTestThreadAbort"), 0, "")
-CONFIG_STRING_INFO(INTERNAL_InvokeHalt, W("InvokeHalt"), "Throws an assert when the given method is invoked through reflection.")
-CONFIG_DWORD_INFO(INTERNAL_MaxStubUnwindInfoSegmentSize, W("MaxStubUnwindInfoSegmentSize"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_MessageDebugOut, W("MessageDebugOut"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_NativeImageRequire, W("NativeImageRequire"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_NestedEhOom, W("NestedEhOom"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_NoProcedureSplitting, W("NoProcedureSplitting"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_PauseOnLoad, W("PauseOnLoad"), 0, "Stops in SystemDomain::init. I think it can be removed.")
-CONFIG_DWORD_INFO(INTERNAL_PerfAllocsSizeThreshold, W("PerfAllocsSizeThreshold"), 0x3FFFFFFF, "Log facility LF_GCALLOC logs object allocations. This flag controls which ones also log stacktraces. Predates ClrProfiler.")
-CONFIG_DWORD_INFO(INTERNAL_PerfNumAllocsThreshold, W("PerfNumAllocsThreshold"), 0x3FFFFFFF, "Log facility LF_GCALLOC logs object allocations. This flag controls which ones also log stacktraces. Predates ClrProfiler.")
-CONFIG_STRING_INFO(INTERNAL_PerfTypesToLog, W("PerfTypesToLog"), "Log facility LF_GCALLOC logs object allocations. This flag controls which ones also log stacktraces. Predates ClrProfiler.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_Prepopulate1, W("Prepopulate1"), 1, "")
-CONFIG_STRING_INFO(INTERNAL_PrestubGC, W("PrestubGC"), "")
-CONFIG_STRING_INFO(INTERNAL_PrestubHalt, W("PrestubHalt"), "")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_RestrictedGCStressExe, W("RestrictedGCStressExe"), "")
-CONFIG_DWORD_INFO(INTERNAL_ReturnSourceTypeForTesting, W("ReturnSourceTypeForTesting"), 0, "Allows returning the (internal only) source type of an IL to Native mapping for debugging purposes")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_RSStressLog, W("RSStressLog"), 0, "Allows turning on logging for RS startup")
-CONFIG_DWORD_INFO(INTERNAL_SBDumpOnNewIndex, W("SBDumpOnNewIndex"), 0, "Used for Syncblock debugging. It's been a while since any of those have been used.")
-CONFIG_DWORD_INFO(INTERNAL_SBDumpOnResize, W("SBDumpOnResize"), 0, "Used for Syncblock debugging. It's been a while since any of those have been used.")
-CONFIG_DWORD_INFO(INTERNAL_SBDumpStyle, W("SBDumpStyle"), 0, "Used for Syncblock debugging. It's been a while since any of those have been used.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_SleepOnExit, W("SleepOnExit"), 0, "Used for lrak detection. I'd say deprecated by umdh.")
-CONFIG_DWORD_INFO(INTERNAL_StubLinkerUnwindInfoVerificationOn, W("StubLinkerUnwindInfoVerificationOn"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_SuccessExit, W("SuccessExit"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TestDataConsistency, W("TestDataConsistency"), FALSE, "Allows ensuring the left side is not holding locks (and may thus be in an inconsistent state) when inspection occurs")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ThreadGuardPages, W("ThreadGuardPages"), 0, "")
-#ifdef _DEBUG
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TraceWrap, W("TraceWrap"), 0, "")
-#endif
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_UseMethodDataCache, W("UseMethodDataCache"), FALSE, "Used during feature development; may now be removed.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_UseParentMethodData, W("UseParentMethodData"), TRUE, "Used during feature development; may now be removed.")
-CONFIG_DWORD_INFO(INTERNAL_VerifierOff, W("VerifierOff"), 0, "")

--- a/src/coreclr/nativeaot/Runtime/unix/PalRedhawkUnix.cpp
+++ b//dev/null
@@ -1,1082 +0,0 @@
-#include <stdio.h>
-#include <errno.h>
-#include <cwchar>
-#include <sal.h>
-#include "config.h"
-#include "UnixHandle.h"
-#include <pthread.h>
-#include "gcenv.h"
-#include "gcenv.ee.h"
-#include "gcconfig.h"
-#include "holder.h"
-#include "UnixSignals.h"
-#include "UnixContext.h"
-#include "HardwareExceptions.h"
-#include "cgroupcpu.h"
-#define _T(s) s
-#include "RhConfig.h"
-#include <unistd.h>
-#include <sched.h>
-#include <sys/mman.h>
-#include <sys/types.h>
-#include <sys/syscall.h>
-#include <dlfcn.h>
-#include <dirent.h>
-#include <string.h>
-#include <ctype.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <sys/time.h>
-#include <cstdarg>
-#include <signal.h>
-#if HAVE_PTHREAD_GETTHREADID_NP
-#include <pthread_np.h>
-#endif
-#if HAVE_LWP_SELF
-#include <lwp.h>
-#endif
-#if HAVE_SYS_VMPARAM_H
-#include <sys/vmparam.h>
-#endif  // HAVE_SYS_VMPARAM_H
-#if HAVE_MACH_VM_TYPES_H
-#include <mach/vm_types.h>
-#endif // HAVE_MACH_VM_TYPES_H
-#if HAVE_MACH_VM_PARAM_H
-#include <mach/vm_param.h>
-#endif  // HAVE_MACH_VM_PARAM_H
-#ifdef __APPLE__
-#include <mach/vm_statistics.h>
-#include <mach/mach_types.h>
-#include <mach/mach_init.h>
-#include <mach/mach_host.h>
-#include <mach/mach_port.h>
-#endif // __APPLE__
-#if HAVE_CLOCK_GETTIME_NSEC_NP
-#include <time.h>
-#endif
-using std::nullptr_t;
-#define PalRaiseFailFastException RaiseFailFastException
-#define INVALID_HANDLE_VALUE    ((HANDLE)(intptr_t)-1)
-#define PAGE_NOACCESS           0x01
-#define PAGE_READWRITE          0x04
-#define PAGE_EXECUTE_READ       0x20
-#define PAGE_EXECUTE_READWRITE  0x40
-#define MEM_COMMIT              0x1000
-#define MEM_RESERVE             0x2000
-#define MEM_DECOMMIT            0x4000
-#define MEM_RELEASE             0x8000
-#define WAIT_OBJECT_0           0
-#define WAIT_TIMEOUT            258
-#define WAIT_FAILED             0xFFFFFFFF
-static const int tccSecondsToMilliSeconds = 1000;
-static const int tccSecondsToMicroSeconds = 1000000;
-static const int tccSecondsToNanoSeconds = 1000000000;
-static const int tccMilliSecondsToMicroSeconds = 1000;
-static const int tccMilliSecondsToNanoSeconds = 1000000;
-static const int tccMicroSecondsToNanoSeconds = 1000;
-extern "C" void RaiseFailFastException(PEXCEPTION_RECORD arg1, PCONTEXT arg2, uint32_t arg3)
-{
-    abort();
-}
-static void TimeSpecAdd(timespec* time, uint32_t milliseconds)
-{
-    uint64_t nsec = time->tv_nsec + (uint64_t)milliseconds * tccMilliSecondsToNanoSeconds;
-    if (nsec >= tccSecondsToNanoSeconds)
-    {
-        time->tv_sec += nsec / tccSecondsToNanoSeconds;
-        nsec %= tccSecondsToNanoSeconds;
-    }
-    time->tv_nsec = nsec;
-}
-static void NanosecondsToTimeSpec(uint64_t nanoseconds, timespec* t)
-{
-    t->tv_sec = nanoseconds / tccSecondsToNanoSeconds;
-    t->tv_nsec = nanoseconds % tccSecondsToNanoSeconds;
-}
-void ReleaseCondAttr(pthread_condattr_t* condAttr)
-{
-    int st = pthread_condattr_destroy(condAttr);
-    ASSERT_MSG(st == 0, "Failed to destroy pthread_condattr_t object");
-}
-class PthreadCondAttrHolder : public Wrapper<pthread_condattr_t*, DoNothing, ReleaseCondAttr, nullptr>
-{
-public:
-    PthreadCondAttrHolder(pthread_condattr_t* attrs)
-    : Wrapper<pthread_condattr_t*, DoNothing, ReleaseCondAttr, nullptr>(attrs)
-    {
-    }
-};
-class UnixEvent
-{
-    pthread_cond_t m_condition;
-    pthread_mutex_t m_mutex;
-    bool m_manualReset;
-    bool m_state;
-    bool m_isValid;
-public:
-    UnixEvent(bool manualReset, bool initialState)
-    : m_manualReset(manualReset),
-      m_state(initialState),
-      m_isValid(false)
-    {
-    }
-    bool Initialize()
-    {
-        pthread_condattr_t attrs;
-        int st = pthread_condattr_init(&attrs);
-        if (st != 0)
-        {
-            ASSERT_UNCONDITIONALLY("Failed to initialize UnixEvent condition attribute");
-            return false;
-        }
-        PthreadCondAttrHolder attrsHolder(&attrs);
-#if HAVE_PTHREAD_CONDATTR_SETCLOCK && !HAVE_CLOCK_GETTIME_NSEC_NP
-        st = pthread_condattr_setclock(&attrs, CLOCK_MONOTONIC);
-        if (st != 0)
-        {
-            ASSERT_UNCONDITIONALLY("Failed to set UnixEvent condition variable wait clock");
-            return false;
-        }
-#endif // HAVE_PTHREAD_CONDATTR_SETCLOCK && !HAVE_CLOCK_GETTIME_NSEC_NP
-        st = pthread_mutex_init(&m_mutex, NULL);
-        if (st != 0)
-        {
-            ASSERT_UNCONDITIONALLY("Failed to initialize UnixEvent mutex");
-            return false;
-        }
-        st = pthread_cond_init(&m_condition, &attrs);
-        if (st != 0)
-        {
-            ASSERT_UNCONDITIONALLY("Failed to initialize UnixEvent condition variable");
-            st = pthread_mutex_destroy(&m_mutex);
-            ASSERT_MSG(st == 0, "Failed to destroy UnixEvent mutex");
-            return false;
-        }
-        m_isValid = true;
-        return true;
-    }
-    bool Destroy()
-    {
-        bool success = true;
-        if (m_isValid)
-        {
-            int st = pthread_mutex_destroy(&m_mutex);
-            ASSERT_MSG(st == 0, "Failed to destroy UnixEvent mutex");
-            success = success && (st == 0);
-            st = pthread_cond_destroy(&m_condition);
-            ASSERT_MSG(st == 0, "Failed to destroy UnixEvent condition variable");
-            success = success && (st == 0);
-        }
-        return success;
-    }
-    uint32_t Wait(uint32_t milliseconds)
-    {
-        timespec endTime;
-#if HAVE_CLOCK_GETTIME_NSEC_NP
-        uint64_t endNanoseconds;
-        if (milliseconds != INFINITE)
-        {
-            uint64_t nanoseconds = (uint64_t)milliseconds * tccMilliSecondsToNanoSeconds;
-            NanosecondsToTimeSpec(nanoseconds, &endTime);
-            endNanoseconds = clock_gettime_nsec_np(CLOCK_UPTIME_RAW) + nanoseconds;
-        }
-#elif HAVE_PTHREAD_CONDATTR_SETCLOCK
-        if (milliseconds != INFINITE)
-        {
-            clock_gettime(CLOCK_MONOTONIC, &endTime);
-            TimeSpecAdd(&endTime, milliseconds);
-        }
-#else
-#error "Don't know how to perform timed wait on this platform"
-#endif
-        int st = 0;
-        pthread_mutex_lock(&m_mutex);
-        while (!m_state)
-        {
-            if (milliseconds == INFINITE)
-            {
-                st = pthread_cond_wait(&m_condition, &m_mutex);
-            }
-            else
-            {
-#if HAVE_CLOCK_GETTIME_NSEC_NP
-                st = pthread_cond_timedwait_relative_np(&m_condition, &m_mutex, &endTime);
-                if ((st == 0) && !m_state)
-                {
-                    uint64_t currentNanoseconds = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
-                    if (currentNanoseconds < endNanoseconds)
-                    {
-                        uint64_t remainingNanoseconds = (endNanoseconds - currentNanoseconds);
-                        NanosecondsToTimeSpec(remainingNanoseconds, &endTime);
-                    }
-                    else
-                    {
-                        st = ETIMEDOUT;
-                    }
-                }
-#else // HAVE_CLOCK_GETTIME_NSEC_NP
-                st = pthread_cond_timedwait(&m_condition, &m_mutex, &endTime);
-#endif // HAVE_CLOCK_GETTIME_NSEC_NP
-                ASSERT((st != ETIMEDOUT) || !m_state);
-            }
-            if (st != 0)
-            {
-                break;
-            }
-        }
-        if ((st == 0) && !m_manualReset)
-        {
-            m_state = false;
-        }
-        pthread_mutex_unlock(&m_mutex);
-        uint32_t waitStatus;
-        if (st == 0)
-        {
-            waitStatus = WAIT_OBJECT_0;
-        }
-        else if (st == ETIMEDOUT)
-        {
-            waitStatus = WAIT_TIMEOUT;
-        }
-        else
-        {
-            waitStatus = WAIT_FAILED;
-        }
-        return waitStatus;
-    }
-    void Set()
-    {
-        pthread_mutex_lock(&m_mutex);
-        m_state = true;
-        pthread_cond_broadcast(&m_condition);
-        pthread_mutex_unlock(&m_mutex);
-    }
-    void Reset()
-    {
-        pthread_mutex_lock(&m_mutex);
-        m_state = false;
-        pthread_mutex_unlock(&m_mutex);
-    }
-};
-class EventUnixHandle : public UnixHandle<UnixHandleType::Event, UnixEvent>
-{
-public:
-    EventUnixHandle(UnixEvent event)
-    : UnixHandle<UnixHandleType::Event, UnixEvent>(event)
-    {
-    }
-    virtual bool Destroy()
-    {
-        return m_object.Destroy();
-    }
-};
-typedef UnixHandle<UnixHandleType::Thread, pthread_t> ThreadUnixHandle;
-#if !HAVE_THREAD_LOCAL
-extern "C" int __cxa_thread_atexit(void (*)(void*), void*, void *);
-extern "C" void *__dso_handle;
-#endif
-void ConfigureSignals()
-{
-    signal(SIGPIPE, SIG_IGN);
-}
-extern bool GetCpuLimit(uint32_t* val);
-void InitializeCurrentProcessCpuCount()
-{
-    uint32_t count;
-    const unsigned int MAX_PROCESSOR_COUNT = 0xffff;
-    uint32_t configValue;
-    if (g_pRhConfig->ReadConfigValue(_T("PROCESSOR_COUNT"), &configValue, true /* decimal */) &&
-        0 < configValue && configValue <= MAX_PROCESSOR_COUNT)
-    {
-        count = configValue;
-    }
-    else
-    {
-#if HAVE_SCHED_GETAFFINITY
-        cpu_set_t cpuSet;
-        int st = sched_getaffinity(getpid(), sizeof(cpu_set_t), &cpuSet);
-        if (st != 0)
-        {
-            _ASSERTE(!"sched_getaffinity failed");
-        }
-        count = CPU_COUNT(&cpuSet);
-#else // HAVE_SCHED_GETAFFINITY
-        count = GCToOSInterface::GetTotalProcessorCount();
-#endif // HAVE_SCHED_GETAFFINITY
-        uint32_t cpuLimit;
-        if (GetCpuLimit(&cpuLimit) && cpuLimit < count)
-            count = cpuLimit;
-    }
-    _ASSERTE(count > 0);
-    g_RhNumberOfProcessors = count;
-}
-REDHAWK_PALEXPORT bool REDHAWK_PALAPI PalInit()
-{
-#ifndef USE_PORTABLE_HELPERS
-    if (!InitializeHardwareExceptionHandling())
-    {
-        return false;
-    }
-#endif // !USE_PORTABLE_HELPERS
-    ConfigureSignals();
-    GCConfig::Initialize();
-    if (!GCToOSInterface::Initialize())
-    {
-        return false;
-    }
-    InitializeCpuCGroup();
-    InitializeCurrentProcessCpuCount();
-    return true;
-}
-#if HAVE_THREAD_LOCAL
-struct TlsDestructionMonitor
-{
-    void* m_thread = nullptr;
-    void SetThread(void* thread)
-    {
-        m_thread = thread;
-    }
-    ~TlsDestructionMonitor()
-    {
-        if (m_thread != nullptr)
-        {
-            RuntimeThreadShutdown(m_thread);
-        }
-    }
-};
-thread_local TlsDestructionMonitor tls_destructionMonitor;
-#endif // HAVE_THREAD_LOCAL
-DECLSPEC_THREAD intptr_t tls_thunkData;
-#ifdef FEATURE_EMULATED_TLS
-EXTERN_C intptr_t* RhpGetThunkData()
-{
-    return &tls_thunkData;
-}
-EXTERN_C intptr_t RhGetCurrentThunkContext()
-{
-    return tls_thunkData;
-}
-#endif //FEATURE_EMULATED_TLS
-extern "C" void PalAttachThread(void* thread)
-{
-#if HAVE_THREAD_LOCAL
-    tls_destructionMonitor.SetThread(thread);
-#else
-    __cxa_thread_atexit(RuntimeThreadShutdown, thread, &__dso_handle);
-#endif
-}
-extern "C" bool PalDetachThread(void* thread)
-{
-    UNREFERENCED_PARAMETER(thread);
-    if (g_threadExitCallback != nullptr)
-    {
-        g_threadExitCallback();
-    }
-    return true;
-}
-#if !defined(USE_PORTABLE_HELPERS) && !defined(FEATURE_RX_THUNKS)
-REDHAWK_PALEXPORT UInt32_BOOL REDHAWK_PALAPI PalAllocateThunksFromTemplate(HANDLE hTemplateModule, uint32_t templateRva, size_t templateSize, void** newThunksOut)
-{
-    PORTABILITY_ASSERT("UNIXTODO: Implement this function");
-}
-REDHAWK_PALEXPORT UInt32_BOOL REDHAWK_PALAPI PalFreeThunksFromTemplate(void *pBaseAddress)
-{
-    PORTABILITY_ASSERT("UNIXTODO: Implement this function");
-}
-#endif // !USE_PORTABLE_HELPERS && !FEATURE_RX_THUNKS
-REDHAWK_PALEXPORT UInt32_BOOL REDHAWK_PALAPI PalMarkThunksAsValidCallTargets(
-    void *virtualAddress,
-    int thunkSize,
-    int thunksPerBlock,
-    int thunkBlockSize,
-    int thunkBlocksPerMapping)
-{
-    return UInt32_TRUE;
-}
-REDHAWK_PALEXPORT void REDHAWK_PALAPI PalSleep(uint32_t milliseconds)
-{
-#if HAVE_CLOCK_NANOSLEEP
-    timespec endTime;
-    clock_gettime(CLOCK_MONOTONIC, &endTime);
-    TimeSpecAdd(&endTime, milliseconds);
-    while (clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &endTime, NULL) == EINTR)
-    {
-    }
-#else // HAVE_CLOCK_NANOSLEEP
-    timespec requested;
-    requested.tv_sec = milliseconds / tccSecondsToMilliSeconds;
-    requested.tv_nsec = (milliseconds - requested.tv_sec * tccSecondsToMilliSeconds) * tccMilliSecondsToNanoSeconds;
-    timespec remaining;
-    while (nanosleep(&requested, &remaining) == EINTR)
-    {
-        requested = remaining;
-    }
-#endif // HAVE_CLOCK_NANOSLEEP
-}
-REDHAWK_PALEXPORT UInt32_BOOL REDHAWK_PALAPI __stdcall PalSwitchToThread()
-{
-    sched_yield();
-    return false;
-}
-extern "C" UInt32_BOOL CloseHandle(HANDLE handle)
-{
-    if ((handle == NULL) || (handle == INVALID_HANDLE_VALUE))
-    {
-        return UInt32_FALSE;
-    }
-    UnixHandleBase* handleBase = (UnixHandleBase*)handle;
-    bool success = handleBase->Destroy();
-    delete handleBase;
-    return success ? UInt32_TRUE : UInt32_FALSE;
-}
-REDHAWK_PALEXPORT HANDLE REDHAWK_PALAPI PalCreateEventW(_In_opt_ LPSECURITY_ATTRIBUTES pEventAttributes, UInt32_BOOL manualReset, UInt32_BOOL initialState, _In_opt_z_ const wchar_t* pName)
-{
-    UnixEvent event = UnixEvent(manualReset, initialState);
-    if (!event.Initialize())
-    {
-        return INVALID_HANDLE_VALUE;
-    }
-    EventUnixHandle* handle = new (nothrow) EventUnixHandle(event);
-    if (handle == NULL)
-    {
-        return INVALID_HANDLE_VALUE;
-    }
-    return handle;
-}
-typedef uint32_t(__stdcall *BackgroundCallback)(_In_opt_ void* pCallbackContext);
-REDHAWK_PALEXPORT bool REDHAWK_PALAPI PalStartBackgroundWork(_In_ BackgroundCallback callback, _In_opt_ void* pCallbackContext, UInt32_BOOL highPriority)
-{
-#ifdef HOST_WASM
-    ASSERT(false);
-#endif // HOST_WASM
-    pthread_attr_t attrs;
-    int st = pthread_attr_init(&attrs);
-    ASSERT(st == 0);
-    static const int NormalPriority = 0;
-    static const int HighestPriority = -20;
-#if 0
-    sched_param params;
-    memset(&params, 0, sizeof(params));
-    params.sched_priority = highPriority ? HighestPriority : NormalPriority;
-    st = pthread_attr_setschedparam(&attrs, &params);
-    ASSERT(st == 0);
-#endif
-    st = pthread_attr_setdetachstate(&attrs, PTHREAD_CREATE_DETACHED);
-    ASSERT(st == 0);
-    pthread_t threadId;
-    st = pthread_create(&threadId, &attrs, (void *(*)(void*))callback, pCallbackContext);
-    int st2 = pthread_attr_destroy(&attrs);
-    ASSERT(st2 == 0);
-    return st == 0;
-}
-REDHAWK_PALEXPORT bool REDHAWK_PALAPI PalStartBackgroundGCThread(_In_ BackgroundCallback callback, _In_opt_ void* pCallbackContext)
-{
-    return PalStartBackgroundWork(callback, pCallbackContext, UInt32_FALSE);
-}
-REDHAWK_PALEXPORT bool REDHAWK_PALAPI PalStartFinalizerThread(_In_ BackgroundCallback callback, _In_opt_ void* pCallbackContext)
-{
-#ifdef HOST_WASM
-    return true;
-#else // HOST_WASM
-    return PalStartBackgroundWork(callback, pCallbackContext, UInt32_TRUE);
-#endif // HOST_WASM
-}
-REDHAWK_PALEXPORT uint64_t REDHAWK_PALAPI PalGetTickCount64()
-{
-    uint64_t retval = 0;
-#if HAVE_CLOCK_GETTIME_NSEC_NP
-    {
-        retval = clock_gettime_nsec_np(CLOCK_UPTIME_RAW) / tccMilliSecondsToNanoSeconds;
-    }
-#elif HAVE_CLOCK_MONOTONIC
-    {
-        clockid_t clockType =
-#if HAVE_CLOCK_MONOTONIC_COARSE
-            CLOCK_MONOTONIC_COARSE; // good enough resolution, fastest speed
-#else
-            CLOCK_MONOTONIC;
-#endif
-        struct timespec ts;
-        if (clock_gettime(clockType, &ts) == 0)
-        {
-            retval = (ts.tv_sec * tccSecondsToMilliSeconds) + (ts.tv_nsec / tccMilliSecondsToNanoSeconds);
-        }
-        else
-        {
-            ASSERT_UNCONDITIONALLY("clock_gettime(CLOCK_MONOTONIC) failed\n");
-        }
-    }
-#else
-    {
-        struct timeval tv;
-        if (gettimeofday(&tv, NULL) == 0)
-        {
-            retval = (tv.tv_sec * tccSecondsToMilliSeconds) + (tv.tv_usec / tccMilliSecondsToMicroSeconds);
-        }
-        else
-        {
-            ASSERT_UNCONDITIONALLY("gettimeofday() failed\n");
-        }
-    }
-#endif
-    return retval;
-}
-REDHAWK_PALEXPORT HANDLE REDHAWK_PALAPI PalGetModuleHandleFromPointer(_In_ void* pointer)
-{
-    HANDLE moduleHandle = NULL;
-#if !defined(HOST_WASM)
-    Dl_info info;
-    int st = dladdr(pointer, &info);
-    if (st != 0)
-    {
-        moduleHandle = info.dli_fbase;
-    }
-#endif //!defined(HOST_WASM)
-    return moduleHandle;
-}
-REDHAWK_PALEXPORT bool REDHAWK_PALAPI PalIsAvxEnabled()
-{
-    return true;
-}
-REDHAWK_PALEXPORT void PalPrintFatalError(const char* message)
-{
-    write(STDERR_FILENO, message, strlen(message));
-}
-static int W32toUnixAccessControl(uint32_t flProtect)
-{
-    int prot = 0;
-    switch (flProtect & 0xff)
-    {
-    case PAGE_NOACCESS:
-        prot = PROT_NONE;
-        break;
-    case PAGE_READWRITE:
-        prot = PROT_READ | PROT_WRITE;
-        break;
-    case PAGE_EXECUTE_READ:
-        prot = PROT_READ | PROT_EXEC;
-        break;
-    case PAGE_EXECUTE_READWRITE:
-        prot = PROT_READ | PROT_WRITE | PROT_EXEC;
-        break;
-    case PAGE_READONLY:
-        prot = PROT_READ;
-        break;
-    default:
-        ASSERT(false);
-        break;
-    }
-    return prot;
-}
-REDHAWK_PALEXPORT _Ret_maybenull_ _Post_writable_byte_size_(size) void* REDHAWK_PALAPI PalVirtualAlloc(_In_opt_ void* pAddress, size_t size, uint32_t allocationType, uint32_t protect)
-{
-    if ((allocationType & ~(MEM_RESERVE | MEM_COMMIT)) != 0)
-    {
-        return NULL;
-    }
-    ASSERT(((size_t)pAddress & (OS_PAGE_SIZE - 1)) == 0);
-    size = (size + (OS_PAGE_SIZE - 1)) & ~(OS_PAGE_SIZE - 1);
-    int unixProtect = W32toUnixAccessControl(protect);
-    if (allocationType & (MEM_RESERVE | MEM_COMMIT))
-    {
-        static const size_t Alignment = 64 * 1024;
-        size_t alignedSize = size + (Alignment - OS_PAGE_SIZE);
-        void * pRetVal = mmap(pAddress, alignedSize, unixProtect, MAP_ANON | MAP_PRIVATE, -1, 0);
-        if (pRetVal != NULL)
-        {
-            void * pAlignedRetVal = (void *)(((size_t)pRetVal + (Alignment - 1)) & ~(Alignment - 1));
-            size_t startPadding = (size_t)pAlignedRetVal - (size_t)pRetVal;
-            if (startPadding != 0)
-            {
-                int ret = munmap(pRetVal, startPadding);
-                ASSERT(ret == 0);
-            }
-            size_t endPadding = alignedSize - (startPadding + size);
-            if (endPadding != 0)
-            {
-                int ret = munmap((void *)((size_t)pAlignedRetVal + size), endPadding);
-                ASSERT(ret == 0);
-            }
-            pRetVal = pAlignedRetVal;
-        }
-        return pRetVal;
-    }
-    if (allocationType & MEM_COMMIT)
-    {
-        int ret = mprotect(pAddress, size, unixProtect);
-        return (ret == 0) ? pAddress : NULL;
-    }
-    return NULL;
-}
-REDHAWK_PALEXPORT UInt32_BOOL REDHAWK_PALAPI PalVirtualFree(_In_ void* pAddress, size_t size, uint32_t freeType)
-{
-    ASSERT(((freeType & MEM_RELEASE) != MEM_RELEASE) || size == 0);
-    ASSERT((freeType & (MEM_RELEASE | MEM_DECOMMIT)) != (MEM_RELEASE | MEM_DECOMMIT));
-    ASSERT(freeType != 0);
-    return UInt32_TRUE;
-}
-REDHAWK_PALEXPORT UInt32_BOOL REDHAWK_PALAPI PalVirtualProtect(_In_ void* pAddress, size_t size, uint32_t protect)
-{
-    int unixProtect = W32toUnixAccessControl(protect);
-    uint8_t* pPageStart = ALIGN_DOWN((uint8_t*)pAddress, OS_PAGE_SIZE);
-    size_t memSize = ALIGN_UP((uint8_t*)pAddress + size, OS_PAGE_SIZE) - pPageStart;
-    return mprotect(pPageStart, memSize, unixProtect) == 0;
-}
-REDHAWK_PALEXPORT void PalFlushInstructionCache(_In_ void* pAddress, size_t size)
-{
-#if defined(__linux__) && defined(HOST_ARM)
-    const size_t pageSize = getpagesize();
-    uint8_t* begin = (uint8_t*)pAddress;
-    uint8_t* end = begin + size;
-    while (begin < end)
-    {
-        uint8_t* endOrNextPageBegin = ALIGN_UP(begin + 1, pageSize);
-        if (endOrNextPageBegin > end)
-            endOrNextPageBegin = end;
-        __builtin___clear_cache((char *)begin, (char *)endOrNextPageBegin);
-        begin = endOrNextPageBegin;
-    }
-#else
-    __builtin___clear_cache((char *)pAddress, (char *)pAddress + size);
-#endif
-}
-REDHAWK_PALEXPORT _Ret_maybenull_ void* REDHAWK_PALAPI PalSetWerDataBuffer(_In_ void* pNewBuffer)
-{
-    static void* pBuffer;
-    return PalInterlockedExchangePointer(&pBuffer, pNewBuffer);
-}
-extern "C" HANDLE GetCurrentProcess()
-{
-    return (HANDLE)-1;
-}
-extern "C" uint32_t GetCurrentProcessId()
-{
-    return getpid();
-}
-extern "C" HANDLE GetCurrentThread()
-{
-    return (HANDLE)-2;
-}
-extern "C" UInt32_BOOL DuplicateHandle(
-    HANDLE hSourceProcessHandle,
-    HANDLE hSourceHandle,
-    HANDLE hTargetProcessHandle,
-    HANDLE * lpTargetHandle,
-    uint32_t dwDesiredAccess,
-    UInt32_BOOL bInheritHandle,
-    uint32_t dwOptions)
-{
-    ASSERT(hSourceProcessHandle == GetCurrentProcess());
-    ASSERT(hTargetProcessHandle == GetCurrentProcess());
-    ASSERT(hSourceHandle == GetCurrentThread());
-    *lpTargetHandle = new (nothrow) ThreadUnixHandle(pthread_self());
-    return lpTargetHandle != nullptr;
-}
-extern "C" UInt32_BOOL InitializeCriticalSection(CRITICAL_SECTION * lpCriticalSection)
-{
-    pthread_mutexattr_t mutexAttributes;
-    int st = pthread_mutexattr_init(&mutexAttributes);
-    if (st != 0)
-    {
-        return false;
-    }
-    st = pthread_mutexattr_settype(&mutexAttributes, PTHREAD_MUTEX_RECURSIVE);
-    if (st == 0)
-    {
-        st = pthread_mutex_init(&lpCriticalSection->mutex, &mutexAttributes);
-    }
-    pthread_mutexattr_destroy(&mutexAttributes);
-    return (st == 0);
-}
-extern "C" UInt32_BOOL InitializeCriticalSectionEx(CRITICAL_SECTION * lpCriticalSection, uint32_t arg2, uint32_t arg3)
-{
-    return InitializeCriticalSection(lpCriticalSection);
-}
-extern "C" void DeleteCriticalSection(CRITICAL_SECTION * lpCriticalSection)
-{
-    pthread_mutex_destroy(&lpCriticalSection->mutex);
-}
-extern "C" void EnterCriticalSection(CRITICAL_SECTION * lpCriticalSection)
-{
-    pthread_mutex_lock(&lpCriticalSection->mutex);;
-}
-extern "C" void LeaveCriticalSection(CRITICAL_SECTION * lpCriticalSection)
-{
-    pthread_mutex_unlock(&lpCriticalSection->mutex);
-}
-extern "C" UInt32_BOOL IsDebuggerPresent()
-{
-#ifdef HOST_WASM
-    return UInt32_TRUE;
-#else
-    return UInt32_FALSE;
-#endif
-}
-extern "C" UInt32_BOOL SetEvent(HANDLE event)
-{
-    EventUnixHandle* unixHandle = (EventUnixHandle*)event;
-    unixHandle->GetObject()->Set();
-    return UInt32_TRUE;
-}
-extern "C" UInt32_BOOL ResetEvent(HANDLE event)
-{
-    EventUnixHandle* unixHandle = (EventUnixHandle*)event;
-    unixHandle->GetObject()->Reset();
-    return UInt32_TRUE;
-}
-extern "C" uint32_t GetEnvironmentVariableA(const char * name, char * buffer, uint32_t size)
-{
-    const char* value = std::getenv(name);
-    if (value == NULL)
-    {
-        return 0;
-    }
-    size_t valueLen = strlen(value);
-    if (valueLen < size)
-    {
-        strcpy(buffer, value);
-        return valueLen;
-    }
-    return (valueLen < UINT32_MAX) ? (valueLen + 1) : 0;
-}
-extern "C" uint16_t RtlCaptureStackBackTrace(uint32_t arg1, uint32_t arg2, void* arg3, uint32_t* arg4)
-{
-    return 0;
-}
-static PalHijackCallback g_pHijackCallback;
-static struct sigaction g_previousActivationHandler;
-static void ActivationHandler(int code, siginfo_t* siginfo, void* context)
-{
-    if (g_pHijackCallback != NULL && (siginfo->si_pid == getpid()
-#ifdef HOST_OSX
-        || siginfo->si_pid == 0
-#endif
-        ))
-    {
-        int savedErrNo = errno;
-        g_pHijackCallback((NATIVE_CONTEXT*)context, NULL);
-        errno = savedErrNo;
-    }
-    else
-    {
-        if (g_previousActivationHandler.sa_flags & SA_SIGINFO)
-        {
-            _ASSERTE(g_previousActivationHandler.sa_sigaction != NULL);
-            g_previousActivationHandler.sa_sigaction(code, siginfo, context);
-        }
-        else
-        {
-            if (g_previousActivationHandler.sa_handler != SIG_IGN &&
-                g_previousActivationHandler.sa_handler != SIG_DFL)
-            {
-                _ASSERTE(g_previousActivationHandler.sa_handler != NULL);
-                g_previousActivationHandler.sa_handler(code);
-            }
-        }
-    }
-}
-REDHAWK_PALEXPORT UInt32_BOOL REDHAWK_PALAPI PalRegisterHijackCallback(_In_ PalHijackCallback callback)
-{
-    ASSERT(g_pHijackCallback == NULL);
-    g_pHijackCallback = callback;
-    return AddSignalHandler(INJECT_ACTIVATION_SIGNAL, ActivationHandler, &g_previousActivationHandler);
-}
-REDHAWK_PALEXPORT void REDHAWK_PALAPI PalHijack(HANDLE hThread, _In_opt_ void* pThreadToHijack)
-{
-    ThreadUnixHandle* threadHandle = (ThreadUnixHandle*)hThread;
-    int status = pthread_kill(*threadHandle->GetObject(), INJECT_ACTIVATION_SIGNAL);
-#ifdef __APPLE__
-    if (status == ENOTSUP)
-    {
-        return;
-    }
-#endif
-    if ((status != 0) && (status != EAGAIN))
-    {
-        abort();
-    }
-}
-extern "C" uint32_t WaitForSingleObjectEx(HANDLE handle, uint32_t milliseconds, UInt32_BOOL alertable)
-{
-    UnixHandleBase* handleBase = (UnixHandleBase*)handle;
-    ASSERT(handleBase->GetType() == UnixHandleType::Event);
-    EventUnixHandle* unixHandle = (EventUnixHandle*)handleBase;
-    return unixHandle->GetObject()->Wait(milliseconds);
-}
-REDHAWK_PALEXPORT uint32_t REDHAWK_PALAPI PalCompatibleWaitAny(UInt32_BOOL alertable, uint32_t timeout, uint32_t handleCount, HANDLE* pHandles, UInt32_BOOL allowReentrantWait)
-{
-    ASSERT(handleCount == 1);
-    return WaitForSingleObjectEx(pHandles[0], timeout, alertable);
-}
-#if !__has_builtin(_mm_pause)
-extern "C" void _mm_pause()
-{
-#if defined(HOST_AMD64) || defined(HOST_X86)
-  __asm__ volatile ("pause");
-#endif
-}
-#endif
-extern "C" int32_t _stricmp(const char *string1, const char *string2)
-{
-    return strcasecmp(string1, string2);
-}
-REDHAWK_PALIMPORT void REDHAWK_PALAPI PopulateControlSegmentRegisters(CONTEXT* pContext)
-{
-#if defined(TARGET_X86) || defined(TARGET_AMD64)
-#endif
-}
-uint32_t g_RhNumberOfProcessors;
-REDHAWK_PALEXPORT int32_t PalGetProcessCpuCount()
-{
-    ASSERT(g_RhNumberOfProcessors > 0);
-    return g_RhNumberOfProcessors;
-}
-__thread void* pStackHighOut = NULL;
-__thread void* pStackLowOut = NULL;
-REDHAWK_PALEXPORT bool PalGetMaximumStackBounds(_Out_ void** ppStackLowOut, _Out_ void** ppStackHighOut)
-{
-    if (pStackHighOut == NULL)
-    {
-#ifdef __APPLE__
-        pStackHighOut = pthread_get_stackaddr_np(pthread_self());
-        pStackLowOut = ((uint8_t *)pStackHighOut - pthread_get_stacksize_np(pthread_self()));
-#else // __APPLE__
-        pthread_attr_t attr;
-        size_t stackSize;
-        int status;
-        pthread_t thread = pthread_self();
-        status = pthread_attr_init(&attr);
-        ASSERT_MSG(status == 0, "pthread_attr_init call failed");
-#if HAVE_PTHREAD_ATTR_GET_NP
-        status = pthread_attr_get_np(thread, &attr);
-#elif HAVE_PTHREAD_GETATTR_NP
-        status = pthread_getattr_np(thread, &attr);
-#else
-#error Dont know how to get thread attributes on this platform!
-#endif
-        ASSERT_MSG(status == 0, "pthread_getattr_np call failed");
-        status = pthread_attr_getstack(&attr, &pStackLowOut, &stackSize);
-        ASSERT_MSG(status == 0, "pthread_attr_getstack call failed");
-        status = pthread_attr_destroy(&attr);
-        ASSERT_MSG(status == 0, "pthread_attr_destroy call failed");
-        pStackHighOut = (uint8_t*)pStackLowOut + stackSize;
-#endif // __APPLE__
-    }
-    *ppStackLowOut = pStackLowOut;
-    *ppStackHighOut = pStackHighOut;
-    return true;
-}
-REDHAWK_PALEXPORT int32_t PalGetModuleFileName(_Out_ const TCHAR** pModuleNameOut, HANDLE moduleBase)
-{
-#if defined(HOST_WASM)
-    const TCHAR* wasmModuleName = "WebAssemblyModule";
-    *pModuleNameOut = wasmModuleName;
-    return strlen(wasmModuleName);
-#else // HOST_WASM
-    Dl_info dl;
-    if (dladdr(moduleBase, &dl) == 0)
-    {
-        *pModuleNameOut = NULL;
-        return 0;
-    }
-    *pModuleNameOut = dl.dli_fname;
-    return strlen(dl.dli_fname);
-#endif // defined(HOST_WASM)
-}
-extern "C" void FlushProcessWriteBuffers()
-{
-    GCToOSInterface::FlushProcessWriteBuffers();
-}
-static const int64_t SECS_BETWEEN_1601_AND_1970_EPOCHS = 11644473600LL;
-static const int64_t SECS_TO_100NS = 10000000; /* 10^7 */
-extern "C" void GetSystemTimeAsFileTime(FILETIME *lpSystemTimeAsFileTime)
-{
-    struct timeval time = { 0 };
-    gettimeofday(&time, NULL);
-    int64_t result = ((int64_t)time.tv_sec + SECS_BETWEEN_1601_AND_1970_EPOCHS) * SECS_TO_100NS +
-        (time.tv_usec * 10);
-    lpSystemTimeAsFileTime->dwLowDateTime = (uint32_t)result;
-    lpSystemTimeAsFileTime->dwHighDateTime = (uint32_t)(result >> 32);
-}
-extern "C" UInt32_BOOL QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
-{
-    struct timeval tv;
-    if (gettimeofday(&tv, NULL) == -1)
-    {
-        ASSERT_UNCONDITIONALLY("gettimeofday() failed");
-        return UInt32_FALSE;
-    }
-    lpPerformanceCount->QuadPart =
-        (int64_t) tv.tv_sec * (int64_t) tccSecondsToMicroSeconds + (int64_t) tv.tv_usec;
-    return UInt32_TRUE;
-}
-extern "C" UInt32_BOOL QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency)
-{
-    lpFrequency->QuadPart = (int64_t) tccSecondsToMicroSeconds;
-    return UInt32_TRUE;
-}
-extern "C" uint64_t PalGetCurrentThreadIdForLogging()
-{
-#if defined(__linux__)
-    return (uint64_t)syscall(SYS_gettid);
-#elif defined(__APPLE__)
-    uint64_t tid;
-    pthread_threadid_np(pthread_self(), &tid);
-    return (uint64_t)tid;
-#elif HAVE_PTHREAD_GETTHREADID_NP
-    return (uint64_t)pthread_getthreadid_np();
-#elif HAVE_LWP_SELF
-    return (uint64_t)_lwp_self();
-#else
-    return (uint64_t)pthread_self();
-#endif
-}
-#if defined(HOST_X86) || defined(HOST_AMD64)
-#if !__has_builtin(__cpuid)
-REDHAWK_PALEXPORT void __cpuid(int cpuInfo[4], int function_id)
-{
-    __asm("  cpuid\n" \
-        : "=a"(cpuInfo[0]), "=b"(cpuInfo[1]), "=c"(cpuInfo[2]), "=d"(cpuInfo[3]) \
-        : "0"(function_id)
-        );
-}
-#endif
-#if !__has_builtin(__cpuidex)
-REDHAWK_PALEXPORT void __cpuidex(int cpuInfo[4], int function_id, int subFunction_id)
-{
-    __asm("  cpuid\n" \
-        : "=a"(cpuInfo[0]), "=b"(cpuInfo[1]), "=c"(cpuInfo[2]), "=d"(cpuInfo[3]) \
-        : "0"(function_id), "2"(subFunction_id)
-        );
-}
-#endif
-REDHAWK_PALEXPORT uint32_t REDHAWK_PALAPI xmmYmmStateSupport()
-{
-    DWORD eax;
-    __asm("  xgetbv\n" \
-        : "=a"(eax) /*output in eax*/\
-        : "c"(0) /*inputs - 0 in ecx*/\
-        : "edx" /* registers that are clobbered*/
-      );
-    return ((eax & 0x06) == 0x06) ? 1 : 0;
-}
-#endif // defined(HOST_X86) || defined(HOST_AMD64)
-#if defined (HOST_ARM64)
-#if HAVE_AUXV_HWCAP_H
-#include <sys/auxv.h>
-#include <asm/hwcap.h>
-#endif
-#if HAVE_SYSCTLBYNAME
-#include <sys/sysctl.h>
-#endif
-REDHAWK_PALEXPORT void REDHAWK_PALAPI PAL_GetCpuCapabilityFlags(int* flags)
-{
-    *flags = 0;
-#if HAVE_AUXV_HWCAP_H
-    unsigned long hwCap = getauxval(AT_HWCAP);
-#ifdef HWCAP_AES
-    if (hwCap & HWCAP_AES)
-        *flags |= ARM64IntrinsicConstants_Aes;
-#endif
-#ifdef HWCAP_ATOMICS
-    if (hwCap & HWCAP_ATOMICS)
-        *flags |= ARM64IntrinsicConstants_Atomics;
-#endif
-#ifdef HWCAP_CRC32
-    if (hwCap & HWCAP_CRC32)
-        *flags |= ARM64IntrinsicConstants_Crc32;
-#endif
-#ifdef HWCAP_DCPOP
-#endif
-#ifdef HWCAP_ASIMDDP
-    if (hwCap & HWCAP_ASIMDDP)
-        *flags |= ARM64IntrinsicConstants_Dp;
-#endif
-#ifdef HWCAP_FCMA
-#endif
-#ifdef HWCAP_FP
-#endif
-#ifdef HWCAP_FPHP
-#endif
-#ifdef HWCAP_JSCVT
-#endif
-#ifdef HWCAP_LRCPC
-      if (hwCap & HWCAP_LRCPC)
-          *flags |= ARM64IntrinsicConstants_Rcpc;
-#endif
-#ifdef HWCAP_PMULL
-#endif
-#ifdef HWCAP_SHA1
-    if (hwCap & HWCAP_SHA1)
-        *flags |= ARM64IntrinsicConstants_Sha1;
-#endif
-#ifdef HWCAP_SHA2
-    if (hwCap & HWCAP_SHA2)
-        *flags |= ARM64IntrinsicConstants_Sha256;
-#endif
-#ifdef HWCAP_SHA512
-#endif
-#ifdef HWCAP_SHA3
-#endif
-#ifdef HWCAP_ASIMD
-    if (hwCap & HWCAP_ASIMD)
-        *flags |= ARM64IntrinsicConstants_AdvSimd;
-#endif
-#ifdef HWCAP_ASIMDRDM
-    if (hwCap & HWCAP_ASIMDRDM)
-        *flags |= ARM64IntrinsicConstants_Rdm;
-#endif
-#ifdef HWCAP_ASIMDHP
-#endif
-#ifdef HWCAP_SM3
-#endif
-#ifdef HWCAP_SM4
-#endif
-#ifdef HWCAP_SVE
-#endif
-#ifdef AT_HWCAP2
-    unsigned long hwCap2 = getauxval(AT_HWCAP2);
-#ifdef HWCAP2_DCPODP
-#endif
-#ifdef HWCAP2_SVE2
-#endif
-#ifdef HWCAP2_SVEAES
-#endif
-#ifdef HWCAP2_SVEPMULL
-#endif
-#ifdef HWCAP2_SVEBITPERM
-#endif
-#ifdef HWCAP2_SVESHA3
-#endif
-#ifdef HWCAP2_SVESM4
-#endif
-#ifdef HWCAP2_FLAGM2
-#endif
-#ifdef HWCAP2_FRINT
-#endif
-#endif // AT_HWCAP2
-#else // !HAVE_AUXV_HWCAP_H
-#if HAVE_SYSCTLBYNAME
-    int64_t valueFromSysctl = 0;
-    size_t sz = sizeof(valueFromSysctl);
-    if ((sysctlbyname("hw.optional.arm.FEAT_AES", &valueFromSysctl, &sz, nullptr, 0) == 0) && (valueFromSysctl != 0))
-        *flags |= ARM64IntrinsicConstants_Aes;
-    if ((sysctlbyname("hw.optional.armv8_crc32", &valueFromSysctl, &sz, nullptr, 0) == 0) && (valueFromSysctl != 0))
-        *flags |= ARM64IntrinsicConstants_Crc32;
-    if ((sysctlbyname("hw.optional.arm.FEAT_DotProd", &valueFromSysctl, &sz, nullptr, 0) == 0) && (valueFromSysctl != 0))
-        *flags |= ARM64IntrinsicConstants_Dp;
-    if ((sysctlbyname("hw.optional.arm.FEAT_RDM", &valueFromSysctl, &sz, nullptr, 0) == 0) && (valueFromSysctl != 0))
-        *flags |= ARM64IntrinsicConstants_Rdm;
-    if ((sysctlbyname("hw.optional.arm.FEAT_SHA1", &valueFromSysctl, &sz, nullptr, 0) == 0) && (valueFromSysctl != 0))
-        *flags |= ARM64IntrinsicConstants_Sha1;
-    if ((sysctlbyname("hw.optional.arm.FEAT_SHA256", &valueFromSysctl, &sz, nullptr, 0) == 0) && (valueFromSysctl != 0))
-        *flags |= ARM64IntrinsicConstants_Sha256;
-    if ((sysctlbyname("hw.optional.armv8_1_atomics", &valueFromSysctl, &sz, nullptr, 0) == 0) && (valueFromSysctl != 0))
-        *flags |= ARM64IntrinsicConstants_Atomics;
-    if ((sysctlbyname("hw.optional.arm.FEAT_LRCPC", &valueFromSysctl, &sz, nullptr, 0) == 0) && (valueFromSysctl != 0))
-        *flags |= ARM64IntrinsicConstants_Rcpc;
-#endif // HAVE_SYSCTLBYNAME
-    *flags |= ARM64IntrinsicConstants_AdvSimd;
-#endif // HAVE_AUXV_HWCAP_H
-}
-#endif

--- a/src/coreclr/nativeaot/System.Private.CoreLib/src/Internal/Runtime/CompilerHelpers/InteropHelpers.cs
+++ b//dev/null
@@ -1,515 +0,0 @@
-using System;
-using System.Collections.Concurrent;
-using System.Diagnostics;
-using System.Diagnostics.CodeAnalysis;
-using System.Reflection;
-using System.Runtime;
-using System.Runtime.CompilerServices;
-using System.Runtime.InteropServices;
-using System.Runtime.Loader;
-using System.Text;
-using System.Threading;
-using Internal.Runtime;
-using Internal.Runtime.Augments;
-namespace Internal.Runtime.CompilerHelpers
-{
-    internal static class InteropHelpers
-    {
-        internal static unsafe byte* StringToAnsiString(string str, bool bestFit, bool throwOnUnmappableChar)
-        {
-            return PInvokeMarshal.StringToAnsiString(str, bestFit, throwOnUnmappableChar);
-        }
-        public static unsafe string AnsiStringToString(byte* buffer)
-        {
-            return PInvokeMarshal.AnsiStringToString(buffer);
-        }
-        internal static unsafe void StringToByValAnsiString(string str, byte* pNative, int charCount, bool bestFit, bool throwOnUnmappableChar)
-        {
-            if (str != null)
-            {
-                int lenUnicode = str.Length;
-                if (lenUnicode >= charCount)
-                    lenUnicode = charCount - 1;
-                fixed (char* pManaged = str)
-                {
-                    PInvokeMarshal.StringToAnsiString(pManaged, lenUnicode, pNative, /*terminateWithNull=*/true, bestFit, throwOnUnmappableChar);
-                }
-            }
-            else
-            {
-                (*pNative) = (byte)'\0';
-            }
-        }
-        public static unsafe string ByValAnsiStringToString(byte* buffer, int length)
-        {
-            int end = new ReadOnlySpan<byte>(buffer, length).IndexOf((byte)0);
-            if (end >= 0)
-            {
-                length = end;
-            }
-            return new string((sbyte*)buffer, 0, length);
-        }
-        internal static unsafe void StringToUnicodeFixedArray(string str, ushort* buffer, int length)
-        {
-            ReadOnlySpan<char> managed = str;
-            Span<char> native = new Span<char>((char*)buffer, length);
-            int numChars = Math.Min(managed.Length, length - 1);
-            managed.Slice(0, numChars).CopyTo(native);
-            native[numChars] = '\0';
-        }
-        internal static unsafe string UnicodeToStringFixedArray(ushort* buffer, int length)
-        {
-            int end = new ReadOnlySpan<char>(buffer, length).IndexOf('\0');
-            if (end >= 0)
-            {
-                length = end;
-            }
-            return new string((char*)buffer, 0, length);
-        }
-        internal static unsafe char* StringToUnicodeBuffer(string str)
-        {
-            return (char*)Marshal.StringToCoTaskMemUni(str);
-        }
-        public static unsafe byte* AllocMemoryForAnsiStringBuilder(StringBuilder sb)
-        {
-            if (sb == null)
-            {
-                return null;
-            }
-            return (byte *)CoTaskMemAllocAndZeroMemory(checked((sb.Capacity + 2) * Marshal.SystemMaxDBCSCharSize));
-        }
-        public static unsafe char* AllocMemoryForUnicodeStringBuilder(StringBuilder sb)
-        {
-            if (sb == null)
-            {
-                return null;
-            }
-            return (char *)CoTaskMemAllocAndZeroMemory(checked((sb.Capacity + 2) * 2));
-        }
-        public static unsafe byte* AllocMemoryForAnsiCharArray(char[] chArray)
-        {
-            if (chArray == null)
-            {
-                return null;
-            }
-            return (byte*)CoTaskMemAllocAndZeroMemory(checked((chArray.Length + 2) * Marshal.SystemMaxDBCSCharSize));
-        }
-        public static unsafe void AnsiStringToStringBuilder(byte* newBuffer, System.Text.StringBuilder stringBuilder)
-        {
-            if (stringBuilder == null)
-                return;
-            PInvokeMarshal.AnsiStringToStringBuilder(newBuffer, stringBuilder);
-        }
-        public static unsafe void UnicodeStringToStringBuilder(ushort* newBuffer, System.Text.StringBuilder stringBuilder)
-        {
-            if (stringBuilder == null)
-                return;
-            PInvokeMarshal.UnicodeStringToStringBuilder(newBuffer, stringBuilder);
-        }
-        public static unsafe void StringBuilderToAnsiString(System.Text.StringBuilder stringBuilder, byte* pNative,
-            bool bestFit, bool throwOnUnmappableChar)
-        {
-            if (pNative == null)
-                return;
-            PInvokeMarshal.StringBuilderToAnsiString(stringBuilder, pNative, bestFit, throwOnUnmappableChar);
-        }
-        public static unsafe void StringBuilderToUnicodeString(System.Text.StringBuilder stringBuilder, ushort* destination)
-        {
-            if (destination == null)
-                return;
-            PInvokeMarshal.StringBuilderToUnicodeString(stringBuilder, destination);
-        }
-        public static unsafe void WideCharArrayToAnsiCharArray(char[] managedArray, byte* pNative, bool bestFit, bool throwOnUnmappableChar)
-        {
-            PInvokeMarshal.WideCharArrayToAnsiCharArray(managedArray, pNative, bestFit, throwOnUnmappableChar);
-        }
-        public static unsafe void AnsiCharArrayToWideCharArray(byte* pNative, char[] managedArray)
-        {
-            PInvokeMarshal.AnsiCharArrayToWideCharArray(pNative, managedArray);
-        }
-        public static unsafe byte WideCharToAnsiChar(char managedValue, bool bestFit, bool throwOnUnmappableChar)
-        {
-            return PInvokeMarshal.WideCharToAnsiChar(managedValue, bestFit, throwOnUnmappableChar);
-        }
-        public static unsafe char AnsiCharToWideChar(byte nativeValue)
-        {
-            return PInvokeMarshal.AnsiCharToWideChar(nativeValue);
-        }
-        internal static double DateTimeToOleDateTime(DateTime value)
-        {
-            return value.ToOADate();
-        }
-        internal static DateTime OleDateTimeToDateTime(double value)
-        {
-            return DateTime.FromOADate(value);
-        }
-        internal static long DecimalToOleCurrency(decimal value)
-        {
-            return decimal.ToOACurrency(value);
-        }
-        internal static decimal OleCurrencyToDecimal(long value)
-        {
-            return decimal.FromOACurrency(value);
-        }
-        internal static unsafe string BstrBufferToString(char* buffer)
-        {
-            if (buffer == null)
-                return null;
-            return Marshal.PtrToStringBSTR((IntPtr)buffer);
-        }
-        internal static unsafe byte* StringToAnsiBstrBuffer(string s)
-        {
-            if (s is null)
-            {
-                return (byte*)IntPtr.Zero;
-            }
-            int stringLength = s.Length;
-            fixed (char* pStr = s)
-            {
-                int nativeLength = PInvokeMarshal.GetByteCount(pStr, stringLength);
-                byte* bstr = (byte*)Marshal.AllocBSTRByteLen((uint)nativeLength);
-                PInvokeMarshal.ConvertWideCharToMultiByte(pStr, stringLength, bstr, nativeLength, bestFit: false, throwOnUnmappableChar: false);
-                return bstr;
-            }
-        }
-        internal static unsafe string AnsiBstrBufferToString(byte* buffer)
-        {
-            if (buffer == null)
-                return null;
-            return Marshal.PtrToStringAnsi((IntPtr)buffer, (int)Marshal.SysStringByteLen((IntPtr)buffer));
-        }
-        internal static unsafe IntPtr ResolvePInvoke(MethodFixupCell* pCell)
-        {
-            if (pCell->Target != IntPtr.Zero)
-                return pCell->Target;
-            return ResolvePInvokeSlow(pCell);
-        }
-        [MethodImpl(MethodImplOptions.NoInlining)]
-        internal static unsafe IntPtr ResolvePInvokeSlow(MethodFixupCell* pCell)
-        {
-            int lastSystemError = Marshal.GetLastSystemError();
-            ModuleFixupCell* pModuleCell = pCell->Module;
-            IntPtr hModule = pModuleCell->Handle;
-            if (hModule == IntPtr.Zero)
-            {
-                FixupModuleCell(pModuleCell);
-                hModule = pModuleCell->Handle;
-            }
-            FixupMethodCell(hModule, pCell);
-            Marshal.SetLastSystemError(lastSystemError);
-            return pCell->Target;
-        }
-        internal static unsafe void FreeLibrary(IntPtr hModule)
-        {
-#if !TARGET_UNIX
-            Interop.Kernel32.FreeLibrary(hModule);
-#else
-            Interop.Sys.FreeLibrary(hModule);
-#endif
-        }
-        private static unsafe string GetModuleName(ModuleFixupCell* pCell)
-        {
-            byte* pModuleName = (byte*)pCell->ModuleName;
-            return Encoding.UTF8.GetString(pModuleName, string.strlen(pModuleName));
-        }
-        internal static unsafe void FixupModuleCell(ModuleFixupCell* pCell)
-        {
-            string moduleName = GetModuleName(pCell);
-            uint dllImportSearchPath = 0;
-            bool hasDllImportSearchPath = (pCell->DllImportSearchPathAndCookie & InteropDataConstants.HasDllImportSearchPath) != 0;
-            if (hasDllImportSearchPath)
-            {
-                dllImportSearchPath = pCell->DllImportSearchPathAndCookie & ~InteropDataConstants.HasDllImportSearchPath;
-            }
-            Assembly callingAssembly = RuntimeAugments.Callbacks.GetAssemblyForHandle(new RuntimeTypeHandle(pCell->CallingAssemblyType));
-            IntPtr hModule = NativeLibrary.LoadLibraryCallbackStub(moduleName, callingAssembly, hasDllImportSearchPath, dllImportSearchPath);
-            if (hModule == IntPtr.Zero)
-            {
-                NativeLibrary.LoadLibErrorTracker loadLibErrorTracker = default;
-                hModule = NativeLibrary.LoadBySearch(
-                    callingAssembly,
-                    searchAssemblyDirectory: (dllImportSearchPath & (uint)DllImportSearchPath.AssemblyDirectory) != 0,
-                    dllImportSearchPathFlags: (int)(dllImportSearchPath & ~(uint)DllImportSearchPath.AssemblyDirectory),
-                    ref loadLibErrorTracker,
-                    moduleName);
-                if (hModule == IntPtr.Zero)
-                {
-                    AssemblyLoadContext loadContext = AssemblyLoadContext.GetLoadContext(callingAssembly)!;
-                    hModule = loadContext.GetResolvedUnmanagedDll(callingAssembly, moduleName);
-                }
-                if (hModule == IntPtr.Zero)
-                {
-                    loadLibErrorTracker.Throw(moduleName);
-                }
-            }
-            Debug.Assert(hModule != IntPtr.Zero);
-            var oldValue = Interlocked.CompareExchange(ref pCell->Handle, hModule, IntPtr.Zero);
-            if (oldValue != IntPtr.Zero)
-            {
-                FreeLibrary(hModule);
-            }
-        }
-        internal static unsafe void FixupMethodCell(IntPtr hModule, MethodFixupCell* pCell)
-        {
-            byte* methodName = (byte*)pCell->MethodName;
-            IntPtr pTarget;
-#if TARGET_WINDOWS
-            CharSet charSetMangling = pCell->CharSetMangling;
-            if (charSetMangling == 0)
-            {
-                pTarget = Interop.Kernel32.GetProcAddress(hModule, methodName);
-            }
-            else
-            if (charSetMangling == CharSet.Ansi)
-            {
-                pTarget = Interop.Kernel32.GetProcAddress(hModule, methodName);
-                if (pTarget == IntPtr.Zero)
-                    pTarget = GetProcAddressWithSuffix(hModule, methodName, (byte)'A');
-            }
-            else
-            {
-                pTarget = GetProcAddressWithSuffix(hModule, methodName, (byte)'W');
-                if (pTarget == IntPtr.Zero)
-                    pTarget = Interop.Kernel32.GetProcAddress(hModule, methodName);
-            }
-#else
-            pTarget = Interop.Sys.GetProcAddress(hModule, methodName);
-#endif
-            if (pTarget == IntPtr.Zero)
-            {
-                string entryPointName = Encoding.UTF8.GetString(methodName, string.strlen(methodName));
-                throw new EntryPointNotFoundException(SR.Format(SR.Arg_EntryPointNotFoundExceptionParameterized, entryPointName, GetModuleName(pCell->Module)));
-            }
-            pCell->Target = pTarget;
-        }
-#if TARGET_WINDOWS
-        private static unsafe IntPtr GetProcAddressWithSuffix(IntPtr hModule, byte* methodName, byte suffix)
-        {
-            int nameLength = string.strlen(methodName);
-            byte* probedMethodName = stackalloc byte[nameLength + 2];
-            for (int i = 0; i < nameLength; i++)
-            {
-                probedMethodName[i] = methodName[i];
-            }
-            probedMethodName[nameLength + 1] = 0;
-            probedMethodName[nameLength] = suffix;
-            return Interop.Kernel32.GetProcAddress(hModule, probedMethodName);
-        }
-#endif
-        internal static unsafe void* CoTaskMemAllocAndZeroMemory(int size)
-        {
-            byte* ptr = (byte*)Marshal.AllocCoTaskMem(size);
-            Debug.Assert(ptr != null);
-            NativeMemory.Clear(ptr, (uint)size);
-            return ptr;
-        }
-        public static IntPtr GetCurrentCalleeOpenStaticDelegateFunctionPointer()
-        {
-            return PInvokeMarshal.GetCurrentCalleeOpenStaticDelegateFunctionPointer();
-        }
-        public static T GetCurrentCalleeDelegate<T>() where T : class // constraint can't be System.Delegate
-        {
-            return PInvokeMarshal.GetCurrentCalleeDelegate<T>();
-        }
-        public static IntPtr ConvertManagedComInterfaceToNative(object pUnk, Guid interfaceGuid)
-        {
-            if (pUnk == null)
-            {
-                return IntPtr.Zero;
-            }
-#if TARGET_WINDOWS
-#pragma warning disable CA1416
-            return ComWrappers.ComInterfaceForObject(pUnk, interfaceGuid);
-#pragma warning restore CA1416
-#else
-            throw new PlatformNotSupportedException(SR.PlatformNotSupported_ComInterop);
-#endif
-        }
-        public static IntPtr ConvertManagedComInterfaceToIUnknown(object pUnk)
-        {
-            if (pUnk == null)
-            {
-                return IntPtr.Zero;
-            }
-#if TARGET_WINDOWS
-#pragma warning disable CA1416
-            return ComWrappers.ComInterfaceForObject(pUnk);
-#pragma warning restore CA1416
-#else
-            throw new PlatformNotSupportedException(SR.PlatformNotSupported_ComInterop);
-#endif
-        }
-        public static object ConvertNativeComInterfaceToManaged(IntPtr pUnk)
-        {
-            if (pUnk == IntPtr.Zero)
-            {
-                return null;
-            }
-#if TARGET_WINDOWS
-#pragma warning disable CA1416
-            return ComWrappers.ComObjectForInterface(pUnk);
-#pragma warning restore CA1416
-#else
-            throw new PlatformNotSupportedException(SR.PlatformNotSupported_ComInterop);
-#endif
-        }
-        [UnconditionalSuppressMessage("AotAnalysis", "IL3050:RequiresDynamicCode",
-            Justification = "This API will be called from compiler generated code only.")]
-        internal static int AsAnyGetNativeSize(object o)
-        {
-            if (o.GetEETypePtr().IsArray ||
-                o is string ||
-                o is StringBuilder)
-            {
-                throw new PlatformNotSupportedException();
-            }
-            return Marshal.SizeOf(o.GetType());
-        }
-        [UnconditionalSuppressMessage("AotAnalysis", "IL3050:RequiresDynamicCode",
-            Justification = "This API will be called from compiler generated code only.")]
-        internal static void AsAnyMarshalManagedToNative(object o, IntPtr address)
-        {
-            if (o.GetEETypePtr().IsArray ||
-                o is string ||
-                o is StringBuilder)
-            {
-                throw new PlatformNotSupportedException();
-            }
-            Marshal.StructureToPtr(o, address, fDeleteOld: false);
-        }
-        internal static void AsAnyMarshalNativeToManaged(IntPtr address, object o)
-        {
-            if (o.GetEETypePtr().IsArray ||
-                o is string ||
-                o is StringBuilder)
-            {
-                throw new PlatformNotSupportedException();
-            }
-            Marshal.PtrToStructureImpl(address, o);
-        }
-        [UnconditionalSuppressMessage("AotAnalysis", "IL3050:RequiresDynamicCode",
-            Justification = "This API will be called from compiler generated code only.")]
-        internal static void AsAnyCleanupNative(IntPtr address, object o)
-        {
-            if (o.GetEETypePtr().IsArray ||
-                o is string ||
-                o is StringBuilder)
-            {
-                throw new PlatformNotSupportedException();
-            }
-            Marshal.DestroyStructure(address, o.GetType());
-        }
-        internal static unsafe object? VariantToObject(IntPtr pSrcNativeVariant)
-        {
-            if (pSrcNativeVariant == IntPtr.Zero)
-            {
-                return null;
-            }
-#if TARGET_WINDOWS
-#pragma warning disable CA1416
-            return Marshal.GetObjectForNativeVariant(pSrcNativeVariant);
-#pragma warning restore CA1416
-#else
-            throw new PlatformNotSupportedException(SR.PlatformNotSupported_ComInterop);
-#endif
-        }
-        internal static unsafe void ConvertObjectToVariant(object? obj, IntPtr pDstNativeVariant)
-        {
-#if TARGET_WINDOWS
-#pragma warning disable CA1416
-            Marshal.GetNativeVariantForObject(obj, pDstNativeVariant);
-#pragma warning restore CA1416
-#else
-            throw new PlatformNotSupportedException(SR.PlatformNotSupported_ComInterop);
-#endif
-        }
-        internal static unsafe void CleanupVariant(IntPtr pDstNativeVariant)
-        {
-#if TARGET_WINDOWS
-#pragma warning disable CA1416
-            Variant* data = (Variant*)pDstNativeVariant;
-            data->Clear();
-#pragma warning restore CA1416
-#else
-            throw new PlatformNotSupportedException(SR.PlatformNotSupported_ComInterop);
-#endif
-        }
-        public static unsafe object InitializeCustomMarshaller(RuntimeTypeHandle pParameterType, RuntimeTypeHandle pMarshallerType, string cookie, delegate*<string, object> getInstanceMethod)
-        {
-            if (getInstanceMethod == null)
-            {
-                throw new ApplicationException();
-            }
-            if (!RuntimeImports.AreTypesAssignable(pMarshallerType.ToEETypePtr(), EETypePtr.EETypePtrOf<ICustomMarshaler>()))
-            {
-                throw new ApplicationException();
-            }
-            var marshaller = CustomMarshallerTable.s_customMarshallersTable.GetOrAdd(new CustomMarshallerKey(pParameterType, pMarshallerType, cookie, getInstanceMethod));
-            if (marshaller == null)
-            {
-                throw new ApplicationException();
-            }
-            if (!RuntimeImports.AreTypesAssignable(marshaller.GetEETypePtr(), EETypePtr.EETypePtrOf<ICustomMarshaler>()))
-            {
-                throw new ApplicationException();
-            }
-            return marshaller;
-        }
-        [StructLayout(LayoutKind.Sequential)]
-        internal unsafe struct ModuleFixupCell
-        {
-            public IntPtr Handle;
-            public IntPtr ModuleName;
-            public EETypePtr CallingAssemblyType;
-            public uint DllImportSearchPathAndCookie;
-        }
-        [StructLayout(LayoutKind.Sequential)]
-        internal unsafe struct MethodFixupCell
-        {
-            public IntPtr Target;
-            public IntPtr MethodName;
-            public ModuleFixupCell* Module;
-            public CharSet CharSetMangling;
-        }
-        internal unsafe struct CustomMarshallerKey : IEquatable<CustomMarshallerKey>
-        {
-            public CustomMarshallerKey(RuntimeTypeHandle pParameterType, RuntimeTypeHandle pMarshallerType, string cookie, delegate*<string, object> getInstanceMethod)
-            {
-                ParameterType = pParameterType;
-                MarshallerType = pMarshallerType;
-                Cookie = cookie;
-                GetInstanceMethod = getInstanceMethod;
-            }
-            public RuntimeTypeHandle ParameterType { get; }
-            public RuntimeTypeHandle MarshallerType { get; }
-            public string Cookie { get; }
-            public delegate*<string, object> GetInstanceMethod { get; }
-            public override bool Equals(object obj)
-            {
-                if (!(obj is CustomMarshallerKey other))
-                    return false;
-                return Equals(other);
-            }
-            public bool Equals(CustomMarshallerKey other)
-            {
-                return ParameterType.Equals(other.ParameterType)
-                    && MarshallerType.Equals(other.MarshallerType)
-                    && Cookie.Equals(other.Cookie);
-            }
-            public override int GetHashCode()
-            {
-                return ParameterType.GetHashCode()
-                    ^ MarshallerType.GetHashCode()
-                    ^ Cookie.GetHashCode();
-            }
-        }
-        internal sealed class CustomMarshallerTable : ConcurrentUnifier<CustomMarshallerKey, object>
-        {
-            internal static CustomMarshallerTable s_customMarshallersTable = new CustomMarshallerTable();
-            protected override unsafe object Factory(CustomMarshallerKey key)
-            {
-                return key.GetInstanceMethod(key.Cookie);
-            }
-        }
-    }
-}

--- a/src/coreclr/nativeaot/System.Private.CoreLib/src/System/Runtime/InteropServices/NativeLibrary.NativeAot.cs
+++ b//dev/null
@@ -1,92 +0,0 @@
-using System.IO;
-using System.Reflection;
-using LibraryNameVariation = System.Runtime.Loader.LibraryNameVariation;
-namespace System.Runtime.InteropServices
-{
-    public static partial class NativeLibrary
-    {
-        internal static IntPtr LoadLibraryByName(string libraryName, Assembly assembly, DllImportSearchPath? searchPath, bool throwOnError)
-        {
-            int searchPathFlags;
-            bool searchAssemblyDirectory;
-            if (searchPath.HasValue)
-            {
-                searchPathFlags = (int)(searchPath!.Value & ~DllImportSearchPath.AssemblyDirectory);
-                searchAssemblyDirectory = (searchPath.Value & DllImportSearchPath.AssemblyDirectory) != 0;
-            }
-            else
-            {
-                GetDllImportSearchPathFlags(assembly, out searchPathFlags, out searchAssemblyDirectory);
-            }
-            LoadLibErrorTracker errorTracker = default;
-            IntPtr ret = LoadBySearch(assembly, searchAssemblyDirectory, searchPathFlags, ref errorTracker, libraryName);
-            if (throwOnError && ret == IntPtr.Zero)
-            {
-                errorTracker.Throw(libraryName);
-            }
-            return ret;
-        }
-        internal static void GetDllImportSearchPathFlags(Assembly callingAssembly, out int searchPathFlags, out bool searchAssemblyDirectory)
-        {
-            var searchPath = DllImportSearchPath.AssemblyDirectory;
-            foreach (CustomAttributeData cad in callingAssembly.CustomAttributes)
-            {
-                if (cad.AttributeType == typeof(DefaultDllImportSearchPathsAttribute))
-                {
-                    searchPath = (DllImportSearchPath)cad.ConstructorArguments[0].Value!;
-                }
-            }
-            searchPathFlags = (int)(searchPath & ~DllImportSearchPath.AssemblyDirectory);
-            searchAssemblyDirectory = (searchPath & DllImportSearchPath.AssemblyDirectory) != 0;
-        }
-        internal static IntPtr LoadBySearch(Assembly callingAssembly, bool searchAssemblyDirectory, int dllImportSearchPathFlags, ref LoadLibErrorTracker errorTracker, string libraryName)
-        {
-            IntPtr ret;
-            int loadWithAlteredPathFlags = LoadWithAlteredSearchPathFlag;
-            bool libNameIsRelativePath = !Path.IsPathFullyQualified(libraryName);
-            foreach (LibraryNameVariation libraryNameVariation in LibraryNameVariation.DetermineLibraryNameVariations(libraryName, libNameIsRelativePath))
-            {
-                string currLibNameVariation = libraryNameVariation.Prefix + libraryName + libraryNameVariation.Suffix;
-                if (!libNameIsRelativePath)
-                {
-                    int flags = loadWithAlteredPathFlags;
-                    if ((dllImportSearchPathFlags & (int)DllImportSearchPath.UseDllDirectoryForDependencies) != 0)
-                    {
-                        flags |= dllImportSearchPathFlags;
-                    }
-                    ret = LoadLibraryHelper(currLibNameVariation, flags, ref errorTracker);
-                    if (ret != IntPtr.Zero)
-                    {
-                        return ret;
-                    }
-                }
-                else if ((callingAssembly != null) && searchAssemblyDirectory)
-                {
-                }
-                ret = LoadLibraryHelper(currLibNameVariation, dllImportSearchPathFlags, ref errorTracker);
-                if (ret != IntPtr.Zero)
-                {
-                    return ret;
-                }
-            }
-            return IntPtr.Zero;
-        }
-        private static IntPtr LoadFromPath(string libraryName, bool throwOnError)
-        {
-            LoadLibErrorTracker errorTracker = default;
-            IntPtr ret = LoadLibraryHelper(libraryName, LoadWithAlteredSearchPathFlag, ref errorTracker);
-            if (throwOnError && ret == IntPtr.Zero)
-            {
-                errorTracker.Throw(libraryName);
-            }
-            return ret;
-        }
-        private static unsafe IntPtr GetSymbol(IntPtr handle, string symbolName, bool throwOnError)
-        {
-            IntPtr ret = GetSymbolOrNull(handle, symbolName);
-            if (throwOnError && ret == IntPtr.Zero)
-                throw new EntryPointNotFoundException(SR.Format(SR.Arg_EntryPointNotFoundExceptionParameterizedNoLibrary, symbolName));
-            return ret;
-        }
-    }
-}

--- a/src/coreclr/pal/src/exception/signal.cpp
+++ b//dev/null
@@ -1,824 +0,0 @@
-/*++
-Module Name:
-    exception/signal.cpp
-Abstract:
-    Signal handler implementation (map signals to exceptions)
---*/
-#include "pal/dbgmsg.h"
-SET_DEFAULT_DEBUG_CHANNEL(EXCEPT); // some headers have code with asserts, so do this first
-#include "pal/corunix.hpp"
-#include "pal/handleapi.hpp"
-#include "pal/process.h"
-#include "pal/thread.hpp"
-#include "pal/threadinfo.hpp"
-#include "pal/threadsusp.hpp"
-#include "pal/seh.hpp"
-#include "pal/signal.hpp"
-#include "pal/palinternal.h"
-#include <clrconfignocache.h>
-#include <errno.h>
-#include <signal.h>
-#if !HAVE_MACH_EXCEPTIONS
-#include "pal/init.h"
-#include "pal/debug.h"
-#include "pal/virtual.h"
-#include "pal/utils.h"
-#include <string.h>
-#include <sys/ucontext.h>
-#include <sys/utsname.h>
-#include <unistd.h>
-#include <sys/mman.h>
-#endif // !HAVE_MACH_EXCEPTIONS
-#include "pal/context.h"
-#ifdef SIGRTMIN
-#define INJECT_ACTIVATION_SIGNAL SIGRTMIN
-#else
-#define INJECT_ACTIVATION_SIGNAL SIGUSR1
-#endif
-#if !defined(INJECT_ACTIVATION_SIGNAL) && defined(FEATURE_HIJACK)
-#error FEATURE_HIJACK requires INJECT_ACTIVATION_SIGNAL to be defined
-#endif
-using namespace CorUnix;
-/* local type definitions *****************************************************/
-typedef void (*SIGFUNC)(int, siginfo_t *, void *);
-/* internal function declarations *********************************************/
-static void sigterm_handler(int code, siginfo_t *siginfo, void *context);
-#ifdef INJECT_ACTIVATION_SIGNAL
-static void inject_activation_handler(int code, siginfo_t *siginfo, void *context);
-extern void* g_InvokeActivationHandlerReturnAddress;
-#endif
-static void sigill_handler(int code, siginfo_t *siginfo, void *context);
-static void sigfpe_handler(int code, siginfo_t *siginfo, void *context);
-static void sigsegv_handler(int code, siginfo_t *siginfo, void *context);
-static void sigtrap_handler(int code, siginfo_t *siginfo, void *context);
-static void sigbus_handler(int code, siginfo_t *siginfo, void *context);
-static void sigint_handler(int code, siginfo_t *siginfo, void *context);
-static void sigquit_handler(int code, siginfo_t *siginfo, void *context);
-static void sigabrt_handler(int code, siginfo_t *siginfo, void *context);
-static bool common_signal_handler(int code, siginfo_t *siginfo, void *sigcontext, int numParams, ...);
-static void handle_signal(int signal_id, SIGFUNC sigfunc, struct sigaction *previousAction, int additionalFlags = 0, bool skipIgnored = false);
-static void restore_signal(int signal_id, struct sigaction *previousAction);
-static void restore_signal_and_resend(int code, struct sigaction* action);
-/* internal data declarations *********************************************/
-bool g_registered_signal_handlers = false;
-#if !HAVE_MACH_EXCEPTIONS
-bool g_enable_alternate_stack_check = false;
-#endif // !HAVE_MACH_EXCEPTIONS
-static bool g_registered_sigterm_handler = false;
-static bool g_registered_activation_handler = false;
-struct sigaction g_previous_sigterm;
-#ifdef INJECT_ACTIVATION_SIGNAL
-struct sigaction g_previous_activation;
-#endif
-struct sigaction g_previous_sigill;
-struct sigaction g_previous_sigtrap;
-struct sigaction g_previous_sigfpe;
-struct sigaction g_previous_sigbus;
-struct sigaction g_previous_sigsegv;
-struct sigaction g_previous_sigint;
-struct sigaction g_previous_sigquit;
-struct sigaction g_previous_sigabrt;
-#if !HAVE_MACH_EXCEPTIONS
-volatile void* g_stackOverflowHandlerStack = NULL;
-const int StackOverflowFlag = 0x40000000;
-#endif // !HAVE_MACH_EXCEPTIONS
-/* public function definitions ************************************************/
-/*++
-Function :
-    SEHInitializeSignals
-    Set up signal handlers to catch signals and translate them to exceptions
-Parameters :
-    None
-Return :
-    TRUE in case of a success, FALSE otherwise
---*/
-BOOL SEHInitializeSignals(CorUnix::CPalThread *pthrCurrent, DWORD flags)
-{
-    TRACE("Initializing signal handlers %04x\n", flags);
-#if !HAVE_MACH_EXCEPTIONS
-    g_enable_alternate_stack_check = false;
-    CLRConfigNoCache stackCheck = CLRConfigNoCache::Get("EnableAlternateStackCheck", /*noprefix*/ false, &getenv);
-    if (stackCheck.IsSet())
-    {
-        DWORD value;
-        if (stackCheck.TryAsInteger(10, value))
-            g_enable_alternate_stack_check = (value != 0);
-    }
-#endif
-    if (flags & PAL_INITIALIZE_REGISTER_SIGNALS)
-    {
-        g_registered_signal_handlers = true;
-        /* we call handle_signal for every possible signal, even
-           if we don't provide a signal handler.
-           handle_signal will set SA_RESTART flag for specified signal.
-           Therefore, all signals will have SA_RESTART flag set, preventing
-           slow Unix system calls from being interrupted. On systems without
-           siginfo_t, SIGKILL and SIGSTOP can't be restarted, so we don't
-           handle those signals. Both the Darwin and FreeBSD man pages say
-           that SIGKILL and SIGSTOP can't be handled, but FreeBSD allows us
-           to register a handler for them anyway. We don't do that.
-           see sigaction man page for more details
-           */
-        handle_signal(SIGILL, sigill_handler, &g_previous_sigill);
-        handle_signal(SIGFPE, sigfpe_handler, &g_previous_sigfpe);
-        handle_signal(SIGBUS, sigbus_handler, &g_previous_sigbus);
-        handle_signal(SIGABRT, sigabrt_handler, &g_previous_sigabrt);
-        handle_signal(SIGINT, sigint_handler, &g_previous_sigint, 0 /* additionalFlags */, true /* skipIgnored */);
-        handle_signal(SIGQUIT, sigquit_handler, &g_previous_sigquit, 0 /* additionalFlags */, true /* skipIgnored */);
-#if HAVE_MACH_EXCEPTIONS
-        handle_signal(SIGSEGV, sigsegv_handler, &g_previous_sigsegv);
-#else
-        handle_signal(SIGTRAP, sigtrap_handler, &g_previous_sigtrap);
-        handle_signal(SIGSEGV, sigsegv_handler, &g_previous_sigsegv, SA_ONSTACK);
-        if (!pthrCurrent->EnsureSignalAlternateStack())
-        {
-            return FALSE;
-        }
-        int stackOverflowStackSize = ALIGN_UP(sizeof(SignalHandlerWorkerReturnPoint), 16) + 7 * 4096;
-        stackOverflowStackSize = ALIGN_UP(stackOverflowStackSize, GetVirtualPageSize()) + GetVirtualPageSize();
-        int flags = MAP_ANONYMOUS | MAP_PRIVATE;
-#ifdef MAP_STACK
-        flags |= MAP_STACK;
-#endif
-        g_stackOverflowHandlerStack = mmap(NULL, stackOverflowStackSize, PROT_READ | PROT_WRITE, flags, -1, 0);
-        if (g_stackOverflowHandlerStack == MAP_FAILED)
-        {
-            return FALSE;
-        }
-        int st = mprotect((void*)g_stackOverflowHandlerStack, GetVirtualPageSize(), PROT_NONE);
-        if (st != 0)
-        {
-            munmap((void*)g_stackOverflowHandlerStack, stackOverflowStackSize);
-            return FALSE;
-        }
-        g_stackOverflowHandlerStack = (void*)((size_t)g_stackOverflowHandlerStack + stackOverflowStackSize);
-#endif // HAVE_MACH_EXCEPTIONS
-    }
-    /* The default action for SIGPIPE is process termination.
-       Since SIGPIPE can be signaled when trying to write on a socket for which
-       the connection has been dropped, we need to tell the system we want
-       to ignore this signal.
-       Instead of terminating the process, the system call which would had
-       issued a SIGPIPE will, instead, report an error and set errno to EPIPE.
-    */
-    signal(SIGPIPE, SIG_IGN);
-    if (flags & PAL_INITIALIZE_REGISTER_SIGTERM_HANDLER)
-    {
-        g_registered_sigterm_handler = true;
-        handle_signal(SIGTERM, sigterm_handler, &g_previous_sigterm);
-    }
-#ifdef INJECT_ACTIVATION_SIGNAL
-    if (flags & PAL_INITIALIZE_REGISTER_ACTIVATION_SIGNAL)
-    {
-        handle_signal(INJECT_ACTIVATION_SIGNAL, inject_activation_handler, &g_previous_activation);
-        g_registered_activation_handler = true;
-    }
-#endif
-    return TRUE;
-}
-/*++
-Function :
-    SEHCleanupSignals
-    Restore default signal handlers
-Parameters :
-    None
-    (no return value)
-note :
-reason for this function is that during PAL_Terminate, we reach a point where
-SEH isn't possible anymore (handle manager is off, etc). Past that point,
-we can't avoid crashing on a signal.
---*/
-void SEHCleanupSignals()
-{
-    TRACE("Restoring default signal handlers\n");
-    if (g_registered_signal_handlers)
-    {
-        restore_signal(SIGILL, &g_previous_sigill);
-#if !HAVE_MACH_EXCEPTIONS
-        restore_signal(SIGTRAP, &g_previous_sigtrap);
-#endif
-        restore_signal(SIGFPE, &g_previous_sigfpe);
-        restore_signal(SIGBUS, &g_previous_sigbus);
-        restore_signal(SIGABRT, &g_previous_sigabrt);
-        restore_signal(SIGSEGV, &g_previous_sigsegv);
-        restore_signal(SIGINT, &g_previous_sigint);
-        restore_signal(SIGQUIT, &g_previous_sigquit);
-    }
-#ifdef INJECT_ACTIVATION_SIGNAL
-    if (g_registered_activation_handler)
-    {
-        restore_signal(INJECT_ACTIVATION_SIGNAL, &g_previous_activation);
-    }
-#endif
-    if (g_registered_sigterm_handler)
-    {
-        restore_signal(SIGTERM, &g_previous_sigterm);
-    }
-}
-/* internal function definitions **********************************************/
-/*++
-Function :
-    IsRunningOnAlternateStack
-    Detects if the current signal handlers is running on an alternate stack
-Parameters :
-    The context of the signal
-Return :
-    true if we are running on an alternate stack
---*/
-bool IsRunningOnAlternateStack(void *context)
-{
-#if HAVE_MACH_EXCEPTIONS
-    return false;
-#else
-    bool isRunningOnAlternateStack;
-    if (g_enable_alternate_stack_check)
-    {
-        stack_t *signalStack = &((native_context_t *)context)->uc_stack;
-        void* alternateStackEnd = (char *)signalStack->ss_sp + signalStack->ss_size;
-        isRunningOnAlternateStack = ((signalStack->ss_flags & SS_DISABLE) == 0) && (signalStack->ss_sp <= &signalStack) && (&signalStack < alternateStackEnd);
-    }
-    else
-    {
-        isRunningOnAlternateStack = true;
-    }
-    return isRunningOnAlternateStack;
-#endif // HAVE_MACH_EXCEPTIONS
-}
-static bool IsSaSigInfo(struct sigaction* action)
-{
-    return (action->sa_flags & SA_SIGINFO) != 0;
-}
-static bool IsSigDfl(struct sigaction* action)
-{
-    return (&action->sa_handler == (void*)&action->sa_sigaction || !IsSaSigInfo(action)) &&
-            action->sa_handler == SIG_DFL;
-}
-static bool IsSigIgn(struct sigaction* action)
-{
-    return (&action->sa_handler == (void*)&action->sa_sigaction || !IsSaSigInfo(action)) &&
-            action->sa_handler == SIG_IGN;
-}
-/*++
-Function :
-    invoke_previous_action
-    synchronously invokes the previous action or aborts when that is not possible
-Parameters :
-    action  : previous sigaction struct
-    code    : signal code
-    siginfo : signal siginfo
-    context : signal context
-    signalRestarts: BOOL state : TRUE if the process will be signalled again
-    (no return value)
---*/
-static void invoke_previous_action(struct sigaction* action, int code, siginfo_t *siginfo, void *context, bool signalRestarts = true)
-{
-    _ASSERTE(action != NULL);
-    if (IsSigIgn(action))
-    {
-        if (signalRestarts)
-        {
-            PROCAbort(code, siginfo);
-        }
-        return;
-    }
-    else if (IsSigDfl(action))
-    {
-        if (signalRestarts)
-        {
-            restore_signal(code, action);
-        }
-        else
-        {
-            PROCAbort(code, siginfo);
-        }
-    }
-    else if (IsSaSigInfo(action))
-    {
-        _ASSERTE(action->sa_sigaction != NULL);
-        action->sa_sigaction(code, siginfo, context);
-    }
-    else
-    {
-        _ASSERTE(action->sa_handler != NULL);
-        action->sa_handler(code);
-    }
-    PROCNotifyProcessShutdown(IsRunningOnAlternateStack(context));
-    PROCCreateCrashDumpIfEnabled(code, siginfo);
-}
-/*++
-Function :
-    sigill_handler
-    handle SIGILL signal (EXCEPTION_ILLEGAL_INSTRUCTION, others?)
-Parameters :
-    POSIX signal handler parameter list ("man sigaction" for details)
-    (no return value)
---*/
-static void sigill_handler(int code, siginfo_t *siginfo, void *context)
-{
-    if (PALIsInitialized())
-    {
-        if (common_signal_handler(code, siginfo, context, 0))
-        {
-            return;
-        }
-    }
-    invoke_previous_action(&g_previous_sigill, code, siginfo, context);
-}
-/*++
-Function :
-    sigfpe_handler
-    handle SIGFPE signal (division by zero, floating point exception)
-Parameters :
-    POSIX signal handler parameter list ("man sigaction" for details)
-    (no return value)
---*/
-static void sigfpe_handler(int code, siginfo_t *siginfo, void *context)
-{
-    if (PALIsInitialized())
-    {
-        if (common_signal_handler(code, siginfo, context, 0))
-        {
-            return;
-        }
-    }
-    invoke_previous_action(&g_previous_sigfpe, code, siginfo, context);
-}
-#if !HAVE_MACH_EXCEPTIONS
-/*++
-Function :
-    signal_handler_worker
-    Handles signal on the original stack where the signal occurred.
-    Invoked via setcontext.
-Parameters :
-    POSIX signal handler parameter list ("man sigaction" for details)
-    returnPoint - context to which the function returns if the common_signal_handler returns
-    (no return value)
---*/
-extern "C" void signal_handler_worker(int code, siginfo_t *siginfo, void *context, SignalHandlerWorkerReturnPoint* returnPoint)
-{
-    sigset_t signal_set;
-    sigemptyset(&signal_set);
-    sigaddset(&signal_set, INJECT_ACTIVATION_SIGNAL);
-    int sigmaskRet = pthread_sigmask(SIG_UNBLOCK, &signal_set, NULL);
-    if (sigmaskRet != 0)
-    {
-        ASSERT("pthread_sigmask failed; error number is %d\n", sigmaskRet);
-    }
-    returnPoint->returnFromHandler = common_signal_handler(code, siginfo, context, 2, (size_t)0, (size_t)siginfo->si_addr);
-    sigmaskRet = pthread_sigmask(SIG_BLOCK, &signal_set, NULL);
-    if (sigmaskRet != 0)
-    {
-        ASSERT("pthread_sigmask failed; error number is %d\n", sigmaskRet);
-    }
-    RtlRestoreContext(&returnPoint->context, NULL);
-}
-/*++
-Function :
-    SwitchStackAndExecuteHandler
-    Switch to the stack specified by the sp argument
-Parameters :
-    POSIX signal handler parameter list ("man sigaction" for details)
-    sp - stack pointer of the stack to execute the handler on.
-         If sp == 0, execute it on the original stack where the signal has occurred.
-Return :
-    The return value from the signal handler
---*/
-static bool SwitchStackAndExecuteHandler(int code, siginfo_t *siginfo, void *context, size_t sp)
-{
-    volatile bool contextInitialization = true;
-    void *ptr = alloca(sizeof(SignalHandlerWorkerReturnPoint) + alignof(SignalHandlerWorkerReturnPoint) - 1);
-    SignalHandlerWorkerReturnPoint *pReturnPoint = (SignalHandlerWorkerReturnPoint *)ALIGN_UP(ptr, alignof(SignalHandlerWorkerReturnPoint));
-    RtlCaptureContext(&pReturnPoint->context);
-    if (contextInitialization)
-    {
-        contextInitialization = false;
-        ExecuteHandlerOnCustomStack(code, siginfo, context, sp, pReturnPoint);
-        _ASSERTE(FALSE); // The ExecuteHandlerOnCustomStack should never return
-    }
-    return pReturnPoint->returnFromHandler;
-}
-#endif // !HAVE_MACH_EXCEPTIONS
-/*++
-Function :
-    sigsegv_handler
-    handle SIGSEGV signal (EXCEPTION_ACCESS_VIOLATION, others)
-Parameters :
-    POSIX signal handler parameter list ("man sigaction" for details)
-    (no return value)
---*/
-static void sigsegv_handler(int code, siginfo_t *siginfo, void *context)
-{
-#if !HAVE_MACH_EXCEPTIONS
-    if (PALIsInitialized())
-    {
-        size_t sp = (size_t)GetNativeContextSP((native_context_t *)context);
-        size_t failureAddress = (size_t)siginfo->si_addr;
-        if ((failureAddress - (sp - GetVirtualPageSize())) < 2 * GetVirtualPageSize())
-        {
-            if (GetCurrentPalThread())
-            {
-                size_t handlerStackTop = __sync_val_compare_and_swap((size_t*)&g_stackOverflowHandlerStack, (size_t)g_stackOverflowHandlerStack, 0);
-                if (handlerStackTop == 0)
-                {
-                    while (true)
-                    {
-                        sleep(1);
-                    }
-                }
-                if (SwitchStackAndExecuteHandler(code | StackOverflowFlag, siginfo, context, (size_t)handlerStackTop))
-                {
-                    PROCAbort(SIGSEGV, siginfo);
-                }
-            }
-            else
-            {
-                (void)!write(STDERR_FILENO, StackOverflowMessage, sizeof(StackOverflowMessage) - 1);
-                PROCAbort(SIGSEGV, siginfo);
-            }
-        }
-        if (GetCurrentPalThread() && IsRunningOnAlternateStack(context))
-        {
-            if (SwitchStackAndExecuteHandler(code, siginfo, context, 0 /* sp */)) // sp == 0 indicates execution on the original stack
-            {
-                return;
-            }
-        }
-        else
-        {
-            if (common_signal_handler(code, siginfo, context, 2, (size_t)0, (size_t)siginfo->si_addr))
-            {
-                return;
-            }
-        }
-    }
-#endif // !HAVE_MACH_EXCEPTIONS
-    invoke_previous_action(&g_previous_sigsegv, code, siginfo, context);
-}
-/*++
-Function :
-    sigtrap_handler
-    handle SIGTRAP signal (EXCEPTION_SINGLE_STEP, EXCEPTION_BREAKPOINT)
-Parameters :
-    POSIX signal handler parameter list ("man sigaction" for details)
-    (no return value)
---*/
-static void sigtrap_handler(int code, siginfo_t *siginfo, void *context)
-{
-    if (PALIsInitialized())
-    {
-        if (common_signal_handler(code, siginfo, context, 0))
-        {
-            return;
-        }
-    }
-    invoke_previous_action(&g_previous_sigtrap, code, siginfo, context, /* signalRestarts */ false);
-}
-/*++
-Function :
-    sigbus_handler
-    handle SIGBUS signal (EXCEPTION_ACCESS_VIOLATION?)
-Parameters :
-    POSIX signal handler parameter list ("man sigaction" for details)
-    (no return value)
---*/
-static void sigbus_handler(int code, siginfo_t *siginfo, void *context)
-{
-    if (PALIsInitialized())
-    {
-        if (common_signal_handler(code, siginfo, context, 2, (size_t)0, (size_t)siginfo->si_addr))
-        {
-            return;
-        }
-    }
-    invoke_previous_action(&g_previous_sigbus, code, siginfo, context);
-}
-/*++
-Function :
-    sigabrt_handler
-    handle SIGABRT signal - abort() API
-Parameters :
-    POSIX signal handler parameter list ("man sigaction" for details)
-    (no return value)
---*/
-static void sigabrt_handler(int code, siginfo_t *siginfo, void *context)
-{
-    invoke_previous_action(&g_previous_sigabrt, code, siginfo, context);
-}
-/*++
-Function :
-    sigint_handler
-    handle SIGINT signal
-Parameters :
-    POSIX signal handler parameter list ("man sigaction" for details)
-    (no return value)
---*/
-static void sigint_handler(int code, siginfo_t *siginfo, void *context)
-{
-    PROCNotifyProcessShutdown();
-    restore_signal_and_resend(code, &g_previous_sigint);
-}
-/*++
-Function :
-    sigquit_handler
-    handle SIGQUIT signal
-Parameters :
-    POSIX signal handler parameter list ("man sigaction" for details)
-    (no return value)
---*/
-static void sigquit_handler(int code, siginfo_t *siginfo, void *context)
-{
-    PROCNotifyProcessShutdown();
-    restore_signal_and_resend(code, &g_previous_sigquit);
-}
-/*++
-Function :
-    sigterm_handler
-    handle SIGTERM signal
-Parameters :
-    POSIX signal handler parameter list ("man sigaction" for details)
-    (no return value)
---*/
-static void sigterm_handler(int code, siginfo_t *siginfo, void *context)
-{
-    if (PALIsInitialized())
-    {
-        CLRConfigNoCache enableDumpOnSigTerm = CLRConfigNoCache::Get("EnableDumpOnSigTerm", /*noprefix*/ false, &getenv);
-        DWORD val = 0;
-        if (enableDumpOnSigTerm.IsSet() && enableDumpOnSigTerm.TryAsInteger(10, val) && val == 1)
-        {
-            PROCCreateCrashDumpIfEnabled(code, siginfo);
-        }
-        _ASSERTE(g_pSynchronizationManager != nullptr);
-        g_pSynchronizationManager->SendTerminationRequestToWorkerThread();
-    }
-    else
-    {
-        restore_signal_and_resend(SIGTERM, &g_previous_sigterm);
-    }
-}
-#ifdef INJECT_ACTIVATION_SIGNAL
-/*++
-Function :
-    InvokeActivationHandler
-    Invoke the registered activation handler.
-    It also saves the return address (inject_activation_handler) so that PAL_VirtualUnwind can detect that
-    it has reached that method and use the context stored in the winContext there to unwind to the code
-    where the activation was injected. This is necessary on Alpine Linux where the libunwind cannot correctly
-    unwind past the signal frame.
-Parameters :
-    Windows style context of the location where the activation was injected
-(no return value)
---*/
-__attribute__((noinline))
-static void InvokeActivationHandler(CONTEXT *pWinContext)
-{
-    g_InvokeActivationHandlerReturnAddress = __builtin_return_address(0);
-    g_activationFunction(pWinContext);
-}
-/*++
-Function :
-    inject_activation_handler
-    Handle the INJECT_ACTIVATION_SIGNAL signal. This signal interrupts a running thread
-    so it can call the activation function that was specified when sending the signal.
-Parameters :
-    POSIX signal handler parameter list ("man sigaction" for details)
-(no return value)
---*/
-static void inject_activation_handler(int code, siginfo_t *siginfo, void *context)
-{
-    if (g_activationFunction != NULL && (siginfo->si_pid == getpid()
-#ifdef HOST_OSX
-    || siginfo->si_pid == 0
-#endif
-    ))
-    {
-        _ASSERTE(g_safeActivationCheckFunction != NULL);
-        native_context_t *ucontext = (native_context_t *)context;
-        CONTEXT winContext;
-        RtlCaptureContext(&winContext);
-        ULONG contextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_FLOATING_POINT;
-#if defined(HOST_AMD64)
-        contextFlags |= CONTEXT_XSTATE;
-#endif
-        CONTEXTFromNativeContext(
-            ucontext,
-            &winContext,
-            contextFlags);
-        if (g_safeActivationCheckFunction(CONTEXTGetPC(&winContext), /* checkingCurrentThread */ TRUE))
-        {
-            g_inject_activation_context_locvar_offset = (int)((char*)&winContext - (char*)__builtin_frame_address(0));
-            int savedErrNo = errno; // Make sure that errno is not modified
-            InvokeActivationHandler(&winContext);
-            errno = savedErrNo;
-            CONTEXTToNativeContext(&winContext, ucontext);
-        }
-    }
-    else
-    {
-        if (g_previous_activation.sa_flags & SA_SIGINFO)
-        {
-            _ASSERTE(g_previous_activation.sa_sigaction != NULL);
-            g_previous_activation.sa_sigaction(code, siginfo, context);
-        }
-        else
-        {
-            if (g_previous_activation.sa_handler != SIG_IGN &&
-                g_previous_activation.sa_handler != SIG_DFL)
-            {
-                _ASSERTE(g_previous_activation.sa_handler != NULL);
-                g_previous_activation.sa_handler(code);
-            }
-        }
-    }
-}
-#endif
-/*++
-Function :
-    InjectActivationInternal
-    Interrupt the specified thread and have it call the activationFunction passed in
-Parameters :
-    pThread            - target PAL thread
-    activationFunction - function to call
-(no return value)
---*/
-PAL_ERROR InjectActivationInternal(CorUnix::CPalThread* pThread)
-{
-#ifdef INJECT_ACTIVATION_SIGNAL
-    int status = pthread_kill(pThread->GetPThreadSelf(), INJECT_ACTIVATION_SIGNAL);
-#ifdef __APPLE__
-    if (status == ENOTSUP)
-    {
-        return ERROR_NOT_SUPPORTED;
-    }
-#endif
-    if ((status != 0) && (status != EAGAIN))
-    {
-        PROCAbort();
-    }
-    return NO_ERROR;
-#else
-    return ERROR_CANCELLED;
-#endif
-}
-#if !HAVE_MACH_EXCEPTIONS
-/*++
-Function :
-    signal_ignore_handler
-    Simple signal handler which does nothing
-Parameters :
-    POSIX signal handler parameter list ("man sigaction" for details)
-(no return value)
---*/
-static void signal_ignore_handler(int code, siginfo_t *siginfo, void *context)
-{
-}
-#endif // !HAVE_MACH_EXCEPTIONS
-void PAL_IgnoreProfileSignal(int signalNum)
-{
-#if !HAVE_MACH_EXCEPTIONS
-    handle_signal(signalNum, signal_ignore_handler, 0);
-#endif
-}
-/*++
-Function :
-    common_signal_handler
-    common code for all signal handlers
-Parameters :
-    int code : signal received
-    siginfo_t *siginfo : siginfo passed to the signal handler
-    void *context : context structure passed to the signal handler
-    int numParams : number of variable parameters of the exception
-    ... : variable parameters of the exception (each of size_t type)
-    Returns true if the execution should continue or false if the exception was unhandled
-Note:
-    the "pointers" parameter should contain a valid exception record pointer,
-    but the ContextRecord pointer will be overwritten.
---*/
-__attribute__((noinline))
-static bool common_signal_handler(int code, siginfo_t *siginfo, void *sigcontext, int numParams, ...)
-{
-#if !HAVE_MACH_EXCEPTIONS
-    sigset_t signal_set;
-    CONTEXT signalContextRecord;
-    CONTEXT* signalContextRecordPtr = &signalContextRecord;
-    EXCEPTION_RECORD exceptionRecord;
-    native_context_t *ucontext;
-    ucontext = (native_context_t *)sigcontext;
-    g_hardware_exception_context_locvar_offset = (int)((char*)&signalContextRecordPtr - (char*)__builtin_frame_address(0));
-    if (code == (SIGSEGV | StackOverflowFlag))
-    {
-        exceptionRecord.ExceptionCode = EXCEPTION_STACK_OVERFLOW;
-        code &= ~StackOverflowFlag;
-    }
-    else
-    {
-        exceptionRecord.ExceptionCode = CONTEXTGetExceptionCodeForSignal(siginfo, ucontext);
-    }
-    exceptionRecord.ExceptionFlags = EXCEPTION_IS_SIGNAL;
-    exceptionRecord.ExceptionRecord = NULL;
-    exceptionRecord.ExceptionAddress = GetNativeContextPC(ucontext);
-    exceptionRecord.NumberParameters = numParams;
-    va_list params;
-    va_start(params, numParams);
-    for (int i = 0; i < numParams; i++)
-    {
-        exceptionRecord.ExceptionInformation[i] = va_arg(params, size_t);
-    }
-    RtlCaptureContext(&signalContextRecord);
-    ULONG contextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_FLOATING_POINT;
-#if defined(HOST_AMD64)
-    contextFlags |= CONTEXT_XSTATE;
-#endif
-    CONTEXTFromNativeContext(ucontext, &signalContextRecord, contextFlags);
-    /* Unmask signal so we can receive it again */
-    sigemptyset(&signal_set);
-    sigaddset(&signal_set, code);
-    int sigmaskRet = pthread_sigmask(SIG_UNBLOCK, &signal_set, NULL);
-    if (sigmaskRet != 0)
-    {
-        ASSERT("pthread_sigmask failed; error number is %d\n", sigmaskRet);
-    }
-    signalContextRecord.ContextFlags |= CONTEXT_EXCEPTION_ACTIVE;
-    PAL_SEHException exception(&exceptionRecord, &signalContextRecord, true);
-    if (SEHProcessException(&exception))
-    {
-        CONTEXTToNativeContext(exception.ExceptionPointers.ContextRecord, ucontext);
-        return true;
-    }
-#endif // !HAVE_MACH_EXCEPTIONS
-    return false;
-}
-/*++
-Function :
-    handle_signal
-    register handler for specified signal
-Parameters :
-    int signal_id : signal to handle
-    SIGFUNC sigfunc : signal handler
-    previousAction : previous sigaction struct
-    (no return value)
-note : if sigfunc is NULL, the default signal handler is restored
---*/
-void handle_signal(int signal_id, SIGFUNC sigfunc, struct sigaction *previousAction, int additionalFlags, bool skipIgnored)
-{
-    struct sigaction newAction;
-    newAction.sa_flags = SA_RESTART | additionalFlags;
-    newAction.sa_handler = NULL;
-    newAction.sa_sigaction = sigfunc;
-    newAction.sa_flags |= SA_SIGINFO;
-    sigemptyset(&newAction.sa_mask);
-#ifdef INJECT_ACTIVATION_SIGNAL
-    if ((additionalFlags & SA_ONSTACK) != 0)
-    {
-        sigaddset(&newAction.sa_mask, INJECT_ACTIVATION_SIGNAL);
-    }
-#endif
-    if (skipIgnored)
-    {
-        if (-1 == sigaction(signal_id, NULL, previousAction))
-        {
-            ASSERT("handle_signal: sigaction() call failed with error code %d (%s)\n",
-                errno, strerror(errno));
-        }
-        else if (previousAction->sa_handler == SIG_IGN)
-        {
-            return;
-        }
-    }
-    if (-1 == sigaction(signal_id, &newAction, previousAction))
-    {
-        ASSERT("handle_signal: sigaction() call failed with error code %d (%s)\n",
-            errno, strerror(errno));
-    }
-}
-/*++
-Function :
-    restore_signal
-    restore handler for specified signal
-Parameters :
-    int signal_id : signal to handle
-    previousAction : previous sigaction struct to restore
-    (no return value)
---*/
-void restore_signal(int signal_id, struct sigaction *previousAction)
-{
-    if (-1 == sigaction(signal_id, previousAction, NULL))
-    {
-        ASSERT("restore_signal: sigaction() call failed with error code %d (%s)\n",
-            errno, strerror(errno));
-    }
-}
-/*++
-Function :
-    restore_signal_and_resend
-    restore handler for specified signal and signal the process
-Parameters :
-    int signal_id : signal to handle
-    previousAction : previous sigaction struct to restore
-    (no return value)
---*/
-void restore_signal_and_resend(int signal_id, struct sigaction* previousAction)
-{
-    restore_signal(signal_id, previousAction);
-    kill(gPID, signal_id);
-}

--- a/src/coreclr/pal/src/include/pal/process.h
+++ b//dev/null
@@ -1,140 +0,0 @@
-/*++
-Module Name:
-    include/pal/process.h
-Abstract:
-    Miscellaneous process related functions.
-Revision History:
---*/
-#ifndef _PAL_PROCESS_H_
-#define _PAL_PROCESS_H_
-#include "pal/palinternal.h"
-#include "pal/stackstring.hpp"
-#ifdef __cplusplus
-extern "C"
-{
-#endif // __cplusplus
-/* thread ID of thread that has initiated an ExitProcess (or TerminateProcess).
-   this is to make sure only one thread cleans up the PAL, and also to prevent
-   calls to CreateThread from succeeding once shutdown has started
-   [defined in process.c]
-*/
-extern Volatile<LONG> terminator;
-extern DWORD gPID;
-extern DWORD gSID;
-extern LPWSTR pAppDir;
-#ifdef __APPLE__
-extern LPCSTR gApplicationGroupId;
-extern int gApplicationGroupIdLength;
-#endif // __APPLE__
-extern PathCharString *gSharedFilesPath;
-/*++
-Function:
-  PROCGetProcessIDFromHandle
-Abstract
-  Return the process ID from a process handle
---*/
-DWORD PROCGetProcessIDFromHandle(HANDLE hProcess);
-/*++
-Function:
-  PROCCreateInitialProcess
-Abstract
-  Initialize all the structures for the initial process.
-Parameter
-  lpwstrCmdLine:   Command line.
-  lpwstrFullPath : Full path to executable
-Return
-  TRUE: if successful
-  FALSE: otherwise
-Notes :
-    This function takes ownership of lpwstrCmdLine, but not of lpwstrFullPath
---*/
-BOOL PROCCreateInitialProcess(LPWSTR lpwstrCmdLine, LPWSTR lpwstrFullPath);
-/*++
-Function:
-  PROCCleanupInitialProcess
-Abstract
-  Cleanup all the structures for the initial process.
-Parameter
-  VOID
-Return
-  VOID
---*/
-VOID PROCCleanupInitialProcess(VOID);
-#if USE_SYSV_SEMAPHORES
-/*++
-Function:
-  PROCCleanupThreadSemIds(VOID);
-Abstract
-  Cleanup SysV semaphore ids for all threads.
-(no parameters, no return value)
---*/
-VOID PROCCleanupThreadSemIds(VOID);
-#endif
-/*++
-Function:
-  PROCProcessLock
-Abstract
-  Enter the critical section associated to the current process
---*/
-VOID PROCProcessLock(VOID);
-/*++
-Function:
-  PROCProcessUnlock
-Abstract
-  Leave the critical section associated to the current process
---*/
-VOID PROCProcessUnlock(VOID);
-/*++
-Function
-  PROCAbortInitialize()
-Abstract
-  Initialize the process abort crash dump program file path and
-  name. Doing all of this ahead of time so nothing is allocated
-  or copied in PROCAbort/signal handler.
-Return
-  TRUE - succeeds, FALSE - fails
---*/
-BOOL PROCAbortInitialize();
-/*++
-Function:
-  PROCAbort()
-  Aborts the process after calling the shutdown cleanup handler. This function
-  should be called instead of calling abort() directly.
-Parameters:
-  signal - POSIX signal number
-  siginfo - POSIX signal info
-  Does not return
---*/
-PAL_NORETURN
-VOID PROCAbort(int signal = SIGABRT, siginfo_t* siginfo = nullptr);
-/*++
-Function:
-  PROCNotifyProcessShutdown
-  Calls the abort handler to do any shutdown cleanup. Call be
-  called from the unhandled native exception handler.
-(no return value)
---*/
-VOID PROCNotifyProcessShutdown(bool isExecutingOnAltStack = false);
-/*++
-Function:
-  PROCCreateCrashDumpIfEnabled
-  Creates crash dump of the process (if enabled). Can be
-  called from the unhandled native exception handler.
-Parameters:
-  signal - POSIX signal number
-(no return value)
---*/
-VOID PROCCreateCrashDumpIfEnabled(int signal, siginfo_t* siginfo);
-/*++
-Function:
-  InitializeFlushProcessWriteBuffers
-Abstract
-  This function initializes data structures needed for the FlushProcessWriteBuffers
-Return
-  TRUE if it succeeded, FALSE otherwise
---*/
-BOOL InitializeFlushProcessWriteBuffers();
-#ifdef __cplusplus
-}
-#endif // __cplusplus
-#endif //PAL_PROCESS_H_

--- a/src/coreclr/pal/src/thread/process.cpp
+++ b//dev/null
@@ -1,3410 +0,0 @@
-/*++
-Module Name:
-    process.cpp
-Abstract:
-    Implementation of process object and functions related to processes.
---*/
-#include "pal/dbgmsg.h"
-SET_DEFAULT_DEBUG_CHANNEL(PROCESS); // some headers have code with asserts, so do this first
-#include "pal/procobj.hpp"
-#include "pal/thread.hpp"
-#include "pal/file.hpp"
-#include "pal/handlemgr.hpp"
-#include "pal/module.h"
-#include "procprivate.hpp"
-#include "pal/palinternal.h"
-#include "pal/process.h"
-#include "pal/init.h"
-#include "pal/critsect.h"
-#include "pal/debug.h"
-#include "pal/utils.h"
-#include "pal/environ.h"
-#include "pal/virtual.h"
-#include "pal/stackstring.hpp"
-#include "pal/signal.hpp"
-#include <clrconfignocache.h>
-#include <errno.h>
-#if HAVE_POLL
-#include <poll.h>
-#else
-#include "pal/fakepoll.h"
-#endif  // HAVE_POLL
-#include <unistd.h>
-#include <sys/mman.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <signal.h>
-#if HAVE_PRCTL_H
-#include <sys/prctl.h>
-#include <sys/syscall.h>
-#endif
-#include <sys/wait.h>
-#include <sys/time.h>
-#include <sys/resource.h>
-#include <debugmacrosext.h>
-#include <semaphore.h>
-#include <stdint.h>
-#include <dlfcn.h>
-#include <limits.h>
-#include <vector>
-#ifdef __linux__
-#include <sys/syscall.h> // __NR_membarrier
-# if !defined(__NR_membarrier)
-#  if defined(__amd64__)
-#   define __NR_membarrier  324
-#  elif defined(__i386__)
-#   define __NR_membarrier  375
-#  elif defined(__arm__)
-#   define __NR_membarrier  389
-#  elif defined(__aarch64__)
-#   define __NR_membarrier  283
-#  elif defined(__loongarch64)
-#   define __NR_membarrier  283
-#  else
-#   error Unknown architecture
-#  endif
-# endif
-#endif
-#ifdef __APPLE__
-#include <libproc.h>
-#include <sys/sysctl.h>
-#include <sys/posix_sem.h>
-#include <mach/task.h>
-#include <mach/vm_map.h>
-extern "C"
-{
-#  include <mach/thread_state.h>
-}
-#define CHECK_MACH(_msg, machret) do {                                      \
-        if (machret != KERN_SUCCESS)                                        \
-        {                                                                   \
-            char _szError[1024];                                            \
-            snprintf(_szError, ARRAY_SIZE(_szError), "%s: %u: %s", __FUNCTION__, __LINE__, _msg);  \
-            mach_error(_szError, machret);                                  \
-            abort();                                                        \
-        }                                                                   \
-    } while (false)
-#endif // __APPLE__
-#ifdef __NetBSD__
-#include <sys/cdefs.h>
-#include <sys/param.h>
-#include <sys/sysctl.h>
-#include <kvm.h>
-#endif
-#ifdef __FreeBSD__
-#include <sys/sysctl.h>
-#include <sys/user.h>
-#endif
-extern char *g_szCoreCLRPath;
-extern bool g_running_in_exe;
-using namespace CorUnix;
-CObjectType CorUnix::otProcess(
-                otiProcess,
-                NULL,   // No cleanup routine
-                NULL,   // No initialization routine
-                0,      // No immutable data
-                NULL,   // No immutable data copy routine
-                NULL,   // No immutable data cleanup routine
-                sizeof(CProcProcessLocalData),
-                NULL,   // No process local data cleanup routine
-                0,      // No shared data
-                PROCESS_ALL_ACCESS,
-                CObjectType::SecuritySupported,
-                CObjectType::SecurityInfoNotPersisted,
-                CObjectType::UnnamedObject,
-                CObjectType::CrossProcessDuplicationAllowed,
-                CObjectType::WaitableObject,
-                CObjectType::SingleTransitionObject,
-                CObjectType::ThreadReleaseHasNoSideEffects,
-                CObjectType::NoOwner
-                );
-#ifdef __NR_membarrier
-# define membarrier(...)  syscall(__NR_membarrier, __VA_ARGS__)
-#else
-# define membarrier(...)  -ENOSYS
-#endif
-enum membarrier_cmd
-{
-    MEMBARRIER_CMD_QUERY                                 = 0,
-    MEMBARRIER_CMD_GLOBAL                                = (1 << 0),
-    MEMBARRIER_CMD_GLOBAL_EXPEDITED                      = (1 << 1),
-    MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED             = (1 << 2),
-    MEMBARRIER_CMD_PRIVATE_EXPEDITED                     = (1 << 3),
-    MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED            = (1 << 4),
-    MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE           = (1 << 5),
-    MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE  = (1 << 6)
-};
-static int s_flushUsingMemBarrier = 0;
-static int* s_helperPage = 0;
-pthread_mutex_t flushProcessWriteBuffersMutex;
-CAllowedObjectTypes aotProcess(otiProcess);
-IPalObject* CorUnix::g_pobjProcess;
-CRITICAL_SECTION g_csProcess;
-CPalThread* CorUnix::pGThreadList;
-DWORD g_dwThreadCount;
-LPWSTR g_lpwstrCmdLine = NULL;
-LPWSTR g_lpwstrAppDir = NULL;
-Volatile<LONG> terminator = 0;
-DWORD gPID = (DWORD) -1;
-DWORD gSID = (DWORD) -1;
-#ifdef __APPLE__
-LPCSTR gApplicationGroupId = nullptr;
-int gApplicationGroupIdLength = 0;
-#endif // __APPLE__
-PathCharString* gSharedFilesPath = nullptr;
-#if defined(__NetBSD__)
-#define CLR_SEM_MAX_NAMELEN 15
-#elif defined(__APPLE__)
-#define CLR_SEM_MAX_NAMELEN PSEMNAMLEN
-#elif defined(NAME_MAX)
-#define CLR_SEM_MAX_NAMELEN (NAME_MAX - 4)
-#else
-#define CLR_SEM_MAX_NAMELEN MAX_PATH
-#endif
-static_assert_no_msg(CLR_SEM_MAX_NAMELEN <= MAX_PATH);
-Volatile<PSHUTDOWN_CALLBACK> g_shutdownCallback = nullptr;
-std::vector<const char*> g_argvCreateDump;
-pthread_key_t CorUnix::thObjKey;
-static WCHAR W16_WHITESPACE[]= {0x0020, 0x0009, 0x000D, 0};
-static WCHAR W16_WHITESPACE_DQUOTE[]= {0x0020, 0x0009, 0x000D, '"', 0};
-enum FILETYPE
-{
-    FILE_ERROR,/*ERROR*/
-    FILE_UNIX, /*Unix Executable*/
-    FILE_DIR   /*Directory*/
-};
-#pragma pack(push,1)
-struct UnambiguousProcessDescriptor
-{
-    UnambiguousProcessDescriptor()
-    {
-    }
-    UnambiguousProcessDescriptor(DWORD processId, UINT64 disambiguationKey)
-    {
-        Init(processId, disambiguationKey);
-    }
-    void Init(DWORD processId, UINT64 disambiguationKey)
-    {
-        m_processId = processId;
-        m_disambiguationKey = disambiguationKey;
-    }
-    UINT64 m_disambiguationKey;
-    DWORD m_processId;
-};
-#pragma pack(pop)
-static
-DWORD
-StartupHelperThread(
-    LPVOID p);
-static
-BOOL
-GetProcessIdDisambiguationKey(
-    IN DWORD processId,
-    OUT UINT64 *disambiguationKey);
-PAL_ERROR
-PROCGetProcessStatus(
-    CPalThread *pThread,
-    HANDLE hProcess,
-    PROCESS_STATE *pps,
-    DWORD *pdwExitCode);
-static
-void
-CreateSemaphoreName(
-    char semName[CLR_SEM_MAX_NAMELEN],
-    LPCSTR semaphoreName,
-    const UnambiguousProcessDescriptor& unambiguousProcessDescriptor,
-    LPCSTR applicationGroupId);
-static BOOL getFileName(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, PathCharString& lpFileName);
-static char ** buildArgv(LPCWSTR lpCommandLine, PathCharString& lpAppPath, UINT *pnArg);
-static BOOL getPath(PathCharString& lpFileName, PathCharString& lpPathFileName);
-static int checkFileType(LPCSTR lpFileName);
-static BOOL PROCEndProcess(HANDLE hProcess, UINT uExitCode, BOOL bTerminateUnconditionally);
-/*++
-Function:
-  GetCurrentProcessId
-See MSDN doc.
---*/
-DWORD
-PALAPI
-GetCurrentProcessId(
-            VOID)
-{
-    PERF_ENTRY(GetCurrentProcessId);
-    ENTRY("GetCurrentProcessId()\n" );
-    LOGEXIT("GetCurrentProcessId returns DWORD %#x\n", gPID);
-    PERF_EXIT(GetCurrentProcessId);
-    return gPID;
-}
-/*++
-Function:
-  GetCurrentSessionId
-See MSDN doc.
---*/
-DWORD
-PALAPI
-GetCurrentSessionId(
-            VOID)
-{
-    PERF_ENTRY(GetCurrentSessionId);
-    ENTRY("GetCurrentSessionId()\n" );
-    LOGEXIT("GetCurrentSessionId returns DWORD %#x\n", gSID);
-    PERF_EXIT(GetCurrentSessionId);
-    return gSID;
-}
-/*++
-Function:
-  GetCurrentProcess
-See MSDN doc.
---*/
-HANDLE
-PALAPI
-GetCurrentProcess(
-          VOID)
-{
-    PERF_ENTRY(GetCurrentProcess);
-    ENTRY("GetCurrentProcess()\n" );
-    LOGEXIT("GetCurrentProcess returns HANDLE %p\n", hPseudoCurrentProcess);
-    PERF_EXIT(GetCurrentProcess);
-    /* return a pseudo handle */
-    return hPseudoCurrentProcess;
-}
-/*++
-Function:
-  CreateProcessW
-Note:
-  Only Standard handles need to be inherited.
-  Security attributes parameters are not used.
-See MSDN doc.
---*/
-BOOL
-PALAPI
-CreateProcessW(
-           IN LPCWSTR lpApplicationName,
-           IN LPWSTR lpCommandLine,
-           IN LPSECURITY_ATTRIBUTES lpProcessAttributes,
-           IN LPSECURITY_ATTRIBUTES lpThreadAttributes,
-           IN BOOL bInheritHandles,
-           IN DWORD dwCreationFlags,
-           IN LPVOID lpEnvironment,
-           IN LPCWSTR lpCurrentDirectory,
-           IN LPSTARTUPINFOW lpStartupInfo,
-           OUT LPPROCESS_INFORMATION lpProcessInformation)
-{
-    PAL_ERROR palError = NO_ERROR;
-    CPalThread *pThread;
-    PERF_ENTRY(CreateProcessW);
-    ENTRY("CreateProcessW(lpAppName=%p (%S), lpCmdLine=%p (%S), lpProcessAttr=%p,"
-           "lpThreadAttr=%p, bInherit=%d, dwFlags=%#x, lpEnv=%p,"
-           "lpCurrentDir=%p (%S), lpStartupInfo=%p, lpProcessInfo=%p)\n",
-           lpApplicationName?lpApplicationName:W16_NULLSTRING,
-           lpApplicationName?lpApplicationName:W16_NULLSTRING,
-           lpCommandLine?lpCommandLine:W16_NULLSTRING,
-           lpCommandLine?lpCommandLine:W16_NULLSTRING,lpProcessAttributes,
-           lpThreadAttributes, bInheritHandles, dwCreationFlags,lpEnvironment,
-           lpCurrentDirectory?lpCurrentDirectory:W16_NULLSTRING,
-           lpCurrentDirectory?lpCurrentDirectory:W16_NULLSTRING,
-           lpStartupInfo, lpProcessInformation);
-    pThread = InternalGetCurrentThread();
-    palError = InternalCreateProcess(
-        pThread,
-        lpApplicationName,
-        lpCommandLine,
-        lpProcessAttributes,
-        lpThreadAttributes,
-        dwCreationFlags,
-        lpEnvironment,
-        lpCurrentDirectory,
-        lpStartupInfo,
-        lpProcessInformation
-        );
-    if (NO_ERROR != palError)
-    {
-        pThread->SetLastError(palError);
-    }
-    LOGEXIT("CreateProcessW returns BOOL %d\n", NO_ERROR == palError);
-    PERF_EXIT(CreateProcessW);
-    return NO_ERROR == palError;
-}
-PAL_ERROR
-PrepareStandardHandle(
-    CPalThread *pThread,
-    HANDLE hFile,
-    IPalObject **ppobjFile,
-    int *piFd
-    )
-{
-    PAL_ERROR palError = NO_ERROR;
-    IPalObject *pobjFile = NULL;
-    IDataLock *pDataLock = NULL;
-    CFileProcessLocalData *pLocalData = NULL;
-    int iError = 0;
-    palError = g_pObjectManager->ReferenceObjectByHandle(
-        pThread,
-        hFile,
-        &aotFile,
-        &pobjFile
-        );
-    if (NO_ERROR != palError)
-    {
-        ERROR("Bad handle passed through CreateProcess\n");
-        goto PrepareStandardHandleExit;
-    }
-    palError = pobjFile->GetProcessLocalData(
-        pThread,
-        ReadLock,
-        &pDataLock,
-        reinterpret_cast<void **>(&pLocalData)
-        );
-    if (NO_ERROR != palError)
-    {
-        ASSERT("Unable to access file data\n");
-        goto PrepareStandardHandleExit;
-    }
-    if (!pLocalData->inheritable)
-    {
-        ERROR("Non-inheritable handle passed through CreateProcess\n");
-        palError = ERROR_INVALID_HANDLE;
-        goto PrepareStandardHandleExit;
-    }
-    iError = fcntl(pLocalData->unix_fd, F_SETFD, 0);
-    if (-1 == iError)
-    {
-        ERROR("Unable to remove close-on-exec for file (errno %i)\n", errno);
-        palError = ERROR_INVALID_HANDLE;
-        goto PrepareStandardHandleExit;
-    }
-    *piFd = pLocalData->unix_fd;
-    pDataLock->ReleaseLock(pThread, FALSE);
-    pDataLock = NULL;
-    *ppobjFile = pobjFile;
-    pobjFile = NULL;
-PrepareStandardHandleExit:
-    if (NULL != pDataLock)
-    {
-        pDataLock->ReleaseLock(pThread, FALSE);
-    }
-    if (NULL != pobjFile)
-    {
-        pobjFile->ReleaseReference(pThread);
-    }
-    return palError;
-}
-PAL_ERROR
-CorUnix::InternalCreateProcess(
-    CPalThread *pThread,
-    LPCWSTR lpApplicationName,
-    LPWSTR lpCommandLine,
-    LPSECURITY_ATTRIBUTES lpProcessAttributes,
-    LPSECURITY_ATTRIBUTES lpThreadAttributes,
-    DWORD dwCreationFlags,
-    LPVOID lpEnvironment,
-    LPCWSTR lpCurrentDirectory,
-    LPSTARTUPINFOW lpStartupInfo,
-    LPPROCESS_INFORMATION lpProcessInformation
-    )
-{
-    PAL_ERROR palError = NO_ERROR;
-    IPalObject *pobjProcess = NULL;
-    IPalObject *pobjProcessRegistered = NULL;
-    IDataLock *pLocalDataLock = NULL;
-    CProcProcessLocalData *pLocalData;
-    IDataLock *pSharedDataLock = NULL;
-    CPalThread *pDummyThread = NULL;
-    HANDLE hDummyThread = NULL;
-    HANDLE hProcess = NULL;
-    CObjectAttributes oa(NULL, lpProcessAttributes);
-    IPalObject *pobjFileIn = NULL;
-    int iFdIn = -1;
-    IPalObject *pobjFileOut = NULL;
-    int iFdOut = -1;
-    IPalObject *pobjFileErr = NULL;
-    int iFdErr = -1;
-    pid_t processId;
-    PathCharString lpFileNamePS;
-    char **lppArgv = NULL;
-    UINT nArg;
-    int  iRet;
-    char **EnvironmentArray=NULL;
-    int child_blocking_pipe = -1;
-    int parent_blocking_pipe = -1;
-    /* Validate parameters */
-    /* note : specs indicate lpApplicationName should always
-       be NULL; however support for it is already implemented. Leaving the code
-       in, specs can change; but rejecting non-NULL for now to conform to the
-       spec. */
-    if( NULL != lpApplicationName )
-    {
-        ASSERT("lpApplicationName should be NULL, but is %S instead\n",
-               lpApplicationName);
-        palError = ERROR_INVALID_PARAMETER;
-        goto InternalCreateProcessExit;
-    }
-    if (0 != (dwCreationFlags & ~(CREATE_SUSPENDED|CREATE_NEW_CONSOLE)))
-    {
-        ASSERT("Unexpected creation flags (%#x)\n", dwCreationFlags);
-        palError = ERROR_INVALID_PARAMETER;
-        goto InternalCreateProcessExit;
-    }
-    /* Security attributes parameters are ignored */
-    if (lpProcessAttributes != NULL &&
-        (lpProcessAttributes->lpSecurityDescriptor != NULL ||
-         lpProcessAttributes->bInheritHandle != TRUE))
-    {
-        ASSERT("lpProcessAttributes is invalid, parameter ignored (%p)\n",
-               lpProcessAttributes);
-        palError = ERROR_INVALID_PARAMETER;
-        goto InternalCreateProcessExit;
-    }
-    if (lpThreadAttributes != NULL)
-    {
-        ASSERT("lpThreadAttributes parameter must be NULL (%p)\n",
-               lpThreadAttributes);
-        palError = ERROR_INVALID_PARAMETER;
-        goto InternalCreateProcessExit;
-    }
-    /* note : Win32 crashes in this case */
-    if(NULL == lpStartupInfo)
-    {
-        ERROR("lpStartupInfo is NULL\n");
-        palError = ERROR_INVALID_PARAMETER;
-        goto InternalCreateProcessExit;
-    }
-    /* Validate lpStartupInfo.cb field */
-    if (lpStartupInfo->cb < sizeof(STARTUPINFOW))
-    {
-        ASSERT("lpStartupInfo parameter structure size is invalid (%u)\n",
-              lpStartupInfo->cb);
-        palError = ERROR_INVALID_PARAMETER;
-        goto InternalCreateProcessExit;
-    }
-    /* lpStartupInfo should be either zero or STARTF_USESTDHANDLES */
-    if (lpStartupInfo->dwFlags & ~STARTF_USESTDHANDLES)
-    {
-        ASSERT("lpStartupInfo parameter invalid flags (%#x)\n",
-              lpStartupInfo->dwFlags);
-        palError = ERROR_INVALID_PARAMETER;
-        goto InternalCreateProcessExit;
-    }
-    /* validate given standard handles if we have any */
-    if (lpStartupInfo->dwFlags & STARTF_USESTDHANDLES)
-    {
-        palError = PrepareStandardHandle(
-            pThread,
-            lpStartupInfo->hStdInput,
-            &pobjFileIn,
-            &iFdIn
-            );
-        if (NO_ERROR != palError)
-        {
-            goto InternalCreateProcessExit;
-        }
-        palError = PrepareStandardHandle(
-            pThread,
-            lpStartupInfo->hStdOutput,
-            &pobjFileOut,
-            &iFdOut
-            );
-        if (NO_ERROR != palError)
-        {
-            goto InternalCreateProcessExit;
-        }
-        palError = PrepareStandardHandle(
-            pThread,
-            lpStartupInfo->hStdError,
-            &pobjFileErr,
-            &iFdErr
-            );
-        if (NO_ERROR != palError)
-        {
-            goto InternalCreateProcessExit;
-        }
-    }
-    if (!getFileName(lpApplicationName, lpCommandLine, lpFileNamePS))
-    {
-        ERROR("Can't find executable!\n");
-        palError = ERROR_FILE_NOT_FOUND;
-        goto InternalCreateProcessExit;
-    }
-    /* check type of file */
-    iRet = checkFileType(lpFileNamePS);
-    switch (iRet)
-    {
-        case FILE_ERROR: /* file not found, or not an executable */
-            WARN ("File is not valid (%s)", lpFileNamePS.GetString());
-            palError = ERROR_FILE_NOT_FOUND;
-            goto InternalCreateProcessExit;
-        case FILE_UNIX: /* Unix binary file */
-            break;  /* nothing to do */
-        case FILE_DIR:/*Directory*/
-            WARN ("File is a Directory (%s)", lpFileNamePS.GetString());
-            palError = ERROR_ACCESS_DENIED;
-            goto InternalCreateProcessExit;
-            break;
-        default: /* not supposed to get here */
-            ASSERT ("Invalid return type from checkFileType");
-            palError = ERROR_FILE_NOT_FOUND;
-            goto InternalCreateProcessExit;
-    }
-    /* build Argument list, lppArgv is allocated in buildArgv function and
-       requires to be freed */
-    lppArgv = buildArgv(lpCommandLine, lpFileNamePS, &nArg);
-    /* set the Environment variable */
-    if (lpEnvironment != NULL)
-    {
-        unsigned i;
-        unsigned EnvironmentEntries = 0;
-        for (i = 0; ((char *)lpEnvironment)[i]!='\0'; i++)
-        {
-            EnvironmentEntries ++;
-            for (;((char *)lpEnvironment)[i]!='\0'; i++)
-            {
-            }
-        }
-        EnvironmentEntries++;
-        EnvironmentArray = (char **)InternalMalloc(EnvironmentEntries * sizeof(char *));
-        EnvironmentEntries = 0;
-        for (i = 0; ((char *)lpEnvironment)[i]!='\0'; i++)
-        {
-            EnvironmentArray[EnvironmentEntries] = &((char *)lpEnvironment)[i];
-            EnvironmentEntries ++;
-            for (;((char *)lpEnvironment)[i]!='\0'; i++)
-            {
-            }
-        }
-        EnvironmentArray[EnvironmentEntries] = NULL;
-    }
-    palError = g_pObjectManager->AllocateObject(
-        pThread,
-        &otProcess,
-        &oa,
-        &pobjProcess
-        );
-    if (NO_ERROR != palError)
-    {
-        ERROR("Unable to allocate object for new process\n");
-        goto InternalCreateProcessExit;
-    }
-    palError = g_pObjectManager->RegisterObject(
-        pThread,
-        pobjProcess,
-        &aotProcess,
-        &hProcess,
-        &pobjProcessRegistered
-        );
-    pobjProcess = NULL;
-    if (NO_ERROR != palError)
-    {
-        ERROR("Unable to register new process object\n");
-        goto InternalCreateProcessExit;
-    }
-    palError = InternalCreateDummyThread(
-        pThread,
-        lpThreadAttributes,
-        &pDummyThread,
-        &hDummyThread
-        );
-    if (dwCreationFlags & CREATE_SUSPENDED)
-    {
-        int pipe_descs[2];
-        if (-1 == pipe(pipe_descs))
-        {
-            ERROR("pipe() failed! error is %d (%s)\n", errno, strerror(errno));
-            palError = ERROR_NOT_ENOUGH_MEMORY;
-            goto InternalCreateProcessExit;
-        }
-        /* [0] is read end, [1] is write end */
-        pDummyThread->suspensionInfo.SetBlockingPipe(pipe_descs[1]);
-        parent_blocking_pipe = pipe_descs[1];
-        child_blocking_pipe = pipe_descs[0];
-    }
-    palError = pobjProcessRegistered->GetProcessLocalData(
-        pThread,
-        WriteLock,
-        &pLocalDataLock,
-        reinterpret_cast<void **>(&pLocalData)
-        );
-    if (NO_ERROR != palError)
-    {
-        ASSERT("Unable to obtain local data for new process object\n");
-        goto InternalCreateProcessExit;
-    }
-    /* fork the new process */
-    processId = fork();
-    if (processId == -1)
-    {
-        ASSERT("Unable to create a new process with fork()\n");
-        if (-1 != child_blocking_pipe)
-        {
-            close(child_blocking_pipe);
-            close(parent_blocking_pipe);
-        }
-        palError = ERROR_INTERNAL_ERROR;
-        goto InternalCreateProcessExit;
-    }
-    /* From the time the child process begins running, to when it reaches execve,
-    the child process is not a real PAL process and does not own any PAL
-    resources, although it has access to the PAL resources of its parent process.
-    Thus, while the child process is in this window, it is dangerous for it to affect
-    its parent's PAL resources. As a consequence, no PAL code should be used
-    in this window; all code should make unix calls. Note the use of _exit
-    instead of exit to avoid calling PAL_Terminate and the lack of TRACE's and
-    ASSERT's. */
-    if (processId == 0)  /* child process */
-    {
-        init_count = 0;
-        sigset_t sm;
-        sigemptyset(&sm);
-        iRet = sigprocmask(SIG_SETMASK, &sm, NULL);
-        if (iRet != 0)
-        {
-            _exit(EXIT_FAILURE);
-        }
-        if (dwCreationFlags & CREATE_SUSPENDED)
-        {
-            BYTE resume_code = 0;
-            ssize_t read_ret;
-            /* close the write end of the pipe, the child doesn't need it */
-            close(parent_blocking_pipe);
-            read_again:
-            /* block until ResumeThread writes something to the pipe */
-            read_ret = read(child_blocking_pipe, &resume_code, sizeof(resume_code));
-            if (sizeof(resume_code) != read_ret)
-            {
-                if (read_ret == -1 && EINTR == errno)
-                {
-                    goto read_again;
-                }
-                else
-                {
-                    /* note : read might return 0 (and return EAGAIN) if the other
-                       end of the pipe gets closed - for example because the parent
-                       process dies (very) abruptly */
-                    _exit(EXIT_FAILURE);
-                }
-            }
-            if (WAKEUPCODE != resume_code)
-            {
-                _exit(EXIT_FAILURE);
-            }
-            close(child_blocking_pipe);
-        }
-        /* Set the current directory */
-        if (lpCurrentDirectory)
-        {
-            SetCurrentDirectoryW(lpCurrentDirectory);
-        }
-        /* Set the standard handles to the incoming values */
-        if (lpStartupInfo->dwFlags & STARTF_USESTDHANDLES)
-        {
-            /* For each handle, we need to duplicate the incoming unix
-               fd to the corresponding standard one.  The API that I use,
-               dup2, will copy the source to the destination, automatically
-               closing the existing destination, in an atomic way */
-            if (dup2(iFdIn, STDIN_FILENO) == -1)
-            {
-                _exit(EXIT_FAILURE);
-            }
-            if (dup2(iFdOut, STDOUT_FILENO) == -1)
-            {
-                _exit(EXIT_FAILURE);
-            }
-            if (dup2(iFdErr, STDERR_FILENO) == -1)
-            {
-                _exit(EXIT_FAILURE);
-            }
-            /* now close the original FDs, we don't need them anymore */
-            close(iFdIn);
-            close(iFdOut);
-            close(iFdErr);
-        }
-        /* execute the new process */
-        if (EnvironmentArray)
-        {
-            execve(lpFileNamePS, lppArgv, EnvironmentArray);
-        }
-        else
-        {
-            execve(lpFileNamePS, lppArgv, palEnvironment);
-        }
-        /* if we get here, it means the execve function call failed so just exit */
-        _exit(EXIT_FAILURE);
-    }
-    /* parent process */
-    /* close the read end of the pipe, the parent doesn't need it */
-    close(child_blocking_pipe);
-    /* Set the process ID */
-    pLocalData->dwProcessId = processId;
-    pLocalDataLock->ReleaseLock(pThread, TRUE);
-    pLocalDataLock = NULL;
-    if (lpStartupInfo->dwFlags & STARTF_USESTDHANDLES)
-    {
-        pobjFileIn->ReleaseReference(pThread);
-        pobjFileIn = NULL;
-        pobjFileOut->ReleaseReference(pThread);
-        pobjFileOut = NULL;
-        pobjFileErr->ReleaseReference(pThread);
-        pobjFileErr = NULL;
-    }
-    /* fill PROCESS_INFORMATION structure */
-    lpProcessInformation->hProcess = hProcess;
-    lpProcessInformation->hThread = hDummyThread;
-    lpProcessInformation->dwProcessId = processId;
-    lpProcessInformation->dwThreadId_PAL_Undefined = 0;
-    TRACE("New process created: id=%#x\n", processId);
-InternalCreateProcessExit:
-    if (NULL != pLocalDataLock)
-    {
-        pLocalDataLock->ReleaseLock(pThread, FALSE);
-    }
-    if (NULL != pSharedDataLock)
-    {
-        pSharedDataLock->ReleaseLock(pThread, FALSE);
-    }
-    if (NULL != pobjProcess)
-    {
-        pobjProcess->ReleaseReference(pThread);
-    }
-    if (NULL != pobjProcessRegistered)
-    {
-        pobjProcessRegistered->ReleaseReference(pThread);
-    }
-    if (NO_ERROR != palError)
-    {
-        if (NULL != hProcess)
-        {
-            g_pObjectManager->RevokeHandle(pThread, hProcess);
-        }
-        if (NULL != hDummyThread)
-        {
-            g_pObjectManager->RevokeHandle(pThread, hDummyThread);
-        }
-    }
-    if (EnvironmentArray)
-    {
-        free(EnvironmentArray);
-    }
-    /* if we still have the file structures at this point, it means we
-       encountered an error sometime between when we acquired them and when we
-       fork()ed. We not only have to release them, we have to give them back
-       their close-on-exec flag */
-    if (NULL != pobjFileIn)
-    {
-        if(-1 == fcntl(iFdIn, F_SETFD, 1))
-        {
-            WARN("couldn't restore close-on-exec flag to stdin descriptor! "
-                 "errno is %d (%s)\n", errno, strerror(errno));
-        }
-        pobjFileIn->ReleaseReference(pThread);
-    }
-    if (NULL != pobjFileOut)
-    {
-        if(-1 == fcntl(iFdOut, F_SETFD, 1))
-        {
-            WARN("couldn't restore close-on-exec flag to stdout descriptor! "
-                 "errno is %d (%s)\n", errno, strerror(errno));
-        }
-        pobjFileOut->ReleaseReference(pThread);
-    }
-    if (NULL != pobjFileErr)
-    {
-        if(-1 == fcntl(iFdErr, F_SETFD, 1))
-        {
-            WARN("couldn't restore close-on-exec flag to stderr descriptor! "
-                 "errno is %d (%s)\n", errno, strerror(errno));
-        }
-        pobjFileErr->ReleaseReference(pThread);
-    }
-    /* free allocated memory */
-    if (lppArgv)
-    {
-        free(*lppArgv);
-        free(lppArgv);
-    }
-    return palError;
-}
-/*++
-Function:
-  GetExitCodeProcess
-See MSDN doc.
---*/
-BOOL
-PALAPI
-GetExitCodeProcess(
-    IN HANDLE hProcess,
-    IN LPDWORD lpExitCode)
-{
-    CPalThread *pThread;
-    PAL_ERROR palError = NO_ERROR;
-    DWORD dwExitCode;
-    PROCESS_STATE ps;
-    PERF_ENTRY(GetExitCodeProcess);
-    ENTRY("GetExitCodeProcess(hProcess = %p, lpExitCode = %p)\n",
-          hProcess, lpExitCode);
-    pThread = InternalGetCurrentThread();
-    if(NULL == lpExitCode)
-    {
-        WARN("Got NULL lpExitCode\n");
-        palError = ERROR_INVALID_PARAMETER;
-        goto done;
-    }
-    palError = PROCGetProcessStatus(
-        pThread,
-        hProcess,
-        &ps,
-        &dwExitCode
-        );
-    if (NO_ERROR != palError)
-    {
-        ASSERT("Couldn't get process status information!\n");
-        goto done;
-    }
-    if( PS_DONE == ps )
-    {
-        *lpExitCode = dwExitCode;
-    }
-    else
-    {
-        *lpExitCode = STILL_ACTIVE;
-    }
-done:
-    if (NO_ERROR != palError)
-    {
-        pThread->SetLastError(palError);
-    }
-    LOGEXIT("GetExitCodeProcess returns BOOL %d\n", NO_ERROR == palError);
-    PERF_EXIT(GetExitCodeProcess);
-    return NO_ERROR == palError;
-}
-/*++
-Function:
-  ExitProcess
-See MSDN doc.
---*/
-PAL_NORETURN
-VOID
-PALAPI
-ExitProcess(
-    IN UINT uExitCode)
-{
-    DWORD old_terminator;
-    PERF_ENTRY_ONLY(ExitProcess);
-    ENTRY("ExitProcess(uExitCode=0x%x)\n", uExitCode );
-    old_terminator = InterlockedCompareExchange(&terminator, GetCurrentThreadId(), 0);
-    if (GetCurrentThreadId() == old_terminator)
-    {
-        if (!PALIsInitialized())
-        {
-            exit(uExitCode);
-            ASSERT("exit has returned\n");
-        }
-        else
-        {
-            WARN("thread re-called ExitProcess\n");
-            PROCEndProcess(GetCurrentProcess(), uExitCode, FALSE);
-        }
-    }
-    else if (0 != old_terminator)
-    {
-        /* another thread has already initiated the termination process. we
-           could just block on the PALInitLock critical section, but then
-           PROCSuspendOtherThreads would hang... so sleep forever here, we're
-           terminating anyway
-           Update: [TODO] PROCSuspendOtherThreads has been removed. Can this
-           code be changed? */
-        WARN("termination already started from another thread; blocking.\n");
-        poll(NULL, 0, INFTIM);
-    }
-    /* ExitProcess may be called even if PAL is not initialized.
-       Verify if process structure exist
-    */
-    if (PALInitLock() && PALIsInitialized())
-    {
-        PROCEndProcess(GetCurrentProcess(), uExitCode, FALSE);
-        /* Should not get here, because we terminate the current process */
-        ASSERT("PROCEndProcess has returned\n");
-    }
-    else
-    {
-        exit(uExitCode);
-        /* Should not get here, because we terminate the current process */
-        ASSERT("exit has returned\n");
-    }
-    /* this should never get executed */
-    ASSERT("ExitProcess should not return!\n");
-    while (true);
-}
-/*++
-Function:
-  TerminateProcess
-Note:
-  hProcess is a handle on the current process.
-See MSDN doc.
---*/
-BOOL
-PALAPI
-TerminateProcess(
-    IN HANDLE hProcess,
-    IN UINT uExitCode)
-{
-    BOOL ret;
-    PERF_ENTRY(TerminateProcess);
-    ENTRY("TerminateProcess(hProcess=%p, uExitCode=%u)\n",hProcess, uExitCode );
-    ret = PROCEndProcess(hProcess, uExitCode, TRUE);
-    LOGEXIT("TerminateProcess returns BOOL %d\n", ret);
-    PERF_EXIT(TerminateProcess);
-    return ret;
-}
-/*++
-Function:
-  RaiseFailFastException
-See MSDN doc.
---*/
-VOID
-PALAPI
-DECLSPEC_NORETURN
-RaiseFailFastException(
-    IN PEXCEPTION_RECORD pExceptionRecord,
-    IN PCONTEXT pContextRecord,
-    IN DWORD dwFlags)
-{
-    PERF_ENTRY(RaiseFailFastException);
-    ENTRY("RaiseFailFastException");
-    TerminateCurrentProcessNoExit(TRUE);
-    PROCAbort();
-    LOGEXIT("RaiseFailFastException");
-    PERF_EXIT(RaiseFailFastException);
-}
-/*++
-Function:
-  PROCEndProcess
-  Called from TerminateProcess and ExitProcess. This does the work of
-  TerminateProcess, but also takes a flag that determines whether we
-  shut down unconditionally. If the flag is set, the PAL will do very
-  little extra work before exiting. Most importantly, it won't shut
-  down any DLLs that are loaded.
---*/
-static BOOL PROCEndProcess(HANDLE hProcess, UINT uExitCode, BOOL bTerminateUnconditionally)
-{
-    DWORD dwProcessId;
-    BOOL ret = FALSE;
-    dwProcessId = PROCGetProcessIDFromHandle(hProcess);
-    if (dwProcessId == 0)
-    {
-        SetLastError(ERROR_INVALID_HANDLE);
-    }
-    else if(dwProcessId != GetCurrentProcessId())
-    {
-        if (uExitCode != 0)
-            WARN("exit code 0x%x ignored for external process.\n", uExitCode);
-        if (kill(dwProcessId, SIGKILL) == 0)
-        {
-            ret = TRUE;
-        }
-        else
-        {
-            switch (errno) {
-            case ESRCH:
-                SetLastError(ERROR_INVALID_HANDLE);
-                break;
-            case EPERM:
-                SetLastError(ERROR_ACCESS_DENIED);
-                break;
-            default:
-                ASSERT(FALSE);
-                SetLastError(ERROR_INTERNAL_ERROR);
-                break;
-            }
-        }
-    }
-    else
-    {
-        if (bTerminateUnconditionally)
-        {
-            WARN("exit code 0x%x ignored for terminate.\n", uExitCode);
-        }
-        else if ((uExitCode & 0xff) != uExitCode)
-        {
-            ERROR("exit() only supports the lower 8-bits of an exit code. "
-                "status will only see error 0x%x instead of 0x%x.\n", uExitCode & 0xff, uExitCode);
-        }
-        TerminateCurrentProcessNoExit(bTerminateUnconditionally);
-        LOGEXIT("PROCEndProcess will not return\n");
-        if (bTerminateUnconditionally)
-        {
-            PROCAbort(uExitCode == (128 + SIGTERM) ? SIGTERM : SIGABRT);
-        }
-        else
-        {
-            exit(uExitCode);
-        }
-        ASSERT(FALSE); // we shouldn't get here
-    }
-    return ret;
-}
-/*++
-Function:
-  PAL_SetShutdownCallback
-Abstract:
-  Sets a callback that is executed when the PAL is shut down because of
-  ExitProcess, TerminateProcess or PAL_Shutdown but not PAL_Terminate/Ex.
-  NOTE: Currently only one callback can be set at a time.
---*/
-PALIMPORT
-VOID
-PALAPI
-PAL_SetShutdownCallback(
-    IN PSHUTDOWN_CALLBACK callback)
-{
-    _ASSERTE(g_shutdownCallback == nullptr);
-    g_shutdownCallback = callback;
-}
-#if defined(__NetBSD__)
-static const char* RuntimeSemaphoreNameFormat = "/clr%s%08llx";
-#else
-static const char* RuntimeSemaphoreNameFormat = "/clr%s%08x%016llx";
-#endif
-static const char* RuntimeStartupSemaphoreName = "st";
-static const char* RuntimeContinueSemaphoreName = "co";
-#if defined(__NetBSD__)
-static uint64_t HashSemaphoreName(uint64_t a, uint64_t b)
-{
-    return (a ^ b) & 0xffffffff;
-}
-#else
-#define HashSemaphoreName(a,b) a,b
-#endif
-static const char *const TwoWayNamedPipePrefix = "clr-debug-pipe";
-static const char* IpcNameFormat = "%s-%d-%llu-%s";
-/*++
-    PAL_NotifyRuntimeStarted
-    Signals the debugger waiting for runtime startup notification to continue and
-    waits until the debugger signals us to continue.
-Parameters:
-    None
-Return value:
-    TRUE - successfully launched by debugger, FALSE - not launched or some failure in the handshake
---*/
-BOOL
-PALAPI
-PAL_NotifyRuntimeStarted()
-{
-    char startupSemName[CLR_SEM_MAX_NAMELEN];
-    char continueSemName[CLR_SEM_MAX_NAMELEN];
-    sem_t *startupSem = SEM_FAILED;
-    sem_t *continueSem = SEM_FAILED;
-    BOOL launched = FALSE;
-    UINT64 processIdDisambiguationKey = 0;
-    BOOL ret = GetProcessIdDisambiguationKey(gPID, &processIdDisambiguationKey);
-    _ASSERTE(ret == TRUE || processIdDisambiguationKey == 0);
-    UnambiguousProcessDescriptor unambiguousProcessDescriptor(gPID, processIdDisambiguationKey);
-    LPCSTR applicationGroupId = PAL_GetApplicationGroupId();
-    CreateSemaphoreName(startupSemName, RuntimeStartupSemaphoreName, unambiguousProcessDescriptor, applicationGroupId);
-    CreateSemaphoreName(continueSemName, RuntimeContinueSemaphoreName, unambiguousProcessDescriptor, applicationGroupId);
-    TRACE("PAL_NotifyRuntimeStarted opening continue '%s' startup '%s'\n", continueSemName, startupSemName);
-    startupSem = sem_open(startupSemName, 0);
-    if (startupSem == SEM_FAILED)
-    {
-        TRACE("sem_open(%s) failed: %d (%s)\n", startupSemName, errno, strerror(errno));
-        goto exit;
-    }
-    continueSem = sem_open(continueSemName, 0);
-    if (continueSem == SEM_FAILED)
-    {
-        ASSERT("sem_open(%s) failed: %d (%s)\n", continueSemName, errno, strerror(errno));
-        goto exit;
-    }
-    if (sem_post(startupSem) != 0)
-    {
-        ASSERT("sem_post(startupSem) failed: errno is %d (%s)\n", errno, strerror(errno));
-        goto exit;
-    }
-    while (sem_wait(continueSem) != 0)
-    {
-        if (EINTR == errno)
-        {
-            TRACE("sem_wait() failed with EINTR; re-waiting");
-            continue;
-        }
-        ASSERT("sem_wait(continueSem) failed: errno is %d (%s)\n", errno, strerror(errno));
-        goto exit;
-    }
-    launched = TRUE;
-exit:
-    if (startupSem != SEM_FAILED)
-    {
-        sem_close(startupSem);
-    }
-    if (continueSem != SEM_FAILED)
-    {
-        sem_close(continueSem);
-    }
-    return launched;
-}
-LPCSTR
-PALAPI
-PAL_GetApplicationGroupId()
-{
-#ifdef __APPLE__
-    return gApplicationGroupId;
-#else
-    return nullptr;
-#endif
-}
-#ifdef __APPLE__
-constexpr int GetExtraEncodedAreaSize(UINT rawByteCount)
-{
-    return (rawByteCount+6)/7;
-}
-const int SEMAPHORE_ENCODED_NAME_EXTRA_LENGTH = GetExtraEncodedAreaSize(sizeof(UnambiguousProcessDescriptor));
-const int SEMAPHORE_ENCODED_NAME_LENGTH =
-    sizeof(UnambiguousProcessDescriptor) + /* For process ID + disambiguationKey */
-    SEMAPHORE_ENCODED_NAME_EXTRA_LENGTH; /* For base 255 extra encoding space */
-static_assert_no_msg(MAX_APPLICATION_GROUP_ID_LENGTH
-    + 1 /* For / */
-    + 2 /* For ST/CO name prefix */
-    + SEMAPHORE_ENCODED_NAME_LENGTH /* For encoded name string */
-    + 1 /* For null terminator */
-    <= CLR_SEM_MAX_NAMELEN);
-void EncodeSemaphoreName(char *encodedSemName, const UnambiguousProcessDescriptor& unambiguousProcessDescriptor)
-{
-    const unsigned char *buffer = (const unsigned char *)&unambiguousProcessDescriptor;
-    char *extraEncodingBits = encodedSemName + sizeof(UnambiguousProcessDescriptor);
-    for (int i=0; i<SEMAPHORE_ENCODED_NAME_EXTRA_LENGTH; i++)
-    {
-        extraEncodingBits[i] = 0x80;
-    }
-    for (int i=0; i<sizeof(UnambiguousProcessDescriptor); i++)
-    {
-        unsigned char b = buffer[i];
-        encodedSemName[i] = b ? b : 1;
-        extraEncodingBits[i/7] |= (b ? 0 : 1) << (i%7);
-    }
-}
-#endif
-void CreateSemaphoreName(char semName[CLR_SEM_MAX_NAMELEN], LPCSTR semaphoreName, const UnambiguousProcessDescriptor& unambiguousProcessDescriptor, LPCSTR applicationGroupId)
-{
-    int length = 0;
-#ifdef __APPLE__
-    if (applicationGroupId != nullptr)
-    {
-        length = sprintf_s(semName, CLR_SEM_MAX_NAMELEN, "%s/%s", applicationGroupId, semaphoreName);
-        _ASSERTE(length > 0 && length < CLR_SEM_MAX_NAMELEN);
-        EncodeSemaphoreName(semName+length, unambiguousProcessDescriptor);
-        length += SEMAPHORE_ENCODED_NAME_LENGTH;
-        semName[length] = 0;
-    }
-    else
-#endif // __APPLE__
-    {
-        length = sprintf_s(
-            semName,
-            CLR_SEM_MAX_NAMELEN,
-            RuntimeSemaphoreNameFormat,
-            semaphoreName,
-            HashSemaphoreName(unambiguousProcessDescriptor.m_processId, unambiguousProcessDescriptor.m_disambiguationKey));
-    }
-    _ASSERTE(length > 0 && length < CLR_SEM_MAX_NAMELEN );
-}
-/*++
- Function:
-  GetProcessIdDisambiguationKey
-  Get a numeric value that can be used to disambiguate between processes with the same PID,
-  provided that one of them is still running. The numeric value can mean different things
-  on different platforms, so it should not be used for any other purpose. Under the hood,
-  it is implemented based on the creation time of the process.
---*/
-BOOL
-GetProcessIdDisambiguationKey(DWORD processId, UINT64 *disambiguationKey)
-{
-    if (disambiguationKey == nullptr)
-    {
-        _ASSERTE(!"disambiguationKey argument cannot be null!");
-        return FALSE;
-    }
-    *disambiguationKey = 0;
-#if defined(__APPLE__) || defined(__FreeBSD__)
-    struct kinfo_proc info = {};
-    size_t size = sizeof(info);
-    int mib[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PID, processId };
-    int ret = ::sysctl(mib, sizeof(mib)/sizeof(*mib), &info, &size, nullptr, 0);
-    if (ret == 0)
-    {
-#if defined(__APPLE__)
-        timeval procStartTime = info.kp_proc.p_starttime;
-#else // __FreeBSD__
-        timeval procStartTime = info.ki_start;
-#endif
-        long secondsSinceEpoch = procStartTime.tv_sec;
-        *disambiguationKey = secondsSinceEpoch;
-        return TRUE;
-    }
-    else
-    {
-        _ASSERTE(!"Failed to get start time of a process.");
-        return FALSE;
-    }
-#elif defined(__NetBSD__)
-    kvm_t *kd;
-    int cnt;
-    struct kinfo_proc2 *info;
-    kd = kvm_open(nullptr, nullptr, nullptr, KVM_NO_FILES, "kvm_open");
-    if (kd == nullptr)
-    {
-        _ASSERTE(!"Failed to get start time of a process.");
-        return FALSE;
-    }
-    info = kvm_getproc2(kd, KERN_PROC_PID, processId, sizeof(struct kinfo_proc2), &cnt);
-    if (info == nullptr || cnt < 1)
-    {
-        kvm_close(kd);
-        _ASSERTE(!"Failed to get start time of a process.");
-        return FALSE;
-    }
-    kvm_close(kd);
-    long secondsSinceEpoch = info->p_ustart_sec;
-    *disambiguationKey = secondsSinceEpoch;
-    return TRUE;
-#elif HAVE_PROCFS_STAT
-    char statFileName[64];
-    INDEBUG(int chars = )
-    snprintf(statFileName, sizeof(statFileName), "/proc/%d/stat", processId);
-    _ASSERTE(chars > 0 && chars <= (int)sizeof(statFileName));
-    FILE *statFile = fopen(statFileName, "r");
-    if (statFile == nullptr)
-    {
-        TRACE("GetProcessIdDisambiguationKey: fopen() FAILED");
-        SetLastError(ERROR_INVALID_HANDLE);
-        return FALSE;
-    }
-    char *line = nullptr;
-    size_t lineLen = 0;
-    if (getline(&line, &lineLen, statFile) == -1)
-    {
-        TRACE("GetProcessIdDisambiguationKey: getline() FAILED");
-        SetLastError(ERROR_INVALID_HANDLE);
-        return FALSE;
-    }
-    unsigned long long starttime;
-    char *scanStartPosition = strrchr(line, ')') + 2;
-    int sscanfRet = sscanf_s(scanStartPosition,
-        "%*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u %*u %*u %*d %*d %*d %*d %*d %*d %llu \n",
-         &starttime);
-    if (sscanfRet != 1)
-    {
-        _ASSERTE(!"Failed to parse stat file contents with sscanf_s.");
-        return FALSE;
-    }
-    free(line);
-    fclose(statFile);
-    *disambiguationKey = starttime;
-    return TRUE;
-#else
-    WARN("GetProcessIdDisambiguationKey was called but is not implemented on this platform!");
-    return FALSE;
-#endif
-}
-/*++
- Function:
-  PAL_GetTransportName
-  Builds the transport IPC names from the process id.
---*/
-VOID
-PALAPI
-PAL_GetTransportName(
-    const unsigned int MAX_TRANSPORT_NAME_LENGTH,
-    OUT char *name,
-    IN const char *prefix,
-    IN DWORD id,
-    IN const char *applicationGroupId,
-    IN const char *suffix)
-{
-    *name = '\0';
-    DWORD dwRetVal = 0;
-    UINT64 disambiguationKey = 0;
-    PathCharString formatBufferString;
-    BOOL ret = GetProcessIdDisambiguationKey(id, &disambiguationKey);
-    char *formatBuffer = formatBufferString.OpenStringBuffer(MAX_TRANSPORT_NAME_LENGTH-1);
-    if (formatBuffer == nullptr)
-    {
-        ERROR("Out Of Memory");
-        return;
-    }
-    _ASSERTE(ret == TRUE || disambiguationKey == 0);
-#ifdef __APPLE__
-    if (nullptr != applicationGroupId)
-    {
-        int applicationGroupIdLength = strlen(applicationGroupId);
-        if (applicationGroupIdLength > MAX_APPLICATION_GROUP_ID_LENGTH)
-        {
-            ERROR("The length of applicationGroupId is larger than MAX_APPLICATION_GROUP_ID_LENGTH");
-            return;
-        }
-        if (!GetApplicationContainerFolder(formatBufferString, applicationGroupId, applicationGroupIdLength))
-        {
-            ERROR("Out Of Memory");
-            return;
-        }
-        if (formatBufferString.GetCount() >= MAX_TRANSPORT_NAME_LENGTH)
-        {
-            ERROR("GetApplicationContainerFolder returned a path that was larger than MAX_TRANSPORT_NAME_LENGTH");
-            return;
-        }
-    }
-    else
-#endif // __APPLE__
-    {
-        dwRetVal = ::GetTempPathA(MAX_TRANSPORT_NAME_LENGTH, formatBuffer);
-        if (dwRetVal == 0)
-        {
-            ERROR("GetTempPath failed (0x%08x)", ::GetLastError());
-            return;
-        }
-        if (dwRetVal > MAX_TRANSPORT_NAME_LENGTH)
-        {
-            ERROR("GetTempPath returned a path that was larger than MAX_TRANSPORT_NAME_LENGTH");
-            return;
-        }
-    }
-    if (strncat_s(formatBuffer, MAX_TRANSPORT_NAME_LENGTH, IpcNameFormat, strlen(IpcNameFormat)) == STRUNCATE)
-    {
-        ERROR("TransportPipeName was larger than MAX_TRANSPORT_NAME_LENGTH");
-        return;
-    }
-    int chars = snprintf(name, MAX_TRANSPORT_NAME_LENGTH, formatBuffer, prefix, id, disambiguationKey, suffix);
-    _ASSERTE(chars > 0 && (unsigned int)chars < MAX_TRANSPORT_NAME_LENGTH);
-}
-/*++
- Function:
-  PAL_GetTransportPipeName
-  Builds the transport pipe names from the process id.
---*/
-VOID
-PALAPI
-PAL_GetTransportPipeName(
-    OUT char *name,
-    IN DWORD id,
-    IN const char *applicationGroupId,
-    IN const char *suffix)
-{
-    PAL_GetTransportName(
-        MAX_DEBUGGER_TRANSPORT_PIPE_NAME_LENGTH,
-        name,
-        TwoWayNamedPipePrefix,
-        id,
-        applicationGroupId,
-        suffix);
-}
-/*++
-Function:
-  GetProcessTimes
-See MSDN doc.
---*/
-BOOL
-PALAPI
-GetProcessTimes(
-        IN HANDLE hProcess,
-        OUT LPFILETIME lpCreationTime,
-        OUT LPFILETIME lpExitTime,
-        OUT LPFILETIME lpKernelTime,
-        OUT LPFILETIME lpUserTime)
-{
-    BOOL retval = FALSE;
-    struct rusage resUsage;
-    UINT64 calcTime;
-    const UINT64 SECS_TO_100NS = 10000000ULL;  // 10^7
-    const UINT64 USECS_TO_100NS = 10ULL;       // 10
-    const UINT64 EPOCH_DIFF = 11644473600ULL;  // number of seconds from 1 Jan. 1601 00:00 to 1 Jan 1970 00:00 UTC
-    PERF_ENTRY(GetProcessTimes);
-    ENTRY("GetProcessTimes(hProcess=%p, lpExitTime=%p, lpKernelTime=%p,"
-          "lpUserTime=%p)\n",
-          hProcess, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime );
-    /* Make sure hProcess is the current process, this is the only supported
-       case */
-    if(PROCGetProcessIDFromHandle(hProcess)!=GetCurrentProcessId())
-    {
-        ASSERT("GetProcessTimes() does not work on a process other than the "
-              "current process.\n");
-        SetLastError(ERROR_INVALID_HANDLE);
-        goto GetProcessTimesExit;
-    }
-    /* First, we need to actually retrieve the relevant statistics from the
-       OS */
-    if (getrusage (RUSAGE_SELF, &resUsage) == -1)
-    {
-        ASSERT("Unable to get resource usage information for the current "
-              "process\n");
-        SetLastError(ERROR_INTERNAL_ERROR);
-        goto GetProcessTimesExit;
-    }
-    TRACE ("getrusage User: %ld sec,%ld microsec. Kernel: %ld sec,%ld"
-           " microsec\n",
-           resUsage.ru_utime.tv_sec, resUsage.ru_utime.tv_usec,
-           resUsage.ru_stime.tv_sec, resUsage.ru_stime.tv_usec);
-    if (lpCreationTime)
-    {
-        struct timeval tv;
-        if (gettimeofday(&tv, NULL) == -1)
-        {
-            ASSERT("gettimeofday() failed; errno is %d (%s)\n", errno, strerror(errno));
-            lpCreationTime->dwLowDateTime = 0;
-            lpCreationTime->dwHighDateTime = 0;
-        }
-        else
-        {
-            calcTime = EPOCH_DIFF;
-            calcTime += (UINT64)tv.tv_sec;
-            calcTime *= SECS_TO_100NS;
-            calcTime += ((UINT64)tv.tv_usec * USECS_TO_100NS);
-            lpCreationTime->dwLowDateTime = (DWORD)calcTime;
-            lpCreationTime->dwHighDateTime = (DWORD)(calcTime >> 32);
-        }
-    }
-    if (lpExitTime)
-    {
-        lpExitTime->dwLowDateTime = 0;
-        lpExitTime->dwHighDateTime = 0;
-    }
-    if (lpUserTime)
-    {
-        /* Get the time of user mode execution, in 100s of nanoseconds */
-        calcTime = (UINT64)resUsage.ru_utime.tv_sec * SECS_TO_100NS;
-        calcTime += (UINT64)resUsage.ru_utime.tv_usec * USECS_TO_100NS;
-        /* Assign the time into lpUserTime */
-        lpUserTime->dwLowDateTime = (DWORD)calcTime;
-        lpUserTime->dwHighDateTime = (DWORD)(calcTime >> 32);
-    }
-    if (lpKernelTime)
-    {
-        /* Get the time of kernel mode execution, in 100s of nanoseconds */
-        calcTime = (UINT64)resUsage.ru_stime.tv_sec * SECS_TO_100NS;
-        calcTime += (UINT64)resUsage.ru_stime.tv_usec * USECS_TO_100NS;
-        /* Assign the time into lpUserTime */
-        lpKernelTime->dwLowDateTime = (DWORD)calcTime;
-        lpKernelTime->dwHighDateTime = (DWORD)(calcTime >> 32);
-    }
-    retval = TRUE;
-GetProcessTimesExit:
-    LOGEXIT("GetProcessTimes returns BOOL %d\n", retval);
-    PERF_EXIT(GetProcessTimes);
-    return (retval);
-}
-#define FILETIME_TO_ULONGLONG(f) \
-    (((ULONGLONG)(f).dwHighDateTime << 32) | ((ULONGLONG)(f).dwLowDateTime))
-/*++
-Function:
-  PAL_GetCPUBusyTime
-The main purpose of this function is to compute the overall CPU utilization
-for the CLR thread pool to regulate the number of I/O completion port
-worker threads.
-Since there is no consistent API on Unix to get the CPU utilization
-from a user process, getrusage and gettimeofday are used to
-compute the current process's CPU utilization instead.
-This function emulates the ThreadpoolMgr::GetCPUBusyTime_NT function in
-win32threadpool.cpp of the CLR.
-See MSDN doc for GetSystemTimes.
---*/
-INT
-PALAPI
-PAL_GetCPUBusyTime(
-    IN OUT PAL_IOCP_CPU_INFORMATION *lpPrevCPUInfo)
-{
-    ULONGLONG nLastRecordedCurrentTime = 0;
-    ULONGLONG nLastRecordedUserTime = 0;
-    ULONGLONG nLastRecordedKernelTime = 0;
-    ULONGLONG nKernelTime = 0;
-    ULONGLONG nUserTime = 0;
-    ULONGLONG nCurrentTime = 0;
-    ULONGLONG nCpuBusyTime = 0;
-    ULONGLONG nCpuTotalTime = 0;
-    DWORD nReading = 0;
-    struct rusage resUsage;
-    struct timeval tv;
-    static DWORD dwNumberOfProcessors = 0;
-    if (dwNumberOfProcessors <= 0)
-    {
-        SYSTEM_INFO SystemInfo;
-        GetSystemInfo(&SystemInfo);
-        dwNumberOfProcessors = SystemInfo.dwNumberOfProcessors;
-        if (dwNumberOfProcessors <= 0)
-        {
-            return 0;
-        }
-        UINT cpuLimit;
-        if (PAL_GetCpuLimit(&cpuLimit) && cpuLimit < dwNumberOfProcessors)
-        {
-            dwNumberOfProcessors = cpuLimit;
-        }
-    }
-    if (getrusage(RUSAGE_SELF, &resUsage) == -1)
-    {
-        ASSERT("getrusage() failed; errno is %d (%s)\n", errno, strerror(errno));
-        return 0;
-    }
-    else
-    {
-        nKernelTime = (ULONGLONG)resUsage.ru_stime.tv_sec*tccSecondsTo100NanoSeconds +
-            resUsage.ru_stime.tv_usec*tccMicroSecondsTo100NanoSeconds;
-        nUserTime = (ULONGLONG)resUsage.ru_utime.tv_sec*tccSecondsTo100NanoSeconds +
-            resUsage.ru_utime.tv_usec*tccMicroSecondsTo100NanoSeconds;
-    }
-    if (gettimeofday(&tv, NULL) == -1)
-    {
-        ASSERT("gettimeofday() failed; errno is %d (%s)\n", errno, strerror(errno));
-        return 0;
-    }
-    else
-    {
-        nCurrentTime = (ULONGLONG)tv.tv_sec*tccSecondsTo100NanoSeconds +
-            tv.tv_usec*tccMicroSecondsTo100NanoSeconds;
-    }
-    nLastRecordedCurrentTime = FILETIME_TO_ULONGLONG(lpPrevCPUInfo->LastRecordedTime.ftLastRecordedCurrentTime);
-    nLastRecordedUserTime = FILETIME_TO_ULONGLONG(lpPrevCPUInfo->ftLastRecordedUserTime);
-    nLastRecordedKernelTime = FILETIME_TO_ULONGLONG(lpPrevCPUInfo->ftLastRecordedKernelTime);
-    if (nCurrentTime > nLastRecordedCurrentTime)
-    {
-        nCpuTotalTime = (nCurrentTime - nLastRecordedCurrentTime);
-#if HAVE_THREAD_SELF || HAVE__LWP_SELF || HAVE_VM_READ
-        nCpuTotalTime *= dwNumberOfProcessors;
-#endif // HAVE_THREAD_SELF || HAVE__LWP_SELF || HAVE_VM_READ
-    }
-    if (nUserTime >= nLastRecordedUserTime &&
-        nKernelTime >= nLastRecordedKernelTime)
-    {
-        nCpuBusyTime =
-            (nUserTime - nLastRecordedUserTime)+
-            (nKernelTime - nLastRecordedKernelTime);
-    }
-    if (nCpuTotalTime > 0 && nCpuBusyTime > 0)
-    {
-        nReading = (DWORD)((nCpuBusyTime*100)/nCpuTotalTime);
-        TRACE("PAL_GetCPUBusyTime: nCurrentTime=%lld, nKernelTime=%lld, nUserTime=%lld, nReading=%d\n",
-            nCurrentTime, nKernelTime, nUserTime, nReading);
-    }
-    if (nReading > 100)
-    {
-        ERROR("cpu utilization(%d) > 100\n", nReading);
-    }
-    lpPrevCPUInfo->LastRecordedTime.ftLastRecordedCurrentTime.dwLowDateTime = (DWORD)nCurrentTime;
-    lpPrevCPUInfo->LastRecordedTime.ftLastRecordedCurrentTime.dwHighDateTime = (DWORD)(nCurrentTime >> 32);
-    lpPrevCPUInfo->ftLastRecordedUserTime.dwLowDateTime = (DWORD)nUserTime;
-    lpPrevCPUInfo->ftLastRecordedUserTime.dwHighDateTime = (DWORD)(nUserTime >> 32);
-    lpPrevCPUInfo->ftLastRecordedKernelTime.dwLowDateTime = (DWORD)nKernelTime;
-    lpPrevCPUInfo->ftLastRecordedKernelTime.dwHighDateTime = (DWORD)(nKernelTime >> 32);
-    return (DWORD)nReading;
-}
-/*++
-Function:
-  GetCommandLineW
-See MSDN doc.
---*/
-LPWSTR
-PALAPI
-GetCommandLineW(
-    VOID)
-{
-    PERF_ENTRY(GetCommandLineW);
-    ENTRY("GetCommandLineW()\n");
-    LPWSTR lpwstr = g_lpwstrCmdLine ? g_lpwstrCmdLine : (LPWSTR)W("");
-    LOGEXIT("GetCommandLineW returns LPWSTR %p (%S)\n",
-          g_lpwstrCmdLine,
-          lpwstr);
-    PERF_EXIT(GetCommandLineW);
-    return lpwstr;
-}
-/*++
-Function:
-  OpenProcess
-See MSDN doc.
-Notes :
-dwDesiredAccess is ignored (all supported operations will be allowed)
-bInheritHandle is ignored (no inheritance)
---*/
-HANDLE
-PALAPI
-OpenProcess(
-        DWORD dwDesiredAccess,
-        BOOL bInheritHandle,
-        DWORD dwProcessId)
-{
-    PAL_ERROR palError;
-    CPalThread *pThread;
-    IPalObject *pobjProcess = NULL;
-    IPalObject *pobjProcessRegistered = NULL;
-    IDataLock *pDataLock;
-    CProcProcessLocalData *pLocalData;
-    CObjectAttributes oa;
-    HANDLE hProcess = NULL;
-    PERF_ENTRY(OpenProcess);
-    ENTRY("OpenProcess(dwDesiredAccess=0x%08x, bInheritHandle=%d, "
-          "dwProcessId = 0x%08x)\n",
-          dwDesiredAccess, bInheritHandle, dwProcessId );
-    pThread = InternalGetCurrentThread();
-    if (0 == dwProcessId)
-    {
-        palError = ERROR_INVALID_PARAMETER;
-        goto OpenProcessExit;
-    }
-    palError = g_pObjectManager->AllocateObject(
-        pThread,
-        &otProcess,
-        &oa,
-        &pobjProcess
-        );
-    if (NO_ERROR != palError)
-    {
-        goto OpenProcessExit;
-    }
-    palError = pobjProcess->GetProcessLocalData(
-        pThread,
-        WriteLock,
-        &pDataLock,
-        reinterpret_cast<void **>(&pLocalData)
-        );
-    if (NO_ERROR != palError)
-    {
-        goto OpenProcessExit;
-    }
-    pLocalData->dwProcessId = dwProcessId;
-    pDataLock->ReleaseLock(pThread, TRUE);
-    palError = g_pObjectManager->RegisterObject(
-        pThread,
-        pobjProcess,
-        &aotProcess,
-        &hProcess,
-        &pobjProcessRegistered
-        );
-    pobjProcess = NULL;
-OpenProcessExit:
-    if (NULL != pobjProcess)
-    {
-        pobjProcess->ReleaseReference(pThread);
-    }
-    if (NULL != pobjProcessRegistered)
-    {
-        pobjProcessRegistered->ReleaseReference(pThread);
-    }
-    if (NO_ERROR != palError)
-    {
-        pThread->SetLastError(palError);
-    }
-    LOGEXIT("OpenProcess returns HANDLE %p\n", hProcess);
-    PERF_EXIT(OpenProcess);
-    return hProcess;
-}
-/*++
-Function
-  PROCNotifyProcessShutdown
-  Calls the abort handler to do any shutdown cleanup. Call be called
-  from the unhandled native exception handler.
-(no return value)
---*/
-VOID
-PROCNotifyProcessShutdown(bool isExecutingOnAltStack)
-{
-    PSHUTDOWN_CALLBACK callback = InterlockedExchangePointer(&g_shutdownCallback, NULL);
-    if (callback != NULL)
-    {
-        callback(isExecutingOnAltStack);
-    }
-}
-/*++
-Function
-  PROCNotifyProcessShutdownDestructor
-  Called at process exit, invokes process shutdown notification
-(no return value)
---*/
-__attribute__((destructor))
-VOID
-PROCNotifyProcessShutdownDestructor()
-{
-    PROCNotifyProcessShutdown(/* isExecutingOnAltStack */ false);
-}
-/*++
-Function:
-    PROCFormatInt
-    Helper function to format an ULONG32 as a string.
---*/
-char*
-PROCFormatInt(ULONG32 value)
-{
-    char* buffer = (char*)InternalMalloc(128);
-    if (buffer != nullptr)
-    {
-        if (sprintf_s(buffer, 128, "%d", value) == -1)
-        {
-            free(buffer);
-            buffer = nullptr;
-        }
-    }
-    return buffer;
-}
-/*++
-Function:
-    PROCFormatInt64
-    Helper function to format an ULONG64 as a string.
---*/
-char*
-PROCFormatInt64(ULONG64 value)
-{
-    char* buffer = (char*)InternalMalloc(128);
-    if (buffer != nullptr)
-    {
-        if (sprintf_s(buffer, 128, "%lld", value) == -1)
-        {
-            free(buffer);
-            buffer = nullptr;
-        }
-    }
-    return buffer;
-}
-static const INT UndefinedDumpType = 0;
-/*++
-Function
-  PROCBuildCreateDumpCommandLine
-Abstract
-  Builds the createdump command line from the arguments.
-Return
-  TRUE - succeeds, FALSE - fails
---*/
-BOOL
-PROCBuildCreateDumpCommandLine(
-    std::vector<const char*>& argv,
-    char** pprogram,
-    char** ppidarg,
-    const char* dumpName,
-    const char* logFileName,
-    INT dumpType,
-    ULONG32 flags)
-{
-    if (g_szCoreCLRPath == nullptr)
-    {
-        return FALSE;
-    }
-    const char* DumpGeneratorName = "createdump";
-    int programLen = strlen(g_szCoreCLRPath) + strlen(DumpGeneratorName) + 1;
-    char* program = *pprogram = (char*)InternalMalloc(programLen);
-    if (program == nullptr)
-    {
-        return FALSE;
-    }
-    if (strcpy_s(program, programLen, g_szCoreCLRPath) != SAFECRT_SUCCESS)
-    {
-        return FALSE;
-    }
-    char *last = strrchr(program, '/');
-    if (last != nullptr)
-    {
-        *(last + 1) = '\0';
-    }
-    else
-    {
-        program[0] = '\0';
-    }
-    if (strcat_s(program, programLen, DumpGeneratorName) != SAFECRT_SUCCESS)
-    {
-        return FALSE;
-    }
-    *ppidarg = PROCFormatInt(gPID);
-    if (*ppidarg == nullptr)
-    {
-        return FALSE;
-    }
-    argv.push_back(program);
-    if (dumpName != nullptr)
-    {
-        argv.push_back("--name");
-        argv.push_back(dumpName);
-    }
-    switch (dumpType)
-    {
-        case 1: argv.push_back("--normal");
-            break;
-        case 2: argv.push_back("--withheap");
-            break;
-        case 3: argv.push_back("--triage");
-            break;
-        case 4: argv.push_back("--full");
-            break;
-        case UndefinedDumpType:
-        default:
-            break;
-    }
-    if (flags & GenerateDumpFlagsLoggingEnabled)
-    {
-        argv.push_back("--diag");
-    }
-    if (flags & GenerateDumpFlagsVerboseLoggingEnabled)
-    {
-        argv.push_back("--verbose");
-    }
-    if (flags & GenerateDumpFlagsCrashReportEnabled)
-    {
-        argv.push_back("--crashreport");
-    }
-    if (flags & GenerateDumpFlagsCrashReportOnlyEnabled)
-    {
-        argv.push_back("--crashreportonly");
-    }
-    if (g_running_in_exe)
-    {
-        argv.push_back("--singlefile");
-    }
-    if (logFileName != nullptr)
-    {
-        argv.push_back("--logtofile");
-        argv.push_back(logFileName);
-    }
-    argv.push_back(*ppidarg);
-    argv.push_back(nullptr);
-    return TRUE;
-}
-/*++
-Function:
-  PROCCreateCrashDump
-  Creates crash dump of the process. Can be called from the
-  unhandled native exception handler.
-(no return value)
---*/
-BOOL
-PROCCreateCrashDump(
-    std::vector<const char*>& argv,
-    LPSTR errorMessageBuffer,
-    INT cbErrorMessageBuffer)
-{
-    _ASSERTE(argv.size() > 0);
-    _ASSERTE(errorMessageBuffer == nullptr || cbErrorMessageBuffer > 0);
-    int pipe_descs[2];
-    if (pipe(pipe_descs) == -1)
-    {
-        if (errorMessageBuffer != nullptr)
-        {
-            sprintf_s(errorMessageBuffer, cbErrorMessageBuffer, "Problem launching createdump: pipe() FAILED %s (%d)\n", strerror(errno), errno);
-        }
-        return false;
-    }
-    int parent_pipe = pipe_descs[0];
-    int child_pipe = pipe_descs[1];
-    pid_t childpid = fork();
-    if (childpid == -1)
-    {
-        if (errorMessageBuffer != nullptr)
-        {
-            sprintf_s(errorMessageBuffer, cbErrorMessageBuffer, "Problem launching createdump: fork() FAILED %s (%d)\n", strerror(errno), errno);
-        }
-        close(pipe_descs[0]);
-        close(pipe_descs[1]);
-        return false;
-    }
-    else if (childpid == 0)
-    {
-        close(parent_pipe);
-        if (errorMessageBuffer != nullptr)
-        {
-            dup2(child_pipe, STDERR_FILENO);
-        }
-        if (execve(argv[0], (char**)argv.data(), palEnvironment) == -1)
-        {
-            fprintf(stderr, "Problem launching createdump (may not have execute permissions): execve(%s) FAILED %s (%d)\n", argv[0], strerror(errno), errno);
-            exit(-1);
-        }
-    }
-    else
-    {
-#if HAVE_PRCTL_H && HAVE_PR_SET_PTRACER
-        if (prctl(PR_SET_PTRACER, childpid, 0, 0, 0) == -1)
-        {
-            ERROR("PROCCreateCrashDump: prctl() FAILED %s (%d)\n", strerror(errno), errno);
-        }
-#endif // HAVE_PRCTL_H && HAVE_PR_SET_PTRACER
-        close(child_pipe);
-        if (errorMessageBuffer != nullptr)
-        {
-            int bytesRead = 0;
-            int count = 0;
-            while ((count = read(parent_pipe, errorMessageBuffer + bytesRead, cbErrorMessageBuffer - bytesRead)) > 0)
-            {
-                bytesRead += count;
-            }
-            errorMessageBuffer[bytesRead] = 0;
-            if (bytesRead > 0)
-            {
-                fputs(errorMessageBuffer, stderr);
-            }
-        }
-        close(parent_pipe);
-        int wstatus = 0;
-        int result = waitpid(childpid, &wstatus, 0);
-        if (result != childpid)
-        {
-            fprintf(stderr, "Problem waiting for createdump: waitpid() FAILED result %d wstatus %08x errno %s (%d)\n",
-                result, wstatus, strerror(errno), errno);
-            return false;
-        }
-        else
-        {
-#ifdef _DEBUG
-            fprintf(stderr, "[createdump] waitpid() returned successfully (wstatus %08x)\n", wstatus);
-#endif
-            return !WIFEXITED(wstatus) || WEXITSTATUS(wstatus) == 0;
-        }
-    }
-    return true;
-}
-/*++
-Function
-  PROCAbortInitialize()
-Abstract
-  Initialize the process abort crash dump program file path and
-  name. Doing all of this ahead of time so nothing is allocated
-  or copied in PROCAbort/signal handler.
-Return
-  TRUE - succeeds, FALSE - fails
---*/
-BOOL
-PROCAbortInitialize()
-{
-    CLRConfigNoCache enabledCfg = CLRConfigNoCache::Get("DbgEnableMiniDump", /*noprefix*/ false, &getenv);
-    DWORD enabled = 0;
-    if (enabledCfg.IsSet() && enabledCfg.TryAsInteger(10, enabled) && enabled)
-    {
-        CLRConfigNoCache dmpNameCfg = CLRConfigNoCache::Get("DbgMiniDumpName", /*noprefix*/ false, &getenv);
-        const char* dumpName = dmpNameCfg.IsSet() ? dmpNameCfg.AsString() : nullptr;
-        CLRConfigNoCache dmpLogToFileCfg = CLRConfigNoCache::Get("CreateDumpLogToFile", /*noprefix*/ false, &getenv);
-        const char* logFilePath = dmpLogToFileCfg.IsSet() ? dmpLogToFileCfg.AsString() : nullptr;
-        CLRConfigNoCache dmpTypeCfg = CLRConfigNoCache::Get("DbgMiniDumpType", /*noprefix*/ false, &getenv);
-        DWORD dumpType = UndefinedDumpType;
-        if (dmpTypeCfg.IsSet())
-        {
-            (void)dmpTypeCfg.TryAsInteger(10, dumpType);
-            if (dumpType < 1 || dumpType > 4)
-            {
-                dumpType = UndefinedDumpType;
-            }
-        }
-        ULONG32 flags = GenerateDumpFlagsNone;
-        CLRConfigNoCache createDumpDiag = CLRConfigNoCache::Get("CreateDumpDiagnostics", /*noprefix*/ false, &getenv);
-        DWORD val = 0;
-        if (createDumpDiag.IsSet() && createDumpDiag.TryAsInteger(10, val) && val == 1)
-        {
-            flags |= GenerateDumpFlagsLoggingEnabled;
-        }
-        CLRConfigNoCache createDumpVerboseDiag = CLRConfigNoCache::Get("CreateDumpVerboseDiagnostics", /*noprefix*/ false, &getenv);
-        val = 0;
-        if (createDumpVerboseDiag.IsSet() && createDumpVerboseDiag.TryAsInteger(10, val) && val == 1)
-        {
-            flags |= GenerateDumpFlagsVerboseLoggingEnabled;
-        }
-        CLRConfigNoCache enabledReportCfg = CLRConfigNoCache::Get("EnableCrashReport", /*noprefix*/ false, &getenv);
-        val = 0;
-        if (enabledReportCfg.IsSet() && enabledReportCfg.TryAsInteger(10, val) && val == 1)
-        {
-            flags |= GenerateDumpFlagsCrashReportEnabled;
-        }
-        CLRConfigNoCache enabledReportOnlyCfg = CLRConfigNoCache::Get("EnableCrashReportOnly", /*noprefix*/ false, &getenv);
-        val = 0;
-        if (enabledReportOnlyCfg.IsSet() && enabledReportOnlyCfg.TryAsInteger(10, val) && val == 1)
-        {
-            flags |= GenerateDumpFlagsCrashReportOnlyEnabled;
-        }
-        char* program = nullptr;
-        char* pidarg = nullptr;
-        if (!PROCBuildCreateDumpCommandLine(g_argvCreateDump, &program, &pidarg, dumpName, logFilePath, dumpType, flags))
-        {
-            return FALSE;
-        }
-    }
-    return TRUE;
-}
-/*++
-Function:
-  PAL_GenerateCoreDump
-Abstract:
-  Public entry point to create a crash dump of the process.
-Parameters:
-    dumpName
-    dumpType:
-        Normal = 1,
-        WithHeap = 2,
-        Triage = 3,
-        Full = 4
-    flags
-        See enum
-Return:
-    TRUE success
-    FALSE failed
---*/
-BOOL
-PAL_GenerateCoreDump(
-    LPCSTR dumpName,
-    INT dumpType,
-    ULONG32 flags,
-    LPSTR errorMessageBuffer,
-    INT cbErrorMessageBuffer)
-{
-    std::vector<const char*> argvCreateDump;
-    if (dumpType < 1 || dumpType > 4)
-    {
-        return FALSE;
-    }
-    if (dumpName != nullptr && dumpName[0] == '\0')
-    {
-        dumpName = nullptr;
-    }
-    char* program = nullptr;
-    char* pidarg = nullptr;
-    BOOL result = PROCBuildCreateDumpCommandLine(argvCreateDump, &program, &pidarg, dumpName, nullptr, dumpType, flags);
-    if (result)
-    {
-        result = PROCCreateCrashDump(argvCreateDump, errorMessageBuffer, cbErrorMessageBuffer);
-    }
-    free(program);
-    free(pidarg);
-    return result;
-}
-/*++
-Function:
-  PROCCreateCrashDumpIfEnabled
-  Creates crash dump of the process (if enabled). Can be
-  called from the unhandled native exception handler.
-Parameters:
-  signal - POSIX signal number
-(no return value)
---*/
-VOID
-PROCCreateCrashDumpIfEnabled(int signal, siginfo_t* siginfo)
-{
-    if (!g_argvCreateDump.empty())
-    {
-        std::vector<const char*> argv(g_argvCreateDump);
-        char* signalArg = nullptr;
-        char* crashThreadArg = nullptr;
-        char* signalCodeArg = nullptr;
-        char* signalErrnoArg = nullptr;
-        char* signalAddressArg = nullptr;
-        if (signal != 0)
-        {
-            argv.pop_back();
-            signalArg = PROCFormatInt(signal);
-            if (signalArg != nullptr)
-            {
-                argv.push_back("--signal");
-                argv.push_back(signalArg);
-            }
-            crashThreadArg = PROCFormatInt(THREADSilentGetCurrentThreadId());
-            if (crashThreadArg != nullptr)
-            {
-                argv.push_back("--crashthread");
-                argv.push_back(crashThreadArg);
-            }
-            if (siginfo != nullptr)
-            {
-                signalCodeArg = PROCFormatInt(siginfo->si_code);
-                if (signalCodeArg != nullptr)
-                {
-                    argv.push_back("--code");
-                    argv.push_back(signalCodeArg);
-                }
-                signalErrnoArg = PROCFormatInt(siginfo->si_errno);
-                if (signalErrnoArg != nullptr)
-                {
-                    argv.push_back("--errno");
-                    argv.push_back(signalErrnoArg);
-                }
-                signalAddressArg = PROCFormatInt64((ULONG64)siginfo->si_addr);
-                if (signalAddressArg != nullptr)
-                {
-                    argv.push_back("--address");
-                    argv.push_back(signalAddressArg);
-                }
-            }
-            argv.push_back(nullptr);
-        }
-        PROCCreateCrashDump(argv, nullptr, 0);
-        free(signalArg);
-        free(crashThreadArg);
-        free(signalCodeArg);
-        free(signalErrnoArg);
-        free(signalAddressArg);
-    }
-}
-/*++
-Function:
-  PROCAbort()
-  Aborts the process after calling the shutdown cleanup handler. This function
-  should be called instead of calling abort() directly.
-Parameters:
-  signal - POSIX signal number
-  Does not return
---*/
-PAL_NORETURN
-VOID
-PROCAbort(int signal, siginfo_t* siginfo)
-{
-    PROCNotifyProcessShutdown();
-    PROCCreateCrashDumpIfEnabled(signal, siginfo);
-    SEHCleanupSignals();
-    abort();
-}
-/*++
-Function:
-  InitializeFlushProcessWriteBuffers
-Abstract
-  This function initializes data structures needed for the FlushProcessWriteBuffers
-Return
-  TRUE if it succeeded, FALSE otherwise
---*/
-BOOL
-InitializeFlushProcessWriteBuffers()
-{
-    _ASSERTE(s_helperPage == 0);
-    _ASSERTE(s_flushUsingMemBarrier == 0);
-    int mask = membarrier(MEMBARRIER_CMD_QUERY, 0);
-    if (mask >= 0 &&
-        mask & MEMBARRIER_CMD_PRIVATE_EXPEDITED)
-    {
-        if (membarrier(MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED, 0) == 0)
-        {
-            s_flushUsingMemBarrier = TRUE;
-            return TRUE;
-        }
-    }
-#ifdef TARGET_OSX
-    return TRUE;
-#else
-    s_helperPage = static_cast<int*>(mmap(0, GetVirtualPageSize(), PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0));
-    if(s_helperPage == MAP_FAILED)
-    {
-        return FALSE;
-    }
-    _ASSERTE((((SIZE_T)s_helperPage) & (GetVirtualPageSize() - 1)) == 0);
-    int status = mlock(s_helperPage, GetVirtualPageSize());
-    if (status != 0)
-    {
-        return FALSE;
-    }
-    status = pthread_mutex_init(&flushProcessWriteBuffersMutex, NULL);
-    if (status != 0)
-    {
-        munlock(s_helperPage, GetVirtualPageSize());
-    }
-    return status == 0;
-#endif // TARGET_OSX
-}
-#define FATAL_ASSERT(e, msg) \
-    do \
-    { \
-        if (!(e)) \
-        { \
-            fprintf(stderr, "FATAL ERROR: " msg); \
-            PROCAbort(); \
-        } \
-    } \
-    while(0)
-/*++
-Function:
-  FlushProcessWriteBuffers
-See MSDN doc.
---*/
-VOID
-PALAPI
-FlushProcessWriteBuffers()
-{
-    if (s_flushUsingMemBarrier)
-    {
-        int status = membarrier(MEMBARRIER_CMD_PRIVATE_EXPEDITED, 0);
-        FATAL_ASSERT(status == 0, "Failed to flush using membarrier");
-    }
-    else if (s_helperPage != 0)
-    {
-        int status = pthread_mutex_lock(&flushProcessWriteBuffersMutex);
-        FATAL_ASSERT(status == 0, "Failed to lock the flushProcessWriteBuffersMutex lock");
-        status = mprotect(s_helperPage, GetVirtualPageSize(), PROT_READ | PROT_WRITE);
-        FATAL_ASSERT(status == 0, "Failed to change helper page protection to read / write");
-        InterlockedIncrement(s_helperPage);
-        status = mprotect(s_helperPage, GetVirtualPageSize(), PROT_NONE);
-        FATAL_ASSERT(status == 0, "Failed to change helper page protection to no access");
-        status = pthread_mutex_unlock(&flushProcessWriteBuffersMutex);
-        FATAL_ASSERT(status == 0, "Failed to unlock the flushProcessWriteBuffersMutex lock");
-    }
-#ifdef TARGET_OSX
-    else
-    {
-        mach_msg_type_number_t cThreads;
-        thread_act_t *pThreads;
-        kern_return_t machret = task_threads(mach_task_self(), &pThreads, &cThreads);
-        CHECK_MACH("task_threads()", machret);
-        uintptr_t sp;
-        uintptr_t registerValues[128];
-        for (mach_msg_type_number_t i = 0; i < cThreads; i++)
-        {
-            size_t registers = 128;
-            machret = thread_get_register_pointer_values(pThreads[i], &sp, &registers, registerValues);
-            if (machret == KERN_INSUFFICIENT_BUFFER_SIZE)
-            {
-                CHECK_MACH("thread_get_register_pointer_values()", machret);
-            }
-            machret = mach_port_deallocate(mach_task_self(), pThreads[i]);
-            CHECK_MACH("mach_port_deallocate()", machret);
-        }
-        machret = vm_deallocate(mach_task_self(), (vm_address_t)pThreads, cThreads * sizeof(thread_act_t));
-        CHECK_MACH("vm_deallocate()", machret);
-    }
-#endif // TARGET_OSX
-}
-/*++
-Function:
-  PROCGetProcessIDFromHandle
-Abstract
-  Return the process ID from a process handle
-Parameter
-  hProcess:  process handle
-Return
-  Return the process ID, or 0 if it's not a valid handle
---*/
-DWORD
-PROCGetProcessIDFromHandle(
-        HANDLE hProcess)
-{
-    PAL_ERROR palError;
-    IPalObject *pobjProcess = NULL;
-    CPalThread *pThread = InternalGetCurrentThread();
-    DWORD dwProcessId = 0;
-    if (hPseudoCurrentProcess == hProcess)
-    {
-        dwProcessId = gPID;
-        goto PROCGetProcessIDFromHandleExit;
-    }
-    palError = g_pObjectManager->ReferenceObjectByHandle(
-        pThread,
-        hProcess,
-        &aotProcess,
-        &pobjProcess
-        );
-    if (NO_ERROR == palError)
-    {
-        IDataLock *pDataLock;
-        CProcProcessLocalData *pLocalData;
-        palError = pobjProcess->GetProcessLocalData(
-            pThread,
-            ReadLock,
-            &pDataLock,
-            reinterpret_cast<void **>(&pLocalData)
-            );
-        if (NO_ERROR == palError)
-        {
-            dwProcessId = pLocalData->dwProcessId;
-            pDataLock->ReleaseLock(pThread, FALSE);
-        }
-        pobjProcess->ReleaseReference(pThread);
-    }
-PROCGetProcessIDFromHandleExit:
-    return dwProcessId;
-}
-PAL_ERROR
-CorUnix::InitializeProcessData(
-    void
-    )
-{
-    PAL_ERROR palError = NO_ERROR;
-    bool fLockInitialized = FALSE;
-    pGThreadList = NULL;
-    g_dwThreadCount = 0;
-    InternalInitializeCriticalSection(&g_csProcess);
-    fLockInitialized = TRUE;
-    if (NO_ERROR != palError)
-    {
-        if (fLockInitialized)
-        {
-            InternalDeleteCriticalSection(&g_csProcess);
-        }
-    }
-    return palError;
-}
-/*++
-Function
-    InitializeProcessCommandLine
-Abstract
-    Initializes (or re-initializes) the saved command line and exe path.
-Parameter
-    lpwstrCmdLine
-    lpwstrFullPath
-Return
-    PAL_ERROR
-Notes
-    This function takes ownership of lpwstrCmdLine, but not of lpwstrFullPath
---*/
-PAL_ERROR
-CorUnix::InitializeProcessCommandLine(
-    LPWSTR lpwstrCmdLine,
-    LPWSTR lpwstrFullPath
-)
-{
-    PAL_ERROR palError = NO_ERROR;
-    LPWSTR initial_dir = NULL;
-    if (lpwstrFullPath)
-    {
-        LPWSTR lpwstr = PAL_wcsrchr(lpwstrFullPath, '/');
-        lpwstr[0] = '\0';
-        size_t n = PAL_wcslen(lpwstrFullPath) + 1;
-        size_t iLen = n;
-        initial_dir = reinterpret_cast<LPWSTR>(InternalMalloc(iLen*sizeof(WCHAR)));
-        if (NULL == initial_dir)
-        {
-            ERROR("malloc() failed! (initial_dir) \n");
-            palError = ERROR_NOT_ENOUGH_MEMORY;
-            goto exit;
-        }
-        if (wcscpy_s(initial_dir, iLen, lpwstrFullPath) != SAFECRT_SUCCESS)
-        {
-            ERROR("wcscpy_s failed!\n");
-            free(initial_dir);
-            palError = ERROR_INTERNAL_ERROR;
-            goto exit;
-        }
-        lpwstr[0] = '/';
-        free(g_lpwstrAppDir);
-        g_lpwstrAppDir = initial_dir;
-    }
-    free(g_lpwstrCmdLine);
-    g_lpwstrCmdLine = lpwstrCmdLine;
-exit:
-    return palError;
-}
-/*++
-Function:
-  CreateInitialProcessAndThreadObjects
-Abstract
-  Creates the IPalObjects that represent the current process
-  and the initial thread
-Parameter
-  pThread - the initial thread
-Return
-  PAL_ERROR
---*/
-PAL_ERROR
-CorUnix::CreateInitialProcessAndThreadObjects(
-    CPalThread *pThread
-    )
-{
-    PAL_ERROR palError = NO_ERROR;
-    HANDLE hThread;
-    IPalObject *pobjProcess = NULL;
-    IDataLock *pDataLock;
-    CProcProcessLocalData *pLocalData;
-    CObjectAttributes oa;
-    HANDLE hProcess;
-    palError = CreateThreadObject(pThread, pThread, &hThread);
-    if (NO_ERROR != palError)
-    {
-        goto CreateInitialProcessAndThreadObjectsExit;
-    }
-    (void) g_pObjectManager->RevokeHandle(pThread, hThread);
-    palError = g_pObjectManager->AllocateObject(
-        pThread,
-        &otProcess,
-        &oa,
-        &pobjProcess
-        );
-    if (NO_ERROR != palError)
-    {
-        ERROR("Unable to allocate process object");
-        goto CreateInitialProcessAndThreadObjectsExit;
-    }
-    palError = pobjProcess->GetProcessLocalData(
-        pThread,
-        WriteLock,
-        &pDataLock,
-        reinterpret_cast<void **>(&pLocalData)
-        );
-    if (NO_ERROR != palError)
-    {
-        ASSERT("Unable to access local data");
-        goto CreateInitialProcessAndThreadObjectsExit;
-    }
-    pLocalData->dwProcessId = gPID;
-    pLocalData->ps = PS_RUNNING;
-    pDataLock->ReleaseLock(pThread, TRUE);
-    palError = g_pObjectManager->RegisterObject(
-        pThread,
-        pobjProcess,
-        &aotProcess,
-        &hProcess,
-        &g_pobjProcess
-        );
-    pobjProcess = NULL;
-    if (NO_ERROR != palError)
-    {
-        ASSERT("Failure registering process object");
-        goto CreateInitialProcessAndThreadObjectsExit;
-    }
-    g_pObjectManager->RevokeHandle(pThread, hProcess);
-CreateInitialProcessAndThreadObjectsExit:
-    if (NULL != pobjProcess)
-    {
-        pobjProcess->ReleaseReference(pThread);
-    }
-    return palError;
-}
-/*++
-Function:
-  PROCCleanupInitialProcess
-Abstract
-  Cleanup all the structures for the initial process.
-Parameter
-  VOID
-Return
-  VOID
---*/
-VOID
-PROCCleanupInitialProcess(VOID)
-{
-    CPalThread *pThread = InternalGetCurrentThread();
-    InternalEnterCriticalSection(pThread, &g_csProcess);
-    /* Free the application directory */
-    free(g_lpwstrAppDir);
-    /* Free the stored command line */
-    free(g_lpwstrCmdLine);
-    InternalLeaveCriticalSection(pThread, &g_csProcess);
-}
-/*++
-Function:
-  PROCAddThread
-Abstract
-  Add a thread to the thread list of the current process
-Parameter
-  pThread:   Thread object
---*/
-VOID
-CorUnix::PROCAddThread(
-    CPalThread *pCurrentThread,
-    CPalThread *pTargetThread
-    )
-{
-    /* protect the access of the thread list with critical section for
-       mutithreading access */
-    InternalEnterCriticalSection(pCurrentThread, &g_csProcess);
-    pTargetThread->SetNext(pGThreadList);
-    pGThreadList = pTargetThread;
-    g_dwThreadCount += 1;
-    TRACE("Thread 0x%p (id %#x) added to the process thread list\n",
-          pTargetThread, pTargetThread->GetThreadId());
-    InternalLeaveCriticalSection(pCurrentThread, &g_csProcess);
-}
-/*++
-Function:
-  PROCRemoveThread
-Abstract
-  Remove a thread form the thread list of the current process
-Parameter
-  CPalThread *pThread : thread object to remove
-(no return value)
---*/
-VOID
-CorUnix::PROCRemoveThread(
-    CPalThread *pCurrentThread,
-    CPalThread *pTargetThread
-    )
-{
-    CPalThread *curThread, *prevThread;
-    /* protect the access of the thread list with critical section for
-       mutithreading access */
-    InternalEnterCriticalSection(pCurrentThread, &g_csProcess);
-    curThread = pGThreadList;
-    /* if thread list is empty */
-    if (curThread == NULL)
-    {
-        ASSERT("Thread list is empty.\n");
-        goto EXIT;
-    }
-    /* do we remove the first thread? */
-    if (curThread == pTargetThread)
-    {
-        pGThreadList =  curThread->GetNext();
-        TRACE("Thread 0x%p (id %#x) removed from the process thread list\n",
-            pTargetThread, pTargetThread->GetThreadId());
-        goto EXIT;
-    }
-    prevThread = curThread;
-    curThread = curThread->GetNext();
-    /* find the thread to remove */
-    while (curThread != NULL)
-    {
-        if (curThread == pTargetThread)
-        {
-            /* found, fix the chain list */
-            prevThread->SetNext(curThread->GetNext());
-            g_dwThreadCount -= 1;
-            TRACE("Thread %p removed from the process thread list\n", pTargetThread);
-            goto EXIT;
-        }
-        prevThread = curThread;
-        curThread = curThread->GetNext();
-    }
-    WARN("Thread %p not removed (it wasn't found in the list)\n", pTargetThread);
-EXIT:
-    InternalLeaveCriticalSection(pCurrentThread, &g_csProcess);
-}
-/*++
-Function:
-  PROCGetNumberOfThreads
-Abstract
-  Return the number of threads in the thread list.
-Parameter
-  void
-Return
-  the number of threads.
---*/
-INT
-CorUnix::PROCGetNumberOfThreads(
-    VOID)
-{
-    return g_dwThreadCount;
-}
-/*++
-Function:
-  PROCProcessLock
-Abstract
-  Enter the critical section associated to the current process
-Parameter
-  void
-Return
-  void
---*/
-VOID
-PROCProcessLock(
-    VOID)
-{
-    CPalThread * pThread =
-        (PALIsThreadDataInitialized() ? InternalGetCurrentThread() : NULL);
-    InternalEnterCriticalSection(pThread, &g_csProcess);
-}
-/*++
-Function:
-  PROCProcessUnlock
-Abstract
-  Leave the critical section associated to the current process
-Parameter
-  void
-Return
-  void
---*/
-VOID
-PROCProcessUnlock(
-    VOID)
-{
-    CPalThread * pThread =
-        (PALIsThreadDataInitialized() ? InternalGetCurrentThread() : NULL);
-    InternalLeaveCriticalSection(pThread, &g_csProcess);
-}
-#if USE_SYSV_SEMAPHORES
-/*++
-Function:
-  PROCCleanupThreadSemIds
-Abstract
-  Cleanup SysV semaphore ids for all threads
-(no parameters, no return value)
---*/
-VOID
-PROCCleanupThreadSemIds(void)
-{
-    PROCProcessLock();
-    CPalThread *pTargetThread = pGThreadList;
-    while (NULL != pTargetThread)
-    {
-        pTargetThread->suspensionInfo.DestroySemaphoreIds();
-        pTargetThread = pTargetThread->GetNext();
-    }
-    PROCProcessUnlock();
-}
-#endif // USE_SYSV_SEMAPHORES
-/*++
-Function:
-  TerminateCurrentProcessNoExit
-Abstract:
-    Terminate current Process, but leave the caller alive
-Parameters:
-    BOOL bTerminateUnconditionally - If this is set, the PAL will exit as
-    quickly as possible. In particular, it will not unload DLLs.
-Return value :
-    No return
-Note:
-  This function is used in ExitThread and TerminateProcess
---*/
-VOID
-CorUnix::TerminateCurrentProcessNoExit(BOOL bTerminateUnconditionally)
-{
-    BOOL locked;
-    DWORD old_terminator;
-    old_terminator = InterlockedCompareExchange(&terminator, GetCurrentThreadId(), 0);
-    if (0 != old_terminator && GetCurrentThreadId() != old_terminator)
-    {
-        /* another thread has already initiated the termination process. we
-           could just block on the PALInitLock critical section, but then
-           PROCSuspendOtherThreads would hang... so sleep forever here, we're
-           terminating anyway
-           Update: [TODO] PROCSuspendOtherThreads has been removed. Can this
-           code be changed? */
-        /* note that if *this* thread has already started the termination
-           process, we want to proceed. the only way this can happen is if a
-           call to DllMain (from ExitProcess) brought us here (because DllMain
-           called ExitProcess, or TerminateProcess, or ExitThread);
-           TerminateProcess won't call DllMain, so there's no danger to get
-           caught in an infinite loop */
-        WARN("termination already started from another thread; blocking.\n");
-        poll(NULL, 0, INFTIM);
-    }
-    /* Try to lock the initialization count to prevent multiple threads from
-       terminating/initializing the PAL simultaneously */
-    /* note : it's also important to take this lock before the process lock,
-       because Init/Shutdown take the init lock, and the functions they call
-       may take the process lock. We must do it in the same order to avoid
-       deadlocks */
-    locked = PALInitLock();
-    if(locked && PALIsInitialized())
-    {
-        PROCNotifyProcessShutdown();
-        PALCommonCleanup();
-    }
-}
-/*++
-Function:
-    PROCGetProcessStatus
-Abstract:
-    Retrieve process state information (state & exit code).
-Parameters:
-    DWORD process_id : PID of process to retrieve state for
-    PROCESS_STATE *state : state of process (starting, running, done)
-    DWORD *exit_code : exit code of process (from ExitProcess, etc.)
-Return value :
-    TRUE on success
---*/
-PAL_ERROR
-PROCGetProcessStatus(
-    CPalThread *pThread,
-    HANDLE hProcess,
-    PROCESS_STATE *pps,
-    DWORD *pdwExitCode
-    )
-{
-    PAL_ERROR palError = NO_ERROR;
-    IPalObject *pobjProcess = NULL;
-    IDataLock *pDataLock;
-    CProcProcessLocalData *pLocalData;
-    pid_t wait_retval;
-    int status;
-    palError = g_pObjectManager->ReferenceObjectByHandle(
-        pThread,
-        hProcess,
-        &aotProcess,
-        &pobjProcess
-        );
-    if (NO_ERROR != palError)
-    {
-        goto PROCGetProcessStatusExit;
-    }
-    palError = pobjProcess->GetProcessLocalData(
-        pThread,
-        WriteLock,
-        &pDataLock,
-        reinterpret_cast<void **>(&pLocalData)
-        );
-    if (PS_DONE == pLocalData->ps)
-    {
-        TRACE("We already called waitpid() on process ID %#x; process has "
-              "terminated, exit code is %d\n",
-              pLocalData->dwProcessId, pLocalData->dwExitCode);
-        *pps = pLocalData->ps;
-        *pdwExitCode = pLocalData->dwExitCode;
-        pDataLock->ReleaseLock(pThread, FALSE);
-        goto PROCGetProcessStatusExit;
-    }
-    /* By using waitpid(), we can even retrieve the exit code of a non-PAL
-       process. However, note that waitpid() can only provide the low 8 bits
-       of the exit code. This is all that is required for the PAL spec. */
-    TRACE("Looking for status of process; trying wait()");
-    while(1)
-    {
-        /* try to get state of process, using non-blocking call */
-        wait_retval = waitpid(pLocalData->dwProcessId, &status, WNOHANG);
-        if ( wait_retval == (pid_t) pLocalData->dwProcessId )
-        {
-            /* success; get the exit code */
-            if ( WIFEXITED( status ) )
-            {
-                *pdwExitCode = WEXITSTATUS(status);
-                TRACE("Exit code was %d\n", *pdwExitCode);
-            }
-            else
-            {
-                WARN("process terminated without exiting; can't get exit "
-                     "code. faking it.\n");
-                *pdwExitCode = EXIT_FAILURE;
-            }
-            *pps = PS_DONE;
-        }
-        else if (0 == wait_retval)
-        {
-            TRACE("Process %#x is still active.\n", pLocalData->dwProcessId);
-            *pps = PS_RUNNING;
-            *pdwExitCode = 0;
-        }
-        else if (-1 == wait_retval)
-        {
-            if (EINTR == errno)
-            {
-                TRACE("waitpid() failed with EINTR; re-waiting");
-                continue;
-            }
-            else if (ECHILD == errno)
-            {
-                TRACE("waitpid() failed with ECHILD; calling kill instead");
-                if (kill(pLocalData->dwProcessId, 0) != 0)
-                {
-                    if(ESRCH == errno)
-                    {
-                        WARN("kill() failed with ESRCH, i.e. target "
-                             "process exited and it wasn't a child, "
-                             "so can't get the exit code, assuming  "
-                             "it was 0.\n");
-                        *pdwExitCode = 0;
-                    }
-                    else
-                    {
-                        ERROR("kill(pid, 0) failed; errno is %d (%s)\n",
-                              errno, strerror(errno));
-                        *pdwExitCode = EXIT_FAILURE;
-                    }
-                    *pps = PS_DONE;
-                }
-                else
-                {
-                    *pps = PS_RUNNING;
-                    *pdwExitCode = 0;
-                }
-            }
-            else
-            {
-                ERROR("waitpid(pid=%u) failed with unexpected errno=%d (%s)\n",
-                      pLocalData->dwProcessId, errno, strerror(errno));
-                *pps = PS_RUNNING;
-                *pdwExitCode = 0;
-            }
-        }
-        else
-        {
-            ASSERT("waitpid returned unexpected value %d\n",wait_retval);
-            *pdwExitCode = EXIT_FAILURE;
-            *pps = PS_DONE;
-        }
-        break;
-    }
-    if(PS_DONE == *pps)
-    {
-        pLocalData->ps = PS_DONE;
-        pLocalData->dwExitCode = *pdwExitCode;
-    }
-    TRACE( "State of process 0x%08x : %d (exit code %d)\n",
-           pLocalData->dwProcessId, *pps, *pdwExitCode );
-    pDataLock->ReleaseLock(pThread, TRUE);
-PROCGetProcessStatusExit:
-    if (NULL != pobjProcess)
-    {
-        pobjProcess->ReleaseReference(pThread);
-    }
-    return palError;
-}
-#ifdef __APPLE__
-bool GetApplicationContainerFolder(PathCharString& buffer, const char *applicationGroupId, int applicationGroupIdLength)
-{
-    const char *homeDir = getpwuid(getuid())->pw_dir;
-    int homeDirLength = strlen(homeDir);
-    return buffer.Set(homeDir, homeDirLength)
-        && buffer.Append(APPLICATION_CONTAINER_BASE_PATH_SUFFIX)
-        && buffer.Append(applicationGroupId, applicationGroupIdLength)
-        && buffer.Append('/');
-}
-#endif // __APPLE__
-#ifdef _DEBUG
-void PROCDumpThreadList()
-{
-    CPalThread *pThread;
-    PROCProcessLock();
-    TRACE ("Threads:{\n");
-    pThread = pGThreadList;
-    while (NULL != pThread)
-    {
-        TRACE ("    {pThr=0x%p tid=%#x lwpid=%#x state=%d finsusp=%d}\n",
-               pThread, (int)pThread->GetThreadId(), (int)pThread->GetLwpId(),
-               (int)pThread->synchronizationInfo.GetThreadState(),
-               (int)pThread->suspensionInfo.GetSuspendedForShutdown());
-        pThread = pThread->GetNext();
-    }
-    TRACE ("Threads:}\n");
-    PROCProcessUnlock();
-}
-#endif
-/* Internal function definitions **********************************************/
-/*++
-Function:
-  getFileName
-Abstract:
-    Helper function for CreateProcessW, it retrieves the executable filename
-    from the application name, and the command line.
-Parameters:
-    IN  lpApplicationName:  first parameter from CreateProcessW (an unicode string)
-    IN  lpCommandLine: second parameter from CreateProcessW (an unicode string)
-    OUT lpFileName: file to be executed (the new process)
-Return:
-    TRUE: if the file name is retrieved
-    FALSE: otherwise
---*/
-static
-BOOL
-getFileName(
-       LPCWSTR lpApplicationName,
-       LPWSTR lpCommandLine,
-       PathCharString& lpPathFileName)
-{
-    LPWSTR lpEnd;
-    WCHAR wcEnd;
-    char * lpFileName;
-    PathCharString lpFileNamePS;
-    char *lpTemp;
-    if (lpApplicationName)
-    {
-        int length = WideCharToMultiByte(CP_ACP, 0, lpApplicationName, -1,
-                                            NULL, 0, NULL, NULL);
-        /* if only a file name is specified, prefix it with "./" */
-        if ((*lpApplicationName != '.') && (*lpApplicationName != '/') &&
-            (*lpApplicationName != '\\'))
-        {
-            length += 2;
-            lpTemp = lpPathFileName.OpenStringBuffer(length);
-            if (strcpy_s(lpTemp, length, "./") != SAFECRT_SUCCESS)
-            {
-                ERROR("strcpy_s failed!\n");
-                return FALSE;
-            }
-            lpTemp+=2;
-       }
-       else
-       {
-            lpTemp = lpPathFileName.OpenStringBuffer(length);
-       }
-        /* Convert to ASCII */
-        length = WideCharToMultiByte(CP_ACP, 0, lpApplicationName, -1,
-                                     lpTemp, length, NULL, NULL);
-        if (length == 0)
-        {
-            lpPathFileName.CloseBuffer(0);
-            ASSERT("WideCharToMultiByte failure\n");
-            return FALSE;
-        }
-        lpPathFileName.CloseBuffer(length -1);
-        /* Replace '\' by '/' */
-        FILEDosToUnixPathA(lpTemp);
-        return TRUE;
-    }
-    else
-    {
-        /* use the Command line */
-        /* filename should be the first token of the command line */
-        /* first skip all leading whitespace */
-        lpCommandLine = UTIL_inverse_wcspbrk(lpCommandLine,W16_WHITESPACE);
-        if(NULL == lpCommandLine)
-        {
-            ERROR("CommandLine contains only whitespace!\n");
-            return FALSE;
-        }
-        /* check if it is starting with a quote (") character */
-        if (*lpCommandLine == 0x0022)
-        {
-            lpCommandLine++; /* skip the quote */
-            /* file name ends with another quote */
-            lpEnd = PAL_wcschr(lpCommandLine+1, 0x0022);
-            /* if no quotes found, set lpEnd to the end of the Command line */
-            if (lpEnd == NULL)
-                lpEnd = lpCommandLine + PAL_wcslen(lpCommandLine);
-        }
-        else
-        {
-            /* filename is end out by a whitespace */
-            lpEnd = PAL_wcspbrk(lpCommandLine, W16_WHITESPACE);
-            /* if no whitespace found, set lpEnd to end of the Command line */
-            if (lpEnd == NULL)
-            {
-                lpEnd = lpCommandLine + PAL_wcslen(lpCommandLine);
-            }
-        }
-        if (lpEnd == lpCommandLine)
-        {
-            ERROR("application name and command line are both empty!\n");
-            return FALSE;
-        }
-        /* replace the last character by a null */
-        wcEnd = *lpEnd;
-        *lpEnd = 0x0000;
-        /* Convert to ASCII */
-        int size = 0;
-        int length = (PAL_wcslen(lpCommandLine)+1) * sizeof(WCHAR);
-        lpFileName = lpFileNamePS.OpenStringBuffer(length);
-        if (NULL == lpFileName)
-        {
-            ERROR("Not Enough Memory!\n");
-            return FALSE;
-        }
-        if (!(size = WideCharToMultiByte(CP_ACP, 0, lpCommandLine, -1,
-                                 lpFileName, length, NULL, NULL)))
-        {
-            ASSERT("WideCharToMultiByte failure\n");
-            return FALSE;
-        }
-        lpFileNamePS.CloseBuffer(size - 1);
-        /* restore last character */
-        *lpEnd = wcEnd;
-        /* Replace '\' by '/' */
-        FILEDosToUnixPathA(lpFileName);
-        if (!getPath(lpFileNamePS, lpPathFileName))
-        {
-            /* file is not in the path */
-            return FALSE;
-        }
-    }
-    return TRUE;
-}
-/*++
-Function:
-    checkFileType
-Abstract:
-    Return the type of the file.
-Parameters:
-    IN  lpFileName:  file name
-Return:
-    FILE_DIR: Directory
-    FILE_UNIX: Unix executable file
-    FILE_ERROR: Error
---*/
-static
-int
-checkFileType( LPCSTR lpFileName)
-{
-    struct stat stat_data;
-    /* check if the file exist */
-    if ( access(lpFileName, F_OK) != 0 )
-    {
-        return FILE_ERROR;
-    }
-    /* if it's not a PE/COFF file, check if it is executable */
-    if ( -1 != stat( lpFileName, &stat_data ) )
-    {
-        if((stat_data.st_mode & S_IFMT) == S_IFDIR )
-        {
-            /*The given file is a directory*/
-            return FILE_DIR;
-        }
-        if ( UTIL_IsExecuteBitsSet( &stat_data ) )
-        {
-            return FILE_UNIX;
-        }
-        else
-        {
-            return FILE_ERROR;
-        }
-    }
-    return FILE_ERROR;
-}
-/*++
-Function:
-  buildArgv
-Abstract:
-    Helper function for CreateProcessW, it builds the array of argument in
-    a format than can be passed to execve function.lppArgv is allocated
-    in this function and must be freed by the caller.
-Parameters:
-    IN  lpCommandLine: second parameter from CreateProcessW (an unicode string)
-    IN  lpAppPath: canonical name of the application to launched
-    OUT lppArgv: array of arguments to be passed to the new process
-Return:
-    the number of arguments
-note: this doesn't yet match precisely the behavior of Windows, but should be
-sufficient.
-what's here:
-1) stripping nonquoted whitespace
-2) handling of quoted parameters and quoted "parts" of parameters, removal of
-   doublequotes (<aaaa"b bbb b"ccc> becomes <aaaab bbb bccc>)
-3) \" as an escaped doublequote, both within doublequoted sequences and out
-what's known missing :
-1) \\ as an escaped backslash, but only if the string of '\'
-   is followed by a " (escaped or not)
-2) "alternate" escape sequence : double-doublequote within a double-quoted
-    argument (<"aaa a""aa aaa">) expands to a single-doublequote(<aaa a"aa aaa>)
-note that there may be other special cases
---*/
-static
-char **
-buildArgv(
-      LPCWSTR lpCommandLine,
-      PathCharString& lpAppPath,
-      UINT *pnArg)
-{
-    CPalThread *pThread = NULL;
-    UINT iWlen;
-    char *lpAsciiCmdLine;
-    char *pChar;
-    char **lppArgv;
-    char **lppTemp;
-    UINT i,j;
-    *pnArg = 0;
-    iWlen = WideCharToMultiByte(CP_ACP,0,lpCommandLine,-1,NULL,0,NULL,NULL);
-    if(0 == iWlen)
-    {
-        ASSERT("Can't determine length of command line\n");
-        return NULL;
-    }
-    pThread = InternalGetCurrentThread();
-    /* make sure to allocate enough space, up for the worst case scenario */
-    int iLength = (iWlen + lpAppPath.GetCount() + 2);
-    lpAsciiCmdLine = (char *) InternalMalloc(iLength);
-    if (lpAsciiCmdLine == NULL)
-    {
-        ERROR("Unable to allocate memory\n");
-        return NULL;
-    }
-    pChar = lpAsciiCmdLine;
-    /* put the canonical name of the application as the first parameter */
-    if ((strcpy_s(lpAsciiCmdLine, iLength, "\"") != SAFECRT_SUCCESS) ||
-        (strcat_s(lpAsciiCmdLine, iLength, lpAppPath) != SAFECRT_SUCCESS) ||
-        (strcat_s(lpAsciiCmdLine, iLength,  "\"") != SAFECRT_SUCCESS) ||
-        (strcat_s(lpAsciiCmdLine, iLength, " ") != SAFECRT_SUCCESS))
-    {
-        ERROR("strcpy_s/strcat_s failed!\n");
-        return NULL;
-    }
-    pChar = lpAsciiCmdLine + strlen (lpAsciiCmdLine);
-    /* let's skip the first argument in the command line */
-    /* strip leading whitespace; function returns NULL if there's only
-        whitespace, so the if statement below will work correctly */
-    lpCommandLine = UTIL_inverse_wcspbrk((LPWSTR)lpCommandLine, W16_WHITESPACE);
-    if (lpCommandLine)
-    {
-        LPCWSTR stringstart = lpCommandLine;
-        do
-        {
-            /* find first whitespace or dquote character */
-            lpCommandLine = PAL_wcspbrk(lpCommandLine,W16_WHITESPACE_DQUOTE);
-            if(NULL == lpCommandLine)
-            {
-                /* no whitespace or dquote found : first arg is only arg */
-                break;
-            }
-            else if('"' == *lpCommandLine)
-            {
-                /* got a dquote; skip over it if it's escaped; make sure we
-                    don't try to look before the first character in the
-                    string */
-                if(lpCommandLine > stringstart && '\\' == lpCommandLine[-1])
-                {
-                    lpCommandLine++;
-                    continue;
-                }
-                /* found beginning of dquoted sequence, run to the end */
-                /* don't stop if we hit an escaped dquote */
-                lpCommandLine++;
-                while( *lpCommandLine )
-                {
-                    lpCommandLine = PAL_wcschr(lpCommandLine, '"');
-                    if(NULL == lpCommandLine)
-                    {
-                        /* no ending dquote, arg runs to end of string */
-                        break;
-                    }
-                    if('\\' != lpCommandLine[-1])
-                    {
-                        /* dquote is not escaped, dquoted sequence is over*/
-                        break;
-                    }
-                    lpCommandLine++;
-                }
-                if(NULL == lpCommandLine || '\0' == *lpCommandLine)
-                {
-                    /* no terminating dquote */
-                    break;
-                }
-                /* step over dquote, keep looking for end of arg */
-                lpCommandLine++;
-            }
-            else
-            {
-                /* found whitespace : end of arg. */
-                lpCommandLine++;
-                break;
-            }
-        }while(lpCommandLine);
-    }
-    /* Convert to ASCII */
-    if (lpCommandLine)
-    {
-        if (!WideCharToMultiByte(CP_ACP, 0, lpCommandLine, -1,
-                                 pChar, iWlen+1, NULL, NULL))
-        {
-            ASSERT("Unable to convert to a multibyte string\n");
-            free(lpAsciiCmdLine);
-            return NULL;
-        }
-    }
-    pChar = lpAsciiCmdLine;
-    /* loops through all the arguments, to find out how many arguments there
-       are; while looping replace whitespace by \0 */
-    /* skip leading whitespace (and replace by '\0') */
-    /* note : there shouldn't be any, command starts either with PE loader name
-       or computed application path, but this won't hurt */
-    while (*pChar)
-    {
-        if (!isspace((unsigned char) *pChar))
-        {
-           break;
-        }
-        WARN("unexpected whitespace in command line!\n");
-        *pChar++ = '\0';
-    }
-    while (*pChar)
-    {
-        (*pnArg)++;
-        /* find end of current arg */
-        while(*pChar && !isspace((unsigned char) *pChar))
-        {
-            if('"' == *pChar)
-            {
-                /* skip over dquote if it's escaped; make sure we don't try to
-                   look before the start of the string for the \ */
-                if(pChar > lpAsciiCmdLine && '\\' == pChar[-1])
-                {
-                    pChar++;
-                    continue;
-                }
-                /* found leading dquote : look for ending dquote */
-                pChar++;
-                while (*pChar)
-                {
-                    pChar = strchr(pChar,'"');
-                    if(NULL == pChar)
-                    {
-                        /* no ending dquote found : argument extends to the end
-                           of the string*/
-                        break;
-                    }
-                    if('\\' != pChar[-1])
-                    {
-                        /* found a dquote, and it's not escaped : quoted
-                           sequence is over*/
-                        break;
-                    }
-                    /* found a dquote, but it was escaped : skip over it, keep
-                       looking */
-                    pChar++;
-                }
-                if(NULL == pChar || '\0' == *pChar)
-                {
-                    /* reached the end of the string : we're done */
-                    break;
-                }
-            }
-            pChar++;
-        }
-        if(NULL == pChar)
-        {
-            /* reached the end of the string : we're done */
-            break;
-        }
-        /* reached end of arg; replace trailing whitespace by '\0', to split
-           arguments into separate strings */
-        while (isspace((unsigned char) *pChar))
-        {
-            *pChar++ = '\0';
-        }
-    }
-    /* allocate lppargv according to the number of arguments
-       in the command line */
-    lppArgv = (char **) InternalMalloc((((*pnArg)+1) * sizeof(char *)));
-    if (lppArgv == NULL)
-    {
-        free(lpAsciiCmdLine);
-        return NULL;
-    }
-    lppTemp = lppArgv;
-    /* at this point all parameters are separated by NULL
-       we need to fill the array of arguments; we must also remove all dquotes
-       from arguments (new process shouldn't see them) */
-    for (i = *pnArg, pChar = lpAsciiCmdLine; i; i--)
-    {
-        /* skip NULLs */
-        while (!*pChar)
-        {
-            pChar++;
-        }
-        *lppTemp = pChar;
-        /* go to the next parameter, removing dquotes as we go along */
-        j = 0;
-        while (*pChar)
-        {
-            /* copy character if it's not a dquote */
-            if('"' != *pChar)
-            {
-                /* if it's the \ of an escaped dquote, skip over it, we'll
-                   copy the " instead */
-                if( '\\' == pChar[0] && '"' == pChar[1] )
-                {
-                    pChar++;
-                }
-                (*lppTemp)[j++] = *pChar;
-            }
-            pChar++;
-        }
-        /* re-NULL terminate the argument */
-        (*lppTemp)[j] = '\0';
-        lppTemp++;
-    }
-    *lppTemp = NULL;
-    return lppArgv;
-}
-/*++
-Function:
-  getPath
-Abstract:
-    Helper function for CreateProcessW, it looks in the path environment
-    variable to find where the process to executed is.
-Parameters:
-    IN  lpFileName: file name to search in the path
-    OUT lpPathFileName: returned string containing the path and the filename
-Return:
-    TRUE if found
-    FALSE otherwise
---*/
-static
-BOOL
-getPath(
-      PathCharString& lpFileNameString,
-      PathCharString& lpPathFileName)
-{
-    LPSTR lpPath;
-    LPSTR lpNext;
-    LPSTR lpCurrent;
-    LPWSTR lpwstr;
-    INT n;
-    INT nextLen;
-    INT slashLen;
-    CPalThread *pThread = NULL;
-    LPCSTR lpFileName = lpFileNameString.GetString();
-    /* if a path is specified, only look there */
-    if(strchr(lpFileName, '/'))
-    {
-        if (access (lpFileName, F_OK) == 0)
-        {
-            if (!lpPathFileName.Set(lpFileNameString))
-            {
-                TRACE("Set of StackString failed!\n");
-                return FALSE;
-            }
-            TRACE("file %s exists\n", lpFileName);
-            return TRUE;
-        }
-        else
-        {
-            TRACE("file %s doesn't exist.\n", lpFileName);
-            return FALSE;
-        }
-    }
-    /* first look in directory from which the application loaded */
-    lpwstr = g_lpwstrAppDir;
-    if (lpwstr)
-    {
-        /* convert path to multibyte, check buffer size */
-        n = WideCharToMultiByte(CP_ACP, 0, lpwstr, -1, NULL, 0,
-            NULL, NULL);
-        if (!lpPathFileName.Reserve(n + lpFileNameString.GetCount() + 1 ))
-        {
-            ERROR("StackString Reserve failed!\n");
-            return FALSE;
-        }
-        lpPath = lpPathFileName.OpenStringBuffer(n);
-        n = WideCharToMultiByte(CP_ACP, 0, lpwstr, -1, lpPath, n,
-            NULL, NULL);
-        if (n == 0)
-        {
-            lpPathFileName.CloseBuffer(0);
-            ASSERT("WideCharToMultiByte failure!\n");
-            return FALSE;
-        }
-        lpPathFileName.CloseBuffer(n - 1);
-        lpPathFileName.Append("/", 1);
-        lpPathFileName.Append(lpFileNameString);
-        if (access(lpPathFileName, F_OK) == 0)
-        {
-            TRACE("found %s in application directory (%s)\n", lpFileName, lpPathFileName.GetString());
-            return TRUE;
-        }
-    }
-    /* then try the current directory */
-    if (!lpPathFileName.Reserve(lpFileNameString.GetCount()  + 2))
-    {
-        ERROR("StackString Reserve failed!\n");
-        return FALSE;
-    }
-    lpPathFileName.Set("./", 2);
-    lpPathFileName.Append(lpFileNameString);
-    if (access (lpPathFileName, R_OK) == 0)
-    {
-        TRACE("found %s in current directory.\n", lpFileName);
-        return TRUE;
-    }
-    pThread = InternalGetCurrentThread();
-    /* Then try to look in the path */
-    lpPath = EnvironGetenv("PATH");
-    if (!lpPath)
-    {
-        ERROR("EnvironGetenv returned NULL for $PATH\n");
-        return FALSE;
-    }
-    lpNext = lpPath;
-    /* search in every path directory */
-    TRACE("looking for file %s in $PATH (%s)\n", lpFileName, lpPath);
-    while (lpNext)
-    {
-        /* skip all leading ':' */
-        while(*lpNext==':')
-        {
-            lpNext++;
-        }
-        /* search for ':' */
-        lpCurrent = strchr(lpNext, ':');
-        if (lpCurrent)
-        {
-            *lpCurrent++ = '\0';
-        }
-        nextLen = strlen(lpNext);
-        slashLen = (lpNext[nextLen-1] == '/') ? 0:1;
-        if (!lpPathFileName.Reserve(nextLen + lpFileNameString.GetCount() + 1))
-        {
-            free(lpPath);
-            ERROR("StackString ran out of memory for full path\n");
-            return FALSE;
-        }
-        lpPathFileName.Set(lpNext, nextLen);
-        if( slashLen == 1)
-        {
-            /* append a '/' if there's no '/' at the end of the path */
-            lpPathFileName.Append("/", 1);
-        }
-        lpPathFileName.Append(lpFileNameString);
-        if ( access (lpPathFileName, F_OK) == 0)
-        {
-            TRACE("Found %s in $PATH element %s\n", lpFileName, lpNext);
-            free(lpPath);
-            return TRUE;
-        }
-        lpNext = lpCurrent;  /* search in the next directory */
-    }
-    free(lpPath);
-    TRACE("File %s not found in $PATH\n", lpFileName);
-    return FALSE;
-}

--- a/src/coreclr/scripts/superpmi_collect_setup.py
+++ b//dev/null
@@ -1,392 +0,0 @@
-import argparse
-import os
-import stat
-from coreclr_arguments import *
-from jitutil import run_command, copy_directory, copy_files, set_pipeline_variable, ChangeDir, TempDir
-parser = argparse.ArgumentParser(description="description")
-parser.add_argument("-source_directory", help="path to source directory")
-parser.add_argument("-core_root_directory", help="path to core_root directory")
-parser.add_argument("-arch", help="Architecture")
-parser.add_argument("-platform", help="OS platform")
-parser.add_argument("-mch_file_tag", help="Tag to be used to mch files")
-parser.add_argument("-collection_name", help="Name of the SPMI collection to be done (e.g., libraries, tests)")
-parser.add_argument("-collection_type", help="Type of the SPMI collection to be done (crossgen, crossgen2, pmi)")
-parser.add_argument("-input_directory", help="directory containing assemblies for which superpmi collection to be done")
-parser.add_argument("-max_size", help="Max size of each partition in MB")
-is_windows = platform.system() == "Windows"
-native_binaries_to_ignore = [
-    "api-ms-win-core-console-l1-1-0.dll",
-    "api-ms-win-core-datetime-l1-1-0.dll",
-    "api-ms-win-core-debug-l1-1-0.dll",
-    "api-ms-win-core-errorhandling-l1-1-0.dll",
-    "api-ms-win-core-file-l1-1-0.dll",
-    "api-ms-win-core-file-l1-2-0.dll",
-    "api-ms-win-core-file-l2-1-0.dll",
-    "api-ms-win-core-handle-l1-1-0.dll",
-    "api-ms-win-core-heap-l1-1-0.dll",
-    "api-ms-win-core-interlocked-l1-1-0.dll",
-    "api-ms-win-core-libraryloader-l1-1-0.dll",
-    "api-ms-win-core-localization-l1-2-0.dll",
-    "api-ms-win-core-memory-l1-1-0.dll",
-    "api-ms-win-core-namedpipe-l1-1-0.dll",
-    "api-ms-win-core-processenvironment-l1-1-0.dll",
-    "api-ms-win-core-processthreads-l1-1-0.dll",
-    "api-ms-win-core-processthreads-l1-1-1.dll",
-    "api-ms-win-core-profile-l1-1-0.dll",
-    "api-ms-win-core-rtlsupport-l1-1-0.dll",
-    "api-ms-win-core-string-l1-1-0.dll",
-    "api-ms-win-core-synch-l1-1-0.dll",
-    "api-ms-win-core-synch-l1-2-0.dll",
-    "api-ms-win-core-sysinfo-l1-1-0.dll",
-    "api-ms-win-core-timezone-l1-1-0.dll",
-    "api-ms-win-core-util-l1-1-0.dll",
-    "api-ms-win-crt-conio-l1-1-0.dll",
-    "api-ms-win-crt-convert-l1-1-0.dll",
-    "api-ms-win-crt-environment-l1-1-0.dll",
-    "api-ms-win-crt-filesystem-l1-1-0.dll",
-    "api-ms-win-crt-heap-l1-1-0.dll",
-    "api-ms-win-crt-locale-l1-1-0.dll",
-    "api-ms-win-crt-math-l1-1-0.dll",
-    "api-ms-win-crt-multibyte-l1-1-0.dll",
-    "api-ms-win-crt-private-l1-1-0.dll",
-    "api-ms-win-crt-process-l1-1-0.dll",
-    "api-ms-win-crt-runtime-l1-1-0.dll",
-    "api-ms-win-crt-stdio-l1-1-0.dll",
-    "api-ms-win-crt-string-l1-1-0.dll",
-    "api-ms-win-crt-time-l1-1-0.dll",
-    "api-ms-win-crt-utility-l1-1-0.dll",
-    "clretwrc.dll",
-    "clrgc.dll",
-    "clrjit.dll",
-    "clrjit_unix_arm_arm.dll",
-    "clrjit_unix_arm_arm64.dll",
-    "clrjit_unix_arm_x64.dll",
-    "clrjit_unix_arm_x86.dll",
-    "clrjit_unix_arm64_arm64.dll",
-    "clrjit_unix_arm64_x64.dll",
-    "clrjit_unix_armel_arm.dll",
-    "clrjit_unix_armel_arm64.dll",
-    "clrjit_unix_armel_x64.dll",
-    "clrjit_unix_armel_x86.dll",
-    "clrjit_unix_osx_arm64_arm64.dll",
-    "clrjit_unix_osx_arm64_x64.dll",
-    "clrjit_unix_x64_arm64.dll",
-    "clrjit_unix_x64_x64.dll",
-    "clrjit_win_arm_arm.dll",
-    "clrjit_win_arm_arm64.dll",
-    "clrjit_win_arm_x64.dll",
-    "clrjit_win_arm_x86.dll",
-    "clrjit_win_arm64_arm64.dll",
-    "clrjit_win_arm64_x64.dll",
-    "clrjit_win_x64_arm64.dll",
-    "clrjit_win_x64_x64.dll",
-    "clrjit_win_x86_arm.dll",
-    "clrjit_win_x86_arm64.dll",
-    "clrjit_win_x86_x64.dll",
-    "clrjit_win_x86_x86.dll",
-    "clrjit_universal_arm_arm.dll",
-    "clrjit_universal_arm_arm64.dll",
-    "clrjit_universal_arm_x64.dll",
-    "clrjit_universal_arm_x86.dll",
-    "clrjit_universal_arm64_arm64.dll",
-    "clrjit_universal_arm64_x64.dll",
-    "coreclr.dll",
-    "CoreConsole.exe",
-    "coredistools.dll",
-    "CoreRun.exe",
-    "CoreShim.dll",
-    "createdump.exe",
-    "crossgen.exe",
-    "crossgen2.exe",
-    "dbgshim.dll",
-    "ilasm.exe",
-    "ildasm.exe",
-    "jitinterface_arm.dll",
-    "jitinterface_arm64.dll",
-    "jitinterface_x64.dll",
-    "jitinterface_x86.dll",
-    "KernelTraceControl.dll",
-    "KernelTraceControl.Win61.dll",
-    "mcs.exe",
-    "Microsoft.DiaSymReader.Native.amd64.dll",
-    "Microsoft.DiaSymReader.Native.x86.dll",
-    "mscordaccore.dll",
-    "mscordbi.dll",
-    "mscorrc.dll",
-    "msdia140.dll",
-    "msquic.dll",
-    "msvcp140.dll",
-    "vcruntime140.dll",
-    "vcruntime140_1.dll",
-    "R2RDump.exe",
-    "R2RTest.exe",
-    "superpmi.exe",
-    "superpmi-shim-collector.dll",
-    "superpmi-shim-counter.dll",
-    "superpmi-shim-simple.dll",
-    "System.CommandLine.resources.dll", # Managed, but uninteresting
-    "System.IO.Compression.Native.dll",
-    "ucrtbase.dll",
-    "xunit.console.exe",
-]
-MAX_FILES_COUNT = 1500
-def setup_args(args):
-    """ Setup the args for SuperPMI to use.
-    Args:
-        args (ArgParse): args parsed by arg parser
-    Returns:
-        args (CoreclrArguments)
-    """
-    coreclr_args = CoreclrArguments(args, require_built_core_root=False, require_built_product_dir=False,
-                                    require_built_test_dir=False, default_build_type="Checked")
-    coreclr_args.verify(args,
-                        "source_directory",
-                        lambda source_directory: os.path.isdir(source_directory),
-                        "source_directory doesn't exist")
-    coreclr_args.verify(args,
-                        "core_root_directory",
-                        lambda core_root_directory: os.path.isdir(core_root_directory),
-                        "core_root_directory doesn't exist")
-    coreclr_args.verify(args,
-                        "arch",
-                        lambda unused: True,
-                        "Unable to set arch")
-    coreclr_args.verify(args,
-                        "platform",
-                        lambda unused: True,
-                        "Unable to set platform")
-    coreclr_args.verify(args,
-                        "mch_file_tag",
-                        lambda unused: True,
-                        "Unable to set mch_file_tag")
-    coreclr_args.verify(args,
-                        "collection_name",
-                        lambda unused: True,
-                        "Unable to set collection_name")
-    coreclr_args.verify(args,
-                        "collection_type",
-                        lambda unused: True,
-                        "Unable to set collection_type")
-    coreclr_args.verify(args,
-                        "input_directory",
-                        lambda input_directory: os.path.isdir(input_directory),
-                        "input_directory doesn't exist")
-    coreclr_args.verify(args,
-                        "max_size",
-                        lambda max_size: max_size > 0,
-                        "Please enter valid positive numeric max_size",
-                        modify_arg=lambda max_size: int(
-                            max_size) * 1000 * 1000 if max_size is not None and max_size.isnumeric() else 0
-                        )
-    return coreclr_args
-def get_files_sorted_by_size(src_directory, exclude_directories, exclude_files):
-    """ For a given src_directory, returns all the .dll files sorted by size.
-    Args:
-        src_directory (string): Path of directory to enumerate.
-        exclude_directories ([string]): Directory names to exclude.
-        exclude_files ([string]): File names to exclude.
-    """
-    def sorter_by_size(pair):
-        """ Sorts the pair (file_name, file_size) tuple in descending order of file_size
-        Args:
-            pair ([(string, int)]): List of tuple of file_name, file_size
-        """
-        pair.sort(key=lambda x: x[1], reverse=True)
-        return pair
-    filename_with_size = []
-    exclude_files_lower = [filename.lower() for filename in exclude_files]
-    for file_path, dirs, files in os.walk(src_directory, topdown=True):
-        dirs[:] = [d for d in dirs if d not in exclude_directories]
-        for name in files:
-            if name.lower() in exclude_files_lower:
-                continue
-            curr_file_path = os.path.join(file_path, name)
-            if not os.path.isfile(curr_file_path):
-                continue
-            if not name.endswith(".dll") and not name.endswith(".exe"):
-                continue
-            size = os.path.getsize(curr_file_path)
-            filename_with_size.append((curr_file_path, size))
-    return sorter_by_size(filename_with_size)
-def first_fit(sorted_by_size, max_size):
-    """ Given a list of file names along with size in descending order, divides the files
-    in number of buckets such that each bucket doesn't exceed max_size (unless a single file exceeds
-    max_size, in which case it gets its own bucket). Since this is a first-fit
-    approach, it doesn't guarantee to find the bucket with tighest spot available.
-    Args:
-        sorted_by_size ((string, int)): (file_name, file_size) tuple
-        max_size (int): Maximum size (in bytes) of each bucket.
-    Returns:
-        [{int, [string]}]: Returns a dictionary of partition-index to list of file names following in that bucket.
-    """
-    partitions = {}
-    for curr_file in sorted_by_size:
-        _, file_size = curr_file
-        found_bucket = False
-        if file_size < max_size:
-            for p_index in partitions:
-                total_in_curr_par = sum(n for _, n in partitions[p_index])
-                if ((total_in_curr_par + file_size) < max_size) and (len(partitions[p_index]) < MAX_FILES_COUNT):
-                    partitions[p_index].append(curr_file)
-                    found_bucket = True
-                    break
-        if not found_bucket:
-            partitions[len(partitions)] = [curr_file]
-    total_size = 0
-    for p_index in partitions:
-        partition_size = sum(n for _, n in partitions[p_index])
-        print("Partition {0}: {1} files with {2} bytes.".format(p_index, len(partitions[p_index]), partition_size))
-        total_size += partition_size
-    print("Total {0} partitions with {1} bytes.".format(str(len(partitions)), total_size))
-    return partitions
-def partition_files(src_directory, dst_directory, max_size, exclude_directories=[],
-                    exclude_files=native_binaries_to_ignore):
-    """ Copy bucketized files based on size to destination folder.
-    Args:
-        src_directory (string): Source folder containing files to be copied.
-        dst_directory (string): Destination folder where files should be copied.
-        max_size (int): Maximum partition size in bytes
-        exclude_directories ([string]): List of folder names to be excluded.
-        exclude_files ([string]): List of files names to be excluded.
-    """
-    print('Partitioning files from {0} to {1}'.format(src_directory, dst_directory))
-    sorted_by_size = get_files_sorted_by_size(src_directory, exclude_directories, exclude_files)
-    partitions = first_fit(sorted_by_size, max_size)
-    index = 0
-    for p_index in partitions:
-        file_names = [curr_file[0] for curr_file in partitions[p_index]]
-        curr_dst_path = os.path.join(dst_directory, str(index), "binaries")
-        copy_files(src_directory, curr_dst_path, file_names)
-        index += 1
-def setup_microbenchmark(workitem_directory, arch):
-    """ Perform setup of microbenchmarks
-    Args:
-        workitem_directory (string): Path to work
-        arch (string): Architecture for which dotnet will be installed
-    """
-    performance_directory = os.path.join(workitem_directory, "performance")
-    run_command(
-        ["git", "clone", "--quiet", "--depth", "1", "https://github.com/dotnet/performance", performance_directory])
-    with ChangeDir(performance_directory):
-        dotnet_directory = os.path.join(performance_directory, "tools", "dotnet", arch)
-        dotnet_install_script = os.path.join(performance_directory, "scripts", "dotnet.py")
-        if not os.path.isfile(dotnet_install_script):
-            print("Missing " + dotnet_install_script)
-            return
-        run_command(
-            get_python_name() + [dotnet_install_script, "install", "--architecture", arch, "--install-dir",
-                                 dotnet_directory, "--verbose"])
-def get_python_name():
-    """Gets the python name
-    Returns:
-        [string]: Returns the appropriate python name depending on the OS.
-    """
-    if is_windows:
-        return ["py", "-3"]
-    else:
-        return ["python3"]
-def main(main_args):
-    """ Main entrypoint
-    Args:
-        main_args ([type]): Arguments to the script
-    """
-    coreclr_args = setup_args(main_args)
-    source_directory = coreclr_args.source_directory
-    correlation_payload_directory = os.path.join(coreclr_args.source_directory, "payload")
-    superpmi_src_directory = os.path.join(source_directory, 'src', 'coreclr', 'scripts')
-    superpmi_dst_directory = os.path.join(correlation_payload_directory, "superpmi")
-    arch = coreclr_args.arch
-    platform_name = coreclr_args.platform.lower()
-    helix_source_prefix = "official"
-    creator = ""
-    ci = True
-    if platform_name == "windows":
-        helix_queue = "Windows.10.Arm64" if arch == "arm64" else "Windows.10.Amd64.X86.Rt"
-    elif platform_name == "linux":
-        if arch == "arm":
-            helix_queue = "(Ubuntu.1804.Arm32)Ubuntu.1804.Armarch@mcr.microsoft.com/dotnet-buildtools/prereqs:ubuntu-18.04-helix-arm32v7"
-        elif arch == "arm64":
-            helix_queue = "(Ubuntu.1804.Arm64)Ubuntu.1804.ArmArch@mcr.microsoft.com/dotnet-buildtools/prereqs:ubuntu-18.04-helix-arm64v8"
-        else:
-            helix_queue = "Ubuntu.1804.Amd64"
-    elif platform_name == "osx":
-        helix_queue = "OSX.1100.ARM64" if arch == "arm64" else "OSX.1014.Amd64"
-    print('Copying {} -> {}'.format(superpmi_src_directory, superpmi_dst_directory))
-    copy_directory(superpmi_src_directory, superpmi_dst_directory, verbose_output=True, match_func=lambda path: any(path.endswith(extension) for extension in [".py"]))
-    if platform_name == "windows":
-        acceptable_copy = lambda path: any(path.endswith(extension) for extension in [".py", ".dll", ".exe", ".json"])
-    else:
-        acceptable_extensions = [".py", ".dll", ".json"]
-        acceptable_extensions.append(".so" if platform_name == "linux" else ".dylib")
-        acceptable_copy = lambda path: (os.path.basename(path).find(".") == -1) or any(path.endswith(extension) for extension in acceptable_extensions)
-    print('Copying {} -> {}'.format(coreclr_args.core_root_directory, superpmi_dst_directory))
-    copy_directory(coreclr_args.core_root_directory, superpmi_dst_directory, verbose_output=True, match_func=acceptable_copy)
-    if coreclr_args.collection_name == "libraries_tests":
-        print('Copying {} -> {}'.format(coreclr_args.input_directory, superpmi_dst_directory))
-        def make_readable(folder_name):
-            """Make file executable by changing the permission
-            Args:
-                folder_name (string): folder to mark with 744
-            """
-            if is_windows:
-                return
-            print("Inside make_readable")
-            run_command(["ls", "-l", folder_name])
-            for file_path, dirs, files in os.walk(folder_name, topdown=True):
-                for d in dirs:
-                    os.chmod(os.path.join(file_path, d),
-                    (stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR) |
-                    (stat.S_IRGRP) |
-                    (stat.S_IROTH))
-                for f in files:
-                    os.chmod(os.path.join(file_path, f),
-                    (stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR) |
-                    (stat.S_IRGRP) |
-                    (stat.S_IROTH))
-            run_command(["ls", "-l", folder_name])
-        make_readable(coreclr_args.input_directory)
-        copy_directory(coreclr_args.input_directory, superpmi_dst_directory, verbose_output=True, match_func=acceptable_copy)
-    workitem_directory = os.path.join(source_directory, "workitem")
-    input_artifacts = ""
-    if coreclr_args.collection_name == "benchmarks":
-        setup_microbenchmark(workitem_directory, arch)
-    else:
-        try:
-            with TempDir() as jitutils_directory:
-                run_command(
-                    ["git", "clone", "--quiet", "--depth", "1", "https://github.com/dotnet/jitutils", jitutils_directory])
-                dotnet_script_name = "dotnet.cmd" if is_windows else "dotnet.sh"
-                dotnet_script_path = os.path.join(source_directory, dotnet_script_name)
-                run_command([dotnet_script_path, "--info"], jitutils_directory)
-                os.environ["PATH"] = os.path.join(source_directory, ".dotnet") + os.pathsep + os.environ["PATH"]
-                build_file = "build.cmd" if is_windows else "build.sh"
-                run_command([os.path.join(jitutils_directory, build_file), "-p"], jitutils_directory)
-                copy_files(os.path.join(jitutils_directory, "bin"), superpmi_dst_directory, [os.path.join(jitutils_directory, "bin", "pmi.dll")])
-        except PermissionError as pe_error:
-            print('Ignoring PermissionError: {0}'.format(pe_error))
-        pmiassemblies_directory = os.path.join(workitem_directory, "pmiAssembliesDirectory")
-        input_artifacts = os.path.join(pmiassemblies_directory, coreclr_args.collection_name)
-        exclude_directory = ['Core_Root'] if coreclr_args.collection_name == "coreclr_tests" else []
-        exclude_files = native_binaries_to_ignore
-        if coreclr_args.collection_type == "crossgen2":
-            print('Adding exclusions for crossgen2')
-            exclude_files += ["Microsoft.Build.dll"]
-        if coreclr_args.collection_name == "libraries_tests":
-            core_root_dir = coreclr_args.core_root_directory
-            exclude_files += [item for item in os.listdir(core_root_dir)
-                              if os.path.isfile(os.path.join(core_root_dir, item)) and (item.endswith(".dll") or item.endswith(".exe"))]
-        partition_files(coreclr_args.input_directory, input_artifacts, coreclr_args.max_size, exclude_directory,
-                        exclude_files)
-    print('Setting pipeline variables:')
-    set_pipeline_variable("CorrelationPayloadDirectory", correlation_payload_directory)
-    set_pipeline_variable("WorkItemDirectory", workitem_directory)
-    set_pipeline_variable("InputArtifacts", input_artifacts)
-    set_pipeline_variable("Python", ' '.join(get_python_name()))
-    set_pipeline_variable("Architecture", arch)
-    set_pipeline_variable("Creator", creator)
-    set_pipeline_variable("Queue", helix_queue)
-    set_pipeline_variable("HelixSourcePrefix", helix_source_prefix)
-    set_pipeline_variable("MchFileTag", coreclr_args.mch_file_tag)
-if __name__ == "__main__":
-    args = parser.parse_args()
-    sys.exit(main(args))

--- a/src/coreclr/tools/aot/ILCompiler.Compiler/Compiler/DependencyAnalysis/PInvokeMethodFixupNode.cs
+++ b//dev/null
@@ -1,138 +0,0 @@
-using System;
-using System.Reflection.Metadata;
-using System.Runtime.InteropServices;
-using Internal.IL.Stubs;
-using Internal.Text;
-using Internal.TypeSystem;
-using Internal.TypeSystem.Ecma;
-namespace ILCompiler.DependencyAnalysis
-{
-    public class PInvokeMethodFixupNode : ObjectNode, ISymbolDefinitionNode
-    {
-        private readonly PInvokeMethodData _pInvokeMethodData;
-        public PInvokeMethodFixupNode(PInvokeMethodData pInvokeMethodData)
-        {
-            _pInvokeMethodData = pInvokeMethodData;
-        }
-        public void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb)
-        {
-            sb.Append("__pinvoke_");
-            _pInvokeMethodData.AppendMangledName(nameMangler, sb);
-        }
-        public int Offset => 0;
-        public override bool IsShareable => true;
-        protected override string GetName(NodeFactory factory) => this.GetMangledName(factory.NameMangler);
-        public override ObjectNodeSection Section => ObjectNodeSection.DataSection;
-        public override bool StaticDependenciesAreComputed => true;
-        public override ObjectData GetData(NodeFactory factory, bool relocsOnly = false)
-        {
-            ObjectDataBuilder builder = new ObjectDataBuilder(factory, relocsOnly);
-            builder.RequireInitialPointerAlignment();
-            builder.AddSymbol(this);
-            builder.EmitZeroPointer();
-            string entryPointName = _pInvokeMethodData.EntryPointName;
-            if (factory.Target.IsWindows && entryPointName.StartsWith("#", StringComparison.OrdinalIgnoreCase))
-            {
-                int entrypointOrdinal;
-                if (!int.TryParse(entryPointName.Substring(1), out entrypointOrdinal))
-                    entrypointOrdinal = 0;
-                builder.EmitNaturalInt((ushort)entrypointOrdinal);
-            }
-            else
-            {
-                builder.EmitPointerReloc(factory.ConstantUtf8String(entryPointName));
-            }
-            builder.EmitPointerReloc(factory.PInvokeModuleFixup(_pInvokeMethodData.ModuleData));
-            builder.EmitInt((int)_pInvokeMethodData.CharSetMangling);
-            return builder.ToObjectData();
-        }
-        public override int ClassCode => -1592006940;
-        public override int CompareToImpl(ISortableNode other, CompilerComparer comparer)
-        {
-            return _pInvokeMethodData.CompareTo(((PInvokeMethodFixupNode)other)._pInvokeMethodData, comparer);
-        }
-    }
-    public readonly struct PInvokeMethodData : IEquatable<PInvokeMethodData>
-    {
-        public readonly PInvokeModuleData ModuleData;
-        public readonly string EntryPointName;
-        public readonly CharSet CharSetMangling;
-        public PInvokeMethodData(PInvokeLazyFixupField pInvokeLazyFixupField)
-        {
-            PInvokeMetadata metadata = pInvokeLazyFixupField.PInvokeMetadata;
-            ModuleDesc declaringModule = ((MetadataType)pInvokeLazyFixupField.TargetMethod.OwningType).Module;
-            CustomAttributeValue<TypeDesc>? decodedAttr = null;
-            if (pInvokeLazyFixupField.TargetMethod is EcmaMethod method)
-            {
-                decodedAttr = method.GetDecodedCustomAttribute("System.Runtime.InteropServices", "DefaultDllImportSearchPathsAttribute");
-            }
-            if (!decodedAttr.HasValue && declaringModule.Assembly is EcmaAssembly asm)
-            {
-                var attrHandle = asm.MetadataReader.GetCustomAttributeHandle(asm.AssemblyDefinition.GetCustomAttributes(),
-                    "System.Runtime.InteropServices", "DefaultDllImportSearchPathsAttribute");
-                if (!attrHandle.IsNil)
-                {
-                    var attr = asm.MetadataReader.GetCustomAttribute(attrHandle);
-                    decodedAttr = attr.DecodeValue(new CustomAttributeTypeProvider(asm));
-                }
-            }
-            DllImportSearchPath? dllImportSearchPath = default;
-            if (decodedAttr.HasValue
-                && decodedAttr.Value.FixedArguments.Length == 1
-                && decodedAttr.Value.FixedArguments[0].Value is int searchPath)
-            {
-                dllImportSearchPath = (DllImportSearchPath)searchPath;
-            }
-            ModuleData = new PInvokeModuleData(metadata.Module, dllImportSearchPath, declaringModule);
-            EntryPointName = metadata.Name;
-            CharSet charSetMangling = default;
-            if (declaringModule.Context.Target.IsWindows && !metadata.Flags.ExactSpelling)
-            {
-                bool isAnsi = metadata.Flags.CharSet switch
-                {
-                    CharSet.Ansi => true,
-                    CharSet.Unicode => false,
-                    CharSet.Auto => false,
-                    _ => true
-                };
-                charSetMangling = isAnsi ? CharSet.Ansi : CharSet.Unicode;
-            }
-            CharSetMangling = charSetMangling;
-        }
-        public bool Equals(PInvokeMethodData other)
-        {
-            return ModuleData.Equals(other.ModuleData) &&
-                EntryPointName == other.EntryPointName &&
-                CharSetMangling == other.CharSetMangling;
-        }
-        public override bool Equals(object obj)
-        {
-            return obj is PInvokeMethodData other && Equals(other);
-        }
-        public override int GetHashCode()
-        {
-            return ModuleData.GetHashCode() ^ EntryPointName.GetHashCode();
-        }
-        public int CompareTo(PInvokeMethodData other, CompilerComparer comparer)
-        {
-            var entryPointCompare = StringComparer.Ordinal.Compare(EntryPointName, other.EntryPointName);
-            if (entryPointCompare != 0)
-                return entryPointCompare;
-            var moduleCompare = ModuleData.CompareTo(other.ModuleData, comparer);
-            if (moduleCompare != 0)
-                return moduleCompare;
-            return CharSetMangling.CompareTo(other.CharSetMangling);
-        }
-        public void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb)
-        {
-            ModuleData.AppendMangledName(nameMangler, sb);
-            sb.Append("__");
-            sb.Append(EntryPointName);
-            if (CharSetMangling != default)
-            {
-                sb.Append("__");
-                sb.Append(CharSetMangling.ToString());
-            }
-        }
-    }
-}

--- a/src/coreclr/vm/eventing/eventpipe/ep-rt-coreclr.h
+++ b//dev/null
@@ -1,2699 +0,0 @@
-#ifndef __EVENTPIPE_RT_CORECLR_H__
-#define __EVENTPIPE_RT_CORECLR_H__
-#include <eventpipe/ep-rt-config.h>
-#ifdef ENABLE_PERFTRACING
-#include <eventpipe/ep-thread.h>
-#include <eventpipe/ep-types.h>
-#include <eventpipe/ep-provider.h>
-#include <eventpipe/ep-session-provider.h>
-#include "fstream.h"
-#include "typestring.h"
-#include "win32threadpool.h"
-#include "clrversion.h"
-#undef EP_INFINITE_WAIT
-#define EP_INFINITE_WAIT INFINITE
-#undef EP_GCX_PREEMP_ENTER
-#define EP_GCX_PREEMP_ENTER { GCX_PREEMP();
-#undef EP_GCX_PREEMP_EXIT
-#define EP_GCX_PREEMP_EXIT }
-#undef EP_ALWAYS_INLINE
-#define EP_ALWAYS_INLINE FORCEINLINE
-#undef EP_NEVER_INLINE
-#define EP_NEVER_INLINE NOINLINE
-#undef EP_ALIGN_UP
-#define EP_ALIGN_UP(val,align) ALIGN_UP(val,align)
-#ifndef EP_RT_BUILD_TYPE_FUNC_NAME
-#define EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, type_name, func_name) \
-prefix_name ## _rt_ ## type_name ## _ ## func_name
-#endif
-template<typename LIST_TYPE>
-static
-inline
-void
-_rt_coreclr_list_alloc (LIST_TYPE *list) {
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (list != NULL);
-	list->list = new (nothrow) typename LIST_TYPE::list_type_t ();
-}
-template<typename LIST_TYPE>
-static
-inline
-void
-_rt_coreclr_list_free (
-	LIST_TYPE *list,
-	void (*callback)(void *))
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (list != NULL);
-	if (list->list) {
-		while (!list->list->IsEmpty ()) {
-				typename LIST_TYPE::element_type_t *current = list->list->RemoveHead ();
-				if (callback)
-					callback (reinterpret_cast<void *>(current->GetValue ()));
-				delete current;
-		}
-		delete list->list;
-	}
-	list->list = NULL;
-}
-template<typename LIST_TYPE>
-static
-inline
-void
-_rt_coreclr_list_clear (
-	LIST_TYPE *list,
-	void (*callback)(void *))
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (list != NULL && list->list != NULL);
-	while (!list->list->IsEmpty ()) {
-		typename LIST_TYPE::element_type_t *current = list->list->RemoveHead ();
-		if (callback)
-				callback (reinterpret_cast<void *>(current->GetValue ()));
-		delete current;
-	}
-}
-template<typename LIST_TYPE, typename LIST_ITEM>
-static
-inline
-bool
-_rt_coreclr_list_append (
-	LIST_TYPE *list,
-	LIST_ITEM item)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (list != NULL && list->list != NULL);
-	typename LIST_TYPE::element_type_t *node = new (nothrow) typename LIST_TYPE::element_type_t (item);
-	if (node)
-		list->list->InsertTail (node);
-	return (node != NULL);
-}
-template<typename LIST_TYPE, typename LIST_ITEM, typename CONST_LIST_ITEM = LIST_ITEM>
-static
-inline
-void
-_rt_coreclr_list_remove (
-	LIST_TYPE *list,
-	CONST_LIST_ITEM item)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (list != NULL && list->list != NULL);
-	typename LIST_TYPE::element_type_t *current = list->list->GetHead ();
-	while (current) {
-		if (current->GetValue () == item) {
-			if (list->list->FindAndRemove (current))
-					delete current;
-			break;
-		}
-		current = list->list->GetNext (current);
-	}
-}
-template<typename LIST_TYPE, typename LIST_ITEM, typename CONST_LIST_TYPE = const LIST_TYPE, typename CONST_LIST_ITEM = const LIST_ITEM>
-static
-inline
-bool
-_rt_coreclr_list_find (
-	CONST_LIST_TYPE *list,
-	CONST_LIST_ITEM item_to_find,
-	LIST_ITEM *found_item)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (list != NULL && list->list != NULL);
-	EP_ASSERT (found_item != NULL);
-	bool found = false;
-	typename LIST_TYPE::element_type_t *current = list->list->GetHead ();
-	while (current) {
-		if (current->GetValue () == item_to_find) {
-			*found_item = current->GetValue ();
-			found = true;
-			break;
-		}
-		current = list->list->GetNext (current);
-	}
-	return found;
-}
-template<typename LIST_TYPE, typename CONST_LIST_TYPE = const LIST_TYPE>
-static
-inline
-bool
-_rt_coreclr_list_is_empty (CONST_LIST_TYPE *list)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (list != NULL);
-	return (list->list == NULL || list->list->IsEmpty ());
-}
-template<typename LIST_TYPE, typename CONST_LIST_TYPE = const LIST_TYPE>
-static
-inline
-bool
-_rt_coreclr_list_is_valid (CONST_LIST_TYPE *list)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return (list != NULL && list->list != NULL);
-}
-template<typename LIST_TYPE, typename ITERATOR_TYPE, typename CONST_LIST_TYPE = const LIST_TYPE>
-static
-inline
-ITERATOR_TYPE
-_rt_coreclr_list_iterator_begin (CONST_LIST_TYPE *list)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (list != NULL && list->list != NULL);
-	return list->list->begin ();
-}
-template<typename LIST_TYPE, typename ITERATOR_TYPE, typename CONST_LIST_TYPE = const LIST_TYPE, typename CONST_ITERATOR_TYPE = const ITERATOR_TYPE>
-static
-inline
-bool
-_rt_coreclr_list_iterator_end (
-	CONST_LIST_TYPE *list,
-	CONST_ITERATOR_TYPE *iterator)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (list != NULL && list->list != NULL && iterator != NULL);
-	return (*iterator == list->list->end ());
-}
-template<typename ITERATOR_TYPE>
-static
-inline
-void
-_rt_coreclr_list_iterator_next (ITERATOR_TYPE *iterator)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (iterator != NULL);
-	(*iterator)++;
-}
-template<typename ITERATOR_TYPE, typename ITEM_TYPE, typename CONST_ITERATOR_TYPE = const ITERATOR_TYPE>
-static
-inline
-ITEM_TYPE
-_rt_coreclr_list_iterator_value (CONST_ITERATOR_TYPE *iterator)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (iterator != NULL);
-	return const_cast<ITERATOR_TYPE *>(iterator)->operator*();
-}
-template<typename QUEUE_TYPE>
-static
-inline
-void
-_rt_coreclr_queue_alloc (QUEUE_TYPE *queue)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (queue != NULL);
-	queue->queue = new (nothrow) typename QUEUE_TYPE::queue_type_t ();
-}
-template<typename QUEUE_TYPE>
-static
-inline
-void
-_rt_coreclr_queue_free (QUEUE_TYPE *queue)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (queue != NULL);
-	if (queue->queue)
-		delete queue->queue;
-	queue->queue = NULL;
-}
-template<typename QUEUE_TYPE, typename ITEM_TYPE>
-static
-inline
-bool
-_rt_coreclr_queue_pop_head (
-	QUEUE_TYPE *queue,
-	ITEM_TYPE *item)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (queue != NULL && queue->queue != NULL && item != NULL);
-	bool found = true;
-	typename QUEUE_TYPE::element_type_t *node = queue->queue->RemoveHead ();
-	if (node) {
-		*item = node->m_Value;
-		delete node;
-	} else {
-		*item = NULL;
-		found = false;
-	}
-	return found;
-}
-template<typename QUEUE_TYPE, typename ITEM_TYPE>
-static
-inline
-bool
-_rt_coreclr_queue_push_head (
-	QUEUE_TYPE *queue,
-	ITEM_TYPE item)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (queue != NULL && queue->queue != NULL);
-	typename QUEUE_TYPE::element_type_t *node = new (nothrow) typename QUEUE_TYPE::element_type_t (item);
-	if (node)
-		queue->queue->InsertHead (node);
-	return (node != NULL);
-}
-template<typename QUEUE_TYPE, typename ITEM_TYPE>
-static
-inline
-bool
-_rt_coreclr_queue_push_tail (
-	QUEUE_TYPE *queue,
-	ITEM_TYPE item)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (queue != NULL && queue->queue != NULL);
-	typename QUEUE_TYPE::element_type_t *node = new (nothrow) typename QUEUE_TYPE::element_type_t (item);
-	if (node)
-		queue->queue->InsertTail (node);
-	return (node != NULL);
-}
-template<typename QUEUE_TYPE, typename CONST_QUEUE_TYPE = const QUEUE_TYPE>
-static
-inline
-bool
-_rt_coreclr_queue_is_empty (CONST_QUEUE_TYPE *queue)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (queue != NULL && queue->queue != NULL);
-	return (queue->queue != NULL && queue->queue->IsEmpty ());
-}
-template<typename QUEUE_TYPE, typename CONST_QUEUE_TYPE = const QUEUE_TYPE>
-static
-inline
-bool
-_rt_coreclr_queue_is_valid (CONST_QUEUE_TYPE *queue)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return (queue != NULL && queue->queue != NULL);
-}
-template<typename ARRAY_TYPE>
-static
-inline
-void
-_rt_coreclr_array_alloc (ARRAY_TYPE *ep_array)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (ep_array != NULL);
-	ep_array->array = new (nothrow) typename ARRAY_TYPE::array_type_t ();
-}
-template<typename ARRAY_TYPE>
-static
-inline
-void
-_rt_coreclr_array_alloc_capacity (
-	ARRAY_TYPE *ep_array,
-	size_t capacity)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (ep_array != NULL);
-	ep_array->array = new (nothrow) typename ARRAY_TYPE::array_type_t ();
-	if (ep_array->array)
-		ep_array->array->AllocNoThrow (capacity);
-}
-template<typename ARRAY_TYPE>
-static
-inline
-void
-_rt_coreclr_array_init_capacity (
-	ARRAY_TYPE *ep_array,
-	size_t capacity)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (ep_array != NULL);
-	if (ep_array->array)
-		ep_array->array->AllocNoThrow (capacity);
-}
-template<typename ARRAY_TYPE>
-static
-inline
-void
-_rt_coreclr_array_free (ARRAY_TYPE *ep_array)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (ep_array != NULL);
-	if (ep_array->array) {
-		delete ep_array->array;
-		ep_array->array = NULL;
-	}
-}
-template<typename ARRAY_TYPE, typename ITEM_TYPE>
-static
-inline
-bool
-_rt_coreclr_array_append (
-	ARRAY_TYPE *ep_array,
-	ITEM_TYPE item)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (ep_array != NULL && ep_array->array != NULL);
-	return ep_array->array->PushNoThrow (item);
-}
-template<typename ARRAY_TYPE, typename ITEM_TYPE>
-static
-inline
-void
-_rt_coreclr_array_clear (ARRAY_TYPE *ep_array)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (ep_array != NULL && ep_array->array != NULL);
-	while (ep_array->array->Size () > 0)
-		ITEM_TYPE item = ep_array->array->Pop ();
-	ep_array->array->Shrink ();
-}
-template<typename ARRAY_TYPE, typename CONST_ARRAY_TYPE = const ARRAY_TYPE>
-static
-inline
-size_t
-_rt_coreclr_array_size (CONST_ARRAY_TYPE *ep_array)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (ep_array != NULL && ep_array->array != NULL);
-	return ep_array->array->Size ();
-}
-template<typename ARRAY_TYPE, typename ITEM_TYPE, typename CONST_ARRAY_TYPE = const ARRAY_TYPE>
-static
-inline
-ITEM_TYPE *
-_rt_coreclr_array_data (CONST_ARRAY_TYPE *ep_array)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (ep_array != NULL && ep_array->array != NULL);
-	return ep_array->array->Ptr ();
-}
-template<typename ARRAY_TYPE, typename CONST_ARRAY_TYPE = const ARRAY_TYPE>
-static
-inline
-bool
-_rt_coreclr_array_is_valid (CONST_ARRAY_TYPE *ep_array)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return (ep_array->array != NULL);
-}
-template<typename ARRAY_TYPE, typename ITERATOR_TYPE, typename CONST_ARRAY_TYPE = const ARRAY_TYPE>
-static
-inline
-ITERATOR_TYPE
-_rt_coreclr_array_iterator_begin (CONST_ARRAY_TYPE *ep_array)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (ep_array != NULL && ep_array->array != NULL);
-	ITERATOR_TYPE temp;
-	temp.array = ep_array->array;
-	temp.index = 0;
-	return temp;
-}
-template<typename ARRAY_TYPE, typename ITERATOR_TYPE, typename CONST_ARRAY_TYPE = const ARRAY_TYPE, typename CONST_ITERATOR_TYPE = const ITERATOR_TYPE>
-static
-inline
-bool
-_rt_coreclr_array_iterator_end (
-	CONST_ARRAY_TYPE *ep_array,
-	CONST_ITERATOR_TYPE *iterator)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (ep_array != NULL && iterator != NULL && iterator->array != NULL);
-	return (iterator->index >= static_cast<size_t>(iterator->array->Size ()));
-}
-template<typename ITERATOR_TYPE>
-static
-inline
-void
-_rt_coreclr_array_iterator_next (ITERATOR_TYPE *iterator)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (iterator != NULL);
-	iterator->index++;
-}
-template<typename ITERATOR_TYPE, typename ITEM_TYPE, typename CONST_ITERATOR_TYPE = const ITERATOR_TYPE>
-static
-inline
-ITEM_TYPE
-_rt_coreclr_array_iterator_value (const CONST_ITERATOR_TYPE *iterator)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (iterator != NULL && iterator->array != NULL);
-	EP_ASSERT (iterator->index < static_cast<size_t>(iterator->array->Size ()));
-	return iterator->array->operator[] (iterator->index);
-}
-template<typename ARRAY_TYPE, typename ITERATOR_TYPE, typename CONST_ARRAY_TYPE = const ARRAY_TYPE>
-static
-inline
-ITERATOR_TYPE
-_rt_coreclr_array_reverse_iterator_begin (CONST_ARRAY_TYPE *ep_array)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (ep_array != NULL && ep_array->array != NULL);
-	ITERATOR_TYPE temp;
-	temp.array = ep_array->array;
-	temp.index = static_cast<size_t>(ep_array->array->Size ());
-	return temp;
-}
-template<typename ARRAY_TYPE, typename ITERATOR_TYPE, typename CONST_ARRAY_TYPE = const ARRAY_TYPE, typename CONST_ITERATOR_TYPE = const ITERATOR_TYPE>
-static
-inline
-bool
-_rt_coreclr_array_reverse_iterator_end (
-	CONST_ARRAY_TYPE *ep_array,
-	CONST_ITERATOR_TYPE *iterator)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (ep_array != NULL && iterator != NULL && iterator->array != NULL);
-	return (iterator->index == 0);
-}
-template<typename ITERATOR_TYPE>
-static
-inline
-void
-_rt_coreclr_array_reverse_iterator_next (ITERATOR_TYPE *iterator)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (iterator != NULL);
-	iterator->index--;
-}
-template<typename ITERATOR_TYPE, typename ITEM_TYPE, typename CONST_ITERATOR_TYPE = const ITERATOR_TYPE>
-static
-inline
-ITEM_TYPE
-_rt_coreclr_array_reverse_iterator_value (CONST_ITERATOR_TYPE *iterator)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (iterator != NULL && iterator->array != NULL);
-	EP_ASSERT (iterator->index > 0);
-	return iterator->array->operator[] (iterator->index - 1);
-}
-template<typename HASH_MAP_TYPE>
-static
-inline
-void
-_rt_coreclr_hash_map_alloc (
-	HASH_MAP_TYPE *hash_map,
-	uint32_t (*hash_callback)(const void *),
-	bool (*eq_callback)(const void *, const void *),
-	void (*key_free_callback)(void *),
-	void (*value_free_callback)(void *))
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
-	EP_ASSERT (hash_map != NULL && key_free_callback == NULL);
-	hash_map->table = new (nothrow) typename HASH_MAP_TYPE::table_type_t ();
-	hash_map->callbacks.key_free_func = key_free_callback;
-	hash_map->callbacks.value_free_func = value_free_callback;
-}
-template<typename HASH_MAP_TYPE>
-static
-inline
-void
-_rt_coreclr_hash_map_free (HASH_MAP_TYPE *hash_map)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
-	EP_ASSERT (hash_map != NULL);
-	if (hash_map->table) {
-		if (hash_map->callbacks.value_free_func) {
-			for (typename HASH_MAP_TYPE::table_type_t::Iterator iterator = hash_map->table->Begin (); iterator != hash_map->table->End (); ++iterator)
-					hash_map->callbacks.value_free_func (reinterpret_cast<void *>((ptrdiff_t)(iterator->Value ())));
-		}
-		delete hash_map->table;
-	}
-}
-template<typename HASH_MAP_TYPE, typename KEY_TYPE, typename VALUE_TYPE>
-static
-inline
-bool
-_rt_coreclr_hash_map_add (
-	HASH_MAP_TYPE *hash_map,
-	KEY_TYPE key,
-	VALUE_TYPE value)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
-	EP_ASSERT (hash_map != NULL && hash_map->table != NULL);
-	return hash_map->table->AddNoThrow (typename HASH_MAP_TYPE::table_type_t::element_t (key, value));
-}
-template<typename HASH_MAP_TYPE, typename KEY_TYPE, typename VALUE_TYPE>
-static
-inline
-bool
-_rt_coreclr_hash_map_add_or_replace (
-	HASH_MAP_TYPE *hash_map,
-	KEY_TYPE key,
-	VALUE_TYPE value)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
-	EP_ASSERT (hash_map != NULL && hash_map->table != NULL);
-	return hash_map->table->AddOrReplaceNoThrow (typename HASH_MAP_TYPE::table_type_t::element_t (key, value));
-}
-template<typename HASH_MAP_TYPE>
-static
-inline
-void
-_rt_coreclr_hash_map_remove_all (HASH_MAP_TYPE *hash_map)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
-	EP_ASSERT (hash_map != NULL && hash_map->table != NULL);
-	if (hash_map->callbacks.value_free_func) {
-		for (typename HASH_MAP_TYPE::table_type_t::Iterator iterator = hash_map->table->Begin (); iterator != hash_map->table->End (); ++iterator)
-			hash_map->callbacks.value_free_func (reinterpret_cast<void *>((ptrdiff_t)(iterator->Value ())));
-	}
-	hash_map->table->RemoveAll ();
-}
-template<typename HASH_MAP_TYPE, typename KEY_TYPE, typename VALUE_TYPE, typename CONST_HASH_MAP_TYPE = const HASH_MAP_TYPE, typename CONST_KEY_TYPE = const KEY_TYPE>
-static
-inline
-bool
-_rt_coreclr_hash_map_lookup (
-	CONST_HASH_MAP_TYPE *hash_map,
-	CONST_KEY_TYPE key,
-	VALUE_TYPE *value)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
-	EP_ASSERT (hash_map != NULL && hash_map->table != NULL);
-	const typename HASH_MAP_TYPE::table_type_t::element_t *ret = hash_map->table->LookupPtr ((KEY_TYPE)key);
-	if (ret == NULL)
-		return false;
-	*value = ret->Value ();
-	return true;
-}
-template<typename HASH_MAP_TYPE, typename CONST_HASH_MAP_TYPE = const HASH_MAP_TYPE>
-static
-inline
-uint32_t
-_rt_coreclr_hash_map_count (CONST_HASH_MAP_TYPE *hash_map)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
-	EP_ASSERT (hash_map != NULL && hash_map->table != NULL);
-	return hash_map->table->GetCount ();
-}
-template<typename HASH_MAP_TYPE, typename CONST_HASH_MAP_TYPE = const HASH_MAP_TYPE>
-static
-inline
-bool
-_rt_coreclr_hash_map_is_valid (CONST_HASH_MAP_TYPE *hash_map)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
-	return (hash_map != NULL && hash_map->table != NULL);
-}
-template<typename HASH_MAP_TYPE, typename KEY_TYPE, typename CONST_KEY_TYPE = const KEY_TYPE>
-static
-inline
-void
-_rt_coreclr_hash_map_remove (
-	HASH_MAP_TYPE *hash_map,
-	CONST_KEY_TYPE key)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
-	EP_ASSERT (hash_map != NULL && hash_map->table != NULL);
-	const typename HASH_MAP_TYPE::table_type_t::element_t *ret = NULL;
-	if (hash_map->callbacks.value_free_func)
-		ret = hash_map->table->LookupPtr ((KEY_TYPE)key);
-	hash_map->table->Remove ((KEY_TYPE)key);
-	if (ret)
-		hash_map->callbacks.value_free_func (reinterpret_cast<void *>(static_cast<ptrdiff_t>(ret->Value ())));
-}
-template<typename HASH_MAP_TYPE, typename ITERATOR_TYPE, typename CONST_HASH_MAP_TYPE = const HASH_MAP_TYPE>
-static
-inline
-ITERATOR_TYPE
-_rt_coreclr_hash_map_iterator_begin (CONST_HASH_MAP_TYPE *hash_map)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
-	EP_ASSERT (hash_map != NULL && hash_map->table != NULL);
-	return hash_map->table->Begin ();
-}
-template<typename HASH_MAP_TYPE, typename ITERATOR_TYPE, typename CONST_HASH_MAP_TYPE = const HASH_MAP_TYPE, typename CONST_ITERATOR_TYPE = const ITERATOR_TYPE>
-static
-inline
-bool
-_rt_coreclr_hash_map_iterator_end (
-	CONST_HASH_MAP_TYPE *hash_map,
-	CONST_ITERATOR_TYPE *iterator)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
-	EP_ASSERT (hash_map != NULL && hash_map->table != NULL && iterator != NULL);
-	return (hash_map->table->End () == *iterator);
-}
-template<typename HASH_MAP_TYPE, typename ITERATOR_TYPE>
-static
-inline
-void
-_rt_coreclr_hash_map_iterator_next (ITERATOR_TYPE *iterator)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
-	EP_ASSERT (iterator != NULL);
-	(*iterator)++;
-}
-template<typename HASH_MAP_TYPE, typename ITERATOR_TYPE, typename KEY_TYPE, typename CONST_ITERATOR_TYPE = const ITERATOR_TYPE>
-static
-inline
-KEY_TYPE
-_rt_coreclr_hash_map_iterator_key (CONST_ITERATOR_TYPE *iterator)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
-	EP_ASSERT (iterator != NULL);
-	return (*iterator)->Key ();
-}
-template<typename HASH_MAP_TYPE, typename ITERATOR_TYPE, typename VALUE_TYPE, typename CONST_ITERATOR_TYPE = const ITERATOR_TYPE>
-static
-inline
-VALUE_TYPE
-_rt_coreclr_hash_map_iterator_value (CONST_ITERATOR_TYPE *iterator)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
-	EP_ASSERT (iterator != NULL);
-	return (*iterator)->Value ();
-}
-#define EP_RT_DEFINE_LIST_PREFIX(prefix_name, list_name, list_type, item_type) \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, alloc) (list_type *list) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		_rt_coreclr_list_alloc<list_type>(list); \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, free) (list_type *list, void (*callback)(void *)) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		_rt_coreclr_list_free<list_type>(list, callback); \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, clear) (list_type *list, void (*callback)(void *)) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		_rt_coreclr_list_clear<list_type>(list, callback); \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, append) (list_type *list, item_type item) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_list_append<list_type, item_type>(list, item); \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, remove) (list_type *list, const item_type item) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		_rt_coreclr_list_remove<list_type, item_type>(list, item); \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, find) (const list_type *list, const item_type item_to_find, item_type *found_item) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_list_find<list_type, item_type>(list, item_to_find, found_item); \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, is_empty) (const list_type *list) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_list_is_empty<list_type>(list); \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, is_valid) (const list_type *list) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_list_is_valid<list_type>(list); \
-	}
-#undef EP_RT_DEFINE_LIST
-#define EP_RT_DEFINE_LIST(list_name, list_type, item_type) \
-	EP_RT_DEFINE_LIST_PREFIX(ep, list_name, list_type, item_type)
-#define EP_RT_DEFINE_LIST_ITERATOR_PREFIX(prefix_name, list_name, list_type, iterator_type, item_type) \
-	static inline iterator_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, iterator_begin) (const list_type *list) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_list_iterator_begin<list_type, iterator_type>(list); \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, iterator_end) (const list_type *list, const iterator_type *iterator) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_list_iterator_end<list_type, iterator_type>(list, iterator); \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, iterator_next) (iterator_type *iterator) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		_rt_coreclr_list_iterator_next<iterator_type>(iterator); \
-	} \
-	static inline item_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, iterator_value) (const iterator_type *iterator) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_list_iterator_value<iterator_type, item_type>(iterator); \
-	}
-#undef EP_RT_DEFINE_LIST_ITERATOR
-#define EP_RT_DEFINE_LIST_ITERATOR(list_name, list_type, iterator_type, item_type) \
-	EP_RT_DEFINE_LIST_ITERATOR_PREFIX(ep, list_name, list_type, iterator_type, item_type)
-#define EP_RT_DEFINE_QUEUE_PREFIX(prefix_name, queue_name, queue_type, item_type) \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, alloc) (queue_type *queue) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		_rt_coreclr_queue_alloc<queue_type>(queue); \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, free) (queue_type *queue) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		_rt_coreclr_queue_free<queue_type>(queue); \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, pop_head) (queue_type *queue, item_type *item) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_queue_pop_head<queue_type, item_type>(queue, item); \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, push_head) (queue_type *queue, item_type item) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_queue_push_head<queue_type, item_type>(queue, item); \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, push_tail) (queue_type *queue, item_type item) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_queue_push_tail<queue_type, item_type>(queue, item); \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, is_empty) (const queue_type *queue) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_queue_is_empty<queue_type>(queue); \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, is_valid) (const queue_type *queue) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_queue_is_valid<queue_type>(queue); \
-	}
-#undef EP_RT_DEFINE_QUEUE
-#define EP_RT_DEFINE_QUEUE(queue_name, queue_type, item_type) \
-	EP_RT_DEFINE_QUEUE_PREFIX(ep, queue_name, queue_type, item_type)
-#define EP_RT_DEFINE_ARRAY_PREFIX(prefix_name, array_name, array_type, iterator_type, item_type) \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, alloc) (array_type *ep_array) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		_rt_coreclr_array_alloc<array_type>(ep_array); \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, alloc_capacity) (array_type *ep_array, size_t capacity) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		_rt_coreclr_array_alloc_capacity<array_type>(ep_array, capacity); \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, free) (array_type *ep_array) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		_rt_coreclr_array_free<array_type>(ep_array); \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, append) (array_type *ep_array, item_type item) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_array_append<array_type, item_type> (ep_array, item); \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, clear) (array_type *ep_array) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		_rt_coreclr_array_clear<array_type, item_type> (ep_array); \
-	} \
-	static inline size_t EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, size) (const array_type *ep_array) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_array_size<array_type> (ep_array); \
-	} \
-	static inline item_type * EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, data) (const array_type *ep_array) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_array_data<array_type, item_type> (ep_array); \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, is_valid) (const array_type *ep_array) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_array_is_valid<array_type> (ep_array); \
-	}
-#define EP_RT_DEFINE_LOCAL_ARRAY_PREFIX(prefix_name, array_name, array_type, iterator_type, item_type) \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, init) (array_type *ep_array) { \
-		STATIC_CONTRACT_NOTHROW; \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, init_capacity) (array_type *ep_array, size_t capacity) { \
-		STATIC_CONTRACT_NOTHROW; \
-		_rt_coreclr_array_init_capacity<array_type>(ep_array, capacity); \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, fini) (array_type *ep_array) { \
-		STATIC_CONTRACT_NOTHROW; \
-	}
-#undef EP_RT_DEFINE_ARRAY
-#define EP_RT_DEFINE_ARRAY(array_name, array_type, iterator_type, item_type) \
-	EP_RT_DEFINE_ARRAY_PREFIX(ep, array_name, array_type, iterator_type, item_type)
-#undef EP_RT_DEFINE_LOCAL_ARRAY
-#define EP_RT_DEFINE_LOCAL_ARRAY(array_name, array_type, iterator_type, item_type) \
-	EP_RT_DEFINE_LOCAL_ARRAY_PREFIX(ep, array_name, array_type, iterator_type, item_type)
-#define EP_RT_DECLARE_LOCAL_ARRAY_VARIABLE(var_name, var_type) \
-	var_type::array_type_t _local_ ##var_name; \
-	var_type var_name; \
-	var_name.array = &_local_ ##var_name
-#define EP_RT_DEFINE_ARRAY_ITERATOR_PREFIX(prefix_name, array_name, array_type, iterator_type, item_type) \
-	static inline iterator_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, iterator_begin) (const array_type *ep_array) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_array_iterator_begin<array_type, iterator_type> (ep_array); \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, iterator_end) (const array_type *ep_array, const iterator_type *iterator) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_array_iterator_end<array_type, iterator_type> (ep_array, iterator); \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, iterator_next) (iterator_type *iterator) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		_rt_coreclr_array_iterator_next<iterator_type> (iterator); \
-	} \
-	static inline item_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, iterator_value) (const iterator_type *iterator) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_array_iterator_value<iterator_type, item_type> (iterator); \
-	}
-#define EP_RT_DEFINE_ARRAY_REVERSE_ITERATOR_PREFIX(prefix_name, array_name, array_type, iterator_type, item_type) \
-	static inline iterator_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, reverse_iterator_begin) (const array_type *ep_array) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_array_reverse_iterator_begin<array_type, iterator_type> (ep_array); \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, reverse_iterator_end) (const array_type *ep_array, const iterator_type *iterator) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_array_reverse_iterator_end<array_type, iterator_type> (ep_array, iterator); \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, reverse_iterator_next) (iterator_type *iterator) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		_rt_coreclr_array_reverse_iterator_next<iterator_type> (iterator); \
-	} \
-	static inline item_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, reverse_iterator_value) (const iterator_type *iterator) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_array_reverse_iterator_value<iterator_type, item_type> (iterator); \
-	}
-#undef EP_RT_DEFINE_ARRAY_ITERATOR
-#define EP_RT_DEFINE_ARRAY_ITERATOR(array_name, array_type, iterator_type, item_type) \
-	EP_RT_DEFINE_ARRAY_ITERATOR_PREFIX(ep, array_name, array_type, iterator_type, item_type)
-#undef EP_RT_DEFINE_ARRAY_REVERSE_ITERATOR
-#define EP_RT_DEFINE_ARRAY_REVERSE_ITERATOR(array_name, array_type, iterator_type, item_type) \
-	EP_RT_DEFINE_ARRAY_REVERSE_ITERATOR_PREFIX(ep, array_name, array_type, iterator_type, item_type)
-#define EP_RT_DEFINE_HASH_MAP_BASE_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, alloc) (hash_map_type *hash_map, uint32_t (*hash_callback)(const void *), bool (*eq_callback)(const void *, const void *), void (*key_free_callback)(void *), void (*value_free_callback)(void *)) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		_rt_coreclr_hash_map_alloc<hash_map_type>(hash_map, hash_callback, eq_callback, key_free_callback, value_free_callback); \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, free) (hash_map_type *hash_map) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		_rt_coreclr_hash_map_free<hash_map_type>(hash_map); \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, add) (hash_map_type *hash_map, key_type key, value_type value) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_hash_map_add<hash_map_type, key_type, value_type>(hash_map, key, value); \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, remove_all) (hash_map_type *hash_map) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		_rt_coreclr_hash_map_remove_all<hash_map_type>(hash_map); \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, lookup) (const hash_map_type *hash_map, const key_type key, value_type *value) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_hash_map_lookup<hash_map_type, key_type, value_type>(hash_map, key, value); \
-	} \
-	static inline uint32_t EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, count) (const hash_map_type *hash_map) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_hash_map_count<hash_map_type>(hash_map); \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, is_valid) (const hash_map_type *hash_map) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_hash_map_is_valid<hash_map_type>(hash_map); \
-	}
-#define EP_RT_DEFINE_HASH_MAP_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
-	EP_RT_DEFINE_HASH_MAP_BASE_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, add_or_replace) (hash_map_type *hash_map, key_type key, value_type value) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_hash_map_add_or_replace<hash_map_type, key_type, value_type>(hash_map, key, value); \
-	} \
-#define EP_RT_DEFINE_HASH_MAP_REMOVE_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
-	EP_RT_DEFINE_HASH_MAP_BASE_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, remove) (hash_map_type *hash_map, const key_type key) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		_rt_coreclr_hash_map_remove<hash_map_type, key_type>(hash_map, key); \
-	}
-#undef EP_RT_DEFINE_HASH_MAP
-#define EP_RT_DEFINE_HASH_MAP(hash_map_name, hash_map_type, key_type, value_type) \
-	EP_RT_DEFINE_HASH_MAP_PREFIX(ep, hash_map_name, hash_map_type, key_type, value_type)
-#undef EP_RT_DEFINE_HASH_MAP_REMOVE
-#define EP_RT_DEFINE_HASH_MAP_REMOVE(hash_map_name, hash_map_type, key_type, value_type) \
-	EP_RT_DEFINE_HASH_MAP_REMOVE_PREFIX(ep, hash_map_name, hash_map_type, key_type, value_type)
-#define EP_RT_DEFINE_HASH_MAP_ITERATOR_PREFIX(prefix_name, hash_map_name, hash_map_type, iterator_type, key_type, value_type) \
-	static inline iterator_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_begin) (const hash_map_type *hash_map) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_hash_map_iterator_begin<hash_map_type, iterator_type>(hash_map); \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_end) (const hash_map_type *hash_map, const iterator_type *iterator) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_hash_map_iterator_end<hash_map_type, iterator_type>(hash_map, iterator); \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_next) (iterator_type *iterator) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		_rt_coreclr_hash_map_iterator_next<hash_map_type, iterator_type>(iterator); \
-	} \
-	static inline key_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_key) (const iterator_type *iterator) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_hash_map_iterator_key<hash_map_type, iterator_type, key_type>(iterator); \
-	} \
-	static inline value_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_value) (const iterator_type *iterator) \
-	{ \
-		STATIC_CONTRACT_NOTHROW; \
-		return _rt_coreclr_hash_map_iterator_value<hash_map_type, iterator_type, value_type>(iterator); \
-	}
-#undef EP_RT_DEFINE_HASH_MAP_ITERATOR
-#define EP_RT_DEFINE_HASH_MAP_ITERATOR(hash_map_name, hash_map_type, iterator_type, key_type, value_type) \
-	EP_RT_DEFINE_HASH_MAP_ITERATOR_PREFIX(ep, hash_map_name, hash_map_type, iterator_type, key_type, value_type)
-static
-inline
-ep_rt_lock_handle_t *
-ep_rt_coreclr_config_lock_get (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	extern ep_rt_lock_handle_t _ep_rt_coreclr_config_lock_handle;
-	return &_ep_rt_coreclr_config_lock_handle;
-}
-static
-inline
-const ep_char8_t *
-ep_rt_entrypoint_assembly_name_get_utf8 (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	AppDomain *app_domain_ref = nullptr;
-	Assembly *assembly_ref = nullptr;
-	app_domain_ref = GetAppDomain ();
-	if (app_domain_ref != nullptr)
-	{
-		assembly_ref = app_domain_ref->GetRootAssembly ();
-		if (assembly_ref != nullptr)
-		{
-			return reinterpret_cast<const ep_char8_t*>(assembly_ref->GetSimpleName ());
-		}
-	}
-	return reinterpret_cast<const ep_char8_t*>("");
-}
-static
-const ep_char8_t *
-ep_rt_runtime_version_get_utf8 (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return reinterpret_cast<const ep_char8_t*>(CLR_PRODUCT_VERSION);
-}
-/*
- * Little-Endian Conversion.
- */
-static
-EP_ALWAYS_INLINE
-uint16_t
-ep_rt_val_uint16_t (uint16_t value)
-{
-	return value;
-}
-static
-EP_ALWAYS_INLINE
-uint32_t
-ep_rt_val_uint32_t (uint32_t value)
-{
-	return value;
-}
-static
-EP_ALWAYS_INLINE
-uint64_t
-ep_rt_val_uint64_t (uint64_t value)
-{
-	return value;
-}
-static
-EP_ALWAYS_INLINE
-int16_t
-ep_rt_val_int16_t (int16_t value)
-{
-	return value;
-}
-static
-EP_ALWAYS_INLINE
-int32_t
-ep_rt_val_int32_t (int32_t value)
-{
-	return value;
-}
-static
-EP_ALWAYS_INLINE
-int64_t
-ep_rt_val_int64_t (int64_t value)
-{
-	return value;
-}
-static
-EP_ALWAYS_INLINE
-uintptr_t
-ep_rt_val_uintptr_t (uintptr_t value)
-{
-	return value;
-}
-/*
-* Atomics.
-*/
-static
-inline
-uint32_t
-ep_rt_atomic_inc_uint32_t (volatile uint32_t *value)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return static_cast<uint32_t>(InterlockedIncrement ((volatile LONG *)(value)));
-}
-static
-inline
-uint32_t
-ep_rt_atomic_dec_uint32_t (volatile uint32_t *value)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return static_cast<uint32_t>(InterlockedDecrement ((volatile LONG *)(value)));
-}
-static
-inline
-int32_t
-ep_rt_atomic_inc_int32_t (volatile int32_t *value)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return static_cast<int32_t>(InterlockedIncrement ((volatile LONG *)(value)));
-}
-static
-inline
-int32_t
-ep_rt_atomic_dec_int32_t (volatile int32_t *value)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return static_cast<int32_t>(InterlockedDecrement ((volatile LONG *)(value)));
-}
-static
-inline
-int64_t
-ep_rt_atomic_inc_int64_t (volatile int64_t *value)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return static_cast<int64_t>(InterlockedIncrement64 ((volatile LONG64 *)(value)));
-}
-static
-inline
-int64_t
-ep_rt_atomic_dec_int64_t (volatile int64_t *value)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return static_cast<int64_t>(InterlockedDecrement64 ((volatile LONG64 *)(value)));
-}
-static
-inline
-size_t
-ep_rt_atomic_compare_exchange_size_t (volatile size_t *target, size_t expected, size_t value)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return static_cast<size_t>(InterlockedCompareExchangeT<size_t> (target, value, expected));
-}
-static
-inline
-ep_char8_t *
-ep_rt_atomic_compare_exchange_utf8_string (ep_char8_t *volatile *target, ep_char8_t *expected, ep_char8_t *value)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return static_cast<ep_char8_t *>(InterlockedCompareExchangeT<ep_char8_t *> (target, value, expected));
-}
-/*
- * EventPipe.
- */
-EP_RT_DEFINE_ARRAY (session_id_array, ep_rt_session_id_array_t, ep_rt_session_id_array_iterator_t, EventPipeSessionID)
-EP_RT_DEFINE_ARRAY_ITERATOR (session_id_array, ep_rt_session_id_array_t, ep_rt_session_id_array_iterator_t, EventPipeSessionID)
-EP_RT_DEFINE_ARRAY (execution_checkpoint_array, ep_rt_execution_checkpoint_array_t, ep_rt_execution_checkpoint_array_iterator_t, EventPipeExecutionCheckpoint *)
-EP_RT_DEFINE_ARRAY_ITERATOR (execution_checkpoint_array, ep_rt_execution_checkpoint_array_t, ep_rt_execution_checkpoint_array_iterator_t, EventPipeExecutionCheckpoint *)
-static
-void
-ep_rt_init (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	extern ep_rt_lock_handle_t _ep_rt_coreclr_config_lock_handle;
-	extern CrstStatic _ep_rt_coreclr_config_lock;
-	_ep_rt_coreclr_config_lock_handle.lock = &_ep_rt_coreclr_config_lock;
-	_ep_rt_coreclr_config_lock_handle.lock->InitNoThrow (CrstEventPipe, (CrstFlags)(CRST_REENTRANCY | CRST_TAKEN_DURING_SHUTDOWN | CRST_HOST_BREAKABLE));
-	if (CLRConfig::GetConfigValue (CLRConfig::INTERNAL_EventPipeProcNumbers) != 0) {
-#ifndef TARGET_UNIX
-		uint16_t groups = ::GetActiveProcessorGroupCount ();
-		extern uint32_t *_ep_rt_coreclr_proc_group_offsets;
-		_ep_rt_coreclr_proc_group_offsets = new (nothrow) uint32_t [groups];
-		if (_ep_rt_coreclr_proc_group_offsets) {
-			uint32_t procs = 0;
-			for (uint16_t i = 0; i < procs; ++i) {
-				_ep_rt_coreclr_proc_group_offsets [i] = procs;
-				procs += GetActiveProcessorCount (i);
-			}
-		}
-#endif
-	}
-}
-static
-inline
-void
-ep_rt_init_finish (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-}
-static
-inline
-void
-ep_rt_shutdown (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-}
-static
-inline
-bool
-ep_rt_config_acquire (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return ep_rt_lock_acquire (ep_rt_coreclr_config_lock_get ());
-}
-static
-inline
-bool
-ep_rt_config_release (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return ep_rt_lock_release (ep_rt_coreclr_config_lock_get ());
-}
-#ifdef EP_CHECKED_BUILD
-static
-inline
-void
-ep_rt_config_requires_lock_held (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	ep_rt_lock_requires_lock_held (ep_rt_coreclr_config_lock_get ());
-}
-static
-inline
-void
-ep_rt_config_requires_lock_not_held (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	ep_rt_lock_requires_lock_not_held (ep_rt_coreclr_config_lock_get ());
-}
-#endif
-static
-inline
-bool
-ep_rt_walk_managed_stack_for_thread (
-	ep_rt_thread_handle_t thread,
-	EventPipeStackContents *stack_contents)
-{
-	STATIC_CONTRACT_NOTHROW;
-	extern bool ep_rt_coreclr_walk_managed_stack_for_thread (ep_rt_thread_handle_t thread, EventPipeStackContents *stack_contents);
-	return ep_rt_coreclr_walk_managed_stack_for_thread (thread, stack_contents);
-}
-static
-inline
-bool
-ep_rt_method_get_simple_assembly_name (
-	ep_rt_method_desc_t *method,
-	ep_char8_t *name,
-	size_t name_len)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (method != NULL);
-	EP_ASSERT (name != NULL);
-	const ep_char8_t *assembly_name = method->GetLoaderModule ()->GetAssembly ()->GetSimpleName ();
-	if (!assembly_name)
-		return false;
-	size_t assembly_name_len = strlen (assembly_name) + 1;
-	size_t to_copy = assembly_name_len < name_len ? assembly_name_len : name_len;
-	memcpy (name, assembly_name, to_copy);
-	name [to_copy - 1] = 0;
-	return true;
-}
-static
-bool
-ep_rt_method_get_full_name (
-	ep_rt_method_desc_t *method,
-	ep_char8_t *name,
-	size_t name_len)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (method != NULL);
-	EP_ASSERT (name != NULL);
-	bool result = true;
-	EX_TRY
-	{
-		SString method_name;
-		TypeString::AppendMethodInternal (method_name, method, TypeString::FormatNamespace | TypeString::FormatSignature);
-		const ep_char8_t *method_name_utf8 = method_name.GetUTF8 ();
-		if (method_name_utf8) {
-			size_t method_name_utf8_len = strlen (method_name_utf8) + 1;
-			size_t to_copy = method_name_utf8_len < name_len ? method_name_utf8_len : name_len;
-			memcpy (name, method_name_utf8, to_copy);
-			name [to_copy - 1] = 0;
-		} else {
-			result = false;
-		}
-	}
-	EX_CATCH
-	{
-		result = false;
-	}
-	EX_END_CATCH(SwallowAllExceptions);
-	return result;
-}
-static
-inline
-void
-ep_rt_provider_config_init (EventPipeProviderConfiguration *provider_config)
-{
-	STATIC_CONTRACT_NOTHROW;
-	if (!ep_rt_utf8_string_compare (ep_config_get_rundown_provider_name_utf8 (), ep_provider_config_get_provider_name (provider_config))) {
-		MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_DOTNET_Context.EventPipeProvider.Level = (UCHAR) ep_provider_config_get_logging_level (provider_config);
-		MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_DOTNET_Context.EventPipeProvider.EnabledKeywordsBitmask = ep_provider_config_get_keywords (provider_config);
-		MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_DOTNET_Context.EventPipeProvider.IsEnabled = true;
-	}
-}
-#ifdef TARGET_UNIX
-extern "C" void InitProvidersAndEvents ();
-#else
-extern void InitProvidersAndEvents ();
-#endif
-static
-void
-ep_rt_init_providers_and_events (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EX_TRY
-	{
-		InitProvidersAndEvents ();
-	}
-	EX_CATCH {}
-	EX_END_CATCH(SwallowAllExceptions);
-}
-static
-inline
-bool
-ep_rt_providers_validate_all_disabled (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return (!MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_DOTNET_Context.EventPipeProvider.IsEnabled &&
-		!MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_DOTNET_Context.EventPipeProvider.IsEnabled &&
-		!MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_DOTNET_Context.EventPipeProvider.IsEnabled);
-}
-static
-inline
-void
-ep_rt_prepare_provider_invoke_callback (EventPipeProviderCallbackData *provider_callback_data)
-{
-	STATIC_CONTRACT_NOTHROW;
-}
-static
-void
-ep_rt_provider_invoke_callback (
-	EventPipeCallback callback_func,
-	const uint8_t *source_id,
-	unsigned long is_enabled,
-	uint8_t level,
-	uint64_t match_any_keywords,
-	uint64_t match_all_keywords,
-	EventFilterDescriptor *filter_data,
-	void *callback_data)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (callback_func != NULL);
-	EX_TRY
-	{
-		(*callback_func)(
-			source_id,
-			is_enabled,
-			level,
-			match_any_keywords,
-			match_all_keywords,
-			filter_data,
-			callback_data);
-	}
-	EX_CATCH {}
-	EX_END_CATCH(SwallowAllExceptions);
-}
-/*
- * EventPipeBuffer.
- */
-EP_RT_DEFINE_ARRAY (buffer_array, ep_rt_buffer_array_t, ep_rt_buffer_array_iterator_t, EventPipeBuffer *)
-EP_RT_DEFINE_LOCAL_ARRAY (buffer_array, ep_rt_buffer_array_t, ep_rt_buffer_array_iterator_t, EventPipeBuffer *)
-EP_RT_DEFINE_ARRAY_ITERATOR (buffer_array, ep_rt_buffer_array_t, ep_rt_buffer_array_iterator_t, EventPipeBuffer *)
-#undef EP_RT_DECLARE_LOCAL_BUFFER_ARRAY
-#define EP_RT_DECLARE_LOCAL_BUFFER_ARRAY(var_name) \
-	EP_RT_DECLARE_LOCAL_ARRAY_VARIABLE(var_name, ep_rt_buffer_array_t)
-/*
- * EventPipeBufferList.
- */
-EP_RT_DEFINE_ARRAY (buffer_list_array, ep_rt_buffer_list_array_t, ep_rt_buffer_list_array_iterator_t, EventPipeBufferList *)
-EP_RT_DEFINE_LOCAL_ARRAY (buffer_list_array, ep_rt_buffer_list_array_t, ep_rt_buffer_list_array_iterator_t, EventPipeBufferList *)
-EP_RT_DEFINE_ARRAY_ITERATOR (buffer_list_array, ep_rt_buffer_list_array_t, ep_rt_buffer_list_array_iterator_t, EventPipeBufferList *)
-#undef EP_RT_DECLARE_LOCAL_BUFFER_LIST_ARRAY
-#define EP_RT_DECLARE_LOCAL_BUFFER_LIST_ARRAY(var_name) \
-	EP_RT_DECLARE_LOCAL_ARRAY_VARIABLE(var_name, ep_rt_buffer_list_array_t)
-/*
- * EventPipeEvent.
- */
-EP_RT_DEFINE_LIST (event_list, ep_rt_event_list_t, EventPipeEvent *)
-EP_RT_DEFINE_LIST_ITERATOR (event_list, ep_rt_event_list_t, ep_rt_event_list_iterator_t, EventPipeEvent *)
-/*
- * EventPipeFile.
- */
-EP_RT_DEFINE_HASH_MAP_REMOVE(metadata_labels_hash, ep_rt_metadata_labels_hash_map_t, EventPipeEvent *, uint32_t)
-EP_RT_DEFINE_HASH_MAP(stack_hash, ep_rt_stack_hash_map_t, StackHashKey *, StackHashEntry *)
-EP_RT_DEFINE_HASH_MAP_ITERATOR(stack_hash, ep_rt_stack_hash_map_t, ep_rt_stack_hash_map_iterator_t, StackHashKey *, StackHashEntry *)
-/*
- * EventPipeProvider.
- */
-EP_RT_DEFINE_LIST (provider_list, ep_rt_provider_list_t, EventPipeProvider *)
-EP_RT_DEFINE_LIST_ITERATOR (provider_list, ep_rt_provider_list_t, ep_rt_provider_list_iterator_t, EventPipeProvider *)
-EP_RT_DEFINE_QUEUE (provider_callback_data_queue, ep_rt_provider_callback_data_queue_t, EventPipeProviderCallbackData *)
-static
-EventPipeProvider *
-ep_rt_provider_list_find_by_name (
-	const ep_rt_provider_list_t *list,
-	const ep_char8_t *name)
-{
-	STATIC_CONTRACT_NOTHROW;
-	if (list) {
-		SList<SListElem<EventPipeProvider *>> *provider_list = list->list;
-		SListElem<EventPipeProvider *> *element = provider_list->GetHead ();
-		while (element) {
-			EventPipeProvider *provider = element->GetValue ();
-			if (ep_rt_utf8_string_compare (ep_provider_get_provider_name (element->GetValue ()), name) == 0)
-				return provider;
-			element = provider_list->GetNext (element);
-		}
-	}
-	return NULL;
-}
-/*
- * EventPipeProviderConfiguration.
- */
-EP_RT_DEFINE_ARRAY (provider_config_array, ep_rt_provider_config_array_t, ep_rt_provider_config_array_iterator_t, EventPipeProviderConfiguration)
-EP_RT_DEFINE_ARRAY_ITERATOR (provider_config_array, ep_rt_provider_config_array_t, ep_rt_provider_config_array_iterator_t, EventPipeProviderConfiguration)
-static
-inline
-bool
-ep_rt_config_value_get_enable (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return CLRConfig::GetConfigValue (CLRConfig::INTERNAL_EnableEventPipe) != 0;
-}
-static
-inline
-ep_char8_t *
-ep_rt_config_value_get_config (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	CLRConfigStringHolder value(CLRConfig::GetConfigValue (CLRConfig::INTERNAL_EventPipeConfig));
-	return ep_rt_utf16_to_utf8_string (reinterpret_cast<ep_char16_t *>(value.GetValue ()), -1);
-}
-static
-inline
-ep_char8_t *
-ep_rt_config_value_get_output_path (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	CLRConfigStringHolder value(CLRConfig::GetConfigValue (CLRConfig::INTERNAL_EventPipeOutputPath));
-	return ep_rt_utf16_to_utf8_string (reinterpret_cast<ep_char16_t *>(value.GetValue ()), -1);
-}
-static
-inline
-uint32_t
-ep_rt_config_value_get_circular_mb (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return CLRConfig::GetConfigValue (CLRConfig::INTERNAL_EventPipeCircularMB);
-}
-static
-inline
-bool
-ep_rt_config_value_get_output_streaming (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return CLRConfig::GetConfigValue (CLRConfig::INTERNAL_EventPipeOutputStreaming) != 0;
-}
-static
-inline
-bool
-ep_rt_config_value_get_use_portable_thread_pool (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return ThreadpoolMgr::UsePortableThreadPool ();
-}
-static
-inline
-bool
-ep_rt_config_value_get_enable_stackwalk (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return CLRConfig::GetConfigValue(CLRConfig::INTERNAL_EventPipeEnableStackwalk) != 0;
-}
-/*
- * EventPipeSampleProfiler.
- */
-static
-inline
-void
-ep_rt_sample_profiler_write_sampling_event_for_threads (
-	ep_rt_thread_handle_t sampling_thread,
-	EventPipeEvent *sampling_event)
-{
-	STATIC_CONTRACT_NOTHROW;
-	extern void ep_rt_coreclr_sample_profiler_write_sampling_event_for_threads (ep_rt_thread_handle_t sampling_thread, EventPipeEvent *sampling_event);
-	ep_rt_coreclr_sample_profiler_write_sampling_event_for_threads (sampling_thread, sampling_event);
-}
-static
-inline
-void
-ep_rt_notify_profiler_provider_created (EventPipeProvider *provider)
-{
-	STATIC_CONTRACT_NOTHROW;
-#ifndef DACCESS_COMPILE
-		BEGIN_PROFILER_CALLBACK (CORProfilerTrackEventPipe ());
-		(&g_profControlBlock)->EventPipeProviderCreated (provider);
-		END_PROFILER_CALLBACK ();
-#endif // DACCESS_COMPILE
-}
-/*
- * EventPipeSessionProvider.
- */
-EP_RT_DEFINE_LIST (session_provider_list, ep_rt_session_provider_list_t, EventPipeSessionProvider *)
-EP_RT_DEFINE_LIST_ITERATOR (session_provider_list, ep_rt_session_provider_list_t, ep_rt_session_provider_list_iterator_t, EventPipeSessionProvider *)
-static
-EventPipeSessionProvider *
-ep_rt_session_provider_list_find_by_name (
-	const ep_rt_session_provider_list_t *list,
-	const ep_char8_t *name)
-{
-	STATIC_CONTRACT_NOTHROW;
-	SList<SListElem<EventPipeSessionProvider *>> *provider_list = list->list;
-	EventPipeSessionProvider *session_provider = NULL;
-	SListElem<EventPipeSessionProvider *> *element = provider_list->GetHead ();
-	while (element) {
-		EventPipeSessionProvider *candidate = element->GetValue ();
-		if (ep_rt_utf8_string_compare (ep_session_provider_get_provider_name (candidate), name) == 0) {
-			session_provider = candidate;
-			break;
-		}
-		element = provider_list->GetNext (element);
-	}
-	return session_provider;
-}
-/*
- * EventPipeSequencePoint.
- */
-EP_RT_DEFINE_LIST (sequence_point_list, ep_rt_sequence_point_list_t, EventPipeSequencePoint *)
-EP_RT_DEFINE_LIST_ITERATOR (sequence_point_list, ep_rt_sequence_point_list_t, ep_rt_sequence_point_list_iterator_t, EventPipeSequencePoint *)
-/*
- * EventPipeThread.
- */
-EP_RT_DEFINE_LIST (thread_list, ep_rt_thread_list_t, EventPipeThread *)
-EP_RT_DEFINE_LIST_ITERATOR (thread_list, ep_rt_thread_list_t, ep_rt_thread_list_iterator_t, EventPipeThread *)
-EP_RT_DEFINE_ARRAY (thread_array, ep_rt_thread_array_t, ep_rt_thread_array_iterator_t, EventPipeThread *)
-EP_RT_DEFINE_LOCAL_ARRAY (thread_array, ep_rt_thread_array_t, ep_rt_thread_array_iterator_t, EventPipeThread *)
-EP_RT_DEFINE_ARRAY_ITERATOR (thread_array, ep_rt_thread_array_t, ep_rt_thread_array_iterator_t, EventPipeThread *)
-#undef EP_RT_DECLARE_LOCAL_THREAD_ARRAY
-#define EP_RT_DECLARE_LOCAL_THREAD_ARRAY(var_name) \
-	EP_RT_DECLARE_LOCAL_ARRAY_VARIABLE(var_name, ep_rt_thread_array_t)
-/*
- * EventPipeThreadSessionState.
- */
-EP_RT_DEFINE_LIST (thread_session_state_list, ep_rt_thread_session_state_list_t, EventPipeThreadSessionState *)
-EP_RT_DEFINE_LIST_ITERATOR (thread_session_state_list, ep_rt_thread_session_state_list_t, ep_rt_thread_session_state_list_iterator_t, EventPipeThreadSessionState *)
-EP_RT_DEFINE_ARRAY (thread_session_state_array, ep_rt_thread_session_state_array_t, ep_rt_thread_session_state_array_iterator_t, EventPipeThreadSessionState *)
-EP_RT_DEFINE_LOCAL_ARRAY (thread_session_state_array, ep_rt_thread_session_state_array_t, ep_rt_thread_session_state_array_iterator_t, EventPipeThreadSessionState *)
-EP_RT_DEFINE_ARRAY_ITERATOR (thread_session_state_array, ep_rt_thread_session_state_array_t, ep_rt_thread_session_state_array_iterator_t, EventPipeThreadSessionState *)
-#undef EP_RT_DECLARE_LOCAL_THREAD_SESSION_STATE_ARRAY
-#define EP_RT_DECLARE_LOCAL_THREAD_SESSION_STATE_ARRAY(var_name) \
-	EP_RT_DECLARE_LOCAL_ARRAY_VARIABLE(var_name, ep_rt_thread_session_state_array_t)
-/*
- * Arrays.
- */
-static
-inline
-uint8_t *
-ep_rt_byte_array_alloc (size_t len)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return new (nothrow) uint8_t [len];
-}
-static
-inline
-void
-ep_rt_byte_array_free (uint8_t *ptr)
-{
-	STATIC_CONTRACT_NOTHROW;
-	if (ptr)
-		delete [] ptr;
-}
-/*
- * Event.
- */
-static
-void
-ep_rt_wait_event_alloc (
-	ep_rt_wait_event_handle_t *wait_event,
-	bool manual,
-	bool initial)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (wait_event != NULL);
-	EP_ASSERT (wait_event->event == NULL);
-	wait_event->event = new (nothrow) CLREventStatic ();
-	if (wait_event->event) {
-		EX_TRY
-		{
-			if (manual)
-				wait_event->event->CreateManualEvent (initial);
-			else
-				wait_event->event->CreateAutoEvent (initial);
-		}
-		EX_CATCH {}
-		EX_END_CATCH(SwallowAllExceptions);
-	}
-}
-static
-inline
-void
-ep_rt_wait_event_free (ep_rt_wait_event_handle_t *wait_event)
-{
-	STATIC_CONTRACT_NOTHROW;
-	if (wait_event != NULL && wait_event->event != NULL) {
-		wait_event->event->CloseEvent ();
-		delete wait_event->event;
-		wait_event->event = NULL;
-	}
-}
-static
-inline
-bool
-ep_rt_wait_event_set (ep_rt_wait_event_handle_t *wait_event)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (wait_event != NULL && wait_event->event != NULL);
-	return wait_event->event->Set ();
-}
-static
-int32_t
-ep_rt_wait_event_wait (
-	ep_rt_wait_event_handle_t *wait_event,
-	uint32_t timeout,
-	bool alertable)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (wait_event != NULL && wait_event->event != NULL);
-	int32_t result;
-	EX_TRY
-	{
-		result = wait_event->event->Wait (timeout, alertable);
-	}
-	EX_CATCH
-	{
-		result = -1;
-	}
-	EX_END_CATCH(SwallowAllExceptions);
-	return result;
-}
-static
-inline
-EventPipeWaitHandle
-ep_rt_wait_event_get_wait_handle (ep_rt_wait_event_handle_t *wait_event)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (wait_event != NULL && wait_event->event != NULL);
-	return reinterpret_cast<EventPipeWaitHandle>(wait_event->event->GetHandleUNHOSTED ());
-}
-static
-inline
-bool
-ep_rt_wait_event_is_valid (ep_rt_wait_event_handle_t *wait_event)
-{
-	STATIC_CONTRACT_NOTHROW;
-	if (wait_event == NULL || wait_event->event == NULL)
-		return false;
-	return wait_event->event->IsValid ();
-}
-/*
- * Misc.
- */
-static
-inline
-int
-ep_rt_get_last_error (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return ::GetLastError ();
-}
-static
-inline
-bool
-ep_rt_process_detach (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return (bool)g_fProcessDetach;
-}
-static
-inline
-bool
-ep_rt_process_shutdown (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return (bool)g_fEEShutDown;
-}
-static
-inline
-void
-ep_rt_create_activity_id (
-	uint8_t *activity_id,
-	uint32_t activity_id_len)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (activity_id != NULL);
-	EP_ASSERT (activity_id_len == EP_ACTIVITY_ID_SIZE);
-	CoCreateGuid (reinterpret_cast<GUID *>(activity_id));
-}
-static
-inline
-bool
-ep_rt_is_running (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return (bool)g_fEEStarted;
-}
-static
-inline
-void
-ep_rt_execute_rundown (ep_rt_execution_checkpoint_array_t *execution_checkpoints)
-{
-	STATIC_CONTRACT_NOTHROW;
-	if (CLRConfig::GetConfigValue (CLRConfig::INTERNAL_EventPipeRundown) > 0) {
-		if (g_fEEStarted && !g_fEEShutDown)
-			ETW::EnumerationLog::EndRundown ();
-	}
-}
-/*
- * Objects.
- */
-#undef ep_rt_object_alloc
-#define ep_rt_object_alloc(obj_type) (new (nothrow) obj_type())
-#undef ep_rt_object_array_alloc
-#define ep_rt_object_array_alloc(obj_type,size) (new (nothrow) obj_type [size]())
-#undef ep_rt_object_array_free
-#define ep_rt_object_array_free(obj_ptr) do { if (obj_ptr) delete [] obj_ptr; } while(0)
-#undef ep_rt_object_free
-#define ep_rt_object_free(obj_ptr) do { if (obj_ptr) delete obj_ptr; } while(0)
-/*
- * PAL.
- */
-typedef struct _rt_coreclr_thread_params_internal_t {
-	ep_rt_thread_params_t thread_params;
-} rt_coreclr_thread_params_internal_t;
-#undef EP_RT_DEFINE_THREAD_FUNC
-#define EP_RT_DEFINE_THREAD_FUNC(name) static ep_rt_thread_start_func_return_t WINAPI name (LPVOID data)
-EP_RT_DEFINE_THREAD_FUNC (ep_rt_thread_coreclr_start_func)
-{
-	STATIC_CONTRACT_NOTHROW;
-	rt_coreclr_thread_params_internal_t *thread_params = reinterpret_cast<rt_coreclr_thread_params_internal_t *>(data);
-	DWORD result = thread_params->thread_params.thread_func (thread_params);
-	if (thread_params->thread_params.thread)
-		::DestroyThread (thread_params->thread_params.thread);
-	delete thread_params;
-	return result;
-}
-static
-bool
-ep_rt_thread_create (
-	void *thread_func,
-	void *params,
-	EventPipeThreadType thread_type,
-	void *id)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (thread_func != NULL);
-	bool result = false;
-	EX_TRY
-	{
-		rt_coreclr_thread_params_internal_t *thread_params = new (nothrow) rt_coreclr_thread_params_internal_t ();
-		if (thread_params) {
-			thread_params->thread_params.thread_type = thread_type;
-			if (thread_type == EP_THREAD_TYPE_SESSION || thread_type == EP_THREAD_TYPE_SAMPLING) {
-				thread_params->thread_params.thread = SetupUnstartedThread ();
-				thread_params->thread_params.thread_func = reinterpret_cast<LPTHREAD_START_ROUTINE>(thread_func);
-				thread_params->thread_params.thread_params = params;
-				if (thread_params->thread_params.thread->CreateNewThread (0, ep_rt_thread_coreclr_start_func, thread_params)) {
-					thread_params->thread_params.thread->SetBackground (TRUE);
-					thread_params->thread_params.thread->StartThread ();
-					if (id)
-						*reinterpret_cast<DWORD *>(id) = thread_params->thread_params.thread->GetThreadId ();
-					result = true;
-				}
-			} else if (thread_type == EP_THREAD_TYPE_SERVER) {
-				DWORD thread_id = 0;
-				HANDLE server_thread = ::CreateThread (nullptr, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(thread_func), nullptr, 0, &thread_id);
-				if (server_thread != NULL) {
-					::CloseHandle (server_thread);
-					if (id)
-						*reinterpret_cast<DWORD *>(id) = thread_id;
-					result = true;
-				}
-			}
-		}
-	}
-	EX_CATCH
-	{
-		result = false;
-	}
-	EX_END_CATCH(SwallowAllExceptions);
-	return result;
-}
-static
-inline
-void
-ep_rt_thread_sleep (uint64_t ns)
-{
-	STATIC_CONTRACT_NOTHROW;
-#ifdef TARGET_UNIX
-	PAL_nanosleep (ns);
-#else  //TARGET_UNIX
-	const uint32_t NUM_NANOSECONDS_IN_1_MS = 1000000;
-	ClrSleepEx (static_cast<DWORD>(ns / NUM_NANOSECONDS_IN_1_MS), FALSE);
-#endif //TARGET_UNIX
-}
-static
-inline
-uint32_t
-ep_rt_current_process_get_id (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return static_cast<uint32_t>(GetCurrentProcessId ());
-}
-static
-inline
-uint32_t
-ep_rt_current_processor_get_number (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-#ifndef TARGET_UNIX
-	extern uint32_t *_ep_rt_coreclr_proc_group_offsets;
-	if (_ep_rt_coreclr_proc_group_offsets) {
-		PROCESSOR_NUMBER proc;
-		GetCurrentProcessorNumberEx (&proc);
-		return _ep_rt_coreclr_proc_group_offsets [proc.Group] + proc.Number;
-	}
-#endif
-	return 0xFFFFFFFF;
-}
-static
-inline
-uint32_t
-ep_rt_processors_get_count (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	SYSTEM_INFO sys_info = {};
-	GetSystemInfo (&sys_info);
-	return static_cast<uint32_t>(sys_info.dwNumberOfProcessors);
-}
-static
-inline
-ep_rt_thread_id_t
-ep_rt_current_thread_get_id (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-#ifdef TARGET_UNIX
-	return static_cast<ep_rt_thread_id_t>(::PAL_GetCurrentOSThreadId ());
-#else
-	return static_cast<ep_rt_thread_id_t>(::GetCurrentThreadId ());
-#endif
-}
-static
-inline
-int64_t
-ep_rt_perf_counter_query (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	LARGE_INTEGER value;
-	if (QueryPerformanceCounter (&value))
-		return static_cast<int64_t>(value.QuadPart);
-	else
-		return 0;
-}
-static
-inline
-int64_t
-ep_rt_perf_frequency_query (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	LARGE_INTEGER value;
-	if (QueryPerformanceFrequency (&value))
-		return static_cast<int64_t>(value.QuadPart);
-	else
-		return 0;
-}
-static
-inline
-void
-ep_rt_system_time_get (EventPipeSystemTime *system_time)
-{
-	STATIC_CONTRACT_NOTHROW;
-	SYSTEMTIME value;
-	GetSystemTime (&value);
-	EP_ASSERT(system_time != NULL);
-	ep_system_time_set (
-		system_time,
-		value.wYear,
-		value.wMonth,
-		value.wDayOfWeek,
-		value.wDay,
-		value.wHour,
-		value.wMinute,
-		value.wSecond,
-		value.wMilliseconds);
-}
-static
-inline
-int64_t
-ep_rt_system_timestamp_get (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	FILETIME value;
-	GetSystemTimeAsFileTime (&value);
-	return static_cast<int64_t>(((static_cast<uint64_t>(value.dwHighDateTime)) << 32) | static_cast<uint64_t>(value.dwLowDateTime));
-}
-static
-inline
-int32_t
-ep_rt_system_get_alloc_granularity (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return static_cast<int32_t>(g_SystemInfo.dwAllocationGranularity);
-}
-static
-inline
-const ep_char8_t *
-ep_rt_os_command_line_get (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_UNREACHABLE ("Can not reach here");
-	return NULL;
-}
-static
-ep_rt_file_handle_t
-ep_rt_file_open_write (const ep_char8_t *path)
-{
-	STATIC_CONTRACT_NOTHROW;
-	ep_char16_t *path_utf16 = ep_rt_utf8_to_utf16le_string (path, -1);
-	ep_return_null_if_nok (path_utf16 != NULL);
-	CFileStream *file_stream = new (nothrow) CFileStream ();
-	if (file_stream && FAILED (file_stream->OpenForWrite (reinterpret_cast<LPWSTR>(path_utf16)))) {
-		delete file_stream;
-		file_stream = NULL;
-	}
-	ep_rt_utf16_string_free (path_utf16);
-	return static_cast<ep_rt_file_handle_t>(file_stream);
-}
-static
-inline
-bool
-ep_rt_file_close (ep_rt_file_handle_t file_handle)
-{
-	STATIC_CONTRACT_NOTHROW;
-	if (file_handle)
-		delete file_handle;
-	return true;
-}
-static
-inline
-bool
-ep_rt_file_write (
-	ep_rt_file_handle_t file_handle,
-	const uint8_t *buffer,
-	uint32_t bytes_to_write,
-	uint32_t *bytes_written)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (buffer != NULL);
-	ep_return_false_if_nok (file_handle != NULL);
-	ULONG out_count;
-	HRESULT result = reinterpret_cast<CFileStream *>(file_handle)->Write (buffer, bytes_to_write, &out_count);
-	*bytes_written = static_cast<uint32_t>(out_count);
-	return result == S_OK;
-}
-static
-inline
-uint8_t *
-ep_rt_valloc0 (size_t buffer_size)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return reinterpret_cast<uint8_t *>(ClrVirtualAlloc (NULL, buffer_size, MEM_COMMIT, PAGE_READWRITE));
-}
-static
-inline
-void
-ep_rt_vfree (
-	uint8_t *buffer,
-	size_t buffer_size)
-{
-	STATIC_CONTRACT_NOTHROW;
-	if (buffer)
-		ClrVirtualFree (buffer, 0, MEM_RELEASE);
-}
-static
-inline
-uint32_t
-ep_rt_temp_path_get (
-	ep_char8_t *buffer,
-	uint32_t buffer_len)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_UNREACHABLE ("Can not reach here");
-	return 0;
-}
-EP_RT_DEFINE_ARRAY (env_array_utf16, ep_rt_env_array_utf16_t, ep_rt_env_array_utf16_iterator_t, ep_char16_t *)
-EP_RT_DEFINE_ARRAY_ITERATOR (env_array_utf16, ep_rt_env_array_utf16_t, ep_rt_env_array_utf16_iterator_t, ep_char16_t *)
-static
-void
-ep_rt_os_environment_get_utf16 (ep_rt_env_array_utf16_t *env_array)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (env_array != NULL);
-	LPWSTR envs = GetEnvironmentStringsW ();
-	if (envs) {
-		LPWSTR next = envs;
-		while (*next) {
-			ep_rt_env_array_utf16_append (env_array, ep_rt_utf16_string_dup (reinterpret_cast<const ep_char16_t *>(next)));
-			next += ep_rt_utf16_string_len (reinterpret_cast<const ep_char16_t *>(next)) + 1;
-		}
-		FreeEnvironmentStringsW (envs);
-	}
-}
-/*
-* Lock.
-*/
-static
-bool
-ep_rt_lock_acquire (ep_rt_lock_handle_t *lock)
-{
-	STATIC_CONTRACT_NOTHROW;
-	bool result = true;
-	EX_TRY
-	{
-		if (lock) {
-			CrstBase::CrstHolderWithState holder (lock->lock);
-			holder.SuppressRelease ();
-		}
-	}
-	EX_CATCH
-	{
-		result = false;
-	}
-	EX_END_CATCH(SwallowAllExceptions);
-	return result;
-}
-static
-bool
-ep_rt_lock_release (ep_rt_lock_handle_t *lock)
-{
-	STATIC_CONTRACT_NOTHROW;
-	bool result = true;
-	EX_TRY
-	{
-		if (lock) {
-			CrstBase::UnsafeCrstInverseHolder holder (lock->lock);
-			holder.SuppressRelease ();
-		}
-	}
-	EX_CATCH
-	{
-		result = false;
-	}
-	EX_END_CATCH(SwallowAllExceptions);
-	return result;
-}
-#ifdef EP_CHECKED_BUILD
-static
-inline
-void
-ep_rt_lock_requires_lock_held (const ep_rt_lock_handle_t *lock)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (((ep_rt_lock_handle_t *)lock)->lock->OwnedByCurrentThread ());
-}
-static
-inline
-void
-ep_rt_lock_requires_lock_not_held (const ep_rt_lock_handle_t *lock)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (lock->lock == NULL || !((ep_rt_lock_handle_t *)lock)->lock->OwnedByCurrentThread ());
-}
-#endif
-/*
-* SpinLock.
-*/
-static
-void
-ep_rt_spin_lock_alloc (ep_rt_spin_lock_handle_t *spin_lock)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EX_TRY
-	{
-		spin_lock->lock = new (nothrow) SpinLock ();
-		spin_lock->lock->Init (LOCK_TYPE_DEFAULT);
-	}
-	EX_CATCH {}
-	EX_END_CATCH(SwallowAllExceptions);
-}
-static
-inline
-void
-ep_rt_spin_lock_free (ep_rt_spin_lock_handle_t *spin_lock)
-{
-	STATIC_CONTRACT_NOTHROW;
-	if (spin_lock && spin_lock->lock) {
-		delete spin_lock->lock;
-		spin_lock->lock = NULL;
-	}
-}
-static
-inline
-bool
-ep_rt_spin_lock_acquire (ep_rt_spin_lock_handle_t *spin_lock)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (ep_rt_spin_lock_is_valid (spin_lock));
-	SpinLock::AcquireLock (spin_lock->lock);
-	return true;
-}
-static
-inline
-bool
-ep_rt_spin_lock_release (ep_rt_spin_lock_handle_t *spin_lock)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (ep_rt_spin_lock_is_valid (spin_lock));
-	SpinLock::ReleaseLock (spin_lock->lock);
-	return true;
-}
-#ifdef EP_CHECKED_BUILD
-static
-inline
-void
-ep_rt_spin_lock_requires_lock_held (const ep_rt_spin_lock_handle_t *spin_lock)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (ep_rt_spin_lock_is_valid (spin_lock));
-	EP_ASSERT (spin_lock->lock->OwnedByCurrentThread ());
-}
-static
-inline
-void
-ep_rt_spin_lock_requires_lock_not_held (const ep_rt_spin_lock_handle_t *spin_lock)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (spin_lock->lock == NULL || !spin_lock->lock->OwnedByCurrentThread ());
-}
-#endif
-static
-inline
-bool
-ep_rt_spin_lock_is_valid (const ep_rt_spin_lock_handle_t *spin_lock)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return (spin_lock != NULL && spin_lock->lock != NULL);
-}
-/*
- * String.
- */
-static
-inline
-int
-ep_rt_utf8_string_compare (
-	const ep_char8_t *str1,
-	const ep_char8_t *str2)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (str1 != NULL && str2 != NULL);
-	return strcmp (reinterpret_cast<const char *>(str1), reinterpret_cast<const char *>(str2));
-}
-static
-inline
-int
-ep_rt_utf8_string_compare_ignore_case (
-	const ep_char8_t *str1,
-	const ep_char8_t *str2)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (str1 != NULL && str2 != NULL);
-	return _stricmp (reinterpret_cast<const char *>(str1), reinterpret_cast<const char *>(str2));
-}
-static
-inline
-bool
-ep_rt_utf8_string_is_null_or_empty (const ep_char8_t *str)
-{
-	STATIC_CONTRACT_NOTHROW;
-	if (str == NULL)
-		return true;
-	while (*str) {
-		if (!isspace (*str))
-			return false;
-		str++;
-	}
-	return true;
-}
-static
-inline
-ep_char8_t *
-ep_rt_utf8_string_dup (const ep_char8_t *str)
-{
-	STATIC_CONTRACT_NOTHROW;
-	if (!str)
-		return NULL;
-	return _strdup (str);
-}
-static
-inline
-ep_char8_t *
-ep_rt_utf8_string_dup_range (const ep_char8_t *str, const ep_char8_t *strEnd)
-{
-	ptrdiff_t byte_len = strEnd - str;
-	ep_char8_t *buffer = reinterpret_cast<ep_char8_t *>(malloc(byte_len + 1));
-	if (buffer != NULL)
-	{
-		memcpy (buffer, str, byte_len);
-		buffer [byte_len] = '\0';
-	}
-	return buffer;
-}
-static
-inline
-ep_char8_t *
-ep_rt_utf8_string_strtok (
-	ep_char8_t *str,
-	const ep_char8_t *delimiter,
-	ep_char8_t **context)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return strtok_s (str, delimiter, context);
-}
-#undef ep_rt_utf8_string_snprintf
-#define ep_rt_utf8_string_snprintf( \
-	str, \
-	str_len, \
-	format, ...) \
-sprintf_s (reinterpret_cast<char *>(str), static_cast<size_t>(str_len), reinterpret_cast<const char *>(format), __VA_ARGS__)
-static
-inline
-bool
-ep_rt_utf8_string_replace (
-	ep_char8_t **str,
-	const ep_char8_t *strSearch,
-	const ep_char8_t *strReplacement
-)
-{
-	STATIC_CONTRACT_NOTHROW;
-	if ((*str) == NULL)
-		return false;
-	ep_char8_t* strFound = strstr(*str, strSearch);
-	if (strFound != NULL)
-	{
-		size_t strSearchLen = strlen(strSearch);
-		size_t newStrSize = strlen(*str) + strlen(strReplacement) - strSearchLen + 1;
-		ep_char8_t *newStr =  reinterpret_cast<ep_char8_t *>(malloc(newStrSize));
-		if (newStr == NULL)
-		{
-			*str = NULL;
-			return false;
-		}
-		ep_rt_utf8_string_snprintf(newStr, newStrSize, "%.*s%s%s", (int)(strFound - (*str)), *str, strReplacement, strFound + strSearchLen);
-		ep_rt_utf8_string_free(*str);
-		*str = newStr;
-		return true;
-	}
-	return false;
-}
-static
-ep_char16_t *
-ep_rt_utf8_to_utf16le_string (
-	const ep_char8_t *str,
-	size_t len)
-{
-	STATIC_CONTRACT_NOTHROW;
-	if (!str)
-		return NULL;
-	COUNT_T len_utf16 = WszMultiByteToWideChar (CP_UTF8, 0, str, static_cast<int>(len), 0, 0);
-	if (len_utf16 == 0)
-		return NULL;
-	if (static_cast<int>(len) != -1)
-		len_utf16 += 1;
-	ep_char16_t *str_utf16 = reinterpret_cast<ep_char16_t *>(malloc (len_utf16 * sizeof (ep_char16_t)));
-	if (!str_utf16)
-		return NULL;
-	len_utf16 = WszMultiByteToWideChar (CP_UTF8, 0, str, static_cast<int>(len), reinterpret_cast<LPWSTR>(str_utf16), len_utf16);
-	if (len_utf16 == 0) {
-		free (str_utf16);
-		return NULL;
-	}
-	str_utf16 [len_utf16 - 1] = 0;
-	return str_utf16;
-}
-static
-inline
-ep_char16_t *
-ep_rt_utf16_string_dup (const ep_char16_t *str)
-{
-	STATIC_CONTRACT_NOTHROW;
-	if (!str)
-		return NULL;
-	size_t str_size = (ep_rt_utf16_string_len (str) + 1) * sizeof (ep_char16_t);
-	ep_char16_t *str_dup = reinterpret_cast<ep_char16_t *>(malloc (str_size));
-	if (str_dup)
-		memcpy (str_dup, str, str_size);
-	return str_dup;
-}
-static
-inline
-void
-ep_rt_utf8_string_free (ep_char8_t *str)
-{
-	STATIC_CONTRACT_NOTHROW;
-	if (str)
-		free (str);
-}
-static
-inline
-size_t
-ep_rt_utf16_string_len (const ep_char16_t *str)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (str != NULL);
-	return wcslen (reinterpret_cast<LPCWSTR>(str));
-}
-static
-ep_char8_t *
-ep_rt_utf16_to_utf8_string (
-	const ep_char16_t *str,
-	size_t len)
-{
-	STATIC_CONTRACT_NOTHROW;
-	if (!str)
-		return NULL;
-	COUNT_T size_utf8 = WszWideCharToMultiByte (CP_UTF8, 0, reinterpret_cast<LPCWSTR>(str), static_cast<int>(len), NULL, 0, NULL, NULL);
-	if (size_utf8 == 0)
-		return NULL;
-	if (static_cast<int>(len) != -1)
-		size_utf8 += 1;
-	ep_char8_t *str_utf8 = reinterpret_cast<ep_char8_t *>(malloc (size_utf8));
-	if (!str_utf8)
-		return NULL;
-	size_utf8 = WszWideCharToMultiByte (CP_UTF8, 0, reinterpret_cast<LPCWSTR>(str), static_cast<int>(len), reinterpret_cast<LPSTR>(str_utf8), size_utf8, NULL, NULL);
-	if (size_utf8 == 0) {
-		free (str_utf8);
-		return NULL;
-	}
-	str_utf8 [size_utf8 - 1] = 0;
-	return str_utf8;
-}
-static
-inline
-ep_char8_t *
-ep_rt_utf16le_to_utf8_string (
-	const ep_char16_t *str,
-	size_t len)
-{
-	return ep_rt_utf16_to_utf8_string (str, len);
-}
-static
-inline
-void
-ep_rt_utf16_string_free (ep_char16_t *str)
-{
-	STATIC_CONTRACT_NOTHROW;
-	if (str)
-		free (str);
-}
-static
-inline
-const ep_char8_t *
-ep_rt_managed_command_line_get (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_UNREACHABLE ("Can not reach here");
-	return NULL;
-}
-static
-const ep_char8_t *
-ep_rt_diagnostics_command_line_get (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	extern ep_char8_t *volatile _ep_rt_coreclr_diagnostics_cmd_line;
-	ep_char8_t *old_cmd_line = _ep_rt_coreclr_diagnostics_cmd_line;
-	ep_char8_t *new_cmd_line = ep_rt_utf16_to_utf8_string (reinterpret_cast<const ep_char16_t *>(GetCommandLineForDiagnostics ()), -1);
-	if (old_cmd_line && ep_rt_utf8_string_compare (old_cmd_line, new_cmd_line) == 0) {
-		ep_rt_utf8_string_free (new_cmd_line);
-	} else {
-		if (ep_rt_atomic_compare_exchange_utf8_string (&_ep_rt_coreclr_diagnostics_cmd_line, old_cmd_line, new_cmd_line) != old_cmd_line) {
-			ep_rt_utf8_string_free (new_cmd_line);
-		}
-	}
-	return _ep_rt_coreclr_diagnostics_cmd_line;
-}
-/*
- * Thread.
- */
-static
-inline
-EventPipeThreadHolder *
-thread_holder_alloc_func (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EventPipeThreadHolder *instance = ep_thread_holder_alloc (ep_thread_alloc());
-	if (instance)
-		ep_thread_register (ep_thread_holder_get_thread (instance));
-	return instance;
-}
-static
-inline
-void
-thread_holder_free_func (EventPipeThreadHolder * thread_holder)
-{
-	STATIC_CONTRACT_NOTHROW;
-	if (thread_holder) {
-		ep_thread_unregister (ep_thread_holder_get_thread (thread_holder));
-		ep_thread_holder_free (thread_holder);
-	}
-}
-class EventPipeCoreCLRThreadHolderTLS {
-public:
-	EventPipeCoreCLRThreadHolderTLS ()
-	{
-		STATIC_CONTRACT_NOTHROW;
-	}
-	~EventPipeCoreCLRThreadHolderTLS ()
-	{
-		STATIC_CONTRACT_NOTHROW;
-		if (m_threadHolder) {
-			thread_holder_free_func (m_threadHolder);
-			m_threadHolder = NULL;
-		}
-	}
-	static inline EventPipeThreadHolder * getThreadHolder ()
-	{
-		STATIC_CONTRACT_NOTHROW;
-		return g_threadHolderTLS.m_threadHolder;
-	}
-	static inline EventPipeThreadHolder * createThreadHolder ()
-	{
-		STATIC_CONTRACT_NOTHROW;
-		if (g_threadHolderTLS.m_threadHolder) {
-			thread_holder_free_func (g_threadHolderTLS.m_threadHolder);
-			g_threadHolderTLS.m_threadHolder = NULL;
-		}
-		g_threadHolderTLS.m_threadHolder = thread_holder_alloc_func ();
-		return g_threadHolderTLS.m_threadHolder;
-	}
-private:
-	EventPipeThreadHolder *m_threadHolder;
-	static thread_local EventPipeCoreCLRThreadHolderTLS g_threadHolderTLS;
-};
-static
-void
-ep_rt_thread_setup (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	Thread* thread_handle = SetupThreadNoThrow ();
-	EP_ASSERT (thread_handle != NULL);
-}
-static
-inline
-EventPipeThread *
-ep_rt_thread_get (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EventPipeThreadHolder *thread_holder = EventPipeCoreCLRThreadHolderTLS::getThreadHolder ();
-	return thread_holder ? ep_thread_holder_get_thread (thread_holder) : NULL;
-}
-static
-inline
-EventPipeThread *
-ep_rt_thread_get_or_create (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EventPipeThreadHolder *thread_holder = EventPipeCoreCLRThreadHolderTLS::getThreadHolder ();
-	if (!thread_holder)
-		thread_holder = EventPipeCoreCLRThreadHolderTLS::createThreadHolder ();
-	return ep_thread_holder_get_thread (thread_holder);
-}
-static
-inline
-ep_rt_thread_handle_t
-ep_rt_thread_get_handle (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return GetThreadNULLOk ();
-}
-static
-inline
-ep_rt_thread_id_t
-ep_rt_thread_get_id (ep_rt_thread_handle_t thread_handle)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (thread_handle != NULL);
-	return ep_rt_uint64_t_to_thread_id_t (thread_handle->GetOSThreadId64 ());
-}
-static
-inline
-uint64_t
-ep_rt_thread_id_t_to_uint64_t (ep_rt_thread_id_t thread_id)
-{
-	return static_cast<uint64_t>(thread_id);
-}
-static
-inline
-ep_rt_thread_id_t
-ep_rt_uint64_t_to_thread_id_t (uint64_t thread_id)
-{
-	return static_cast<ep_rt_thread_id_t>(thread_id);
-}
-static
-inline
-bool
-ep_rt_thread_has_started (ep_rt_thread_handle_t thread_handle)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return thread_handle != NULL && thread_handle->HasStarted ();
-}
-static
-inline
-ep_rt_thread_activity_id_handle_t
-ep_rt_thread_get_activity_id_handle (void)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return GetThread ();
-}
-static
-inline
-const uint8_t *
-ep_rt_thread_get_activity_id_cref (ep_rt_thread_activity_id_handle_t activity_id_handle)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (activity_id_handle != NULL);
-	return reinterpret_cast<const uint8_t *>(activity_id_handle->GetActivityId ());
-}
-static
-inline
-void
-ep_rt_thread_get_activity_id (
-	ep_rt_thread_activity_id_handle_t activity_id_handle,
-	uint8_t *activity_id,
-	uint32_t activity_id_len)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (activity_id_handle != NULL);
-	EP_ASSERT (activity_id != NULL);
-	EP_ASSERT (activity_id_len == EP_ACTIVITY_ID_SIZE);
-	memcpy (activity_id, ep_rt_thread_get_activity_id_cref (activity_id_handle), EP_ACTIVITY_ID_SIZE);
-}
-static
-inline
-void
-ep_rt_thread_set_activity_id (
-	ep_rt_thread_activity_id_handle_t activity_id_handle,
-	const uint8_t *activity_id,
-	uint32_t activity_id_len)
-{
-	STATIC_CONTRACT_NOTHROW;
-	EP_ASSERT (activity_id_handle != NULL);
-	EP_ASSERT (activity_id != NULL);
-	EP_ASSERT (activity_id_len == EP_ACTIVITY_ID_SIZE);
-	activity_id_handle->SetActivityId (reinterpret_cast<LPCGUID>(activity_id));
-}
-#undef EP_YIELD_WHILE
-#define EP_YIELD_WHILE(condition) YIELD_WHILE(condition)
-/*
- * ThreadSequenceNumberMap.
- */
-EP_RT_DEFINE_HASH_MAP_REMOVE(thread_sequence_number_map, ep_rt_thread_sequence_number_hash_map_t, EventPipeThreadSessionState *, uint32_t)
-EP_RT_DEFINE_HASH_MAP_ITERATOR(thread_sequence_number_map, ep_rt_thread_sequence_number_hash_map_t, ep_rt_thread_sequence_number_hash_map_iterator_t, EventPipeThreadSessionState *, uint32_t)
-/*
- * Volatile.
- */
-static
-inline
-uint32_t
-ep_rt_volatile_load_uint32_t (const volatile uint32_t *ptr)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return VolatileLoad<uint32_t> ((const uint32_t *)ptr);
-}
-static
-inline
-uint32_t
-ep_rt_volatile_load_uint32_t_without_barrier (const volatile uint32_t *ptr)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return VolatileLoadWithoutBarrier<uint32_t> ((const uint32_t *)ptr);
-}
-static
-inline
-void
-ep_rt_volatile_store_uint32_t (
-	volatile uint32_t *ptr,
-	uint32_t value)
-{
-	STATIC_CONTRACT_NOTHROW;
-	VolatileStore<uint32_t> ((uint32_t *)ptr, value);
-}
-static
-inline
-void
-ep_rt_volatile_store_uint32_t_without_barrier (
-	volatile uint32_t *ptr,
-	uint32_t value)
-{
-	STATIC_CONTRACT_NOTHROW;
-	VolatileStoreWithoutBarrier<uint32_t>((uint32_t *)ptr, value);
-}
-static
-inline
-uint64_t
-ep_rt_volatile_load_uint64_t (const volatile uint64_t *ptr)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return VolatileLoad<uint64_t> ((const uint64_t *)ptr);
-}
-static
-inline
-uint64_t
-ep_rt_volatile_load_uint64_t_without_barrier (const volatile uint64_t *ptr)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return VolatileLoadWithoutBarrier<uint64_t> ((const uint64_t *)ptr);
-}
-static
-inline
-void
-ep_rt_volatile_store_uint64_t (
-	volatile uint64_t *ptr,
-	uint64_t value)
-{
-	STATIC_CONTRACT_NOTHROW;
-	VolatileStore<uint64_t> ((uint64_t *)ptr, value);
-}
-static
-inline
-void
-ep_rt_volatile_store_uint64_t_without_barrier (
-	volatile uint64_t *ptr,
-	uint64_t value)
-{
-	STATIC_CONTRACT_NOTHROW;
-	VolatileStoreWithoutBarrier<uint64_t> ((uint64_t *)ptr, value);
-}
-static
-inline
-int64_t
-ep_rt_volatile_load_int64_t (const volatile int64_t *ptr)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return VolatileLoad<int64_t> ((int64_t *)ptr);
-}
-static
-inline
-int64_t
-ep_rt_volatile_load_int64_t_without_barrier (const volatile int64_t *ptr)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return VolatileLoadWithoutBarrier<int64_t> ((int64_t *)ptr);
-}
-static
-inline
-void
-ep_rt_volatile_store_int64_t (
-	volatile int64_t *ptr,
-	int64_t value)
-{
-	STATIC_CONTRACT_NOTHROW;
-	VolatileStore<int64_t> ((int64_t *)ptr, value);
-}
-static
-inline
-void
-ep_rt_volatile_store_int64_t_without_barrier (
-	volatile int64_t *ptr,
-	int64_t value)
-{
-	STATIC_CONTRACT_NOTHROW;
-	VolatileStoreWithoutBarrier<int64_t> ((int64_t *)ptr, value);
-}
-static
-inline
-void *
-ep_rt_volatile_load_ptr (volatile void **ptr)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return VolatileLoad<void *> ((void **)ptr);
-}
-static
-inline
-void *
-ep_rt_volatile_load_ptr_without_barrier (volatile void **ptr)
-{
-	STATIC_CONTRACT_NOTHROW;
-	return VolatileLoadWithoutBarrier<void *> ((void **)ptr);
-}
-static
-inline
-void
-ep_rt_volatile_store_ptr (
-	volatile void **ptr,
-	void *value)
-{
-	STATIC_CONTRACT_NOTHROW;
-	VolatileStore<void *> ((void **)ptr, value);
-}
-static
-inline
-void
-ep_rt_volatile_store_ptr_without_barrier (
-	volatile void **ptr,
-	void *value)
-{
-	STATIC_CONTRACT_NOTHROW;
-	VolatileStoreWithoutBarrier<void *> ((void **)ptr, value);
-}
-#endif /* ENABLE_PERFTRACING */
-#endif /* __EVENTPIPE_RT_CORECLR_H__ */

--- a/src/libraries/Common/src/Interop/Unix/System.Security.Cryptography.Native/Interop.OpenSsl.cs
+++ b//dev/null
@@ -1,697 +0,0 @@
-using System;
-using System.Collections.Concurrent;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Globalization;
-using System.IO;
-using System.Net;
-using System.Net.Security;
-using System.Runtime.InteropServices;
-using System.Security.Authentication;
-using System.Security.Authentication.ExtendedProtection;
-using System.Security.Cryptography;
-using System.Security.Cryptography.X509Certificates;
-using Microsoft.Win32.SafeHandles;
-internal static partial class Interop
-{
-    internal static partial class OpenSsl
-    {
-        private const string DisableTlsResumeCtxSwitch = "System.Net.Security.DisableTlsResume";
-        private const string DisableTlsResumeEnvironmentVariable = "DOTNET_SYSTEM_NET_SECURITY_DISABLETLSRESUME";
-        private const string TlsCacheSizeCtxName = "System.Net.Security.TlsCacheSize";
-        private const string TlsCacheSizeEnvironmentVariable = "DOTNET_SYSTEM_NET_SECURITY_TLSCACHESIZE";
-        private const SslProtocols FakeAlpnSslProtocol = (SslProtocols)1;   // used to distinguish server sessions with ALPN
-        private static readonly IdnMapping s_idnMapping = new IdnMapping();
-        private static readonly ConcurrentDictionary<SslProtocols, SafeSslContextHandle> s_clientSslContexts = new ConcurrentDictionary<SslProtocols, SafeSslContextHandle>();
-        #region internal methods
-        internal static SafeChannelBindingHandle? QueryChannelBinding(SafeSslHandle context, ChannelBindingKind bindingType)
-        {
-            Debug.Assert(
-                bindingType != ChannelBindingKind.Endpoint,
-                "Endpoint binding should be handled by EndpointChannelBindingToken");
-            SafeChannelBindingHandle? bindingHandle;
-            switch (bindingType)
-            {
-                case ChannelBindingKind.Unique:
-                    bindingHandle = new SafeChannelBindingHandle(bindingType);
-                    QueryUniqueChannelBinding(context, bindingHandle);
-                    break;
-                default:
-                    bindingHandle = null;
-                    break;
-            }
-            return bindingHandle;
-        }
-        private static int s_cacheSize = GetCacheSize();
-        private static volatile int s_disableTlsResume = -1;
-        private static bool DisableTlsResume
-        {
-            get
-            {
-                int disableTlsResume = s_disableTlsResume;
-                if (disableTlsResume != -1)
-                {
-                    return disableTlsResume != 0;
-                }
-                if (AppContext.TryGetSwitch(DisableTlsResumeCtxSwitch, out bool value))
-                {
-                    s_disableTlsResume = value ? 1 : 0;
-                }
-                else
-                {
-                    s_disableTlsResume =
-                        Environment.GetEnvironmentVariable(DisableTlsResumeEnvironmentVariable) is string envVar &&
-                        (envVar == "1" || envVar.Equals("true", StringComparison.OrdinalIgnoreCase)) ? 1 : 0;
-                }
-                return s_disableTlsResume != 0;
-            }
-        }
-        private static int GetCacheSize()
-        {
-            int cacheSize = -1;
-            string? value = AppContext.GetData(TlsCacheSizeCtxName) as string ?? Environment.GetEnvironmentVariable(TlsCacheSizeEnvironmentVariable);
-            try
-            {
-                if (value != null)
-                {
-                    cacheSize = int.Parse(value);
-                }
-            }
-            catch { };
-            return cacheSize;
-        }
-        private static SslProtocols CalculateEffectiveProtocols(SslAuthenticationOptions sslAuthenticationOptions)
-        {
-            Debug.Assert((sslAuthenticationOptions.EnabledSslProtocols & FakeAlpnSslProtocol) == 0);
-            SslProtocols protocols = sslAuthenticationOptions.EnabledSslProtocols & ~((SslProtocols)1);
-            if (!Interop.Ssl.Capabilities.Tls13Supported)
-            {
-                if (protocols != SslProtocols.None &&
-                    CipherSuitesPolicyPal.WantsTls13(protocols))
-                {
-                    protocols &= ~SslProtocols.Tls13;
-                }
-            }
-            else if (CipherSuitesPolicyPal.WantsTls13(protocols) &&
-                CipherSuitesPolicyPal.ShouldOptOutOfTls13(sslAuthenticationOptions.CipherSuitesPolicy, sslAuthenticationOptions.EncryptionPolicy))
-            {
-                if (protocols == SslProtocols.None)
-                {
-#pragma warning disable SYSLIB0039 // TLS 1.0 and 1.1 are obsolete
-                    protocols = SslProtocols.Tls | SslProtocols.Tls11 | SslProtocols.Tls12;
-#pragma warning restore SYSLIB0039
-                }
-                else
-                {
-                    throw new SslException(
-                        SR.Format(SR.net_ssl_encryptionpolicy_notsupported, sslAuthenticationOptions.EncryptionPolicy));
-                }
-            }
-            if (CipherSuitesPolicyPal.ShouldOptOutOfLowerThanTls13(sslAuthenticationOptions.CipherSuitesPolicy, sslAuthenticationOptions.EncryptionPolicy))
-            {
-                if (!CipherSuitesPolicyPal.WantsTls13(protocols))
-                {
-                    throw new SslException(
-                        SR.Format(SR.net_ssl_encryptionpolicy_notsupported, sslAuthenticationOptions.EncryptionPolicy));
-                }
-                protocols = SslProtocols.Tls13;
-            }
-            return protocols;
-        }
-        internal static unsafe SafeSslContextHandle AllocateSslContext(SslAuthenticationOptions sslAuthenticationOptions, SslProtocols protocols, bool enableResume)
-        {
-            SafeSslContextHandle sslCtx = Ssl.SslCtxCreate(Ssl.SslMethods.SSLv23_method);
-            try
-            {
-                if (sslCtx.IsInvalid)
-                {
-                    throw CreateSslException(SR.net_allocate_ssl_context_failed);
-                }
-                Ssl.SslCtxSetProtocolOptions(sslCtx, protocols);
-                if (sslAuthenticationOptions.EncryptionPolicy != EncryptionPolicy.RequireEncryption)
-                {
-                    if (!Ssl.SetEncryptionPolicy(sslCtx, sslAuthenticationOptions.EncryptionPolicy))
-                    {
-                        throw new SslException(SR.Format(SR.net_ssl_encryptionpolicy_notsupported, sslAuthenticationOptions.EncryptionPolicy));
-                    }
-                }
-                ReadOnlySpan<byte> cipherList = CipherSuitesPolicyPal.GetOpenSslCipherList(sslAuthenticationOptions.CipherSuitesPolicy, protocols, sslAuthenticationOptions.EncryptionPolicy);
-                Debug.Assert(cipherList.IsEmpty || cipherList[^1] == 0);
-                byte[]? cipherSuites = CipherSuitesPolicyPal.GetOpenSslCipherSuites(sslAuthenticationOptions.CipherSuitesPolicy, protocols, sslAuthenticationOptions.EncryptionPolicy);
-                Debug.Assert(cipherSuites == null || (cipherSuites.Length >= 1 && cipherSuites[cipherSuites.Length - 1] == 0));
-                fixed (byte* cipherListStr = cipherList)
-                fixed (byte* cipherSuitesStr = cipherSuites)
-                {
-                    if (!Ssl.SslCtxSetCiphers(sslCtx, cipherListStr, cipherSuitesStr))
-                    {
-                        Crypto.ErrClearError();
-                        throw new PlatformNotSupportedException(SR.Format(SR.net_ssl_encryptionpolicy_notsupported, sslAuthenticationOptions.EncryptionPolicy));
-                    }
-                }
-                Ssl.SslCtxSetQuietShutdown(sslCtx);
-                if (enableResume)
-                {
-                    if (sslAuthenticationOptions.IsServer)
-                    {
-                        Span<byte> contextId = stackalloc byte[32];
-                        RandomNumberGenerator.Fill(contextId);
-                        Ssl.SslCtxSetCaching(sslCtx, 1, s_cacheSize, contextId.Length, contextId, null, null);
-                    }
-                    else
-                    {
-                        int result = Ssl.SslCtxSetCaching(sslCtx, 1, s_cacheSize, 0, null, &NewSessionCallback, &RemoveSessionCallback);
-                        Debug.Assert(result == 1);
-                        sslCtx.EnableSessionCache();
-                    }
-                }
-                else
-                {
-                    Ssl.SslCtxSetCaching(sslCtx, 0, -1, 0, null, null, null);
-                }
-                if (sslAuthenticationOptions.IsServer && sslAuthenticationOptions.ApplicationProtocols != null && sslAuthenticationOptions.ApplicationProtocols.Count != 0)
-                {
-                    Interop.Ssl.SslCtxSetAlpnSelectCb(sslCtx, &AlpnServerSelectCallback, IntPtr.Zero);
-                }
-                if (sslAuthenticationOptions.CertificateContext != null)
-                {
-                    SetSslCertificate(sslCtx, sslAuthenticationOptions.CertificateContext.CertificateHandle, sslAuthenticationOptions.CertificateContext.KeyHandle);
-                    if (sslAuthenticationOptions.CertificateContext.IntermediateCertificates.Length > 0)
-                    {
-                        if (!Ssl.AddExtraChainCertificates(sslCtx, sslAuthenticationOptions.CertificateContext.IntermediateCertificates))
-                        {
-                            throw CreateSslException(SR.net_ssl_use_cert_failed);
-                        }
-                    }
-                    if (sslAuthenticationOptions.CertificateContext.OcspStaplingAvailable)
-                    {
-                        Ssl.SslCtxSetDefaultOcspCallback(sslCtx);
-                    }
-                }
-            }
-            catch
-            {
-                sslCtx.Dispose();
-                throw;
-            }
-            return sslCtx;
-        }
-        internal static void UpdateClientCertiticate(SafeSslHandle ssl, SslAuthenticationOptions sslAuthenticationOptions)
-        {
-            Interop.Ssl.SslSetClientCertCallback(ssl, 0);
-            if (sslAuthenticationOptions.CertificateContext == null)
-            {
-                return;
-            }
-            Debug.Assert(sslAuthenticationOptions.CertificateContext.CertificateHandle != null);
-            Debug.Assert(sslAuthenticationOptions.CertificateContext.KeyHandle != null);
-            int retVal = Ssl.SslUseCertificate(ssl, sslAuthenticationOptions.CertificateContext.CertificateHandle);
-            if (1 != retVal)
-            {
-                throw CreateSslException(SR.net_ssl_use_cert_failed);
-            }
-            retVal = Ssl.SslUsePrivateKey(ssl, sslAuthenticationOptions.CertificateContext.KeyHandle);
-            if (1 != retVal)
-            {
-                throw CreateSslException(SR.net_ssl_use_private_key_failed);
-            }
-            if (sslAuthenticationOptions.CertificateContext.IntermediateCertificates.Length > 0)
-            {
-                if (!Ssl.AddExtraChainCertificates(ssl, sslAuthenticationOptions.CertificateContext.IntermediateCertificates))
-                {
-                    throw CreateSslException(SR.net_ssl_use_cert_failed);
-                }
-            }
-        }
-        internal static SafeSslHandle AllocateSslHandle(SslAuthenticationOptions sslAuthenticationOptions)
-        {
-            SafeSslHandle? sslHandle = null;
-            SafeSslContextHandle? sslCtxHandle = null;
-            SafeSslContextHandle? newCtxHandle = null;
-            SslProtocols protocols = CalculateEffectiveProtocols(sslAuthenticationOptions);
-            bool hasAlpn = sslAuthenticationOptions.ApplicationProtocols != null && sslAuthenticationOptions.ApplicationProtocols.Count != 0;
-            bool cacheSslContext = !DisableTlsResume && sslAuthenticationOptions.EncryptionPolicy == EncryptionPolicy.RequireEncryption && sslAuthenticationOptions.CipherSuitesPolicy == null;
-            if (cacheSslContext)
-            {
-                if (sslAuthenticationOptions.IsClient)
-                {
-                    if (!Interop.Ssl.Capabilities.Tls13Supported ||
-                       string.IsNullOrEmpty(sslAuthenticationOptions.TargetHost) ||
-                       sslAuthenticationOptions.CertificateContext != null ||
-                       sslAuthenticationOptions.ClientCertificates?.Count > 0 ||
-                       sslAuthenticationOptions.CertSelectionDelegate != null)
-                    {
-                        cacheSslContext = false;
-                    }
-                }
-                else
-                {
-                    Debug.Assert(sslAuthenticationOptions.CertificateContext != null);
-                    if (sslAuthenticationOptions.CertificateContext == null ||
-                       sslAuthenticationOptions.CertificateContext.SslContexts == null)
-                    {
-                        cacheSslContext = false;
-                    }
-                }
-            }
-            if (cacheSslContext)
-            {
-                if (sslAuthenticationOptions.IsServer)
-                {
-                    sslAuthenticationOptions.CertificateContext!.SslContexts!.TryGetValue(protocols | (hasAlpn ? FakeAlpnSslProtocol : SslProtocols.None), out sslCtxHandle);
-                }
-                else
-                {
-                    s_clientSslContexts.TryGetValue(protocols, out sslCtxHandle);
-                }
-            }
-            if (sslCtxHandle == null)
-            {
-                sslCtxHandle = newCtxHandle = AllocateSslContext(sslAuthenticationOptions, protocols, cacheSslContext);
-                if (cacheSslContext)
-                {
-                    bool added = sslAuthenticationOptions.IsServer ?
-                                    sslAuthenticationOptions.CertificateContext!.SslContexts!.TryAdd(protocols | (SslProtocols)(hasAlpn ? 1 : 0), newCtxHandle) :
-                                    s_clientSslContexts.TryAdd(protocols, newCtxHandle);
-                    if (added)
-                    {
-                        newCtxHandle = null;
-                    }
-                }
-            }
-            GCHandle alpnHandle = default;
-            try
-            {
-                sslHandle = SafeSslHandle.Create(sslCtxHandle, sslAuthenticationOptions.IsServer);
-                Debug.Assert(sslHandle != null, "Expected non-null return value from SafeSslHandle.Create");
-                if (sslHandle.IsInvalid)
-                {
-                    sslHandle.Dispose();
-                    throw CreateSslException(SR.net_allocate_ssl_context_failed);
-                }
-                if (sslAuthenticationOptions.ApplicationProtocols != null && sslAuthenticationOptions.ApplicationProtocols.Count != 0)
-                {
-                    if (sslAuthenticationOptions.IsServer)
-                    {
-                        Debug.Assert(Interop.Ssl.SslGetData(sslHandle) == IntPtr.Zero);
-                        alpnHandle = GCHandle.Alloc(sslAuthenticationOptions.ApplicationProtocols);
-                        Interop.Ssl.SslSetData(sslHandle, GCHandle.ToIntPtr(alpnHandle));
-                        sslHandle.AlpnHandle = alpnHandle;
-                    }
-                    else
-                    {
-                        if (Interop.Ssl.SslSetAlpnProtos(sslHandle, sslAuthenticationOptions.ApplicationProtocols) != 0)
-                        {
-                            throw CreateSslException(SR.net_alpn_config_failed);
-                        }
-                    }
-                }
-                if (sslAuthenticationOptions.IsClient)
-                {
-                    string punyCode = string.IsNullOrEmpty(sslAuthenticationOptions.TargetHost) ? string.Empty : s_idnMapping.GetAscii(sslAuthenticationOptions.TargetHost!);
-                    if (!Ssl.SslSetTlsExtHostName(sslHandle, punyCode))
-                    {
-                        Crypto.ErrClearError();
-                    }
-                    if (cacheSslContext && !string.IsNullOrEmpty(punyCode))
-                    {
-                        sslCtxHandle.TrySetSession(sslHandle, punyCode);
-                        bool ignored = false;
-                        sslCtxHandle.DangerousAddRef(ref ignored);
-                        sslHandle.SslContextHandle = sslCtxHandle;
-                    }
-                    if (sslAuthenticationOptions.ClientCertificates?.Count > 0 ||
-                        sslAuthenticationOptions.CertSelectionDelegate != null)
-                    {
-                        Ssl.SslSetPostHandshakeAuth(sslHandle, 1);
-                    }
-                    Ssl.SslSetClientCertCallback(sslHandle, 1);
-                }
-                else // sslAuthenticationOptions.IsServer
-                {
-                    if (sslAuthenticationOptions.RemoteCertRequired)
-                    {
-                        Ssl.SslSetVerifyPeer(sslHandle);
-                    }
-                    if (sslAuthenticationOptions.CertificateContext != null)
-                    {
-                        if (sslAuthenticationOptions.CertificateContext.Trust?._sendTrustInHandshake == true)
-                        {
-                            SslCertificateTrust trust = sslAuthenticationOptions.CertificateContext!.Trust!;
-                            X509Certificate2Collection certList = (trust._trustList ?? trust._store!.Certificates);
-                            Debug.Assert(certList != null, "certList != null");
-                            Span<IntPtr> handles = certList.Count <= 256 ?
-                                stackalloc IntPtr[256] :
-                                new IntPtr[certList.Count];
-                            for (int i = 0; i < certList.Count; i++)
-                            {
-                                handles[i] = certList[i].Handle;
-                            }
-                            if (!Ssl.SslAddClientCAs(sslHandle, handles.Slice(0, certList.Count)))
-                            {
-                                Debug.Fail("Failed to add issuer to trusted CA list.");
-                            }
-                        }
-                        byte[]? ocspResponse = sslAuthenticationOptions.CertificateContext.GetOcspResponseNoWaiting();
-                        if (ocspResponse != null)
-                        {
-                            Ssl.SslStapleOcsp(sslHandle, ocspResponse);
-                        }
-                    }
-                }
-            }
-            catch
-            {
-                if (alpnHandle.IsAllocated)
-                {
-                    alpnHandle.Free();
-                }
-                throw;
-            }
-            finally
-            {
-                newCtxHandle?.Dispose();
-            }
-            return sslHandle;
-        }
-        internal static SecurityStatusPal SslRenegotiate(SafeSslHandle sslContext, out byte[]? outputBuffer)
-        {
-            int ret = Interop.Ssl.SslRenegotiate(sslContext, out Ssl.SslErrorCode errorCode);
-            outputBuffer = Array.Empty<byte>();
-            if (ret != 1)
-            {
-                return new SecurityStatusPal(SecurityStatusPalErrorCode.InternalError, GetSslError(ret, errorCode));
-            }
-            return new SecurityStatusPal(SecurityStatusPalErrorCode.OK);
-        }
-        internal static SecurityStatusPalErrorCode DoSslHandshake(SafeSslHandle context, ReadOnlySpan<byte> input, out byte[]? sendBuf, out int sendCount)
-        {
-            sendBuf = null;
-            sendCount = 0;
-            Exception? handshakeException = null;
-            if (input.Length > 0)
-            {
-                if (Ssl.BioWrite(context.InputBio!, ref MemoryMarshal.GetReference(input), input.Length) != input.Length)
-                {
-                    throw Crypto.CreateOpenSslCryptographicException();
-                }
-            }
-            int retVal = Ssl.SslDoHandshake(context, out Ssl.SslErrorCode errorCode);
-            if (retVal != 1)
-            {
-                if (errorCode == Ssl.SslErrorCode.SSL_ERROR_WANT_X509_LOOKUP)
-                {
-                    return SecurityStatusPalErrorCode.CredentialsNeeded;
-                }
-                if ((retVal != -1) || (errorCode != Ssl.SslErrorCode.SSL_ERROR_WANT_READ))
-                {
-                    Exception? innerError = GetSslError(retVal, errorCode);
-                    handshakeException = new SslException(SR.Format(SR.net_ssl_handshake_failed_error, errorCode), innerError);
-                }
-            }
-            sendCount = Crypto.BioCtrlPending(context.OutputBio!);
-            if (sendCount > 0)
-            {
-                sendBuf = new byte[sendCount];
-                try
-                {
-                    sendCount = BioRead(context.OutputBio!, sendBuf, sendCount);
-                }
-                catch (Exception) when (handshakeException != null)
-                {
-                }
-                finally
-                {
-                    if (sendCount <= 0)
-                    {
-                        Crypto.ErrClearError();
-                        sendBuf = null;
-                        sendCount = 0;
-                    }
-                }
-            }
-            if (handshakeException != null)
-            {
-                throw handshakeException;
-            }
-            bool stateOk = Ssl.IsSslStateOK(context);
-            if (stateOk)
-            {
-                context.MarkHandshakeCompleted();
-            }
-            return stateOk ? SecurityStatusPalErrorCode.OK : SecurityStatusPalErrorCode.ContinueNeeded;
-        }
-        internal static int Encrypt(SafeSslHandle context, ReadOnlySpan<byte> input, ref byte[] output, out Ssl.SslErrorCode errorCode)
-        {
-            int retVal = Ssl.SslWrite(context, ref MemoryMarshal.GetReference(input), input.Length, out errorCode);
-            if (retVal != input.Length)
-            {
-                retVal = 0;
-                switch (errorCode)
-                {
-                    case Ssl.SslErrorCode.SSL_ERROR_ZERO_RETURN:
-                    case Ssl.SslErrorCode.SSL_ERROR_WANT_READ:
-                        break;
-                    default:
-                        throw new SslException(SR.Format(SR.net_ssl_encrypt_failed, errorCode), GetSslError(retVal, errorCode));
-                }
-            }
-            else
-            {
-                int capacityNeeded = Crypto.BioCtrlPending(context.OutputBio!);
-                if (output == null || output.Length < capacityNeeded)
-                {
-                    output = new byte[capacityNeeded];
-                }
-                retVal = BioRead(context.OutputBio!, output, capacityNeeded);
-                if (retVal <= 0)
-                {
-                    Crypto.ErrClearError();
-                }
-            }
-            return retVal;
-        }
-        internal static int Decrypt(SafeSslHandle context, Span<byte> buffer, out Ssl.SslErrorCode errorCode)
-        {
-            BioWrite(context.InputBio!, buffer);
-            int retVal = Ssl.SslRead(context, ref MemoryMarshal.GetReference(buffer), buffer.Length, out errorCode);
-            if (retVal > 0)
-            {
-                return retVal;
-            }
-            switch (errorCode)
-            {
-                case Ssl.SslErrorCode.SSL_ERROR_ZERO_RETURN:
-                    break;
-                case Ssl.SslErrorCode.SSL_ERROR_WANT_READ:
-                    errorCode = Ssl.IsSslRenegotiatePending(context)
-                        ? Ssl.SslErrorCode.SSL_ERROR_RENEGOTIATE
-                        : Ssl.SslErrorCode.SSL_ERROR_WANT_READ;
-                    break;
-                case Ssl.SslErrorCode.SSL_ERROR_WANT_X509_LOOKUP:
-                    errorCode = Ssl.SslErrorCode.SSL_ERROR_RENEGOTIATE;
-                    break;
-                default:
-                    throw new SslException(SR.Format(SR.net_ssl_decrypt_failed, errorCode), GetSslError(retVal, errorCode));
-            }
-            return 0;
-        }
-        internal static SafeX509Handle GetPeerCertificate(SafeSslHandle context)
-        {
-            return Ssl.SslGetPeerCertificate(context);
-        }
-        internal static SafeSharedX509StackHandle GetPeerCertificateChain(SafeSslHandle context)
-        {
-            return Ssl.SslGetPeerCertChain(context);
-        }
-        #endregion
-        #region private methods
-        private static void QueryUniqueChannelBinding(SafeSslHandle context, SafeChannelBindingHandle bindingHandle)
-        {
-            bool sessionReused = Ssl.SslSessionReused(context);
-            int certHashLength = context.IsServer ^ sessionReused ?
-                                 Ssl.SslGetPeerFinished(context, bindingHandle.CertHashPtr, bindingHandle.Length) :
-                                 Ssl.SslGetFinished(context, bindingHandle.CertHashPtr, bindingHandle.Length);
-            if (0 == certHashLength)
-            {
-                throw CreateSslException(SR.net_ssl_get_channel_binding_token_failed);
-            }
-            bindingHandle.SetCertHashLength(certHashLength);
-        }
-        [UnmanagedCallersOnly]
-        private static int VerifyClientCertificate(int preverify_ok, IntPtr x509_ctx_ptr)
-        {
-            const int OpenSslSuccess = 1;
-            return OpenSslSuccess;
-        }
-        [UnmanagedCallersOnly]
-        private static unsafe int AlpnServerSelectCallback(IntPtr ssl, byte** outp, byte* outlen, byte* inp, uint inlen, IntPtr arg)
-        {
-            *outp = null;
-            *outlen = 0;
-            IntPtr sslData = Ssl.SslGetData(ssl);
-            if (sslData == IntPtr.Zero)
-            {
-                return Ssl.SSL_TLSEXT_ERR_ALERT_FATAL;
-            }
-            Ssl.SslSetData(ssl, IntPtr.Zero);
-            GCHandle protocolHandle = GCHandle.FromIntPtr(sslData);
-            if (!(protocolHandle.Target is List<SslApplicationProtocol> protocolList))
-            {
-                return Ssl.SSL_TLSEXT_ERR_ALERT_FATAL;
-            }
-            try
-            {
-                for (int i = 0; i < protocolList.Count; i++)
-                {
-                    var clientList = new Span<byte>(inp, (int)inlen);
-                    while (clientList.Length > 0)
-                    {
-                        byte length = clientList[0];
-                        Span<byte> clientProto = clientList.Slice(1, length);
-                        if (clientProto.SequenceEqual(protocolList[i].Protocol.Span))
-                        {
-                            fixed (byte* p = &MemoryMarshal.GetReference(clientProto)) *outp = p;
-                            *outlen = length;
-                            return Ssl.SSL_TLSEXT_ERR_OK;
-                        }
-                        clientList = clientList.Slice(1 + length);
-                    }
-                }
-            }
-            catch
-            {
-                protocolHandle.Target = null;
-                return Ssl.SSL_TLSEXT_ERR_ALERT_FATAL;
-            }
-            protocolHandle.Target = null;
-            return Ssl.SSL_TLSEXT_ERR_ALERT_FATAL;
-        }
-        [UnmanagedCallersOnly]
-        private static unsafe int NewSessionCallback(IntPtr ssl, IntPtr session)
-        {
-            Debug.Assert(ssl != IntPtr.Zero);
-            Debug.Assert(session != IntPtr.Zero);
-            IntPtr ptr = Ssl.SslGetData(ssl);
-            Debug.Assert(ptr != IntPtr.Zero);
-            GCHandle gch = GCHandle.FromIntPtr(ptr);
-            SafeSslContextHandle? ctxHandle = gch.Target as SafeSslContextHandle;
-            if (ctxHandle != null && ctxHandle.TryAddSession(Ssl.SslGetServerName(ssl), session))
-            {
-                return 1;
-            }
-            return 0;
-        }
-        [UnmanagedCallersOnly]
-        private static unsafe void RemoveSessionCallback(IntPtr ctx, IntPtr session)
-        {
-            Debug.Assert(ctx != IntPtr.Zero && session != IntPtr.Zero);
-            IntPtr ptr = Ssl.SslCtxGetData(ctx);
-            if (ptr == IntPtr.Zero)
-            {
-                return;
-            }
-            GCHandle gch = GCHandle.FromIntPtr(ptr);
-            SafeSslContextHandle? ctxHandle = gch.Target as SafeSslContextHandle;
-            if (ctxHandle == null)
-            {
-                return;
-            }
-            IntPtr name = Ssl.SessionGetHostname(session);
-            Debug.Assert(name != IntPtr.Zero);
-            ctxHandle.RemoveSession(name, session);
-        }
-        private static int BioRead(SafeBioHandle bio, byte[] buffer, int count)
-        {
-            Debug.Assert(buffer != null);
-            Debug.Assert(count >= 0);
-            Debug.Assert(buffer.Length >= count);
-            int bytes = Crypto.BioRead(bio, buffer, count);
-            if (bytes != count)
-            {
-                throw CreateSslException(SR.net_ssl_read_bio_failed_error);
-            }
-            return bytes;
-        }
-        private static void BioWrite(SafeBioHandle bio, ReadOnlySpan<byte> buffer)
-        {
-            int bytes = Ssl.BioWrite(bio, ref MemoryMarshal.GetReference(buffer), buffer.Length);
-            if (bytes != buffer.Length)
-            {
-                throw CreateSslException(SR.net_ssl_write_bio_failed_error);
-            }
-        }
-        private static Exception? GetSslError(int result, Ssl.SslErrorCode retVal)
-        {
-            Exception? innerError;
-            switch (retVal)
-            {
-                case Ssl.SslErrorCode.SSL_ERROR_SYSCALL:
-                    ErrorInfo lastErrno = Sys.GetLastErrorInfo();
-                    innerError =
-                        Crypto.ErrPeekError() != 0 ? Crypto.CreateOpenSslCryptographicException() : // crypto error queue not empty
-                        result == 0 ? new EndOfStreamException() : // end of file that violates protocol
-                        result == -1 && lastErrno.Error != Error.SUCCESS ? new IOException(lastErrno.GetErrorMessage(), lastErrno.RawErrno) : // underlying I/O error
-                        null; // no additional info available
-                    break;
-                case Ssl.SslErrorCode.SSL_ERROR_SSL:
-                    innerError = Interop.Crypto.CreateOpenSslCryptographicException();
-                    break;
-                default:
-                    innerError = null;
-                    break;
-            }
-            return innerError;
-        }
-        private static void SetSslCertificate(SafeSslContextHandle contextPtr, SafeX509Handle certPtr, SafeEvpPKeyHandle keyPtr)
-        {
-            Debug.Assert(certPtr != null && !certPtr.IsInvalid, "certPtr != null && !certPtr.IsInvalid");
-            Debug.Assert(keyPtr != null && !keyPtr.IsInvalid, "keyPtr != null && !keyPtr.IsInvalid");
-            int retVal = Ssl.SslCtxUseCertificate(contextPtr, certPtr);
-            if (1 != retVal)
-            {
-                throw CreateSslException(SR.net_ssl_use_cert_failed);
-            }
-            retVal = Ssl.SslCtxUsePrivateKey(contextPtr, keyPtr);
-            if (1 != retVal)
-            {
-                throw CreateSslException(SR.net_ssl_use_private_key_failed);
-            }
-            retVal = Ssl.SslCtxCheckPrivateKey(contextPtr);
-            if (1 != retVal)
-            {
-                throw CreateSslException(SR.net_ssl_check_private_key_failed);
-            }
-        }
-        internal static SslException CreateSslException(string message)
-        {
-            ulong errorVal = Crypto.ErrPeekLastError();
-            Crypto.ErrClearError();
-            string msg = SR.Format(message, Marshal.PtrToStringUTF8(Crypto.ErrReasonErrorString(errorVal)));
-            return new SslException(msg, (int)errorVal);
-        }
-        #endregion
-        #region Internal class
-        internal sealed class SslException : Exception
-        {
-            public SslException(string? inputMessage)
-                : base(inputMessage)
-            {
-            }
-            public SslException(string? inputMessage, Exception? ex)
-                : base(inputMessage, ex)
-            {
-            }
-            public SslException(string? inputMessage, int error)
-                : this(inputMessage)
-            {
-                HResult = error;
-            }
-            public SslException(int error)
-                : this(SR.Format(SR.net_generic_operation_failed, error))
-            {
-                HResult = error;
-            }
-        }
-        #endregion
-    }
-}

--- a/src/libraries/Common/src/Interop/Unix/System.Security.Cryptography.Native/Interop.Ssl.cs
+++ b//dev/null
@@ -1,361 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Net.Security;
-using System.Runtime.InteropServices;
-using System.Runtime.CompilerServices;
-using System.Security.Cryptography;
-using System.Security.Cryptography.X509Certificates;
-using Microsoft.Win32.SafeHandles;
-internal static partial class Interop
-{
-    internal static partial class Ssl
-    {
-        internal const int SSL_TLSEXT_ERR_OK = 0;
-        internal const int OPENSSL_NPN_NEGOTIATED = 1;
-        internal const int SSL_TLSEXT_ERR_ALERT_FATAL = 2;
-        internal const int SSL_TLSEXT_ERR_NOACK = 3;
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslV2_3Method")]
-        internal static partial IntPtr SslV2_3Method();
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslCreate")]
-        internal static partial SafeSslHandle SslCreate(SafeSslContextHandle ctx);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetError")]
-        internal static partial SslErrorCode SslGetError(SafeSslHandle ssl, int ret);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetError")]
-        internal static partial SslErrorCode SslGetError(IntPtr ssl, int ret);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSetQuietShutdown")]
-        internal static partial void SslSetQuietShutdown(SafeSslHandle ssl, int mode);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslDestroy")]
-        internal static partial void SslDestroy(IntPtr ssl);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSetConnectState")]
-        internal static partial void SslSetConnectState(SafeSslHandle ssl);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSetAcceptState")]
-        internal static partial void SslSetAcceptState(SafeSslHandle ssl);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSetAlpnProtos")]
-        internal static unsafe partial int SslSetAlpnProtos(SafeSslHandle ssl, byte* protos, int len);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetVersion")]
-        internal static partial IntPtr SslGetVersion(SafeSslHandle ssl);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSetTlsExtHostName", StringMarshalling = StringMarshalling.Utf8)]
-        [return: MarshalAs(UnmanagedType.Bool)]
-        internal static partial bool SslSetTlsExtHostName(SafeSslHandle ssl, string host);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetServerName")]
-        internal static unsafe partial IntPtr SslGetServerName(IntPtr ssl);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSetSession")]
-        internal static unsafe partial int SslSetSession(SafeSslHandle ssl, IntPtr session);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGet0AlpnSelected")]
-        internal static partial void SslGetAlpnSelected(SafeSslHandle ssl, out IntPtr protocol, out int len);
-        internal static unsafe ReadOnlySpan<byte> SslGetAlpnSelected(SafeSslHandle ssl)
-        {
-            IntPtr protocol;
-            int len;
-            SslGetAlpnSelected(ssl, out protocol, out len);
-            if (len == 0)
-                return ReadOnlySpan<byte>.Empty;
-            return new ReadOnlySpan<byte>((void*)protocol, len);
-        }
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslWrite", SetLastError = true)]
-        internal static partial int SslWrite(SafeSslHandle ssl, ref byte buf, int num, out SslErrorCode error);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslRead", SetLastError = true)]
-        internal static partial int SslRead(SafeSslHandle ssl, ref byte buf, int num, out SslErrorCode error);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslRenegotiate")]
-        internal static partial int SslRenegotiate(SafeSslHandle ssl, out SslErrorCode error);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_IsSslRenegotiatePending")]
-        [return: MarshalAs(UnmanagedType.Bool)]
-        internal static partial bool IsSslRenegotiatePending(SafeSslHandle ssl);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslShutdown")]
-        internal static partial int SslShutdown(IntPtr ssl);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslShutdown")]
-        internal static partial int SslShutdown(SafeSslHandle ssl);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSetBio")]
-        internal static partial void SslSetBio(SafeSslHandle ssl, SafeBioHandle rbio, SafeBioHandle wbio);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslDoHandshake", SetLastError = true)]
-        internal static partial int SslDoHandshake(SafeSslHandle ssl, out SslErrorCode error);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_IsSslStateOK")]
-        [return: MarshalAs(UnmanagedType.Bool)]
-        internal static partial bool IsSslStateOK(SafeSslHandle ssl);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_BioWrite")]
-        internal static unsafe partial int BioWrite(SafeBioHandle b, byte* data, int len);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_BioWrite")]
-        internal static partial int BioWrite(SafeBioHandle b, ref byte data, int len);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetPeerCertificate")]
-        internal static partial SafeX509Handle SslGetPeerCertificate(SafeSslHandle ssl);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetPeerCertChain")]
-        internal static partial SafeSharedX509StackHandle SslGetPeerCertChain(SafeSslHandle ssl);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetPeerFinished")]
-        internal static partial int SslGetPeerFinished(SafeSslHandle ssl, IntPtr buf, int count);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetFinished")]
-        internal static partial int SslGetFinished(SafeSslHandle ssl, IntPtr buf, int count);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSessionReused")]
-        [return: MarshalAs(UnmanagedType.Bool)]
-        internal static partial bool SslSessionReused(SafeSslHandle ssl);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetClientCAList")]
-        private static partial SafeSharedX509NameStackHandle SslGetClientCAList_private(SafeSslHandle ssl);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetCurrentCipherId")]
-        [return: MarshalAs(UnmanagedType.Bool)]
-        internal static partial bool SslGetCurrentCipherId(SafeSslHandle ssl, out int cipherId);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_GetOpenSslCipherSuiteName")]
-        private static partial IntPtr GetOpenSslCipherSuiteName(SafeSslHandle ssl, int cipherSuite, out int isTls12OrLower);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SetCiphers")]
-        [return: MarshalAs(UnmanagedType.Bool)]
-        internal static unsafe partial bool SslSetCiphers(SafeSslHandle ssl, byte* cipherList, byte* cipherSuites);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSetVerifyPeer")]
-        internal static partial void SslSetVerifyPeer(SafeSslHandle ssl);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetData")]
-        internal static partial IntPtr SslGetData(IntPtr ssl);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetData")]
-        internal static partial IntPtr SslGetData(SafeSslHandle ssl);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSetData")]
-        internal static partial int SslSetData(SafeSslHandle ssl, IntPtr data);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSetData")]
-        internal static partial int SslSetData(IntPtr ssl, IntPtr data);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslUseCertificate")]
-        internal static partial int SslUseCertificate(SafeSslHandle ssl, SafeX509Handle certPtr);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslUsePrivateKey")]
-        internal static partial int SslUsePrivateKey(SafeSslHandle ssl, SafeEvpPKeyHandle keyPtr);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSetClientCertCallback")]
-        internal static unsafe partial void SslSetClientCertCallback(SafeSslHandle ssl, int set);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSetPostHandshakeAuth")]
-        internal static partial void SslSetPostHandshakeAuth(SafeSslHandle ssl, int value);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_Tls13Supported")]
-        private static partial int Tls13SupportedImpl();
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSessionGetHostname")]
-        internal static partial IntPtr SessionGetHostname(IntPtr session);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSessionFree")]
-        internal static partial void SessionFree(IntPtr session);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSessionSetHostname")]
-        internal static partial int SessionSetHostname(IntPtr session, IntPtr name);
-        internal static class Capabilities
-        {
-            internal static readonly bool Tls13Supported = Tls13SupportedImpl() != 0;
-        }
-        internal static int GetAlpnProtocolListSerializedLength(List<SslApplicationProtocol> applicationProtocols)
-        {
-            int protocolSize = 0;
-            foreach (SslApplicationProtocol protocol in applicationProtocols)
-            {
-                if (protocol.Protocol.Length == 0 || protocol.Protocol.Length > byte.MaxValue)
-                {
-                    throw new ArgumentException(SR.net_ssl_app_protocols_invalid, nameof(applicationProtocols));
-                }
-                protocolSize += protocol.Protocol.Length + 1;
-            }
-            return protocolSize;
-        }
-        internal static void SerializeAlpnProtocolList(List<SslApplicationProtocol> applicationProtocols, Span<byte> buffer)
-        {
-            Debug.Assert(GetAlpnProtocolListSerializedLength(applicationProtocols) == buffer.Length,
-                "GetAlpnProtocolListSerializedSize(applicationProtocols) == buffer.Length");
-            int offset = 0;
-            foreach (SslApplicationProtocol protocol in applicationProtocols)
-            {
-                buffer[offset++] = (byte)protocol.Protocol.Length;
-                protocol.Protocol.Span.CopyTo(buffer.Slice(offset));
-                offset += protocol.Protocol.Length;
-            }
-        }
-        internal static unsafe int SslSetAlpnProtos(SafeSslHandle ssl, List<SslApplicationProtocol> applicationProtocols)
-        {
-            int length = GetAlpnProtocolListSerializedLength(applicationProtocols);
-            Span<byte> buffer = length <= 256 ? stackalloc byte[256].Slice(0, length) : new byte[length];
-            SerializeAlpnProtocolList(applicationProtocols, buffer);
-            return SslSetAlpnProtos(ssl, buffer);
-        }
-        internal static unsafe int SslSetAlpnProtos(SafeSslHandle ssl, Span<byte> serializedProtocols)
-        {
-            fixed (byte* pBuffer = &MemoryMarshal.GetReference(serializedProtocols))
-            {
-                return SslSetAlpnProtos(ssl, pBuffer, serializedProtocols.Length);
-            }
-        }
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslAddExtraChainCert")]
-        [return: MarshalAs(UnmanagedType.Bool)]
-        internal static partial bool SslAddExtraChainCert(SafeSslHandle ssl, SafeX509Handle x509);
-        [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslAddClientCAs")]
-        [return: MarshalAs(UnmanagedType.Bool)]
-        private static unsafe partial bool SslAddClientCAs(SafeSslHandle ssl, IntPtr* x509s, int count);
-        internal static unsafe bool SslAddClientCAs(SafeSslHandle ssl, Span<IntPtr> x509handles)
-        {
-            fixed (IntPtr* pHandles = &MemoryMarshal.GetReference(x509handles))
-            {
-                return SslAddClientCAs(ssl, pHandles, x509handles.Length);
-            }
-        }
-        [LibraryImport(Libraries.CryptoNative)]
-        private static unsafe partial void CryptoNative_SslStapleOcsp(SafeSslHandle ssl, byte* buf, int len);
-        internal static unsafe void SslStapleOcsp(SafeSslHandle ssl, ReadOnlySpan<byte> stapledResponse)
-        {
-            Debug.Assert(stapledResponse.Length > 0);
-            fixed (byte* ptr = stapledResponse)
-            {
-                CryptoNative_SslStapleOcsp(ssl, ptr, stapledResponse.Length);
-            }
-        }
-        internal static bool AddExtraChainCertificates(SafeSslHandle ssl, X509Certificate2[] chain)
-        {
-            for (int i = 0; i < chain.Length; i++)
-            {
-                SafeX509Handle dupCertHandle = Crypto.X509UpRef(chain[i].Handle);
-                Crypto.CheckValidOpenSslHandle(dupCertHandle);
-                if (!SslAddExtraChainCert(ssl, dupCertHandle))
-                {
-                    Crypto.ErrClearError();
-                    dupCertHandle.Dispose(); // we still own the safe handle; clean it up
-                    return false;
-                }
-                dupCertHandle.SetHandleAsInvalid(); // ownership has been transferred to sslHandle; do not free via this safe handle
-            }
-            return true;
-        }
-        internal static string? GetOpenSslCipherSuiteName(SafeSslHandle ssl, TlsCipherSuite cipherSuite, out bool isTls12OrLower)
-        {
-            string? ret = Marshal.PtrToStringUTF8(GetOpenSslCipherSuiteName(ssl, (int)cipherSuite, out int isTls12OrLowerInt));
-            isTls12OrLower = isTls12OrLowerInt != 0;
-            return ret;
-        }
-        internal static SafeSharedX509NameStackHandle SslGetClientCAList(SafeSslHandle ssl)
-        {
-            Crypto.CheckValidOpenSslHandle(ssl);
-            SafeSharedX509NameStackHandle handle = SslGetClientCAList_private(ssl);
-            if (!handle.IsInvalid)
-            {
-                handle.SetParent(ssl);
-            }
-            return handle;
-        }
-        internal static class SslMethods
-        {
-            internal static readonly IntPtr SSLv23_method = SslV2_3Method();
-        }
-        internal enum SslErrorCode
-        {
-            SSL_ERROR_NONE = 0,
-            SSL_ERROR_SSL = 1,
-            SSL_ERROR_WANT_READ = 2,
-            SSL_ERROR_WANT_WRITE = 3,
-            SSL_ERROR_WANT_X509_LOOKUP = 4,
-            SSL_ERROR_SYSCALL = 5,
-            SSL_ERROR_ZERO_RETURN = 6,
-            SSL_ERROR_RENEGOTIATE = 29304
-        }
-    }
-}
-namespace Microsoft.Win32.SafeHandles
-{
-    internal sealed class SafeSslHandle : SafeDeleteSslContext
-    {
-        private SafeBioHandle? _readBio;
-        private SafeBioHandle? _writeBio;
-        private bool _isServer;
-        private bool _handshakeCompleted;
-        public GCHandle AlpnHandle;
-        public SafeSslContextHandle? SslContextHandle;
-        public bool IsServer
-        {
-            get { return _isServer; }
-        }
-        public SafeBioHandle? InputBio
-        {
-            get
-            {
-                return _readBio;
-            }
-        }
-        public SafeBioHandle? OutputBio
-        {
-            get
-            {
-                return _writeBio;
-            }
-        }
-        internal void MarkHandshakeCompleted()
-        {
-            _handshakeCompleted = true;
-        }
-        public static SafeSslHandle Create(SafeSslContextHandle context, bool isServer)
-        {
-            SafeBioHandle readBio = Interop.Crypto.CreateMemoryBio();
-            SafeBioHandle writeBio = Interop.Crypto.CreateMemoryBio();
-            SafeSslHandle handle = Interop.Ssl.SslCreate(context);
-            if (readBio.IsInvalid || writeBio.IsInvalid || handle.IsInvalid)
-            {
-                readBio.Dispose();
-                writeBio.Dispose();
-                handle.Dispose(); // will make IsInvalid==true if it's not already
-                return handle;
-            }
-            handle._isServer = isServer;
-            try
-            {
-                readBio.TransferOwnershipToParent(handle);
-                writeBio.TransferOwnershipToParent(handle);
-                handle._readBio = readBio;
-                handle._writeBio = writeBio;
-                Interop.Ssl.SslSetBio(handle, readBio, writeBio);
-            }
-            catch (Exception exc)
-            {
-                Debug.Fail("Unexpected exception while transferring SafeBioHandle ownership to SafeSslHandle", exc.ToString());
-                throw;
-            }
-            if (isServer)
-            {
-                Interop.Ssl.SslSetAcceptState(handle);
-            }
-            else
-            {
-                Interop.Ssl.SslSetConnectState(handle);
-            }
-            return handle;
-        }
-        public override bool IsInvalid
-        {
-            get { return handle == IntPtr.Zero; }
-        }
-        protected override void Dispose(bool disposing)
-        {
-            if (disposing)
-            {
-                _readBio?.Dispose();
-                _writeBio?.Dispose();
-            }
-            if (AlpnHandle.IsAllocated)
-            {
-                Interop.Ssl.SslSetData(handle, IntPtr.Zero);
-                AlpnHandle.Free();
-            }
-            base.Dispose(disposing);
-        }
-        protected override bool ReleaseHandle()
-        {
-            if (_handshakeCompleted)
-            {
-                Disconnect();
-            }
-            SslContextHandle?.DangerousRelease();
-            IntPtr h = handle;
-            SetHandle(IntPtr.Zero);
-            Interop.Ssl.SslDestroy(h); // will free the handles underlying _readBio and _writeBio
-            return true;
-        }
-        private void Disconnect()
-        {
-            Debug.Assert(!IsInvalid, "Expected a valid context in Disconnect");
-            int retVal = Interop.Ssl.SslShutdown(handle);
-            if (retVal == 0)
-            {
-                retVal = Interop.Ssl.SslShutdown(handle);
-            }
-            if (retVal < 0)
-            {
-                Interop.Crypto.ErrClearError();
-            }
-        }
-        public SafeSslHandle() : base(IntPtr.Zero, true)
-        {
-        }
-        internal SafeSslHandle(IntPtr validSslPointer, bool ownsHandle) : base(IntPtr.Zero, ownsHandle)
-        {
-            handle = validSslPointer;
-        }
-    }
-}

--- a/src/libraries/Common/src/Interop/Windows/Kernel32/Interop.Threading.cs
+++ b//dev/null
@@ -1,62 +0,0 @@
-using Microsoft.Win32.SafeHandles;
-using System;
-using System.Runtime.InteropServices;
-internal static partial class Interop
-{
-    internal static partial class Kernel32
-    {
-        internal const int WAIT_FAILED = unchecked((int)0xFFFFFFFF);
-        [LibraryImport(Libraries.Kernel32)]
-        internal static partial uint WaitForMultipleObjectsEx(uint nCount, IntPtr lpHandles, BOOL bWaitAll, uint dwMilliseconds, BOOL bAlertable);
-        [LibraryImport(Libraries.Kernel32)]
-        internal static partial uint WaitForSingleObject(IntPtr hHandle, uint dwMilliseconds);
-        [LibraryImport(Libraries.Kernel32)]
-        internal static partial uint SignalObjectAndWait(IntPtr hObjectToSignal, IntPtr hObjectToWaitOn, uint dwMilliseconds, BOOL bAlertable);
-        [LibraryImport(Libraries.Kernel32)]
-        internal static partial void Sleep(uint milliseconds);
-        internal const uint CREATE_SUSPENDED = 0x00000004;
-        internal const uint STACK_SIZE_PARAM_IS_A_RESERVATION = 0x00010000;
-        [LibraryImport(Libraries.Kernel32)]
-        internal static unsafe partial SafeWaitHandle CreateThread(
-            IntPtr lpThreadAttributes,
-            IntPtr dwStackSize,
-            delegate* unmanaged<IntPtr, uint> lpStartAddress,
-            IntPtr lpParameter,
-            uint dwCreationFlags,
-            out uint lpThreadId);
-        [LibraryImport(Libraries.Kernel32)]
-        internal static partial uint ResumeThread(SafeWaitHandle hThread);
-        [LibraryImport(Libraries.Kernel32)]
-        internal static partial IntPtr GetCurrentThread();
-        internal const int DUPLICATE_SAME_ACCESS = 2;
-        [LibraryImport(Libraries.Kernel32, SetLastError = true)]
-        [return:MarshalAs(UnmanagedType.Bool)]
-        internal static partial bool DuplicateHandle(
-            IntPtr hSourceProcessHandle,
-            IntPtr hSourceHandle,
-            IntPtr hTargetProcessHandle,
-            out SafeWaitHandle lpTargetHandle,
-            uint dwDesiredAccess,
-            [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle,
-            uint dwOptions);
-        internal enum ThreadPriority : int
-        {
-            Idle = -15,
-            Lowest = -2,
-            BelowNormal = -1,
-            Normal = 0,
-            AboveNormal = 1,
-            Highest = 2,
-            TimeCritical = 15,
-            ErrorReturn = 0x7FFFFFFF
-        }
-        [LibraryImport(Libraries.Kernel32)]
-        internal static partial ThreadPriority GetThreadPriority(SafeWaitHandle hThread);
-        [LibraryImport(Libraries.Kernel32)]
-        [return:MarshalAs(UnmanagedType.Bool)]
-        internal static partial bool SetThreadPriority(SafeWaitHandle hThread, int nPriority);
-        [LibraryImport(Libraries.Kernel32, SetLastError = true)]
-        [return: MarshalAs(UnmanagedType.Bool)]
-        internal static partial bool GetThreadIOPendingFlag(nint hThread, out BOOL lpIOIsPending);
-    }
-}

--- a/src/libraries/System.Console/src/System/TermInfo.DatabaseFactory.cs
+++ b//dev/null
@@ -1,90 +0,0 @@
-using System.Diagnostics.CodeAnalysis;
-using System.IO;
-using Microsoft.Win32.SafeHandles;
-namespace System;
-internal static partial class TermInfo
-{
-    internal sealed class DatabaseFactory
-    {
-        internal static readonly string[] s_terminfoLocations = {
-            "/etc/terminfo",
-            "/lib/terminfo",
-            "/usr/share/terminfo",
-            "/usr/share/misc/terminfo",
-            "/usr/local/share/terminfo"
-        };
-        internal static Database? ReadActiveDatabase()
-        {
-            string? term = Environment.GetEnvironmentVariable("TERM");
-            return !string.IsNullOrEmpty(term) ? ReadDatabase(term) : null;
-        }
-        internal static Database? ReadDatabase(string term)
-        {
-            Database? db;
-            string? terminfo = Environment.GetEnvironmentVariable("TERMINFO");
-            if (!string.IsNullOrWhiteSpace(terminfo) && (db = ReadDatabase(term, terminfo)) != null)
-            {
-                return db;
-            }
-            string? home = PersistedFiles.GetHomeDirectory();
-            if (!string.IsNullOrWhiteSpace(home) && (db = ReadDatabase(term, home + "/.terminfo")) != null)
-            {
-                return db;
-            }
-            foreach (string terminfoLocation in s_terminfoLocations)
-            {
-                if ((db = ReadDatabase(term, terminfoLocation)) != null)
-                {
-                    return db;
-                }
-            }
-            return null;
-        }
-        private static bool TryOpen(string filePath, [NotNullWhen(true)] out SafeFileHandle? fd)
-        {
-            fd = Interop.Sys.Open(filePath, Interop.Sys.OpenFlags.O_RDONLY | Interop.Sys.OpenFlags.O_CLOEXEC, 0);
-            if (fd.IsInvalid)
-            {
-                fd.Dispose();
-                fd = null;
-                return false;
-            }
-            return true;
-        }
-        internal static Database? ReadDatabase(string? term, string? directoryPath)
-        {
-            if (string.IsNullOrEmpty(term) || string.IsNullOrEmpty(directoryPath))
-            {
-                return null;
-            }
-            Span<char> stackBuffer = stackalloc char[256];
-            SafeFileHandle? fd;
-            if (!TryOpen(string.Create(null, stackBuffer, $"{directoryPath}/{term[0]}/{term}"), out fd) &&       // /directory/termFirstLetter/term      (Linux)
-                !TryOpen(string.Create(null, stackBuffer, $"{directoryPath}/{(int)term[0]:X}/{term}"), out fd))  // /directory/termFirstLetterAsHex/term (Mac)
-            {
-                return null;
-            }
-            using (fd)
-            {
-                long termInfoLength = RandomAccess.GetLength(fd);
-                const int HeaderLength = 12;
-                if (termInfoLength <= HeaderLength)
-                {
-                    throw new InvalidOperationException(SR.IO_TermInfoInvalid);
-                }
-                byte[] data = new byte[(int)termInfoLength];
-                long fileOffset = 0;
-                do
-                {
-                    int bytesRead = RandomAccess.Read(fd, new Span<byte>(data, (int)fileOffset, (int)(termInfoLength - fileOffset)), fileOffset);
-                    if (bytesRead == 0)
-                    {
-                        throw new InvalidOperationException(SR.IO_TermInfoInvalid);
-                    }
-                    fileOffset += bytesRead;
-                } while (fileOffset < termInfoLength);
-                return new Database(term, data);
-            }
-        }
-    }
-}

--- a/src/libraries/System.Console/src/System/TerminalFormatStrings.cs
+++ b//dev/null
@@ -1,203 +0,0 @@
-using System.Collections.Generic;
-using System.Diagnostics;
-namespace System;
-internal sealed class TerminalFormatStrings
-{
-    public readonly string? Foreground;
-    public readonly string? Background;
-    public readonly string? Reset;
-    public readonly int MaxColors;
-    public readonly int Columns;
-    public readonly int Lines;
-    public readonly string? CursorVisible;
-    public readonly string? CursorInvisible;
-    public readonly string? Title;
-    public readonly string? Bell;
-    public readonly string? Clear;
-    public readonly string? CursorAddress;
-    public readonly string? CursorLeft;
-    public readonly string? ClrEol;
-    public const string CursorPositionReport = "\x1B[6n";
-    public readonly Dictionary<ReadOnlyMemory<char>, ConsoleKeyInfo> KeyFormatToConsoleKey =
-        new Dictionary<ReadOnlyMemory<char>, ConsoleKeyInfo>(new ReadOnlyMemoryContentComparer());
-    public readonly int MaxKeyFormatLength;
-    public readonly int MinKeyFormatLength;
-    public readonly string? KeypadXmit;
-    public readonly bool IsRxvtTerm;
-    public TerminalFormatStrings(TermInfo.Database? db)
-    {
-        if (db == null)
-            return;
-        KeypadXmit = db.GetString(TermInfo.WellKnownStrings.KeypadXmit);
-        Foreground = db.GetString(TermInfo.WellKnownStrings.SetAnsiForeground);
-        Background = db.GetString(TermInfo.WellKnownStrings.SetAnsiBackground);
-        Reset = db.GetString(TermInfo.WellKnownStrings.OrigPairs) ?? db.GetString(TermInfo.WellKnownStrings.OrigColors);
-        Bell = db.GetString(TermInfo.WellKnownStrings.Bell);
-        Clear = db.GetString(TermInfo.WellKnownStrings.Clear);
-        Columns = db.GetNumber(TermInfo.WellKnownNumbers.Columns);
-        Lines = db.GetNumber(TermInfo.WellKnownNumbers.Lines);
-        CursorVisible = db.GetString(TermInfo.WellKnownStrings.CursorVisible);
-        CursorInvisible = db.GetString(TermInfo.WellKnownStrings.CursorInvisible);
-        CursorAddress = db.GetString(TermInfo.WellKnownStrings.CursorAddress);
-        CursorLeft = db.GetString(TermInfo.WellKnownStrings.CursorLeft);
-        ClrEol = db.GetString(TermInfo.WellKnownStrings.ClrEol);
-        IsRxvtTerm = !string.IsNullOrEmpty(db.Term) && db.Term.Contains("rxvt", StringComparison.OrdinalIgnoreCase);
-        Title = GetTitle(db);
-        Debug.WriteLineIf(db.GetString(TermInfo.WellKnownStrings.CursorPositionReport) != CursorPositionReport,
-            "Getting the cursor position will only work if the terminal supports the CPR sequence," +
-            "but the terminfo database does not contain an entry for it.");
-        int maxColors = db.GetNumber(TermInfo.WellKnownNumbers.MaxColors);
-        MaxColors = // normalize to either the full range of all ANSI colors, just the dark ones, or none
-            maxColors >= 16 ? 16 :
-            maxColors >= 8 ? 8 :
-            0;
-        AddKey(db, TermInfo.WellKnownStrings.KeyF1, ConsoleKey.F1);
-        AddKey(db, TermInfo.WellKnownStrings.KeyF2, ConsoleKey.F2);
-        AddKey(db, TermInfo.WellKnownStrings.KeyF3, ConsoleKey.F3);
-        AddKey(db, TermInfo.WellKnownStrings.KeyF4, ConsoleKey.F4);
-        AddKey(db, TermInfo.WellKnownStrings.KeyF5, ConsoleKey.F5);
-        AddKey(db, TermInfo.WellKnownStrings.KeyF6, ConsoleKey.F6);
-        AddKey(db, TermInfo.WellKnownStrings.KeyF7, ConsoleKey.F7);
-        AddKey(db, TermInfo.WellKnownStrings.KeyF8, ConsoleKey.F8);
-        AddKey(db, TermInfo.WellKnownStrings.KeyF9, ConsoleKey.F9);
-        AddKey(db, TermInfo.WellKnownStrings.KeyF10, ConsoleKey.F10);
-        AddKey(db, TermInfo.WellKnownStrings.KeyF11, ConsoleKey.F11);
-        AddKey(db, TermInfo.WellKnownStrings.KeyF12, ConsoleKey.F12);
-        AddKey(db, TermInfo.WellKnownStrings.KeyF13, ConsoleKey.F13);
-        AddKey(db, TermInfo.WellKnownStrings.KeyF14, ConsoleKey.F14);
-        AddKey(db, TermInfo.WellKnownStrings.KeyF15, ConsoleKey.F15);
-        AddKey(db, TermInfo.WellKnownStrings.KeyF16, ConsoleKey.F16);
-        AddKey(db, TermInfo.WellKnownStrings.KeyF17, ConsoleKey.F17);
-        AddKey(db, TermInfo.WellKnownStrings.KeyF18, ConsoleKey.F18);
-        AddKey(db, TermInfo.WellKnownStrings.KeyF19, ConsoleKey.F19);
-        AddKey(db, TermInfo.WellKnownStrings.KeyF20, ConsoleKey.F20);
-        AddKey(db, TermInfo.WellKnownStrings.KeyF21, ConsoleKey.F21);
-        AddKey(db, TermInfo.WellKnownStrings.KeyF22, ConsoleKey.F22);
-        AddKey(db, TermInfo.WellKnownStrings.KeyF23, ConsoleKey.F23);
-        AddKey(db, TermInfo.WellKnownStrings.KeyF24, ConsoleKey.F24);
-        AddKey(db, TermInfo.WellKnownStrings.KeyBackspace, ConsoleKey.Backspace);
-        AddKey(db, TermInfo.WellKnownStrings.KeyBackTab, ConsoleKey.Tab, shift: true, alt: false, control: false);
-        AddKey(db, TermInfo.WellKnownStrings.KeyBegin, ConsoleKey.Home);
-        AddKey(db, TermInfo.WellKnownStrings.KeyClear, ConsoleKey.Clear);
-        AddKey(db, TermInfo.WellKnownStrings.KeyDelete, ConsoleKey.Delete);
-        AddKey(db, TermInfo.WellKnownStrings.KeyDown, ConsoleKey.DownArrow);
-        AddKey(db, TermInfo.WellKnownStrings.KeyEnd, ConsoleKey.End);
-        AddKey(db, TermInfo.WellKnownStrings.KeyEnter, ConsoleKey.Enter);
-        AddKey(db, TermInfo.WellKnownStrings.KeyHelp, ConsoleKey.Help);
-        AddKey(db, TermInfo.WellKnownStrings.KeyHome, ConsoleKey.Home);
-        AddKey(db, TermInfo.WellKnownStrings.KeyInsert, ConsoleKey.Insert);
-        AddKey(db, TermInfo.WellKnownStrings.KeyLeft, ConsoleKey.LeftArrow);
-        AddKey(db, TermInfo.WellKnownStrings.KeyPageDown, ConsoleKey.PageDown);
-        AddKey(db, TermInfo.WellKnownStrings.KeyPageUp, ConsoleKey.PageUp);
-        AddKey(db, TermInfo.WellKnownStrings.KeyPrint, ConsoleKey.Print);
-        AddKey(db, TermInfo.WellKnownStrings.KeyRight, ConsoleKey.RightArrow);
-        AddKey(db, TermInfo.WellKnownStrings.KeyScrollForward, ConsoleKey.PageDown, shift: true, alt: false, control: false);
-        AddKey(db, TermInfo.WellKnownStrings.KeyScrollReverse, ConsoleKey.PageUp, shift: true, alt: false, control: false);
-        AddKey(db, TermInfo.WellKnownStrings.KeySBegin, ConsoleKey.Home, shift: true, alt: false, control: false);
-        AddKey(db, TermInfo.WellKnownStrings.KeySDelete, ConsoleKey.Delete, shift: true, alt: false, control: false);
-        AddKey(db, TermInfo.WellKnownStrings.KeySHome, ConsoleKey.Home, shift: true, alt: false, control: false);
-        AddKey(db, TermInfo.WellKnownStrings.KeySelect, ConsoleKey.Select);
-        AddKey(db, TermInfo.WellKnownStrings.KeySLeft, ConsoleKey.LeftArrow, shift: true, alt: false, control: false);
-        AddKey(db, TermInfo.WellKnownStrings.KeySPrint, ConsoleKey.Print, shift: true, alt: false, control: false);
-        AddKey(db, TermInfo.WellKnownStrings.KeySRight, ConsoleKey.RightArrow, shift: true, alt: false, control: false);
-        AddKey(db, TermInfo.WellKnownStrings.KeyUp, ConsoleKey.UpArrow);
-        AddPrefixKey(db, "kLFT", ConsoleKey.LeftArrow);
-        AddPrefixKey(db, "kRIT", ConsoleKey.RightArrow);
-        AddPrefixKey(db, "kUP", ConsoleKey.UpArrow);
-        AddPrefixKey(db, "kDN", ConsoleKey.DownArrow);
-        AddPrefixKey(db, "kDC", ConsoleKey.Delete);
-        AddPrefixKey(db, "kEND", ConsoleKey.End);
-        AddPrefixKey(db, "kHOM", ConsoleKey.Home);
-        AddPrefixKey(db, "kNXT", ConsoleKey.PageDown);
-        AddPrefixKey(db, "kPRV", ConsoleKey.PageUp);
-        if (KeyFormatToConsoleKey.Count > 0)
-        {
-            MaxKeyFormatLength = int.MinValue;
-            MinKeyFormatLength = int.MaxValue;
-            foreach (KeyValuePair<ReadOnlyMemory<char>, ConsoleKeyInfo> entry in KeyFormatToConsoleKey)
-            {
-                if (entry.Key.Length > MaxKeyFormatLength)
-                {
-                    MaxKeyFormatLength = entry.Key.Length;
-                }
-                if (entry.Key.Length < MinKeyFormatLength)
-                {
-                    MinKeyFormatLength = entry.Key.Length;
-                }
-            }
-        }
-    }
-    private static string GetTitle(TermInfo.Database db)
-    {
-        string? tsl = db.GetString(TermInfo.WellKnownStrings.ToStatusLine);
-        string? fsl = db.GetString(TermInfo.WellKnownStrings.FromStatusLine);
-        if (tsl != null && fsl != null)
-        {
-            return tsl + "%p1%s" + fsl;
-        }
-        string term = db.Term;
-        if (term == null)
-        {
-            return string.Empty;
-        }
-        if (term.StartsWith("xterm", StringComparison.Ordinal)) // normalize all xterms to enable easier matching
-        {
-            term = "xterm";
-        }
-        else if (term.StartsWith("screen", StringComparison.Ordinal)) // normalize all tmux configs
-        {
-            term = "screen";
-        }
-        switch (term)
-        {
-            case "aixterm":
-            case "dtterm":
-            case "linux":
-            case "rxvt":
-            case "xterm":
-                return "\x1B]0;%p1%s\x07";
-            case "cygwin":
-                return "\x1B];%p1%s\x07";
-            case "konsole":
-                return "\x1B]30;%p1%s\x07";
-            case "screen":
-                return "\x1Bk%p1%s\x1B\\";
-            default:
-                return string.Empty;
-        }
-    }
-    private void AddKey(TermInfo.Database db, TermInfo.WellKnownStrings keyId, ConsoleKey key)
-    {
-        AddKey(db, keyId, key, shift: false, alt: false, control: false);
-    }
-    private void AddKey(TermInfo.Database db, TermInfo.WellKnownStrings keyId, ConsoleKey key, bool shift, bool alt, bool control)
-    {
-        ReadOnlyMemory<char> keyFormat = db.GetString(keyId).AsMemory();
-        if (!keyFormat.IsEmpty)
-            KeyFormatToConsoleKey[keyFormat] = new ConsoleKeyInfo(key == ConsoleKey.Enter ? '\r' : '\0', key, shift, alt, control);
-    }
-    private void AddPrefixKey(TermInfo.Database db, string extendedNamePrefix, ConsoleKey key)
-    {
-        if (db.HasExtendedStrings) // avoid string concatenation in case when there are no Extended Strings (typical scenario)
-        {
-            AddKey(db, extendedNamePrefix + "3", key, shift: false, alt: true,  control: false);
-            AddKey(db, extendedNamePrefix + "4", key, shift: true,  alt: true,  control: false);
-            AddKey(db, extendedNamePrefix + "5", key, shift: false, alt: false, control: true);
-            AddKey(db, extendedNamePrefix + "6", key, shift: true,  alt: false, control: true);
-            AddKey(db, extendedNamePrefix + "7", key, shift: false, alt: false, control: true);
-        }
-    }
-    private void AddKey(TermInfo.Database db, string extendedName, ConsoleKey key, bool shift, bool alt, bool control)
-    {
-        ReadOnlyMemory<char> keyFormat = db.GetExtendedString(extendedName).AsMemory();
-        if (!keyFormat.IsEmpty)
-            KeyFormatToConsoleKey[keyFormat] = new ConsoleKeyInfo('\0', key, shift, alt, control);
-    }
-    private sealed class ReadOnlyMemoryContentComparer : IEqualityComparer<ReadOnlyMemory<char>>
-    {
-        public bool Equals(ReadOnlyMemory<char> x, ReadOnlyMemory<char> y) =>
-            x.Span.SequenceEqual(y.Span);
-        public int GetHashCode(ReadOnlyMemory<char> obj) =>
-            string.GetHashCode(obj.Span);
-    }
-}

--- a/src/libraries/System.Drawing.Common/src/System.Drawing.Common.Forwards.cs
+++ b//dev/null
@@ -1,11 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-[assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Drawing.Color))]
-[assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Drawing.ColorTranslator))]
-[assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Drawing.KnownColor))]
-[assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Drawing.Point))]
-[assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Drawing.PointF))]
-[assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Drawing.Rectangle))]
-[assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Drawing.RectangleF))]
-[assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Drawing.Size))]
-[assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Drawing.SizeF))]
-[assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Drawing.SystemColors))]

--- a/src/libraries/System.Formats.Tar/src/System/Formats/Tar/TarHeader.Read.cs
+++ b//dev/null
@@ -1,526 +0,0 @@
-using System.Buffers;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Diagnostics.CodeAnalysis;
-using System.IO;
-using System.Text;
-using System.Threading;
-using System.Threading.Tasks;
-namespace System.Formats.Tar
-{
-    internal sealed partial class TarHeader
-    {
-        private const string UstarPrefixFormat = "{0}/{1}"; // "prefix/name"
-        internal static TarHeader? TryGetNextHeader(Stream archiveStream, bool copyData, TarEntryFormat initialFormat, bool processDataBlock)
-        {
-            Span<byte> buffer = stackalloc byte[TarHelpers.RecordSize];
-            archiveStream.ReadExactly(buffer);
-            TarHeader? header = TryReadAttributes(initialFormat, buffer);
-            if (header != null && processDataBlock)
-            {
-                header.ProcessDataBlock(archiveStream, copyData);
-            }
-            return header;
-        }
-        internal static async ValueTask<TarHeader?> TryGetNextHeaderAsync(Stream archiveStream, bool copyData, TarEntryFormat initialFormat, bool processDataBlock, CancellationToken cancellationToken)
-        {
-            cancellationToken.ThrowIfCancellationRequested();
-            byte[] rented = ArrayPool<byte>.Shared.Rent(minimumLength: TarHelpers.RecordSize);
-            Memory<byte> buffer = rented.AsMemory(0, TarHelpers.RecordSize); // minimumLength means the array could've been larger
-            await archiveStream.ReadExactlyAsync(buffer, cancellationToken).ConfigureAwait(false);
-            TarHeader? header = TryReadAttributes(initialFormat, buffer.Span);
-            if (header != null && processDataBlock)
-            {
-                await header.ProcessDataBlockAsync(archiveStream, copyData, cancellationToken).ConfigureAwait(false);
-            }
-            ArrayPool<byte>.Shared.Return(rented);
-            return header;
-        }
-        private static TarHeader? TryReadAttributes(TarEntryFormat initialFormat, Span<byte> buffer)
-        {
-            TarHeader? header = TryReadCommonAttributes(buffer, initialFormat);
-            if (header != null)
-            {
-                header.ReadMagicAttribute(buffer);
-                if (header._format != TarEntryFormat.V7)
-                {
-                    header.ReadVersionAttribute(buffer);
-                    header.ReadPosixAndGnuSharedAttributes(buffer);
-                    Debug.Assert(header._format is TarEntryFormat.Ustar or TarEntryFormat.Pax or TarEntryFormat.Gnu);
-                    if (header._format == TarEntryFormat.Ustar)
-                    {
-                        header.ReadUstarAttributes(buffer);
-                    }
-                    else if (header._format == TarEntryFormat.Gnu)
-                    {
-                        header.ReadGnuAttributes(buffer);
-                    }
-                }
-            }
-            return header;
-        }
-        internal void ReplaceNormalAttributesWithExtended(Dictionary<string, string>? dictionaryFromExtendedAttributesHeader)
-        {
-            if (dictionaryFromExtendedAttributesHeader == null || dictionaryFromExtendedAttributesHeader.Count == 0)
-            {
-                return;
-            }
-            InitializeExtendedAttributesWithExisting(dictionaryFromExtendedAttributesHeader);
-            if (ExtendedAttributes.TryGetValue(PaxEaName, out string? paxEaName))
-            {
-                _name = paxEaName;
-            }
-            if (ExtendedAttributes.TryGetValue(PaxEaLinkName, out string? paxEaLinkName))
-            {
-                _linkName = paxEaLinkName;
-            }
-            if (TarHelpers.TryGetDateTimeOffsetFromTimestampString(ExtendedAttributes, PaxEaMTime, out DateTimeOffset mTime))
-            {
-                _mTime = mTime;
-            }
-            if (TarHelpers.TryGetStringAsBaseTenInteger(ExtendedAttributes, PaxEaMode, out int mode))
-            {
-                _mode = mode;
-            }
-            if (TarHelpers.TryGetStringAsBaseTenLong(ExtendedAttributes, PaxEaSize, out long size))
-            {
-                _size = size;
-            }
-            if (TarHelpers.TryGetStringAsBaseTenInteger(ExtendedAttributes, PaxEaUid, out int uid))
-            {
-                _uid = uid;
-            }
-            if (TarHelpers.TryGetStringAsBaseTenInteger(ExtendedAttributes, PaxEaGid, out int gid))
-            {
-                _gid = gid;
-            }
-            if (ExtendedAttributes.TryGetValue(PaxEaUName, out string? paxEaUName))
-            {
-                _uName = paxEaUName;
-            }
-            if (ExtendedAttributes.TryGetValue(PaxEaGName, out string? paxEaGName))
-            {
-                _gName = paxEaGName;
-            }
-            if (TarHelpers.TryGetStringAsBaseTenInteger(ExtendedAttributes, PaxEaDevMajor, out int devMajor))
-            {
-                _devMajor = devMajor;
-            }
-            if (TarHelpers.TryGetStringAsBaseTenInteger(ExtendedAttributes, PaxEaDevMinor, out int devMinor))
-            {
-                _devMinor = devMinor;
-            }
-        }
-        internal void ProcessDataBlock(Stream archiveStream, bool copyData)
-        {
-            bool skipBlockAlignmentPadding = true;
-            switch (_typeFlag)
-            {
-                case TarEntryType.ExtendedAttributes or TarEntryType.GlobalExtendedAttributes:
-                    ReadExtendedAttributesBlock(archiveStream);
-                    break;
-                case TarEntryType.LongLink or TarEntryType.LongPath:
-                    ReadGnuLongPathDataBlock(archiveStream);
-                    break;
-                case TarEntryType.BlockDevice:
-                case TarEntryType.CharacterDevice:
-                case TarEntryType.Directory:
-                case TarEntryType.Fifo:
-                case TarEntryType.HardLink:
-                case TarEntryType.SymbolicLink:
-                    if (_size > 0)
-                    {
-                        throw new InvalidDataException(string.Format(SR.TarSizeFieldTooLargeForEntryType, _typeFlag));
-                    }
-                    break;
-                case TarEntryType.RegularFile:
-                case TarEntryType.V7RegularFile: // Treated as regular file
-                case TarEntryType.ContiguousFile: // Treated as regular file
-                case TarEntryType.DirectoryList: // Contains the list of filesystem entries in the data section
-                case TarEntryType.MultiVolume: // Contains portion of a file
-                case TarEntryType.RenamedOrSymlinked: // Might contain data
-                case TarEntryType.SparseFile: // Contains portion of a file
-                case TarEntryType.TapeVolume: // Might contain data
-                default: // Unrecognized entry types could potentially have a data section
-                    _dataStream = GetDataStream(archiveStream, copyData);
-                    if (_dataStream is SeekableSubReadStream)
-                    {
-                        TarHelpers.AdvanceStream(archiveStream, _size);
-                    }
-                    else if (_dataStream is SubReadStream)
-                    {
-                        skipBlockAlignmentPadding = false;
-                    }
-                    break;
-            }
-            if (skipBlockAlignmentPadding)
-            {
-                if (_size > 0)
-                {
-                    TarHelpers.SkipBlockAlignmentPadding(archiveStream, _size);
-                }
-                if (archiveStream.CanSeek)
-                {
-                    _endOfHeaderAndDataAndBlockAlignment = archiveStream.Position;
-                }
-            }
-        }
-        private async Task ProcessDataBlockAsync(Stream archiveStream, bool copyData, CancellationToken cancellationToken)
-        {
-            bool skipBlockAlignmentPadding = true;
-            switch (_typeFlag)
-            {
-                case TarEntryType.ExtendedAttributes or TarEntryType.GlobalExtendedAttributes:
-                    await ReadExtendedAttributesBlockAsync(archiveStream, cancellationToken).ConfigureAwait(false);
-                    break;
-                case TarEntryType.LongLink or TarEntryType.LongPath:
-                    await ReadGnuLongPathDataBlockAsync(archiveStream, cancellationToken).ConfigureAwait(false);
-                    break;
-                case TarEntryType.BlockDevice:
-                case TarEntryType.CharacterDevice:
-                case TarEntryType.Directory:
-                case TarEntryType.Fifo:
-                case TarEntryType.HardLink:
-                case TarEntryType.SymbolicLink:
-                    if (_size > 0)
-                    {
-                        throw new InvalidDataException(string.Format(SR.TarSizeFieldTooLargeForEntryType, _typeFlag));
-                    }
-                    break;
-                case TarEntryType.RegularFile:
-                case TarEntryType.V7RegularFile: // Treated as regular file
-                case TarEntryType.ContiguousFile: // Treated as regular file
-                case TarEntryType.DirectoryList: // Contains the list of filesystem entries in the data section
-                case TarEntryType.MultiVolume: // Contains portion of a file
-                case TarEntryType.RenamedOrSymlinked: // Might contain data
-                case TarEntryType.SparseFile: // Contains portion of a file
-                case TarEntryType.TapeVolume: // Might contain data
-                default: // Unrecognized entry types could potentially have a data section
-                    _dataStream = await GetDataStreamAsync(archiveStream, copyData, _size, cancellationToken).ConfigureAwait(false);
-                    if (_dataStream is SeekableSubReadStream)
-                    {
-                        await TarHelpers.AdvanceStreamAsync(archiveStream, _size, cancellationToken).ConfigureAwait(false);
-                    }
-                    else if (_dataStream is SubReadStream)
-                    {
-                        skipBlockAlignmentPadding = false;
-                    }
-                    break;
-            }
-            if (skipBlockAlignmentPadding)
-            {
-                if (_size > 0)
-                {
-                    await TarHelpers.SkipBlockAlignmentPaddingAsync(archiveStream, _size, cancellationToken).ConfigureAwait(false);
-                }
-                if (archiveStream.CanSeek)
-                {
-                    _endOfHeaderAndDataAndBlockAlignment = archiveStream.Position;
-                }
-            }
-        }
-        private Stream? GetDataStream(Stream archiveStream, bool copyData)
-        {
-            if (_size == 0)
-            {
-                return null;
-            }
-            if (copyData)
-            {
-                MemoryStream copiedData = new MemoryStream();
-                TarHelpers.CopyBytes(archiveStream, copiedData, _size);
-                copiedData.Position = 0;
-                return copiedData;
-            }
-            return archiveStream.CanSeek
-                ? new SeekableSubReadStream(archiveStream, archiveStream.Position, _size)
-                : new SubReadStream(archiveStream, 0, _size);
-        }
-        private static async ValueTask<Stream?> GetDataStreamAsync(Stream archiveStream, bool copyData, long size, CancellationToken cancellationToken)
-        {
-            cancellationToken.ThrowIfCancellationRequested();
-            if (size == 0)
-            {
-                return null;
-            }
-            if (copyData)
-            {
-                MemoryStream copiedData = new MemoryStream();
-                await TarHelpers.CopyBytesAsync(archiveStream, copiedData, size, cancellationToken).ConfigureAwait(false);
-                copiedData.Position = 0;
-                return copiedData;
-            }
-            return archiveStream.CanSeek
-                ? new SeekableSubReadStream(archiveStream, archiveStream.Position, size)
-                : new SubReadStream(archiveStream, 0, size);
-        }
-        private static TarHeader? TryReadCommonAttributes(Span<byte> buffer, TarEntryFormat initialFormat)
-        {
-            Span<byte> spanChecksum = buffer.Slice(FieldLocations.Checksum, FieldLengths.Checksum);
-            if (TarHelpers.IsAllNullBytes(spanChecksum))
-            {
-                return null;
-            }
-            int checksum = (int)TarHelpers.ParseOctal<uint>(spanChecksum);
-            if (checksum == 0)
-            {
-                return null;
-            }
-            long size = (long)TarHelpers.ParseOctal<ulong>(buffer.Slice(FieldLocations.Size, FieldLengths.Size));
-            Debug.Assert(size <= TarHelpers.MaxSizeLength, "size exceeded the max value possible with 11 octal digits. Actual size " + size);
-            if (size < 0)
-            {
-                throw new InvalidDataException(string.Format(SR.TarSizeFieldNegative));
-            }
-            TarHeader header = new(initialFormat,
-                name: TarHelpers.GetTrimmedUtf8String(buffer.Slice(FieldLocations.Name, FieldLengths.Name)),
-                mode: (int)TarHelpers.ParseOctal<uint>(buffer.Slice(FieldLocations.Mode, FieldLengths.Mode)),
-                mTime: TarHelpers.GetDateTimeOffsetFromSecondsSinceEpoch((long)TarHelpers.ParseOctal<ulong>(buffer.Slice(FieldLocations.MTime, FieldLengths.MTime))),
-                typeFlag: (TarEntryType)buffer[FieldLocations.TypeFlag])
-            {
-                _checksum = checksum,
-                _size = size,
-                _uid = (int)TarHelpers.ParseOctal<uint>(buffer.Slice(FieldLocations.Uid, FieldLengths.Uid)),
-                _gid = (int)TarHelpers.ParseOctal<uint>(buffer.Slice(FieldLocations.Gid, FieldLengths.Gid)),
-                _linkName = TarHelpers.GetTrimmedUtf8String(buffer.Slice(FieldLocations.LinkName, FieldLengths.LinkName))
-            };
-            if (header._format == TarEntryFormat.Unknown)
-            {
-                header._format = header._typeFlag switch
-                {
-                    TarEntryType.ExtendedAttributes or
-                    TarEntryType.GlobalExtendedAttributes => TarEntryFormat.Pax,
-                    TarEntryType.DirectoryList or
-                    TarEntryType.LongLink or
-                    TarEntryType.LongPath or
-                    TarEntryType.MultiVolume or
-                    TarEntryType.RenamedOrSymlinked or
-                    TarEntryType.TapeVolume => TarEntryFormat.Gnu,
-                    TarEntryType.V7RegularFile => TarEntryFormat.V7,
-                    TarEntryType.SparseFile => throw new NotSupportedException(string.Format(SR.TarEntryTypeNotSupported, header._typeFlag)),
-                    _ => (header._typeFlag == TarEntryType.RegularFile) ? TarEntryFormat.Ustar : TarEntryFormat.V7
-                };
-            }
-            return header;
-        }
-        private void ReadMagicAttribute(Span<byte> buffer)
-        {
-            Span<byte> magic = buffer.Slice(FieldLocations.Magic, FieldLengths.Magic);
-            if (TarHelpers.IsAllNullBytes(magic))
-            {
-                _format = TarEntryFormat.V7;
-                return;
-            }
-            if (magic.SequenceEqual(GnuMagicBytes))
-            {
-                _magic = GnuMagic;
-                _format = TarEntryFormat.Gnu;
-            }
-            else if (magic.SequenceEqual(UstarMagicBytes))
-            {
-                _magic = UstarMagic;
-                if (_format == TarEntryFormat.V7)
-                {
-                    _format = TarEntryFormat.Ustar;
-                }
-            }
-            else
-            {
-                _magic = Encoding.ASCII.GetString(magic);
-            }
-        }
-        private void ReadVersionAttribute(Span<byte> buffer)
-        {
-            if (_format == TarEntryFormat.V7)
-            {
-                return;
-            }
-            Span<byte> version = buffer.Slice(FieldLocations.Version, FieldLengths.Version);
-            switch (_format)
-            {
-                case TarEntryFormat.Ustar or TarEntryFormat.Pax:
-                    if (!version.SequenceEqual(UstarVersionBytes))
-                    {
-                        if (!version.SequenceEqual(GnuVersionBytes))
-                        {
-                            throw new InvalidDataException(string.Format(SR.TarPosixFormatExpected, _name));
-                        }
-                        _version = GnuVersion;
-                    }
-                    else
-                    {
-                        _version = UstarVersion;
-                    }
-                    break;
-                case TarEntryFormat.Gnu:
-                    if (!version.SequenceEqual(GnuVersionBytes))
-                    {
-                        if (!version.SequenceEqual(UstarVersionBytes))
-                        {
-                            throw new InvalidDataException(string.Format(SR.TarGnuFormatExpected, _name));
-                        }
-                        _version = UstarVersion;
-                    }
-                    else
-                    {
-                        _version = GnuVersion;
-                    }
-                    break;
-                default:
-                    _version = Encoding.ASCII.GetString(version);
-                    break;
-            }
-        }
-        private void ReadPosixAndGnuSharedAttributes(Span<byte> buffer)
-        {
-            _uName = TarHelpers.GetTrimmedUtf8String(buffer.Slice(FieldLocations.UName, FieldLengths.UName));
-            _gName = TarHelpers.GetTrimmedUtf8String(buffer.Slice(FieldLocations.GName, FieldLengths.GName));
-            if (_typeFlag is TarEntryType.CharacterDevice or TarEntryType.BlockDevice)
-            {
-                _devMajor = (int)TarHelpers.ParseOctal<uint>(buffer.Slice(FieldLocations.DevMajor, FieldLengths.DevMajor));
-                _devMinor = (int)TarHelpers.ParseOctal<uint>(buffer.Slice(FieldLocations.DevMinor, FieldLengths.DevMinor));
-            }
-        }
-        private void ReadGnuAttributes(Span<byte> buffer)
-        {
-            long aTime = (long)TarHelpers.ParseOctal<ulong>(buffer.Slice(FieldLocations.ATime, FieldLengths.ATime));
-            _aTime = TarHelpers.GetDateTimeOffsetFromSecondsSinceEpoch(aTime);
-            long cTime = (long)TarHelpers.ParseOctal<ulong>(buffer.Slice(FieldLocations.CTime, FieldLengths.CTime));
-            _cTime = TarHelpers.GetDateTimeOffsetFromSecondsSinceEpoch(cTime);
-        }
-        private void ReadUstarAttributes(Span<byte> buffer)
-        {
-            _prefix = TarHelpers.GetTrimmedUtf8String(buffer.Slice(FieldLocations.Prefix, FieldLengths.Prefix));
-            if (!string.IsNullOrEmpty(_prefix))
-            {
-                _name = string.Format(UstarPrefixFormat, _prefix, _name);
-            }
-        }
-        private void ReadExtendedAttributesBlock(Stream archiveStream)
-        {
-            if (_size != 0)
-            {
-                ValidateSize();
-                byte[]? buffer = null;
-                Span<byte> span = _size <= 256 ?
-                    stackalloc byte[256] :
-                    (buffer = ArrayPool<byte>.Shared.Rent((int)_size));
-                span = span.Slice(0, (int)_size);
-                archiveStream.ReadExactly(span);
-                ReadExtendedAttributesFromBuffer(span, _name);
-                if (buffer is not null)
-                {
-                    ArrayPool<byte>.Shared.Return(buffer);
-                }
-            }
-        }
-        private async ValueTask ReadExtendedAttributesBlockAsync(Stream archiveStream, CancellationToken cancellationToken)
-        {
-            cancellationToken.ThrowIfCancellationRequested();
-            if (_size != 0)
-            {
-                ValidateSize();
-                byte[] buffer = ArrayPool<byte>.Shared.Rent((int)_size);
-                Memory<byte> memory = buffer.AsMemory(0, (int)_size);
-                await archiveStream.ReadExactlyAsync(memory, cancellationToken).ConfigureAwait(false);
-                ReadExtendedAttributesFromBuffer(memory.Span, _name);
-                ArrayPool<byte>.Shared.Return(buffer);
-            }
-        }
-        private void ValidateSize()
-        {
-            if ((uint)_size > (uint)Array.MaxLength)
-            {
-                ThrowSizeFieldTooLarge();
-            }
-            [DoesNotReturn]
-            void ThrowSizeFieldTooLarge() =>
-                throw new InvalidOperationException(string.Format(SR.TarSizeFieldTooLargeForEntryType, _typeFlag.ToString()));
-        }
-        private void ReadExtendedAttributesFromBuffer(ReadOnlySpan<byte> buffer, string name)
-        {
-            buffer = TarHelpers.TrimEndingNullsAndSpaces(buffer);
-            while (TryGetNextExtendedAttribute(ref buffer, out string? key, out string? value))
-            {
-                if (!ExtendedAttributes.TryAdd(key, value))
-                {
-                    throw new InvalidDataException(string.Format(SR.TarDuplicateExtendedAttribute, name));
-                }
-            }
-        }
-        private void ReadGnuLongPathDataBlock(Stream archiveStream)
-        {
-            if (_size != 0)
-            {
-                ValidateSize();
-                byte[]? buffer = null;
-                Span<byte> span = _size <= 256 ?
-                    stackalloc byte[256] :
-                    (buffer = ArrayPool<byte>.Shared.Rent((int)_size));
-                span = span.Slice(0, (int)_size);
-                archiveStream.ReadExactly(span);
-                ReadGnuLongPathDataFromBuffer(span);
-                if (buffer is not null)
-                {
-                    ArrayPool<byte>.Shared.Return(buffer);
-                }
-            }
-        }
-        private async ValueTask ReadGnuLongPathDataBlockAsync(Stream archiveStream, CancellationToken cancellationToken)
-        {
-            cancellationToken.ThrowIfCancellationRequested();
-            if (_size != 0)
-            {
-                ValidateSize();
-                byte[] buffer = ArrayPool<byte>.Shared.Rent((int)_size);
-                Memory<byte> memory = buffer.AsMemory(0, (int)_size);
-                await archiveStream.ReadExactlyAsync(memory, cancellationToken).ConfigureAwait(false);
-                ReadGnuLongPathDataFromBuffer(memory.Span);
-                ArrayPool<byte>.Shared.Return(buffer);
-            }
-        }
-        private void ReadGnuLongPathDataFromBuffer(ReadOnlySpan<byte> buffer)
-        {
-            string longPath = TarHelpers.GetTrimmedUtf8String(buffer);
-            if (_typeFlag == TarEntryType.LongLink)
-            {
-                _linkName = longPath;
-            }
-            else if (_typeFlag == TarEntryType.LongPath)
-            {
-                _name = longPath;
-            }
-        }
-        private static bool TryGetNextExtendedAttribute(
-            ref ReadOnlySpan<byte> buffer,
-            [NotNullWhen(returnValue: true)] out string? key,
-            [NotNullWhen(returnValue: true)] out string? value)
-        {
-            key = null;
-            value = null;
-            int newlinePos = buffer.IndexOf((byte)'\n');
-            if (newlinePos < 0)
-            {
-                return false;
-            }
-            ReadOnlySpan<byte> line = buffer.Slice(0, newlinePos);
-            buffer = buffer.Slice(newlinePos + 1);
-            int spacePos = line.IndexOf((byte)' ');
-            if (spacePos < 0)
-            {
-                return false;
-            }
-            line = line.Slice(spacePos + 1);
-            int equalPos = line.IndexOf((byte)'=');
-            if (equalPos < 0)
-            {
-                return false;
-            }
-            ReadOnlySpan<byte> keySlice = line.Slice(0, equalPos);
-            ReadOnlySpan<byte> valueSlice = line.Slice(equalPos + 1);
-            key = Encoding.UTF8.GetString(keySlice);
-            value = Encoding.UTF8.GetString(valueSlice);
-            return true;
-        }
-    }
-}

--- a/src/libraries/System.Management/src/System/Management/ManagementScope.cs
+++ b//dev/null
@@ -1,1105 +0,0 @@
-using System.ComponentModel;
-using System.Runtime.InteropServices;
-using System.Globalization;
-using System.IO;
-using System.Reflection;
-using System.ComponentModel.Design.Serialization;
-using System.Security;
-using Microsoft.Win32;
-namespace System.Management
-{
-    internal static class CompatSwitches
-    {
-        internal const string DotNetVersion = "v4.0.30319";
-        private const string RegKeyLocation = @"SOFTWARE\Microsoft\.NETFramework\" + DotNetVersion;
-        private static readonly object s_syncLock = new object();
-        private static int s_allowManagementObjectQI;
-        private const string c_WMIDisableCOMSecurity = "WMIDisableCOMSecurity";
-        public static bool AllowIManagementObjectQI
-        {
-            get
-            {
-                if (s_allowManagementObjectQI == 0)
-                {
-                    lock (s_syncLock)
-                    {
-                        if (s_allowManagementObjectQI == 0)
-                        {
-                            s_allowManagementObjectQI = GetSwitchValueFromRegistry() ? 1 : -1;
-                        }
-                    }
-                }
-                return s_allowManagementObjectQI == 1 ? true : false;
-            }
-        }
-        private static bool GetSwitchValueFromRegistry()
-        {
-            RegistryKey s_switchesRegKey = null;
-            try
-            {
-                s_switchesRegKey = Registry.LocalMachine.OpenSubKey(RegKeyLocation);
-                if (s_switchesRegKey == null)
-                {
-                    return false;
-                }
-                return ((int)s_switchesRegKey.GetValue(c_WMIDisableCOMSecurity, -1 /* default */) == 1);
-            }
-            catch (Exception e)
-            {
-                if (e is StackOverflowException ||
-                    e is OutOfMemoryException ||
-                    e is System.Threading.ThreadAbortException ||
-                    e is AccessViolationException)
-                    throw;
-            }
-            finally
-            {
-                s_switchesRegKey?.Dispose();
-            }
-            return false;
-        }
-    }
-    internal static class WmiNetUtilsHelper
-    {
-        internal delegate int ResetSecurity(IntPtr hToken);
-        internal delegate int SetSecurity([In][Out] ref bool pNeedtoReset, [In][Out] ref IntPtr pHandle);
-        internal delegate int BlessIWbemServices([MarshalAs(UnmanagedType.Interface)] IWbemServices pIUnknown,
-                                                                        [In][MarshalAs(UnmanagedType.BStr)]  string strUser,
-                                                                        IntPtr password,
-                                                                        [In][MarshalAs(UnmanagedType.BStr)]  string strAuthority,
-                                                                        int impersonationLevel,
-                                                                        int authenticationLevel);
-        internal delegate int BlessIWbemServicesObject([MarshalAs(UnmanagedType.IUnknown)] object pIUnknown,
-                                                                        [In][MarshalAs(UnmanagedType.BStr)]  string strUser,
-                                                                        IntPtr password,
-                                                                        [In][MarshalAs(UnmanagedType.BStr)]  string strAuthority,
-                                                                        int impersonationLevel,
-                                                                        int authenticationLevel);
-        internal delegate int GetPropertyHandle(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszPropertyName, [Out] out int pType, [Out] out int plHandle);
-        internal delegate int WritePropertyValue(int vFunc, IntPtr pWbemClassObject, [In] int lHandle, [In] int lNumBytes, [In][MarshalAs(UnmanagedType.LPWStr)] string str);
-        internal delegate int GetQualifierSet(int vFunc, IntPtr pWbemClassObject, [Out] out IntPtr ppQualSet);
-        internal delegate int Get(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszName, [In] int lFlags, [In][Out] ref object pVal, [In][Out] ref int pType, [In][Out] ref int plFlavor);
-        internal delegate int Put(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszName, [In] int lFlags, [In] ref object pVal, [In] int Type);
-        internal delegate int Delete(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszName);
-        internal delegate int GetNames(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszQualifierName, [In] int lFlags, [In] ref object pQualifierVal, [Out][MarshalAs(UnmanagedType.SafeArray, SafeArraySubType = VarEnum.VT_BSTR)]  out string[] pNames);
-        internal delegate int BeginEnumeration(int vFunc, IntPtr pWbemClassObject, [In] int lEnumFlags);
-        internal delegate int Next(int vFunc, IntPtr pWbemClassObject, [In] int lFlags, [In][Out][MarshalAs(UnmanagedType.BStr)]  ref string strName, [In][Out] ref object pVal, [In][Out] ref int pType, [In][Out] ref int plFlavor);
-        internal delegate int EndEnumeration(int vFunc, IntPtr pWbemClassObject);
-        internal delegate int GetPropertyQualifierSet(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszProperty, [Out] out IntPtr ppQualSet);
-        internal delegate int Clone(int vFunc, IntPtr pWbemClassObject, [Out] out IntPtr ppCopy);
-        internal delegate int GetObjectText(int vFunc, IntPtr pWbemClassObject, [In] int lFlags, [Out][MarshalAs(UnmanagedType.BStr)]  out string pstrObjectText);
-        internal delegate int SpawnDerivedClass(int vFunc, IntPtr pWbemClassObject, [In] int lFlags, [Out] out IntPtr ppNewClass);
-        internal delegate int SpawnInstance(int vFunc, IntPtr pWbemClassObject, [In] int lFlags, [Out] out IntPtr ppNewInstance);
-        internal delegate int CompareTo(int vFunc, IntPtr pWbemClassObject, [In] int lFlags, [In] IntPtr pCompareTo);
-        internal delegate int GetPropertyOrigin(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszName, [Out][MarshalAs(UnmanagedType.BStr)]  out string pstrClassName);
-        internal delegate int InheritsFrom(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string strAncestor);
-        internal delegate int GetMethod(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszName, [In] int lFlags, [Out]out IntPtr ppInSignature, [Out] out IntPtr ppOutSignature);
-        internal delegate int PutMethod(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszName, [In] int lFlags, [In] IntPtr pInSignature, [In] IntPtr pOutSignature);
-        internal delegate int DeleteMethod(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszName);
-        internal delegate int BeginMethodEnumeration(int vFunc, IntPtr pWbemClassObject, [In] int lEnumFlags);
-        internal delegate int NextMethod(int vFunc, IntPtr pWbemClassObject, [In] int lFlags, [Out][MarshalAs(UnmanagedType.BStr)] out string pstrName, [Out] out IntPtr ppInSignature, [Out] out IntPtr ppOutSignature);
-        internal delegate int EndMethodEnumeration(int vFunc, IntPtr pWbemClassObject);
-        internal delegate int GetMethodQualifierSet(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszMethod, [Out] out IntPtr ppQualSet);
-        internal delegate int GetMethodOrigin(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszMethodName, [Out][MarshalAs(UnmanagedType.BStr)]  out string pstrClassName);
-        internal delegate int QualifierSet_Get(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszName, [In] int lFlags, [In][Out] ref object pVal, [In][Out] ref int plFlavor);
-        internal delegate int QualifierSet_Put(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszName, [In] ref object pVal, [In] int lFlavor);
-        internal delegate int QualifierSet_Delete(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszName);
-        internal delegate int QualifierSet_GetNames(int vFunc, IntPtr pWbemClassObject, [In] int lFlags, [Out][MarshalAs(UnmanagedType.SafeArray, SafeArraySubType = VarEnum.VT_BSTR)]  out string[] pNames);
-        internal delegate int QualifierSet_BeginEnumeration(int vFunc, IntPtr pWbemClassObject, [In] int lFlags);
-        internal delegate int QualifierSet_Next(int vFunc, IntPtr pWbemClassObject, [In] int lFlags, [Out][MarshalAs(UnmanagedType.BStr)]  out string pstrName, [Out] out object pVal, [Out] out int plFlavor);
-        internal delegate int QualifierSet_EndEnumeration(int vFunc, IntPtr pWbemClassObject);
-        internal delegate int GetCurrentApartmentType(int vFunc, IntPtr pComThreadingInfo, [Out] out APTTYPE aptType);
-        internal delegate void VerifyClientKey();
-        internal delegate int GetDemultiplexedStub([In, MarshalAs(UnmanagedType.IUnknown)]object pIUnknown, [In]bool isLocal, [Out, MarshalAs(UnmanagedType.IUnknown)]out object ppIUnknown);
-        internal delegate int CreateInstanceEnumWmi([In][MarshalAs(UnmanagedType.BStr)]  string strFilter,
-                                                                                           [In] int lFlags,
-                                                                                           [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext pCtx,
-                                                                                           [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject ppEnum,
-                                                                                           [In] int impLevel,
-                                                                                           [In] int authnLevel,
-                                                                                           [In] [MarshalAs(UnmanagedType.Interface)] IWbemServices pCurrentNamespace,
-                                                                                           [In][MarshalAs(UnmanagedType.BStr)]  string strUser,
-                                                                                           [In]IntPtr strPassword,
-                                                                                           [In][MarshalAs(UnmanagedType.BStr)]  string strAuthority
-                                                                                           );
-        internal delegate int CreateClassEnumWmi([In][MarshalAs(UnmanagedType.BStr)]  string strSuperclass,
-                                                                                       [In] int lFlags,
-                                                                                       [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext pCtx,
-                                                                                       [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject ppEnum,
-                                                                                       [In] int impLevel,
-                                                                                       [In] int authnLevel,
-                                                                                       [In] [MarshalAs(UnmanagedType.Interface)] IWbemServices pCurrentNamespace,
-                                                                                       [In][MarshalAs(UnmanagedType.BStr)]  string strUser,
-                                                                                       [In]IntPtr strPassword,
-                                                                                       [In][MarshalAs(UnmanagedType.BStr)]  string strAuthority
-                                                                                       );
-        internal delegate int ExecQueryWmi([In][MarshalAs(UnmanagedType.BStr)]  string strQueryLanguage,
-                                                                           [In][MarshalAs(UnmanagedType.BStr)]  string strQuery,
-                                                                           [In] int lFlags,
-                                                                           [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext pCtx,
-                                                                           [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject ppEnum,
-                                                                           [In] int impLevel,
-                                                                           [In] int authnLevel,
-                                                                           [In] [MarshalAs(UnmanagedType.Interface)] IWbemServices pCurrentNamespace,
-                                                                           [In][MarshalAs(UnmanagedType.BStr)]  string strUser,
-                                                                           [In]IntPtr strPassword,
-                                                                           [In][MarshalAs(UnmanagedType.BStr)]  string strAuthority
-                                                                           );
-        internal delegate int ExecNotificationQueryWmi([In][MarshalAs(UnmanagedType.BStr)]  string strQueryLanguage,
-                                                                                                [In][MarshalAs(UnmanagedType.BStr)]  string strQuery,
-                                                                                                [In] int lFlags,
-                                                                                                [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext pCtx,
-                                                                                                [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject ppEnum,
-                                                                                                [In] int impLevel,
-                                                                                                [In] int authnLevel,
-                                                                                                [In] [MarshalAs(UnmanagedType.Interface)] IWbemServices pCurrentNamespace,
-                                                                                                [In][MarshalAs(UnmanagedType.BStr)]  string strUser,
-                                                                                                [In]IntPtr strPassword,
-                                                                                                [In][MarshalAs(UnmanagedType.BStr)]  string strAuthority
-                                                                                                );
-        internal delegate int PutInstanceWmi([In] IntPtr pInst,
-                                                                            [In] int lFlags,
-                                                                            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext pCtx,
-                                                                            [In] IntPtr ppCallResult,
-                                                                            [In] int impLevel,
-                                                                            [In] int authnLevel,
-                                                                            [In] [MarshalAs(UnmanagedType.Interface)] IWbemServices pCurrentNamespace,
-                                                                            [In][MarshalAs(UnmanagedType.BStr)]  string strUser,
-                                                                            [In]IntPtr strPassword,
-                                                                            [In][MarshalAs(UnmanagedType.BStr)]  string strAuthority
-                                                                            );
-        internal delegate int PutClassWmi([In] IntPtr pObject,
-                                                                        [In] int lFlags,
-                                                                        [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext pCtx,
-                                                                        [In] IntPtr ppCallResult,
-                                                                        [In] int impLevel,
-                                                                        [In] int authnLevel,
-                                                                        [In] [MarshalAs(UnmanagedType.Interface)] IWbemServices pCurrentNamespace,
-                                                                        [In][MarshalAs(UnmanagedType.BStr)]  string strUser,
-                                                                        [In]IntPtr strPassword,
-                                                                        [In][MarshalAs(UnmanagedType.BStr)]  string strAuthority
-                                                                        );
-        internal delegate int CloneEnumWbemClassObject(
-                                                                [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject ppEnum,
-                                                                [In] int impLevel,
-                                                                [In] int authnLevel,
-                                                                [In] [MarshalAs(UnmanagedType.Interface)] IEnumWbemClassObject pCurrentEnumWbemClassObject,
-                                                                [In][MarshalAs(UnmanagedType.BStr)]  string strUser,
-                                                                [In]IntPtr strPassword,
-                                                                [In][MarshalAs(UnmanagedType.BStr)]  string strAuthority
-                                                                );
-        internal delegate int ConnectServerWmi(
-                                                                        [In][MarshalAs(UnmanagedType.BStr)]  string strNetworkResource,
-                                                                        [In][MarshalAs(UnmanagedType.BStr)]  string strUser,
-                                                                        [In]  IntPtr strPassword,
-                                                                        [In][MarshalAs(UnmanagedType.BStr)]  string strLocale,
-                                                                        [In] int lSecurityFlags,
-                                                                        [In][MarshalAs(UnmanagedType.BStr)]  string strAuthority,
-                                                                        [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext pCtx,
-                                                                        [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemServices ppNamespace,
-                                                                        int impersonationLevel,
-                                                                        int authenticationLevel);
-        internal delegate IntPtr GetErrorInfo();
-        internal delegate int Initialize([In]bool AllowIManagementObjectQI);
-        internal enum APTTYPE
-        {
-            APTTYPE_CURRENT = -1,
-            APTTYPE_STA = 0,
-            APTTYPE_MTA = 1,
-            APTTYPE_NA = 2,
-            APTTYPE_MAINSTA = 3
-        }
-        internal static ResetSecurity ResetSecurity_f;
-        internal static SetSecurity SetSecurity_f;
-        internal static BlessIWbemServices BlessIWbemServices_f;
-        internal static BlessIWbemServicesObject BlessIWbemServicesObject_f;
-        internal static GetPropertyHandle GetPropertyHandle_f27;
-        internal static WritePropertyValue WritePropertyValue_f28;
-        internal static GetQualifierSet GetQualifierSet_f;
-        internal static Get Get_f;
-        internal static Put Put_f;
-        internal static Delete Delete_f;
-        internal static GetNames GetNames_f;
-        internal static BeginEnumeration BeginEnumeration_f;
-        internal static Next Next_f;
-        internal static EndEnumeration EndEnumeration_f;
-        internal static GetPropertyQualifierSet GetPropertyQualifierSet_f;
-        internal static Clone Clone_f;
-        internal static GetObjectText GetObjectText_f;
-        internal static SpawnDerivedClass SpawnDerivedClass_f;
-        internal static SpawnInstance SpawnInstance_f;
-        internal static CompareTo CompareTo_f;
-        internal static GetPropertyOrigin GetPropertyOrigin_f;
-        internal static InheritsFrom InheritsFrom_f;
-        internal static GetMethod GetMethod_f;
-        internal static PutMethod PutMethod_f;
-        internal static DeleteMethod DeleteMethod_f;
-        internal static BeginMethodEnumeration BeginMethodEnumeration_f;
-        internal static NextMethod NextMethod_f;
-        internal static EndMethodEnumeration EndMethodEnumeration_f;
-        internal static GetMethodQualifierSet GetMethodQualifierSet_f;
-        internal static GetMethodOrigin GetMethodOrigin_f;
-        internal static QualifierSet_Get QualifierGet_f;
-        internal static QualifierSet_Put QualifierPut_f;
-        internal static QualifierSet_Delete QualifierDelete_f;
-        internal static QualifierSet_GetNames QualifierGetNames_f;
-        internal static QualifierSet_BeginEnumeration QualifierBeginEnumeration_f;
-        internal static QualifierSet_Next QualifierNext_f;
-        internal static QualifierSet_EndEnumeration QualifierEndEnumeration_f;
-        internal static GetCurrentApartmentType GetCurrentApartmentType_f;
-        internal static VerifyClientKey VerifyClientKey_f;
-        internal static Clone Clone_f12;
-        internal static GetDemultiplexedStub GetDemultiplexedStub_f;
-        internal static CreateInstanceEnumWmi CreateInstanceEnumWmi_f;
-        internal static CreateClassEnumWmi CreateClassEnumWmi_f;
-        internal static ExecQueryWmi ExecQueryWmi_f;
-        internal static ExecNotificationQueryWmi ExecNotificationQueryWmi_f;
-        internal static PutInstanceWmi PutInstanceWmi_f;
-        internal static PutClassWmi PutClassWmi_f;
-        internal static CloneEnumWbemClassObject CloneEnumWbemClassObject_f;
-        internal static ConnectServerWmi ConnectServerWmi_f;
-        internal static GetErrorInfo GetErrorInfo_f;
-        internal static Initialize Initialize_f;
-        static WmiNetUtilsHelper()
-        {
-            RegistryKey netFrameworkSubKey = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\.NETFramework\");
-            string netFrameworkInstallRoot = (string)netFrameworkSubKey?.GetValue(RuntimeInformation.ProcessArchitecture == Architecture.Arm64 ?
-                "InstallRootArm64" :
-                "InstallRoot");
-            if (netFrameworkInstallRoot == null)
-            {
-                LoadPlatformNotSupportedDelegates(SR.PlatformNotSupported_FullFrameworkRequired);
-                return;
-            }
-            string wminet_utilsPath = Path.Combine(
-                netFrameworkInstallRoot,
-                CompatSwitches.DotNetVersion, // The same value is hard coded on Environment.Version and quirks for WMI
-                "wminet_utils.dll");
-            IntPtr hModule = Interop.Kernel32.LoadLibrary(wminet_utilsPath);
-            if (hModule == IntPtr.Zero)
-            {
-                throw new Win32Exception(Marshal.GetLastWin32Error(), SR.Format(SR.LoadLibraryFailed, wminet_utilsPath));
-            }
-            if (LoadDelegate(ref ResetSecurity_f, hModule, "ResetSecurity") &&
-                LoadDelegate(ref SetSecurity_f, hModule, "SetSecurity") &&
-                LoadDelegate(ref BlessIWbemServices_f, hModule, "BlessIWbemServices") &&
-                LoadDelegate(ref BlessIWbemServicesObject_f, hModule, "BlessIWbemServicesObject") &&
-                LoadDelegate(ref GetPropertyHandle_f27, hModule, "GetPropertyHandle") &&
-                LoadDelegate(ref WritePropertyValue_f28, hModule, "WritePropertyValue") &&
-                LoadDelegate(ref Clone_f12, hModule, "Clone") &&
-                LoadDelegate(ref VerifyClientKey_f, hModule, "VerifyClientKey") &&
-                LoadDelegate(ref GetQualifierSet_f, hModule, "GetQualifierSet") &&
-                LoadDelegate(ref Get_f, hModule, "Get") &&
-                LoadDelegate(ref Put_f, hModule, "Put") &&
-                LoadDelegate(ref Delete_f, hModule, "Delete") &&
-                LoadDelegate(ref GetNames_f, hModule, "GetNames") &&
-                LoadDelegate(ref BeginEnumeration_f, hModule, "BeginEnumeration") &&
-                LoadDelegate(ref Next_f, hModule, "Next") &&
-                LoadDelegate(ref EndEnumeration_f, hModule, "EndEnumeration") &&
-                LoadDelegate(ref GetPropertyQualifierSet_f, hModule, "GetPropertyQualifierSet") &&
-                LoadDelegate(ref Clone_f, hModule, "Clone") &&
-                LoadDelegate(ref GetObjectText_f, hModule, "GetObjectText") &&
-                LoadDelegate(ref SpawnDerivedClass_f, hModule, "SpawnDerivedClass") &&
-                LoadDelegate(ref SpawnInstance_f, hModule, "SpawnInstance") &&
-                LoadDelegate(ref CompareTo_f, hModule, "CompareTo") &&
-                LoadDelegate(ref GetPropertyOrigin_f, hModule, "GetPropertyOrigin") &&
-                LoadDelegate(ref InheritsFrom_f, hModule, "InheritsFrom") &&
-                LoadDelegate(ref GetMethod_f, hModule, "GetMethod") &&
-                LoadDelegate(ref PutMethod_f, hModule, "PutMethod") &&
-                LoadDelegate(ref DeleteMethod_f, hModule, "DeleteMethod") &&
-                LoadDelegate(ref BeginMethodEnumeration_f, hModule, "BeginMethodEnumeration") &&
-                LoadDelegate(ref NextMethod_f, hModule, "NextMethod") &&
-                LoadDelegate(ref EndMethodEnumeration_f, hModule, "EndMethodEnumeration") &&
-                LoadDelegate(ref GetMethodQualifierSet_f, hModule, "GetMethodQualifierSet") &&
-                LoadDelegate(ref GetMethodOrigin_f, hModule, "GetMethodOrigin") &&
-                LoadDelegate(ref QualifierGet_f, hModule, "QualifierSet_Get") &&
-                LoadDelegate(ref QualifierPut_f, hModule, "QualifierSet_Put") &&
-                LoadDelegate(ref QualifierDelete_f, hModule, "QualifierSet_Delete") &&
-                LoadDelegate(ref QualifierGetNames_f, hModule, "QualifierSet_GetNames") &&
-                LoadDelegate(ref QualifierBeginEnumeration_f, hModule, "QualifierSet_BeginEnumeration") &&
-                LoadDelegate(ref QualifierNext_f, hModule, "QualifierSet_Next") &&
-                LoadDelegate(ref QualifierEndEnumeration_f, hModule, "QualifierSet_EndEnumeration") &&
-                LoadDelegate(ref GetCurrentApartmentType_f, hModule, "GetCurrentApartmentType") &&
-                LoadDelegate(ref GetDemultiplexedStub_f, hModule, "GetDemultiplexedStub") &&
-                LoadDelegate(ref CreateInstanceEnumWmi_f, hModule, "CreateInstanceEnumWmi") &&
-                LoadDelegate(ref CreateClassEnumWmi_f, hModule, "CreateClassEnumWmi") &&
-                LoadDelegate(ref ExecQueryWmi_f, hModule, "ExecQueryWmi") &&
-                LoadDelegate(ref ExecNotificationQueryWmi_f, hModule, "ExecNotificationQueryWmi") &&
-                LoadDelegate(ref PutInstanceWmi_f, hModule, "PutInstanceWmi") &&
-                LoadDelegate(ref PutClassWmi_f, hModule, "PutClassWmi") &&
-                LoadDelegate(ref CloneEnumWbemClassObject_f, hModule, "CloneEnumWbemClassObject") &&
-                LoadDelegate(ref ConnectServerWmi_f, hModule, "ConnectServerWmi") &&
-                LoadDelegate(ref GetErrorInfo_f, hModule, "GetErrorInfo") &&
-                LoadDelegate(ref Initialize_f, hModule, "Initialize"))
-            {
-                Initialize_f(CompatSwitches.AllowIManagementObjectQI);
-            }
-            else
-            {
-                LoadPlatformNotSupportedDelegates(SR.Format(SR.PlatformNotSupported_FrameworkUpdatedRequired, wminet_utilsPath));
-            }
-        }
-        private static bool LoadDelegate<TDelegate>(ref TDelegate delegate_f, IntPtr hModule, string procName) where TDelegate : class
-        {
-            IntPtr procAddr = Interop.Kernel32.GetProcAddress(hModule, procName);
-            return procAddr != IntPtr.Zero &&
-                (delegate_f = Marshal.GetDelegateForFunctionPointer<TDelegate>(procAddr)) != null;
-        }
-        private static void LoadPlatformNotSupportedDelegates(string exceptionMessage)
-        {
-            ResetSecurity_f = (_) => throw new PlatformNotSupportedException(exceptionMessage);
-            SetSecurity_f = (ref bool _, ref IntPtr __) => throw new PlatformNotSupportedException(exceptionMessage);
-            BlessIWbemServices_f = (_, __, ___, ____, _____, ______) => throw new PlatformNotSupportedException(exceptionMessage);
-            BlessIWbemServicesObject_f = (_, __, ___, ____, _____, ______) => throw new PlatformNotSupportedException(exceptionMessage);
-            GetPropertyHandle_f27 = (int _, IntPtr __, string ___, out int ____, out int _____) => throw new PlatformNotSupportedException(exceptionMessage);
-            WritePropertyValue_f28 = (_, __, ___, ____, _____) => throw new PlatformNotSupportedException(exceptionMessage);
-            Clone_f12 = (int _, IntPtr __, out IntPtr ___) => throw new PlatformNotSupportedException(exceptionMessage);
-            VerifyClientKey_f = () => throw new PlatformNotSupportedException(exceptionMessage);
-            GetQualifierSet_f = (int _, IntPtr __, out IntPtr ___) => throw new PlatformNotSupportedException(exceptionMessage);
-            Get_f = (int _, IntPtr __, string ___, int ____, ref object _____, ref int ______, ref int _______) => throw new PlatformNotSupportedException(exceptionMessage);
-            Put_f = (int _, IntPtr __, string ___, int ____, ref object _____, int ______) => throw new PlatformNotSupportedException(exceptionMessage);
-            Delete_f = (_, __, ___) => throw new PlatformNotSupportedException(exceptionMessage);
-            GetNames_f = (int _, IntPtr __, string ___, int ____, ref object _____, out string[] ______) => throw new PlatformNotSupportedException(exceptionMessage);
-            BeginEnumeration_f = (_, __, ___) => throw new PlatformNotSupportedException(exceptionMessage);
-            Next_f = (int _, IntPtr __, int ___, ref string ____, ref object _____, ref int ______, ref int _______) => throw new PlatformNotSupportedException(exceptionMessage);
-            EndEnumeration_f = (_, __) => throw new PlatformNotSupportedException(exceptionMessage);
-            GetPropertyQualifierSet_f = (int _, IntPtr __, string ___, out IntPtr ____) => throw new PlatformNotSupportedException(exceptionMessage);
-            Clone_f = (int _, IntPtr __, out IntPtr ___) => throw new PlatformNotSupportedException(exceptionMessage);
-            GetObjectText_f = (int _, IntPtr __, int ___, out string ____) => throw new PlatformNotSupportedException(exceptionMessage);
-            SpawnDerivedClass_f = (int _, IntPtr __, int ___, out IntPtr ____) => throw new PlatformNotSupportedException(exceptionMessage);
-            SpawnInstance_f = (int _, IntPtr __, int ___, out IntPtr ____) => throw new PlatformNotSupportedException(exceptionMessage);
-            CompareTo_f = (_, __, ___, ____) => throw new PlatformNotSupportedException(exceptionMessage);
-            GetPropertyOrigin_f = (int _, IntPtr __, string ___, out string ____) => throw new PlatformNotSupportedException(exceptionMessage);
-            InheritsFrom_f = (int _, IntPtr __, string ___) => throw new PlatformNotSupportedException(exceptionMessage);
-            GetMethod_f = (int _, IntPtr __, string ___, int ____, out IntPtr _____, out IntPtr ______) => throw new PlatformNotSupportedException(exceptionMessage);
-            PutMethod_f = (_, __, ___, ____, _____, ______) => throw new PlatformNotSupportedException(exceptionMessage);
-            DeleteMethod_f = (_, __, ___) => throw new PlatformNotSupportedException(exceptionMessage);
-            BeginMethodEnumeration_f = (_, __, ___) => throw new PlatformNotSupportedException(exceptionMessage);
-            NextMethod_f = (int _, IntPtr __, int ___, out string ____, out IntPtr _____, out IntPtr ______) => throw new PlatformNotSupportedException(exceptionMessage);
-            EndMethodEnumeration_f = (_, __) => throw new PlatformNotSupportedException(exceptionMessage);
-            GetMethodQualifierSet_f = (int _, IntPtr __, string ___, out IntPtr ____) => throw new PlatformNotSupportedException(exceptionMessage);
-            GetMethodOrigin_f = (int _, IntPtr __, string ___, out string ____) => throw new PlatformNotSupportedException(exceptionMessage);
-            QualifierGet_f = (int _, IntPtr __, string ___, int ____, ref object _____, ref int ______) => throw new PlatformNotSupportedException(exceptionMessage);
-            QualifierPut_f = (int _, IntPtr __, string ___, ref object ____, int _____) => throw new PlatformNotSupportedException(exceptionMessage);
-            QualifierDelete_f = (_, __, ___) => throw new PlatformNotSupportedException(exceptionMessage);
-            QualifierGetNames_f = (int _, IntPtr __, int ___, out string[] ____) => throw new PlatformNotSupportedException(exceptionMessage);
-            QualifierBeginEnumeration_f = (_, __, ___) => throw new PlatformNotSupportedException(exceptionMessage);
-            QualifierNext_f = (int _, IntPtr __, int ___, out string ____, out object _____, out int ______) => throw new PlatformNotSupportedException(exceptionMessage);
-            QualifierEndEnumeration_f = (_, __) => throw new PlatformNotSupportedException(exceptionMessage);
-            GetCurrentApartmentType_f = (int _, IntPtr __, out APTTYPE ___) => throw new PlatformNotSupportedException(exceptionMessage);
-            GetDemultiplexedStub_f = (object _, bool __, out object ___) => throw new PlatformNotSupportedException(exceptionMessage);
-            CreateInstanceEnumWmi_f = (string _, int __, IWbemContext ___, out IEnumWbemClassObject ____, int _____, int ______, IWbemServices _______, string ________, IntPtr _________, string __________) => throw new PlatformNotSupportedException(exceptionMessage);
-            CreateClassEnumWmi_f = (string _, int __, IWbemContext ___, out IEnumWbemClassObject ____, int _____, int ______, IWbemServices _______, string ________, IntPtr _________, string __________) => throw new PlatformNotSupportedException(exceptionMessage);
-            ExecQueryWmi_f = (string _, string __, int ___, IWbemContext ____, out IEnumWbemClassObject _____, int ______, int _______, IWbemServices ________, string _________, IntPtr __________, string ___________) => throw new PlatformNotSupportedException(exceptionMessage);
-            ExecNotificationQueryWmi_f = (string _, string __, int ___, IWbemContext ____, out IEnumWbemClassObject _____, int ______, int _______, IWbemServices ________, string _________, IntPtr __________, string ___________) => throw new PlatformNotSupportedException(exceptionMessage);
-            PutInstanceWmi_f = (_, __, ___, ____, _____, ______, _______, ________, _________, __________) => throw new PlatformNotSupportedException(exceptionMessage);
-            PutClassWmi_f = (_, __, ___, ____, _____, ______, _______, ________, _________, __________) => throw new PlatformNotSupportedException(exceptionMessage);
-            CloneEnumWbemClassObject_f = (out IEnumWbemClassObject _, int __, int ____, IEnumWbemClassObject _____, string ______, IntPtr _______, string ________) => throw new PlatformNotSupportedException(exceptionMessage);
-            ConnectServerWmi_f = (string _, string __, IntPtr ___, string ____, int _____, string ______, IWbemContext _______, out IWbemServices ________, int _________, int __________) => throw new PlatformNotSupportedException(exceptionMessage);
-            GetErrorInfo_f = () => throw new PlatformNotSupportedException(exceptionMessage);
-            Initialize_f = (_) => throw new PlatformNotSupportedException(exceptionMessage);
-        }
-    }
-    [TypeConverter(typeof(ManagementScopeConverter))]
-    public class ManagementScope : ICloneable
-    {
-        private ManagementPath validatedPath;
-        private IWbemServices wbemServices;
-        private ConnectionOptions options;
-        internal event IdentifierChangedEventHandler IdentifierChanged;
-        internal bool IsDefaulted; //used to tell whether the current scope has been created from the default
-        private void FireIdentifierChanged()
-        {
-            IdentifierChanged?.Invoke(this, null);
-        }
-        private void HandleIdentifierChange(object sender,
-            IdentifierChangedEventArgs args)
-        {
-            wbemServices = null;
-            FireIdentifierChanged();
-        }
-        private ManagementPath prvpath
-        {
-            get
-            {
-                return validatedPath;
-            }
-            set
-            {
-                if (value != null)
-                {
-                    string pathValue = value.Path;
-                    if (!ManagementPath.IsValidNamespaceSyntax(pathValue))
-                        ManagementException.ThrowWithExtendedInfo((ManagementStatus)tag_WBEMSTATUS.WBEM_E_INVALID_NAMESPACE);
-                }
-                validatedPath = value;
-            }
-        }
-        internal IWbemServices GetIWbemServices()
-        {
-            IWbemServices localCopy = wbemServices;
-            if (CompatSwitches.AllowIManagementObjectQI)
-            {
-                IntPtr pUnk = Marshal.GetIUnknownForObject(wbemServices);
-                object unknown = Marshal.GetObjectForIUnknown(pUnk);
-                Marshal.Release(pUnk);
-                if (!object.ReferenceEquals(unknown, wbemServices))
-                {
-                    SecurityHandler securityHandler = GetSecurityHandler();
-                    securityHandler.SecureIUnknown(unknown);
-                    localCopy = (IWbemServices)unknown;
-                    securityHandler.Secure(localCopy);
-                }
-            }
-            return localCopy; // STRANGE: Why does it still work if I return 'wbemServices'?
-        }
-        public bool IsConnected
-        {
-            get
-            {
-                return (null != wbemServices);
-            }
-        }
-        internal ManagementScope(ManagementPath path, IWbemServices wbemServices,
-            ConnectionOptions options)
-        {
-            if (null != path)
-                this.Path = path;
-            if (null != options)
-            {
-                this.Options = options;
-            }
-            this.wbemServices = wbemServices;
-        }
-        internal ManagementScope(ManagementPath path, ManagementScope scope)
-            : this(path, scope?.options) { }
-        internal static ManagementScope _Clone(ManagementScope scope)
-        {
-            return ManagementScope._Clone(scope, null);
-        }
-        internal static ManagementScope _Clone(ManagementScope scope, IdentifierChangedEventHandler handler)
-        {
-            ManagementScope scopeTmp = new ManagementScope(null, null, null);
-            if (handler != null)
-                scopeTmp.IdentifierChanged = handler;
-            else if (scope != null)
-                scopeTmp.IdentifierChanged = new IdentifierChangedEventHandler(scope.HandleIdentifierChange);
-            if (scope == null)
-            {
-                scopeTmp.prvpath = ManagementPath._Clone(ManagementPath.DefaultPath, new IdentifierChangedEventHandler(scopeTmp.HandleIdentifierChange));
-                scopeTmp.IsDefaulted = true;
-                scopeTmp.wbemServices = null;
-                scopeTmp.options = null;
-            }
-            else
-            {
-                if (scope.prvpath == null)
-                {
-                    scopeTmp.prvpath = ManagementPath._Clone(ManagementPath.DefaultPath, new IdentifierChangedEventHandler(scopeTmp.HandleIdentifierChange));
-                    scopeTmp.IsDefaulted = true;
-                }
-                else
-                {
-                    scopeTmp.prvpath = ManagementPath._Clone(scope.prvpath, new IdentifierChangedEventHandler(scopeTmp.HandleIdentifierChange));
-                    scopeTmp.IsDefaulted = scope.IsDefaulted;
-                }
-                scopeTmp.wbemServices = scope.wbemServices;
-                if (scope.options != null)
-                    scopeTmp.options = ConnectionOptions._Clone(scope.options, new IdentifierChangedEventHandler(scopeTmp.HandleIdentifierChange));
-            }
-            return scopeTmp;
-        }
-        public ManagementScope() :
-            this(new ManagementPath(ManagementPath.DefaultPath.Path))
-        {
-            IsDefaulted = true;
-        }
-        public ManagementScope(ManagementPath path) : this(path, (ConnectionOptions)null) { }
-        public ManagementScope(string path) : this(new ManagementPath(path), (ConnectionOptions)null) { }
-        public ManagementScope(string path, ConnectionOptions options) : this(new ManagementPath(path), options) { }
-        public ManagementScope(ManagementPath path, ConnectionOptions options)
-        {
-            if (null != path)
-                this.prvpath = ManagementPath._Clone(path, new IdentifierChangedEventHandler(HandleIdentifierChange));
-            else
-                this.prvpath = ManagementPath._Clone(null);
-            if (null != options)
-            {
-                this.options = ConnectionOptions._Clone(options, new IdentifierChangedEventHandler(HandleIdentifierChange));
-            }
-            else
-                this.options = null;
-            IsDefaulted = false; //assume that this scope is not initialized by the default path
-        }
-        public ConnectionOptions Options
-        {
-            get
-            {
-                return options ??= ConnectionOptions._Clone(null, new IdentifierChangedEventHandler(HandleIdentifierChange));
-            }
-            set
-            {
-                if (null != value)
-                {
-                    if (null != options)
-                        options.IdentifierChanged -= new IdentifierChangedEventHandler(HandleIdentifierChange);
-                    options = ConnectionOptions._Clone((ConnectionOptions)value, new IdentifierChangedEventHandler(HandleIdentifierChange));
-                    HandleIdentifierChange(this, null);
-                }
-                else
-                    throw new ArgumentNullException(nameof(value));
-            }
-        }
-        public ManagementPath Path
-        {
-            get
-            {
-                return prvpath ??= ManagementPath._Clone(null);
-            }
-            set
-            {
-                if (null != value)
-                {
-                    if (null != prvpath)
-                        prvpath.IdentifierChanged -= new IdentifierChangedEventHandler(HandleIdentifierChange);
-                    IsDefaulted = false; //someone is specifically setting the scope path so it's not defaulted any more
-                    prvpath = ManagementPath._Clone((ManagementPath)value, new IdentifierChangedEventHandler(HandleIdentifierChange));
-                    HandleIdentifierChange(this, null);
-                }
-                else
-                    throw new ArgumentNullException(nameof(value));
-            }
-        }
-        public ManagementScope Clone()
-        {
-            return ManagementScope._Clone(this);
-        }
-        object ICloneable.Clone()
-        {
-            return Clone();
-        }
-        public void Connect()
-        {
-            Initialize();
-        }
-        internal void Initialize()
-        {
-            if (null == prvpath)
-                throw new InvalidOperationException();
-            /*
-             * If we're not connected yet, this is the time to do it... We lock
-             * the state to prevent 2 threads simultaneously doing the same
-             * connection. To avoid taking the lock unnecessarily we examine
-             * isConnected first
-             */
-            if (!IsConnected)
-            {
-                lock (this)
-                {
-                    if (!IsConnected)
-                    {
-                        if (!MTAHelper.IsNoContextMTA())
-                        {
-                            ThreadDispatch disp = new ThreadDispatch(new ThreadDispatch.ThreadWorkerMethodWithParam(InitializeGuts));
-                            disp.Parameter = this;
-                            disp.Start();
-                        }
-                        else
-                            InitializeGuts(this);
-                    }
-                }
-            }
-        }
-        private void InitializeGuts(object o)
-        {
-            ManagementScope threadParam = (ManagementScope)o;
-            if (null == threadParam.options)
-            {
-                threadParam.Options = new ConnectionOptions();
-            }
-            string nsPath = threadParam.prvpath.GetNamespacePath((int)tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY);
-            if ((null == nsPath) || (0 == nsPath.Length))
-            {
-                nsPath = threadParam.prvpath.SetNamespacePath(ManagementPath.DefaultPath.Path, out _);
-            }
-            int status = (int)ManagementStatus.NoError;
-            threadParam.wbemServices = null;
-            if (Environment.OSVersion.Platform == PlatformID.Win32NT)
-            {
-                if (((Environment.OSVersion.Version.Major == 5) && (Environment.OSVersion.Version.Minor >= 1)) || (Environment.OSVersion.Version.Major >= 6))
-                {
-                    threadParam.options.Flags |= (int)tag_WBEM_CONNECT_OPTIONS.WBEM_FLAG_CONNECT_USE_MAX_WAIT;
-                }
-            }
-            try
-            {
-                status = GetSecuredConnectHandler().ConnectNSecureIWbemServices(nsPath, ref threadParam.wbemServices);
-            }
-            catch (COMException e)
-            {
-                ManagementException.ThrowWithExtendedInfo(e);
-            }
-            if ((status & 0xfffff000) == 0x80041000)
-            {
-                ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
-            }
-            else if ((status & 0x80000000) != 0)
-            {
-                Marshal.ThrowExceptionForHR(status, WmiNetUtilsHelper.GetErrorInfo_f());
-            }
-        }
-        internal SecurityHandler GetSecurityHandler()
-        {
-            return new SecurityHandler(this);
-        }
-        internal SecuredConnectHandler GetSecuredConnectHandler()
-        {
-            return new SecuredConnectHandler(this);
-        }
-        internal SecuredIEnumWbemClassObjectHandler GetSecuredIEnumWbemClassObjectHandler(IEnumWbemClassObject pEnumWbemClassObject)
-        {
-            return new SecuredIEnumWbemClassObjectHandler(this, pEnumWbemClassObject);
-        }
-        internal SecuredIWbemServicesHandler GetSecuredIWbemServicesHandler(IWbemServices pWbemServiecs)
-        {
-            return new SecuredIWbemServicesHandler(this, pWbemServiecs);
-        }
-    }//ManagementScope
-    internal sealed class SecuredIEnumWbemClassObjectHandler
-    {
-        private readonly IEnumWbemClassObject pEnumWbemClassObjectsecurityHelper;
-        private readonly ManagementScope scope;
-        internal SecuredIEnumWbemClassObjectHandler(ManagementScope theScope, IEnumWbemClassObject pEnumWbemClassObject)
-        {
-            this.scope = theScope;
-            pEnumWbemClassObjectsecurityHelper = pEnumWbemClassObject;
-        }
-        internal int Reset_()
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            status = pEnumWbemClassObjectsecurityHelper.Reset_();
-            return status;
-        }
-        internal int Next_(int lTimeout, uint uCount, IWbemClassObject_DoNotMarshal[] ppOutParams, ref uint puReturned)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            status = pEnumWbemClassObjectsecurityHelper.Next_(lTimeout, uCount, ppOutParams, out puReturned);
-            return status;
-        }
-        internal int NextAsync_(uint uCount, IWbemObjectSink pSink)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            status = pEnumWbemClassObjectsecurityHelper.NextAsync_(uCount, pSink);
-            return status;
-        }
-        internal int Clone_(ref IEnumWbemClassObject ppEnum)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            if (null != scope)
-            {
-                IntPtr password = scope.Options.GetPassword();
-                status = WmiNetUtilsHelper.CloneEnumWbemClassObject_f(
-                    out ppEnum,
-                    (int)scope.Options.Authentication,
-                    (int)scope.Options.Impersonation,
-                    pEnumWbemClassObjectsecurityHelper,
-                    scope.Options.Username,
-                    password,
-                    scope.Options.Authority);
-                System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(password);
-            }
-            return status;
-        }
-        internal int Skip_(int lTimeout, uint nCount)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            status = pEnumWbemClassObjectsecurityHelper.Skip_(lTimeout, nCount);
-            return status;
-        }
-    }
-    internal sealed class SecuredConnectHandler
-    {
-        private readonly ManagementScope scope;
-        internal SecuredConnectHandler(ManagementScope theScope)
-        {
-            this.scope = theScope;
-        }
-        internal int ConnectNSecureIWbemServices(string path, ref IWbemServices pServices)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            if (null != scope)
-            {
-                bool needToReset = false;
-                IntPtr handle = IntPtr.Zero;
-                try
-                {
-                    if (scope.Options.EnablePrivileges && !CompatSwitches.AllowIManagementObjectQI)
-                    {
-                        WmiNetUtilsHelper.SetSecurity_f(ref needToReset, ref handle);
-                    }
-                    IntPtr password = scope.Options.GetPassword();
-                    status = WmiNetUtilsHelper.ConnectServerWmi_f(
-                        path,
-                        scope.Options.Username,
-                        password,
-                        scope.Options.Locale,
-                        scope.Options.Flags,
-                        scope.Options.Authority,
-                        scope.Options.GetContext(),
-                        out pServices,
-                        (int)scope.Options.Impersonation,
-                        (int)scope.Options.Authentication);
-                    System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(password);
-                }
-                finally
-                {
-                    if (needToReset)
-                    {
-                        needToReset = false;
-                        WmiNetUtilsHelper.ResetSecurity_f(handle);
-                    }
-                }
-            }
-            return status;
-        }
-    }
-    internal sealed class SecuredIWbemServicesHandler
-    {
-        private readonly IWbemServices pWbemServiecsSecurityHelper;
-        private readonly ManagementScope scope;
-        internal SecuredIWbemServicesHandler(ManagementScope theScope, IWbemServices pWbemServiecs)
-        {
-            this.scope = theScope;
-            pWbemServiecsSecurityHelper = pWbemServiecs;
-        }
-        internal int OpenNamespace_(string strNamespace, int lFlags, ref IWbemServices ppWorkingNamespace, IntPtr ppCallResult)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED;
-            return status;
-        }
-        internal int CancelAsyncCall_(IWbemObjectSink pSink)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            status = pWbemServiecsSecurityHelper.CancelAsyncCall_(pSink);
-            return status;
-        }
-        internal int QueryObjectSink_(int lFlags, ref IWbemObjectSink ppResponseHandler)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            status = pWbemServiecsSecurityHelper.QueryObjectSink_(lFlags, out ppResponseHandler);
-            return status;
-        }
-        internal int GetObject_(string strObjectPath, int lFlags, IWbemContext pCtx, ref IWbemClassObjectFreeThreaded ppObject, IntPtr ppCallResult)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            status = pWbemServiecsSecurityHelper.GetObject_(strObjectPath, lFlags, pCtx, out ppObject, ppCallResult);
-            return status;
-        }
-        internal int GetObjectAsync_(string strObjectPath, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            status = pWbemServiecsSecurityHelper.GetObjectAsync_(strObjectPath, lFlags, pCtx, pResponseHandler);
-            return status;
-        }
-        internal int PutClass_(IWbemClassObjectFreeThreaded pObject, int lFlags, IWbemContext pCtx, IntPtr ppCallResult)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            if (null != scope)
-            {
-                IntPtr password = scope.Options.GetPassword();
-                status = WmiNetUtilsHelper.PutClassWmi_f(pObject,
-                    lFlags,
-                    pCtx,
-                    ppCallResult,
-                    (int)scope.Options.Authentication,
-                    (int)scope.Options.Impersonation,
-                    pWbemServiecsSecurityHelper,
-                    scope.Options.Username,
-                    password,
-                    scope.Options.Authority);
-                System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(password);
-            }
-            return status;
-        }
-        internal int PutClassAsync_(IWbemClassObjectFreeThreaded pObject, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            status = pWbemServiecsSecurityHelper.PutClassAsync_(pObject, lFlags, pCtx, pResponseHandler);
-            return status;
-        }
-        internal int DeleteClass_(string strClass, int lFlags, IWbemContext pCtx, IntPtr ppCallResult)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            status = pWbemServiecsSecurityHelper.DeleteClass_(strClass, lFlags, pCtx, ppCallResult);
-            return status;
-        }
-        internal int DeleteClassAsync_(string strClass, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            status = pWbemServiecsSecurityHelper.DeleteClassAsync_(strClass, lFlags, pCtx, pResponseHandler);
-            return status;
-        }
-        internal int CreateClassEnum_(string strSuperClass, int lFlags, IWbemContext pCtx, ref IEnumWbemClassObject ppEnum)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            if (null != scope)
-            {
-                IntPtr password = scope.Options.GetPassword();
-                status = WmiNetUtilsHelper.CreateClassEnumWmi_f(strSuperClass,
-                    lFlags,
-                    pCtx,
-                    out ppEnum,
-                    (int)scope.Options.Authentication,
-                    (int)scope.Options.Impersonation,
-                    pWbemServiecsSecurityHelper,
-                    scope.Options.Username,
-                    password,
-                    scope.Options.Authority);
-                System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(password);
-            }
-            return status;
-        }
-        internal int CreateClassEnumAsync_(string strSuperClass, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            status = pWbemServiecsSecurityHelper.CreateClassEnumAsync_(strSuperClass, lFlags, pCtx, pResponseHandler);
-            return status;
-        }
-        internal int PutInstance_(IWbemClassObjectFreeThreaded pInst, int lFlags, IWbemContext pCtx, IntPtr ppCallResult)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            if (null != scope)
-            {
-                IntPtr password = scope.Options.GetPassword();
-                status = WmiNetUtilsHelper.PutInstanceWmi_f(pInst,
-                    lFlags,
-                    pCtx,
-                    ppCallResult,
-                    (int)scope.Options.Authentication,
-                    (int)scope.Options.Impersonation,
-                    pWbemServiecsSecurityHelper,
-                    scope.Options.Username,
-                    password,
-                    scope.Options.Authority);
-                System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(password);
-            }
-            return status;
-        }
-        internal int PutInstanceAsync_(IWbemClassObjectFreeThreaded pInst, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            status = pWbemServiecsSecurityHelper.PutInstanceAsync_(pInst, lFlags, pCtx, pResponseHandler);
-            return status;
-        }
-        internal int DeleteInstance_(string strObjectPath, int lFlags, IWbemContext pCtx, IntPtr ppCallResult)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            status = pWbemServiecsSecurityHelper.DeleteInstance_(strObjectPath, lFlags, pCtx, ppCallResult);
-            return status;
-        }
-        internal int DeleteInstanceAsync_(string strObjectPath, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            status = pWbemServiecsSecurityHelper.DeleteInstanceAsync_(strObjectPath, lFlags, pCtx, pResponseHandler);
-            return status;
-        }
-        internal int CreateInstanceEnum_(string strFilter, int lFlags, IWbemContext pCtx, ref IEnumWbemClassObject ppEnum)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            if (null != scope)
-            {
-                IntPtr password = scope.Options.GetPassword();
-                status = WmiNetUtilsHelper.CreateInstanceEnumWmi_f(strFilter,
-                    lFlags,
-                    pCtx,
-                    out ppEnum,
-                    (int)scope.Options.Authentication,
-                    (int)scope.Options.Impersonation,
-                    pWbemServiecsSecurityHelper,
-                    scope.Options.Username,
-                    password,
-                    scope.Options.Authority);
-                System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(password);
-            }
-            return status;
-        }
-        internal int CreateInstanceEnumAsync_(string strFilter, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            status = pWbemServiecsSecurityHelper.CreateInstanceEnumAsync_(strFilter, lFlags, pCtx, pResponseHandler);
-            return status;
-        }
-        internal int ExecQuery_(string strQueryLanguage, string strQuery, int lFlags, IWbemContext pCtx, ref IEnumWbemClassObject ppEnum)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            if (null != scope)
-            {
-                IntPtr password = scope.Options.GetPassword();
-                status = WmiNetUtilsHelper.ExecQueryWmi_f(strQueryLanguage,
-                    strQuery,
-                    lFlags,
-                    pCtx,
-                    out ppEnum,
-                    (int)scope.Options.Authentication,
-                    (int)scope.Options.Impersonation,
-                    pWbemServiecsSecurityHelper,
-                    scope.Options.Username,
-                    password,
-                    scope.Options.Authority);
-                System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(password);
-            }
-            return status;
-        }
-        internal int ExecQueryAsync_(string strQueryLanguage, string strQuery, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            status = pWbemServiecsSecurityHelper.ExecQueryAsync_(strQueryLanguage, strQuery, lFlags, pCtx, pResponseHandler);
-            return status;
-        }
-        internal int ExecNotificationQuery_(string strQueryLanguage, string strQuery, int lFlags, IWbemContext pCtx, ref IEnumWbemClassObject ppEnum)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            if (null != scope)
-            {
-                IntPtr password = scope.Options.GetPassword();
-                status = WmiNetUtilsHelper.ExecNotificationQueryWmi_f(strQueryLanguage,
-                    strQuery,
-                    lFlags,
-                    pCtx,
-                    out ppEnum,
-                    (int)scope.Options.Authentication,
-                    (int)scope.Options.Impersonation,
-                    pWbemServiecsSecurityHelper,
-                    scope.Options.Username,
-                    password,
-                    scope.Options.Authority);
-                System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(password);
-            }
-            return status;
-        }
-        internal int ExecNotificationQueryAsync_(string strQueryLanguage, string strQuery, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            status = pWbemServiecsSecurityHelper.ExecNotificationQueryAsync_(strQueryLanguage, strQuery, lFlags, pCtx, pResponseHandler);
-            return status;
-        }
-        internal int ExecMethod_(string strObjectPath, string strMethodName, int lFlags, IWbemContext pCtx, IWbemClassObjectFreeThreaded pInParams, ref IWbemClassObjectFreeThreaded ppOutParams, IntPtr ppCallResult)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            status = pWbemServiecsSecurityHelper.ExecMethod_(strObjectPath, strMethodName, lFlags, pCtx, pInParams, out ppOutParams, ppCallResult);
-            return status;
-        }
-        internal int ExecMethodAsync_(string strObjectPath, string strMethodName, int lFlags, IWbemContext pCtx, IWbemClassObjectFreeThreaded pInParams, IWbemObjectSink pResponseHandler)
-        {
-            int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
-            status = pWbemServiecsSecurityHelper.ExecMethodAsync_(strObjectPath, strMethodName, lFlags, pCtx, pInParams, pResponseHandler);
-            return status;
-        }
-    }
-    internal sealed class SecurityHandler
-    {
-        private bool needToReset;
-        private readonly IntPtr handle;
-        private readonly ManagementScope scope;
-        internal SecurityHandler(ManagementScope theScope)
-        {
-            this.scope = theScope;
-            if (null != scope)
-            {
-                if (scope.Options.EnablePrivileges)
-                {
-                    WmiNetUtilsHelper.SetSecurity_f(ref needToReset, ref handle);
-                }
-            }
-        }
-        internal void Reset()
-        {
-            if (needToReset)
-            {
-                needToReset = false;
-                if (null != scope)
-                {
-                    WmiNetUtilsHelper.ResetSecurity_f(handle);
-                }
-            }
-        }
-        internal void Secure(IWbemServices services)
-        {
-            if (null != scope)
-            {
-                IntPtr password = scope.Options.GetPassword();
-                int status = WmiNetUtilsHelper.BlessIWbemServices_f
-                    (
-                    services,
-                    scope.Options.Username,
-                    password,
-                    scope.Options.Authority,
-                    (int)scope.Options.Impersonation,
-                    (int)scope.Options.Authentication
-                    );
-                System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(password);
-                if (status < 0)
-                {
-                    Marshal.ThrowExceptionForHR(status, WmiNetUtilsHelper.GetErrorInfo_f());
-                }
-            }
-        }
-        internal void SecureIUnknown(object unknown)
-        {
-            if (null != scope)
-            {
-                IntPtr password = scope.Options.GetPassword();
-                int status = WmiNetUtilsHelper.BlessIWbemServicesObject_f
-                    (
-                    unknown,
-                    scope.Options.Username,
-                    password,
-                    scope.Options.Authority,
-                    (int)scope.Options.Impersonation,
-                    (int)scope.Options.Authentication
-                    );
-                System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(password);
-                if (status < 0)
-                {
-                    Marshal.ThrowExceptionForHR(status, WmiNetUtilsHelper.GetErrorInfo_f());
-                }
-            }
-        }
-    } //SecurityHandler
-    internal sealed class ManagementScopeConverter : ExpandableObjectConverter
-    {
-        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
-        {
-            if ((sourceType == typeof(ManagementScope)))
-            {
-                return true;
-            }
-            return base.CanConvertFrom(context, sourceType);
-        }
-        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
-        {
-            if ((destinationType == typeof(InstanceDescriptor)))
-            {
-                return true;
-            }
-            return base.CanConvertTo(context, destinationType);
-        }
-        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
-        {
-            if (destinationType == null)
-            {
-                throw new ArgumentNullException(nameof(destinationType));
-            }
-            if (value is ManagementScope && destinationType == typeof(InstanceDescriptor))
-            {
-                ManagementScope obj = ((ManagementScope)(value));
-                ConstructorInfo ctor = typeof(ManagementScope).GetConstructor(new Type[] { typeof(string) });
-                if (ctor != null)
-                {
-                    return new InstanceDescriptor(ctor, new object[] { obj.Path.Path });
-                }
-            }
-            return base.ConvertTo(context, culture, value, destinationType);
-        }
-    }
-}

--- a/src/libraries/System.Net.Quic/src/System/Net/Quic/Internal/MsQuicApi.cs
+++ b//dev/null
@@ -1,158 +0,0 @@
-using System.Diagnostics;
-using System.Diagnostics.CodeAnalysis;
-using System.Runtime.InteropServices;
-using Microsoft.Quic;
-using static Microsoft.Quic.MsQuic;
-#if TARGET_WINDOWS
-using Microsoft.Win32;
-#endif
-namespace System.Net.Quic;
-internal sealed unsafe partial class MsQuicApi
-{
-    private static readonly Version MinWindowsVersion = new Version(10, 0, 20145, 1000);
-    private static readonly Version MinMsQuicVersion = new Version(2, 1);
-    private static readonly delegate* unmanaged[Cdecl]<uint, QUIC_API_TABLE**, int> MsQuicOpenVersion;
-    private static readonly delegate* unmanaged[Cdecl]<QUIC_API_TABLE*, void> MsQuicClose;
-    public MsQuicSafeHandle Registration { get; }
-    public QUIC_API_TABLE* ApiTable { get; }
-    [DynamicDependency(DynamicallyAccessedMemberTypes.PublicConstructors, typeof(MsQuicSafeHandle))]
-    [DynamicDependency(DynamicallyAccessedMemberTypes.PublicConstructors, typeof(MsQuicContextSafeHandle))]
-    private MsQuicApi(QUIC_API_TABLE* apiTable)
-    {
-        ApiTable = apiTable;
-        fixed (byte* pAppName = "System.Net.Quic"u8)
-        {
-            var cfg = new QUIC_REGISTRATION_CONFIG
-            {
-                AppName = (sbyte*)pAppName,
-                ExecutionProfile = QUIC_EXECUTION_PROFILE.LOW_LATENCY
-            };
-            QUIC_HANDLE* handle;
-            ThrowHelper.ThrowIfMsQuicError(ApiTable->RegistrationOpen(&cfg, &handle), "RegistrationOpen failed");
-            Registration = new MsQuicSafeHandle(handle, apiTable->RegistrationClose, SafeHandleType.Registration);
-        }
-    }
-    private static readonly Lazy<MsQuicApi> s_api = new Lazy<MsQuicApi>(AllocateMsQuicApi);
-    internal static MsQuicApi Api => s_api.Value;
-    internal static bool IsQuicSupported { get; }
-    internal static bool UsesSChannelBackend { get; }
-    internal static bool Tls13ServerMayBeDisabled { get; }
-    internal static bool Tls13ClientMayBeDisabled { get; }
-#pragma warning disable CA1810 // Initialize all static fields in 'MsQuicApi' when those fields are declared and remove the explicit static constructor
-    static MsQuicApi()
-    {
-        bool loaded = false;
-        IntPtr msQuicHandle;
-        if (OperatingSystem.IsWindows())
-        {
-            loaded = NativeLibrary.TryLoad(Interop.Libraries.MsQuic, typeof(MsQuicApi).Assembly, DllImportSearchPath.AssemblyDirectory, out msQuicHandle);
-        }
-        else
-        {
-            loaded = NativeLibrary.TryLoad($"{Interop.Libraries.MsQuic}.{MinMsQuicVersion.Major}", typeof(MsQuicApi).Assembly, null, out msQuicHandle) ||
-                     NativeLibrary.TryLoad(Interop.Libraries.MsQuic, typeof(MsQuicApi).Assembly, null, out msQuicHandle);
-        }
-        if (!loaded)
-        {
-            return;
-        }
-        MsQuicOpenVersion = (delegate* unmanaged[Cdecl]<uint, QUIC_API_TABLE**, int>)NativeLibrary.GetExport(msQuicHandle, nameof(MsQuicOpenVersion));
-        MsQuicClose = (delegate* unmanaged[Cdecl]<QUIC_API_TABLE*, void>)NativeLibrary.GetExport(msQuicHandle, nameof(MsQuicClose));
-        if (!TryOpenMsQuic(out QUIC_API_TABLE* apiTable, out _))
-        {
-            return;
-        }
-        try
-        {
-            const int ArraySize = 4;
-            uint* libVersion = stackalloc uint[ArraySize];
-            uint size = (uint)ArraySize * sizeof(uint);
-            if (StatusFailed(apiTable->GetParam(null, QUIC_PARAM_GLOBAL_LIBRARY_VERSION, &size, libVersion)))
-            {
-                return;
-            }
-            var version = new Version((int)libVersion[0], (int)libVersion[1], (int)libVersion[2], (int)libVersion[3]);
-            if (version < MinMsQuicVersion)
-            {
-                if (NetEventSource.Log.IsEnabled())
-                {
-                    NetEventSource.Info(null, $"Incompatible MsQuic library version '{version}', expecting at least '{MinMsQuicVersion}'");
-                }
-                return;
-            }
-            QUIC_TLS_PROVIDER provider = OperatingSystem.IsWindows() ? QUIC_TLS_PROVIDER.SCHANNEL : QUIC_TLS_PROVIDER.OPENSSL;
-            size = sizeof(QUIC_TLS_PROVIDER);
-            apiTable->GetParam(null, QUIC_PARAM_GLOBAL_TLS_PROVIDER, &size, &provider);
-            UsesSChannelBackend = provider == QUIC_TLS_PROVIDER.SCHANNEL;
-            if (UsesSChannelBackend)
-            {
-                if (!IsWindowsVersionSupported())
-                {
-                    if (NetEventSource.Log.IsEnabled())
-                    {
-                        NetEventSource.Info(null, $"Current Windows version ({Environment.OSVersion}) is not supported by QUIC. Minimal supported version is {MinWindowsVersion}");
-                    }
-                    return;
-                }
-                Tls13ServerMayBeDisabled = IsTls13Disabled(isServer: true);
-                Tls13ClientMayBeDisabled = IsTls13Disabled(isServer: false);
-            }
-            IsQuicSupported = true;
-        }
-        finally
-        {
-            MsQuicClose(apiTable);
-        }
-    }
-#pragma warning restore CA1810
-    private static MsQuicApi AllocateMsQuicApi()
-    {
-        Debug.Assert(IsQuicSupported);
-        if (!TryOpenMsQuic(out QUIC_API_TABLE* apiTable, out int openStatus))
-        {
-            throw ThrowHelper.GetExceptionForMsQuicStatus(openStatus);
-        }
-        return new MsQuicApi(apiTable);
-    }
-    private static bool TryOpenMsQuic(out QUIC_API_TABLE* apiTable, out int openStatus)
-    {
-        Debug.Assert(MsQuicOpenVersion != null);
-        QUIC_API_TABLE* table = null;
-        openStatus = MsQuicOpenVersion((uint)MinMsQuicVersion.Major, &table);
-        if (StatusFailed(openStatus))
-        {
-            if (NetEventSource.Log.IsEnabled())
-            {
-                NetEventSource.Info(null, $"MsQuicOpenVersion returned {openStatus} status code.");
-            }
-            apiTable = null;
-            return false;
-        }
-        apiTable = table;
-        return true;
-    }
-    private static bool IsWindowsVersionSupported() => OperatingSystem.IsWindowsVersionAtLeast(MinWindowsVersion.Major,
-        MinWindowsVersion.Minor, MinWindowsVersion.Build, MinWindowsVersion.Revision);
-    private static bool IsTls13Disabled(bool isServer)
-    {
-#if TARGET_WINDOWS
-        string SChannelTls13RegistryKey = isServer
-            ? @"SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.3\Server"
-            : @"SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.3\Client";
-        using var regKey = Registry.LocalMachine.OpenSubKey(SChannelTls13RegistryKey);
-        if (regKey is null)
-        {
-            return false;
-        }
-        if (regKey.GetValue("Enabled") is int enabled && enabled == 0)
-        {
-            return true;
-        }
-        if (regKey.GetValue("DisabledByDefault") is int disabled && disabled == 1)
-        {
-            return true;
-        }
-#endif
-        return false;
-    }
-}

--- a/src/libraries/System.Net.Security/src/System/Net/Security/SslStreamCertificateContext.Linux.cs
+++ b//dev/null
@@ -1,224 +0,0 @@
-using Microsoft.Win32.SafeHandles;
-using System.Buffers;
-using System.Collections.Concurrent;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Security.Authentication;
-using System.Security.Cryptography;
-using System.Security.Cryptography.X509Certificates;
-using System.Text;
-using System.Threading.Tasks;
-namespace System.Net.Security
-{
-    public partial class SslStreamCertificateContext
-    {
-        private const bool TrimRootCertificate = true;
-        internal readonly ConcurrentDictionary<SslProtocols, SafeSslContextHandle> SslContexts;
-        internal readonly SafeX509Handle CertificateHandle;
-        internal readonly SafeEvpPKeyHandle KeyHandle;
-        private bool _staplingForbidden;
-        private byte[]? _ocspResponse;
-        private DateTimeOffset _ocspExpiration;
-        private DateTimeOffset _nextDownload;
-        private Task<byte[]?>? _pendingDownload;
-        private List<string>? _ocspUrls;
-        private X509Certificate2? _ca;
-        private SslStreamCertificateContext(X509Certificate2 target, X509Certificate2[] intermediates, SslCertificateTrust? trust)
-        {
-            Certificate = target;
-            IntermediateCertificates = intermediates;
-            Trust = trust;
-            SslContexts = new ConcurrentDictionary<SslProtocols, SafeSslContextHandle>();
-            using (RSAOpenSsl? rsa = (RSAOpenSsl?)target.GetRSAPrivateKey())
-            {
-                if (rsa != null)
-                {
-                    KeyHandle = rsa.DuplicateKeyHandle();
-                }
-            }
-            if (KeyHandle == null)
-            {
-                using (ECDsaOpenSsl? ecdsa = (ECDsaOpenSsl?)target.GetECDsaPrivateKey())
-                {
-                    if (ecdsa != null)
-                    {
-                        KeyHandle = ecdsa.DuplicateKeyHandle();
-                    }
-                }
-                if (KeyHandle== null)
-                {
-                    throw new NotSupportedException(SR.net_ssl_io_no_server_cert);
-                }
-            }
-            CertificateHandle = Interop.Crypto.X509UpRef(target.Handle);
-        }
-        internal static SslStreamCertificateContext Create(X509Certificate2 target) =>
-            Create(target, null, offline: false, trust: null, noOcspFetch: true);
-        internal bool OcspStaplingAvailable => _ocspUrls is not null;
-        partial void SetNoOcspFetch(bool noOcspFetch)
-        {
-            _staplingForbidden = noOcspFetch;
-        }
-        partial void AddRootCertificate(X509Certificate2? rootCertificate, ref bool transferredOwnership)
-        {
-            if (IntermediateCertificates.Length == 0)
-            {
-                _ca = rootCertificate;
-                transferredOwnership = true;
-            }
-            else
-            {
-                _ca = IntermediateCertificates[0];
-            }
-            if (!_staplingForbidden)
-            {
-                GetOcspResponseAsync().AsTask();
-            }
-        }
-        internal byte[]? GetOcspResponseNoWaiting()
-        {
-            try
-            {
-                ValueTask<byte[]?> task = GetOcspResponseAsync();
-                if (task.IsCompletedSuccessfully)
-                {
-                    return task.Result;
-                }
-            }
-            catch
-            {
-            }
-            return null;
-        }
-        internal ValueTask<byte[]?> GetOcspResponseAsync()
-        {
-            if (_staplingForbidden)
-            {
-                return ValueTask.FromResult((byte[]?)null);
-            }
-            DateTimeOffset now = DateTimeOffset.UtcNow;
-            if (now > _ocspExpiration)
-            {
-                return DownloadOcspAsync();
-            }
-            if (now > _nextDownload)
-            {
-#pragma warning disable CA2012 // Use ValueTasks correctly
-                DownloadOcspAsync();
-#pragma warning restore CA2012 // Use ValueTasks correctly
-            }
-            return ValueTask.FromResult(_ocspResponse);
-        }
-        private ValueTask<byte[]?> DownloadOcspAsync()
-        {
-            Task<byte[]?>? pending = _pendingDownload;
-            if (pending is not null && !pending.IsFaulted)
-            {
-                return new ValueTask<byte[]?>(pending);
-            }
-            if (_ocspUrls is null && _ca is not null)
-            {
-                foreach (X509Extension ext in Certificate.Extensions)
-                {
-                    if (ext is X509AuthorityInformationAccessExtension aia)
-                    {
-                        foreach (string entry in aia.EnumerateOcspUris())
-                        {
-                            if (Uri.TryCreate(entry, UriKind.Absolute, out Uri? uri))
-                            {
-                                if (uri.Scheme == UriScheme.Http)
-                                {
-                                    (_ocspUrls ??= new List<string>()).Add(entry);
-                                }
-                            }
-                        }
-                        break;
-                    }
-                }
-            }
-            if (_ocspUrls is null)
-            {
-                _ocspExpiration = _nextDownload = DateTimeOffset.MaxValue;
-                return new ValueTask<byte[]?>((byte[]?)null);
-            }
-            lock (SslContexts)
-            {
-                pending = _pendingDownload;
-                if (pending is null || pending.IsFaulted)
-                {
-                    _pendingDownload = pending = FetchOcspAsync();
-                }
-            }
-            return new ValueTask<byte[]?>(pending);
-        }
-        private async Task<byte[]?> FetchOcspAsync()
-        {
-            X509Certificate2? caCert = _ca;
-            Debug.Assert(_ocspUrls is not null);
-            Debug.Assert(_ocspUrls.Count > 0);
-            Debug.Assert(caCert is not null);
-            IntPtr subject = Certificate.Handle;
-            IntPtr issuer = caCert.Handle;
-            Debug.Assert(subject != 0);
-            Debug.Assert(issuer != 0);
-            if (subject == 0 || issuer == 0)
-            {
-                _staplingForbidden = true;
-                return null;
-            }
-            using (SafeOcspRequestHandle ocspRequest = Interop.Crypto.X509BuildOcspRequest(subject, issuer))
-            {
-                byte[] rentedBytes = ArrayPool<byte>.Shared.Rent(Interop.Crypto.GetOcspRequestDerSize(ocspRequest));
-                int encodingSize = Interop.Crypto.EncodeOcspRequest(ocspRequest, rentedBytes);
-                ArraySegment<byte> encoded = new ArraySegment<byte>(rentedBytes, 0, encodingSize);
-                ArraySegment<char> rentedChars = UrlBase64Encoding.RentEncode(encoded);
-                byte[]? ret = null;
-                for (int i = 0; i < _ocspUrls.Count; i++)
-                {
-                    string url = MakeUrl(_ocspUrls[i], rentedChars);
-                    ret = await System.Net.Http.X509ResourceClient.DownloadAssetAsync(url, TimeSpan.MaxValue).ConfigureAwait(false);
-                    if (ret is not null)
-                    {
-                        if (!Interop.Crypto.X509DecodeOcspToExpiration(ret, ocspRequest, subject, issuer, out DateTimeOffset expiration))
-                        {
-                            continue;
-                        }
-                        if (i != 0)
-                        {
-                            string tmp = _ocspUrls[0];
-                            _ocspUrls[0] = _ocspUrls[i];
-                            _ocspUrls[i] = tmp;
-                        }
-                        DateTimeOffset nextCheckA = DateTimeOffset.UtcNow.AddDays(1);
-                        DateTimeOffset nextCheckB = expiration.AddMinutes(-5);
-                        _ocspResponse = ret;
-                        _ocspExpiration = expiration;
-                        _nextDownload = nextCheckA < nextCheckB ? nextCheckA : nextCheckB;
-                        _pendingDownload = null;
-                        break;
-                    }
-                }
-                ArrayPool<byte>.Shared.Return(rentedBytes);
-                ArrayPool<char>.Shared.Return(rentedChars.Array!);
-                GC.KeepAlive(Certificate);
-                GC.KeepAlive(caCert);
-                return ret;
-            }
-        }
-        private static string MakeUrl(string baseUri, ArraySegment<char> encodedRequest)
-        {
-            Debug.Assert(baseUri.Length > 0);
-            Debug.Assert(encodedRequest.Count > 0);
-            string uriString;
-            if (baseUri.EndsWith('/'))
-            {
-                uriString = string.Concat(baseUri, encodedRequest.AsSpan());
-            }
-            else
-            {
-                uriString = string.Concat(baseUri, "/", encodedRequest.AsSpan());
-            }
-            return uriString;
-        }
-    }
-}

--- a/src/libraries/System.Net.Security/src/System/Net/Security/SslStreamCertificateContext.cs
+++ b//dev/null
@@ -1,103 +0,0 @@
-using System.ComponentModel;
-using System.Security.Cryptography.X509Certificates;
-namespace System.Net.Security
-{
-    public partial class SslStreamCertificateContext
-    {
-        public readonly X509Certificate2 Certificate;
-        public readonly X509Certificate2[] IntermediateCertificates;
-        internal readonly SslCertificateTrust? Trust;
-        [EditorBrowsable(EditorBrowsableState.Never)]
-        public static SslStreamCertificateContext Create(X509Certificate2 target, X509Certificate2Collection? additionalCertificates, bool offline)
-        {
-            return Create(target, additionalCertificates, offline, null);
-        }
-        public static SslStreamCertificateContext Create(X509Certificate2 target, X509Certificate2Collection? additionalCertificates, bool offline = false, SslCertificateTrust? trust = null)
-        {
-            return Create(target, additionalCertificates, offline, trust, noOcspFetch: false);
-        }
-        internal static SslStreamCertificateContext Create(
-            X509Certificate2 target,
-            X509Certificate2Collection? additionalCertificates,
-            bool offline,
-            SslCertificateTrust? trust,
-            bool noOcspFetch)
-        {
-            if (!target.HasPrivateKey)
-            {
-                throw new NotSupportedException(SR.net_ssl_io_no_server_cert);
-            }
-            X509Certificate2[] intermediates = Array.Empty<X509Certificate2>();
-            X509Certificate2? root = null;
-            using (X509Chain chain = new X509Chain())
-            {
-                if (additionalCertificates != null)
-                {
-                    foreach (X509Certificate cert in additionalCertificates)
-                    {
-                        chain.ChainPolicy.ExtraStore.Add(cert);
-                    }
-                }
-                chain.ChainPolicy.VerificationFlags = X509VerificationFlags.AllFlags;
-                chain.ChainPolicy.RevocationMode = X509RevocationMode.NoCheck;
-                chain.ChainPolicy.DisableCertificateDownloads = offline;
-                bool chainStatus = chain.Build(target);
-                if (!chainStatus && NetEventSource.Log.IsEnabled())
-                {
-                    NetEventSource.Error(null, $"Failed to build chain for {target.Subject}");
-                }
-                int count = chain.ChainElements.Count - 1;
-                if (count >= 0)
-                {
-#pragma warning disable 0162 // Disable unreachable code warning. TrimRootCertificate is const bool = false on some platforms
-                    if (TrimRootCertificate)
-                    {
-                        count--;
-                        root = chain.ChainElements[chain.ChainElements.Count - 1].Certificate;
-                        foreach (X509ChainStatus status in chain.ChainStatus)
-                        {
-                            if (status.Status.HasFlag(X509ChainStatusFlags.PartialChain))
-                            {
-                                count++;
-                                root = null;
-                                break;
-                            }
-                        }
-                    }
-#pragma warning restore 0162
-                    if (count > 0 && chain.ChainElements.Count > 1)
-                    {
-                        intermediates = new X509Certificate2[count];
-                        for (int i = 0; i < count; i++)
-                        {
-                            intermediates[i] = chain.ChainElements[i + 1].Certificate;
-                        }
-                    }
-                    chain.ChainElements[0].Certificate.Dispose();
-                    int stopDisposingChainPosition = root is null ?
-                        chain.ChainElements.Count :
-                        chain.ChainElements.Count - 1;
-                    for (int i = count + 1; i < stopDisposingChainPosition; i++)
-                    {
-                        chain.ChainElements[i].Certificate.Dispose();
-                    }
-                }
-            }
-            SslStreamCertificateContext ctx = new SslStreamCertificateContext(target, intermediates, trust);
-            ctx.SetNoOcspFetch(offline || noOcspFetch);
-            bool transferredOwnership = false;
-            ctx.AddRootCertificate(root, ref transferredOwnership);
-            if (!transferredOwnership)
-            {
-                root?.Dispose();
-            }
-            return ctx;
-        }
-        partial void AddRootCertificate(X509Certificate2? rootCertificate, ref bool transferredOwnership);
-        partial void SetNoOcspFetch(bool noOcspFetch);
-        internal SslStreamCertificateContext Duplicate()
-        {
-            return new SslStreamCertificateContext(new X509Certificate2(Certificate), IntermediateCertificates, Trust);
-        }
-    }
-}

--- a/src/libraries/System.Private.CoreLib/src/System/Resources/ResourceReader.cs
+++ b//dev/null
@@ -1,882 +0,0 @@
-using System.Buffers.Binary;
-using System.Collections;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Diagnostics.CodeAnalysis;
-using System.IO;
-using System.Runtime.CompilerServices;
-using System.Text;
-using System.Threading;
-namespace System.Resources
-#if RESOURCES_EXTENSIONS
-    .Extensions
-#endif
-{
-#pragma warning disable IDE0065
-#if RESOURCES_EXTENSIONS
-    using ResourceReader = DeserializingResourceReader;
-#endif
-#pragma warning restore IDE0065
-    internal readonly struct ResourceLocator
-    {
-        internal ResourceLocator(int dataPos, object? value)
-        {
-            DataPosition = dataPos;
-            Value = value;
-        }
-        internal int DataPosition { get; }
-        internal object? Value { get; }
-        internal static bool CanCache(ResourceTypeCode value)
-        {
-            Debug.Assert(value >= 0, "negative ResourceTypeCode.  What?");
-            return value <= ResourceTypeCode.LastPrimitive;
-        }
-    }
-    public sealed partial class
-#if RESOURCES_EXTENSIONS
-        DeserializingResourceReader
-#else
-        ResourceReader
-#endif
-        : IResourceReader
-    {
-        private const int DefaultFileStreamBufferSize = 4096;
-        private BinaryReader _store;
-        internal Dictionary<string, ResourceLocator>? _resCache;
-        private long _nameSectionOffset;  // Offset to name section of file.
-        private long _dataSectionOffset;  // Offset to Data section of file.
-        private int[]? _nameHashes;    // hash values for all names.
-        private unsafe int* _nameHashesPtr;  // In case we're using UnmanagedMemoryStream
-        private int[]? _namePositions; // relative locations of names
-        private unsafe int* _namePositionsPtr;  // If we're using UnmanagedMemoryStream
-        private Type?[] _typeTable;    // Lazy array of Types for resource values.
-        private int[] _typeNamePositions;  // To delay initialize type table
-        private int _numResources;    // Num of resources files, in case arrays aren't allocated.
-        private UnmanagedMemoryStream? _ums;
-        private int _version;
-        public
-#if RESOURCES_EXTENSIONS
-        DeserializingResourceReader(string fileName)
-#else
-        ResourceReader(string fileName)
-#endif
-        {
-            _resCache = new Dictionary<string, ResourceLocator>(FastResourceComparer.Default);
-            _store = new BinaryReader(new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read, DefaultFileStreamBufferSize, FileOptions.RandomAccess), Encoding.UTF8);
-            try
-            {
-                ReadResources();
-            }
-            catch
-            {
-                _store.Close(); // If we threw an exception, close the file.
-                throw;
-            }
-        }
-        public
-#if RESOURCES_EXTENSIONS
-        DeserializingResourceReader(Stream stream)
-#else
-        ResourceReader(Stream stream)
-#endif
-        {
-            if (stream is null)
-            {
-                throw new ArgumentNullException(nameof(stream));
-            }
-            if (!stream.CanRead)
-            {
-                throw new ArgumentException(SR.Argument_StreamNotReadable);
-            }
-            _resCache = new Dictionary<string, ResourceLocator>(FastResourceComparer.Default);
-            _store = new BinaryReader(stream, Encoding.UTF8);
-            _ums = stream as UnmanagedMemoryStream;
-            ReadResources();
-        }
-        internal static bool AllowCustomResourceTypes { get; } = AppContext.TryGetSwitch("System.Resources.ResourceManager.AllowCustomResourceTypes", out bool allowReflection) ? allowReflection : true;
-        public void Close()
-        {
-            Dispose(true);
-        }
-        public void Dispose()
-        {
-            Close();
-        }
-        private unsafe void Dispose(bool disposing)
-        {
-            if (_store != null)
-            {
-                _resCache = null;
-                if (disposing)
-                {
-                    BinaryReader copyOfStore = _store;
-                    _store = null!;
-                    copyOfStore?.Close();
-                }
-                _store = null!;
-                _namePositions = null;
-                _nameHashes = null;
-                _ums = null;
-                _namePositionsPtr = null;
-                _nameHashesPtr = null;
-            }
-        }
-        private static unsafe int ReadUnalignedI4(int* p)
-        {
-            return BinaryPrimitives.ReadInt32LittleEndian(new ReadOnlySpan<byte>(p, sizeof(int)));
-        }
-        private void SkipString()
-        {
-            int stringLength = _store.Read7BitEncodedInt();
-            if (stringLength < 0)
-            {
-                throw new BadImageFormatException(SR.BadImageFormat_NegativeStringLength);
-            }
-            _store.BaseStream.Seek(stringLength, SeekOrigin.Current);
-        }
-        private unsafe int GetNameHash(int index)
-        {
-            Debug.Assert(index >= 0 && index < _numResources, $"Bad index into hash array.  index: {index}");
-            if (_ums == null)
-            {
-                Debug.Assert(_nameHashes != null && _nameHashesPtr == null, "Internal state mangled.");
-                return _nameHashes[index];
-            }
-            else
-            {
-                Debug.Assert(_nameHashes == null && _nameHashesPtr != null, "Internal state mangled.");
-                return ReadUnalignedI4(&_nameHashesPtr[index]);
-            }
-        }
-        private unsafe int GetNamePosition(int index)
-        {
-            Debug.Assert(index >= 0 && index < _numResources, $"Bad index into name position array.  index: {index}");
-            int r;
-            if (_ums == null)
-            {
-                Debug.Assert(_namePositions != null && _namePositionsPtr == null, "Internal state mangled.");
-                r = _namePositions[index];
-            }
-            else
-            {
-                Debug.Assert(_namePositions == null && _namePositionsPtr != null, "Internal state mangled.");
-                r = ReadUnalignedI4(&_namePositionsPtr[index]);
-            }
-            if (r < 0 || r > _dataSectionOffset - _nameSectionOffset)
-            {
-                throw new FormatException(SR.Format(SR.BadImageFormat_ResourcesNameInvalidOffset, r));
-            }
-            return r;
-        }
-        IEnumerator IEnumerable.GetEnumerator()
-        {
-            return GetEnumerator();
-        }
-        public IDictionaryEnumerator GetEnumerator()
-        {
-            if (_resCache == null)
-                throw new InvalidOperationException(SR.ResourceReaderIsClosed);
-            return new ResourceEnumerator(this);
-        }
-        internal ResourceEnumerator GetEnumeratorInternal()
-        {
-            return new ResourceEnumerator(this);
-        }
-        internal int FindPosForResource(string name)
-        {
-            Debug.Assert(_store != null, "ResourceReader is closed!");
-            int hash = FastResourceComparer.HashFunction(name);
-            int lo = 0;
-            int hi = _numResources - 1;
-            int index = -1;
-            bool success = false;
-            while (lo <= hi)
-            {
-                index = (lo + hi) >> 1;
-                int currentHash = GetNameHash(index);
-                int c;
-                if (currentHash == hash)
-                    c = 0;
-                else if (currentHash < hash)
-                    c = -1;
-                else
-                    c = 1;
-                if (c == 0)
-                {
-                    success = true;
-                    break;
-                }
-                if (c < 0)
-                    lo = index + 1;
-                else
-                    hi = index - 1;
-            }
-            if (!success)
-            {
-                return -1;
-            }
-            if (lo != index)
-            {
-                lo = index;
-                while (lo > 0 && GetNameHash(lo - 1) == hash)
-                    lo--;
-            }
-            if (hi != index)
-            {
-                hi = index;
-                while (hi < _numResources - 1 && GetNameHash(hi + 1) == hash)
-                    hi++;
-            }
-            lock (this)
-            {
-                for (int i = lo; i <= hi; i++)
-                {
-                    _store.BaseStream.Seek(_nameSectionOffset + GetNamePosition(i), SeekOrigin.Begin);
-                    if (CompareStringEqualsName(name))
-                    {
-                        int dataPos = _store.ReadInt32();
-                        if (dataPos < 0 || dataPos >= _store.BaseStream.Length - _dataSectionOffset)
-                        {
-                            throw new FormatException(SR.Format(SR.BadImageFormat_ResourcesDataInvalidOffset, dataPos));
-                        }
-                        return dataPos;
-                    }
-                }
-            }
-            return -1;
-        }
-        private unsafe bool CompareStringEqualsName(string name)
-        {
-            Debug.Assert(_store != null, "ResourceReader is closed!");
-            Debug.Assert(Monitor.IsEntered(this)); // uses _store
-            int byteLen = _store.Read7BitEncodedInt();
-            if (byteLen < 0)
-            {
-                throw new BadImageFormatException(SR.BadImageFormat_NegativeStringLength);
-            }
-            if (_ums != null)
-            {
-                byte* bytes = _ums.PositionPointer;
-                _ums.Seek(byteLen, SeekOrigin.Current);
-                if (_ums.Position > _ums.Length)
-                {
-                    throw new BadImageFormatException(SR.BadImageFormat_ResourcesNameTooLong);
-                }
-                return FastResourceComparer.CompareOrdinal(bytes, byteLen, name) == 0;
-            }
-            else
-            {
-                byte[] bytes = new byte[byteLen];
-                int numBytesToRead = byteLen;
-                while (numBytesToRead > 0)
-                {
-                    int n = _store.Read(bytes, byteLen - numBytesToRead, numBytesToRead);
-                    if (n == 0)
-                        throw new BadImageFormatException(SR.BadImageFormat_ResourceNameCorrupted);
-                    numBytesToRead -= n;
-                }
-                return FastResourceComparer.CompareOrdinal(bytes, byteLen / 2, name) == 0;
-            }
-        }
-        private unsafe string AllocateStringForNameIndex(int index, out int dataOffset)
-        {
-            Debug.Assert(_store != null, "ResourceReader is closed!");
-            byte[] bytes;
-            int byteLen;
-            long nameVA = GetNamePosition(index);
-            lock (this)
-            {
-                _store.BaseStream.Seek(nameVA + _nameSectionOffset, SeekOrigin.Begin);
-                byteLen = _store.Read7BitEncodedInt();
-                if (byteLen < 0)
-                {
-                    throw new BadImageFormatException(SR.BadImageFormat_NegativeStringLength);
-                }
-                if (_ums != null)
-                {
-                    if (_ums.Position > _ums.Length - byteLen)
-                        throw new BadImageFormatException(SR.Format(SR.BadImageFormat_ResourcesIndexTooLong, index));
-                    string? s = null;
-                    char* charPtr = (char*)_ums.PositionPointer;
-                    if (BitConverter.IsLittleEndian)
-                    {
-                        s = new string(charPtr, 0, byteLen / 2);
-                    }
-                    else
-                    {
-                        char[] arr = new char[byteLen / 2];
-                        for (int i = 0; i < arr.Length; i++)
-                        {
-                            arr[i] = (char)BinaryPrimitives.ReverseEndianness((short)charPtr[i]);
-                        }
-                        s = new string(arr);
-                    }
-                    _ums.Position += byteLen;
-                    dataOffset = _store.ReadInt32();
-                    if (dataOffset < 0 || dataOffset >= _store.BaseStream.Length - _dataSectionOffset)
-                    {
-                        throw new FormatException(SR.Format(SR.BadImageFormat_ResourcesDataInvalidOffset, dataOffset));
-                    }
-                    return s;
-                }
-                bytes = new byte[byteLen];
-                int count = byteLen;
-                while (count > 0)
-                {
-                    int n = _store.Read(bytes, byteLen - count, count);
-                    if (n == 0)
-                        throw new EndOfStreamException(SR.Format(SR.BadImageFormat_ResourceNameCorrupted_NameIndex, index));
-                    count -= n;
-                }
-                dataOffset = _store.ReadInt32();
-                if (dataOffset < 0 || dataOffset >= _store.BaseStream.Length - _dataSectionOffset)
-                {
-                    throw new FormatException(SR.Format(SR.BadImageFormat_ResourcesDataInvalidOffset, dataOffset));
-                }
-            }
-            return Encoding.Unicode.GetString(bytes, 0, byteLen);
-        }
-        private object? GetValueForNameIndex(int index)
-        {
-            Debug.Assert(_store != null, "ResourceReader is closed!");
-            long nameVA = GetNamePosition(index);
-            lock (this)
-            {
-                _store.BaseStream.Seek(nameVA + _nameSectionOffset, SeekOrigin.Begin);
-                SkipString();
-                int dataPos = _store.ReadInt32();
-                if (dataPos < 0 || dataPos >= _store.BaseStream.Length - _dataSectionOffset)
-                {
-                    throw new FormatException(SR.Format(SR.BadImageFormat_ResourcesDataInvalidOffset, dataPos));
-                }
-                if (_version == 1)
-                    return LoadObjectV1(dataPos);
-                else
-                    return LoadObjectV2(dataPos, out _);
-            }
-        }
-        internal string? LoadString(int pos)
-        {
-            Debug.Assert(_store != null, "ResourceReader is closed!");
-            lock (this)
-            {
-                _store.BaseStream.Seek(_dataSectionOffset + pos, SeekOrigin.Begin);
-                string? s = null;
-                int typeIndex = _store.Read7BitEncodedInt();
-                if (_version == 1)
-                {
-                    if (typeIndex == -1)
-                        return null;
-                    if (FindType(typeIndex) != typeof(string))
-                        throw new InvalidOperationException(SR.Format(SR.InvalidOperation_ResourceNotString_Type, FindType(typeIndex).FullName));
-                    s = _store.ReadString();
-                }
-                else
-                {
-                    ResourceTypeCode typeCode = (ResourceTypeCode)typeIndex;
-                    if (typeCode != ResourceTypeCode.String && typeCode != ResourceTypeCode.Null)
-                    {
-                        string? typeString;
-                        if (typeCode < ResourceTypeCode.StartOfUserTypes)
-                            typeString = typeCode.ToString();
-                        else
-                            typeString = FindType(typeCode - ResourceTypeCode.StartOfUserTypes).FullName;
-                        throw new InvalidOperationException(SR.Format(SR.InvalidOperation_ResourceNotString_Type, typeString));
-                    }
-                    if (typeCode == ResourceTypeCode.String) // ignore Null
-                        s = _store.ReadString();
-                }
-                return s;
-            }
-        }
-        internal object? LoadObject(int pos)
-        {
-            lock (this)
-            {
-                return _version == 1 ? LoadObjectV1(pos) : LoadObjectV2(pos, out _);
-            }
-        }
-        internal object? LoadObject(int pos, out ResourceTypeCode typeCode)
-        {
-            lock (this)
-            {
-                if (_version == 1)
-                {
-                    object? o = LoadObjectV1(pos);
-                    typeCode = (o is string) ? ResourceTypeCode.String : ResourceTypeCode.StartOfUserTypes;
-                    return o;
-                }
-                return LoadObjectV2(pos, out typeCode);
-            }
-        }
-        private object? LoadObjectV1(int pos)
-        {
-            Debug.Assert(_store != null, "ResourceReader is closed!");
-            Debug.Assert(_version == 1, ".resources file was not a V1 .resources file!");
-            Debug.Assert(Monitor.IsEntered(this)); // uses _store
-            try
-            {
-                return _LoadObjectV1(pos);
-            }
-            catch (EndOfStreamException eof)
-            {
-                throw new BadImageFormatException(SR.BadImageFormat_TypeMismatch, eof);
-            }
-            catch (ArgumentOutOfRangeException e)
-            {
-                throw new BadImageFormatException(SR.BadImageFormat_TypeMismatch, e);
-            }
-        }
-        private object? _LoadObjectV1(int pos)
-        {
-            Debug.Assert(Monitor.IsEntered(this)); // uses _store
-            _store.BaseStream.Seek(_dataSectionOffset + pos, SeekOrigin.Begin);
-            int typeIndex = _store.Read7BitEncodedInt();
-            if (typeIndex == -1)
-                return null;
-            Type type = FindType(typeIndex);
-            if (type == typeof(string))
-                return _store.ReadString();
-            else if (type == typeof(int))
-                return _store.ReadInt32();
-            else if (type == typeof(byte))
-                return _store.ReadByte();
-            else if (type == typeof(sbyte))
-                return _store.ReadSByte();
-            else if (type == typeof(short))
-                return _store.ReadInt16();
-            else if (type == typeof(long))
-                return _store.ReadInt64();
-            else if (type == typeof(ushort))
-                return _store.ReadUInt16();
-            else if (type == typeof(uint))
-                return _store.ReadUInt32();
-            else if (type == typeof(ulong))
-                return _store.ReadUInt64();
-            else if (type == typeof(float))
-                return _store.ReadSingle();
-            else if (type == typeof(double))
-                return _store.ReadDouble();
-            else if (type == typeof(DateTime))
-            {
-                return new DateTime(_store.ReadInt64());
-            }
-            else if (type == typeof(TimeSpan))
-                return new TimeSpan(_store.ReadInt64());
-            else if (type == typeof(decimal))
-            {
-#if RESOURCES_EXTENSIONS
-                int[] bits = new int[4];
-#else
-                Span<int> bits = stackalloc int[4];
-#endif
-                for (int i = 0; i < bits.Length; i++)
-                    bits[i] = _store.ReadInt32();
-                return new decimal(bits);
-            }
-            else
-            {
-                return DeserializeObject(typeIndex);
-            }
-        }
-        private object? LoadObjectV2(int pos, out ResourceTypeCode typeCode)
-        {
-            Debug.Assert(_store != null, "ResourceReader is closed!");
-            Debug.Assert(_version >= 2, ".resources file was not a V2 (or higher) .resources file!");
-            Debug.Assert(Monitor.IsEntered(this)); // uses _store
-            try
-            {
-                return _LoadObjectV2(pos, out typeCode);
-            }
-            catch (EndOfStreamException eof)
-            {
-                throw new BadImageFormatException(SR.BadImageFormat_TypeMismatch, eof);
-            }
-            catch (ArgumentOutOfRangeException e)
-            {
-                throw new BadImageFormatException(SR.BadImageFormat_TypeMismatch, e);
-            }
-        }
-        private object? _LoadObjectV2(int pos, out ResourceTypeCode typeCode)
-        {
-            Debug.Assert(Monitor.IsEntered(this)); // uses _store
-            _store.BaseStream.Seek(_dataSectionOffset + pos, SeekOrigin.Begin);
-            typeCode = (ResourceTypeCode)_store.Read7BitEncodedInt();
-            switch (typeCode)
-            {
-                case ResourceTypeCode.Null:
-                    return null;
-                case ResourceTypeCode.String:
-                    return _store.ReadString();
-                case ResourceTypeCode.Boolean:
-                    return _store.ReadBoolean();
-                case ResourceTypeCode.Char:
-                    return (char)_store.ReadUInt16();
-                case ResourceTypeCode.Byte:
-                    return _store.ReadByte();
-                case ResourceTypeCode.SByte:
-                    return _store.ReadSByte();
-                case ResourceTypeCode.Int16:
-                    return _store.ReadInt16();
-                case ResourceTypeCode.UInt16:
-                    return _store.ReadUInt16();
-                case ResourceTypeCode.Int32:
-                    return _store.ReadInt32();
-                case ResourceTypeCode.UInt32:
-                    return _store.ReadUInt32();
-                case ResourceTypeCode.Int64:
-                    return _store.ReadInt64();
-                case ResourceTypeCode.UInt64:
-                    return _store.ReadUInt64();
-                case ResourceTypeCode.Single:
-                    return _store.ReadSingle();
-                case ResourceTypeCode.Double:
-                    return _store.ReadDouble();
-                case ResourceTypeCode.Decimal:
-                    return _store.ReadDecimal();
-                case ResourceTypeCode.DateTime:
-                    long data = _store.ReadInt64();
-                    return DateTime.FromBinary(data);
-                case ResourceTypeCode.TimeSpan:
-                    long ticks = _store.ReadInt64();
-                    return new TimeSpan(ticks);
-                case ResourceTypeCode.ByteArray:
-                    {
-                        int len = _store.ReadInt32();
-                        if (len < 0)
-                        {
-                            throw new BadImageFormatException(SR.Format(SR.BadImageFormat_ResourceDataLengthInvalid, len));
-                        }
-                        if (_ums == null)
-                        {
-                            if (len > _store.BaseStream.Length)
-                            {
-                                throw new BadImageFormatException(SR.Format(SR.BadImageFormat_ResourceDataLengthInvalid, len));
-                            }
-                            return _store.ReadBytes(len);
-                        }
-                        if (len > _ums.Length - _ums.Position)
-                        {
-                            throw new BadImageFormatException(SR.Format(SR.BadImageFormat_ResourceDataLengthInvalid, len));
-                        }
-                        byte[] bytes = new byte[len];
-                        int r = _ums.Read(bytes, 0, len);
-                        Debug.Assert(r == len, "ResourceReader needs to use a blocking read here.  (Call _store.ReadBytes(len)?)");
-                        return bytes;
-                    }
-                case ResourceTypeCode.Stream:
-                    {
-                        int len = _store.ReadInt32();
-                        if (len < 0)
-                        {
-                            throw new BadImageFormatException(SR.Format(SR.BadImageFormat_ResourceDataLengthInvalid, len));
-                        }
-                        if (_ums == null)
-                        {
-                            byte[] bytes = _store.ReadBytes(len);
-                            return new PinnedBufferMemoryStream(bytes);
-                        }
-                        if (len > _ums.Length - _ums.Position)
-                        {
-                            throw new BadImageFormatException(SR.Format(SR.BadImageFormat_ResourceDataLengthInvalid, len));
-                        }
-                        unsafe
-                        {
-                            return new UnmanagedMemoryStream(_ums.PositionPointer, len, len, FileAccess.Read);
-                        }
-                    }
-                default:
-                    if (typeCode < ResourceTypeCode.StartOfUserTypes)
-                    {
-                        throw new BadImageFormatException(SR.BadImageFormat_TypeMismatch);
-                    }
-                    break;
-            }
-            int typeIndex = typeCode - ResourceTypeCode.StartOfUserTypes;
-            return DeserializeObject(typeIndex);
-        }
-        [MemberNotNull(nameof(_typeTable))]
-        [MemberNotNull(nameof(_typeNamePositions))]
-        private void ReadResources()
-        {
-            Debug.Assert(!Monitor.IsEntered(this)); // only called during init
-            Debug.Assert(_store != null, "ResourceReader is closed!");
-            try
-            {
-                _ReadResources();
-            }
-            catch (EndOfStreamException eof)
-            {
-                throw new BadImageFormatException(SR.BadImageFormat_ResourcesHeaderCorrupted, eof);
-            }
-            catch (IndexOutOfRangeException e)
-            {
-                throw new BadImageFormatException(SR.BadImageFormat_ResourcesHeaderCorrupted, e);
-            }
-        }
-        [MemberNotNull(nameof(_typeTable))]
-        [MemberNotNull(nameof(_typeNamePositions))]
-        private void _ReadResources()
-        {
-            Debug.Assert(!Monitor.IsEntered(this)); // only called during init
-            int magicNum = _store.ReadInt32();
-            if (magicNum != ResourceManager.MagicNumber)
-                throw new ArgumentException(SR.Resources_StreamNotValid);
-            int resMgrHeaderVersion = _store.ReadInt32();
-            int numBytesToSkip = _store.ReadInt32();
-            if (numBytesToSkip < 0 || resMgrHeaderVersion < 0)
-            {
-                throw new BadImageFormatException(SR.BadImageFormat_ResourcesHeaderCorrupted);
-            }
-            if (resMgrHeaderVersion > 1)
-            {
-                _store.BaseStream.Seek(numBytesToSkip, SeekOrigin.Current);
-            }
-            else
-            {
-                string readerType = _store.ReadString();
-                if (!ValidateReaderType(readerType))
-                    throw new NotSupportedException(SR.Format(SR.NotSupported_WrongResourceReader_Type, readerType));
-                SkipString();
-            }
-            int version = _store.ReadInt32();
-            const int CurrentVersion = 2;
-            if (version != CurrentVersion && version != 1)
-                throw new ArgumentException(SR.Format(SR.Arg_ResourceFileUnsupportedVersion, CurrentVersion, version));
-            _version = version;
-            _numResources = _store.ReadInt32();
-            if (_numResources < 0)
-            {
-                throw new BadImageFormatException(SR.BadImageFormat_ResourcesHeaderCorrupted);
-            }
-            int numTypes = _store.ReadInt32();
-            if (numTypes < 0)
-            {
-                throw new BadImageFormatException(SR.BadImageFormat_ResourcesHeaderCorrupted);
-            }
-            _typeTable = new Type[numTypes];
-            _typeNamePositions = new int[numTypes];
-            for (int i = 0; i < numTypes; i++)
-            {
-                _typeNamePositions[i] = (int)_store.BaseStream.Position;
-                SkipString();
-            }
-            long pos = _store.BaseStream.Position;
-            int alignBytes = ((int)pos) & 7;
-            if (alignBytes != 0)
-            {
-                for (int i = 0; i < 8 - alignBytes; i++)
-                {
-                    _store.ReadByte();
-                }
-            }
-            if (_ums == null)
-            {
-                _nameHashes = new int[_numResources];
-                for (int i = 0; i < _numResources; i++)
-                {
-                    _nameHashes[i] = _store.ReadInt32();
-                }
-            }
-            else
-            {
-                int seekPos = unchecked(4 * _numResources);
-                if (seekPos < 0)
-                {
-                    throw new BadImageFormatException(SR.BadImageFormat_ResourcesHeaderCorrupted);
-                }
-                unsafe
-                {
-                    _nameHashesPtr = (int*)_ums.PositionPointer;
-                    _ums.Seek(seekPos, SeekOrigin.Current);
-                    _ = _ums.PositionPointer;
-                }
-            }
-            if (_ums == null)
-            {
-                _namePositions = new int[_numResources];
-                for (int i = 0; i < _numResources; i++)
-                {
-                    int namePosition = _store.ReadInt32();
-                    if (namePosition < 0)
-                    {
-                        throw new BadImageFormatException(SR.BadImageFormat_ResourcesHeaderCorrupted);
-                    }
-                    _namePositions[i] = namePosition;
-                }
-            }
-            else
-            {
-                int seekPos = unchecked(4 * _numResources);
-                if (seekPos < 0)
-                {
-                    throw new BadImageFormatException(SR.BadImageFormat_ResourcesHeaderCorrupted);
-                }
-                unsafe
-                {
-                    _namePositionsPtr = (int*)_ums.PositionPointer;
-                    _ums.Seek(seekPos, SeekOrigin.Current);
-                    _ = _ums.PositionPointer;
-                }
-            }
-            _dataSectionOffset = _store.ReadInt32();
-            if (_dataSectionOffset < 0)
-            {
-                throw new BadImageFormatException(SR.BadImageFormat_ResourcesHeaderCorrupted);
-            }
-            _nameSectionOffset = _store.BaseStream.Position;
-            if (_dataSectionOffset < _nameSectionOffset)
-            {
-                throw new BadImageFormatException(SR.BadImageFormat_ResourcesHeaderCorrupted);
-            }
-        }
-        [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode",
-            Justification = "UseReflectionToGetType will get trimmed out when AllowCustomResourceTypes is set to false. " +
-            "When set to true, we will already throw a warning for this feature switch, so we suppress this one in order for" +
-            "the user to only get one error.")]
-        private Type FindType(int typeIndex)
-        {
-            if (!AllowCustomResourceTypes)
-            {
-                throw new NotSupportedException(SR.ResourceManager_ReflectionNotAllowed);
-            }
-            if (typeIndex < 0 || typeIndex >= _typeTable.Length)
-            {
-                throw new BadImageFormatException(SR.BadImageFormat_InvalidType);
-            }
-            return _typeTable[typeIndex] ?? UseReflectionToGetType(typeIndex);
-        }
-        [RequiresUnreferencedCode("The CustomResourceTypesSupport feature switch has been enabled for this app which is being trimmed. " +
-            "Custom readers as well as custom objects on the resources file are not observable by the trimmer and so required assemblies, types and members may be removed.")]
-        private Type UseReflectionToGetType(int typeIndex)
-        {
-            Debug.Assert(Monitor.IsEntered(this)); // uses _store
-            long oldPos = _store.BaseStream.Position;
-            try
-            {
-                _store.BaseStream.Position = _typeNamePositions[typeIndex];
-                string typeName = _store.ReadString();
-                _typeTable[typeIndex] = Type.GetType(typeName, true);
-                Debug.Assert(_typeTable[typeIndex] != null, "Should have found a type!");
-                return _typeTable[typeIndex]!;
-            }
-#if !RESOURCES_EXTENSIONS
-            catch (FileNotFoundException fileNotFoundException) when (!_permitDeserialization)
-            {
-                throw new NotSupportedException(SR.NotSupported_ResourceObjectSerialization, fileNotFoundException);
-            }
-#endif
-            finally
-            {
-                _store.BaseStream.Position = oldPos;
-            }
-        }
-        private string TypeNameFromTypeCode(ResourceTypeCode typeCode)
-        {
-            Debug.Assert(typeCode >= 0, "can't be negative");
-            Debug.Assert(Monitor.IsEntered(this)); // uses _store
-            if (typeCode < ResourceTypeCode.StartOfUserTypes)
-            {
-                Debug.Assert(!string.Equals(typeCode.ToString(), "LastPrimitive"), "Change ResourceTypeCode metadata order so LastPrimitive isn't what Enum.ToString prefers.");
-                return "ResourceTypeCode." + typeCode.ToString();
-            }
-            else
-            {
-                int typeIndex = typeCode - ResourceTypeCode.StartOfUserTypes;
-                Debug.Assert(typeIndex >= 0 && typeIndex < _typeTable.Length, "TypeCode is broken or corrupted!");
-                long oldPos = _store.BaseStream.Position;
-                try
-                {
-                    _store.BaseStream.Position = _typeNamePositions[typeIndex];
-                    return _store.ReadString();
-                }
-                finally
-                {
-                    _store.BaseStream.Position = oldPos;
-                }
-            }
-        }
-        internal sealed class ResourceEnumerator : IDictionaryEnumerator
-        {
-            private const int ENUM_DONE = int.MinValue;
-            private const int ENUM_NOT_STARTED = -1;
-            private readonly ResourceReader _reader;
-            private bool _currentIsValid;
-            private int _currentName;
-            private int _dataPosition; // cached for case-insensitive table
-            internal ResourceEnumerator(ResourceReader reader)
-            {
-                _currentName = ENUM_NOT_STARTED;
-                _reader = reader;
-                _dataPosition = -2;
-            }
-            public bool MoveNext()
-            {
-                if (_currentName == _reader._numResources - 1 || _currentName == ENUM_DONE)
-                {
-                    _currentIsValid = false;
-                    _currentName = ENUM_DONE;
-                    return false;
-                }
-                _currentIsValid = true;
-                _currentName++;
-                return true;
-            }
-            public object Key
-            {
-                get
-                {
-                    if (_currentName == ENUM_DONE) throw new InvalidOperationException(SR.InvalidOperation_EnumEnded);
-                    if (!_currentIsValid) throw new InvalidOperationException(SR.InvalidOperation_EnumNotStarted);
-                    if (_reader._resCache == null) throw new InvalidOperationException(SR.ResourceReaderIsClosed);
-                    return _reader.AllocateStringForNameIndex(_currentName, out _dataPosition);
-                }
-            }
-            public object Current => Entry;
-            internal int DataPosition => _dataPosition;
-            public DictionaryEntry Entry
-            {
-                get
-                {
-                    if (_currentName == ENUM_DONE) throw new InvalidOperationException(SR.InvalidOperation_EnumEnded);
-                    if (!_currentIsValid) throw new InvalidOperationException(SR.InvalidOperation_EnumNotStarted);
-                    if (_reader._resCache == null) throw new InvalidOperationException(SR.ResourceReaderIsClosed);
-                    string key = _reader.AllocateStringForNameIndex(_currentName, out _dataPosition); // AllocateStringForNameIndex could lock on _reader
-                    object? value = null;
-                    Debug.Assert(!Monitor.IsEntered(_reader));
-                    lock (_reader._resCache)
-                    {
-                        if (_reader._resCache.TryGetValue(key, out ResourceLocator locator))
-                        {
-                            value = locator.Value;
-                        }
-                    }
-                    if (value is null)
-                    {
-                        if (_dataPosition == -1)
-                            value = _reader.GetValueForNameIndex(_currentName);
-                        else
-                            value = _reader.LoadObject(_dataPosition);
-                    }
-                    return new DictionaryEntry(key, value);
-                }
-            }
-            public object? Value
-            {
-                get
-                {
-                    if (_currentName == ENUM_DONE) throw new InvalidOperationException(SR.InvalidOperation_EnumEnded);
-                    if (!_currentIsValid) throw new InvalidOperationException(SR.InvalidOperation_EnumNotStarted);
-                    if (_reader._resCache == null) throw new InvalidOperationException(SR.ResourceReaderIsClosed);
-                    return _reader.GetValueForNameIndex(_currentName);
-                }
-            }
-            public void Reset()
-            {
-                if (_reader._resCache == null) throw new InvalidOperationException(SR.ResourceReaderIsClosed);
-                _currentIsValid = false;
-                _currentName = ENUM_NOT_STARTED;
-            }
-        }
-    }
-}

--- a/src/libraries/System.Private.CoreLib/src/System/Resources/RuntimeResourceSet.cs
+++ b//dev/null
@@ -1,179 +0,0 @@
-using System.Collections;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.IO;
-using System.Threading;
-namespace System.Resources
-#if RESOURCES_EXTENSIONS
-    .Extensions
-#endif
-{
-#pragma warning disable IDE0065
-#if RESOURCES_EXTENSIONS
-    using ResourceReader = DeserializingResourceReader;
-#endif
-#pragma warning restore IDE0065
-#if NATIVEAOT
-    public  // On NativeAOT, this must be public to prevent it from getting reflection blocked.
-#else
-    internal
-#endif
-    sealed class RuntimeResourceSet : ResourceSet, IEnumerable
-    {
-        private Dictionary<string, ResourceLocator>? _resCache;
-        private ResourceReader? _defaultReader;
-        private Dictionary<string, ResourceLocator>? _caseInsensitiveTable;
-#if !RESOURCES_EXTENSIONS
-        internal RuntimeResourceSet(string fileName) :
-            this(new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read))
-        {
-        }
-        internal RuntimeResourceSet(Stream stream, bool permitDeserialization = false) :
-            base(false)
-        {
-            _resCache = new Dictionary<string, ResourceLocator>(FastResourceComparer.Default);
-            _defaultReader = new ResourceReader(stream, _resCache, permitDeserialization);
-        }
-#else
-        internal RuntimeResourceSet(IResourceReader reader) :
-            base()
-        {
-            if (reader is null)
-            {
-                throw new ArgumentNullException(nameof(reader));
-            }
-            _defaultReader = reader as DeserializingResourceReader ?? throw new ArgumentException(SR.Format(SR.NotSupported_WrongResourceReader_Type, reader.GetType()), nameof(reader));
-            _resCache = new Dictionary<string, ResourceLocator>(FastResourceComparer.Default);
-            _defaultReader._resCache = _resCache;
-        }
-#endif
-        protected override void Dispose(bool disposing)
-        {
-            if (_defaultReader is null)
-                return;
-            if (disposing)
-            {
-                _defaultReader?.Close();
-            }
-            _defaultReader = null;
-            _resCache = null;
-            _caseInsensitiveTable = null;
-            base.Dispose(disposing);
-        }
-        public override IDictionaryEnumerator GetEnumerator()
-        {
-            return GetEnumeratorHelper();
-        }
-        IEnumerator IEnumerable.GetEnumerator()
-        {
-            return GetEnumeratorHelper();
-        }
-        private IDictionaryEnumerator GetEnumeratorHelper()
-        {
-            ResourceReader? reader = _defaultReader;
-            if (reader is null)
-                throw new ObjectDisposedException(null, SR.ObjectDisposed_ResourceSet);
-            return reader.GetEnumerator();
-        }
-        public override string? GetString(string key)
-        {
-            object? o = GetObject(key, false, true);
-            return (string?)o;
-        }
-        public override string? GetString(string key, bool ignoreCase)
-        {
-            object? o = GetObject(key, ignoreCase, true);
-            return (string?)o;
-        }
-        public override object? GetObject(string key)
-        {
-            return GetObject(key, false, false);
-        }
-        public override object? GetObject(string key, bool ignoreCase)
-        {
-            return GetObject(key, ignoreCase, false);
-        }
-        private object? GetObject(string key, bool ignoreCase, bool isString)
-        {
-            if (key is null)
-            {
-                throw new ArgumentNullException(nameof(key));
-            }
-            ResourceReader? reader = _defaultReader;
-            Dictionary<string, ResourceLocator>? cache = _resCache;
-            if (reader is null || cache is null)
-                throw new ObjectDisposedException(null, SR.ObjectDisposed_ResourceSet);
-            object? value;
-            ResourceLocator resEntry;
-            Debug.Assert(!Monitor.IsEntered(reader));
-            lock (cache)
-            {
-                int dataPos;
-                if (cache.TryGetValue(key, out resEntry))
-                {
-                    value = resEntry.Value;
-                    if (value != null)
-                        return value;
-                    dataPos = resEntry.DataPosition;
-                    return isString ? reader.LoadString(dataPos) : reader.LoadObject(dataPos);
-                }
-                dataPos = reader.FindPosForResource(key);
-                if (dataPos >= 0)
-                {
-                    value = ReadValue(reader, dataPos, isString, out resEntry);
-                    cache[key] = resEntry;
-                    return value;
-                }
-            }
-            if (!ignoreCase)
-            {
-                return null;
-            }
-            bool initialize = false;
-            Dictionary<string, ResourceLocator>? caseInsensitiveTable = _caseInsensitiveTable;
-            if (caseInsensitiveTable == null)
-            {
-                caseInsensitiveTable = new Dictionary<string, ResourceLocator>(StringComparer.OrdinalIgnoreCase);
-                initialize = true;
-            }
-            lock (caseInsensitiveTable)
-            {
-                if (initialize)
-                {
-                    ResourceReader.ResourceEnumerator en = reader.GetEnumeratorInternal();
-                    while (en.MoveNext())
-                    {
-                        string currentKey = (string)en.Key;
-                        ResourceLocator resLoc = new ResourceLocator(en.DataPosition, null);
-                        caseInsensitiveTable.Add(currentKey, resLoc);
-                    }
-                    _caseInsensitiveTable = caseInsensitiveTable;
-                }
-                if (!caseInsensitiveTable.TryGetValue(key, out resEntry))
-                    return null;
-                if (resEntry.Value != null)
-                    return resEntry.Value;
-                value = ReadValue(reader, resEntry.DataPosition, isString, out resEntry);
-                if (resEntry.Value != null)
-                    caseInsensitiveTable[key] = resEntry;
-            }
-            return value;
-        }
-        private static object? ReadValue(ResourceReader reader, int dataPos, bool isString, out ResourceLocator locator)
-        {
-            object? value;
-            ResourceTypeCode typeCode;
-            if (isString)
-            {
-                value = reader.LoadString(dataPos);
-                typeCode = ResourceTypeCode.String;
-            }
-            else
-            {
-                value = reader.LoadObject(dataPos, out typeCode);
-            }
-            locator = new ResourceLocator(dataPos, ResourceLocator.CanCache(typeCode) ? value : null);
-            return value;
-        }
-    }
-}

--- a/src/libraries/System.Private.CoreLib/src/System/Threading/PortableThreadPool.Unix.cs
+++ b//dev/null
@@ -1,16 +0,0 @@
-namespace System.Threading
-{
-    internal sealed partial class PortableThreadPool
-    {
-        private static partial class WorkerThread
-        {
-            private static bool IsIOPending => false;
-        }
-        private struct CpuUtilizationReader
-        {
-            private Interop.Sys.ProcessCpuInformation _cpuInfo;
-            public double CurrentUtilization =>
-                Interop.Sys.GetCpuUtilization(ref _cpuInfo) / Environment.ProcessorCount;
-        }
-    }
-}

--- a/src/libraries/System.Private.CoreLib/src/System/Threading/PortableThreadPool.Windows.cs
+++ b//dev/null
@@ -1,50 +0,0 @@
-using System.Diagnostics;
-using System.Runtime.InteropServices;
-namespace System.Threading
-{
-    internal sealed partial class PortableThreadPool
-    {
-        private static partial class WorkerThread
-        {
-            private static bool IsIOPending
-            {
-                get
-                {
-                    bool success =
-                        Interop.Kernel32.GetThreadIOPendingFlag(Interop.Kernel32.GetCurrentThread(), out Interop.BOOL isIOPending);
-                    Debug.Assert(success);
-                    return !success || isIOPending != Interop.BOOL.FALSE;
-                }
-            }
-        }
-        private struct CpuUtilizationReader
-        {
-            public long _idleTime;
-            public long _kernelTime;
-            public long _userTime;
-            public int CurrentUtilization
-            {
-                get
-                {
-                    if (!Interop.Kernel32.GetSystemTimes(out long idleTime, out long kernelTime, out long userTime))
-                    {
-                        return 0;
-                    }
-                    long cpuTotalTime = ((long)userTime - _userTime) + ((long)kernelTime - _kernelTime);
-                    long cpuBusyTime = cpuTotalTime - ((long)idleTime - _idleTime);
-                    _kernelTime = (long)kernelTime;
-                    _userTime = (long)userTime;
-                    _idleTime = (long)idleTime;
-                    if (cpuTotalTime > 0 && cpuBusyTime > 0)
-                    {
-                        long reading = cpuBusyTime * 100 / cpuTotalTime;
-                        reading = Math.Min(reading, 100);
-                        Debug.Assert(0 <= reading);
-                        return (int)reading;
-                    }
-                    return 0;
-                }
-            }
-        }
-    }
-}

--- a/src/libraries/System.Private.CoreLib/src/System/Threading/PortableThreadPool.WorkerThread.cs
+++ b//dev/null
@@ -1,243 +0,0 @@
-using System.Diagnostics.Tracing;
-namespace System.Threading
-{
-    internal sealed partial class PortableThreadPool
-    {
-        private static partial class WorkerThread
-        {
-            private const int SemaphoreSpinCountDefaultBaseline = 70;
-#if !TARGET_ARM64 && !TARGET_ARM && !TARGET_LOONGARCH64
-            private const int SemaphoreSpinCountDefault = SemaphoreSpinCountDefaultBaseline;
-#else
-            private const int SemaphoreSpinCountDefault = SemaphoreSpinCountDefaultBaseline * 4;
-#endif
-            public const int EstimatedAdditionalStackUsagePerThreadBytes = 64 << 10; // 64 KB
-            private static readonly LowLevelLifoSemaphore s_semaphore =
-                new LowLevelLifoSemaphore(
-                    0,
-                    MaxPossibleThreadCount,
-                    AppContextConfigHelper.GetInt32Config(
-                        "System.Threading.ThreadPool.UnfairSemaphoreSpinLimit",
-                        SemaphoreSpinCountDefault,
-                        false),
-                    onWait: () =>
-                    {
-                        if (NativeRuntimeEventSource.Log.IsEnabled())
-                        {
-                            NativeRuntimeEventSource.Log.ThreadPoolWorkerThreadWait(
-                                (uint)ThreadPoolInstance._separated.counts.VolatileRead().NumExistingThreads);
-                        }
-                    });
-            private static readonly ThreadStart s_workerThreadStart = WorkerThreadStart;
-            private static void WorkerThreadStart()
-            {
-                Thread.CurrentThread.SetThreadPoolWorkerThreadName();
-                PortableThreadPool threadPoolInstance = ThreadPoolInstance;
-                if (NativeRuntimeEventSource.Log.IsEnabled())
-                {
-                    NativeRuntimeEventSource.Log.ThreadPoolWorkerThreadStart(
-                        (uint)threadPoolInstance._separated.counts.VolatileRead().NumExistingThreads);
-                }
-                LowLevelLock threadAdjustmentLock = threadPoolInstance._threadAdjustmentLock;
-                LowLevelLifoSemaphore semaphore = s_semaphore;
-                while (true)
-                {
-                    bool spinWait = true;
-                    while (semaphore.Wait(ThreadPoolThreadTimeoutMs, spinWait))
-                    {
-                        bool alreadyRemovedWorkingWorker = false;
-                        while (TakeActiveRequest(threadPoolInstance))
-                        {
-                            threadPoolInstance._separated.lastDequeueTime = Environment.TickCount;
-                            if (!ThreadPoolWorkQueue.Dispatch())
-                            {
-                                alreadyRemovedWorkingWorker = true;
-                                break;
-                            }
-                            if (threadPoolInstance._separated.numRequestedWorkers <= 0)
-                            {
-                                break;
-                            }
-                            Thread.UninterruptibleSleep0();
-                            if (!Environment.IsSingleProcessor)
-                            {
-                                Thread.SpinWait(1);
-                            }
-                        }
-                        spinWait = !alreadyRemovedWorkingWorker;
-                        if (!alreadyRemovedWorkingWorker)
-                        {
-                            RemoveWorkingWorker(threadPoolInstance);
-                        }
-                    }
-                    if (IsIOPending)
-                    {
-                        continue;
-                    }
-                    threadAdjustmentLock.Acquire();
-                    try
-                    {
-                        ThreadCounts counts = threadPoolInstance._separated.counts;
-                        while (true)
-                        {
-                            if (counts.NumExistingThreads <= counts.NumProcessingWork)
-                            {
-                                break;
-                            }
-                            ThreadCounts newCounts = counts;
-                            short newNumExistingThreads = --newCounts.NumExistingThreads;
-                            short newNumThreadsGoal =
-                                Math.Max(
-                                    threadPoolInstance.MinThreadsGoal,
-                                    Math.Min(newNumExistingThreads, counts.NumThreadsGoal));
-                            newCounts.NumThreadsGoal = newNumThreadsGoal;
-                            ThreadCounts oldCounts =
-                                threadPoolInstance._separated.counts.InterlockedCompareExchange(newCounts, counts);
-                            if (oldCounts == counts)
-                            {
-                                HillClimbing.ThreadPoolHillClimber.ForceChange(
-                                    newNumThreadsGoal,
-                                    HillClimbing.StateOrTransition.ThreadTimedOut);
-                                if (NativeRuntimeEventSource.Log.IsEnabled())
-                                {
-                                    NativeRuntimeEventSource.Log.ThreadPoolWorkerThreadStop((uint)newNumExistingThreads);
-                                }
-                                return;
-                            }
-                            counts = oldCounts;
-                        }
-                    }
-                    finally
-                    {
-                        threadAdjustmentLock.Release();
-                    }
-                }
-            }
-            private static void RemoveWorkingWorker(PortableThreadPool threadPoolInstance)
-            {
-                ThreadCounts counts = threadPoolInstance._separated.counts;
-                while (true)
-                {
-                    ThreadCounts newCounts = counts;
-                    newCounts.NumProcessingWork--;
-                    ThreadCounts countsBeforeUpdate =
-                        threadPoolInstance._separated.counts.InterlockedCompareExchange(newCounts, counts);
-                    if (countsBeforeUpdate == counts)
-                    {
-                        break;
-                    }
-                    counts = countsBeforeUpdate;
-                }
-                if (threadPoolInstance._separated.numRequestedWorkers > 0)
-                {
-                    MaybeAddWorkingWorker(threadPoolInstance);
-                }
-            }
-            internal static void MaybeAddWorkingWorker(PortableThreadPool threadPoolInstance)
-            {
-                ThreadCounts counts = threadPoolInstance._separated.counts;
-                short numExistingThreads, numProcessingWork, newNumExistingThreads, newNumProcessingWork;
-                while (true)
-                {
-                    numProcessingWork = counts.NumProcessingWork;
-                    if (numProcessingWork >= counts.NumThreadsGoal)
-                    {
-                        return;
-                    }
-                    newNumProcessingWork = (short)(numProcessingWork + 1);
-                    numExistingThreads = counts.NumExistingThreads;
-                    newNumExistingThreads = Math.Max(numExistingThreads, newNumProcessingWork);
-                    ThreadCounts newCounts = counts;
-                    newCounts.NumProcessingWork = newNumProcessingWork;
-                    newCounts.NumExistingThreads = newNumExistingThreads;
-                    ThreadCounts oldCounts = threadPoolInstance._separated.counts.InterlockedCompareExchange(newCounts, counts);
-                    if (oldCounts == counts)
-                    {
-                        break;
-                    }
-                    counts = oldCounts;
-                }
-                int toCreate = newNumExistingThreads - numExistingThreads;
-                int toRelease = newNumProcessingWork - numProcessingWork;
-                if (toRelease > 0)
-                {
-                    s_semaphore.Release(toRelease);
-                }
-                while (toCreate > 0)
-                {
-                    if (TryCreateWorkerThread())
-                    {
-                        toCreate--;
-                        continue;
-                    }
-                    counts = threadPoolInstance._separated.counts;
-                    while (true)
-                    {
-                        ThreadCounts newCounts = counts;
-                        newCounts.NumProcessingWork -= (short)toCreate;
-                        newCounts.NumExistingThreads -= (short)toCreate;
-                        ThreadCounts oldCounts = threadPoolInstance._separated.counts.InterlockedCompareExchange(newCounts, counts);
-                        if (oldCounts == counts)
-                        {
-                            break;
-                        }
-                        counts = oldCounts;
-                    }
-                    break;
-                }
-            }
-            internal static bool ShouldStopProcessingWorkNow(PortableThreadPool threadPoolInstance)
-            {
-                ThreadCounts counts = threadPoolInstance._separated.counts;
-                while (true)
-                {
-                    if (counts.NumProcessingWork <= counts.NumThreadsGoal)
-                    {
-                        return false;
-                    }
-                    ThreadCounts newCounts = counts;
-                    newCounts.NumProcessingWork--;
-                    ThreadCounts oldCounts = threadPoolInstance._separated.counts.InterlockedCompareExchange(newCounts, counts);
-                    if (oldCounts == counts)
-                    {
-                        return true;
-                    }
-                    counts = oldCounts;
-                }
-            }
-            private static bool TakeActiveRequest(PortableThreadPool threadPoolInstance)
-            {
-                int count = threadPoolInstance._separated.numRequestedWorkers;
-                while (count > 0)
-                {
-                    int prevCount = Interlocked.CompareExchange(ref threadPoolInstance._separated.numRequestedWorkers, count - 1, count);
-                    if (prevCount == count)
-                    {
-                        return true;
-                    }
-                    count = prevCount;
-                }
-                return false;
-            }
-            private static bool TryCreateWorkerThread()
-            {
-                try
-                {
-                    Thread workerThread = new Thread(s_workerThreadStart);
-                    workerThread.IsThreadPoolThread = true;
-                    workerThread.IsBackground = true;
-                    workerThread.UnsafeStart();
-                }
-                catch (ThreadStartException)
-                {
-                    return false;
-                }
-                catch (OutOfMemoryException)
-                {
-                    return false;
-                }
-                return true;
-            }
-        }
-    }
-}

--- a/src/libraries/System.Reflection.DispatchProxy/src/System/Reflection/DispatchProxyGenerator.cs
+++ b//dev/null
@@ -1,589 +0,0 @@
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Diagnostics.CodeAnalysis;
-using System.Linq;
-using System.Reflection.Emit;
-using System.Runtime.CompilerServices;
-using System.Runtime.Loader;
-using System.Threading;
-namespace System.Reflection
-{
-    internal static class DispatchProxyGenerator
-    {
-        private const int MethodInfosFieldAndCtorParameterIndex = 0;
-        private static readonly ConditionalWeakTable<AssemblyLoadContext, ProxyAssembly> s_alcProxyAssemblyMap = new();
-        private static readonly MethodInfo s_dispatchProxyInvokeMethod = typeof(DispatchProxy).GetMethod("Invoke", BindingFlags.NonPublic | BindingFlags.Instance)!;
-        private static readonly MethodInfo s_getTypeFromHandleMethod = typeof(Type).GetMethod("GetTypeFromHandle", new Type[] { typeof(RuntimeTypeHandle) })!;
-        private static readonly MethodInfo s_makeGenericMethodMethod = GetGenericMethodMethodInfo();
-        [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode",
-            Justification = "MakeGenericMethod is safe here because the user code invoking the generic method will reference " +
-            "the GenericTypes being used, which will guarantee the requirements of the generic method.")]
-        private static MethodInfo GetGenericMethodMethodInfo() =>
-            typeof(MethodInfo).GetMethod("MakeGenericMethod", new Type[] { typeof(Type[]) })!;
-        [RequiresDynamicCode("Defining a dynamic assembly requires generating code at runtime")]
-        internal static object CreateProxyInstance(
-            [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] Type baseType,
-            [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type interfaceType)
-        {
-            Debug.Assert(baseType != null);
-            Debug.Assert(interfaceType != null);
-            AssemblyLoadContext? alc = AssemblyLoadContext.GetLoadContext(baseType.Assembly);
-            Debug.Assert(alc != null);
-            ProxyAssembly proxyAssembly = s_alcProxyAssemblyMap.GetValue(alc, static x => new ProxyAssembly(x));
-            GeneratedTypeInfo proxiedType = proxyAssembly.GetProxyType(baseType, interfaceType);
-            return Activator.CreateInstance(proxiedType.GeneratedType, new object[] { proxiedType.MethodInfos })!;
-        }
-        private sealed class GeneratedTypeInfo
-        {
-            public GeneratedTypeInfo(
-                [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type generatedType,
-                MethodInfo[] methodInfos)
-            {
-                GeneratedType = generatedType;
-                MethodInfos = methodInfos;
-            }
-            [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
-            public Type GeneratedType { get; }
-            public MethodInfo[] MethodInfos { get; }
-        }
-        private sealed class ProxyAssembly
-        {
-            private readonly Dictionary<Type, Dictionary<Type, GeneratedTypeInfo>> _baseTypeAndInterfaceToGeneratedProxyType = new Dictionary<Type, Dictionary<Type, GeneratedTypeInfo>>();
-            private readonly AssemblyBuilder _ab;
-            private readonly ModuleBuilder _mb;
-            private int _typeId;
-            private readonly HashSet<string> _ignoresAccessAssemblyNames = new HashSet<string>();
-            private ConstructorInfo? _ignoresAccessChecksToAttributeConstructor;
-            [RequiresDynamicCode("Defining a dynamic assembly requires generating code at runtime")]
-            public ProxyAssembly(AssemblyLoadContext alc)
-            {
-                AssemblyBuilderAccess builderAccess =
-                    alc.IsCollectible ? AssemblyBuilderAccess.RunAndCollect : AssemblyBuilderAccess.Run;
-                _ab = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName("ProxyBuilder"), builderAccess);
-                _mb = _ab.DefineDynamicModule("testmod");
-            }
-            internal ConstructorInfo IgnoresAccessChecksAttributeConstructor =>
-                _ignoresAccessChecksToAttributeConstructor ??= IgnoreAccessChecksToAttributeBuilder.AddToModule(_mb);
-            public GeneratedTypeInfo GetProxyType(
-                [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] Type baseType,
-                [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type interfaceType)
-            {
-                lock (_baseTypeAndInterfaceToGeneratedProxyType)
-                {
-                    if (!_baseTypeAndInterfaceToGeneratedProxyType.TryGetValue(baseType, out Dictionary<Type, GeneratedTypeInfo>? interfaceToProxy))
-                    {
-                        interfaceToProxy = new Dictionary<Type, GeneratedTypeInfo>();
-                        _baseTypeAndInterfaceToGeneratedProxyType[baseType] = interfaceToProxy;
-                    }
-                    if (!interfaceToProxy.TryGetValue(interfaceType, out GeneratedTypeInfo? generatedProxy))
-                    {
-                        generatedProxy = GenerateProxyType(baseType, interfaceType);
-                        interfaceToProxy[interfaceType] = generatedProxy;
-                    }
-                    return generatedProxy;
-                }
-            }
-            [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2062:UnrecognizedReflectionPattern",
-                Justification = "interfaceType is annotated as preserve All members, so any Types returned from GetInterfaces should be preserved as well once https://github.com/mono/linker/issues/1731 is fixed.")]
-            [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2072:UnrecognizedReflectionPattern",
-                Justification = "interfaceType is annotated as preserve All members, so any Types returned from GetInterfaces should be preserved as well once https://github.com/mono/linker/issues/1731 is fixed.")]
-            private GeneratedTypeInfo GenerateProxyType(
-                [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] Type baseType,
-                [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type interfaceType)
-            {
-                if (!interfaceType.IsInterface)
-                {
-                    throw new ArgumentException(SR.Format(SR.InterfaceType_Must_Be_Interface, interfaceType.FullName), "T");
-                }
-                if (baseType.IsSealed)
-                {
-                    throw new ArgumentException(SR.Format(SR.BaseType_Cannot_Be_Sealed, baseType.FullName), "TProxy");
-                }
-                if (baseType.IsAbstract)
-                {
-                    throw new ArgumentException(SR.Format(SR.BaseType_Cannot_Be_Abstract, baseType.FullName), "TProxy");
-                }
-                if (baseType.GetConstructor(Type.EmptyTypes) == null)
-                {
-                    throw new ArgumentException(SR.Format(SR.BaseType_Must_Have_Default_Ctor, baseType.FullName), "TProxy");
-                }
-                ProxyBuilder pb = CreateProxy("generatedProxy", baseType);
-                foreach (Type t in interfaceType.GetInterfaces())
-                    pb.AddInterfaceImpl(t);
-                pb.AddInterfaceImpl(interfaceType);
-                GeneratedTypeInfo generatedProxyType = pb.CreateType();
-                return generatedProxyType;
-            }
-            [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2067:UnrecognizedReflectionPattern",
-                Justification = "Only the parameterless ctor is referenced on proxyBaseType. Other members can be trimmed if unused.")]
-            private ProxyBuilder CreateProxy(
-                string name,
-                [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] Type proxyBaseType)
-            {
-                int nextId = Interlocked.Increment(ref _typeId);
-                TypeBuilder tb = _mb.DefineType(name + "_" + nextId, TypeAttributes.Public, proxyBaseType);
-                return new ProxyBuilder(this, tb, proxyBaseType);
-            }
-            internal void GenerateInstanceOfIgnoresAccessChecksToAttribute(string assemblyName)
-            {
-                ConstructorInfo attributeConstructor = IgnoresAccessChecksAttributeConstructor;
-                CustomAttributeBuilder customAttributeBuilder =
-                    new CustomAttributeBuilder(attributeConstructor, new object[] { assemblyName });
-                _ab.SetCustomAttribute(customAttributeBuilder);
-            }
-            internal void EnsureTypeIsVisible(Type type)
-            {
-                if (!type.IsVisible)
-                {
-                    string assemblyName = type.Assembly.GetName().Name!;
-                    if (_ignoresAccessAssemblyNames.Add(assemblyName))
-                    {
-                        GenerateInstanceOfIgnoresAccessChecksToAttribute(assemblyName);
-                    }
-                }
-            }
-        }
-        private sealed class ProxyBuilder
-        {
-            private readonly ProxyAssembly _assembly;
-            private readonly TypeBuilder _tb;
-            [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)]
-            private readonly Type _proxyBaseType;
-            private readonly List<FieldBuilder> _fields;
-            private readonly List<MethodInfo> _methodInfos;
-            internal ProxyBuilder(
-                ProxyAssembly assembly,
-                TypeBuilder tb,
-                [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] Type proxyBaseType)
-            {
-                _assembly = assembly;
-                _tb = tb;
-                _proxyBaseType = proxyBaseType;
-                _fields = new List<FieldBuilder>();
-                _fields.Add(tb.DefineField("_methodInfos", typeof(MethodInfo[]), FieldAttributes.Private));
-                _methodInfos = new List<MethodInfo>();
-                _assembly.EnsureTypeIsVisible(proxyBaseType);
-            }
-            private void Complete()
-            {
-                Type[] args = new Type[_fields.Count];
-                for (int i = 0; i < args.Length; i++)
-                {
-                    args[i] = _fields[i].FieldType;
-                }
-                ConstructorBuilder cb = _tb.DefineConstructor(MethodAttributes.Public, CallingConventions.HasThis, args);
-                ILGenerator il = cb.GetILGenerator();
-                ConstructorInfo baseCtor = _proxyBaseType.GetConstructor(Type.EmptyTypes)!;
-                Debug.Assert(baseCtor != null);
-                il.Emit(OpCodes.Ldarg_0);
-                il.Emit(OpCodes.Call, baseCtor);
-                for (int i = 0; i < args.Length; i++)
-                {
-                    il.Emit(OpCodes.Ldarg_0);
-                    il.Emit(OpCodes.Ldarg, i + 1);
-                    il.Emit(OpCodes.Stfld, _fields[i]);
-                }
-                il.Emit(OpCodes.Ret);
-            }
-            internal GeneratedTypeInfo CreateType()
-            {
-                this.Complete();
-                return new GeneratedTypeInfo(_tb.CreateType(), _methodInfos.ToArray());
-            }
-            internal void AddInterfaceImpl([DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type iface)
-            {
-                _assembly.EnsureTypeIsVisible(iface);
-                _tb.AddInterfaceImplementation(iface);
-                var propertyMap = new Dictionary<MethodInfo, PropertyAccessorInfo>();
-                foreach (PropertyInfo pi in iface.GetRuntimeProperties())
-                {
-                    var ai = new PropertyAccessorInfo(pi.GetMethod, pi.SetMethod);
-                    if (pi.GetMethod != null)
-                        propertyMap[pi.GetMethod] = ai;
-                    if (pi.SetMethod != null)
-                        propertyMap[pi.SetMethod] = ai;
-                }
-                var eventMap = new Dictionary<MethodInfo, EventAccessorInfo>();
-                foreach (EventInfo ei in iface.GetRuntimeEvents())
-                {
-                    var ai = new EventAccessorInfo(ei.AddMethod, ei.RemoveMethod, ei.RaiseMethod);
-                    if (ei.AddMethod != null)
-                        eventMap[ei.AddMethod] = ai;
-                    if (ei.RemoveMethod != null)
-                        eventMap[ei.RemoveMethod] = ai;
-                    if (ei.RaiseMethod != null)
-                        eventMap[ei.RaiseMethod] = ai;
-                }
-                foreach (MethodInfo mi in iface.GetRuntimeMethods())
-                {
-                    if (!mi.IsVirtual || mi.IsFinal)
-                        continue;
-                    int methodInfoIndex = _methodInfos.Count;
-                    _methodInfos.Add(mi);
-                    MethodBuilder mdb = AddMethodImpl(mi, methodInfoIndex);
-                    if (propertyMap.TryGetValue(mi, out PropertyAccessorInfo? associatedProperty))
-                    {
-                        if (mi.Equals(associatedProperty.InterfaceGetMethod))
-                            associatedProperty.GetMethodBuilder = mdb;
-                        else
-                            associatedProperty.SetMethodBuilder = mdb;
-                    }
-                    if (eventMap.TryGetValue(mi, out EventAccessorInfo? associatedEvent))
-                    {
-                        if (mi.Equals(associatedEvent.InterfaceAddMethod))
-                            associatedEvent.AddMethodBuilder = mdb;
-                        else if (mi.Equals(associatedEvent.InterfaceRemoveMethod))
-                            associatedEvent.RemoveMethodBuilder = mdb;
-                        else
-                            associatedEvent.RaiseMethodBuilder = mdb;
-                    }
-                }
-                foreach (PropertyInfo pi in iface.GetRuntimeProperties())
-                {
-                    PropertyAccessorInfo ai = propertyMap[pi.GetMethod ?? pi.SetMethod!];
-                    if (ai.GetMethodBuilder == null && ai.SetMethodBuilder == null)
-                        continue;
-                    PropertyBuilder pb = _tb.DefineProperty(pi.Name, pi.Attributes, pi.PropertyType, pi.GetIndexParameters().Select(p => p.ParameterType).ToArray());
-                    if (ai.GetMethodBuilder != null)
-                        pb.SetGetMethod(ai.GetMethodBuilder);
-                    if (ai.SetMethodBuilder != null)
-                        pb.SetSetMethod(ai.SetMethodBuilder);
-                }
-                foreach (EventInfo ei in iface.GetRuntimeEvents())
-                {
-                    EventAccessorInfo ai = eventMap[ei.AddMethod ?? ei.RemoveMethod!];
-                    if (ai.AddMethodBuilder == null && ai.RemoveMethodBuilder == null && ai.RaiseMethodBuilder == null)
-                        continue;
-                    Debug.Assert(ei.EventHandlerType != null);
-                    EventBuilder eb = _tb.DefineEvent(ei.Name, ei.Attributes, ei.EventHandlerType!);
-                    if (ai.AddMethodBuilder != null)
-                        eb.SetAddOnMethod(ai.AddMethodBuilder);
-                    if (ai.RemoveMethodBuilder != null)
-                        eb.SetRemoveOnMethod(ai.RemoveMethodBuilder);
-                    if (ai.RaiseMethodBuilder != null)
-                        eb.SetRaiseMethod(ai.RaiseMethodBuilder);
-                }
-            }
-            private MethodBuilder AddMethodImpl(MethodInfo mi, int methodInfoIndex)
-            {
-                ParameterInfo[] parameters = mi.GetParameters();
-                Type[] paramTypes = new Type[parameters.Length];
-                Type[][] paramReqMods = new Type[paramTypes.Length][];
-                for (int i = 0; i < parameters.Length; i++)
-                {
-                    paramTypes[i] = parameters[i].ParameterType;
-                    paramReqMods[i] = parameters[i].GetRequiredCustomModifiers();
-                }
-                MethodBuilder mdb = _tb.DefineMethod(mi.Name, MethodAttributes.Public | MethodAttributes.Virtual, CallingConventions.Standard,
-                    mi.ReturnType, null, null,
-                    paramTypes, paramReqMods, null);
-                if (mi.ContainsGenericParameters)
-                {
-                    Type[] ts = mi.GetGenericArguments();
-                    string[] ss = new string[ts.Length];
-                    for (int i = 0; i < ts.Length; i++)
-                    {
-                        ss[i] = ts[i].Name;
-                    }
-                    GenericTypeParameterBuilder[] genericParameters = mdb.DefineGenericParameters(ss);
-                    for (int i = 0; i < genericParameters.Length; i++)
-                    {
-                        genericParameters[i].SetGenericParameterAttributes(ts[i].GenericParameterAttributes);
-                    }
-                }
-                ILGenerator il = mdb.GetILGenerator();
-                ParametersArray args = new ParametersArray(il, paramTypes);
-                il.Emit(OpCodes.Nop);
-                GenericArray<object> argsArr = new GenericArray<object>(il, parameters.Length);
-                for (int i = 0; i < parameters.Length; i++)
-                {
-                    bool isOutRef = parameters[i].IsOut && parameters[i].ParameterType.IsByRef && !parameters[i].IsIn;
-                    if (!isOutRef)
-                    {
-                        argsArr.BeginSet(i);
-                        args.Get(i);
-                        argsArr.EndSet(parameters[i].ParameterType);
-                    }
-                }
-                LocalBuilder methodInfoLocal = il.DeclareLocal(typeof(MethodInfo));
-                il.Emit(OpCodes.Ldarg_0);
-                il.Emit(OpCodes.Ldfld, _fields[MethodInfosFieldAndCtorParameterIndex]); // MethodInfo[] _methodInfos
-                il.Emit(OpCodes.Ldc_I4, methodInfoIndex);
-                il.Emit(OpCodes.Ldelem_Ref);
-                il.Emit(OpCodes.Stloc, methodInfoLocal);
-                if (mi.ContainsGenericParameters)
-                {
-                    il.Emit(OpCodes.Ldloc, methodInfoLocal);
-                    Type[] genericTypes = mi.GetGenericArguments();
-                    GenericArray<Type> typeArr = new GenericArray<Type>(il, genericTypes.Length);
-                    for (int i = 0; i < genericTypes.Length; ++i)
-                    {
-                        typeArr.BeginSet(i);
-                        il.Emit(OpCodes.Ldtoken, genericTypes[i]);
-                        il.Emit(OpCodes.Call, s_getTypeFromHandleMethod);
-                        typeArr.EndSet(typeof(Type));
-                    }
-                    typeArr.Load();
-                    il.Emit(OpCodes.Callvirt, s_makeGenericMethodMethod);
-                    il.Emit(OpCodes.Stloc, methodInfoLocal);
-                }
-                LocalBuilder? resultLocal = mi.ReturnType != typeof(void) ?
-                    il.DeclareLocal(typeof(object)) :
-                    null;
-                il.Emit(OpCodes.Ldarg_0);
-                il.Emit(OpCodes.Ldloc, methodInfoLocal);
-                argsArr.Load();
-                il.Emit(OpCodes.Callvirt, s_dispatchProxyInvokeMethod);
-                if (resultLocal != null)
-                {
-                    il.Emit(OpCodes.Stloc, resultLocal);
-                }
-                else
-                {
-                    il.Emit(OpCodes.Pop);
-                }
-                for (int i = 0; i < parameters.Length; i++)
-                {
-                    if (parameters[i].ParameterType.IsByRef)
-                    {
-                        args.BeginSet(i);
-                        argsArr.Get(i);
-                        args.EndSet(i, typeof(object));
-                    }
-                }
-                if (resultLocal != null)
-                {
-                    il.Emit(OpCodes.Ldloc, resultLocal);
-                    Convert(il, typeof(object), mi.ReturnType, false);
-                }
-                il.Emit(OpCodes.Ret);
-                _tb.DefineMethodOverride(mdb, mi);
-                return mdb;
-            }
-            private static int GetTypeCode(Type type) => (int)Type.GetTypeCode(type);
-            private static readonly OpCode[] s_convOpCodes = new OpCode[] {
-                OpCodes.Nop, //Empty = 0,
-                OpCodes.Nop, //Object = 1,
-                OpCodes.Nop, //DBNull = 2,
-                OpCodes.Conv_I1, //Boolean = 3,
-                OpCodes.Conv_I2, //Char = 4,
-                OpCodes.Conv_I1, //SByte = 5,
-                OpCodes.Conv_U1, //Byte = 6,
-                OpCodes.Conv_I2, //Int16 = 7,
-                OpCodes.Conv_U2, //UInt16 = 8,
-                OpCodes.Conv_I4, //Int32 = 9,
-                OpCodes.Conv_U4, //UInt32 = 10,
-                OpCodes.Conv_I8, //Int64 = 11,
-                OpCodes.Conv_U8, //UInt64 = 12,
-                OpCodes.Conv_R4, //Single = 13,
-                OpCodes.Conv_R8, //Double = 14,
-                OpCodes.Nop, //Decimal = 15,
-                OpCodes.Nop, //DateTime = 16,
-                OpCodes.Nop, //17
-                OpCodes.Nop, //String = 18,
-            };
-            private static readonly OpCode[] s_ldindOpCodes = new OpCode[] {
-                OpCodes.Nop, //Empty = 0,
-                OpCodes.Nop, //Object = 1,
-                OpCodes.Nop, //DBNull = 2,
-                OpCodes.Ldind_I1, //Boolean = 3,
-                OpCodes.Ldind_I2, //Char = 4,
-                OpCodes.Ldind_I1, //SByte = 5,
-                OpCodes.Ldind_U1, //Byte = 6,
-                OpCodes.Ldind_I2, //Int16 = 7,
-                OpCodes.Ldind_U2, //UInt16 = 8,
-                OpCodes.Ldind_I4, //Int32 = 9,
-                OpCodes.Ldind_U4, //UInt32 = 10,
-                OpCodes.Ldind_I8, //Int64 = 11,
-                OpCodes.Ldind_I8, //UInt64 = 12,
-                OpCodes.Ldind_R4, //Single = 13,
-                OpCodes.Ldind_R8, //Double = 14,
-                OpCodes.Nop, //Decimal = 15,
-                OpCodes.Nop, //DateTime = 16,
-                OpCodes.Nop, //17
-                OpCodes.Ldind_Ref, //String = 18,
-            };
-            private static readonly OpCode[] s_stindOpCodes = new OpCode[] {
-                OpCodes.Nop, //Empty = 0,
-                OpCodes.Nop, //Object = 1,
-                OpCodes.Nop, //DBNull = 2,
-                OpCodes.Stind_I1, //Boolean = 3,
-                OpCodes.Stind_I2, //Char = 4,
-                OpCodes.Stind_I1, //SByte = 5,
-                OpCodes.Stind_I1, //Byte = 6,
-                OpCodes.Stind_I2, //Int16 = 7,
-                OpCodes.Stind_I2, //UInt16 = 8,
-                OpCodes.Stind_I4, //Int32 = 9,
-                OpCodes.Stind_I4, //UInt32 = 10,
-                OpCodes.Stind_I8, //Int64 = 11,
-                OpCodes.Stind_I8, //UInt64 = 12,
-                OpCodes.Stind_R4, //Single = 13,
-                OpCodes.Stind_R8, //Double = 14,
-                OpCodes.Nop, //Decimal = 15,
-                OpCodes.Nop, //DateTime = 16,
-                OpCodes.Nop, //17
-                OpCodes.Stind_Ref, //String = 18,
-            };
-            private static void Convert(ILGenerator il, Type source, Type target, bool isAddress)
-            {
-                Debug.Assert(!target.IsByRef);
-                if (target == source)
-                    return;
-                if (source.IsByRef)
-                {
-                    Debug.Assert(!isAddress);
-                    Type argType = source.GetElementType()!;
-                    Ldind(il, argType);
-                    Convert(il, argType, target, isAddress);
-                    return;
-                }
-                if (target.IsValueType)
-                {
-                    if (source.IsValueType)
-                    {
-                        OpCode opCode = s_convOpCodes[GetTypeCode(target)];
-                        Debug.Assert(!opCode.Equals(OpCodes.Nop));
-                        il.Emit(opCode);
-                    }
-                    else
-                    {
-                        Debug.Assert(source.IsAssignableFrom(target));
-                        il.Emit(OpCodes.Unbox, target);
-                        if (!isAddress)
-                            Ldind(il, target);
-                    }
-                }
-                else if (target.IsAssignableFrom(source))
-                {
-                    if (source.IsValueType || source.IsGenericParameter)
-                    {
-                        if (isAddress)
-                            Ldind(il, source);
-                        il.Emit(OpCodes.Box, source);
-                    }
-                }
-                else
-                {
-                    Debug.Assert(source.IsAssignableFrom(target) || target.IsInterface || source.IsInterface);
-                    if (target.IsGenericParameter)
-                    {
-                        il.Emit(OpCodes.Unbox_Any, target);
-                    }
-                    else
-                    {
-                        il.Emit(OpCodes.Castclass, target);
-                    }
-                }
-            }
-            private static void Ldind(ILGenerator il, Type type)
-            {
-                OpCode opCode = s_ldindOpCodes[GetTypeCode(type)];
-                if (!opCode.Equals(OpCodes.Nop))
-                {
-                    il.Emit(opCode);
-                }
-                else
-                {
-                    il.Emit(OpCodes.Ldobj, type);
-                }
-            }
-            private static void Stind(ILGenerator il, Type type)
-            {
-                OpCode opCode = s_stindOpCodes[GetTypeCode(type)];
-                if (!opCode.Equals(OpCodes.Nop))
-                {
-                    il.Emit(opCode);
-                }
-                else
-                {
-                    il.Emit(OpCodes.Stobj, type);
-                }
-            }
-            private sealed class ParametersArray
-            {
-                private readonly ILGenerator _il;
-                private readonly Type[] _paramTypes;
-                internal ParametersArray(ILGenerator il, Type[] paramTypes)
-                {
-                    _il = il;
-                    _paramTypes = paramTypes;
-                }
-                internal void Get(int i)
-                {
-                    _il.Emit(OpCodes.Ldarg, i + 1);
-                }
-                internal void BeginSet(int i)
-                {
-                    _il.Emit(OpCodes.Ldarg, i + 1);
-                }
-                internal void EndSet(int i, Type stackType)
-                {
-                    Debug.Assert(_paramTypes[i].IsByRef);
-                    Type argType = _paramTypes[i].GetElementType()!;
-                    Convert(_il, stackType, argType, false);
-                    Stind(_il, argType);
-                }
-            }
-            private sealed class GenericArray<T>
-            {
-                private readonly ILGenerator _il;
-                private readonly LocalBuilder _lb;
-                internal GenericArray(ILGenerator il, int len)
-                {
-                    _il = il;
-                    _lb = il.DeclareLocal(typeof(T[]));
-                    il.Emit(OpCodes.Ldc_I4, len);
-                    il.Emit(OpCodes.Newarr, typeof(T));
-                    il.Emit(OpCodes.Stloc, _lb);
-                }
-                internal void Load()
-                {
-                    _il.Emit(OpCodes.Ldloc, _lb);
-                }
-                internal void Get(int i)
-                {
-                    _il.Emit(OpCodes.Ldloc, _lb);
-                    _il.Emit(OpCodes.Ldc_I4, i);
-                    _il.Emit(OpCodes.Ldelem_Ref);
-                }
-                internal void BeginSet(int i)
-                {
-                    _il.Emit(OpCodes.Ldloc, _lb);
-                    _il.Emit(OpCodes.Ldc_I4, i);
-                }
-                internal void EndSet(Type stackType)
-                {
-                    Convert(_il, stackType, typeof(T), false);
-                    _il.Emit(OpCodes.Stelem_Ref);
-                }
-            }
-            private sealed class PropertyAccessorInfo
-            {
-                public MethodInfo? InterfaceGetMethod { get; }
-                public MethodInfo? InterfaceSetMethod { get; }
-                public MethodBuilder? GetMethodBuilder { get; set; }
-                public MethodBuilder? SetMethodBuilder { get; set; }
-                public PropertyAccessorInfo(MethodInfo? interfaceGetMethod, MethodInfo? interfaceSetMethod)
-                {
-                    InterfaceGetMethod = interfaceGetMethod;
-                    InterfaceSetMethod = interfaceSetMethod;
-                }
-            }
-            private sealed class EventAccessorInfo
-            {
-                public MethodInfo? InterfaceAddMethod { get; }
-                public MethodInfo? InterfaceRemoveMethod { get; }
-                public MethodInfo? InterfaceRaiseMethod { get; }
-                public MethodBuilder? AddMethodBuilder { get; set; }
-                public MethodBuilder? RemoveMethodBuilder { get; set; }
-                public MethodBuilder? RaiseMethodBuilder { get; set; }
-                public EventAccessorInfo(MethodInfo? interfaceAddMethod, MethodInfo? interfaceRemoveMethod, MethodInfo? interfaceRaiseMethod)
-                {
-                    InterfaceAddMethod = interfaceAddMethod;
-                    InterfaceRemoveMethod = interfaceRemoveMethod;
-                    InterfaceRaiseMethod = interfaceRaiseMethod;
-                }
-            }
-        }
-    }
-}

--- a/src/libraries/shims/src/mscorlib.forwards.cs
+++ b//dev/null
@@ -1,105 +0,0 @@
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.GenericComparer<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.NullableComparer<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.ObjectComparer<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.GenericEqualityComparer<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.NullableEqualityComparer<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.ObjectEqualityComparer<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.NonRandomizedStringEqualityComparer))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.ByteEqualityComparer))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.EnumEqualityComparer<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.ListDictionaryInternal))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.CultureAwareComparer))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.OrdinalComparer))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.UnitySerializationHolder))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.Contracts.ContractException))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.HashCode))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.IAsyncDisposable))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Index))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.MathF))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.MemoryExtensions))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Memory<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Range))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.ReadOnlyMemory<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.ReadOnlySpan<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.SequencePosition))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Span<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.ArrayBufferWriter<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.ArrayPool<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.BuffersExtensions))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.IBufferWriter<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.IMemoryOwner<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.IPinnable))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.MemoryHandle))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.MemoryManager<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.MemoryPool<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.OperationStatus))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.ReadOnlySequenceSegment<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.ReadOnlySequence<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.ReadOnlySpanAction<,>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.SequenceReaderExtensions))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.SequenceReader<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.SpanAction<,>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.StandardFormat))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.Binary.BinaryPrimitives))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.Text.Base64))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.Text.Utf8Formatter))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.Text.Utf8Parser))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.CollectionExtensions))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.IAsyncEnumerable<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.IAsyncEnumerator<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.KeyValuePair))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.Queue<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.Stack<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.CodeAnalysis.AllowNullAttribute))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.CodeAnalysis.DisallowNullAttribute))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.CodeAnalysis.MaybeNullAttribute))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.CodeAnalysis.NotNullAttribute))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.CodeAnalysis.NotNullWhenAttribute))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.Tracing.DiagnosticCounter))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.Tracing.EventCounter))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.Tracing.IncrementingEventCounter))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.Tracing.IncrementingPollingCounter))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.Tracing.PollingCounter))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Globalization.ISOWeek))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.IO.EnumerationOptions))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.IO.MatchCasing))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.IO.MatchType))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.IO.Enumeration.FileSystemEntry))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.IO.Enumeration.FileSystemEnumerable<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.IO.Enumeration.FileSystemEnumerator<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.IO.Enumeration.FileSystemName))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Numerics.Vector))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Numerics.Vector<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Reflection.AssemblyExtensions))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Reflection.EventInfoExtensions))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Reflection.MemberInfoExtensions))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Reflection.MethodInfoExtensions))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Reflection.ModuleExtensions))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Reflection.PropertyInfoExtensions))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Reflection.TypeExtensions))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.AsyncIteratorMethodBuilder))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.AsyncIteratorStateMachineAttribute))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.AsyncMethodBuilderAttribute))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.ConfiguredAsyncDisposable))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.EnumeratorCancellationAttribute))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.ValueTaskAwaiter))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.ValueTaskAwaiter<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.InteropServices.MemoryMarshal))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.InteropServices.SequenceMarshal))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Threading.Tasks.TaskAsyncEnumerableExtensions))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Threading.Tasks.ValueTask))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Threading.Tasks.ValueTask<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Threading.Tasks.Sources.IValueTaskSource))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Threading.Tasks.Sources.IValueTaskSource<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore<>))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags))]
-[assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Threading.Tasks.Sources.ValueTaskSourceStatus))]

--- a/src/mono/mono/eventpipe/ep-rt-mono.c
+++ b//dev/null
@@ -1,6297 +0,0 @@
-#include <config.h>
-#ifdef ENABLE_PERFTRACING
-#include <eventpipe/ep-rt-config.h>
-#include <eventpipe/ep-types.h>
-#include <eventpipe/ep-rt.h>
-#include <eventpipe/ep.h>
-#include <eventpipe/ep-event.h>
-#include <eglib/gmodule.h>
-#include <mono/utils/mono-lazy-init.h>
-#include <mono/utils/mono-time.h>
-#include <mono/utils/mono-proclib.h>
-#include <mono/utils/mono-threads.h>
-#include <mono/utils/mono-rand.h>
-#include <mono/metadata/profiler.h>
-#include <mono/metadata/appdomain.h>
-#include <mono/metadata/assembly.h>
-#include <mono/metadata/assembly-internals.h>
-#include <mono/metadata/class-internals.h>
-#include <mono/metadata/debug-internals.h>
-#include <mono/metadata/gc-internals.h>
-#include <mono/metadata/profiler-private.h>
-#include <mono/metadata/cil-coff.h>
-#include <mono/metadata/mono-endian.h>
-#include <mono/mini/mini-runtime.h>
-#include <mono/sgen/sgen-conf.h>
-#include <mono/sgen/sgen-tagged-pointer.h>
-#include <mono/utils/mono-logger-internals.h>
-#include <minipal/getexepath.h>
-#include <runtime_version.h>
-#include <clretwallmain.h>
-extern void InitProvidersAndEvents (void);
-gboolean _ep_rt_mono_initialized;
-MonoNativeTlsKey _ep_rt_mono_thread_holder_tls_id;
-MonoNativeTlsKey _ep_rt_mono_thread_data_tls_id;
-gpointer _ep_rt_mono_rand_provider;
-ep_rt_spin_lock_handle_t _ep_rt_mono_config_lock = {0};
-mono_lazy_init_t _ep_rt_mono_os_cmd_line_init = MONO_LAZY_INIT_STATUS_NOT_INITIALIZED;
-char *_ep_rt_mono_os_cmd_line = NULL;
-mono_lazy_init_t _ep_rt_mono_managed_cmd_line_init = MONO_LAZY_INIT_STATUS_NOT_INITIALIZED;
-char *_ep_rt_mono_managed_cmd_line = NULL;
-typedef struct _EventPipeThreadData EventPipeThreadData;
-struct _EventPipeThreadData {
-	bool prevent_profiler_event_recursion;
-};
-static GArray * _ep_rt_mono_sampled_thread_callstacks = NULL;
-static uint32_t _ep_rt_mono_max_sampled_thread_count = 32;
-static MonoProfilerHandle _ep_rt_default_profiler = NULL;
-static MonoProfilerHandle _ep_rt_dotnet_runtime_profiler_provider = NULL;
-static MonoProfilerHandle _ep_rt_dotnet_mono_profiler_provider = NULL;
-static MonoProfilerHandle _ep_rt_dotnet_mono_profiler_heap_collect_provider = NULL;
-static MonoCallSpec _ep_rt_dotnet_mono_profiler_provider_callspec = {0};
-MonoMethod *_ep_rt_mono_runtime_helper_compile_method = NULL;
-MonoJitInfo *_ep_rt_mono_runtime_helper_compile_method_jitinfo = NULL;
-MonoMethod *_ep_rt_mono_monitor_enter_method = NULL;
-MonoJitInfo *_ep_rt_mono_monitor_enter_method_jitinfo = NULL;
-MonoMethod *_ep_rt_mono_monitor_enter_v4_method = NULL;
-MonoJitInfo *_ep_rt_mono_monitor_enter_v4_method_jitinfo = NULL;
-typedef
-bool
-(*ep_rt_mono_fire_method_rundown_events_func)(
-	const uint64_t method_id,
-	const uint64_t module_id,
-	const uint64_t method_start_address,
-	const uint32_t method_size,
-	const uint32_t method_token,
-	const uint32_t method_flags,
-	const ep_char8_t *method_namespace,
-	const ep_char8_t *method_name,
-	const ep_char8_t *method_signature,
-	const uint16_t count_of_map_entries,
-	const uint32_t *il_offsets,
-	const uint32_t *native_offsets,
-	bool aot_method,
-	bool verbose,
-	void *user_data);
-typedef
-bool
-(*ep_rt_mono_fire_assembly_rundown_events_func)(
-	const uint64_t domain_id,
-	const uint64_t assembly_id,
-	const uint32_t assembly_flags,
-	const uint32_t binding_id,
-	const ep_char8_t *assembly_name,
-	const uint64_t module_id,
-	const uint32_t module_flags,
-	const uint32_t reserved_flags,
-	const ep_char8_t *module_il_path,
-	const ep_char8_t *module_native_path,
-	const uint8_t *managed_pdb_signature,
-	const uint32_t managed_pdb_age,
-	const ep_char8_t *managed_pdb_build_path,
-	const uint8_t *native_pdb_signature,
-	const uint32_t native_pdb_age,
-	const ep_char8_t *native_pdb_build_path,
-	void *user_data);
-typedef
-bool
-(*ep_rt_mono_fire_domain_rundown_events_func)(
-	const uint64_t domain_id,
-	const uint32_t domain_flags,
-	const ep_char8_t *domain_name,
-	const uint32_t domain_index,
-	void *user_data);
-typedef struct _EventPipeFireMethodEventsData {
-	MonoDomain *domain;
-	uint8_t *buffer;
-	size_t buffer_size;
-	ep_rt_mono_fire_method_rundown_events_func method_events_func;
-} EventPipeFireMethodEventsData;
-typedef struct _EventPipeStackWalkData {
-	EventPipeStackContents *stack_contents;
-	bool top_frame;
-	bool async_frame;
-	bool safe_point_frame;
-	bool runtime_invoke_frame;
-} EventPipeStackWalkData;
-typedef struct _EventPipeSampleProfileStackWalkData {
-	EventPipeStackWalkData stack_walk_data;
-	EventPipeStackContents stack_contents;
-	uint64_t thread_id;
-	uintptr_t thread_ip;
-	uint32_t payload_data;
-} EventPipeSampleProfileStackWalkData;
-#define RUNTIME_SKU_MONO 0x4
-#define METHOD_FLAGS_DYNAMIC_METHOD 0x1
-#define METHOD_FLAGS_GENERIC_METHOD 0x2
-#define METHOD_FLAGS_SHARED_GENERIC_METHOD 0x4
-#define METHOD_FLAGS_JITTED_METHOD 0x8
-#define METHOD_FLAGS_JITTED_HELPER_METHOD 0x10
-#define METHOD_FLAGS_EXTENT_HOT_SECTION 0x00000000
-#define METHOD_FLAGS_EXTENT_COLD_SECTION 0x10000000
-#define MODULE_FLAGS_NATIVE_MODULE 0x2
-#define MODULE_FLAGS_DYNAMIC_MODULE 0x4
-#define MODULE_FLAGS_MANIFEST_MODULE 0x8
-#define ASSEMBLY_FLAGS_DYNAMIC_ASSEMBLY 0x2
-#define ASSEMBLY_FLAGS_NATIVE_ASSEMBLY 0x4
-#define ASSEMBLY_FLAGS_COLLECTIBLE_ASSEMBLY 0x8
-#define DOMAIN_FLAGS_DEFAULT_DOMAIN 0x1
-#define DOMAIN_FLAGS_EXECUTABLE_DOMAIN 0x2
-struct _ModuleEventData {
-	uint8_t module_il_pdb_signature [EP_GUID_SIZE];
-	uint8_t module_native_pdb_signature [EP_GUID_SIZE];
-	uint64_t domain_id;
-	uint64_t module_id;
-	uint64_t assembly_id;
-	const char *module_il_path;
-	const char *module_il_pdb_path;
-	const char *module_native_path;
-	const char *module_native_pdb_path;
-	uint32_t module_il_pdb_age;
-	uint32_t module_native_pdb_age;
-	uint32_t reserved_flags;
-	uint32_t module_flags;
-};
-typedef struct _ModuleEventData ModuleEventData;
-struct _AssemblyEventData {
-	uint64_t domain_id;
-	uint64_t assembly_id;
-	uint64_t binding_id;
-	char *assembly_name;
-	uint32_t assembly_flags;
-};
-typedef struct _AssemblyEventData AssemblyEventData;
-#define THREAD_FLAGS_GC_SPECIAL 0x00000001
-#define THREAD_FLAGS_FINALIZER 0x00000002
-#define THREAD_FLAGS_THREADPOOL_WORKER 0x00000004
-#define EXCEPTION_THROWN_FLAGS_HAS_INNER 0x1
-#define EXCEPTION_THROWN_FLAGS_IS_NESTED 0x2
-#define EXCEPTION_THROWN_FLAGS_IS_RETHROWN 0x4
-#define EXCEPTION_THROWN_FLAGS_IS_CSE 0x8
-#define EXCEPTION_THROWN_FLAGS_IS_CLS_COMPLIANT 0x10
-#define GC_KEYWORD 0x1
-#define GC_HANDLE_KEYWORD 0x2
-#define LOADER_KEYWORD 0x8
-#define JIT_KEYWORD 0x10
-#define APP_DOMAIN_RESOURCE_MANAGEMENT_KEYWORD 0x800
-#define CONTENTION_KEYWORD 0x4000
-#define EXCEPTION_KEYWORD 0x8000
-#define THREADING_KEYWORD 0x10000
-#define GC_HEAP_DUMP_KEYWORD 0x100000
-#define GC_ALLOCATION_KEYWORD 0x200000
-#define GC_MOVES_KEYWORD 0x400000
-#define GC_HEAP_COLLECT_KEYWORD 0x800000
-#define GC_FINALIZATION_KEYWORD 0x1000000
-#define GC_RESIZE_KEYWORD 0x2000000
-#define GC_ROOT_KEYWORD 0x4000000
-#define GC_HEAP_DUMP_VTABLE_CLASS_REF_KEYWORD 0x8000000
-#define METHOD_TRACING_KEYWORD 0x20000000
-#define TYPE_DIAGNOSTIC_KEYWORD 0x8000000000
-#define TYPE_LOADING_KEYWORD 0x8000000000
-#define MONITOR_KEYWORD 0x10000000000
-#define METHOD_INSTRUMENTATION_KEYWORD 0x40000000000
-typedef enum {
-	MONO_PROFILER_BUFFERED_GC_EVENT = 1,
-	MONO_PROFILER_BUFFERED_GC_EVENT_RESIZE = 2,
-	MONO_PROFILER_BUFFERED_GC_EVENT_ROOTS = 3,
-	MONO_PROFILER_BUFFERED_GC_EVENT_MOVES = 4,
-	MONO_PROFILER_BUFFERED_GC_EVENT_OBJECT_REF = 5,
-	MONO_PROFILER_BUFFERED_GC_EVENT_ROOT_REGISTER = 6,
-	MONO_PROFILER_BUFFERED_GC_EVENT_ROOT_UNREGISTER = 7
-} MonoProfilerBufferedGCEventType;
-typedef struct _MonoProfilerBufferedGCEvent MonoProfilerBufferedGCEvent;
-struct _MonoProfilerBufferedGCEvent {
-	MonoProfilerBufferedGCEventType type;
-	uint32_t payload_size;
-};
-#define MONO_PROFILER_MEM_DEFAULT_BLOCK_SIZE (mono_pagesize() * 16)
-#define MONO_PROFILER_MEM_BLOCK_SIZE_INC (mono_pagesize())
-typedef struct _MonoProfilerMemBlock MonoProfilerMemBlock;
-struct _MonoProfilerMemBlock {
-	MonoProfilerMemBlock *next;
-	MonoProfilerMemBlock *prev;
-	uint8_t *start;
-	uint32_t alloc_size;
-	uint32_t size;
-	uint32_t offset;
-	uint32_t last_used_offset;
-};
-static volatile MonoProfilerMemBlock *_ep_rt_mono_profiler_mem_blocks = NULL;
-static volatile MonoProfilerMemBlock *_ep_rt_mono_profiler_current_mem_block = NULL;
-static volatile uint32_t _ep_rt_mono_profiler_gc_heap_collect_requests = 0;
-static volatile uint32_t _ep_rt_mono_profiler_gc_heap_collect_in_progress = 0;
-static bool _ep_rt_mono_profiler_gc_can_collect_heap = false;
-static GSList *_ep_rt_mono_profiler_provider_params = NULL;
-static GQueue *_ep_rt_mono_profiler_gc_heap_collect_request_params = NULL;
-typedef uint32_t mono_profiler_gc_state_t;
-typedef uint16_t mono_profiler_gc_state_count_t;
-#define MONO_PROFILER_GC_STATE_GET_FIRE_EVENT_COUNT(x) ((mono_profiler_gc_state_count_t)((x & 0xFFFF)))
-#define MONO_PROFILER_GC_STATE_INC_FIRE_EVENT_COUNT(x) ((mono_profiler_gc_state_t)((mono_profiler_gc_state_t)(x & 0xFFFF0000) | (mono_profiler_gc_state_t)(MONO_PROFILER_GC_STATE_GET_FIRE_EVENT_COUNT(x) + 1)))
-#define MONO_PROFILER_GC_STATE_DEC_FIRE_EVENT_COUNT(x) ((mono_profiler_gc_state_t)((mono_profiler_gc_state_t)(x & 0xFFFF0000) | (mono_profiler_gc_state_t)(MONO_PROFILER_GC_STATE_GET_FIRE_EVENT_COUNT(x) - 1)))
-#define MONO_PROFILER_GC_STATE_GC_IN_PROGRESS_START(x) ((mono_profiler_gc_state_t)((mono_profiler_gc_state_t)(0xFFFF << 16) | (mono_profiler_gc_state_t)MONO_PROFILER_GC_STATE_GET_FIRE_EVENT_COUNT(x)))
-#define MONO_PROFILER_GC_STATE_IS_GC_IN_PROGRESS(x) (((x >> 16) & 0xFFFF) == 0xFFFF)
-#define MONO_PROFILER_GC_STATE_GC_IN_PROGRESS_STOP(x) ((mono_profiler_gc_state_t)((mono_profiler_gc_state_t)MONO_PROFILER_GC_STATE_GET_FIRE_EVENT_COUNT(x)))
-static volatile mono_profiler_gc_state_t _ep_rt_mono_profiler_gc_state = 0;
-static ep_rt_spin_lock_handle_t _ep_rt_mono_profiler_gc_state_lock = {0};
-/*
- * Forward declares of all static functions.
- */
-static
-EventPipeThreadData *
-eventpipe_thread_data_get_or_create (void);
-static
-void
-eventpipe_thread_data_free (EventPipeThreadData *thread_data);
-static
-bool
-fire_method_rundown_events_func (
-	const uint64_t method_id,
-	const uint64_t module_id,
-	const uint64_t method_start_address,
-	const uint32_t method_size,
-	const uint32_t method_token,
-	const uint32_t method_flags,
-	const ep_char8_t *method_namespace,
-	const ep_char8_t *method_name,
-	const ep_char8_t *method_signature,
-	const uint16_t count_of_map_entries,
-	const uint32_t *il_offsets,
-	const uint32_t *native_offsets,
-	bool aot_method,
-	bool verbose,
-	void *user_data);
-static
-bool
-fire_assembly_rundown_events_func (
-	const uint64_t domain_id,
-	const uint64_t assembly_id,
-	const uint32_t assembly_flags,
-	const uint32_t binding_id,
-	const ep_char8_t *assembly_name,
-	const uint64_t module_id,
-	const uint32_t module_flags,
-	const uint32_t reserved_flags,
-	const ep_char8_t *module_il_path,
-	const ep_char8_t *module_native_path,
-	const uint8_t *managed_pdb_signature,
-	const uint32_t managed_pdb_age,
-	const ep_char8_t *managed_pdb_build_path,
-	const uint8_t *native_pdb_signature,
-	const uint32_t native_pdb_age,
-	const ep_char8_t *native_pdb_build_path,
-	void *user_data);
-static
-bool
-fire_domain_rundown_events_func (
-	const uint64_t domain_id,
-	const uint32_t domain_flags,
-	const ep_char8_t *domain_name,
-	const uint32_t domain_index,
-	void *user_data);
-static
-void
-eventpipe_fire_method_events (
-	MonoJitInfo *ji,
-	MonoMethod *method,
-	EventPipeFireMethodEventsData *events_data);
-static
-void
-eventpipe_fire_method_events_func (
-	MonoJitInfo *ji,
-	void *user_data);
-static
-void
-eventpipe_fire_assembly_events (
-	MonoDomain *domain,
-	MonoAssembly *assembly,
-	ep_rt_mono_fire_assembly_rundown_events_func assembly_events_func);
-static
-gboolean
-eventpipe_execute_rundown (
-	ep_rt_mono_fire_domain_rundown_events_func domain_events_func,
-	ep_rt_mono_fire_assembly_rundown_events_func assembly_events_func,
-	ep_rt_mono_fire_method_rundown_events_func methods_events_func);
-static
-gboolean
-eventpipe_walk_managed_stack_for_thread (
-	MonoStackFrameInfo *frame,
-	MonoContext *ctx,
-	EventPipeStackWalkData *stack_walk_data);
-static
-gboolean
-eventpipe_walk_managed_stack_for_thread_func (
-	MonoStackFrameInfo *frame,
-	MonoContext *ctx,
-	void *data);
-static
-gboolean
-eventpipe_sample_profiler_walk_managed_stack_for_thread_func (
-	MonoStackFrameInfo *frame,
-	MonoContext *ctx,
-	void *data);
-static
-void
-profiler_eventpipe_runtime_initialized (MonoProfiler *prof);
-static
-void
-profiler_eventpipe_thread_exited (
-	MonoProfiler *prof,
-	uintptr_t tid);
-static
-bool
-parse_mono_profiler_options (const ep_char8_t *option);
-static
-bool
-get_module_event_data (
-	MonoImage *image,
-	ModuleEventData *module_data);
-static
-bool
-get_assembly_event_data (
-	MonoAssembly *assembly,
-	AssemblyEventData *assembly_data);
-static
-uint32_t
-get_type_start_id (MonoType *type);
-static
-gboolean
-get_exception_ip_func (
-	MonoStackFrameInfo *frame,
-	MonoContext *ctx,
-	void *data);
-static
-void
-runtime_profiler_jit_begin (
-	MonoProfiler *prof,
-	MonoMethod *method);
-static
-void
-runtime_profiler_jit_failed (
-	MonoProfiler *prof,
-	MonoMethod *method);
-static
-void
-runtime_profiler_jit_done (
-	MonoProfiler *prof,
-	MonoMethod *method,
-	MonoJitInfo *ji);
-static
-void
-runtime_profiler_image_loaded (
-	MonoProfiler *prof,
-	MonoImage *image);
-static
-void
-runtime_profiler_image_unloaded (
-	MonoProfiler *prof,
-	MonoImage *image);
-static
-void
-runtime_profiler_assembly_loaded (
-	MonoProfiler *prof,
-	MonoAssembly *assembly);
-static
-void
-runtime_profiler_assembly_unloaded (
-	MonoProfiler *prof,
-	MonoAssembly *assembly);
-static
-void
-runtime_profiler_thread_started (
-	MonoProfiler *prof,
-	uintptr_t tid);
-static
-void
-runtime_profiler_thread_stopped (
-	MonoProfiler *prof,
-	uintptr_t tid);
-static
-void
-runtime_profiler_class_loading (
-	MonoProfiler *prof,
-	MonoClass *klass);
-static
-void
-runtime_profiler_class_failed (
-	MonoProfiler *prof,
-	MonoClass *klass);
-static
-void
-runtime_profiler_class_loaded (
-	MonoProfiler *prof,
-	MonoClass *klass);
-static
-void
-runtime_profiler_exception_throw (
-	MonoProfiler *prof,
-	MonoObject *exception);
-static
-void
-runtime_profiler_exception_clause (
-	MonoProfiler *prof,
-	MonoMethod *method,
-	uint32_t clause_num,
-	MonoExceptionEnum clause_type,
-	MonoObject *exc);
-static
-void
-runtime_profiler_monitor_contention (
-	MonoProfiler *prof,
-	MonoObject *obj);
-static
-void
-runtime_profiler_monitor_acquired (
-	MonoProfiler *prof,
-	MonoObject *obj);
-static
-void
-runtime_profiler_monitor_failed (
-	MonoProfiler *prof,
-	MonoObject *obj);
-static
-void
-runtime_profiler_jit_code_buffer (
-	MonoProfiler *prof,
-	const mono_byte *buffer,
-	uint64_t size,
-	MonoProfilerCodeBufferType type,
-	const void *data);
-static
-void
-mono_profiler_get_class_data (
-	MonoClass *klass,
-	uint64_t *class_id,
-	uint64_t *module_id,
-	ep_char8_t **class_name,
-	uint32_t *class_generic_type_count,
-	uint8_t **class_generic_types);
-static
-void
-mono_profiler_fire_event_enter (void);
-static
-void
-mono_profiler_fire_event_exit (void);
-static
-void
-mono_profiler_gc_in_progress_start (void);
-static
-void
-mono_profiler_gc_in_progress_stop (void);
-static
-MonoProfilerMemBlock *
-mono_profiler_mem_block_alloc (uint32_t req_size);
-static
-uint8_t *
-mono_profiler_mem_alloc (uint32_t req_size);
-static
-void
-mono_profiler_mem_block_free_all (void);
-static
-void
-mono_profiler_mem_block_free_all_but_current (void);
-static
-void
-mono_profiler_trigger_heap_collect (MonoProfiler *prof);
-static
-void
-mono_profiler_fire_gc_event_root_register (
-	uint8_t *data,
-	uint32_t payload_size);
-static
-void
-mono_profiler_fire_buffered_gc_event_root_register (
-	MonoProfiler *prof,
-	const mono_byte *start,
-	uintptr_t size,
-	MonoGCRootSource source,
-	const void * key,
-	const char * name);
-static
-void
-mono_profiler_fire_gc_event_root_unregister (
-	uint8_t *data,
-	uint32_t payload_size);
-static
-void
-mono_profiler_fire_buffered_gc_event_root_unregister (
-	MonoProfiler *prof,
-	const mono_byte *start);
-static
-void
-mono_profiler_fire_gc_event (
-	uint8_t *data,
-	uint32_t payload_size);
-static
-void
-mono_profiler_fire_buffered_gc_event (
-	uint8_t gc_event_type,
-	uint32_t generation);
-static
-void
-mono_profiler_fire_gc_event_resize (
-	uint8_t *data,
-	uint32_t payload_size);
-static
-void
-mono_profiler_fire_buffered_gc_event_resize (
-	MonoProfiler *prof,
-	uintptr_t size);
-static
-void
-mono_profiler_fire_gc_event_moves (
-	uint8_t *data,
-	uint32_t payload_size);
-static
-void
-mono_profiler_fire_buffered_gc_event_moves (
-	MonoProfiler *prof,
-	MonoObject *const* objects,
-	uint64_t count);
-static
-void
-mono_profiler_fire_gc_event_roots (
-	uint8_t *data,
-	uint32_t payload_size);
-static
-void
-mono_profiler_fire_buffered_gc_event_roots (
-	MonoProfiler *prof,
-	uint64_t count,
-	const mono_byte *const * addresses,
-	MonoObject *const * objects);
-static
-void
-mono_profiler_fire_gc_event_heap_dump_object_reference (
-	uint8_t *data,
-	uint32_t payload_size,
-	GHashTable *cache);
-static
-int
-mono_profiler_fire_buffered_gc_event_heap_dump_object_reference (
-	MonoObject *obj,
-	MonoClass *klass,
-	uintptr_t size,
-	uintptr_t num,
-	MonoObject **refs,
-	uintptr_t *offsets,
-	void *data);
-static
-void
-mono_profiler_fire_buffered_gc_events (
-	MonoProfilerMemBlock *block,
-	GHashTable *cache);
-static
-void
-mono_profiler_fire_buffered_gc_events_in_alloc_order (GHashTable *cache);
-static
-void
-mono_profiler_fire_cached_gc_events (GHashTable *cache);
-static
-void
-mono_profiler_app_domain_loading (
-	MonoProfiler *prof,
-	MonoDomain *domain);
-static
-void
-mono_profiler_app_domain_loaded (
-	MonoProfiler *prof,
-	MonoDomain *domain);
-static
-void
-mono_profiler_app_domain_unloading (
-	MonoProfiler *prof,
-	MonoDomain *domain);
-static
-void
-mono_profiler_app_domain_unloaded (
-	MonoProfiler *prof,
-	MonoDomain *domain);
-static
-void
-mono_profiler_app_domain_name (
-	MonoProfiler *prof,
-	MonoDomain *domain,
-	const char *name);
-static
-void
-mono_profiler_get_generic_types (
-	MonoGenericInst *generic_instance,
-	uint32_t *generic_type_count,
-	uint8_t **generic_types);
-static
-void
-mono_profiler_get_jit_data (
-	MonoMethod *method,
-	uint64_t *method_id,
-	uint64_t *module_id,
-	uint32_t *method_token,
-	uint32_t *method_generic_type_count,
-	uint8_t **method_generic_types);
-static
-void
-mono_profiler_jit_begin (
-	MonoProfiler *prof,
-	MonoMethod *method);
-static
-void
-mono_profiler_jit_failed (
-	MonoProfiler *prof,
-	MonoMethod *method);
-static
-void
-mono_profiler_jit_done (
-	MonoProfiler *prof,
-	MonoMethod *method,
-	MonoJitInfo *ji);
-static
-void
-mono_profiler_jit_chunk_created (
-	MonoProfiler *prof,
-	const mono_byte *chunk,
-	uintptr_t size);
-static
-void
-mono_profiler_jit_chunk_destroyed (
-	MonoProfiler *prof,
-	const mono_byte *chunk);
-static
-void
-mono_profiler_jit_code_buffer (
-	MonoProfiler *prof,
-	const mono_byte *buffer,
-	uint64_t size,
-	MonoProfilerCodeBufferType type,
-	const void *data);
-static
-void
-mono_profiler_class_loading (
-	MonoProfiler *prof,
-	MonoClass *klass);
-static
-void
-mono_profiler_class_failed (
-	MonoProfiler *prof,
-	MonoClass *klass);
-static
-void
-mono_profiler_class_loaded (
-	MonoProfiler *prof,
-	MonoClass *klass);
-static
-void
-mono_profiler_vtable_loading (
-	MonoProfiler *prof,
-	MonoVTable *vtable);
-static
-void
-mono_profiler_vtable_failed (
-	MonoProfiler *prof,
-	MonoVTable *vtable);
-static
-void
-mono_profiler_vtable_loaded (
-	MonoProfiler *prof,
-	MonoVTable *vtable);
-static
-void
-mono_profiler_module_loading (
-	MonoProfiler *prof,
-	MonoImage *image);
-static
-void
-mono_profiler_module_failed (
-	MonoProfiler *prof,
-	MonoImage *image);
-static
-void
-mono_profiler_module_loaded (
-	MonoProfiler *prof,
-	MonoImage *image);
-static
-void
-mono_profiler_module_unloading (
-	MonoProfiler *prof,
-	MonoImage *image);
-static
-void
-mono_profiler_module_unloaded (
-	MonoProfiler *prof,
-	MonoImage *image);
-static
-void
-mono_profiler_assembly_loading (
-	MonoProfiler *prof,
-	MonoAssembly *assembly);
-static
-void
-mono_profiler_assembly_loaded (
-	MonoProfiler *prof,
-	MonoAssembly *assembly);
-static
-void
-mono_profiler_assembly_unloading (
-	MonoProfiler *prof,
-	MonoAssembly *assembly);
-static
-void
-mono_profiler_assembly_unloaded (
-	MonoProfiler *prof,
-	MonoAssembly *assembly);
-static
-void
-mono_profiler_method_enter (
-	MonoProfiler *prof,
-	MonoMethod *method,
-	MonoProfilerCallContext *context);
-static
-void
-mono_profiler_method_leave (
-	MonoProfiler *prof,
-	MonoMethod *method,
-	MonoProfilerCallContext *context);
-static
-void
-mono_profiler_method_tail_call (
-	MonoProfiler *prof,
-	MonoMethod *method,
-	MonoMethod *target_method);
-static
-void
-mono_profiler_method_exception_leave (
-	MonoProfiler *prof,
-	MonoMethod *method,
-	MonoObject *exc);
-static
-void
-mono_profiler_method_free (
-	MonoProfiler *prof,
-	MonoMethod *method);
-static
-void
-mono_profiler_method_begin_invoke (
-	MonoProfiler *prof,
-	MonoMethod *method);
-static
-void
-mono_profiler_method_end_invoke (
-	MonoProfiler *prof,
-	MonoMethod *method);
-static
-MonoProfilerCallInstrumentationFlags
-mono_profiler_method_instrumentation (
-	MonoProfiler *prof,
-	MonoMethod *method);
-static
-void
-mono_profiler_exception_throw (
-	MonoProfiler *prof,
-	MonoObject *exc);
-static
-void
-mono_profiler_exception_clause (
-	MonoProfiler *prof,
-	MonoMethod *method,
-	uint32_t clause_num,
-	MonoExceptionEnum clause_type,
-	MonoObject *exc);
-static
-void
-mono_profiler_gc_event (
-	MonoProfiler *prof,
-	MonoProfilerGCEvent gc_event,
-	uint32_t generation,
-	mono_bool serial);
-static
-void
-mono_profiler_gc_allocation (
-	MonoProfiler *prof,
-	MonoObject *object);
-static
-void
-mono_profiler_gc_handle_created (
-	MonoProfiler *prof,
-	uint32_t handle,
-	MonoGCHandleType type,
-	MonoObject * object);
-static
-void
-mono_profiler_gc_handle_deleted (
-	MonoProfiler *prof,
-	uint32_t handle,
-	MonoGCHandleType type);
-static
-void
-mono_profiler_gc_finalizing (MonoProfiler *prof);
-static
-void
-mono_profiler_gc_finalized (MonoProfiler *prof);
-static
-void
-mono_profiler_gc_root_register (
-	MonoProfiler *prof,
-	const mono_byte *start,
-	uintptr_t size,
-	MonoGCRootSource source,
-	const void * key,
-	const char * name);
-static
-void
-mono_profiler_gc_root_unregister (
-	MonoProfiler *prof,
-	const mono_byte *start);
-static
-void
-mono_profiler_monitor_contention (
-	MonoProfiler *prof,
-	MonoObject *object);
-static
-void
-mono_profiler_monitor_failed (
-	MonoProfiler *prof,
-	MonoObject *object);
-static
-void
-mono_profiler_monitor_acquired (
-	MonoProfiler *prof,
-	MonoObject *object);
-static
-void
-mono_profiler_thread_started (
-	MonoProfiler *prof,
-	uintptr_t tid);
-static
-void
-mono_profiler_thread_stopping (
-	MonoProfiler *prof,
-	uintptr_t tid);
-static
-void
-mono_profiler_thread_stopped (
-	MonoProfiler *prof,
-	uintptr_t tid);
-static
-void
-mono_profiler_thread_exited (
-	MonoProfiler *prof,
-	uintptr_t tid);
-static
-void
-mono_profiler_thread_name (
-	MonoProfiler *prof,
-	uintptr_t tid,
-	const char *name);
-static
-const EventFilterDescriptor *
-mono_profiler_add_provider_param (const EventFilterDescriptor *key);
-static
-bool
-mono_profiler_remove_provider_param (const EventFilterDescriptor *key);
-static
-void
-mono_profiler_free_provider_params (void);
-static
-bool
-mono_profiler_provider_params_get_value (
-	const EventFilterDescriptor *param,
-	const ep_char8_t *key,
-	const ep_char8_t **value);
-static
-bool
-mono_profiler_provider_param_contains_heap_collect_ondemand (const EventFilterDescriptor *param);
-static
-void
-mono_profiler_push_gc_heap_collect_param_request_value (const EventFilterDescriptor *param);
-static
-void
-mono_profiler_pop_gc_heap_collect_param_request_value (void);
-static
-void
-mono_profiler_pop_gc_heap_collect_param_request_value (void);
-static
-const ep_char8_t *
-mono_profiler_get_gc_heap_collect_param_request_value (void);
-static
-void
-mono_profiler_free_gc_heap_collect_param_requests (void);
-static
-void
-mono_profiler_ep_provider_callback (
-	const uint8_t *source_id,
-	unsigned long is_enabled,
-	uint8_t level,
-	uint64_t match_any_keywords,
-	uint64_t match_all_keywords,
-	EventFilterDescriptor *filter_data,
-	void *callback_data);
-/*
- * Forward declares of all private functions (accessed using extern in ep-rt-mono.h).
- */
-void
-ep_rt_mono_component_init (void);
-void
-ep_rt_mono_init (void);
-void
-ep_rt_mono_init_finish (void);
-void
-ep_rt_mono_fini (void);
-bool
-ep_rt_mono_rand_try_get_bytes (
-	uint8_t *buffer,
-	size_t buffer_size);
-ep_rt_file_handle_t
-ep_rt_mono_file_open_write(const ep_char8_t *path);
-bool
-ep_rt_mono_file_close (ep_rt_file_handle_t handle);
-bool
-ep_rt_mono_file_write (
-	ep_rt_file_handle_t handle,
-	const uint8_t *buffer,
-	uint32_t numbytes,
-	uint32_t *byteswritten);
-EventPipeThread *
-ep_rt_mono_thread_get_or_create (void);
-void *
-ep_rt_mono_thread_attach (bool background_thread);
-void *
-ep_rt_mono_thread_attach_2 (bool background_thread, EventPipeThreadType thread_type);
-void
-ep_rt_mono_thread_detach (void);
-void
-ep_rt_mono_thread_exited (void);
-int64_t
-ep_rt_mono_perf_counter_query (void);
-int64_t
-ep_rt_mono_perf_frequency_query (void);
-void
-ep_rt_mono_system_time_get (EventPipeSystemTime *system_time);
-int64_t
-ep_rt_mono_system_timestamp_get (void);
-void
-ep_rt_mono_os_environment_get_utf16 (ep_rt_env_array_utf16_t *env_array);
-void
-ep_rt_mono_init_providers_and_events (void);
-void
-ep_rt_mono_provider_config_init (EventPipeProviderConfiguration *provider_config);
-bool
-ep_rt_mono_providers_validate_all_disabled (void);
-void
-ep_rt_mono_fini_providers_and_events (void);
-bool
-ep_rt_mono_sample_profiler_write_sampling_event_for_threads (
-	ep_rt_thread_handle_t sampling_thread,
-	EventPipeEvent *sampling_event);
-bool
-ep_rt_mono_walk_managed_stack_for_thread (
-	ep_rt_thread_handle_t thread,
-	EventPipeStackContents *stack_contents);
-bool
-ep_rt_mono_method_get_simple_assembly_name (
-	ep_rt_method_desc_t *method,
-	ep_char8_t *name,
-	size_t name_len);
-bool
-ep_rt_mono_method_get_full_name (
-	ep_rt_method_desc_t *method,
-	ep_char8_t *name,
-	size_t name_len);
-void
-ep_rt_mono_execute_rundown (ep_rt_execution_checkpoint_array_t *execution_checkpoints);
-static
-inline
-bool
-profiler_callback_is_enabled (uint64_t enabled_keywords, uint64_t keyword)
-{
-	return (enabled_keywords & keyword) == keyword;
-}
-static
-inline
-uint16_t
-clr_instance_get_id (void)
-{
-	return 9;
-}
-static
-EventPipeThreadData *
-eventpipe_thread_data_get_or_create (void)
-{
-	EventPipeThreadData *thread_data = (EventPipeThreadData *)mono_native_tls_get_value (_ep_rt_mono_thread_data_tls_id);
-	if (!thread_data) {
-		thread_data = ep_rt_object_alloc (EventPipeThreadData);
-		mono_native_tls_set_value (_ep_rt_mono_thread_data_tls_id, thread_data);
-	}
-	return thread_data;
-}
-static
-void
-eventpipe_thread_data_free (EventPipeThreadData *thread_data)
-{
-	ep_return_void_if_nok (thread_data != NULL);
-	ep_rt_object_free (thread_data);
-}
-static
-bool
-fire_method_rundown_events_func (
-	const uint64_t method_id,
-	const uint64_t module_id,
-	const uint64_t method_start_address,
-	const uint32_t method_size,
-	const uint32_t method_token,
-	const uint32_t method_flags,
-	const ep_char8_t *method_namespace,
-	const ep_char8_t *method_name,
-	const ep_char8_t *method_signature,
-	const uint16_t count_of_map_entries,
-	const uint32_t *il_offsets,
-	const uint32_t *native_offsets,
-	bool aot_method,
-	bool verbose,
-	void *user_data)
-{
-	FireEtwMethodDCEndILToNativeMap (
-		method_id,
-		0,
-		0,
-		count_of_map_entries,
-		il_offsets,
-		native_offsets,
-		clr_instance_get_id (),
-		NULL,
-		NULL);
-	if (verbose) {
-		FireEtwMethodDCEndVerbose_V1 (
-			method_id,
-			module_id,
-			method_start_address,
-			method_size,
-			method_token,
-			method_flags | METHOD_FLAGS_EXTENT_HOT_SECTION,
-			method_namespace,
-			method_name,
-			method_signature,
-			clr_instance_get_id (),
-			NULL,
-			NULL);
-		if (aot_method)
-			FireEtwMethodDCEndVerbose_V1 (
-				method_id,
-				module_id,
-				method_start_address,
-				method_size,
-				method_token,
-				method_flags | METHOD_FLAGS_EXTENT_COLD_SECTION,
-				method_namespace,
-				method_name,
-				method_signature,
-				clr_instance_get_id (),
-				NULL,
-				NULL);
-	} else {
-		FireEtwMethodDCEnd_V1 (
-			method_id,
-			module_id,
-			method_start_address,
-			method_size,
-			method_token,
-			method_flags | METHOD_FLAGS_EXTENT_HOT_SECTION,
-			clr_instance_get_id (),
-			NULL,
-			NULL);
-		if (aot_method)
-			FireEtwMethodDCEnd_V1 (
-				method_id,
-				module_id,
-				method_start_address,
-				method_size,
-				method_token,
-				method_flags | METHOD_FLAGS_EXTENT_COLD_SECTION,
-				clr_instance_get_id (),
-				NULL,
-				NULL);
-	}
-	return true;
-}
-static
-bool
-fire_assembly_rundown_events_func (
-	const uint64_t domain_id,
-	const uint64_t assembly_id,
-	const uint32_t assembly_flags,
-	const uint32_t binding_id,
-	const ep_char8_t *assembly_name,
-	const uint64_t module_id,
-	const uint32_t module_flags,
-	const uint32_t reserved_flags,
-	const ep_char8_t *module_il_path,
-	const ep_char8_t *module_native_path,
-	const uint8_t *managed_pdb_signature,
-	const uint32_t managed_pdb_age,
-	const ep_char8_t *managed_pdb_build_path,
-	const uint8_t *native_pdb_signature,
-	const uint32_t native_pdb_age,
-	const ep_char8_t *native_pdb_build_path,
-	void *user_data)
-{
-	FireEtwModuleDCEnd_V2 (
-		module_id,
-		assembly_id,
-		module_flags,
-		reserved_flags,
-		module_il_path,
-		module_native_path,
-		clr_instance_get_id (),
-		managed_pdb_signature,
-		managed_pdb_age,
-		managed_pdb_build_path,
-		native_pdb_signature,
-		native_pdb_age,
-		native_pdb_build_path,
-		NULL,
-		NULL);
-	FireEtwDomainModuleDCEnd_V1 (
-		module_id,
-		assembly_id,
-		domain_id,
-		module_flags,
-		reserved_flags,
-		module_il_path,
-		module_native_path,
-		clr_instance_get_id (),
-		NULL,
-		NULL);
-	FireEtwAssemblyDCEnd_V1 (
-		assembly_id,
-		domain_id,
-		binding_id,
-		assembly_flags,
-		assembly_name,
-		clr_instance_get_id (),
-		NULL,
-		NULL);
-	return true;
-}
-static
-bool
-fire_domain_rundown_events_func (
-	const uint64_t domain_id,
-	const uint32_t domain_flags,
-	const ep_char8_t *domain_name,
-	const uint32_t domain_index,
-	void *user_data)
-{
-	return FireEtwAppDomainDCEnd_V1 (
-		domain_id,
-		domain_flags,
-		domain_name,
-		domain_index,
-		clr_instance_get_id (),
-		NULL,
-		NULL);
-}
-static
-void
-eventpipe_fire_method_events (
-	MonoJitInfo *ji,
-	MonoMethod *method,
-	EventPipeFireMethodEventsData *events_data)
-{
-	EP_ASSERT (ji != NULL);
-	EP_ASSERT (events_data->domain != NULL);
-	EP_ASSERT (events_data->method_events_func != NULL);
-	uint64_t method_id = 0;
-	uint64_t module_id = 0;
-	uint64_t method_code_start = (uint64_t)ji->code_start;
-	uint32_t method_code_size = (uint32_t)ji->code_size;
-	uint32_t method_token = 0;
-	uint32_t method_flags = 0;
-	uint8_t kind = MONO_CLASS_DEF;
-	char *method_namespace = NULL;
-	const char *method_name = NULL;
-	char *method_signature = NULL;
-	bool verbose = (MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_EVENTPIPE_Context.Level >= (uint8_t)EP_EVENT_LEVEL_VERBOSE);
-	if (method) {
-		method_id = (uint64_t)method;
-		method_token = method->token;
-		if (mono_jit_info_get_generic_sharing_context (ji))
-			method_flags |= METHOD_FLAGS_SHARED_GENERIC_METHOD;
-		if (method->dynamic)
-			method_flags |= METHOD_FLAGS_DYNAMIC_METHOD;
-		if (!ji->from_aot && !ji->from_llvm) {
-			method_flags |= METHOD_FLAGS_JITTED_METHOD;
-			if (method->wrapper_type != MONO_WRAPPER_NONE)
-				method_flags |= METHOD_FLAGS_JITTED_HELPER_METHOD;
-		}
-		if (method->is_generic || method->is_inflated)
-			method_flags |= METHOD_FLAGS_GENERIC_METHOD;
-		if (method->klass) {
-			module_id = (uint64_t)m_class_get_image (method->klass);
-			kind = m_class_get_class_kind (method->klass);
-			if (kind == MONO_CLASS_GTD || kind == MONO_CLASS_GINST)
-				method_flags |= METHOD_FLAGS_GENERIC_METHOD;
-		}
-		if (verbose) {
-			method_name = method->name;
-			method_signature = mono_signature_full_name (mono_method_signature_internal (method));
-			if (method->klass)
-				method_namespace = mono_type_get_name_full (m_class_get_byval_arg (method->klass), MONO_TYPE_NAME_FORMAT_IL);
-		}
-	}
-	uint32_t offset_entries = 0;
-	uint32_t *il_offsets = NULL;
-	uint32_t *native_offsets = NULL;
-	MonoDebugMethodJitInfo *debug_info = method ? mono_debug_find_method (method, events_data->domain) : NULL;
-	if (debug_info) {
-		offset_entries = debug_info->num_line_numbers;
-		if (offset_entries != 0) {
-			size_t needed_size = (offset_entries * sizeof (uint32_t) * 2);
-			if (!events_data->buffer || needed_size > events_data->buffer_size) {
-				g_free (events_data->buffer);
-				events_data->buffer_size = (size_t)(needed_size * 1.5);
-				events_data->buffer = g_new (uint8_t, events_data->buffer_size);
-			}
-			if (events_data->buffer) {
-				il_offsets = (uint32_t*)events_data->buffer;
-				native_offsets = il_offsets + offset_entries;
-				for (uint32_t offset_count = 0; offset_count < offset_entries; ++offset_count) {
-					il_offsets [offset_count] = debug_info->line_numbers [offset_count].il_offset;
-					native_offsets [offset_count] = debug_info->line_numbers [offset_count].native_offset;
-				}
-			}
-		}
-		mono_debug_free_method_jit_info (debug_info);
-	}
-	if (events_data->buffer && !il_offsets && !native_offsets) {
-		EP_ASSERT (events_data->buffer_size >= sizeof (uint32_t) * 2);
-		offset_entries = 1;
-		il_offsets = (uint32_t*)events_data->buffer;
-		native_offsets = il_offsets + offset_entries;
-		il_offsets [0] = 0;
-		native_offsets [0] = (uint32_t)ji->code_size;
-	}
-	events_data->method_events_func (
-		method_id,
-		module_id,
-		method_code_start,
-		method_code_size,
-		method_token,
-		method_flags,
-		(ep_char8_t *)method_namespace,
-		(ep_char8_t *)method_name,
-		(ep_char8_t *)method_signature,
-		GUINT32_TO_UINT16 (offset_entries),
-		il_offsets,
-		native_offsets,
-		(ji->from_aot || ji->from_llvm),
-		verbose,
-		NULL);
-	g_free (method_namespace);
-	g_free (method_signature);
-}
-static
-inline
-bool
-include_method (MonoMethod *method)
-{
-	if (!method) {
-		return false;
-	} else if (!m_method_is_wrapper (method)) {
-		return true;
-	} else {
-		WrapperInfo *wrapper = mono_marshal_get_wrapper_info (method);
-		return (wrapper && wrapper->subtype == WRAPPER_SUBTYPE_PINVOKE) ? true : false;
-	}
-}
-static
-void
-eventpipe_fire_method_events_func (
-	MonoJitInfo *ji,
-	void  *user_data)
-{
-	EventPipeFireMethodEventsData *events_data = (EventPipeFireMethodEventsData *)user_data;
-	EP_ASSERT (events_data != NULL);
-	if (ji && !ji->is_trampoline && !ji->async) {
-		MonoMethod *method = jinfo_get_method (ji);
-		if (include_method (method))
-			eventpipe_fire_method_events (ji, method, events_data);
-	}
-}
-static
-void
-eventpipe_fire_assembly_events (
-	MonoDomain *domain,
-	MonoAssembly *assembly,
-	ep_rt_mono_fire_assembly_rundown_events_func assembly_events_func)
-{
-	EP_ASSERT (domain != NULL);
-	EP_ASSERT (assembly != NULL);
-	EP_ASSERT (assembly_events_func != NULL);
-	uint32_t binding_id = 0;
-	ModuleEventData module_data;
-	memset (&module_data, 0, sizeof (module_data));
-	get_module_event_data (assembly->image, &module_data);
-	uint32_t assembly_flags = 0;
-	if (assembly->dynamic)
-		assembly_flags |= ASSEMBLY_FLAGS_DYNAMIC_ASSEMBLY;
-	if (assembly->image && assembly->image->aot_module) {
-		assembly_flags |= ASSEMBLY_FLAGS_NATIVE_ASSEMBLY;
-	}
-	char *assembly_name = mono_stringify_assembly_name (&assembly->aname);
-	assembly_events_func (
-		module_data.domain_id,
-		module_data.assembly_id,
-		assembly_flags,
-		binding_id,
-		(const ep_char8_t*)assembly_name,
-		module_data.module_id,
-		module_data.module_flags,
-		module_data.reserved_flags,
-		(const ep_char8_t *)module_data.module_il_path,
-		(const ep_char8_t *)module_data.module_native_path,
-		module_data.module_il_pdb_signature,
-		module_data.module_il_pdb_age,
-		(const ep_char8_t *)module_data.module_il_pdb_path,
-		module_data.module_native_pdb_signature,
-		module_data.module_native_pdb_age,
-		(const ep_char8_t *)module_data.module_native_pdb_path,
-		NULL);
-	g_free (assembly_name);
-}
-static
-gboolean
-eventpipe_execute_rundown (
-	ep_rt_mono_fire_domain_rundown_events_func domain_events_func,
-	ep_rt_mono_fire_assembly_rundown_events_func assembly_events_func,
-	ep_rt_mono_fire_method_rundown_events_func method_events_func)
-{
-	EP_ASSERT (domain_events_func != NULL);
-	EP_ASSERT (assembly_events_func != NULL);
-	EP_ASSERT (method_events_func != NULL);
-	MonoDomain *root_domain = mono_get_root_domain ();
-	if (root_domain) {
-		uint64_t domain_id = (uint64_t)root_domain;
-		EventPipeFireMethodEventsData events_data;
-		events_data.domain = root_domain;
-		events_data.buffer_size = 1024 * sizeof(uint32_t);
-		events_data.buffer = g_new (uint8_t, events_data.buffer_size);
-		events_data.method_events_func = method_events_func;
-		mono_jit_info_table_foreach_internal (eventpipe_fire_method_events_func, &events_data);
-		if (mono_get_runtime_callbacks ()->is_interpreter_enabled())
-			mono_get_runtime_callbacks ()->interp_jit_info_foreach (eventpipe_fire_method_events_func, &events_data);
-		if (_ep_rt_mono_runtime_helper_compile_method_jitinfo && _ep_rt_mono_runtime_helper_compile_method)
-			eventpipe_fire_method_events (_ep_rt_mono_runtime_helper_compile_method_jitinfo, _ep_rt_mono_runtime_helper_compile_method, &events_data);
-		if (_ep_rt_mono_monitor_enter_method_jitinfo && _ep_rt_mono_monitor_enter_method)
-			eventpipe_fire_method_events (_ep_rt_mono_monitor_enter_method_jitinfo, _ep_rt_mono_monitor_enter_method, &events_data);
-		if (_ep_rt_mono_monitor_enter_v4_method_jitinfo && _ep_rt_mono_monitor_enter_v4_method)
-			eventpipe_fire_method_events (_ep_rt_mono_monitor_enter_v4_method_jitinfo, _ep_rt_mono_monitor_enter_v4_method, &events_data);
-		g_free (events_data.buffer);
-		GPtrArray *assemblies = mono_alc_get_all_loaded_assemblies ();
-		if (assemblies) {
-			for (uint32_t i = 0; i < assemblies->len; ++i) {
-				MonoAssembly *assembly = (MonoAssembly *)g_ptr_array_index (assemblies, i);
-				if (assembly)
-					eventpipe_fire_assembly_events (root_domain, assembly, assembly_events_func);
-			}
-			g_ptr_array_free (assemblies, TRUE);
-		}
-		uint32_t domain_flags = DOMAIN_FLAGS_DEFAULT_DOMAIN | DOMAIN_FLAGS_EXECUTABLE_DOMAIN;
-		const char *domain_name = root_domain->friendly_name ? root_domain->friendly_name : "";
-		uint32_t domain_index = 1;
-		domain_events_func (
-			domain_id,
-			domain_flags,
-			(const ep_char8_t *)domain_name,
-			domain_index,
-			NULL);
-	}
-	return TRUE;
-}
-inline
-static
-bool
-in_safe_point_frame (EventPipeStackContents *stack_content, WrapperInfo *wrapper)
-{
-	EP_ASSERT (stack_content != NULL);
-	if (wrapper && ep_stack_contents_get_length (stack_content) == 0 && wrapper->subtype == WRAPPER_SUBTYPE_ICALL_WRAPPER &&
-			(wrapper->d.icall.jit_icall_id == MONO_JIT_ICALL_mono_threads_state_poll ||
-			wrapper->d.icall.jit_icall_id == MONO_JIT_ICALL_mono_threads_enter_gc_safe_region_unbalanced ||
-			wrapper->d.icall.jit_icall_id == MONO_JIT_ICALL_mono_threads_exit_gc_safe_region_unbalanced ||
-			wrapper->d.icall.jit_icall_id == MONO_JIT_ICALL_mono_threads_enter_gc_unsafe_region_unbalanced ||
-			wrapper->d.icall.jit_icall_id == MONO_JIT_ICALL_mono_threads_exit_gc_unsafe_region_unbalanced))
-		return true;
-	return false;
-}
-inline
-static
-bool
-in_runtime_invoke_frame (EventPipeStackContents *stack_content, WrapperInfo *wrapper)
-{
-	EP_ASSERT (stack_content != NULL);
-	if (wrapper && ep_stack_contents_get_length (stack_content) == 0 &&
-			(wrapper->subtype == WRAPPER_SUBTYPE_RUNTIME_INVOKE_NORMAL ||
-			wrapper->subtype == WRAPPER_SUBTYPE_RUNTIME_INVOKE_DIRECT ||
-			wrapper->subtype == WRAPPER_SUBTYPE_RUNTIME_INVOKE_DYNAMIC ||
-			wrapper->subtype == WRAPPER_SUBTYPE_RUNTIME_INVOKE_VIRTUAL))
-		return true;
-	return false;
-}
-inline
-static
-bool
-in_monitor_enter_frame (WrapperInfo *wrapper)
-{
-	if (wrapper && wrapper->subtype == WRAPPER_SUBTYPE_ICALL_WRAPPER &&
-			(wrapper->d.icall.jit_icall_id == MONO_JIT_ICALL_mono_monitor_enter_fast ||
-			wrapper->d.icall.jit_icall_id == MONO_JIT_ICALL_mono_monitor_enter_internal))
-		return true;
-	return false;
-}
-inline
-static
-bool
-in_monitor_enter_v4_frame (WrapperInfo *wrapper)
-{
-	if (wrapper && wrapper->subtype == WRAPPER_SUBTYPE_ICALL_WRAPPER &&
-			(wrapper->d.icall.jit_icall_id == MONO_JIT_ICALL_mono_monitor_enter_v4_fast ||
-			wrapper->d.icall.jit_icall_id == MONO_JIT_ICALL_mono_monitor_enter_v4_internal))
-		return true;
-	return false;
-}
-static
-gboolean
-eventpipe_walk_managed_stack_for_thread (
-	MonoStackFrameInfo *frame,
-	MonoContext *ctx,
-	EventPipeStackWalkData *stack_walk_data)
-{
-	EP_ASSERT (frame != NULL);
-	EP_ASSERT (stack_walk_data != NULL);
-	switch (frame->type) {
-	case FRAME_TYPE_DEBUGGER_INVOKE:
-	case FRAME_TYPE_MANAGED_TO_NATIVE:
-	case FRAME_TYPE_TRAMPOLINE:
-	case FRAME_TYPE_INTERP_TO_MANAGED:
-	case FRAME_TYPE_INTERP_TO_MANAGED_WITH_CTX:
-	case FRAME_TYPE_INTERP_ENTRY:
-		stack_walk_data->top_frame = false;
-		return FALSE;
-	case FRAME_TYPE_JIT_ENTRY:
-		if (_ep_rt_mono_runtime_helper_compile_method && stack_walk_data->top_frame)
-			ep_stack_contents_append (stack_walk_data->stack_contents, (uintptr_t)((uint8_t*)_ep_rt_mono_runtime_helper_compile_method), _ep_rt_mono_runtime_helper_compile_method);
-		stack_walk_data->top_frame = false;
-		return FALSE;
-	case FRAME_TYPE_MANAGED:
-	case FRAME_TYPE_INTERP:
-		if (frame->ji) {
-			stack_walk_data->async_frame |= frame->ji->async;
-			MonoMethod *method = frame->ji->async ? NULL : frame->actual_method;
-			if (method && m_method_is_wrapper (method)) {
-				WrapperInfo *wrapper = mono_marshal_get_wrapper_info (method);
-				if (in_safe_point_frame (stack_walk_data->stack_contents, wrapper)) {
-					stack_walk_data->safe_point_frame = true;
-				}else if (in_runtime_invoke_frame (stack_walk_data->stack_contents, wrapper)) {
-					stack_walk_data->runtime_invoke_frame = true;
-				} else if (_ep_rt_mono_monitor_enter_method && in_monitor_enter_frame (wrapper)) {
-					ep_stack_contents_append (stack_walk_data->stack_contents, (uintptr_t)((uint8_t*)_ep_rt_mono_monitor_enter_method), _ep_rt_mono_monitor_enter_method);
-				} else if (_ep_rt_mono_monitor_enter_v4_method && in_monitor_enter_v4_frame (wrapper)) {
-					ep_stack_contents_append (stack_walk_data->stack_contents, (uintptr_t)((uint8_t*)_ep_rt_mono_monitor_enter_v4_method), _ep_rt_mono_monitor_enter_v4_method);
-				} else if (wrapper && wrapper->subtype == WRAPPER_SUBTYPE_PINVOKE) {
-					ep_stack_contents_append (stack_walk_data->stack_contents, (uintptr_t)((uint8_t*)frame->ji->code_start + frame->native_offset), method);
-				}
-			} else if (method && !m_method_is_wrapper (method)) {
-				ep_stack_contents_append (stack_walk_data->stack_contents, (uintptr_t)((uint8_t*)frame->ji->code_start + frame->native_offset), method);
-			} else if (!method && frame->ji->async && !frame->ji->is_trampoline) {
-				ep_stack_contents_append (stack_walk_data->stack_contents, (uintptr_t)((uint8_t*)frame->ji->code_start), method);
-			}
-		}
-		stack_walk_data->top_frame = false;
-		return ep_stack_contents_get_length (stack_walk_data->stack_contents) >= EP_MAX_STACK_DEPTH;
-	default:
-		EP_UNREACHABLE ("eventpipe_walk_managed_stack_for_thread");
-		return FALSE;
-	}
-}
-static
-gboolean
-eventpipe_walk_managed_stack_for_thread_func (
-	MonoStackFrameInfo *frame,
-	MonoContext *ctx,
-	void *data)
-{
-	return eventpipe_walk_managed_stack_for_thread (frame, ctx, (EventPipeStackWalkData *)data);
-}
-static
-gboolean
-eventpipe_sample_profiler_walk_managed_stack_for_thread_func (
-	MonoStackFrameInfo *frame,
-	MonoContext *ctx,
-	void *data)
-{
-	EP_ASSERT (frame != NULL);
-	EP_ASSERT (data != NULL);
-	EventPipeSampleProfileStackWalkData *sample_data = (EventPipeSampleProfileStackWalkData *)data;
-	if (sample_data->payload_data == EP_SAMPLE_PROFILER_SAMPLE_TYPE_ERROR) {
-		switch (frame->type) {
-		case FRAME_TYPE_MANAGED:
-			sample_data->payload_data = EP_SAMPLE_PROFILER_SAMPLE_TYPE_MANAGED;
-			break;
-		case FRAME_TYPE_MANAGED_TO_NATIVE:
-		case FRAME_TYPE_TRAMPOLINE:
-			sample_data->payload_data = EP_SAMPLE_PROFILER_SAMPLE_TYPE_EXTERNAL;
-			break;
-		case FRAME_TYPE_JIT_ENTRY:
-			sample_data->payload_data = EP_SAMPLE_PROFILER_SAMPLE_TYPE_EXTERNAL;
-			break;
-		case FRAME_TYPE_INTERP:
-			sample_data->payload_data = frame->managed ? EP_SAMPLE_PROFILER_SAMPLE_TYPE_MANAGED : EP_SAMPLE_PROFILER_SAMPLE_TYPE_EXTERNAL;
-			break;
-		case FRAME_TYPE_INTERP_TO_MANAGED:
-		case FRAME_TYPE_INTERP_TO_MANAGED_WITH_CTX:
-			break;
-		default:
-			sample_data->payload_data = EP_SAMPLE_PROFILER_SAMPLE_TYPE_MANAGED;
-		}
-	}
-	return eventpipe_walk_managed_stack_for_thread (frame, ctx, &sample_data->stack_walk_data);
-}
-static
-void
-profiler_eventpipe_runtime_initialized (MonoProfiler *prof)
-{
-	_ep_rt_mono_profiler_gc_can_collect_heap = true;
-}
-static
-void
-profiler_eventpipe_thread_exited (
-	MonoProfiler *prof,
-	uintptr_t tid)
-{
-	ep_rt_mono_thread_exited ();
-}
-static
-bool
-parse_mono_profiler_options (const ep_char8_t *option)
-{
-	do {
-		if (!*option)
-			return false;
-		if (!strncmp (option, "alloc", 5)) {
-			mono_profiler_enable_allocations ();
-			option += 5;
-		} else if (!strncmp (option, "exception", 9)) {
-			mono_profiler_enable_clauses ();
-			option += 9;
-		/*} else if (!strncmp (option, "sample", 6)) {
-			mono_profiler_enable_sampling (_ep_rt_dotnet_mono_profiler_provider);
-			option += 6;*/
-		} else {
-			return false;
-		}
-		if (*option == ',')
-			option++;
-	} while (*option);
-	return true;
-}
-void
-ep_rt_mono_component_init (void)
-{
-	_ep_rt_default_profiler = mono_profiler_create (NULL);
-	_ep_rt_dotnet_runtime_profiler_provider = mono_profiler_create (NULL);
-	_ep_rt_dotnet_mono_profiler_provider = mono_profiler_create (NULL);
-	_ep_rt_dotnet_mono_profiler_heap_collect_provider = mono_profiler_create (NULL);
-	char *diag_env = g_getenv("MONO_DIAGNOSTICS");
-	if (diag_env) {
-		int diag_argc = 1;
-		char **diag_argv = g_new (char *, 1);
-		if (diag_argv) {
-			diag_argv [0] = NULL;
-			if (!mono_parse_options_from (diag_env, &diag_argc, &diag_argv)) {
-				for (int i = 0; i < diag_argc; ++i) {
-					if (diag_argv [i]) {
-						if (strncmp (diag_argv [i], "--diagnostic-mono-profiler=", 27) == 0) {
-							if (!parse_mono_profiler_options (diag_argv [i] + 27))
-								mono_trace (G_LOG_LEVEL_ERROR, MONO_TRACE_DIAGNOSTICS, "Failed parsing MONO_DIAGNOSTICS environment variable option: %s", diag_argv [i]);
-						} else if (strncmp (diag_argv [i], "--diagnostic-mono-profiler-callspec=", 36) == 0) {
-							char *errstr = NULL;
-							if (!mono_callspec_parse (diag_argv [i] + 36, &_ep_rt_dotnet_mono_profiler_provider_callspec, &errstr)) {
-								mono_trace (G_LOG_LEVEL_ERROR, MONO_TRACE_DIAGNOSTICS, "Failed parsing '%s': %s", diag_argv [i], errstr);
-								g_free (errstr);
-								mono_callspec_cleanup (&_ep_rt_dotnet_mono_profiler_provider_callspec);
-							} else {
-								mono_profiler_set_call_instrumentation_filter_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_method_instrumentation);
-							}
-						} else if (strncmp (diag_argv [i], "--diagnostic-ports=", 19) == 0) {
-							char *diag_ports_env = g_getenv("DOTNET_DiagnosticPorts");
-							if (diag_ports_env)
-								mono_trace (G_LOG_LEVEL_WARNING, MONO_TRACE_DIAGNOSTICS, "DOTNET_DiagnosticPorts environment variable already set, ignoring --diagnostic-ports used in MONO_DIAGNOSTICS environment variable");
-							else
-								g_setenv ("DOTNET_DiagnosticPorts", diag_argv [i] + 19, TRUE);
-							g_free (diag_ports_env);
-						} else {
-							mono_trace (G_LOG_LEVEL_ERROR, MONO_TRACE_DIAGNOSTICS, "Failed parsing MONO_DIAGNOSTICS environment variable, unknown option: %s", diag_argv [i]);
-						}
-						g_free (diag_argv [i]);
-						diag_argv [i] = NULL;
-					}
-				}
-				g_free (diag_argv);
-			} else {
-				mono_trace (G_LOG_LEVEL_ERROR, MONO_TRACE_DIAGNOSTICS, "Failed parsing MONO_DIAGNOSTICS environment variable");
-			}
-		}
-	}
-	g_free (diag_env);
-}
-void
-ep_rt_mono_init (void)
-{
-	mono_native_tls_alloc (&_ep_rt_mono_thread_holder_tls_id, NULL);
-	mono_native_tls_alloc (&_ep_rt_mono_thread_data_tls_id, NULL);
-	mono_100ns_ticks ();
-	mono_rand_open ();
-	_ep_rt_mono_rand_provider = mono_rand_init (NULL, 0);
-	_ep_rt_mono_initialized = TRUE;
-	EP_ASSERT (_ep_rt_default_profiler != NULL);
-	EP_ASSERT (_ep_rt_dotnet_runtime_profiler_provider != NULL);
-	EP_ASSERT (_ep_rt_dotnet_mono_profiler_provider != NULL);
-	EP_ASSERT (_ep_rt_dotnet_mono_profiler_heap_collect_provider != NULL);
-	ep_rt_spin_lock_alloc (&_ep_rt_mono_profiler_gc_state_lock);
-	mono_profiler_set_runtime_initialized_callback (_ep_rt_default_profiler, profiler_eventpipe_runtime_initialized);
-	mono_profiler_set_thread_stopped_callback (_ep_rt_default_profiler, profiler_eventpipe_thread_exited);
-	MonoMethodSignature *method_signature = mono_metadata_signature_alloc (mono_get_corlib (), 1);
-	if (method_signature) {
-		method_signature->params[0] = m_class_get_byval_arg (mono_get_object_class());
-		method_signature->ret = m_class_get_byval_arg (mono_get_void_class());
-		ERROR_DECL (error);
-		MonoClass *runtime_helpers = mono_class_from_name_checked (mono_get_corlib (), "System.Runtime.CompilerServices", "RuntimeHelpers", error);
-		if (is_ok (error) && runtime_helpers) {
-			MonoMethodBuilder *method_builder = mono_mb_new (runtime_helpers, "CompileMethod", MONO_WRAPPER_RUNTIME_INVOKE);
-			if (method_builder) {
-				_ep_rt_mono_runtime_helper_compile_method = mono_mb_create_method (method_builder, method_signature, 1);
-				mono_mb_free (method_builder);
-			}
-		}
-		mono_error_cleanup (error);
-		mono_metadata_free_method_signature (method_signature);
-		if (_ep_rt_mono_runtime_helper_compile_method) {
-			_ep_rt_mono_runtime_helper_compile_method_jitinfo = (MonoJitInfo *)g_new0 (MonoJitInfo, 1);
-			if (_ep_rt_mono_runtime_helper_compile_method) {
-				_ep_rt_mono_runtime_helper_compile_method_jitinfo->code_start = MINI_FTNPTR_TO_ADDR (_ep_rt_mono_runtime_helper_compile_method);
-				_ep_rt_mono_runtime_helper_compile_method_jitinfo->code_size = 20;
-				_ep_rt_mono_runtime_helper_compile_method_jitinfo->d.method = _ep_rt_mono_runtime_helper_compile_method;
-			}
-		}
-	}
-	{
-		ERROR_DECL (error);
-		MonoMethodDesc *desc = NULL;
-		MonoClass *monitor = mono_class_from_name_checked (mono_get_corlib (), "System.Threading", "Monitor", error);
-		if (is_ok (error) && monitor) {
-			desc = mono_method_desc_new ("Monitor:Enter(object,bool&)", FALSE);
-			if (desc) {
-				_ep_rt_mono_monitor_enter_v4_method = mono_method_desc_search_in_class (desc, monitor);
-				mono_method_desc_free (desc);
-				if (_ep_rt_mono_monitor_enter_v4_method) {
-					_ep_rt_mono_monitor_enter_v4_method_jitinfo = (MonoJitInfo *)g_new0 (MonoJitInfo, 1);
-					if (_ep_rt_mono_monitor_enter_v4_method_jitinfo) {
-						_ep_rt_mono_monitor_enter_v4_method_jitinfo->code_start = MINI_FTNPTR_TO_ADDR (_ep_rt_mono_monitor_enter_v4_method);
-						_ep_rt_mono_monitor_enter_v4_method_jitinfo->code_size = 20;
-						_ep_rt_mono_monitor_enter_v4_method_jitinfo->d.method = _ep_rt_mono_monitor_enter_v4_method;
-					}
-				}
-			}
-			desc = mono_method_desc_new ("Monitor:Enter(object)", FALSE);
-			if (desc) {
-				_ep_rt_mono_monitor_enter_method = mono_method_desc_search_in_class (desc, monitor);
-				mono_method_desc_free (desc);
-				if (_ep_rt_mono_monitor_enter_method ) {
-					_ep_rt_mono_monitor_enter_method_jitinfo = (MonoJitInfo *)g_new0 (MonoJitInfo, 1);
-					if (_ep_rt_mono_monitor_enter_method_jitinfo) {
-						_ep_rt_mono_monitor_enter_method_jitinfo->code_start = MINI_FTNPTR_TO_ADDR (_ep_rt_mono_monitor_enter_method);
-						_ep_rt_mono_monitor_enter_method_jitinfo->code_size = 20;
-						_ep_rt_mono_monitor_enter_method_jitinfo->d.method = _ep_rt_mono_monitor_enter_method;
-					}
-				}
-			}
-		}
-		mono_error_cleanup (error);
-	}
-}
-void
-ep_rt_mono_init_finish (void)
-{
-	if (mono_runtime_get_no_exec ())
-		return;
-	ERROR_DECL (error);
-	MonoClass *runtime_event_source = mono_class_from_name_checked (mono_get_corlib (), "System.Diagnostics.Tracing", "RuntimeEventSource", error);
-	if (is_ok (error) && runtime_event_source) {
-		MonoMethod *init = mono_class_get_method_from_name_checked (runtime_event_source, "Initialize", -1, 0, error);
-		if (is_ok (error) && init) {
-			mono_runtime_try_invoke_handle (init, NULL_HANDLE, NULL, error);
-		}
-	}
-	mono_error_cleanup (error);
-}
-void
-ep_rt_mono_fini (void)
-{
-	if (_ep_rt_mono_sampled_thread_callstacks)
-		g_array_free (_ep_rt_mono_sampled_thread_callstacks, TRUE);
-	if (_ep_rt_mono_initialized)
-		mono_rand_close (_ep_rt_mono_rand_provider);
-	g_free (_ep_rt_mono_runtime_helper_compile_method_jitinfo);
-	_ep_rt_mono_runtime_helper_compile_method_jitinfo = NULL;
-	mono_free_method (_ep_rt_mono_runtime_helper_compile_method);
-	_ep_rt_mono_runtime_helper_compile_method = NULL;
-	g_free (_ep_rt_mono_monitor_enter_method_jitinfo);
-	_ep_rt_mono_monitor_enter_method_jitinfo = NULL;
-	_ep_rt_mono_monitor_enter_method = NULL;
-	g_free (_ep_rt_mono_monitor_enter_v4_method_jitinfo);
-	_ep_rt_mono_monitor_enter_v4_method_jitinfo = NULL;
-	_ep_rt_mono_monitor_enter_v4_method = NULL;
-	if (_ep_rt_dotnet_mono_profiler_provider_callspec.enabled) {
-		mono_profiler_set_call_instrumentation_filter_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-		mono_callspec_cleanup (&_ep_rt_dotnet_mono_profiler_provider_callspec);
-	}
-	mono_profiler_free_gc_heap_collect_param_requests ();
-	mono_profiler_free_provider_params ();
-	ep_rt_spin_lock_free (&_ep_rt_mono_profiler_gc_state_lock);
-	_ep_rt_mono_sampled_thread_callstacks = NULL;
-	_ep_rt_mono_rand_provider = NULL;
-	_ep_rt_mono_initialized = FALSE;
-}
-bool
-ep_rt_mono_rand_try_get_bytes (
-	uint8_t *buffer,
-	size_t buffer_size)
-{
-	EP_ASSERT (_ep_rt_mono_rand_provider != NULL);
-	ERROR_DECL (error);
-	return mono_rand_try_get_bytes (&_ep_rt_mono_rand_provider, (guchar *)buffer, (gssize)buffer_size, error);
-}
-char *
-ep_rt_mono_get_managed_cmd_line ()
-{
-	return mono_runtime_get_managed_cmd_line ();
-}
-char *
-ep_rt_mono_get_os_cmd_line ()
-{
-	MONO_REQ_GC_NEUTRAL_MODE;
-	char *host_path = minipal_getexepath ();
-	char *res = g_strdup (host_path);
-	free (host_path);
-	return res;
-}
-#ifdef HOST_WIN32
-ep_rt_file_handle_t
-ep_rt_mono_file_open_write (const ep_char8_t *path)
-{
-	if (!path)
-		return INVALID_HANDLE_VALUE;
-	ep_char16_t *path_utf16 = ep_rt_utf8_to_utf16le_string (path, -1);
-	if (!path_utf16)
-		return INVALID_HANDLE_VALUE;
-	ep_rt_file_handle_t res;
-	MONO_ENTER_GC_SAFE;
-	res = (ep_rt_file_handle_t)CreateFileW (path_utf16, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
-	MONO_EXIT_GC_SAFE;
-	ep_rt_utf16_string_free (path_utf16);
-	return res;
-}
-bool
-ep_rt_mono_file_close (ep_rt_file_handle_t handle)
-{
-	bool res;
-	MONO_ENTER_GC_SAFE;
-	res = CloseHandle (handle);
-	MONO_EXIT_GC_SAFE;
-	return res;
-}
-static
-void
-win32_io_interrupt_handler (void *ignored)
-{
-}
-bool
-ep_rt_mono_file_write (
-	ep_rt_file_handle_t handle,
-	const uint8_t *buffer,
-	uint32_t numbytes,
-	uint32_t *byteswritten)
-{
-	MONO_REQ_GC_UNSAFE_MODE;
-	bool res;
-	MonoThreadInfo *info = mono_thread_info_current ();
-	gboolean alerted = FALSE;
-	if (info) {
-		mono_thread_info_install_interrupt (win32_io_interrupt_handler, NULL, &alerted);
-		if (alerted) {
-			return false;
-		}
-		mono_win32_enter_blocking_io_call (info, handle);
-	}
-	MONO_ENTER_GC_SAFE;
-	if (info && mono_thread_info_is_interrupt_state (info)) {
-		res = false;
-	} else {
-		res = WriteFile (handle, buffer, numbytes, (PDWORD)byteswritten, NULL) ? true : false;
-	}
-	MONO_EXIT_GC_SAFE;
-	if (info) {
-		mono_win32_leave_blocking_io_call (info, handle);
-		mono_thread_info_uninstall_interrupt (&alerted);
-	}
-	return res;
-}
-#else
-#include <fcntl.h>
-#include <unistd.h>
-ep_rt_file_handle_t
-ep_rt_mono_file_open_write (const ep_char8_t *path)
-{
-	int fd;
-	mode_t perms = 0666;
-	if (!path)
-		return INVALID_HANDLE_VALUE;
-	MONO_ENTER_GC_SAFE;
-	fd = creat (path, perms);
-	MONO_EXIT_GC_SAFE;
-	if (fd == -1)
-		return INVALID_HANDLE_VALUE;
-	return (ep_rt_file_handle_t)(ptrdiff_t)fd;
-}
-bool
-ep_rt_mono_file_close (ep_rt_file_handle_t handle)
-{
-	int fd = (int)(ptrdiff_t)handle;
-	MONO_ENTER_GC_SAFE;
-	close (fd);
-	MONO_EXIT_GC_SAFE;
-	return true;
-}
-bool
-ep_rt_mono_file_write (
-	ep_rt_file_handle_t handle,
-	const uint8_t *buffer,
-	uint32_t numbytes,
-	uint32_t *byteswritten)
-{
-	MONO_REQ_GC_UNSAFE_MODE;
-	int fd = (int)(ptrdiff_t)handle;
-	uint32_t ret;
-	MonoThreadInfo *info = mono_thread_info_current ();
-	if (byteswritten != NULL)
-		*byteswritten = 0;
-	do {
-		MONO_ENTER_GC_SAFE;
-		ret = write (fd, buffer, numbytes);
-		MONO_EXIT_GC_SAFE;
-	} while (ret == -1 && errno == EINTR &&
-		 !mono_thread_info_is_interrupt_state (info));
-	if (ret == -1) {
-		if (errno == EINTR)
-			ret = 0;
-		else
-			return false;
-	}
-	if (byteswritten != NULL)
-		*byteswritten = ret;
-	return true;
-}
-#endif // HOST_WIN32
-EventPipeThread *
-ep_rt_mono_thread_get_or_create (void)
-{
-	EventPipeThreadHolder *thread_holder = (EventPipeThreadHolder *)mono_native_tls_get_value (_ep_rt_mono_thread_holder_tls_id);
-	if (!thread_holder) {
-		thread_holder = thread_holder_alloc_func ();
-		mono_native_tls_set_value (_ep_rt_mono_thread_holder_tls_id, thread_holder);
-	}
-	return ep_thread_holder_get_thread (thread_holder);
-}
-void *
-ep_rt_mono_thread_attach (bool background_thread)
-{
-	MonoThread *thread = NULL;
-	if (!mono_thread_current ()) {
-		thread = mono_thread_internal_attach (mono_get_root_domain ());
-		if (background_thread && thread) {
-			mono_thread_set_state (thread, ThreadState_Background);
-			mono_thread_info_set_flags (MONO_THREAD_INFO_FLAGS_NO_SAMPLE);
-		}
-	}
-	return thread;
-}
-void *
-ep_rt_mono_thread_attach_2 (bool background_thread, EventPipeThreadType thread_type)
-{
-	void *result = ep_rt_mono_thread_attach (background_thread);
-	if (result && thread_type == EP_THREAD_TYPE_SAMPLING) {
-#ifdef HOST_WIN32
-		SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_HIGHEST);
-#elif _POSIX_PRIORITY_SCHEDULING
-		int policy;
-		int priority;
-		struct sched_param param;
-		int schedparam_result = pthread_getschedparam (pthread_self (), &policy, &param);
-		if (schedparam_result == 0) {
-			priority = param.sched_priority;
-			param.sched_priority = sched_get_priority_max (SCHED_RR);
-			if (param.sched_priority != -1) {
-				schedparam_result = pthread_setschedparam (pthread_self (), SCHED_RR, &param);
-				if (schedparam_result != 0) {
-					param.sched_priority = sched_get_priority_max (policy);
-					if (param.sched_priority != -1 && param.sched_priority != priority)
-						pthread_setschedparam (pthread_self (), policy, &param);
-				}
-			}
-		}
-#endif
-	}
-	return result;
-}
-void
-ep_rt_mono_thread_detach (void)
-{
-	MonoThread *current_thread = mono_thread_current ();
-	if (current_thread)
-		mono_thread_internal_detach (current_thread);
-}
-void
-ep_rt_mono_thread_exited (void)
-{
-	if (_ep_rt_mono_initialized) {
-		EventPipeThreadHolder *thread_holder = (EventPipeThreadHolder *)mono_native_tls_get_value (_ep_rt_mono_thread_holder_tls_id);
-		if (thread_holder)
-			thread_holder_free_func (thread_holder);
-		mono_native_tls_set_value (_ep_rt_mono_thread_holder_tls_id, NULL);
-		EventPipeThreadData *thread_data = (EventPipeThreadData *)mono_native_tls_get_value (_ep_rt_mono_thread_data_tls_id);
-		if (thread_data)
-			eventpipe_thread_data_free (thread_data);
-		mono_native_tls_set_value (_ep_rt_mono_thread_data_tls_id, NULL);
-	}
-}
-#ifdef HOST_WIN32
-int64_t
-ep_rt_mono_perf_counter_query (void)
-{
-	LARGE_INTEGER value;
-	if (QueryPerformanceCounter (&value))
-		return (int64_t)value.QuadPart;
-	else
-		return 0;
-}
-int64_t
-ep_rt_mono_perf_frequency_query (void)
-{
-	LARGE_INTEGER value;
-	if (QueryPerformanceFrequency (&value))
-		return (int64_t)value.QuadPart;
-	else
-		return 0;
-}
-void
-ep_rt_mono_system_time_get (EventPipeSystemTime *system_time)
-{
-	SYSTEMTIME value;
-	GetSystemTime (&value);
-	EP_ASSERT (system_time != NULL);
-	ep_system_time_set (
-		system_time,
-		value.wYear,
-		value.wMonth,
-		value.wDayOfWeek,
-		value.wDay,
-		value.wHour,
-		value.wMinute,
-		value.wSecond,
-		value.wMilliseconds);
-}
-int64_t
-ep_rt_mono_system_timestamp_get (void)
-{
-	FILETIME value;
-	GetSystemTimeAsFileTime (&value);
-	return (int64_t)((((uint64_t)value.dwHighDateTime) << 32) | (uint64_t)value.dwLowDateTime);
-}
-#else
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <utime.h>
-#include <time.h>
-#if HAVE_SYS_TIME_H
-#include <sys/time.h>
-#endif // HAVE_SYS_TIME_H
-#if HAVE_MACH_ABSOLUTE_TIME
-#include <mach/mach_time.h>
-static mono_lazy_init_t _ep_rt_mono_time_base_info_init = MONO_LAZY_INIT_STATUS_NOT_INITIALIZED;
-static mach_timebase_info_data_t _ep_rt_mono_time_base_info = {0};
-#endif
-#ifdef HAVE_LOCALTIME_R
-#define HAVE_GMTIME_R 1
-#endif
-static const int64_t SECS_BETWEEN_1601_AND_1970_EPOCHS = 11644473600LL;
-static const int64_t SECS_TO_100NS = 10000000;
-static const int64_t SECS_TO_NS = 1000000000;
-static const int64_t MSECS_TO_MIS = 1000;
-/* clock_gettime () is found by configure on Apple builds, but its only present from ios 10, macos 10.12, tvos 10 and watchos 3 */
-#if defined (HAVE_CLOCK_MONOTONIC) && (defined(HOST_IOS) || defined(HOST_OSX) || defined(HOST_WATCHOS) || defined(HOST_TVOS))
-#undef HAVE_CLOCK_MONOTONIC
-#endif
-#ifndef HAVE_CLOCK_MONOTONIC
-static const int64_t MISECS_TO_NS = 1000;
-#endif
-static
-void
-time_base_info_lazy_init (void);
-static
-int64_t
-system_time_to_int64 (
-	time_t sec,
-	long nsec);
-#if HAVE_MACH_ABSOLUTE_TIME
-static
-void
-time_base_info_lazy_init (void)
-{
-	kern_return_t result = mach_timebase_info (&_ep_rt_mono_time_base_info);
-	if (result != KERN_SUCCESS)
-		memset (&_ep_rt_mono_time_base_info, 0, sizeof (_ep_rt_mono_time_base_info));
-}
-#endif
-int64_t
-ep_rt_mono_perf_counter_query (void)
-{
-#if HAVE_MACH_ABSOLUTE_TIME
-	return (int64_t)mach_absolute_time ();
-#elif HAVE_CLOCK_MONOTONIC
-	struct timespec ts;
-	int result = clock_gettime (CLOCK_MONOTONIC, &ts);
-	if (result == 0)
-		return ((int64_t)(ts.tv_sec) * (int64_t)(SECS_TO_NS)) + (int64_t)(ts.tv_nsec);
-#else
-	#error "ep_rt_mono_perf_counter_get requires either mach_absolute_time () or clock_gettime (CLOCK_MONOTONIC) to be supported."
-#endif
-	return 0;
-}
-int64_t
-ep_rt_mono_perf_frequency_query (void)
-{
-#if HAVE_MACH_ABSOLUTE_TIME
-	mono_lazy_initialize (&_ep_rt_mono_time_base_info_init, time_base_info_lazy_init);
-	if (_ep_rt_mono_time_base_info.denom == 0 || _ep_rt_mono_time_base_info.numer == 0)
-		return 0;
-	return ((int64_t)(SECS_TO_NS) * (int64_t)(_ep_rt_mono_time_base_info.denom)) / (int64_t)(_ep_rt_mono_time_base_info.numer);
-#elif HAVE_CLOCK_MONOTONIC
-	return (int64_t)(SECS_TO_NS);
-#else
-	#error "ep_rt_mono_perf_frequency_query requires either mach_absolute_time () or clock_gettime (CLOCK_MONOTONIC) to be supported."
-#endif
-	return 0;
-}
-void
-ep_rt_mono_system_time_get (EventPipeSystemTime *system_time)
-{
-	time_t tt;
-#if HAVE_GMTIME_R
-	struct tm ut;
-#endif /* HAVE_GMTIME_R */
-	struct tm *ut_ptr;
-	struct timeval time_val;
-	int timeofday_retval;
-	EP_ASSERT (system_time != NULL);
-	tt = time (NULL);
-	/* We can't get millisecond resolution from time (), so we get it from gettimeofday () */
-	timeofday_retval = gettimeofday (&time_val, NULL);
-#if HAVE_GMTIME_R
-	ut_ptr = &ut;
-	if (gmtime_r (&tt, ut_ptr) == NULL)
-#else /* HAVE_GMTIME_R */
-	if ((ut_ptr = gmtime (&tt)) == NULL)
-#endif /* HAVE_GMTIME_R */
-		EP_UNREACHABLE ();
-	uint16_t milliseconds = 0;
-	if (timeofday_retval != -1) {
-		int old_seconds;
-		int new_seconds;
-		milliseconds = (uint16_t)(time_val.tv_usec / MSECS_TO_MIS);
-		old_seconds = ut_ptr->tm_sec;
-		new_seconds = time_val.tv_sec % 60;
-		/* just in case we reached the next second in the interval between time () and gettimeofday () */
-		if (old_seconds != new_seconds)
-			milliseconds = 999;
-	}
-	ep_system_time_set (
-		system_time,
-		(uint16_t)(1900 + ut_ptr->tm_year),
-		(uint16_t)ut_ptr->tm_mon + 1,
-		(uint16_t)ut_ptr->tm_wday,
-		(uint16_t)ut_ptr->tm_mday,
-		(uint16_t)ut_ptr->tm_hour,
-		(uint16_t)ut_ptr->tm_min,
-		(uint16_t)ut_ptr->tm_sec,
-		milliseconds);
-}
-static
-inline
-int64_t
-system_time_to_int64 (
-	time_t sec,
-	long nsec)
-{
-	return ((int64_t)sec + SECS_BETWEEN_1601_AND_1970_EPOCHS) * SECS_TO_100NS + (nsec / 100);
-}
-int64_t
-ep_rt_mono_system_timestamp_get (void)
-{
-#if HAVE_CLOCK_MONOTONIC
-	struct timespec time;
-	if (clock_gettime (CLOCK_REALTIME, &time) == 0)
-		return system_time_to_int64 (time.tv_sec, time.tv_nsec);
-#else
-	struct timeval time;
-	if (gettimeofday (&time, NULL) == 0)
-		return system_time_to_int64 (time.tv_sec, time.tv_usec * MISECS_TO_NS);
-#endif
-	else
-		return system_time_to_int64 (0, 0);
-}
-#endif
-#ifndef HOST_WIN32
-#if defined(__APPLE__)
-#if defined (HOST_OSX)
-G_BEGIN_DECLS
-gchar ***_NSGetEnviron(void);
-G_END_DECLS
-#define environ (*_NSGetEnviron())
-#else
-static char *_ep_rt_mono_environ[1] = { NULL };
-#define environ _ep_rt_mono_environ
-#endif /* defined (HOST_OSX) */
-#else
-G_BEGIN_DECLS
-extern char **environ;
-G_END_DECLS
-#endif /* defined (__APPLE__) */
-#endif /* !defined (HOST_WIN32) */
-void
-ep_rt_mono_os_environment_get_utf16 (ep_rt_env_array_utf16_t *env_array)
-{
-	EP_ASSERT (env_array != NULL);
-#ifdef HOST_WIN32
-	LPWSTR envs = GetEnvironmentStringsW ();
-	if (envs) {
-		LPWSTR next = envs;
-		while (*next) {
-			ep_rt_env_array_utf16_append (env_array, ep_rt_utf16_string_dup (next));
-			next += ep_rt_utf16_string_len (next) + 1;
-		}
-		FreeEnvironmentStringsW (envs);
-	}
-#else
-	gchar **next = NULL;
-	for (next = environ; *next != NULL; ++next)
-		ep_rt_env_array_utf16_append (env_array, ep_rt_utf8_to_utf16le_string (*next, -1));
-#endif
-}
-void
-ep_rt_mono_init_providers_and_events (void)
-{
-	InitProvidersAndEvents ();
-}
-void
-ep_rt_mono_provider_config_init (EventPipeProviderConfiguration *provider_config)
-{
-	if (!ep_rt_utf8_string_compare (ep_config_get_rundown_provider_name_utf8 (), ep_provider_config_get_provider_name (provider_config))) {
-		MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_EVENTPIPE_Context.Level = (uint8_t)ep_provider_config_get_logging_level (provider_config);
-		MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_EVENTPIPE_Context.EnabledKeywordsBitmask = ep_provider_config_get_keywords (provider_config);
-		MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_EVENTPIPE_Context.IsEnabled = true;
-	}
-}
-bool
-ep_rt_mono_providers_validate_all_disabled (void)
-{
-	return (!MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_EVENTPIPE_Context.IsEnabled &&
-		!MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_EVENTPIPE_Context.IsEnabled &&
-		!MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_EVENTPIPE_Context.IsEnabled &&
-		!MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_EVENTPIPE_Context.IsEnabled);
-}
-void
-ep_rt_mono_fini_providers_and_events (void)
-{
-}
-bool
-ep_rt_mono_walk_managed_stack_for_thread (
-	ep_rt_thread_handle_t thread,
-	EventPipeStackContents *stack_contents)
-{
-	EP_ASSERT (thread != NULL && stack_contents != NULL);
-	EventPipeStackWalkData stack_walk_data;
-	stack_walk_data.stack_contents = stack_contents;
-	stack_walk_data.top_frame = true;
-	stack_walk_data.async_frame = false;
-	stack_walk_data.safe_point_frame = false;
-	stack_walk_data.runtime_invoke_frame = false;
-	bool restore_async_context = FALSE;
-	bool prevent_profiler_event_recursion = FALSE;
-	EventPipeThreadData *thread_data = eventpipe_thread_data_get_or_create ();
-	if (thread_data) {
-		prevent_profiler_event_recursion = thread_data->prevent_profiler_event_recursion;
-		if (prevent_profiler_event_recursion && !mono_thread_info_is_async_context ()) {
-			mono_thread_info_set_is_async_context (TRUE);
-			restore_async_context = TRUE;
-		}
-		thread_data->prevent_profiler_event_recursion = TRUE;
-	}
-	if (thread == ep_rt_thread_get_handle () && mono_get_eh_callbacks ()->mono_walk_stack_with_ctx)
-		mono_get_eh_callbacks ()->mono_walk_stack_with_ctx (eventpipe_walk_managed_stack_for_thread_func, NULL, MONO_UNWIND_SIGNAL_SAFE, &stack_walk_data);
-	else if (mono_get_eh_callbacks ()->mono_walk_stack_with_state)
-		mono_get_eh_callbacks ()->mono_walk_stack_with_state (eventpipe_walk_managed_stack_for_thread_func, mono_thread_info_get_suspend_state (thread), MONO_UNWIND_SIGNAL_SAFE, &stack_walk_data);
-	if (thread_data) {
-		if (restore_async_context)
-			mono_thread_info_set_is_async_context (FALSE);
-		thread_data->prevent_profiler_event_recursion = prevent_profiler_event_recursion;
-	}
-	return true;
-}
-bool
-ep_rt_mono_method_get_simple_assembly_name (
-	ep_rt_method_desc_t *method,
-	ep_char8_t *name,
-	size_t name_len)
-{
-	EP_ASSERT (method != NULL);
-	EP_ASSERT (name != NULL);
-	MonoClass *method_class = mono_method_get_class (method);
-	MonoImage *method_image = method_class ? mono_class_get_image (method_class) : NULL;
-	const ep_char8_t *assembly_name = method_image ? mono_image_get_name (method_image) : NULL;
-	if (!assembly_name)
-		return false;
-	g_strlcpy (name, assembly_name, name_len);
-	return true;
-}
-bool
-ep_rt_mono_method_get_full_name (
-	ep_rt_method_desc_t *method,
-	ep_char8_t *name,
-	size_t name_len)
-{
-	EP_ASSERT (method != NULL);
-	EP_ASSERT (name != NULL);
-	char *full_method_name = mono_method_get_name_full (method, TRUE, TRUE, MONO_TYPE_NAME_FORMAT_IL);
-	if (!full_method_name)
-		return false;
-	g_strlcpy (name, full_method_name, name_len);
-	g_free (full_method_name);
-	return true;
-}
-bool
-ep_rt_mono_sample_profiler_write_sampling_event_for_threads (
-	ep_rt_thread_handle_t sampling_thread,
-	EventPipeEvent *sampling_event)
-{
-	if (!_ep_rt_mono_sampled_thread_callstacks)
-		_ep_rt_mono_sampled_thread_callstacks = g_array_sized_new (FALSE, FALSE, sizeof (EventPipeSampleProfileStackWalkData), _ep_rt_mono_max_sampled_thread_count);
-	g_array_set_size (_ep_rt_mono_sampled_thread_callstacks, _ep_rt_mono_max_sampled_thread_count);
-	uint32_t filtered_thread_count = 0;
-	uint32_t sampled_thread_count = 0;
-	mono_stop_world (MONO_THREAD_INFO_FLAGS_NO_GC);
-	bool restore_async_context = FALSE;
-	if (!mono_thread_info_is_async_context ()) {
-		mono_thread_info_set_is_async_context (TRUE);
-		restore_async_context = TRUE;
-	}
-	FOREACH_THREAD_SAFE_EXCLUDE (thread_info, MONO_THREAD_INFO_FLAGS_NO_GC | MONO_THREAD_INFO_FLAGS_NO_SAMPLE) {
-		if (!mono_thread_info_is_running (thread_info)) {
-			MonoThreadUnwindState *thread_state = mono_thread_info_get_suspend_state (thread_info);
-			if (thread_state->valid) {
-				if (sampled_thread_count < _ep_rt_mono_max_sampled_thread_count) {
-					EventPipeSampleProfileStackWalkData *data = &g_array_index (_ep_rt_mono_sampled_thread_callstacks, EventPipeSampleProfileStackWalkData, sampled_thread_count);
-					data->thread_id = ep_rt_thread_id_t_to_uint64_t (mono_thread_info_get_tid (thread_info));
-					data->thread_ip = (uintptr_t)MONO_CONTEXT_GET_IP (&thread_state->ctx);
-					data->payload_data = EP_SAMPLE_PROFILER_SAMPLE_TYPE_ERROR;
-					data->stack_walk_data.stack_contents = &data->stack_contents;
-					data->stack_walk_data.top_frame = true;
-					data->stack_walk_data.async_frame = false;
-					data->stack_walk_data.safe_point_frame = false;
-					data->stack_walk_data.runtime_invoke_frame = false;
-					ep_stack_contents_reset (&data->stack_contents);
-					mono_get_eh_callbacks ()->mono_walk_stack_with_state (eventpipe_sample_profiler_walk_managed_stack_for_thread_func, thread_state, MONO_UNWIND_SIGNAL_SAFE, data);
-					if (data->payload_data == EP_SAMPLE_PROFILER_SAMPLE_TYPE_EXTERNAL && (data->stack_walk_data.safe_point_frame || data->stack_walk_data.runtime_invoke_frame)) {
-						data->payload_data = EP_SAMPLE_PROFILER_SAMPLE_TYPE_MANAGED;
-					}
-					if (data->stack_walk_data.top_frame && ep_stack_contents_get_length (&data->stack_contents) == 0) {
-						data->payload_data = EP_SAMPLE_PROFILER_SAMPLE_TYPE_EXTERNAL;
-					}
-					sampled_thread_count++;
-				}
-			}
-		}
-		filtered_thread_count++;
-	} FOREACH_THREAD_SAFE_END
-	if (restore_async_context)
-		mono_thread_info_set_is_async_context (FALSE);
-	mono_restart_world (MONO_THREAD_INFO_FLAGS_NO_GC);
-	THREAD_INFO_TYPE adapter = { { 0 } };
-	for (uint32_t thread_count = 0; thread_count < sampled_thread_count; ++thread_count) {
-		EventPipeSampleProfileStackWalkData *data = &g_array_index (_ep_rt_mono_sampled_thread_callstacks, EventPipeSampleProfileStackWalkData, thread_count);
-		if ((data->stack_walk_data.top_frame && data->payload_data == EP_SAMPLE_PROFILER_SAMPLE_TYPE_EXTERNAL) || (data->payload_data != EP_SAMPLE_PROFILER_SAMPLE_TYPE_ERROR && ep_stack_contents_get_length (&data->stack_contents) > 0)) {
-			if (data->stack_walk_data.async_frame) {
-				for (uint32_t frame_count = 0; frame_count < data->stack_contents.next_available_frame; ++frame_count)
-					mono_jit_info_table_find_internal ((gpointer)data->stack_contents.stack_frames [frame_count], TRUE, FALSE);
-			}
-			mono_thread_info_set_tid (&adapter, ep_rt_uint64_t_to_thread_id_t (data->thread_id));
-			uint32_t payload_data = ep_rt_val_uint32_t (data->payload_data);
-			ep_write_sample_profile_event (sampling_thread, sampling_event, &adapter, &data->stack_contents, (uint8_t *)&payload_data, sizeof (payload_data));
-		}
-	}
-	_ep_rt_mono_max_sampled_thread_count = filtered_thread_count;
-	return true;
-}
-void
-ep_rt_mono_execute_rundown (ep_rt_execution_checkpoint_array_t *execution_checkpoints)
-{
-	ep_char8_t runtime_module_path [256];
-	const uint8_t object_guid [EP_GUID_SIZE] = { 0 };
-	const uint16_t runtime_product_qfe_version = 0;
-	const uint8_t startup_flags = 0;
-	const uint8_t startup_mode = 0;
-	const ep_char8_t *command_line = "";
-	if (!g_module_address ((void *)mono_init, runtime_module_path, sizeof (runtime_module_path), NULL, NULL, 0, NULL))
-		runtime_module_path [0] = '\0';
-	FireEtwRuntimeInformationDCStart (
-		clr_instance_get_id (),
-		RUNTIME_SKU_MONO,
-		RuntimeProductMajorVersion,
-		RuntimeProductMinorVersion,
-		RuntimeProductPatchVersion,
-		runtime_product_qfe_version,
-		RuntimeFileMajorVersion,
-		RuntimeFileMajorVersion,
-		RuntimeFileBuildVersion,
-		RuntimeFileRevisionVersion,
-		startup_mode,
-		startup_flags,
-		command_line,
-		object_guid,
-		runtime_module_path,
-		NULL,
-		NULL);
-	if (execution_checkpoints) {
-		ep_rt_execution_checkpoint_array_iterator_t execution_checkpoints_iterator = ep_rt_execution_checkpoint_array_iterator_begin (execution_checkpoints);
-		while (!ep_rt_execution_checkpoint_array_iterator_end (execution_checkpoints, &execution_checkpoints_iterator)) {
-			EventPipeExecutionCheckpoint *checkpoint = ep_rt_execution_checkpoint_array_iterator_value (&execution_checkpoints_iterator);
-			FireEtwExecutionCheckpointDCEnd (
-				clr_instance_get_id (),
-				checkpoint->name,
-				checkpoint->timestamp,
-				NULL,
-				NULL);
-			ep_rt_execution_checkpoint_array_iterator_next (&execution_checkpoints_iterator);
-		}
-	}
-	FireEtwDCEndInit_V1 (
-		clr_instance_get_id (),
-		NULL,
-		NULL);
-	eventpipe_execute_rundown (
-		fire_domain_rundown_events_func,
-		fire_assembly_rundown_events_func,
-		fire_method_rundown_events_func);
-	FireEtwDCEndComplete_V1 (
-		clr_instance_get_id (),
-		NULL,
-		NULL);
-}
-bool
-ep_rt_mono_write_event_ee_startup_start (void)
-{
-	return FireEtwEEStartupStart_V1 (
-		clr_instance_get_id (),
-		NULL,
-		NULL);
-}
-#define STACK_ALLOC 256
-#define INIT_SIZE_OF_TYPE_PARAMETER_ARRAY ((uint32_t)(STACK_ALLOC / sizeof (intptr_t)))
-typedef enum {
-	TYPE_FLAGS_DELEGATE = 0x1,
-	TYPE_FLAGS_FINALIZABLE = 0x2,
-	TYPE_FLAGS_EXTERNALLY_IMPLEMENTED_COM_OBJECT = 0x4,
-	TYPE_FLAGS_ARRAY = 0x8,
-	TYPE_FLAGS_ARRAY_RANK_MASK = 0x3F00,
-	TYPE_FLAGS_ARRAY_RANK_SHIFT = 8,
-	TYPE_FLAGS_ARRAY_RANK_MAX = TYPE_FLAGS_ARRAY_RANK_MASK >> TYPE_FLAGS_ARRAY_RANK_SHIFT
-} TypeFlags;
-typedef struct _EventStructBulkTypeFixedSizedData {
-	uint64_t type_id;
-	uint64_t module_id;
-	uint32_t type_name_id;
-	uint32_t flags;
-	uint8_t cor_element_type;
-} EventStructBulkTypeFixedSizedData;
-typedef struct _BulkTypeValue {
-	EventStructBulkTypeFixedSizedData fixed_sized_data;
-	uint32_t type_parameters_count;
-	MonoType **mono_type_parameters;
-	ep_char8_t *name; // Currently should only be NULL, TODO if we want to provide the name in the BulkTypeEvent data, figure out memory management to use
-} BulkTypeValue;
-static
-void
-ep_rt_bulk_type_value_clear (BulkTypeValue *bulk_type_value);
-static
-int
-ep_rt_mono_get_byte_count_in_event (BulkTypeValue *bulk_type_value);
-static
-BulkTypeEventLogger*
-ep_rt_bulk_type_event_logger_alloc (void);
-static
-void
-ep_rt_bulk_type_event_logger_free (BulkTypeEventLogger *type_logger);
-static
-int
-write_event_buffer (
-	const uint8_t *val,
-	int size,
-	char *buf_start,
-	char **buf_next);
-static
-int
-write_event_buffer_int8 (
-	int8_t val,
-	char *buf_start,
-	char **buf_next);
-static
-int
-write_event_buffer_int16 (
-	int16_t val,
-	char *buf_start,
-	char **buf_next);
-static
-int
-write_event_buffer_int32 (
-	int32_t val,
-	char *buf_start,
-	char **buf_next);
-static
-int
-write_event_buffer_int64 (
-	int64_t val,
-	char *buf_start,
-	char **buf_next);
-static
-uint64_t
-get_typeid_for_type (MonoType *t);
-static
-uint64_t
-get_typeid_for_class (MonoClass *c);
-static
-void
-ep_rt_bulk_type_value_clear (BulkTypeValue *bulk_type_value)
-{
-	memset (bulk_type_value, 0, sizeof(BulkTypeValue));
-}
-static
-int
-ep_rt_mono_get_byte_count_in_event (BulkTypeValue *bulk_type_value)
-{
-	int name_len = 0;
-	return sizeof (bulk_type_value->fixed_sized_data.type_id) + 	// Fixed Sized Data
-		sizeof (bulk_type_value->fixed_sized_data.module_id) +
-		sizeof (bulk_type_value->fixed_sized_data.type_name_id) +
-		sizeof (bulk_type_value->fixed_sized_data.flags) +
-		sizeof (bulk_type_value->fixed_sized_data.cor_element_type) +
-		sizeof (bulk_type_value->type_parameters_count) +		// Type parameters
-		(name_len + 1) * sizeof (ep_char8_t) +		// Size of name, including null terminator
-		bulk_type_value->type_parameters_count * sizeof (uint64_t);	// Type parameters
-}
-#define MAX_EVENT_BYTE_COUNT (63 * 1024)
-#define MAX_SIZE_OF_EVENT_BUFFER 65536
-#define MAX_TYPE_VALUES_BYTES (MAX_EVENT_BYTE_COUNT - 0x30)
-#define K_MAX_COUNT_TYPE_VALUES ((uint32_t)(128 - 2) / 4)
-struct _BulkTypeEventLogger {
-	BulkTypeValue bulk_type_values [K_MAX_COUNT_TYPE_VALUES];
-	uint8_t *bulk_type_event_buffer;
-	uint32_t bulk_type_value_count;
-	uint32_t bulk_type_value_byte_count;
-	MonoMemPool *mem_pool;
-};
-static
-BulkTypeEventLogger*
-ep_rt_bulk_type_event_logger_alloc ()
-{
-	BulkTypeEventLogger *type_logger = g_malloc0 (sizeof (BulkTypeEventLogger));
-	type_logger->bulk_type_event_buffer = g_malloc0 (sizeof (uint8_t) * MAX_SIZE_OF_EVENT_BUFFER);
-	type_logger->mem_pool = mono_mempool_new ();
-	return type_logger;
-}
-static
-void
-ep_rt_bulk_type_event_logger_free (BulkTypeEventLogger *type_logger)
-{
-	mono_mempool_destroy (type_logger->mem_pool);
-	g_free (type_logger->bulk_type_event_buffer);
-	g_free (type_logger);
-}
-static
-int
-write_event_buffer (
-	const uint8_t *val,
-	int size,
-	char *buf_start,
-	char **buf_next)
-{
-	memcpy (buf_start, val, size);
-	*buf_next = buf_start + size;
-	return size;
-}
-static
-int
-write_event_buffer_int8 (
-	int8_t val,
-	char *buf_start,
-	char **buf_next)
-{
-	return write_event_buffer ((const uint8_t *)&val, sizeof (int8_t), buf_start, buf_next);
-}
-static
-int
-write_event_buffer_int16 (
-	int16_t val,
-	char *buf_start,
-	char **buf_next)
-{
-	return write_event_buffer ((const uint8_t *)&val, sizeof (int16_t), buf_start, buf_next);
-}
-static
-int
-write_event_buffer_int32 (
-	int32_t val,
-	char *buf_start,
-	char **buf_next)
-{
-	return write_event_buffer ((const uint8_t *)&val, sizeof (int32_t), buf_start, buf_next);
-}
-static
-int
-write_event_buffer_int64 (
-	int64_t val,
-	char *buf_start,
-	char **buf_next)
-{
-	return write_event_buffer ((const uint8_t *)&val, sizeof (int64_t), buf_start, buf_next);
-}
-void
-ep_rt_mono_fire_bulk_type_event (BulkTypeEventLogger *type_logger)
-{
-	if (type_logger->bulk_type_value_count == 0)
-		return;
-	uint16_t clr_instance_id = clr_instance_get_id ();
-	uint32_t values_element_size = 0;
-	char *ptr = (char *)type_logger->bulk_type_event_buffer;
-	for (uint32_t type_value_index = 0; type_value_index < type_logger->bulk_type_value_count; type_value_index++) {
-		BulkTypeValue *target = &type_logger->bulk_type_values [type_value_index];
-		values_element_size += write_event_buffer_int64 (target->fixed_sized_data.type_id, ptr, &ptr);
-		values_element_size += write_event_buffer_int64 (target->fixed_sized_data.module_id, ptr, &ptr);
-		values_element_size += write_event_buffer_int32 (target->fixed_sized_data.type_name_id, ptr, &ptr);
-		values_element_size += write_event_buffer_int32 (target->fixed_sized_data.flags, ptr, &ptr);
-		values_element_size += write_event_buffer_int8 (target->fixed_sized_data.cor_element_type, ptr, &ptr);
-		g_assert (target->name == NULL);
-		values_element_size += write_event_buffer_int16 (0, ptr, &ptr);
-		values_element_size += write_event_buffer_int32 (target->type_parameters_count, ptr, &ptr);
-		for (uint32_t i = 0; i < target->type_parameters_count; i++) {
-			uint64_t type_parameter = get_typeid_for_type (target->mono_type_parameters [i]);
-			values_element_size += write_event_buffer_int64 ((int64_t)type_parameter, ptr, &ptr);
-		}
-	}
-	FireEtwBulkType (
-		type_logger->bulk_type_value_count,
-		clr_instance_id,
-		values_element_size,
-		type_logger->bulk_type_event_buffer,
-		NULL,
-		NULL);
-	memset (type_logger->bulk_type_event_buffer, 0, sizeof (uint8_t) * MAX_SIZE_OF_EVENT_BUFFER);
-	type_logger->bulk_type_value_count = 0;
-	type_logger->bulk_type_value_byte_count = 0;
-}
-static
-uint64_t
-get_typeid_for_type (MonoType *t)
-{
-	if (m_type_is_byref (t))
-		return (uint64_t)m_class_get_this_arg (mono_class_from_mono_type_internal (t));
-	else
-		return (uint64_t)m_class_get_byval_arg (mono_class_from_mono_type_internal (t));
-}
-static
-uint64_t
-get_typeid_for_class (MonoClass *c)
-{
-	return get_typeid_for_type (m_class_get_byval_arg (c));
-}
-int
-ep_rt_mono_log_single_type (
-	BulkTypeEventLogger *type_logger,
-	MonoType *mono_type)
-{
-	if (type_logger->bulk_type_value_count == K_MAX_COUNT_TYPE_VALUES)
-		ep_rt_mono_fire_bulk_type_event (type_logger);
-	EP_ASSERT (type_logger->bulk_type_value_count < K_MAX_COUNT_TYPE_VALUES);
-	BulkTypeValue *val = &type_logger->bulk_type_values [type_logger->bulk_type_value_count];
-	ep_rt_bulk_type_value_clear (val);
-	MonoClass *klass = mono_class_from_mono_type_internal (mono_type);
-	MonoType *mono_underlying_type = mono_type_get_underlying_type (mono_type);
-	val->fixed_sized_data.type_id = get_typeid_for_type (mono_type);
-	val->fixed_sized_data.module_id = (uint64_t)m_class_get_image (klass);
-	val->fixed_sized_data.type_name_id = m_class_get_type_token (klass) ? mono_metadata_make_token (MONO_TABLE_TYPEDEF, mono_metadata_token_index (m_class_get_type_token (klass))) : 0;
-	if (mono_class_has_finalizer (klass))
-		val->fixed_sized_data.flags |= TYPE_FLAGS_FINALIZABLE;
-	if (m_class_is_delegate (klass))
-		val->fixed_sized_data.flags |= TYPE_FLAGS_DELEGATE;
-	if (mono_class_is_com_object (klass))
-		val->fixed_sized_data.flags |= TYPE_FLAGS_EXTERNALLY_IMPLEMENTED_COM_OBJECT;
-	val->fixed_sized_data.cor_element_type = (uint8_t)mono_underlying_type->type;
-	switch (mono_underlying_type->type) {
-	case MONO_TYPE_ARRAY:
-	case MONO_TYPE_SZARRAY:
-	{
-		MonoArrayType *mono_array_type = mono_type_get_array_type (mono_type);
-		val->fixed_sized_data.flags |= TYPE_FLAGS_ARRAY;
-		if (mono_underlying_type->type == MONO_TYPE_ARRAY) {
-			uint32_t rank = mono_array_type->rank;
-			if (rank < TYPE_FLAGS_ARRAY_RANK_MAX) {
-				rank <<= 8;
-				val->fixed_sized_data.flags |= rank;
-			}
-		}
-		val->mono_type_parameters = mono_mempool_alloc0 (type_logger->mem_pool, 1 * sizeof (MonoType*));
-		*val->mono_type_parameters = m_class_get_byval_arg (mono_array_type->eklass);
-		val->type_parameters_count++;
-		break;
-	}
-	case MONO_TYPE_GENERICINST:
-	{
-		MonoGenericInst *class_inst = mono_type->data.generic_class->context.class_inst;
-		val->type_parameters_count = class_inst->type_argc;
-		val->mono_type_parameters = mono_mempool_alloc0 (type_logger->mem_pool, val->type_parameters_count * sizeof (MonoType*));
-		memcpy (val->mono_type_parameters, class_inst->type_argv, val->type_parameters_count * sizeof (MonoType*));
-		break;
-	}
-	case MONO_TYPE_CLASS:
-	case MONO_TYPE_VALUETYPE:
-	case MONO_TYPE_PTR:
-	case MONO_TYPE_BYREF:
-	{
-		if (mono_underlying_type == mono_type)
-			break;
-		val->mono_type_parameters = mono_mempool_alloc0 (type_logger->mem_pool, 1 * sizeof (MonoType*));
-		*val->mono_type_parameters = mono_underlying_type;
-		val->type_parameters_count++;
-		break;
-	}
-	default:
-		break;
-	}
-	int val_byte_count = ep_rt_mono_get_byte_count_in_event (val);
-	if (val_byte_count > MAX_TYPE_VALUES_BYTES) {
-		mono_trace (G_LOG_LEVEL_ERROR, MONO_TRACE_DIAGNOSTICS, "Failed to log single mono type %p with typeID %llu. Type is too large for the BulkType Event.\n", (gpointer)mono_type, (unsigned long long)val->fixed_sized_data.type_id);
-		return -1;
-	}
-	if (type_logger->bulk_type_value_byte_count + val_byte_count > MAX_TYPE_VALUES_BYTES) {
-		g_assert (type_logger->bulk_type_value_byte_count + val_byte_count > MAX_TYPE_VALUES_BYTES);
-		ep_rt_mono_fire_bulk_type_event (type_logger);
-		return ep_rt_mono_log_single_type (type_logger, mono_type);
-	}
-	type_logger->bulk_type_value_count++;
-	type_logger->bulk_type_value_byte_count += val_byte_count;
-	return type_logger->bulk_type_value_count - 1;
-}
-void
-ep_rt_mono_log_type_and_parameters (
-	BulkTypeEventLogger *type_logger,
-	MonoType *mono_type)
-{
-	int bulk_type_value_index = ep_rt_mono_log_single_type (type_logger, mono_type);
-	if (bulk_type_value_index == -1) {
-		return;
-	}
-	BulkTypeValue *val = &type_logger->bulk_type_values [bulk_type_value_index];
-	uint32_t param_count = val->type_parameters_count;
-	if (param_count == 0)
-		return;
-	MonoType **mono_type_parameters = mono_mempool_alloc0 (type_logger->mem_pool, param_count * sizeof (MonoType*));
-	memcpy (mono_type_parameters, val->mono_type_parameters, sizeof (MonoType*) * param_count);
-	for (uint32_t i = 0; i < param_count; i++)
-		ep_rt_mono_log_type_and_parameters_if_necessary (type_logger, mono_type_parameters [i]);
-}
-void
-ep_rt_mono_log_type_and_parameters_if_necessary (
-	BulkTypeEventLogger *type_logger,
-	MonoType *mono_type)
-{
-	ep_rt_mono_log_type_and_parameters (type_logger, mono_type);
-}
-static const uint32_t MAX_METHOD_TYPE_ARGUMENT_COUNT = 1024;
-void
-ep_rt_mono_send_method_details_event (MonoMethod *method)
-{
-	if (method->wrapper_type != MONO_WRAPPER_NONE || method->dynamic)
-		return;
-	MonoGenericContext *method_ctx = mono_method_get_context (method);
-	MonoGenericInst *method_inst = NULL;
-	if (method_ctx)
-		method_inst = method_ctx->method_inst;
-	if (method_inst && method_inst->type_argc > MAX_METHOD_TYPE_ARGUMENT_COUNT)
-		return;
-	BulkTypeEventLogger *type_logger = ep_rt_bulk_type_event_logger_alloc ();
-	uint64_t method_type_id = 0;
-	g_assert (mono_metadata_token_index (method->token) != 0);
-	uint32_t method_token = mono_metadata_make_token (MONO_TABLE_METHOD, mono_metadata_token_index (method->token));
-	uint64_t loader_module_id = 0;
-	MonoClass *klass = method->klass;
-	if (klass) {
-		MonoType *method_mono_type = m_class_get_byval_arg (klass);
-		method_type_id = get_typeid_for_class (klass);
-		ep_rt_mono_log_type_and_parameters_if_necessary (type_logger, method_mono_type);
-		loader_module_id = (uint64_t)mono_class_get_image (klass);
-	}
-	uint32_t method_inst_parameter_types_count = 0;
-	if (method_inst)
-		method_inst_parameter_types_count = method_inst->type_argc;
-	uint64_t *method_inst_parameters_type_ids = mono_mempool_alloc0 (type_logger->mem_pool, method_inst_parameter_types_count * sizeof (uint64_t));
-	for (uint32_t i = 0; i < method_inst_parameter_types_count; i++) {
-		method_inst_parameters_type_ids [i] = get_typeid_for_type (method_inst->type_argv [i]);
-		ep_rt_mono_log_type_and_parameters_if_necessary (type_logger, method_inst->type_argv [i]);
-	}
-	ep_rt_mono_fire_bulk_type_event (type_logger);
-	FireEtwMethodDetails (
-		(uint64_t)method,
-		method_type_id,
-		method_token,
-		method_inst_parameter_types_count,
-		loader_module_id,
-		(uint64_t*)method_inst_parameters_type_ids,
-		NULL,
-		NULL);
-	ep_rt_bulk_type_event_logger_free (type_logger);
-}
-bool
-ep_rt_mono_write_event_jit_start (MonoMethod *method)
-{
-	if (!EventEnabledMethodJittingStarted_V1 ())
-		return true;
-	if (method) {
-		uint64_t method_id = 0;
-		uint64_t module_id = 0;
-		uint32_t code_size = 0;
-		uint32_t method_token = 0;
-		char *method_namespace = NULL;
-		const char *method_name = NULL;
-		char *method_signature = NULL;
-		ep_rt_mono_send_method_details_event(method);
-		method_id = (uint64_t)method;
-		if (!method->dynamic)
-			method_token = method->token;
-		if (!mono_method_has_no_body (method)) {
-			ERROR_DECL (error);
-			MonoMethodHeader *header = mono_method_get_header_internal (method, error);
-			if (header)
-				code_size = header->code_size;
-		}
-		method_name = method->name;
-		method_signature = mono_signature_full_name (mono_method_signature_internal (method));
-		if (method->klass) {
-			module_id = (uint64_t)m_class_get_image (method->klass);
-			method_namespace = mono_type_get_name_full (m_class_get_byval_arg (method->klass), MONO_TYPE_NAME_FORMAT_IL);
-		}
-		FireEtwMethodJittingStarted_V1 (
-			method_id,
-			module_id,
-			method_token,
-			code_size,
-			method_namespace,
-			method_name,
-			method_signature,
-			clr_instance_get_id (),
-			NULL,
-			NULL);
-		g_free (method_namespace);
-		g_free (method_signature);
-	}
-	return true;
-}
-bool
-ep_rt_mono_write_event_method_il_to_native_map (
-	MonoMethod *method,
-	MonoJitInfo *ji)
-{
-	if (!EventEnabledMethodILToNativeMap ())
-		return true;
-	if (method) {
-		MonoDomain *root_domain = mono_get_root_domain ();
-		uint64_t method_id = (uint64_t)method;
-		uint32_t fixed_buffer [64];
-		uint8_t *buffer = NULL;
-		uint32_t offset_entries = 0;
-		uint32_t *il_offsets = NULL;
-		uint32_t *native_offsets = NULL;
-		MonoDebugMethodJitInfo *debug_info = method ? mono_debug_find_method (method, root_domain) : NULL;
-		if (debug_info) {
-			offset_entries = debug_info->num_line_numbers;
-			if (offset_entries != 0) {
-				size_t needed_size = (offset_entries * sizeof (uint32_t) * 2);
-				if (needed_size > sizeof (fixed_buffer)) {
-					buffer = g_new (uint8_t, needed_size);
-					il_offsets = (uint32_t*)buffer;
-				} else {
-					il_offsets = fixed_buffer;
-				}
-				if (il_offsets) {
-					native_offsets = il_offsets + offset_entries;
-					for (uint32_t offset_count = 0; offset_count < offset_entries; ++offset_count) {
-						il_offsets [offset_count] = debug_info->line_numbers [offset_count].il_offset;
-						native_offsets [offset_count] = debug_info->line_numbers [offset_count].native_offset;
-					}
-				}
-			}
-			mono_debug_free_method_jit_info (debug_info);
-		}
-		if (!il_offsets && !native_offsets) {
-			EP_ASSERT (sizeof (fixed_buffer) >= sizeof (uint32_t) * 2);
-			offset_entries = 1;
-			il_offsets = fixed_buffer;
-			native_offsets = il_offsets + offset_entries;
-			il_offsets [0] = 0;
-			native_offsets [0] = ji ? (uint32_t)ji->code_size : 0;
-		}
-		FireEtwMethodILToNativeMap (
-			method_id,
-			0,
-			0,
-			GUINT32_TO_UINT16 (offset_entries),
-			il_offsets,
-			native_offsets,
-			clr_instance_get_id (),
-			NULL,
-			NULL);
-		g_free (buffer);
-	}
-	return true;
-}
-bool
-ep_rt_mono_write_event_method_load (
-	MonoMethod *method,
-	MonoJitInfo *ji)
-{
-	if (!EventEnabledMethodLoad_V1 () && !EventEnabledMethodLoadVerbose_V1 ())
-		return true;
-	if (method) {
-		uint64_t method_id = 0;
-		uint64_t module_id = 0;
-		uint64_t method_code_start = ji ? (uint64_t)ji->code_start : 0;
-		uint32_t method_code_size = ji ? (uint32_t)ji->code_size : 0;
-		uint32_t method_token = 0;
-		uint32_t method_flags = 0;
-		uint8_t kind = MONO_CLASS_DEF;
-		char *method_namespace = NULL;
-		const char *method_name = NULL;
-		char *method_signature = NULL;
-		bool verbose = (MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_EVENTPIPE_Context.Level >= (uint8_t)EP_EVENT_LEVEL_VERBOSE);
-		method_id = (uint64_t)method;
-		if (!method->dynamic)
-			method_token = method->token;
-		if (ji && mono_jit_info_get_generic_sharing_context (ji)) {
-			method_flags |= METHOD_FLAGS_SHARED_GENERIC_METHOD;
-			verbose = true;
-		}
-		if (method->dynamic) {
-			method_flags |= METHOD_FLAGS_DYNAMIC_METHOD;
-			verbose = true;
-		}
-		if (ji && !ji->from_aot && !ji->from_llvm) {
-			method_flags |= METHOD_FLAGS_JITTED_METHOD;
-			if (method->wrapper_type != MONO_WRAPPER_NONE)
-				method_flags |= METHOD_FLAGS_JITTED_HELPER_METHOD;
-		}
-		if (method->is_generic || method->is_inflated) {
-			method_flags |= METHOD_FLAGS_GENERIC_METHOD;
-			verbose = true;
-		}
-		if (method->klass) {
-			module_id = (uint64_t)m_class_get_image (method->klass);
-			kind = m_class_get_class_kind (method->klass);
-			if (kind == MONO_CLASS_GTD || kind == MONO_CLASS_GINST)
-				method_flags |= METHOD_FLAGS_GENERIC_METHOD;
-		}
-		ep_rt_mono_send_method_details_event(method);
-		if (verbose) {
-			method_name = method->name;
-			method_signature = mono_signature_full_name (mono_method_signature_internal (method));
-			if (method->klass)
-				method_namespace = mono_type_get_name_full (m_class_get_byval_arg (method->klass), MONO_TYPE_NAME_FORMAT_IL);
-			FireEtwMethodLoadVerbose_V1 (
-				method_id,
-				module_id,
-				method_code_start,
-				method_code_size,
-				method_token,
-				method_flags | METHOD_FLAGS_EXTENT_HOT_SECTION,
-				method_namespace,
-				method_name,
-				method_signature,
-				clr_instance_get_id (),
-				NULL,
-				NULL);
-			if (ji && (ji->from_aot || ji->from_llvm))
-				FireEtwMethodLoadVerbose_V1 (
-					method_id,
-					module_id,
-					method_code_start,
-					method_code_size,
-					method_token,
-					method_flags | METHOD_FLAGS_EXTENT_COLD_SECTION,
-					method_namespace,
-					method_name,
-					method_signature,
-					clr_instance_get_id (),
-					NULL,
-					NULL);
-		} else {
-			FireEtwMethodLoad_V1 (
-				method_id,
-				module_id,
-				method_code_start,
-				method_code_size,
-				method_token,
-				method_flags | METHOD_FLAGS_EXTENT_HOT_SECTION,
-				clr_instance_get_id (),
-				NULL,
-				NULL);
-			if (ji && (ji->from_aot || ji->from_llvm))
-				FireEtwMethodLoad_V1 (
-					method_id,
-					module_id,
-					method_code_start,
-					method_code_size,
-					method_token,
-					method_flags | METHOD_FLAGS_EXTENT_COLD_SECTION,
-					clr_instance_get_id (),
-					NULL,
-					NULL);
-		}
-		g_free (method_namespace);
-		g_free (method_signature);
-	}
-	return true;
-}
-static
-bool
-get_module_event_data (
-	MonoImage *image,
-	ModuleEventData *module_data)
-{
-	if (module_data) {
-		memset (module_data->module_il_pdb_signature, 0, EP_GUID_SIZE);
-		memset (module_data->module_native_pdb_signature, 0, EP_GUID_SIZE);
-		MonoDomain *root_domain = mono_get_root_domain ();
-		module_data->domain_id = (uint64_t)root_domain;
-		module_data->module_id = (uint64_t)image;
-		module_data->assembly_id = image ? (uint64_t)image->assembly : 0;
-		module_data->module_native_path = "";
-		module_data->module_native_pdb_path = "";
-		module_data->module_native_pdb_age = 0;
-		module_data->reserved_flags = 0;
-		module_data->module_flags = MODULE_FLAGS_MANIFEST_MODULE;
-		if (image && image->dynamic)
-			module_data->module_flags |= MODULE_FLAGS_DYNAMIC_MODULE;
-		if (image && image->aot_module)
-			module_data->module_flags |= MODULE_FLAGS_NATIVE_MODULE;
-		module_data->module_il_path = NULL;
-		if (image && image->filename) {
-			/* if there's a filename, use it */
-			module_data->module_il_path = image->filename;
-		} else if (image && image->module_name) {
-			/* otherwise, use the module name */
-			module_data->module_il_path = image->module_name;
-		}
-		if (!module_data->module_il_path)
-			module_data->module_il_path = "";
-		module_data->module_il_pdb_path = "";
-		module_data->module_il_pdb_age = 0;
-		if (image && image->image_info) {
-			MonoPEDirEntry *debug_dir_entry = (MonoPEDirEntry *)&image->image_info->cli_header.datadir.pe_debug;
-			if (debug_dir_entry->size) {
-				ImageDebugDirectory debug_dir;
-				memset (&debug_dir, 0, sizeof (debug_dir));
-				uint32_t offset = mono_cli_rva_image_map (image, debug_dir_entry->rva);
-				for (uint32_t idx = 0; idx < debug_dir_entry->size / sizeof (ImageDebugDirectory); ++idx) {
-					uint8_t *data = (uint8_t *) ((ImageDebugDirectory *) (image->raw_data + offset) + idx);
-					debug_dir.major_version = read16 (data + 8);
-					debug_dir.minor_version = read16 (data + 10);
-					debug_dir.type = read32 (data + 12);
-					debug_dir.pointer = read32 (data + 24);
-					if (debug_dir.type == DEBUG_DIR_ENTRY_CODEVIEW && debug_dir.major_version == 0x100 && debug_dir.minor_version == 0x504d) {
-						data  = (uint8_t *)(image->raw_data + debug_dir.pointer);
-						int32_t signature = read32 (data);
-						if (signature == 0x53445352) {
-							memcpy (module_data->module_il_pdb_signature, data + 4, EP_GUID_SIZE);
-							module_data->module_il_pdb_age = read32 (data + 20);
-							module_data->module_il_pdb_path = (const char *)(data + 24);
-							break;
-						}
-					}
-				}
-			}
-		}
-	}
-	return true;
-}
-bool
-ep_rt_mono_write_event_module_load (MonoImage *image)
-{
-	if (!EventEnabledModuleLoad_V2 () && !EventEnabledDomainModuleLoad_V1 ())
-		return true;
-	if (image) {
-		ModuleEventData module_data;
-		memset (&module_data, 0, sizeof (module_data));
-		if (get_module_event_data (image, &module_data)) {
-			FireEtwModuleLoad_V2 (
-				module_data.module_id,
-				module_data.assembly_id,
-				module_data.module_flags,
-				module_data.reserved_flags,
-				module_data.module_il_path,
-				module_data.module_native_path,
-				clr_instance_get_id (),
-				module_data.module_il_pdb_signature,
-				module_data.module_il_pdb_age,
-				module_data.module_il_pdb_path,
-				module_data.module_native_pdb_signature,
-				module_data.module_native_pdb_age,
-				module_data.module_native_pdb_path,
-				NULL,
-				NULL);
-			FireEtwDomainModuleLoad_V1 (
-				module_data.module_id,
-				module_data.assembly_id,
-				module_data.domain_id,
-				module_data.module_flags,
-				module_data.reserved_flags,
-				module_data.module_il_path,
-				module_data.module_native_path,
-				clr_instance_get_id (),
-				NULL,
-				NULL);
-		}
-	}
-	return true;
-}
-bool
-ep_rt_mono_write_event_module_unload (MonoImage *image)
-{
-	if (!EventEnabledModuleUnload_V2())
-		return true;
-	if (image) {
-		ModuleEventData module_data;
-		memset (&module_data, 0, sizeof (module_data));
-		if (get_module_event_data (image, &module_data)) {
-			FireEtwModuleUnload_V2 (
-				module_data.module_id,
-				module_data.assembly_id,
-				module_data.module_flags,
-				module_data.reserved_flags,
-				module_data.module_il_path,
-				module_data.module_native_path,
-				clr_instance_get_id (),
-				module_data.module_il_pdb_signature,
-				module_data.module_il_pdb_age,
-				module_data.module_il_pdb_path,
-				module_data.module_native_pdb_signature,
-				module_data.module_native_pdb_age,
-				module_data.module_native_pdb_path,
-				NULL,
-				NULL);
-		}
-	}
-	return true;
-}
-static
-bool
-get_assembly_event_data (
-	MonoAssembly *assembly,
-	AssemblyEventData *assembly_data)
-{
-	if (assembly && assembly_data) {
-		MonoDomain *root_domain = mono_get_root_domain ();
-		assembly_data->domain_id = (uint64_t)root_domain;
-		assembly_data->assembly_id = (uint64_t)assembly;
-		assembly_data->binding_id = 0;
-		assembly_data->assembly_flags = 0;
-		if (assembly->dynamic)
-			assembly_data->assembly_flags |= ASSEMBLY_FLAGS_DYNAMIC_ASSEMBLY;
-		if (assembly->image && assembly->image->aot_module)
-			assembly_data->assembly_flags |= ASSEMBLY_FLAGS_NATIVE_ASSEMBLY;
-		assembly_data->assembly_name = mono_stringify_assembly_name (&assembly->aname);
-	}
-	return true;
-}
-bool
-ep_rt_mono_write_event_assembly_load (MonoAssembly *assembly)
-{
-	if (!EventEnabledAssemblyLoad_V1 ())
-		return true;
-	if (assembly) {
-		AssemblyEventData assembly_data;
-		memset (&assembly_data, 0, sizeof (assembly_data));
-		if (get_assembly_event_data (assembly, &assembly_data)) {
-			FireEtwAssemblyLoad_V1 (
-				assembly_data.assembly_id,
-				assembly_data.domain_id,
-				assembly_data.binding_id,
-				assembly_data.assembly_flags,
-				assembly_data.assembly_name,
-				clr_instance_get_id (),
-				NULL,
-				NULL);
-			g_free (assembly_data.assembly_name);
-		}
-	}
-	return true;
-}
-bool
-ep_rt_mono_write_event_assembly_unload (MonoAssembly *assembly)
-{
-	if (!EventEnabledAssemblyUnload_V1 ())
-		return true;
-	if (assembly) {
-		AssemblyEventData assembly_data;
-		memset (&assembly_data, 0, sizeof (assembly_data));
-		if (get_assembly_event_data (assembly, &assembly_data)) {
-			FireEtwAssemblyUnload_V1 (
-				assembly_data.assembly_id,
-				assembly_data.domain_id,
-				assembly_data.binding_id,
-				assembly_data.assembly_flags,
-				assembly_data.assembly_name,
-				clr_instance_get_id (),
-				NULL,
-				NULL);
-			g_free (assembly_data.assembly_name);
-		}
-	}
-	return true;
-}
-bool
-ep_rt_mono_write_event_thread_created (ep_rt_thread_id_t tid)
-{
-	if (!EventEnabledThreadCreated ())
-		return true;
-	uint64_t managed_thread = 0;
-	uint32_t native_thread_id = MONO_NATIVE_THREAD_ID_TO_UINT (tid);
-	uint32_t managed_thread_id = 0;
-	uint32_t flags = 0;
-	MonoThread *thread = mono_thread_current ();
-	if (thread && mono_thread_info_get_tid (thread->thread_info) == tid) {
-		managed_thread_id = mono_thread_get_managed_id (thread);
-		managed_thread = (uint64_t)thread;
-		switch (mono_thread_info_get_flags (thread->thread_info)) {
-		case MONO_THREAD_INFO_FLAGS_NO_GC:
-		case MONO_THREAD_INFO_FLAGS_NO_SAMPLE:
-			flags |= THREAD_FLAGS_GC_SPECIAL;
-		}
-		if (mono_gc_is_finalizer_thread (thread))
-			flags |= THREAD_FLAGS_FINALIZER;
-		if (thread->threadpool_thread)
-			flags |= THREAD_FLAGS_THREADPOOL_WORKER;
-	}
-	FireEtwThreadCreated (
-		managed_thread,
-		(uint64_t)mono_get_root_domain (),
-		flags,
-		managed_thread_id,
-		native_thread_id,
-		clr_instance_get_id (),
-		NULL,
-		NULL);
-	return true;
-}
-bool
-ep_rt_mono_write_event_thread_terminated (ep_rt_thread_id_t tid)
-{
-	if (!EventEnabledThreadTerminated ())
-		return true;
-	uint64_t managed_thread = 0;
-	MonoThread *thread = mono_thread_current ();
-	if (thread && mono_thread_info_get_tid (thread->thread_info) == tid)
-		managed_thread = (uint64_t)thread;
-	FireEtwThreadTerminated (
-		managed_thread,
-		(uint64_t)mono_get_root_domain (),
-		clr_instance_get_id (),
-		NULL,
-		NULL);
-	return true;
-}
-static
-uint32_t
-get_type_start_id (MonoType *type)
-{
-	uint32_t start_id = (uint32_t)(uintptr_t)type;
-	start_id = (((start_id * 215497) >> 16) ^ ((start_id * 1823231) + start_id));
-MONO_DISABLE_WARNING(4127) /* conditional expression is constant */
-	if (sizeof (type) > 4)
-		start_id = start_id ^ GUINT64_TO_UINT32 ((((uint64_t)type >> 31) >> 1));
-MONO_RESTORE_WARNING
-	return start_id;
-}
-bool
-ep_rt_mono_write_event_type_load_start (MonoType *type)
-{
-	if (!EventEnabledTypeLoadStart ())
-		return true;
-	FireEtwTypeLoadStart (
-		get_type_start_id (type),
-		clr_instance_get_id (),
-		NULL,
-		NULL);
-	return true;
-}
-bool
-ep_rt_mono_write_event_type_load_stop (MonoType *type)
-{
-	if (!EventEnabledTypeLoadStop ())
-		return true;
-	char *type_name = NULL;
-	if (type)
-		type_name = mono_type_get_name_full (type, MONO_TYPE_NAME_FORMAT_IL);
-	FireEtwTypeLoadStop (
-		get_type_start_id (type),
-		clr_instance_get_id (),
-		6 /* CLASS_LOADED */,
-		(uint64_t)type,
-		type_name,
-		NULL,
-		NULL);
-	g_free (type_name);
-	return true;
-}
-static
-gboolean
-get_exception_ip_func (
-	MonoStackFrameInfo *frame,
-	MonoContext *ctx,
-	void *data)
-{
-	*(uintptr_t *)data = (uintptr_t)MONO_CONTEXT_GET_IP (ctx);
-	return TRUE;
-}
-bool
-ep_rt_mono_write_event_exception_thrown (MonoObject *obj)
-{
-	if (!EventEnabledExceptionThrown_V1 ())
-		return true;
-	if (obj) {
-		ERROR_DECL (error);
-		char *type_name = NULL;
-		char *exception_message = NULL;
-		uint16_t flags = 0;
-		uint32_t hresult = 0;
-		uintptr_t ip = 0;
-		if (mono_object_isinst_checked ((MonoObject *) obj, mono_get_exception_class (), error)) {
-			MonoException *exception = (MonoException *)obj;
-			flags |= EXCEPTION_THROWN_FLAGS_IS_CLS_COMPLIANT;
-			if (exception->inner_ex)
-				flags |= EXCEPTION_THROWN_FLAGS_HAS_INNER;
-			if (exception->message)
-				exception_message = ep_rt_utf16_to_utf8_string (mono_string_chars_internal (exception->message), mono_string_length_internal (exception->message));
-			hresult = exception->hresult;
-		}
-		if (exception_message == NULL)
-			exception_message = g_strdup ("");
-		if (mono_get_eh_callbacks ()->mono_walk_stack_with_ctx)
-			mono_get_eh_callbacks ()->mono_walk_stack_with_ctx (get_exception_ip_func, NULL, MONO_UNWIND_SIGNAL_SAFE, (void *)&ip);
-		type_name = mono_type_get_name_full (m_class_get_byval_arg (mono_object_class (obj)), MONO_TYPE_NAME_FORMAT_IL);
-		FireEtwExceptionThrown_V1 (
-			type_name,
-			exception_message,
-			(void *)&ip,
-			hresult,
-			flags,
-			clr_instance_get_id (),
-			NULL,
-			NULL);
-		if (!mono_component_profiler_clauses_enabled ()) {
-			FireEtwExceptionThrownStop (
-				NULL,
-				NULL);
-		}
-		g_free (exception_message);
-		g_free (type_name);
-		mono_error_cleanup (error);
-	}
-	return true;
-}
-bool
-ep_rt_mono_write_event_exception_clause (
-	MonoMethod *method,
-	uint32_t clause_num,
-	MonoExceptionEnum clause_type,
-	MonoObject *obj)
-{
-	if (!mono_component_profiler_clauses_enabled ())
-		return true;
-	if ((clause_type == MONO_EXCEPTION_CLAUSE_FAULT || clause_type == MONO_EXCEPTION_CLAUSE_NONE) && (!EventEnabledExceptionCatchStart() || !EventEnabledExceptionCatchStop()))
-		return true;
-	if (clause_type == MONO_EXCEPTION_CLAUSE_FILTER && (!EventEnabledExceptionFilterStart() || !EventEnabledExceptionFilterStop()))
-		return true;
-	if (clause_type == MONO_EXCEPTION_CLAUSE_FINALLY && (!EventEnabledExceptionFinallyStart() || !EventEnabledExceptionFinallyStop()))
-		return true;
-	uintptr_t ip = 0; //TODO: Have profiler pass along IP of handler block.
-	uint64_t method_id = (uint64_t)method;
-	char *method_name = NULL;
-	method_name = mono_method_get_name_full (method, TRUE, TRUE, MONO_TYPE_NAME_FORMAT_IL);
-	if ((clause_type == MONO_EXCEPTION_CLAUSE_FAULT || clause_type == MONO_EXCEPTION_CLAUSE_NONE)) {
-		FireEtwExceptionCatchStart (
-			(uint64_t)ip,
-			method_id,
-			(const ep_char8_t *)method_name,
-			clr_instance_get_id (),
-			NULL,
-			NULL);
-		FireEtwExceptionCatchStop (
-			NULL,
-			NULL);
-		FireEtwExceptionThrownStop (
-			NULL,
-			NULL);
-	}
-	if (clause_type == MONO_EXCEPTION_CLAUSE_FILTER) {
-		FireEtwExceptionFilterStart (
-			(uint64_t)ip,
-			method_id,
-			(const ep_char8_t *)method_name,
-			clr_instance_get_id (),
-			NULL,
-			NULL);
-		FireEtwExceptionFilterStop (
-			NULL,
-			NULL);
-	}
-	if (clause_type == MONO_EXCEPTION_CLAUSE_FINALLY) {
-		FireEtwExceptionFinallyStart (
-			(uint64_t)ip,
-			method_id,
-			(const ep_char8_t *)method_name,
-			clr_instance_get_id (),
-			NULL,
-			NULL);
-		FireEtwExceptionFinallyStop (
-			NULL,
-			NULL);
-	}
-	g_free (method_name);
-	return true;
-}
-bool
-ep_rt_mono_write_event_monitor_contention_start (MonoObject *obj)
-{
-	if (!EventEnabledContentionStart_V1 ())
-		return true;
-	FireEtwContentionStart_V1 (
-		0 /* ManagedContention */,
-		clr_instance_get_id (),
-		NULL,
-		NULL);
-	return true;
-}
-bool
-ep_rt_mono_write_event_monitor_contention_stop (MonoObject *obj)
-{
-	if (!EventEnabledContentionStop ())
-		return true;
-	FireEtwContentionStop (
-		0 /* ManagedContention */,
-		clr_instance_get_id (),
-		NULL,
-		NULL);
-	return true;
-}
-bool
-ep_rt_mono_write_event_method_jit_memory_allocated_for_code (
-	const uint8_t *buffer,
-	uint64_t size,
-	MonoProfilerCodeBufferType type,
-	const void *data)
-{
-	if (!EventEnabledMethodJitMemoryAllocatedForCode ())
-		return true;
-	if (type != MONO_PROFILER_CODE_BUFFER_METHOD)
-		return true;
-	uint64_t method_id = 0;
-	uint64_t module_id = 0;
-	if (data) {
-		MonoMethod *method;
-		method = (MonoMethod *)data;
-		method_id = (uint64_t)method;
-		if (method->klass)
-			module_id = (uint64_t)(uint64_t)m_class_get_image (method->klass);
-	}
-	FireEtwMethodJitMemoryAllocatedForCode (
-		method_id,
-		module_id,
-		size,
-		0,
-		size,
-		0 /* CORJIT_ALLOCMEM_DEFAULT_CODE_ALIGN */,
-		clr_instance_get_id (),
-		NULL,
-		NULL);
-	return true;
-}
-bool
-ep_rt_write_event_threadpool_worker_thread_start (
-	uint32_t active_thread_count,
-	uint32_t retired_worker_thread_count,
-	uint16_t clr_instance_id)
-{
-	return FireEtwThreadPoolWorkerThreadStart (
-		active_thread_count,
-		retired_worker_thread_count,
-		clr_instance_id,
-		NULL,
-		NULL) == 0 ? true : false;
-}
-bool
-ep_rt_write_event_threadpool_worker_thread_stop (
-	uint32_t active_thread_count,
-	uint32_t retired_worker_thread_count,
-	uint16_t clr_instance_id)
-{
-	return FireEtwThreadPoolWorkerThreadStop (
-		active_thread_count,
-		retired_worker_thread_count,
-		clr_instance_id,
-		NULL,
-		NULL) == 0 ? true : false;
-}
-bool
-ep_rt_write_event_threadpool_worker_thread_wait (
-	uint32_t active_thread_count,
-	uint32_t retired_worker_thread_count,
-	uint16_t clr_instance_id)
-{
-	return FireEtwThreadPoolWorkerThreadWait (
-		active_thread_count,
-		retired_worker_thread_count,
-		clr_instance_id,
-		NULL,
-		NULL) == 0 ? true : false;
-}
-bool
-ep_rt_write_event_threadpool_min_max_threads (
-	uint16_t min_worker_threads,
-	uint16_t max_worker_threads,
-	uint16_t min_io_completion_threads,
-	uint16_t max_io_completion_threads,
-	uint16_t clr_instance_id)
-{
-	return FireEtwThreadPoolMinMaxThreads (
-		min_worker_threads,
-		max_worker_threads,
-		min_io_completion_threads,
-		max_io_completion_threads,
-		clr_instance_id,
-		NULL,
-		NULL) == 0 ? true : false;
-}
-bool
-ep_rt_write_event_threadpool_worker_thread_adjustment_sample (
-	double throughput,
-	uint16_t clr_instance_id)
-{
-	return FireEtwThreadPoolWorkerThreadAdjustmentSample (
-		throughput,
-		clr_instance_id,
-		NULL,
-		NULL) == 0 ? true : false;
-}
-bool
-ep_rt_write_event_threadpool_worker_thread_adjustment_adjustment (
-	double average_throughput,
-	uint32_t networker_thread_count,
-	/*NativeRuntimeEventSource.ThreadAdjustmentReasonMap*/ int32_t reason,
-	uint16_t clr_instance_id)
-{
-	return FireEtwThreadPoolWorkerThreadAdjustmentAdjustment (
-		average_throughput,
-		networker_thread_count,
-		reason,
-		clr_instance_id,
-		NULL,
-		NULL) == 0 ? true : false;
-}
-bool
-ep_rt_write_event_threadpool_worker_thread_adjustment_stats (
-	double duration,
-	double throughput,
-	double threadpool_worker_thread_wait,
-	double throughput_wave,
-	double throughput_error_estimate,
-	double average_throughput_error_estimate,
-	double throughput_ratio,
-	double confidence,
-	double new_control_setting,
-	uint16_t new_thread_wave_magnitude,
-	uint16_t clr_instance_id)
-{
-	return FireEtwThreadPoolWorkerThreadAdjustmentStats (
-		duration,
-		throughput,
-		threadpool_worker_thread_wait,
-		throughput_wave,
-		throughput_error_estimate,
-		average_throughput_error_estimate,
-		throughput_ratio,
-		confidence,
-		new_control_setting,
-		new_thread_wave_magnitude,
-		clr_instance_id,
-		NULL,
-		NULL) == 0 ? true : false;
-}
-bool
-ep_rt_write_event_threadpool_io_enqueue (
-	intptr_t native_overlapped,
-	intptr_t overlapped,
-	bool multi_dequeues,
-	uint16_t clr_instance_id)
-{
-	return FireEtwThreadPoolIOEnqueue (
-		(const void *)native_overlapped,
-		(const void *)overlapped,
-		multi_dequeues,
-		clr_instance_id,
-		NULL,
-		NULL) == 0 ? true : false;
-}
-bool
-ep_rt_write_event_threadpool_io_dequeue (
-	intptr_t native_overlapped,
-	intptr_t overlapped,
-	uint16_t clr_instance_id)
-{
-	return FireEtwThreadPoolIODequeue (
-		(const void *)native_overlapped,
-		(const void *)overlapped,
-		clr_instance_id,
-		NULL,
-		NULL) == 0 ? true : false;
-}
-bool
-ep_rt_write_event_threadpool_working_thread_count (
-	uint16_t count,
-	uint16_t clr_instance_id)
-{
-	return FireEtwThreadPoolWorkingThreadCount (
-		count,
-		clr_instance_id,
-		NULL,
-		NULL) == 0 ? true : false;
-}
-bool
-ep_rt_write_event_threadpool_io_pack (
-	intptr_t native_overlapped,
-	intptr_t overlapped,
-	uint16_t clr_instance_id)
-{
-	return FireEtwThreadPoolIOPack (
-		(const void *)native_overlapped,
-		(const void *)overlapped,
-		clr_instance_id,
-		NULL,
-		NULL) == 0 ? true : false;
-}
-static
-void
-runtime_profiler_jit_begin (
-	MonoProfiler *prof,
-	MonoMethod *method)
-{
-	ep_rt_mono_write_event_jit_start (method);
-}
-static
-void
-runtime_profiler_jit_failed (
-	MonoProfiler *prof,
-	MonoMethod *method)
-{
-}
-static
-void
-runtime_profiler_jit_done (
-	MonoProfiler *prof,
-	MonoMethod *method,
-	MonoJitInfo *ji)
-{
-	ep_rt_mono_write_event_method_load (method, ji);
-	ep_rt_mono_write_event_method_il_to_native_map (method, ji);
-}
-static
-void
-runtime_profiler_image_loaded (
-	MonoProfiler *prof,
-	MonoImage *image)
-{
-	if (image && image->heap_pdb.size == 0)
-		ep_rt_mono_write_event_module_load (image);
-}
-static
-void
-runtime_profiler_image_unloaded (
-	MonoProfiler *prof,
-	MonoImage *image)
-{
-	if (image && image->heap_pdb.size == 0)
-		ep_rt_mono_write_event_module_unload (image);
-}
-static
-void
-runtime_profiler_assembly_loaded (
-	MonoProfiler *prof,
-	MonoAssembly *assembly)
-{
-	ep_rt_mono_write_event_assembly_load (assembly);
-}
-static
-void
-runtime_profiler_assembly_unloaded (
-	MonoProfiler *prof,
-	MonoAssembly *assembly)
-{
-	ep_rt_mono_write_event_assembly_unload (assembly);
-}
-static
-void
-runtime_profiler_thread_started (
-	MonoProfiler *prof,
-	uintptr_t tid)
-{
-	ep_rt_mono_write_event_thread_created (ep_rt_uint64_t_to_thread_id_t (tid));
-}
-static
-void
-runtime_profiler_thread_stopped (
-	MonoProfiler *prof,
-	uintptr_t tid)
-{
-	ep_rt_mono_write_event_thread_terminated (ep_rt_uint64_t_to_thread_id_t (tid));
-}
-static
-void
-runtime_profiler_class_loading (
-	MonoProfiler *prof,
-	MonoClass *klass)
-{
-	bool prevent_profiler_event_recursion = FALSE;
-	EventPipeThreadData *thread_data = eventpipe_thread_data_get_or_create ();
-	if (thread_data) {
-		prevent_profiler_event_recursion = thread_data->prevent_profiler_event_recursion;
-		thread_data->prevent_profiler_event_recursion = TRUE;
-	}
-	ep_rt_mono_write_event_type_load_start (m_class_get_byval_arg (klass));
-	if (thread_data)
-		thread_data->prevent_profiler_event_recursion = prevent_profiler_event_recursion;
-}
-static
-void
-runtime_profiler_class_failed (
-	MonoProfiler *prof,
-	MonoClass *klass)
-{
-	ep_rt_mono_write_event_type_load_stop (m_class_get_byval_arg (klass));
-}
-static
-void
-runtime_profiler_class_loaded (
-	MonoProfiler *prof,
-	MonoClass *klass)
-{
-	ep_rt_mono_write_event_type_load_stop (m_class_get_byval_arg (klass));
-}
-static
-void
-runtime_profiler_exception_throw (
-	MonoProfiler *prof,
-	MonoObject *exc)
-{
-	ep_rt_mono_write_event_exception_thrown (exc);
-}
-static
-void
-runtime_profiler_exception_clause (
-	MonoProfiler *prof,
-	MonoMethod *method,
-	uint32_t clause_num,
-	MonoExceptionEnum clause_type,
-	MonoObject *exc)
-{
-	ep_rt_mono_write_event_exception_clause (method, clause_num, clause_type, exc);
-}
-static
-void
-runtime_profiler_monitor_contention (
-	MonoProfiler *prof,
-	MonoObject *obj)
-{
-	ep_rt_mono_write_event_monitor_contention_start (obj);
-}
-static
-void
-runtime_profiler_monitor_acquired (
-	MonoProfiler *prof,
-	MonoObject *obj)
-{
-	ep_rt_mono_write_event_monitor_contention_stop (obj);
-}
-static
-void
-runtime_profiler_monitor_failed (
-	MonoProfiler *prof,
-	MonoObject *obj)
-{
-	ep_rt_mono_write_event_monitor_contention_stop (obj);
-}
-static
-void
-runtime_profiler_jit_code_buffer (
-	MonoProfiler *prof,
-	const mono_byte *buffer,
-	uint64_t size,
-	MonoProfilerCodeBufferType type,
-	const void *data)
-{
-	ep_rt_mono_write_event_method_jit_memory_allocated_for_code ((const uint8_t *)buffer, size, type, data);
-}
-void
-EventPipeEtwCallbackDotNETRuntime (
-	const uint8_t *source_id,
-	unsigned long is_enabled,
-	uint8_t level,
-	uint64_t match_any_keywords,
-	uint64_t match_all_keywords,
-	EventFilterDescriptor *filter_data,
-	void *callback_data)
-{
-	ep_rt_config_requires_lock_not_held ();
-	EP_ASSERT(is_enabled == 0 || is_enabled == 1) ;
-	EP_ASSERT (_ep_rt_dotnet_runtime_profiler_provider != NULL);
-	match_any_keywords = (is_enabled == 1) ? match_any_keywords : 0;
-	EP_LOCK_ENTER (section1)
-		uint64_t enabled_keywords = MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_EVENTPIPE_Context.EnabledKeywordsBitmask;
-		if (profiler_callback_is_enabled(match_any_keywords, JIT_KEYWORD)) {
-			if (!profiler_callback_is_enabled (enabled_keywords, JIT_KEYWORD)) {
-				mono_profiler_set_jit_begin_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_jit_begin);
-				mono_profiler_set_jit_failed_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_jit_failed);
-				mono_profiler_set_jit_done_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_jit_done);
-			}
-		} else {
-			if (profiler_callback_is_enabled (enabled_keywords, JIT_KEYWORD)) {
-				mono_profiler_set_jit_begin_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
-				mono_profiler_set_jit_failed_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
-				mono_profiler_set_jit_done_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
-			}
-		}
-		if (profiler_callback_is_enabled(match_any_keywords, LOADER_KEYWORD)) {
-			if (!profiler_callback_is_enabled(enabled_keywords, LOADER_KEYWORD)) {
-				mono_profiler_set_image_loaded_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_image_loaded);
-				mono_profiler_set_image_unloaded_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_image_unloaded);
-				mono_profiler_set_assembly_loaded_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_assembly_loaded);
-				mono_profiler_set_assembly_unloaded_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_assembly_unloaded);
-			}
-		} else {
-			if (profiler_callback_is_enabled (enabled_keywords, LOADER_KEYWORD)) {
-				mono_profiler_set_image_loaded_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
-				mono_profiler_set_image_unloaded_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
-				mono_profiler_set_assembly_loaded_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
-				mono_profiler_set_assembly_unloaded_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
-			}
-		}
-		if (profiler_callback_is_enabled(match_any_keywords, APP_DOMAIN_RESOURCE_MANAGEMENT_KEYWORD) || profiler_callback_is_enabled(match_any_keywords, THREADING_KEYWORD)) {
-			if (!(profiler_callback_is_enabled(enabled_keywords, APP_DOMAIN_RESOURCE_MANAGEMENT_KEYWORD) && profiler_callback_is_enabled(enabled_keywords, THREADING_KEYWORD))) {
-				mono_profiler_set_thread_started_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_thread_started);
-				mono_profiler_set_thread_stopped_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_thread_stopped);
-			}
-		} else {
-			if (profiler_callback_is_enabled (enabled_keywords, APP_DOMAIN_RESOURCE_MANAGEMENT_KEYWORD) || profiler_callback_is_enabled (enabled_keywords, THREADING_KEYWORD)) {
-				mono_profiler_set_thread_started_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
-				mono_profiler_set_thread_stopped_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
-			}
-		}
-		if (profiler_callback_is_enabled(match_any_keywords, TYPE_DIAGNOSTIC_KEYWORD)) {
-			if (!profiler_callback_is_enabled(enabled_keywords, TYPE_DIAGNOSTIC_KEYWORD)) {
-				mono_profiler_set_class_loading_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_class_loading);
-				mono_profiler_set_class_failed_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_class_failed);
-				mono_profiler_set_class_loaded_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_class_loaded);
-			}
-		} else {
-			if (profiler_callback_is_enabled (enabled_keywords, TYPE_DIAGNOSTIC_KEYWORD)) {
-				mono_profiler_set_class_loading_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
-				mono_profiler_set_class_failed_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
-				mono_profiler_set_class_loaded_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
-			}
-		}
-		if (profiler_callback_is_enabled(match_any_keywords, EXCEPTION_KEYWORD)) {
-			if (!profiler_callback_is_enabled(enabled_keywords, EXCEPTION_KEYWORD)) {
-				mono_profiler_set_exception_throw_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_exception_throw);
-				mono_profiler_set_exception_clause_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_exception_clause);
-			}
-		} else {
-			if (profiler_callback_is_enabled (enabled_keywords, EXCEPTION_KEYWORD)) {
-				mono_profiler_set_exception_throw_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
-				mono_profiler_set_exception_clause_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
-			}
-		}
-		if (profiler_callback_is_enabled(match_any_keywords, CONTENTION_KEYWORD)) {
-			if (!profiler_callback_is_enabled(enabled_keywords, CONTENTION_KEYWORD)) {
-				mono_profiler_set_monitor_contention_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_monitor_contention);
-				mono_profiler_set_monitor_acquired_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_monitor_acquired);
-				mono_profiler_set_monitor_failed_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_monitor_failed);
-			}
-		} else {
-			if (profiler_callback_is_enabled (enabled_keywords, CONTENTION_KEYWORD)) {
-				mono_profiler_set_monitor_contention_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
-				mono_profiler_set_monitor_acquired_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
-				mono_profiler_set_monitor_failed_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
-			}
-		}
-		MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_EVENTPIPE_Context.Level = level;
-		MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_EVENTPIPE_Context.EnabledKeywordsBitmask = match_any_keywords;
-		MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_EVENTPIPE_Context.IsEnabled = (is_enabled == 1 ? true : false);
-	EP_LOCK_EXIT (section1)
-ep_on_exit:
-	ep_rt_config_requires_lock_not_held ();
-	return;
-ep_on_error:
-	ep_exit_error_handler ();
-}
-void
-EventPipeEtwCallbackDotNETRuntimeRundown (
-	const uint8_t *source_id,
-	unsigned long is_enabled,
-	uint8_t level,
-	uint64_t match_any_keywords,
-	uint64_t match_all_keywords,
-	EventFilterDescriptor *filter_data,
-	void *callback_data)
-{
-	MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_EVENTPIPE_Context.Level = level;
-	MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_EVENTPIPE_Context.EnabledKeywordsBitmask = match_any_keywords;
-	MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_EVENTPIPE_Context.IsEnabled = (is_enabled == 1 ? true : false);
-}
-void
-EventPipeEtwCallbackDotNETRuntimePrivate (
-	const uint8_t *source_id,
-	unsigned long is_enabled,
-	uint8_t level,
-	uint64_t match_any_keywords,
-	uint64_t match_all_keywords,
-	EventFilterDescriptor *filter_data,
-	void *callback_data)
-{
-	MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_EVENTPIPE_Context.Level = level;
-	MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_EVENTPIPE_Context.EnabledKeywordsBitmask = match_any_keywords;
-	MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_EVENTPIPE_Context.IsEnabled = (is_enabled == 1 ? true : false);
-}
-void
-EventPipeEtwCallbackDotNETRuntimeStress (
-	const uint8_t *source_id,
-	unsigned long is_enabled,
-	uint8_t level,
-	uint64_t match_any_keywords,
-	uint64_t match_all_keywords,
-	EventFilterDescriptor *filter_data,
-	void *callback_data)
-{
-	MICROSOFT_WINDOWS_DOTNETRUNTIME_STRESS_PROVIDER_EVENTPIPE_Context.Level = level;
-	MICROSOFT_WINDOWS_DOTNETRUNTIME_STRESS_PROVIDER_EVENTPIPE_Context.EnabledKeywordsBitmask = match_any_keywords;
-	MICROSOFT_WINDOWS_DOTNETRUNTIME_STRESS_PROVIDER_EVENTPIPE_Context.IsEnabled = (is_enabled == 1 ? true : false);
-}
-static
-inline
-mono_profiler_gc_state_t
-mono_profiler_volatile_load_gc_state_t (const volatile mono_profiler_gc_state_t *ptr)
-{
-	return ep_rt_volatile_load_uint32_t ((const volatile uint32_t *)ptr);
-}
-static
-inline
-mono_profiler_gc_state_t
-mono_profiler_atomic_cas_gc_state_t (volatile mono_profiler_gc_state_t *target, mono_profiler_gc_state_t expected, mono_profiler_gc_state_t value)
-{
-	return (mono_profiler_gc_state_t)(mono_atomic_cas_i32 ((volatile gint32 *)(target), (gint32)(value), (gint32)(expected)));
-}
-static
-void
-mono_profiler_fire_event_enter (void)
-{
-	mono_profiler_gc_state_t old_state = 0;
-	mono_profiler_gc_state_t new_state = 0;
-	do {
-		old_state = mono_profiler_volatile_load_gc_state_t (&_ep_rt_mono_profiler_gc_state);
-		if (MONO_PROFILER_GC_STATE_IS_GC_IN_PROGRESS (old_state)) {
-			ep_rt_spin_lock_acquire (&_ep_rt_mono_profiler_gc_state_lock);
-			ep_rt_spin_lock_release (&_ep_rt_mono_profiler_gc_state_lock);
-			old_state = mono_profiler_volatile_load_gc_state_t (&_ep_rt_mono_profiler_gc_state);
-		}
-		new_state = MONO_PROFILER_GC_STATE_INC_FIRE_EVENT_COUNT (old_state);
-	} while (mono_profiler_atomic_cas_gc_state_t (&_ep_rt_mono_profiler_gc_state, old_state, new_state) != old_state);
-}
-static
-void
-mono_profiler_fire_event_exit (void)
-{
-	mono_profiler_gc_state_t old_state = 0;
-	mono_profiler_gc_state_t new_state = 0;
-	do {
-		old_state = mono_profiler_volatile_load_gc_state_t (&_ep_rt_mono_profiler_gc_state);
-		new_state = MONO_PROFILER_GC_STATE_DEC_FIRE_EVENT_COUNT (old_state);
-	} while (mono_profiler_atomic_cas_gc_state_t (&_ep_rt_mono_profiler_gc_state, old_state, new_state) != old_state);
-}
-static
-void
-mono_profiler_gc_in_progress_start (void)
-{
-	mono_profiler_gc_state_t old_state = 0;
-	mono_profiler_gc_state_t new_state = 0;
-	ep_rt_spin_lock_acquire (&_ep_rt_mono_profiler_gc_state_lock);
-	do {
-		old_state = mono_profiler_volatile_load_gc_state_t (&_ep_rt_mono_profiler_gc_state);
-		EP_ASSERT (!MONO_PROFILER_GC_STATE_IS_GC_IN_PROGRESS (old_state));
-		new_state = MONO_PROFILER_GC_STATE_GC_IN_PROGRESS_START (old_state);
-	} while (mono_profiler_atomic_cas_gc_state_t (&_ep_rt_mono_profiler_gc_state, old_state, new_state) != old_state);
-	mono_profiler_gc_state_count_t count = MONO_PROFILER_GC_STATE_GET_FIRE_EVENT_COUNT (new_state);
-	int yield_count = 40;
-	while (count) {
-		if (yield_count > 0) {
-			ep_rt_mono_thread_yield ();
-			yield_count--;
-		} else {
-			ep_rt_thread_sleep (200);
-		}
-		count = MONO_PROFILER_GC_STATE_GET_FIRE_EVENT_COUNT (mono_profiler_volatile_load_gc_state_t (&_ep_rt_mono_profiler_gc_state));
-	}
-}
-static
-void
-mono_profiler_gc_in_progress_stop (void)
-{
-	mono_profiler_gc_state_t old_state = 0;
-	mono_profiler_gc_state_t new_state = 0;
-	do {
-		old_state = mono_profiler_volatile_load_gc_state_t (&_ep_rt_mono_profiler_gc_state);
-		EP_ASSERT (MONO_PROFILER_GC_STATE_IS_GC_IN_PROGRESS (old_state));
-		new_state = MONO_PROFILER_GC_STATE_GC_IN_PROGRESS_STOP (old_state);
-		EP_ASSERT (!MONO_PROFILER_GC_STATE_IS_GC_IN_PROGRESS (new_state));
-	} while (mono_profiler_atomic_cas_gc_state_t (&_ep_rt_mono_profiler_gc_state, old_state, new_state) != old_state);
-	ep_rt_spin_lock_release (&_ep_rt_mono_profiler_gc_state_lock);
-}
-static
-inline
-bool
-mono_profiler_gc_in_progress (void)
-{
-	return MONO_PROFILER_GC_STATE_IS_GC_IN_PROGRESS (mono_profiler_volatile_load_gc_state_t (&_ep_rt_mono_profiler_gc_state));
-}
-static
-inline
-bool
-mono_profiler_gc_can_collect_heap (void)
-{
-	return _ep_rt_mono_profiler_gc_can_collect_heap;
-}
-static
-inline
-void
-mono_profiler_gc_heap_collect_requests_inc (void)
-{
-	EP_ASSERT (mono_profiler_gc_can_collect_heap ());
-	ep_rt_atomic_inc_uint32_t (&_ep_rt_mono_profiler_gc_heap_collect_requests);
-}
-static
-inline
-void
-mono_profiler_gc_heap_collect_requests_dec (void)
-{
-	EP_ASSERT (mono_profiler_gc_can_collect_heap ());
-	ep_rt_atomic_dec_uint32_t (&_ep_rt_mono_profiler_gc_heap_collect_requests);
-}
-static
-inline
-bool
-mono_profiler_gc_heap_collect_requested (void)
-{
-	if (!mono_profiler_gc_can_collect_heap ())
-		return false;
-	return ep_rt_volatile_load_uint32_t(&_ep_rt_mono_profiler_gc_heap_collect_requests) != 0 ? true : false;
-}
-static
-inline
-bool
-mono_profiler_gc_heap_collect_in_progress (void)
-{
-	ep_rt_spin_lock_requires_lock_held (&_ep_rt_mono_profiler_gc_state_lock);
-	return ep_rt_volatile_load_uint32_t_without_barrier (&_ep_rt_mono_profiler_gc_heap_collect_in_progress) != 0 ? true : false;
-}
-static
-inline
-void
-mono_profiler_gc_heap_collect_in_progress_start (void)
-{
-	EP_ASSERT (mono_profiler_gc_can_collect_heap ());
-	ep_rt_spin_lock_requires_lock_held (&_ep_rt_mono_profiler_gc_state_lock);
-	ep_rt_volatile_store_uint32_t_without_barrier (&_ep_rt_mono_profiler_gc_heap_collect_in_progress, 1);
-}
-static
-inline
-void
-mono_profiler_gc_heap_collect_in_progress_stop (void)
-{
-	EP_ASSERT (mono_profiler_gc_can_collect_heap ());
-	ep_rt_spin_lock_requires_lock_held (&_ep_rt_mono_profiler_gc_state_lock);
-	ep_rt_volatile_store_uint32_t_without_barrier (&_ep_rt_mono_profiler_gc_heap_collect_in_progress, 0);
-}
-static
-MonoProfilerMemBlock *
-mono_profiler_mem_block_alloc (uint32_t req_size)
-{
-	EP_ASSERT (mono_profiler_gc_in_progress ());
-	MonoProfilerMemBlock *prev = NULL;
-	uint32_t size = MONO_PROFILER_MEM_DEFAULT_BLOCK_SIZE;
-	while (size - sizeof(MonoProfilerMemBlock) < req_size)
-		size += MONO_PROFILER_MEM_BLOCK_SIZE_INC;
-	MonoProfilerMemBlock *block = mono_valloc (NULL, size, MONO_MMAP_READ | MONO_MMAP_WRITE | MONO_MMAP_ANON | MONO_MMAP_PRIVATE, MONO_MEM_ACCOUNT_PROFILER);
-	if (block) {
-		block->alloc_size = size;
-		block->start = (uint8_t *)ALIGN_PTR_TO ((uint8_t *)block + sizeof (MonoProfilerMemBlock), 16);
-		block->size = (uint32_t)(((uint8_t*)block + size) - (uint8_t*)block->start);
-		block->offset = 0;
-		block->last_used_offset = 0;
-		while (true) {
-			prev = (MonoProfilerMemBlock *)ep_rt_volatile_load_ptr_without_barrier ((volatile void **)&_ep_rt_mono_profiler_mem_blocks);
-			if (mono_atomic_cas_ptr ((volatile gpointer*)&_ep_rt_mono_profiler_mem_blocks, block, prev) == prev)
-				break;
-		}
-		if (prev)
-			prev->next = block;
-		block->prev = prev;
-	}
-	return block;
-}
-static
-uint8_t *
-mono_profiler_mem_alloc (uint32_t req_size)
-{
-	EP_ASSERT (mono_profiler_gc_in_progress ());
-	MonoProfilerMemBlock *current_block = (MonoProfilerMemBlock *)ep_rt_volatile_load_ptr_without_barrier ((volatile void **)&_ep_rt_mono_profiler_current_mem_block);
-	uint8_t *buffer = NULL;
-	if (!current_block) {
-		current_block = mono_profiler_mem_block_alloc (req_size);
-		if (current_block) {
-			mono_memory_barrier ();
-			ep_rt_volatile_store_ptr_without_barrier ((volatile void **)&_ep_rt_mono_profiler_current_mem_block, current_block);
-		}
-	}
-	if (current_block) {
-		uint32_t prev_offset = (uint32_t)mono_atomic_fetch_add_i32 ((volatile int32_t *)&current_block->offset, (int32_t)req_size);
-		if (prev_offset + req_size > current_block->size) {
-			if (prev_offset <= current_block->size)
-				current_block->last_used_offset = prev_offset;
-			current_block = mono_profiler_mem_block_alloc (req_size);
-			if (current_block) {
-				buffer = current_block->start;
-				current_block->offset += req_size;
-				mono_memory_barrier ();
-				ep_rt_volatile_store_ptr_without_barrier ((volatile void **)&_ep_rt_mono_profiler_current_mem_block, current_block);
-			}
-		} else {
-			buffer = (uint8_t*)current_block->start + prev_offset;
-		}
-	}
-	return buffer;
-}
-static
-void
-mono_profiler_mem_block_free_all (void)
-{
-	EP_ASSERT (mono_profiler_gc_in_progress ());
-	MonoProfilerMemBlock *current_block = (MonoProfilerMemBlock *)ep_rt_volatile_load_ptr ((volatile void **)&_ep_rt_mono_profiler_current_mem_block);
-	ep_rt_volatile_store_ptr_without_barrier ((volatile void **)&_ep_rt_mono_profiler_current_mem_block, NULL);
-	ep_rt_volatile_store_ptr_without_barrier ((volatile void **)&_ep_rt_mono_profiler_mem_blocks, NULL);
-	mono_memory_barrier ();
-	while (current_block) {
-		MonoProfilerMemBlock *prev_block = current_block->prev;
-		mono_vfree ((uint8_t *)current_block, current_block->alloc_size, MONO_MEM_ACCOUNT_MEM_MANAGER);
-		current_block = prev_block;
-	}
-}
-static
-void
-mono_profiler_mem_block_free_all_but_current (void)
-{
-	EP_ASSERT (mono_profiler_gc_in_progress ());
-	MonoProfilerMemBlock *block_to_keep = (MonoProfilerMemBlock *)ep_rt_volatile_load_ptr ((volatile void **)&_ep_rt_mono_profiler_current_mem_block);
-	MonoProfilerMemBlock *current_block = block_to_keep;
-	ep_rt_volatile_store_ptr_without_barrier ((volatile void **)&_ep_rt_mono_profiler_current_mem_block, NULL);
-	ep_rt_volatile_store_ptr_without_barrier ((volatile void **)&_ep_rt_mono_profiler_mem_blocks, NULL);
-	mono_memory_barrier ();
-	if (current_block) {
-		if (current_block->prev) {
-			current_block = current_block->prev;
-			while (current_block) {
-				MonoProfilerMemBlock *prev_block = current_block->prev;
-				mono_vfree ((uint8_t *)current_block, current_block->alloc_size, MONO_MEM_ACCOUNT_MEM_MANAGER);
-				current_block = prev_block;
-			}
-		}
-	}
-	if (block_to_keep) {
-		block_to_keep->prev = NULL;
-		block_to_keep->next = NULL;
-		block_to_keep->offset = 0;
-		block_to_keep->last_used_offset = 0;
-	}
-	mono_memory_barrier ();
-	ep_rt_volatile_store_ptr_without_barrier ((volatile void **)&_ep_rt_mono_profiler_current_mem_block, block_to_keep);
-	ep_rt_volatile_store_ptr_without_barrier ((volatile void **)&_ep_rt_mono_profiler_mem_blocks, block_to_keep);
-}
-static
-inline
-uint8_t *
-mono_profiler_buffered_gc_event_alloc (uint32_t req_size)
-{
-	EP_ASSERT (mono_profiler_gc_in_progress ());
-	return mono_profiler_mem_alloc (req_size + sizeof (MonoProfilerBufferedGCEvent));
-}
-static
-void
-mono_profiler_trigger_heap_collect (MonoProfiler *prof)
-{
-	if (mono_profiler_gc_heap_collect_requested ()) {
-		ep_rt_spin_lock_acquire (&_ep_rt_mono_profiler_gc_state_lock);
-			mono_profiler_gc_heap_collect_requests_dec ();
-			mono_profiler_gc_heap_collect_in_progress_start ();
-		ep_rt_spin_lock_release (&_ep_rt_mono_profiler_gc_state_lock);
-		mono_gc_collect (mono_gc_max_generation ());
-		ep_rt_spin_lock_acquire (&_ep_rt_mono_profiler_gc_state_lock);
-			mono_profiler_pop_gc_heap_collect_param_request_value ();
-			mono_profiler_gc_heap_collect_in_progress_stop ();
-		ep_rt_spin_lock_release (&_ep_rt_mono_profiler_gc_state_lock);
-	}
-}
-static
-void
-mono_profiler_fire_gc_event_root_register (
-	uint8_t *data,
-	uint32_t payload_size)
-{
-	EP_ASSERT (mono_profiler_gc_in_progress ());
-	uintptr_t root_id;
-	uintptr_t root_size;
-	uint8_t root_source;
-	uintptr_t root_key;
-	memcpy (&root_id, data, sizeof (root_id));
-	data += sizeof (root_id);
-	memcpy (&root_size, data, sizeof (root_size));
-	data += sizeof (root_size);
-	memcpy (&root_source, data, sizeof (root_source));
-	data += sizeof (root_source);
-	memcpy (&root_key, data, sizeof (root_key));
-	data += sizeof (root_key);
-	FireEtwMonoProfilerGCRootRegister (
-		(const void *)root_id,
-		(uint64_t)root_size,
-		root_source,
-		(uint64_t)root_key,
-		(const ep_char8_t *)data,
-		NULL,
-		NULL);
-}
-static
-void
-mono_profiler_fire_buffered_gc_event_root_register (
-	MonoProfiler *prof,
-	const mono_byte *start,
-	uintptr_t size,
-	MonoGCRootSource source,
-	const void * key,
-	const char * name)
-{
-	EP_ASSERT (mono_profiler_gc_in_progress ());
-	uintptr_t root_id = (uintptr_t)start;
-	uintptr_t root_size = size;
-	uint8_t root_source = (uint8_t)source;
-	uintptr_t root_key = (uintptr_t)key;
-	const char *root_name = (name ? name : "");
-	size_t root_name_len = strlen (root_name) + 1;
-	MonoProfilerBufferedGCEvent gc_event_data;
-	gc_event_data.type = MONO_PROFILER_BUFFERED_GC_EVENT_ROOT_REGISTER;
-	gc_event_data.payload_size = (uint32_t)
-		(sizeof (root_id) +
-		sizeof (root_size) +
-		sizeof (root_source) +
-		sizeof (root_key) +
-		root_name_len);
-	uint8_t * buffer = mono_profiler_buffered_gc_event_alloc (gc_event_data.payload_size);
-	if (buffer) {
-		memcpy (buffer, &gc_event_data, sizeof (gc_event_data));
-		buffer += sizeof (gc_event_data);
-		memcpy(buffer, &root_id, sizeof (root_id));
-		buffer += sizeof (root_id);
-		memcpy(buffer, &root_size, sizeof (root_size));
-		buffer += sizeof (root_size);
-		memcpy(buffer, &root_source, sizeof (root_source));
-		buffer += sizeof (root_source);
-		memcpy(buffer, &root_key, sizeof (root_key));
-		buffer += sizeof (root_key);
-		memcpy(buffer, root_name, root_name_len);
-	}
-}
-static
-void
-mono_profiler_fire_gc_event_root_unregister (
-	uint8_t *data,
-	uint32_t payload_size)
-{
-	EP_ASSERT (mono_profiler_gc_in_progress ());
-	uintptr_t root_id;
-	memcpy (&root_id, data, sizeof (root_id));
-	FireEtwMonoProfilerGCRootUnregister (
-		(const void *)root_id,
-		NULL,
-		NULL);
-}
-static
-void
-mono_profiler_fire_buffered_gc_event_root_unregister (
-	MonoProfiler *prof,
-	const mono_byte *start)
-{
-	EP_ASSERT (mono_profiler_gc_in_progress ());
-	uintptr_t root_id = (uintptr_t)start;
-	MonoProfilerBufferedGCEvent gc_event_data;
-	gc_event_data.type = MONO_PROFILER_BUFFERED_GC_EVENT_ROOT_UNREGISTER;
-	gc_event_data.payload_size = sizeof (root_id);
-	uint8_t * buffer = mono_profiler_buffered_gc_event_alloc (gc_event_data.payload_size);
-	if (buffer) {
-		memcpy (buffer, &gc_event_data, sizeof (gc_event_data));
-		buffer += sizeof (gc_event_data);
-		memcpy(buffer, &root_id, sizeof (root_id));
-	}
-}
-static
-void
-mono_profiler_fire_gc_event (
-	uint8_t *data,
-	uint32_t payload_size)
-{
-	EP_ASSERT (mono_profiler_gc_in_progress ());
-	uint8_t gc_event_type;
-	uint32_t generation;
-	memcpy (&gc_event_type, data, sizeof (gc_event_type));
-	data += sizeof (gc_event_type);
-	memcpy (&generation, data, sizeof (generation));
-	FireEtwMonoProfilerGCEvent (
-		gc_event_type,
-		generation,
-		NULL,
-		NULL);
-}
-static
-void
-mono_profiler_fire_buffered_gc_event (
-	uint8_t gc_event_type,
-	uint32_t generation)
-{
-	EP_ASSERT (mono_profiler_gc_in_progress ());
-	MonoProfilerBufferedGCEvent gc_event_data;
-	gc_event_data.type = MONO_PROFILER_BUFFERED_GC_EVENT;
-	gc_event_data.payload_size =
-		sizeof (gc_event_type) +
-		sizeof (generation);
-	uint8_t * buffer = mono_profiler_buffered_gc_event_alloc (gc_event_data.payload_size);
-	if (buffer) {
-		memcpy (buffer, &gc_event_data, sizeof (gc_event_data));
-		buffer += sizeof (gc_event_data);
-		memcpy(buffer, &gc_event_type, sizeof (gc_event_type));
-		buffer += sizeof (gc_event_type);
-		memcpy(buffer, &generation, sizeof (generation));
-	}
-}
-static
-void
-mono_profiler_fire_gc_event_resize (
-	uint8_t *data,
-	uint32_t payload_size)
-{
-	EP_ASSERT (mono_profiler_gc_in_progress ());
-	uintptr_t size;
-	memcpy (&size, data, sizeof (size));
-	FireEtwMonoProfilerGCResize (
-		(uint64_t)size,
-		NULL,
-		NULL);
-}
-static
-void
-mono_profiler_fire_buffered_gc_event_resize (
-	MonoProfiler *prof,
-	uintptr_t size)
-{
-	EP_ASSERT (mono_profiler_gc_in_progress ());
-	MonoProfilerBufferedGCEvent gc_event_data;
-	gc_event_data.type = MONO_PROFILER_BUFFERED_GC_EVENT_RESIZE;
-	gc_event_data.payload_size = sizeof (size);
-	uint8_t * buffer = mono_profiler_buffered_gc_event_alloc (gc_event_data.payload_size);
-	if (buffer) {
-		memcpy (buffer, &gc_event_data, sizeof (gc_event_data));
-		buffer += sizeof (gc_event_data);
-		memcpy(buffer, &size, sizeof (size));
-	}
-}
-static
-void
-mono_profiler_fire_gc_event_moves (
-	uint8_t *data,
-	uint32_t payload_size)
-{
-	EP_ASSERT (mono_profiler_gc_in_progress ());
-	uint64_t count;
-	memcpy (&count, data, sizeof (count));
-	data += sizeof (count);
-	FireEtwMonoProfilerGCMoves (
-		(uint32_t)count,
-		sizeof (uintptr_t) + sizeof (uintptr_t),
-		data,
-		NULL,
-		NULL);
-}
-static
-void
-mono_profiler_fire_buffered_gc_event_moves (
-	MonoProfiler *prof,
-	MonoObject *const* objects,
-	uint64_t count)
-{
-	EP_ASSERT (mono_profiler_gc_in_progress ());
-	uintptr_t object_id;
-	uintptr_t address_id;
-	count = count / 2;
-	MonoProfilerBufferedGCEvent gc_event_data;
-	gc_event_data.type = MONO_PROFILER_BUFFERED_GC_EVENT_MOVES;
-	gc_event_data.payload_size =
-		(uint32_t)(sizeof (count) +
-		(count * (sizeof (uintptr_t) + sizeof (uintptr_t))));
-	uint8_t * buffer = mono_profiler_buffered_gc_event_alloc (gc_event_data.payload_size);
-	if (buffer) {
-		memcpy (buffer, &gc_event_data, sizeof (gc_event_data));
-		buffer += sizeof (gc_event_data);
-		memcpy (buffer, &count, sizeof (count));
-		buffer += sizeof (count);
-		for (uint64_t i = 0; i < count; i++) {
-			object_id = (uintptr_t)SGEN_POINTER_UNTAG_ALL (*objects);
-			memcpy (buffer, &object_id, sizeof (object_id));
-			buffer += sizeof (object_id);
-			objects++;
-			address_id = (uintptr_t)*objects;
-			memcpy (buffer, &address_id, sizeof (address_id));
-			buffer += sizeof (address_id);
-			objects++;
-		}
-	}
-}
-static
-void
-mono_profiler_fire_gc_event_roots (
-	uint8_t *data,
-	uint32_t payload_size)
-{
-	EP_ASSERT (mono_profiler_gc_in_progress ());
-	uint64_t count;
-	memcpy (&count, data, sizeof (count));
-	data += sizeof (count);
-	FireEtwMonoProfilerGCRoots (
-		(uint32_t)count,
-		sizeof (uintptr_t) + sizeof (uintptr_t),
-		data,
-		NULL,
-		NULL);
-}
-static
-void
-mono_profiler_fire_buffered_gc_event_roots (
-	MonoProfiler *prof,
-	uint64_t count,
-	const mono_byte *const * addresses,
-	MonoObject *const * objects)
-{
-	EP_ASSERT (mono_profiler_gc_in_progress ());
-	uintptr_t object_id;
-	uintptr_t address_id;
-	MonoProfilerBufferedGCEvent gc_event_data;
-	gc_event_data.type = MONO_PROFILER_BUFFERED_GC_EVENT_ROOTS;
-	gc_event_data.payload_size =
-		(uint32_t)(sizeof (count) +
-		(count * (sizeof (uintptr_t) + sizeof (uintptr_t))));
-	uint8_t * buffer = mono_profiler_buffered_gc_event_alloc (gc_event_data.payload_size);
-	if (buffer) {
-		memcpy (buffer, &gc_event_data, sizeof (gc_event_data));
-		buffer += sizeof (gc_event_data);
-		memcpy (buffer, &count, sizeof (count));
-		buffer += sizeof (count);
-		for (uint64_t i = 0; i < count; i++) {
-			object_id = (uintptr_t)SGEN_POINTER_UNTAG_ALL (*objects);
-			memcpy (buffer, &object_id, sizeof (object_id));
-			buffer += sizeof (object_id);
-			objects++;
-			address_id = (uintptr_t)*addresses;
-			memcpy (buffer, &address_id, sizeof (address_id));
-			buffer += sizeof (address_id);
-			addresses++;
-		}
-	}
-}
-static
-void
-mono_profiler_fire_gc_event_heap_dump_object_reference (
-	uint8_t *data,
-	uint32_t payload_size,
-	GHashTable *cache)
-{
-	EP_ASSERT (mono_profiler_gc_in_progress ());
-	uintptr_t object_id;
-	uintptr_t vtable_id;
-	uintptr_t object_size;
-	uint8_t object_gen;
-	uintptr_t object_ref_count;
-	memcpy (&object_id, data, sizeof (object_id));
-	data += sizeof (object_id);
-	memcpy (&vtable_id, data, sizeof (vtable_id));
-	data += sizeof (vtable_id);
-	memcpy (&object_size, data, sizeof (object_size));
-	data += sizeof (object_size);
-	memcpy (&object_gen, data, sizeof (object_gen));
-	data += sizeof (object_gen);
-	memcpy (&object_ref_count, data, sizeof (object_ref_count));
-	data += sizeof (object_ref_count);
-	FireEtwMonoProfilerGCHeapDumpObjectReference (
-		(const void *)object_id,
-		(uint64_t)vtable_id,
-		(uint64_t)object_size,
-		object_gen,
-		(uint32_t)object_ref_count,
-		sizeof (uint32_t) + sizeof (uintptr_t),
-		data,
-		NULL,
-		NULL);
-	if (cache)
-		g_hash_table_insert (cache, (MonoVTable *)SGEN_POINTER_UNTAG_ALL (vtable_id), NULL);
-}
-static
-int
-mono_profiler_fire_buffered_gc_event_heap_dump_object_reference (
-	MonoObject *obj,
-	MonoClass *klass,
-	uintptr_t size,
-	uintptr_t num,
-	MonoObject **refs,
-	uintptr_t *offsets,
-	void *data)
-{
-	EP_ASSERT (mono_profiler_gc_in_progress ());
-	uintptr_t object_id;
-	uintptr_t vtable_id;
-	uint8_t object_gen;
-	uintptr_t object_size = size;
-	uintptr_t object_ref_count = num;
-	uint32_t object_ref_offset;
-	/* account for object alignment */
-	object_size += 7;
-	object_size &= ~7;
-	size_t payload_size =
-		sizeof (object_id) +
-		sizeof (vtable_id) +
-		sizeof (object_size) +
-		sizeof (object_gen) +
-		sizeof (object_ref_count) +
-		(object_ref_count * (sizeof (uint32_t) + sizeof (uintptr_t)));
-	MonoProfilerBufferedGCEvent gc_event_data;
-	gc_event_data.type = MONO_PROFILER_BUFFERED_GC_EVENT_OBJECT_REF;
-	gc_event_data.payload_size = GSIZE_TO_UINT32 (payload_size);
-	uint8_t *buffer = mono_profiler_buffered_gc_event_alloc (gc_event_data.payload_size);
-	if (buffer) {
-		memcpy (buffer, &gc_event_data, sizeof (gc_event_data));
-		buffer += sizeof (gc_event_data);
-		object_id = (uintptr_t)SGEN_POINTER_UNTAG_ALL (obj);
-		memcpy (buffer, &object_id, sizeof (object_id));
-		buffer += sizeof (object_id);
-		vtable_id = (uintptr_t)SGEN_POINTER_UNTAG_ALL (mono_object_get_vtable_internal (obj));
-		memcpy (buffer, &vtable_id, sizeof (vtable_id));
-		buffer += sizeof (vtable_id);
-		memcpy (buffer, &object_size, sizeof (object_size));
-		buffer += sizeof (object_size);
-		object_gen = (uint8_t)mono_gc_get_generation (obj);
-		memcpy (buffer, &object_gen, sizeof (object_gen));
-		buffer += sizeof (object_gen);
-		memcpy (buffer, &object_ref_count, sizeof (object_ref_count));
-		buffer += sizeof (object_ref_count);
-		uintptr_t last_offset = 0;
-		for (uintptr_t i = 0; i < object_ref_count; i++) {
-			object_ref_offset = GUINTPTR_TO_UINT32 (offsets [i] - last_offset);
-			memcpy (buffer, &object_ref_offset, sizeof (object_ref_offset));
-			buffer += sizeof (object_ref_offset);
-			object_id = (uintptr_t)SGEN_POINTER_UNTAG_ALL (refs[i]);
-			memcpy (buffer, &object_id, sizeof (object_id));
-			buffer += sizeof (object_id);
-			last_offset = offsets [i];
-		}
-	}
-	return 0;
-}
-static
-void
-mono_profiler_fire_buffered_gc_events (
-	MonoProfilerMemBlock *block,
-	GHashTable *cache)
-{
-	EP_ASSERT (mono_profiler_gc_in_progress ());
-	if (block) {
-		uint32_t current_offset = 0;
-		uint32_t used_size = (block->offset < block->size) ? block->offset : block->last_used_offset;
-		MonoProfilerBufferedGCEvent gc_event;
-		while ((current_offset + sizeof (gc_event)) <= used_size) {
-			uint8_t *data = block->start + current_offset;
-			memcpy (&gc_event, data, sizeof (gc_event));
-			data += sizeof (gc_event);
-			if ((current_offset + sizeof (gc_event) + gc_event.payload_size) <= used_size) {
-				switch (gc_event.type) {
-				case MONO_PROFILER_BUFFERED_GC_EVENT:
-					mono_profiler_fire_gc_event (data, gc_event.payload_size);
-					break;
-				case MONO_PROFILER_BUFFERED_GC_EVENT_RESIZE:
-					mono_profiler_fire_gc_event_resize (data, gc_event.payload_size);
-					break;
-				case MONO_PROFILER_BUFFERED_GC_EVENT_ROOTS:
-					mono_profiler_fire_gc_event_roots (data, gc_event.payload_size);
-					break;
-				case MONO_PROFILER_BUFFERED_GC_EVENT_MOVES:
-					mono_profiler_fire_gc_event_moves (data, gc_event.payload_size);
-					break;
-				case MONO_PROFILER_BUFFERED_GC_EVENT_OBJECT_REF:
-					mono_profiler_fire_gc_event_heap_dump_object_reference (data, gc_event.payload_size, cache);
-					break;
-				case MONO_PROFILER_BUFFERED_GC_EVENT_ROOT_REGISTER:
-					mono_profiler_fire_gc_event_root_register (data, gc_event.payload_size);
-					break;
-				case MONO_PROFILER_BUFFERED_GC_EVENT_ROOT_UNREGISTER:
-					mono_profiler_fire_gc_event_root_unregister (data, gc_event.payload_size);
-					break;
-				default:
-					EP_ASSERT (!"Unknown buffered GC event type.");
-				}
-				current_offset += sizeof (gc_event) + gc_event.payload_size;
-			} else {
-				break;
-			}
-		}
-	}
-}
-static
-void
-mono_profiler_fire_buffered_gc_events_in_alloc_order (GHashTable *cache)
-{
-	EP_ASSERT (mono_profiler_gc_in_progress ());
-	MonoProfilerMemBlock *first_block = (MonoProfilerMemBlock *)ep_rt_volatile_load_ptr ((volatile void **)&_ep_rt_mono_profiler_current_mem_block);
-	while (first_block && first_block->prev)
-		first_block = first_block->prev;
-	MonoProfilerMemBlock *current_block = first_block;
-	while (current_block) {
-		MonoProfilerMemBlock *next_block = current_block->next;
-		mono_profiler_fire_buffered_gc_events (current_block, cache);
-		current_block = next_block;
-	}
-	mono_profiler_mem_block_free_all_but_current ();
-}
-static
-void
-mono_profiler_fire_cached_gc_events (GHashTable *cache)
-{
-	if (cache) {
-		GHashTableIter iter;
-		MonoVTable *object_vtable;
-		g_hash_table_iter_init (&iter, cache);
-		while (g_hash_table_iter_next (&iter, (void**)&object_vtable, NULL)) {
-			if (object_vtable) {
-				uint64_t vtable_id = (uint64_t)object_vtable;
-				uint64_t class_id;
-				uint64_t module_id;
-				ep_char8_t *class_name;
-				mono_profiler_get_class_data (object_vtable->klass, &class_id, &module_id, &class_name, NULL, NULL);
-				FireEtwMonoProfilerGCHeapDumpVTableClassReference (
-					vtable_id,
-					class_id,
-					module_id,
-					class_name,
-					NULL,
-					NULL);
-				g_free (class_name);
-			}
-		}
-	}
-}
-static
-void
-mono_profiler_app_domain_loading (
-	MonoProfiler *prof,
-	MonoDomain *domain)
-{
-	if (!EventEnabledMonoProfilerAppDomainLoading ())
-		return;
-	uint64_t domain_id = (uint64_t)domain;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerAppDomainLoading (
-		domain_id,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_app_domain_loaded (
-	MonoProfiler *prof,
-	MonoDomain *domain)
-{
-	if (!EventEnabledMonoProfilerAppDomainLoaded ())
-		return;
-	uint64_t domain_id = (uint64_t)domain;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerAppDomainLoaded (
-		domain_id,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_app_domain_unloading (
-	MonoProfiler *prof,
-	MonoDomain *domain)
-{
-	if (!EventEnabledMonoProfilerAppDomainUnloading ())
-		return;
-	uint64_t domain_id = (uint64_t)domain;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerAppDomainUnloading (
-		domain_id,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_app_domain_unloaded (
-	MonoProfiler *prof,
-	MonoDomain *domain)
-{
-	if (!EventEnabledMonoProfilerAppDomainUnloaded ())
-		return;
-	uint64_t domain_id = (uint64_t)domain;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerAppDomainUnloaded (
-		domain_id,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_app_domain_name (
-	MonoProfiler *prof,
-	MonoDomain *domain,
-	const char *name)
-{
-	if (!EventEnabledMonoProfilerAppDomainName ())
-		return;
-	uint64_t domain_id = (uint64_t)domain;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerAppDomainName (
-		domain_id,
-		(const ep_char8_t *)(name ? name : ""),
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_get_generic_types (
-	MonoGenericInst *generic_instance,
-	uint32_t *generic_type_count,
-	uint8_t **generic_types)
-{
-	if (generic_instance) {
-		uint8_t *buffer = g_malloc (generic_instance->type_argc * (sizeof (uint8_t) + sizeof (uint64_t)));
-		if (buffer) {
-			*generic_types = buffer;
-			*generic_type_count = generic_instance->type_argc;
-			for (uint32_t i = 0; i < generic_instance->type_argc; ++i) {
-				uint8_t type = generic_instance->type_argv [i]->type;
-				ep_write_buffer_uint8_t (&buffer, type);
-				uint64_t class_id = (uint64_t)mono_class_from_mono_type_internal (generic_instance->type_argv [i]);
-				ep_write_buffer_uint64_t (&buffer, class_id);
-			}
-		}
-	}
-}
-static
-void
-mono_profiler_get_jit_data (
-	MonoMethod *method,
-	uint64_t *method_id,
-	uint64_t *module_id,
-	uint32_t *method_token,
-	uint32_t *method_generic_type_count,
-	uint8_t **method_generic_types)
-{
-	*method_id = (uint64_t)method;
-	*module_id = 0;
-	*method_token = 0;
-	if (method) {
-		*method_token = method->token;
-		if (method->klass)
-			*module_id = (uint64_t)m_class_get_image (method->klass);
-		if (method_generic_type_count && method_generic_types) {
-			if (method->is_inflated) {
-				MonoGenericContext *context = mono_method_get_context (method);
-				MonoGenericInst *method_instance = (context && context->method_inst) ? context->method_inst : NULL;
-				mono_profiler_get_generic_types (method_instance, method_generic_type_count, method_generic_types);
-			}
-		}
-	}
-}
-static
-void
-mono_profiler_jit_begin (
-	MonoProfiler *prof,
-	MonoMethod *method)
-{
-	if (!EventEnabledMonoProfilerJitBegin ())
-		return;
-	uint64_t method_id;
-	uint64_t module_id;
-	uint32_t method_token;
-	mono_profiler_get_jit_data (method, &method_id, &module_id, &method_token, NULL, NULL);
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerJitBegin (
-		method_id,
-		module_id,
-		method_token,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_jit_failed (
-	MonoProfiler *prof,
-	MonoMethod *method)
-{
-	if (!EventEnabledMonoProfilerJitFailed ())
-		return;
-	uint64_t method_id;
-	uint64_t module_id;
-	uint32_t method_token;
-	mono_profiler_get_jit_data (method, &method_id, &module_id, &method_token, NULL, NULL);
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerJitFailed (
-		method_id,
-		module_id,
-		method_token,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_jit_done (
-	MonoProfiler *prof,
-	MonoMethod *method,
-	MonoJitInfo *ji)
-{
-	if (!EventEnabledMonoProfilerJitDone () && !EventEnabledMonoProfilerJitDone_V1 () && !EventEnabledMonoProfilerJitDoneVerbose ())
-		return;
-	bool verbose = (MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_EVENTPIPE_Context.Level >= (uint8_t)EP_EVENT_LEVEL_VERBOSE);
-	uint64_t method_id;
-	uint64_t module_id;
-	uint32_t method_token;
-	uint32_t method_generic_type_count = 0;
-	uint8_t *method_generic_types = NULL;
-	char *method_namespace = NULL;
-	const char *method_name = NULL;
-	char *method_signature = NULL;
-	mono_profiler_get_jit_data (method, &method_id, &module_id, &method_token, &method_generic_type_count, &method_generic_types);
-	if (verbose) {
-		method_name = method->name;
-		method_signature = mono_signature_full_name (mono_method_signature_internal (method));
-		if (method->klass)
-			method_namespace = mono_type_get_name_full (m_class_get_byval_arg (method->klass), MONO_TYPE_NAME_FORMAT_IL);
-	}
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerJitDone_V1 (
-		method_id,
-		module_id,
-		method_token,
-		method_generic_type_count,
-		sizeof (uint8_t) + sizeof (uint64_t),
-		method_generic_types,
-		NULL,
-		NULL);
-	if (verbose) {
-		FireEtwMonoProfilerJitDoneVerbose (
-			method_id,
-			(const ep_char8_t *)method_namespace,
-			(const ep_char8_t *)method_name,
-			(const ep_char8_t *)method_signature,
-			NULL,
-			NULL);
-	}
-	mono_profiler_fire_event_exit ();
-	g_free (method_namespace);
-	g_free (method_signature);
-	g_free (method_generic_types);
-}
-static
-void
-mono_profiler_jit_chunk_created (
-	MonoProfiler *prof,
-	const mono_byte *chunk,
-	uintptr_t size)
-{
-	if (!EventEnabledMonoProfilerJitChunkCreated ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerJitChunkCreated (
-		chunk,
-		(uint64_t)size,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_jit_chunk_destroyed (
-	MonoProfiler *prof,
-	const mono_byte *chunk)
-{
-	if (!EventEnabledMonoProfilerJitChunkDestroyed ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerJitChunkDestroyed (
-		chunk,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_jit_code_buffer (
-	MonoProfiler *prof,
-	const mono_byte *buffer,
-	uint64_t size,
-	MonoProfilerCodeBufferType type,
-	const void *data)
-{
-	if (!EventEnabledMonoProfilerJitCodeBuffer ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerJitCodeBuffer (
-		buffer,
-		size,
-		(uint8_t)type,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_get_class_data (
-	MonoClass *klass,
-	uint64_t *class_id,
-	uint64_t *module_id,
-	ep_char8_t **class_name,
-	uint32_t *class_generic_type_count,
-	uint8_t **class_generic_types)
-{
-	*class_id = (uint64_t)klass;
-	*module_id = 0;
-	if (klass)
-		*module_id = (uint64_t)m_class_get_image (klass);
-	if (klass && class_name)
-		*class_name = (ep_char8_t *)mono_type_get_name_full (m_class_get_byval_arg (klass), MONO_TYPE_NAME_FORMAT_IL);
-	else if (class_name)
-		*class_name = NULL;
-	if (class_generic_type_count && class_generic_types) {
-		if (mono_class_is_ginst (klass)) {
-			MonoGenericContext *context = mono_class_get_context (klass);
-			MonoGenericInst *class_instance = (context && context->class_inst) ? context->class_inst : NULL;
-			mono_profiler_get_generic_types (class_instance, class_generic_type_count, class_generic_types);
-		}
-	}
-}
-static
-void
-mono_profiler_class_loading (
-	MonoProfiler *prof,
-	MonoClass *klass)
-{
-	if (!EventEnabledMonoProfilerClassLoading ())
-		return;
-	uint64_t class_id;
-	uint64_t module_id;
-	mono_profiler_get_class_data (klass, &class_id, &module_id, NULL, NULL, NULL);
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerClassLoading (
-		class_id,
-		module_id,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_class_failed (
-	MonoProfiler *prof,
-	MonoClass *klass)
-{
-	if (!EventEnabledMonoProfilerClassFailed ())
-		return;
-	uint64_t class_id;
-	uint64_t module_id;
-	mono_profiler_get_class_data (klass, &class_id, &module_id, NULL, NULL, NULL);
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerClassFailed (
-		class_id,
-		module_id,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_class_loaded (
-	MonoProfiler *prof,
-	MonoClass *klass)
-{
-	if (!EventEnabledMonoProfilerClassLoaded () && !EventEnabledMonoProfilerClassLoaded_V1 ())
-		return;
-	uint64_t class_id;
-	uint64_t module_id;
-	ep_char8_t *class_name;
-	uint32_t class_generic_type_count = 0;
-	uint8_t *class_generic_types = NULL;
-	mono_profiler_get_class_data (klass, &class_id, &module_id, &class_name, &class_generic_type_count, &class_generic_types);
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerClassLoaded_V1 (
-		class_id,
-		module_id,
-		class_name ? class_name : "",
-		class_generic_type_count,
-		sizeof (uint8_t) + sizeof (uint64_t),
-		class_generic_types,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-	g_free (class_name);
-	g_free (class_generic_types);
-}
-static
-inline
-void
-get_vtable_data (
-	MonoVTable *vtable,
-	uint64_t *vtable_id,
-	uint64_t *class_id,
-	uint64_t *domain_id)
-{
-	*vtable_id = (uint64_t)vtable;
-	*class_id = 0;
-	*domain_id = 0;
-	if (vtable) {
-		*class_id = (uint64_t)mono_vtable_class_internal (vtable);
-		*domain_id = (uint64_t)mono_vtable_domain_internal (vtable);
-	}
-}
-static
-void
-mono_profiler_vtable_loading (
-	MonoProfiler *prof,
-	MonoVTable *vtable)
-{
-	if (!EventEnabledMonoProfilerVTableLoading ())
-		return;
-	uint64_t vtable_id;
-	uint64_t class_id;
-	uint64_t domain_id;
-	get_vtable_data (vtable, &vtable_id, &class_id, &domain_id);
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerVTableLoading (
-		vtable_id,
-		class_id,
-		domain_id,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_vtable_failed (
-	MonoProfiler *prof,
-	MonoVTable *vtable)
-{
-	if (!EventEnabledMonoProfilerVTableFailed ())
-		return;
-	uint64_t vtable_id;
-	uint64_t class_id;
-	uint64_t domain_id;
-	get_vtable_data (vtable, &vtable_id, &class_id, &domain_id);
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerVTableFailed (
-		vtable_id,
-		class_id,
-		domain_id,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_vtable_loaded (
-	MonoProfiler *prof,
-	MonoVTable *vtable)
-{
-	if (!EventEnabledMonoProfilerVTableLoaded ())
-		return;
-	uint64_t vtable_id;
-	uint64_t class_id;
-	uint64_t domain_id;
-	get_vtable_data (vtable, &vtable_id, &class_id, &domain_id);
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerVTableLoaded (
-		vtable_id,
-		class_id,
-		domain_id,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_module_loading (
-	MonoProfiler *prof,
-	MonoImage *image)
-{
-	if (!EventEnabledMonoProfilerModuleLoading ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerModuleLoading (
-		(uint64_t)image,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_module_failed (
-	MonoProfiler *prof,
-	MonoImage *image)
-{
-	if (!EventEnabledMonoProfilerModuleFailed ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerModuleFailed (
-		(uint64_t)image,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_module_loaded (
-	MonoProfiler *prof,
-	MonoImage *image)
-{
-	if (!EventEnabledMonoProfilerModuleLoaded ())
-		return;
-	uint64_t module_id = (uint64_t)image;
-	const ep_char8_t *module_path = NULL;
-	const ep_char8_t *module_guid = NULL;
-	if (image) {
-		ModuleEventData module_data;
-		memset (&module_data, 0, sizeof (module_data));
-		if (get_module_event_data (image, &module_data))
-			module_path = (const ep_char8_t *)module_data.module_il_path;
-		module_guid = (const ep_char8_t *)mono_image_get_guid (image);
-	}
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerModuleLoaded (
-		module_id,
-		module_path ? module_path : "",
-		module_guid ? module_guid : "",
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_module_unloading (
-	MonoProfiler *prof,
-	MonoImage *image)
-{
-	if (!EventEnabledMonoProfilerModuleUnloading ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerModuleUnloading (
-		(uint64_t)image,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_module_unloaded (
-	MonoProfiler *prof,
-	MonoImage *image)
-{
-	if (!EventEnabledMonoProfilerModuleUnloaded ())
-		return;
-	uint64_t module_id = (uint64_t)image;
-	const ep_char8_t *module_path = NULL;
-	const ep_char8_t *module_guid = NULL;
-	if (image) {
-		ModuleEventData module_data;
-		memset (&module_data, 0, sizeof (module_data));
-		if (get_module_event_data (image, &module_data))
-			module_path = (const ep_char8_t *)module_data.module_il_path;
-		module_guid = (const ep_char8_t *)mono_image_get_guid (image);
-	}
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerModuleUnloaded (
-		module_id,
-		module_path ? module_path : "",
-		module_guid ? module_guid : "",
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-inline
-void
-get_assembly_data (
-	MonoAssembly *assembly,
-	uint64_t *assembly_id,
-	uint64_t *module_id,
-	ep_char8_t **assembly_name)
-{
-	*assembly_id = (uint64_t)assembly;
-	*module_id = 0;
-	if (assembly)
-		*module_id = (uint64_t)mono_assembly_get_image_internal (assembly);
-	if (assembly && assembly_name)
-		*assembly_name = (ep_char8_t *)mono_stringify_assembly_name (&assembly->aname);
-	else if (assembly_name)
-		*assembly_name = NULL;
-}
-static
-void
-mono_profiler_assembly_loading (
-	MonoProfiler *prof,
-	MonoAssembly *assembly)
-{
-	if (!EventEnabledMonoProfilerAssemblyLoading ())
-		return;
-	uint64_t assembly_id;
-	uint64_t module_id;
-	get_assembly_data (assembly, &assembly_id, &module_id, NULL);
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerAssemblyLoading (
-		assembly_id,
-		module_id,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_assembly_loaded (
-	MonoProfiler *prof,
-	MonoAssembly *assembly)
-{
-	if (!EventEnabledMonoProfilerAssemblyLoaded ())
-		return;
-	uint64_t assembly_id;
-	uint64_t module_id;
-	ep_char8_t *assembly_name;
-	get_assembly_data (assembly, &assembly_id, &module_id, &assembly_name);
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerAssemblyLoaded (
-		assembly_id,
-		module_id,
-		assembly_name ? assembly_name : "",
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-	g_free (assembly_name);
-}
-static
-void
-mono_profiler_assembly_unloading (
-	MonoProfiler *prof,
-	MonoAssembly *assembly)
-{
-	if (!EventEnabledMonoProfilerAssemblyUnloading ())
-		return;
-	uint64_t assembly_id;
-	uint64_t module_id;
-	get_assembly_data (assembly, &assembly_id, &module_id, NULL);
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerAssemblyUnloading (
-		assembly_id,
-		module_id,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_assembly_unloaded (
-	MonoProfiler *prof,
-	MonoAssembly *assembly)
-{
-	if (!EventEnabledMonoProfilerAssemblyUnloaded ())
-		return;
-	uint64_t assembly_id;
-	uint64_t module_id;
-	ep_char8_t *assembly_name;
-	get_assembly_data (assembly, &assembly_id, &module_id, &assembly_name);
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerAssemblyUnloaded (
-		assembly_id,
-		module_id,
-		assembly_name ? assembly_name : "",
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-	g_free (assembly_name);
-}
-static
-void
-mono_profiler_method_enter (
-	MonoProfiler *prof,
-	MonoMethod *method,
-	MonoProfilerCallContext *context)
-{
-	if (!EventEnabledMonoProfilerMethodEnter ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerMethodEnter (
-		(uint64_t)method,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_method_leave (
-	MonoProfiler *prof,
-	MonoMethod *method,
-	MonoProfilerCallContext *context)
-{
-	if (!EventEnabledMonoProfilerMethodLeave ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerMethodLeave (
-		(uint64_t)method,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_method_tail_call (
-	MonoProfiler *prof,
-	MonoMethod *method,
-	MonoMethod *target_method)
-{
-	if (!EventEnabledMonoProfilerMethodTailCall ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerMethodTailCall (
-		(uint64_t)method,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_method_exception_leave (
-	MonoProfiler *prof,
-	MonoMethod *method,
-	MonoObject *exc)
-{
-	if (!EventEnabledMonoProfilerMethodExceptionLeave ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerMethodExceptionLeave (
-		(uint64_t)method,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_method_free (
-	MonoProfiler *prof,
-	MonoMethod *method)
-{
-	if (!EventEnabledMonoProfilerMethodFree ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerMethodFree (
-		(uint64_t)method,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_method_begin_invoke (
-	MonoProfiler *prof,
-	MonoMethod *method)
-{
-	if (!EventEnabledMonoProfilerMethodBeginInvoke ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerMethodBeginInvoke (
-		(uint64_t)method,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_method_end_invoke (
-	MonoProfiler *prof,
-	MonoMethod *method)
-{
-	if (!EventEnabledMonoProfilerMethodEndInvoke ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerMethodEndInvoke (
-		(uint64_t)method,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-MonoProfilerCallInstrumentationFlags
-mono_profiler_method_instrumentation (
-	MonoProfiler *prof,
-	MonoMethod *method)
-{
-	if (_ep_rt_dotnet_mono_profiler_provider_callspec.len > 0 && !mono_callspec_eval (method, &_ep_rt_dotnet_mono_profiler_provider_callspec))
-		return MONO_PROFILER_CALL_INSTRUMENTATION_NONE;
-	return MONO_PROFILER_CALL_INSTRUMENTATION_ENTER |
-			MONO_PROFILER_CALL_INSTRUMENTATION_LEAVE |
-			MONO_PROFILER_CALL_INSTRUMENTATION_TAIL_CALL |
-			MONO_PROFILER_CALL_INSTRUMENTATION_EXCEPTION_LEAVE;
-}
-static
-void
-mono_profiler_exception_throw (
-	MonoProfiler *prof,
-	MonoObject *exc)
-{
-	if (!EventEnabledMonoProfilerExceptionThrow ())
-		return;
-	uint64_t type_id = 0;
-	if (exc && mono_object_class(exc))
-		type_id = (uint64_t)m_class_get_byval_arg (mono_object_class(exc));
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerExceptionThrow (
-		type_id,
-		SGEN_POINTER_UNTAG_ALL (exc),
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_exception_clause (
-	MonoProfiler *prof,
-	MonoMethod *method,
-	uint32_t clause_num,
-	MonoExceptionEnum clause_type,
-	MonoObject *exc)
-{
-	if (!EventEnabledMonoProfilerExceptionClause ())
-		return;
-	uint64_t type_id = 0;
-	if (exc && mono_object_class(exc))
-		type_id = (uint64_t)m_class_get_byval_arg (mono_object_class(exc));
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerExceptionClause (
-		(uint8_t)clause_type,
-		clause_num,
-		(uint64_t)method,
-		type_id,
-		SGEN_POINTER_UNTAG_ALL (exc),
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_gc_event (
-	MonoProfiler *prof,
-	MonoProfilerGCEvent gc_event,
-	uint32_t generation,
-	mono_bool serial)
-{
-	switch (gc_event) {
-	case MONO_GC_EVENT_PRE_STOP_WORLD:
-	case MONO_GC_EVENT_POST_START_WORLD_UNLOCKED:
-	{
-		FireEtwMonoProfilerGCEvent (
-			(uint8_t)gc_event,
-			generation,
-			NULL,
-			NULL);
-		break;
-	}
-	case MONO_GC_EVENT_PRE_STOP_WORLD_LOCKED:
-	{
-		FireEtwMonoProfilerGCEvent (
-			(uint8_t)gc_event,
-			generation,
-			NULL,
-			NULL);
-		mono_profiler_gc_in_progress_start ();
-		if (mono_profiler_gc_heap_collect_in_progress ()) {
-			FireEtwMonoProfilerGCHeapDumpStart (
-				mono_profiler_get_gc_heap_collect_param_request_value (),
-				NULL,
-				NULL);
-		}
-		break;
-	}
-	case MONO_GC_EVENT_POST_STOP_WORLD:
-	{
-		if (mono_profiler_gc_in_progress ()) {
-			uint64_t enabled_keywords = MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_EVENTPIPE_Context.EnabledKeywordsBitmask;
-			if (profiler_callback_is_enabled (enabled_keywords, GC_ROOT_KEYWORD)) {
-				mono_profiler_set_gc_root_register_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_gc_root_unregister_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_gc_root_register_callback (_ep_rt_dotnet_mono_profiler_heap_collect_provider, mono_profiler_fire_buffered_gc_event_root_register);
-				mono_profiler_set_gc_root_unregister_callback (_ep_rt_dotnet_mono_profiler_heap_collect_provider, mono_profiler_fire_buffered_gc_event_root_unregister);
-			}
-			if (mono_profiler_gc_heap_collect_in_progress ()) {
-				if (profiler_callback_is_enabled (enabled_keywords, GC_ROOT_KEYWORD)) {
-					mono_profiler_set_gc_roots_callback (_ep_rt_dotnet_mono_profiler_heap_collect_provider, mono_profiler_fire_buffered_gc_event_roots);
-				}
-				if (profiler_callback_is_enabled (enabled_keywords, GC_MOVES_KEYWORD)) {
-					mono_profiler_set_gc_moves_callback (_ep_rt_dotnet_mono_profiler_heap_collect_provider, mono_profiler_fire_buffered_gc_event_moves);
-				}
-				if (profiler_callback_is_enabled (enabled_keywords, GC_RESIZE_KEYWORD)) {
-					mono_profiler_set_gc_resize_callback (_ep_rt_dotnet_mono_profiler_heap_collect_provider, mono_profiler_fire_buffered_gc_event_resize);
-				}
-			}
-			mono_profiler_fire_buffered_gc_event (
-				(uint8_t)gc_event,
-				generation);
-		}
-		break;
-	}
-	case MONO_GC_EVENT_START:
-	case MONO_GC_EVENT_END:
-	{
-		if (mono_profiler_gc_in_progress ()) {
-			mono_profiler_fire_buffered_gc_event (
-				(uint8_t)gc_event,
-				generation);
-		}
-		break;
-	}
-	case MONO_GC_EVENT_PRE_START_WORLD:
-	{
-		if (mono_profiler_gc_in_progress ()) {
-			uint64_t enabled_keywords = MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_EVENTPIPE_Context.EnabledKeywordsBitmask;
-			if (mono_profiler_gc_heap_collect_in_progress () && profiler_callback_is_enabled (enabled_keywords, GC_HEAP_DUMP_KEYWORD))
-				mono_gc_walk_heap (0, mono_profiler_fire_buffered_gc_event_heap_dump_object_reference, NULL);
-			mono_profiler_set_gc_root_register_callback (_ep_rt_dotnet_mono_profiler_heap_collect_provider, NULL);
-			mono_profiler_set_gc_root_unregister_callback (_ep_rt_dotnet_mono_profiler_heap_collect_provider, NULL);
-			mono_profiler_set_gc_roots_callback (_ep_rt_dotnet_mono_profiler_heap_collect_provider, NULL);
-			mono_profiler_set_gc_moves_callback (_ep_rt_dotnet_mono_profiler_heap_collect_provider, NULL);
-			mono_profiler_set_gc_resize_callback (_ep_rt_dotnet_mono_profiler_heap_collect_provider, NULL);
-			if (profiler_callback_is_enabled (enabled_keywords, GC_ROOT_KEYWORD)) {
-				mono_profiler_set_gc_root_register_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_gc_root_register);
-				mono_profiler_set_gc_root_unregister_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_gc_root_unregister);
-			}
-			mono_profiler_fire_buffered_gc_event (
-				(uint8_t)gc_event,
-				generation);
-		}
-		break;
-	}
-	case MONO_GC_EVENT_POST_START_WORLD:
-	{
-		if (mono_profiler_gc_in_progress ()) {
-			GHashTable *cache = NULL;
-			uint64_t enabled_keywords = MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_EVENTPIPE_Context.EnabledKeywordsBitmask;
-			if (mono_profiler_gc_heap_collect_in_progress () && profiler_callback_is_enabled (enabled_keywords, GC_HEAP_DUMP_VTABLE_CLASS_REF_KEYWORD))
-				cache = g_hash_table_new_full (NULL, NULL, NULL, NULL);
-			mono_profiler_fire_buffered_gc_events_in_alloc_order (cache);
-			mono_profiler_fire_cached_gc_events (cache);
-			if (cache)
-				g_hash_table_destroy (cache);
-			if (mono_profiler_gc_heap_collect_in_progress ()) {
-				FireEtwMonoProfilerGCHeapDumpStop (
-					NULL,
-					NULL);
-			}
-			FireEtwMonoProfilerGCEvent (
-				(uint8_t)gc_event,
-				generation,
-				NULL,
-				NULL);
-			if (!profiler_callback_is_enabled (enabled_keywords, GC_KEYWORD))
-				mono_profiler_set_gc_event_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-			mono_profiler_gc_heap_collect_in_progress_stop ();
-			mono_profiler_gc_in_progress_stop ();
-		}
-		break;
-	}
-	default:
-		break;
-	}
-}
-static
-void
-mono_profiler_gc_allocation (
-	MonoProfiler *prof,
-	MonoObject *object)
-{
-	if (!EventEnabledMonoProfilerGCAllocation ())
-		return;
-	uint64_t vtable_id = 0;
-	uint64_t object_size = 0;
-	if (object) {
-		vtable_id = (uint64_t)mono_object_get_vtable_internal (object);
-		object_size = (uint64_t)mono_object_get_size_internal (object);
-		/* account for object alignment */
-		object_size += 7;
-		object_size &= ~7;
-	}
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerGCAllocation (
-		vtable_id,
-		SGEN_POINTER_UNTAG_ALL (object),
-		object_size,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_gc_handle_created (
-	MonoProfiler *prof,
-	uint32_t handle,
-	MonoGCHandleType type,
-	MonoObject *object)
-{
-	if (!EventEnabledMonoProfilerGCHandleCreated ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerGCHandleCreated (
-		handle,
-		(uint8_t)type,
-		SGEN_POINTER_UNTAG_ALL (object),
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_gc_handle_deleted (
-	MonoProfiler *prof,
-	uint32_t handle,
-	MonoGCHandleType type)
-{
-	if (!EventEnabledMonoProfilerGCHandleDeleted ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerGCHandleDeleted (
-		handle,
-		(uint8_t)type,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_gc_finalizing (MonoProfiler *prof)
-{
-	if (!EventEnabledMonoProfilerGCFinalizing ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerGCFinalizing (
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_gc_finalized (MonoProfiler *prof)
-{
-	if (!EventEnabledMonoProfilerGCFinalized ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerGCFinalized (
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_gc_finalizing_object (
-	MonoProfiler *prof,
-	MonoObject *object)
-{
-	if (!EventEnabledMonoProfilerGCFinalizingObject ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerGCFinalizingObject (
-		SGEN_POINTER_UNTAG_ALL (object),
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_gc_finalized_object (
-	MonoProfiler *prof,
-	MonoObject * object)
-{
-	if (!EventEnabledMonoProfilerGCFinalizedObject ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerGCFinalizedObject (
-		SGEN_POINTER_UNTAG_ALL (object),
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_gc_root_register (
-	MonoProfiler *prof,
-	const mono_byte *start,
-	uintptr_t size,
-	MonoGCRootSource source,
-	const void * key,
-	const char * name)
-{
-	if (!EventEnabledMonoProfilerGCRootRegister ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerGCRootRegister (
-		start,
-		(uint64_t)size,
-		(uint8_t) source,
-		(uint64_t)key,
-		(const ep_char8_t *)(name ? name : ""),
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_gc_root_unregister (
-	MonoProfiler *prof,
-	const mono_byte *start)
-{
-	if (!EventEnabledMonoProfilerGCRootUnregister ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerGCRootUnregister (
-		start,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_monitor_contention (
-	MonoProfiler *prof,
-	MonoObject *object)
-{
-	if (!EventEnabledMonoProfilerMonitorContention ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerMonitorContention (
-		SGEN_POINTER_UNTAG_ALL (object),
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_monitor_failed (
-	MonoProfiler *prof,
-	MonoObject *object)
-{
-	if (!EventEnabledMonoProfilerMonitorFailed ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerMonitorFailed (
-		SGEN_POINTER_UNTAG_ALL (object),
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_monitor_acquired (
-	MonoProfiler *prof,
-	MonoObject *object)
-{
-	if (!EventEnabledMonoProfilerMonitorAcquired ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerMonitorAcquired (
-		SGEN_POINTER_UNTAG_ALL (object),
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_thread_started (
-	MonoProfiler *prof,
-	uintptr_t tid)
-{
-	if (!EventEnabledMonoProfilerThreadStarted ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerThreadStarted (
-		(uint64_t)tid,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_thread_stopping (
-	MonoProfiler *prof,
-	uintptr_t tid)
-{
-	if (!EventEnabledMonoProfilerThreadStopping ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerThreadStopping (
-		(uint64_t)tid,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_thread_stopped (
-	MonoProfiler *prof,
-	uintptr_t tid)
-{
-	if (!EventEnabledMonoProfilerThreadStopped ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerThreadStopped (
-		(uint64_t)tid,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_thread_exited (
-	MonoProfiler *prof,
-	uintptr_t tid)
-{
-	if (!EventEnabledMonoProfilerThreadExited ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerThreadExited (
-		(uint64_t)tid,
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-void
-mono_profiler_thread_name (
-	MonoProfiler *prof,
-	uintptr_t tid,
-	const char *name)
-{
-	if (!EventEnabledMonoProfilerThreadName ())
-		return;
-	mono_profiler_fire_event_enter ();
-	FireEtwMonoProfilerThreadName (
-		(uint64_t)tid,
-		(ep_char8_t *)(name ? name : ""),
-		NULL,
-		NULL);
-	mono_profiler_fire_event_exit ();
-}
-static
-const EventFilterDescriptor *
-mono_profiler_add_provider_param (const EventFilterDescriptor *key)
-{
-	ep_rt_spin_lock_requires_lock_held (&_ep_rt_mono_profiler_gc_state_lock);
-	EventFilterDescriptor *param = NULL;
-	if (key && key->ptr && key->size) {
-		uint64_t param_ptr = (uint64_t)g_malloc (key->size);
-		if (param_ptr) {
-			param = ep_event_filter_desc_alloc (param_ptr, key->size, key->type);
-			if (param) {
-				memcpy ((uint8_t*)(uintptr_t)param->ptr,(const uint8_t*)(uintptr_t)key->ptr, key->size);
-				_ep_rt_mono_profiler_provider_params = g_slist_append (_ep_rt_mono_profiler_provider_params, param);
-			} else {
-				g_free ((void *)(uintptr_t)param_ptr);
-			}
-		}
-	}
-	return param;
-}
-static
-bool
-mono_profiler_remove_provider_param (const EventFilterDescriptor *key)
-{
-	ep_rt_spin_lock_requires_lock_held (&_ep_rt_mono_profiler_gc_state_lock);
-	bool removed = false;
-	if (_ep_rt_mono_profiler_provider_params && key && key->ptr && key->size) {
-		GSList *list = _ep_rt_mono_profiler_provider_params;
-		EventFilterDescriptor *param = NULL;
-		while (list) {
-			param = (EventFilterDescriptor *)(list->data);
-			if (param && param->ptr && param->type == key->type && param->size == key->size &&
-				memcmp ((const void *)(uintptr_t)param->ptr, (const void *)(uintptr_t)key->ptr, param->size) == 0) {
-					g_free ((void *)(uintptr_t)param->ptr);
-					ep_event_filter_desc_free (param);
-					_ep_rt_mono_profiler_provider_params = g_slist_delete_link (_ep_rt_mono_profiler_provider_params, list);
-					removed = true;
-					break;
-			}
-			list = list->next;
-		}
-	}
-	return removed;
-}
-static
-void
-mono_profiler_free_provider_params (void)
-{
-	for (GSList *list = _ep_rt_mono_profiler_provider_params; list; list = list->next) {
-		EventFilterDescriptor *param = (EventFilterDescriptor *)(list->data);
-		if (param) {
-			g_free ((void *)(uintptr_t)param->ptr);
-			ep_event_filter_desc_free (param);
-		}
-	}
-	g_slist_free (_ep_rt_mono_profiler_provider_params);
-	_ep_rt_mono_profiler_provider_params = NULL;
-}
-static
-bool
-mono_profiler_provider_params_get_value (
-	const EventFilterDescriptor *param,
-	const ep_char8_t *key,
-	const ep_char8_t **value)
-{
-	if (!param || !param->ptr || !param->size || !key)
-		return false;
-	const ep_char8_t *current = (ep_char8_t *)(uintptr_t)param->ptr;
-	const ep_char8_t *end = current + param->size;
-	bool found_key = false;
-	if (value)
-		*value = "";
-	if (!current [param->size - 1]) {
-		while (current < end) {
-			if (found_key) {
-				if (value)
-					*value = current;
-				break;
-			}
-			if (!ep_rt_utf8_string_compare_ignore_case (current, key)) {
-				found_key = true;
-			}
-			current = current + strlen (current) + 1;
-		}
-	}
-	return found_key;
-}
-static
-bool
-mono_profiler_provider_param_contains_heap_collect_ondemand (const EventFilterDescriptor *param)
-{
-	const ep_char8_t *value = NULL;
-	bool found_heap_collect_ondemand_value = false;
-	if (mono_profiler_provider_params_get_value (param, "heapcollect", &value)) {
-		if (strstr (value, "ondemand"))
-			found_heap_collect_ondemand_value = true;
-	}
-	return found_heap_collect_ondemand_value;
-}
-static
-void
-mono_profiler_push_gc_heap_collect_param_request_value (const EventFilterDescriptor *param)
-{
-	ep_rt_spin_lock_requires_lock_held (&_ep_rt_mono_profiler_gc_state_lock);
-	const ep_char8_t *value = NULL;
-	if (param)
-		mono_profiler_provider_params_get_value (param, "heapcollect", &value);
-	if (!_ep_rt_mono_profiler_gc_heap_collect_request_params)
-		_ep_rt_mono_profiler_gc_heap_collect_request_params = g_queue_new ();
-	if (_ep_rt_mono_profiler_gc_heap_collect_request_params)
-		g_queue_push_tail (_ep_rt_mono_profiler_gc_heap_collect_request_params, (gpointer)ep_rt_utf8_string_dup (value ? value : ""));
-}
-static
-void
-mono_profiler_pop_gc_heap_collect_param_request_value (void)
-{
-	ep_rt_spin_lock_requires_lock_held (&_ep_rt_mono_profiler_gc_state_lock);
-	ep_char8_t *value = NULL;
-	if (_ep_rt_mono_profiler_gc_heap_collect_request_params && !g_queue_is_empty (_ep_rt_mono_profiler_gc_heap_collect_request_params))
-		value = (ep_char8_t *)g_queue_pop_head (_ep_rt_mono_profiler_gc_heap_collect_request_params);
-	g_free (value);
-}
-static
-const ep_char8_t *
-mono_profiler_get_gc_heap_collect_param_request_value (void)
-{
-	ep_rt_spin_lock_requires_lock_held (&_ep_rt_mono_profiler_gc_state_lock);
-	ep_char8_t *value = NULL;
-	if (_ep_rt_mono_profiler_gc_heap_collect_request_params && !g_queue_is_empty (_ep_rt_mono_profiler_gc_heap_collect_request_params)) {
-		value = (ep_char8_t *)g_queue_pop_head (_ep_rt_mono_profiler_gc_heap_collect_request_params);
-		g_queue_push_head (_ep_rt_mono_profiler_gc_heap_collect_request_params, (gpointer)value);
-	}
-	return value ? value : "";
-}
-static
-void
-mono_profiler_free_gc_heap_collect_param_requests (void)
-{
-	if (_ep_rt_mono_profiler_gc_heap_collect_request_params) {
-		while (!g_queue_is_empty (_ep_rt_mono_profiler_gc_heap_collect_request_params))
-			g_free (g_queue_pop_head (_ep_rt_mono_profiler_gc_heap_collect_request_params));
-		g_queue_free (_ep_rt_mono_profiler_gc_heap_collect_request_params);
-		_ep_rt_mono_profiler_gc_heap_collect_request_params = NULL;
-	}
-}
-static
-void
-mono_profiler_ep_provider_callback (
-	const uint8_t *source_id,
-	unsigned long is_enabled,
-	uint8_t level,
-	uint64_t match_any_keywords,
-	uint64_t match_all_keywords,
-	EventFilterDescriptor *filter_data,
-	void *callback_data)
-{
-	ep_rt_config_requires_lock_not_held ();
-	ep_rt_spin_lock_requires_lock_held (&_ep_rt_mono_profiler_gc_state_lock);
-	EP_ASSERT(is_enabled == 0 || is_enabled == 1) ;
-	EP_ASSERT (_ep_rt_dotnet_mono_profiler_provider != NULL);
-	EP_ASSERT (_ep_rt_dotnet_mono_profiler_heap_collect_provider != NULL);
-	match_any_keywords = (is_enabled == 1) ? match_any_keywords : 0;
-	EP_LOCK_ENTER (section1)
-		uint64_t enabled_keywords = MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_EVENTPIPE_Context.EnabledKeywordsBitmask;
-		if (profiler_callback_is_enabled(match_any_keywords, LOADER_KEYWORD)) {
-			if (!profiler_callback_is_enabled (enabled_keywords, LOADER_KEYWORD)) {
-				mono_profiler_set_domain_loading_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_app_domain_loading);
-				mono_profiler_set_domain_loaded_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_app_domain_loaded);
-				mono_profiler_set_domain_unloading_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_app_domain_unloading);
-				mono_profiler_set_domain_unloaded_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_app_domain_unloaded);
-				mono_profiler_set_domain_name_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_app_domain_name);
-				mono_profiler_set_image_loading_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_module_loading);
-				mono_profiler_set_image_failed_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_module_failed);
-				mono_profiler_set_image_loaded_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_module_loaded);
-				mono_profiler_set_image_unloading_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_module_unloading);
-				mono_profiler_set_image_unloaded_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_module_unloaded);
-				mono_profiler_set_assembly_loading_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_assembly_loading);
-				mono_profiler_set_assembly_loaded_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_assembly_loaded);
-				mono_profiler_set_assembly_unloading_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_assembly_unloading);
-				mono_profiler_set_assembly_unloaded_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_assembly_unloaded);
-			}
-		} else {
-			if (profiler_callback_is_enabled (enabled_keywords, LOADER_KEYWORD)) {
-				mono_profiler_set_domain_loading_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_domain_loaded_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_domain_unloading_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_domain_unloaded_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_domain_name_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_image_loading_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_image_failed_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_image_loaded_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_image_unloading_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_image_unloaded_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_assembly_loading_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_assembly_loaded_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_assembly_unloading_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_assembly_unloaded_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-			}
-		}
-		if (profiler_callback_is_enabled(match_any_keywords, JIT_KEYWORD)) {
-			if (!profiler_callback_is_enabled (enabled_keywords, JIT_KEYWORD)) {
-				mono_profiler_set_jit_begin_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_jit_begin);
-				mono_profiler_set_jit_failed_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_jit_failed);
-				mono_profiler_set_jit_done_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_jit_done);
-				mono_profiler_set_jit_chunk_created_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_jit_chunk_created);
-				mono_profiler_set_jit_chunk_destroyed_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_jit_chunk_destroyed);
-				mono_profiler_set_jit_code_buffer_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_jit_code_buffer);
-			}
-		} else {
-			if (profiler_callback_is_enabled (enabled_keywords, JIT_KEYWORD)) {
-				mono_profiler_set_jit_begin_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_jit_failed_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_jit_done_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_jit_chunk_created_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_jit_chunk_destroyed_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_jit_code_buffer_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-			}
-		}
-		if (profiler_callback_is_enabled(match_any_keywords, TYPE_LOADING_KEYWORD)) {
-			if (!profiler_callback_is_enabled (enabled_keywords, TYPE_LOADING_KEYWORD)) {
-				mono_profiler_set_class_loading_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_class_loading);
-				mono_profiler_set_class_failed_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_class_failed);
-				mono_profiler_set_class_loaded_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_class_loaded);
-				mono_profiler_set_vtable_loading_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_vtable_loading);
-				mono_profiler_set_vtable_failed_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_vtable_failed);
-				mono_profiler_set_vtable_loaded_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_vtable_loaded);
-			}
-		} else {
-			if (profiler_callback_is_enabled (enabled_keywords, TYPE_LOADING_KEYWORD)) {
-				mono_profiler_set_class_loading_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_class_failed_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_class_loaded_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_vtable_loading_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_vtable_failed_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_vtable_loaded_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-			}
-		}
-		if (profiler_callback_is_enabled(match_any_keywords, METHOD_TRACING_KEYWORD)) {
-			if (!profiler_callback_is_enabled (enabled_keywords, METHOD_TRACING_KEYWORD)) {
-				mono_profiler_set_method_enter_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_method_enter);
-				mono_profiler_set_method_leave_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_method_leave);
-				mono_profiler_set_method_tail_call_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_method_tail_call);
-				mono_profiler_set_method_exception_leave_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_method_exception_leave);
-				mono_profiler_set_method_free_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_method_free);
-				mono_profiler_set_method_begin_invoke_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_method_begin_invoke);
-				mono_profiler_set_method_end_invoke_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_method_end_invoke);
-			}
-		} else {
-			if (profiler_callback_is_enabled (enabled_keywords, METHOD_TRACING_KEYWORD)) {
-				mono_profiler_set_method_enter_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_method_leave_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_method_tail_call_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_method_exception_leave_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_method_free_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_method_begin_invoke_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_method_end_invoke_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-			}
-		}
-		if (profiler_callback_is_enabled(match_any_keywords, EXCEPTION_KEYWORD)) {
-			if (!profiler_callback_is_enabled (enabled_keywords, EXCEPTION_KEYWORD)) {
-				mono_profiler_set_exception_throw_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_exception_throw);
-				mono_profiler_set_exception_clause_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_exception_clause);
-			}
-		} else {
-			if (profiler_callback_is_enabled (enabled_keywords, EXCEPTION_KEYWORD)) {
-				mono_profiler_set_exception_throw_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_exception_clause_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-			}
-		}
-		if (profiler_callback_is_enabled(match_any_keywords, GC_KEYWORD)) {
-			if (!profiler_callback_is_enabled (enabled_keywords, GC_KEYWORD)) {
-				mono_profiler_set_gc_event_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_gc_event);
-			}
-		} else {
-		}
-		if (profiler_callback_is_enabled(match_any_keywords, GC_ALLOCATION_KEYWORD)) {
-			if (!profiler_callback_is_enabled (enabled_keywords, GC_ALLOCATION_KEYWORD)) {
-				mono_profiler_set_gc_allocation_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_gc_allocation);
-			}
-		} else {
-			if (profiler_callback_is_enabled (enabled_keywords, GC_ALLOCATION_KEYWORD)) {
-				mono_profiler_set_gc_allocation_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-			}
-		}
-		if (profiler_callback_is_enabled(match_any_keywords, GC_HANDLE_KEYWORD)) {
-			if (!profiler_callback_is_enabled (enabled_keywords, GC_HANDLE_KEYWORD)) {
-				mono_profiler_set_gc_handle_created_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_gc_handle_created);
-				mono_profiler_set_gc_handle_deleted_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_gc_handle_deleted);
-			}
-		} else {
-			if (profiler_callback_is_enabled (enabled_keywords, GC_HANDLE_KEYWORD)) {
-				mono_profiler_set_gc_handle_created_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_gc_handle_deleted_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-			}
-		}
-		if (profiler_callback_is_enabled(match_any_keywords, GC_FINALIZATION_KEYWORD)) {
-			if (!profiler_callback_is_enabled (enabled_keywords, GC_FINALIZATION_KEYWORD)) {
-				mono_profiler_set_gc_finalizing_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_gc_finalizing);
-				mono_profiler_set_gc_finalized_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_gc_finalized);
-				mono_profiler_set_gc_finalizing_object_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_gc_finalizing_object);
-				mono_profiler_set_gc_finalized_object_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_gc_finalized_object);
-			}
-		} else {
-			if (profiler_callback_is_enabled (enabled_keywords, GC_FINALIZATION_KEYWORD)) {
-				mono_profiler_set_gc_finalizing_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_gc_finalized_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_gc_finalizing_object_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_gc_finalized_object_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-			}
-		}
-		if (profiler_callback_is_enabled(match_any_keywords, GC_ROOT_KEYWORD)) {
-			if (!profiler_callback_is_enabled (enabled_keywords, GC_ROOT_KEYWORD)) {
-				mono_profiler_set_gc_root_register_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_gc_root_register);
-				mono_profiler_set_gc_root_unregister_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_gc_root_unregister);
-			}
-		} else {
-			if (profiler_callback_is_enabled (enabled_keywords, GC_ROOT_KEYWORD)) {
-				mono_profiler_set_gc_root_register_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_gc_root_unregister_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-			}
-		}
-		if (profiler_callback_is_enabled(match_any_keywords, GC_HEAP_COLLECT_KEYWORD)) {
-			if (!profiler_callback_is_enabled (enabled_keywords, GC_HEAP_COLLECT_KEYWORD)) {
-				mono_profiler_set_gc_finalized_callback (_ep_rt_dotnet_mono_profiler_heap_collect_provider, mono_profiler_trigger_heap_collect);
-			}
-		} else {
-			if (profiler_callback_is_enabled (enabled_keywords, GC_HEAP_COLLECT_KEYWORD)) {
-				mono_profiler_set_gc_finalized_callback (_ep_rt_dotnet_mono_profiler_heap_collect_provider, NULL);
-			}
-		}
-		if (profiler_callback_is_enabled(match_any_keywords, MONITOR_KEYWORD) || profiler_callback_is_enabled(match_any_keywords, CONTENTION_KEYWORD)) {
-			if (!(profiler_callback_is_enabled(enabled_keywords, MONITOR_KEYWORD) && profiler_callback_is_enabled(enabled_keywords, CONTENTION_KEYWORD))) {
-				mono_profiler_set_monitor_contention_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_monitor_contention);
-			}
-		} else {
-			if (profiler_callback_is_enabled(enabled_keywords, MONITOR_KEYWORD) || profiler_callback_is_enabled(enabled_keywords, CONTENTION_KEYWORD)) {
-				mono_profiler_set_monitor_contention_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-			}
-		}
-		if (profiler_callback_is_enabled(match_any_keywords, MONITOR_KEYWORD)) {
-			if (!profiler_callback_is_enabled (enabled_keywords, MONITOR_KEYWORD)) {
-				mono_profiler_set_monitor_failed_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_monitor_failed);
-				mono_profiler_set_monitor_acquired_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_monitor_acquired);
-			}
-		} else {
-			if (profiler_callback_is_enabled (enabled_keywords, MONITOR_KEYWORD)) {
-				mono_profiler_set_monitor_failed_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_monitor_acquired_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-			}
-		}
-		if (profiler_callback_is_enabled(match_any_keywords, THREADING_KEYWORD)) {
-			if (!profiler_callback_is_enabled (enabled_keywords, THREADING_KEYWORD)) {
-				mono_profiler_set_thread_started_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_thread_started);
-				mono_profiler_set_thread_stopping_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_thread_stopping);
-				mono_profiler_set_thread_stopped_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_thread_stopped);
-				mono_profiler_set_thread_exited_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_thread_exited);
-				mono_profiler_set_thread_name_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_thread_name);
-			}
-		} else {
-			if (profiler_callback_is_enabled (enabled_keywords, THREADING_KEYWORD)) {
-				mono_profiler_set_thread_started_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_thread_stopping_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_thread_stopped_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_thread_exited_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				mono_profiler_set_thread_name_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-			}
-		}
-		if (!_ep_rt_dotnet_mono_profiler_provider_callspec.enabled) {
-			if (profiler_callback_is_enabled(match_any_keywords, METHOD_INSTRUMENTATION_KEYWORD)) {
-				if (!profiler_callback_is_enabled (enabled_keywords, METHOD_INSTRUMENTATION_KEYWORD)) {
-					mono_profiler_set_call_instrumentation_filter_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_method_instrumentation);
-				}
-			} else {
-				if (profiler_callback_is_enabled (enabled_keywords, METHOD_INSTRUMENTATION_KEYWORD)) {
-					mono_profiler_set_call_instrumentation_filter_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
-				}
-			}
-		}
-		if (match_any_keywords) {
-			bool request_heap_collect = false;
-			if (profiler_callback_is_enabled (match_any_keywords, GC_HEAP_COLLECT_KEYWORD)) {
-				if (mono_profiler_gc_can_collect_heap () && !profiler_callback_is_enabled (enabled_keywords, GC_HEAP_COLLECT_KEYWORD))
-					request_heap_collect = true;
-			}
-			if (filter_data) {
-				if (mono_profiler_provider_param_contains_heap_collect_ondemand (filter_data) && !mono_profiler_remove_provider_param (filter_data)) {
-					mono_profiler_add_provider_param (filter_data);
-					if (mono_profiler_gc_can_collect_heap () && profiler_callback_is_enabled (match_any_keywords, GC_HEAP_COLLECT_KEYWORD))
-						request_heap_collect = true;
-				}
-			}
-			if (request_heap_collect) {
-				mono_profiler_push_gc_heap_collect_param_request_value (filter_data);
-				mono_profiler_gc_heap_collect_requests_inc ();
-				mono_gc_finalize_notify ();
-			}
-		} else {
-			mono_profiler_free_provider_params ();
-		}
-		MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_EVENTPIPE_Context.Level = level;
-		MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_EVENTPIPE_Context.EnabledKeywordsBitmask = match_any_keywords;
-		MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_EVENTPIPE_Context.IsEnabled = (is_enabled == 1 ? true : false);
-	EP_LOCK_EXIT (section1)
-ep_on_exit:
-	ep_rt_config_requires_lock_not_held ();
-	return;
-ep_on_error:
-	ep_exit_error_handler ();
-}
-void
-EventPipeEtwCallbackDotNETRuntimeMonoProfiler (
-	const uint8_t *source_id,
-	unsigned long is_enabled,
-	uint8_t level,
-	uint64_t match_any_keywords,
-	uint64_t match_all_keywords,
-	EventFilterDescriptor *filter_data,
-	void *callback_data)
-{
-	ep_rt_spin_lock_requires_lock_not_held (&_ep_rt_mono_profiler_gc_state_lock);
-	EP_SPIN_LOCK_ENTER (&_ep_rt_mono_profiler_gc_state_lock, section1);
-		mono_profiler_ep_provider_callback (
-			source_id,
-			is_enabled,
-			level,
-			match_any_keywords,
-			match_all_keywords,
-			filter_data,
-			callback_data);
-	EP_SPIN_LOCK_EXIT (&_ep_rt_mono_profiler_gc_state_lock, section1);
-ep_on_exit:
-	ep_rt_spin_lock_requires_lock_not_held (&_ep_rt_mono_profiler_gc_state_lock);
-	return;
-ep_on_error:
-	ep_exit_error_handler ();
-}
-#endif /* ENABLE_PERFTRACING */
-MONO_EMPTY_SOURCE_FILE(eventpipe_rt_mono);

--- a/src/mono/mono/eventpipe/ep-rt-mono.h
+++ b//dev/null
@@ -1,2176 +0,0 @@
-#ifndef __EVENTPIPE_RT_MONO_H__
-#define __EVENTPIPE_RT_MONO_H__
-#include <config.h>
-#ifdef ENABLE_PERFTRACING
-#include <eventpipe/ep-rt-config.h>
-#include <eventpipe/ep-thread.h>
-#include <eventpipe/ep-types.h>
-#include <eventpipe/ep-provider.h>
-#include <eventpipe/ep-session-provider.h>
-#include <glib.h>
-#include <mono/utils/checked-build.h>
-#include <mono/utils/mono-threads.h>
-#include <mono/utils/mono-coop-mutex.h>
-#include <mono/utils/mono-proclib.h>
-#include <mono/utils/mono-time.h>
-#include <mono/utils/mono-rand.h>
-#include <mono/utils/mono-lazy-init.h>
-#include <mono/utils/w32api.h>
-#include <mono/metadata/assembly.h>
-#include <mono/metadata/w32event.h>
-#include <mono/metadata/metadata-internals.h>
-#include "mono/utils/mono-logger-internals.h"
-#include <runtime_version.h>
-#include <mono/metadata/profiler.h>
-#undef EP_INFINITE_WAIT
-#define EP_INFINITE_WAIT MONO_INFINITE_WAIT
-#undef EP_GCX_PREEMP_ENTER
-#define EP_GCX_PREEMP_ENTER {
-#undef EP_GCX_PREEMP_EXIT
-#define EP_GCX_PREEMP_EXIT }
-#undef EP_ALWAYS_INLINE
-#define EP_ALWAYS_INLINE MONO_ALWAYS_INLINE
-#undef EP_NEVER_INLINE
-#define EP_NEVER_INLINE MONO_NEVER_INLINE
-#undef EP_ALIGN_UP
-#define EP_ALIGN_UP(val,align) ALIGN_TO(val,align)
-#ifndef EP_RT_BUILD_TYPE_FUNC_NAME
-#define EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, type_name, func_name) \
-prefix_name ## _rt_ ## type_name ## _ ## func_name
-#endif
-#define EP_RT_DEFINE_LIST_PREFIX(prefix_name, list_name, list_type, item_type) \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, alloc) (list_type *list) { ; } \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, free) (list_type *list, void (*callback)(void *)) { \
-		if (list && list->list) { \
-			if (callback) { \
-				for (GSList *l = list->list; l; l = l->next) { \
-					callback (l->data); \
-				} \
-			} \
-			g_slist_free (list->list); \
-			list->list = NULL; \
-		} \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, clear) (list_type *list, void (*callback)(void *)) { \
-		EP_ASSERT (list != NULL); \
-		ep_rt_ ## list_name ## _free (list, callback); \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, append) (list_type *list, item_type item) { \
-		EP_ASSERT (list != NULL); \
-		list->list = g_slist_append (list->list, ((gpointer)(gsize)item)); \
-		return list->list != NULL; \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, remove) (list_type *list, const item_type item) { \
-		EP_ASSERT (list != NULL); \
-		list->list = g_slist_remove (list->list, ((gconstpointer)(const gsize)item)); \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, find) (const list_type *list, const item_type item_to_find, item_type *found_item) { \
-		EP_ASSERT (list != NULL && found_item != NULL); \
-		GSList *found_glist_item = g_slist_find (list->list, ((gconstpointer)(const gsize)item_to_find)); \
-		*found_item = (found_glist_item != NULL) ? ((item_type)(gsize)(found_glist_item->data)) : ((item_type)(gsize)NULL); \
-		return *found_item != NULL; \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, is_empty) (const list_type *list) { \
-		EP_ASSERT (list != NULL); \
-		return list->list == NULL; \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, is_valid) (const list_type *list) { return (list != NULL && list->list == NULL); }
-#undef EP_RT_DEFINE_LIST
-#define EP_RT_DEFINE_LIST(list_name, list_type, item_type) \
-	EP_RT_DEFINE_LIST_PREFIX(ep, list_name, list_type, item_type)
-#define EP_RT_DEFINE_LIST_ITERATOR_PREFIX(prefix_name, list_name, list_type, iterator_type, item_type) \
-	static inline iterator_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, iterator_begin) (const list_type *list) { \
-		EP_ASSERT (list != NULL); \
-		iterator_type temp; \
-		temp.iterator = list->list; \
-		return temp;\
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, iterator_end) (const list_type *list, const iterator_type *iterator) { \
-		EP_ASSERT (list != NULL && iterator != NULL); \
-		return iterator->iterator == NULL; \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, iterator_next) (iterator_type *iterator) { \
-		EP_ASSERT (iterator != NULL); \
-		iterator->iterator = iterator->iterator->next; \
-	} \
-	static inline item_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, iterator_value) (const iterator_type *iterator) { \
-		EP_ASSERT (iterator != NULL); \
-		return ((item_type)(gsize)(iterator->iterator->data)); \
-	}
-#undef EP_RT_DEFINE_LIST_ITERATOR
-#define EP_RT_DEFINE_LIST_ITERATOR(list_name, list_type, iterator_type, item_type) \
-	EP_RT_DEFINE_LIST_ITERATOR_PREFIX(ep, list_name, list_type, iterator_type, item_type)
-#define EP_RT_DEFINE_QUEUE_PREFIX(prefix_name, queue_name, queue_type, item_type) \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, alloc) (queue_type *queue) { queue->queue = g_queue_new (); } \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, free) (queue_type *queue) { \
-		EP_ASSERT (queue != NULL); \
-		g_queue_free (queue->queue); \
-		queue->queue = NULL; \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, pop_head) (queue_type *queue, item_type *item) { \
-		EP_ASSERT (queue != NULL && item != NULL); \
-		*item = ((item_type)(gsize)g_queue_pop_head (queue->queue)); \
-		return true; \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, push_head) (queue_type *queue, item_type item) { \
-		EP_ASSERT (queue != NULL); \
-		g_queue_push_head (queue->queue, ((gpointer)(gsize)item)); \
-		return true; \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, push_tail) (queue_type *queue, item_type item) { \
-		EP_ASSERT (queue != NULL); \
-		g_queue_push_tail (queue->queue, ((gpointer)(gsize)item)); \
-		return true; \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, is_empty) (const queue_type *queue) { \
-		EP_ASSERT (queue != NULL); \
-		return (g_queue_is_empty (queue->queue) == TRUE) ? true : false; \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, is_valid) (const queue_type *queue) { return (queue != NULL && queue->queue != NULL); }
-#undef EP_RT_DEFINE_QUEUE
-#define EP_RT_DEFINE_QUEUE(queue_name, queue_type, item_type) \
-	EP_RT_DEFINE_QUEUE_PREFIX(ep, queue_name, queue_type, item_type)
-#define EP_RT_DEFINE_ARRAY_PREFIX(prefix_name, array_name, array_type, iterator_type, item_type) \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, alloc) (array_type *ep_array) { \
-		EP_ASSERT (ep_array != NULL); \
-		ep_array->array = g_array_new (FALSE, FALSE, (guint)sizeof (item_type)); \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, alloc_capacity) (array_type *ep_array, size_t capacity) { \
-		EP_ASSERT (ep_array != NULL); \
-		ep_array->array = g_array_sized_new (FALSE, FALSE, (guint)sizeof (item_type), (guint)capacity); \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, free) (array_type *ep_array) { \
-		EP_ASSERT (ep_array != NULL); \
-		g_array_free (ep_array->array, TRUE); \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, append) (array_type *ep_array, item_type item) { \
-		EP_ASSERT (ep_array != NULL); \
-		return g_array_append_val (ep_array->array, item) != NULL; \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, clear) (array_type *ep_array) { \
-		EP_ASSERT (ep_array != NULL); \
-		g_array_set_size (ep_array->array, 0); \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, remove) (array_type *ep_array, iterator_type *pos) { \
-		EP_ASSERT (ep_array != NULL && pos != NULL); \
-		EP_ASSERT (pos->index < ep_array->array->len); \
-		ep_array->array = g_array_remove_index_fast (ep_array->array, pos->index); \
-	} \
-	static inline size_t EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, size) (const array_type *ep_array) { \
-		EP_ASSERT (ep_array != NULL); \
-		return ep_array->array->len; \
-	} \
-	static inline item_type * EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, data) (const array_type *ep_array) { \
-		EP_ASSERT (ep_array != NULL); \
-		return (item_type *)ep_array->array->data; \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, is_valid) (const array_type *ep_array) { return (ep_array != NULL && ep_array->array != NULL); }
-#define EP_RT_DEFINE_LOCAL_ARRAY_PREFIX(prefix_name, array_name, array_type, iterator_type, item_type) \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, init) (array_type *ep_array) { \
-		EP_ASSERT (ep_array != NULL); \
-		ep_array->array = g_array_new (FALSE, FALSE, (guint)sizeof (item_type)); \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, init_capacity) (array_type *ep_array, size_t capacity) { \
-		EP_ASSERT (ep_array != NULL); \
-		ep_array->array = g_array_sized_new (FALSE, FALSE, (guint)sizeof (item_type), (guint)capacity); \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, fini) (array_type *ep_array) { \
-		EP_ASSERT (ep_array != NULL); \
-		g_array_free (ep_array->array, TRUE); \
-	}
-#undef EP_RT_DEFINE_ARRAY
-#define EP_RT_DEFINE_ARRAY(array_name, array_type, iterator_type, item_type) \
-	EP_RT_DEFINE_ARRAY_PREFIX(ep, array_name, array_type, iterator_type, item_type)
-#undef EP_RT_DEFINE_LOCAL_ARRAY
-#define EP_RT_DEFINE_LOCAL_ARRAY(array_name, array_type, iterator_type, item_type) \
-	EP_RT_DEFINE_LOCAL_ARRAY_PREFIX(ep, array_name, array_type, iterator_type, item_type)
-#define EP_RT_DEFINE_ARRAY_ITERATOR_PREFIX(prefix_name, array_name, array_type, iterator_type, item_type) \
-	static inline iterator_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, iterator_begin) (const array_type *ep_array) { \
-		EP_ASSERT (ep_array != NULL); \
-		iterator_type temp; \
-		temp.array = ep_array->array; \
-		temp.index = 0; \
-		return temp; \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, iterator_end) (const array_type *ep_array, const iterator_type *iterator) { \
-		EP_ASSERT (ep_array != NULL && iterator != NULL && iterator->array == ep_array->array); \
-		return iterator->index >= iterator->array->len; \
-	} \
-	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, iterator_next) (iterator_type *iterator) { \
-		EP_ASSERT (iterator != NULL); \
-		iterator->index++; \
-	} \
-	static item_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, iterator_value) (const iterator_type *iterator) { \
-		EP_ASSERT (iterator != NULL); \
-		return g_array_index(iterator->array, item_type, iterator->index); \
-	}
-#define EP_RT_DEFINE_ARRAY_REVERSE_ITERATOR_PREFIX(prefix_name, array_name, array_type, iterator_type, item_type) \
-	static inline iterator_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, reverse_iterator_begin) (const array_type *ep_array) { \
-		EP_ASSERT (ep_array != NULL); \
-		iterator_type temp; \
-		temp.array = ep_array->array; \
-		temp.index = ep_array->array->len - 1; \
-		return temp; \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, reverse_iterator_end) (const array_type *ep_array, const iterator_type *iterator) { \
-		EP_ASSERT (ep_array != NULL && iterator != NULL && iterator->array == ep_array->array); \
-		return iterator->index < 0; \
-	} \
-	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, reverse_iterator_next) (iterator_type *iterator) { \
-		EP_ASSERT (iterator != NULL && iterator->array != NULL); \
-		iterator->index--; \
-	} \
-	static item_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, reverse_iterator_value) (const iterator_type *iterator) { \
-		EP_ASSERT (iterator != NULL && iterator->array != NULL); \
-		EP_ASSERT (iterator->index >= 0); \
-		return g_array_index(iterator->array, item_type, iterator->index); \
-	}
-#undef EP_RT_DEFINE_ARRAY_ITERATOR
-#define EP_RT_DEFINE_ARRAY_ITERATOR(array_name, array_type, iterator_type, item_type) \
-	EP_RT_DEFINE_ARRAY_ITERATOR_PREFIX(ep, array_name, array_type, iterator_type, item_type)
-#undef EP_RT_DEFINE_ARRAY_REVERSE_ITERATOR
-#define EP_RT_DEFINE_ARRAY_REVERSE_ITERATOR(array_name, array_type, iterator_type, item_type) \
-	EP_RT_DEFINE_ARRAY_REVERSE_ITERATOR_PREFIX(ep, array_name, array_type, iterator_type, item_type)
-#define EP_RT_DEFINE_HASH_MAP_BASE_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, alloc) (hash_map_type *hash_map, ep_rt_hash_map_hash_callback_t hash_callback, ep_rt_hash_map_equal_callback_t eq_callback, void (*key_free_callback)(void *), void (*value_free_callback)(void *)) { \
-		EP_ASSERT (hash_map != NULL); \
-		EP_ASSERT (key_free_callback == NULL); \
-		hash_map->table = g_hash_table_new_full ((GHashFunc)hash_callback, (GEqualFunc)eq_callback, (GDestroyNotify)key_free_callback, (GDestroyNotify)value_free_callback); \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, free) (hash_map_type *hash_map) { \
-		EP_ASSERT (hash_map != NULL); \
-		g_hash_table_destroy (hash_map->table); \
-		hash_map->table = NULL; \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, add) (hash_map_type *hash_map, key_type key, value_type value) { \
-		EP_ASSERT (hash_map != NULL); \
-		EP_ASSERT (!g_hash_table_lookup_extended (hash_map->table, (gconstpointer)key, NULL, NULL)); \
-		g_hash_table_insert (hash_map->table, (gpointer)key, ((gpointer)(gsize)value)); \
-		return true; \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, remove_all) (hash_map_type *hash_map) { \
-		EP_ASSERT (hash_map != NULL); \
-		g_hash_table_remove_all (hash_map->table); \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, lookup) (const hash_map_type *hash_map, const key_type key, value_type *value) { \
-		EP_ASSERT (hash_map != NULL && value != NULL); \
-		gpointer _value = NULL; \
-		bool result = (g_hash_table_lookup_extended (hash_map->table, (gconstpointer)key, NULL, &_value) == TRUE) ? true : false; \
-		*value = ((value_type)(gsize)_value); \
-		return result; \
-	} \
-	static inline uint32_t EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, count) (const hash_map_type *hash_map) { \
-		EP_ASSERT (hash_map != NULL); \
-		return (hash_map->table != NULL) ? g_hash_table_size (hash_map->table) : 0; \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, is_valid) (const hash_map_type *hash_map) { \
-		EP_ASSERT (hash_map != NULL); \
-		return (hash_map != NULL && hash_map->table != NULL); \
-	}
-#define EP_RT_DEFINE_HASH_MAP_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
-	EP_RT_DEFINE_HASH_MAP_BASE_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, add_or_replace) (hash_map_type *hash_map, key_type key, value_type value) { \
-		EP_ASSERT (hash_map != NULL); \
-		g_hash_table_replace (hash_map->table, (gpointer)key, ((gpointer)(gsize)value)); \
-		return true; \
-	}
-#define EP_RT_DEFINE_HASH_MAP_REMOVE_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
-	EP_RT_DEFINE_HASH_MAP_BASE_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, remove) (hash_map_type *hash_map, const key_type key) { \
-		EP_ASSERT (hash_map != NULL); \
-		g_hash_table_remove (hash_map->table, (gconstpointer)key); \
-	}
-#undef EP_RT_DEFINE_HASH_MAP
-#define EP_RT_DEFINE_HASH_MAP(hash_map_name, hash_map_type, key_type, value_type) \
-	EP_RT_DEFINE_HASH_MAP_PREFIX(ep, hash_map_name, hash_map_type, key_type, value_type)
-#undef EP_RT_DEFINE_HASH_MAP_REMOVE
-#define EP_RT_DEFINE_HASH_MAP_REMOVE(hash_map_name, hash_map_type, key_type, value_type) \
-	EP_RT_DEFINE_HASH_MAP_REMOVE_PREFIX(ep, hash_map_name, hash_map_type, key_type, value_type)
-#define EP_RT_DEFINE_HASH_MAP_ITERATOR_PREFIX(prefix_name, hash_map_name, hash_map_type, iterator_type, key_type, value_type) \
-	static inline iterator_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_begin) (const hash_map_type *hash_map) { \
-		EP_ASSERT (hash_map != NULL); \
-		iterator_type temp; \
-		g_hash_table_iter_init (&temp.iterator, hash_map->table); \
-		if (hash_map->table && g_hash_table_size (hash_map->table) > 0) \
-			temp.end = !g_hash_table_iter_next (&temp.iterator, &temp.key, &temp.value); \
-		else \
-			temp.end = true; \
-		return temp; \
-	} \
-	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_end) (const hash_map_type *hash_map, const iterator_type *iterator) { \
-		EP_ASSERT (hash_map != NULL && iterator != NULL); \
-		return iterator->end; \
-	} \
-	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_next) (iterator_type *iterator) { \
-		EP_ASSERT (iterator != NULL); \
-		iterator->end = !g_hash_table_iter_next (&iterator->iterator, &iterator->key, &iterator->value); \
-	} \
-	static inline key_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_key) (const iterator_type *iterator) { \
-		EP_ASSERT (iterator != NULL); \
-		return ((key_type)(gsize)iterator->key); \
-	} \
-	static inline value_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_value) (const iterator_type *iterator) { \
-		EP_ASSERT (iterator != NULL); \
-		return ((value_type)(gsize)iterator->value); \
-	}
-#undef EP_RT_DEFINE_HASH_MAP_ITERATOR
-#define EP_RT_DEFINE_HASH_MAP_ITERATOR(hash_map_name, hash_map_type, iterator_type, key_type, value_type) \
-	EP_RT_DEFINE_HASH_MAP_ITERATOR_PREFIX(ep, hash_map_name, hash_map_type, iterator_type, key_type, value_type)
-extern char *_ep_rt_mono_os_cmd_line;
-extern mono_lazy_init_t _ep_rt_mono_os_cmd_line_init;
-extern char *_ep_rt_mono_managed_cmd_line;
-extern mono_lazy_init_t _ep_rt_mono_managed_cmd_line_init;
-extern ep_rt_spin_lock_handle_t _ep_rt_mono_config_lock;
-extern char * ep_rt_mono_get_managed_cmd_line (void);
-extern char * ep_rt_mono_get_os_cmd_line (void);
-extern ep_rt_file_handle_t ep_rt_mono_file_open_write (const ep_char8_t *path);
-extern bool ep_rt_mono_file_close (ep_rt_file_handle_t handle);
-extern bool ep_rt_mono_file_write (ep_rt_file_handle_t handle, const uint8_t *buffer, uint32_t numbytes, uint32_t *byteswritten);
-extern void * ep_rt_mono_thread_attach (bool background_thread);
-extern void * ep_rt_mono_thread_attach_2 (bool background_thread, EventPipeThreadType thread_type);
-extern void ep_rt_mono_thread_detach (void);
-extern void ep_rt_mono_init (void);
-extern void ep_rt_mono_init_finish (void);
-extern void ep_rt_mono_fini (void);
-extern bool ep_rt_mono_walk_managed_stack_for_thread (ep_rt_thread_handle_t thread, EventPipeStackContents *stack_contents);
-extern bool ep_rt_mono_method_get_simple_assembly_name (ep_rt_method_desc_t *method, ep_char8_t *name, size_t name_len);
-extern bool ep_rt_mono_method_get_full_name (ep_rt_method_desc_t *method, ep_char8_t *name, size_t name_len);
-extern void ep_rt_mono_provider_config_init (EventPipeProviderConfiguration *provider_config);
-extern void ep_rt_mono_init_providers_and_events (void);
-extern bool ep_rt_mono_providers_validate_all_disabled (void);
-extern bool ep_rt_mono_sample_profiler_write_sampling_event_for_threads (ep_rt_thread_handle_t sampling_thread, EventPipeEvent *sampling_event);
-extern bool ep_rt_mono_rand_try_get_bytes (uint8_t *buffer,size_t buffer_size);
-extern void ep_rt_mono_execute_rundown (ep_rt_execution_checkpoint_array_t *execution_checkpoints);
-extern int64_t ep_rt_mono_perf_counter_query (void);
-extern int64_t ep_rt_mono_perf_frequency_query (void);
-extern void ep_rt_mono_system_time_get (EventPipeSystemTime *system_time);
-extern int64_t ep_rt_mono_system_timestamp_get (void);
-extern void ep_rt_mono_os_environment_get_utf16 (ep_rt_env_array_utf16_t *env_array);
-extern MonoNativeTlsKey _ep_rt_mono_thread_holder_tls_id;
-extern EventPipeThread * ep_rt_mono_thread_get_or_create (void);
-extern uint32_t ep_stack_hash_key_hash (const void *key);
-extern bool ep_stack_hash_key_equal (const void *key1, const void *key2);
-static
-inline
-char *
-os_command_line_get (void)
-{
-	return ep_rt_mono_get_os_cmd_line ();
-}
-static
-inline
-char **
-os_command_line_get_ref (void)
-{
-	return &_ep_rt_mono_os_cmd_line;
-}
-static
-inline
-mono_lazy_init_t *
-os_command_line_get_init (void)
-{
-	return &_ep_rt_mono_os_cmd_line_init;
-}
-static
-inline
-void
-os_command_line_lazy_init (void)
-{
-	if (!*os_command_line_get_ref ())
-		*os_command_line_get_ref () = os_command_line_get ();
-}
-static
-inline
-void
-os_command_line_lazy_clean (void)
-{
-	g_free (*os_command_line_get_ref ());
-	*os_command_line_get_ref () = NULL;
-}
-static
-inline
-char *
-managed_command_line_get (void)
-{
-	return ep_rt_mono_get_managed_cmd_line ();
-}
-static
-inline
-char **
-managed_command_line_get_ref (void)
-{
-	return &_ep_rt_mono_managed_cmd_line;
-}
-static
-inline
-mono_lazy_init_t *
-managed_command_line_get_init (void)
-{
-	return &_ep_rt_mono_managed_cmd_line_init;
-}
-static
-inline
-void
-managed_command_line_lazy_init (void)
-{
-	if (!*managed_command_line_get_ref ())
-		*managed_command_line_get_ref () = managed_command_line_get ();
-}
-static
-inline
-void
-managed_command_line_lazy_clean (void)
-{
-	g_free (*managed_command_line_get_ref ());
-	*managed_command_line_get_ref () = NULL;
-}
-static
-inline
-ep_rt_spin_lock_handle_t *
-ep_rt_mono_config_lock_get (void)
-{
-	return &_ep_rt_mono_config_lock;
-}
-/*
-* Helpers
-*/
-static
-inline
-EventPipeThreadHolder *
-thread_holder_alloc_func (void)
-{
-	EventPipeThreadHolder *instance = ep_thread_holder_alloc (ep_thread_alloc());
-	if (instance)
-		ep_thread_register (ep_thread_holder_get_thread (instance));
-	return instance;
-}
-static
-inline
-void
-thread_holder_free_func (EventPipeThreadHolder * thread_holder)
-{
-	if (thread_holder) {
-		ep_thread_unregister (ep_thread_holder_get_thread (thread_holder));
-		ep_thread_holder_free (thread_holder);
-	}
-}
-static
-inline
-MonoNativeThreadId
-ep_rt_mono_native_thread_id_get (void)
-{
-	return mono_native_thread_id_get ();
-}
-static
-inline
-gboolean
-ep_rt_mono_native_thread_id_equals (MonoNativeThreadId id1, MonoNativeThreadId id2)
-{
-	return mono_native_thread_id_equals (id1, id2);
-}
-static
-inline
-void
-ep_rt_mono_thread_setup (bool background_thread)
-{
-	ep_rt_mono_thread_attach (background_thread);
-}
-static
-inline
-void
-ep_rt_mono_thread_setup_2 (bool background_thread, EventPipeThreadType thread_type)
-{
-	ep_rt_mono_thread_attach_2 (background_thread, thread_type);
-}
-static
-inline
-void
-ep_rt_mono_thread_teardown (void)
-{
-	ep_rt_mono_thread_detach ();
-}
-/*
- * Little-Endian Conversion.
- */
-static
-EP_ALWAYS_INLINE
-uint16_t
-ep_rt_val_uint16_t (uint16_t value)
-{
-	return GUINT16_TO_LE (value);
-}
-static
-EP_ALWAYS_INLINE
-uint32_t
-ep_rt_val_uint32_t (uint32_t value)
-{
-	return GUINT32_TO_LE (value);
-}
-static
-EP_ALWAYS_INLINE
-uint64_t
-ep_rt_val_uint64_t (uint64_t value)
-{
-	return GUINT64_TO_LE (value);
-}
-static
-EP_ALWAYS_INLINE
-int16_t
-ep_rt_val_int16_t (int16_t value)
-{
-	return (int16_t)GUINT16_TO_LE ((uint16_t)value);
-}
-static
-EP_ALWAYS_INLINE
-int32_t
-ep_rt_val_int32_t (int32_t value)
-{
-	return (int32_t)GUINT32_TO_LE ((uint32_t)value);
-}
-static
-EP_ALWAYS_INLINE
-int64_t
-ep_rt_val_int64_t (int64_t value)
-{
-	return (int64_t)GUINT64_TO_LE ((uint64_t)value);
-}
-static
-EP_ALWAYS_INLINE
-uintptr_t
-ep_rt_val_uintptr_t (uintptr_t value)
-{
-#if SIZEOF_VOID_P == 4
-	return (uintptr_t)GUINT32_TO_LE ((uint32_t)value);
-#else
-	return (uintptr_t)GUINT64_TO_LE ((uint64_t)value);
-#endif
-}
-/*
-* Atomics.
-*/
-static
-inline
-uint32_t
-ep_rt_atomic_inc_uint32_t (volatile uint32_t *value)
-{
-	return (uint32_t)mono_atomic_inc_i32 ((volatile gint32 *)value);
-}
-static
-inline
-uint32_t
-ep_rt_atomic_dec_uint32_t (volatile uint32_t *value)
-{
-	return (uint32_t)mono_atomic_dec_i32 ((volatile gint32 *)value);
-}
-static
-inline
-int32_t
-ep_rt_atomic_inc_int32_t (volatile int32_t *value)
-{
-	return (int32_t)mono_atomic_inc_i32 ((volatile gint32 *)value);
-}
-static
-inline
-int32_t
-ep_rt_atomic_dec_int32_t (volatile int32_t *value)
-{
-	return (int32_t)mono_atomic_dec_i32 ((volatile gint32 *)value);
-}
-static
-inline
-int64_t
-ep_rt_atomic_inc_int64_t (volatile int64_t *value)
-{
-	return (int64_t)mono_atomic_inc_i64 ((volatile gint64 *)value);
-}
-static
-inline
-int64_t
-ep_rt_atomic_dec_int64_t (volatile int64_t *value)
-{
-	return (int64_t)mono_atomic_dec_i64 ((volatile gint64 *)value);
-}
-static
-inline
-size_t
-ep_rt_atomic_compare_exchange_size_t (volatile size_t *target, size_t expected, size_t value)
-{
-#if SIZEOF_SIZE_T == 8
-	return (size_t)(mono_atomic_cas_i64((volatile gint64*)(target), (gint64)(value), (gint64)(expected)));
-#else
-	return (size_t)(mono_atomic_cas_i32 ((volatile gint32 *)(target), (gint32)(value), (gint32)(expected)));
-#endif
-}
-static
-inline
-ep_char8_t *
-ep_rt_atomic_compare_exchange_utf8_string (ep_char8_t *volatile *target, ep_char8_t *expected, ep_char8_t *value)
-{
-	return (ep_char8_t *)mono_atomic_cas_ptr ((volatile gpointer *)target, (gpointer)value, (gpointer)expected);
-}
-/*
- * EventPipe.
- */
-EP_RT_DEFINE_ARRAY (session_id_array, ep_rt_session_id_array_t, ep_rt_session_id_array_iterator_t, EventPipeSessionID)
-EP_RT_DEFINE_ARRAY_ITERATOR (session_id_array, ep_rt_session_id_array_t, ep_rt_session_id_array_iterator_t, EventPipeSessionID)
-EP_RT_DEFINE_ARRAY (execution_checkpoint_array, ep_rt_execution_checkpoint_array_t, ep_rt_execution_checkpoint_array_iterator_t, EventPipeExecutionCheckpoint *)
-EP_RT_DEFINE_ARRAY_ITERATOR (execution_checkpoint_array, ep_rt_execution_checkpoint_array_t, ep_rt_execution_checkpoint_array_iterator_t, EventPipeExecutionCheckpoint *)
-static
-inline
-void
-ep_rt_init (void)
-{
-	ep_rt_mono_init ();
-	ep_rt_spin_lock_alloc (ep_rt_mono_config_lock_get ());
-}
-static
-inline
-void
-ep_rt_init_finish (void)
-{
-	ep_rt_mono_init_finish ();
-}
-static
-inline
-void
-ep_rt_shutdown (void)
-{
-	mono_lazy_cleanup (managed_command_line_get_init (), managed_command_line_lazy_clean);
-	mono_lazy_cleanup (os_command_line_get_init (), os_command_line_lazy_clean);
-	ep_rt_spin_lock_free (ep_rt_mono_config_lock_get ());
-	ep_rt_mono_fini ();
-}
-static
-inline
-bool
-ep_rt_config_acquire (void)
-{
-	return ep_rt_spin_lock_acquire (ep_rt_mono_config_lock_get ());
-}
-static
-inline
-bool
-ep_rt_config_release (void)
-{
-	return ep_rt_spin_lock_release (ep_rt_mono_config_lock_get ());
-}
-#ifdef EP_CHECKED_BUILD
-static
-inline
-void
-ep_rt_config_requires_lock_held (void)
-{
-	ep_rt_spin_lock_requires_lock_held (ep_rt_mono_config_lock_get ());
-}
-static
-inline
-void
-ep_rt_config_requires_lock_not_held (void)
-{
-	ep_rt_spin_lock_requires_lock_not_held (ep_rt_mono_config_lock_get ());
-}
-#endif
-static
-inline
-bool
-ep_rt_walk_managed_stack_for_thread (
-	ep_rt_thread_handle_t thread,
-	EventPipeStackContents *stack_contents)
-{
-	return ep_rt_mono_walk_managed_stack_for_thread (thread, stack_contents);
-}
-static
-inline
-bool
-ep_rt_method_get_simple_assembly_name (
-	ep_rt_method_desc_t *method,
-	ep_char8_t *name,
-	size_t name_len)
-{
-	return ep_rt_mono_method_get_simple_assembly_name (method, name, name_len);
-}
-static
-inline
-bool
-ep_rt_method_get_full_name (
-	ep_rt_method_desc_t *method,
-	ep_char8_t *name,
-	size_t name_len)
-{
-	return ep_rt_mono_method_get_full_name (method, name, name_len);
-}
-static
-inline
-void
-ep_rt_provider_config_init (EventPipeProviderConfiguration *provider_config)
-{
-	ep_rt_mono_provider_config_init (provider_config);
-}
-static
-inline
-void
-ep_rt_init_providers_and_events (void)
-{
-	ep_rt_mono_init_providers_and_events ();
-}
-static
-inline
-bool
-ep_rt_providers_validate_all_disabled (void)
-{
-	return ep_rt_mono_providers_validate_all_disabled ();
-}
-static
-inline
-void
-ep_rt_prepare_provider_invoke_callback (EventPipeProviderCallbackData *provider_callback_data)
-{
-	;
-}
-static
-inline
-void
-ep_rt_provider_invoke_callback (
-	EventPipeCallback callback_func,
-	const uint8_t *source_id,
-	unsigned long is_enabled,
-	uint8_t level,
-	uint64_t match_any_keywords,
-	uint64_t match_all_keywords,
-	EventFilterDescriptor *filter_data,
-	void *callback_data)
-{
-	EP_ASSERT (callback_func != NULL);
-	(*callback_func)(
-		source_id,
-		is_enabled,
-		level,
-		match_any_keywords,
-		match_all_keywords,
-		filter_data,
-		callback_data);
-}
-/*
- * EventPipeBuffer.
- */
-EP_RT_DEFINE_ARRAY (buffer_array, ep_rt_buffer_array_t, ep_rt_buffer_array_iterator_t, EventPipeBuffer *)
-EP_RT_DEFINE_LOCAL_ARRAY (buffer_array, ep_rt_buffer_array_t, ep_rt_buffer_array_iterator_t, EventPipeBuffer *)
-EP_RT_DEFINE_ARRAY_ITERATOR (buffer_array, ep_rt_buffer_array_t, ep_rt_buffer_array_iterator_t, EventPipeBuffer *)
-#undef EP_RT_DECLARE_LOCAL_BUFFER_ARRAY
-#define EP_RT_DECLARE_LOCAL_BUFFER_ARRAY(var_name) \
-	ep_rt_buffer_array_t var_name
-/*
- * EventPipeBufferList.
- */
-EP_RT_DEFINE_ARRAY (buffer_list_array, ep_rt_buffer_list_array_t, ep_rt_buffer_list_array_iterator_t, EventPipeBufferList *)
-EP_RT_DEFINE_LOCAL_ARRAY (buffer_list_array, ep_rt_buffer_list_array_t, ep_rt_buffer_list_array_iterator_t, EventPipeBufferList *)
-EP_RT_DEFINE_ARRAY_ITERATOR (buffer_list_array, ep_rt_buffer_list_array_t, ep_rt_buffer_list_array_iterator_t, EventPipeBufferList *)
-#undef EP_RT_DECLARE_LOCAL_BUFFER_LIST_ARRAY
-#define EP_RT_DECLARE_LOCAL_BUFFER_LIST_ARRAY(var_name) \
-	ep_rt_buffer_list_array_t var_name
-/*
- * EventPipeEvent.
- */
-EP_RT_DEFINE_LIST (event_list, ep_rt_event_list_t, EventPipeEvent *)
-EP_RT_DEFINE_LIST_ITERATOR (event_list, ep_rt_event_list_t, ep_rt_event_list_iterator_t, EventPipeEvent *)
-/*
- * EventPipeFile.
- */
-EP_RT_DEFINE_HASH_MAP_REMOVE(metadata_labels_hash, ep_rt_metadata_labels_hash_map_t, EventPipeEvent *, uint32_t)
-EP_RT_DEFINE_HASH_MAP(stack_hash, ep_rt_stack_hash_map_t, StackHashKey *, StackHashEntry *)
-EP_RT_DEFINE_HASH_MAP_ITERATOR(stack_hash, ep_rt_stack_hash_map_t, ep_rt_stack_hash_map_iterator_t, StackHashKey *, StackHashEntry *)
-#ifdef EP_RT_USE_CUSTOM_HASH_MAP_CALLBACKS
-static
-inline
-guint
-ep_rt_stack_hash_key_hash (gconstpointer key)
-{
-	return (guint)ep_stack_hash_key_hash (key);
-}
-static
-inline
-gboolean
-ep_rt_stack_hash_key_equal (gconstpointer key1, gconstpointer key2)
-{
-	return !!ep_stack_hash_key_equal (key1, key2);
-}
-#endif
-/*
- * EventPipeProvider.
- */
-EP_RT_DEFINE_LIST (provider_list, ep_rt_provider_list_t, EventPipeProvider *)
-EP_RT_DEFINE_LIST_ITERATOR (provider_list, ep_rt_provider_list_t, ep_rt_provider_list_iterator_t, EventPipeProvider *)
-EP_RT_DEFINE_QUEUE (provider_callback_data_queue, ep_rt_provider_callback_data_queue_t, EventPipeProviderCallbackData *)
-static
-inline
-int
-compare_provider_name (
-	gconstpointer a,
-	gconstpointer b)
-{
-	return (a) ? ep_rt_utf8_string_compare (ep_provider_get_provider_name ((EventPipeProvider *)a), (const ep_char8_t *)b) : 1;
-}
-static
-inline
-EventPipeProvider *
-ep_rt_provider_list_find_by_name (
-	const ep_rt_provider_list_t *list,
-	const ep_char8_t *name)
-{
-	GSList *item = g_slist_find_custom (list->list, name, compare_provider_name);
-	return (item != NULL) ? (EventPipeProvider *)item->data : NULL;
-}
-/*
- * EventPipeProviderConfiguration.
- */
-EP_RT_DEFINE_ARRAY (provider_config_array, ep_rt_provider_config_array_t, ep_rt_provider_config_array_iterator_t, EventPipeProviderConfiguration)
-EP_RT_DEFINE_ARRAY_ITERATOR (provider_config_array, ep_rt_provider_config_array_t, ep_rt_provider_config_array_iterator_t, EventPipeProviderConfiguration)
-static
-inline
-bool
-ep_rt_config_value_get_enable (void)
-{
-	bool enable = false;
-	gchar *value = g_getenv ("DOTNET_EnableEventPipe");
-	if (!value)
-		value = g_getenv ("COMPlus_EnableEventPipe");
-	if (value && atoi (value) == 1)
-		enable = true;
-	g_free (value);
-	return enable;
-}
-static
-inline
-ep_char8_t *
-ep_rt_config_value_get_config (void)
-{
-	gchar *value = g_getenv ("DOTNET_EventPipeConfig");
-	if (!value)
-		value = g_getenv ("COMPlus_EventPipeConfig");
-	return (ep_char8_t *)value;
-}
-static
-inline
-ep_char8_t *
-ep_rt_config_value_get_output_path (void)
-{
-	gchar *value = g_getenv ("DOTNET_EventPipeOutputPath");
-	if (!value)
-		value = g_getenv ("COMPlus_EventPipeOutputPath");
-	return (ep_char8_t *)value;
-}
-static
-inline
-uint32_t
-ep_rt_config_value_get_circular_mb (void)
-{
-	uint32_t circular_mb = 0;
-	gchar *value = g_getenv ("DOTNET_EventPipeCircularMB");
-	if (!value)
-		value = g_getenv ("COMPlus_EventPipeCircularMB");
-	if (value)
-		circular_mb = strtoul (value, NULL, 10);
-	g_free (value);
-	return circular_mb;
-}
-static
-inline
-bool
-ep_rt_config_value_get_output_streaming (void)
-{
-	bool enable = false;
-	gchar *value = g_getenv ("DOTNET_EventPipeOutputStreaming");
-	if (!value)
-		value = g_getenv ("COMPlus_EventPipeOutputStreaming");
-	if (value && atoi (value) == 1)
-		enable = true;
-	g_free (value);
-	return enable;
-}
-static
-inline
-bool
-ep_rt_config_value_get_use_portable_thread_pool (void)
-{
-	return true;
-}
-static
-inline
-uint32_t
-ep_rt_config_value_get_rundown (void)
-{
-	uint32_t value_uint32_t = 1;
-	gchar *value = g_getenv ("DOTNET_EventPipeRundown");
-	if (!value)
-		value = g_getenv ("COMPlus_EventPipeRundown");
-	if (value)
-		value_uint32_t = (uint32_t)atoi (value);
-	g_free (value);
-	return value_uint32_t;
-}
-static
-inline
-bool
-ep_rt_config_value_get_enable_stackwalk (void)
-{
-	uint32_t value_uint32_t = 1;
-	gchar *value = g_getenv ("DOTNET_EventPipeEnableStackwalk");
-	if (!value)
-		value = g_getenv ("COMPlus_EventPipeEnableStackwalk");
-	if (value)
-		value_uint32_t = (uint32_t)atoi (value);
-	g_free (value);
-	return value_uint32_t != 0;
-}
-/*
- * EventPipeSampleProfiler.
- */
-static
-void
-ep_rt_sample_profiler_write_sampling_event_for_threads (ep_rt_thread_handle_t sampling_thread, EventPipeEvent *sampling_event)
-{
-	ep_rt_mono_sample_profiler_write_sampling_event_for_threads (sampling_thread, sampling_event);
-}
-static
-void
-ep_rt_notify_profiler_provider_created (EventPipeProvider *provider)
-{
-	;
-}
-/*
- * EventPipeSessionProvider.
- */
-EP_RT_DEFINE_LIST (session_provider_list, ep_rt_session_provider_list_t, EventPipeSessionProvider *)
-EP_RT_DEFINE_LIST_ITERATOR (session_provider_list, ep_rt_session_provider_list_t, ep_rt_session_provider_list_iterator_t, EventPipeSessionProvider *)
-static
-inline
-int
-compare_session_provider_name (
-	gconstpointer a,
-	gconstpointer b)
-{
-	return (a) ? ep_rt_utf8_string_compare (ep_session_provider_get_provider_name ((EventPipeSessionProvider *)a), (const ep_char8_t *)b) : 1;
-}
-static
-inline
-EventPipeSessionProvider *
-ep_rt_session_provider_list_find_by_name (
-	const ep_rt_session_provider_list_t *list,
-	const ep_char8_t *name)
-{
-	GSList *item = g_slist_find_custom (list->list, name, compare_session_provider_name);
-	return (item != NULL) ? (EventPipeSessionProvider *)item->data : NULL;
-}
-/*
- * EventPipeSequencePoint.
- */
-EP_RT_DEFINE_LIST (sequence_point_list, ep_rt_sequence_point_list_t, EventPipeSequencePoint *)
-EP_RT_DEFINE_LIST_ITERATOR (sequence_point_list, ep_rt_sequence_point_list_t, ep_rt_sequence_point_list_iterator_t, EventPipeSequencePoint *)
-/*
- * EventPipeThread.
- */
-EP_RT_DEFINE_LIST (thread_list, ep_rt_thread_list_t, EventPipeThread *)
-EP_RT_DEFINE_LIST_ITERATOR (thread_list, ep_rt_thread_list_t, ep_rt_thread_list_iterator_t, EventPipeThread *)
-EP_RT_DEFINE_ARRAY (thread_array, ep_rt_thread_array_t, ep_rt_thread_array_iterator_t, EventPipeThread *)
-EP_RT_DEFINE_LOCAL_ARRAY (thread_array, ep_rt_thread_array_t, ep_rt_thread_array_iterator_t, EventPipeThread *)
-EP_RT_DEFINE_ARRAY_ITERATOR (thread_array, ep_rt_thread_array_t, ep_rt_thread_array_iterator_t, EventPipeThread *)
-#undef EP_RT_DECLARE_LOCAL_THREAD_ARRAY
-#define EP_RT_DECLARE_LOCAL_THREAD_ARRAY(var_name) \
-	ep_rt_thread_array_t var_name
-/*
- * EventPipeThreadSessionState.
- */
-EP_RT_DEFINE_LIST (thread_session_state_list, ep_rt_thread_session_state_list_t, EventPipeThreadSessionState *)
-EP_RT_DEFINE_LIST_ITERATOR (thread_session_state_list, ep_rt_thread_session_state_list_t, ep_rt_thread_session_state_list_iterator_t, EventPipeThreadSessionState *)
-EP_RT_DEFINE_ARRAY (thread_session_state_array, ep_rt_thread_session_state_array_t, ep_rt_thread_session_state_array_iterator_t, EventPipeThreadSessionState *)
-EP_RT_DEFINE_LOCAL_ARRAY (thread_session_state_array, ep_rt_thread_session_state_array_t, ep_rt_thread_session_state_array_iterator_t, EventPipeThreadSessionState *)
-EP_RT_DEFINE_ARRAY_ITERATOR (thread_session_state_array, ep_rt_thread_session_state_array_t, ep_rt_thread_session_state_array_iterator_t, EventPipeThreadSessionState *)
-#undef EP_RT_DECLARE_LOCAL_THREAD_SESSION_STATE_ARRAY
-#define EP_RT_DECLARE_LOCAL_THREAD_SESSION_STATE_ARRAY(var_name) \
-	ep_rt_thread_session_state_array_t var_name
-/*
- * Arrays.
- */
-static
-inline
-uint8_t *
-ep_rt_byte_array_alloc (size_t len)
-{
-	return g_new(uint8_t, len);
-}
-static
-inline
-void
-ep_rt_byte_array_free (uint8_t *ptr)
-{
-	g_free (ptr);
-}
-/*
- * Event.
- */
-static
-inline
-void
-ep_rt_wait_event_alloc (
-	ep_rt_wait_event_handle_t *wait_event,
-	bool manual,
-	bool initial)
-{
-	EP_ASSERT (wait_event != NULL);
-	wait_event->event = mono_w32event_create (manual, initial);
-}
-static
-inline
-void
-ep_rt_wait_event_free (ep_rt_wait_event_handle_t *wait_event)
-{
-	if (wait_event != NULL && wait_event->event != NULL) {
-		mono_w32event_close (wait_event->event);
-		wait_event->event = NULL;
-	}
-}
-static
-inline
-bool
-ep_rt_wait_event_set (ep_rt_wait_event_handle_t *wait_event)
-{
-	EP_ASSERT (wait_event != NULL && wait_event->event != NULL);
-	mono_w32event_set (wait_event->event);
-	return true;
-}
-static
-inline
-int32_t
-ep_rt_wait_event_wait (
-	ep_rt_wait_event_handle_t *wait_event,
-	uint32_t timeout,
-	bool alertable)
-{
-	EP_ASSERT (wait_event != NULL && wait_event->event != NULL);
-	return (int32_t)mono_w32handle_wait_one (wait_event->event, timeout, alertable);
-}
-static
-inline
-EventPipeWaitHandle
-ep_rt_wait_event_get_wait_handle (ep_rt_wait_event_handle_t *wait_event)
-{
-	EP_ASSERT (wait_event != NULL);
-	return (EventPipeWaitHandle)wait_event->event;
-}
-static
-inline
-bool
-ep_rt_wait_event_is_valid (ep_rt_wait_event_handle_t *wait_event)
-{
-	if (wait_event == NULL || wait_event->event == NULL || wait_event->event == INVALID_HANDLE_VALUE)
-		return false;
-	else
-		return true;
-}
-/*
- * Misc.
- */
-static
-inline
-int
-ep_rt_get_last_error (void)
-{
-#ifdef HOST_WIN32
-	return GetLastError ();
-#else
-	return errno;
-#endif
-}
-static
-inline
-bool
-ep_rt_process_detach (void)
-{
-	return FALSE;
-}
-static
-inline
-bool
-ep_rt_process_shutdown (void)
-{
-	return ep_rt_process_detach ();
-}
-static
-inline
-void
-ep_rt_create_activity_id (
-	uint8_t *activity_id,
-	uint32_t activity_id_len)
-{
-	EP_ASSERT (activity_id != NULL);
-	EP_ASSERT (activity_id_len == EP_ACTIVITY_ID_SIZE);
-	ep_rt_mono_rand_try_get_bytes ((guchar *)activity_id, EP_ACTIVITY_ID_SIZE);
-	const uint16_t version_mask = 0xF000;
-	const uint16_t random_guid_version = 0x4000;
-	const uint8_t clock_seq_hi_and_reserved_mask = 0xC0;
-	const uint8_t clock_seq_hi_and_reserved_value = 0x80;
-	uint8_t *activity_id_c = activity_id + sizeof (uint32_t) + sizeof (uint16_t);
-	uint8_t *activity_id_d = activity_id + sizeof (uint32_t) + sizeof (uint16_t) + sizeof (uint16_t);
-	uint16_t c;
-	memcpy (&c, activity_id_c, sizeof (c));
-	uint8_t d;
-	memcpy (&d, activity_id_d, sizeof (d));
-	c = ((c & ~version_mask) | random_guid_version);
-	d = ((d & ~clock_seq_hi_and_reserved_mask) | clock_seq_hi_and_reserved_value);
-	memcpy (activity_id_c, &c, sizeof (c));
-	memcpy (activity_id_d, &d, sizeof (d));
-}
-static
-inline
-bool
-ep_rt_is_running (void)
-{
-	return !ep_rt_process_detach ();
-}
-static
-inline
-void
-ep_rt_execute_rundown (ep_rt_execution_checkpoint_array_t *execution_checkpoints)
-{
-	if (ep_rt_config_value_get_rundown () > 0) {
-		if (/*is_running &&*/ !ep_rt_process_shutdown ()) {
-			ep_rt_mono_execute_rundown (execution_checkpoints);
-		}
-	}
-}
-/*
- * Objects.
- */
-#undef ep_rt_object_alloc
-#define ep_rt_object_alloc(obj_type) (g_new0 (obj_type, 1))
-#undef ep_rt_object_array_alloc
-#define ep_rt_object_array_alloc(obj_type,size) (g_new0 (obj_type, size))
-static
-inline
-void
-ep_rt_object_array_free (void *ptr)
-{
-	g_free (ptr);
-}
-static
-inline
-void
-ep_rt_object_free (void *ptr)
-{
-	g_free (ptr);
-}
-/*
- * PAL.
- */
-typedef struct _rt_mono_thread_params_internal_t {
-	ep_rt_thread_params_t thread_params;
-	bool background_thread;
-} rt_mono_thread_params_internal_t;
-#undef EP_RT_DEFINE_THREAD_FUNC
-#define EP_RT_DEFINE_THREAD_FUNC(name) static mono_thread_start_return_t WINAPI name (gpointer data)
-EP_RT_DEFINE_THREAD_FUNC (ep_rt_thread_mono_start_func)
-{
-	rt_mono_thread_params_internal_t *thread_params = (rt_mono_thread_params_internal_t *)data;
-	ep_rt_mono_thread_setup_2 (thread_params->background_thread, thread_params->thread_params.thread_type);
-	thread_params->thread_params.thread = ep_rt_thread_get_handle ();
-	mono_thread_start_return_t result = thread_params->thread_params.thread_func (thread_params);
-	ep_rt_mono_thread_teardown ();
-	g_free (thread_params);
-	return result;
-}
-static
-inline
-bool
-ep_rt_thread_create (
-	void *thread_func,
-	void *params,
-	EventPipeThreadType thread_type,
-	void *id)
-{
-	rt_mono_thread_params_internal_t *thread_params = g_new0 (rt_mono_thread_params_internal_t, 1);
-	if (thread_params) {
-		thread_params->thread_params.thread_type = thread_type;
-		thread_params->thread_params.thread_func = (ep_rt_thread_start_func)thread_func;
-		thread_params->thread_params.thread_params = params;
-		thread_params->background_thread = true;
-		return (mono_thread_platform_create_thread (ep_rt_thread_mono_start_func, thread_params, NULL, (ep_rt_thread_id_t *)id) == TRUE) ? true : false;
-	}
-	return false;
-}
-static
-inline
-void
-ep_rt_thread_sleep (uint64_t ns)
-{
-	MONO_REQ_GC_UNSAFE_MODE;
-	if (ns == 0) {
-		mono_thread_info_yield ();
-	} else {
-		MONO_ENTER_GC_SAFE;
-		g_usleep ((gulong)(ns / 1000));
-		MONO_EXIT_GC_SAFE;
-	}
-}
-static
-inline
-uint32_t
-ep_rt_current_process_get_id (void)
-{
-	return (uint32_t)mono_process_current_pid ();
-}
-static
-inline
-uint32_t
-ep_rt_current_processor_get_number (void)
-{
-	return 0xFFFFFFFF;
-}
-static
-inline
-uint32_t
-ep_rt_processors_get_count (void)
-{
-	return (uint32_t)mono_cpu_count ();
-}
-static
-inline
-ep_rt_thread_id_t
-ep_rt_current_thread_get_id (void)
-{
-	return mono_native_thread_id_get ();
-}
-static
-inline
-int64_t
-ep_rt_perf_counter_query (void)
-{
-	return ep_rt_mono_perf_counter_query ();
-}
-static
-inline
-int64_t
-ep_rt_perf_frequency_query (void)
-{
-	return ep_rt_mono_perf_frequency_query ();
-}
-static
-inline
-void
-ep_rt_system_time_get (EventPipeSystemTime *system_time)
-{
-	ep_rt_mono_system_time_get (system_time);
-}
-static
-inline
-int64_t
-ep_rt_system_timestamp_get (void)
-{
-	return ep_rt_mono_system_timestamp_get ();
-}
-static
-inline
-int32_t
-ep_rt_system_get_alloc_granularity (void)
-{
-	return (int32_t)mono_valloc_granule ();
-}
-static
-inline
-const ep_char8_t *
-ep_rt_os_command_line_get (void)
-{
-	if (!mono_lazy_is_initialized (os_command_line_get_init ())) {
-		char *cmd_line = os_command_line_get ();
-		if (!cmd_line)
-			return NULL;
-		g_free (cmd_line);
-	}
-	mono_lazy_initialize (os_command_line_get_init (), os_command_line_lazy_init);
-	EP_ASSERT (*os_command_line_get_ref () != NULL);
-	return *os_command_line_get_ref ();
-}
-static
-inline
-ep_rt_file_handle_t
-ep_rt_file_open_write (const ep_char8_t *path)
-{
-	ep_rt_file_handle_t res = ep_rt_mono_file_open_write (path);
-	return (res != INVALID_HANDLE_VALUE) ? res : NULL;
-}
-static
-inline
-bool
-ep_rt_file_close (ep_rt_file_handle_t file_handle)
-{
-	ep_return_false_if_nok (file_handle != NULL);
-	return ep_rt_mono_file_close (file_handle);
-}
-static
-inline
-bool
-ep_rt_file_write (
-	ep_rt_file_handle_t file_handle,
-	const uint8_t *buffer,
-	uint32_t bytes_to_write,
-	uint32_t *bytes_written)
-{
-	ep_return_false_if_nok (file_handle != NULL);
-	EP_ASSERT (buffer != NULL);
-	bool result = ep_rt_mono_file_write (file_handle, buffer, bytes_to_write, bytes_written);
-	if (result)
-		*bytes_written = bytes_to_write;
-	return result;
-}
-static
-inline
-uint8_t *
-ep_rt_valloc0 (size_t buffer_size)
-{
-	uint8_t *buffer = (uint8_t *)mono_valloc (NULL, buffer_size, MONO_MMAP_READ | MONO_MMAP_WRITE, MONO_MEM_ACCOUNT_PROFILER);
-	if (buffer)
-		memset (buffer, 0, buffer_size);
-	return buffer;
-}
-static
-inline
-void
-ep_rt_vfree (
-	uint8_t *buffer,
-	size_t buffer_size)
-{
-	if (buffer)
-		mono_vfree (buffer, buffer_size, MONO_MEM_ACCOUNT_PROFILER);
-}
-static
-inline
-uint32_t
-ep_rt_temp_path_get (
-	ep_char8_t *buffer,
-	uint32_t buffer_len)
-{
-	EP_ASSERT (buffer != NULL);
-	EP_ASSERT (buffer_len > 0);
-	const ep_char8_t *path = g_get_tmp_dir ();
-	int32_t result = snprintf (buffer, buffer_len, "%s", path);
-	if (result <= 0 || GINT32_TO_UINT32(result) > buffer_len)
-		ep_raise_error ();
-	if (buffer [result - 1] != G_DIR_SEPARATOR) {
-		buffer [result++] = G_DIR_SEPARATOR;
-		buffer [result] = '\0';
-	}
-ep_on_exit:
-	return result;
-ep_on_error:
-	result = 0;
-	ep_exit_error_handler ();
-}
-EP_RT_DEFINE_ARRAY (env_array_utf16, ep_rt_env_array_utf16_t, ep_rt_env_array_utf16_iterator_t, ep_char16_t *)
-EP_RT_DEFINE_ARRAY_ITERATOR (env_array_utf16, ep_rt_env_array_utf16_t, ep_rt_env_array_utf16_iterator_t, ep_char16_t *)
-static
-inline
-void
-ep_rt_os_environment_get_utf16 (ep_rt_env_array_utf16_t *env_array)
-{
-	ep_rt_mono_os_environment_get_utf16 (env_array);
-}
-/*
-* Lock.
-*/
-static
-bool
-ep_rt_lock_acquire (ep_rt_lock_handle_t *lock)
-{
-	EP_UNREACHABLE ("Not implemented on Mono.");
-}
-static
-bool
-ep_rt_lock_release (ep_rt_lock_handle_t *lock)
-{
-	EP_UNREACHABLE ("Not implemented on Mono.");
-}
-#ifdef EP_CHECKED_BUILD
-static
-inline
-void
-ep_rt_lock_requires_lock_held (const ep_rt_lock_handle_t *lock)
-{
-	EP_UNREACHABLE ("Not implemented on Mono.");
-}
-static
-inline
-void
-ep_rt_lock_requires_lock_not_held (const ep_rt_lock_handle_t *lock)
-{
-	EP_UNREACHABLE ("Not implemented on Mono.");
-}
-#endif
-/*
-* SpinLock.
-*/
-#ifdef EP_CHECKED_BUILD
-static
-inline
-void
-ep_rt_spin_lock_set_owning_thread_id (
-	ep_rt_spin_lock_handle_t *spin_lock,
-	MonoNativeThreadId thread_id)
-{
-MONO_DISABLE_WARNING(4127) /* conditional expression is constant */
-	if (sizeof (spin_lock->owning_thread_id) == sizeof (uint32_t))
-		ep_rt_volatile_store_uint32_t ((uint32_t *)&spin_lock->owning_thread_id, MONO_NATIVE_THREAD_ID_TO_UINT (thread_id));
-	else if (sizeof (spin_lock->owning_thread_id) == sizeof (uint64_t))
-		ep_rt_volatile_store_uint64_t ((uint64_t *)&spin_lock->owning_thread_id, MONO_NATIVE_THREAD_ID_TO_UINT (thread_id));
-	else
-		spin_lock->owning_thread_id = thread_id;
-MONO_RESTORE_WARNING
-}
-static
-inline
-MonoNativeThreadId
-ep_rt_spin_lock_get_owning_thread_id (const ep_rt_spin_lock_handle_t *spin_lock)
-{
-MONO_DISABLE_WARNING(4127) /* conditional expression is constant */
-	if (sizeof (spin_lock->owning_thread_id) == sizeof (uint32_t))
-		return MONO_UINT_TO_NATIVE_THREAD_ID (ep_rt_volatile_load_uint32_t ((const uint32_t *)&spin_lock->owning_thread_id));
-	else if (sizeof (spin_lock->owning_thread_id) == sizeof (uint64_t))
-		return MONO_UINT_TO_NATIVE_THREAD_ID (ep_rt_volatile_load_uint64_t ((const uint64_t *)&spin_lock->owning_thread_id));
-	else
-		return spin_lock->owning_thread_id;
-MONO_RESTORE_WARNING
-}
-#endif
-static
-inline
-void
-ep_rt_spin_lock_alloc (ep_rt_spin_lock_handle_t *spin_lock)
-{
-#ifdef EP_CHECKED_BUILD
-	ep_rt_spin_lock_set_owning_thread_id (spin_lock, MONO_UINT_TO_NATIVE_THREAD_ID (0));
-#endif
-	spin_lock->lock = g_new0 (MonoCoopMutex, 1);
-	if (spin_lock->lock)
-		mono_coop_mutex_init (spin_lock->lock);
-}
-static
-inline
-void
-ep_rt_spin_lock_free (ep_rt_spin_lock_handle_t *spin_lock)
-{
-	if (spin_lock && spin_lock->lock) {
-		mono_coop_mutex_destroy (spin_lock->lock);
-		g_free (spin_lock->lock);
-		spin_lock->lock = NULL;
-	}
-}
-static
-inline
-bool
-ep_rt_spin_lock_acquire (ep_rt_spin_lock_handle_t *spin_lock)
-{
-	if (spin_lock && spin_lock->lock) {
-		mono_coop_mutex_lock (spin_lock->lock);
-#ifdef EP_CHECKED_BUILD
-		ep_rt_spin_lock_set_owning_thread_id (spin_lock, ep_rt_mono_native_thread_id_get ());
-#endif
-	}
-	return true;
-}
-static
-inline
-bool
-ep_rt_spin_lock_release (ep_rt_spin_lock_handle_t *spin_lock)
-{
-	if (spin_lock && spin_lock->lock) {
-#ifdef EP_CHECKED_BUILD
-		ep_rt_spin_lock_set_owning_thread_id (spin_lock, MONO_UINT_TO_NATIVE_THREAD_ID (0));
-#endif
-		mono_coop_mutex_unlock (spin_lock->lock);
-	}
-	return true;
-}
-#ifdef EP_CHECKED_BUILD
-static
-inline
-void
-ep_rt_spin_lock_requires_lock_held (const ep_rt_spin_lock_handle_t *spin_lock)
-{
-	g_assert (ep_rt_mono_native_thread_id_equals (ep_rt_spin_lock_get_owning_thread_id (spin_lock), ep_rt_mono_native_thread_id_get ()));
-}
-static
-inline
-void
-ep_rt_spin_lock_requires_lock_not_held (const ep_rt_spin_lock_handle_t *spin_lock)
-{
-	g_assert (!ep_rt_mono_native_thread_id_equals (ep_rt_spin_lock_get_owning_thread_id (spin_lock), ep_rt_mono_native_thread_id_get ()));
-}
-#endif
-static
-bool
-ep_rt_spin_lock_is_valid (const ep_rt_spin_lock_handle_t *spin_lock)
-{
-	return (spin_lock != NULL && spin_lock->lock != NULL);
-}
-/*
- * String.
- */
-static
-inline
-int
-ep_rt_utf8_string_compare (
-	const ep_char8_t *str1,
-	const ep_char8_t *str2)
-{
-	return strcmp ((const char *)str1, (const char *)str2);
-}
-static
-inline
-int
-ep_rt_utf8_string_compare_ignore_case (
-	const ep_char8_t *str1,
-	const ep_char8_t *str2)
-{
-	return g_strcasecmp ((const char *)str1, (const char *)str2);
-}
-static
-inline
-bool
-ep_rt_utf8_string_is_null_or_empty (const ep_char8_t *str)
-{
-	if (str == NULL)
-		return true;
-	while (*str) {
-		if (!isspace(*str))
-			return false;
-		str++;
-	}
-	return true;
-}
-static
-inline
-ep_char8_t *
-ep_rt_utf8_string_dup (const ep_char8_t *str)
-{
-	return g_strdup (str);
-}
-static
-inline
-ep_char8_t *
-ep_rt_utf8_string_dup_range (const ep_char8_t *str, const ep_char8_t *strEnd)
-{
-	ptrdiff_t byte_len = strEnd - str;
-	ep_char8_t *buffer = g_new(ep_char8_t, byte_len + 1);
-	if (buffer != NULL)
-	{
-		memcpy (buffer, str, byte_len);
-		buffer [byte_len] = '\0';
-	}
-	return buffer;
-}
-static
-inline
-ep_char8_t *
-ep_rt_utf8_string_strtok (
-	ep_char8_t *str,
-	const ep_char8_t *delimiter,
-	ep_char8_t **context)
-{
-	return strtok_r (str, delimiter, context);
-}
-#undef ep_rt_utf8_string_snprintf
-#define ep_rt_utf8_string_snprintf( \
-	str, \
-	str_len, \
-	format, ...) \
-g_snprintf ((gchar *)str, (gulong)str_len, (const gchar *)format, __VA_ARGS__)
-static
-inline
-bool
-ep_rt_utf8_string_replace (
-	ep_char8_t **str,
-	const ep_char8_t *strSearch,
-	const ep_char8_t *strReplacement
-)
-{
-	if ((*str) == NULL)
-		return false;
-	ep_char8_t* strFound = strstr(*str, strSearch);
-	if (strFound != NULL)
-	{
-		size_t strSearchLen = strlen(strSearch);
-		size_t newStrSize = strlen(*str) + strlen(strReplacement) - strSearchLen + 1;
-		ep_char8_t *newStr =  g_new(ep_char8_t, newStrSize);
-		if (newStr == NULL)
-		{
-			*str = NULL;
-			return false;
-		}
-		ep_rt_utf8_string_snprintf(newStr, newStrSize, "%.*s%s%s", (int)(strFound - (*str)), *str, strReplacement, strFound + strSearchLen);
-		ep_rt_utf8_string_free(*str);
-		*str = newStr;
-		return true;
-	}
-	return false;
-}
-static
-inline
-ep_char16_t *
-ep_rt_utf8_to_utf16le_string (
-	const ep_char8_t *str,
-	size_t len)
-{
-	return (ep_char16_t *)(g_utf8_to_utf16le ((const gchar *)str, (glong)len, NULL, NULL, NULL));
-}
-static
-inline
-ep_char16_t *
-ep_rt_utf16_string_dup (const ep_char16_t *str)
-{
-	size_t str_size = (ep_rt_utf16_string_len (str) + 1) * sizeof (ep_char16_t);
-	ep_char16_t *str_dup = (ep_char16_t *)malloc (str_size);
-	if (str_dup)
-		memcpy (str_dup, str, str_size);
-	return str_dup;
-}
-static
-inline
-void
-ep_rt_utf8_string_free (ep_char8_t *str)
-{
-	g_free (str);
-}
-static
-inline
-size_t
-ep_rt_utf16_string_len (const ep_char16_t *str)
-{
-	return g_utf16_len ((const gunichar2 *)str);
-}
-static
-inline
-ep_char8_t *
-ep_rt_utf16_to_utf8_string (
-	const ep_char16_t *str,
-	size_t len)
-{
-	return g_utf16_to_utf8 ((const gunichar2 *)str, (glong)len, NULL, NULL, NULL);
-}
-static
-inline
-ep_char8_t *
-ep_rt_utf16le_to_utf8_string (
-	const ep_char16_t *str,
-	size_t len)
-{
-	return g_utf16le_to_utf8 ((const gunichar2 *)str, (glong)len, NULL, NULL, NULL);
-}
-static
-inline
-void
-ep_rt_utf16_string_free (ep_char16_t *str)
-{
-	g_free (str);
-}
-static
-inline
-const ep_char8_t *
-ep_rt_managed_command_line_get (void)
-{
-	if (!mono_lazy_is_initialized (managed_command_line_get_init ())) {
-		char *cmd_line = managed_command_line_get ();
-		if (!cmd_line)
-			return NULL;
-		g_free (cmd_line);
-	}
-	mono_lazy_initialize (managed_command_line_get_init (), managed_command_line_lazy_init);
-	EP_ASSERT (*managed_command_line_get_ref () != NULL);
-	return *managed_command_line_get_ref ();
-}
-static
-const ep_char8_t *
-ep_rt_diagnostics_command_line_get (void)
-{
-	const ep_char8_t * cmd_line = ep_rt_managed_command_line_get ();
-	if (cmd_line == NULL)
-		cmd_line = ep_rt_os_command_line_get ();
-	return cmd_line;
-}
-static
-inline
-const ep_char8_t *
-ep_rt_entrypoint_assembly_name_get_utf8 (void)
-{
-	MonoAssembly *main_assembly = mono_assembly_get_main ();
-	if (!main_assembly || !main_assembly->image)
-		return "";
-	const char *assembly_name = m_image_get_assembly_name (mono_assembly_get_main ()->image);
-	if (!assembly_name)
-		return "";
-	return (const ep_char8_t*)assembly_name;
-}
-static
-inline
-const ep_char8_t *
-ep_rt_runtime_version_get_utf8 (void)
-{
-	return (const ep_char8_t *)EGLIB_TOSTRING (RuntimeProductVersion);
-}
-/*
- * Thread.
- */
-static
-inline
-void
-ep_rt_thread_setup ()
-{
-	ep_rt_mono_thread_setup (false);
-}
-static
-inline
-EventPipeThread *
-ep_rt_thread_get (void)
-{
-	EventPipeThreadHolder *thread_holder = (EventPipeThreadHolder *)mono_native_tls_get_value (_ep_rt_mono_thread_holder_tls_id);
-	return thread_holder ? ep_thread_holder_get_thread (thread_holder) : NULL;
-}
-static
-inline
-EventPipeThread *
-ep_rt_thread_get_or_create (void)
-{
-	EventPipeThread *thread = ep_rt_thread_get ();
-	if (!thread) {
-		thread = ep_rt_mono_thread_get_or_create ();
-	}
-	return thread;
-}
-static
-inline
-ep_rt_thread_handle_t
-ep_rt_thread_get_handle (void)
-{
-	return mono_thread_info_current ();
-}
-static
-inline
-ep_rt_thread_id_t
-ep_rt_thread_get_id (ep_rt_thread_handle_t thread_handle)
-{
-	return mono_thread_info_get_tid (thread_handle);
-}
-static
-inline
-uint64_t
-ep_rt_thread_id_t_to_uint64_t (ep_rt_thread_id_t thread_id)
-{
-	return (uint64_t)MONO_NATIVE_THREAD_ID_TO_UINT (thread_id);
-}
-static
-inline
-ep_rt_thread_id_t
-ep_rt_uint64_t_to_thread_id_t (uint64_t thread_id)
-{
-	return MONO_UINT_TO_NATIVE_THREAD_ID (thread_id);
-}
-static
-inline
-bool
-ep_rt_thread_has_started (ep_rt_thread_handle_t thread_handle)
-{
-	return thread_handle == ep_rt_thread_get_handle ();
-}
-static
-inline
-ep_rt_thread_activity_id_handle_t
-ep_rt_thread_get_activity_id_handle (void)
-{
-	return ep_rt_thread_get_or_create ();
-}
-static
-inline
-const uint8_t *
-ep_rt_thread_get_activity_id_cref (ep_rt_thread_activity_id_handle_t activity_id_handle)
-{
-	EP_UNREACHABLE ("EP_THREAD_INCLUDE_ACTIVITY_ID should have been defined on Mono");
-	return NULL;
-}
-static
-inline
-void
-ep_rt_thread_get_activity_id (
-	ep_rt_thread_activity_id_handle_t activity_id_handle,
-	uint8_t *activity_id,
-	uint32_t activity_id_len)
-{
-	EP_ASSERT (activity_id_handle != NULL);
-	EP_ASSERT (activity_id != NULL);
-	EP_ASSERT (activity_id_len == EP_ACTIVITY_ID_SIZE);
-	memcpy (activity_id, ep_thread_get_activity_id_cref (activity_id_handle), EP_ACTIVITY_ID_SIZE);
-}
-static
-inline
-void
-ep_rt_thread_set_activity_id (
-	ep_rt_thread_activity_id_handle_t activity_id_handle,
-	const uint8_t *activity_id,
-	uint32_t activity_id_len)
-{
-	EP_ASSERT (activity_id_handle != NULL);
-	EP_ASSERT (activity_id != NULL);
-	EP_ASSERT (activity_id_len == EP_ACTIVITY_ID_SIZE);
-	memcpy (ep_thread_get_activity_id_ref (activity_id_handle), activity_id, EP_ACTIVITY_ID_SIZE);
-}
-static
-inline
-int32_t
-ep_rt_mono_thread_sleep (uint32_t ms, bool alertable)
-{
-	gboolean alerted = false;
-	if (alertable)
-		return (int32_t)mono_thread_info_sleep (ms, &alerted);
-	else
-		return (int32_t)mono_thread_info_sleep (ms, NULL);
-}
-static
-inline
-bool
-ep_rt_mono_thread_yield (void)
-{
-	return (mono_thread_info_yield () == TRUE) ? true : false;
-}
-#if defined(TARGET_ARM) || defined(TARGET_ARM64)
-	#define EP_SLEEP_START_THRESHOLD (5 * 1024)
-#else
-	#define EP_SLEEP_START_THRESHOLD (32 * 1024)
-#endif
-#undef EP_YIELD_WHILE
-#define EP_YIELD_WHILE(condition) { \
-	int32_t __switch_count = 0; \
-	while (condition) { \
-		if (++__switch_count >= EP_SLEEP_START_THRESHOLD) { \
-			ep_rt_mono_thread_sleep (1, false); \
-		} \
-	} \
-	{ \
-		ep_rt_mono_thread_yield (); \
-	} \
-}
-/*
- * ThreadSequenceNumberMap.
- */
-EP_RT_DEFINE_HASH_MAP_REMOVE(thread_sequence_number_map, ep_rt_thread_sequence_number_hash_map_t, EventPipeThreadSessionState *, uint32_t)
-EP_RT_DEFINE_HASH_MAP_ITERATOR(thread_sequence_number_map, ep_rt_thread_sequence_number_hash_map_t, ep_rt_thread_sequence_number_hash_map_iterator_t, EventPipeThreadSessionState *, uint32_t)
-/*
- * Volatile.
- */
-static
-inline
-uint32_t
-ep_rt_volatile_load_uint32_t (const volatile uint32_t *ptr)
-{
-	return (uint32_t)mono_atomic_load_i32 ((volatile gint32 *)ptr);
-}
-static
-inline
-uint32_t
-ep_rt_volatile_load_uint32_t_without_barrier (const volatile uint32_t *ptr)
-{
-	uint32_t value = *ptr;
-	return value;
-}
-static
-inline
-void
-ep_rt_volatile_store_uint32_t (
-	volatile uint32_t *ptr,
-	uint32_t value)
-{
-	mono_atomic_store_i32 ((volatile gint32 *)ptr, (gint32)value);
-}
-static
-inline
-void
-ep_rt_volatile_store_uint32_t_without_barrier (
-	volatile uint32_t *ptr,
-	uint32_t value)
-{
-	*ptr = value;
-}
-static
-inline
-uint64_t
-ep_rt_volatile_load_uint64_t (const volatile uint64_t *ptr)
-{
-	return (uint64_t)mono_atomic_load_i64 ((volatile gint64 *)ptr);
-}
-static
-inline
-uint64_t
-ep_rt_volatile_load_uint64_t_without_barrier (const volatile uint64_t *ptr)
-{
-	uint64_t value = *ptr;
-	return value;
-}
-static
-inline
-void
-ep_rt_volatile_store_uint64_t (
-	volatile uint64_t *ptr,
-	uint64_t value)
-{
-	mono_atomic_store_i64 ((volatile gint64 *)ptr, (gint64)value);
-}
-static
-inline
-void
-ep_rt_volatile_store_uint64_t_without_barrier (
-	volatile uint64_t *ptr,
-	uint64_t value)
-{
-	*ptr = value;
-}
-static
-inline
-int64_t
-ep_rt_volatile_load_int64_t (const volatile int64_t *ptr)
-{
-	return mono_atomic_load_i64 ((volatile gint64 *)ptr);
-}
-static
-inline
-int64_t
-ep_rt_volatile_load_int64_t_without_barrier (const volatile int64_t *ptr)
-{
-	return *ptr;
-}
-static
-inline
-void
-ep_rt_volatile_store_int64_t (
-	volatile int64_t *ptr,
-	int64_t value)
-{
-	mono_atomic_store_i64 ((volatile gint64 *)ptr, (gint64)value);
-}
-static
-inline
-void
-ep_rt_volatile_store_int64_t_without_barrier (
-	volatile int64_t *ptr,
-	int64_t value)
-{
-	*ptr = value;
-}
-static
-inline
-void *
-ep_rt_volatile_load_ptr (volatile void **ptr)
-{
-	return mono_atomic_load_ptr ((volatile gpointer *)ptr);
-}
-static
-inline
-void *
-ep_rt_volatile_load_ptr_without_barrier (volatile void **ptr)
-{
-	void *value = (void *)(*ptr);
-	return value;
-}
-static
-inline
-void
-ep_rt_volatile_store_ptr (
-	volatile void **ptr,
-	void *value)
-{
-	mono_atomic_store_ptr ((volatile gpointer *)ptr, (gpointer)value);
-}
-static
-inline
-void
-ep_rt_volatile_store_ptr_without_barrier (
-	volatile void **ptr,
-	void *value)
-{
-	*ptr = value;
-}
-/*
- * EventPipe Native Events.
- */
-bool
-ep_rt_mono_write_event_ee_startup_start (void);
-typedef struct _BulkTypeEventLogger BulkTypeEventLogger;
-void
-ep_rt_mono_fire_bulk_type_event (BulkTypeEventLogger *p_type_logger);
-int
-ep_rt_mono_log_single_type (
-	BulkTypeEventLogger *p_type_logger,
-	MonoType *mono_type);
-void
-ep_rt_mono_log_type_and_parameters (
-	BulkTypeEventLogger *p_type_logger,
-	MonoType *mono_type);
-void
-ep_rt_mono_log_type_and_parameters_if_necessary (
-	BulkTypeEventLogger *p_type_logger,
-	MonoType *mono_type);
-void
-ep_rt_mono_send_method_details_event (MonoMethod *method);
-bool
-ep_rt_mono_write_event_jit_start (MonoMethod *method);
-bool
-ep_rt_mono_write_event_method_il_to_native_map (
-	MonoMethod *method,
-	MonoJitInfo *ji);
-bool
-ep_rt_mono_write_event_method_load (
-	MonoMethod *method,
-	MonoJitInfo *ji);
-bool
-ep_rt_mono_write_event_module_load (MonoImage *image);
-bool
-ep_rt_mono_write_event_module_unload (MonoImage *image);
-bool
-ep_rt_mono_write_event_assembly_load (MonoAssembly *assembly);
-bool
-ep_rt_mono_write_event_assembly_unload (MonoAssembly *assembly);
-bool
-ep_rt_mono_write_event_thread_created (ep_rt_thread_id_t tid);
-bool
-ep_rt_mono_write_event_thread_terminated (ep_rt_thread_id_t tid);
-bool
-ep_rt_mono_write_event_type_load_start (MonoType *type);
-bool
-ep_rt_mono_write_event_type_load_stop (MonoType *type);
-bool
-ep_rt_mono_write_event_exception_thrown (MonoObject *object);
-bool
-ep_rt_mono_write_event_exception_clause (
-	MonoMethod *method,
-	uint32_t clause_num,
-	MonoExceptionEnum clause_type,
-	MonoObject *obj);
-bool
-ep_rt_mono_write_event_monitor_contention_start (MonoObject *obj);
-bool
-ep_rt_mono_write_event_monitor_contention_stop (MonoObject *obj);
-bool
-ep_rt_mono_write_event_method_jit_memory_allocated_for_code (
-	const uint8_t *buffer,
-	uint64_t size,
-	MonoProfilerCodeBufferType type,
-	const void *data);
-bool
-ep_rt_write_event_threadpool_worker_thread_start (
-	uint32_t active_thread_count,
-	uint32_t retired_worker_thread_count,
-	uint16_t clr_instance_id);
-bool
-ep_rt_write_event_threadpool_worker_thread_stop (
-	uint32_t active_thread_count,
-	uint32_t retired_worker_thread_count,
-	uint16_t clr_instance_id);
-bool
-ep_rt_write_event_threadpool_worker_thread_wait (
-	uint32_t active_thread_count,
-	uint32_t retired_worker_thread_count,
-	uint16_t clr_instance_id);
-bool
-ep_rt_write_event_threadpool_min_max_threads (
-	uint16_t min_worker_threads,
-	uint16_t max_worker_threads,
-	uint16_t min_io_completion_threads,
-	uint16_t max_io_completion_threads,
-	uint16_t clr_instance_id);
-bool
-ep_rt_write_event_threadpool_worker_thread_adjustment_sample (
-	double throughput,
-	uint16_t clr_instance_id);
-bool
-ep_rt_write_event_threadpool_worker_thread_adjustment_adjustment (
-	double average_throughput,
-	uint32_t networker_thread_count,
-	/*NativeRuntimeEventSource.ThreadAdjustmentReasonMap*/ int32_t reason,
-	uint16_t clr_instance_id);
-bool
-ep_rt_write_event_threadpool_worker_thread_adjustment_stats (
-	double duration,
-	double throughput,
-	double threadpool_worker_thread_wait,
-	double throughput_wave,
-	double throughput_error_estimate,
-	double average_throughput_error_estimate,
-	double throughput_ratio,
-	double confidence,
-	double new_control_setting,
-	uint16_t new_thread_wave_magnitude,
-	uint16_t clr_instance_id);
-bool
-ep_rt_write_event_threadpool_io_enqueue (
-	intptr_t native_overlapped,
-	intptr_t overlapped,
-	bool multi_dequeues,
-	uint16_t clr_instance_id);
-bool
-ep_rt_write_event_threadpool_io_dequeue (
-	intptr_t native_overlapped,
-	intptr_t overlapped,
-	uint16_t clr_instance_id);
-bool
-ep_rt_write_event_threadpool_working_thread_count (
-	uint16_t count,
-	uint16_t clr_instance_id);
-bool
-ep_rt_write_event_threadpool_io_pack (
-	intptr_t native_overlapped,
-	intptr_t overlapped,
-	uint16_t clr_instance_id);
-/*
-* EventPipe provider callbacks.
-*/
-void
-EventPipeEtwCallbackDotNETRuntime (
-	const uint8_t *source_id,
-	unsigned long is_enabled,
-	uint8_t level,
-	uint64_t match_any_keywords,
-	uint64_t match_all_keywords,
-	EventFilterDescriptor *filter_data,
-	void *callback_data);
-void
-EventPipeEtwCallbackDotNETRuntimeRundown (
-	const uint8_t *source_id,
-	unsigned long is_enabled,
-	uint8_t level,
-	uint64_t match_any_keywords,
-	uint64_t match_all_keywords,
-	EventFilterDescriptor *filter_data,
-	void *callback_data);
-void
-EventPipeEtwCallbackDotNETRuntimePrivate (
-	const uint8_t *source_id,
-	unsigned long is_enabled,
-	uint8_t level,
-	uint64_t match_any_keywords,
-	uint64_t match_all_keywords,
-	EventFilterDescriptor *filter_data,
-	void *callback_data);
-void
-EventPipeEtwCallbackDotNETRuntimeStress (
-	const uint8_t *source_id,
-	unsigned long is_enabled,
-	uint8_t level,
-	uint64_t match_any_keywords,
-	uint64_t match_all_keywords,
-	EventFilterDescriptor *filter_data,
-	void *callback_data);
-void
-EventPipeEtwCallbackDotNETRuntimeMonoProfiler (
-	const uint8_t *source_id,
-	unsigned long is_enabled,
-	uint8_t level,
-	uint64_t match_any_keywords,
-	uint64_t match_all_keywords,
-	EventFilterDescriptor *filter_data,
-	void *callback_data);
-#endif /* ENABLE_PERFTRACING */
-#endif /* __EVENTPIPE_RT_MONO_H__ */

--- a/src/mono/mono/metadata/native-library.c
+++ b//dev/null
@@ -1,1219 +0,0 @@
-#include "config.h"
-#include "mono/metadata/assembly-internals.h"
-#include "mono/metadata/class-internals.h"
-#include "mono/metadata/icall-decl.h"
-#include "mono/metadata/loader-internals.h"
-#include "mono/metadata/loader.h"
-#include "mono/metadata/object-internals.h"
-#include "mono/metadata/reflection-internals.h"
-#include "mono/utils/checked-build.h"
-#include "mono/utils/mono-compiler.h"
-#include "mono/utils/mono-logger-internals.h"
-#include "mono/utils/mono-path.h"
-#include "mono/metadata/native-library.h"
-#include "mono/metadata/custom-attrs-internals.h"
-static int pinvoke_search_directories_count;
-static char **pinvoke_search_directories;
-typedef enum
-{
-	DLLIMPORTSEARCHPATH_LEGACY_BEHAVIOR = 0x0, // when no other flags are present, search the application directory and then call LoadLibraryEx with LOAD_WITH_ALTERED_SEARCH_PATH
-	DLLIMPORTSEARCHPATH_USE_DLL_DIRECTORY_FOR_DEPENDENCIES = 0x100,
-	DLLIMPORTSEARCHPATH_APPLICATION_DIRECTORY = 0x200,
-	DLLIMPORTSEARCHPATH_USER_DIRECTORIES = 0x400,
-	DLLIMPORTSEARCHPATH_SYSTEM32 = 0x800,
-	DLLIMPORTSEARCHPATH_SAFE_DIRECTORIES = 0x1000,
-	DLLIMPORTSEARCHPATH_ASSEMBLY_DIRECTORY = 0x2, // search the assembly directory first regardless of platform, not passed on to LoadLibraryEx
-} DllImportSearchPath;
-#ifdef HOST_WIN32
-static const int DLLIMPORTSEARCHPATH_LOADLIBRARY_FLAG_MASK = DLLIMPORTSEARCHPATH_USE_DLL_DIRECTORY_FOR_DEPENDENCIES | DLLIMPORTSEARCHPATH_APPLICATION_DIRECTORY |
-                                                             DLLIMPORTSEARCHPATH_USER_DIRECTORIES | DLLIMPORTSEARCHPATH_SYSTEM32 | DLLIMPORTSEARCHPATH_SAFE_DIRECTORIES;
-#endif
-static MonoCoopMutex native_library_module_lock;
-static GHashTable *native_library_module_map;
-/*
- * This blocklist is used as a set for cache invalidation purposes with netcore pinvokes.
- * When pinvokes are resolved with anything other than the last-chance managed event,
- * the results of that lookup are added to an ALC-level cache. However, if a library is then
- * unloaded with NativeLibrary.Free(), this cache should be invalidated so that a newly called
- * pinvoke will not attempt to use it, hence the blocklist. This design means that if another
- * library is loaded at the same address, it will function with a perf hit, as the entry will
- * repeatedly be added and removed from the cache due to its presence in the blocklist.
- * This is a rare scenario and considered a worthwhile tradeoff.
- */
-static GHashTable *native_library_module_blocklist;
-#ifndef NO_GLOBALIZATION_SHIM
-extern const void *GlobalizationResolveDllImport (const char *name);
-#endif
-#ifndef DISABLE_DLLMAP
-static MonoDllMap *global_dll_map;
-#endif
-static GHashTable *global_module_map; // should only be accessed with the global loader data lock
-static MonoDl *internal_module; // used when pinvoking `__Internal`
-static PInvokeOverrideFn pinvoke_override;
-static gboolean bundle_save_library_initialized;
-static GSList *bundle_library_paths;
-static char *bundled_dylibrary_directory;
-/* Class lazy loading functions */
-GENERATE_GET_CLASS_WITH_CACHE (appdomain_unloaded_exception, "System", "AppDomainUnloadedException")
-GENERATE_TRY_GET_CLASS_WITH_CACHE (appdomain_unloaded_exception, "System", "AppDomainUnloadedException")
-GENERATE_GET_CLASS_WITH_CACHE (native_library, "System.Runtime.InteropServices", "NativeLibrary");
-static GENERATE_TRY_GET_CLASS_WITH_CACHE (dllimportsearchpath_attribute, "System.Runtime.InteropServices", "DefaultDllImportSearchPathsAttribute");
-#ifndef DISABLE_DLLMAP
-/*
- * LOCKING: Assumes the relevant lock is held.
- * For the global DllMap, this is `global_loader_data_mutex`, and for images it's their internal lock.
- */
-static gboolean
-mono_dllmap_lookup_list (MonoDllMap *dll_map, const char *dll, const char* func, const char **rdll, const char **rfunc) {
-	gboolean found = FALSE;
-	*rdll = dll;
-	*rfunc = func;
-	if (!dll_map)
-		goto exit;
-	/*
-	 * we use the first entry we find that matches, since entries from
-	 * the config file are prepended to the list and we document that the
-	 * later entries win.
-	 */
-	for (; dll_map; dll_map = dll_map->next) {
-		gboolean case_insensitive_match = strncmp (dll_map->dll, "i:", 2) == 0 && g_ascii_strcasecmp (dll_map->dll + 2, dll) == 0;
-		gboolean case_sensitive_match = strcmp (dll_map->dll, dll) == 0;
-		if (!(case_insensitive_match || case_sensitive_match))
-			continue;
-		if (!found && dll_map->target) {
-			*rdll = dll_map->target;
-			found = TRUE;
-			/* we don't quit here, because we could find a full
-			 * entry that also matches the function, which takes priority.
-			 */
-		}
-		if (dll_map->func && strcmp (dll_map->func, func) == 0) {
-			*rdll = dll_map->target;
-			*rfunc = dll_map->target_func;
-			break;
-		}
-	}
-exit:
-	return found;
-}
-/*
- * The locking and GC state transitions here are wonky due to the fact the image lock is a coop lock
- * and the global loader data lock is an OS lock.
- */
-static gboolean
-mono_dllmap_lookup (MonoImage *assembly, const char *dll, const char* func, const char **rdll, const char **rfunc)
-{
-	gboolean res;
-	MONO_REQ_GC_UNSAFE_MODE;
-	if (assembly && assembly->dll_map) {
-		mono_image_lock (assembly);
-		res = mono_dllmap_lookup_list (assembly->dll_map, dll, func, rdll, rfunc);
-		mono_image_unlock (assembly);
-		if (res)
-			goto leave;
-	}
-	MONO_ENTER_GC_SAFE;
-	mono_global_loader_data_lock ();
-	res = mono_dllmap_lookup_list (global_dll_map, dll, func, rdll, rfunc);
-	mono_global_loader_data_unlock ();
-	MONO_EXIT_GC_SAFE;
-leave:
-	*rdll = g_strdup (*rdll);
-	*rfunc = g_strdup (*rfunc);
-	return res;
-}
-static void
-dllmap_insert_global (const char *dll, const char *func, const char *tdll, const char *tfunc)
-{
-	MonoDllMap *entry;
-	entry = (MonoDllMap *)g_malloc0 (sizeof (MonoDllMap));
-	entry->dll = dll? g_strdup (dll): NULL;
-	entry->target = tdll? g_strdup (tdll): NULL;
-	entry->func = func? g_strdup (func): NULL;
-	entry->target_func = tfunc? g_strdup (tfunc): (func? g_strdup (func): NULL);
-	mono_global_loader_data_lock ();
-	entry->next = global_dll_map;
-	global_dll_map = entry;
-	mono_global_loader_data_unlock ();
-}
-static void
-dllmap_insert_image (MonoImage *assembly, const char *dll, const char *func, const char *tdll, const char *tfunc)
-{
-	MonoDllMap *entry;
-	g_assert (assembly != NULL);
-	MONO_REQ_GC_UNSAFE_MODE;
-	entry = (MonoDllMap *)mono_image_alloc0 (assembly, sizeof (MonoDllMap));
-	entry->dll = dll? mono_image_strdup (assembly, dll): NULL;
-	entry->target = tdll? mono_image_strdup (assembly, tdll): NULL;
-	entry->func = func? mono_image_strdup (assembly, func): NULL;
-	entry->target_func = tfunc? mono_image_strdup (assembly, tfunc): (func? mono_image_strdup (assembly, func): NULL);
-	mono_image_lock (assembly);
-	entry->next = assembly->dll_map;
-	assembly->dll_map = entry;
-	mono_image_unlock (assembly);
-}
-/*
- * LOCKING: Assumes the relevant lock is held.
- * For the global DllMap, this is `global_loader_data_mutex`, and for images it's their internal lock.
- */
-static void
-free_dllmap (MonoDllMap *map)
-{
-	while (map) {
-		MonoDllMap *next = map->next;
-		g_free (map->dll);
-		g_free (map->target);
-		g_free (map->func);
-		g_free (map->target_func);
-		g_free (map);
-		map = next;
-	}
-}
-void
-mono_dllmap_insert_internal (MonoImage *assembly, const char *dll, const char *func, const char *tdll, const char *tfunc)
-{
-	mono_loader_init ();
-	if (!assembly)
-		dllmap_insert_global (dll, func, tdll, tfunc);
-	else
-		dllmap_insert_image (assembly, dll, func, tdll, tfunc);
-}
-void
-mono_global_dllmap_cleanup (void)
-{
-	mono_global_loader_data_lock ();
-	free_dllmap (global_dll_map);
-	global_dll_map = NULL;
-	mono_global_loader_data_unlock ();
-}
-#endif
-/**
- * mono_dllmap_insert:
- * \param assembly if NULL, this is a global mapping, otherwise the remapping of the dynamic library will only apply to the specified assembly
- * \param dll The name of the external library, as it would be found in the \c DllImport declaration.  If prefixed with <code>i:</code> the matching of the library name is done without case sensitivity
- * \param func if not null, the mapping will only applied to the named function (the value of <code>EntryPoint</code>)
- * \param tdll The name of the library to map the specified \p dll if it matches.
- * \param tfunc The name of the function that replaces the invocation.  If NULL, it is replaced with a copy of \p func.
- *
- * LOCKING: Acquires the image lock, or the loader data lock if an image is not passed.
- *
- * This function is used to programatically add \c DllImport remapping in either
- * a specific assembly, or as a global remapping.   This is done by remapping
- * references in a \c DllImport attribute from the \p dll library name into the \p tdll
- * name. If the \p dll name contains the prefix <code>i:</code>, the comparison of the
- * library name is done without case sensitivity.
- *
- * If you pass \p func, this is the name of the \c EntryPoint in a \c DllImport if specified
- * or the name of the function as determined by \c DllImport. If you pass \p func, you
- * must also pass \p tfunc which is the name of the target function to invoke on a match.
- *
- * Example:
- *
- * <code>mono_dllmap_insert (NULL, "i:libdemo.dll", NULL, relocated_demo_path, NULL);</code>
- *
- * The above will remap \c DllImport statements for \c libdemo.dll and \c LIBDEMO.DLL to
- * the contents of \c relocated_demo_path for all assemblies in the Mono process.
- *
- * NOTE: This can be called before the runtime is initialized.
- */
-void
-mono_dllmap_insert (MonoImage *assembly, const char *dll, const char *func, const char *tdll, const char *tfunc)
-{
-#ifndef DISABLE_DLLMAP
-	mono_dllmap_insert_internal (assembly, dll, func, tdll, tfunc);
-#else
-	g_assert_not_reached ();
-#endif
-}
-void
-mono_loader_register_module (const char *name, MonoDl *module)
-{
-	mono_loader_init ();
-	mono_global_loader_data_lock ();
-	g_hash_table_insert (global_module_map, g_strdup (name), module);
-	mono_global_loader_data_unlock ();
-}
-static MonoDl *
-mono_loader_register_module_locking (const char *name, MonoDl *module)
-{
-	MonoDl *result = NULL;
-	MONO_ENTER_GC_SAFE;
-	mono_global_loader_data_lock ();
-	MONO_EXIT_GC_SAFE;
-	result = (MonoDl *)g_hash_table_lookup (global_module_map, name);
-	if (result) {
-		g_free (module->full_name);
-		g_free (module);
-		goto exit;
-	}
-	g_hash_table_insert (global_module_map, g_strdup (name), module);
-	result = module;
-exit:
-	MONO_ENTER_GC_SAFE;
-	mono_global_loader_data_unlock ();
-	MONO_EXIT_GC_SAFE;
-	return result;
-}
-static void
-remove_cached_module (gpointer key, gpointer value, gpointer user_data)
-{
-	ERROR_DECL (close_error);
-	mono_dl_close((MonoDl*)value, close_error);
-	mono_error_cleanup (close_error);
-}
-void
-mono_global_loader_cache_init (void)
-{
-	if (!global_module_map)
-		global_module_map = g_hash_table_new (g_str_hash, g_str_equal);
-	if (!native_library_module_map)
-		native_library_module_map = g_hash_table_new (g_direct_hash, g_direct_equal);
-	if (!native_library_module_blocklist)
-		native_library_module_blocklist = g_hash_table_new (g_direct_hash, g_direct_equal);
-	mono_coop_mutex_init (&native_library_module_lock);
-}
-static gboolean
-is_absolute_path (const char *path)
-{
-#ifdef HOST_DARWIN
-	if (!strncmp (path, "@executable_path/", 17) || !strncmp (path, "@loader_path/", 13) || !strncmp (path, "@rpath/", 7))
-		return TRUE;
-#endif
-	return g_path_is_absolute (path);
-}
-static gpointer
-lookup_pinvoke_call_impl (MonoMethod *method, MonoLookupPInvokeStatus *status_out);
-static gpointer
-pinvoke_probe_for_symbol (MonoDl *module, MonoMethodPInvoke *piinfo, const char *import);
-static void
-pinvoke_probe_convert_status_for_api (MonoLookupPInvokeStatus *status, const char **exc_class, const char **exc_arg)
-{
-	if (!exc_class)
-		return;
-	switch (status->err_code) {
-	case LOOKUP_PINVOKE_ERR_OK:
-		*exc_class = NULL;
-		*exc_arg = NULL;
-		break;
-	case LOOKUP_PINVOKE_ERR_NO_LIB:
-		*exc_class = "DllNotFoundException";
-		*exc_arg = status->err_arg;
-		status->err_arg = NULL;
-		break;
-	case LOOKUP_PINVOKE_ERR_NO_SYM:
-		*exc_class = "EntryPointNotFoundException";
-		*exc_arg = status->err_arg;
-		status->err_arg = NULL;
-		break;
-	default:
-		g_assert_not_reached ();
-	}
-}
-static void
-pinvoke_probe_convert_status_to_error (MonoLookupPInvokeStatus *status, MonoError *error)
-{
-	/* Note: this has to return a MONO_ERROR_GENERIC because mono_mb_emit_exception_for_error only knows how to decode generic errors. */
-	switch (status->err_code) {
-	case LOOKUP_PINVOKE_ERR_OK:
-		return;
-	case LOOKUP_PINVOKE_ERR_NO_LIB:
-		mono_error_set_generic_error (error, "System", "DllNotFoundException", "%s", status->err_arg);
-		g_free (status->err_arg);
-		status->err_arg = NULL;
-		break;
-	case LOOKUP_PINVOKE_ERR_NO_SYM:
-		mono_error_set_generic_error (error, "System", "EntryPointNotFoundException", "%s", status->err_arg);
-		g_free (status->err_arg);
-		status->err_arg = NULL;
-		break;
-	default:
-		g_assert_not_reached ();
-	}
-}
-/**
- * mono_lookup_pinvoke_call:
- */
-gpointer
-mono_lookup_pinvoke_call (MonoMethod *method, const char **exc_class, const char **exc_arg)
-{
-	gpointer result;
-	MONO_ENTER_GC_UNSAFE;
-	MonoLookupPInvokeStatus status;
-	memset (&status, 0, sizeof (status));
-	result = lookup_pinvoke_call_impl (method, &status);
-	pinvoke_probe_convert_status_for_api (&status, exc_class, exc_arg);
-	MONO_EXIT_GC_UNSAFE;
-	return result;
-}
-gpointer
-mono_lookup_pinvoke_call_internal (MonoMethod *method, MonoError *error)
-{
-	gpointer result;
-	MonoLookupPInvokeStatus status;
-	memset (&status, 0, sizeof (status));
-	result = lookup_pinvoke_call_impl (method, &status);
-	if (status.err_code)
-		pinvoke_probe_convert_status_to_error (&status, error);
-	return result;
-}
-void
-mono_set_pinvoke_search_directories (int dir_count, char **dirs)
-{
-	pinvoke_search_directories_count = dir_count;
-	g_strfreev (pinvoke_search_directories);
-	pinvoke_search_directories = dirs;
-}
-static void
-native_library_lock (void)
-{
-	mono_coop_mutex_lock (&native_library_module_lock);
-}
-static void
-native_library_unlock (void)
-{
-	mono_coop_mutex_unlock (&native_library_module_lock);
-}
-static void
-alc_pinvoke_lock (MonoAssemblyLoadContext *alc)
-{
-	mono_coop_mutex_lock (&alc->pinvoke_lock);
-}
-static void
-alc_pinvoke_unlock (MonoAssemblyLoadContext *alc)
-{
-	mono_coop_mutex_unlock (&alc->pinvoke_lock);
-}
-static MonoDl *
-netcore_handle_lookup (gpointer handle)
-{
-	return (MonoDl *)g_hash_table_lookup (native_library_module_map, handle);
-}
-static gboolean
-netcore_check_blocklist (MonoDl *module)
-{
-	return g_hash_table_contains (native_library_module_blocklist, module);
-}
-static int
-convert_dllimport_flags (int flags)
-{
-#ifdef HOST_WIN32
-	return flags & DLLIMPORTSEARCHPATH_LOADLIBRARY_FLAG_MASK;
-#else
-	return 0;
-#endif
-}
-static MonoDl *
-netcore_probe_for_module_variations (const char *mdirname, const char *file_name, int raw_flags, MonoError *error)
-{
-	void *iter = NULL;
-	char *full_name = NULL;
-	MonoDl *module = NULL;
-	ERROR_DECL (bad_image_error);
-	while (module == NULL && (full_name = mono_dl_build_path (mdirname, file_name, &iter))) {
-		mono_error_cleanup (error);
-		error_init_reuse (error);
-		module = mono_dl_open_full (full_name, MONO_DL_LAZY, raw_flags, error);
-		if (!module)
-			mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "DllImport error loading library '%s': '%s'.", full_name, mono_error_get_message_without_fields (error));
-		g_free (full_name);
-		if (!module && !is_ok (error) && mono_error_get_error_code (error) == MONO_ERROR_BAD_IMAGE) {
-			mono_error_cleanup (bad_image_error);
-			mono_error_move (bad_image_error, error);
-		}
-	}
-	if (!module && !is_ok (bad_image_error)) {
-		mono_error_cleanup (error);
-		mono_error_move (error, bad_image_error);
-	}
-	mono_error_cleanup (bad_image_error);
-	return module;
-}
-static MonoDl *
-netcore_probe_for_module (MonoImage *image, const char *file_name, int flags, MonoError *error)
-{
-	MonoDl *module = NULL;
-	int lflags = convert_dllimport_flags (flags);
-	ERROR_DECL (bad_image_error);
-#if defined(HOST_ANDROID)
-	module = netcore_probe_for_module_variations (NULL, file_name, lflags, error);
-	if (!module && !is_ok (error) && mono_error_get_error_code (error) == MONO_ERROR_BAD_IMAGE)
-		mono_error_move (bad_image_error, error);
-#endif
-	for (int i = 0; i < pinvoke_search_directories_count && module == NULL; ++i) {
-		mono_error_cleanup (error);
-		error_init_reuse (error);
-		module = netcore_probe_for_module_variations (pinvoke_search_directories[i], file_name, lflags, error);
-		if (!module && !is_ok (error) && mono_error_get_error_code (error) == MONO_ERROR_BAD_IMAGE) {
-			mono_error_cleanup (bad_image_error);
-			mono_error_move (bad_image_error, error);
-		}
-	}
-	if ((flags & DLLIMPORTSEARCHPATH_ASSEMBLY_DIRECTORY) != 0 && image != NULL &&
-		module == NULL && (image->filename != NULL)) {
-		mono_error_cleanup (error);
-		error_init_reuse (error);
-		char *mdirname = g_path_get_dirname (image->filename);
-		if (mdirname)
-			module = netcore_probe_for_module_variations (mdirname, file_name, lflags, error);
-		g_free (mdirname);
-	}
-#if !defined(HOST_ANDROID)
-	if (module == NULL)
-	{
-		module = netcore_probe_for_module_variations (NULL, file_name, lflags, error);
-		if (!module && !is_ok (error) && mono_error_get_error_code (error) == MONO_ERROR_BAD_IMAGE)
-			mono_error_move (bad_image_error, error);
-	}
-#endif
-	if (!module && !is_ok (bad_image_error)) {
-		mono_error_cleanup (error);
-		mono_error_move (error, bad_image_error);
-	}
-	mono_error_cleanup (bad_image_error);
-	return module;
-}
-static MonoDl *
-netcore_probe_for_module_nofail (MonoImage *image, const char *file_name, int flags)
-{
-	MonoDl *result = NULL;
-	ERROR_DECL (error);
-	result = netcore_probe_for_module (image, file_name, flags, error);
-	mono_error_cleanup (error);
-	return result;
-}
-static MonoDl*
-netcore_lookup_self_native_handle (void)
-{
-	ERROR_DECL (load_error);
-	if (!internal_module)
-		internal_module = mono_dl_open_self (load_error);
-	if (!internal_module)
-		mono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT, "DllImport error loading library '__Internal': '%s'.", mono_error_get_message_without_fields (load_error));
-	mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "Native library found via __Internal.");
-	mono_error_cleanup (load_error);
-	return internal_module;
-}
-static MonoDl* native_handle_lookup_wrapper (gpointer handle)
-{
-	MonoDl *result = NULL;
-	if (!internal_module)
-		netcore_lookup_self_native_handle ();
-	if (internal_module->handle == handle) {
-		result = internal_module;
-	} else {
-		native_library_lock ();
-		result = netcore_handle_lookup (handle);
-		native_library_unlock ();
-	}
-	return result;
-}
-static MonoDl *
-netcore_resolve_with_dll_import_resolver (MonoAssemblyLoadContext *alc, MonoAssembly *assembly, const char *scope, guint32 flags, MonoError *error)
-{
-	MonoDl *result = NULL;
-	gpointer lib = NULL;
-	MONO_STATIC_POINTER_INIT (MonoMethod, resolve)
-		ERROR_DECL (local_error);
-		static gboolean inited;
-		if (!inited) {
-			MonoClass *native_lib_class = mono_class_get_native_library_class ();
-			g_assert (native_lib_class);
-			resolve = mono_class_get_method_from_name_checked (native_lib_class, "MonoLoadLibraryCallbackStub", -1, 0, local_error);
-			inited = TRUE;
-		}
-		mono_error_cleanup (local_error);
-	MONO_STATIC_POINTER_INIT_END (MonoMethod, resolve)
-	if (!resolve)
-		return NULL;
-	if (mono_runtime_get_no_exec ())
-		return NULL;
-	HANDLE_FUNCTION_ENTER ();
-	MonoStringHandle scope_handle;
-	scope_handle = mono_string_new_handle (scope, error);
-	goto_if_nok (error, leave);
-	MonoReflectionAssemblyHandle assembly_handle;
-	assembly_handle = mono_assembly_get_object_handle (assembly, error);
-	goto_if_nok (error, leave);
-	gboolean has_search_flags;
-	has_search_flags = flags != 0 ? TRUE : FALSE;
-	gpointer args [5];
-	args [0] = MONO_HANDLE_RAW (scope_handle);
-	args [1] = MONO_HANDLE_RAW (assembly_handle);
-	args [2] = &has_search_flags;
-	args [3] = &flags;
-	args [4] = &lib;
-	mono_runtime_invoke_checked (resolve, NULL, args, error);
-	goto_if_nok (error, leave);
-	result = native_handle_lookup_wrapper (lib);
-leave:
-	HANDLE_FUNCTION_RETURN_VAL (result);
-}
-static MonoDl *
-netcore_resolve_with_dll_import_resolver_nofail (MonoAssemblyLoadContext *alc, MonoAssembly *assembly, const char *scope, guint32 flags)
-{
-	MonoDl *result = NULL;
-	ERROR_DECL (error);
-	result = netcore_resolve_with_dll_import_resolver (alc, assembly, scope, flags, error);
-	if (!is_ok (error))
-		mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "Error while invoking ALC DllImportResolver(\"%s\") delegate: '%s'", scope, mono_error_get_message (error));
-	mono_error_cleanup (error);
-	return result;
-}
-static MonoDl *
-netcore_resolve_with_load (MonoAssemblyLoadContext *alc, const char *scope, MonoError *error)
-{
-	MonoDl *result = NULL;
-	gpointer lib = NULL;
-	MONO_STATIC_POINTER_INIT (MonoMethod, resolve)
-		ERROR_DECL (local_error);
-		MonoClass *alc_class = mono_class_get_assembly_load_context_class ();
-		g_assert (alc_class);
-		resolve = mono_class_get_method_from_name_checked (alc_class, "MonoResolveUnmanagedDll", -1, 0, local_error);
-		mono_error_assert_ok (local_error);
-	MONO_STATIC_POINTER_INIT_END (MonoMethod, resolve)
-	g_assert (resolve);
-	if (mono_runtime_get_no_exec ())
-		return NULL;
-	HANDLE_FUNCTION_ENTER ();
-	MonoStringHandle scope_handle;
-	scope_handle = mono_string_new_handle (scope, error);
-	goto_if_nok (error, leave);
-	gpointer gchandle = mono_alc_get_gchandle_for_resolving (alc);
-	gpointer args [3];
-	args [0] = MONO_HANDLE_RAW (scope_handle);
-	args [1] = &gchandle;
-	args [2] = &lib;
-	mono_runtime_invoke_checked (resolve, NULL, args, error);
-	goto_if_nok (error, leave);
-	result = native_handle_lookup_wrapper (lib);
-leave:
-	HANDLE_FUNCTION_RETURN_VAL (result);
-}
-static MonoDl *
-netcore_resolve_with_load_nofail (MonoAssemblyLoadContext *alc, const char *scope)
-{
-	MonoDl *result = NULL;
-	ERROR_DECL (error);
-	result = netcore_resolve_with_load (alc, scope, error);
-	if (!is_ok (error))
-		mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "Error while invoking ALC LoadUnmanagedDll(\"%s\") method: '%s'", scope, mono_error_get_message (error));
-	mono_error_cleanup (error);
-	return result;
-}
-static MonoDl *
-netcore_resolve_with_resolving_event (MonoAssemblyLoadContext *alc, MonoAssembly *assembly, const char *scope, MonoError *error)
-{
-	MonoDl *result = NULL;
-	gpointer lib = NULL;
-	MONO_STATIC_POINTER_INIT (MonoMethod, resolve)
-		ERROR_DECL (local_error);
-		static gboolean inited;
-		if (!inited) {
-			MonoClass *alc_class = mono_class_get_assembly_load_context_class ();
-			g_assert (alc_class);
-			resolve = mono_class_get_method_from_name_checked (alc_class, "MonoResolveUnmanagedDllUsingEvent", -1, 0, local_error);
-			inited = TRUE;
-		}
-		mono_error_cleanup (local_error);
-	MONO_STATIC_POINTER_INIT_END (MonoMethod, resolve)
-	if (!resolve)
-		return NULL;
-	if (mono_runtime_get_no_exec ())
-		return NULL;
-	HANDLE_FUNCTION_ENTER ();
-	MonoStringHandle scope_handle;
-	scope_handle = mono_string_new_handle (scope, error);
-	goto_if_nok (error, leave);
-	MonoReflectionAssemblyHandle assembly_handle;
-	assembly_handle = mono_assembly_get_object_handle (assembly, error);
-	goto_if_nok (error, leave);
-	gpointer gchandle = mono_alc_get_gchandle_for_resolving (alc);
-	gpointer args [4];
-	args [0] = MONO_HANDLE_RAW (scope_handle);
-	args [1] = MONO_HANDLE_RAW (assembly_handle);
-	args [2] = &gchandle;
-	args [3] = &lib;
-	mono_runtime_invoke_checked (resolve, NULL, args, error);
-	goto_if_nok (error, leave);
-	result = native_handle_lookup_wrapper (lib);
-leave:
-	HANDLE_FUNCTION_RETURN_VAL (result);
-}
-static MonoDl *
-netcore_resolve_with_resolving_event_nofail (MonoAssemblyLoadContext *alc, MonoAssembly *assembly, const char *scope)
-{
-	MonoDl *result = NULL;
-	ERROR_DECL (error);
-	result = netcore_resolve_with_resolving_event (alc, assembly, scope, error);
-	if (!is_ok (error))
-		mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "Error while invoking ALC ResolvingUnmangedDll(\"%s\") event: '%s'", scope, mono_error_get_message (error));
-	mono_error_cleanup (error);
-	return result;
-}
-static MonoDl *
-netcore_check_alc_cache (MonoAssemblyLoadContext *alc, const char *scope)
-{
-	MonoDl *result = NULL;
-	result = (MonoDl *)g_hash_table_lookup (alc->pinvoke_scopes, scope);
-	if (result) {
-		gboolean blocklisted;
-		native_library_lock ();
-		blocklisted = netcore_check_blocklist (result);
-		native_library_unlock ();
-		if (blocklisted) {
-			g_hash_table_remove (alc->pinvoke_scopes, scope);
-			result = NULL;
-		}
-	}
-	return result;
-}
-static MonoDl *
-netcore_lookup_native_library (MonoAssemblyLoadContext *alc, MonoImage *image, const char *scope, guint32 flags)
-{
-	MonoDl *module = NULL;
-	MonoDl *cached;
-	MonoAssembly *assembly = mono_image_get_assembly (image);
-	MONO_REQ_GC_UNSAFE_MODE;
-	mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "DllImport attempting to load: '%s'.", scope);
-	if (strcmp (scope, "__Internal") == 0) {
-		return netcore_lookup_self_native_handle();
-	}
-	/*
-	 * Try these until one of them succeeds:
-	 *
-	 * 1. Check the cache in the active ALC.
-	 *
-	 * 2. Call the DllImportResolver on the active assembly.
-	 *
-	 * 3. Call LoadUnmanagedDll on the active ALC.
-	 *
-	 * 4. Check the global cache.
-	 *
-	 * 5. Run the unmanaged probing logic.
-	 *
-	 * 6. Raise the ResolvingUnmanagedDll event on the active ALC.
-	 *
-	 * 7. Return NULL.
-	 */
-	alc_pinvoke_lock (alc);
-	module = netcore_check_alc_cache (alc, scope);
-	alc_pinvoke_unlock (alc);
-	if (module) {
-		mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "Native library found in the active ALC cache: '%s'.", scope);
-		goto leave;
-	}
-	module = (MonoDl *)netcore_resolve_with_dll_import_resolver_nofail (alc, assembly, scope, flags);
-	if (module) {
-		mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "Native library found via DllImportResolver: '%s'.", scope);
-		goto add_to_alc_cache;
-	}
-	module = (MonoDl *)netcore_resolve_with_load_nofail (alc, scope);
-	if (module) {
-		mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "Native library found via LoadUnmanagedDll: '%s'.", scope);
-		goto add_to_alc_cache;
-	}
-	MONO_ENTER_GC_SAFE;
-	mono_global_loader_data_lock ();
-	MONO_EXIT_GC_SAFE;
-	module = (MonoDl *)g_hash_table_lookup (global_module_map, scope);
-	MONO_ENTER_GC_SAFE;
-	mono_global_loader_data_unlock ();
-	MONO_EXIT_GC_SAFE;
-	if (module) {
-		mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "Native library found in the global cache: '%s'.", scope);
-		goto add_to_alc_cache;
-	}
-	module = netcore_probe_for_module_nofail (image, scope, flags);
-	if (module) {
-		mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "Native library found via filesystem probing: '%s'.", scope);
-		goto add_to_global_cache;
-	}
-	/* As this is last chance, I've opted not to put it in a cache, but that is not necessarily the correct decision.
-	 * It is rather convenient here, however, because it means the global cache will only be populated by libraries
-	 * resolved via netcore_probe_for_module and not NativeLibrary, eliminating potential races/conflicts.
-	 */
-	module = netcore_resolve_with_resolving_event_nofail (alc, assembly, scope);
-	if (module)
-		mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "Native library found via the Resolving event: '%s'.", scope);
-	goto leave;
-add_to_global_cache:
-	module = mono_loader_register_module_locking (scope, module);
-add_to_alc_cache:
-	/* Nothing is closed here because the only two places this can come from are:
-	 * 1. A managed callback that made use of NativeLibrary.Load, in which case closing is dependent on NativeLibrary.Free
-	 * 2. The global cache, which is only populated by results of netcore_probe_for_module. When adding to the global cache,
-	 *      we free the new MonoDl if another thread beat us, so we don't have to repeat that here.
-	 */
-	alc_pinvoke_lock (alc);
-	cached = netcore_check_alc_cache (alc, scope);
-	if (cached)
-		module = cached;
-	else
-		g_hash_table_insert (alc->pinvoke_scopes, g_strdup (scope), module);
-	alc_pinvoke_unlock (alc);
-leave:
-	return module;
-}
-static int
-get_dllimportsearchpath_flags (MonoCustomAttrInfo *cinfo)
-{
-	ERROR_DECL (error);
-	MonoCustomAttrEntry *attr = NULL;
-	MonoClass *dllimportsearchpath = mono_class_try_get_dllimportsearchpath_attribute_class ();
-	int idx;
-	int flags;
-	if (!dllimportsearchpath)
-		return -1;
-	if (!cinfo)
-		return -2;
-	for (idx = 0; idx < cinfo->num_attrs; ++idx) {
-		MonoClass *ctor_class = cinfo->attrs [idx].ctor->klass;
-		if (ctor_class == dllimportsearchpath) {
-			attr = &cinfo->attrs [idx];
-			break;
-		}
-	}
-	if (!attr)
-		return -3;
-	MonoDecodeCustomAttr *decoded_args = mono_reflection_create_custom_attr_data_args_noalloc (m_class_get_image (attr->ctor->klass), attr->ctor, attr->data, attr->data_size, error);
-	if (!is_ok (error)) {
-		mono_error_cleanup (error);
-		return -4;
-	}
-	flags = *(gint32*)decoded_args->typed_args[0]->value.primitive;
-	mono_reflection_free_custom_attr_data_args_noalloc (decoded_args);
-	return flags;
-}
-#ifndef NO_GLOBALIZATION_SHIM
-#ifdef HOST_WIN32
-#define GLOBALIZATION_DLL_NAME "System.Globalization.Native"
-#else
-#define GLOBALIZATION_DLL_NAME "libSystem.Globalization.Native"
-#endif
-static gpointer
-default_resolve_dllimport (const char *dll, const char *func)
-{
-	if (strcmp (dll, GLOBALIZATION_DLL_NAME) == 0) {
-		const void *method_impl = GlobalizationResolveDllImport (func);
-		if (method_impl)
-			return (gpointer)method_impl;
-	}
-	return NULL;
-}
-#endif // NO_GLOBALIZATION_SHIM
-gpointer
-lookup_pinvoke_call_impl (MonoMethod *method, MonoLookupPInvokeStatus *status_out)
-{
-	MonoImage *image = m_class_get_image (method->klass);
-	MonoAssemblyLoadContext *alc = mono_image_get_alc (image);
-	MonoCustomAttrInfo *cinfo;
-	int flags;
-	MonoMethodPInvoke *piinfo = (MonoMethodPInvoke *)method;
-	MonoTableInfo *tables = image->tables;
-	MonoTableInfo *im = &tables [MONO_TABLE_IMPLMAP];
-	MonoTableInfo *mr = &tables [MONO_TABLE_MODULEREF];
-	guint32 im_cols [MONO_IMPLMAP_SIZE];
-	guint32 scope_token;
-	const char *orig_import = NULL;
-	const char *new_import = NULL;
-	const char *orig_scope = NULL;
-	const char *new_scope = NULL;
-	const char *error_scope = NULL;
-	MonoDl *module = NULL;
-	gpointer addr = NULL;
-	MONO_REQ_GC_UNSAFE_MODE;
-	g_assert (method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL);
-	g_assert (status_out);
-	if (piinfo->addr)
-		return piinfo->addr;
-	if (image_is_dynamic (image)) {
-		MonoReflectionMethodAux *method_aux =
-			(MonoReflectionMethodAux *)g_hash_table_lookup (
-				((MonoDynamicImage*)m_class_get_image (method->klass))->method_aux_hash, method);
-		if (!method_aux)
-			goto exit;
-		orig_import = method_aux->dllentry;
-		orig_scope = method_aux->dll;
-	}
-	else {
-		if (!piinfo->implmap_idx || mono_metadata_table_bounds_check (image, MONO_TABLE_IMPLMAP, piinfo->implmap_idx))
-			goto exit;
-		mono_metadata_decode_row (im, piinfo->implmap_idx - 1, im_cols, MONO_IMPLMAP_SIZE);
-		if (!im_cols [MONO_IMPLMAP_SCOPE] || mono_metadata_table_bounds_check (image, MONO_TABLE_MODULEREF, im_cols [MONO_IMPLMAP_SCOPE]))
-			goto exit;
-		piinfo->piflags = GUINT32_TO_UINT16 (im_cols [MONO_IMPLMAP_FLAGS]);
-		orig_import = mono_metadata_string_heap (image, im_cols [MONO_IMPLMAP_NAME]);
-		scope_token = mono_metadata_decode_row_col (mr, im_cols [MONO_IMPLMAP_SCOPE] - 1, MONO_MODULEREF_NAME);
-		orig_scope = mono_metadata_string_heap (image, scope_token);
-	}
-#ifndef DISABLE_DLLMAP
-	mono_dllmap_lookup (image, orig_scope, orig_import, &new_scope, &new_import);
-#else
-	new_scope = g_strdup (orig_scope);
-	new_import = g_strdup (orig_import);
-#endif
-	error_scope = new_scope;
-	/* If qcalls are disabled, we fall back to the normal pinvoke code for them */
-#ifndef DISABLE_QCALLS
-	if (strcmp (new_scope, "QCall") == 0) {
-		piinfo->addr = mono_lookup_pinvoke_qcall_internal (new_import);
-		if (!piinfo->addr) {
-			mono_trace (G_LOG_LEVEL_WARNING, MONO_TRACE_DLLIMPORT,
-						"Unable to find qcall for '%s'.",
-						new_import);
-			status_out->err_code = LOOKUP_PINVOKE_ERR_NO_SYM;
-			status_out->err_arg = g_strdup (new_import);
-		}
-		return piinfo->addr;
-	}
-#endif
-#ifndef NO_GLOBALIZATION_SHIM
-	addr = default_resolve_dllimport (new_scope, new_import);
-	if (addr)
-		goto exit;
-#endif
-	if (pinvoke_override) {
-		addr = pinvoke_override (new_scope, new_import);
-		if (addr)
-			goto exit;
-	}
-#ifndef HOST_WIN32
-retry_with_libcoreclr:
-#endif
-	{
-		ERROR_DECL (local_error);
-		cinfo = mono_custom_attrs_from_method_checked (method, local_error);
-		mono_error_cleanup (local_error);
-	}
-	flags = get_dllimportsearchpath_flags (cinfo);
-	if (cinfo && !cinfo->cached)
-		mono_custom_attrs_free (cinfo);
-	if (flags < 0) {
-		ERROR_DECL (local_error);
-		cinfo = mono_custom_attrs_from_assembly_checked (m_class_get_image (method->klass)->assembly, TRUE, local_error);
-		mono_error_cleanup (local_error);
-		flags = get_dllimportsearchpath_flags (cinfo);
-		if (cinfo && !cinfo->cached)
-			mono_custom_attrs_free (cinfo);
-	}
-	if (flags < 0)
-		flags = DLLIMPORTSEARCHPATH_ASSEMBLY_DIRECTORY;
-	module = netcore_lookup_native_library (alc, image, new_scope, flags);
-	if (!module) {
-		mono_trace (G_LOG_LEVEL_WARNING, MONO_TRACE_DLLIMPORT,
-				"DllImport unable to load library '%s'.",
-				error_scope);
-		status_out->err_code = LOOKUP_PINVOKE_ERR_NO_LIB;
-		status_out->err_arg = g_strdup (error_scope);
-		goto exit;
-	}
-	mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT,
-				"DllImport searching in: '%s' ('%s').", new_scope, module->full_name);
-	addr = pinvoke_probe_for_symbol (module, piinfo, new_import);
-	if (!addr) {
-#ifndef HOST_WIN32
-		if (strcmp (new_scope, "__Internal") == 0) {
-			g_assert (error_scope == new_scope);
-			new_scope = g_strdup (MONO_LOADER_LIBRARY_NAME);
-			goto retry_with_libcoreclr;
-		}
-#endif
-		status_out->err_code = LOOKUP_PINVOKE_ERR_NO_SYM;
-		status_out->err_arg = g_strdup (new_import);
-		goto exit;
-	}
-	piinfo->addr = addr;
-exit:
-	if (error_scope != new_scope) {
-		g_free ((char *)error_scope);
-	}
-	g_free ((char *)new_import);
-	g_free ((char *)new_scope);
-	return addr;
-}
-static gpointer
-pinvoke_probe_for_symbol (MonoDl *module, MonoMethodPInvoke *piinfo, const char *import)
-{
-	gpointer addr = NULL;
-	ERROR_DECL (symbol_error);
-	mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT,
-				"Searching for '%s'.", import);
-#ifdef HOST_WIN32 // For netcore, name mangling is Windows-exclusive
-	if (piinfo->piflags & PINVOKE_ATTRIBUTE_NO_MANGLE)
-		addr = mono_dl_symbol (module, import, symbol_error);
-	else {
-		/*
-		 * Search using a variety of mangled names
-		 */
-		for (int mangle_stdcall = 0; mangle_stdcall <= 1 && addr == NULL; mangle_stdcall++) {
-#if HOST_WIN32 && HOST_X86
-			const int max_managle_param_count = (mangle_stdcall == 0) ? 0 : 256;
-#else
-			const int max_managle_param_count = 0;
-#endif
-			for (int mangle_charset = 0; mangle_charset <= 1 && addr == NULL; mangle_charset ++) {
-				for (int mangle_param_count = 0; mangle_param_count <= max_managle_param_count && addr == NULL; mangle_param_count += 4) {
-					char *mangled_name = (char*)import;
-					switch (piinfo->piflags & PINVOKE_ATTRIBUTE_CHAR_SET_MASK) {
-					case PINVOKE_ATTRIBUTE_CHAR_SET_UNICODE:
-						/* Try the mangled name first */
-						if (mangle_charset == 0)
-							mangled_name = g_strconcat (import, "W", (const char*)NULL);
-						break;
-					case PINVOKE_ATTRIBUTE_CHAR_SET_AUTO:
-#ifdef HOST_WIN32
-						if (mangle_charset == 0)
-							mangled_name = g_strconcat (import, "W", (const char*)NULL);
-#else
-						/* Try the mangled name last */
-						if (mangle_charset == 1)
-							mangled_name = g_strconcat (import, "A", (const char*)NULL);
-#endif
-						break;
-					case PINVOKE_ATTRIBUTE_CHAR_SET_ANSI:
-					default:
-						/* Try the mangled name last */
-						if (mangle_charset == 1)
-							mangled_name = g_strconcat (import, "A", (const char*)NULL);
-						break;
-					}
-#if HOST_WIN32 && HOST_X86
-					/* Try the stdcall mangled name */
-					/*
-					 * gcc under windows creates mangled names without the underscore, but MS.NET
-					 * doesn't support it, so we doesn't support it either.
-					 */
-					if (mangle_stdcall == 1) {
-						MonoMethod *method = &piinfo->method;
-						int param_count;
-						if (mangle_param_count == 0)
-							param_count = mono_method_signature_internal (method)->param_count * sizeof (gpointer);
-						else
-							/* Try brute force, since it would be very hard to compute the stack usage correctly */
-							param_count = mangle_param_count;
-						char *mangled_stdcall_name = g_strdup_printf ("_%s@%d", mangled_name, param_count);
-						if (mangled_name != import)
-							g_free (mangled_name);
-						mangled_name = mangled_stdcall_name;
-					}
-#endif
-					mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT,
-								"Probing '%s'.", mangled_name);
-					error_init_reuse (symbol_error);
-					addr = mono_dl_symbol (module, mangled_name, symbol_error);
-					if (addr)
-						mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT,
-									"Found as '%s'.", mangled_name);
-					else
-						mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT,
-									"Could not find '%s' due to '%s'.", mangled_name, mono_error_get_message_without_fields (symbol_error));
-					mono_error_cleanup (symbol_error);
-					if (mangled_name != import)
-						g_free (mangled_name);
-				}
-			}
-		}
-	}
-#else
-	addr = mono_dl_symbol (module, import, symbol_error);
-	mono_error_cleanup (symbol_error);
-#endif
-	return addr;
-}
-void
-ves_icall_System_Runtime_InteropServices_NativeLibrary_FreeLib (gpointer lib, MonoError *error)
-{
-	ERROR_DECL (close_error);
-	MonoDl *module;
-	guint32 ref_count;
-	g_assert (lib);
-	if (internal_module && lib == internal_module->handle)
-		return;
-	native_library_lock ();
-	module = netcore_handle_lookup (lib);
-	if (module) {
-		ref_count = mono_refcount_dec (module);
-		if (ref_count > 0)
-			goto leave;
-		g_hash_table_remove (native_library_module_map, module->handle);
-		g_hash_table_add (native_library_module_blocklist, module);
-		mono_dl_close (module, close_error);
-	} else {
-		MonoDl *raw_module = (MonoDl *) g_malloc0 (sizeof (MonoDl));
-		if (raw_module) {
-			raw_module->handle = lib;
-			mono_dl_close (raw_module, close_error);
-		}
-	}
-leave:
-	if (!is_ok (close_error)) {
-		mono_error_set_invalid_operation (error, NULL);
-		mono_error_cleanup (close_error);
-	}
-	native_library_unlock ();
-}
-gpointer
-ves_icall_System_Runtime_InteropServices_NativeLibrary_GetSymbol (gpointer lib, MonoStringHandle symbol_name_handle, MonoBoolean throw_on_error, MonoError *error)
-{
-	MonoDl *module;
-	gpointer symbol = NULL;
-	char *symbol_name;
-	g_assert (lib);
-	ERROR_LOCAL_BEGIN (local_error, error, throw_on_error)
-	symbol_name = mono_string_handle_to_utf8 (symbol_name_handle, error);
-	goto_if_nok (error, leave_nolock);
-	native_library_lock ();
-	module = netcore_handle_lookup (lib);
-	if (module) {
-		symbol = mono_dl_symbol (module, symbol_name, error);
-		if (!symbol) {
-			mono_error_cleanup (error);
-			error_init_reuse (error);
-			mono_error_set_generic_error (error, "System", "EntryPointNotFoundException", "%s: %s", module->full_name, symbol_name);
-		}
-	} else {
-		MonoDl raw_module = { { 0 } };
-		raw_module.handle = lib;
-		symbol = mono_dl_symbol (&raw_module, symbol_name, error);
-		if (!symbol) {
-			mono_error_cleanup (error);
-			error_init_reuse (error);
-			mono_error_set_generic_error (error, "System", "EntryPointNotFoundException", "%p: %s", lib, symbol_name);
-		}
-	}
-	native_library_unlock ();
-leave_nolock:
-	ERROR_LOCAL_END (local_error);
-	g_free (symbol_name);
-	return symbol;
-}
-static MonoDl *
-check_native_library_cache (MonoDl *module)
-{
-	gpointer handle = module->handle;
-	MonoDl *cached_module = netcore_handle_lookup (handle);
-	if (cached_module) {
-		g_free (module->full_name);
-		g_free (module);
-		mono_refcount_inc (cached_module);
-		return cached_module;
-	}
-	g_hash_table_insert (native_library_module_map, handle, (gpointer)module);
-	return module;
-}
-gpointer
-ves_icall_System_Runtime_InteropServices_NativeLibrary_LoadByName (MonoStringHandle lib_name_handle, MonoReflectionAssemblyHandle assembly_handle, MonoBoolean has_search_flag, guint32 search_flag, MonoBoolean throw_on_error, MonoError *error)
-{
-	MonoDl *module;
-	gpointer handle = NULL;
-	MonoAssembly *assembly = MONO_HANDLE_GETVAL (assembly_handle, assembly);
-	MonoImage *image = mono_assembly_get_image_internal (assembly);
-	char *lib_name;
-	ERROR_LOCAL_BEGIN (local_error, error, throw_on_error)
-	lib_name = mono_string_handle_to_utf8 (lib_name_handle, error);
-	goto_if_nok (error, leave);
-	{
-		ERROR_DECL (load_error);
-		module = netcore_probe_for_module (image, lib_name, has_search_flag ? search_flag : DLLIMPORTSEARCHPATH_ASSEMBLY_DIRECTORY, load_error);
-		if (!module) {
-			if (mono_error_get_error_code (load_error) == MONO_ERROR_BAD_IMAGE)
-				mono_error_set_generic_error (error, "System", "BadImageFormatException", "%s", lib_name);
-			else
-				mono_error_set_generic_error (error, "System", "DllNotFoundException", "%s", lib_name);
-		}
-		mono_error_cleanup (load_error);
-	}
-	goto_if_nok (error, leave);
-	native_library_lock ();
-	module = check_native_library_cache (module);
-	native_library_unlock ();
-	handle = module->handle;
-leave:
-	ERROR_LOCAL_END (local_error);
-	g_free (lib_name);
-	return handle;
-}
-gpointer
-ves_icall_System_Runtime_InteropServices_NativeLibrary_LoadFromPath (MonoStringHandle lib_path_handle, MonoBoolean throw_on_error, MonoError *error)
-{
-	MonoDl *module;
-	gpointer handle = NULL;
-	char *lib_path;
-	ERROR_LOCAL_BEGIN (local_error, error, throw_on_error)
-	lib_path = mono_string_handle_to_utf8 (lib_path_handle, error);
-	goto_if_nok (error, leave);
-	ERROR_DECL (load_error);
-	module = mono_dl_open (lib_path, MONO_DL_LAZY, load_error);
-	if (!module) {
-		const char *error_msg = mono_error_get_message_without_fields (load_error);
-		guint16 error_code = mono_error_get_error_code (load_error);
-		mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "DllImport error loading library '%s': '%s'.", lib_path, error_msg);
-		if (error_code == MONO_ERROR_BAD_IMAGE)
-			mono_error_set_generic_error (error, "System", "BadImageFormatException", "'%s': '%s'", lib_path, error_msg);
-		else
-			mono_error_set_generic_error (error, "System", "DllNotFoundException", "'%s': '%s'", lib_path, error_msg);
-	}
-	mono_error_cleanup (load_error);
-	goto_if_nok (error, leave);
-	native_library_lock ();
-	module = check_native_library_cache (module);
-	native_library_unlock ();
-	handle = module->handle;
-leave:
-	ERROR_LOCAL_END (local_error);
-	g_free (lib_path);
-	return handle;
-}
-#ifdef HAVE_ATEXIT
-static void
-delete_bundled_libraries (void)
-{
-	GSList *list;
-	for (list = bundle_library_paths; list != NULL; list = list->next){
-		unlink ((const char*)list->data);
-	}
-	rmdir (bundled_dylibrary_directory);
-}
-#endif
-static void
-bundle_save_library_initialize (void)
-{
-	bundle_save_library_initialized = TRUE;
-	char *path = g_build_filename (g_get_tmp_dir (), "mono-bundle-XXXXXX", (const char*)NULL);
-	bundled_dylibrary_directory = g_mkdtemp (path);
-	g_free (path);
-	if (bundled_dylibrary_directory == NULL)
-		return;
-#ifdef HAVE_ATEXIT
-	atexit (delete_bundled_libraries);
-#endif
-}
-void
-mono_loader_save_bundled_library (int fd, uint64_t offset, uint64_t size, const char *destfname)
-{
-	MonoDl *lib;
-	char *file, *buffer, *internal_path;
-	if (!bundle_save_library_initialized)
-		bundle_save_library_initialize ();
-	file = g_build_filename (bundled_dylibrary_directory, destfname, (const char*)NULL);
-	buffer = g_str_from_file_region (fd, offset, GUINT64_TO_SIZE (size));
-	g_file_set_contents (file, buffer, GUINT64_TO_SIZE (size), NULL);
-	ERROR_DECL (load_error);
-	lib = mono_dl_open (file, MONO_DL_LAZY, load_error);
-	if (!lib) {
-		fprintf (stderr, "Error loading shared library: %s %s\n", file, mono_error_get_message_without_fields (load_error));
-		mono_error_cleanup (load_error);
-		exit (1);
-	}
-	mono_error_assert_ok (load_error);
-	internal_path = g_build_filename (".", destfname, (const char*)NULL);
- 	mono_loader_register_module (internal_path, lib);
-	g_free (internal_path);
-	bundle_library_paths = g_slist_append (bundle_library_paths, file);
-	g_free (buffer);
-}
-void
-mono_loader_install_pinvoke_override (PInvokeOverrideFn override_fn)
-{
-	pinvoke_override = override_fn;
-}

--- a/src/mono/sample/wasm/browser/main.js
+++ b//dev/null
@@ -1,66 +0,0 @@
-import { dotnet, exit } from './dotnet.js'
-function add(a, b) {
-    return a + b;
-}
-function sub(a, b) {
-    return a - b;
-}
-let testError = true;
-let testAbort = true;
-try {
-    const { runtimeBuildInfo, setModuleImports, getAssemblyExports, runMain, getConfig } = await dotnet
-        .withConsoleForwarding()
-        .withElementOnExit()
-        .withModuleConfig({
-            configSrc: "./mono-config.json",
-            imports: {
-                fetch: (url, fetchArgs) => {
-                    if (testAbort && url.indexOf('System.Private.Uri.dll') != -1) {
-                        testAbort = false;
-                        return fetch(url + "?testAbort=true", fetchArgs);
-                    }
-                    if (testError && url.indexOf('System.Console.dll') != -1) {
-                        testError = false;
-                        return fetch(url + "?testError=true", fetchArgs);
-                    }
-                    return fetch(url, fetchArgs);
-                }
-            },
-            onConfigLoaded: (config) => {
-                console.log('user code Module.onConfigLoaded');
-                config.environmentVariables["MONO_LOG_LEVEL"] = "debug"
-            },
-            preInit: () => { console.log('user code Module.preInit'); },
-            preRun: () => { console.log('user code Module.preRun'); },
-            onRuntimeInitialized: () => {
-                console.log('user code Module.onRuntimeInitialized');
-            },
-            onDotnetReady: () => {
-                console.log('user code Module.onDotnetReady');
-            },
-            postRun: () => { console.log('user code Module.postRun'); },
-        })
-        .create();
-    console.log('user code after createDotnetRuntime()');
-    setModuleImports("main.js", {
-        Sample: {
-            Test: {
-                add,
-                sub
-            }
-        }
-    });
-    const config = getConfig();
-    const exports = await getAssemblyExports(config.mainAssemblyName);
-    const meaning = exports.Sample.Test.TestMeaning();
-    console.debug(`meaning: ${meaning}`);
-    if (!exports.Sample.Test.IsPrime(meaning)) {
-        document.getElementById("out").innerHTML = `${meaning} as computed on dotnet ver ${runtimeBuildInfo.productVersion}`;
-        console.debug(`ret: ${meaning}`);
-    }
-    let exit_code = await runMain(config.mainAssemblyName, []);
-    exit(exit_code);
-}
-catch (err) {
-    exit(2, err);
-}

--- a/src/mono/sample/wasm/simple-server/Program.cs
+++ b//dev/null
@@ -1,179 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-using System.Net;
-using System.Diagnostics;
-using System.Runtime.InteropServices;
-namespace HttpServer
-{
-    public sealed class Program
-    {
-        private bool Verbose = false;
-        public static int Main()
-        {
-            if (!HttpListener.IsSupported)
-            {
-                Console.WriteLine("error: HttpListener is not supported.");
-                return -1;
-            }
-            for (int i = 0; i < 10; i++)
-            {
-                if (new Program().StartServer())
-                    break;
-            }
-            return 0;
-        }
-        private bool StartServer()
-        {
-            var port = 8000 + Random.Shared.Next(1000);
-            var listener = new HttpListener();
-            var url = $"http://localhost:{port}/";
-            listener.Prefixes.Add(url);
-            try
-            {
-                listener.Start();
-            }
-            catch (HttpListenerException)
-            {
-                return false;
-            }
-            Console.WriteLine($"Listening on {url}");
-            OpenUrl(url);
-            while (true)
-                HandleRequest(listener);
-        }
-        private void OpenUrl(string url)
-        {
-            var proc = new Process();
-            var si = new ProcessStartInfo();
-            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
-            {
-                si.FileName = url;
-                si.UseShellExecute = true;
-            }
-            else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
-            {
-                si.FileName = "xdg-open";
-                si.ArgumentList.Add(url);
-            }
-            else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
-            {
-                si.FileName = "open";
-                si.ArgumentList.Add(url);
-            }
-            else
-            {
-                System.Console.WriteLine("Don't know how to open url on this OS platform");
-            }
-            proc.StartInfo = si;
-            proc.Start();
-        }
-        private void HandleRequest(HttpListener listener)
-        {
-            var context = listener.GetContext();
-            if (Verbose)
-                Console.WriteLine($"request url: {context.Request.Url}");
-            if (context.Request.HttpMethod == "GET")
-                ServeAsync(context);
-            else if (context.Request.HttpMethod == "POST")
-                ReceivePostAsync(context);
-        }
-        private async void ReceivePostAsync(HttpListenerContext context)
-        {
-            if (Verbose)
-            {
-                Console.WriteLine("got POST request");
-                Console.WriteLine($"  content type: {context.Request.ContentType}");
-            }
-            var url = context.Request.Url;
-            if (url == null)
-                return;
-            var path = url.LocalPath;
-            var contentType = context.Request.ContentType;
-            if (contentType != null && contentType.StartsWith("text/plain") && path.StartsWith("/"))
-            {
-                path = path.Substring(1);
-                if (Verbose)
-                    Console.WriteLine($"  writting POST stream to '{path}' file");
-                var content = await new StreamReader(context.Request.InputStream).ReadToEndAsync().ConfigureAwait(false);
-                await File.WriteAllTextAsync(path, content).ConfigureAwait(false);
-            }
-            else
-                return;
-            var stream = context.Response.OutputStream;
-            stream.Close();
-            context.Response.Close();
-        }
-        private async void ServeAsync(HttpListenerContext context)
-        {
-            if (Verbose)
-                Console.WriteLine("got GET request");
-            var request = context.Request;
-            var url = request.Url;
-            if (url == null)
-                return;
-            string path = url.LocalPath == "/" ? "index.html" : url.LocalPath;
-            if (Verbose)
-                Console.WriteLine($"  serving: {path}");
-            if (path.StartsWith("/"))
-                path = path.Substring(1);
-            byte[]? buffer;
-            try
-            {
-                buffer = await File.ReadAllBytesAsync(path).ConfigureAwait(false);
-            }
-            catch (Exception)
-            {
-                buffer = null;
-            }
-            if (buffer != null)
-            {
-                string? contentType = null;
-                if (path.EndsWith(".wasm"))
-                    contentType = "application/wasm";
-                if (path.EndsWith(".js") || path.EndsWith(".mjs") || path.EndsWith(".cjs"))
-                    contentType = "text/javascript";
-                var stream = context.Response.OutputStream;
-                if (url.Query.Contains("testError"))
-                {
-                    Console.WriteLine("Faking 500 " + url);
-                    context.Response.StatusCode = (int)HttpStatusCode.InternalServerError;
-                    await stream.WriteAsync(buffer, 0, 0).ConfigureAwait(false);
-                    await stream.FlushAsync();
-                    context.Response.Close();
-                    return;
-                }
-                if (contentType != null)
-                    context.Response.ContentType = contentType;
-                context.Response.ContentLength64 = buffer.Length;
-                context.Response.AppendHeader("cache-control", "public, max-age=31536000");
-                if (url.Query.Contains("testAbort"))
-                {
-                    Console.WriteLine("Faking abort " + url);
-                    await stream.WriteAsync(buffer, 0, 10).ConfigureAwait(false);
-                    await stream.FlushAsync();
-                    await Task.Delay(100);
-                    context.Response.Abort();
-                    return;
-                }
-                try
-                {
-                    await stream.WriteAsync(buffer).ConfigureAwait(false);
-                }
-                catch (Exception e)
-                {
-                    if (Verbose)
-                        Console.WriteLine($"interrupted: {e.Message}");
-                }
-                stream.Close();
-                context.Response.Close();
-            }
-            else
-            {
-                if (Verbose)
-                    Console.WriteLine("  => not found");
-                context.Response.StatusCode = (int)HttpStatusCode.NotFound;
-            }
-            if (Verbose)
-                Console.WriteLine($"finished url: {context.Request.Url}");
-        }
-    }
-}

--- a/src/mono/wasm/debugger/BrowserDebugProxy/MonoProxy.cs
+++ b//dev/null
@@ -1,1600 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.IO;
-using System.Linq;
-using System.Threading;
-using System.Threading.Tasks;
-using Microsoft.CodeAnalysis;
-using Microsoft.Extensions.Logging;
-using Newtonsoft.Json;
-using Newtonsoft.Json.Linq;
-using System.Net.Http;
-using BrowserDebugProxy;
-namespace Microsoft.WebAssembly.Diagnostics
-{
-    internal class MonoProxy : DevToolsProxy
-    {
-        private IList<string> urlSymbolServerList;
-        private HashSet<SessionId> sessions = new HashSet<SessionId>();
-        protected Dictionary<SessionId, ExecutionContext> contexts = new Dictionary<SessionId, ExecutionContext>();
-        public static HttpClient HttpClient => new HttpClient();
-        public int RuntimeId { get; private init; }
-        public bool JustMyCode { get; private set; }
-        private PauseOnExceptionsKind _defaultPauseOnExceptions { get; set; }
-        protected readonly ProxyOptions _options;
-        public MonoProxy(ILogger logger, IList<string> urlSymbolServerList, int runtimeId = 0, string loggerId = "", ProxyOptions options = null) : base(logger, loggerId)
-        {
-            this.urlSymbolServerList = urlSymbolServerList ?? new List<string>();
-            RuntimeId = runtimeId;
-            _options = options;
-            _defaultPauseOnExceptions = PauseOnExceptionsKind.Unset;
-        }
-        internal ExecutionContext GetContext(SessionId sessionId)
-        {
-            if (contexts.TryGetValue(sessionId, out ExecutionContext context))
-                return context;
-            throw new ArgumentException($"Invalid Session: \"{sessionId}\"", nameof(sessionId));
-        }
-        private bool UpdateContext(SessionId sessionId, ExecutionContext executionContext, out ExecutionContext previousExecutionContext)
-        {
-            bool previous = contexts.TryGetValue(sessionId, out previousExecutionContext);
-            contexts[sessionId] = executionContext;
-            return previous;
-        }
-        internal virtual Task<Result> SendMonoCommand(SessionId id, MonoCommands cmd, CancellationToken token) => SendCommand(id, "Runtime.evaluate", JObject.FromObject(cmd), token);
-        internal void SendLog(SessionId sessionId, string message, CancellationToken token, string type = "warning")
-        {
-            if (!contexts.TryGetValue(sessionId, out ExecutionContext context))
-                return;
-            /*var o = JObject.FromObject(new
-            {
-                entry = JObject.FromObject(new
-                {
-                    source = "recommendation",
-                    level = "warning",
-                    text = message
-                })
-            });
-            SendEvent(id, "Log.enabled", null, token);
-            SendEvent(id, "Log.entryAdded", o, token);*/
-            var o = JObject.FromObject(new
-            {
-                type,
-                args = new JArray(JObject.FromObject(new
-                                {
-                                    type = "string",
-                                    value = message,
-                                })),
-                executionContextId = context.Id
-            });
-            SendEvent(sessionId, "Runtime.consoleAPICalled", o, token);
-        }
-        protected override async Task<bool> AcceptEvent(SessionId sessionId, JObject parms, CancellationToken token)
-        {
-            var method = parms["method"].Value<string>();
-            var args = parms["params"] as JObject;
-            switch (method)
-            {
-                case "Runtime.consoleAPICalled":
-                    {
-                        if (!contexts.TryGetValue(sessionId, out ExecutionContext context))
-                            return false;
-                        string type = args["type"]?.ToString();
-                        if (type == "debug")
-                        {
-                            JToken a = args["args"];
-                            if (a is null)
-                                break;
-                            int aCount = a.Count();
-                            if (aCount >= 2 &&
-                                a[0]?["value"]?.ToString() == MonoConstants.RUNTIME_IS_READY &&
-                                a[1]?["value"]?.ToString() == MonoConstants.RUNTIME_IS_READY_ID)
-                            {
-                                if (aCount > 2)
-                                {
-                                    try
-                                    {
-                                        string loaded = a[2]?["value"]?.ToString();
-                                        if (loaded != null)
-                                            context.LoadedFiles = JToken.Parse(loaded).ToObject<string[]>();
-                                    }
-                                    catch (InvalidCastException ice)
-                                    {
-                                        Log("verbose", ice.ToString());
-                                    }
-                                }
-                                await RuntimeReady(sessionId, token);
-                            }
-                            else if (aCount > 1 && a[0]?["value"]?.ToString() == MonoConstants.EVENT_RAISED)
-                            {
-                                if (a.Type != JTokenType.Array)
-                                {
-                                    logger.LogDebug($"Invalid event raised args, expected an array: {a.Type}");
-                                }
-                                else
-                                {
-                                    if (aCount > 2 &&
-                                        JObjectTryParse(a?[2]?["value"]?.Value<string>(), out JObject raiseArgs) &&
-                                        JObjectTryParse(a?[1]?["value"]?.Value<string>(), out JObject eventArgs))
-                                    {
-                                        await OnJSEventRaised(sessionId, eventArgs, token);
-                                        if (raiseArgs?["trace"]?.Value<bool>() == true) {
-                                            return false;
-                                        }
-                                    }
-                                }
-                                return true;
-                            }
-                        }
-                        break;
-                    }
-                case "Runtime.executionContextCreated":
-                    {
-                        await SendEvent(sessionId, method, args, token);
-                        JToken ctx = args?["context"];
-                        var aux_data = ctx?["auxData"] as JObject;
-                        int id = ctx["id"].Value<int>();
-                        if (aux_data != null)
-                        {
-                            bool? is_default = aux_data["isDefault"]?.Value<bool>();
-                            if (is_default == true)
-                            {
-                                await OnDefaultContext(sessionId, new ExecutionContext(new MonoSDBHelper (this, logger, sessionId), id, aux_data, _defaultPauseOnExceptions), token);
-                            }
-                        }
-                        return true;
-                    }
-                case "Debugger.paused":
-                    {
-                        if (!contexts.ContainsKey(sessionId))
-                            return false;
-                        if (args?["callFrames"]?.Value<JArray>()?.Count == 0)
-                            return false;
-                        string top_func = args?["callFrames"]?[0]?["functionName"]?.Value<string>();
-                        switch (top_func) {
-                            case "mono_wasm_set_entrypoint_breakpoint":
-                            case "_mono_wasm_set_entrypoint_breakpoint":
-                                {
-                                    await OnSetEntrypointBreakpoint(sessionId, args, token);
-                                    return true;
-                                }
-                            case "mono_wasm_runtime_ready":
-                            case "_mono_wasm_runtime_ready":
-                                {
-                                    await RuntimeReady(sessionId, token);
-                                    await SendResume(sessionId, token);
-                                    return true;
-                                }
-                            case "mono_wasm_fire_debugger_agent_message":
-                            case "_mono_wasm_fire_debugger_agent_message":
-                                {
-                                    try {
-                                        return await OnReceiveDebuggerAgentEvent(sessionId, args, token);
-                                    }
-                                    catch (Exception) //if the page is refreshed maybe it stops here.
-                                    {
-                                        await SendResume(sessionId, token);
-                                        return true;
-                                    }
-                                }
-                        }
-                        break;
-                    }
-                case "Debugger.breakpointResolved":
-                    {
-                        break;
-                    }
-                case "Debugger.scriptParsed":
-                    {
-                        string url = args?["url"]?.Value<string>() ?? "";
-                        switch (url)
-                        {
-                            case var _ when url == "":
-                            {
-                                logger.LogTrace($"ignoring empty: Debugger.scriptParsed {url}");
-                                return true;
-                            }
-                        }
-                        logger.LogTrace($"proxying Debugger.scriptParsed ({sessionId.sessionId}) {url} {args}");
-                        break;
-                    }
-                case "Target.attachedToTarget":
-                    {
-                        if (args["targetInfo"]["type"]?.ToString() == "page")
-                            await AttachToTarget(new SessionId(args["sessionId"]?.ToString()), token);
-                        break;
-                    }
-                case "Target.targetDestroyed":
-                    {
-                        await SendMonoCommand(sessionId, MonoCommands.DetachDebugger(RuntimeId), token);
-                        break;
-                    }
-            }
-            return false;
-        }
-        protected virtual async Task SendResume(SessionId id, CancellationToken token)
-        {
-            await SendCommand(id, "Debugger.resume", new JObject(), token);
-        }
-        protected async Task<bool> IsRuntimeAlreadyReadyAlready(SessionId sessionId, CancellationToken token)
-        {
-            if (contexts.TryGetValue(sessionId, out ExecutionContext context) && context.IsRuntimeReady)
-                return true;
-            Result res = await SendMonoCommand(sessionId, MonoCommands.IsRuntimeReady(RuntimeId), token);
-            return res.Value?["result"]?["value"]?.Value<bool>() ?? false;
-        }
-        private static PauseOnExceptionsKind GetPauseOnExceptionsStatusFromString(string state)
-        {
-            PauseOnExceptionsKind pauseOnException;
-            if (Enum.TryParse(state, true, out pauseOnException))
-                return pauseOnException;
-            return PauseOnExceptionsKind.Unset;
-        }
-        protected override async Task<bool> AcceptCommand(MessageId id, JObject parms, CancellationToken token)
-        {
-            var method = parms["method"].Value<string>();
-            var args = parms["params"] as JObject;
-            if (id == SessionId.Null)
-                await AttachToTarget(id, token);
-            if (!contexts.TryGetValue(id, out ExecutionContext context))
-            {
-                if  (method == "Debugger.setPauseOnExceptions")
-                {
-                    string state = args["state"].Value<string>();
-                    var pauseOnException = GetPauseOnExceptionsStatusFromString(state);
-                    if (pauseOnException != PauseOnExceptionsKind.Unset)
-                        _defaultPauseOnExceptions = pauseOnException;
-                }
-                if (method != "DotnetDebugger.setDebuggerProperty")
-                {
-                    return method.StartsWith("DotnetDebugger.", StringComparison.OrdinalIgnoreCase);
-                }
-            }
-            switch (method)
-            {
-                case "Target.attachToTarget":
-                    {
-                        Result resp = await SendCommand(id, method, args, token);
-                        await AttachToTarget(new SessionId(resp.Value["sessionId"]?.ToString()), token);
-                        break;
-                    }
-                case "Debugger.enable":
-                    {
-                        Result resp = await SendCommand(id, method, args, token);
-                        if (!resp.IsOk)
-                        {
-                            SendResponse(id, resp, token);
-                            return true;
-                        }
-                        context.DebugId = resp.Value["DebugId"]?.ToString();
-                        if (await IsRuntimeAlreadyReadyAlready(id, token))
-                            await RuntimeReady(id, token);
-                        SendResponse(id, resp, token);
-                        return true;
-                    }
-                case "Debugger.getScriptSource":
-                    {
-                        string script = args?["scriptId"]?.Value<string>();
-                        return await OnGetScriptSource(id, script, token);
-                    }
-                case "Runtime.compileScript":
-                    {
-                        string exp = args?["expression"]?.Value<string>();
-                        if (exp.StartsWith("//dotnet:", StringComparison.Ordinal))
-                        {
-                            OnCompileDotnetScript(id, token);
-                            return true;
-                        }
-                        break;
-                    }
-                case "Debugger.getPossibleBreakpoints":
-                    {
-                        Result resp = await SendCommand(id, method, args, token);
-                        if (resp.IsOk && resp.Value["locations"].HasValues)
-                        {
-                            SendResponse(id, resp, token);
-                            return true;
-                        }
-                        var start = SourceLocation.Parse(args?["start"] as JObject);
-                        var end = SourceLocation.Parse(args?["end"] as JObject);
-                        if (start != null && end != null && await GetPossibleBreakpoints(id, start, end, token))
-                            return true;
-                        SendResponse(id, resp, token);
-                        return true;
-                    }
-                case "Debugger.setBreakpoint":
-                    {
-                        break;
-                    }
-                case "Debugger.setBreakpointByUrl":
-                    {
-                        Result resp = await SendCommand(id, method, args, token);
-                        if (!resp.IsOk)
-                        {
-                            SendResponse(id, resp, token);
-                            return true;
-                        }
-                        try
-                        {
-                            string bpid = resp.Value["breakpointId"]?.ToString();
-                            IEnumerable<object> locations = resp.Value["locations"]?.Values<object>();
-                            var request = BreakpointRequest.Parse(bpid, args);
-                            bool loaded = context.Source.Task.IsCompleted;
-                            if (!loaded)
-                            {
-                                context.BreakpointRequests[bpid] = request;
-                                SendResponse(id, resp, token);
-                            }
-                            if (await IsRuntimeAlreadyReadyAlready(id, token))
-                            {
-                                DebugStore store = await RuntimeReady(id, token);
-                                Log("verbose", $"BP req {args}");
-                                await SetBreakpoint(id, store, request, !loaded, false, token);
-                            }
-                            if (loaded)
-                            {
-                                context.BreakpointRequests[bpid] = request;
-                                var result = Result.OkFromObject(request.AsSetBreakpointByUrlResponse(locations));
-                                SendResponse(id, result, token);
-                            }
-                        }
-                        catch (Exception e)
-                        {
-                            logger.LogDebug($"Debugger.setBreakpointByUrl - {args} - failed with exception: {e}");
-                            SendResponse(id, Result.Err($"Debugger.setBreakpointByUrl - {args} - failed with exception: {e}"), token);
-                        }
-                        return true;
-                    }
-                case "Debugger.removeBreakpoint":
-                    {
-                        await RemoveBreakpoint(id, args, false, token);
-                        break;
-                    }
-                case "Debugger.resume":
-                    {
-                        await OnResume(id, token);
-                        break;
-                    }
-                case "Debugger.stepInto":
-                    {
-                        return await Step(id, StepKind.Into, token);
-                    }
-                case "Debugger.setVariableValue":
-                    {
-                        if (!DotnetObjectId.TryParse(args?["callFrameId"], out DotnetObjectId objectId))
-                            return false;
-                        switch (objectId.Scheme)
-                        {
-                            case "scope":
-                                return await OnSetVariableValue(id,
-                                    objectId.Value,
-                                    args?["variableName"]?.Value<string>(),
-                                    args?["newValue"],
-                                    token);
-                            default:
-                                return false;
-                        }
-                    }
-                case "Debugger.stepOut":
-                    {
-                        return await Step(id, StepKind.Out, token);
-                    }
-                case "Debugger.stepOver":
-                    {
-                        return await Step(id, StepKind.Over, token);
-                    }
-                case "Runtime.evaluate":
-                    {
-                        if (context.CallStack != null)
-                        {
-                            Frame scope = context.CallStack.First<Frame>();
-                            return await OnEvaluateOnCallFrame(id,
-                                    scope.Id,
-                                    args?["expression"]?.Value<string>(), token);
-                        }
-                        break;
-                    }
-                case "Debugger.evaluateOnCallFrame":
-                    {
-                        if (!DotnetObjectId.TryParse(args?["callFrameId"], out DotnetObjectId objectId))
-                            return false;
-                        switch (objectId.Scheme)
-                        {
-                            case "scope":
-                                return await OnEvaluateOnCallFrame(id,
-                                    objectId.Value,
-                                    args?["expression"]?.Value<string>(), token);
-                            default:
-                                return false;
-                        }
-                    }
-                case "Runtime.getProperties":
-                    {
-                        if (!DotnetObjectId.TryParse(args?["objectId"], out DotnetObjectId objectId))
-                            break;
-                        var valueOrError = await RuntimeGetObjectMembers(id, objectId, args, token, true);
-                        if (valueOrError.IsError)
-                        {
-                            logger.LogDebug($"Runtime.getProperties: {valueOrError.Error}");
-                            SendResponse(id, valueOrError.Error.Value, token);
-                            return true;
-                        }
-                        if (valueOrError.Value.JObject == null)
-                        {
-                            SendResponse(id, Result.Err($"Failed to get properties for '{objectId}'"), token);
-                            return true;
-                        }
-                        SendResponse(id, Result.OkFromObject(valueOrError.Value.JObject), token);
-                        return true;
-                    }
-                case "Runtime.releaseObject":
-                    {
-                        if (!(DotnetObjectId.TryParse(args["objectId"], out DotnetObjectId objectId) && objectId.Scheme == "cfo_res"))
-                            break;
-                        await SendMonoCommand(id, MonoCommands.ReleaseObject(RuntimeId, objectId), token);
-                        SendResponse(id, Result.OkFromObject(new { }), token);
-                        return true;
-                    }
-                case "Debugger.setPauseOnExceptions":
-                    {
-                        string state = args["state"].Value<string>();
-                        var pauseOnException = GetPauseOnExceptionsStatusFromString(state);
-                        if (pauseOnException != PauseOnExceptionsKind.Unset)
-                            context.PauseOnExceptions = pauseOnException;
-                        if (context.IsRuntimeReady)
-                            await context.SdbAgent.EnableExceptions(context.PauseOnExceptions, token);
-                        return false;
-                    }
-                case "DotnetDebugger.setDebuggerProperty":
-                    {
-                        foreach (KeyValuePair<string, JToken> property in args)
-                        {
-                            switch (property.Key)
-                            {
-                                case "JustMyCodeStepping":
-                                    SetJustMyCode(id, (bool) property.Value, token);
-                                break;
-                                default:
-                                    logger.LogDebug($"DotnetDebugger.setDebuggerProperty failed for {property.Key} with value {property.Value}");
-                                break;
-                            }
-                        }
-                        return true;
-                    }
-                case "DotnetDebugger.setNextIP":
-                    {
-                        var loc = SourceLocation.Parse(args?["location"] as JObject);
-                        if (loc == null)
-                            return false;
-                        bool ret = await OnSetNextIP(id, loc, token);
-                        if (ret)
-                            SendResponse(id, Result.OkFromObject(new { }), token);
-                        else
-                            SendResponse(id, Result.Err("Set next instruction pointer failed."), token);
-                        return true;
-                    }
-                case "DotnetDebugger.applyUpdates":
-                    {
-                        if (await ApplyUpdates(id, args, token))
-                            SendResponse(id, Result.OkFromObject(new { }), token);
-                        else
-                            SendResponse(id, Result.Err("ApplyUpdate failed."), token);
-                        return true;
-                    }
-                case "DotnetDebugger.addSymbolServerUrl":
-                    {
-                        string url = args["url"]?.Value<string>();
-                        if (!string.IsNullOrEmpty(url) && !urlSymbolServerList.Contains(url))
-                            urlSymbolServerList.Add(url);
-                        return true;
-                    }
-                case "DotnetDebugger.getMethodLocation":
-                    {
-                        SendResponse(id, await GetMethodLocation(id, args, token), token);
-                        return true;
-                    }
-                case "Runtime.callFunctionOn":
-                    {
-                        try {
-                            return await CallOnFunction(id, args, token);
-                        }
-                        catch (Exception ex) {
-                            logger.LogDebug($"Runtime.callFunctionOn failed for {id} with args {args}: {ex}");
-                            SendResponse(id,
-                                Result.Exception(new ArgumentException(
-                                    $"Runtime.callFunctionOn not supported with ({args["objectId"]}).")),
-                                token);
-                            return true;
-                        }
-                    }
-            }
-            return method.StartsWith("DotnetDebugger.", StringComparison.OrdinalIgnoreCase);
-        }
-        private async Task<bool> ApplyUpdates(MessageId id, JObject args, CancellationToken token)
-        {
-            var context = GetContext(id);
-            string moduleGUID = args["moduleGUID"]?.Value<string>();
-            string dmeta = args["dmeta"]?.Value<string>();
-            string dil = args["dil"]?.Value<string>();
-            string dpdb = args["dpdb"]?.Value<string>();
-            var moduleId = await context.SdbAgent.GetModuleId(moduleGUID, token);
-            var applyUpdates =  await context.SdbAgent.ApplyUpdates(moduleId, dmeta, dil, dpdb, token);
-            return applyUpdates;
-        }
-        private void SetJustMyCode(MessageId id, bool isEnabled, CancellationToken token)
-        {
-            JustMyCode = isEnabled;
-            SendResponse(id, Result.OkFromObject(new { justMyCodeEnabled = JustMyCode }), token);
-        }
-        internal async Task<Result> GetMethodLocation(MessageId id, JObject args, CancellationToken token)
-        {
-            DebugStore store = await RuntimeReady(id, token);
-            string aname = args["assemblyName"]?.Value<string>();
-            string typeName = args["typeName"]?.Value<string>();
-            string methodName = args["methodName"]?.Value<string>();
-            if (aname == null || typeName == null || methodName == null)
-            {
-                return Result.Err("Invalid protocol message '" + args + "'.");
-            }
-            AssemblyInfo assembly = store.GetAssemblyByName(aname);
-            if (assembly == null)
-                assembly = store.GetAssemblyByName(aname + ".exe");
-            if (assembly == null)
-                assembly = store.GetAssemblyByName(aname + ".dll");
-            if (assembly == null)
-            {
-                return Result.Err($"Assembly '{aname}' not found," +
-                                    $"needed to get method location of '{typeName}:{methodName}'");
-            }
-            TypeInfo type = assembly.GetTypeByName(typeName);
-            if (type == null)
-            {
-                return Result.Err($"Type '{typeName}' not found.");
-            }
-            MethodInfo methodInfo = type.Methods.FirstOrDefault(m => m.Name == methodName);
-            if (methodInfo?.Source is null)
-            {
-                methodInfo = assembly.TypesByName.Values.SingleOrDefault(t => t.FullName.StartsWith($"{typeName}.<{methodName}>"))?
-                    .Methods.FirstOrDefault(mi => mi.Name == "MoveNext");
-            }
-            if (methodInfo == null)
-            {
-                return Result.Err($"Method '{typeName}:{methodName}' not found.");
-            }
-            string src_url = methodInfo.Assembly.Sources.Single(sf => sf.SourceId == methodInfo.SourceId).Url;
-            return Result.OkFromObject(new
-            {
-                result = new { line = methodInfo.StartLocation.Line, column = methodInfo.StartLocation.Column, url = src_url }
-            });
-        }
-        private async Task<bool> CallOnFunction(MessageId id, JObject args, CancellationToken token)
-        {
-            var context = GetContext(id);
-            if (!DotnetObjectId.TryParse(args["objectId"], out DotnetObjectId objectId)) {
-                return false;
-            }
-            switch (objectId.Scheme)
-            {
-                case "method":
-                    args["details"] = await context.SdbAgent.GetMethodProxy(objectId.ValueAsJson, token);
-                    break;
-                case "object":
-                    args["details"] = await context.SdbAgent.GetObjectProxy(objectId.Value, token);
-                    break;
-                case "valuetype":
-                    var valueType = context.SdbAgent.GetValueTypeClass(objectId.Value);
-                    if (valueType == null)
-                        throw new Exception($"Internal Error: No valuetype found for {objectId}.");
-                    args["details"] = await valueType.GetProxy(context.SdbAgent, token);
-                    break;
-                case "pointer":
-                    args["details"] = await context.SdbAgent.GetPointerContent(objectId.Value, token);
-                    break;
-                case "array":
-                    args["details"] = await context.SdbAgent.GetArrayValuesProxy(objectId.Value, token);
-                    break;
-                case "cfo_res":
-                    Result cfo_res = await SendMonoCommand(id, MonoCommands.CallFunctionOn(RuntimeId, args), token);
-                    cfo_res = Result.OkFromObject(new { result = cfo_res.Value?["result"]?["value"]});
-                    SendResponse(id, cfo_res, token);
-                    return true;
-                case "scope":
-                {
-                    SendResponse(id,
-                    Result.Exception(new ArgumentException(
-                        $"Runtime.callFunctionOn not supported with scope ({objectId}).")),
-                        token);
-                    return true;
-                }
-                default:
-                    return false;
-            }
-            Result res = await SendMonoCommand(id, MonoCommands.CallFunctionOn(RuntimeId, args), token);
-            if (!res.IsOk)
-            {
-                SendResponse(id, res, token);
-                return true;
-            }
-            if (res.Value?["result"]?["value"]?["type"] == null) //it means that is not a buffer returned from the debugger-agent
-            {
-                byte[] newBytes = Convert.FromBase64String(res.Value?["result"]?["value"]?["value"]?.Value<string>());
-                var retDebuggerCmdReader = new MonoBinaryReader(newBytes);
-                retDebuggerCmdReader.ReadByte(); //number of objects returned.
-                var obj = await context.SdbAgent.ValueCreator.ReadAsVariableValue(retDebuggerCmdReader, "ret", token);
-                /*JTokenType? res_value_type = res.Value?["result"]?["value"]?.Type;*/
-                res = Result.OkFromObject(new { result = obj["value"]});
-                SendResponse(id, res, token);
-                return true;
-            }
-            res = Result.OkFromObject(new { result = res.Value?["result"]?["value"]});
-            SendResponse(id, res, token);
-            return true;
-        }
-        private async Task<bool> OnSetVariableValue(MessageId id, int scopeId, string varName, JToken varValue, CancellationToken token)
-        {
-            ExecutionContext context = GetContext(id);
-            Frame scope = context.CallStack.FirstOrDefault(s => s.Id == scopeId);
-            if (scope == null)
-                return false;
-            var varIds = scope.Method.Info.GetLiveVarsAt(scope.Location.IlLocation.Offset);
-            if (varIds == null)
-                return false;
-            var varToSetValue = varIds.FirstOrDefault(v => v.Name == varName);
-            if (varToSetValue == null)
-                return false;
-            var res = await context.SdbAgent.SetVariableValue(context.ThreadId, scopeId, varToSetValue.Index, varValue["value"].Value<string>(), token);
-            if (res)
-                SendResponse(id, Result.Ok(new JObject()), token);
-            else
-                SendResponse(id, Result.Err($"Unable to set '{varValue["value"].Value<string>()}' to variable '{varName}'"), token);
-            return true;
-        }
-        internal async Task<ValueOrError<GetMembersResult>> RuntimeGetObjectMembers(SessionId id, DotnetObjectId objectId, JToken args, CancellationToken token, bool sortByAccessLevel = false)
-        {
-            var context = GetContext(id);
-            GetObjectCommandOptions getObjectOptions = GetObjectCommandOptions.WithProperties;
-            if (args != null)
-            {
-                if (args["accessorPropertiesOnly"]?.Value<bool>() == true)
-                    getObjectOptions |= GetObjectCommandOptions.AccessorPropertiesOnly;
-                if (args["ownProperties"]?.Value<bool>() == true)
-                    getObjectOptions |= GetObjectCommandOptions.OwnProperties;
-                if (args["forDebuggerDisplayAttribute"]?.Value<bool>() == true)
-                    getObjectOptions |= GetObjectCommandOptions.ForDebuggerDisplayAttribute;
-            }
-            if (JustMyCode)
-                getObjectOptions |= GetObjectCommandOptions.JustMyCode;
-            try
-            {
-                switch (objectId.Scheme)
-                {
-                    case "scope":
-                        Result resScope = await GetScopeProperties(id, objectId.Value, token);
-                        return resScope.IsOk
-                            ? ValueOrError<GetMembersResult>.WithValue(
-                                new GetMembersResult((JArray)resScope.Value?["result"], sortByAccessLevel: false))
-                            : ValueOrError<GetMembersResult>.WithError(resScope);
-                    case "valuetype":
-                        var resValue = await MemberObjectsExplorer.GetValueTypeMemberValues(
-                            context.SdbAgent, objectId.Value, getObjectOptions, token, sortByAccessLevel, includeStatic: true);
-                        return resValue switch
-                        {
-                            null => ValueOrError<GetMembersResult>.WithError($"Could not get properties for {objectId}"),
-                            _ => ValueOrError<GetMembersResult>.WithValue(resValue)
-                        };
-                    case "array":
-                        var resArr = await context.SdbAgent.GetArrayValues(objectId.Value, token);
-                        return ValueOrError<GetMembersResult>.WithValue(GetMembersResult.FromValues(resArr));
-                    case "method":
-                        var resMethod = await context.SdbAgent.InvokeMethod(objectId, token);
-                        return ValueOrError<GetMembersResult>.WithValue(GetMembersResult.FromValues(new JArray(resMethod)));
-                    case "object":
-                        var resObj = await MemberObjectsExplorer.GetObjectMemberValues(
-                            context.SdbAgent, objectId.Value, getObjectOptions, token, sortByAccessLevel, includeStatic: true);
-                        return ValueOrError<GetMembersResult>.WithValue(resObj);
-                    case "pointer":
-                        var resPointer = new JArray { await context.SdbAgent.GetPointerContent(objectId.Value, token) };
-                        return ValueOrError<GetMembersResult>.WithValue(GetMembersResult.FromValues(resPointer));
-                    case "cfo_res":
-                        Result res = await SendMonoCommand(id, MonoCommands.GetDetails(RuntimeId, objectId.Value, args), token);
-                        string value_json_str = res.Value["result"]?["value"]?["__value_as_json_string__"]?.Value<string>();
-                        if (res.IsOk && value_json_str == null)
-                            return ValueOrError<GetMembersResult>.WithError(
-                                $"Internal error: Could not find expected __value_as_json_string__ field in the result: {res}");
-                        return value_json_str != null
-                                    ? ValueOrError<GetMembersResult>.WithValue(GetMembersResult.FromValues(JArray.Parse(value_json_str)))
-                                    : ValueOrError<GetMembersResult>.WithError(res);
-                    case "evaluationResult":
-                        JArray evaluationRes = (JArray)context.SdbAgent.GetEvaluationResultProperties(objectId.ToString());
-                        return ValueOrError<GetMembersResult>.WithValue(GetMembersResult.FromValues(evaluationRes));
-                    default:
-                        return ValueOrError<GetMembersResult>.WithError($"RuntimeGetProperties: unknown object id scheme: {objectId.Scheme}");
-                }
-            }
-            catch (Exception ex)
-            {
-                return ValueOrError<GetMembersResult>.WithError($"RuntimeGetProperties: Failed to get properties for {objectId}: {ex}");
-            }
-        }
-        protected async Task<bool> EvaluateCondition(SessionId sessionId, ExecutionContext context, Frame mono_frame, Breakpoint bp, CancellationToken token)
-        {
-            if (string.IsNullOrEmpty(bp?.Condition) || mono_frame == null)
-                return true;
-            string condition = bp.Condition;
-            if (bp.ConditionAlreadyEvaluatedWithError)
-                return false;
-            try {
-                var resolver = new MemberReferenceResolver(this, context, sessionId, mono_frame.Id, logger);
-                JObject retValue = await resolver.Resolve(condition, token);
-                if (retValue == null)
-                    retValue = await ExpressionEvaluator.CompileAndRunTheExpression(condition, resolver, logger, token);
-                if (retValue?["value"]?.Type == JTokenType.Boolean ||
-                    retValue?["value"]?.Type == JTokenType.Integer ||
-                    retValue?["value"]?.Type == JTokenType.Float) {
-                    if (retValue?["value"]?.Value<bool>() == true)
-                        return true;
-                }
-                else if (retValue?["value"] != null && // null object, missing value
-                         retValue?["value"]?.Type != JTokenType.Null)
-                {
-                    return true;
-                }
-            }
-            catch (ReturnAsErrorException raee)
-            {
-                logger.LogDebug($"Unable to evaluate breakpoint condition '{condition}': {raee}");
-                SendLog(sessionId, $"Unable to evaluate breakpoint condition '{condition}': {raee.Message}", token, type: "error");
-                bp.ConditionAlreadyEvaluatedWithError = true;
-            }
-            catch (Exception e)
-            {
-                Log("info", $"Unable to evaluate breakpoint condition '{condition}': {e}");
-                bp.ConditionAlreadyEvaluatedWithError = true;
-            }
-            return false;
-        }
-        private async Task<bool> ProcessEnC(SessionId sessionId, ExecutionContext context, MonoBinaryReader retDebuggerCmdReader, CancellationToken token)
-        {
-            int moduleId = retDebuggerCmdReader.ReadInt32();
-            int meta_size = retDebuggerCmdReader.ReadInt32();
-            byte[] meta_buf = retDebuggerCmdReader.ReadBytes(meta_size);
-            int pdb_size = retDebuggerCmdReader.ReadInt32();
-            byte[] pdb_buf = retDebuggerCmdReader.ReadBytes(pdb_size);
-            var assemblyName = await context.SdbAgent.GetAssemblyNameFromModule(moduleId, token);
-            DebugStore store = await LoadStore(sessionId, true, token);
-            AssemblyInfo asm = store.GetAssemblyByName(assemblyName);
-            var methods = DebugStore.EnC(asm, meta_buf, pdb_buf);
-            foreach (var method in methods)
-            {
-                await ResetBreakpoint(sessionId, store, method, token);
-            }
-            var files = methods.Distinct(new MethodInfo.SourceComparer());
-            foreach (var file in files)
-            {
-                JObject scriptSource = JObject.FromObject(file.Source.ToScriptSource(context.Id, context.AuxData));
-                Log("debug", $"sending after update {file.Source.Url} {context.Id} {sessionId.sessionId}");
-                await SendEvent(sessionId, "Debugger.scriptParsed", scriptSource, token);
-            }
-            return true;
-        }
-        private async Task<bool> SendBreakpointsOfMethodUpdated(SessionId sessionId, ExecutionContext context, MonoBinaryReader retDebuggerCmdReader, CancellationToken token)
-        {
-            var methodId = retDebuggerCmdReader.ReadInt32();
-            var method = await context.SdbAgent.GetMethodInfo(methodId, token);
-            if (method == null || method.Info.Source is null)
-            {
-                return true;
-            }
-            foreach (var req in context.BreakpointRequests.Values)
-            {
-                if (req.TryResolve(method.Info.Source))
-                {
-                    await SetBreakpoint(sessionId, context.store, req, true, true, token);
-                }
-            }
-            return true;
-        }
-        protected virtual async Task<bool> ShouldSkipMethod(SessionId sessionId, ExecutionContext context, EventKind event_kind, int j, MethodInfoWithDebugInformation method, CancellationToken token)
-        {
-            var shouldReturn = await SkipMethod(
-                    isSkippable: context.IsSkippingHiddenMethod,
-                    shouldBeSkipped: event_kind != EventKind.UserBreak,
-                    StepKind.Over);
-            context.IsSkippingHiddenMethod = false;
-            if (shouldReturn)
-                return true;
-            shouldReturn = await SkipMethod(
-                isSkippable: context.IsSteppingThroughMethod,
-                shouldBeSkipped: event_kind != EventKind.UserBreak && event_kind != EventKind.Breakpoint,
-                StepKind.Over);
-            context.IsSteppingThroughMethod = false;
-            if (shouldReturn)
-                return true;
-            if (j == 0 && method?.Info.DebuggerAttrInfo.DoAttributesAffectCallStack(JustMyCode) == true)
-            {
-                if (method.Info.DebuggerAttrInfo.ShouldStepOut(event_kind))
-                {
-                    if (event_kind == EventKind.Step)
-                        context.IsSkippingHiddenMethod = true;
-                    if (await SkipMethod(isSkippable: true, shouldBeSkipped: true, StepKind.Out))
-                        return true;
-                }
-                if (!method.Info.DebuggerAttrInfo.HasStepperBoundary)
-                {
-                    if (event_kind == EventKind.Step ||
-                    (JustMyCode && (event_kind == EventKind.Breakpoint || event_kind == EventKind.UserBreak)))
-                    {
-                        if (context.IsResumedAfterBp)
-                            context.IsResumedAfterBp = false;
-                        else if (event_kind != EventKind.UserBreak)
-                            context.IsSteppingThroughMethod = true;
-                        if (await SkipMethod(isSkippable: true, shouldBeSkipped: true, StepKind.Out))
-                            return true;
-                    }
-                    if (event_kind == EventKind.Breakpoint)
-                        context.IsResumedAfterBp = true;
-                }
-            }
-            return false;
-            async Task<bool> SkipMethod(bool isSkippable, bool shouldBeSkipped, StepKind stepKind)
-            {
-                if (isSkippable && shouldBeSkipped)
-                {
-                    await context.SdbAgent.Step(context.ThreadId, stepKind, token);
-                    await SendResume(sessionId, token);
-                    return true;
-                }
-                return false;
-            }
-        }
-        protected virtual async Task<bool> SendCallStack(SessionId sessionId, ExecutionContext context, string reason, int thread_id, Breakpoint bp, JObject data, JObject args, EventKind event_kind, CancellationToken token)
-        {
-            var orig_callframes = args?["callFrames"]?.Values<JObject>();
-            var callFrames = new List<object>();
-            var frames = new List<Frame>();
-            using var commandParamsWriter = new MonoBinaryWriter();
-            commandParamsWriter.Write(thread_id);
-            commandParamsWriter.Write(0);
-            commandParamsWriter.Write(-1);
-            using var retDebuggerCmdReader = await context.SdbAgent.SendDebuggerAgentCommand(CmdThread.GetFrameInfo, commandParamsWriter, token);
-            var frame_count = retDebuggerCmdReader.ReadInt32();
-            for (int j = 0; j < frame_count; j++) {
-                var frame_id = retDebuggerCmdReader.ReadInt32();
-                var methodId = retDebuggerCmdReader.ReadInt32();
-                var il_pos = retDebuggerCmdReader.ReadInt32();
-                var flags = retDebuggerCmdReader.ReadByte();
-                DebugStore store = await LoadStore(sessionId, true, token);
-                var method = await context.SdbAgent.GetMethodInfo(methodId, token);
-                if (await ShouldSkipMethod(sessionId, context, event_kind, j, method, token))
-                    return true;
-                SourceLocation location = method?.Info.GetLocationByIl(il_pos);
-                if (location == null)
-                {
-                    continue;
-                }
-                frames.Add(new Frame(method, location, frame_id));
-                callFrames.Add(new
-                {
-                    functionName = method.Name,
-                    callFrameId = $"dotnet:scope:{frame_id}",
-                    functionLocation = method.Info.StartLocation.AsLocation(),
-                    location = location.AsLocation(),
-                    url = store.ToUrl(location),
-                    scopeChain = new[]
-                        {
-                            new
-                            {
-                                type = "local",
-                                    @object = new
-                                    {
-                                        @type = "object",
-                                            className = "Object",
-                                            description = "Object",
-                                            objectId = $"dotnet:scope:{frame_id}",
-                                    },
-                                    name = method.Name,
-                                    startLocation = method.Info.StartLocation.AsLocation(),
-                                    endLocation = method.Info.EndLocation.AsLocation(),
-                            }
-                        }
-                });
-                context.CallStack = frames;
-            }
-            string[] bp_list = new string[bp == null ? 0 : 1];
-            if (bp != null)
-                bp_list[0] = bp.StackId;
-            foreach (JObject frame in orig_callframes)
-            {
-                string function_name = frame["functionName"]?.Value<string>();
-                string url = frame["url"]?.Value<string>();
-                if (!(function_name.StartsWith("wasm-function", StringComparison.Ordinal) ||
-                        url.StartsWith("wasm://", StringComparison.Ordinal) ||
-                        url.EndsWith(".wasm", StringComparison.Ordinal) ||
-                        function_name == "_mono_wasm_fire_debugger_agent_message"))
-                {
-                    callFrames.Add(frame);
-                }
-            }
-            var o = JObject.FromObject(new
-            {
-                callFrames,
-                reason,
-                data,
-                hitBreakpoints = bp_list,
-            });
-            if (!await EvaluateCondition(sessionId, context, context.CallStack.First(), bp, token))
-            {
-                context.ClearState();
-                await SendResume(sessionId, token);
-                return true;
-            }
-            await SendEvent(sessionId, "Debugger.paused", o, token);
-            return true;
-        }
-        internal virtual void SaveLastDebuggerAgentBufferReceivedToContext(SessionId sessionId, Result res)
-        {
-        }
-        internal async Task<bool> OnReceiveDebuggerAgentEvent(SessionId sessionId, JObject args, CancellationToken token)
-        {
-            Result res = await SendMonoCommand(sessionId, MonoCommands.GetDebuggerAgentBufferReceived(RuntimeId), token);
-            SaveLastDebuggerAgentBufferReceivedToContext(sessionId, res);
-            if (!res.IsOk)
-                return false;
-            ExecutionContext context = GetContext(sessionId);
-            byte[] newBytes = Convert.FromBase64String(res.Value?["result"]?["value"]?["value"]?.Value<string>());
-            using var retDebuggerCmdReader = new MonoBinaryReader(newBytes);
-            retDebuggerCmdReader.ReadBytes(11); //skip HEADER_LEN
-            retDebuggerCmdReader.ReadByte(); //suspend_policy
-            var number_of_events = retDebuggerCmdReader.ReadInt32(); //number of events -> should be always one
-            for (int i = 0 ; i < number_of_events; i++) {
-                var event_kind = (EventKind)retDebuggerCmdReader.ReadByte(); //event kind
-                var request_id = retDebuggerCmdReader.ReadInt32(); //request id
-                if (event_kind == EventKind.Step)
-                    await context.SdbAgent.ClearSingleStep(request_id, token);
-                int thread_id = retDebuggerCmdReader.ReadInt32();
-                context.ThreadId = thread_id;
-                switch (event_kind)
-                {
-                    case EventKind.MethodUpdate:
-                    {
-                        var ret = await SendBreakpointsOfMethodUpdated(sessionId, context, retDebuggerCmdReader, token);
-                        await SendResume(sessionId, token);
-                        return ret;
-                    }
-                    case EventKind.EnC:
-                    {
-                        var ret = await ProcessEnC(sessionId, context, retDebuggerCmdReader, token);
-                        await SendResume(sessionId, token);
-                        return ret;
-                    }
-                    case EventKind.Exception:
-                    {
-                        string reason = "exception";
-                        int object_id = retDebuggerCmdReader.ReadInt32();
-                        var caught = retDebuggerCmdReader.ReadByte();
-                        var exceptionObject = await MemberObjectsExplorer.GetObjectMemberValues(
-                            context.SdbAgent, object_id, GetObjectCommandOptions.WithProperties | GetObjectCommandOptions.OwnProperties, token);
-                        var exceptionObjectMessage = exceptionObject.FirstOrDefault(attr => attr["name"].Value<string>().Equals("_message"));
-                        var data = JObject.FromObject(new
-                        {
-                            type = "object",
-                            subtype = "error",
-                            className = await context.SdbAgent.GetClassNameFromObject(object_id, token),
-                            uncaught = caught == 0,
-                            description = exceptionObjectMessage["value"]["value"].Value<string>(),
-                            objectId = $"dotnet:object:{object_id}"
-                        });
-                        var ret = await SendCallStack(sessionId, context, reason, thread_id, null, data, args, event_kind, token);
-                        return ret;
-                    }
-                    case EventKind.UserBreak:
-                    case EventKind.Step:
-                    case EventKind.Breakpoint:
-                    {
-                        if (event_kind == EventKind.Step)
-                            context.PauseKind = "resumeLimit";
-                        else if (event_kind == EventKind.Breakpoint)
-                            context.PauseKind = "breakpoint";
-                        Breakpoint bp = context.BreakpointRequests.Values.SelectMany(v => v.Locations).FirstOrDefault(b => b.RemoteId == request_id);
-                        if (request_id == context.TempBreakpointForSetNextIP)
-                        {
-                            context.TempBreakpointForSetNextIP = -1;
-                            await context.SdbAgent.RemoveBreakpoint(request_id, token);
-                        }
-                        string reason = "other";//other means breakpoint
-                        int methodId = 0;
-                        if (event_kind != EventKind.UserBreak)
-                            methodId = retDebuggerCmdReader.ReadInt32();
-                        var ret = await SendCallStack(sessionId, context, reason, thread_id, bp, null, args, event_kind, token);
-                        return ret;
-                    }
-                }
-            }
-            return false;
-        }
-        internal async Task<MethodInfo> LoadSymbolsOnDemand(AssemblyInfo asm, int method_token, SessionId sessionId, CancellationToken token)
-        {
-            ExecutionContext context = GetContext(sessionId);
-            if (urlSymbolServerList.Count == 0)
-                return null;
-            if (asm.TriedToLoadSymbolsOnDemand || !asm.CodeViewInformationAvailable)
-                return null;
-            asm.TriedToLoadSymbolsOnDemand = true;
-            var pdbName = Path.GetFileName(asm.PdbName);
-            foreach (string urlSymbolServer in urlSymbolServerList)
-            {
-                string downloadURL = $"{urlSymbolServer}/{pdbName}/{asm.PdbGuid.ToString("N").ToUpperInvariant() + asm.PdbAge}/{pdbName}";
-                try
-                {
-                    using HttpResponseMessage response = await HttpClient.GetAsync(downloadURL, token);
-                    if (!response.IsSuccessStatusCode)
-                    {
-                        Log("info", $"Unable to download symbols on demand url:{downloadURL} assembly: {asm.Name}");
-                        continue;
-                    }
-                    using Stream streamToReadFrom = await response.Content.ReadAsStreamAsync(token);
-                    asm.UpdatePdbInformation(streamToReadFrom);
-                    foreach (SourceFile source in asm.Sources)
-                    {
-                        var scriptSource = JObject.FromObject(source.ToScriptSource(context.Id, context.AuxData));
-                        await SendEvent(sessionId, "Debugger.scriptParsed", scriptSource, token);
-                    }
-                    return asm.GetMethodByToken(method_token);
-                }
-                catch (Exception e)
-                {
-                    Log("info", $"Unable to load symbols on demand exception: {e} url:{downloadURL} assembly: {asm.Name}");
-                }
-                break;
-            }
-            Log("info", $"Unable to load symbols on demand assembly: {asm.Name}");
-            return null;
-        }
-        protected void OnDefaultContextUpdate(SessionId sessionId, ExecutionContext context)
-        {
-            if (UpdateContext(sessionId, context, out ExecutionContext previousContext))
-            {
-                foreach (KeyValuePair<string, BreakpointRequest> kvp in previousContext.BreakpointRequests)
-                {
-                    context.BreakpointRequests[kvp.Key] = kvp.Value.Clone();
-                }
-                context.PauseOnExceptions = previousContext.PauseOnExceptions;
-            }
-        }
-        protected async Task OnDefaultContext(SessionId sessionId, ExecutionContext context, CancellationToken token)
-        {
-            Log("verbose", "Default context created, clearing state and sending events");
-            OnDefaultContextUpdate(sessionId, context);
-            if (await IsRuntimeAlreadyReadyAlready(sessionId, token))
-                await RuntimeReady(sessionId, token);
-        }
-        protected async Task OnResume(MessageId msg_id, CancellationToken token)
-        {
-            ExecutionContext context = GetContext(msg_id);
-            if (context.CallStack != null)
-            {
-                await SendMonoCommand(msg_id, MonoCommands.Resume(RuntimeId), token);
-            }
-            GetContext(msg_id).ClearState();
-        }
-        protected async Task<bool> Step(MessageId msgId, StepKind kind, CancellationToken token)
-        {
-            ExecutionContext context = GetContext(msgId);
-            if (context.CallStack == null)
-                return false;
-            if (context.CallStack.Count <= 1 && kind == StepKind.Out)
-                return false;
-            var step = await context.SdbAgent.Step(context.ThreadId, kind, token);
-            if (step == false) {
-                context.ClearState();
-                await SendCommand(msgId, "Debugger.stepOut", new JObject(), token);
-                return false;
-            }
-            SendResponse(msgId, Result.Ok(new JObject()), token);
-            context.ClearState();
-            await SendResume(msgId, token);
-            return true;
-        }
-        private async Task<bool> OnJSEventRaised(SessionId sessionId, JObject eventArgs, CancellationToken token)
-        {
-            string eventName = eventArgs?["eventName"]?.Value<string>();
-            if (string.IsNullOrEmpty(eventName))
-            {
-                logger.LogDebug($"Missing name for raised js event: {eventArgs}");
-                return false;
-            }
-            logger.LogDebug($"OnJsEventRaised: args: {eventArgs.ToString().TruncateLogMessage()}");
-            switch (eventName)
-            {
-                case "AssemblyLoaded":
-                    return await OnAssemblyLoadedJSEvent(sessionId, eventArgs, token);
-                default:
-                {
-                    logger.LogDebug($"Unknown js event name: {eventName} with args {eventArgs}");
-                    return await Task.FromResult(false);
-                }
-            }
-        }
-        private async Task<bool> OnAssemblyLoadedJSEvent(SessionId sessionId, JObject eventArgs, CancellationToken token)
-        {
-            try
-            {
-                var store = await LoadStore(sessionId, true, token);
-                var assembly_name = eventArgs?["assembly_name"]?.Value<string>();
-                if (store.GetAssemblyByName(assembly_name) != null)
-                {
-                    Log("debug", $"Got AssemblyLoaded event for {assembly_name}, but skipping it as it has already been loaded.");
-                    return true;
-                }
-                var assembly_b64 = eventArgs?["assembly_b64"]?.ToObject<string>();
-                var pdb_b64 = eventArgs?["pdb_b64"]?.ToObject<string>();
-                if (string.IsNullOrEmpty(assembly_b64))
-                {
-                    logger.LogDebug("No assembly data provided to load.");
-                    return false;
-                }
-                var assembly_data = Convert.FromBase64String(assembly_b64);
-                var pdb_data = string.IsNullOrEmpty(pdb_b64) ? null : Convert.FromBase64String(pdb_b64);
-                var context = GetContext(sessionId);
-                foreach (var source in store.Add(sessionId, assembly_name, assembly_data, pdb_data, token))
-                {
-                    await OnSourceFileAdded(sessionId, source, context, token);
-                }
-                return true;
-            }
-            catch (Exception e)
-            {
-                logger.LogDebug($"Failed to load assemblies and PDBs: {e}");
-                return false;
-            }
-        }
-        private async Task OnSetEntrypointBreakpoint(SessionId sessionId, JObject args, CancellationToken token)
-        {
-            try
-            {
-                ExecutionContext context = GetContext(sessionId);
-                var argsNew = JObject.FromObject(new
-                {
-                    callFrameId = args?["callFrames"]?[0]?["callFrameId"]?.Value<string>(),
-                    expression = "_assembly_name_str + '|' + _entrypoint_method_token",
-                });
-                Result assemblyAndMethodToken = await SendCommand(sessionId, "Debugger.evaluateOnCallFrame", argsNew, token);
-                if (!assemblyAndMethodToken.IsOk)
-                {
-                    logger.LogDebug("Failure evaluating _assembly_name_str + '|' + _entrypoint_method_token");
-                    return;
-                }
-                logger.LogDebug($"Entrypoint assembly and method token {assemblyAndMethodToken.Value["result"]["value"].Value<string>()}");
-                var assemblyAndMethodTokenArr = assemblyAndMethodToken.Value["result"]["value"].Value<string>().Split('|', StringSplitOptions.TrimEntries);
-                var assemblyName = assemblyAndMethodTokenArr[0];
-                var methodToken = Convert.ToInt32(assemblyAndMethodTokenArr[1]) & 0xffffff; //token
-                var store = await LoadStore(sessionId, true, token);
-                AssemblyInfo assembly = store.GetAssemblyByName(assemblyName);
-                if (assembly == null)
-                {
-                    logger.LogDebug($"Could not find entrypoint assembly {assemblyName} in the store");
-                    return;
-                }
-                var method = assembly.GetMethodByToken(methodToken);
-                if (method.StartLocation == null) //It's an async method and we need to get the MoveNext method to add the breakpoint
-                    method = assembly.Methods.FirstOrDefault(m => m.Value.KickOffMethod == methodToken).Value;
-                if (method == null)
-                {
-                    logger.LogDebug($"Could not find entrypoint method {methodToken} in assembly {assemblyName}");
-                    return;
-                }
-                var sourceFile = assembly.Sources.FirstOrDefault(sf => sf.SourceId == method.SourceId);
-                if (sourceFile == null)
-                {
-                    logger.LogDebug($"Could not source file {method.SourceName} for method {method.Name} in assembly {assemblyName}");
-                    return;
-                }
-                string bpId = $"auto:{method.StartLocation.Line}:{method.StartLocation.Column}:{sourceFile.DotNetUrl}";
-                BreakpointRequest request = new(bpId, JObject.FromObject(new
-                {
-                    lineNumber = method.StartLocation.Line,
-                    columnNumber = method.StartLocation.Column,
-                    url = sourceFile.Url
-                }));
-                context.BreakpointRequests[bpId] = request;
-                if (request.TryResolve(sourceFile))
-                    await SetBreakpoint(sessionId, context.store, request, sendResolvedEvent: false, fromEnC: false, token);
-                logger.LogInformation($"Adding bp req {request}");
-            }
-            catch (Exception e)
-            {
-                logger.LogDebug($"Unable to set entrypoint breakpoint. {e}");
-            }
-            finally
-            {
-                await SendResume(sessionId, token);
-            }
-        }
-        private async Task<bool> OnEvaluateOnCallFrame(MessageId msg_id, int scopeId, string expression, CancellationToken token)
-        {
-            try
-            {
-                ExecutionContext context = GetContext(msg_id);
-                if (context.CallStack == null)
-                    return false;
-                var resolver = new MemberReferenceResolver(this, context, msg_id, scopeId, logger);
-                JObject retValue = await resolver.Resolve(expression, token);
-                if (retValue == null)
-                {
-                    retValue = await ExpressionEvaluator.CompileAndRunTheExpression(expression, resolver, logger, token);
-                }
-                if (retValue != null)
-                {
-                    SendResponse(msg_id, Result.OkFromObject(new
-                    {
-                        result = retValue
-                    }), token);
-                }
-                else
-                {
-                    SendResponse(msg_id, Result.Err($"Unable to evaluate '{expression}'"), token);
-                }
-            }
-            catch (ReturnAsErrorException ree)
-            {
-                SendResponse(msg_id, ree.Error, token);
-            }
-            catch (ExpressionEvaluationFailedException eefe)
-            {
-                logger.LogDebug($"Error in EvaluateOnCallFrame for expression '{expression}' with '{eefe}.");
-                SendResponse(msg_id, Result.Exception(eefe), token);
-            }
-            catch (Exception e)
-            {
-                logger.LogDebug($"Error in EvaluateOnCallFrame for expression '{expression}' with '{e}.");
-                SendResponse(msg_id, Result.Exception(e), token);
-            }
-            return true;
-        }
-        internal async Task<Result> GetScopeProperties(SessionId msg_id, int scopeId, CancellationToken token)
-        {
-            try
-            {
-                ExecutionContext context = GetContext(msg_id);
-                Frame scope = context.CallStack.FirstOrDefault(s => s.Id == scopeId);
-                if (scope == null)
-                    return Result.Err(JObject.FromObject(new { message = $"Could not find scope with id #{scopeId}" }));
-                VarInfo[] varIds = scope.Method.Info.GetLiveVarsAt(scope.Location.IlLocation.Offset);
-                var values = await context.SdbAgent.StackFrameGetValues(scope.Method, context.ThreadId, scopeId, varIds, scope.Location.IlLocation.Offset, token);
-                if (values != null)
-                {
-                    if (values == null || values.Count == 0)
-                        return Result.OkFromObject(new { result = Array.Empty<object>() });
-                    PerScopeCache frameCache = context.GetCacheForScope(scopeId);
-                    foreach (JObject value in values)
-                    {
-                        frameCache.Locals[value["name"]?.Value<string>()] = value;
-                    }
-                    return Result.OkFromObject(new { result = values });
-                }
-                return Result.OkFromObject(new { result = Array.Empty<object>() });
-            }
-            catch (Exception exception)
-            {
-                Log("verbose", $"Error resolving scope properties {exception.Message}");
-                return Result.Exception(exception);
-            }
-        }
-        private async Task<Breakpoint> SetMonoBreakpoint(SessionId sessionId, string reqId, SourceLocation location, string condition, CancellationToken token)
-        {
-            var context = GetContext(sessionId);
-            var bp = new Breakpoint(reqId, location, condition, BreakpointState.Pending);
-            string asm_name = bp.Location.IlLocation.Method.Assembly.Name;
-            int method_token = bp.Location.IlLocation.Method.Token;
-            int il_offset = bp.Location.IlLocation.Offset;
-            var assembly_id = await context.SdbAgent.GetAssemblyId(asm_name, token);
-            var methodId = await context.SdbAgent.GetMethodIdByToken(assembly_id, method_token, token);
-            var breakpoint_id = await context.SdbAgent.SetBreakpointNoThrow(methodId, il_offset, token);
-            if (breakpoint_id > 0)
-            {
-                bp.RemoteId = breakpoint_id;
-                bp.State = BreakpointState.Active;
-            }
-            return bp;
-        }
-        internal virtual async Task OnSourceFileAdded(SessionId sessionId, SourceFile source, ExecutionContext context, CancellationToken token)
-        {
-            JObject scriptSource = JObject.FromObject(source.ToScriptSource(context.Id, context.AuxData));
-            await SendEvent(sessionId, "Debugger.scriptParsed", scriptSource, token);
-            foreach (var req in context.BreakpointRequests.Values)
-            {
-                if (req.TryResolve(source))
-                {
-                    await SetBreakpoint(sessionId, context.store, req, true, false, token);
-                }
-            }
-        }
-        internal virtual async Task<DebugStore> LoadStore(SessionId sessionId, bool tryUseDebuggerProtocol, CancellationToken token)
-        {
-            ExecutionContext context = GetContext(sessionId);
-            if (Interlocked.CompareExchange(ref context.store, new DebugStore(this, logger), null) != null)
-                return await context.Source.Task;
-            try
-            {
-                string[] loaded_files = await GetLoadedFiles(sessionId, context, token);
-                if (loaded_files == null)
-                {
-                    SendLog(sessionId, $"Failed to get the list of loaded files. Managed code debugging won't work due to this.", token);
-                }
-                else
-                {
-                    var useDebuggerProtocol = false;
-                    if (tryUseDebuggerProtocol)
-                    {
-                        (int MajorVersion, int MinorVersion) = await context.SdbAgent.GetVMVersion(token);
-                        if (MajorVersion == 2 && MinorVersion >= 61)
-                            useDebuggerProtocol = true;
-                    }
-                    await foreach (SourceFile source in context.store.Load(sessionId, loaded_files, context, useDebuggerProtocol, token))
-                    {
-                        await OnSourceFileAdded(sessionId, source, context, token);
-                    }
-                }
-            }
-            catch (Exception e)
-            {
-                logger.LogError($"failed: {e}");
-                context.Source.SetException(e);
-            }
-            if (!context.Source.Task.IsCompleted)
-                context.Source.SetResult(context.store);
-            return context.store;
-            async Task<string[]> GetLoadedFiles(SessionId sessionId, ExecutionContext context, CancellationToken token)
-            {
-                if (context.LoadedFiles != null)
-                    return context.LoadedFiles;
-                Result loaded = await SendMonoCommand(sessionId, MonoCommands.GetLoadedFiles(RuntimeId), token);
-                if (!loaded.IsOk)
-                {
-                    SendLog(sessionId, $"Error on mono_wasm_get_loaded_files {loaded}", token);
-                    return null;
-                }
-                string[] files = loaded.Value?["result"]?["value"]?.ToObject<string[]>();
-                if (files == null)
-                    SendLog(sessionId, $"Error extracting the list of loaded_files from the result of mono_wasm_get_loaded_files: {loaded}", token);
-                return files;
-            }
-        }
-        protected async Task<DebugStore> RuntimeReady(SessionId sessionId, CancellationToken token)
-        {
-            try
-            {
-                ExecutionContext context = GetContext(sessionId);
-                if (Interlocked.CompareExchange(ref context.ready, new TaskCompletionSource<DebugStore>(), null) != null)
-                    return await context.ready.Task;
-                await context.SdbAgent.SendDebuggerAgentCommand(CmdEventRequest.ClearAllBreakpoints, null, token);
-                if (context.PauseOnExceptions != PauseOnExceptionsKind.None && context.PauseOnExceptions != PauseOnExceptionsKind.Unset)
-                    await context.SdbAgent.EnableExceptions(context.PauseOnExceptions, token);
-                await context.SdbAgent.SetProtocolVersion(token);
-                await context.SdbAgent.EnableReceiveRequests(EventKind.UserBreak, token);
-                await context.SdbAgent.EnableReceiveRequests(EventKind.EnC, token);
-                await context.SdbAgent.EnableReceiveRequests(EventKind.MethodUpdate, token);
-                DebugStore store = await LoadStore(sessionId, true, token);
-                context.ready.SetResult(store);
-                await SendEvent(sessionId, "Mono.runtimeReady", new JObject(), token);
-                await SendMonoCommand(sessionId, MonoCommands.SetDebuggerAttached(RuntimeId), token);
-                context.SdbAgent.ResetStore(store);
-                return store;
-            }
-            catch (DebuggerAgentException e)
-            {
-                if (!e.Message.Contains("getDotnetRuntime is not defined"))
-                    logger.LogDebug($"Unexpected error on RuntimeReady {e}");
-                return null;
-            }
-            catch (Exception e)
-            {
-                logger.LogDebug($"Unexpected error on RuntimeReady {e}");
-                return null;
-            }
-        }
-        private static IEnumerable<IGrouping<SourceId, SourceLocation>> GetBPReqLocations(DebugStore store, BreakpointRequest req, bool ifNoneFoundThenFindNext = false)
-        {
-            var comparer = new SourceLocation.LocationComparer();
-            var bpLocations = store.FindBreakpointLocations(req, ifNoneFoundThenFindNext);
-            IEnumerable<IGrouping<SourceId, SourceLocation>> locations = bpLocations.Distinct(comparer)
-                .OrderBy(l => l.Column)
-                .GroupBy(l => l.Id);
-            if (ifNoneFoundThenFindNext && !locations.Any())
-            {
-                locations = bpLocations.GroupBy(l => l.Id);
-            }
-            return locations;
-        }
-        private async Task ResetBreakpoint(SessionId msg_id, DebugStore store, MethodInfo method, CancellationToken token)
-        {
-            ExecutionContext context = GetContext(msg_id);
-            foreach (var req in context.BreakpointRequests.Values)
-            {
-                if (req.Method != null)
-                {
-                    if (req.Method.Assembly.Id == method.Assembly.Id && req.Method.Token == method.Token) {
-                        var locations = GetBPReqLocations(store, req);
-                        foreach (IGrouping<SourceId, SourceLocation> sourceId in locations)
-                        {
-                            SourceLocation loc = sourceId.First();
-                            if (req.Locations.Any(b => b.Location.IlLocation.Offset != loc.IlLocation.Offset))
-                            {
-                                await RemoveBreakpoint(msg_id, JObject.FromObject(new {breakpointId = req.Id}), true, token);
-                                break;
-                            }
-                        }
-                    }
-                }
-            }
-        }
-        protected async Task RemoveBreakpoint(SessionId msg_id, JObject args, bool isEnCReset, CancellationToken token)
-        {
-            string bpid = args?["breakpointId"]?.Value<string>();
-            ExecutionContext context = GetContext(msg_id);
-            if (!context.BreakpointRequests.TryGetValue(bpid, out BreakpointRequest breakpointRequest))
-                return;
-            foreach (Breakpoint bp in breakpointRequest.Locations)
-            {
-                var breakpoint_removed = await context.SdbAgent.RemoveBreakpoint(bp.RemoteId, token);
-                if (breakpoint_removed)
-                {
-                    bp.RemoteId = -1;
-                    if (isEnCReset)
-                        bp.State = BreakpointState.Pending;
-                    else
-                        bp.State = BreakpointState.Disabled;
-                }
-            }
-            if (!isEnCReset)
-                context.BreakpointRequests.Remove(bpid);
-        }
-        protected async Task SetBreakpoint(SessionId sessionId, DebugStore store, BreakpointRequest req, bool sendResolvedEvent, bool fromEnC, CancellationToken token)
-        {
-            ExecutionContext context = GetContext(sessionId);
-            if ((!fromEnC && req.Locations.Any()) || (fromEnC && req.Locations.Any(bp => bp.State == BreakpointState.Active)))
-            {
-                if (!fromEnC)
-                    Log("debug", $"locations already loaded for {req.Id}");
-                return;
-            }
-            var locations = GetBPReqLocations(store, req, true);
-            logger.LogDebug("BP request for '{Req}' runtime ready {Context.RuntimeReady}", req, context.IsRuntimeReady);
-            var breakpoints = new List<Breakpoint>();
-            foreach (IGrouping<SourceId, SourceLocation> sourceId in locations)
-            {
-                SourceLocation loc = sourceId.First();
-                req.Method = loc.IlLocation.Method;
-                if (req.Method.DebuggerAttrInfo.HasDebuggerHidden)
-                    continue;
-                Breakpoint bp = await SetMonoBreakpoint(sessionId, req.Id, loc, req.Condition, token);
-                if (bp.State != BreakpointState.Active)
-                    continue;
-                breakpoints.Add(bp);
-                var resolvedLocation = new
-                {
-                    breakpointId = req.Id,
-                    location = loc.AsLocation()
-                };
-                if (sendResolvedEvent)
-                    await SendEvent(sessionId, "Debugger.breakpointResolved", JObject.FromObject(resolvedLocation), token);
-            }
-            req.Locations.AddRange(breakpoints);
-            return;
-        }
-        private async Task<bool> GetPossibleBreakpoints(MessageId msg, SourceLocation start, SourceLocation end, CancellationToken token)
-        {
-            List<SourceLocation> bps = (await RuntimeReady(msg, token)).FindPossibleBreakpoints(start, end);
-            if (bps == null)
-                return false;
-            var response = new { locations = bps.Select(b => b.AsLocation()) };
-            SendResponse(msg, Result.OkFromObject(response), token);
-            return true;
-        }
-        private void OnCompileDotnetScript(MessageId msg_id, CancellationToken token)
-        {
-            SendResponse(msg_id, Result.OkFromObject(new { }), token);
-        }
-        private static bool IsNestedMethod(DebugStore store, Frame scope, SourceLocation foundLocation, SourceLocation targetLocation)
-        {
-            if (foundLocation.Line != targetLocation.Line || foundLocation.Column != targetLocation.Column)
-            {
-                SourceFile doc = store.GetFileById(scope.Method.Info.SourceId);
-                foreach (var method in doc.Methods)
-                {
-                    if (method.Token == scope.Method.Info.Token)
-                        continue;
-                    if (method.IsLexicallyContainedInMethod(scope.Method.Info))
-                        continue;
-                    SourceLocation newFoundLocation = DebugStore.FindBreakpointLocations(targetLocation, targetLocation, scope.Method.Info)
-                                                .FirstOrDefault();
-                    if (!(newFoundLocation is null))
-                        return true;
-                }
-            }
-            return false;
-        }
-        private async Task<bool> OnSetNextIP(MessageId sessionId, SourceLocation targetLocation, CancellationToken token)
-        {
-            DebugStore store = await RuntimeReady(sessionId, token);
-            ExecutionContext context = GetContext(sessionId);
-            Frame scope = context.CallStack.First<Frame>();
-            SourceLocation foundLocation = DebugStore.FindBreakpointLocations(targetLocation, targetLocation, scope.Method.Info)
-                                                    .FirstOrDefault();
-            if (foundLocation is null)
-                 return false;
-            if (IsNestedMethod(store, scope, foundLocation, targetLocation))
-                return false;
-            var ilOffset = foundLocation.IlLocation;
-            var ret = await context.SdbAgent.SetNextIP(scope.Method, context.ThreadId, ilOffset, token);
-            if (!ret)
-                return false;
-            var breakpointId = await context.SdbAgent.SetBreakpointNoThrow(scope.Method.DebugId, ilOffset.Offset, token);
-            if (breakpointId == -1)
-                return false;
-            context.TempBreakpointForSetNextIP = breakpointId;
-            await SendResume(sessionId, token);
-            return true;
-        }
-        internal virtual async Task<bool> OnGetScriptSource(MessageId msg_id, string script_id, CancellationToken token)
-        {
-            if (!SourceId.TryParse(script_id, out SourceId id))
-                return false;
-            SourceFile src_file = (await LoadStore(msg_id, true, token)).GetFileById(id);
-            try
-            {
-                var uri = new Uri(src_file.Url);
-                string source = $"// Unable to find document {src_file.SourceUri}";
-                using (Stream data = await src_file.GetSourceAsync(checkHash: false, token: token))
-                {
-                    if (data is MemoryStream && data.Length == 0)
-                        return false;
-                    using (var reader = new StreamReader(data))
-                        source = await reader.ReadToEndAsync(token);
-                }
-                SendResponse(msg_id, Result.OkFromObject(new { scriptSource = source }), token);
-            }
-            catch (Exception e)
-            {
-                var o = new
-                {
-                    scriptSource = $"// Unable to read document ({e.Message})\n" +
-                    $"Local path: {src_file?.SourceUri}\n" +
-                    $"SourceLink path: {src_file?.SourceLinkUri}\n"
-                };
-                SendResponse(msg_id, Result.OkFromObject(o), token);
-            }
-            return true;
-        }
-        private async Task AttachToTarget(SessionId sessionId, CancellationToken token)
-        {
-            if (sessions.Add(sessionId))
-            {
-                await SendMonoCommand(sessionId, new MonoCommands("globalThis.dotnetDebugger = true"), token);
-                Result res = await SendCommand(sessionId,
-                    "Page.addScriptToEvaluateOnNewDocument",
-                    JObject.FromObject(new { source = $"globalThis.dotnetDebugger = true; delete navigator.constructor.prototype.webdriver;" }),
-                    token);
-                if (sessionId != SessionId.Null && !res.IsOk)
-                    sessions.Remove(sessionId);
-            }
-        }
-        private bool JObjectTryParse(string str, out JObject obj, bool log_exception = true)
-        {
-            obj = null;
-            if (string.IsNullOrEmpty(str))
-                return false;
-            try
-            {
-                obj = JObject.Parse(str);
-                return true;
-            }
-            catch (JsonReaderException jre)
-            {
-                if (log_exception)
-                    logger.LogDebug($"Could not parse {str}. Failed with {jre}");
-                return false;
-            }
-        }
-    }
-}

--- a/src/mono/wasm/runtime/assets.ts
+++ b//dev/null
@@ -1,453 +0,0 @@
-import cwraps from "./cwraps";
-import { mono_wasm_load_icu_data } from "./icu";
-import { ENVIRONMENT_IS_NODE, ENVIRONMENT_IS_SHELL, ENVIRONMENT_IS_WEB, Module, runtimeHelpers } from "./imports";
-import { mono_wasm_load_bytes_into_heap } from "./memory";
-import { MONO } from "./net6-legacy/imports";
-import { createPromiseController, PromiseAndController } from "./promise-controller";
-import { delay } from "./promise-utils";
-import { abort_startup, beforeOnRuntimeInitialized } from "./startup";
-import { AssetBehaviours, AssetEntry, AssetEntryInternal, LoadingResource, mono_assert, ResourceRequest } from "./types";
-import { InstantiateWasmSuccessCallback, VoidPtr } from "./types/emscripten";
-const allAssetsInMemory = createPromiseController<void>();
-const allDownloadsQueued = createPromiseController<void>();
-let actual_downloaded_assets_count = 0;
-let actual_instantiated_assets_count = 0;
-let expected_downloaded_assets_count = 0;
-let expected_instantiated_assets_count = 0;
-const loaded_files: { url: string, file: string }[] = [];
-const loaded_assets: { [id: string]: [VoidPtr, number] } = Object.create(null);
-let parallel_count = 0;
-let throttlingPromise: PromiseAndController<void> | undefined;
-const skipDownloadsByAssetTypes: {
-    [k: string]: boolean
-} = {
-    "js-module-threads": true,
-};
-const skipBufferByAssetTypes: {
-    [k: string]: boolean
-} = {
-    "dotnetwasm": true,
-};
-const skipInstantiateByAssetTypes: {
-    [k: string]: boolean
-} = {
-    "js-module-threads": true,
-    "dotnetwasm": true,
-};
-export function resolve_asset_path(behavior: AssetBehaviours) {
-    const asset: AssetEntry | undefined = runtimeHelpers.config.assets?.find(a => a.behavior == behavior);
-    mono_assert(asset, () => `Can't find asset for ${behavior}`);
-    if (!asset.resolvedUrl) {
-        asset.resolvedUrl = resolve_path(asset, "");
-    }
-    return asset;
-}
-type AssetWithBuffer = {
-    asset: AssetEntryInternal,
-    buffer?: ArrayBuffer
-}
-export async function mono_download_assets(): Promise<void> {
-    if (runtimeHelpers.diagnosticTracing) console.debug("MONO_WASM: mono_download_assets");
-    runtimeHelpers.maxParallelDownloads = runtimeHelpers.config.maxParallelDownloads || runtimeHelpers.maxParallelDownloads;
-    try {
-        const promises_of_assets_with_buffer: Promise<AssetWithBuffer>[] = [];
-        for (const a of runtimeHelpers.config.assets!) {
-            const asset: AssetEntryInternal = a;
-            if (!skipInstantiateByAssetTypes[asset.behavior]) {
-                expected_instantiated_assets_count++;
-            }
-            if (!skipDownloadsByAssetTypes[asset.behavior]) {
-                const headersOnly = skipBufferByAssetTypes[asset.behavior];// `response.arrayBuffer()` can't be called twice. Some usecases are calling it on response in the instantiation.
-                expected_downloaded_assets_count++;
-                if (asset.pendingDownload) {
-                    asset.pendingDownloadInternal = asset.pendingDownload;
-                    const waitForExternalData: () => Promise<AssetWithBuffer> = async () => {
-                        const response = await asset.pendingDownloadInternal!.response;
-                        if (!headersOnly) {
-                            asset.buffer = await response.arrayBuffer();
-                        }
-                        ++actual_downloaded_assets_count;
-                        return { asset, buffer: asset.buffer };
-                    };
-                    promises_of_assets_with_buffer.push(waitForExternalData());
-                } else {
-                    const waitForExternalData: () => Promise<AssetWithBuffer> = async () => {
-                        asset.buffer = await start_asset_download_with_retries(asset, !headersOnly);
-                        return { asset, buffer: asset.buffer };
-                    };
-                    promises_of_assets_with_buffer.push(waitForExternalData());
-                }
-            }
-        }
-        allDownloadsQueued.promise_control.resolve();
-        const promises_of_asset_instantiation: Promise<void>[] = [];
-        for (const downloadPromise of promises_of_assets_with_buffer) {
-            promises_of_asset_instantiation.push((async () => {
-                const assetWithBuffer = await downloadPromise;
-                const asset = assetWithBuffer.asset;
-                if (assetWithBuffer.buffer) {
-                    if (!skipInstantiateByAssetTypes[asset.behavior]) {
-                        const url = asset.pendingDownloadInternal!.url;
-                        const data = new Uint8Array(asset.buffer!);
-                        asset.pendingDownloadInternal = null as any; // GC
-                        asset.pendingDownload = null as any; // GC
-                        asset.buffer = null as any; // GC
-                        assetWithBuffer.buffer = null as any; // GC
-                        await beforeOnRuntimeInitialized.promise;
-                        _instantiate_asset(asset, url, data);
-                    }
-                } else {
-                    const headersOnly = skipBufferByAssetTypes[asset.behavior];
-                    if (!headersOnly) {
-                        mono_assert(asset.isOptional, "Expected asset to have the downloaded buffer");
-                        if (!skipDownloadsByAssetTypes[asset.behavior]) {
-                            expected_downloaded_assets_count--;
-                        }
-                        if (!skipInstantiateByAssetTypes[asset.behavior]) {
-                            expected_instantiated_assets_count--;
-                        }
-                    } else {
-                        if (skipBufferByAssetTypes[asset.behavior]) {
-                            ++actual_downloaded_assets_count;
-                        }
-                    }
-                }
-            })());
-        }
-        Promise.all(promises_of_asset_instantiation).then(() => {
-            allAssetsInMemory.promise_control.resolve();
-        }).catch(err => {
-            Module.printErr("MONO_WASM: Error in mono_download_assets: " + err);
-            abort_startup(err, true);
-        });
-    } catch (err: any) {
-        Module.printErr("MONO_WASM: Error in mono_download_assets: " + err);
-        throw err;
-    }
-}
-export async function start_asset_download_with_retries(asset: AssetEntryInternal, downloadData: boolean): Promise<ArrayBuffer | undefined> {
-    try {
-        return await start_asset_download_with_throttle(asset, downloadData);
-    } catch (err: any) {
-        if (ENVIRONMENT_IS_SHELL || ENVIRONMENT_IS_NODE) {
-            throw err;
-        }
-        if (asset.pendingDownload && asset.pendingDownloadInternal == asset.pendingDownload) {
-            throw err;
-        }
-        if (asset.resolvedUrl && asset.resolvedUrl.indexOf("file://") != -1) {
-            throw err;
-        }
-        if (err && err.status == 404) {
-            throw err;
-        }
-        asset.pendingDownloadInternal = undefined;
-        await allDownloadsQueued.promise;
-        try {
-            return await start_asset_download_with_throttle(asset, downloadData);
-        } catch (err) {
-            asset.pendingDownloadInternal = undefined;
-            await delay(100);
-            return await start_asset_download_with_throttle(asset, downloadData);
-        }
-    }
-}
-async function start_asset_download_with_throttle(asset: AssetEntry, downloadData: boolean): Promise<ArrayBuffer | undefined> {
-    while (throttlingPromise) {
-        await throttlingPromise.promise;
-    }
-    try {
-        ++parallel_count;
-        if (parallel_count == runtimeHelpers.maxParallelDownloads) {
-            if (runtimeHelpers.diagnosticTracing)
-                console.debug("MONO_WASM: Throttling further parallel downloads");
-            throttlingPromise = createPromiseController<void>();
-        }
-        const response = await start_asset_download_sources(asset);
-        if (!downloadData || !response) {
-            return undefined;
-        }
-        const buffer = await response.arrayBuffer();
-        ++actual_downloaded_assets_count;
-        return buffer;
-    }
-    finally {
-        --parallel_count;
-        if (throttlingPromise && parallel_count == runtimeHelpers.maxParallelDownloads - 1) {
-            if (runtimeHelpers.diagnosticTracing)
-                console.debug("MONO_WASM: Resuming more parallel downloads");
-            const old_throttling = throttlingPromise;
-            throttlingPromise = undefined;
-            old_throttling.promise_control.resolve();
-        }
-    }
-}
-async function start_asset_download_sources(asset: AssetEntryInternal): Promise<Response | undefined> {
-    if (asset.buffer) {
-        const buffer = asset.buffer;
-        asset.buffer = null as any; // GC
-        asset.pendingDownloadInternal = {
-            url: "undefined://" + asset.name,
-            name: asset.name,
-            response: Promise.resolve({
-                arrayBuffer: () => buffer,
-                headers: {
-                    get: () => undefined,
-                }
-            }) as any
-        };
-        return asset.pendingDownloadInternal.response;
-    }
-    if (asset.pendingDownloadInternal && asset.pendingDownloadInternal.response) {
-        const response = await asset.pendingDownloadInternal.response;
-        return response;
-    }
-    const sourcesList = asset.loadRemote && runtimeHelpers.config.remoteSources ? runtimeHelpers.config.remoteSources : [""];
-    let response: Response | undefined = undefined;
-    for (let sourcePrefix of sourcesList) {
-        sourcePrefix = sourcePrefix.trim();
-        if (sourcePrefix === "./")
-            sourcePrefix = "";
-        const attemptUrl = resolve_path(asset, sourcePrefix);
-        if (asset.name === attemptUrl) {
-            if (runtimeHelpers.diagnosticTracing)
-                console.debug(`MONO_WASM: Attempting to download '${attemptUrl}'`);
-        } else {
-            if (runtimeHelpers.diagnosticTracing)
-                console.debug(`MONO_WASM: Attempting to download '${attemptUrl}' for ${asset.name}`);
-        }
-        try {
-            const loadingResource = download_resource({
-                name: asset.name,
-                resolvedUrl: attemptUrl,
-                hash: asset.hash,
-                behavior: asset.behavior
-            });
-            asset.pendingDownloadInternal = loadingResource;
-            response = await loadingResource.response;
-            if (!response.ok) {
-                continue;// next source
-            }
-            return response;
-        }
-        catch (err) {
-            continue; //next source
-        }
-    }
-    const isOkToFail = asset.isOptional || (asset.name.match(/\.pdb$/) && runtimeHelpers.config.ignorePdbLoadErrors);
-    mono_assert(response, () => `Response undefined ${asset.name}`);
-    if (!isOkToFail) {
-        const err: any = new Error(`MONO_WASM: download '${response.url}' for ${asset.name} failed ${response.status} ${response.statusText}`);
-        err.status = response.status;
-        throw err;
-    } else {
-        Module.print(`MONO_WASM: optional download '${response.url}' for ${asset.name} failed ${response.status} ${response.statusText}`);
-        return undefined;
-    }
-}
-function resolve_path(asset: AssetEntry, sourcePrefix: string): string {
-    mono_assert(sourcePrefix !== null && sourcePrefix !== undefined, () => `sourcePrefix must be provided for ${asset.name}`);
-    let attemptUrl;
-    const assemblyRootFolder = runtimeHelpers.config.assemblyRootFolder;
-    if (!asset.resolvedUrl) {
-        if (sourcePrefix === "") {
-            if (asset.behavior === "assembly" || asset.behavior === "pdb") {
-                attemptUrl = assemblyRootFolder
-                    ? (assemblyRootFolder + "/" + asset.name)
-                    : asset.name;
-            }
-            else if (asset.behavior === "resource") {
-                const path = asset.culture && asset.culture !== "" ? `${asset.culture}/${asset.name}` : asset.name;
-                attemptUrl = assemblyRootFolder
-                    ? (assemblyRootFolder + "/" + path)
-                    : path;
-            }
-            else {
-                attemptUrl = asset.name;
-            }
-        } else {
-            attemptUrl = sourcePrefix + asset.name;
-        }
-        attemptUrl = runtimeHelpers.locateFile(attemptUrl);
-    }
-    else {
-        attemptUrl = asset.resolvedUrl;
-    }
-    mono_assert(attemptUrl && typeof attemptUrl == "string", "attemptUrl need to be path or url string");
-    return attemptUrl;
-}
-function download_resource(request: ResourceRequest): LoadingResource {
-    try {
-        if (typeof Module.downloadResource === "function") {
-            const loading = Module.downloadResource(request);
-            if (loading) return loading;
-        }
-        const options: any = {};
-        if (request.hash) {
-            options.integrity = request.hash;
-        }
-        const response = runtimeHelpers.fetch_like(request.resolvedUrl!, options);
-        return {
-            name: request.name, url: request.resolvedUrl!, response
-        };
-    } catch (err) {
-        const response = <Response><any>{
-            ok: false,
-            url: request.resolvedUrl,
-            status: 500,
-            statusText: "ERR29: " + err,
-            arrayBuffer: () => { throw err; },
-            json: () => { throw err; }
-        };
-        return {
-            name: request.name, url: request.resolvedUrl!, response: Promise.resolve(response)
-        };
-    }
-}
-function _instantiate_asset(asset: AssetEntry, url: string, bytes: Uint8Array) {
-    if (runtimeHelpers.diagnosticTracing)
-        console.debug(`MONO_WASM: Loaded:${asset.name} as ${asset.behavior} size ${bytes.length} from ${url}`);
-    const virtualName: string = typeof (asset.virtualPath) === "string"
-        ? asset.virtualPath
-        : asset.name;
-    let offset: VoidPtr | null = null;
-    switch (asset.behavior) {
-        case "dotnetwasm":
-        case "js-module-threads":
-            break;
-        case "resource":
-        case "assembly":
-        case "pdb":
-            loaded_files.push({ url: url, file: virtualName });
-        case "heap":
-        case "icu":
-            offset = mono_wasm_load_bytes_into_heap(bytes);
-            loaded_assets[virtualName] = [offset, bytes.length];
-            break;
-        case "vfs": {
-            const lastSlash = virtualName.lastIndexOf("/");
-            let parentDirectory = (lastSlash > 0)
-                ? virtualName.substr(0, lastSlash)
-                : null;
-            let fileName = (lastSlash > 0)
-                ? virtualName.substr(lastSlash + 1)
-                : virtualName;
-            if (fileName.startsWith("/"))
-                fileName = fileName.substr(1);
-            if (parentDirectory) {
-                if (runtimeHelpers.diagnosticTracing)
-                    console.debug(`MONO_WASM: Creating directory '${parentDirectory}'`);
-                Module.FS_createPath(
-                    "/", parentDirectory, true, true // fixme: should canWrite be false?
-                );
-            } else {
-                parentDirectory = "/";
-            }
-            if (runtimeHelpers.diagnosticTracing)
-                console.debug(`MONO_WASM: Creating file '${fileName}' in directory '${parentDirectory}'`);
-            if (!mono_wasm_load_data_archive(bytes, parentDirectory)) {
-                Module.FS_createDataFile(
-                    parentDirectory, fileName,
-                    bytes, true /* canRead */, true /* canWrite */, true /* canOwn */
-                );
-            }
-            break;
-        }
-        default:
-            throw new Error(`Unrecognized asset behavior:${asset.behavior}, for asset ${asset.name}`);
-    }
-    if (asset.behavior === "assembly") {
-        const hasPpdb = cwraps.mono_wasm_add_assembly(virtualName, offset!, bytes.length);
-        if (!hasPpdb) {
-            const index = loaded_files.findIndex(element => element.file == virtualName);
-            loaded_files.splice(index, 1);
-        }
-    }
-    else if (asset.behavior === "icu") {
-        if (!mono_wasm_load_icu_data(offset!))
-            Module.printErr(`MONO_WASM: Error loading ICU asset ${asset.name}`);
-    }
-    else if (asset.behavior === "resource") {
-        cwraps.mono_wasm_add_satellite_assembly(virtualName, asset.culture || "", offset!, bytes.length);
-    }
-    ++actual_instantiated_assets_count;
-}
-export async function instantiate_wasm_asset(
-    pendingAsset: AssetEntryInternal,
-    wasmModuleImports: WebAssembly.Imports,
-    successCallback: InstantiateWasmSuccessCallback,
-): Promise<void> {
-    mono_assert(pendingAsset && pendingAsset.pendingDownloadInternal && pendingAsset.pendingDownloadInternal.response, "Can't load dotnet.wasm");
-    const response = await pendingAsset.pendingDownloadInternal.response;
-    const contentType = response.headers && response.headers.get ? response.headers.get("Content-Type") : undefined;
-    let compiledInstance: WebAssembly.Instance;
-    let compiledModule: WebAssembly.Module;
-    if (typeof WebAssembly.instantiateStreaming === "function" && contentType === "application/wasm") {
-        if (runtimeHelpers.diagnosticTracing) console.debug("MONO_WASM: instantiate_wasm_module streaming");
-        const streamingResult = await WebAssembly.instantiateStreaming(response, wasmModuleImports!);
-        compiledInstance = streamingResult.instance;
-        compiledModule = streamingResult.module;
-    } else {
-        if (ENVIRONMENT_IS_WEB && contentType !== "application/wasm") {
-            console.warn("MONO_WASM: WebAssembly resource does not have the expected content type \"application/wasm\", so falling back to slower ArrayBuffer instantiation.");
-        }
-        const arrayBuffer = await response.arrayBuffer();
-        if (runtimeHelpers.diagnosticTracing) console.debug("MONO_WASM: instantiate_wasm_module buffered");
-        const arrayBufferResult = await WebAssembly.instantiate(arrayBuffer, wasmModuleImports!);
-        compiledInstance = arrayBufferResult.instance;
-        compiledModule = arrayBufferResult.module;
-    }
-    successCallback(compiledInstance, compiledModule);
-}
-export function mono_wasm_load_data_archive(data: Uint8Array, prefix: string): boolean {
-    if (data.length < 8)
-        return false;
-    const dataview = new DataView(data.buffer);
-    const magic = dataview.getUint32(0, true);
-    if (magic != 0x626c6174) {
-        return false;
-    }
-    const manifestSize = dataview.getUint32(4, true);
-    if (manifestSize == 0 || data.length < manifestSize + 8)
-        return false;
-    let manifest;
-    try {
-        const manifestContent = Module.UTF8ArrayToString(data, 8, manifestSize);
-        manifest = JSON.parse(manifestContent);
-        if (!(manifest instanceof Array))
-            return false;
-    } catch (exc) {
-        return false;
-    }
-    data = data.slice(manifestSize + 8);
-    const folders = new Set<string>();
-    manifest.filter(m => {
-        const file = m[0];
-        const last = file.lastIndexOf("/");
-        const directory = file.slice(0, last + 1);
-        folders.add(directory);
-    });
-    folders.forEach(folder => {
-        Module["FS_createPath"](prefix, folder, true, true);
-    });
-    for (const row of manifest) {
-        const name = row[0];
-        const length = row[1];
-        const bytes = data.slice(0, length);
-        Module["FS_createDataFile"](prefix, name, bytes, true, true);
-        data = data.slice(length);
-    }
-    return true;
-}
-export async function wait_for_all_assets() {
-    await allAssetsInMemory.promise;
-    if (runtimeHelpers.config.assets) {
-        mono_assert(actual_downloaded_assets_count == expected_downloaded_assets_count, () => `Expected ${expected_downloaded_assets_count} assets to be downloaded, but only finished ${actual_downloaded_assets_count}`);
-        mono_assert(actual_instantiated_assets_count == expected_instantiated_assets_count, () => `Expected ${expected_instantiated_assets_count} assets to be in memory, but only instantiated ${actual_instantiated_assets_count}`);
-        loaded_files.forEach(value => MONO.loaded_files.push(value.url));
-        if (runtimeHelpers.diagnosticTracing) console.debug("MONO_WASM: all assets are loaded in wasm memory");
-    }
-}
-export function mono_wasm_get_loaded_files(): string[] {
-    return MONO.loaded_files;
-}

--- a/src/mono/wasm/runtime/memory.ts
+++ b//dev/null
@@ -1,233 +0,0 @@
-import monoWasmThreads from "consts:monoWasmThreads";
-import { Module, runtimeHelpers } from "./imports";
-import { mono_assert, MemOffset, NumberOrPointer } from "./types";
-import { VoidPtr, CharPtr } from "./types/emscripten";
-import * as cuint64 from "./cuint64";
-import cwraps, { I52Error } from "./cwraps";
-const alloca_stack: Array<VoidPtr> = [];
-const alloca_buffer_size = 32 * 1024;
-let alloca_base: VoidPtr, alloca_offset: VoidPtr, alloca_limit: VoidPtr;
-let HEAPI64: BigInt64Array = <any>null;
-function _ensure_allocated(): void {
-    if (alloca_base)
-        return;
-    alloca_base = Module._malloc(alloca_buffer_size);
-    alloca_offset = alloca_base;
-    alloca_limit = <VoidPtr>(<any>alloca_base + alloca_buffer_size);
-}
-const is_bigint_supported = typeof BigInt !== "undefined" && typeof BigInt64Array !== "undefined";
-export function temp_malloc(size: number): VoidPtr {
-    _ensure_allocated();
-    if (!alloca_stack.length)
-        throw new Error("No temp frames have been created at this point");
-    const result = alloca_offset;
-    alloca_offset += <any>size;
-    if (alloca_offset >= alloca_limit)
-        throw new Error("Out of temp storage space");
-    return result;
-}
-export function _create_temp_frame(): void {
-    _ensure_allocated();
-    alloca_stack.push(alloca_offset);
-}
-export function _release_temp_frame(): void {
-    if (!alloca_stack.length)
-        throw new Error("No temp frames have been created at this point");
-    alloca_offset = <VoidPtr>alloca_stack.pop();
-}
-function assert_int_in_range(value: Number, min: Number, max: Number) {
-    mono_assert(Number.isSafeInteger(value), () => `Value is not an integer: ${value} (${typeof (value)})`);
-    mono_assert(value >= min && value <= max, () => `Overflow: value ${value} is out of ${min} ${max} range`);
-}
-export function _zero_region(byteOffset: VoidPtr, sizeBytes: number): void {
-    Module.HEAP8.fill(0, <any>byteOffset, sizeBytes + <any>byteOffset);
-}
-export function setB32(offset: MemOffset, value: number | boolean): void {
-    const boolValue = !!value;
-    if (typeof (value) === "number")
-        assert_int_in_range(value, 0, 1);
-    Module.HEAP32[<any>offset >>> 2] = boolValue ? 1 : 0;
-}
-export function setU8(offset: MemOffset, value: number): void {
-    assert_int_in_range(value, 0, 0xFF);
-    Module.HEAPU8[<any>offset] = value;
-}
-export function setU16(offset: MemOffset, value: number): void {
-    assert_int_in_range(value, 0, 0xFFFF);
-    Module.HEAPU16[<any>offset >>> 1] = value;
-}
-export function setU32_unchecked(offset: MemOffset, value: NumberOrPointer): void {
-    Module.HEAPU32[<any>offset >>> 2] = <number><any>value;
-}
-export function setU32(offset: MemOffset, value: NumberOrPointer): void {
-    assert_int_in_range(<any>value, 0, 0xFFFF_FFFF);
-    Module.HEAPU32[<any>offset >>> 2] = <number><any>value;
-}
-export function setI8(offset: MemOffset, value: number): void {
-    assert_int_in_range(value, -0x80, 0x7F);
-    Module.HEAP8[<any>offset] = value;
-}
-export function setI16(offset: MemOffset, value: number): void {
-    assert_int_in_range(value, -0x8000, 0x7FFF);
-    Module.HEAP16[<any>offset >>> 1] = value;
-}
-export function setI32_unchecked(offset: MemOffset, value: number): void {
-    Module.HEAP32[<any>offset >>> 2] = value;
-}
-export function setI32(offset: MemOffset, value: number): void {
-    assert_int_in_range(<any>value, -0x8000_0000, 0x7FFF_FFFF);
-    Module.HEAP32[<any>offset >>> 2] = value;
-}
-function autoThrowI52(error: I52Error) {
-    if (error === I52Error.NONE)
-        return;
-    switch (error) {
-        case I52Error.NON_INTEGRAL:
-            throw new Error("value was not an integer");
-        case I52Error.OUT_OF_RANGE:
-            throw new Error("value out of range");
-        default:
-            throw new Error("unknown internal error");
-    }
-}
-/**
- * Throws for values which are not 52 bit integer. See Number.isSafeInteger()
- */
-export function setI52(offset: MemOffset, value: number): void {
-    mono_assert(Number.isSafeInteger(value), () => `Value is not a safe integer: ${value} (${typeof (value)})`);
-    const error = cwraps.mono_wasm_f64_to_i52(<any>offset, value);
-    autoThrowI52(error);
-}
-/**
- * Throws for values which are not 52 bit integer or are negative. See Number.isSafeInteger().
- */
-export function setU52(offset: MemOffset, value: number): void {
-    mono_assert(Number.isSafeInteger(value), () => `Value is not a safe integer: ${value} (${typeof (value)})`);
-    mono_assert(value >= 0, "Can't convert negative Number into UInt64");
-    const error = cwraps.mono_wasm_f64_to_u52(<any>offset, value);
-    autoThrowI52(error);
-}
-export function setI64Big(offset: MemOffset, value: bigint): void {
-    mono_assert(is_bigint_supported, "BigInt is not supported.");
-    mono_assert(typeof value === "bigint", () => `Value is not an bigint: ${value} (${typeof (value)})`);
-    mono_assert(value >= min_int64_big && value <= max_int64_big, () => `Overflow: value ${value} is out of ${min_int64_big} ${max_int64_big} range`);
-    HEAPI64[<any>offset >>> 3] = value;
-}
-export function setF32(offset: MemOffset, value: number): void {
-    mono_assert(typeof value === "number", () => `Value is not a Number: ${value} (${typeof (value)})`);
-    Module.HEAPF32[<any>offset >>> 2] = value;
-}
-export function setF64(offset: MemOffset, value: number): void {
-    mono_assert(typeof value === "number", () => `Value is not a Number: ${value} (${typeof (value)})`);
-    Module.HEAPF64[<any>offset >>> 3] = value;
-}
-export function getB32(offset: MemOffset): boolean {
-    return !!(Module.HEAP32[<any>offset >>> 2]);
-}
-export function getU8(offset: MemOffset): number {
-    return Module.HEAPU8[<any>offset];
-}
-export function getU16(offset: MemOffset): number {
-    return Module.HEAPU16[<any>offset >>> 1];
-}
-export function getU32(offset: MemOffset): number {
-    return Module.HEAPU32[<any>offset >>> 2];
-}
-export function getI8(offset: MemOffset): number {
-    return Module.HEAP8[<any>offset];
-}
-export function getI16(offset: MemOffset): number {
-    return Module.HEAP16[<any>offset >>> 1];
-}
-export function getI32(offset: MemOffset): number {
-    return Module.HEAP32[<any>offset >>> 2];
-}
-/**
- * Throws for Number.MIN_SAFE_INTEGER > value > Number.MAX_SAFE_INTEGER
- */
-export function getI52(offset: MemOffset): number {
-    const result = cwraps.mono_wasm_i52_to_f64(<any>offset, runtimeHelpers._i52_error_scratch_buffer);
-    const error = getI32(runtimeHelpers._i52_error_scratch_buffer);
-    autoThrowI52(error);
-    return result;
-}
-/**
- * Throws for 0 > value > Number.MAX_SAFE_INTEGER
- */
-export function getU52(offset: MemOffset): number {
-    const result = cwraps.mono_wasm_u52_to_f64(<any>offset, runtimeHelpers._i52_error_scratch_buffer);
-    const error = getI32(runtimeHelpers._i52_error_scratch_buffer);
-    autoThrowI52(error);
-    return result;
-}
-export function getI64Big(offset: MemOffset): bigint {
-    mono_assert(is_bigint_supported, "BigInt is not supported.");
-    return HEAPI64[<any>offset >>> 3];
-}
-export function getF32(offset: MemOffset): number {
-    return Module.HEAPF32[<any>offset >>> 2];
-}
-export function getF64(offset: MemOffset): number {
-    return Module.HEAPF64[<any>offset >>> 3];
-}
-let max_int64_big: BigInt;
-let min_int64_big: BigInt;
-export function afterUpdateGlobalBufferAndViews(buffer: ArrayBufferLike): void {
-    if (is_bigint_supported) {
-        max_int64_big = BigInt("9223372036854775807");
-        min_int64_big = BigInt("-9223372036854775808");
-        HEAPI64 = new BigInt64Array(buffer);
-    }
-}
-export function getCU64(offset: MemOffset): cuint64.CUInt64 {
-    const lo = getU32(offset);
-    const hi = getU32(<any>offset + 4);
-    return cuint64.pack32(lo, hi);
-}
-export function setCU64(offset: MemOffset, value: cuint64.CUInt64): void {
-    const [lo, hi] = cuint64.unpack32(value);
-    setU32_unchecked(offset, lo);
-    setU32_unchecked(<any>offset + 4, hi);
-}
-export function withStackAlloc<TResult>(bytesWanted: number, f: (ptr: VoidPtr) => TResult): TResult;
-export function withStackAlloc<T1, TResult>(bytesWanted: number, f: (ptr: VoidPtr, ud1: T1) => TResult, ud1: T1): TResult;
-export function withStackAlloc<T1, T2, TResult>(bytesWanted: number, f: (ptr: VoidPtr, ud1: T1, ud2: T2) => TResult, ud1: T1, ud2: T2): TResult;
-export function withStackAlloc<T1, T2, T3, TResult>(bytesWanted: number, f: (ptr: VoidPtr, ud1: T1, ud2: T2, ud3: T3) => TResult, ud1: T1, ud2: T2, ud3: T3): TResult;
-export function withStackAlloc<T1, T2, T3, TResult>(bytesWanted: number, f: (ptr: VoidPtr, ud1?: T1, ud2?: T2, ud3?: T3) => TResult, ud1?: T1, ud2?: T2, ud3?: T3): TResult {
-    const sp = Module.stackSave();
-    const ptr = Module.stackAlloc(bytesWanted);
-    try {
-        return f(ptr, ud1, ud2, ud3);
-    } finally {
-        Module.stackRestore(sp);
-    }
-}
-export function mono_wasm_load_bytes_into_heap(bytes: Uint8Array): VoidPtr {
-    const memoryOffset = Module._malloc(bytes.length);
-    const heapBytes = new Uint8Array(Module.HEAPU8.buffer, <any>memoryOffset, bytes.length);
-    heapBytes.set(bytes);
-    return memoryOffset;
-}
-export function getEnv(name: string): string | null {
-    let charPtr: CharPtr = <any>0;
-    try {
-        charPtr = cwraps.mono_wasm_getenv(name);
-        if (<any>charPtr === 0)
-            return null;
-        else return Module.UTF8ToString(charPtr);
-    } finally {
-        if (charPtr) Module._free(<any>charPtr);
-    }
-}
-const BuiltinAtomics = globalThis.Atomics;
-export const Atomics = monoWasmThreads ? {
-    storeI32(offset: MemOffset, value: number): void {
-        BuiltinAtomics.store(Module.HEAP32, <any>offset >>> 2, value);
-    },
-    notifyI32(offset: MemOffset, count: number): void {
-        BuiltinAtomics.notify(Module.HEAP32, <any>offset >>> 2, count);
-    }
-} : {
-    storeI32: setI32,
-    notifyI32: () => { /*empty*/ }
-};

--- a/src/native/eventpipe/ep-buffer-manager.c
+++ b//dev/null
@@ -1,1013 +0,0 @@
-#include "ep-rt-config.h"
-#ifdef ENABLE_PERFTRACING
-#if !defined(EP_INCLUDE_SOURCE_FILES) || defined(EP_FORCE_INCLUDE_SOURCE_FILES)
-#define EP_IMPL_BUFFER_MANAGER_GETTER_SETTER
-#include "ep.h"
-#include "ep-buffer.h"
-#include "ep-buffer-manager.h"
-#include "ep-event.h"
-#include "ep-event-instance.h"
-#include "ep-event-payload.h"
-#include "ep-file.h"
-#include "ep-session.h"
-#include "ep-stack-contents.h"
-#define EP_MAX(a,b) (((a) > (b)) ? (a) : (b))
-#define EP_MIN(a,b) (((a) < (b)) ? (a) : (b))
-#define EP_CLAMP(min,value,max) (EP_MIN(EP_MAX(min, value), max))
-/*
- * Forward declares of all static functions.
- */
-static
-void
-buffer_list_fini (EventPipeBufferList *buffer_list);
-static
-bool
-buffer_manager_enqueue_sequence_point (
-	EventPipeBufferManager *buffer_manager,
-	EventPipeSequencePoint *sequence_point);
-static
-void
-buffer_manager_init_sequence_point_thread_list (
-	EventPipeBufferManager *buffer_manager,
-	EventPipeSequencePoint *sequence_point);
-static
-void
-buffer_manager_dequeue_sequence_point (EventPipeBufferManager *buffer_manager);
-static
-bool
-buffer_manager_try_peek_sequence_point (
-	EventPipeBufferManager *buffer_manager,
-	EventPipeSequencePoint **sequence_point);
-static
-EventPipeBuffer *
-buffer_manager_allocate_buffer_for_thread (
-	EventPipeBufferManager *buffer_manager,
-	EventPipeThreadSessionState *thread_session_state,
-	uint32_t request_size,
-	bool *write_suspended);
-static
-void
-buffer_manager_deallocate_buffer (
-	EventPipeBufferManager *buffer_manager,
-	EventPipeBuffer *buffer);
-static
-bool
-buffer_manager_try_reserve_buffer(
-	EventPipeBufferManager *buffer_manager,
-	uint32_t request_size);
-static
-void
-buffer_manager_release_buffer(
-	EventPipeBufferManager *buffer_manager,
-	uint32_t size);
-static
-void
-buffer_manager_move_next_event_any_thread (
-	EventPipeBufferManager *buffer_manager,
-	ep_timestamp_t stop_timestamp);
-static
-void
-buffer_manager_move_next_event_same_thread (
-	EventPipeBufferManager *buffer_manager,
-	ep_timestamp_t stop_timestamp);
-static
-EventPipeBuffer *
-buffer_manager_advance_to_non_empty_buffer (
-	EventPipeBufferManager *buffer_manager,
-	EventPipeBufferList *buffer_list,
-	EventPipeBuffer *buffer,
-	ep_timestamp_t before_timestamp);
-static
-bool
-buffer_manager_try_convert_buffer_to_read_only (
-	EventPipeBufferManager *buffer_manager,
-	EventPipeBuffer *new_read_buffer);
-/*
- * EventPipeBufferList.
- */
-static
-void
-buffer_list_fini (EventPipeBufferList *buffer_list)
-{
-	EP_ASSERT (buffer_list != NULL);
-	ep_thread_holder_fini (&buffer_list->thread_holder);
-}
-EventPipeBufferList *
-ep_buffer_list_alloc (
-	EventPipeBufferManager *manager,
-	EventPipeThread *thread)
-{
-	EventPipeBufferList *instance = ep_rt_object_alloc (EventPipeBufferList);
-	ep_raise_error_if_nok (instance != NULL);
-	ep_raise_error_if_nok (ep_buffer_list_init (instance, manager, thread) != NULL);
-ep_on_exit:
-	return instance;
-ep_on_error:
-	ep_buffer_list_free (instance);
-	instance = NULL;
-	ep_exit_error_handler ();
-}
-EventPipeBufferList *
-ep_buffer_list_init (
-	EventPipeBufferList *buffer_list,
-	EventPipeBufferManager *manager,
-	EventPipeThread *thread)
-{
-	EP_ASSERT (buffer_list != NULL);
-	EP_ASSERT (manager != NULL);
-	EP_ASSERT (thread != NULL);
-	ep_thread_holder_init (&buffer_list->thread_holder, thread);
-	buffer_list->manager = manager;
-	buffer_list->head_buffer = NULL;
-	buffer_list->tail_buffer = NULL;
-	buffer_list->buffer_count = 0;
-	buffer_list->last_read_sequence_number = 0;
-	return buffer_list;
-}
-void
-ep_buffer_list_fini (EventPipeBufferList *buffer_list)
-{
-	ep_return_void_if_nok (buffer_list != NULL);
-	buffer_list_fini (buffer_list);
-}
-void
-ep_buffer_list_free (EventPipeBufferList *buffer_list)
-{
-	ep_return_void_if_nok (buffer_list != NULL);
-	buffer_list_fini (buffer_list);
-	ep_rt_object_free (buffer_list);
-}
-void
-ep_buffer_list_insert_tail (
-	EventPipeBufferList *buffer_list,
-	EventPipeBuffer *buffer)
-{
-	ep_return_void_if_nok (buffer_list != NULL);
-	EP_ASSERT (buffer != NULL);
-	EP_ASSERT (ep_buffer_list_ensure_consistency (buffer_list));
-	EP_ASSERT ((ep_buffer_get_next_buffer (buffer) == NULL) && (ep_buffer_get_prev_buffer (buffer) == NULL));
-	if (buffer_list->tail_buffer == NULL) {
-		buffer_list->head_buffer = buffer_list->tail_buffer = buffer;
-	} else {
-		ep_buffer_set_next_buffer (buffer_list->tail_buffer, buffer);
-		ep_buffer_set_prev_buffer (buffer, buffer_list->tail_buffer);
-		buffer_list->tail_buffer = buffer;
-	}
-	buffer_list->buffer_count++;
-	EP_ASSERT (ep_buffer_list_ensure_consistency (buffer_list));
-}
-EventPipeBuffer *
-ep_buffer_list_get_and_remove_head (EventPipeBufferList *buffer_list)
-{
-	ep_return_null_if_nok (buffer_list != NULL);
-	EP_ASSERT (ep_buffer_list_ensure_consistency (buffer_list));
-	EventPipeBuffer *ret_buffer = NULL;
-	if (buffer_list->head_buffer != NULL)
-	{
-		ret_buffer = buffer_list->head_buffer;
-		buffer_list->head_buffer = ep_buffer_get_next_buffer (buffer_list->head_buffer);
-		if (buffer_list->head_buffer != NULL)
-			ep_buffer_set_prev_buffer (buffer_list->head_buffer, NULL);
-		else
-			buffer_list->tail_buffer = NULL;
-		ep_buffer_set_next_buffer (ret_buffer, NULL);
-		EP_ASSERT ((ep_buffer_get_next_buffer (ret_buffer) == NULL) && (ep_buffer_get_prev_buffer (ret_buffer) == NULL));
-		buffer_list->buffer_count--;
-	}
-	EP_ASSERT (ep_buffer_list_ensure_consistency (buffer_list));
-	return ret_buffer;
-}
-bool
-buffer_manager_try_reserve_buffer(
-	EventPipeBufferManager *buffer_manager,
-	uint32_t request_size)
-{
-	uint64_t iters = 0;
-	size_t old_size_of_all_buffers;
-	size_t new_size_of_all_buffers;
-	do {
-		old_size_of_all_buffers = buffer_manager->size_of_all_buffers;
-		new_size_of_all_buffers = old_size_of_all_buffers + request_size;
-		iters++;
-		if (iters % 64 == 0) {
-			ep_rt_thread_sleep (0); // yield the thread to the scheduler in case we're in high contention
-		}
-	} while (new_size_of_all_buffers <= buffer_manager->max_size_of_all_buffers && ep_rt_atomic_compare_exchange_size_t (&buffer_manager->size_of_all_buffers, old_size_of_all_buffers, new_size_of_all_buffers) != old_size_of_all_buffers);
-	return new_size_of_all_buffers <= buffer_manager->max_size_of_all_buffers;
-}
-void
-buffer_manager_release_buffer(
-	EventPipeBufferManager *buffer_manager,
-	uint32_t size)
-{
-	uint64_t iters = 0;
-	size_t old_size_of_all_buffers;
-	size_t new_size_of_all_buffers;
-	do {
-		old_size_of_all_buffers = buffer_manager->size_of_all_buffers;
-		new_size_of_all_buffers = old_size_of_all_buffers - size;
-		iters++;
-		if (iters % 64 == 0) {
-			ep_rt_thread_sleep (0); // yield the thread to the scheduler in case we're in high contention
-		}
-	} while (new_size_of_all_buffers >= 0 && ep_rt_atomic_compare_exchange_size_t (&buffer_manager->size_of_all_buffers, old_size_of_all_buffers, new_size_of_all_buffers) != old_size_of_all_buffers);
-}
-#ifdef EP_CHECKED_BUILD
-bool
-ep_buffer_list_ensure_consistency (EventPipeBufferList *buffer_list)
-{
-	EP_ASSERT ((buffer_list->head_buffer == NULL && buffer_list->tail_buffer == NULL) ||
-		(buffer_list->head_buffer != NULL && buffer_list->tail_buffer != NULL));
-	if (buffer_list->head_buffer == NULL) {
-		EP_ASSERT (buffer_list->buffer_count == 0);
-		return true;
-	}
-	uint32_t node_count = (buffer_list->head_buffer != NULL) ? 1 : 0;
-	EventPipeBuffer *iterator = buffer_list->head_buffer;
-	while (ep_buffer_get_next_buffer (iterator) != NULL) {
-		iterator = ep_buffer_get_next_buffer (iterator);
-		node_count++;
-		if (ep_buffer_get_next_buffer (iterator) != NULL)
-			EP_ASSERT (ep_buffer_ensure_consistency (iterator));
-		EP_ASSERT (node_count <= buffer_list->buffer_count);
-	}
-	EP_ASSERT (iterator == buffer_list->tail_buffer);
-	EP_ASSERT (node_count == buffer_list->buffer_count);
-	iterator = buffer_list->tail_buffer;
-	node_count = (buffer_list->tail_buffer != NULL) ? 1 : 0;
-	while (ep_buffer_get_prev_buffer (iterator) != NULL) {
-		iterator = ep_buffer_get_prev_buffer (iterator);
-		node_count++;
-		EP_ASSERT (node_count <= buffer_list->buffer_count);
-	}
-	EP_ASSERT (iterator == buffer_list->head_buffer);
-	EP_ASSERT (node_count == buffer_list->buffer_count);
-	return true;
-}
-#endif
-/*
- * EventPipeBufferManager.
- */
-static
-bool
-buffer_manager_enqueue_sequence_point (
-	EventPipeBufferManager *buffer_manager,
-	EventPipeSequencePoint *sequence_point)
-{
-	EP_ASSERT (buffer_manager != NULL);
-	EP_ASSERT (sequence_point != NULL);
-	ep_buffer_manager_requires_lock_held (buffer_manager);
-	return ep_rt_sequence_point_list_append (&buffer_manager->sequence_points, sequence_point);
-}
-static
-void
-buffer_manager_init_sequence_point_thread_list (
-	EventPipeBufferManager *buffer_manager,
-	EventPipeSequencePoint *sequence_point)
-{
-	EP_ASSERT (buffer_manager != NULL);
-	EP_ASSERT (sequence_point != NULL);
-	ep_buffer_manager_requires_lock_held (buffer_manager);
-	ep_rt_thread_session_state_list_iterator_t iterator = ep_rt_thread_session_state_list_iterator_begin (&buffer_manager->thread_session_state_list);
-	while (!ep_rt_thread_session_state_list_iterator_end (&buffer_manager->thread_session_state_list, &iterator)) {
-		EventPipeThreadSessionState *thread_session_state = ep_rt_thread_session_state_list_iterator_value (&iterator);
-		uint32_t sequence_number = ep_thread_session_state_get_volatile_sequence_number (thread_session_state) - 1;
-		ep_rt_thread_sequence_number_map_add (ep_sequence_point_get_thread_sequence_numbers_ref (sequence_point), thread_session_state, sequence_number);
-		ep_thread_addref (ep_thread_holder_get_thread (ep_thread_session_state_get_thread_holder_ref (thread_session_state)));
-		ep_rt_thread_session_state_list_iterator_next (&iterator);
-	}
-	ep_buffer_manager_requires_lock_held (buffer_manager);
-	ep_sequence_point_set_timestamp (sequence_point, ep_perf_timestamp_get ());
-}
-static
-void
-buffer_manager_dequeue_sequence_point (EventPipeBufferManager *buffer_manager)
-{
-	EP_ASSERT (buffer_manager != NULL);
-	ep_buffer_manager_requires_lock_held (buffer_manager);
-	ep_return_void_if_nok (!ep_rt_sequence_point_list_is_empty (&buffer_manager->sequence_points));
-	ep_rt_sequence_point_list_iterator_t iterator = ep_rt_sequence_point_list_iterator_begin (&buffer_manager->sequence_points);
-	EventPipeSequencePoint *value = ep_rt_sequence_point_list_iterator_value (&iterator);
-	ep_rt_sequence_point_list_remove (&buffer_manager->sequence_points, value);
-	ep_sequence_point_free (value);
-}
-static
-bool
-buffer_manager_try_peek_sequence_point (
-	EventPipeBufferManager *buffer_manager,
-	EventPipeSequencePoint **sequence_point)
-{
-	EP_ASSERT (buffer_manager != NULL);
-	EP_ASSERT (sequence_point != NULL);
-	ep_buffer_manager_requires_lock_held (buffer_manager);
-	ep_return_false_if_nok (!ep_rt_sequence_point_list_is_empty (&buffer_manager->sequence_points));
-	ep_rt_sequence_point_list_iterator_t iterator = ep_rt_sequence_point_list_iterator_begin (&buffer_manager->sequence_points);
-	*sequence_point = ep_rt_sequence_point_list_iterator_value (&iterator);
-	return *sequence_point != NULL;
-}
-static
-EventPipeBuffer *
-buffer_manager_allocate_buffer_for_thread (
-	EventPipeBufferManager *buffer_manager,
-	EventPipeThreadSessionState *thread_session_state,
-	uint32_t request_size,
-	bool *write_suspended)
-{
-	EP_ASSERT (buffer_manager != NULL);
-	EP_ASSERT (thread_session_state != NULL);
-	EP_ASSERT (request_size > 0);
-	EventPipeBuffer *new_buffer = NULL;
-	EventPipeBufferList *thread_buffer_list = NULL;
-	EventPipeSequencePoint* sequence_point = NULL;
-	uint32_t sequence_number = 0;
-	uint32_t size_multiplier = ep_thread_session_state_get_buffer_count_estimate(thread_session_state) + 1;
-	EP_ASSERT(size_multiplier > 0);
-#ifdef EP_CHECKED_BUILD
-	uint32_t base_buffer_size = 30 * 1024; // 30K
-#else
-	uint32_t base_buffer_size = 100 * 1024; // 100K
-#endif
-	uint32_t buffer_size = base_buffer_size * size_multiplier;
-	EP_ASSERT(buffer_size > 0);
-	buffer_size = EP_MAX (request_size, buffer_size);
-	const uint32_t max_buffer_size = 1024 * 1024;
-	buffer_size = EP_MIN (buffer_size, max_buffer_size);
-	EP_ASSERT (request_size <= buffer_size);
-	buffer_size = (buffer_size + ep_rt_system_get_alloc_granularity () - 1) & ~(uint32_t)(ep_rt_system_get_alloc_granularity () - 1);
-	EP_ASSERT(buffer_size > 0);
-	ep_return_null_if_nok(buffer_manager_try_reserve_buffer(buffer_manager, buffer_size));
-	sequence_number = ep_thread_session_state_get_volatile_sequence_number (thread_session_state);
-	new_buffer = ep_buffer_alloc (buffer_size, ep_thread_session_state_get_thread (thread_session_state), sequence_number);
-	ep_raise_error_if_nok (new_buffer != NULL);
-	EP_SPIN_LOCK_ENTER (&buffer_manager->rt_lock, section1)
-		thread_buffer_list = ep_thread_session_state_get_buffer_list (thread_session_state);
-		if (thread_buffer_list == NULL) {
-			thread_buffer_list = ep_buffer_list_alloc (buffer_manager, ep_thread_session_state_get_thread (thread_session_state));
-			ep_raise_error_if_nok_holding_spin_lock (thread_buffer_list != NULL, section1);
-			ep_raise_error_if_nok_holding_spin_lock (ep_rt_thread_session_state_list_append (&buffer_manager->thread_session_state_list, thread_session_state), section1);
-			ep_thread_session_state_set_buffer_list (thread_session_state, thread_buffer_list);
-			thread_buffer_list = NULL;
-		}
-		if (buffer_manager->sequence_point_alloc_budget != 0) {
-			if (buffer_size >= buffer_manager->remaining_sequence_point_alloc_budget) {
-				sequence_point = ep_sequence_point_alloc ();
-				if (sequence_point) {
-					buffer_manager_init_sequence_point_thread_list (buffer_manager, sequence_point);
-					ep_raise_error_if_nok_holding_spin_lock (buffer_manager_enqueue_sequence_point (buffer_manager, sequence_point), section1);
-					sequence_point = NULL;
-				}
-				buffer_manager->remaining_sequence_point_alloc_budget = buffer_manager->sequence_point_alloc_budget;
-			} else {
-				buffer_manager->remaining_sequence_point_alloc_budget -= buffer_size;
-			}
-		}
-#ifdef EP_CHECKED_BUILD
-		buffer_manager->num_buffers_allocated++;
-#endif // EP_CHECKED_BUILD
-		if (new_buffer != NULL)
-			ep_buffer_list_insert_tail (ep_thread_session_state_get_buffer_list (thread_session_state), new_buffer);
-	EP_SPIN_LOCK_EXIT (&buffer_manager->rt_lock, section1)
-ep_on_exit:
-	return new_buffer;
-ep_on_error:
-	ep_sequence_point_free (sequence_point);
-	sequence_point = NULL;
-	ep_buffer_list_free (thread_buffer_list);
-	thread_buffer_list = NULL;
-	ep_buffer_free (new_buffer);
-	new_buffer = NULL;
-	buffer_manager_release_buffer(buffer_manager, buffer_size);
-	ep_exit_error_handler ();
-}
-static
-void
-buffer_manager_deallocate_buffer (
-	EventPipeBufferManager *buffer_manager,
-	EventPipeBuffer *buffer)
-{
-	EP_ASSERT (buffer_manager != NULL);
-	if (buffer) {
-		buffer_manager_release_buffer(buffer_manager, ep_buffer_get_size (buffer));
-		ep_buffer_free (buffer);
-#ifdef EP_CHECKED_BUILD
-		buffer_manager->num_buffers_allocated--;
-#endif
-	}
-}
-static
-void
-buffer_manager_move_next_event_any_thread (
-	EventPipeBufferManager *buffer_manager,
-	ep_timestamp_t stop_timestamp)
-{
-	EP_ASSERT (buffer_manager != NULL);
-	ep_buffer_manager_requires_lock_not_held (buffer_manager);
-	if (buffer_manager->current_event != NULL)
-		ep_buffer_move_next_read_event (buffer_manager->current_buffer);
-	buffer_manager->current_event = NULL;
-	buffer_manager->current_buffer = NULL;
-	buffer_manager->current_buffer_list = NULL;
-	EP_RT_DECLARE_LOCAL_BUFFER_ARRAY (buffer_array);
-	EP_RT_DECLARE_LOCAL_BUFFER_LIST_ARRAY (buffer_list_array);
-	ep_rt_buffer_array_init (&buffer_array);
-	ep_rt_buffer_list_array_init (&buffer_list_array);
-	EP_SPIN_LOCK_ENTER (&buffer_manager->rt_lock, section1)
-		EventPipeBufferList *buffer_list;
-		EventPipeBuffer *buffer;
-		ep_rt_thread_session_state_list_iterator_t iterator = ep_rt_thread_session_state_list_iterator_begin (&buffer_manager->thread_session_state_list);
-		while (!ep_rt_thread_session_state_list_iterator_end (&buffer_manager->thread_session_state_list, &iterator)) {
-			buffer_list = ep_thread_session_state_get_buffer_list (ep_rt_thread_session_state_list_iterator_value (&iterator));
-			buffer = buffer_list->head_buffer;
-			if (buffer && ep_buffer_get_creation_timestamp (buffer) < stop_timestamp) {
-				ep_rt_buffer_list_array_append (&buffer_list_array, buffer_list);
-				ep_rt_buffer_array_append (&buffer_array, buffer);
-			}
-			ep_rt_thread_session_state_list_iterator_next (&iterator);
-		}
-	EP_SPIN_LOCK_EXIT (&buffer_manager->rt_lock, section1)
-	ep_timestamp_t oldest_timestamp;
-	oldest_timestamp = stop_timestamp;
-	EventPipeBufferList *buffer_list;
-	EventPipeBuffer *head_buffer;
-	EventPipeBuffer *buffer;
-	EventPipeEventInstance *next_event;
-	ep_rt_buffer_list_array_iterator_t buffer_list_array_iterator;
-	buffer_list_array_iterator = ep_rt_buffer_list_array_iterator_begin (&buffer_list_array);
-	ep_rt_buffer_array_iterator_t buffer_array_iterator;
-	buffer_array_iterator = ep_rt_buffer_array_iterator_begin (&buffer_array);
-	while (!ep_rt_buffer_array_iterator_end (&buffer_array, &buffer_array_iterator) && !ep_rt_buffer_list_array_iterator_end (&buffer_list_array, &buffer_list_array_iterator)) {
-		buffer_list = ep_rt_buffer_list_array_iterator_value (&buffer_list_array_iterator);
-		head_buffer = ep_rt_buffer_array_iterator_value (&buffer_array_iterator);
-		buffer = buffer_manager_advance_to_non_empty_buffer (buffer_manager, buffer_list, head_buffer, stop_timestamp);
-		if (buffer) {
-			next_event = ep_buffer_get_current_read_event (buffer);
-			if (next_event && ep_event_instance_get_timestamp (next_event) < oldest_timestamp) {
-				buffer_manager->current_event = next_event;
-				buffer_manager->current_buffer = buffer;
-				buffer_manager->current_buffer_list = buffer_list;
-				oldest_timestamp = ep_event_instance_get_timestamp (buffer_manager->current_event);
-			}
-		}
-		ep_rt_buffer_list_array_iterator_next (&buffer_list_array_iterator);
-		ep_rt_buffer_array_iterator_next (&buffer_array_iterator);
-	}
-ep_on_exit:
-	ep_buffer_manager_requires_lock_not_held (buffer_manager);
-	ep_rt_buffer_list_array_fini (&buffer_list_array);
-	ep_rt_buffer_array_fini (&buffer_array);
-	return;
-ep_on_error:
-	ep_exit_error_handler ();
-}
-static
-void
-buffer_manager_move_next_event_same_thread (
-	EventPipeBufferManager *buffer_manager,
-	ep_timestamp_t stop_timestamp)
-{
-	EP_ASSERT (buffer_manager != NULL);
-	EP_ASSERT (buffer_manager->current_event != NULL);
-	EP_ASSERT (buffer_manager->current_buffer != NULL);
-	EP_ASSERT (buffer_manager->current_buffer_list != NULL);
-	ep_buffer_manager_requires_lock_not_held (buffer_manager);
-	buffer_manager->current_event = NULL;
-	ep_buffer_move_next_read_event (buffer_manager->current_buffer);
-	buffer_manager->current_buffer = buffer_manager_advance_to_non_empty_buffer (
-		buffer_manager,
-		buffer_manager->current_buffer_list,
-		buffer_manager->current_buffer,
-		stop_timestamp);
-	if (buffer_manager->current_buffer) {
-		EventPipeEventInstance *next_event = ep_buffer_get_current_read_event (buffer_manager->current_buffer);
-		ep_timestamp_t next_timestamp = ep_event_instance_get_timestamp (next_event);
-		if (next_timestamp >= stop_timestamp) {
-			buffer_manager->current_event = NULL;
-			buffer_manager->current_buffer = NULL;
-			buffer_manager->current_buffer_list = NULL;
-		} else {
-			buffer_manager->current_event = next_event;
-			EP_ASSERT (buffer_manager->current_buffer != NULL);
-			EP_ASSERT (buffer_manager->current_buffer_list != NULL);
-		}
-	} else {
-		EP_ASSERT (buffer_manager->current_event == NULL);
-		EP_ASSERT (buffer_manager->current_buffer == NULL);
-		buffer_manager->current_buffer_list = NULL;
-	}
-}
-static
-EventPipeBuffer *
-buffer_manager_advance_to_non_empty_buffer (
-	EventPipeBufferManager *buffer_manager,
-	EventPipeBufferList *buffer_list,
-	EventPipeBuffer *buffer,
-	ep_timestamp_t before_timestamp)
-{
-	EP_ASSERT (buffer_manager != NULL);
-	EP_ASSERT (buffer_list != NULL);
-	EP_ASSERT (buffer != NULL);
-	EP_ASSERT (buffer_list->head_buffer == buffer);
-	ep_buffer_manager_requires_lock_not_held (buffer_manager);
-	EventPipeBuffer *current_buffer = buffer;
-	bool done = false;
-	while (!done) {
-		if (!buffer_manager_try_convert_buffer_to_read_only (buffer_manager, current_buffer)) {
-			current_buffer = NULL;
-			done = true;
-		} else if (ep_buffer_get_current_read_event (current_buffer) != NULL) {
-			done = true;
-		} else {
-			EP_SPIN_LOCK_ENTER (&buffer_manager->rt_lock, section1)
-				EventPipeBuffer *removed_buffer = ep_buffer_list_get_and_remove_head (buffer_list);
-				EP_ASSERT (current_buffer == removed_buffer);
-				buffer_manager_deallocate_buffer (buffer_manager, removed_buffer);
-				current_buffer = buffer_list->head_buffer;
-				if (!current_buffer || ep_buffer_get_creation_timestamp (current_buffer) >= before_timestamp) {
-					current_buffer = NULL;
-					done = true;
-				}
-			EP_SPIN_LOCK_EXIT (&buffer_manager->rt_lock, section1)
-		}
-	}
-ep_on_exit:
-	ep_buffer_manager_requires_lock_not_held (buffer_manager);
-	return current_buffer;
-ep_on_error:
-	current_buffer = NULL;
-	ep_exit_error_handler ();
-}
-static
-bool
-buffer_manager_try_convert_buffer_to_read_only (
-	EventPipeBufferManager *buffer_manager,
-	EventPipeBuffer *new_read_buffer)
-{
-	EP_ASSERT (buffer_manager != NULL);
-	EP_ASSERT (new_read_buffer != NULL);
-	ep_buffer_manager_requires_lock_not_held (buffer_manager);
-	bool result = false;
-	if (ep_buffer_get_volatile_state (new_read_buffer) == EP_BUFFER_STATE_READ_ONLY)
-		return true;
-	EventPipeThread *thread = ep_buffer_get_writer_thread (new_read_buffer);
-	EP_SPIN_LOCK_ENTER (ep_thread_get_rt_lock_ref (thread), section1);
-		EventPipeThreadSessionState *thread_session_state = ep_thread_get_session_state (thread, buffer_manager->session);
-		EP_ASSERT(thread_session_state != NULL);
-		if (ep_thread_session_state_get_write_buffer (thread_session_state) == new_read_buffer) {
-			ep_thread_session_state_set_write_buffer (thread_session_state, NULL);
-			EP_ASSERT (ep_buffer_get_volatile_state (new_read_buffer) == EP_BUFFER_STATE_READ_ONLY);
-			result = true;
-		}
-	EP_SPIN_LOCK_EXIT (ep_thread_get_rt_lock_ref (thread), section1);
-	if (!result)
-		result = (ep_buffer_get_volatile_state (new_read_buffer) == EP_BUFFER_STATE_READ_ONLY);
-ep_on_exit:
-	ep_buffer_manager_requires_lock_not_held (buffer_manager);
-	return result;
-ep_on_error:
-	EP_ASSERT (!result);
-	ep_exit_error_handler ();
-}
-EventPipeBufferManager *
-ep_buffer_manager_alloc (
-	EventPipeSession *session,
-	size_t max_size_of_all_buffers,
-	size_t sequence_point_allocation_budget)
-{
-	EventPipeBufferManager *instance = ep_rt_object_alloc (EventPipeBufferManager);
-	ep_raise_error_if_nok (instance != NULL);
-	ep_rt_thread_session_state_list_alloc (&instance->thread_session_state_list);
-	ep_raise_error_if_nok (ep_rt_thread_session_state_list_is_valid (&instance->thread_session_state_list));
-	ep_rt_sequence_point_list_alloc (&instance->sequence_points);
-	ep_raise_error_if_nok (ep_rt_sequence_point_list_is_valid (&instance->sequence_points));
-	ep_rt_spin_lock_alloc (&instance->rt_lock);
-	ep_raise_error_if_nok (ep_rt_spin_lock_is_valid (&instance->rt_lock));
-	ep_rt_wait_event_alloc (&instance->rt_wait_event, false, true);
-	ep_raise_error_if_nok (ep_rt_wait_event_is_valid (&instance->rt_wait_event));
-	instance->session = session;
-	instance->size_of_all_buffers = 0;
-	instance->num_oversized_events_dropped = 0;
-#ifdef EP_CHECKED_BUILD
-	instance->num_buffers_allocated = 0;
-	instance->num_buffers_stolen = 0;
-	instance->num_buffers_leaked = 0;
-	instance->num_events_stored = 0;
-	ep_rt_volatile_store_int64_t (&instance->num_events_dropped, 0);
-	ep_rt_volatile_store_int64_t (&instance->num_events_written, 0);
-#endif
-	instance->current_event = NULL;
-	instance->current_buffer = NULL;
-	instance->current_buffer_list = NULL;
-	instance->max_size_of_all_buffers = EP_CLAMP ((size_t)100 * 1024, max_size_of_all_buffers, (size_t)UINT32_MAX);
-	if (sequence_point_allocation_budget == 0) {
-		instance->sequence_point_alloc_budget = 0;
-		instance->remaining_sequence_point_alloc_budget = 0;
-	} else {
-		instance->sequence_point_alloc_budget = EP_CLAMP ((size_t)1024 * 1024, sequence_point_allocation_budget, (size_t)1024 * 1024 * 1024);
-		instance->remaining_sequence_point_alloc_budget = sequence_point_allocation_budget;
-	}
-ep_on_exit:
-	return instance;
-ep_on_error:
-	ep_buffer_manager_free (instance);
-	instance = NULL;
-	ep_exit_error_handler ();
-}
-void
-ep_buffer_manager_free (EventPipeBufferManager * buffer_manager)
-{
-	ep_return_void_if_nok (buffer_manager != NULL);
-	ep_buffer_manager_deallocate_buffers (buffer_manager);
-	ep_rt_wait_event_free (&buffer_manager->rt_wait_event);
-	ep_rt_spin_lock_free (&buffer_manager->rt_lock);
-	ep_rt_object_free (buffer_manager);
-}
-#ifdef EP_CHECKED_BUILD
-void
-ep_buffer_manager_requires_lock_held (const EventPipeBufferManager *buffer_manager)
-{
-	ep_rt_spin_lock_requires_lock_held (&buffer_manager->rt_lock);
-}
-void
-ep_buffer_manager_requires_lock_not_held (const EventPipeBufferManager *buffer_manager)
-{
-	ep_rt_spin_lock_requires_lock_not_held (&buffer_manager->rt_lock);
-}
-#endif
-void
-ep_buffer_manager_init_sequence_point_thread_list (
-	EventPipeBufferManager *buffer_manager,
-	EventPipeSequencePoint *sequence_point)
-{
-	EP_ASSERT (buffer_manager != NULL);
-	EP_ASSERT (sequence_point != NULL);
-	ep_buffer_manager_requires_lock_not_held (buffer_manager);
-	EP_SPIN_LOCK_ENTER (&buffer_manager->rt_lock, section1)
-		buffer_manager_init_sequence_point_thread_list (buffer_manager, sequence_point);
-	EP_SPIN_LOCK_EXIT (&buffer_manager->rt_lock, section1)
-ep_on_exit:
-	ep_buffer_manager_requires_lock_not_held (buffer_manager);
-	return;
-ep_on_error:
-	ep_exit_error_handler ();
-}
-bool
-ep_buffer_manager_write_event (
-	EventPipeBufferManager *buffer_manager,
-	ep_rt_thread_handle_t thread,
-	EventPipeSession *session,
-	EventPipeEvent *ep_event,
-	EventPipeEventPayload *payload,
-	const uint8_t *activity_id,
-	const uint8_t *related_activity_id,
-	ep_rt_thread_handle_t event_thread,
-	EventPipeStackContents *stack)
-{
-	bool result = false;
-	bool alloc_new_buffer = false;
-	EventPipeBuffer *buffer = NULL;
-	EventPipeThreadSessionState *session_state = NULL;
-	EventPipeStackContents stack_contents;
-	EventPipeStackContents *current_stack_contents = NULL;
-	EP_ASSERT (buffer_manager != NULL);
-	EP_ASSERT (ep_event != NULL);
-	EP_ASSERT (thread == ep_rt_thread_get_handle ());
-	ep_return_false_if_nok (ep_event_is_enabled (ep_event));
-	if (ep_event_payload_get_size (payload) > 64 * 1024)
-	{
-		ep_rt_atomic_inc_int64_t (&buffer_manager->num_oversized_events_dropped);
-		EventPipeThread *current_thread = ep_thread_get();
-		ep_rt_spin_lock_handle_t *thread_lock = ep_thread_get_rt_lock_ref (current_thread);
-		EP_SPIN_LOCK_ENTER (thread_lock, section1)
-			session_state = ep_thread_get_or_create_session_state (current_thread, session);
-			ep_thread_session_state_increment_sequence_number (session_state);
-		EP_SPIN_LOCK_EXIT (thread_lock, section1)
-		return false;
-	}
-	if (event_thread == NULL)
-		event_thread = thread;
-	current_stack_contents = ep_stack_contents_init (&stack_contents);
-	if (stack == NULL && ep_session_get_enable_stackwalk (session) && ep_event_get_need_stack (ep_event) && !ep_session_get_rundown_enabled (session)) {
-		ep_walk_managed_stack_for_current_thread (current_stack_contents);
-		stack = current_stack_contents;
-	}
-	EventPipeThread *current_thread;
-	current_thread = ep_thread_get ();
-	ep_raise_error_if_nok (current_thread != NULL);
-	ep_rt_spin_lock_handle_t *thread_lock;
-	thread_lock = ep_thread_get_rt_lock_ref (current_thread);
-	EP_SPIN_LOCK_ENTER (thread_lock, section2)
-		session_state = ep_thread_get_or_create_session_state (current_thread, session);
-		ep_raise_error_if_nok_holding_spin_lock (session_state != NULL, section2);
-		buffer = ep_thread_session_state_get_write_buffer (session_state);
-		if (!buffer) {
-			alloc_new_buffer = true;
-		} else {
-			if (ep_buffer_write_event (buffer, event_thread, session, ep_event, payload, activity_id, related_activity_id, stack))
-				ep_thread_session_state_increment_sequence_number (session_state);
-			else
-				alloc_new_buffer = true;
-		}
-	EP_SPIN_LOCK_EXIT (thread_lock, section2)
-	bool should_signal_reader_thread;
-	should_signal_reader_thread = alloc_new_buffer;
-	if (alloc_new_buffer) {
-		uint32_t request_size = sizeof (EventPipeEventInstance) + ep_event_payload_get_size (payload);
-		bool write_suspended = false;
-		buffer = buffer_manager_allocate_buffer_for_thread (buffer_manager, session_state, request_size, &write_suspended);
-		if (!buffer) {
-			ep_raise_error_if_nok (!write_suspended);
-			EP_SPIN_LOCK_ENTER (thread_lock, section3)
-				ep_thread_session_state_increment_sequence_number (session_state);
-			EP_SPIN_LOCK_EXIT (thread_lock, section3)
-		} else {
-			current_thread = ep_thread_get ();
-			EP_ASSERT (current_thread != NULL);
-			thread_lock = ep_thread_get_rt_lock_ref (current_thread);
-			EP_SPIN_LOCK_ENTER (thread_lock, section4)
-					ep_thread_session_state_set_write_buffer (session_state, buffer);
-					alloc_new_buffer = !ep_buffer_write_event (buffer, event_thread, session, ep_event, payload, activity_id, related_activity_id, stack);
-					EP_ASSERT(!alloc_new_buffer);
-					ep_thread_session_state_increment_sequence_number (session_state);
-			EP_SPIN_LOCK_EXIT (thread_lock, section4)
-		}
-	}
-	if (should_signal_reader_thread)
-		ep_rt_wait_event_set (&buffer_manager->rt_wait_event);
-#ifdef EP_CHECKED_BUILD
-	if (!alloc_new_buffer)
-		ep_rt_atomic_inc_int64_t (&buffer_manager->num_events_stored);
-	else
-		ep_rt_atomic_inc_int64_t (&buffer_manager->num_events_dropped);
-#endif
-	result = !alloc_new_buffer;
-ep_on_exit:
-	ep_stack_contents_fini (current_stack_contents);
-	return result;
-ep_on_error:
-	ep_exit_error_handler ();
-}
-void
-ep_buffer_manager_suspend_write_event (
-	EventPipeBufferManager *buffer_manager,
-	uint32_t session_index)
-{
-	EP_ASSERT (buffer_manager != NULL);
-	ep_requires_lock_held ();
-	EP_RT_DECLARE_LOCAL_THREAD_ARRAY (thread_array);
-	ep_rt_thread_array_init (&thread_array);
-	EP_SPIN_LOCK_ENTER (&buffer_manager->rt_lock, section1);
-		EP_ASSERT (ep_buffer_manager_ensure_consistency (buffer_manager));
-		ep_rt_thread_session_state_list_iterator_t thread_session_state_list_iterator = ep_rt_thread_session_state_list_iterator_begin (&buffer_manager->thread_session_state_list);
-		while (!ep_rt_thread_session_state_list_iterator_end (&buffer_manager->thread_session_state_list, &thread_session_state_list_iterator)) {
-			EventPipeThread *thread = ep_thread_session_state_get_thread (ep_rt_thread_session_state_list_iterator_value (&thread_session_state_list_iterator));
-			ep_rt_thread_array_append (&thread_array, thread);
-			ep_rt_thread_session_state_list_iterator_next (&thread_session_state_list_iterator);
-		}
-	EP_SPIN_LOCK_EXIT (&buffer_manager->rt_lock, section1);
-	ep_rt_thread_array_iterator_t thread_array_iterator;
-	thread_array_iterator = ep_rt_thread_array_iterator_begin (&thread_array);
-	while (!ep_rt_thread_array_iterator_end (&thread_array, &thread_array_iterator)) {
-		EventPipeThread *thread = ep_rt_thread_array_iterator_value (&thread_array_iterator);
-		EP_SPIN_LOCK_ENTER (ep_thread_get_rt_lock_ref (thread), section2)
-			EventPipeThreadSessionState *thread_session_state = ep_thread_get_session_state (thread, buffer_manager->session);
-			EP_ASSERT(thread_session_state != NULL);
-			ep_thread_session_state_set_write_buffer (thread_session_state, NULL);
-		EP_SPIN_LOCK_EXIT (ep_thread_get_rt_lock_ref (thread), section2)
-		ep_rt_thread_array_iterator_next (&thread_array_iterator);
-	}
-ep_on_exit:
-	ep_requires_lock_held ();
-	ep_rt_thread_array_fini (&thread_array);
-	return;
-ep_on_error:
-	ep_exit_error_handler ();
-}
-void
-ep_buffer_manager_write_all_buffers_to_file (
-	EventPipeBufferManager *buffer_manager,
-	EventPipeFile *file,
-	ep_timestamp_t stop_timestamp,
-	bool *events_written)
-{
-	EP_ASSERT (buffer_manager != NULL);
-	EP_ASSERT (file != NULL);
-	EP_ASSERT (buffer_manager->current_event == NULL);
-	if (ep_file_get_format (file) >= EP_SERIALIZATION_FORMAT_NETTRACE_V4)
-		ep_buffer_manager_write_all_buffers_to_file_v4 (buffer_manager, file, stop_timestamp, events_written);
-	else
-		ep_buffer_manager_write_all_buffers_to_file_v3 (buffer_manager, file, stop_timestamp, events_written);
-}
-void
-ep_buffer_manager_write_all_buffers_to_file_v3 (
-	EventPipeBufferManager *buffer_manager,
-	EventPipeFile *file,
-	ep_timestamp_t stop_timestamp,
-	bool *events_written)
-{
-	EP_ASSERT (buffer_manager != NULL);
-	EP_ASSERT (file != NULL);
-	EP_ASSERT (buffer_manager->current_event == NULL);
-	EP_ASSERT (events_written != NULL);
-	*events_written = false;
-	buffer_manager_move_next_event_any_thread (buffer_manager, stop_timestamp);
-	while (buffer_manager->current_event != NULL) {
-		*events_written = true;
-		ep_file_write_event (file, buffer_manager->current_event, /*CaptureThreadId=*/0, /*sequenceNumber=*/0, /*IsSorted=*/true);
-		buffer_manager_move_next_event_any_thread (buffer_manager, stop_timestamp);
-	}
-	ep_file_flush (file, EP_FILE_FLUSH_FLAGS_ALL_BLOCKS);
-}
-void
-ep_buffer_manager_write_all_buffers_to_file_v4 (
-	EventPipeBufferManager *buffer_manager,
-	EventPipeFile *file,
-	ep_timestamp_t stop_timestamp,
-	bool *events_written)
-{
-	EP_ASSERT (buffer_manager != NULL);
-	EP_ASSERT (file != NULL);
-	EP_ASSERT (buffer_manager->current_event == NULL);
-	EP_ASSERT (events_written != NULL);
-	*events_written = false;
-	EP_RT_DECLARE_LOCAL_THREAD_SESSION_STATE_ARRAY(session_states_to_delete);
-	ep_rt_thread_session_state_array_init(&session_states_to_delete);
-	EventPipeSequencePoint *sequence_point = NULL;
-	ep_timestamp_t current_timestamp_boundary = stop_timestamp;
-	EP_SPIN_LOCK_ENTER (&buffer_manager->rt_lock, section1)
-		if (buffer_manager_try_peek_sequence_point (buffer_manager, &sequence_point))
-			current_timestamp_boundary = EP_MIN (current_timestamp_boundary, ep_sequence_point_get_timestamp (sequence_point));
-	EP_SPIN_LOCK_EXIT (&buffer_manager->rt_lock, section1)
-	while(true) {
-		while (true) {
-			buffer_manager_move_next_event_any_thread (buffer_manager, current_timestamp_boundary);
-			if (buffer_manager->current_event == NULL)
-				break;
-			uint64_t capture_thread_id = ep_thread_get_os_thread_id (ep_buffer_get_writer_thread (buffer_manager->current_buffer));
-			EventPipeBufferList *buffer_list = buffer_manager->current_buffer_list;
-			bool events_written_for_thread = false;
-			uint32_t sequence_number = 0;
-			while (buffer_manager->current_event != NULL) {
-				sequence_number = ep_buffer_get_current_sequence_number (buffer_manager->current_buffer);
-				ep_file_write_event (file, buffer_manager->current_event, capture_thread_id, sequence_number, !events_written_for_thread);
-				events_written_for_thread = true;
-				buffer_manager_move_next_event_same_thread (buffer_manager, current_timestamp_boundary);
-			}
-			buffer_list->last_read_sequence_number = sequence_number;
-			*events_written = events_written_for_thread || *events_written;
-		}
-		ep_file_flush (file, EP_FILE_FLUSH_FLAGS_ALL_BLOCKS);
-		if (current_timestamp_boundary == stop_timestamp) {
-			break;
-		} else {
-			EP_SPIN_LOCK_ENTER (&buffer_manager->rt_lock, section2)
-				ep_rt_thread_session_state_list_iterator_t thread_session_state_list_iterator = ep_rt_thread_session_state_list_iterator_begin (&buffer_manager->thread_session_state_list);
-				while (!ep_rt_thread_session_state_list_iterator_end (&buffer_manager->thread_session_state_list, &thread_session_state_list_iterator)) {
-					EventPipeThreadSessionState * session_state = ep_rt_thread_session_state_list_iterator_value (&thread_session_state_list_iterator);
-					uint32_t thread_sequence_number = 0;
-					bool exists = ep_rt_thread_sequence_number_map_lookup (ep_sequence_point_get_thread_sequence_numbers_cref (sequence_point), session_state, &thread_sequence_number);
-					uint32_t last_read_sequence_number = ep_thread_session_state_get_buffer_list (session_state)->last_read_sequence_number;
-					uint32_t last_read_delta = last_read_sequence_number - thread_sequence_number;
-					if (0 < last_read_delta && last_read_delta < 0x80000000) {
-						if (exists) {
-							ep_rt_thread_sequence_number_map_remove (ep_sequence_point_get_thread_sequence_numbers_ref (sequence_point), session_state);
-						} else {
-							ep_thread_addref (ep_thread_holder_get_thread (ep_thread_session_state_get_thread_holder_ref (session_state)));
-						}
-						ep_rt_thread_sequence_number_map_add (ep_sequence_point_get_thread_sequence_numbers_ref (sequence_point), session_state, last_read_sequence_number);
-					}
-					ep_rt_thread_session_state_list_iterator_next (&thread_session_state_list_iterator);
-					if (ep_thread_session_state_get_buffer_list (session_state)->head_buffer == NULL) {
-						if (ep_rt_volatile_load_uint32_t_without_barrier (ep_thread_get_unregistered_ref (ep_thread_session_state_get_thread (session_state))) > 0) {
-							ep_rt_thread_session_state_array_append (&session_states_to_delete, session_state);
-							ep_rt_thread_session_state_list_remove (&buffer_manager->thread_session_state_list, session_state);
-						}
-					}
-				}
-			EP_SPIN_LOCK_EXIT (&buffer_manager->rt_lock, section2)
-			ep_file_write_sequence_point (file, sequence_point);
-			EP_SPIN_LOCK_ENTER (&buffer_manager->rt_lock, section3)
-				buffer_manager_dequeue_sequence_point (buffer_manager);
-				current_timestamp_boundary = stop_timestamp;
-				if (buffer_manager_try_peek_sequence_point (buffer_manager, &sequence_point))
-					current_timestamp_boundary = EP_MIN (current_timestamp_boundary, ep_sequence_point_get_timestamp (sequence_point));
-			EP_SPIN_LOCK_EXIT (&buffer_manager->rt_lock, section3)
-		}
-	}
-	if (ep_rt_thread_session_state_array_size (&session_states_to_delete) > 0) {
-		EP_SPIN_LOCK_ENTER (&buffer_manager->rt_lock, section4)
-			if (buffer_manager_try_peek_sequence_point (buffer_manager, &sequence_point)) {
-				for (ep_rt_sequence_point_list_iterator_t sequence_point_list_iterator = ep_rt_sequence_point_list_iterator_begin (&buffer_manager->sequence_points);
-					!ep_rt_sequence_point_list_iterator_end (&buffer_manager->sequence_points, &sequence_point_list_iterator);
-					ep_rt_sequence_point_list_iterator_next (&sequence_point_list_iterator)) {
-					sequence_point = ep_rt_sequence_point_list_iterator_value (&sequence_point_list_iterator);
-					for (ep_rt_thread_session_state_array_iterator_t thread_session_state_array_iterator = ep_rt_thread_session_state_array_iterator_begin (&session_states_to_delete);
-						!ep_rt_thread_session_state_array_iterator_end (&session_states_to_delete, &thread_session_state_array_iterator);
-						ep_rt_thread_session_state_array_iterator_next (&thread_session_state_array_iterator)) {
-						EventPipeThreadSessionState * thread_session_state = ep_rt_thread_session_state_array_iterator_value (&thread_session_state_array_iterator);
-						uint32_t unused_thread_sequence_number = 0;
-						bool exists = ep_rt_thread_sequence_number_map_lookup (ep_sequence_point_get_thread_sequence_numbers_cref (sequence_point), thread_session_state, &unused_thread_sequence_number);
-						if (exists) {
-							ep_rt_thread_sequence_number_map_remove (ep_sequence_point_get_thread_sequence_numbers_ref (sequence_point), thread_session_state);
-							ep_thread_release (ep_thread_session_state_get_thread (thread_session_state));
-						}
-					}
-				}
-			}
-		EP_SPIN_LOCK_EXIT (&buffer_manager->rt_lock, section4)
-	}
-	for (ep_rt_thread_session_state_array_iterator_t thread_session_state_array_iterator = ep_rt_thread_session_state_array_iterator_begin (&session_states_to_delete);
-		!ep_rt_thread_session_state_array_iterator_end (&session_states_to_delete, &thread_session_state_array_iterator);
-		ep_rt_thread_session_state_array_iterator_next (&thread_session_state_array_iterator)) {
-		EventPipeThreadSessionState * thread_session_state = ep_rt_thread_session_state_array_iterator_value (&thread_session_state_array_iterator);
-		EP_ASSERT (thread_session_state != NULL);
-		EventPipeThreadHolder thread_holder;
-		if (ep_thread_holder_init (&thread_holder, ep_thread_session_state_get_thread (thread_session_state))) {
-			ep_rt_spin_lock_handle_t *thread_lock = ep_thread_get_rt_lock_ref (ep_thread_holder_get_thread (&thread_holder));
-			EP_SPIN_LOCK_ENTER (thread_lock, section5)
-				EP_ASSERT(ep_rt_volatile_load_uint32_t_without_barrier (ep_thread_get_unregistered_ref (ep_thread_session_state_get_thread (thread_session_state))) > 0);
-				ep_thread_delete_session_state (ep_thread_session_state_get_thread (thread_session_state), ep_thread_session_state_get_session (thread_session_state));
-			EP_SPIN_LOCK_EXIT (thread_lock, section5)
-			ep_thread_holder_fini (&thread_holder);
-		}
-	}
-ep_on_exit:
-	ep_rt_thread_session_state_array_fini(&session_states_to_delete);
-	return;
-ep_on_error:
-	ep_exit_error_handler ();
-}
-EventPipeEventInstance *
-ep_buffer_manager_get_next_event (EventPipeBufferManager *buffer_manager)
-{
-	EP_ASSERT (buffer_manager != NULL);
-	ep_requires_lock_not_held ();
-	ep_timestamp_t stop_timestamp = ep_perf_timestamp_get ();
-	buffer_manager_move_next_event_any_thread (buffer_manager, stop_timestamp);
-	return buffer_manager->current_event;
-}
-void
-ep_buffer_manager_deallocate_buffers (EventPipeBufferManager *buffer_manager)
-{
-	EP_ASSERT (buffer_manager != NULL);
-	EP_RT_DECLARE_LOCAL_THREAD_SESSION_STATE_ARRAY(thread_session_states_to_remove);
-	ep_rt_thread_session_state_array_init (&thread_session_states_to_remove);
-	EP_SPIN_LOCK_ENTER (&buffer_manager->rt_lock, section1)
-		EP_ASSERT (ep_buffer_manager_ensure_consistency (buffer_manager));
-		ep_rt_thread_session_state_list_iterator_t thread_session_state_list_iterator = ep_rt_thread_session_state_list_iterator_begin (&buffer_manager->thread_session_state_list);
-		while (!ep_rt_thread_session_state_list_iterator_end (&buffer_manager->thread_session_state_list, &thread_session_state_list_iterator)) {
-			EventPipeThreadSessionState *thread_session_state = ep_rt_thread_session_state_list_iterator_value (&thread_session_state_list_iterator);
-			EventPipeBufferList *buffer_list = ep_thread_session_state_get_buffer_list (thread_session_state);
-			ep_thread_session_state_set_buffer_list (thread_session_state, NULL);
-			EventPipeBuffer *buffer = ep_buffer_list_get_and_remove_head (buffer_list);
-			while (buffer) {
-				buffer_manager_deallocate_buffer (buffer_manager, buffer);
-				buffer = ep_buffer_list_get_and_remove_head (buffer_list);
-			}
-			ep_buffer_list_free (buffer_list);
-			buffer_list = NULL;
-			ep_rt_thread_session_state_array_append (&thread_session_states_to_remove, thread_session_state);
-			ep_rt_thread_session_state_list_iterator_next (&thread_session_state_list_iterator);
-		}
-		ep_rt_thread_session_state_list_free (&buffer_manager->thread_session_state_list, NULL);
-	EP_SPIN_LOCK_EXIT (&buffer_manager->rt_lock, section1)
-	ep_rt_thread_session_state_array_iterator_t thread_session_states_to_remove_iterator;
-	thread_session_states_to_remove_iterator = ep_rt_thread_session_state_array_iterator_begin (&thread_session_states_to_remove);
-	while (!ep_rt_thread_session_state_array_iterator_end (&thread_session_states_to_remove, &thread_session_states_to_remove_iterator)) {
-		EventPipeThreadSessionState *thread_session_state = ep_rt_thread_session_state_array_iterator_value (&thread_session_states_to_remove_iterator);
-		EP_ASSERT (thread_session_state != NULL);
-		EventPipeThreadHolder thread_holder;
-		if (ep_thread_holder_init (&thread_holder, ep_thread_session_state_get_thread (thread_session_state))) {
-			ep_rt_spin_lock_handle_t *thread_lock = ep_thread_get_rt_lock_ref (ep_thread_session_state_get_thread (thread_session_state));
-			EP_SPIN_LOCK_ENTER (thread_lock, section2)
-				ep_thread_delete_session_state (ep_thread_session_state_get_thread (thread_session_state), ep_thread_session_state_get_session (thread_session_state));
-			EP_SPIN_LOCK_EXIT (thread_lock, section2)
-			ep_thread_holder_fini (&thread_holder);
-		}
-		ep_rt_thread_session_state_array_iterator_next (&thread_session_states_to_remove_iterator);
-	}
-ep_on_exit:
-	ep_rt_thread_session_state_array_fini (&thread_session_states_to_remove);
-	return;
-ep_on_error:
-	ep_exit_error_handler ();
-}
-#ifdef EP_CHECKED_BUILD
-bool
-ep_buffer_manager_ensure_consistency (EventPipeBufferManager *buffer_manager)
-{
-	EP_ASSERT (buffer_manager != NULL);
-	ep_rt_thread_session_state_list_iterator_t iterator = ep_rt_thread_session_state_list_iterator_begin (&buffer_manager->thread_session_state_list);
-	while (!ep_rt_thread_session_state_list_iterator_end (&buffer_manager->thread_session_state_list, &iterator)) {
-		EventPipeThreadSessionState *thread_session_state = ep_rt_thread_session_state_list_iterator_value (&iterator);
-		EP_ASSERT (ep_buffer_list_ensure_consistency (ep_thread_session_state_get_buffer_list (thread_session_state)));
-		ep_rt_thread_session_state_list_iterator_next (&iterator);
-	}
-	return true;
-}
-#endif
-#endif /* !defined(EP_INCLUDE_SOURCE_FILES) || defined(EP_FORCE_INCLUDE_SOURCE_FILES) */
-#endif /* ENABLE_PERFTRACING */
-#if !defined(ENABLE_PERFTRACING) || (defined(EP_INCLUDE_SOURCE_FILES) && !defined(EP_FORCE_INCLUDE_SOURCE_FILES))
-extern const char quiet_linker_empty_file_warning_eventpipe_buffer_manager;
-const char quiet_linker_empty_file_warning_eventpipe_buffer_manager = 0;
-#endif

--- a/src/native/eventpipe/ep-rt.h
+++ b//dev/null
@@ -1,792 +0,0 @@
-#ifndef __EVENTPIPE_RT_H__
-#define __EVENTPIPE_RT_H__
-#include "ep-rt-config.h"
-#include <minipal/utils.h>
-#ifdef ENABLE_PERFTRACING
-#include "ep-types.h"
-#define EP_INFINITE_WAIT ep_rt_redefine
-#define EP_GCX_PREEMP_ENTER ep_rt_redefine
-#define EP_GCX_PREEMP_EXIT ep_rt_redefine
-#define EP_YIELD_WHILE(condition) ep_rt_redefine
-#define EP_ALWAYS_INLINE ep_rt_redefine
-#define EP_NEVER_INLINE ep_rt_redefine
-#define EP_ALIGN_UP(val,align) ep_rt_redefine
-#ifndef EP_RT_BUILD_TYPE_FUNC_NAME
-#define EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, type_name, func_name) \
-prefix_name ## _rt_ ## type_name ## _ ## func_name
-#endif
-#define EP_RT_DECLARE_LIST_PREFIX(prefix_name, list_name, list_type, item_type) \
-	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, alloc) (list_type *list); \
-	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, free) (list_type *list, void (*callback)(void *)); \
-	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, clear) (list_type *list, void (*callback)(void *)); \
-	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, append) (list_type *list, item_type item); \
-	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, remove) (list_type *list, const item_type item); \
-	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, find) (const list_type *list, const item_type item_to_find, item_type *found_item); \
-	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, is_empty) (const list_type *list); \
-	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, is_valid) (const list_type *list);
-#define EP_RT_DECLARE_LIST(list_name, list_type, item_type) \
-	EP_RT_DECLARE_LIST_PREFIX(ep, list_name, list_type, item_type)
-#define EP_RT_DEFINE_LIST ep_rt_redefine
-#define EP_RT_DECLARE_LIST_ITERATOR_PREFIX(prefix_name, list_name, list_type, iterator_type, item_type) \
-	static iterator_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, iterator_begin) (const list_type *list); \
-	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, iterator_end) (const list_type *list, const iterator_type *iterator); \
-	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, iterator_next) (iterator_type *iterator); \
-	static item_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, iterator_value) (const iterator_type *iterator);
-#define EP_RT_DECLARE_LIST_ITERATOR(list_name, list_type, iterator_type, item_type) \
-	EP_RT_DECLARE_LIST_ITERATOR_PREFIX(ep, list_name, list_type, iterator_type, item_type)
-#define EP_RT_DEFINE_LIST_ITERATOR ep_rt_redefine
-#define EP_RT_DECLARE_QUEUE_PREFIX(prefix_name, queue_name, queue_type, item_type) \
-	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, alloc) (queue_type *queue); \
-	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, free) (queue_type *queue); \
-	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, pop_head) (queue_type *queue, item_type *item); \
-	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, push_head) (queue_type *queue, item_type item); \
-	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, push_tail) (queue_type *queue, item_type item); \
-	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, is_empty) (const queue_type *queue); \
-	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, is_valid) (const queue_type *queue);
-#define EP_RT_DECLARE_QUEUE(queue_name, queue_type, item_type) \
-	EP_RT_DECLARE_QUEUE_PREFIX(ep, queue_name, queue_type, item_type)
-#define EP_RT_DEFINE_QUEUE ep_rt_redefine
-#define EP_RT_DECLARE_ARRAY_PREFIX(prefix_name, array_name, array_type, iterator_type, item_type) \
-	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, alloc) (array_type *ep_array); \
-	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, alloc_capacity) (array_type *ep_array, size_t capacity); \
-	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, free) (array_type *ep_array); \
-	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, append) (array_type *ep_array, item_type item); \
-	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, clear) (array_type *ep_array); \
-	static size_t EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, size) (const array_type *ep_array); \
-	static item_type * EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, data) (const array_type *ep_array); \
-	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, is_valid) (const array_type *ep_array);
-#define EP_RT_DECLARE_LOCAL_ARRAY_PREFIX(prefix_name, array_name, array_type, iterator_type, item_type) \
-	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, init) (array_type *ep_array); \
-	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, init_capacity) (array_type *ep_array, size_t capacity); \
-	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, fini) (array_type *ep_array);
-#define EP_RT_DECLARE_ARRAY(array_name, array_type, iterator_type, item_type) \
-	EP_RT_DECLARE_ARRAY_PREFIX(ep, array_name, array_type, iterator_type, item_type)
-#define EP_RT_DEFINE_ARRAY ep_rt_redefine
-#define EP_RT_DECLARE_LOCAL_ARRAY(array_name, array_type, iterator_type, item_type) \
-	EP_RT_DECLARE_LOCAL_ARRAY_PREFIX(ep, array_name, array_type, iterator_type, item_type)
-#define EP_RT_DEFINE_LOCAL_ARRAY ep_rt_redefine
-#define EP_RT_DECLARE_ARRAY_ITERATOR_PREFIX(prefix_name, array_name, array_type, iterator_type, item_type) \
-	static iterator_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, iterator_begin) (const array_type *ep_array); \
-	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, iterator_end) (const array_type *ep_array, const iterator_type *iterator); \
-	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, iterator_next) (iterator_type *iterator); \
-	static item_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, iterator_value) (const iterator_type *iterator);
-#define EP_RT_DECLARE_ARRAY_REVERSE_ITERATOR_PREFIX(prefix_name, array_name, array_type, iterator_type, item_type) \
-	static iterator_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, reverse_iterator_begin) (const array_type *ep_array); \
-	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, reverse_iterator_end) (const array_type *ep_array, const iterator_type *iterator); \
-	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, reverse_iterator_next) (iterator_type *iterator); \
-	static item_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, reverse_iterator_value) (const iterator_type *iterator);
-#define EP_RT_DECLARE_ARRAY_ITERATOR(array_name, array_type, iterator_type, item_type) \
-	EP_RT_DECLARE_ARRAY_ITERATOR_PREFIX(ep, array_name, array_type, iterator_type, item_type)
-#define EP_RT_DEFINE_ARRAY_ITERATOR ep_rt_redefine
-#define EP_RT_DECLARE_ARRAY_REVERSE_ITERATOR(array_name, array_type, iterator_type, item_type) \
-	EP_RT_DECLARE_ARRAY_REVERSE_ITERATOR_PREFIX(ep, array_name, array_type, iterator_type, item_type)
-#define EP_RT_DEFINE_ARRAY_REVERSE_ITERATOR ep_rt_redefine
-#ifndef EP_RT_USE_CUSTOM_HASH_MAP_CALLBACKS
-typedef uint32_t (*ep_rt_hash_map_hash_callback_t)(const void *);
-typedef bool (*ep_rt_hash_map_equal_callback_t)(const void *, const void *);
-#endif
-#define EP_RT_DECLARE_HASH_MAP_BASE_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
-	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, alloc) (hash_map_type *hash_map, ep_rt_hash_map_hash_callback_t hash_callback, ep_rt_hash_map_equal_callback_t eq_callback, void (*key_free_callback)(void *), void (*value_free_callback)(void *)); \
-	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, free) (hash_map_type *hash_map); \
-	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, add) (hash_map_type *hash_map, key_type key, value_type value); \
-	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, remove_all) (hash_map_type *hash_map); \
-	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, lookup) (const hash_map_type *hash_map, const key_type key, value_type *value); \
-	static uint32_t EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, count) (const hash_map_type *hash_map); \
-	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, is_valid) (const hash_map_type *hash_map);
-#define EP_RT_DECLARE_HASH_MAP_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
-	EP_RT_DECLARE_HASH_MAP_BASE_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
-	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, add_or_replace) (hash_map_type *hash_map, key_type key, value_type value);
-#define EP_RT_DECLARE_HASH_MAP_REMOVE_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
-	EP_RT_DECLARE_HASH_MAP_BASE_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
-	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, remove) (hash_map_type *hash_map, const key_type key);
-#define EP_RT_DECLARE_HASH_MAP(hash_map_name, hash_map_type, key_type, value_type) \
-	EP_RT_DECLARE_HASH_MAP_PREFIX(ep, hash_map_name, hash_map_type, key_type, value_type)
-#define EP_RT_DEFINE_HASH_MAP ep_rt_redefine
-#define EP_RT_DECLARE_HASH_MAP_REMOVE(hash_map_name, hash_map_type, key_type, value_type) \
-	EP_RT_DECLARE_HASH_MAP_REMOVE_PREFIX(ep, hash_map_name, hash_map_type, key_type, value_type)
-#define EP_RT_DEFINE_HASH_MAP_REMOVE ep_rt_redefine
-#define EP_RT_DECLARE_HASH_MAP_ITERATOR_PREFIX(prefix_name, hash_map_name, hash_map_type, iterator_type, key_type, value_type) \
-	static iterator_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_begin) (const hash_map_type *hash_map); \
-	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_end) (const hash_map_type *hash_map, const iterator_type *iterator); \
-	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_next) (iterator_type *iterator); \
-	static key_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_key) (const iterator_type *iterator); \
-	static value_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_value) (const iterator_type *iterator);
-#define EP_RT_DECLARE_HASH_MAP_ITERATOR(hash_map_name, hash_map_type, iterator_type, key_type, value_type) \
-	EP_RT_DECLARE_HASH_MAP_ITERATOR_PREFIX(ep, hash_map_name, hash_map_type, iterator_type, key_type, value_type)
-#define EP_RT_DEFINE_HASH_MAP_ITERATOR ep_rt_redefine
-/*
- * Little-Endian Conversion.
- */
-static
-inline
-uint16_t
-ep_rt_val_uint16_t (uint16_t value);
-static
-inline
-uint32_t
-ep_rt_val_uint32_t (uint32_t value);
-static
-inline
-uint64_t
-ep_rt_val_uint64_t (uint64_t value);
-static
-inline
-int16_t
-ep_rt_val_int16_t (int16_t value);
-static
-inline
-int32_t
-ep_rt_val_int32_t (int32_t value);
-static
-inline
-int64_t
-ep_rt_val_int64_t (int64_t value);
-static
-inline
-uintptr_t
-ep_rt_val_uintptr_t (uintptr_t value);
-/*
-* Atomics.
-*/
-static
-uint32_t
-ep_rt_atomic_inc_uint32_t (volatile uint32_t *value);
-static
-uint32_t
-ep_rt_atomic_dec_uint32_t (volatile uint32_t *value);
-static
-int32_t
-ep_rt_atomic_inc_int32_t (volatile int32_t *value);
-static
-int32_t
-ep_rt_atomic_dec_int32_t (volatile int32_t *value);
-static
-int64_t
-ep_rt_atomic_inc_int64_t (volatile int64_t *value);
-static
-int64_t
-ep_rt_atomic_dec_int64_t (volatile int64_t *value);
-static
-size_t
-ep_rt_atomic_compare_exchange_size_t (volatile size_t *target, size_t expected, size_t value);
-static
-ep_char8_t *
-eo_rt_atomic_compare_exchange_utf8_string (volatile ep_char8_t **target, ep_char8_t *expected, ep_char8_t *value);
-/*
- * EventPipe.
- */
-EP_RT_DECLARE_ARRAY (session_id_array, ep_rt_session_id_array_t, ep_rt_session_id_array_iterator_t, EventPipeSessionID)
-EP_RT_DECLARE_ARRAY_ITERATOR (session_id_array, ep_rt_session_id_array_t, ep_rt_session_id_array_iterator_t, EventPipeSessionID)
-EP_RT_DECLARE_ARRAY (execution_checkpoint_array, ep_rt_execution_checkpoint_array_t, ep_rt_execution_checkpoint_array_iterator_t, EventPipeExecutionCheckpoint *)
-EP_RT_DECLARE_ARRAY_ITERATOR (execution_checkpoint_array, ep_rt_execution_checkpoint_array_t, ep_rt_execution_checkpoint_array_iterator_t, EventPipeExecutionCheckpoint *)
-static
-void
-ep_rt_init (void);
-static
-void
-ep_rt_init_finish (void);
-static
-void
-ep_rt_shutdown (void);
-static
-bool
-ep_rt_config_acquire (void);
-static
-bool
-ep_rt_config_release (void);
-#ifdef EP_CHECKED_BUILD
-static
-void
-ep_rt_config_requires_lock_held (void);
-static
-void
-ep_rt_config_requires_lock_not_held (void);
-#else
-#define ep_rt_config_requires_lock_held()
-#define ep_rt_config_requires_lock_not_held()
-#endif
-static
-bool
-ep_rt_walk_managed_stack_for_thread (
-	ep_rt_thread_handle_t thread,
-	EventPipeStackContents *stack_contents);
-static
-bool
-ep_rt_method_get_simple_assembly_name (
-	ep_rt_method_desc_t *method,
-	ep_char8_t *name, size_t name_len);
-static
-bool
-ep_rt_method_get_full_name (
-	ep_rt_method_desc_t *method,
-	ep_char8_t *name, size_t name_len);
-static
-void
-ep_rt_provider_config_init (EventPipeProviderConfiguration *provider_config);
-static
-void
-ep_rt_init_providers_and_events (void);
-static
-bool
-ep_rt_providers_validate_all_disabled (void);
-static
-void
-ep_rt_prepare_provider_invoke_callback (EventPipeProviderCallbackData *provider_callback_data);
-static
-void
-ep_rt_provider_invoke_callback (
-	EventPipeCallback callback_func,
-	const uint8_t *source_id,
-	unsigned long is_enabled,
-	uint8_t level,
-	uint64_t match_any_keywords,
-	uint64_t match_all_keywords,
-	EventFilterDescriptor *filter_data,
-	void *callback_data);
-/*
- * EventPipeBuffer.
- */
-EP_RT_DECLARE_ARRAY (buffer_array, ep_rt_buffer_array_t, ep_rt_buffer_array_iterator_t, EventPipeBuffer *)
-EP_RT_DECLARE_LOCAL_ARRAY (buffer_array, ep_rt_buffer_array_t, ep_rt_buffer_array_iterator_t, EventPipeBuffer *)
-EP_RT_DECLARE_ARRAY_ITERATOR (buffer_array, ep_rt_buffer_array_t, ep_rt_buffer_array_iterator_t, EventPipeBuffer *)
-#define EP_RT_DECLARE_LOCAL_BUFFER_ARRAY(var_name) ds_rt_redefine
-/*
- * EventPipeBufferList.
- */
-EP_RT_DECLARE_ARRAY (buffer_list_array, ep_rt_buffer_list_array_t, ep_rt_buffer_list_array_iterator_t, EventPipeBufferList *)
-EP_RT_DECLARE_LOCAL_ARRAY (buffer_list_array, ep_rt_buffer_list_array_t, ep_rt_buffer_list_array_iterator_t, EventPipeBufferList *)
-EP_RT_DECLARE_ARRAY_ITERATOR (buffer_list_array, ep_rt_buffer_list_array_t, ep_rt_buffer_list_array_iterator_t, EventPipeBufferList *)
-#define EP_RT_DECLARE_LOCAL_BUFFER_LIST_ARRAY(var_name) ds_rt_redefine
-/*
- * EventPipeEvent.
- */
-EP_RT_DECLARE_LIST (event_list, ep_rt_event_list_t, EventPipeEvent *)
-EP_RT_DECLARE_LIST_ITERATOR (event_list, ep_rt_event_list_t, ep_rt_event_list_iterator_t, EventPipeEvent *)
-/*
- * EventPipeFile.
- */
-EP_RT_DECLARE_HASH_MAP_REMOVE(metadata_labels_hash, ep_rt_metadata_labels_hash_map_t, EventPipeEvent *, uint32_t)
-EP_RT_DECLARE_HASH_MAP(stack_hash, ep_rt_stack_hash_map_t, StackHashKey *, StackHashEntry *)
-EP_RT_DECLARE_HASH_MAP_ITERATOR(stack_hash, ep_rt_stack_hash_map_t, ep_rt_stack_hash_map_iterator_t, StackHashKey *, StackHashEntry *)
-#ifndef EP_RT_USE_CUSTOM_HASH_MAP_CALLBACKS
-#define ep_rt_stack_hash_key_hash ep_stack_hash_key_hash
-#define ep_rt_stack_hash_key_equal ep_stack_hash_key_equal
-#endif
-/*
- * EventPipeProvider.
- */
-EP_RT_DECLARE_LIST (provider_list, ep_rt_provider_list_t, EventPipeProvider *)
-EP_RT_DECLARE_LIST_ITERATOR (provider_list, ep_rt_provider_list_t, ep_rt_provider_list_iterator_t, EventPipeProvider *)
-EP_RT_DECLARE_QUEUE (provider_callback_data_queue, ep_rt_provider_callback_data_queue_t, EventPipeProviderCallbackData *)
-static
-EventPipeProvider *
-ep_rt_provider_list_find_by_name (
-	const ep_rt_provider_list_t *list,
-	const ep_char8_t *name);
-/*
- * EventPipeProviderConfiguration.
- */
-EP_RT_DECLARE_ARRAY (provider_config_array, ep_rt_provider_config_array_t, ep_rt_provider_config_array_iterator_t, EventPipeProviderConfiguration)
-EP_RT_DECLARE_ARRAY_ITERATOR (provider_config_array, ep_rt_provider_config_array_t, ep_rt_provider_config_array_iterator_t, EventPipeProviderConfiguration)
-static
-bool
-ep_rt_config_value_get_enable (void);
-static
-ep_char8_t *
-ep_rt_config_value_get_config (void);
-static
-ep_char8_t *
-ep_rt_config_value_get_output_path (void);
-static
-uint32_t
-ep_rt_config_value_get_circular_mb (void);
-static
-inline
-bool
-ep_rt_config_value_get_output_streaming (void);
-static
-bool
-ep_rt_config_value_get_use_portable_thread_pool (void);
-static
-inline
-bool
-ep_rt_config_value_get_enable_stackwalk (void);
-/*
- * EventPipeSampleProfiler.
- */
-static
-void
-ep_rt_sample_profiler_write_sampling_event_for_threads (ep_rt_thread_handle_t sampling_thread, EventPipeEvent *sampling_event);
-static
-void
-ep_rt_notify_profiler_provider_created (EventPipeProvider *provider);
-/*
- * EventPipeSessionProvider.
- */
-EP_RT_DECLARE_LIST (session_provider_list, ep_rt_session_provider_list_t, EventPipeSessionProvider *)
-EP_RT_DECLARE_LIST_ITERATOR (session_provider_list, ep_rt_session_provider_list_t, ep_rt_session_provider_list_iterator_t, EventPipeSessionProvider *)
-static
-EventPipeSessionProvider *
-ep_rt_session_provider_list_find_by_name (
-	const ep_rt_session_provider_list_t *list,
-	const ep_char8_t *name);
-/*
- * EventPipeSequencePoint.
- */
-EP_RT_DECLARE_LIST (sequence_point_list, ep_rt_sequence_point_list_t, EventPipeSequencePoint *)
-EP_RT_DECLARE_LIST_ITERATOR (sequence_point_list, ep_rt_sequence_point_list_t, ep_rt_sequence_point_list_iterator_t, EventPipeSequencePoint *)
-/*
- * EventPipeThread.
- */
-EP_RT_DECLARE_LIST (thread_list, ep_rt_thread_list_t, EventPipeThread *)
-EP_RT_DECLARE_LIST_ITERATOR (thread_list, ep_rt_thread_list_t, ep_rt_thread_list_iterator_t, EventPipeThread *)
-EP_RT_DECLARE_ARRAY (thread_array, ep_rt_thread_array_t, ep_rt_thread_array_iterator_t, EventPipeThread *)
-EP_RT_DECLARE_LOCAL_ARRAY (thread_array, ep_rt_thread_array_t, ep_rt_thread_array_iterator_t, EventPipeThread *)
-EP_RT_DECLARE_ARRAY_ITERATOR (thread_array, ep_rt_thread_array_t, ep_rt_thread_array_iterator_t, EventPipeThread *)
-#define EP_RT_DECLARE_LOCAL_THREAD_ARRAY(var_name) ds_rt_redefine
-/*
- * EventPipeThreadSessionState.
- */
-EP_RT_DECLARE_LIST (thread_session_state_list, ep_rt_thread_session_state_list_t, EventPipeThreadSessionState *)
-EP_RT_DECLARE_LIST_ITERATOR (thread_session_state_list, ep_rt_thread_session_state_list_t, ep_rt_thread_session_state_list_iterator_t, EventPipeThreadSessionState *)
-EP_RT_DECLARE_ARRAY (thread_session_state_array, ep_rt_thread_session_state_array_t, ep_rt_thread_session_state_array_iterator_t, EventPipeThreadSessionState *)
-EP_RT_DECLARE_LOCAL_ARRAY (thread_session_state_array, ep_rt_thread_session_state_array_t, ep_rt_thread_session_state_array_iterator_t, EventPipeThreadSessionState *)
-EP_RT_DECLARE_ARRAY_ITERATOR (thread_session_state_array, ep_rt_thread_session_state_array_t, ep_rt_thread_session_state_array_iterator_t, EventPipeThreadSessionState *)
-#define EP_RT_DECLARE_LOCAL_THREAD_SESSION_STATE_ARRAY(var_name) ds_rt_redefine
-/*
- * Arrays.
- */
-static
-uint8_t *
-ep_rt_byte_array_alloc (size_t len);
-static
-void
-ep_rt_byte_array_free (uint8_t *ptr);
-/*
- * Event.
- */
-static
-void
-ep_rt_wait_event_alloc (
-	ep_rt_wait_event_handle_t *wait_event,
-	bool manual,
-	bool initial);
-static
-void
-ep_rt_wait_event_free (ep_rt_wait_event_handle_t *wait_event);
-static
-bool
-ep_rt_wait_event_set (ep_rt_wait_event_handle_t *wait_event);
-static
-int32_t
-ep_rt_wait_event_wait (
-	ep_rt_wait_event_handle_t *wait_event,
-	uint32_t timeout,
-	bool alertable);
-static
-EventPipeWaitHandle
-ep_rt_wait_event_get_wait_handle (ep_rt_wait_event_handle_t *wait_event);
-static
-bool
-ep_rt_wait_event_is_valid (ep_rt_wait_event_handle_t *wait_event);
-/*
- * Misc.
- */
-static
-int
-ep_rt_get_last_error (void);
-static
-bool
-ep_rt_process_detach (void);
-static
-bool
-ep_rt_process_shutdown (void);
-static
-void
-ep_rt_create_activity_id (
-	uint8_t *activity_id,
-	uint32_t activity_id_len);
-static
-bool
-ep_rt_is_running (void);
-static
-void
-ep_rt_execute_rundown (ep_rt_execution_checkpoint_array_t *execution_checkpoints);
-/*
- * Objects.
- */
-#define ep_rt_object_alloc(obj_type) ep_rt_redefine
-#define ep_rt_object_array_alloc(obj_type,size) ep_rt_redefine
-static
-void
-ep_rt_object_array_free (void *ptr);
-static
-void
-ep_rt_object_free (void *ptr);
-/*
- * PAL.
- */
-#define EP_RT_DEFINE_THREAD_FUNC ep_rt_redefine
-static
-bool
-ep_rt_thread_create (
-	void *thread_func,
-	void *params,
-	EventPipeThreadType thread_type,
-	void *id);
-static
-void
-ep_rt_thread_sleep (uint64_t ns);
-static
-uint32_t
-ep_rt_current_process_get_id (void);
-static
-uint32_t
-ep_rt_current_processor_get_number (void);
-static
-uint32_t
-ep_rt_processors_get_count (void);
-static
-ep_rt_thread_id_t
-ep_rt_current_thread_get_id (void);
-static
-int64_t
-ep_rt_perf_counter_query (void);
-static
-int64_t
-ep_rt_perf_frequency_query (void);
-static
-void
-ep_rt_system_time_get (EventPipeSystemTime *system_time);
-static
-int64_t
-ep_rt_system_timestamp_get (void);
-static
-int32_t
-ep_rt_system_get_alloc_granularity (void);
-static
-const ep_char8_t *
-ep_rt_os_command_line_get (void);
-static
-ep_rt_file_handle_t
-ep_rt_file_open_write (const ep_char8_t *path);
-static
-bool
-ep_rt_file_close (ep_rt_file_handle_t file_handle);
-static
-bool
-ep_rt_file_write (
-	ep_rt_file_handle_t file_handle,
-	const uint8_t *buffer,
-	uint32_t bytes_to_write,
-	uint32_t *bytes_written);
-static
-uint8_t *
-ep_rt_valloc0 (size_t buffer_size);
-static
-void
-ep_rt_vfree (
-	uint8_t *buffer,
-	size_t buffer_size);
-static
-uint32_t
-ep_rt_temp_path_get (
-	ep_char8_t *buffer,
-	uint32_t buffer_len);
-EP_RT_DECLARE_ARRAY (env_array_utf16_, ep_rt_env_array_utf16_t, ep_rt_env_array_utf16_iterator_t, ep_char16_t *)
-EP_RT_DECLARE_ARRAY_ITERATOR (env_array_utf16, ep_rt_env_array_utf16_t, ep_rt_env_array_utf16_iterator_t, ep_char16_t *)
-static
-void
-ep_rt_os_environment_get_utf16 (ep_rt_env_array_utf16_t *env_array);
-static
-const ep_char8_t *
-ep_rt_entrypoint_assembly_name_get_utf8 (void);
-static
-const ep_char8_t *
-ep_rt_runtime_version_get_utf8 (void);
-/*
-* Lock
-*/
-static
-bool
-ep_rt_lock_acquire (ep_rt_lock_handle_t *lock);
-static
-bool
-ep_rt_lock_release (ep_rt_lock_handle_t *lock);
-#ifdef EP_CHECKED_BUILD
-static
-void
-ep_rt_lock_requires_lock_held (const ep_rt_lock_handle_t *lock);
-static
-void
-ep_rt_lock_requires_lock_not_held (const ep_rt_lock_handle_t *lock);
-#else
-#define ep_rt_lock_requires_lock_held(lock)
-#define ep_rt_lock_requires_lock_not_held(lock)
-#endif
-/*
-* SpinLock.
-*/
-static
-void
-ep_rt_spin_lock_alloc (ep_rt_spin_lock_handle_t *spin_lock);
-static
-void
-ep_rt_spin_lock_free (ep_rt_spin_lock_handle_t *spin_lock);
-static
-bool
-ep_rt_spin_lock_acquire (ep_rt_spin_lock_handle_t *spin_lock);
-static
-bool
-ep_rt_spin_lock_release (ep_rt_spin_lock_handle_t *spin_lock);
-#ifdef EP_CHECKED_BUILD
-static
-void
-ep_rt_spin_lock_requires_lock_held (const ep_rt_spin_lock_handle_t *spin_lock);
-static
-void
-ep_rt_spin_lock_requires_lock_not_held (const ep_rt_spin_lock_handle_t *spin_lock);
-#else
-#define ep_rt_spin_lock_requires_lock_held(spin_lock)
-#define ep_rt_spin_lock_requires_lock_not_held(spin_lock)
-#endif
-static
-bool
-ep_rt_spin_lock_is_valid (const ep_rt_spin_lock_handle_t *spin_lock);
-/*
- * String.
- */
-static
-int
-ep_rt_utf8_string_compare (
-	const ep_char8_t *str1,
-	const ep_char8_t *str2);
-static
-int
-ep_rt_utf8_string_compare_ignore_case (
-	const ep_char8_t *str1,
-	const ep_char8_t *str2);
-static
-bool
-ep_rt_utf8_string_is_null_or_empty (const ep_char8_t *str);
-static
-ep_char8_t *
-ep_rt_utf8_string_dup (const ep_char8_t *str);
-static
-ep_char8_t *
-ep_rt_utf8_string_dup_range (const ep_char8_t *str, const ep_char8_t *strEnd);
-static
-ep_char8_t *
-ep_rt_utf8_string_strtok (
-	ep_char8_t *str,
-	const ep_char8_t *delimiter,
-	ep_char8_t **context);
-#define ep_rt_utf8_string_snprintf( \
-	str, \
-	str_len, \
-	format, ...) ep_redefine
-static
-inline bool
-ep_rt_utf8_string_replace (
-	ep_char8_t **str,
-	const ep_char8_t *strSearch,
-	const ep_char8_t *strReplacement
-);
-static
-ep_char16_t *
-ep_rt_utf8_to_utf16le_string (
-	const ep_char8_t *str,
-	size_t len);
-static
-ep_char16_t *
-ep_rt_utf16_string_dup (const ep_char16_t *str);
-static
-void
-ep_rt_utf8_string_free (ep_char8_t *str);
-static
-size_t
-ep_rt_utf16_string_len (const ep_char16_t *str);
-static
-ep_char8_t *
-ep_rt_utf16_to_utf8_string (
-	const ep_char16_t *str,
-	size_t len);
-static
-ep_char8_t *
-ep_rt_utf16le_to_utf8_string (
-	const ep_char16_t *str,
-	size_t len);
-static
-void
-ep_rt_utf16_string_free (ep_char16_t *str);
-static
-const ep_char8_t *
-ep_rt_managed_command_line_get (void);
-static
-const ep_char8_t *
-ep_rt_diagnostics_command_line_get (void);
-/*
- * Thread.
- */
-static
-void
-ep_rt_thread_setup (void);
-static
-EventPipeThread *
-ep_rt_thread_get (void);
-static
-EventPipeThread *
-ep_rt_thread_get_or_create (void);
-static
-ep_rt_thread_handle_t
-ep_rt_thread_get_handle (void);
-static
-ep_rt_thread_id_t
-ep_rt_thread_get_id (ep_rt_thread_handle_t thread_handle);
-static
-uint64_t
-ep_rt_thread_id_t_to_uint64_t (ep_rt_thread_id_t thread_id);
-static
-ep_rt_thread_id_t
-ep_rt_uint64_t_to_thread_id_t (uint64_t thread_id);
-static
-bool
-ep_rt_thread_has_started (ep_rt_thread_handle_t thread_handle);
-static
-ep_rt_thread_activity_id_handle_t
-ep_rt_thread_get_activity_id_handle (void);
-static
-const uint8_t *
-ep_rt_thread_get_activity_id_cref (ep_rt_thread_activity_id_handle_t activity_id_handle);
-static
-void
-ep_rt_thread_get_activity_id (
-	ep_rt_thread_activity_id_handle_t activity_id_handle,
-	uint8_t *activity_id,
-	uint32_t activity_id_len);
-static
-void
-ep_rt_thread_set_activity_id (
-	ep_rt_thread_activity_id_handle_t activity_id_handle,
-	const uint8_t *activity_id,
-	uint32_t activity_id_len);
-/*
- * ThreadSequenceNumberMap.
- */
-EP_RT_DECLARE_HASH_MAP_REMOVE(thread_sequence_number_map, ep_rt_thread_sequence_number_hash_map_t, EventPipeThreadSessionState *, uint32_t)
-EP_RT_DECLARE_HASH_MAP_ITERATOR(thread_sequence_number_map, ep_rt_thread_sequence_number_hash_map_t, ep_rt_thread_sequence_number_hash_map_iterator_t, EventPipeThreadSessionState *, uint32_t)
-/*
- * Volatile.
- */
-static
-uint32_t
-ep_rt_volatile_load_uint32_t (const volatile uint32_t *ptr);
-static
-uint32_t
-ep_rt_volatile_load_uint32_t_without_barrier (const volatile uint32_t *ptr);
-static
-void
-ep_rt_volatile_store_uint32_t (
-	volatile uint32_t *ptr,
-	uint32_t value);
-static
-void
-ep_rt_volatile_store_uint32_t_without_barrier (
-	volatile uint32_t *ptr,
-	uint32_t value);
-static
-uint64_t
-ep_rt_volatile_load_uint64_t (const volatile uint64_t *ptr);
-static
-uint64_t
-ep_rt_volatile_load_uint64_t_without_barrier (const volatile uint64_t *ptr);
-static
-void
-ep_rt_volatile_store_uint64_t (
-	volatile uint64_t *ptr,
-	uint64_t value);
-static
-void
-ep_rt_volatile_store_uint64_t_without_barrier (
-	volatile uint64_t *ptr,
-	uint64_t value);
-static
-int64_t
-ep_rt_volatile_load_int64_t (const volatile int64_t *ptr);
-static
-int64_t
-ep_rt_volatile_load_int64_t_without_barrier (const volatile int64_t *ptr);
-static
-void
-ep_rt_volatile_store_int64_t (
-	volatile int64_t *ptr,
-	int64_t value);
-static
-void
-ep_rt_volatile_store_int64_t_without_barrier (
-	volatile int64_t *ptr,
-	int64_t value);
-static
-void *
-ep_rt_volatile_load_ptr (volatile void **ptr);
-static
-void *
-ep_rt_volatile_load_ptr_without_barrier (volatile void **ptr);
-static
-void
-ep_rt_volatile_store_ptr (
-	volatile void **ptr,
-	void *value);
-static
-void
-ep_rt_volatile_store_ptr_without_barrier (
-	volatile void **ptr,
-	void *value);
-/*
- * Enter/Exit spin lock helper used with error handling macros.
- */
-#define EP_SPIN_LOCK_ENTER(expr, section_name) \
-{ \
-	ep_rt_spin_lock_requires_lock_not_held (expr); \
-	ep_rt_spin_lock_acquire (expr); \
-	bool _no_error_ ##section_name = false;
-#define EP_SPIN_LOCK_EXIT(expr, section_name) \
-	_no_error_ ##section_name = true; \
-	goto _ep_on_spinlock_exit_ ##section_name; \
-_ep_on_spinlock_exit_ ##section_name : \
-	ep_rt_spin_lock_requires_lock_held (expr); \
-	ep_rt_spin_lock_release (expr); \
-	if (EP_UNLIKELY((!_no_error_ ##section_name))) \
-		goto ep_on_error; \
-	ep_rt_spin_lock_requires_lock_not_held (expr); \
-}
-#define ep_raise_error_if_nok_holding_spin_lock(expr, section_name) do { if (EP_UNLIKELY(!(expr))) { _no_error_ ##section_name = false; goto _ep_on_spinlock_exit_ ##section_name; } } while (0)
-#define ep_raise_error_holding_spin_lock(section_name) do { _no_error_ ##section_name = false; goto _ep_on_spinlock_exit_ ##section_name; } while (0)
-/*
- * Enter/Exit config lock helper used with error handling macros.
- */
-#define EP_LOCK_ENTER(section_name) \
-{ \
-	ep_requires_lock_not_held (); \
-	bool _owns_config_lock_ ##section_name = ep_rt_config_acquire (); \
-	bool _no_config_error_ ##section_name = false; \
-	if (EP_UNLIKELY((!_owns_config_lock_ ##section_name))) \
-		goto _ep_on_config_lock_exit_ ##section_name;
-#define EP_LOCK_EXIT(section_name) \
-	_no_config_error_ ##section_name = true; \
-_ep_on_config_lock_exit_ ##section_name: \
-	if (EP_UNLIKELY((!_owns_config_lock_ ##section_name))) \
-		goto ep_on_error; \
-	ep_requires_lock_held (); \
-	ep_rt_config_release (); \
-	if (EP_UNLIKELY((!_no_config_error_ ##section_name))) \
-		goto ep_on_error; \
-	ep_requires_lock_not_held (); \
-}
-#define ep_raise_error_if_nok_holding_lock(expr, section_name) do { if (EP_UNLIKELY(!(expr))) { _no_config_error_ ##section_name = false; goto _ep_on_config_lock_exit_ ##section_name; } } while (0)
-#define ep_raise_error_holding_lock(section_name) do { _no_config_error_ ##section_name = false; goto _ep_on_config_lock_exit_ ##section_name; } while (0)
-#ifndef EP_NO_RT_DEPENDENCY
-#include EP_RT_H
-#endif
-#endif /* ENABLE_PERFTRACING */
-#endif /* __EVENTPIPE_RT_H__ */

--- a/src/native/eventpipe/ep-session.c
+++ b//dev/null
@@ -1,466 +0,0 @@
-#include "ep-rt-config.h"
-#ifdef ENABLE_PERFTRACING
-#if !defined(EP_INCLUDE_SOURCE_FILES) || defined(EP_FORCE_INCLUDE_SOURCE_FILES)
-#define EP_IMPL_SESSION_GETTER_SETTER
-#include "ep.h"
-#include "ep-buffer-manager.h"
-#include "ep-config.h"
-#include "ep-event.h"
-#include "ep-file.h"
-#include "ep-session.h"
-#include "ep-event-payload.h"
-#include "ep-rt.h"
-/*
- * Forward declares of all static functions.
- */
-static
-void
-session_disable_streaming_thread (EventPipeSession *session);
-static
-void
-session_create_streaming_thread (EventPipeSession *session);
-static
-void
-ep_session_remove_dangling_session_states (EventPipeSession *session);
-/*
- * EventPipeSession.
- */
-EP_RT_DEFINE_THREAD_FUNC (streaming_thread)
-{
-	EP_ASSERT (data != NULL);
-	if (data == NULL)
-		return 1;
-	ep_rt_thread_params_t *thread_params = (ep_rt_thread_params_t *)data;
-	EventPipeSession *const session = (EventPipeSession *)thread_params->thread_params;
-	if (session->session_type != EP_SESSION_TYPE_IPCSTREAM && session->session_type != EP_SESSION_TYPE_FILESTREAM)
-		return 1;
-	if (!thread_params->thread || !ep_rt_thread_has_started (thread_params->thread))
-		return 1;
-	session->streaming_thread = thread_params->thread;
-	bool success = true;
-	ep_rt_wait_event_handle_t *wait_event = ep_session_get_wait_event (session);
-	EP_GCX_PREEMP_ENTER
-		while (ep_session_get_streaming_enabled (session)) {
-			bool events_written = false;
-			if (!ep_session_write_all_buffers_to_file (session, &events_written)) {
-				success = false;
-				break;
-			}
-			if (!events_written) {
-				ep_rt_wait_event_wait (wait_event, EP_INFINITE_WAIT, false);
-			}
-			const uint32_t timeout_ns = 100000000; // 100 msec.
-			ep_rt_thread_sleep (timeout_ns);
-		}
-		session->streaming_thread = NULL;
-		ep_rt_wait_event_set (&session->rt_thread_shutdown_event);
-	EP_GCX_PREEMP_EXIT
-	if (!success)
-		ep_disable ((EventPipeSessionID)session);
-	return (ep_rt_thread_start_func_return_t)0;
-}
-static
-void
-session_create_streaming_thread (EventPipeSession *session)
-{
-	EP_ASSERT (session != NULL);
-	EP_ASSERT (session->session_type == EP_SESSION_TYPE_IPCSTREAM || session->session_type == EP_SESSION_TYPE_FILESTREAM);
-	ep_requires_lock_held ();
-	ep_session_set_streaming_enabled (session, true);
-	ep_rt_wait_event_alloc (&session->rt_thread_shutdown_event, true, false);
-	if (!ep_rt_wait_event_is_valid (&session->rt_thread_shutdown_event))
-		EP_UNREACHABLE ("Unable to create stream flushing thread shutdown event.");
-	ep_rt_thread_id_t thread_id = ep_rt_uint64_t_to_thread_id_t (0);
-	if (!ep_rt_thread_create ((void *)streaming_thread, (void *)session, EP_THREAD_TYPE_SESSION, &thread_id))
-		EP_UNREACHABLE ("Unable to create stream flushing thread.");
-}
-static
-void
-session_disable_streaming_thread (EventPipeSession *session)
-{
-	EP_ASSERT (session->session_type == EP_SESSION_TYPE_IPCSTREAM || session->session_type == EP_SESSION_TYPE_FILESTREAM);
-	EP_ASSERT (ep_session_get_streaming_enabled (session));
-	EP_ASSERT (!ep_rt_process_detach ());
-	EP_ASSERT (session->buffer_manager != NULL);
-	ep_session_set_streaming_enabled (session, false);
-	ep_rt_wait_event_set (ep_buffer_manager_get_rt_wait_event_ref (session->buffer_manager));
-	ep_rt_wait_event_handle_t *rt_thread_shutdown_event = &session->rt_thread_shutdown_event;
-	ep_rt_wait_event_wait (rt_thread_shutdown_event, EP_INFINITE_WAIT, false /* bAlertable */);
-	ep_rt_wait_event_free (rt_thread_shutdown_event);
-}
-EventPipeSession *
-ep_session_alloc (
-	uint32_t index,
-	const ep_char8_t *output_path,
-	IpcStream *stream,
-	EventPipeSessionType session_type,
-	EventPipeSerializationFormat format,
-	bool rundown_requested,
-	uint32_t circular_buffer_size_in_mb,
-	const EventPipeProviderConfiguration *providers,
-	uint32_t providers_len,
-	EventPipeSessionSynchronousCallback sync_callback,
-	void *callback_additional_data)
-{
-	EP_ASSERT (index < EP_MAX_NUMBER_OF_SESSIONS);
-	EP_ASSERT (format < EP_SERIALIZATION_FORMAT_COUNT);
-	EP_ASSERT (session_type == EP_SESSION_TYPE_SYNCHRONOUS || circular_buffer_size_in_mb > 0);
-	EP_ASSERT (providers_len > 0);
-	EP_ASSERT (providers != NULL);
-	EP_ASSERT ((sync_callback != NULL) == (session_type == EP_SESSION_TYPE_SYNCHRONOUS));
-	ep_requires_lock_held ();
-	FileStreamWriter *file_stream_writer = NULL;
-	IpcStreamWriter *ipc_stream_writer = NULL;
-	size_t sequence_point_alloc_budget = 0;
-	EventPipeSession *instance = ep_rt_object_alloc (EventPipeSession);
-	ep_raise_error_if_nok (instance != NULL);
-	instance->providers = ep_session_provider_list_alloc (providers, providers_len);
-	ep_raise_error_if_nok (instance->providers != NULL);
-	instance->index = index;
-	instance->rundown_enabled = 0;
-	instance->session_type = session_type;
-	instance->format = format;
-	instance->rundown_requested = rundown_requested;
-	instance->synchronous_callback = sync_callback;
-	instance->callback_additional_data = callback_additional_data;
-	if (instance->session_type != EP_SESSION_TYPE_LISTENER && instance->format >= EP_SERIALIZATION_FORMAT_NETTRACE_V4) {
-		sequence_point_alloc_budget = 10 * 1024 * 1024;
-	}
-	if (session_type != EP_SESSION_TYPE_SYNCHRONOUS) {
-		instance->buffer_manager = ep_buffer_manager_alloc (instance, ((size_t)circular_buffer_size_in_mb) << 20, sequence_point_alloc_budget);
-		ep_raise_error_if_nok (instance->buffer_manager != NULL);
-	}
-	switch (session_type) {
-	case EP_SESSION_TYPE_FILE :
-	case EP_SESSION_TYPE_FILESTREAM :
-		if (output_path) {
-			file_stream_writer = ep_file_stream_writer_alloc (output_path);
-			ep_raise_error_if_nok (file_stream_writer != NULL);
-			instance->file = ep_file_alloc (ep_file_stream_writer_get_stream_writer_ref (file_stream_writer), format);
-			ep_raise_error_if_nok (instance->file != NULL);
-			file_stream_writer = NULL;
-		}
-		break;
-	case EP_SESSION_TYPE_IPCSTREAM:
-		ipc_stream_writer = ep_ipc_stream_writer_alloc ((uint64_t)instance, stream);
-		ep_raise_error_if_nok (ipc_stream_writer != NULL);
-		instance->file = ep_file_alloc (ep_ipc_stream_writer_get_stream_writer_ref (ipc_stream_writer), format);
-		ep_raise_error_if_nok (instance->file != NULL);
-		ipc_stream_writer = NULL;
-		break;
-	default:
-		break;
-	}
-	instance->session_start_time = ep_system_timestamp_get ();
-	instance->session_start_timestamp = ep_perf_timestamp_get ();
-	instance->paused = false;
-	instance->enable_stackwalk = ep_rt_config_value_get_enable_stackwalk ();
-ep_on_exit:
-	ep_requires_lock_held ();
-	return instance;
-ep_on_error:
-	ep_file_stream_writer_free (file_stream_writer);
-	ep_ipc_stream_writer_free (ipc_stream_writer);
-	ep_session_free (instance);
-	instance = NULL;
-	ep_exit_error_handler ();
-}
-void
-ep_session_remove_dangling_session_states (EventPipeSession *session)
-{
-	ep_return_void_if_nok (session != NULL);
-	EP_RT_DECLARE_LOCAL_THREAD_ARRAY (threads);
-	ep_rt_thread_array_init (&threads);
-	ep_thread_get_threads (&threads);
-	ep_rt_thread_array_iterator_t threads_iterator = ep_rt_thread_array_iterator_begin (&threads);
-	while (!ep_rt_thread_array_iterator_end (&threads, &threads_iterator)) {
-		EventPipeThread *thread = ep_rt_thread_array_iterator_value (&threads_iterator);
-		EP_ASSERT(thread != NULL);
-		EP_SPIN_LOCK_ENTER (ep_thread_get_rt_lock_ref (thread), section1);
-			EventPipeThreadSessionState *session_state = ep_thread_get_session_state(thread, session);
-			if (session_state) {
-				ep_thread_delete_session_state(thread, session);
-			}
-		EP_SPIN_LOCK_EXIT (ep_thread_get_rt_lock_ref (thread), section1);
-		ep_thread_release (thread);
-		ep_rt_thread_array_iterator_next (&threads_iterator);
-	}
-	ep_rt_thread_array_fini (&threads);
-ep_on_exit:
-	return;
-ep_on_error:
-	ep_exit_error_handler ();
-}
-void
-ep_session_free (EventPipeSession *session)
-{
-	ep_return_void_if_nok (session != NULL);
-	EP_ASSERT (!ep_session_get_streaming_enabled (session));
-	ep_rt_wait_event_free (&session->rt_thread_shutdown_event);
-	ep_session_provider_list_free (session->providers);
-	ep_buffer_manager_free (session->buffer_manager);
-	ep_file_free (session->file);
-	ep_session_remove_dangling_session_states (session);
-	ep_rt_object_free (session);
-}
-EventPipeSessionProvider *
-ep_session_get_session_provider (
-	const EventPipeSession *session,
-	const EventPipeProvider *provider)
-{
-	EP_ASSERT (session != NULL);
-	EP_ASSERT (provider != NULL);
-	ep_requires_lock_held ();
-	EventPipeSessionProviderList *providers = session->providers;
-	ep_return_null_if_nok (providers != NULL);
-	EventPipeSessionProvider *catch_all = ep_session_provider_list_get_catch_all_provider (providers);
-	if (catch_all)
-		return catch_all;
-	EventPipeSessionProvider *session_provider = ep_rt_session_provider_list_find_by_name (ep_session_provider_list_get_providers_ref (providers), ep_provider_get_provider_name (provider));
-	ep_requires_lock_held ();
-	return session_provider;
-}
-bool
-ep_session_enable_rundown (EventPipeSession *session)
-{
-	EP_ASSERT (session != NULL);
-	ep_requires_lock_held ();
-	bool result = false;
-	const uint64_t keywords = 0x80020138;
-	const EventPipeEventLevel verbose_logging_level = EP_EVENT_LEVEL_VERBOSE;
-	EventPipeProviderConfiguration rundown_providers [2];
-	uint32_t rundown_providers_len = (uint32_t)ARRAY_SIZE (rundown_providers);
-	ep_provider_config_init (&rundown_providers [0], ep_config_get_public_provider_name_utf8 (), keywords, verbose_logging_level, NULL); // Public provider.
-	ep_provider_config_init (&rundown_providers [1], ep_config_get_rundown_provider_name_utf8 (), keywords, verbose_logging_level, NULL); // Rundown provider.
-	for (uint32_t i = 0; i < rundown_providers_len; ++i) {
-		const EventPipeProviderConfiguration *config = &rundown_providers [i];
-		EventPipeSessionProvider *session_provider = ep_session_provider_alloc (
-			ep_provider_config_get_provider_name (config),
-			ep_provider_config_get_keywords (config),
-			ep_provider_config_get_logging_level (config),
-			ep_provider_config_get_filter_data (config));
-		ep_raise_error_if_nok (ep_session_add_session_provider (session, session_provider));
-	}
-	ep_session_set_rundown_enabled (session, true);
-	result = true;
-ep_on_exit:
-	ep_requires_lock_held ();
-	return result;
-ep_on_error:
-	EP_ASSERT (!result);
-	ep_exit_error_handler ();
-}
-void
-ep_session_execute_rundown (
-	EventPipeSession *session,
-	ep_rt_execution_checkpoint_array_t *execution_checkpoints)
-{
-	EP_ASSERT (session != NULL);
-	ep_requires_lock_held ();
-	ep_return_void_if_nok (session->file != NULL);
-	ep_rt_execute_rundown (execution_checkpoints);
-}
-void
-ep_session_suspend_write_event (EventPipeSession *session)
-{
-	EP_ASSERT (session != NULL);
-	EP_ASSERT (!ep_is_session_enabled ((EventPipeSessionID)session));
-	EP_RT_DECLARE_LOCAL_THREAD_ARRAY (threads);
-	ep_rt_thread_array_init (&threads);
-	ep_thread_get_threads (&threads);
-	ep_rt_thread_array_iterator_t threads_iterator = ep_rt_thread_array_iterator_begin (&threads);
-	while (!ep_rt_thread_array_iterator_end (&threads, &threads_iterator)) {
-		EventPipeThread *thread = ep_rt_thread_array_iterator_value (&threads_iterator);
-		if (thread) {
-			EP_YIELD_WHILE (ep_thread_get_session_write_in_progress (thread) == session->index);
-			ep_thread_release (thread);
-		}
-		ep_rt_thread_array_iterator_next (&threads_iterator);
-	}
-	ep_rt_thread_array_fini (&threads);
-	if (session->buffer_manager)
-		ep_buffer_manager_suspend_write_event (session->buffer_manager, session->index);
-}
-void
-ep_session_write_sequence_point_unbuffered (EventPipeSession *session)
-{
-	EP_ASSERT (session != NULL);
-	ep_return_void_if_nok (session->file != NULL && session->buffer_manager != NULL);
-	EventPipeSequencePoint sequence_point;
-	ep_sequence_point_init (&sequence_point);
-	ep_buffer_manager_init_sequence_point_thread_list (session->buffer_manager, &sequence_point);
-	ep_file_write_sequence_point (session->file, &sequence_point);
-	ep_sequence_point_fini (&sequence_point);
-}
-void
-ep_session_start_streaming (EventPipeSession *session)
-{
-	EP_ASSERT (session != NULL);
-	ep_requires_lock_held ();
-	if (session->file != NULL)
-		ep_file_initialize_file (session->file);
-	if (session->session_type == EP_SESSION_TYPE_IPCSTREAM || session->session_type == EP_SESSION_TYPE_FILESTREAM)
-		session_create_streaming_thread (session);
-	if (session->session_type == EP_SESSION_TYPE_SYNCHRONOUS) {
-		EP_ASSERT (session->file == NULL);
-		EP_ASSERT (!ep_session_get_streaming_enabled (session));
-	}
-	ep_requires_lock_held ();
-	return;
-}
-bool
-ep_session_is_valid (const EventPipeSession *session)
-{
-	EP_ASSERT (session != NULL);
-	ep_requires_lock_held ();
-	return !ep_session_provider_list_is_empty (session->providers);
-}
-bool
-ep_session_add_session_provider (EventPipeSession *session, EventPipeSessionProvider *session_provider)
-{
-	EP_ASSERT (session != NULL);
-	ep_requires_lock_held ();
-	return ep_session_provider_list_add_session_provider (session->providers, session_provider);
-}
-void
-ep_session_disable (EventPipeSession *session)
-{
-	EP_ASSERT (session != NULL);
-	if ((session->session_type == EP_SESSION_TYPE_IPCSTREAM || session->session_type == EP_SESSION_TYPE_FILESTREAM) && ep_session_get_streaming_enabled (session))
-		session_disable_streaming_thread (session);
-	bool ignored;
-	ep_session_write_all_buffers_to_file (session, &ignored);
-	ep_session_provider_list_clear (session->providers);
-}
-bool
-ep_session_write_all_buffers_to_file (EventPipeSession *session, bool *events_written)
-{
-	EP_ASSERT (session != NULL);
-	if (session->file == NULL || session->buffer_manager == NULL)
-		return true;
-	ep_timestamp_t stop_timestamp = ep_perf_timestamp_get ();
-	ep_buffer_manager_write_all_buffers_to_file (session->buffer_manager, session->file, stop_timestamp, events_written);
-	return !ep_file_has_errors (session->file);
-}
-bool
-ep_session_write_event (
-	EventPipeSession *session,
-	ep_rt_thread_handle_t thread,
-	EventPipeEvent *ep_event,
-	EventPipeEventPayload *payload,
-	const uint8_t *activity_id,
-	const uint8_t *related_activity_id,
-	ep_rt_thread_handle_t event_thread,
-	EventPipeStackContents *stack)
-{
-	EP_ASSERT (session != NULL);
-	EP_ASSERT (ep_event != NULL);
-	if (session->paused)
-		return true;
-	bool result = false;
-	if (ep_event_is_enabled_by_mask (ep_event, ep_session_get_mask (session))) {
-		if (session->synchronous_callback) {
-			session->synchronous_callback (
-				ep_event_get_provider (ep_event),
-				ep_event_get_event_id (ep_event),
-				ep_event_get_event_version (ep_event),
-				ep_event_get_metadata_len (ep_event),
-				ep_event_get_metadata (ep_event),
-				ep_event_payload_get_size (payload),
-				ep_event_payload_get_flat_data (payload),
-				activity_id,
-				related_activity_id,
-				event_thread,
-				stack == NULL ? 0 : ep_stack_contents_get_size (stack),
-				stack == NULL ? NULL : (uintptr_t *)ep_stack_contents_get_pointer (stack),
-				session->callback_additional_data);
-			result = true;
-		} else {
-			EP_ASSERT (session->buffer_manager != NULL);
-			result = ep_buffer_manager_write_event (
-				session->buffer_manager,
-				thread,
-				session,
-				ep_event,
-				payload,
-				activity_id,
-				related_activity_id,
-				event_thread,
-				stack);
-		}
-	}
-	return result;
-}
-EventPipeEventInstance *
-ep_session_get_next_event (EventPipeSession *session)
-{
-	EP_ASSERT (session != NULL);
-	ep_requires_lock_not_held ();
-	if (!session->buffer_manager) {
-		EP_ASSERT (!"Shouldn't call get_next_event on a synchronous session.");
-		return NULL;
-	}
-	return ep_buffer_manager_get_next_event (session->buffer_manager);
-}
-ep_rt_wait_event_handle_t *
-ep_session_get_wait_event (EventPipeSession *session)
-{
-	EP_ASSERT (session != NULL);
-	if (!session->buffer_manager) {
-		EP_ASSERT (!"Shouldn't call get_wait_event on a synchronous session.");
-		return NULL;
-	}
-	return ep_buffer_manager_get_rt_wait_event_ref (session->buffer_manager);
-}
-uint64_t
-ep_session_get_mask (const EventPipeSession *session)
-{
-	EP_ASSERT (session != NULL);
-	return ((uint64_t)1 << session->index);
-}
-bool
-ep_session_get_rundown_enabled (const EventPipeSession *session)
-{
-	EP_ASSERT (session != NULL);
-	return (ep_rt_volatile_load_uint32_t (&session->rundown_enabled) != 0 ? true : false);
-}
-void
-ep_session_set_rundown_enabled (
-	EventPipeSession *session,
-	bool enabled)
-{
-	EP_ASSERT (session != NULL);
-	ep_rt_volatile_store_uint32_t (&session->rundown_enabled, (enabled) ? 1 : 0);
-}
-bool
-ep_session_get_streaming_enabled (const EventPipeSession *session)
-{
-	EP_ASSERT (session != NULL);
-	return (ep_rt_volatile_load_uint32_t(&session->streaming_enabled) != 0 ? true : false);
-}
-void
-ep_session_set_streaming_enabled (
-	EventPipeSession *session,
-	bool enabled)
-{
-	EP_ASSERT (session != NULL);
-	ep_rt_volatile_store_uint32_t (&session->streaming_enabled, (enabled) ? 1 : 0);
-}
-void
-ep_session_pause (EventPipeSession *session)
-{
-	EP_ASSERT (session != NULL);
-	session->paused = true;
-}
-void
-ep_session_resume (EventPipeSession *session)
-{
-	EP_ASSERT (session != NULL);
-	session->paused = false;
-}
-#endif /* !defined(EP_INCLUDE_SOURCE_FILES) || defined(EP_FORCE_INCLUDE_SOURCE_FILES) */
-#endif /* ENABLE_PERFTRACING */
-#if !defined(ENABLE_PERFTRACING) || (defined(EP_INCLUDE_SOURCE_FILES) && !defined(EP_FORCE_INCLUDE_SOURCE_FILES))
-extern const char quiet_linker_empty_file_warning_eventpipe_session;
-const char quiet_linker_empty_file_warning_eventpipe_session = 0;
-#endif

--- a/src/native/eventpipe/ep-session.h
+++ b//dev/null
@@ -1,128 +0,0 @@
-#ifndef __EVENTPIPE_SESSION_H__
-#define __EVENTPIPE_SESSION_H__
-#include "ep-rt-config.h"
-#ifdef ENABLE_PERFTRACING
-#include "ep-types.h"
-#include "ep-thread.h"
-#undef EP_IMPL_GETTER_SETTER
-#ifdef EP_IMPL_SESSION_GETTER_SETTER
-#define EP_IMPL_GETTER_SETTER
-#endif
-#include "ep-getter-setter.h"
-/*
- * EventPipeSession.
- */
-#if defined(EP_INLINE_GETTER_SETTER) || defined(EP_IMPL_SESSION_GETTER_SETTER)
-struct _EventPipeSession {
-#else
-struct _EventPipeSession_Internal {
-#endif
-	ep_rt_thread_handle_t streaming_thread;
-	ep_rt_wait_event_handle_t rt_thread_shutdown_event;
-	EventPipeSessionProviderList *providers;
-	EventPipeBufferManager *buffer_manager;
-	EventPipeFile *file;
-	EventPipeSessionSynchronousCallback synchronous_callback;
-	void *callback_additional_data;
-	ep_system_timestamp_t session_start_time;
-	ep_timestamp_t session_start_timestamp;
-	uint32_t index;
-	volatile uint32_t rundown_enabled;
-	volatile uint32_t streaming_enabled;
-	EventPipeSessionType session_type;
-	EventPipeSerializationFormat format;
-	bool rundown_requested;
-	bool paused;
-	bool enable_stackwalk;
-};
-#if !defined(EP_INLINE_GETTER_SETTER) && !defined(EP_IMPL_SESSION_GETTER_SETTER)
-struct _EventPipeSession {
-	uint8_t _internal [sizeof (struct _EventPipeSession_Internal)];
-};
-#endif
-EP_DEFINE_GETTER(EventPipeSession *, session, uint32_t, index)
-EP_DEFINE_GETTER(EventPipeSession *, session, EventPipeSessionProviderList *, providers)
-EP_DEFINE_GETTER(EventPipeSession *, session, EventPipeBufferManager *, buffer_manager)
-EP_DEFINE_GETTER_REF(EventPipeSession *, session, volatile uint32_t *, rundown_enabled)
-EP_DEFINE_GETTER(EventPipeSession *, session, bool, rundown_requested)
-EP_DEFINE_GETTER(EventPipeSession *, session, ep_timestamp_t, session_start_time)
-EP_DEFINE_GETTER(EventPipeSession *, session, ep_timestamp_t, session_start_timestamp)
-EP_DEFINE_GETTER(EventPipeSession *, session, EventPipeFile *, file)
-EP_DEFINE_GETTER(EventPipeSession *, session, bool, enable_stackwalk)
-EventPipeSession *
-ep_session_alloc (
-	uint32_t index,
-	const ep_char8_t *output_path,
-	IpcStream *stream,
-	EventPipeSessionType session_type,
-	EventPipeSerializationFormat format,
-	bool rundown_requested,
-	uint32_t circular_buffer_size_in_mb,
-	const EventPipeProviderConfiguration *providers,
-	uint32_t providers_len,
-	EventPipeSessionSynchronousCallback sync_callback,
-	void *callback_additional_data);
-void
-ep_session_free (EventPipeSession *session);
-EventPipeSessionProvider *
-ep_session_get_session_provider (
-	const EventPipeSession *session,
-	const EventPipeProvider *provider);
-bool
-ep_session_enable_rundown (EventPipeSession *session);
-void
-ep_session_execute_rundown (
-	EventPipeSession *session,
-	ep_rt_execution_checkpoint_array_t *execution_checkpoints);
-void
-ep_session_suspend_write_event (EventPipeSession *session);
-void
-ep_session_write_sequence_point_unbuffered (EventPipeSession *session);
-void
-ep_session_start_streaming (EventPipeSession *session);
-bool
-ep_session_is_valid (const EventPipeSession *session);
-bool
-ep_session_add_session_provider (
-	EventPipeSession *session,
-	EventPipeSessionProvider *session_provider);
-void
-ep_session_disable (EventPipeSession *session);
-bool
-ep_session_write_all_buffers_to_file (
-	EventPipeSession *session,
-	bool *events_written);
-bool
-ep_session_write_event (
-	EventPipeSession *session,
-	ep_rt_thread_handle_t thread,
-	EventPipeEvent *ep_event,
-	EventPipeEventPayload *payload,
-	const uint8_t *activity_id,
-	const uint8_t *related_activity_id,
-	ep_rt_thread_handle_t event_thread,
-	EventPipeStackContents *stack);
-EventPipeEventInstance *
-ep_session_get_next_event (EventPipeSession *session);
-ep_rt_wait_event_handle_t *
-ep_session_get_wait_event (EventPipeSession *session);
-uint64_t
-ep_session_get_mask (const EventPipeSession *session);
-bool
-ep_session_get_rundown_enabled (const EventPipeSession *session);
-void
-ep_session_set_rundown_enabled (
-	EventPipeSession *session,
-	bool enabled);
-bool
-ep_session_get_streaming_enabled (const EventPipeSession *session);
-void
-ep_session_set_streaming_enabled (
-	EventPipeSession *session,
-	bool enabled);
-void
-ep_session_pause (EventPipeSession *session);
-void
-ep_session_resume (EventPipeSession *session);
-#endif /* ENABLE_PERFTRACING */
-#endif /* __EVENTPIPE_SESSION_H__ */

--- a/src/tasks/WorkloadBuildTasks/InstallWorkloadFromArtifacts.cs
+++ b//dev/null
@@ -1,328 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.Diagnostics.CodeAnalysis;
-using System.Globalization;
-using System.IO;
-using System.IO.Compression;
-using System.Linq;
-using System.Text.Json;
-using System.Text.Json.Serialization;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
-#nullable enable
-namespace Microsoft.Workload.Build.Tasks
-{
-    public class InstallWorkloadFromArtifacts : Task
-    {
-        [Required, NotNull]
-        public ITaskItem[]    WorkloadIds        { get; set; } = Array.Empty<ITaskItem>();
-        [Required, NotNull]
-        public ITaskItem[]    InstallTargets     { get; set; } = Array.Empty<ITaskItem>();
-        [Required, NotNull]
-        public string?        VersionBand        { get; set; }
-        [Required, NotNull]
-        public string?        LocalNuGetsPath    { get; set; }
-        [Required, NotNull]
-        public string?        TemplateNuGetConfigPath { get; set; }
-        [Required, NotNull]
-        public string         SdkWithNoWorkloadInstalledPath { get; set; } = string.Empty;
-        public bool           OnlyUpdateManifests{ get; set; }
-        private const string s_nugetInsertionTag = "<!-- TEST_RESTORE_SOURCES_INSERTION_LINE -->";
-        private string AllManifestsStampPath => Path.Combine(SdkWithNoWorkloadInstalledPath, ".all-manifests.stamp");
-        public override bool Execute()
-        {
-            try
-            {
-                if (!Directory.Exists(SdkWithNoWorkloadInstalledPath))
-                    throw new LogAsErrorException($"Cannot find {nameof(SdkWithNoWorkloadInstalledPath)}={SdkWithNoWorkloadInstalledPath}");
-                if (!Directory.Exists(LocalNuGetsPath))
-                    throw new LogAsErrorException($"Cannot find {nameof(LocalNuGetsPath)}={LocalNuGetsPath} . " +
-                                                    "Set it to the Shipping packages directory in artifacts.");
-                if (!InstallAllManifests())
-                    return false;
-                if (OnlyUpdateManifests)
-                    return !Log.HasLoggedErrors;
-                InstallWorkloadRequest[] selectedRequests = InstallTargets
-                    .SelectMany(workloadToInstall =>
-                    {
-                        if (!HasMetadata(workloadToInstall, nameof(workloadToInstall), "Variants", Log))
-                            throw new LogAsErrorException($"Missing Variants metadata on item '{workloadToInstall.ItemSpec}'");
-                        return workloadToInstall
-                                .GetMetadata("Variants")
-                                .Split(";", StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
-                                .Select(v => (variant: v, target: workloadToInstall));
-                    })
-                    .SelectMany(w =>
-                    {
-                        IEnumerable<InstallWorkloadRequest> workloads = WorkloadIds.Where(wi => wi.GetMetadata("Variant") == w.variant)
-                                                                                    .Select(wi => new InstallWorkloadRequest(wi, w.target));
-                        return workloads.Any()
-                                ? workloads
-                                : throw new LogAsErrorException($"Could not find any workload variant named '{w.variant}'");
-                    }).ToArray();
-                foreach (InstallWorkloadRequest req in selectedRequests)
-                {
-                    if (Directory.Exists(req.TargetPath))
-                    {
-                        Log.LogMessage(MessageImportance.Low, $"Deleting directory {req.TargetPath}");
-                        Directory.Delete(req.TargetPath, recursive: true);
-                    }
-                }
-                string cachePath = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
-                foreach (InstallWorkloadRequest req in selectedRequests)
-                {
-                    Log.LogMessage(MessageImportance.High, $"** Installing workload {req.WorkloadId} in {req.TargetPath} **");
-                    if (!req.Validate(Log))
-                        return false;
-                    if (!ExecuteInternal(req) && !req.IgnoreErrors)
-                        return false;
-                    File.WriteAllText(req.StampPath, string.Empty);
-                }
-                return !Log.HasLoggedErrors;
-            }
-            catch (LogAsErrorException laee)
-            {
-                Log.LogError(laee.Message);
-                return false;
-            }
-        }
-        private bool ExecuteInternal(InstallWorkloadRequest req)
-        {
-            if (!File.Exists(TemplateNuGetConfigPath))
-            {
-                Log.LogError($"Cannot find TemplateNuGetConfigPath={TemplateNuGetConfigPath}");
-                return false;
-            }
-            Log.LogMessage(MessageImportance.Low, $"Duplicating {SdkWithNoWorkloadInstalledPath} into {req.TargetPath}");
-            Utils.DirectoryCopy(SdkWithNoWorkloadInstalledPath, req.TargetPath);
-            string nugetConfigContents = GetNuGetConfig();
-            if (!InstallPacks(req, nugetConfigContents))
-                return false;
-            UpdateAppRef(req.TargetPath, req.Version);
-            return !Log.HasLoggedErrors;
-        }
-        private bool InstallAllManifests()
-        {
-            var allManifestPkgs = Directory.EnumerateFiles(LocalNuGetsPath, "*Manifest*nupkg");
-            if (!AnyInputsNewerThanOutput(AllManifestsStampPath, allManifestPkgs))
-            {
-                Log.LogMessage(MessageImportance.Low,
-                                    $"Skipping installing manifests because the {AllManifestsStampPath} " +
-                                    $"is newer than packages {string.Join(',', allManifestPkgs)}.");
-                return true;
-            }
-            string nugetConfigContents = GetNuGetConfig();
-            HashSet<string> manifestsInstalled = new();
-            foreach (ITaskItem workload in WorkloadIds)
-            {
-                InstallWorkloadRequest req = new(workload, new TaskItem());
-                if (manifestsInstalled.Contains(req.ManifestName))
-                {
-                    Log.LogMessage(MessageImportance.High, $"{Environment.NewLine}** Manifests for workload {req.WorkloadId} are already installed **{Environment.NewLine}");
-                    continue;
-                }
-                if (string.IsNullOrEmpty(req.Version))
-                {
-                    Log.LogError($"No Version set for workload manifest {req.ManifestName} in workload install requests.");
-                    return false;
-                }
-                Log.LogMessage(MessageImportance.High, $"{Environment.NewLine}** Installing manifests for workload {req.WorkloadId} **");
-                if (!InstallWorkloadManifest(workload,
-                                             req.ManifestName,
-                                             req.Version,
-                                             SdkWithNoWorkloadInstalledPath,
-                                             nugetConfigContents,
-                                             stopOnMissing: true))
-                {
-                    return false;
-                }
-                manifestsInstalled.Add(req.ManifestName);
-            }
-            File.WriteAllText(AllManifestsStampPath, string.Empty);
-            return true;
-        }
-        private bool InstallPacks(InstallWorkloadRequest req, string nugetConfigContents)
-        {
-            string nugetConfigPath = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
-            File.WriteAllText(nugetConfigPath, nugetConfigContents);
-            (int exitCode, string output) = Utils.TryRunProcess(
-                                                    Log,
-                                                    Path.Combine(req.TargetPath, "dotnet"),
-                                                    $"workload install --skip-sign-check --skip-manifest-update --no-cache --configfile \"{nugetConfigPath}\" {req.WorkloadId}",
-                                                    workingDir: Path.GetTempPath(),
-                                                    silent: false,
-                                                    logStdErrAsMessage: req.IgnoreErrors,
-                                                    debugMessageImportance: MessageImportance.High);
-            if (exitCode != 0)
-            {
-                if (req.IgnoreErrors)
-                {
-                    Log.LogMessage(MessageImportance.High,
-                                    $"{Environment.NewLine} ** Ignoring workload installation failure exit code {exitCode}. **{Environment.NewLine}");
-                }
-                else
-                {
-                    Log.LogError($"workload install failed with exit code {exitCode}: {output}");
-                }
-                foreach (string dir in Directory.EnumerateDirectories(Path.Combine(req.TargetPath, "sdk-manifests"), "*", SearchOption.AllDirectories))
-                    Log.LogMessage(MessageImportance.Low, $"\t{Path.Combine(req.TargetPath, "sdk-manifests", dir)}");
-                foreach (string dir in Directory.EnumerateDirectories(Path.Combine(req.TargetPath, "packs"), "*", SearchOption.AllDirectories))
-                    Log.LogMessage(MessageImportance.Low, $"\t{Path.Combine(req.TargetPath, "packs", dir)}");
-            }
-            return !Log.HasLoggedErrors;
-        }
-        private void UpdateAppRef(string sdkPath, string version)
-        {
-            Log.LogMessage(MessageImportance.High, $"{Environment.NewLine}** Updating Targeting pack **{Environment.NewLine}");
-            string pkgPath = Path.Combine(LocalNuGetsPath, $"Microsoft.NETCore.App.Ref.{version}.nupkg");
-            if (!File.Exists(pkgPath))
-                throw new LogAsErrorException($"Could not find {pkgPath} needed to update the targeting pack to the newly built one." +
-                                                " Make sure to build the subset `packs`, like `./build.sh -os browser -s mono+libs+packs`.");
-            string packDir = Path.Combine(sdkPath, "packs", "Microsoft.NETCore.App.Ref");
-            string[] dirs = Directory.EnumerateDirectories(packDir).ToArray();
-            if (dirs.Length != 1)
-                throw new LogAsErrorException($"Expected to find exactly one versioned directory under {packDir}, but got " +
-                                                string.Join(',', dirs));
-            string dstDir = dirs[0];
-            Directory.Delete(dstDir, recursive: true);
-            Log.LogMessage($"Deleting {dstDir}");
-            Directory.CreateDirectory(dstDir);
-            ZipFile.ExtractToDirectory(pkgPath, dstDir);
-            Log.LogMessage($"Extracting {pkgPath} to {dstDir}");
-        }
-        private string GetNuGetConfig()
-        {
-            string contents = File.ReadAllText(TemplateNuGetConfigPath);
-            if (contents.IndexOf(s_nugetInsertionTag, StringComparison.InvariantCultureIgnoreCase) < 0)
-                throw new LogAsErrorException($"Could not find {s_nugetInsertionTag} in {TemplateNuGetConfigPath}");
-            return contents.Replace(s_nugetInsertionTag, $@"<add key=""nuget-local"" value=""{LocalNuGetsPath}"" />");
-        }
-        private bool InstallWorkloadManifest(ITaskItem workloadId, string name, string version, string sdkDir, string nugetConfigContents, bool stopOnMissing)
-        {
-            Log.LogMessage(MessageImportance.High, $"    ** Installing manifest: {name}/{version}");
-            string outputDir = FindSubDirIgnoringCase(Path.Combine(sdkDir, "sdk-manifests", VersionBand), name);
-            PackageReference pkgRef = new(Name: $"{name}.Manifest-{VersionBand}",
-                                          Version: version,
-                                          OutputDir: outputDir,
-                                          relativeSourceDir: "data");
-            if (!PackageInstaller.Install(new[] { pkgRef }, nugetConfigContents, Log, stopOnMissing))
-                return false;
-            string manifestDir = pkgRef.OutputDir;
-            string jsonPath = Path.Combine(manifestDir, "WorkloadManifest.json");
-            if (!File.Exists(jsonPath))
-            {
-                Log.LogError($"Could not find WorkloadManifest.json at {jsonPath}");
-                return false;
-            }
-            ManifestInformation? manifest;
-            try
-            {
-                manifest = JsonSerializer.Deserialize<ManifestInformation>(
-                                                    File.ReadAllBytes(jsonPath),
-                                                    new JsonSerializerOptions(JsonSerializerDefaults.Web)
-                                                    {
-                                                        AllowTrailingCommas = true,
-                                                        ReadCommentHandling = JsonCommentHandling.Skip
-                                                    });
-                if (manifest == null)
-                {
-                    Log.LogError($"Could not parse manifest from {jsonPath}.");
-                    return false;
-                }
-            }
-            catch (JsonException je)
-            {
-                Log.LogError($"Failed to read from {jsonPath}: {je.Message}");
-                return false;
-            }
-            if (manifest.DependsOn != null)
-            {
-                foreach ((string depName, string depVersion) in manifest.DependsOn)
-                {
-                    if (!InstallWorkloadManifest(workloadId, depName, depVersion, sdkDir, nugetConfigContents, stopOnMissing: false))
-                    {
-                        Log.LogWarning($"Could not install manifest {depName}/{depVersion}. This can be ignored if the workload {workloadId.ItemSpec} doesn't depend on it.");
-                        continue;
-                    }
-                }
-            }
-            return true;
-        }
-        private static bool HasMetadata(ITaskItem item, string itemName, string metadataName, TaskLoggingHelper log)
-        {
-            if (!string.IsNullOrEmpty(item.GetMetadata(metadataName)))
-                return true;
-            log.LogError($"{itemName} item ({item.ItemSpec}) is missing {metadataName} metadata");
-            return false;
-        }
-        private string FindSubDirIgnoringCase(string parentDir, string dirName)
-        {
-            string[] matchingDirs = Directory.EnumerateDirectories(parentDir,
-                                                            dirName,
-                                                            new EnumerationOptions { MatchCasing = MatchCasing.CaseInsensitive })
-                                                .ToArray();
-            string? first = matchingDirs.FirstOrDefault();
-            if (matchingDirs.Length > 1)
-            {
-                Log.LogWarning($"Found multiple directories with names that differ only in case. {string.Join(", ", matchingDirs)}"
-                                + $"{Environment.NewLine}Using the first one: {first}");
-            }
-            return first ?? Path.Combine(parentDir, dirName.ToLower(CultureInfo.InvariantCulture));
-        }
-        private static bool AnyInputsNewerThanOutput(string output, IEnumerable<string> inputs)
-            => inputs.Any(i => Utils.IsNewerThan(i, output));
-        private sealed record ManifestInformation(
-            object Version,
-            string Description,
-            [property: JsonPropertyName("depends-on")]
-            IDictionary<string, string> DependsOn,
-            IDictionary<string, WorkloadInformation> Workloads,
-            IDictionary<string, PackVersionInformation> Packs,
-            object Data
-        );
-        private sealed record WorkloadInformation(
-            bool Abstract,
-            string Kind,
-            string Description,
-            List<string> Packs,
-            List<string> Extends,
-            List<string> Platforms
-        );
-        private sealed record PackVersionInformation(
-            string Kind,
-            string Version,
-            [property: JsonPropertyName("alias-to")]
-            Dictionary<string, string> AliasTo
-        );
-        internal sealed record InstallWorkloadRequest(
-            ITaskItem Workload,
-            ITaskItem Target)
-        {
-            public string ManifestName => Workload.GetMetadata("ManifestName");
-            public string Version => Workload.GetMetadata("Version");
-            public string TargetPath => Target.GetMetadata("InstallPath");
-            public string StampPath => Target.GetMetadata("StampPath");
-            public bool IgnoreErrors => Workload.GetMetadata("IgnoreErrors").ToLowerInvariant() == "true";
-            public string WorkloadId => Workload.ItemSpec;
-            public bool Validate(TaskLoggingHelper log)
-            {
-                if (!HasMetadata(Workload, nameof(Workload), "Version", log) ||
-                    !HasMetadata(Workload, nameof(Workload), "ManifestName", log) ||
-                    !HasMetadata(Target, nameof(Target), "InstallPath", log))
-                {
-                    return false;
-                }
-                if (string.IsNullOrEmpty(TargetPath))
-                {
-                    log.LogError($"InstallPath is empty for workload {Workload.ItemSpec}");
-                    return false;
-                }
-                return true;
-            }
-        }
-    }
-    internal sealed record PackageReference(string Name,
-                                     string Version,
-                                     string OutputDir,
-                                     string relativeSourceDir = "");
-}
