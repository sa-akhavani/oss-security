# ====================================================================
# FILE: eng/install-native-dependencies.sh
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-31 ---
     1| set -e
     2| os="$(echo "$1" | tr "[:upper:]" "[:lower:]")"
     3| if [ -z "$os" ]; then
     4|     . "$(dirname "$0")"/native/init-os-and-arch.sh
     5|     os="$(echo "$os" | tr "[:upper:]" "[:lower:]")"
     6| fi
     7| case "$os" in
     8|     linux)
     9|         if [ -e /etc/os-release ]; then
    10|             . /etc/os-release
    11|         fi
    12|         if [ "$ID" != "debian" ] && [ "$ID_LIKE" != "debian" ]; then
    13|             echo "Unsupported distro. distro: $ID"
    14|             exit 1
    15|         fi
    16|         apt update
    17|         apt install -y build-essential gettext locales cmake llvm clang lldb liblldb-dev libunwind8-dev libicu-dev liblttng-ust-dev \
    18|             libssl-dev libkrb5-dev libnuma-dev zlib1g-dev
    19|         localedef -i en_US -c -f UTF-8 -A /usr/share/locale/locale.alias en_US.UTF-8
    20|         ;;
    21|     osx|mac*|ios*|tvos*)
    22|         echo "Installed xcode version: $(xcode-select -p)"
    23|         export HOMEBREW_NO_INSTALL_CLEANUP=1
    24|         export HOMEBREW_NO_INSTALLED_DEPENDENTS_CHECK=1
    25|         brew bundle --no-upgrade --no-lock --file "$(dirname "$0")/Brewfile"
    26|         ;;
    27|     *)
    28|         echo "Unsupported platform. OS: $os"
    29|         exit 1
    30|         ;;
    31| esac


# ====================================================================
# FILE: src/coreclr/debug/createdump/crashinfo.cpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-708 ---
     1| #include "createdump.h"
     2| #include <clrconfignocache.h>
     3| CrashInfo* g_crashInfo;
     4| static bool ModuleInfoCompare(const ModuleInfo* lhs, const ModuleInfo* rhs) { return lhs->BaseAddress() < rhs->BaseAddress(); }
     5| CrashInfo::CrashInfo(const CreateDumpOptions& options) :
     6|     m_ref(1),
     7|     m_pid(options.Pid),
     8|     m_ppid(-1),
     9|     m_hdac(nullptr),
    10|     m_pClrDataEnumRegions(nullptr),
    11|     m_pClrDataProcess(nullptr),
    12|     m_gatherFrames(options.CrashReport),
    13|     m_crashThread(options.CrashThread),
    14|     m_signal(options.Signal),
    15|     m_moduleInfos(&ModuleInfoCompare),
    16|     m_mainModule(nullptr),
    17|     m_cbModuleMappings(0),
    18|     m_dataTargetPagesAdded(0),
    19|     m_enumMemoryPagesAdded(0)
    20| {
    21|     g_crashInfo = this;
    22| #ifdef __APPLE__
    23|     m_task = 0;
    24| #else
    25|     m_auxvValues.fill(0);
    26|     m_fd = -1;
    27|     memset(&m_siginfo, 0, sizeof(m_siginfo));
    28|     m_siginfo.si_signo = options.Signal;
    29|     m_siginfo.si_code = options.SignalCode;
    30|     m_siginfo.si_errno = options.SignalErrno;
    31|     m_siginfo.si_addr = options.SignalAddress;
    32| #endif
    33| }
    34| CrashInfo::~CrashInfo()
    35| {
    36|     for (ThreadInfo* thread : m_threads)
    37|     {
    38|         delete thread;
    39|     }
    40|     m_threads.clear();
    41|     for (ModuleInfo* module : m_moduleInfos)
    42|     {
    43|         delete module;
    44|     }
    45|     m_moduleInfos.clear();
    46|     if (m_pClrDataEnumRegions != nullptr)
    47|     {
    48|         m_pClrDataEnumRegions->Release();
    49|     }
    50|     if (m_pClrDataProcess != nullptr)
    51|     {
    52|         m_pClrDataProcess->Release();
    53|     }
    54|     if (m_hdac != nullptr)
    55|     {
    56|         FreeLibrary(m_hdac);
    57|         m_hdac = nullptr;
    58|     }
    59| #ifdef __APPLE__
    60|     if (m_task != 0)
    61|     {
    62|         kern_return_t result = ::mach_port_deallocate(mach_task_self(), m_task);
    63|         if (result != KERN_SUCCESS)
    64|         {
    65|             printf_error("Internal error: mach_port_deallocate FAILED %s (%x)\n", mach_error_string(result), result);
    66|         }
    67|     }
    68| #endif
    69| }
    70| STDMETHODIMP
    71| CrashInfo::QueryInterface(
    72|     ___in REFIID InterfaceId,
    73|     ___out PVOID* Interface)
    74| {
    75|     if (InterfaceId == IID_IUnknown ||
    76|         InterfaceId == IID_ICLRDataEnumMemoryRegionsCallback)
    77|     {
    78|         *Interface = (ICLRDataEnumMemoryRegionsCallback*)this;
    79|         AddRef();
    80|         return S_OK;
    81|     }
    82|     else if (InterfaceId == IID_ICLRDataLoggingCallback)
    83|     {
    84|         *Interface = (ICLRDataLoggingCallback*)this;
    85|         AddRef();
    86|         return S_OK;
    87|     }
    88|     else
    89|     {
    90|         *Interface = nullptr;
    91|         return E_NOINTERFACE;
    92|     }
    93| }
    94| STDMETHODIMP_(ULONG)
    95| CrashInfo::AddRef()
    96| {
    97|     LONG ref = InterlockedIncrement(&m_ref);
    98|     return ref;
    99| }
   100| STDMETHODIMP_(ULONG)
   101| CrashInfo::Release()
   102| {
   103|     LONG ref = InterlockedDecrement(&m_ref);
   104|     if (ref == 0)
   105|     {
   106|         delete this;
   107|     }
   108|     return ref;
   109| }
   110| HRESULT STDMETHODCALLTYPE
   111| CrashInfo::EnumMemoryRegion(
   112|     /* [in] */ CLRDATA_ADDRESS address,
   113|     /* [in] */ ULONG32 size)
   114| {
   115|     m_enumMemoryPagesAdded += InsertMemoryRegion((ULONG_PTR)address, size);
   116|     return S_OK;
   117| }
   118| HRESULT STDMETHODCALLTYPE
   119| CrashInfo::LogMessage(
   120|     /* [in] */ LPCSTR message)
   121| {
   122|     Trace("%s", message);
   123|     return S_OK;
   124| }
   125| bool
   126| CrashInfo::GatherCrashInfo(MINIDUMP_TYPE minidumpType)
   127| {
   128|     for (ThreadInfo* thread : m_threads)
   129|     {
   130|         if (!thread->Initialize())
   131|         {
   132|             return false;
   133|         }
   134|     }
   135| #ifdef __APPLE__
   136|     if (!EnumerateMemoryRegions())
   137|     {
   138|         return false;
   139|     }
   140| #else
   141|     if (!GetAuxvEntries())
   142|     {
   143|         return false;
   144|     }
   145|     if (!EnumerateMemoryRegions())
   146|     {
   147|         return false;
   148|     }
   149|     if (!GetDSOInfo())
   150|     {
   151|         return false;
   152|     }
   153| #endif
   154|     if (!InitializeDAC())
   155|     {
   156|         return false;
   157|     }
   158|     if (!EnumerateManagedModules())
   159|     {
   160|         return false;
   161|     }
   162| #ifdef __APPLE__
   163|     InitializeOtherMappings();
   164| #endif
   165|     if (!UnwindAllThreads())
   166|     {
   167|         return false;
   168|     }
   169|     if (g_diagnosticsVerbose)
   170|     {
   171|         TRACE("Module addresses:\n");
   172|         for (const MemoryRegion& region : m_moduleAddresses)
   173|         {
   174|             region.Trace();
   175|         }
   176|     }
   177|     if (minidumpType & MiniDumpWithFullMemory)
   178|     {
   179|         for (const MemoryRegion& region : m_moduleMappings)
   180|         {
   181|             InsertMemoryRegion(region);
   182|         }
   183|         for (const MemoryRegion& region : m_otherMappings)
   184|         {
   185|             if ((region.Permissions() & (PF_R | PF_W | PF_X)) != 0)
   186|             {
   187|                 InsertMemoryRegion(region);
   188|             }
   189|         }
   190|     }
   191|     else
   192|     {
   193|         if (minidumpType & MiniDumpWithPrivateReadWriteMemory)
   194|         {
   195|             for (const MemoryRegion& region : m_otherMappings)
   196|             {
   197|                 uint32_t permissions = region.Permissions();
   198| #ifdef __APPLE__
   199|                 if (permissions == (PF_R | PF_W))
   200| #else
   201|                 if (permissions == (PF_R | PF_W) || permissions == (PF_R | PF_W | PF_X))
   202| #endif
   203|                 {
   204|                     InsertMemoryRegion(region);
   205|                 }
   206|             }
   207|         }
   208|         for (ThreadInfo* thread : m_threads)
   209|         {
   210|             thread->GetThreadStack();
   211|         }
   212|     }
   213|     return true;
   214| }
   215| static const char*
   216| GetHResultString(HRESULT hr)
   217| {
   218|     switch (hr)
   219|     {
   220|         case E_FAIL:
   221|             return "The operation has failed";
   222|         case E_INVALIDARG:
   223|             return "Invalid argument";
   224|         case E_OUTOFMEMORY:
   225|             return "Out of memory";
   226|         case CORDBG_E_INCOMPATIBLE_PLATFORMS:
   227|             return "The operation failed because debuggee and debugger are on incompatible platforms";
   228|         case CORDBG_E_MISSING_DEBUGGER_EXPORTS:
   229|             return "The debuggee memory space does not have the expected debugging export table";
   230|         case CORDBG_E_UNSUPPORTED:
   231|             return "The specified action is unsupported by this version of the runtime";
   232|     }
   233|     return "";
   234| }
   235| bool
   236| CrashInfo::InitializeDAC()
   237| {
   238|     ReleaseHolder<DumpDataTarget> dataTarget = new DumpDataTarget(*this);
   239|     PFN_CLRDataCreateInstance pfnCLRDataCreateInstance = nullptr;
   240|     bool result = false;
   241|     HRESULT hr = S_OK;
   242|     if (!m_coreclrPath.empty())
   243|     {
   244|         std::string dacPath;
   245|         dacPath.append(m_coreclrPath);
   246|         dacPath.append(MAKEDLLNAME_A("mscordaccore"));
   247|         m_hdac = LoadLibraryA(dacPath.c_str());
   248|         if (m_hdac == nullptr)
   249|         {
   250|             printf_error("InitializeDAC: LoadLibraryA(%s) FAILED %s\n", dacPath.c_str(), GetLastErrorString().c_str());
   251|             goto exit;
   252|         }
   253|         pfnCLRDataCreateInstance = (PFN_CLRDataCreateInstance)GetProcAddress(m_hdac, "CLRDataCreateInstance");
   254|         if (pfnCLRDataCreateInstance == nullptr)
   255|         {
   256|             printf_error("InitializeDAC: GetProcAddress(CLRDataCreateInstance) FAILED %s\n", GetLastErrorString().c_str());
   257|             goto exit;
   258|         }
   259|         hr = pfnCLRDataCreateInstance(__uuidof(ICLRDataEnumMemoryRegions), dataTarget, (void**)&m_pClrDataEnumRegions);
   260|         if (FAILED(hr))
   261|         {
   262|             printf_error("InitializeDAC: CLRDataCreateInstance(ICLRDataEnumMemoryRegions) FAILED %s (%08x)\n", GetHResultString(hr), hr);
   263|             goto exit;
   264|         }
   265|         hr = pfnCLRDataCreateInstance(__uuidof(IXCLRDataProcess), dataTarget, (void**)&m_pClrDataProcess);
   266|         if (FAILED(hr))
   267|         {
   268|             printf_error("InitializeDAC: CLRDataCreateInstance(IXCLRDataProcess) FAILED %s (%08x)\n", GetHResultString(hr), hr);
   269|             goto exit;
   270|         }
   271|     }
   272|     else
   273|     {
   274|         printf_error("InitializeDAC: coreclr not found; not using DAC\n");
   275|     }
   276|     result = true;
   277| exit:
   278|     return result;
   279| }
   280| bool
   281| CrashInfo::EnumerateMemoryRegionsWithDAC(MINIDUMP_TYPE minidumpType)
   282| {
   283|     if (m_pClrDataEnumRegions != nullptr && (minidumpType & MiniDumpWithFullMemory) == 0)
   284|     {
   285|         TRACE("EnumerateMemoryRegionsWithDAC: Memory enumeration STARTED (%d %d)\n", m_enumMemoryPagesAdded, m_dataTargetPagesAdded);
   286|         CLRDataEnumMemoryFlags flags = CLRDATA_ENUM_MEM_DEFAULT;
   287|         if (minidumpType & MiniDumpWithPrivateReadWriteMemory)
   288|         {
   289|             CLRConfigNoCache fastHeapDumps = CLRConfigNoCache::Get("DbgEnableFastHeapDumps", /*noprefix*/ false, &getenv);
   290|             DWORD val = 0;
   291|             if (fastHeapDumps.IsSet() && fastHeapDumps.TryAsInteger(10, val) && val == 1)
   292|             {
   293|                 minidumpType = MiniDumpNormal;
   294|             }
   295|             fastHeapDumps = CLRConfigNoCache::Get("EnableFastHeapDumps", /*noprefix*/ false, &getenv);
   296|             if (fastHeapDumps.IsSet() && fastHeapDumps.TryAsInteger(10, val) && val == 1)
   297|             {
   298|                 flags = CLRDATA_ENUM_MEM_HEAP2;
   299|             }
   300|         }
   301|         HRESULT hr = m_pClrDataEnumRegions->EnumMemoryRegions(this, minidumpType, flags);
   302|         if (FAILED(hr))
   303|         {
   304|             printf_error("EnumMemoryRegions FAILED %s (%08x)\n", GetHResultString(hr), hr);
   305|             return false;
   306|         }
   307|         TRACE("EnumerateMemoryRegionsWithDAC: Memory enumeration FINISHED (%d %d)\n", m_enumMemoryPagesAdded, m_dataTargetPagesAdded);
   308|     }
   309|     return true;
   310| }
   311| bool
   312| CrashInfo::EnumerateManagedModules()
   313| {
   314|     CLRDATA_ENUM enumModules = 0;
   315|     HRESULT hr = S_OK;
   316|     if (m_pClrDataProcess != nullptr)
   317|     {
   318|         TRACE("EnumerateManagedModules: Module enumeration STARTED (%d)\n", m_dataTargetPagesAdded);
   319|         if (FAILED(hr = m_pClrDataProcess->StartEnumModules(&enumModules))) {
   320|             printf_error("StartEnumModules FAILED %s (%08x)\n", GetHResultString(hr), hr);
   321|             return false;
   322|         }
   323|         while (true)
   324|         {
   325|             ReleaseHolder<IXCLRDataModule> pClrDataModule;
   326|             if ((hr = m_pClrDataProcess->EnumModule(&enumModules, &pClrDataModule)) != S_OK) {
   327|                 break;
   328|             }
   329|             ULONG32 flags;
   330|             if ((hr = pClrDataModule->GetFlags(&flags)) != S_OK) {
   331|                 TRACE("MODULE: GetFlags FAILED %08x\n", hr);
   332|                 continue;
   333|             }
   334|             if (flags & CLRDATA_MODULE_IS_DYNAMIC) {
   335|                 TRACE("MODULE: Skipping dynamic module\n");
   336|                 continue;
   337|             }
   338|             DacpGetModuleData moduleData;
   339|             if (SUCCEEDED(hr = moduleData.Request(pClrDataModule.GetPtr())))
   340|             {
   341|                 TRACE("MODULE: %" PRIA PRIx64 " dyn %d inmem %d file %d pe %" PRIA PRIx64 " pdb %" PRIA PRIx64, (uint64_t)moduleData.LoadedPEAddress, moduleData.IsDynamic,
   342|                     moduleData.IsInMemory, moduleData.IsFileLayout, (uint64_t)moduleData.PEAssembly, (uint64_t)moduleData.InMemoryPdbAddress);
   343|                 if (!moduleData.IsDynamic && moduleData.LoadedPEAddress != 0)
   344|                 {
   345|                     ArrayHolder<WCHAR> wszUnicodeName = new WCHAR[MAX_LONGPATH + 1];
   346|                     if (SUCCEEDED(hr = pClrDataModule->GetFileName(MAX_LONGPATH, nullptr, wszUnicodeName)))
   347|                     {
   348|                         std::string moduleName = FormatString("%S", wszUnicodeName.GetPtr());
   349|                         AddOrReplaceModuleMapping(moduleData.LoadedPEAddress, moduleData.LoadedPESize, moduleName);
   350|                         AddModuleInfo(true, moduleData.LoadedPEAddress, pClrDataModule, moduleName);
   351|                     }
   352|                     else {
   353|                         TRACE("\nModule.GetFileName FAILED %08x\n", hr);
   354|                     }
   355|                 }
   356|                 else {
   357|                     TRACE("\n");
   358|                 }
   359|             }
   360|             else {
   361|                 TRACE("moduleData.Request FAILED %08x\n", hr);
   362|             }
   363|         }
   364|         if (enumModules != 0) {
   365|             m_pClrDataProcess->EndEnumModules(enumModules);
   366|         }
   367|         TRACE("EnumerateManagedModules: Module enumeration FINISHED (%d) ModuleMappings %06llx\n", m_dataTargetPagesAdded, m_cbModuleMappings / PAGE_SIZE);
   368|     }
   369|     return true;
   370| }
   371| bool
   372| CrashInfo::UnwindAllThreads()
   373| {
   374|     TRACE("UnwindAllThreads: STARTED (%d)\n", m_dataTargetPagesAdded);
   375|     ReleaseHolder<ISOSDacInterface> pSos = nullptr;
   376|     if (m_pClrDataProcess != nullptr) {
   377|         m_pClrDataProcess->QueryInterface(__uuidof(ISOSDacInterface), (void**)&pSos);
   378|     }
   379|     for (ThreadInfo* thread : m_threads)
   380|     {
   381|         if (!thread->UnwindThread(m_pClrDataProcess, pSos)) {
   382|             return false;
   383|         }
   384|     }
   385|     TRACE("UnwindAllThreads: FINISHED (%d)\n", m_dataTargetPagesAdded);
   386|     return true;
   387| }
   388| void
   389| CrashInfo::AddOrReplaceModuleMapping(CLRDATA_ADDRESS baseAddress, ULONG64 size, const std::string& name)
   390| {
   391|     ULONG_PTR start = ((ULONG_PTR)baseAddress) & PAGE_MASK;
   392|     assert(start > 0);
   393|     ULONG_PTR end = ((baseAddress + size) + (PAGE_SIZE - 1)) & PAGE_MASK;
   394|     assert(end > 0);
   395|     uint32_t flags = GetMemoryRegionFlags((ULONG_PTR)baseAddress);
   396|     MemoryRegion header(flags, start, start + PAGE_SIZE);
   397|     InsertMemoryRegion(header);
   398|     const auto& found = m_moduleMappings.find(header);
   399|     if (found == m_moduleMappings.end())
   400|     {
   401|         MemoryRegion newRegion(flags, start, end, 0, name);
   402|         m_moduleMappings.insert(newRegion);
   403|         m_cbModuleMappings += newRegion.Size();
   404|         if (g_diagnostics) {
   405|             newRegion.Trace("MODULE: ADD ");
   406|         }
   407|     }
   408|     else if (found->FileName().compare(name) != 0)
   409|     {
   410|         MemoryRegion newRegion(*found, name);
   411|         m_moduleMappings.erase(found);
   412|         m_cbModuleMappings -= found->Size();
   413|         m_moduleMappings.insert(newRegion);
   414|         m_cbModuleMappings += newRegion.Size();
   415|         if (g_diagnostics) {
   416|             newRegion.Trace("MODULE: REPLACE ");
   417|         }
   418|     }
   419| }
   420| uint64_t
   421| CrashInfo::GetBaseAddressFromAddress(uint64_t address)
   422| {
   423|     MemoryRegion search(0, address, address, 0);
   424|     const MemoryRegion* found = SearchMemoryRegions(m_moduleAddresses, search);
   425|     if (found == nullptr) {
   426|         return 0;
   427|     }
   428|     return found->Offset();
   429| }
   430| uint64_t
   431| CrashInfo::GetBaseAddressFromName(const char* moduleName)
   432| {
   433|     for (const ModuleInfo* moduleInfo : m_moduleInfos)
   434|     {
   435|         std::string name = GetFileName(moduleInfo->ModuleName());
   436| #ifdef __APPLE__
   437|         if (strcasecmp(name.c_str(), moduleName) == 0)
   438| #else
   439|         if (name.compare(moduleName) == 0)
   440| #endif
   441|         {
   442|             return moduleInfo->BaseAddress();
   443|         }
   444|     }
   445|     return 0;
   446| }
   447| ModuleInfo*
   448| CrashInfo::GetModuleInfoFromBaseAddress(uint64_t baseAddress)
   449| {
   450|     ModuleInfo search(baseAddress);
   451|     const auto& found = m_moduleInfos.find(&search);
   452|     if (found != m_moduleInfos.end())
   453|     {
   454|         return *found;
   455|     }
   456|     return nullptr;
   457| }
   458| void
   459| CrashInfo::AddModuleAddressRange(uint64_t startAddress, uint64_t endAddress, uint64_t baseAddress)
   460| {
   461|     MemoryRegion region(0, startAddress, endAddress, baseAddress);
   462|     m_moduleAddresses.insert(region);
   463| }
   464| void
   465| CrashInfo::AddModuleInfo(bool isManaged, uint64_t baseAddress, IXCLRDataModule* pClrDataModule, const std::string& moduleName)
   466| {
   467|     ModuleInfo moduleInfo(baseAddress);
   468|     const auto& found = m_moduleInfos.find(&moduleInfo);
   469|     if (found == m_moduleInfos.end())
   470|     {
   471|         uint32_t timeStamp = 0;
   472|         uint32_t imageSize = 0;
   473|         bool isMainModule = false;
   474|         GUID mvid;
   475|         if (isManaged)
   476|         {
   477|             IMAGE_DOS_HEADER dosHeader;
   478|             if (ReadMemory((void*)baseAddress, &dosHeader, sizeof(dosHeader)))
   479|             {
   480|                 WORD magic;
   481|                 if (ReadMemory((void*)(baseAddress + dosHeader.e_lfanew + offsetof(IMAGE_NT_HEADERS, OptionalHeader.Magic)), &magic, sizeof(magic)))
   482|                 {
   483|                     if (magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
   484|                     {
   485|                         IMAGE_NT_HEADERS32 header;
   486|                         if (ReadMemory((void*)(baseAddress + dosHeader.e_lfanew), &header, sizeof(header)))
   487|                         {
   488|                             imageSize = header.OptionalHeader.SizeOfImage;
   489|                             timeStamp = header.FileHeader.TimeDateStamp;
   490|                         }
   491|                     }
   492|                     else if (magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
   493|                     {
   494|                         IMAGE_NT_HEADERS64 header;
   495|                         if (ReadMemory((void*)(baseAddress + dosHeader.e_lfanew), &header, sizeof(header)))
   496|                         {
   497|                             imageSize = header.OptionalHeader.SizeOfImage;
   498|                             timeStamp = header.FileHeader.TimeDateStamp;
   499|                         }
   500|                     }
   501|                 }
   502|             }
   503|             if (pClrDataModule != nullptr)
   504|             {
   505|                 ULONG32 flags = 0;
   506|                 pClrDataModule->GetFlags(&flags);
   507|                 isMainModule = (flags & CLRDATA_MODULE_IS_MAIN_MODULE) != 0;
   508|                 pClrDataModule->GetVersionId(&mvid);
   509|             }
   510|             TRACE("MODULE: timestamp %08x size %08x %s %s%s\n", timeStamp, imageSize, FormatGuid(&mvid).c_str(), isMainModule ? "*" : "", moduleName.c_str());
   511|         }
   512|         ModuleInfo* moduleInfo = new ModuleInfo(isManaged, baseAddress, timeStamp, imageSize, &mvid, moduleName);
   513|         if (isMainModule) {
   514|             m_mainModule = moduleInfo;
   515|         }
   516|         m_moduleInfos.insert(moduleInfo);
   517|     }
   518| }
   519| bool
   520| CrashInfo::ReadMemory(void* address, void* buffer, size_t size)
   521| {
   522|     size_t read = 0;
   523|     if (!ReadProcessMemory(address, buffer, size, &read))
   524|     {
   525|         return false;
   526|     }
   527|     assert(read == size);
   528|     InsertMemoryRegion(reinterpret_cast<uint64_t>(address), read);
   529|     return true;
   530| }
   531| int
   532| CrashInfo::InsertMemoryRegion(uint64_t address, size_t size)
   533| {
   534|     assert(size < UINT_MAX);
   535|     uint64_t start = address & PAGE_MASK;
   536|     assert(start > 0);
   537|     uint64_t end = ((address + size) + (PAGE_SIZE - 1)) & PAGE_MASK;
   538|     assert(end > 0);
   539|     return InsertMemoryRegion(MemoryRegion(GetMemoryRegionFlags(start), start, end));
   540| }
   541| int
   542| CrashInfo::InsertMemoryRegion(const MemoryRegion& region)
   543| {
   544|     const auto& found = m_memoryRegions.find(region);
   545|     if (found == m_memoryRegions.end())
   546|     {
   547|         if (ValidRegion(region))
   548|         {
   549|             m_memoryRegions.insert(region);
   550|             return region.SizeInPages();
   551|         }
   552|     }
   553|     else
   554|     {
   555|         if (found->Contains(region))
   556|         {
   557|             return 0;
   558|         }
   559|     }
   560|     uint64_t start = region.StartAddress();
   561|     uint64_t numberPages = region.SizeInPages();
   562|     int pagesAdded = 0;
   563|     for (size_t p = 0; p < numberPages; p++, start += PAGE_SIZE)
   564|     {
   565|         MemoryRegion memoryRegionPage(region.Flags(), start, start + PAGE_SIZE);
   566|         const auto& found = m_memoryRegions.find(memoryRegionPage);
   567|         if (found == m_memoryRegions.end())
   568|         {
   569|             if (ValidRegion(memoryRegionPage))
   570|             {
   571|                 m_memoryRegions.insert(memoryRegionPage);
   572|                 pagesAdded++;
   573|             }
   574|         }
   575|     }
   576|     return pagesAdded;
   577| }
   578| bool
   579| CrashInfo::ValidRegion(const MemoryRegion& region)
   580| {
   581|     uint64_t start = region.StartAddress();
   582|     uint64_t numberPages = region.SizeInPages();
   583|     for (size_t p = 0; p < numberPages; p++, start += PAGE_SIZE)
   584|     {
   585|         BYTE buffer[1];
   586|         size_t read;
   587|         if (!ReadProcessMemory((void*)start, buffer, 1, &read))
   588|         {
   589|             return false;
   590|         }
   591|     }
   592|     return true;
   593| }
   594| void
   595| CrashInfo::CombineMemoryRegions()
   596| {
   597|     TRACE("CombineMemoryRegions: STARTED\n");
   598|     assert(!m_memoryRegions.empty());
   599|     std::set<MemoryRegion> memoryRegionsNew;
   600|     uint32_t flags = m_memoryRegions.begin()->Flags() & MEMORY_REGION_FLAG_PERMISSIONS_MASK;
   601|     uint64_t start = m_memoryRegions.begin()->StartAddress();
   602|     uint64_t end = start;
   603|     for (const MemoryRegion& region : m_memoryRegions)
   604|     {
   605|         if ((end == region.StartAddress()) &&
   606|             (flags == (region.Flags() & MEMORY_REGION_FLAG_PERMISSIONS_MASK)))
   607|         {
   608|             end = region.EndAddress();
   609|         }
   610|         else
   611|         {
   612|             MemoryRegion memoryRegion(flags, start, end);
   613|             assert(memoryRegionsNew.find(memoryRegion) == memoryRegionsNew.end());
   614|             memoryRegionsNew.insert(memoryRegion);
   615|             flags = region.Flags() & MEMORY_REGION_FLAG_PERMISSIONS_MASK;
   616|             start = region.StartAddress();
   617|             end = region.EndAddress();
   618|         }
   619|     }
   620|     assert(start != end);
   621|     MemoryRegion memoryRegion(flags, start, end);
   622|     assert(memoryRegionsNew.find(memoryRegion) == memoryRegionsNew.end());
   623|     memoryRegionsNew.insert(memoryRegion);
   624|     m_memoryRegions = memoryRegionsNew;
   625|     TRACE("CombineMemoryRegions: FINISHED\n");
   626|     if (g_diagnosticsVerbose)
   627|     {
   628|         TRACE("Final Memory Regions:\n");
   629|         for (const MemoryRegion& region : m_memoryRegions)
   630|         {
   631|             region.Trace();
   632|         }
   633|     }
   634| }
   635| const MemoryRegion*
   636| CrashInfo::SearchMemoryRegions(const std::set<MemoryRegion>& regions, const MemoryRegion& search)
   637| {
   638|     std::set<MemoryRegion>::iterator found = regions.find(search);
   639|     for (; found != regions.end(); found++)
   640|     {
   641|         if (search.StartAddress() >= found->StartAddress() && search.StartAddress() < found->EndAddress())
   642|         {
   643|             return &*found;
   644|         }
   645|     }
   646|     return nullptr;
   647| }
   648| const char*
   649| ModuleInfo::GetSymbolName(uint64_t address)
   650| {
   651|     LoadModule();
   652|     if (m_localBaseAddress != 0)
   653|     {
   654|         uint64_t localAddress = m_localBaseAddress + (address - m_baseAddress);
   655|         Dl_info info;
   656|         if (dladdr((void*)localAddress, &info) != 0)
   657|         {
   658|             if (info.dli_sname != nullptr)
   659|             {
   660|                 int status = -1;
   661|                 char *demangled = abi::__cxa_demangle(info.dli_sname, nullptr, 0, &status);
   662|                 return status == 0 ? demangled : strdup(info.dli_sname);
   663|             }
   664|         }
   665|     }
   666|     return nullptr;
   667| }
   668| const std::string
   669| GetFileName(const std::string& fileName)
   670| {
   671|     size_t last = fileName.rfind(DIRECTORY_SEPARATOR_STR_A);
   672|     if (last != std::string::npos) {
   673|         last++;
   674|     }
   675|     else {
   676|         last = 0;
   677|     }
   678|     return fileName.substr(last);
   679| }
   680| const std::string
   681| GetDirectory(const std::string& fileName)
   682| {
   683|     size_t last = fileName.rfind(DIRECTORY_SEPARATOR_STR_A);
   684|     if (last != std::string::npos) {
   685|         last++;
   686|     }
   687|     else {
   688|         last = 0;
   689|     }
   690|     return fileName.substr(0, last);
   691| }
   692| std::string
   693| FormatString(const char* format, ...)
   694| {
   695|     ArrayHolder<char> buffer = new char[MAX_LONGPATH + 1];
   696|     va_list args;
   697|     va_start(args, format);
   698|     int result = vsprintf_s(buffer, MAX_LONGPATH, format, args);
   699|     va_end(args);
   700|     return result > 0 ? std::string(buffer) : std::string();
   701| }
   702| std::string
   703| FormatGuid(const GUID* guid)
   704| {
   705|     uint8_t* bytes = (uint8_t*)guid;
   706|     return FormatString("%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
   707|         bytes[3], bytes[2], bytes[1], bytes[0], bytes[5], bytes[4], bytes[7], bytes[6], bytes[8], bytes[9], bytes[10], bytes[11], bytes[12], bytes[13], bytes[14], bytes[15]);
   708| }


# ====================================================================
# FILE: src/coreclr/debug/createdump/crashinfo.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-140 ---
     1| #ifdef __APPLE__
     2| #include "../dbgutil/machoreader.h"
     3| #else
     4| #include "../dbgutil/elfreader.h"
     5| #if TARGET_64BIT
     6| typedef Elf64_auxv_t elf_aux_entry;
     7| #define PRIx PRIx64
     8| #define PRIu PRIu64
     9| #define PRId PRId64
    10| #define PRIA "016"
    11| #define PRIxA PRIA PRIx
    12| #else
    13| typedef Elf32_auxv_t elf_aux_entry;
    14| #define PRIx PRIx32
    15| #define PRIu PRIu32
    16| #define PRId PRId32
    17| #define PRIA "08"
    18| #define PRIxA PRIA PRIx
    19| #endif
    20| typedef __typeof__(((elf_aux_entry*) 0)->a_un.a_val) elf_aux_val_t;
    21| #define AT_MAX (AT_SYSINFO_EHDR + 1)
    22| #endif
    23| extern const std::string GetFileName(const std::string& fileName);
    24| extern const std::string GetDirectory(const std::string& fileName);
    25| extern std::string FormatString(const char* format, ...);
    26| extern std::string FormatGuid(const GUID* guid);
    27| class CrashInfo : public ICLRDataEnumMemoryRegionsCallback, public ICLRDataLoggingCallback,
    28| #ifdef __APPLE__
    29|     public MachOReader
    30| #else
    31|     public ElfReader
    32| #endif
    33| {
    34| private:
    35|     LONG m_ref;                                     // reference count
    36|     pid_t m_pid;                                    // pid
    37|     pid_t m_ppid;                                   // parent pid
    38|     pid_t m_tgid;                                   // process group
    39|     HMODULE m_hdac;                                 // dac module handle when loaded
    40|     ICLRDataEnumMemoryRegions* m_pClrDataEnumRegions; // dac enumerate memory interface instance
    41|     IXCLRDataProcess* m_pClrDataProcess;            // dac process interface instance
    42|     bool m_gatherFrames;                            // if true, add the native and managed stack frames to the thread info
    43|     pid_t m_crashThread;                            // crashing thread id or 0 if none
    44|     uint32_t m_signal;                              // crash signal code or 0 if none
    45|     std::string m_name;                             // exe name
    46| #ifdef __APPLE__
    47|     vm_map_t m_task;                                // the mach task for the process
    48| #else
    49|     siginfo_t m_siginfo;                            // signal info (if any)
    50|     bool m_canUseProcVmReadSyscall;
    51|     int m_fd;                                       // /proc/<pid>/mem handle
    52| #endif
    53|     std::string m_coreclrPath;                      // the path of the coreclr module or empty if none
    54|     uint64_t m_runtimeBaseAddress;
    55| #ifdef __APPLE__
    56|     std::set<MemoryRegion> m_allMemoryRegions;      // all memory regions on MacOS
    57| #else
    58|     std::array<elf_aux_val_t, AT_MAX> m_auxvValues; // auxv values
    59|     std::vector<elf_aux_entry> m_auxvEntries;       // full auxv entries
    60| #endif
    61|     std::vector<ThreadInfo*> m_threads;             // threads found and suspended
    62|     std::set<MemoryRegion> m_moduleMappings;        // module memory mappings
    63|     std::set<MemoryRegion> m_otherMappings;         // other memory mappings
    64|     std::set<MemoryRegion> m_memoryRegions;         // memory regions from DAC, etc.
    65|     std::set<MemoryRegion> m_moduleAddresses;       // memory region to module base address
    66|     std::set<ModuleInfo*, bool (*)(const ModuleInfo* lhs, const ModuleInfo* rhs)> m_moduleInfos; // module infos (base address and module name)
    67|     ModuleInfo* m_mainModule;                       // the module containing "Main"
    68|     CrashInfo(const CrashInfo&) = delete;
    69|     void operator=(const CrashInfo&) = delete;
    70| public:
    71|     CrashInfo(const CreateDumpOptions& options);
    72|     virtual ~CrashInfo();
    73|     uint64_t m_cbModuleMappings;
    74|     int m_dataTargetPagesAdded;
    75|     int m_enumMemoryPagesAdded;
    76|     bool Initialize();
    77|     void CleanupAndResumeProcess();
    78|     bool EnumerateAndSuspendThreads();
    79|     bool GatherCrashInfo(MINIDUMP_TYPE minidumpType);
    80|     void CombineMemoryRegions();
    81|     bool EnumerateMemoryRegionsWithDAC(MINIDUMP_TYPE minidumpType);
    82|     bool ReadMemory(void* address, void* buffer, size_t size);                          // read memory and add to dump
    83|     bool ReadProcessMemory(void* address, void* buffer, size_t size, size_t* read);     // read raw memory
    84|     uint64_t GetBaseAddressFromAddress(uint64_t address);
    85|     uint64_t GetBaseAddressFromName(const char* moduleName);
    86|     ModuleInfo* GetModuleInfoFromBaseAddress(uint64_t baseAddress);
    87|     void AddModuleAddressRange(uint64_t startAddress, uint64_t endAddress, uint64_t baseAddress);
    88|     void AddModuleInfo(bool isManaged, uint64_t baseAddress, IXCLRDataModule* pClrDataModule, const std::string& moduleName);
    89|     int InsertMemoryRegion(uint64_t address, size_t size);
    90|     static const MemoryRegion* SearchMemoryRegions(const std::set<MemoryRegion>& regions, const MemoryRegion& search);
    91|     inline pid_t Pid() const { return m_pid; }
    92|     inline pid_t Ppid() const { return m_ppid; }
    93|     inline pid_t Tgid() const { return m_tgid; }
    94| #ifdef __APPLE__
    95|     inline vm_map_t Task() const { return m_task; }
    96| #endif
    97|     inline const bool GatherFrames() const { return m_gatherFrames; }
    98|     inline const pid_t CrashThread() const { return m_crashThread; }
    99|     inline const uint32_t Signal() const { return m_signal; }
   100|     inline const std::string& Name() const { return m_name; }
   101|     inline const ModuleInfo* MainModule() const { return m_mainModule; }
   102|     inline const uint64_t RuntimeBaseAddress() const { return m_runtimeBaseAddress; }
   103|     inline const std::vector<ThreadInfo*>& Threads() const { return m_threads; }
   104|     inline const std::set<MemoryRegion>& ModuleMappings() const { return m_moduleMappings; }
   105|     inline const std::set<MemoryRegion>& OtherMappings() const { return m_otherMappings; }
   106|     inline const std::set<MemoryRegion>& MemoryRegions() const { return m_memoryRegions; }
   107| #ifndef __APPLE__
   108|     inline const std::vector<elf_aux_entry>& AuxvEntries() const { return m_auxvEntries; }
   109|     inline size_t GetAuxvSize() const { return m_auxvEntries.size() * sizeof(elf_aux_entry); }
   110|     inline const siginfo_t* SigInfo() const { return &m_siginfo; }
   111| #endif
   112|     STDMETHOD(QueryInterface)(___in REFIID InterfaceId, ___out PVOID* Interface);
   113|     STDMETHOD_(ULONG, AddRef)();
   114|     STDMETHOD_(ULONG, Release)();
   115|     virtual HRESULT STDMETHODCALLTYPE EnumMemoryRegion(/* [in] */ CLRDATA_ADDRESS address, /* [in] */ ULONG32 size);
   116|     virtual HRESULT STDMETHODCALLTYPE LogMessage( /* [in] */ LPCSTR message);
   117| private:
   118| #ifdef __APPLE__
   119|     bool EnumerateMemoryRegions();
   120|     void InitializeOtherMappings();
   121|     void VisitModule(MachOModule& module);
   122|     void VisitSegment(MachOModule& module, const segment_command_64& segment);
   123|     void VisitSection(MachOModule& module, const section_64& section);
   124| #else
   125|     bool GetAuxvEntries();
   126|     bool GetDSOInfo();
   127|     void VisitModule(uint64_t baseAddress, std::string& moduleName);
   128|     void VisitProgramHeader(uint64_t loadbias, uint64_t baseAddress, ElfW(Phdr)* phdr);
   129|     bool EnumerateMemoryRegions();
   130| #endif
   131|     bool InitializeDAC();
   132|     bool EnumerateManagedModules();
   133|     bool UnwindAllThreads();
   134|     void AddOrReplaceModuleMapping(CLRDATA_ADDRESS baseAddress, ULONG64 size, const std::string& pszName);
   135|     int InsertMemoryRegion(const MemoryRegion& region);
   136|     uint32_t GetMemoryRegionFlags(uint64_t start);
   137|     bool ValidRegion(const MemoryRegion& region);
   138|     void Trace(const char* format, ...);
   139|     void TraceVerbose(const char* format, ...);
   140| };


# ====================================================================
# FILE: src/coreclr/debug/createdump/crashreportwriter.cpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-366 ---
     1| #include "createdump.h"
     2| #include "_version.c"
     3| CrashReportWriter::CrashReportWriter(CrashInfo& crashInfo) :
     4|     m_crashInfo(crashInfo)
     5| {
     6|     m_fd = -1;
     7|     m_indent = JSON_INDENT_VALUE;
     8|     m_comma = false;
     9|     m_crashInfo.AddRef();
    10| }
    11| CrashReportWriter::~CrashReportWriter()
    12| {
    13|     m_crashInfo.Release();
    14|     if (m_fd != -1)
    15|     {
    16|         close(m_fd);
    17|         m_fd = -1;
    18|     }
    19| }
    20| void
    21| CrashReportWriter::WriteCrashReport(const std::string& dumpFileName)
    22| {
    23|     std::string crashReportFile(dumpFileName);
    24|     crashReportFile.append(".crashreport.json");
    25|     printf_status("Writing crash report to file %s\n", crashReportFile.c_str());
    26|     try
    27|     {
    28|         if (!OpenWriter(crashReportFile.c_str())) {
    29|             return;
    30|         }
    31|         WriteCrashReport();
    32|         CloseWriter();
    33|         printf_status("Crash report successfully written\n");
    34|     }
    35|     catch (const std::exception& e)
    36|     {
    37|         printf_error("Writing the crash report file FAILED\n");
    38|         remove(crashReportFile.c_str());
    39|     }
    40| }
    41| void
    42| CrashReportWriter::WriteCrashReport()
    43| {
    44|     OpenObject("payload");
    45|     WriteValue("protocol_version", "1.0.0");
    46|     OpenObject("configuration");
    47| #if defined(__x86_64__)
    48|     WriteValue("architecture", "amd64");
    49| #elif defined(__aarch64__)
    50|     WriteValue("architecture", "arm64");
    51| #elif defined(__arm__)
    52|     WriteValue("architecture", "arm");
    53| #endif
    54|     std::string version;
    55|     assert(strncmp(sccsid, "@(#)Version ", 12) == 0);
    56|     version.append(sccsid + 12);    // skip "@(#)Version "
    57|     version.append(" ");            // the analyzer requires a space after the version
    58|     WriteValue("version", version.c_str());
    59|     CloseObject();                  // configuration
    60|     const ModuleInfo* mainModule = m_crashInfo.MainModule();
    61|     if (mainModule != nullptr && mainModule->BaseAddress() != 0)
    62|     {
    63|         WriteValue("process_name", GetFileName(mainModule->ModuleName()).c_str());
    64|     }
    65|     const char* exceptionType = nullptr;
    66|     OpenArray("threads");
    67|     for (const ThreadInfo* thread : m_crashInfo.Threads())
    68|     {
    69|         OpenObject();
    70|         bool crashed = false;
    71|         if (thread->Tid() == m_crashInfo.CrashThread())
    72|         {
    73|             crashed = true;
    74|             if (thread->ManagedExceptionObject() != 0)
    75|             {
    76|                 exceptionType = "0x05000000";   // ManagedException
    77|             }
    78|             else
    79|             {
    80|                 switch (m_crashInfo.Signal())
    81|                 {
    82|                 case 0:
    83|                     break;
    84|                 case SIGILL:
    85|                     exceptionType = "0x50000000";
    86|                     break;
    87|                 case SIGFPE:
    88|                     exceptionType = "0x70000000";
    89|                     break;
    90|                 case SIGBUS:
    91|                     exceptionType = "0x60000000";
    92|                     break;
    93|                 case SIGTRAP:
    94|                     exceptionType = "0x03000000";
    95|                     break;
    96|                 case SIGSEGV:
    97|                     exceptionType = "0x20000000";
    98|                     break;
    99|                 case SIGTERM:
   100|                     exceptionType = "0x02000000";
   101|                     break;
   102|                 case SIGABRT:
   103|                     exceptionType = "0x30000000";
   104|                     break;
   105|                 default:
   106|                     exceptionType = "0x00000000";
   107|                     break;
   108|                 }
   109|             }
   110|         }
   111|         WriteValueBool("is_managed", thread->IsManaged());
   112|         WriteValueBool("crashed", crashed);
   113|         if (thread->ManagedExceptionObject() != 0)
   114|         {
   115|             WriteValue64("managed_exception_object", thread->ManagedExceptionObject());
   116|         }
   117|         if (!thread->ManagedExceptionType().empty())
   118|         {
   119|             WriteValue("managed_exception_type", thread->ManagedExceptionType().c_str());
   120|         }
   121|         if (thread->ManagedExceptionHResult() != 0)
   122|         {
   123|             WriteValue32("managed_exception_hresult", thread->ManagedExceptionHResult());
   124|         }
   125|         WriteValue64("native_thread_id", thread->Tid());
   126|         OpenObject("ctx");
   127|         WriteValue64("IP", thread->GetInstructionPointer());
   128|         WriteValue64("SP", thread->GetStackPointer());
   129|         WriteValue64("BP", thread->GetFramePointer());
   130|         CloseObject();          // ctx
   131|         OpenArray("stack_frames");
   132|         for (auto iterator = thread->StackFrames().cbegin(); iterator != thread->StackFrames().cend(); ++iterator)
   133|         {
   134|             if (thread->IsBeginRepeat(iterator))
   135|             {
   136|                 OpenObject();
   137|                 WriteValue32("repeated", thread->NumRepeatedFrames());
   138|                 OpenArray("repeated_frames");
   139|             }
   140|             if (thread->IsEndRepeat(iterator))
   141|             {
   142|                 CloseArray();   // repeated_frames
   143|                 CloseObject();
   144|             }
   145|             WriteStackFrame(*iterator);
   146|         }
   147|         CloseArray();           // stack_frames
   148|         CloseObject();
   149|     }
   150|     CloseArray();               // threads
   151|     CloseObject();              // payload
   152|     OpenObject("parameters");
   153|     if (exceptionType != nullptr)
   154|     {
   155|         WriteValue("ExceptionType", exceptionType);
   156|     }
   157| #ifdef __APPLE__
   158|     WriteSysctl("kern.osproductversion", "OSVersion");
   159|     WriteSysctl("hw.model", "SystemModel");
   160|     WriteValue("SystemManufacturer", "apple");
   161| #endif // __APPLE__
   162|     CloseObject();              // parameters
   163| }
   164| #ifdef __APPLE__
   165| void
   166| CrashReportWriter::WriteSysctl(const char* sysctlname, const char* valueName)
   167| {
   168|     size_t size = 0;
   169|     if (sysctlbyname(sysctlname, nullptr, &size, NULL, 0) >= 0)
   170|     {
   171|         ArrayHolder<char> buffer = new char[size];
   172|         if (sysctlbyname(sysctlname, buffer, &size, NULL, 0) >= 0)
   173|         {
   174|             WriteValue(valueName, buffer);
   175|         }
   176|         else
   177|         {
   178|             TRACE("sysctlbyname(%s) 1 FAILED %s\n", sysctlname, strerror(errno));
   179|         }
   180|     }
   181|     else
   182|     {
   183|         TRACE("sysctlbyname(%s) 2 FAILED %s\n", sysctlname, strerror(errno));
   184|     }
   185| }
   186| #endif // __APPLE__
   187| void
   188| CrashReportWriter::WriteStackFrame(const StackFrame& frame)
   189| {
   190|     OpenObject();
   191|     WriteValueBool("is_managed", frame.IsManaged());
   192|     WriteValue64("module_address", frame.ModuleAddress());
   193|     WriteValue64("stack_pointer", frame.StackPointer());
   194|     WriteValue64("native_address", frame.InstructionPointer());
   195|     WriteValue64("native_offset", frame.NativeOffset());
   196|     if (frame.IsManaged())
   197|     {
   198|         WriteValue32("token", frame.Token());
   199|         WriteValue32("il_offset", frame.ILOffset());
   200|     }
   201|     IXCLRDataMethodInstance* pMethod = frame.GetMethod();
   202|     if (pMethod != nullptr)
   203|     {
   204|         ArrayHolder<WCHAR> wszUnicodeName = new WCHAR[MAX_LONGPATH + 1];
   205|         if (SUCCEEDED(pMethod->GetName(0, MAX_LONGPATH, nullptr, wszUnicodeName)))
   206|         {
   207|             std::string methodName = FormatString("%S", wszUnicodeName.GetPtr());
   208|             WriteValue("method_name", methodName.c_str());
   209|         }
   210|     }
   211|     if (frame.ModuleAddress() != 0)
   212|     {
   213|         ModuleInfo* moduleInfo = m_crashInfo.GetModuleInfoFromBaseAddress(frame.ModuleAddress());
   214|         if (moduleInfo != nullptr)
   215|         {
   216|             std::string moduleName = GetFileName(moduleInfo->ModuleName());
   217|             if (frame.IsManaged())
   218|             {
   219|                 WriteValue32("timestamp", moduleInfo->TimeStamp());
   220|                 WriteValue32("sizeofimage", moduleInfo->ImageSize());
   221|                 WriteValue("filename", moduleName.c_str());
   222|                 WriteValue("guid", FormatGuid(moduleInfo->Mvid()).c_str());
   223|             }
   224|             else
   225|             {
   226|                 const char* symbol = moduleInfo->GetSymbolName(frame.InstructionPointer());
   227|                 if (symbol != nullptr)
   228|                 {
   229|                     WriteValue("unmanaged_name", symbol);
   230|                     free((void*)symbol);
   231|                 }
   232|                 WriteValue("native_module", moduleName.c_str());
   233|             }
   234|         }
   235|     }
   236|     CloseObject();
   237| }
   238| bool
   239| CrashReportWriter::OpenWriter(const char* fileName)
   240| {
   241|     m_fd = open(fileName, O_WRONLY|O_CREAT|O_TRUNC, S_IWUSR | S_IRUSR);
   242|     if (m_fd == -1)
   243|     {
   244|         printf_error("Could not create json file '%s': %s (%d)\n", fileName, strerror(errno), errno);
   245|         return false;
   246|     }
   247|     Write("{\n");
   248|     return true;
   249| }
   250| void
   251| CrashReportWriter::CloseWriter()
   252| {
   253|     assert(m_indent == JSON_INDENT_VALUE);
   254|     Write("\n}\n");
   255| }
   256| void
   257| CrashReportWriter::Write(const std::string& text)
   258| {
   259|     if (!DumpWriter::WriteData(m_fd, (void*)text.c_str(), text.length()))
   260|     {
   261|         throw std::exception();
   262|     }
   263| }
   264| void
   265| CrashReportWriter::Write(const char* buffer)
   266| {
   267|     std::string text(buffer);
   268|     Write(text);
   269| }
   270| void
   271| CrashReportWriter::Indent(std::string& text)
   272| {
   273|     assert(m_indent >= 0);
   274|     text.append(m_indent, ' ');
   275| }
   276| void
   277| CrashReportWriter::WriteSeparator(std::string& text)
   278| {
   279|     if (m_comma)
   280|     {
   281|         text.append(1, ',');
   282|         text.append(1, '\n');
   283|     }
   284|     Indent(text);
   285| }
   286| void
   287| CrashReportWriter::OpenValue(const char* key, char marker)
   288| {
   289|     std::string text;
   290|     WriteSeparator(text);
   291|     if (key != nullptr)
   292|     {
   293|         text.append("\"");
   294|         text.append(key);
   295|         text.append("\" : ");
   296|     }
   297|     text.append(1, marker);
   298|     text.append(1, '\n');
   299|     m_comma = false;
   300|     m_indent += JSON_INDENT_VALUE;
   301|     Write(text);
   302| }
   303| void
   304| CrashReportWriter::CloseValue(char marker)
   305| {
   306|     std::string text;
   307|     text.append(1, '\n');
   308|     assert(m_indent >= JSON_INDENT_VALUE);
   309|     m_indent -= JSON_INDENT_VALUE;
   310|     Indent(text);
   311|     text.append(1, marker);
   312|     m_comma = true;
   313|     Write(text);
   314| }
   315| void
   316| CrashReportWriter::WriteValue(const char* key, const char* value)
   317| {
   318|     std::string text;
   319|     WriteSeparator(text);
   320|     text.append("\"");
   321|     text.append(key);
   322|     text.append("\" : \"");
   323|     text.append(value);
   324|     text.append("\"");
   325|     m_comma = true;
   326|     Write(text);
   327| }
   328| void
   329| CrashReportWriter::WriteValueBool(const char* key, bool value)
   330| {
   331|     WriteValue(key, value ? "true" : "false");
   332| }
   333| void
   334| CrashReportWriter::WriteValue32(const char* key, uint32_t value)
   335| {
   336|     char buffer[16];
   337|     snprintf(buffer, sizeof(buffer), "0x%x", value);
   338|     WriteValue(key, buffer);
   339| }
   340| void
   341| CrashReportWriter::WriteValue64(const char* key, uint64_t value)
   342| {
   343|     char buffer[32];
   344|     snprintf(buffer, sizeof(buffer), "0x%" PRIx64, value);
   345|     WriteValue(key, buffer);
   346| }
   347| void
   348| CrashReportWriter::OpenObject(const char* key)
   349| {
   350|     OpenValue(key, '{');
   351| }
   352| void
   353| CrashReportWriter::CloseObject()
   354| {
   355|     CloseValue('}');
   356| }
   357| void
   358| CrashReportWriter::OpenArray(const char* key)
   359| {
   360|     OpenValue(key, '[');
   361| }
   362| void
   363| CrashReportWriter::CloseArray()
   364| {
   365|     CloseValue(']');
   366| }


# ====================================================================
# FILE: src/coreclr/debug/createdump/createdump.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-119 ---
     1| #pragma once
     2| #define ___in       _SAL1_Source_(__in, (), _In_)
     3| #define ___out      _SAL1_Source_(__out, (), _Out_)
     4| extern bool g_diagnostics;
     5| extern bool g_diagnosticsVerbose;
     6| #ifdef HOST_UNIX
     7| extern bool g_checkForSingleFile;
     8| extern void trace_printf(const char* format, ...);
     9| extern void trace_verbose_printf(const char* format, ...);
    10| #define TRACE(args...) trace_printf(args)
    11| #define TRACE_VERBOSE(args...) trace_verbose_printf(args)
    12| #else
    13| #define TRACE(args, ...)
    14| #define TRACE_VERBOSE(args, ...)
    15| #endif
    16| #define DACCESS_TABLE_SYMBOL "g_dacTable"
    17| #ifdef HOST_64BIT
    18| #define PRIA "016"
    19| #else
    20| #define PRIA "08"
    21| #endif
    22| #ifdef HOST_UNIX
    23| #include "config.h"
    24| #endif
    25| #include <windows.h>
    26| #include <winternl.h>
    27| #include <winver.h>
    28| #include <stdlib.h>
    29| #include <stdint.h>
    30| #include <stddef.h>
    31| #include <string.h>
    32| #include <corhdr.h>
    33| #include <cor.h>
    34| #include <corsym.h>
    35| #include <clrdata.h>
    36| #include <xclrdata.h>
    37| #include <corerror.h>
    38| #include <cordebug.h>
    39| #include <xcordebug.h>
    40| #include <mscoree.h>
    41| typedef int T_CONTEXT;
    42| #include <dacprivate.h>
    43| #include <arrayholder.h>
    44| #include <releaseholder.h>
    45| #ifdef HOST_UNIX
    46| #include <dumpcommon.h>
    47| #include <unistd.h>
    48| #include <signal.h>
    49| #include <sys/types.h>
    50| #include <sys/stat.h>
    51| #include <sys/ptrace.h>
    52| #include <sys/user.h>
    53| #include <sys/wait.h>
    54| #ifndef __APPLE__
    55| #include <sys/procfs.h>
    56| #include <asm/ptrace.h>
    57| #endif
    58| #ifdef HAVE_PROCESS_VM_READV
    59| #include <sys/uio.h>
    60| #endif
    61| #include <dirent.h>
    62| #include <fcntl.h>
    63| #include <dlfcn.h>
    64| #include <cxxabi.h>
    65| #ifdef __APPLE__
    66| #include <ELF.h>
    67| #else
    68| #include <elf.h>
    69| #include <link.h>
    70| #endif
    71| #define __STDC_FORMAT_MACROS
    72| #include <inttypes.h>
    73| #else
    74| #include <dbghelp.h>
    75| #endif
    76| #include <map>
    77| #include <set>
    78| #include <vector>
    79| #include <array>
    80| #include <string>
    81| typedef struct
    82| {
    83|     const char* DumpPathTemplate;
    84|     const char* DumpType;
    85|     MINIDUMP_TYPE MinidumpType;
    86|     bool CreateDump;
    87|     bool CrashReport;
    88|     int Pid;
    89|     int CrashThread;
    90|     int Signal;
    91| #if defined(HOST_UNIX) && !defined(HOST_OSX)
    92|     int SignalCode;
    93|     int SignalErrno;
    94|     void* SignalAddress;
    95| #endif
    96| } CreateDumpOptions;
    97| #ifdef HOST_UNIX
    98| #ifdef __APPLE__
    99| #include <mach/mach.h>
   100| #include <mach/mach_vm.h>
   101| #endif
   102| #include "moduleinfo.h"
   103| #include "datatarget.h"
   104| #include "stackframe.h"
   105| #include "threadinfo.h"
   106| #include "memoryregion.h"
   107| #include "crashinfo.h"
   108| #include "crashreportwriter.h"
   109| #include "dumpwriter.h"
   110| #include "runtimeinfo.h"
   111| #endif
   112| #ifndef MAX_LONGPATH
   113| #define MAX_LONGPATH   1024
   114| #endif
   115| extern bool CreateDump(const CreateDumpOptions& options);
   116| extern bool FormatDumpName(std::string& name, const char* pattern, const char* exename, int pid);
   117| extern std::string GetLastErrorString();
   118| extern void printf_status(const char* format, ...);
   119| extern void printf_error(const char* format, ...);


# ====================================================================
# FILE: src/coreclr/debug/createdump/createdumpunix.cpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-81 ---
     1| #include "createdump.h"
     2| #if defined(__arm__) || defined(__aarch64__) || defined(__loongarch64)
     3| long g_pageSize = 0;
     4| #endif
     5| bool
     6| CreateDump(const CreateDumpOptions& options)
     7| {
     8|     ReleaseHolder<CrashInfo> crashInfo = new CrashInfo(options);
     9|     DumpWriter dumpWriter(*crashInfo);
    10|     std::string dumpPath;
    11|     bool result = false;
    12| #if defined(__arm__) || defined(__aarch64__) || defined(__loongarch64)
    13|     g_pageSize = sysconf(_SC_PAGESIZE);
    14| #endif
    15|     TRACE("PAGE_SIZE %d\n", PAGE_SIZE);
    16|     if (!crashInfo->Initialize())
    17|     {
    18|         goto exit;
    19|     }
    20|     printf_status("Gathering state for process %d %s\n", options.Pid, crashInfo->Name().c_str());
    21|     if (options.Signal != 0 || options.CrashThread != 0)
    22|     {
    23|         printf_status("Crashing thread %04x signal %d (%04x)\n", options.CrashThread, options.Signal, options.Signal);
    24|     }
    25|     if (!crashInfo->EnumerateAndSuspendThreads())
    26|     {
    27|         goto exit;
    28|     }
    29|     if (!crashInfo->GatherCrashInfo(options.MinidumpType))
    30|     {
    31|         goto exit;
    32|     }
    33|     if (!FormatDumpName(dumpPath, options.DumpPathTemplate, crashInfo->Name().c_str(), options.Pid))
    34|     {
    35|         goto exit;
    36|     }
    37|     if (options.CrashReport)
    38|     {
    39|         CrashReportWriter crashReportWriter(*crashInfo);
    40|         crashReportWriter.WriteCrashReport(dumpPath);
    41|     }
    42|     if (options.CreateDump)
    43|     {
    44|         if (!crashInfo->EnumerateMemoryRegionsWithDAC(options.MinidumpType))
    45|         {
    46|             goto exit;
    47|         }
    48|         crashInfo->CombineMemoryRegions();
    49|         printf_status("Writing %s to file %s\n", options.DumpType, dumpPath.c_str());
    50|         if (!dumpWriter.OpenDump(dumpPath.c_str()))
    51|         {
    52|             goto exit;
    53|         }
    54|         if (!dumpWriter.WriteDump())
    55|         {
    56|             printf_error("Writing dump FAILED\n");
    57|             remove(dumpPath.c_str());
    58|             goto exit;
    59|         }
    60|     }
    61|     result = true;
    62| exit:
    63|     if (kill(options.Pid, 0) == 0)
    64|     {
    65|         printf_status("Target process is alive\n");
    66|     }
    67|     else
    68|     {
    69|         int err = errno;
    70|         if (err == ESRCH)
    71|         {
    72|             printf_error("Target process terminated\n");
    73|         }
    74|         else
    75|         {
    76|             printf_error("kill(%d, 0) FAILED %s (%d)\n", options.Pid, strerror(err), err);
    77|         }
    78|     }
    79|     crashInfo->CleanupAndResumeProcess();
    80|     return result;
    81| }


# ====================================================================
# FILE: src/coreclr/debug/createdump/createdumpwindows.cpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-78 ---
     1| #include "createdump.h"
     2| #include <psapi.h>
     3| typedef struct _PROCESS_BASIC_INFORMATION_ {
     4|     NTSTATUS ExitStatus;
     5|     PPEB PebBaseAddress;
     6|     ULONG_PTR AffinityMask;
     7|     KPRIORITY BasePriority;
     8|     ULONG_PTR UniqueProcessId;
     9|     ULONG_PTR InheritedFromUniqueProcessId;
    10| } PROCESS_BASIC_INFORMATION_;
    11| bool
    12| CreateDump(const CreateDumpOptions& options)
    13| {
    14|     HANDLE hFile = INVALID_HANDLE_VALUE;
    15|     HANDLE hProcess = NULL;
    16|     bool result = false;
    17|     _ASSERTE(options.CreateDump);
    18|     _ASSERTE(!options.CrashReport);
    19|     ArrayHolder<char> pszName = new char[MAX_LONGPATH + 1];
    20|     std::string dumpPath;
    21|     PROCESS_BASIC_INFORMATION_ processInformation;
    22|     NTSTATUS status = NtQueryInformationProcess(GetCurrentProcess(), PROCESSINFOCLASS::ProcessBasicInformation, &processInformation, sizeof(processInformation), NULL);
    23|     if (status != 0)
    24|     {
    25|         printf_error("Failed to get parent process id status %d\n", status);
    26|         goto exit;
    27|     }
    28|     int pid = (int)processInformation.InheritedFromUniqueProcessId;
    29|     hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
    30|     if (hProcess == NULL)
    31|     {
    32|         printf_error("Invalid process id '%d' - %s\n", pid, GetLastErrorString().c_str());
    33|         goto exit;
    34|     }
    35|     if (GetModuleBaseNameA(hProcess, NULL, pszName, MAX_LONGPATH) <= 0)
    36|     {
    37|         printf_error("Get process name FAILED - %s\n", GetLastErrorString().c_str());
    38|         goto exit;
    39|     }
    40|     if (!FormatDumpName(dumpPath, options.DumpPathTemplate, pszName, pid))
    41|     {
    42|         goto exit;
    43|     }
    44|     printf_status("Writing %s for process %d to file %s\n", options.DumpType, pid, dumpPath.c_str());
    45|     hFile = CreateFileA(dumpPath.c_str(), GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    46|     if (hFile == INVALID_HANDLE_VALUE)
    47|     {
    48|         printf_error("Invalid dump path '%s' - %s\n", dumpPath.c_str(), GetLastErrorString().c_str());
    49|         goto exit;
    50|     }
    51|     for (int i = 0; i < 5; i++)
    52|     {
    53|         if (MiniDumpWriteDump(hProcess, pid, hFile, options.MinidumpType, NULL, NULL, NULL))
    54|         {
    55|             result = true;
    56|             break;
    57|         }
    58|         else
    59|         {
    60|             int err = GetLastError();
    61|             if (err != ERROR_PARTIAL_COPY)
    62|             {
    63|                 printf_error("MiniDumpWriteDump - %s\n", GetLastErrorString().c_str());
    64|                 break;
    65|             }
    66|         }
    67|     }
    68| exit:
    69|     if (hProcess != NULL)
    70|     {
    71|         CloseHandle(hProcess);
    72|     }
    73|     if (hFile != INVALID_HANDLE_VALUE)
    74|     {
    75|         CloseHandle(hFile);
    76|     }
    77|     return result;
    78| }


# ====================================================================
# FILE: src/coreclr/debug/createdump/dumpwriterelf.cpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-312 ---
     1| #include "createdump.h"
     2| extern int g_readProcessMemoryErrno;
     3| bool
     4| DumpWriter::WriteDump()
     5| {
     6|     Ehdr ehdr;
     7|     memset(&ehdr, 0, sizeof(Ehdr));
     8|     ehdr.e_ident[0] = ELFMAG0;
     9|     ehdr.e_ident[1] = ELFMAG1;
    10|     ehdr.e_ident[2] = ELFMAG2;
    11|     ehdr.e_ident[3] = ELFMAG3;
    12|     ehdr.e_ident[EI_CLASS] = ELF_CLASS;
    13|     ehdr.e_ident[EI_DATA] = ELFDATA2LSB;
    14|     ehdr.e_ident[EI_VERSION] = EV_CURRENT;
    15|     ehdr.e_ident[EI_OSABI] = ELFOSABI_LINUX;
    16|     ehdr.e_type = ET_CORE;
    17|     ehdr.e_machine = ELF_ARCH;
    18|     ehdr.e_version = EV_CURRENT;
    19|     ehdr.e_phoff = sizeof(Ehdr);
    20|     ehdr.e_ehsize = sizeof(Ehdr);
    21|     ehdr.e_phentsize = sizeof(Phdr);
    22|     uint64_t phnum = 1;
    23|     for (const MemoryRegion& memoryRegion : m_crashInfo.MemoryRegions())
    24|     {
    25|         phnum++;
    26|     }
    27|     if (phnum < PH_HDR_CANARY) {
    28|         ehdr.e_phnum = phnum;
    29|     }
    30|     else {
    31|         ehdr.e_phnum = PH_HDR_CANARY;
    32|         ehdr.e_phoff = sizeof(Ehdr) + sizeof(Shdr);
    33|         ehdr.e_shnum = 1;
    34|         ehdr.e_shoff = sizeof(Ehdr);
    35|         ehdr.e_shentsize = sizeof(Shdr);
    36|     }
    37|     if (!WriteData(&ehdr, sizeof(Ehdr))) {
    38|         return false;
    39|     }
    40|     size_t offset = sizeof(Ehdr) + (phnum * sizeof(Phdr));
    41|     size_t filesz = GetProcessInfoSize() + GetAuxvInfoSize() + GetThreadInfoSize() + GetNTFileInfoSize();
    42|     if (ehdr.e_phnum == PH_HDR_CANARY)
    43|     {
    44|         Shdr shdr;
    45|         memset(&shdr, 0, sizeof(shdr));
    46|         shdr.sh_info = phnum;
    47|         shdr.sh_size = 1;
    48|         offset += sizeof(Shdr);
    49|         if (!WriteData(&shdr, sizeof(shdr))) {
    50|             return false;
    51|         }
    52|     }
    53|     Phdr phdr;
    54|     memset(&phdr, 0, sizeof(Phdr));
    55|     phdr.p_type = PT_NOTE;
    56|     phdr.p_offset = offset;
    57|     phdr.p_filesz = filesz;
    58|     if (!WriteData(&phdr, sizeof(phdr))) {
    59|         return false;
    60|     }
    61|     phdr.p_type = PT_LOAD;
    62|     phdr.p_align = 4096;
    63|     size_t finalNoteAlignment = phdr.p_align - ((offset + filesz) % phdr.p_align);
    64|     if (finalNoteAlignment == phdr.p_align) {
    65|         finalNoteAlignment = 0;
    66|     }
    67|     offset += finalNoteAlignment;
    68|     TRACE("Writing memory region headers to core file\n");
    69|     for (const MemoryRegion& memoryRegion : m_crashInfo.MemoryRegions())
    70|     {
    71|         phdr.p_flags = memoryRegion.Permissions();
    72|         phdr.p_vaddr = memoryRegion.StartAddress();
    73|         phdr.p_memsz = memoryRegion.Size();
    74|         offset += filesz;
    75|         phdr.p_filesz = filesz = memoryRegion.Size();
    76|         phdr.p_offset = offset;
    77|         if (!WriteData(&phdr, sizeof(phdr))) {
    78|             return false;
    79|         }
    80|     }
    81|     if (!WriteProcessInfo()) {
    82|         return false;
    83|     }
    84|     if (!WriteAuxv()) {
    85|         return false;
    86|     }
    87|     if (!WriteNTFileInfo()) {
    88|         return false;
    89|     }
    90|     TRACE("Writing %zd thread entries to core file\n", m_crashInfo.Threads().size());
    91|     for (const ThreadInfo* thread : m_crashInfo.Threads())
    92|     {
    93|         if (!WriteThread(*thread)) {
    94|             return false;
    95|         }
    96|     }
    97|     if (finalNoteAlignment > 0) {
    98|         if (finalNoteAlignment > sizeof(m_tempBuffer)) {
    99|             printf_error("Internal error: finalNoteAlignment %zu > sizeof(m_tempBuffer)\n", finalNoteAlignment);
   100|             return false;
   101|         }
   102|         memset(m_tempBuffer, 0, finalNoteAlignment);
   103|         if (!WriteData(m_tempBuffer, finalNoteAlignment)) {
   104|             return false;
   105|         }
   106|     }
   107|     TRACE("Writing %" PRIu64 " memory regions to core file\n", phnum - 1);
   108|     uint64_t total = 0;
   109|     for (const MemoryRegion& memoryRegion : m_crashInfo.MemoryRegions())
   110|     {
   111|         uint64_t address = memoryRegion.StartAddress();
   112|         size_t size = memoryRegion.Size();
   113|         total += size;
   114|         while (size > 0)
   115|         {
   116|             size_t bytesToRead = std::min(size, sizeof(m_tempBuffer));
   117|             size_t read = 0;
   118|             if (!m_crashInfo.ReadProcessMemory((void*)address, m_tempBuffer, bytesToRead, &read)) {
   119|                 printf_error("Error reading memory at %" PRIA PRIx64 " size %08zx FAILED %s (%d)\n", address, bytesToRead, strerror(g_readProcessMemoryErrno), g_readProcessMemoryErrno);
   120|                 return false;
   121|             }
   122|             if (read == 0) {
   123|                 printf_error("Error reading memory at %" PRIA PRIx64 " size %08zx returned 0 bytes read: %s (%d)\n", address, bytesToRead, strerror(g_readProcessMemoryErrno), g_readProcessMemoryErrno);
   124|                 return false;
   125|             }
   126|             if (!WriteData(m_tempBuffer, read)) {
   127|                 return false;
   128|             }
   129|             address += read;
   130|             size -= read;
   131|         }
   132|     }
   133|     printf_status("Written %" PRId64 " bytes (%" PRId64 " pages) to core file\n", total, total / PAGE_SIZE);
   134|     return true;
   135| }
   136| bool
   137| DumpWriter::WriteProcessInfo()
   138| {
   139|     prpsinfo_t processInfo;
   140|     memset(&processInfo, 0, sizeof(processInfo));
   141|     processInfo.pr_sname = 'R';
   142|     processInfo.pr_pid = m_crashInfo.Pid();
   143|     processInfo.pr_ppid = m_crashInfo.Ppid();
   144|     processInfo.pr_pgrp = m_crashInfo.Tgid();
   145|     m_crashInfo.Name().copy(processInfo.pr_fname, sizeof(processInfo.pr_fname));
   146|     Nhdr nhdr;
   147|     memset(&nhdr, 0, sizeof(nhdr));
   148|     nhdr.n_namesz = 5;
   149|     nhdr.n_descsz = sizeof(prpsinfo_t);
   150|     nhdr.n_type = NT_PRPSINFO;
   151|     TRACE("Writing process information to core file\n");
   152|     if (!WriteData(&nhdr, sizeof(nhdr)) ||
   153|         !WriteData("CORE\0PRP", 8) ||
   154|         !WriteData(&processInfo, sizeof(prpsinfo_t))) {
   155|         return false;
   156|     }
   157|     return true;
   158| }
   159| bool
   160| DumpWriter::WriteAuxv()
   161| {
   162|     Nhdr nhdr;
   163|     memset(&nhdr, 0, sizeof(nhdr));
   164|     nhdr.n_namesz = 5;
   165|     nhdr.n_descsz = m_crashInfo.GetAuxvSize();
   166|     nhdr.n_type = NT_AUXV;
   167|     TRACE("Writing %zd auxv entries to core file\n", m_crashInfo.AuxvEntries().size());
   168|     if (!WriteData(&nhdr, sizeof(nhdr)) ||
   169|         !WriteData("CORE\0AUX", 8)) {
   170|         return false;
   171|     }
   172|     for (const auto& auxvEntry : m_crashInfo.AuxvEntries())
   173|     {
   174|         if (!WriteData(&auxvEntry, sizeof(auxvEntry))) {
   175|             return false;
   176|         }
   177|     }
   178|     return true;
   179| }
   180| struct NTFileEntry
   181| {
   182|     unsigned long StartAddress;
   183|     unsigned long EndAddress;
   184|     unsigned long Offset;
   185| };
   186| size_t
   187| DumpWriter::GetNTFileInfoSize(size_t* alignmentBytes)
   188| {
   189|     size_t count = m_crashInfo.ModuleMappings().size();
   190|     size_t size = 0;
   191|     size = sizeof(Nhdr) + 8 + sizeof(count) + sizeof(size);
   192|     size += count * sizeof(NTFileEntry);
   193|     size += count;
   194|     for (const MemoryRegion& image : m_crashInfo.ModuleMappings()) {
   195|         size += image.FileName().length();
   196|     }
   197|     size_t alignmentBytesNeeded = 4 - (size % 4);
   198|     size += alignmentBytesNeeded;
   199|     if (alignmentBytes != nullptr) {
   200|         *alignmentBytes = alignmentBytesNeeded;
   201|     }
   202|     return size;
   203| }
   204| bool
   205| DumpWriter::WriteNTFileInfo()
   206| {
   207|     Nhdr nhdr;
   208|     memset(&nhdr, 0, sizeof(nhdr));
   209|     nhdr.n_namesz = 5;
   210|     nhdr.n_type = NT_FILE;  // "FILE"
   211|     size_t alignmentBytesNeeded = 0;
   212|     nhdr.n_descsz = GetNTFileInfoSize(&alignmentBytesNeeded) - sizeof(nhdr) - 8;
   213|     size_t count = m_crashInfo.ModuleMappings().size();
   214|     size_t pageSize = PAGE_SIZE;
   215|     TRACE("Writing %zd NT_FILE entries to core file\n", m_crashInfo.ModuleMappings().size());
   216|     if (!WriteData(&nhdr, sizeof(nhdr)) ||
   217|         !WriteData("CORE\0FIL", 8) ||
   218|         !WriteData(&count, sizeof(count)) ||
   219|         !WriteData(&pageSize, sizeof(pageSize))) {
   220|         return false;
   221|     }
   222|     for (const MemoryRegion& image : m_crashInfo.ModuleMappings())
   223|     {
   224|         struct NTFileEntry entry { (unsigned long)image.StartAddress(), (unsigned long)image.EndAddress(), (unsigned long)(image.Offset() / pageSize) };
   225|         if (!WriteData(&entry, sizeof(entry))) {
   226|             return false;
   227|         }
   228|     }
   229|     for (const MemoryRegion& image : m_crashInfo.ModuleMappings())
   230|     {
   231|         if (!WriteData(image.FileName().c_str(), image.FileName().length()) ||
   232|             !WriteData("\0", 1)) {
   233|             return false;
   234|         }
   235|     }
   236|     if (alignmentBytesNeeded) {
   237|         if (!WriteData("\0\0\0\0", alignmentBytesNeeded)) {
   238|             return false;
   239|         }
   240|     }
   241|     return true;
   242| }
   243| bool
   244| DumpWriter::WriteThread(const ThreadInfo& thread)
   245| {
   246|     prstatus_t pr;
   247|     memset(&pr, 0, sizeof(pr));
   248|     const siginfo_t* siginfo = nullptr;
   249|     if (m_crashInfo.Signal() != 0 && thread.IsCrashThread())
   250|     {
   251|         siginfo = m_crashInfo.SigInfo();
   252|         pr.pr_info.si_signo = siginfo->si_signo;
   253|         pr.pr_info.si_code = siginfo->si_code;
   254|         pr.pr_info.si_errno = siginfo->si_errno;
   255|         pr.pr_cursig = siginfo->si_signo;
   256|     }
   257|     pr.pr_pid = thread.Tid();
   258|     pr.pr_ppid = thread.Ppid();
   259|     pr.pr_pgrp = thread.Tgid();
   260|     memcpy(&pr.pr_reg, thread.GPRegisters(), sizeof(user_regs_struct));
   261|     Nhdr nhdr;
   262|     memset(&nhdr, 0, sizeof(nhdr));
   263|     nhdr.n_namesz = 5;
   264|     nhdr.n_descsz = sizeof(prstatus_t);
   265|     nhdr.n_type = NT_PRSTATUS;
   266|     if (!WriteData(&nhdr, sizeof(nhdr)) ||
   267|         !WriteData("CORE\0THR", 8) ||
   268|         !WriteData(&pr, sizeof(prstatus_t))) {
   269|         return false;
   270|     }
   271|     nhdr.n_descsz = sizeof(user_fpregs_struct);
   272|     nhdr.n_type = NT_FPREGSET;
   273|     if (!WriteData(&nhdr, sizeof(nhdr)) ||
   274|         !WriteData("CORE\0FLT", 8) ||
   275|         !WriteData(thread.FPRegisters(), sizeof(user_fpregs_struct))) {
   276|         return false;
   277|     }
   278| #if defined(__i386__)
   279|     nhdr.n_namesz = 6;
   280|     nhdr.n_descsz = sizeof(user_fpxregs_struct);
   281|     nhdr.n_type = NT_PRXFPREG;
   282|     if (!WriteData(&nhdr, sizeof(nhdr)) ||
   283|         !WriteData("LINUX\0\0\0", 8) ||
   284|         !WriteData(thread.FPXRegisters(), sizeof(user_fpxregs_struct))) {
   285|         return false;
   286|     }
   287| #endif
   288| #if defined(__arm__) && defined(__VFP_FP__) && !defined(__SOFTFP__)
   289|     nhdr.n_namesz = 6;
   290|     nhdr.n_descsz = sizeof(user_vfpregs_struct);
   291|     nhdr.n_type = NT_ARM_VFP;
   292|     if (!WriteData(&nhdr, sizeof(nhdr)) ||
   293|         !WriteData("LINUX\0\0\0", 8) ||
   294|         !WriteData(thread.VFPRegisters(), sizeof(user_vfpregs_struct))) {
   295|         return false;
   296|     }
   297| #endif
   298|     if (siginfo != nullptr)
   299|     {
   300|         TRACE("Writing NT_SIGINFO tid %04x signo %d (%04x) code %04x errno %04x addr %p\n",
   301|             thread.Tid(), siginfo->si_signo, siginfo->si_signo, siginfo->si_code, siginfo->si_errno, siginfo->si_addr);
   302|         nhdr.n_namesz = 5;
   303|         nhdr.n_descsz = sizeof(siginfo_t);
   304|         nhdr.n_type = NT_SIGINFO;
   305|         if (!WriteData(&nhdr, sizeof(nhdr)) ||
   306|             !WriteData("CORE\0SIG", 8) ||
   307|             !WriteData(siginfo, sizeof(siginfo_t))) {
   308|             return false;
   309|         }
   310|     }
   311|     return true;
   312| }


# ====================================================================
# FILE: src/coreclr/debug/createdump/dumpwriterelf.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-65 ---
     1| #ifdef HOST_64BIT
     2| #define ELF_CLASS ELFCLASS64
     3| #else
     4| #define ELF_CLASS ELFCLASS32
     5| #endif
     6| #define Ehdr   ElfW(Ehdr)
     7| #define Phdr   ElfW(Phdr)
     8| #define Shdr   ElfW(Shdr)
     9| #define Nhdr   ElfW(Nhdr)
    10| #define auxv_t ElfW(auxv_t)
    11| #if defined(__x86_64__)
    12| #define ELF_ARCH  EM_X86_64
    13| #elif defined(__i386__)
    14| #define ELF_ARCH  EM_386
    15| #elif defined(__aarch64__)
    16| #define ELF_ARCH  EM_AARCH64
    17| #elif defined(__arm__)
    18| #define ELF_ARCH  EM_ARM
    19| #elif defined(__loongarch64)
    20| #define ELF_ARCH  EM_LOONGARCH
    21| #endif
    22| #define PH_HDR_CANARY 0xFFFF
    23| #ifndef NT_FILE
    24| #define NT_FILE		0x46494c45
    25| #endif
    26| #ifndef NT_SIGINFO	
    27| #define NT_SIGINFO	0x53494749
    28| #endif
    29| class DumpWriter
    30| {
    31| private:
    32|     int m_fd;
    33|     CrashInfo& m_crashInfo;
    34|     BYTE m_tempBuffer[0x4000];
    35|     DumpWriter(const DumpWriter&) = delete;
    36|     void operator=(const DumpWriter&) = delete;
    37| public:
    38|     DumpWriter(CrashInfo& crashInfo);
    39|     virtual ~DumpWriter();
    40|     bool OpenDump(const char* dumpFileName);
    41|     bool WriteDump();
    42|     static bool WriteData(int fd, const void* buffer, size_t length);
    43| private:
    44|     bool WriteProcessInfo();
    45|     bool WriteAuxv();
    46|     size_t GetNTFileInfoSize(size_t* alignmentBytes = nullptr);
    47|     bool WriteNTFileInfo();
    48|     bool WriteThread(const ThreadInfo& thread);
    49|     bool WriteData(const void* buffer, size_t length) { return WriteData(m_fd, buffer, length); }
    50|     size_t GetProcessInfoSize() const { return sizeof(Nhdr) + 8 + sizeof(prpsinfo_t); }
    51|     size_t GetAuxvInfoSize() const { return sizeof(Nhdr) + 8 + m_crashInfo.GetAuxvSize(); }
    52|     size_t GetThreadInfoSize() const
    53|     {
    54|         return (m_crashInfo.Signal() != 0 ? (sizeof(Nhdr) + 8 + sizeof(siginfo_t)) : 0)
    55|               + (m_crashInfo.Threads().size() * ((sizeof(Nhdr) + 8 + sizeof(prstatus_t))
    56|               + (sizeof(Nhdr) + 8 + sizeof(user_fpregs_struct))
    57| #if defined(__i386__)
    58|               + (sizeof(Nhdr) + 8 + sizeof(user_fpxregs_struct))
    59| #endif
    60| #if defined(__arm__) && defined(__VFP_FP__) && !defined(__SOFTFP__)
    61|               + (sizeof(Nhdr) + 8 + sizeof(user_vfpregs_struct))
    62| #endif
    63|         ));
    64|     }
    65| };


# ====================================================================
# FILE: src/coreclr/debug/createdump/main.cpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-391 ---
     1| #include "createdump.h"
     2| #ifdef HOST_WINDOWS
     3| #define DEFAULT_DUMP_PATH "%TEMP%\\"
     4| #define DEFAULT_DUMP_TEMPLATE "dump.%p.dmp"
     5| #else
     6| #define DEFAULT_DUMP_PATH "/tmp/"
     7| #define DEFAULT_DUMP_TEMPLATE "coredump.%p"
     8| #endif
     9| #ifdef HOST_UNIX
    10| const char* g_help = "createdump [options] pid\n"
    11| #else
    12| const char* g_help = "createdump [options]\n"
    13| #endif
    14| "-f, --name - dump path and file name. The default is '" DEFAULT_DUMP_PATH DEFAULT_DUMP_TEMPLATE "'. These specifiers are substituted with following values:\n"
    15| "   %p  PID of dumped process.\n"
    16| "   %e  The process executable filename.\n"
    17| "   %h  Hostname return by gethostname().\n"
    18| "   %t  Time of dump, expressed as seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).\n"
    19| "-n, --normal - create minidump.\n"
    20| "-h, --withheap - create minidump with heap (default).\n"
    21| "-t, --triage - create triage minidump.\n"
    22| "-u, --full - create full core dump.\n"
    23| "-d, --diag - enable diagnostic messages.\n"
    24| "-v, --verbose - enable verbose diagnostic messages.\n"
    25| "-l, --logtofile - file path and name to log diagnostic messages.\n"
    26| #ifdef HOST_UNIX
    27| "--crashreport - write crash report file (dump file path + .crashreport.json).\n"
    28| "--crashreportonly - write crash report file only (no dump).\n"
    29| "--crashthread <id> - the thread id of the crashing thread.\n"
    30| "--signal <code> - the signal code of the crash.\n"
    31| "--singlefile - enable single-file app check.\n"
    32| #endif
    33| ;
    34| FILE *g_logfile = nullptr;
    35| FILE *g_stdout = stdout;
    36| bool g_diagnostics = false;
    37| bool g_diagnosticsVerbose = false;
    38| uint64_t g_ticksPerMS = 0;
    39| uint64_t g_startTime = 0;
    40| uint64_t GetTickFrequency();
    41| uint64_t GetTimeStamp();
    42| #ifdef HOST_UNIX
    43| bool g_checkForSingleFile = false;
    44| #endif
    45| int __cdecl main(const int argc, const char* argv[])
    46| {
    47|     CreateDumpOptions options;
    48|     options.MinidumpType = (MINIDUMP_TYPE)(MiniDumpWithPrivateReadWriteMemory |
    49|                                            MiniDumpWithDataSegs |
    50|                                            MiniDumpWithHandleData |
    51|                                            MiniDumpWithUnloadedModules |
    52|                                            MiniDumpWithFullMemoryInfo |
    53|                                            MiniDumpWithThreadInfo |
    54|                                            MiniDumpWithTokenInformation);
    55|     options.DumpType = "minidump with heap";
    56|     options.DumpPathTemplate = nullptr;
    57|     options.CrashReport = false;
    58|     options.CreateDump = true;
    59|     options.Signal = 0;
    60|     options.CrashThread = 0;
    61|     options.Pid = 0;
    62| #if defined(HOST_UNIX) && !defined(HOST_OSX)
    63|     options.SignalCode = 0;
    64|     options.SignalErrno = 0;
    65|     options.SignalAddress = nullptr;
    66| #endif
    67|     bool help = false;
    68|     int exitCode = 0;
    69| #ifdef HOST_UNIX
    70|     exitCode = PAL_InitializeDLL();
    71|     if (exitCode != 0)
    72|     {
    73|         printf_error("PAL initialization FAILED %d\n", exitCode);
    74|         return exitCode;
    75|     }
    76| #endif
    77|     argv++;
    78|     for (int i = 1; i < argc; i++)
    79|     {
    80|         if (*argv != nullptr)
    81|         {
    82|             if ((strcmp(*argv, "-f") == 0) || (strcmp(*argv, "--name") == 0))
    83|             {
    84|                 options.DumpPathTemplate = *++argv;
    85|             }
    86|             else if ((strcmp(*argv, "-n") == 0) || (strcmp(*argv, "--normal") == 0))
    87|             {
    88|                 options.DumpType = "minidump";
    89|                 options.MinidumpType = (MINIDUMP_TYPE)(MiniDumpNormal |
    90|                                                        MiniDumpWithDataSegs |
    91|                                                        MiniDumpWithHandleData |
    92|                                                        MiniDumpWithThreadInfo);
    93|             }
    94|             else if ((strcmp(*argv, "-h") == 0) || (strcmp(*argv, "--withheap") == 0))
    95|             {
    96|                 options.DumpType = "minidump with heap";
    97|                 options.MinidumpType = (MINIDUMP_TYPE)(MiniDumpWithPrivateReadWriteMemory |
    98|                                                        MiniDumpWithDataSegs |
    99|                                                        MiniDumpWithHandleData |
   100|                                                        MiniDumpWithUnloadedModules |
   101|                                                        MiniDumpWithFullMemoryInfo |
   102|                                                        MiniDumpWithThreadInfo |
   103|                                                        MiniDumpWithTokenInformation);
   104|             }
   105|             else if ((strcmp(*argv, "-t") == 0) || (strcmp(*argv, "--triage") == 0))
   106|             {
   107|                 options.DumpType = "triage minidump";
   108|                 options.MinidumpType = (MINIDUMP_TYPE)(MiniDumpFilterTriage |
   109|                                                        MiniDumpIgnoreInaccessibleMemory |
   110|                                                        MiniDumpWithoutOptionalData |
   111|                                                        MiniDumpWithProcessThreadData |
   112|                                                        MiniDumpFilterModulePaths |
   113|                                                        MiniDumpWithUnloadedModules |
   114|                                                        MiniDumpFilterMemory |
   115|                                                        MiniDumpWithHandleData);
   116|             }
   117|             else if ((strcmp(*argv, "-u") == 0) || (strcmp(*argv, "--full") == 0))
   118|             {
   119|                 options.DumpType = "full dump";
   120|                 options.MinidumpType = (MINIDUMP_TYPE)(MiniDumpWithFullMemory |
   121|                                                        MiniDumpWithDataSegs |
   122|                                                        MiniDumpWithHandleData |
   123|                                                        MiniDumpWithUnloadedModules |
   124|                                                        MiniDumpWithFullMemoryInfo |
   125|                                                        MiniDumpWithThreadInfo |
   126|                                                        MiniDumpWithTokenInformation);
   127|             }
   128| #ifdef HOST_UNIX
   129|             else if (strcmp(*argv, "--crashreport") == 0)
   130|             {
   131|                 options.CrashReport = true;
   132|             }
   133|             else if (strcmp(*argv, "--crashreportonly") == 0)
   134|             {
   135|                 options.CrashReport = true;
   136|                 options.CreateDump = false;
   137|             }
   138|             else if (strcmp(*argv, "--crashthread") == 0)
   139|             {
   140|                 options.CrashThread = atoi(*++argv);
   141|             }
   142|             else if (strcmp(*argv, "--signal") == 0)
   143|             {
   144|                 options.Signal = atoi(*++argv);
   145|             }
   146|             else if (strcmp(*argv, "--singlefile") == 0)
   147|             {
   148|                 g_checkForSingleFile = true;
   149|             }
   150| #ifndef HOST_OSX
   151|             else if (strcmp(*argv, "--code") == 0)
   152|             {
   153|                 options.SignalCode = atoi(*++argv);
   154|             }
   155|             else if (strcmp(*argv, "--errno") == 0)
   156|             {
   157|                 options.SignalErrno = atoi(*++argv);
   158|             }
   159|             else if (strcmp(*argv, "--address") == 0)
   160|             {
   161|                 options.SignalAddress = (void*)atoll(*++argv);
   162|             }
   163| #endif
   164| #endif
   165|             else if ((strcmp(*argv, "-d") == 0) || (strcmp(*argv, "--diag") == 0))
   166|             {
   167|                 g_diagnostics = true;
   168|             }
   169|             else if ((strcmp(*argv, "-v") == 0) || (strcmp(*argv, "--verbose") == 0))
   170|             {
   171|                 g_diagnostics = true;
   172|                 g_diagnosticsVerbose = true;
   173|             }
   174|             else if ((strcmp(*argv, "-l") == 0) || (strcmp(*argv, "--logtofile") == 0))
   175|             {
   176|                 const char* logFilePath = *++argv;
   177|                 g_logfile = fopen(logFilePath, "w");
   178|                 if (g_logfile == nullptr)
   179|                 {
   180|                     printf_error("Can not create log file '%s': %s (%d)\n", logFilePath, strerror(errno), errno);
   181|                     return errno;
   182|                 }
   183|                 g_stdout = g_logfile;
   184|             }
   185|             else if ((strcmp(*argv, "-?") == 0) || (strcmp(*argv, "--help") == 0))
   186|             {
   187|                 help = true;
   188|             }
   189|             else
   190|             {
   191| #ifdef HOST_UNIX
   192|                 options.Pid = atoi(*argv);
   193| #else
   194|                 printf_error("The pid argument is no longer supported\n");
   195|                 return -1;
   196| #endif
   197|             }
   198|             argv++;
   199|         }
   200|     }
   201| #ifdef HOST_UNIX
   202|     if (options.Pid == 0)
   203|     {
   204|         help = true;
   205|     }
   206| #endif
   207|     if (help)
   208|     {
   209|         printf_error("%s", g_help);
   210|         return -1;
   211|     }
   212|     g_ticksPerMS = GetTickFrequency() / 1000UL;
   213|     g_startTime = GetTimeStamp();
   214|     TRACE("TickFrequency: %d ticks per ms\n", g_ticksPerMS);
   215|     ArrayHolder<char> tmpPath = new char[MAX_LONGPATH];
   216|     if (options.DumpPathTemplate == nullptr)
   217|     {
   218|         if (::GetTempPathA(MAX_LONGPATH, tmpPath) == 0)
   219|         {
   220|             printf_error("GetTempPath failed %s", GetLastErrorString().c_str());
   221|             return ::GetLastError();
   222|         }
   223|         exitCode = strcat_s(tmpPath, MAX_LONGPATH, DEFAULT_DUMP_TEMPLATE);
   224|         if (exitCode != 0)
   225|         {
   226|             printf_error("strcat_s failed (%d)", exitCode);
   227|             return exitCode;
   228|         }
   229|         options.DumpPathTemplate = tmpPath;
   230|     }
   231|     if (CreateDump(options))
   232|     {
   233|         printf_status("Dump successfully written in %llums\n", GetTimeStamp() - g_startTime);
   234|     }
   235|     else
   236|     {
   237|         printf_error("Failure took %llums\n", GetTimeStamp() - g_startTime);
   238|         exitCode = -1;
   239|     }
   240|     fflush(g_stdout);
   241|     if (g_logfile != nullptr)
   242|     {
   243|         fflush(g_logfile);
   244|         fclose(g_logfile);
   245|     }
   246| #ifdef HOST_UNIX
   247|     PAL_TerminateEx(exitCode);
   248| #endif
   249|     return exitCode;
   250| }
   251| std::string
   252| GetLastErrorString()
   253| {
   254|     DWORD error = GetLastError();
   255|     std::string result;
   256| #ifdef HOST_WINDOWS
   257|     LPSTR messageBuffer;
   258|     DWORD length = FormatMessage(
   259|         FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
   260|         NULL,
   261|         error,
   262|         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
   263|         (LPTSTR)&messageBuffer,
   264|         0,
   265|         NULL);
   266|     if (length > 0)
   267|     {
   268|         result.append(messageBuffer, length);
   269|         LocalFree(messageBuffer);
   270|         size_t found = result.find_last_of('\r');
   271|         if (found != std::string::npos)
   272|         {
   273|             result.erase(found);
   274|         }
   275|         result.append(" ");
   276|     }
   277| #endif
   278|     char buffer[64];
   279|     snprintf(buffer, sizeof(buffer), "(%d)", error);
   280|     result.append(buffer);
   281|     return result;
   282| }
   283| void
   284| printf_status(const char* format, ...)
   285| {
   286|     va_list args;
   287|     va_start(args, format);
   288|     if (g_logfile == nullptr)
   289|     {
   290|         fprintf(g_stdout, "[createdump] ");
   291|     }
   292|     vfprintf(g_stdout, format, args);
   293|     fflush(g_stdout);
   294|     va_end(args);
   295| }
   296| void
   297| printf_error(const char* format, ...)
   298| {
   299|     va_list args;
   300|     va_start(args, format);
   301|     if (g_logfile != nullptr)
   302|     {
   303|         va_list args2;
   304|         va_copy(args2, args);
   305|         vfprintf(g_logfile, format, args2);
   306|         fflush(g_logfile);
   307|     }
   308|     fprintf(stderr, "[createdump] ");
   309|     vfprintf(stderr, format, args);
   310|     fflush(stderr);
   311|     va_end(args);
   312| }
   313| uint64_t
   314| GetTickFrequency()
   315| {
   316|     LARGE_INTEGER ret;
   317|     ZeroMemory(&ret, sizeof(LARGE_INTEGER));
   318|     QueryPerformanceFrequency(&ret);
   319|     return ret.QuadPart;
   320| }
   321| uint64_t
   322| GetTimeStamp()
   323| {
   324|     LARGE_INTEGER ret;
   325|     ZeroMemory(&ret, sizeof(LARGE_INTEGER));
   326|     QueryPerformanceCounter(&ret);
   327|     return ret.QuadPart / g_ticksPerMS;
   328| }
   329| #ifdef HOST_UNIX
   330| static void
   331| trace_prefix()
   332| {
   333|     if (g_logfile == nullptr)
   334|     {
   335|         fprintf(g_stdout, "[createdump] ");
   336|     }
   337|     fprintf(g_stdout, "%08" PRIx64 " ", GetTimeStamp());
   338| }
   339| void
   340| trace_printf(const char* format, ...)
   341| {
   342|     if (g_diagnostics)
   343|     {
   344|         va_list args;
   345|         va_start(args, format);
   346|         trace_prefix();
   347|         vfprintf(g_stdout, format, args);
   348|         fflush(g_stdout);
   349|         va_end(args);
   350|     }
   351| }
   352| void
   353| trace_verbose_printf(const char* format, ...)
   354| {
   355|     if (g_diagnosticsVerbose)
   356|     {
   357|         va_list args;
   358|         va_start(args, format);
   359|         trace_prefix();
   360|         vfprintf(g_stdout, format, args);
   361|         fflush(g_stdout);
   362|         va_end(args);
   363|     }
   364| }
   365| void
   366| CrashInfo::Trace(const char* format, ...)
   367| {
   368|     if (g_diagnostics)
   369|     {
   370|         va_list args;
   371|         va_start(args, format);
   372|         trace_prefix();
   373|         vfprintf(g_stdout, format, args);
   374|         fflush(g_stdout);
   375|         va_end(args);
   376|     }
   377| }
   378| void
   379| CrashInfo::TraceVerbose(const char* format, ...)
   380| {
   381|     if (g_diagnosticsVerbose)
   382|     {
   383|         va_list args;
   384|         va_start(args, format);
   385|         trace_prefix();
   386|         vfprintf(g_stdout, format, args);
   387|         fflush(g_stdout);
   388|         va_end(args);
   389|     }
   390| }
   391| #endif // HOST_UNIX


# ====================================================================
# FILE: src/coreclr/debug/createdump/threadinfo.cpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-304 ---
     1| #include "createdump.h"
     2| #ifndef THUMB_CODE
     3| #define THUMB_CODE 1
     4| #endif
     5| #ifndef __GLIBC__
     6| typedef int __ptrace_request;
     7| #endif
     8| extern CrashInfo* g_crashInfo;
     9| static void
    10| GetFrameLocation(CONTEXT* pContext, uint64_t* ip, uint64_t* sp)
    11| {
    12| #if defined(__x86_64__)
    13|     *ip = pContext->Rip;
    14|     *sp = pContext->Rsp;
    15| #elif defined(__i386__)
    16|     *ip = pContext->Eip;
    17|     *sp = pContext->Esp;
    18| #elif defined(__aarch64__)
    19|     *ip = pContext->Pc;
    20|     *sp = pContext->Sp;
    21| #elif defined(__arm__)
    22|     *ip = pContext->Pc & ~THUMB_CODE;
    23|     *sp = pContext->Sp;
    24| #endif
    25| }
    26| static BOOL
    27| ReadMemoryAdapter(PVOID address, PVOID buffer, SIZE_T size)
    28| {
    29|     return g_crashInfo->ReadMemory(address, buffer, size);
    30| }
    31| void
    32| ThreadInfo::UnwindNativeFrames(CONTEXT* pContext)
    33| {
    34|     uint64_t previousSp = 0;
    35|     uint64_t previousIp = 0;
    36|     int ipMatchCount = 0;
    37|     while (true)
    38|     {
    39|         uint64_t ip = 0, sp = 0;
    40|         GetFrameLocation(pContext, &ip, &sp);
    41| #if defined(__aarch64__)
    42|         if (sp == previousSp && ip != previousIp)
    43|         {
    44|             sp++;
    45|         }
    46| #endif
    47|         if (ip == 0 || sp <= previousSp) {
    48|             TRACE_VERBOSE("Unwind: sp not increasing or ip == 0 sp %p ip %p\n", (void*)sp, (void*)ip);
    49|             break;
    50|         }
    51|         if (ip == previousIp)
    52|         {
    53|             if (ipMatchCount++ > 1000)
    54|             {
    55|                 TRACE("Unwind: same ip %p over 1000 times\n", (void*)ip);
    56|                 break;
    57|             }
    58|         }
    59|         else
    60|         {
    61|             ipMatchCount = 0;
    62|         }
    63|         m_crashInfo.InsertMemoryRegion(ip - PAGE_SIZE, PAGE_SIZE * 2);
    64|         uint64_t baseAddress = m_crashInfo.GetBaseAddressFromAddress(ip);
    65|         if (baseAddress == 0) {
    66|             TRACE_VERBOSE("Unwind: module base not found ip %p\n", (void*)ip);
    67|             break;
    68|         }
    69|         ULONG64 functionStart;
    70|         if (!PAL_VirtualUnwindOutOfProc(pContext, nullptr, &functionStart, baseAddress, ReadMemoryAdapter)) {
    71|             TRACE("Unwind: PAL_VirtualUnwindOutOfProc returned false\n");
    72|             break;
    73|         }
    74|         if (m_crashInfo.GatherFrames())
    75|         {
    76|             StackFrame frame(baseAddress, ip, sp, ip - functionStart);
    77|             AddStackFrame(frame);
    78|         }
    79|         previousSp = sp;
    80|         previousIp = ip;
    81|     }
    82| }
    83| bool
    84| ThreadInfo::UnwindThread(IXCLRDataProcess* pClrDataProcess, ISOSDacInterface* pSos)
    85| {
    86|     TRACE("Unwind: thread %04x\n", Tid());
    87|     CONTEXT context;
    88|     GetThreadContext(CONTEXT_ALL, &context);
    89|     UnwindNativeFrames(&context);
    90|     if (pClrDataProcess != nullptr)
    91|     {
    92|         ReleaseHolder<IXCLRDataTask> pTask;
    93|         ReleaseHolder<IXCLRDataStackWalk> pStackwalk;
    94|         if (SUCCEEDED(pClrDataProcess->GetTaskByOSThreadID(Tid(), &pTask)))
    95|         {
    96|             pTask->CreateStackWalk(
    97|                 CLRDATA_SIMPFRAME_UNRECOGNIZED |
    98|                 CLRDATA_SIMPFRAME_MANAGED_METHOD |
    99|                 CLRDATA_SIMPFRAME_RUNTIME_MANAGED_CODE |
   100|                 CLRDATA_SIMPFRAME_RUNTIME_UNMANAGED_CODE,
   101|                 &pStackwalk);
   102|         }
   103|         if (pStackwalk != nullptr)
   104|         {
   105|             TRACE("Unwind: managed frames\n");
   106|             m_managed = true;
   107|             ReleaseHolder<IXCLRDataExceptionState> pException;
   108|             HRESULT hr = pTask->GetCurrentExceptionState(&pException);
   109|             if (FAILED(hr))
   110|             {
   111|                 hr = pTask->GetLastExceptionState(&pException);
   112|             }
   113|             if (SUCCEEDED(hr))
   114|             {
   115|                 TRACE("Unwind: found managed exception\n");
   116|                 ReleaseHolder<IXCLRDataValue> pExceptionValue;
   117|                 if (SUCCEEDED(pException->GetManagedObject(&pExceptionValue)))
   118|                 {
   119|                     CLRDATA_ADDRESS exceptionObject;
   120|                     if (SUCCEEDED(pExceptionValue->GetAddress(&exceptionObject)))
   121|                     {
   122|                         m_exceptionObject = exceptionObject;
   123|                         if (pSos != nullptr)
   124|                         {
   125|                             DacpExceptionObjectData exceptionData;
   126|                             if (SUCCEEDED(exceptionData.Request(pSos, exceptionObject)))
   127|                             {
   128|                                 m_exceptionHResult = exceptionData.HResult;
   129|                             }
   130|                         }
   131|                         TRACE("Unwind: exception object %p exception hresult %08x\n", (void*)m_exceptionObject, m_exceptionHResult);
   132|                     }
   133|                     ReleaseHolder<IXCLRDataTypeInstance> pExceptionType;
   134|                     if (SUCCEEDED(pExceptionValue->GetType(&pExceptionType)))
   135|                     {
   136|                         ArrayHolder<WCHAR> typeName = new WCHAR[MAX_LONGPATH + 1];
   137|                         if (SUCCEEDED(pExceptionType->GetName(0, MAX_LONGPATH, nullptr, typeName.GetPtr())))
   138|                         {
   139|                             m_exceptionType = FormatString("%S", typeName.GetPtr());
   140|                             TRACE("Unwind: exception type %s\n", m_exceptionType.c_str());
   141|                         }
   142|                     }
   143|                 }
   144|             }
   145|             do
   146|             {
   147|                 if (pStackwalk->GetContext(CONTEXT_ALL, sizeof(context), nullptr, (BYTE *)&context) != S_OK) {
   148|                     TRACE("Unwind: stack walker GetContext FAILED\n");
   149|                     break;
   150|                 }
   151|                 if (m_crashInfo.GatherFrames())
   152|                 {
   153|                     GatherStackFrames(&context, pStackwalk);
   154|                 }
   155|                 UnwindNativeFrames(&context);
   156|             } while (pStackwalk->Next() == S_OK);
   157|         }
   158|     }
   159|     return true;
   160| }
   161| void
   162| ThreadInfo::GatherStackFrames(CONTEXT* pContext, IXCLRDataStackWalk* pStackwalk)
   163| {
   164|     uint64_t ip = 0, sp = 0;
   165|     GetFrameLocation(pContext, &ip, &sp);
   166|     uint64_t moduleAddress = 0;
   167|     mdMethodDef token = 0;
   168|     uint32_t nativeOffset = 0;
   169|     uint32_t ilOffset = 0;
   170|     ReleaseHolder<IXCLRDataMethodInstance> pMethod;
   171|     ReleaseHolder<IXCLRDataFrame> pFrame;
   172|     if (SUCCEEDED(pStackwalk->GetFrame(&pFrame)))
   173|     {
   174|         CLRDataSimpleFrameType simpleType;
   175|         CLRDataDetailedFrameType detailedType;
   176|         pFrame->GetFrameType(&simpleType, &detailedType);
   177|         if ((simpleType & (CLRDATA_SIMPFRAME_MANAGED_METHOD | CLRDATA_SIMPFRAME_RUNTIME_MANAGED_CODE)) != 0)
   178|         {
   179|             if (SUCCEEDED(pFrame->GetMethodInstance(&pMethod)))
   180|             {
   181|                 ReleaseHolder<IXCLRDataModule> pModule;
   182|                 if (SUCCEEDED(pMethod->GetTokenAndScope(&token, &pModule)))
   183|                 {
   184|                     DacpGetModuleData moduleData;
   185|                     if (SUCCEEDED(moduleData.Request(pModule)))
   186|                     {
   187|                         moduleAddress = moduleData.LoadedPEAddress;
   188|                     }
   189|                     else
   190|                     {
   191|                         TRACE("Unwind: DacpGetModuleData.Request sp %p ip %p FAILED\n", (void*)sp, (void*)ip);
   192|                     }
   193|                 }
   194|                 else
   195|                 {
   196|                     TRACE("Unwind: GetTokenAndScope sp %p ip %p FAILED\n", (void*)sp, (void*)ip);
   197|                 }
   198|                 if (FAILED(pMethod->GetILOffsetsByAddress(ip, 1, NULL, &ilOffset)))
   199|                 {
   200|                     TRACE("Unwind: GetILOffsetsByAddress sp %p ip %p FAILED\n", (void*)sp, (void*)ip);
   201|                 }
   202|                 CLRDATA_ADDRESS startAddress;
   203|                 if (SUCCEEDED(pMethod->GetRepresentativeEntryAddress(&startAddress)))
   204|                 {
   205|                     nativeOffset = ip - startAddress;
   206|                 }
   207|                 else
   208|                 {
   209|                     TRACE("Unwind: GetRepresentativeEntryAddress sp %p ip %p FAILED\n", (void*)sp, (void*)ip);
   210|                 }
   211|             }
   212|             else
   213|             {
   214|                 TRACE("Unwind: GetMethodInstance sp %p ip %p FAILED\n", (void*)sp, (void*)ip);
   215|             }
   216|         }
   217|         else
   218|         {
   219|             TRACE("Unwind: simpleType %08x detailedType %08x\n", simpleType, detailedType);
   220|         }
   221|     }
   222|     StackFrame frame(moduleAddress, ip, sp, pMethod.Detach(), nativeOffset, token, ilOffset);
   223|     AddStackFrame(frame);
   224| }
   225| void
   226| ThreadInfo::AddStackFrame(const StackFrame& frame)
   227| {
   228|     const std::set<StackFrame>::iterator& found = m_frames.find(frame);
   229|     if (found == m_frames.end())
   230|     {
   231|         if (m_exceptionHResult == STACK_OVERFLOW_EXCEPTION)
   232|         {
   233|             if (m_beginRepeat == m_frames.end())
   234|             {
   235|                 for (auto iterator = m_frames.cbegin(); iterator != m_frames.cend(); ++iterator)
   236|                 {
   237|                     if (frame.InstructionPointer() == iterator->InstructionPointer())
   238|                     {
   239|                         m_repeatedFrames++;
   240|                         m_beginRepeat = iterator;
   241|                         TRACE("Unwind: begin repeat sp %p ip %p\n", (void*)frame.StackPointer(), (void*)frame.InstructionPointer());
   242|                         return;
   243|                     }
   244|                 }
   245|             }
   246|             if (m_endRepeat == m_frames.end())
   247|             {
   248|                 for (auto iterator = m_beginRepeat; iterator != m_endRepeat; ++iterator)
   249|                 {
   250|                     if (frame.InstructionPointer() == iterator->InstructionPointer())
   251|                     {
   252|                         m_repeatedFrames++;
   253|                         return;
   254|                     }
   255|                 }
   256|             }
   257|         }
   258|         std::pair<std::set<StackFrame>::iterator, bool> result = m_frames.insert(frame);
   259|         assert(result.second);
   260|         TRACE("Unwind: sp %p ip %p off %08x mod %p%c\n",
   261|             (void*)frame.StackPointer(), (void*)frame.InstructionPointer(), frame.NativeOffset(), (void*)frame.ModuleAddress(), frame.IsManaged() ? '*' : ' ');
   262|         if (m_beginRepeat != m_frames.end() && m_endRepeat == m_frames.end())
   263|         {
   264|             TRACE("Unwind: end repeat sp %p ip %p\n", (void*)frame.StackPointer(), (void*)frame.InstructionPointer());
   265|             m_endRepeat = result.first;
   266|             int framesRepeated = 0;
   267|             for (auto iterator = m_beginRepeat; iterator != m_endRepeat; ++iterator)
   268|             {
   269|                 framesRepeated++;
   270|             }
   271|             m_repeatedFrames = framesRepeated > 0 && m_repeatedFrames >= framesRepeated ? (m_repeatedFrames / framesRepeated) + 1 : 0;
   272|         }
   273|     }
   274| }
   275| void
   276| ThreadInfo::GetThreadStack()
   277| {
   278|     uint64_t startAddress = GetStackPointer() & PAGE_MASK;
   279|     size_t size = 4 * PAGE_SIZE;
   280|     if (startAddress != 0)
   281|     {
   282|         MemoryRegion search(0, startAddress, startAddress + PAGE_SIZE);
   283|         const MemoryRegion* region = CrashInfo::SearchMemoryRegions(m_crashInfo.OtherMappings(), search);
   284|         if (region != nullptr)
   285|         {
   286|             size = region->EndAddress() - startAddress;
   287|             if (g_diagnostics)
   288|             {
   289|                 TRACE("Thread %04x stack found in other mapping (size %08zx): ", m_tid, size);
   290|                 region->Trace();
   291|             }
   292|         }
   293|         m_crashInfo.InsertMemoryRegion(startAddress, size);
   294|     }
   295|     else
   296|     {
   297|         TRACE("Thread %04x null stack pointer\n", m_tid);
   298|     }
   299| }
   300| bool
   301| ThreadInfo::IsCrashThread() const
   302| {
   303|     return m_tid == m_crashInfo.CrashThread();
   304| }


# ====================================================================
# FILE: src/coreclr/debug/createdump/threadinfo.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-146 ---
     1| class CrashInfo;
     2| #if defined(__aarch64__)
     3| #define MCREG_Fp(mc)      ((mc).regs[29])
     4| #define MCREG_Lr(mc)      ((mc).regs[30])
     5| #define MCREG_Sp(mc)      ((mc).sp)
     6| #define MCREG_Pc(mc)      ((mc).pc)
     7| #define MCREG_Cpsr(mc)    ((mc).pstate)
     8| #endif
     9| #if defined(__loongarch64)
    10| #define MCREG_Ra(mc)      ((mc).gpr[1])
    11| #define MCREG_Fp(mc)      ((mc).gpr[22])
    12| #define MCREG_Sp(mc)      ((mc).gpr[3])
    13| #define MCREG_Pc(mc)      ((mc).pc)
    14| #endif
    15| #define FPREG_ErrorOffset(fpregs) *(DWORD*)&((fpregs).rip)
    16| #define FPREG_ErrorSelector(fpregs) *(((WORD*)&((fpregs).rip)) + 2)
    17| #define FPREG_DataOffset(fpregs) *(DWORD*)&((fpregs).rdp)
    18| #define FPREG_DataSelector(fpregs) *(((WORD*)&((fpregs).rdp)) + 2)
    19| #if defined(__arm__)
    20| #define user_regs_struct user_regs
    21| #define user_fpregs_struct user_fpregs
    22| #elif defined(__loongarch64)
    23| struct user_fpregs_struct
    24| {
    25|   unsigned long long  fpregs[32];
    26|   unsigned long       fpscr;
    27| } __attribute__((__packed__));
    28| #endif
    29| #if defined(__aarch64__)
    30| #define user_fpregs_struct user_fpsimd_struct
    31| #endif
    32| #if defined(__arm__) && defined(__VFP_FP__) && !defined(__SOFTFP__)
    33| struct user_vfpregs_struct
    34| {
    35|   unsigned long long  fpregs[32];
    36|   unsigned long       fpscr;
    37| } __attribute__((__packed__));
    38| #endif
    39| #define STACK_OVERFLOW_EXCEPTION    0x800703e9
    40| class ThreadInfo
    41| {
    42| private:
    43|     CrashInfo& m_crashInfo;                     // crashinfo instance
    44|     pid_t m_tid;                                // thread id
    45|     pid_t m_ppid;                               // parent process
    46|     pid_t m_tgid;                               // thread group
    47|     bool m_managed;                             // if true, thread has managed code running
    48|     uint64_t m_exceptionObject;                 // exception object address
    49|     std::string m_exceptionType;                // exception type
    50|     uint32_t m_exceptionHResult;                // exception HRESULT
    51|     std::set<StackFrame> m_frames;              // stack frames
    52|     int m_repeatedFrames;                       // number of repeated frames
    53|     std::set<StackFrame>::const_iterator m_beginRepeat;   // beginning of stack overflow repeated frame sequence
    54|     std::set<StackFrame>::const_iterator m_endRepeat;     // end of repeated frame sequence
    55| #ifdef __APPLE__
    56|     mach_port_t m_port;                         // MacOS thread port
    57| #if defined(__x86_64__)
    58|     x86_thread_state64_t m_gpRegisters;         // MacOS general purpose registers
    59|     x86_float_state64_t m_fpRegisters;          // MacOS floating point registers
    60| #elif defined(__aarch64__)
    61|     arm_thread_state64_t m_gpRegisters;         // MacOS general purpose arm64 registers
    62|     arm_neon_state64_t m_fpRegisters;           // MacOS floating point arm64 registers
    63| #endif
    64| #else // __APPLE__
    65|     struct user_regs_struct m_gpRegisters;      // general purpose registers
    66|     struct user_fpregs_struct m_fpRegisters;    // floating point registers
    67| #if defined(__i386__)
    68|     struct user_fpxregs_struct m_fpxRegisters;  // x86 floating point registers
    69| #elif defined(__arm__) && defined(__VFP_FP__) && !defined(__SOFTFP__)
    70|     struct user_vfpregs_struct m_vfpRegisters;  // ARM VFP/NEON registers
    71| #endif
    72| #endif // __APPLE__
    73|     ThreadInfo(const ThreadInfo&) = delete;
    74|     void operator=(const ThreadInfo&) = delete;
    75| public:
    76| #ifdef __APPLE__
    77|     ThreadInfo(CrashInfo& crashInfo, pid_t tid, mach_port_t port);
    78|     inline mach_port_t Port() const { return m_port; }
    79| #else
    80|     ThreadInfo(CrashInfo& crashInfo, pid_t tid);
    81| #endif
    82|     ~ThreadInfo();
    83|     bool Initialize();
    84|     bool UnwindThread(IXCLRDataProcess* pClrDataProcess, ISOSDacInterface* pSos);
    85|     void GetThreadStack();
    86|     void GetThreadContext(uint32_t flags, CONTEXT* context) const;
    87|     inline pid_t Tid() const { return m_tid; }
    88|     inline pid_t Ppid() const { return m_ppid; }
    89|     inline pid_t Tgid() const { return m_tgid; }
    90|     inline bool IsManaged() const { return m_managed; }
    91|     inline uint64_t ManagedExceptionObject() const { return m_exceptionObject; }
    92|     inline uint32_t ManagedExceptionHResult() const { return m_exceptionHResult; }
    93|     inline std::string ManagedExceptionType() const { return m_exceptionType; }
    94|     inline const std::set<StackFrame>& StackFrames() const { return m_frames; }
    95|     inline int NumRepeatedFrames() const { return m_repeatedFrames;  }
    96|     inline bool IsBeginRepeat(std::set<StackFrame>::const_iterator& iterator) const { return m_repeatedFrames > 0 && iterator == m_beginRepeat; }
    97|     inline bool IsEndRepeat(std::set<StackFrame>::const_iterator& iterator) const { return  m_repeatedFrames > 0 && iterator == m_endRepeat; }
    98| #ifdef __APPLE__
    99| #if defined(__x86_64__)
   100|     inline const x86_thread_state64_t* GPRegisters() const { return &m_gpRegisters; }
   101|     inline const x86_float_state64_t* FPRegisters() const { return &m_fpRegisters; }
   102|     inline const uint64_t GetInstructionPointer() const { return m_gpRegisters.__rip; }
   103|     inline const uint64_t GetFramePointer() const { return m_gpRegisters.__rbp; }
   104|     inline const uint64_t GetStackPointer() const { return m_gpRegisters.__rsp; }
   105| #elif defined(__aarch64__)
   106|     inline const arm_thread_state64_t* GPRegisters() const { return &m_gpRegisters; }
   107|     inline const arm_neon_state64_t* FPRegisters() const { return &m_fpRegisters; }
   108|     inline const uint64_t GetInstructionPointer() const { return arm_thread_state64_get_pc(m_gpRegisters); }
   109|     inline const uint64_t GetFramePointer() const { return arm_thread_state64_get_fp(m_gpRegisters); }
   110|     inline const uint64_t GetStackPointer() const { return arm_thread_state64_get_sp(m_gpRegisters); }
   111| #endif
   112| #else // __APPLE__
   113|     inline const user_regs_struct* GPRegisters() const { return &m_gpRegisters; }
   114|     inline const user_fpregs_struct* FPRegisters() const { return &m_fpRegisters; }
   115| #if defined(__i386__)
   116|     inline const user_fpxregs_struct* FPXRegisters() const { return &m_fpxRegisters; }
   117| #elif defined(__arm__) && defined(__VFP_FP__) && !defined(__SOFTFP__)
   118|     inline const user_vfpregs_struct* VFPRegisters() const { return &m_vfpRegisters; }
   119| #endif
   120| #if defined(__x86_64__)
   121|     inline const uint64_t GetInstructionPointer() const { return m_gpRegisters.rip; }
   122|     inline const uint64_t GetStackPointer() const { return m_gpRegisters.rsp; }
   123|     inline const uint64_t GetFramePointer() const { return m_gpRegisters.rbp; }
   124| #elif defined(__aarch64__)
   125|     inline const uint64_t GetInstructionPointer() const { return MCREG_Pc(m_gpRegisters); }
   126|     inline const uint64_t GetStackPointer() const { return MCREG_Sp(m_gpRegisters); }
   127|     inline const uint64_t GetFramePointer() const { return MCREG_Fp(m_gpRegisters); }
   128| #elif defined(__loongarch64)
   129|     inline const uint64_t GetInstructionPointer() const { return MCREG_Pc(m_gpRegisters); }
   130|     inline const uint64_t GetStackPointer() const { return MCREG_Sp(m_gpRegisters); }
   131|     inline const uint64_t GetFramePointer() const { return MCREG_Fp(m_gpRegisters); }
   132| #elif defined(__arm__)
   133|     inline const uint64_t GetInstructionPointer() const { return m_gpRegisters.ARM_pc; }
   134|     inline const uint64_t GetStackPointer() const { return m_gpRegisters.ARM_sp; }
   135|     inline const uint64_t GetFramePointer() const { return m_gpRegisters.ARM_fp; }
   136| #endif
   137| #endif // __APPLE__
   138|     bool IsCrashThread() const;
   139| private:
   140|     void UnwindNativeFrames(CONTEXT* pContext);
   141|     void GatherStackFrames(CONTEXT* pContext, IXCLRDataStackWalk* pStackwalk);
   142|     void AddStackFrame(const StackFrame& frame);
   143| #ifndef __APPLE__
   144|     bool GetRegistersWithPTrace();
   145| #endif
   146| };


# ====================================================================
# FILE: src/coreclr/gc/unix/events.cpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-245 ---
     1| #include <cstdint>
     2| #include <cstddef>
     3| #include <cassert>
     4| #include <memory>
     5| #include <mutex>
     6| #include <pthread.h>
     7| #include <errno.h>
     8| #include "config.gc.h"
     9| #include "common.h"
    10| #include "gcenv.structs.h"
    11| #include "gcenv.base.h"
    12| #include "gcenv.os.h"
    13| #include "globals.h"
    14| namespace
    15| {
    16| #if HAVE_PTHREAD_CONDATTR_SETCLOCK
    17| void TimeSpecAdd(timespec* time, uint32_t milliseconds)
    18| {
    19|     uint64_t nsec = time->tv_nsec + (uint64_t)milliseconds * tccMilliSecondsToNanoSeconds;
    20|     if (nsec >= tccSecondsToNanoSeconds)
    21|     {
    22|         time->tv_sec += nsec / tccSecondsToNanoSeconds;
    23|         nsec %= tccSecondsToNanoSeconds;
    24|     }
    25|     time->tv_nsec = nsec;
    26| }
    27| #endif // HAVE_PTHREAD_CONDATTR_SETCLOCK
    28| #if HAVE_CLOCK_GETTIME_NSEC_NP
    29| void NanosecondsToTimeSpec(uint64_t nanoseconds, timespec* t)
    30| {
    31|     t->tv_sec = nanoseconds / tccSecondsToNanoSeconds;
    32|     t->tv_nsec = nanoseconds % tccSecondsToNanoSeconds;
    33| }
    34| #endif // HAVE_CLOCK_GETTIME_NSEC_NP
    35| } // anonymous namespace
    36| class GCEvent::Impl
    37| {
    38|     pthread_cond_t m_condition;
    39|     pthread_mutex_t m_mutex;
    40|     bool m_manualReset;
    41|     bool m_state;
    42|     bool m_isValid;
    43| public:
    44|     Impl(bool manualReset, bool initialState)
    45|     : m_manualReset(manualReset),
    46|       m_state(initialState),
    47|       m_isValid(false)
    48|     {
    49|     }
    50|     bool Initialize()
    51|     {
    52|         pthread_condattr_t attrs;
    53|         int st = pthread_condattr_init(&attrs);
    54|         if (st != 0)
    55|         {
    56|             assert(!"Failed to initialize UnixEvent condition attribute");
    57|             return false;
    58|         }
    59| #if HAVE_PTHREAD_CONDATTR_SETCLOCK && !HAVE_CLOCK_GETTIME_NSEC_NP
    60|         st = pthread_condattr_setclock(&attrs, CLOCK_MONOTONIC);
    61|         if (st != 0)
    62|         {
    63|             assert(!"Failed to set UnixEvent condition variable wait clock");
    64|             return false;
    65|         }
    66| #endif // HAVE_PTHREAD_CONDATTR_SETCLOCK && !HAVE_CLOCK_GETTIME_NSEC_NP
    67|         st = pthread_mutex_init(&m_mutex, NULL);
    68|         if (st != 0)
    69|         {
    70|             assert(!"Failed to initialize UnixEvent mutex");
    71|             return false;
    72|         }
    73|         st = pthread_cond_init(&m_condition, &attrs);
    74|         if (st != 0)
    75|         {
    76|             assert(!"Failed to initialize UnixEvent condition variable");
    77|             st = pthread_mutex_destroy(&m_mutex);
    78|             assert(st == 0 && "Failed to destroy UnixEvent mutex");
    79|             return false;
    80|         }
    81|         m_isValid = true;
    82|         return true;
    83|     }
    84|     void CloseEvent()
    85|     {
    86|         if (m_isValid)
    87|         {
    88|             int st = pthread_mutex_destroy(&m_mutex);
    89|             assert(st == 0 && "Failed to destroy UnixEvent mutex");
    90|             st = pthread_cond_destroy(&m_condition);
    91|             assert(st == 0 && "Failed to destroy UnixEvent condition variable");
    92|         }
    93|     }
    94|     uint32_t Wait(uint32_t milliseconds, bool alertable)
    95|     {
    96|         UNREFERENCED_PARAMETER(alertable);
    97|         timespec endTime;
    98| #if HAVE_CLOCK_GETTIME_NSEC_NP
    99|         uint64_t endMachTime;
   100|         if (milliseconds != INFINITE)
   101|         {
   102|             uint64_t nanoseconds = (uint64_t)milliseconds * tccMilliSecondsToNanoSeconds;
   103|             NanosecondsToTimeSpec(nanoseconds, &endTime);
   104|             endMachTime = clock_gettime_nsec_np(CLOCK_UPTIME_RAW) + nanoseconds;
   105|         }
   106| #elif HAVE_PTHREAD_CONDATTR_SETCLOCK
   107|         if (milliseconds != INFINITE)
   108|         {
   109|             clock_gettime(CLOCK_MONOTONIC, &endTime);
   110|             TimeSpecAdd(&endTime, milliseconds);
   111|         }
   112| #else
   113| #error "Don't know how to perform timed wait on this platform"
   114| #endif
   115|         int st = 0;
   116|         pthread_mutex_lock(&m_mutex);
   117|         while (!m_state)
   118|         {
   119|             if (milliseconds == INFINITE)
   120|             {
   121|                 st = pthread_cond_wait(&m_condition, &m_mutex);
   122|             }
   123|             else
   124|             {
   125| #if HAVE_CLOCK_GETTIME_NSEC_NP
   126|                 st = pthread_cond_timedwait_relative_np(&m_condition, &m_mutex, &endTime);
   127|                 if ((st == 0) && !m_state)
   128|                 {
   129|                     uint64_t machTime = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
   130|                     if (machTime < endMachTime)
   131|                     {
   132|                         uint64_t remainingNanoseconds = endMachTime - machTime;
   133|                         NanosecondsToTimeSpec(remainingNanoseconds, &endTime);
   134|                     }
   135|                     else
   136|                     {
   137|                         st = ETIMEDOUT;
   138|                     }
   139|                 }
   140| #else // HAVE_CLOCK_GETTIME_NSEC_NP
   141|                 st = pthread_cond_timedwait(&m_condition, &m_mutex, &endTime);
   142| #endif // HAVE_CLOCK_GETTIME_NSEC_NP
   143|                 assert((st != ETIMEDOUT) || !m_state);
   144|             }
   145|             if (st != 0)
   146|             {
   147|                 break;
   148|             }
   149|         }
   150|         if ((st == 0) && !m_manualReset)
   151|         {
   152|             m_state = false;
   153|         }
   154|         pthread_mutex_unlock(&m_mutex);
   155|         uint32_t waitStatus;
   156|         if (st == 0)
   157|         {
   158|             waitStatus = WAIT_OBJECT_0;
   159|         }
   160|         else if (st == ETIMEDOUT)
   161|         {
   162|             waitStatus = WAIT_TIMEOUT;
   163|         }
   164|         else
   165|         {
   166|             waitStatus = WAIT_FAILED;
   167|         }
   168|         return waitStatus;
   169|     }
   170|     void Set()
   171|     {
   172|         pthread_mutex_lock(&m_mutex);
   173|         m_state = true;
   174|         pthread_cond_broadcast(&m_condition);
   175|         pthread_mutex_unlock(&m_mutex);
   176|     }
   177|     void Reset()
   178|     {
   179|         pthread_mutex_lock(&m_mutex);
   180|         m_state = false;
   181|         pthread_mutex_unlock(&m_mutex);
   182|     }
   183| };
   184| GCEvent::GCEvent()
   185|   : m_impl(nullptr)
   186| {
   187| }
   188| void GCEvent::CloseEvent()
   189| {
   190|     assert(m_impl != nullptr);
   191|     m_impl->CloseEvent();
   192| }
   193| void GCEvent::Set()
   194| {
   195|     assert(m_impl != nullptr);
   196|     m_impl->Set();
   197| }
   198| void GCEvent::Reset()
   199| {
   200|     assert(m_impl != nullptr);
   201|     m_impl->Reset();
   202| }
   203| uint32_t GCEvent::Wait(uint32_t timeout, bool alertable)
   204| {
   205|     assert(m_impl != nullptr);
   206|     return m_impl->Wait(timeout, alertable);
   207| }
   208| bool GCEvent::CreateAutoEventNoThrow(bool initialState)
   209| {
   210|     return CreateOSAutoEventNoThrow(initialState);
   211| }
   212| bool GCEvent::CreateManualEventNoThrow(bool initialState)
   213| {
   214|     return CreateOSManualEventNoThrow(initialState);
   215| }
   216| bool GCEvent::CreateOSAutoEventNoThrow(bool initialState)
   217| {
   218|     assert(m_impl == nullptr);
   219|     std::unique_ptr<GCEvent::Impl> event(new (std::nothrow) GCEvent::Impl(false, initialState));
   220|     if (!event)
   221|     {
   222|         return false;
   223|     }
   224|     if (!event->Initialize())
   225|     {
   226|         return false;
   227|     }
   228|     m_impl = event.release();
   229|     return true;
   230| }
   231| bool GCEvent::CreateOSManualEventNoThrow(bool initialState)
   232| {
   233|     assert(m_impl == nullptr);
   234|     std::unique_ptr<GCEvent::Impl> event(new (std::nothrow) GCEvent::Impl(true, initialState));
   235|     if (!event)
   236|     {
   237|         return false;
   238|     }
   239|     if (!event->Initialize())
   240|     {
   241|         return false;
   242|     }
   243|     m_impl = event.release();
   244|     return true;
   245| }


# ====================================================================
# FILE: src/coreclr/inc/clrconfigvalues.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-539 ---
     1| CONFIG_DWORD_INFO(INTERNAL_EnableFullDebug, W("EnableFullDebug"), 0, "Heavy-weight checking for AD boundary violations (AD leaks)")
     2| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchEnabled, W("JitPitchEnabled"), (DWORD)0, "Set it to 1 to enable Jit Pitching")
     3| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchMemThreshold, W("JitPitchMemThreshold"), (DWORD)0, "Do Jit Pitching when code heap usage is larger than this (in bytes)")
     4| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchMethodSizeThreshold, W("JitPitchMethodSizeThreshold"), (DWORD)0, "Do Jit Pitching for methods whose native code size larger than this (in bytes)")
     5| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchTimeInterval, W("JitPitchTimeInterval"), (DWORD)0, "Time interval between Jit Pitchings in ms")
     6| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchPrintStat, W("JitPitchPrintStat"), (DWORD)0, "Print statistics about Jit Pitching")
     7| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchMinVal, W("JitPitchMinVal"), (DWORD)0, "Do Jit Pitching if the value of the inner counter greater than this value (for debugging purpose only)")
     8| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchMaxVal, W("JitPitchMaxVal"), (DWORD)0xffffffff, "Do Jit Pitching the value of the inner counter less then this value (for debuggin purpose only)")
     9| CONFIG_DWORD_INFO(INTERNAL_GetAssemblyIfLoadedIgnoreRidMap, W("GetAssemblyIfLoadedIgnoreRidMap"), 0, "Used to force loader to ignore assemblies cached in the rid-map")
    10| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_BreakOnBadExit, W("BreakOnBadExit"), 0, "")
    11| CONFIG_STRING_INFO(INTERNAL_BreakOnClassBuild, W("BreakOnClassBuild"), "Very useful for debugging class layout code.")
    12| CONFIG_STRING_INFO(INTERNAL_BreakOnClassLoad, W("BreakOnClassLoad"), "Very useful for debugging class loading code.")
    13| CONFIG_STRING_INFO(INTERNAL_BreakOnComToClrNativeInfoInit, W("BreakOnComToClrNativeInfoInit"), "Throws an assert when native information about a COM -> CLR call are about to be gathered.")
    14| CONFIG_DWORD_INFO(INTERNAL_BreakOnDebugBreak, W("BreakOnDebugBreak"), 0, "Allows an assert in debug builds when a user break is hit")
    15| CONFIG_DWORD_INFO(INTERNAL_BreakOnDILoad, W("BreakOnDILoad"), 0, "Allows an assert when the DI is loaded")
    16| CONFIG_DWORD_INFO(INTERNAL_BreakOnDumpToken, W("BreakOnDumpToken"), 0xffffffff, "Breaks when using internal logging on a particular token value.")
    17| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_BreakOnEELoad, W("BreakOnEELoad"), 0, "")
    18| CONFIG_DWORD_INFO(INTERNAL_BreakOnEEShutdown, W("BreakOnEEShutdown"), 0, "")
    19| CONFIG_DWORD_INFO(INTERNAL_BreakOnExceptionInGetThrowable, W("BreakOnExceptionInGetThrowable"), 0, "")
    20| CONFIG_DWORD_INFO(INTERNAL_BreakOnFindMethod, W("BreakOnFindMethod"), 0, "Breaks in findMethodInternal when it searches for the specified token.")
    21| CONFIG_DWORD_INFO(INTERNAL_BreakOnFirstPass, W("BreakOnFirstPass"), 0, "")
    22| CONFIG_DWORD_INFO(INTERNAL_BreakOnHR, W("BreakOnHR"), 0, "Debug.cpp, IfFailxxx use this macro to stop if hr matches ")
    23| CONFIG_STRING_INFO(INTERNAL_BreakOnInstantiation, W("BreakOnInstantiation"), "Very useful for debugging generic class instantiation.")
    24| CONFIG_STRING_INFO(INTERNAL_BreakOnInteropStubSetup, W("BreakOnInteropStubSetup"), "Throws an assert when marshaling stub for the given method is about to be built.")
    25| CONFIG_STRING_INFO(INTERNAL_BreakOnInteropVTableBuild, W("BreakOnInteropVTableBuild"), "Specifies a type name for which an assert should be thrown when building interop v-table.")
    26| CONFIG_STRING_INFO(INTERNAL_BreakOnMethodName, W("BreakOnMethodName"), "Very useful for debugging method override placement code.")
    27| CONFIG_DWORD_INFO(INTERNAL_BreakOnNotify, W("BreakOnNotify"), 0, "")
    28| CONFIG_DWORD_INFO(INTERNAL_BreakOnSecondPass, W("BreakOnSecondPass"), 0, "")
    29| CONFIG_STRING_INFO(INTERNAL_BreakOnStructMarshalSetup, W("BreakOnStructMarshalSetup"), "Throws an assert when field marshalers for the given type with layout are about to be created.")
    30| CONFIG_DWORD_INFO(INTERNAL_BreakOnUEF, W("BreakOnUEF"), 0, "")
    31| CONFIG_DWORD_INFO(INTERNAL_BreakOnUncaughtException, W("BreakOnUncaughtException"), 0, "")
    32| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableDiagnostics, W("EnableDiagnostics"), 1, "Allows the debugger, profiler, and EventPipe diagnostics to be disabled")
    33| CONFIG_DWORD_INFO(INTERNAL_D__FCE, W("D::FCE"), 0, "Allows an assert when crawling the managed stack for an exception handler")
    34| CONFIG_DWORD_INFO(INTERNAL_DbgBreakIfLocksUnavailable, W("DbgBreakIfLocksUnavailable"), 0, "Allows an assert when the debugger can't take a lock ")
    35| CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnErr, W("DbgBreakOnErr"), 0, "Allows an assert when we get a failing hresult")
    36| CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnMapPatchToDJI, W("DbgBreakOnMapPatchToDJI"), 0, "Allows an assert when mapping a patch to an address")
    37| CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnRawInt3, W("DbgBreakOnRawInt3"), 0, "Allows an assert for test coverage for debug break or other int3 breaks")
    38| CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnSendBreakpoint, W("DbgBreakOnSendBreakpoint"), 0, "Allows an assert when sending a breakpoint to the right side")
    39| CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnSetIP, W("DbgBreakOnSetIP"), 0, "Allows an assert when setting the IP")
    40| CONFIG_DWORD_INFO(INTERNAL_DbgCheckInt3, W("DbgCheckInt3"), 0, "Asserts if the debugger explicitly writes int3 instead of calling SetUnmanagedBreakpoint")
    41| CONFIG_DWORD_INFO(INTERNAL_DbgDACAssertOnMismatch, W("DbgDACAssertOnMismatch"), 0, "Allows an assert when the mscordacwks and mscorwks dll versions don't match")
    42| CONFIG_DWORD_INFO(INTERNAL_DbgDACEnableAssert, W("DbgDACEnableAssert"), 0, "Enables extra validity checking in DAC - assumes target isn't corrupt")
    43| RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgDACSkipVerifyDlls, W("DbgDACSkipVerifyDlls"), 0, "Allows disabling the check to ensure mscordacwks and mscorwks dll versions match")
    44| CONFIG_DWORD_INFO(INTERNAL_DbgDelayHelper, W("DbgDelayHelper"), 0, "Varies the wait in the helper thread startup for testing race between threads")
    45| RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgDisableDynamicSymsCompat, W("DbgDisableDynamicSymsCompat"), 0, "")
    46| CONFIG_DWORD_INFO(INTERNAL_DbgDisableTargetConsistencyAsserts, W("DbgDisableTargetConsistencyAsserts"), 0, "Allows explicitly testing with corrupt targets")
    47| CONFIG_DWORD_INFO(INTERNAL_DbgExtraThreads, W("DbgExtraThreads"), 0, "Allows extra unmanaged threads to run and throw debug events for stress testing")
    48| CONFIG_DWORD_INFO(INTERNAL_DbgExtraThreadsCantStop, W("DbgExtraThreadsCantStop"), 0, "Allows extra unmanaged threads in can't stop region to run and throw debug events for stress testing")
    49| CONFIG_DWORD_INFO(INTERNAL_DbgExtraThreadsIB, W("DbgExtraThreadsIB"), 0, "Allows extra in-band unmanaged threads to run and throw debug events for stress testing")
    50| CONFIG_DWORD_INFO(INTERNAL_DbgExtraThreadsOOB, W("DbgExtraThreadsOOB"), 0, "Allows extra out of band unmanaged threads to run and throw debug events for stress testing")
    51| CONFIG_DWORD_INFO(INTERNAL_DbgFaultInHandleIPCEvent, W("DbgFaultInHandleIPCEvent"), 0, "Allows testing the unhandled event filter")
    52| CONFIG_DWORD_INFO(INTERNAL_DbgInjectFEE, W("DbgInjectFEE"), 0, "Allows injecting a fatal execution error for testing Watson")
    53| CONFIG_DWORD_INFO(INTERNAL_DbgLeakCheck, W("DbgLeakCheck"), 0, "Allows checking for leaked Cordb objects")
    54| CONFIG_DWORD_INFO(INTERNAL_DbgNo2ndChance, W("DbgNo2ndChance"), 0, "Allows breaking on (and catching bogus) 2nd chance exceptions")
    55| CONFIG_DWORD_INFO(INTERNAL_DbgNoDebugger, W("DbgNoDebugger"), 0, "Allows breaking if we don't want to lazily initialize the debugger")
    56| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgNoForceContinue, W("DbgNoForceContinue"), 1, "Used to force a continue on longhorn")
    57| CONFIG_DWORD_INFO(INTERNAL_DbgNoOpenMDByFile, W("DbgNoOpenMDByFile"), 0, "Allows opening MD by memory for perf testing")
    58| CONFIG_DWORD_INFO(INTERNAL_DbgOOBinFEEE, W("DbgOOBinFEEE"), 0, "Allows forcing oob breakpoints when a fatal error occurs")
    59| CONFIG_DWORD_INFO(INTERNAL_DbgPingInterop, W("DbgPingInterop"), 0, "Allows checking for deadlocks in interop debugging")
    60| CONFIG_DWORD_INFO(INTERNAL_DbgRace, W("DbgRace"), 0, "Allows pausing for native debug events to get hijicked")
    61| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgRedirect, W("DbgRedirect"), 0, "Allows for redirecting the event pipeline")
    62| RETAIL_CONFIG_STRING_INFO(EXTERNAL_DbgRedirectApplication, W("DbgRedirectApplication"), "Specifies the auxiliary debugger application to launch.")
    63| RETAIL_CONFIG_STRING_INFO(EXTERNAL_DbgRedirectAttachCmd, W("DbgRedirectAttachCmd"), "Specifies command parameters for attaching the auxiliary debugger.")
    64| RETAIL_CONFIG_STRING_INFO(EXTERNAL_DbgRedirectCommonCmd, W("DbgRedirectCommonCmd"), "Specifies a command line format string for the auxiliary debugger.")
    65| RETAIL_CONFIG_STRING_INFO(EXTERNAL_DbgRedirectCreateCmd, W("DbgRedirectCreateCmd"), "Specifies command parameters when creating the auxiliary debugger.")
    66| CONFIG_DWORD_INFO(INTERNAL_DbgShortcutCanary, W("DbgShortcutCanary"), 0, "Allows a way to force canary to fail to be able to test failure paths")
    67| CONFIG_DWORD_INFO(INTERNAL_DbgSkipMEOnStep, W("DbgSkipMEOnStep"), 0, "Turns off MethodEnter checks")
    68| CONFIG_DWORD_INFO(INTERNAL_DbgSkipVerCheck, W("DbgSkipVerCheck"), 0, "Allows different RS and LS versions (for servicing work)")
    69| CONFIG_DWORD_INFO(INTERNAL_DbgTC, W("DbgTC"), 0, "Allows checking boundary compression for offset mappings")
    70| CONFIG_DWORD_INFO(INTERNAL_DbgTransportFaultInject, W("DbgTransportFaultInject"), 0, "Allows injecting a fault for testing the debug transport")
    71| CONFIG_DWORD_INFO(INTERNAL_DbgTransportLog, W("DbgTransportLog"), 0 /* LE_None */, "Turns on logging for the debug transport")
    72| CONFIG_DWORD_INFO(INTERNAL_DbgTransportLogClass, W("DbgTransportLogClass"), (DWORD)-1 /* LC_All */, "Mask to control what is logged in DbgTransportLog")
    73| RETAIL_CONFIG_STRING_INFO(UNSUPPORTED_DbgTransportProxyAddress, W("DbgTransportProxyAddress"), "Allows specifying the transport proxy address")
    74| CONFIG_DWORD_INFO(INTERNAL_DbgTrapOnSkip, W("DbgTrapOnSkip"), 0, "Allows breaking when we skip a breakpoint")
    75| CONFIG_DWORD_INFO(INTERNAL_DbgWaitTimeout, W("DbgWaitTimeout"), 1, "Specifies the timeout value for waits")
    76| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgWFDETimeout, W("DbgWFDETimeout"), 25, "Specifies the timeout value for wait when waiting for a debug event")
    77| CONFIG_DWORD_INFO(INTERNAL_RaiseExceptionOnAssert, W("RaiseExceptionOnAssert"), 0, "Raise a first chance (if set to 1) or second chance (if set to 2) exception on asserts.")
    78| CONFIG_DWORD_INFO(INTERNAL_DebugBreakOnVerificationFailure, W("DebugBreakOnVerificationFailure"), 0, "Halts the jit on verification failure")
    79| CONFIG_STRING_INFO(INTERNAL_DebuggerBreakPoint, W("DebuggerBreakPoint"), "Allows counting various debug events")
    80| CONFIG_STRING_INFO(INTERNAL_DebugVerify, W("DebugVerify"), "Control for tracing in peverify")
    81| CONFIG_DWORD_INFO(INTERNAL_EncApplyChanges, W("EncApplyChanges"), 0, "Allows breaking when ApplyEditAndContinue is called")
    82| CONFIG_DWORD_INFO(INTERNAL_EnCBreakOnRemapComplete, W("EnCBreakOnRemapComplete"), 0, "Allows breaking after N RemapCompletes")
    83| CONFIG_DWORD_INFO(INTERNAL_EnCBreakOnRemapOpportunity, W("EnCBreakOnRemapOpportunity"), 0, "Allows breaking after N RemapOpportunities")
    84| CONFIG_DWORD_INFO(INTERNAL_EncDumpApplyChanges, W("EncDumpApplyChanges"), 0, "Allows dumping edits in delta metadata and il files")
    85| CONFIG_DWORD_INFO(INTERNAL_EncFixupFieldBreak, W("EncFixupFieldBreak"), 0, "Unlikely that this is used anymore.")
    86| CONFIG_DWORD_INFO(INTERNAL_EncJitUpdatedFunction, W("EncJitUpdatedFunction"), 0, "Allows breaking when an updated function is jitted")
    87| CONFIG_DWORD_INFO(INTERNAL_EnCResolveField, W("EnCResolveField"), 0, "Allows breaking when computing the address of an EnC-added field")
    88| CONFIG_DWORD_INFO(INTERNAL_EncResumeInUpdatedFunction, W("EncResumeInUpdatedFunction"), 0, "Allows breaking when execution resumes in a new EnC version of a function")
    89| CONFIG_DWORD_INFO(INTERNAL_DbgAssertOnDebuggeeDebugBreak, W("DbgAssertOnDebuggeeDebugBreak"), 0, "If non-zero causes the managed-only debugger to assert on unhandled breakpoints in the debuggee")
    90| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgDontResumeThreadsOnUnhandledException, W("UNSUPPORTED_DbgDontResumeThreadsOnUnhandledException"), 0, "If non-zero, then don't try to unsuspend threads after continuing a 2nd-chance native exception")
    91| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgSkipStackCheck, W("DbgSkipStackCheck"), 0, "Skip the stack pointer check during stackwalking")
    92| #ifdef DACCESS_COMPILE
    93| CONFIG_DWORD_INFO(INTERNAL_DumpGeneration_IntentionallyCorruptDataFromTarget, W("IntentionallyCorruptDataFromTarget"), 0, "Intentionally fakes bad data retrieved from target to try and break dump generation.")
    94| #endif
    95| CONFIG_DWORD_INFO(UNSUPPORTED_Debugging_RequiredVersion, W("UNSUPPORTED_Debugging_RequiredVersion"), 0, "The lowest ICorDebug version we should attempt to emulate, or 0 for default policy.  Use 2 for CLRv2, 4 for CLRv4, etc.")
    96| #ifdef FEATURE_MINIMETADATA_IN_TRIAGEDUMPS
    97| RETAIL_CONFIG_DWORD_INFO(INTERNAL_MiniMdBufferCapacity, W("MiniMdBufferCapacity"), 64 * 1024, "The max size of the buffer to store mini metadata information for triage- and mini-dumps.")
    98| #endif // FEATURE_MINIMETADATA_IN_TRIAGEDUMPS
    99| CONFIG_DWORD_INFO(INTERNAL_DbgNativeCodeBpBindsAcrossVersions, W("DbgNativeCodeBpBindsAcrossVersions"), 0, "If non-zero causes native breakpoints at offset 0 to bind in all tiered compilation versions of the given method")
   100| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_RichDebugInfo, W("RichDebugInfo"), 0, "If non-zero store some additional debug information for each jitted method")
   101| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_OutOfProcessSetContext, W("OutOfProcessSetContext"), 0, "If enabled the debugger will not modify thread contexts in-process.  Enabled by default when CET is enabled for the process.")
   102| CONFIG_DWORD_INFO(INTERNAL_ConditionalContracts, W("ConditionalContracts"), 0, "If ENABLE_CONTRACTS_IMPL is defined, sets whether contracts are conditional. (?)")
   103| CONFIG_DWORD_INFO(INTERNAL_ConsistencyCheck, W("ConsistencyCheck"), 0, "")
   104| CONFIG_DWORD_INFO(INTERNAL_ContinueOnAssert, W("ContinueOnAssert"), 0, "If set, doesn't break on asserts.")
   105| CONFIG_DWORD_INFO(INTERNAL_InjectFatalError, W("InjectFatalError"), 0, "")
   106| CONFIG_DWORD_INFO(INTERNAL_InjectFault, W("InjectFault"), 0, "")
   107| CONFIG_DWORD_INFO(INTERNAL_SuppressChecks, W("SuppressChecks"),0,  "")
   108| #ifdef FEATURE_EH_FUNCLETS
   109| CONFIG_DWORD_INFO(INTERNAL_SuppressLockViolationsOnReentryFromOS, W("SuppressLockViolationsOnReentryFromOS"), 0, "64 bit OOM tests re-enter the CLR via RtlVirtualUnwind.  This indicates whether to suppress resulting locking violations.")
   110| #endif // FEATURE_EH_FUNCLETS
   111| CONFIG_DWORD_INFO(INTERNAL_AssertOnFailFast, W("AssertOnFailFast"), 1, "")
   112| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_legacyCorruptedStateExceptionsPolicy, W("legacyCorruptedStateExceptionsPolicy"), 0, "Enabled Pre-V4 CSE behavior")
   113| CONFIG_DWORD_INFO(INTERNAL_SuppressLostExceptionTypeAssert, W("SuppressLostExceptionTypeAssert"), 0, "")
   114| RETAIL_CONFIG_DWORD_INFO(INTERNAL_UseEntryPointFilter, W("UseEntryPointFilter"), 0, "")
   115| RETAIL_CONFIG_DWORD_INFO(INTERNAL_Corhost_Swallow_Uncaught_Exceptions, W("Corhost_Swallow_Uncaught_Exceptions"), 0, "")
   116| CONFIG_DWORD_INFO(INTERNAL_FastGCCheckStack, W("FastGCCheckStack"), 0, "")
   117| CONFIG_DWORD_INFO(INTERNAL_FastGCStress, W("FastGCStress"), 0, "Reduce the number of GCs done by enabling GCStress")
   118| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_GCBreakOnOOM, W("GCBreakOnOOM"), 0, "Does a DebugBreak at the soonest time we detect an OOM")
   119| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_gcConcurrent, W("gcConcurrent"), (DWORD)-1, "Enables/Disables concurrent GC")
   120| #ifdef FEATURE_CONSERVATIVE_GC
   121| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_gcConservative, W("gcConservative"), 0, "Enables/Disables conservative GC")
   122| #endif
   123| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_gcServer, W("gcServer"), 0, "Enables server GC")
   124| CONFIG_STRING_INFO(INTERNAL_GcCoverage, W("GcCoverage"), "Specify a method or regular expression of method names to run with GCStress")
   125| CONFIG_STRING_INFO(INTERNAL_SkipGCCoverage, W("SkipGcCoverage"), "Specify a list of assembly names to skip with GC Coverage")
   126| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StatsUpdatePeriod, W("StatsUpdatePeriod"), 60, "Specifies the interval, in seconds, at which to update the statistics")
   127| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_GCRetainVM, W("GCRetainVM"), 0, "When set we put the segments that should be deleted on a standby list (instead of releasing them back to the OS) which will be considered to satisfy new segment requests (note that the same thing can be specified via API which is the supported way)")
   128| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCLOHThreshold, W("GCLOHThreshold"), 0, "Specifies the size that will make objects go on LOH")
   129| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_gcAllowVeryLargeObjects, W("gcAllowVeryLargeObjects"), 1, "Allow allocation of 2GB+ objects on GC heap")
   130| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCStress, W("GCStress"), 0, "Trigger GCs at regular intervals")
   131| CONFIG_DWORD_INFO(INTERNAL_GcStressOnDirectCalls, W("GcStressOnDirectCalls"), 0, "Whether to trigger a GC on direct calls")
   132| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_HeapVerify, W("HeapVerify"), 0, "When set verifies the integrity of the managed heap on entry and exit of each GC")
   133| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_GCNumaAware, W("GCNumaAware"), 1, "Specifies if to enable GC NUMA aware")
   134| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCCpuGroup, W("GCCpuGroup"), 0, "Specifies if to enable GC to support CPU groups")
   135| RETAIL_CONFIG_STRING_INFO(EXTERNAL_GCName, W("GCName"), "")
   136| /**
   137|  * This flag allows us to force the runtime to use global allocation context on Windows x86/amd64 instead of thread allocation context just for testing purpose.
   138|  * The flag is unsafe for a subtle reason. Although the access to the g_global_alloc_context is protected under a lock. The implementation of
   139|  * that lock in the JIT helpers are not multi-core safe (in particular, it used and inc instruction without using the LOCK prefix). This is
   140|  * only useful for ad-hoc testing.
   141|  */
   142| CONFIG_DWORD_INFO(INTERNAL_GCUseGlobalAllocationContext, W("GCUseGlobalAllocationContext"), 0, "Force using the global allocation context for testing only")
   143| CONFIG_DWORD_INFO(INTERNAL_JitBreakEmit, W("JitBreakEmit"), (DWORD)-1, "")
   144| CONFIG_DWORD_INFO(INTERNAL_JitDebuggable, W("JitDebuggable"), 0, "")
   145| #if !defined(DEBUG) && !defined(_DEBUG)
   146| #define INTERNAL_JitEnableNoWayAssert_Default 0
   147| #else
   148| #define INTERNAL_JitEnableNoWayAssert_Default 1
   149| #endif
   150| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitEnableNoWayAssert, W("JitEnableNoWayAssert"), INTERNAL_JitEnableNoWayAssert_Default, "")
   151| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_JitFramed, W("JitFramed"), 0, "Forces EBP frames")
   152| CONFIG_DWORD_INFO(INTERNAL_JitThrowOnAssertionFailure, W("JitThrowOnAssertionFailure"), 0, "Throw managed exception on assertion failures during JIT instead of failfast")
   153| CONFIG_DWORD_INFO(INTERNAL_JitGCStress, W("JitGCStress"), 0, "GC stress mode for jit")
   154| CONFIG_DWORD_INFO(INTERNAL_JitHeartbeat, W("JitHeartbeat"), 0, "")
   155| CONFIG_DWORD_INFO(INTERNAL_JitHelperLogging, W("JitHelperLogging"), 0, "")
   156| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_JITMinOpts, W("JITMinOpts"), 0, "Forces MinOpts")
   157| RETAIL_CONFIG_STRING_INFO(EXTERNAL_JitName, W("JitName"), "Primary jit to use")
   158| CONFIG_STRING_INFO(INTERNAL_JitPath, W("JitPath"), "Full path to primary jit to use")
   159| #if defined(ALLOW_SXS_JIT)
   160| RETAIL_CONFIG_STRING_INFO(EXTERNAL_AltJitName, W("AltJitName"), "Alternative jit to use, will fall back to primary jit.")
   161| CONFIG_STRING_INFO(INTERNAL_AltJitPath, W("AltJitPath"), "Full path to alternative jit to use")
   162| RETAIL_CONFIG_STRING_INFO(EXTERNAL_AltJit, W("AltJit"), "Enables AltJit and selectively limits it to the specified methods.")
   163| RETAIL_CONFIG_STRING_INFO(EXTERNAL_AltJitOs, W("AltJitOS"), "Sets target OS for AltJit or uses native one by default. Only applicable for ARM/AMR64 at the moment.")
   164| RETAIL_CONFIG_STRING_INFO(EXTERNAL_AltJitExcludeAssemblies, W("AltJitExcludeAssemblies"), "Do not use AltJit on this semicolon-delimited list of assemblies.")
   165| #endif // defined(ALLOW_SXS_JIT)
   166| #if defined(FEATURE_STACK_SAMPLING)
   167| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StackSamplingEnabled, W("StackSamplingEnabled"), 0, "Is stack sampling based tracking of evolving hot methods enabled.")
   168| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StackSamplingAfter, W("StackSamplingAfter"), 0, "When to start sampling (for some sort of app steady state), i.e., initial delay for sampling start in milliseconds.")
   169| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StackSamplingEvery, W("StackSamplingEvery"), 100, "How frequent should thread stacks be sampled in milliseconds.")
   170| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StackSamplingNumMethods, W("StackSamplingNumMethods"), 32, "Number of evolving methods to track as hot and JIT them in the background at a given point of execution.")
   171| #endif // defined(FEATURE_JIT_SAMPLING)
   172| #if defined(ALLOW_SXS_JIT_NGEN)
   173| RETAIL_CONFIG_STRING_INFO(INTERNAL_AltJitNgen, W("AltJitNgen"), "Enables AltJit for NGEN and selectively limits it to the specified methods.")
   174| #endif // defined(ALLOW_SXS_JIT_NGEN)
   175| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitHostMaxSlabCache, W("JitHostMaxSlabCache"), 0x1000000, "Sets jit host max slab cache size, 16MB default")
   176| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitOptimizeType, W("JitOptimizeType"), 0 /* OPT_DEFAULT */, "")
   177| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitPrintInlinedMethods, W("JitPrintInlinedMethods"), 0, "")
   178| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitTelemetry, W("JitTelemetry"), 1, "If non-zero, gather JIT telemetry data")
   179| RETAIL_CONFIG_STRING_INFO(INTERNAL_JitTimeLogFile, W("JitTimeLogFile"), "If set, gather JIT throughput data and write to this file.")
   180| RETAIL_CONFIG_STRING_INFO(INTERNAL_JitTimeLogCsv, W("JitTimeLogCsv"), "If set, gather JIT throughput data and write to a CSV file. This mode must be used in internal retail builds.")
   181| RETAIL_CONFIG_STRING_INFO(INTERNAL_JitFuncInfoLogFile, W("JitFuncInfoLogFile"), "If set, gather JIT function info and write to this file.")
   182| CONFIG_DWORD_INFO(INTERNAL_JitVerificationDisable, W("JitVerificationDisable"), 0, "")
   183| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitLockWrite, W("JitLockWrite"), 0, "Force all volatile writes to be 'locked'")
   184| CONFIG_STRING_INFO(INTERNAL_TailCallMax, W("TailCallMax"), "")
   185| RETAIL_CONFIG_STRING_INFO(EXTERNAL_TailCallOpt, W("TailCallOpt"), "")
   186| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TailCallLoopOpt, W("TailCallLoopOpt"), 1, "Convert recursive tail calls to loops")
   187| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_Jit_NetFx40PInvokeStackResilience, W("NetFx40_PInvokeStackResilience"), (DWORD)-1, "Makes P/Invoke resilient against mismatched signature and calling convention (significant perf penalty).")
   188| #if defined(TARGET_X86)
   189| RETAIL_CONFIG_DWORD_INFO(INTERNAL_AltJitAssertOnNYI, W("AltJitAssertOnNYI"), 0, "Controls the AltJit behavior of NYI stuff")
   190| #else
   191| RETAIL_CONFIG_DWORD_INFO(INTERNAL_AltJitAssertOnNYI, W("AltJitAssertOnNYI"), 1, "Controls the AltJit behavior of NYI stuff")
   192| #endif
   193| CONFIG_DWORD_INFO(INTERNAL_JitLargeBranches, W("JitLargeBranches"), 0, "Force using the largest conditional branch format")
   194| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitRegisterFP, W("JitRegisterFP"), 3, "Control FP enregistration")
   195| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitELTHookEnabled, W("JitELTHookEnabled"), 0, "On ARM, setting this will emit Enter/Leave/TailCall callbacks")
   196| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitMemStats, W("JitMemStats"), 0, "Display JIT memory usage statistics")
   197| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitVNMapSelBudget, W("JitVNMapSelBudget"), 100, "Max # of MapSelect's considered for a particular top-level invocation.")
   198| #if defined(TARGET_AMD64) || defined(TARGET_X86) || defined(TARGET_ARM64)
   199| #define EXTERNAL_FeatureSIMD_Default 1
   200| #else // !(defined(TARGET_AMD64) || defined(TARGET_X86) || defined(TARGET_ARM64))
   201| #define EXTERNAL_FeatureSIMD_Default 0
   202| #endif // !(defined(TARGET_AMD64) || defined(TARGET_X86) || defined(TARGET_ARM64))
   203| RETAIL_CONFIG_DWORD_INFO(INTERNAL_SIMD16ByteOnly, W("SIMD16ByteOnly"), 0, "Limit maximum SIMD vector length to 16 bytes (used by x64_arm64_altjit)")
   204| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TrackDynamicMethodDebugInfo, W("TrackDynamicMethodDebugInfo"), 0, "Specifies whether debug info should be generated and tracked for dynamic methods")
   205| #ifdef FEATURE_MULTICOREJIT
   206| RETAIL_CONFIG_STRING_INFO(INTERNAL_MultiCoreJitProfile, W("MultiCoreJitProfile"), "If set, use the file to store/control multi-core JIT.")
   207| RETAIL_CONFIG_DWORD_INFO(INTERNAL_MultiCoreJitProfileWriteDelay, W("MultiCoreJitProfileWriteDelay"), 12, "Set the delay after which the multi-core JIT profile will be written to disk.")
   208| RETAIL_CONFIG_DWORD_INFO(INTERNAL_MultiCoreJitMinNumCpus, W("MultiCoreJitMinNumCpus"), 2, "Minimum number of cpus that must be present to allow MultiCoreJit usage.")
   209| RETAIL_CONFIG_DWORD_INFO(INTERNAL_MultiCoreJitNoProfileGather, W("MultiCoreJitNoProfileGather"), 0, "Set to 1 to disable profile gathering (but leave possibly enabled profile usage).")
   210| #endif
   211| #ifdef FEATURE_INTERPRETER
   212| RETAIL_CONFIG_STRING_INFO(INTERNAL_Interpret, W("Interpret"), "Selectively uses the interpreter to execute the specified methods")
   213| RETAIL_CONFIG_STRING_INFO(INTERNAL_InterpretExclude, W("InterpretExclude"), "Excludes the specified methods from the set selected by 'Interpret'")
   214| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterMethHashMin, W("InterpreterMethHashMin"), 0, "Only interpret methods selected by 'Interpret' whose hash is at least this value. or after nth")
   215| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterMethHashMax, W("InterpreterMethHashMax"), UINT32_MAX, "If non-zero, only interpret methods selected by 'Interpret' whose hash is at most this value")
   216| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterStubMin, W("InterpreterStubMin"), 0, "Only interpret methods selected by 'Interpret' whose stub num is at least this value.")
   217| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterStubMax, W("InterpreterStubMax"), UINT32_MAX, "If non-zero, only interpret methods selected by 'Interpret' whose stub number is at most this value.")
   218| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterJITThreshold, W("InterpreterJITThreshold"), 10, "The number of times a method should be interpreted before being JITted")
   219| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterDoLoopMethods, W("InterpreterDoLoopMethods"), 0, "If set, don't check for loops, start by interpreting *all* methods")
   220| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterUseCaching, W("InterpreterUseCaching"), 1, "If non-zero, use the caching mechanism.")
   221| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterLooseRules, W("InterpreterLooseRules"), 1, "If non-zero, allow ECMA spec violations required by managed C++.")
   222| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterPrintPostMortem, W("InterpreterPrintPostMortem"), 0, "Prints summary information about the execution to the console")
   223| RETAIL_CONFIG_STRING_INFO(INTERNAL_InterpreterLogFile, W("InterpreterLogFile"), "If non-null, append interpreter logging to this file, else use stdout")
   224| RETAIL_CONFIG_DWORD_INFO(INTERNAL_DumpInterpreterStubs, W("DumpInterpreterStubs"), 0, "Prints all interpreter stubs that are created to the console")
   225| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterEntries, W("TraceInterpreterEntries"), 0, "Logs entries to interpreted methods to the console")
   226| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterIL, W("TraceInterpreterIL"), 0, "Logs individual instructions of interpreted methods to the console")
   227| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterOstack, W("TraceInterpreterOstack"), 0, "Logs operand stack after each IL instruction of interpreted methods to the console")
   228| CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterVerbose, W("TraceInterpreterVerbose"), 0, "Logs interpreter progress with detailed messages to the console")
   229| CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterJITTransition, W("TraceInterpreterJITTransition"), 0, "Logs when the interpreter determines a method should be JITted")
   230| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ForceInterpreter, W("ForceInterpreter"), 0, "If non-zero, force the interpreter to be used")
   231| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterHWIntrinsicsIsSupportedFalse, W("InterpreterHWIntrinsicsIsSupportedFalse"), 0, "If non-zero, force get_IsSupported to return false for hardware intrinsics") // for internal testing purposes
   232| #endif
   233| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterFallback, W("InterpreterFallback"), 0, "Fallback to the interpreter when the JIT compiler fails")
   234| CONFIG_DWORD_INFO(INTERNAL_LoaderHeapCallTracing, W("LoaderHeapCallTracing"), 0, "Loader heap troubleshooting")
   235| RETAIL_CONFIG_DWORD_INFO(INTERNAL_CodeHeapReserveForJumpStubs, W("CodeHeapReserveForJumpStubs"), 1, "Percentage of code heap to reserve for jump stubs")
   236| RETAIL_CONFIG_DWORD_INFO(INTERNAL_NGenReserveForJumpStubs, W("NGenReserveForJumpStubs"), 0, "Percentage of ngen image size to reserve for jump stubs")
   237| RETAIL_CONFIG_DWORD_INFO(INTERNAL_BreakOnOutOfMemoryWithinRange, W("BreakOnOutOfMemoryWithinRange"), 0, "Break before out of memory within range exception is thrown")
   238| RETAIL_CONFIG_DWORD_INFO(INTERNAL_LogEnable, W("LogEnable"), 0, "Turns on the traditional CLR log.")
   239| RETAIL_CONFIG_DWORD_INFO(INTERNAL_LogFacility,  W("LogFacility"), 0, "Specifies a facility mask for CLR log. (See 'loglf.h'; VM interprets string value as hex number.) Also used by stresslog.")
   240| RETAIL_CONFIG_DWORD_INFO(INTERNAL_LogFacility2, W("LogFacility2"), 0, "Specifies a facility mask for CLR log. (See 'loglf.h'; VM interprets string value as hex number.) Also used by stresslog.")
   241| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_logFatalError, W("logFatalError"), 1, "Specifies whether EventReporter logs fatal errors in the Windows event log.")
   242| CONFIG_STRING_INFO(INTERNAL_LogFile, W("LogFile"), "Specifies a file name for the CLR log.")
   243| CONFIG_DWORD_INFO(INTERNAL_LogFileAppend, W("LogFileAppend"), 0 , "Specifies whether to append to or replace the CLR log file.")
   244| CONFIG_DWORD_INFO(INTERNAL_LogFlushFile, W("LogFlushFile"), 0 , "Specifies whether to flush the CLR log file on each write.")
   245| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_LogLevel, W("LogLevel"), 0 , "4=10 msgs, 9=1000000, 10=everything")
   246| RETAIL_CONFIG_DWORD_INFO(INTERNAL_LogToConsole, W("LogToConsole"), 0 , "Writes the CLR log to console.")
   247| CONFIG_DWORD_INFO(INTERNAL_LogToDebugger, W("LogToDebugger"), 0 , "Writes the CLR log to debugger (OutputDebugStringA).")
   248| CONFIG_DWORD_INFO(INTERNAL_LogToFile, W("LogToFile"), 0 , "Writes the CLR log to a file.")
   249| CONFIG_DWORD_INFO(INTERNAL_LogWithPid, W("LogWithPid"), FALSE, "Appends pid to filename for the CLR log.")
   250| CONFIG_DWORD_INFO(INTERNAL_MD_ApplyDeltaBreak, W("MD_ApplyDeltaBreak"), 0, "ASSERT when applying EnC")
   251| RETAIL_CONFIG_DWORD_INFO(INTERNAL_AssertOnBadImageFormat, W("AssertOnBadImageFormat"), 0, "ASSERT when invalid MD read")
   252| RETAIL_CONFIG_DWORD_INFO(INTERNAL_MD_DeltaCheck, W("MD_DeltaCheck"), 1, "Some checks of GUID when applying EnC (?)")
   253| CONFIG_DWORD_INFO(INTERNAL_MD_EncDelta, W("MD_EncDelta"), 0, "Forces EnC Delta format in MD (?)")
   254| RETAIL_CONFIG_DWORD_INFO(INTERNAL_MD_ForceNoColDesSharing, W("MD_ForceNoColDesSharing"), 0, "Don't know - the only usage I could find is #if 0 (?)")
   255| CONFIG_DWORD_INFO(INTERNAL_MD_KeepKnownCA, W("MD_KeepKnownCA"), 0, "Something with known CAs (?)")
   256| CONFIG_DWORD_INFO(INTERNAL_MD_MiniMDBreak, W("MD_MiniMDBreak"), 0, "ASSERT when creating CMiniMdRw class")
   257| CONFIG_DWORD_INFO(INTERNAL_MD_PreSaveBreak, W("MD_PreSaveBreak"), 0, "ASSERT when calling CMiniMdRw::PreSave")
   258| CONFIG_DWORD_INFO(INTERNAL_MD_RegMetaBreak, W("MD_RegMetaBreak"), 0, "ASSERT when creating RegMeta class")
   259| CONFIG_DWORD_INFO(INTERNAL_MD_RegMetaDump, W("MD_RegMetaDump"), 0, "Dump MD in 4 functions (?)")
   260| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_DOTNET_MODIFIABLE_ASSEMBLIES, W("MODIFIABLE_ASSEMBLIES"), "Enables hot reload on debug built assemblies with the 'debug' keyword", CLRConfig::LookupOptions::TrimWhiteSpaceFromStringValue);
   261| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_MD_PreserveDebuggerMetadataMemory, W("MD_PreserveDebuggerMetadataMemory"), 0, "Save all versions of metadata memory in the debugger when debuggee metadata is updated")
   262| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinInitialDuration, W("SpinInitialDuration"), 0x32, "Hex value specifying the first spin duration")
   263| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinBackoffFactor, W("SpinBackoffFactor"), 0x3, "Hex value specifying the growth of each successive spin duration")
   264| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinLimitProcCap, W("SpinLimitProcCap"), 0xFFFFFFFF, "Hex value specifying the largest value of NumProcs to use when calculating the maximum spin duration")
   265| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinLimitProcFactor, W("SpinLimitProcFactor"), 0x4E20, "Hex value specifying the multiplier on NumProcs to use when calculating the maximum spin duration")
   266| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinLimitConstant, W("SpinLimitConstant"), 0x0, "Hex value specifying the constant to add when calculating the maximum spin duration")
   267| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinRetryCount, W("SpinRetryCount"), 0xA, "Hex value specifying the number of times the entire spin process is repeated (when applicable)")
   268| RETAIL_CONFIG_DWORD_INFO(INTERNAL_Monitor_SpinCount, W("Monitor_SpinCount"), 0x1e, "Hex value specifying the maximum number of spin iterations Monitor may perform upon contention on acquiring the lock before waiting.")
   269| CONFIG_DWORD_INFO(INTERNAL_SymDiffDump, W("SymDiffDump"), 0, "Used to create the map file while binding the assembly. Used by SemanticDiffer")
   270| RETAIL_CONFIG_DWORD_INFO_EX(EXTERNAL_CORECLR_ENABLE_PROFILING, W("CORECLR_ENABLE_PROFILING"), 0, "CoreCLR only: Flag to indicate whether profiling should be enabled for the currently running process.", CLRConfig::LookupOptions::DontPrependPrefix)
   271| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER, W("CORECLR_PROFILER"), "CoreCLR only: Specifies GUID of profiler to load into currently running process", CLRConfig::LookupOptions::DontPrependPrefix)
   272| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH, W("CORECLR_PROFILER_PATH"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running process", CLRConfig::LookupOptions::DontPrependPrefix)
   273| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH_32, W("CORECLR_PROFILER_PATH_32"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running 32 process", CLRConfig::LookupOptions::DontPrependPrefix)
   274| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH_64, W("CORECLR_PROFILER_PATH_64"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running 64 process", CLRConfig::LookupOptions::DontPrependPrefix)
   275| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH_ARM32, W("CORECLR_PROFILER_PATH_ARM32"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running ARM32 process", CLRConfig::LookupOptions::DontPrependPrefix)
   276| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH_ARM64, W("CORECLR_PROFILER_PATH_ARM64"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running ARM64 process", CLRConfig::LookupOptions::DontPrependPrefix)
   277| RETAIL_CONFIG_DWORD_INFO_EX(EXTERNAL_CORECLR_ENABLE_NOTIFICATION_PROFILERS, W("CORECLR_ENABLE_NOTIFICATION_PROFILERS"), 0, "Set to 0 to disable loading notification profilers.", CLRConfig::LookupOptions::DontPrependPrefix)
   278| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS, W("CORECLR_NOTIFICATION_PROFILERS"), "A semi-colon separated list of notification profilers to load into currently running process in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
   279| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS_32, W("CORECLR_NOTIFICATION_PROFILERS_32"), "A semi-colon separated list of notification profilers to load into currently running 32 process in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
   280| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS_64, W("CORECLR_NOTIFICATION_PROFILERS_64"), "A semi-colon separated list of notification profilers to load into currently running 64 process in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
   281| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS_ARM32, W("CORECLR_NOTIFICATION_PROFILERS_ARM32"), "A semi-colon separated list of notification profilers to load into currently running ARM32 process in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
   282| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS_ARM64, W("CORECLR_NOTIFICATION_PROFILERS_ARM64"), "A semi-colon separated list of notification profilers to load into currently running ARM64 process in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
   283| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_ProfAPI_ProfilerCompatibilitySetting, W("ProfAPI_ProfilerCompatibilitySetting"), "Specifies the profiler loading policy (the default is not to load a V2 profiler in V4)", CLRConfig::LookupOptions::TrimWhiteSpaceFromStringValue)
   284| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ProfAPI_DetachMinSleepMs, W("ProfAPI_DetachMinSleepMs"), 0, "The minimum time, in milliseconds, the CLR will wait before checking whether a profiler that is in the process of detaching is ready to be unloaded.")
   285| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ProfAPI_DetachMaxSleepMs, W("ProfAPI_DetachMaxSleepMs"), 0, "The maximum time, in milliseconds, the CLR will wait before checking whether a profiler that is in the process of detaching is ready to be unloaded.")
   286| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ProfAPI_RejitOnAttach, W("ProfApi_RejitOnAttach"), 1, "Enables the ability for profilers to rejit methods on attach.")
   287| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ProfAPI_InliningTracking, W("ProfApi_InliningTracking"), 1, "Enables the runtime's tracking of inlining for profiler ReJIT.")
   288| CONFIG_DWORD_INFO(INTERNAL_ProfAPI_EnableRejitDiagnostics, W("ProfAPI_EnableRejitDiagnostics"), 0, "Enable extra dumping to stdout of rejit structures")
   289| CONFIG_DWORD_INFO(INTERNAL_ProfAPIFault, W("ProfAPIFault"), 0, "Test-only bitmask to inject various types of faults in the profapi code")
   290| CONFIG_DWORD_INFO(INTERNAL_TestOnlyAllowedEventMask, W("TestOnlyAllowedEventMask"), 0, "Test-only bitmask to allow profiler tests to override CLR enforcement of COR_PRF_ALLOWABLE_AFTER_ATTACH and COR_PRF_MONITOR_IMMUTABLE")
   291| CONFIG_DWORD_INFO(INTERNAL_TestOnlyEnableICorProfilerInfo, W("ProfAPI_TestOnlyEnableICorProfilerInfo"), 0, "Test-only flag to allow attaching profiler tests to call ICorProfilerInfo interface, which would otherwise be disallowed for attaching profilers")
   292| CONFIG_DWORD_INFO(INTERNAL_TestOnlyEnableObjectAllocatedHook, W("TestOnlyEnableObjectAllocatedHook"), 0, "Test-only flag that forces CLR to initialize on startup as if ObjectAllocated callback were requested, to enable post-attach ObjectAllocated functionality.")
   293| CONFIG_DWORD_INFO(INTERNAL_TestOnlyEnableSlowELTHooks, W("TestOnlyEnableSlowELTHooks"), 0, "Test-only flag that forces CLR to initialize on startup as if slow-ELT were requested, to enable post-attach ELT functionality.")
   294| RETAIL_CONFIG_STRING_INFO(UNSUPPORTED_ETW_ObjectAllocationEventsPerTypePerSec, W("ETW_ObjectAllocationEventsPerTypePerSec"), "Desired number of GCSampledObjectAllocation ETW events to be logged per type per second.  If 0, then the default built in to the implementation for the enabled event (e.g., High, Low), will be used.")
   295| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_ProfAPI_ValidateNGENInstrumentation, W("ProfAPI_ValidateNGENInstrumentation"), 0, "This flag enables additional validations when using the IMetaDataEmit APIs for NGEN'ed images to ensure only supported edits are made.")
   296| #ifdef FEATURE_PERFMAP
   297| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_PerfMapEnabled, W("PerfMapEnabled"), 0, "This flag is used on Linux to enable writing /tmp/perf-$pid.map. It is disabled by default")
   298| RETAIL_CONFIG_STRING_INFO(EXTERNAL_PerfMapJitDumpPath, W("PerfMapJitDumpPath"), "Specifies a path to write the perf jitdump file. Defaults to GetTempPathA()")
   299| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_PerfMapIgnoreSignal, W("PerfMapIgnoreSignal"), 0, "When perf map is enabled, this option will configure the specified signal to be accepted and ignored as a marker in the perf logs.  It is disabled by default")
   300| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_PerfMapShowOptimizationTiers, W("PerfMapShowOptimizationTiers"), 1, "Shows optimization tiers in the perf map for methods, as part of the symbol name. Useful for seeing separate stack frames for different optimization tiers of each method.")
   301| RETAIL_CONFIG_STRING_INFO(EXTERNAL_NativeImagePerfMapFormat, W("NativeImagePerfMapFormat"), "Specifies the format of native image perfmap files generated by crossgen.  Valid options are RVA or OFFSET.")
   302| #endif
   303| RETAIL_CONFIG_STRING_INFO(EXTERNAL_StartupDelayMS, W("StartupDelayMS"), "")
   304| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StressLog, W("StressLog"), 0, "Turns on the stress log.")
   305| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_ForceEnc, W("ForceEnc"), 0, "Forces Edit and Continue to be on for all eligible modules.")
   306| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StressLogSize, W("StressLogSize"), 0, "Stress log size in bytes per thread.")
   307| RETAIL_CONFIG_STRING_INFO(UNSUPPORTED_StressLogFilename, W("StressLogFilename"), "Stress log filename for memory mapped stress log.")
   308| CONFIG_DWORD_INFO(INTERNAL_stressSynchronized, W("stressSynchronized"), 0, "Unknown if or where this is used; unless a test is specifically depending on this, it can be removed.")
   309| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TotalStressLogSize, W("TotalStressLogSize"), 0, "Total stress log size in bytes.")
   310| CONFIG_DWORD_INFO(INTERNAL_DiagnosticSuspend, W("DiagnosticSuspend"), 0, "")
   311| CONFIG_DWORD_INFO(INTERNAL_SuspendDeadlockTimeout, W("SuspendDeadlockTimeout"), 40000, "")
   312| CONFIG_DWORD_INFO(INTERNAL_SuspendThreadDeadlockTimeoutMs, W("SuspendThreadDeadlockTimeoutMs"), 2000, "")
   313| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadSuspendInjection, W("INTERNAL_ThreadSuspendInjection"), 1, "Specifies whether to inject activations for thread suspension on Unix")
   314| RETAIL_CONFIG_DWORD_INFO(INTERNAL_DefaultStackSize, W("DefaultStackSize"), 0, "Stack size to use for new VM threads when thread is created with default stack size (dwStackSize == 0).")
   315| RETAIL_CONFIG_DWORD_INFO(INTERNAL_Thread_DeadThreadCountThresholdForGCTrigger, W("Thread_DeadThreadCountThresholdForGCTrigger"), 75, "In the heuristics to clean up dead threads, this threshold must be reached before triggering a GC will be considered. Set to 0 to disable triggering a GC based on dead threads.")
   316| RETAIL_CONFIG_DWORD_INFO(INTERNAL_Thread_DeadThreadGCTriggerPeriodMilliseconds, W("Thread_DeadThreadGCTriggerPeriodMilliseconds"), 1000 * 60 * 30, "In the heuristics to clean up dead threads, this much time must have elapsed since the previous max-generation GC before triggering another GC will be considered")
   317| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_Thread_UseAllCpuGroups, W("Thread_UseAllCpuGroups"), 0, "Specifies whether to query and use CPU group information for determining the processor count.")
   318| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_Thread_AssignCpuGroups, W("Thread_AssignCpuGroups"), 1, "Specifies whether to automatically distribute threads created by the CLR across CPU Groups. Effective only when Thread_UseAllCpuGroups and GCCpuGroup are enabled.")
   319| RETAIL_CONFIG_DWORD_INFO_EX(EXTERNAL_ProcessorCount, W("PROCESSOR_COUNT"), 0, "Specifies the number of processors available for the process, which is returned by Environment.ProcessorCount", CLRConfig::LookupOptions::ParseIntegerAsBase10)
   320| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_UsePortableThreadPool, W("ThreadPool_UsePortableThreadPool"), 1, "Uses the managed portable thread pool implementation instead of the unmanaged one.")
   321| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_UsePortableThreadPoolForIO, W("ThreadPool_UsePortableThreadPoolForIO"), 1, "Uses the managed portable thread pool implementation instead of the unmanaged one for async IO.")
   322| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_ForceMinWorkerThreads, W("ThreadPool_ForceMinWorkerThreads"), 0, "Overrides the MinThreads setting for the ThreadPool worker pool")
   323| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_ForceMaxWorkerThreads, W("ThreadPool_ForceMaxWorkerThreads"), 0, "Overrides the MaxThreads setting for the ThreadPool worker pool")
   324| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_DisableStarvationDetection, W("ThreadPool_DisableStarvationDetection"), 0, "Disables the ThreadPool feature that forces new threads to be added when workitems run for too long")
   325| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_DebugBreakOnWorkerStarvation, W("ThreadPool_DebugBreakOnWorkerStarvation"), 0, "Breaks into the debugger if the ThreadPool detects work queue starvation")
   326| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_EnableWorkerTracking, W("ThreadPool_EnableWorkerTracking"), 0, "Enables extra expensive tracking of how many workers threads are working simultaneously")
   327| #ifdef TARGET_ARM64
   328| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_UnfairSemaphoreSpinLimit, W("ThreadPool_UnfairSemaphoreSpinLimit"), 0x32, "Maximum number of spins per processor a thread pool worker thread performs before waiting for work")
   329| #else // !TARGET_ARM64
   330| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_UnfairSemaphoreSpinLimit, W("ThreadPool_UnfairSemaphoreSpinLimit"), 0x46, "Maximum number of spins a thread pool worker thread performs before waiting for work")
   331| #endif // TARGET_ARM64
   332| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_Disable,                             W("HillClimbing_Disable"),                            0, "Disables hill climbing for thread adjustments in the thread pool");
   333| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_WavePeriod,                          W("HillClimbing_WavePeriod"),                         4, "");
   334| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_TargetSignalToNoiseRatio,            W("HillClimbing_TargetSignalToNoiseRatio"),           300, "");
   335| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_ErrorSmoothingFactor,                W("HillClimbing_ErrorSmoothingFactor"),               1, "");
   336| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_WaveMagnitudeMultiplier,             W("HillClimbing_WaveMagnitudeMultiplier"),            100, "");
   337| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_MaxWaveMagnitude,                    W("HillClimbing_MaxWaveMagnitude"),                   20, "");
   338| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_WaveHistorySize,                     W("HillClimbing_WaveHistorySize"),                    8, "");
   339| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_Bias,                                W("HillClimbing_Bias"),                               15, "The 'cost' of a thread.  0 means drive for increased throughput regardless of thread count; higher values bias more against higher thread counts.");
   340| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_MaxChangePerSecond,                  W("HillClimbing_MaxChangePerSecond"),                 4, "");
   341| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_MaxChangePerSample,                  W("HillClimbing_MaxChangePerSample"),                 20, "");
   342| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_MaxSampleErrorPercent,               W("HillClimbing_MaxSampleErrorPercent"),              15, "");
   343| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_SampleIntervalLow,                   W("HillClimbing_SampleIntervalLow"),                  10, "");
   344| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_SampleIntervalHigh,                  W("HillClimbing_SampleIntervalHigh"),                 200, "");
   345| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_GainExponent,                        W("HillClimbing_GainExponent"),                       200, "The exponent to apply to the gain, times 100.  100 means to use linear gain, higher values will enhance large moves and damp small ones.");
   346| #ifdef FEATURE_TIERED_COMPILATION
   347| #ifdef _DEBUG
   348| #define TC_BackgroundWorkerTimeoutMs (100)
   349| #define TC_CallCountThreshold (2)
   350| #define TC_CallCountingDelayMs (1)
   351| #define TC_DelaySingleProcMultiplier (2)
   352| #else // !_DEBUG
   353| #define TC_BackgroundWorkerTimeoutMs (4000)
   354| #define TC_CallCountThreshold (30)
   355| #define TC_CallCountingDelayMs (100)
   356| #define TC_DelaySingleProcMultiplier (10)
   357| #endif // _DEBUG
   358| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TieredCompilation, W("TieredCompilation"), 1, "Enables tiered compilation")
   359| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TC_QuickJit, W("TC_QuickJit"), 1, "For methods that would be jitted, enable using quick JIT when appropriate.")
   360| #if defined(TARGET_AMD64) || defined(TARGET_ARM64)
   361| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TC_QuickJitForLoops, W("TC_QuickJitForLoops"), 1, "When quick JIT is enabled, quick JIT may also be used for methods that contain loops.")
   362| #else // !(defined(TARGET_AMD64) || defined(TARGET_ARM64))
   363| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TC_QuickJitForLoops, W("TC_QuickJitForLoops"), 0, "When quick JIT is enabled, quick JIT may also be used for methods that contain loops.")
   364| #endif // defined(TARGET_AMD64) || defined(TARGET_ARM64)
   365| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TC_AggressiveTiering, W("TC_AggressiveTiering"), 0, "Transition through tiers aggressively.")
   366| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_BackgroundWorkerTimeoutMs, W("TC_BackgroundWorkerTimeoutMs"), TC_BackgroundWorkerTimeoutMs, "How long in milliseconds the background worker thread may remain idle before exiting.")
   367| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_CallCountThreshold, W("TC_CallCountThreshold"), TC_CallCountThreshold, "Number of times a method must be called in tier 0 after which it is promoted to the next tier.")
   368| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_CallCountingDelayMs, W("TC_CallCountingDelayMs"), TC_CallCountingDelayMs, "A perpetual delay in milliseconds that is applied to call counting in tier 0 and jitting at higher tiers, while there is startup-like activity.")
   369| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_DelaySingleProcMultiplier, W("TC_DelaySingleProcMultiplier"), TC_DelaySingleProcMultiplier, "Multiplier for TC_CallCountingDelayMs that is applied on a single-processor machine or when the process is affinitized to a single processor.")
   370| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_CallCounting, W("TC_CallCounting"), 1, "Enabled by default (only activates when TieredCompilation is also enabled). If disabled immediately backpatches prestub, and likely prevents any promotion to higher tiers")
   371| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_UseCallCountingStubs, W("TC_UseCallCountingStubs"), 1, "Uses call counting stubs for faster call counting.")
   372| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_DeleteCallCountingStubsAfter, W("TC_DeleteCallCountingStubsAfter"), 0, "Deletes call counting stubs after this many have completed. Zero to disable deleting.")
   373| #undef TC_BackgroundWorkerTimeoutMs
   374| #undef TC_CallCountThreshold
   375| #undef TC_CallCountingDelayMs
   376| #undef TC_DelaySingleProcMultiplier
   377| #undef TC_DeleteCallCountingStubsAfter
   378| #endif // FEATURE_TIERED_COMPILATION
   379| #ifdef FEATURE_ON_STACK_REPLACEMENT
   380| RETAIL_CONFIG_DWORD_INFO(INTERNAL_OSR_CounterBump, W("OSR_CounterBump"), 1000, "Counter reload value when a patchpoint is hit")
   381| RETAIL_CONFIG_DWORD_INFO(INTERNAL_OSR_HitLimit, W("OSR_HitLimit"), 10, "Number of times a patchpoint must call back to trigger an OSR transition")
   382| CONFIG_DWORD_INFO(INTERNAL_OSR_LowId, W("OSR_LowId"), (DWORD)-1, "Low end of enabled patchpoint range (inclusive)");
   383| CONFIG_DWORD_INFO(INTERNAL_OSR_HighId, W("OSR_HighId"), 10000000, "High end of enabled patchpoint range (inclusive)");
   384| #endif
   385| #ifdef FEATURE_PGO
   386| RETAIL_CONFIG_STRING_INFO(INTERNAL_PGODataPath, W("PGODataPath"), "Read/Write PGO data from/to the indicated file.")
   387| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ReadPGOData, W("ReadPGOData"), 0, "Read PGO data")
   388| RETAIL_CONFIG_DWORD_INFO(INTERNAL_WritePGOData, W("WritePGOData"), 0, "Write PGO data")
   389| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TieredPGO, W("TieredPGO"), 0, "Instrument Tier0 code and make counts available to Tier1")
   390| #endif
   391| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_BackpatchEntryPointSlots, W("BackpatchEntryPointSlots"), 1, "Indicates whether to enable entry point slot backpatching, for instance to avoid making virtual calls through a precode and instead to patch virtual slots for a method when its entry point changes.")
   392| CONFIG_DWORD_INFO(INTERNAL_TypeLoader_InjectInterfaceDuplicates, W("INTERNAL_TypeLoader_InjectInterfaceDuplicates"), 0, "Injects duplicates in interface map for all types.")
   393| CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubCollideMonoPct, W("VirtualCallStubCollideMonoPct"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
   394| CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubCollideWritePct, W("VirtualCallStubCollideWritePct"), 100, "Used only when STUB_LOGGING is defined, which by default is not.")
   395| CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubDumpLogCounter, W("VirtualCallStubDumpLogCounter"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
   396| CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubDumpLogIncr, W("VirtualCallStubDumpLogIncr"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
   397| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_VirtualCallStubLogging, W("VirtualCallStubLogging"), 0, "Worth keeping, but should be moved into \"#ifdef STUB_LOGGING\" blocks. This goes for most (or all) of the stub logging infrastructure.")
   398| CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubMissCount, W("VirtualCallStubMissCount"), 100, "Used only when STUB_LOGGING is defined, which by default is not.")
   399| CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubResetCacheCounter, W("VirtualCallStubResetCacheCounter"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
   400| CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubResetCacheIncr, W("VirtualCallStubResetCacheIncr"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
   401| RETAIL_CONFIG_DWORD_INFO(INTERNAL_DisableWatsonForManagedExceptions, W("DisableWatsonForManagedExceptions"), 0, "Disable Watson and debugger launching for managed exceptions")
   402| RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgEnableMiniDump, W("DbgEnableMiniDump"), 0, "Enable unhandled exception crash dump generation")
   403| RETAIL_CONFIG_STRING_INFO(INTERNAL_DbgMiniDumpName, W("DbgMiniDumpName"), "Crash dump name")
   404| RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgMiniDumpType, W("DbgMiniDumpType"), 0, "Crash dump type: 1 normal, 2 withheap, 3 triage, 4 full")
   405| RETAIL_CONFIG_DWORD_INFO(INTERNAL_CreateDumpDiagnostics, W("CreateDumpDiagnostics"), 0, "Enable crash dump generation diagnostic logging")
   406| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EnableDumpOnSigTerm, W("EnableDumpOnSigTerm"), 0, "Enable crash dump generation on SIGTERM")
   407| RETAIL_CONFIG_STRING_INFO(INTERNAL_ZapBBInstr, W("ZapBBInstr"), "")
   408| RETAIL_CONFIG_STRING_INFO(EXTERNAL_ZapBBInstrDir, W("ZapBBInstrDir"), "")
   409| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ZapDisable, W("ZapDisable"), 0, "")
   410| RETAIL_CONFIG_STRING_INFO(INTERNAL_NativeImageSearchPaths, W("NativeImageSearchPaths"), "Extra search paths for native composite R2R images")
   411| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ReadyToRun, W("ReadyToRun"), 1, "Enable/disable use of ReadyToRun native code") // On by default for CoreCLR
   412| RETAIL_CONFIG_STRING_INFO(EXTERNAL_ReadyToRunExcludeList, W("ReadyToRunExcludeList"), "List of assemblies that cannot use Ready to Run images")
   413| RETAIL_CONFIG_STRING_INFO(EXTERNAL_ReadyToRunLogFile, W("ReadyToRunLogFile"), "Name of file to log success/failure of using Ready to Run images")
   414| #if defined(FEATURE_EVENT_TRACE) || defined(FEATURE_EVENTSOURCE_XPLAT)
   415| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableEventLog, W("EnableEventLog"), 0, "Enable/disable use of EnableEventLogging mechanism ") // Off by default
   416| RETAIL_CONFIG_STRING_INFO(INTERNAL_EventSourceFilter, W("EventSourceFilter"), "")
   417| RETAIL_CONFIG_STRING_INFO(INTERNAL_EventNameFilter, W("EventNameFilter"), "")
   418| #endif //defined(FEATURE_EVENT_TRACE) || defined(FEATURE_EVENTSOURCE_XPLAT)
   419| CONFIG_DWORD_INFO(INTERNAL_ExposeExceptionsInCOM, W("ExposeExceptionsInCOM"), 0, "")
   420| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_InteropValidatePinnedObjects, W("InteropValidatePinnedObjects"), 0, "After returning from a managed-to-unmanaged interop call, validate GC heap around objects pinned by IL stubs.")
   421| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_InteropLogArguments, W("InteropLogArguments"), 0, "Log all pinned arguments passed to an interop call")
   422| RETAIL_CONFIG_STRING_INFO(UNSUPPORTED_LogCCWRefCountChange, W("LogCCWRefCountChange"), "Outputs debug information and calls LogCCWRefCountChange_BREAKPOINT when AddRef or Release is called on a CCW.")
   423| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EnableRCWCleanupOnSTAShutdown, W("EnableRCWCleanupOnSTAShutdown"), 0, "Performs RCW cleanup when STA shutdown is detected using IInitializeSpy in classic processes.")
   424| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EnableEventPipe, W("EnableEventPipe"), 0, "Enable/disable event pipe.  Non-zero values enable tracing.")
   425| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeNetTraceFormat, W("EventPipeNetTraceFormat"), 1, "Enable/disable using the newer nettrace file format.")
   426| RETAIL_CONFIG_STRING_INFO(INTERNAL_EventPipeOutputPath, W("EventPipeOutputPath"), "The full path excluding file name for the trace file that will be written when COMPlus_EnableEventPipe=1")
   427| RETAIL_CONFIG_STRING_INFO(INTERNAL_EventPipeConfig, W("EventPipeConfig"), "Configuration for EventPipe.")
   428| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeRundown, W("EventPipeRundown"), 1, "Enable/disable eventpipe rundown.")
   429| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeCircularMB, W("EventPipeCircularMB"), 1024, "The EventPipe circular buffer size in megabytes.")
   430| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeProcNumbers, W("EventPipeProcNumbers"), 0, "Enable/disable capturing processor numbers in EventPipe event headers")
   431| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeOutputStreaming, W("EventPipeOutputStreaming"), 0, "Enable/disable streaming for trace file set in COMPlus_EventPipeOutputPath.  Non-zero values enable streaming.")
   432| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeEnableStackwalk, W("EventPipeEnableStackwalk"), 1, "Set to 0 to disable collecting stacks for EventPipe events.")
   433| #ifdef FEATURE_AUTO_TRACE
   434| RETAIL_CONFIG_DWORD_INFO_EX(INTERNAL_AutoTrace_N_Tracers, W("AutoTrace_N_Tracers"), 0, "", CLRConfig::LookupOptions::ParseIntegerAsBase10)
   435| RETAIL_CONFIG_STRING_INFO(INTERNAL_AutoTrace_Command, W("AutoTrace_Command"), "")
   436| #endif // FEATURE_AUTO_TRACE
   437| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisGen, W("GCGenAnalysisGen"), 0, "The generation to trigger generational aware analysis")
   438| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisBytes, W("GCGenAnalysisBytes"), 0, "The number of bytes to trigger generational aware analysis")
   439| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisTimeUSec, W("GCGenAnalysisTimeUSec"), 0, "The number of microseconds to trigger generational aware analysis")
   440| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisTimeMSec, W("GCGenAnalysisTimeMSec"), 0, "The number of milliseconds to trigger generational aware analysis")
   441| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisIndex, W("GCGenAnalysisIndex"), 0, "The gc index to trigger generational aware analysis")
   442| RETAIL_CONFIG_STRING_INFO(EXTERNAL_GCGenAnalysisCmd, W("GCGenAnalysisCmd"), "An optional filter to match with the command line used to spawn the process")
   443| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisTrace, W("GCGenAnalysisTrace"), 1, "Enable/Disable capturing a trace")
   444| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisDump, W("GCGenAnalysisDump"), 0, "Enable/Disable capturing a dump")
   445| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_DOTNET_DefaultDiagnosticPortSuspend, W("DefaultDiagnosticPortSuspend"), 0, "This sets the deafult diagnostic port to suspend causing the runtime to pause during startup before major subsystems are started.  Resume using the Diagnostics IPC ResumeStartup command on the default diagnostic port.");
   446| RETAIL_CONFIG_STRING_INFO(EXTERNAL_DOTNET_DiagnosticPorts, W("DiagnosticPorts"), "A semicolon delimited list of additional Diagnostic Ports, where a Diagnostic Port is a NamedPipe path without '\\\\.\\pipe\\' on Windows or the full path of Unix Domain Socket on Linux/Unix followed by optional tags, e.g., '<path>,connect,nosuspend;<path>'");
   447| RETAIL_CONFIG_STRING_INFO(INTERNAL_LTTngConfig, W("LTTngConfig"), "Configuration for LTTng.")
   448| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_LTTng, W("LTTng"), 1, "If COMPlus_LTTng is set to 0, this will prevent the LTTng library from being loaded at runtime")
   449| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableWriteXorExecute, W("EnableWriteXorExecute"), 1, "Enable W^X for executable memory.");
   450| #ifdef FEATURE_GDBJIT
   451| CONFIG_STRING_INFO(INTERNAL_GDBJitElfDump, W("GDBJitElfDump"), "Dump ELF for specified method")
   452| #ifdef FEATURE_GDBJIT_FRAME
   453| RETAIL_CONFIG_DWORD_INFO(INTERNAL_GDBJitEmitDebugFrame, W("GDBJitEmitDebugFrame"), TRUE, "Enable .debug_frame generation")
   454| #endif
   455| #endif
   456| #if defined(TARGET_LOONGARCH64)
   457| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableHWIntrinsic,  W("EnableHWIntrinsic"),  0, "Allows Base+ hardware intrinsics to be disabled")
   458| #else
   459| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableHWIntrinsic,  W("EnableHWIntrinsic"),  1, "Allows Base+ hardware intrinsics to be disabled")
   460| #endif // defined(TARGET_LOONGARCH64)
   461| #if defined(TARGET_AMD64) || defined(TARGET_X86)
   462| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableAES,          W("EnableAES"),          1, "Allows AES+ hardware intrinsics to be disabled")
   463| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableAVX,          W("EnableAVX"),          1, "Allows AVX+ hardware intrinsics to be disabled")
   464| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableAVX2,         W("EnableAVX2"),         1, "Allows AVX2+ hardware intrinsics to be disabled")
   465| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableAVXVNNI,      W("EnableAVXVNNI"),      1, "Allows AVX VNNI+ hardware intrinsics to be disabled")
   466| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableBMI1,         W("EnableBMI1"),         1, "Allows BMI1+ hardware intrinsics to be disabled")
   467| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableBMI2,         W("EnableBMI2"),         1, "Allows BMI2+ hardware intrinsics to be disabled")
   468| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableFMA,          W("EnableFMA"),          1, "Allows FMA+ hardware intrinsics to be disabled")
   469| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableLZCNT,        W("EnableLZCNT"),        1, "Allows LZCNT+ hardware intrinsics to be disabled")
   470| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnablePCLMULQDQ,    W("EnablePCLMULQDQ"),    1, "Allows PCLMULQDQ+ hardware intrinsics to be disabled")
   471| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableMOVBE,        W("EnableMOVBE"),        1, "Allows MOVBE+ hardware intrinsics to be disabled")
   472| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnablePOPCNT,       W("EnablePOPCNT"),       1, "Allows POPCNT+ hardware intrinsics to be disabled")
   473| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSE,          W("EnableSSE"),          1, "Allows SSE+ hardware intrinsics to be disabled")
   474| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSE2,         W("EnableSSE2"),         1, "Allows SSE2+ hardware intrinsics to be disabled")
   475| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSE3,         W("EnableSSE3"),         1, "Allows SSE3+ hardware intrinsics to be disabled")
   476| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSE3_4,       W("EnableSSE3_4"),       1, "Allows SSE3+ hardware intrinsics to be disabled")
   477| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSE41,        W("EnableSSE41"),        1, "Allows SSE4.1+ hardware intrinsics to be disabled")
   478| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSE42,        W("EnableSSE42"),        1, "Allows SSE4.2+ hardware intrinsics to be disabled")
   479| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSSE3,        W("EnableSSSE3"),        1, "Allows SSSE3+ hardware intrinsics to be disabled")
   480| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableX86Serialize, W("EnableX86Serialize"), 1, "Allows X86Serialize+ hardware intrinsics to be disabled")
   481| #elif defined(TARGET_ARM64)
   482| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64AdvSimd, W("EnableArm64AdvSimd"), 1, "Allows Arm64 AdvSimd+ hardware intrinsics to be disabled")
   483| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Aes,     W("EnableArm64Aes"),     1, "Allows Arm64 Aes+ hardware intrinsics to be disabled")
   484| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Atomics, W("EnableArm64Atomics"), 1, "Allows Arm64 Atomics+ hardware intrinsics to be disabled")
   485| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Crc32,   W("EnableArm64Crc32"),   1, "Allows Arm64 Crc32+ hardware intrinsics to be disabled")
   486| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Dczva,   W("EnableArm64Dczva"),   1, "Allows Arm64 Dczva+ hardware intrinsics to be disabled")
   487| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Dp,      W("EnableArm64Dp"),      1, "Allows Arm64 Dp+ hardware intrinsics to be disabled")
   488| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Rdm,     W("EnableArm64Rdm"),     1, "Allows Arm64 Rdm+ hardware intrinsics to be disabled")
   489| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Sha1,    W("EnableArm64Sha1"),    1, "Allows Arm64 Sha1+ hardware intrinsics to be disabled")
   490| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Sha256,  W("EnableArm64Sha256"),  1, "Allows Arm64 Sha256+ hardware intrinsics to be disabled")
   491| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Rcpc,    W("EnableArm64Rcpc"),    1, "Allows Arm64 Rcpc+ hardware intrinsics to be disabled")
   492| #endif
   493| CONFIG_DWORD_INFO(INTERNAL_ActivatePatchSkip, W("ActivatePatchSkip"), 0, "Allows an assert when ActivatePatchSkip is called")
   494| CONFIG_DWORD_INFO(INTERNAL_AlwaysUseMetadataInterfaceMapLayout, W("AlwaysUseMetadataInterfaceMapLayout"), 0, "Used for debugging generic interface map layout.")
   495| CONFIG_DWORD_INFO(INTERNAL_AssertOnUnneededThis, W("AssertOnUnneededThis"), 0, "While the ConfigDWORD is unnecessary, the contained ASSERT should be kept. This may result in some work tracking down violating MethodDescCallSites.")
   496| CONFIG_DWORD_INFO(INTERNAL_AssertStacktrace, W("AssertStacktrace"), 1, "")
   497| CONFIG_DWORD_INFO(INTERNAL_clearNativeImageStress, W("clearNativeImageStress"), 0, "")
   498| CONFIG_DWORD_INFO(INTERNAL_CPUFamily, W("CPUFamily"), 0xFFFFFFFF, "")
   499| CONFIG_DWORD_INFO(INTERNAL_CPUFeatures, W("CPUFeatures"), 0xFFFFFFFF, "")
   500| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_DisableConfigCache, W("DisableConfigCache"), 0, "Used to disable the \"probabilistic\" config cache, which walks through the appropriate config registry keys on init and probabilistically keeps track of which exist.")
   501| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_DisableStackwalkCache, W("DisableStackwalkCache"), 0, "")
   502| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DoubleArrayToLargeObjectHeap, W("DoubleArrayToLargeObjectHeap"), 0, "Controls double[] placement")
   503| CONFIG_STRING_INFO(INTERNAL_DumpOnClassLoad, W("DumpOnClassLoad"), "Dumps information about loaded class to log.")
   504| CONFIG_DWORD_INFO(INTERNAL_ExpandAllOnLoad, W("ExpandAllOnLoad"), 0, "")
   505| CONFIG_DWORD_INFO(INTERNAL_ForceRelocs, W("ForceRelocs"), 0, "")
   506| CONFIG_DWORD_INFO(INTERNAL_GenerateLongJumpDispatchStubRatio, W("GenerateLongJumpDispatchStubRatio"), 0, "Useful for testing VSD on AMD64")
   507| CONFIG_DWORD_INFO(INTERNAL_HashStack, W("HashStack"), 0, "")
   508| CONFIG_DWORD_INFO(INTERNAL_HostManagerConfig, W("HostManagerConfig"), (DWORD)-1, "")
   509| CONFIG_DWORD_INFO(INTERNAL_HostTestThreadAbort, W("HostTestThreadAbort"), 0, "")
   510| CONFIG_STRING_INFO(INTERNAL_InvokeHalt, W("InvokeHalt"), "Throws an assert when the given method is invoked through reflection.")
   511| CONFIG_DWORD_INFO(INTERNAL_MaxStubUnwindInfoSegmentSize, W("MaxStubUnwindInfoSegmentSize"), 0, "")
   512| CONFIG_DWORD_INFO(INTERNAL_MessageDebugOut, W("MessageDebugOut"), 0, "")
   513| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_NativeImageRequire, W("NativeImageRequire"), 0, "")
   514| CONFIG_DWORD_INFO(INTERNAL_NestedEhOom, W("NestedEhOom"), 0, "")
   515| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_NoProcedureSplitting, W("NoProcedureSplitting"), 0, "")
   516| CONFIG_DWORD_INFO(INTERNAL_PauseOnLoad, W("PauseOnLoad"), 0, "Stops in SystemDomain::init. I think it can be removed.")
   517| CONFIG_DWORD_INFO(INTERNAL_PerfAllocsSizeThreshold, W("PerfAllocsSizeThreshold"), 0x3FFFFFFF, "Log facility LF_GCALLOC logs object allocations. This flag controls which ones also log stacktraces. Predates ClrProfiler.")
   518| CONFIG_DWORD_INFO(INTERNAL_PerfNumAllocsThreshold, W("PerfNumAllocsThreshold"), 0x3FFFFFFF, "Log facility LF_GCALLOC logs object allocations. This flag controls which ones also log stacktraces. Predates ClrProfiler.")
   519| CONFIG_STRING_INFO(INTERNAL_PerfTypesToLog, W("PerfTypesToLog"), "Log facility LF_GCALLOC logs object allocations. This flag controls which ones also log stacktraces. Predates ClrProfiler.")
   520| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_Prepopulate1, W("Prepopulate1"), 1, "")
   521| CONFIG_STRING_INFO(INTERNAL_PrestubGC, W("PrestubGC"), "")
   522| CONFIG_STRING_INFO(INTERNAL_PrestubHalt, W("PrestubHalt"), "")
   523| RETAIL_CONFIG_STRING_INFO(EXTERNAL_RestrictedGCStressExe, W("RestrictedGCStressExe"), "")
   524| CONFIG_DWORD_INFO(INTERNAL_ReturnSourceTypeForTesting, W("ReturnSourceTypeForTesting"), 0, "Allows returning the (internal only) source type of an IL to Native mapping for debugging purposes")
   525| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_RSStressLog, W("RSStressLog"), 0, "Allows turning on logging for RS startup")
   526| CONFIG_DWORD_INFO(INTERNAL_SBDumpOnNewIndex, W("SBDumpOnNewIndex"), 0, "Used for Syncblock debugging. It's been a while since any of those have been used.")
   527| CONFIG_DWORD_INFO(INTERNAL_SBDumpOnResize, W("SBDumpOnResize"), 0, "Used for Syncblock debugging. It's been a while since any of those have been used.")
   528| CONFIG_DWORD_INFO(INTERNAL_SBDumpStyle, W("SBDumpStyle"), 0, "Used for Syncblock debugging. It's been a while since any of those have been used.")
   529| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_SleepOnExit, W("SleepOnExit"), 0, "Used for lrak detection. I'd say deprecated by umdh.")
   530| CONFIG_DWORD_INFO(INTERNAL_StubLinkerUnwindInfoVerificationOn, W("StubLinkerUnwindInfoVerificationOn"), 0, "")
   531| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_SuccessExit, W("SuccessExit"), 0, "")
   532| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TestDataConsistency, W("TestDataConsistency"), FALSE, "Allows ensuring the left side is not holding locks (and may thus be in an inconsistent state) when inspection occurs")
   533| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ThreadGuardPages, W("ThreadGuardPages"), 0, "")
   534| #ifdef _DEBUG
   535| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TraceWrap, W("TraceWrap"), 0, "")
   536| #endif
   537| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_UseMethodDataCache, W("UseMethodDataCache"), FALSE, "Used during feature development; may now be removed.")
   538| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_UseParentMethodData, W("UseParentMethodData"), TRUE, "Used during feature development; may now be removed.")
   539| CONFIG_DWORD_INFO(INTERNAL_VerifierOff, W("VerifierOff"), 0, "")


# ====================================================================
# FILE: src/coreclr/nativeaot/Runtime/unix/PalRedhawkUnix.cpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1082 ---
     1| #include <stdio.h>
     2| #include <errno.h>
     3| #include <cwchar>
     4| #include <sal.h>
     5| #include "config.h"
     6| #include "UnixHandle.h"
     7| #include <pthread.h>
     8| #include "gcenv.h"
     9| #include "gcenv.ee.h"
    10| #include "gcconfig.h"
    11| #include "holder.h"
    12| #include "UnixSignals.h"
    13| #include "UnixContext.h"
    14| #include "HardwareExceptions.h"
    15| #include "cgroupcpu.h"
    16| #define _T(s) s
    17| #include "RhConfig.h"
    18| #include <unistd.h>
    19| #include <sched.h>
    20| #include <sys/mman.h>
    21| #include <sys/types.h>
    22| #include <sys/syscall.h>
    23| #include <dlfcn.h>
    24| #include <dirent.h>
    25| #include <string.h>
    26| #include <ctype.h>
    27| #include <sys/stat.h>
    28| #include <fcntl.h>
    29| #include <sys/time.h>
    30| #include <cstdarg>
    31| #include <signal.h>
    32| #if HAVE_PTHREAD_GETTHREADID_NP
    33| #include <pthread_np.h>
    34| #endif
    35| #if HAVE_LWP_SELF
    36| #include <lwp.h>
    37| #endif
    38| #if HAVE_SYS_VMPARAM_H
    39| #include <sys/vmparam.h>
    40| #endif  // HAVE_SYS_VMPARAM_H
    41| #if HAVE_MACH_VM_TYPES_H
    42| #include <mach/vm_types.h>
    43| #endif // HAVE_MACH_VM_TYPES_H
    44| #if HAVE_MACH_VM_PARAM_H
    45| #include <mach/vm_param.h>
    46| #endif  // HAVE_MACH_VM_PARAM_H
    47| #ifdef __APPLE__
    48| #include <mach/vm_statistics.h>
    49| #include <mach/mach_types.h>
    50| #include <mach/mach_init.h>
    51| #include <mach/mach_host.h>
    52| #include <mach/mach_port.h>
    53| #endif // __APPLE__
    54| #if HAVE_CLOCK_GETTIME_NSEC_NP
    55| #include <time.h>
    56| #endif
    57| using std::nullptr_t;
    58| #define PalRaiseFailFastException RaiseFailFastException
    59| #define INVALID_HANDLE_VALUE    ((HANDLE)(intptr_t)-1)
    60| #define PAGE_NOACCESS           0x01
    61| #define PAGE_READWRITE          0x04
    62| #define PAGE_EXECUTE_READ       0x20
    63| #define PAGE_EXECUTE_READWRITE  0x40
    64| #define MEM_COMMIT              0x1000
    65| #define MEM_RESERVE             0x2000
    66| #define MEM_DECOMMIT            0x4000
    67| #define MEM_RELEASE             0x8000
    68| #define WAIT_OBJECT_0           0
    69| #define WAIT_TIMEOUT            258
    70| #define WAIT_FAILED             0xFFFFFFFF
    71| static const int tccSecondsToMilliSeconds = 1000;
    72| static const int tccSecondsToMicroSeconds = 1000000;
    73| static const int tccSecondsToNanoSeconds = 1000000000;
    74| static const int tccMilliSecondsToMicroSeconds = 1000;
    75| static const int tccMilliSecondsToNanoSeconds = 1000000;
    76| static const int tccMicroSecondsToNanoSeconds = 1000;
    77| extern "C" void RaiseFailFastException(PEXCEPTION_RECORD arg1, PCONTEXT arg2, uint32_t arg3)
    78| {
    79|     abort();
    80| }
    81| static void TimeSpecAdd(timespec* time, uint32_t milliseconds)
    82| {
    83|     uint64_t nsec = time->tv_nsec + (uint64_t)milliseconds * tccMilliSecondsToNanoSeconds;
    84|     if (nsec >= tccSecondsToNanoSeconds)
    85|     {
    86|         time->tv_sec += nsec / tccSecondsToNanoSeconds;
    87|         nsec %= tccSecondsToNanoSeconds;
    88|     }
    89|     time->tv_nsec = nsec;
    90| }
    91| static void NanosecondsToTimeSpec(uint64_t nanoseconds, timespec* t)
    92| {
    93|     t->tv_sec = nanoseconds / tccSecondsToNanoSeconds;
    94|     t->tv_nsec = nanoseconds % tccSecondsToNanoSeconds;
    95| }
    96| void ReleaseCondAttr(pthread_condattr_t* condAttr)
    97| {
    98|     int st = pthread_condattr_destroy(condAttr);
    99|     ASSERT_MSG(st == 0, "Failed to destroy pthread_condattr_t object");
   100| }
   101| class PthreadCondAttrHolder : public Wrapper<pthread_condattr_t*, DoNothing, ReleaseCondAttr, nullptr>
   102| {
   103| public:
   104|     PthreadCondAttrHolder(pthread_condattr_t* attrs)
   105|     : Wrapper<pthread_condattr_t*, DoNothing, ReleaseCondAttr, nullptr>(attrs)
   106|     {
   107|     }
   108| };
   109| class UnixEvent
   110| {
   111|     pthread_cond_t m_condition;
   112|     pthread_mutex_t m_mutex;
   113|     bool m_manualReset;
   114|     bool m_state;
   115|     bool m_isValid;
   116| public:
   117|     UnixEvent(bool manualReset, bool initialState)
   118|     : m_manualReset(manualReset),
   119|       m_state(initialState),
   120|       m_isValid(false)
   121|     {
   122|     }
   123|     bool Initialize()
   124|     {
   125|         pthread_condattr_t attrs;
   126|         int st = pthread_condattr_init(&attrs);
   127|         if (st != 0)
   128|         {
   129|             ASSERT_UNCONDITIONALLY("Failed to initialize UnixEvent condition attribute");
   130|             return false;
   131|         }
   132|         PthreadCondAttrHolder attrsHolder(&attrs);
   133| #if HAVE_PTHREAD_CONDATTR_SETCLOCK && !HAVE_CLOCK_GETTIME_NSEC_NP
   134|         st = pthread_condattr_setclock(&attrs, CLOCK_MONOTONIC);
   135|         if (st != 0)
   136|         {
   137|             ASSERT_UNCONDITIONALLY("Failed to set UnixEvent condition variable wait clock");
   138|             return false;
   139|         }
   140| #endif // HAVE_PTHREAD_CONDATTR_SETCLOCK && !HAVE_CLOCK_GETTIME_NSEC_NP
   141|         st = pthread_mutex_init(&m_mutex, NULL);
   142|         if (st != 0)
   143|         {
   144|             ASSERT_UNCONDITIONALLY("Failed to initialize UnixEvent mutex");
   145|             return false;
   146|         }
   147|         st = pthread_cond_init(&m_condition, &attrs);
   148|         if (st != 0)
   149|         {
   150|             ASSERT_UNCONDITIONALLY("Failed to initialize UnixEvent condition variable");
   151|             st = pthread_mutex_destroy(&m_mutex);
   152|             ASSERT_MSG(st == 0, "Failed to destroy UnixEvent mutex");
   153|             return false;
   154|         }
   155|         m_isValid = true;
   156|         return true;
   157|     }
   158|     bool Destroy()
   159|     {
   160|         bool success = true;
   161|         if (m_isValid)
   162|         {
   163|             int st = pthread_mutex_destroy(&m_mutex);
   164|             ASSERT_MSG(st == 0, "Failed to destroy UnixEvent mutex");
   165|             success = success && (st == 0);
   166|             st = pthread_cond_destroy(&m_condition);
   167|             ASSERT_MSG(st == 0, "Failed to destroy UnixEvent condition variable");
   168|             success = success && (st == 0);
   169|         }
   170|         return success;
   171|     }
   172|     uint32_t Wait(uint32_t milliseconds)
   173|     {
   174|         timespec endTime;
   175| #if HAVE_CLOCK_GETTIME_NSEC_NP
   176|         uint64_t endNanoseconds;
   177|         if (milliseconds != INFINITE)
   178|         {
   179|             uint64_t nanoseconds = (uint64_t)milliseconds * tccMilliSecondsToNanoSeconds;
   180|             NanosecondsToTimeSpec(nanoseconds, &endTime);
   181|             endNanoseconds = clock_gettime_nsec_np(CLOCK_UPTIME_RAW) + nanoseconds;
   182|         }
   183| #elif HAVE_PTHREAD_CONDATTR_SETCLOCK
   184|         if (milliseconds != INFINITE)
   185|         {
   186|             clock_gettime(CLOCK_MONOTONIC, &endTime);
   187|             TimeSpecAdd(&endTime, milliseconds);
   188|         }
   189| #else
   190| #error "Don't know how to perform timed wait on this platform"
   191| #endif
   192|         int st = 0;
   193|         pthread_mutex_lock(&m_mutex);
   194|         while (!m_state)
   195|         {
   196|             if (milliseconds == INFINITE)
   197|             {
   198|                 st = pthread_cond_wait(&m_condition, &m_mutex);
   199|             }
   200|             else
   201|             {
   202| #if HAVE_CLOCK_GETTIME_NSEC_NP
   203|                 st = pthread_cond_timedwait_relative_np(&m_condition, &m_mutex, &endTime);
   204|                 if ((st == 0) && !m_state)
   205|                 {
   206|                     uint64_t currentNanoseconds = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
   207|                     if (currentNanoseconds < endNanoseconds)
   208|                     {
   209|                         uint64_t remainingNanoseconds = (endNanoseconds - currentNanoseconds);
   210|                         NanosecondsToTimeSpec(remainingNanoseconds, &endTime);
   211|                     }
   212|                     else
   213|                     {
   214|                         st = ETIMEDOUT;
   215|                     }
   216|                 }
   217| #else // HAVE_CLOCK_GETTIME_NSEC_NP
   218|                 st = pthread_cond_timedwait(&m_condition, &m_mutex, &endTime);
   219| #endif // HAVE_CLOCK_GETTIME_NSEC_NP
   220|                 ASSERT((st != ETIMEDOUT) || !m_state);
   221|             }
   222|             if (st != 0)
   223|             {
   224|                 break;
   225|             }
   226|         }
   227|         if ((st == 0) && !m_manualReset)
   228|         {
   229|             m_state = false;
   230|         }
   231|         pthread_mutex_unlock(&m_mutex);
   232|         uint32_t waitStatus;
   233|         if (st == 0)
   234|         {
   235|             waitStatus = WAIT_OBJECT_0;
   236|         }
   237|         else if (st == ETIMEDOUT)
   238|         {
   239|             waitStatus = WAIT_TIMEOUT;
   240|         }
   241|         else
   242|         {
   243|             waitStatus = WAIT_FAILED;
   244|         }
   245|         return waitStatus;
   246|     }
   247|     void Set()
   248|     {
   249|         pthread_mutex_lock(&m_mutex);
   250|         m_state = true;
   251|         pthread_cond_broadcast(&m_condition);
   252|         pthread_mutex_unlock(&m_mutex);
   253|     }
   254|     void Reset()
   255|     {
   256|         pthread_mutex_lock(&m_mutex);
   257|         m_state = false;
   258|         pthread_mutex_unlock(&m_mutex);
   259|     }
   260| };
   261| class EventUnixHandle : public UnixHandle<UnixHandleType::Event, UnixEvent>
   262| {
   263| public:
   264|     EventUnixHandle(UnixEvent event)
   265|     : UnixHandle<UnixHandleType::Event, UnixEvent>(event)
   266|     {
   267|     }
   268|     virtual bool Destroy()
   269|     {
   270|         return m_object.Destroy();
   271|     }
   272| };
   273| typedef UnixHandle<UnixHandleType::Thread, pthread_t> ThreadUnixHandle;
   274| #if !HAVE_THREAD_LOCAL
   275| extern "C" int __cxa_thread_atexit(void (*)(void*), void*, void *);
   276| extern "C" void *__dso_handle;
   277| #endif
   278| void ConfigureSignals()
   279| {
   280|     signal(SIGPIPE, SIG_IGN);
   281| }
   282| extern bool GetCpuLimit(uint32_t* val);
   283| void InitializeCurrentProcessCpuCount()
   284| {
   285|     uint32_t count;
   286|     const unsigned int MAX_PROCESSOR_COUNT = 0xffff;
   287|     uint32_t configValue;
   288|     if (g_pRhConfig->ReadConfigValue(_T("PROCESSOR_COUNT"), &configValue, true /* decimal */) &&
   289|         0 < configValue && configValue <= MAX_PROCESSOR_COUNT)
   290|     {
   291|         count = configValue;
   292|     }
   293|     else
   294|     {
   295| #if HAVE_SCHED_GETAFFINITY
   296|         cpu_set_t cpuSet;
   297|         int st = sched_getaffinity(getpid(), sizeof(cpu_set_t), &cpuSet);
   298|         if (st != 0)
   299|         {
   300|             _ASSERTE(!"sched_getaffinity failed");
   301|         }
   302|         count = CPU_COUNT(&cpuSet);
   303| #else // HAVE_SCHED_GETAFFINITY
   304|         count = GCToOSInterface::GetTotalProcessorCount();
   305| #endif // HAVE_SCHED_GETAFFINITY
   306|         uint32_t cpuLimit;
   307|         if (GetCpuLimit(&cpuLimit) && cpuLimit < count)
   308|             count = cpuLimit;
   309|     }
   310|     _ASSERTE(count > 0);
   311|     g_RhNumberOfProcessors = count;
   312| }
   313| REDHAWK_PALEXPORT bool REDHAWK_PALAPI PalInit()
   314| {
   315| #ifndef USE_PORTABLE_HELPERS
   316|     if (!InitializeHardwareExceptionHandling())
   317|     {
   318|         return false;
   319|     }
   320| #endif // !USE_PORTABLE_HELPERS
   321|     ConfigureSignals();
   322|     GCConfig::Initialize();
   323|     if (!GCToOSInterface::Initialize())
   324|     {
   325|         return false;
   326|     }
   327|     InitializeCpuCGroup();
   328|     InitializeCurrentProcessCpuCount();
   329|     return true;
   330| }
   331| #if HAVE_THREAD_LOCAL
   332| struct TlsDestructionMonitor
   333| {
   334|     void* m_thread = nullptr;
   335|     void SetThread(void* thread)
   336|     {
   337|         m_thread = thread;
   338|     }
   339|     ~TlsDestructionMonitor()
   340|     {
   341|         if (m_thread != nullptr)
   342|         {
   343|             RuntimeThreadShutdown(m_thread);
   344|         }
   345|     }
   346| };
   347| thread_local TlsDestructionMonitor tls_destructionMonitor;
   348| #endif // HAVE_THREAD_LOCAL
   349| DECLSPEC_THREAD intptr_t tls_thunkData;
   350| #ifdef FEATURE_EMULATED_TLS
   351| EXTERN_C intptr_t* RhpGetThunkData()
   352| {
   353|     return &tls_thunkData;
   354| }
   355| EXTERN_C intptr_t RhGetCurrentThunkContext()
   356| {
   357|     return tls_thunkData;
   358| }
   359| #endif //FEATURE_EMULATED_TLS
   360| extern "C" void PalAttachThread(void* thread)
   361| {
   362| #if HAVE_THREAD_LOCAL
   363|     tls_destructionMonitor.SetThread(thread);
   364| #else
   365|     __cxa_thread_atexit(RuntimeThreadShutdown, thread, &__dso_handle);
   366| #endif
   367| }
   368| extern "C" bool PalDetachThread(void* thread)
   369| {
   370|     UNREFERENCED_PARAMETER(thread);
   371|     if (g_threadExitCallback != nullptr)
   372|     {
   373|         g_threadExitCallback();
   374|     }
   375|     return true;
   376| }
   377| #if !defined(USE_PORTABLE_HELPERS) && !defined(FEATURE_RX_THUNKS)
   378| REDHAWK_PALEXPORT UInt32_BOOL REDHAWK_PALAPI PalAllocateThunksFromTemplate(HANDLE hTemplateModule, uint32_t templateRva, size_t templateSize, void** newThunksOut)
   379| {
   380|     PORTABILITY_ASSERT("UNIXTODO: Implement this function");
   381| }
   382| REDHAWK_PALEXPORT UInt32_BOOL REDHAWK_PALAPI PalFreeThunksFromTemplate(void *pBaseAddress)
   383| {
   384|     PORTABILITY_ASSERT("UNIXTODO: Implement this function");
   385| }
   386| #endif // !USE_PORTABLE_HELPERS && !FEATURE_RX_THUNKS
   387| REDHAWK_PALEXPORT UInt32_BOOL REDHAWK_PALAPI PalMarkThunksAsValidCallTargets(
   388|     void *virtualAddress,
   389|     int thunkSize,
   390|     int thunksPerBlock,
   391|     int thunkBlockSize,
   392|     int thunkBlocksPerMapping)
   393| {
   394|     return UInt32_TRUE;
   395| }
   396| REDHAWK_PALEXPORT void REDHAWK_PALAPI PalSleep(uint32_t milliseconds)
   397| {
   398| #if HAVE_CLOCK_NANOSLEEP
   399|     timespec endTime;
   400|     clock_gettime(CLOCK_MONOTONIC, &endTime);
   401|     TimeSpecAdd(&endTime, milliseconds);
   402|     while (clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &endTime, NULL) == EINTR)
   403|     {
   404|     }
   405| #else // HAVE_CLOCK_NANOSLEEP
   406|     timespec requested;
   407|     requested.tv_sec = milliseconds / tccSecondsToMilliSeconds;
   408|     requested.tv_nsec = (milliseconds - requested.tv_sec * tccSecondsToMilliSeconds) * tccMilliSecondsToNanoSeconds;
   409|     timespec remaining;
   410|     while (nanosleep(&requested, &remaining) == EINTR)
   411|     {
   412|         requested = remaining;
   413|     }
   414| #endif // HAVE_CLOCK_NANOSLEEP
   415| }
   416| REDHAWK_PALEXPORT UInt32_BOOL REDHAWK_PALAPI __stdcall PalSwitchToThread()
   417| {
   418|     sched_yield();
   419|     return false;
   420| }
   421| extern "C" UInt32_BOOL CloseHandle(HANDLE handle)
   422| {
   423|     if ((handle == NULL) || (handle == INVALID_HANDLE_VALUE))
   424|     {
   425|         return UInt32_FALSE;
   426|     }
   427|     UnixHandleBase* handleBase = (UnixHandleBase*)handle;
   428|     bool success = handleBase->Destroy();
   429|     delete handleBase;
   430|     return success ? UInt32_TRUE : UInt32_FALSE;
   431| }
   432| REDHAWK_PALEXPORT HANDLE REDHAWK_PALAPI PalCreateEventW(_In_opt_ LPSECURITY_ATTRIBUTES pEventAttributes, UInt32_BOOL manualReset, UInt32_BOOL initialState, _In_opt_z_ const wchar_t* pName)
   433| {
   434|     UnixEvent event = UnixEvent(manualReset, initialState);
   435|     if (!event.Initialize())
   436|     {
   437|         return INVALID_HANDLE_VALUE;
   438|     }
   439|     EventUnixHandle* handle = new (nothrow) EventUnixHandle(event);
   440|     if (handle == NULL)
   441|     {
   442|         return INVALID_HANDLE_VALUE;
   443|     }
   444|     return handle;
   445| }
   446| typedef uint32_t(__stdcall *BackgroundCallback)(_In_opt_ void* pCallbackContext);
   447| REDHAWK_PALEXPORT bool REDHAWK_PALAPI PalStartBackgroundWork(_In_ BackgroundCallback callback, _In_opt_ void* pCallbackContext, UInt32_BOOL highPriority)
   448| {
   449| #ifdef HOST_WASM
   450|     ASSERT(false);
   451| #endif // HOST_WASM
   452|     pthread_attr_t attrs;
   453|     int st = pthread_attr_init(&attrs);
   454|     ASSERT(st == 0);
   455|     static const int NormalPriority = 0;
   456|     static const int HighestPriority = -20;
   457| #if 0
   458|     sched_param params;
   459|     memset(&params, 0, sizeof(params));
   460|     params.sched_priority = highPriority ? HighestPriority : NormalPriority;
   461|     st = pthread_attr_setschedparam(&attrs, &params);
   462|     ASSERT(st == 0);
   463| #endif
   464|     st = pthread_attr_setdetachstate(&attrs, PTHREAD_CREATE_DETACHED);
   465|     ASSERT(st == 0);
   466|     pthread_t threadId;
   467|     st = pthread_create(&threadId, &attrs, (void *(*)(void*))callback, pCallbackContext);
   468|     int st2 = pthread_attr_destroy(&attrs);
   469|     ASSERT(st2 == 0);
   470|     return st == 0;
   471| }
   472| REDHAWK_PALEXPORT bool REDHAWK_PALAPI PalStartBackgroundGCThread(_In_ BackgroundCallback callback, _In_opt_ void* pCallbackContext)
   473| {
   474|     return PalStartBackgroundWork(callback, pCallbackContext, UInt32_FALSE);
   475| }
   476| REDHAWK_PALEXPORT bool REDHAWK_PALAPI PalStartFinalizerThread(_In_ BackgroundCallback callback, _In_opt_ void* pCallbackContext)
   477| {
   478| #ifdef HOST_WASM
   479|     return true;
   480| #else // HOST_WASM
   481|     return PalStartBackgroundWork(callback, pCallbackContext, UInt32_TRUE);
   482| #endif // HOST_WASM
   483| }
   484| REDHAWK_PALEXPORT uint64_t REDHAWK_PALAPI PalGetTickCount64()
   485| {
   486|     uint64_t retval = 0;
   487| #if HAVE_CLOCK_GETTIME_NSEC_NP
   488|     {
   489|         retval = clock_gettime_nsec_np(CLOCK_UPTIME_RAW) / tccMilliSecondsToNanoSeconds;
   490|     }
   491| #elif HAVE_CLOCK_MONOTONIC
   492|     {
   493|         clockid_t clockType =
   494| #if HAVE_CLOCK_MONOTONIC_COARSE
   495|             CLOCK_MONOTONIC_COARSE; // good enough resolution, fastest speed
   496| #else
   497|             CLOCK_MONOTONIC;
   498| #endif
   499|         struct timespec ts;
   500|         if (clock_gettime(clockType, &ts) == 0)
   501|         {
   502|             retval = (ts.tv_sec * tccSecondsToMilliSeconds) + (ts.tv_nsec / tccMilliSecondsToNanoSeconds);
   503|         }
   504|         else
   505|         {
   506|             ASSERT_UNCONDITIONALLY("clock_gettime(CLOCK_MONOTONIC) failed\n");
   507|         }
   508|     }
   509| #else
   510|     {
   511|         struct timeval tv;
   512|         if (gettimeofday(&tv, NULL) == 0)
   513|         {
   514|             retval = (tv.tv_sec * tccSecondsToMilliSeconds) + (tv.tv_usec / tccMilliSecondsToMicroSeconds);
   515|         }
   516|         else
   517|         {
   518|             ASSERT_UNCONDITIONALLY("gettimeofday() failed\n");
   519|         }
   520|     }
   521| #endif
   522|     return retval;
   523| }
   524| REDHAWK_PALEXPORT HANDLE REDHAWK_PALAPI PalGetModuleHandleFromPointer(_In_ void* pointer)
   525| {
   526|     HANDLE moduleHandle = NULL;
   527| #if !defined(HOST_WASM)
   528|     Dl_info info;
   529|     int st = dladdr(pointer, &info);
   530|     if (st != 0)
   531|     {
   532|         moduleHandle = info.dli_fbase;
   533|     }
   534| #endif //!defined(HOST_WASM)
   535|     return moduleHandle;
   536| }
   537| REDHAWK_PALEXPORT bool REDHAWK_PALAPI PalIsAvxEnabled()
   538| {
   539|     return true;
   540| }
   541| REDHAWK_PALEXPORT void PalPrintFatalError(const char* message)
   542| {
   543|     write(STDERR_FILENO, message, strlen(message));
   544| }
   545| static int W32toUnixAccessControl(uint32_t flProtect)
   546| {
   547|     int prot = 0;
   548|     switch (flProtect & 0xff)
   549|     {
   550|     case PAGE_NOACCESS:
   551|         prot = PROT_NONE;
   552|         break;
   553|     case PAGE_READWRITE:
   554|         prot = PROT_READ | PROT_WRITE;
   555|         break;
   556|     case PAGE_EXECUTE_READ:
   557|         prot = PROT_READ | PROT_EXEC;
   558|         break;
   559|     case PAGE_EXECUTE_READWRITE:
   560|         prot = PROT_READ | PROT_WRITE | PROT_EXEC;
   561|         break;
   562|     case PAGE_READONLY:
   563|         prot = PROT_READ;
   564|         break;
   565|     default:
   566|         ASSERT(false);
   567|         break;
   568|     }
   569|     return prot;
   570| }
   571| REDHAWK_PALEXPORT _Ret_maybenull_ _Post_writable_byte_size_(size) void* REDHAWK_PALAPI PalVirtualAlloc(_In_opt_ void* pAddress, size_t size, uint32_t allocationType, uint32_t protect)
   572| {
   573|     if ((allocationType & ~(MEM_RESERVE | MEM_COMMIT)) != 0)
   574|     {
   575|         return NULL;
   576|     }
   577|     ASSERT(((size_t)pAddress & (OS_PAGE_SIZE - 1)) == 0);
   578|     size = (size + (OS_PAGE_SIZE - 1)) & ~(OS_PAGE_SIZE - 1);
   579|     int unixProtect = W32toUnixAccessControl(protect);
   580|     if (allocationType & (MEM_RESERVE | MEM_COMMIT))
   581|     {
   582|         static const size_t Alignment = 64 * 1024;
   583|         size_t alignedSize = size + (Alignment - OS_PAGE_SIZE);
   584|         void * pRetVal = mmap(pAddress, alignedSize, unixProtect, MAP_ANON | MAP_PRIVATE, -1, 0);
   585|         if (pRetVal != NULL)
   586|         {
   587|             void * pAlignedRetVal = (void *)(((size_t)pRetVal + (Alignment - 1)) & ~(Alignment - 1));
   588|             size_t startPadding = (size_t)pAlignedRetVal - (size_t)pRetVal;
   589|             if (startPadding != 0)
   590|             {
   591|                 int ret = munmap(pRetVal, startPadding);
   592|                 ASSERT(ret == 0);
   593|             }
   594|             size_t endPadding = alignedSize - (startPadding + size);
   595|             if (endPadding != 0)
   596|             {
   597|                 int ret = munmap((void *)((size_t)pAlignedRetVal + size), endPadding);
   598|                 ASSERT(ret == 0);
   599|             }
   600|             pRetVal = pAlignedRetVal;
   601|         }
   602|         return pRetVal;
   603|     }
   604|     if (allocationType & MEM_COMMIT)
   605|     {
   606|         int ret = mprotect(pAddress, size, unixProtect);
   607|         return (ret == 0) ? pAddress : NULL;
   608|     }
   609|     return NULL;
   610| }
   611| REDHAWK_PALEXPORT UInt32_BOOL REDHAWK_PALAPI PalVirtualFree(_In_ void* pAddress, size_t size, uint32_t freeType)
   612| {
   613|     ASSERT(((freeType & MEM_RELEASE) != MEM_RELEASE) || size == 0);
   614|     ASSERT((freeType & (MEM_RELEASE | MEM_DECOMMIT)) != (MEM_RELEASE | MEM_DECOMMIT));
   615|     ASSERT(freeType != 0);
   616|     return UInt32_TRUE;
   617| }
   618| REDHAWK_PALEXPORT UInt32_BOOL REDHAWK_PALAPI PalVirtualProtect(_In_ void* pAddress, size_t size, uint32_t protect)
   619| {
   620|     int unixProtect = W32toUnixAccessControl(protect);
   621|     uint8_t* pPageStart = ALIGN_DOWN((uint8_t*)pAddress, OS_PAGE_SIZE);
   622|     size_t memSize = ALIGN_UP((uint8_t*)pAddress + size, OS_PAGE_SIZE) - pPageStart;
   623|     return mprotect(pPageStart, memSize, unixProtect) == 0;
   624| }
   625| REDHAWK_PALEXPORT void PalFlushInstructionCache(_In_ void* pAddress, size_t size)
   626| {
   627| #if defined(__linux__) && defined(HOST_ARM)
   628|     const size_t pageSize = getpagesize();
   629|     uint8_t* begin = (uint8_t*)pAddress;
   630|     uint8_t* end = begin + size;
   631|     while (begin < end)
   632|     {
   633|         uint8_t* endOrNextPageBegin = ALIGN_UP(begin + 1, pageSize);
   634|         if (endOrNextPageBegin > end)
   635|             endOrNextPageBegin = end;
   636|         __builtin___clear_cache((char *)begin, (char *)endOrNextPageBegin);
   637|         begin = endOrNextPageBegin;
   638|     }
   639| #else
   640|     __builtin___clear_cache((char *)pAddress, (char *)pAddress + size);
   641| #endif
   642| }
   643| REDHAWK_PALEXPORT _Ret_maybenull_ void* REDHAWK_PALAPI PalSetWerDataBuffer(_In_ void* pNewBuffer)
   644| {
   645|     static void* pBuffer;
   646|     return PalInterlockedExchangePointer(&pBuffer, pNewBuffer);
   647| }
   648| extern "C" HANDLE GetCurrentProcess()
   649| {
   650|     return (HANDLE)-1;
   651| }
   652| extern "C" uint32_t GetCurrentProcessId()
   653| {
   654|     return getpid();
   655| }
   656| extern "C" HANDLE GetCurrentThread()
   657| {
   658|     return (HANDLE)-2;
   659| }
   660| extern "C" UInt32_BOOL DuplicateHandle(
   661|     HANDLE hSourceProcessHandle,
   662|     HANDLE hSourceHandle,
   663|     HANDLE hTargetProcessHandle,
   664|     HANDLE * lpTargetHandle,
   665|     uint32_t dwDesiredAccess,
   666|     UInt32_BOOL bInheritHandle,
   667|     uint32_t dwOptions)
   668| {
   669|     ASSERT(hSourceProcessHandle == GetCurrentProcess());
   670|     ASSERT(hTargetProcessHandle == GetCurrentProcess());
   671|     ASSERT(hSourceHandle == GetCurrentThread());
   672|     *lpTargetHandle = new (nothrow) ThreadUnixHandle(pthread_self());
   673|     return lpTargetHandle != nullptr;
   674| }
   675| extern "C" UInt32_BOOL InitializeCriticalSection(CRITICAL_SECTION * lpCriticalSection)
   676| {
   677|     pthread_mutexattr_t mutexAttributes;
   678|     int st = pthread_mutexattr_init(&mutexAttributes);
   679|     if (st != 0)
   680|     {
   681|         return false;
   682|     }
   683|     st = pthread_mutexattr_settype(&mutexAttributes, PTHREAD_MUTEX_RECURSIVE);
   684|     if (st == 0)
   685|     {
   686|         st = pthread_mutex_init(&lpCriticalSection->mutex, &mutexAttributes);
   687|     }
   688|     pthread_mutexattr_destroy(&mutexAttributes);
   689|     return (st == 0);
   690| }
   691| extern "C" UInt32_BOOL InitializeCriticalSectionEx(CRITICAL_SECTION * lpCriticalSection, uint32_t arg2, uint32_t arg3)
   692| {
   693|     return InitializeCriticalSection(lpCriticalSection);
   694| }
   695| extern "C" void DeleteCriticalSection(CRITICAL_SECTION * lpCriticalSection)
   696| {
   697|     pthread_mutex_destroy(&lpCriticalSection->mutex);
   698| }
   699| extern "C" void EnterCriticalSection(CRITICAL_SECTION * lpCriticalSection)
   700| {
   701|     pthread_mutex_lock(&lpCriticalSection->mutex);;
   702| }
   703| extern "C" void LeaveCriticalSection(CRITICAL_SECTION * lpCriticalSection)
   704| {
   705|     pthread_mutex_unlock(&lpCriticalSection->mutex);
   706| }
   707| extern "C" UInt32_BOOL IsDebuggerPresent()
   708| {
   709| #ifdef HOST_WASM
   710|     return UInt32_TRUE;
   711| #else
   712|     return UInt32_FALSE;
   713| #endif
   714| }
   715| extern "C" UInt32_BOOL SetEvent(HANDLE event)
   716| {
   717|     EventUnixHandle* unixHandle = (EventUnixHandle*)event;
   718|     unixHandle->GetObject()->Set();
   719|     return UInt32_TRUE;
   720| }
   721| extern "C" UInt32_BOOL ResetEvent(HANDLE event)
   722| {
   723|     EventUnixHandle* unixHandle = (EventUnixHandle*)event;
   724|     unixHandle->GetObject()->Reset();
   725|     return UInt32_TRUE;
   726| }
   727| extern "C" uint32_t GetEnvironmentVariableA(const char * name, char * buffer, uint32_t size)
   728| {
   729|     const char* value = std::getenv(name);
   730|     if (value == NULL)
   731|     {
   732|         return 0;
   733|     }
   734|     size_t valueLen = strlen(value);
   735|     if (valueLen < size)
   736|     {
   737|         strcpy(buffer, value);
   738|         return valueLen;
   739|     }
   740|     return (valueLen < UINT32_MAX) ? (valueLen + 1) : 0;
   741| }
   742| extern "C" uint16_t RtlCaptureStackBackTrace(uint32_t arg1, uint32_t arg2, void* arg3, uint32_t* arg4)
   743| {
   744|     return 0;
   745| }
   746| static PalHijackCallback g_pHijackCallback;
   747| static struct sigaction g_previousActivationHandler;
   748| static void ActivationHandler(int code, siginfo_t* siginfo, void* context)
   749| {
   750|     if (g_pHijackCallback != NULL && (siginfo->si_pid == getpid()
   751| #ifdef HOST_OSX
   752|         || siginfo->si_pid == 0
   753| #endif
   754|         ))
   755|     {
   756|         int savedErrNo = errno;
   757|         g_pHijackCallback((NATIVE_CONTEXT*)context, NULL);
   758|         errno = savedErrNo;
   759|     }
   760|     else
   761|     {
   762|         if (g_previousActivationHandler.sa_flags & SA_SIGINFO)
   763|         {
   764|             _ASSERTE(g_previousActivationHandler.sa_sigaction != NULL);
   765|             g_previousActivationHandler.sa_sigaction(code, siginfo, context);
   766|         }
   767|         else
   768|         {
   769|             if (g_previousActivationHandler.sa_handler != SIG_IGN &&
   770|                 g_previousActivationHandler.sa_handler != SIG_DFL)
   771|             {
   772|                 _ASSERTE(g_previousActivationHandler.sa_handler != NULL);
   773|                 g_previousActivationHandler.sa_handler(code);
   774|             }
   775|         }
   776|     }
   777| }
   778| REDHAWK_PALEXPORT UInt32_BOOL REDHAWK_PALAPI PalRegisterHijackCallback(_In_ PalHijackCallback callback)
   779| {
   780|     ASSERT(g_pHijackCallback == NULL);
   781|     g_pHijackCallback = callback;
   782|     return AddSignalHandler(INJECT_ACTIVATION_SIGNAL, ActivationHandler, &g_previousActivationHandler);
   783| }
   784| REDHAWK_PALEXPORT void REDHAWK_PALAPI PalHijack(HANDLE hThread, _In_opt_ void* pThreadToHijack)
   785| {
   786|     ThreadUnixHandle* threadHandle = (ThreadUnixHandle*)hThread;
   787|     int status = pthread_kill(*threadHandle->GetObject(), INJECT_ACTIVATION_SIGNAL);
   788| #ifdef __APPLE__
   789|     if (status == ENOTSUP)
   790|     {
   791|         return;
   792|     }
   793| #endif
   794|     if ((status != 0) && (status != EAGAIN))
   795|     {
   796|         abort();
   797|     }
   798| }
   799| extern "C" uint32_t WaitForSingleObjectEx(HANDLE handle, uint32_t milliseconds, UInt32_BOOL alertable)
   800| {
   801|     UnixHandleBase* handleBase = (UnixHandleBase*)handle;
   802|     ASSERT(handleBase->GetType() == UnixHandleType::Event);
   803|     EventUnixHandle* unixHandle = (EventUnixHandle*)handleBase;
   804|     return unixHandle->GetObject()->Wait(milliseconds);
   805| }
   806| REDHAWK_PALEXPORT uint32_t REDHAWK_PALAPI PalCompatibleWaitAny(UInt32_BOOL alertable, uint32_t timeout, uint32_t handleCount, HANDLE* pHandles, UInt32_BOOL allowReentrantWait)
   807| {
   808|     ASSERT(handleCount == 1);
   809|     return WaitForSingleObjectEx(pHandles[0], timeout, alertable);
   810| }
   811| #if !__has_builtin(_mm_pause)
   812| extern "C" void _mm_pause()
   813| {
   814| #if defined(HOST_AMD64) || defined(HOST_X86)
   815|   __asm__ volatile ("pause");
   816| #endif
   817| }
   818| #endif
   819| extern "C" int32_t _stricmp(const char *string1, const char *string2)
   820| {
   821|     return strcasecmp(string1, string2);
   822| }
   823| REDHAWK_PALIMPORT void REDHAWK_PALAPI PopulateControlSegmentRegisters(CONTEXT* pContext)
   824| {
   825| #if defined(TARGET_X86) || defined(TARGET_AMD64)
   826| #endif
   827| }
   828| uint32_t g_RhNumberOfProcessors;
   829| REDHAWK_PALEXPORT int32_t PalGetProcessCpuCount()
   830| {
   831|     ASSERT(g_RhNumberOfProcessors > 0);
   832|     return g_RhNumberOfProcessors;
   833| }
   834| __thread void* pStackHighOut = NULL;
   835| __thread void* pStackLowOut = NULL;
   836| REDHAWK_PALEXPORT bool PalGetMaximumStackBounds(_Out_ void** ppStackLowOut, _Out_ void** ppStackHighOut)
   837| {
   838|     if (pStackHighOut == NULL)
   839|     {
   840| #ifdef __APPLE__
   841|         pStackHighOut = pthread_get_stackaddr_np(pthread_self());
   842|         pStackLowOut = ((uint8_t *)pStackHighOut - pthread_get_stacksize_np(pthread_self()));
   843| #else // __APPLE__
   844|         pthread_attr_t attr;
   845|         size_t stackSize;
   846|         int status;
   847|         pthread_t thread = pthread_self();
   848|         status = pthread_attr_init(&attr);
   849|         ASSERT_MSG(status == 0, "pthread_attr_init call failed");
   850| #if HAVE_PTHREAD_ATTR_GET_NP
   851|         status = pthread_attr_get_np(thread, &attr);
   852| #elif HAVE_PTHREAD_GETATTR_NP
   853|         status = pthread_getattr_np(thread, &attr);
   854| #else
   855| #error Dont know how to get thread attributes on this platform!
   856| #endif
   857|         ASSERT_MSG(status == 0, "pthread_getattr_np call failed");
   858|         status = pthread_attr_getstack(&attr, &pStackLowOut, &stackSize);
   859|         ASSERT_MSG(status == 0, "pthread_attr_getstack call failed");
   860|         status = pthread_attr_destroy(&attr);
   861|         ASSERT_MSG(status == 0, "pthread_attr_destroy call failed");
   862|         pStackHighOut = (uint8_t*)pStackLowOut + stackSize;
   863| #endif // __APPLE__
   864|     }
   865|     *ppStackLowOut = pStackLowOut;
   866|     *ppStackHighOut = pStackHighOut;
   867|     return true;
   868| }
   869| REDHAWK_PALEXPORT int32_t PalGetModuleFileName(_Out_ const TCHAR** pModuleNameOut, HANDLE moduleBase)
   870| {
   871| #if defined(HOST_WASM)
   872|     const TCHAR* wasmModuleName = "WebAssemblyModule";
   873|     *pModuleNameOut = wasmModuleName;
   874|     return strlen(wasmModuleName);
   875| #else // HOST_WASM
   876|     Dl_info dl;
   877|     if (dladdr(moduleBase, &dl) == 0)
   878|     {
   879|         *pModuleNameOut = NULL;
   880|         return 0;
   881|     }
   882|     *pModuleNameOut = dl.dli_fname;
   883|     return strlen(dl.dli_fname);
   884| #endif // defined(HOST_WASM)
   885| }
   886| extern "C" void FlushProcessWriteBuffers()
   887| {
   888|     GCToOSInterface::FlushProcessWriteBuffers();
   889| }
   890| static const int64_t SECS_BETWEEN_1601_AND_1970_EPOCHS = 11644473600LL;
   891| static const int64_t SECS_TO_100NS = 10000000; /* 10^7 */
   892| extern "C" void GetSystemTimeAsFileTime(FILETIME *lpSystemTimeAsFileTime)
   893| {
   894|     struct timeval time = { 0 };
   895|     gettimeofday(&time, NULL);
   896|     int64_t result = ((int64_t)time.tv_sec + SECS_BETWEEN_1601_AND_1970_EPOCHS) * SECS_TO_100NS +
   897|         (time.tv_usec * 10);
   898|     lpSystemTimeAsFileTime->dwLowDateTime = (uint32_t)result;
   899|     lpSystemTimeAsFileTime->dwHighDateTime = (uint32_t)(result >> 32);
   900| }
   901| extern "C" UInt32_BOOL QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
   902| {
   903|     struct timeval tv;
   904|     if (gettimeofday(&tv, NULL) == -1)
   905|     {
   906|         ASSERT_UNCONDITIONALLY("gettimeofday() failed");
   907|         return UInt32_FALSE;
   908|     }
   909|     lpPerformanceCount->QuadPart =
   910|         (int64_t) tv.tv_sec * (int64_t) tccSecondsToMicroSeconds + (int64_t) tv.tv_usec;
   911|     return UInt32_TRUE;
   912| }
   913| extern "C" UInt32_BOOL QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency)
   914| {
   915|     lpFrequency->QuadPart = (int64_t) tccSecondsToMicroSeconds;
   916|     return UInt32_TRUE;
   917| }
   918| extern "C" uint64_t PalGetCurrentThreadIdForLogging()
   919| {
   920| #if defined(__linux__)
   921|     return (uint64_t)syscall(SYS_gettid);
   922| #elif defined(__APPLE__)
   923|     uint64_t tid;
   924|     pthread_threadid_np(pthread_self(), &tid);
   925|     return (uint64_t)tid;
   926| #elif HAVE_PTHREAD_GETTHREADID_NP
   927|     return (uint64_t)pthread_getthreadid_np();
   928| #elif HAVE_LWP_SELF
   929|     return (uint64_t)_lwp_self();
   930| #else
   931|     return (uint64_t)pthread_self();
   932| #endif
   933| }
   934| #if defined(HOST_X86) || defined(HOST_AMD64)
   935| #if !__has_builtin(__cpuid)
   936| REDHAWK_PALEXPORT void __cpuid(int cpuInfo[4], int function_id)
   937| {
   938|     __asm("  cpuid\n" \
   939|         : "=a"(cpuInfo[0]), "=b"(cpuInfo[1]), "=c"(cpuInfo[2]), "=d"(cpuInfo[3]) \
   940|         : "0"(function_id)
   941|         );
   942| }
   943| #endif
   944| #if !__has_builtin(__cpuidex)
   945| REDHAWK_PALEXPORT void __cpuidex(int cpuInfo[4], int function_id, int subFunction_id)
   946| {
   947|     __asm("  cpuid\n" \
   948|         : "=a"(cpuInfo[0]), "=b"(cpuInfo[1]), "=c"(cpuInfo[2]), "=d"(cpuInfo[3]) \
   949|         : "0"(function_id), "2"(subFunction_id)
   950|         );
   951| }
   952| #endif
   953| REDHAWK_PALEXPORT uint32_t REDHAWK_PALAPI xmmYmmStateSupport()
   954| {
   955|     DWORD eax;
   956|     __asm("  xgetbv\n" \
   957|         : "=a"(eax) /*output in eax*/\
   958|         : "c"(0) /*inputs - 0 in ecx*/\
   959|         : "edx" /* registers that are clobbered*/
   960|       );
   961|     return ((eax & 0x06) == 0x06) ? 1 : 0;
   962| }
   963| #endif // defined(HOST_X86) || defined(HOST_AMD64)
   964| #if defined (HOST_ARM64)
   965| #if HAVE_AUXV_HWCAP_H
   966| #include <sys/auxv.h>
   967| #include <asm/hwcap.h>
   968| #endif
   969| #if HAVE_SYSCTLBYNAME
   970| #include <sys/sysctl.h>
   971| #endif
   972| REDHAWK_PALEXPORT void REDHAWK_PALAPI PAL_GetCpuCapabilityFlags(int* flags)
   973| {
   974|     *flags = 0;
   975| #if HAVE_AUXV_HWCAP_H
   976|     unsigned long hwCap = getauxval(AT_HWCAP);
   977| #ifdef HWCAP_AES
   978|     if (hwCap & HWCAP_AES)
   979|         *flags |= ARM64IntrinsicConstants_Aes;
   980| #endif
   981| #ifdef HWCAP_ATOMICS
   982|     if (hwCap & HWCAP_ATOMICS)
   983|         *flags |= ARM64IntrinsicConstants_Atomics;
   984| #endif
   985| #ifdef HWCAP_CRC32
   986|     if (hwCap & HWCAP_CRC32)
   987|         *flags |= ARM64IntrinsicConstants_Crc32;
   988| #endif
   989| #ifdef HWCAP_DCPOP
   990| #endif
   991| #ifdef HWCAP_ASIMDDP
   992|     if (hwCap & HWCAP_ASIMDDP)
   993|         *flags |= ARM64IntrinsicConstants_Dp;
   994| #endif
   995| #ifdef HWCAP_FCMA
   996| #endif
   997| #ifdef HWCAP_FP
   998| #endif
   999| #ifdef HWCAP_FPHP
  1000| #endif
  1001| #ifdef HWCAP_JSCVT
  1002| #endif
  1003| #ifdef HWCAP_LRCPC
  1004|       if (hwCap & HWCAP_LRCPC)
  1005|           *flags |= ARM64IntrinsicConstants_Rcpc;
  1006| #endif
  1007| #ifdef HWCAP_PMULL
  1008| #endif
  1009| #ifdef HWCAP_SHA1
  1010|     if (hwCap & HWCAP_SHA1)
  1011|         *flags |= ARM64IntrinsicConstants_Sha1;
  1012| #endif
  1013| #ifdef HWCAP_SHA2
  1014|     if (hwCap & HWCAP_SHA2)
  1015|         *flags |= ARM64IntrinsicConstants_Sha256;
  1016| #endif
  1017| #ifdef HWCAP_SHA512
  1018| #endif
  1019| #ifdef HWCAP_SHA3
  1020| #endif
  1021| #ifdef HWCAP_ASIMD
  1022|     if (hwCap & HWCAP_ASIMD)
  1023|         *flags |= ARM64IntrinsicConstants_AdvSimd;
  1024| #endif
  1025| #ifdef HWCAP_ASIMDRDM
  1026|     if (hwCap & HWCAP_ASIMDRDM)
  1027|         *flags |= ARM64IntrinsicConstants_Rdm;
  1028| #endif
  1029| #ifdef HWCAP_ASIMDHP
  1030| #endif
  1031| #ifdef HWCAP_SM3
  1032| #endif
  1033| #ifdef HWCAP_SM4
  1034| #endif
  1035| #ifdef HWCAP_SVE
  1036| #endif
  1037| #ifdef AT_HWCAP2
  1038|     unsigned long hwCap2 = getauxval(AT_HWCAP2);
  1039| #ifdef HWCAP2_DCPODP
  1040| #endif
  1041| #ifdef HWCAP2_SVE2
  1042| #endif
  1043| #ifdef HWCAP2_SVEAES
  1044| #endif
  1045| #ifdef HWCAP2_SVEPMULL
  1046| #endif
  1047| #ifdef HWCAP2_SVEBITPERM
  1048| #endif
  1049| #ifdef HWCAP2_SVESHA3
  1050| #endif
  1051| #ifdef HWCAP2_SVESM4
  1052| #endif
  1053| #ifdef HWCAP2_FLAGM2
  1054| #endif
  1055| #ifdef HWCAP2_FRINT
  1056| #endif
  1057| #endif // AT_HWCAP2
  1058| #else // !HAVE_AUXV_HWCAP_H
  1059| #if HAVE_SYSCTLBYNAME
  1060|     int64_t valueFromSysctl = 0;
  1061|     size_t sz = sizeof(valueFromSysctl);
  1062|     if ((sysctlbyname("hw.optional.arm.FEAT_AES", &valueFromSysctl, &sz, nullptr, 0) == 0) && (valueFromSysctl != 0))
  1063|         *flags |= ARM64IntrinsicConstants_Aes;
  1064|     if ((sysctlbyname("hw.optional.armv8_crc32", &valueFromSysctl, &sz, nullptr, 0) == 0) && (valueFromSysctl != 0))
  1065|         *flags |= ARM64IntrinsicConstants_Crc32;
  1066|     if ((sysctlbyname("hw.optional.arm.FEAT_DotProd", &valueFromSysctl, &sz, nullptr, 0) == 0) && (valueFromSysctl != 0))
  1067|         *flags |= ARM64IntrinsicConstants_Dp;
  1068|     if ((sysctlbyname("hw.optional.arm.FEAT_RDM", &valueFromSysctl, &sz, nullptr, 0) == 0) && (valueFromSysctl != 0))
  1069|         *flags |= ARM64IntrinsicConstants_Rdm;
  1070|     if ((sysctlbyname("hw.optional.arm.FEAT_SHA1", &valueFromSysctl, &sz, nullptr, 0) == 0) && (valueFromSysctl != 0))
  1071|         *flags |= ARM64IntrinsicConstants_Sha1;
  1072|     if ((sysctlbyname("hw.optional.arm.FEAT_SHA256", &valueFromSysctl, &sz, nullptr, 0) == 0) && (valueFromSysctl != 0))
  1073|         *flags |= ARM64IntrinsicConstants_Sha256;
  1074|     if ((sysctlbyname("hw.optional.armv8_1_atomics", &valueFromSysctl, &sz, nullptr, 0) == 0) && (valueFromSysctl != 0))
  1075|         *flags |= ARM64IntrinsicConstants_Atomics;
  1076|     if ((sysctlbyname("hw.optional.arm.FEAT_LRCPC", &valueFromSysctl, &sz, nullptr, 0) == 0) && (valueFromSysctl != 0))
  1077|         *flags |= ARM64IntrinsicConstants_Rcpc;
  1078| #endif // HAVE_SYSCTLBYNAME
  1079|     *flags |= ARM64IntrinsicConstants_AdvSimd;
  1080| #endif // HAVE_AUXV_HWCAP_H
  1081| }
  1082| #endif


# ====================================================================
# FILE: src/coreclr/nativeaot/System.Private.CoreLib/src/Internal/Runtime/CompilerHelpers/InteropHelpers.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-515 ---
     1| using System;
     2| using System.Collections.Concurrent;
     3| using System.Diagnostics;
     4| using System.Diagnostics.CodeAnalysis;
     5| using System.Reflection;
     6| using System.Runtime;
     7| using System.Runtime.CompilerServices;
     8| using System.Runtime.InteropServices;
     9| using System.Runtime.Loader;
    10| using System.Text;
    11| using System.Threading;
    12| using Internal.Runtime;
    13| using Internal.Runtime.Augments;
    14| namespace Internal.Runtime.CompilerHelpers
    15| {
    16|     internal static class InteropHelpers
    17|     {
    18|         internal static unsafe byte* StringToAnsiString(string str, bool bestFit, bool throwOnUnmappableChar)
    19|         {
    20|             return PInvokeMarshal.StringToAnsiString(str, bestFit, throwOnUnmappableChar);
    21|         }
    22|         public static unsafe string AnsiStringToString(byte* buffer)
    23|         {
    24|             return PInvokeMarshal.AnsiStringToString(buffer);
    25|         }
    26|         internal static unsafe void StringToByValAnsiString(string str, byte* pNative, int charCount, bool bestFit, bool throwOnUnmappableChar)
    27|         {
    28|             if (str != null)
    29|             {
    30|                 int lenUnicode = str.Length;
    31|                 if (lenUnicode >= charCount)
    32|                     lenUnicode = charCount - 1;
    33|                 fixed (char* pManaged = str)
    34|                 {
    35|                     PInvokeMarshal.StringToAnsiString(pManaged, lenUnicode, pNative, /*terminateWithNull=*/true, bestFit, throwOnUnmappableChar);
    36|                 }
    37|             }
    38|             else
    39|             {
    40|                 (*pNative) = (byte)'\0';
    41|             }
    42|         }
    43|         public static unsafe string ByValAnsiStringToString(byte* buffer, int length)
    44|         {
    45|             int end = new ReadOnlySpan<byte>(buffer, length).IndexOf((byte)0);
    46|             if (end >= 0)
    47|             {
    48|                 length = end;
    49|             }
    50|             return new string((sbyte*)buffer, 0, length);
    51|         }
    52|         internal static unsafe void StringToUnicodeFixedArray(string str, ushort* buffer, int length)
    53|         {
    54|             ReadOnlySpan<char> managed = str;
    55|             Span<char> native = new Span<char>((char*)buffer, length);
    56|             int numChars = Math.Min(managed.Length, length - 1);
    57|             managed.Slice(0, numChars).CopyTo(native);
    58|             native[numChars] = '\0';
    59|         }
    60|         internal static unsafe string UnicodeToStringFixedArray(ushort* buffer, int length)
    61|         {
    62|             int end = new ReadOnlySpan<char>(buffer, length).IndexOf('\0');
    63|             if (end >= 0)
    64|             {
    65|                 length = end;
    66|             }
    67|             return new string((char*)buffer, 0, length);
    68|         }
    69|         internal static unsafe char* StringToUnicodeBuffer(string str)
    70|         {
    71|             return (char*)Marshal.StringToCoTaskMemUni(str);
    72|         }
    73|         public static unsafe byte* AllocMemoryForAnsiStringBuilder(StringBuilder sb)
    74|         {
    75|             if (sb == null)
    76|             {
    77|                 return null;
    78|             }
    79|             return (byte *)CoTaskMemAllocAndZeroMemory(checked((sb.Capacity + 2) * Marshal.SystemMaxDBCSCharSize));
    80|         }
    81|         public static unsafe char* AllocMemoryForUnicodeStringBuilder(StringBuilder sb)
    82|         {
    83|             if (sb == null)
    84|             {
    85|                 return null;
    86|             }
    87|             return (char *)CoTaskMemAllocAndZeroMemory(checked((sb.Capacity + 2) * 2));
    88|         }
    89|         public static unsafe byte* AllocMemoryForAnsiCharArray(char[] chArray)
    90|         {
    91|             if (chArray == null)
    92|             {
    93|                 return null;
    94|             }
    95|             return (byte*)CoTaskMemAllocAndZeroMemory(checked((chArray.Length + 2) * Marshal.SystemMaxDBCSCharSize));
    96|         }
    97|         public static unsafe void AnsiStringToStringBuilder(byte* newBuffer, System.Text.StringBuilder stringBuilder)
    98|         {
    99|             if (stringBuilder == null)
   100|                 return;
   101|             PInvokeMarshal.AnsiStringToStringBuilder(newBuffer, stringBuilder);
   102|         }
   103|         public static unsafe void UnicodeStringToStringBuilder(ushort* newBuffer, System.Text.StringBuilder stringBuilder)
   104|         {
   105|             if (stringBuilder == null)
   106|                 return;
   107|             PInvokeMarshal.UnicodeStringToStringBuilder(newBuffer, stringBuilder);
   108|         }
   109|         public static unsafe void StringBuilderToAnsiString(System.Text.StringBuilder stringBuilder, byte* pNative,
   110|             bool bestFit, bool throwOnUnmappableChar)
   111|         {
   112|             if (pNative == null)
   113|                 return;
   114|             PInvokeMarshal.StringBuilderToAnsiString(stringBuilder, pNative, bestFit, throwOnUnmappableChar);
   115|         }
   116|         public static unsafe void StringBuilderToUnicodeString(System.Text.StringBuilder stringBuilder, ushort* destination)
   117|         {
   118|             if (destination == null)
   119|                 return;
   120|             PInvokeMarshal.StringBuilderToUnicodeString(stringBuilder, destination);
   121|         }
   122|         public static unsafe void WideCharArrayToAnsiCharArray(char[] managedArray, byte* pNative, bool bestFit, bool throwOnUnmappableChar)
   123|         {
   124|             PInvokeMarshal.WideCharArrayToAnsiCharArray(managedArray, pNative, bestFit, throwOnUnmappableChar);
   125|         }
   126|         public static unsafe void AnsiCharArrayToWideCharArray(byte* pNative, char[] managedArray)
   127|         {
   128|             PInvokeMarshal.AnsiCharArrayToWideCharArray(pNative, managedArray);
   129|         }
   130|         public static unsafe byte WideCharToAnsiChar(char managedValue, bool bestFit, bool throwOnUnmappableChar)
   131|         {
   132|             return PInvokeMarshal.WideCharToAnsiChar(managedValue, bestFit, throwOnUnmappableChar);
   133|         }
   134|         public static unsafe char AnsiCharToWideChar(byte nativeValue)
   135|         {
   136|             return PInvokeMarshal.AnsiCharToWideChar(nativeValue);
   137|         }
   138|         internal static double DateTimeToOleDateTime(DateTime value)
   139|         {
   140|             return value.ToOADate();
   141|         }
   142|         internal static DateTime OleDateTimeToDateTime(double value)
   143|         {
   144|             return DateTime.FromOADate(value);
   145|         }
   146|         internal static long DecimalToOleCurrency(decimal value)
   147|         {
   148|             return decimal.ToOACurrency(value);
   149|         }
   150|         internal static decimal OleCurrencyToDecimal(long value)
   151|         {
   152|             return decimal.FromOACurrency(value);
   153|         }
   154|         internal static unsafe string BstrBufferToString(char* buffer)
   155|         {
   156|             if (buffer == null)
   157|                 return null;
   158|             return Marshal.PtrToStringBSTR((IntPtr)buffer);
   159|         }
   160|         internal static unsafe byte* StringToAnsiBstrBuffer(string s)
   161|         {
   162|             if (s is null)
   163|             {
   164|                 return (byte*)IntPtr.Zero;
   165|             }
   166|             int stringLength = s.Length;
   167|             fixed (char* pStr = s)
   168|             {
   169|                 int nativeLength = PInvokeMarshal.GetByteCount(pStr, stringLength);
   170|                 byte* bstr = (byte*)Marshal.AllocBSTRByteLen((uint)nativeLength);
   171|                 PInvokeMarshal.ConvertWideCharToMultiByte(pStr, stringLength, bstr, nativeLength, bestFit: false, throwOnUnmappableChar: false);
   172|                 return bstr;
   173|             }
   174|         }
   175|         internal static unsafe string AnsiBstrBufferToString(byte* buffer)
   176|         {
   177|             if (buffer == null)
   178|                 return null;
   179|             return Marshal.PtrToStringAnsi((IntPtr)buffer, (int)Marshal.SysStringByteLen((IntPtr)buffer));
   180|         }
   181|         internal static unsafe IntPtr ResolvePInvoke(MethodFixupCell* pCell)
   182|         {
   183|             if (pCell->Target != IntPtr.Zero)
   184|                 return pCell->Target;
   185|             return ResolvePInvokeSlow(pCell);
   186|         }
   187|         [MethodImpl(MethodImplOptions.NoInlining)]
   188|         internal static unsafe IntPtr ResolvePInvokeSlow(MethodFixupCell* pCell)
   189|         {
   190|             int lastSystemError = Marshal.GetLastSystemError();
   191|             ModuleFixupCell* pModuleCell = pCell->Module;
   192|             IntPtr hModule = pModuleCell->Handle;
   193|             if (hModule == IntPtr.Zero)
   194|             {
   195|                 FixupModuleCell(pModuleCell);
   196|                 hModule = pModuleCell->Handle;
   197|             }
   198|             FixupMethodCell(hModule, pCell);
   199|             Marshal.SetLastSystemError(lastSystemError);
   200|             return pCell->Target;
   201|         }
   202|         internal static unsafe void FreeLibrary(IntPtr hModule)
   203|         {
   204| #if !TARGET_UNIX
   205|             Interop.Kernel32.FreeLibrary(hModule);
   206| #else
   207|             Interop.Sys.FreeLibrary(hModule);
   208| #endif
   209|         }
   210|         private static unsafe string GetModuleName(ModuleFixupCell* pCell)
   211|         {
   212|             byte* pModuleName = (byte*)pCell->ModuleName;
   213|             return Encoding.UTF8.GetString(pModuleName, string.strlen(pModuleName));
   214|         }
   215|         internal static unsafe void FixupModuleCell(ModuleFixupCell* pCell)
   216|         {
   217|             string moduleName = GetModuleName(pCell);
   218|             uint dllImportSearchPath = 0;
   219|             bool hasDllImportSearchPath = (pCell->DllImportSearchPathAndCookie & InteropDataConstants.HasDllImportSearchPath) != 0;
   220|             if (hasDllImportSearchPath)
   221|             {
   222|                 dllImportSearchPath = pCell->DllImportSearchPathAndCookie & ~InteropDataConstants.HasDllImportSearchPath;
   223|             }
   224|             Assembly callingAssembly = RuntimeAugments.Callbacks.GetAssemblyForHandle(new RuntimeTypeHandle(pCell->CallingAssemblyType));
   225|             IntPtr hModule = NativeLibrary.LoadLibraryCallbackStub(moduleName, callingAssembly, hasDllImportSearchPath, dllImportSearchPath);
   226|             if (hModule == IntPtr.Zero)
   227|             {
   228|                 NativeLibrary.LoadLibErrorTracker loadLibErrorTracker = default;
   229|                 hModule = NativeLibrary.LoadBySearch(
   230|                     callingAssembly,
   231|                     searchAssemblyDirectory: (dllImportSearchPath & (uint)DllImportSearchPath.AssemblyDirectory) != 0,
   232|                     dllImportSearchPathFlags: (int)(dllImportSearchPath & ~(uint)DllImportSearchPath.AssemblyDirectory),
   233|                     ref loadLibErrorTracker,
   234|                     moduleName);
   235|                 if (hModule == IntPtr.Zero)
   236|                 {
   237|                     AssemblyLoadContext loadContext = AssemblyLoadContext.GetLoadContext(callingAssembly)!;
   238|                     hModule = loadContext.GetResolvedUnmanagedDll(callingAssembly, moduleName);
   239|                 }
   240|                 if (hModule == IntPtr.Zero)
   241|                 {
   242|                     loadLibErrorTracker.Throw(moduleName);
   243|                 }
   244|             }
   245|             Debug.Assert(hModule != IntPtr.Zero);
   246|             var oldValue = Interlocked.CompareExchange(ref pCell->Handle, hModule, IntPtr.Zero);
   247|             if (oldValue != IntPtr.Zero)
   248|             {
   249|                 FreeLibrary(hModule);
   250|             }
   251|         }
   252|         internal static unsafe void FixupMethodCell(IntPtr hModule, MethodFixupCell* pCell)
   253|         {
   254|             byte* methodName = (byte*)pCell->MethodName;
   255|             IntPtr pTarget;
   256| #if TARGET_WINDOWS
   257|             CharSet charSetMangling = pCell->CharSetMangling;
   258|             if (charSetMangling == 0)
   259|             {
   260|                 pTarget = Interop.Kernel32.GetProcAddress(hModule, methodName);
   261|             }
   262|             else
   263|             if (charSetMangling == CharSet.Ansi)
   264|             {
   265|                 pTarget = Interop.Kernel32.GetProcAddress(hModule, methodName);
   266|                 if (pTarget == IntPtr.Zero)
   267|                     pTarget = GetProcAddressWithSuffix(hModule, methodName, (byte)'A');
   268|             }
   269|             else
   270|             {
   271|                 pTarget = GetProcAddressWithSuffix(hModule, methodName, (byte)'W');
   272|                 if (pTarget == IntPtr.Zero)
   273|                     pTarget = Interop.Kernel32.GetProcAddress(hModule, methodName);
   274|             }
   275| #else
   276|             pTarget = Interop.Sys.GetProcAddress(hModule, methodName);
   277| #endif
   278|             if (pTarget == IntPtr.Zero)
   279|             {
   280|                 string entryPointName = Encoding.UTF8.GetString(methodName, string.strlen(methodName));
   281|                 throw new EntryPointNotFoundException(SR.Format(SR.Arg_EntryPointNotFoundExceptionParameterized, entryPointName, GetModuleName(pCell->Module)));
   282|             }
   283|             pCell->Target = pTarget;
   284|         }
   285| #if TARGET_WINDOWS
   286|         private static unsafe IntPtr GetProcAddressWithSuffix(IntPtr hModule, byte* methodName, byte suffix)
   287|         {
   288|             int nameLength = string.strlen(methodName);
   289|             byte* probedMethodName = stackalloc byte[nameLength + 2];
   290|             for (int i = 0; i < nameLength; i++)
   291|             {
   292|                 probedMethodName[i] = methodName[i];
   293|             }
   294|             probedMethodName[nameLength + 1] = 0;
   295|             probedMethodName[nameLength] = suffix;
   296|             return Interop.Kernel32.GetProcAddress(hModule, probedMethodName);
   297|         }
   298| #endif
   299|         internal static unsafe void* CoTaskMemAllocAndZeroMemory(int size)
   300|         {
   301|             byte* ptr = (byte*)Marshal.AllocCoTaskMem(size);
   302|             Debug.Assert(ptr != null);
   303|             NativeMemory.Clear(ptr, (uint)size);
   304|             return ptr;
   305|         }
   306|         public static IntPtr GetCurrentCalleeOpenStaticDelegateFunctionPointer()
   307|         {
   308|             return PInvokeMarshal.GetCurrentCalleeOpenStaticDelegateFunctionPointer();
   309|         }
   310|         public static T GetCurrentCalleeDelegate<T>() where T : class // constraint can't be System.Delegate
   311|         {
   312|             return PInvokeMarshal.GetCurrentCalleeDelegate<T>();
   313|         }
   314|         public static IntPtr ConvertManagedComInterfaceToNative(object pUnk, Guid interfaceGuid)
   315|         {
   316|             if (pUnk == null)
   317|             {
   318|                 return IntPtr.Zero;
   319|             }
   320| #if TARGET_WINDOWS
   321| #pragma warning disable CA1416
   322|             return ComWrappers.ComInterfaceForObject(pUnk, interfaceGuid);
   323| #pragma warning restore CA1416
   324| #else
   325|             throw new PlatformNotSupportedException(SR.PlatformNotSupported_ComInterop);
   326| #endif
   327|         }
   328|         public static IntPtr ConvertManagedComInterfaceToIUnknown(object pUnk)
   329|         {
   330|             if (pUnk == null)
   331|             {
   332|                 return IntPtr.Zero;
   333|             }
   334| #if TARGET_WINDOWS
   335| #pragma warning disable CA1416
   336|             return ComWrappers.ComInterfaceForObject(pUnk);
   337| #pragma warning restore CA1416
   338| #else
   339|             throw new PlatformNotSupportedException(SR.PlatformNotSupported_ComInterop);
   340| #endif
   341|         }
   342|         public static object ConvertNativeComInterfaceToManaged(IntPtr pUnk)
   343|         {
   344|             if (pUnk == IntPtr.Zero)
   345|             {
   346|                 return null;
   347|             }
   348| #if TARGET_WINDOWS
   349| #pragma warning disable CA1416
   350|             return ComWrappers.ComObjectForInterface(pUnk);
   351| #pragma warning restore CA1416
   352| #else
   353|             throw new PlatformNotSupportedException(SR.PlatformNotSupported_ComInterop);
   354| #endif
   355|         }
   356|         [UnconditionalSuppressMessage("AotAnalysis", "IL3050:RequiresDynamicCode",
   357|             Justification = "This API will be called from compiler generated code only.")]
   358|         internal static int AsAnyGetNativeSize(object o)
   359|         {
   360|             if (o.GetEETypePtr().IsArray ||
   361|                 o is string ||
   362|                 o is StringBuilder)
   363|             {
   364|                 throw new PlatformNotSupportedException();
   365|             }
   366|             return Marshal.SizeOf(o.GetType());
   367|         }
   368|         [UnconditionalSuppressMessage("AotAnalysis", "IL3050:RequiresDynamicCode",
   369|             Justification = "This API will be called from compiler generated code only.")]
   370|         internal static void AsAnyMarshalManagedToNative(object o, IntPtr address)
   371|         {
   372|             if (o.GetEETypePtr().IsArray ||
   373|                 o is string ||
   374|                 o is StringBuilder)
   375|             {
   376|                 throw new PlatformNotSupportedException();
   377|             }
   378|             Marshal.StructureToPtr(o, address, fDeleteOld: false);
   379|         }
   380|         internal static void AsAnyMarshalNativeToManaged(IntPtr address, object o)
   381|         {
   382|             if (o.GetEETypePtr().IsArray ||
   383|                 o is string ||
   384|                 o is StringBuilder)
   385|             {
   386|                 throw new PlatformNotSupportedException();
   387|             }
   388|             Marshal.PtrToStructureImpl(address, o);
   389|         }
   390|         [UnconditionalSuppressMessage("AotAnalysis", "IL3050:RequiresDynamicCode",
   391|             Justification = "This API will be called from compiler generated code only.")]
   392|         internal static void AsAnyCleanupNative(IntPtr address, object o)
   393|         {
   394|             if (o.GetEETypePtr().IsArray ||
   395|                 o is string ||
   396|                 o is StringBuilder)
   397|             {
   398|                 throw new PlatformNotSupportedException();
   399|             }
   400|             Marshal.DestroyStructure(address, o.GetType());
   401|         }
   402|         internal static unsafe object? VariantToObject(IntPtr pSrcNativeVariant)
   403|         {
   404|             if (pSrcNativeVariant == IntPtr.Zero)
   405|             {
   406|                 return null;
   407|             }
   408| #if TARGET_WINDOWS
   409| #pragma warning disable CA1416
   410|             return Marshal.GetObjectForNativeVariant(pSrcNativeVariant);
   411| #pragma warning restore CA1416
   412| #else
   413|             throw new PlatformNotSupportedException(SR.PlatformNotSupported_ComInterop);
   414| #endif
   415|         }
   416|         internal static unsafe void ConvertObjectToVariant(object? obj, IntPtr pDstNativeVariant)
   417|         {
   418| #if TARGET_WINDOWS
   419| #pragma warning disable CA1416
   420|             Marshal.GetNativeVariantForObject(obj, pDstNativeVariant);
   421| #pragma warning restore CA1416
   422| #else
   423|             throw new PlatformNotSupportedException(SR.PlatformNotSupported_ComInterop);
   424| #endif
   425|         }
   426|         internal static unsafe void CleanupVariant(IntPtr pDstNativeVariant)
   427|         {
   428| #if TARGET_WINDOWS
   429| #pragma warning disable CA1416
   430|             Variant* data = (Variant*)pDstNativeVariant;
   431|             data->Clear();
   432| #pragma warning restore CA1416
   433| #else
   434|             throw new PlatformNotSupportedException(SR.PlatformNotSupported_ComInterop);
   435| #endif
   436|         }
   437|         public static unsafe object InitializeCustomMarshaller(RuntimeTypeHandle pParameterType, RuntimeTypeHandle pMarshallerType, string cookie, delegate*<string, object> getInstanceMethod)
   438|         {
   439|             if (getInstanceMethod == null)
   440|             {
   441|                 throw new ApplicationException();
   442|             }
   443|             if (!RuntimeImports.AreTypesAssignable(pMarshallerType.ToEETypePtr(), EETypePtr.EETypePtrOf<ICustomMarshaler>()))
   444|             {
   445|                 throw new ApplicationException();
   446|             }
   447|             var marshaller = CustomMarshallerTable.s_customMarshallersTable.GetOrAdd(new CustomMarshallerKey(pParameterType, pMarshallerType, cookie, getInstanceMethod));
   448|             if (marshaller == null)
   449|             {
   450|                 throw new ApplicationException();
   451|             }
   452|             if (!RuntimeImports.AreTypesAssignable(marshaller.GetEETypePtr(), EETypePtr.EETypePtrOf<ICustomMarshaler>()))
   453|             {
   454|                 throw new ApplicationException();
   455|             }
   456|             return marshaller;
   457|         }
   458|         [StructLayout(LayoutKind.Sequential)]
   459|         internal unsafe struct ModuleFixupCell
   460|         {
   461|             public IntPtr Handle;
   462|             public IntPtr ModuleName;
   463|             public EETypePtr CallingAssemblyType;
   464|             public uint DllImportSearchPathAndCookie;
   465|         }
   466|         [StructLayout(LayoutKind.Sequential)]
   467|         internal unsafe struct MethodFixupCell
   468|         {
   469|             public IntPtr Target;
   470|             public IntPtr MethodName;
   471|             public ModuleFixupCell* Module;
   472|             public CharSet CharSetMangling;
   473|         }
   474|         internal unsafe struct CustomMarshallerKey : IEquatable<CustomMarshallerKey>
   475|         {
   476|             public CustomMarshallerKey(RuntimeTypeHandle pParameterType, RuntimeTypeHandle pMarshallerType, string cookie, delegate*<string, object> getInstanceMethod)
   477|             {
   478|                 ParameterType = pParameterType;
   479|                 MarshallerType = pMarshallerType;
   480|                 Cookie = cookie;
   481|                 GetInstanceMethod = getInstanceMethod;
   482|             }
   483|             public RuntimeTypeHandle ParameterType { get; }
   484|             public RuntimeTypeHandle MarshallerType { get; }
   485|             public string Cookie { get; }
   486|             public delegate*<string, object> GetInstanceMethod { get; }
   487|             public override bool Equals(object obj)
   488|             {
   489|                 if (!(obj is CustomMarshallerKey other))
   490|                     return false;
   491|                 return Equals(other);
   492|             }
   493|             public bool Equals(CustomMarshallerKey other)
   494|             {
   495|                 return ParameterType.Equals(other.ParameterType)
   496|                     && MarshallerType.Equals(other.MarshallerType)
   497|                     && Cookie.Equals(other.Cookie);
   498|             }
   499|             public override int GetHashCode()
   500|             {
   501|                 return ParameterType.GetHashCode()
   502|                     ^ MarshallerType.GetHashCode()
   503|                     ^ Cookie.GetHashCode();
   504|             }
   505|         }
   506|         internal sealed class CustomMarshallerTable : ConcurrentUnifier<CustomMarshallerKey, object>
   507|         {
   508|             internal static CustomMarshallerTable s_customMarshallersTable = new CustomMarshallerTable();
   509|             protected override unsafe object Factory(CustomMarshallerKey key)
   510|             {
   511|                 return key.GetInstanceMethod(key.Cookie);
   512|             }
   513|         }
   514|     }
   515| }


# ====================================================================
# FILE: src/coreclr/nativeaot/System.Private.CoreLib/src/System/Runtime/InteropServices/NativeLibrary.NativeAot.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-92 ---
     1| using System.IO;
     2| using System.Reflection;
     3| using LibraryNameVariation = System.Runtime.Loader.LibraryNameVariation;
     4| namespace System.Runtime.InteropServices
     5| {
     6|     public static partial class NativeLibrary
     7|     {
     8|         internal static IntPtr LoadLibraryByName(string libraryName, Assembly assembly, DllImportSearchPath? searchPath, bool throwOnError)
     9|         {
    10|             int searchPathFlags;
    11|             bool searchAssemblyDirectory;
    12|             if (searchPath.HasValue)
    13|             {
    14|                 searchPathFlags = (int)(searchPath!.Value & ~DllImportSearchPath.AssemblyDirectory);
    15|                 searchAssemblyDirectory = (searchPath.Value & DllImportSearchPath.AssemblyDirectory) != 0;
    16|             }
    17|             else
    18|             {
    19|                 GetDllImportSearchPathFlags(assembly, out searchPathFlags, out searchAssemblyDirectory);
    20|             }
    21|             LoadLibErrorTracker errorTracker = default;
    22|             IntPtr ret = LoadBySearch(assembly, searchAssemblyDirectory, searchPathFlags, ref errorTracker, libraryName);
    23|             if (throwOnError && ret == IntPtr.Zero)
    24|             {
    25|                 errorTracker.Throw(libraryName);
    26|             }
    27|             return ret;
    28|         }
    29|         internal static void GetDllImportSearchPathFlags(Assembly callingAssembly, out int searchPathFlags, out bool searchAssemblyDirectory)
    30|         {
    31|             var searchPath = DllImportSearchPath.AssemblyDirectory;
    32|             foreach (CustomAttributeData cad in callingAssembly.CustomAttributes)
    33|             {
    34|                 if (cad.AttributeType == typeof(DefaultDllImportSearchPathsAttribute))
    35|                 {
    36|                     searchPath = (DllImportSearchPath)cad.ConstructorArguments[0].Value!;
    37|                 }
    38|             }
    39|             searchPathFlags = (int)(searchPath & ~DllImportSearchPath.AssemblyDirectory);
    40|             searchAssemblyDirectory = (searchPath & DllImportSearchPath.AssemblyDirectory) != 0;
    41|         }
    42|         internal static IntPtr LoadBySearch(Assembly callingAssembly, bool searchAssemblyDirectory, int dllImportSearchPathFlags, ref LoadLibErrorTracker errorTracker, string libraryName)
    43|         {
    44|             IntPtr ret;
    45|             int loadWithAlteredPathFlags = LoadWithAlteredSearchPathFlag;
    46|             bool libNameIsRelativePath = !Path.IsPathFullyQualified(libraryName);
    47|             foreach (LibraryNameVariation libraryNameVariation in LibraryNameVariation.DetermineLibraryNameVariations(libraryName, libNameIsRelativePath))
    48|             {
    49|                 string currLibNameVariation = libraryNameVariation.Prefix + libraryName + libraryNameVariation.Suffix;
    50|                 if (!libNameIsRelativePath)
    51|                 {
    52|                     int flags = loadWithAlteredPathFlags;
    53|                     if ((dllImportSearchPathFlags & (int)DllImportSearchPath.UseDllDirectoryForDependencies) != 0)
    54|                     {
    55|                         flags |= dllImportSearchPathFlags;
    56|                     }
    57|                     ret = LoadLibraryHelper(currLibNameVariation, flags, ref errorTracker);
    58|                     if (ret != IntPtr.Zero)
    59|                     {
    60|                         return ret;
    61|                     }
    62|                 }
    63|                 else if ((callingAssembly != null) && searchAssemblyDirectory)
    64|                 {
    65|                 }
    66|                 ret = LoadLibraryHelper(currLibNameVariation, dllImportSearchPathFlags, ref errorTracker);
    67|                 if (ret != IntPtr.Zero)
    68|                 {
    69|                     return ret;
    70|                 }
    71|             }
    72|             return IntPtr.Zero;
    73|         }
    74|         private static IntPtr LoadFromPath(string libraryName, bool throwOnError)
    75|         {
    76|             LoadLibErrorTracker errorTracker = default;
    77|             IntPtr ret = LoadLibraryHelper(libraryName, LoadWithAlteredSearchPathFlag, ref errorTracker);
    78|             if (throwOnError && ret == IntPtr.Zero)
    79|             {
    80|                 errorTracker.Throw(libraryName);
    81|             }
    82|             return ret;
    83|         }
    84|         private static unsafe IntPtr GetSymbol(IntPtr handle, string symbolName, bool throwOnError)
    85|         {
    86|             IntPtr ret = GetSymbolOrNull(handle, symbolName);
    87|             if (throwOnError && ret == IntPtr.Zero)
    88|                 throw new EntryPointNotFoundException(SR.Format(SR.Arg_EntryPointNotFoundExceptionParameterizedNoLibrary, symbolName));
    89|             return ret;
    90|         }
    91|     }
    92| }


# ====================================================================
# FILE: src/coreclr/pal/src/exception/signal.cpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-824 ---
     1| /*++
     2| Module Name:
     3|     exception/signal.cpp
     4| Abstract:
     5|     Signal handler implementation (map signals to exceptions)
     6| --*/
     7| #include "pal/dbgmsg.h"
     8| SET_DEFAULT_DEBUG_CHANNEL(EXCEPT); // some headers have code with asserts, so do this first
     9| #include "pal/corunix.hpp"
    10| #include "pal/handleapi.hpp"
    11| #include "pal/process.h"
    12| #include "pal/thread.hpp"
    13| #include "pal/threadinfo.hpp"
    14| #include "pal/threadsusp.hpp"
    15| #include "pal/seh.hpp"
    16| #include "pal/signal.hpp"
    17| #include "pal/palinternal.h"
    18| #include <clrconfignocache.h>
    19| #include <errno.h>
    20| #include <signal.h>
    21| #if !HAVE_MACH_EXCEPTIONS
    22| #include "pal/init.h"
    23| #include "pal/debug.h"
    24| #include "pal/virtual.h"
    25| #include "pal/utils.h"
    26| #include <string.h>
    27| #include <sys/ucontext.h>
    28| #include <sys/utsname.h>
    29| #include <unistd.h>
    30| #include <sys/mman.h>
    31| #endif // !HAVE_MACH_EXCEPTIONS
    32| #include "pal/context.h"
    33| #ifdef SIGRTMIN
    34| #define INJECT_ACTIVATION_SIGNAL SIGRTMIN
    35| #else
    36| #define INJECT_ACTIVATION_SIGNAL SIGUSR1
    37| #endif
    38| #if !defined(INJECT_ACTIVATION_SIGNAL) && defined(FEATURE_HIJACK)
    39| #error FEATURE_HIJACK requires INJECT_ACTIVATION_SIGNAL to be defined
    40| #endif
    41| using namespace CorUnix;
    42| /* local type definitions *****************************************************/
    43| typedef void (*SIGFUNC)(int, siginfo_t *, void *);
    44| /* internal function declarations *********************************************/
    45| static void sigterm_handler(int code, siginfo_t *siginfo, void *context);
    46| #ifdef INJECT_ACTIVATION_SIGNAL
    47| static void inject_activation_handler(int code, siginfo_t *siginfo, void *context);
    48| extern void* g_InvokeActivationHandlerReturnAddress;
    49| #endif
    50| static void sigill_handler(int code, siginfo_t *siginfo, void *context);
    51| static void sigfpe_handler(int code, siginfo_t *siginfo, void *context);
    52| static void sigsegv_handler(int code, siginfo_t *siginfo, void *context);
    53| static void sigtrap_handler(int code, siginfo_t *siginfo, void *context);
    54| static void sigbus_handler(int code, siginfo_t *siginfo, void *context);
    55| static void sigint_handler(int code, siginfo_t *siginfo, void *context);
    56| static void sigquit_handler(int code, siginfo_t *siginfo, void *context);
    57| static void sigabrt_handler(int code, siginfo_t *siginfo, void *context);
    58| static bool common_signal_handler(int code, siginfo_t *siginfo, void *sigcontext, int numParams, ...);
    59| static void handle_signal(int signal_id, SIGFUNC sigfunc, struct sigaction *previousAction, int additionalFlags = 0, bool skipIgnored = false);
    60| static void restore_signal(int signal_id, struct sigaction *previousAction);
    61| static void restore_signal_and_resend(int code, struct sigaction* action);
    62| /* internal data declarations *********************************************/
    63| bool g_registered_signal_handlers = false;
    64| #if !HAVE_MACH_EXCEPTIONS
    65| bool g_enable_alternate_stack_check = false;
    66| #endif // !HAVE_MACH_EXCEPTIONS
    67| static bool g_registered_sigterm_handler = false;
    68| static bool g_registered_activation_handler = false;
    69| struct sigaction g_previous_sigterm;
    70| #ifdef INJECT_ACTIVATION_SIGNAL
    71| struct sigaction g_previous_activation;
    72| #endif
    73| struct sigaction g_previous_sigill;
    74| struct sigaction g_previous_sigtrap;
    75| struct sigaction g_previous_sigfpe;
    76| struct sigaction g_previous_sigbus;
    77| struct sigaction g_previous_sigsegv;
    78| struct sigaction g_previous_sigint;
    79| struct sigaction g_previous_sigquit;
    80| struct sigaction g_previous_sigabrt;
    81| #if !HAVE_MACH_EXCEPTIONS
    82| volatile void* g_stackOverflowHandlerStack = NULL;
    83| const int StackOverflowFlag = 0x40000000;
    84| #endif // !HAVE_MACH_EXCEPTIONS
    85| /* public function definitions ************************************************/
    86| /*++
    87| Function :
    88|     SEHInitializeSignals
    89|     Set up signal handlers to catch signals and translate them to exceptions
    90| Parameters :
    91|     None
    92| Return :
    93|     TRUE in case of a success, FALSE otherwise
    94| --*/
    95| BOOL SEHInitializeSignals(CorUnix::CPalThread *pthrCurrent, DWORD flags)
    96| {
    97|     TRACE("Initializing signal handlers %04x\n", flags);
    98| #if !HAVE_MACH_EXCEPTIONS
    99|     g_enable_alternate_stack_check = false;
   100|     CLRConfigNoCache stackCheck = CLRConfigNoCache::Get("EnableAlternateStackCheck", /*noprefix*/ false, &getenv);
   101|     if (stackCheck.IsSet())
   102|     {
   103|         DWORD value;
   104|         if (stackCheck.TryAsInteger(10, value))
   105|             g_enable_alternate_stack_check = (value != 0);
   106|     }
   107| #endif
   108|     if (flags & PAL_INITIALIZE_REGISTER_SIGNALS)
   109|     {
   110|         g_registered_signal_handlers = true;
   111|         /* we call handle_signal for every possible signal, even
   112|            if we don't provide a signal handler.
   113|            handle_signal will set SA_RESTART flag for specified signal.
   114|            Therefore, all signals will have SA_RESTART flag set, preventing
   115|            slow Unix system calls from being interrupted. On systems without
   116|            siginfo_t, SIGKILL and SIGSTOP can't be restarted, so we don't
   117|            handle those signals. Both the Darwin and FreeBSD man pages say
   118|            that SIGKILL and SIGSTOP can't be handled, but FreeBSD allows us
   119|            to register a handler for them anyway. We don't do that.
   120|            see sigaction man page for more details
   121|            */
   122|         handle_signal(SIGILL, sigill_handler, &g_previous_sigill);
   123|         handle_signal(SIGFPE, sigfpe_handler, &g_previous_sigfpe);
   124|         handle_signal(SIGBUS, sigbus_handler, &g_previous_sigbus);
   125|         handle_signal(SIGABRT, sigabrt_handler, &g_previous_sigabrt);
   126|         handle_signal(SIGINT, sigint_handler, &g_previous_sigint, 0 /* additionalFlags */, true /* skipIgnored */);
   127|         handle_signal(SIGQUIT, sigquit_handler, &g_previous_sigquit, 0 /* additionalFlags */, true /* skipIgnored */);
   128| #if HAVE_MACH_EXCEPTIONS
   129|         handle_signal(SIGSEGV, sigsegv_handler, &g_previous_sigsegv);
   130| #else
   131|         handle_signal(SIGTRAP, sigtrap_handler, &g_previous_sigtrap);
   132|         handle_signal(SIGSEGV, sigsegv_handler, &g_previous_sigsegv, SA_ONSTACK);
   133|         if (!pthrCurrent->EnsureSignalAlternateStack())
   134|         {
   135|             return FALSE;
   136|         }
   137|         int stackOverflowStackSize = ALIGN_UP(sizeof(SignalHandlerWorkerReturnPoint), 16) + 7 * 4096;
   138|         stackOverflowStackSize = ALIGN_UP(stackOverflowStackSize, GetVirtualPageSize()) + GetVirtualPageSize();
   139|         int flags = MAP_ANONYMOUS | MAP_PRIVATE;
   140| #ifdef MAP_STACK
   141|         flags |= MAP_STACK;
   142| #endif
   143|         g_stackOverflowHandlerStack = mmap(NULL, stackOverflowStackSize, PROT_READ | PROT_WRITE, flags, -1, 0);
   144|         if (g_stackOverflowHandlerStack == MAP_FAILED)
   145|         {
   146|             return FALSE;
   147|         }
   148|         int st = mprotect((void*)g_stackOverflowHandlerStack, GetVirtualPageSize(), PROT_NONE);
   149|         if (st != 0)
   150|         {
   151|             munmap((void*)g_stackOverflowHandlerStack, stackOverflowStackSize);
   152|             return FALSE;
   153|         }
   154|         g_stackOverflowHandlerStack = (void*)((size_t)g_stackOverflowHandlerStack + stackOverflowStackSize);
   155| #endif // HAVE_MACH_EXCEPTIONS
   156|     }
   157|     /* The default action for SIGPIPE is process termination.
   158|        Since SIGPIPE can be signaled when trying to write on a socket for which
   159|        the connection has been dropped, we need to tell the system we want
   160|        to ignore this signal.
   161|        Instead of terminating the process, the system call which would had
   162|        issued a SIGPIPE will, instead, report an error and set errno to EPIPE.
   163|     */
   164|     signal(SIGPIPE, SIG_IGN);
   165|     if (flags & PAL_INITIALIZE_REGISTER_SIGTERM_HANDLER)
   166|     {
   167|         g_registered_sigterm_handler = true;
   168|         handle_signal(SIGTERM, sigterm_handler, &g_previous_sigterm);
   169|     }
   170| #ifdef INJECT_ACTIVATION_SIGNAL
   171|     if (flags & PAL_INITIALIZE_REGISTER_ACTIVATION_SIGNAL)
   172|     {
   173|         handle_signal(INJECT_ACTIVATION_SIGNAL, inject_activation_handler, &g_previous_activation);
   174|         g_registered_activation_handler = true;
   175|     }
   176| #endif
   177|     return TRUE;
   178| }
   179| /*++
   180| Function :
   181|     SEHCleanupSignals
   182|     Restore default signal handlers
   183| Parameters :
   184|     None
   185|     (no return value)
   186| note :
   187| reason for this function is that during PAL_Terminate, we reach a point where
   188| SEH isn't possible anymore (handle manager is off, etc). Past that point,
   189| we can't avoid crashing on a signal.
   190| --*/
   191| void SEHCleanupSignals()
   192| {
   193|     TRACE("Restoring default signal handlers\n");
   194|     if (g_registered_signal_handlers)
   195|     {
   196|         restore_signal(SIGILL, &g_previous_sigill);
   197| #if !HAVE_MACH_EXCEPTIONS
   198|         restore_signal(SIGTRAP, &g_previous_sigtrap);
   199| #endif
   200|         restore_signal(SIGFPE, &g_previous_sigfpe);
   201|         restore_signal(SIGBUS, &g_previous_sigbus);
   202|         restore_signal(SIGABRT, &g_previous_sigabrt);
   203|         restore_signal(SIGSEGV, &g_previous_sigsegv);
   204|         restore_signal(SIGINT, &g_previous_sigint);
   205|         restore_signal(SIGQUIT, &g_previous_sigquit);
   206|     }
   207| #ifdef INJECT_ACTIVATION_SIGNAL
   208|     if (g_registered_activation_handler)
   209|     {
   210|         restore_signal(INJECT_ACTIVATION_SIGNAL, &g_previous_activation);
   211|     }
   212| #endif
   213|     if (g_registered_sigterm_handler)
   214|     {
   215|         restore_signal(SIGTERM, &g_previous_sigterm);
   216|     }
   217| }
   218| /* internal function definitions **********************************************/
   219| /*++
   220| Function :
   221|     IsRunningOnAlternateStack
   222|     Detects if the current signal handlers is running on an alternate stack
   223| Parameters :
   224|     The context of the signal
   225| Return :
   226|     true if we are running on an alternate stack
   227| --*/
   228| bool IsRunningOnAlternateStack(void *context)
   229| {
   230| #if HAVE_MACH_EXCEPTIONS
   231|     return false;
   232| #else
   233|     bool isRunningOnAlternateStack;
   234|     if (g_enable_alternate_stack_check)
   235|     {
   236|         stack_t *signalStack = &((native_context_t *)context)->uc_stack;
   237|         void* alternateStackEnd = (char *)signalStack->ss_sp + signalStack->ss_size;
   238|         isRunningOnAlternateStack = ((signalStack->ss_flags & SS_DISABLE) == 0) && (signalStack->ss_sp <= &signalStack) && (&signalStack < alternateStackEnd);
   239|     }
   240|     else
   241|     {
   242|         isRunningOnAlternateStack = true;
   243|     }
   244|     return isRunningOnAlternateStack;
   245| #endif // HAVE_MACH_EXCEPTIONS
   246| }
   247| static bool IsSaSigInfo(struct sigaction* action)
   248| {
   249|     return (action->sa_flags & SA_SIGINFO) != 0;
   250| }
   251| static bool IsSigDfl(struct sigaction* action)
   252| {
   253|     return (&action->sa_handler == (void*)&action->sa_sigaction || !IsSaSigInfo(action)) &&
   254|             action->sa_handler == SIG_DFL;
   255| }
   256| static bool IsSigIgn(struct sigaction* action)
   257| {
   258|     return (&action->sa_handler == (void*)&action->sa_sigaction || !IsSaSigInfo(action)) &&
   259|             action->sa_handler == SIG_IGN;
   260| }
   261| /*++
   262| Function :
   263|     invoke_previous_action
   264|     synchronously invokes the previous action or aborts when that is not possible
   265| Parameters :
   266|     action  : previous sigaction struct
   267|     code    : signal code
   268|     siginfo : signal siginfo
   269|     context : signal context
   270|     signalRestarts: BOOL state : TRUE if the process will be signalled again
   271|     (no return value)
   272| --*/
   273| static void invoke_previous_action(struct sigaction* action, int code, siginfo_t *siginfo, void *context, bool signalRestarts = true)
   274| {
   275|     _ASSERTE(action != NULL);
   276|     if (IsSigIgn(action))
   277|     {
   278|         if (signalRestarts)
   279|         {
   280|             PROCAbort(code, siginfo);
   281|         }
   282|         return;
   283|     }
   284|     else if (IsSigDfl(action))
   285|     {
   286|         if (signalRestarts)
   287|         {
   288|             restore_signal(code, action);
   289|         }
   290|         else
   291|         {
   292|             PROCAbort(code, siginfo);
   293|         }
   294|     }
   295|     else if (IsSaSigInfo(action))
   296|     {
   297|         _ASSERTE(action->sa_sigaction != NULL);
   298|         action->sa_sigaction(code, siginfo, context);
   299|     }
   300|     else
   301|     {
   302|         _ASSERTE(action->sa_handler != NULL);
   303|         action->sa_handler(code);
   304|     }
   305|     PROCNotifyProcessShutdown(IsRunningOnAlternateStack(context));
   306|     PROCCreateCrashDumpIfEnabled(code, siginfo);
   307| }
   308| /*++
   309| Function :
   310|     sigill_handler
   311|     handle SIGILL signal (EXCEPTION_ILLEGAL_INSTRUCTION, others?)
   312| Parameters :
   313|     POSIX signal handler parameter list ("man sigaction" for details)
   314|     (no return value)
   315| --*/
   316| static void sigill_handler(int code, siginfo_t *siginfo, void *context)
   317| {
   318|     if (PALIsInitialized())
   319|     {
   320|         if (common_signal_handler(code, siginfo, context, 0))
   321|         {
   322|             return;
   323|         }
   324|     }
   325|     invoke_previous_action(&g_previous_sigill, code, siginfo, context);
   326| }
   327| /*++
   328| Function :
   329|     sigfpe_handler
   330|     handle SIGFPE signal (division by zero, floating point exception)
   331| Parameters :
   332|     POSIX signal handler parameter list ("man sigaction" for details)
   333|     (no return value)
   334| --*/
   335| static void sigfpe_handler(int code, siginfo_t *siginfo, void *context)
   336| {
   337|     if (PALIsInitialized())
   338|     {
   339|         if (common_signal_handler(code, siginfo, context, 0))
   340|         {
   341|             return;
   342|         }
   343|     }
   344|     invoke_previous_action(&g_previous_sigfpe, code, siginfo, context);
   345| }
   346| #if !HAVE_MACH_EXCEPTIONS
   347| /*++
   348| Function :
   349|     signal_handler_worker
   350|     Handles signal on the original stack where the signal occurred.
   351|     Invoked via setcontext.
   352| Parameters :
   353|     POSIX signal handler parameter list ("man sigaction" for details)
   354|     returnPoint - context to which the function returns if the common_signal_handler returns
   355|     (no return value)
   356| --*/
   357| extern "C" void signal_handler_worker(int code, siginfo_t *siginfo, void *context, SignalHandlerWorkerReturnPoint* returnPoint)
   358| {
   359|     sigset_t signal_set;
   360|     sigemptyset(&signal_set);
   361|     sigaddset(&signal_set, INJECT_ACTIVATION_SIGNAL);
   362|     int sigmaskRet = pthread_sigmask(SIG_UNBLOCK, &signal_set, NULL);
   363|     if (sigmaskRet != 0)
   364|     {
   365|         ASSERT("pthread_sigmask failed; error number is %d\n", sigmaskRet);
   366|     }
   367|     returnPoint->returnFromHandler = common_signal_handler(code, siginfo, context, 2, (size_t)0, (size_t)siginfo->si_addr);
   368|     sigmaskRet = pthread_sigmask(SIG_BLOCK, &signal_set, NULL);
   369|     if (sigmaskRet != 0)
   370|     {
   371|         ASSERT("pthread_sigmask failed; error number is %d\n", sigmaskRet);
   372|     }
   373|     RtlRestoreContext(&returnPoint->context, NULL);
   374| }
   375| /*++
   376| Function :
   377|     SwitchStackAndExecuteHandler
   378|     Switch to the stack specified by the sp argument
   379| Parameters :
   380|     POSIX signal handler parameter list ("man sigaction" for details)
   381|     sp - stack pointer of the stack to execute the handler on.
   382|          If sp == 0, execute it on the original stack where the signal has occurred.
   383| Return :
   384|     The return value from the signal handler
   385| --*/
   386| static bool SwitchStackAndExecuteHandler(int code, siginfo_t *siginfo, void *context, size_t sp)
   387| {
   388|     volatile bool contextInitialization = true;
   389|     void *ptr = alloca(sizeof(SignalHandlerWorkerReturnPoint) + alignof(SignalHandlerWorkerReturnPoint) - 1);
   390|     SignalHandlerWorkerReturnPoint *pReturnPoint = (SignalHandlerWorkerReturnPoint *)ALIGN_UP(ptr, alignof(SignalHandlerWorkerReturnPoint));
   391|     RtlCaptureContext(&pReturnPoint->context);
   392|     if (contextInitialization)
   393|     {
   394|         contextInitialization = false;
   395|         ExecuteHandlerOnCustomStack(code, siginfo, context, sp, pReturnPoint);
   396|         _ASSERTE(FALSE); // The ExecuteHandlerOnCustomStack should never return
   397|     }
   398|     return pReturnPoint->returnFromHandler;
   399| }
   400| #endif // !HAVE_MACH_EXCEPTIONS
   401| /*++
   402| Function :
   403|     sigsegv_handler
   404|     handle SIGSEGV signal (EXCEPTION_ACCESS_VIOLATION, others)
   405| Parameters :
   406|     POSIX signal handler parameter list ("man sigaction" for details)
   407|     (no return value)
   408| --*/
   409| static void sigsegv_handler(int code, siginfo_t *siginfo, void *context)
   410| {
   411| #if !HAVE_MACH_EXCEPTIONS
   412|     if (PALIsInitialized())
   413|     {
   414|         size_t sp = (size_t)GetNativeContextSP((native_context_t *)context);
   415|         size_t failureAddress = (size_t)siginfo->si_addr;
   416|         if ((failureAddress - (sp - GetVirtualPageSize())) < 2 * GetVirtualPageSize())
   417|         {
   418|             if (GetCurrentPalThread())
   419|             {
   420|                 size_t handlerStackTop = __sync_val_compare_and_swap((size_t*)&g_stackOverflowHandlerStack, (size_t)g_stackOverflowHandlerStack, 0);
   421|                 if (handlerStackTop == 0)
   422|                 {
   423|                     while (true)
   424|                     {
   425|                         sleep(1);
   426|                     }
   427|                 }
   428|                 if (SwitchStackAndExecuteHandler(code | StackOverflowFlag, siginfo, context, (size_t)handlerStackTop))
   429|                 {
   430|                     PROCAbort(SIGSEGV, siginfo);
   431|                 }
   432|             }
   433|             else
   434|             {
   435|                 (void)!write(STDERR_FILENO, StackOverflowMessage, sizeof(StackOverflowMessage) - 1);
   436|                 PROCAbort(SIGSEGV, siginfo);
   437|             }
   438|         }
   439|         if (GetCurrentPalThread() && IsRunningOnAlternateStack(context))
   440|         {
   441|             if (SwitchStackAndExecuteHandler(code, siginfo, context, 0 /* sp */)) // sp == 0 indicates execution on the original stack
   442|             {
   443|                 return;
   444|             }
   445|         }
   446|         else
   447|         {
   448|             if (common_signal_handler(code, siginfo, context, 2, (size_t)0, (size_t)siginfo->si_addr))
   449|             {
   450|                 return;
   451|             }
   452|         }
   453|     }
   454| #endif // !HAVE_MACH_EXCEPTIONS
   455|     invoke_previous_action(&g_previous_sigsegv, code, siginfo, context);
   456| }
   457| /*++
   458| Function :
   459|     sigtrap_handler
   460|     handle SIGTRAP signal (EXCEPTION_SINGLE_STEP, EXCEPTION_BREAKPOINT)
   461| Parameters :
   462|     POSIX signal handler parameter list ("man sigaction" for details)
   463|     (no return value)
   464| --*/
   465| static void sigtrap_handler(int code, siginfo_t *siginfo, void *context)
   466| {
   467|     if (PALIsInitialized())
   468|     {
   469|         if (common_signal_handler(code, siginfo, context, 0))
   470|         {
   471|             return;
   472|         }
   473|     }
   474|     invoke_previous_action(&g_previous_sigtrap, code, siginfo, context, /* signalRestarts */ false);
   475| }
   476| /*++
   477| Function :
   478|     sigbus_handler
   479|     handle SIGBUS signal (EXCEPTION_ACCESS_VIOLATION?)
   480| Parameters :
   481|     POSIX signal handler parameter list ("man sigaction" for details)
   482|     (no return value)
   483| --*/
   484| static void sigbus_handler(int code, siginfo_t *siginfo, void *context)
   485| {
   486|     if (PALIsInitialized())
   487|     {
   488|         if (common_signal_handler(code, siginfo, context, 2, (size_t)0, (size_t)siginfo->si_addr))
   489|         {
   490|             return;
   491|         }
   492|     }
   493|     invoke_previous_action(&g_previous_sigbus, code, siginfo, context);
   494| }
   495| /*++
   496| Function :
   497|     sigabrt_handler
   498|     handle SIGABRT signal - abort() API
   499| Parameters :
   500|     POSIX signal handler parameter list ("man sigaction" for details)
   501|     (no return value)
   502| --*/
   503| static void sigabrt_handler(int code, siginfo_t *siginfo, void *context)
   504| {
   505|     invoke_previous_action(&g_previous_sigabrt, code, siginfo, context);
   506| }
   507| /*++
   508| Function :
   509|     sigint_handler
   510|     handle SIGINT signal
   511| Parameters :
   512|     POSIX signal handler parameter list ("man sigaction" for details)
   513|     (no return value)
   514| --*/
   515| static void sigint_handler(int code, siginfo_t *siginfo, void *context)
   516| {
   517|     PROCNotifyProcessShutdown();
   518|     restore_signal_and_resend(code, &g_previous_sigint);
   519| }
   520| /*++
   521| Function :
   522|     sigquit_handler
   523|     handle SIGQUIT signal
   524| Parameters :
   525|     POSIX signal handler parameter list ("man sigaction" for details)
   526|     (no return value)
   527| --*/
   528| static void sigquit_handler(int code, siginfo_t *siginfo, void *context)
   529| {
   530|     PROCNotifyProcessShutdown();
   531|     restore_signal_and_resend(code, &g_previous_sigquit);
   532| }
   533| /*++
   534| Function :
   535|     sigterm_handler
   536|     handle SIGTERM signal
   537| Parameters :
   538|     POSIX signal handler parameter list ("man sigaction" for details)
   539|     (no return value)
   540| --*/
   541| static void sigterm_handler(int code, siginfo_t *siginfo, void *context)
   542| {
   543|     if (PALIsInitialized())
   544|     {
   545|         CLRConfigNoCache enableDumpOnSigTerm = CLRConfigNoCache::Get("EnableDumpOnSigTerm", /*noprefix*/ false, &getenv);
   546|         DWORD val = 0;
   547|         if (enableDumpOnSigTerm.IsSet() && enableDumpOnSigTerm.TryAsInteger(10, val) && val == 1)
   548|         {
   549|             PROCCreateCrashDumpIfEnabled(code, siginfo);
   550|         }
   551|         _ASSERTE(g_pSynchronizationManager != nullptr);
   552|         g_pSynchronizationManager->SendTerminationRequestToWorkerThread();
   553|     }
   554|     else
   555|     {
   556|         restore_signal_and_resend(SIGTERM, &g_previous_sigterm);
   557|     }
   558| }
   559| #ifdef INJECT_ACTIVATION_SIGNAL
   560| /*++
   561| Function :
   562|     InvokeActivationHandler
   563|     Invoke the registered activation handler.
   564|     It also saves the return address (inject_activation_handler) so that PAL_VirtualUnwind can detect that
   565|     it has reached that method and use the context stored in the winContext there to unwind to the code
   566|     where the activation was injected. This is necessary on Alpine Linux where the libunwind cannot correctly
   567|     unwind past the signal frame.
   568| Parameters :
   569|     Windows style context of the location where the activation was injected
   570| (no return value)
   571| --*/
   572| __attribute__((noinline))
   573| static void InvokeActivationHandler(CONTEXT *pWinContext)
   574| {
   575|     g_InvokeActivationHandlerReturnAddress = __builtin_return_address(0);
   576|     g_activationFunction(pWinContext);
   577| }
   578| /*++
   579| Function :
   580|     inject_activation_handler
   581|     Handle the INJECT_ACTIVATION_SIGNAL signal. This signal interrupts a running thread
   582|     so it can call the activation function that was specified when sending the signal.
   583| Parameters :
   584|     POSIX signal handler parameter list ("man sigaction" for details)
   585| (no return value)
   586| --*/
   587| static void inject_activation_handler(int code, siginfo_t *siginfo, void *context)
   588| {
   589|     if (g_activationFunction != NULL && (siginfo->si_pid == getpid()
   590| #ifdef HOST_OSX
   591|     || siginfo->si_pid == 0
   592| #endif
   593|     ))
   594|     {
   595|         _ASSERTE(g_safeActivationCheckFunction != NULL);
   596|         native_context_t *ucontext = (native_context_t *)context;
   597|         CONTEXT winContext;
   598|         RtlCaptureContext(&winContext);
   599|         ULONG contextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_FLOATING_POINT;
   600| #if defined(HOST_AMD64)
   601|         contextFlags |= CONTEXT_XSTATE;
   602| #endif
   603|         CONTEXTFromNativeContext(
   604|             ucontext,
   605|             &winContext,
   606|             contextFlags);
   607|         if (g_safeActivationCheckFunction(CONTEXTGetPC(&winContext), /* checkingCurrentThread */ TRUE))
   608|         {
   609|             g_inject_activation_context_locvar_offset = (int)((char*)&winContext - (char*)__builtin_frame_address(0));
   610|             int savedErrNo = errno; // Make sure that errno is not modified
   611|             InvokeActivationHandler(&winContext);
   612|             errno = savedErrNo;
   613|             CONTEXTToNativeContext(&winContext, ucontext);
   614|         }
   615|     }
   616|     else
   617|     {
   618|         if (g_previous_activation.sa_flags & SA_SIGINFO)
   619|         {
   620|             _ASSERTE(g_previous_activation.sa_sigaction != NULL);
   621|             g_previous_activation.sa_sigaction(code, siginfo, context);
   622|         }
   623|         else
   624|         {
   625|             if (g_previous_activation.sa_handler != SIG_IGN &&
   626|                 g_previous_activation.sa_handler != SIG_DFL)
   627|             {
   628|                 _ASSERTE(g_previous_activation.sa_handler != NULL);
   629|                 g_previous_activation.sa_handler(code);
   630|             }
   631|         }
   632|     }
   633| }
   634| #endif
   635| /*++
   636| Function :
   637|     InjectActivationInternal
   638|     Interrupt the specified thread and have it call the activationFunction passed in
   639| Parameters :
   640|     pThread            - target PAL thread
   641|     activationFunction - function to call
   642| (no return value)
   643| --*/
   644| PAL_ERROR InjectActivationInternal(CorUnix::CPalThread* pThread)
   645| {
   646| #ifdef INJECT_ACTIVATION_SIGNAL
   647|     int status = pthread_kill(pThread->GetPThreadSelf(), INJECT_ACTIVATION_SIGNAL);
   648| #ifdef __APPLE__
   649|     if (status == ENOTSUP)
   650|     {
   651|         return ERROR_NOT_SUPPORTED;
   652|     }
   653| #endif
   654|     if ((status != 0) && (status != EAGAIN))
   655|     {
   656|         PROCAbort();
   657|     }
   658|     return NO_ERROR;
   659| #else
   660|     return ERROR_CANCELLED;
   661| #endif
   662| }
   663| #if !HAVE_MACH_EXCEPTIONS
   664| /*++
   665| Function :
   666|     signal_ignore_handler
   667|     Simple signal handler which does nothing
   668| Parameters :
   669|     POSIX signal handler parameter list ("man sigaction" for details)
   670| (no return value)
   671| --*/
   672| static void signal_ignore_handler(int code, siginfo_t *siginfo, void *context)
   673| {
   674| }
   675| #endif // !HAVE_MACH_EXCEPTIONS
   676| void PAL_IgnoreProfileSignal(int signalNum)
   677| {
   678| #if !HAVE_MACH_EXCEPTIONS
   679|     handle_signal(signalNum, signal_ignore_handler, 0);
   680| #endif
   681| }
   682| /*++
   683| Function :
   684|     common_signal_handler
   685|     common code for all signal handlers
   686| Parameters :
   687|     int code : signal received
   688|     siginfo_t *siginfo : siginfo passed to the signal handler
   689|     void *context : context structure passed to the signal handler
   690|     int numParams : number of variable parameters of the exception
   691|     ... : variable parameters of the exception (each of size_t type)
   692|     Returns true if the execution should continue or false if the exception was unhandled
   693| Note:
   694|     the "pointers" parameter should contain a valid exception record pointer,
   695|     but the ContextRecord pointer will be overwritten.
   696| --*/
   697| __attribute__((noinline))
   698| static bool common_signal_handler(int code, siginfo_t *siginfo, void *sigcontext, int numParams, ...)
   699| {
   700| #if !HAVE_MACH_EXCEPTIONS
   701|     sigset_t signal_set;
   702|     CONTEXT signalContextRecord;
   703|     CONTEXT* signalContextRecordPtr = &signalContextRecord;
   704|     EXCEPTION_RECORD exceptionRecord;
   705|     native_context_t *ucontext;
   706|     ucontext = (native_context_t *)sigcontext;
   707|     g_hardware_exception_context_locvar_offset = (int)((char*)&signalContextRecordPtr - (char*)__builtin_frame_address(0));
   708|     if (code == (SIGSEGV | StackOverflowFlag))
   709|     {
   710|         exceptionRecord.ExceptionCode = EXCEPTION_STACK_OVERFLOW;
   711|         code &= ~StackOverflowFlag;
   712|     }
   713|     else
   714|     {
   715|         exceptionRecord.ExceptionCode = CONTEXTGetExceptionCodeForSignal(siginfo, ucontext);
   716|     }
   717|     exceptionRecord.ExceptionFlags = EXCEPTION_IS_SIGNAL;
   718|     exceptionRecord.ExceptionRecord = NULL;
   719|     exceptionRecord.ExceptionAddress = GetNativeContextPC(ucontext);
   720|     exceptionRecord.NumberParameters = numParams;
   721|     va_list params;
   722|     va_start(params, numParams);
   723|     for (int i = 0; i < numParams; i++)
   724|     {
   725|         exceptionRecord.ExceptionInformation[i] = va_arg(params, size_t);
   726|     }
   727|     RtlCaptureContext(&signalContextRecord);
   728|     ULONG contextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_FLOATING_POINT;
   729| #if defined(HOST_AMD64)
   730|     contextFlags |= CONTEXT_XSTATE;
   731| #endif
   732|     CONTEXTFromNativeContext(ucontext, &signalContextRecord, contextFlags);
   733|     /* Unmask signal so we can receive it again */
   734|     sigemptyset(&signal_set);
   735|     sigaddset(&signal_set, code);
   736|     int sigmaskRet = pthread_sigmask(SIG_UNBLOCK, &signal_set, NULL);
   737|     if (sigmaskRet != 0)
   738|     {
   739|         ASSERT("pthread_sigmask failed; error number is %d\n", sigmaskRet);
   740|     }
   741|     signalContextRecord.ContextFlags |= CONTEXT_EXCEPTION_ACTIVE;
   742|     PAL_SEHException exception(&exceptionRecord, &signalContextRecord, true);
   743|     if (SEHProcessException(&exception))
   744|     {
   745|         CONTEXTToNativeContext(exception.ExceptionPointers.ContextRecord, ucontext);
   746|         return true;
   747|     }
   748| #endif // !HAVE_MACH_EXCEPTIONS
   749|     return false;
   750| }
   751| /*++
   752| Function :
   753|     handle_signal
   754|     register handler for specified signal
   755| Parameters :
   756|     int signal_id : signal to handle
   757|     SIGFUNC sigfunc : signal handler
   758|     previousAction : previous sigaction struct
   759|     (no return value)
   760| note : if sigfunc is NULL, the default signal handler is restored
   761| --*/
   762| void handle_signal(int signal_id, SIGFUNC sigfunc, struct sigaction *previousAction, int additionalFlags, bool skipIgnored)
   763| {
   764|     struct sigaction newAction;
   765|     newAction.sa_flags = SA_RESTART | additionalFlags;
   766|     newAction.sa_handler = NULL;
   767|     newAction.sa_sigaction = sigfunc;
   768|     newAction.sa_flags |= SA_SIGINFO;
   769|     sigemptyset(&newAction.sa_mask);
   770| #ifdef INJECT_ACTIVATION_SIGNAL
   771|     if ((additionalFlags & SA_ONSTACK) != 0)
   772|     {
   773|         sigaddset(&newAction.sa_mask, INJECT_ACTIVATION_SIGNAL);
   774|     }
   775| #endif
   776|     if (skipIgnored)
   777|     {
   778|         if (-1 == sigaction(signal_id, NULL, previousAction))
   779|         {
   780|             ASSERT("handle_signal: sigaction() call failed with error code %d (%s)\n",
   781|                 errno, strerror(errno));
   782|         }
   783|         else if (previousAction->sa_handler == SIG_IGN)
   784|         {
   785|             return;
   786|         }
   787|     }
   788|     if (-1 == sigaction(signal_id, &newAction, previousAction))
   789|     {
   790|         ASSERT("handle_signal: sigaction() call failed with error code %d (%s)\n",
   791|             errno, strerror(errno));
   792|     }
   793| }
   794| /*++
   795| Function :
   796|     restore_signal
   797|     restore handler for specified signal
   798| Parameters :
   799|     int signal_id : signal to handle
   800|     previousAction : previous sigaction struct to restore
   801|     (no return value)
   802| --*/
   803| void restore_signal(int signal_id, struct sigaction *previousAction)
   804| {
   805|     if (-1 == sigaction(signal_id, previousAction, NULL))
   806|     {
   807|         ASSERT("restore_signal: sigaction() call failed with error code %d (%s)\n",
   808|             errno, strerror(errno));
   809|     }
   810| }
   811| /*++
   812| Function :
   813|     restore_signal_and_resend
   814|     restore handler for specified signal and signal the process
   815| Parameters :
   816|     int signal_id : signal to handle
   817|     previousAction : previous sigaction struct to restore
   818|     (no return value)
   819| --*/
   820| void restore_signal_and_resend(int signal_id, struct sigaction* previousAction)
   821| {
   822|     restore_signal(signal_id, previousAction);
   823|     kill(gPID, signal_id);
   824| }


# ====================================================================
# FILE: src/coreclr/pal/src/include/pal/process.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-140 ---
     1| /*++
     2| Module Name:
     3|     include/pal/process.h
     4| Abstract:
     5|     Miscellaneous process related functions.
     6| Revision History:
     7| --*/
     8| #ifndef _PAL_PROCESS_H_
     9| #define _PAL_PROCESS_H_
    10| #include "pal/palinternal.h"
    11| #include "pal/stackstring.hpp"
    12| #ifdef __cplusplus
    13| extern "C"
    14| {
    15| #endif // __cplusplus
    16| /* thread ID of thread that has initiated an ExitProcess (or TerminateProcess).
    17|    this is to make sure only one thread cleans up the PAL, and also to prevent
    18|    calls to CreateThread from succeeding once shutdown has started
    19|    [defined in process.c]
    20| */
    21| extern Volatile<LONG> terminator;
    22| extern DWORD gPID;
    23| extern DWORD gSID;
    24| extern LPWSTR pAppDir;
    25| #ifdef __APPLE__
    26| extern LPCSTR gApplicationGroupId;
    27| extern int gApplicationGroupIdLength;
    28| #endif // __APPLE__
    29| extern PathCharString *gSharedFilesPath;
    30| /*++
    31| Function:
    32|   PROCGetProcessIDFromHandle
    33| Abstract
    34|   Return the process ID from a process handle
    35| --*/
    36| DWORD PROCGetProcessIDFromHandle(HANDLE hProcess);
    37| /*++
    38| Function:
    39|   PROCCreateInitialProcess
    40| Abstract
    41|   Initialize all the structures for the initial process.
    42| Parameter
    43|   lpwstrCmdLine:   Command line.
    44|   lpwstrFullPath : Full path to executable
    45| Return
    46|   TRUE: if successful
    47|   FALSE: otherwise
    48| Notes :
    49|     This function takes ownership of lpwstrCmdLine, but not of lpwstrFullPath
    50| --*/
    51| BOOL PROCCreateInitialProcess(LPWSTR lpwstrCmdLine, LPWSTR lpwstrFullPath);
    52| /*++
    53| Function:
    54|   PROCCleanupInitialProcess
    55| Abstract
    56|   Cleanup all the structures for the initial process.
    57| Parameter
    58|   VOID
    59| Return
    60|   VOID
    61| --*/
    62| VOID PROCCleanupInitialProcess(VOID);
    63| #if USE_SYSV_SEMAPHORES
    64| /*++
    65| Function:
    66|   PROCCleanupThreadSemIds(VOID);
    67| Abstract
    68|   Cleanup SysV semaphore ids for all threads.
    69| (no parameters, no return value)
    70| --*/
    71| VOID PROCCleanupThreadSemIds(VOID);
    72| #endif
    73| /*++
    74| Function:
    75|   PROCProcessLock
    76| Abstract
    77|   Enter the critical section associated to the current process
    78| --*/
    79| VOID PROCProcessLock(VOID);
    80| /*++
    81| Function:
    82|   PROCProcessUnlock
    83| Abstract
    84|   Leave the critical section associated to the current process
    85| --*/
    86| VOID PROCProcessUnlock(VOID);
    87| /*++
    88| Function
    89|   PROCAbortInitialize()
    90| Abstract
    91|   Initialize the process abort crash dump program file path and
    92|   name. Doing all of this ahead of time so nothing is allocated
    93|   or copied in PROCAbort/signal handler.
    94| Return
    95|   TRUE - succeeds, FALSE - fails
    96| --*/
    97| BOOL PROCAbortInitialize();
    98| /*++
    99| Function:
   100|   PROCAbort()
   101|   Aborts the process after calling the shutdown cleanup handler. This function
   102|   should be called instead of calling abort() directly.
   103| Parameters:
   104|   signal - POSIX signal number
   105|   siginfo - POSIX signal info
   106|   Does not return
   107| --*/
   108| PAL_NORETURN
   109| VOID PROCAbort(int signal = SIGABRT, siginfo_t* siginfo = nullptr);
   110| /*++
   111| Function:
   112|   PROCNotifyProcessShutdown
   113|   Calls the abort handler to do any shutdown cleanup. Call be
   114|   called from the unhandled native exception handler.
   115| (no return value)
   116| --*/
   117| VOID PROCNotifyProcessShutdown(bool isExecutingOnAltStack = false);
   118| /*++
   119| Function:
   120|   PROCCreateCrashDumpIfEnabled
   121|   Creates crash dump of the process (if enabled). Can be
   122|   called from the unhandled native exception handler.
   123| Parameters:
   124|   signal - POSIX signal number
   125| (no return value)
   126| --*/
   127| VOID PROCCreateCrashDumpIfEnabled(int signal, siginfo_t* siginfo);
   128| /*++
   129| Function:
   130|   InitializeFlushProcessWriteBuffers
   131| Abstract
   132|   This function initializes data structures needed for the FlushProcessWriteBuffers
   133| Return
   134|   TRUE if it succeeded, FALSE otherwise
   135| --*/
   136| BOOL InitializeFlushProcessWriteBuffers();
   137| #ifdef __cplusplus
   138| }
   139| #endif // __cplusplus
   140| #endif //PAL_PROCESS_H_


# ====================================================================
# FILE: src/coreclr/pal/src/thread/process.cpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-3410 ---
     1| /*++
     2| Module Name:
     3|     process.cpp
     4| Abstract:
     5|     Implementation of process object and functions related to processes.
     6| --*/
     7| #include "pal/dbgmsg.h"
     8| SET_DEFAULT_DEBUG_CHANNEL(PROCESS); // some headers have code with asserts, so do this first
     9| #include "pal/procobj.hpp"
    10| #include "pal/thread.hpp"
    11| #include "pal/file.hpp"
    12| #include "pal/handlemgr.hpp"
    13| #include "pal/module.h"
    14| #include "procprivate.hpp"
    15| #include "pal/palinternal.h"
    16| #include "pal/process.h"
    17| #include "pal/init.h"
    18| #include "pal/critsect.h"
    19| #include "pal/debug.h"
    20| #include "pal/utils.h"
    21| #include "pal/environ.h"
    22| #include "pal/virtual.h"
    23| #include "pal/stackstring.hpp"
    24| #include "pal/signal.hpp"
    25| #include <clrconfignocache.h>
    26| #include <errno.h>
    27| #if HAVE_POLL
    28| #include <poll.h>
    29| #else
    30| #include "pal/fakepoll.h"
    31| #endif  // HAVE_POLL
    32| #include <unistd.h>
    33| #include <sys/mman.h>
    34| #include <sys/types.h>
    35| #include <sys/stat.h>
    36| #include <signal.h>
    37| #if HAVE_PRCTL_H
    38| #include <sys/prctl.h>
    39| #include <sys/syscall.h>
    40| #endif
    41| #include <sys/wait.h>
    42| #include <sys/time.h>
    43| #include <sys/resource.h>
    44| #include <debugmacrosext.h>
    45| #include <semaphore.h>
    46| #include <stdint.h>
    47| #include <dlfcn.h>
    48| #include <limits.h>
    49| #include <vector>
    50| #ifdef __linux__
    51| #include <sys/syscall.h> // __NR_membarrier
    52| # if !defined(__NR_membarrier)
    53| #  if defined(__amd64__)
    54| #   define __NR_membarrier  324
    55| #  elif defined(__i386__)
    56| #   define __NR_membarrier  375
    57| #  elif defined(__arm__)
    58| #   define __NR_membarrier  389
    59| #  elif defined(__aarch64__)
    60| #   define __NR_membarrier  283
    61| #  elif defined(__loongarch64)
    62| #   define __NR_membarrier  283
    63| #  else
    64| #   error Unknown architecture
    65| #  endif
    66| # endif
    67| #endif
    68| #ifdef __APPLE__
    69| #include <libproc.h>
    70| #include <sys/sysctl.h>
    71| #include <sys/posix_sem.h>
    72| #include <mach/task.h>
    73| #include <mach/vm_map.h>
    74| extern "C"
    75| {
    76| #  include <mach/thread_state.h>
    77| }
    78| #define CHECK_MACH(_msg, machret) do {                                      \
    79|         if (machret != KERN_SUCCESS)                                        \
    80|         {                                                                   \
    81|             char _szError[1024];                                            \
    82|             snprintf(_szError, ARRAY_SIZE(_szError), "%s: %u: %s", __FUNCTION__, __LINE__, _msg);  \
    83|             mach_error(_szError, machret);                                  \
    84|             abort();                                                        \
    85|         }                                                                   \
    86|     } while (false)
    87| #endif // __APPLE__
    88| #ifdef __NetBSD__
    89| #include <sys/cdefs.h>
    90| #include <sys/param.h>
    91| #include <sys/sysctl.h>
    92| #include <kvm.h>
    93| #endif
    94| #ifdef __FreeBSD__
    95| #include <sys/sysctl.h>
    96| #include <sys/user.h>
    97| #endif
    98| extern char *g_szCoreCLRPath;
    99| extern bool g_running_in_exe;
   100| using namespace CorUnix;
   101| CObjectType CorUnix::otProcess(
   102|                 otiProcess,
   103|                 NULL,   // No cleanup routine
   104|                 NULL,   // No initialization routine
   105|                 0,      // No immutable data
   106|                 NULL,   // No immutable data copy routine
   107|                 NULL,   // No immutable data cleanup routine
   108|                 sizeof(CProcProcessLocalData),
   109|                 NULL,   // No process local data cleanup routine
   110|                 0,      // No shared data
   111|                 PROCESS_ALL_ACCESS,
   112|                 CObjectType::SecuritySupported,
   113|                 CObjectType::SecurityInfoNotPersisted,
   114|                 CObjectType::UnnamedObject,
   115|                 CObjectType::CrossProcessDuplicationAllowed,
   116|                 CObjectType::WaitableObject,
   117|                 CObjectType::SingleTransitionObject,
   118|                 CObjectType::ThreadReleaseHasNoSideEffects,
   119|                 CObjectType::NoOwner
   120|                 );
   121| #ifdef __NR_membarrier
   122| # define membarrier(...)  syscall(__NR_membarrier, __VA_ARGS__)
   123| #else
   124| # define membarrier(...)  -ENOSYS
   125| #endif
   126| enum membarrier_cmd
   127| {
   128|     MEMBARRIER_CMD_QUERY                                 = 0,
   129|     MEMBARRIER_CMD_GLOBAL                                = (1 << 0),
   130|     MEMBARRIER_CMD_GLOBAL_EXPEDITED                      = (1 << 1),
   131|     MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED             = (1 << 2),
   132|     MEMBARRIER_CMD_PRIVATE_EXPEDITED                     = (1 << 3),
   133|     MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED            = (1 << 4),
   134|     MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE           = (1 << 5),
   135|     MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE  = (1 << 6)
   136| };
   137| static int s_flushUsingMemBarrier = 0;
   138| static int* s_helperPage = 0;
   139| pthread_mutex_t flushProcessWriteBuffersMutex;
   140| CAllowedObjectTypes aotProcess(otiProcess);
   141| IPalObject* CorUnix::g_pobjProcess;
   142| CRITICAL_SECTION g_csProcess;
   143| CPalThread* CorUnix::pGThreadList;
   144| DWORD g_dwThreadCount;
   145| LPWSTR g_lpwstrCmdLine = NULL;
   146| LPWSTR g_lpwstrAppDir = NULL;
   147| Volatile<LONG> terminator = 0;
   148| DWORD gPID = (DWORD) -1;
   149| DWORD gSID = (DWORD) -1;
   150| #ifdef __APPLE__
   151| LPCSTR gApplicationGroupId = nullptr;
   152| int gApplicationGroupIdLength = 0;
   153| #endif // __APPLE__
   154| PathCharString* gSharedFilesPath = nullptr;
   155| #if defined(__NetBSD__)
   156| #define CLR_SEM_MAX_NAMELEN 15
   157| #elif defined(__APPLE__)
   158| #define CLR_SEM_MAX_NAMELEN PSEMNAMLEN
   159| #elif defined(NAME_MAX)
   160| #define CLR_SEM_MAX_NAMELEN (NAME_MAX - 4)
   161| #else
   162| #define CLR_SEM_MAX_NAMELEN MAX_PATH
   163| #endif
   164| static_assert_no_msg(CLR_SEM_MAX_NAMELEN <= MAX_PATH);
   165| Volatile<PSHUTDOWN_CALLBACK> g_shutdownCallback = nullptr;
   166| std::vector<const char*> g_argvCreateDump;
   167| pthread_key_t CorUnix::thObjKey;
   168| static WCHAR W16_WHITESPACE[]= {0x0020, 0x0009, 0x000D, 0};
   169| static WCHAR W16_WHITESPACE_DQUOTE[]= {0x0020, 0x0009, 0x000D, '"', 0};
   170| enum FILETYPE
   171| {
   172|     FILE_ERROR,/*ERROR*/
   173|     FILE_UNIX, /*Unix Executable*/
   174|     FILE_DIR   /*Directory*/
   175| };
   176| #pragma pack(push,1)
   177| struct UnambiguousProcessDescriptor
   178| {
   179|     UnambiguousProcessDescriptor()
   180|     {
   181|     }
   182|     UnambiguousProcessDescriptor(DWORD processId, UINT64 disambiguationKey)
   183|     {
   184|         Init(processId, disambiguationKey);
   185|     }
   186|     void Init(DWORD processId, UINT64 disambiguationKey)
   187|     {
   188|         m_processId = processId;
   189|         m_disambiguationKey = disambiguationKey;
   190|     }
   191|     UINT64 m_disambiguationKey;
   192|     DWORD m_processId;
   193| };
   194| #pragma pack(pop)
   195| static
   196| DWORD
   197| StartupHelperThread(
   198|     LPVOID p);
   199| static
   200| BOOL
   201| GetProcessIdDisambiguationKey(
   202|     IN DWORD processId,
   203|     OUT UINT64 *disambiguationKey);
   204| PAL_ERROR
   205| PROCGetProcessStatus(
   206|     CPalThread *pThread,
   207|     HANDLE hProcess,
   208|     PROCESS_STATE *pps,
   209|     DWORD *pdwExitCode);
   210| static
   211| void
   212| CreateSemaphoreName(
   213|     char semName[CLR_SEM_MAX_NAMELEN],
   214|     LPCSTR semaphoreName,
   215|     const UnambiguousProcessDescriptor& unambiguousProcessDescriptor,
   216|     LPCSTR applicationGroupId);
   217| static BOOL getFileName(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, PathCharString& lpFileName);
   218| static char ** buildArgv(LPCWSTR lpCommandLine, PathCharString& lpAppPath, UINT *pnArg);
   219| static BOOL getPath(PathCharString& lpFileName, PathCharString& lpPathFileName);
   220| static int checkFileType(LPCSTR lpFileName);
   221| static BOOL PROCEndProcess(HANDLE hProcess, UINT uExitCode, BOOL bTerminateUnconditionally);
   222| /*++
   223| Function:
   224|   GetCurrentProcessId
   225| See MSDN doc.
   226| --*/
   227| DWORD
   228| PALAPI
   229| GetCurrentProcessId(
   230|             VOID)
   231| {
   232|     PERF_ENTRY(GetCurrentProcessId);
   233|     ENTRY("GetCurrentProcessId()\n" );
   234|     LOGEXIT("GetCurrentProcessId returns DWORD %#x\n", gPID);
   235|     PERF_EXIT(GetCurrentProcessId);
   236|     return gPID;
   237| }
   238| /*++
   239| Function:
   240|   GetCurrentSessionId
   241| See MSDN doc.
   242| --*/
   243| DWORD
   244| PALAPI
   245| GetCurrentSessionId(
   246|             VOID)
   247| {
   248|     PERF_ENTRY(GetCurrentSessionId);
   249|     ENTRY("GetCurrentSessionId()\n" );
   250|     LOGEXIT("GetCurrentSessionId returns DWORD %#x\n", gSID);
   251|     PERF_EXIT(GetCurrentSessionId);
   252|     return gSID;
   253| }
   254| /*++
   255| Function:
   256|   GetCurrentProcess
   257| See MSDN doc.
   258| --*/
   259| HANDLE
   260| PALAPI
   261| GetCurrentProcess(
   262|           VOID)
   263| {
   264|     PERF_ENTRY(GetCurrentProcess);
   265|     ENTRY("GetCurrentProcess()\n" );
   266|     LOGEXIT("GetCurrentProcess returns HANDLE %p\n", hPseudoCurrentProcess);
   267|     PERF_EXIT(GetCurrentProcess);
   268|     /* return a pseudo handle */
   269|     return hPseudoCurrentProcess;
   270| }
   271| /*++
   272| Function:
   273|   CreateProcessW
   274| Note:
   275|   Only Standard handles need to be inherited.
   276|   Security attributes parameters are not used.
   277| See MSDN doc.
   278| --*/
   279| BOOL
   280| PALAPI
   281| CreateProcessW(
   282|            IN LPCWSTR lpApplicationName,
   283|            IN LPWSTR lpCommandLine,
   284|            IN LPSECURITY_ATTRIBUTES lpProcessAttributes,
   285|            IN LPSECURITY_ATTRIBUTES lpThreadAttributes,
   286|            IN BOOL bInheritHandles,
   287|            IN DWORD dwCreationFlags,
   288|            IN LPVOID lpEnvironment,
   289|            IN LPCWSTR lpCurrentDirectory,
   290|            IN LPSTARTUPINFOW lpStartupInfo,
   291|            OUT LPPROCESS_INFORMATION lpProcessInformation)
   292| {
   293|     PAL_ERROR palError = NO_ERROR;
   294|     CPalThread *pThread;
   295|     PERF_ENTRY(CreateProcessW);
   296|     ENTRY("CreateProcessW(lpAppName=%p (%S), lpCmdLine=%p (%S), lpProcessAttr=%p,"
   297|            "lpThreadAttr=%p, bInherit=%d, dwFlags=%#x, lpEnv=%p,"
   298|            "lpCurrentDir=%p (%S), lpStartupInfo=%p, lpProcessInfo=%p)\n",
   299|            lpApplicationName?lpApplicationName:W16_NULLSTRING,
   300|            lpApplicationName?lpApplicationName:W16_NULLSTRING,
   301|            lpCommandLine?lpCommandLine:W16_NULLSTRING,
   302|            lpCommandLine?lpCommandLine:W16_NULLSTRING,lpProcessAttributes,
   303|            lpThreadAttributes, bInheritHandles, dwCreationFlags,lpEnvironment,
   304|            lpCurrentDirectory?lpCurrentDirectory:W16_NULLSTRING,
   305|            lpCurrentDirectory?lpCurrentDirectory:W16_NULLSTRING,
   306|            lpStartupInfo, lpProcessInformation);
   307|     pThread = InternalGetCurrentThread();
   308|     palError = InternalCreateProcess(
   309|         pThread,
   310|         lpApplicationName,
   311|         lpCommandLine,
   312|         lpProcessAttributes,
   313|         lpThreadAttributes,
   314|         dwCreationFlags,
   315|         lpEnvironment,
   316|         lpCurrentDirectory,
   317|         lpStartupInfo,
   318|         lpProcessInformation
   319|         );
   320|     if (NO_ERROR != palError)
   321|     {
   322|         pThread->SetLastError(palError);
   323|     }
   324|     LOGEXIT("CreateProcessW returns BOOL %d\n", NO_ERROR == palError);
   325|     PERF_EXIT(CreateProcessW);
   326|     return NO_ERROR == palError;
   327| }
   328| PAL_ERROR
   329| PrepareStandardHandle(
   330|     CPalThread *pThread,
   331|     HANDLE hFile,
   332|     IPalObject **ppobjFile,
   333|     int *piFd
   334|     )
   335| {
   336|     PAL_ERROR palError = NO_ERROR;
   337|     IPalObject *pobjFile = NULL;
   338|     IDataLock *pDataLock = NULL;
   339|     CFileProcessLocalData *pLocalData = NULL;
   340|     int iError = 0;
   341|     palError = g_pObjectManager->ReferenceObjectByHandle(
   342|         pThread,
   343|         hFile,
   344|         &aotFile,
   345|         &pobjFile
   346|         );
   347|     if (NO_ERROR != palError)
   348|     {
   349|         ERROR("Bad handle passed through CreateProcess\n");
   350|         goto PrepareStandardHandleExit;
   351|     }
   352|     palError = pobjFile->GetProcessLocalData(
   353|         pThread,
   354|         ReadLock,
   355|         &pDataLock,
   356|         reinterpret_cast<void **>(&pLocalData)
   357|         );
   358|     if (NO_ERROR != palError)
   359|     {
   360|         ASSERT("Unable to access file data\n");
   361|         goto PrepareStandardHandleExit;
   362|     }
   363|     if (!pLocalData->inheritable)
   364|     {
   365|         ERROR("Non-inheritable handle passed through CreateProcess\n");
   366|         palError = ERROR_INVALID_HANDLE;
   367|         goto PrepareStandardHandleExit;
   368|     }
   369|     iError = fcntl(pLocalData->unix_fd, F_SETFD, 0);
   370|     if (-1 == iError)
   371|     {
   372|         ERROR("Unable to remove close-on-exec for file (errno %i)\n", errno);
   373|         palError = ERROR_INVALID_HANDLE;
   374|         goto PrepareStandardHandleExit;
   375|     }
   376|     *piFd = pLocalData->unix_fd;
   377|     pDataLock->ReleaseLock(pThread, FALSE);
   378|     pDataLock = NULL;
   379|     *ppobjFile = pobjFile;
   380|     pobjFile = NULL;
   381| PrepareStandardHandleExit:
   382|     if (NULL != pDataLock)
   383|     {
   384|         pDataLock->ReleaseLock(pThread, FALSE);
   385|     }
   386|     if (NULL != pobjFile)
   387|     {
   388|         pobjFile->ReleaseReference(pThread);
   389|     }
   390|     return palError;
   391| }
   392| PAL_ERROR
   393| CorUnix::InternalCreateProcess(
   394|     CPalThread *pThread,
   395|     LPCWSTR lpApplicationName,
   396|     LPWSTR lpCommandLine,
   397|     LPSECURITY_ATTRIBUTES lpProcessAttributes,
   398|     LPSECURITY_ATTRIBUTES lpThreadAttributes,
   399|     DWORD dwCreationFlags,
   400|     LPVOID lpEnvironment,
   401|     LPCWSTR lpCurrentDirectory,
   402|     LPSTARTUPINFOW lpStartupInfo,
   403|     LPPROCESS_INFORMATION lpProcessInformation
   404|     )
   405| {
   406|     PAL_ERROR palError = NO_ERROR;
   407|     IPalObject *pobjProcess = NULL;
   408|     IPalObject *pobjProcessRegistered = NULL;
   409|     IDataLock *pLocalDataLock = NULL;
   410|     CProcProcessLocalData *pLocalData;
   411|     IDataLock *pSharedDataLock = NULL;
   412|     CPalThread *pDummyThread = NULL;
   413|     HANDLE hDummyThread = NULL;
   414|     HANDLE hProcess = NULL;
   415|     CObjectAttributes oa(NULL, lpProcessAttributes);
   416|     IPalObject *pobjFileIn = NULL;
   417|     int iFdIn = -1;
   418|     IPalObject *pobjFileOut = NULL;
   419|     int iFdOut = -1;
   420|     IPalObject *pobjFileErr = NULL;
   421|     int iFdErr = -1;
   422|     pid_t processId;
   423|     PathCharString lpFileNamePS;
   424|     char **lppArgv = NULL;
   425|     UINT nArg;
   426|     int  iRet;
   427|     char **EnvironmentArray=NULL;
   428|     int child_blocking_pipe = -1;
   429|     int parent_blocking_pipe = -1;
   430|     /* Validate parameters */
   431|     /* note : specs indicate lpApplicationName should always
   432|        be NULL; however support for it is already implemented. Leaving the code
   433|        in, specs can change; but rejecting non-NULL for now to conform to the
   434|        spec. */
   435|     if( NULL != lpApplicationName )
   436|     {
   437|         ASSERT("lpApplicationName should be NULL, but is %S instead\n",
   438|                lpApplicationName);
   439|         palError = ERROR_INVALID_PARAMETER;
   440|         goto InternalCreateProcessExit;
   441|     }
   442|     if (0 != (dwCreationFlags & ~(CREATE_SUSPENDED|CREATE_NEW_CONSOLE)))
   443|     {
   444|         ASSERT("Unexpected creation flags (%#x)\n", dwCreationFlags);
   445|         palError = ERROR_INVALID_PARAMETER;
   446|         goto InternalCreateProcessExit;
   447|     }
   448|     /* Security attributes parameters are ignored */
   449|     if (lpProcessAttributes != NULL &&
   450|         (lpProcessAttributes->lpSecurityDescriptor != NULL ||
   451|          lpProcessAttributes->bInheritHandle != TRUE))
   452|     {
   453|         ASSERT("lpProcessAttributes is invalid, parameter ignored (%p)\n",
   454|                lpProcessAttributes);
   455|         palError = ERROR_INVALID_PARAMETER;
   456|         goto InternalCreateProcessExit;
   457|     }
   458|     if (lpThreadAttributes != NULL)
   459|     {
   460|         ASSERT("lpThreadAttributes parameter must be NULL (%p)\n",
   461|                lpThreadAttributes);
   462|         palError = ERROR_INVALID_PARAMETER;
   463|         goto InternalCreateProcessExit;
   464|     }
   465|     /* note : Win32 crashes in this case */
   466|     if(NULL == lpStartupInfo)
   467|     {
   468|         ERROR("lpStartupInfo is NULL\n");
   469|         palError = ERROR_INVALID_PARAMETER;
   470|         goto InternalCreateProcessExit;
   471|     }
   472|     /* Validate lpStartupInfo.cb field */
   473|     if (lpStartupInfo->cb < sizeof(STARTUPINFOW))
   474|     {
   475|         ASSERT("lpStartupInfo parameter structure size is invalid (%u)\n",
   476|               lpStartupInfo->cb);
   477|         palError = ERROR_INVALID_PARAMETER;
   478|         goto InternalCreateProcessExit;
   479|     }
   480|     /* lpStartupInfo should be either zero or STARTF_USESTDHANDLES */
   481|     if (lpStartupInfo->dwFlags & ~STARTF_USESTDHANDLES)
   482|     {
   483|         ASSERT("lpStartupInfo parameter invalid flags (%#x)\n",
   484|               lpStartupInfo->dwFlags);
   485|         palError = ERROR_INVALID_PARAMETER;
   486|         goto InternalCreateProcessExit;
   487|     }
   488|     /* validate given standard handles if we have any */
   489|     if (lpStartupInfo->dwFlags & STARTF_USESTDHANDLES)
   490|     {
   491|         palError = PrepareStandardHandle(
   492|             pThread,
   493|             lpStartupInfo->hStdInput,
   494|             &pobjFileIn,
   495|             &iFdIn
   496|             );
   497|         if (NO_ERROR != palError)
   498|         {
   499|             goto InternalCreateProcessExit;
   500|         }
   501|         palError = PrepareStandardHandle(
   502|             pThread,
   503|             lpStartupInfo->hStdOutput,
   504|             &pobjFileOut,
   505|             &iFdOut
   506|             );
   507|         if (NO_ERROR != palError)
   508|         {
   509|             goto InternalCreateProcessExit;
   510|         }
   511|         palError = PrepareStandardHandle(
   512|             pThread,
   513|             lpStartupInfo->hStdError,
   514|             &pobjFileErr,
   515|             &iFdErr
   516|             );
   517|         if (NO_ERROR != palError)
   518|         {
   519|             goto InternalCreateProcessExit;
   520|         }
   521|     }
   522|     if (!getFileName(lpApplicationName, lpCommandLine, lpFileNamePS))
   523|     {
   524|         ERROR("Can't find executable!\n");
   525|         palError = ERROR_FILE_NOT_FOUND;
   526|         goto InternalCreateProcessExit;
   527|     }
   528|     /* check type of file */
   529|     iRet = checkFileType(lpFileNamePS);
   530|     switch (iRet)
   531|     {
   532|         case FILE_ERROR: /* file not found, or not an executable */
   533|             WARN ("File is not valid (%s)", lpFileNamePS.GetString());
   534|             palError = ERROR_FILE_NOT_FOUND;
   535|             goto InternalCreateProcessExit;
   536|         case FILE_UNIX: /* Unix binary file */
   537|             break;  /* nothing to do */
   538|         case FILE_DIR:/*Directory*/
   539|             WARN ("File is a Directory (%s)", lpFileNamePS.GetString());
   540|             palError = ERROR_ACCESS_DENIED;
   541|             goto InternalCreateProcessExit;
   542|             break;
   543|         default: /* not supposed to get here */
   544|             ASSERT ("Invalid return type from checkFileType");
   545|             palError = ERROR_FILE_NOT_FOUND;
   546|             goto InternalCreateProcessExit;
   547|     }
   548|     /* build Argument list, lppArgv is allocated in buildArgv function and
   549|        requires to be freed */
   550|     lppArgv = buildArgv(lpCommandLine, lpFileNamePS, &nArg);
   551|     /* set the Environment variable */
   552|     if (lpEnvironment != NULL)
   553|     {
   554|         unsigned i;
   555|         unsigned EnvironmentEntries = 0;
   556|         for (i = 0; ((char *)lpEnvironment)[i]!='\0'; i++)
   557|         {
   558|             EnvironmentEntries ++;
   559|             for (;((char *)lpEnvironment)[i]!='\0'; i++)
   560|             {
   561|             }
   562|         }
   563|         EnvironmentEntries++;
   564|         EnvironmentArray = (char **)InternalMalloc(EnvironmentEntries * sizeof(char *));
   565|         EnvironmentEntries = 0;
   566|         for (i = 0; ((char *)lpEnvironment)[i]!='\0'; i++)
   567|         {
   568|             EnvironmentArray[EnvironmentEntries] = &((char *)lpEnvironment)[i];
   569|             EnvironmentEntries ++;
   570|             for (;((char *)lpEnvironment)[i]!='\0'; i++)
   571|             {
   572|             }
   573|         }
   574|         EnvironmentArray[EnvironmentEntries] = NULL;
   575|     }
   576|     palError = g_pObjectManager->AllocateObject(
   577|         pThread,
   578|         &otProcess,
   579|         &oa,
   580|         &pobjProcess
   581|         );
   582|     if (NO_ERROR != palError)
   583|     {
   584|         ERROR("Unable to allocate object for new process\n");
   585|         goto InternalCreateProcessExit;
   586|     }
   587|     palError = g_pObjectManager->RegisterObject(
   588|         pThread,
   589|         pobjProcess,
   590|         &aotProcess,
   591|         &hProcess,
   592|         &pobjProcessRegistered
   593|         );
   594|     pobjProcess = NULL;
   595|     if (NO_ERROR != palError)
   596|     {
   597|         ERROR("Unable to register new process object\n");
   598|         goto InternalCreateProcessExit;
   599|     }
   600|     palError = InternalCreateDummyThread(
   601|         pThread,
   602|         lpThreadAttributes,
   603|         &pDummyThread,
   604|         &hDummyThread
   605|         );
   606|     if (dwCreationFlags & CREATE_SUSPENDED)
   607|     {
   608|         int pipe_descs[2];
   609|         if (-1 == pipe(pipe_descs))
   610|         {
   611|             ERROR("pipe() failed! error is %d (%s)\n", errno, strerror(errno));
   612|             palError = ERROR_NOT_ENOUGH_MEMORY;
   613|             goto InternalCreateProcessExit;
   614|         }
   615|         /* [0] is read end, [1] is write end */
   616|         pDummyThread->suspensionInfo.SetBlockingPipe(pipe_descs[1]);
   617|         parent_blocking_pipe = pipe_descs[1];
   618|         child_blocking_pipe = pipe_descs[0];
   619|     }
   620|     palError = pobjProcessRegistered->GetProcessLocalData(
   621|         pThread,
   622|         WriteLock,
   623|         &pLocalDataLock,
   624|         reinterpret_cast<void **>(&pLocalData)
   625|         );
   626|     if (NO_ERROR != palError)
   627|     {
   628|         ASSERT("Unable to obtain local data for new process object\n");
   629|         goto InternalCreateProcessExit;
   630|     }
   631|     /* fork the new process */
   632|     processId = fork();
   633|     if (processId == -1)
   634|     {
   635|         ASSERT("Unable to create a new process with fork()\n");
   636|         if (-1 != child_blocking_pipe)
   637|         {
   638|             close(child_blocking_pipe);
   639|             close(parent_blocking_pipe);
   640|         }
   641|         palError = ERROR_INTERNAL_ERROR;
   642|         goto InternalCreateProcessExit;
   643|     }
   644|     /* From the time the child process begins running, to when it reaches execve,
   645|     the child process is not a real PAL process and does not own any PAL
   646|     resources, although it has access to the PAL resources of its parent process.
   647|     Thus, while the child process is in this window, it is dangerous for it to affect
   648|     its parent's PAL resources. As a consequence, no PAL code should be used
   649|     in this window; all code should make unix calls. Note the use of _exit
   650|     instead of exit to avoid calling PAL_Terminate and the lack of TRACE's and
   651|     ASSERT's. */
   652|     if (processId == 0)  /* child process */
   653|     {
   654|         init_count = 0;
   655|         sigset_t sm;
   656|         sigemptyset(&sm);
   657|         iRet = sigprocmask(SIG_SETMASK, &sm, NULL);
   658|         if (iRet != 0)
   659|         {
   660|             _exit(EXIT_FAILURE);
   661|         }
   662|         if (dwCreationFlags & CREATE_SUSPENDED)
   663|         {
   664|             BYTE resume_code = 0;
   665|             ssize_t read_ret;
   666|             /* close the write end of the pipe, the child doesn't need it */
   667|             close(parent_blocking_pipe);
   668|             read_again:
   669|             /* block until ResumeThread writes something to the pipe */
   670|             read_ret = read(child_blocking_pipe, &resume_code, sizeof(resume_code));
   671|             if (sizeof(resume_code) != read_ret)
   672|             {
   673|                 if (read_ret == -1 && EINTR == errno)
   674|                 {
   675|                     goto read_again;
   676|                 }
   677|                 else
   678|                 {
   679|                     /* note : read might return 0 (and return EAGAIN) if the other
   680|                        end of the pipe gets closed - for example because the parent
   681|                        process dies (very) abruptly */
   682|                     _exit(EXIT_FAILURE);
   683|                 }
   684|             }
   685|             if (WAKEUPCODE != resume_code)
   686|             {
   687|                 _exit(EXIT_FAILURE);
   688|             }
   689|             close(child_blocking_pipe);
   690|         }
   691|         /* Set the current directory */
   692|         if (lpCurrentDirectory)
   693|         {
   694|             SetCurrentDirectoryW(lpCurrentDirectory);
   695|         }
   696|         /* Set the standard handles to the incoming values */
   697|         if (lpStartupInfo->dwFlags & STARTF_USESTDHANDLES)
   698|         {
   699|             /* For each handle, we need to duplicate the incoming unix
   700|                fd to the corresponding standard one.  The API that I use,
   701|                dup2, will copy the source to the destination, automatically
   702|                closing the existing destination, in an atomic way */
   703|             if (dup2(iFdIn, STDIN_FILENO) == -1)
   704|             {
   705|                 _exit(EXIT_FAILURE);
   706|             }
   707|             if (dup2(iFdOut, STDOUT_FILENO) == -1)
   708|             {
   709|                 _exit(EXIT_FAILURE);
   710|             }
   711|             if (dup2(iFdErr, STDERR_FILENO) == -1)
   712|             {
   713|                 _exit(EXIT_FAILURE);
   714|             }
   715|             /* now close the original FDs, we don't need them anymore */
   716|             close(iFdIn);
   717|             close(iFdOut);
   718|             close(iFdErr);
   719|         }
   720|         /* execute the new process */
   721|         if (EnvironmentArray)
   722|         {
   723|             execve(lpFileNamePS, lppArgv, EnvironmentArray);
   724|         }
   725|         else
   726|         {
   727|             execve(lpFileNamePS, lppArgv, palEnvironment);
   728|         }
   729|         /* if we get here, it means the execve function call failed so just exit */
   730|         _exit(EXIT_FAILURE);
   731|     }
   732|     /* parent process */
   733|     /* close the read end of the pipe, the parent doesn't need it */
   734|     close(child_blocking_pipe);
   735|     /* Set the process ID */
   736|     pLocalData->dwProcessId = processId;
   737|     pLocalDataLock->ReleaseLock(pThread, TRUE);
   738|     pLocalDataLock = NULL;
   739|     if (lpStartupInfo->dwFlags & STARTF_USESTDHANDLES)
   740|     {
   741|         pobjFileIn->ReleaseReference(pThread);
   742|         pobjFileIn = NULL;
   743|         pobjFileOut->ReleaseReference(pThread);
   744|         pobjFileOut = NULL;
   745|         pobjFileErr->ReleaseReference(pThread);
   746|         pobjFileErr = NULL;
   747|     }
   748|     /* fill PROCESS_INFORMATION structure */
   749|     lpProcessInformation->hProcess = hProcess;
   750|     lpProcessInformation->hThread = hDummyThread;
   751|     lpProcessInformation->dwProcessId = processId;
   752|     lpProcessInformation->dwThreadId_PAL_Undefined = 0;
   753|     TRACE("New process created: id=%#x\n", processId);
   754| InternalCreateProcessExit:
   755|     if (NULL != pLocalDataLock)
   756|     {
   757|         pLocalDataLock->ReleaseLock(pThread, FALSE);
   758|     }
   759|     if (NULL != pSharedDataLock)
   760|     {
   761|         pSharedDataLock->ReleaseLock(pThread, FALSE);
   762|     }
   763|     if (NULL != pobjProcess)
   764|     {
   765|         pobjProcess->ReleaseReference(pThread);
   766|     }
   767|     if (NULL != pobjProcessRegistered)
   768|     {
   769|         pobjProcessRegistered->ReleaseReference(pThread);
   770|     }
   771|     if (NO_ERROR != palError)
   772|     {
   773|         if (NULL != hProcess)
   774|         {
   775|             g_pObjectManager->RevokeHandle(pThread, hProcess);
   776|         }
   777|         if (NULL != hDummyThread)
   778|         {
   779|             g_pObjectManager->RevokeHandle(pThread, hDummyThread);
   780|         }
   781|     }
   782|     if (EnvironmentArray)
   783|     {
   784|         free(EnvironmentArray);
   785|     }
   786|     /* if we still have the file structures at this point, it means we
   787|        encountered an error sometime between when we acquired them and when we
   788|        fork()ed. We not only have to release them, we have to give them back
   789|        their close-on-exec flag */
   790|     if (NULL != pobjFileIn)
   791|     {
   792|         if(-1 == fcntl(iFdIn, F_SETFD, 1))
   793|         {
   794|             WARN("couldn't restore close-on-exec flag to stdin descriptor! "
   795|                  "errno is %d (%s)\n", errno, strerror(errno));
   796|         }
   797|         pobjFileIn->ReleaseReference(pThread);
   798|     }
   799|     if (NULL != pobjFileOut)
   800|     {
   801|         if(-1 == fcntl(iFdOut, F_SETFD, 1))
   802|         {
   803|             WARN("couldn't restore close-on-exec flag to stdout descriptor! "
   804|                  "errno is %d (%s)\n", errno, strerror(errno));
   805|         }
   806|         pobjFileOut->ReleaseReference(pThread);
   807|     }
   808|     if (NULL != pobjFileErr)
   809|     {
   810|         if(-1 == fcntl(iFdErr, F_SETFD, 1))
   811|         {
   812|             WARN("couldn't restore close-on-exec flag to stderr descriptor! "
   813|                  "errno is %d (%s)\n", errno, strerror(errno));
   814|         }
   815|         pobjFileErr->ReleaseReference(pThread);
   816|     }
   817|     /* free allocated memory */
   818|     if (lppArgv)
   819|     {
   820|         free(*lppArgv);
   821|         free(lppArgv);
   822|     }
   823|     return palError;
   824| }
   825| /*++
   826| Function:
   827|   GetExitCodeProcess
   828| See MSDN doc.
   829| --*/
   830| BOOL
   831| PALAPI
   832| GetExitCodeProcess(
   833|     IN HANDLE hProcess,
   834|     IN LPDWORD lpExitCode)
   835| {
   836|     CPalThread *pThread;
   837|     PAL_ERROR palError = NO_ERROR;
   838|     DWORD dwExitCode;
   839|     PROCESS_STATE ps;
   840|     PERF_ENTRY(GetExitCodeProcess);
   841|     ENTRY("GetExitCodeProcess(hProcess = %p, lpExitCode = %p)\n",
   842|           hProcess, lpExitCode);
   843|     pThread = InternalGetCurrentThread();
   844|     if(NULL == lpExitCode)
   845|     {
   846|         WARN("Got NULL lpExitCode\n");
   847|         palError = ERROR_INVALID_PARAMETER;
   848|         goto done;
   849|     }
   850|     palError = PROCGetProcessStatus(
   851|         pThread,
   852|         hProcess,
   853|         &ps,
   854|         &dwExitCode
   855|         );
   856|     if (NO_ERROR != palError)
   857|     {
   858|         ASSERT("Couldn't get process status information!\n");
   859|         goto done;
   860|     }
   861|     if( PS_DONE == ps )
   862|     {
   863|         *lpExitCode = dwExitCode;
   864|     }
   865|     else
   866|     {
   867|         *lpExitCode = STILL_ACTIVE;
   868|     }
   869| done:
   870|     if (NO_ERROR != palError)
   871|     {
   872|         pThread->SetLastError(palError);
   873|     }
   874|     LOGEXIT("GetExitCodeProcess returns BOOL %d\n", NO_ERROR == palError);
   875|     PERF_EXIT(GetExitCodeProcess);
   876|     return NO_ERROR == palError;
   877| }
   878| /*++
   879| Function:
   880|   ExitProcess
   881| See MSDN doc.
   882| --*/
   883| PAL_NORETURN
   884| VOID
   885| PALAPI
   886| ExitProcess(
   887|     IN UINT uExitCode)
   888| {
   889|     DWORD old_terminator;
   890|     PERF_ENTRY_ONLY(ExitProcess);
   891|     ENTRY("ExitProcess(uExitCode=0x%x)\n", uExitCode );
   892|     old_terminator = InterlockedCompareExchange(&terminator, GetCurrentThreadId(), 0);
   893|     if (GetCurrentThreadId() == old_terminator)
   894|     {
   895|         if (!PALIsInitialized())
   896|         {
   897|             exit(uExitCode);
   898|             ASSERT("exit has returned\n");
   899|         }
   900|         else
   901|         {
   902|             WARN("thread re-called ExitProcess\n");
   903|             PROCEndProcess(GetCurrentProcess(), uExitCode, FALSE);
   904|         }
   905|     }
   906|     else if (0 != old_terminator)
   907|     {
   908|         /* another thread has already initiated the termination process. we
   909|            could just block on the PALInitLock critical section, but then
   910|            PROCSuspendOtherThreads would hang... so sleep forever here, we're
   911|            terminating anyway
   912|            Update: [TODO] PROCSuspendOtherThreads has been removed. Can this
   913|            code be changed? */
   914|         WARN("termination already started from another thread; blocking.\n");
   915|         poll(NULL, 0, INFTIM);
   916|     }
   917|     /* ExitProcess may be called even if PAL is not initialized.
   918|        Verify if process structure exist
   919|     */
   920|     if (PALInitLock() && PALIsInitialized())
   921|     {
   922|         PROCEndProcess(GetCurrentProcess(), uExitCode, FALSE);
   923|         /* Should not get here, because we terminate the current process */
   924|         ASSERT("PROCEndProcess has returned\n");
   925|     }
   926|     else
   927|     {
   928|         exit(uExitCode);
   929|         /* Should not get here, because we terminate the current process */
   930|         ASSERT("exit has returned\n");
   931|     }
   932|     /* this should never get executed */
   933|     ASSERT("ExitProcess should not return!\n");
   934|     while (true);
   935| }
   936| /*++
   937| Function:
   938|   TerminateProcess
   939| Note:
   940|   hProcess is a handle on the current process.
   941| See MSDN doc.
   942| --*/
   943| BOOL
   944| PALAPI
   945| TerminateProcess(
   946|     IN HANDLE hProcess,
   947|     IN UINT uExitCode)
   948| {
   949|     BOOL ret;
   950|     PERF_ENTRY(TerminateProcess);
   951|     ENTRY("TerminateProcess(hProcess=%p, uExitCode=%u)\n",hProcess, uExitCode );
   952|     ret = PROCEndProcess(hProcess, uExitCode, TRUE);
   953|     LOGEXIT("TerminateProcess returns BOOL %d\n", ret);
   954|     PERF_EXIT(TerminateProcess);
   955|     return ret;
   956| }
   957| /*++
   958| Function:
   959|   RaiseFailFastException
   960| See MSDN doc.
   961| --*/
   962| VOID
   963| PALAPI
   964| DECLSPEC_NORETURN
   965| RaiseFailFastException(
   966|     IN PEXCEPTION_RECORD pExceptionRecord,
   967|     IN PCONTEXT pContextRecord,
   968|     IN DWORD dwFlags)
   969| {
   970|     PERF_ENTRY(RaiseFailFastException);
   971|     ENTRY("RaiseFailFastException");
   972|     TerminateCurrentProcessNoExit(TRUE);
   973|     PROCAbort();
   974|     LOGEXIT("RaiseFailFastException");
   975|     PERF_EXIT(RaiseFailFastException);
   976| }
   977| /*++
   978| Function:
   979|   PROCEndProcess
   980|   Called from TerminateProcess and ExitProcess. This does the work of
   981|   TerminateProcess, but also takes a flag that determines whether we
   982|   shut down unconditionally. If the flag is set, the PAL will do very
   983|   little extra work before exiting. Most importantly, it won't shut
   984|   down any DLLs that are loaded.
   985| --*/
   986| static BOOL PROCEndProcess(HANDLE hProcess, UINT uExitCode, BOOL bTerminateUnconditionally)
   987| {
   988|     DWORD dwProcessId;
   989|     BOOL ret = FALSE;
   990|     dwProcessId = PROCGetProcessIDFromHandle(hProcess);
   991|     if (dwProcessId == 0)
   992|     {
   993|         SetLastError(ERROR_INVALID_HANDLE);
   994|     }
   995|     else if(dwProcessId != GetCurrentProcessId())
   996|     {
   997|         if (uExitCode != 0)
   998|             WARN("exit code 0x%x ignored for external process.\n", uExitCode);
   999|         if (kill(dwProcessId, SIGKILL) == 0)
  1000|         {
  1001|             ret = TRUE;
  1002|         }
  1003|         else
  1004|         {
  1005|             switch (errno) {
  1006|             case ESRCH:
  1007|                 SetLastError(ERROR_INVALID_HANDLE);
  1008|                 break;
  1009|             case EPERM:
  1010|                 SetLastError(ERROR_ACCESS_DENIED);
  1011|                 break;
  1012|             default:
  1013|                 ASSERT(FALSE);
  1014|                 SetLastError(ERROR_INTERNAL_ERROR);
  1015|                 break;
  1016|             }
  1017|         }
  1018|     }
  1019|     else
  1020|     {
  1021|         if (bTerminateUnconditionally)
  1022|         {
  1023|             WARN("exit code 0x%x ignored for terminate.\n", uExitCode);
  1024|         }
  1025|         else if ((uExitCode & 0xff) != uExitCode)
  1026|         {
  1027|             ERROR("exit() only supports the lower 8-bits of an exit code. "
  1028|                 "status will only see error 0x%x instead of 0x%x.\n", uExitCode & 0xff, uExitCode);
  1029|         }
  1030|         TerminateCurrentProcessNoExit(bTerminateUnconditionally);
  1031|         LOGEXIT("PROCEndProcess will not return\n");
  1032|         if (bTerminateUnconditionally)
  1033|         {
  1034|             PROCAbort(uExitCode == (128 + SIGTERM) ? SIGTERM : SIGABRT);
  1035|         }
  1036|         else
  1037|         {
  1038|             exit(uExitCode);
  1039|         }
  1040|         ASSERT(FALSE); // we shouldn't get here
  1041|     }
  1042|     return ret;
  1043| }
  1044| /*++
  1045| Function:
  1046|   PAL_SetShutdownCallback
  1047| Abstract:
  1048|   Sets a callback that is executed when the PAL is shut down because of
  1049|   ExitProcess, TerminateProcess or PAL_Shutdown but not PAL_Terminate/Ex.
  1050|   NOTE: Currently only one callback can be set at a time.
  1051| --*/
  1052| PALIMPORT
  1053| VOID
  1054| PALAPI
  1055| PAL_SetShutdownCallback(
  1056|     IN PSHUTDOWN_CALLBACK callback)
  1057| {
  1058|     _ASSERTE(g_shutdownCallback == nullptr);
  1059|     g_shutdownCallback = callback;
  1060| }
  1061| #if defined(__NetBSD__)
  1062| static const char* RuntimeSemaphoreNameFormat = "/clr%s%08llx";
  1063| #else
  1064| static const char* RuntimeSemaphoreNameFormat = "/clr%s%08x%016llx";
  1065| #endif
  1066| static const char* RuntimeStartupSemaphoreName = "st";
  1067| static const char* RuntimeContinueSemaphoreName = "co";
  1068| #if defined(__NetBSD__)
  1069| static uint64_t HashSemaphoreName(uint64_t a, uint64_t b)
  1070| {
  1071|     return (a ^ b) & 0xffffffff;
  1072| }
  1073| #else
  1074| #define HashSemaphoreName(a,b) a,b
  1075| #endif
  1076| static const char *const TwoWayNamedPipePrefix = "clr-debug-pipe";
  1077| static const char* IpcNameFormat = "%s-%d-%llu-%s";
  1078| /*++
  1079|     PAL_NotifyRuntimeStarted
  1080|     Signals the debugger waiting for runtime startup notification to continue and
  1081|     waits until the debugger signals us to continue.
  1082| Parameters:
  1083|     None
  1084| Return value:
  1085|     TRUE - successfully launched by debugger, FALSE - not launched or some failure in the handshake
  1086| --*/
  1087| BOOL
  1088| PALAPI
  1089| PAL_NotifyRuntimeStarted()
  1090| {
  1091|     char startupSemName[CLR_SEM_MAX_NAMELEN];
  1092|     char continueSemName[CLR_SEM_MAX_NAMELEN];
  1093|     sem_t *startupSem = SEM_FAILED;
  1094|     sem_t *continueSem = SEM_FAILED;
  1095|     BOOL launched = FALSE;
  1096|     UINT64 processIdDisambiguationKey = 0;
  1097|     BOOL ret = GetProcessIdDisambiguationKey(gPID, &processIdDisambiguationKey);
  1098|     _ASSERTE(ret == TRUE || processIdDisambiguationKey == 0);
  1099|     UnambiguousProcessDescriptor unambiguousProcessDescriptor(gPID, processIdDisambiguationKey);
  1100|     LPCSTR applicationGroupId = PAL_GetApplicationGroupId();
  1101|     CreateSemaphoreName(startupSemName, RuntimeStartupSemaphoreName, unambiguousProcessDescriptor, applicationGroupId);
  1102|     CreateSemaphoreName(continueSemName, RuntimeContinueSemaphoreName, unambiguousProcessDescriptor, applicationGroupId);
  1103|     TRACE("PAL_NotifyRuntimeStarted opening continue '%s' startup '%s'\n", continueSemName, startupSemName);
  1104|     startupSem = sem_open(startupSemName, 0);
  1105|     if (startupSem == SEM_FAILED)
  1106|     {
  1107|         TRACE("sem_open(%s) failed: %d (%s)\n", startupSemName, errno, strerror(errno));
  1108|         goto exit;
  1109|     }
  1110|     continueSem = sem_open(continueSemName, 0);
  1111|     if (continueSem == SEM_FAILED)
  1112|     {
  1113|         ASSERT("sem_open(%s) failed: %d (%s)\n", continueSemName, errno, strerror(errno));
  1114|         goto exit;
  1115|     }
  1116|     if (sem_post(startupSem) != 0)
  1117|     {
  1118|         ASSERT("sem_post(startupSem) failed: errno is %d (%s)\n", errno, strerror(errno));
  1119|         goto exit;
  1120|     }
  1121|     while (sem_wait(continueSem) != 0)
  1122|     {
  1123|         if (EINTR == errno)
  1124|         {
  1125|             TRACE("sem_wait() failed with EINTR; re-waiting");
  1126|             continue;
  1127|         }
  1128|         ASSERT("sem_wait(continueSem) failed: errno is %d (%s)\n", errno, strerror(errno));
  1129|         goto exit;
  1130|     }
  1131|     launched = TRUE;
  1132| exit:
  1133|     if (startupSem != SEM_FAILED)
  1134|     {
  1135|         sem_close(startupSem);
  1136|     }
  1137|     if (continueSem != SEM_FAILED)
  1138|     {
  1139|         sem_close(continueSem);
  1140|     }
  1141|     return launched;
  1142| }
  1143| LPCSTR
  1144| PALAPI
  1145| PAL_GetApplicationGroupId()
  1146| {
  1147| #ifdef __APPLE__
  1148|     return gApplicationGroupId;
  1149| #else
  1150|     return nullptr;
  1151| #endif
  1152| }
  1153| #ifdef __APPLE__
  1154| constexpr int GetExtraEncodedAreaSize(UINT rawByteCount)
  1155| {
  1156|     return (rawByteCount+6)/7;
  1157| }
  1158| const int SEMAPHORE_ENCODED_NAME_EXTRA_LENGTH = GetExtraEncodedAreaSize(sizeof(UnambiguousProcessDescriptor));
  1159| const int SEMAPHORE_ENCODED_NAME_LENGTH =
  1160|     sizeof(UnambiguousProcessDescriptor) + /* For process ID + disambiguationKey */
  1161|     SEMAPHORE_ENCODED_NAME_EXTRA_LENGTH; /* For base 255 extra encoding space */
  1162| static_assert_no_msg(MAX_APPLICATION_GROUP_ID_LENGTH
  1163|     + 1 /* For / */
  1164|     + 2 /* For ST/CO name prefix */
  1165|     + SEMAPHORE_ENCODED_NAME_LENGTH /* For encoded name string */
  1166|     + 1 /* For null terminator */
  1167|     <= CLR_SEM_MAX_NAMELEN);
  1168| void EncodeSemaphoreName(char *encodedSemName, const UnambiguousProcessDescriptor& unambiguousProcessDescriptor)
  1169| {
  1170|     const unsigned char *buffer = (const unsigned char *)&unambiguousProcessDescriptor;
  1171|     char *extraEncodingBits = encodedSemName + sizeof(UnambiguousProcessDescriptor);
  1172|     for (int i=0; i<SEMAPHORE_ENCODED_NAME_EXTRA_LENGTH; i++)
  1173|     {
  1174|         extraEncodingBits[i] = 0x80;
  1175|     }
  1176|     for (int i=0; i<sizeof(UnambiguousProcessDescriptor); i++)
  1177|     {
  1178|         unsigned char b = buffer[i];
  1179|         encodedSemName[i] = b ? b : 1;
  1180|         extraEncodingBits[i/7] |= (b ? 0 : 1) << (i%7);
  1181|     }
  1182| }
  1183| #endif
  1184| void CreateSemaphoreName(char semName[CLR_SEM_MAX_NAMELEN], LPCSTR semaphoreName, const UnambiguousProcessDescriptor& unambiguousProcessDescriptor, LPCSTR applicationGroupId)
  1185| {
  1186|     int length = 0;
  1187| #ifdef __APPLE__
  1188|     if (applicationGroupId != nullptr)
  1189|     {
  1190|         length = sprintf_s(semName, CLR_SEM_MAX_NAMELEN, "%s/%s", applicationGroupId, semaphoreName);
  1191|         _ASSERTE(length > 0 && length < CLR_SEM_MAX_NAMELEN);
  1192|         EncodeSemaphoreName(semName+length, unambiguousProcessDescriptor);
  1193|         length += SEMAPHORE_ENCODED_NAME_LENGTH;
  1194|         semName[length] = 0;
  1195|     }
  1196|     else
  1197| #endif // __APPLE__
  1198|     {
  1199|         length = sprintf_s(
  1200|             semName,
  1201|             CLR_SEM_MAX_NAMELEN,
  1202|             RuntimeSemaphoreNameFormat,
  1203|             semaphoreName,
  1204|             HashSemaphoreName(unambiguousProcessDescriptor.m_processId, unambiguousProcessDescriptor.m_disambiguationKey));
  1205|     }
  1206|     _ASSERTE(length > 0 && length < CLR_SEM_MAX_NAMELEN );
  1207| }
  1208| /*++
  1209|  Function:
  1210|   GetProcessIdDisambiguationKey
  1211|   Get a numeric value that can be used to disambiguate between processes with the same PID,
  1212|   provided that one of them is still running. The numeric value can mean different things
  1213|   on different platforms, so it should not be used for any other purpose. Under the hood,
  1214|   it is implemented based on the creation time of the process.
  1215| --*/
  1216| BOOL
  1217| GetProcessIdDisambiguationKey(DWORD processId, UINT64 *disambiguationKey)
  1218| {
  1219|     if (disambiguationKey == nullptr)
  1220|     {
  1221|         _ASSERTE(!"disambiguationKey argument cannot be null!");
  1222|         return FALSE;
  1223|     }
  1224|     *disambiguationKey = 0;
  1225| #if defined(__APPLE__) || defined(__FreeBSD__)
  1226|     struct kinfo_proc info = {};
  1227|     size_t size = sizeof(info);
  1228|     int mib[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PID, processId };
  1229|     int ret = ::sysctl(mib, sizeof(mib)/sizeof(*mib), &info, &size, nullptr, 0);
  1230|     if (ret == 0)
  1231|     {
  1232| #if defined(__APPLE__)
  1233|         timeval procStartTime = info.kp_proc.p_starttime;
  1234| #else // __FreeBSD__
  1235|         timeval procStartTime = info.ki_start;
  1236| #endif
  1237|         long secondsSinceEpoch = procStartTime.tv_sec;
  1238|         *disambiguationKey = secondsSinceEpoch;
  1239|         return TRUE;
  1240|     }
  1241|     else
  1242|     {
  1243|         _ASSERTE(!"Failed to get start time of a process.");
  1244|         return FALSE;
  1245|     }
  1246| #elif defined(__NetBSD__)
  1247|     kvm_t *kd;
  1248|     int cnt;
  1249|     struct kinfo_proc2 *info;
  1250|     kd = kvm_open(nullptr, nullptr, nullptr, KVM_NO_FILES, "kvm_open");
  1251|     if (kd == nullptr)
  1252|     {
  1253|         _ASSERTE(!"Failed to get start time of a process.");
  1254|         return FALSE;
  1255|     }
  1256|     info = kvm_getproc2(kd, KERN_PROC_PID, processId, sizeof(struct kinfo_proc2), &cnt);
  1257|     if (info == nullptr || cnt < 1)
  1258|     {
  1259|         kvm_close(kd);
  1260|         _ASSERTE(!"Failed to get start time of a process.");
  1261|         return FALSE;
  1262|     }
  1263|     kvm_close(kd);
  1264|     long secondsSinceEpoch = info->p_ustart_sec;
  1265|     *disambiguationKey = secondsSinceEpoch;
  1266|     return TRUE;
  1267| #elif HAVE_PROCFS_STAT
  1268|     char statFileName[64];
  1269|     INDEBUG(int chars = )
  1270|     snprintf(statFileName, sizeof(statFileName), "/proc/%d/stat", processId);
  1271|     _ASSERTE(chars > 0 && chars <= (int)sizeof(statFileName));
  1272|     FILE *statFile = fopen(statFileName, "r");
  1273|     if (statFile == nullptr)
  1274|     {
  1275|         TRACE("GetProcessIdDisambiguationKey: fopen() FAILED");
  1276|         SetLastError(ERROR_INVALID_HANDLE);
  1277|         return FALSE;
  1278|     }
  1279|     char *line = nullptr;
  1280|     size_t lineLen = 0;
  1281|     if (getline(&line, &lineLen, statFile) == -1)
  1282|     {
  1283|         TRACE("GetProcessIdDisambiguationKey: getline() FAILED");
  1284|         SetLastError(ERROR_INVALID_HANDLE);
  1285|         return FALSE;
  1286|     }
  1287|     unsigned long long starttime;
  1288|     char *scanStartPosition = strrchr(line, ')') + 2;
  1289|     int sscanfRet = sscanf_s(scanStartPosition,
  1290|         "%*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u %*u %*u %*d %*d %*d %*d %*d %*d %llu \n",
  1291|          &starttime);
  1292|     if (sscanfRet != 1)
  1293|     {
  1294|         _ASSERTE(!"Failed to parse stat file contents with sscanf_s.");
  1295|         return FALSE;
  1296|     }
  1297|     free(line);
  1298|     fclose(statFile);
  1299|     *disambiguationKey = starttime;
  1300|     return TRUE;
  1301| #else
  1302|     WARN("GetProcessIdDisambiguationKey was called but is not implemented on this platform!");
  1303|     return FALSE;
  1304| #endif
  1305| }
  1306| /*++
  1307|  Function:
  1308|   PAL_GetTransportName
  1309|   Builds the transport IPC names from the process id.
  1310| --*/
  1311| VOID
  1312| PALAPI
  1313| PAL_GetTransportName(
  1314|     const unsigned int MAX_TRANSPORT_NAME_LENGTH,
  1315|     OUT char *name,
  1316|     IN const char *prefix,
  1317|     IN DWORD id,
  1318|     IN const char *applicationGroupId,
  1319|     IN const char *suffix)
  1320| {
  1321|     *name = '\0';
  1322|     DWORD dwRetVal = 0;
  1323|     UINT64 disambiguationKey = 0;
  1324|     PathCharString formatBufferString;
  1325|     BOOL ret = GetProcessIdDisambiguationKey(id, &disambiguationKey);
  1326|     char *formatBuffer = formatBufferString.OpenStringBuffer(MAX_TRANSPORT_NAME_LENGTH-1);
  1327|     if (formatBuffer == nullptr)
  1328|     {
  1329|         ERROR("Out Of Memory");
  1330|         return;
  1331|     }
  1332|     _ASSERTE(ret == TRUE || disambiguationKey == 0);
  1333| #ifdef __APPLE__
  1334|     if (nullptr != applicationGroupId)
  1335|     {
  1336|         int applicationGroupIdLength = strlen(applicationGroupId);
  1337|         if (applicationGroupIdLength > MAX_APPLICATION_GROUP_ID_LENGTH)
  1338|         {
  1339|             ERROR("The length of applicationGroupId is larger than MAX_APPLICATION_GROUP_ID_LENGTH");
  1340|             return;
  1341|         }
  1342|         if (!GetApplicationContainerFolder(formatBufferString, applicationGroupId, applicationGroupIdLength))
  1343|         {
  1344|             ERROR("Out Of Memory");
  1345|             return;
  1346|         }
  1347|         if (formatBufferString.GetCount() >= MAX_TRANSPORT_NAME_LENGTH)
  1348|         {
  1349|             ERROR("GetApplicationContainerFolder returned a path that was larger than MAX_TRANSPORT_NAME_LENGTH");
  1350|             return;
  1351|         }
  1352|     }
  1353|     else
  1354| #endif // __APPLE__
  1355|     {
  1356|         dwRetVal = ::GetTempPathA(MAX_TRANSPORT_NAME_LENGTH, formatBuffer);
  1357|         if (dwRetVal == 0)
  1358|         {
  1359|             ERROR("GetTempPath failed (0x%08x)", ::GetLastError());
  1360|             return;
  1361|         }
  1362|         if (dwRetVal > MAX_TRANSPORT_NAME_LENGTH)
  1363|         {
  1364|             ERROR("GetTempPath returned a path that was larger than MAX_TRANSPORT_NAME_LENGTH");
  1365|             return;
  1366|         }
  1367|     }
  1368|     if (strncat_s(formatBuffer, MAX_TRANSPORT_NAME_LENGTH, IpcNameFormat, strlen(IpcNameFormat)) == STRUNCATE)
  1369|     {
  1370|         ERROR("TransportPipeName was larger than MAX_TRANSPORT_NAME_LENGTH");
  1371|         return;
  1372|     }
  1373|     int chars = snprintf(name, MAX_TRANSPORT_NAME_LENGTH, formatBuffer, prefix, id, disambiguationKey, suffix);
  1374|     _ASSERTE(chars > 0 && (unsigned int)chars < MAX_TRANSPORT_NAME_LENGTH);
  1375| }
  1376| /*++
  1377|  Function:
  1378|   PAL_GetTransportPipeName
  1379|   Builds the transport pipe names from the process id.
  1380| --*/
  1381| VOID
  1382| PALAPI
  1383| PAL_GetTransportPipeName(
  1384|     OUT char *name,
  1385|     IN DWORD id,
  1386|     IN const char *applicationGroupId,
  1387|     IN const char *suffix)
  1388| {
  1389|     PAL_GetTransportName(
  1390|         MAX_DEBUGGER_TRANSPORT_PIPE_NAME_LENGTH,
  1391|         name,
  1392|         TwoWayNamedPipePrefix,
  1393|         id,
  1394|         applicationGroupId,
  1395|         suffix);
  1396| }
  1397| /*++
  1398| Function:
  1399|   GetProcessTimes
  1400| See MSDN doc.
  1401| --*/
  1402| BOOL
  1403| PALAPI
  1404| GetProcessTimes(
  1405|         IN HANDLE hProcess,
  1406|         OUT LPFILETIME lpCreationTime,
  1407|         OUT LPFILETIME lpExitTime,
  1408|         OUT LPFILETIME lpKernelTime,
  1409|         OUT LPFILETIME lpUserTime)
  1410| {
  1411|     BOOL retval = FALSE;
  1412|     struct rusage resUsage;
  1413|     UINT64 calcTime;
  1414|     const UINT64 SECS_TO_100NS = 10000000ULL;  // 10^7
  1415|     const UINT64 USECS_TO_100NS = 10ULL;       // 10
  1416|     const UINT64 EPOCH_DIFF = 11644473600ULL;  // number of seconds from 1 Jan. 1601 00:00 to 1 Jan 1970 00:00 UTC
  1417|     PERF_ENTRY(GetProcessTimes);
  1418|     ENTRY("GetProcessTimes(hProcess=%p, lpExitTime=%p, lpKernelTime=%p,"
  1419|           "lpUserTime=%p)\n",
  1420|           hProcess, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime );
  1421|     /* Make sure hProcess is the current process, this is the only supported
  1422|        case */
  1423|     if(PROCGetProcessIDFromHandle(hProcess)!=GetCurrentProcessId())
  1424|     {
  1425|         ASSERT("GetProcessTimes() does not work on a process other than the "
  1426|               "current process.\n");
  1427|         SetLastError(ERROR_INVALID_HANDLE);
  1428|         goto GetProcessTimesExit;
  1429|     }
  1430|     /* First, we need to actually retrieve the relevant statistics from the
  1431|        OS */
  1432|     if (getrusage (RUSAGE_SELF, &resUsage) == -1)
  1433|     {
  1434|         ASSERT("Unable to get resource usage information for the current "
  1435|               "process\n");
  1436|         SetLastError(ERROR_INTERNAL_ERROR);
  1437|         goto GetProcessTimesExit;
  1438|     }
  1439|     TRACE ("getrusage User: %ld sec,%ld microsec. Kernel: %ld sec,%ld"
  1440|            " microsec\n",
  1441|            resUsage.ru_utime.tv_sec, resUsage.ru_utime.tv_usec,
  1442|            resUsage.ru_stime.tv_sec, resUsage.ru_stime.tv_usec);
  1443|     if (lpCreationTime)
  1444|     {
  1445|         struct timeval tv;
  1446|         if (gettimeofday(&tv, NULL) == -1)
  1447|         {
  1448|             ASSERT("gettimeofday() failed; errno is %d (%s)\n", errno, strerror(errno));
  1449|             lpCreationTime->dwLowDateTime = 0;
  1450|             lpCreationTime->dwHighDateTime = 0;
  1451|         }
  1452|         else
  1453|         {
  1454|             calcTime = EPOCH_DIFF;
  1455|             calcTime += (UINT64)tv.tv_sec;
  1456|             calcTime *= SECS_TO_100NS;
  1457|             calcTime += ((UINT64)tv.tv_usec * USECS_TO_100NS);
  1458|             lpCreationTime->dwLowDateTime = (DWORD)calcTime;
  1459|             lpCreationTime->dwHighDateTime = (DWORD)(calcTime >> 32);
  1460|         }
  1461|     }
  1462|     if (lpExitTime)
  1463|     {
  1464|         lpExitTime->dwLowDateTime = 0;
  1465|         lpExitTime->dwHighDateTime = 0;
  1466|     }
  1467|     if (lpUserTime)
  1468|     {
  1469|         /* Get the time of user mode execution, in 100s of nanoseconds */
  1470|         calcTime = (UINT64)resUsage.ru_utime.tv_sec * SECS_TO_100NS;
  1471|         calcTime += (UINT64)resUsage.ru_utime.tv_usec * USECS_TO_100NS;
  1472|         /* Assign the time into lpUserTime */
  1473|         lpUserTime->dwLowDateTime = (DWORD)calcTime;
  1474|         lpUserTime->dwHighDateTime = (DWORD)(calcTime >> 32);
  1475|     }
  1476|     if (lpKernelTime)
  1477|     {
  1478|         /* Get the time of kernel mode execution, in 100s of nanoseconds */
  1479|         calcTime = (UINT64)resUsage.ru_stime.tv_sec * SECS_TO_100NS;
  1480|         calcTime += (UINT64)resUsage.ru_stime.tv_usec * USECS_TO_100NS;
  1481|         /* Assign the time into lpUserTime */
  1482|         lpKernelTime->dwLowDateTime = (DWORD)calcTime;
  1483|         lpKernelTime->dwHighDateTime = (DWORD)(calcTime >> 32);
  1484|     }
  1485|     retval = TRUE;
  1486| GetProcessTimesExit:
  1487|     LOGEXIT("GetProcessTimes returns BOOL %d\n", retval);
  1488|     PERF_EXIT(GetProcessTimes);
  1489|     return (retval);
  1490| }
  1491| #define FILETIME_TO_ULONGLONG(f) \
  1492|     (((ULONGLONG)(f).dwHighDateTime << 32) | ((ULONGLONG)(f).dwLowDateTime))
  1493| /*++
  1494| Function:
  1495|   PAL_GetCPUBusyTime
  1496| The main purpose of this function is to compute the overall CPU utilization
  1497| for the CLR thread pool to regulate the number of I/O completion port
  1498| worker threads.
  1499| Since there is no consistent API on Unix to get the CPU utilization
  1500| from a user process, getrusage and gettimeofday are used to
  1501| compute the current process's CPU utilization instead.
  1502| This function emulates the ThreadpoolMgr::GetCPUBusyTime_NT function in
  1503| win32threadpool.cpp of the CLR.
  1504| See MSDN doc for GetSystemTimes.
  1505| --*/
  1506| INT
  1507| PALAPI
  1508| PAL_GetCPUBusyTime(
  1509|     IN OUT PAL_IOCP_CPU_INFORMATION *lpPrevCPUInfo)
  1510| {
  1511|     ULONGLONG nLastRecordedCurrentTime = 0;
  1512|     ULONGLONG nLastRecordedUserTime = 0;
  1513|     ULONGLONG nLastRecordedKernelTime = 0;
  1514|     ULONGLONG nKernelTime = 0;
  1515|     ULONGLONG nUserTime = 0;
  1516|     ULONGLONG nCurrentTime = 0;
  1517|     ULONGLONG nCpuBusyTime = 0;
  1518|     ULONGLONG nCpuTotalTime = 0;
  1519|     DWORD nReading = 0;
  1520|     struct rusage resUsage;
  1521|     struct timeval tv;
  1522|     static DWORD dwNumberOfProcessors = 0;
  1523|     if (dwNumberOfProcessors <= 0)
  1524|     {
  1525|         SYSTEM_INFO SystemInfo;
  1526|         GetSystemInfo(&SystemInfo);
  1527|         dwNumberOfProcessors = SystemInfo.dwNumberOfProcessors;
  1528|         if (dwNumberOfProcessors <= 0)
  1529|         {
  1530|             return 0;
  1531|         }
  1532|         UINT cpuLimit;
  1533|         if (PAL_GetCpuLimit(&cpuLimit) && cpuLimit < dwNumberOfProcessors)
  1534|         {
  1535|             dwNumberOfProcessors = cpuLimit;
  1536|         }
  1537|     }
  1538|     if (getrusage(RUSAGE_SELF, &resUsage) == -1)
  1539|     {
  1540|         ASSERT("getrusage() failed; errno is %d (%s)\n", errno, strerror(errno));
  1541|         return 0;
  1542|     }
  1543|     else
  1544|     {
  1545|         nKernelTime = (ULONGLONG)resUsage.ru_stime.tv_sec*tccSecondsTo100NanoSeconds +
  1546|             resUsage.ru_stime.tv_usec*tccMicroSecondsTo100NanoSeconds;
  1547|         nUserTime = (ULONGLONG)resUsage.ru_utime.tv_sec*tccSecondsTo100NanoSeconds +
  1548|             resUsage.ru_utime.tv_usec*tccMicroSecondsTo100NanoSeconds;
  1549|     }
  1550|     if (gettimeofday(&tv, NULL) == -1)
  1551|     {
  1552|         ASSERT("gettimeofday() failed; errno is %d (%s)\n", errno, strerror(errno));
  1553|         return 0;
  1554|     }
  1555|     else
  1556|     {
  1557|         nCurrentTime = (ULONGLONG)tv.tv_sec*tccSecondsTo100NanoSeconds +
  1558|             tv.tv_usec*tccMicroSecondsTo100NanoSeconds;
  1559|     }
  1560|     nLastRecordedCurrentTime = FILETIME_TO_ULONGLONG(lpPrevCPUInfo->LastRecordedTime.ftLastRecordedCurrentTime);
  1561|     nLastRecordedUserTime = FILETIME_TO_ULONGLONG(lpPrevCPUInfo->ftLastRecordedUserTime);
  1562|     nLastRecordedKernelTime = FILETIME_TO_ULONGLONG(lpPrevCPUInfo->ftLastRecordedKernelTime);
  1563|     if (nCurrentTime > nLastRecordedCurrentTime)
  1564|     {
  1565|         nCpuTotalTime = (nCurrentTime - nLastRecordedCurrentTime);
  1566| #if HAVE_THREAD_SELF || HAVE__LWP_SELF || HAVE_VM_READ
  1567|         nCpuTotalTime *= dwNumberOfProcessors;
  1568| #endif // HAVE_THREAD_SELF || HAVE__LWP_SELF || HAVE_VM_READ
  1569|     }
  1570|     if (nUserTime >= nLastRecordedUserTime &&
  1571|         nKernelTime >= nLastRecordedKernelTime)
  1572|     {
  1573|         nCpuBusyTime =
  1574|             (nUserTime - nLastRecordedUserTime)+
  1575|             (nKernelTime - nLastRecordedKernelTime);
  1576|     }
  1577|     if (nCpuTotalTime > 0 && nCpuBusyTime > 0)
  1578|     {
  1579|         nReading = (DWORD)((nCpuBusyTime*100)/nCpuTotalTime);
  1580|         TRACE("PAL_GetCPUBusyTime: nCurrentTime=%lld, nKernelTime=%lld, nUserTime=%lld, nReading=%d\n",
  1581|             nCurrentTime, nKernelTime, nUserTime, nReading);
  1582|     }
  1583|     if (nReading > 100)
  1584|     {
  1585|         ERROR("cpu utilization(%d) > 100\n", nReading);
  1586|     }
  1587|     lpPrevCPUInfo->LastRecordedTime.ftLastRecordedCurrentTime.dwLowDateTime = (DWORD)nCurrentTime;
  1588|     lpPrevCPUInfo->LastRecordedTime.ftLastRecordedCurrentTime.dwHighDateTime = (DWORD)(nCurrentTime >> 32);
  1589|     lpPrevCPUInfo->ftLastRecordedUserTime.dwLowDateTime = (DWORD)nUserTime;
  1590|     lpPrevCPUInfo->ftLastRecordedUserTime.dwHighDateTime = (DWORD)(nUserTime >> 32);
  1591|     lpPrevCPUInfo->ftLastRecordedKernelTime.dwLowDateTime = (DWORD)nKernelTime;
  1592|     lpPrevCPUInfo->ftLastRecordedKernelTime.dwHighDateTime = (DWORD)(nKernelTime >> 32);
  1593|     return (DWORD)nReading;
  1594| }
  1595| /*++
  1596| Function:
  1597|   GetCommandLineW
  1598| See MSDN doc.
  1599| --*/
  1600| LPWSTR
  1601| PALAPI
  1602| GetCommandLineW(
  1603|     VOID)
  1604| {
  1605|     PERF_ENTRY(GetCommandLineW);
  1606|     ENTRY("GetCommandLineW()\n");
  1607|     LPWSTR lpwstr = g_lpwstrCmdLine ? g_lpwstrCmdLine : (LPWSTR)W("");
  1608|     LOGEXIT("GetCommandLineW returns LPWSTR %p (%S)\n",
  1609|           g_lpwstrCmdLine,
  1610|           lpwstr);
  1611|     PERF_EXIT(GetCommandLineW);
  1612|     return lpwstr;
  1613| }
  1614| /*++
  1615| Function:
  1616|   OpenProcess
  1617| See MSDN doc.
  1618| Notes :
  1619| dwDesiredAccess is ignored (all supported operations will be allowed)
  1620| bInheritHandle is ignored (no inheritance)
  1621| --*/
  1622| HANDLE
  1623| PALAPI
  1624| OpenProcess(
  1625|         DWORD dwDesiredAccess,
  1626|         BOOL bInheritHandle,
  1627|         DWORD dwProcessId)
  1628| {
  1629|     PAL_ERROR palError;
  1630|     CPalThread *pThread;
  1631|     IPalObject *pobjProcess = NULL;
  1632|     IPalObject *pobjProcessRegistered = NULL;
  1633|     IDataLock *pDataLock;
  1634|     CProcProcessLocalData *pLocalData;
  1635|     CObjectAttributes oa;
  1636|     HANDLE hProcess = NULL;
  1637|     PERF_ENTRY(OpenProcess);
  1638|     ENTRY("OpenProcess(dwDesiredAccess=0x%08x, bInheritHandle=%d, "
  1639|           "dwProcessId = 0x%08x)\n",
  1640|           dwDesiredAccess, bInheritHandle, dwProcessId );
  1641|     pThread = InternalGetCurrentThread();
  1642|     if (0 == dwProcessId)
  1643|     {
  1644|         palError = ERROR_INVALID_PARAMETER;
  1645|         goto OpenProcessExit;
  1646|     }
  1647|     palError = g_pObjectManager->AllocateObject(
  1648|         pThread,
  1649|         &otProcess,
  1650|         &oa,
  1651|         &pobjProcess
  1652|         );
  1653|     if (NO_ERROR != palError)
  1654|     {
  1655|         goto OpenProcessExit;
  1656|     }
  1657|     palError = pobjProcess->GetProcessLocalData(
  1658|         pThread,
  1659|         WriteLock,
  1660|         &pDataLock,
  1661|         reinterpret_cast<void **>(&pLocalData)
  1662|         );
  1663|     if (NO_ERROR != palError)
  1664|     {
  1665|         goto OpenProcessExit;
  1666|     }
  1667|     pLocalData->dwProcessId = dwProcessId;
  1668|     pDataLock->ReleaseLock(pThread, TRUE);
  1669|     palError = g_pObjectManager->RegisterObject(
  1670|         pThread,
  1671|         pobjProcess,
  1672|         &aotProcess,
  1673|         &hProcess,
  1674|         &pobjProcessRegistered
  1675|         );
  1676|     pobjProcess = NULL;
  1677| OpenProcessExit:
  1678|     if (NULL != pobjProcess)
  1679|     {
  1680|         pobjProcess->ReleaseReference(pThread);
  1681|     }
  1682|     if (NULL != pobjProcessRegistered)
  1683|     {
  1684|         pobjProcessRegistered->ReleaseReference(pThread);
  1685|     }
  1686|     if (NO_ERROR != palError)
  1687|     {
  1688|         pThread->SetLastError(palError);
  1689|     }
  1690|     LOGEXIT("OpenProcess returns HANDLE %p\n", hProcess);
  1691|     PERF_EXIT(OpenProcess);
  1692|     return hProcess;
  1693| }
  1694| /*++
  1695| Function
  1696|   PROCNotifyProcessShutdown
  1697|   Calls the abort handler to do any shutdown cleanup. Call be called
  1698|   from the unhandled native exception handler.
  1699| (no return value)
  1700| --*/
  1701| VOID
  1702| PROCNotifyProcessShutdown(bool isExecutingOnAltStack)
  1703| {
  1704|     PSHUTDOWN_CALLBACK callback = InterlockedExchangePointer(&g_shutdownCallback, NULL);
  1705|     if (callback != NULL)
  1706|     {
  1707|         callback(isExecutingOnAltStack);
  1708|     }
  1709| }
  1710| /*++
  1711| Function
  1712|   PROCNotifyProcessShutdownDestructor
  1713|   Called at process exit, invokes process shutdown notification
  1714| (no return value)
  1715| --*/
  1716| __attribute__((destructor))
  1717| VOID
  1718| PROCNotifyProcessShutdownDestructor()
  1719| {
  1720|     PROCNotifyProcessShutdown(/* isExecutingOnAltStack */ false);
  1721| }
  1722| /*++
  1723| Function:
  1724|     PROCFormatInt
  1725|     Helper function to format an ULONG32 as a string.
  1726| --*/
  1727| char*
  1728| PROCFormatInt(ULONG32 value)
  1729| {
  1730|     char* buffer = (char*)InternalMalloc(128);
  1731|     if (buffer != nullptr)
  1732|     {
  1733|         if (sprintf_s(buffer, 128, "%d", value) == -1)
  1734|         {
  1735|             free(buffer);
  1736|             buffer = nullptr;
  1737|         }
  1738|     }
  1739|     return buffer;
  1740| }
  1741| /*++
  1742| Function:
  1743|     PROCFormatInt64
  1744|     Helper function to format an ULONG64 as a string.
  1745| --*/
  1746| char*
  1747| PROCFormatInt64(ULONG64 value)
  1748| {
  1749|     char* buffer = (char*)InternalMalloc(128);
  1750|     if (buffer != nullptr)
  1751|     {
  1752|         if (sprintf_s(buffer, 128, "%lld", value) == -1)
  1753|         {
  1754|             free(buffer);
  1755|             buffer = nullptr;
  1756|         }
  1757|     }
  1758|     return buffer;
  1759| }
  1760| static const INT UndefinedDumpType = 0;
  1761| /*++
  1762| Function
  1763|   PROCBuildCreateDumpCommandLine
  1764| Abstract
  1765|   Builds the createdump command line from the arguments.
  1766| Return
  1767|   TRUE - succeeds, FALSE - fails
  1768| --*/
  1769| BOOL
  1770| PROCBuildCreateDumpCommandLine(
  1771|     std::vector<const char*>& argv,
  1772|     char** pprogram,
  1773|     char** ppidarg,
  1774|     const char* dumpName,
  1775|     const char* logFileName,
  1776|     INT dumpType,
  1777|     ULONG32 flags)
  1778| {
  1779|     if (g_szCoreCLRPath == nullptr)
  1780|     {
  1781|         return FALSE;
  1782|     }
  1783|     const char* DumpGeneratorName = "createdump";
  1784|     int programLen = strlen(g_szCoreCLRPath) + strlen(DumpGeneratorName) + 1;
  1785|     char* program = *pprogram = (char*)InternalMalloc(programLen);
  1786|     if (program == nullptr)
  1787|     {
  1788|         return FALSE;
  1789|     }
  1790|     if (strcpy_s(program, programLen, g_szCoreCLRPath) != SAFECRT_SUCCESS)
  1791|     {
  1792|         return FALSE;
  1793|     }
  1794|     char *last = strrchr(program, '/');
  1795|     if (last != nullptr)
  1796|     {
  1797|         *(last + 1) = '\0';
  1798|     }
  1799|     else
  1800|     {
  1801|         program[0] = '\0';
  1802|     }
  1803|     if (strcat_s(program, programLen, DumpGeneratorName) != SAFECRT_SUCCESS)
  1804|     {
  1805|         return FALSE;
  1806|     }
  1807|     *ppidarg = PROCFormatInt(gPID);
  1808|     if (*ppidarg == nullptr)
  1809|     {
  1810|         return FALSE;
  1811|     }
  1812|     argv.push_back(program);
  1813|     if (dumpName != nullptr)
  1814|     {
  1815|         argv.push_back("--name");
  1816|         argv.push_back(dumpName);
  1817|     }
  1818|     switch (dumpType)
  1819|     {
  1820|         case 1: argv.push_back("--normal");
  1821|             break;
  1822|         case 2: argv.push_back("--withheap");
  1823|             break;
  1824|         case 3: argv.push_back("--triage");
  1825|             break;
  1826|         case 4: argv.push_back("--full");
  1827|             break;
  1828|         case UndefinedDumpType:
  1829|         default:
  1830|             break;
  1831|     }
  1832|     if (flags & GenerateDumpFlagsLoggingEnabled)
  1833|     {
  1834|         argv.push_back("--diag");
  1835|     }
  1836|     if (flags & GenerateDumpFlagsVerboseLoggingEnabled)
  1837|     {
  1838|         argv.push_back("--verbose");
  1839|     }
  1840|     if (flags & GenerateDumpFlagsCrashReportEnabled)
  1841|     {
  1842|         argv.push_back("--crashreport");
  1843|     }
  1844|     if (flags & GenerateDumpFlagsCrashReportOnlyEnabled)
  1845|     {
  1846|         argv.push_back("--crashreportonly");
  1847|     }
  1848|     if (g_running_in_exe)
  1849|     {
  1850|         argv.push_back("--singlefile");
  1851|     }
  1852|     if (logFileName != nullptr)
  1853|     {
  1854|         argv.push_back("--logtofile");
  1855|         argv.push_back(logFileName);
  1856|     }
  1857|     argv.push_back(*ppidarg);
  1858|     argv.push_back(nullptr);
  1859|     return TRUE;
  1860| }
  1861| /*++
  1862| Function:
  1863|   PROCCreateCrashDump
  1864|   Creates crash dump of the process. Can be called from the
  1865|   unhandled native exception handler.
  1866| (no return value)
  1867| --*/
  1868| BOOL
  1869| PROCCreateCrashDump(
  1870|     std::vector<const char*>& argv,
  1871|     LPSTR errorMessageBuffer,
  1872|     INT cbErrorMessageBuffer)
  1873| {
  1874|     _ASSERTE(argv.size() > 0);
  1875|     _ASSERTE(errorMessageBuffer == nullptr || cbErrorMessageBuffer > 0);
  1876|     int pipe_descs[2];
  1877|     if (pipe(pipe_descs) == -1)
  1878|     {
  1879|         if (errorMessageBuffer != nullptr)
  1880|         {
  1881|             sprintf_s(errorMessageBuffer, cbErrorMessageBuffer, "Problem launching createdump: pipe() FAILED %s (%d)\n", strerror(errno), errno);
  1882|         }
  1883|         return false;
  1884|     }
  1885|     int parent_pipe = pipe_descs[0];
  1886|     int child_pipe = pipe_descs[1];
  1887|     pid_t childpid = fork();
  1888|     if (childpid == -1)
  1889|     {
  1890|         if (errorMessageBuffer != nullptr)
  1891|         {
  1892|             sprintf_s(errorMessageBuffer, cbErrorMessageBuffer, "Problem launching createdump: fork() FAILED %s (%d)\n", strerror(errno), errno);
  1893|         }
  1894|         close(pipe_descs[0]);
  1895|         close(pipe_descs[1]);
  1896|         return false;
  1897|     }
  1898|     else if (childpid == 0)
  1899|     {
  1900|         close(parent_pipe);
  1901|         if (errorMessageBuffer != nullptr)
  1902|         {
  1903|             dup2(child_pipe, STDERR_FILENO);
  1904|         }
  1905|         if (execve(argv[0], (char**)argv.data(), palEnvironment) == -1)
  1906|         {
  1907|             fprintf(stderr, "Problem launching createdump (may not have execute permissions): execve(%s) FAILED %s (%d)\n", argv[0], strerror(errno), errno);
  1908|             exit(-1);
  1909|         }
  1910|     }
  1911|     else
  1912|     {
  1913| #if HAVE_PRCTL_H && HAVE_PR_SET_PTRACER
  1914|         if (prctl(PR_SET_PTRACER, childpid, 0, 0, 0) == -1)
  1915|         {
  1916|             ERROR("PROCCreateCrashDump: prctl() FAILED %s (%d)\n", strerror(errno), errno);
  1917|         }
  1918| #endif // HAVE_PRCTL_H && HAVE_PR_SET_PTRACER
  1919|         close(child_pipe);
  1920|         if (errorMessageBuffer != nullptr)
  1921|         {
  1922|             int bytesRead = 0;
  1923|             int count = 0;
  1924|             while ((count = read(parent_pipe, errorMessageBuffer + bytesRead, cbErrorMessageBuffer - bytesRead)) > 0)
  1925|             {
  1926|                 bytesRead += count;
  1927|             }
  1928|             errorMessageBuffer[bytesRead] = 0;
  1929|             if (bytesRead > 0)
  1930|             {
  1931|                 fputs(errorMessageBuffer, stderr);
  1932|             }
  1933|         }
  1934|         close(parent_pipe);
  1935|         int wstatus = 0;
  1936|         int result = waitpid(childpid, &wstatus, 0);
  1937|         if (result != childpid)
  1938|         {
  1939|             fprintf(stderr, "Problem waiting for createdump: waitpid() FAILED result %d wstatus %08x errno %s (%d)\n",
  1940|                 result, wstatus, strerror(errno), errno);
  1941|             return false;
  1942|         }
  1943|         else
  1944|         {
  1945| #ifdef _DEBUG
  1946|             fprintf(stderr, "[createdump] waitpid() returned successfully (wstatus %08x)\n", wstatus);
  1947| #endif
  1948|             return !WIFEXITED(wstatus) || WEXITSTATUS(wstatus) == 0;
  1949|         }
  1950|     }
  1951|     return true;
  1952| }
  1953| /*++
  1954| Function
  1955|   PROCAbortInitialize()
  1956| Abstract
  1957|   Initialize the process abort crash dump program file path and
  1958|   name. Doing all of this ahead of time so nothing is allocated
  1959|   or copied in PROCAbort/signal handler.
  1960| Return
  1961|   TRUE - succeeds, FALSE - fails
  1962| --*/
  1963| BOOL
  1964| PROCAbortInitialize()
  1965| {
  1966|     CLRConfigNoCache enabledCfg = CLRConfigNoCache::Get("DbgEnableMiniDump", /*noprefix*/ false, &getenv);
  1967|     DWORD enabled = 0;
  1968|     if (enabledCfg.IsSet() && enabledCfg.TryAsInteger(10, enabled) && enabled)
  1969|     {
  1970|         CLRConfigNoCache dmpNameCfg = CLRConfigNoCache::Get("DbgMiniDumpName", /*noprefix*/ false, &getenv);
  1971|         const char* dumpName = dmpNameCfg.IsSet() ? dmpNameCfg.AsString() : nullptr;
  1972|         CLRConfigNoCache dmpLogToFileCfg = CLRConfigNoCache::Get("CreateDumpLogToFile", /*noprefix*/ false, &getenv);
  1973|         const char* logFilePath = dmpLogToFileCfg.IsSet() ? dmpLogToFileCfg.AsString() : nullptr;
  1974|         CLRConfigNoCache dmpTypeCfg = CLRConfigNoCache::Get("DbgMiniDumpType", /*noprefix*/ false, &getenv);
  1975|         DWORD dumpType = UndefinedDumpType;
  1976|         if (dmpTypeCfg.IsSet())
  1977|         {
  1978|             (void)dmpTypeCfg.TryAsInteger(10, dumpType);
  1979|             if (dumpType < 1 || dumpType > 4)
  1980|             {
  1981|                 dumpType = UndefinedDumpType;
  1982|             }
  1983|         }
  1984|         ULONG32 flags = GenerateDumpFlagsNone;
  1985|         CLRConfigNoCache createDumpDiag = CLRConfigNoCache::Get("CreateDumpDiagnostics", /*noprefix*/ false, &getenv);
  1986|         DWORD val = 0;
  1987|         if (createDumpDiag.IsSet() && createDumpDiag.TryAsInteger(10, val) && val == 1)
  1988|         {
  1989|             flags |= GenerateDumpFlagsLoggingEnabled;
  1990|         }
  1991|         CLRConfigNoCache createDumpVerboseDiag = CLRConfigNoCache::Get("CreateDumpVerboseDiagnostics", /*noprefix*/ false, &getenv);
  1992|         val = 0;
  1993|         if (createDumpVerboseDiag.IsSet() && createDumpVerboseDiag.TryAsInteger(10, val) && val == 1)
  1994|         {
  1995|             flags |= GenerateDumpFlagsVerboseLoggingEnabled;
  1996|         }
  1997|         CLRConfigNoCache enabledReportCfg = CLRConfigNoCache::Get("EnableCrashReport", /*noprefix*/ false, &getenv);
  1998|         val = 0;
  1999|         if (enabledReportCfg.IsSet() && enabledReportCfg.TryAsInteger(10, val) && val == 1)
  2000|         {
  2001|             flags |= GenerateDumpFlagsCrashReportEnabled;
  2002|         }
  2003|         CLRConfigNoCache enabledReportOnlyCfg = CLRConfigNoCache::Get("EnableCrashReportOnly", /*noprefix*/ false, &getenv);
  2004|         val = 0;
  2005|         if (enabledReportOnlyCfg.IsSet() && enabledReportOnlyCfg.TryAsInteger(10, val) && val == 1)
  2006|         {
  2007|             flags |= GenerateDumpFlagsCrashReportOnlyEnabled;
  2008|         }
  2009|         char* program = nullptr;
  2010|         char* pidarg = nullptr;
  2011|         if (!PROCBuildCreateDumpCommandLine(g_argvCreateDump, &program, &pidarg, dumpName, logFilePath, dumpType, flags))
  2012|         {
  2013|             return FALSE;
  2014|         }
  2015|     }
  2016|     return TRUE;
  2017| }
  2018| /*++
  2019| Function:
  2020|   PAL_GenerateCoreDump
  2021| Abstract:
  2022|   Public entry point to create a crash dump of the process.
  2023| Parameters:
  2024|     dumpName
  2025|     dumpType:
  2026|         Normal = 1,
  2027|         WithHeap = 2,
  2028|         Triage = 3,
  2029|         Full = 4
  2030|     flags
  2031|         See enum
  2032| Return:
  2033|     TRUE success
  2034|     FALSE failed
  2035| --*/
  2036| BOOL
  2037| PAL_GenerateCoreDump(
  2038|     LPCSTR dumpName,
  2039|     INT dumpType,
  2040|     ULONG32 flags,
  2041|     LPSTR errorMessageBuffer,
  2042|     INT cbErrorMessageBuffer)
  2043| {
  2044|     std::vector<const char*> argvCreateDump;
  2045|     if (dumpType < 1 || dumpType > 4)
  2046|     {
  2047|         return FALSE;
  2048|     }
  2049|     if (dumpName != nullptr && dumpName[0] == '\0')
  2050|     {
  2051|         dumpName = nullptr;
  2052|     }
  2053|     char* program = nullptr;
  2054|     char* pidarg = nullptr;
  2055|     BOOL result = PROCBuildCreateDumpCommandLine(argvCreateDump, &program, &pidarg, dumpName, nullptr, dumpType, flags);
  2056|     if (result)
  2057|     {
  2058|         result = PROCCreateCrashDump(argvCreateDump, errorMessageBuffer, cbErrorMessageBuffer);
  2059|     }
  2060|     free(program);
  2061|     free(pidarg);
  2062|     return result;
  2063| }
  2064| /*++
  2065| Function:
  2066|   PROCCreateCrashDumpIfEnabled
  2067|   Creates crash dump of the process (if enabled). Can be
  2068|   called from the unhandled native exception handler.
  2069| Parameters:
  2070|   signal - POSIX signal number
  2071| (no return value)
  2072| --*/
  2073| VOID
  2074| PROCCreateCrashDumpIfEnabled(int signal, siginfo_t* siginfo)
  2075| {
  2076|     if (!g_argvCreateDump.empty())
  2077|     {
  2078|         std::vector<const char*> argv(g_argvCreateDump);
  2079|         char* signalArg = nullptr;
  2080|         char* crashThreadArg = nullptr;
  2081|         char* signalCodeArg = nullptr;
  2082|         char* signalErrnoArg = nullptr;
  2083|         char* signalAddressArg = nullptr;
  2084|         if (signal != 0)
  2085|         {
  2086|             argv.pop_back();
  2087|             signalArg = PROCFormatInt(signal);
  2088|             if (signalArg != nullptr)
  2089|             {
  2090|                 argv.push_back("--signal");
  2091|                 argv.push_back(signalArg);
  2092|             }
  2093|             crashThreadArg = PROCFormatInt(THREADSilentGetCurrentThreadId());
  2094|             if (crashThreadArg != nullptr)
  2095|             {
  2096|                 argv.push_back("--crashthread");
  2097|                 argv.push_back(crashThreadArg);
  2098|             }
  2099|             if (siginfo != nullptr)
  2100|             {
  2101|                 signalCodeArg = PROCFormatInt(siginfo->si_code);
  2102|                 if (signalCodeArg != nullptr)
  2103|                 {
  2104|                     argv.push_back("--code");
  2105|                     argv.push_back(signalCodeArg);
  2106|                 }
  2107|                 signalErrnoArg = PROCFormatInt(siginfo->si_errno);
  2108|                 if (signalErrnoArg != nullptr)
  2109|                 {
  2110|                     argv.push_back("--errno");
  2111|                     argv.push_back(signalErrnoArg);
  2112|                 }
  2113|                 signalAddressArg = PROCFormatInt64((ULONG64)siginfo->si_addr);
  2114|                 if (signalAddressArg != nullptr)
  2115|                 {
  2116|                     argv.push_back("--address");
  2117|                     argv.push_back(signalAddressArg);
  2118|                 }
  2119|             }
  2120|             argv.push_back(nullptr);
  2121|         }
  2122|         PROCCreateCrashDump(argv, nullptr, 0);
  2123|         free(signalArg);
  2124|         free(crashThreadArg);
  2125|         free(signalCodeArg);
  2126|         free(signalErrnoArg);
  2127|         free(signalAddressArg);
  2128|     }
  2129| }
  2130| /*++
  2131| Function:
  2132|   PROCAbort()
  2133|   Aborts the process after calling the shutdown cleanup handler. This function
  2134|   should be called instead of calling abort() directly.
  2135| Parameters:
  2136|   signal - POSIX signal number
  2137|   Does not return
  2138| --*/
  2139| PAL_NORETURN
  2140| VOID
  2141| PROCAbort(int signal, siginfo_t* siginfo)
  2142| {
  2143|     PROCNotifyProcessShutdown();
  2144|     PROCCreateCrashDumpIfEnabled(signal, siginfo);
  2145|     SEHCleanupSignals();
  2146|     abort();
  2147| }
  2148| /*++
  2149| Function:
  2150|   InitializeFlushProcessWriteBuffers
  2151| Abstract
  2152|   This function initializes data structures needed for the FlushProcessWriteBuffers
  2153| Return
  2154|   TRUE if it succeeded, FALSE otherwise
  2155| --*/
  2156| BOOL
  2157| InitializeFlushProcessWriteBuffers()
  2158| {
  2159|     _ASSERTE(s_helperPage == 0);
  2160|     _ASSERTE(s_flushUsingMemBarrier == 0);
  2161|     int mask = membarrier(MEMBARRIER_CMD_QUERY, 0);
  2162|     if (mask >= 0 &&
  2163|         mask & MEMBARRIER_CMD_PRIVATE_EXPEDITED)
  2164|     {
  2165|         if (membarrier(MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED, 0) == 0)
  2166|         {
  2167|             s_flushUsingMemBarrier = TRUE;
  2168|             return TRUE;
  2169|         }
  2170|     }
  2171| #ifdef TARGET_OSX
  2172|     return TRUE;
  2173| #else
  2174|     s_helperPage = static_cast<int*>(mmap(0, GetVirtualPageSize(), PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0));
  2175|     if(s_helperPage == MAP_FAILED)
  2176|     {
  2177|         return FALSE;
  2178|     }
  2179|     _ASSERTE((((SIZE_T)s_helperPage) & (GetVirtualPageSize() - 1)) == 0);
  2180|     int status = mlock(s_helperPage, GetVirtualPageSize());
  2181|     if (status != 0)
  2182|     {
  2183|         return FALSE;
  2184|     }
  2185|     status = pthread_mutex_init(&flushProcessWriteBuffersMutex, NULL);
  2186|     if (status != 0)
  2187|     {
  2188|         munlock(s_helperPage, GetVirtualPageSize());
  2189|     }
  2190|     return status == 0;
  2191| #endif // TARGET_OSX
  2192| }
  2193| #define FATAL_ASSERT(e, msg) \
  2194|     do \
  2195|     { \
  2196|         if (!(e)) \
  2197|         { \
  2198|             fprintf(stderr, "FATAL ERROR: " msg); \
  2199|             PROCAbort(); \
  2200|         } \
  2201|     } \
  2202|     while(0)
  2203| /*++
  2204| Function:
  2205|   FlushProcessWriteBuffers
  2206| See MSDN doc.
  2207| --*/
  2208| VOID
  2209| PALAPI
  2210| FlushProcessWriteBuffers()
  2211| {
  2212|     if (s_flushUsingMemBarrier)
  2213|     {
  2214|         int status = membarrier(MEMBARRIER_CMD_PRIVATE_EXPEDITED, 0);
  2215|         FATAL_ASSERT(status == 0, "Failed to flush using membarrier");
  2216|     }
  2217|     else if (s_helperPage != 0)
  2218|     {
  2219|         int status = pthread_mutex_lock(&flushProcessWriteBuffersMutex);
  2220|         FATAL_ASSERT(status == 0, "Failed to lock the flushProcessWriteBuffersMutex lock");
  2221|         status = mprotect(s_helperPage, GetVirtualPageSize(), PROT_READ | PROT_WRITE);
  2222|         FATAL_ASSERT(status == 0, "Failed to change helper page protection to read / write");
  2223|         InterlockedIncrement(s_helperPage);
  2224|         status = mprotect(s_helperPage, GetVirtualPageSize(), PROT_NONE);
  2225|         FATAL_ASSERT(status == 0, "Failed to change helper page protection to no access");
  2226|         status = pthread_mutex_unlock(&flushProcessWriteBuffersMutex);
  2227|         FATAL_ASSERT(status == 0, "Failed to unlock the flushProcessWriteBuffersMutex lock");
  2228|     }
  2229| #ifdef TARGET_OSX
  2230|     else
  2231|     {
  2232|         mach_msg_type_number_t cThreads;
  2233|         thread_act_t *pThreads;
  2234|         kern_return_t machret = task_threads(mach_task_self(), &pThreads, &cThreads);
  2235|         CHECK_MACH("task_threads()", machret);
  2236|         uintptr_t sp;
  2237|         uintptr_t registerValues[128];
  2238|         for (mach_msg_type_number_t i = 0; i < cThreads; i++)
  2239|         {
  2240|             size_t registers = 128;
  2241|             machret = thread_get_register_pointer_values(pThreads[i], &sp, &registers, registerValues);
  2242|             if (machret == KERN_INSUFFICIENT_BUFFER_SIZE)
  2243|             {
  2244|                 CHECK_MACH("thread_get_register_pointer_values()", machret);
  2245|             }
  2246|             machret = mach_port_deallocate(mach_task_self(), pThreads[i]);
  2247|             CHECK_MACH("mach_port_deallocate()", machret);
  2248|         }
  2249|         machret = vm_deallocate(mach_task_self(), (vm_address_t)pThreads, cThreads * sizeof(thread_act_t));
  2250|         CHECK_MACH("vm_deallocate()", machret);
  2251|     }
  2252| #endif // TARGET_OSX
  2253| }
  2254| /*++
  2255| Function:
  2256|   PROCGetProcessIDFromHandle
  2257| Abstract
  2258|   Return the process ID from a process handle
  2259| Parameter
  2260|   hProcess:  process handle
  2261| Return
  2262|   Return the process ID, or 0 if it's not a valid handle
  2263| --*/
  2264| DWORD
  2265| PROCGetProcessIDFromHandle(
  2266|         HANDLE hProcess)
  2267| {
  2268|     PAL_ERROR palError;
  2269|     IPalObject *pobjProcess = NULL;
  2270|     CPalThread *pThread = InternalGetCurrentThread();
  2271|     DWORD dwProcessId = 0;
  2272|     if (hPseudoCurrentProcess == hProcess)
  2273|     {
  2274|         dwProcessId = gPID;
  2275|         goto PROCGetProcessIDFromHandleExit;
  2276|     }
  2277|     palError = g_pObjectManager->ReferenceObjectByHandle(
  2278|         pThread,
  2279|         hProcess,
  2280|         &aotProcess,
  2281|         &pobjProcess
  2282|         );
  2283|     if (NO_ERROR == palError)
  2284|     {
  2285|         IDataLock *pDataLock;
  2286|         CProcProcessLocalData *pLocalData;
  2287|         palError = pobjProcess->GetProcessLocalData(
  2288|             pThread,
  2289|             ReadLock,
  2290|             &pDataLock,
  2291|             reinterpret_cast<void **>(&pLocalData)
  2292|             );
  2293|         if (NO_ERROR == palError)
  2294|         {
  2295|             dwProcessId = pLocalData->dwProcessId;
  2296|             pDataLock->ReleaseLock(pThread, FALSE);
  2297|         }
  2298|         pobjProcess->ReleaseReference(pThread);
  2299|     }
  2300| PROCGetProcessIDFromHandleExit:
  2301|     return dwProcessId;
  2302| }
  2303| PAL_ERROR
  2304| CorUnix::InitializeProcessData(
  2305|     void
  2306|     )
  2307| {
  2308|     PAL_ERROR palError = NO_ERROR;
  2309|     bool fLockInitialized = FALSE;
  2310|     pGThreadList = NULL;
  2311|     g_dwThreadCount = 0;
  2312|     InternalInitializeCriticalSection(&g_csProcess);
  2313|     fLockInitialized = TRUE;
  2314|     if (NO_ERROR != palError)
  2315|     {
  2316|         if (fLockInitialized)
  2317|         {
  2318|             InternalDeleteCriticalSection(&g_csProcess);
  2319|         }
  2320|     }
  2321|     return palError;
  2322| }
  2323| /*++
  2324| Function
  2325|     InitializeProcessCommandLine
  2326| Abstract
  2327|     Initializes (or re-initializes) the saved command line and exe path.
  2328| Parameter
  2329|     lpwstrCmdLine
  2330|     lpwstrFullPath
  2331| Return
  2332|     PAL_ERROR
  2333| Notes
  2334|     This function takes ownership of lpwstrCmdLine, but not of lpwstrFullPath
  2335| --*/
  2336| PAL_ERROR
  2337| CorUnix::InitializeProcessCommandLine(
  2338|     LPWSTR lpwstrCmdLine,
  2339|     LPWSTR lpwstrFullPath
  2340| )
  2341| {
  2342|     PAL_ERROR palError = NO_ERROR;
  2343|     LPWSTR initial_dir = NULL;
  2344|     if (lpwstrFullPath)
  2345|     {
  2346|         LPWSTR lpwstr = PAL_wcsrchr(lpwstrFullPath, '/');
  2347|         lpwstr[0] = '\0';
  2348|         size_t n = PAL_wcslen(lpwstrFullPath) + 1;
  2349|         size_t iLen = n;
  2350|         initial_dir = reinterpret_cast<LPWSTR>(InternalMalloc(iLen*sizeof(WCHAR)));
  2351|         if (NULL == initial_dir)
  2352|         {
  2353|             ERROR("malloc() failed! (initial_dir) \n");
  2354|             palError = ERROR_NOT_ENOUGH_MEMORY;
  2355|             goto exit;
  2356|         }
  2357|         if (wcscpy_s(initial_dir, iLen, lpwstrFullPath) != SAFECRT_SUCCESS)
  2358|         {
  2359|             ERROR("wcscpy_s failed!\n");
  2360|             free(initial_dir);
  2361|             palError = ERROR_INTERNAL_ERROR;
  2362|             goto exit;
  2363|         }
  2364|         lpwstr[0] = '/';
  2365|         free(g_lpwstrAppDir);
  2366|         g_lpwstrAppDir = initial_dir;
  2367|     }
  2368|     free(g_lpwstrCmdLine);
  2369|     g_lpwstrCmdLine = lpwstrCmdLine;
  2370| exit:
  2371|     return palError;
  2372| }
  2373| /*++
  2374| Function:
  2375|   CreateInitialProcessAndThreadObjects
  2376| Abstract
  2377|   Creates the IPalObjects that represent the current process
  2378|   and the initial thread
  2379| Parameter
  2380|   pThread - the initial thread
  2381| Return
  2382|   PAL_ERROR
  2383| --*/
  2384| PAL_ERROR
  2385| CorUnix::CreateInitialProcessAndThreadObjects(
  2386|     CPalThread *pThread
  2387|     )
  2388| {
  2389|     PAL_ERROR palError = NO_ERROR;
  2390|     HANDLE hThread;
  2391|     IPalObject *pobjProcess = NULL;
  2392|     IDataLock *pDataLock;
  2393|     CProcProcessLocalData *pLocalData;
  2394|     CObjectAttributes oa;
  2395|     HANDLE hProcess;
  2396|     palError = CreateThreadObject(pThread, pThread, &hThread);
  2397|     if (NO_ERROR != palError)
  2398|     {
  2399|         goto CreateInitialProcessAndThreadObjectsExit;
  2400|     }
  2401|     (void) g_pObjectManager->RevokeHandle(pThread, hThread);
  2402|     palError = g_pObjectManager->AllocateObject(
  2403|         pThread,
  2404|         &otProcess,
  2405|         &oa,
  2406|         &pobjProcess
  2407|         );
  2408|     if (NO_ERROR != palError)
  2409|     {
  2410|         ERROR("Unable to allocate process object");
  2411|         goto CreateInitialProcessAndThreadObjectsExit;
  2412|     }
  2413|     palError = pobjProcess->GetProcessLocalData(
  2414|         pThread,
  2415|         WriteLock,
  2416|         &pDataLock,
  2417|         reinterpret_cast<void **>(&pLocalData)
  2418|         );
  2419|     if (NO_ERROR != palError)
  2420|     {
  2421|         ASSERT("Unable to access local data");
  2422|         goto CreateInitialProcessAndThreadObjectsExit;
  2423|     }
  2424|     pLocalData->dwProcessId = gPID;
  2425|     pLocalData->ps = PS_RUNNING;
  2426|     pDataLock->ReleaseLock(pThread, TRUE);
  2427|     palError = g_pObjectManager->RegisterObject(
  2428|         pThread,
  2429|         pobjProcess,
  2430|         &aotProcess,
  2431|         &hProcess,
  2432|         &g_pobjProcess
  2433|         );
  2434|     pobjProcess = NULL;
  2435|     if (NO_ERROR != palError)
  2436|     {
  2437|         ASSERT("Failure registering process object");
  2438|         goto CreateInitialProcessAndThreadObjectsExit;
  2439|     }
  2440|     g_pObjectManager->RevokeHandle(pThread, hProcess);
  2441| CreateInitialProcessAndThreadObjectsExit:
  2442|     if (NULL != pobjProcess)
  2443|     {
  2444|         pobjProcess->ReleaseReference(pThread);
  2445|     }
  2446|     return palError;
  2447| }
  2448| /*++
  2449| Function:
  2450|   PROCCleanupInitialProcess
  2451| Abstract
  2452|   Cleanup all the structures for the initial process.
  2453| Parameter
  2454|   VOID
  2455| Return
  2456|   VOID
  2457| --*/
  2458| VOID
  2459| PROCCleanupInitialProcess(VOID)
  2460| {
  2461|     CPalThread *pThread = InternalGetCurrentThread();
  2462|     InternalEnterCriticalSection(pThread, &g_csProcess);
  2463|     /* Free the application directory */
  2464|     free(g_lpwstrAppDir);
  2465|     /* Free the stored command line */
  2466|     free(g_lpwstrCmdLine);
  2467|     InternalLeaveCriticalSection(pThread, &g_csProcess);
  2468| }
  2469| /*++
  2470| Function:
  2471|   PROCAddThread
  2472| Abstract
  2473|   Add a thread to the thread list of the current process
  2474| Parameter
  2475|   pThread:   Thread object
  2476| --*/
  2477| VOID
  2478| CorUnix::PROCAddThread(
  2479|     CPalThread *pCurrentThread,
  2480|     CPalThread *pTargetThread
  2481|     )
  2482| {
  2483|     /* protect the access of the thread list with critical section for
  2484|        mutithreading access */
  2485|     InternalEnterCriticalSection(pCurrentThread, &g_csProcess);
  2486|     pTargetThread->SetNext(pGThreadList);
  2487|     pGThreadList = pTargetThread;
  2488|     g_dwThreadCount += 1;
  2489|     TRACE("Thread 0x%p (id %#x) added to the process thread list\n",
  2490|           pTargetThread, pTargetThread->GetThreadId());
  2491|     InternalLeaveCriticalSection(pCurrentThread, &g_csProcess);
  2492| }
  2493| /*++
  2494| Function:
  2495|   PROCRemoveThread
  2496| Abstract
  2497|   Remove a thread form the thread list of the current process
  2498| Parameter
  2499|   CPalThread *pThread : thread object to remove
  2500| (no return value)
  2501| --*/
  2502| VOID
  2503| CorUnix::PROCRemoveThread(
  2504|     CPalThread *pCurrentThread,
  2505|     CPalThread *pTargetThread
  2506|     )
  2507| {
  2508|     CPalThread *curThread, *prevThread;
  2509|     /* protect the access of the thread list with critical section for
  2510|        mutithreading access */
  2511|     InternalEnterCriticalSection(pCurrentThread, &g_csProcess);
  2512|     curThread = pGThreadList;
  2513|     /* if thread list is empty */
  2514|     if (curThread == NULL)
  2515|     {
  2516|         ASSERT("Thread list is empty.\n");
  2517|         goto EXIT;
  2518|     }
  2519|     /* do we remove the first thread? */
  2520|     if (curThread == pTargetThread)
  2521|     {
  2522|         pGThreadList =  curThread->GetNext();
  2523|         TRACE("Thread 0x%p (id %#x) removed from the process thread list\n",
  2524|             pTargetThread, pTargetThread->GetThreadId());
  2525|         goto EXIT;
  2526|     }
  2527|     prevThread = curThread;
  2528|     curThread = curThread->GetNext();
  2529|     /* find the thread to remove */
  2530|     while (curThread != NULL)
  2531|     {
  2532|         if (curThread == pTargetThread)
  2533|         {
  2534|             /* found, fix the chain list */
  2535|             prevThread->SetNext(curThread->GetNext());
  2536|             g_dwThreadCount -= 1;
  2537|             TRACE("Thread %p removed from the process thread list\n", pTargetThread);
  2538|             goto EXIT;
  2539|         }
  2540|         prevThread = curThread;
  2541|         curThread = curThread->GetNext();
  2542|     }
  2543|     WARN("Thread %p not removed (it wasn't found in the list)\n", pTargetThread);
  2544| EXIT:
  2545|     InternalLeaveCriticalSection(pCurrentThread, &g_csProcess);
  2546| }
  2547| /*++
  2548| Function:
  2549|   PROCGetNumberOfThreads
  2550| Abstract
  2551|   Return the number of threads in the thread list.
  2552| Parameter
  2553|   void
  2554| Return
  2555|   the number of threads.
  2556| --*/
  2557| INT
  2558| CorUnix::PROCGetNumberOfThreads(
  2559|     VOID)
  2560| {
  2561|     return g_dwThreadCount;
  2562| }
  2563| /*++
  2564| Function:
  2565|   PROCProcessLock
  2566| Abstract
  2567|   Enter the critical section associated to the current process
  2568| Parameter
  2569|   void
  2570| Return
  2571|   void
  2572| --*/
  2573| VOID
  2574| PROCProcessLock(
  2575|     VOID)
  2576| {
  2577|     CPalThread * pThread =
  2578|         (PALIsThreadDataInitialized() ? InternalGetCurrentThread() : NULL);
  2579|     InternalEnterCriticalSection(pThread, &g_csProcess);
  2580| }
  2581| /*++
  2582| Function:
  2583|   PROCProcessUnlock
  2584| Abstract
  2585|   Leave the critical section associated to the current process
  2586| Parameter
  2587|   void
  2588| Return
  2589|   void
  2590| --*/
  2591| VOID
  2592| PROCProcessUnlock(
  2593|     VOID)
  2594| {
  2595|     CPalThread * pThread =
  2596|         (PALIsThreadDataInitialized() ? InternalGetCurrentThread() : NULL);
  2597|     InternalLeaveCriticalSection(pThread, &g_csProcess);
  2598| }
  2599| #if USE_SYSV_SEMAPHORES
  2600| /*++
  2601| Function:
  2602|   PROCCleanupThreadSemIds
  2603| Abstract
  2604|   Cleanup SysV semaphore ids for all threads
  2605| (no parameters, no return value)
  2606| --*/
  2607| VOID
  2608| PROCCleanupThreadSemIds(void)
  2609| {
  2610|     PROCProcessLock();
  2611|     CPalThread *pTargetThread = pGThreadList;
  2612|     while (NULL != pTargetThread)
  2613|     {
  2614|         pTargetThread->suspensionInfo.DestroySemaphoreIds();
  2615|         pTargetThread = pTargetThread->GetNext();
  2616|     }
  2617|     PROCProcessUnlock();
  2618| }
  2619| #endif // USE_SYSV_SEMAPHORES
  2620| /*++
  2621| Function:
  2622|   TerminateCurrentProcessNoExit
  2623| Abstract:
  2624|     Terminate current Process, but leave the caller alive
  2625| Parameters:
  2626|     BOOL bTerminateUnconditionally - If this is set, the PAL will exit as
  2627|     quickly as possible. In particular, it will not unload DLLs.
  2628| Return value :
  2629|     No return
  2630| Note:
  2631|   This function is used in ExitThread and TerminateProcess
  2632| --*/
  2633| VOID
  2634| CorUnix::TerminateCurrentProcessNoExit(BOOL bTerminateUnconditionally)
  2635| {
  2636|     BOOL locked;
  2637|     DWORD old_terminator;
  2638|     old_terminator = InterlockedCompareExchange(&terminator, GetCurrentThreadId(), 0);
  2639|     if (0 != old_terminator && GetCurrentThreadId() != old_terminator)
  2640|     {
  2641|         /* another thread has already initiated the termination process. we
  2642|            could just block on the PALInitLock critical section, but then
  2643|            PROCSuspendOtherThreads would hang... so sleep forever here, we're
  2644|            terminating anyway
  2645|            Update: [TODO] PROCSuspendOtherThreads has been removed. Can this
  2646|            code be changed? */
  2647|         /* note that if *this* thread has already started the termination
  2648|            process, we want to proceed. the only way this can happen is if a
  2649|            call to DllMain (from ExitProcess) brought us here (because DllMain
  2650|            called ExitProcess, or TerminateProcess, or ExitThread);
  2651|            TerminateProcess won't call DllMain, so there's no danger to get
  2652|            caught in an infinite loop */
  2653|         WARN("termination already started from another thread; blocking.\n");
  2654|         poll(NULL, 0, INFTIM);
  2655|     }
  2656|     /* Try to lock the initialization count to prevent multiple threads from
  2657|        terminating/initializing the PAL simultaneously */
  2658|     /* note : it's also important to take this lock before the process lock,
  2659|        because Init/Shutdown take the init lock, and the functions they call
  2660|        may take the process lock. We must do it in the same order to avoid
  2661|        deadlocks */
  2662|     locked = PALInitLock();
  2663|     if(locked && PALIsInitialized())
  2664|     {
  2665|         PROCNotifyProcessShutdown();
  2666|         PALCommonCleanup();
  2667|     }
  2668| }
  2669| /*++
  2670| Function:
  2671|     PROCGetProcessStatus
  2672| Abstract:
  2673|     Retrieve process state information (state & exit code).
  2674| Parameters:
  2675|     DWORD process_id : PID of process to retrieve state for
  2676|     PROCESS_STATE *state : state of process (starting, running, done)
  2677|     DWORD *exit_code : exit code of process (from ExitProcess, etc.)
  2678| Return value :
  2679|     TRUE on success
  2680| --*/
  2681| PAL_ERROR
  2682| PROCGetProcessStatus(
  2683|     CPalThread *pThread,
  2684|     HANDLE hProcess,
  2685|     PROCESS_STATE *pps,
  2686|     DWORD *pdwExitCode
  2687|     )
  2688| {
  2689|     PAL_ERROR palError = NO_ERROR;
  2690|     IPalObject *pobjProcess = NULL;
  2691|     IDataLock *pDataLock;
  2692|     CProcProcessLocalData *pLocalData;
  2693|     pid_t wait_retval;
  2694|     int status;
  2695|     palError = g_pObjectManager->ReferenceObjectByHandle(
  2696|         pThread,
  2697|         hProcess,
  2698|         &aotProcess,
  2699|         &pobjProcess
  2700|         );
  2701|     if (NO_ERROR != palError)
  2702|     {
  2703|         goto PROCGetProcessStatusExit;
  2704|     }
  2705|     palError = pobjProcess->GetProcessLocalData(
  2706|         pThread,
  2707|         WriteLock,
  2708|         &pDataLock,
  2709|         reinterpret_cast<void **>(&pLocalData)
  2710|         );
  2711|     if (PS_DONE == pLocalData->ps)
  2712|     {
  2713|         TRACE("We already called waitpid() on process ID %#x; process has "
  2714|               "terminated, exit code is %d\n",
  2715|               pLocalData->dwProcessId, pLocalData->dwExitCode);
  2716|         *pps = pLocalData->ps;
  2717|         *pdwExitCode = pLocalData->dwExitCode;
  2718|         pDataLock->ReleaseLock(pThread, FALSE);
  2719|         goto PROCGetProcessStatusExit;
  2720|     }
  2721|     /* By using waitpid(), we can even retrieve the exit code of a non-PAL
  2722|        process. However, note that waitpid() can only provide the low 8 bits
  2723|        of the exit code. This is all that is required for the PAL spec. */
  2724|     TRACE("Looking for status of process; trying wait()");
  2725|     while(1)
  2726|     {
  2727|         /* try to get state of process, using non-blocking call */
  2728|         wait_retval = waitpid(pLocalData->dwProcessId, &status, WNOHANG);
  2729|         if ( wait_retval == (pid_t) pLocalData->dwProcessId )
  2730|         {
  2731|             /* success; get the exit code */
  2732|             if ( WIFEXITED( status ) )
  2733|             {
  2734|                 *pdwExitCode = WEXITSTATUS(status);
  2735|                 TRACE("Exit code was %d\n", *pdwExitCode);
  2736|             }
  2737|             else
  2738|             {
  2739|                 WARN("process terminated without exiting; can't get exit "
  2740|                      "code. faking it.\n");
  2741|                 *pdwExitCode = EXIT_FAILURE;
  2742|             }
  2743|             *pps = PS_DONE;
  2744|         }
  2745|         else if (0 == wait_retval)
  2746|         {
  2747|             TRACE("Process %#x is still active.\n", pLocalData->dwProcessId);
  2748|             *pps = PS_RUNNING;
  2749|             *pdwExitCode = 0;
  2750|         }
  2751|         else if (-1 == wait_retval)
  2752|         {
  2753|             if (EINTR == errno)
  2754|             {
  2755|                 TRACE("waitpid() failed with EINTR; re-waiting");
  2756|                 continue;
  2757|             }
  2758|             else if (ECHILD == errno)
  2759|             {
  2760|                 TRACE("waitpid() failed with ECHILD; calling kill instead");
  2761|                 if (kill(pLocalData->dwProcessId, 0) != 0)
  2762|                 {
  2763|                     if(ESRCH == errno)
  2764|                     {
  2765|                         WARN("kill() failed with ESRCH, i.e. target "
  2766|                              "process exited and it wasn't a child, "
  2767|                              "so can't get the exit code, assuming  "
  2768|                              "it was 0.\n");
  2769|                         *pdwExitCode = 0;
  2770|                     }
  2771|                     else
  2772|                     {
  2773|                         ERROR("kill(pid, 0) failed; errno is %d (%s)\n",
  2774|                               errno, strerror(errno));
  2775|                         *pdwExitCode = EXIT_FAILURE;
  2776|                     }
  2777|                     *pps = PS_DONE;
  2778|                 }
  2779|                 else
  2780|                 {
  2781|                     *pps = PS_RUNNING;
  2782|                     *pdwExitCode = 0;
  2783|                 }
  2784|             }
  2785|             else
  2786|             {
  2787|                 ERROR("waitpid(pid=%u) failed with unexpected errno=%d (%s)\n",
  2788|                       pLocalData->dwProcessId, errno, strerror(errno));
  2789|                 *pps = PS_RUNNING;
  2790|                 *pdwExitCode = 0;
  2791|             }
  2792|         }
  2793|         else
  2794|         {
  2795|             ASSERT("waitpid returned unexpected value %d\n",wait_retval);
  2796|             *pdwExitCode = EXIT_FAILURE;
  2797|             *pps = PS_DONE;
  2798|         }
  2799|         break;
  2800|     }
  2801|     if(PS_DONE == *pps)
  2802|     {
  2803|         pLocalData->ps = PS_DONE;
  2804|         pLocalData->dwExitCode = *pdwExitCode;
  2805|     }
  2806|     TRACE( "State of process 0x%08x : %d (exit code %d)\n",
  2807|            pLocalData->dwProcessId, *pps, *pdwExitCode );
  2808|     pDataLock->ReleaseLock(pThread, TRUE);
  2809| PROCGetProcessStatusExit:
  2810|     if (NULL != pobjProcess)
  2811|     {
  2812|         pobjProcess->ReleaseReference(pThread);
  2813|     }
  2814|     return palError;
  2815| }
  2816| #ifdef __APPLE__
  2817| bool GetApplicationContainerFolder(PathCharString& buffer, const char *applicationGroupId, int applicationGroupIdLength)
  2818| {
  2819|     const char *homeDir = getpwuid(getuid())->pw_dir;
  2820|     int homeDirLength = strlen(homeDir);
  2821|     return buffer.Set(homeDir, homeDirLength)
  2822|         && buffer.Append(APPLICATION_CONTAINER_BASE_PATH_SUFFIX)
  2823|         && buffer.Append(applicationGroupId, applicationGroupIdLength)
  2824|         && buffer.Append('/');
  2825| }
  2826| #endif // __APPLE__
  2827| #ifdef _DEBUG
  2828| void PROCDumpThreadList()
  2829| {
  2830|     CPalThread *pThread;
  2831|     PROCProcessLock();
  2832|     TRACE ("Threads:{\n");
  2833|     pThread = pGThreadList;
  2834|     while (NULL != pThread)
  2835|     {
  2836|         TRACE ("    {pThr=0x%p tid=%#x lwpid=%#x state=%d finsusp=%d}\n",
  2837|                pThread, (int)pThread->GetThreadId(), (int)pThread->GetLwpId(),
  2838|                (int)pThread->synchronizationInfo.GetThreadState(),
  2839|                (int)pThread->suspensionInfo.GetSuspendedForShutdown());
  2840|         pThread = pThread->GetNext();
  2841|     }
  2842|     TRACE ("Threads:}\n");
  2843|     PROCProcessUnlock();
  2844| }
  2845| #endif
  2846| /* Internal function definitions **********************************************/
  2847| /*++
  2848| Function:
  2849|   getFileName
  2850| Abstract:
  2851|     Helper function for CreateProcessW, it retrieves the executable filename
  2852|     from the application name, and the command line.
  2853| Parameters:
  2854|     IN  lpApplicationName:  first parameter from CreateProcessW (an unicode string)
  2855|     IN  lpCommandLine: second parameter from CreateProcessW (an unicode string)
  2856|     OUT lpFileName: file to be executed (the new process)
  2857| Return:
  2858|     TRUE: if the file name is retrieved
  2859|     FALSE: otherwise
  2860| --*/
  2861| static
  2862| BOOL
  2863| getFileName(
  2864|        LPCWSTR lpApplicationName,
  2865|        LPWSTR lpCommandLine,
  2866|        PathCharString& lpPathFileName)
  2867| {
  2868|     LPWSTR lpEnd;
  2869|     WCHAR wcEnd;
  2870|     char * lpFileName;
  2871|     PathCharString lpFileNamePS;
  2872|     char *lpTemp;
  2873|     if (lpApplicationName)
  2874|     {
  2875|         int length = WideCharToMultiByte(CP_ACP, 0, lpApplicationName, -1,
  2876|                                             NULL, 0, NULL, NULL);
  2877|         /* if only a file name is specified, prefix it with "./" */
  2878|         if ((*lpApplicationName != '.') && (*lpApplicationName != '/') &&
  2879|             (*lpApplicationName != '\\'))
  2880|         {
  2881|             length += 2;
  2882|             lpTemp = lpPathFileName.OpenStringBuffer(length);
  2883|             if (strcpy_s(lpTemp, length, "./") != SAFECRT_SUCCESS)
  2884|             {
  2885|                 ERROR("strcpy_s failed!\n");
  2886|                 return FALSE;
  2887|             }
  2888|             lpTemp+=2;
  2889|        }
  2890|        else
  2891|        {
  2892|             lpTemp = lpPathFileName.OpenStringBuffer(length);
  2893|        }
  2894|         /* Convert to ASCII */
  2895|         length = WideCharToMultiByte(CP_ACP, 0, lpApplicationName, -1,
  2896|                                      lpTemp, length, NULL, NULL);
  2897|         if (length == 0)
  2898|         {
  2899|             lpPathFileName.CloseBuffer(0);
  2900|             ASSERT("WideCharToMultiByte failure\n");
  2901|             return FALSE;
  2902|         }
  2903|         lpPathFileName.CloseBuffer(length -1);
  2904|         /* Replace '\' by '/' */
  2905|         FILEDosToUnixPathA(lpTemp);
  2906|         return TRUE;
  2907|     }
  2908|     else
  2909|     {
  2910|         /* use the Command line */
  2911|         /* filename should be the first token of the command line */
  2912|         /* first skip all leading whitespace */
  2913|         lpCommandLine = UTIL_inverse_wcspbrk(lpCommandLine,W16_WHITESPACE);
  2914|         if(NULL == lpCommandLine)
  2915|         {
  2916|             ERROR("CommandLine contains only whitespace!\n");
  2917|             return FALSE;
  2918|         }
  2919|         /* check if it is starting with a quote (") character */
  2920|         if (*lpCommandLine == 0x0022)
  2921|         {
  2922|             lpCommandLine++; /* skip the quote */
  2923|             /* file name ends with another quote */
  2924|             lpEnd = PAL_wcschr(lpCommandLine+1, 0x0022);
  2925|             /* if no quotes found, set lpEnd to the end of the Command line */
  2926|             if (lpEnd == NULL)
  2927|                 lpEnd = lpCommandLine + PAL_wcslen(lpCommandLine);
  2928|         }
  2929|         else
  2930|         {
  2931|             /* filename is end out by a whitespace */
  2932|             lpEnd = PAL_wcspbrk(lpCommandLine, W16_WHITESPACE);
  2933|             /* if no whitespace found, set lpEnd to end of the Command line */
  2934|             if (lpEnd == NULL)
  2935|             {
  2936|                 lpEnd = lpCommandLine + PAL_wcslen(lpCommandLine);
  2937|             }
  2938|         }
  2939|         if (lpEnd == lpCommandLine)
  2940|         {
  2941|             ERROR("application name and command line are both empty!\n");
  2942|             return FALSE;
  2943|         }
  2944|         /* replace the last character by a null */
  2945|         wcEnd = *lpEnd;
  2946|         *lpEnd = 0x0000;
  2947|         /* Convert to ASCII */
  2948|         int size = 0;
  2949|         int length = (PAL_wcslen(lpCommandLine)+1) * sizeof(WCHAR);
  2950|         lpFileName = lpFileNamePS.OpenStringBuffer(length);
  2951|         if (NULL == lpFileName)
  2952|         {
  2953|             ERROR("Not Enough Memory!\n");
  2954|             return FALSE;
  2955|         }
  2956|         if (!(size = WideCharToMultiByte(CP_ACP, 0, lpCommandLine, -1,
  2957|                                  lpFileName, length, NULL, NULL)))
  2958|         {
  2959|             ASSERT("WideCharToMultiByte failure\n");
  2960|             return FALSE;
  2961|         }
  2962|         lpFileNamePS.CloseBuffer(size - 1);
  2963|         /* restore last character */
  2964|         *lpEnd = wcEnd;
  2965|         /* Replace '\' by '/' */
  2966|         FILEDosToUnixPathA(lpFileName);
  2967|         if (!getPath(lpFileNamePS, lpPathFileName))
  2968|         {
  2969|             /* file is not in the path */
  2970|             return FALSE;
  2971|         }
  2972|     }
  2973|     return TRUE;
  2974| }
  2975| /*++
  2976| Function:
  2977|     checkFileType
  2978| Abstract:
  2979|     Return the type of the file.
  2980| Parameters:
  2981|     IN  lpFileName:  file name
  2982| Return:
  2983|     FILE_DIR: Directory
  2984|     FILE_UNIX: Unix executable file
  2985|     FILE_ERROR: Error
  2986| --*/
  2987| static
  2988| int
  2989| checkFileType( LPCSTR lpFileName)
  2990| {
  2991|     struct stat stat_data;
  2992|     /* check if the file exist */
  2993|     if ( access(lpFileName, F_OK) != 0 )
  2994|     {
  2995|         return FILE_ERROR;
  2996|     }
  2997|     /* if it's not a PE/COFF file, check if it is executable */
  2998|     if ( -1 != stat( lpFileName, &stat_data ) )
  2999|     {
  3000|         if((stat_data.st_mode & S_IFMT) == S_IFDIR )
  3001|         {
  3002|             /*The given file is a directory*/
  3003|             return FILE_DIR;
  3004|         }
  3005|         if ( UTIL_IsExecuteBitsSet( &stat_data ) )
  3006|         {
  3007|             return FILE_UNIX;
  3008|         }
  3009|         else
  3010|         {
  3011|             return FILE_ERROR;
  3012|         }
  3013|     }
  3014|     return FILE_ERROR;
  3015| }
  3016| /*++
  3017| Function:
  3018|   buildArgv
  3019| Abstract:
  3020|     Helper function for CreateProcessW, it builds the array of argument in
  3021|     a format than can be passed to execve function.lppArgv is allocated
  3022|     in this function and must be freed by the caller.
  3023| Parameters:
  3024|     IN  lpCommandLine: second parameter from CreateProcessW (an unicode string)
  3025|     IN  lpAppPath: canonical name of the application to launched
  3026|     OUT lppArgv: array of arguments to be passed to the new process
  3027| Return:
  3028|     the number of arguments
  3029| note: this doesn't yet match precisely the behavior of Windows, but should be
  3030| sufficient.
  3031| what's here:
  3032| 1) stripping nonquoted whitespace
  3033| 2) handling of quoted parameters and quoted "parts" of parameters, removal of
  3034|    doublequotes (<aaaa"b bbb b"ccc> becomes <aaaab bbb bccc>)
  3035| 3) \" as an escaped doublequote, both within doublequoted sequences and out
  3036| what's known missing :
  3037| 1) \\ as an escaped backslash, but only if the string of '\'
  3038|    is followed by a " (escaped or not)
  3039| 2) "alternate" escape sequence : double-doublequote within a double-quoted
  3040|     argument (<"aaa a""aa aaa">) expands to a single-doublequote(<aaa a"aa aaa>)
  3041| note that there may be other special cases
  3042| --*/
  3043| static
  3044| char **
  3045| buildArgv(
  3046|       LPCWSTR lpCommandLine,
  3047|       PathCharString& lpAppPath,
  3048|       UINT *pnArg)
  3049| {
  3050|     CPalThread *pThread = NULL;
  3051|     UINT iWlen;
  3052|     char *lpAsciiCmdLine;
  3053|     char *pChar;
  3054|     char **lppArgv;
  3055|     char **lppTemp;
  3056|     UINT i,j;
  3057|     *pnArg = 0;
  3058|     iWlen = WideCharToMultiByte(CP_ACP,0,lpCommandLine,-1,NULL,0,NULL,NULL);
  3059|     if(0 == iWlen)
  3060|     {
  3061|         ASSERT("Can't determine length of command line\n");
  3062|         return NULL;
  3063|     }
  3064|     pThread = InternalGetCurrentThread();
  3065|     /* make sure to allocate enough space, up for the worst case scenario */
  3066|     int iLength = (iWlen + lpAppPath.GetCount() + 2);
  3067|     lpAsciiCmdLine = (char *) InternalMalloc(iLength);
  3068|     if (lpAsciiCmdLine == NULL)
  3069|     {
  3070|         ERROR("Unable to allocate memory\n");
  3071|         return NULL;
  3072|     }
  3073|     pChar = lpAsciiCmdLine;
  3074|     /* put the canonical name of the application as the first parameter */
  3075|     if ((strcpy_s(lpAsciiCmdLine, iLength, "\"") != SAFECRT_SUCCESS) ||
  3076|         (strcat_s(lpAsciiCmdLine, iLength, lpAppPath) != SAFECRT_SUCCESS) ||
  3077|         (strcat_s(lpAsciiCmdLine, iLength,  "\"") != SAFECRT_SUCCESS) ||
  3078|         (strcat_s(lpAsciiCmdLine, iLength, " ") != SAFECRT_SUCCESS))
  3079|     {
  3080|         ERROR("strcpy_s/strcat_s failed!\n");
  3081|         return NULL;
  3082|     }
  3083|     pChar = lpAsciiCmdLine + strlen (lpAsciiCmdLine);
  3084|     /* let's skip the first argument in the command line */
  3085|     /* strip leading whitespace; function returns NULL if there's only
  3086|         whitespace, so the if statement below will work correctly */
  3087|     lpCommandLine = UTIL_inverse_wcspbrk((LPWSTR)lpCommandLine, W16_WHITESPACE);
  3088|     if (lpCommandLine)
  3089|     {
  3090|         LPCWSTR stringstart = lpCommandLine;
  3091|         do
  3092|         {
  3093|             /* find first whitespace or dquote character */
  3094|             lpCommandLine = PAL_wcspbrk(lpCommandLine,W16_WHITESPACE_DQUOTE);
  3095|             if(NULL == lpCommandLine)
  3096|             {
  3097|                 /* no whitespace or dquote found : first arg is only arg */
  3098|                 break;
  3099|             }
  3100|             else if('"' == *lpCommandLine)
  3101|             {
  3102|                 /* got a dquote; skip over it if it's escaped; make sure we
  3103|                     don't try to look before the first character in the
  3104|                     string */
  3105|                 if(lpCommandLine > stringstart && '\\' == lpCommandLine[-1])
  3106|                 {
  3107|                     lpCommandLine++;
  3108|                     continue;
  3109|                 }
  3110|                 /* found beginning of dquoted sequence, run to the end */
  3111|                 /* don't stop if we hit an escaped dquote */
  3112|                 lpCommandLine++;
  3113|                 while( *lpCommandLine )
  3114|                 {
  3115|                     lpCommandLine = PAL_wcschr(lpCommandLine, '"');
  3116|                     if(NULL == lpCommandLine)
  3117|                     {
  3118|                         /* no ending dquote, arg runs to end of string */
  3119|                         break;
  3120|                     }
  3121|                     if('\\' != lpCommandLine[-1])
  3122|                     {
  3123|                         /* dquote is not escaped, dquoted sequence is over*/
  3124|                         break;
  3125|                     }
  3126|                     lpCommandLine++;
  3127|                 }
  3128|                 if(NULL == lpCommandLine || '\0' == *lpCommandLine)
  3129|                 {
  3130|                     /* no terminating dquote */
  3131|                     break;
  3132|                 }
  3133|                 /* step over dquote, keep looking for end of arg */
  3134|                 lpCommandLine++;
  3135|             }
  3136|             else
  3137|             {
  3138|                 /* found whitespace : end of arg. */
  3139|                 lpCommandLine++;
  3140|                 break;
  3141|             }
  3142|         }while(lpCommandLine);
  3143|     }
  3144|     /* Convert to ASCII */
  3145|     if (lpCommandLine)
  3146|     {
  3147|         if (!WideCharToMultiByte(CP_ACP, 0, lpCommandLine, -1,
  3148|                                  pChar, iWlen+1, NULL, NULL))
  3149|         {
  3150|             ASSERT("Unable to convert to a multibyte string\n");
  3151|             free(lpAsciiCmdLine);
  3152|             return NULL;
  3153|         }
  3154|     }
  3155|     pChar = lpAsciiCmdLine;
  3156|     /* loops through all the arguments, to find out how many arguments there
  3157|        are; while looping replace whitespace by \0 */
  3158|     /* skip leading whitespace (and replace by '\0') */
  3159|     /* note : there shouldn't be any, command starts either with PE loader name
  3160|        or computed application path, but this won't hurt */
  3161|     while (*pChar)
  3162|     {
  3163|         if (!isspace((unsigned char) *pChar))
  3164|         {
  3165|            break;
  3166|         }
  3167|         WARN("unexpected whitespace in command line!\n");
  3168|         *pChar++ = '\0';
  3169|     }
  3170|     while (*pChar)
  3171|     {
  3172|         (*pnArg)++;
  3173|         /* find end of current arg */
  3174|         while(*pChar && !isspace((unsigned char) *pChar))
  3175|         {
  3176|             if('"' == *pChar)
  3177|             {
  3178|                 /* skip over dquote if it's escaped; make sure we don't try to
  3179|                    look before the start of the string for the \ */
  3180|                 if(pChar > lpAsciiCmdLine && '\\' == pChar[-1])
  3181|                 {
  3182|                     pChar++;
  3183|                     continue;
  3184|                 }
  3185|                 /* found leading dquote : look for ending dquote */
  3186|                 pChar++;
  3187|                 while (*pChar)
  3188|                 {
  3189|                     pChar = strchr(pChar,'"');
  3190|                     if(NULL == pChar)
  3191|                     {
  3192|                         /* no ending dquote found : argument extends to the end
  3193|                            of the string*/
  3194|                         break;
  3195|                     }
  3196|                     if('\\' != pChar[-1])
  3197|                     {
  3198|                         /* found a dquote, and it's not escaped : quoted
  3199|                            sequence is over*/
  3200|                         break;
  3201|                     }
  3202|                     /* found a dquote, but it was escaped : skip over it, keep
  3203|                        looking */
  3204|                     pChar++;
  3205|                 }
  3206|                 if(NULL == pChar || '\0' == *pChar)
  3207|                 {
  3208|                     /* reached the end of the string : we're done */
  3209|                     break;
  3210|                 }
  3211|             }
  3212|             pChar++;
  3213|         }
  3214|         if(NULL == pChar)
  3215|         {
  3216|             /* reached the end of the string : we're done */
  3217|             break;
  3218|         }
  3219|         /* reached end of arg; replace trailing whitespace by '\0', to split
  3220|            arguments into separate strings */
  3221|         while (isspace((unsigned char) *pChar))
  3222|         {
  3223|             *pChar++ = '\0';
  3224|         }
  3225|     }
  3226|     /* allocate lppargv according to the number of arguments
  3227|        in the command line */
  3228|     lppArgv = (char **) InternalMalloc((((*pnArg)+1) * sizeof(char *)));
  3229|     if (lppArgv == NULL)
  3230|     {
  3231|         free(lpAsciiCmdLine);
  3232|         return NULL;
  3233|     }
  3234|     lppTemp = lppArgv;
  3235|     /* at this point all parameters are separated by NULL
  3236|        we need to fill the array of arguments; we must also remove all dquotes
  3237|        from arguments (new process shouldn't see them) */
  3238|     for (i = *pnArg, pChar = lpAsciiCmdLine; i; i--)
  3239|     {
  3240|         /* skip NULLs */
  3241|         while (!*pChar)
  3242|         {
  3243|             pChar++;
  3244|         }
  3245|         *lppTemp = pChar;
  3246|         /* go to the next parameter, removing dquotes as we go along */
  3247|         j = 0;
  3248|         while (*pChar)
  3249|         {
  3250|             /* copy character if it's not a dquote */
  3251|             if('"' != *pChar)
  3252|             {
  3253|                 /* if it's the \ of an escaped dquote, skip over it, we'll
  3254|                    copy the " instead */
  3255|                 if( '\\' == pChar[0] && '"' == pChar[1] )
  3256|                 {
  3257|                     pChar++;
  3258|                 }
  3259|                 (*lppTemp)[j++] = *pChar;
  3260|             }
  3261|             pChar++;
  3262|         }
  3263|         /* re-NULL terminate the argument */
  3264|         (*lppTemp)[j] = '\0';
  3265|         lppTemp++;
  3266|     }
  3267|     *lppTemp = NULL;
  3268|     return lppArgv;
  3269| }
  3270| /*++
  3271| Function:
  3272|   getPath
  3273| Abstract:
  3274|     Helper function for CreateProcessW, it looks in the path environment
  3275|     variable to find where the process to executed is.
  3276| Parameters:
  3277|     IN  lpFileName: file name to search in the path
  3278|     OUT lpPathFileName: returned string containing the path and the filename
  3279| Return:
  3280|     TRUE if found
  3281|     FALSE otherwise
  3282| --*/
  3283| static
  3284| BOOL
  3285| getPath(
  3286|       PathCharString& lpFileNameString,
  3287|       PathCharString& lpPathFileName)
  3288| {
  3289|     LPSTR lpPath;
  3290|     LPSTR lpNext;
  3291|     LPSTR lpCurrent;
  3292|     LPWSTR lpwstr;
  3293|     INT n;
  3294|     INT nextLen;
  3295|     INT slashLen;
  3296|     CPalThread *pThread = NULL;
  3297|     LPCSTR lpFileName = lpFileNameString.GetString();
  3298|     /* if a path is specified, only look there */
  3299|     if(strchr(lpFileName, '/'))
  3300|     {
  3301|         if (access (lpFileName, F_OK) == 0)
  3302|         {
  3303|             if (!lpPathFileName.Set(lpFileNameString))
  3304|             {
  3305|                 TRACE("Set of StackString failed!\n");
  3306|                 return FALSE;
  3307|             }
  3308|             TRACE("file %s exists\n", lpFileName);
  3309|             return TRUE;
  3310|         }
  3311|         else
  3312|         {
  3313|             TRACE("file %s doesn't exist.\n", lpFileName);
  3314|             return FALSE;
  3315|         }
  3316|     }
  3317|     /* first look in directory from which the application loaded */
  3318|     lpwstr = g_lpwstrAppDir;
  3319|     if (lpwstr)
  3320|     {
  3321|         /* convert path to multibyte, check buffer size */
  3322|         n = WideCharToMultiByte(CP_ACP, 0, lpwstr, -1, NULL, 0,
  3323|             NULL, NULL);
  3324|         if (!lpPathFileName.Reserve(n + lpFileNameString.GetCount() + 1 ))
  3325|         {
  3326|             ERROR("StackString Reserve failed!\n");
  3327|             return FALSE;
  3328|         }
  3329|         lpPath = lpPathFileName.OpenStringBuffer(n);
  3330|         n = WideCharToMultiByte(CP_ACP, 0, lpwstr, -1, lpPath, n,
  3331|             NULL, NULL);
  3332|         if (n == 0)
  3333|         {
  3334|             lpPathFileName.CloseBuffer(0);
  3335|             ASSERT("WideCharToMultiByte failure!\n");
  3336|             return FALSE;
  3337|         }
  3338|         lpPathFileName.CloseBuffer(n - 1);
  3339|         lpPathFileName.Append("/", 1);
  3340|         lpPathFileName.Append(lpFileNameString);
  3341|         if (access(lpPathFileName, F_OK) == 0)
  3342|         {
  3343|             TRACE("found %s in application directory (%s)\n", lpFileName, lpPathFileName.GetString());
  3344|             return TRUE;
  3345|         }
  3346|     }
  3347|     /* then try the current directory */
  3348|     if (!lpPathFileName.Reserve(lpFileNameString.GetCount()  + 2))
  3349|     {
  3350|         ERROR("StackString Reserve failed!\n");
  3351|         return FALSE;
  3352|     }
  3353|     lpPathFileName.Set("./", 2);
  3354|     lpPathFileName.Append(lpFileNameString);
  3355|     if (access (lpPathFileName, R_OK) == 0)
  3356|     {
  3357|         TRACE("found %s in current directory.\n", lpFileName);
  3358|         return TRUE;
  3359|     }
  3360|     pThread = InternalGetCurrentThread();
  3361|     /* Then try to look in the path */
  3362|     lpPath = EnvironGetenv("PATH");
  3363|     if (!lpPath)
  3364|     {
  3365|         ERROR("EnvironGetenv returned NULL for $PATH\n");
  3366|         return FALSE;
  3367|     }
  3368|     lpNext = lpPath;
  3369|     /* search in every path directory */
  3370|     TRACE("looking for file %s in $PATH (%s)\n", lpFileName, lpPath);
  3371|     while (lpNext)
  3372|     {
  3373|         /* skip all leading ':' */
  3374|         while(*lpNext==':')
  3375|         {
  3376|             lpNext++;
  3377|         }
  3378|         /* search for ':' */
  3379|         lpCurrent = strchr(lpNext, ':');
  3380|         if (lpCurrent)
  3381|         {
  3382|             *lpCurrent++ = '\0';
  3383|         }
  3384|         nextLen = strlen(lpNext);
  3385|         slashLen = (lpNext[nextLen-1] == '/') ? 0:1;
  3386|         if (!lpPathFileName.Reserve(nextLen + lpFileNameString.GetCount() + 1))
  3387|         {
  3388|             free(lpPath);
  3389|             ERROR("StackString ran out of memory for full path\n");
  3390|             return FALSE;
  3391|         }
  3392|         lpPathFileName.Set(lpNext, nextLen);
  3393|         if( slashLen == 1)
  3394|         {
  3395|             /* append a '/' if there's no '/' at the end of the path */
  3396|             lpPathFileName.Append("/", 1);
  3397|         }
  3398|         lpPathFileName.Append(lpFileNameString);
  3399|         if ( access (lpPathFileName, F_OK) == 0)
  3400|         {
  3401|             TRACE("Found %s in $PATH element %s\n", lpFileName, lpNext);
  3402|             free(lpPath);
  3403|             return TRUE;
  3404|         }
  3405|         lpNext = lpCurrent;  /* search in the next directory */
  3406|     }
  3407|     free(lpPath);
  3408|     TRACE("File %s not found in $PATH\n", lpFileName);
  3409|     return FALSE;
  3410| }


# ====================================================================
# FILE: src/coreclr/scripts/superpmi_collect_setup.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-392 ---
     1| import argparse
     2| import os
     3| import stat
     4| from coreclr_arguments import *
     5| from jitutil import run_command, copy_directory, copy_files, set_pipeline_variable, ChangeDir, TempDir
     6| parser = argparse.ArgumentParser(description="description")
     7| parser.add_argument("-source_directory", help="path to source directory")
     8| parser.add_argument("-core_root_directory", help="path to core_root directory")
     9| parser.add_argument("-arch", help="Architecture")
    10| parser.add_argument("-platform", help="OS platform")
    11| parser.add_argument("-mch_file_tag", help="Tag to be used to mch files")
    12| parser.add_argument("-collection_name", help="Name of the SPMI collection to be done (e.g., libraries, tests)")
    13| parser.add_argument("-collection_type", help="Type of the SPMI collection to be done (crossgen, crossgen2, pmi)")
    14| parser.add_argument("-input_directory", help="directory containing assemblies for which superpmi collection to be done")
    15| parser.add_argument("-max_size", help="Max size of each partition in MB")
    16| is_windows = platform.system() == "Windows"
    17| native_binaries_to_ignore = [
    18|     "api-ms-win-core-console-l1-1-0.dll",
    19|     "api-ms-win-core-datetime-l1-1-0.dll",
    20|     "api-ms-win-core-debug-l1-1-0.dll",
    21|     "api-ms-win-core-errorhandling-l1-1-0.dll",
    22|     "api-ms-win-core-file-l1-1-0.dll",
    23|     "api-ms-win-core-file-l1-2-0.dll",
    24|     "api-ms-win-core-file-l2-1-0.dll",
    25|     "api-ms-win-core-handle-l1-1-0.dll",
    26|     "api-ms-win-core-heap-l1-1-0.dll",
    27|     "api-ms-win-core-interlocked-l1-1-0.dll",
    28|     "api-ms-win-core-libraryloader-l1-1-0.dll",
    29|     "api-ms-win-core-localization-l1-2-0.dll",
    30|     "api-ms-win-core-memory-l1-1-0.dll",
    31|     "api-ms-win-core-namedpipe-l1-1-0.dll",
    32|     "api-ms-win-core-processenvironment-l1-1-0.dll",
    33|     "api-ms-win-core-processthreads-l1-1-0.dll",
    34|     "api-ms-win-core-processthreads-l1-1-1.dll",
    35|     "api-ms-win-core-profile-l1-1-0.dll",
    36|     "api-ms-win-core-rtlsupport-l1-1-0.dll",
    37|     "api-ms-win-core-string-l1-1-0.dll",
    38|     "api-ms-win-core-synch-l1-1-0.dll",
    39|     "api-ms-win-core-synch-l1-2-0.dll",
    40|     "api-ms-win-core-sysinfo-l1-1-0.dll",
    41|     "api-ms-win-core-timezone-l1-1-0.dll",
    42|     "api-ms-win-core-util-l1-1-0.dll",
    43|     "api-ms-win-crt-conio-l1-1-0.dll",
    44|     "api-ms-win-crt-convert-l1-1-0.dll",
    45|     "api-ms-win-crt-environment-l1-1-0.dll",
    46|     "api-ms-win-crt-filesystem-l1-1-0.dll",
    47|     "api-ms-win-crt-heap-l1-1-0.dll",
    48|     "api-ms-win-crt-locale-l1-1-0.dll",
    49|     "api-ms-win-crt-math-l1-1-0.dll",
    50|     "api-ms-win-crt-multibyte-l1-1-0.dll",
    51|     "api-ms-win-crt-private-l1-1-0.dll",
    52|     "api-ms-win-crt-process-l1-1-0.dll",
    53|     "api-ms-win-crt-runtime-l1-1-0.dll",
    54|     "api-ms-win-crt-stdio-l1-1-0.dll",
    55|     "api-ms-win-crt-string-l1-1-0.dll",
    56|     "api-ms-win-crt-time-l1-1-0.dll",
    57|     "api-ms-win-crt-utility-l1-1-0.dll",
    58|     "clretwrc.dll",
    59|     "clrgc.dll",
    60|     "clrjit.dll",
    61|     "clrjit_unix_arm_arm.dll",
    62|     "clrjit_unix_arm_arm64.dll",
    63|     "clrjit_unix_arm_x64.dll",
    64|     "clrjit_unix_arm_x86.dll",
    65|     "clrjit_unix_arm64_arm64.dll",
    66|     "clrjit_unix_arm64_x64.dll",
    67|     "clrjit_unix_armel_arm.dll",
    68|     "clrjit_unix_armel_arm64.dll",
    69|     "clrjit_unix_armel_x64.dll",
    70|     "clrjit_unix_armel_x86.dll",
    71|     "clrjit_unix_osx_arm64_arm64.dll",
    72|     "clrjit_unix_osx_arm64_x64.dll",
    73|     "clrjit_unix_x64_arm64.dll",
    74|     "clrjit_unix_x64_x64.dll",
    75|     "clrjit_win_arm_arm.dll",
    76|     "clrjit_win_arm_arm64.dll",
    77|     "clrjit_win_arm_x64.dll",
    78|     "clrjit_win_arm_x86.dll",
    79|     "clrjit_win_arm64_arm64.dll",
    80|     "clrjit_win_arm64_x64.dll",
    81|     "clrjit_win_x64_arm64.dll",
    82|     "clrjit_win_x64_x64.dll",
    83|     "clrjit_win_x86_arm.dll",
    84|     "clrjit_win_x86_arm64.dll",
    85|     "clrjit_win_x86_x64.dll",
    86|     "clrjit_win_x86_x86.dll",
    87|     "clrjit_universal_arm_arm.dll",
    88|     "clrjit_universal_arm_arm64.dll",
    89|     "clrjit_universal_arm_x64.dll",
    90|     "clrjit_universal_arm_x86.dll",
    91|     "clrjit_universal_arm64_arm64.dll",
    92|     "clrjit_universal_arm64_x64.dll",
    93|     "coreclr.dll",
    94|     "CoreConsole.exe",
    95|     "coredistools.dll",
    96|     "CoreRun.exe",
    97|     "CoreShim.dll",
    98|     "createdump.exe",
    99|     "crossgen.exe",
   100|     "crossgen2.exe",
   101|     "dbgshim.dll",
   102|     "ilasm.exe",
   103|     "ildasm.exe",
   104|     "jitinterface_arm.dll",
   105|     "jitinterface_arm64.dll",
   106|     "jitinterface_x64.dll",
   107|     "jitinterface_x86.dll",
   108|     "KernelTraceControl.dll",
   109|     "KernelTraceControl.Win61.dll",
   110|     "mcs.exe",
   111|     "Microsoft.DiaSymReader.Native.amd64.dll",
   112|     "Microsoft.DiaSymReader.Native.x86.dll",
   113|     "mscordaccore.dll",
   114|     "mscordbi.dll",
   115|     "mscorrc.dll",
   116|     "msdia140.dll",
   117|     "msquic.dll",
   118|     "msvcp140.dll",
   119|     "vcruntime140.dll",
   120|     "vcruntime140_1.dll",
   121|     "R2RDump.exe",
   122|     "R2RTest.exe",
   123|     "superpmi.exe",
   124|     "superpmi-shim-collector.dll",
   125|     "superpmi-shim-counter.dll",
   126|     "superpmi-shim-simple.dll",
   127|     "System.CommandLine.resources.dll", # Managed, but uninteresting
   128|     "System.IO.Compression.Native.dll",
   129|     "ucrtbase.dll",
   130|     "xunit.console.exe",
   131| ]
   132| MAX_FILES_COUNT = 1500
   133| def setup_args(args):
   134|     """ Setup the args for SuperPMI to use.
   135|     Args:
   136|         args (ArgParse): args parsed by arg parser
   137|     Returns:
   138|         args (CoreclrArguments)
   139|     """
   140|     coreclr_args = CoreclrArguments(args, require_built_core_root=False, require_built_product_dir=False,
   141|                                     require_built_test_dir=False, default_build_type="Checked")
   142|     coreclr_args.verify(args,
   143|                         "source_directory",
   144|                         lambda source_directory: os.path.isdir(source_directory),
   145|                         "source_directory doesn't exist")
   146|     coreclr_args.verify(args,
   147|                         "core_root_directory",
   148|                         lambda core_root_directory: os.path.isdir(core_root_directory),
   149|                         "core_root_directory doesn't exist")
   150|     coreclr_args.verify(args,
   151|                         "arch",
   152|                         lambda unused: True,
   153|                         "Unable to set arch")
   154|     coreclr_args.verify(args,
   155|                         "platform",
   156|                         lambda unused: True,
   157|                         "Unable to set platform")
   158|     coreclr_args.verify(args,
   159|                         "mch_file_tag",
   160|                         lambda unused: True,
   161|                         "Unable to set mch_file_tag")
   162|     coreclr_args.verify(args,
   163|                         "collection_name",
   164|                         lambda unused: True,
   165|                         "Unable to set collection_name")
   166|     coreclr_args.verify(args,
   167|                         "collection_type",
   168|                         lambda unused: True,
   169|                         "Unable to set collection_type")
   170|     coreclr_args.verify(args,
   171|                         "input_directory",
   172|                         lambda input_directory: os.path.isdir(input_directory),
   173|                         "input_directory doesn't exist")
   174|     coreclr_args.verify(args,
   175|                         "max_size",
   176|                         lambda max_size: max_size > 0,
   177|                         "Please enter valid positive numeric max_size",
   178|                         modify_arg=lambda max_size: int(
   179|                             max_size) * 1000 * 1000 if max_size is not None and max_size.isnumeric() else 0
   180|                         )
   181|     return coreclr_args
   182| def get_files_sorted_by_size(src_directory, exclude_directories, exclude_files):
   183|     """ For a given src_directory, returns all the .dll files sorted by size.
   184|     Args:
   185|         src_directory (string): Path of directory to enumerate.
   186|         exclude_directories ([string]): Directory names to exclude.
   187|         exclude_files ([string]): File names to exclude.
   188|     """
   189|     def sorter_by_size(pair):
   190|         """ Sorts the pair (file_name, file_size) tuple in descending order of file_size
   191|         Args:
   192|             pair ([(string, int)]): List of tuple of file_name, file_size
   193|         """
   194|         pair.sort(key=lambda x: x[1], reverse=True)
   195|         return pair
   196|     filename_with_size = []
   197|     exclude_files_lower = [filename.lower() for filename in exclude_files]
   198|     for file_path, dirs, files in os.walk(src_directory, topdown=True):
   199|         dirs[:] = [d for d in dirs if d not in exclude_directories]
   200|         for name in files:
   201|             if name.lower() in exclude_files_lower:
   202|                 continue
   203|             curr_file_path = os.path.join(file_path, name)
   204|             if not os.path.isfile(curr_file_path):
   205|                 continue
   206|             if not name.endswith(".dll") and not name.endswith(".exe"):
   207|                 continue
   208|             size = os.path.getsize(curr_file_path)
   209|             filename_with_size.append((curr_file_path, size))
   210|     return sorter_by_size(filename_with_size)
   211| def first_fit(sorted_by_size, max_size):
   212|     """ Given a list of file names along with size in descending order, divides the files
   213|     in number of buckets such that each bucket doesn't exceed max_size (unless a single file exceeds
   214|     max_size, in which case it gets its own bucket). Since this is a first-fit
   215|     approach, it doesn't guarantee to find the bucket with tighest spot available.
   216|     Args:
   217|         sorted_by_size ((string, int)): (file_name, file_size) tuple
   218|         max_size (int): Maximum size (in bytes) of each bucket.
   219|     Returns:
   220|         [{int, [string]}]: Returns a dictionary of partition-index to list of file names following in that bucket.
   221|     """
   222|     partitions = {}
   223|     for curr_file in sorted_by_size:
   224|         _, file_size = curr_file
   225|         found_bucket = False
   226|         if file_size < max_size:
   227|             for p_index in partitions:
   228|                 total_in_curr_par = sum(n for _, n in partitions[p_index])
   229|                 if ((total_in_curr_par + file_size) < max_size) and (len(partitions[p_index]) < MAX_FILES_COUNT):
   230|                     partitions[p_index].append(curr_file)
   231|                     found_bucket = True
   232|                     break
   233|         if not found_bucket:
   234|             partitions[len(partitions)] = [curr_file]
   235|     total_size = 0
   236|     for p_index in partitions:
   237|         partition_size = sum(n for _, n in partitions[p_index])
   238|         print("Partition {0}: {1} files with {2} bytes.".format(p_index, len(partitions[p_index]), partition_size))
   239|         total_size += partition_size
   240|     print("Total {0} partitions with {1} bytes.".format(str(len(partitions)), total_size))
   241|     return partitions
   242| def partition_files(src_directory, dst_directory, max_size, exclude_directories=[],
   243|                     exclude_files=native_binaries_to_ignore):
   244|     """ Copy bucketized files based on size to destination folder.
   245|     Args:
   246|         src_directory (string): Source folder containing files to be copied.
   247|         dst_directory (string): Destination folder where files should be copied.
   248|         max_size (int): Maximum partition size in bytes
   249|         exclude_directories ([string]): List of folder names to be excluded.
   250|         exclude_files ([string]): List of files names to be excluded.
   251|     """
   252|     print('Partitioning files from {0} to {1}'.format(src_directory, dst_directory))
   253|     sorted_by_size = get_files_sorted_by_size(src_directory, exclude_directories, exclude_files)
   254|     partitions = first_fit(sorted_by_size, max_size)
   255|     index = 0
   256|     for p_index in partitions:
   257|         file_names = [curr_file[0] for curr_file in partitions[p_index]]
   258|         curr_dst_path = os.path.join(dst_directory, str(index), "binaries")
   259|         copy_files(src_directory, curr_dst_path, file_names)
   260|         index += 1
   261| def setup_microbenchmark(workitem_directory, arch):
   262|     """ Perform setup of microbenchmarks
   263|     Args:
   264|         workitem_directory (string): Path to work
   265|         arch (string): Architecture for which dotnet will be installed
   266|     """
   267|     performance_directory = os.path.join(workitem_directory, "performance")
   268|     run_command(
   269|         ["git", "clone", "--quiet", "--depth", "1", "https://github.com/dotnet/performance", performance_directory])
   270|     with ChangeDir(performance_directory):
   271|         dotnet_directory = os.path.join(performance_directory, "tools", "dotnet", arch)
   272|         dotnet_install_script = os.path.join(performance_directory, "scripts", "dotnet.py")
   273|         if not os.path.isfile(dotnet_install_script):
   274|             print("Missing " + dotnet_install_script)
   275|             return
   276|         run_command(
   277|             get_python_name() + [dotnet_install_script, "install", "--architecture", arch, "--install-dir",
   278|                                  dotnet_directory, "--verbose"])
   279| def get_python_name():
   280|     """Gets the python name
   281|     Returns:
   282|         [string]: Returns the appropriate python name depending on the OS.
   283|     """
   284|     if is_windows:
   285|         return ["py", "-3"]
   286|     else:
   287|         return ["python3"]
   288| def main(main_args):
   289|     """ Main entrypoint
   290|     Args:
   291|         main_args ([type]): Arguments to the script
   292|     """
   293|     coreclr_args = setup_args(main_args)
   294|     source_directory = coreclr_args.source_directory
   295|     correlation_payload_directory = os.path.join(coreclr_args.source_directory, "payload")
   296|     superpmi_src_directory = os.path.join(source_directory, 'src', 'coreclr', 'scripts')
   297|     superpmi_dst_directory = os.path.join(correlation_payload_directory, "superpmi")
   298|     arch = coreclr_args.arch
   299|     platform_name = coreclr_args.platform.lower()
   300|     helix_source_prefix = "official"
   301|     creator = ""
   302|     ci = True
   303|     if platform_name == "windows":
   304|         helix_queue = "Windows.10.Arm64" if arch == "arm64" else "Windows.10.Amd64.X86.Rt"
   305|     elif platform_name == "linux":
   306|         if arch == "arm":
   307|             helix_queue = "(Ubuntu.1804.Arm32)Ubuntu.1804.Armarch@mcr.microsoft.com/dotnet-buildtools/prereqs:ubuntu-18.04-helix-arm32v7"
   308|         elif arch == "arm64":
   309|             helix_queue = "(Ubuntu.1804.Arm64)Ubuntu.1804.ArmArch@mcr.microsoft.com/dotnet-buildtools/prereqs:ubuntu-18.04-helix-arm64v8"
   310|         else:
   311|             helix_queue = "Ubuntu.1804.Amd64"
   312|     elif platform_name == "osx":
   313|         helix_queue = "OSX.1100.ARM64" if arch == "arm64" else "OSX.1014.Amd64"
   314|     print('Copying {} -> {}'.format(superpmi_src_directory, superpmi_dst_directory))
   315|     copy_directory(superpmi_src_directory, superpmi_dst_directory, verbose_output=True, match_func=lambda path: any(path.endswith(extension) for extension in [".py"]))
   316|     if platform_name == "windows":
   317|         acceptable_copy = lambda path: any(path.endswith(extension) for extension in [".py", ".dll", ".exe", ".json"])
   318|     else:
   319|         acceptable_extensions = [".py", ".dll", ".json"]
   320|         acceptable_extensions.append(".so" if platform_name == "linux" else ".dylib")
   321|         acceptable_copy = lambda path: (os.path.basename(path).find(".") == -1) or any(path.endswith(extension) for extension in acceptable_extensions)
   322|     print('Copying {} -> {}'.format(coreclr_args.core_root_directory, superpmi_dst_directory))
   323|     copy_directory(coreclr_args.core_root_directory, superpmi_dst_directory, verbose_output=True, match_func=acceptable_copy)
   324|     if coreclr_args.collection_name == "libraries_tests":
   325|         print('Copying {} -> {}'.format(coreclr_args.input_directory, superpmi_dst_directory))
   326|         def make_readable(folder_name):
   327|             """Make file executable by changing the permission
   328|             Args:
   329|                 folder_name (string): folder to mark with 744
   330|             """
   331|             if is_windows:
   332|                 return
   333|             print("Inside make_readable")
   334|             run_command(["ls", "-l", folder_name])
   335|             for file_path, dirs, files in os.walk(folder_name, topdown=True):
   336|                 for d in dirs:
   337|                     os.chmod(os.path.join(file_path, d),
   338|                     (stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR) |
   339|                     (stat.S_IRGRP) |
   340|                     (stat.S_IROTH))
   341|                 for f in files:
   342|                     os.chmod(os.path.join(file_path, f),
   343|                     (stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR) |
   344|                     (stat.S_IRGRP) |
   345|                     (stat.S_IROTH))
   346|             run_command(["ls", "-l", folder_name])
   347|         make_readable(coreclr_args.input_directory)
   348|         copy_directory(coreclr_args.input_directory, superpmi_dst_directory, verbose_output=True, match_func=acceptable_copy)
   349|     workitem_directory = os.path.join(source_directory, "workitem")
   350|     input_artifacts = ""
   351|     if coreclr_args.collection_name == "benchmarks":
   352|         setup_microbenchmark(workitem_directory, arch)
   353|     else:
   354|         try:
   355|             with TempDir() as jitutils_directory:
   356|                 run_command(
   357|                     ["git", "clone", "--quiet", "--depth", "1", "https://github.com/dotnet/jitutils", jitutils_directory])
   358|                 dotnet_script_name = "dotnet.cmd" if is_windows else "dotnet.sh"
   359|                 dotnet_script_path = os.path.join(source_directory, dotnet_script_name)
   360|                 run_command([dotnet_script_path, "--info"], jitutils_directory)
   361|                 os.environ["PATH"] = os.path.join(source_directory, ".dotnet") + os.pathsep + os.environ["PATH"]
   362|                 build_file = "build.cmd" if is_windows else "build.sh"
   363|                 run_command([os.path.join(jitutils_directory, build_file), "-p"], jitutils_directory)
   364|                 copy_files(os.path.join(jitutils_directory, "bin"), superpmi_dst_directory, [os.path.join(jitutils_directory, "bin", "pmi.dll")])
   365|         except PermissionError as pe_error:
   366|             print('Ignoring PermissionError: {0}'.format(pe_error))
   367|         pmiassemblies_directory = os.path.join(workitem_directory, "pmiAssembliesDirectory")
   368|         input_artifacts = os.path.join(pmiassemblies_directory, coreclr_args.collection_name)
   369|         exclude_directory = ['Core_Root'] if coreclr_args.collection_name == "coreclr_tests" else []
   370|         exclude_files = native_binaries_to_ignore
   371|         if coreclr_args.collection_type == "crossgen2":
   372|             print('Adding exclusions for crossgen2')
   373|             exclude_files += ["Microsoft.Build.dll"]
   374|         if coreclr_args.collection_name == "libraries_tests":
   375|             core_root_dir = coreclr_args.core_root_directory
   376|             exclude_files += [item for item in os.listdir(core_root_dir)
   377|                               if os.path.isfile(os.path.join(core_root_dir, item)) and (item.endswith(".dll") or item.endswith(".exe"))]
   378|         partition_files(coreclr_args.input_directory, input_artifacts, coreclr_args.max_size, exclude_directory,
   379|                         exclude_files)
   380|     print('Setting pipeline variables:')
   381|     set_pipeline_variable("CorrelationPayloadDirectory", correlation_payload_directory)
   382|     set_pipeline_variable("WorkItemDirectory", workitem_directory)
   383|     set_pipeline_variable("InputArtifacts", input_artifacts)
   384|     set_pipeline_variable("Python", ' '.join(get_python_name()))
   385|     set_pipeline_variable("Architecture", arch)
   386|     set_pipeline_variable("Creator", creator)
   387|     set_pipeline_variable("Queue", helix_queue)
   388|     set_pipeline_variable("HelixSourcePrefix", helix_source_prefix)
   389|     set_pipeline_variable("MchFileTag", coreclr_args.mch_file_tag)
   390| if __name__ == "__main__":
   391|     args = parser.parse_args()
   392|     sys.exit(main(args))


# ====================================================================
# FILE: src/coreclr/tools/aot/ILCompiler.Compiler/Compiler/DependencyAnalysis/PInvokeMethodFixupNode.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-138 ---
     1| using System;
     2| using System.Reflection.Metadata;
     3| using System.Runtime.InteropServices;
     4| using Internal.IL.Stubs;
     5| using Internal.Text;
     6| using Internal.TypeSystem;
     7| using Internal.TypeSystem.Ecma;
     8| namespace ILCompiler.DependencyAnalysis
     9| {
    10|     public class PInvokeMethodFixupNode : ObjectNode, ISymbolDefinitionNode
    11|     {
    12|         private readonly PInvokeMethodData _pInvokeMethodData;
    13|         public PInvokeMethodFixupNode(PInvokeMethodData pInvokeMethodData)
    14|         {
    15|             _pInvokeMethodData = pInvokeMethodData;
    16|         }
    17|         public void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb)
    18|         {
    19|             sb.Append("__pinvoke_");
    20|             _pInvokeMethodData.AppendMangledName(nameMangler, sb);
    21|         }
    22|         public int Offset => 0;
    23|         public override bool IsShareable => true;
    24|         protected override string GetName(NodeFactory factory) => this.GetMangledName(factory.NameMangler);
    25|         public override ObjectNodeSection Section => ObjectNodeSection.DataSection;
    26|         public override bool StaticDependenciesAreComputed => true;
    27|         public override ObjectData GetData(NodeFactory factory, bool relocsOnly = false)
    28|         {
    29|             ObjectDataBuilder builder = new ObjectDataBuilder(factory, relocsOnly);
    30|             builder.RequireInitialPointerAlignment();
    31|             builder.AddSymbol(this);
    32|             builder.EmitZeroPointer();
    33|             string entryPointName = _pInvokeMethodData.EntryPointName;
    34|             if (factory.Target.IsWindows && entryPointName.StartsWith("#", StringComparison.OrdinalIgnoreCase))
    35|             {
    36|                 int entrypointOrdinal;
    37|                 if (!int.TryParse(entryPointName.Substring(1), out entrypointOrdinal))
    38|                     entrypointOrdinal = 0;
    39|                 builder.EmitNaturalInt((ushort)entrypointOrdinal);
    40|             }
    41|             else
    42|             {
    43|                 builder.EmitPointerReloc(factory.ConstantUtf8String(entryPointName));
    44|             }
    45|             builder.EmitPointerReloc(factory.PInvokeModuleFixup(_pInvokeMethodData.ModuleData));
    46|             builder.EmitInt((int)_pInvokeMethodData.CharSetMangling);
    47|             return builder.ToObjectData();
    48|         }
    49|         public override int ClassCode => -1592006940;
    50|         public override int CompareToImpl(ISortableNode other, CompilerComparer comparer)
    51|         {
    52|             return _pInvokeMethodData.CompareTo(((PInvokeMethodFixupNode)other)._pInvokeMethodData, comparer);
    53|         }
    54|     }
    55|     public readonly struct PInvokeMethodData : IEquatable<PInvokeMethodData>
    56|     {
    57|         public readonly PInvokeModuleData ModuleData;
    58|         public readonly string EntryPointName;
    59|         public readonly CharSet CharSetMangling;
    60|         public PInvokeMethodData(PInvokeLazyFixupField pInvokeLazyFixupField)
    61|         {
    62|             PInvokeMetadata metadata = pInvokeLazyFixupField.PInvokeMetadata;
    63|             ModuleDesc declaringModule = ((MetadataType)pInvokeLazyFixupField.TargetMethod.OwningType).Module;
    64|             CustomAttributeValue<TypeDesc>? decodedAttr = null;
    65|             if (pInvokeLazyFixupField.TargetMethod is EcmaMethod method)
    66|             {
    67|                 decodedAttr = method.GetDecodedCustomAttribute("System.Runtime.InteropServices", "DefaultDllImportSearchPathsAttribute");
    68|             }
    69|             if (!decodedAttr.HasValue && declaringModule.Assembly is EcmaAssembly asm)
    70|             {
    71|                 var attrHandle = asm.MetadataReader.GetCustomAttributeHandle(asm.AssemblyDefinition.GetCustomAttributes(),
    72|                     "System.Runtime.InteropServices", "DefaultDllImportSearchPathsAttribute");
    73|                 if (!attrHandle.IsNil)
    74|                 {
    75|                     var attr = asm.MetadataReader.GetCustomAttribute(attrHandle);
    76|                     decodedAttr = attr.DecodeValue(new CustomAttributeTypeProvider(asm));
    77|                 }
    78|             }
    79|             DllImportSearchPath? dllImportSearchPath = default;
    80|             if (decodedAttr.HasValue
    81|                 && decodedAttr.Value.FixedArguments.Length == 1
    82|                 && decodedAttr.Value.FixedArguments[0].Value is int searchPath)
    83|             {
    84|                 dllImportSearchPath = (DllImportSearchPath)searchPath;
    85|             }
    86|             ModuleData = new PInvokeModuleData(metadata.Module, dllImportSearchPath, declaringModule);
    87|             EntryPointName = metadata.Name;
    88|             CharSet charSetMangling = default;
    89|             if (declaringModule.Context.Target.IsWindows && !metadata.Flags.ExactSpelling)
    90|             {
    91|                 bool isAnsi = metadata.Flags.CharSet switch
    92|                 {
    93|                     CharSet.Ansi => true,
    94|                     CharSet.Unicode => false,
    95|                     CharSet.Auto => false,
    96|                     _ => true
    97|                 };
    98|                 charSetMangling = isAnsi ? CharSet.Ansi : CharSet.Unicode;
    99|             }
   100|             CharSetMangling = charSetMangling;
   101|         }
   102|         public bool Equals(PInvokeMethodData other)
   103|         {
   104|             return ModuleData.Equals(other.ModuleData) &&
   105|                 EntryPointName == other.EntryPointName &&
   106|                 CharSetMangling == other.CharSetMangling;
   107|         }
   108|         public override bool Equals(object obj)
   109|         {
   110|             return obj is PInvokeMethodData other && Equals(other);
   111|         }
   112|         public override int GetHashCode()
   113|         {
   114|             return ModuleData.GetHashCode() ^ EntryPointName.GetHashCode();
   115|         }
   116|         public int CompareTo(PInvokeMethodData other, CompilerComparer comparer)
   117|         {
   118|             var entryPointCompare = StringComparer.Ordinal.Compare(EntryPointName, other.EntryPointName);
   119|             if (entryPointCompare != 0)
   120|                 return entryPointCompare;
   121|             var moduleCompare = ModuleData.CompareTo(other.ModuleData, comparer);
   122|             if (moduleCompare != 0)
   123|                 return moduleCompare;
   124|             return CharSetMangling.CompareTo(other.CharSetMangling);
   125|         }
   126|         public void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb)
   127|         {
   128|             ModuleData.AppendMangledName(nameMangler, sb);
   129|             sb.Append("__");
   130|             sb.Append(EntryPointName);
   131|             if (CharSetMangling != default)
   132|             {
   133|                 sb.Append("__");
   134|                 sb.Append(CharSetMangling.ToString());
   135|             }
   136|         }
   137|     }
   138| }


# ====================================================================
# FILE: src/coreclr/vm/eventing/eventpipe/ep-rt-coreclr.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-2699 ---
     1| #ifndef __EVENTPIPE_RT_CORECLR_H__
     2| #define __EVENTPIPE_RT_CORECLR_H__
     3| #include <eventpipe/ep-rt-config.h>
     4| #ifdef ENABLE_PERFTRACING
     5| #include <eventpipe/ep-thread.h>
     6| #include <eventpipe/ep-types.h>
     7| #include <eventpipe/ep-provider.h>
     8| #include <eventpipe/ep-session-provider.h>
     9| #include "fstream.h"
    10| #include "typestring.h"
    11| #include "win32threadpool.h"
    12| #include "clrversion.h"
    13| #undef EP_INFINITE_WAIT
    14| #define EP_INFINITE_WAIT INFINITE
    15| #undef EP_GCX_PREEMP_ENTER
    16| #define EP_GCX_PREEMP_ENTER { GCX_PREEMP();
    17| #undef EP_GCX_PREEMP_EXIT
    18| #define EP_GCX_PREEMP_EXIT }
    19| #undef EP_ALWAYS_INLINE
    20| #define EP_ALWAYS_INLINE FORCEINLINE
    21| #undef EP_NEVER_INLINE
    22| #define EP_NEVER_INLINE NOINLINE
    23| #undef EP_ALIGN_UP
    24| #define EP_ALIGN_UP(val,align) ALIGN_UP(val,align)
    25| #ifndef EP_RT_BUILD_TYPE_FUNC_NAME
    26| #define EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, type_name, func_name) \
    27| prefix_name ## _rt_ ## type_name ## _ ## func_name
    28| #endif
    29| template<typename LIST_TYPE>
    30| static
    31| inline
    32| void
    33| _rt_coreclr_list_alloc (LIST_TYPE *list) {
    34| 	STATIC_CONTRACT_NOTHROW;
    35| 	EP_ASSERT (list != NULL);
    36| 	list->list = new (nothrow) typename LIST_TYPE::list_type_t ();
    37| }
    38| template<typename LIST_TYPE>
    39| static
    40| inline
    41| void
    42| _rt_coreclr_list_free (
    43| 	LIST_TYPE *list,
    44| 	void (*callback)(void *))
    45| {
    46| 	STATIC_CONTRACT_NOTHROW;
    47| 	EP_ASSERT (list != NULL);
    48| 	if (list->list) {
    49| 		while (!list->list->IsEmpty ()) {
    50| 				typename LIST_TYPE::element_type_t *current = list->list->RemoveHead ();
    51| 				if (callback)
    52| 					callback (reinterpret_cast<void *>(current->GetValue ()));
    53| 				delete current;
    54| 		}
    55| 		delete list->list;
    56| 	}
    57| 	list->list = NULL;
    58| }
    59| template<typename LIST_TYPE>
    60| static
    61| inline
    62| void
    63| _rt_coreclr_list_clear (
    64| 	LIST_TYPE *list,
    65| 	void (*callback)(void *))
    66| {
    67| 	STATIC_CONTRACT_NOTHROW;
    68| 	EP_ASSERT (list != NULL && list->list != NULL);
    69| 	while (!list->list->IsEmpty ()) {
    70| 		typename LIST_TYPE::element_type_t *current = list->list->RemoveHead ();
    71| 		if (callback)
    72| 				callback (reinterpret_cast<void *>(current->GetValue ()));
    73| 		delete current;
    74| 	}
    75| }
    76| template<typename LIST_TYPE, typename LIST_ITEM>
    77| static
    78| inline
    79| bool
    80| _rt_coreclr_list_append (
    81| 	LIST_TYPE *list,
    82| 	LIST_ITEM item)
    83| {
    84| 	STATIC_CONTRACT_NOTHROW;
    85| 	EP_ASSERT (list != NULL && list->list != NULL);
    86| 	typename LIST_TYPE::element_type_t *node = new (nothrow) typename LIST_TYPE::element_type_t (item);
    87| 	if (node)
    88| 		list->list->InsertTail (node);
    89| 	return (node != NULL);
    90| }
    91| template<typename LIST_TYPE, typename LIST_ITEM, typename CONST_LIST_ITEM = LIST_ITEM>
    92| static
    93| inline
    94| void
    95| _rt_coreclr_list_remove (
    96| 	LIST_TYPE *list,
    97| 	CONST_LIST_ITEM item)
    98| {
    99| 	STATIC_CONTRACT_NOTHROW;
   100| 	EP_ASSERT (list != NULL && list->list != NULL);
   101| 	typename LIST_TYPE::element_type_t *current = list->list->GetHead ();
   102| 	while (current) {
   103| 		if (current->GetValue () == item) {
   104| 			if (list->list->FindAndRemove (current))
   105| 					delete current;
   106| 			break;
   107| 		}
   108| 		current = list->list->GetNext (current);
   109| 	}
   110| }
   111| template<typename LIST_TYPE, typename LIST_ITEM, typename CONST_LIST_TYPE = const LIST_TYPE, typename CONST_LIST_ITEM = const LIST_ITEM>
   112| static
   113| inline
   114| bool
   115| _rt_coreclr_list_find (
   116| 	CONST_LIST_TYPE *list,
   117| 	CONST_LIST_ITEM item_to_find,
   118| 	LIST_ITEM *found_item)
   119| {
   120| 	STATIC_CONTRACT_NOTHROW;
   121| 	EP_ASSERT (list != NULL && list->list != NULL);
   122| 	EP_ASSERT (found_item != NULL);
   123| 	bool found = false;
   124| 	typename LIST_TYPE::element_type_t *current = list->list->GetHead ();
   125| 	while (current) {
   126| 		if (current->GetValue () == item_to_find) {
   127| 			*found_item = current->GetValue ();
   128| 			found = true;
   129| 			break;
   130| 		}
   131| 		current = list->list->GetNext (current);
   132| 	}
   133| 	return found;
   134| }
   135| template<typename LIST_TYPE, typename CONST_LIST_TYPE = const LIST_TYPE>
   136| static
   137| inline
   138| bool
   139| _rt_coreclr_list_is_empty (CONST_LIST_TYPE *list)
   140| {
   141| 	STATIC_CONTRACT_NOTHROW;
   142| 	EP_ASSERT (list != NULL);
   143| 	return (list->list == NULL || list->list->IsEmpty ());
   144| }
   145| template<typename LIST_TYPE, typename CONST_LIST_TYPE = const LIST_TYPE>
   146| static
   147| inline
   148| bool
   149| _rt_coreclr_list_is_valid (CONST_LIST_TYPE *list)
   150| {
   151| 	STATIC_CONTRACT_NOTHROW;
   152| 	return (list != NULL && list->list != NULL);
   153| }
   154| template<typename LIST_TYPE, typename ITERATOR_TYPE, typename CONST_LIST_TYPE = const LIST_TYPE>
   155| static
   156| inline
   157| ITERATOR_TYPE
   158| _rt_coreclr_list_iterator_begin (CONST_LIST_TYPE *list)
   159| {
   160| 	STATIC_CONTRACT_NOTHROW;
   161| 	EP_ASSERT (list != NULL && list->list != NULL);
   162| 	return list->list->begin ();
   163| }
   164| template<typename LIST_TYPE, typename ITERATOR_TYPE, typename CONST_LIST_TYPE = const LIST_TYPE, typename CONST_ITERATOR_TYPE = const ITERATOR_TYPE>
   165| static
   166| inline
   167| bool
   168| _rt_coreclr_list_iterator_end (
   169| 	CONST_LIST_TYPE *list,
   170| 	CONST_ITERATOR_TYPE *iterator)
   171| {
   172| 	STATIC_CONTRACT_NOTHROW;
   173| 	EP_ASSERT (list != NULL && list->list != NULL && iterator != NULL);
   174| 	return (*iterator == list->list->end ());
   175| }
   176| template<typename ITERATOR_TYPE>
   177| static
   178| inline
   179| void
   180| _rt_coreclr_list_iterator_next (ITERATOR_TYPE *iterator)
   181| {
   182| 	STATIC_CONTRACT_NOTHROW;
   183| 	EP_ASSERT (iterator != NULL);
   184| 	(*iterator)++;
   185| }
   186| template<typename ITERATOR_TYPE, typename ITEM_TYPE, typename CONST_ITERATOR_TYPE = const ITERATOR_TYPE>
   187| static
   188| inline
   189| ITEM_TYPE
   190| _rt_coreclr_list_iterator_value (CONST_ITERATOR_TYPE *iterator)
   191| {
   192| 	STATIC_CONTRACT_NOTHROW;
   193| 	EP_ASSERT (iterator != NULL);
   194| 	return const_cast<ITERATOR_TYPE *>(iterator)->operator*();
   195| }
   196| template<typename QUEUE_TYPE>
   197| static
   198| inline
   199| void
   200| _rt_coreclr_queue_alloc (QUEUE_TYPE *queue)
   201| {
   202| 	STATIC_CONTRACT_NOTHROW;
   203| 	EP_ASSERT (queue != NULL);
   204| 	queue->queue = new (nothrow) typename QUEUE_TYPE::queue_type_t ();
   205| }
   206| template<typename QUEUE_TYPE>
   207| static
   208| inline
   209| void
   210| _rt_coreclr_queue_free (QUEUE_TYPE *queue)
   211| {
   212| 	STATIC_CONTRACT_NOTHROW;
   213| 	EP_ASSERT (queue != NULL);
   214| 	if (queue->queue)
   215| 		delete queue->queue;
   216| 	queue->queue = NULL;
   217| }
   218| template<typename QUEUE_TYPE, typename ITEM_TYPE>
   219| static
   220| inline
   221| bool
   222| _rt_coreclr_queue_pop_head (
   223| 	QUEUE_TYPE *queue,
   224| 	ITEM_TYPE *item)
   225| {
   226| 	STATIC_CONTRACT_NOTHROW;
   227| 	EP_ASSERT (queue != NULL && queue->queue != NULL && item != NULL);
   228| 	bool found = true;
   229| 	typename QUEUE_TYPE::element_type_t *node = queue->queue->RemoveHead ();
   230| 	if (node) {
   231| 		*item = node->m_Value;
   232| 		delete node;
   233| 	} else {
   234| 		*item = NULL;
   235| 		found = false;
   236| 	}
   237| 	return found;
   238| }
   239| template<typename QUEUE_TYPE, typename ITEM_TYPE>
   240| static
   241| inline
   242| bool
   243| _rt_coreclr_queue_push_head (
   244| 	QUEUE_TYPE *queue,
   245| 	ITEM_TYPE item)
   246| {
   247| 	STATIC_CONTRACT_NOTHROW;
   248| 	EP_ASSERT (queue != NULL && queue->queue != NULL);
   249| 	typename QUEUE_TYPE::element_type_t *node = new (nothrow) typename QUEUE_TYPE::element_type_t (item);
   250| 	if (node)
   251| 		queue->queue->InsertHead (node);
   252| 	return (node != NULL);
   253| }
   254| template<typename QUEUE_TYPE, typename ITEM_TYPE>
   255| static
   256| inline
   257| bool
   258| _rt_coreclr_queue_push_tail (
   259| 	QUEUE_TYPE *queue,
   260| 	ITEM_TYPE item)
   261| {
   262| 	STATIC_CONTRACT_NOTHROW;
   263| 	EP_ASSERT (queue != NULL && queue->queue != NULL);
   264| 	typename QUEUE_TYPE::element_type_t *node = new (nothrow) typename QUEUE_TYPE::element_type_t (item);
   265| 	if (node)
   266| 		queue->queue->InsertTail (node);
   267| 	return (node != NULL);
   268| }
   269| template<typename QUEUE_TYPE, typename CONST_QUEUE_TYPE = const QUEUE_TYPE>
   270| static
   271| inline
   272| bool
   273| _rt_coreclr_queue_is_empty (CONST_QUEUE_TYPE *queue)
   274| {
   275| 	STATIC_CONTRACT_NOTHROW;
   276| 	EP_ASSERT (queue != NULL && queue->queue != NULL);
   277| 	return (queue->queue != NULL && queue->queue->IsEmpty ());
   278| }
   279| template<typename QUEUE_TYPE, typename CONST_QUEUE_TYPE = const QUEUE_TYPE>
   280| static
   281| inline
   282| bool
   283| _rt_coreclr_queue_is_valid (CONST_QUEUE_TYPE *queue)
   284| {
   285| 	STATIC_CONTRACT_NOTHROW;
   286| 	return (queue != NULL && queue->queue != NULL);
   287| }
   288| template<typename ARRAY_TYPE>
   289| static
   290| inline
   291| void
   292| _rt_coreclr_array_alloc (ARRAY_TYPE *ep_array)
   293| {
   294| 	STATIC_CONTRACT_NOTHROW;
   295| 	EP_ASSERT (ep_array != NULL);
   296| 	ep_array->array = new (nothrow) typename ARRAY_TYPE::array_type_t ();
   297| }
   298| template<typename ARRAY_TYPE>
   299| static
   300| inline
   301| void
   302| _rt_coreclr_array_alloc_capacity (
   303| 	ARRAY_TYPE *ep_array,
   304| 	size_t capacity)
   305| {
   306| 	STATIC_CONTRACT_NOTHROW;
   307| 	EP_ASSERT (ep_array != NULL);
   308| 	ep_array->array = new (nothrow) typename ARRAY_TYPE::array_type_t ();
   309| 	if (ep_array->array)
   310| 		ep_array->array->AllocNoThrow (capacity);
   311| }
   312| template<typename ARRAY_TYPE>
   313| static
   314| inline
   315| void
   316| _rt_coreclr_array_init_capacity (
   317| 	ARRAY_TYPE *ep_array,
   318| 	size_t capacity)
   319| {
   320| 	STATIC_CONTRACT_NOTHROW;
   321| 	EP_ASSERT (ep_array != NULL);
   322| 	if (ep_array->array)
   323| 		ep_array->array->AllocNoThrow (capacity);
   324| }
   325| template<typename ARRAY_TYPE>
   326| static
   327| inline
   328| void
   329| _rt_coreclr_array_free (ARRAY_TYPE *ep_array)
   330| {
   331| 	STATIC_CONTRACT_NOTHROW;
   332| 	EP_ASSERT (ep_array != NULL);
   333| 	if (ep_array->array) {
   334| 		delete ep_array->array;
   335| 		ep_array->array = NULL;
   336| 	}
   337| }
   338| template<typename ARRAY_TYPE, typename ITEM_TYPE>
   339| static
   340| inline
   341| bool
   342| _rt_coreclr_array_append (
   343| 	ARRAY_TYPE *ep_array,
   344| 	ITEM_TYPE item)
   345| {
   346| 	STATIC_CONTRACT_NOTHROW;
   347| 	EP_ASSERT (ep_array != NULL && ep_array->array != NULL);
   348| 	return ep_array->array->PushNoThrow (item);
   349| }
   350| template<typename ARRAY_TYPE, typename ITEM_TYPE>
   351| static
   352| inline
   353| void
   354| _rt_coreclr_array_clear (ARRAY_TYPE *ep_array)
   355| {
   356| 	STATIC_CONTRACT_NOTHROW;
   357| 	EP_ASSERT (ep_array != NULL && ep_array->array != NULL);
   358| 	while (ep_array->array->Size () > 0)
   359| 		ITEM_TYPE item = ep_array->array->Pop ();
   360| 	ep_array->array->Shrink ();
   361| }
   362| template<typename ARRAY_TYPE, typename CONST_ARRAY_TYPE = const ARRAY_TYPE>
   363| static
   364| inline
   365| size_t
   366| _rt_coreclr_array_size (CONST_ARRAY_TYPE *ep_array)
   367| {
   368| 	STATIC_CONTRACT_NOTHROW;
   369| 	EP_ASSERT (ep_array != NULL && ep_array->array != NULL);
   370| 	return ep_array->array->Size ();
   371| }
   372| template<typename ARRAY_TYPE, typename ITEM_TYPE, typename CONST_ARRAY_TYPE = const ARRAY_TYPE>
   373| static
   374| inline
   375| ITEM_TYPE *
   376| _rt_coreclr_array_data (CONST_ARRAY_TYPE *ep_array)
   377| {
   378| 	STATIC_CONTRACT_NOTHROW;
   379| 	EP_ASSERT (ep_array != NULL && ep_array->array != NULL);
   380| 	return ep_array->array->Ptr ();
   381| }
   382| template<typename ARRAY_TYPE, typename CONST_ARRAY_TYPE = const ARRAY_TYPE>
   383| static
   384| inline
   385| bool
   386| _rt_coreclr_array_is_valid (CONST_ARRAY_TYPE *ep_array)
   387| {
   388| 	STATIC_CONTRACT_NOTHROW;
   389| 	return (ep_array->array != NULL);
   390| }
   391| template<typename ARRAY_TYPE, typename ITERATOR_TYPE, typename CONST_ARRAY_TYPE = const ARRAY_TYPE>
   392| static
   393| inline
   394| ITERATOR_TYPE
   395| _rt_coreclr_array_iterator_begin (CONST_ARRAY_TYPE *ep_array)
   396| {
   397| 	STATIC_CONTRACT_NOTHROW;
   398| 	EP_ASSERT (ep_array != NULL && ep_array->array != NULL);
   399| 	ITERATOR_TYPE temp;
   400| 	temp.array = ep_array->array;
   401| 	temp.index = 0;
   402| 	return temp;
   403| }
   404| template<typename ARRAY_TYPE, typename ITERATOR_TYPE, typename CONST_ARRAY_TYPE = const ARRAY_TYPE, typename CONST_ITERATOR_TYPE = const ITERATOR_TYPE>
   405| static
   406| inline
   407| bool
   408| _rt_coreclr_array_iterator_end (
   409| 	CONST_ARRAY_TYPE *ep_array,
   410| 	CONST_ITERATOR_TYPE *iterator)
   411| {
   412| 	STATIC_CONTRACT_NOTHROW;
   413| 	EP_ASSERT (ep_array != NULL && iterator != NULL && iterator->array != NULL);
   414| 	return (iterator->index >= static_cast<size_t>(iterator->array->Size ()));
   415| }
   416| template<typename ITERATOR_TYPE>
   417| static
   418| inline
   419| void
   420| _rt_coreclr_array_iterator_next (ITERATOR_TYPE *iterator)
   421| {
   422| 	STATIC_CONTRACT_NOTHROW;
   423| 	EP_ASSERT (iterator != NULL);
   424| 	iterator->index++;
   425| }
   426| template<typename ITERATOR_TYPE, typename ITEM_TYPE, typename CONST_ITERATOR_TYPE = const ITERATOR_TYPE>
   427| static
   428| inline
   429| ITEM_TYPE
   430| _rt_coreclr_array_iterator_value (const CONST_ITERATOR_TYPE *iterator)
   431| {
   432| 	STATIC_CONTRACT_NOTHROW;
   433| 	EP_ASSERT (iterator != NULL && iterator->array != NULL);
   434| 	EP_ASSERT (iterator->index < static_cast<size_t>(iterator->array->Size ()));
   435| 	return iterator->array->operator[] (iterator->index);
   436| }
   437| template<typename ARRAY_TYPE, typename ITERATOR_TYPE, typename CONST_ARRAY_TYPE = const ARRAY_TYPE>
   438| static
   439| inline
   440| ITERATOR_TYPE
   441| _rt_coreclr_array_reverse_iterator_begin (CONST_ARRAY_TYPE *ep_array)
   442| {
   443| 	STATIC_CONTRACT_NOTHROW;
   444| 	EP_ASSERT (ep_array != NULL && ep_array->array != NULL);
   445| 	ITERATOR_TYPE temp;
   446| 	temp.array = ep_array->array;
   447| 	temp.index = static_cast<size_t>(ep_array->array->Size ());
   448| 	return temp;
   449| }
   450| template<typename ARRAY_TYPE, typename ITERATOR_TYPE, typename CONST_ARRAY_TYPE = const ARRAY_TYPE, typename CONST_ITERATOR_TYPE = const ITERATOR_TYPE>
   451| static
   452| inline
   453| bool
   454| _rt_coreclr_array_reverse_iterator_end (
   455| 	CONST_ARRAY_TYPE *ep_array,
   456| 	CONST_ITERATOR_TYPE *iterator)
   457| {
   458| 	STATIC_CONTRACT_NOTHROW;
   459| 	EP_ASSERT (ep_array != NULL && iterator != NULL && iterator->array != NULL);
   460| 	return (iterator->index == 0);
   461| }
   462| template<typename ITERATOR_TYPE>
   463| static
   464| inline
   465| void
   466| _rt_coreclr_array_reverse_iterator_next (ITERATOR_TYPE *iterator)
   467| {
   468| 	STATIC_CONTRACT_NOTHROW;
   469| 	EP_ASSERT (iterator != NULL);
   470| 	iterator->index--;
   471| }
   472| template<typename ITERATOR_TYPE, typename ITEM_TYPE, typename CONST_ITERATOR_TYPE = const ITERATOR_TYPE>
   473| static
   474| inline
   475| ITEM_TYPE
   476| _rt_coreclr_array_reverse_iterator_value (CONST_ITERATOR_TYPE *iterator)
   477| {
   478| 	STATIC_CONTRACT_NOTHROW;
   479| 	EP_ASSERT (iterator != NULL && iterator->array != NULL);
   480| 	EP_ASSERT (iterator->index > 0);
   481| 	return iterator->array->operator[] (iterator->index - 1);
   482| }
   483| template<typename HASH_MAP_TYPE>
   484| static
   485| inline
   486| void
   487| _rt_coreclr_hash_map_alloc (
   488| 	HASH_MAP_TYPE *hash_map,
   489| 	uint32_t (*hash_callback)(const void *),
   490| 	bool (*eq_callback)(const void *, const void *),
   491| 	void (*key_free_callback)(void *),
   492| 	void (*value_free_callback)(void *))
   493| {
   494| 	STATIC_CONTRACT_NOTHROW;
   495| 	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
   496| 	EP_ASSERT (hash_map != NULL && key_free_callback == NULL);
   497| 	hash_map->table = new (nothrow) typename HASH_MAP_TYPE::table_type_t ();
   498| 	hash_map->callbacks.key_free_func = key_free_callback;
   499| 	hash_map->callbacks.value_free_func = value_free_callback;
   500| }
   501| template<typename HASH_MAP_TYPE>
   502| static
   503| inline
   504| void
   505| _rt_coreclr_hash_map_free (HASH_MAP_TYPE *hash_map)
   506| {
   507| 	STATIC_CONTRACT_NOTHROW;
   508| 	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
   509| 	EP_ASSERT (hash_map != NULL);
   510| 	if (hash_map->table) {
   511| 		if (hash_map->callbacks.value_free_func) {
   512| 			for (typename HASH_MAP_TYPE::table_type_t::Iterator iterator = hash_map->table->Begin (); iterator != hash_map->table->End (); ++iterator)
   513| 					hash_map->callbacks.value_free_func (reinterpret_cast<void *>((ptrdiff_t)(iterator->Value ())));
   514| 		}
   515| 		delete hash_map->table;
   516| 	}
   517| }
   518| template<typename HASH_MAP_TYPE, typename KEY_TYPE, typename VALUE_TYPE>
   519| static
   520| inline
   521| bool
   522| _rt_coreclr_hash_map_add (
   523| 	HASH_MAP_TYPE *hash_map,
   524| 	KEY_TYPE key,
   525| 	VALUE_TYPE value)
   526| {
   527| 	STATIC_CONTRACT_NOTHROW;
   528| 	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
   529| 	EP_ASSERT (hash_map != NULL && hash_map->table != NULL);
   530| 	return hash_map->table->AddNoThrow (typename HASH_MAP_TYPE::table_type_t::element_t (key, value));
   531| }
   532| template<typename HASH_MAP_TYPE, typename KEY_TYPE, typename VALUE_TYPE>
   533| static
   534| inline
   535| bool
   536| _rt_coreclr_hash_map_add_or_replace (
   537| 	HASH_MAP_TYPE *hash_map,
   538| 	KEY_TYPE key,
   539| 	VALUE_TYPE value)
   540| {
   541| 	STATIC_CONTRACT_NOTHROW;
   542| 	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
   543| 	EP_ASSERT (hash_map != NULL && hash_map->table != NULL);
   544| 	return hash_map->table->AddOrReplaceNoThrow (typename HASH_MAP_TYPE::table_type_t::element_t (key, value));
   545| }
   546| template<typename HASH_MAP_TYPE>
   547| static
   548| inline
   549| void
   550| _rt_coreclr_hash_map_remove_all (HASH_MAP_TYPE *hash_map)
   551| {
   552| 	STATIC_CONTRACT_NOTHROW;
   553| 	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
   554| 	EP_ASSERT (hash_map != NULL && hash_map->table != NULL);
   555| 	if (hash_map->callbacks.value_free_func) {
   556| 		for (typename HASH_MAP_TYPE::table_type_t::Iterator iterator = hash_map->table->Begin (); iterator != hash_map->table->End (); ++iterator)
   557| 			hash_map->callbacks.value_free_func (reinterpret_cast<void *>((ptrdiff_t)(iterator->Value ())));
   558| 	}
   559| 	hash_map->table->RemoveAll ();
   560| }
   561| template<typename HASH_MAP_TYPE, typename KEY_TYPE, typename VALUE_TYPE, typename CONST_HASH_MAP_TYPE = const HASH_MAP_TYPE, typename CONST_KEY_TYPE = const KEY_TYPE>
   562| static
   563| inline
   564| bool
   565| _rt_coreclr_hash_map_lookup (
   566| 	CONST_HASH_MAP_TYPE *hash_map,
   567| 	CONST_KEY_TYPE key,
   568| 	VALUE_TYPE *value)
   569| {
   570| 	STATIC_CONTRACT_NOTHROW;
   571| 	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
   572| 	EP_ASSERT (hash_map != NULL && hash_map->table != NULL);
   573| 	const typename HASH_MAP_TYPE::table_type_t::element_t *ret = hash_map->table->LookupPtr ((KEY_TYPE)key);
   574| 	if (ret == NULL)
   575| 		return false;
   576| 	*value = ret->Value ();
   577| 	return true;
   578| }
   579| template<typename HASH_MAP_TYPE, typename CONST_HASH_MAP_TYPE = const HASH_MAP_TYPE>
   580| static
   581| inline
   582| uint32_t
   583| _rt_coreclr_hash_map_count (CONST_HASH_MAP_TYPE *hash_map)
   584| {
   585| 	STATIC_CONTRACT_NOTHROW;
   586| 	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
   587| 	EP_ASSERT (hash_map != NULL && hash_map->table != NULL);
   588| 	return hash_map->table->GetCount ();
   589| }
   590| template<typename HASH_MAP_TYPE, typename CONST_HASH_MAP_TYPE = const HASH_MAP_TYPE>
   591| static
   592| inline
   593| bool
   594| _rt_coreclr_hash_map_is_valid (CONST_HASH_MAP_TYPE *hash_map)
   595| {
   596| 	STATIC_CONTRACT_NOTHROW;
   597| 	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
   598| 	return (hash_map != NULL && hash_map->table != NULL);
   599| }
   600| template<typename HASH_MAP_TYPE, typename KEY_TYPE, typename CONST_KEY_TYPE = const KEY_TYPE>
   601| static
   602| inline
   603| void
   604| _rt_coreclr_hash_map_remove (
   605| 	HASH_MAP_TYPE *hash_map,
   606| 	CONST_KEY_TYPE key)
   607| {
   608| 	STATIC_CONTRACT_NOTHROW;
   609| 	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
   610| 	EP_ASSERT (hash_map != NULL && hash_map->table != NULL);
   611| 	const typename HASH_MAP_TYPE::table_type_t::element_t *ret = NULL;
   612| 	if (hash_map->callbacks.value_free_func)
   613| 		ret = hash_map->table->LookupPtr ((KEY_TYPE)key);
   614| 	hash_map->table->Remove ((KEY_TYPE)key);
   615| 	if (ret)
   616| 		hash_map->callbacks.value_free_func (reinterpret_cast<void *>(static_cast<ptrdiff_t>(ret->Value ())));
   617| }
   618| template<typename HASH_MAP_TYPE, typename ITERATOR_TYPE, typename CONST_HASH_MAP_TYPE = const HASH_MAP_TYPE>
   619| static
   620| inline
   621| ITERATOR_TYPE
   622| _rt_coreclr_hash_map_iterator_begin (CONST_HASH_MAP_TYPE *hash_map)
   623| {
   624| 	STATIC_CONTRACT_NOTHROW;
   625| 	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
   626| 	EP_ASSERT (hash_map != NULL && hash_map->table != NULL);
   627| 	return hash_map->table->Begin ();
   628| }
   629| template<typename HASH_MAP_TYPE, typename ITERATOR_TYPE, typename CONST_HASH_MAP_TYPE = const HASH_MAP_TYPE, typename CONST_ITERATOR_TYPE = const ITERATOR_TYPE>
   630| static
   631| inline
   632| bool
   633| _rt_coreclr_hash_map_iterator_end (
   634| 	CONST_HASH_MAP_TYPE *hash_map,
   635| 	CONST_ITERATOR_TYPE *iterator)
   636| {
   637| 	STATIC_CONTRACT_NOTHROW;
   638| 	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
   639| 	EP_ASSERT (hash_map != NULL && hash_map->table != NULL && iterator != NULL);
   640| 	return (hash_map->table->End () == *iterator);
   641| }
   642| template<typename HASH_MAP_TYPE, typename ITERATOR_TYPE>
   643| static
   644| inline
   645| void
   646| _rt_coreclr_hash_map_iterator_next (ITERATOR_TYPE *iterator)
   647| {
   648| 	STATIC_CONTRACT_NOTHROW;
   649| 	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
   650| 	EP_ASSERT (iterator != NULL);
   651| 	(*iterator)++;
   652| }
   653| template<typename HASH_MAP_TYPE, typename ITERATOR_TYPE, typename KEY_TYPE, typename CONST_ITERATOR_TYPE = const ITERATOR_TYPE>
   654| static
   655| inline
   656| KEY_TYPE
   657| _rt_coreclr_hash_map_iterator_key (CONST_ITERATOR_TYPE *iterator)
   658| {
   659| 	STATIC_CONTRACT_NOTHROW;
   660| 	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
   661| 	EP_ASSERT (iterator != NULL);
   662| 	return (*iterator)->Key ();
   663| }
   664| template<typename HASH_MAP_TYPE, typename ITERATOR_TYPE, typename VALUE_TYPE, typename CONST_ITERATOR_TYPE = const ITERATOR_TYPE>
   665| static
   666| inline
   667| VALUE_TYPE
   668| _rt_coreclr_hash_map_iterator_value (CONST_ITERATOR_TYPE *iterator)
   669| {
   670| 	STATIC_CONTRACT_NOTHROW;
   671| 	EP_ASSERT (HASH_MAP_TYPE::table_type_t::s_NoThrow);
   672| 	EP_ASSERT (iterator != NULL);
   673| 	return (*iterator)->Value ();
   674| }
   675| #define EP_RT_DEFINE_LIST_PREFIX(prefix_name, list_name, list_type, item_type) \
   676| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, alloc) (list_type *list) \
   677| 	{ \
   678| 		STATIC_CONTRACT_NOTHROW; \
   679| 		_rt_coreclr_list_alloc<list_type>(list); \
   680| 	} \
   681| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, free) (list_type *list, void (*callback)(void *)) \
   682| 	{ \
   683| 		STATIC_CONTRACT_NOTHROW; \
   684| 		_rt_coreclr_list_free<list_type>(list, callback); \
   685| 	} \
   686| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, clear) (list_type *list, void (*callback)(void *)) \
   687| 	{ \
   688| 		STATIC_CONTRACT_NOTHROW; \
   689| 		_rt_coreclr_list_clear<list_type>(list, callback); \
   690| 	} \
   691| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, append) (list_type *list, item_type item) \
   692| 	{ \
   693| 		STATIC_CONTRACT_NOTHROW; \
   694| 		return _rt_coreclr_list_append<list_type, item_type>(list, item); \
   695| 	} \
   696| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, remove) (list_type *list, const item_type item) \
   697| 	{ \
   698| 		STATIC_CONTRACT_NOTHROW; \
   699| 		_rt_coreclr_list_remove<list_type, item_type>(list, item); \
   700| 	} \
   701| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, find) (const list_type *list, const item_type item_to_find, item_type *found_item) \
   702| 	{ \
   703| 		STATIC_CONTRACT_NOTHROW; \
   704| 		return _rt_coreclr_list_find<list_type, item_type>(list, item_to_find, found_item); \
   705| 	} \
   706| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, is_empty) (const list_type *list) \
   707| 	{ \
   708| 		STATIC_CONTRACT_NOTHROW; \
   709| 		return _rt_coreclr_list_is_empty<list_type>(list); \
   710| 	} \
   711| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, is_valid) (const list_type *list) \
   712| 	{ \
   713| 		STATIC_CONTRACT_NOTHROW; \
   714| 		return _rt_coreclr_list_is_valid<list_type>(list); \
   715| 	}
   716| #undef EP_RT_DEFINE_LIST
   717| #define EP_RT_DEFINE_LIST(list_name, list_type, item_type) \
   718| 	EP_RT_DEFINE_LIST_PREFIX(ep, list_name, list_type, item_type)
   719| #define EP_RT_DEFINE_LIST_ITERATOR_PREFIX(prefix_name, list_name, list_type, iterator_type, item_type) \
   720| 	static inline iterator_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, iterator_begin) (const list_type *list) \
   721| 	{ \
   722| 		STATIC_CONTRACT_NOTHROW; \
   723| 		return _rt_coreclr_list_iterator_begin<list_type, iterator_type>(list); \
   724| 	} \
   725| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, iterator_end) (const list_type *list, const iterator_type *iterator) \
   726| 	{ \
   727| 		STATIC_CONTRACT_NOTHROW; \
   728| 		return _rt_coreclr_list_iterator_end<list_type, iterator_type>(list, iterator); \
   729| 	} \
   730| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, iterator_next) (iterator_type *iterator) \
   731| 	{ \
   732| 		STATIC_CONTRACT_NOTHROW; \
   733| 		_rt_coreclr_list_iterator_next<iterator_type>(iterator); \
   734| 	} \
   735| 	static inline item_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, iterator_value) (const iterator_type *iterator) \
   736| 	{ \
   737| 		STATIC_CONTRACT_NOTHROW; \
   738| 		return _rt_coreclr_list_iterator_value<iterator_type, item_type>(iterator); \
   739| 	}
   740| #undef EP_RT_DEFINE_LIST_ITERATOR
   741| #define EP_RT_DEFINE_LIST_ITERATOR(list_name, list_type, iterator_type, item_type) \
   742| 	EP_RT_DEFINE_LIST_ITERATOR_PREFIX(ep, list_name, list_type, iterator_type, item_type)
   743| #define EP_RT_DEFINE_QUEUE_PREFIX(prefix_name, queue_name, queue_type, item_type) \
   744| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, alloc) (queue_type *queue) \
   745| 	{ \
   746| 		STATIC_CONTRACT_NOTHROW; \
   747| 		_rt_coreclr_queue_alloc<queue_type>(queue); \
   748| 	} \
   749| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, free) (queue_type *queue) \
   750| 	{ \
   751| 		STATIC_CONTRACT_NOTHROW; \
   752| 		_rt_coreclr_queue_free<queue_type>(queue); \
   753| 	} \
   754| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, pop_head) (queue_type *queue, item_type *item) \
   755| 	{ \
   756| 		STATIC_CONTRACT_NOTHROW; \
   757| 		return _rt_coreclr_queue_pop_head<queue_type, item_type>(queue, item); \
   758| 	} \
   759| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, push_head) (queue_type *queue, item_type item) \
   760| 	{ \
   761| 		STATIC_CONTRACT_NOTHROW; \
   762| 		return _rt_coreclr_queue_push_head<queue_type, item_type>(queue, item); \
   763| 	} \
   764| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, push_tail) (queue_type *queue, item_type item) \
   765| 	{ \
   766| 		STATIC_CONTRACT_NOTHROW; \
   767| 		return _rt_coreclr_queue_push_tail<queue_type, item_type>(queue, item); \
   768| 	} \
   769| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, is_empty) (const queue_type *queue) \
   770| 	{ \
   771| 		STATIC_CONTRACT_NOTHROW; \
   772| 		return _rt_coreclr_queue_is_empty<queue_type>(queue); \
   773| 	} \
   774| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, is_valid) (const queue_type *queue) \
   775| 	{ \
   776| 		STATIC_CONTRACT_NOTHROW; \
   777| 		return _rt_coreclr_queue_is_valid<queue_type>(queue); \
   778| 	}
   779| #undef EP_RT_DEFINE_QUEUE
   780| #define EP_RT_DEFINE_QUEUE(queue_name, queue_type, item_type) \
   781| 	EP_RT_DEFINE_QUEUE_PREFIX(ep, queue_name, queue_type, item_type)
   782| #define EP_RT_DEFINE_ARRAY_PREFIX(prefix_name, array_name, array_type, iterator_type, item_type) \
   783| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, alloc) (array_type *ep_array) \
   784| 	{ \
   785| 		STATIC_CONTRACT_NOTHROW; \
   786| 		_rt_coreclr_array_alloc<array_type>(ep_array); \
   787| 	} \
   788| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, alloc_capacity) (array_type *ep_array, size_t capacity) \
   789| 	{ \
   790| 		STATIC_CONTRACT_NOTHROW; \
   791| 		_rt_coreclr_array_alloc_capacity<array_type>(ep_array, capacity); \
   792| 	} \
   793| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, free) (array_type *ep_array) \
   794| 	{ \
   795| 		STATIC_CONTRACT_NOTHROW; \
   796| 		_rt_coreclr_array_free<array_type>(ep_array); \
   797| 	} \
   798| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, append) (array_type *ep_array, item_type item) \
   799| 	{ \
   800| 		STATIC_CONTRACT_NOTHROW; \
   801| 		return _rt_coreclr_array_append<array_type, item_type> (ep_array, item); \
   802| 	} \
   803| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, clear) (array_type *ep_array) \
   804| 	{ \
   805| 		STATIC_CONTRACT_NOTHROW; \
   806| 		_rt_coreclr_array_clear<array_type, item_type> (ep_array); \
   807| 	} \
   808| 	static inline size_t EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, size) (const array_type *ep_array) \
   809| 	{ \
   810| 		STATIC_CONTRACT_NOTHROW; \
   811| 		return _rt_coreclr_array_size<array_type> (ep_array); \
   812| 	} \
   813| 	static inline item_type * EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, data) (const array_type *ep_array) \
   814| 	{ \
   815| 		STATIC_CONTRACT_NOTHROW; \
   816| 		return _rt_coreclr_array_data<array_type, item_type> (ep_array); \
   817| 	} \
   818| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, is_valid) (const array_type *ep_array) \
   819| 	{ \
   820| 		STATIC_CONTRACT_NOTHROW; \
   821| 		return _rt_coreclr_array_is_valid<array_type> (ep_array); \
   822| 	}
   823| #define EP_RT_DEFINE_LOCAL_ARRAY_PREFIX(prefix_name, array_name, array_type, iterator_type, item_type) \
   824| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, init) (array_type *ep_array) { \
   825| 		STATIC_CONTRACT_NOTHROW; \
   826| 	} \
   827| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, init_capacity) (array_type *ep_array, size_t capacity) { \
   828| 		STATIC_CONTRACT_NOTHROW; \
   829| 		_rt_coreclr_array_init_capacity<array_type>(ep_array, capacity); \
   830| 	} \
   831| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, fini) (array_type *ep_array) { \
   832| 		STATIC_CONTRACT_NOTHROW; \
   833| 	}
   834| #undef EP_RT_DEFINE_ARRAY
   835| #define EP_RT_DEFINE_ARRAY(array_name, array_type, iterator_type, item_type) \
   836| 	EP_RT_DEFINE_ARRAY_PREFIX(ep, array_name, array_type, iterator_type, item_type)
   837| #undef EP_RT_DEFINE_LOCAL_ARRAY
   838| #define EP_RT_DEFINE_LOCAL_ARRAY(array_name, array_type, iterator_type, item_type) \
   839| 	EP_RT_DEFINE_LOCAL_ARRAY_PREFIX(ep, array_name, array_type, iterator_type, item_type)
   840| #define EP_RT_DECLARE_LOCAL_ARRAY_VARIABLE(var_name, var_type) \
   841| 	var_type::array_type_t _local_ ##var_name; \
   842| 	var_type var_name; \
   843| 	var_name.array = &_local_ ##var_name
   844| #define EP_RT_DEFINE_ARRAY_ITERATOR_PREFIX(prefix_name, array_name, array_type, iterator_type, item_type) \
   845| 	static inline iterator_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, iterator_begin) (const array_type *ep_array) \
   846| 	{ \
   847| 		STATIC_CONTRACT_NOTHROW; \
   848| 		return _rt_coreclr_array_iterator_begin<array_type, iterator_type> (ep_array); \
   849| 	} \
   850| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, iterator_end) (const array_type *ep_array, const iterator_type *iterator) \
   851| 	{ \
   852| 		STATIC_CONTRACT_NOTHROW; \
   853| 		return _rt_coreclr_array_iterator_end<array_type, iterator_type> (ep_array, iterator); \
   854| 	} \
   855| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, iterator_next) (iterator_type *iterator) \
   856| 	{ \
   857| 		STATIC_CONTRACT_NOTHROW; \
   858| 		_rt_coreclr_array_iterator_next<iterator_type> (iterator); \
   859| 	} \
   860| 	static inline item_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, iterator_value) (const iterator_type *iterator) \
   861| 	{ \
   862| 		STATIC_CONTRACT_NOTHROW; \
   863| 		return _rt_coreclr_array_iterator_value<iterator_type, item_type> (iterator); \
   864| 	}
   865| #define EP_RT_DEFINE_ARRAY_REVERSE_ITERATOR_PREFIX(prefix_name, array_name, array_type, iterator_type, item_type) \
   866| 	static inline iterator_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, reverse_iterator_begin) (const array_type *ep_array) \
   867| 	{ \
   868| 		STATIC_CONTRACT_NOTHROW; \
   869| 		return _rt_coreclr_array_reverse_iterator_begin<array_type, iterator_type> (ep_array); \
   870| 	} \
   871| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, reverse_iterator_end) (const array_type *ep_array, const iterator_type *iterator) \
   872| 	{ \
   873| 		STATIC_CONTRACT_NOTHROW; \
   874| 		return _rt_coreclr_array_reverse_iterator_end<array_type, iterator_type> (ep_array, iterator); \
   875| 	} \
   876| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, reverse_iterator_next) (iterator_type *iterator) \
   877| 	{ \
   878| 		STATIC_CONTRACT_NOTHROW; \
   879| 		_rt_coreclr_array_reverse_iterator_next<iterator_type> (iterator); \
   880| 	} \
   881| 	static inline item_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, reverse_iterator_value) (const iterator_type *iterator) \
   882| 	{ \
   883| 		STATIC_CONTRACT_NOTHROW; \
   884| 		return _rt_coreclr_array_reverse_iterator_value<iterator_type, item_type> (iterator); \
   885| 	}
   886| #undef EP_RT_DEFINE_ARRAY_ITERATOR
   887| #define EP_RT_DEFINE_ARRAY_ITERATOR(array_name, array_type, iterator_type, item_type) \
   888| 	EP_RT_DEFINE_ARRAY_ITERATOR_PREFIX(ep, array_name, array_type, iterator_type, item_type)
   889| #undef EP_RT_DEFINE_ARRAY_REVERSE_ITERATOR
   890| #define EP_RT_DEFINE_ARRAY_REVERSE_ITERATOR(array_name, array_type, iterator_type, item_type) \
   891| 	EP_RT_DEFINE_ARRAY_REVERSE_ITERATOR_PREFIX(ep, array_name, array_type, iterator_type, item_type)
   892| #define EP_RT_DEFINE_HASH_MAP_BASE_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
   893| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, alloc) (hash_map_type *hash_map, uint32_t (*hash_callback)(const void *), bool (*eq_callback)(const void *, const void *), void (*key_free_callback)(void *), void (*value_free_callback)(void *)) \
   894| 	{ \
   895| 		STATIC_CONTRACT_NOTHROW; \
   896| 		_rt_coreclr_hash_map_alloc<hash_map_type>(hash_map, hash_callback, eq_callback, key_free_callback, value_free_callback); \
   897| 	} \
   898| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, free) (hash_map_type *hash_map) \
   899| 	{ \
   900| 		STATIC_CONTRACT_NOTHROW; \
   901| 		_rt_coreclr_hash_map_free<hash_map_type>(hash_map); \
   902| 	} \
   903| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, add) (hash_map_type *hash_map, key_type key, value_type value) \
   904| 	{ \
   905| 		STATIC_CONTRACT_NOTHROW; \
   906| 		return _rt_coreclr_hash_map_add<hash_map_type, key_type, value_type>(hash_map, key, value); \
   907| 	} \
   908| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, remove_all) (hash_map_type *hash_map) \
   909| 	{ \
   910| 		STATIC_CONTRACT_NOTHROW; \
   911| 		_rt_coreclr_hash_map_remove_all<hash_map_type>(hash_map); \
   912| 	} \
   913| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, lookup) (const hash_map_type *hash_map, const key_type key, value_type *value) \
   914| 	{ \
   915| 		STATIC_CONTRACT_NOTHROW; \
   916| 		return _rt_coreclr_hash_map_lookup<hash_map_type, key_type, value_type>(hash_map, key, value); \
   917| 	} \
   918| 	static inline uint32_t EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, count) (const hash_map_type *hash_map) \
   919| 	{ \
   920| 		STATIC_CONTRACT_NOTHROW; \
   921| 		return _rt_coreclr_hash_map_count<hash_map_type>(hash_map); \
   922| 	} \
   923| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, is_valid) (const hash_map_type *hash_map) \
   924| 	{ \
   925| 		STATIC_CONTRACT_NOTHROW; \
   926| 		return _rt_coreclr_hash_map_is_valid<hash_map_type>(hash_map); \
   927| 	}
   928| #define EP_RT_DEFINE_HASH_MAP_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
   929| 	EP_RT_DEFINE_HASH_MAP_BASE_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
   930| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, add_or_replace) (hash_map_type *hash_map, key_type key, value_type value) \
   931| 	{ \
   932| 		STATIC_CONTRACT_NOTHROW; \
   933| 		return _rt_coreclr_hash_map_add_or_replace<hash_map_type, key_type, value_type>(hash_map, key, value); \
   934| 	} \
   935| #define EP_RT_DEFINE_HASH_MAP_REMOVE_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
   936| 	EP_RT_DEFINE_HASH_MAP_BASE_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
   937| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, remove) (hash_map_type *hash_map, const key_type key) \
   938| 	{ \
   939| 		STATIC_CONTRACT_NOTHROW; \
   940| 		_rt_coreclr_hash_map_remove<hash_map_type, key_type>(hash_map, key); \
   941| 	}
   942| #undef EP_RT_DEFINE_HASH_MAP
   943| #define EP_RT_DEFINE_HASH_MAP(hash_map_name, hash_map_type, key_type, value_type) \
   944| 	EP_RT_DEFINE_HASH_MAP_PREFIX(ep, hash_map_name, hash_map_type, key_type, value_type)
   945| #undef EP_RT_DEFINE_HASH_MAP_REMOVE
   946| #define EP_RT_DEFINE_HASH_MAP_REMOVE(hash_map_name, hash_map_type, key_type, value_type) \
   947| 	EP_RT_DEFINE_HASH_MAP_REMOVE_PREFIX(ep, hash_map_name, hash_map_type, key_type, value_type)
   948| #define EP_RT_DEFINE_HASH_MAP_ITERATOR_PREFIX(prefix_name, hash_map_name, hash_map_type, iterator_type, key_type, value_type) \
   949| 	static inline iterator_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_begin) (const hash_map_type *hash_map) \
   950| 	{ \
   951| 		STATIC_CONTRACT_NOTHROW; \
   952| 		return _rt_coreclr_hash_map_iterator_begin<hash_map_type, iterator_type>(hash_map); \
   953| 	} \
   954| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_end) (const hash_map_type *hash_map, const iterator_type *iterator) \
   955| 	{ \
   956| 		STATIC_CONTRACT_NOTHROW; \
   957| 		return _rt_coreclr_hash_map_iterator_end<hash_map_type, iterator_type>(hash_map, iterator); \
   958| 	} \
   959| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_next) (iterator_type *iterator) \
   960| 	{ \
   961| 		STATIC_CONTRACT_NOTHROW; \
   962| 		_rt_coreclr_hash_map_iterator_next<hash_map_type, iterator_type>(iterator); \
   963| 	} \
   964| 	static inline key_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_key) (const iterator_type *iterator) \
   965| 	{ \
   966| 		STATIC_CONTRACT_NOTHROW; \
   967| 		return _rt_coreclr_hash_map_iterator_key<hash_map_type, iterator_type, key_type>(iterator); \
   968| 	} \
   969| 	static inline value_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_value) (const iterator_type *iterator) \
   970| 	{ \
   971| 		STATIC_CONTRACT_NOTHROW; \
   972| 		return _rt_coreclr_hash_map_iterator_value<hash_map_type, iterator_type, value_type>(iterator); \
   973| 	}
   974| #undef EP_RT_DEFINE_HASH_MAP_ITERATOR
   975| #define EP_RT_DEFINE_HASH_MAP_ITERATOR(hash_map_name, hash_map_type, iterator_type, key_type, value_type) \
   976| 	EP_RT_DEFINE_HASH_MAP_ITERATOR_PREFIX(ep, hash_map_name, hash_map_type, iterator_type, key_type, value_type)
   977| static
   978| inline
   979| ep_rt_lock_handle_t *
   980| ep_rt_coreclr_config_lock_get (void)
   981| {
   982| 	STATIC_CONTRACT_NOTHROW;
   983| 	extern ep_rt_lock_handle_t _ep_rt_coreclr_config_lock_handle;
   984| 	return &_ep_rt_coreclr_config_lock_handle;
   985| }
   986| static
   987| inline
   988| const ep_char8_t *
   989| ep_rt_entrypoint_assembly_name_get_utf8 (void)
   990| {
   991| 	STATIC_CONTRACT_NOTHROW;
   992| 	AppDomain *app_domain_ref = nullptr;
   993| 	Assembly *assembly_ref = nullptr;
   994| 	app_domain_ref = GetAppDomain ();
   995| 	if (app_domain_ref != nullptr)
   996| 	{
   997| 		assembly_ref = app_domain_ref->GetRootAssembly ();
   998| 		if (assembly_ref != nullptr)
   999| 		{
  1000| 			return reinterpret_cast<const ep_char8_t*>(assembly_ref->GetSimpleName ());
  1001| 		}
  1002| 	}
  1003| 	return reinterpret_cast<const ep_char8_t*>("");
  1004| }
  1005| static
  1006| const ep_char8_t *
  1007| ep_rt_runtime_version_get_utf8 (void)
  1008| {
  1009| 	STATIC_CONTRACT_NOTHROW;
  1010| 	return reinterpret_cast<const ep_char8_t*>(CLR_PRODUCT_VERSION);
  1011| }
  1012| /*
  1013|  * Little-Endian Conversion.
  1014|  */
  1015| static
  1016| EP_ALWAYS_INLINE
  1017| uint16_t
  1018| ep_rt_val_uint16_t (uint16_t value)
  1019| {
  1020| 	return value;
  1021| }
  1022| static
  1023| EP_ALWAYS_INLINE
  1024| uint32_t
  1025| ep_rt_val_uint32_t (uint32_t value)
  1026| {
  1027| 	return value;
  1028| }
  1029| static
  1030| EP_ALWAYS_INLINE
  1031| uint64_t
  1032| ep_rt_val_uint64_t (uint64_t value)
  1033| {
  1034| 	return value;
  1035| }
  1036| static
  1037| EP_ALWAYS_INLINE
  1038| int16_t
  1039| ep_rt_val_int16_t (int16_t value)
  1040| {
  1041| 	return value;
  1042| }
  1043| static
  1044| EP_ALWAYS_INLINE
  1045| int32_t
  1046| ep_rt_val_int32_t (int32_t value)
  1047| {
  1048| 	return value;
  1049| }
  1050| static
  1051| EP_ALWAYS_INLINE
  1052| int64_t
  1053| ep_rt_val_int64_t (int64_t value)
  1054| {
  1055| 	return value;
  1056| }
  1057| static
  1058| EP_ALWAYS_INLINE
  1059| uintptr_t
  1060| ep_rt_val_uintptr_t (uintptr_t value)
  1061| {
  1062| 	return value;
  1063| }
  1064| /*
  1065| * Atomics.
  1066| */
  1067| static
  1068| inline
  1069| uint32_t
  1070| ep_rt_atomic_inc_uint32_t (volatile uint32_t *value)
  1071| {
  1072| 	STATIC_CONTRACT_NOTHROW;
  1073| 	return static_cast<uint32_t>(InterlockedIncrement ((volatile LONG *)(value)));
  1074| }
  1075| static
  1076| inline
  1077| uint32_t
  1078| ep_rt_atomic_dec_uint32_t (volatile uint32_t *value)
  1079| {
  1080| 	STATIC_CONTRACT_NOTHROW;
  1081| 	return static_cast<uint32_t>(InterlockedDecrement ((volatile LONG *)(value)));
  1082| }
  1083| static
  1084| inline
  1085| int32_t
  1086| ep_rt_atomic_inc_int32_t (volatile int32_t *value)
  1087| {
  1088| 	STATIC_CONTRACT_NOTHROW;
  1089| 	return static_cast<int32_t>(InterlockedIncrement ((volatile LONG *)(value)));
  1090| }
  1091| static
  1092| inline
  1093| int32_t
  1094| ep_rt_atomic_dec_int32_t (volatile int32_t *value)
  1095| {
  1096| 	STATIC_CONTRACT_NOTHROW;
  1097| 	return static_cast<int32_t>(InterlockedDecrement ((volatile LONG *)(value)));
  1098| }
  1099| static
  1100| inline
  1101| int64_t
  1102| ep_rt_atomic_inc_int64_t (volatile int64_t *value)
  1103| {
  1104| 	STATIC_CONTRACT_NOTHROW;
  1105| 	return static_cast<int64_t>(InterlockedIncrement64 ((volatile LONG64 *)(value)));
  1106| }
  1107| static
  1108| inline
  1109| int64_t
  1110| ep_rt_atomic_dec_int64_t (volatile int64_t *value)
  1111| {
  1112| 	STATIC_CONTRACT_NOTHROW;
  1113| 	return static_cast<int64_t>(InterlockedDecrement64 ((volatile LONG64 *)(value)));
  1114| }
  1115| static
  1116| inline
  1117| size_t
  1118| ep_rt_atomic_compare_exchange_size_t (volatile size_t *target, size_t expected, size_t value)
  1119| {
  1120| 	STATIC_CONTRACT_NOTHROW;
  1121| 	return static_cast<size_t>(InterlockedCompareExchangeT<size_t> (target, value, expected));
  1122| }
  1123| static
  1124| inline
  1125| ep_char8_t *
  1126| ep_rt_atomic_compare_exchange_utf8_string (ep_char8_t *volatile *target, ep_char8_t *expected, ep_char8_t *value)
  1127| {
  1128| 	STATIC_CONTRACT_NOTHROW;
  1129| 	return static_cast<ep_char8_t *>(InterlockedCompareExchangeT<ep_char8_t *> (target, value, expected));
  1130| }
  1131| /*
  1132|  * EventPipe.
  1133|  */
  1134| EP_RT_DEFINE_ARRAY (session_id_array, ep_rt_session_id_array_t, ep_rt_session_id_array_iterator_t, EventPipeSessionID)
  1135| EP_RT_DEFINE_ARRAY_ITERATOR (session_id_array, ep_rt_session_id_array_t, ep_rt_session_id_array_iterator_t, EventPipeSessionID)
  1136| EP_RT_DEFINE_ARRAY (execution_checkpoint_array, ep_rt_execution_checkpoint_array_t, ep_rt_execution_checkpoint_array_iterator_t, EventPipeExecutionCheckpoint *)
  1137| EP_RT_DEFINE_ARRAY_ITERATOR (execution_checkpoint_array, ep_rt_execution_checkpoint_array_t, ep_rt_execution_checkpoint_array_iterator_t, EventPipeExecutionCheckpoint *)
  1138| static
  1139| void
  1140| ep_rt_init (void)
  1141| {
  1142| 	STATIC_CONTRACT_NOTHROW;
  1143| 	extern ep_rt_lock_handle_t _ep_rt_coreclr_config_lock_handle;
  1144| 	extern CrstStatic _ep_rt_coreclr_config_lock;
  1145| 	_ep_rt_coreclr_config_lock_handle.lock = &_ep_rt_coreclr_config_lock;
  1146| 	_ep_rt_coreclr_config_lock_handle.lock->InitNoThrow (CrstEventPipe, (CrstFlags)(CRST_REENTRANCY | CRST_TAKEN_DURING_SHUTDOWN | CRST_HOST_BREAKABLE));
  1147| 	if (CLRConfig::GetConfigValue (CLRConfig::INTERNAL_EventPipeProcNumbers) != 0) {
  1148| #ifndef TARGET_UNIX
  1149| 		uint16_t groups = ::GetActiveProcessorGroupCount ();
  1150| 		extern uint32_t *_ep_rt_coreclr_proc_group_offsets;
  1151| 		_ep_rt_coreclr_proc_group_offsets = new (nothrow) uint32_t [groups];
  1152| 		if (_ep_rt_coreclr_proc_group_offsets) {
  1153| 			uint32_t procs = 0;
  1154| 			for (uint16_t i = 0; i < procs; ++i) {
  1155| 				_ep_rt_coreclr_proc_group_offsets [i] = procs;
  1156| 				procs += GetActiveProcessorCount (i);
  1157| 			}
  1158| 		}
  1159| #endif
  1160| 	}
  1161| }
  1162| static
  1163| inline
  1164| void
  1165| ep_rt_init_finish (void)
  1166| {
  1167| 	STATIC_CONTRACT_NOTHROW;
  1168| }
  1169| static
  1170| inline
  1171| void
  1172| ep_rt_shutdown (void)
  1173| {
  1174| 	STATIC_CONTRACT_NOTHROW;
  1175| }
  1176| static
  1177| inline
  1178| bool
  1179| ep_rt_config_acquire (void)
  1180| {
  1181| 	STATIC_CONTRACT_NOTHROW;
  1182| 	return ep_rt_lock_acquire (ep_rt_coreclr_config_lock_get ());
  1183| }
  1184| static
  1185| inline
  1186| bool
  1187| ep_rt_config_release (void)
  1188| {
  1189| 	STATIC_CONTRACT_NOTHROW;
  1190| 	return ep_rt_lock_release (ep_rt_coreclr_config_lock_get ());
  1191| }
  1192| #ifdef EP_CHECKED_BUILD
  1193| static
  1194| inline
  1195| void
  1196| ep_rt_config_requires_lock_held (void)
  1197| {
  1198| 	STATIC_CONTRACT_NOTHROW;
  1199| 	ep_rt_lock_requires_lock_held (ep_rt_coreclr_config_lock_get ());
  1200| }
  1201| static
  1202| inline
  1203| void
  1204| ep_rt_config_requires_lock_not_held (void)
  1205| {
  1206| 	STATIC_CONTRACT_NOTHROW;
  1207| 	ep_rt_lock_requires_lock_not_held (ep_rt_coreclr_config_lock_get ());
  1208| }
  1209| #endif
  1210| static
  1211| inline
  1212| bool
  1213| ep_rt_walk_managed_stack_for_thread (
  1214| 	ep_rt_thread_handle_t thread,
  1215| 	EventPipeStackContents *stack_contents)
  1216| {
  1217| 	STATIC_CONTRACT_NOTHROW;
  1218| 	extern bool ep_rt_coreclr_walk_managed_stack_for_thread (ep_rt_thread_handle_t thread, EventPipeStackContents *stack_contents);
  1219| 	return ep_rt_coreclr_walk_managed_stack_for_thread (thread, stack_contents);
  1220| }
  1221| static
  1222| inline
  1223| bool
  1224| ep_rt_method_get_simple_assembly_name (
  1225| 	ep_rt_method_desc_t *method,
  1226| 	ep_char8_t *name,
  1227| 	size_t name_len)
  1228| {
  1229| 	STATIC_CONTRACT_NOTHROW;
  1230| 	EP_ASSERT (method != NULL);
  1231| 	EP_ASSERT (name != NULL);
  1232| 	const ep_char8_t *assembly_name = method->GetLoaderModule ()->GetAssembly ()->GetSimpleName ();
  1233| 	if (!assembly_name)
  1234| 		return false;
  1235| 	size_t assembly_name_len = strlen (assembly_name) + 1;
  1236| 	size_t to_copy = assembly_name_len < name_len ? assembly_name_len : name_len;
  1237| 	memcpy (name, assembly_name, to_copy);
  1238| 	name [to_copy - 1] = 0;
  1239| 	return true;
  1240| }
  1241| static
  1242| bool
  1243| ep_rt_method_get_full_name (
  1244| 	ep_rt_method_desc_t *method,
  1245| 	ep_char8_t *name,
  1246| 	size_t name_len)
  1247| {
  1248| 	STATIC_CONTRACT_NOTHROW;
  1249| 	EP_ASSERT (method != NULL);
  1250| 	EP_ASSERT (name != NULL);
  1251| 	bool result = true;
  1252| 	EX_TRY
  1253| 	{
  1254| 		SString method_name;
  1255| 		TypeString::AppendMethodInternal (method_name, method, TypeString::FormatNamespace | TypeString::FormatSignature);
  1256| 		const ep_char8_t *method_name_utf8 = method_name.GetUTF8 ();
  1257| 		if (method_name_utf8) {
  1258| 			size_t method_name_utf8_len = strlen (method_name_utf8) + 1;
  1259| 			size_t to_copy = method_name_utf8_len < name_len ? method_name_utf8_len : name_len;
  1260| 			memcpy (name, method_name_utf8, to_copy);
  1261| 			name [to_copy - 1] = 0;
  1262| 		} else {
  1263| 			result = false;
  1264| 		}
  1265| 	}
  1266| 	EX_CATCH
  1267| 	{
  1268| 		result = false;
  1269| 	}
  1270| 	EX_END_CATCH(SwallowAllExceptions);
  1271| 	return result;
  1272| }
  1273| static
  1274| inline
  1275| void
  1276| ep_rt_provider_config_init (EventPipeProviderConfiguration *provider_config)
  1277| {
  1278| 	STATIC_CONTRACT_NOTHROW;
  1279| 	if (!ep_rt_utf8_string_compare (ep_config_get_rundown_provider_name_utf8 (), ep_provider_config_get_provider_name (provider_config))) {
  1280| 		MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_DOTNET_Context.EventPipeProvider.Level = (UCHAR) ep_provider_config_get_logging_level (provider_config);
  1281| 		MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_DOTNET_Context.EventPipeProvider.EnabledKeywordsBitmask = ep_provider_config_get_keywords (provider_config);
  1282| 		MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_DOTNET_Context.EventPipeProvider.IsEnabled = true;
  1283| 	}
  1284| }
  1285| #ifdef TARGET_UNIX
  1286| extern "C" void InitProvidersAndEvents ();
  1287| #else
  1288| extern void InitProvidersAndEvents ();
  1289| #endif
  1290| static
  1291| void
  1292| ep_rt_init_providers_and_events (void)
  1293| {
  1294| 	STATIC_CONTRACT_NOTHROW;
  1295| 	EX_TRY
  1296| 	{
  1297| 		InitProvidersAndEvents ();
  1298| 	}
  1299| 	EX_CATCH {}
  1300| 	EX_END_CATCH(SwallowAllExceptions);
  1301| }
  1302| static
  1303| inline
  1304| bool
  1305| ep_rt_providers_validate_all_disabled (void)
  1306| {
  1307| 	STATIC_CONTRACT_NOTHROW;
  1308| 	return (!MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_DOTNET_Context.EventPipeProvider.IsEnabled &&
  1309| 		!MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_DOTNET_Context.EventPipeProvider.IsEnabled &&
  1310| 		!MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_DOTNET_Context.EventPipeProvider.IsEnabled);
  1311| }
  1312| static
  1313| inline
  1314| void
  1315| ep_rt_prepare_provider_invoke_callback (EventPipeProviderCallbackData *provider_callback_data)
  1316| {
  1317| 	STATIC_CONTRACT_NOTHROW;
  1318| }
  1319| static
  1320| void
  1321| ep_rt_provider_invoke_callback (
  1322| 	EventPipeCallback callback_func,
  1323| 	const uint8_t *source_id,
  1324| 	unsigned long is_enabled,
  1325| 	uint8_t level,
  1326| 	uint64_t match_any_keywords,
  1327| 	uint64_t match_all_keywords,
  1328| 	EventFilterDescriptor *filter_data,
  1329| 	void *callback_data)
  1330| {
  1331| 	STATIC_CONTRACT_NOTHROW;
  1332| 	EP_ASSERT (callback_func != NULL);
  1333| 	EX_TRY
  1334| 	{
  1335| 		(*callback_func)(
  1336| 			source_id,
  1337| 			is_enabled,
  1338| 			level,
  1339| 			match_any_keywords,
  1340| 			match_all_keywords,
  1341| 			filter_data,
  1342| 			callback_data);
  1343| 	}
  1344| 	EX_CATCH {}
  1345| 	EX_END_CATCH(SwallowAllExceptions);
  1346| }
  1347| /*
  1348|  * EventPipeBuffer.
  1349|  */
  1350| EP_RT_DEFINE_ARRAY (buffer_array, ep_rt_buffer_array_t, ep_rt_buffer_array_iterator_t, EventPipeBuffer *)
  1351| EP_RT_DEFINE_LOCAL_ARRAY (buffer_array, ep_rt_buffer_array_t, ep_rt_buffer_array_iterator_t, EventPipeBuffer *)
  1352| EP_RT_DEFINE_ARRAY_ITERATOR (buffer_array, ep_rt_buffer_array_t, ep_rt_buffer_array_iterator_t, EventPipeBuffer *)
  1353| #undef EP_RT_DECLARE_LOCAL_BUFFER_ARRAY
  1354| #define EP_RT_DECLARE_LOCAL_BUFFER_ARRAY(var_name) \
  1355| 	EP_RT_DECLARE_LOCAL_ARRAY_VARIABLE(var_name, ep_rt_buffer_array_t)
  1356| /*
  1357|  * EventPipeBufferList.
  1358|  */
  1359| EP_RT_DEFINE_ARRAY (buffer_list_array, ep_rt_buffer_list_array_t, ep_rt_buffer_list_array_iterator_t, EventPipeBufferList *)
  1360| EP_RT_DEFINE_LOCAL_ARRAY (buffer_list_array, ep_rt_buffer_list_array_t, ep_rt_buffer_list_array_iterator_t, EventPipeBufferList *)
  1361| EP_RT_DEFINE_ARRAY_ITERATOR (buffer_list_array, ep_rt_buffer_list_array_t, ep_rt_buffer_list_array_iterator_t, EventPipeBufferList *)
  1362| #undef EP_RT_DECLARE_LOCAL_BUFFER_LIST_ARRAY
  1363| #define EP_RT_DECLARE_LOCAL_BUFFER_LIST_ARRAY(var_name) \
  1364| 	EP_RT_DECLARE_LOCAL_ARRAY_VARIABLE(var_name, ep_rt_buffer_list_array_t)
  1365| /*
  1366|  * EventPipeEvent.
  1367|  */
  1368| EP_RT_DEFINE_LIST (event_list, ep_rt_event_list_t, EventPipeEvent *)
  1369| EP_RT_DEFINE_LIST_ITERATOR (event_list, ep_rt_event_list_t, ep_rt_event_list_iterator_t, EventPipeEvent *)
  1370| /*
  1371|  * EventPipeFile.
  1372|  */
  1373| EP_RT_DEFINE_HASH_MAP_REMOVE(metadata_labels_hash, ep_rt_metadata_labels_hash_map_t, EventPipeEvent *, uint32_t)
  1374| EP_RT_DEFINE_HASH_MAP(stack_hash, ep_rt_stack_hash_map_t, StackHashKey *, StackHashEntry *)
  1375| EP_RT_DEFINE_HASH_MAP_ITERATOR(stack_hash, ep_rt_stack_hash_map_t, ep_rt_stack_hash_map_iterator_t, StackHashKey *, StackHashEntry *)
  1376| /*
  1377|  * EventPipeProvider.
  1378|  */
  1379| EP_RT_DEFINE_LIST (provider_list, ep_rt_provider_list_t, EventPipeProvider *)
  1380| EP_RT_DEFINE_LIST_ITERATOR (provider_list, ep_rt_provider_list_t, ep_rt_provider_list_iterator_t, EventPipeProvider *)
  1381| EP_RT_DEFINE_QUEUE (provider_callback_data_queue, ep_rt_provider_callback_data_queue_t, EventPipeProviderCallbackData *)
  1382| static
  1383| EventPipeProvider *
  1384| ep_rt_provider_list_find_by_name (
  1385| 	const ep_rt_provider_list_t *list,
  1386| 	const ep_char8_t *name)
  1387| {
  1388| 	STATIC_CONTRACT_NOTHROW;
  1389| 	if (list) {
  1390| 		SList<SListElem<EventPipeProvider *>> *provider_list = list->list;
  1391| 		SListElem<EventPipeProvider *> *element = provider_list->GetHead ();
  1392| 		while (element) {
  1393| 			EventPipeProvider *provider = element->GetValue ();
  1394| 			if (ep_rt_utf8_string_compare (ep_provider_get_provider_name (element->GetValue ()), name) == 0)
  1395| 				return provider;
  1396| 			element = provider_list->GetNext (element);
  1397| 		}
  1398| 	}
  1399| 	return NULL;
  1400| }
  1401| /*
  1402|  * EventPipeProviderConfiguration.
  1403|  */
  1404| EP_RT_DEFINE_ARRAY (provider_config_array, ep_rt_provider_config_array_t, ep_rt_provider_config_array_iterator_t, EventPipeProviderConfiguration)
  1405| EP_RT_DEFINE_ARRAY_ITERATOR (provider_config_array, ep_rt_provider_config_array_t, ep_rt_provider_config_array_iterator_t, EventPipeProviderConfiguration)
  1406| static
  1407| inline
  1408| bool
  1409| ep_rt_config_value_get_enable (void)
  1410| {
  1411| 	STATIC_CONTRACT_NOTHROW;
  1412| 	return CLRConfig::GetConfigValue (CLRConfig::INTERNAL_EnableEventPipe) != 0;
  1413| }
  1414| static
  1415| inline
  1416| ep_char8_t *
  1417| ep_rt_config_value_get_config (void)
  1418| {
  1419| 	STATIC_CONTRACT_NOTHROW;
  1420| 	CLRConfigStringHolder value(CLRConfig::GetConfigValue (CLRConfig::INTERNAL_EventPipeConfig));
  1421| 	return ep_rt_utf16_to_utf8_string (reinterpret_cast<ep_char16_t *>(value.GetValue ()), -1);
  1422| }
  1423| static
  1424| inline
  1425| ep_char8_t *
  1426| ep_rt_config_value_get_output_path (void)
  1427| {
  1428| 	STATIC_CONTRACT_NOTHROW;
  1429| 	CLRConfigStringHolder value(CLRConfig::GetConfigValue (CLRConfig::INTERNAL_EventPipeOutputPath));
  1430| 	return ep_rt_utf16_to_utf8_string (reinterpret_cast<ep_char16_t *>(value.GetValue ()), -1);
  1431| }
  1432| static
  1433| inline
  1434| uint32_t
  1435| ep_rt_config_value_get_circular_mb (void)
  1436| {
  1437| 	STATIC_CONTRACT_NOTHROW;
  1438| 	return CLRConfig::GetConfigValue (CLRConfig::INTERNAL_EventPipeCircularMB);
  1439| }
  1440| static
  1441| inline
  1442| bool
  1443| ep_rt_config_value_get_output_streaming (void)
  1444| {
  1445| 	STATIC_CONTRACT_NOTHROW;
  1446| 	return CLRConfig::GetConfigValue (CLRConfig::INTERNAL_EventPipeOutputStreaming) != 0;
  1447| }
  1448| static
  1449| inline
  1450| bool
  1451| ep_rt_config_value_get_use_portable_thread_pool (void)
  1452| {
  1453| 	STATIC_CONTRACT_NOTHROW;
  1454| 	return ThreadpoolMgr::UsePortableThreadPool ();
  1455| }
  1456| static
  1457| inline
  1458| bool
  1459| ep_rt_config_value_get_enable_stackwalk (void)
  1460| {
  1461| 	STATIC_CONTRACT_NOTHROW;
  1462| 	return CLRConfig::GetConfigValue(CLRConfig::INTERNAL_EventPipeEnableStackwalk) != 0;
  1463| }
  1464| /*
  1465|  * EventPipeSampleProfiler.
  1466|  */
  1467| static
  1468| inline
  1469| void
  1470| ep_rt_sample_profiler_write_sampling_event_for_threads (
  1471| 	ep_rt_thread_handle_t sampling_thread,
  1472| 	EventPipeEvent *sampling_event)
  1473| {
  1474| 	STATIC_CONTRACT_NOTHROW;
  1475| 	extern void ep_rt_coreclr_sample_profiler_write_sampling_event_for_threads (ep_rt_thread_handle_t sampling_thread, EventPipeEvent *sampling_event);
  1476| 	ep_rt_coreclr_sample_profiler_write_sampling_event_for_threads (sampling_thread, sampling_event);
  1477| }
  1478| static
  1479| inline
  1480| void
  1481| ep_rt_notify_profiler_provider_created (EventPipeProvider *provider)
  1482| {
  1483| 	STATIC_CONTRACT_NOTHROW;
  1484| #ifndef DACCESS_COMPILE
  1485| 		BEGIN_PROFILER_CALLBACK (CORProfilerTrackEventPipe ());
  1486| 		(&g_profControlBlock)->EventPipeProviderCreated (provider);
  1487| 		END_PROFILER_CALLBACK ();
  1488| #endif // DACCESS_COMPILE
  1489| }
  1490| /*
  1491|  * EventPipeSessionProvider.
  1492|  */
  1493| EP_RT_DEFINE_LIST (session_provider_list, ep_rt_session_provider_list_t, EventPipeSessionProvider *)
  1494| EP_RT_DEFINE_LIST_ITERATOR (session_provider_list, ep_rt_session_provider_list_t, ep_rt_session_provider_list_iterator_t, EventPipeSessionProvider *)
  1495| static
  1496| EventPipeSessionProvider *
  1497| ep_rt_session_provider_list_find_by_name (
  1498| 	const ep_rt_session_provider_list_t *list,
  1499| 	const ep_char8_t *name)
  1500| {
  1501| 	STATIC_CONTRACT_NOTHROW;
  1502| 	SList<SListElem<EventPipeSessionProvider *>> *provider_list = list->list;
  1503| 	EventPipeSessionProvider *session_provider = NULL;
  1504| 	SListElem<EventPipeSessionProvider *> *element = provider_list->GetHead ();
  1505| 	while (element) {
  1506| 		EventPipeSessionProvider *candidate = element->GetValue ();
  1507| 		if (ep_rt_utf8_string_compare (ep_session_provider_get_provider_name (candidate), name) == 0) {
  1508| 			session_provider = candidate;
  1509| 			break;
  1510| 		}
  1511| 		element = provider_list->GetNext (element);
  1512| 	}
  1513| 	return session_provider;
  1514| }
  1515| /*
  1516|  * EventPipeSequencePoint.
  1517|  */
  1518| EP_RT_DEFINE_LIST (sequence_point_list, ep_rt_sequence_point_list_t, EventPipeSequencePoint *)
  1519| EP_RT_DEFINE_LIST_ITERATOR (sequence_point_list, ep_rt_sequence_point_list_t, ep_rt_sequence_point_list_iterator_t, EventPipeSequencePoint *)
  1520| /*
  1521|  * EventPipeThread.
  1522|  */
  1523| EP_RT_DEFINE_LIST (thread_list, ep_rt_thread_list_t, EventPipeThread *)
  1524| EP_RT_DEFINE_LIST_ITERATOR (thread_list, ep_rt_thread_list_t, ep_rt_thread_list_iterator_t, EventPipeThread *)
  1525| EP_RT_DEFINE_ARRAY (thread_array, ep_rt_thread_array_t, ep_rt_thread_array_iterator_t, EventPipeThread *)
  1526| EP_RT_DEFINE_LOCAL_ARRAY (thread_array, ep_rt_thread_array_t, ep_rt_thread_array_iterator_t, EventPipeThread *)
  1527| EP_RT_DEFINE_ARRAY_ITERATOR (thread_array, ep_rt_thread_array_t, ep_rt_thread_array_iterator_t, EventPipeThread *)
  1528| #undef EP_RT_DECLARE_LOCAL_THREAD_ARRAY
  1529| #define EP_RT_DECLARE_LOCAL_THREAD_ARRAY(var_name) \
  1530| 	EP_RT_DECLARE_LOCAL_ARRAY_VARIABLE(var_name, ep_rt_thread_array_t)
  1531| /*
  1532|  * EventPipeThreadSessionState.
  1533|  */
  1534| EP_RT_DEFINE_LIST (thread_session_state_list, ep_rt_thread_session_state_list_t, EventPipeThreadSessionState *)
  1535| EP_RT_DEFINE_LIST_ITERATOR (thread_session_state_list, ep_rt_thread_session_state_list_t, ep_rt_thread_session_state_list_iterator_t, EventPipeThreadSessionState *)
  1536| EP_RT_DEFINE_ARRAY (thread_session_state_array, ep_rt_thread_session_state_array_t, ep_rt_thread_session_state_array_iterator_t, EventPipeThreadSessionState *)
  1537| EP_RT_DEFINE_LOCAL_ARRAY (thread_session_state_array, ep_rt_thread_session_state_array_t, ep_rt_thread_session_state_array_iterator_t, EventPipeThreadSessionState *)
  1538| EP_RT_DEFINE_ARRAY_ITERATOR (thread_session_state_array, ep_rt_thread_session_state_array_t, ep_rt_thread_session_state_array_iterator_t, EventPipeThreadSessionState *)
  1539| #undef EP_RT_DECLARE_LOCAL_THREAD_SESSION_STATE_ARRAY
  1540| #define EP_RT_DECLARE_LOCAL_THREAD_SESSION_STATE_ARRAY(var_name) \
  1541| 	EP_RT_DECLARE_LOCAL_ARRAY_VARIABLE(var_name, ep_rt_thread_session_state_array_t)
  1542| /*
  1543|  * Arrays.
  1544|  */
  1545| static
  1546| inline
  1547| uint8_t *
  1548| ep_rt_byte_array_alloc (size_t len)
  1549| {
  1550| 	STATIC_CONTRACT_NOTHROW;
  1551| 	return new (nothrow) uint8_t [len];
  1552| }
  1553| static
  1554| inline
  1555| void
  1556| ep_rt_byte_array_free (uint8_t *ptr)
  1557| {
  1558| 	STATIC_CONTRACT_NOTHROW;
  1559| 	if (ptr)
  1560| 		delete [] ptr;
  1561| }
  1562| /*
  1563|  * Event.
  1564|  */
  1565| static
  1566| void
  1567| ep_rt_wait_event_alloc (
  1568| 	ep_rt_wait_event_handle_t *wait_event,
  1569| 	bool manual,
  1570| 	bool initial)
  1571| {
  1572| 	STATIC_CONTRACT_NOTHROW;
  1573| 	EP_ASSERT (wait_event != NULL);
  1574| 	EP_ASSERT (wait_event->event == NULL);
  1575| 	wait_event->event = new (nothrow) CLREventStatic ();
  1576| 	if (wait_event->event) {
  1577| 		EX_TRY
  1578| 		{
  1579| 			if (manual)
  1580| 				wait_event->event->CreateManualEvent (initial);
  1581| 			else
  1582| 				wait_event->event->CreateAutoEvent (initial);
  1583| 		}
  1584| 		EX_CATCH {}
  1585| 		EX_END_CATCH(SwallowAllExceptions);
  1586| 	}
  1587| }
  1588| static
  1589| inline
  1590| void
  1591| ep_rt_wait_event_free (ep_rt_wait_event_handle_t *wait_event)
  1592| {
  1593| 	STATIC_CONTRACT_NOTHROW;
  1594| 	if (wait_event != NULL && wait_event->event != NULL) {
  1595| 		wait_event->event->CloseEvent ();
  1596| 		delete wait_event->event;
  1597| 		wait_event->event = NULL;
  1598| 	}
  1599| }
  1600| static
  1601| inline
  1602| bool
  1603| ep_rt_wait_event_set (ep_rt_wait_event_handle_t *wait_event)
  1604| {
  1605| 	STATIC_CONTRACT_NOTHROW;
  1606| 	EP_ASSERT (wait_event != NULL && wait_event->event != NULL);
  1607| 	return wait_event->event->Set ();
  1608| }
  1609| static
  1610| int32_t
  1611| ep_rt_wait_event_wait (
  1612| 	ep_rt_wait_event_handle_t *wait_event,
  1613| 	uint32_t timeout,
  1614| 	bool alertable)
  1615| {
  1616| 	STATIC_CONTRACT_NOTHROW;
  1617| 	EP_ASSERT (wait_event != NULL && wait_event->event != NULL);
  1618| 	int32_t result;
  1619| 	EX_TRY
  1620| 	{
  1621| 		result = wait_event->event->Wait (timeout, alertable);
  1622| 	}
  1623| 	EX_CATCH
  1624| 	{
  1625| 		result = -1;
  1626| 	}
  1627| 	EX_END_CATCH(SwallowAllExceptions);
  1628| 	return result;
  1629| }
  1630| static
  1631| inline
  1632| EventPipeWaitHandle
  1633| ep_rt_wait_event_get_wait_handle (ep_rt_wait_event_handle_t *wait_event)
  1634| {
  1635| 	STATIC_CONTRACT_NOTHROW;
  1636| 	EP_ASSERT (wait_event != NULL && wait_event->event != NULL);
  1637| 	return reinterpret_cast<EventPipeWaitHandle>(wait_event->event->GetHandleUNHOSTED ());
  1638| }
  1639| static
  1640| inline
  1641| bool
  1642| ep_rt_wait_event_is_valid (ep_rt_wait_event_handle_t *wait_event)
  1643| {
  1644| 	STATIC_CONTRACT_NOTHROW;
  1645| 	if (wait_event == NULL || wait_event->event == NULL)
  1646| 		return false;
  1647| 	return wait_event->event->IsValid ();
  1648| }
  1649| /*
  1650|  * Misc.
  1651|  */
  1652| static
  1653| inline
  1654| int
  1655| ep_rt_get_last_error (void)
  1656| {
  1657| 	STATIC_CONTRACT_NOTHROW;
  1658| 	return ::GetLastError ();
  1659| }
  1660| static
  1661| inline
  1662| bool
  1663| ep_rt_process_detach (void)
  1664| {
  1665| 	STATIC_CONTRACT_NOTHROW;
  1666| 	return (bool)g_fProcessDetach;
  1667| }
  1668| static
  1669| inline
  1670| bool
  1671| ep_rt_process_shutdown (void)
  1672| {
  1673| 	STATIC_CONTRACT_NOTHROW;
  1674| 	return (bool)g_fEEShutDown;
  1675| }
  1676| static
  1677| inline
  1678| void
  1679| ep_rt_create_activity_id (
  1680| 	uint8_t *activity_id,
  1681| 	uint32_t activity_id_len)
  1682| {
  1683| 	STATIC_CONTRACT_NOTHROW;
  1684| 	EP_ASSERT (activity_id != NULL);
  1685| 	EP_ASSERT (activity_id_len == EP_ACTIVITY_ID_SIZE);
  1686| 	CoCreateGuid (reinterpret_cast<GUID *>(activity_id));
  1687| }
  1688| static
  1689| inline
  1690| bool
  1691| ep_rt_is_running (void)
  1692| {
  1693| 	STATIC_CONTRACT_NOTHROW;
  1694| 	return (bool)g_fEEStarted;
  1695| }
  1696| static
  1697| inline
  1698| void
  1699| ep_rt_execute_rundown (ep_rt_execution_checkpoint_array_t *execution_checkpoints)
  1700| {
  1701| 	STATIC_CONTRACT_NOTHROW;
  1702| 	if (CLRConfig::GetConfigValue (CLRConfig::INTERNAL_EventPipeRundown) > 0) {
  1703| 		if (g_fEEStarted && !g_fEEShutDown)
  1704| 			ETW::EnumerationLog::EndRundown ();
  1705| 	}
  1706| }
  1707| /*
  1708|  * Objects.
  1709|  */
  1710| #undef ep_rt_object_alloc
  1711| #define ep_rt_object_alloc(obj_type) (new (nothrow) obj_type())
  1712| #undef ep_rt_object_array_alloc
  1713| #define ep_rt_object_array_alloc(obj_type,size) (new (nothrow) obj_type [size]())
  1714| #undef ep_rt_object_array_free
  1715| #define ep_rt_object_array_free(obj_ptr) do { if (obj_ptr) delete [] obj_ptr; } while(0)
  1716| #undef ep_rt_object_free
  1717| #define ep_rt_object_free(obj_ptr) do { if (obj_ptr) delete obj_ptr; } while(0)
  1718| /*
  1719|  * PAL.
  1720|  */
  1721| typedef struct _rt_coreclr_thread_params_internal_t {
  1722| 	ep_rt_thread_params_t thread_params;
  1723| } rt_coreclr_thread_params_internal_t;
  1724| #undef EP_RT_DEFINE_THREAD_FUNC
  1725| #define EP_RT_DEFINE_THREAD_FUNC(name) static ep_rt_thread_start_func_return_t WINAPI name (LPVOID data)
  1726| EP_RT_DEFINE_THREAD_FUNC (ep_rt_thread_coreclr_start_func)
  1727| {
  1728| 	STATIC_CONTRACT_NOTHROW;
  1729| 	rt_coreclr_thread_params_internal_t *thread_params = reinterpret_cast<rt_coreclr_thread_params_internal_t *>(data);
  1730| 	DWORD result = thread_params->thread_params.thread_func (thread_params);
  1731| 	if (thread_params->thread_params.thread)
  1732| 		::DestroyThread (thread_params->thread_params.thread);
  1733| 	delete thread_params;
  1734| 	return result;
  1735| }
  1736| static
  1737| bool
  1738| ep_rt_thread_create (
  1739| 	void *thread_func,
  1740| 	void *params,
  1741| 	EventPipeThreadType thread_type,
  1742| 	void *id)
  1743| {
  1744| 	STATIC_CONTRACT_NOTHROW;
  1745| 	EP_ASSERT (thread_func != NULL);
  1746| 	bool result = false;
  1747| 	EX_TRY
  1748| 	{
  1749| 		rt_coreclr_thread_params_internal_t *thread_params = new (nothrow) rt_coreclr_thread_params_internal_t ();
  1750| 		if (thread_params) {
  1751| 			thread_params->thread_params.thread_type = thread_type;
  1752| 			if (thread_type == EP_THREAD_TYPE_SESSION || thread_type == EP_THREAD_TYPE_SAMPLING) {
  1753| 				thread_params->thread_params.thread = SetupUnstartedThread ();
  1754| 				thread_params->thread_params.thread_func = reinterpret_cast<LPTHREAD_START_ROUTINE>(thread_func);
  1755| 				thread_params->thread_params.thread_params = params;
  1756| 				if (thread_params->thread_params.thread->CreateNewThread (0, ep_rt_thread_coreclr_start_func, thread_params)) {
  1757| 					thread_params->thread_params.thread->SetBackground (TRUE);
  1758| 					thread_params->thread_params.thread->StartThread ();
  1759| 					if (id)
  1760| 						*reinterpret_cast<DWORD *>(id) = thread_params->thread_params.thread->GetThreadId ();
  1761| 					result = true;
  1762| 				}
  1763| 			} else if (thread_type == EP_THREAD_TYPE_SERVER) {
  1764| 				DWORD thread_id = 0;
  1765| 				HANDLE server_thread = ::CreateThread (nullptr, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(thread_func), nullptr, 0, &thread_id);
  1766| 				if (server_thread != NULL) {
  1767| 					::CloseHandle (server_thread);
  1768| 					if (id)
  1769| 						*reinterpret_cast<DWORD *>(id) = thread_id;
  1770| 					result = true;
  1771| 				}
  1772| 			}
  1773| 		}
  1774| 	}
  1775| 	EX_CATCH
  1776| 	{
  1777| 		result = false;
  1778| 	}
  1779| 	EX_END_CATCH(SwallowAllExceptions);
  1780| 	return result;
  1781| }
  1782| static
  1783| inline
  1784| void
  1785| ep_rt_thread_sleep (uint64_t ns)
  1786| {
  1787| 	STATIC_CONTRACT_NOTHROW;
  1788| #ifdef TARGET_UNIX
  1789| 	PAL_nanosleep (ns);
  1790| #else  //TARGET_UNIX
  1791| 	const uint32_t NUM_NANOSECONDS_IN_1_MS = 1000000;
  1792| 	ClrSleepEx (static_cast<DWORD>(ns / NUM_NANOSECONDS_IN_1_MS), FALSE);
  1793| #endif //TARGET_UNIX
  1794| }
  1795| static
  1796| inline
  1797| uint32_t
  1798| ep_rt_current_process_get_id (void)
  1799| {
  1800| 	STATIC_CONTRACT_NOTHROW;
  1801| 	return static_cast<uint32_t>(GetCurrentProcessId ());
  1802| }
  1803| static
  1804| inline
  1805| uint32_t
  1806| ep_rt_current_processor_get_number (void)
  1807| {
  1808| 	STATIC_CONTRACT_NOTHROW;
  1809| #ifndef TARGET_UNIX
  1810| 	extern uint32_t *_ep_rt_coreclr_proc_group_offsets;
  1811| 	if (_ep_rt_coreclr_proc_group_offsets) {
  1812| 		PROCESSOR_NUMBER proc;
  1813| 		GetCurrentProcessorNumberEx (&proc);
  1814| 		return _ep_rt_coreclr_proc_group_offsets [proc.Group] + proc.Number;
  1815| 	}
  1816| #endif
  1817| 	return 0xFFFFFFFF;
  1818| }
  1819| static
  1820| inline
  1821| uint32_t
  1822| ep_rt_processors_get_count (void)
  1823| {
  1824| 	STATIC_CONTRACT_NOTHROW;
  1825| 	SYSTEM_INFO sys_info = {};
  1826| 	GetSystemInfo (&sys_info);
  1827| 	return static_cast<uint32_t>(sys_info.dwNumberOfProcessors);
  1828| }
  1829| static
  1830| inline
  1831| ep_rt_thread_id_t
  1832| ep_rt_current_thread_get_id (void)
  1833| {
  1834| 	STATIC_CONTRACT_NOTHROW;
  1835| #ifdef TARGET_UNIX
  1836| 	return static_cast<ep_rt_thread_id_t>(::PAL_GetCurrentOSThreadId ());
  1837| #else
  1838| 	return static_cast<ep_rt_thread_id_t>(::GetCurrentThreadId ());
  1839| #endif
  1840| }
  1841| static
  1842| inline
  1843| int64_t
  1844| ep_rt_perf_counter_query (void)
  1845| {
  1846| 	STATIC_CONTRACT_NOTHROW;
  1847| 	LARGE_INTEGER value;
  1848| 	if (QueryPerformanceCounter (&value))
  1849| 		return static_cast<int64_t>(value.QuadPart);
  1850| 	else
  1851| 		return 0;
  1852| }
  1853| static
  1854| inline
  1855| int64_t
  1856| ep_rt_perf_frequency_query (void)
  1857| {
  1858| 	STATIC_CONTRACT_NOTHROW;
  1859| 	LARGE_INTEGER value;
  1860| 	if (QueryPerformanceFrequency (&value))
  1861| 		return static_cast<int64_t>(value.QuadPart);
  1862| 	else
  1863| 		return 0;
  1864| }
  1865| static
  1866| inline
  1867| void
  1868| ep_rt_system_time_get (EventPipeSystemTime *system_time)
  1869| {
  1870| 	STATIC_CONTRACT_NOTHROW;
  1871| 	SYSTEMTIME value;
  1872| 	GetSystemTime (&value);
  1873| 	EP_ASSERT(system_time != NULL);
  1874| 	ep_system_time_set (
  1875| 		system_time,
  1876| 		value.wYear,
  1877| 		value.wMonth,
  1878| 		value.wDayOfWeek,
  1879| 		value.wDay,
  1880| 		value.wHour,
  1881| 		value.wMinute,
  1882| 		value.wSecond,
  1883| 		value.wMilliseconds);
  1884| }
  1885| static
  1886| inline
  1887| int64_t
  1888| ep_rt_system_timestamp_get (void)
  1889| {
  1890| 	STATIC_CONTRACT_NOTHROW;
  1891| 	FILETIME value;
  1892| 	GetSystemTimeAsFileTime (&value);
  1893| 	return static_cast<int64_t>(((static_cast<uint64_t>(value.dwHighDateTime)) << 32) | static_cast<uint64_t>(value.dwLowDateTime));
  1894| }
  1895| static
  1896| inline
  1897| int32_t
  1898| ep_rt_system_get_alloc_granularity (void)
  1899| {
  1900| 	STATIC_CONTRACT_NOTHROW;
  1901| 	return static_cast<int32_t>(g_SystemInfo.dwAllocationGranularity);
  1902| }
  1903| static
  1904| inline
  1905| const ep_char8_t *
  1906| ep_rt_os_command_line_get (void)
  1907| {
  1908| 	STATIC_CONTRACT_NOTHROW;
  1909| 	EP_UNREACHABLE ("Can not reach here");
  1910| 	return NULL;
  1911| }
  1912| static
  1913| ep_rt_file_handle_t
  1914| ep_rt_file_open_write (const ep_char8_t *path)
  1915| {
  1916| 	STATIC_CONTRACT_NOTHROW;
  1917| 	ep_char16_t *path_utf16 = ep_rt_utf8_to_utf16le_string (path, -1);
  1918| 	ep_return_null_if_nok (path_utf16 != NULL);
  1919| 	CFileStream *file_stream = new (nothrow) CFileStream ();
  1920| 	if (file_stream && FAILED (file_stream->OpenForWrite (reinterpret_cast<LPWSTR>(path_utf16)))) {
  1921| 		delete file_stream;
  1922| 		file_stream = NULL;
  1923| 	}
  1924| 	ep_rt_utf16_string_free (path_utf16);
  1925| 	return static_cast<ep_rt_file_handle_t>(file_stream);
  1926| }
  1927| static
  1928| inline
  1929| bool
  1930| ep_rt_file_close (ep_rt_file_handle_t file_handle)
  1931| {
  1932| 	STATIC_CONTRACT_NOTHROW;
  1933| 	if (file_handle)
  1934| 		delete file_handle;
  1935| 	return true;
  1936| }
  1937| static
  1938| inline
  1939| bool
  1940| ep_rt_file_write (
  1941| 	ep_rt_file_handle_t file_handle,
  1942| 	const uint8_t *buffer,
  1943| 	uint32_t bytes_to_write,
  1944| 	uint32_t *bytes_written)
  1945| {
  1946| 	STATIC_CONTRACT_NOTHROW;
  1947| 	EP_ASSERT (buffer != NULL);
  1948| 	ep_return_false_if_nok (file_handle != NULL);
  1949| 	ULONG out_count;
  1950| 	HRESULT result = reinterpret_cast<CFileStream *>(file_handle)->Write (buffer, bytes_to_write, &out_count);
  1951| 	*bytes_written = static_cast<uint32_t>(out_count);
  1952| 	return result == S_OK;
  1953| }
  1954| static
  1955| inline
  1956| uint8_t *
  1957| ep_rt_valloc0 (size_t buffer_size)
  1958| {
  1959| 	STATIC_CONTRACT_NOTHROW;
  1960| 	return reinterpret_cast<uint8_t *>(ClrVirtualAlloc (NULL, buffer_size, MEM_COMMIT, PAGE_READWRITE));
  1961| }
  1962| static
  1963| inline
  1964| void
  1965| ep_rt_vfree (
  1966| 	uint8_t *buffer,
  1967| 	size_t buffer_size)
  1968| {
  1969| 	STATIC_CONTRACT_NOTHROW;
  1970| 	if (buffer)
  1971| 		ClrVirtualFree (buffer, 0, MEM_RELEASE);
  1972| }
  1973| static
  1974| inline
  1975| uint32_t
  1976| ep_rt_temp_path_get (
  1977| 	ep_char8_t *buffer,
  1978| 	uint32_t buffer_len)
  1979| {
  1980| 	STATIC_CONTRACT_NOTHROW;
  1981| 	EP_UNREACHABLE ("Can not reach here");
  1982| 	return 0;
  1983| }
  1984| EP_RT_DEFINE_ARRAY (env_array_utf16, ep_rt_env_array_utf16_t, ep_rt_env_array_utf16_iterator_t, ep_char16_t *)
  1985| EP_RT_DEFINE_ARRAY_ITERATOR (env_array_utf16, ep_rt_env_array_utf16_t, ep_rt_env_array_utf16_iterator_t, ep_char16_t *)
  1986| static
  1987| void
  1988| ep_rt_os_environment_get_utf16 (ep_rt_env_array_utf16_t *env_array)
  1989| {
  1990| 	STATIC_CONTRACT_NOTHROW;
  1991| 	EP_ASSERT (env_array != NULL);
  1992| 	LPWSTR envs = GetEnvironmentStringsW ();
  1993| 	if (envs) {
  1994| 		LPWSTR next = envs;
  1995| 		while (*next) {
  1996| 			ep_rt_env_array_utf16_append (env_array, ep_rt_utf16_string_dup (reinterpret_cast<const ep_char16_t *>(next)));
  1997| 			next += ep_rt_utf16_string_len (reinterpret_cast<const ep_char16_t *>(next)) + 1;
  1998| 		}
  1999| 		FreeEnvironmentStringsW (envs);
  2000| 	}
  2001| }
  2002| /*
  2003| * Lock.
  2004| */
  2005| static
  2006| bool
  2007| ep_rt_lock_acquire (ep_rt_lock_handle_t *lock)
  2008| {
  2009| 	STATIC_CONTRACT_NOTHROW;
  2010| 	bool result = true;
  2011| 	EX_TRY
  2012| 	{
  2013| 		if (lock) {
  2014| 			CrstBase::CrstHolderWithState holder (lock->lock);
  2015| 			holder.SuppressRelease ();
  2016| 		}
  2017| 	}
  2018| 	EX_CATCH
  2019| 	{
  2020| 		result = false;
  2021| 	}
  2022| 	EX_END_CATCH(SwallowAllExceptions);
  2023| 	return result;
  2024| }
  2025| static
  2026| bool
  2027| ep_rt_lock_release (ep_rt_lock_handle_t *lock)
  2028| {
  2029| 	STATIC_CONTRACT_NOTHROW;
  2030| 	bool result = true;
  2031| 	EX_TRY
  2032| 	{
  2033| 		if (lock) {
  2034| 			CrstBase::UnsafeCrstInverseHolder holder (lock->lock);
  2035| 			holder.SuppressRelease ();
  2036| 		}
  2037| 	}
  2038| 	EX_CATCH
  2039| 	{
  2040| 		result = false;
  2041| 	}
  2042| 	EX_END_CATCH(SwallowAllExceptions);
  2043| 	return result;
  2044| }
  2045| #ifdef EP_CHECKED_BUILD
  2046| static
  2047| inline
  2048| void
  2049| ep_rt_lock_requires_lock_held (const ep_rt_lock_handle_t *lock)
  2050| {
  2051| 	STATIC_CONTRACT_NOTHROW;
  2052| 	EP_ASSERT (((ep_rt_lock_handle_t *)lock)->lock->OwnedByCurrentThread ());
  2053| }
  2054| static
  2055| inline
  2056| void
  2057| ep_rt_lock_requires_lock_not_held (const ep_rt_lock_handle_t *lock)
  2058| {
  2059| 	STATIC_CONTRACT_NOTHROW;
  2060| 	EP_ASSERT (lock->lock == NULL || !((ep_rt_lock_handle_t *)lock)->lock->OwnedByCurrentThread ());
  2061| }
  2062| #endif
  2063| /*
  2064| * SpinLock.
  2065| */
  2066| static
  2067| void
  2068| ep_rt_spin_lock_alloc (ep_rt_spin_lock_handle_t *spin_lock)
  2069| {
  2070| 	STATIC_CONTRACT_NOTHROW;
  2071| 	EX_TRY
  2072| 	{
  2073| 		spin_lock->lock = new (nothrow) SpinLock ();
  2074| 		spin_lock->lock->Init (LOCK_TYPE_DEFAULT);
  2075| 	}
  2076| 	EX_CATCH {}
  2077| 	EX_END_CATCH(SwallowAllExceptions);
  2078| }
  2079| static
  2080| inline
  2081| void
  2082| ep_rt_spin_lock_free (ep_rt_spin_lock_handle_t *spin_lock)
  2083| {
  2084| 	STATIC_CONTRACT_NOTHROW;
  2085| 	if (spin_lock && spin_lock->lock) {
  2086| 		delete spin_lock->lock;
  2087| 		spin_lock->lock = NULL;
  2088| 	}
  2089| }
  2090| static
  2091| inline
  2092| bool
  2093| ep_rt_spin_lock_acquire (ep_rt_spin_lock_handle_t *spin_lock)
  2094| {
  2095| 	STATIC_CONTRACT_NOTHROW;
  2096| 	EP_ASSERT (ep_rt_spin_lock_is_valid (spin_lock));
  2097| 	SpinLock::AcquireLock (spin_lock->lock);
  2098| 	return true;
  2099| }
  2100| static
  2101| inline
  2102| bool
  2103| ep_rt_spin_lock_release (ep_rt_spin_lock_handle_t *spin_lock)
  2104| {
  2105| 	STATIC_CONTRACT_NOTHROW;
  2106| 	EP_ASSERT (ep_rt_spin_lock_is_valid (spin_lock));
  2107| 	SpinLock::ReleaseLock (spin_lock->lock);
  2108| 	return true;
  2109| }
  2110| #ifdef EP_CHECKED_BUILD
  2111| static
  2112| inline
  2113| void
  2114| ep_rt_spin_lock_requires_lock_held (const ep_rt_spin_lock_handle_t *spin_lock)
  2115| {
  2116| 	STATIC_CONTRACT_NOTHROW;
  2117| 	EP_ASSERT (ep_rt_spin_lock_is_valid (spin_lock));
  2118| 	EP_ASSERT (spin_lock->lock->OwnedByCurrentThread ());
  2119| }
  2120| static
  2121| inline
  2122| void
  2123| ep_rt_spin_lock_requires_lock_not_held (const ep_rt_spin_lock_handle_t *spin_lock)
  2124| {
  2125| 	STATIC_CONTRACT_NOTHROW;
  2126| 	EP_ASSERT (spin_lock->lock == NULL || !spin_lock->lock->OwnedByCurrentThread ());
  2127| }
  2128| #endif
  2129| static
  2130| inline
  2131| bool
  2132| ep_rt_spin_lock_is_valid (const ep_rt_spin_lock_handle_t *spin_lock)
  2133| {
  2134| 	STATIC_CONTRACT_NOTHROW;
  2135| 	return (spin_lock != NULL && spin_lock->lock != NULL);
  2136| }
  2137| /*
  2138|  * String.
  2139|  */
  2140| static
  2141| inline
  2142| int
  2143| ep_rt_utf8_string_compare (
  2144| 	const ep_char8_t *str1,
  2145| 	const ep_char8_t *str2)
  2146| {
  2147| 	STATIC_CONTRACT_NOTHROW;
  2148| 	EP_ASSERT (str1 != NULL && str2 != NULL);
  2149| 	return strcmp (reinterpret_cast<const char *>(str1), reinterpret_cast<const char *>(str2));
  2150| }
  2151| static
  2152| inline
  2153| int
  2154| ep_rt_utf8_string_compare_ignore_case (
  2155| 	const ep_char8_t *str1,
  2156| 	const ep_char8_t *str2)
  2157| {
  2158| 	STATIC_CONTRACT_NOTHROW;
  2159| 	EP_ASSERT (str1 != NULL && str2 != NULL);
  2160| 	return _stricmp (reinterpret_cast<const char *>(str1), reinterpret_cast<const char *>(str2));
  2161| }
  2162| static
  2163| inline
  2164| bool
  2165| ep_rt_utf8_string_is_null_or_empty (const ep_char8_t *str)
  2166| {
  2167| 	STATIC_CONTRACT_NOTHROW;
  2168| 	if (str == NULL)
  2169| 		return true;
  2170| 	while (*str) {
  2171| 		if (!isspace (*str))
  2172| 			return false;
  2173| 		str++;
  2174| 	}
  2175| 	return true;
  2176| }
  2177| static
  2178| inline
  2179| ep_char8_t *
  2180| ep_rt_utf8_string_dup (const ep_char8_t *str)
  2181| {
  2182| 	STATIC_CONTRACT_NOTHROW;
  2183| 	if (!str)
  2184| 		return NULL;
  2185| 	return _strdup (str);
  2186| }
  2187| static
  2188| inline
  2189| ep_char8_t *
  2190| ep_rt_utf8_string_dup_range (const ep_char8_t *str, const ep_char8_t *strEnd)
  2191| {
  2192| 	ptrdiff_t byte_len = strEnd - str;
  2193| 	ep_char8_t *buffer = reinterpret_cast<ep_char8_t *>(malloc(byte_len + 1));
  2194| 	if (buffer != NULL)
  2195| 	{
  2196| 		memcpy (buffer, str, byte_len);
  2197| 		buffer [byte_len] = '\0';
  2198| 	}
  2199| 	return buffer;
  2200| }
  2201| static
  2202| inline
  2203| ep_char8_t *
  2204| ep_rt_utf8_string_strtok (
  2205| 	ep_char8_t *str,
  2206| 	const ep_char8_t *delimiter,
  2207| 	ep_char8_t **context)
  2208| {
  2209| 	STATIC_CONTRACT_NOTHROW;
  2210| 	return strtok_s (str, delimiter, context);
  2211| }
  2212| #undef ep_rt_utf8_string_snprintf
  2213| #define ep_rt_utf8_string_snprintf( \
  2214| 	str, \
  2215| 	str_len, \
  2216| 	format, ...) \
  2217| sprintf_s (reinterpret_cast<char *>(str), static_cast<size_t>(str_len), reinterpret_cast<const char *>(format), __VA_ARGS__)
  2218| static
  2219| inline
  2220| bool
  2221| ep_rt_utf8_string_replace (
  2222| 	ep_char8_t **str,
  2223| 	const ep_char8_t *strSearch,
  2224| 	const ep_char8_t *strReplacement
  2225| )
  2226| {
  2227| 	STATIC_CONTRACT_NOTHROW;
  2228| 	if ((*str) == NULL)
  2229| 		return false;
  2230| 	ep_char8_t* strFound = strstr(*str, strSearch);
  2231| 	if (strFound != NULL)
  2232| 	{
  2233| 		size_t strSearchLen = strlen(strSearch);
  2234| 		size_t newStrSize = strlen(*str) + strlen(strReplacement) - strSearchLen + 1;
  2235| 		ep_char8_t *newStr =  reinterpret_cast<ep_char8_t *>(malloc(newStrSize));
  2236| 		if (newStr == NULL)
  2237| 		{
  2238| 			*str = NULL;
  2239| 			return false;
  2240| 		}
  2241| 		ep_rt_utf8_string_snprintf(newStr, newStrSize, "%.*s%s%s", (int)(strFound - (*str)), *str, strReplacement, strFound + strSearchLen);
  2242| 		ep_rt_utf8_string_free(*str);
  2243| 		*str = newStr;
  2244| 		return true;
  2245| 	}
  2246| 	return false;
  2247| }
  2248| static
  2249| ep_char16_t *
  2250| ep_rt_utf8_to_utf16le_string (
  2251| 	const ep_char8_t *str,
  2252| 	size_t len)
  2253| {
  2254| 	STATIC_CONTRACT_NOTHROW;
  2255| 	if (!str)
  2256| 		return NULL;
  2257| 	COUNT_T len_utf16 = WszMultiByteToWideChar (CP_UTF8, 0, str, static_cast<int>(len), 0, 0);
  2258| 	if (len_utf16 == 0)
  2259| 		return NULL;
  2260| 	if (static_cast<int>(len) != -1)
  2261| 		len_utf16 += 1;
  2262| 	ep_char16_t *str_utf16 = reinterpret_cast<ep_char16_t *>(malloc (len_utf16 * sizeof (ep_char16_t)));
  2263| 	if (!str_utf16)
  2264| 		return NULL;
  2265| 	len_utf16 = WszMultiByteToWideChar (CP_UTF8, 0, str, static_cast<int>(len), reinterpret_cast<LPWSTR>(str_utf16), len_utf16);
  2266| 	if (len_utf16 == 0) {
  2267| 		free (str_utf16);
  2268| 		return NULL;
  2269| 	}
  2270| 	str_utf16 [len_utf16 - 1] = 0;
  2271| 	return str_utf16;
  2272| }
  2273| static
  2274| inline
  2275| ep_char16_t *
  2276| ep_rt_utf16_string_dup (const ep_char16_t *str)
  2277| {
  2278| 	STATIC_CONTRACT_NOTHROW;
  2279| 	if (!str)
  2280| 		return NULL;
  2281| 	size_t str_size = (ep_rt_utf16_string_len (str) + 1) * sizeof (ep_char16_t);
  2282| 	ep_char16_t *str_dup = reinterpret_cast<ep_char16_t *>(malloc (str_size));
  2283| 	if (str_dup)
  2284| 		memcpy (str_dup, str, str_size);
  2285| 	return str_dup;
  2286| }
  2287| static
  2288| inline
  2289| void
  2290| ep_rt_utf8_string_free (ep_char8_t *str)
  2291| {
  2292| 	STATIC_CONTRACT_NOTHROW;
  2293| 	if (str)
  2294| 		free (str);
  2295| }
  2296| static
  2297| inline
  2298| size_t
  2299| ep_rt_utf16_string_len (const ep_char16_t *str)
  2300| {
  2301| 	STATIC_CONTRACT_NOTHROW;
  2302| 	EP_ASSERT (str != NULL);
  2303| 	return wcslen (reinterpret_cast<LPCWSTR>(str));
  2304| }
  2305| static
  2306| ep_char8_t *
  2307| ep_rt_utf16_to_utf8_string (
  2308| 	const ep_char16_t *str,
  2309| 	size_t len)
  2310| {
  2311| 	STATIC_CONTRACT_NOTHROW;
  2312| 	if (!str)
  2313| 		return NULL;
  2314| 	COUNT_T size_utf8 = WszWideCharToMultiByte (CP_UTF8, 0, reinterpret_cast<LPCWSTR>(str), static_cast<int>(len), NULL, 0, NULL, NULL);
  2315| 	if (size_utf8 == 0)
  2316| 		return NULL;
  2317| 	if (static_cast<int>(len) != -1)
  2318| 		size_utf8 += 1;
  2319| 	ep_char8_t *str_utf8 = reinterpret_cast<ep_char8_t *>(malloc (size_utf8));
  2320| 	if (!str_utf8)
  2321| 		return NULL;
  2322| 	size_utf8 = WszWideCharToMultiByte (CP_UTF8, 0, reinterpret_cast<LPCWSTR>(str), static_cast<int>(len), reinterpret_cast<LPSTR>(str_utf8), size_utf8, NULL, NULL);
  2323| 	if (size_utf8 == 0) {
  2324| 		free (str_utf8);
  2325| 		return NULL;
  2326| 	}
  2327| 	str_utf8 [size_utf8 - 1] = 0;
  2328| 	return str_utf8;
  2329| }
  2330| static
  2331| inline
  2332| ep_char8_t *
  2333| ep_rt_utf16le_to_utf8_string (
  2334| 	const ep_char16_t *str,
  2335| 	size_t len)
  2336| {
  2337| 	return ep_rt_utf16_to_utf8_string (str, len);
  2338| }
  2339| static
  2340| inline
  2341| void
  2342| ep_rt_utf16_string_free (ep_char16_t *str)
  2343| {
  2344| 	STATIC_CONTRACT_NOTHROW;
  2345| 	if (str)
  2346| 		free (str);
  2347| }
  2348| static
  2349| inline
  2350| const ep_char8_t *
  2351| ep_rt_managed_command_line_get (void)
  2352| {
  2353| 	STATIC_CONTRACT_NOTHROW;
  2354| 	EP_UNREACHABLE ("Can not reach here");
  2355| 	return NULL;
  2356| }
  2357| static
  2358| const ep_char8_t *
  2359| ep_rt_diagnostics_command_line_get (void)
  2360| {
  2361| 	STATIC_CONTRACT_NOTHROW;
  2362| 	extern ep_char8_t *volatile _ep_rt_coreclr_diagnostics_cmd_line;
  2363| 	ep_char8_t *old_cmd_line = _ep_rt_coreclr_diagnostics_cmd_line;
  2364| 	ep_char8_t *new_cmd_line = ep_rt_utf16_to_utf8_string (reinterpret_cast<const ep_char16_t *>(GetCommandLineForDiagnostics ()), -1);
  2365| 	if (old_cmd_line && ep_rt_utf8_string_compare (old_cmd_line, new_cmd_line) == 0) {
  2366| 		ep_rt_utf8_string_free (new_cmd_line);
  2367| 	} else {
  2368| 		if (ep_rt_atomic_compare_exchange_utf8_string (&_ep_rt_coreclr_diagnostics_cmd_line, old_cmd_line, new_cmd_line) != old_cmd_line) {
  2369| 			ep_rt_utf8_string_free (new_cmd_line);
  2370| 		}
  2371| 	}
  2372| 	return _ep_rt_coreclr_diagnostics_cmd_line;
  2373| }
  2374| /*
  2375|  * Thread.
  2376|  */
  2377| static
  2378| inline
  2379| EventPipeThreadHolder *
  2380| thread_holder_alloc_func (void)
  2381| {
  2382| 	STATIC_CONTRACT_NOTHROW;
  2383| 	EventPipeThreadHolder *instance = ep_thread_holder_alloc (ep_thread_alloc());
  2384| 	if (instance)
  2385| 		ep_thread_register (ep_thread_holder_get_thread (instance));
  2386| 	return instance;
  2387| }
  2388| static
  2389| inline
  2390| void
  2391| thread_holder_free_func (EventPipeThreadHolder * thread_holder)
  2392| {
  2393| 	STATIC_CONTRACT_NOTHROW;
  2394| 	if (thread_holder) {
  2395| 		ep_thread_unregister (ep_thread_holder_get_thread (thread_holder));
  2396| 		ep_thread_holder_free (thread_holder);
  2397| 	}
  2398| }
  2399| class EventPipeCoreCLRThreadHolderTLS {
  2400| public:
  2401| 	EventPipeCoreCLRThreadHolderTLS ()
  2402| 	{
  2403| 		STATIC_CONTRACT_NOTHROW;
  2404| 	}
  2405| 	~EventPipeCoreCLRThreadHolderTLS ()
  2406| 	{
  2407| 		STATIC_CONTRACT_NOTHROW;
  2408| 		if (m_threadHolder) {
  2409| 			thread_holder_free_func (m_threadHolder);
  2410| 			m_threadHolder = NULL;
  2411| 		}
  2412| 	}
  2413| 	static inline EventPipeThreadHolder * getThreadHolder ()
  2414| 	{
  2415| 		STATIC_CONTRACT_NOTHROW;
  2416| 		return g_threadHolderTLS.m_threadHolder;
  2417| 	}
  2418| 	static inline EventPipeThreadHolder * createThreadHolder ()
  2419| 	{
  2420| 		STATIC_CONTRACT_NOTHROW;
  2421| 		if (g_threadHolderTLS.m_threadHolder) {
  2422| 			thread_holder_free_func (g_threadHolderTLS.m_threadHolder);
  2423| 			g_threadHolderTLS.m_threadHolder = NULL;
  2424| 		}
  2425| 		g_threadHolderTLS.m_threadHolder = thread_holder_alloc_func ();
  2426| 		return g_threadHolderTLS.m_threadHolder;
  2427| 	}
  2428| private:
  2429| 	EventPipeThreadHolder *m_threadHolder;
  2430| 	static thread_local EventPipeCoreCLRThreadHolderTLS g_threadHolderTLS;
  2431| };
  2432| static
  2433| void
  2434| ep_rt_thread_setup (void)
  2435| {
  2436| 	STATIC_CONTRACT_NOTHROW;
  2437| 	Thread* thread_handle = SetupThreadNoThrow ();
  2438| 	EP_ASSERT (thread_handle != NULL);
  2439| }
  2440| static
  2441| inline
  2442| EventPipeThread *
  2443| ep_rt_thread_get (void)
  2444| {
  2445| 	STATIC_CONTRACT_NOTHROW;
  2446| 	EventPipeThreadHolder *thread_holder = EventPipeCoreCLRThreadHolderTLS::getThreadHolder ();
  2447| 	return thread_holder ? ep_thread_holder_get_thread (thread_holder) : NULL;
  2448| }
  2449| static
  2450| inline
  2451| EventPipeThread *
  2452| ep_rt_thread_get_or_create (void)
  2453| {
  2454| 	STATIC_CONTRACT_NOTHROW;
  2455| 	EventPipeThreadHolder *thread_holder = EventPipeCoreCLRThreadHolderTLS::getThreadHolder ();
  2456| 	if (!thread_holder)
  2457| 		thread_holder = EventPipeCoreCLRThreadHolderTLS::createThreadHolder ();
  2458| 	return ep_thread_holder_get_thread (thread_holder);
  2459| }
  2460| static
  2461| inline
  2462| ep_rt_thread_handle_t
  2463| ep_rt_thread_get_handle (void)
  2464| {
  2465| 	STATIC_CONTRACT_NOTHROW;
  2466| 	return GetThreadNULLOk ();
  2467| }
  2468| static
  2469| inline
  2470| ep_rt_thread_id_t
  2471| ep_rt_thread_get_id (ep_rt_thread_handle_t thread_handle)
  2472| {
  2473| 	STATIC_CONTRACT_NOTHROW;
  2474| 	EP_ASSERT (thread_handle != NULL);
  2475| 	return ep_rt_uint64_t_to_thread_id_t (thread_handle->GetOSThreadId64 ());
  2476| }
  2477| static
  2478| inline
  2479| uint64_t
  2480| ep_rt_thread_id_t_to_uint64_t (ep_rt_thread_id_t thread_id)
  2481| {
  2482| 	return static_cast<uint64_t>(thread_id);
  2483| }
  2484| static
  2485| inline
  2486| ep_rt_thread_id_t
  2487| ep_rt_uint64_t_to_thread_id_t (uint64_t thread_id)
  2488| {
  2489| 	return static_cast<ep_rt_thread_id_t>(thread_id);
  2490| }
  2491| static
  2492| inline
  2493| bool
  2494| ep_rt_thread_has_started (ep_rt_thread_handle_t thread_handle)
  2495| {
  2496| 	STATIC_CONTRACT_NOTHROW;
  2497| 	return thread_handle != NULL && thread_handle->HasStarted ();
  2498| }
  2499| static
  2500| inline
  2501| ep_rt_thread_activity_id_handle_t
  2502| ep_rt_thread_get_activity_id_handle (void)
  2503| {
  2504| 	STATIC_CONTRACT_NOTHROW;
  2505| 	return GetThread ();
  2506| }
  2507| static
  2508| inline
  2509| const uint8_t *
  2510| ep_rt_thread_get_activity_id_cref (ep_rt_thread_activity_id_handle_t activity_id_handle)
  2511| {
  2512| 	STATIC_CONTRACT_NOTHROW;
  2513| 	EP_ASSERT (activity_id_handle != NULL);
  2514| 	return reinterpret_cast<const uint8_t *>(activity_id_handle->GetActivityId ());
  2515| }
  2516| static
  2517| inline
  2518| void
  2519| ep_rt_thread_get_activity_id (
  2520| 	ep_rt_thread_activity_id_handle_t activity_id_handle,
  2521| 	uint8_t *activity_id,
  2522| 	uint32_t activity_id_len)
  2523| {
  2524| 	STATIC_CONTRACT_NOTHROW;
  2525| 	EP_ASSERT (activity_id_handle != NULL);
  2526| 	EP_ASSERT (activity_id != NULL);
  2527| 	EP_ASSERT (activity_id_len == EP_ACTIVITY_ID_SIZE);
  2528| 	memcpy (activity_id, ep_rt_thread_get_activity_id_cref (activity_id_handle), EP_ACTIVITY_ID_SIZE);
  2529| }
  2530| static
  2531| inline
  2532| void
  2533| ep_rt_thread_set_activity_id (
  2534| 	ep_rt_thread_activity_id_handle_t activity_id_handle,
  2535| 	const uint8_t *activity_id,
  2536| 	uint32_t activity_id_len)
  2537| {
  2538| 	STATIC_CONTRACT_NOTHROW;
  2539| 	EP_ASSERT (activity_id_handle != NULL);
  2540| 	EP_ASSERT (activity_id != NULL);
  2541| 	EP_ASSERT (activity_id_len == EP_ACTIVITY_ID_SIZE);
  2542| 	activity_id_handle->SetActivityId (reinterpret_cast<LPCGUID>(activity_id));
  2543| }
  2544| #undef EP_YIELD_WHILE
  2545| #define EP_YIELD_WHILE(condition) YIELD_WHILE(condition)
  2546| /*
  2547|  * ThreadSequenceNumberMap.
  2548|  */
  2549| EP_RT_DEFINE_HASH_MAP_REMOVE(thread_sequence_number_map, ep_rt_thread_sequence_number_hash_map_t, EventPipeThreadSessionState *, uint32_t)
  2550| EP_RT_DEFINE_HASH_MAP_ITERATOR(thread_sequence_number_map, ep_rt_thread_sequence_number_hash_map_t, ep_rt_thread_sequence_number_hash_map_iterator_t, EventPipeThreadSessionState *, uint32_t)
  2551| /*
  2552|  * Volatile.
  2553|  */
  2554| static
  2555| inline
  2556| uint32_t
  2557| ep_rt_volatile_load_uint32_t (const volatile uint32_t *ptr)
  2558| {
  2559| 	STATIC_CONTRACT_NOTHROW;
  2560| 	return VolatileLoad<uint32_t> ((const uint32_t *)ptr);
  2561| }
  2562| static
  2563| inline
  2564| uint32_t
  2565| ep_rt_volatile_load_uint32_t_without_barrier (const volatile uint32_t *ptr)
  2566| {
  2567| 	STATIC_CONTRACT_NOTHROW;
  2568| 	return VolatileLoadWithoutBarrier<uint32_t> ((const uint32_t *)ptr);
  2569| }
  2570| static
  2571| inline
  2572| void
  2573| ep_rt_volatile_store_uint32_t (
  2574| 	volatile uint32_t *ptr,
  2575| 	uint32_t value)
  2576| {
  2577| 	STATIC_CONTRACT_NOTHROW;
  2578| 	VolatileStore<uint32_t> ((uint32_t *)ptr, value);
  2579| }
  2580| static
  2581| inline
  2582| void
  2583| ep_rt_volatile_store_uint32_t_without_barrier (
  2584| 	volatile uint32_t *ptr,
  2585| 	uint32_t value)
  2586| {
  2587| 	STATIC_CONTRACT_NOTHROW;
  2588| 	VolatileStoreWithoutBarrier<uint32_t>((uint32_t *)ptr, value);
  2589| }
  2590| static
  2591| inline
  2592| uint64_t
  2593| ep_rt_volatile_load_uint64_t (const volatile uint64_t *ptr)
  2594| {
  2595| 	STATIC_CONTRACT_NOTHROW;
  2596| 	return VolatileLoad<uint64_t> ((const uint64_t *)ptr);
  2597| }
  2598| static
  2599| inline
  2600| uint64_t
  2601| ep_rt_volatile_load_uint64_t_without_barrier (const volatile uint64_t *ptr)
  2602| {
  2603| 	STATIC_CONTRACT_NOTHROW;
  2604| 	return VolatileLoadWithoutBarrier<uint64_t> ((const uint64_t *)ptr);
  2605| }
  2606| static
  2607| inline
  2608| void
  2609| ep_rt_volatile_store_uint64_t (
  2610| 	volatile uint64_t *ptr,
  2611| 	uint64_t value)
  2612| {
  2613| 	STATIC_CONTRACT_NOTHROW;
  2614| 	VolatileStore<uint64_t> ((uint64_t *)ptr, value);
  2615| }
  2616| static
  2617| inline
  2618| void
  2619| ep_rt_volatile_store_uint64_t_without_barrier (
  2620| 	volatile uint64_t *ptr,
  2621| 	uint64_t value)
  2622| {
  2623| 	STATIC_CONTRACT_NOTHROW;
  2624| 	VolatileStoreWithoutBarrier<uint64_t> ((uint64_t *)ptr, value);
  2625| }
  2626| static
  2627| inline
  2628| int64_t
  2629| ep_rt_volatile_load_int64_t (const volatile int64_t *ptr)
  2630| {
  2631| 	STATIC_CONTRACT_NOTHROW;
  2632| 	return VolatileLoad<int64_t> ((int64_t *)ptr);
  2633| }
  2634| static
  2635| inline
  2636| int64_t
  2637| ep_rt_volatile_load_int64_t_without_barrier (const volatile int64_t *ptr)
  2638| {
  2639| 	STATIC_CONTRACT_NOTHROW;
  2640| 	return VolatileLoadWithoutBarrier<int64_t> ((int64_t *)ptr);
  2641| }
  2642| static
  2643| inline
  2644| void
  2645| ep_rt_volatile_store_int64_t (
  2646| 	volatile int64_t *ptr,
  2647| 	int64_t value)
  2648| {
  2649| 	STATIC_CONTRACT_NOTHROW;
  2650| 	VolatileStore<int64_t> ((int64_t *)ptr, value);
  2651| }
  2652| static
  2653| inline
  2654| void
  2655| ep_rt_volatile_store_int64_t_without_barrier (
  2656| 	volatile int64_t *ptr,
  2657| 	int64_t value)
  2658| {
  2659| 	STATIC_CONTRACT_NOTHROW;
  2660| 	VolatileStoreWithoutBarrier<int64_t> ((int64_t *)ptr, value);
  2661| }
  2662| static
  2663| inline
  2664| void *
  2665| ep_rt_volatile_load_ptr (volatile void **ptr)
  2666| {
  2667| 	STATIC_CONTRACT_NOTHROW;
  2668| 	return VolatileLoad<void *> ((void **)ptr);
  2669| }
  2670| static
  2671| inline
  2672| void *
  2673| ep_rt_volatile_load_ptr_without_barrier (volatile void **ptr)
  2674| {
  2675| 	STATIC_CONTRACT_NOTHROW;
  2676| 	return VolatileLoadWithoutBarrier<void *> ((void **)ptr);
  2677| }
  2678| static
  2679| inline
  2680| void
  2681| ep_rt_volatile_store_ptr (
  2682| 	volatile void **ptr,
  2683| 	void *value)
  2684| {
  2685| 	STATIC_CONTRACT_NOTHROW;
  2686| 	VolatileStore<void *> ((void **)ptr, value);
  2687| }
  2688| static
  2689| inline
  2690| void
  2691| ep_rt_volatile_store_ptr_without_barrier (
  2692| 	volatile void **ptr,
  2693| 	void *value)
  2694| {
  2695| 	STATIC_CONTRACT_NOTHROW;
  2696| 	VolatileStoreWithoutBarrier<void *> ((void **)ptr, value);
  2697| }
  2698| #endif /* ENABLE_PERFTRACING */
  2699| #endif /* __EVENTPIPE_RT_CORECLR_H__ */


# ====================================================================
# FILE: src/libraries/Common/src/Interop/Unix/System.Security.Cryptography.Native/Interop.OpenSsl.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-697 ---
     1| using System;
     2| using System.Collections.Concurrent;
     3| using System.Collections.Generic;
     4| using System.Diagnostics;
     5| using System.Globalization;
     6| using System.IO;
     7| using System.Net;
     8| using System.Net.Security;
     9| using System.Runtime.InteropServices;
    10| using System.Security.Authentication;
    11| using System.Security.Authentication.ExtendedProtection;
    12| using System.Security.Cryptography;
    13| using System.Security.Cryptography.X509Certificates;
    14| using Microsoft.Win32.SafeHandles;
    15| internal static partial class Interop
    16| {
    17|     internal static partial class OpenSsl
    18|     {
    19|         private const string DisableTlsResumeCtxSwitch = "System.Net.Security.DisableTlsResume";
    20|         private const string DisableTlsResumeEnvironmentVariable = "DOTNET_SYSTEM_NET_SECURITY_DISABLETLSRESUME";
    21|         private const string TlsCacheSizeCtxName = "System.Net.Security.TlsCacheSize";
    22|         private const string TlsCacheSizeEnvironmentVariable = "DOTNET_SYSTEM_NET_SECURITY_TLSCACHESIZE";
    23|         private const SslProtocols FakeAlpnSslProtocol = (SslProtocols)1;   // used to distinguish server sessions with ALPN
    24|         private static readonly IdnMapping s_idnMapping = new IdnMapping();
    25|         private static readonly ConcurrentDictionary<SslProtocols, SafeSslContextHandle> s_clientSslContexts = new ConcurrentDictionary<SslProtocols, SafeSslContextHandle>();
    26|         #region internal methods
    27|         internal static SafeChannelBindingHandle? QueryChannelBinding(SafeSslHandle context, ChannelBindingKind bindingType)
    28|         {
    29|             Debug.Assert(
    30|                 bindingType != ChannelBindingKind.Endpoint,
    31|                 "Endpoint binding should be handled by EndpointChannelBindingToken");
    32|             SafeChannelBindingHandle? bindingHandle;
    33|             switch (bindingType)
    34|             {
    35|                 case ChannelBindingKind.Unique:
    36|                     bindingHandle = new SafeChannelBindingHandle(bindingType);
    37|                     QueryUniqueChannelBinding(context, bindingHandle);
    38|                     break;
    39|                 default:
    40|                     bindingHandle = null;
    41|                     break;
    42|             }
    43|             return bindingHandle;
    44|         }
    45|         private static int s_cacheSize = GetCacheSize();
    46|         private static volatile int s_disableTlsResume = -1;
    47|         private static bool DisableTlsResume
    48|         {
    49|             get
    50|             {
    51|                 int disableTlsResume = s_disableTlsResume;
    52|                 if (disableTlsResume != -1)
    53|                 {
    54|                     return disableTlsResume != 0;
    55|                 }
    56|                 if (AppContext.TryGetSwitch(DisableTlsResumeCtxSwitch, out bool value))
    57|                 {
    58|                     s_disableTlsResume = value ? 1 : 0;
    59|                 }
    60|                 else
    61|                 {
    62|                     s_disableTlsResume =
    63|                         Environment.GetEnvironmentVariable(DisableTlsResumeEnvironmentVariable) is string envVar &&
    64|                         (envVar == "1" || envVar.Equals("true", StringComparison.OrdinalIgnoreCase)) ? 1 : 0;
    65|                 }
    66|                 return s_disableTlsResume != 0;
    67|             }
    68|         }
    69|         private static int GetCacheSize()
    70|         {
    71|             int cacheSize = -1;
    72|             string? value = AppContext.GetData(TlsCacheSizeCtxName) as string ?? Environment.GetEnvironmentVariable(TlsCacheSizeEnvironmentVariable);
    73|             try
    74|             {
    75|                 if (value != null)
    76|                 {
    77|                     cacheSize = int.Parse(value);
    78|                 }
    79|             }
    80|             catch { };
    81|             return cacheSize;
    82|         }
    83|         private static SslProtocols CalculateEffectiveProtocols(SslAuthenticationOptions sslAuthenticationOptions)
    84|         {
    85|             Debug.Assert((sslAuthenticationOptions.EnabledSslProtocols & FakeAlpnSslProtocol) == 0);
    86|             SslProtocols protocols = sslAuthenticationOptions.EnabledSslProtocols & ~((SslProtocols)1);
    87|             if (!Interop.Ssl.Capabilities.Tls13Supported)
    88|             {
    89|                 if (protocols != SslProtocols.None &&
    90|                     CipherSuitesPolicyPal.WantsTls13(protocols))
    91|                 {
    92|                     protocols &= ~SslProtocols.Tls13;
    93|                 }
    94|             }
    95|             else if (CipherSuitesPolicyPal.WantsTls13(protocols) &&
    96|                 CipherSuitesPolicyPal.ShouldOptOutOfTls13(sslAuthenticationOptions.CipherSuitesPolicy, sslAuthenticationOptions.EncryptionPolicy))
    97|             {
    98|                 if (protocols == SslProtocols.None)
    99|                 {
   100| #pragma warning disable SYSLIB0039 // TLS 1.0 and 1.1 are obsolete
   101|                     protocols = SslProtocols.Tls | SslProtocols.Tls11 | SslProtocols.Tls12;
   102| #pragma warning restore SYSLIB0039
   103|                 }
   104|                 else
   105|                 {
   106|                     throw new SslException(
   107|                         SR.Format(SR.net_ssl_encryptionpolicy_notsupported, sslAuthenticationOptions.EncryptionPolicy));
   108|                 }
   109|             }
   110|             if (CipherSuitesPolicyPal.ShouldOptOutOfLowerThanTls13(sslAuthenticationOptions.CipherSuitesPolicy, sslAuthenticationOptions.EncryptionPolicy))
   111|             {
   112|                 if (!CipherSuitesPolicyPal.WantsTls13(protocols))
   113|                 {
   114|                     throw new SslException(
   115|                         SR.Format(SR.net_ssl_encryptionpolicy_notsupported, sslAuthenticationOptions.EncryptionPolicy));
   116|                 }
   117|                 protocols = SslProtocols.Tls13;
   118|             }
   119|             return protocols;
   120|         }
   121|         internal static unsafe SafeSslContextHandle AllocateSslContext(SslAuthenticationOptions sslAuthenticationOptions, SslProtocols protocols, bool enableResume)
   122|         {
   123|             SafeSslContextHandle sslCtx = Ssl.SslCtxCreate(Ssl.SslMethods.SSLv23_method);
   124|             try
   125|             {
   126|                 if (sslCtx.IsInvalid)
   127|                 {
   128|                     throw CreateSslException(SR.net_allocate_ssl_context_failed);
   129|                 }
   130|                 Ssl.SslCtxSetProtocolOptions(sslCtx, protocols);
   131|                 if (sslAuthenticationOptions.EncryptionPolicy != EncryptionPolicy.RequireEncryption)
   132|                 {
   133|                     if (!Ssl.SetEncryptionPolicy(sslCtx, sslAuthenticationOptions.EncryptionPolicy))
   134|                     {
   135|                         throw new SslException(SR.Format(SR.net_ssl_encryptionpolicy_notsupported, sslAuthenticationOptions.EncryptionPolicy));
   136|                     }
   137|                 }
   138|                 ReadOnlySpan<byte> cipherList = CipherSuitesPolicyPal.GetOpenSslCipherList(sslAuthenticationOptions.CipherSuitesPolicy, protocols, sslAuthenticationOptions.EncryptionPolicy);
   139|                 Debug.Assert(cipherList.IsEmpty || cipherList[^1] == 0);
   140|                 byte[]? cipherSuites = CipherSuitesPolicyPal.GetOpenSslCipherSuites(sslAuthenticationOptions.CipherSuitesPolicy, protocols, sslAuthenticationOptions.EncryptionPolicy);
   141|                 Debug.Assert(cipherSuites == null || (cipherSuites.Length >= 1 && cipherSuites[cipherSuites.Length - 1] == 0));
   142|                 fixed (byte* cipherListStr = cipherList)
   143|                 fixed (byte* cipherSuitesStr = cipherSuites)
   144|                 {
   145|                     if (!Ssl.SslCtxSetCiphers(sslCtx, cipherListStr, cipherSuitesStr))
   146|                     {
   147|                         Crypto.ErrClearError();
   148|                         throw new PlatformNotSupportedException(SR.Format(SR.net_ssl_encryptionpolicy_notsupported, sslAuthenticationOptions.EncryptionPolicy));
   149|                     }
   150|                 }
   151|                 Ssl.SslCtxSetQuietShutdown(sslCtx);
   152|                 if (enableResume)
   153|                 {
   154|                     if (sslAuthenticationOptions.IsServer)
   155|                     {
   156|                         Span<byte> contextId = stackalloc byte[32];
   157|                         RandomNumberGenerator.Fill(contextId);
   158|                         Ssl.SslCtxSetCaching(sslCtx, 1, s_cacheSize, contextId.Length, contextId, null, null);
   159|                     }
   160|                     else
   161|                     {
   162|                         int result = Ssl.SslCtxSetCaching(sslCtx, 1, s_cacheSize, 0, null, &NewSessionCallback, &RemoveSessionCallback);
   163|                         Debug.Assert(result == 1);
   164|                         sslCtx.EnableSessionCache();
   165|                     }
   166|                 }
   167|                 else
   168|                 {
   169|                     Ssl.SslCtxSetCaching(sslCtx, 0, -1, 0, null, null, null);
   170|                 }
   171|                 if (sslAuthenticationOptions.IsServer && sslAuthenticationOptions.ApplicationProtocols != null && sslAuthenticationOptions.ApplicationProtocols.Count != 0)
   172|                 {
   173|                     Interop.Ssl.SslCtxSetAlpnSelectCb(sslCtx, &AlpnServerSelectCallback, IntPtr.Zero);
   174|                 }
   175|                 if (sslAuthenticationOptions.CertificateContext != null)
   176|                 {
   177|                     SetSslCertificate(sslCtx, sslAuthenticationOptions.CertificateContext.CertificateHandle, sslAuthenticationOptions.CertificateContext.KeyHandle);
   178|                     if (sslAuthenticationOptions.CertificateContext.IntermediateCertificates.Length > 0)
   179|                     {
   180|                         if (!Ssl.AddExtraChainCertificates(sslCtx, sslAuthenticationOptions.CertificateContext.IntermediateCertificates))
   181|                         {
   182|                             throw CreateSslException(SR.net_ssl_use_cert_failed);
   183|                         }
   184|                     }
   185|                     if (sslAuthenticationOptions.CertificateContext.OcspStaplingAvailable)
   186|                     {
   187|                         Ssl.SslCtxSetDefaultOcspCallback(sslCtx);
   188|                     }
   189|                 }
   190|             }
   191|             catch
   192|             {
   193|                 sslCtx.Dispose();
   194|                 throw;
   195|             }
   196|             return sslCtx;
   197|         }
   198|         internal static void UpdateClientCertiticate(SafeSslHandle ssl, SslAuthenticationOptions sslAuthenticationOptions)
   199|         {
   200|             Interop.Ssl.SslSetClientCertCallback(ssl, 0);
   201|             if (sslAuthenticationOptions.CertificateContext == null)
   202|             {
   203|                 return;
   204|             }
   205|             Debug.Assert(sslAuthenticationOptions.CertificateContext.CertificateHandle != null);
   206|             Debug.Assert(sslAuthenticationOptions.CertificateContext.KeyHandle != null);
   207|             int retVal = Ssl.SslUseCertificate(ssl, sslAuthenticationOptions.CertificateContext.CertificateHandle);
   208|             if (1 != retVal)
   209|             {
   210|                 throw CreateSslException(SR.net_ssl_use_cert_failed);
   211|             }
   212|             retVal = Ssl.SslUsePrivateKey(ssl, sslAuthenticationOptions.CertificateContext.KeyHandle);
   213|             if (1 != retVal)
   214|             {
   215|                 throw CreateSslException(SR.net_ssl_use_private_key_failed);
   216|             }
   217|             if (sslAuthenticationOptions.CertificateContext.IntermediateCertificates.Length > 0)
   218|             {
   219|                 if (!Ssl.AddExtraChainCertificates(ssl, sslAuthenticationOptions.CertificateContext.IntermediateCertificates))
   220|                 {
   221|                     throw CreateSslException(SR.net_ssl_use_cert_failed);
   222|                 }
   223|             }
   224|         }
   225|         internal static SafeSslHandle AllocateSslHandle(SslAuthenticationOptions sslAuthenticationOptions)
   226|         {
   227|             SafeSslHandle? sslHandle = null;
   228|             SafeSslContextHandle? sslCtxHandle = null;
   229|             SafeSslContextHandle? newCtxHandle = null;
   230|             SslProtocols protocols = CalculateEffectiveProtocols(sslAuthenticationOptions);
   231|             bool hasAlpn = sslAuthenticationOptions.ApplicationProtocols != null && sslAuthenticationOptions.ApplicationProtocols.Count != 0;
   232|             bool cacheSslContext = !DisableTlsResume && sslAuthenticationOptions.EncryptionPolicy == EncryptionPolicy.RequireEncryption && sslAuthenticationOptions.CipherSuitesPolicy == null;
   233|             if (cacheSslContext)
   234|             {
   235|                 if (sslAuthenticationOptions.IsClient)
   236|                 {
   237|                     if (!Interop.Ssl.Capabilities.Tls13Supported ||
   238|                        string.IsNullOrEmpty(sslAuthenticationOptions.TargetHost) ||
   239|                        sslAuthenticationOptions.CertificateContext != null ||
   240|                        sslAuthenticationOptions.ClientCertificates?.Count > 0 ||
   241|                        sslAuthenticationOptions.CertSelectionDelegate != null)
   242|                     {
   243|                         cacheSslContext = false;
   244|                     }
   245|                 }
   246|                 else
   247|                 {
   248|                     Debug.Assert(sslAuthenticationOptions.CertificateContext != null);
   249|                     if (sslAuthenticationOptions.CertificateContext == null ||
   250|                        sslAuthenticationOptions.CertificateContext.SslContexts == null)
   251|                     {
   252|                         cacheSslContext = false;
   253|                     }
   254|                 }
   255|             }
   256|             if (cacheSslContext)
   257|             {
   258|                 if (sslAuthenticationOptions.IsServer)
   259|                 {
   260|                     sslAuthenticationOptions.CertificateContext!.SslContexts!.TryGetValue(protocols | (hasAlpn ? FakeAlpnSslProtocol : SslProtocols.None), out sslCtxHandle);
   261|                 }
   262|                 else
   263|                 {
   264|                     s_clientSslContexts.TryGetValue(protocols, out sslCtxHandle);
   265|                 }
   266|             }
   267|             if (sslCtxHandle == null)
   268|             {
   269|                 sslCtxHandle = newCtxHandle = AllocateSslContext(sslAuthenticationOptions, protocols, cacheSslContext);
   270|                 if (cacheSslContext)
   271|                 {
   272|                     bool added = sslAuthenticationOptions.IsServer ?
   273|                                     sslAuthenticationOptions.CertificateContext!.SslContexts!.TryAdd(protocols | (SslProtocols)(hasAlpn ? 1 : 0), newCtxHandle) :
   274|                                     s_clientSslContexts.TryAdd(protocols, newCtxHandle);
   275|                     if (added)
   276|                     {
   277|                         newCtxHandle = null;
   278|                     }
   279|                 }
   280|             }
   281|             GCHandle alpnHandle = default;
   282|             try
   283|             {
   284|                 sslHandle = SafeSslHandle.Create(sslCtxHandle, sslAuthenticationOptions.IsServer);
   285|                 Debug.Assert(sslHandle != null, "Expected non-null return value from SafeSslHandle.Create");
   286|                 if (sslHandle.IsInvalid)
   287|                 {
   288|                     sslHandle.Dispose();
   289|                     throw CreateSslException(SR.net_allocate_ssl_context_failed);
   290|                 }
   291|                 if (sslAuthenticationOptions.ApplicationProtocols != null && sslAuthenticationOptions.ApplicationProtocols.Count != 0)
   292|                 {
   293|                     if (sslAuthenticationOptions.IsServer)
   294|                     {
   295|                         Debug.Assert(Interop.Ssl.SslGetData(sslHandle) == IntPtr.Zero);
   296|                         alpnHandle = GCHandle.Alloc(sslAuthenticationOptions.ApplicationProtocols);
   297|                         Interop.Ssl.SslSetData(sslHandle, GCHandle.ToIntPtr(alpnHandle));
   298|                         sslHandle.AlpnHandle = alpnHandle;
   299|                     }
   300|                     else
   301|                     {
   302|                         if (Interop.Ssl.SslSetAlpnProtos(sslHandle, sslAuthenticationOptions.ApplicationProtocols) != 0)
   303|                         {
   304|                             throw CreateSslException(SR.net_alpn_config_failed);
   305|                         }
   306|                     }
   307|                 }
   308|                 if (sslAuthenticationOptions.IsClient)
   309|                 {
   310|                     string punyCode = string.IsNullOrEmpty(sslAuthenticationOptions.TargetHost) ? string.Empty : s_idnMapping.GetAscii(sslAuthenticationOptions.TargetHost!);
   311|                     if (!Ssl.SslSetTlsExtHostName(sslHandle, punyCode))
   312|                     {
   313|                         Crypto.ErrClearError();
   314|                     }
   315|                     if (cacheSslContext && !string.IsNullOrEmpty(punyCode))
   316|                     {
   317|                         sslCtxHandle.TrySetSession(sslHandle, punyCode);
   318|                         bool ignored = false;
   319|                         sslCtxHandle.DangerousAddRef(ref ignored);
   320|                         sslHandle.SslContextHandle = sslCtxHandle;
   321|                     }
   322|                     if (sslAuthenticationOptions.ClientCertificates?.Count > 0 ||
   323|                         sslAuthenticationOptions.CertSelectionDelegate != null)
   324|                     {
   325|                         Ssl.SslSetPostHandshakeAuth(sslHandle, 1);
   326|                     }
   327|                     Ssl.SslSetClientCertCallback(sslHandle, 1);
   328|                 }
   329|                 else // sslAuthenticationOptions.IsServer
   330|                 {
   331|                     if (sslAuthenticationOptions.RemoteCertRequired)
   332|                     {
   333|                         Ssl.SslSetVerifyPeer(sslHandle);
   334|                     }
   335|                     if (sslAuthenticationOptions.CertificateContext != null)
   336|                     {
   337|                         if (sslAuthenticationOptions.CertificateContext.Trust?._sendTrustInHandshake == true)
   338|                         {
   339|                             SslCertificateTrust trust = sslAuthenticationOptions.CertificateContext!.Trust!;
   340|                             X509Certificate2Collection certList = (trust._trustList ?? trust._store!.Certificates);
   341|                             Debug.Assert(certList != null, "certList != null");
   342|                             Span<IntPtr> handles = certList.Count <= 256 ?
   343|                                 stackalloc IntPtr[256] :
   344|                                 new IntPtr[certList.Count];
   345|                             for (int i = 0; i < certList.Count; i++)
   346|                             {
   347|                                 handles[i] = certList[i].Handle;
   348|                             }
   349|                             if (!Ssl.SslAddClientCAs(sslHandle, handles.Slice(0, certList.Count)))
   350|                             {
   351|                                 Debug.Fail("Failed to add issuer to trusted CA list.");
   352|                             }
   353|                         }
   354|                         byte[]? ocspResponse = sslAuthenticationOptions.CertificateContext.GetOcspResponseNoWaiting();
   355|                         if (ocspResponse != null)
   356|                         {
   357|                             Ssl.SslStapleOcsp(sslHandle, ocspResponse);
   358|                         }
   359|                     }
   360|                 }
   361|             }
   362|             catch
   363|             {
   364|                 if (alpnHandle.IsAllocated)
   365|                 {
   366|                     alpnHandle.Free();
   367|                 }
   368|                 throw;
   369|             }
   370|             finally
   371|             {
   372|                 newCtxHandle?.Dispose();
   373|             }
   374|             return sslHandle;
   375|         }
   376|         internal static SecurityStatusPal SslRenegotiate(SafeSslHandle sslContext, out byte[]? outputBuffer)
   377|         {
   378|             int ret = Interop.Ssl.SslRenegotiate(sslContext, out Ssl.SslErrorCode errorCode);
   379|             outputBuffer = Array.Empty<byte>();
   380|             if (ret != 1)
   381|             {
   382|                 return new SecurityStatusPal(SecurityStatusPalErrorCode.InternalError, GetSslError(ret, errorCode));
   383|             }
   384|             return new SecurityStatusPal(SecurityStatusPalErrorCode.OK);
   385|         }
   386|         internal static SecurityStatusPalErrorCode DoSslHandshake(SafeSslHandle context, ReadOnlySpan<byte> input, out byte[]? sendBuf, out int sendCount)
   387|         {
   388|             sendBuf = null;
   389|             sendCount = 0;
   390|             Exception? handshakeException = null;
   391|             if (input.Length > 0)
   392|             {
   393|                 if (Ssl.BioWrite(context.InputBio!, ref MemoryMarshal.GetReference(input), input.Length) != input.Length)
   394|                 {
   395|                     throw Crypto.CreateOpenSslCryptographicException();
   396|                 }
   397|             }
   398|             int retVal = Ssl.SslDoHandshake(context, out Ssl.SslErrorCode errorCode);
   399|             if (retVal != 1)
   400|             {
   401|                 if (errorCode == Ssl.SslErrorCode.SSL_ERROR_WANT_X509_LOOKUP)
   402|                 {
   403|                     return SecurityStatusPalErrorCode.CredentialsNeeded;
   404|                 }
   405|                 if ((retVal != -1) || (errorCode != Ssl.SslErrorCode.SSL_ERROR_WANT_READ))
   406|                 {
   407|                     Exception? innerError = GetSslError(retVal, errorCode);
   408|                     handshakeException = new SslException(SR.Format(SR.net_ssl_handshake_failed_error, errorCode), innerError);
   409|                 }
   410|             }
   411|             sendCount = Crypto.BioCtrlPending(context.OutputBio!);
   412|             if (sendCount > 0)
   413|             {
   414|                 sendBuf = new byte[sendCount];
   415|                 try
   416|                 {
   417|                     sendCount = BioRead(context.OutputBio!, sendBuf, sendCount);
   418|                 }
   419|                 catch (Exception) when (handshakeException != null)
   420|                 {
   421|                 }
   422|                 finally
   423|                 {
   424|                     if (sendCount <= 0)
   425|                     {
   426|                         Crypto.ErrClearError();
   427|                         sendBuf = null;
   428|                         sendCount = 0;
   429|                     }
   430|                 }
   431|             }
   432|             if (handshakeException != null)
   433|             {
   434|                 throw handshakeException;
   435|             }
   436|             bool stateOk = Ssl.IsSslStateOK(context);
   437|             if (stateOk)
   438|             {
   439|                 context.MarkHandshakeCompleted();
   440|             }
   441|             return stateOk ? SecurityStatusPalErrorCode.OK : SecurityStatusPalErrorCode.ContinueNeeded;
   442|         }
   443|         internal static int Encrypt(SafeSslHandle context, ReadOnlySpan<byte> input, ref byte[] output, out Ssl.SslErrorCode errorCode)
   444|         {
   445|             int retVal = Ssl.SslWrite(context, ref MemoryMarshal.GetReference(input), input.Length, out errorCode);
   446|             if (retVal != input.Length)
   447|             {
   448|                 retVal = 0;
   449|                 switch (errorCode)
   450|                 {
   451|                     case Ssl.SslErrorCode.SSL_ERROR_ZERO_RETURN:
   452|                     case Ssl.SslErrorCode.SSL_ERROR_WANT_READ:
   453|                         break;
   454|                     default:
   455|                         throw new SslException(SR.Format(SR.net_ssl_encrypt_failed, errorCode), GetSslError(retVal, errorCode));
   456|                 }
   457|             }
   458|             else
   459|             {
   460|                 int capacityNeeded = Crypto.BioCtrlPending(context.OutputBio!);
   461|                 if (output == null || output.Length < capacityNeeded)
   462|                 {
   463|                     output = new byte[capacityNeeded];
   464|                 }
   465|                 retVal = BioRead(context.OutputBio!, output, capacityNeeded);
   466|                 if (retVal <= 0)
   467|                 {
   468|                     Crypto.ErrClearError();
   469|                 }
   470|             }
   471|             return retVal;
   472|         }
   473|         internal static int Decrypt(SafeSslHandle context, Span<byte> buffer, out Ssl.SslErrorCode errorCode)
   474|         {
   475|             BioWrite(context.InputBio!, buffer);
   476|             int retVal = Ssl.SslRead(context, ref MemoryMarshal.GetReference(buffer), buffer.Length, out errorCode);
   477|             if (retVal > 0)
   478|             {
   479|                 return retVal;
   480|             }
   481|             switch (errorCode)
   482|             {
   483|                 case Ssl.SslErrorCode.SSL_ERROR_ZERO_RETURN:
   484|                     break;
   485|                 case Ssl.SslErrorCode.SSL_ERROR_WANT_READ:
   486|                     errorCode = Ssl.IsSslRenegotiatePending(context)
   487|                         ? Ssl.SslErrorCode.SSL_ERROR_RENEGOTIATE
   488|                         : Ssl.SslErrorCode.SSL_ERROR_WANT_READ;
   489|                     break;
   490|                 case Ssl.SslErrorCode.SSL_ERROR_WANT_X509_LOOKUP:
   491|                     errorCode = Ssl.SslErrorCode.SSL_ERROR_RENEGOTIATE;
   492|                     break;
   493|                 default:
   494|                     throw new SslException(SR.Format(SR.net_ssl_decrypt_failed, errorCode), GetSslError(retVal, errorCode));
   495|             }
   496|             return 0;
   497|         }
   498|         internal static SafeX509Handle GetPeerCertificate(SafeSslHandle context)
   499|         {
   500|             return Ssl.SslGetPeerCertificate(context);
   501|         }
   502|         internal static SafeSharedX509StackHandle GetPeerCertificateChain(SafeSslHandle context)
   503|         {
   504|             return Ssl.SslGetPeerCertChain(context);
   505|         }
   506|         #endregion
   507|         #region private methods
   508|         private static void QueryUniqueChannelBinding(SafeSslHandle context, SafeChannelBindingHandle bindingHandle)
   509|         {
   510|             bool sessionReused = Ssl.SslSessionReused(context);
   511|             int certHashLength = context.IsServer ^ sessionReused ?
   512|                                  Ssl.SslGetPeerFinished(context, bindingHandle.CertHashPtr, bindingHandle.Length) :
   513|                                  Ssl.SslGetFinished(context, bindingHandle.CertHashPtr, bindingHandle.Length);
   514|             if (0 == certHashLength)
   515|             {
   516|                 throw CreateSslException(SR.net_ssl_get_channel_binding_token_failed);
   517|             }
   518|             bindingHandle.SetCertHashLength(certHashLength);
   519|         }
   520|         [UnmanagedCallersOnly]
   521|         private static int VerifyClientCertificate(int preverify_ok, IntPtr x509_ctx_ptr)
   522|         {
   523|             const int OpenSslSuccess = 1;
   524|             return OpenSslSuccess;
   525|         }
   526|         [UnmanagedCallersOnly]
   527|         private static unsafe int AlpnServerSelectCallback(IntPtr ssl, byte** outp, byte* outlen, byte* inp, uint inlen, IntPtr arg)
   528|         {
   529|             *outp = null;
   530|             *outlen = 0;
   531|             IntPtr sslData = Ssl.SslGetData(ssl);
   532|             if (sslData == IntPtr.Zero)
   533|             {
   534|                 return Ssl.SSL_TLSEXT_ERR_ALERT_FATAL;
   535|             }
   536|             Ssl.SslSetData(ssl, IntPtr.Zero);
   537|             GCHandle protocolHandle = GCHandle.FromIntPtr(sslData);
   538|             if (!(protocolHandle.Target is List<SslApplicationProtocol> protocolList))
   539|             {
   540|                 return Ssl.SSL_TLSEXT_ERR_ALERT_FATAL;
   541|             }
   542|             try
   543|             {
   544|                 for (int i = 0; i < protocolList.Count; i++)
   545|                 {
   546|                     var clientList = new Span<byte>(inp, (int)inlen);
   547|                     while (clientList.Length > 0)
   548|                     {
   549|                         byte length = clientList[0];
   550|                         Span<byte> clientProto = clientList.Slice(1, length);
   551|                         if (clientProto.SequenceEqual(protocolList[i].Protocol.Span))
   552|                         {
   553|                             fixed (byte* p = &MemoryMarshal.GetReference(clientProto)) *outp = p;
   554|                             *outlen = length;
   555|                             return Ssl.SSL_TLSEXT_ERR_OK;
   556|                         }
   557|                         clientList = clientList.Slice(1 + length);
   558|                     }
   559|                 }
   560|             }
   561|             catch
   562|             {
   563|                 protocolHandle.Target = null;
   564|                 return Ssl.SSL_TLSEXT_ERR_ALERT_FATAL;
   565|             }
   566|             protocolHandle.Target = null;
   567|             return Ssl.SSL_TLSEXT_ERR_ALERT_FATAL;
   568|         }
   569|         [UnmanagedCallersOnly]
   570|         private static unsafe int NewSessionCallback(IntPtr ssl, IntPtr session)
   571|         {
   572|             Debug.Assert(ssl != IntPtr.Zero);
   573|             Debug.Assert(session != IntPtr.Zero);
   574|             IntPtr ptr = Ssl.SslGetData(ssl);
   575|             Debug.Assert(ptr != IntPtr.Zero);
   576|             GCHandle gch = GCHandle.FromIntPtr(ptr);
   577|             SafeSslContextHandle? ctxHandle = gch.Target as SafeSslContextHandle;
   578|             if (ctxHandle != null && ctxHandle.TryAddSession(Ssl.SslGetServerName(ssl), session))
   579|             {
   580|                 return 1;
   581|             }
   582|             return 0;
   583|         }
   584|         [UnmanagedCallersOnly]
   585|         private static unsafe void RemoveSessionCallback(IntPtr ctx, IntPtr session)
   586|         {
   587|             Debug.Assert(ctx != IntPtr.Zero && session != IntPtr.Zero);
   588|             IntPtr ptr = Ssl.SslCtxGetData(ctx);
   589|             if (ptr == IntPtr.Zero)
   590|             {
   591|                 return;
   592|             }
   593|             GCHandle gch = GCHandle.FromIntPtr(ptr);
   594|             SafeSslContextHandle? ctxHandle = gch.Target as SafeSslContextHandle;
   595|             if (ctxHandle == null)
   596|             {
   597|                 return;
   598|             }
   599|             IntPtr name = Ssl.SessionGetHostname(session);
   600|             Debug.Assert(name != IntPtr.Zero);
   601|             ctxHandle.RemoveSession(name, session);
   602|         }
   603|         private static int BioRead(SafeBioHandle bio, byte[] buffer, int count)
   604|         {
   605|             Debug.Assert(buffer != null);
   606|             Debug.Assert(count >= 0);
   607|             Debug.Assert(buffer.Length >= count);
   608|             int bytes = Crypto.BioRead(bio, buffer, count);
   609|             if (bytes != count)
   610|             {
   611|                 throw CreateSslException(SR.net_ssl_read_bio_failed_error);
   612|             }
   613|             return bytes;
   614|         }
   615|         private static void BioWrite(SafeBioHandle bio, ReadOnlySpan<byte> buffer)
   616|         {
   617|             int bytes = Ssl.BioWrite(bio, ref MemoryMarshal.GetReference(buffer), buffer.Length);
   618|             if (bytes != buffer.Length)
   619|             {
   620|                 throw CreateSslException(SR.net_ssl_write_bio_failed_error);
   621|             }
   622|         }
   623|         private static Exception? GetSslError(int result, Ssl.SslErrorCode retVal)
   624|         {
   625|             Exception? innerError;
   626|             switch (retVal)
   627|             {
   628|                 case Ssl.SslErrorCode.SSL_ERROR_SYSCALL:
   629|                     ErrorInfo lastErrno = Sys.GetLastErrorInfo();
   630|                     innerError =
   631|                         Crypto.ErrPeekError() != 0 ? Crypto.CreateOpenSslCryptographicException() : // crypto error queue not empty
   632|                         result == 0 ? new EndOfStreamException() : // end of file that violates protocol
   633|                         result == -1 && lastErrno.Error != Error.SUCCESS ? new IOException(lastErrno.GetErrorMessage(), lastErrno.RawErrno) : // underlying I/O error
   634|                         null; // no additional info available
   635|                     break;
   636|                 case Ssl.SslErrorCode.SSL_ERROR_SSL:
   637|                     innerError = Interop.Crypto.CreateOpenSslCryptographicException();
   638|                     break;
   639|                 default:
   640|                     innerError = null;
   641|                     break;
   642|             }
   643|             return innerError;
   644|         }
   645|         private static void SetSslCertificate(SafeSslContextHandle contextPtr, SafeX509Handle certPtr, SafeEvpPKeyHandle keyPtr)
   646|         {
   647|             Debug.Assert(certPtr != null && !certPtr.IsInvalid, "certPtr != null && !certPtr.IsInvalid");
   648|             Debug.Assert(keyPtr != null && !keyPtr.IsInvalid, "keyPtr != null && !keyPtr.IsInvalid");
   649|             int retVal = Ssl.SslCtxUseCertificate(contextPtr, certPtr);
   650|             if (1 != retVal)
   651|             {
   652|                 throw CreateSslException(SR.net_ssl_use_cert_failed);
   653|             }
   654|             retVal = Ssl.SslCtxUsePrivateKey(contextPtr, keyPtr);
   655|             if (1 != retVal)
   656|             {
   657|                 throw CreateSslException(SR.net_ssl_use_private_key_failed);
   658|             }
   659|             retVal = Ssl.SslCtxCheckPrivateKey(contextPtr);
   660|             if (1 != retVal)
   661|             {
   662|                 throw CreateSslException(SR.net_ssl_check_private_key_failed);
   663|             }
   664|         }
   665|         internal static SslException CreateSslException(string message)
   666|         {
   667|             ulong errorVal = Crypto.ErrPeekLastError();
   668|             Crypto.ErrClearError();
   669|             string msg = SR.Format(message, Marshal.PtrToStringUTF8(Crypto.ErrReasonErrorString(errorVal)));
   670|             return new SslException(msg, (int)errorVal);
   671|         }
   672|         #endregion
   673|         #region Internal class
   674|         internal sealed class SslException : Exception
   675|         {
   676|             public SslException(string? inputMessage)
   677|                 : base(inputMessage)
   678|             {
   679|             }
   680|             public SslException(string? inputMessage, Exception? ex)
   681|                 : base(inputMessage, ex)
   682|             {
   683|             }
   684|             public SslException(string? inputMessage, int error)
   685|                 : this(inputMessage)
   686|             {
   687|                 HResult = error;
   688|             }
   689|             public SslException(int error)
   690|                 : this(SR.Format(SR.net_generic_operation_failed, error))
   691|             {
   692|                 HResult = error;
   693|             }
   694|         }
   695|         #endregion
   696|     }
   697| }


# ====================================================================
# FILE: src/libraries/Common/src/Interop/Unix/System.Security.Cryptography.Native/Interop.Ssl.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-361 ---
     1| using System;
     2| using System.Collections.Generic;
     3| using System.Diagnostics;
     4| using System.Net.Security;
     5| using System.Runtime.InteropServices;
     6| using System.Runtime.CompilerServices;
     7| using System.Security.Cryptography;
     8| using System.Security.Cryptography.X509Certificates;
     9| using Microsoft.Win32.SafeHandles;
    10| internal static partial class Interop
    11| {
    12|     internal static partial class Ssl
    13|     {
    14|         internal const int SSL_TLSEXT_ERR_OK = 0;
    15|         internal const int OPENSSL_NPN_NEGOTIATED = 1;
    16|         internal const int SSL_TLSEXT_ERR_ALERT_FATAL = 2;
    17|         internal const int SSL_TLSEXT_ERR_NOACK = 3;
    18|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslV2_3Method")]
    19|         internal static partial IntPtr SslV2_3Method();
    20|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslCreate")]
    21|         internal static partial SafeSslHandle SslCreate(SafeSslContextHandle ctx);
    22|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetError")]
    23|         internal static partial SslErrorCode SslGetError(SafeSslHandle ssl, int ret);
    24|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetError")]
    25|         internal static partial SslErrorCode SslGetError(IntPtr ssl, int ret);
    26|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSetQuietShutdown")]
    27|         internal static partial void SslSetQuietShutdown(SafeSslHandle ssl, int mode);
    28|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslDestroy")]
    29|         internal static partial void SslDestroy(IntPtr ssl);
    30|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSetConnectState")]
    31|         internal static partial void SslSetConnectState(SafeSslHandle ssl);
    32|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSetAcceptState")]
    33|         internal static partial void SslSetAcceptState(SafeSslHandle ssl);
    34|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSetAlpnProtos")]
    35|         internal static unsafe partial int SslSetAlpnProtos(SafeSslHandle ssl, byte* protos, int len);
    36|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetVersion")]
    37|         internal static partial IntPtr SslGetVersion(SafeSslHandle ssl);
    38|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSetTlsExtHostName", StringMarshalling = StringMarshalling.Utf8)]
    39|         [return: MarshalAs(UnmanagedType.Bool)]
    40|         internal static partial bool SslSetTlsExtHostName(SafeSslHandle ssl, string host);
    41|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetServerName")]
    42|         internal static unsafe partial IntPtr SslGetServerName(IntPtr ssl);
    43|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSetSession")]
    44|         internal static unsafe partial int SslSetSession(SafeSslHandle ssl, IntPtr session);
    45|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGet0AlpnSelected")]
    46|         internal static partial void SslGetAlpnSelected(SafeSslHandle ssl, out IntPtr protocol, out int len);
    47|         internal static unsafe ReadOnlySpan<byte> SslGetAlpnSelected(SafeSslHandle ssl)
    48|         {
    49|             IntPtr protocol;
    50|             int len;
    51|             SslGetAlpnSelected(ssl, out protocol, out len);
    52|             if (len == 0)
    53|                 return ReadOnlySpan<byte>.Empty;
    54|             return new ReadOnlySpan<byte>((void*)protocol, len);
    55|         }
    56|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslWrite", SetLastError = true)]
    57|         internal static partial int SslWrite(SafeSslHandle ssl, ref byte buf, int num, out SslErrorCode error);
    58|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslRead", SetLastError = true)]
    59|         internal static partial int SslRead(SafeSslHandle ssl, ref byte buf, int num, out SslErrorCode error);
    60|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslRenegotiate")]
    61|         internal static partial int SslRenegotiate(SafeSslHandle ssl, out SslErrorCode error);
    62|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_IsSslRenegotiatePending")]
    63|         [return: MarshalAs(UnmanagedType.Bool)]
    64|         internal static partial bool IsSslRenegotiatePending(SafeSslHandle ssl);
    65|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslShutdown")]
    66|         internal static partial int SslShutdown(IntPtr ssl);
    67|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslShutdown")]
    68|         internal static partial int SslShutdown(SafeSslHandle ssl);
    69|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSetBio")]
    70|         internal static partial void SslSetBio(SafeSslHandle ssl, SafeBioHandle rbio, SafeBioHandle wbio);
    71|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslDoHandshake", SetLastError = true)]
    72|         internal static partial int SslDoHandshake(SafeSslHandle ssl, out SslErrorCode error);
    73|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_IsSslStateOK")]
    74|         [return: MarshalAs(UnmanagedType.Bool)]
    75|         internal static partial bool IsSslStateOK(SafeSslHandle ssl);
    76|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_BioWrite")]
    77|         internal static unsafe partial int BioWrite(SafeBioHandle b, byte* data, int len);
    78|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_BioWrite")]
    79|         internal static partial int BioWrite(SafeBioHandle b, ref byte data, int len);
    80|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetPeerCertificate")]
    81|         internal static partial SafeX509Handle SslGetPeerCertificate(SafeSslHandle ssl);
    82|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetPeerCertChain")]
    83|         internal static partial SafeSharedX509StackHandle SslGetPeerCertChain(SafeSslHandle ssl);
    84|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetPeerFinished")]
    85|         internal static partial int SslGetPeerFinished(SafeSslHandle ssl, IntPtr buf, int count);
    86|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetFinished")]
    87|         internal static partial int SslGetFinished(SafeSslHandle ssl, IntPtr buf, int count);
    88|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSessionReused")]
    89|         [return: MarshalAs(UnmanagedType.Bool)]
    90|         internal static partial bool SslSessionReused(SafeSslHandle ssl);
    91|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetClientCAList")]
    92|         private static partial SafeSharedX509NameStackHandle SslGetClientCAList_private(SafeSslHandle ssl);
    93|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetCurrentCipherId")]
    94|         [return: MarshalAs(UnmanagedType.Bool)]
    95|         internal static partial bool SslGetCurrentCipherId(SafeSslHandle ssl, out int cipherId);
    96|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_GetOpenSslCipherSuiteName")]
    97|         private static partial IntPtr GetOpenSslCipherSuiteName(SafeSslHandle ssl, int cipherSuite, out int isTls12OrLower);
    98|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SetCiphers")]
    99|         [return: MarshalAs(UnmanagedType.Bool)]
   100|         internal static unsafe partial bool SslSetCiphers(SafeSslHandle ssl, byte* cipherList, byte* cipherSuites);
   101|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSetVerifyPeer")]
   102|         internal static partial void SslSetVerifyPeer(SafeSslHandle ssl);
   103|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetData")]
   104|         internal static partial IntPtr SslGetData(IntPtr ssl);
   105|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslGetData")]
   106|         internal static partial IntPtr SslGetData(SafeSslHandle ssl);
   107|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSetData")]
   108|         internal static partial int SslSetData(SafeSslHandle ssl, IntPtr data);
   109|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSetData")]
   110|         internal static partial int SslSetData(IntPtr ssl, IntPtr data);
   111|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslUseCertificate")]
   112|         internal static partial int SslUseCertificate(SafeSslHandle ssl, SafeX509Handle certPtr);
   113|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslUsePrivateKey")]
   114|         internal static partial int SslUsePrivateKey(SafeSslHandle ssl, SafeEvpPKeyHandle keyPtr);
   115|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSetClientCertCallback")]
   116|         internal static unsafe partial void SslSetClientCertCallback(SafeSslHandle ssl, int set);
   117|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSetPostHandshakeAuth")]
   118|         internal static partial void SslSetPostHandshakeAuth(SafeSslHandle ssl, int value);
   119|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_Tls13Supported")]
   120|         private static partial int Tls13SupportedImpl();
   121|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSessionGetHostname")]
   122|         internal static partial IntPtr SessionGetHostname(IntPtr session);
   123|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSessionFree")]
   124|         internal static partial void SessionFree(IntPtr session);
   125|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslSessionSetHostname")]
   126|         internal static partial int SessionSetHostname(IntPtr session, IntPtr name);
   127|         internal static class Capabilities
   128|         {
   129|             internal static readonly bool Tls13Supported = Tls13SupportedImpl() != 0;
   130|         }
   131|         internal static int GetAlpnProtocolListSerializedLength(List<SslApplicationProtocol> applicationProtocols)
   132|         {
   133|             int protocolSize = 0;
   134|             foreach (SslApplicationProtocol protocol in applicationProtocols)
   135|             {
   136|                 if (protocol.Protocol.Length == 0 || protocol.Protocol.Length > byte.MaxValue)
   137|                 {
   138|                     throw new ArgumentException(SR.net_ssl_app_protocols_invalid, nameof(applicationProtocols));
   139|                 }
   140|                 protocolSize += protocol.Protocol.Length + 1;
   141|             }
   142|             return protocolSize;
   143|         }
   144|         internal static void SerializeAlpnProtocolList(List<SslApplicationProtocol> applicationProtocols, Span<byte> buffer)
   145|         {
   146|             Debug.Assert(GetAlpnProtocolListSerializedLength(applicationProtocols) == buffer.Length,
   147|                 "GetAlpnProtocolListSerializedSize(applicationProtocols) == buffer.Length");
   148|             int offset = 0;
   149|             foreach (SslApplicationProtocol protocol in applicationProtocols)
   150|             {
   151|                 buffer[offset++] = (byte)protocol.Protocol.Length;
   152|                 protocol.Protocol.Span.CopyTo(buffer.Slice(offset));
   153|                 offset += protocol.Protocol.Length;
   154|             }
   155|         }
   156|         internal static unsafe int SslSetAlpnProtos(SafeSslHandle ssl, List<SslApplicationProtocol> applicationProtocols)
   157|         {
   158|             int length = GetAlpnProtocolListSerializedLength(applicationProtocols);
   159|             Span<byte> buffer = length <= 256 ? stackalloc byte[256].Slice(0, length) : new byte[length];
   160|             SerializeAlpnProtocolList(applicationProtocols, buffer);
   161|             return SslSetAlpnProtos(ssl, buffer);
   162|         }
   163|         internal static unsafe int SslSetAlpnProtos(SafeSslHandle ssl, Span<byte> serializedProtocols)
   164|         {
   165|             fixed (byte* pBuffer = &MemoryMarshal.GetReference(serializedProtocols))
   166|             {
   167|                 return SslSetAlpnProtos(ssl, pBuffer, serializedProtocols.Length);
   168|             }
   169|         }
   170|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslAddExtraChainCert")]
   171|         [return: MarshalAs(UnmanagedType.Bool)]
   172|         internal static partial bool SslAddExtraChainCert(SafeSslHandle ssl, SafeX509Handle x509);
   173|         [LibraryImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_SslAddClientCAs")]
   174|         [return: MarshalAs(UnmanagedType.Bool)]
   175|         private static unsafe partial bool SslAddClientCAs(SafeSslHandle ssl, IntPtr* x509s, int count);
   176|         internal static unsafe bool SslAddClientCAs(SafeSslHandle ssl, Span<IntPtr> x509handles)
   177|         {
   178|             fixed (IntPtr* pHandles = &MemoryMarshal.GetReference(x509handles))
   179|             {
   180|                 return SslAddClientCAs(ssl, pHandles, x509handles.Length);
   181|             }
   182|         }
   183|         [LibraryImport(Libraries.CryptoNative)]
   184|         private static unsafe partial void CryptoNative_SslStapleOcsp(SafeSslHandle ssl, byte* buf, int len);
   185|         internal static unsafe void SslStapleOcsp(SafeSslHandle ssl, ReadOnlySpan<byte> stapledResponse)
   186|         {
   187|             Debug.Assert(stapledResponse.Length > 0);
   188|             fixed (byte* ptr = stapledResponse)
   189|             {
   190|                 CryptoNative_SslStapleOcsp(ssl, ptr, stapledResponse.Length);
   191|             }
   192|         }
   193|         internal static bool AddExtraChainCertificates(SafeSslHandle ssl, X509Certificate2[] chain)
   194|         {
   195|             for (int i = 0; i < chain.Length; i++)
   196|             {
   197|                 SafeX509Handle dupCertHandle = Crypto.X509UpRef(chain[i].Handle);
   198|                 Crypto.CheckValidOpenSslHandle(dupCertHandle);
   199|                 if (!SslAddExtraChainCert(ssl, dupCertHandle))
   200|                 {
   201|                     Crypto.ErrClearError();
   202|                     dupCertHandle.Dispose(); // we still own the safe handle; clean it up
   203|                     return false;
   204|                 }
   205|                 dupCertHandle.SetHandleAsInvalid(); // ownership has been transferred to sslHandle; do not free via this safe handle
   206|             }
   207|             return true;
   208|         }
   209|         internal static string? GetOpenSslCipherSuiteName(SafeSslHandle ssl, TlsCipherSuite cipherSuite, out bool isTls12OrLower)
   210|         {
   211|             string? ret = Marshal.PtrToStringUTF8(GetOpenSslCipherSuiteName(ssl, (int)cipherSuite, out int isTls12OrLowerInt));
   212|             isTls12OrLower = isTls12OrLowerInt != 0;
   213|             return ret;
   214|         }
   215|         internal static SafeSharedX509NameStackHandle SslGetClientCAList(SafeSslHandle ssl)
   216|         {
   217|             Crypto.CheckValidOpenSslHandle(ssl);
   218|             SafeSharedX509NameStackHandle handle = SslGetClientCAList_private(ssl);
   219|             if (!handle.IsInvalid)
   220|             {
   221|                 handle.SetParent(ssl);
   222|             }
   223|             return handle;
   224|         }
   225|         internal static class SslMethods
   226|         {
   227|             internal static readonly IntPtr SSLv23_method = SslV2_3Method();
   228|         }
   229|         internal enum SslErrorCode
   230|         {
   231|             SSL_ERROR_NONE = 0,
   232|             SSL_ERROR_SSL = 1,
   233|             SSL_ERROR_WANT_READ = 2,
   234|             SSL_ERROR_WANT_WRITE = 3,
   235|             SSL_ERROR_WANT_X509_LOOKUP = 4,
   236|             SSL_ERROR_SYSCALL = 5,
   237|             SSL_ERROR_ZERO_RETURN = 6,
   238|             SSL_ERROR_RENEGOTIATE = 29304
   239|         }
   240|     }
   241| }
   242| namespace Microsoft.Win32.SafeHandles
   243| {
   244|     internal sealed class SafeSslHandle : SafeDeleteSslContext
   245|     {
   246|         private SafeBioHandle? _readBio;
   247|         private SafeBioHandle? _writeBio;
   248|         private bool _isServer;
   249|         private bool _handshakeCompleted;
   250|         public GCHandle AlpnHandle;
   251|         public SafeSslContextHandle? SslContextHandle;
   252|         public bool IsServer
   253|         {
   254|             get { return _isServer; }
   255|         }
   256|         public SafeBioHandle? InputBio
   257|         {
   258|             get
   259|             {
   260|                 return _readBio;
   261|             }
   262|         }
   263|         public SafeBioHandle? OutputBio
   264|         {
   265|             get
   266|             {
   267|                 return _writeBio;
   268|             }
   269|         }
   270|         internal void MarkHandshakeCompleted()
   271|         {
   272|             _handshakeCompleted = true;
   273|         }
   274|         public static SafeSslHandle Create(SafeSslContextHandle context, bool isServer)
   275|         {
   276|             SafeBioHandle readBio = Interop.Crypto.CreateMemoryBio();
   277|             SafeBioHandle writeBio = Interop.Crypto.CreateMemoryBio();
   278|             SafeSslHandle handle = Interop.Ssl.SslCreate(context);
   279|             if (readBio.IsInvalid || writeBio.IsInvalid || handle.IsInvalid)
   280|             {
   281|                 readBio.Dispose();
   282|                 writeBio.Dispose();
   283|                 handle.Dispose(); // will make IsInvalid==true if it's not already
   284|                 return handle;
   285|             }
   286|             handle._isServer = isServer;
   287|             try
   288|             {
   289|                 readBio.TransferOwnershipToParent(handle);
   290|                 writeBio.TransferOwnershipToParent(handle);
   291|                 handle._readBio = readBio;
   292|                 handle._writeBio = writeBio;
   293|                 Interop.Ssl.SslSetBio(handle, readBio, writeBio);
   294|             }
   295|             catch (Exception exc)
   296|             {
   297|                 Debug.Fail("Unexpected exception while transferring SafeBioHandle ownership to SafeSslHandle", exc.ToString());
   298|                 throw;
   299|             }
   300|             if (isServer)
   301|             {
   302|                 Interop.Ssl.SslSetAcceptState(handle);
   303|             }
   304|             else
   305|             {
   306|                 Interop.Ssl.SslSetConnectState(handle);
   307|             }
   308|             return handle;
   309|         }
   310|         public override bool IsInvalid
   311|         {
   312|             get { return handle == IntPtr.Zero; }
   313|         }
   314|         protected override void Dispose(bool disposing)
   315|         {
   316|             if (disposing)
   317|             {
   318|                 _readBio?.Dispose();
   319|                 _writeBio?.Dispose();
   320|             }
   321|             if (AlpnHandle.IsAllocated)
   322|             {
   323|                 Interop.Ssl.SslSetData(handle, IntPtr.Zero);
   324|                 AlpnHandle.Free();
   325|             }
   326|             base.Dispose(disposing);
   327|         }
   328|         protected override bool ReleaseHandle()
   329|         {
   330|             if (_handshakeCompleted)
   331|             {
   332|                 Disconnect();
   333|             }
   334|             SslContextHandle?.DangerousRelease();
   335|             IntPtr h = handle;
   336|             SetHandle(IntPtr.Zero);
   337|             Interop.Ssl.SslDestroy(h); // will free the handles underlying _readBio and _writeBio
   338|             return true;
   339|         }
   340|         private void Disconnect()
   341|         {
   342|             Debug.Assert(!IsInvalid, "Expected a valid context in Disconnect");
   343|             int retVal = Interop.Ssl.SslShutdown(handle);
   344|             if (retVal == 0)
   345|             {
   346|                 retVal = Interop.Ssl.SslShutdown(handle);
   347|             }
   348|             if (retVal < 0)
   349|             {
   350|                 Interop.Crypto.ErrClearError();
   351|             }
   352|         }
   353|         public SafeSslHandle() : base(IntPtr.Zero, true)
   354|         {
   355|         }
   356|         internal SafeSslHandle(IntPtr validSslPointer, bool ownsHandle) : base(IntPtr.Zero, ownsHandle)
   357|         {
   358|             handle = validSslPointer;
   359|         }
   360|     }
   361| }


# ====================================================================
# FILE: src/libraries/Common/src/Interop/Windows/Kernel32/Interop.Threading.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-62 ---
     1| using Microsoft.Win32.SafeHandles;
     2| using System;
     3| using System.Runtime.InteropServices;
     4| internal static partial class Interop
     5| {
     6|     internal static partial class Kernel32
     7|     {
     8|         internal const int WAIT_FAILED = unchecked((int)0xFFFFFFFF);
     9|         [LibraryImport(Libraries.Kernel32)]
    10|         internal static partial uint WaitForMultipleObjectsEx(uint nCount, IntPtr lpHandles, BOOL bWaitAll, uint dwMilliseconds, BOOL bAlertable);
    11|         [LibraryImport(Libraries.Kernel32)]
    12|         internal static partial uint WaitForSingleObject(IntPtr hHandle, uint dwMilliseconds);
    13|         [LibraryImport(Libraries.Kernel32)]
    14|         internal static partial uint SignalObjectAndWait(IntPtr hObjectToSignal, IntPtr hObjectToWaitOn, uint dwMilliseconds, BOOL bAlertable);
    15|         [LibraryImport(Libraries.Kernel32)]
    16|         internal static partial void Sleep(uint milliseconds);
    17|         internal const uint CREATE_SUSPENDED = 0x00000004;
    18|         internal const uint STACK_SIZE_PARAM_IS_A_RESERVATION = 0x00010000;
    19|         [LibraryImport(Libraries.Kernel32)]
    20|         internal static unsafe partial SafeWaitHandle CreateThread(
    21|             IntPtr lpThreadAttributes,
    22|             IntPtr dwStackSize,
    23|             delegate* unmanaged<IntPtr, uint> lpStartAddress,
    24|             IntPtr lpParameter,
    25|             uint dwCreationFlags,
    26|             out uint lpThreadId);
    27|         [LibraryImport(Libraries.Kernel32)]
    28|         internal static partial uint ResumeThread(SafeWaitHandle hThread);
    29|         [LibraryImport(Libraries.Kernel32)]
    30|         internal static partial IntPtr GetCurrentThread();
    31|         internal const int DUPLICATE_SAME_ACCESS = 2;
    32|         [LibraryImport(Libraries.Kernel32, SetLastError = true)]
    33|         [return:MarshalAs(UnmanagedType.Bool)]
    34|         internal static partial bool DuplicateHandle(
    35|             IntPtr hSourceProcessHandle,
    36|             IntPtr hSourceHandle,
    37|             IntPtr hTargetProcessHandle,
    38|             out SafeWaitHandle lpTargetHandle,
    39|             uint dwDesiredAccess,
    40|             [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle,
    41|             uint dwOptions);
    42|         internal enum ThreadPriority : int
    43|         {
    44|             Idle = -15,
    45|             Lowest = -2,
    46|             BelowNormal = -1,
    47|             Normal = 0,
    48|             AboveNormal = 1,
    49|             Highest = 2,
    50|             TimeCritical = 15,
    51|             ErrorReturn = 0x7FFFFFFF
    52|         }
    53|         [LibraryImport(Libraries.Kernel32)]
    54|         internal static partial ThreadPriority GetThreadPriority(SafeWaitHandle hThread);
    55|         [LibraryImport(Libraries.Kernel32)]
    56|         [return:MarshalAs(UnmanagedType.Bool)]
    57|         internal static partial bool SetThreadPriority(SafeWaitHandle hThread, int nPriority);
    58|         [LibraryImport(Libraries.Kernel32, SetLastError = true)]
    59|         [return: MarshalAs(UnmanagedType.Bool)]
    60|         internal static partial bool GetThreadIOPendingFlag(nint hThread, out BOOL lpIOIsPending);
    61|     }
    62| }


# ====================================================================
# FILE: src/libraries/System.Console/src/System/TermInfo.DatabaseFactory.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-90 ---
     1| using System.Diagnostics.CodeAnalysis;
     2| using System.IO;
     3| using Microsoft.Win32.SafeHandles;
     4| namespace System;
     5| internal static partial class TermInfo
     6| {
     7|     internal sealed class DatabaseFactory
     8|     {
     9|         internal static readonly string[] s_terminfoLocations = {
    10|             "/etc/terminfo",
    11|             "/lib/terminfo",
    12|             "/usr/share/terminfo",
    13|             "/usr/share/misc/terminfo",
    14|             "/usr/local/share/terminfo"
    15|         };
    16|         internal static Database? ReadActiveDatabase()
    17|         {
    18|             string? term = Environment.GetEnvironmentVariable("TERM");
    19|             return !string.IsNullOrEmpty(term) ? ReadDatabase(term) : null;
    20|         }
    21|         internal static Database? ReadDatabase(string term)
    22|         {
    23|             Database? db;
    24|             string? terminfo = Environment.GetEnvironmentVariable("TERMINFO");
    25|             if (!string.IsNullOrWhiteSpace(terminfo) && (db = ReadDatabase(term, terminfo)) != null)
    26|             {
    27|                 return db;
    28|             }
    29|             string? home = PersistedFiles.GetHomeDirectory();
    30|             if (!string.IsNullOrWhiteSpace(home) && (db = ReadDatabase(term, home + "/.terminfo")) != null)
    31|             {
    32|                 return db;
    33|             }
    34|             foreach (string terminfoLocation in s_terminfoLocations)
    35|             {
    36|                 if ((db = ReadDatabase(term, terminfoLocation)) != null)
    37|                 {
    38|                     return db;
    39|                 }
    40|             }
    41|             return null;
    42|         }
    43|         private static bool TryOpen(string filePath, [NotNullWhen(true)] out SafeFileHandle? fd)
    44|         {
    45|             fd = Interop.Sys.Open(filePath, Interop.Sys.OpenFlags.O_RDONLY | Interop.Sys.OpenFlags.O_CLOEXEC, 0);
    46|             if (fd.IsInvalid)
    47|             {
    48|                 fd.Dispose();
    49|                 fd = null;
    50|                 return false;
    51|             }
    52|             return true;
    53|         }
    54|         internal static Database? ReadDatabase(string? term, string? directoryPath)
    55|         {
    56|             if (string.IsNullOrEmpty(term) || string.IsNullOrEmpty(directoryPath))
    57|             {
    58|                 return null;
    59|             }
    60|             Span<char> stackBuffer = stackalloc char[256];
    61|             SafeFileHandle? fd;
    62|             if (!TryOpen(string.Create(null, stackBuffer, $"{directoryPath}/{term[0]}/{term}"), out fd) &&       // /directory/termFirstLetter/term      (Linux)
    63|                 !TryOpen(string.Create(null, stackBuffer, $"{directoryPath}/{(int)term[0]:X}/{term}"), out fd))  // /directory/termFirstLetterAsHex/term (Mac)
    64|             {
    65|                 return null;
    66|             }
    67|             using (fd)
    68|             {
    69|                 long termInfoLength = RandomAccess.GetLength(fd);
    70|                 const int HeaderLength = 12;
    71|                 if (termInfoLength <= HeaderLength)
    72|                 {
    73|                     throw new InvalidOperationException(SR.IO_TermInfoInvalid);
    74|                 }
    75|                 byte[] data = new byte[(int)termInfoLength];
    76|                 long fileOffset = 0;
    77|                 do
    78|                 {
    79|                     int bytesRead = RandomAccess.Read(fd, new Span<byte>(data, (int)fileOffset, (int)(termInfoLength - fileOffset)), fileOffset);
    80|                     if (bytesRead == 0)
    81|                     {
    82|                         throw new InvalidOperationException(SR.IO_TermInfoInvalid);
    83|                     }
    84|                     fileOffset += bytesRead;
    85|                 } while (fileOffset < termInfoLength);
    86|                 return new Database(term, data);
    87|             }
    88|         }
    89|     }
    90| }


# ====================================================================
# FILE: src/libraries/System.Console/src/System/TerminalFormatStrings.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-203 ---
     1| using System.Collections.Generic;
     2| using System.Diagnostics;
     3| namespace System;
     4| internal sealed class TerminalFormatStrings
     5| {
     6|     public readonly string? Foreground;
     7|     public readonly string? Background;
     8|     public readonly string? Reset;
     9|     public readonly int MaxColors;
    10|     public readonly int Columns;
    11|     public readonly int Lines;
    12|     public readonly string? CursorVisible;
    13|     public readonly string? CursorInvisible;
    14|     public readonly string? Title;
    15|     public readonly string? Bell;
    16|     public readonly string? Clear;
    17|     public readonly string? CursorAddress;
    18|     public readonly string? CursorLeft;
    19|     public readonly string? ClrEol;
    20|     public const string CursorPositionReport = "\x1B[6n";
    21|     public readonly Dictionary<ReadOnlyMemory<char>, ConsoleKeyInfo> KeyFormatToConsoleKey =
    22|         new Dictionary<ReadOnlyMemory<char>, ConsoleKeyInfo>(new ReadOnlyMemoryContentComparer());
    23|     public readonly int MaxKeyFormatLength;
    24|     public readonly int MinKeyFormatLength;
    25|     public readonly string? KeypadXmit;
    26|     public readonly bool IsRxvtTerm;
    27|     public TerminalFormatStrings(TermInfo.Database? db)
    28|     {
    29|         if (db == null)
    30|             return;
    31|         KeypadXmit = db.GetString(TermInfo.WellKnownStrings.KeypadXmit);
    32|         Foreground = db.GetString(TermInfo.WellKnownStrings.SetAnsiForeground);
    33|         Background = db.GetString(TermInfo.WellKnownStrings.SetAnsiBackground);
    34|         Reset = db.GetString(TermInfo.WellKnownStrings.OrigPairs) ?? db.GetString(TermInfo.WellKnownStrings.OrigColors);
    35|         Bell = db.GetString(TermInfo.WellKnownStrings.Bell);
    36|         Clear = db.GetString(TermInfo.WellKnownStrings.Clear);
    37|         Columns = db.GetNumber(TermInfo.WellKnownNumbers.Columns);
    38|         Lines = db.GetNumber(TermInfo.WellKnownNumbers.Lines);
    39|         CursorVisible = db.GetString(TermInfo.WellKnownStrings.CursorVisible);
    40|         CursorInvisible = db.GetString(TermInfo.WellKnownStrings.CursorInvisible);
    41|         CursorAddress = db.GetString(TermInfo.WellKnownStrings.CursorAddress);
    42|         CursorLeft = db.GetString(TermInfo.WellKnownStrings.CursorLeft);
    43|         ClrEol = db.GetString(TermInfo.WellKnownStrings.ClrEol);
    44|         IsRxvtTerm = !string.IsNullOrEmpty(db.Term) && db.Term.Contains("rxvt", StringComparison.OrdinalIgnoreCase);
    45|         Title = GetTitle(db);
    46|         Debug.WriteLineIf(db.GetString(TermInfo.WellKnownStrings.CursorPositionReport) != CursorPositionReport,
    47|             "Getting the cursor position will only work if the terminal supports the CPR sequence," +
    48|             "but the terminfo database does not contain an entry for it.");
    49|         int maxColors = db.GetNumber(TermInfo.WellKnownNumbers.MaxColors);
    50|         MaxColors = // normalize to either the full range of all ANSI colors, just the dark ones, or none
    51|             maxColors >= 16 ? 16 :
    52|             maxColors >= 8 ? 8 :
    53|             0;
    54|         AddKey(db, TermInfo.WellKnownStrings.KeyF1, ConsoleKey.F1);
    55|         AddKey(db, TermInfo.WellKnownStrings.KeyF2, ConsoleKey.F2);
    56|         AddKey(db, TermInfo.WellKnownStrings.KeyF3, ConsoleKey.F3);
    57|         AddKey(db, TermInfo.WellKnownStrings.KeyF4, ConsoleKey.F4);
    58|         AddKey(db, TermInfo.WellKnownStrings.KeyF5, ConsoleKey.F5);
    59|         AddKey(db, TermInfo.WellKnownStrings.KeyF6, ConsoleKey.F6);
    60|         AddKey(db, TermInfo.WellKnownStrings.KeyF7, ConsoleKey.F7);
    61|         AddKey(db, TermInfo.WellKnownStrings.KeyF8, ConsoleKey.F8);
    62|         AddKey(db, TermInfo.WellKnownStrings.KeyF9, ConsoleKey.F9);
    63|         AddKey(db, TermInfo.WellKnownStrings.KeyF10, ConsoleKey.F10);
    64|         AddKey(db, TermInfo.WellKnownStrings.KeyF11, ConsoleKey.F11);
    65|         AddKey(db, TermInfo.WellKnownStrings.KeyF12, ConsoleKey.F12);
    66|         AddKey(db, TermInfo.WellKnownStrings.KeyF13, ConsoleKey.F13);
    67|         AddKey(db, TermInfo.WellKnownStrings.KeyF14, ConsoleKey.F14);
    68|         AddKey(db, TermInfo.WellKnownStrings.KeyF15, ConsoleKey.F15);
    69|         AddKey(db, TermInfo.WellKnownStrings.KeyF16, ConsoleKey.F16);
    70|         AddKey(db, TermInfo.WellKnownStrings.KeyF17, ConsoleKey.F17);
    71|         AddKey(db, TermInfo.WellKnownStrings.KeyF18, ConsoleKey.F18);
    72|         AddKey(db, TermInfo.WellKnownStrings.KeyF19, ConsoleKey.F19);
    73|         AddKey(db, TermInfo.WellKnownStrings.KeyF20, ConsoleKey.F20);
    74|         AddKey(db, TermInfo.WellKnownStrings.KeyF21, ConsoleKey.F21);
    75|         AddKey(db, TermInfo.WellKnownStrings.KeyF22, ConsoleKey.F22);
    76|         AddKey(db, TermInfo.WellKnownStrings.KeyF23, ConsoleKey.F23);
    77|         AddKey(db, TermInfo.WellKnownStrings.KeyF24, ConsoleKey.F24);
    78|         AddKey(db, TermInfo.WellKnownStrings.KeyBackspace, ConsoleKey.Backspace);
    79|         AddKey(db, TermInfo.WellKnownStrings.KeyBackTab, ConsoleKey.Tab, shift: true, alt: false, control: false);
    80|         AddKey(db, TermInfo.WellKnownStrings.KeyBegin, ConsoleKey.Home);
    81|         AddKey(db, TermInfo.WellKnownStrings.KeyClear, ConsoleKey.Clear);
    82|         AddKey(db, TermInfo.WellKnownStrings.KeyDelete, ConsoleKey.Delete);
    83|         AddKey(db, TermInfo.WellKnownStrings.KeyDown, ConsoleKey.DownArrow);
    84|         AddKey(db, TermInfo.WellKnownStrings.KeyEnd, ConsoleKey.End);
    85|         AddKey(db, TermInfo.WellKnownStrings.KeyEnter, ConsoleKey.Enter);
    86|         AddKey(db, TermInfo.WellKnownStrings.KeyHelp, ConsoleKey.Help);
    87|         AddKey(db, TermInfo.WellKnownStrings.KeyHome, ConsoleKey.Home);
    88|         AddKey(db, TermInfo.WellKnownStrings.KeyInsert, ConsoleKey.Insert);
    89|         AddKey(db, TermInfo.WellKnownStrings.KeyLeft, ConsoleKey.LeftArrow);
    90|         AddKey(db, TermInfo.WellKnownStrings.KeyPageDown, ConsoleKey.PageDown);
    91|         AddKey(db, TermInfo.WellKnownStrings.KeyPageUp, ConsoleKey.PageUp);
    92|         AddKey(db, TermInfo.WellKnownStrings.KeyPrint, ConsoleKey.Print);
    93|         AddKey(db, TermInfo.WellKnownStrings.KeyRight, ConsoleKey.RightArrow);
    94|         AddKey(db, TermInfo.WellKnownStrings.KeyScrollForward, ConsoleKey.PageDown, shift: true, alt: false, control: false);
    95|         AddKey(db, TermInfo.WellKnownStrings.KeyScrollReverse, ConsoleKey.PageUp, shift: true, alt: false, control: false);
    96|         AddKey(db, TermInfo.WellKnownStrings.KeySBegin, ConsoleKey.Home, shift: true, alt: false, control: false);
    97|         AddKey(db, TermInfo.WellKnownStrings.KeySDelete, ConsoleKey.Delete, shift: true, alt: false, control: false);
    98|         AddKey(db, TermInfo.WellKnownStrings.KeySHome, ConsoleKey.Home, shift: true, alt: false, control: false);
    99|         AddKey(db, TermInfo.WellKnownStrings.KeySelect, ConsoleKey.Select);
   100|         AddKey(db, TermInfo.WellKnownStrings.KeySLeft, ConsoleKey.LeftArrow, shift: true, alt: false, control: false);
   101|         AddKey(db, TermInfo.WellKnownStrings.KeySPrint, ConsoleKey.Print, shift: true, alt: false, control: false);
   102|         AddKey(db, TermInfo.WellKnownStrings.KeySRight, ConsoleKey.RightArrow, shift: true, alt: false, control: false);
   103|         AddKey(db, TermInfo.WellKnownStrings.KeyUp, ConsoleKey.UpArrow);
   104|         AddPrefixKey(db, "kLFT", ConsoleKey.LeftArrow);
   105|         AddPrefixKey(db, "kRIT", ConsoleKey.RightArrow);
   106|         AddPrefixKey(db, "kUP", ConsoleKey.UpArrow);
   107|         AddPrefixKey(db, "kDN", ConsoleKey.DownArrow);
   108|         AddPrefixKey(db, "kDC", ConsoleKey.Delete);
   109|         AddPrefixKey(db, "kEND", ConsoleKey.End);
   110|         AddPrefixKey(db, "kHOM", ConsoleKey.Home);
   111|         AddPrefixKey(db, "kNXT", ConsoleKey.PageDown);
   112|         AddPrefixKey(db, "kPRV", ConsoleKey.PageUp);
   113|         if (KeyFormatToConsoleKey.Count > 0)
   114|         {
   115|             MaxKeyFormatLength = int.MinValue;
   116|             MinKeyFormatLength = int.MaxValue;
   117|             foreach (KeyValuePair<ReadOnlyMemory<char>, ConsoleKeyInfo> entry in KeyFormatToConsoleKey)
   118|             {
   119|                 if (entry.Key.Length > MaxKeyFormatLength)
   120|                 {
   121|                     MaxKeyFormatLength = entry.Key.Length;
   122|                 }
   123|                 if (entry.Key.Length < MinKeyFormatLength)
   124|                 {
   125|                     MinKeyFormatLength = entry.Key.Length;
   126|                 }
   127|             }
   128|         }
   129|     }
   130|     private static string GetTitle(TermInfo.Database db)
   131|     {
   132|         string? tsl = db.GetString(TermInfo.WellKnownStrings.ToStatusLine);
   133|         string? fsl = db.GetString(TermInfo.WellKnownStrings.FromStatusLine);
   134|         if (tsl != null && fsl != null)
   135|         {
   136|             return tsl + "%p1%s" + fsl;
   137|         }
   138|         string term = db.Term;
   139|         if (term == null)
   140|         {
   141|             return string.Empty;
   142|         }
   143|         if (term.StartsWith("xterm", StringComparison.Ordinal)) // normalize all xterms to enable easier matching
   144|         {
   145|             term = "xterm";
   146|         }
   147|         else if (term.StartsWith("screen", StringComparison.Ordinal)) // normalize all tmux configs
   148|         {
   149|             term = "screen";
   150|         }
   151|         switch (term)
   152|         {
   153|             case "aixterm":
   154|             case "dtterm":
   155|             case "linux":
   156|             case "rxvt":
   157|             case "xterm":
   158|                 return "\x1B]0;%p1%s\x07";
   159|             case "cygwin":
   160|                 return "\x1B];%p1%s\x07";
   161|             case "konsole":
   162|                 return "\x1B]30;%p1%s\x07";
   163|             case "screen":
   164|                 return "\x1Bk%p1%s\x1B\\";
   165|             default:
   166|                 return string.Empty;
   167|         }
   168|     }
   169|     private void AddKey(TermInfo.Database db, TermInfo.WellKnownStrings keyId, ConsoleKey key)
   170|     {
   171|         AddKey(db, keyId, key, shift: false, alt: false, control: false);
   172|     }
   173|     private void AddKey(TermInfo.Database db, TermInfo.WellKnownStrings keyId, ConsoleKey key, bool shift, bool alt, bool control)
   174|     {
   175|         ReadOnlyMemory<char> keyFormat = db.GetString(keyId).AsMemory();
   176|         if (!keyFormat.IsEmpty)
   177|             KeyFormatToConsoleKey[keyFormat] = new ConsoleKeyInfo(key == ConsoleKey.Enter ? '\r' : '\0', key, shift, alt, control);
   178|     }
   179|     private void AddPrefixKey(TermInfo.Database db, string extendedNamePrefix, ConsoleKey key)
   180|     {
   181|         if (db.HasExtendedStrings) // avoid string concatenation in case when there are no Extended Strings (typical scenario)
   182|         {
   183|             AddKey(db, extendedNamePrefix + "3", key, shift: false, alt: true,  control: false);
   184|             AddKey(db, extendedNamePrefix + "4", key, shift: true,  alt: true,  control: false);
   185|             AddKey(db, extendedNamePrefix + "5", key, shift: false, alt: false, control: true);
   186|             AddKey(db, extendedNamePrefix + "6", key, shift: true,  alt: false, control: true);
   187|             AddKey(db, extendedNamePrefix + "7", key, shift: false, alt: false, control: true);
   188|         }
   189|     }
   190|     private void AddKey(TermInfo.Database db, string extendedName, ConsoleKey key, bool shift, bool alt, bool control)
   191|     {
   192|         ReadOnlyMemory<char> keyFormat = db.GetExtendedString(extendedName).AsMemory();
   193|         if (!keyFormat.IsEmpty)
   194|             KeyFormatToConsoleKey[keyFormat] = new ConsoleKeyInfo('\0', key, shift, alt, control);
   195|     }
   196|     private sealed class ReadOnlyMemoryContentComparer : IEqualityComparer<ReadOnlyMemory<char>>
   197|     {
   198|         public bool Equals(ReadOnlyMemory<char> x, ReadOnlyMemory<char> y) =>
   199|             x.Span.SequenceEqual(y.Span);
   200|         public int GetHashCode(ReadOnlyMemory<char> obj) =>
   201|             string.GetHashCode(obj.Span);
   202|     }
   203| }


# ====================================================================
# FILE: src/libraries/System.Drawing.Common/src/System.Drawing.Common.Forwards.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-11 ---
     1| // Licensed to the .NET Foundation under one or more agreements.
     2| [assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Drawing.Color))]
     3| [assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Drawing.ColorTranslator))]
     4| [assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Drawing.KnownColor))]
     5| [assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Drawing.Point))]
     6| [assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Drawing.PointF))]
     7| [assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Drawing.Rectangle))]
     8| [assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Drawing.RectangleF))]
     9| [assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Drawing.Size))]
    10| [assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Drawing.SizeF))]
    11| [assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Drawing.SystemColors))]


# ====================================================================
# FILE: src/libraries/System.Formats.Tar/src/System/Formats/Tar/TarHeader.Read.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-526 ---
     1| using System.Buffers;
     2| using System.Collections.Generic;
     3| using System.Diagnostics;
     4| using System.Diagnostics.CodeAnalysis;
     5| using System.IO;
     6| using System.Text;
     7| using System.Threading;
     8| using System.Threading.Tasks;
     9| namespace System.Formats.Tar
    10| {
    11|     internal sealed partial class TarHeader
    12|     {
    13|         private const string UstarPrefixFormat = "{0}/{1}"; // "prefix/name"
    14|         internal static TarHeader? TryGetNextHeader(Stream archiveStream, bool copyData, TarEntryFormat initialFormat, bool processDataBlock)
    15|         {
    16|             Span<byte> buffer = stackalloc byte[TarHelpers.RecordSize];
    17|             archiveStream.ReadExactly(buffer);
    18|             TarHeader? header = TryReadAttributes(initialFormat, buffer);
    19|             if (header != null && processDataBlock)
    20|             {
    21|                 header.ProcessDataBlock(archiveStream, copyData);
    22|             }
    23|             return header;
    24|         }
    25|         internal static async ValueTask<TarHeader?> TryGetNextHeaderAsync(Stream archiveStream, bool copyData, TarEntryFormat initialFormat, bool processDataBlock, CancellationToken cancellationToken)
    26|         {
    27|             cancellationToken.ThrowIfCancellationRequested();
    28|             byte[] rented = ArrayPool<byte>.Shared.Rent(minimumLength: TarHelpers.RecordSize);
    29|             Memory<byte> buffer = rented.AsMemory(0, TarHelpers.RecordSize); // minimumLength means the array could've been larger
    30|             await archiveStream.ReadExactlyAsync(buffer, cancellationToken).ConfigureAwait(false);
    31|             TarHeader? header = TryReadAttributes(initialFormat, buffer.Span);
    32|             if (header != null && processDataBlock)
    33|             {
    34|                 await header.ProcessDataBlockAsync(archiveStream, copyData, cancellationToken).ConfigureAwait(false);
    35|             }
    36|             ArrayPool<byte>.Shared.Return(rented);
    37|             return header;
    38|         }
    39|         private static TarHeader? TryReadAttributes(TarEntryFormat initialFormat, Span<byte> buffer)
    40|         {
    41|             TarHeader? header = TryReadCommonAttributes(buffer, initialFormat);
    42|             if (header != null)
    43|             {
    44|                 header.ReadMagicAttribute(buffer);
    45|                 if (header._format != TarEntryFormat.V7)
    46|                 {
    47|                     header.ReadVersionAttribute(buffer);
    48|                     header.ReadPosixAndGnuSharedAttributes(buffer);
    49|                     Debug.Assert(header._format is TarEntryFormat.Ustar or TarEntryFormat.Pax or TarEntryFormat.Gnu);
    50|                     if (header._format == TarEntryFormat.Ustar)
    51|                     {
    52|                         header.ReadUstarAttributes(buffer);
    53|                     }
    54|                     else if (header._format == TarEntryFormat.Gnu)
    55|                     {
    56|                         header.ReadGnuAttributes(buffer);
    57|                     }
    58|                 }
    59|             }
    60|             return header;
    61|         }
    62|         internal void ReplaceNormalAttributesWithExtended(Dictionary<string, string>? dictionaryFromExtendedAttributesHeader)
    63|         {
    64|             if (dictionaryFromExtendedAttributesHeader == null || dictionaryFromExtendedAttributesHeader.Count == 0)
    65|             {
    66|                 return;
    67|             }
    68|             InitializeExtendedAttributesWithExisting(dictionaryFromExtendedAttributesHeader);
    69|             if (ExtendedAttributes.TryGetValue(PaxEaName, out string? paxEaName))
    70|             {
    71|                 _name = paxEaName;
    72|             }
    73|             if (ExtendedAttributes.TryGetValue(PaxEaLinkName, out string? paxEaLinkName))
    74|             {
    75|                 _linkName = paxEaLinkName;
    76|             }
    77|             if (TarHelpers.TryGetDateTimeOffsetFromTimestampString(ExtendedAttributes, PaxEaMTime, out DateTimeOffset mTime))
    78|             {
    79|                 _mTime = mTime;
    80|             }
    81|             if (TarHelpers.TryGetStringAsBaseTenInteger(ExtendedAttributes, PaxEaMode, out int mode))
    82|             {
    83|                 _mode = mode;
    84|             }
    85|             if (TarHelpers.TryGetStringAsBaseTenLong(ExtendedAttributes, PaxEaSize, out long size))
    86|             {
    87|                 _size = size;
    88|             }
    89|             if (TarHelpers.TryGetStringAsBaseTenInteger(ExtendedAttributes, PaxEaUid, out int uid))
    90|             {
    91|                 _uid = uid;
    92|             }
    93|             if (TarHelpers.TryGetStringAsBaseTenInteger(ExtendedAttributes, PaxEaGid, out int gid))
    94|             {
    95|                 _gid = gid;
    96|             }
    97|             if (ExtendedAttributes.TryGetValue(PaxEaUName, out string? paxEaUName))
    98|             {
    99|                 _uName = paxEaUName;
   100|             }
   101|             if (ExtendedAttributes.TryGetValue(PaxEaGName, out string? paxEaGName))
   102|             {
   103|                 _gName = paxEaGName;
   104|             }
   105|             if (TarHelpers.TryGetStringAsBaseTenInteger(ExtendedAttributes, PaxEaDevMajor, out int devMajor))
   106|             {
   107|                 _devMajor = devMajor;
   108|             }
   109|             if (TarHelpers.TryGetStringAsBaseTenInteger(ExtendedAttributes, PaxEaDevMinor, out int devMinor))
   110|             {
   111|                 _devMinor = devMinor;
   112|             }
   113|         }
   114|         internal void ProcessDataBlock(Stream archiveStream, bool copyData)
   115|         {
   116|             bool skipBlockAlignmentPadding = true;
   117|             switch (_typeFlag)
   118|             {
   119|                 case TarEntryType.ExtendedAttributes or TarEntryType.GlobalExtendedAttributes:
   120|                     ReadExtendedAttributesBlock(archiveStream);
   121|                     break;
   122|                 case TarEntryType.LongLink or TarEntryType.LongPath:
   123|                     ReadGnuLongPathDataBlock(archiveStream);
   124|                     break;
   125|                 case TarEntryType.BlockDevice:
   126|                 case TarEntryType.CharacterDevice:
   127|                 case TarEntryType.Directory:
   128|                 case TarEntryType.Fifo:
   129|                 case TarEntryType.HardLink:
   130|                 case TarEntryType.SymbolicLink:
   131|                     if (_size > 0)
   132|                     {
   133|                         throw new InvalidDataException(string.Format(SR.TarSizeFieldTooLargeForEntryType, _typeFlag));
   134|                     }
   135|                     break;
   136|                 case TarEntryType.RegularFile:
   137|                 case TarEntryType.V7RegularFile: // Treated as regular file
   138|                 case TarEntryType.ContiguousFile: // Treated as regular file
   139|                 case TarEntryType.DirectoryList: // Contains the list of filesystem entries in the data section
   140|                 case TarEntryType.MultiVolume: // Contains portion of a file
   141|                 case TarEntryType.RenamedOrSymlinked: // Might contain data
   142|                 case TarEntryType.SparseFile: // Contains portion of a file
   143|                 case TarEntryType.TapeVolume: // Might contain data
   144|                 default: // Unrecognized entry types could potentially have a data section
   145|                     _dataStream = GetDataStream(archiveStream, copyData);
   146|                     if (_dataStream is SeekableSubReadStream)
   147|                     {
   148|                         TarHelpers.AdvanceStream(archiveStream, _size);
   149|                     }
   150|                     else if (_dataStream is SubReadStream)
   151|                     {
   152|                         skipBlockAlignmentPadding = false;
   153|                     }
   154|                     break;
   155|             }
   156|             if (skipBlockAlignmentPadding)
   157|             {
   158|                 if (_size > 0)
   159|                 {
   160|                     TarHelpers.SkipBlockAlignmentPadding(archiveStream, _size);
   161|                 }
   162|                 if (archiveStream.CanSeek)
   163|                 {
   164|                     _endOfHeaderAndDataAndBlockAlignment = archiveStream.Position;
   165|                 }
   166|             }
   167|         }
   168|         private async Task ProcessDataBlockAsync(Stream archiveStream, bool copyData, CancellationToken cancellationToken)
   169|         {
   170|             bool skipBlockAlignmentPadding = true;
   171|             switch (_typeFlag)
   172|             {
   173|                 case TarEntryType.ExtendedAttributes or TarEntryType.GlobalExtendedAttributes:
   174|                     await ReadExtendedAttributesBlockAsync(archiveStream, cancellationToken).ConfigureAwait(false);
   175|                     break;
   176|                 case TarEntryType.LongLink or TarEntryType.LongPath:
   177|                     await ReadGnuLongPathDataBlockAsync(archiveStream, cancellationToken).ConfigureAwait(false);
   178|                     break;
   179|                 case TarEntryType.BlockDevice:
   180|                 case TarEntryType.CharacterDevice:
   181|                 case TarEntryType.Directory:
   182|                 case TarEntryType.Fifo:
   183|                 case TarEntryType.HardLink:
   184|                 case TarEntryType.SymbolicLink:
   185|                     if (_size > 0)
   186|                     {
   187|                         throw new InvalidDataException(string.Format(SR.TarSizeFieldTooLargeForEntryType, _typeFlag));
   188|                     }
   189|                     break;
   190|                 case TarEntryType.RegularFile:
   191|                 case TarEntryType.V7RegularFile: // Treated as regular file
   192|                 case TarEntryType.ContiguousFile: // Treated as regular file
   193|                 case TarEntryType.DirectoryList: // Contains the list of filesystem entries in the data section
   194|                 case TarEntryType.MultiVolume: // Contains portion of a file
   195|                 case TarEntryType.RenamedOrSymlinked: // Might contain data
   196|                 case TarEntryType.SparseFile: // Contains portion of a file
   197|                 case TarEntryType.TapeVolume: // Might contain data
   198|                 default: // Unrecognized entry types could potentially have a data section
   199|                     _dataStream = await GetDataStreamAsync(archiveStream, copyData, _size, cancellationToken).ConfigureAwait(false);
   200|                     if (_dataStream is SeekableSubReadStream)
   201|                     {
   202|                         await TarHelpers.AdvanceStreamAsync(archiveStream, _size, cancellationToken).ConfigureAwait(false);
   203|                     }
   204|                     else if (_dataStream is SubReadStream)
   205|                     {
   206|                         skipBlockAlignmentPadding = false;
   207|                     }
   208|                     break;
   209|             }
   210|             if (skipBlockAlignmentPadding)
   211|             {
   212|                 if (_size > 0)
   213|                 {
   214|                     await TarHelpers.SkipBlockAlignmentPaddingAsync(archiveStream, _size, cancellationToken).ConfigureAwait(false);
   215|                 }
   216|                 if (archiveStream.CanSeek)
   217|                 {
   218|                     _endOfHeaderAndDataAndBlockAlignment = archiveStream.Position;
   219|                 }
   220|             }
   221|         }
   222|         private Stream? GetDataStream(Stream archiveStream, bool copyData)
   223|         {
   224|             if (_size == 0)
   225|             {
   226|                 return null;
   227|             }
   228|             if (copyData)
   229|             {
   230|                 MemoryStream copiedData = new MemoryStream();
   231|                 TarHelpers.CopyBytes(archiveStream, copiedData, _size);
   232|                 copiedData.Position = 0;
   233|                 return copiedData;
   234|             }
   235|             return archiveStream.CanSeek
   236|                 ? new SeekableSubReadStream(archiveStream, archiveStream.Position, _size)
   237|                 : new SubReadStream(archiveStream, 0, _size);
   238|         }
   239|         private static async ValueTask<Stream?> GetDataStreamAsync(Stream archiveStream, bool copyData, long size, CancellationToken cancellationToken)
   240|         {
   241|             cancellationToken.ThrowIfCancellationRequested();
   242|             if (size == 0)
   243|             {
   244|                 return null;
   245|             }
   246|             if (copyData)
   247|             {
   248|                 MemoryStream copiedData = new MemoryStream();
   249|                 await TarHelpers.CopyBytesAsync(archiveStream, copiedData, size, cancellationToken).ConfigureAwait(false);
   250|                 copiedData.Position = 0;
   251|                 return copiedData;
   252|             }
   253|             return archiveStream.CanSeek
   254|                 ? new SeekableSubReadStream(archiveStream, archiveStream.Position, size)
   255|                 : new SubReadStream(archiveStream, 0, size);
   256|         }
   257|         private static TarHeader? TryReadCommonAttributes(Span<byte> buffer, TarEntryFormat initialFormat)
   258|         {
   259|             Span<byte> spanChecksum = buffer.Slice(FieldLocations.Checksum, FieldLengths.Checksum);
   260|             if (TarHelpers.IsAllNullBytes(spanChecksum))
   261|             {
   262|                 return null;
   263|             }
   264|             int checksum = (int)TarHelpers.ParseOctal<uint>(spanChecksum);
   265|             if (checksum == 0)
   266|             {
   267|                 return null;
   268|             }
   269|             long size = (long)TarHelpers.ParseOctal<ulong>(buffer.Slice(FieldLocations.Size, FieldLengths.Size));
   270|             Debug.Assert(size <= TarHelpers.MaxSizeLength, "size exceeded the max value possible with 11 octal digits. Actual size " + size);
   271|             if (size < 0)
   272|             {
   273|                 throw new InvalidDataException(string.Format(SR.TarSizeFieldNegative));
   274|             }
   275|             TarHeader header = new(initialFormat,
   276|                 name: TarHelpers.GetTrimmedUtf8String(buffer.Slice(FieldLocations.Name, FieldLengths.Name)),
   277|                 mode: (int)TarHelpers.ParseOctal<uint>(buffer.Slice(FieldLocations.Mode, FieldLengths.Mode)),
   278|                 mTime: TarHelpers.GetDateTimeOffsetFromSecondsSinceEpoch((long)TarHelpers.ParseOctal<ulong>(buffer.Slice(FieldLocations.MTime, FieldLengths.MTime))),
   279|                 typeFlag: (TarEntryType)buffer[FieldLocations.TypeFlag])
   280|             {
   281|                 _checksum = checksum,
   282|                 _size = size,
   283|                 _uid = (int)TarHelpers.ParseOctal<uint>(buffer.Slice(FieldLocations.Uid, FieldLengths.Uid)),
   284|                 _gid = (int)TarHelpers.ParseOctal<uint>(buffer.Slice(FieldLocations.Gid, FieldLengths.Gid)),
   285|                 _linkName = TarHelpers.GetTrimmedUtf8String(buffer.Slice(FieldLocations.LinkName, FieldLengths.LinkName))
   286|             };
   287|             if (header._format == TarEntryFormat.Unknown)
   288|             {
   289|                 header._format = header._typeFlag switch
   290|                 {
   291|                     TarEntryType.ExtendedAttributes or
   292|                     TarEntryType.GlobalExtendedAttributes => TarEntryFormat.Pax,
   293|                     TarEntryType.DirectoryList or
   294|                     TarEntryType.LongLink or
   295|                     TarEntryType.LongPath or
   296|                     TarEntryType.MultiVolume or
   297|                     TarEntryType.RenamedOrSymlinked or
   298|                     TarEntryType.TapeVolume => TarEntryFormat.Gnu,
   299|                     TarEntryType.V7RegularFile => TarEntryFormat.V7,
   300|                     TarEntryType.SparseFile => throw new NotSupportedException(string.Format(SR.TarEntryTypeNotSupported, header._typeFlag)),
   301|                     _ => (header._typeFlag == TarEntryType.RegularFile) ? TarEntryFormat.Ustar : TarEntryFormat.V7
   302|                 };
   303|             }
   304|             return header;
   305|         }
   306|         private void ReadMagicAttribute(Span<byte> buffer)
   307|         {
   308|             Span<byte> magic = buffer.Slice(FieldLocations.Magic, FieldLengths.Magic);
   309|             if (TarHelpers.IsAllNullBytes(magic))
   310|             {
   311|                 _format = TarEntryFormat.V7;
   312|                 return;
   313|             }
   314|             if (magic.SequenceEqual(GnuMagicBytes))
   315|             {
   316|                 _magic = GnuMagic;
   317|                 _format = TarEntryFormat.Gnu;
   318|             }
   319|             else if (magic.SequenceEqual(UstarMagicBytes))
   320|             {
   321|                 _magic = UstarMagic;
   322|                 if (_format == TarEntryFormat.V7)
   323|                 {
   324|                     _format = TarEntryFormat.Ustar;
   325|                 }
   326|             }
   327|             else
   328|             {
   329|                 _magic = Encoding.ASCII.GetString(magic);
   330|             }
   331|         }
   332|         private void ReadVersionAttribute(Span<byte> buffer)
   333|         {
   334|             if (_format == TarEntryFormat.V7)
   335|             {
   336|                 return;
   337|             }
   338|             Span<byte> version = buffer.Slice(FieldLocations.Version, FieldLengths.Version);
   339|             switch (_format)
   340|             {
   341|                 case TarEntryFormat.Ustar or TarEntryFormat.Pax:
   342|                     if (!version.SequenceEqual(UstarVersionBytes))
   343|                     {
   344|                         if (!version.SequenceEqual(GnuVersionBytes))
   345|                         {
   346|                             throw new InvalidDataException(string.Format(SR.TarPosixFormatExpected, _name));
   347|                         }
   348|                         _version = GnuVersion;
   349|                     }
   350|                     else
   351|                     {
   352|                         _version = UstarVersion;
   353|                     }
   354|                     break;
   355|                 case TarEntryFormat.Gnu:
   356|                     if (!version.SequenceEqual(GnuVersionBytes))
   357|                     {
   358|                         if (!version.SequenceEqual(UstarVersionBytes))
   359|                         {
   360|                             throw new InvalidDataException(string.Format(SR.TarGnuFormatExpected, _name));
   361|                         }
   362|                         _version = UstarVersion;
   363|                     }
   364|                     else
   365|                     {
   366|                         _version = GnuVersion;
   367|                     }
   368|                     break;
   369|                 default:
   370|                     _version = Encoding.ASCII.GetString(version);
   371|                     break;
   372|             }
   373|         }
   374|         private void ReadPosixAndGnuSharedAttributes(Span<byte> buffer)
   375|         {
   376|             _uName = TarHelpers.GetTrimmedUtf8String(buffer.Slice(FieldLocations.UName, FieldLengths.UName));
   377|             _gName = TarHelpers.GetTrimmedUtf8String(buffer.Slice(FieldLocations.GName, FieldLengths.GName));
   378|             if (_typeFlag is TarEntryType.CharacterDevice or TarEntryType.BlockDevice)
   379|             {
   380|                 _devMajor = (int)TarHelpers.ParseOctal<uint>(buffer.Slice(FieldLocations.DevMajor, FieldLengths.DevMajor));
   381|                 _devMinor = (int)TarHelpers.ParseOctal<uint>(buffer.Slice(FieldLocations.DevMinor, FieldLengths.DevMinor));
   382|             }
   383|         }
   384|         private void ReadGnuAttributes(Span<byte> buffer)
   385|         {
   386|             long aTime = (long)TarHelpers.ParseOctal<ulong>(buffer.Slice(FieldLocations.ATime, FieldLengths.ATime));
   387|             _aTime = TarHelpers.GetDateTimeOffsetFromSecondsSinceEpoch(aTime);
   388|             long cTime = (long)TarHelpers.ParseOctal<ulong>(buffer.Slice(FieldLocations.CTime, FieldLengths.CTime));
   389|             _cTime = TarHelpers.GetDateTimeOffsetFromSecondsSinceEpoch(cTime);
   390|         }
   391|         private void ReadUstarAttributes(Span<byte> buffer)
   392|         {
   393|             _prefix = TarHelpers.GetTrimmedUtf8String(buffer.Slice(FieldLocations.Prefix, FieldLengths.Prefix));
   394|             if (!string.IsNullOrEmpty(_prefix))
   395|             {
   396|                 _name = string.Format(UstarPrefixFormat, _prefix, _name);
   397|             }
   398|         }
   399|         private void ReadExtendedAttributesBlock(Stream archiveStream)
   400|         {
   401|             if (_size != 0)
   402|             {
   403|                 ValidateSize();
   404|                 byte[]? buffer = null;
   405|                 Span<byte> span = _size <= 256 ?
   406|                     stackalloc byte[256] :
   407|                     (buffer = ArrayPool<byte>.Shared.Rent((int)_size));
   408|                 span = span.Slice(0, (int)_size);
   409|                 archiveStream.ReadExactly(span);
   410|                 ReadExtendedAttributesFromBuffer(span, _name);
   411|                 if (buffer is not null)
   412|                 {
   413|                     ArrayPool<byte>.Shared.Return(buffer);
   414|                 }
   415|             }
   416|         }
   417|         private async ValueTask ReadExtendedAttributesBlockAsync(Stream archiveStream, CancellationToken cancellationToken)
   418|         {
   419|             cancellationToken.ThrowIfCancellationRequested();
   420|             if (_size != 0)
   421|             {
   422|                 ValidateSize();
   423|                 byte[] buffer = ArrayPool<byte>.Shared.Rent((int)_size);
   424|                 Memory<byte> memory = buffer.AsMemory(0, (int)_size);
   425|                 await archiveStream.ReadExactlyAsync(memory, cancellationToken).ConfigureAwait(false);
   426|                 ReadExtendedAttributesFromBuffer(memory.Span, _name);
   427|                 ArrayPool<byte>.Shared.Return(buffer);
   428|             }
   429|         }
   430|         private void ValidateSize()
   431|         {
   432|             if ((uint)_size > (uint)Array.MaxLength)
   433|             {
   434|                 ThrowSizeFieldTooLarge();
   435|             }
   436|             [DoesNotReturn]
   437|             void ThrowSizeFieldTooLarge() =>
   438|                 throw new InvalidOperationException(string.Format(SR.TarSizeFieldTooLargeForEntryType, _typeFlag.ToString()));
   439|         }
   440|         private void ReadExtendedAttributesFromBuffer(ReadOnlySpan<byte> buffer, string name)
   441|         {
   442|             buffer = TarHelpers.TrimEndingNullsAndSpaces(buffer);
   443|             while (TryGetNextExtendedAttribute(ref buffer, out string? key, out string? value))
   444|             {
   445|                 if (!ExtendedAttributes.TryAdd(key, value))
   446|                 {
   447|                     throw new InvalidDataException(string.Format(SR.TarDuplicateExtendedAttribute, name));
   448|                 }
   449|             }
   450|         }
   451|         private void ReadGnuLongPathDataBlock(Stream archiveStream)
   452|         {
   453|             if (_size != 0)
   454|             {
   455|                 ValidateSize();
   456|                 byte[]? buffer = null;
   457|                 Span<byte> span = _size <= 256 ?
   458|                     stackalloc byte[256] :
   459|                     (buffer = ArrayPool<byte>.Shared.Rent((int)_size));
   460|                 span = span.Slice(0, (int)_size);
   461|                 archiveStream.ReadExactly(span);
   462|                 ReadGnuLongPathDataFromBuffer(span);
   463|                 if (buffer is not null)
   464|                 {
   465|                     ArrayPool<byte>.Shared.Return(buffer);
   466|                 }
   467|             }
   468|         }
   469|         private async ValueTask ReadGnuLongPathDataBlockAsync(Stream archiveStream, CancellationToken cancellationToken)
   470|         {
   471|             cancellationToken.ThrowIfCancellationRequested();
   472|             if (_size != 0)
   473|             {
   474|                 ValidateSize();
   475|                 byte[] buffer = ArrayPool<byte>.Shared.Rent((int)_size);
   476|                 Memory<byte> memory = buffer.AsMemory(0, (int)_size);
   477|                 await archiveStream.ReadExactlyAsync(memory, cancellationToken).ConfigureAwait(false);
   478|                 ReadGnuLongPathDataFromBuffer(memory.Span);
   479|                 ArrayPool<byte>.Shared.Return(buffer);
   480|             }
   481|         }
   482|         private void ReadGnuLongPathDataFromBuffer(ReadOnlySpan<byte> buffer)
   483|         {
   484|             string longPath = TarHelpers.GetTrimmedUtf8String(buffer);
   485|             if (_typeFlag == TarEntryType.LongLink)
   486|             {
   487|                 _linkName = longPath;
   488|             }
   489|             else if (_typeFlag == TarEntryType.LongPath)
   490|             {
   491|                 _name = longPath;
   492|             }
   493|         }
   494|         private static bool TryGetNextExtendedAttribute(
   495|             ref ReadOnlySpan<byte> buffer,
   496|             [NotNullWhen(returnValue: true)] out string? key,
   497|             [NotNullWhen(returnValue: true)] out string? value)
   498|         {
   499|             key = null;
   500|             value = null;
   501|             int newlinePos = buffer.IndexOf((byte)'\n');
   502|             if (newlinePos < 0)
   503|             {
   504|                 return false;
   505|             }
   506|             ReadOnlySpan<byte> line = buffer.Slice(0, newlinePos);
   507|             buffer = buffer.Slice(newlinePos + 1);
   508|             int spacePos = line.IndexOf((byte)' ');
   509|             if (spacePos < 0)
   510|             {
   511|                 return false;
   512|             }
   513|             line = line.Slice(spacePos + 1);
   514|             int equalPos = line.IndexOf((byte)'=');
   515|             if (equalPos < 0)
   516|             {
   517|                 return false;
   518|             }
   519|             ReadOnlySpan<byte> keySlice = line.Slice(0, equalPos);
   520|             ReadOnlySpan<byte> valueSlice = line.Slice(equalPos + 1);
   521|             key = Encoding.UTF8.GetString(keySlice);
   522|             value = Encoding.UTF8.GetString(valueSlice);
   523|             return true;
   524|         }
   525|     }
   526| }


# ====================================================================
# FILE: src/libraries/System.Management/src/System/Management/ManagementScope.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1105 ---
     1| using System.ComponentModel;
     2| using System.Runtime.InteropServices;
     3| using System.Globalization;
     4| using System.IO;
     5| using System.Reflection;
     6| using System.ComponentModel.Design.Serialization;
     7| using System.Security;
     8| using Microsoft.Win32;
     9| namespace System.Management
    10| {
    11|     internal static class CompatSwitches
    12|     {
    13|         internal const string DotNetVersion = "v4.0.30319";
    14|         private const string RegKeyLocation = @"SOFTWARE\Microsoft\.NETFramework\" + DotNetVersion;
    15|         private static readonly object s_syncLock = new object();
    16|         private static int s_allowManagementObjectQI;
    17|         private const string c_WMIDisableCOMSecurity = "WMIDisableCOMSecurity";
    18|         public static bool AllowIManagementObjectQI
    19|         {
    20|             get
    21|             {
    22|                 if (s_allowManagementObjectQI == 0)
    23|                 {
    24|                     lock (s_syncLock)
    25|                     {
    26|                         if (s_allowManagementObjectQI == 0)
    27|                         {
    28|                             s_allowManagementObjectQI = GetSwitchValueFromRegistry() ? 1 : -1;
    29|                         }
    30|                     }
    31|                 }
    32|                 return s_allowManagementObjectQI == 1 ? true : false;
    33|             }
    34|         }
    35|         private static bool GetSwitchValueFromRegistry()
    36|         {
    37|             RegistryKey s_switchesRegKey = null;
    38|             try
    39|             {
    40|                 s_switchesRegKey = Registry.LocalMachine.OpenSubKey(RegKeyLocation);
    41|                 if (s_switchesRegKey == null)
    42|                 {
    43|                     return false;
    44|                 }
    45|                 return ((int)s_switchesRegKey.GetValue(c_WMIDisableCOMSecurity, -1 /* default */) == 1);
    46|             }
    47|             catch (Exception e)
    48|             {
    49|                 if (e is StackOverflowException ||
    50|                     e is OutOfMemoryException ||
    51|                     e is System.Threading.ThreadAbortException ||
    52|                     e is AccessViolationException)
    53|                     throw;
    54|             }
    55|             finally
    56|             {
    57|                 s_switchesRegKey?.Dispose();
    58|             }
    59|             return false;
    60|         }
    61|     }
    62|     internal static class WmiNetUtilsHelper
    63|     {
    64|         internal delegate int ResetSecurity(IntPtr hToken);
    65|         internal delegate int SetSecurity([In][Out] ref bool pNeedtoReset, [In][Out] ref IntPtr pHandle);
    66|         internal delegate int BlessIWbemServices([MarshalAs(UnmanagedType.Interface)] IWbemServices pIUnknown,
    67|                                                                         [In][MarshalAs(UnmanagedType.BStr)]  string strUser,
    68|                                                                         IntPtr password,
    69|                                                                         [In][MarshalAs(UnmanagedType.BStr)]  string strAuthority,
    70|                                                                         int impersonationLevel,
    71|                                                                         int authenticationLevel);
    72|         internal delegate int BlessIWbemServicesObject([MarshalAs(UnmanagedType.IUnknown)] object pIUnknown,
    73|                                                                         [In][MarshalAs(UnmanagedType.BStr)]  string strUser,
    74|                                                                         IntPtr password,
    75|                                                                         [In][MarshalAs(UnmanagedType.BStr)]  string strAuthority,
    76|                                                                         int impersonationLevel,
    77|                                                                         int authenticationLevel);
    78|         internal delegate int GetPropertyHandle(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszPropertyName, [Out] out int pType, [Out] out int plHandle);
    79|         internal delegate int WritePropertyValue(int vFunc, IntPtr pWbemClassObject, [In] int lHandle, [In] int lNumBytes, [In][MarshalAs(UnmanagedType.LPWStr)] string str);
    80|         internal delegate int GetQualifierSet(int vFunc, IntPtr pWbemClassObject, [Out] out IntPtr ppQualSet);
    81|         internal delegate int Get(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszName, [In] int lFlags, [In][Out] ref object pVal, [In][Out] ref int pType, [In][Out] ref int plFlavor);
    82|         internal delegate int Put(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszName, [In] int lFlags, [In] ref object pVal, [In] int Type);
    83|         internal delegate int Delete(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszName);
    84|         internal delegate int GetNames(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszQualifierName, [In] int lFlags, [In] ref object pQualifierVal, [Out][MarshalAs(UnmanagedType.SafeArray, SafeArraySubType = VarEnum.VT_BSTR)]  out string[] pNames);
    85|         internal delegate int BeginEnumeration(int vFunc, IntPtr pWbemClassObject, [In] int lEnumFlags);
    86|         internal delegate int Next(int vFunc, IntPtr pWbemClassObject, [In] int lFlags, [In][Out][MarshalAs(UnmanagedType.BStr)]  ref string strName, [In][Out] ref object pVal, [In][Out] ref int pType, [In][Out] ref int plFlavor);
    87|         internal delegate int EndEnumeration(int vFunc, IntPtr pWbemClassObject);
    88|         internal delegate int GetPropertyQualifierSet(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszProperty, [Out] out IntPtr ppQualSet);
    89|         internal delegate int Clone(int vFunc, IntPtr pWbemClassObject, [Out] out IntPtr ppCopy);
    90|         internal delegate int GetObjectText(int vFunc, IntPtr pWbemClassObject, [In] int lFlags, [Out][MarshalAs(UnmanagedType.BStr)]  out string pstrObjectText);
    91|         internal delegate int SpawnDerivedClass(int vFunc, IntPtr pWbemClassObject, [In] int lFlags, [Out] out IntPtr ppNewClass);
    92|         internal delegate int SpawnInstance(int vFunc, IntPtr pWbemClassObject, [In] int lFlags, [Out] out IntPtr ppNewInstance);
    93|         internal delegate int CompareTo(int vFunc, IntPtr pWbemClassObject, [In] int lFlags, [In] IntPtr pCompareTo);
    94|         internal delegate int GetPropertyOrigin(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszName, [Out][MarshalAs(UnmanagedType.BStr)]  out string pstrClassName);
    95|         internal delegate int InheritsFrom(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string strAncestor);
    96|         internal delegate int GetMethod(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszName, [In] int lFlags, [Out]out IntPtr ppInSignature, [Out] out IntPtr ppOutSignature);
    97|         internal delegate int PutMethod(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszName, [In] int lFlags, [In] IntPtr pInSignature, [In] IntPtr pOutSignature);
    98|         internal delegate int DeleteMethod(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszName);
    99|         internal delegate int BeginMethodEnumeration(int vFunc, IntPtr pWbemClassObject, [In] int lEnumFlags);
   100|         internal delegate int NextMethod(int vFunc, IntPtr pWbemClassObject, [In] int lFlags, [Out][MarshalAs(UnmanagedType.BStr)] out string pstrName, [Out] out IntPtr ppInSignature, [Out] out IntPtr ppOutSignature);
   101|         internal delegate int EndMethodEnumeration(int vFunc, IntPtr pWbemClassObject);
   102|         internal delegate int GetMethodQualifierSet(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszMethod, [Out] out IntPtr ppQualSet);
   103|         internal delegate int GetMethodOrigin(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszMethodName, [Out][MarshalAs(UnmanagedType.BStr)]  out string pstrClassName);
   104|         internal delegate int QualifierSet_Get(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszName, [In] int lFlags, [In][Out] ref object pVal, [In][Out] ref int plFlavor);
   105|         internal delegate int QualifierSet_Put(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszName, [In] ref object pVal, [In] int lFlavor);
   106|         internal delegate int QualifierSet_Delete(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string wszName);
   107|         internal delegate int QualifierSet_GetNames(int vFunc, IntPtr pWbemClassObject, [In] int lFlags, [Out][MarshalAs(UnmanagedType.SafeArray, SafeArraySubType = VarEnum.VT_BSTR)]  out string[] pNames);
   108|         internal delegate int QualifierSet_BeginEnumeration(int vFunc, IntPtr pWbemClassObject, [In] int lFlags);
   109|         internal delegate int QualifierSet_Next(int vFunc, IntPtr pWbemClassObject, [In] int lFlags, [Out][MarshalAs(UnmanagedType.BStr)]  out string pstrName, [Out] out object pVal, [Out] out int plFlavor);
   110|         internal delegate int QualifierSet_EndEnumeration(int vFunc, IntPtr pWbemClassObject);
   111|         internal delegate int GetCurrentApartmentType(int vFunc, IntPtr pComThreadingInfo, [Out] out APTTYPE aptType);
   112|         internal delegate void VerifyClientKey();
   113|         internal delegate int GetDemultiplexedStub([In, MarshalAs(UnmanagedType.IUnknown)]object pIUnknown, [In]bool isLocal, [Out, MarshalAs(UnmanagedType.IUnknown)]out object ppIUnknown);
   114|         internal delegate int CreateInstanceEnumWmi([In][MarshalAs(UnmanagedType.BStr)]  string strFilter,
   115|                                                                                            [In] int lFlags,
   116|                                                                                            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext pCtx,
   117|                                                                                            [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject ppEnum,
   118|                                                                                            [In] int impLevel,
   119|                                                                                            [In] int authnLevel,
   120|                                                                                            [In] [MarshalAs(UnmanagedType.Interface)] IWbemServices pCurrentNamespace,
   121|                                                                                            [In][MarshalAs(UnmanagedType.BStr)]  string strUser,
   122|                                                                                            [In]IntPtr strPassword,
   123|                                                                                            [In][MarshalAs(UnmanagedType.BStr)]  string strAuthority
   124|                                                                                            );
   125|         internal delegate int CreateClassEnumWmi([In][MarshalAs(UnmanagedType.BStr)]  string strSuperclass,
   126|                                                                                        [In] int lFlags,
   127|                                                                                        [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext pCtx,
   128|                                                                                        [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject ppEnum,
   129|                                                                                        [In] int impLevel,
   130|                                                                                        [In] int authnLevel,
   131|                                                                                        [In] [MarshalAs(UnmanagedType.Interface)] IWbemServices pCurrentNamespace,
   132|                                                                                        [In][MarshalAs(UnmanagedType.BStr)]  string strUser,
   133|                                                                                        [In]IntPtr strPassword,
   134|                                                                                        [In][MarshalAs(UnmanagedType.BStr)]  string strAuthority
   135|                                                                                        );
   136|         internal delegate int ExecQueryWmi([In][MarshalAs(UnmanagedType.BStr)]  string strQueryLanguage,
   137|                                                                            [In][MarshalAs(UnmanagedType.BStr)]  string strQuery,
   138|                                                                            [In] int lFlags,
   139|                                                                            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext pCtx,
   140|                                                                            [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject ppEnum,
   141|                                                                            [In] int impLevel,
   142|                                                                            [In] int authnLevel,
   143|                                                                            [In] [MarshalAs(UnmanagedType.Interface)] IWbemServices pCurrentNamespace,
   144|                                                                            [In][MarshalAs(UnmanagedType.BStr)]  string strUser,
   145|                                                                            [In]IntPtr strPassword,
   146|                                                                            [In][MarshalAs(UnmanagedType.BStr)]  string strAuthority
   147|                                                                            );
   148|         internal delegate int ExecNotificationQueryWmi([In][MarshalAs(UnmanagedType.BStr)]  string strQueryLanguage,
   149|                                                                                                 [In][MarshalAs(UnmanagedType.BStr)]  string strQuery,
   150|                                                                                                 [In] int lFlags,
   151|                                                                                                 [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext pCtx,
   152|                                                                                                 [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject ppEnum,
   153|                                                                                                 [In] int impLevel,
   154|                                                                                                 [In] int authnLevel,
   155|                                                                                                 [In] [MarshalAs(UnmanagedType.Interface)] IWbemServices pCurrentNamespace,
   156|                                                                                                 [In][MarshalAs(UnmanagedType.BStr)]  string strUser,
   157|                                                                                                 [In]IntPtr strPassword,
   158|                                                                                                 [In][MarshalAs(UnmanagedType.BStr)]  string strAuthority
   159|                                                                                                 );
   160|         internal delegate int PutInstanceWmi([In] IntPtr pInst,
   161|                                                                             [In] int lFlags,
   162|                                                                             [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext pCtx,
   163|                                                                             [In] IntPtr ppCallResult,
   164|                                                                             [In] int impLevel,
   165|                                                                             [In] int authnLevel,
   166|                                                                             [In] [MarshalAs(UnmanagedType.Interface)] IWbemServices pCurrentNamespace,
   167|                                                                             [In][MarshalAs(UnmanagedType.BStr)]  string strUser,
   168|                                                                             [In]IntPtr strPassword,
   169|                                                                             [In][MarshalAs(UnmanagedType.BStr)]  string strAuthority
   170|                                                                             );
   171|         internal delegate int PutClassWmi([In] IntPtr pObject,
   172|                                                                         [In] int lFlags,
   173|                                                                         [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext pCtx,
   174|                                                                         [In] IntPtr ppCallResult,
   175|                                                                         [In] int impLevel,
   176|                                                                         [In] int authnLevel,
   177|                                                                         [In] [MarshalAs(UnmanagedType.Interface)] IWbemServices pCurrentNamespace,
   178|                                                                         [In][MarshalAs(UnmanagedType.BStr)]  string strUser,
   179|                                                                         [In]IntPtr strPassword,
   180|                                                                         [In][MarshalAs(UnmanagedType.BStr)]  string strAuthority
   181|                                                                         );
   182|         internal delegate int CloneEnumWbemClassObject(
   183|                                                                 [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject ppEnum,
   184|                                                                 [In] int impLevel,
   185|                                                                 [In] int authnLevel,
   186|                                                                 [In] [MarshalAs(UnmanagedType.Interface)] IEnumWbemClassObject pCurrentEnumWbemClassObject,
   187|                                                                 [In][MarshalAs(UnmanagedType.BStr)]  string strUser,
   188|                                                                 [In]IntPtr strPassword,
   189|                                                                 [In][MarshalAs(UnmanagedType.BStr)]  string strAuthority
   190|                                                                 );
   191|         internal delegate int ConnectServerWmi(
   192|                                                                         [In][MarshalAs(UnmanagedType.BStr)]  string strNetworkResource,
   193|                                                                         [In][MarshalAs(UnmanagedType.BStr)]  string strUser,
   194|                                                                         [In]  IntPtr strPassword,
   195|                                                                         [In][MarshalAs(UnmanagedType.BStr)]  string strLocale,
   196|                                                                         [In] int lSecurityFlags,
   197|                                                                         [In][MarshalAs(UnmanagedType.BStr)]  string strAuthority,
   198|                                                                         [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext pCtx,
   199|                                                                         [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemServices ppNamespace,
   200|                                                                         int impersonationLevel,
   201|                                                                         int authenticationLevel);
   202|         internal delegate IntPtr GetErrorInfo();
   203|         internal delegate int Initialize([In]bool AllowIManagementObjectQI);
   204|         internal enum APTTYPE
   205|         {
   206|             APTTYPE_CURRENT = -1,
   207|             APTTYPE_STA = 0,
   208|             APTTYPE_MTA = 1,
   209|             APTTYPE_NA = 2,
   210|             APTTYPE_MAINSTA = 3
   211|         }
   212|         internal static ResetSecurity ResetSecurity_f;
   213|         internal static SetSecurity SetSecurity_f;
   214|         internal static BlessIWbemServices BlessIWbemServices_f;
   215|         internal static BlessIWbemServicesObject BlessIWbemServicesObject_f;
   216|         internal static GetPropertyHandle GetPropertyHandle_f27;
   217|         internal static WritePropertyValue WritePropertyValue_f28;
   218|         internal static GetQualifierSet GetQualifierSet_f;
   219|         internal static Get Get_f;
   220|         internal static Put Put_f;
   221|         internal static Delete Delete_f;
   222|         internal static GetNames GetNames_f;
   223|         internal static BeginEnumeration BeginEnumeration_f;
   224|         internal static Next Next_f;
   225|         internal static EndEnumeration EndEnumeration_f;
   226|         internal static GetPropertyQualifierSet GetPropertyQualifierSet_f;
   227|         internal static Clone Clone_f;
   228|         internal static GetObjectText GetObjectText_f;
   229|         internal static SpawnDerivedClass SpawnDerivedClass_f;
   230|         internal static SpawnInstance SpawnInstance_f;
   231|         internal static CompareTo CompareTo_f;
   232|         internal static GetPropertyOrigin GetPropertyOrigin_f;
   233|         internal static InheritsFrom InheritsFrom_f;
   234|         internal static GetMethod GetMethod_f;
   235|         internal static PutMethod PutMethod_f;
   236|         internal static DeleteMethod DeleteMethod_f;
   237|         internal static BeginMethodEnumeration BeginMethodEnumeration_f;
   238|         internal static NextMethod NextMethod_f;
   239|         internal static EndMethodEnumeration EndMethodEnumeration_f;
   240|         internal static GetMethodQualifierSet GetMethodQualifierSet_f;
   241|         internal static GetMethodOrigin GetMethodOrigin_f;
   242|         internal static QualifierSet_Get QualifierGet_f;
   243|         internal static QualifierSet_Put QualifierPut_f;
   244|         internal static QualifierSet_Delete QualifierDelete_f;
   245|         internal static QualifierSet_GetNames QualifierGetNames_f;
   246|         internal static QualifierSet_BeginEnumeration QualifierBeginEnumeration_f;
   247|         internal static QualifierSet_Next QualifierNext_f;
   248|         internal static QualifierSet_EndEnumeration QualifierEndEnumeration_f;
   249|         internal static GetCurrentApartmentType GetCurrentApartmentType_f;
   250|         internal static VerifyClientKey VerifyClientKey_f;
   251|         internal static Clone Clone_f12;
   252|         internal static GetDemultiplexedStub GetDemultiplexedStub_f;
   253|         internal static CreateInstanceEnumWmi CreateInstanceEnumWmi_f;
   254|         internal static CreateClassEnumWmi CreateClassEnumWmi_f;
   255|         internal static ExecQueryWmi ExecQueryWmi_f;
   256|         internal static ExecNotificationQueryWmi ExecNotificationQueryWmi_f;
   257|         internal static PutInstanceWmi PutInstanceWmi_f;
   258|         internal static PutClassWmi PutClassWmi_f;
   259|         internal static CloneEnumWbemClassObject CloneEnumWbemClassObject_f;
   260|         internal static ConnectServerWmi ConnectServerWmi_f;
   261|         internal static GetErrorInfo GetErrorInfo_f;
   262|         internal static Initialize Initialize_f;
   263|         static WmiNetUtilsHelper()
   264|         {
   265|             RegistryKey netFrameworkSubKey = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\.NETFramework\");
   266|             string netFrameworkInstallRoot = (string)netFrameworkSubKey?.GetValue(RuntimeInformation.ProcessArchitecture == Architecture.Arm64 ?
   267|                 "InstallRootArm64" :
   268|                 "InstallRoot");
   269|             if (netFrameworkInstallRoot == null)
   270|             {
   271|                 LoadPlatformNotSupportedDelegates(SR.PlatformNotSupported_FullFrameworkRequired);
   272|                 return;
   273|             }
   274|             string wminet_utilsPath = Path.Combine(
   275|                 netFrameworkInstallRoot,
   276|                 CompatSwitches.DotNetVersion, // The same value is hard coded on Environment.Version and quirks for WMI
   277|                 "wminet_utils.dll");
   278|             IntPtr hModule = Interop.Kernel32.LoadLibrary(wminet_utilsPath);
   279|             if (hModule == IntPtr.Zero)
   280|             {
   281|                 throw new Win32Exception(Marshal.GetLastWin32Error(), SR.Format(SR.LoadLibraryFailed, wminet_utilsPath));
   282|             }
   283|             if (LoadDelegate(ref ResetSecurity_f, hModule, "ResetSecurity") &&
   284|                 LoadDelegate(ref SetSecurity_f, hModule, "SetSecurity") &&
   285|                 LoadDelegate(ref BlessIWbemServices_f, hModule, "BlessIWbemServices") &&
   286|                 LoadDelegate(ref BlessIWbemServicesObject_f, hModule, "BlessIWbemServicesObject") &&
   287|                 LoadDelegate(ref GetPropertyHandle_f27, hModule, "GetPropertyHandle") &&
   288|                 LoadDelegate(ref WritePropertyValue_f28, hModule, "WritePropertyValue") &&
   289|                 LoadDelegate(ref Clone_f12, hModule, "Clone") &&
   290|                 LoadDelegate(ref VerifyClientKey_f, hModule, "VerifyClientKey") &&
   291|                 LoadDelegate(ref GetQualifierSet_f, hModule, "GetQualifierSet") &&
   292|                 LoadDelegate(ref Get_f, hModule, "Get") &&
   293|                 LoadDelegate(ref Put_f, hModule, "Put") &&
   294|                 LoadDelegate(ref Delete_f, hModule, "Delete") &&
   295|                 LoadDelegate(ref GetNames_f, hModule, "GetNames") &&
   296|                 LoadDelegate(ref BeginEnumeration_f, hModule, "BeginEnumeration") &&
   297|                 LoadDelegate(ref Next_f, hModule, "Next") &&
   298|                 LoadDelegate(ref EndEnumeration_f, hModule, "EndEnumeration") &&
   299|                 LoadDelegate(ref GetPropertyQualifierSet_f, hModule, "GetPropertyQualifierSet") &&
   300|                 LoadDelegate(ref Clone_f, hModule, "Clone") &&
   301|                 LoadDelegate(ref GetObjectText_f, hModule, "GetObjectText") &&
   302|                 LoadDelegate(ref SpawnDerivedClass_f, hModule, "SpawnDerivedClass") &&
   303|                 LoadDelegate(ref SpawnInstance_f, hModule, "SpawnInstance") &&
   304|                 LoadDelegate(ref CompareTo_f, hModule, "CompareTo") &&
   305|                 LoadDelegate(ref GetPropertyOrigin_f, hModule, "GetPropertyOrigin") &&
   306|                 LoadDelegate(ref InheritsFrom_f, hModule, "InheritsFrom") &&
   307|                 LoadDelegate(ref GetMethod_f, hModule, "GetMethod") &&
   308|                 LoadDelegate(ref PutMethod_f, hModule, "PutMethod") &&
   309|                 LoadDelegate(ref DeleteMethod_f, hModule, "DeleteMethod") &&
   310|                 LoadDelegate(ref BeginMethodEnumeration_f, hModule, "BeginMethodEnumeration") &&
   311|                 LoadDelegate(ref NextMethod_f, hModule, "NextMethod") &&
   312|                 LoadDelegate(ref EndMethodEnumeration_f, hModule, "EndMethodEnumeration") &&
   313|                 LoadDelegate(ref GetMethodQualifierSet_f, hModule, "GetMethodQualifierSet") &&
   314|                 LoadDelegate(ref GetMethodOrigin_f, hModule, "GetMethodOrigin") &&
   315|                 LoadDelegate(ref QualifierGet_f, hModule, "QualifierSet_Get") &&
   316|                 LoadDelegate(ref QualifierPut_f, hModule, "QualifierSet_Put") &&
   317|                 LoadDelegate(ref QualifierDelete_f, hModule, "QualifierSet_Delete") &&
   318|                 LoadDelegate(ref QualifierGetNames_f, hModule, "QualifierSet_GetNames") &&
   319|                 LoadDelegate(ref QualifierBeginEnumeration_f, hModule, "QualifierSet_BeginEnumeration") &&
   320|                 LoadDelegate(ref QualifierNext_f, hModule, "QualifierSet_Next") &&
   321|                 LoadDelegate(ref QualifierEndEnumeration_f, hModule, "QualifierSet_EndEnumeration") &&
   322|                 LoadDelegate(ref GetCurrentApartmentType_f, hModule, "GetCurrentApartmentType") &&
   323|                 LoadDelegate(ref GetDemultiplexedStub_f, hModule, "GetDemultiplexedStub") &&
   324|                 LoadDelegate(ref CreateInstanceEnumWmi_f, hModule, "CreateInstanceEnumWmi") &&
   325|                 LoadDelegate(ref CreateClassEnumWmi_f, hModule, "CreateClassEnumWmi") &&
   326|                 LoadDelegate(ref ExecQueryWmi_f, hModule, "ExecQueryWmi") &&
   327|                 LoadDelegate(ref ExecNotificationQueryWmi_f, hModule, "ExecNotificationQueryWmi") &&
   328|                 LoadDelegate(ref PutInstanceWmi_f, hModule, "PutInstanceWmi") &&
   329|                 LoadDelegate(ref PutClassWmi_f, hModule, "PutClassWmi") &&
   330|                 LoadDelegate(ref CloneEnumWbemClassObject_f, hModule, "CloneEnumWbemClassObject") &&
   331|                 LoadDelegate(ref ConnectServerWmi_f, hModule, "ConnectServerWmi") &&
   332|                 LoadDelegate(ref GetErrorInfo_f, hModule, "GetErrorInfo") &&
   333|                 LoadDelegate(ref Initialize_f, hModule, "Initialize"))
   334|             {
   335|                 Initialize_f(CompatSwitches.AllowIManagementObjectQI);
   336|             }
   337|             else
   338|             {
   339|                 LoadPlatformNotSupportedDelegates(SR.Format(SR.PlatformNotSupported_FrameworkUpdatedRequired, wminet_utilsPath));
   340|             }
   341|         }
   342|         private static bool LoadDelegate<TDelegate>(ref TDelegate delegate_f, IntPtr hModule, string procName) where TDelegate : class
   343|         {
   344|             IntPtr procAddr = Interop.Kernel32.GetProcAddress(hModule, procName);
   345|             return procAddr != IntPtr.Zero &&
   346|                 (delegate_f = Marshal.GetDelegateForFunctionPointer<TDelegate>(procAddr)) != null;
   347|         }
   348|         private static void LoadPlatformNotSupportedDelegates(string exceptionMessage)
   349|         {
   350|             ResetSecurity_f = (_) => throw new PlatformNotSupportedException(exceptionMessage);
   351|             SetSecurity_f = (ref bool _, ref IntPtr __) => throw new PlatformNotSupportedException(exceptionMessage);
   352|             BlessIWbemServices_f = (_, __, ___, ____, _____, ______) => throw new PlatformNotSupportedException(exceptionMessage);
   353|             BlessIWbemServicesObject_f = (_, __, ___, ____, _____, ______) => throw new PlatformNotSupportedException(exceptionMessage);
   354|             GetPropertyHandle_f27 = (int _, IntPtr __, string ___, out int ____, out int _____) => throw new PlatformNotSupportedException(exceptionMessage);
   355|             WritePropertyValue_f28 = (_, __, ___, ____, _____) => throw new PlatformNotSupportedException(exceptionMessage);
   356|             Clone_f12 = (int _, IntPtr __, out IntPtr ___) => throw new PlatformNotSupportedException(exceptionMessage);
   357|             VerifyClientKey_f = () => throw new PlatformNotSupportedException(exceptionMessage);
   358|             GetQualifierSet_f = (int _, IntPtr __, out IntPtr ___) => throw new PlatformNotSupportedException(exceptionMessage);
   359|             Get_f = (int _, IntPtr __, string ___, int ____, ref object _____, ref int ______, ref int _______) => throw new PlatformNotSupportedException(exceptionMessage);
   360|             Put_f = (int _, IntPtr __, string ___, int ____, ref object _____, int ______) => throw new PlatformNotSupportedException(exceptionMessage);
   361|             Delete_f = (_, __, ___) => throw new PlatformNotSupportedException(exceptionMessage);
   362|             GetNames_f = (int _, IntPtr __, string ___, int ____, ref object _____, out string[] ______) => throw new PlatformNotSupportedException(exceptionMessage);
   363|             BeginEnumeration_f = (_, __, ___) => throw new PlatformNotSupportedException(exceptionMessage);
   364|             Next_f = (int _, IntPtr __, int ___, ref string ____, ref object _____, ref int ______, ref int _______) => throw new PlatformNotSupportedException(exceptionMessage);
   365|             EndEnumeration_f = (_, __) => throw new PlatformNotSupportedException(exceptionMessage);
   366|             GetPropertyQualifierSet_f = (int _, IntPtr __, string ___, out IntPtr ____) => throw new PlatformNotSupportedException(exceptionMessage);
   367|             Clone_f = (int _, IntPtr __, out IntPtr ___) => throw new PlatformNotSupportedException(exceptionMessage);
   368|             GetObjectText_f = (int _, IntPtr __, int ___, out string ____) => throw new PlatformNotSupportedException(exceptionMessage);
   369|             SpawnDerivedClass_f = (int _, IntPtr __, int ___, out IntPtr ____) => throw new PlatformNotSupportedException(exceptionMessage);
   370|             SpawnInstance_f = (int _, IntPtr __, int ___, out IntPtr ____) => throw new PlatformNotSupportedException(exceptionMessage);
   371|             CompareTo_f = (_, __, ___, ____) => throw new PlatformNotSupportedException(exceptionMessage);
   372|             GetPropertyOrigin_f = (int _, IntPtr __, string ___, out string ____) => throw new PlatformNotSupportedException(exceptionMessage);
   373|             InheritsFrom_f = (int _, IntPtr __, string ___) => throw new PlatformNotSupportedException(exceptionMessage);
   374|             GetMethod_f = (int _, IntPtr __, string ___, int ____, out IntPtr _____, out IntPtr ______) => throw new PlatformNotSupportedException(exceptionMessage);
   375|             PutMethod_f = (_, __, ___, ____, _____, ______) => throw new PlatformNotSupportedException(exceptionMessage);
   376|             DeleteMethod_f = (_, __, ___) => throw new PlatformNotSupportedException(exceptionMessage);
   377|             BeginMethodEnumeration_f = (_, __, ___) => throw new PlatformNotSupportedException(exceptionMessage);
   378|             NextMethod_f = (int _, IntPtr __, int ___, out string ____, out IntPtr _____, out IntPtr ______) => throw new PlatformNotSupportedException(exceptionMessage);
   379|             EndMethodEnumeration_f = (_, __) => throw new PlatformNotSupportedException(exceptionMessage);
   380|             GetMethodQualifierSet_f = (int _, IntPtr __, string ___, out IntPtr ____) => throw new PlatformNotSupportedException(exceptionMessage);
   381|             GetMethodOrigin_f = (int _, IntPtr __, string ___, out string ____) => throw new PlatformNotSupportedException(exceptionMessage);
   382|             QualifierGet_f = (int _, IntPtr __, string ___, int ____, ref object _____, ref int ______) => throw new PlatformNotSupportedException(exceptionMessage);
   383|             QualifierPut_f = (int _, IntPtr __, string ___, ref object ____, int _____) => throw new PlatformNotSupportedException(exceptionMessage);
   384|             QualifierDelete_f = (_, __, ___) => throw new PlatformNotSupportedException(exceptionMessage);
   385|             QualifierGetNames_f = (int _, IntPtr __, int ___, out string[] ____) => throw new PlatformNotSupportedException(exceptionMessage);
   386|             QualifierBeginEnumeration_f = (_, __, ___) => throw new PlatformNotSupportedException(exceptionMessage);
   387|             QualifierNext_f = (int _, IntPtr __, int ___, out string ____, out object _____, out int ______) => throw new PlatformNotSupportedException(exceptionMessage);
   388|             QualifierEndEnumeration_f = (_, __) => throw new PlatformNotSupportedException(exceptionMessage);
   389|             GetCurrentApartmentType_f = (int _, IntPtr __, out APTTYPE ___) => throw new PlatformNotSupportedException(exceptionMessage);
   390|             GetDemultiplexedStub_f = (object _, bool __, out object ___) => throw new PlatformNotSupportedException(exceptionMessage);
   391|             CreateInstanceEnumWmi_f = (string _, int __, IWbemContext ___, out IEnumWbemClassObject ____, int _____, int ______, IWbemServices _______, string ________, IntPtr _________, string __________) => throw new PlatformNotSupportedException(exceptionMessage);
   392|             CreateClassEnumWmi_f = (string _, int __, IWbemContext ___, out IEnumWbemClassObject ____, int _____, int ______, IWbemServices _______, string ________, IntPtr _________, string __________) => throw new PlatformNotSupportedException(exceptionMessage);
   393|             ExecQueryWmi_f = (string _, string __, int ___, IWbemContext ____, out IEnumWbemClassObject _____, int ______, int _______, IWbemServices ________, string _________, IntPtr __________, string ___________) => throw new PlatformNotSupportedException(exceptionMessage);
   394|             ExecNotificationQueryWmi_f = (string _, string __, int ___, IWbemContext ____, out IEnumWbemClassObject _____, int ______, int _______, IWbemServices ________, string _________, IntPtr __________, string ___________) => throw new PlatformNotSupportedException(exceptionMessage);
   395|             PutInstanceWmi_f = (_, __, ___, ____, _____, ______, _______, ________, _________, __________) => throw new PlatformNotSupportedException(exceptionMessage);
   396|             PutClassWmi_f = (_, __, ___, ____, _____, ______, _______, ________, _________, __________) => throw new PlatformNotSupportedException(exceptionMessage);
   397|             CloneEnumWbemClassObject_f = (out IEnumWbemClassObject _, int __, int ____, IEnumWbemClassObject _____, string ______, IntPtr _______, string ________) => throw new PlatformNotSupportedException(exceptionMessage);
   398|             ConnectServerWmi_f = (string _, string __, IntPtr ___, string ____, int _____, string ______, IWbemContext _______, out IWbemServices ________, int _________, int __________) => throw new PlatformNotSupportedException(exceptionMessage);
   399|             GetErrorInfo_f = () => throw new PlatformNotSupportedException(exceptionMessage);
   400|             Initialize_f = (_) => throw new PlatformNotSupportedException(exceptionMessage);
   401|         }
   402|     }
   403|     [TypeConverter(typeof(ManagementScopeConverter))]
   404|     public class ManagementScope : ICloneable
   405|     {
   406|         private ManagementPath validatedPath;
   407|         private IWbemServices wbemServices;
   408|         private ConnectionOptions options;
   409|         internal event IdentifierChangedEventHandler IdentifierChanged;
   410|         internal bool IsDefaulted; //used to tell whether the current scope has been created from the default
   411|         private void FireIdentifierChanged()
   412|         {
   413|             IdentifierChanged?.Invoke(this, null);
   414|         }
   415|         private void HandleIdentifierChange(object sender,
   416|             IdentifierChangedEventArgs args)
   417|         {
   418|             wbemServices = null;
   419|             FireIdentifierChanged();
   420|         }
   421|         private ManagementPath prvpath
   422|         {
   423|             get
   424|             {
   425|                 return validatedPath;
   426|             }
   427|             set
   428|             {
   429|                 if (value != null)
   430|                 {
   431|                     string pathValue = value.Path;
   432|                     if (!ManagementPath.IsValidNamespaceSyntax(pathValue))
   433|                         ManagementException.ThrowWithExtendedInfo((ManagementStatus)tag_WBEMSTATUS.WBEM_E_INVALID_NAMESPACE);
   434|                 }
   435|                 validatedPath = value;
   436|             }
   437|         }
   438|         internal IWbemServices GetIWbemServices()
   439|         {
   440|             IWbemServices localCopy = wbemServices;
   441|             if (CompatSwitches.AllowIManagementObjectQI)
   442|             {
   443|                 IntPtr pUnk = Marshal.GetIUnknownForObject(wbemServices);
   444|                 object unknown = Marshal.GetObjectForIUnknown(pUnk);
   445|                 Marshal.Release(pUnk);
   446|                 if (!object.ReferenceEquals(unknown, wbemServices))
   447|                 {
   448|                     SecurityHandler securityHandler = GetSecurityHandler();
   449|                     securityHandler.SecureIUnknown(unknown);
   450|                     localCopy = (IWbemServices)unknown;
   451|                     securityHandler.Secure(localCopy);
   452|                 }
   453|             }
   454|             return localCopy; // STRANGE: Why does it still work if I return 'wbemServices'?
   455|         }
   456|         public bool IsConnected
   457|         {
   458|             get
   459|             {
   460|                 return (null != wbemServices);
   461|             }
   462|         }
   463|         internal ManagementScope(ManagementPath path, IWbemServices wbemServices,
   464|             ConnectionOptions options)
   465|         {
   466|             if (null != path)
   467|                 this.Path = path;
   468|             if (null != options)
   469|             {
   470|                 this.Options = options;
   471|             }
   472|             this.wbemServices = wbemServices;
   473|         }
   474|         internal ManagementScope(ManagementPath path, ManagementScope scope)
   475|             : this(path, scope?.options) { }
   476|         internal static ManagementScope _Clone(ManagementScope scope)
   477|         {
   478|             return ManagementScope._Clone(scope, null);
   479|         }
   480|         internal static ManagementScope _Clone(ManagementScope scope, IdentifierChangedEventHandler handler)
   481|         {
   482|             ManagementScope scopeTmp = new ManagementScope(null, null, null);
   483|             if (handler != null)
   484|                 scopeTmp.IdentifierChanged = handler;
   485|             else if (scope != null)
   486|                 scopeTmp.IdentifierChanged = new IdentifierChangedEventHandler(scope.HandleIdentifierChange);
   487|             if (scope == null)
   488|             {
   489|                 scopeTmp.prvpath = ManagementPath._Clone(ManagementPath.DefaultPath, new IdentifierChangedEventHandler(scopeTmp.HandleIdentifierChange));
   490|                 scopeTmp.IsDefaulted = true;
   491|                 scopeTmp.wbemServices = null;
   492|                 scopeTmp.options = null;
   493|             }
   494|             else
   495|             {
   496|                 if (scope.prvpath == null)
   497|                 {
   498|                     scopeTmp.prvpath = ManagementPath._Clone(ManagementPath.DefaultPath, new IdentifierChangedEventHandler(scopeTmp.HandleIdentifierChange));
   499|                     scopeTmp.IsDefaulted = true;
   500|                 }
   501|                 else
   502|                 {
   503|                     scopeTmp.prvpath = ManagementPath._Clone(scope.prvpath, new IdentifierChangedEventHandler(scopeTmp.HandleIdentifierChange));
   504|                     scopeTmp.IsDefaulted = scope.IsDefaulted;
   505|                 }
   506|                 scopeTmp.wbemServices = scope.wbemServices;
   507|                 if (scope.options != null)
   508|                     scopeTmp.options = ConnectionOptions._Clone(scope.options, new IdentifierChangedEventHandler(scopeTmp.HandleIdentifierChange));
   509|             }
   510|             return scopeTmp;
   511|         }
   512|         public ManagementScope() :
   513|             this(new ManagementPath(ManagementPath.DefaultPath.Path))
   514|         {
   515|             IsDefaulted = true;
   516|         }
   517|         public ManagementScope(ManagementPath path) : this(path, (ConnectionOptions)null) { }
   518|         public ManagementScope(string path) : this(new ManagementPath(path), (ConnectionOptions)null) { }
   519|         public ManagementScope(string path, ConnectionOptions options) : this(new ManagementPath(path), options) { }
   520|         public ManagementScope(ManagementPath path, ConnectionOptions options)
   521|         {
   522|             if (null != path)
   523|                 this.prvpath = ManagementPath._Clone(path, new IdentifierChangedEventHandler(HandleIdentifierChange));
   524|             else
   525|                 this.prvpath = ManagementPath._Clone(null);
   526|             if (null != options)
   527|             {
   528|                 this.options = ConnectionOptions._Clone(options, new IdentifierChangedEventHandler(HandleIdentifierChange));
   529|             }
   530|             else
   531|                 this.options = null;
   532|             IsDefaulted = false; //assume that this scope is not initialized by the default path
   533|         }
   534|         public ConnectionOptions Options
   535|         {
   536|             get
   537|             {
   538|                 return options ??= ConnectionOptions._Clone(null, new IdentifierChangedEventHandler(HandleIdentifierChange));
   539|             }
   540|             set
   541|             {
   542|                 if (null != value)
   543|                 {
   544|                     if (null != options)
   545|                         options.IdentifierChanged -= new IdentifierChangedEventHandler(HandleIdentifierChange);
   546|                     options = ConnectionOptions._Clone((ConnectionOptions)value, new IdentifierChangedEventHandler(HandleIdentifierChange));
   547|                     HandleIdentifierChange(this, null);
   548|                 }
   549|                 else
   550|                     throw new ArgumentNullException(nameof(value));
   551|             }
   552|         }
   553|         public ManagementPath Path
   554|         {
   555|             get
   556|             {
   557|                 return prvpath ??= ManagementPath._Clone(null);
   558|             }
   559|             set
   560|             {
   561|                 if (null != value)
   562|                 {
   563|                     if (null != prvpath)
   564|                         prvpath.IdentifierChanged -= new IdentifierChangedEventHandler(HandleIdentifierChange);
   565|                     IsDefaulted = false; //someone is specifically setting the scope path so it's not defaulted any more
   566|                     prvpath = ManagementPath._Clone((ManagementPath)value, new IdentifierChangedEventHandler(HandleIdentifierChange));
   567|                     HandleIdentifierChange(this, null);
   568|                 }
   569|                 else
   570|                     throw new ArgumentNullException(nameof(value));
   571|             }
   572|         }
   573|         public ManagementScope Clone()
   574|         {
   575|             return ManagementScope._Clone(this);
   576|         }
   577|         object ICloneable.Clone()
   578|         {
   579|             return Clone();
   580|         }
   581|         public void Connect()
   582|         {
   583|             Initialize();
   584|         }
   585|         internal void Initialize()
   586|         {
   587|             if (null == prvpath)
   588|                 throw new InvalidOperationException();
   589|             /*
   590|              * If we're not connected yet, this is the time to do it... We lock
   591|              * the state to prevent 2 threads simultaneously doing the same
   592|              * connection. To avoid taking the lock unnecessarily we examine
   593|              * isConnected first
   594|              */
   595|             if (!IsConnected)
   596|             {
   597|                 lock (this)
   598|                 {
   599|                     if (!IsConnected)
   600|                     {
   601|                         if (!MTAHelper.IsNoContextMTA())
   602|                         {
   603|                             ThreadDispatch disp = new ThreadDispatch(new ThreadDispatch.ThreadWorkerMethodWithParam(InitializeGuts));
   604|                             disp.Parameter = this;
   605|                             disp.Start();
   606|                         }
   607|                         else
   608|                             InitializeGuts(this);
   609|                     }
   610|                 }
   611|             }
   612|         }
   613|         private void InitializeGuts(object o)
   614|         {
   615|             ManagementScope threadParam = (ManagementScope)o;
   616|             if (null == threadParam.options)
   617|             {
   618|                 threadParam.Options = new ConnectionOptions();
   619|             }
   620|             string nsPath = threadParam.prvpath.GetNamespacePath((int)tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY);
   621|             if ((null == nsPath) || (0 == nsPath.Length))
   622|             {
   623|                 nsPath = threadParam.prvpath.SetNamespacePath(ManagementPath.DefaultPath.Path, out _);
   624|             }
   625|             int status = (int)ManagementStatus.NoError;
   626|             threadParam.wbemServices = null;
   627|             if (Environment.OSVersion.Platform == PlatformID.Win32NT)
   628|             {
   629|                 if (((Environment.OSVersion.Version.Major == 5) && (Environment.OSVersion.Version.Minor >= 1)) || (Environment.OSVersion.Version.Major >= 6))
   630|                 {
   631|                     threadParam.options.Flags |= (int)tag_WBEM_CONNECT_OPTIONS.WBEM_FLAG_CONNECT_USE_MAX_WAIT;
   632|                 }
   633|             }
   634|             try
   635|             {
   636|                 status = GetSecuredConnectHandler().ConnectNSecureIWbemServices(nsPath, ref threadParam.wbemServices);
   637|             }
   638|             catch (COMException e)
   639|             {
   640|                 ManagementException.ThrowWithExtendedInfo(e);
   641|             }
   642|             if ((status & 0xfffff000) == 0x80041000)
   643|             {
   644|                 ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
   645|             }
   646|             else if ((status & 0x80000000) != 0)
   647|             {
   648|                 Marshal.ThrowExceptionForHR(status, WmiNetUtilsHelper.GetErrorInfo_f());
   649|             }
   650|         }
   651|         internal SecurityHandler GetSecurityHandler()
   652|         {
   653|             return new SecurityHandler(this);
   654|         }
   655|         internal SecuredConnectHandler GetSecuredConnectHandler()
   656|         {
   657|             return new SecuredConnectHandler(this);
   658|         }
   659|         internal SecuredIEnumWbemClassObjectHandler GetSecuredIEnumWbemClassObjectHandler(IEnumWbemClassObject pEnumWbemClassObject)
   660|         {
   661|             return new SecuredIEnumWbemClassObjectHandler(this, pEnumWbemClassObject);
   662|         }
   663|         internal SecuredIWbemServicesHandler GetSecuredIWbemServicesHandler(IWbemServices pWbemServiecs)
   664|         {
   665|             return new SecuredIWbemServicesHandler(this, pWbemServiecs);
   666|         }
   667|     }//ManagementScope
   668|     internal sealed class SecuredIEnumWbemClassObjectHandler
   669|     {
   670|         private readonly IEnumWbemClassObject pEnumWbemClassObjectsecurityHelper;
   671|         private readonly ManagementScope scope;
   672|         internal SecuredIEnumWbemClassObjectHandler(ManagementScope theScope, IEnumWbemClassObject pEnumWbemClassObject)
   673|         {
   674|             this.scope = theScope;
   675|             pEnumWbemClassObjectsecurityHelper = pEnumWbemClassObject;
   676|         }
   677|         internal int Reset_()
   678|         {
   679|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   680|             status = pEnumWbemClassObjectsecurityHelper.Reset_();
   681|             return status;
   682|         }
   683|         internal int Next_(int lTimeout, uint uCount, IWbemClassObject_DoNotMarshal[] ppOutParams, ref uint puReturned)
   684|         {
   685|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   686|             status = pEnumWbemClassObjectsecurityHelper.Next_(lTimeout, uCount, ppOutParams, out puReturned);
   687|             return status;
   688|         }
   689|         internal int NextAsync_(uint uCount, IWbemObjectSink pSink)
   690|         {
   691|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   692|             status = pEnumWbemClassObjectsecurityHelper.NextAsync_(uCount, pSink);
   693|             return status;
   694|         }
   695|         internal int Clone_(ref IEnumWbemClassObject ppEnum)
   696|         {
   697|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   698|             if (null != scope)
   699|             {
   700|                 IntPtr password = scope.Options.GetPassword();
   701|                 status = WmiNetUtilsHelper.CloneEnumWbemClassObject_f(
   702|                     out ppEnum,
   703|                     (int)scope.Options.Authentication,
   704|                     (int)scope.Options.Impersonation,
   705|                     pEnumWbemClassObjectsecurityHelper,
   706|                     scope.Options.Username,
   707|                     password,
   708|                     scope.Options.Authority);
   709|                 System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(password);
   710|             }
   711|             return status;
   712|         }
   713|         internal int Skip_(int lTimeout, uint nCount)
   714|         {
   715|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   716|             status = pEnumWbemClassObjectsecurityHelper.Skip_(lTimeout, nCount);
   717|             return status;
   718|         }
   719|     }
   720|     internal sealed class SecuredConnectHandler
   721|     {
   722|         private readonly ManagementScope scope;
   723|         internal SecuredConnectHandler(ManagementScope theScope)
   724|         {
   725|             this.scope = theScope;
   726|         }
   727|         internal int ConnectNSecureIWbemServices(string path, ref IWbemServices pServices)
   728|         {
   729|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   730|             if (null != scope)
   731|             {
   732|                 bool needToReset = false;
   733|                 IntPtr handle = IntPtr.Zero;
   734|                 try
   735|                 {
   736|                     if (scope.Options.EnablePrivileges && !CompatSwitches.AllowIManagementObjectQI)
   737|                     {
   738|                         WmiNetUtilsHelper.SetSecurity_f(ref needToReset, ref handle);
   739|                     }
   740|                     IntPtr password = scope.Options.GetPassword();
   741|                     status = WmiNetUtilsHelper.ConnectServerWmi_f(
   742|                         path,
   743|                         scope.Options.Username,
   744|                         password,
   745|                         scope.Options.Locale,
   746|                         scope.Options.Flags,
   747|                         scope.Options.Authority,
   748|                         scope.Options.GetContext(),
   749|                         out pServices,
   750|                         (int)scope.Options.Impersonation,
   751|                         (int)scope.Options.Authentication);
   752|                     System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(password);
   753|                 }
   754|                 finally
   755|                 {
   756|                     if (needToReset)
   757|                     {
   758|                         needToReset = false;
   759|                         WmiNetUtilsHelper.ResetSecurity_f(handle);
   760|                     }
   761|                 }
   762|             }
   763|             return status;
   764|         }
   765|     }
   766|     internal sealed class SecuredIWbemServicesHandler
   767|     {
   768|         private readonly IWbemServices pWbemServiecsSecurityHelper;
   769|         private readonly ManagementScope scope;
   770|         internal SecuredIWbemServicesHandler(ManagementScope theScope, IWbemServices pWbemServiecs)
   771|         {
   772|             this.scope = theScope;
   773|             pWbemServiecsSecurityHelper = pWbemServiecs;
   774|         }
   775|         internal int OpenNamespace_(string strNamespace, int lFlags, ref IWbemServices ppWorkingNamespace, IntPtr ppCallResult)
   776|         {
   777|             int status = (int)tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED;
   778|             return status;
   779|         }
   780|         internal int CancelAsyncCall_(IWbemObjectSink pSink)
   781|         {
   782|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   783|             status = pWbemServiecsSecurityHelper.CancelAsyncCall_(pSink);
   784|             return status;
   785|         }
   786|         internal int QueryObjectSink_(int lFlags, ref IWbemObjectSink ppResponseHandler)
   787|         {
   788|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   789|             status = pWbemServiecsSecurityHelper.QueryObjectSink_(lFlags, out ppResponseHandler);
   790|             return status;
   791|         }
   792|         internal int GetObject_(string strObjectPath, int lFlags, IWbemContext pCtx, ref IWbemClassObjectFreeThreaded ppObject, IntPtr ppCallResult)
   793|         {
   794|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   795|             status = pWbemServiecsSecurityHelper.GetObject_(strObjectPath, lFlags, pCtx, out ppObject, ppCallResult);
   796|             return status;
   797|         }
   798|         internal int GetObjectAsync_(string strObjectPath, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
   799|         {
   800|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   801|             status = pWbemServiecsSecurityHelper.GetObjectAsync_(strObjectPath, lFlags, pCtx, pResponseHandler);
   802|             return status;
   803|         }
   804|         internal int PutClass_(IWbemClassObjectFreeThreaded pObject, int lFlags, IWbemContext pCtx, IntPtr ppCallResult)
   805|         {
   806|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   807|             if (null != scope)
   808|             {
   809|                 IntPtr password = scope.Options.GetPassword();
   810|                 status = WmiNetUtilsHelper.PutClassWmi_f(pObject,
   811|                     lFlags,
   812|                     pCtx,
   813|                     ppCallResult,
   814|                     (int)scope.Options.Authentication,
   815|                     (int)scope.Options.Impersonation,
   816|                     pWbemServiecsSecurityHelper,
   817|                     scope.Options.Username,
   818|                     password,
   819|                     scope.Options.Authority);
   820|                 System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(password);
   821|             }
   822|             return status;
   823|         }
   824|         internal int PutClassAsync_(IWbemClassObjectFreeThreaded pObject, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
   825|         {
   826|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   827|             status = pWbemServiecsSecurityHelper.PutClassAsync_(pObject, lFlags, pCtx, pResponseHandler);
   828|             return status;
   829|         }
   830|         internal int DeleteClass_(string strClass, int lFlags, IWbemContext pCtx, IntPtr ppCallResult)
   831|         {
   832|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   833|             status = pWbemServiecsSecurityHelper.DeleteClass_(strClass, lFlags, pCtx, ppCallResult);
   834|             return status;
   835|         }
   836|         internal int DeleteClassAsync_(string strClass, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
   837|         {
   838|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   839|             status = pWbemServiecsSecurityHelper.DeleteClassAsync_(strClass, lFlags, pCtx, pResponseHandler);
   840|             return status;
   841|         }
   842|         internal int CreateClassEnum_(string strSuperClass, int lFlags, IWbemContext pCtx, ref IEnumWbemClassObject ppEnum)
   843|         {
   844|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   845|             if (null != scope)
   846|             {
   847|                 IntPtr password = scope.Options.GetPassword();
   848|                 status = WmiNetUtilsHelper.CreateClassEnumWmi_f(strSuperClass,
   849|                     lFlags,
   850|                     pCtx,
   851|                     out ppEnum,
   852|                     (int)scope.Options.Authentication,
   853|                     (int)scope.Options.Impersonation,
   854|                     pWbemServiecsSecurityHelper,
   855|                     scope.Options.Username,
   856|                     password,
   857|                     scope.Options.Authority);
   858|                 System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(password);
   859|             }
   860|             return status;
   861|         }
   862|         internal int CreateClassEnumAsync_(string strSuperClass, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
   863|         {
   864|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   865|             status = pWbemServiecsSecurityHelper.CreateClassEnumAsync_(strSuperClass, lFlags, pCtx, pResponseHandler);
   866|             return status;
   867|         }
   868|         internal int PutInstance_(IWbemClassObjectFreeThreaded pInst, int lFlags, IWbemContext pCtx, IntPtr ppCallResult)
   869|         {
   870|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   871|             if (null != scope)
   872|             {
   873|                 IntPtr password = scope.Options.GetPassword();
   874|                 status = WmiNetUtilsHelper.PutInstanceWmi_f(pInst,
   875|                     lFlags,
   876|                     pCtx,
   877|                     ppCallResult,
   878|                     (int)scope.Options.Authentication,
   879|                     (int)scope.Options.Impersonation,
   880|                     pWbemServiecsSecurityHelper,
   881|                     scope.Options.Username,
   882|                     password,
   883|                     scope.Options.Authority);
   884|                 System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(password);
   885|             }
   886|             return status;
   887|         }
   888|         internal int PutInstanceAsync_(IWbemClassObjectFreeThreaded pInst, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
   889|         {
   890|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   891|             status = pWbemServiecsSecurityHelper.PutInstanceAsync_(pInst, lFlags, pCtx, pResponseHandler);
   892|             return status;
   893|         }
   894|         internal int DeleteInstance_(string strObjectPath, int lFlags, IWbemContext pCtx, IntPtr ppCallResult)
   895|         {
   896|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   897|             status = pWbemServiecsSecurityHelper.DeleteInstance_(strObjectPath, lFlags, pCtx, ppCallResult);
   898|             return status;
   899|         }
   900|         internal int DeleteInstanceAsync_(string strObjectPath, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
   901|         {
   902|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   903|             status = pWbemServiecsSecurityHelper.DeleteInstanceAsync_(strObjectPath, lFlags, pCtx, pResponseHandler);
   904|             return status;
   905|         }
   906|         internal int CreateInstanceEnum_(string strFilter, int lFlags, IWbemContext pCtx, ref IEnumWbemClassObject ppEnum)
   907|         {
   908|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   909|             if (null != scope)
   910|             {
   911|                 IntPtr password = scope.Options.GetPassword();
   912|                 status = WmiNetUtilsHelper.CreateInstanceEnumWmi_f(strFilter,
   913|                     lFlags,
   914|                     pCtx,
   915|                     out ppEnum,
   916|                     (int)scope.Options.Authentication,
   917|                     (int)scope.Options.Impersonation,
   918|                     pWbemServiecsSecurityHelper,
   919|                     scope.Options.Username,
   920|                     password,
   921|                     scope.Options.Authority);
   922|                 System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(password);
   923|             }
   924|             return status;
   925|         }
   926|         internal int CreateInstanceEnumAsync_(string strFilter, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
   927|         {
   928|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   929|             status = pWbemServiecsSecurityHelper.CreateInstanceEnumAsync_(strFilter, lFlags, pCtx, pResponseHandler);
   930|             return status;
   931|         }
   932|         internal int ExecQuery_(string strQueryLanguage, string strQuery, int lFlags, IWbemContext pCtx, ref IEnumWbemClassObject ppEnum)
   933|         {
   934|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   935|             if (null != scope)
   936|             {
   937|                 IntPtr password = scope.Options.GetPassword();
   938|                 status = WmiNetUtilsHelper.ExecQueryWmi_f(strQueryLanguage,
   939|                     strQuery,
   940|                     lFlags,
   941|                     pCtx,
   942|                     out ppEnum,
   943|                     (int)scope.Options.Authentication,
   944|                     (int)scope.Options.Impersonation,
   945|                     pWbemServiecsSecurityHelper,
   946|                     scope.Options.Username,
   947|                     password,
   948|                     scope.Options.Authority);
   949|                 System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(password);
   950|             }
   951|             return status;
   952|         }
   953|         internal int ExecQueryAsync_(string strQueryLanguage, string strQuery, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
   954|         {
   955|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   956|             status = pWbemServiecsSecurityHelper.ExecQueryAsync_(strQueryLanguage, strQuery, lFlags, pCtx, pResponseHandler);
   957|             return status;
   958|         }
   959|         internal int ExecNotificationQuery_(string strQueryLanguage, string strQuery, int lFlags, IWbemContext pCtx, ref IEnumWbemClassObject ppEnum)
   960|         {
   961|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   962|             if (null != scope)
   963|             {
   964|                 IntPtr password = scope.Options.GetPassword();
   965|                 status = WmiNetUtilsHelper.ExecNotificationQueryWmi_f(strQueryLanguage,
   966|                     strQuery,
   967|                     lFlags,
   968|                     pCtx,
   969|                     out ppEnum,
   970|                     (int)scope.Options.Authentication,
   971|                     (int)scope.Options.Impersonation,
   972|                     pWbemServiecsSecurityHelper,
   973|                     scope.Options.Username,
   974|                     password,
   975|                     scope.Options.Authority);
   976|                 System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(password);
   977|             }
   978|             return status;
   979|         }
   980|         internal int ExecNotificationQueryAsync_(string strQueryLanguage, string strQuery, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
   981|         {
   982|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   983|             status = pWbemServiecsSecurityHelper.ExecNotificationQueryAsync_(strQueryLanguage, strQuery, lFlags, pCtx, pResponseHandler);
   984|             return status;
   985|         }
   986|         internal int ExecMethod_(string strObjectPath, string strMethodName, int lFlags, IWbemContext pCtx, IWbemClassObjectFreeThreaded pInParams, ref IWbemClassObjectFreeThreaded ppOutParams, IntPtr ppCallResult)
   987|         {
   988|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   989|             status = pWbemServiecsSecurityHelper.ExecMethod_(strObjectPath, strMethodName, lFlags, pCtx, pInParams, out ppOutParams, ppCallResult);
   990|             return status;
   991|         }
   992|         internal int ExecMethodAsync_(string strObjectPath, string strMethodName, int lFlags, IWbemContext pCtx, IWbemClassObjectFreeThreaded pInParams, IWbemObjectSink pResponseHandler)
   993|         {
   994|             int status = (int)tag_WBEMSTATUS.WBEM_E_FAILED;
   995|             status = pWbemServiecsSecurityHelper.ExecMethodAsync_(strObjectPath, strMethodName, lFlags, pCtx, pInParams, pResponseHandler);
   996|             return status;
   997|         }
   998|     }
   999|     internal sealed class SecurityHandler
  1000|     {
  1001|         private bool needToReset;
  1002|         private readonly IntPtr handle;
  1003|         private readonly ManagementScope scope;
  1004|         internal SecurityHandler(ManagementScope theScope)
  1005|         {
  1006|             this.scope = theScope;
  1007|             if (null != scope)
  1008|             {
  1009|                 if (scope.Options.EnablePrivileges)
  1010|                 {
  1011|                     WmiNetUtilsHelper.SetSecurity_f(ref needToReset, ref handle);
  1012|                 }
  1013|             }
  1014|         }
  1015|         internal void Reset()
  1016|         {
  1017|             if (needToReset)
  1018|             {
  1019|                 needToReset = false;
  1020|                 if (null != scope)
  1021|                 {
  1022|                     WmiNetUtilsHelper.ResetSecurity_f(handle);
  1023|                 }
  1024|             }
  1025|         }
  1026|         internal void Secure(IWbemServices services)
  1027|         {
  1028|             if (null != scope)
  1029|             {
  1030|                 IntPtr password = scope.Options.GetPassword();
  1031|                 int status = WmiNetUtilsHelper.BlessIWbemServices_f
  1032|                     (
  1033|                     services,
  1034|                     scope.Options.Username,
  1035|                     password,
  1036|                     scope.Options.Authority,
  1037|                     (int)scope.Options.Impersonation,
  1038|                     (int)scope.Options.Authentication
  1039|                     );
  1040|                 System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(password);
  1041|                 if (status < 0)
  1042|                 {
  1043|                     Marshal.ThrowExceptionForHR(status, WmiNetUtilsHelper.GetErrorInfo_f());
  1044|                 }
  1045|             }
  1046|         }
  1047|         internal void SecureIUnknown(object unknown)
  1048|         {
  1049|             if (null != scope)
  1050|             {
  1051|                 IntPtr password = scope.Options.GetPassword();
  1052|                 int status = WmiNetUtilsHelper.BlessIWbemServicesObject_f
  1053|                     (
  1054|                     unknown,
  1055|                     scope.Options.Username,
  1056|                     password,
  1057|                     scope.Options.Authority,
  1058|                     (int)scope.Options.Impersonation,
  1059|                     (int)scope.Options.Authentication
  1060|                     );
  1061|                 System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(password);
  1062|                 if (status < 0)
  1063|                 {
  1064|                     Marshal.ThrowExceptionForHR(status, WmiNetUtilsHelper.GetErrorInfo_f());
  1065|                 }
  1066|             }
  1067|         }
  1068|     } //SecurityHandler
  1069|     internal sealed class ManagementScopeConverter : ExpandableObjectConverter
  1070|     {
  1071|         public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
  1072|         {
  1073|             if ((sourceType == typeof(ManagementScope)))
  1074|             {
  1075|                 return true;
  1076|             }
  1077|             return base.CanConvertFrom(context, sourceType);
  1078|         }
  1079|         public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
  1080|         {
  1081|             if ((destinationType == typeof(InstanceDescriptor)))
  1082|             {
  1083|                 return true;
  1084|             }
  1085|             return base.CanConvertTo(context, destinationType);
  1086|         }
  1087|         public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
  1088|         {
  1089|             if (destinationType == null)
  1090|             {
  1091|                 throw new ArgumentNullException(nameof(destinationType));
  1092|             }
  1093|             if (value is ManagementScope && destinationType == typeof(InstanceDescriptor))
  1094|             {
  1095|                 ManagementScope obj = ((ManagementScope)(value));
  1096|                 ConstructorInfo ctor = typeof(ManagementScope).GetConstructor(new Type[] { typeof(string) });
  1097|                 if (ctor != null)
  1098|                 {
  1099|                     return new InstanceDescriptor(ctor, new object[] { obj.Path.Path });
  1100|                 }
  1101|             }
  1102|             return base.ConvertTo(context, culture, value, destinationType);
  1103|         }
  1104|     }
  1105| }


# ====================================================================
# FILE: src/libraries/System.Net.Quic/src/System/Net/Quic/Internal/MsQuicApi.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-158 ---
     1| using System.Diagnostics;
     2| using System.Diagnostics.CodeAnalysis;
     3| using System.Runtime.InteropServices;
     4| using Microsoft.Quic;
     5| using static Microsoft.Quic.MsQuic;
     6| #if TARGET_WINDOWS
     7| using Microsoft.Win32;
     8| #endif
     9| namespace System.Net.Quic;
    10| internal sealed unsafe partial class MsQuicApi
    11| {
    12|     private static readonly Version MinWindowsVersion = new Version(10, 0, 20145, 1000);
    13|     private static readonly Version MinMsQuicVersion = new Version(2, 1);
    14|     private static readonly delegate* unmanaged[Cdecl]<uint, QUIC_API_TABLE**, int> MsQuicOpenVersion;
    15|     private static readonly delegate* unmanaged[Cdecl]<QUIC_API_TABLE*, void> MsQuicClose;
    16|     public MsQuicSafeHandle Registration { get; }
    17|     public QUIC_API_TABLE* ApiTable { get; }
    18|     [DynamicDependency(DynamicallyAccessedMemberTypes.PublicConstructors, typeof(MsQuicSafeHandle))]
    19|     [DynamicDependency(DynamicallyAccessedMemberTypes.PublicConstructors, typeof(MsQuicContextSafeHandle))]
    20|     private MsQuicApi(QUIC_API_TABLE* apiTable)
    21|     {
    22|         ApiTable = apiTable;
    23|         fixed (byte* pAppName = "System.Net.Quic"u8)
    24|         {
    25|             var cfg = new QUIC_REGISTRATION_CONFIG
    26|             {
    27|                 AppName = (sbyte*)pAppName,
    28|                 ExecutionProfile = QUIC_EXECUTION_PROFILE.LOW_LATENCY
    29|             };
    30|             QUIC_HANDLE* handle;
    31|             ThrowHelper.ThrowIfMsQuicError(ApiTable->RegistrationOpen(&cfg, &handle), "RegistrationOpen failed");
    32|             Registration = new MsQuicSafeHandle(handle, apiTable->RegistrationClose, SafeHandleType.Registration);
    33|         }
    34|     }
    35|     private static readonly Lazy<MsQuicApi> s_api = new Lazy<MsQuicApi>(AllocateMsQuicApi);
    36|     internal static MsQuicApi Api => s_api.Value;
    37|     internal static bool IsQuicSupported { get; }
    38|     internal static bool UsesSChannelBackend { get; }
    39|     internal static bool Tls13ServerMayBeDisabled { get; }
    40|     internal static bool Tls13ClientMayBeDisabled { get; }
    41| #pragma warning disable CA1810 // Initialize all static fields in 'MsQuicApi' when those fields are declared and remove the explicit static constructor
    42|     static MsQuicApi()
    43|     {
    44|         bool loaded = false;
    45|         IntPtr msQuicHandle;
    46|         if (OperatingSystem.IsWindows())
    47|         {
    48|             loaded = NativeLibrary.TryLoad(Interop.Libraries.MsQuic, typeof(MsQuicApi).Assembly, DllImportSearchPath.AssemblyDirectory, out msQuicHandle);
    49|         }
    50|         else
    51|         {
    52|             loaded = NativeLibrary.TryLoad($"{Interop.Libraries.MsQuic}.{MinMsQuicVersion.Major}", typeof(MsQuicApi).Assembly, null, out msQuicHandle) ||
    53|                      NativeLibrary.TryLoad(Interop.Libraries.MsQuic, typeof(MsQuicApi).Assembly, null, out msQuicHandle);
    54|         }
    55|         if (!loaded)
    56|         {
    57|             return;
    58|         }
    59|         MsQuicOpenVersion = (delegate* unmanaged[Cdecl]<uint, QUIC_API_TABLE**, int>)NativeLibrary.GetExport(msQuicHandle, nameof(MsQuicOpenVersion));
    60|         MsQuicClose = (delegate* unmanaged[Cdecl]<QUIC_API_TABLE*, void>)NativeLibrary.GetExport(msQuicHandle, nameof(MsQuicClose));
    61|         if (!TryOpenMsQuic(out QUIC_API_TABLE* apiTable, out _))
    62|         {
    63|             return;
    64|         }
    65|         try
    66|         {
    67|             const int ArraySize = 4;
    68|             uint* libVersion = stackalloc uint[ArraySize];
    69|             uint size = (uint)ArraySize * sizeof(uint);
    70|             if (StatusFailed(apiTable->GetParam(null, QUIC_PARAM_GLOBAL_LIBRARY_VERSION, &size, libVersion)))
    71|             {
    72|                 return;
    73|             }
    74|             var version = new Version((int)libVersion[0], (int)libVersion[1], (int)libVersion[2], (int)libVersion[3]);
    75|             if (version < MinMsQuicVersion)
    76|             {
    77|                 if (NetEventSource.Log.IsEnabled())
    78|                 {
    79|                     NetEventSource.Info(null, $"Incompatible MsQuic library version '{version}', expecting at least '{MinMsQuicVersion}'");
    80|                 }
    81|                 return;
    82|             }
    83|             QUIC_TLS_PROVIDER provider = OperatingSystem.IsWindows() ? QUIC_TLS_PROVIDER.SCHANNEL : QUIC_TLS_PROVIDER.OPENSSL;
    84|             size = sizeof(QUIC_TLS_PROVIDER);
    85|             apiTable->GetParam(null, QUIC_PARAM_GLOBAL_TLS_PROVIDER, &size, &provider);
    86|             UsesSChannelBackend = provider == QUIC_TLS_PROVIDER.SCHANNEL;
    87|             if (UsesSChannelBackend)
    88|             {
    89|                 if (!IsWindowsVersionSupported())
    90|                 {
    91|                     if (NetEventSource.Log.IsEnabled())
    92|                     {
    93|                         NetEventSource.Info(null, $"Current Windows version ({Environment.OSVersion}) is not supported by QUIC. Minimal supported version is {MinWindowsVersion}");
    94|                     }
    95|                     return;
    96|                 }
    97|                 Tls13ServerMayBeDisabled = IsTls13Disabled(isServer: true);
    98|                 Tls13ClientMayBeDisabled = IsTls13Disabled(isServer: false);
    99|             }
   100|             IsQuicSupported = true;
   101|         }
   102|         finally
   103|         {
   104|             MsQuicClose(apiTable);
   105|         }
   106|     }
   107| #pragma warning restore CA1810
   108|     private static MsQuicApi AllocateMsQuicApi()
   109|     {
   110|         Debug.Assert(IsQuicSupported);
   111|         if (!TryOpenMsQuic(out QUIC_API_TABLE* apiTable, out int openStatus))
   112|         {
   113|             throw ThrowHelper.GetExceptionForMsQuicStatus(openStatus);
   114|         }
   115|         return new MsQuicApi(apiTable);
   116|     }
   117|     private static bool TryOpenMsQuic(out QUIC_API_TABLE* apiTable, out int openStatus)
   118|     {
   119|         Debug.Assert(MsQuicOpenVersion != null);
   120|         QUIC_API_TABLE* table = null;
   121|         openStatus = MsQuicOpenVersion((uint)MinMsQuicVersion.Major, &table);
   122|         if (StatusFailed(openStatus))
   123|         {
   124|             if (NetEventSource.Log.IsEnabled())
   125|             {
   126|                 NetEventSource.Info(null, $"MsQuicOpenVersion returned {openStatus} status code.");
   127|             }
   128|             apiTable = null;
   129|             return false;
   130|         }
   131|         apiTable = table;
   132|         return true;
   133|     }
   134|     private static bool IsWindowsVersionSupported() => OperatingSystem.IsWindowsVersionAtLeast(MinWindowsVersion.Major,
   135|         MinWindowsVersion.Minor, MinWindowsVersion.Build, MinWindowsVersion.Revision);
   136|     private static bool IsTls13Disabled(bool isServer)
   137|     {
   138| #if TARGET_WINDOWS
   139|         string SChannelTls13RegistryKey = isServer
   140|             ? @"SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.3\Server"
   141|             : @"SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.3\Client";
   142|         using var regKey = Registry.LocalMachine.OpenSubKey(SChannelTls13RegistryKey);
   143|         if (regKey is null)
   144|         {
   145|             return false;
   146|         }
   147|         if (regKey.GetValue("Enabled") is int enabled && enabled == 0)
   148|         {
   149|             return true;
   150|         }
   151|         if (regKey.GetValue("DisabledByDefault") is int disabled && disabled == 1)
   152|         {
   153|             return true;
   154|         }
   155| #endif
   156|         return false;
   157|     }
   158| }


# ====================================================================
# FILE: src/libraries/System.Net.Security/src/System/Net/Security/SslStreamCertificateContext.Linux.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-224 ---
     1| using Microsoft.Win32.SafeHandles;
     2| using System.Buffers;
     3| using System.Collections.Concurrent;
     4| using System.Collections.Generic;
     5| using System.Diagnostics;
     6| using System.Security.Authentication;
     7| using System.Security.Cryptography;
     8| using System.Security.Cryptography.X509Certificates;
     9| using System.Text;
    10| using System.Threading.Tasks;
    11| namespace System.Net.Security
    12| {
    13|     public partial class SslStreamCertificateContext
    14|     {
    15|         private const bool TrimRootCertificate = true;
    16|         internal readonly ConcurrentDictionary<SslProtocols, SafeSslContextHandle> SslContexts;
    17|         internal readonly SafeX509Handle CertificateHandle;
    18|         internal readonly SafeEvpPKeyHandle KeyHandle;
    19|         private bool _staplingForbidden;
    20|         private byte[]? _ocspResponse;
    21|         private DateTimeOffset _ocspExpiration;
    22|         private DateTimeOffset _nextDownload;
    23|         private Task<byte[]?>? _pendingDownload;
    24|         private List<string>? _ocspUrls;
    25|         private X509Certificate2? _ca;
    26|         private SslStreamCertificateContext(X509Certificate2 target, X509Certificate2[] intermediates, SslCertificateTrust? trust)
    27|         {
    28|             Certificate = target;
    29|             IntermediateCertificates = intermediates;
    30|             Trust = trust;
    31|             SslContexts = new ConcurrentDictionary<SslProtocols, SafeSslContextHandle>();
    32|             using (RSAOpenSsl? rsa = (RSAOpenSsl?)target.GetRSAPrivateKey())
    33|             {
    34|                 if (rsa != null)
    35|                 {
    36|                     KeyHandle = rsa.DuplicateKeyHandle();
    37|                 }
    38|             }
    39|             if (KeyHandle == null)
    40|             {
    41|                 using (ECDsaOpenSsl? ecdsa = (ECDsaOpenSsl?)target.GetECDsaPrivateKey())
    42|                 {
    43|                     if (ecdsa != null)
    44|                     {
    45|                         KeyHandle = ecdsa.DuplicateKeyHandle();
    46|                     }
    47|                 }
    48|                 if (KeyHandle== null)
    49|                 {
    50|                     throw new NotSupportedException(SR.net_ssl_io_no_server_cert);
    51|                 }
    52|             }
    53|             CertificateHandle = Interop.Crypto.X509UpRef(target.Handle);
    54|         }
    55|         internal static SslStreamCertificateContext Create(X509Certificate2 target) =>
    56|             Create(target, null, offline: false, trust: null, noOcspFetch: true);
    57|         internal bool OcspStaplingAvailable => _ocspUrls is not null;
    58|         partial void SetNoOcspFetch(bool noOcspFetch)
    59|         {
    60|             _staplingForbidden = noOcspFetch;
    61|         }
    62|         partial void AddRootCertificate(X509Certificate2? rootCertificate, ref bool transferredOwnership)
    63|         {
    64|             if (IntermediateCertificates.Length == 0)
    65|             {
    66|                 _ca = rootCertificate;
    67|                 transferredOwnership = true;
    68|             }
    69|             else
    70|             {
    71|                 _ca = IntermediateCertificates[0];
    72|             }
    73|             if (!_staplingForbidden)
    74|             {
    75|                 GetOcspResponseAsync().AsTask();
    76|             }
    77|         }
    78|         internal byte[]? GetOcspResponseNoWaiting()
    79|         {
    80|             try
    81|             {
    82|                 ValueTask<byte[]?> task = GetOcspResponseAsync();
    83|                 if (task.IsCompletedSuccessfully)
    84|                 {
    85|                     return task.Result;
    86|                 }
    87|             }
    88|             catch
    89|             {
    90|             }
    91|             return null;
    92|         }
    93|         internal ValueTask<byte[]?> GetOcspResponseAsync()
    94|         {
    95|             if (_staplingForbidden)
    96|             {
    97|                 return ValueTask.FromResult((byte[]?)null);
    98|             }
    99|             DateTimeOffset now = DateTimeOffset.UtcNow;
   100|             if (now > _ocspExpiration)
   101|             {
   102|                 return DownloadOcspAsync();
   103|             }
   104|             if (now > _nextDownload)
   105|             {
   106| #pragma warning disable CA2012 // Use ValueTasks correctly
   107|                 DownloadOcspAsync();
   108| #pragma warning restore CA2012 // Use ValueTasks correctly
   109|             }
   110|             return ValueTask.FromResult(_ocspResponse);
   111|         }
   112|         private ValueTask<byte[]?> DownloadOcspAsync()
   113|         {
   114|             Task<byte[]?>? pending = _pendingDownload;
   115|             if (pending is not null && !pending.IsFaulted)
   116|             {
   117|                 return new ValueTask<byte[]?>(pending);
   118|             }
   119|             if (_ocspUrls is null && _ca is not null)
   120|             {
   121|                 foreach (X509Extension ext in Certificate.Extensions)
   122|                 {
   123|                     if (ext is X509AuthorityInformationAccessExtension aia)
   124|                     {
   125|                         foreach (string entry in aia.EnumerateOcspUris())
   126|                         {
   127|                             if (Uri.TryCreate(entry, UriKind.Absolute, out Uri? uri))
   128|                             {
   129|                                 if (uri.Scheme == UriScheme.Http)
   130|                                 {
   131|                                     (_ocspUrls ??= new List<string>()).Add(entry);
   132|                                 }
   133|                             }
   134|                         }
   135|                         break;
   136|                     }
   137|                 }
   138|             }
   139|             if (_ocspUrls is null)
   140|             {
   141|                 _ocspExpiration = _nextDownload = DateTimeOffset.MaxValue;
   142|                 return new ValueTask<byte[]?>((byte[]?)null);
   143|             }
   144|             lock (SslContexts)
   145|             {
   146|                 pending = _pendingDownload;
   147|                 if (pending is null || pending.IsFaulted)
   148|                 {
   149|                     _pendingDownload = pending = FetchOcspAsync();
   150|                 }
   151|             }
   152|             return new ValueTask<byte[]?>(pending);
   153|         }
   154|         private async Task<byte[]?> FetchOcspAsync()
   155|         {
   156|             X509Certificate2? caCert = _ca;
   157|             Debug.Assert(_ocspUrls is not null);
   158|             Debug.Assert(_ocspUrls.Count > 0);
   159|             Debug.Assert(caCert is not null);
   160|             IntPtr subject = Certificate.Handle;
   161|             IntPtr issuer = caCert.Handle;
   162|             Debug.Assert(subject != 0);
   163|             Debug.Assert(issuer != 0);
   164|             if (subject == 0 || issuer == 0)
   165|             {
   166|                 _staplingForbidden = true;
   167|                 return null;
   168|             }
   169|             using (SafeOcspRequestHandle ocspRequest = Interop.Crypto.X509BuildOcspRequest(subject, issuer))
   170|             {
   171|                 byte[] rentedBytes = ArrayPool<byte>.Shared.Rent(Interop.Crypto.GetOcspRequestDerSize(ocspRequest));
   172|                 int encodingSize = Interop.Crypto.EncodeOcspRequest(ocspRequest, rentedBytes);
   173|                 ArraySegment<byte> encoded = new ArraySegment<byte>(rentedBytes, 0, encodingSize);
   174|                 ArraySegment<char> rentedChars = UrlBase64Encoding.RentEncode(encoded);
   175|                 byte[]? ret = null;
   176|                 for (int i = 0; i < _ocspUrls.Count; i++)
   177|                 {
   178|                     string url = MakeUrl(_ocspUrls[i], rentedChars);
   179|                     ret = await System.Net.Http.X509ResourceClient.DownloadAssetAsync(url, TimeSpan.MaxValue).ConfigureAwait(false);
   180|                     if (ret is not null)
   181|                     {
   182|                         if (!Interop.Crypto.X509DecodeOcspToExpiration(ret, ocspRequest, subject, issuer, out DateTimeOffset expiration))
   183|                         {
   184|                             continue;
   185|                         }
   186|                         if (i != 0)
   187|                         {
   188|                             string tmp = _ocspUrls[0];
   189|                             _ocspUrls[0] = _ocspUrls[i];
   190|                             _ocspUrls[i] = tmp;
   191|                         }
   192|                         DateTimeOffset nextCheckA = DateTimeOffset.UtcNow.AddDays(1);
   193|                         DateTimeOffset nextCheckB = expiration.AddMinutes(-5);
   194|                         _ocspResponse = ret;
   195|                         _ocspExpiration = expiration;
   196|                         _nextDownload = nextCheckA < nextCheckB ? nextCheckA : nextCheckB;
   197|                         _pendingDownload = null;
   198|                         break;
   199|                     }
   200|                 }
   201|                 ArrayPool<byte>.Shared.Return(rentedBytes);
   202|                 ArrayPool<char>.Shared.Return(rentedChars.Array!);
   203|                 GC.KeepAlive(Certificate);
   204|                 GC.KeepAlive(caCert);
   205|                 return ret;
   206|             }
   207|         }
   208|         private static string MakeUrl(string baseUri, ArraySegment<char> encodedRequest)
   209|         {
   210|             Debug.Assert(baseUri.Length > 0);
   211|             Debug.Assert(encodedRequest.Count > 0);
   212|             string uriString;
   213|             if (baseUri.EndsWith('/'))
   214|             {
   215|                 uriString = string.Concat(baseUri, encodedRequest.AsSpan());
   216|             }
   217|             else
   218|             {
   219|                 uriString = string.Concat(baseUri, "/", encodedRequest.AsSpan());
   220|             }
   221|             return uriString;
   222|         }
   223|     }
   224| }


# ====================================================================
# FILE: src/libraries/System.Net.Security/src/System/Net/Security/SslStreamCertificateContext.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-103 ---
     1| using System.ComponentModel;
     2| using System.Security.Cryptography.X509Certificates;
     3| namespace System.Net.Security
     4| {
     5|     public partial class SslStreamCertificateContext
     6|     {
     7|         public readonly X509Certificate2 Certificate;
     8|         public readonly X509Certificate2[] IntermediateCertificates;
     9|         internal readonly SslCertificateTrust? Trust;
    10|         [EditorBrowsable(EditorBrowsableState.Never)]
    11|         public static SslStreamCertificateContext Create(X509Certificate2 target, X509Certificate2Collection? additionalCertificates, bool offline)
    12|         {
    13|             return Create(target, additionalCertificates, offline, null);
    14|         }
    15|         public static SslStreamCertificateContext Create(X509Certificate2 target, X509Certificate2Collection? additionalCertificates, bool offline = false, SslCertificateTrust? trust = null)
    16|         {
    17|             return Create(target, additionalCertificates, offline, trust, noOcspFetch: false);
    18|         }
    19|         internal static SslStreamCertificateContext Create(
    20|             X509Certificate2 target,
    21|             X509Certificate2Collection? additionalCertificates,
    22|             bool offline,
    23|             SslCertificateTrust? trust,
    24|             bool noOcspFetch)
    25|         {
    26|             if (!target.HasPrivateKey)
    27|             {
    28|                 throw new NotSupportedException(SR.net_ssl_io_no_server_cert);
    29|             }
    30|             X509Certificate2[] intermediates = Array.Empty<X509Certificate2>();
    31|             X509Certificate2? root = null;
    32|             using (X509Chain chain = new X509Chain())
    33|             {
    34|                 if (additionalCertificates != null)
    35|                 {
    36|                     foreach (X509Certificate cert in additionalCertificates)
    37|                     {
    38|                         chain.ChainPolicy.ExtraStore.Add(cert);
    39|                     }
    40|                 }
    41|                 chain.ChainPolicy.VerificationFlags = X509VerificationFlags.AllFlags;
    42|                 chain.ChainPolicy.RevocationMode = X509RevocationMode.NoCheck;
    43|                 chain.ChainPolicy.DisableCertificateDownloads = offline;
    44|                 bool chainStatus = chain.Build(target);
    45|                 if (!chainStatus && NetEventSource.Log.IsEnabled())
    46|                 {
    47|                     NetEventSource.Error(null, $"Failed to build chain for {target.Subject}");
    48|                 }
    49|                 int count = chain.ChainElements.Count - 1;
    50|                 if (count >= 0)
    51|                 {
    52| #pragma warning disable 0162 // Disable unreachable code warning. TrimRootCertificate is const bool = false on some platforms
    53|                     if (TrimRootCertificate)
    54|                     {
    55|                         count--;
    56|                         root = chain.ChainElements[chain.ChainElements.Count - 1].Certificate;
    57|                         foreach (X509ChainStatus status in chain.ChainStatus)
    58|                         {
    59|                             if (status.Status.HasFlag(X509ChainStatusFlags.PartialChain))
    60|                             {
    61|                                 count++;
    62|                                 root = null;
    63|                                 break;
    64|                             }
    65|                         }
    66|                     }
    67| #pragma warning restore 0162
    68|                     if (count > 0 && chain.ChainElements.Count > 1)
    69|                     {
    70|                         intermediates = new X509Certificate2[count];
    71|                         for (int i = 0; i < count; i++)
    72|                         {
    73|                             intermediates[i] = chain.ChainElements[i + 1].Certificate;
    74|                         }
    75|                     }
    76|                     chain.ChainElements[0].Certificate.Dispose();
    77|                     int stopDisposingChainPosition = root is null ?
    78|                         chain.ChainElements.Count :
    79|                         chain.ChainElements.Count - 1;
    80|                     for (int i = count + 1; i < stopDisposingChainPosition; i++)
    81|                     {
    82|                         chain.ChainElements[i].Certificate.Dispose();
    83|                     }
    84|                 }
    85|             }
    86|             SslStreamCertificateContext ctx = new SslStreamCertificateContext(target, intermediates, trust);
    87|             ctx.SetNoOcspFetch(offline || noOcspFetch);
    88|             bool transferredOwnership = false;
    89|             ctx.AddRootCertificate(root, ref transferredOwnership);
    90|             if (!transferredOwnership)
    91|             {
    92|                 root?.Dispose();
    93|             }
    94|             return ctx;
    95|         }
    96|         partial void AddRootCertificate(X509Certificate2? rootCertificate, ref bool transferredOwnership);
    97|         partial void SetNoOcspFetch(bool noOcspFetch);
    98|         internal SslStreamCertificateContext Duplicate()
    99|         {
   100|             return new SslStreamCertificateContext(new X509Certificate2(Certificate), IntermediateCertificates, Trust);
   101|         }
   102|     }
   103| }


# ====================================================================
# FILE: src/libraries/System.Private.CoreLib/src/System/Resources/ResourceReader.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-882 ---
     1| using System.Buffers.Binary;
     2| using System.Collections;
     3| using System.Collections.Generic;
     4| using System.Diagnostics;
     5| using System.Diagnostics.CodeAnalysis;
     6| using System.IO;
     7| using System.Runtime.CompilerServices;
     8| using System.Text;
     9| using System.Threading;
    10| namespace System.Resources
    11| #if RESOURCES_EXTENSIONS
    12|     .Extensions
    13| #endif
    14| {
    15| #pragma warning disable IDE0065
    16| #if RESOURCES_EXTENSIONS
    17|     using ResourceReader = DeserializingResourceReader;
    18| #endif
    19| #pragma warning restore IDE0065
    20|     internal readonly struct ResourceLocator
    21|     {
    22|         internal ResourceLocator(int dataPos, object? value)
    23|         {
    24|             DataPosition = dataPos;
    25|             Value = value;
    26|         }
    27|         internal int DataPosition { get; }
    28|         internal object? Value { get; }
    29|         internal static bool CanCache(ResourceTypeCode value)
    30|         {
    31|             Debug.Assert(value >= 0, "negative ResourceTypeCode.  What?");
    32|             return value <= ResourceTypeCode.LastPrimitive;
    33|         }
    34|     }
    35|     public sealed partial class
    36| #if RESOURCES_EXTENSIONS
    37|         DeserializingResourceReader
    38| #else
    39|         ResourceReader
    40| #endif
    41|         : IResourceReader
    42|     {
    43|         private const int DefaultFileStreamBufferSize = 4096;
    44|         private BinaryReader _store;
    45|         internal Dictionary<string, ResourceLocator>? _resCache;
    46|         private long _nameSectionOffset;  // Offset to name section of file.
    47|         private long _dataSectionOffset;  // Offset to Data section of file.
    48|         private int[]? _nameHashes;    // hash values for all names.
    49|         private unsafe int* _nameHashesPtr;  // In case we're using UnmanagedMemoryStream
    50|         private int[]? _namePositions; // relative locations of names
    51|         private unsafe int* _namePositionsPtr;  // If we're using UnmanagedMemoryStream
    52|         private Type?[] _typeTable;    // Lazy array of Types for resource values.
    53|         private int[] _typeNamePositions;  // To delay initialize type table
    54|         private int _numResources;    // Num of resources files, in case arrays aren't allocated.
    55|         private UnmanagedMemoryStream? _ums;
    56|         private int _version;
    57|         public
    58| #if RESOURCES_EXTENSIONS
    59|         DeserializingResourceReader(string fileName)
    60| #else
    61|         ResourceReader(string fileName)
    62| #endif
    63|         {
    64|             _resCache = new Dictionary<string, ResourceLocator>(FastResourceComparer.Default);
    65|             _store = new BinaryReader(new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read, DefaultFileStreamBufferSize, FileOptions.RandomAccess), Encoding.UTF8);
    66|             try
    67|             {
    68|                 ReadResources();
    69|             }
    70|             catch
    71|             {
    72|                 _store.Close(); // If we threw an exception, close the file.
    73|                 throw;
    74|             }
    75|         }
    76|         public
    77| #if RESOURCES_EXTENSIONS
    78|         DeserializingResourceReader(Stream stream)
    79| #else
    80|         ResourceReader(Stream stream)
    81| #endif
    82|         {
    83|             if (stream is null)
    84|             {
    85|                 throw new ArgumentNullException(nameof(stream));
    86|             }
    87|             if (!stream.CanRead)
    88|             {
    89|                 throw new ArgumentException(SR.Argument_StreamNotReadable);
    90|             }
    91|             _resCache = new Dictionary<string, ResourceLocator>(FastResourceComparer.Default);
    92|             _store = new BinaryReader(stream, Encoding.UTF8);
    93|             _ums = stream as UnmanagedMemoryStream;
    94|             ReadResources();
    95|         }
    96|         internal static bool AllowCustomResourceTypes { get; } = AppContext.TryGetSwitch("System.Resources.ResourceManager.AllowCustomResourceTypes", out bool allowReflection) ? allowReflection : true;
    97|         public void Close()
    98|         {
    99|             Dispose(true);
   100|         }
   101|         public void Dispose()
   102|         {
   103|             Close();
   104|         }
   105|         private unsafe void Dispose(bool disposing)
   106|         {
   107|             if (_store != null)
   108|             {
   109|                 _resCache = null;
   110|                 if (disposing)
   111|                 {
   112|                     BinaryReader copyOfStore = _store;
   113|                     _store = null!;
   114|                     copyOfStore?.Close();
   115|                 }
   116|                 _store = null!;
   117|                 _namePositions = null;
   118|                 _nameHashes = null;
   119|                 _ums = null;
   120|                 _namePositionsPtr = null;
   121|                 _nameHashesPtr = null;
   122|             }
   123|         }
   124|         private static unsafe int ReadUnalignedI4(int* p)
   125|         {
   126|             return BinaryPrimitives.ReadInt32LittleEndian(new ReadOnlySpan<byte>(p, sizeof(int)));
   127|         }
   128|         private void SkipString()
   129|         {
   130|             int stringLength = _store.Read7BitEncodedInt();
   131|             if (stringLength < 0)
   132|             {
   133|                 throw new BadImageFormatException(SR.BadImageFormat_NegativeStringLength);
   134|             }
   135|             _store.BaseStream.Seek(stringLength, SeekOrigin.Current);
   136|         }
   137|         private unsafe int GetNameHash(int index)
   138|         {
   139|             Debug.Assert(index >= 0 && index < _numResources, $"Bad index into hash array.  index: {index}");
   140|             if (_ums == null)
   141|             {
   142|                 Debug.Assert(_nameHashes != null && _nameHashesPtr == null, "Internal state mangled.");
   143|                 return _nameHashes[index];
   144|             }
   145|             else
   146|             {
   147|                 Debug.Assert(_nameHashes == null && _nameHashesPtr != null, "Internal state mangled.");
   148|                 return ReadUnalignedI4(&_nameHashesPtr[index]);
   149|             }
   150|         }
   151|         private unsafe int GetNamePosition(int index)
   152|         {
   153|             Debug.Assert(index >= 0 && index < _numResources, $"Bad index into name position array.  index: {index}");
   154|             int r;
   155|             if (_ums == null)
   156|             {
   157|                 Debug.Assert(_namePositions != null && _namePositionsPtr == null, "Internal state mangled.");
   158|                 r = _namePositions[index];
   159|             }
   160|             else
   161|             {
   162|                 Debug.Assert(_namePositions == null && _namePositionsPtr != null, "Internal state mangled.");
   163|                 r = ReadUnalignedI4(&_namePositionsPtr[index]);
   164|             }
   165|             if (r < 0 || r > _dataSectionOffset - _nameSectionOffset)
   166|             {
   167|                 throw new FormatException(SR.Format(SR.BadImageFormat_ResourcesNameInvalidOffset, r));
   168|             }
   169|             return r;
   170|         }
   171|         IEnumerator IEnumerable.GetEnumerator()
   172|         {
   173|             return GetEnumerator();
   174|         }
   175|         public IDictionaryEnumerator GetEnumerator()
   176|         {
   177|             if (_resCache == null)
   178|                 throw new InvalidOperationException(SR.ResourceReaderIsClosed);
   179|             return new ResourceEnumerator(this);
   180|         }
   181|         internal ResourceEnumerator GetEnumeratorInternal()
   182|         {
   183|             return new ResourceEnumerator(this);
   184|         }
   185|         internal int FindPosForResource(string name)
   186|         {
   187|             Debug.Assert(_store != null, "ResourceReader is closed!");
   188|             int hash = FastResourceComparer.HashFunction(name);
   189|             int lo = 0;
   190|             int hi = _numResources - 1;
   191|             int index = -1;
   192|             bool success = false;
   193|             while (lo <= hi)
   194|             {
   195|                 index = (lo + hi) >> 1;
   196|                 int currentHash = GetNameHash(index);
   197|                 int c;
   198|                 if (currentHash == hash)
   199|                     c = 0;
   200|                 else if (currentHash < hash)
   201|                     c = -1;
   202|                 else
   203|                     c = 1;
   204|                 if (c == 0)
   205|                 {
   206|                     success = true;
   207|                     break;
   208|                 }
   209|                 if (c < 0)
   210|                     lo = index + 1;
   211|                 else
   212|                     hi = index - 1;
   213|             }
   214|             if (!success)
   215|             {
   216|                 return -1;
   217|             }
   218|             if (lo != index)
   219|             {
   220|                 lo = index;
   221|                 while (lo > 0 && GetNameHash(lo - 1) == hash)
   222|                     lo--;
   223|             }
   224|             if (hi != index)
   225|             {
   226|                 hi = index;
   227|                 while (hi < _numResources - 1 && GetNameHash(hi + 1) == hash)
   228|                     hi++;
   229|             }
   230|             lock (this)
   231|             {
   232|                 for (int i = lo; i <= hi; i++)
   233|                 {
   234|                     _store.BaseStream.Seek(_nameSectionOffset + GetNamePosition(i), SeekOrigin.Begin);
   235|                     if (CompareStringEqualsName(name))
   236|                     {
   237|                         int dataPos = _store.ReadInt32();
   238|                         if (dataPos < 0 || dataPos >= _store.BaseStream.Length - _dataSectionOffset)
   239|                         {
   240|                             throw new FormatException(SR.Format(SR.BadImageFormat_ResourcesDataInvalidOffset, dataPos));
   241|                         }
   242|                         return dataPos;
   243|                     }
   244|                 }
   245|             }
   246|             return -1;
   247|         }
   248|         private unsafe bool CompareStringEqualsName(string name)
   249|         {
   250|             Debug.Assert(_store != null, "ResourceReader is closed!");
   251|             Debug.Assert(Monitor.IsEntered(this)); // uses _store
   252|             int byteLen = _store.Read7BitEncodedInt();
   253|             if (byteLen < 0)
   254|             {
   255|                 throw new BadImageFormatException(SR.BadImageFormat_NegativeStringLength);
   256|             }
   257|             if (_ums != null)
   258|             {
   259|                 byte* bytes = _ums.PositionPointer;
   260|                 _ums.Seek(byteLen, SeekOrigin.Current);
   261|                 if (_ums.Position > _ums.Length)
   262|                 {
   263|                     throw new BadImageFormatException(SR.BadImageFormat_ResourcesNameTooLong);
   264|                 }
   265|                 return FastResourceComparer.CompareOrdinal(bytes, byteLen, name) == 0;
   266|             }
   267|             else
   268|             {
   269|                 byte[] bytes = new byte[byteLen];
   270|                 int numBytesToRead = byteLen;
   271|                 while (numBytesToRead > 0)
   272|                 {
   273|                     int n = _store.Read(bytes, byteLen - numBytesToRead, numBytesToRead);
   274|                     if (n == 0)
   275|                         throw new BadImageFormatException(SR.BadImageFormat_ResourceNameCorrupted);
   276|                     numBytesToRead -= n;
   277|                 }
   278|                 return FastResourceComparer.CompareOrdinal(bytes, byteLen / 2, name) == 0;
   279|             }
   280|         }
   281|         private unsafe string AllocateStringForNameIndex(int index, out int dataOffset)
   282|         {
   283|             Debug.Assert(_store != null, "ResourceReader is closed!");
   284|             byte[] bytes;
   285|             int byteLen;
   286|             long nameVA = GetNamePosition(index);
   287|             lock (this)
   288|             {
   289|                 _store.BaseStream.Seek(nameVA + _nameSectionOffset, SeekOrigin.Begin);
   290|                 byteLen = _store.Read7BitEncodedInt();
   291|                 if (byteLen < 0)
   292|                 {
   293|                     throw new BadImageFormatException(SR.BadImageFormat_NegativeStringLength);
   294|                 }
   295|                 if (_ums != null)
   296|                 {
   297|                     if (_ums.Position > _ums.Length - byteLen)
   298|                         throw new BadImageFormatException(SR.Format(SR.BadImageFormat_ResourcesIndexTooLong, index));
   299|                     string? s = null;
   300|                     char* charPtr = (char*)_ums.PositionPointer;
   301|                     if (BitConverter.IsLittleEndian)
   302|                     {
   303|                         s = new string(charPtr, 0, byteLen / 2);
   304|                     }
   305|                     else
   306|                     {
   307|                         char[] arr = new char[byteLen / 2];
   308|                         for (int i = 0; i < arr.Length; i++)
   309|                         {
   310|                             arr[i] = (char)BinaryPrimitives.ReverseEndianness((short)charPtr[i]);
   311|                         }
   312|                         s = new string(arr);
   313|                     }
   314|                     _ums.Position += byteLen;
   315|                     dataOffset = _store.ReadInt32();
   316|                     if (dataOffset < 0 || dataOffset >= _store.BaseStream.Length - _dataSectionOffset)
   317|                     {
   318|                         throw new FormatException(SR.Format(SR.BadImageFormat_ResourcesDataInvalidOffset, dataOffset));
   319|                     }
   320|                     return s;
   321|                 }
   322|                 bytes = new byte[byteLen];
   323|                 int count = byteLen;
   324|                 while (count > 0)
   325|                 {
   326|                     int n = _store.Read(bytes, byteLen - count, count);
   327|                     if (n == 0)
   328|                         throw new EndOfStreamException(SR.Format(SR.BadImageFormat_ResourceNameCorrupted_NameIndex, index));
   329|                     count -= n;
   330|                 }
   331|                 dataOffset = _store.ReadInt32();
   332|                 if (dataOffset < 0 || dataOffset >= _store.BaseStream.Length - _dataSectionOffset)
   333|                 {
   334|                     throw new FormatException(SR.Format(SR.BadImageFormat_ResourcesDataInvalidOffset, dataOffset));
   335|                 }
   336|             }
   337|             return Encoding.Unicode.GetString(bytes, 0, byteLen);
   338|         }
   339|         private object? GetValueForNameIndex(int index)
   340|         {
   341|             Debug.Assert(_store != null, "ResourceReader is closed!");
   342|             long nameVA = GetNamePosition(index);
   343|             lock (this)
   344|             {
   345|                 _store.BaseStream.Seek(nameVA + _nameSectionOffset, SeekOrigin.Begin);
   346|                 SkipString();
   347|                 int dataPos = _store.ReadInt32();
   348|                 if (dataPos < 0 || dataPos >= _store.BaseStream.Length - _dataSectionOffset)
   349|                 {
   350|                     throw new FormatException(SR.Format(SR.BadImageFormat_ResourcesDataInvalidOffset, dataPos));
   351|                 }
   352|                 if (_version == 1)
   353|                     return LoadObjectV1(dataPos);
   354|                 else
   355|                     return LoadObjectV2(dataPos, out _);
   356|             }
   357|         }
   358|         internal string? LoadString(int pos)
   359|         {
   360|             Debug.Assert(_store != null, "ResourceReader is closed!");
   361|             lock (this)
   362|             {
   363|                 _store.BaseStream.Seek(_dataSectionOffset + pos, SeekOrigin.Begin);
   364|                 string? s = null;
   365|                 int typeIndex = _store.Read7BitEncodedInt();
   366|                 if (_version == 1)
   367|                 {
   368|                     if (typeIndex == -1)
   369|                         return null;
   370|                     if (FindType(typeIndex) != typeof(string))
   371|                         throw new InvalidOperationException(SR.Format(SR.InvalidOperation_ResourceNotString_Type, FindType(typeIndex).FullName));
   372|                     s = _store.ReadString();
   373|                 }
   374|                 else
   375|                 {
   376|                     ResourceTypeCode typeCode = (ResourceTypeCode)typeIndex;
   377|                     if (typeCode != ResourceTypeCode.String && typeCode != ResourceTypeCode.Null)
   378|                     {
   379|                         string? typeString;
   380|                         if (typeCode < ResourceTypeCode.StartOfUserTypes)
   381|                             typeString = typeCode.ToString();
   382|                         else
   383|                             typeString = FindType(typeCode - ResourceTypeCode.StartOfUserTypes).FullName;
   384|                         throw new InvalidOperationException(SR.Format(SR.InvalidOperation_ResourceNotString_Type, typeString));
   385|                     }
   386|                     if (typeCode == ResourceTypeCode.String) // ignore Null
   387|                         s = _store.ReadString();
   388|                 }
   389|                 return s;
   390|             }
   391|         }
   392|         internal object? LoadObject(int pos)
   393|         {
   394|             lock (this)
   395|             {
   396|                 return _version == 1 ? LoadObjectV1(pos) : LoadObjectV2(pos, out _);
   397|             }
   398|         }
   399|         internal object? LoadObject(int pos, out ResourceTypeCode typeCode)
   400|         {
   401|             lock (this)
   402|             {
   403|                 if (_version == 1)
   404|                 {
   405|                     object? o = LoadObjectV1(pos);
   406|                     typeCode = (o is string) ? ResourceTypeCode.String : ResourceTypeCode.StartOfUserTypes;
   407|                     return o;
   408|                 }
   409|                 return LoadObjectV2(pos, out typeCode);
   410|             }
   411|         }
   412|         private object? LoadObjectV1(int pos)
   413|         {
   414|             Debug.Assert(_store != null, "ResourceReader is closed!");
   415|             Debug.Assert(_version == 1, ".resources file was not a V1 .resources file!");
   416|             Debug.Assert(Monitor.IsEntered(this)); // uses _store
   417|             try
   418|             {
   419|                 return _LoadObjectV1(pos);
   420|             }
   421|             catch (EndOfStreamException eof)
   422|             {
   423|                 throw new BadImageFormatException(SR.BadImageFormat_TypeMismatch, eof);
   424|             }
   425|             catch (ArgumentOutOfRangeException e)
   426|             {
   427|                 throw new BadImageFormatException(SR.BadImageFormat_TypeMismatch, e);
   428|             }
   429|         }
   430|         private object? _LoadObjectV1(int pos)
   431|         {
   432|             Debug.Assert(Monitor.IsEntered(this)); // uses _store
   433|             _store.BaseStream.Seek(_dataSectionOffset + pos, SeekOrigin.Begin);
   434|             int typeIndex = _store.Read7BitEncodedInt();
   435|             if (typeIndex == -1)
   436|                 return null;
   437|             Type type = FindType(typeIndex);
   438|             if (type == typeof(string))
   439|                 return _store.ReadString();
   440|             else if (type == typeof(int))
   441|                 return _store.ReadInt32();
   442|             else if (type == typeof(byte))
   443|                 return _store.ReadByte();
   444|             else if (type == typeof(sbyte))
   445|                 return _store.ReadSByte();
   446|             else if (type == typeof(short))
   447|                 return _store.ReadInt16();
   448|             else if (type == typeof(long))
   449|                 return _store.ReadInt64();
   450|             else if (type == typeof(ushort))
   451|                 return _store.ReadUInt16();
   452|             else if (type == typeof(uint))
   453|                 return _store.ReadUInt32();
   454|             else if (type == typeof(ulong))
   455|                 return _store.ReadUInt64();
   456|             else if (type == typeof(float))
   457|                 return _store.ReadSingle();
   458|             else if (type == typeof(double))
   459|                 return _store.ReadDouble();
   460|             else if (type == typeof(DateTime))
   461|             {
   462|                 return new DateTime(_store.ReadInt64());
   463|             }
   464|             else if (type == typeof(TimeSpan))
   465|                 return new TimeSpan(_store.ReadInt64());
   466|             else if (type == typeof(decimal))
   467|             {
   468| #if RESOURCES_EXTENSIONS
   469|                 int[] bits = new int[4];
   470| #else
   471|                 Span<int> bits = stackalloc int[4];
   472| #endif
   473|                 for (int i = 0; i < bits.Length; i++)
   474|                     bits[i] = _store.ReadInt32();
   475|                 return new decimal(bits);
   476|             }
   477|             else
   478|             {
   479|                 return DeserializeObject(typeIndex);
   480|             }
   481|         }
   482|         private object? LoadObjectV2(int pos, out ResourceTypeCode typeCode)
   483|         {
   484|             Debug.Assert(_store != null, "ResourceReader is closed!");
   485|             Debug.Assert(_version >= 2, ".resources file was not a V2 (or higher) .resources file!");
   486|             Debug.Assert(Monitor.IsEntered(this)); // uses _store
   487|             try
   488|             {
   489|                 return _LoadObjectV2(pos, out typeCode);
   490|             }
   491|             catch (EndOfStreamException eof)
   492|             {
   493|                 throw new BadImageFormatException(SR.BadImageFormat_TypeMismatch, eof);
   494|             }
   495|             catch (ArgumentOutOfRangeException e)
   496|             {
   497|                 throw new BadImageFormatException(SR.BadImageFormat_TypeMismatch, e);
   498|             }
   499|         }
   500|         private object? _LoadObjectV2(int pos, out ResourceTypeCode typeCode)
   501|         {
   502|             Debug.Assert(Monitor.IsEntered(this)); // uses _store
   503|             _store.BaseStream.Seek(_dataSectionOffset + pos, SeekOrigin.Begin);
   504|             typeCode = (ResourceTypeCode)_store.Read7BitEncodedInt();
   505|             switch (typeCode)
   506|             {
   507|                 case ResourceTypeCode.Null:
   508|                     return null;
   509|                 case ResourceTypeCode.String:
   510|                     return _store.ReadString();
   511|                 case ResourceTypeCode.Boolean:
   512|                     return _store.ReadBoolean();
   513|                 case ResourceTypeCode.Char:
   514|                     return (char)_store.ReadUInt16();
   515|                 case ResourceTypeCode.Byte:
   516|                     return _store.ReadByte();
   517|                 case ResourceTypeCode.SByte:
   518|                     return _store.ReadSByte();
   519|                 case ResourceTypeCode.Int16:
   520|                     return _store.ReadInt16();
   521|                 case ResourceTypeCode.UInt16:
   522|                     return _store.ReadUInt16();
   523|                 case ResourceTypeCode.Int32:
   524|                     return _store.ReadInt32();
   525|                 case ResourceTypeCode.UInt32:
   526|                     return _store.ReadUInt32();
   527|                 case ResourceTypeCode.Int64:
   528|                     return _store.ReadInt64();
   529|                 case ResourceTypeCode.UInt64:
   530|                     return _store.ReadUInt64();
   531|                 case ResourceTypeCode.Single:
   532|                     return _store.ReadSingle();
   533|                 case ResourceTypeCode.Double:
   534|                     return _store.ReadDouble();
   535|                 case ResourceTypeCode.Decimal:
   536|                     return _store.ReadDecimal();
   537|                 case ResourceTypeCode.DateTime:
   538|                     long data = _store.ReadInt64();
   539|                     return DateTime.FromBinary(data);
   540|                 case ResourceTypeCode.TimeSpan:
   541|                     long ticks = _store.ReadInt64();
   542|                     return new TimeSpan(ticks);
   543|                 case ResourceTypeCode.ByteArray:
   544|                     {
   545|                         int len = _store.ReadInt32();
   546|                         if (len < 0)
   547|                         {
   548|                             throw new BadImageFormatException(SR.Format(SR.BadImageFormat_ResourceDataLengthInvalid, len));
   549|                         }
   550|                         if (_ums == null)
   551|                         {
   552|                             if (len > _store.BaseStream.Length)
   553|                             {
   554|                                 throw new BadImageFormatException(SR.Format(SR.BadImageFormat_ResourceDataLengthInvalid, len));
   555|                             }
   556|                             return _store.ReadBytes(len);
   557|                         }
   558|                         if (len > _ums.Length - _ums.Position)
   559|                         {
   560|                             throw new BadImageFormatException(SR.Format(SR.BadImageFormat_ResourceDataLengthInvalid, len));
   561|                         }
   562|                         byte[] bytes = new byte[len];
   563|                         int r = _ums.Read(bytes, 0, len);
   564|                         Debug.Assert(r == len, "ResourceReader needs to use a blocking read here.  (Call _store.ReadBytes(len)?)");
   565|                         return bytes;
   566|                     }
   567|                 case ResourceTypeCode.Stream:
   568|                     {
   569|                         int len = _store.ReadInt32();
   570|                         if (len < 0)
   571|                         {
   572|                             throw new BadImageFormatException(SR.Format(SR.BadImageFormat_ResourceDataLengthInvalid, len));
   573|                         }
   574|                         if (_ums == null)
   575|                         {
   576|                             byte[] bytes = _store.ReadBytes(len);
   577|                             return new PinnedBufferMemoryStream(bytes);
   578|                         }
   579|                         if (len > _ums.Length - _ums.Position)
   580|                         {
   581|                             throw new BadImageFormatException(SR.Format(SR.BadImageFormat_ResourceDataLengthInvalid, len));
   582|                         }
   583|                         unsafe
   584|                         {
   585|                             return new UnmanagedMemoryStream(_ums.PositionPointer, len, len, FileAccess.Read);
   586|                         }
   587|                     }
   588|                 default:
   589|                     if (typeCode < ResourceTypeCode.StartOfUserTypes)
   590|                     {
   591|                         throw new BadImageFormatException(SR.BadImageFormat_TypeMismatch);
   592|                     }
   593|                     break;
   594|             }
   595|             int typeIndex = typeCode - ResourceTypeCode.StartOfUserTypes;
   596|             return DeserializeObject(typeIndex);
   597|         }
   598|         [MemberNotNull(nameof(_typeTable))]
   599|         [MemberNotNull(nameof(_typeNamePositions))]
   600|         private void ReadResources()
   601|         {
   602|             Debug.Assert(!Monitor.IsEntered(this)); // only called during init
   603|             Debug.Assert(_store != null, "ResourceReader is closed!");
   604|             try
   605|             {
   606|                 _ReadResources();
   607|             }
   608|             catch (EndOfStreamException eof)
   609|             {
   610|                 throw new BadImageFormatException(SR.BadImageFormat_ResourcesHeaderCorrupted, eof);
   611|             }
   612|             catch (IndexOutOfRangeException e)
   613|             {
   614|                 throw new BadImageFormatException(SR.BadImageFormat_ResourcesHeaderCorrupted, e);
   615|             }
   616|         }
   617|         [MemberNotNull(nameof(_typeTable))]
   618|         [MemberNotNull(nameof(_typeNamePositions))]
   619|         private void _ReadResources()
   620|         {
   621|             Debug.Assert(!Monitor.IsEntered(this)); // only called during init
   622|             int magicNum = _store.ReadInt32();
   623|             if (magicNum != ResourceManager.MagicNumber)
   624|                 throw new ArgumentException(SR.Resources_StreamNotValid);
   625|             int resMgrHeaderVersion = _store.ReadInt32();
   626|             int numBytesToSkip = _store.ReadInt32();
   627|             if (numBytesToSkip < 0 || resMgrHeaderVersion < 0)
   628|             {
   629|                 throw new BadImageFormatException(SR.BadImageFormat_ResourcesHeaderCorrupted);
   630|             }
   631|             if (resMgrHeaderVersion > 1)
   632|             {
   633|                 _store.BaseStream.Seek(numBytesToSkip, SeekOrigin.Current);
   634|             }
   635|             else
   636|             {
   637|                 string readerType = _store.ReadString();
   638|                 if (!ValidateReaderType(readerType))
   639|                     throw new NotSupportedException(SR.Format(SR.NotSupported_WrongResourceReader_Type, readerType));
   640|                 SkipString();
   641|             }
   642|             int version = _store.ReadInt32();
   643|             const int CurrentVersion = 2;
   644|             if (version != CurrentVersion && version != 1)
   645|                 throw new ArgumentException(SR.Format(SR.Arg_ResourceFileUnsupportedVersion, CurrentVersion, version));
   646|             _version = version;
   647|             _numResources = _store.ReadInt32();
   648|             if (_numResources < 0)
   649|             {
   650|                 throw new BadImageFormatException(SR.BadImageFormat_ResourcesHeaderCorrupted);
   651|             }
   652|             int numTypes = _store.ReadInt32();
   653|             if (numTypes < 0)
   654|             {
   655|                 throw new BadImageFormatException(SR.BadImageFormat_ResourcesHeaderCorrupted);
   656|             }
   657|             _typeTable = new Type[numTypes];
   658|             _typeNamePositions = new int[numTypes];
   659|             for (int i = 0; i < numTypes; i++)
   660|             {
   661|                 _typeNamePositions[i] = (int)_store.BaseStream.Position;
   662|                 SkipString();
   663|             }
   664|             long pos = _store.BaseStream.Position;
   665|             int alignBytes = ((int)pos) & 7;
   666|             if (alignBytes != 0)
   667|             {
   668|                 for (int i = 0; i < 8 - alignBytes; i++)
   669|                 {
   670|                     _store.ReadByte();
   671|                 }
   672|             }
   673|             if (_ums == null)
   674|             {
   675|                 _nameHashes = new int[_numResources];
   676|                 for (int i = 0; i < _numResources; i++)
   677|                 {
   678|                     _nameHashes[i] = _store.ReadInt32();
   679|                 }
   680|             }
   681|             else
   682|             {
   683|                 int seekPos = unchecked(4 * _numResources);
   684|                 if (seekPos < 0)
   685|                 {
   686|                     throw new BadImageFormatException(SR.BadImageFormat_ResourcesHeaderCorrupted);
   687|                 }
   688|                 unsafe
   689|                 {
   690|                     _nameHashesPtr = (int*)_ums.PositionPointer;
   691|                     _ums.Seek(seekPos, SeekOrigin.Current);
   692|                     _ = _ums.PositionPointer;
   693|                 }
   694|             }
   695|             if (_ums == null)
   696|             {
   697|                 _namePositions = new int[_numResources];
   698|                 for (int i = 0; i < _numResources; i++)
   699|                 {
   700|                     int namePosition = _store.ReadInt32();
   701|                     if (namePosition < 0)
   702|                     {
   703|                         throw new BadImageFormatException(SR.BadImageFormat_ResourcesHeaderCorrupted);
   704|                     }
   705|                     _namePositions[i] = namePosition;
   706|                 }
   707|             }
   708|             else
   709|             {
   710|                 int seekPos = unchecked(4 * _numResources);
   711|                 if (seekPos < 0)
   712|                 {
   713|                     throw new BadImageFormatException(SR.BadImageFormat_ResourcesHeaderCorrupted);
   714|                 }
   715|                 unsafe
   716|                 {
   717|                     _namePositionsPtr = (int*)_ums.PositionPointer;
   718|                     _ums.Seek(seekPos, SeekOrigin.Current);
   719|                     _ = _ums.PositionPointer;
   720|                 }
   721|             }
   722|             _dataSectionOffset = _store.ReadInt32();
   723|             if (_dataSectionOffset < 0)
   724|             {
   725|                 throw new BadImageFormatException(SR.BadImageFormat_ResourcesHeaderCorrupted);
   726|             }
   727|             _nameSectionOffset = _store.BaseStream.Position;
   728|             if (_dataSectionOffset < _nameSectionOffset)
   729|             {
   730|                 throw new BadImageFormatException(SR.BadImageFormat_ResourcesHeaderCorrupted);
   731|             }
   732|         }
   733|         [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode",
   734|             Justification = "UseReflectionToGetType will get trimmed out when AllowCustomResourceTypes is set to false. " +
   735|             "When set to true, we will already throw a warning for this feature switch, so we suppress this one in order for" +
   736|             "the user to only get one error.")]
   737|         private Type FindType(int typeIndex)
   738|         {
   739|             if (!AllowCustomResourceTypes)
   740|             {
   741|                 throw new NotSupportedException(SR.ResourceManager_ReflectionNotAllowed);
   742|             }
   743|             if (typeIndex < 0 || typeIndex >= _typeTable.Length)
   744|             {
   745|                 throw new BadImageFormatException(SR.BadImageFormat_InvalidType);
   746|             }
   747|             return _typeTable[typeIndex] ?? UseReflectionToGetType(typeIndex);
   748|         }
   749|         [RequiresUnreferencedCode("The CustomResourceTypesSupport feature switch has been enabled for this app which is being trimmed. " +
   750|             "Custom readers as well as custom objects on the resources file are not observable by the trimmer and so required assemblies, types and members may be removed.")]
   751|         private Type UseReflectionToGetType(int typeIndex)
   752|         {
   753|             Debug.Assert(Monitor.IsEntered(this)); // uses _store
   754|             long oldPos = _store.BaseStream.Position;
   755|             try
   756|             {
   757|                 _store.BaseStream.Position = _typeNamePositions[typeIndex];
   758|                 string typeName = _store.ReadString();
   759|                 _typeTable[typeIndex] = Type.GetType(typeName, true);
   760|                 Debug.Assert(_typeTable[typeIndex] != null, "Should have found a type!");
   761|                 return _typeTable[typeIndex]!;
   762|             }
   763| #if !RESOURCES_EXTENSIONS
   764|             catch (FileNotFoundException fileNotFoundException) when (!_permitDeserialization)
   765|             {
   766|                 throw new NotSupportedException(SR.NotSupported_ResourceObjectSerialization, fileNotFoundException);
   767|             }
   768| #endif
   769|             finally
   770|             {
   771|                 _store.BaseStream.Position = oldPos;
   772|             }
   773|         }
   774|         private string TypeNameFromTypeCode(ResourceTypeCode typeCode)
   775|         {
   776|             Debug.Assert(typeCode >= 0, "can't be negative");
   777|             Debug.Assert(Monitor.IsEntered(this)); // uses _store
   778|             if (typeCode < ResourceTypeCode.StartOfUserTypes)
   779|             {
   780|                 Debug.Assert(!string.Equals(typeCode.ToString(), "LastPrimitive"), "Change ResourceTypeCode metadata order so LastPrimitive isn't what Enum.ToString prefers.");
   781|                 return "ResourceTypeCode." + typeCode.ToString();
   782|             }
   783|             else
   784|             {
   785|                 int typeIndex = typeCode - ResourceTypeCode.StartOfUserTypes;
   786|                 Debug.Assert(typeIndex >= 0 && typeIndex < _typeTable.Length, "TypeCode is broken or corrupted!");
   787|                 long oldPos = _store.BaseStream.Position;
   788|                 try
   789|                 {
   790|                     _store.BaseStream.Position = _typeNamePositions[typeIndex];
   791|                     return _store.ReadString();
   792|                 }
   793|                 finally
   794|                 {
   795|                     _store.BaseStream.Position = oldPos;
   796|                 }
   797|             }
   798|         }
   799|         internal sealed class ResourceEnumerator : IDictionaryEnumerator
   800|         {
   801|             private const int ENUM_DONE = int.MinValue;
   802|             private const int ENUM_NOT_STARTED = -1;
   803|             private readonly ResourceReader _reader;
   804|             private bool _currentIsValid;
   805|             private int _currentName;
   806|             private int _dataPosition; // cached for case-insensitive table
   807|             internal ResourceEnumerator(ResourceReader reader)
   808|             {
   809|                 _currentName = ENUM_NOT_STARTED;
   810|                 _reader = reader;
   811|                 _dataPosition = -2;
   812|             }
   813|             public bool MoveNext()
   814|             {
   815|                 if (_currentName == _reader._numResources - 1 || _currentName == ENUM_DONE)
   816|                 {
   817|                     _currentIsValid = false;
   818|                     _currentName = ENUM_DONE;
   819|                     return false;
   820|                 }
   821|                 _currentIsValid = true;
   822|                 _currentName++;
   823|                 return true;
   824|             }
   825|             public object Key
   826|             {
   827|                 get
   828|                 {
   829|                     if (_currentName == ENUM_DONE) throw new InvalidOperationException(SR.InvalidOperation_EnumEnded);
   830|                     if (!_currentIsValid) throw new InvalidOperationException(SR.InvalidOperation_EnumNotStarted);
   831|                     if (_reader._resCache == null) throw new InvalidOperationException(SR.ResourceReaderIsClosed);
   832|                     return _reader.AllocateStringForNameIndex(_currentName, out _dataPosition);
   833|                 }
   834|             }
   835|             public object Current => Entry;
   836|             internal int DataPosition => _dataPosition;
   837|             public DictionaryEntry Entry
   838|             {
   839|                 get
   840|                 {
   841|                     if (_currentName == ENUM_DONE) throw new InvalidOperationException(SR.InvalidOperation_EnumEnded);
   842|                     if (!_currentIsValid) throw new InvalidOperationException(SR.InvalidOperation_EnumNotStarted);
   843|                     if (_reader._resCache == null) throw new InvalidOperationException(SR.ResourceReaderIsClosed);
   844|                     string key = _reader.AllocateStringForNameIndex(_currentName, out _dataPosition); // AllocateStringForNameIndex could lock on _reader
   845|                     object? value = null;
   846|                     Debug.Assert(!Monitor.IsEntered(_reader));
   847|                     lock (_reader._resCache)
   848|                     {
   849|                         if (_reader._resCache.TryGetValue(key, out ResourceLocator locator))
   850|                         {
   851|                             value = locator.Value;
   852|                         }
   853|                     }
   854|                     if (value is null)
   855|                     {
   856|                         if (_dataPosition == -1)
   857|                             value = _reader.GetValueForNameIndex(_currentName);
   858|                         else
   859|                             value = _reader.LoadObject(_dataPosition);
   860|                     }
   861|                     return new DictionaryEntry(key, value);
   862|                 }
   863|             }
   864|             public object? Value
   865|             {
   866|                 get
   867|                 {
   868|                     if (_currentName == ENUM_DONE) throw new InvalidOperationException(SR.InvalidOperation_EnumEnded);
   869|                     if (!_currentIsValid) throw new InvalidOperationException(SR.InvalidOperation_EnumNotStarted);
   870|                     if (_reader._resCache == null) throw new InvalidOperationException(SR.ResourceReaderIsClosed);
   871|                     return _reader.GetValueForNameIndex(_currentName);
   872|                 }
   873|             }
   874|             public void Reset()
   875|             {
   876|                 if (_reader._resCache == null) throw new InvalidOperationException(SR.ResourceReaderIsClosed);
   877|                 _currentIsValid = false;
   878|                 _currentName = ENUM_NOT_STARTED;
   879|             }
   880|         }
   881|     }
   882| }


# ====================================================================
# FILE: src/libraries/System.Private.CoreLib/src/System/Resources/RuntimeResourceSet.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-179 ---
     1| using System.Collections;
     2| using System.Collections.Generic;
     3| using System.Diagnostics;
     4| using System.IO;
     5| using System.Threading;
     6| namespace System.Resources
     7| #if RESOURCES_EXTENSIONS
     8|     .Extensions
     9| #endif
    10| {
    11| #pragma warning disable IDE0065
    12| #if RESOURCES_EXTENSIONS
    13|     using ResourceReader = DeserializingResourceReader;
    14| #endif
    15| #pragma warning restore IDE0065
    16| #if NATIVEAOT
    17|     public  // On NativeAOT, this must be public to prevent it from getting reflection blocked.
    18| #else
    19|     internal
    20| #endif
    21|     sealed class RuntimeResourceSet : ResourceSet, IEnumerable
    22|     {
    23|         private Dictionary<string, ResourceLocator>? _resCache;
    24|         private ResourceReader? _defaultReader;
    25|         private Dictionary<string, ResourceLocator>? _caseInsensitiveTable;
    26| #if !RESOURCES_EXTENSIONS
    27|         internal RuntimeResourceSet(string fileName) :
    28|             this(new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read))
    29|         {
    30|         }
    31|         internal RuntimeResourceSet(Stream stream, bool permitDeserialization = false) :
    32|             base(false)
    33|         {
    34|             _resCache = new Dictionary<string, ResourceLocator>(FastResourceComparer.Default);
    35|             _defaultReader = new ResourceReader(stream, _resCache, permitDeserialization);
    36|         }
    37| #else
    38|         internal RuntimeResourceSet(IResourceReader reader) :
    39|             base()
    40|         {
    41|             if (reader is null)
    42|             {
    43|                 throw new ArgumentNullException(nameof(reader));
    44|             }
    45|             _defaultReader = reader as DeserializingResourceReader ?? throw new ArgumentException(SR.Format(SR.NotSupported_WrongResourceReader_Type, reader.GetType()), nameof(reader));
    46|             _resCache = new Dictionary<string, ResourceLocator>(FastResourceComparer.Default);
    47|             _defaultReader._resCache = _resCache;
    48|         }
    49| #endif
    50|         protected override void Dispose(bool disposing)
    51|         {
    52|             if (_defaultReader is null)
    53|                 return;
    54|             if (disposing)
    55|             {
    56|                 _defaultReader?.Close();
    57|             }
    58|             _defaultReader = null;
    59|             _resCache = null;
    60|             _caseInsensitiveTable = null;
    61|             base.Dispose(disposing);
    62|         }
    63|         public override IDictionaryEnumerator GetEnumerator()
    64|         {
    65|             return GetEnumeratorHelper();
    66|         }
    67|         IEnumerator IEnumerable.GetEnumerator()
    68|         {
    69|             return GetEnumeratorHelper();
    70|         }
    71|         private IDictionaryEnumerator GetEnumeratorHelper()
    72|         {
    73|             ResourceReader? reader = _defaultReader;
    74|             if (reader is null)
    75|                 throw new ObjectDisposedException(null, SR.ObjectDisposed_ResourceSet);
    76|             return reader.GetEnumerator();
    77|         }
    78|         public override string? GetString(string key)
    79|         {
    80|             object? o = GetObject(key, false, true);
    81|             return (string?)o;
    82|         }
    83|         public override string? GetString(string key, bool ignoreCase)
    84|         {
    85|             object? o = GetObject(key, ignoreCase, true);
    86|             return (string?)o;
    87|         }
    88|         public override object? GetObject(string key)
    89|         {
    90|             return GetObject(key, false, false);
    91|         }
    92|         public override object? GetObject(string key, bool ignoreCase)
    93|         {
    94|             return GetObject(key, ignoreCase, false);
    95|         }
    96|         private object? GetObject(string key, bool ignoreCase, bool isString)
    97|         {
    98|             if (key is null)
    99|             {
   100|                 throw new ArgumentNullException(nameof(key));
   101|             }
   102|             ResourceReader? reader = _defaultReader;
   103|             Dictionary<string, ResourceLocator>? cache = _resCache;
   104|             if (reader is null || cache is null)
   105|                 throw new ObjectDisposedException(null, SR.ObjectDisposed_ResourceSet);
   106|             object? value;
   107|             ResourceLocator resEntry;
   108|             Debug.Assert(!Monitor.IsEntered(reader));
   109|             lock (cache)
   110|             {
   111|                 int dataPos;
   112|                 if (cache.TryGetValue(key, out resEntry))
   113|                 {
   114|                     value = resEntry.Value;
   115|                     if (value != null)
   116|                         return value;
   117|                     dataPos = resEntry.DataPosition;
   118|                     return isString ? reader.LoadString(dataPos) : reader.LoadObject(dataPos);
   119|                 }
   120|                 dataPos = reader.FindPosForResource(key);
   121|                 if (dataPos >= 0)
   122|                 {
   123|                     value = ReadValue(reader, dataPos, isString, out resEntry);
   124|                     cache[key] = resEntry;
   125|                     return value;
   126|                 }
   127|             }
   128|             if (!ignoreCase)
   129|             {
   130|                 return null;
   131|             }
   132|             bool initialize = false;
   133|             Dictionary<string, ResourceLocator>? caseInsensitiveTable = _caseInsensitiveTable;
   134|             if (caseInsensitiveTable == null)
   135|             {
   136|                 caseInsensitiveTable = new Dictionary<string, ResourceLocator>(StringComparer.OrdinalIgnoreCase);
   137|                 initialize = true;
   138|             }
   139|             lock (caseInsensitiveTable)
   140|             {
   141|                 if (initialize)
   142|                 {
   143|                     ResourceReader.ResourceEnumerator en = reader.GetEnumeratorInternal();
   144|                     while (en.MoveNext())
   145|                     {
   146|                         string currentKey = (string)en.Key;
   147|                         ResourceLocator resLoc = new ResourceLocator(en.DataPosition, null);
   148|                         caseInsensitiveTable.Add(currentKey, resLoc);
   149|                     }
   150|                     _caseInsensitiveTable = caseInsensitiveTable;
   151|                 }
   152|                 if (!caseInsensitiveTable.TryGetValue(key, out resEntry))
   153|                     return null;
   154|                 if (resEntry.Value != null)
   155|                     return resEntry.Value;
   156|                 value = ReadValue(reader, resEntry.DataPosition, isString, out resEntry);
   157|                 if (resEntry.Value != null)
   158|                     caseInsensitiveTable[key] = resEntry;
   159|             }
   160|             return value;
   161|         }
   162|         private static object? ReadValue(ResourceReader reader, int dataPos, bool isString, out ResourceLocator locator)
   163|         {
   164|             object? value;
   165|             ResourceTypeCode typeCode;
   166|             if (isString)
   167|             {
   168|                 value = reader.LoadString(dataPos);
   169|                 typeCode = ResourceTypeCode.String;
   170|             }
   171|             else
   172|             {
   173|                 value = reader.LoadObject(dataPos, out typeCode);
   174|             }
   175|             locator = new ResourceLocator(dataPos, ResourceLocator.CanCache(typeCode) ? value : null);
   176|             return value;
   177|         }
   178|     }
   179| }


# ====================================================================
# FILE: src/libraries/System.Private.CoreLib/src/System/Threading/PortableThreadPool.Unix.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-16 ---
     1| namespace System.Threading
     2| {
     3|     internal sealed partial class PortableThreadPool
     4|     {
     5|         private static partial class WorkerThread
     6|         {
     7|             private static bool IsIOPending => false;
     8|         }
     9|         private struct CpuUtilizationReader
    10|         {
    11|             private Interop.Sys.ProcessCpuInformation _cpuInfo;
    12|             public double CurrentUtilization =>
    13|                 Interop.Sys.GetCpuUtilization(ref _cpuInfo) / Environment.ProcessorCount;
    14|         }
    15|     }
    16| }


# ====================================================================
# FILE: src/libraries/System.Private.CoreLib/src/System/Threading/PortableThreadPool.Windows.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-50 ---
     1| using System.Diagnostics;
     2| using System.Runtime.InteropServices;
     3| namespace System.Threading
     4| {
     5|     internal sealed partial class PortableThreadPool
     6|     {
     7|         private static partial class WorkerThread
     8|         {
     9|             private static bool IsIOPending
    10|             {
    11|                 get
    12|                 {
    13|                     bool success =
    14|                         Interop.Kernel32.GetThreadIOPendingFlag(Interop.Kernel32.GetCurrentThread(), out Interop.BOOL isIOPending);
    15|                     Debug.Assert(success);
    16|                     return !success || isIOPending != Interop.BOOL.FALSE;
    17|                 }
    18|             }
    19|         }
    20|         private struct CpuUtilizationReader
    21|         {
    22|             public long _idleTime;
    23|             public long _kernelTime;
    24|             public long _userTime;
    25|             public int CurrentUtilization
    26|             {
    27|                 get
    28|                 {
    29|                     if (!Interop.Kernel32.GetSystemTimes(out long idleTime, out long kernelTime, out long userTime))
    30|                     {
    31|                         return 0;
    32|                     }
    33|                     long cpuTotalTime = ((long)userTime - _userTime) + ((long)kernelTime - _kernelTime);
    34|                     long cpuBusyTime = cpuTotalTime - ((long)idleTime - _idleTime);
    35|                     _kernelTime = (long)kernelTime;
    36|                     _userTime = (long)userTime;
    37|                     _idleTime = (long)idleTime;
    38|                     if (cpuTotalTime > 0 && cpuBusyTime > 0)
    39|                     {
    40|                         long reading = cpuBusyTime * 100 / cpuTotalTime;
    41|                         reading = Math.Min(reading, 100);
    42|                         Debug.Assert(0 <= reading);
    43|                         return (int)reading;
    44|                     }
    45|                     return 0;
    46|                 }
    47|             }
    48|         }
    49|     }
    50| }


# ====================================================================
# FILE: src/libraries/System.Private.CoreLib/src/System/Threading/PortableThreadPool.WorkerThread.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-243 ---
     1| using System.Diagnostics.Tracing;
     2| namespace System.Threading
     3| {
     4|     internal sealed partial class PortableThreadPool
     5|     {
     6|         private static partial class WorkerThread
     7|         {
     8|             private const int SemaphoreSpinCountDefaultBaseline = 70;
     9| #if !TARGET_ARM64 && !TARGET_ARM && !TARGET_LOONGARCH64
    10|             private const int SemaphoreSpinCountDefault = SemaphoreSpinCountDefaultBaseline;
    11| #else
    12|             private const int SemaphoreSpinCountDefault = SemaphoreSpinCountDefaultBaseline * 4;
    13| #endif
    14|             public const int EstimatedAdditionalStackUsagePerThreadBytes = 64 << 10; // 64 KB
    15|             private static readonly LowLevelLifoSemaphore s_semaphore =
    16|                 new LowLevelLifoSemaphore(
    17|                     0,
    18|                     MaxPossibleThreadCount,
    19|                     AppContextConfigHelper.GetInt32Config(
    20|                         "System.Threading.ThreadPool.UnfairSemaphoreSpinLimit",
    21|                         SemaphoreSpinCountDefault,
    22|                         false),
    23|                     onWait: () =>
    24|                     {
    25|                         if (NativeRuntimeEventSource.Log.IsEnabled())
    26|                         {
    27|                             NativeRuntimeEventSource.Log.ThreadPoolWorkerThreadWait(
    28|                                 (uint)ThreadPoolInstance._separated.counts.VolatileRead().NumExistingThreads);
    29|                         }
    30|                     });
    31|             private static readonly ThreadStart s_workerThreadStart = WorkerThreadStart;
    32|             private static void WorkerThreadStart()
    33|             {
    34|                 Thread.CurrentThread.SetThreadPoolWorkerThreadName();
    35|                 PortableThreadPool threadPoolInstance = ThreadPoolInstance;
    36|                 if (NativeRuntimeEventSource.Log.IsEnabled())
    37|                 {
    38|                     NativeRuntimeEventSource.Log.ThreadPoolWorkerThreadStart(
    39|                         (uint)threadPoolInstance._separated.counts.VolatileRead().NumExistingThreads);
    40|                 }
    41|                 LowLevelLock threadAdjustmentLock = threadPoolInstance._threadAdjustmentLock;
    42|                 LowLevelLifoSemaphore semaphore = s_semaphore;
    43|                 while (true)
    44|                 {
    45|                     bool spinWait = true;
    46|                     while (semaphore.Wait(ThreadPoolThreadTimeoutMs, spinWait))
    47|                     {
    48|                         bool alreadyRemovedWorkingWorker = false;
    49|                         while (TakeActiveRequest(threadPoolInstance))
    50|                         {
    51|                             threadPoolInstance._separated.lastDequeueTime = Environment.TickCount;
    52|                             if (!ThreadPoolWorkQueue.Dispatch())
    53|                             {
    54|                                 alreadyRemovedWorkingWorker = true;
    55|                                 break;
    56|                             }
    57|                             if (threadPoolInstance._separated.numRequestedWorkers <= 0)
    58|                             {
    59|                                 break;
    60|                             }
    61|                             Thread.UninterruptibleSleep0();
    62|                             if (!Environment.IsSingleProcessor)
    63|                             {
    64|                                 Thread.SpinWait(1);
    65|                             }
    66|                         }
    67|                         spinWait = !alreadyRemovedWorkingWorker;
    68|                         if (!alreadyRemovedWorkingWorker)
    69|                         {
    70|                             RemoveWorkingWorker(threadPoolInstance);
    71|                         }
    72|                     }
    73|                     if (IsIOPending)
    74|                     {
    75|                         continue;
    76|                     }
    77|                     threadAdjustmentLock.Acquire();
    78|                     try
    79|                     {
    80|                         ThreadCounts counts = threadPoolInstance._separated.counts;
    81|                         while (true)
    82|                         {
    83|                             if (counts.NumExistingThreads <= counts.NumProcessingWork)
    84|                             {
    85|                                 break;
    86|                             }
    87|                             ThreadCounts newCounts = counts;
    88|                             short newNumExistingThreads = --newCounts.NumExistingThreads;
    89|                             short newNumThreadsGoal =
    90|                                 Math.Max(
    91|                                     threadPoolInstance.MinThreadsGoal,
    92|                                     Math.Min(newNumExistingThreads, counts.NumThreadsGoal));
    93|                             newCounts.NumThreadsGoal = newNumThreadsGoal;
    94|                             ThreadCounts oldCounts =
    95|                                 threadPoolInstance._separated.counts.InterlockedCompareExchange(newCounts, counts);
    96|                             if (oldCounts == counts)
    97|                             {
    98|                                 HillClimbing.ThreadPoolHillClimber.ForceChange(
    99|                                     newNumThreadsGoal,
   100|                                     HillClimbing.StateOrTransition.ThreadTimedOut);
   101|                                 if (NativeRuntimeEventSource.Log.IsEnabled())
   102|                                 {
   103|                                     NativeRuntimeEventSource.Log.ThreadPoolWorkerThreadStop((uint)newNumExistingThreads);
   104|                                 }
   105|                                 return;
   106|                             }
   107|                             counts = oldCounts;
   108|                         }
   109|                     }
   110|                     finally
   111|                     {
   112|                         threadAdjustmentLock.Release();
   113|                     }
   114|                 }
   115|             }
   116|             private static void RemoveWorkingWorker(PortableThreadPool threadPoolInstance)
   117|             {
   118|                 ThreadCounts counts = threadPoolInstance._separated.counts;
   119|                 while (true)
   120|                 {
   121|                     ThreadCounts newCounts = counts;
   122|                     newCounts.NumProcessingWork--;
   123|                     ThreadCounts countsBeforeUpdate =
   124|                         threadPoolInstance._separated.counts.InterlockedCompareExchange(newCounts, counts);
   125|                     if (countsBeforeUpdate == counts)
   126|                     {
   127|                         break;
   128|                     }
   129|                     counts = countsBeforeUpdate;
   130|                 }
   131|                 if (threadPoolInstance._separated.numRequestedWorkers > 0)
   132|                 {
   133|                     MaybeAddWorkingWorker(threadPoolInstance);
   134|                 }
   135|             }
   136|             internal static void MaybeAddWorkingWorker(PortableThreadPool threadPoolInstance)
   137|             {
   138|                 ThreadCounts counts = threadPoolInstance._separated.counts;
   139|                 short numExistingThreads, numProcessingWork, newNumExistingThreads, newNumProcessingWork;
   140|                 while (true)
   141|                 {
   142|                     numProcessingWork = counts.NumProcessingWork;
   143|                     if (numProcessingWork >= counts.NumThreadsGoal)
   144|                     {
   145|                         return;
   146|                     }
   147|                     newNumProcessingWork = (short)(numProcessingWork + 1);
   148|                     numExistingThreads = counts.NumExistingThreads;
   149|                     newNumExistingThreads = Math.Max(numExistingThreads, newNumProcessingWork);
   150|                     ThreadCounts newCounts = counts;
   151|                     newCounts.NumProcessingWork = newNumProcessingWork;
   152|                     newCounts.NumExistingThreads = newNumExistingThreads;
   153|                     ThreadCounts oldCounts = threadPoolInstance._separated.counts.InterlockedCompareExchange(newCounts, counts);
   154|                     if (oldCounts == counts)
   155|                     {
   156|                         break;
   157|                     }
   158|                     counts = oldCounts;
   159|                 }
   160|                 int toCreate = newNumExistingThreads - numExistingThreads;
   161|                 int toRelease = newNumProcessingWork - numProcessingWork;
   162|                 if (toRelease > 0)
   163|                 {
   164|                     s_semaphore.Release(toRelease);
   165|                 }
   166|                 while (toCreate > 0)
   167|                 {
   168|                     if (TryCreateWorkerThread())
   169|                     {
   170|                         toCreate--;
   171|                         continue;
   172|                     }
   173|                     counts = threadPoolInstance._separated.counts;
   174|                     while (true)
   175|                     {
   176|                         ThreadCounts newCounts = counts;
   177|                         newCounts.NumProcessingWork -= (short)toCreate;
   178|                         newCounts.NumExistingThreads -= (short)toCreate;
   179|                         ThreadCounts oldCounts = threadPoolInstance._separated.counts.InterlockedCompareExchange(newCounts, counts);
   180|                         if (oldCounts == counts)
   181|                         {
   182|                             break;
   183|                         }
   184|                         counts = oldCounts;
   185|                     }
   186|                     break;
   187|                 }
   188|             }
   189|             internal static bool ShouldStopProcessingWorkNow(PortableThreadPool threadPoolInstance)
   190|             {
   191|                 ThreadCounts counts = threadPoolInstance._separated.counts;
   192|                 while (true)
   193|                 {
   194|                     if (counts.NumProcessingWork <= counts.NumThreadsGoal)
   195|                     {
   196|                         return false;
   197|                     }
   198|                     ThreadCounts newCounts = counts;
   199|                     newCounts.NumProcessingWork--;
   200|                     ThreadCounts oldCounts = threadPoolInstance._separated.counts.InterlockedCompareExchange(newCounts, counts);
   201|                     if (oldCounts == counts)
   202|                     {
   203|                         return true;
   204|                     }
   205|                     counts = oldCounts;
   206|                 }
   207|             }
   208|             private static bool TakeActiveRequest(PortableThreadPool threadPoolInstance)
   209|             {
   210|                 int count = threadPoolInstance._separated.numRequestedWorkers;
   211|                 while (count > 0)
   212|                 {
   213|                     int prevCount = Interlocked.CompareExchange(ref threadPoolInstance._separated.numRequestedWorkers, count - 1, count);
   214|                     if (prevCount == count)
   215|                     {
   216|                         return true;
   217|                     }
   218|                     count = prevCount;
   219|                 }
   220|                 return false;
   221|             }
   222|             private static bool TryCreateWorkerThread()
   223|             {
   224|                 try
   225|                 {
   226|                     Thread workerThread = new Thread(s_workerThreadStart);
   227|                     workerThread.IsThreadPoolThread = true;
   228|                     workerThread.IsBackground = true;
   229|                     workerThread.UnsafeStart();
   230|                 }
   231|                 catch (ThreadStartException)
   232|                 {
   233|                     return false;
   234|                 }
   235|                 catch (OutOfMemoryException)
   236|                 {
   237|                     return false;
   238|                 }
   239|                 return true;
   240|             }
   241|         }
   242|     }
   243| }


# ====================================================================
# FILE: src/libraries/System.Reflection.DispatchProxy/src/System/Reflection/DispatchProxyGenerator.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-589 ---
     1| using System.Collections.Generic;
     2| using System.Diagnostics;
     3| using System.Diagnostics.CodeAnalysis;
     4| using System.Linq;
     5| using System.Reflection.Emit;
     6| using System.Runtime.CompilerServices;
     7| using System.Runtime.Loader;
     8| using System.Threading;
     9| namespace System.Reflection
    10| {
    11|     internal static class DispatchProxyGenerator
    12|     {
    13|         private const int MethodInfosFieldAndCtorParameterIndex = 0;
    14|         private static readonly ConditionalWeakTable<AssemblyLoadContext, ProxyAssembly> s_alcProxyAssemblyMap = new();
    15|         private static readonly MethodInfo s_dispatchProxyInvokeMethod = typeof(DispatchProxy).GetMethod("Invoke", BindingFlags.NonPublic | BindingFlags.Instance)!;
    16|         private static readonly MethodInfo s_getTypeFromHandleMethod = typeof(Type).GetMethod("GetTypeFromHandle", new Type[] { typeof(RuntimeTypeHandle) })!;
    17|         private static readonly MethodInfo s_makeGenericMethodMethod = GetGenericMethodMethodInfo();
    18|         [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode",
    19|             Justification = "MakeGenericMethod is safe here because the user code invoking the generic method will reference " +
    20|             "the GenericTypes being used, which will guarantee the requirements of the generic method.")]
    21|         private static MethodInfo GetGenericMethodMethodInfo() =>
    22|             typeof(MethodInfo).GetMethod("MakeGenericMethod", new Type[] { typeof(Type[]) })!;
    23|         [RequiresDynamicCode("Defining a dynamic assembly requires generating code at runtime")]
    24|         internal static object CreateProxyInstance(
    25|             [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] Type baseType,
    26|             [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type interfaceType)
    27|         {
    28|             Debug.Assert(baseType != null);
    29|             Debug.Assert(interfaceType != null);
    30|             AssemblyLoadContext? alc = AssemblyLoadContext.GetLoadContext(baseType.Assembly);
    31|             Debug.Assert(alc != null);
    32|             ProxyAssembly proxyAssembly = s_alcProxyAssemblyMap.GetValue(alc, static x => new ProxyAssembly(x));
    33|             GeneratedTypeInfo proxiedType = proxyAssembly.GetProxyType(baseType, interfaceType);
    34|             return Activator.CreateInstance(proxiedType.GeneratedType, new object[] { proxiedType.MethodInfos })!;
    35|         }
    36|         private sealed class GeneratedTypeInfo
    37|         {
    38|             public GeneratedTypeInfo(
    39|                 [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type generatedType,
    40|                 MethodInfo[] methodInfos)
    41|             {
    42|                 GeneratedType = generatedType;
    43|                 MethodInfos = methodInfos;
    44|             }
    45|             [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
    46|             public Type GeneratedType { get; }
    47|             public MethodInfo[] MethodInfos { get; }
    48|         }
    49|         private sealed class ProxyAssembly
    50|         {
    51|             private readonly Dictionary<Type, Dictionary<Type, GeneratedTypeInfo>> _baseTypeAndInterfaceToGeneratedProxyType = new Dictionary<Type, Dictionary<Type, GeneratedTypeInfo>>();
    52|             private readonly AssemblyBuilder _ab;
    53|             private readonly ModuleBuilder _mb;
    54|             private int _typeId;
    55|             private readonly HashSet<string> _ignoresAccessAssemblyNames = new HashSet<string>();
    56|             private ConstructorInfo? _ignoresAccessChecksToAttributeConstructor;
    57|             [RequiresDynamicCode("Defining a dynamic assembly requires generating code at runtime")]
    58|             public ProxyAssembly(AssemblyLoadContext alc)
    59|             {
    60|                 AssemblyBuilderAccess builderAccess =
    61|                     alc.IsCollectible ? AssemblyBuilderAccess.RunAndCollect : AssemblyBuilderAccess.Run;
    62|                 _ab = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName("ProxyBuilder"), builderAccess);
    63|                 _mb = _ab.DefineDynamicModule("testmod");
    64|             }
    65|             internal ConstructorInfo IgnoresAccessChecksAttributeConstructor =>
    66|                 _ignoresAccessChecksToAttributeConstructor ??= IgnoreAccessChecksToAttributeBuilder.AddToModule(_mb);
    67|             public GeneratedTypeInfo GetProxyType(
    68|                 [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] Type baseType,
    69|                 [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type interfaceType)
    70|             {
    71|                 lock (_baseTypeAndInterfaceToGeneratedProxyType)
    72|                 {
    73|                     if (!_baseTypeAndInterfaceToGeneratedProxyType.TryGetValue(baseType, out Dictionary<Type, GeneratedTypeInfo>? interfaceToProxy))
    74|                     {
    75|                         interfaceToProxy = new Dictionary<Type, GeneratedTypeInfo>();
    76|                         _baseTypeAndInterfaceToGeneratedProxyType[baseType] = interfaceToProxy;
    77|                     }
    78|                     if (!interfaceToProxy.TryGetValue(interfaceType, out GeneratedTypeInfo? generatedProxy))
    79|                     {
    80|                         generatedProxy = GenerateProxyType(baseType, interfaceType);
    81|                         interfaceToProxy[interfaceType] = generatedProxy;
    82|                     }
    83|                     return generatedProxy;
    84|                 }
    85|             }
    86|             [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2062:UnrecognizedReflectionPattern",
    87|                 Justification = "interfaceType is annotated as preserve All members, so any Types returned from GetInterfaces should be preserved as well once https://github.com/mono/linker/issues/1731 is fixed.")]
    88|             [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2072:UnrecognizedReflectionPattern",
    89|                 Justification = "interfaceType is annotated as preserve All members, so any Types returned from GetInterfaces should be preserved as well once https://github.com/mono/linker/issues/1731 is fixed.")]
    90|             private GeneratedTypeInfo GenerateProxyType(
    91|                 [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] Type baseType,
    92|                 [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type interfaceType)
    93|             {
    94|                 if (!interfaceType.IsInterface)
    95|                 {
    96|                     throw new ArgumentException(SR.Format(SR.InterfaceType_Must_Be_Interface, interfaceType.FullName), "T");
    97|                 }
    98|                 if (baseType.IsSealed)
    99|                 {
   100|                     throw new ArgumentException(SR.Format(SR.BaseType_Cannot_Be_Sealed, baseType.FullName), "TProxy");
   101|                 }
   102|                 if (baseType.IsAbstract)
   103|                 {
   104|                     throw new ArgumentException(SR.Format(SR.BaseType_Cannot_Be_Abstract, baseType.FullName), "TProxy");
   105|                 }
   106|                 if (baseType.GetConstructor(Type.EmptyTypes) == null)
   107|                 {
   108|                     throw new ArgumentException(SR.Format(SR.BaseType_Must_Have_Default_Ctor, baseType.FullName), "TProxy");
   109|                 }
   110|                 ProxyBuilder pb = CreateProxy("generatedProxy", baseType);
   111|                 foreach (Type t in interfaceType.GetInterfaces())
   112|                     pb.AddInterfaceImpl(t);
   113|                 pb.AddInterfaceImpl(interfaceType);
   114|                 GeneratedTypeInfo generatedProxyType = pb.CreateType();
   115|                 return generatedProxyType;
   116|             }
   117|             [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2067:UnrecognizedReflectionPattern",
   118|                 Justification = "Only the parameterless ctor is referenced on proxyBaseType. Other members can be trimmed if unused.")]
   119|             private ProxyBuilder CreateProxy(
   120|                 string name,
   121|                 [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] Type proxyBaseType)
   122|             {
   123|                 int nextId = Interlocked.Increment(ref _typeId);
   124|                 TypeBuilder tb = _mb.DefineType(name + "_" + nextId, TypeAttributes.Public, proxyBaseType);
   125|                 return new ProxyBuilder(this, tb, proxyBaseType);
   126|             }
   127|             internal void GenerateInstanceOfIgnoresAccessChecksToAttribute(string assemblyName)
   128|             {
   129|                 ConstructorInfo attributeConstructor = IgnoresAccessChecksAttributeConstructor;
   130|                 CustomAttributeBuilder customAttributeBuilder =
   131|                     new CustomAttributeBuilder(attributeConstructor, new object[] { assemblyName });
   132|                 _ab.SetCustomAttribute(customAttributeBuilder);
   133|             }
   134|             internal void EnsureTypeIsVisible(Type type)
   135|             {
   136|                 if (!type.IsVisible)
   137|                 {
   138|                     string assemblyName = type.Assembly.GetName().Name!;
   139|                     if (_ignoresAccessAssemblyNames.Add(assemblyName))
   140|                     {
   141|                         GenerateInstanceOfIgnoresAccessChecksToAttribute(assemblyName);
   142|                     }
   143|                 }
   144|             }
   145|         }
   146|         private sealed class ProxyBuilder
   147|         {
   148|             private readonly ProxyAssembly _assembly;
   149|             private readonly TypeBuilder _tb;
   150|             [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)]
   151|             private readonly Type _proxyBaseType;
   152|             private readonly List<FieldBuilder> _fields;
   153|             private readonly List<MethodInfo> _methodInfos;
   154|             internal ProxyBuilder(
   155|                 ProxyAssembly assembly,
   156|                 TypeBuilder tb,
   157|                 [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] Type proxyBaseType)
   158|             {
   159|                 _assembly = assembly;
   160|                 _tb = tb;
   161|                 _proxyBaseType = proxyBaseType;
   162|                 _fields = new List<FieldBuilder>();
   163|                 _fields.Add(tb.DefineField("_methodInfos", typeof(MethodInfo[]), FieldAttributes.Private));
   164|                 _methodInfos = new List<MethodInfo>();
   165|                 _assembly.EnsureTypeIsVisible(proxyBaseType);
   166|             }
   167|             private void Complete()
   168|             {
   169|                 Type[] args = new Type[_fields.Count];
   170|                 for (int i = 0; i < args.Length; i++)
   171|                 {
   172|                     args[i] = _fields[i].FieldType;
   173|                 }
   174|                 ConstructorBuilder cb = _tb.DefineConstructor(MethodAttributes.Public, CallingConventions.HasThis, args);
   175|                 ILGenerator il = cb.GetILGenerator();
   176|                 ConstructorInfo baseCtor = _proxyBaseType.GetConstructor(Type.EmptyTypes)!;
   177|                 Debug.Assert(baseCtor != null);
   178|                 il.Emit(OpCodes.Ldarg_0);
   179|                 il.Emit(OpCodes.Call, baseCtor);
   180|                 for (int i = 0; i < args.Length; i++)
   181|                 {
   182|                     il.Emit(OpCodes.Ldarg_0);
   183|                     il.Emit(OpCodes.Ldarg, i + 1);
   184|                     il.Emit(OpCodes.Stfld, _fields[i]);
   185|                 }
   186|                 il.Emit(OpCodes.Ret);
   187|             }
   188|             internal GeneratedTypeInfo CreateType()
   189|             {
   190|                 this.Complete();
   191|                 return new GeneratedTypeInfo(_tb.CreateType(), _methodInfos.ToArray());
   192|             }
   193|             internal void AddInterfaceImpl([DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type iface)
   194|             {
   195|                 _assembly.EnsureTypeIsVisible(iface);
   196|                 _tb.AddInterfaceImplementation(iface);
   197|                 var propertyMap = new Dictionary<MethodInfo, PropertyAccessorInfo>();
   198|                 foreach (PropertyInfo pi in iface.GetRuntimeProperties())
   199|                 {
   200|                     var ai = new PropertyAccessorInfo(pi.GetMethod, pi.SetMethod);
   201|                     if (pi.GetMethod != null)
   202|                         propertyMap[pi.GetMethod] = ai;
   203|                     if (pi.SetMethod != null)
   204|                         propertyMap[pi.SetMethod] = ai;
   205|                 }
   206|                 var eventMap = new Dictionary<MethodInfo, EventAccessorInfo>();
   207|                 foreach (EventInfo ei in iface.GetRuntimeEvents())
   208|                 {
   209|                     var ai = new EventAccessorInfo(ei.AddMethod, ei.RemoveMethod, ei.RaiseMethod);
   210|                     if (ei.AddMethod != null)
   211|                         eventMap[ei.AddMethod] = ai;
   212|                     if (ei.RemoveMethod != null)
   213|                         eventMap[ei.RemoveMethod] = ai;
   214|                     if (ei.RaiseMethod != null)
   215|                         eventMap[ei.RaiseMethod] = ai;
   216|                 }
   217|                 foreach (MethodInfo mi in iface.GetRuntimeMethods())
   218|                 {
   219|                     if (!mi.IsVirtual || mi.IsFinal)
   220|                         continue;
   221|                     int methodInfoIndex = _methodInfos.Count;
   222|                     _methodInfos.Add(mi);
   223|                     MethodBuilder mdb = AddMethodImpl(mi, methodInfoIndex);
   224|                     if (propertyMap.TryGetValue(mi, out PropertyAccessorInfo? associatedProperty))
   225|                     {
   226|                         if (mi.Equals(associatedProperty.InterfaceGetMethod))
   227|                             associatedProperty.GetMethodBuilder = mdb;
   228|                         else
   229|                             associatedProperty.SetMethodBuilder = mdb;
   230|                     }
   231|                     if (eventMap.TryGetValue(mi, out EventAccessorInfo? associatedEvent))
   232|                     {
   233|                         if (mi.Equals(associatedEvent.InterfaceAddMethod))
   234|                             associatedEvent.AddMethodBuilder = mdb;
   235|                         else if (mi.Equals(associatedEvent.InterfaceRemoveMethod))
   236|                             associatedEvent.RemoveMethodBuilder = mdb;
   237|                         else
   238|                             associatedEvent.RaiseMethodBuilder = mdb;
   239|                     }
   240|                 }
   241|                 foreach (PropertyInfo pi in iface.GetRuntimeProperties())
   242|                 {
   243|                     PropertyAccessorInfo ai = propertyMap[pi.GetMethod ?? pi.SetMethod!];
   244|                     if (ai.GetMethodBuilder == null && ai.SetMethodBuilder == null)
   245|                         continue;
   246|                     PropertyBuilder pb = _tb.DefineProperty(pi.Name, pi.Attributes, pi.PropertyType, pi.GetIndexParameters().Select(p => p.ParameterType).ToArray());
   247|                     if (ai.GetMethodBuilder != null)
   248|                         pb.SetGetMethod(ai.GetMethodBuilder);
   249|                     if (ai.SetMethodBuilder != null)
   250|                         pb.SetSetMethod(ai.SetMethodBuilder);
   251|                 }
   252|                 foreach (EventInfo ei in iface.GetRuntimeEvents())
   253|                 {
   254|                     EventAccessorInfo ai = eventMap[ei.AddMethod ?? ei.RemoveMethod!];
   255|                     if (ai.AddMethodBuilder == null && ai.RemoveMethodBuilder == null && ai.RaiseMethodBuilder == null)
   256|                         continue;
   257|                     Debug.Assert(ei.EventHandlerType != null);
   258|                     EventBuilder eb = _tb.DefineEvent(ei.Name, ei.Attributes, ei.EventHandlerType!);
   259|                     if (ai.AddMethodBuilder != null)
   260|                         eb.SetAddOnMethod(ai.AddMethodBuilder);
   261|                     if (ai.RemoveMethodBuilder != null)
   262|                         eb.SetRemoveOnMethod(ai.RemoveMethodBuilder);
   263|                     if (ai.RaiseMethodBuilder != null)
   264|                         eb.SetRaiseMethod(ai.RaiseMethodBuilder);
   265|                 }
   266|             }
   267|             private MethodBuilder AddMethodImpl(MethodInfo mi, int methodInfoIndex)
   268|             {
   269|                 ParameterInfo[] parameters = mi.GetParameters();
   270|                 Type[] paramTypes = new Type[parameters.Length];
   271|                 Type[][] paramReqMods = new Type[paramTypes.Length][];
   272|                 for (int i = 0; i < parameters.Length; i++)
   273|                 {
   274|                     paramTypes[i] = parameters[i].ParameterType;
   275|                     paramReqMods[i] = parameters[i].GetRequiredCustomModifiers();
   276|                 }
   277|                 MethodBuilder mdb = _tb.DefineMethod(mi.Name, MethodAttributes.Public | MethodAttributes.Virtual, CallingConventions.Standard,
   278|                     mi.ReturnType, null, null,
   279|                     paramTypes, paramReqMods, null);
   280|                 if (mi.ContainsGenericParameters)
   281|                 {
   282|                     Type[] ts = mi.GetGenericArguments();
   283|                     string[] ss = new string[ts.Length];
   284|                     for (int i = 0; i < ts.Length; i++)
   285|                     {
   286|                         ss[i] = ts[i].Name;
   287|                     }
   288|                     GenericTypeParameterBuilder[] genericParameters = mdb.DefineGenericParameters(ss);
   289|                     for (int i = 0; i < genericParameters.Length; i++)
   290|                     {
   291|                         genericParameters[i].SetGenericParameterAttributes(ts[i].GenericParameterAttributes);
   292|                     }
   293|                 }
   294|                 ILGenerator il = mdb.GetILGenerator();
   295|                 ParametersArray args = new ParametersArray(il, paramTypes);
   296|                 il.Emit(OpCodes.Nop);
   297|                 GenericArray<object> argsArr = new GenericArray<object>(il, parameters.Length);
   298|                 for (int i = 0; i < parameters.Length; i++)
   299|                 {
   300|                     bool isOutRef = parameters[i].IsOut && parameters[i].ParameterType.IsByRef && !parameters[i].IsIn;
   301|                     if (!isOutRef)
   302|                     {
   303|                         argsArr.BeginSet(i);
   304|                         args.Get(i);
   305|                         argsArr.EndSet(parameters[i].ParameterType);
   306|                     }
   307|                 }
   308|                 LocalBuilder methodInfoLocal = il.DeclareLocal(typeof(MethodInfo));
   309|                 il.Emit(OpCodes.Ldarg_0);
   310|                 il.Emit(OpCodes.Ldfld, _fields[MethodInfosFieldAndCtorParameterIndex]); // MethodInfo[] _methodInfos
   311|                 il.Emit(OpCodes.Ldc_I4, methodInfoIndex);
   312|                 il.Emit(OpCodes.Ldelem_Ref);
   313|                 il.Emit(OpCodes.Stloc, methodInfoLocal);
   314|                 if (mi.ContainsGenericParameters)
   315|                 {
   316|                     il.Emit(OpCodes.Ldloc, methodInfoLocal);
   317|                     Type[] genericTypes = mi.GetGenericArguments();
   318|                     GenericArray<Type> typeArr = new GenericArray<Type>(il, genericTypes.Length);
   319|                     for (int i = 0; i < genericTypes.Length; ++i)
   320|                     {
   321|                         typeArr.BeginSet(i);
   322|                         il.Emit(OpCodes.Ldtoken, genericTypes[i]);
   323|                         il.Emit(OpCodes.Call, s_getTypeFromHandleMethod);
   324|                         typeArr.EndSet(typeof(Type));
   325|                     }
   326|                     typeArr.Load();
   327|                     il.Emit(OpCodes.Callvirt, s_makeGenericMethodMethod);
   328|                     il.Emit(OpCodes.Stloc, methodInfoLocal);
   329|                 }
   330|                 LocalBuilder? resultLocal = mi.ReturnType != typeof(void) ?
   331|                     il.DeclareLocal(typeof(object)) :
   332|                     null;
   333|                 il.Emit(OpCodes.Ldarg_0);
   334|                 il.Emit(OpCodes.Ldloc, methodInfoLocal);
   335|                 argsArr.Load();
   336|                 il.Emit(OpCodes.Callvirt, s_dispatchProxyInvokeMethod);
   337|                 if (resultLocal != null)
   338|                 {
   339|                     il.Emit(OpCodes.Stloc, resultLocal);
   340|                 }
   341|                 else
   342|                 {
   343|                     il.Emit(OpCodes.Pop);
   344|                 }
   345|                 for (int i = 0; i < parameters.Length; i++)
   346|                 {
   347|                     if (parameters[i].ParameterType.IsByRef)
   348|                     {
   349|                         args.BeginSet(i);
   350|                         argsArr.Get(i);
   351|                         args.EndSet(i, typeof(object));
   352|                     }
   353|                 }
   354|                 if (resultLocal != null)
   355|                 {
   356|                     il.Emit(OpCodes.Ldloc, resultLocal);
   357|                     Convert(il, typeof(object), mi.ReturnType, false);
   358|                 }
   359|                 il.Emit(OpCodes.Ret);
   360|                 _tb.DefineMethodOverride(mdb, mi);
   361|                 return mdb;
   362|             }
   363|             private static int GetTypeCode(Type type) => (int)Type.GetTypeCode(type);
   364|             private static readonly OpCode[] s_convOpCodes = new OpCode[] {
   365|                 OpCodes.Nop, //Empty = 0,
   366|                 OpCodes.Nop, //Object = 1,
   367|                 OpCodes.Nop, //DBNull = 2,
   368|                 OpCodes.Conv_I1, //Boolean = 3,
   369|                 OpCodes.Conv_I2, //Char = 4,
   370|                 OpCodes.Conv_I1, //SByte = 5,
   371|                 OpCodes.Conv_U1, //Byte = 6,
   372|                 OpCodes.Conv_I2, //Int16 = 7,
   373|                 OpCodes.Conv_U2, //UInt16 = 8,
   374|                 OpCodes.Conv_I4, //Int32 = 9,
   375|                 OpCodes.Conv_U4, //UInt32 = 10,
   376|                 OpCodes.Conv_I8, //Int64 = 11,
   377|                 OpCodes.Conv_U8, //UInt64 = 12,
   378|                 OpCodes.Conv_R4, //Single = 13,
   379|                 OpCodes.Conv_R8, //Double = 14,
   380|                 OpCodes.Nop, //Decimal = 15,
   381|                 OpCodes.Nop, //DateTime = 16,
   382|                 OpCodes.Nop, //17
   383|                 OpCodes.Nop, //String = 18,
   384|             };
   385|             private static readonly OpCode[] s_ldindOpCodes = new OpCode[] {
   386|                 OpCodes.Nop, //Empty = 0,
   387|                 OpCodes.Nop, //Object = 1,
   388|                 OpCodes.Nop, //DBNull = 2,
   389|                 OpCodes.Ldind_I1, //Boolean = 3,
   390|                 OpCodes.Ldind_I2, //Char = 4,
   391|                 OpCodes.Ldind_I1, //SByte = 5,
   392|                 OpCodes.Ldind_U1, //Byte = 6,
   393|                 OpCodes.Ldind_I2, //Int16 = 7,
   394|                 OpCodes.Ldind_U2, //UInt16 = 8,
   395|                 OpCodes.Ldind_I4, //Int32 = 9,
   396|                 OpCodes.Ldind_U4, //UInt32 = 10,
   397|                 OpCodes.Ldind_I8, //Int64 = 11,
   398|                 OpCodes.Ldind_I8, //UInt64 = 12,
   399|                 OpCodes.Ldind_R4, //Single = 13,
   400|                 OpCodes.Ldind_R8, //Double = 14,
   401|                 OpCodes.Nop, //Decimal = 15,
   402|                 OpCodes.Nop, //DateTime = 16,
   403|                 OpCodes.Nop, //17
   404|                 OpCodes.Ldind_Ref, //String = 18,
   405|             };
   406|             private static readonly OpCode[] s_stindOpCodes = new OpCode[] {
   407|                 OpCodes.Nop, //Empty = 0,
   408|                 OpCodes.Nop, //Object = 1,
   409|                 OpCodes.Nop, //DBNull = 2,
   410|                 OpCodes.Stind_I1, //Boolean = 3,
   411|                 OpCodes.Stind_I2, //Char = 4,
   412|                 OpCodes.Stind_I1, //SByte = 5,
   413|                 OpCodes.Stind_I1, //Byte = 6,
   414|                 OpCodes.Stind_I2, //Int16 = 7,
   415|                 OpCodes.Stind_I2, //UInt16 = 8,
   416|                 OpCodes.Stind_I4, //Int32 = 9,
   417|                 OpCodes.Stind_I4, //UInt32 = 10,
   418|                 OpCodes.Stind_I8, //Int64 = 11,
   419|                 OpCodes.Stind_I8, //UInt64 = 12,
   420|                 OpCodes.Stind_R4, //Single = 13,
   421|                 OpCodes.Stind_R8, //Double = 14,
   422|                 OpCodes.Nop, //Decimal = 15,
   423|                 OpCodes.Nop, //DateTime = 16,
   424|                 OpCodes.Nop, //17
   425|                 OpCodes.Stind_Ref, //String = 18,
   426|             };
   427|             private static void Convert(ILGenerator il, Type source, Type target, bool isAddress)
   428|             {
   429|                 Debug.Assert(!target.IsByRef);
   430|                 if (target == source)
   431|                     return;
   432|                 if (source.IsByRef)
   433|                 {
   434|                     Debug.Assert(!isAddress);
   435|                     Type argType = source.GetElementType()!;
   436|                     Ldind(il, argType);
   437|                     Convert(il, argType, target, isAddress);
   438|                     return;
   439|                 }
   440|                 if (target.IsValueType)
   441|                 {
   442|                     if (source.IsValueType)
   443|                     {
   444|                         OpCode opCode = s_convOpCodes[GetTypeCode(target)];
   445|                         Debug.Assert(!opCode.Equals(OpCodes.Nop));
   446|                         il.Emit(opCode);
   447|                     }
   448|                     else
   449|                     {
   450|                         Debug.Assert(source.IsAssignableFrom(target));
   451|                         il.Emit(OpCodes.Unbox, target);
   452|                         if (!isAddress)
   453|                             Ldind(il, target);
   454|                     }
   455|                 }
   456|                 else if (target.IsAssignableFrom(source))
   457|                 {
   458|                     if (source.IsValueType || source.IsGenericParameter)
   459|                     {
   460|                         if (isAddress)
   461|                             Ldind(il, source);
   462|                         il.Emit(OpCodes.Box, source);
   463|                     }
   464|                 }
   465|                 else
   466|                 {
   467|                     Debug.Assert(source.IsAssignableFrom(target) || target.IsInterface || source.IsInterface);
   468|                     if (target.IsGenericParameter)
   469|                     {
   470|                         il.Emit(OpCodes.Unbox_Any, target);
   471|                     }
   472|                     else
   473|                     {
   474|                         il.Emit(OpCodes.Castclass, target);
   475|                     }
   476|                 }
   477|             }
   478|             private static void Ldind(ILGenerator il, Type type)
   479|             {
   480|                 OpCode opCode = s_ldindOpCodes[GetTypeCode(type)];
   481|                 if (!opCode.Equals(OpCodes.Nop))
   482|                 {
   483|                     il.Emit(opCode);
   484|                 }
   485|                 else
   486|                 {
   487|                     il.Emit(OpCodes.Ldobj, type);
   488|                 }
   489|             }
   490|             private static void Stind(ILGenerator il, Type type)
   491|             {
   492|                 OpCode opCode = s_stindOpCodes[GetTypeCode(type)];
   493|                 if (!opCode.Equals(OpCodes.Nop))
   494|                 {
   495|                     il.Emit(opCode);
   496|                 }
   497|                 else
   498|                 {
   499|                     il.Emit(OpCodes.Stobj, type);
   500|                 }
   501|             }
   502|             private sealed class ParametersArray
   503|             {
   504|                 private readonly ILGenerator _il;
   505|                 private readonly Type[] _paramTypes;
   506|                 internal ParametersArray(ILGenerator il, Type[] paramTypes)
   507|                 {
   508|                     _il = il;
   509|                     _paramTypes = paramTypes;
   510|                 }
   511|                 internal void Get(int i)
   512|                 {
   513|                     _il.Emit(OpCodes.Ldarg, i + 1);
   514|                 }
   515|                 internal void BeginSet(int i)
   516|                 {
   517|                     _il.Emit(OpCodes.Ldarg, i + 1);
   518|                 }
   519|                 internal void EndSet(int i, Type stackType)
   520|                 {
   521|                     Debug.Assert(_paramTypes[i].IsByRef);
   522|                     Type argType = _paramTypes[i].GetElementType()!;
   523|                     Convert(_il, stackType, argType, false);
   524|                     Stind(_il, argType);
   525|                 }
   526|             }
   527|             private sealed class GenericArray<T>
   528|             {
   529|                 private readonly ILGenerator _il;
   530|                 private readonly LocalBuilder _lb;
   531|                 internal GenericArray(ILGenerator il, int len)
   532|                 {
   533|                     _il = il;
   534|                     _lb = il.DeclareLocal(typeof(T[]));
   535|                     il.Emit(OpCodes.Ldc_I4, len);
   536|                     il.Emit(OpCodes.Newarr, typeof(T));
   537|                     il.Emit(OpCodes.Stloc, _lb);
   538|                 }
   539|                 internal void Load()
   540|                 {
   541|                     _il.Emit(OpCodes.Ldloc, _lb);
   542|                 }
   543|                 internal void Get(int i)
   544|                 {
   545|                     _il.Emit(OpCodes.Ldloc, _lb);
   546|                     _il.Emit(OpCodes.Ldc_I4, i);
   547|                     _il.Emit(OpCodes.Ldelem_Ref);
   548|                 }
   549|                 internal void BeginSet(int i)
   550|                 {
   551|                     _il.Emit(OpCodes.Ldloc, _lb);
   552|                     _il.Emit(OpCodes.Ldc_I4, i);
   553|                 }
   554|                 internal void EndSet(Type stackType)
   555|                 {
   556|                     Convert(_il, stackType, typeof(T), false);
   557|                     _il.Emit(OpCodes.Stelem_Ref);
   558|                 }
   559|             }
   560|             private sealed class PropertyAccessorInfo
   561|             {
   562|                 public MethodInfo? InterfaceGetMethod { get; }
   563|                 public MethodInfo? InterfaceSetMethod { get; }
   564|                 public MethodBuilder? GetMethodBuilder { get; set; }
   565|                 public MethodBuilder? SetMethodBuilder { get; set; }
   566|                 public PropertyAccessorInfo(MethodInfo? interfaceGetMethod, MethodInfo? interfaceSetMethod)
   567|                 {
   568|                     InterfaceGetMethod = interfaceGetMethod;
   569|                     InterfaceSetMethod = interfaceSetMethod;
   570|                 }
   571|             }
   572|             private sealed class EventAccessorInfo
   573|             {
   574|                 public MethodInfo? InterfaceAddMethod { get; }
   575|                 public MethodInfo? InterfaceRemoveMethod { get; }
   576|                 public MethodInfo? InterfaceRaiseMethod { get; }
   577|                 public MethodBuilder? AddMethodBuilder { get; set; }
   578|                 public MethodBuilder? RemoveMethodBuilder { get; set; }
   579|                 public MethodBuilder? RaiseMethodBuilder { get; set; }
   580|                 public EventAccessorInfo(MethodInfo? interfaceAddMethod, MethodInfo? interfaceRemoveMethod, MethodInfo? interfaceRaiseMethod)
   581|                 {
   582|                     InterfaceAddMethod = interfaceAddMethod;
   583|                     InterfaceRemoveMethod = interfaceRemoveMethod;
   584|                     InterfaceRaiseMethod = interfaceRaiseMethod;
   585|                 }
   586|             }
   587|         }
   588|     }
   589| }


# ====================================================================
# FILE: src/libraries/shims/src/mscorlib.forwards.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-105 ---
     1| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.GenericComparer<>))]
     2| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.NullableComparer<>))]
     3| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.ObjectComparer<>))]
     4| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.GenericEqualityComparer<>))]
     5| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.NullableEqualityComparer<>))]
     6| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.ObjectEqualityComparer<>))]
     7| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.NonRandomizedStringEqualityComparer))]
     8| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.ByteEqualityComparer))]
     9| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.EnumEqualityComparer<>))]
    10| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.ListDictionaryInternal))]
    11| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.CultureAwareComparer))]
    12| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.OrdinalComparer))]
    13| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.UnitySerializationHolder))]
    14| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.Contracts.ContractException))]
    15| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.HashCode))]
    16| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.IAsyncDisposable))]
    17| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Index))]
    18| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.MathF))]
    19| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.MemoryExtensions))]
    20| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Memory<>))]
    21| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Range))]
    22| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.ReadOnlyMemory<>))]
    23| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.ReadOnlySpan<>))]
    24| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.SequencePosition))]
    25| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Span<>))]
    26| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.ArrayBufferWriter<>))]
    27| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.ArrayPool<>))]
    28| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.BuffersExtensions))]
    29| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.IBufferWriter<>))]
    30| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.IMemoryOwner<>))]
    31| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.IPinnable))]
    32| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.MemoryHandle))]
    33| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.MemoryManager<>))]
    34| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.MemoryPool<>))]
    35| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.OperationStatus))]
    36| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.ReadOnlySequenceSegment<>))]
    37| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.ReadOnlySequence<>))]
    38| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.ReadOnlySpanAction<,>))]
    39| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.SequenceReaderExtensions))]
    40| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.SequenceReader<>))]
    41| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.SpanAction<,>))]
    42| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.StandardFormat))]
    43| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.Binary.BinaryPrimitives))]
    44| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.Text.Base64))]
    45| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.Text.Utf8Formatter))]
    46| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Buffers.Text.Utf8Parser))]
    47| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.CollectionExtensions))]
    48| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.IAsyncEnumerable<>))]
    49| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.IAsyncEnumerator<>))]
    50| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.KeyValuePair))]
    51| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.Queue<>))]
    52| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Collections.Generic.Stack<>))]
    53| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.CodeAnalysis.AllowNullAttribute))]
    54| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.CodeAnalysis.DisallowNullAttribute))]
    55| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute))]
    56| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute))]
    57| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.CodeAnalysis.MaybeNullAttribute))]
    58| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute))]
    59| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.CodeAnalysis.NotNullAttribute))]
    60| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute))]
    61| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.CodeAnalysis.NotNullWhenAttribute))]
    62| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.Tracing.DiagnosticCounter))]
    63| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.Tracing.EventCounter))]
    64| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.Tracing.IncrementingEventCounter))]
    65| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.Tracing.IncrementingPollingCounter))]
    66| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Diagnostics.Tracing.PollingCounter))]
    67| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Globalization.ISOWeek))]
    68| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.IO.EnumerationOptions))]
    69| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.IO.MatchCasing))]
    70| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.IO.MatchType))]
    71| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.IO.Enumeration.FileSystemEntry))]
    72| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.IO.Enumeration.FileSystemEnumerable<>))]
    73| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.IO.Enumeration.FileSystemEnumerator<>))]
    74| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.IO.Enumeration.FileSystemName))]
    75| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Numerics.Vector))]
    76| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Numerics.Vector<>))]
    77| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Reflection.AssemblyExtensions))]
    78| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Reflection.EventInfoExtensions))]
    79| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Reflection.MemberInfoExtensions))]
    80| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Reflection.MethodInfoExtensions))]
    81| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Reflection.ModuleExtensions))]
    82| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Reflection.PropertyInfoExtensions))]
    83| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Reflection.TypeExtensions))]
    84| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.AsyncIteratorMethodBuilder))]
    85| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.AsyncIteratorStateMachineAttribute))]
    86| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.AsyncMethodBuilderAttribute))]
    87| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder))]
    88| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder<>))]
    89| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.ConfiguredAsyncDisposable))]
    90| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable<>))]
    91| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable))]
    92| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable<>))]
    93| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.EnumeratorCancellationAttribute))]
    94| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.ValueTaskAwaiter))]
    95| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.CompilerServices.ValueTaskAwaiter<>))]
    96| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.InteropServices.MemoryMarshal))]
    97| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Runtime.InteropServices.SequenceMarshal))]
    98| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Threading.Tasks.TaskAsyncEnumerableExtensions))]
    99| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Threading.Tasks.ValueTask))]
   100| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Threading.Tasks.ValueTask<>))]
   101| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Threading.Tasks.Sources.IValueTaskSource))]
   102| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Threading.Tasks.Sources.IValueTaskSource<>))]
   103| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore<>))]
   104| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags))]
   105| [assembly:System.Runtime.CompilerServices.TypeForwardedTo(typeof(System.Threading.Tasks.Sources.ValueTaskSourceStatus))]


# ====================================================================
# FILE: src/mono/mono/eventpipe/ep-rt-mono.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-6297 ---
     1| #include <config.h>
     2| #ifdef ENABLE_PERFTRACING
     3| #include <eventpipe/ep-rt-config.h>
     4| #include <eventpipe/ep-types.h>
     5| #include <eventpipe/ep-rt.h>
     6| #include <eventpipe/ep.h>
     7| #include <eventpipe/ep-event.h>
     8| #include <eglib/gmodule.h>
     9| #include <mono/utils/mono-lazy-init.h>
    10| #include <mono/utils/mono-time.h>
    11| #include <mono/utils/mono-proclib.h>
    12| #include <mono/utils/mono-threads.h>
    13| #include <mono/utils/mono-rand.h>
    14| #include <mono/metadata/profiler.h>
    15| #include <mono/metadata/appdomain.h>
    16| #include <mono/metadata/assembly.h>
    17| #include <mono/metadata/assembly-internals.h>
    18| #include <mono/metadata/class-internals.h>
    19| #include <mono/metadata/debug-internals.h>
    20| #include <mono/metadata/gc-internals.h>
    21| #include <mono/metadata/profiler-private.h>
    22| #include <mono/metadata/cil-coff.h>
    23| #include <mono/metadata/mono-endian.h>
    24| #include <mono/mini/mini-runtime.h>
    25| #include <mono/sgen/sgen-conf.h>
    26| #include <mono/sgen/sgen-tagged-pointer.h>
    27| #include <mono/utils/mono-logger-internals.h>
    28| #include <minipal/getexepath.h>
    29| #include <runtime_version.h>
    30| #include <clretwallmain.h>
    31| extern void InitProvidersAndEvents (void);
    32| gboolean _ep_rt_mono_initialized;
    33| MonoNativeTlsKey _ep_rt_mono_thread_holder_tls_id;
    34| MonoNativeTlsKey _ep_rt_mono_thread_data_tls_id;
    35| gpointer _ep_rt_mono_rand_provider;
    36| ep_rt_spin_lock_handle_t _ep_rt_mono_config_lock = {0};
    37| mono_lazy_init_t _ep_rt_mono_os_cmd_line_init = MONO_LAZY_INIT_STATUS_NOT_INITIALIZED;
    38| char *_ep_rt_mono_os_cmd_line = NULL;
    39| mono_lazy_init_t _ep_rt_mono_managed_cmd_line_init = MONO_LAZY_INIT_STATUS_NOT_INITIALIZED;
    40| char *_ep_rt_mono_managed_cmd_line = NULL;
    41| typedef struct _EventPipeThreadData EventPipeThreadData;
    42| struct _EventPipeThreadData {
    43| 	bool prevent_profiler_event_recursion;
    44| };
    45| static GArray * _ep_rt_mono_sampled_thread_callstacks = NULL;
    46| static uint32_t _ep_rt_mono_max_sampled_thread_count = 32;
    47| static MonoProfilerHandle _ep_rt_default_profiler = NULL;
    48| static MonoProfilerHandle _ep_rt_dotnet_runtime_profiler_provider = NULL;
    49| static MonoProfilerHandle _ep_rt_dotnet_mono_profiler_provider = NULL;
    50| static MonoProfilerHandle _ep_rt_dotnet_mono_profiler_heap_collect_provider = NULL;
    51| static MonoCallSpec _ep_rt_dotnet_mono_profiler_provider_callspec = {0};
    52| MonoMethod *_ep_rt_mono_runtime_helper_compile_method = NULL;
    53| MonoJitInfo *_ep_rt_mono_runtime_helper_compile_method_jitinfo = NULL;
    54| MonoMethod *_ep_rt_mono_monitor_enter_method = NULL;
    55| MonoJitInfo *_ep_rt_mono_monitor_enter_method_jitinfo = NULL;
    56| MonoMethod *_ep_rt_mono_monitor_enter_v4_method = NULL;
    57| MonoJitInfo *_ep_rt_mono_monitor_enter_v4_method_jitinfo = NULL;
    58| typedef
    59| bool
    60| (*ep_rt_mono_fire_method_rundown_events_func)(
    61| 	const uint64_t method_id,
    62| 	const uint64_t module_id,
    63| 	const uint64_t method_start_address,
    64| 	const uint32_t method_size,
    65| 	const uint32_t method_token,
    66| 	const uint32_t method_flags,
    67| 	const ep_char8_t *method_namespace,
    68| 	const ep_char8_t *method_name,
    69| 	const ep_char8_t *method_signature,
    70| 	const uint16_t count_of_map_entries,
    71| 	const uint32_t *il_offsets,
    72| 	const uint32_t *native_offsets,
    73| 	bool aot_method,
    74| 	bool verbose,
    75| 	void *user_data);
    76| typedef
    77| bool
    78| (*ep_rt_mono_fire_assembly_rundown_events_func)(
    79| 	const uint64_t domain_id,
    80| 	const uint64_t assembly_id,
    81| 	const uint32_t assembly_flags,
    82| 	const uint32_t binding_id,
    83| 	const ep_char8_t *assembly_name,
    84| 	const uint64_t module_id,
    85| 	const uint32_t module_flags,
    86| 	const uint32_t reserved_flags,
    87| 	const ep_char8_t *module_il_path,
    88| 	const ep_char8_t *module_native_path,
    89| 	const uint8_t *managed_pdb_signature,
    90| 	const uint32_t managed_pdb_age,
    91| 	const ep_char8_t *managed_pdb_build_path,
    92| 	const uint8_t *native_pdb_signature,
    93| 	const uint32_t native_pdb_age,
    94| 	const ep_char8_t *native_pdb_build_path,
    95| 	void *user_data);
    96| typedef
    97| bool
    98| (*ep_rt_mono_fire_domain_rundown_events_func)(
    99| 	const uint64_t domain_id,
   100| 	const uint32_t domain_flags,
   101| 	const ep_char8_t *domain_name,
   102| 	const uint32_t domain_index,
   103| 	void *user_data);
   104| typedef struct _EventPipeFireMethodEventsData {
   105| 	MonoDomain *domain;
   106| 	uint8_t *buffer;
   107| 	size_t buffer_size;
   108| 	ep_rt_mono_fire_method_rundown_events_func method_events_func;
   109| } EventPipeFireMethodEventsData;
   110| typedef struct _EventPipeStackWalkData {
   111| 	EventPipeStackContents *stack_contents;
   112| 	bool top_frame;
   113| 	bool async_frame;
   114| 	bool safe_point_frame;
   115| 	bool runtime_invoke_frame;
   116| } EventPipeStackWalkData;
   117| typedef struct _EventPipeSampleProfileStackWalkData {
   118| 	EventPipeStackWalkData stack_walk_data;
   119| 	EventPipeStackContents stack_contents;
   120| 	uint64_t thread_id;
   121| 	uintptr_t thread_ip;
   122| 	uint32_t payload_data;
   123| } EventPipeSampleProfileStackWalkData;
   124| #define RUNTIME_SKU_MONO 0x4
   125| #define METHOD_FLAGS_DYNAMIC_METHOD 0x1
   126| #define METHOD_FLAGS_GENERIC_METHOD 0x2
   127| #define METHOD_FLAGS_SHARED_GENERIC_METHOD 0x4
   128| #define METHOD_FLAGS_JITTED_METHOD 0x8
   129| #define METHOD_FLAGS_JITTED_HELPER_METHOD 0x10
   130| #define METHOD_FLAGS_EXTENT_HOT_SECTION 0x00000000
   131| #define METHOD_FLAGS_EXTENT_COLD_SECTION 0x10000000
   132| #define MODULE_FLAGS_NATIVE_MODULE 0x2
   133| #define MODULE_FLAGS_DYNAMIC_MODULE 0x4
   134| #define MODULE_FLAGS_MANIFEST_MODULE 0x8
   135| #define ASSEMBLY_FLAGS_DYNAMIC_ASSEMBLY 0x2
   136| #define ASSEMBLY_FLAGS_NATIVE_ASSEMBLY 0x4
   137| #define ASSEMBLY_FLAGS_COLLECTIBLE_ASSEMBLY 0x8
   138| #define DOMAIN_FLAGS_DEFAULT_DOMAIN 0x1
   139| #define DOMAIN_FLAGS_EXECUTABLE_DOMAIN 0x2
   140| struct _ModuleEventData {
   141| 	uint8_t module_il_pdb_signature [EP_GUID_SIZE];
   142| 	uint8_t module_native_pdb_signature [EP_GUID_SIZE];
   143| 	uint64_t domain_id;
   144| 	uint64_t module_id;
   145| 	uint64_t assembly_id;
   146| 	const char *module_il_path;
   147| 	const char *module_il_pdb_path;
   148| 	const char *module_native_path;
   149| 	const char *module_native_pdb_path;
   150| 	uint32_t module_il_pdb_age;
   151| 	uint32_t module_native_pdb_age;
   152| 	uint32_t reserved_flags;
   153| 	uint32_t module_flags;
   154| };
   155| typedef struct _ModuleEventData ModuleEventData;
   156| struct _AssemblyEventData {
   157| 	uint64_t domain_id;
   158| 	uint64_t assembly_id;
   159| 	uint64_t binding_id;
   160| 	char *assembly_name;
   161| 	uint32_t assembly_flags;
   162| };
   163| typedef struct _AssemblyEventData AssemblyEventData;
   164| #define THREAD_FLAGS_GC_SPECIAL 0x00000001
   165| #define THREAD_FLAGS_FINALIZER 0x00000002
   166| #define THREAD_FLAGS_THREADPOOL_WORKER 0x00000004
   167| #define EXCEPTION_THROWN_FLAGS_HAS_INNER 0x1
   168| #define EXCEPTION_THROWN_FLAGS_IS_NESTED 0x2
   169| #define EXCEPTION_THROWN_FLAGS_IS_RETHROWN 0x4
   170| #define EXCEPTION_THROWN_FLAGS_IS_CSE 0x8
   171| #define EXCEPTION_THROWN_FLAGS_IS_CLS_COMPLIANT 0x10
   172| #define GC_KEYWORD 0x1
   173| #define GC_HANDLE_KEYWORD 0x2
   174| #define LOADER_KEYWORD 0x8
   175| #define JIT_KEYWORD 0x10
   176| #define APP_DOMAIN_RESOURCE_MANAGEMENT_KEYWORD 0x800
   177| #define CONTENTION_KEYWORD 0x4000
   178| #define EXCEPTION_KEYWORD 0x8000
   179| #define THREADING_KEYWORD 0x10000
   180| #define GC_HEAP_DUMP_KEYWORD 0x100000
   181| #define GC_ALLOCATION_KEYWORD 0x200000
   182| #define GC_MOVES_KEYWORD 0x400000
   183| #define GC_HEAP_COLLECT_KEYWORD 0x800000
   184| #define GC_FINALIZATION_KEYWORD 0x1000000
   185| #define GC_RESIZE_KEYWORD 0x2000000
   186| #define GC_ROOT_KEYWORD 0x4000000
   187| #define GC_HEAP_DUMP_VTABLE_CLASS_REF_KEYWORD 0x8000000
   188| #define METHOD_TRACING_KEYWORD 0x20000000
   189| #define TYPE_DIAGNOSTIC_KEYWORD 0x8000000000
   190| #define TYPE_LOADING_KEYWORD 0x8000000000
   191| #define MONITOR_KEYWORD 0x10000000000
   192| #define METHOD_INSTRUMENTATION_KEYWORD 0x40000000000
   193| typedef enum {
   194| 	MONO_PROFILER_BUFFERED_GC_EVENT = 1,
   195| 	MONO_PROFILER_BUFFERED_GC_EVENT_RESIZE = 2,
   196| 	MONO_PROFILER_BUFFERED_GC_EVENT_ROOTS = 3,
   197| 	MONO_PROFILER_BUFFERED_GC_EVENT_MOVES = 4,
   198| 	MONO_PROFILER_BUFFERED_GC_EVENT_OBJECT_REF = 5,
   199| 	MONO_PROFILER_BUFFERED_GC_EVENT_ROOT_REGISTER = 6,
   200| 	MONO_PROFILER_BUFFERED_GC_EVENT_ROOT_UNREGISTER = 7
   201| } MonoProfilerBufferedGCEventType;
   202| typedef struct _MonoProfilerBufferedGCEvent MonoProfilerBufferedGCEvent;
   203| struct _MonoProfilerBufferedGCEvent {
   204| 	MonoProfilerBufferedGCEventType type;
   205| 	uint32_t payload_size;
   206| };
   207| #define MONO_PROFILER_MEM_DEFAULT_BLOCK_SIZE (mono_pagesize() * 16)
   208| #define MONO_PROFILER_MEM_BLOCK_SIZE_INC (mono_pagesize())
   209| typedef struct _MonoProfilerMemBlock MonoProfilerMemBlock;
   210| struct _MonoProfilerMemBlock {
   211| 	MonoProfilerMemBlock *next;
   212| 	MonoProfilerMemBlock *prev;
   213| 	uint8_t *start;
   214| 	uint32_t alloc_size;
   215| 	uint32_t size;
   216| 	uint32_t offset;
   217| 	uint32_t last_used_offset;
   218| };
   219| static volatile MonoProfilerMemBlock *_ep_rt_mono_profiler_mem_blocks = NULL;
   220| static volatile MonoProfilerMemBlock *_ep_rt_mono_profiler_current_mem_block = NULL;
   221| static volatile uint32_t _ep_rt_mono_profiler_gc_heap_collect_requests = 0;
   222| static volatile uint32_t _ep_rt_mono_profiler_gc_heap_collect_in_progress = 0;
   223| static bool _ep_rt_mono_profiler_gc_can_collect_heap = false;
   224| static GSList *_ep_rt_mono_profiler_provider_params = NULL;
   225| static GQueue *_ep_rt_mono_profiler_gc_heap_collect_request_params = NULL;
   226| typedef uint32_t mono_profiler_gc_state_t;
   227| typedef uint16_t mono_profiler_gc_state_count_t;
   228| #define MONO_PROFILER_GC_STATE_GET_FIRE_EVENT_COUNT(x) ((mono_profiler_gc_state_count_t)((x & 0xFFFF)))
   229| #define MONO_PROFILER_GC_STATE_INC_FIRE_EVENT_COUNT(x) ((mono_profiler_gc_state_t)((mono_profiler_gc_state_t)(x & 0xFFFF0000) | (mono_profiler_gc_state_t)(MONO_PROFILER_GC_STATE_GET_FIRE_EVENT_COUNT(x) + 1)))
   230| #define MONO_PROFILER_GC_STATE_DEC_FIRE_EVENT_COUNT(x) ((mono_profiler_gc_state_t)((mono_profiler_gc_state_t)(x & 0xFFFF0000) | (mono_profiler_gc_state_t)(MONO_PROFILER_GC_STATE_GET_FIRE_EVENT_COUNT(x) - 1)))
   231| #define MONO_PROFILER_GC_STATE_GC_IN_PROGRESS_START(x) ((mono_profiler_gc_state_t)((mono_profiler_gc_state_t)(0xFFFF << 16) | (mono_profiler_gc_state_t)MONO_PROFILER_GC_STATE_GET_FIRE_EVENT_COUNT(x)))
   232| #define MONO_PROFILER_GC_STATE_IS_GC_IN_PROGRESS(x) (((x >> 16) & 0xFFFF) == 0xFFFF)
   233| #define MONO_PROFILER_GC_STATE_GC_IN_PROGRESS_STOP(x) ((mono_profiler_gc_state_t)((mono_profiler_gc_state_t)MONO_PROFILER_GC_STATE_GET_FIRE_EVENT_COUNT(x)))
   234| static volatile mono_profiler_gc_state_t _ep_rt_mono_profiler_gc_state = 0;
   235| static ep_rt_spin_lock_handle_t _ep_rt_mono_profiler_gc_state_lock = {0};
   236| /*
   237|  * Forward declares of all static functions.
   238|  */
   239| static
   240| EventPipeThreadData *
   241| eventpipe_thread_data_get_or_create (void);
   242| static
   243| void
   244| eventpipe_thread_data_free (EventPipeThreadData *thread_data);
   245| static
   246| bool
   247| fire_method_rundown_events_func (
   248| 	const uint64_t method_id,
   249| 	const uint64_t module_id,
   250| 	const uint64_t method_start_address,
   251| 	const uint32_t method_size,
   252| 	const uint32_t method_token,
   253| 	const uint32_t method_flags,
   254| 	const ep_char8_t *method_namespace,
   255| 	const ep_char8_t *method_name,
   256| 	const ep_char8_t *method_signature,
   257| 	const uint16_t count_of_map_entries,
   258| 	const uint32_t *il_offsets,
   259| 	const uint32_t *native_offsets,
   260| 	bool aot_method,
   261| 	bool verbose,
   262| 	void *user_data);
   263| static
   264| bool
   265| fire_assembly_rundown_events_func (
   266| 	const uint64_t domain_id,
   267| 	const uint64_t assembly_id,
   268| 	const uint32_t assembly_flags,
   269| 	const uint32_t binding_id,
   270| 	const ep_char8_t *assembly_name,
   271| 	const uint64_t module_id,
   272| 	const uint32_t module_flags,
   273| 	const uint32_t reserved_flags,
   274| 	const ep_char8_t *module_il_path,
   275| 	const ep_char8_t *module_native_path,
   276| 	const uint8_t *managed_pdb_signature,
   277| 	const uint32_t managed_pdb_age,
   278| 	const ep_char8_t *managed_pdb_build_path,
   279| 	const uint8_t *native_pdb_signature,
   280| 	const uint32_t native_pdb_age,
   281| 	const ep_char8_t *native_pdb_build_path,
   282| 	void *user_data);
   283| static
   284| bool
   285| fire_domain_rundown_events_func (
   286| 	const uint64_t domain_id,
   287| 	const uint32_t domain_flags,
   288| 	const ep_char8_t *domain_name,
   289| 	const uint32_t domain_index,
   290| 	void *user_data);
   291| static
   292| void
   293| eventpipe_fire_method_events (
   294| 	MonoJitInfo *ji,
   295| 	MonoMethod *method,
   296| 	EventPipeFireMethodEventsData *events_data);
   297| static
   298| void
   299| eventpipe_fire_method_events_func (
   300| 	MonoJitInfo *ji,
   301| 	void *user_data);
   302| static
   303| void
   304| eventpipe_fire_assembly_events (
   305| 	MonoDomain *domain,
   306| 	MonoAssembly *assembly,
   307| 	ep_rt_mono_fire_assembly_rundown_events_func assembly_events_func);
   308| static
   309| gboolean
   310| eventpipe_execute_rundown (
   311| 	ep_rt_mono_fire_domain_rundown_events_func domain_events_func,
   312| 	ep_rt_mono_fire_assembly_rundown_events_func assembly_events_func,
   313| 	ep_rt_mono_fire_method_rundown_events_func methods_events_func);
   314| static
   315| gboolean
   316| eventpipe_walk_managed_stack_for_thread (
   317| 	MonoStackFrameInfo *frame,
   318| 	MonoContext *ctx,
   319| 	EventPipeStackWalkData *stack_walk_data);
   320| static
   321| gboolean
   322| eventpipe_walk_managed_stack_for_thread_func (
   323| 	MonoStackFrameInfo *frame,
   324| 	MonoContext *ctx,
   325| 	void *data);
   326| static
   327| gboolean
   328| eventpipe_sample_profiler_walk_managed_stack_for_thread_func (
   329| 	MonoStackFrameInfo *frame,
   330| 	MonoContext *ctx,
   331| 	void *data);
   332| static
   333| void
   334| profiler_eventpipe_runtime_initialized (MonoProfiler *prof);
   335| static
   336| void
   337| profiler_eventpipe_thread_exited (
   338| 	MonoProfiler *prof,
   339| 	uintptr_t tid);
   340| static
   341| bool
   342| parse_mono_profiler_options (const ep_char8_t *option);
   343| static
   344| bool
   345| get_module_event_data (
   346| 	MonoImage *image,
   347| 	ModuleEventData *module_data);
   348| static
   349| bool
   350| get_assembly_event_data (
   351| 	MonoAssembly *assembly,
   352| 	AssemblyEventData *assembly_data);
   353| static
   354| uint32_t
   355| get_type_start_id (MonoType *type);
   356| static
   357| gboolean
   358| get_exception_ip_func (
   359| 	MonoStackFrameInfo *frame,
   360| 	MonoContext *ctx,
   361| 	void *data);
   362| static
   363| void
   364| runtime_profiler_jit_begin (
   365| 	MonoProfiler *prof,
   366| 	MonoMethod *method);
   367| static
   368| void
   369| runtime_profiler_jit_failed (
   370| 	MonoProfiler *prof,
   371| 	MonoMethod *method);
   372| static
   373| void
   374| runtime_profiler_jit_done (
   375| 	MonoProfiler *prof,
   376| 	MonoMethod *method,
   377| 	MonoJitInfo *ji);
   378| static
   379| void
   380| runtime_profiler_image_loaded (
   381| 	MonoProfiler *prof,
   382| 	MonoImage *image);
   383| static
   384| void
   385| runtime_profiler_image_unloaded (
   386| 	MonoProfiler *prof,
   387| 	MonoImage *image);
   388| static
   389| void
   390| runtime_profiler_assembly_loaded (
   391| 	MonoProfiler *prof,
   392| 	MonoAssembly *assembly);
   393| static
   394| void
   395| runtime_profiler_assembly_unloaded (
   396| 	MonoProfiler *prof,
   397| 	MonoAssembly *assembly);
   398| static
   399| void
   400| runtime_profiler_thread_started (
   401| 	MonoProfiler *prof,
   402| 	uintptr_t tid);
   403| static
   404| void
   405| runtime_profiler_thread_stopped (
   406| 	MonoProfiler *prof,
   407| 	uintptr_t tid);
   408| static
   409| void
   410| runtime_profiler_class_loading (
   411| 	MonoProfiler *prof,
   412| 	MonoClass *klass);
   413| static
   414| void
   415| runtime_profiler_class_failed (
   416| 	MonoProfiler *prof,
   417| 	MonoClass *klass);
   418| static
   419| void
   420| runtime_profiler_class_loaded (
   421| 	MonoProfiler *prof,
   422| 	MonoClass *klass);
   423| static
   424| void
   425| runtime_profiler_exception_throw (
   426| 	MonoProfiler *prof,
   427| 	MonoObject *exception);
   428| static
   429| void
   430| runtime_profiler_exception_clause (
   431| 	MonoProfiler *prof,
   432| 	MonoMethod *method,
   433| 	uint32_t clause_num,
   434| 	MonoExceptionEnum clause_type,
   435| 	MonoObject *exc);
   436| static
   437| void
   438| runtime_profiler_monitor_contention (
   439| 	MonoProfiler *prof,
   440| 	MonoObject *obj);
   441| static
   442| void
   443| runtime_profiler_monitor_acquired (
   444| 	MonoProfiler *prof,
   445| 	MonoObject *obj);
   446| static
   447| void
   448| runtime_profiler_monitor_failed (
   449| 	MonoProfiler *prof,
   450| 	MonoObject *obj);
   451| static
   452| void
   453| runtime_profiler_jit_code_buffer (
   454| 	MonoProfiler *prof,
   455| 	const mono_byte *buffer,
   456| 	uint64_t size,
   457| 	MonoProfilerCodeBufferType type,
   458| 	const void *data);
   459| static
   460| void
   461| mono_profiler_get_class_data (
   462| 	MonoClass *klass,
   463| 	uint64_t *class_id,
   464| 	uint64_t *module_id,
   465| 	ep_char8_t **class_name,
   466| 	uint32_t *class_generic_type_count,
   467| 	uint8_t **class_generic_types);
   468| static
   469| void
   470| mono_profiler_fire_event_enter (void);
   471| static
   472| void
   473| mono_profiler_fire_event_exit (void);
   474| static
   475| void
   476| mono_profiler_gc_in_progress_start (void);
   477| static
   478| void
   479| mono_profiler_gc_in_progress_stop (void);
   480| static
   481| MonoProfilerMemBlock *
   482| mono_profiler_mem_block_alloc (uint32_t req_size);
   483| static
   484| uint8_t *
   485| mono_profiler_mem_alloc (uint32_t req_size);
   486| static
   487| void
   488| mono_profiler_mem_block_free_all (void);
   489| static
   490| void
   491| mono_profiler_mem_block_free_all_but_current (void);
   492| static
   493| void
   494| mono_profiler_trigger_heap_collect (MonoProfiler *prof);
   495| static
   496| void
   497| mono_profiler_fire_gc_event_root_register (
   498| 	uint8_t *data,
   499| 	uint32_t payload_size);
   500| static
   501| void
   502| mono_profiler_fire_buffered_gc_event_root_register (
   503| 	MonoProfiler *prof,
   504| 	const mono_byte *start,
   505| 	uintptr_t size,
   506| 	MonoGCRootSource source,
   507| 	const void * key,
   508| 	const char * name);
   509| static
   510| void
   511| mono_profiler_fire_gc_event_root_unregister (
   512| 	uint8_t *data,
   513| 	uint32_t payload_size);
   514| static
   515| void
   516| mono_profiler_fire_buffered_gc_event_root_unregister (
   517| 	MonoProfiler *prof,
   518| 	const mono_byte *start);
   519| static
   520| void
   521| mono_profiler_fire_gc_event (
   522| 	uint8_t *data,
   523| 	uint32_t payload_size);
   524| static
   525| void
   526| mono_profiler_fire_buffered_gc_event (
   527| 	uint8_t gc_event_type,
   528| 	uint32_t generation);
   529| static
   530| void
   531| mono_profiler_fire_gc_event_resize (
   532| 	uint8_t *data,
   533| 	uint32_t payload_size);
   534| static
   535| void
   536| mono_profiler_fire_buffered_gc_event_resize (
   537| 	MonoProfiler *prof,
   538| 	uintptr_t size);
   539| static
   540| void
   541| mono_profiler_fire_gc_event_moves (
   542| 	uint8_t *data,
   543| 	uint32_t payload_size);
   544| static
   545| void
   546| mono_profiler_fire_buffered_gc_event_moves (
   547| 	MonoProfiler *prof,
   548| 	MonoObject *const* objects,
   549| 	uint64_t count);
   550| static
   551| void
   552| mono_profiler_fire_gc_event_roots (
   553| 	uint8_t *data,
   554| 	uint32_t payload_size);
   555| static
   556| void
   557| mono_profiler_fire_buffered_gc_event_roots (
   558| 	MonoProfiler *prof,
   559| 	uint64_t count,
   560| 	const mono_byte *const * addresses,
   561| 	MonoObject *const * objects);
   562| static
   563| void
   564| mono_profiler_fire_gc_event_heap_dump_object_reference (
   565| 	uint8_t *data,
   566| 	uint32_t payload_size,
   567| 	GHashTable *cache);
   568| static
   569| int
   570| mono_profiler_fire_buffered_gc_event_heap_dump_object_reference (
   571| 	MonoObject *obj,
   572| 	MonoClass *klass,
   573| 	uintptr_t size,
   574| 	uintptr_t num,
   575| 	MonoObject **refs,
   576| 	uintptr_t *offsets,
   577| 	void *data);
   578| static
   579| void
   580| mono_profiler_fire_buffered_gc_events (
   581| 	MonoProfilerMemBlock *block,
   582| 	GHashTable *cache);
   583| static
   584| void
   585| mono_profiler_fire_buffered_gc_events_in_alloc_order (GHashTable *cache);
   586| static
   587| void
   588| mono_profiler_fire_cached_gc_events (GHashTable *cache);
   589| static
   590| void
   591| mono_profiler_app_domain_loading (
   592| 	MonoProfiler *prof,
   593| 	MonoDomain *domain);
   594| static
   595| void
   596| mono_profiler_app_domain_loaded (
   597| 	MonoProfiler *prof,
   598| 	MonoDomain *domain);
   599| static
   600| void
   601| mono_profiler_app_domain_unloading (
   602| 	MonoProfiler *prof,
   603| 	MonoDomain *domain);
   604| static
   605| void
   606| mono_profiler_app_domain_unloaded (
   607| 	MonoProfiler *prof,
   608| 	MonoDomain *domain);
   609| static
   610| void
   611| mono_profiler_app_domain_name (
   612| 	MonoProfiler *prof,
   613| 	MonoDomain *domain,
   614| 	const char *name);
   615| static
   616| void
   617| mono_profiler_get_generic_types (
   618| 	MonoGenericInst *generic_instance,
   619| 	uint32_t *generic_type_count,
   620| 	uint8_t **generic_types);
   621| static
   622| void
   623| mono_profiler_get_jit_data (
   624| 	MonoMethod *method,
   625| 	uint64_t *method_id,
   626| 	uint64_t *module_id,
   627| 	uint32_t *method_token,
   628| 	uint32_t *method_generic_type_count,
   629| 	uint8_t **method_generic_types);
   630| static
   631| void
   632| mono_profiler_jit_begin (
   633| 	MonoProfiler *prof,
   634| 	MonoMethod *method);
   635| static
   636| void
   637| mono_profiler_jit_failed (
   638| 	MonoProfiler *prof,
   639| 	MonoMethod *method);
   640| static
   641| void
   642| mono_profiler_jit_done (
   643| 	MonoProfiler *prof,
   644| 	MonoMethod *method,
   645| 	MonoJitInfo *ji);
   646| static
   647| void
   648| mono_profiler_jit_chunk_created (
   649| 	MonoProfiler *prof,
   650| 	const mono_byte *chunk,
   651| 	uintptr_t size);
   652| static
   653| void
   654| mono_profiler_jit_chunk_destroyed (
   655| 	MonoProfiler *prof,
   656| 	const mono_byte *chunk);
   657| static
   658| void
   659| mono_profiler_jit_code_buffer (
   660| 	MonoProfiler *prof,
   661| 	const mono_byte *buffer,
   662| 	uint64_t size,
   663| 	MonoProfilerCodeBufferType type,
   664| 	const void *data);
   665| static
   666| void
   667| mono_profiler_class_loading (
   668| 	MonoProfiler *prof,
   669| 	MonoClass *klass);
   670| static
   671| void
   672| mono_profiler_class_failed (
   673| 	MonoProfiler *prof,
   674| 	MonoClass *klass);
   675| static
   676| void
   677| mono_profiler_class_loaded (
   678| 	MonoProfiler *prof,
   679| 	MonoClass *klass);
   680| static
   681| void
   682| mono_profiler_vtable_loading (
   683| 	MonoProfiler *prof,
   684| 	MonoVTable *vtable);
   685| static
   686| void
   687| mono_profiler_vtable_failed (
   688| 	MonoProfiler *prof,
   689| 	MonoVTable *vtable);
   690| static
   691| void
   692| mono_profiler_vtable_loaded (
   693| 	MonoProfiler *prof,
   694| 	MonoVTable *vtable);
   695| static
   696| void
   697| mono_profiler_module_loading (
   698| 	MonoProfiler *prof,
   699| 	MonoImage *image);
   700| static
   701| void
   702| mono_profiler_module_failed (
   703| 	MonoProfiler *prof,
   704| 	MonoImage *image);
   705| static
   706| void
   707| mono_profiler_module_loaded (
   708| 	MonoProfiler *prof,
   709| 	MonoImage *image);
   710| static
   711| void
   712| mono_profiler_module_unloading (
   713| 	MonoProfiler *prof,
   714| 	MonoImage *image);
   715| static
   716| void
   717| mono_profiler_module_unloaded (
   718| 	MonoProfiler *prof,
   719| 	MonoImage *image);
   720| static
   721| void
   722| mono_profiler_assembly_loading (
   723| 	MonoProfiler *prof,
   724| 	MonoAssembly *assembly);
   725| static
   726| void
   727| mono_profiler_assembly_loaded (
   728| 	MonoProfiler *prof,
   729| 	MonoAssembly *assembly);
   730| static
   731| void
   732| mono_profiler_assembly_unloading (
   733| 	MonoProfiler *prof,
   734| 	MonoAssembly *assembly);
   735| static
   736| void
   737| mono_profiler_assembly_unloaded (
   738| 	MonoProfiler *prof,
   739| 	MonoAssembly *assembly);
   740| static
   741| void
   742| mono_profiler_method_enter (
   743| 	MonoProfiler *prof,
   744| 	MonoMethod *method,
   745| 	MonoProfilerCallContext *context);
   746| static
   747| void
   748| mono_profiler_method_leave (
   749| 	MonoProfiler *prof,
   750| 	MonoMethod *method,
   751| 	MonoProfilerCallContext *context);
   752| static
   753| void
   754| mono_profiler_method_tail_call (
   755| 	MonoProfiler *prof,
   756| 	MonoMethod *method,
   757| 	MonoMethod *target_method);
   758| static
   759| void
   760| mono_profiler_method_exception_leave (
   761| 	MonoProfiler *prof,
   762| 	MonoMethod *method,
   763| 	MonoObject *exc);
   764| static
   765| void
   766| mono_profiler_method_free (
   767| 	MonoProfiler *prof,
   768| 	MonoMethod *method);
   769| static
   770| void
   771| mono_profiler_method_begin_invoke (
   772| 	MonoProfiler *prof,
   773| 	MonoMethod *method);
   774| static
   775| void
   776| mono_profiler_method_end_invoke (
   777| 	MonoProfiler *prof,
   778| 	MonoMethod *method);
   779| static
   780| MonoProfilerCallInstrumentationFlags
   781| mono_profiler_method_instrumentation (
   782| 	MonoProfiler *prof,
   783| 	MonoMethod *method);
   784| static
   785| void
   786| mono_profiler_exception_throw (
   787| 	MonoProfiler *prof,
   788| 	MonoObject *exc);
   789| static
   790| void
   791| mono_profiler_exception_clause (
   792| 	MonoProfiler *prof,
   793| 	MonoMethod *method,
   794| 	uint32_t clause_num,
   795| 	MonoExceptionEnum clause_type,
   796| 	MonoObject *exc);
   797| static
   798| void
   799| mono_profiler_gc_event (
   800| 	MonoProfiler *prof,
   801| 	MonoProfilerGCEvent gc_event,
   802| 	uint32_t generation,
   803| 	mono_bool serial);
   804| static
   805| void
   806| mono_profiler_gc_allocation (
   807| 	MonoProfiler *prof,
   808| 	MonoObject *object);
   809| static
   810| void
   811| mono_profiler_gc_handle_created (
   812| 	MonoProfiler *prof,
   813| 	uint32_t handle,
   814| 	MonoGCHandleType type,
   815| 	MonoObject * object);
   816| static
   817| void
   818| mono_profiler_gc_handle_deleted (
   819| 	MonoProfiler *prof,
   820| 	uint32_t handle,
   821| 	MonoGCHandleType type);
   822| static
   823| void
   824| mono_profiler_gc_finalizing (MonoProfiler *prof);
   825| static
   826| void
   827| mono_profiler_gc_finalized (MonoProfiler *prof);
   828| static
   829| void
   830| mono_profiler_gc_root_register (
   831| 	MonoProfiler *prof,
   832| 	const mono_byte *start,
   833| 	uintptr_t size,
   834| 	MonoGCRootSource source,
   835| 	const void * key,
   836| 	const char * name);
   837| static
   838| void
   839| mono_profiler_gc_root_unregister (
   840| 	MonoProfiler *prof,
   841| 	const mono_byte *start);
   842| static
   843| void
   844| mono_profiler_monitor_contention (
   845| 	MonoProfiler *prof,
   846| 	MonoObject *object);
   847| static
   848| void
   849| mono_profiler_monitor_failed (
   850| 	MonoProfiler *prof,
   851| 	MonoObject *object);
   852| static
   853| void
   854| mono_profiler_monitor_acquired (
   855| 	MonoProfiler *prof,
   856| 	MonoObject *object);
   857| static
   858| void
   859| mono_profiler_thread_started (
   860| 	MonoProfiler *prof,
   861| 	uintptr_t tid);
   862| static
   863| void
   864| mono_profiler_thread_stopping (
   865| 	MonoProfiler *prof,
   866| 	uintptr_t tid);
   867| static
   868| void
   869| mono_profiler_thread_stopped (
   870| 	MonoProfiler *prof,
   871| 	uintptr_t tid);
   872| static
   873| void
   874| mono_profiler_thread_exited (
   875| 	MonoProfiler *prof,
   876| 	uintptr_t tid);
   877| static
   878| void
   879| mono_profiler_thread_name (
   880| 	MonoProfiler *prof,
   881| 	uintptr_t tid,
   882| 	const char *name);
   883| static
   884| const EventFilterDescriptor *
   885| mono_profiler_add_provider_param (const EventFilterDescriptor *key);
   886| static
   887| bool
   888| mono_profiler_remove_provider_param (const EventFilterDescriptor *key);
   889| static
   890| void
   891| mono_profiler_free_provider_params (void);
   892| static
   893| bool
   894| mono_profiler_provider_params_get_value (
   895| 	const EventFilterDescriptor *param,
   896| 	const ep_char8_t *key,
   897| 	const ep_char8_t **value);
   898| static
   899| bool
   900| mono_profiler_provider_param_contains_heap_collect_ondemand (const EventFilterDescriptor *param);
   901| static
   902| void
   903| mono_profiler_push_gc_heap_collect_param_request_value (const EventFilterDescriptor *param);
   904| static
   905| void
   906| mono_profiler_pop_gc_heap_collect_param_request_value (void);
   907| static
   908| void
   909| mono_profiler_pop_gc_heap_collect_param_request_value (void);
   910| static
   911| const ep_char8_t *
   912| mono_profiler_get_gc_heap_collect_param_request_value (void);
   913| static
   914| void
   915| mono_profiler_free_gc_heap_collect_param_requests (void);
   916| static
   917| void
   918| mono_profiler_ep_provider_callback (
   919| 	const uint8_t *source_id,
   920| 	unsigned long is_enabled,
   921| 	uint8_t level,
   922| 	uint64_t match_any_keywords,
   923| 	uint64_t match_all_keywords,
   924| 	EventFilterDescriptor *filter_data,
   925| 	void *callback_data);
   926| /*
   927|  * Forward declares of all private functions (accessed using extern in ep-rt-mono.h).
   928|  */
   929| void
   930| ep_rt_mono_component_init (void);
   931| void
   932| ep_rt_mono_init (void);
   933| void
   934| ep_rt_mono_init_finish (void);
   935| void
   936| ep_rt_mono_fini (void);
   937| bool
   938| ep_rt_mono_rand_try_get_bytes (
   939| 	uint8_t *buffer,
   940| 	size_t buffer_size);
   941| ep_rt_file_handle_t
   942| ep_rt_mono_file_open_write(const ep_char8_t *path);
   943| bool
   944| ep_rt_mono_file_close (ep_rt_file_handle_t handle);
   945| bool
   946| ep_rt_mono_file_write (
   947| 	ep_rt_file_handle_t handle,
   948| 	const uint8_t *buffer,
   949| 	uint32_t numbytes,
   950| 	uint32_t *byteswritten);
   951| EventPipeThread *
   952| ep_rt_mono_thread_get_or_create (void);
   953| void *
   954| ep_rt_mono_thread_attach (bool background_thread);
   955| void *
   956| ep_rt_mono_thread_attach_2 (bool background_thread, EventPipeThreadType thread_type);
   957| void
   958| ep_rt_mono_thread_detach (void);
   959| void
   960| ep_rt_mono_thread_exited (void);
   961| int64_t
   962| ep_rt_mono_perf_counter_query (void);
   963| int64_t
   964| ep_rt_mono_perf_frequency_query (void);
   965| void
   966| ep_rt_mono_system_time_get (EventPipeSystemTime *system_time);
   967| int64_t
   968| ep_rt_mono_system_timestamp_get (void);
   969| void
   970| ep_rt_mono_os_environment_get_utf16 (ep_rt_env_array_utf16_t *env_array);
   971| void
   972| ep_rt_mono_init_providers_and_events (void);
   973| void
   974| ep_rt_mono_provider_config_init (EventPipeProviderConfiguration *provider_config);
   975| bool
   976| ep_rt_mono_providers_validate_all_disabled (void);
   977| void
   978| ep_rt_mono_fini_providers_and_events (void);
   979| bool
   980| ep_rt_mono_sample_profiler_write_sampling_event_for_threads (
   981| 	ep_rt_thread_handle_t sampling_thread,
   982| 	EventPipeEvent *sampling_event);
   983| bool
   984| ep_rt_mono_walk_managed_stack_for_thread (
   985| 	ep_rt_thread_handle_t thread,
   986| 	EventPipeStackContents *stack_contents);
   987| bool
   988| ep_rt_mono_method_get_simple_assembly_name (
   989| 	ep_rt_method_desc_t *method,
   990| 	ep_char8_t *name,
   991| 	size_t name_len);
   992| bool
   993| ep_rt_mono_method_get_full_name (
   994| 	ep_rt_method_desc_t *method,
   995| 	ep_char8_t *name,
   996| 	size_t name_len);
   997| void
   998| ep_rt_mono_execute_rundown (ep_rt_execution_checkpoint_array_t *execution_checkpoints);
   999| static
  1000| inline
  1001| bool
  1002| profiler_callback_is_enabled (uint64_t enabled_keywords, uint64_t keyword)
  1003| {
  1004| 	return (enabled_keywords & keyword) == keyword;
  1005| }
  1006| static
  1007| inline
  1008| uint16_t
  1009| clr_instance_get_id (void)
  1010| {
  1011| 	return 9;
  1012| }
  1013| static
  1014| EventPipeThreadData *
  1015| eventpipe_thread_data_get_or_create (void)
  1016| {
  1017| 	EventPipeThreadData *thread_data = (EventPipeThreadData *)mono_native_tls_get_value (_ep_rt_mono_thread_data_tls_id);
  1018| 	if (!thread_data) {
  1019| 		thread_data = ep_rt_object_alloc (EventPipeThreadData);
  1020| 		mono_native_tls_set_value (_ep_rt_mono_thread_data_tls_id, thread_data);
  1021| 	}
  1022| 	return thread_data;
  1023| }
  1024| static
  1025| void
  1026| eventpipe_thread_data_free (EventPipeThreadData *thread_data)
  1027| {
  1028| 	ep_return_void_if_nok (thread_data != NULL);
  1029| 	ep_rt_object_free (thread_data);
  1030| }
  1031| static
  1032| bool
  1033| fire_method_rundown_events_func (
  1034| 	const uint64_t method_id,
  1035| 	const uint64_t module_id,
  1036| 	const uint64_t method_start_address,
  1037| 	const uint32_t method_size,
  1038| 	const uint32_t method_token,
  1039| 	const uint32_t method_flags,
  1040| 	const ep_char8_t *method_namespace,
  1041| 	const ep_char8_t *method_name,
  1042| 	const ep_char8_t *method_signature,
  1043| 	const uint16_t count_of_map_entries,
  1044| 	const uint32_t *il_offsets,
  1045| 	const uint32_t *native_offsets,
  1046| 	bool aot_method,
  1047| 	bool verbose,
  1048| 	void *user_data)
  1049| {
  1050| 	FireEtwMethodDCEndILToNativeMap (
  1051| 		method_id,
  1052| 		0,
  1053| 		0,
  1054| 		count_of_map_entries,
  1055| 		il_offsets,
  1056| 		native_offsets,
  1057| 		clr_instance_get_id (),
  1058| 		NULL,
  1059| 		NULL);
  1060| 	if (verbose) {
  1061| 		FireEtwMethodDCEndVerbose_V1 (
  1062| 			method_id,
  1063| 			module_id,
  1064| 			method_start_address,
  1065| 			method_size,
  1066| 			method_token,
  1067| 			method_flags | METHOD_FLAGS_EXTENT_HOT_SECTION,
  1068| 			method_namespace,
  1069| 			method_name,
  1070| 			method_signature,
  1071| 			clr_instance_get_id (),
  1072| 			NULL,
  1073| 			NULL);
  1074| 		if (aot_method)
  1075| 			FireEtwMethodDCEndVerbose_V1 (
  1076| 				method_id,
  1077| 				module_id,
  1078| 				method_start_address,
  1079| 				method_size,
  1080| 				method_token,
  1081| 				method_flags | METHOD_FLAGS_EXTENT_COLD_SECTION,
  1082| 				method_namespace,
  1083| 				method_name,
  1084| 				method_signature,
  1085| 				clr_instance_get_id (),
  1086| 				NULL,
  1087| 				NULL);
  1088| 	} else {
  1089| 		FireEtwMethodDCEnd_V1 (
  1090| 			method_id,
  1091| 			module_id,
  1092| 			method_start_address,
  1093| 			method_size,
  1094| 			method_token,
  1095| 			method_flags | METHOD_FLAGS_EXTENT_HOT_SECTION,
  1096| 			clr_instance_get_id (),
  1097| 			NULL,
  1098| 			NULL);
  1099| 		if (aot_method)
  1100| 			FireEtwMethodDCEnd_V1 (
  1101| 				method_id,
  1102| 				module_id,
  1103| 				method_start_address,
  1104| 				method_size,
  1105| 				method_token,
  1106| 				method_flags | METHOD_FLAGS_EXTENT_COLD_SECTION,
  1107| 				clr_instance_get_id (),
  1108| 				NULL,
  1109| 				NULL);
  1110| 	}
  1111| 	return true;
  1112| }
  1113| static
  1114| bool
  1115| fire_assembly_rundown_events_func (
  1116| 	const uint64_t domain_id,
  1117| 	const uint64_t assembly_id,
  1118| 	const uint32_t assembly_flags,
  1119| 	const uint32_t binding_id,
  1120| 	const ep_char8_t *assembly_name,
  1121| 	const uint64_t module_id,
  1122| 	const uint32_t module_flags,
  1123| 	const uint32_t reserved_flags,
  1124| 	const ep_char8_t *module_il_path,
  1125| 	const ep_char8_t *module_native_path,
  1126| 	const uint8_t *managed_pdb_signature,
  1127| 	const uint32_t managed_pdb_age,
  1128| 	const ep_char8_t *managed_pdb_build_path,
  1129| 	const uint8_t *native_pdb_signature,
  1130| 	const uint32_t native_pdb_age,
  1131| 	const ep_char8_t *native_pdb_build_path,
  1132| 	void *user_data)
  1133| {
  1134| 	FireEtwModuleDCEnd_V2 (
  1135| 		module_id,
  1136| 		assembly_id,
  1137| 		module_flags,
  1138| 		reserved_flags,
  1139| 		module_il_path,
  1140| 		module_native_path,
  1141| 		clr_instance_get_id (),
  1142| 		managed_pdb_signature,
  1143| 		managed_pdb_age,
  1144| 		managed_pdb_build_path,
  1145| 		native_pdb_signature,
  1146| 		native_pdb_age,
  1147| 		native_pdb_build_path,
  1148| 		NULL,
  1149| 		NULL);
  1150| 	FireEtwDomainModuleDCEnd_V1 (
  1151| 		module_id,
  1152| 		assembly_id,
  1153| 		domain_id,
  1154| 		module_flags,
  1155| 		reserved_flags,
  1156| 		module_il_path,
  1157| 		module_native_path,
  1158| 		clr_instance_get_id (),
  1159| 		NULL,
  1160| 		NULL);
  1161| 	FireEtwAssemblyDCEnd_V1 (
  1162| 		assembly_id,
  1163| 		domain_id,
  1164| 		binding_id,
  1165| 		assembly_flags,
  1166| 		assembly_name,
  1167| 		clr_instance_get_id (),
  1168| 		NULL,
  1169| 		NULL);
  1170| 	return true;
  1171| }
  1172| static
  1173| bool
  1174| fire_domain_rundown_events_func (
  1175| 	const uint64_t domain_id,
  1176| 	const uint32_t domain_flags,
  1177| 	const ep_char8_t *domain_name,
  1178| 	const uint32_t domain_index,
  1179| 	void *user_data)
  1180| {
  1181| 	return FireEtwAppDomainDCEnd_V1 (
  1182| 		domain_id,
  1183| 		domain_flags,
  1184| 		domain_name,
  1185| 		domain_index,
  1186| 		clr_instance_get_id (),
  1187| 		NULL,
  1188| 		NULL);
  1189| }
  1190| static
  1191| void
  1192| eventpipe_fire_method_events (
  1193| 	MonoJitInfo *ji,
  1194| 	MonoMethod *method,
  1195| 	EventPipeFireMethodEventsData *events_data)
  1196| {
  1197| 	EP_ASSERT (ji != NULL);
  1198| 	EP_ASSERT (events_data->domain != NULL);
  1199| 	EP_ASSERT (events_data->method_events_func != NULL);
  1200| 	uint64_t method_id = 0;
  1201| 	uint64_t module_id = 0;
  1202| 	uint64_t method_code_start = (uint64_t)ji->code_start;
  1203| 	uint32_t method_code_size = (uint32_t)ji->code_size;
  1204| 	uint32_t method_token = 0;
  1205| 	uint32_t method_flags = 0;
  1206| 	uint8_t kind = MONO_CLASS_DEF;
  1207| 	char *method_namespace = NULL;
  1208| 	const char *method_name = NULL;
  1209| 	char *method_signature = NULL;
  1210| 	bool verbose = (MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_EVENTPIPE_Context.Level >= (uint8_t)EP_EVENT_LEVEL_VERBOSE);
  1211| 	if (method) {
  1212| 		method_id = (uint64_t)method;
  1213| 		method_token = method->token;
  1214| 		if (mono_jit_info_get_generic_sharing_context (ji))
  1215| 			method_flags |= METHOD_FLAGS_SHARED_GENERIC_METHOD;
  1216| 		if (method->dynamic)
  1217| 			method_flags |= METHOD_FLAGS_DYNAMIC_METHOD;
  1218| 		if (!ji->from_aot && !ji->from_llvm) {
  1219| 			method_flags |= METHOD_FLAGS_JITTED_METHOD;
  1220| 			if (method->wrapper_type != MONO_WRAPPER_NONE)
  1221| 				method_flags |= METHOD_FLAGS_JITTED_HELPER_METHOD;
  1222| 		}
  1223| 		if (method->is_generic || method->is_inflated)
  1224| 			method_flags |= METHOD_FLAGS_GENERIC_METHOD;
  1225| 		if (method->klass) {
  1226| 			module_id = (uint64_t)m_class_get_image (method->klass);
  1227| 			kind = m_class_get_class_kind (method->klass);
  1228| 			if (kind == MONO_CLASS_GTD || kind == MONO_CLASS_GINST)
  1229| 				method_flags |= METHOD_FLAGS_GENERIC_METHOD;
  1230| 		}
  1231| 		if (verbose) {
  1232| 			method_name = method->name;
  1233| 			method_signature = mono_signature_full_name (mono_method_signature_internal (method));
  1234| 			if (method->klass)
  1235| 				method_namespace = mono_type_get_name_full (m_class_get_byval_arg (method->klass), MONO_TYPE_NAME_FORMAT_IL);
  1236| 		}
  1237| 	}
  1238| 	uint32_t offset_entries = 0;
  1239| 	uint32_t *il_offsets = NULL;
  1240| 	uint32_t *native_offsets = NULL;
  1241| 	MonoDebugMethodJitInfo *debug_info = method ? mono_debug_find_method (method, events_data->domain) : NULL;
  1242| 	if (debug_info) {
  1243| 		offset_entries = debug_info->num_line_numbers;
  1244| 		if (offset_entries != 0) {
  1245| 			size_t needed_size = (offset_entries * sizeof (uint32_t) * 2);
  1246| 			if (!events_data->buffer || needed_size > events_data->buffer_size) {
  1247| 				g_free (events_data->buffer);
  1248| 				events_data->buffer_size = (size_t)(needed_size * 1.5);
  1249| 				events_data->buffer = g_new (uint8_t, events_data->buffer_size);
  1250| 			}
  1251| 			if (events_data->buffer) {
  1252| 				il_offsets = (uint32_t*)events_data->buffer;
  1253| 				native_offsets = il_offsets + offset_entries;
  1254| 				for (uint32_t offset_count = 0; offset_count < offset_entries; ++offset_count) {
  1255| 					il_offsets [offset_count] = debug_info->line_numbers [offset_count].il_offset;
  1256| 					native_offsets [offset_count] = debug_info->line_numbers [offset_count].native_offset;
  1257| 				}
  1258| 			}
  1259| 		}
  1260| 		mono_debug_free_method_jit_info (debug_info);
  1261| 	}
  1262| 	if (events_data->buffer && !il_offsets && !native_offsets) {
  1263| 		EP_ASSERT (events_data->buffer_size >= sizeof (uint32_t) * 2);
  1264| 		offset_entries = 1;
  1265| 		il_offsets = (uint32_t*)events_data->buffer;
  1266| 		native_offsets = il_offsets + offset_entries;
  1267| 		il_offsets [0] = 0;
  1268| 		native_offsets [0] = (uint32_t)ji->code_size;
  1269| 	}
  1270| 	events_data->method_events_func (
  1271| 		method_id,
  1272| 		module_id,
  1273| 		method_code_start,
  1274| 		method_code_size,
  1275| 		method_token,
  1276| 		method_flags,
  1277| 		(ep_char8_t *)method_namespace,
  1278| 		(ep_char8_t *)method_name,
  1279| 		(ep_char8_t *)method_signature,
  1280| 		GUINT32_TO_UINT16 (offset_entries),
  1281| 		il_offsets,
  1282| 		native_offsets,
  1283| 		(ji->from_aot || ji->from_llvm),
  1284| 		verbose,
  1285| 		NULL);
  1286| 	g_free (method_namespace);
  1287| 	g_free (method_signature);
  1288| }
  1289| static
  1290| inline
  1291| bool
  1292| include_method (MonoMethod *method)
  1293| {
  1294| 	if (!method) {
  1295| 		return false;
  1296| 	} else if (!m_method_is_wrapper (method)) {
  1297| 		return true;
  1298| 	} else {
  1299| 		WrapperInfo *wrapper = mono_marshal_get_wrapper_info (method);
  1300| 		return (wrapper && wrapper->subtype == WRAPPER_SUBTYPE_PINVOKE) ? true : false;
  1301| 	}
  1302| }
  1303| static
  1304| void
  1305| eventpipe_fire_method_events_func (
  1306| 	MonoJitInfo *ji,
  1307| 	void  *user_data)
  1308| {
  1309| 	EventPipeFireMethodEventsData *events_data = (EventPipeFireMethodEventsData *)user_data;
  1310| 	EP_ASSERT (events_data != NULL);
  1311| 	if (ji && !ji->is_trampoline && !ji->async) {
  1312| 		MonoMethod *method = jinfo_get_method (ji);
  1313| 		if (include_method (method))
  1314| 			eventpipe_fire_method_events (ji, method, events_data);
  1315| 	}
  1316| }
  1317| static
  1318| void
  1319| eventpipe_fire_assembly_events (
  1320| 	MonoDomain *domain,
  1321| 	MonoAssembly *assembly,
  1322| 	ep_rt_mono_fire_assembly_rundown_events_func assembly_events_func)
  1323| {
  1324| 	EP_ASSERT (domain != NULL);
  1325| 	EP_ASSERT (assembly != NULL);
  1326| 	EP_ASSERT (assembly_events_func != NULL);
  1327| 	uint32_t binding_id = 0;
  1328| 	ModuleEventData module_data;
  1329| 	memset (&module_data, 0, sizeof (module_data));
  1330| 	get_module_event_data (assembly->image, &module_data);
  1331| 	uint32_t assembly_flags = 0;
  1332| 	if (assembly->dynamic)
  1333| 		assembly_flags |= ASSEMBLY_FLAGS_DYNAMIC_ASSEMBLY;
  1334| 	if (assembly->image && assembly->image->aot_module) {
  1335| 		assembly_flags |= ASSEMBLY_FLAGS_NATIVE_ASSEMBLY;
  1336| 	}
  1337| 	char *assembly_name = mono_stringify_assembly_name (&assembly->aname);
  1338| 	assembly_events_func (
  1339| 		module_data.domain_id,
  1340| 		module_data.assembly_id,
  1341| 		assembly_flags,
  1342| 		binding_id,
  1343| 		(const ep_char8_t*)assembly_name,
  1344| 		module_data.module_id,
  1345| 		module_data.module_flags,
  1346| 		module_data.reserved_flags,
  1347| 		(const ep_char8_t *)module_data.module_il_path,
  1348| 		(const ep_char8_t *)module_data.module_native_path,
  1349| 		module_data.module_il_pdb_signature,
  1350| 		module_data.module_il_pdb_age,
  1351| 		(const ep_char8_t *)module_data.module_il_pdb_path,
  1352| 		module_data.module_native_pdb_signature,
  1353| 		module_data.module_native_pdb_age,
  1354| 		(const ep_char8_t *)module_data.module_native_pdb_path,
  1355| 		NULL);
  1356| 	g_free (assembly_name);
  1357| }
  1358| static
  1359| gboolean
  1360| eventpipe_execute_rundown (
  1361| 	ep_rt_mono_fire_domain_rundown_events_func domain_events_func,
  1362| 	ep_rt_mono_fire_assembly_rundown_events_func assembly_events_func,
  1363| 	ep_rt_mono_fire_method_rundown_events_func method_events_func)
  1364| {
  1365| 	EP_ASSERT (domain_events_func != NULL);
  1366| 	EP_ASSERT (assembly_events_func != NULL);
  1367| 	EP_ASSERT (method_events_func != NULL);
  1368| 	MonoDomain *root_domain = mono_get_root_domain ();
  1369| 	if (root_domain) {
  1370| 		uint64_t domain_id = (uint64_t)root_domain;
  1371| 		EventPipeFireMethodEventsData events_data;
  1372| 		events_data.domain = root_domain;
  1373| 		events_data.buffer_size = 1024 * sizeof(uint32_t);
  1374| 		events_data.buffer = g_new (uint8_t, events_data.buffer_size);
  1375| 		events_data.method_events_func = method_events_func;
  1376| 		mono_jit_info_table_foreach_internal (eventpipe_fire_method_events_func, &events_data);
  1377| 		if (mono_get_runtime_callbacks ()->is_interpreter_enabled())
  1378| 			mono_get_runtime_callbacks ()->interp_jit_info_foreach (eventpipe_fire_method_events_func, &events_data);
  1379| 		if (_ep_rt_mono_runtime_helper_compile_method_jitinfo && _ep_rt_mono_runtime_helper_compile_method)
  1380| 			eventpipe_fire_method_events (_ep_rt_mono_runtime_helper_compile_method_jitinfo, _ep_rt_mono_runtime_helper_compile_method, &events_data);
  1381| 		if (_ep_rt_mono_monitor_enter_method_jitinfo && _ep_rt_mono_monitor_enter_method)
  1382| 			eventpipe_fire_method_events (_ep_rt_mono_monitor_enter_method_jitinfo, _ep_rt_mono_monitor_enter_method, &events_data);
  1383| 		if (_ep_rt_mono_monitor_enter_v4_method_jitinfo && _ep_rt_mono_monitor_enter_v4_method)
  1384| 			eventpipe_fire_method_events (_ep_rt_mono_monitor_enter_v4_method_jitinfo, _ep_rt_mono_monitor_enter_v4_method, &events_data);
  1385| 		g_free (events_data.buffer);
  1386| 		GPtrArray *assemblies = mono_alc_get_all_loaded_assemblies ();
  1387| 		if (assemblies) {
  1388| 			for (uint32_t i = 0; i < assemblies->len; ++i) {
  1389| 				MonoAssembly *assembly = (MonoAssembly *)g_ptr_array_index (assemblies, i);
  1390| 				if (assembly)
  1391| 					eventpipe_fire_assembly_events (root_domain, assembly, assembly_events_func);
  1392| 			}
  1393| 			g_ptr_array_free (assemblies, TRUE);
  1394| 		}
  1395| 		uint32_t domain_flags = DOMAIN_FLAGS_DEFAULT_DOMAIN | DOMAIN_FLAGS_EXECUTABLE_DOMAIN;
  1396| 		const char *domain_name = root_domain->friendly_name ? root_domain->friendly_name : "";
  1397| 		uint32_t domain_index = 1;
  1398| 		domain_events_func (
  1399| 			domain_id,
  1400| 			domain_flags,
  1401| 			(const ep_char8_t *)domain_name,
  1402| 			domain_index,
  1403| 			NULL);
  1404| 	}
  1405| 	return TRUE;
  1406| }
  1407| inline
  1408| static
  1409| bool
  1410| in_safe_point_frame (EventPipeStackContents *stack_content, WrapperInfo *wrapper)
  1411| {
  1412| 	EP_ASSERT (stack_content != NULL);
  1413| 	if (wrapper && ep_stack_contents_get_length (stack_content) == 0 && wrapper->subtype == WRAPPER_SUBTYPE_ICALL_WRAPPER &&
  1414| 			(wrapper->d.icall.jit_icall_id == MONO_JIT_ICALL_mono_threads_state_poll ||
  1415| 			wrapper->d.icall.jit_icall_id == MONO_JIT_ICALL_mono_threads_enter_gc_safe_region_unbalanced ||
  1416| 			wrapper->d.icall.jit_icall_id == MONO_JIT_ICALL_mono_threads_exit_gc_safe_region_unbalanced ||
  1417| 			wrapper->d.icall.jit_icall_id == MONO_JIT_ICALL_mono_threads_enter_gc_unsafe_region_unbalanced ||
  1418| 			wrapper->d.icall.jit_icall_id == MONO_JIT_ICALL_mono_threads_exit_gc_unsafe_region_unbalanced))
  1419| 		return true;
  1420| 	return false;
  1421| }
  1422| inline
  1423| static
  1424| bool
  1425| in_runtime_invoke_frame (EventPipeStackContents *stack_content, WrapperInfo *wrapper)
  1426| {
  1427| 	EP_ASSERT (stack_content != NULL);
  1428| 	if (wrapper && ep_stack_contents_get_length (stack_content) == 0 &&
  1429| 			(wrapper->subtype == WRAPPER_SUBTYPE_RUNTIME_INVOKE_NORMAL ||
  1430| 			wrapper->subtype == WRAPPER_SUBTYPE_RUNTIME_INVOKE_DIRECT ||
  1431| 			wrapper->subtype == WRAPPER_SUBTYPE_RUNTIME_INVOKE_DYNAMIC ||
  1432| 			wrapper->subtype == WRAPPER_SUBTYPE_RUNTIME_INVOKE_VIRTUAL))
  1433| 		return true;
  1434| 	return false;
  1435| }
  1436| inline
  1437| static
  1438| bool
  1439| in_monitor_enter_frame (WrapperInfo *wrapper)
  1440| {
  1441| 	if (wrapper && wrapper->subtype == WRAPPER_SUBTYPE_ICALL_WRAPPER &&
  1442| 			(wrapper->d.icall.jit_icall_id == MONO_JIT_ICALL_mono_monitor_enter_fast ||
  1443| 			wrapper->d.icall.jit_icall_id == MONO_JIT_ICALL_mono_monitor_enter_internal))
  1444| 		return true;
  1445| 	return false;
  1446| }
  1447| inline
  1448| static
  1449| bool
  1450| in_monitor_enter_v4_frame (WrapperInfo *wrapper)
  1451| {
  1452| 	if (wrapper && wrapper->subtype == WRAPPER_SUBTYPE_ICALL_WRAPPER &&
  1453| 			(wrapper->d.icall.jit_icall_id == MONO_JIT_ICALL_mono_monitor_enter_v4_fast ||
  1454| 			wrapper->d.icall.jit_icall_id == MONO_JIT_ICALL_mono_monitor_enter_v4_internal))
  1455| 		return true;
  1456| 	return false;
  1457| }
  1458| static
  1459| gboolean
  1460| eventpipe_walk_managed_stack_for_thread (
  1461| 	MonoStackFrameInfo *frame,
  1462| 	MonoContext *ctx,
  1463| 	EventPipeStackWalkData *stack_walk_data)
  1464| {
  1465| 	EP_ASSERT (frame != NULL);
  1466| 	EP_ASSERT (stack_walk_data != NULL);
  1467| 	switch (frame->type) {
  1468| 	case FRAME_TYPE_DEBUGGER_INVOKE:
  1469| 	case FRAME_TYPE_MANAGED_TO_NATIVE:
  1470| 	case FRAME_TYPE_TRAMPOLINE:
  1471| 	case FRAME_TYPE_INTERP_TO_MANAGED:
  1472| 	case FRAME_TYPE_INTERP_TO_MANAGED_WITH_CTX:
  1473| 	case FRAME_TYPE_INTERP_ENTRY:
  1474| 		stack_walk_data->top_frame = false;
  1475| 		return FALSE;
  1476| 	case FRAME_TYPE_JIT_ENTRY:
  1477| 		if (_ep_rt_mono_runtime_helper_compile_method && stack_walk_data->top_frame)
  1478| 			ep_stack_contents_append (stack_walk_data->stack_contents, (uintptr_t)((uint8_t*)_ep_rt_mono_runtime_helper_compile_method), _ep_rt_mono_runtime_helper_compile_method);
  1479| 		stack_walk_data->top_frame = false;
  1480| 		return FALSE;
  1481| 	case FRAME_TYPE_MANAGED:
  1482| 	case FRAME_TYPE_INTERP:
  1483| 		if (frame->ji) {
  1484| 			stack_walk_data->async_frame |= frame->ji->async;
  1485| 			MonoMethod *method = frame->ji->async ? NULL : frame->actual_method;
  1486| 			if (method && m_method_is_wrapper (method)) {
  1487| 				WrapperInfo *wrapper = mono_marshal_get_wrapper_info (method);
  1488| 				if (in_safe_point_frame (stack_walk_data->stack_contents, wrapper)) {
  1489| 					stack_walk_data->safe_point_frame = true;
  1490| 				}else if (in_runtime_invoke_frame (stack_walk_data->stack_contents, wrapper)) {
  1491| 					stack_walk_data->runtime_invoke_frame = true;
  1492| 				} else if (_ep_rt_mono_monitor_enter_method && in_monitor_enter_frame (wrapper)) {
  1493| 					ep_stack_contents_append (stack_walk_data->stack_contents, (uintptr_t)((uint8_t*)_ep_rt_mono_monitor_enter_method), _ep_rt_mono_monitor_enter_method);
  1494| 				} else if (_ep_rt_mono_monitor_enter_v4_method && in_monitor_enter_v4_frame (wrapper)) {
  1495| 					ep_stack_contents_append (stack_walk_data->stack_contents, (uintptr_t)((uint8_t*)_ep_rt_mono_monitor_enter_v4_method), _ep_rt_mono_monitor_enter_v4_method);
  1496| 				} else if (wrapper && wrapper->subtype == WRAPPER_SUBTYPE_PINVOKE) {
  1497| 					ep_stack_contents_append (stack_walk_data->stack_contents, (uintptr_t)((uint8_t*)frame->ji->code_start + frame->native_offset), method);
  1498| 				}
  1499| 			} else if (method && !m_method_is_wrapper (method)) {
  1500| 				ep_stack_contents_append (stack_walk_data->stack_contents, (uintptr_t)((uint8_t*)frame->ji->code_start + frame->native_offset), method);
  1501| 			} else if (!method && frame->ji->async && !frame->ji->is_trampoline) {
  1502| 				ep_stack_contents_append (stack_walk_data->stack_contents, (uintptr_t)((uint8_t*)frame->ji->code_start), method);
  1503| 			}
  1504| 		}
  1505| 		stack_walk_data->top_frame = false;
  1506| 		return ep_stack_contents_get_length (stack_walk_data->stack_contents) >= EP_MAX_STACK_DEPTH;
  1507| 	default:
  1508| 		EP_UNREACHABLE ("eventpipe_walk_managed_stack_for_thread");
  1509| 		return FALSE;
  1510| 	}
  1511| }
  1512| static
  1513| gboolean
  1514| eventpipe_walk_managed_stack_for_thread_func (
  1515| 	MonoStackFrameInfo *frame,
  1516| 	MonoContext *ctx,
  1517| 	void *data)
  1518| {
  1519| 	return eventpipe_walk_managed_stack_for_thread (frame, ctx, (EventPipeStackWalkData *)data);
  1520| }
  1521| static
  1522| gboolean
  1523| eventpipe_sample_profiler_walk_managed_stack_for_thread_func (
  1524| 	MonoStackFrameInfo *frame,
  1525| 	MonoContext *ctx,
  1526| 	void *data)
  1527| {
  1528| 	EP_ASSERT (frame != NULL);
  1529| 	EP_ASSERT (data != NULL);
  1530| 	EventPipeSampleProfileStackWalkData *sample_data = (EventPipeSampleProfileStackWalkData *)data;
  1531| 	if (sample_data->payload_data == EP_SAMPLE_PROFILER_SAMPLE_TYPE_ERROR) {
  1532| 		switch (frame->type) {
  1533| 		case FRAME_TYPE_MANAGED:
  1534| 			sample_data->payload_data = EP_SAMPLE_PROFILER_SAMPLE_TYPE_MANAGED;
  1535| 			break;
  1536| 		case FRAME_TYPE_MANAGED_TO_NATIVE:
  1537| 		case FRAME_TYPE_TRAMPOLINE:
  1538| 			sample_data->payload_data = EP_SAMPLE_PROFILER_SAMPLE_TYPE_EXTERNAL;
  1539| 			break;
  1540| 		case FRAME_TYPE_JIT_ENTRY:
  1541| 			sample_data->payload_data = EP_SAMPLE_PROFILER_SAMPLE_TYPE_EXTERNAL;
  1542| 			break;
  1543| 		case FRAME_TYPE_INTERP:
  1544| 			sample_data->payload_data = frame->managed ? EP_SAMPLE_PROFILER_SAMPLE_TYPE_MANAGED : EP_SAMPLE_PROFILER_SAMPLE_TYPE_EXTERNAL;
  1545| 			break;
  1546| 		case FRAME_TYPE_INTERP_TO_MANAGED:
  1547| 		case FRAME_TYPE_INTERP_TO_MANAGED_WITH_CTX:
  1548| 			break;
  1549| 		default:
  1550| 			sample_data->payload_data = EP_SAMPLE_PROFILER_SAMPLE_TYPE_MANAGED;
  1551| 		}
  1552| 	}
  1553| 	return eventpipe_walk_managed_stack_for_thread (frame, ctx, &sample_data->stack_walk_data);
  1554| }
  1555| static
  1556| void
  1557| profiler_eventpipe_runtime_initialized (MonoProfiler *prof)
  1558| {
  1559| 	_ep_rt_mono_profiler_gc_can_collect_heap = true;
  1560| }
  1561| static
  1562| void
  1563| profiler_eventpipe_thread_exited (
  1564| 	MonoProfiler *prof,
  1565| 	uintptr_t tid)
  1566| {
  1567| 	ep_rt_mono_thread_exited ();
  1568| }
  1569| static
  1570| bool
  1571| parse_mono_profiler_options (const ep_char8_t *option)
  1572| {
  1573| 	do {
  1574| 		if (!*option)
  1575| 			return false;
  1576| 		if (!strncmp (option, "alloc", 5)) {
  1577| 			mono_profiler_enable_allocations ();
  1578| 			option += 5;
  1579| 		} else if (!strncmp (option, "exception", 9)) {
  1580| 			mono_profiler_enable_clauses ();
  1581| 			option += 9;
  1582| 		/*} else if (!strncmp (option, "sample", 6)) {
  1583| 			mono_profiler_enable_sampling (_ep_rt_dotnet_mono_profiler_provider);
  1584| 			option += 6;*/
  1585| 		} else {
  1586| 			return false;
  1587| 		}
  1588| 		if (*option == ',')
  1589| 			option++;
  1590| 	} while (*option);
  1591| 	return true;
  1592| }
  1593| void
  1594| ep_rt_mono_component_init (void)
  1595| {
  1596| 	_ep_rt_default_profiler = mono_profiler_create (NULL);
  1597| 	_ep_rt_dotnet_runtime_profiler_provider = mono_profiler_create (NULL);
  1598| 	_ep_rt_dotnet_mono_profiler_provider = mono_profiler_create (NULL);
  1599| 	_ep_rt_dotnet_mono_profiler_heap_collect_provider = mono_profiler_create (NULL);
  1600| 	char *diag_env = g_getenv("MONO_DIAGNOSTICS");
  1601| 	if (diag_env) {
  1602| 		int diag_argc = 1;
  1603| 		char **diag_argv = g_new (char *, 1);
  1604| 		if (diag_argv) {
  1605| 			diag_argv [0] = NULL;
  1606| 			if (!mono_parse_options_from (diag_env, &diag_argc, &diag_argv)) {
  1607| 				for (int i = 0; i < diag_argc; ++i) {
  1608| 					if (diag_argv [i]) {
  1609| 						if (strncmp (diag_argv [i], "--diagnostic-mono-profiler=", 27) == 0) {
  1610| 							if (!parse_mono_profiler_options (diag_argv [i] + 27))
  1611| 								mono_trace (G_LOG_LEVEL_ERROR, MONO_TRACE_DIAGNOSTICS, "Failed parsing MONO_DIAGNOSTICS environment variable option: %s", diag_argv [i]);
  1612| 						} else if (strncmp (diag_argv [i], "--diagnostic-mono-profiler-callspec=", 36) == 0) {
  1613| 							char *errstr = NULL;
  1614| 							if (!mono_callspec_parse (diag_argv [i] + 36, &_ep_rt_dotnet_mono_profiler_provider_callspec, &errstr)) {
  1615| 								mono_trace (G_LOG_LEVEL_ERROR, MONO_TRACE_DIAGNOSTICS, "Failed parsing '%s': %s", diag_argv [i], errstr);
  1616| 								g_free (errstr);
  1617| 								mono_callspec_cleanup (&_ep_rt_dotnet_mono_profiler_provider_callspec);
  1618| 							} else {
  1619| 								mono_profiler_set_call_instrumentation_filter_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_method_instrumentation);
  1620| 							}
  1621| 						} else if (strncmp (diag_argv [i], "--diagnostic-ports=", 19) == 0) {
  1622| 							char *diag_ports_env = g_getenv("DOTNET_DiagnosticPorts");
  1623| 							if (diag_ports_env)
  1624| 								mono_trace (G_LOG_LEVEL_WARNING, MONO_TRACE_DIAGNOSTICS, "DOTNET_DiagnosticPorts environment variable already set, ignoring --diagnostic-ports used in MONO_DIAGNOSTICS environment variable");
  1625| 							else
  1626| 								g_setenv ("DOTNET_DiagnosticPorts", diag_argv [i] + 19, TRUE);
  1627| 							g_free (diag_ports_env);
  1628| 						} else {
  1629| 							mono_trace (G_LOG_LEVEL_ERROR, MONO_TRACE_DIAGNOSTICS, "Failed parsing MONO_DIAGNOSTICS environment variable, unknown option: %s", diag_argv [i]);
  1630| 						}
  1631| 						g_free (diag_argv [i]);
  1632| 						diag_argv [i] = NULL;
  1633| 					}
  1634| 				}
  1635| 				g_free (diag_argv);
  1636| 			} else {
  1637| 				mono_trace (G_LOG_LEVEL_ERROR, MONO_TRACE_DIAGNOSTICS, "Failed parsing MONO_DIAGNOSTICS environment variable");
  1638| 			}
  1639| 		}
  1640| 	}
  1641| 	g_free (diag_env);
  1642| }
  1643| void
  1644| ep_rt_mono_init (void)
  1645| {
  1646| 	mono_native_tls_alloc (&_ep_rt_mono_thread_holder_tls_id, NULL);
  1647| 	mono_native_tls_alloc (&_ep_rt_mono_thread_data_tls_id, NULL);
  1648| 	mono_100ns_ticks ();
  1649| 	mono_rand_open ();
  1650| 	_ep_rt_mono_rand_provider = mono_rand_init (NULL, 0);
  1651| 	_ep_rt_mono_initialized = TRUE;
  1652| 	EP_ASSERT (_ep_rt_default_profiler != NULL);
  1653| 	EP_ASSERT (_ep_rt_dotnet_runtime_profiler_provider != NULL);
  1654| 	EP_ASSERT (_ep_rt_dotnet_mono_profiler_provider != NULL);
  1655| 	EP_ASSERT (_ep_rt_dotnet_mono_profiler_heap_collect_provider != NULL);
  1656| 	ep_rt_spin_lock_alloc (&_ep_rt_mono_profiler_gc_state_lock);
  1657| 	mono_profiler_set_runtime_initialized_callback (_ep_rt_default_profiler, profiler_eventpipe_runtime_initialized);
  1658| 	mono_profiler_set_thread_stopped_callback (_ep_rt_default_profiler, profiler_eventpipe_thread_exited);
  1659| 	MonoMethodSignature *method_signature = mono_metadata_signature_alloc (mono_get_corlib (), 1);
  1660| 	if (method_signature) {
  1661| 		method_signature->params[0] = m_class_get_byval_arg (mono_get_object_class());
  1662| 		method_signature->ret = m_class_get_byval_arg (mono_get_void_class());
  1663| 		ERROR_DECL (error);
  1664| 		MonoClass *runtime_helpers = mono_class_from_name_checked (mono_get_corlib (), "System.Runtime.CompilerServices", "RuntimeHelpers", error);
  1665| 		if (is_ok (error) && runtime_helpers) {
  1666| 			MonoMethodBuilder *method_builder = mono_mb_new (runtime_helpers, "CompileMethod", MONO_WRAPPER_RUNTIME_INVOKE);
  1667| 			if (method_builder) {
  1668| 				_ep_rt_mono_runtime_helper_compile_method = mono_mb_create_method (method_builder, method_signature, 1);
  1669| 				mono_mb_free (method_builder);
  1670| 			}
  1671| 		}
  1672| 		mono_error_cleanup (error);
  1673| 		mono_metadata_free_method_signature (method_signature);
  1674| 		if (_ep_rt_mono_runtime_helper_compile_method) {
  1675| 			_ep_rt_mono_runtime_helper_compile_method_jitinfo = (MonoJitInfo *)g_new0 (MonoJitInfo, 1);
  1676| 			if (_ep_rt_mono_runtime_helper_compile_method) {
  1677| 				_ep_rt_mono_runtime_helper_compile_method_jitinfo->code_start = MINI_FTNPTR_TO_ADDR (_ep_rt_mono_runtime_helper_compile_method);
  1678| 				_ep_rt_mono_runtime_helper_compile_method_jitinfo->code_size = 20;
  1679| 				_ep_rt_mono_runtime_helper_compile_method_jitinfo->d.method = _ep_rt_mono_runtime_helper_compile_method;
  1680| 			}
  1681| 		}
  1682| 	}
  1683| 	{
  1684| 		ERROR_DECL (error);
  1685| 		MonoMethodDesc *desc = NULL;
  1686| 		MonoClass *monitor = mono_class_from_name_checked (mono_get_corlib (), "System.Threading", "Monitor", error);
  1687| 		if (is_ok (error) && monitor) {
  1688| 			desc = mono_method_desc_new ("Monitor:Enter(object,bool&)", FALSE);
  1689| 			if (desc) {
  1690| 				_ep_rt_mono_monitor_enter_v4_method = mono_method_desc_search_in_class (desc, monitor);
  1691| 				mono_method_desc_free (desc);
  1692| 				if (_ep_rt_mono_monitor_enter_v4_method) {
  1693| 					_ep_rt_mono_monitor_enter_v4_method_jitinfo = (MonoJitInfo *)g_new0 (MonoJitInfo, 1);
  1694| 					if (_ep_rt_mono_monitor_enter_v4_method_jitinfo) {
  1695| 						_ep_rt_mono_monitor_enter_v4_method_jitinfo->code_start = MINI_FTNPTR_TO_ADDR (_ep_rt_mono_monitor_enter_v4_method);
  1696| 						_ep_rt_mono_monitor_enter_v4_method_jitinfo->code_size = 20;
  1697| 						_ep_rt_mono_monitor_enter_v4_method_jitinfo->d.method = _ep_rt_mono_monitor_enter_v4_method;
  1698| 					}
  1699| 				}
  1700| 			}
  1701| 			desc = mono_method_desc_new ("Monitor:Enter(object)", FALSE);
  1702| 			if (desc) {
  1703| 				_ep_rt_mono_monitor_enter_method = mono_method_desc_search_in_class (desc, monitor);
  1704| 				mono_method_desc_free (desc);
  1705| 				if (_ep_rt_mono_monitor_enter_method ) {
  1706| 					_ep_rt_mono_monitor_enter_method_jitinfo = (MonoJitInfo *)g_new0 (MonoJitInfo, 1);
  1707| 					if (_ep_rt_mono_monitor_enter_method_jitinfo) {
  1708| 						_ep_rt_mono_monitor_enter_method_jitinfo->code_start = MINI_FTNPTR_TO_ADDR (_ep_rt_mono_monitor_enter_method);
  1709| 						_ep_rt_mono_monitor_enter_method_jitinfo->code_size = 20;
  1710| 						_ep_rt_mono_monitor_enter_method_jitinfo->d.method = _ep_rt_mono_monitor_enter_method;
  1711| 					}
  1712| 				}
  1713| 			}
  1714| 		}
  1715| 		mono_error_cleanup (error);
  1716| 	}
  1717| }
  1718| void
  1719| ep_rt_mono_init_finish (void)
  1720| {
  1721| 	if (mono_runtime_get_no_exec ())
  1722| 		return;
  1723| 	ERROR_DECL (error);
  1724| 	MonoClass *runtime_event_source = mono_class_from_name_checked (mono_get_corlib (), "System.Diagnostics.Tracing", "RuntimeEventSource", error);
  1725| 	if (is_ok (error) && runtime_event_source) {
  1726| 		MonoMethod *init = mono_class_get_method_from_name_checked (runtime_event_source, "Initialize", -1, 0, error);
  1727| 		if (is_ok (error) && init) {
  1728| 			mono_runtime_try_invoke_handle (init, NULL_HANDLE, NULL, error);
  1729| 		}
  1730| 	}
  1731| 	mono_error_cleanup (error);
  1732| }
  1733| void
  1734| ep_rt_mono_fini (void)
  1735| {
  1736| 	if (_ep_rt_mono_sampled_thread_callstacks)
  1737| 		g_array_free (_ep_rt_mono_sampled_thread_callstacks, TRUE);
  1738| 	if (_ep_rt_mono_initialized)
  1739| 		mono_rand_close (_ep_rt_mono_rand_provider);
  1740| 	g_free (_ep_rt_mono_runtime_helper_compile_method_jitinfo);
  1741| 	_ep_rt_mono_runtime_helper_compile_method_jitinfo = NULL;
  1742| 	mono_free_method (_ep_rt_mono_runtime_helper_compile_method);
  1743| 	_ep_rt_mono_runtime_helper_compile_method = NULL;
  1744| 	g_free (_ep_rt_mono_monitor_enter_method_jitinfo);
  1745| 	_ep_rt_mono_monitor_enter_method_jitinfo = NULL;
  1746| 	_ep_rt_mono_monitor_enter_method = NULL;
  1747| 	g_free (_ep_rt_mono_monitor_enter_v4_method_jitinfo);
  1748| 	_ep_rt_mono_monitor_enter_v4_method_jitinfo = NULL;
  1749| 	_ep_rt_mono_monitor_enter_v4_method = NULL;
  1750| 	if (_ep_rt_dotnet_mono_profiler_provider_callspec.enabled) {
  1751| 		mono_profiler_set_call_instrumentation_filter_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  1752| 		mono_callspec_cleanup (&_ep_rt_dotnet_mono_profiler_provider_callspec);
  1753| 	}
  1754| 	mono_profiler_free_gc_heap_collect_param_requests ();
  1755| 	mono_profiler_free_provider_params ();
  1756| 	ep_rt_spin_lock_free (&_ep_rt_mono_profiler_gc_state_lock);
  1757| 	_ep_rt_mono_sampled_thread_callstacks = NULL;
  1758| 	_ep_rt_mono_rand_provider = NULL;
  1759| 	_ep_rt_mono_initialized = FALSE;
  1760| }
  1761| bool
  1762| ep_rt_mono_rand_try_get_bytes (
  1763| 	uint8_t *buffer,
  1764| 	size_t buffer_size)
  1765| {
  1766| 	EP_ASSERT (_ep_rt_mono_rand_provider != NULL);
  1767| 	ERROR_DECL (error);
  1768| 	return mono_rand_try_get_bytes (&_ep_rt_mono_rand_provider, (guchar *)buffer, (gssize)buffer_size, error);
  1769| }
  1770| char *
  1771| ep_rt_mono_get_managed_cmd_line ()
  1772| {
  1773| 	return mono_runtime_get_managed_cmd_line ();
  1774| }
  1775| char *
  1776| ep_rt_mono_get_os_cmd_line ()
  1777| {
  1778| 	MONO_REQ_GC_NEUTRAL_MODE;
  1779| 	char *host_path = minipal_getexepath ();
  1780| 	char *res = g_strdup (host_path);
  1781| 	free (host_path);
  1782| 	return res;
  1783| }
  1784| #ifdef HOST_WIN32
  1785| ep_rt_file_handle_t
  1786| ep_rt_mono_file_open_write (const ep_char8_t *path)
  1787| {
  1788| 	if (!path)
  1789| 		return INVALID_HANDLE_VALUE;
  1790| 	ep_char16_t *path_utf16 = ep_rt_utf8_to_utf16le_string (path, -1);
  1791| 	if (!path_utf16)
  1792| 		return INVALID_HANDLE_VALUE;
  1793| 	ep_rt_file_handle_t res;
  1794| 	MONO_ENTER_GC_SAFE;
  1795| 	res = (ep_rt_file_handle_t)CreateFileW (path_utf16, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
  1796| 	MONO_EXIT_GC_SAFE;
  1797| 	ep_rt_utf16_string_free (path_utf16);
  1798| 	return res;
  1799| }
  1800| bool
  1801| ep_rt_mono_file_close (ep_rt_file_handle_t handle)
  1802| {
  1803| 	bool res;
  1804| 	MONO_ENTER_GC_SAFE;
  1805| 	res = CloseHandle (handle);
  1806| 	MONO_EXIT_GC_SAFE;
  1807| 	return res;
  1808| }
  1809| static
  1810| void
  1811| win32_io_interrupt_handler (void *ignored)
  1812| {
  1813| }
  1814| bool
  1815| ep_rt_mono_file_write (
  1816| 	ep_rt_file_handle_t handle,
  1817| 	const uint8_t *buffer,
  1818| 	uint32_t numbytes,
  1819| 	uint32_t *byteswritten)
  1820| {
  1821| 	MONO_REQ_GC_UNSAFE_MODE;
  1822| 	bool res;
  1823| 	MonoThreadInfo *info = mono_thread_info_current ();
  1824| 	gboolean alerted = FALSE;
  1825| 	if (info) {
  1826| 		mono_thread_info_install_interrupt (win32_io_interrupt_handler, NULL, &alerted);
  1827| 		if (alerted) {
  1828| 			return false;
  1829| 		}
  1830| 		mono_win32_enter_blocking_io_call (info, handle);
  1831| 	}
  1832| 	MONO_ENTER_GC_SAFE;
  1833| 	if (info && mono_thread_info_is_interrupt_state (info)) {
  1834| 		res = false;
  1835| 	} else {
  1836| 		res = WriteFile (handle, buffer, numbytes, (PDWORD)byteswritten, NULL) ? true : false;
  1837| 	}
  1838| 	MONO_EXIT_GC_SAFE;
  1839| 	if (info) {
  1840| 		mono_win32_leave_blocking_io_call (info, handle);
  1841| 		mono_thread_info_uninstall_interrupt (&alerted);
  1842| 	}
  1843| 	return res;
  1844| }
  1845| #else
  1846| #include <fcntl.h>
  1847| #include <unistd.h>
  1848| ep_rt_file_handle_t
  1849| ep_rt_mono_file_open_write (const ep_char8_t *path)
  1850| {
  1851| 	int fd;
  1852| 	mode_t perms = 0666;
  1853| 	if (!path)
  1854| 		return INVALID_HANDLE_VALUE;
  1855| 	MONO_ENTER_GC_SAFE;
  1856| 	fd = creat (path, perms);
  1857| 	MONO_EXIT_GC_SAFE;
  1858| 	if (fd == -1)
  1859| 		return INVALID_HANDLE_VALUE;
  1860| 	return (ep_rt_file_handle_t)(ptrdiff_t)fd;
  1861| }
  1862| bool
  1863| ep_rt_mono_file_close (ep_rt_file_handle_t handle)
  1864| {
  1865| 	int fd = (int)(ptrdiff_t)handle;
  1866| 	MONO_ENTER_GC_SAFE;
  1867| 	close (fd);
  1868| 	MONO_EXIT_GC_SAFE;
  1869| 	return true;
  1870| }
  1871| bool
  1872| ep_rt_mono_file_write (
  1873| 	ep_rt_file_handle_t handle,
  1874| 	const uint8_t *buffer,
  1875| 	uint32_t numbytes,
  1876| 	uint32_t *byteswritten)
  1877| {
  1878| 	MONO_REQ_GC_UNSAFE_MODE;
  1879| 	int fd = (int)(ptrdiff_t)handle;
  1880| 	uint32_t ret;
  1881| 	MonoThreadInfo *info = mono_thread_info_current ();
  1882| 	if (byteswritten != NULL)
  1883| 		*byteswritten = 0;
  1884| 	do {
  1885| 		MONO_ENTER_GC_SAFE;
  1886| 		ret = write (fd, buffer, numbytes);
  1887| 		MONO_EXIT_GC_SAFE;
  1888| 	} while (ret == -1 && errno == EINTR &&
  1889| 		 !mono_thread_info_is_interrupt_state (info));
  1890| 	if (ret == -1) {
  1891| 		if (errno == EINTR)
  1892| 			ret = 0;
  1893| 		else
  1894| 			return false;
  1895| 	}
  1896| 	if (byteswritten != NULL)
  1897| 		*byteswritten = ret;
  1898| 	return true;
  1899| }
  1900| #endif // HOST_WIN32
  1901| EventPipeThread *
  1902| ep_rt_mono_thread_get_or_create (void)
  1903| {
  1904| 	EventPipeThreadHolder *thread_holder = (EventPipeThreadHolder *)mono_native_tls_get_value (_ep_rt_mono_thread_holder_tls_id);
  1905| 	if (!thread_holder) {
  1906| 		thread_holder = thread_holder_alloc_func ();
  1907| 		mono_native_tls_set_value (_ep_rt_mono_thread_holder_tls_id, thread_holder);
  1908| 	}
  1909| 	return ep_thread_holder_get_thread (thread_holder);
  1910| }
  1911| void *
  1912| ep_rt_mono_thread_attach (bool background_thread)
  1913| {
  1914| 	MonoThread *thread = NULL;
  1915| 	if (!mono_thread_current ()) {
  1916| 		thread = mono_thread_internal_attach (mono_get_root_domain ());
  1917| 		if (background_thread && thread) {
  1918| 			mono_thread_set_state (thread, ThreadState_Background);
  1919| 			mono_thread_info_set_flags (MONO_THREAD_INFO_FLAGS_NO_SAMPLE);
  1920| 		}
  1921| 	}
  1922| 	return thread;
  1923| }
  1924| void *
  1925| ep_rt_mono_thread_attach_2 (bool background_thread, EventPipeThreadType thread_type)
  1926| {
  1927| 	void *result = ep_rt_mono_thread_attach (background_thread);
  1928| 	if (result && thread_type == EP_THREAD_TYPE_SAMPLING) {
  1929| #ifdef HOST_WIN32
  1930| 		SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_HIGHEST);
  1931| #elif _POSIX_PRIORITY_SCHEDULING
  1932| 		int policy;
  1933| 		int priority;
  1934| 		struct sched_param param;
  1935| 		int schedparam_result = pthread_getschedparam (pthread_self (), &policy, &param);
  1936| 		if (schedparam_result == 0) {
  1937| 			priority = param.sched_priority;
  1938| 			param.sched_priority = sched_get_priority_max (SCHED_RR);
  1939| 			if (param.sched_priority != -1) {
  1940| 				schedparam_result = pthread_setschedparam (pthread_self (), SCHED_RR, &param);
  1941| 				if (schedparam_result != 0) {
  1942| 					param.sched_priority = sched_get_priority_max (policy);
  1943| 					if (param.sched_priority != -1 && param.sched_priority != priority)
  1944| 						pthread_setschedparam (pthread_self (), policy, &param);
  1945| 				}
  1946| 			}
  1947| 		}
  1948| #endif
  1949| 	}
  1950| 	return result;
  1951| }
  1952| void
  1953| ep_rt_mono_thread_detach (void)
  1954| {
  1955| 	MonoThread *current_thread = mono_thread_current ();
  1956| 	if (current_thread)
  1957| 		mono_thread_internal_detach (current_thread);
  1958| }
  1959| void
  1960| ep_rt_mono_thread_exited (void)
  1961| {
  1962| 	if (_ep_rt_mono_initialized) {
  1963| 		EventPipeThreadHolder *thread_holder = (EventPipeThreadHolder *)mono_native_tls_get_value (_ep_rt_mono_thread_holder_tls_id);
  1964| 		if (thread_holder)
  1965| 			thread_holder_free_func (thread_holder);
  1966| 		mono_native_tls_set_value (_ep_rt_mono_thread_holder_tls_id, NULL);
  1967| 		EventPipeThreadData *thread_data = (EventPipeThreadData *)mono_native_tls_get_value (_ep_rt_mono_thread_data_tls_id);
  1968| 		if (thread_data)
  1969| 			eventpipe_thread_data_free (thread_data);
  1970| 		mono_native_tls_set_value (_ep_rt_mono_thread_data_tls_id, NULL);
  1971| 	}
  1972| }
  1973| #ifdef HOST_WIN32
  1974| int64_t
  1975| ep_rt_mono_perf_counter_query (void)
  1976| {
  1977| 	LARGE_INTEGER value;
  1978| 	if (QueryPerformanceCounter (&value))
  1979| 		return (int64_t)value.QuadPart;
  1980| 	else
  1981| 		return 0;
  1982| }
  1983| int64_t
  1984| ep_rt_mono_perf_frequency_query (void)
  1985| {
  1986| 	LARGE_INTEGER value;
  1987| 	if (QueryPerformanceFrequency (&value))
  1988| 		return (int64_t)value.QuadPart;
  1989| 	else
  1990| 		return 0;
  1991| }
  1992| void
  1993| ep_rt_mono_system_time_get (EventPipeSystemTime *system_time)
  1994| {
  1995| 	SYSTEMTIME value;
  1996| 	GetSystemTime (&value);
  1997| 	EP_ASSERT (system_time != NULL);
  1998| 	ep_system_time_set (
  1999| 		system_time,
  2000| 		value.wYear,
  2001| 		value.wMonth,
  2002| 		value.wDayOfWeek,
  2003| 		value.wDay,
  2004| 		value.wHour,
  2005| 		value.wMinute,
  2006| 		value.wSecond,
  2007| 		value.wMilliseconds);
  2008| }
  2009| int64_t
  2010| ep_rt_mono_system_timestamp_get (void)
  2011| {
  2012| 	FILETIME value;
  2013| 	GetSystemTimeAsFileTime (&value);
  2014| 	return (int64_t)((((uint64_t)value.dwHighDateTime) << 32) | (uint64_t)value.dwLowDateTime);
  2015| }
  2016| #else
  2017| #include <sys/types.h>
  2018| #include <sys/stat.h>
  2019| #include <utime.h>
  2020| #include <time.h>
  2021| #if HAVE_SYS_TIME_H
  2022| #include <sys/time.h>
  2023| #endif // HAVE_SYS_TIME_H
  2024| #if HAVE_MACH_ABSOLUTE_TIME
  2025| #include <mach/mach_time.h>
  2026| static mono_lazy_init_t _ep_rt_mono_time_base_info_init = MONO_LAZY_INIT_STATUS_NOT_INITIALIZED;
  2027| static mach_timebase_info_data_t _ep_rt_mono_time_base_info = {0};
  2028| #endif
  2029| #ifdef HAVE_LOCALTIME_R
  2030| #define HAVE_GMTIME_R 1
  2031| #endif
  2032| static const int64_t SECS_BETWEEN_1601_AND_1970_EPOCHS = 11644473600LL;
  2033| static const int64_t SECS_TO_100NS = 10000000;
  2034| static const int64_t SECS_TO_NS = 1000000000;
  2035| static const int64_t MSECS_TO_MIS = 1000;
  2036| /* clock_gettime () is found by configure on Apple builds, but its only present from ios 10, macos 10.12, tvos 10 and watchos 3 */
  2037| #if defined (HAVE_CLOCK_MONOTONIC) && (defined(HOST_IOS) || defined(HOST_OSX) || defined(HOST_WATCHOS) || defined(HOST_TVOS))
  2038| #undef HAVE_CLOCK_MONOTONIC
  2039| #endif
  2040| #ifndef HAVE_CLOCK_MONOTONIC
  2041| static const int64_t MISECS_TO_NS = 1000;
  2042| #endif
  2043| static
  2044| void
  2045| time_base_info_lazy_init (void);
  2046| static
  2047| int64_t
  2048| system_time_to_int64 (
  2049| 	time_t sec,
  2050| 	long nsec);
  2051| #if HAVE_MACH_ABSOLUTE_TIME
  2052| static
  2053| void
  2054| time_base_info_lazy_init (void)
  2055| {
  2056| 	kern_return_t result = mach_timebase_info (&_ep_rt_mono_time_base_info);
  2057| 	if (result != KERN_SUCCESS)
  2058| 		memset (&_ep_rt_mono_time_base_info, 0, sizeof (_ep_rt_mono_time_base_info));
  2059| }
  2060| #endif
  2061| int64_t
  2062| ep_rt_mono_perf_counter_query (void)
  2063| {
  2064| #if HAVE_MACH_ABSOLUTE_TIME
  2065| 	return (int64_t)mach_absolute_time ();
  2066| #elif HAVE_CLOCK_MONOTONIC
  2067| 	struct timespec ts;
  2068| 	int result = clock_gettime (CLOCK_MONOTONIC, &ts);
  2069| 	if (result == 0)
  2070| 		return ((int64_t)(ts.tv_sec) * (int64_t)(SECS_TO_NS)) + (int64_t)(ts.tv_nsec);
  2071| #else
  2072| 	#error "ep_rt_mono_perf_counter_get requires either mach_absolute_time () or clock_gettime (CLOCK_MONOTONIC) to be supported."
  2073| #endif
  2074| 	return 0;
  2075| }
  2076| int64_t
  2077| ep_rt_mono_perf_frequency_query (void)
  2078| {
  2079| #if HAVE_MACH_ABSOLUTE_TIME
  2080| 	mono_lazy_initialize (&_ep_rt_mono_time_base_info_init, time_base_info_lazy_init);
  2081| 	if (_ep_rt_mono_time_base_info.denom == 0 || _ep_rt_mono_time_base_info.numer == 0)
  2082| 		return 0;
  2083| 	return ((int64_t)(SECS_TO_NS) * (int64_t)(_ep_rt_mono_time_base_info.denom)) / (int64_t)(_ep_rt_mono_time_base_info.numer);
  2084| #elif HAVE_CLOCK_MONOTONIC
  2085| 	return (int64_t)(SECS_TO_NS);
  2086| #else
  2087| 	#error "ep_rt_mono_perf_frequency_query requires either mach_absolute_time () or clock_gettime (CLOCK_MONOTONIC) to be supported."
  2088| #endif
  2089| 	return 0;
  2090| }
  2091| void
  2092| ep_rt_mono_system_time_get (EventPipeSystemTime *system_time)
  2093| {
  2094| 	time_t tt;
  2095| #if HAVE_GMTIME_R
  2096| 	struct tm ut;
  2097| #endif /* HAVE_GMTIME_R */
  2098| 	struct tm *ut_ptr;
  2099| 	struct timeval time_val;
  2100| 	int timeofday_retval;
  2101| 	EP_ASSERT (system_time != NULL);
  2102| 	tt = time (NULL);
  2103| 	/* We can't get millisecond resolution from time (), so we get it from gettimeofday () */
  2104| 	timeofday_retval = gettimeofday (&time_val, NULL);
  2105| #if HAVE_GMTIME_R
  2106| 	ut_ptr = &ut;
  2107| 	if (gmtime_r (&tt, ut_ptr) == NULL)
  2108| #else /* HAVE_GMTIME_R */
  2109| 	if ((ut_ptr = gmtime (&tt)) == NULL)
  2110| #endif /* HAVE_GMTIME_R */
  2111| 		EP_UNREACHABLE ();
  2112| 	uint16_t milliseconds = 0;
  2113| 	if (timeofday_retval != -1) {
  2114| 		int old_seconds;
  2115| 		int new_seconds;
  2116| 		milliseconds = (uint16_t)(time_val.tv_usec / MSECS_TO_MIS);
  2117| 		old_seconds = ut_ptr->tm_sec;
  2118| 		new_seconds = time_val.tv_sec % 60;
  2119| 		/* just in case we reached the next second in the interval between time () and gettimeofday () */
  2120| 		if (old_seconds != new_seconds)
  2121| 			milliseconds = 999;
  2122| 	}
  2123| 	ep_system_time_set (
  2124| 		system_time,
  2125| 		(uint16_t)(1900 + ut_ptr->tm_year),
  2126| 		(uint16_t)ut_ptr->tm_mon + 1,
  2127| 		(uint16_t)ut_ptr->tm_wday,
  2128| 		(uint16_t)ut_ptr->tm_mday,
  2129| 		(uint16_t)ut_ptr->tm_hour,
  2130| 		(uint16_t)ut_ptr->tm_min,
  2131| 		(uint16_t)ut_ptr->tm_sec,
  2132| 		milliseconds);
  2133| }
  2134| static
  2135| inline
  2136| int64_t
  2137| system_time_to_int64 (
  2138| 	time_t sec,
  2139| 	long nsec)
  2140| {
  2141| 	return ((int64_t)sec + SECS_BETWEEN_1601_AND_1970_EPOCHS) * SECS_TO_100NS + (nsec / 100);
  2142| }
  2143| int64_t
  2144| ep_rt_mono_system_timestamp_get (void)
  2145| {
  2146| #if HAVE_CLOCK_MONOTONIC
  2147| 	struct timespec time;
  2148| 	if (clock_gettime (CLOCK_REALTIME, &time) == 0)
  2149| 		return system_time_to_int64 (time.tv_sec, time.tv_nsec);
  2150| #else
  2151| 	struct timeval time;
  2152| 	if (gettimeofday (&time, NULL) == 0)
  2153| 		return system_time_to_int64 (time.tv_sec, time.tv_usec * MISECS_TO_NS);
  2154| #endif
  2155| 	else
  2156| 		return system_time_to_int64 (0, 0);
  2157| }
  2158| #endif
  2159| #ifndef HOST_WIN32
  2160| #if defined(__APPLE__)
  2161| #if defined (HOST_OSX)
  2162| G_BEGIN_DECLS
  2163| gchar ***_NSGetEnviron(void);
  2164| G_END_DECLS
  2165| #define environ (*_NSGetEnviron())
  2166| #else
  2167| static char *_ep_rt_mono_environ[1] = { NULL };
  2168| #define environ _ep_rt_mono_environ
  2169| #endif /* defined (HOST_OSX) */
  2170| #else
  2171| G_BEGIN_DECLS
  2172| extern char **environ;
  2173| G_END_DECLS
  2174| #endif /* defined (__APPLE__) */
  2175| #endif /* !defined (HOST_WIN32) */
  2176| void
  2177| ep_rt_mono_os_environment_get_utf16 (ep_rt_env_array_utf16_t *env_array)
  2178| {
  2179| 	EP_ASSERT (env_array != NULL);
  2180| #ifdef HOST_WIN32
  2181| 	LPWSTR envs = GetEnvironmentStringsW ();
  2182| 	if (envs) {
  2183| 		LPWSTR next = envs;
  2184| 		while (*next) {
  2185| 			ep_rt_env_array_utf16_append (env_array, ep_rt_utf16_string_dup (next));
  2186| 			next += ep_rt_utf16_string_len (next) + 1;
  2187| 		}
  2188| 		FreeEnvironmentStringsW (envs);
  2189| 	}
  2190| #else
  2191| 	gchar **next = NULL;
  2192| 	for (next = environ; *next != NULL; ++next)
  2193| 		ep_rt_env_array_utf16_append (env_array, ep_rt_utf8_to_utf16le_string (*next, -1));
  2194| #endif
  2195| }
  2196| void
  2197| ep_rt_mono_init_providers_and_events (void)
  2198| {
  2199| 	InitProvidersAndEvents ();
  2200| }
  2201| void
  2202| ep_rt_mono_provider_config_init (EventPipeProviderConfiguration *provider_config)
  2203| {
  2204| 	if (!ep_rt_utf8_string_compare (ep_config_get_rundown_provider_name_utf8 (), ep_provider_config_get_provider_name (provider_config))) {
  2205| 		MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_EVENTPIPE_Context.Level = (uint8_t)ep_provider_config_get_logging_level (provider_config);
  2206| 		MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_EVENTPIPE_Context.EnabledKeywordsBitmask = ep_provider_config_get_keywords (provider_config);
  2207| 		MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_EVENTPIPE_Context.IsEnabled = true;
  2208| 	}
  2209| }
  2210| bool
  2211| ep_rt_mono_providers_validate_all_disabled (void)
  2212| {
  2213| 	return (!MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_EVENTPIPE_Context.IsEnabled &&
  2214| 		!MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_EVENTPIPE_Context.IsEnabled &&
  2215| 		!MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_EVENTPIPE_Context.IsEnabled &&
  2216| 		!MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_EVENTPIPE_Context.IsEnabled);
  2217| }
  2218| void
  2219| ep_rt_mono_fini_providers_and_events (void)
  2220| {
  2221| }
  2222| bool
  2223| ep_rt_mono_walk_managed_stack_for_thread (
  2224| 	ep_rt_thread_handle_t thread,
  2225| 	EventPipeStackContents *stack_contents)
  2226| {
  2227| 	EP_ASSERT (thread != NULL && stack_contents != NULL);
  2228| 	EventPipeStackWalkData stack_walk_data;
  2229| 	stack_walk_data.stack_contents = stack_contents;
  2230| 	stack_walk_data.top_frame = true;
  2231| 	stack_walk_data.async_frame = false;
  2232| 	stack_walk_data.safe_point_frame = false;
  2233| 	stack_walk_data.runtime_invoke_frame = false;
  2234| 	bool restore_async_context = FALSE;
  2235| 	bool prevent_profiler_event_recursion = FALSE;
  2236| 	EventPipeThreadData *thread_data = eventpipe_thread_data_get_or_create ();
  2237| 	if (thread_data) {
  2238| 		prevent_profiler_event_recursion = thread_data->prevent_profiler_event_recursion;
  2239| 		if (prevent_profiler_event_recursion && !mono_thread_info_is_async_context ()) {
  2240| 			mono_thread_info_set_is_async_context (TRUE);
  2241| 			restore_async_context = TRUE;
  2242| 		}
  2243| 		thread_data->prevent_profiler_event_recursion = TRUE;
  2244| 	}
  2245| 	if (thread == ep_rt_thread_get_handle () && mono_get_eh_callbacks ()->mono_walk_stack_with_ctx)
  2246| 		mono_get_eh_callbacks ()->mono_walk_stack_with_ctx (eventpipe_walk_managed_stack_for_thread_func, NULL, MONO_UNWIND_SIGNAL_SAFE, &stack_walk_data);
  2247| 	else if (mono_get_eh_callbacks ()->mono_walk_stack_with_state)
  2248| 		mono_get_eh_callbacks ()->mono_walk_stack_with_state (eventpipe_walk_managed_stack_for_thread_func, mono_thread_info_get_suspend_state (thread), MONO_UNWIND_SIGNAL_SAFE, &stack_walk_data);
  2249| 	if (thread_data) {
  2250| 		if (restore_async_context)
  2251| 			mono_thread_info_set_is_async_context (FALSE);
  2252| 		thread_data->prevent_profiler_event_recursion = prevent_profiler_event_recursion;
  2253| 	}
  2254| 	return true;
  2255| }
  2256| bool
  2257| ep_rt_mono_method_get_simple_assembly_name (
  2258| 	ep_rt_method_desc_t *method,
  2259| 	ep_char8_t *name,
  2260| 	size_t name_len)
  2261| {
  2262| 	EP_ASSERT (method != NULL);
  2263| 	EP_ASSERT (name != NULL);
  2264| 	MonoClass *method_class = mono_method_get_class (method);
  2265| 	MonoImage *method_image = method_class ? mono_class_get_image (method_class) : NULL;
  2266| 	const ep_char8_t *assembly_name = method_image ? mono_image_get_name (method_image) : NULL;
  2267| 	if (!assembly_name)
  2268| 		return false;
  2269| 	g_strlcpy (name, assembly_name, name_len);
  2270| 	return true;
  2271| }
  2272| bool
  2273| ep_rt_mono_method_get_full_name (
  2274| 	ep_rt_method_desc_t *method,
  2275| 	ep_char8_t *name,
  2276| 	size_t name_len)
  2277| {
  2278| 	EP_ASSERT (method != NULL);
  2279| 	EP_ASSERT (name != NULL);
  2280| 	char *full_method_name = mono_method_get_name_full (method, TRUE, TRUE, MONO_TYPE_NAME_FORMAT_IL);
  2281| 	if (!full_method_name)
  2282| 		return false;
  2283| 	g_strlcpy (name, full_method_name, name_len);
  2284| 	g_free (full_method_name);
  2285| 	return true;
  2286| }
  2287| bool
  2288| ep_rt_mono_sample_profiler_write_sampling_event_for_threads (
  2289| 	ep_rt_thread_handle_t sampling_thread,
  2290| 	EventPipeEvent *sampling_event)
  2291| {
  2292| 	if (!_ep_rt_mono_sampled_thread_callstacks)
  2293| 		_ep_rt_mono_sampled_thread_callstacks = g_array_sized_new (FALSE, FALSE, sizeof (EventPipeSampleProfileStackWalkData), _ep_rt_mono_max_sampled_thread_count);
  2294| 	g_array_set_size (_ep_rt_mono_sampled_thread_callstacks, _ep_rt_mono_max_sampled_thread_count);
  2295| 	uint32_t filtered_thread_count = 0;
  2296| 	uint32_t sampled_thread_count = 0;
  2297| 	mono_stop_world (MONO_THREAD_INFO_FLAGS_NO_GC);
  2298| 	bool restore_async_context = FALSE;
  2299| 	if (!mono_thread_info_is_async_context ()) {
  2300| 		mono_thread_info_set_is_async_context (TRUE);
  2301| 		restore_async_context = TRUE;
  2302| 	}
  2303| 	FOREACH_THREAD_SAFE_EXCLUDE (thread_info, MONO_THREAD_INFO_FLAGS_NO_GC | MONO_THREAD_INFO_FLAGS_NO_SAMPLE) {
  2304| 		if (!mono_thread_info_is_running (thread_info)) {
  2305| 			MonoThreadUnwindState *thread_state = mono_thread_info_get_suspend_state (thread_info);
  2306| 			if (thread_state->valid) {
  2307| 				if (sampled_thread_count < _ep_rt_mono_max_sampled_thread_count) {
  2308| 					EventPipeSampleProfileStackWalkData *data = &g_array_index (_ep_rt_mono_sampled_thread_callstacks, EventPipeSampleProfileStackWalkData, sampled_thread_count);
  2309| 					data->thread_id = ep_rt_thread_id_t_to_uint64_t (mono_thread_info_get_tid (thread_info));
  2310| 					data->thread_ip = (uintptr_t)MONO_CONTEXT_GET_IP (&thread_state->ctx);
  2311| 					data->payload_data = EP_SAMPLE_PROFILER_SAMPLE_TYPE_ERROR;
  2312| 					data->stack_walk_data.stack_contents = &data->stack_contents;
  2313| 					data->stack_walk_data.top_frame = true;
  2314| 					data->stack_walk_data.async_frame = false;
  2315| 					data->stack_walk_data.safe_point_frame = false;
  2316| 					data->stack_walk_data.runtime_invoke_frame = false;
  2317| 					ep_stack_contents_reset (&data->stack_contents);
  2318| 					mono_get_eh_callbacks ()->mono_walk_stack_with_state (eventpipe_sample_profiler_walk_managed_stack_for_thread_func, thread_state, MONO_UNWIND_SIGNAL_SAFE, data);
  2319| 					if (data->payload_data == EP_SAMPLE_PROFILER_SAMPLE_TYPE_EXTERNAL && (data->stack_walk_data.safe_point_frame || data->stack_walk_data.runtime_invoke_frame)) {
  2320| 						data->payload_data = EP_SAMPLE_PROFILER_SAMPLE_TYPE_MANAGED;
  2321| 					}
  2322| 					if (data->stack_walk_data.top_frame && ep_stack_contents_get_length (&data->stack_contents) == 0) {
  2323| 						data->payload_data = EP_SAMPLE_PROFILER_SAMPLE_TYPE_EXTERNAL;
  2324| 					}
  2325| 					sampled_thread_count++;
  2326| 				}
  2327| 			}
  2328| 		}
  2329| 		filtered_thread_count++;
  2330| 	} FOREACH_THREAD_SAFE_END
  2331| 	if (restore_async_context)
  2332| 		mono_thread_info_set_is_async_context (FALSE);
  2333| 	mono_restart_world (MONO_THREAD_INFO_FLAGS_NO_GC);
  2334| 	THREAD_INFO_TYPE adapter = { { 0 } };
  2335| 	for (uint32_t thread_count = 0; thread_count < sampled_thread_count; ++thread_count) {
  2336| 		EventPipeSampleProfileStackWalkData *data = &g_array_index (_ep_rt_mono_sampled_thread_callstacks, EventPipeSampleProfileStackWalkData, thread_count);
  2337| 		if ((data->stack_walk_data.top_frame && data->payload_data == EP_SAMPLE_PROFILER_SAMPLE_TYPE_EXTERNAL) || (data->payload_data != EP_SAMPLE_PROFILER_SAMPLE_TYPE_ERROR && ep_stack_contents_get_length (&data->stack_contents) > 0)) {
  2338| 			if (data->stack_walk_data.async_frame) {
  2339| 				for (uint32_t frame_count = 0; frame_count < data->stack_contents.next_available_frame; ++frame_count)
  2340| 					mono_jit_info_table_find_internal ((gpointer)data->stack_contents.stack_frames [frame_count], TRUE, FALSE);
  2341| 			}
  2342| 			mono_thread_info_set_tid (&adapter, ep_rt_uint64_t_to_thread_id_t (data->thread_id));
  2343| 			uint32_t payload_data = ep_rt_val_uint32_t (data->payload_data);
  2344| 			ep_write_sample_profile_event (sampling_thread, sampling_event, &adapter, &data->stack_contents, (uint8_t *)&payload_data, sizeof (payload_data));
  2345| 		}
  2346| 	}
  2347| 	_ep_rt_mono_max_sampled_thread_count = filtered_thread_count;
  2348| 	return true;
  2349| }
  2350| void
  2351| ep_rt_mono_execute_rundown (ep_rt_execution_checkpoint_array_t *execution_checkpoints)
  2352| {
  2353| 	ep_char8_t runtime_module_path [256];
  2354| 	const uint8_t object_guid [EP_GUID_SIZE] = { 0 };
  2355| 	const uint16_t runtime_product_qfe_version = 0;
  2356| 	const uint8_t startup_flags = 0;
  2357| 	const uint8_t startup_mode = 0;
  2358| 	const ep_char8_t *command_line = "";
  2359| 	if (!g_module_address ((void *)mono_init, runtime_module_path, sizeof (runtime_module_path), NULL, NULL, 0, NULL))
  2360| 		runtime_module_path [0] = '\0';
  2361| 	FireEtwRuntimeInformationDCStart (
  2362| 		clr_instance_get_id (),
  2363| 		RUNTIME_SKU_MONO,
  2364| 		RuntimeProductMajorVersion,
  2365| 		RuntimeProductMinorVersion,
  2366| 		RuntimeProductPatchVersion,
  2367| 		runtime_product_qfe_version,
  2368| 		RuntimeFileMajorVersion,
  2369| 		RuntimeFileMajorVersion,
  2370| 		RuntimeFileBuildVersion,
  2371| 		RuntimeFileRevisionVersion,
  2372| 		startup_mode,
  2373| 		startup_flags,
  2374| 		command_line,
  2375| 		object_guid,
  2376| 		runtime_module_path,
  2377| 		NULL,
  2378| 		NULL);
  2379| 	if (execution_checkpoints) {
  2380| 		ep_rt_execution_checkpoint_array_iterator_t execution_checkpoints_iterator = ep_rt_execution_checkpoint_array_iterator_begin (execution_checkpoints);
  2381| 		while (!ep_rt_execution_checkpoint_array_iterator_end (execution_checkpoints, &execution_checkpoints_iterator)) {
  2382| 			EventPipeExecutionCheckpoint *checkpoint = ep_rt_execution_checkpoint_array_iterator_value (&execution_checkpoints_iterator);
  2383| 			FireEtwExecutionCheckpointDCEnd (
  2384| 				clr_instance_get_id (),
  2385| 				checkpoint->name,
  2386| 				checkpoint->timestamp,
  2387| 				NULL,
  2388| 				NULL);
  2389| 			ep_rt_execution_checkpoint_array_iterator_next (&execution_checkpoints_iterator);
  2390| 		}
  2391| 	}
  2392| 	FireEtwDCEndInit_V1 (
  2393| 		clr_instance_get_id (),
  2394| 		NULL,
  2395| 		NULL);
  2396| 	eventpipe_execute_rundown (
  2397| 		fire_domain_rundown_events_func,
  2398| 		fire_assembly_rundown_events_func,
  2399| 		fire_method_rundown_events_func);
  2400| 	FireEtwDCEndComplete_V1 (
  2401| 		clr_instance_get_id (),
  2402| 		NULL,
  2403| 		NULL);
  2404| }
  2405| bool
  2406| ep_rt_mono_write_event_ee_startup_start (void)
  2407| {
  2408| 	return FireEtwEEStartupStart_V1 (
  2409| 		clr_instance_get_id (),
  2410| 		NULL,
  2411| 		NULL);
  2412| }
  2413| #define STACK_ALLOC 256
  2414| #define INIT_SIZE_OF_TYPE_PARAMETER_ARRAY ((uint32_t)(STACK_ALLOC / sizeof (intptr_t)))
  2415| typedef enum {
  2416| 	TYPE_FLAGS_DELEGATE = 0x1,
  2417| 	TYPE_FLAGS_FINALIZABLE = 0x2,
  2418| 	TYPE_FLAGS_EXTERNALLY_IMPLEMENTED_COM_OBJECT = 0x4,
  2419| 	TYPE_FLAGS_ARRAY = 0x8,
  2420| 	TYPE_FLAGS_ARRAY_RANK_MASK = 0x3F00,
  2421| 	TYPE_FLAGS_ARRAY_RANK_SHIFT = 8,
  2422| 	TYPE_FLAGS_ARRAY_RANK_MAX = TYPE_FLAGS_ARRAY_RANK_MASK >> TYPE_FLAGS_ARRAY_RANK_SHIFT
  2423| } TypeFlags;
  2424| typedef struct _EventStructBulkTypeFixedSizedData {
  2425| 	uint64_t type_id;
  2426| 	uint64_t module_id;
  2427| 	uint32_t type_name_id;
  2428| 	uint32_t flags;
  2429| 	uint8_t cor_element_type;
  2430| } EventStructBulkTypeFixedSizedData;
  2431| typedef struct _BulkTypeValue {
  2432| 	EventStructBulkTypeFixedSizedData fixed_sized_data;
  2433| 	uint32_t type_parameters_count;
  2434| 	MonoType **mono_type_parameters;
  2435| 	ep_char8_t *name; // Currently should only be NULL, TODO if we want to provide the name in the BulkTypeEvent data, figure out memory management to use
  2436| } BulkTypeValue;
  2437| static
  2438| void
  2439| ep_rt_bulk_type_value_clear (BulkTypeValue *bulk_type_value);
  2440| static
  2441| int
  2442| ep_rt_mono_get_byte_count_in_event (BulkTypeValue *bulk_type_value);
  2443| static
  2444| BulkTypeEventLogger*
  2445| ep_rt_bulk_type_event_logger_alloc (void);
  2446| static
  2447| void
  2448| ep_rt_bulk_type_event_logger_free (BulkTypeEventLogger *type_logger);
  2449| static
  2450| int
  2451| write_event_buffer (
  2452| 	const uint8_t *val,
  2453| 	int size,
  2454| 	char *buf_start,
  2455| 	char **buf_next);
  2456| static
  2457| int
  2458| write_event_buffer_int8 (
  2459| 	int8_t val,
  2460| 	char *buf_start,
  2461| 	char **buf_next);
  2462| static
  2463| int
  2464| write_event_buffer_int16 (
  2465| 	int16_t val,
  2466| 	char *buf_start,
  2467| 	char **buf_next);
  2468| static
  2469| int
  2470| write_event_buffer_int32 (
  2471| 	int32_t val,
  2472| 	char *buf_start,
  2473| 	char **buf_next);
  2474| static
  2475| int
  2476| write_event_buffer_int64 (
  2477| 	int64_t val,
  2478| 	char *buf_start,
  2479| 	char **buf_next);
  2480| static
  2481| uint64_t
  2482| get_typeid_for_type (MonoType *t);
  2483| static
  2484| uint64_t
  2485| get_typeid_for_class (MonoClass *c);
  2486| static
  2487| void
  2488| ep_rt_bulk_type_value_clear (BulkTypeValue *bulk_type_value)
  2489| {
  2490| 	memset (bulk_type_value, 0, sizeof(BulkTypeValue));
  2491| }
  2492| static
  2493| int
  2494| ep_rt_mono_get_byte_count_in_event (BulkTypeValue *bulk_type_value)
  2495| {
  2496| 	int name_len = 0;
  2497| 	return sizeof (bulk_type_value->fixed_sized_data.type_id) + 	// Fixed Sized Data
  2498| 		sizeof (bulk_type_value->fixed_sized_data.module_id) +
  2499| 		sizeof (bulk_type_value->fixed_sized_data.type_name_id) +
  2500| 		sizeof (bulk_type_value->fixed_sized_data.flags) +
  2501| 		sizeof (bulk_type_value->fixed_sized_data.cor_element_type) +
  2502| 		sizeof (bulk_type_value->type_parameters_count) +		// Type parameters
  2503| 		(name_len + 1) * sizeof (ep_char8_t) +		// Size of name, including null terminator
  2504| 		bulk_type_value->type_parameters_count * sizeof (uint64_t);	// Type parameters
  2505| }
  2506| #define MAX_EVENT_BYTE_COUNT (63 * 1024)
  2507| #define MAX_SIZE_OF_EVENT_BUFFER 65536
  2508| #define MAX_TYPE_VALUES_BYTES (MAX_EVENT_BYTE_COUNT - 0x30)
  2509| #define K_MAX_COUNT_TYPE_VALUES ((uint32_t)(128 - 2) / 4)
  2510| struct _BulkTypeEventLogger {
  2511| 	BulkTypeValue bulk_type_values [K_MAX_COUNT_TYPE_VALUES];
  2512| 	uint8_t *bulk_type_event_buffer;
  2513| 	uint32_t bulk_type_value_count;
  2514| 	uint32_t bulk_type_value_byte_count;
  2515| 	MonoMemPool *mem_pool;
  2516| };
  2517| static
  2518| BulkTypeEventLogger*
  2519| ep_rt_bulk_type_event_logger_alloc ()
  2520| {
  2521| 	BulkTypeEventLogger *type_logger = g_malloc0 (sizeof (BulkTypeEventLogger));
  2522| 	type_logger->bulk_type_event_buffer = g_malloc0 (sizeof (uint8_t) * MAX_SIZE_OF_EVENT_BUFFER);
  2523| 	type_logger->mem_pool = mono_mempool_new ();
  2524| 	return type_logger;
  2525| }
  2526| static
  2527| void
  2528| ep_rt_bulk_type_event_logger_free (BulkTypeEventLogger *type_logger)
  2529| {
  2530| 	mono_mempool_destroy (type_logger->mem_pool);
  2531| 	g_free (type_logger->bulk_type_event_buffer);
  2532| 	g_free (type_logger);
  2533| }
  2534| static
  2535| int
  2536| write_event_buffer (
  2537| 	const uint8_t *val,
  2538| 	int size,
  2539| 	char *buf_start,
  2540| 	char **buf_next)
  2541| {
  2542| 	memcpy (buf_start, val, size);
  2543| 	*buf_next = buf_start + size;
  2544| 	return size;
  2545| }
  2546| static
  2547| int
  2548| write_event_buffer_int8 (
  2549| 	int8_t val,
  2550| 	char *buf_start,
  2551| 	char **buf_next)
  2552| {
  2553| 	return write_event_buffer ((const uint8_t *)&val, sizeof (int8_t), buf_start, buf_next);
  2554| }
  2555| static
  2556| int
  2557| write_event_buffer_int16 (
  2558| 	int16_t val,
  2559| 	char *buf_start,
  2560| 	char **buf_next)
  2561| {
  2562| 	return write_event_buffer ((const uint8_t *)&val, sizeof (int16_t), buf_start, buf_next);
  2563| }
  2564| static
  2565| int
  2566| write_event_buffer_int32 (
  2567| 	int32_t val,
  2568| 	char *buf_start,
  2569| 	char **buf_next)
  2570| {
  2571| 	return write_event_buffer ((const uint8_t *)&val, sizeof (int32_t), buf_start, buf_next);
  2572| }
  2573| static
  2574| int
  2575| write_event_buffer_int64 (
  2576| 	int64_t val,
  2577| 	char *buf_start,
  2578| 	char **buf_next)
  2579| {
  2580| 	return write_event_buffer ((const uint8_t *)&val, sizeof (int64_t), buf_start, buf_next);
  2581| }
  2582| void
  2583| ep_rt_mono_fire_bulk_type_event (BulkTypeEventLogger *type_logger)
  2584| {
  2585| 	if (type_logger->bulk_type_value_count == 0)
  2586| 		return;
  2587| 	uint16_t clr_instance_id = clr_instance_get_id ();
  2588| 	uint32_t values_element_size = 0;
  2589| 	char *ptr = (char *)type_logger->bulk_type_event_buffer;
  2590| 	for (uint32_t type_value_index = 0; type_value_index < type_logger->bulk_type_value_count; type_value_index++) {
  2591| 		BulkTypeValue *target = &type_logger->bulk_type_values [type_value_index];
  2592| 		values_element_size += write_event_buffer_int64 (target->fixed_sized_data.type_id, ptr, &ptr);
  2593| 		values_element_size += write_event_buffer_int64 (target->fixed_sized_data.module_id, ptr, &ptr);
  2594| 		values_element_size += write_event_buffer_int32 (target->fixed_sized_data.type_name_id, ptr, &ptr);
  2595| 		values_element_size += write_event_buffer_int32 (target->fixed_sized_data.flags, ptr, &ptr);
  2596| 		values_element_size += write_event_buffer_int8 (target->fixed_sized_data.cor_element_type, ptr, &ptr);
  2597| 		g_assert (target->name == NULL);
  2598| 		values_element_size += write_event_buffer_int16 (0, ptr, &ptr);
  2599| 		values_element_size += write_event_buffer_int32 (target->type_parameters_count, ptr, &ptr);
  2600| 		for (uint32_t i = 0; i < target->type_parameters_count; i++) {
  2601| 			uint64_t type_parameter = get_typeid_for_type (target->mono_type_parameters [i]);
  2602| 			values_element_size += write_event_buffer_int64 ((int64_t)type_parameter, ptr, &ptr);
  2603| 		}
  2604| 	}
  2605| 	FireEtwBulkType (
  2606| 		type_logger->bulk_type_value_count,
  2607| 		clr_instance_id,
  2608| 		values_element_size,
  2609| 		type_logger->bulk_type_event_buffer,
  2610| 		NULL,
  2611| 		NULL);
  2612| 	memset (type_logger->bulk_type_event_buffer, 0, sizeof (uint8_t) * MAX_SIZE_OF_EVENT_BUFFER);
  2613| 	type_logger->bulk_type_value_count = 0;
  2614| 	type_logger->bulk_type_value_byte_count = 0;
  2615| }
  2616| static
  2617| uint64_t
  2618| get_typeid_for_type (MonoType *t)
  2619| {
  2620| 	if (m_type_is_byref (t))
  2621| 		return (uint64_t)m_class_get_this_arg (mono_class_from_mono_type_internal (t));
  2622| 	else
  2623| 		return (uint64_t)m_class_get_byval_arg (mono_class_from_mono_type_internal (t));
  2624| }
  2625| static
  2626| uint64_t
  2627| get_typeid_for_class (MonoClass *c)
  2628| {
  2629| 	return get_typeid_for_type (m_class_get_byval_arg (c));
  2630| }
  2631| int
  2632| ep_rt_mono_log_single_type (
  2633| 	BulkTypeEventLogger *type_logger,
  2634| 	MonoType *mono_type)
  2635| {
  2636| 	if (type_logger->bulk_type_value_count == K_MAX_COUNT_TYPE_VALUES)
  2637| 		ep_rt_mono_fire_bulk_type_event (type_logger);
  2638| 	EP_ASSERT (type_logger->bulk_type_value_count < K_MAX_COUNT_TYPE_VALUES);
  2639| 	BulkTypeValue *val = &type_logger->bulk_type_values [type_logger->bulk_type_value_count];
  2640| 	ep_rt_bulk_type_value_clear (val);
  2641| 	MonoClass *klass = mono_class_from_mono_type_internal (mono_type);
  2642| 	MonoType *mono_underlying_type = mono_type_get_underlying_type (mono_type);
  2643| 	val->fixed_sized_data.type_id = get_typeid_for_type (mono_type);
  2644| 	val->fixed_sized_data.module_id = (uint64_t)m_class_get_image (klass);
  2645| 	val->fixed_sized_data.type_name_id = m_class_get_type_token (klass) ? mono_metadata_make_token (MONO_TABLE_TYPEDEF, mono_metadata_token_index (m_class_get_type_token (klass))) : 0;
  2646| 	if (mono_class_has_finalizer (klass))
  2647| 		val->fixed_sized_data.flags |= TYPE_FLAGS_FINALIZABLE;
  2648| 	if (m_class_is_delegate (klass))
  2649| 		val->fixed_sized_data.flags |= TYPE_FLAGS_DELEGATE;
  2650| 	if (mono_class_is_com_object (klass))
  2651| 		val->fixed_sized_data.flags |= TYPE_FLAGS_EXTERNALLY_IMPLEMENTED_COM_OBJECT;
  2652| 	val->fixed_sized_data.cor_element_type = (uint8_t)mono_underlying_type->type;
  2653| 	switch (mono_underlying_type->type) {
  2654| 	case MONO_TYPE_ARRAY:
  2655| 	case MONO_TYPE_SZARRAY:
  2656| 	{
  2657| 		MonoArrayType *mono_array_type = mono_type_get_array_type (mono_type);
  2658| 		val->fixed_sized_data.flags |= TYPE_FLAGS_ARRAY;
  2659| 		if (mono_underlying_type->type == MONO_TYPE_ARRAY) {
  2660| 			uint32_t rank = mono_array_type->rank;
  2661| 			if (rank < TYPE_FLAGS_ARRAY_RANK_MAX) {
  2662| 				rank <<= 8;
  2663| 				val->fixed_sized_data.flags |= rank;
  2664| 			}
  2665| 		}
  2666| 		val->mono_type_parameters = mono_mempool_alloc0 (type_logger->mem_pool, 1 * sizeof (MonoType*));
  2667| 		*val->mono_type_parameters = m_class_get_byval_arg (mono_array_type->eklass);
  2668| 		val->type_parameters_count++;
  2669| 		break;
  2670| 	}
  2671| 	case MONO_TYPE_GENERICINST:
  2672| 	{
  2673| 		MonoGenericInst *class_inst = mono_type->data.generic_class->context.class_inst;
  2674| 		val->type_parameters_count = class_inst->type_argc;
  2675| 		val->mono_type_parameters = mono_mempool_alloc0 (type_logger->mem_pool, val->type_parameters_count * sizeof (MonoType*));
  2676| 		memcpy (val->mono_type_parameters, class_inst->type_argv, val->type_parameters_count * sizeof (MonoType*));
  2677| 		break;
  2678| 	}
  2679| 	case MONO_TYPE_CLASS:
  2680| 	case MONO_TYPE_VALUETYPE:
  2681| 	case MONO_TYPE_PTR:
  2682| 	case MONO_TYPE_BYREF:
  2683| 	{
  2684| 		if (mono_underlying_type == mono_type)
  2685| 			break;
  2686| 		val->mono_type_parameters = mono_mempool_alloc0 (type_logger->mem_pool, 1 * sizeof (MonoType*));
  2687| 		*val->mono_type_parameters = mono_underlying_type;
  2688| 		val->type_parameters_count++;
  2689| 		break;
  2690| 	}
  2691| 	default:
  2692| 		break;
  2693| 	}
  2694| 	int val_byte_count = ep_rt_mono_get_byte_count_in_event (val);
  2695| 	if (val_byte_count > MAX_TYPE_VALUES_BYTES) {
  2696| 		mono_trace (G_LOG_LEVEL_ERROR, MONO_TRACE_DIAGNOSTICS, "Failed to log single mono type %p with typeID %llu. Type is too large for the BulkType Event.\n", (gpointer)mono_type, (unsigned long long)val->fixed_sized_data.type_id);
  2697| 		return -1;
  2698| 	}
  2699| 	if (type_logger->bulk_type_value_byte_count + val_byte_count > MAX_TYPE_VALUES_BYTES) {
  2700| 		g_assert (type_logger->bulk_type_value_byte_count + val_byte_count > MAX_TYPE_VALUES_BYTES);
  2701| 		ep_rt_mono_fire_bulk_type_event (type_logger);
  2702| 		return ep_rt_mono_log_single_type (type_logger, mono_type);
  2703| 	}
  2704| 	type_logger->bulk_type_value_count++;
  2705| 	type_logger->bulk_type_value_byte_count += val_byte_count;
  2706| 	return type_logger->bulk_type_value_count - 1;
  2707| }
  2708| void
  2709| ep_rt_mono_log_type_and_parameters (
  2710| 	BulkTypeEventLogger *type_logger,
  2711| 	MonoType *mono_type)
  2712| {
  2713| 	int bulk_type_value_index = ep_rt_mono_log_single_type (type_logger, mono_type);
  2714| 	if (bulk_type_value_index == -1) {
  2715| 		return;
  2716| 	}
  2717| 	BulkTypeValue *val = &type_logger->bulk_type_values [bulk_type_value_index];
  2718| 	uint32_t param_count = val->type_parameters_count;
  2719| 	if (param_count == 0)
  2720| 		return;
  2721| 	MonoType **mono_type_parameters = mono_mempool_alloc0 (type_logger->mem_pool, param_count * sizeof (MonoType*));
  2722| 	memcpy (mono_type_parameters, val->mono_type_parameters, sizeof (MonoType*) * param_count);
  2723| 	for (uint32_t i = 0; i < param_count; i++)
  2724| 		ep_rt_mono_log_type_and_parameters_if_necessary (type_logger, mono_type_parameters [i]);
  2725| }
  2726| void
  2727| ep_rt_mono_log_type_and_parameters_if_necessary (
  2728| 	BulkTypeEventLogger *type_logger,
  2729| 	MonoType *mono_type)
  2730| {
  2731| 	ep_rt_mono_log_type_and_parameters (type_logger, mono_type);
  2732| }
  2733| static const uint32_t MAX_METHOD_TYPE_ARGUMENT_COUNT = 1024;
  2734| void
  2735| ep_rt_mono_send_method_details_event (MonoMethod *method)
  2736| {
  2737| 	if (method->wrapper_type != MONO_WRAPPER_NONE || method->dynamic)
  2738| 		return;
  2739| 	MonoGenericContext *method_ctx = mono_method_get_context (method);
  2740| 	MonoGenericInst *method_inst = NULL;
  2741| 	if (method_ctx)
  2742| 		method_inst = method_ctx->method_inst;
  2743| 	if (method_inst && method_inst->type_argc > MAX_METHOD_TYPE_ARGUMENT_COUNT)
  2744| 		return;
  2745| 	BulkTypeEventLogger *type_logger = ep_rt_bulk_type_event_logger_alloc ();
  2746| 	uint64_t method_type_id = 0;
  2747| 	g_assert (mono_metadata_token_index (method->token) != 0);
  2748| 	uint32_t method_token = mono_metadata_make_token (MONO_TABLE_METHOD, mono_metadata_token_index (method->token));
  2749| 	uint64_t loader_module_id = 0;
  2750| 	MonoClass *klass = method->klass;
  2751| 	if (klass) {
  2752| 		MonoType *method_mono_type = m_class_get_byval_arg (klass);
  2753| 		method_type_id = get_typeid_for_class (klass);
  2754| 		ep_rt_mono_log_type_and_parameters_if_necessary (type_logger, method_mono_type);
  2755| 		loader_module_id = (uint64_t)mono_class_get_image (klass);
  2756| 	}
  2757| 	uint32_t method_inst_parameter_types_count = 0;
  2758| 	if (method_inst)
  2759| 		method_inst_parameter_types_count = method_inst->type_argc;
  2760| 	uint64_t *method_inst_parameters_type_ids = mono_mempool_alloc0 (type_logger->mem_pool, method_inst_parameter_types_count * sizeof (uint64_t));
  2761| 	for (uint32_t i = 0; i < method_inst_parameter_types_count; i++) {
  2762| 		method_inst_parameters_type_ids [i] = get_typeid_for_type (method_inst->type_argv [i]);
  2763| 		ep_rt_mono_log_type_and_parameters_if_necessary (type_logger, method_inst->type_argv [i]);
  2764| 	}
  2765| 	ep_rt_mono_fire_bulk_type_event (type_logger);
  2766| 	FireEtwMethodDetails (
  2767| 		(uint64_t)method,
  2768| 		method_type_id,
  2769| 		method_token,
  2770| 		method_inst_parameter_types_count,
  2771| 		loader_module_id,
  2772| 		(uint64_t*)method_inst_parameters_type_ids,
  2773| 		NULL,
  2774| 		NULL);
  2775| 	ep_rt_bulk_type_event_logger_free (type_logger);
  2776| }
  2777| bool
  2778| ep_rt_mono_write_event_jit_start (MonoMethod *method)
  2779| {
  2780| 	if (!EventEnabledMethodJittingStarted_V1 ())
  2781| 		return true;
  2782| 	if (method) {
  2783| 		uint64_t method_id = 0;
  2784| 		uint64_t module_id = 0;
  2785| 		uint32_t code_size = 0;
  2786| 		uint32_t method_token = 0;
  2787| 		char *method_namespace = NULL;
  2788| 		const char *method_name = NULL;
  2789| 		char *method_signature = NULL;
  2790| 		ep_rt_mono_send_method_details_event(method);
  2791| 		method_id = (uint64_t)method;
  2792| 		if (!method->dynamic)
  2793| 			method_token = method->token;
  2794| 		if (!mono_method_has_no_body (method)) {
  2795| 			ERROR_DECL (error);
  2796| 			MonoMethodHeader *header = mono_method_get_header_internal (method, error);
  2797| 			if (header)
  2798| 				code_size = header->code_size;
  2799| 		}
  2800| 		method_name = method->name;
  2801| 		method_signature = mono_signature_full_name (mono_method_signature_internal (method));
  2802| 		if (method->klass) {
  2803| 			module_id = (uint64_t)m_class_get_image (method->klass);
  2804| 			method_namespace = mono_type_get_name_full (m_class_get_byval_arg (method->klass), MONO_TYPE_NAME_FORMAT_IL);
  2805| 		}
  2806| 		FireEtwMethodJittingStarted_V1 (
  2807| 			method_id,
  2808| 			module_id,
  2809| 			method_token,
  2810| 			code_size,
  2811| 			method_namespace,
  2812| 			method_name,
  2813| 			method_signature,
  2814| 			clr_instance_get_id (),
  2815| 			NULL,
  2816| 			NULL);
  2817| 		g_free (method_namespace);
  2818| 		g_free (method_signature);
  2819| 	}
  2820| 	return true;
  2821| }
  2822| bool
  2823| ep_rt_mono_write_event_method_il_to_native_map (
  2824| 	MonoMethod *method,
  2825| 	MonoJitInfo *ji)
  2826| {
  2827| 	if (!EventEnabledMethodILToNativeMap ())
  2828| 		return true;
  2829| 	if (method) {
  2830| 		MonoDomain *root_domain = mono_get_root_domain ();
  2831| 		uint64_t method_id = (uint64_t)method;
  2832| 		uint32_t fixed_buffer [64];
  2833| 		uint8_t *buffer = NULL;
  2834| 		uint32_t offset_entries = 0;
  2835| 		uint32_t *il_offsets = NULL;
  2836| 		uint32_t *native_offsets = NULL;
  2837| 		MonoDebugMethodJitInfo *debug_info = method ? mono_debug_find_method (method, root_domain) : NULL;
  2838| 		if (debug_info) {
  2839| 			offset_entries = debug_info->num_line_numbers;
  2840| 			if (offset_entries != 0) {
  2841| 				size_t needed_size = (offset_entries * sizeof (uint32_t) * 2);
  2842| 				if (needed_size > sizeof (fixed_buffer)) {
  2843| 					buffer = g_new (uint8_t, needed_size);
  2844| 					il_offsets = (uint32_t*)buffer;
  2845| 				} else {
  2846| 					il_offsets = fixed_buffer;
  2847| 				}
  2848| 				if (il_offsets) {
  2849| 					native_offsets = il_offsets + offset_entries;
  2850| 					for (uint32_t offset_count = 0; offset_count < offset_entries; ++offset_count) {
  2851| 						il_offsets [offset_count] = debug_info->line_numbers [offset_count].il_offset;
  2852| 						native_offsets [offset_count] = debug_info->line_numbers [offset_count].native_offset;
  2853| 					}
  2854| 				}
  2855| 			}
  2856| 			mono_debug_free_method_jit_info (debug_info);
  2857| 		}
  2858| 		if (!il_offsets && !native_offsets) {
  2859| 			EP_ASSERT (sizeof (fixed_buffer) >= sizeof (uint32_t) * 2);
  2860| 			offset_entries = 1;
  2861| 			il_offsets = fixed_buffer;
  2862| 			native_offsets = il_offsets + offset_entries;
  2863| 			il_offsets [0] = 0;
  2864| 			native_offsets [0] = ji ? (uint32_t)ji->code_size : 0;
  2865| 		}
  2866| 		FireEtwMethodILToNativeMap (
  2867| 			method_id,
  2868| 			0,
  2869| 			0,
  2870| 			GUINT32_TO_UINT16 (offset_entries),
  2871| 			il_offsets,
  2872| 			native_offsets,
  2873| 			clr_instance_get_id (),
  2874| 			NULL,
  2875| 			NULL);
  2876| 		g_free (buffer);
  2877| 	}
  2878| 	return true;
  2879| }
  2880| bool
  2881| ep_rt_mono_write_event_method_load (
  2882| 	MonoMethod *method,
  2883| 	MonoJitInfo *ji)
  2884| {
  2885| 	if (!EventEnabledMethodLoad_V1 () && !EventEnabledMethodLoadVerbose_V1 ())
  2886| 		return true;
  2887| 	if (method) {
  2888| 		uint64_t method_id = 0;
  2889| 		uint64_t module_id = 0;
  2890| 		uint64_t method_code_start = ji ? (uint64_t)ji->code_start : 0;
  2891| 		uint32_t method_code_size = ji ? (uint32_t)ji->code_size : 0;
  2892| 		uint32_t method_token = 0;
  2893| 		uint32_t method_flags = 0;
  2894| 		uint8_t kind = MONO_CLASS_DEF;
  2895| 		char *method_namespace = NULL;
  2896| 		const char *method_name = NULL;
  2897| 		char *method_signature = NULL;
  2898| 		bool verbose = (MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_EVENTPIPE_Context.Level >= (uint8_t)EP_EVENT_LEVEL_VERBOSE);
  2899| 		method_id = (uint64_t)method;
  2900| 		if (!method->dynamic)
  2901| 			method_token = method->token;
  2902| 		if (ji && mono_jit_info_get_generic_sharing_context (ji)) {
  2903| 			method_flags |= METHOD_FLAGS_SHARED_GENERIC_METHOD;
  2904| 			verbose = true;
  2905| 		}
  2906| 		if (method->dynamic) {
  2907| 			method_flags |= METHOD_FLAGS_DYNAMIC_METHOD;
  2908| 			verbose = true;
  2909| 		}
  2910| 		if (ji && !ji->from_aot && !ji->from_llvm) {
  2911| 			method_flags |= METHOD_FLAGS_JITTED_METHOD;
  2912| 			if (method->wrapper_type != MONO_WRAPPER_NONE)
  2913| 				method_flags |= METHOD_FLAGS_JITTED_HELPER_METHOD;
  2914| 		}
  2915| 		if (method->is_generic || method->is_inflated) {
  2916| 			method_flags |= METHOD_FLAGS_GENERIC_METHOD;
  2917| 			verbose = true;
  2918| 		}
  2919| 		if (method->klass) {
  2920| 			module_id = (uint64_t)m_class_get_image (method->klass);
  2921| 			kind = m_class_get_class_kind (method->klass);
  2922| 			if (kind == MONO_CLASS_GTD || kind == MONO_CLASS_GINST)
  2923| 				method_flags |= METHOD_FLAGS_GENERIC_METHOD;
  2924| 		}
  2925| 		ep_rt_mono_send_method_details_event(method);
  2926| 		if (verbose) {
  2927| 			method_name = method->name;
  2928| 			method_signature = mono_signature_full_name (mono_method_signature_internal (method));
  2929| 			if (method->klass)
  2930| 				method_namespace = mono_type_get_name_full (m_class_get_byval_arg (method->klass), MONO_TYPE_NAME_FORMAT_IL);
  2931| 			FireEtwMethodLoadVerbose_V1 (
  2932| 				method_id,
  2933| 				module_id,
  2934| 				method_code_start,
  2935| 				method_code_size,
  2936| 				method_token,
  2937| 				method_flags | METHOD_FLAGS_EXTENT_HOT_SECTION,
  2938| 				method_namespace,
  2939| 				method_name,
  2940| 				method_signature,
  2941| 				clr_instance_get_id (),
  2942| 				NULL,
  2943| 				NULL);
  2944| 			if (ji && (ji->from_aot || ji->from_llvm))
  2945| 				FireEtwMethodLoadVerbose_V1 (
  2946| 					method_id,
  2947| 					module_id,
  2948| 					method_code_start,
  2949| 					method_code_size,
  2950| 					method_token,
  2951| 					method_flags | METHOD_FLAGS_EXTENT_COLD_SECTION,
  2952| 					method_namespace,
  2953| 					method_name,
  2954| 					method_signature,
  2955| 					clr_instance_get_id (),
  2956| 					NULL,
  2957| 					NULL);
  2958| 		} else {
  2959| 			FireEtwMethodLoad_V1 (
  2960| 				method_id,
  2961| 				module_id,
  2962| 				method_code_start,
  2963| 				method_code_size,
  2964| 				method_token,
  2965| 				method_flags | METHOD_FLAGS_EXTENT_HOT_SECTION,
  2966| 				clr_instance_get_id (),
  2967| 				NULL,
  2968| 				NULL);
  2969| 			if (ji && (ji->from_aot || ji->from_llvm))
  2970| 				FireEtwMethodLoad_V1 (
  2971| 					method_id,
  2972| 					module_id,
  2973| 					method_code_start,
  2974| 					method_code_size,
  2975| 					method_token,
  2976| 					method_flags | METHOD_FLAGS_EXTENT_COLD_SECTION,
  2977| 					clr_instance_get_id (),
  2978| 					NULL,
  2979| 					NULL);
  2980| 		}
  2981| 		g_free (method_namespace);
  2982| 		g_free (method_signature);
  2983| 	}
  2984| 	return true;
  2985| }
  2986| static
  2987| bool
  2988| get_module_event_data (
  2989| 	MonoImage *image,
  2990| 	ModuleEventData *module_data)
  2991| {
  2992| 	if (module_data) {
  2993| 		memset (module_data->module_il_pdb_signature, 0, EP_GUID_SIZE);
  2994| 		memset (module_data->module_native_pdb_signature, 0, EP_GUID_SIZE);
  2995| 		MonoDomain *root_domain = mono_get_root_domain ();
  2996| 		module_data->domain_id = (uint64_t)root_domain;
  2997| 		module_data->module_id = (uint64_t)image;
  2998| 		module_data->assembly_id = image ? (uint64_t)image->assembly : 0;
  2999| 		module_data->module_native_path = "";
  3000| 		module_data->module_native_pdb_path = "";
  3001| 		module_data->module_native_pdb_age = 0;
  3002| 		module_data->reserved_flags = 0;
  3003| 		module_data->module_flags = MODULE_FLAGS_MANIFEST_MODULE;
  3004| 		if (image && image->dynamic)
  3005| 			module_data->module_flags |= MODULE_FLAGS_DYNAMIC_MODULE;
  3006| 		if (image && image->aot_module)
  3007| 			module_data->module_flags |= MODULE_FLAGS_NATIVE_MODULE;
  3008| 		module_data->module_il_path = NULL;
  3009| 		if (image && image->filename) {
  3010| 			/* if there's a filename, use it */
  3011| 			module_data->module_il_path = image->filename;
  3012| 		} else if (image && image->module_name) {
  3013| 			/* otherwise, use the module name */
  3014| 			module_data->module_il_path = image->module_name;
  3015| 		}
  3016| 		if (!module_data->module_il_path)
  3017| 			module_data->module_il_path = "";
  3018| 		module_data->module_il_pdb_path = "";
  3019| 		module_data->module_il_pdb_age = 0;
  3020| 		if (image && image->image_info) {
  3021| 			MonoPEDirEntry *debug_dir_entry = (MonoPEDirEntry *)&image->image_info->cli_header.datadir.pe_debug;
  3022| 			if (debug_dir_entry->size) {
  3023| 				ImageDebugDirectory debug_dir;
  3024| 				memset (&debug_dir, 0, sizeof (debug_dir));
  3025| 				uint32_t offset = mono_cli_rva_image_map (image, debug_dir_entry->rva);
  3026| 				for (uint32_t idx = 0; idx < debug_dir_entry->size / sizeof (ImageDebugDirectory); ++idx) {
  3027| 					uint8_t *data = (uint8_t *) ((ImageDebugDirectory *) (image->raw_data + offset) + idx);
  3028| 					debug_dir.major_version = read16 (data + 8);
  3029| 					debug_dir.minor_version = read16 (data + 10);
  3030| 					debug_dir.type = read32 (data + 12);
  3031| 					debug_dir.pointer = read32 (data + 24);
  3032| 					if (debug_dir.type == DEBUG_DIR_ENTRY_CODEVIEW && debug_dir.major_version == 0x100 && debug_dir.minor_version == 0x504d) {
  3033| 						data  = (uint8_t *)(image->raw_data + debug_dir.pointer);
  3034| 						int32_t signature = read32 (data);
  3035| 						if (signature == 0x53445352) {
  3036| 							memcpy (module_data->module_il_pdb_signature, data + 4, EP_GUID_SIZE);
  3037| 							module_data->module_il_pdb_age = read32 (data + 20);
  3038| 							module_data->module_il_pdb_path = (const char *)(data + 24);
  3039| 							break;
  3040| 						}
  3041| 					}
  3042| 				}
  3043| 			}
  3044| 		}
  3045| 	}
  3046| 	return true;
  3047| }
  3048| bool
  3049| ep_rt_mono_write_event_module_load (MonoImage *image)
  3050| {
  3051| 	if (!EventEnabledModuleLoad_V2 () && !EventEnabledDomainModuleLoad_V1 ())
  3052| 		return true;
  3053| 	if (image) {
  3054| 		ModuleEventData module_data;
  3055| 		memset (&module_data, 0, sizeof (module_data));
  3056| 		if (get_module_event_data (image, &module_data)) {
  3057| 			FireEtwModuleLoad_V2 (
  3058| 				module_data.module_id,
  3059| 				module_data.assembly_id,
  3060| 				module_data.module_flags,
  3061| 				module_data.reserved_flags,
  3062| 				module_data.module_il_path,
  3063| 				module_data.module_native_path,
  3064| 				clr_instance_get_id (),
  3065| 				module_data.module_il_pdb_signature,
  3066| 				module_data.module_il_pdb_age,
  3067| 				module_data.module_il_pdb_path,
  3068| 				module_data.module_native_pdb_signature,
  3069| 				module_data.module_native_pdb_age,
  3070| 				module_data.module_native_pdb_path,
  3071| 				NULL,
  3072| 				NULL);
  3073| 			FireEtwDomainModuleLoad_V1 (
  3074| 				module_data.module_id,
  3075| 				module_data.assembly_id,
  3076| 				module_data.domain_id,
  3077| 				module_data.module_flags,
  3078| 				module_data.reserved_flags,
  3079| 				module_data.module_il_path,
  3080| 				module_data.module_native_path,
  3081| 				clr_instance_get_id (),
  3082| 				NULL,
  3083| 				NULL);
  3084| 		}
  3085| 	}
  3086| 	return true;
  3087| }
  3088| bool
  3089| ep_rt_mono_write_event_module_unload (MonoImage *image)
  3090| {
  3091| 	if (!EventEnabledModuleUnload_V2())
  3092| 		return true;
  3093| 	if (image) {
  3094| 		ModuleEventData module_data;
  3095| 		memset (&module_data, 0, sizeof (module_data));
  3096| 		if (get_module_event_data (image, &module_data)) {
  3097| 			FireEtwModuleUnload_V2 (
  3098| 				module_data.module_id,
  3099| 				module_data.assembly_id,
  3100| 				module_data.module_flags,
  3101| 				module_data.reserved_flags,
  3102| 				module_data.module_il_path,
  3103| 				module_data.module_native_path,
  3104| 				clr_instance_get_id (),
  3105| 				module_data.module_il_pdb_signature,
  3106| 				module_data.module_il_pdb_age,
  3107| 				module_data.module_il_pdb_path,
  3108| 				module_data.module_native_pdb_signature,
  3109| 				module_data.module_native_pdb_age,
  3110| 				module_data.module_native_pdb_path,
  3111| 				NULL,
  3112| 				NULL);
  3113| 		}
  3114| 	}
  3115| 	return true;
  3116| }
  3117| static
  3118| bool
  3119| get_assembly_event_data (
  3120| 	MonoAssembly *assembly,
  3121| 	AssemblyEventData *assembly_data)
  3122| {
  3123| 	if (assembly && assembly_data) {
  3124| 		MonoDomain *root_domain = mono_get_root_domain ();
  3125| 		assembly_data->domain_id = (uint64_t)root_domain;
  3126| 		assembly_data->assembly_id = (uint64_t)assembly;
  3127| 		assembly_data->binding_id = 0;
  3128| 		assembly_data->assembly_flags = 0;
  3129| 		if (assembly->dynamic)
  3130| 			assembly_data->assembly_flags |= ASSEMBLY_FLAGS_DYNAMIC_ASSEMBLY;
  3131| 		if (assembly->image && assembly->image->aot_module)
  3132| 			assembly_data->assembly_flags |= ASSEMBLY_FLAGS_NATIVE_ASSEMBLY;
  3133| 		assembly_data->assembly_name = mono_stringify_assembly_name (&assembly->aname);
  3134| 	}
  3135| 	return true;
  3136| }
  3137| bool
  3138| ep_rt_mono_write_event_assembly_load (MonoAssembly *assembly)
  3139| {
  3140| 	if (!EventEnabledAssemblyLoad_V1 ())
  3141| 		return true;
  3142| 	if (assembly) {
  3143| 		AssemblyEventData assembly_data;
  3144| 		memset (&assembly_data, 0, sizeof (assembly_data));
  3145| 		if (get_assembly_event_data (assembly, &assembly_data)) {
  3146| 			FireEtwAssemblyLoad_V1 (
  3147| 				assembly_data.assembly_id,
  3148| 				assembly_data.domain_id,
  3149| 				assembly_data.binding_id,
  3150| 				assembly_data.assembly_flags,
  3151| 				assembly_data.assembly_name,
  3152| 				clr_instance_get_id (),
  3153| 				NULL,
  3154| 				NULL);
  3155| 			g_free (assembly_data.assembly_name);
  3156| 		}
  3157| 	}
  3158| 	return true;
  3159| }
  3160| bool
  3161| ep_rt_mono_write_event_assembly_unload (MonoAssembly *assembly)
  3162| {
  3163| 	if (!EventEnabledAssemblyUnload_V1 ())
  3164| 		return true;
  3165| 	if (assembly) {
  3166| 		AssemblyEventData assembly_data;
  3167| 		memset (&assembly_data, 0, sizeof (assembly_data));
  3168| 		if (get_assembly_event_data (assembly, &assembly_data)) {
  3169| 			FireEtwAssemblyUnload_V1 (
  3170| 				assembly_data.assembly_id,
  3171| 				assembly_data.domain_id,
  3172| 				assembly_data.binding_id,
  3173| 				assembly_data.assembly_flags,
  3174| 				assembly_data.assembly_name,
  3175| 				clr_instance_get_id (),
  3176| 				NULL,
  3177| 				NULL);
  3178| 			g_free (assembly_data.assembly_name);
  3179| 		}
  3180| 	}
  3181| 	return true;
  3182| }
  3183| bool
  3184| ep_rt_mono_write_event_thread_created (ep_rt_thread_id_t tid)
  3185| {
  3186| 	if (!EventEnabledThreadCreated ())
  3187| 		return true;
  3188| 	uint64_t managed_thread = 0;
  3189| 	uint32_t native_thread_id = MONO_NATIVE_THREAD_ID_TO_UINT (tid);
  3190| 	uint32_t managed_thread_id = 0;
  3191| 	uint32_t flags = 0;
  3192| 	MonoThread *thread = mono_thread_current ();
  3193| 	if (thread && mono_thread_info_get_tid (thread->thread_info) == tid) {
  3194| 		managed_thread_id = mono_thread_get_managed_id (thread);
  3195| 		managed_thread = (uint64_t)thread;
  3196| 		switch (mono_thread_info_get_flags (thread->thread_info)) {
  3197| 		case MONO_THREAD_INFO_FLAGS_NO_GC:
  3198| 		case MONO_THREAD_INFO_FLAGS_NO_SAMPLE:
  3199| 			flags |= THREAD_FLAGS_GC_SPECIAL;
  3200| 		}
  3201| 		if (mono_gc_is_finalizer_thread (thread))
  3202| 			flags |= THREAD_FLAGS_FINALIZER;
  3203| 		if (thread->threadpool_thread)
  3204| 			flags |= THREAD_FLAGS_THREADPOOL_WORKER;
  3205| 	}
  3206| 	FireEtwThreadCreated (
  3207| 		managed_thread,
  3208| 		(uint64_t)mono_get_root_domain (),
  3209| 		flags,
  3210| 		managed_thread_id,
  3211| 		native_thread_id,
  3212| 		clr_instance_get_id (),
  3213| 		NULL,
  3214| 		NULL);
  3215| 	return true;
  3216| }
  3217| bool
  3218| ep_rt_mono_write_event_thread_terminated (ep_rt_thread_id_t tid)
  3219| {
  3220| 	if (!EventEnabledThreadTerminated ())
  3221| 		return true;
  3222| 	uint64_t managed_thread = 0;
  3223| 	MonoThread *thread = mono_thread_current ();
  3224| 	if (thread && mono_thread_info_get_tid (thread->thread_info) == tid)
  3225| 		managed_thread = (uint64_t)thread;
  3226| 	FireEtwThreadTerminated (
  3227| 		managed_thread,
  3228| 		(uint64_t)mono_get_root_domain (),
  3229| 		clr_instance_get_id (),
  3230| 		NULL,
  3231| 		NULL);
  3232| 	return true;
  3233| }
  3234| static
  3235| uint32_t
  3236| get_type_start_id (MonoType *type)
  3237| {
  3238| 	uint32_t start_id = (uint32_t)(uintptr_t)type;
  3239| 	start_id = (((start_id * 215497) >> 16) ^ ((start_id * 1823231) + start_id));
  3240| MONO_DISABLE_WARNING(4127) /* conditional expression is constant */
  3241| 	if (sizeof (type) > 4)
  3242| 		start_id = start_id ^ GUINT64_TO_UINT32 ((((uint64_t)type >> 31) >> 1));
  3243| MONO_RESTORE_WARNING
  3244| 	return start_id;
  3245| }
  3246| bool
  3247| ep_rt_mono_write_event_type_load_start (MonoType *type)
  3248| {
  3249| 	if (!EventEnabledTypeLoadStart ())
  3250| 		return true;
  3251| 	FireEtwTypeLoadStart (
  3252| 		get_type_start_id (type),
  3253| 		clr_instance_get_id (),
  3254| 		NULL,
  3255| 		NULL);
  3256| 	return true;
  3257| }
  3258| bool
  3259| ep_rt_mono_write_event_type_load_stop (MonoType *type)
  3260| {
  3261| 	if (!EventEnabledTypeLoadStop ())
  3262| 		return true;
  3263| 	char *type_name = NULL;
  3264| 	if (type)
  3265| 		type_name = mono_type_get_name_full (type, MONO_TYPE_NAME_FORMAT_IL);
  3266| 	FireEtwTypeLoadStop (
  3267| 		get_type_start_id (type),
  3268| 		clr_instance_get_id (),
  3269| 		6 /* CLASS_LOADED */,
  3270| 		(uint64_t)type,
  3271| 		type_name,
  3272| 		NULL,
  3273| 		NULL);
  3274| 	g_free (type_name);
  3275| 	return true;
  3276| }
  3277| static
  3278| gboolean
  3279| get_exception_ip_func (
  3280| 	MonoStackFrameInfo *frame,
  3281| 	MonoContext *ctx,
  3282| 	void *data)
  3283| {
  3284| 	*(uintptr_t *)data = (uintptr_t)MONO_CONTEXT_GET_IP (ctx);
  3285| 	return TRUE;
  3286| }
  3287| bool
  3288| ep_rt_mono_write_event_exception_thrown (MonoObject *obj)
  3289| {
  3290| 	if (!EventEnabledExceptionThrown_V1 ())
  3291| 		return true;
  3292| 	if (obj) {
  3293| 		ERROR_DECL (error);
  3294| 		char *type_name = NULL;
  3295| 		char *exception_message = NULL;
  3296| 		uint16_t flags = 0;
  3297| 		uint32_t hresult = 0;
  3298| 		uintptr_t ip = 0;
  3299| 		if (mono_object_isinst_checked ((MonoObject *) obj, mono_get_exception_class (), error)) {
  3300| 			MonoException *exception = (MonoException *)obj;
  3301| 			flags |= EXCEPTION_THROWN_FLAGS_IS_CLS_COMPLIANT;
  3302| 			if (exception->inner_ex)
  3303| 				flags |= EXCEPTION_THROWN_FLAGS_HAS_INNER;
  3304| 			if (exception->message)
  3305| 				exception_message = ep_rt_utf16_to_utf8_string (mono_string_chars_internal (exception->message), mono_string_length_internal (exception->message));
  3306| 			hresult = exception->hresult;
  3307| 		}
  3308| 		if (exception_message == NULL)
  3309| 			exception_message = g_strdup ("");
  3310| 		if (mono_get_eh_callbacks ()->mono_walk_stack_with_ctx)
  3311| 			mono_get_eh_callbacks ()->mono_walk_stack_with_ctx (get_exception_ip_func, NULL, MONO_UNWIND_SIGNAL_SAFE, (void *)&ip);
  3312| 		type_name = mono_type_get_name_full (m_class_get_byval_arg (mono_object_class (obj)), MONO_TYPE_NAME_FORMAT_IL);
  3313| 		FireEtwExceptionThrown_V1 (
  3314| 			type_name,
  3315| 			exception_message,
  3316| 			(void *)&ip,
  3317| 			hresult,
  3318| 			flags,
  3319| 			clr_instance_get_id (),
  3320| 			NULL,
  3321| 			NULL);
  3322| 		if (!mono_component_profiler_clauses_enabled ()) {
  3323| 			FireEtwExceptionThrownStop (
  3324| 				NULL,
  3325| 				NULL);
  3326| 		}
  3327| 		g_free (exception_message);
  3328| 		g_free (type_name);
  3329| 		mono_error_cleanup (error);
  3330| 	}
  3331| 	return true;
  3332| }
  3333| bool
  3334| ep_rt_mono_write_event_exception_clause (
  3335| 	MonoMethod *method,
  3336| 	uint32_t clause_num,
  3337| 	MonoExceptionEnum clause_type,
  3338| 	MonoObject *obj)
  3339| {
  3340| 	if (!mono_component_profiler_clauses_enabled ())
  3341| 		return true;
  3342| 	if ((clause_type == MONO_EXCEPTION_CLAUSE_FAULT || clause_type == MONO_EXCEPTION_CLAUSE_NONE) && (!EventEnabledExceptionCatchStart() || !EventEnabledExceptionCatchStop()))
  3343| 		return true;
  3344| 	if (clause_type == MONO_EXCEPTION_CLAUSE_FILTER && (!EventEnabledExceptionFilterStart() || !EventEnabledExceptionFilterStop()))
  3345| 		return true;
  3346| 	if (clause_type == MONO_EXCEPTION_CLAUSE_FINALLY && (!EventEnabledExceptionFinallyStart() || !EventEnabledExceptionFinallyStop()))
  3347| 		return true;
  3348| 	uintptr_t ip = 0; //TODO: Have profiler pass along IP of handler block.
  3349| 	uint64_t method_id = (uint64_t)method;
  3350| 	char *method_name = NULL;
  3351| 	method_name = mono_method_get_name_full (method, TRUE, TRUE, MONO_TYPE_NAME_FORMAT_IL);
  3352| 	if ((clause_type == MONO_EXCEPTION_CLAUSE_FAULT || clause_type == MONO_EXCEPTION_CLAUSE_NONE)) {
  3353| 		FireEtwExceptionCatchStart (
  3354| 			(uint64_t)ip,
  3355| 			method_id,
  3356| 			(const ep_char8_t *)method_name,
  3357| 			clr_instance_get_id (),
  3358| 			NULL,
  3359| 			NULL);
  3360| 		FireEtwExceptionCatchStop (
  3361| 			NULL,
  3362| 			NULL);
  3363| 		FireEtwExceptionThrownStop (
  3364| 			NULL,
  3365| 			NULL);
  3366| 	}
  3367| 	if (clause_type == MONO_EXCEPTION_CLAUSE_FILTER) {
  3368| 		FireEtwExceptionFilterStart (
  3369| 			(uint64_t)ip,
  3370| 			method_id,
  3371| 			(const ep_char8_t *)method_name,
  3372| 			clr_instance_get_id (),
  3373| 			NULL,
  3374| 			NULL);
  3375| 		FireEtwExceptionFilterStop (
  3376| 			NULL,
  3377| 			NULL);
  3378| 	}
  3379| 	if (clause_type == MONO_EXCEPTION_CLAUSE_FINALLY) {
  3380| 		FireEtwExceptionFinallyStart (
  3381| 			(uint64_t)ip,
  3382| 			method_id,
  3383| 			(const ep_char8_t *)method_name,
  3384| 			clr_instance_get_id (),
  3385| 			NULL,
  3386| 			NULL);
  3387| 		FireEtwExceptionFinallyStop (
  3388| 			NULL,
  3389| 			NULL);
  3390| 	}
  3391| 	g_free (method_name);
  3392| 	return true;
  3393| }
  3394| bool
  3395| ep_rt_mono_write_event_monitor_contention_start (MonoObject *obj)
  3396| {
  3397| 	if (!EventEnabledContentionStart_V1 ())
  3398| 		return true;
  3399| 	FireEtwContentionStart_V1 (
  3400| 		0 /* ManagedContention */,
  3401| 		clr_instance_get_id (),
  3402| 		NULL,
  3403| 		NULL);
  3404| 	return true;
  3405| }
  3406| bool
  3407| ep_rt_mono_write_event_monitor_contention_stop (MonoObject *obj)
  3408| {
  3409| 	if (!EventEnabledContentionStop ())
  3410| 		return true;
  3411| 	FireEtwContentionStop (
  3412| 		0 /* ManagedContention */,
  3413| 		clr_instance_get_id (),
  3414| 		NULL,
  3415| 		NULL);
  3416| 	return true;
  3417| }
  3418| bool
  3419| ep_rt_mono_write_event_method_jit_memory_allocated_for_code (
  3420| 	const uint8_t *buffer,
  3421| 	uint64_t size,
  3422| 	MonoProfilerCodeBufferType type,
  3423| 	const void *data)
  3424| {
  3425| 	if (!EventEnabledMethodJitMemoryAllocatedForCode ())
  3426| 		return true;
  3427| 	if (type != MONO_PROFILER_CODE_BUFFER_METHOD)
  3428| 		return true;
  3429| 	uint64_t method_id = 0;
  3430| 	uint64_t module_id = 0;
  3431| 	if (data) {
  3432| 		MonoMethod *method;
  3433| 		method = (MonoMethod *)data;
  3434| 		method_id = (uint64_t)method;
  3435| 		if (method->klass)
  3436| 			module_id = (uint64_t)(uint64_t)m_class_get_image (method->klass);
  3437| 	}
  3438| 	FireEtwMethodJitMemoryAllocatedForCode (
  3439| 		method_id,
  3440| 		module_id,
  3441| 		size,
  3442| 		0,
  3443| 		size,
  3444| 		0 /* CORJIT_ALLOCMEM_DEFAULT_CODE_ALIGN */,
  3445| 		clr_instance_get_id (),
  3446| 		NULL,
  3447| 		NULL);
  3448| 	return true;
  3449| }
  3450| bool
  3451| ep_rt_write_event_threadpool_worker_thread_start (
  3452| 	uint32_t active_thread_count,
  3453| 	uint32_t retired_worker_thread_count,
  3454| 	uint16_t clr_instance_id)
  3455| {
  3456| 	return FireEtwThreadPoolWorkerThreadStart (
  3457| 		active_thread_count,
  3458| 		retired_worker_thread_count,
  3459| 		clr_instance_id,
  3460| 		NULL,
  3461| 		NULL) == 0 ? true : false;
  3462| }
  3463| bool
  3464| ep_rt_write_event_threadpool_worker_thread_stop (
  3465| 	uint32_t active_thread_count,
  3466| 	uint32_t retired_worker_thread_count,
  3467| 	uint16_t clr_instance_id)
  3468| {
  3469| 	return FireEtwThreadPoolWorkerThreadStop (
  3470| 		active_thread_count,
  3471| 		retired_worker_thread_count,
  3472| 		clr_instance_id,
  3473| 		NULL,
  3474| 		NULL) == 0 ? true : false;
  3475| }
  3476| bool
  3477| ep_rt_write_event_threadpool_worker_thread_wait (
  3478| 	uint32_t active_thread_count,
  3479| 	uint32_t retired_worker_thread_count,
  3480| 	uint16_t clr_instance_id)
  3481| {
  3482| 	return FireEtwThreadPoolWorkerThreadWait (
  3483| 		active_thread_count,
  3484| 		retired_worker_thread_count,
  3485| 		clr_instance_id,
  3486| 		NULL,
  3487| 		NULL) == 0 ? true : false;
  3488| }
  3489| bool
  3490| ep_rt_write_event_threadpool_min_max_threads (
  3491| 	uint16_t min_worker_threads,
  3492| 	uint16_t max_worker_threads,
  3493| 	uint16_t min_io_completion_threads,
  3494| 	uint16_t max_io_completion_threads,
  3495| 	uint16_t clr_instance_id)
  3496| {
  3497| 	return FireEtwThreadPoolMinMaxThreads (
  3498| 		min_worker_threads,
  3499| 		max_worker_threads,
  3500| 		min_io_completion_threads,
  3501| 		max_io_completion_threads,
  3502| 		clr_instance_id,
  3503| 		NULL,
  3504| 		NULL) == 0 ? true : false;
  3505| }
  3506| bool
  3507| ep_rt_write_event_threadpool_worker_thread_adjustment_sample (
  3508| 	double throughput,
  3509| 	uint16_t clr_instance_id)
  3510| {
  3511| 	return FireEtwThreadPoolWorkerThreadAdjustmentSample (
  3512| 		throughput,
  3513| 		clr_instance_id,
  3514| 		NULL,
  3515| 		NULL) == 0 ? true : false;
  3516| }
  3517| bool
  3518| ep_rt_write_event_threadpool_worker_thread_adjustment_adjustment (
  3519| 	double average_throughput,
  3520| 	uint32_t networker_thread_count,
  3521| 	/*NativeRuntimeEventSource.ThreadAdjustmentReasonMap*/ int32_t reason,
  3522| 	uint16_t clr_instance_id)
  3523| {
  3524| 	return FireEtwThreadPoolWorkerThreadAdjustmentAdjustment (
  3525| 		average_throughput,
  3526| 		networker_thread_count,
  3527| 		reason,
  3528| 		clr_instance_id,
  3529| 		NULL,
  3530| 		NULL) == 0 ? true : false;
  3531| }
  3532| bool
  3533| ep_rt_write_event_threadpool_worker_thread_adjustment_stats (
  3534| 	double duration,
  3535| 	double throughput,
  3536| 	double threadpool_worker_thread_wait,
  3537| 	double throughput_wave,
  3538| 	double throughput_error_estimate,
  3539| 	double average_throughput_error_estimate,
  3540| 	double throughput_ratio,
  3541| 	double confidence,
  3542| 	double new_control_setting,
  3543| 	uint16_t new_thread_wave_magnitude,
  3544| 	uint16_t clr_instance_id)
  3545| {
  3546| 	return FireEtwThreadPoolWorkerThreadAdjustmentStats (
  3547| 		duration,
  3548| 		throughput,
  3549| 		threadpool_worker_thread_wait,
  3550| 		throughput_wave,
  3551| 		throughput_error_estimate,
  3552| 		average_throughput_error_estimate,
  3553| 		throughput_ratio,
  3554| 		confidence,
  3555| 		new_control_setting,
  3556| 		new_thread_wave_magnitude,
  3557| 		clr_instance_id,
  3558| 		NULL,
  3559| 		NULL) == 0 ? true : false;
  3560| }
  3561| bool
  3562| ep_rt_write_event_threadpool_io_enqueue (
  3563| 	intptr_t native_overlapped,
  3564| 	intptr_t overlapped,
  3565| 	bool multi_dequeues,
  3566| 	uint16_t clr_instance_id)
  3567| {
  3568| 	return FireEtwThreadPoolIOEnqueue (
  3569| 		(const void *)native_overlapped,
  3570| 		(const void *)overlapped,
  3571| 		multi_dequeues,
  3572| 		clr_instance_id,
  3573| 		NULL,
  3574| 		NULL) == 0 ? true : false;
  3575| }
  3576| bool
  3577| ep_rt_write_event_threadpool_io_dequeue (
  3578| 	intptr_t native_overlapped,
  3579| 	intptr_t overlapped,
  3580| 	uint16_t clr_instance_id)
  3581| {
  3582| 	return FireEtwThreadPoolIODequeue (
  3583| 		(const void *)native_overlapped,
  3584| 		(const void *)overlapped,
  3585| 		clr_instance_id,
  3586| 		NULL,
  3587| 		NULL) == 0 ? true : false;
  3588| }
  3589| bool
  3590| ep_rt_write_event_threadpool_working_thread_count (
  3591| 	uint16_t count,
  3592| 	uint16_t clr_instance_id)
  3593| {
  3594| 	return FireEtwThreadPoolWorkingThreadCount (
  3595| 		count,
  3596| 		clr_instance_id,
  3597| 		NULL,
  3598| 		NULL) == 0 ? true : false;
  3599| }
  3600| bool
  3601| ep_rt_write_event_threadpool_io_pack (
  3602| 	intptr_t native_overlapped,
  3603| 	intptr_t overlapped,
  3604| 	uint16_t clr_instance_id)
  3605| {
  3606| 	return FireEtwThreadPoolIOPack (
  3607| 		(const void *)native_overlapped,
  3608| 		(const void *)overlapped,
  3609| 		clr_instance_id,
  3610| 		NULL,
  3611| 		NULL) == 0 ? true : false;
  3612| }
  3613| static
  3614| void
  3615| runtime_profiler_jit_begin (
  3616| 	MonoProfiler *prof,
  3617| 	MonoMethod *method)
  3618| {
  3619| 	ep_rt_mono_write_event_jit_start (method);
  3620| }
  3621| static
  3622| void
  3623| runtime_profiler_jit_failed (
  3624| 	MonoProfiler *prof,
  3625| 	MonoMethod *method)
  3626| {
  3627| }
  3628| static
  3629| void
  3630| runtime_profiler_jit_done (
  3631| 	MonoProfiler *prof,
  3632| 	MonoMethod *method,
  3633| 	MonoJitInfo *ji)
  3634| {
  3635| 	ep_rt_mono_write_event_method_load (method, ji);
  3636| 	ep_rt_mono_write_event_method_il_to_native_map (method, ji);
  3637| }
  3638| static
  3639| void
  3640| runtime_profiler_image_loaded (
  3641| 	MonoProfiler *prof,
  3642| 	MonoImage *image)
  3643| {
  3644| 	if (image && image->heap_pdb.size == 0)
  3645| 		ep_rt_mono_write_event_module_load (image);
  3646| }
  3647| static
  3648| void
  3649| runtime_profiler_image_unloaded (
  3650| 	MonoProfiler *prof,
  3651| 	MonoImage *image)
  3652| {
  3653| 	if (image && image->heap_pdb.size == 0)
  3654| 		ep_rt_mono_write_event_module_unload (image);
  3655| }
  3656| static
  3657| void
  3658| runtime_profiler_assembly_loaded (
  3659| 	MonoProfiler *prof,
  3660| 	MonoAssembly *assembly)
  3661| {
  3662| 	ep_rt_mono_write_event_assembly_load (assembly);
  3663| }
  3664| static
  3665| void
  3666| runtime_profiler_assembly_unloaded (
  3667| 	MonoProfiler *prof,
  3668| 	MonoAssembly *assembly)
  3669| {
  3670| 	ep_rt_mono_write_event_assembly_unload (assembly);
  3671| }
  3672| static
  3673| void
  3674| runtime_profiler_thread_started (
  3675| 	MonoProfiler *prof,
  3676| 	uintptr_t tid)
  3677| {
  3678| 	ep_rt_mono_write_event_thread_created (ep_rt_uint64_t_to_thread_id_t (tid));
  3679| }
  3680| static
  3681| void
  3682| runtime_profiler_thread_stopped (
  3683| 	MonoProfiler *prof,
  3684| 	uintptr_t tid)
  3685| {
  3686| 	ep_rt_mono_write_event_thread_terminated (ep_rt_uint64_t_to_thread_id_t (tid));
  3687| }
  3688| static
  3689| void
  3690| runtime_profiler_class_loading (
  3691| 	MonoProfiler *prof,
  3692| 	MonoClass *klass)
  3693| {
  3694| 	bool prevent_profiler_event_recursion = FALSE;
  3695| 	EventPipeThreadData *thread_data = eventpipe_thread_data_get_or_create ();
  3696| 	if (thread_data) {
  3697| 		prevent_profiler_event_recursion = thread_data->prevent_profiler_event_recursion;
  3698| 		thread_data->prevent_profiler_event_recursion = TRUE;
  3699| 	}
  3700| 	ep_rt_mono_write_event_type_load_start (m_class_get_byval_arg (klass));
  3701| 	if (thread_data)
  3702| 		thread_data->prevent_profiler_event_recursion = prevent_profiler_event_recursion;
  3703| }
  3704| static
  3705| void
  3706| runtime_profiler_class_failed (
  3707| 	MonoProfiler *prof,
  3708| 	MonoClass *klass)
  3709| {
  3710| 	ep_rt_mono_write_event_type_load_stop (m_class_get_byval_arg (klass));
  3711| }
  3712| static
  3713| void
  3714| runtime_profiler_class_loaded (
  3715| 	MonoProfiler *prof,
  3716| 	MonoClass *klass)
  3717| {
  3718| 	ep_rt_mono_write_event_type_load_stop (m_class_get_byval_arg (klass));
  3719| }
  3720| static
  3721| void
  3722| runtime_profiler_exception_throw (
  3723| 	MonoProfiler *prof,
  3724| 	MonoObject *exc)
  3725| {
  3726| 	ep_rt_mono_write_event_exception_thrown (exc);
  3727| }
  3728| static
  3729| void
  3730| runtime_profiler_exception_clause (
  3731| 	MonoProfiler *prof,
  3732| 	MonoMethod *method,
  3733| 	uint32_t clause_num,
  3734| 	MonoExceptionEnum clause_type,
  3735| 	MonoObject *exc)
  3736| {
  3737| 	ep_rt_mono_write_event_exception_clause (method, clause_num, clause_type, exc);
  3738| }
  3739| static
  3740| void
  3741| runtime_profiler_monitor_contention (
  3742| 	MonoProfiler *prof,
  3743| 	MonoObject *obj)
  3744| {
  3745| 	ep_rt_mono_write_event_monitor_contention_start (obj);
  3746| }
  3747| static
  3748| void
  3749| runtime_profiler_monitor_acquired (
  3750| 	MonoProfiler *prof,
  3751| 	MonoObject *obj)
  3752| {
  3753| 	ep_rt_mono_write_event_monitor_contention_stop (obj);
  3754| }
  3755| static
  3756| void
  3757| runtime_profiler_monitor_failed (
  3758| 	MonoProfiler *prof,
  3759| 	MonoObject *obj)
  3760| {
  3761| 	ep_rt_mono_write_event_monitor_contention_stop (obj);
  3762| }
  3763| static
  3764| void
  3765| runtime_profiler_jit_code_buffer (
  3766| 	MonoProfiler *prof,
  3767| 	const mono_byte *buffer,
  3768| 	uint64_t size,
  3769| 	MonoProfilerCodeBufferType type,
  3770| 	const void *data)
  3771| {
  3772| 	ep_rt_mono_write_event_method_jit_memory_allocated_for_code ((const uint8_t *)buffer, size, type, data);
  3773| }
  3774| void
  3775| EventPipeEtwCallbackDotNETRuntime (
  3776| 	const uint8_t *source_id,
  3777| 	unsigned long is_enabled,
  3778| 	uint8_t level,
  3779| 	uint64_t match_any_keywords,
  3780| 	uint64_t match_all_keywords,
  3781| 	EventFilterDescriptor *filter_data,
  3782| 	void *callback_data)
  3783| {
  3784| 	ep_rt_config_requires_lock_not_held ();
  3785| 	EP_ASSERT(is_enabled == 0 || is_enabled == 1) ;
  3786| 	EP_ASSERT (_ep_rt_dotnet_runtime_profiler_provider != NULL);
  3787| 	match_any_keywords = (is_enabled == 1) ? match_any_keywords : 0;
  3788| 	EP_LOCK_ENTER (section1)
  3789| 		uint64_t enabled_keywords = MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_EVENTPIPE_Context.EnabledKeywordsBitmask;
  3790| 		if (profiler_callback_is_enabled(match_any_keywords, JIT_KEYWORD)) {
  3791| 			if (!profiler_callback_is_enabled (enabled_keywords, JIT_KEYWORD)) {
  3792| 				mono_profiler_set_jit_begin_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_jit_begin);
  3793| 				mono_profiler_set_jit_failed_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_jit_failed);
  3794| 				mono_profiler_set_jit_done_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_jit_done);
  3795| 			}
  3796| 		} else {
  3797| 			if (profiler_callback_is_enabled (enabled_keywords, JIT_KEYWORD)) {
  3798| 				mono_profiler_set_jit_begin_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
  3799| 				mono_profiler_set_jit_failed_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
  3800| 				mono_profiler_set_jit_done_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
  3801| 			}
  3802| 		}
  3803| 		if (profiler_callback_is_enabled(match_any_keywords, LOADER_KEYWORD)) {
  3804| 			if (!profiler_callback_is_enabled(enabled_keywords, LOADER_KEYWORD)) {
  3805| 				mono_profiler_set_image_loaded_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_image_loaded);
  3806| 				mono_profiler_set_image_unloaded_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_image_unloaded);
  3807| 				mono_profiler_set_assembly_loaded_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_assembly_loaded);
  3808| 				mono_profiler_set_assembly_unloaded_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_assembly_unloaded);
  3809| 			}
  3810| 		} else {
  3811| 			if (profiler_callback_is_enabled (enabled_keywords, LOADER_KEYWORD)) {
  3812| 				mono_profiler_set_image_loaded_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
  3813| 				mono_profiler_set_image_unloaded_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
  3814| 				mono_profiler_set_assembly_loaded_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
  3815| 				mono_profiler_set_assembly_unloaded_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
  3816| 			}
  3817| 		}
  3818| 		if (profiler_callback_is_enabled(match_any_keywords, APP_DOMAIN_RESOURCE_MANAGEMENT_KEYWORD) || profiler_callback_is_enabled(match_any_keywords, THREADING_KEYWORD)) {
  3819| 			if (!(profiler_callback_is_enabled(enabled_keywords, APP_DOMAIN_RESOURCE_MANAGEMENT_KEYWORD) && profiler_callback_is_enabled(enabled_keywords, THREADING_KEYWORD))) {
  3820| 				mono_profiler_set_thread_started_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_thread_started);
  3821| 				mono_profiler_set_thread_stopped_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_thread_stopped);
  3822| 			}
  3823| 		} else {
  3824| 			if (profiler_callback_is_enabled (enabled_keywords, APP_DOMAIN_RESOURCE_MANAGEMENT_KEYWORD) || profiler_callback_is_enabled (enabled_keywords, THREADING_KEYWORD)) {
  3825| 				mono_profiler_set_thread_started_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
  3826| 				mono_profiler_set_thread_stopped_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
  3827| 			}
  3828| 		}
  3829| 		if (profiler_callback_is_enabled(match_any_keywords, TYPE_DIAGNOSTIC_KEYWORD)) {
  3830| 			if (!profiler_callback_is_enabled(enabled_keywords, TYPE_DIAGNOSTIC_KEYWORD)) {
  3831| 				mono_profiler_set_class_loading_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_class_loading);
  3832| 				mono_profiler_set_class_failed_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_class_failed);
  3833| 				mono_profiler_set_class_loaded_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_class_loaded);
  3834| 			}
  3835| 		} else {
  3836| 			if (profiler_callback_is_enabled (enabled_keywords, TYPE_DIAGNOSTIC_KEYWORD)) {
  3837| 				mono_profiler_set_class_loading_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
  3838| 				mono_profiler_set_class_failed_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
  3839| 				mono_profiler_set_class_loaded_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
  3840| 			}
  3841| 		}
  3842| 		if (profiler_callback_is_enabled(match_any_keywords, EXCEPTION_KEYWORD)) {
  3843| 			if (!profiler_callback_is_enabled(enabled_keywords, EXCEPTION_KEYWORD)) {
  3844| 				mono_profiler_set_exception_throw_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_exception_throw);
  3845| 				mono_profiler_set_exception_clause_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_exception_clause);
  3846| 			}
  3847| 		} else {
  3848| 			if (profiler_callback_is_enabled (enabled_keywords, EXCEPTION_KEYWORD)) {
  3849| 				mono_profiler_set_exception_throw_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
  3850| 				mono_profiler_set_exception_clause_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
  3851| 			}
  3852| 		}
  3853| 		if (profiler_callback_is_enabled(match_any_keywords, CONTENTION_KEYWORD)) {
  3854| 			if (!profiler_callback_is_enabled(enabled_keywords, CONTENTION_KEYWORD)) {
  3855| 				mono_profiler_set_monitor_contention_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_monitor_contention);
  3856| 				mono_profiler_set_monitor_acquired_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_monitor_acquired);
  3857| 				mono_profiler_set_monitor_failed_callback (_ep_rt_dotnet_runtime_profiler_provider, runtime_profiler_monitor_failed);
  3858| 			}
  3859| 		} else {
  3860| 			if (profiler_callback_is_enabled (enabled_keywords, CONTENTION_KEYWORD)) {
  3861| 				mono_profiler_set_monitor_contention_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
  3862| 				mono_profiler_set_monitor_acquired_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
  3863| 				mono_profiler_set_monitor_failed_callback (_ep_rt_dotnet_runtime_profiler_provider, NULL);
  3864| 			}
  3865| 		}
  3866| 		MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_EVENTPIPE_Context.Level = level;
  3867| 		MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_EVENTPIPE_Context.EnabledKeywordsBitmask = match_any_keywords;
  3868| 		MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_EVENTPIPE_Context.IsEnabled = (is_enabled == 1 ? true : false);
  3869| 	EP_LOCK_EXIT (section1)
  3870| ep_on_exit:
  3871| 	ep_rt_config_requires_lock_not_held ();
  3872| 	return;
  3873| ep_on_error:
  3874| 	ep_exit_error_handler ();
  3875| }
  3876| void
  3877| EventPipeEtwCallbackDotNETRuntimeRundown (
  3878| 	const uint8_t *source_id,
  3879| 	unsigned long is_enabled,
  3880| 	uint8_t level,
  3881| 	uint64_t match_any_keywords,
  3882| 	uint64_t match_all_keywords,
  3883| 	EventFilterDescriptor *filter_data,
  3884| 	void *callback_data)
  3885| {
  3886| 	MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_EVENTPIPE_Context.Level = level;
  3887| 	MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_EVENTPIPE_Context.EnabledKeywordsBitmask = match_any_keywords;
  3888| 	MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_EVENTPIPE_Context.IsEnabled = (is_enabled == 1 ? true : false);
  3889| }
  3890| void
  3891| EventPipeEtwCallbackDotNETRuntimePrivate (
  3892| 	const uint8_t *source_id,
  3893| 	unsigned long is_enabled,
  3894| 	uint8_t level,
  3895| 	uint64_t match_any_keywords,
  3896| 	uint64_t match_all_keywords,
  3897| 	EventFilterDescriptor *filter_data,
  3898| 	void *callback_data)
  3899| {
  3900| 	MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_EVENTPIPE_Context.Level = level;
  3901| 	MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_EVENTPIPE_Context.EnabledKeywordsBitmask = match_any_keywords;
  3902| 	MICROSOFT_WINDOWS_DOTNETRUNTIME_PRIVATE_PROVIDER_EVENTPIPE_Context.IsEnabled = (is_enabled == 1 ? true : false);
  3903| }
  3904| void
  3905| EventPipeEtwCallbackDotNETRuntimeStress (
  3906| 	const uint8_t *source_id,
  3907| 	unsigned long is_enabled,
  3908| 	uint8_t level,
  3909| 	uint64_t match_any_keywords,
  3910| 	uint64_t match_all_keywords,
  3911| 	EventFilterDescriptor *filter_data,
  3912| 	void *callback_data)
  3913| {
  3914| 	MICROSOFT_WINDOWS_DOTNETRUNTIME_STRESS_PROVIDER_EVENTPIPE_Context.Level = level;
  3915| 	MICROSOFT_WINDOWS_DOTNETRUNTIME_STRESS_PROVIDER_EVENTPIPE_Context.EnabledKeywordsBitmask = match_any_keywords;
  3916| 	MICROSOFT_WINDOWS_DOTNETRUNTIME_STRESS_PROVIDER_EVENTPIPE_Context.IsEnabled = (is_enabled == 1 ? true : false);
  3917| }
  3918| static
  3919| inline
  3920| mono_profiler_gc_state_t
  3921| mono_profiler_volatile_load_gc_state_t (const volatile mono_profiler_gc_state_t *ptr)
  3922| {
  3923| 	return ep_rt_volatile_load_uint32_t ((const volatile uint32_t *)ptr);
  3924| }
  3925| static
  3926| inline
  3927| mono_profiler_gc_state_t
  3928| mono_profiler_atomic_cas_gc_state_t (volatile mono_profiler_gc_state_t *target, mono_profiler_gc_state_t expected, mono_profiler_gc_state_t value)
  3929| {
  3930| 	return (mono_profiler_gc_state_t)(mono_atomic_cas_i32 ((volatile gint32 *)(target), (gint32)(value), (gint32)(expected)));
  3931| }
  3932| static
  3933| void
  3934| mono_profiler_fire_event_enter (void)
  3935| {
  3936| 	mono_profiler_gc_state_t old_state = 0;
  3937| 	mono_profiler_gc_state_t new_state = 0;
  3938| 	do {
  3939| 		old_state = mono_profiler_volatile_load_gc_state_t (&_ep_rt_mono_profiler_gc_state);
  3940| 		if (MONO_PROFILER_GC_STATE_IS_GC_IN_PROGRESS (old_state)) {
  3941| 			ep_rt_spin_lock_acquire (&_ep_rt_mono_profiler_gc_state_lock);
  3942| 			ep_rt_spin_lock_release (&_ep_rt_mono_profiler_gc_state_lock);
  3943| 			old_state = mono_profiler_volatile_load_gc_state_t (&_ep_rt_mono_profiler_gc_state);
  3944| 		}
  3945| 		new_state = MONO_PROFILER_GC_STATE_INC_FIRE_EVENT_COUNT (old_state);
  3946| 	} while (mono_profiler_atomic_cas_gc_state_t (&_ep_rt_mono_profiler_gc_state, old_state, new_state) != old_state);
  3947| }
  3948| static
  3949| void
  3950| mono_profiler_fire_event_exit (void)
  3951| {
  3952| 	mono_profiler_gc_state_t old_state = 0;
  3953| 	mono_profiler_gc_state_t new_state = 0;
  3954| 	do {
  3955| 		old_state = mono_profiler_volatile_load_gc_state_t (&_ep_rt_mono_profiler_gc_state);
  3956| 		new_state = MONO_PROFILER_GC_STATE_DEC_FIRE_EVENT_COUNT (old_state);
  3957| 	} while (mono_profiler_atomic_cas_gc_state_t (&_ep_rt_mono_profiler_gc_state, old_state, new_state) != old_state);
  3958| }
  3959| static
  3960| void
  3961| mono_profiler_gc_in_progress_start (void)
  3962| {
  3963| 	mono_profiler_gc_state_t old_state = 0;
  3964| 	mono_profiler_gc_state_t new_state = 0;
  3965| 	ep_rt_spin_lock_acquire (&_ep_rt_mono_profiler_gc_state_lock);
  3966| 	do {
  3967| 		old_state = mono_profiler_volatile_load_gc_state_t (&_ep_rt_mono_profiler_gc_state);
  3968| 		EP_ASSERT (!MONO_PROFILER_GC_STATE_IS_GC_IN_PROGRESS (old_state));
  3969| 		new_state = MONO_PROFILER_GC_STATE_GC_IN_PROGRESS_START (old_state);
  3970| 	} while (mono_profiler_atomic_cas_gc_state_t (&_ep_rt_mono_profiler_gc_state, old_state, new_state) != old_state);
  3971| 	mono_profiler_gc_state_count_t count = MONO_PROFILER_GC_STATE_GET_FIRE_EVENT_COUNT (new_state);
  3972| 	int yield_count = 40;
  3973| 	while (count) {
  3974| 		if (yield_count > 0) {
  3975| 			ep_rt_mono_thread_yield ();
  3976| 			yield_count--;
  3977| 		} else {
  3978| 			ep_rt_thread_sleep (200);
  3979| 		}
  3980| 		count = MONO_PROFILER_GC_STATE_GET_FIRE_EVENT_COUNT (mono_profiler_volatile_load_gc_state_t (&_ep_rt_mono_profiler_gc_state));
  3981| 	}
  3982| }
  3983| static
  3984| void
  3985| mono_profiler_gc_in_progress_stop (void)
  3986| {
  3987| 	mono_profiler_gc_state_t old_state = 0;
  3988| 	mono_profiler_gc_state_t new_state = 0;
  3989| 	do {
  3990| 		old_state = mono_profiler_volatile_load_gc_state_t (&_ep_rt_mono_profiler_gc_state);
  3991| 		EP_ASSERT (MONO_PROFILER_GC_STATE_IS_GC_IN_PROGRESS (old_state));
  3992| 		new_state = MONO_PROFILER_GC_STATE_GC_IN_PROGRESS_STOP (old_state);
  3993| 		EP_ASSERT (!MONO_PROFILER_GC_STATE_IS_GC_IN_PROGRESS (new_state));
  3994| 	} while (mono_profiler_atomic_cas_gc_state_t (&_ep_rt_mono_profiler_gc_state, old_state, new_state) != old_state);
  3995| 	ep_rt_spin_lock_release (&_ep_rt_mono_profiler_gc_state_lock);
  3996| }
  3997| static
  3998| inline
  3999| bool
  4000| mono_profiler_gc_in_progress (void)
  4001| {
  4002| 	return MONO_PROFILER_GC_STATE_IS_GC_IN_PROGRESS (mono_profiler_volatile_load_gc_state_t (&_ep_rt_mono_profiler_gc_state));
  4003| }
  4004| static
  4005| inline
  4006| bool
  4007| mono_profiler_gc_can_collect_heap (void)
  4008| {
  4009| 	return _ep_rt_mono_profiler_gc_can_collect_heap;
  4010| }
  4011| static
  4012| inline
  4013| void
  4014| mono_profiler_gc_heap_collect_requests_inc (void)
  4015| {
  4016| 	EP_ASSERT (mono_profiler_gc_can_collect_heap ());
  4017| 	ep_rt_atomic_inc_uint32_t (&_ep_rt_mono_profiler_gc_heap_collect_requests);
  4018| }
  4019| static
  4020| inline
  4021| void
  4022| mono_profiler_gc_heap_collect_requests_dec (void)
  4023| {
  4024| 	EP_ASSERT (mono_profiler_gc_can_collect_heap ());
  4025| 	ep_rt_atomic_dec_uint32_t (&_ep_rt_mono_profiler_gc_heap_collect_requests);
  4026| }
  4027| static
  4028| inline
  4029| bool
  4030| mono_profiler_gc_heap_collect_requested (void)
  4031| {
  4032| 	if (!mono_profiler_gc_can_collect_heap ())
  4033| 		return false;
  4034| 	return ep_rt_volatile_load_uint32_t(&_ep_rt_mono_profiler_gc_heap_collect_requests) != 0 ? true : false;
  4035| }
  4036| static
  4037| inline
  4038| bool
  4039| mono_profiler_gc_heap_collect_in_progress (void)
  4040| {
  4041| 	ep_rt_spin_lock_requires_lock_held (&_ep_rt_mono_profiler_gc_state_lock);
  4042| 	return ep_rt_volatile_load_uint32_t_without_barrier (&_ep_rt_mono_profiler_gc_heap_collect_in_progress) != 0 ? true : false;
  4043| }
  4044| static
  4045| inline
  4046| void
  4047| mono_profiler_gc_heap_collect_in_progress_start (void)
  4048| {
  4049| 	EP_ASSERT (mono_profiler_gc_can_collect_heap ());
  4050| 	ep_rt_spin_lock_requires_lock_held (&_ep_rt_mono_profiler_gc_state_lock);
  4051| 	ep_rt_volatile_store_uint32_t_without_barrier (&_ep_rt_mono_profiler_gc_heap_collect_in_progress, 1);
  4052| }
  4053| static
  4054| inline
  4055| void
  4056| mono_profiler_gc_heap_collect_in_progress_stop (void)
  4057| {
  4058| 	EP_ASSERT (mono_profiler_gc_can_collect_heap ());
  4059| 	ep_rt_spin_lock_requires_lock_held (&_ep_rt_mono_profiler_gc_state_lock);
  4060| 	ep_rt_volatile_store_uint32_t_without_barrier (&_ep_rt_mono_profiler_gc_heap_collect_in_progress, 0);
  4061| }
  4062| static
  4063| MonoProfilerMemBlock *
  4064| mono_profiler_mem_block_alloc (uint32_t req_size)
  4065| {
  4066| 	EP_ASSERT (mono_profiler_gc_in_progress ());
  4067| 	MonoProfilerMemBlock *prev = NULL;
  4068| 	uint32_t size = MONO_PROFILER_MEM_DEFAULT_BLOCK_SIZE;
  4069| 	while (size - sizeof(MonoProfilerMemBlock) < req_size)
  4070| 		size += MONO_PROFILER_MEM_BLOCK_SIZE_INC;
  4071| 	MonoProfilerMemBlock *block = mono_valloc (NULL, size, MONO_MMAP_READ | MONO_MMAP_WRITE | MONO_MMAP_ANON | MONO_MMAP_PRIVATE, MONO_MEM_ACCOUNT_PROFILER);
  4072| 	if (block) {
  4073| 		block->alloc_size = size;
  4074| 		block->start = (uint8_t *)ALIGN_PTR_TO ((uint8_t *)block + sizeof (MonoProfilerMemBlock), 16);
  4075| 		block->size = (uint32_t)(((uint8_t*)block + size) - (uint8_t*)block->start);
  4076| 		block->offset = 0;
  4077| 		block->last_used_offset = 0;
  4078| 		while (true) {
  4079| 			prev = (MonoProfilerMemBlock *)ep_rt_volatile_load_ptr_without_barrier ((volatile void **)&_ep_rt_mono_profiler_mem_blocks);
  4080| 			if (mono_atomic_cas_ptr ((volatile gpointer*)&_ep_rt_mono_profiler_mem_blocks, block, prev) == prev)
  4081| 				break;
  4082| 		}
  4083| 		if (prev)
  4084| 			prev->next = block;
  4085| 		block->prev = prev;
  4086| 	}
  4087| 	return block;
  4088| }
  4089| static
  4090| uint8_t *
  4091| mono_profiler_mem_alloc (uint32_t req_size)
  4092| {
  4093| 	EP_ASSERT (mono_profiler_gc_in_progress ());
  4094| 	MonoProfilerMemBlock *current_block = (MonoProfilerMemBlock *)ep_rt_volatile_load_ptr_without_barrier ((volatile void **)&_ep_rt_mono_profiler_current_mem_block);
  4095| 	uint8_t *buffer = NULL;
  4096| 	if (!current_block) {
  4097| 		current_block = mono_profiler_mem_block_alloc (req_size);
  4098| 		if (current_block) {
  4099| 			mono_memory_barrier ();
  4100| 			ep_rt_volatile_store_ptr_without_barrier ((volatile void **)&_ep_rt_mono_profiler_current_mem_block, current_block);
  4101| 		}
  4102| 	}
  4103| 	if (current_block) {
  4104| 		uint32_t prev_offset = (uint32_t)mono_atomic_fetch_add_i32 ((volatile int32_t *)&current_block->offset, (int32_t)req_size);
  4105| 		if (prev_offset + req_size > current_block->size) {
  4106| 			if (prev_offset <= current_block->size)
  4107| 				current_block->last_used_offset = prev_offset;
  4108| 			current_block = mono_profiler_mem_block_alloc (req_size);
  4109| 			if (current_block) {
  4110| 				buffer = current_block->start;
  4111| 				current_block->offset += req_size;
  4112| 				mono_memory_barrier ();
  4113| 				ep_rt_volatile_store_ptr_without_barrier ((volatile void **)&_ep_rt_mono_profiler_current_mem_block, current_block);
  4114| 			}
  4115| 		} else {
  4116| 			buffer = (uint8_t*)current_block->start + prev_offset;
  4117| 		}
  4118| 	}
  4119| 	return buffer;
  4120| }
  4121| static
  4122| void
  4123| mono_profiler_mem_block_free_all (void)
  4124| {
  4125| 	EP_ASSERT (mono_profiler_gc_in_progress ());
  4126| 	MonoProfilerMemBlock *current_block = (MonoProfilerMemBlock *)ep_rt_volatile_load_ptr ((volatile void **)&_ep_rt_mono_profiler_current_mem_block);
  4127| 	ep_rt_volatile_store_ptr_without_barrier ((volatile void **)&_ep_rt_mono_profiler_current_mem_block, NULL);
  4128| 	ep_rt_volatile_store_ptr_without_barrier ((volatile void **)&_ep_rt_mono_profiler_mem_blocks, NULL);
  4129| 	mono_memory_barrier ();
  4130| 	while (current_block) {
  4131| 		MonoProfilerMemBlock *prev_block = current_block->prev;
  4132| 		mono_vfree ((uint8_t *)current_block, current_block->alloc_size, MONO_MEM_ACCOUNT_MEM_MANAGER);
  4133| 		current_block = prev_block;
  4134| 	}
  4135| }
  4136| static
  4137| void
  4138| mono_profiler_mem_block_free_all_but_current (void)
  4139| {
  4140| 	EP_ASSERT (mono_profiler_gc_in_progress ());
  4141| 	MonoProfilerMemBlock *block_to_keep = (MonoProfilerMemBlock *)ep_rt_volatile_load_ptr ((volatile void **)&_ep_rt_mono_profiler_current_mem_block);
  4142| 	MonoProfilerMemBlock *current_block = block_to_keep;
  4143| 	ep_rt_volatile_store_ptr_without_barrier ((volatile void **)&_ep_rt_mono_profiler_current_mem_block, NULL);
  4144| 	ep_rt_volatile_store_ptr_without_barrier ((volatile void **)&_ep_rt_mono_profiler_mem_blocks, NULL);
  4145| 	mono_memory_barrier ();
  4146| 	if (current_block) {
  4147| 		if (current_block->prev) {
  4148| 			current_block = current_block->prev;
  4149| 			while (current_block) {
  4150| 				MonoProfilerMemBlock *prev_block = current_block->prev;
  4151| 				mono_vfree ((uint8_t *)current_block, current_block->alloc_size, MONO_MEM_ACCOUNT_MEM_MANAGER);
  4152| 				current_block = prev_block;
  4153| 			}
  4154| 		}
  4155| 	}
  4156| 	if (block_to_keep) {
  4157| 		block_to_keep->prev = NULL;
  4158| 		block_to_keep->next = NULL;
  4159| 		block_to_keep->offset = 0;
  4160| 		block_to_keep->last_used_offset = 0;
  4161| 	}
  4162| 	mono_memory_barrier ();
  4163| 	ep_rt_volatile_store_ptr_without_barrier ((volatile void **)&_ep_rt_mono_profiler_current_mem_block, block_to_keep);
  4164| 	ep_rt_volatile_store_ptr_without_barrier ((volatile void **)&_ep_rt_mono_profiler_mem_blocks, block_to_keep);
  4165| }
  4166| static
  4167| inline
  4168| uint8_t *
  4169| mono_profiler_buffered_gc_event_alloc (uint32_t req_size)
  4170| {
  4171| 	EP_ASSERT (mono_profiler_gc_in_progress ());
  4172| 	return mono_profiler_mem_alloc (req_size + sizeof (MonoProfilerBufferedGCEvent));
  4173| }
  4174| static
  4175| void
  4176| mono_profiler_trigger_heap_collect (MonoProfiler *prof)
  4177| {
  4178| 	if (mono_profiler_gc_heap_collect_requested ()) {
  4179| 		ep_rt_spin_lock_acquire (&_ep_rt_mono_profiler_gc_state_lock);
  4180| 			mono_profiler_gc_heap_collect_requests_dec ();
  4181| 			mono_profiler_gc_heap_collect_in_progress_start ();
  4182| 		ep_rt_spin_lock_release (&_ep_rt_mono_profiler_gc_state_lock);
  4183| 		mono_gc_collect (mono_gc_max_generation ());
  4184| 		ep_rt_spin_lock_acquire (&_ep_rt_mono_profiler_gc_state_lock);
  4185| 			mono_profiler_pop_gc_heap_collect_param_request_value ();
  4186| 			mono_profiler_gc_heap_collect_in_progress_stop ();
  4187| 		ep_rt_spin_lock_release (&_ep_rt_mono_profiler_gc_state_lock);
  4188| 	}
  4189| }
  4190| static
  4191| void
  4192| mono_profiler_fire_gc_event_root_register (
  4193| 	uint8_t *data,
  4194| 	uint32_t payload_size)
  4195| {
  4196| 	EP_ASSERT (mono_profiler_gc_in_progress ());
  4197| 	uintptr_t root_id;
  4198| 	uintptr_t root_size;
  4199| 	uint8_t root_source;
  4200| 	uintptr_t root_key;
  4201| 	memcpy (&root_id, data, sizeof (root_id));
  4202| 	data += sizeof (root_id);
  4203| 	memcpy (&root_size, data, sizeof (root_size));
  4204| 	data += sizeof (root_size);
  4205| 	memcpy (&root_source, data, sizeof (root_source));
  4206| 	data += sizeof (root_source);
  4207| 	memcpy (&root_key, data, sizeof (root_key));
  4208| 	data += sizeof (root_key);
  4209| 	FireEtwMonoProfilerGCRootRegister (
  4210| 		(const void *)root_id,
  4211| 		(uint64_t)root_size,
  4212| 		root_source,
  4213| 		(uint64_t)root_key,
  4214| 		(const ep_char8_t *)data,
  4215| 		NULL,
  4216| 		NULL);
  4217| }
  4218| static
  4219| void
  4220| mono_profiler_fire_buffered_gc_event_root_register (
  4221| 	MonoProfiler *prof,
  4222| 	const mono_byte *start,
  4223| 	uintptr_t size,
  4224| 	MonoGCRootSource source,
  4225| 	const void * key,
  4226| 	const char * name)
  4227| {
  4228| 	EP_ASSERT (mono_profiler_gc_in_progress ());
  4229| 	uintptr_t root_id = (uintptr_t)start;
  4230| 	uintptr_t root_size = size;
  4231| 	uint8_t root_source = (uint8_t)source;
  4232| 	uintptr_t root_key = (uintptr_t)key;
  4233| 	const char *root_name = (name ? name : "");
  4234| 	size_t root_name_len = strlen (root_name) + 1;
  4235| 	MonoProfilerBufferedGCEvent gc_event_data;
  4236| 	gc_event_data.type = MONO_PROFILER_BUFFERED_GC_EVENT_ROOT_REGISTER;
  4237| 	gc_event_data.payload_size = (uint32_t)
  4238| 		(sizeof (root_id) +
  4239| 		sizeof (root_size) +
  4240| 		sizeof (root_source) +
  4241| 		sizeof (root_key) +
  4242| 		root_name_len);
  4243| 	uint8_t * buffer = mono_profiler_buffered_gc_event_alloc (gc_event_data.payload_size);
  4244| 	if (buffer) {
  4245| 		memcpy (buffer, &gc_event_data, sizeof (gc_event_data));
  4246| 		buffer += sizeof (gc_event_data);
  4247| 		memcpy(buffer, &root_id, sizeof (root_id));
  4248| 		buffer += sizeof (root_id);
  4249| 		memcpy(buffer, &root_size, sizeof (root_size));
  4250| 		buffer += sizeof (root_size);
  4251| 		memcpy(buffer, &root_source, sizeof (root_source));
  4252| 		buffer += sizeof (root_source);
  4253| 		memcpy(buffer, &root_key, sizeof (root_key));
  4254| 		buffer += sizeof (root_key);
  4255| 		memcpy(buffer, root_name, root_name_len);
  4256| 	}
  4257| }
  4258| static
  4259| void
  4260| mono_profiler_fire_gc_event_root_unregister (
  4261| 	uint8_t *data,
  4262| 	uint32_t payload_size)
  4263| {
  4264| 	EP_ASSERT (mono_profiler_gc_in_progress ());
  4265| 	uintptr_t root_id;
  4266| 	memcpy (&root_id, data, sizeof (root_id));
  4267| 	FireEtwMonoProfilerGCRootUnregister (
  4268| 		(const void *)root_id,
  4269| 		NULL,
  4270| 		NULL);
  4271| }
  4272| static
  4273| void
  4274| mono_profiler_fire_buffered_gc_event_root_unregister (
  4275| 	MonoProfiler *prof,
  4276| 	const mono_byte *start)
  4277| {
  4278| 	EP_ASSERT (mono_profiler_gc_in_progress ());
  4279| 	uintptr_t root_id = (uintptr_t)start;
  4280| 	MonoProfilerBufferedGCEvent gc_event_data;
  4281| 	gc_event_data.type = MONO_PROFILER_BUFFERED_GC_EVENT_ROOT_UNREGISTER;
  4282| 	gc_event_data.payload_size = sizeof (root_id);
  4283| 	uint8_t * buffer = mono_profiler_buffered_gc_event_alloc (gc_event_data.payload_size);
  4284| 	if (buffer) {
  4285| 		memcpy (buffer, &gc_event_data, sizeof (gc_event_data));
  4286| 		buffer += sizeof (gc_event_data);
  4287| 		memcpy(buffer, &root_id, sizeof (root_id));
  4288| 	}
  4289| }
  4290| static
  4291| void
  4292| mono_profiler_fire_gc_event (
  4293| 	uint8_t *data,
  4294| 	uint32_t payload_size)
  4295| {
  4296| 	EP_ASSERT (mono_profiler_gc_in_progress ());
  4297| 	uint8_t gc_event_type;
  4298| 	uint32_t generation;
  4299| 	memcpy (&gc_event_type, data, sizeof (gc_event_type));
  4300| 	data += sizeof (gc_event_type);
  4301| 	memcpy (&generation, data, sizeof (generation));
  4302| 	FireEtwMonoProfilerGCEvent (
  4303| 		gc_event_type,
  4304| 		generation,
  4305| 		NULL,
  4306| 		NULL);
  4307| }
  4308| static
  4309| void
  4310| mono_profiler_fire_buffered_gc_event (
  4311| 	uint8_t gc_event_type,
  4312| 	uint32_t generation)
  4313| {
  4314| 	EP_ASSERT (mono_profiler_gc_in_progress ());
  4315| 	MonoProfilerBufferedGCEvent gc_event_data;
  4316| 	gc_event_data.type = MONO_PROFILER_BUFFERED_GC_EVENT;
  4317| 	gc_event_data.payload_size =
  4318| 		sizeof (gc_event_type) +
  4319| 		sizeof (generation);
  4320| 	uint8_t * buffer = mono_profiler_buffered_gc_event_alloc (gc_event_data.payload_size);
  4321| 	if (buffer) {
  4322| 		memcpy (buffer, &gc_event_data, sizeof (gc_event_data));
  4323| 		buffer += sizeof (gc_event_data);
  4324| 		memcpy(buffer, &gc_event_type, sizeof (gc_event_type));
  4325| 		buffer += sizeof (gc_event_type);
  4326| 		memcpy(buffer, &generation, sizeof (generation));
  4327| 	}
  4328| }
  4329| static
  4330| void
  4331| mono_profiler_fire_gc_event_resize (
  4332| 	uint8_t *data,
  4333| 	uint32_t payload_size)
  4334| {
  4335| 	EP_ASSERT (mono_profiler_gc_in_progress ());
  4336| 	uintptr_t size;
  4337| 	memcpy (&size, data, sizeof (size));
  4338| 	FireEtwMonoProfilerGCResize (
  4339| 		(uint64_t)size,
  4340| 		NULL,
  4341| 		NULL);
  4342| }
  4343| static
  4344| void
  4345| mono_profiler_fire_buffered_gc_event_resize (
  4346| 	MonoProfiler *prof,
  4347| 	uintptr_t size)
  4348| {
  4349| 	EP_ASSERT (mono_profiler_gc_in_progress ());
  4350| 	MonoProfilerBufferedGCEvent gc_event_data;
  4351| 	gc_event_data.type = MONO_PROFILER_BUFFERED_GC_EVENT_RESIZE;
  4352| 	gc_event_data.payload_size = sizeof (size);
  4353| 	uint8_t * buffer = mono_profiler_buffered_gc_event_alloc (gc_event_data.payload_size);
  4354| 	if (buffer) {
  4355| 		memcpy (buffer, &gc_event_data, sizeof (gc_event_data));
  4356| 		buffer += sizeof (gc_event_data);
  4357| 		memcpy(buffer, &size, sizeof (size));
  4358| 	}
  4359| }
  4360| static
  4361| void
  4362| mono_profiler_fire_gc_event_moves (
  4363| 	uint8_t *data,
  4364| 	uint32_t payload_size)
  4365| {
  4366| 	EP_ASSERT (mono_profiler_gc_in_progress ());
  4367| 	uint64_t count;
  4368| 	memcpy (&count, data, sizeof (count));
  4369| 	data += sizeof (count);
  4370| 	FireEtwMonoProfilerGCMoves (
  4371| 		(uint32_t)count,
  4372| 		sizeof (uintptr_t) + sizeof (uintptr_t),
  4373| 		data,
  4374| 		NULL,
  4375| 		NULL);
  4376| }
  4377| static
  4378| void
  4379| mono_profiler_fire_buffered_gc_event_moves (
  4380| 	MonoProfiler *prof,
  4381| 	MonoObject *const* objects,
  4382| 	uint64_t count)
  4383| {
  4384| 	EP_ASSERT (mono_profiler_gc_in_progress ());
  4385| 	uintptr_t object_id;
  4386| 	uintptr_t address_id;
  4387| 	count = count / 2;
  4388| 	MonoProfilerBufferedGCEvent gc_event_data;
  4389| 	gc_event_data.type = MONO_PROFILER_BUFFERED_GC_EVENT_MOVES;
  4390| 	gc_event_data.payload_size =
  4391| 		(uint32_t)(sizeof (count) +
  4392| 		(count * (sizeof (uintptr_t) + sizeof (uintptr_t))));
  4393| 	uint8_t * buffer = mono_profiler_buffered_gc_event_alloc (gc_event_data.payload_size);
  4394| 	if (buffer) {
  4395| 		memcpy (buffer, &gc_event_data, sizeof (gc_event_data));
  4396| 		buffer += sizeof (gc_event_data);
  4397| 		memcpy (buffer, &count, sizeof (count));
  4398| 		buffer += sizeof (count);
  4399| 		for (uint64_t i = 0; i < count; i++) {
  4400| 			object_id = (uintptr_t)SGEN_POINTER_UNTAG_ALL (*objects);
  4401| 			memcpy (buffer, &object_id, sizeof (object_id));
  4402| 			buffer += sizeof (object_id);
  4403| 			objects++;
  4404| 			address_id = (uintptr_t)*objects;
  4405| 			memcpy (buffer, &address_id, sizeof (address_id));
  4406| 			buffer += sizeof (address_id);
  4407| 			objects++;
  4408| 		}
  4409| 	}
  4410| }
  4411| static
  4412| void
  4413| mono_profiler_fire_gc_event_roots (
  4414| 	uint8_t *data,
  4415| 	uint32_t payload_size)
  4416| {
  4417| 	EP_ASSERT (mono_profiler_gc_in_progress ());
  4418| 	uint64_t count;
  4419| 	memcpy (&count, data, sizeof (count));
  4420| 	data += sizeof (count);
  4421| 	FireEtwMonoProfilerGCRoots (
  4422| 		(uint32_t)count,
  4423| 		sizeof (uintptr_t) + sizeof (uintptr_t),
  4424| 		data,
  4425| 		NULL,
  4426| 		NULL);
  4427| }
  4428| static
  4429| void
  4430| mono_profiler_fire_buffered_gc_event_roots (
  4431| 	MonoProfiler *prof,
  4432| 	uint64_t count,
  4433| 	const mono_byte *const * addresses,
  4434| 	MonoObject *const * objects)
  4435| {
  4436| 	EP_ASSERT (mono_profiler_gc_in_progress ());
  4437| 	uintptr_t object_id;
  4438| 	uintptr_t address_id;
  4439| 	MonoProfilerBufferedGCEvent gc_event_data;
  4440| 	gc_event_data.type = MONO_PROFILER_BUFFERED_GC_EVENT_ROOTS;
  4441| 	gc_event_data.payload_size =
  4442| 		(uint32_t)(sizeof (count) +
  4443| 		(count * (sizeof (uintptr_t) + sizeof (uintptr_t))));
  4444| 	uint8_t * buffer = mono_profiler_buffered_gc_event_alloc (gc_event_data.payload_size);
  4445| 	if (buffer) {
  4446| 		memcpy (buffer, &gc_event_data, sizeof (gc_event_data));
  4447| 		buffer += sizeof (gc_event_data);
  4448| 		memcpy (buffer, &count, sizeof (count));
  4449| 		buffer += sizeof (count);
  4450| 		for (uint64_t i = 0; i < count; i++) {
  4451| 			object_id = (uintptr_t)SGEN_POINTER_UNTAG_ALL (*objects);
  4452| 			memcpy (buffer, &object_id, sizeof (object_id));
  4453| 			buffer += sizeof (object_id);
  4454| 			objects++;
  4455| 			address_id = (uintptr_t)*addresses;
  4456| 			memcpy (buffer, &address_id, sizeof (address_id));
  4457| 			buffer += sizeof (address_id);
  4458| 			addresses++;
  4459| 		}
  4460| 	}
  4461| }
  4462| static
  4463| void
  4464| mono_profiler_fire_gc_event_heap_dump_object_reference (
  4465| 	uint8_t *data,
  4466| 	uint32_t payload_size,
  4467| 	GHashTable *cache)
  4468| {
  4469| 	EP_ASSERT (mono_profiler_gc_in_progress ());
  4470| 	uintptr_t object_id;
  4471| 	uintptr_t vtable_id;
  4472| 	uintptr_t object_size;
  4473| 	uint8_t object_gen;
  4474| 	uintptr_t object_ref_count;
  4475| 	memcpy (&object_id, data, sizeof (object_id));
  4476| 	data += sizeof (object_id);
  4477| 	memcpy (&vtable_id, data, sizeof (vtable_id));
  4478| 	data += sizeof (vtable_id);
  4479| 	memcpy (&object_size, data, sizeof (object_size));
  4480| 	data += sizeof (object_size);
  4481| 	memcpy (&object_gen, data, sizeof (object_gen));
  4482| 	data += sizeof (object_gen);
  4483| 	memcpy (&object_ref_count, data, sizeof (object_ref_count));
  4484| 	data += sizeof (object_ref_count);
  4485| 	FireEtwMonoProfilerGCHeapDumpObjectReference (
  4486| 		(const void *)object_id,
  4487| 		(uint64_t)vtable_id,
  4488| 		(uint64_t)object_size,
  4489| 		object_gen,
  4490| 		(uint32_t)object_ref_count,
  4491| 		sizeof (uint32_t) + sizeof (uintptr_t),
  4492| 		data,
  4493| 		NULL,
  4494| 		NULL);
  4495| 	if (cache)
  4496| 		g_hash_table_insert (cache, (MonoVTable *)SGEN_POINTER_UNTAG_ALL (vtable_id), NULL);
  4497| }
  4498| static
  4499| int
  4500| mono_profiler_fire_buffered_gc_event_heap_dump_object_reference (
  4501| 	MonoObject *obj,
  4502| 	MonoClass *klass,
  4503| 	uintptr_t size,
  4504| 	uintptr_t num,
  4505| 	MonoObject **refs,
  4506| 	uintptr_t *offsets,
  4507| 	void *data)
  4508| {
  4509| 	EP_ASSERT (mono_profiler_gc_in_progress ());
  4510| 	uintptr_t object_id;
  4511| 	uintptr_t vtable_id;
  4512| 	uint8_t object_gen;
  4513| 	uintptr_t object_size = size;
  4514| 	uintptr_t object_ref_count = num;
  4515| 	uint32_t object_ref_offset;
  4516| 	/* account for object alignment */
  4517| 	object_size += 7;
  4518| 	object_size &= ~7;
  4519| 	size_t payload_size =
  4520| 		sizeof (object_id) +
  4521| 		sizeof (vtable_id) +
  4522| 		sizeof (object_size) +
  4523| 		sizeof (object_gen) +
  4524| 		sizeof (object_ref_count) +
  4525| 		(object_ref_count * (sizeof (uint32_t) + sizeof (uintptr_t)));
  4526| 	MonoProfilerBufferedGCEvent gc_event_data;
  4527| 	gc_event_data.type = MONO_PROFILER_BUFFERED_GC_EVENT_OBJECT_REF;
  4528| 	gc_event_data.payload_size = GSIZE_TO_UINT32 (payload_size);
  4529| 	uint8_t *buffer = mono_profiler_buffered_gc_event_alloc (gc_event_data.payload_size);
  4530| 	if (buffer) {
  4531| 		memcpy (buffer, &gc_event_data, sizeof (gc_event_data));
  4532| 		buffer += sizeof (gc_event_data);
  4533| 		object_id = (uintptr_t)SGEN_POINTER_UNTAG_ALL (obj);
  4534| 		memcpy (buffer, &object_id, sizeof (object_id));
  4535| 		buffer += sizeof (object_id);
  4536| 		vtable_id = (uintptr_t)SGEN_POINTER_UNTAG_ALL (mono_object_get_vtable_internal (obj));
  4537| 		memcpy (buffer, &vtable_id, sizeof (vtable_id));
  4538| 		buffer += sizeof (vtable_id);
  4539| 		memcpy (buffer, &object_size, sizeof (object_size));
  4540| 		buffer += sizeof (object_size);
  4541| 		object_gen = (uint8_t)mono_gc_get_generation (obj);
  4542| 		memcpy (buffer, &object_gen, sizeof (object_gen));
  4543| 		buffer += sizeof (object_gen);
  4544| 		memcpy (buffer, &object_ref_count, sizeof (object_ref_count));
  4545| 		buffer += sizeof (object_ref_count);
  4546| 		uintptr_t last_offset = 0;
  4547| 		for (uintptr_t i = 0; i < object_ref_count; i++) {
  4548| 			object_ref_offset = GUINTPTR_TO_UINT32 (offsets [i] - last_offset);
  4549| 			memcpy (buffer, &object_ref_offset, sizeof (object_ref_offset));
  4550| 			buffer += sizeof (object_ref_offset);
  4551| 			object_id = (uintptr_t)SGEN_POINTER_UNTAG_ALL (refs[i]);
  4552| 			memcpy (buffer, &object_id, sizeof (object_id));
  4553| 			buffer += sizeof (object_id);
  4554| 			last_offset = offsets [i];
  4555| 		}
  4556| 	}
  4557| 	return 0;
  4558| }
  4559| static
  4560| void
  4561| mono_profiler_fire_buffered_gc_events (
  4562| 	MonoProfilerMemBlock *block,
  4563| 	GHashTable *cache)
  4564| {
  4565| 	EP_ASSERT (mono_profiler_gc_in_progress ());
  4566| 	if (block) {
  4567| 		uint32_t current_offset = 0;
  4568| 		uint32_t used_size = (block->offset < block->size) ? block->offset : block->last_used_offset;
  4569| 		MonoProfilerBufferedGCEvent gc_event;
  4570| 		while ((current_offset + sizeof (gc_event)) <= used_size) {
  4571| 			uint8_t *data = block->start + current_offset;
  4572| 			memcpy (&gc_event, data, sizeof (gc_event));
  4573| 			data += sizeof (gc_event);
  4574| 			if ((current_offset + sizeof (gc_event) + gc_event.payload_size) <= used_size) {
  4575| 				switch (gc_event.type) {
  4576| 				case MONO_PROFILER_BUFFERED_GC_EVENT:
  4577| 					mono_profiler_fire_gc_event (data, gc_event.payload_size);
  4578| 					break;
  4579| 				case MONO_PROFILER_BUFFERED_GC_EVENT_RESIZE:
  4580| 					mono_profiler_fire_gc_event_resize (data, gc_event.payload_size);
  4581| 					break;
  4582| 				case MONO_PROFILER_BUFFERED_GC_EVENT_ROOTS:
  4583| 					mono_profiler_fire_gc_event_roots (data, gc_event.payload_size);
  4584| 					break;
  4585| 				case MONO_PROFILER_BUFFERED_GC_EVENT_MOVES:
  4586| 					mono_profiler_fire_gc_event_moves (data, gc_event.payload_size);
  4587| 					break;
  4588| 				case MONO_PROFILER_BUFFERED_GC_EVENT_OBJECT_REF:
  4589| 					mono_profiler_fire_gc_event_heap_dump_object_reference (data, gc_event.payload_size, cache);
  4590| 					break;
  4591| 				case MONO_PROFILER_BUFFERED_GC_EVENT_ROOT_REGISTER:
  4592| 					mono_profiler_fire_gc_event_root_register (data, gc_event.payload_size);
  4593| 					break;
  4594| 				case MONO_PROFILER_BUFFERED_GC_EVENT_ROOT_UNREGISTER:
  4595| 					mono_profiler_fire_gc_event_root_unregister (data, gc_event.payload_size);
  4596| 					break;
  4597| 				default:
  4598| 					EP_ASSERT (!"Unknown buffered GC event type.");
  4599| 				}
  4600| 				current_offset += sizeof (gc_event) + gc_event.payload_size;
  4601| 			} else {
  4602| 				break;
  4603| 			}
  4604| 		}
  4605| 	}
  4606| }
  4607| static
  4608| void
  4609| mono_profiler_fire_buffered_gc_events_in_alloc_order (GHashTable *cache)
  4610| {
  4611| 	EP_ASSERT (mono_profiler_gc_in_progress ());
  4612| 	MonoProfilerMemBlock *first_block = (MonoProfilerMemBlock *)ep_rt_volatile_load_ptr ((volatile void **)&_ep_rt_mono_profiler_current_mem_block);
  4613| 	while (first_block && first_block->prev)
  4614| 		first_block = first_block->prev;
  4615| 	MonoProfilerMemBlock *current_block = first_block;
  4616| 	while (current_block) {
  4617| 		MonoProfilerMemBlock *next_block = current_block->next;
  4618| 		mono_profiler_fire_buffered_gc_events (current_block, cache);
  4619| 		current_block = next_block;
  4620| 	}
  4621| 	mono_profiler_mem_block_free_all_but_current ();
  4622| }
  4623| static
  4624| void
  4625| mono_profiler_fire_cached_gc_events (GHashTable *cache)
  4626| {
  4627| 	if (cache) {
  4628| 		GHashTableIter iter;
  4629| 		MonoVTable *object_vtable;
  4630| 		g_hash_table_iter_init (&iter, cache);
  4631| 		while (g_hash_table_iter_next (&iter, (void**)&object_vtable, NULL)) {
  4632| 			if (object_vtable) {
  4633| 				uint64_t vtable_id = (uint64_t)object_vtable;
  4634| 				uint64_t class_id;
  4635| 				uint64_t module_id;
  4636| 				ep_char8_t *class_name;
  4637| 				mono_profiler_get_class_data (object_vtable->klass, &class_id, &module_id, &class_name, NULL, NULL);
  4638| 				FireEtwMonoProfilerGCHeapDumpVTableClassReference (
  4639| 					vtable_id,
  4640| 					class_id,
  4641| 					module_id,
  4642| 					class_name,
  4643| 					NULL,
  4644| 					NULL);
  4645| 				g_free (class_name);
  4646| 			}
  4647| 		}
  4648| 	}
  4649| }
  4650| static
  4651| void
  4652| mono_profiler_app_domain_loading (
  4653| 	MonoProfiler *prof,
  4654| 	MonoDomain *domain)
  4655| {
  4656| 	if (!EventEnabledMonoProfilerAppDomainLoading ())
  4657| 		return;
  4658| 	uint64_t domain_id = (uint64_t)domain;
  4659| 	mono_profiler_fire_event_enter ();
  4660| 	FireEtwMonoProfilerAppDomainLoading (
  4661| 		domain_id,
  4662| 		NULL,
  4663| 		NULL);
  4664| 	mono_profiler_fire_event_exit ();
  4665| }
  4666| static
  4667| void
  4668| mono_profiler_app_domain_loaded (
  4669| 	MonoProfiler *prof,
  4670| 	MonoDomain *domain)
  4671| {
  4672| 	if (!EventEnabledMonoProfilerAppDomainLoaded ())
  4673| 		return;
  4674| 	uint64_t domain_id = (uint64_t)domain;
  4675| 	mono_profiler_fire_event_enter ();
  4676| 	FireEtwMonoProfilerAppDomainLoaded (
  4677| 		domain_id,
  4678| 		NULL,
  4679| 		NULL);
  4680| 	mono_profiler_fire_event_exit ();
  4681| }
  4682| static
  4683| void
  4684| mono_profiler_app_domain_unloading (
  4685| 	MonoProfiler *prof,
  4686| 	MonoDomain *domain)
  4687| {
  4688| 	if (!EventEnabledMonoProfilerAppDomainUnloading ())
  4689| 		return;
  4690| 	uint64_t domain_id = (uint64_t)domain;
  4691| 	mono_profiler_fire_event_enter ();
  4692| 	FireEtwMonoProfilerAppDomainUnloading (
  4693| 		domain_id,
  4694| 		NULL,
  4695| 		NULL);
  4696| 	mono_profiler_fire_event_exit ();
  4697| }
  4698| static
  4699| void
  4700| mono_profiler_app_domain_unloaded (
  4701| 	MonoProfiler *prof,
  4702| 	MonoDomain *domain)
  4703| {
  4704| 	if (!EventEnabledMonoProfilerAppDomainUnloaded ())
  4705| 		return;
  4706| 	uint64_t domain_id = (uint64_t)domain;
  4707| 	mono_profiler_fire_event_enter ();
  4708| 	FireEtwMonoProfilerAppDomainUnloaded (
  4709| 		domain_id,
  4710| 		NULL,
  4711| 		NULL);
  4712| 	mono_profiler_fire_event_exit ();
  4713| }
  4714| static
  4715| void
  4716| mono_profiler_app_domain_name (
  4717| 	MonoProfiler *prof,
  4718| 	MonoDomain *domain,
  4719| 	const char *name)
  4720| {
  4721| 	if (!EventEnabledMonoProfilerAppDomainName ())
  4722| 		return;
  4723| 	uint64_t domain_id = (uint64_t)domain;
  4724| 	mono_profiler_fire_event_enter ();
  4725| 	FireEtwMonoProfilerAppDomainName (
  4726| 		domain_id,
  4727| 		(const ep_char8_t *)(name ? name : ""),
  4728| 		NULL,
  4729| 		NULL);
  4730| 	mono_profiler_fire_event_exit ();
  4731| }
  4732| static
  4733| void
  4734| mono_profiler_get_generic_types (
  4735| 	MonoGenericInst *generic_instance,
  4736| 	uint32_t *generic_type_count,
  4737| 	uint8_t **generic_types)
  4738| {
  4739| 	if (generic_instance) {
  4740| 		uint8_t *buffer = g_malloc (generic_instance->type_argc * (sizeof (uint8_t) + sizeof (uint64_t)));
  4741| 		if (buffer) {
  4742| 			*generic_types = buffer;
  4743| 			*generic_type_count = generic_instance->type_argc;
  4744| 			for (uint32_t i = 0; i < generic_instance->type_argc; ++i) {
  4745| 				uint8_t type = generic_instance->type_argv [i]->type;
  4746| 				ep_write_buffer_uint8_t (&buffer, type);
  4747| 				uint64_t class_id = (uint64_t)mono_class_from_mono_type_internal (generic_instance->type_argv [i]);
  4748| 				ep_write_buffer_uint64_t (&buffer, class_id);
  4749| 			}
  4750| 		}
  4751| 	}
  4752| }
  4753| static
  4754| void
  4755| mono_profiler_get_jit_data (
  4756| 	MonoMethod *method,
  4757| 	uint64_t *method_id,
  4758| 	uint64_t *module_id,
  4759| 	uint32_t *method_token,
  4760| 	uint32_t *method_generic_type_count,
  4761| 	uint8_t **method_generic_types)
  4762| {
  4763| 	*method_id = (uint64_t)method;
  4764| 	*module_id = 0;
  4765| 	*method_token = 0;
  4766| 	if (method) {
  4767| 		*method_token = method->token;
  4768| 		if (method->klass)
  4769| 			*module_id = (uint64_t)m_class_get_image (method->klass);
  4770| 		if (method_generic_type_count && method_generic_types) {
  4771| 			if (method->is_inflated) {
  4772| 				MonoGenericContext *context = mono_method_get_context (method);
  4773| 				MonoGenericInst *method_instance = (context && context->method_inst) ? context->method_inst : NULL;
  4774| 				mono_profiler_get_generic_types (method_instance, method_generic_type_count, method_generic_types);
  4775| 			}
  4776| 		}
  4777| 	}
  4778| }
  4779| static
  4780| void
  4781| mono_profiler_jit_begin (
  4782| 	MonoProfiler *prof,
  4783| 	MonoMethod *method)
  4784| {
  4785| 	if (!EventEnabledMonoProfilerJitBegin ())
  4786| 		return;
  4787| 	uint64_t method_id;
  4788| 	uint64_t module_id;
  4789| 	uint32_t method_token;
  4790| 	mono_profiler_get_jit_data (method, &method_id, &module_id, &method_token, NULL, NULL);
  4791| 	mono_profiler_fire_event_enter ();
  4792| 	FireEtwMonoProfilerJitBegin (
  4793| 		method_id,
  4794| 		module_id,
  4795| 		method_token,
  4796| 		NULL,
  4797| 		NULL);
  4798| 	mono_profiler_fire_event_exit ();
  4799| }
  4800| static
  4801| void
  4802| mono_profiler_jit_failed (
  4803| 	MonoProfiler *prof,
  4804| 	MonoMethod *method)
  4805| {
  4806| 	if (!EventEnabledMonoProfilerJitFailed ())
  4807| 		return;
  4808| 	uint64_t method_id;
  4809| 	uint64_t module_id;
  4810| 	uint32_t method_token;
  4811| 	mono_profiler_get_jit_data (method, &method_id, &module_id, &method_token, NULL, NULL);
  4812| 	mono_profiler_fire_event_enter ();
  4813| 	FireEtwMonoProfilerJitFailed (
  4814| 		method_id,
  4815| 		module_id,
  4816| 		method_token,
  4817| 		NULL,
  4818| 		NULL);
  4819| 	mono_profiler_fire_event_exit ();
  4820| }
  4821| static
  4822| void
  4823| mono_profiler_jit_done (
  4824| 	MonoProfiler *prof,
  4825| 	MonoMethod *method,
  4826| 	MonoJitInfo *ji)
  4827| {
  4828| 	if (!EventEnabledMonoProfilerJitDone () && !EventEnabledMonoProfilerJitDone_V1 () && !EventEnabledMonoProfilerJitDoneVerbose ())
  4829| 		return;
  4830| 	bool verbose = (MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_EVENTPIPE_Context.Level >= (uint8_t)EP_EVENT_LEVEL_VERBOSE);
  4831| 	uint64_t method_id;
  4832| 	uint64_t module_id;
  4833| 	uint32_t method_token;
  4834| 	uint32_t method_generic_type_count = 0;
  4835| 	uint8_t *method_generic_types = NULL;
  4836| 	char *method_namespace = NULL;
  4837| 	const char *method_name = NULL;
  4838| 	char *method_signature = NULL;
  4839| 	mono_profiler_get_jit_data (method, &method_id, &module_id, &method_token, &method_generic_type_count, &method_generic_types);
  4840| 	if (verbose) {
  4841| 		method_name = method->name;
  4842| 		method_signature = mono_signature_full_name (mono_method_signature_internal (method));
  4843| 		if (method->klass)
  4844| 			method_namespace = mono_type_get_name_full (m_class_get_byval_arg (method->klass), MONO_TYPE_NAME_FORMAT_IL);
  4845| 	}
  4846| 	mono_profiler_fire_event_enter ();
  4847| 	FireEtwMonoProfilerJitDone_V1 (
  4848| 		method_id,
  4849| 		module_id,
  4850| 		method_token,
  4851| 		method_generic_type_count,
  4852| 		sizeof (uint8_t) + sizeof (uint64_t),
  4853| 		method_generic_types,
  4854| 		NULL,
  4855| 		NULL);
  4856| 	if (verbose) {
  4857| 		FireEtwMonoProfilerJitDoneVerbose (
  4858| 			method_id,
  4859| 			(const ep_char8_t *)method_namespace,
  4860| 			(const ep_char8_t *)method_name,
  4861| 			(const ep_char8_t *)method_signature,
  4862| 			NULL,
  4863| 			NULL);
  4864| 	}
  4865| 	mono_profiler_fire_event_exit ();
  4866| 	g_free (method_namespace);
  4867| 	g_free (method_signature);
  4868| 	g_free (method_generic_types);
  4869| }
  4870| static
  4871| void
  4872| mono_profiler_jit_chunk_created (
  4873| 	MonoProfiler *prof,
  4874| 	const mono_byte *chunk,
  4875| 	uintptr_t size)
  4876| {
  4877| 	if (!EventEnabledMonoProfilerJitChunkCreated ())
  4878| 		return;
  4879| 	mono_profiler_fire_event_enter ();
  4880| 	FireEtwMonoProfilerJitChunkCreated (
  4881| 		chunk,
  4882| 		(uint64_t)size,
  4883| 		NULL,
  4884| 		NULL);
  4885| 	mono_profiler_fire_event_exit ();
  4886| }
  4887| static
  4888| void
  4889| mono_profiler_jit_chunk_destroyed (
  4890| 	MonoProfiler *prof,
  4891| 	const mono_byte *chunk)
  4892| {
  4893| 	if (!EventEnabledMonoProfilerJitChunkDestroyed ())
  4894| 		return;
  4895| 	mono_profiler_fire_event_enter ();
  4896| 	FireEtwMonoProfilerJitChunkDestroyed (
  4897| 		chunk,
  4898| 		NULL,
  4899| 		NULL);
  4900| 	mono_profiler_fire_event_exit ();
  4901| }
  4902| static
  4903| void
  4904| mono_profiler_jit_code_buffer (
  4905| 	MonoProfiler *prof,
  4906| 	const mono_byte *buffer,
  4907| 	uint64_t size,
  4908| 	MonoProfilerCodeBufferType type,
  4909| 	const void *data)
  4910| {
  4911| 	if (!EventEnabledMonoProfilerJitCodeBuffer ())
  4912| 		return;
  4913| 	mono_profiler_fire_event_enter ();
  4914| 	FireEtwMonoProfilerJitCodeBuffer (
  4915| 		buffer,
  4916| 		size,
  4917| 		(uint8_t)type,
  4918| 		NULL,
  4919| 		NULL);
  4920| 	mono_profiler_fire_event_exit ();
  4921| }
  4922| static
  4923| void
  4924| mono_profiler_get_class_data (
  4925| 	MonoClass *klass,
  4926| 	uint64_t *class_id,
  4927| 	uint64_t *module_id,
  4928| 	ep_char8_t **class_name,
  4929| 	uint32_t *class_generic_type_count,
  4930| 	uint8_t **class_generic_types)
  4931| {
  4932| 	*class_id = (uint64_t)klass;
  4933| 	*module_id = 0;
  4934| 	if (klass)
  4935| 		*module_id = (uint64_t)m_class_get_image (klass);
  4936| 	if (klass && class_name)
  4937| 		*class_name = (ep_char8_t *)mono_type_get_name_full (m_class_get_byval_arg (klass), MONO_TYPE_NAME_FORMAT_IL);
  4938| 	else if (class_name)
  4939| 		*class_name = NULL;
  4940| 	if (class_generic_type_count && class_generic_types) {
  4941| 		if (mono_class_is_ginst (klass)) {
  4942| 			MonoGenericContext *context = mono_class_get_context (klass);
  4943| 			MonoGenericInst *class_instance = (context && context->class_inst) ? context->class_inst : NULL;
  4944| 			mono_profiler_get_generic_types (class_instance, class_generic_type_count, class_generic_types);
  4945| 		}
  4946| 	}
  4947| }
  4948| static
  4949| void
  4950| mono_profiler_class_loading (
  4951| 	MonoProfiler *prof,
  4952| 	MonoClass *klass)
  4953| {
  4954| 	if (!EventEnabledMonoProfilerClassLoading ())
  4955| 		return;
  4956| 	uint64_t class_id;
  4957| 	uint64_t module_id;
  4958| 	mono_profiler_get_class_data (klass, &class_id, &module_id, NULL, NULL, NULL);
  4959| 	mono_profiler_fire_event_enter ();
  4960| 	FireEtwMonoProfilerClassLoading (
  4961| 		class_id,
  4962| 		module_id,
  4963| 		NULL,
  4964| 		NULL);
  4965| 	mono_profiler_fire_event_exit ();
  4966| }
  4967| static
  4968| void
  4969| mono_profiler_class_failed (
  4970| 	MonoProfiler *prof,
  4971| 	MonoClass *klass)
  4972| {
  4973| 	if (!EventEnabledMonoProfilerClassFailed ())
  4974| 		return;
  4975| 	uint64_t class_id;
  4976| 	uint64_t module_id;
  4977| 	mono_profiler_get_class_data (klass, &class_id, &module_id, NULL, NULL, NULL);
  4978| 	mono_profiler_fire_event_enter ();
  4979| 	FireEtwMonoProfilerClassFailed (
  4980| 		class_id,
  4981| 		module_id,
  4982| 		NULL,
  4983| 		NULL);
  4984| 	mono_profiler_fire_event_exit ();
  4985| }
  4986| static
  4987| void
  4988| mono_profiler_class_loaded (
  4989| 	MonoProfiler *prof,
  4990| 	MonoClass *klass)
  4991| {
  4992| 	if (!EventEnabledMonoProfilerClassLoaded () && !EventEnabledMonoProfilerClassLoaded_V1 ())
  4993| 		return;
  4994| 	uint64_t class_id;
  4995| 	uint64_t module_id;
  4996| 	ep_char8_t *class_name;
  4997| 	uint32_t class_generic_type_count = 0;
  4998| 	uint8_t *class_generic_types = NULL;
  4999| 	mono_profiler_get_class_data (klass, &class_id, &module_id, &class_name, &class_generic_type_count, &class_generic_types);
  5000| 	mono_profiler_fire_event_enter ();
  5001| 	FireEtwMonoProfilerClassLoaded_V1 (
  5002| 		class_id,
  5003| 		module_id,
  5004| 		class_name ? class_name : "",
  5005| 		class_generic_type_count,
  5006| 		sizeof (uint8_t) + sizeof (uint64_t),
  5007| 		class_generic_types,
  5008| 		NULL,
  5009| 		NULL);
  5010| 	mono_profiler_fire_event_exit ();
  5011| 	g_free (class_name);
  5012| 	g_free (class_generic_types);
  5013| }
  5014| static
  5015| inline
  5016| void
  5017| get_vtable_data (
  5018| 	MonoVTable *vtable,
  5019| 	uint64_t *vtable_id,
  5020| 	uint64_t *class_id,
  5021| 	uint64_t *domain_id)
  5022| {
  5023| 	*vtable_id = (uint64_t)vtable;
  5024| 	*class_id = 0;
  5025| 	*domain_id = 0;
  5026| 	if (vtable) {
  5027| 		*class_id = (uint64_t)mono_vtable_class_internal (vtable);
  5028| 		*domain_id = (uint64_t)mono_vtable_domain_internal (vtable);
  5029| 	}
  5030| }
  5031| static
  5032| void
  5033| mono_profiler_vtable_loading (
  5034| 	MonoProfiler *prof,
  5035| 	MonoVTable *vtable)
  5036| {
  5037| 	if (!EventEnabledMonoProfilerVTableLoading ())
  5038| 		return;
  5039| 	uint64_t vtable_id;
  5040| 	uint64_t class_id;
  5041| 	uint64_t domain_id;
  5042| 	get_vtable_data (vtable, &vtable_id, &class_id, &domain_id);
  5043| 	mono_profiler_fire_event_enter ();
  5044| 	FireEtwMonoProfilerVTableLoading (
  5045| 		vtable_id,
  5046| 		class_id,
  5047| 		domain_id,
  5048| 		NULL,
  5049| 		NULL);
  5050| 	mono_profiler_fire_event_exit ();
  5051| }
  5052| static
  5053| void
  5054| mono_profiler_vtable_failed (
  5055| 	MonoProfiler *prof,
  5056| 	MonoVTable *vtable)
  5057| {
  5058| 	if (!EventEnabledMonoProfilerVTableFailed ())
  5059| 		return;
  5060| 	uint64_t vtable_id;
  5061| 	uint64_t class_id;
  5062| 	uint64_t domain_id;
  5063| 	get_vtable_data (vtable, &vtable_id, &class_id, &domain_id);
  5064| 	mono_profiler_fire_event_enter ();
  5065| 	FireEtwMonoProfilerVTableFailed (
  5066| 		vtable_id,
  5067| 		class_id,
  5068| 		domain_id,
  5069| 		NULL,
  5070| 		NULL);
  5071| 	mono_profiler_fire_event_exit ();
  5072| }
  5073| static
  5074| void
  5075| mono_profiler_vtable_loaded (
  5076| 	MonoProfiler *prof,
  5077| 	MonoVTable *vtable)
  5078| {
  5079| 	if (!EventEnabledMonoProfilerVTableLoaded ())
  5080| 		return;
  5081| 	uint64_t vtable_id;
  5082| 	uint64_t class_id;
  5083| 	uint64_t domain_id;
  5084| 	get_vtable_data (vtable, &vtable_id, &class_id, &domain_id);
  5085| 	mono_profiler_fire_event_enter ();
  5086| 	FireEtwMonoProfilerVTableLoaded (
  5087| 		vtable_id,
  5088| 		class_id,
  5089| 		domain_id,
  5090| 		NULL,
  5091| 		NULL);
  5092| 	mono_profiler_fire_event_exit ();
  5093| }
  5094| static
  5095| void
  5096| mono_profiler_module_loading (
  5097| 	MonoProfiler *prof,
  5098| 	MonoImage *image)
  5099| {
  5100| 	if (!EventEnabledMonoProfilerModuleLoading ())
  5101| 		return;
  5102| 	mono_profiler_fire_event_enter ();
  5103| 	FireEtwMonoProfilerModuleLoading (
  5104| 		(uint64_t)image,
  5105| 		NULL,
  5106| 		NULL);
  5107| 	mono_profiler_fire_event_exit ();
  5108| }
  5109| static
  5110| void
  5111| mono_profiler_module_failed (
  5112| 	MonoProfiler *prof,
  5113| 	MonoImage *image)
  5114| {
  5115| 	if (!EventEnabledMonoProfilerModuleFailed ())
  5116| 		return;
  5117| 	mono_profiler_fire_event_enter ();
  5118| 	FireEtwMonoProfilerModuleFailed (
  5119| 		(uint64_t)image,
  5120| 		NULL,
  5121| 		NULL);
  5122| 	mono_profiler_fire_event_exit ();
  5123| }
  5124| static
  5125| void
  5126| mono_profiler_module_loaded (
  5127| 	MonoProfiler *prof,
  5128| 	MonoImage *image)
  5129| {
  5130| 	if (!EventEnabledMonoProfilerModuleLoaded ())
  5131| 		return;
  5132| 	uint64_t module_id = (uint64_t)image;
  5133| 	const ep_char8_t *module_path = NULL;
  5134| 	const ep_char8_t *module_guid = NULL;
  5135| 	if (image) {
  5136| 		ModuleEventData module_data;
  5137| 		memset (&module_data, 0, sizeof (module_data));
  5138| 		if (get_module_event_data (image, &module_data))
  5139| 			module_path = (const ep_char8_t *)module_data.module_il_path;
  5140| 		module_guid = (const ep_char8_t *)mono_image_get_guid (image);
  5141| 	}
  5142| 	mono_profiler_fire_event_enter ();
  5143| 	FireEtwMonoProfilerModuleLoaded (
  5144| 		module_id,
  5145| 		module_path ? module_path : "",
  5146| 		module_guid ? module_guid : "",
  5147| 		NULL,
  5148| 		NULL);
  5149| 	mono_profiler_fire_event_exit ();
  5150| }
  5151| static
  5152| void
  5153| mono_profiler_module_unloading (
  5154| 	MonoProfiler *prof,
  5155| 	MonoImage *image)
  5156| {
  5157| 	if (!EventEnabledMonoProfilerModuleUnloading ())
  5158| 		return;
  5159| 	mono_profiler_fire_event_enter ();
  5160| 	FireEtwMonoProfilerModuleUnloading (
  5161| 		(uint64_t)image,
  5162| 		NULL,
  5163| 		NULL);
  5164| 	mono_profiler_fire_event_exit ();
  5165| }
  5166| static
  5167| void
  5168| mono_profiler_module_unloaded (
  5169| 	MonoProfiler *prof,
  5170| 	MonoImage *image)
  5171| {
  5172| 	if (!EventEnabledMonoProfilerModuleUnloaded ())
  5173| 		return;
  5174| 	uint64_t module_id = (uint64_t)image;
  5175| 	const ep_char8_t *module_path = NULL;
  5176| 	const ep_char8_t *module_guid = NULL;
  5177| 	if (image) {
  5178| 		ModuleEventData module_data;
  5179| 		memset (&module_data, 0, sizeof (module_data));
  5180| 		if (get_module_event_data (image, &module_data))
  5181| 			module_path = (const ep_char8_t *)module_data.module_il_path;
  5182| 		module_guid = (const ep_char8_t *)mono_image_get_guid (image);
  5183| 	}
  5184| 	mono_profiler_fire_event_enter ();
  5185| 	FireEtwMonoProfilerModuleUnloaded (
  5186| 		module_id,
  5187| 		module_path ? module_path : "",
  5188| 		module_guid ? module_guid : "",
  5189| 		NULL,
  5190| 		NULL);
  5191| 	mono_profiler_fire_event_exit ();
  5192| }
  5193| static
  5194| inline
  5195| void
  5196| get_assembly_data (
  5197| 	MonoAssembly *assembly,
  5198| 	uint64_t *assembly_id,
  5199| 	uint64_t *module_id,
  5200| 	ep_char8_t **assembly_name)
  5201| {
  5202| 	*assembly_id = (uint64_t)assembly;
  5203| 	*module_id = 0;
  5204| 	if (assembly)
  5205| 		*module_id = (uint64_t)mono_assembly_get_image_internal (assembly);
  5206| 	if (assembly && assembly_name)
  5207| 		*assembly_name = (ep_char8_t *)mono_stringify_assembly_name (&assembly->aname);
  5208| 	else if (assembly_name)
  5209| 		*assembly_name = NULL;
  5210| }
  5211| static
  5212| void
  5213| mono_profiler_assembly_loading (
  5214| 	MonoProfiler *prof,
  5215| 	MonoAssembly *assembly)
  5216| {
  5217| 	if (!EventEnabledMonoProfilerAssemblyLoading ())
  5218| 		return;
  5219| 	uint64_t assembly_id;
  5220| 	uint64_t module_id;
  5221| 	get_assembly_data (assembly, &assembly_id, &module_id, NULL);
  5222| 	mono_profiler_fire_event_enter ();
  5223| 	FireEtwMonoProfilerAssemblyLoading (
  5224| 		assembly_id,
  5225| 		module_id,
  5226| 		NULL,
  5227| 		NULL);
  5228| 	mono_profiler_fire_event_exit ();
  5229| }
  5230| static
  5231| void
  5232| mono_profiler_assembly_loaded (
  5233| 	MonoProfiler *prof,
  5234| 	MonoAssembly *assembly)
  5235| {
  5236| 	if (!EventEnabledMonoProfilerAssemblyLoaded ())
  5237| 		return;
  5238| 	uint64_t assembly_id;
  5239| 	uint64_t module_id;
  5240| 	ep_char8_t *assembly_name;
  5241| 	get_assembly_data (assembly, &assembly_id, &module_id, &assembly_name);
  5242| 	mono_profiler_fire_event_enter ();
  5243| 	FireEtwMonoProfilerAssemblyLoaded (
  5244| 		assembly_id,
  5245| 		module_id,
  5246| 		assembly_name ? assembly_name : "",
  5247| 		NULL,
  5248| 		NULL);
  5249| 	mono_profiler_fire_event_exit ();
  5250| 	g_free (assembly_name);
  5251| }
  5252| static
  5253| void
  5254| mono_profiler_assembly_unloading (
  5255| 	MonoProfiler *prof,
  5256| 	MonoAssembly *assembly)
  5257| {
  5258| 	if (!EventEnabledMonoProfilerAssemblyUnloading ())
  5259| 		return;
  5260| 	uint64_t assembly_id;
  5261| 	uint64_t module_id;
  5262| 	get_assembly_data (assembly, &assembly_id, &module_id, NULL);
  5263| 	mono_profiler_fire_event_enter ();
  5264| 	FireEtwMonoProfilerAssemblyUnloading (
  5265| 		assembly_id,
  5266| 		module_id,
  5267| 		NULL,
  5268| 		NULL);
  5269| 	mono_profiler_fire_event_exit ();
  5270| }
  5271| static
  5272| void
  5273| mono_profiler_assembly_unloaded (
  5274| 	MonoProfiler *prof,
  5275| 	MonoAssembly *assembly)
  5276| {
  5277| 	if (!EventEnabledMonoProfilerAssemblyUnloaded ())
  5278| 		return;
  5279| 	uint64_t assembly_id;
  5280| 	uint64_t module_id;
  5281| 	ep_char8_t *assembly_name;
  5282| 	get_assembly_data (assembly, &assembly_id, &module_id, &assembly_name);
  5283| 	mono_profiler_fire_event_enter ();
  5284| 	FireEtwMonoProfilerAssemblyUnloaded (
  5285| 		assembly_id,
  5286| 		module_id,
  5287| 		assembly_name ? assembly_name : "",
  5288| 		NULL,
  5289| 		NULL);
  5290| 	mono_profiler_fire_event_exit ();
  5291| 	g_free (assembly_name);
  5292| }
  5293| static
  5294| void
  5295| mono_profiler_method_enter (
  5296| 	MonoProfiler *prof,
  5297| 	MonoMethod *method,
  5298| 	MonoProfilerCallContext *context)
  5299| {
  5300| 	if (!EventEnabledMonoProfilerMethodEnter ())
  5301| 		return;
  5302| 	mono_profiler_fire_event_enter ();
  5303| 	FireEtwMonoProfilerMethodEnter (
  5304| 		(uint64_t)method,
  5305| 		NULL,
  5306| 		NULL);
  5307| 	mono_profiler_fire_event_exit ();
  5308| }
  5309| static
  5310| void
  5311| mono_profiler_method_leave (
  5312| 	MonoProfiler *prof,
  5313| 	MonoMethod *method,
  5314| 	MonoProfilerCallContext *context)
  5315| {
  5316| 	if (!EventEnabledMonoProfilerMethodLeave ())
  5317| 		return;
  5318| 	mono_profiler_fire_event_enter ();
  5319| 	FireEtwMonoProfilerMethodLeave (
  5320| 		(uint64_t)method,
  5321| 		NULL,
  5322| 		NULL);
  5323| 	mono_profiler_fire_event_exit ();
  5324| }
  5325| static
  5326| void
  5327| mono_profiler_method_tail_call (
  5328| 	MonoProfiler *prof,
  5329| 	MonoMethod *method,
  5330| 	MonoMethod *target_method)
  5331| {
  5332| 	if (!EventEnabledMonoProfilerMethodTailCall ())
  5333| 		return;
  5334| 	mono_profiler_fire_event_enter ();
  5335| 	FireEtwMonoProfilerMethodTailCall (
  5336| 		(uint64_t)method,
  5337| 		NULL,
  5338| 		NULL);
  5339| 	mono_profiler_fire_event_exit ();
  5340| }
  5341| static
  5342| void
  5343| mono_profiler_method_exception_leave (
  5344| 	MonoProfiler *prof,
  5345| 	MonoMethod *method,
  5346| 	MonoObject *exc)
  5347| {
  5348| 	if (!EventEnabledMonoProfilerMethodExceptionLeave ())
  5349| 		return;
  5350| 	mono_profiler_fire_event_enter ();
  5351| 	FireEtwMonoProfilerMethodExceptionLeave (
  5352| 		(uint64_t)method,
  5353| 		NULL,
  5354| 		NULL);
  5355| 	mono_profiler_fire_event_exit ();
  5356| }
  5357| static
  5358| void
  5359| mono_profiler_method_free (
  5360| 	MonoProfiler *prof,
  5361| 	MonoMethod *method)
  5362| {
  5363| 	if (!EventEnabledMonoProfilerMethodFree ())
  5364| 		return;
  5365| 	mono_profiler_fire_event_enter ();
  5366| 	FireEtwMonoProfilerMethodFree (
  5367| 		(uint64_t)method,
  5368| 		NULL,
  5369| 		NULL);
  5370| 	mono_profiler_fire_event_exit ();
  5371| }
  5372| static
  5373| void
  5374| mono_profiler_method_begin_invoke (
  5375| 	MonoProfiler *prof,
  5376| 	MonoMethod *method)
  5377| {
  5378| 	if (!EventEnabledMonoProfilerMethodBeginInvoke ())
  5379| 		return;
  5380| 	mono_profiler_fire_event_enter ();
  5381| 	FireEtwMonoProfilerMethodBeginInvoke (
  5382| 		(uint64_t)method,
  5383| 		NULL,
  5384| 		NULL);
  5385| 	mono_profiler_fire_event_exit ();
  5386| }
  5387| static
  5388| void
  5389| mono_profiler_method_end_invoke (
  5390| 	MonoProfiler *prof,
  5391| 	MonoMethod *method)
  5392| {
  5393| 	if (!EventEnabledMonoProfilerMethodEndInvoke ())
  5394| 		return;
  5395| 	mono_profiler_fire_event_enter ();
  5396| 	FireEtwMonoProfilerMethodEndInvoke (
  5397| 		(uint64_t)method,
  5398| 		NULL,
  5399| 		NULL);
  5400| 	mono_profiler_fire_event_exit ();
  5401| }
  5402| static
  5403| MonoProfilerCallInstrumentationFlags
  5404| mono_profiler_method_instrumentation (
  5405| 	MonoProfiler *prof,
  5406| 	MonoMethod *method)
  5407| {
  5408| 	if (_ep_rt_dotnet_mono_profiler_provider_callspec.len > 0 && !mono_callspec_eval (method, &_ep_rt_dotnet_mono_profiler_provider_callspec))
  5409| 		return MONO_PROFILER_CALL_INSTRUMENTATION_NONE;
  5410| 	return MONO_PROFILER_CALL_INSTRUMENTATION_ENTER |
  5411| 			MONO_PROFILER_CALL_INSTRUMENTATION_LEAVE |
  5412| 			MONO_PROFILER_CALL_INSTRUMENTATION_TAIL_CALL |
  5413| 			MONO_PROFILER_CALL_INSTRUMENTATION_EXCEPTION_LEAVE;
  5414| }
  5415| static
  5416| void
  5417| mono_profiler_exception_throw (
  5418| 	MonoProfiler *prof,
  5419| 	MonoObject *exc)
  5420| {
  5421| 	if (!EventEnabledMonoProfilerExceptionThrow ())
  5422| 		return;
  5423| 	uint64_t type_id = 0;
  5424| 	if (exc && mono_object_class(exc))
  5425| 		type_id = (uint64_t)m_class_get_byval_arg (mono_object_class(exc));
  5426| 	mono_profiler_fire_event_enter ();
  5427| 	FireEtwMonoProfilerExceptionThrow (
  5428| 		type_id,
  5429| 		SGEN_POINTER_UNTAG_ALL (exc),
  5430| 		NULL,
  5431| 		NULL);
  5432| 	mono_profiler_fire_event_exit ();
  5433| }
  5434| static
  5435| void
  5436| mono_profiler_exception_clause (
  5437| 	MonoProfiler *prof,
  5438| 	MonoMethod *method,
  5439| 	uint32_t clause_num,
  5440| 	MonoExceptionEnum clause_type,
  5441| 	MonoObject *exc)
  5442| {
  5443| 	if (!EventEnabledMonoProfilerExceptionClause ())
  5444| 		return;
  5445| 	uint64_t type_id = 0;
  5446| 	if (exc && mono_object_class(exc))
  5447| 		type_id = (uint64_t)m_class_get_byval_arg (mono_object_class(exc));
  5448| 	mono_profiler_fire_event_enter ();
  5449| 	FireEtwMonoProfilerExceptionClause (
  5450| 		(uint8_t)clause_type,
  5451| 		clause_num,
  5452| 		(uint64_t)method,
  5453| 		type_id,
  5454| 		SGEN_POINTER_UNTAG_ALL (exc),
  5455| 		NULL,
  5456| 		NULL);
  5457| 	mono_profiler_fire_event_exit ();
  5458| }
  5459| static
  5460| void
  5461| mono_profiler_gc_event (
  5462| 	MonoProfiler *prof,
  5463| 	MonoProfilerGCEvent gc_event,
  5464| 	uint32_t generation,
  5465| 	mono_bool serial)
  5466| {
  5467| 	switch (gc_event) {
  5468| 	case MONO_GC_EVENT_PRE_STOP_WORLD:
  5469| 	case MONO_GC_EVENT_POST_START_WORLD_UNLOCKED:
  5470| 	{
  5471| 		FireEtwMonoProfilerGCEvent (
  5472| 			(uint8_t)gc_event,
  5473| 			generation,
  5474| 			NULL,
  5475| 			NULL);
  5476| 		break;
  5477| 	}
  5478| 	case MONO_GC_EVENT_PRE_STOP_WORLD_LOCKED:
  5479| 	{
  5480| 		FireEtwMonoProfilerGCEvent (
  5481| 			(uint8_t)gc_event,
  5482| 			generation,
  5483| 			NULL,
  5484| 			NULL);
  5485| 		mono_profiler_gc_in_progress_start ();
  5486| 		if (mono_profiler_gc_heap_collect_in_progress ()) {
  5487| 			FireEtwMonoProfilerGCHeapDumpStart (
  5488| 				mono_profiler_get_gc_heap_collect_param_request_value (),
  5489| 				NULL,
  5490| 				NULL);
  5491| 		}
  5492| 		break;
  5493| 	}
  5494| 	case MONO_GC_EVENT_POST_STOP_WORLD:
  5495| 	{
  5496| 		if (mono_profiler_gc_in_progress ()) {
  5497| 			uint64_t enabled_keywords = MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_EVENTPIPE_Context.EnabledKeywordsBitmask;
  5498| 			if (profiler_callback_is_enabled (enabled_keywords, GC_ROOT_KEYWORD)) {
  5499| 				mono_profiler_set_gc_root_register_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  5500| 				mono_profiler_set_gc_root_unregister_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  5501| 				mono_profiler_set_gc_root_register_callback (_ep_rt_dotnet_mono_profiler_heap_collect_provider, mono_profiler_fire_buffered_gc_event_root_register);
  5502| 				mono_profiler_set_gc_root_unregister_callback (_ep_rt_dotnet_mono_profiler_heap_collect_provider, mono_profiler_fire_buffered_gc_event_root_unregister);
  5503| 			}
  5504| 			if (mono_profiler_gc_heap_collect_in_progress ()) {
  5505| 				if (profiler_callback_is_enabled (enabled_keywords, GC_ROOT_KEYWORD)) {
  5506| 					mono_profiler_set_gc_roots_callback (_ep_rt_dotnet_mono_profiler_heap_collect_provider, mono_profiler_fire_buffered_gc_event_roots);
  5507| 				}
  5508| 				if (profiler_callback_is_enabled (enabled_keywords, GC_MOVES_KEYWORD)) {
  5509| 					mono_profiler_set_gc_moves_callback (_ep_rt_dotnet_mono_profiler_heap_collect_provider, mono_profiler_fire_buffered_gc_event_moves);
  5510| 				}
  5511| 				if (profiler_callback_is_enabled (enabled_keywords, GC_RESIZE_KEYWORD)) {
  5512| 					mono_profiler_set_gc_resize_callback (_ep_rt_dotnet_mono_profiler_heap_collect_provider, mono_profiler_fire_buffered_gc_event_resize);
  5513| 				}
  5514| 			}
  5515| 			mono_profiler_fire_buffered_gc_event (
  5516| 				(uint8_t)gc_event,
  5517| 				generation);
  5518| 		}
  5519| 		break;
  5520| 	}
  5521| 	case MONO_GC_EVENT_START:
  5522| 	case MONO_GC_EVENT_END:
  5523| 	{
  5524| 		if (mono_profiler_gc_in_progress ()) {
  5525| 			mono_profiler_fire_buffered_gc_event (
  5526| 				(uint8_t)gc_event,
  5527| 				generation);
  5528| 		}
  5529| 		break;
  5530| 	}
  5531| 	case MONO_GC_EVENT_PRE_START_WORLD:
  5532| 	{
  5533| 		if (mono_profiler_gc_in_progress ()) {
  5534| 			uint64_t enabled_keywords = MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_EVENTPIPE_Context.EnabledKeywordsBitmask;
  5535| 			if (mono_profiler_gc_heap_collect_in_progress () && profiler_callback_is_enabled (enabled_keywords, GC_HEAP_DUMP_KEYWORD))
  5536| 				mono_gc_walk_heap (0, mono_profiler_fire_buffered_gc_event_heap_dump_object_reference, NULL);
  5537| 			mono_profiler_set_gc_root_register_callback (_ep_rt_dotnet_mono_profiler_heap_collect_provider, NULL);
  5538| 			mono_profiler_set_gc_root_unregister_callback (_ep_rt_dotnet_mono_profiler_heap_collect_provider, NULL);
  5539| 			mono_profiler_set_gc_roots_callback (_ep_rt_dotnet_mono_profiler_heap_collect_provider, NULL);
  5540| 			mono_profiler_set_gc_moves_callback (_ep_rt_dotnet_mono_profiler_heap_collect_provider, NULL);
  5541| 			mono_profiler_set_gc_resize_callback (_ep_rt_dotnet_mono_profiler_heap_collect_provider, NULL);
  5542| 			if (profiler_callback_is_enabled (enabled_keywords, GC_ROOT_KEYWORD)) {
  5543| 				mono_profiler_set_gc_root_register_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_gc_root_register);
  5544| 				mono_profiler_set_gc_root_unregister_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_gc_root_unregister);
  5545| 			}
  5546| 			mono_profiler_fire_buffered_gc_event (
  5547| 				(uint8_t)gc_event,
  5548| 				generation);
  5549| 		}
  5550| 		break;
  5551| 	}
  5552| 	case MONO_GC_EVENT_POST_START_WORLD:
  5553| 	{
  5554| 		if (mono_profiler_gc_in_progress ()) {
  5555| 			GHashTable *cache = NULL;
  5556| 			uint64_t enabled_keywords = MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_EVENTPIPE_Context.EnabledKeywordsBitmask;
  5557| 			if (mono_profiler_gc_heap_collect_in_progress () && profiler_callback_is_enabled (enabled_keywords, GC_HEAP_DUMP_VTABLE_CLASS_REF_KEYWORD))
  5558| 				cache = g_hash_table_new_full (NULL, NULL, NULL, NULL);
  5559| 			mono_profiler_fire_buffered_gc_events_in_alloc_order (cache);
  5560| 			mono_profiler_fire_cached_gc_events (cache);
  5561| 			if (cache)
  5562| 				g_hash_table_destroy (cache);
  5563| 			if (mono_profiler_gc_heap_collect_in_progress ()) {
  5564| 				FireEtwMonoProfilerGCHeapDumpStop (
  5565| 					NULL,
  5566| 					NULL);
  5567| 			}
  5568| 			FireEtwMonoProfilerGCEvent (
  5569| 				(uint8_t)gc_event,
  5570| 				generation,
  5571| 				NULL,
  5572| 				NULL);
  5573| 			if (!profiler_callback_is_enabled (enabled_keywords, GC_KEYWORD))
  5574| 				mono_profiler_set_gc_event_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  5575| 			mono_profiler_gc_heap_collect_in_progress_stop ();
  5576| 			mono_profiler_gc_in_progress_stop ();
  5577| 		}
  5578| 		break;
  5579| 	}
  5580| 	default:
  5581| 		break;
  5582| 	}
  5583| }
  5584| static
  5585| void
  5586| mono_profiler_gc_allocation (
  5587| 	MonoProfiler *prof,
  5588| 	MonoObject *object)
  5589| {
  5590| 	if (!EventEnabledMonoProfilerGCAllocation ())
  5591| 		return;
  5592| 	uint64_t vtable_id = 0;
  5593| 	uint64_t object_size = 0;
  5594| 	if (object) {
  5595| 		vtable_id = (uint64_t)mono_object_get_vtable_internal (object);
  5596| 		object_size = (uint64_t)mono_object_get_size_internal (object);
  5597| 		/* account for object alignment */
  5598| 		object_size += 7;
  5599| 		object_size &= ~7;
  5600| 	}
  5601| 	mono_profiler_fire_event_enter ();
  5602| 	FireEtwMonoProfilerGCAllocation (
  5603| 		vtable_id,
  5604| 		SGEN_POINTER_UNTAG_ALL (object),
  5605| 		object_size,
  5606| 		NULL,
  5607| 		NULL);
  5608| 	mono_profiler_fire_event_exit ();
  5609| }
  5610| static
  5611| void
  5612| mono_profiler_gc_handle_created (
  5613| 	MonoProfiler *prof,
  5614| 	uint32_t handle,
  5615| 	MonoGCHandleType type,
  5616| 	MonoObject *object)
  5617| {
  5618| 	if (!EventEnabledMonoProfilerGCHandleCreated ())
  5619| 		return;
  5620| 	mono_profiler_fire_event_enter ();
  5621| 	FireEtwMonoProfilerGCHandleCreated (
  5622| 		handle,
  5623| 		(uint8_t)type,
  5624| 		SGEN_POINTER_UNTAG_ALL (object),
  5625| 		NULL,
  5626| 		NULL);
  5627| 	mono_profiler_fire_event_exit ();
  5628| }
  5629| static
  5630| void
  5631| mono_profiler_gc_handle_deleted (
  5632| 	MonoProfiler *prof,
  5633| 	uint32_t handle,
  5634| 	MonoGCHandleType type)
  5635| {
  5636| 	if (!EventEnabledMonoProfilerGCHandleDeleted ())
  5637| 		return;
  5638| 	mono_profiler_fire_event_enter ();
  5639| 	FireEtwMonoProfilerGCHandleDeleted (
  5640| 		handle,
  5641| 		(uint8_t)type,
  5642| 		NULL,
  5643| 		NULL);
  5644| 	mono_profiler_fire_event_exit ();
  5645| }
  5646| static
  5647| void
  5648| mono_profiler_gc_finalizing (MonoProfiler *prof)
  5649| {
  5650| 	if (!EventEnabledMonoProfilerGCFinalizing ())
  5651| 		return;
  5652| 	mono_profiler_fire_event_enter ();
  5653| 	FireEtwMonoProfilerGCFinalizing (
  5654| 		NULL,
  5655| 		NULL);
  5656| 	mono_profiler_fire_event_exit ();
  5657| }
  5658| static
  5659| void
  5660| mono_profiler_gc_finalized (MonoProfiler *prof)
  5661| {
  5662| 	if (!EventEnabledMonoProfilerGCFinalized ())
  5663| 		return;
  5664| 	mono_profiler_fire_event_enter ();
  5665| 	FireEtwMonoProfilerGCFinalized (
  5666| 		NULL,
  5667| 		NULL);
  5668| 	mono_profiler_fire_event_exit ();
  5669| }
  5670| static
  5671| void
  5672| mono_profiler_gc_finalizing_object (
  5673| 	MonoProfiler *prof,
  5674| 	MonoObject *object)
  5675| {
  5676| 	if (!EventEnabledMonoProfilerGCFinalizingObject ())
  5677| 		return;
  5678| 	mono_profiler_fire_event_enter ();
  5679| 	FireEtwMonoProfilerGCFinalizingObject (
  5680| 		SGEN_POINTER_UNTAG_ALL (object),
  5681| 		NULL,
  5682| 		NULL);
  5683| 	mono_profiler_fire_event_exit ();
  5684| }
  5685| static
  5686| void
  5687| mono_profiler_gc_finalized_object (
  5688| 	MonoProfiler *prof,
  5689| 	MonoObject * object)
  5690| {
  5691| 	if (!EventEnabledMonoProfilerGCFinalizedObject ())
  5692| 		return;
  5693| 	mono_profiler_fire_event_enter ();
  5694| 	FireEtwMonoProfilerGCFinalizedObject (
  5695| 		SGEN_POINTER_UNTAG_ALL (object),
  5696| 		NULL,
  5697| 		NULL);
  5698| 	mono_profiler_fire_event_exit ();
  5699| }
  5700| static
  5701| void
  5702| mono_profiler_gc_root_register (
  5703| 	MonoProfiler *prof,
  5704| 	const mono_byte *start,
  5705| 	uintptr_t size,
  5706| 	MonoGCRootSource source,
  5707| 	const void * key,
  5708| 	const char * name)
  5709| {
  5710| 	if (!EventEnabledMonoProfilerGCRootRegister ())
  5711| 		return;
  5712| 	mono_profiler_fire_event_enter ();
  5713| 	FireEtwMonoProfilerGCRootRegister (
  5714| 		start,
  5715| 		(uint64_t)size,
  5716| 		(uint8_t) source,
  5717| 		(uint64_t)key,
  5718| 		(const ep_char8_t *)(name ? name : ""),
  5719| 		NULL,
  5720| 		NULL);
  5721| 	mono_profiler_fire_event_exit ();
  5722| }
  5723| static
  5724| void
  5725| mono_profiler_gc_root_unregister (
  5726| 	MonoProfiler *prof,
  5727| 	const mono_byte *start)
  5728| {
  5729| 	if (!EventEnabledMonoProfilerGCRootUnregister ())
  5730| 		return;
  5731| 	mono_profiler_fire_event_enter ();
  5732| 	FireEtwMonoProfilerGCRootUnregister (
  5733| 		start,
  5734| 		NULL,
  5735| 		NULL);
  5736| 	mono_profiler_fire_event_exit ();
  5737| }
  5738| static
  5739| void
  5740| mono_profiler_monitor_contention (
  5741| 	MonoProfiler *prof,
  5742| 	MonoObject *object)
  5743| {
  5744| 	if (!EventEnabledMonoProfilerMonitorContention ())
  5745| 		return;
  5746| 	mono_profiler_fire_event_enter ();
  5747| 	FireEtwMonoProfilerMonitorContention (
  5748| 		SGEN_POINTER_UNTAG_ALL (object),
  5749| 		NULL,
  5750| 		NULL);
  5751| 	mono_profiler_fire_event_exit ();
  5752| }
  5753| static
  5754| void
  5755| mono_profiler_monitor_failed (
  5756| 	MonoProfiler *prof,
  5757| 	MonoObject *object)
  5758| {
  5759| 	if (!EventEnabledMonoProfilerMonitorFailed ())
  5760| 		return;
  5761| 	mono_profiler_fire_event_enter ();
  5762| 	FireEtwMonoProfilerMonitorFailed (
  5763| 		SGEN_POINTER_UNTAG_ALL (object),
  5764| 		NULL,
  5765| 		NULL);
  5766| 	mono_profiler_fire_event_exit ();
  5767| }
  5768| static
  5769| void
  5770| mono_profiler_monitor_acquired (
  5771| 	MonoProfiler *prof,
  5772| 	MonoObject *object)
  5773| {
  5774| 	if (!EventEnabledMonoProfilerMonitorAcquired ())
  5775| 		return;
  5776| 	mono_profiler_fire_event_enter ();
  5777| 	FireEtwMonoProfilerMonitorAcquired (
  5778| 		SGEN_POINTER_UNTAG_ALL (object),
  5779| 		NULL,
  5780| 		NULL);
  5781| 	mono_profiler_fire_event_exit ();
  5782| }
  5783| static
  5784| void
  5785| mono_profiler_thread_started (
  5786| 	MonoProfiler *prof,
  5787| 	uintptr_t tid)
  5788| {
  5789| 	if (!EventEnabledMonoProfilerThreadStarted ())
  5790| 		return;
  5791| 	mono_profiler_fire_event_enter ();
  5792| 	FireEtwMonoProfilerThreadStarted (
  5793| 		(uint64_t)tid,
  5794| 		NULL,
  5795| 		NULL);
  5796| 	mono_profiler_fire_event_exit ();
  5797| }
  5798| static
  5799| void
  5800| mono_profiler_thread_stopping (
  5801| 	MonoProfiler *prof,
  5802| 	uintptr_t tid)
  5803| {
  5804| 	if (!EventEnabledMonoProfilerThreadStopping ())
  5805| 		return;
  5806| 	mono_profiler_fire_event_enter ();
  5807| 	FireEtwMonoProfilerThreadStopping (
  5808| 		(uint64_t)tid,
  5809| 		NULL,
  5810| 		NULL);
  5811| 	mono_profiler_fire_event_exit ();
  5812| }
  5813| static
  5814| void
  5815| mono_profiler_thread_stopped (
  5816| 	MonoProfiler *prof,
  5817| 	uintptr_t tid)
  5818| {
  5819| 	if (!EventEnabledMonoProfilerThreadStopped ())
  5820| 		return;
  5821| 	mono_profiler_fire_event_enter ();
  5822| 	FireEtwMonoProfilerThreadStopped (
  5823| 		(uint64_t)tid,
  5824| 		NULL,
  5825| 		NULL);
  5826| 	mono_profiler_fire_event_exit ();
  5827| }
  5828| static
  5829| void
  5830| mono_profiler_thread_exited (
  5831| 	MonoProfiler *prof,
  5832| 	uintptr_t tid)
  5833| {
  5834| 	if (!EventEnabledMonoProfilerThreadExited ())
  5835| 		return;
  5836| 	mono_profiler_fire_event_enter ();
  5837| 	FireEtwMonoProfilerThreadExited (
  5838| 		(uint64_t)tid,
  5839| 		NULL,
  5840| 		NULL);
  5841| 	mono_profiler_fire_event_exit ();
  5842| }
  5843| static
  5844| void
  5845| mono_profiler_thread_name (
  5846| 	MonoProfiler *prof,
  5847| 	uintptr_t tid,
  5848| 	const char *name)
  5849| {
  5850| 	if (!EventEnabledMonoProfilerThreadName ())
  5851| 		return;
  5852| 	mono_profiler_fire_event_enter ();
  5853| 	FireEtwMonoProfilerThreadName (
  5854| 		(uint64_t)tid,
  5855| 		(ep_char8_t *)(name ? name : ""),
  5856| 		NULL,
  5857| 		NULL);
  5858| 	mono_profiler_fire_event_exit ();
  5859| }
  5860| static
  5861| const EventFilterDescriptor *
  5862| mono_profiler_add_provider_param (const EventFilterDescriptor *key)
  5863| {
  5864| 	ep_rt_spin_lock_requires_lock_held (&_ep_rt_mono_profiler_gc_state_lock);
  5865| 	EventFilterDescriptor *param = NULL;
  5866| 	if (key && key->ptr && key->size) {
  5867| 		uint64_t param_ptr = (uint64_t)g_malloc (key->size);
  5868| 		if (param_ptr) {
  5869| 			param = ep_event_filter_desc_alloc (param_ptr, key->size, key->type);
  5870| 			if (param) {
  5871| 				memcpy ((uint8_t*)(uintptr_t)param->ptr,(const uint8_t*)(uintptr_t)key->ptr, key->size);
  5872| 				_ep_rt_mono_profiler_provider_params = g_slist_append (_ep_rt_mono_profiler_provider_params, param);
  5873| 			} else {
  5874| 				g_free ((void *)(uintptr_t)param_ptr);
  5875| 			}
  5876| 		}
  5877| 	}
  5878| 	return param;
  5879| }
  5880| static
  5881| bool
  5882| mono_profiler_remove_provider_param (const EventFilterDescriptor *key)
  5883| {
  5884| 	ep_rt_spin_lock_requires_lock_held (&_ep_rt_mono_profiler_gc_state_lock);
  5885| 	bool removed = false;
  5886| 	if (_ep_rt_mono_profiler_provider_params && key && key->ptr && key->size) {
  5887| 		GSList *list = _ep_rt_mono_profiler_provider_params;
  5888| 		EventFilterDescriptor *param = NULL;
  5889| 		while (list) {
  5890| 			param = (EventFilterDescriptor *)(list->data);
  5891| 			if (param && param->ptr && param->type == key->type && param->size == key->size &&
  5892| 				memcmp ((const void *)(uintptr_t)param->ptr, (const void *)(uintptr_t)key->ptr, param->size) == 0) {
  5893| 					g_free ((void *)(uintptr_t)param->ptr);
  5894| 					ep_event_filter_desc_free (param);
  5895| 					_ep_rt_mono_profiler_provider_params = g_slist_delete_link (_ep_rt_mono_profiler_provider_params, list);
  5896| 					removed = true;
  5897| 					break;
  5898| 			}
  5899| 			list = list->next;
  5900| 		}
  5901| 	}
  5902| 	return removed;
  5903| }
  5904| static
  5905| void
  5906| mono_profiler_free_provider_params (void)
  5907| {
  5908| 	for (GSList *list = _ep_rt_mono_profiler_provider_params; list; list = list->next) {
  5909| 		EventFilterDescriptor *param = (EventFilterDescriptor *)(list->data);
  5910| 		if (param) {
  5911| 			g_free ((void *)(uintptr_t)param->ptr);
  5912| 			ep_event_filter_desc_free (param);
  5913| 		}
  5914| 	}
  5915| 	g_slist_free (_ep_rt_mono_profiler_provider_params);
  5916| 	_ep_rt_mono_profiler_provider_params = NULL;
  5917| }
  5918| static
  5919| bool
  5920| mono_profiler_provider_params_get_value (
  5921| 	const EventFilterDescriptor *param,
  5922| 	const ep_char8_t *key,
  5923| 	const ep_char8_t **value)
  5924| {
  5925| 	if (!param || !param->ptr || !param->size || !key)
  5926| 		return false;
  5927| 	const ep_char8_t *current = (ep_char8_t *)(uintptr_t)param->ptr;
  5928| 	const ep_char8_t *end = current + param->size;
  5929| 	bool found_key = false;
  5930| 	if (value)
  5931| 		*value = "";
  5932| 	if (!current [param->size - 1]) {
  5933| 		while (current < end) {
  5934| 			if (found_key) {
  5935| 				if (value)
  5936| 					*value = current;
  5937| 				break;
  5938| 			}
  5939| 			if (!ep_rt_utf8_string_compare_ignore_case (current, key)) {
  5940| 				found_key = true;
  5941| 			}
  5942| 			current = current + strlen (current) + 1;
  5943| 		}
  5944| 	}
  5945| 	return found_key;
  5946| }
  5947| static
  5948| bool
  5949| mono_profiler_provider_param_contains_heap_collect_ondemand (const EventFilterDescriptor *param)
  5950| {
  5951| 	const ep_char8_t *value = NULL;
  5952| 	bool found_heap_collect_ondemand_value = false;
  5953| 	if (mono_profiler_provider_params_get_value (param, "heapcollect", &value)) {
  5954| 		if (strstr (value, "ondemand"))
  5955| 			found_heap_collect_ondemand_value = true;
  5956| 	}
  5957| 	return found_heap_collect_ondemand_value;
  5958| }
  5959| static
  5960| void
  5961| mono_profiler_push_gc_heap_collect_param_request_value (const EventFilterDescriptor *param)
  5962| {
  5963| 	ep_rt_spin_lock_requires_lock_held (&_ep_rt_mono_profiler_gc_state_lock);
  5964| 	const ep_char8_t *value = NULL;
  5965| 	if (param)
  5966| 		mono_profiler_provider_params_get_value (param, "heapcollect", &value);
  5967| 	if (!_ep_rt_mono_profiler_gc_heap_collect_request_params)
  5968| 		_ep_rt_mono_profiler_gc_heap_collect_request_params = g_queue_new ();
  5969| 	if (_ep_rt_mono_profiler_gc_heap_collect_request_params)
  5970| 		g_queue_push_tail (_ep_rt_mono_profiler_gc_heap_collect_request_params, (gpointer)ep_rt_utf8_string_dup (value ? value : ""));
  5971| }
  5972| static
  5973| void
  5974| mono_profiler_pop_gc_heap_collect_param_request_value (void)
  5975| {
  5976| 	ep_rt_spin_lock_requires_lock_held (&_ep_rt_mono_profiler_gc_state_lock);
  5977| 	ep_char8_t *value = NULL;
  5978| 	if (_ep_rt_mono_profiler_gc_heap_collect_request_params && !g_queue_is_empty (_ep_rt_mono_profiler_gc_heap_collect_request_params))
  5979| 		value = (ep_char8_t *)g_queue_pop_head (_ep_rt_mono_profiler_gc_heap_collect_request_params);
  5980| 	g_free (value);
  5981| }
  5982| static
  5983| const ep_char8_t *
  5984| mono_profiler_get_gc_heap_collect_param_request_value (void)
  5985| {
  5986| 	ep_rt_spin_lock_requires_lock_held (&_ep_rt_mono_profiler_gc_state_lock);
  5987| 	ep_char8_t *value = NULL;
  5988| 	if (_ep_rt_mono_profiler_gc_heap_collect_request_params && !g_queue_is_empty (_ep_rt_mono_profiler_gc_heap_collect_request_params)) {
  5989| 		value = (ep_char8_t *)g_queue_pop_head (_ep_rt_mono_profiler_gc_heap_collect_request_params);
  5990| 		g_queue_push_head (_ep_rt_mono_profiler_gc_heap_collect_request_params, (gpointer)value);
  5991| 	}
  5992| 	return value ? value : "";
  5993| }
  5994| static
  5995| void
  5996| mono_profiler_free_gc_heap_collect_param_requests (void)
  5997| {
  5998| 	if (_ep_rt_mono_profiler_gc_heap_collect_request_params) {
  5999| 		while (!g_queue_is_empty (_ep_rt_mono_profiler_gc_heap_collect_request_params))
  6000| 			g_free (g_queue_pop_head (_ep_rt_mono_profiler_gc_heap_collect_request_params));
  6001| 		g_queue_free (_ep_rt_mono_profiler_gc_heap_collect_request_params);
  6002| 		_ep_rt_mono_profiler_gc_heap_collect_request_params = NULL;
  6003| 	}
  6004| }
  6005| static
  6006| void
  6007| mono_profiler_ep_provider_callback (
  6008| 	const uint8_t *source_id,
  6009| 	unsigned long is_enabled,
  6010| 	uint8_t level,
  6011| 	uint64_t match_any_keywords,
  6012| 	uint64_t match_all_keywords,
  6013| 	EventFilterDescriptor *filter_data,
  6014| 	void *callback_data)
  6015| {
  6016| 	ep_rt_config_requires_lock_not_held ();
  6017| 	ep_rt_spin_lock_requires_lock_held (&_ep_rt_mono_profiler_gc_state_lock);
  6018| 	EP_ASSERT(is_enabled == 0 || is_enabled == 1) ;
  6019| 	EP_ASSERT (_ep_rt_dotnet_mono_profiler_provider != NULL);
  6020| 	EP_ASSERT (_ep_rt_dotnet_mono_profiler_heap_collect_provider != NULL);
  6021| 	match_any_keywords = (is_enabled == 1) ? match_any_keywords : 0;
  6022| 	EP_LOCK_ENTER (section1)
  6023| 		uint64_t enabled_keywords = MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_EVENTPIPE_Context.EnabledKeywordsBitmask;
  6024| 		if (profiler_callback_is_enabled(match_any_keywords, LOADER_KEYWORD)) {
  6025| 			if (!profiler_callback_is_enabled (enabled_keywords, LOADER_KEYWORD)) {
  6026| 				mono_profiler_set_domain_loading_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_app_domain_loading);
  6027| 				mono_profiler_set_domain_loaded_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_app_domain_loaded);
  6028| 				mono_profiler_set_domain_unloading_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_app_domain_unloading);
  6029| 				mono_profiler_set_domain_unloaded_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_app_domain_unloaded);
  6030| 				mono_profiler_set_domain_name_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_app_domain_name);
  6031| 				mono_profiler_set_image_loading_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_module_loading);
  6032| 				mono_profiler_set_image_failed_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_module_failed);
  6033| 				mono_profiler_set_image_loaded_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_module_loaded);
  6034| 				mono_profiler_set_image_unloading_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_module_unloading);
  6035| 				mono_profiler_set_image_unloaded_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_module_unloaded);
  6036| 				mono_profiler_set_assembly_loading_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_assembly_loading);
  6037| 				mono_profiler_set_assembly_loaded_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_assembly_loaded);
  6038| 				mono_profiler_set_assembly_unloading_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_assembly_unloading);
  6039| 				mono_profiler_set_assembly_unloaded_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_assembly_unloaded);
  6040| 			}
  6041| 		} else {
  6042| 			if (profiler_callback_is_enabled (enabled_keywords, LOADER_KEYWORD)) {
  6043| 				mono_profiler_set_domain_loading_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6044| 				mono_profiler_set_domain_loaded_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6045| 				mono_profiler_set_domain_unloading_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6046| 				mono_profiler_set_domain_unloaded_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6047| 				mono_profiler_set_domain_name_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6048| 				mono_profiler_set_image_loading_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6049| 				mono_profiler_set_image_failed_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6050| 				mono_profiler_set_image_loaded_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6051| 				mono_profiler_set_image_unloading_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6052| 				mono_profiler_set_image_unloaded_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6053| 				mono_profiler_set_assembly_loading_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6054| 				mono_profiler_set_assembly_loaded_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6055| 				mono_profiler_set_assembly_unloading_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6056| 				mono_profiler_set_assembly_unloaded_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6057| 			}
  6058| 		}
  6059| 		if (profiler_callback_is_enabled(match_any_keywords, JIT_KEYWORD)) {
  6060| 			if (!profiler_callback_is_enabled (enabled_keywords, JIT_KEYWORD)) {
  6061| 				mono_profiler_set_jit_begin_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_jit_begin);
  6062| 				mono_profiler_set_jit_failed_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_jit_failed);
  6063| 				mono_profiler_set_jit_done_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_jit_done);
  6064| 				mono_profiler_set_jit_chunk_created_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_jit_chunk_created);
  6065| 				mono_profiler_set_jit_chunk_destroyed_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_jit_chunk_destroyed);
  6066| 				mono_profiler_set_jit_code_buffer_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_jit_code_buffer);
  6067| 			}
  6068| 		} else {
  6069| 			if (profiler_callback_is_enabled (enabled_keywords, JIT_KEYWORD)) {
  6070| 				mono_profiler_set_jit_begin_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6071| 				mono_profiler_set_jit_failed_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6072| 				mono_profiler_set_jit_done_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6073| 				mono_profiler_set_jit_chunk_created_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6074| 				mono_profiler_set_jit_chunk_destroyed_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6075| 				mono_profiler_set_jit_code_buffer_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6076| 			}
  6077| 		}
  6078| 		if (profiler_callback_is_enabled(match_any_keywords, TYPE_LOADING_KEYWORD)) {
  6079| 			if (!profiler_callback_is_enabled (enabled_keywords, TYPE_LOADING_KEYWORD)) {
  6080| 				mono_profiler_set_class_loading_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_class_loading);
  6081| 				mono_profiler_set_class_failed_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_class_failed);
  6082| 				mono_profiler_set_class_loaded_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_class_loaded);
  6083| 				mono_profiler_set_vtable_loading_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_vtable_loading);
  6084| 				mono_profiler_set_vtable_failed_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_vtable_failed);
  6085| 				mono_profiler_set_vtable_loaded_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_vtable_loaded);
  6086| 			}
  6087| 		} else {
  6088| 			if (profiler_callback_is_enabled (enabled_keywords, TYPE_LOADING_KEYWORD)) {
  6089| 				mono_profiler_set_class_loading_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6090| 				mono_profiler_set_class_failed_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6091| 				mono_profiler_set_class_loaded_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6092| 				mono_profiler_set_vtable_loading_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6093| 				mono_profiler_set_vtable_failed_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6094| 				mono_profiler_set_vtable_loaded_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6095| 			}
  6096| 		}
  6097| 		if (profiler_callback_is_enabled(match_any_keywords, METHOD_TRACING_KEYWORD)) {
  6098| 			if (!profiler_callback_is_enabled (enabled_keywords, METHOD_TRACING_KEYWORD)) {
  6099| 				mono_profiler_set_method_enter_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_method_enter);
  6100| 				mono_profiler_set_method_leave_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_method_leave);
  6101| 				mono_profiler_set_method_tail_call_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_method_tail_call);
  6102| 				mono_profiler_set_method_exception_leave_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_method_exception_leave);
  6103| 				mono_profiler_set_method_free_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_method_free);
  6104| 				mono_profiler_set_method_begin_invoke_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_method_begin_invoke);
  6105| 				mono_profiler_set_method_end_invoke_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_method_end_invoke);
  6106| 			}
  6107| 		} else {
  6108| 			if (profiler_callback_is_enabled (enabled_keywords, METHOD_TRACING_KEYWORD)) {
  6109| 				mono_profiler_set_method_enter_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6110| 				mono_profiler_set_method_leave_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6111| 				mono_profiler_set_method_tail_call_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6112| 				mono_profiler_set_method_exception_leave_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6113| 				mono_profiler_set_method_free_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6114| 				mono_profiler_set_method_begin_invoke_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6115| 				mono_profiler_set_method_end_invoke_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6116| 			}
  6117| 		}
  6118| 		if (profiler_callback_is_enabled(match_any_keywords, EXCEPTION_KEYWORD)) {
  6119| 			if (!profiler_callback_is_enabled (enabled_keywords, EXCEPTION_KEYWORD)) {
  6120| 				mono_profiler_set_exception_throw_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_exception_throw);
  6121| 				mono_profiler_set_exception_clause_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_exception_clause);
  6122| 			}
  6123| 		} else {
  6124| 			if (profiler_callback_is_enabled (enabled_keywords, EXCEPTION_KEYWORD)) {
  6125| 				mono_profiler_set_exception_throw_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6126| 				mono_profiler_set_exception_clause_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6127| 			}
  6128| 		}
  6129| 		if (profiler_callback_is_enabled(match_any_keywords, GC_KEYWORD)) {
  6130| 			if (!profiler_callback_is_enabled (enabled_keywords, GC_KEYWORD)) {
  6131| 				mono_profiler_set_gc_event_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_gc_event);
  6132| 			}
  6133| 		} else {
  6134| 		}
  6135| 		if (profiler_callback_is_enabled(match_any_keywords, GC_ALLOCATION_KEYWORD)) {
  6136| 			if (!profiler_callback_is_enabled (enabled_keywords, GC_ALLOCATION_KEYWORD)) {
  6137| 				mono_profiler_set_gc_allocation_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_gc_allocation);
  6138| 			}
  6139| 		} else {
  6140| 			if (profiler_callback_is_enabled (enabled_keywords, GC_ALLOCATION_KEYWORD)) {
  6141| 				mono_profiler_set_gc_allocation_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6142| 			}
  6143| 		}
  6144| 		if (profiler_callback_is_enabled(match_any_keywords, GC_HANDLE_KEYWORD)) {
  6145| 			if (!profiler_callback_is_enabled (enabled_keywords, GC_HANDLE_KEYWORD)) {
  6146| 				mono_profiler_set_gc_handle_created_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_gc_handle_created);
  6147| 				mono_profiler_set_gc_handle_deleted_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_gc_handle_deleted);
  6148| 			}
  6149| 		} else {
  6150| 			if (profiler_callback_is_enabled (enabled_keywords, GC_HANDLE_KEYWORD)) {
  6151| 				mono_profiler_set_gc_handle_created_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6152| 				mono_profiler_set_gc_handle_deleted_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6153| 			}
  6154| 		}
  6155| 		if (profiler_callback_is_enabled(match_any_keywords, GC_FINALIZATION_KEYWORD)) {
  6156| 			if (!profiler_callback_is_enabled (enabled_keywords, GC_FINALIZATION_KEYWORD)) {
  6157| 				mono_profiler_set_gc_finalizing_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_gc_finalizing);
  6158| 				mono_profiler_set_gc_finalized_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_gc_finalized);
  6159| 				mono_profiler_set_gc_finalizing_object_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_gc_finalizing_object);
  6160| 				mono_profiler_set_gc_finalized_object_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_gc_finalized_object);
  6161| 			}
  6162| 		} else {
  6163| 			if (profiler_callback_is_enabled (enabled_keywords, GC_FINALIZATION_KEYWORD)) {
  6164| 				mono_profiler_set_gc_finalizing_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6165| 				mono_profiler_set_gc_finalized_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6166| 				mono_profiler_set_gc_finalizing_object_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6167| 				mono_profiler_set_gc_finalized_object_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6168| 			}
  6169| 		}
  6170| 		if (profiler_callback_is_enabled(match_any_keywords, GC_ROOT_KEYWORD)) {
  6171| 			if (!profiler_callback_is_enabled (enabled_keywords, GC_ROOT_KEYWORD)) {
  6172| 				mono_profiler_set_gc_root_register_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_gc_root_register);
  6173| 				mono_profiler_set_gc_root_unregister_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_gc_root_unregister);
  6174| 			}
  6175| 		} else {
  6176| 			if (profiler_callback_is_enabled (enabled_keywords, GC_ROOT_KEYWORD)) {
  6177| 				mono_profiler_set_gc_root_register_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6178| 				mono_profiler_set_gc_root_unregister_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6179| 			}
  6180| 		}
  6181| 		if (profiler_callback_is_enabled(match_any_keywords, GC_HEAP_COLLECT_KEYWORD)) {
  6182| 			if (!profiler_callback_is_enabled (enabled_keywords, GC_HEAP_COLLECT_KEYWORD)) {
  6183| 				mono_profiler_set_gc_finalized_callback (_ep_rt_dotnet_mono_profiler_heap_collect_provider, mono_profiler_trigger_heap_collect);
  6184| 			}
  6185| 		} else {
  6186| 			if (profiler_callback_is_enabled (enabled_keywords, GC_HEAP_COLLECT_KEYWORD)) {
  6187| 				mono_profiler_set_gc_finalized_callback (_ep_rt_dotnet_mono_profiler_heap_collect_provider, NULL);
  6188| 			}
  6189| 		}
  6190| 		if (profiler_callback_is_enabled(match_any_keywords, MONITOR_KEYWORD) || profiler_callback_is_enabled(match_any_keywords, CONTENTION_KEYWORD)) {
  6191| 			if (!(profiler_callback_is_enabled(enabled_keywords, MONITOR_KEYWORD) && profiler_callback_is_enabled(enabled_keywords, CONTENTION_KEYWORD))) {
  6192| 				mono_profiler_set_monitor_contention_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_monitor_contention);
  6193| 			}
  6194| 		} else {
  6195| 			if (profiler_callback_is_enabled(enabled_keywords, MONITOR_KEYWORD) || profiler_callback_is_enabled(enabled_keywords, CONTENTION_KEYWORD)) {
  6196| 				mono_profiler_set_monitor_contention_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6197| 			}
  6198| 		}
  6199| 		if (profiler_callback_is_enabled(match_any_keywords, MONITOR_KEYWORD)) {
  6200| 			if (!profiler_callback_is_enabled (enabled_keywords, MONITOR_KEYWORD)) {
  6201| 				mono_profiler_set_monitor_failed_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_monitor_failed);
  6202| 				mono_profiler_set_monitor_acquired_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_monitor_acquired);
  6203| 			}
  6204| 		} else {
  6205| 			if (profiler_callback_is_enabled (enabled_keywords, MONITOR_KEYWORD)) {
  6206| 				mono_profiler_set_monitor_failed_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6207| 				mono_profiler_set_monitor_acquired_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6208| 			}
  6209| 		}
  6210| 		if (profiler_callback_is_enabled(match_any_keywords, THREADING_KEYWORD)) {
  6211| 			if (!profiler_callback_is_enabled (enabled_keywords, THREADING_KEYWORD)) {
  6212| 				mono_profiler_set_thread_started_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_thread_started);
  6213| 				mono_profiler_set_thread_stopping_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_thread_stopping);
  6214| 				mono_profiler_set_thread_stopped_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_thread_stopped);
  6215| 				mono_profiler_set_thread_exited_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_thread_exited);
  6216| 				mono_profiler_set_thread_name_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_thread_name);
  6217| 			}
  6218| 		} else {
  6219| 			if (profiler_callback_is_enabled (enabled_keywords, THREADING_KEYWORD)) {
  6220| 				mono_profiler_set_thread_started_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6221| 				mono_profiler_set_thread_stopping_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6222| 				mono_profiler_set_thread_stopped_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6223| 				mono_profiler_set_thread_exited_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6224| 				mono_profiler_set_thread_name_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6225| 			}
  6226| 		}
  6227| 		if (!_ep_rt_dotnet_mono_profiler_provider_callspec.enabled) {
  6228| 			if (profiler_callback_is_enabled(match_any_keywords, METHOD_INSTRUMENTATION_KEYWORD)) {
  6229| 				if (!profiler_callback_is_enabled (enabled_keywords, METHOD_INSTRUMENTATION_KEYWORD)) {
  6230| 					mono_profiler_set_call_instrumentation_filter_callback (_ep_rt_dotnet_mono_profiler_provider, mono_profiler_method_instrumentation);
  6231| 				}
  6232| 			} else {
  6233| 				if (profiler_callback_is_enabled (enabled_keywords, METHOD_INSTRUMENTATION_KEYWORD)) {
  6234| 					mono_profiler_set_call_instrumentation_filter_callback (_ep_rt_dotnet_mono_profiler_provider, NULL);
  6235| 				}
  6236| 			}
  6237| 		}
  6238| 		if (match_any_keywords) {
  6239| 			bool request_heap_collect = false;
  6240| 			if (profiler_callback_is_enabled (match_any_keywords, GC_HEAP_COLLECT_KEYWORD)) {
  6241| 				if (mono_profiler_gc_can_collect_heap () && !profiler_callback_is_enabled (enabled_keywords, GC_HEAP_COLLECT_KEYWORD))
  6242| 					request_heap_collect = true;
  6243| 			}
  6244| 			if (filter_data) {
  6245| 				if (mono_profiler_provider_param_contains_heap_collect_ondemand (filter_data) && !mono_profiler_remove_provider_param (filter_data)) {
  6246| 					mono_profiler_add_provider_param (filter_data);
  6247| 					if (mono_profiler_gc_can_collect_heap () && profiler_callback_is_enabled (match_any_keywords, GC_HEAP_COLLECT_KEYWORD))
  6248| 						request_heap_collect = true;
  6249| 				}
  6250| 			}
  6251| 			if (request_heap_collect) {
  6252| 				mono_profiler_push_gc_heap_collect_param_request_value (filter_data);
  6253| 				mono_profiler_gc_heap_collect_requests_inc ();
  6254| 				mono_gc_finalize_notify ();
  6255| 			}
  6256| 		} else {
  6257| 			mono_profiler_free_provider_params ();
  6258| 		}
  6259| 		MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_EVENTPIPE_Context.Level = level;
  6260| 		MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_EVENTPIPE_Context.EnabledKeywordsBitmask = match_any_keywords;
  6261| 		MICROSOFT_DOTNETRUNTIME_MONO_PROFILER_PROVIDER_EVENTPIPE_Context.IsEnabled = (is_enabled == 1 ? true : false);
  6262| 	EP_LOCK_EXIT (section1)
  6263| ep_on_exit:
  6264| 	ep_rt_config_requires_lock_not_held ();
  6265| 	return;
  6266| ep_on_error:
  6267| 	ep_exit_error_handler ();
  6268| }
  6269| void
  6270| EventPipeEtwCallbackDotNETRuntimeMonoProfiler (
  6271| 	const uint8_t *source_id,
  6272| 	unsigned long is_enabled,
  6273| 	uint8_t level,
  6274| 	uint64_t match_any_keywords,
  6275| 	uint64_t match_all_keywords,
  6276| 	EventFilterDescriptor *filter_data,
  6277| 	void *callback_data)
  6278| {
  6279| 	ep_rt_spin_lock_requires_lock_not_held (&_ep_rt_mono_profiler_gc_state_lock);
  6280| 	EP_SPIN_LOCK_ENTER (&_ep_rt_mono_profiler_gc_state_lock, section1);
  6281| 		mono_profiler_ep_provider_callback (
  6282| 			source_id,
  6283| 			is_enabled,
  6284| 			level,
  6285| 			match_any_keywords,
  6286| 			match_all_keywords,
  6287| 			filter_data,
  6288| 			callback_data);
  6289| 	EP_SPIN_LOCK_EXIT (&_ep_rt_mono_profiler_gc_state_lock, section1);
  6290| ep_on_exit:
  6291| 	ep_rt_spin_lock_requires_lock_not_held (&_ep_rt_mono_profiler_gc_state_lock);
  6292| 	return;
  6293| ep_on_error:
  6294| 	ep_exit_error_handler ();
  6295| }
  6296| #endif /* ENABLE_PERFTRACING */
  6297| MONO_EMPTY_SOURCE_FILE(eventpipe_rt_mono);


# ====================================================================
# FILE: src/mono/mono/eventpipe/ep-rt-mono.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-2176 ---
     1| #ifndef __EVENTPIPE_RT_MONO_H__
     2| #define __EVENTPIPE_RT_MONO_H__
     3| #include <config.h>
     4| #ifdef ENABLE_PERFTRACING
     5| #include <eventpipe/ep-rt-config.h>
     6| #include <eventpipe/ep-thread.h>
     7| #include <eventpipe/ep-types.h>
     8| #include <eventpipe/ep-provider.h>
     9| #include <eventpipe/ep-session-provider.h>
    10| #include <glib.h>
    11| #include <mono/utils/checked-build.h>
    12| #include <mono/utils/mono-threads.h>
    13| #include <mono/utils/mono-coop-mutex.h>
    14| #include <mono/utils/mono-proclib.h>
    15| #include <mono/utils/mono-time.h>
    16| #include <mono/utils/mono-rand.h>
    17| #include <mono/utils/mono-lazy-init.h>
    18| #include <mono/utils/w32api.h>
    19| #include <mono/metadata/assembly.h>
    20| #include <mono/metadata/w32event.h>
    21| #include <mono/metadata/metadata-internals.h>
    22| #include "mono/utils/mono-logger-internals.h"
    23| #include <runtime_version.h>
    24| #include <mono/metadata/profiler.h>
    25| #undef EP_INFINITE_WAIT
    26| #define EP_INFINITE_WAIT MONO_INFINITE_WAIT
    27| #undef EP_GCX_PREEMP_ENTER
    28| #define EP_GCX_PREEMP_ENTER {
    29| #undef EP_GCX_PREEMP_EXIT
    30| #define EP_GCX_PREEMP_EXIT }
    31| #undef EP_ALWAYS_INLINE
    32| #define EP_ALWAYS_INLINE MONO_ALWAYS_INLINE
    33| #undef EP_NEVER_INLINE
    34| #define EP_NEVER_INLINE MONO_NEVER_INLINE
    35| #undef EP_ALIGN_UP
    36| #define EP_ALIGN_UP(val,align) ALIGN_TO(val,align)
    37| #ifndef EP_RT_BUILD_TYPE_FUNC_NAME
    38| #define EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, type_name, func_name) \
    39| prefix_name ## _rt_ ## type_name ## _ ## func_name
    40| #endif
    41| #define EP_RT_DEFINE_LIST_PREFIX(prefix_name, list_name, list_type, item_type) \
    42| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, alloc) (list_type *list) { ; } \
    43| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, free) (list_type *list, void (*callback)(void *)) { \
    44| 		if (list && list->list) { \
    45| 			if (callback) { \
    46| 				for (GSList *l = list->list; l; l = l->next) { \
    47| 					callback (l->data); \
    48| 				} \
    49| 			} \
    50| 			g_slist_free (list->list); \
    51| 			list->list = NULL; \
    52| 		} \
    53| 	} \
    54| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, clear) (list_type *list, void (*callback)(void *)) { \
    55| 		EP_ASSERT (list != NULL); \
    56| 		ep_rt_ ## list_name ## _free (list, callback); \
    57| 	} \
    58| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, append) (list_type *list, item_type item) { \
    59| 		EP_ASSERT (list != NULL); \
    60| 		list->list = g_slist_append (list->list, ((gpointer)(gsize)item)); \
    61| 		return list->list != NULL; \
    62| 	} \
    63| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, remove) (list_type *list, const item_type item) { \
    64| 		EP_ASSERT (list != NULL); \
    65| 		list->list = g_slist_remove (list->list, ((gconstpointer)(const gsize)item)); \
    66| 	} \
    67| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, find) (const list_type *list, const item_type item_to_find, item_type *found_item) { \
    68| 		EP_ASSERT (list != NULL && found_item != NULL); \
    69| 		GSList *found_glist_item = g_slist_find (list->list, ((gconstpointer)(const gsize)item_to_find)); \
    70| 		*found_item = (found_glist_item != NULL) ? ((item_type)(gsize)(found_glist_item->data)) : ((item_type)(gsize)NULL); \
    71| 		return *found_item != NULL; \
    72| 	} \
    73| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, is_empty) (const list_type *list) { \
    74| 		EP_ASSERT (list != NULL); \
    75| 		return list->list == NULL; \
    76| 	} \
    77| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, is_valid) (const list_type *list) { return (list != NULL && list->list == NULL); }
    78| #undef EP_RT_DEFINE_LIST
    79| #define EP_RT_DEFINE_LIST(list_name, list_type, item_type) \
    80| 	EP_RT_DEFINE_LIST_PREFIX(ep, list_name, list_type, item_type)
    81| #define EP_RT_DEFINE_LIST_ITERATOR_PREFIX(prefix_name, list_name, list_type, iterator_type, item_type) \
    82| 	static inline iterator_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, iterator_begin) (const list_type *list) { \
    83| 		EP_ASSERT (list != NULL); \
    84| 		iterator_type temp; \
    85| 		temp.iterator = list->list; \
    86| 		return temp;\
    87| 	} \
    88| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, iterator_end) (const list_type *list, const iterator_type *iterator) { \
    89| 		EP_ASSERT (list != NULL && iterator != NULL); \
    90| 		return iterator->iterator == NULL; \
    91| 	} \
    92| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, iterator_next) (iterator_type *iterator) { \
    93| 		EP_ASSERT (iterator != NULL); \
    94| 		iterator->iterator = iterator->iterator->next; \
    95| 	} \
    96| 	static inline item_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, iterator_value) (const iterator_type *iterator) { \
    97| 		EP_ASSERT (iterator != NULL); \
    98| 		return ((item_type)(gsize)(iterator->iterator->data)); \
    99| 	}
   100| #undef EP_RT_DEFINE_LIST_ITERATOR
   101| #define EP_RT_DEFINE_LIST_ITERATOR(list_name, list_type, iterator_type, item_type) \
   102| 	EP_RT_DEFINE_LIST_ITERATOR_PREFIX(ep, list_name, list_type, iterator_type, item_type)
   103| #define EP_RT_DEFINE_QUEUE_PREFIX(prefix_name, queue_name, queue_type, item_type) \
   104| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, alloc) (queue_type *queue) { queue->queue = g_queue_new (); } \
   105| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, free) (queue_type *queue) { \
   106| 		EP_ASSERT (queue != NULL); \
   107| 		g_queue_free (queue->queue); \
   108| 		queue->queue = NULL; \
   109| 	} \
   110| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, pop_head) (queue_type *queue, item_type *item) { \
   111| 		EP_ASSERT (queue != NULL && item != NULL); \
   112| 		*item = ((item_type)(gsize)g_queue_pop_head (queue->queue)); \
   113| 		return true; \
   114| 	} \
   115| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, push_head) (queue_type *queue, item_type item) { \
   116| 		EP_ASSERT (queue != NULL); \
   117| 		g_queue_push_head (queue->queue, ((gpointer)(gsize)item)); \
   118| 		return true; \
   119| 	} \
   120| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, push_tail) (queue_type *queue, item_type item) { \
   121| 		EP_ASSERT (queue != NULL); \
   122| 		g_queue_push_tail (queue->queue, ((gpointer)(gsize)item)); \
   123| 		return true; \
   124| 	} \
   125| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, is_empty) (const queue_type *queue) { \
   126| 		EP_ASSERT (queue != NULL); \
   127| 		return (g_queue_is_empty (queue->queue) == TRUE) ? true : false; \
   128| 	} \
   129| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, is_valid) (const queue_type *queue) { return (queue != NULL && queue->queue != NULL); }
   130| #undef EP_RT_DEFINE_QUEUE
   131| #define EP_RT_DEFINE_QUEUE(queue_name, queue_type, item_type) \
   132| 	EP_RT_DEFINE_QUEUE_PREFIX(ep, queue_name, queue_type, item_type)
   133| #define EP_RT_DEFINE_ARRAY_PREFIX(prefix_name, array_name, array_type, iterator_type, item_type) \
   134| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, alloc) (array_type *ep_array) { \
   135| 		EP_ASSERT (ep_array != NULL); \
   136| 		ep_array->array = g_array_new (FALSE, FALSE, (guint)sizeof (item_type)); \
   137| 	} \
   138| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, alloc_capacity) (array_type *ep_array, size_t capacity) { \
   139| 		EP_ASSERT (ep_array != NULL); \
   140| 		ep_array->array = g_array_sized_new (FALSE, FALSE, (guint)sizeof (item_type), (guint)capacity); \
   141| 	} \
   142| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, free) (array_type *ep_array) { \
   143| 		EP_ASSERT (ep_array != NULL); \
   144| 		g_array_free (ep_array->array, TRUE); \
   145| 	} \
   146| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, append) (array_type *ep_array, item_type item) { \
   147| 		EP_ASSERT (ep_array != NULL); \
   148| 		return g_array_append_val (ep_array->array, item) != NULL; \
   149| 	} \
   150| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, clear) (array_type *ep_array) { \
   151| 		EP_ASSERT (ep_array != NULL); \
   152| 		g_array_set_size (ep_array->array, 0); \
   153| 	} \
   154| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, remove) (array_type *ep_array, iterator_type *pos) { \
   155| 		EP_ASSERT (ep_array != NULL && pos != NULL); \
   156| 		EP_ASSERT (pos->index < ep_array->array->len); \
   157| 		ep_array->array = g_array_remove_index_fast (ep_array->array, pos->index); \
   158| 	} \
   159| 	static inline size_t EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, size) (const array_type *ep_array) { \
   160| 		EP_ASSERT (ep_array != NULL); \
   161| 		return ep_array->array->len; \
   162| 	} \
   163| 	static inline item_type * EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, data) (const array_type *ep_array) { \
   164| 		EP_ASSERT (ep_array != NULL); \
   165| 		return (item_type *)ep_array->array->data; \
   166| 	} \
   167| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, is_valid) (const array_type *ep_array) { return (ep_array != NULL && ep_array->array != NULL); }
   168| #define EP_RT_DEFINE_LOCAL_ARRAY_PREFIX(prefix_name, array_name, array_type, iterator_type, item_type) \
   169| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, init) (array_type *ep_array) { \
   170| 		EP_ASSERT (ep_array != NULL); \
   171| 		ep_array->array = g_array_new (FALSE, FALSE, (guint)sizeof (item_type)); \
   172| 	} \
   173| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, init_capacity) (array_type *ep_array, size_t capacity) { \
   174| 		EP_ASSERT (ep_array != NULL); \
   175| 		ep_array->array = g_array_sized_new (FALSE, FALSE, (guint)sizeof (item_type), (guint)capacity); \
   176| 	} \
   177| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, fini) (array_type *ep_array) { \
   178| 		EP_ASSERT (ep_array != NULL); \
   179| 		g_array_free (ep_array->array, TRUE); \
   180| 	}
   181| #undef EP_RT_DEFINE_ARRAY
   182| #define EP_RT_DEFINE_ARRAY(array_name, array_type, iterator_type, item_type) \
   183| 	EP_RT_DEFINE_ARRAY_PREFIX(ep, array_name, array_type, iterator_type, item_type)
   184| #undef EP_RT_DEFINE_LOCAL_ARRAY
   185| #define EP_RT_DEFINE_LOCAL_ARRAY(array_name, array_type, iterator_type, item_type) \
   186| 	EP_RT_DEFINE_LOCAL_ARRAY_PREFIX(ep, array_name, array_type, iterator_type, item_type)
   187| #define EP_RT_DEFINE_ARRAY_ITERATOR_PREFIX(prefix_name, array_name, array_type, iterator_type, item_type) \
   188| 	static inline iterator_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, iterator_begin) (const array_type *ep_array) { \
   189| 		EP_ASSERT (ep_array != NULL); \
   190| 		iterator_type temp; \
   191| 		temp.array = ep_array->array; \
   192| 		temp.index = 0; \
   193| 		return temp; \
   194| 	} \
   195| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, iterator_end) (const array_type *ep_array, const iterator_type *iterator) { \
   196| 		EP_ASSERT (ep_array != NULL && iterator != NULL && iterator->array == ep_array->array); \
   197| 		return iterator->index >= iterator->array->len; \
   198| 	} \
   199| 	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, iterator_next) (iterator_type *iterator) { \
   200| 		EP_ASSERT (iterator != NULL); \
   201| 		iterator->index++; \
   202| 	} \
   203| 	static item_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, iterator_value) (const iterator_type *iterator) { \
   204| 		EP_ASSERT (iterator != NULL); \
   205| 		return g_array_index(iterator->array, item_type, iterator->index); \
   206| 	}
   207| #define EP_RT_DEFINE_ARRAY_REVERSE_ITERATOR_PREFIX(prefix_name, array_name, array_type, iterator_type, item_type) \
   208| 	static inline iterator_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, reverse_iterator_begin) (const array_type *ep_array) { \
   209| 		EP_ASSERT (ep_array != NULL); \
   210| 		iterator_type temp; \
   211| 		temp.array = ep_array->array; \
   212| 		temp.index = ep_array->array->len - 1; \
   213| 		return temp; \
   214| 	} \
   215| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, reverse_iterator_end) (const array_type *ep_array, const iterator_type *iterator) { \
   216| 		EP_ASSERT (ep_array != NULL && iterator != NULL && iterator->array == ep_array->array); \
   217| 		return iterator->index < 0; \
   218| 	} \
   219| 	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, reverse_iterator_next) (iterator_type *iterator) { \
   220| 		EP_ASSERT (iterator != NULL && iterator->array != NULL); \
   221| 		iterator->index--; \
   222| 	} \
   223| 	static item_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, reverse_iterator_value) (const iterator_type *iterator) { \
   224| 		EP_ASSERT (iterator != NULL && iterator->array != NULL); \
   225| 		EP_ASSERT (iterator->index >= 0); \
   226| 		return g_array_index(iterator->array, item_type, iterator->index); \
   227| 	}
   228| #undef EP_RT_DEFINE_ARRAY_ITERATOR
   229| #define EP_RT_DEFINE_ARRAY_ITERATOR(array_name, array_type, iterator_type, item_type) \
   230| 	EP_RT_DEFINE_ARRAY_ITERATOR_PREFIX(ep, array_name, array_type, iterator_type, item_type)
   231| #undef EP_RT_DEFINE_ARRAY_REVERSE_ITERATOR
   232| #define EP_RT_DEFINE_ARRAY_REVERSE_ITERATOR(array_name, array_type, iterator_type, item_type) \
   233| 	EP_RT_DEFINE_ARRAY_REVERSE_ITERATOR_PREFIX(ep, array_name, array_type, iterator_type, item_type)
   234| #define EP_RT_DEFINE_HASH_MAP_BASE_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
   235| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, alloc) (hash_map_type *hash_map, ep_rt_hash_map_hash_callback_t hash_callback, ep_rt_hash_map_equal_callback_t eq_callback, void (*key_free_callback)(void *), void (*value_free_callback)(void *)) { \
   236| 		EP_ASSERT (hash_map != NULL); \
   237| 		EP_ASSERT (key_free_callback == NULL); \
   238| 		hash_map->table = g_hash_table_new_full ((GHashFunc)hash_callback, (GEqualFunc)eq_callback, (GDestroyNotify)key_free_callback, (GDestroyNotify)value_free_callback); \
   239| 	} \
   240| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, free) (hash_map_type *hash_map) { \
   241| 		EP_ASSERT (hash_map != NULL); \
   242| 		g_hash_table_destroy (hash_map->table); \
   243| 		hash_map->table = NULL; \
   244| 	} \
   245| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, add) (hash_map_type *hash_map, key_type key, value_type value) { \
   246| 		EP_ASSERT (hash_map != NULL); \
   247| 		EP_ASSERT (!g_hash_table_lookup_extended (hash_map->table, (gconstpointer)key, NULL, NULL)); \
   248| 		g_hash_table_insert (hash_map->table, (gpointer)key, ((gpointer)(gsize)value)); \
   249| 		return true; \
   250| 	} \
   251| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, remove_all) (hash_map_type *hash_map) { \
   252| 		EP_ASSERT (hash_map != NULL); \
   253| 		g_hash_table_remove_all (hash_map->table); \
   254| 	} \
   255| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, lookup) (const hash_map_type *hash_map, const key_type key, value_type *value) { \
   256| 		EP_ASSERT (hash_map != NULL && value != NULL); \
   257| 		gpointer _value = NULL; \
   258| 		bool result = (g_hash_table_lookup_extended (hash_map->table, (gconstpointer)key, NULL, &_value) == TRUE) ? true : false; \
   259| 		*value = ((value_type)(gsize)_value); \
   260| 		return result; \
   261| 	} \
   262| 	static inline uint32_t EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, count) (const hash_map_type *hash_map) { \
   263| 		EP_ASSERT (hash_map != NULL); \
   264| 		return (hash_map->table != NULL) ? g_hash_table_size (hash_map->table) : 0; \
   265| 	} \
   266| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, is_valid) (const hash_map_type *hash_map) { \
   267| 		EP_ASSERT (hash_map != NULL); \
   268| 		return (hash_map != NULL && hash_map->table != NULL); \
   269| 	}
   270| #define EP_RT_DEFINE_HASH_MAP_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
   271| 	EP_RT_DEFINE_HASH_MAP_BASE_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
   272| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, add_or_replace) (hash_map_type *hash_map, key_type key, value_type value) { \
   273| 		EP_ASSERT (hash_map != NULL); \
   274| 		g_hash_table_replace (hash_map->table, (gpointer)key, ((gpointer)(gsize)value)); \
   275| 		return true; \
   276| 	}
   277| #define EP_RT_DEFINE_HASH_MAP_REMOVE_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
   278| 	EP_RT_DEFINE_HASH_MAP_BASE_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
   279| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, remove) (hash_map_type *hash_map, const key_type key) { \
   280| 		EP_ASSERT (hash_map != NULL); \
   281| 		g_hash_table_remove (hash_map->table, (gconstpointer)key); \
   282| 	}
   283| #undef EP_RT_DEFINE_HASH_MAP
   284| #define EP_RT_DEFINE_HASH_MAP(hash_map_name, hash_map_type, key_type, value_type) \
   285| 	EP_RT_DEFINE_HASH_MAP_PREFIX(ep, hash_map_name, hash_map_type, key_type, value_type)
   286| #undef EP_RT_DEFINE_HASH_MAP_REMOVE
   287| #define EP_RT_DEFINE_HASH_MAP_REMOVE(hash_map_name, hash_map_type, key_type, value_type) \
   288| 	EP_RT_DEFINE_HASH_MAP_REMOVE_PREFIX(ep, hash_map_name, hash_map_type, key_type, value_type)
   289| #define EP_RT_DEFINE_HASH_MAP_ITERATOR_PREFIX(prefix_name, hash_map_name, hash_map_type, iterator_type, key_type, value_type) \
   290| 	static inline iterator_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_begin) (const hash_map_type *hash_map) { \
   291| 		EP_ASSERT (hash_map != NULL); \
   292| 		iterator_type temp; \
   293| 		g_hash_table_iter_init (&temp.iterator, hash_map->table); \
   294| 		if (hash_map->table && g_hash_table_size (hash_map->table) > 0) \
   295| 			temp.end = !g_hash_table_iter_next (&temp.iterator, &temp.key, &temp.value); \
   296| 		else \
   297| 			temp.end = true; \
   298| 		return temp; \
   299| 	} \
   300| 	static inline bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_end) (const hash_map_type *hash_map, const iterator_type *iterator) { \
   301| 		EP_ASSERT (hash_map != NULL && iterator != NULL); \
   302| 		return iterator->end; \
   303| 	} \
   304| 	static inline void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_next) (iterator_type *iterator) { \
   305| 		EP_ASSERT (iterator != NULL); \
   306| 		iterator->end = !g_hash_table_iter_next (&iterator->iterator, &iterator->key, &iterator->value); \
   307| 	} \
   308| 	static inline key_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_key) (const iterator_type *iterator) { \
   309| 		EP_ASSERT (iterator != NULL); \
   310| 		return ((key_type)(gsize)iterator->key); \
   311| 	} \
   312| 	static inline value_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_value) (const iterator_type *iterator) { \
   313| 		EP_ASSERT (iterator != NULL); \
   314| 		return ((value_type)(gsize)iterator->value); \
   315| 	}
   316| #undef EP_RT_DEFINE_HASH_MAP_ITERATOR
   317| #define EP_RT_DEFINE_HASH_MAP_ITERATOR(hash_map_name, hash_map_type, iterator_type, key_type, value_type) \
   318| 	EP_RT_DEFINE_HASH_MAP_ITERATOR_PREFIX(ep, hash_map_name, hash_map_type, iterator_type, key_type, value_type)
   319| extern char *_ep_rt_mono_os_cmd_line;
   320| extern mono_lazy_init_t _ep_rt_mono_os_cmd_line_init;
   321| extern char *_ep_rt_mono_managed_cmd_line;
   322| extern mono_lazy_init_t _ep_rt_mono_managed_cmd_line_init;
   323| extern ep_rt_spin_lock_handle_t _ep_rt_mono_config_lock;
   324| extern char * ep_rt_mono_get_managed_cmd_line (void);
   325| extern char * ep_rt_mono_get_os_cmd_line (void);
   326| extern ep_rt_file_handle_t ep_rt_mono_file_open_write (const ep_char8_t *path);
   327| extern bool ep_rt_mono_file_close (ep_rt_file_handle_t handle);
   328| extern bool ep_rt_mono_file_write (ep_rt_file_handle_t handle, const uint8_t *buffer, uint32_t numbytes, uint32_t *byteswritten);
   329| extern void * ep_rt_mono_thread_attach (bool background_thread);
   330| extern void * ep_rt_mono_thread_attach_2 (bool background_thread, EventPipeThreadType thread_type);
   331| extern void ep_rt_mono_thread_detach (void);
   332| extern void ep_rt_mono_init (void);
   333| extern void ep_rt_mono_init_finish (void);
   334| extern void ep_rt_mono_fini (void);
   335| extern bool ep_rt_mono_walk_managed_stack_for_thread (ep_rt_thread_handle_t thread, EventPipeStackContents *stack_contents);
   336| extern bool ep_rt_mono_method_get_simple_assembly_name (ep_rt_method_desc_t *method, ep_char8_t *name, size_t name_len);
   337| extern bool ep_rt_mono_method_get_full_name (ep_rt_method_desc_t *method, ep_char8_t *name, size_t name_len);
   338| extern void ep_rt_mono_provider_config_init (EventPipeProviderConfiguration *provider_config);
   339| extern void ep_rt_mono_init_providers_and_events (void);
   340| extern bool ep_rt_mono_providers_validate_all_disabled (void);
   341| extern bool ep_rt_mono_sample_profiler_write_sampling_event_for_threads (ep_rt_thread_handle_t sampling_thread, EventPipeEvent *sampling_event);
   342| extern bool ep_rt_mono_rand_try_get_bytes (uint8_t *buffer,size_t buffer_size);
   343| extern void ep_rt_mono_execute_rundown (ep_rt_execution_checkpoint_array_t *execution_checkpoints);
   344| extern int64_t ep_rt_mono_perf_counter_query (void);
   345| extern int64_t ep_rt_mono_perf_frequency_query (void);
   346| extern void ep_rt_mono_system_time_get (EventPipeSystemTime *system_time);
   347| extern int64_t ep_rt_mono_system_timestamp_get (void);
   348| extern void ep_rt_mono_os_environment_get_utf16 (ep_rt_env_array_utf16_t *env_array);
   349| extern MonoNativeTlsKey _ep_rt_mono_thread_holder_tls_id;
   350| extern EventPipeThread * ep_rt_mono_thread_get_or_create (void);
   351| extern uint32_t ep_stack_hash_key_hash (const void *key);
   352| extern bool ep_stack_hash_key_equal (const void *key1, const void *key2);
   353| static
   354| inline
   355| char *
   356| os_command_line_get (void)
   357| {
   358| 	return ep_rt_mono_get_os_cmd_line ();
   359| }
   360| static
   361| inline
   362| char **
   363| os_command_line_get_ref (void)
   364| {
   365| 	return &_ep_rt_mono_os_cmd_line;
   366| }
   367| static
   368| inline
   369| mono_lazy_init_t *
   370| os_command_line_get_init (void)
   371| {
   372| 	return &_ep_rt_mono_os_cmd_line_init;
   373| }
   374| static
   375| inline
   376| void
   377| os_command_line_lazy_init (void)
   378| {
   379| 	if (!*os_command_line_get_ref ())
   380| 		*os_command_line_get_ref () = os_command_line_get ();
   381| }
   382| static
   383| inline
   384| void
   385| os_command_line_lazy_clean (void)
   386| {
   387| 	g_free (*os_command_line_get_ref ());
   388| 	*os_command_line_get_ref () = NULL;
   389| }
   390| static
   391| inline
   392| char *
   393| managed_command_line_get (void)
   394| {
   395| 	return ep_rt_mono_get_managed_cmd_line ();
   396| }
   397| static
   398| inline
   399| char **
   400| managed_command_line_get_ref (void)
   401| {
   402| 	return &_ep_rt_mono_managed_cmd_line;
   403| }
   404| static
   405| inline
   406| mono_lazy_init_t *
   407| managed_command_line_get_init (void)
   408| {
   409| 	return &_ep_rt_mono_managed_cmd_line_init;
   410| }
   411| static
   412| inline
   413| void
   414| managed_command_line_lazy_init (void)
   415| {
   416| 	if (!*managed_command_line_get_ref ())
   417| 		*managed_command_line_get_ref () = managed_command_line_get ();
   418| }
   419| static
   420| inline
   421| void
   422| managed_command_line_lazy_clean (void)
   423| {
   424| 	g_free (*managed_command_line_get_ref ());
   425| 	*managed_command_line_get_ref () = NULL;
   426| }
   427| static
   428| inline
   429| ep_rt_spin_lock_handle_t *
   430| ep_rt_mono_config_lock_get (void)
   431| {
   432| 	return &_ep_rt_mono_config_lock;
   433| }
   434| /*
   435| * Helpers
   436| */
   437| static
   438| inline
   439| EventPipeThreadHolder *
   440| thread_holder_alloc_func (void)
   441| {
   442| 	EventPipeThreadHolder *instance = ep_thread_holder_alloc (ep_thread_alloc());
   443| 	if (instance)
   444| 		ep_thread_register (ep_thread_holder_get_thread (instance));
   445| 	return instance;
   446| }
   447| static
   448| inline
   449| void
   450| thread_holder_free_func (EventPipeThreadHolder * thread_holder)
   451| {
   452| 	if (thread_holder) {
   453| 		ep_thread_unregister (ep_thread_holder_get_thread (thread_holder));
   454| 		ep_thread_holder_free (thread_holder);
   455| 	}
   456| }
   457| static
   458| inline
   459| MonoNativeThreadId
   460| ep_rt_mono_native_thread_id_get (void)
   461| {
   462| 	return mono_native_thread_id_get ();
   463| }
   464| static
   465| inline
   466| gboolean
   467| ep_rt_mono_native_thread_id_equals (MonoNativeThreadId id1, MonoNativeThreadId id2)
   468| {
   469| 	return mono_native_thread_id_equals (id1, id2);
   470| }
   471| static
   472| inline
   473| void
   474| ep_rt_mono_thread_setup (bool background_thread)
   475| {
   476| 	ep_rt_mono_thread_attach (background_thread);
   477| }
   478| static
   479| inline
   480| void
   481| ep_rt_mono_thread_setup_2 (bool background_thread, EventPipeThreadType thread_type)
   482| {
   483| 	ep_rt_mono_thread_attach_2 (background_thread, thread_type);
   484| }
   485| static
   486| inline
   487| void
   488| ep_rt_mono_thread_teardown (void)
   489| {
   490| 	ep_rt_mono_thread_detach ();
   491| }
   492| /*
   493|  * Little-Endian Conversion.
   494|  */
   495| static
   496| EP_ALWAYS_INLINE
   497| uint16_t
   498| ep_rt_val_uint16_t (uint16_t value)
   499| {
   500| 	return GUINT16_TO_LE (value);
   501| }
   502| static
   503| EP_ALWAYS_INLINE
   504| uint32_t
   505| ep_rt_val_uint32_t (uint32_t value)
   506| {
   507| 	return GUINT32_TO_LE (value);
   508| }
   509| static
   510| EP_ALWAYS_INLINE
   511| uint64_t
   512| ep_rt_val_uint64_t (uint64_t value)
   513| {
   514| 	return GUINT64_TO_LE (value);
   515| }
   516| static
   517| EP_ALWAYS_INLINE
   518| int16_t
   519| ep_rt_val_int16_t (int16_t value)
   520| {
   521| 	return (int16_t)GUINT16_TO_LE ((uint16_t)value);
   522| }
   523| static
   524| EP_ALWAYS_INLINE
   525| int32_t
   526| ep_rt_val_int32_t (int32_t value)
   527| {
   528| 	return (int32_t)GUINT32_TO_LE ((uint32_t)value);
   529| }
   530| static
   531| EP_ALWAYS_INLINE
   532| int64_t
   533| ep_rt_val_int64_t (int64_t value)
   534| {
   535| 	return (int64_t)GUINT64_TO_LE ((uint64_t)value);
   536| }
   537| static
   538| EP_ALWAYS_INLINE
   539| uintptr_t
   540| ep_rt_val_uintptr_t (uintptr_t value)
   541| {
   542| #if SIZEOF_VOID_P == 4
   543| 	return (uintptr_t)GUINT32_TO_LE ((uint32_t)value);
   544| #else
   545| 	return (uintptr_t)GUINT64_TO_LE ((uint64_t)value);
   546| #endif
   547| }
   548| /*
   549| * Atomics.
   550| */
   551| static
   552| inline
   553| uint32_t
   554| ep_rt_atomic_inc_uint32_t (volatile uint32_t *value)
   555| {
   556| 	return (uint32_t)mono_atomic_inc_i32 ((volatile gint32 *)value);
   557| }
   558| static
   559| inline
   560| uint32_t
   561| ep_rt_atomic_dec_uint32_t (volatile uint32_t *value)
   562| {
   563| 	return (uint32_t)mono_atomic_dec_i32 ((volatile gint32 *)value);
   564| }
   565| static
   566| inline
   567| int32_t
   568| ep_rt_atomic_inc_int32_t (volatile int32_t *value)
   569| {
   570| 	return (int32_t)mono_atomic_inc_i32 ((volatile gint32 *)value);
   571| }
   572| static
   573| inline
   574| int32_t
   575| ep_rt_atomic_dec_int32_t (volatile int32_t *value)
   576| {
   577| 	return (int32_t)mono_atomic_dec_i32 ((volatile gint32 *)value);
   578| }
   579| static
   580| inline
   581| int64_t
   582| ep_rt_atomic_inc_int64_t (volatile int64_t *value)
   583| {
   584| 	return (int64_t)mono_atomic_inc_i64 ((volatile gint64 *)value);
   585| }
   586| static
   587| inline
   588| int64_t
   589| ep_rt_atomic_dec_int64_t (volatile int64_t *value)
   590| {
   591| 	return (int64_t)mono_atomic_dec_i64 ((volatile gint64 *)value);
   592| }
   593| static
   594| inline
   595| size_t
   596| ep_rt_atomic_compare_exchange_size_t (volatile size_t *target, size_t expected, size_t value)
   597| {
   598| #if SIZEOF_SIZE_T == 8
   599| 	return (size_t)(mono_atomic_cas_i64((volatile gint64*)(target), (gint64)(value), (gint64)(expected)));
   600| #else
   601| 	return (size_t)(mono_atomic_cas_i32 ((volatile gint32 *)(target), (gint32)(value), (gint32)(expected)));
   602| #endif
   603| }
   604| static
   605| inline
   606| ep_char8_t *
   607| ep_rt_atomic_compare_exchange_utf8_string (ep_char8_t *volatile *target, ep_char8_t *expected, ep_char8_t *value)
   608| {
   609| 	return (ep_char8_t *)mono_atomic_cas_ptr ((volatile gpointer *)target, (gpointer)value, (gpointer)expected);
   610| }
   611| /*
   612|  * EventPipe.
   613|  */
   614| EP_RT_DEFINE_ARRAY (session_id_array, ep_rt_session_id_array_t, ep_rt_session_id_array_iterator_t, EventPipeSessionID)
   615| EP_RT_DEFINE_ARRAY_ITERATOR (session_id_array, ep_rt_session_id_array_t, ep_rt_session_id_array_iterator_t, EventPipeSessionID)
   616| EP_RT_DEFINE_ARRAY (execution_checkpoint_array, ep_rt_execution_checkpoint_array_t, ep_rt_execution_checkpoint_array_iterator_t, EventPipeExecutionCheckpoint *)
   617| EP_RT_DEFINE_ARRAY_ITERATOR (execution_checkpoint_array, ep_rt_execution_checkpoint_array_t, ep_rt_execution_checkpoint_array_iterator_t, EventPipeExecutionCheckpoint *)
   618| static
   619| inline
   620| void
   621| ep_rt_init (void)
   622| {
   623| 	ep_rt_mono_init ();
   624| 	ep_rt_spin_lock_alloc (ep_rt_mono_config_lock_get ());
   625| }
   626| static
   627| inline
   628| void
   629| ep_rt_init_finish (void)
   630| {
   631| 	ep_rt_mono_init_finish ();
   632| }
   633| static
   634| inline
   635| void
   636| ep_rt_shutdown (void)
   637| {
   638| 	mono_lazy_cleanup (managed_command_line_get_init (), managed_command_line_lazy_clean);
   639| 	mono_lazy_cleanup (os_command_line_get_init (), os_command_line_lazy_clean);
   640| 	ep_rt_spin_lock_free (ep_rt_mono_config_lock_get ());
   641| 	ep_rt_mono_fini ();
   642| }
   643| static
   644| inline
   645| bool
   646| ep_rt_config_acquire (void)
   647| {
   648| 	return ep_rt_spin_lock_acquire (ep_rt_mono_config_lock_get ());
   649| }
   650| static
   651| inline
   652| bool
   653| ep_rt_config_release (void)
   654| {
   655| 	return ep_rt_spin_lock_release (ep_rt_mono_config_lock_get ());
   656| }
   657| #ifdef EP_CHECKED_BUILD
   658| static
   659| inline
   660| void
   661| ep_rt_config_requires_lock_held (void)
   662| {
   663| 	ep_rt_spin_lock_requires_lock_held (ep_rt_mono_config_lock_get ());
   664| }
   665| static
   666| inline
   667| void
   668| ep_rt_config_requires_lock_not_held (void)
   669| {
   670| 	ep_rt_spin_lock_requires_lock_not_held (ep_rt_mono_config_lock_get ());
   671| }
   672| #endif
   673| static
   674| inline
   675| bool
   676| ep_rt_walk_managed_stack_for_thread (
   677| 	ep_rt_thread_handle_t thread,
   678| 	EventPipeStackContents *stack_contents)
   679| {
   680| 	return ep_rt_mono_walk_managed_stack_for_thread (thread, stack_contents);
   681| }
   682| static
   683| inline
   684| bool
   685| ep_rt_method_get_simple_assembly_name (
   686| 	ep_rt_method_desc_t *method,
   687| 	ep_char8_t *name,
   688| 	size_t name_len)
   689| {
   690| 	return ep_rt_mono_method_get_simple_assembly_name (method, name, name_len);
   691| }
   692| static
   693| inline
   694| bool
   695| ep_rt_method_get_full_name (
   696| 	ep_rt_method_desc_t *method,
   697| 	ep_char8_t *name,
   698| 	size_t name_len)
   699| {
   700| 	return ep_rt_mono_method_get_full_name (method, name, name_len);
   701| }
   702| static
   703| inline
   704| void
   705| ep_rt_provider_config_init (EventPipeProviderConfiguration *provider_config)
   706| {
   707| 	ep_rt_mono_provider_config_init (provider_config);
   708| }
   709| static
   710| inline
   711| void
   712| ep_rt_init_providers_and_events (void)
   713| {
   714| 	ep_rt_mono_init_providers_and_events ();
   715| }
   716| static
   717| inline
   718| bool
   719| ep_rt_providers_validate_all_disabled (void)
   720| {
   721| 	return ep_rt_mono_providers_validate_all_disabled ();
   722| }
   723| static
   724| inline
   725| void
   726| ep_rt_prepare_provider_invoke_callback (EventPipeProviderCallbackData *provider_callback_data)
   727| {
   728| 	;
   729| }
   730| static
   731| inline
   732| void
   733| ep_rt_provider_invoke_callback (
   734| 	EventPipeCallback callback_func,
   735| 	const uint8_t *source_id,
   736| 	unsigned long is_enabled,
   737| 	uint8_t level,
   738| 	uint64_t match_any_keywords,
   739| 	uint64_t match_all_keywords,
   740| 	EventFilterDescriptor *filter_data,
   741| 	void *callback_data)
   742| {
   743| 	EP_ASSERT (callback_func != NULL);
   744| 	(*callback_func)(
   745| 		source_id,
   746| 		is_enabled,
   747| 		level,
   748| 		match_any_keywords,
   749| 		match_all_keywords,
   750| 		filter_data,
   751| 		callback_data);
   752| }
   753| /*
   754|  * EventPipeBuffer.
   755|  */
   756| EP_RT_DEFINE_ARRAY (buffer_array, ep_rt_buffer_array_t, ep_rt_buffer_array_iterator_t, EventPipeBuffer *)
   757| EP_RT_DEFINE_LOCAL_ARRAY (buffer_array, ep_rt_buffer_array_t, ep_rt_buffer_array_iterator_t, EventPipeBuffer *)
   758| EP_RT_DEFINE_ARRAY_ITERATOR (buffer_array, ep_rt_buffer_array_t, ep_rt_buffer_array_iterator_t, EventPipeBuffer *)
   759| #undef EP_RT_DECLARE_LOCAL_BUFFER_ARRAY
   760| #define EP_RT_DECLARE_LOCAL_BUFFER_ARRAY(var_name) \
   761| 	ep_rt_buffer_array_t var_name
   762| /*
   763|  * EventPipeBufferList.
   764|  */
   765| EP_RT_DEFINE_ARRAY (buffer_list_array, ep_rt_buffer_list_array_t, ep_rt_buffer_list_array_iterator_t, EventPipeBufferList *)
   766| EP_RT_DEFINE_LOCAL_ARRAY (buffer_list_array, ep_rt_buffer_list_array_t, ep_rt_buffer_list_array_iterator_t, EventPipeBufferList *)
   767| EP_RT_DEFINE_ARRAY_ITERATOR (buffer_list_array, ep_rt_buffer_list_array_t, ep_rt_buffer_list_array_iterator_t, EventPipeBufferList *)
   768| #undef EP_RT_DECLARE_LOCAL_BUFFER_LIST_ARRAY
   769| #define EP_RT_DECLARE_LOCAL_BUFFER_LIST_ARRAY(var_name) \
   770| 	ep_rt_buffer_list_array_t var_name
   771| /*
   772|  * EventPipeEvent.
   773|  */
   774| EP_RT_DEFINE_LIST (event_list, ep_rt_event_list_t, EventPipeEvent *)
   775| EP_RT_DEFINE_LIST_ITERATOR (event_list, ep_rt_event_list_t, ep_rt_event_list_iterator_t, EventPipeEvent *)
   776| /*
   777|  * EventPipeFile.
   778|  */
   779| EP_RT_DEFINE_HASH_MAP_REMOVE(metadata_labels_hash, ep_rt_metadata_labels_hash_map_t, EventPipeEvent *, uint32_t)
   780| EP_RT_DEFINE_HASH_MAP(stack_hash, ep_rt_stack_hash_map_t, StackHashKey *, StackHashEntry *)
   781| EP_RT_DEFINE_HASH_MAP_ITERATOR(stack_hash, ep_rt_stack_hash_map_t, ep_rt_stack_hash_map_iterator_t, StackHashKey *, StackHashEntry *)
   782| #ifdef EP_RT_USE_CUSTOM_HASH_MAP_CALLBACKS
   783| static
   784| inline
   785| guint
   786| ep_rt_stack_hash_key_hash (gconstpointer key)
   787| {
   788| 	return (guint)ep_stack_hash_key_hash (key);
   789| }
   790| static
   791| inline
   792| gboolean
   793| ep_rt_stack_hash_key_equal (gconstpointer key1, gconstpointer key2)
   794| {
   795| 	return !!ep_stack_hash_key_equal (key1, key2);
   796| }
   797| #endif
   798| /*
   799|  * EventPipeProvider.
   800|  */
   801| EP_RT_DEFINE_LIST (provider_list, ep_rt_provider_list_t, EventPipeProvider *)
   802| EP_RT_DEFINE_LIST_ITERATOR (provider_list, ep_rt_provider_list_t, ep_rt_provider_list_iterator_t, EventPipeProvider *)
   803| EP_RT_DEFINE_QUEUE (provider_callback_data_queue, ep_rt_provider_callback_data_queue_t, EventPipeProviderCallbackData *)
   804| static
   805| inline
   806| int
   807| compare_provider_name (
   808| 	gconstpointer a,
   809| 	gconstpointer b)
   810| {
   811| 	return (a) ? ep_rt_utf8_string_compare (ep_provider_get_provider_name ((EventPipeProvider *)a), (const ep_char8_t *)b) : 1;
   812| }
   813| static
   814| inline
   815| EventPipeProvider *
   816| ep_rt_provider_list_find_by_name (
   817| 	const ep_rt_provider_list_t *list,
   818| 	const ep_char8_t *name)
   819| {
   820| 	GSList *item = g_slist_find_custom (list->list, name, compare_provider_name);
   821| 	return (item != NULL) ? (EventPipeProvider *)item->data : NULL;
   822| }
   823| /*
   824|  * EventPipeProviderConfiguration.
   825|  */
   826| EP_RT_DEFINE_ARRAY (provider_config_array, ep_rt_provider_config_array_t, ep_rt_provider_config_array_iterator_t, EventPipeProviderConfiguration)
   827| EP_RT_DEFINE_ARRAY_ITERATOR (provider_config_array, ep_rt_provider_config_array_t, ep_rt_provider_config_array_iterator_t, EventPipeProviderConfiguration)
   828| static
   829| inline
   830| bool
   831| ep_rt_config_value_get_enable (void)
   832| {
   833| 	bool enable = false;
   834| 	gchar *value = g_getenv ("DOTNET_EnableEventPipe");
   835| 	if (!value)
   836| 		value = g_getenv ("COMPlus_EnableEventPipe");
   837| 	if (value && atoi (value) == 1)
   838| 		enable = true;
   839| 	g_free (value);
   840| 	return enable;
   841| }
   842| static
   843| inline
   844| ep_char8_t *
   845| ep_rt_config_value_get_config (void)
   846| {
   847| 	gchar *value = g_getenv ("DOTNET_EventPipeConfig");
   848| 	if (!value)
   849| 		value = g_getenv ("COMPlus_EventPipeConfig");
   850| 	return (ep_char8_t *)value;
   851| }
   852| static
   853| inline
   854| ep_char8_t *
   855| ep_rt_config_value_get_output_path (void)
   856| {
   857| 	gchar *value = g_getenv ("DOTNET_EventPipeOutputPath");
   858| 	if (!value)
   859| 		value = g_getenv ("COMPlus_EventPipeOutputPath");
   860| 	return (ep_char8_t *)value;
   861| }
   862| static
   863| inline
   864| uint32_t
   865| ep_rt_config_value_get_circular_mb (void)
   866| {
   867| 	uint32_t circular_mb = 0;
   868| 	gchar *value = g_getenv ("DOTNET_EventPipeCircularMB");
   869| 	if (!value)
   870| 		value = g_getenv ("COMPlus_EventPipeCircularMB");
   871| 	if (value)
   872| 		circular_mb = strtoul (value, NULL, 10);
   873| 	g_free (value);
   874| 	return circular_mb;
   875| }
   876| static
   877| inline
   878| bool
   879| ep_rt_config_value_get_output_streaming (void)
   880| {
   881| 	bool enable = false;
   882| 	gchar *value = g_getenv ("DOTNET_EventPipeOutputStreaming");
   883| 	if (!value)
   884| 		value = g_getenv ("COMPlus_EventPipeOutputStreaming");
   885| 	if (value && atoi (value) == 1)
   886| 		enable = true;
   887| 	g_free (value);
   888| 	return enable;
   889| }
   890| static
   891| inline
   892| bool
   893| ep_rt_config_value_get_use_portable_thread_pool (void)
   894| {
   895| 	return true;
   896| }
   897| static
   898| inline
   899| uint32_t
   900| ep_rt_config_value_get_rundown (void)
   901| {
   902| 	uint32_t value_uint32_t = 1;
   903| 	gchar *value = g_getenv ("DOTNET_EventPipeRundown");
   904| 	if (!value)
   905| 		value = g_getenv ("COMPlus_EventPipeRundown");
   906| 	if (value)
   907| 		value_uint32_t = (uint32_t)atoi (value);
   908| 	g_free (value);
   909| 	return value_uint32_t;
   910| }
   911| static
   912| inline
   913| bool
   914| ep_rt_config_value_get_enable_stackwalk (void)
   915| {
   916| 	uint32_t value_uint32_t = 1;
   917| 	gchar *value = g_getenv ("DOTNET_EventPipeEnableStackwalk");
   918| 	if (!value)
   919| 		value = g_getenv ("COMPlus_EventPipeEnableStackwalk");
   920| 	if (value)
   921| 		value_uint32_t = (uint32_t)atoi (value);
   922| 	g_free (value);
   923| 	return value_uint32_t != 0;
   924| }
   925| /*
   926|  * EventPipeSampleProfiler.
   927|  */
   928| static
   929| void
   930| ep_rt_sample_profiler_write_sampling_event_for_threads (ep_rt_thread_handle_t sampling_thread, EventPipeEvent *sampling_event)
   931| {
   932| 	ep_rt_mono_sample_profiler_write_sampling_event_for_threads (sampling_thread, sampling_event);
   933| }
   934| static
   935| void
   936| ep_rt_notify_profiler_provider_created (EventPipeProvider *provider)
   937| {
   938| 	;
   939| }
   940| /*
   941|  * EventPipeSessionProvider.
   942|  */
   943| EP_RT_DEFINE_LIST (session_provider_list, ep_rt_session_provider_list_t, EventPipeSessionProvider *)
   944| EP_RT_DEFINE_LIST_ITERATOR (session_provider_list, ep_rt_session_provider_list_t, ep_rt_session_provider_list_iterator_t, EventPipeSessionProvider *)
   945| static
   946| inline
   947| int
   948| compare_session_provider_name (
   949| 	gconstpointer a,
   950| 	gconstpointer b)
   951| {
   952| 	return (a) ? ep_rt_utf8_string_compare (ep_session_provider_get_provider_name ((EventPipeSessionProvider *)a), (const ep_char8_t *)b) : 1;
   953| }
   954| static
   955| inline
   956| EventPipeSessionProvider *
   957| ep_rt_session_provider_list_find_by_name (
   958| 	const ep_rt_session_provider_list_t *list,
   959| 	const ep_char8_t *name)
   960| {
   961| 	GSList *item = g_slist_find_custom (list->list, name, compare_session_provider_name);
   962| 	return (item != NULL) ? (EventPipeSessionProvider *)item->data : NULL;
   963| }
   964| /*
   965|  * EventPipeSequencePoint.
   966|  */
   967| EP_RT_DEFINE_LIST (sequence_point_list, ep_rt_sequence_point_list_t, EventPipeSequencePoint *)
   968| EP_RT_DEFINE_LIST_ITERATOR (sequence_point_list, ep_rt_sequence_point_list_t, ep_rt_sequence_point_list_iterator_t, EventPipeSequencePoint *)
   969| /*
   970|  * EventPipeThread.
   971|  */
   972| EP_RT_DEFINE_LIST (thread_list, ep_rt_thread_list_t, EventPipeThread *)
   973| EP_RT_DEFINE_LIST_ITERATOR (thread_list, ep_rt_thread_list_t, ep_rt_thread_list_iterator_t, EventPipeThread *)
   974| EP_RT_DEFINE_ARRAY (thread_array, ep_rt_thread_array_t, ep_rt_thread_array_iterator_t, EventPipeThread *)
   975| EP_RT_DEFINE_LOCAL_ARRAY (thread_array, ep_rt_thread_array_t, ep_rt_thread_array_iterator_t, EventPipeThread *)
   976| EP_RT_DEFINE_ARRAY_ITERATOR (thread_array, ep_rt_thread_array_t, ep_rt_thread_array_iterator_t, EventPipeThread *)
   977| #undef EP_RT_DECLARE_LOCAL_THREAD_ARRAY
   978| #define EP_RT_DECLARE_LOCAL_THREAD_ARRAY(var_name) \
   979| 	ep_rt_thread_array_t var_name
   980| /*
   981|  * EventPipeThreadSessionState.
   982|  */
   983| EP_RT_DEFINE_LIST (thread_session_state_list, ep_rt_thread_session_state_list_t, EventPipeThreadSessionState *)
   984| EP_RT_DEFINE_LIST_ITERATOR (thread_session_state_list, ep_rt_thread_session_state_list_t, ep_rt_thread_session_state_list_iterator_t, EventPipeThreadSessionState *)
   985| EP_RT_DEFINE_ARRAY (thread_session_state_array, ep_rt_thread_session_state_array_t, ep_rt_thread_session_state_array_iterator_t, EventPipeThreadSessionState *)
   986| EP_RT_DEFINE_LOCAL_ARRAY (thread_session_state_array, ep_rt_thread_session_state_array_t, ep_rt_thread_session_state_array_iterator_t, EventPipeThreadSessionState *)
   987| EP_RT_DEFINE_ARRAY_ITERATOR (thread_session_state_array, ep_rt_thread_session_state_array_t, ep_rt_thread_session_state_array_iterator_t, EventPipeThreadSessionState *)
   988| #undef EP_RT_DECLARE_LOCAL_THREAD_SESSION_STATE_ARRAY
   989| #define EP_RT_DECLARE_LOCAL_THREAD_SESSION_STATE_ARRAY(var_name) \
   990| 	ep_rt_thread_session_state_array_t var_name
   991| /*
   992|  * Arrays.
   993|  */
   994| static
   995| inline
   996| uint8_t *
   997| ep_rt_byte_array_alloc (size_t len)
   998| {
   999| 	return g_new(uint8_t, len);
  1000| }
  1001| static
  1002| inline
  1003| void
  1004| ep_rt_byte_array_free (uint8_t *ptr)
  1005| {
  1006| 	g_free (ptr);
  1007| }
  1008| /*
  1009|  * Event.
  1010|  */
  1011| static
  1012| inline
  1013| void
  1014| ep_rt_wait_event_alloc (
  1015| 	ep_rt_wait_event_handle_t *wait_event,
  1016| 	bool manual,
  1017| 	bool initial)
  1018| {
  1019| 	EP_ASSERT (wait_event != NULL);
  1020| 	wait_event->event = mono_w32event_create (manual, initial);
  1021| }
  1022| static
  1023| inline
  1024| void
  1025| ep_rt_wait_event_free (ep_rt_wait_event_handle_t *wait_event)
  1026| {
  1027| 	if (wait_event != NULL && wait_event->event != NULL) {
  1028| 		mono_w32event_close (wait_event->event);
  1029| 		wait_event->event = NULL;
  1030| 	}
  1031| }
  1032| static
  1033| inline
  1034| bool
  1035| ep_rt_wait_event_set (ep_rt_wait_event_handle_t *wait_event)
  1036| {
  1037| 	EP_ASSERT (wait_event != NULL && wait_event->event != NULL);
  1038| 	mono_w32event_set (wait_event->event);
  1039| 	return true;
  1040| }
  1041| static
  1042| inline
  1043| int32_t
  1044| ep_rt_wait_event_wait (
  1045| 	ep_rt_wait_event_handle_t *wait_event,
  1046| 	uint32_t timeout,
  1047| 	bool alertable)
  1048| {
  1049| 	EP_ASSERT (wait_event != NULL && wait_event->event != NULL);
  1050| 	return (int32_t)mono_w32handle_wait_one (wait_event->event, timeout, alertable);
  1051| }
  1052| static
  1053| inline
  1054| EventPipeWaitHandle
  1055| ep_rt_wait_event_get_wait_handle (ep_rt_wait_event_handle_t *wait_event)
  1056| {
  1057| 	EP_ASSERT (wait_event != NULL);
  1058| 	return (EventPipeWaitHandle)wait_event->event;
  1059| }
  1060| static
  1061| inline
  1062| bool
  1063| ep_rt_wait_event_is_valid (ep_rt_wait_event_handle_t *wait_event)
  1064| {
  1065| 	if (wait_event == NULL || wait_event->event == NULL || wait_event->event == INVALID_HANDLE_VALUE)
  1066| 		return false;
  1067| 	else
  1068| 		return true;
  1069| }
  1070| /*
  1071|  * Misc.
  1072|  */
  1073| static
  1074| inline
  1075| int
  1076| ep_rt_get_last_error (void)
  1077| {
  1078| #ifdef HOST_WIN32
  1079| 	return GetLastError ();
  1080| #else
  1081| 	return errno;
  1082| #endif
  1083| }
  1084| static
  1085| inline
  1086| bool
  1087| ep_rt_process_detach (void)
  1088| {
  1089| 	return FALSE;
  1090| }
  1091| static
  1092| inline
  1093| bool
  1094| ep_rt_process_shutdown (void)
  1095| {
  1096| 	return ep_rt_process_detach ();
  1097| }
  1098| static
  1099| inline
  1100| void
  1101| ep_rt_create_activity_id (
  1102| 	uint8_t *activity_id,
  1103| 	uint32_t activity_id_len)
  1104| {
  1105| 	EP_ASSERT (activity_id != NULL);
  1106| 	EP_ASSERT (activity_id_len == EP_ACTIVITY_ID_SIZE);
  1107| 	ep_rt_mono_rand_try_get_bytes ((guchar *)activity_id, EP_ACTIVITY_ID_SIZE);
  1108| 	const uint16_t version_mask = 0xF000;
  1109| 	const uint16_t random_guid_version = 0x4000;
  1110| 	const uint8_t clock_seq_hi_and_reserved_mask = 0xC0;
  1111| 	const uint8_t clock_seq_hi_and_reserved_value = 0x80;
  1112| 	uint8_t *activity_id_c = activity_id + sizeof (uint32_t) + sizeof (uint16_t);
  1113| 	uint8_t *activity_id_d = activity_id + sizeof (uint32_t) + sizeof (uint16_t) + sizeof (uint16_t);
  1114| 	uint16_t c;
  1115| 	memcpy (&c, activity_id_c, sizeof (c));
  1116| 	uint8_t d;
  1117| 	memcpy (&d, activity_id_d, sizeof (d));
  1118| 	c = ((c & ~version_mask) | random_guid_version);
  1119| 	d = ((d & ~clock_seq_hi_and_reserved_mask) | clock_seq_hi_and_reserved_value);
  1120| 	memcpy (activity_id_c, &c, sizeof (c));
  1121| 	memcpy (activity_id_d, &d, sizeof (d));
  1122| }
  1123| static
  1124| inline
  1125| bool
  1126| ep_rt_is_running (void)
  1127| {
  1128| 	return !ep_rt_process_detach ();
  1129| }
  1130| static
  1131| inline
  1132| void
  1133| ep_rt_execute_rundown (ep_rt_execution_checkpoint_array_t *execution_checkpoints)
  1134| {
  1135| 	if (ep_rt_config_value_get_rundown () > 0) {
  1136| 		if (/*is_running &&*/ !ep_rt_process_shutdown ()) {
  1137| 			ep_rt_mono_execute_rundown (execution_checkpoints);
  1138| 		}
  1139| 	}
  1140| }
  1141| /*
  1142|  * Objects.
  1143|  */
  1144| #undef ep_rt_object_alloc
  1145| #define ep_rt_object_alloc(obj_type) (g_new0 (obj_type, 1))
  1146| #undef ep_rt_object_array_alloc
  1147| #define ep_rt_object_array_alloc(obj_type,size) (g_new0 (obj_type, size))
  1148| static
  1149| inline
  1150| void
  1151| ep_rt_object_array_free (void *ptr)
  1152| {
  1153| 	g_free (ptr);
  1154| }
  1155| static
  1156| inline
  1157| void
  1158| ep_rt_object_free (void *ptr)
  1159| {
  1160| 	g_free (ptr);
  1161| }
  1162| /*
  1163|  * PAL.
  1164|  */
  1165| typedef struct _rt_mono_thread_params_internal_t {
  1166| 	ep_rt_thread_params_t thread_params;
  1167| 	bool background_thread;
  1168| } rt_mono_thread_params_internal_t;
  1169| #undef EP_RT_DEFINE_THREAD_FUNC
  1170| #define EP_RT_DEFINE_THREAD_FUNC(name) static mono_thread_start_return_t WINAPI name (gpointer data)
  1171| EP_RT_DEFINE_THREAD_FUNC (ep_rt_thread_mono_start_func)
  1172| {
  1173| 	rt_mono_thread_params_internal_t *thread_params = (rt_mono_thread_params_internal_t *)data;
  1174| 	ep_rt_mono_thread_setup_2 (thread_params->background_thread, thread_params->thread_params.thread_type);
  1175| 	thread_params->thread_params.thread = ep_rt_thread_get_handle ();
  1176| 	mono_thread_start_return_t result = thread_params->thread_params.thread_func (thread_params);
  1177| 	ep_rt_mono_thread_teardown ();
  1178| 	g_free (thread_params);
  1179| 	return result;
  1180| }
  1181| static
  1182| inline
  1183| bool
  1184| ep_rt_thread_create (
  1185| 	void *thread_func,
  1186| 	void *params,
  1187| 	EventPipeThreadType thread_type,
  1188| 	void *id)
  1189| {
  1190| 	rt_mono_thread_params_internal_t *thread_params = g_new0 (rt_mono_thread_params_internal_t, 1);
  1191| 	if (thread_params) {
  1192| 		thread_params->thread_params.thread_type = thread_type;
  1193| 		thread_params->thread_params.thread_func = (ep_rt_thread_start_func)thread_func;
  1194| 		thread_params->thread_params.thread_params = params;
  1195| 		thread_params->background_thread = true;
  1196| 		return (mono_thread_platform_create_thread (ep_rt_thread_mono_start_func, thread_params, NULL, (ep_rt_thread_id_t *)id) == TRUE) ? true : false;
  1197| 	}
  1198| 	return false;
  1199| }
  1200| static
  1201| inline
  1202| void
  1203| ep_rt_thread_sleep (uint64_t ns)
  1204| {
  1205| 	MONO_REQ_GC_UNSAFE_MODE;
  1206| 	if (ns == 0) {
  1207| 		mono_thread_info_yield ();
  1208| 	} else {
  1209| 		MONO_ENTER_GC_SAFE;
  1210| 		g_usleep ((gulong)(ns / 1000));
  1211| 		MONO_EXIT_GC_SAFE;
  1212| 	}
  1213| }
  1214| static
  1215| inline
  1216| uint32_t
  1217| ep_rt_current_process_get_id (void)
  1218| {
  1219| 	return (uint32_t)mono_process_current_pid ();
  1220| }
  1221| static
  1222| inline
  1223| uint32_t
  1224| ep_rt_current_processor_get_number (void)
  1225| {
  1226| 	return 0xFFFFFFFF;
  1227| }
  1228| static
  1229| inline
  1230| uint32_t
  1231| ep_rt_processors_get_count (void)
  1232| {
  1233| 	return (uint32_t)mono_cpu_count ();
  1234| }
  1235| static
  1236| inline
  1237| ep_rt_thread_id_t
  1238| ep_rt_current_thread_get_id (void)
  1239| {
  1240| 	return mono_native_thread_id_get ();
  1241| }
  1242| static
  1243| inline
  1244| int64_t
  1245| ep_rt_perf_counter_query (void)
  1246| {
  1247| 	return ep_rt_mono_perf_counter_query ();
  1248| }
  1249| static
  1250| inline
  1251| int64_t
  1252| ep_rt_perf_frequency_query (void)
  1253| {
  1254| 	return ep_rt_mono_perf_frequency_query ();
  1255| }
  1256| static
  1257| inline
  1258| void
  1259| ep_rt_system_time_get (EventPipeSystemTime *system_time)
  1260| {
  1261| 	ep_rt_mono_system_time_get (system_time);
  1262| }
  1263| static
  1264| inline
  1265| int64_t
  1266| ep_rt_system_timestamp_get (void)
  1267| {
  1268| 	return ep_rt_mono_system_timestamp_get ();
  1269| }
  1270| static
  1271| inline
  1272| int32_t
  1273| ep_rt_system_get_alloc_granularity (void)
  1274| {
  1275| 	return (int32_t)mono_valloc_granule ();
  1276| }
  1277| static
  1278| inline
  1279| const ep_char8_t *
  1280| ep_rt_os_command_line_get (void)
  1281| {
  1282| 	if (!mono_lazy_is_initialized (os_command_line_get_init ())) {
  1283| 		char *cmd_line = os_command_line_get ();
  1284| 		if (!cmd_line)
  1285| 			return NULL;
  1286| 		g_free (cmd_line);
  1287| 	}
  1288| 	mono_lazy_initialize (os_command_line_get_init (), os_command_line_lazy_init);
  1289| 	EP_ASSERT (*os_command_line_get_ref () != NULL);
  1290| 	return *os_command_line_get_ref ();
  1291| }
  1292| static
  1293| inline
  1294| ep_rt_file_handle_t
  1295| ep_rt_file_open_write (const ep_char8_t *path)
  1296| {
  1297| 	ep_rt_file_handle_t res = ep_rt_mono_file_open_write (path);
  1298| 	return (res != INVALID_HANDLE_VALUE) ? res : NULL;
  1299| }
  1300| static
  1301| inline
  1302| bool
  1303| ep_rt_file_close (ep_rt_file_handle_t file_handle)
  1304| {
  1305| 	ep_return_false_if_nok (file_handle != NULL);
  1306| 	return ep_rt_mono_file_close (file_handle);
  1307| }
  1308| static
  1309| inline
  1310| bool
  1311| ep_rt_file_write (
  1312| 	ep_rt_file_handle_t file_handle,
  1313| 	const uint8_t *buffer,
  1314| 	uint32_t bytes_to_write,
  1315| 	uint32_t *bytes_written)
  1316| {
  1317| 	ep_return_false_if_nok (file_handle != NULL);
  1318| 	EP_ASSERT (buffer != NULL);
  1319| 	bool result = ep_rt_mono_file_write (file_handle, buffer, bytes_to_write, bytes_written);
  1320| 	if (result)
  1321| 		*bytes_written = bytes_to_write;
  1322| 	return result;
  1323| }
  1324| static
  1325| inline
  1326| uint8_t *
  1327| ep_rt_valloc0 (size_t buffer_size)
  1328| {
  1329| 	uint8_t *buffer = (uint8_t *)mono_valloc (NULL, buffer_size, MONO_MMAP_READ | MONO_MMAP_WRITE, MONO_MEM_ACCOUNT_PROFILER);
  1330| 	if (buffer)
  1331| 		memset (buffer, 0, buffer_size);
  1332| 	return buffer;
  1333| }
  1334| static
  1335| inline
  1336| void
  1337| ep_rt_vfree (
  1338| 	uint8_t *buffer,
  1339| 	size_t buffer_size)
  1340| {
  1341| 	if (buffer)
  1342| 		mono_vfree (buffer, buffer_size, MONO_MEM_ACCOUNT_PROFILER);
  1343| }
  1344| static
  1345| inline
  1346| uint32_t
  1347| ep_rt_temp_path_get (
  1348| 	ep_char8_t *buffer,
  1349| 	uint32_t buffer_len)
  1350| {
  1351| 	EP_ASSERT (buffer != NULL);
  1352| 	EP_ASSERT (buffer_len > 0);
  1353| 	const ep_char8_t *path = g_get_tmp_dir ();
  1354| 	int32_t result = snprintf (buffer, buffer_len, "%s", path);
  1355| 	if (result <= 0 || GINT32_TO_UINT32(result) > buffer_len)
  1356| 		ep_raise_error ();
  1357| 	if (buffer [result - 1] != G_DIR_SEPARATOR) {
  1358| 		buffer [result++] = G_DIR_SEPARATOR;
  1359| 		buffer [result] = '\0';
  1360| 	}
  1361| ep_on_exit:
  1362| 	return result;
  1363| ep_on_error:
  1364| 	result = 0;
  1365| 	ep_exit_error_handler ();
  1366| }
  1367| EP_RT_DEFINE_ARRAY (env_array_utf16, ep_rt_env_array_utf16_t, ep_rt_env_array_utf16_iterator_t, ep_char16_t *)
  1368| EP_RT_DEFINE_ARRAY_ITERATOR (env_array_utf16, ep_rt_env_array_utf16_t, ep_rt_env_array_utf16_iterator_t, ep_char16_t *)
  1369| static
  1370| inline
  1371| void
  1372| ep_rt_os_environment_get_utf16 (ep_rt_env_array_utf16_t *env_array)
  1373| {
  1374| 	ep_rt_mono_os_environment_get_utf16 (env_array);
  1375| }
  1376| /*
  1377| * Lock.
  1378| */
  1379| static
  1380| bool
  1381| ep_rt_lock_acquire (ep_rt_lock_handle_t *lock)
  1382| {
  1383| 	EP_UNREACHABLE ("Not implemented on Mono.");
  1384| }
  1385| static
  1386| bool
  1387| ep_rt_lock_release (ep_rt_lock_handle_t *lock)
  1388| {
  1389| 	EP_UNREACHABLE ("Not implemented on Mono.");
  1390| }
  1391| #ifdef EP_CHECKED_BUILD
  1392| static
  1393| inline
  1394| void
  1395| ep_rt_lock_requires_lock_held (const ep_rt_lock_handle_t *lock)
  1396| {
  1397| 	EP_UNREACHABLE ("Not implemented on Mono.");
  1398| }
  1399| static
  1400| inline
  1401| void
  1402| ep_rt_lock_requires_lock_not_held (const ep_rt_lock_handle_t *lock)
  1403| {
  1404| 	EP_UNREACHABLE ("Not implemented on Mono.");
  1405| }
  1406| #endif
  1407| /*
  1408| * SpinLock.
  1409| */
  1410| #ifdef EP_CHECKED_BUILD
  1411| static
  1412| inline
  1413| void
  1414| ep_rt_spin_lock_set_owning_thread_id (
  1415| 	ep_rt_spin_lock_handle_t *spin_lock,
  1416| 	MonoNativeThreadId thread_id)
  1417| {
  1418| MONO_DISABLE_WARNING(4127) /* conditional expression is constant */
  1419| 	if (sizeof (spin_lock->owning_thread_id) == sizeof (uint32_t))
  1420| 		ep_rt_volatile_store_uint32_t ((uint32_t *)&spin_lock->owning_thread_id, MONO_NATIVE_THREAD_ID_TO_UINT (thread_id));
  1421| 	else if (sizeof (spin_lock->owning_thread_id) == sizeof (uint64_t))
  1422| 		ep_rt_volatile_store_uint64_t ((uint64_t *)&spin_lock->owning_thread_id, MONO_NATIVE_THREAD_ID_TO_UINT (thread_id));
  1423| 	else
  1424| 		spin_lock->owning_thread_id = thread_id;
  1425| MONO_RESTORE_WARNING
  1426| }
  1427| static
  1428| inline
  1429| MonoNativeThreadId
  1430| ep_rt_spin_lock_get_owning_thread_id (const ep_rt_spin_lock_handle_t *spin_lock)
  1431| {
  1432| MONO_DISABLE_WARNING(4127) /* conditional expression is constant */
  1433| 	if (sizeof (spin_lock->owning_thread_id) == sizeof (uint32_t))
  1434| 		return MONO_UINT_TO_NATIVE_THREAD_ID (ep_rt_volatile_load_uint32_t ((const uint32_t *)&spin_lock->owning_thread_id));
  1435| 	else if (sizeof (spin_lock->owning_thread_id) == sizeof (uint64_t))
  1436| 		return MONO_UINT_TO_NATIVE_THREAD_ID (ep_rt_volatile_load_uint64_t ((const uint64_t *)&spin_lock->owning_thread_id));
  1437| 	else
  1438| 		return spin_lock->owning_thread_id;
  1439| MONO_RESTORE_WARNING
  1440| }
  1441| #endif
  1442| static
  1443| inline
  1444| void
  1445| ep_rt_spin_lock_alloc (ep_rt_spin_lock_handle_t *spin_lock)
  1446| {
  1447| #ifdef EP_CHECKED_BUILD
  1448| 	ep_rt_spin_lock_set_owning_thread_id (spin_lock, MONO_UINT_TO_NATIVE_THREAD_ID (0));
  1449| #endif
  1450| 	spin_lock->lock = g_new0 (MonoCoopMutex, 1);
  1451| 	if (spin_lock->lock)
  1452| 		mono_coop_mutex_init (spin_lock->lock);
  1453| }
  1454| static
  1455| inline
  1456| void
  1457| ep_rt_spin_lock_free (ep_rt_spin_lock_handle_t *spin_lock)
  1458| {
  1459| 	if (spin_lock && spin_lock->lock) {
  1460| 		mono_coop_mutex_destroy (spin_lock->lock);
  1461| 		g_free (spin_lock->lock);
  1462| 		spin_lock->lock = NULL;
  1463| 	}
  1464| }
  1465| static
  1466| inline
  1467| bool
  1468| ep_rt_spin_lock_acquire (ep_rt_spin_lock_handle_t *spin_lock)
  1469| {
  1470| 	if (spin_lock && spin_lock->lock) {
  1471| 		mono_coop_mutex_lock (spin_lock->lock);
  1472| #ifdef EP_CHECKED_BUILD
  1473| 		ep_rt_spin_lock_set_owning_thread_id (spin_lock, ep_rt_mono_native_thread_id_get ());
  1474| #endif
  1475| 	}
  1476| 	return true;
  1477| }
  1478| static
  1479| inline
  1480| bool
  1481| ep_rt_spin_lock_release (ep_rt_spin_lock_handle_t *spin_lock)
  1482| {
  1483| 	if (spin_lock && spin_lock->lock) {
  1484| #ifdef EP_CHECKED_BUILD
  1485| 		ep_rt_spin_lock_set_owning_thread_id (spin_lock, MONO_UINT_TO_NATIVE_THREAD_ID (0));
  1486| #endif
  1487| 		mono_coop_mutex_unlock (spin_lock->lock);
  1488| 	}
  1489| 	return true;
  1490| }
  1491| #ifdef EP_CHECKED_BUILD
  1492| static
  1493| inline
  1494| void
  1495| ep_rt_spin_lock_requires_lock_held (const ep_rt_spin_lock_handle_t *spin_lock)
  1496| {
  1497| 	g_assert (ep_rt_mono_native_thread_id_equals (ep_rt_spin_lock_get_owning_thread_id (spin_lock), ep_rt_mono_native_thread_id_get ()));
  1498| }
  1499| static
  1500| inline
  1501| void
  1502| ep_rt_spin_lock_requires_lock_not_held (const ep_rt_spin_lock_handle_t *spin_lock)
  1503| {
  1504| 	g_assert (!ep_rt_mono_native_thread_id_equals (ep_rt_spin_lock_get_owning_thread_id (spin_lock), ep_rt_mono_native_thread_id_get ()));
  1505| }
  1506| #endif
  1507| static
  1508| bool
  1509| ep_rt_spin_lock_is_valid (const ep_rt_spin_lock_handle_t *spin_lock)
  1510| {
  1511| 	return (spin_lock != NULL && spin_lock->lock != NULL);
  1512| }
  1513| /*
  1514|  * String.
  1515|  */
  1516| static
  1517| inline
  1518| int
  1519| ep_rt_utf8_string_compare (
  1520| 	const ep_char8_t *str1,
  1521| 	const ep_char8_t *str2)
  1522| {
  1523| 	return strcmp ((const char *)str1, (const char *)str2);
  1524| }
  1525| static
  1526| inline
  1527| int
  1528| ep_rt_utf8_string_compare_ignore_case (
  1529| 	const ep_char8_t *str1,
  1530| 	const ep_char8_t *str2)
  1531| {
  1532| 	return g_strcasecmp ((const char *)str1, (const char *)str2);
  1533| }
  1534| static
  1535| inline
  1536| bool
  1537| ep_rt_utf8_string_is_null_or_empty (const ep_char8_t *str)
  1538| {
  1539| 	if (str == NULL)
  1540| 		return true;
  1541| 	while (*str) {
  1542| 		if (!isspace(*str))
  1543| 			return false;
  1544| 		str++;
  1545| 	}
  1546| 	return true;
  1547| }
  1548| static
  1549| inline
  1550| ep_char8_t *
  1551| ep_rt_utf8_string_dup (const ep_char8_t *str)
  1552| {
  1553| 	return g_strdup (str);
  1554| }
  1555| static
  1556| inline
  1557| ep_char8_t *
  1558| ep_rt_utf8_string_dup_range (const ep_char8_t *str, const ep_char8_t *strEnd)
  1559| {
  1560| 	ptrdiff_t byte_len = strEnd - str;
  1561| 	ep_char8_t *buffer = g_new(ep_char8_t, byte_len + 1);
  1562| 	if (buffer != NULL)
  1563| 	{
  1564| 		memcpy (buffer, str, byte_len);
  1565| 		buffer [byte_len] = '\0';
  1566| 	}
  1567| 	return buffer;
  1568| }
  1569| static
  1570| inline
  1571| ep_char8_t *
  1572| ep_rt_utf8_string_strtok (
  1573| 	ep_char8_t *str,
  1574| 	const ep_char8_t *delimiter,
  1575| 	ep_char8_t **context)
  1576| {
  1577| 	return strtok_r (str, delimiter, context);
  1578| }
  1579| #undef ep_rt_utf8_string_snprintf
  1580| #define ep_rt_utf8_string_snprintf( \
  1581| 	str, \
  1582| 	str_len, \
  1583| 	format, ...) \
  1584| g_snprintf ((gchar *)str, (gulong)str_len, (const gchar *)format, __VA_ARGS__)
  1585| static
  1586| inline
  1587| bool
  1588| ep_rt_utf8_string_replace (
  1589| 	ep_char8_t **str,
  1590| 	const ep_char8_t *strSearch,
  1591| 	const ep_char8_t *strReplacement
  1592| )
  1593| {
  1594| 	if ((*str) == NULL)
  1595| 		return false;
  1596| 	ep_char8_t* strFound = strstr(*str, strSearch);
  1597| 	if (strFound != NULL)
  1598| 	{
  1599| 		size_t strSearchLen = strlen(strSearch);
  1600| 		size_t newStrSize = strlen(*str) + strlen(strReplacement) - strSearchLen + 1;
  1601| 		ep_char8_t *newStr =  g_new(ep_char8_t, newStrSize);
  1602| 		if (newStr == NULL)
  1603| 		{
  1604| 			*str = NULL;
  1605| 			return false;
  1606| 		}
  1607| 		ep_rt_utf8_string_snprintf(newStr, newStrSize, "%.*s%s%s", (int)(strFound - (*str)), *str, strReplacement, strFound + strSearchLen);
  1608| 		ep_rt_utf8_string_free(*str);
  1609| 		*str = newStr;
  1610| 		return true;
  1611| 	}
  1612| 	return false;
  1613| }
  1614| static
  1615| inline
  1616| ep_char16_t *
  1617| ep_rt_utf8_to_utf16le_string (
  1618| 	const ep_char8_t *str,
  1619| 	size_t len)
  1620| {
  1621| 	return (ep_char16_t *)(g_utf8_to_utf16le ((const gchar *)str, (glong)len, NULL, NULL, NULL));
  1622| }
  1623| static
  1624| inline
  1625| ep_char16_t *
  1626| ep_rt_utf16_string_dup (const ep_char16_t *str)
  1627| {
  1628| 	size_t str_size = (ep_rt_utf16_string_len (str) + 1) * sizeof (ep_char16_t);
  1629| 	ep_char16_t *str_dup = (ep_char16_t *)malloc (str_size);
  1630| 	if (str_dup)
  1631| 		memcpy (str_dup, str, str_size);
  1632| 	return str_dup;
  1633| }
  1634| static
  1635| inline
  1636| void
  1637| ep_rt_utf8_string_free (ep_char8_t *str)
  1638| {
  1639| 	g_free (str);
  1640| }
  1641| static
  1642| inline
  1643| size_t
  1644| ep_rt_utf16_string_len (const ep_char16_t *str)
  1645| {
  1646| 	return g_utf16_len ((const gunichar2 *)str);
  1647| }
  1648| static
  1649| inline
  1650| ep_char8_t *
  1651| ep_rt_utf16_to_utf8_string (
  1652| 	const ep_char16_t *str,
  1653| 	size_t len)
  1654| {
  1655| 	return g_utf16_to_utf8 ((const gunichar2 *)str, (glong)len, NULL, NULL, NULL);
  1656| }
  1657| static
  1658| inline
  1659| ep_char8_t *
  1660| ep_rt_utf16le_to_utf8_string (
  1661| 	const ep_char16_t *str,
  1662| 	size_t len)
  1663| {
  1664| 	return g_utf16le_to_utf8 ((const gunichar2 *)str, (glong)len, NULL, NULL, NULL);
  1665| }
  1666| static
  1667| inline
  1668| void
  1669| ep_rt_utf16_string_free (ep_char16_t *str)
  1670| {
  1671| 	g_free (str);
  1672| }
  1673| static
  1674| inline
  1675| const ep_char8_t *
  1676| ep_rt_managed_command_line_get (void)
  1677| {
  1678| 	if (!mono_lazy_is_initialized (managed_command_line_get_init ())) {
  1679| 		char *cmd_line = managed_command_line_get ();
  1680| 		if (!cmd_line)
  1681| 			return NULL;
  1682| 		g_free (cmd_line);
  1683| 	}
  1684| 	mono_lazy_initialize (managed_command_line_get_init (), managed_command_line_lazy_init);
  1685| 	EP_ASSERT (*managed_command_line_get_ref () != NULL);
  1686| 	return *managed_command_line_get_ref ();
  1687| }
  1688| static
  1689| const ep_char8_t *
  1690| ep_rt_diagnostics_command_line_get (void)
  1691| {
  1692| 	const ep_char8_t * cmd_line = ep_rt_managed_command_line_get ();
  1693| 	if (cmd_line == NULL)
  1694| 		cmd_line = ep_rt_os_command_line_get ();
  1695| 	return cmd_line;
  1696| }
  1697| static
  1698| inline
  1699| const ep_char8_t *
  1700| ep_rt_entrypoint_assembly_name_get_utf8 (void)
  1701| {
  1702| 	MonoAssembly *main_assembly = mono_assembly_get_main ();
  1703| 	if (!main_assembly || !main_assembly->image)
  1704| 		return "";
  1705| 	const char *assembly_name = m_image_get_assembly_name (mono_assembly_get_main ()->image);
  1706| 	if (!assembly_name)
  1707| 		return "";
  1708| 	return (const ep_char8_t*)assembly_name;
  1709| }
  1710| static
  1711| inline
  1712| const ep_char8_t *
  1713| ep_rt_runtime_version_get_utf8 (void)
  1714| {
  1715| 	return (const ep_char8_t *)EGLIB_TOSTRING (RuntimeProductVersion);
  1716| }
  1717| /*
  1718|  * Thread.
  1719|  */
  1720| static
  1721| inline
  1722| void
  1723| ep_rt_thread_setup ()
  1724| {
  1725| 	ep_rt_mono_thread_setup (false);
  1726| }
  1727| static
  1728| inline
  1729| EventPipeThread *
  1730| ep_rt_thread_get (void)
  1731| {
  1732| 	EventPipeThreadHolder *thread_holder = (EventPipeThreadHolder *)mono_native_tls_get_value (_ep_rt_mono_thread_holder_tls_id);
  1733| 	return thread_holder ? ep_thread_holder_get_thread (thread_holder) : NULL;
  1734| }
  1735| static
  1736| inline
  1737| EventPipeThread *
  1738| ep_rt_thread_get_or_create (void)
  1739| {
  1740| 	EventPipeThread *thread = ep_rt_thread_get ();
  1741| 	if (!thread) {
  1742| 		thread = ep_rt_mono_thread_get_or_create ();
  1743| 	}
  1744| 	return thread;
  1745| }
  1746| static
  1747| inline
  1748| ep_rt_thread_handle_t
  1749| ep_rt_thread_get_handle (void)
  1750| {
  1751| 	return mono_thread_info_current ();
  1752| }
  1753| static
  1754| inline
  1755| ep_rt_thread_id_t
  1756| ep_rt_thread_get_id (ep_rt_thread_handle_t thread_handle)
  1757| {
  1758| 	return mono_thread_info_get_tid (thread_handle);
  1759| }
  1760| static
  1761| inline
  1762| uint64_t
  1763| ep_rt_thread_id_t_to_uint64_t (ep_rt_thread_id_t thread_id)
  1764| {
  1765| 	return (uint64_t)MONO_NATIVE_THREAD_ID_TO_UINT (thread_id);
  1766| }
  1767| static
  1768| inline
  1769| ep_rt_thread_id_t
  1770| ep_rt_uint64_t_to_thread_id_t (uint64_t thread_id)
  1771| {
  1772| 	return MONO_UINT_TO_NATIVE_THREAD_ID (thread_id);
  1773| }
  1774| static
  1775| inline
  1776| bool
  1777| ep_rt_thread_has_started (ep_rt_thread_handle_t thread_handle)
  1778| {
  1779| 	return thread_handle == ep_rt_thread_get_handle ();
  1780| }
  1781| static
  1782| inline
  1783| ep_rt_thread_activity_id_handle_t
  1784| ep_rt_thread_get_activity_id_handle (void)
  1785| {
  1786| 	return ep_rt_thread_get_or_create ();
  1787| }
  1788| static
  1789| inline
  1790| const uint8_t *
  1791| ep_rt_thread_get_activity_id_cref (ep_rt_thread_activity_id_handle_t activity_id_handle)
  1792| {
  1793| 	EP_UNREACHABLE ("EP_THREAD_INCLUDE_ACTIVITY_ID should have been defined on Mono");
  1794| 	return NULL;
  1795| }
  1796| static
  1797| inline
  1798| void
  1799| ep_rt_thread_get_activity_id (
  1800| 	ep_rt_thread_activity_id_handle_t activity_id_handle,
  1801| 	uint8_t *activity_id,
  1802| 	uint32_t activity_id_len)
  1803| {
  1804| 	EP_ASSERT (activity_id_handle != NULL);
  1805| 	EP_ASSERT (activity_id != NULL);
  1806| 	EP_ASSERT (activity_id_len == EP_ACTIVITY_ID_SIZE);
  1807| 	memcpy (activity_id, ep_thread_get_activity_id_cref (activity_id_handle), EP_ACTIVITY_ID_SIZE);
  1808| }
  1809| static
  1810| inline
  1811| void
  1812| ep_rt_thread_set_activity_id (
  1813| 	ep_rt_thread_activity_id_handle_t activity_id_handle,
  1814| 	const uint8_t *activity_id,
  1815| 	uint32_t activity_id_len)
  1816| {
  1817| 	EP_ASSERT (activity_id_handle != NULL);
  1818| 	EP_ASSERT (activity_id != NULL);
  1819| 	EP_ASSERT (activity_id_len == EP_ACTIVITY_ID_SIZE);
  1820| 	memcpy (ep_thread_get_activity_id_ref (activity_id_handle), activity_id, EP_ACTIVITY_ID_SIZE);
  1821| }
  1822| static
  1823| inline
  1824| int32_t
  1825| ep_rt_mono_thread_sleep (uint32_t ms, bool alertable)
  1826| {
  1827| 	gboolean alerted = false;
  1828| 	if (alertable)
  1829| 		return (int32_t)mono_thread_info_sleep (ms, &alerted);
  1830| 	else
  1831| 		return (int32_t)mono_thread_info_sleep (ms, NULL);
  1832| }
  1833| static
  1834| inline
  1835| bool
  1836| ep_rt_mono_thread_yield (void)
  1837| {
  1838| 	return (mono_thread_info_yield () == TRUE) ? true : false;
  1839| }
  1840| #if defined(TARGET_ARM) || defined(TARGET_ARM64)
  1841| 	#define EP_SLEEP_START_THRESHOLD (5 * 1024)
  1842| #else
  1843| 	#define EP_SLEEP_START_THRESHOLD (32 * 1024)
  1844| #endif
  1845| #undef EP_YIELD_WHILE
  1846| #define EP_YIELD_WHILE(condition) { \
  1847| 	int32_t __switch_count = 0; \
  1848| 	while (condition) { \
  1849| 		if (++__switch_count >= EP_SLEEP_START_THRESHOLD) { \
  1850| 			ep_rt_mono_thread_sleep (1, false); \
  1851| 		} \
  1852| 	} \
  1853| 	{ \
  1854| 		ep_rt_mono_thread_yield (); \
  1855| 	} \
  1856| }
  1857| /*
  1858|  * ThreadSequenceNumberMap.
  1859|  */
  1860| EP_RT_DEFINE_HASH_MAP_REMOVE(thread_sequence_number_map, ep_rt_thread_sequence_number_hash_map_t, EventPipeThreadSessionState *, uint32_t)
  1861| EP_RT_DEFINE_HASH_MAP_ITERATOR(thread_sequence_number_map, ep_rt_thread_sequence_number_hash_map_t, ep_rt_thread_sequence_number_hash_map_iterator_t, EventPipeThreadSessionState *, uint32_t)
  1862| /*
  1863|  * Volatile.
  1864|  */
  1865| static
  1866| inline
  1867| uint32_t
  1868| ep_rt_volatile_load_uint32_t (const volatile uint32_t *ptr)
  1869| {
  1870| 	return (uint32_t)mono_atomic_load_i32 ((volatile gint32 *)ptr);
  1871| }
  1872| static
  1873| inline
  1874| uint32_t
  1875| ep_rt_volatile_load_uint32_t_without_barrier (const volatile uint32_t *ptr)
  1876| {
  1877| 	uint32_t value = *ptr;
  1878| 	return value;
  1879| }
  1880| static
  1881| inline
  1882| void
  1883| ep_rt_volatile_store_uint32_t (
  1884| 	volatile uint32_t *ptr,
  1885| 	uint32_t value)
  1886| {
  1887| 	mono_atomic_store_i32 ((volatile gint32 *)ptr, (gint32)value);
  1888| }
  1889| static
  1890| inline
  1891| void
  1892| ep_rt_volatile_store_uint32_t_without_barrier (
  1893| 	volatile uint32_t *ptr,
  1894| 	uint32_t value)
  1895| {
  1896| 	*ptr = value;
  1897| }
  1898| static
  1899| inline
  1900| uint64_t
  1901| ep_rt_volatile_load_uint64_t (const volatile uint64_t *ptr)
  1902| {
  1903| 	return (uint64_t)mono_atomic_load_i64 ((volatile gint64 *)ptr);
  1904| }
  1905| static
  1906| inline
  1907| uint64_t
  1908| ep_rt_volatile_load_uint64_t_without_barrier (const volatile uint64_t *ptr)
  1909| {
  1910| 	uint64_t value = *ptr;
  1911| 	return value;
  1912| }
  1913| static
  1914| inline
  1915| void
  1916| ep_rt_volatile_store_uint64_t (
  1917| 	volatile uint64_t *ptr,
  1918| 	uint64_t value)
  1919| {
  1920| 	mono_atomic_store_i64 ((volatile gint64 *)ptr, (gint64)value);
  1921| }
  1922| static
  1923| inline
  1924| void
  1925| ep_rt_volatile_store_uint64_t_without_barrier (
  1926| 	volatile uint64_t *ptr,
  1927| 	uint64_t value)
  1928| {
  1929| 	*ptr = value;
  1930| }
  1931| static
  1932| inline
  1933| int64_t
  1934| ep_rt_volatile_load_int64_t (const volatile int64_t *ptr)
  1935| {
  1936| 	return mono_atomic_load_i64 ((volatile gint64 *)ptr);
  1937| }
  1938| static
  1939| inline
  1940| int64_t
  1941| ep_rt_volatile_load_int64_t_without_barrier (const volatile int64_t *ptr)
  1942| {
  1943| 	return *ptr;
  1944| }
  1945| static
  1946| inline
  1947| void
  1948| ep_rt_volatile_store_int64_t (
  1949| 	volatile int64_t *ptr,
  1950| 	int64_t value)
  1951| {
  1952| 	mono_atomic_store_i64 ((volatile gint64 *)ptr, (gint64)value);
  1953| }
  1954| static
  1955| inline
  1956| void
  1957| ep_rt_volatile_store_int64_t_without_barrier (
  1958| 	volatile int64_t *ptr,
  1959| 	int64_t value)
  1960| {
  1961| 	*ptr = value;
  1962| }
  1963| static
  1964| inline
  1965| void *
  1966| ep_rt_volatile_load_ptr (volatile void **ptr)
  1967| {
  1968| 	return mono_atomic_load_ptr ((volatile gpointer *)ptr);
  1969| }
  1970| static
  1971| inline
  1972| void *
  1973| ep_rt_volatile_load_ptr_without_barrier (volatile void **ptr)
  1974| {
  1975| 	void *value = (void *)(*ptr);
  1976| 	return value;
  1977| }
  1978| static
  1979| inline
  1980| void
  1981| ep_rt_volatile_store_ptr (
  1982| 	volatile void **ptr,
  1983| 	void *value)
  1984| {
  1985| 	mono_atomic_store_ptr ((volatile gpointer *)ptr, (gpointer)value);
  1986| }
  1987| static
  1988| inline
  1989| void
  1990| ep_rt_volatile_store_ptr_without_barrier (
  1991| 	volatile void **ptr,
  1992| 	void *value)
  1993| {
  1994| 	*ptr = value;
  1995| }
  1996| /*
  1997|  * EventPipe Native Events.
  1998|  */
  1999| bool
  2000| ep_rt_mono_write_event_ee_startup_start (void);
  2001| typedef struct _BulkTypeEventLogger BulkTypeEventLogger;
  2002| void
  2003| ep_rt_mono_fire_bulk_type_event (BulkTypeEventLogger *p_type_logger);
  2004| int
  2005| ep_rt_mono_log_single_type (
  2006| 	BulkTypeEventLogger *p_type_logger,
  2007| 	MonoType *mono_type);
  2008| void
  2009| ep_rt_mono_log_type_and_parameters (
  2010| 	BulkTypeEventLogger *p_type_logger,
  2011| 	MonoType *mono_type);
  2012| void
  2013| ep_rt_mono_log_type_and_parameters_if_necessary (
  2014| 	BulkTypeEventLogger *p_type_logger,
  2015| 	MonoType *mono_type);
  2016| void
  2017| ep_rt_mono_send_method_details_event (MonoMethod *method);
  2018| bool
  2019| ep_rt_mono_write_event_jit_start (MonoMethod *method);
  2020| bool
  2021| ep_rt_mono_write_event_method_il_to_native_map (
  2022| 	MonoMethod *method,
  2023| 	MonoJitInfo *ji);
  2024| bool
  2025| ep_rt_mono_write_event_method_load (
  2026| 	MonoMethod *method,
  2027| 	MonoJitInfo *ji);
  2028| bool
  2029| ep_rt_mono_write_event_module_load (MonoImage *image);
  2030| bool
  2031| ep_rt_mono_write_event_module_unload (MonoImage *image);
  2032| bool
  2033| ep_rt_mono_write_event_assembly_load (MonoAssembly *assembly);
  2034| bool
  2035| ep_rt_mono_write_event_assembly_unload (MonoAssembly *assembly);
  2036| bool
  2037| ep_rt_mono_write_event_thread_created (ep_rt_thread_id_t tid);
  2038| bool
  2039| ep_rt_mono_write_event_thread_terminated (ep_rt_thread_id_t tid);
  2040| bool
  2041| ep_rt_mono_write_event_type_load_start (MonoType *type);
  2042| bool
  2043| ep_rt_mono_write_event_type_load_stop (MonoType *type);
  2044| bool
  2045| ep_rt_mono_write_event_exception_thrown (MonoObject *object);
  2046| bool
  2047| ep_rt_mono_write_event_exception_clause (
  2048| 	MonoMethod *method,
  2049| 	uint32_t clause_num,
  2050| 	MonoExceptionEnum clause_type,
  2051| 	MonoObject *obj);
  2052| bool
  2053| ep_rt_mono_write_event_monitor_contention_start (MonoObject *obj);
  2054| bool
  2055| ep_rt_mono_write_event_monitor_contention_stop (MonoObject *obj);
  2056| bool
  2057| ep_rt_mono_write_event_method_jit_memory_allocated_for_code (
  2058| 	const uint8_t *buffer,
  2059| 	uint64_t size,
  2060| 	MonoProfilerCodeBufferType type,
  2061| 	const void *data);
  2062| bool
  2063| ep_rt_write_event_threadpool_worker_thread_start (
  2064| 	uint32_t active_thread_count,
  2065| 	uint32_t retired_worker_thread_count,
  2066| 	uint16_t clr_instance_id);
  2067| bool
  2068| ep_rt_write_event_threadpool_worker_thread_stop (
  2069| 	uint32_t active_thread_count,
  2070| 	uint32_t retired_worker_thread_count,
  2071| 	uint16_t clr_instance_id);
  2072| bool
  2073| ep_rt_write_event_threadpool_worker_thread_wait (
  2074| 	uint32_t active_thread_count,
  2075| 	uint32_t retired_worker_thread_count,
  2076| 	uint16_t clr_instance_id);
  2077| bool
  2078| ep_rt_write_event_threadpool_min_max_threads (
  2079| 	uint16_t min_worker_threads,
  2080| 	uint16_t max_worker_threads,
  2081| 	uint16_t min_io_completion_threads,
  2082| 	uint16_t max_io_completion_threads,
  2083| 	uint16_t clr_instance_id);
  2084| bool
  2085| ep_rt_write_event_threadpool_worker_thread_adjustment_sample (
  2086| 	double throughput,
  2087| 	uint16_t clr_instance_id);
  2088| bool
  2089| ep_rt_write_event_threadpool_worker_thread_adjustment_adjustment (
  2090| 	double average_throughput,
  2091| 	uint32_t networker_thread_count,
  2092| 	/*NativeRuntimeEventSource.ThreadAdjustmentReasonMap*/ int32_t reason,
  2093| 	uint16_t clr_instance_id);
  2094| bool
  2095| ep_rt_write_event_threadpool_worker_thread_adjustment_stats (
  2096| 	double duration,
  2097| 	double throughput,
  2098| 	double threadpool_worker_thread_wait,
  2099| 	double throughput_wave,
  2100| 	double throughput_error_estimate,
  2101| 	double average_throughput_error_estimate,
  2102| 	double throughput_ratio,
  2103| 	double confidence,
  2104| 	double new_control_setting,
  2105| 	uint16_t new_thread_wave_magnitude,
  2106| 	uint16_t clr_instance_id);
  2107| bool
  2108| ep_rt_write_event_threadpool_io_enqueue (
  2109| 	intptr_t native_overlapped,
  2110| 	intptr_t overlapped,
  2111| 	bool multi_dequeues,
  2112| 	uint16_t clr_instance_id);
  2113| bool
  2114| ep_rt_write_event_threadpool_io_dequeue (
  2115| 	intptr_t native_overlapped,
  2116| 	intptr_t overlapped,
  2117| 	uint16_t clr_instance_id);
  2118| bool
  2119| ep_rt_write_event_threadpool_working_thread_count (
  2120| 	uint16_t count,
  2121| 	uint16_t clr_instance_id);
  2122| bool
  2123| ep_rt_write_event_threadpool_io_pack (
  2124| 	intptr_t native_overlapped,
  2125| 	intptr_t overlapped,
  2126| 	uint16_t clr_instance_id);
  2127| /*
  2128| * EventPipe provider callbacks.
  2129| */
  2130| void
  2131| EventPipeEtwCallbackDotNETRuntime (
  2132| 	const uint8_t *source_id,
  2133| 	unsigned long is_enabled,
  2134| 	uint8_t level,
  2135| 	uint64_t match_any_keywords,
  2136| 	uint64_t match_all_keywords,
  2137| 	EventFilterDescriptor *filter_data,
  2138| 	void *callback_data);
  2139| void
  2140| EventPipeEtwCallbackDotNETRuntimeRundown (
  2141| 	const uint8_t *source_id,
  2142| 	unsigned long is_enabled,
  2143| 	uint8_t level,
  2144| 	uint64_t match_any_keywords,
  2145| 	uint64_t match_all_keywords,
  2146| 	EventFilterDescriptor *filter_data,
  2147| 	void *callback_data);
  2148| void
  2149| EventPipeEtwCallbackDotNETRuntimePrivate (
  2150| 	const uint8_t *source_id,
  2151| 	unsigned long is_enabled,
  2152| 	uint8_t level,
  2153| 	uint64_t match_any_keywords,
  2154| 	uint64_t match_all_keywords,
  2155| 	EventFilterDescriptor *filter_data,
  2156| 	void *callback_data);
  2157| void
  2158| EventPipeEtwCallbackDotNETRuntimeStress (
  2159| 	const uint8_t *source_id,
  2160| 	unsigned long is_enabled,
  2161| 	uint8_t level,
  2162| 	uint64_t match_any_keywords,
  2163| 	uint64_t match_all_keywords,
  2164| 	EventFilterDescriptor *filter_data,
  2165| 	void *callback_data);
  2166| void
  2167| EventPipeEtwCallbackDotNETRuntimeMonoProfiler (
  2168| 	const uint8_t *source_id,
  2169| 	unsigned long is_enabled,
  2170| 	uint8_t level,
  2171| 	uint64_t match_any_keywords,
  2172| 	uint64_t match_all_keywords,
  2173| 	EventFilterDescriptor *filter_data,
  2174| 	void *callback_data);
  2175| #endif /* ENABLE_PERFTRACING */
  2176| #endif /* __EVENTPIPE_RT_MONO_H__ */


# ====================================================================
# FILE: src/mono/mono/metadata/native-library.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1219 ---
     1| #include "config.h"
     2| #include "mono/metadata/assembly-internals.h"
     3| #include "mono/metadata/class-internals.h"
     4| #include "mono/metadata/icall-decl.h"
     5| #include "mono/metadata/loader-internals.h"
     6| #include "mono/metadata/loader.h"
     7| #include "mono/metadata/object-internals.h"
     8| #include "mono/metadata/reflection-internals.h"
     9| #include "mono/utils/checked-build.h"
    10| #include "mono/utils/mono-compiler.h"
    11| #include "mono/utils/mono-logger-internals.h"
    12| #include "mono/utils/mono-path.h"
    13| #include "mono/metadata/native-library.h"
    14| #include "mono/metadata/custom-attrs-internals.h"
    15| static int pinvoke_search_directories_count;
    16| static char **pinvoke_search_directories;
    17| typedef enum
    18| {
    19| 	DLLIMPORTSEARCHPATH_LEGACY_BEHAVIOR = 0x0, // when no other flags are present, search the application directory and then call LoadLibraryEx with LOAD_WITH_ALTERED_SEARCH_PATH
    20| 	DLLIMPORTSEARCHPATH_USE_DLL_DIRECTORY_FOR_DEPENDENCIES = 0x100,
    21| 	DLLIMPORTSEARCHPATH_APPLICATION_DIRECTORY = 0x200,
    22| 	DLLIMPORTSEARCHPATH_USER_DIRECTORIES = 0x400,
    23| 	DLLIMPORTSEARCHPATH_SYSTEM32 = 0x800,
    24| 	DLLIMPORTSEARCHPATH_SAFE_DIRECTORIES = 0x1000,
    25| 	DLLIMPORTSEARCHPATH_ASSEMBLY_DIRECTORY = 0x2, // search the assembly directory first regardless of platform, not passed on to LoadLibraryEx
    26| } DllImportSearchPath;
    27| #ifdef HOST_WIN32
    28| static const int DLLIMPORTSEARCHPATH_LOADLIBRARY_FLAG_MASK = DLLIMPORTSEARCHPATH_USE_DLL_DIRECTORY_FOR_DEPENDENCIES | DLLIMPORTSEARCHPATH_APPLICATION_DIRECTORY |
    29|                                                              DLLIMPORTSEARCHPATH_USER_DIRECTORIES | DLLIMPORTSEARCHPATH_SYSTEM32 | DLLIMPORTSEARCHPATH_SAFE_DIRECTORIES;
    30| #endif
    31| static MonoCoopMutex native_library_module_lock;
    32| static GHashTable *native_library_module_map;
    33| /*
    34|  * This blocklist is used as a set for cache invalidation purposes with netcore pinvokes.
    35|  * When pinvokes are resolved with anything other than the last-chance managed event,
    36|  * the results of that lookup are added to an ALC-level cache. However, if a library is then
    37|  * unloaded with NativeLibrary.Free(), this cache should be invalidated so that a newly called
    38|  * pinvoke will not attempt to use it, hence the blocklist. This design means that if another
    39|  * library is loaded at the same address, it will function with a perf hit, as the entry will
    40|  * repeatedly be added and removed from the cache due to its presence in the blocklist.
    41|  * This is a rare scenario and considered a worthwhile tradeoff.
    42|  */
    43| static GHashTable *native_library_module_blocklist;
    44| #ifndef NO_GLOBALIZATION_SHIM
    45| extern const void *GlobalizationResolveDllImport (const char *name);
    46| #endif
    47| #ifndef DISABLE_DLLMAP
    48| static MonoDllMap *global_dll_map;
    49| #endif
    50| static GHashTable *global_module_map; // should only be accessed with the global loader data lock
    51| static MonoDl *internal_module; // used when pinvoking `__Internal`
    52| static PInvokeOverrideFn pinvoke_override;
    53| static gboolean bundle_save_library_initialized;
    54| static GSList *bundle_library_paths;
    55| static char *bundled_dylibrary_directory;
    56| /* Class lazy loading functions */
    57| GENERATE_GET_CLASS_WITH_CACHE (appdomain_unloaded_exception, "System", "AppDomainUnloadedException")
    58| GENERATE_TRY_GET_CLASS_WITH_CACHE (appdomain_unloaded_exception, "System", "AppDomainUnloadedException")
    59| GENERATE_GET_CLASS_WITH_CACHE (native_library, "System.Runtime.InteropServices", "NativeLibrary");
    60| static GENERATE_TRY_GET_CLASS_WITH_CACHE (dllimportsearchpath_attribute, "System.Runtime.InteropServices", "DefaultDllImportSearchPathsAttribute");
    61| #ifndef DISABLE_DLLMAP
    62| /*
    63|  * LOCKING: Assumes the relevant lock is held.
    64|  * For the global DllMap, this is `global_loader_data_mutex`, and for images it's their internal lock.
    65|  */
    66| static gboolean
    67| mono_dllmap_lookup_list (MonoDllMap *dll_map, const char *dll, const char* func, const char **rdll, const char **rfunc) {
    68| 	gboolean found = FALSE;
    69| 	*rdll = dll;
    70| 	*rfunc = func;
    71| 	if (!dll_map)
    72| 		goto exit;
    73| 	/*
    74| 	 * we use the first entry we find that matches, since entries from
    75| 	 * the config file are prepended to the list and we document that the
    76| 	 * later entries win.
    77| 	 */
    78| 	for (; dll_map; dll_map = dll_map->next) {
    79| 		gboolean case_insensitive_match = strncmp (dll_map->dll, "i:", 2) == 0 && g_ascii_strcasecmp (dll_map->dll + 2, dll) == 0;
    80| 		gboolean case_sensitive_match = strcmp (dll_map->dll, dll) == 0;
    81| 		if (!(case_insensitive_match || case_sensitive_match))
    82| 			continue;
    83| 		if (!found && dll_map->target) {
    84| 			*rdll = dll_map->target;
    85| 			found = TRUE;
    86| 			/* we don't quit here, because we could find a full
    87| 			 * entry that also matches the function, which takes priority.
    88| 			 */
    89| 		}
    90| 		if (dll_map->func && strcmp (dll_map->func, func) == 0) {
    91| 			*rdll = dll_map->target;
    92| 			*rfunc = dll_map->target_func;
    93| 			break;
    94| 		}
    95| 	}
    96| exit:
    97| 	return found;
    98| }
    99| /*
   100|  * The locking and GC state transitions here are wonky due to the fact the image lock is a coop lock
   101|  * and the global loader data lock is an OS lock.
   102|  */
   103| static gboolean
   104| mono_dllmap_lookup (MonoImage *assembly, const char *dll, const char* func, const char **rdll, const char **rfunc)
   105| {
   106| 	gboolean res;
   107| 	MONO_REQ_GC_UNSAFE_MODE;
   108| 	if (assembly && assembly->dll_map) {
   109| 		mono_image_lock (assembly);
   110| 		res = mono_dllmap_lookup_list (assembly->dll_map, dll, func, rdll, rfunc);
   111| 		mono_image_unlock (assembly);
   112| 		if (res)
   113| 			goto leave;
   114| 	}
   115| 	MONO_ENTER_GC_SAFE;
   116| 	mono_global_loader_data_lock ();
   117| 	res = mono_dllmap_lookup_list (global_dll_map, dll, func, rdll, rfunc);
   118| 	mono_global_loader_data_unlock ();
   119| 	MONO_EXIT_GC_SAFE;
   120| leave:
   121| 	*rdll = g_strdup (*rdll);
   122| 	*rfunc = g_strdup (*rfunc);
   123| 	return res;
   124| }
   125| static void
   126| dllmap_insert_global (const char *dll, const char *func, const char *tdll, const char *tfunc)
   127| {
   128| 	MonoDllMap *entry;
   129| 	entry = (MonoDllMap *)g_malloc0 (sizeof (MonoDllMap));
   130| 	entry->dll = dll? g_strdup (dll): NULL;
   131| 	entry->target = tdll? g_strdup (tdll): NULL;
   132| 	entry->func = func? g_strdup (func): NULL;
   133| 	entry->target_func = tfunc? g_strdup (tfunc): (func? g_strdup (func): NULL);
   134| 	mono_global_loader_data_lock ();
   135| 	entry->next = global_dll_map;
   136| 	global_dll_map = entry;
   137| 	mono_global_loader_data_unlock ();
   138| }
   139| static void
   140| dllmap_insert_image (MonoImage *assembly, const char *dll, const char *func, const char *tdll, const char *tfunc)
   141| {
   142| 	MonoDllMap *entry;
   143| 	g_assert (assembly != NULL);
   144| 	MONO_REQ_GC_UNSAFE_MODE;
   145| 	entry = (MonoDllMap *)mono_image_alloc0 (assembly, sizeof (MonoDllMap));
   146| 	entry->dll = dll? mono_image_strdup (assembly, dll): NULL;
   147| 	entry->target = tdll? mono_image_strdup (assembly, tdll): NULL;
   148| 	entry->func = func? mono_image_strdup (assembly, func): NULL;
   149| 	entry->target_func = tfunc? mono_image_strdup (assembly, tfunc): (func? mono_image_strdup (assembly, func): NULL);
   150| 	mono_image_lock (assembly);
   151| 	entry->next = assembly->dll_map;
   152| 	assembly->dll_map = entry;
   153| 	mono_image_unlock (assembly);
   154| }
   155| /*
   156|  * LOCKING: Assumes the relevant lock is held.
   157|  * For the global DllMap, this is `global_loader_data_mutex`, and for images it's their internal lock.
   158|  */
   159| static void
   160| free_dllmap (MonoDllMap *map)
   161| {
   162| 	while (map) {
   163| 		MonoDllMap *next = map->next;
   164| 		g_free (map->dll);
   165| 		g_free (map->target);
   166| 		g_free (map->func);
   167| 		g_free (map->target_func);
   168| 		g_free (map);
   169| 		map = next;
   170| 	}
   171| }
   172| void
   173| mono_dllmap_insert_internal (MonoImage *assembly, const char *dll, const char *func, const char *tdll, const char *tfunc)
   174| {
   175| 	mono_loader_init ();
   176| 	if (!assembly)
   177| 		dllmap_insert_global (dll, func, tdll, tfunc);
   178| 	else
   179| 		dllmap_insert_image (assembly, dll, func, tdll, tfunc);
   180| }
   181| void
   182| mono_global_dllmap_cleanup (void)
   183| {
   184| 	mono_global_loader_data_lock ();
   185| 	free_dllmap (global_dll_map);
   186| 	global_dll_map = NULL;
   187| 	mono_global_loader_data_unlock ();
   188| }
   189| #endif
   190| /**
   191|  * mono_dllmap_insert:
   192|  * \param assembly if NULL, this is a global mapping, otherwise the remapping of the dynamic library will only apply to the specified assembly
   193|  * \param dll The name of the external library, as it would be found in the \c DllImport declaration.  If prefixed with <code>i:</code> the matching of the library name is done without case sensitivity
   194|  * \param func if not null, the mapping will only applied to the named function (the value of <code>EntryPoint</code>)
   195|  * \param tdll The name of the library to map the specified \p dll if it matches.
   196|  * \param tfunc The name of the function that replaces the invocation.  If NULL, it is replaced with a copy of \p func.
   197|  *
   198|  * LOCKING: Acquires the image lock, or the loader data lock if an image is not passed.
   199|  *
   200|  * This function is used to programatically add \c DllImport remapping in either
   201|  * a specific assembly, or as a global remapping.   This is done by remapping
   202|  * references in a \c DllImport attribute from the \p dll library name into the \p tdll
   203|  * name. If the \p dll name contains the prefix <code>i:</code>, the comparison of the
   204|  * library name is done without case sensitivity.
   205|  *
   206|  * If you pass \p func, this is the name of the \c EntryPoint in a \c DllImport if specified
   207|  * or the name of the function as determined by \c DllImport. If you pass \p func, you
   208|  * must also pass \p tfunc which is the name of the target function to invoke on a match.
   209|  *
   210|  * Example:
   211|  *
   212|  * <code>mono_dllmap_insert (NULL, "i:libdemo.dll", NULL, relocated_demo_path, NULL);</code>
   213|  *
   214|  * The above will remap \c DllImport statements for \c libdemo.dll and \c LIBDEMO.DLL to
   215|  * the contents of \c relocated_demo_path for all assemblies in the Mono process.
   216|  *
   217|  * NOTE: This can be called before the runtime is initialized.
   218|  */
   219| void
   220| mono_dllmap_insert (MonoImage *assembly, const char *dll, const char *func, const char *tdll, const char *tfunc)
   221| {
   222| #ifndef DISABLE_DLLMAP
   223| 	mono_dllmap_insert_internal (assembly, dll, func, tdll, tfunc);
   224| #else
   225| 	g_assert_not_reached ();
   226| #endif
   227| }
   228| void
   229| mono_loader_register_module (const char *name, MonoDl *module)
   230| {
   231| 	mono_loader_init ();
   232| 	mono_global_loader_data_lock ();
   233| 	g_hash_table_insert (global_module_map, g_strdup (name), module);
   234| 	mono_global_loader_data_unlock ();
   235| }
   236| static MonoDl *
   237| mono_loader_register_module_locking (const char *name, MonoDl *module)
   238| {
   239| 	MonoDl *result = NULL;
   240| 	MONO_ENTER_GC_SAFE;
   241| 	mono_global_loader_data_lock ();
   242| 	MONO_EXIT_GC_SAFE;
   243| 	result = (MonoDl *)g_hash_table_lookup (global_module_map, name);
   244| 	if (result) {
   245| 		g_free (module->full_name);
   246| 		g_free (module);
   247| 		goto exit;
   248| 	}
   249| 	g_hash_table_insert (global_module_map, g_strdup (name), module);
   250| 	result = module;
   251| exit:
   252| 	MONO_ENTER_GC_SAFE;
   253| 	mono_global_loader_data_unlock ();
   254| 	MONO_EXIT_GC_SAFE;
   255| 	return result;
   256| }
   257| static void
   258| remove_cached_module (gpointer key, gpointer value, gpointer user_data)
   259| {
   260| 	ERROR_DECL (close_error);
   261| 	mono_dl_close((MonoDl*)value, close_error);
   262| 	mono_error_cleanup (close_error);
   263| }
   264| void
   265| mono_global_loader_cache_init (void)
   266| {
   267| 	if (!global_module_map)
   268| 		global_module_map = g_hash_table_new (g_str_hash, g_str_equal);
   269| 	if (!native_library_module_map)
   270| 		native_library_module_map = g_hash_table_new (g_direct_hash, g_direct_equal);
   271| 	if (!native_library_module_blocklist)
   272| 		native_library_module_blocklist = g_hash_table_new (g_direct_hash, g_direct_equal);
   273| 	mono_coop_mutex_init (&native_library_module_lock);
   274| }
   275| static gboolean
   276| is_absolute_path (const char *path)
   277| {
   278| #ifdef HOST_DARWIN
   279| 	if (!strncmp (path, "@executable_path/", 17) || !strncmp (path, "@loader_path/", 13) || !strncmp (path, "@rpath/", 7))
   280| 		return TRUE;
   281| #endif
   282| 	return g_path_is_absolute (path);
   283| }
   284| static gpointer
   285| lookup_pinvoke_call_impl (MonoMethod *method, MonoLookupPInvokeStatus *status_out);
   286| static gpointer
   287| pinvoke_probe_for_symbol (MonoDl *module, MonoMethodPInvoke *piinfo, const char *import);
   288| static void
   289| pinvoke_probe_convert_status_for_api (MonoLookupPInvokeStatus *status, const char **exc_class, const char **exc_arg)
   290| {
   291| 	if (!exc_class)
   292| 		return;
   293| 	switch (status->err_code) {
   294| 	case LOOKUP_PINVOKE_ERR_OK:
   295| 		*exc_class = NULL;
   296| 		*exc_arg = NULL;
   297| 		break;
   298| 	case LOOKUP_PINVOKE_ERR_NO_LIB:
   299| 		*exc_class = "DllNotFoundException";
   300| 		*exc_arg = status->err_arg;
   301| 		status->err_arg = NULL;
   302| 		break;
   303| 	case LOOKUP_PINVOKE_ERR_NO_SYM:
   304| 		*exc_class = "EntryPointNotFoundException";
   305| 		*exc_arg = status->err_arg;
   306| 		status->err_arg = NULL;
   307| 		break;
   308| 	default:
   309| 		g_assert_not_reached ();
   310| 	}
   311| }
   312| static void
   313| pinvoke_probe_convert_status_to_error (MonoLookupPInvokeStatus *status, MonoError *error)
   314| {
   315| 	/* Note: this has to return a MONO_ERROR_GENERIC because mono_mb_emit_exception_for_error only knows how to decode generic errors. */
   316| 	switch (status->err_code) {
   317| 	case LOOKUP_PINVOKE_ERR_OK:
   318| 		return;
   319| 	case LOOKUP_PINVOKE_ERR_NO_LIB:
   320| 		mono_error_set_generic_error (error, "System", "DllNotFoundException", "%s", status->err_arg);
   321| 		g_free (status->err_arg);
   322| 		status->err_arg = NULL;
   323| 		break;
   324| 	case LOOKUP_PINVOKE_ERR_NO_SYM:
   325| 		mono_error_set_generic_error (error, "System", "EntryPointNotFoundException", "%s", status->err_arg);
   326| 		g_free (status->err_arg);
   327| 		status->err_arg = NULL;
   328| 		break;
   329| 	default:
   330| 		g_assert_not_reached ();
   331| 	}
   332| }
   333| /**
   334|  * mono_lookup_pinvoke_call:
   335|  */
   336| gpointer
   337| mono_lookup_pinvoke_call (MonoMethod *method, const char **exc_class, const char **exc_arg)
   338| {
   339| 	gpointer result;
   340| 	MONO_ENTER_GC_UNSAFE;
   341| 	MonoLookupPInvokeStatus status;
   342| 	memset (&status, 0, sizeof (status));
   343| 	result = lookup_pinvoke_call_impl (method, &status);
   344| 	pinvoke_probe_convert_status_for_api (&status, exc_class, exc_arg);
   345| 	MONO_EXIT_GC_UNSAFE;
   346| 	return result;
   347| }
   348| gpointer
   349| mono_lookup_pinvoke_call_internal (MonoMethod *method, MonoError *error)
   350| {
   351| 	gpointer result;
   352| 	MonoLookupPInvokeStatus status;
   353| 	memset (&status, 0, sizeof (status));
   354| 	result = lookup_pinvoke_call_impl (method, &status);
   355| 	if (status.err_code)
   356| 		pinvoke_probe_convert_status_to_error (&status, error);
   357| 	return result;
   358| }
   359| void
   360| mono_set_pinvoke_search_directories (int dir_count, char **dirs)
   361| {
   362| 	pinvoke_search_directories_count = dir_count;
   363| 	g_strfreev (pinvoke_search_directories);
   364| 	pinvoke_search_directories = dirs;
   365| }
   366| static void
   367| native_library_lock (void)
   368| {
   369| 	mono_coop_mutex_lock (&native_library_module_lock);
   370| }
   371| static void
   372| native_library_unlock (void)
   373| {
   374| 	mono_coop_mutex_unlock (&native_library_module_lock);
   375| }
   376| static void
   377| alc_pinvoke_lock (MonoAssemblyLoadContext *alc)
   378| {
   379| 	mono_coop_mutex_lock (&alc->pinvoke_lock);
   380| }
   381| static void
   382| alc_pinvoke_unlock (MonoAssemblyLoadContext *alc)
   383| {
   384| 	mono_coop_mutex_unlock (&alc->pinvoke_lock);
   385| }
   386| static MonoDl *
   387| netcore_handle_lookup (gpointer handle)
   388| {
   389| 	return (MonoDl *)g_hash_table_lookup (native_library_module_map, handle);
   390| }
   391| static gboolean
   392| netcore_check_blocklist (MonoDl *module)
   393| {
   394| 	return g_hash_table_contains (native_library_module_blocklist, module);
   395| }
   396| static int
   397| convert_dllimport_flags (int flags)
   398| {
   399| #ifdef HOST_WIN32
   400| 	return flags & DLLIMPORTSEARCHPATH_LOADLIBRARY_FLAG_MASK;
   401| #else
   402| 	return 0;
   403| #endif
   404| }
   405| static MonoDl *
   406| netcore_probe_for_module_variations (const char *mdirname, const char *file_name, int raw_flags, MonoError *error)
   407| {
   408| 	void *iter = NULL;
   409| 	char *full_name = NULL;
   410| 	MonoDl *module = NULL;
   411| 	ERROR_DECL (bad_image_error);
   412| 	while (module == NULL && (full_name = mono_dl_build_path (mdirname, file_name, &iter))) {
   413| 		mono_error_cleanup (error);
   414| 		error_init_reuse (error);
   415| 		module = mono_dl_open_full (full_name, MONO_DL_LAZY, raw_flags, error);
   416| 		if (!module)
   417| 			mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "DllImport error loading library '%s': '%s'.", full_name, mono_error_get_message_without_fields (error));
   418| 		g_free (full_name);
   419| 		if (!module && !is_ok (error) && mono_error_get_error_code (error) == MONO_ERROR_BAD_IMAGE) {
   420| 			mono_error_cleanup (bad_image_error);
   421| 			mono_error_move (bad_image_error, error);
   422| 		}
   423| 	}
   424| 	if (!module && !is_ok (bad_image_error)) {
   425| 		mono_error_cleanup (error);
   426| 		mono_error_move (error, bad_image_error);
   427| 	}
   428| 	mono_error_cleanup (bad_image_error);
   429| 	return module;
   430| }
   431| static MonoDl *
   432| netcore_probe_for_module (MonoImage *image, const char *file_name, int flags, MonoError *error)
   433| {
   434| 	MonoDl *module = NULL;
   435| 	int lflags = convert_dllimport_flags (flags);
   436| 	ERROR_DECL (bad_image_error);
   437| #if defined(HOST_ANDROID)
   438| 	module = netcore_probe_for_module_variations (NULL, file_name, lflags, error);
   439| 	if (!module && !is_ok (error) && mono_error_get_error_code (error) == MONO_ERROR_BAD_IMAGE)
   440| 		mono_error_move (bad_image_error, error);
   441| #endif
   442| 	for (int i = 0; i < pinvoke_search_directories_count && module == NULL; ++i) {
   443| 		mono_error_cleanup (error);
   444| 		error_init_reuse (error);
   445| 		module = netcore_probe_for_module_variations (pinvoke_search_directories[i], file_name, lflags, error);
   446| 		if (!module && !is_ok (error) && mono_error_get_error_code (error) == MONO_ERROR_BAD_IMAGE) {
   447| 			mono_error_cleanup (bad_image_error);
   448| 			mono_error_move (bad_image_error, error);
   449| 		}
   450| 	}
   451| 	if ((flags & DLLIMPORTSEARCHPATH_ASSEMBLY_DIRECTORY) != 0 && image != NULL &&
   452| 		module == NULL && (image->filename != NULL)) {
   453| 		mono_error_cleanup (error);
   454| 		error_init_reuse (error);
   455| 		char *mdirname = g_path_get_dirname (image->filename);
   456| 		if (mdirname)
   457| 			module = netcore_probe_for_module_variations (mdirname, file_name, lflags, error);
   458| 		g_free (mdirname);
   459| 	}
   460| #if !defined(HOST_ANDROID)
   461| 	if (module == NULL)
   462| 	{
   463| 		module = netcore_probe_for_module_variations (NULL, file_name, lflags, error);
   464| 		if (!module && !is_ok (error) && mono_error_get_error_code (error) == MONO_ERROR_BAD_IMAGE)
   465| 			mono_error_move (bad_image_error, error);
   466| 	}
   467| #endif
   468| 	if (!module && !is_ok (bad_image_error)) {
   469| 		mono_error_cleanup (error);
   470| 		mono_error_move (error, bad_image_error);
   471| 	}
   472| 	mono_error_cleanup (bad_image_error);
   473| 	return module;
   474| }
   475| static MonoDl *
   476| netcore_probe_for_module_nofail (MonoImage *image, const char *file_name, int flags)
   477| {
   478| 	MonoDl *result = NULL;
   479| 	ERROR_DECL (error);
   480| 	result = netcore_probe_for_module (image, file_name, flags, error);
   481| 	mono_error_cleanup (error);
   482| 	return result;
   483| }
   484| static MonoDl*
   485| netcore_lookup_self_native_handle (void)
   486| {
   487| 	ERROR_DECL (load_error);
   488| 	if (!internal_module)
   489| 		internal_module = mono_dl_open_self (load_error);
   490| 	if (!internal_module)
   491| 		mono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT, "DllImport error loading library '__Internal': '%s'.", mono_error_get_message_without_fields (load_error));
   492| 	mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "Native library found via __Internal.");
   493| 	mono_error_cleanup (load_error);
   494| 	return internal_module;
   495| }
   496| static MonoDl* native_handle_lookup_wrapper (gpointer handle)
   497| {
   498| 	MonoDl *result = NULL;
   499| 	if (!internal_module)
   500| 		netcore_lookup_self_native_handle ();
   501| 	if (internal_module->handle == handle) {
   502| 		result = internal_module;
   503| 	} else {
   504| 		native_library_lock ();
   505| 		result = netcore_handle_lookup (handle);
   506| 		native_library_unlock ();
   507| 	}
   508| 	return result;
   509| }
   510| static MonoDl *
   511| netcore_resolve_with_dll_import_resolver (MonoAssemblyLoadContext *alc, MonoAssembly *assembly, const char *scope, guint32 flags, MonoError *error)
   512| {
   513| 	MonoDl *result = NULL;
   514| 	gpointer lib = NULL;
   515| 	MONO_STATIC_POINTER_INIT (MonoMethod, resolve)
   516| 		ERROR_DECL (local_error);
   517| 		static gboolean inited;
   518| 		if (!inited) {
   519| 			MonoClass *native_lib_class = mono_class_get_native_library_class ();
   520| 			g_assert (native_lib_class);
   521| 			resolve = mono_class_get_method_from_name_checked (native_lib_class, "MonoLoadLibraryCallbackStub", -1, 0, local_error);
   522| 			inited = TRUE;
   523| 		}
   524| 		mono_error_cleanup (local_error);
   525| 	MONO_STATIC_POINTER_INIT_END (MonoMethod, resolve)
   526| 	if (!resolve)
   527| 		return NULL;
   528| 	if (mono_runtime_get_no_exec ())
   529| 		return NULL;
   530| 	HANDLE_FUNCTION_ENTER ();
   531| 	MonoStringHandle scope_handle;
   532| 	scope_handle = mono_string_new_handle (scope, error);
   533| 	goto_if_nok (error, leave);
   534| 	MonoReflectionAssemblyHandle assembly_handle;
   535| 	assembly_handle = mono_assembly_get_object_handle (assembly, error);
   536| 	goto_if_nok (error, leave);
   537| 	gboolean has_search_flags;
   538| 	has_search_flags = flags != 0 ? TRUE : FALSE;
   539| 	gpointer args [5];
   540| 	args [0] = MONO_HANDLE_RAW (scope_handle);
   541| 	args [1] = MONO_HANDLE_RAW (assembly_handle);
   542| 	args [2] = &has_search_flags;
   543| 	args [3] = &flags;
   544| 	args [4] = &lib;
   545| 	mono_runtime_invoke_checked (resolve, NULL, args, error);
   546| 	goto_if_nok (error, leave);
   547| 	result = native_handle_lookup_wrapper (lib);
   548| leave:
   549| 	HANDLE_FUNCTION_RETURN_VAL (result);
   550| }
   551| static MonoDl *
   552| netcore_resolve_with_dll_import_resolver_nofail (MonoAssemblyLoadContext *alc, MonoAssembly *assembly, const char *scope, guint32 flags)
   553| {
   554| 	MonoDl *result = NULL;
   555| 	ERROR_DECL (error);
   556| 	result = netcore_resolve_with_dll_import_resolver (alc, assembly, scope, flags, error);
   557| 	if (!is_ok (error))
   558| 		mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "Error while invoking ALC DllImportResolver(\"%s\") delegate: '%s'", scope, mono_error_get_message (error));
   559| 	mono_error_cleanup (error);
   560| 	return result;
   561| }
   562| static MonoDl *
   563| netcore_resolve_with_load (MonoAssemblyLoadContext *alc, const char *scope, MonoError *error)
   564| {
   565| 	MonoDl *result = NULL;
   566| 	gpointer lib = NULL;
   567| 	MONO_STATIC_POINTER_INIT (MonoMethod, resolve)
   568| 		ERROR_DECL (local_error);
   569| 		MonoClass *alc_class = mono_class_get_assembly_load_context_class ();
   570| 		g_assert (alc_class);
   571| 		resolve = mono_class_get_method_from_name_checked (alc_class, "MonoResolveUnmanagedDll", -1, 0, local_error);
   572| 		mono_error_assert_ok (local_error);
   573| 	MONO_STATIC_POINTER_INIT_END (MonoMethod, resolve)
   574| 	g_assert (resolve);
   575| 	if (mono_runtime_get_no_exec ())
   576| 		return NULL;
   577| 	HANDLE_FUNCTION_ENTER ();
   578| 	MonoStringHandle scope_handle;
   579| 	scope_handle = mono_string_new_handle (scope, error);
   580| 	goto_if_nok (error, leave);
   581| 	gpointer gchandle = mono_alc_get_gchandle_for_resolving (alc);
   582| 	gpointer args [3];
   583| 	args [0] = MONO_HANDLE_RAW (scope_handle);
   584| 	args [1] = &gchandle;
   585| 	args [2] = &lib;
   586| 	mono_runtime_invoke_checked (resolve, NULL, args, error);
   587| 	goto_if_nok (error, leave);
   588| 	result = native_handle_lookup_wrapper (lib);
   589| leave:
   590| 	HANDLE_FUNCTION_RETURN_VAL (result);
   591| }
   592| static MonoDl *
   593| netcore_resolve_with_load_nofail (MonoAssemblyLoadContext *alc, const char *scope)
   594| {
   595| 	MonoDl *result = NULL;
   596| 	ERROR_DECL (error);
   597| 	result = netcore_resolve_with_load (alc, scope, error);
   598| 	if (!is_ok (error))
   599| 		mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "Error while invoking ALC LoadUnmanagedDll(\"%s\") method: '%s'", scope, mono_error_get_message (error));
   600| 	mono_error_cleanup (error);
   601| 	return result;
   602| }
   603| static MonoDl *
   604| netcore_resolve_with_resolving_event (MonoAssemblyLoadContext *alc, MonoAssembly *assembly, const char *scope, MonoError *error)
   605| {
   606| 	MonoDl *result = NULL;
   607| 	gpointer lib = NULL;
   608| 	MONO_STATIC_POINTER_INIT (MonoMethod, resolve)
   609| 		ERROR_DECL (local_error);
   610| 		static gboolean inited;
   611| 		if (!inited) {
   612| 			MonoClass *alc_class = mono_class_get_assembly_load_context_class ();
   613| 			g_assert (alc_class);
   614| 			resolve = mono_class_get_method_from_name_checked (alc_class, "MonoResolveUnmanagedDllUsingEvent", -1, 0, local_error);
   615| 			inited = TRUE;
   616| 		}
   617| 		mono_error_cleanup (local_error);
   618| 	MONO_STATIC_POINTER_INIT_END (MonoMethod, resolve)
   619| 	if (!resolve)
   620| 		return NULL;
   621| 	if (mono_runtime_get_no_exec ())
   622| 		return NULL;
   623| 	HANDLE_FUNCTION_ENTER ();
   624| 	MonoStringHandle scope_handle;
   625| 	scope_handle = mono_string_new_handle (scope, error);
   626| 	goto_if_nok (error, leave);
   627| 	MonoReflectionAssemblyHandle assembly_handle;
   628| 	assembly_handle = mono_assembly_get_object_handle (assembly, error);
   629| 	goto_if_nok (error, leave);
   630| 	gpointer gchandle = mono_alc_get_gchandle_for_resolving (alc);
   631| 	gpointer args [4];
   632| 	args [0] = MONO_HANDLE_RAW (scope_handle);
   633| 	args [1] = MONO_HANDLE_RAW (assembly_handle);
   634| 	args [2] = &gchandle;
   635| 	args [3] = &lib;
   636| 	mono_runtime_invoke_checked (resolve, NULL, args, error);
   637| 	goto_if_nok (error, leave);
   638| 	result = native_handle_lookup_wrapper (lib);
   639| leave:
   640| 	HANDLE_FUNCTION_RETURN_VAL (result);
   641| }
   642| static MonoDl *
   643| netcore_resolve_with_resolving_event_nofail (MonoAssemblyLoadContext *alc, MonoAssembly *assembly, const char *scope)
   644| {
   645| 	MonoDl *result = NULL;
   646| 	ERROR_DECL (error);
   647| 	result = netcore_resolve_with_resolving_event (alc, assembly, scope, error);
   648| 	if (!is_ok (error))
   649| 		mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "Error while invoking ALC ResolvingUnmangedDll(\"%s\") event: '%s'", scope, mono_error_get_message (error));
   650| 	mono_error_cleanup (error);
   651| 	return result;
   652| }
   653| static MonoDl *
   654| netcore_check_alc_cache (MonoAssemblyLoadContext *alc, const char *scope)
   655| {
   656| 	MonoDl *result = NULL;
   657| 	result = (MonoDl *)g_hash_table_lookup (alc->pinvoke_scopes, scope);
   658| 	if (result) {
   659| 		gboolean blocklisted;
   660| 		native_library_lock ();
   661| 		blocklisted = netcore_check_blocklist (result);
   662| 		native_library_unlock ();
   663| 		if (blocklisted) {
   664| 			g_hash_table_remove (alc->pinvoke_scopes, scope);
   665| 			result = NULL;
   666| 		}
   667| 	}
   668| 	return result;
   669| }
   670| static MonoDl *
   671| netcore_lookup_native_library (MonoAssemblyLoadContext *alc, MonoImage *image, const char *scope, guint32 flags)
   672| {
   673| 	MonoDl *module = NULL;
   674| 	MonoDl *cached;
   675| 	MonoAssembly *assembly = mono_image_get_assembly (image);
   676| 	MONO_REQ_GC_UNSAFE_MODE;
   677| 	mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "DllImport attempting to load: '%s'.", scope);
   678| 	if (strcmp (scope, "__Internal") == 0) {
   679| 		return netcore_lookup_self_native_handle();
   680| 	}
   681| 	/*
   682| 	 * Try these until one of them succeeds:
   683| 	 *
   684| 	 * 1. Check the cache in the active ALC.
   685| 	 *
   686| 	 * 2. Call the DllImportResolver on the active assembly.
   687| 	 *
   688| 	 * 3. Call LoadUnmanagedDll on the active ALC.
   689| 	 *
   690| 	 * 4. Check the global cache.
   691| 	 *
   692| 	 * 5. Run the unmanaged probing logic.
   693| 	 *
   694| 	 * 6. Raise the ResolvingUnmanagedDll event on the active ALC.
   695| 	 *
   696| 	 * 7. Return NULL.
   697| 	 */
   698| 	alc_pinvoke_lock (alc);
   699| 	module = netcore_check_alc_cache (alc, scope);
   700| 	alc_pinvoke_unlock (alc);
   701| 	if (module) {
   702| 		mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "Native library found in the active ALC cache: '%s'.", scope);
   703| 		goto leave;
   704| 	}
   705| 	module = (MonoDl *)netcore_resolve_with_dll_import_resolver_nofail (alc, assembly, scope, flags);
   706| 	if (module) {
   707| 		mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "Native library found via DllImportResolver: '%s'.", scope);
   708| 		goto add_to_alc_cache;
   709| 	}
   710| 	module = (MonoDl *)netcore_resolve_with_load_nofail (alc, scope);
   711| 	if (module) {
   712| 		mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "Native library found via LoadUnmanagedDll: '%s'.", scope);
   713| 		goto add_to_alc_cache;
   714| 	}
   715| 	MONO_ENTER_GC_SAFE;
   716| 	mono_global_loader_data_lock ();
   717| 	MONO_EXIT_GC_SAFE;
   718| 	module = (MonoDl *)g_hash_table_lookup (global_module_map, scope);
   719| 	MONO_ENTER_GC_SAFE;
   720| 	mono_global_loader_data_unlock ();
   721| 	MONO_EXIT_GC_SAFE;
   722| 	if (module) {
   723| 		mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "Native library found in the global cache: '%s'.", scope);
   724| 		goto add_to_alc_cache;
   725| 	}
   726| 	module = netcore_probe_for_module_nofail (image, scope, flags);
   727| 	if (module) {
   728| 		mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "Native library found via filesystem probing: '%s'.", scope);
   729| 		goto add_to_global_cache;
   730| 	}
   731| 	/* As this is last chance, I've opted not to put it in a cache, but that is not necessarily the correct decision.
   732| 	 * It is rather convenient here, however, because it means the global cache will only be populated by libraries
   733| 	 * resolved via netcore_probe_for_module and not NativeLibrary, eliminating potential races/conflicts.
   734| 	 */
   735| 	module = netcore_resolve_with_resolving_event_nofail (alc, assembly, scope);
   736| 	if (module)
   737| 		mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "Native library found via the Resolving event: '%s'.", scope);
   738| 	goto leave;
   739| add_to_global_cache:
   740| 	module = mono_loader_register_module_locking (scope, module);
   741| add_to_alc_cache:
   742| 	/* Nothing is closed here because the only two places this can come from are:
   743| 	 * 1. A managed callback that made use of NativeLibrary.Load, in which case closing is dependent on NativeLibrary.Free
   744| 	 * 2. The global cache, which is only populated by results of netcore_probe_for_module. When adding to the global cache,
   745| 	 *      we free the new MonoDl if another thread beat us, so we don't have to repeat that here.
   746| 	 */
   747| 	alc_pinvoke_lock (alc);
   748| 	cached = netcore_check_alc_cache (alc, scope);
   749| 	if (cached)
   750| 		module = cached;
   751| 	else
   752| 		g_hash_table_insert (alc->pinvoke_scopes, g_strdup (scope), module);
   753| 	alc_pinvoke_unlock (alc);
   754| leave:
   755| 	return module;
   756| }
   757| static int
   758| get_dllimportsearchpath_flags (MonoCustomAttrInfo *cinfo)
   759| {
   760| 	ERROR_DECL (error);
   761| 	MonoCustomAttrEntry *attr = NULL;
   762| 	MonoClass *dllimportsearchpath = mono_class_try_get_dllimportsearchpath_attribute_class ();
   763| 	int idx;
   764| 	int flags;
   765| 	if (!dllimportsearchpath)
   766| 		return -1;
   767| 	if (!cinfo)
   768| 		return -2;
   769| 	for (idx = 0; idx < cinfo->num_attrs; ++idx) {
   770| 		MonoClass *ctor_class = cinfo->attrs [idx].ctor->klass;
   771| 		if (ctor_class == dllimportsearchpath) {
   772| 			attr = &cinfo->attrs [idx];
   773| 			break;
   774| 		}
   775| 	}
   776| 	if (!attr)
   777| 		return -3;
   778| 	MonoDecodeCustomAttr *decoded_args = mono_reflection_create_custom_attr_data_args_noalloc (m_class_get_image (attr->ctor->klass), attr->ctor, attr->data, attr->data_size, error);
   779| 	if (!is_ok (error)) {
   780| 		mono_error_cleanup (error);
   781| 		return -4;
   782| 	}
   783| 	flags = *(gint32*)decoded_args->typed_args[0]->value.primitive;
   784| 	mono_reflection_free_custom_attr_data_args_noalloc (decoded_args);
   785| 	return flags;
   786| }
   787| #ifndef NO_GLOBALIZATION_SHIM
   788| #ifdef HOST_WIN32
   789| #define GLOBALIZATION_DLL_NAME "System.Globalization.Native"
   790| #else
   791| #define GLOBALIZATION_DLL_NAME "libSystem.Globalization.Native"
   792| #endif
   793| static gpointer
   794| default_resolve_dllimport (const char *dll, const char *func)
   795| {
   796| 	if (strcmp (dll, GLOBALIZATION_DLL_NAME) == 0) {
   797| 		const void *method_impl = GlobalizationResolveDllImport (func);
   798| 		if (method_impl)
   799| 			return (gpointer)method_impl;
   800| 	}
   801| 	return NULL;
   802| }
   803| #endif // NO_GLOBALIZATION_SHIM
   804| gpointer
   805| lookup_pinvoke_call_impl (MonoMethod *method, MonoLookupPInvokeStatus *status_out)
   806| {
   807| 	MonoImage *image = m_class_get_image (method->klass);
   808| 	MonoAssemblyLoadContext *alc = mono_image_get_alc (image);
   809| 	MonoCustomAttrInfo *cinfo;
   810| 	int flags;
   811| 	MonoMethodPInvoke *piinfo = (MonoMethodPInvoke *)method;
   812| 	MonoTableInfo *tables = image->tables;
   813| 	MonoTableInfo *im = &tables [MONO_TABLE_IMPLMAP];
   814| 	MonoTableInfo *mr = &tables [MONO_TABLE_MODULEREF];
   815| 	guint32 im_cols [MONO_IMPLMAP_SIZE];
   816| 	guint32 scope_token;
   817| 	const char *orig_import = NULL;
   818| 	const char *new_import = NULL;
   819| 	const char *orig_scope = NULL;
   820| 	const char *new_scope = NULL;
   821| 	const char *error_scope = NULL;
   822| 	MonoDl *module = NULL;
   823| 	gpointer addr = NULL;
   824| 	MONO_REQ_GC_UNSAFE_MODE;
   825| 	g_assert (method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL);
   826| 	g_assert (status_out);
   827| 	if (piinfo->addr)
   828| 		return piinfo->addr;
   829| 	if (image_is_dynamic (image)) {
   830| 		MonoReflectionMethodAux *method_aux =
   831| 			(MonoReflectionMethodAux *)g_hash_table_lookup (
   832| 				((MonoDynamicImage*)m_class_get_image (method->klass))->method_aux_hash, method);
   833| 		if (!method_aux)
   834| 			goto exit;
   835| 		orig_import = method_aux->dllentry;
   836| 		orig_scope = method_aux->dll;
   837| 	}
   838| 	else {
   839| 		if (!piinfo->implmap_idx || mono_metadata_table_bounds_check (image, MONO_TABLE_IMPLMAP, piinfo->implmap_idx))
   840| 			goto exit;
   841| 		mono_metadata_decode_row (im, piinfo->implmap_idx - 1, im_cols, MONO_IMPLMAP_SIZE);
   842| 		if (!im_cols [MONO_IMPLMAP_SCOPE] || mono_metadata_table_bounds_check (image, MONO_TABLE_MODULEREF, im_cols [MONO_IMPLMAP_SCOPE]))
   843| 			goto exit;
   844| 		piinfo->piflags = GUINT32_TO_UINT16 (im_cols [MONO_IMPLMAP_FLAGS]);
   845| 		orig_import = mono_metadata_string_heap (image, im_cols [MONO_IMPLMAP_NAME]);
   846| 		scope_token = mono_metadata_decode_row_col (mr, im_cols [MONO_IMPLMAP_SCOPE] - 1, MONO_MODULEREF_NAME);
   847| 		orig_scope = mono_metadata_string_heap (image, scope_token);
   848| 	}
   849| #ifndef DISABLE_DLLMAP
   850| 	mono_dllmap_lookup (image, orig_scope, orig_import, &new_scope, &new_import);
   851| #else
   852| 	new_scope = g_strdup (orig_scope);
   853| 	new_import = g_strdup (orig_import);
   854| #endif
   855| 	error_scope = new_scope;
   856| 	/* If qcalls are disabled, we fall back to the normal pinvoke code for them */
   857| #ifndef DISABLE_QCALLS
   858| 	if (strcmp (new_scope, "QCall") == 0) {
   859| 		piinfo->addr = mono_lookup_pinvoke_qcall_internal (new_import);
   860| 		if (!piinfo->addr) {
   861| 			mono_trace (G_LOG_LEVEL_WARNING, MONO_TRACE_DLLIMPORT,
   862| 						"Unable to find qcall for '%s'.",
   863| 						new_import);
   864| 			status_out->err_code = LOOKUP_PINVOKE_ERR_NO_SYM;
   865| 			status_out->err_arg = g_strdup (new_import);
   866| 		}
   867| 		return piinfo->addr;
   868| 	}
   869| #endif
   870| #ifndef NO_GLOBALIZATION_SHIM
   871| 	addr = default_resolve_dllimport (new_scope, new_import);
   872| 	if (addr)
   873| 		goto exit;
   874| #endif
   875| 	if (pinvoke_override) {
   876| 		addr = pinvoke_override (new_scope, new_import);
   877| 		if (addr)
   878| 			goto exit;
   879| 	}
   880| #ifndef HOST_WIN32
   881| retry_with_libcoreclr:
   882| #endif
   883| 	{
   884| 		ERROR_DECL (local_error);
   885| 		cinfo = mono_custom_attrs_from_method_checked (method, local_error);
   886| 		mono_error_cleanup (local_error);
   887| 	}
   888| 	flags = get_dllimportsearchpath_flags (cinfo);
   889| 	if (cinfo && !cinfo->cached)
   890| 		mono_custom_attrs_free (cinfo);
   891| 	if (flags < 0) {
   892| 		ERROR_DECL (local_error);
   893| 		cinfo = mono_custom_attrs_from_assembly_checked (m_class_get_image (method->klass)->assembly, TRUE, local_error);
   894| 		mono_error_cleanup (local_error);
   895| 		flags = get_dllimportsearchpath_flags (cinfo);
   896| 		if (cinfo && !cinfo->cached)
   897| 			mono_custom_attrs_free (cinfo);
   898| 	}
   899| 	if (flags < 0)
   900| 		flags = DLLIMPORTSEARCHPATH_ASSEMBLY_DIRECTORY;
   901| 	module = netcore_lookup_native_library (alc, image, new_scope, flags);
   902| 	if (!module) {
   903| 		mono_trace (G_LOG_LEVEL_WARNING, MONO_TRACE_DLLIMPORT,
   904| 				"DllImport unable to load library '%s'.",
   905| 				error_scope);
   906| 		status_out->err_code = LOOKUP_PINVOKE_ERR_NO_LIB;
   907| 		status_out->err_arg = g_strdup (error_scope);
   908| 		goto exit;
   909| 	}
   910| 	mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT,
   911| 				"DllImport searching in: '%s' ('%s').", new_scope, module->full_name);
   912| 	addr = pinvoke_probe_for_symbol (module, piinfo, new_import);
   913| 	if (!addr) {
   914| #ifndef HOST_WIN32
   915| 		if (strcmp (new_scope, "__Internal") == 0) {
   916| 			g_assert (error_scope == new_scope);
   917| 			new_scope = g_strdup (MONO_LOADER_LIBRARY_NAME);
   918| 			goto retry_with_libcoreclr;
   919| 		}
   920| #endif
   921| 		status_out->err_code = LOOKUP_PINVOKE_ERR_NO_SYM;
   922| 		status_out->err_arg = g_strdup (new_import);
   923| 		goto exit;
   924| 	}
   925| 	piinfo->addr = addr;
   926| exit:
   927| 	if (error_scope != new_scope) {
   928| 		g_free ((char *)error_scope);
   929| 	}
   930| 	g_free ((char *)new_import);
   931| 	g_free ((char *)new_scope);
   932| 	return addr;
   933| }
   934| static gpointer
   935| pinvoke_probe_for_symbol (MonoDl *module, MonoMethodPInvoke *piinfo, const char *import)
   936| {
   937| 	gpointer addr = NULL;
   938| 	ERROR_DECL (symbol_error);
   939| 	mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT,
   940| 				"Searching for '%s'.", import);
   941| #ifdef HOST_WIN32 // For netcore, name mangling is Windows-exclusive
   942| 	if (piinfo->piflags & PINVOKE_ATTRIBUTE_NO_MANGLE)
   943| 		addr = mono_dl_symbol (module, import, symbol_error);
   944| 	else {
   945| 		/*
   946| 		 * Search using a variety of mangled names
   947| 		 */
   948| 		for (int mangle_stdcall = 0; mangle_stdcall <= 1 && addr == NULL; mangle_stdcall++) {
   949| #if HOST_WIN32 && HOST_X86
   950| 			const int max_managle_param_count = (mangle_stdcall == 0) ? 0 : 256;
   951| #else
   952| 			const int max_managle_param_count = 0;
   953| #endif
   954| 			for (int mangle_charset = 0; mangle_charset <= 1 && addr == NULL; mangle_charset ++) {
   955| 				for (int mangle_param_count = 0; mangle_param_count <= max_managle_param_count && addr == NULL; mangle_param_count += 4) {
   956| 					char *mangled_name = (char*)import;
   957| 					switch (piinfo->piflags & PINVOKE_ATTRIBUTE_CHAR_SET_MASK) {
   958| 					case PINVOKE_ATTRIBUTE_CHAR_SET_UNICODE:
   959| 						/* Try the mangled name first */
   960| 						if (mangle_charset == 0)
   961| 							mangled_name = g_strconcat (import, "W", (const char*)NULL);
   962| 						break;
   963| 					case PINVOKE_ATTRIBUTE_CHAR_SET_AUTO:
   964| #ifdef HOST_WIN32
   965| 						if (mangle_charset == 0)
   966| 							mangled_name = g_strconcat (import, "W", (const char*)NULL);
   967| #else
   968| 						/* Try the mangled name last */
   969| 						if (mangle_charset == 1)
   970| 							mangled_name = g_strconcat (import, "A", (const char*)NULL);
   971| #endif
   972| 						break;
   973| 					case PINVOKE_ATTRIBUTE_CHAR_SET_ANSI:
   974| 					default:
   975| 						/* Try the mangled name last */
   976| 						if (mangle_charset == 1)
   977| 							mangled_name = g_strconcat (import, "A", (const char*)NULL);
   978| 						break;
   979| 					}
   980| #if HOST_WIN32 && HOST_X86
   981| 					/* Try the stdcall mangled name */
   982| 					/*
   983| 					 * gcc under windows creates mangled names without the underscore, but MS.NET
   984| 					 * doesn't support it, so we doesn't support it either.
   985| 					 */
   986| 					if (mangle_stdcall == 1) {
   987| 						MonoMethod *method = &piinfo->method;
   988| 						int param_count;
   989| 						if (mangle_param_count == 0)
   990| 							param_count = mono_method_signature_internal (method)->param_count * sizeof (gpointer);
   991| 						else
   992| 							/* Try brute force, since it would be very hard to compute the stack usage correctly */
   993| 							param_count = mangle_param_count;
   994| 						char *mangled_stdcall_name = g_strdup_printf ("_%s@%d", mangled_name, param_count);
   995| 						if (mangled_name != import)
   996| 							g_free (mangled_name);
   997| 						mangled_name = mangled_stdcall_name;
   998| 					}
   999| #endif
  1000| 					mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT,
  1001| 								"Probing '%s'.", mangled_name);
  1002| 					error_init_reuse (symbol_error);
  1003| 					addr = mono_dl_symbol (module, mangled_name, symbol_error);
  1004| 					if (addr)
  1005| 						mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT,
  1006| 									"Found as '%s'.", mangled_name);
  1007| 					else
  1008| 						mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT,
  1009| 									"Could not find '%s' due to '%s'.", mangled_name, mono_error_get_message_without_fields (symbol_error));
  1010| 					mono_error_cleanup (symbol_error);
  1011| 					if (mangled_name != import)
  1012| 						g_free (mangled_name);
  1013| 				}
  1014| 			}
  1015| 		}
  1016| 	}
  1017| #else
  1018| 	addr = mono_dl_symbol (module, import, symbol_error);
  1019| 	mono_error_cleanup (symbol_error);
  1020| #endif
  1021| 	return addr;
  1022| }
  1023| void
  1024| ves_icall_System_Runtime_InteropServices_NativeLibrary_FreeLib (gpointer lib, MonoError *error)
  1025| {
  1026| 	ERROR_DECL (close_error);
  1027| 	MonoDl *module;
  1028| 	guint32 ref_count;
  1029| 	g_assert (lib);
  1030| 	if (internal_module && lib == internal_module->handle)
  1031| 		return;
  1032| 	native_library_lock ();
  1033| 	module = netcore_handle_lookup (lib);
  1034| 	if (module) {
  1035| 		ref_count = mono_refcount_dec (module);
  1036| 		if (ref_count > 0)
  1037| 			goto leave;
  1038| 		g_hash_table_remove (native_library_module_map, module->handle);
  1039| 		g_hash_table_add (native_library_module_blocklist, module);
  1040| 		mono_dl_close (module, close_error);
  1041| 	} else {
  1042| 		MonoDl *raw_module = (MonoDl *) g_malloc0 (sizeof (MonoDl));
  1043| 		if (raw_module) {
  1044| 			raw_module->handle = lib;
  1045| 			mono_dl_close (raw_module, close_error);
  1046| 		}
  1047| 	}
  1048| leave:
  1049| 	if (!is_ok (close_error)) {
  1050| 		mono_error_set_invalid_operation (error, NULL);
  1051| 		mono_error_cleanup (close_error);
  1052| 	}
  1053| 	native_library_unlock ();
  1054| }
  1055| gpointer
  1056| ves_icall_System_Runtime_InteropServices_NativeLibrary_GetSymbol (gpointer lib, MonoStringHandle symbol_name_handle, MonoBoolean throw_on_error, MonoError *error)
  1057| {
  1058| 	MonoDl *module;
  1059| 	gpointer symbol = NULL;
  1060| 	char *symbol_name;
  1061| 	g_assert (lib);
  1062| 	ERROR_LOCAL_BEGIN (local_error, error, throw_on_error)
  1063| 	symbol_name = mono_string_handle_to_utf8 (symbol_name_handle, error);
  1064| 	goto_if_nok (error, leave_nolock);
  1065| 	native_library_lock ();
  1066| 	module = netcore_handle_lookup (lib);
  1067| 	if (module) {
  1068| 		symbol = mono_dl_symbol (module, symbol_name, error);
  1069| 		if (!symbol) {
  1070| 			mono_error_cleanup (error);
  1071| 			error_init_reuse (error);
  1072| 			mono_error_set_generic_error (error, "System", "EntryPointNotFoundException", "%s: %s", module->full_name, symbol_name);
  1073| 		}
  1074| 	} else {
  1075| 		MonoDl raw_module = { { 0 } };
  1076| 		raw_module.handle = lib;
  1077| 		symbol = mono_dl_symbol (&raw_module, symbol_name, error);
  1078| 		if (!symbol) {
  1079| 			mono_error_cleanup (error);
  1080| 			error_init_reuse (error);
  1081| 			mono_error_set_generic_error (error, "System", "EntryPointNotFoundException", "%p: %s", lib, symbol_name);
  1082| 		}
  1083| 	}
  1084| 	native_library_unlock ();
  1085| leave_nolock:
  1086| 	ERROR_LOCAL_END (local_error);
  1087| 	g_free (symbol_name);
  1088| 	return symbol;
  1089| }
  1090| static MonoDl *
  1091| check_native_library_cache (MonoDl *module)
  1092| {
  1093| 	gpointer handle = module->handle;
  1094| 	MonoDl *cached_module = netcore_handle_lookup (handle);
  1095| 	if (cached_module) {
  1096| 		g_free (module->full_name);
  1097| 		g_free (module);
  1098| 		mono_refcount_inc (cached_module);
  1099| 		return cached_module;
  1100| 	}
  1101| 	g_hash_table_insert (native_library_module_map, handle, (gpointer)module);
  1102| 	return module;
  1103| }
  1104| gpointer
  1105| ves_icall_System_Runtime_InteropServices_NativeLibrary_LoadByName (MonoStringHandle lib_name_handle, MonoReflectionAssemblyHandle assembly_handle, MonoBoolean has_search_flag, guint32 search_flag, MonoBoolean throw_on_error, MonoError *error)
  1106| {
  1107| 	MonoDl *module;
  1108| 	gpointer handle = NULL;
  1109| 	MonoAssembly *assembly = MONO_HANDLE_GETVAL (assembly_handle, assembly);
  1110| 	MonoImage *image = mono_assembly_get_image_internal (assembly);
  1111| 	char *lib_name;
  1112| 	ERROR_LOCAL_BEGIN (local_error, error, throw_on_error)
  1113| 	lib_name = mono_string_handle_to_utf8 (lib_name_handle, error);
  1114| 	goto_if_nok (error, leave);
  1115| 	{
  1116| 		ERROR_DECL (load_error);
  1117| 		module = netcore_probe_for_module (image, lib_name, has_search_flag ? search_flag : DLLIMPORTSEARCHPATH_ASSEMBLY_DIRECTORY, load_error);
  1118| 		if (!module) {
  1119| 			if (mono_error_get_error_code (load_error) == MONO_ERROR_BAD_IMAGE)
  1120| 				mono_error_set_generic_error (error, "System", "BadImageFormatException", "%s", lib_name);
  1121| 			else
  1122| 				mono_error_set_generic_error (error, "System", "DllNotFoundException", "%s", lib_name);
  1123| 		}
  1124| 		mono_error_cleanup (load_error);
  1125| 	}
  1126| 	goto_if_nok (error, leave);
  1127| 	native_library_lock ();
  1128| 	module = check_native_library_cache (module);
  1129| 	native_library_unlock ();
  1130| 	handle = module->handle;
  1131| leave:
  1132| 	ERROR_LOCAL_END (local_error);
  1133| 	g_free (lib_name);
  1134| 	return handle;
  1135| }
  1136| gpointer
  1137| ves_icall_System_Runtime_InteropServices_NativeLibrary_LoadFromPath (MonoStringHandle lib_path_handle, MonoBoolean throw_on_error, MonoError *error)
  1138| {
  1139| 	MonoDl *module;
  1140| 	gpointer handle = NULL;
  1141| 	char *lib_path;
  1142| 	ERROR_LOCAL_BEGIN (local_error, error, throw_on_error)
  1143| 	lib_path = mono_string_handle_to_utf8 (lib_path_handle, error);
  1144| 	goto_if_nok (error, leave);
  1145| 	ERROR_DECL (load_error);
  1146| 	module = mono_dl_open (lib_path, MONO_DL_LAZY, load_error);
  1147| 	if (!module) {
  1148| 		const char *error_msg = mono_error_get_message_without_fields (load_error);
  1149| 		guint16 error_code = mono_error_get_error_code (load_error);
  1150| 		mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, "DllImport error loading library '%s': '%s'.", lib_path, error_msg);
  1151| 		if (error_code == MONO_ERROR_BAD_IMAGE)
  1152| 			mono_error_set_generic_error (error, "System", "BadImageFormatException", "'%s': '%s'", lib_path, error_msg);
  1153| 		else
  1154| 			mono_error_set_generic_error (error, "System", "DllNotFoundException", "'%s': '%s'", lib_path, error_msg);
  1155| 	}
  1156| 	mono_error_cleanup (load_error);
  1157| 	goto_if_nok (error, leave);
  1158| 	native_library_lock ();
  1159| 	module = check_native_library_cache (module);
  1160| 	native_library_unlock ();
  1161| 	handle = module->handle;
  1162| leave:
  1163| 	ERROR_LOCAL_END (local_error);
  1164| 	g_free (lib_path);
  1165| 	return handle;
  1166| }
  1167| #ifdef HAVE_ATEXIT
  1168| static void
  1169| delete_bundled_libraries (void)
  1170| {
  1171| 	GSList *list;
  1172| 	for (list = bundle_library_paths; list != NULL; list = list->next){
  1173| 		unlink ((const char*)list->data);
  1174| 	}
  1175| 	rmdir (bundled_dylibrary_directory);
  1176| }
  1177| #endif
  1178| static void
  1179| bundle_save_library_initialize (void)
  1180| {
  1181| 	bundle_save_library_initialized = TRUE;
  1182| 	char *path = g_build_filename (g_get_tmp_dir (), "mono-bundle-XXXXXX", (const char*)NULL);
  1183| 	bundled_dylibrary_directory = g_mkdtemp (path);
  1184| 	g_free (path);
  1185| 	if (bundled_dylibrary_directory == NULL)
  1186| 		return;
  1187| #ifdef HAVE_ATEXIT
  1188| 	atexit (delete_bundled_libraries);
  1189| #endif
  1190| }
  1191| void
  1192| mono_loader_save_bundled_library (int fd, uint64_t offset, uint64_t size, const char *destfname)
  1193| {
  1194| 	MonoDl *lib;
  1195| 	char *file, *buffer, *internal_path;
  1196| 	if (!bundle_save_library_initialized)
  1197| 		bundle_save_library_initialize ();
  1198| 	file = g_build_filename (bundled_dylibrary_directory, destfname, (const char*)NULL);
  1199| 	buffer = g_str_from_file_region (fd, offset, GUINT64_TO_SIZE (size));
  1200| 	g_file_set_contents (file, buffer, GUINT64_TO_SIZE (size), NULL);
  1201| 	ERROR_DECL (load_error);
  1202| 	lib = mono_dl_open (file, MONO_DL_LAZY, load_error);
  1203| 	if (!lib) {
  1204| 		fprintf (stderr, "Error loading shared library: %s %s\n", file, mono_error_get_message_without_fields (load_error));
  1205| 		mono_error_cleanup (load_error);
  1206| 		exit (1);
  1207| 	}
  1208| 	mono_error_assert_ok (load_error);
  1209| 	internal_path = g_build_filename (".", destfname, (const char*)NULL);
  1210|  	mono_loader_register_module (internal_path, lib);
  1211| 	g_free (internal_path);
  1212| 	bundle_library_paths = g_slist_append (bundle_library_paths, file);
  1213| 	g_free (buffer);
  1214| }
  1215| void
  1216| mono_loader_install_pinvoke_override (PInvokeOverrideFn override_fn)
  1217| {
  1218| 	pinvoke_override = override_fn;
  1219| }


# ====================================================================
# FILE: src/mono/sample/wasm/browser/main.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-66 ---
     1| import { dotnet, exit } from './dotnet.js'
     2| function add(a, b) {
     3|     return a + b;
     4| }
     5| function sub(a, b) {
     6|     return a - b;
     7| }
     8| let testError = true;
     9| let testAbort = true;
    10| try {
    11|     const { runtimeBuildInfo, setModuleImports, getAssemblyExports, runMain, getConfig } = await dotnet
    12|         .withConsoleForwarding()
    13|         .withElementOnExit()
    14|         .withModuleConfig({
    15|             configSrc: "./mono-config.json",
    16|             imports: {
    17|                 fetch: (url, fetchArgs) => {
    18|                     if (testAbort && url.indexOf('System.Private.Uri.dll') != -1) {
    19|                         testAbort = false;
    20|                         return fetch(url + "?testAbort=true", fetchArgs);
    21|                     }
    22|                     if (testError && url.indexOf('System.Console.dll') != -1) {
    23|                         testError = false;
    24|                         return fetch(url + "?testError=true", fetchArgs);
    25|                     }
    26|                     return fetch(url, fetchArgs);
    27|                 }
    28|             },
    29|             onConfigLoaded: (config) => {
    30|                 console.log('user code Module.onConfigLoaded');
    31|                 config.environmentVariables["MONO_LOG_LEVEL"] = "debug"
    32|             },
    33|             preInit: () => { console.log('user code Module.preInit'); },
    34|             preRun: () => { console.log('user code Module.preRun'); },
    35|             onRuntimeInitialized: () => {
    36|                 console.log('user code Module.onRuntimeInitialized');
    37|             },
    38|             onDotnetReady: () => {
    39|                 console.log('user code Module.onDotnetReady');
    40|             },
    41|             postRun: () => { console.log('user code Module.postRun'); },
    42|         })
    43|         .create();
    44|     console.log('user code after createDotnetRuntime()');
    45|     setModuleImports("main.js", {
    46|         Sample: {
    47|             Test: {
    48|                 add,
    49|                 sub
    50|             }
    51|         }
    52|     });
    53|     const config = getConfig();
    54|     const exports = await getAssemblyExports(config.mainAssemblyName);
    55|     const meaning = exports.Sample.Test.TestMeaning();
    56|     console.debug(`meaning: ${meaning}`);
    57|     if (!exports.Sample.Test.IsPrime(meaning)) {
    58|         document.getElementById("out").innerHTML = `${meaning} as computed on dotnet ver ${runtimeBuildInfo.productVersion}`;
    59|         console.debug(`ret: ${meaning}`);
    60|     }
    61|     let exit_code = await runMain(config.mainAssemblyName, []);
    62|     exit(exit_code);
    63| }
    64| catch (err) {
    65|     exit(2, err);
    66| }


# ====================================================================
# FILE: src/mono/sample/wasm/simple-server/Program.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-179 ---
     1| // Licensed to the .NET Foundation under one or more agreements.
     2| using System.Net;
     3| using System.Diagnostics;
     4| using System.Runtime.InteropServices;
     5| namespace HttpServer
     6| {
     7|     public sealed class Program
     8|     {
     9|         private bool Verbose = false;
    10|         public static int Main()
    11|         {
    12|             if (!HttpListener.IsSupported)
    13|             {
    14|                 Console.WriteLine("error: HttpListener is not supported.");
    15|                 return -1;
    16|             }
    17|             for (int i = 0; i < 10; i++)
    18|             {
    19|                 if (new Program().StartServer())
    20|                     break;
    21|             }
    22|             return 0;
    23|         }
    24|         private bool StartServer()
    25|         {
    26|             var port = 8000 + Random.Shared.Next(1000);
    27|             var listener = new HttpListener();
    28|             var url = $"http://localhost:{port}/";
    29|             listener.Prefixes.Add(url);
    30|             try
    31|             {
    32|                 listener.Start();
    33|             }
    34|             catch (HttpListenerException)
    35|             {
    36|                 return false;
    37|             }
    38|             Console.WriteLine($"Listening on {url}");
    39|             OpenUrl(url);
    40|             while (true)
    41|                 HandleRequest(listener);
    42|         }
    43|         private void OpenUrl(string url)
    44|         {
    45|             var proc = new Process();
    46|             var si = new ProcessStartInfo();
    47|             if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
    48|             {
    49|                 si.FileName = url;
    50|                 si.UseShellExecute = true;
    51|             }
    52|             else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
    53|             {
    54|                 si.FileName = "xdg-open";
    55|                 si.ArgumentList.Add(url);
    56|             }
    57|             else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
    58|             {
    59|                 si.FileName = "open";
    60|                 si.ArgumentList.Add(url);
    61|             }
    62|             else
    63|             {
    64|                 System.Console.WriteLine("Don't know how to open url on this OS platform");
    65|             }
    66|             proc.StartInfo = si;
    67|             proc.Start();
    68|         }
    69|         private void HandleRequest(HttpListener listener)
    70|         {
    71|             var context = listener.GetContext();
    72|             if (Verbose)
    73|                 Console.WriteLine($"request url: {context.Request.Url}");
    74|             if (context.Request.HttpMethod == "GET")
    75|                 ServeAsync(context);
    76|             else if (context.Request.HttpMethod == "POST")
    77|                 ReceivePostAsync(context);
    78|         }
    79|         private async void ReceivePostAsync(HttpListenerContext context)
    80|         {
    81|             if (Verbose)
    82|             {
    83|                 Console.WriteLine("got POST request");
    84|                 Console.WriteLine($"  content type: {context.Request.ContentType}");
    85|             }
    86|             var url = context.Request.Url;
    87|             if (url == null)
    88|                 return;
    89|             var path = url.LocalPath;
    90|             var contentType = context.Request.ContentType;
    91|             if (contentType != null && contentType.StartsWith("text/plain") && path.StartsWith("/"))
    92|             {
    93|                 path = path.Substring(1);
    94|                 if (Verbose)
    95|                     Console.WriteLine($"  writting POST stream to '{path}' file");
    96|                 var content = await new StreamReader(context.Request.InputStream).ReadToEndAsync().ConfigureAwait(false);
    97|                 await File.WriteAllTextAsync(path, content).ConfigureAwait(false);
    98|             }
    99|             else
   100|                 return;
   101|             var stream = context.Response.OutputStream;
   102|             stream.Close();
   103|             context.Response.Close();
   104|         }
   105|         private async void ServeAsync(HttpListenerContext context)
   106|         {
   107|             if (Verbose)
   108|                 Console.WriteLine("got GET request");
   109|             var request = context.Request;
   110|             var url = request.Url;
   111|             if (url == null)
   112|                 return;
   113|             string path = url.LocalPath == "/" ? "index.html" : url.LocalPath;
   114|             if (Verbose)
   115|                 Console.WriteLine($"  serving: {path}");
   116|             if (path.StartsWith("/"))
   117|                 path = path.Substring(1);
   118|             byte[]? buffer;
   119|             try
   120|             {
   121|                 buffer = await File.ReadAllBytesAsync(path).ConfigureAwait(false);
   122|             }
   123|             catch (Exception)
   124|             {
   125|                 buffer = null;
   126|             }
   127|             if (buffer != null)
   128|             {
   129|                 string? contentType = null;
   130|                 if (path.EndsWith(".wasm"))
   131|                     contentType = "application/wasm";
   132|                 if (path.EndsWith(".js") || path.EndsWith(".mjs") || path.EndsWith(".cjs"))
   133|                     contentType = "text/javascript";
   134|                 var stream = context.Response.OutputStream;
   135|                 if (url.Query.Contains("testError"))
   136|                 {
   137|                     Console.WriteLine("Faking 500 " + url);
   138|                     context.Response.StatusCode = (int)HttpStatusCode.InternalServerError;
   139|                     await stream.WriteAsync(buffer, 0, 0).ConfigureAwait(false);
   140|                     await stream.FlushAsync();
   141|                     context.Response.Close();
   142|                     return;
   143|                 }
   144|                 if (contentType != null)
   145|                     context.Response.ContentType = contentType;
   146|                 context.Response.ContentLength64 = buffer.Length;
   147|                 context.Response.AppendHeader("cache-control", "public, max-age=31536000");
   148|                 if (url.Query.Contains("testAbort"))
   149|                 {
   150|                     Console.WriteLine("Faking abort " + url);
   151|                     await stream.WriteAsync(buffer, 0, 10).ConfigureAwait(false);
   152|                     await stream.FlushAsync();
   153|                     await Task.Delay(100);
   154|                     context.Response.Abort();
   155|                     return;
   156|                 }
   157|                 try
   158|                 {
   159|                     await stream.WriteAsync(buffer).ConfigureAwait(false);
   160|                 }
   161|                 catch (Exception e)
   162|                 {
   163|                     if (Verbose)
   164|                         Console.WriteLine($"interrupted: {e.Message}");
   165|                 }
   166|                 stream.Close();
   167|                 context.Response.Close();
   168|             }
   169|             else
   170|             {
   171|                 if (Verbose)
   172|                     Console.WriteLine("  => not found");
   173|                 context.Response.StatusCode = (int)HttpStatusCode.NotFound;
   174|             }
   175|             if (Verbose)
   176|                 Console.WriteLine($"finished url: {context.Request.Url}");
   177|         }
   178|     }
   179| }


# ====================================================================
# FILE: src/mono/wasm/debugger/BrowserDebugProxy/MonoProxy.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1600 ---
     1| using System;
     2| using System.Collections.Generic;
     3| using System.IO;
     4| using System.Linq;
     5| using System.Threading;
     6| using System.Threading.Tasks;
     7| using Microsoft.CodeAnalysis;
     8| using Microsoft.Extensions.Logging;
     9| using Newtonsoft.Json;
    10| using Newtonsoft.Json.Linq;
    11| using System.Net.Http;
    12| using BrowserDebugProxy;
    13| namespace Microsoft.WebAssembly.Diagnostics
    14| {
    15|     internal class MonoProxy : DevToolsProxy
    16|     {
    17|         private IList<string> urlSymbolServerList;
    18|         private HashSet<SessionId> sessions = new HashSet<SessionId>();
    19|         protected Dictionary<SessionId, ExecutionContext> contexts = new Dictionary<SessionId, ExecutionContext>();
    20|         public static HttpClient HttpClient => new HttpClient();
    21|         public int RuntimeId { get; private init; }
    22|         public bool JustMyCode { get; private set; }
    23|         private PauseOnExceptionsKind _defaultPauseOnExceptions { get; set; }
    24|         protected readonly ProxyOptions _options;
    25|         public MonoProxy(ILogger logger, IList<string> urlSymbolServerList, int runtimeId = 0, string loggerId = "", ProxyOptions options = null) : base(logger, loggerId)
    26|         {
    27|             this.urlSymbolServerList = urlSymbolServerList ?? new List<string>();
    28|             RuntimeId = runtimeId;
    29|             _options = options;
    30|             _defaultPauseOnExceptions = PauseOnExceptionsKind.Unset;
    31|         }
    32|         internal ExecutionContext GetContext(SessionId sessionId)
    33|         {
    34|             if (contexts.TryGetValue(sessionId, out ExecutionContext context))
    35|                 return context;
    36|             throw new ArgumentException($"Invalid Session: \"{sessionId}\"", nameof(sessionId));
    37|         }
    38|         private bool UpdateContext(SessionId sessionId, ExecutionContext executionContext, out ExecutionContext previousExecutionContext)
    39|         {
    40|             bool previous = contexts.TryGetValue(sessionId, out previousExecutionContext);
    41|             contexts[sessionId] = executionContext;
    42|             return previous;
    43|         }
    44|         internal virtual Task<Result> SendMonoCommand(SessionId id, MonoCommands cmd, CancellationToken token) => SendCommand(id, "Runtime.evaluate", JObject.FromObject(cmd), token);
    45|         internal void SendLog(SessionId sessionId, string message, CancellationToken token, string type = "warning")
    46|         {
    47|             if (!contexts.TryGetValue(sessionId, out ExecutionContext context))
    48|                 return;
    49|             /*var o = JObject.FromObject(new
    50|             {
    51|                 entry = JObject.FromObject(new
    52|                 {
    53|                     source = "recommendation",
    54|                     level = "warning",
    55|                     text = message
    56|                 })
    57|             });
    58|             SendEvent(id, "Log.enabled", null, token);
    59|             SendEvent(id, "Log.entryAdded", o, token);*/
    60|             var o = JObject.FromObject(new
    61|             {
    62|                 type,
    63|                 args = new JArray(JObject.FromObject(new
    64|                                 {
    65|                                     type = "string",
    66|                                     value = message,
    67|                                 })),
    68|                 executionContextId = context.Id
    69|             });
    70|             SendEvent(sessionId, "Runtime.consoleAPICalled", o, token);
    71|         }
    72|         protected override async Task<bool> AcceptEvent(SessionId sessionId, JObject parms, CancellationToken token)
    73|         {
    74|             var method = parms["method"].Value<string>();
    75|             var args = parms["params"] as JObject;
    76|             switch (method)
    77|             {
    78|                 case "Runtime.consoleAPICalled":
    79|                     {
    80|                         if (!contexts.TryGetValue(sessionId, out ExecutionContext context))
    81|                             return false;
    82|                         string type = args["type"]?.ToString();
    83|                         if (type == "debug")
    84|                         {
    85|                             JToken a = args["args"];
    86|                             if (a is null)
    87|                                 break;
    88|                             int aCount = a.Count();
    89|                             if (aCount >= 2 &&
    90|                                 a[0]?["value"]?.ToString() == MonoConstants.RUNTIME_IS_READY &&
    91|                                 a[1]?["value"]?.ToString() == MonoConstants.RUNTIME_IS_READY_ID)
    92|                             {
    93|                                 if (aCount > 2)
    94|                                 {
    95|                                     try
    96|                                     {
    97|                                         string loaded = a[2]?["value"]?.ToString();
    98|                                         if (loaded != null)
    99|                                             context.LoadedFiles = JToken.Parse(loaded).ToObject<string[]>();
   100|                                     }
   101|                                     catch (InvalidCastException ice)
   102|                                     {
   103|                                         Log("verbose", ice.ToString());
   104|                                     }
   105|                                 }
   106|                                 await RuntimeReady(sessionId, token);
   107|                             }
   108|                             else if (aCount > 1 && a[0]?["value"]?.ToString() == MonoConstants.EVENT_RAISED)
   109|                             {
   110|                                 if (a.Type != JTokenType.Array)
   111|                                 {
   112|                                     logger.LogDebug($"Invalid event raised args, expected an array: {a.Type}");
   113|                                 }
   114|                                 else
   115|                                 {
   116|                                     if (aCount > 2 &&
   117|                                         JObjectTryParse(a?[2]?["value"]?.Value<string>(), out JObject raiseArgs) &&
   118|                                         JObjectTryParse(a?[1]?["value"]?.Value<string>(), out JObject eventArgs))
   119|                                     {
   120|                                         await OnJSEventRaised(sessionId, eventArgs, token);
   121|                                         if (raiseArgs?["trace"]?.Value<bool>() == true) {
   122|                                             return false;
   123|                                         }
   124|                                     }
   125|                                 }
   126|                                 return true;
   127|                             }
   128|                         }
   129|                         break;
   130|                     }
   131|                 case "Runtime.executionContextCreated":
   132|                     {
   133|                         await SendEvent(sessionId, method, args, token);
   134|                         JToken ctx = args?["context"];
   135|                         var aux_data = ctx?["auxData"] as JObject;
   136|                         int id = ctx["id"].Value<int>();
   137|                         if (aux_data != null)
   138|                         {
   139|                             bool? is_default = aux_data["isDefault"]?.Value<bool>();
   140|                             if (is_default == true)
   141|                             {
   142|                                 await OnDefaultContext(sessionId, new ExecutionContext(new MonoSDBHelper (this, logger, sessionId), id, aux_data, _defaultPauseOnExceptions), token);
   143|                             }
   144|                         }
   145|                         return true;
   146|                     }
   147|                 case "Debugger.paused":
   148|                     {
   149|                         if (!contexts.ContainsKey(sessionId))
   150|                             return false;
   151|                         if (args?["callFrames"]?.Value<JArray>()?.Count == 0)
   152|                             return false;
   153|                         string top_func = args?["callFrames"]?[0]?["functionName"]?.Value<string>();
   154|                         switch (top_func) {
   155|                             case "mono_wasm_set_entrypoint_breakpoint":
   156|                             case "_mono_wasm_set_entrypoint_breakpoint":
   157|                                 {
   158|                                     await OnSetEntrypointBreakpoint(sessionId, args, token);
   159|                                     return true;
   160|                                 }
   161|                             case "mono_wasm_runtime_ready":
   162|                             case "_mono_wasm_runtime_ready":
   163|                                 {
   164|                                     await RuntimeReady(sessionId, token);
   165|                                     await SendResume(sessionId, token);
   166|                                     return true;
   167|                                 }
   168|                             case "mono_wasm_fire_debugger_agent_message":
   169|                             case "_mono_wasm_fire_debugger_agent_message":
   170|                                 {
   171|                                     try {
   172|                                         return await OnReceiveDebuggerAgentEvent(sessionId, args, token);
   173|                                     }
   174|                                     catch (Exception) //if the page is refreshed maybe it stops here.
   175|                                     {
   176|                                         await SendResume(sessionId, token);
   177|                                         return true;
   178|                                     }
   179|                                 }
   180|                         }
   181|                         break;
   182|                     }
   183|                 case "Debugger.breakpointResolved":
   184|                     {
   185|                         break;
   186|                     }
   187|                 case "Debugger.scriptParsed":
   188|                     {
   189|                         string url = args?["url"]?.Value<string>() ?? "";
   190|                         switch (url)
   191|                         {
   192|                             case var _ when url == "":
   193|                             {
   194|                                 logger.LogTrace($"ignoring empty: Debugger.scriptParsed {url}");
   195|                                 return true;
   196|                             }
   197|                         }
   198|                         logger.LogTrace($"proxying Debugger.scriptParsed ({sessionId.sessionId}) {url} {args}");
   199|                         break;
   200|                     }
   201|                 case "Target.attachedToTarget":
   202|                     {
   203|                         if (args["targetInfo"]["type"]?.ToString() == "page")
   204|                             await AttachToTarget(new SessionId(args["sessionId"]?.ToString()), token);
   205|                         break;
   206|                     }
   207|                 case "Target.targetDestroyed":
   208|                     {
   209|                         await SendMonoCommand(sessionId, MonoCommands.DetachDebugger(RuntimeId), token);
   210|                         break;
   211|                     }
   212|             }
   213|             return false;
   214|         }
   215|         protected virtual async Task SendResume(SessionId id, CancellationToken token)
   216|         {
   217|             await SendCommand(id, "Debugger.resume", new JObject(), token);
   218|         }
   219|         protected async Task<bool> IsRuntimeAlreadyReadyAlready(SessionId sessionId, CancellationToken token)
   220|         {
   221|             if (contexts.TryGetValue(sessionId, out ExecutionContext context) && context.IsRuntimeReady)
   222|                 return true;
   223|             Result res = await SendMonoCommand(sessionId, MonoCommands.IsRuntimeReady(RuntimeId), token);
   224|             return res.Value?["result"]?["value"]?.Value<bool>() ?? false;
   225|         }
   226|         private static PauseOnExceptionsKind GetPauseOnExceptionsStatusFromString(string state)
   227|         {
   228|             PauseOnExceptionsKind pauseOnException;
   229|             if (Enum.TryParse(state, true, out pauseOnException))
   230|                 return pauseOnException;
   231|             return PauseOnExceptionsKind.Unset;
   232|         }
   233|         protected override async Task<bool> AcceptCommand(MessageId id, JObject parms, CancellationToken token)
   234|         {
   235|             var method = parms["method"].Value<string>();
   236|             var args = parms["params"] as JObject;
   237|             if (id == SessionId.Null)
   238|                 await AttachToTarget(id, token);
   239|             if (!contexts.TryGetValue(id, out ExecutionContext context))
   240|             {
   241|                 if  (method == "Debugger.setPauseOnExceptions")
   242|                 {
   243|                     string state = args["state"].Value<string>();
   244|                     var pauseOnException = GetPauseOnExceptionsStatusFromString(state);
   245|                     if (pauseOnException != PauseOnExceptionsKind.Unset)
   246|                         _defaultPauseOnExceptions = pauseOnException;
   247|                 }
   248|                 if (method != "DotnetDebugger.setDebuggerProperty")
   249|                 {
   250|                     return method.StartsWith("DotnetDebugger.", StringComparison.OrdinalIgnoreCase);
   251|                 }
   252|             }
   253|             switch (method)
   254|             {
   255|                 case "Target.attachToTarget":
   256|                     {
   257|                         Result resp = await SendCommand(id, method, args, token);
   258|                         await AttachToTarget(new SessionId(resp.Value["sessionId"]?.ToString()), token);
   259|                         break;
   260|                     }
   261|                 case "Debugger.enable":
   262|                     {
   263|                         Result resp = await SendCommand(id, method, args, token);
   264|                         if (!resp.IsOk)
   265|                         {
   266|                             SendResponse(id, resp, token);
   267|                             return true;
   268|                         }
   269|                         context.DebugId = resp.Value["DebugId"]?.ToString();
   270|                         if (await IsRuntimeAlreadyReadyAlready(id, token))
   271|                             await RuntimeReady(id, token);
   272|                         SendResponse(id, resp, token);
   273|                         return true;
   274|                     }
   275|                 case "Debugger.getScriptSource":
   276|                     {
   277|                         string script = args?["scriptId"]?.Value<string>();
   278|                         return await OnGetScriptSource(id, script, token);
   279|                     }
   280|                 case "Runtime.compileScript":
   281|                     {
   282|                         string exp = args?["expression"]?.Value<string>();
   283|                         if (exp.StartsWith("//dotnet:", StringComparison.Ordinal))
   284|                         {
   285|                             OnCompileDotnetScript(id, token);
   286|                             return true;
   287|                         }
   288|                         break;
   289|                     }
   290|                 case "Debugger.getPossibleBreakpoints":
   291|                     {
   292|                         Result resp = await SendCommand(id, method, args, token);
   293|                         if (resp.IsOk && resp.Value["locations"].HasValues)
   294|                         {
   295|                             SendResponse(id, resp, token);
   296|                             return true;
   297|                         }
   298|                         var start = SourceLocation.Parse(args?["start"] as JObject);
   299|                         var end = SourceLocation.Parse(args?["end"] as JObject);
   300|                         if (start != null && end != null && await GetPossibleBreakpoints(id, start, end, token))
   301|                             return true;
   302|                         SendResponse(id, resp, token);
   303|                         return true;
   304|                     }
   305|                 case "Debugger.setBreakpoint":
   306|                     {
   307|                         break;
   308|                     }
   309|                 case "Debugger.setBreakpointByUrl":
   310|                     {
   311|                         Result resp = await SendCommand(id, method, args, token);
   312|                         if (!resp.IsOk)
   313|                         {
   314|                             SendResponse(id, resp, token);
   315|                             return true;
   316|                         }
   317|                         try
   318|                         {
   319|                             string bpid = resp.Value["breakpointId"]?.ToString();
   320|                             IEnumerable<object> locations = resp.Value["locations"]?.Values<object>();
   321|                             var request = BreakpointRequest.Parse(bpid, args);
   322|                             bool loaded = context.Source.Task.IsCompleted;
   323|                             if (!loaded)
   324|                             {
   325|                                 context.BreakpointRequests[bpid] = request;
   326|                                 SendResponse(id, resp, token);
   327|                             }
   328|                             if (await IsRuntimeAlreadyReadyAlready(id, token))
   329|                             {
   330|                                 DebugStore store = await RuntimeReady(id, token);
   331|                                 Log("verbose", $"BP req {args}");
   332|                                 await SetBreakpoint(id, store, request, !loaded, false, token);
   333|                             }
   334|                             if (loaded)
   335|                             {
   336|                                 context.BreakpointRequests[bpid] = request;
   337|                                 var result = Result.OkFromObject(request.AsSetBreakpointByUrlResponse(locations));
   338|                                 SendResponse(id, result, token);
   339|                             }
   340|                         }
   341|                         catch (Exception e)
   342|                         {
   343|                             logger.LogDebug($"Debugger.setBreakpointByUrl - {args} - failed with exception: {e}");
   344|                             SendResponse(id, Result.Err($"Debugger.setBreakpointByUrl - {args} - failed with exception: {e}"), token);
   345|                         }
   346|                         return true;
   347|                     }
   348|                 case "Debugger.removeBreakpoint":
   349|                     {
   350|                         await RemoveBreakpoint(id, args, false, token);
   351|                         break;
   352|                     }
   353|                 case "Debugger.resume":
   354|                     {
   355|                         await OnResume(id, token);
   356|                         break;
   357|                     }
   358|                 case "Debugger.stepInto":
   359|                     {
   360|                         return await Step(id, StepKind.Into, token);
   361|                     }
   362|                 case "Debugger.setVariableValue":
   363|                     {
   364|                         if (!DotnetObjectId.TryParse(args?["callFrameId"], out DotnetObjectId objectId))
   365|                             return false;
   366|                         switch (objectId.Scheme)
   367|                         {
   368|                             case "scope":
   369|                                 return await OnSetVariableValue(id,
   370|                                     objectId.Value,
   371|                                     args?["variableName"]?.Value<string>(),
   372|                                     args?["newValue"],
   373|                                     token);
   374|                             default:
   375|                                 return false;
   376|                         }
   377|                     }
   378|                 case "Debugger.stepOut":
   379|                     {
   380|                         return await Step(id, StepKind.Out, token);
   381|                     }
   382|                 case "Debugger.stepOver":
   383|                     {
   384|                         return await Step(id, StepKind.Over, token);
   385|                     }
   386|                 case "Runtime.evaluate":
   387|                     {
   388|                         if (context.CallStack != null)
   389|                         {
   390|                             Frame scope = context.CallStack.First<Frame>();
   391|                             return await OnEvaluateOnCallFrame(id,
   392|                                     scope.Id,
   393|                                     args?["expression"]?.Value<string>(), token);
   394|                         }
   395|                         break;
   396|                     }
   397|                 case "Debugger.evaluateOnCallFrame":
   398|                     {
   399|                         if (!DotnetObjectId.TryParse(args?["callFrameId"], out DotnetObjectId objectId))
   400|                             return false;
   401|                         switch (objectId.Scheme)
   402|                         {
   403|                             case "scope":
   404|                                 return await OnEvaluateOnCallFrame(id,
   405|                                     objectId.Value,
   406|                                     args?["expression"]?.Value<string>(), token);
   407|                             default:
   408|                                 return false;
   409|                         }
   410|                     }
   411|                 case "Runtime.getProperties":
   412|                     {
   413|                         if (!DotnetObjectId.TryParse(args?["objectId"], out DotnetObjectId objectId))
   414|                             break;
   415|                         var valueOrError = await RuntimeGetObjectMembers(id, objectId, args, token, true);
   416|                         if (valueOrError.IsError)
   417|                         {
   418|                             logger.LogDebug($"Runtime.getProperties: {valueOrError.Error}");
   419|                             SendResponse(id, valueOrError.Error.Value, token);
   420|                             return true;
   421|                         }
   422|                         if (valueOrError.Value.JObject == null)
   423|                         {
   424|                             SendResponse(id, Result.Err($"Failed to get properties for '{objectId}'"), token);
   425|                             return true;
   426|                         }
   427|                         SendResponse(id, Result.OkFromObject(valueOrError.Value.JObject), token);
   428|                         return true;
   429|                     }
   430|                 case "Runtime.releaseObject":
   431|                     {
   432|                         if (!(DotnetObjectId.TryParse(args["objectId"], out DotnetObjectId objectId) && objectId.Scheme == "cfo_res"))
   433|                             break;
   434|                         await SendMonoCommand(id, MonoCommands.ReleaseObject(RuntimeId, objectId), token);
   435|                         SendResponse(id, Result.OkFromObject(new { }), token);
   436|                         return true;
   437|                     }
   438|                 case "Debugger.setPauseOnExceptions":
   439|                     {
   440|                         string state = args["state"].Value<string>();
   441|                         var pauseOnException = GetPauseOnExceptionsStatusFromString(state);
   442|                         if (pauseOnException != PauseOnExceptionsKind.Unset)
   443|                             context.PauseOnExceptions = pauseOnException;
   444|                         if (context.IsRuntimeReady)
   445|                             await context.SdbAgent.EnableExceptions(context.PauseOnExceptions, token);
   446|                         return false;
   447|                     }
   448|                 case "DotnetDebugger.setDebuggerProperty":
   449|                     {
   450|                         foreach (KeyValuePair<string, JToken> property in args)
   451|                         {
   452|                             switch (property.Key)
   453|                             {
   454|                                 case "JustMyCodeStepping":
   455|                                     SetJustMyCode(id, (bool) property.Value, token);
   456|                                 break;
   457|                                 default:
   458|                                     logger.LogDebug($"DotnetDebugger.setDebuggerProperty failed for {property.Key} with value {property.Value}");
   459|                                 break;
   460|                             }
   461|                         }
   462|                         return true;
   463|                     }
   464|                 case "DotnetDebugger.setNextIP":
   465|                     {
   466|                         var loc = SourceLocation.Parse(args?["location"] as JObject);
   467|                         if (loc == null)
   468|                             return false;
   469|                         bool ret = await OnSetNextIP(id, loc, token);
   470|                         if (ret)
   471|                             SendResponse(id, Result.OkFromObject(new { }), token);
   472|                         else
   473|                             SendResponse(id, Result.Err("Set next instruction pointer failed."), token);
   474|                         return true;
   475|                     }
   476|                 case "DotnetDebugger.applyUpdates":
   477|                     {
   478|                         if (await ApplyUpdates(id, args, token))
   479|                             SendResponse(id, Result.OkFromObject(new { }), token);
   480|                         else
   481|                             SendResponse(id, Result.Err("ApplyUpdate failed."), token);
   482|                         return true;
   483|                     }
   484|                 case "DotnetDebugger.addSymbolServerUrl":
   485|                     {
   486|                         string url = args["url"]?.Value<string>();
   487|                         if (!string.IsNullOrEmpty(url) && !urlSymbolServerList.Contains(url))
   488|                             urlSymbolServerList.Add(url);
   489|                         return true;
   490|                     }
   491|                 case "DotnetDebugger.getMethodLocation":
   492|                     {
   493|                         SendResponse(id, await GetMethodLocation(id, args, token), token);
   494|                         return true;
   495|                     }
   496|                 case "Runtime.callFunctionOn":
   497|                     {
   498|                         try {
   499|                             return await CallOnFunction(id, args, token);
   500|                         }
   501|                         catch (Exception ex) {
   502|                             logger.LogDebug($"Runtime.callFunctionOn failed for {id} with args {args}: {ex}");
   503|                             SendResponse(id,
   504|                                 Result.Exception(new ArgumentException(
   505|                                     $"Runtime.callFunctionOn not supported with ({args["objectId"]}).")),
   506|                                 token);
   507|                             return true;
   508|                         }
   509|                     }
   510|             }
   511|             return method.StartsWith("DotnetDebugger.", StringComparison.OrdinalIgnoreCase);
   512|         }
   513|         private async Task<bool> ApplyUpdates(MessageId id, JObject args, CancellationToken token)
   514|         {
   515|             var context = GetContext(id);
   516|             string moduleGUID = args["moduleGUID"]?.Value<string>();
   517|             string dmeta = args["dmeta"]?.Value<string>();
   518|             string dil = args["dil"]?.Value<string>();
   519|             string dpdb = args["dpdb"]?.Value<string>();
   520|             var moduleId = await context.SdbAgent.GetModuleId(moduleGUID, token);
   521|             var applyUpdates =  await context.SdbAgent.ApplyUpdates(moduleId, dmeta, dil, dpdb, token);
   522|             return applyUpdates;
   523|         }
   524|         private void SetJustMyCode(MessageId id, bool isEnabled, CancellationToken token)
   525|         {
   526|             JustMyCode = isEnabled;
   527|             SendResponse(id, Result.OkFromObject(new { justMyCodeEnabled = JustMyCode }), token);
   528|         }
   529|         internal async Task<Result> GetMethodLocation(MessageId id, JObject args, CancellationToken token)
   530|         {
   531|             DebugStore store = await RuntimeReady(id, token);
   532|             string aname = args["assemblyName"]?.Value<string>();
   533|             string typeName = args["typeName"]?.Value<string>();
   534|             string methodName = args["methodName"]?.Value<string>();
   535|             if (aname == null || typeName == null || methodName == null)
   536|             {
   537|                 return Result.Err("Invalid protocol message '" + args + "'.");
   538|             }
   539|             AssemblyInfo assembly = store.GetAssemblyByName(aname);
   540|             if (assembly == null)
   541|                 assembly = store.GetAssemblyByName(aname + ".exe");
   542|             if (assembly == null)
   543|                 assembly = store.GetAssemblyByName(aname + ".dll");
   544|             if (assembly == null)
   545|             {
   546|                 return Result.Err($"Assembly '{aname}' not found," +
   547|                                     $"needed to get method location of '{typeName}:{methodName}'");
   548|             }
   549|             TypeInfo type = assembly.GetTypeByName(typeName);
   550|             if (type == null)
   551|             {
   552|                 return Result.Err($"Type '{typeName}' not found.");
   553|             }
   554|             MethodInfo methodInfo = type.Methods.FirstOrDefault(m => m.Name == methodName);
   555|             if (methodInfo?.Source is null)
   556|             {
   557|                 methodInfo = assembly.TypesByName.Values.SingleOrDefault(t => t.FullName.StartsWith($"{typeName}.<{methodName}>"))?
   558|                     .Methods.FirstOrDefault(mi => mi.Name == "MoveNext");
   559|             }
   560|             if (methodInfo == null)
   561|             {
   562|                 return Result.Err($"Method '{typeName}:{methodName}' not found.");
   563|             }
   564|             string src_url = methodInfo.Assembly.Sources.Single(sf => sf.SourceId == methodInfo.SourceId).Url;
   565|             return Result.OkFromObject(new
   566|             {
   567|                 result = new { line = methodInfo.StartLocation.Line, column = methodInfo.StartLocation.Column, url = src_url }
   568|             });
   569|         }
   570|         private async Task<bool> CallOnFunction(MessageId id, JObject args, CancellationToken token)
   571|         {
   572|             var context = GetContext(id);
   573|             if (!DotnetObjectId.TryParse(args["objectId"], out DotnetObjectId objectId)) {
   574|                 return false;
   575|             }
   576|             switch (objectId.Scheme)
   577|             {
   578|                 case "method":
   579|                     args["details"] = await context.SdbAgent.GetMethodProxy(objectId.ValueAsJson, token);
   580|                     break;
   581|                 case "object":
   582|                     args["details"] = await context.SdbAgent.GetObjectProxy(objectId.Value, token);
   583|                     break;
   584|                 case "valuetype":
   585|                     var valueType = context.SdbAgent.GetValueTypeClass(objectId.Value);
   586|                     if (valueType == null)
   587|                         throw new Exception($"Internal Error: No valuetype found for {objectId}.");
   588|                     args["details"] = await valueType.GetProxy(context.SdbAgent, token);
   589|                     break;
   590|                 case "pointer":
   591|                     args["details"] = await context.SdbAgent.GetPointerContent(objectId.Value, token);
   592|                     break;
   593|                 case "array":
   594|                     args["details"] = await context.SdbAgent.GetArrayValuesProxy(objectId.Value, token);
   595|                     break;
   596|                 case "cfo_res":
   597|                     Result cfo_res = await SendMonoCommand(id, MonoCommands.CallFunctionOn(RuntimeId, args), token);
   598|                     cfo_res = Result.OkFromObject(new { result = cfo_res.Value?["result"]?["value"]});
   599|                     SendResponse(id, cfo_res, token);
   600|                     return true;
   601|                 case "scope":
   602|                 {
   603|                     SendResponse(id,
   604|                     Result.Exception(new ArgumentException(
   605|                         $"Runtime.callFunctionOn not supported with scope ({objectId}).")),
   606|                         token);
   607|                     return true;
   608|                 }
   609|                 default:
   610|                     return false;
   611|             }
   612|             Result res = await SendMonoCommand(id, MonoCommands.CallFunctionOn(RuntimeId, args), token);
   613|             if (!res.IsOk)
   614|             {
   615|                 SendResponse(id, res, token);
   616|                 return true;
   617|             }
   618|             if (res.Value?["result"]?["value"]?["type"] == null) //it means that is not a buffer returned from the debugger-agent
   619|             {
   620|                 byte[] newBytes = Convert.FromBase64String(res.Value?["result"]?["value"]?["value"]?.Value<string>());
   621|                 var retDebuggerCmdReader = new MonoBinaryReader(newBytes);
   622|                 retDebuggerCmdReader.ReadByte(); //number of objects returned.
   623|                 var obj = await context.SdbAgent.ValueCreator.ReadAsVariableValue(retDebuggerCmdReader, "ret", token);
   624|                 /*JTokenType? res_value_type = res.Value?["result"]?["value"]?.Type;*/
   625|                 res = Result.OkFromObject(new { result = obj["value"]});
   626|                 SendResponse(id, res, token);
   627|                 return true;
   628|             }
   629|             res = Result.OkFromObject(new { result = res.Value?["result"]?["value"]});
   630|             SendResponse(id, res, token);
   631|             return true;
   632|         }
   633|         private async Task<bool> OnSetVariableValue(MessageId id, int scopeId, string varName, JToken varValue, CancellationToken token)
   634|         {
   635|             ExecutionContext context = GetContext(id);
   636|             Frame scope = context.CallStack.FirstOrDefault(s => s.Id == scopeId);
   637|             if (scope == null)
   638|                 return false;
   639|             var varIds = scope.Method.Info.GetLiveVarsAt(scope.Location.IlLocation.Offset);
   640|             if (varIds == null)
   641|                 return false;
   642|             var varToSetValue = varIds.FirstOrDefault(v => v.Name == varName);
   643|             if (varToSetValue == null)
   644|                 return false;
   645|             var res = await context.SdbAgent.SetVariableValue(context.ThreadId, scopeId, varToSetValue.Index, varValue["value"].Value<string>(), token);
   646|             if (res)
   647|                 SendResponse(id, Result.Ok(new JObject()), token);
   648|             else
   649|                 SendResponse(id, Result.Err($"Unable to set '{varValue["value"].Value<string>()}' to variable '{varName}'"), token);
   650|             return true;
   651|         }
   652|         internal async Task<ValueOrError<GetMembersResult>> RuntimeGetObjectMembers(SessionId id, DotnetObjectId objectId, JToken args, CancellationToken token, bool sortByAccessLevel = false)
   653|         {
   654|             var context = GetContext(id);
   655|             GetObjectCommandOptions getObjectOptions = GetObjectCommandOptions.WithProperties;
   656|             if (args != null)
   657|             {
   658|                 if (args["accessorPropertiesOnly"]?.Value<bool>() == true)
   659|                     getObjectOptions |= GetObjectCommandOptions.AccessorPropertiesOnly;
   660|                 if (args["ownProperties"]?.Value<bool>() == true)
   661|                     getObjectOptions |= GetObjectCommandOptions.OwnProperties;
   662|                 if (args["forDebuggerDisplayAttribute"]?.Value<bool>() == true)
   663|                     getObjectOptions |= GetObjectCommandOptions.ForDebuggerDisplayAttribute;
   664|             }
   665|             if (JustMyCode)
   666|                 getObjectOptions |= GetObjectCommandOptions.JustMyCode;
   667|             try
   668|             {
   669|                 switch (objectId.Scheme)
   670|                 {
   671|                     case "scope":
   672|                         Result resScope = await GetScopeProperties(id, objectId.Value, token);
   673|                         return resScope.IsOk
   674|                             ? ValueOrError<GetMembersResult>.WithValue(
   675|                                 new GetMembersResult((JArray)resScope.Value?["result"], sortByAccessLevel: false))
   676|                             : ValueOrError<GetMembersResult>.WithError(resScope);
   677|                     case "valuetype":
   678|                         var resValue = await MemberObjectsExplorer.GetValueTypeMemberValues(
   679|                             context.SdbAgent, objectId.Value, getObjectOptions, token, sortByAccessLevel, includeStatic: true);
   680|                         return resValue switch
   681|                         {
   682|                             null => ValueOrError<GetMembersResult>.WithError($"Could not get properties for {objectId}"),
   683|                             _ => ValueOrError<GetMembersResult>.WithValue(resValue)
   684|                         };
   685|                     case "array":
   686|                         var resArr = await context.SdbAgent.GetArrayValues(objectId.Value, token);
   687|                         return ValueOrError<GetMembersResult>.WithValue(GetMembersResult.FromValues(resArr));
   688|                     case "method":
   689|                         var resMethod = await context.SdbAgent.InvokeMethod(objectId, token);
   690|                         return ValueOrError<GetMembersResult>.WithValue(GetMembersResult.FromValues(new JArray(resMethod)));
   691|                     case "object":
   692|                         var resObj = await MemberObjectsExplorer.GetObjectMemberValues(
   693|                             context.SdbAgent, objectId.Value, getObjectOptions, token, sortByAccessLevel, includeStatic: true);
   694|                         return ValueOrError<GetMembersResult>.WithValue(resObj);
   695|                     case "pointer":
   696|                         var resPointer = new JArray { await context.SdbAgent.GetPointerContent(objectId.Value, token) };
   697|                         return ValueOrError<GetMembersResult>.WithValue(GetMembersResult.FromValues(resPointer));
   698|                     case "cfo_res":
   699|                         Result res = await SendMonoCommand(id, MonoCommands.GetDetails(RuntimeId, objectId.Value, args), token);
   700|                         string value_json_str = res.Value["result"]?["value"]?["__value_as_json_string__"]?.Value<string>();
   701|                         if (res.IsOk && value_json_str == null)
   702|                             return ValueOrError<GetMembersResult>.WithError(
   703|                                 $"Internal error: Could not find expected __value_as_json_string__ field in the result: {res}");
   704|                         return value_json_str != null
   705|                                     ? ValueOrError<GetMembersResult>.WithValue(GetMembersResult.FromValues(JArray.Parse(value_json_str)))
   706|                                     : ValueOrError<GetMembersResult>.WithError(res);
   707|                     case "evaluationResult":
   708|                         JArray evaluationRes = (JArray)context.SdbAgent.GetEvaluationResultProperties(objectId.ToString());
   709|                         return ValueOrError<GetMembersResult>.WithValue(GetMembersResult.FromValues(evaluationRes));
   710|                     default:
   711|                         return ValueOrError<GetMembersResult>.WithError($"RuntimeGetProperties: unknown object id scheme: {objectId.Scheme}");
   712|                 }
   713|             }
   714|             catch (Exception ex)
   715|             {
   716|                 return ValueOrError<GetMembersResult>.WithError($"RuntimeGetProperties: Failed to get properties for {objectId}: {ex}");
   717|             }
   718|         }
   719|         protected async Task<bool> EvaluateCondition(SessionId sessionId, ExecutionContext context, Frame mono_frame, Breakpoint bp, CancellationToken token)
   720|         {
   721|             if (string.IsNullOrEmpty(bp?.Condition) || mono_frame == null)
   722|                 return true;
   723|             string condition = bp.Condition;
   724|             if (bp.ConditionAlreadyEvaluatedWithError)
   725|                 return false;
   726|             try {
   727|                 var resolver = new MemberReferenceResolver(this, context, sessionId, mono_frame.Id, logger);
   728|                 JObject retValue = await resolver.Resolve(condition, token);
   729|                 if (retValue == null)
   730|                     retValue = await ExpressionEvaluator.CompileAndRunTheExpression(condition, resolver, logger, token);
   731|                 if (retValue?["value"]?.Type == JTokenType.Boolean ||
   732|                     retValue?["value"]?.Type == JTokenType.Integer ||
   733|                     retValue?["value"]?.Type == JTokenType.Float) {
   734|                     if (retValue?["value"]?.Value<bool>() == true)
   735|                         return true;
   736|                 }
   737|                 else if (retValue?["value"] != null && // null object, missing value
   738|                          retValue?["value"]?.Type != JTokenType.Null)
   739|                 {
   740|                     return true;
   741|                 }
   742|             }
   743|             catch (ReturnAsErrorException raee)
   744|             {
   745|                 logger.LogDebug($"Unable to evaluate breakpoint condition '{condition}': {raee}");
   746|                 SendLog(sessionId, $"Unable to evaluate breakpoint condition '{condition}': {raee.Message}", token, type: "error");
   747|                 bp.ConditionAlreadyEvaluatedWithError = true;
   748|             }
   749|             catch (Exception e)
   750|             {
   751|                 Log("info", $"Unable to evaluate breakpoint condition '{condition}': {e}");
   752|                 bp.ConditionAlreadyEvaluatedWithError = true;
   753|             }
   754|             return false;
   755|         }
   756|         private async Task<bool> ProcessEnC(SessionId sessionId, ExecutionContext context, MonoBinaryReader retDebuggerCmdReader, CancellationToken token)
   757|         {
   758|             int moduleId = retDebuggerCmdReader.ReadInt32();
   759|             int meta_size = retDebuggerCmdReader.ReadInt32();
   760|             byte[] meta_buf = retDebuggerCmdReader.ReadBytes(meta_size);
   761|             int pdb_size = retDebuggerCmdReader.ReadInt32();
   762|             byte[] pdb_buf = retDebuggerCmdReader.ReadBytes(pdb_size);
   763|             var assemblyName = await context.SdbAgent.GetAssemblyNameFromModule(moduleId, token);
   764|             DebugStore store = await LoadStore(sessionId, true, token);
   765|             AssemblyInfo asm = store.GetAssemblyByName(assemblyName);
   766|             var methods = DebugStore.EnC(asm, meta_buf, pdb_buf);
   767|             foreach (var method in methods)
   768|             {
   769|                 await ResetBreakpoint(sessionId, store, method, token);
   770|             }
   771|             var files = methods.Distinct(new MethodInfo.SourceComparer());
   772|             foreach (var file in files)
   773|             {
   774|                 JObject scriptSource = JObject.FromObject(file.Source.ToScriptSource(context.Id, context.AuxData));
   775|                 Log("debug", $"sending after update {file.Source.Url} {context.Id} {sessionId.sessionId}");
   776|                 await SendEvent(sessionId, "Debugger.scriptParsed", scriptSource, token);
   777|             }
   778|             return true;
   779|         }
   780|         private async Task<bool> SendBreakpointsOfMethodUpdated(SessionId sessionId, ExecutionContext context, MonoBinaryReader retDebuggerCmdReader, CancellationToken token)
   781|         {
   782|             var methodId = retDebuggerCmdReader.ReadInt32();
   783|             var method = await context.SdbAgent.GetMethodInfo(methodId, token);
   784|             if (method == null || method.Info.Source is null)
   785|             {
   786|                 return true;
   787|             }
   788|             foreach (var req in context.BreakpointRequests.Values)
   789|             {
   790|                 if (req.TryResolve(method.Info.Source))
   791|                 {
   792|                     await SetBreakpoint(sessionId, context.store, req, true, true, token);
   793|                 }
   794|             }
   795|             return true;
   796|         }
   797|         protected virtual async Task<bool> ShouldSkipMethod(SessionId sessionId, ExecutionContext context, EventKind event_kind, int j, MethodInfoWithDebugInformation method, CancellationToken token)
   798|         {
   799|             var shouldReturn = await SkipMethod(
   800|                     isSkippable: context.IsSkippingHiddenMethod,
   801|                     shouldBeSkipped: event_kind != EventKind.UserBreak,
   802|                     StepKind.Over);
   803|             context.IsSkippingHiddenMethod = false;
   804|             if (shouldReturn)
   805|                 return true;
   806|             shouldReturn = await SkipMethod(
   807|                 isSkippable: context.IsSteppingThroughMethod,
   808|                 shouldBeSkipped: event_kind != EventKind.UserBreak && event_kind != EventKind.Breakpoint,
   809|                 StepKind.Over);
   810|             context.IsSteppingThroughMethod = false;
   811|             if (shouldReturn)
   812|                 return true;
   813|             if (j == 0 && method?.Info.DebuggerAttrInfo.DoAttributesAffectCallStack(JustMyCode) == true)
   814|             {
   815|                 if (method.Info.DebuggerAttrInfo.ShouldStepOut(event_kind))
   816|                 {
   817|                     if (event_kind == EventKind.Step)
   818|                         context.IsSkippingHiddenMethod = true;
   819|                     if (await SkipMethod(isSkippable: true, shouldBeSkipped: true, StepKind.Out))
   820|                         return true;
   821|                 }
   822|                 if (!method.Info.DebuggerAttrInfo.HasStepperBoundary)
   823|                 {
   824|                     if (event_kind == EventKind.Step ||
   825|                     (JustMyCode && (event_kind == EventKind.Breakpoint || event_kind == EventKind.UserBreak)))
   826|                     {
   827|                         if (context.IsResumedAfterBp)
   828|                             context.IsResumedAfterBp = false;
   829|                         else if (event_kind != EventKind.UserBreak)
   830|                             context.IsSteppingThroughMethod = true;
   831|                         if (await SkipMethod(isSkippable: true, shouldBeSkipped: true, StepKind.Out))
   832|                             return true;
   833|                     }
   834|                     if (event_kind == EventKind.Breakpoint)
   835|                         context.IsResumedAfterBp = true;
   836|                 }
   837|             }
   838|             return false;
   839|             async Task<bool> SkipMethod(bool isSkippable, bool shouldBeSkipped, StepKind stepKind)
   840|             {
   841|                 if (isSkippable && shouldBeSkipped)
   842|                 {
   843|                     await context.SdbAgent.Step(context.ThreadId, stepKind, token);
   844|                     await SendResume(sessionId, token);
   845|                     return true;
   846|                 }
   847|                 return false;
   848|             }
   849|         }
   850|         protected virtual async Task<bool> SendCallStack(SessionId sessionId, ExecutionContext context, string reason, int thread_id, Breakpoint bp, JObject data, JObject args, EventKind event_kind, CancellationToken token)
   851|         {
   852|             var orig_callframes = args?["callFrames"]?.Values<JObject>();
   853|             var callFrames = new List<object>();
   854|             var frames = new List<Frame>();
   855|             using var commandParamsWriter = new MonoBinaryWriter();
   856|             commandParamsWriter.Write(thread_id);
   857|             commandParamsWriter.Write(0);
   858|             commandParamsWriter.Write(-1);
   859|             using var retDebuggerCmdReader = await context.SdbAgent.SendDebuggerAgentCommand(CmdThread.GetFrameInfo, commandParamsWriter, token);
   860|             var frame_count = retDebuggerCmdReader.ReadInt32();
   861|             for (int j = 0; j < frame_count; j++) {
   862|                 var frame_id = retDebuggerCmdReader.ReadInt32();
   863|                 var methodId = retDebuggerCmdReader.ReadInt32();
   864|                 var il_pos = retDebuggerCmdReader.ReadInt32();
   865|                 var flags = retDebuggerCmdReader.ReadByte();
   866|                 DebugStore store = await LoadStore(sessionId, true, token);
   867|                 var method = await context.SdbAgent.GetMethodInfo(methodId, token);
   868|                 if (await ShouldSkipMethod(sessionId, context, event_kind, j, method, token))
   869|                     return true;
   870|                 SourceLocation location = method?.Info.GetLocationByIl(il_pos);
   871|                 if (location == null)
   872|                 {
   873|                     continue;
   874|                 }
   875|                 frames.Add(new Frame(method, location, frame_id));
   876|                 callFrames.Add(new
   877|                 {
   878|                     functionName = method.Name,
   879|                     callFrameId = $"dotnet:scope:{frame_id}",
   880|                     functionLocation = method.Info.StartLocation.AsLocation(),
   881|                     location = location.AsLocation(),
   882|                     url = store.ToUrl(location),
   883|                     scopeChain = new[]
   884|                         {
   885|                             new
   886|                             {
   887|                                 type = "local",
   888|                                     @object = new
   889|                                     {
   890|                                         @type = "object",
   891|                                             className = "Object",
   892|                                             description = "Object",
   893|                                             objectId = $"dotnet:scope:{frame_id}",
   894|                                     },
   895|                                     name = method.Name,
   896|                                     startLocation = method.Info.StartLocation.AsLocation(),
   897|                                     endLocation = method.Info.EndLocation.AsLocation(),
   898|                             }
   899|                         }
   900|                 });
   901|                 context.CallStack = frames;
   902|             }
   903|             string[] bp_list = new string[bp == null ? 0 : 1];
   904|             if (bp != null)
   905|                 bp_list[0] = bp.StackId;
   906|             foreach (JObject frame in orig_callframes)
   907|             {
   908|                 string function_name = frame["functionName"]?.Value<string>();
   909|                 string url = frame["url"]?.Value<string>();
   910|                 if (!(function_name.StartsWith("wasm-function", StringComparison.Ordinal) ||
   911|                         url.StartsWith("wasm://", StringComparison.Ordinal) ||
   912|                         url.EndsWith(".wasm", StringComparison.Ordinal) ||
   913|                         function_name == "_mono_wasm_fire_debugger_agent_message"))
   914|                 {
   915|                     callFrames.Add(frame);
   916|                 }
   917|             }
   918|             var o = JObject.FromObject(new
   919|             {
   920|                 callFrames,
   921|                 reason,
   922|                 data,
   923|                 hitBreakpoints = bp_list,
   924|             });
   925|             if (!await EvaluateCondition(sessionId, context, context.CallStack.First(), bp, token))
   926|             {
   927|                 context.ClearState();
   928|                 await SendResume(sessionId, token);
   929|                 return true;
   930|             }
   931|             await SendEvent(sessionId, "Debugger.paused", o, token);
   932|             return true;
   933|         }
   934|         internal virtual void SaveLastDebuggerAgentBufferReceivedToContext(SessionId sessionId, Result res)
   935|         {
   936|         }
   937|         internal async Task<bool> OnReceiveDebuggerAgentEvent(SessionId sessionId, JObject args, CancellationToken token)
   938|         {
   939|             Result res = await SendMonoCommand(sessionId, MonoCommands.GetDebuggerAgentBufferReceived(RuntimeId), token);
   940|             SaveLastDebuggerAgentBufferReceivedToContext(sessionId, res);
   941|             if (!res.IsOk)
   942|                 return false;
   943|             ExecutionContext context = GetContext(sessionId);
   944|             byte[] newBytes = Convert.FromBase64String(res.Value?["result"]?["value"]?["value"]?.Value<string>());
   945|             using var retDebuggerCmdReader = new MonoBinaryReader(newBytes);
   946|             retDebuggerCmdReader.ReadBytes(11); //skip HEADER_LEN
   947|             retDebuggerCmdReader.ReadByte(); //suspend_policy
   948|             var number_of_events = retDebuggerCmdReader.ReadInt32(); //number of events -> should be always one
   949|             for (int i = 0 ; i < number_of_events; i++) {
   950|                 var event_kind = (EventKind)retDebuggerCmdReader.ReadByte(); //event kind
   951|                 var request_id = retDebuggerCmdReader.ReadInt32(); //request id
   952|                 if (event_kind == EventKind.Step)
   953|                     await context.SdbAgent.ClearSingleStep(request_id, token);
   954|                 int thread_id = retDebuggerCmdReader.ReadInt32();
   955|                 context.ThreadId = thread_id;
   956|                 switch (event_kind)
   957|                 {
   958|                     case EventKind.MethodUpdate:
   959|                     {
   960|                         var ret = await SendBreakpointsOfMethodUpdated(sessionId, context, retDebuggerCmdReader, token);
   961|                         await SendResume(sessionId, token);
   962|                         return ret;
   963|                     }
   964|                     case EventKind.EnC:
   965|                     {
   966|                         var ret = await ProcessEnC(sessionId, context, retDebuggerCmdReader, token);
   967|                         await SendResume(sessionId, token);
   968|                         return ret;
   969|                     }
   970|                     case EventKind.Exception:
   971|                     {
   972|                         string reason = "exception";
   973|                         int object_id = retDebuggerCmdReader.ReadInt32();
   974|                         var caught = retDebuggerCmdReader.ReadByte();
   975|                         var exceptionObject = await MemberObjectsExplorer.GetObjectMemberValues(
   976|                             context.SdbAgent, object_id, GetObjectCommandOptions.WithProperties | GetObjectCommandOptions.OwnProperties, token);
   977|                         var exceptionObjectMessage = exceptionObject.FirstOrDefault(attr => attr["name"].Value<string>().Equals("_message"));
   978|                         var data = JObject.FromObject(new
   979|                         {
   980|                             type = "object",
   981|                             subtype = "error",
   982|                             className = await context.SdbAgent.GetClassNameFromObject(object_id, token),
   983|                             uncaught = caught == 0,
   984|                             description = exceptionObjectMessage["value"]["value"].Value<string>(),
   985|                             objectId = $"dotnet:object:{object_id}"
   986|                         });
   987|                         var ret = await SendCallStack(sessionId, context, reason, thread_id, null, data, args, event_kind, token);
   988|                         return ret;
   989|                     }
   990|                     case EventKind.UserBreak:
   991|                     case EventKind.Step:
   992|                     case EventKind.Breakpoint:
   993|                     {
   994|                         if (event_kind == EventKind.Step)
   995|                             context.PauseKind = "resumeLimit";
   996|                         else if (event_kind == EventKind.Breakpoint)
   997|                             context.PauseKind = "breakpoint";
   998|                         Breakpoint bp = context.BreakpointRequests.Values.SelectMany(v => v.Locations).FirstOrDefault(b => b.RemoteId == request_id);
   999|                         if (request_id == context.TempBreakpointForSetNextIP)
  1000|                         {
  1001|                             context.TempBreakpointForSetNextIP = -1;
  1002|                             await context.SdbAgent.RemoveBreakpoint(request_id, token);
  1003|                         }
  1004|                         string reason = "other";//other means breakpoint
  1005|                         int methodId = 0;
  1006|                         if (event_kind != EventKind.UserBreak)
  1007|                             methodId = retDebuggerCmdReader.ReadInt32();
  1008|                         var ret = await SendCallStack(sessionId, context, reason, thread_id, bp, null, args, event_kind, token);
  1009|                         return ret;
  1010|                     }
  1011|                 }
  1012|             }
  1013|             return false;
  1014|         }
  1015|         internal async Task<MethodInfo> LoadSymbolsOnDemand(AssemblyInfo asm, int method_token, SessionId sessionId, CancellationToken token)
  1016|         {
  1017|             ExecutionContext context = GetContext(sessionId);
  1018|             if (urlSymbolServerList.Count == 0)
  1019|                 return null;
  1020|             if (asm.TriedToLoadSymbolsOnDemand || !asm.CodeViewInformationAvailable)
  1021|                 return null;
  1022|             asm.TriedToLoadSymbolsOnDemand = true;
  1023|             var pdbName = Path.GetFileName(asm.PdbName);
  1024|             foreach (string urlSymbolServer in urlSymbolServerList)
  1025|             {
  1026|                 string downloadURL = $"{urlSymbolServer}/{pdbName}/{asm.PdbGuid.ToString("N").ToUpperInvariant() + asm.PdbAge}/{pdbName}";
  1027|                 try
  1028|                 {
  1029|                     using HttpResponseMessage response = await HttpClient.GetAsync(downloadURL, token);
  1030|                     if (!response.IsSuccessStatusCode)
  1031|                     {
  1032|                         Log("info", $"Unable to download symbols on demand url:{downloadURL} assembly: {asm.Name}");
  1033|                         continue;
  1034|                     }
  1035|                     using Stream streamToReadFrom = await response.Content.ReadAsStreamAsync(token);
  1036|                     asm.UpdatePdbInformation(streamToReadFrom);
  1037|                     foreach (SourceFile source in asm.Sources)
  1038|                     {
  1039|                         var scriptSource = JObject.FromObject(source.ToScriptSource(context.Id, context.AuxData));
  1040|                         await SendEvent(sessionId, "Debugger.scriptParsed", scriptSource, token);
  1041|                     }
  1042|                     return asm.GetMethodByToken(method_token);
  1043|                 }
  1044|                 catch (Exception e)
  1045|                 {
  1046|                     Log("info", $"Unable to load symbols on demand exception: {e} url:{downloadURL} assembly: {asm.Name}");
  1047|                 }
  1048|                 break;
  1049|             }
  1050|             Log("info", $"Unable to load symbols on demand assembly: {asm.Name}");
  1051|             return null;
  1052|         }
  1053|         protected void OnDefaultContextUpdate(SessionId sessionId, ExecutionContext context)
  1054|         {
  1055|             if (UpdateContext(sessionId, context, out ExecutionContext previousContext))
  1056|             {
  1057|                 foreach (KeyValuePair<string, BreakpointRequest> kvp in previousContext.BreakpointRequests)
  1058|                 {
  1059|                     context.BreakpointRequests[kvp.Key] = kvp.Value.Clone();
  1060|                 }
  1061|                 context.PauseOnExceptions = previousContext.PauseOnExceptions;
  1062|             }
  1063|         }
  1064|         protected async Task OnDefaultContext(SessionId sessionId, ExecutionContext context, CancellationToken token)
  1065|         {
  1066|             Log("verbose", "Default context created, clearing state and sending events");
  1067|             OnDefaultContextUpdate(sessionId, context);
  1068|             if (await IsRuntimeAlreadyReadyAlready(sessionId, token))
  1069|                 await RuntimeReady(sessionId, token);
  1070|         }
  1071|         protected async Task OnResume(MessageId msg_id, CancellationToken token)
  1072|         {
  1073|             ExecutionContext context = GetContext(msg_id);
  1074|             if (context.CallStack != null)
  1075|             {
  1076|                 await SendMonoCommand(msg_id, MonoCommands.Resume(RuntimeId), token);
  1077|             }
  1078|             GetContext(msg_id).ClearState();
  1079|         }
  1080|         protected async Task<bool> Step(MessageId msgId, StepKind kind, CancellationToken token)
  1081|         {
  1082|             ExecutionContext context = GetContext(msgId);
  1083|             if (context.CallStack == null)
  1084|                 return false;
  1085|             if (context.CallStack.Count <= 1 && kind == StepKind.Out)
  1086|                 return false;
  1087|             var step = await context.SdbAgent.Step(context.ThreadId, kind, token);
  1088|             if (step == false) {
  1089|                 context.ClearState();
  1090|                 await SendCommand(msgId, "Debugger.stepOut", new JObject(), token);
  1091|                 return false;
  1092|             }
  1093|             SendResponse(msgId, Result.Ok(new JObject()), token);
  1094|             context.ClearState();
  1095|             await SendResume(msgId, token);
  1096|             return true;
  1097|         }
  1098|         private async Task<bool> OnJSEventRaised(SessionId sessionId, JObject eventArgs, CancellationToken token)
  1099|         {
  1100|             string eventName = eventArgs?["eventName"]?.Value<string>();
  1101|             if (string.IsNullOrEmpty(eventName))
  1102|             {
  1103|                 logger.LogDebug($"Missing name for raised js event: {eventArgs}");
  1104|                 return false;
  1105|             }
  1106|             logger.LogDebug($"OnJsEventRaised: args: {eventArgs.ToString().TruncateLogMessage()}");
  1107|             switch (eventName)
  1108|             {
  1109|                 case "AssemblyLoaded":
  1110|                     return await OnAssemblyLoadedJSEvent(sessionId, eventArgs, token);
  1111|                 default:
  1112|                 {
  1113|                     logger.LogDebug($"Unknown js event name: {eventName} with args {eventArgs}");
  1114|                     return await Task.FromResult(false);
  1115|                 }
  1116|             }
  1117|         }
  1118|         private async Task<bool> OnAssemblyLoadedJSEvent(SessionId sessionId, JObject eventArgs, CancellationToken token)
  1119|         {
  1120|             try
  1121|             {
  1122|                 var store = await LoadStore(sessionId, true, token);
  1123|                 var assembly_name = eventArgs?["assembly_name"]?.Value<string>();
  1124|                 if (store.GetAssemblyByName(assembly_name) != null)
  1125|                 {
  1126|                     Log("debug", $"Got AssemblyLoaded event for {assembly_name}, but skipping it as it has already been loaded.");
  1127|                     return true;
  1128|                 }
  1129|                 var assembly_b64 = eventArgs?["assembly_b64"]?.ToObject<string>();
  1130|                 var pdb_b64 = eventArgs?["pdb_b64"]?.ToObject<string>();
  1131|                 if (string.IsNullOrEmpty(assembly_b64))
  1132|                 {
  1133|                     logger.LogDebug("No assembly data provided to load.");
  1134|                     return false;
  1135|                 }
  1136|                 var assembly_data = Convert.FromBase64String(assembly_b64);
  1137|                 var pdb_data = string.IsNullOrEmpty(pdb_b64) ? null : Convert.FromBase64String(pdb_b64);
  1138|                 var context = GetContext(sessionId);
  1139|                 foreach (var source in store.Add(sessionId, assembly_name, assembly_data, pdb_data, token))
  1140|                 {
  1141|                     await OnSourceFileAdded(sessionId, source, context, token);
  1142|                 }
  1143|                 return true;
  1144|             }
  1145|             catch (Exception e)
  1146|             {
  1147|                 logger.LogDebug($"Failed to load assemblies and PDBs: {e}");
  1148|                 return false;
  1149|             }
  1150|         }
  1151|         private async Task OnSetEntrypointBreakpoint(SessionId sessionId, JObject args, CancellationToken token)
  1152|         {
  1153|             try
  1154|             {
  1155|                 ExecutionContext context = GetContext(sessionId);
  1156|                 var argsNew = JObject.FromObject(new
  1157|                 {
  1158|                     callFrameId = args?["callFrames"]?[0]?["callFrameId"]?.Value<string>(),
  1159|                     expression = "_assembly_name_str + '|' + _entrypoint_method_token",
  1160|                 });
  1161|                 Result assemblyAndMethodToken = await SendCommand(sessionId, "Debugger.evaluateOnCallFrame", argsNew, token);
  1162|                 if (!assemblyAndMethodToken.IsOk)
  1163|                 {
  1164|                     logger.LogDebug("Failure evaluating _assembly_name_str + '|' + _entrypoint_method_token");
  1165|                     return;
  1166|                 }
  1167|                 logger.LogDebug($"Entrypoint assembly and method token {assemblyAndMethodToken.Value["result"]["value"].Value<string>()}");
  1168|                 var assemblyAndMethodTokenArr = assemblyAndMethodToken.Value["result"]["value"].Value<string>().Split('|', StringSplitOptions.TrimEntries);
  1169|                 var assemblyName = assemblyAndMethodTokenArr[0];
  1170|                 var methodToken = Convert.ToInt32(assemblyAndMethodTokenArr[1]) & 0xffffff; //token
  1171|                 var store = await LoadStore(sessionId, true, token);
  1172|                 AssemblyInfo assembly = store.GetAssemblyByName(assemblyName);
  1173|                 if (assembly == null)
  1174|                 {
  1175|                     logger.LogDebug($"Could not find entrypoint assembly {assemblyName} in the store");
  1176|                     return;
  1177|                 }
  1178|                 var method = assembly.GetMethodByToken(methodToken);
  1179|                 if (method.StartLocation == null) //It's an async method and we need to get the MoveNext method to add the breakpoint
  1180|                     method = assembly.Methods.FirstOrDefault(m => m.Value.KickOffMethod == methodToken).Value;
  1181|                 if (method == null)
  1182|                 {
  1183|                     logger.LogDebug($"Could not find entrypoint method {methodToken} in assembly {assemblyName}");
  1184|                     return;
  1185|                 }
  1186|                 var sourceFile = assembly.Sources.FirstOrDefault(sf => sf.SourceId == method.SourceId);
  1187|                 if (sourceFile == null)
  1188|                 {
  1189|                     logger.LogDebug($"Could not source file {method.SourceName} for method {method.Name} in assembly {assemblyName}");
  1190|                     return;
  1191|                 }
  1192|                 string bpId = $"auto:{method.StartLocation.Line}:{method.StartLocation.Column}:{sourceFile.DotNetUrl}";
  1193|                 BreakpointRequest request = new(bpId, JObject.FromObject(new
  1194|                 {
  1195|                     lineNumber = method.StartLocation.Line,
  1196|                     columnNumber = method.StartLocation.Column,
  1197|                     url = sourceFile.Url
  1198|                 }));
  1199|                 context.BreakpointRequests[bpId] = request;
  1200|                 if (request.TryResolve(sourceFile))
  1201|                     await SetBreakpoint(sessionId, context.store, request, sendResolvedEvent: false, fromEnC: false, token);
  1202|                 logger.LogInformation($"Adding bp req {request}");
  1203|             }
  1204|             catch (Exception e)
  1205|             {
  1206|                 logger.LogDebug($"Unable to set entrypoint breakpoint. {e}");
  1207|             }
  1208|             finally
  1209|             {
  1210|                 await SendResume(sessionId, token);
  1211|             }
  1212|         }
  1213|         private async Task<bool> OnEvaluateOnCallFrame(MessageId msg_id, int scopeId, string expression, CancellationToken token)
  1214|         {
  1215|             try
  1216|             {
  1217|                 ExecutionContext context = GetContext(msg_id);
  1218|                 if (context.CallStack == null)
  1219|                     return false;
  1220|                 var resolver = new MemberReferenceResolver(this, context, msg_id, scopeId, logger);
  1221|                 JObject retValue = await resolver.Resolve(expression, token);
  1222|                 if (retValue == null)
  1223|                 {
  1224|                     retValue = await ExpressionEvaluator.CompileAndRunTheExpression(expression, resolver, logger, token);
  1225|                 }
  1226|                 if (retValue != null)
  1227|                 {
  1228|                     SendResponse(msg_id, Result.OkFromObject(new
  1229|                     {
  1230|                         result = retValue
  1231|                     }), token);
  1232|                 }
  1233|                 else
  1234|                 {
  1235|                     SendResponse(msg_id, Result.Err($"Unable to evaluate '{expression}'"), token);
  1236|                 }
  1237|             }
  1238|             catch (ReturnAsErrorException ree)
  1239|             {
  1240|                 SendResponse(msg_id, ree.Error, token);
  1241|             }
  1242|             catch (ExpressionEvaluationFailedException eefe)
  1243|             {
  1244|                 logger.LogDebug($"Error in EvaluateOnCallFrame for expression '{expression}' with '{eefe}.");
  1245|                 SendResponse(msg_id, Result.Exception(eefe), token);
  1246|             }
  1247|             catch (Exception e)
  1248|             {
  1249|                 logger.LogDebug($"Error in EvaluateOnCallFrame for expression '{expression}' with '{e}.");
  1250|                 SendResponse(msg_id, Result.Exception(e), token);
  1251|             }
  1252|             return true;
  1253|         }
  1254|         internal async Task<Result> GetScopeProperties(SessionId msg_id, int scopeId, CancellationToken token)
  1255|         {
  1256|             try
  1257|             {
  1258|                 ExecutionContext context = GetContext(msg_id);
  1259|                 Frame scope = context.CallStack.FirstOrDefault(s => s.Id == scopeId);
  1260|                 if (scope == null)
  1261|                     return Result.Err(JObject.FromObject(new { message = $"Could not find scope with id #{scopeId}" }));
  1262|                 VarInfo[] varIds = scope.Method.Info.GetLiveVarsAt(scope.Location.IlLocation.Offset);
  1263|                 var values = await context.SdbAgent.StackFrameGetValues(scope.Method, context.ThreadId, scopeId, varIds, scope.Location.IlLocation.Offset, token);
  1264|                 if (values != null)
  1265|                 {
  1266|                     if (values == null || values.Count == 0)
  1267|                         return Result.OkFromObject(new { result = Array.Empty<object>() });
  1268|                     PerScopeCache frameCache = context.GetCacheForScope(scopeId);
  1269|                     foreach (JObject value in values)
  1270|                     {
  1271|                         frameCache.Locals[value["name"]?.Value<string>()] = value;
  1272|                     }
  1273|                     return Result.OkFromObject(new { result = values });
  1274|                 }
  1275|                 return Result.OkFromObject(new { result = Array.Empty<object>() });
  1276|             }
  1277|             catch (Exception exception)
  1278|             {
  1279|                 Log("verbose", $"Error resolving scope properties {exception.Message}");
  1280|                 return Result.Exception(exception);
  1281|             }
  1282|         }
  1283|         private async Task<Breakpoint> SetMonoBreakpoint(SessionId sessionId, string reqId, SourceLocation location, string condition, CancellationToken token)
  1284|         {
  1285|             var context = GetContext(sessionId);
  1286|             var bp = new Breakpoint(reqId, location, condition, BreakpointState.Pending);
  1287|             string asm_name = bp.Location.IlLocation.Method.Assembly.Name;
  1288|             int method_token = bp.Location.IlLocation.Method.Token;
  1289|             int il_offset = bp.Location.IlLocation.Offset;
  1290|             var assembly_id = await context.SdbAgent.GetAssemblyId(asm_name, token);
  1291|             var methodId = await context.SdbAgent.GetMethodIdByToken(assembly_id, method_token, token);
  1292|             var breakpoint_id = await context.SdbAgent.SetBreakpointNoThrow(methodId, il_offset, token);
  1293|             if (breakpoint_id > 0)
  1294|             {
  1295|                 bp.RemoteId = breakpoint_id;
  1296|                 bp.State = BreakpointState.Active;
  1297|             }
  1298|             return bp;
  1299|         }
  1300|         internal virtual async Task OnSourceFileAdded(SessionId sessionId, SourceFile source, ExecutionContext context, CancellationToken token)
  1301|         {
  1302|             JObject scriptSource = JObject.FromObject(source.ToScriptSource(context.Id, context.AuxData));
  1303|             await SendEvent(sessionId, "Debugger.scriptParsed", scriptSource, token);
  1304|             foreach (var req in context.BreakpointRequests.Values)
  1305|             {
  1306|                 if (req.TryResolve(source))
  1307|                 {
  1308|                     await SetBreakpoint(sessionId, context.store, req, true, false, token);
  1309|                 }
  1310|             }
  1311|         }
  1312|         internal virtual async Task<DebugStore> LoadStore(SessionId sessionId, bool tryUseDebuggerProtocol, CancellationToken token)
  1313|         {
  1314|             ExecutionContext context = GetContext(sessionId);
  1315|             if (Interlocked.CompareExchange(ref context.store, new DebugStore(this, logger), null) != null)
  1316|                 return await context.Source.Task;
  1317|             try
  1318|             {
  1319|                 string[] loaded_files = await GetLoadedFiles(sessionId, context, token);
  1320|                 if (loaded_files == null)
  1321|                 {
  1322|                     SendLog(sessionId, $"Failed to get the list of loaded files. Managed code debugging won't work due to this.", token);
  1323|                 }
  1324|                 else
  1325|                 {
  1326|                     var useDebuggerProtocol = false;
  1327|                     if (tryUseDebuggerProtocol)
  1328|                     {
  1329|                         (int MajorVersion, int MinorVersion) = await context.SdbAgent.GetVMVersion(token);
  1330|                         if (MajorVersion == 2 && MinorVersion >= 61)
  1331|                             useDebuggerProtocol = true;
  1332|                     }
  1333|                     await foreach (SourceFile source in context.store.Load(sessionId, loaded_files, context, useDebuggerProtocol, token))
  1334|                     {
  1335|                         await OnSourceFileAdded(sessionId, source, context, token);
  1336|                     }
  1337|                 }
  1338|             }
  1339|             catch (Exception e)
  1340|             {
  1341|                 logger.LogError($"failed: {e}");
  1342|                 context.Source.SetException(e);
  1343|             }
  1344|             if (!context.Source.Task.IsCompleted)
  1345|                 context.Source.SetResult(context.store);
  1346|             return context.store;
  1347|             async Task<string[]> GetLoadedFiles(SessionId sessionId, ExecutionContext context, CancellationToken token)
  1348|             {
  1349|                 if (context.LoadedFiles != null)
  1350|                     return context.LoadedFiles;
  1351|                 Result loaded = await SendMonoCommand(sessionId, MonoCommands.GetLoadedFiles(RuntimeId), token);
  1352|                 if (!loaded.IsOk)
  1353|                 {
  1354|                     SendLog(sessionId, $"Error on mono_wasm_get_loaded_files {loaded}", token);
  1355|                     return null;
  1356|                 }
  1357|                 string[] files = loaded.Value?["result"]?["value"]?.ToObject<string[]>();
  1358|                 if (files == null)
  1359|                     SendLog(sessionId, $"Error extracting the list of loaded_files from the result of mono_wasm_get_loaded_files: {loaded}", token);
  1360|                 return files;
  1361|             }
  1362|         }
  1363|         protected async Task<DebugStore> RuntimeReady(SessionId sessionId, CancellationToken token)
  1364|         {
  1365|             try
  1366|             {
  1367|                 ExecutionContext context = GetContext(sessionId);
  1368|                 if (Interlocked.CompareExchange(ref context.ready, new TaskCompletionSource<DebugStore>(), null) != null)
  1369|                     return await context.ready.Task;
  1370|                 await context.SdbAgent.SendDebuggerAgentCommand(CmdEventRequest.ClearAllBreakpoints, null, token);
  1371|                 if (context.PauseOnExceptions != PauseOnExceptionsKind.None && context.PauseOnExceptions != PauseOnExceptionsKind.Unset)
  1372|                     await context.SdbAgent.EnableExceptions(context.PauseOnExceptions, token);
  1373|                 await context.SdbAgent.SetProtocolVersion(token);
  1374|                 await context.SdbAgent.EnableReceiveRequests(EventKind.UserBreak, token);
  1375|                 await context.SdbAgent.EnableReceiveRequests(EventKind.EnC, token);
  1376|                 await context.SdbAgent.EnableReceiveRequests(EventKind.MethodUpdate, token);
  1377|                 DebugStore store = await LoadStore(sessionId, true, token);
  1378|                 context.ready.SetResult(store);
  1379|                 await SendEvent(sessionId, "Mono.runtimeReady", new JObject(), token);
  1380|                 await SendMonoCommand(sessionId, MonoCommands.SetDebuggerAttached(RuntimeId), token);
  1381|                 context.SdbAgent.ResetStore(store);
  1382|                 return store;
  1383|             }
  1384|             catch (DebuggerAgentException e)
  1385|             {
  1386|                 if (!e.Message.Contains("getDotnetRuntime is not defined"))
  1387|                     logger.LogDebug($"Unexpected error on RuntimeReady {e}");
  1388|                 return null;
  1389|             }
  1390|             catch (Exception e)
  1391|             {
  1392|                 logger.LogDebug($"Unexpected error on RuntimeReady {e}");
  1393|                 return null;
  1394|             }
  1395|         }
  1396|         private static IEnumerable<IGrouping<SourceId, SourceLocation>> GetBPReqLocations(DebugStore store, BreakpointRequest req, bool ifNoneFoundThenFindNext = false)
  1397|         {
  1398|             var comparer = new SourceLocation.LocationComparer();
  1399|             var bpLocations = store.FindBreakpointLocations(req, ifNoneFoundThenFindNext);
  1400|             IEnumerable<IGrouping<SourceId, SourceLocation>> locations = bpLocations.Distinct(comparer)
  1401|                 .OrderBy(l => l.Column)
  1402|                 .GroupBy(l => l.Id);
  1403|             if (ifNoneFoundThenFindNext && !locations.Any())
  1404|             {
  1405|                 locations = bpLocations.GroupBy(l => l.Id);
  1406|             }
  1407|             return locations;
  1408|         }
  1409|         private async Task ResetBreakpoint(SessionId msg_id, DebugStore store, MethodInfo method, CancellationToken token)
  1410|         {
  1411|             ExecutionContext context = GetContext(msg_id);
  1412|             foreach (var req in context.BreakpointRequests.Values)
  1413|             {
  1414|                 if (req.Method != null)
  1415|                 {
  1416|                     if (req.Method.Assembly.Id == method.Assembly.Id && req.Method.Token == method.Token) {
  1417|                         var locations = GetBPReqLocations(store, req);
  1418|                         foreach (IGrouping<SourceId, SourceLocation> sourceId in locations)
  1419|                         {
  1420|                             SourceLocation loc = sourceId.First();
  1421|                             if (req.Locations.Any(b => b.Location.IlLocation.Offset != loc.IlLocation.Offset))
  1422|                             {
  1423|                                 await RemoveBreakpoint(msg_id, JObject.FromObject(new {breakpointId = req.Id}), true, token);
  1424|                                 break;
  1425|                             }
  1426|                         }
  1427|                     }
  1428|                 }
  1429|             }
  1430|         }
  1431|         protected async Task RemoveBreakpoint(SessionId msg_id, JObject args, bool isEnCReset, CancellationToken token)
  1432|         {
  1433|             string bpid = args?["breakpointId"]?.Value<string>();
  1434|             ExecutionContext context = GetContext(msg_id);
  1435|             if (!context.BreakpointRequests.TryGetValue(bpid, out BreakpointRequest breakpointRequest))
  1436|                 return;
  1437|             foreach (Breakpoint bp in breakpointRequest.Locations)
  1438|             {
  1439|                 var breakpoint_removed = await context.SdbAgent.RemoveBreakpoint(bp.RemoteId, token);
  1440|                 if (breakpoint_removed)
  1441|                 {
  1442|                     bp.RemoteId = -1;
  1443|                     if (isEnCReset)
  1444|                         bp.State = BreakpointState.Pending;
  1445|                     else
  1446|                         bp.State = BreakpointState.Disabled;
  1447|                 }
  1448|             }
  1449|             if (!isEnCReset)
  1450|                 context.BreakpointRequests.Remove(bpid);
  1451|         }
  1452|         protected async Task SetBreakpoint(SessionId sessionId, DebugStore store, BreakpointRequest req, bool sendResolvedEvent, bool fromEnC, CancellationToken token)
  1453|         {
  1454|             ExecutionContext context = GetContext(sessionId);
  1455|             if ((!fromEnC && req.Locations.Any()) || (fromEnC && req.Locations.Any(bp => bp.State == BreakpointState.Active)))
  1456|             {
  1457|                 if (!fromEnC)
  1458|                     Log("debug", $"locations already loaded for {req.Id}");
  1459|                 return;
  1460|             }
  1461|             var locations = GetBPReqLocations(store, req, true);
  1462|             logger.LogDebug("BP request for '{Req}' runtime ready {Context.RuntimeReady}", req, context.IsRuntimeReady);
  1463|             var breakpoints = new List<Breakpoint>();
  1464|             foreach (IGrouping<SourceId, SourceLocation> sourceId in locations)
  1465|             {
  1466|                 SourceLocation loc = sourceId.First();
  1467|                 req.Method = loc.IlLocation.Method;
  1468|                 if (req.Method.DebuggerAttrInfo.HasDebuggerHidden)
  1469|                     continue;
  1470|                 Breakpoint bp = await SetMonoBreakpoint(sessionId, req.Id, loc, req.Condition, token);
  1471|                 if (bp.State != BreakpointState.Active)
  1472|                     continue;
  1473|                 breakpoints.Add(bp);
  1474|                 var resolvedLocation = new
  1475|                 {
  1476|                     breakpointId = req.Id,
  1477|                     location = loc.AsLocation()
  1478|                 };
  1479|                 if (sendResolvedEvent)
  1480|                     await SendEvent(sessionId, "Debugger.breakpointResolved", JObject.FromObject(resolvedLocation), token);
  1481|             }
  1482|             req.Locations.AddRange(breakpoints);
  1483|             return;
  1484|         }
  1485|         private async Task<bool> GetPossibleBreakpoints(MessageId msg, SourceLocation start, SourceLocation end, CancellationToken token)
  1486|         {
  1487|             List<SourceLocation> bps = (await RuntimeReady(msg, token)).FindPossibleBreakpoints(start, end);
  1488|             if (bps == null)
  1489|                 return false;
  1490|             var response = new { locations = bps.Select(b => b.AsLocation()) };
  1491|             SendResponse(msg, Result.OkFromObject(response), token);
  1492|             return true;
  1493|         }
  1494|         private void OnCompileDotnetScript(MessageId msg_id, CancellationToken token)
  1495|         {
  1496|             SendResponse(msg_id, Result.OkFromObject(new { }), token);
  1497|         }
  1498|         private static bool IsNestedMethod(DebugStore store, Frame scope, SourceLocation foundLocation, SourceLocation targetLocation)
  1499|         {
  1500|             if (foundLocation.Line != targetLocation.Line || foundLocation.Column != targetLocation.Column)
  1501|             {
  1502|                 SourceFile doc = store.GetFileById(scope.Method.Info.SourceId);
  1503|                 foreach (var method in doc.Methods)
  1504|                 {
  1505|                     if (method.Token == scope.Method.Info.Token)
  1506|                         continue;
  1507|                     if (method.IsLexicallyContainedInMethod(scope.Method.Info))
  1508|                         continue;
  1509|                     SourceLocation newFoundLocation = DebugStore.FindBreakpointLocations(targetLocation, targetLocation, scope.Method.Info)
  1510|                                                 .FirstOrDefault();
  1511|                     if (!(newFoundLocation is null))
  1512|                         return true;
  1513|                 }
  1514|             }
  1515|             return false;
  1516|         }
  1517|         private async Task<bool> OnSetNextIP(MessageId sessionId, SourceLocation targetLocation, CancellationToken token)
  1518|         {
  1519|             DebugStore store = await RuntimeReady(sessionId, token);
  1520|             ExecutionContext context = GetContext(sessionId);
  1521|             Frame scope = context.CallStack.First<Frame>();
  1522|             SourceLocation foundLocation = DebugStore.FindBreakpointLocations(targetLocation, targetLocation, scope.Method.Info)
  1523|                                                     .FirstOrDefault();
  1524|             if (foundLocation is null)
  1525|                  return false;
  1526|             if (IsNestedMethod(store, scope, foundLocation, targetLocation))
  1527|                 return false;
  1528|             var ilOffset = foundLocation.IlLocation;
  1529|             var ret = await context.SdbAgent.SetNextIP(scope.Method, context.ThreadId, ilOffset, token);
  1530|             if (!ret)
  1531|                 return false;
  1532|             var breakpointId = await context.SdbAgent.SetBreakpointNoThrow(scope.Method.DebugId, ilOffset.Offset, token);
  1533|             if (breakpointId == -1)
  1534|                 return false;
  1535|             context.TempBreakpointForSetNextIP = breakpointId;
  1536|             await SendResume(sessionId, token);
  1537|             return true;
  1538|         }
  1539|         internal virtual async Task<bool> OnGetScriptSource(MessageId msg_id, string script_id, CancellationToken token)
  1540|         {
  1541|             if (!SourceId.TryParse(script_id, out SourceId id))
  1542|                 return false;
  1543|             SourceFile src_file = (await LoadStore(msg_id, true, token)).GetFileById(id);
  1544|             try
  1545|             {
  1546|                 var uri = new Uri(src_file.Url);
  1547|                 string source = $"// Unable to find document {src_file.SourceUri}";
  1548|                 using (Stream data = await src_file.GetSourceAsync(checkHash: false, token: token))
  1549|                 {
  1550|                     if (data is MemoryStream && data.Length == 0)
  1551|                         return false;
  1552|                     using (var reader = new StreamReader(data))
  1553|                         source = await reader.ReadToEndAsync(token);
  1554|                 }
  1555|                 SendResponse(msg_id, Result.OkFromObject(new { scriptSource = source }), token);
  1556|             }
  1557|             catch (Exception e)
  1558|             {
  1559|                 var o = new
  1560|                 {
  1561|                     scriptSource = $"// Unable to read document ({e.Message})\n" +
  1562|                     $"Local path: {src_file?.SourceUri}\n" +
  1563|                     $"SourceLink path: {src_file?.SourceLinkUri}\n"
  1564|                 };
  1565|                 SendResponse(msg_id, Result.OkFromObject(o), token);
  1566|             }
  1567|             return true;
  1568|         }
  1569|         private async Task AttachToTarget(SessionId sessionId, CancellationToken token)
  1570|         {
  1571|             if (sessions.Add(sessionId))
  1572|             {
  1573|                 await SendMonoCommand(sessionId, new MonoCommands("globalThis.dotnetDebugger = true"), token);
  1574|                 Result res = await SendCommand(sessionId,
  1575|                     "Page.addScriptToEvaluateOnNewDocument",
  1576|                     JObject.FromObject(new { source = $"globalThis.dotnetDebugger = true; delete navigator.constructor.prototype.webdriver;" }),
  1577|                     token);
  1578|                 if (sessionId != SessionId.Null && !res.IsOk)
  1579|                     sessions.Remove(sessionId);
  1580|             }
  1581|         }
  1582|         private bool JObjectTryParse(string str, out JObject obj, bool log_exception = true)
  1583|         {
  1584|             obj = null;
  1585|             if (string.IsNullOrEmpty(str))
  1586|                 return false;
  1587|             try
  1588|             {
  1589|                 obj = JObject.Parse(str);
  1590|                 return true;
  1591|             }
  1592|             catch (JsonReaderException jre)
  1593|             {
  1594|                 if (log_exception)
  1595|                     logger.LogDebug($"Could not parse {str}. Failed with {jre}");
  1596|                 return false;
  1597|             }
  1598|         }
  1599|     }
  1600| }


# ====================================================================
# FILE: src/mono/wasm/runtime/assets.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-453 ---
     1| import cwraps from "./cwraps";
     2| import { mono_wasm_load_icu_data } from "./icu";
     3| import { ENVIRONMENT_IS_NODE, ENVIRONMENT_IS_SHELL, ENVIRONMENT_IS_WEB, Module, runtimeHelpers } from "./imports";
     4| import { mono_wasm_load_bytes_into_heap } from "./memory";
     5| import { MONO } from "./net6-legacy/imports";
     6| import { createPromiseController, PromiseAndController } from "./promise-controller";
     7| import { delay } from "./promise-utils";
     8| import { abort_startup, beforeOnRuntimeInitialized } from "./startup";
     9| import { AssetBehaviours, AssetEntry, AssetEntryInternal, LoadingResource, mono_assert, ResourceRequest } from "./types";
    10| import { InstantiateWasmSuccessCallback, VoidPtr } from "./types/emscripten";
    11| const allAssetsInMemory = createPromiseController<void>();
    12| const allDownloadsQueued = createPromiseController<void>();
    13| let actual_downloaded_assets_count = 0;
    14| let actual_instantiated_assets_count = 0;
    15| let expected_downloaded_assets_count = 0;
    16| let expected_instantiated_assets_count = 0;
    17| const loaded_files: { url: string, file: string }[] = [];
    18| const loaded_assets: { [id: string]: [VoidPtr, number] } = Object.create(null);
    19| let parallel_count = 0;
    20| let throttlingPromise: PromiseAndController<void> | undefined;
    21| const skipDownloadsByAssetTypes: {
    22|     [k: string]: boolean
    23| } = {
    24|     "js-module-threads": true,
    25| };
    26| const skipBufferByAssetTypes: {
    27|     [k: string]: boolean
    28| } = {
    29|     "dotnetwasm": true,
    30| };
    31| const skipInstantiateByAssetTypes: {
    32|     [k: string]: boolean
    33| } = {
    34|     "js-module-threads": true,
    35|     "dotnetwasm": true,
    36| };
    37| export function resolve_asset_path(behavior: AssetBehaviours) {
    38|     const asset: AssetEntry | undefined = runtimeHelpers.config.assets?.find(a => a.behavior == behavior);
    39|     mono_assert(asset, () => `Can't find asset for ${behavior}`);
    40|     if (!asset.resolvedUrl) {
    41|         asset.resolvedUrl = resolve_path(asset, "");
    42|     }
    43|     return asset;
    44| }
    45| type AssetWithBuffer = {
    46|     asset: AssetEntryInternal,
    47|     buffer?: ArrayBuffer
    48| }
    49| export async function mono_download_assets(): Promise<void> {
    50|     if (runtimeHelpers.diagnosticTracing) console.debug("MONO_WASM: mono_download_assets");
    51|     runtimeHelpers.maxParallelDownloads = runtimeHelpers.config.maxParallelDownloads || runtimeHelpers.maxParallelDownloads;
    52|     try {
    53|         const promises_of_assets_with_buffer: Promise<AssetWithBuffer>[] = [];
    54|         for (const a of runtimeHelpers.config.assets!) {
    55|             const asset: AssetEntryInternal = a;
    56|             if (!skipInstantiateByAssetTypes[asset.behavior]) {
    57|                 expected_instantiated_assets_count++;
    58|             }
    59|             if (!skipDownloadsByAssetTypes[asset.behavior]) {
    60|                 const headersOnly = skipBufferByAssetTypes[asset.behavior];// `response.arrayBuffer()` can't be called twice. Some usecases are calling it on response in the instantiation.
    61|                 expected_downloaded_assets_count++;
    62|                 if (asset.pendingDownload) {
    63|                     asset.pendingDownloadInternal = asset.pendingDownload;
    64|                     const waitForExternalData: () => Promise<AssetWithBuffer> = async () => {
    65|                         const response = await asset.pendingDownloadInternal!.response;
    66|                         if (!headersOnly) {
    67|                             asset.buffer = await response.arrayBuffer();
    68|                         }
    69|                         ++actual_downloaded_assets_count;
    70|                         return { asset, buffer: asset.buffer };
    71|                     };
    72|                     promises_of_assets_with_buffer.push(waitForExternalData());
    73|                 } else {
    74|                     const waitForExternalData: () => Promise<AssetWithBuffer> = async () => {
    75|                         asset.buffer = await start_asset_download_with_retries(asset, !headersOnly);
    76|                         return { asset, buffer: asset.buffer };
    77|                     };
    78|                     promises_of_assets_with_buffer.push(waitForExternalData());
    79|                 }
    80|             }
    81|         }
    82|         allDownloadsQueued.promise_control.resolve();
    83|         const promises_of_asset_instantiation: Promise<void>[] = [];
    84|         for (const downloadPromise of promises_of_assets_with_buffer) {
    85|             promises_of_asset_instantiation.push((async () => {
    86|                 const assetWithBuffer = await downloadPromise;
    87|                 const asset = assetWithBuffer.asset;
    88|                 if (assetWithBuffer.buffer) {
    89|                     if (!skipInstantiateByAssetTypes[asset.behavior]) {
    90|                         const url = asset.pendingDownloadInternal!.url;
    91|                         const data = new Uint8Array(asset.buffer!);
    92|                         asset.pendingDownloadInternal = null as any; // GC
    93|                         asset.pendingDownload = null as any; // GC
    94|                         asset.buffer = null as any; // GC
    95|                         assetWithBuffer.buffer = null as any; // GC
    96|                         await beforeOnRuntimeInitialized.promise;
    97|                         _instantiate_asset(asset, url, data);
    98|                     }
    99|                 } else {
   100|                     const headersOnly = skipBufferByAssetTypes[asset.behavior];
   101|                     if (!headersOnly) {
   102|                         mono_assert(asset.isOptional, "Expected asset to have the downloaded buffer");
   103|                         if (!skipDownloadsByAssetTypes[asset.behavior]) {
   104|                             expected_downloaded_assets_count--;
   105|                         }
   106|                         if (!skipInstantiateByAssetTypes[asset.behavior]) {
   107|                             expected_instantiated_assets_count--;
   108|                         }
   109|                     } else {
   110|                         if (skipBufferByAssetTypes[asset.behavior]) {
   111|                             ++actual_downloaded_assets_count;
   112|                         }
   113|                     }
   114|                 }
   115|             })());
   116|         }
   117|         Promise.all(promises_of_asset_instantiation).then(() => {
   118|             allAssetsInMemory.promise_control.resolve();
   119|         }).catch(err => {
   120|             Module.printErr("MONO_WASM: Error in mono_download_assets: " + err);
   121|             abort_startup(err, true);
   122|         });
   123|     } catch (err: any) {
   124|         Module.printErr("MONO_WASM: Error in mono_download_assets: " + err);
   125|         throw err;
   126|     }
   127| }
   128| export async function start_asset_download_with_retries(asset: AssetEntryInternal, downloadData: boolean): Promise<ArrayBuffer | undefined> {
   129|     try {
   130|         return await start_asset_download_with_throttle(asset, downloadData);
   131|     } catch (err: any) {
   132|         if (ENVIRONMENT_IS_SHELL || ENVIRONMENT_IS_NODE) {
   133|             throw err;
   134|         }
   135|         if (asset.pendingDownload && asset.pendingDownloadInternal == asset.pendingDownload) {
   136|             throw err;
   137|         }
   138|         if (asset.resolvedUrl && asset.resolvedUrl.indexOf("file://") != -1) {
   139|             throw err;
   140|         }
   141|         if (err && err.status == 404) {
   142|             throw err;
   143|         }
   144|         asset.pendingDownloadInternal = undefined;
   145|         await allDownloadsQueued.promise;
   146|         try {
   147|             return await start_asset_download_with_throttle(asset, downloadData);
   148|         } catch (err) {
   149|             asset.pendingDownloadInternal = undefined;
   150|             await delay(100);
   151|             return await start_asset_download_with_throttle(asset, downloadData);
   152|         }
   153|     }
   154| }
   155| async function start_asset_download_with_throttle(asset: AssetEntry, downloadData: boolean): Promise<ArrayBuffer | undefined> {
   156|     while (throttlingPromise) {
   157|         await throttlingPromise.promise;
   158|     }
   159|     try {
   160|         ++parallel_count;
   161|         if (parallel_count == runtimeHelpers.maxParallelDownloads) {
   162|             if (runtimeHelpers.diagnosticTracing)
   163|                 console.debug("MONO_WASM: Throttling further parallel downloads");
   164|             throttlingPromise = createPromiseController<void>();
   165|         }
   166|         const response = await start_asset_download_sources(asset);
   167|         if (!downloadData || !response) {
   168|             return undefined;
   169|         }
   170|         const buffer = await response.arrayBuffer();
   171|         ++actual_downloaded_assets_count;
   172|         return buffer;
   173|     }
   174|     finally {
   175|         --parallel_count;
   176|         if (throttlingPromise && parallel_count == runtimeHelpers.maxParallelDownloads - 1) {
   177|             if (runtimeHelpers.diagnosticTracing)
   178|                 console.debug("MONO_WASM: Resuming more parallel downloads");
   179|             const old_throttling = throttlingPromise;
   180|             throttlingPromise = undefined;
   181|             old_throttling.promise_control.resolve();
   182|         }
   183|     }
   184| }
   185| async function start_asset_download_sources(asset: AssetEntryInternal): Promise<Response | undefined> {
   186|     if (asset.buffer) {
   187|         const buffer = asset.buffer;
   188|         asset.buffer = null as any; // GC
   189|         asset.pendingDownloadInternal = {
   190|             url: "undefined://" + asset.name,
   191|             name: asset.name,
   192|             response: Promise.resolve({
   193|                 arrayBuffer: () => buffer,
   194|                 headers: {
   195|                     get: () => undefined,
   196|                 }
   197|             }) as any
   198|         };
   199|         return asset.pendingDownloadInternal.response;
   200|     }
   201|     if (asset.pendingDownloadInternal && asset.pendingDownloadInternal.response) {
   202|         const response = await asset.pendingDownloadInternal.response;
   203|         return response;
   204|     }
   205|     const sourcesList = asset.loadRemote && runtimeHelpers.config.remoteSources ? runtimeHelpers.config.remoteSources : [""];
   206|     let response: Response | undefined = undefined;
   207|     for (let sourcePrefix of sourcesList) {
   208|         sourcePrefix = sourcePrefix.trim();
   209|         if (sourcePrefix === "./")
   210|             sourcePrefix = "";
   211|         const attemptUrl = resolve_path(asset, sourcePrefix);
   212|         if (asset.name === attemptUrl) {
   213|             if (runtimeHelpers.diagnosticTracing)
   214|                 console.debug(`MONO_WASM: Attempting to download '${attemptUrl}'`);
   215|         } else {
   216|             if (runtimeHelpers.diagnosticTracing)
   217|                 console.debug(`MONO_WASM: Attempting to download '${attemptUrl}' for ${asset.name}`);
   218|         }
   219|         try {
   220|             const loadingResource = download_resource({
   221|                 name: asset.name,
   222|                 resolvedUrl: attemptUrl,
   223|                 hash: asset.hash,
   224|                 behavior: asset.behavior
   225|             });
   226|             asset.pendingDownloadInternal = loadingResource;
   227|             response = await loadingResource.response;
   228|             if (!response.ok) {
   229|                 continue;// next source
   230|             }
   231|             return response;
   232|         }
   233|         catch (err) {
   234|             continue; //next source
   235|         }
   236|     }
   237|     const isOkToFail = asset.isOptional || (asset.name.match(/\.pdb$/) && runtimeHelpers.config.ignorePdbLoadErrors);
   238|     mono_assert(response, () => `Response undefined ${asset.name}`);
   239|     if (!isOkToFail) {
   240|         const err: any = new Error(`MONO_WASM: download '${response.url}' for ${asset.name} failed ${response.status} ${response.statusText}`);
   241|         err.status = response.status;
   242|         throw err;
   243|     } else {
   244|         Module.print(`MONO_WASM: optional download '${response.url}' for ${asset.name} failed ${response.status} ${response.statusText}`);
   245|         return undefined;
   246|     }
   247| }
   248| function resolve_path(asset: AssetEntry, sourcePrefix: string): string {
   249|     mono_assert(sourcePrefix !== null && sourcePrefix !== undefined, () => `sourcePrefix must be provided for ${asset.name}`);
   250|     let attemptUrl;
   251|     const assemblyRootFolder = runtimeHelpers.config.assemblyRootFolder;
   252|     if (!asset.resolvedUrl) {
   253|         if (sourcePrefix === "") {
   254|             if (asset.behavior === "assembly" || asset.behavior === "pdb") {
   255|                 attemptUrl = assemblyRootFolder
   256|                     ? (assemblyRootFolder + "/" + asset.name)
   257|                     : asset.name;
   258|             }
   259|             else if (asset.behavior === "resource") {
   260|                 const path = asset.culture && asset.culture !== "" ? `${asset.culture}/${asset.name}` : asset.name;
   261|                 attemptUrl = assemblyRootFolder
   262|                     ? (assemblyRootFolder + "/" + path)
   263|                     : path;
   264|             }
   265|             else {
   266|                 attemptUrl = asset.name;
   267|             }
   268|         } else {
   269|             attemptUrl = sourcePrefix + asset.name;
   270|         }
   271|         attemptUrl = runtimeHelpers.locateFile(attemptUrl);
   272|     }
   273|     else {
   274|         attemptUrl = asset.resolvedUrl;
   275|     }
   276|     mono_assert(attemptUrl && typeof attemptUrl == "string", "attemptUrl need to be path or url string");
   277|     return attemptUrl;
   278| }
   279| function download_resource(request: ResourceRequest): LoadingResource {
   280|     try {
   281|         if (typeof Module.downloadResource === "function") {
   282|             const loading = Module.downloadResource(request);
   283|             if (loading) return loading;
   284|         }
   285|         const options: any = {};
   286|         if (request.hash) {
   287|             options.integrity = request.hash;
   288|         }
   289|         const response = runtimeHelpers.fetch_like(request.resolvedUrl!, options);
   290|         return {
   291|             name: request.name, url: request.resolvedUrl!, response
   292|         };
   293|     } catch (err) {
   294|         const response = <Response><any>{
   295|             ok: false,
   296|             url: request.resolvedUrl,
   297|             status: 500,
   298|             statusText: "ERR29: " + err,
   299|             arrayBuffer: () => { throw err; },
   300|             json: () => { throw err; }
   301|         };
   302|         return {
   303|             name: request.name, url: request.resolvedUrl!, response: Promise.resolve(response)
   304|         };
   305|     }
   306| }
   307| function _instantiate_asset(asset: AssetEntry, url: string, bytes: Uint8Array) {
   308|     if (runtimeHelpers.diagnosticTracing)
   309|         console.debug(`MONO_WASM: Loaded:${asset.name} as ${asset.behavior} size ${bytes.length} from ${url}`);
   310|     const virtualName: string = typeof (asset.virtualPath) === "string"
   311|         ? asset.virtualPath
   312|         : asset.name;
   313|     let offset: VoidPtr | null = null;
   314|     switch (asset.behavior) {
   315|         case "dotnetwasm":
   316|         case "js-module-threads":
   317|             break;
   318|         case "resource":
   319|         case "assembly":
   320|         case "pdb":
   321|             loaded_files.push({ url: url, file: virtualName });
   322|         case "heap":
   323|         case "icu":
   324|             offset = mono_wasm_load_bytes_into_heap(bytes);
   325|             loaded_assets[virtualName] = [offset, bytes.length];
   326|             break;
   327|         case "vfs": {
   328|             const lastSlash = virtualName.lastIndexOf("/");
   329|             let parentDirectory = (lastSlash > 0)
   330|                 ? virtualName.substr(0, lastSlash)
   331|                 : null;
   332|             let fileName = (lastSlash > 0)
   333|                 ? virtualName.substr(lastSlash + 1)
   334|                 : virtualName;
   335|             if (fileName.startsWith("/"))
   336|                 fileName = fileName.substr(1);
   337|             if (parentDirectory) {
   338|                 if (runtimeHelpers.diagnosticTracing)
   339|                     console.debug(`MONO_WASM: Creating directory '${parentDirectory}'`);
   340|                 Module.FS_createPath(
   341|                     "/", parentDirectory, true, true // fixme: should canWrite be false?
   342|                 );
   343|             } else {
   344|                 parentDirectory = "/";
   345|             }
   346|             if (runtimeHelpers.diagnosticTracing)
   347|                 console.debug(`MONO_WASM: Creating file '${fileName}' in directory '${parentDirectory}'`);
   348|             if (!mono_wasm_load_data_archive(bytes, parentDirectory)) {
   349|                 Module.FS_createDataFile(
   350|                     parentDirectory, fileName,
   351|                     bytes, true /* canRead */, true /* canWrite */, true /* canOwn */
   352|                 );
   353|             }
   354|             break;
   355|         }
   356|         default:
   357|             throw new Error(`Unrecognized asset behavior:${asset.behavior}, for asset ${asset.name}`);
   358|     }
   359|     if (asset.behavior === "assembly") {
   360|         const hasPpdb = cwraps.mono_wasm_add_assembly(virtualName, offset!, bytes.length);
   361|         if (!hasPpdb) {
   362|             const index = loaded_files.findIndex(element => element.file == virtualName);
   363|             loaded_files.splice(index, 1);
   364|         }
   365|     }
   366|     else if (asset.behavior === "icu") {
   367|         if (!mono_wasm_load_icu_data(offset!))
   368|             Module.printErr(`MONO_WASM: Error loading ICU asset ${asset.name}`);
   369|     }
   370|     else if (asset.behavior === "resource") {
   371|         cwraps.mono_wasm_add_satellite_assembly(virtualName, asset.culture || "", offset!, bytes.length);
   372|     }
   373|     ++actual_instantiated_assets_count;
   374| }
   375| export async function instantiate_wasm_asset(
   376|     pendingAsset: AssetEntryInternal,
   377|     wasmModuleImports: WebAssembly.Imports,
   378|     successCallback: InstantiateWasmSuccessCallback,
   379| ): Promise<void> {
   380|     mono_assert(pendingAsset && pendingAsset.pendingDownloadInternal && pendingAsset.pendingDownloadInternal.response, "Can't load dotnet.wasm");
   381|     const response = await pendingAsset.pendingDownloadInternal.response;
   382|     const contentType = response.headers && response.headers.get ? response.headers.get("Content-Type") : undefined;
   383|     let compiledInstance: WebAssembly.Instance;
   384|     let compiledModule: WebAssembly.Module;
   385|     if (typeof WebAssembly.instantiateStreaming === "function" && contentType === "application/wasm") {
   386|         if (runtimeHelpers.diagnosticTracing) console.debug("MONO_WASM: instantiate_wasm_module streaming");
   387|         const streamingResult = await WebAssembly.instantiateStreaming(response, wasmModuleImports!);
   388|         compiledInstance = streamingResult.instance;
   389|         compiledModule = streamingResult.module;
   390|     } else {
   391|         if (ENVIRONMENT_IS_WEB && contentType !== "application/wasm") {
   392|             console.warn("MONO_WASM: WebAssembly resource does not have the expected content type \"application/wasm\", so falling back to slower ArrayBuffer instantiation.");
   393|         }
   394|         const arrayBuffer = await response.arrayBuffer();
   395|         if (runtimeHelpers.diagnosticTracing) console.debug("MONO_WASM: instantiate_wasm_module buffered");
   396|         const arrayBufferResult = await WebAssembly.instantiate(arrayBuffer, wasmModuleImports!);
   397|         compiledInstance = arrayBufferResult.instance;
   398|         compiledModule = arrayBufferResult.module;
   399|     }
   400|     successCallback(compiledInstance, compiledModule);
   401| }
   402| export function mono_wasm_load_data_archive(data: Uint8Array, prefix: string): boolean {
   403|     if (data.length < 8)
   404|         return false;
   405|     const dataview = new DataView(data.buffer);
   406|     const magic = dataview.getUint32(0, true);
   407|     if (magic != 0x626c6174) {
   408|         return false;
   409|     }
   410|     const manifestSize = dataview.getUint32(4, true);
   411|     if (manifestSize == 0 || data.length < manifestSize + 8)
   412|         return false;
   413|     let manifest;
   414|     try {
   415|         const manifestContent = Module.UTF8ArrayToString(data, 8, manifestSize);
   416|         manifest = JSON.parse(manifestContent);
   417|         if (!(manifest instanceof Array))
   418|             return false;
   419|     } catch (exc) {
   420|         return false;
   421|     }
   422|     data = data.slice(manifestSize + 8);
   423|     const folders = new Set<string>();
   424|     manifest.filter(m => {
   425|         const file = m[0];
   426|         const last = file.lastIndexOf("/");
   427|         const directory = file.slice(0, last + 1);
   428|         folders.add(directory);
   429|     });
   430|     folders.forEach(folder => {
   431|         Module["FS_createPath"](prefix, folder, true, true);
   432|     });
   433|     for (const row of manifest) {
   434|         const name = row[0];
   435|         const length = row[1];
   436|         const bytes = data.slice(0, length);
   437|         Module["FS_createDataFile"](prefix, name, bytes, true, true);
   438|         data = data.slice(length);
   439|     }
   440|     return true;
   441| }
   442| export async function wait_for_all_assets() {
   443|     await allAssetsInMemory.promise;
   444|     if (runtimeHelpers.config.assets) {
   445|         mono_assert(actual_downloaded_assets_count == expected_downloaded_assets_count, () => `Expected ${expected_downloaded_assets_count} assets to be downloaded, but only finished ${actual_downloaded_assets_count}`);
   446|         mono_assert(actual_instantiated_assets_count == expected_instantiated_assets_count, () => `Expected ${expected_instantiated_assets_count} assets to be in memory, but only instantiated ${actual_instantiated_assets_count}`);
   447|         loaded_files.forEach(value => MONO.loaded_files.push(value.url));
   448|         if (runtimeHelpers.diagnosticTracing) console.debug("MONO_WASM: all assets are loaded in wasm memory");
   449|     }
   450| }
   451| export function mono_wasm_get_loaded_files(): string[] {
   452|     return MONO.loaded_files;
   453| }


# ====================================================================
# FILE: src/mono/wasm/runtime/memory.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-233 ---
     1| import monoWasmThreads from "consts:monoWasmThreads";
     2| import { Module, runtimeHelpers } from "./imports";
     3| import { mono_assert, MemOffset, NumberOrPointer } from "./types";
     4| import { VoidPtr, CharPtr } from "./types/emscripten";
     5| import * as cuint64 from "./cuint64";
     6| import cwraps, { I52Error } from "./cwraps";
     7| const alloca_stack: Array<VoidPtr> = [];
     8| const alloca_buffer_size = 32 * 1024;
     9| let alloca_base: VoidPtr, alloca_offset: VoidPtr, alloca_limit: VoidPtr;
    10| let HEAPI64: BigInt64Array = <any>null;
    11| function _ensure_allocated(): void {
    12|     if (alloca_base)
    13|         return;
    14|     alloca_base = Module._malloc(alloca_buffer_size);
    15|     alloca_offset = alloca_base;
    16|     alloca_limit = <VoidPtr>(<any>alloca_base + alloca_buffer_size);
    17| }
    18| const is_bigint_supported = typeof BigInt !== "undefined" && typeof BigInt64Array !== "undefined";
    19| export function temp_malloc(size: number): VoidPtr {
    20|     _ensure_allocated();
    21|     if (!alloca_stack.length)
    22|         throw new Error("No temp frames have been created at this point");
    23|     const result = alloca_offset;
    24|     alloca_offset += <any>size;
    25|     if (alloca_offset >= alloca_limit)
    26|         throw new Error("Out of temp storage space");
    27|     return result;
    28| }
    29| export function _create_temp_frame(): void {
    30|     _ensure_allocated();
    31|     alloca_stack.push(alloca_offset);
    32| }
    33| export function _release_temp_frame(): void {
    34|     if (!alloca_stack.length)
    35|         throw new Error("No temp frames have been created at this point");
    36|     alloca_offset = <VoidPtr>alloca_stack.pop();
    37| }
    38| function assert_int_in_range(value: Number, min: Number, max: Number) {
    39|     mono_assert(Number.isSafeInteger(value), () => `Value is not an integer: ${value} (${typeof (value)})`);
    40|     mono_assert(value >= min && value <= max, () => `Overflow: value ${value} is out of ${min} ${max} range`);
    41| }
    42| export function _zero_region(byteOffset: VoidPtr, sizeBytes: number): void {
    43|     Module.HEAP8.fill(0, <any>byteOffset, sizeBytes + <any>byteOffset);
    44| }
    45| export function setB32(offset: MemOffset, value: number | boolean): void {
    46|     const boolValue = !!value;
    47|     if (typeof (value) === "number")
    48|         assert_int_in_range(value, 0, 1);
    49|     Module.HEAP32[<any>offset >>> 2] = boolValue ? 1 : 0;
    50| }
    51| export function setU8(offset: MemOffset, value: number): void {
    52|     assert_int_in_range(value, 0, 0xFF);
    53|     Module.HEAPU8[<any>offset] = value;
    54| }
    55| export function setU16(offset: MemOffset, value: number): void {
    56|     assert_int_in_range(value, 0, 0xFFFF);
    57|     Module.HEAPU16[<any>offset >>> 1] = value;
    58| }
    59| export function setU32_unchecked(offset: MemOffset, value: NumberOrPointer): void {
    60|     Module.HEAPU32[<any>offset >>> 2] = <number><any>value;
    61| }
    62| export function setU32(offset: MemOffset, value: NumberOrPointer): void {
    63|     assert_int_in_range(<any>value, 0, 0xFFFF_FFFF);
    64|     Module.HEAPU32[<any>offset >>> 2] = <number><any>value;
    65| }
    66| export function setI8(offset: MemOffset, value: number): void {
    67|     assert_int_in_range(value, -0x80, 0x7F);
    68|     Module.HEAP8[<any>offset] = value;
    69| }
    70| export function setI16(offset: MemOffset, value: number): void {
    71|     assert_int_in_range(value, -0x8000, 0x7FFF);
    72|     Module.HEAP16[<any>offset >>> 1] = value;
    73| }
    74| export function setI32_unchecked(offset: MemOffset, value: number): void {
    75|     Module.HEAP32[<any>offset >>> 2] = value;
    76| }
    77| export function setI32(offset: MemOffset, value: number): void {
    78|     assert_int_in_range(<any>value, -0x8000_0000, 0x7FFF_FFFF);
    79|     Module.HEAP32[<any>offset >>> 2] = value;
    80| }
    81| function autoThrowI52(error: I52Error) {
    82|     if (error === I52Error.NONE)
    83|         return;
    84|     switch (error) {
    85|         case I52Error.NON_INTEGRAL:
    86|             throw new Error("value was not an integer");
    87|         case I52Error.OUT_OF_RANGE:
    88|             throw new Error("value out of range");
    89|         default:
    90|             throw new Error("unknown internal error");
    91|     }
    92| }
    93| /**
    94|  * Throws for values which are not 52 bit integer. See Number.isSafeInteger()
    95|  */
    96| export function setI52(offset: MemOffset, value: number): void {
    97|     mono_assert(Number.isSafeInteger(value), () => `Value is not a safe integer: ${value} (${typeof (value)})`);
    98|     const error = cwraps.mono_wasm_f64_to_i52(<any>offset, value);
    99|     autoThrowI52(error);
   100| }
   101| /**
   102|  * Throws for values which are not 52 bit integer or are negative. See Number.isSafeInteger().
   103|  */
   104| export function setU52(offset: MemOffset, value: number): void {
   105|     mono_assert(Number.isSafeInteger(value), () => `Value is not a safe integer: ${value} (${typeof (value)})`);
   106|     mono_assert(value >= 0, "Can't convert negative Number into UInt64");
   107|     const error = cwraps.mono_wasm_f64_to_u52(<any>offset, value);
   108|     autoThrowI52(error);
   109| }
   110| export function setI64Big(offset: MemOffset, value: bigint): void {
   111|     mono_assert(is_bigint_supported, "BigInt is not supported.");
   112|     mono_assert(typeof value === "bigint", () => `Value is not an bigint: ${value} (${typeof (value)})`);
   113|     mono_assert(value >= min_int64_big && value <= max_int64_big, () => `Overflow: value ${value} is out of ${min_int64_big} ${max_int64_big} range`);
   114|     HEAPI64[<any>offset >>> 3] = value;
   115| }
   116| export function setF32(offset: MemOffset, value: number): void {
   117|     mono_assert(typeof value === "number", () => `Value is not a Number: ${value} (${typeof (value)})`);
   118|     Module.HEAPF32[<any>offset >>> 2] = value;
   119| }
   120| export function setF64(offset: MemOffset, value: number): void {
   121|     mono_assert(typeof value === "number", () => `Value is not a Number: ${value} (${typeof (value)})`);
   122|     Module.HEAPF64[<any>offset >>> 3] = value;
   123| }
   124| export function getB32(offset: MemOffset): boolean {
   125|     return !!(Module.HEAP32[<any>offset >>> 2]);
   126| }
   127| export function getU8(offset: MemOffset): number {
   128|     return Module.HEAPU8[<any>offset];
   129| }
   130| export function getU16(offset: MemOffset): number {
   131|     return Module.HEAPU16[<any>offset >>> 1];
   132| }
   133| export function getU32(offset: MemOffset): number {
   134|     return Module.HEAPU32[<any>offset >>> 2];
   135| }
   136| export function getI8(offset: MemOffset): number {
   137|     return Module.HEAP8[<any>offset];
   138| }
   139| export function getI16(offset: MemOffset): number {
   140|     return Module.HEAP16[<any>offset >>> 1];
   141| }
   142| export function getI32(offset: MemOffset): number {
   143|     return Module.HEAP32[<any>offset >>> 2];
   144| }
   145| /**
   146|  * Throws for Number.MIN_SAFE_INTEGER > value > Number.MAX_SAFE_INTEGER
   147|  */
   148| export function getI52(offset: MemOffset): number {
   149|     const result = cwraps.mono_wasm_i52_to_f64(<any>offset, runtimeHelpers._i52_error_scratch_buffer);
   150|     const error = getI32(runtimeHelpers._i52_error_scratch_buffer);
   151|     autoThrowI52(error);
   152|     return result;
   153| }
   154| /**
   155|  * Throws for 0 > value > Number.MAX_SAFE_INTEGER
   156|  */
   157| export function getU52(offset: MemOffset): number {
   158|     const result = cwraps.mono_wasm_u52_to_f64(<any>offset, runtimeHelpers._i52_error_scratch_buffer);
   159|     const error = getI32(runtimeHelpers._i52_error_scratch_buffer);
   160|     autoThrowI52(error);
   161|     return result;
   162| }
   163| export function getI64Big(offset: MemOffset): bigint {
   164|     mono_assert(is_bigint_supported, "BigInt is not supported.");
   165|     return HEAPI64[<any>offset >>> 3];
   166| }
   167| export function getF32(offset: MemOffset): number {
   168|     return Module.HEAPF32[<any>offset >>> 2];
   169| }
   170| export function getF64(offset: MemOffset): number {
   171|     return Module.HEAPF64[<any>offset >>> 3];
   172| }
   173| let max_int64_big: BigInt;
   174| let min_int64_big: BigInt;
   175| export function afterUpdateGlobalBufferAndViews(buffer: ArrayBufferLike): void {
   176|     if (is_bigint_supported) {
   177|         max_int64_big = BigInt("9223372036854775807");
   178|         min_int64_big = BigInt("-9223372036854775808");
   179|         HEAPI64 = new BigInt64Array(buffer);
   180|     }
   181| }
   182| export function getCU64(offset: MemOffset): cuint64.CUInt64 {
   183|     const lo = getU32(offset);
   184|     const hi = getU32(<any>offset + 4);
   185|     return cuint64.pack32(lo, hi);
   186| }
   187| export function setCU64(offset: MemOffset, value: cuint64.CUInt64): void {
   188|     const [lo, hi] = cuint64.unpack32(value);
   189|     setU32_unchecked(offset, lo);
   190|     setU32_unchecked(<any>offset + 4, hi);
   191| }
   192| export function withStackAlloc<TResult>(bytesWanted: number, f: (ptr: VoidPtr) => TResult): TResult;
   193| export function withStackAlloc<T1, TResult>(bytesWanted: number, f: (ptr: VoidPtr, ud1: T1) => TResult, ud1: T1): TResult;
   194| export function withStackAlloc<T1, T2, TResult>(bytesWanted: number, f: (ptr: VoidPtr, ud1: T1, ud2: T2) => TResult, ud1: T1, ud2: T2): TResult;
   195| export function withStackAlloc<T1, T2, T3, TResult>(bytesWanted: number, f: (ptr: VoidPtr, ud1: T1, ud2: T2, ud3: T3) => TResult, ud1: T1, ud2: T2, ud3: T3): TResult;
   196| export function withStackAlloc<T1, T2, T3, TResult>(bytesWanted: number, f: (ptr: VoidPtr, ud1?: T1, ud2?: T2, ud3?: T3) => TResult, ud1?: T1, ud2?: T2, ud3?: T3): TResult {
   197|     const sp = Module.stackSave();
   198|     const ptr = Module.stackAlloc(bytesWanted);
   199|     try {
   200|         return f(ptr, ud1, ud2, ud3);
   201|     } finally {
   202|         Module.stackRestore(sp);
   203|     }
   204| }
   205| export function mono_wasm_load_bytes_into_heap(bytes: Uint8Array): VoidPtr {
   206|     const memoryOffset = Module._malloc(bytes.length);
   207|     const heapBytes = new Uint8Array(Module.HEAPU8.buffer, <any>memoryOffset, bytes.length);
   208|     heapBytes.set(bytes);
   209|     return memoryOffset;
   210| }
   211| export function getEnv(name: string): string | null {
   212|     let charPtr: CharPtr = <any>0;
   213|     try {
   214|         charPtr = cwraps.mono_wasm_getenv(name);
   215|         if (<any>charPtr === 0)
   216|             return null;
   217|         else return Module.UTF8ToString(charPtr);
   218|     } finally {
   219|         if (charPtr) Module._free(<any>charPtr);
   220|     }
   221| }
   222| const BuiltinAtomics = globalThis.Atomics;
   223| export const Atomics = monoWasmThreads ? {
   224|     storeI32(offset: MemOffset, value: number): void {
   225|         BuiltinAtomics.store(Module.HEAP32, <any>offset >>> 2, value);
   226|     },
   227|     notifyI32(offset: MemOffset, count: number): void {
   228|         BuiltinAtomics.notify(Module.HEAP32, <any>offset >>> 2, count);
   229|     }
   230| } : {
   231|     storeI32: setI32,
   232|     notifyI32: () => { /*empty*/ }
   233| };


# ====================================================================
# FILE: src/native/eventpipe/ep-buffer-manager.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1013 ---
     1| #include "ep-rt-config.h"
     2| #ifdef ENABLE_PERFTRACING
     3| #if !defined(EP_INCLUDE_SOURCE_FILES) || defined(EP_FORCE_INCLUDE_SOURCE_FILES)
     4| #define EP_IMPL_BUFFER_MANAGER_GETTER_SETTER
     5| #include "ep.h"
     6| #include "ep-buffer.h"
     7| #include "ep-buffer-manager.h"
     8| #include "ep-event.h"
     9| #include "ep-event-instance.h"
    10| #include "ep-event-payload.h"
    11| #include "ep-file.h"
    12| #include "ep-session.h"
    13| #include "ep-stack-contents.h"
    14| #define EP_MAX(a,b) (((a) > (b)) ? (a) : (b))
    15| #define EP_MIN(a,b) (((a) < (b)) ? (a) : (b))
    16| #define EP_CLAMP(min,value,max) (EP_MIN(EP_MAX(min, value), max))
    17| /*
    18|  * Forward declares of all static functions.
    19|  */
    20| static
    21| void
    22| buffer_list_fini (EventPipeBufferList *buffer_list);
    23| static
    24| bool
    25| buffer_manager_enqueue_sequence_point (
    26| 	EventPipeBufferManager *buffer_manager,
    27| 	EventPipeSequencePoint *sequence_point);
    28| static
    29| void
    30| buffer_manager_init_sequence_point_thread_list (
    31| 	EventPipeBufferManager *buffer_manager,
    32| 	EventPipeSequencePoint *sequence_point);
    33| static
    34| void
    35| buffer_manager_dequeue_sequence_point (EventPipeBufferManager *buffer_manager);
    36| static
    37| bool
    38| buffer_manager_try_peek_sequence_point (
    39| 	EventPipeBufferManager *buffer_manager,
    40| 	EventPipeSequencePoint **sequence_point);
    41| static
    42| EventPipeBuffer *
    43| buffer_manager_allocate_buffer_for_thread (
    44| 	EventPipeBufferManager *buffer_manager,
    45| 	EventPipeThreadSessionState *thread_session_state,
    46| 	uint32_t request_size,
    47| 	bool *write_suspended);
    48| static
    49| void
    50| buffer_manager_deallocate_buffer (
    51| 	EventPipeBufferManager *buffer_manager,
    52| 	EventPipeBuffer *buffer);
    53| static
    54| bool
    55| buffer_manager_try_reserve_buffer(
    56| 	EventPipeBufferManager *buffer_manager,
    57| 	uint32_t request_size);
    58| static
    59| void
    60| buffer_manager_release_buffer(
    61| 	EventPipeBufferManager *buffer_manager,
    62| 	uint32_t size);
    63| static
    64| void
    65| buffer_manager_move_next_event_any_thread (
    66| 	EventPipeBufferManager *buffer_manager,
    67| 	ep_timestamp_t stop_timestamp);
    68| static
    69| void
    70| buffer_manager_move_next_event_same_thread (
    71| 	EventPipeBufferManager *buffer_manager,
    72| 	ep_timestamp_t stop_timestamp);
    73| static
    74| EventPipeBuffer *
    75| buffer_manager_advance_to_non_empty_buffer (
    76| 	EventPipeBufferManager *buffer_manager,
    77| 	EventPipeBufferList *buffer_list,
    78| 	EventPipeBuffer *buffer,
    79| 	ep_timestamp_t before_timestamp);
    80| static
    81| bool
    82| buffer_manager_try_convert_buffer_to_read_only (
    83| 	EventPipeBufferManager *buffer_manager,
    84| 	EventPipeBuffer *new_read_buffer);
    85| /*
    86|  * EventPipeBufferList.
    87|  */
    88| static
    89| void
    90| buffer_list_fini (EventPipeBufferList *buffer_list)
    91| {
    92| 	EP_ASSERT (buffer_list != NULL);
    93| 	ep_thread_holder_fini (&buffer_list->thread_holder);
    94| }
    95| EventPipeBufferList *
    96| ep_buffer_list_alloc (
    97| 	EventPipeBufferManager *manager,
    98| 	EventPipeThread *thread)
    99| {
   100| 	EventPipeBufferList *instance = ep_rt_object_alloc (EventPipeBufferList);
   101| 	ep_raise_error_if_nok (instance != NULL);
   102| 	ep_raise_error_if_nok (ep_buffer_list_init (instance, manager, thread) != NULL);
   103| ep_on_exit:
   104| 	return instance;
   105| ep_on_error:
   106| 	ep_buffer_list_free (instance);
   107| 	instance = NULL;
   108| 	ep_exit_error_handler ();
   109| }
   110| EventPipeBufferList *
   111| ep_buffer_list_init (
   112| 	EventPipeBufferList *buffer_list,
   113| 	EventPipeBufferManager *manager,
   114| 	EventPipeThread *thread)
   115| {
   116| 	EP_ASSERT (buffer_list != NULL);
   117| 	EP_ASSERT (manager != NULL);
   118| 	EP_ASSERT (thread != NULL);
   119| 	ep_thread_holder_init (&buffer_list->thread_holder, thread);
   120| 	buffer_list->manager = manager;
   121| 	buffer_list->head_buffer = NULL;
   122| 	buffer_list->tail_buffer = NULL;
   123| 	buffer_list->buffer_count = 0;
   124| 	buffer_list->last_read_sequence_number = 0;
   125| 	return buffer_list;
   126| }
   127| void
   128| ep_buffer_list_fini (EventPipeBufferList *buffer_list)
   129| {
   130| 	ep_return_void_if_nok (buffer_list != NULL);
   131| 	buffer_list_fini (buffer_list);
   132| }
   133| void
   134| ep_buffer_list_free (EventPipeBufferList *buffer_list)
   135| {
   136| 	ep_return_void_if_nok (buffer_list != NULL);
   137| 	buffer_list_fini (buffer_list);
   138| 	ep_rt_object_free (buffer_list);
   139| }
   140| void
   141| ep_buffer_list_insert_tail (
   142| 	EventPipeBufferList *buffer_list,
   143| 	EventPipeBuffer *buffer)
   144| {
   145| 	ep_return_void_if_nok (buffer_list != NULL);
   146| 	EP_ASSERT (buffer != NULL);
   147| 	EP_ASSERT (ep_buffer_list_ensure_consistency (buffer_list));
   148| 	EP_ASSERT ((ep_buffer_get_next_buffer (buffer) == NULL) && (ep_buffer_get_prev_buffer (buffer) == NULL));
   149| 	if (buffer_list->tail_buffer == NULL) {
   150| 		buffer_list->head_buffer = buffer_list->tail_buffer = buffer;
   151| 	} else {
   152| 		ep_buffer_set_next_buffer (buffer_list->tail_buffer, buffer);
   153| 		ep_buffer_set_prev_buffer (buffer, buffer_list->tail_buffer);
   154| 		buffer_list->tail_buffer = buffer;
   155| 	}
   156| 	buffer_list->buffer_count++;
   157| 	EP_ASSERT (ep_buffer_list_ensure_consistency (buffer_list));
   158| }
   159| EventPipeBuffer *
   160| ep_buffer_list_get_and_remove_head (EventPipeBufferList *buffer_list)
   161| {
   162| 	ep_return_null_if_nok (buffer_list != NULL);
   163| 	EP_ASSERT (ep_buffer_list_ensure_consistency (buffer_list));
   164| 	EventPipeBuffer *ret_buffer = NULL;
   165| 	if (buffer_list->head_buffer != NULL)
   166| 	{
   167| 		ret_buffer = buffer_list->head_buffer;
   168| 		buffer_list->head_buffer = ep_buffer_get_next_buffer (buffer_list->head_buffer);
   169| 		if (buffer_list->head_buffer != NULL)
   170| 			ep_buffer_set_prev_buffer (buffer_list->head_buffer, NULL);
   171| 		else
   172| 			buffer_list->tail_buffer = NULL;
   173| 		ep_buffer_set_next_buffer (ret_buffer, NULL);
   174| 		EP_ASSERT ((ep_buffer_get_next_buffer (ret_buffer) == NULL) && (ep_buffer_get_prev_buffer (ret_buffer) == NULL));
   175| 		buffer_list->buffer_count--;
   176| 	}
   177| 	EP_ASSERT (ep_buffer_list_ensure_consistency (buffer_list));
   178| 	return ret_buffer;
   179| }
   180| bool
   181| buffer_manager_try_reserve_buffer(
   182| 	EventPipeBufferManager *buffer_manager,
   183| 	uint32_t request_size)
   184| {
   185| 	uint64_t iters = 0;
   186| 	size_t old_size_of_all_buffers;
   187| 	size_t new_size_of_all_buffers;
   188| 	do {
   189| 		old_size_of_all_buffers = buffer_manager->size_of_all_buffers;
   190| 		new_size_of_all_buffers = old_size_of_all_buffers + request_size;
   191| 		iters++;
   192| 		if (iters % 64 == 0) {
   193| 			ep_rt_thread_sleep (0); // yield the thread to the scheduler in case we're in high contention
   194| 		}
   195| 	} while (new_size_of_all_buffers <= buffer_manager->max_size_of_all_buffers && ep_rt_atomic_compare_exchange_size_t (&buffer_manager->size_of_all_buffers, old_size_of_all_buffers, new_size_of_all_buffers) != old_size_of_all_buffers);
   196| 	return new_size_of_all_buffers <= buffer_manager->max_size_of_all_buffers;
   197| }
   198| void
   199| buffer_manager_release_buffer(
   200| 	EventPipeBufferManager *buffer_manager,
   201| 	uint32_t size)
   202| {
   203| 	uint64_t iters = 0;
   204| 	size_t old_size_of_all_buffers;
   205| 	size_t new_size_of_all_buffers;
   206| 	do {
   207| 		old_size_of_all_buffers = buffer_manager->size_of_all_buffers;
   208| 		new_size_of_all_buffers = old_size_of_all_buffers - size;
   209| 		iters++;
   210| 		if (iters % 64 == 0) {
   211| 			ep_rt_thread_sleep (0); // yield the thread to the scheduler in case we're in high contention
   212| 		}
   213| 	} while (new_size_of_all_buffers >= 0 && ep_rt_atomic_compare_exchange_size_t (&buffer_manager->size_of_all_buffers, old_size_of_all_buffers, new_size_of_all_buffers) != old_size_of_all_buffers);
   214| }
   215| #ifdef EP_CHECKED_BUILD
   216| bool
   217| ep_buffer_list_ensure_consistency (EventPipeBufferList *buffer_list)
   218| {
   219| 	EP_ASSERT ((buffer_list->head_buffer == NULL && buffer_list->tail_buffer == NULL) ||
   220| 		(buffer_list->head_buffer != NULL && buffer_list->tail_buffer != NULL));
   221| 	if (buffer_list->head_buffer == NULL) {
   222| 		EP_ASSERT (buffer_list->buffer_count == 0);
   223| 		return true;
   224| 	}
   225| 	uint32_t node_count = (buffer_list->head_buffer != NULL) ? 1 : 0;
   226| 	EventPipeBuffer *iterator = buffer_list->head_buffer;
   227| 	while (ep_buffer_get_next_buffer (iterator) != NULL) {
   228| 		iterator = ep_buffer_get_next_buffer (iterator);
   229| 		node_count++;
   230| 		if (ep_buffer_get_next_buffer (iterator) != NULL)
   231| 			EP_ASSERT (ep_buffer_ensure_consistency (iterator));
   232| 		EP_ASSERT (node_count <= buffer_list->buffer_count);
   233| 	}
   234| 	EP_ASSERT (iterator == buffer_list->tail_buffer);
   235| 	EP_ASSERT (node_count == buffer_list->buffer_count);
   236| 	iterator = buffer_list->tail_buffer;
   237| 	node_count = (buffer_list->tail_buffer != NULL) ? 1 : 0;
   238| 	while (ep_buffer_get_prev_buffer (iterator) != NULL) {
   239| 		iterator = ep_buffer_get_prev_buffer (iterator);
   240| 		node_count++;
   241| 		EP_ASSERT (node_count <= buffer_list->buffer_count);
   242| 	}
   243| 	EP_ASSERT (iterator == buffer_list->head_buffer);
   244| 	EP_ASSERT (node_count == buffer_list->buffer_count);
   245| 	return true;
   246| }
   247| #endif
   248| /*
   249|  * EventPipeBufferManager.
   250|  */
   251| static
   252| bool
   253| buffer_manager_enqueue_sequence_point (
   254| 	EventPipeBufferManager *buffer_manager,
   255| 	EventPipeSequencePoint *sequence_point)
   256| {
   257| 	EP_ASSERT (buffer_manager != NULL);
   258| 	EP_ASSERT (sequence_point != NULL);
   259| 	ep_buffer_manager_requires_lock_held (buffer_manager);
   260| 	return ep_rt_sequence_point_list_append (&buffer_manager->sequence_points, sequence_point);
   261| }
   262| static
   263| void
   264| buffer_manager_init_sequence_point_thread_list (
   265| 	EventPipeBufferManager *buffer_manager,
   266| 	EventPipeSequencePoint *sequence_point)
   267| {
   268| 	EP_ASSERT (buffer_manager != NULL);
   269| 	EP_ASSERT (sequence_point != NULL);
   270| 	ep_buffer_manager_requires_lock_held (buffer_manager);
   271| 	ep_rt_thread_session_state_list_iterator_t iterator = ep_rt_thread_session_state_list_iterator_begin (&buffer_manager->thread_session_state_list);
   272| 	while (!ep_rt_thread_session_state_list_iterator_end (&buffer_manager->thread_session_state_list, &iterator)) {
   273| 		EventPipeThreadSessionState *thread_session_state = ep_rt_thread_session_state_list_iterator_value (&iterator);
   274| 		uint32_t sequence_number = ep_thread_session_state_get_volatile_sequence_number (thread_session_state) - 1;
   275| 		ep_rt_thread_sequence_number_map_add (ep_sequence_point_get_thread_sequence_numbers_ref (sequence_point), thread_session_state, sequence_number);
   276| 		ep_thread_addref (ep_thread_holder_get_thread (ep_thread_session_state_get_thread_holder_ref (thread_session_state)));
   277| 		ep_rt_thread_session_state_list_iterator_next (&iterator);
   278| 	}
   279| 	ep_buffer_manager_requires_lock_held (buffer_manager);
   280| 	ep_sequence_point_set_timestamp (sequence_point, ep_perf_timestamp_get ());
   281| }
   282| static
   283| void
   284| buffer_manager_dequeue_sequence_point (EventPipeBufferManager *buffer_manager)
   285| {
   286| 	EP_ASSERT (buffer_manager != NULL);
   287| 	ep_buffer_manager_requires_lock_held (buffer_manager);
   288| 	ep_return_void_if_nok (!ep_rt_sequence_point_list_is_empty (&buffer_manager->sequence_points));
   289| 	ep_rt_sequence_point_list_iterator_t iterator = ep_rt_sequence_point_list_iterator_begin (&buffer_manager->sequence_points);
   290| 	EventPipeSequencePoint *value = ep_rt_sequence_point_list_iterator_value (&iterator);
   291| 	ep_rt_sequence_point_list_remove (&buffer_manager->sequence_points, value);
   292| 	ep_sequence_point_free (value);
   293| }
   294| static
   295| bool
   296| buffer_manager_try_peek_sequence_point (
   297| 	EventPipeBufferManager *buffer_manager,
   298| 	EventPipeSequencePoint **sequence_point)
   299| {
   300| 	EP_ASSERT (buffer_manager != NULL);
   301| 	EP_ASSERT (sequence_point != NULL);
   302| 	ep_buffer_manager_requires_lock_held (buffer_manager);
   303| 	ep_return_false_if_nok (!ep_rt_sequence_point_list_is_empty (&buffer_manager->sequence_points));
   304| 	ep_rt_sequence_point_list_iterator_t iterator = ep_rt_sequence_point_list_iterator_begin (&buffer_manager->sequence_points);
   305| 	*sequence_point = ep_rt_sequence_point_list_iterator_value (&iterator);
   306| 	return *sequence_point != NULL;
   307| }
   308| static
   309| EventPipeBuffer *
   310| buffer_manager_allocate_buffer_for_thread (
   311| 	EventPipeBufferManager *buffer_manager,
   312| 	EventPipeThreadSessionState *thread_session_state,
   313| 	uint32_t request_size,
   314| 	bool *write_suspended)
   315| {
   316| 	EP_ASSERT (buffer_manager != NULL);
   317| 	EP_ASSERT (thread_session_state != NULL);
   318| 	EP_ASSERT (request_size > 0);
   319| 	EventPipeBuffer *new_buffer = NULL;
   320| 	EventPipeBufferList *thread_buffer_list = NULL;
   321| 	EventPipeSequencePoint* sequence_point = NULL;
   322| 	uint32_t sequence_number = 0;
   323| 	uint32_t size_multiplier = ep_thread_session_state_get_buffer_count_estimate(thread_session_state) + 1;
   324| 	EP_ASSERT(size_multiplier > 0);
   325| #ifdef EP_CHECKED_BUILD
   326| 	uint32_t base_buffer_size = 30 * 1024; // 30K
   327| #else
   328| 	uint32_t base_buffer_size = 100 * 1024; // 100K
   329| #endif
   330| 	uint32_t buffer_size = base_buffer_size * size_multiplier;
   331| 	EP_ASSERT(buffer_size > 0);
   332| 	buffer_size = EP_MAX (request_size, buffer_size);
   333| 	const uint32_t max_buffer_size = 1024 * 1024;
   334| 	buffer_size = EP_MIN (buffer_size, max_buffer_size);
   335| 	EP_ASSERT (request_size <= buffer_size);
   336| 	buffer_size = (buffer_size + ep_rt_system_get_alloc_granularity () - 1) & ~(uint32_t)(ep_rt_system_get_alloc_granularity () - 1);
   337| 	EP_ASSERT(buffer_size > 0);
   338| 	ep_return_null_if_nok(buffer_manager_try_reserve_buffer(buffer_manager, buffer_size));
   339| 	sequence_number = ep_thread_session_state_get_volatile_sequence_number (thread_session_state);
   340| 	new_buffer = ep_buffer_alloc (buffer_size, ep_thread_session_state_get_thread (thread_session_state), sequence_number);
   341| 	ep_raise_error_if_nok (new_buffer != NULL);
   342| 	EP_SPIN_LOCK_ENTER (&buffer_manager->rt_lock, section1)
   343| 		thread_buffer_list = ep_thread_session_state_get_buffer_list (thread_session_state);
   344| 		if (thread_buffer_list == NULL) {
   345| 			thread_buffer_list = ep_buffer_list_alloc (buffer_manager, ep_thread_session_state_get_thread (thread_session_state));
   346| 			ep_raise_error_if_nok_holding_spin_lock (thread_buffer_list != NULL, section1);
   347| 			ep_raise_error_if_nok_holding_spin_lock (ep_rt_thread_session_state_list_append (&buffer_manager->thread_session_state_list, thread_session_state), section1);
   348| 			ep_thread_session_state_set_buffer_list (thread_session_state, thread_buffer_list);
   349| 			thread_buffer_list = NULL;
   350| 		}
   351| 		if (buffer_manager->sequence_point_alloc_budget != 0) {
   352| 			if (buffer_size >= buffer_manager->remaining_sequence_point_alloc_budget) {
   353| 				sequence_point = ep_sequence_point_alloc ();
   354| 				if (sequence_point) {
   355| 					buffer_manager_init_sequence_point_thread_list (buffer_manager, sequence_point);
   356| 					ep_raise_error_if_nok_holding_spin_lock (buffer_manager_enqueue_sequence_point (buffer_manager, sequence_point), section1);
   357| 					sequence_point = NULL;
   358| 				}
   359| 				buffer_manager->remaining_sequence_point_alloc_budget = buffer_manager->sequence_point_alloc_budget;
   360| 			} else {
   361| 				buffer_manager->remaining_sequence_point_alloc_budget -= buffer_size;
   362| 			}
   363| 		}
   364| #ifdef EP_CHECKED_BUILD
   365| 		buffer_manager->num_buffers_allocated++;
   366| #endif // EP_CHECKED_BUILD
   367| 		if (new_buffer != NULL)
   368| 			ep_buffer_list_insert_tail (ep_thread_session_state_get_buffer_list (thread_session_state), new_buffer);
   369| 	EP_SPIN_LOCK_EXIT (&buffer_manager->rt_lock, section1)
   370| ep_on_exit:
   371| 	return new_buffer;
   372| ep_on_error:
   373| 	ep_sequence_point_free (sequence_point);
   374| 	sequence_point = NULL;
   375| 	ep_buffer_list_free (thread_buffer_list);
   376| 	thread_buffer_list = NULL;
   377| 	ep_buffer_free (new_buffer);
   378| 	new_buffer = NULL;
   379| 	buffer_manager_release_buffer(buffer_manager, buffer_size);
   380| 	ep_exit_error_handler ();
   381| }
   382| static
   383| void
   384| buffer_manager_deallocate_buffer (
   385| 	EventPipeBufferManager *buffer_manager,
   386| 	EventPipeBuffer *buffer)
   387| {
   388| 	EP_ASSERT (buffer_manager != NULL);
   389| 	if (buffer) {
   390| 		buffer_manager_release_buffer(buffer_manager, ep_buffer_get_size (buffer));
   391| 		ep_buffer_free (buffer);
   392| #ifdef EP_CHECKED_BUILD
   393| 		buffer_manager->num_buffers_allocated--;
   394| #endif
   395| 	}
   396| }
   397| static
   398| void
   399| buffer_manager_move_next_event_any_thread (
   400| 	EventPipeBufferManager *buffer_manager,
   401| 	ep_timestamp_t stop_timestamp)
   402| {
   403| 	EP_ASSERT (buffer_manager != NULL);
   404| 	ep_buffer_manager_requires_lock_not_held (buffer_manager);
   405| 	if (buffer_manager->current_event != NULL)
   406| 		ep_buffer_move_next_read_event (buffer_manager->current_buffer);
   407| 	buffer_manager->current_event = NULL;
   408| 	buffer_manager->current_buffer = NULL;
   409| 	buffer_manager->current_buffer_list = NULL;
   410| 	EP_RT_DECLARE_LOCAL_BUFFER_ARRAY (buffer_array);
   411| 	EP_RT_DECLARE_LOCAL_BUFFER_LIST_ARRAY (buffer_list_array);
   412| 	ep_rt_buffer_array_init (&buffer_array);
   413| 	ep_rt_buffer_list_array_init (&buffer_list_array);
   414| 	EP_SPIN_LOCK_ENTER (&buffer_manager->rt_lock, section1)
   415| 		EventPipeBufferList *buffer_list;
   416| 		EventPipeBuffer *buffer;
   417| 		ep_rt_thread_session_state_list_iterator_t iterator = ep_rt_thread_session_state_list_iterator_begin (&buffer_manager->thread_session_state_list);
   418| 		while (!ep_rt_thread_session_state_list_iterator_end (&buffer_manager->thread_session_state_list, &iterator)) {
   419| 			buffer_list = ep_thread_session_state_get_buffer_list (ep_rt_thread_session_state_list_iterator_value (&iterator));
   420| 			buffer = buffer_list->head_buffer;
   421| 			if (buffer && ep_buffer_get_creation_timestamp (buffer) < stop_timestamp) {
   422| 				ep_rt_buffer_list_array_append (&buffer_list_array, buffer_list);
   423| 				ep_rt_buffer_array_append (&buffer_array, buffer);
   424| 			}
   425| 			ep_rt_thread_session_state_list_iterator_next (&iterator);
   426| 		}
   427| 	EP_SPIN_LOCK_EXIT (&buffer_manager->rt_lock, section1)
   428| 	ep_timestamp_t oldest_timestamp;
   429| 	oldest_timestamp = stop_timestamp;
   430| 	EventPipeBufferList *buffer_list;
   431| 	EventPipeBuffer *head_buffer;
   432| 	EventPipeBuffer *buffer;
   433| 	EventPipeEventInstance *next_event;
   434| 	ep_rt_buffer_list_array_iterator_t buffer_list_array_iterator;
   435| 	buffer_list_array_iterator = ep_rt_buffer_list_array_iterator_begin (&buffer_list_array);
   436| 	ep_rt_buffer_array_iterator_t buffer_array_iterator;
   437| 	buffer_array_iterator = ep_rt_buffer_array_iterator_begin (&buffer_array);
   438| 	while (!ep_rt_buffer_array_iterator_end (&buffer_array, &buffer_array_iterator) && !ep_rt_buffer_list_array_iterator_end (&buffer_list_array, &buffer_list_array_iterator)) {
   439| 		buffer_list = ep_rt_buffer_list_array_iterator_value (&buffer_list_array_iterator);
   440| 		head_buffer = ep_rt_buffer_array_iterator_value (&buffer_array_iterator);
   441| 		buffer = buffer_manager_advance_to_non_empty_buffer (buffer_manager, buffer_list, head_buffer, stop_timestamp);
   442| 		if (buffer) {
   443| 			next_event = ep_buffer_get_current_read_event (buffer);
   444| 			if (next_event && ep_event_instance_get_timestamp (next_event) < oldest_timestamp) {
   445| 				buffer_manager->current_event = next_event;
   446| 				buffer_manager->current_buffer = buffer;
   447| 				buffer_manager->current_buffer_list = buffer_list;
   448| 				oldest_timestamp = ep_event_instance_get_timestamp (buffer_manager->current_event);
   449| 			}
   450| 		}
   451| 		ep_rt_buffer_list_array_iterator_next (&buffer_list_array_iterator);
   452| 		ep_rt_buffer_array_iterator_next (&buffer_array_iterator);
   453| 	}
   454| ep_on_exit:
   455| 	ep_buffer_manager_requires_lock_not_held (buffer_manager);
   456| 	ep_rt_buffer_list_array_fini (&buffer_list_array);
   457| 	ep_rt_buffer_array_fini (&buffer_array);
   458| 	return;
   459| ep_on_error:
   460| 	ep_exit_error_handler ();
   461| }
   462| static
   463| void
   464| buffer_manager_move_next_event_same_thread (
   465| 	EventPipeBufferManager *buffer_manager,
   466| 	ep_timestamp_t stop_timestamp)
   467| {
   468| 	EP_ASSERT (buffer_manager != NULL);
   469| 	EP_ASSERT (buffer_manager->current_event != NULL);
   470| 	EP_ASSERT (buffer_manager->current_buffer != NULL);
   471| 	EP_ASSERT (buffer_manager->current_buffer_list != NULL);
   472| 	ep_buffer_manager_requires_lock_not_held (buffer_manager);
   473| 	buffer_manager->current_event = NULL;
   474| 	ep_buffer_move_next_read_event (buffer_manager->current_buffer);
   475| 	buffer_manager->current_buffer = buffer_manager_advance_to_non_empty_buffer (
   476| 		buffer_manager,
   477| 		buffer_manager->current_buffer_list,
   478| 		buffer_manager->current_buffer,
   479| 		stop_timestamp);
   480| 	if (buffer_manager->current_buffer) {
   481| 		EventPipeEventInstance *next_event = ep_buffer_get_current_read_event (buffer_manager->current_buffer);
   482| 		ep_timestamp_t next_timestamp = ep_event_instance_get_timestamp (next_event);
   483| 		if (next_timestamp >= stop_timestamp) {
   484| 			buffer_manager->current_event = NULL;
   485| 			buffer_manager->current_buffer = NULL;
   486| 			buffer_manager->current_buffer_list = NULL;
   487| 		} else {
   488| 			buffer_manager->current_event = next_event;
   489| 			EP_ASSERT (buffer_manager->current_buffer != NULL);
   490| 			EP_ASSERT (buffer_manager->current_buffer_list != NULL);
   491| 		}
   492| 	} else {
   493| 		EP_ASSERT (buffer_manager->current_event == NULL);
   494| 		EP_ASSERT (buffer_manager->current_buffer == NULL);
   495| 		buffer_manager->current_buffer_list = NULL;
   496| 	}
   497| }
   498| static
   499| EventPipeBuffer *
   500| buffer_manager_advance_to_non_empty_buffer (
   501| 	EventPipeBufferManager *buffer_manager,
   502| 	EventPipeBufferList *buffer_list,
   503| 	EventPipeBuffer *buffer,
   504| 	ep_timestamp_t before_timestamp)
   505| {
   506| 	EP_ASSERT (buffer_manager != NULL);
   507| 	EP_ASSERT (buffer_list != NULL);
   508| 	EP_ASSERT (buffer != NULL);
   509| 	EP_ASSERT (buffer_list->head_buffer == buffer);
   510| 	ep_buffer_manager_requires_lock_not_held (buffer_manager);
   511| 	EventPipeBuffer *current_buffer = buffer;
   512| 	bool done = false;
   513| 	while (!done) {
   514| 		if (!buffer_manager_try_convert_buffer_to_read_only (buffer_manager, current_buffer)) {
   515| 			current_buffer = NULL;
   516| 			done = true;
   517| 		} else if (ep_buffer_get_current_read_event (current_buffer) != NULL) {
   518| 			done = true;
   519| 		} else {
   520| 			EP_SPIN_LOCK_ENTER (&buffer_manager->rt_lock, section1)
   521| 				EventPipeBuffer *removed_buffer = ep_buffer_list_get_and_remove_head (buffer_list);
   522| 				EP_ASSERT (current_buffer == removed_buffer);
   523| 				buffer_manager_deallocate_buffer (buffer_manager, removed_buffer);
   524| 				current_buffer = buffer_list->head_buffer;
   525| 				if (!current_buffer || ep_buffer_get_creation_timestamp (current_buffer) >= before_timestamp) {
   526| 					current_buffer = NULL;
   527| 					done = true;
   528| 				}
   529| 			EP_SPIN_LOCK_EXIT (&buffer_manager->rt_lock, section1)
   530| 		}
   531| 	}
   532| ep_on_exit:
   533| 	ep_buffer_manager_requires_lock_not_held (buffer_manager);
   534| 	return current_buffer;
   535| ep_on_error:
   536| 	current_buffer = NULL;
   537| 	ep_exit_error_handler ();
   538| }
   539| static
   540| bool
   541| buffer_manager_try_convert_buffer_to_read_only (
   542| 	EventPipeBufferManager *buffer_manager,
   543| 	EventPipeBuffer *new_read_buffer)
   544| {
   545| 	EP_ASSERT (buffer_manager != NULL);
   546| 	EP_ASSERT (new_read_buffer != NULL);
   547| 	ep_buffer_manager_requires_lock_not_held (buffer_manager);
   548| 	bool result = false;
   549| 	if (ep_buffer_get_volatile_state (new_read_buffer) == EP_BUFFER_STATE_READ_ONLY)
   550| 		return true;
   551| 	EventPipeThread *thread = ep_buffer_get_writer_thread (new_read_buffer);
   552| 	EP_SPIN_LOCK_ENTER (ep_thread_get_rt_lock_ref (thread), section1);
   553| 		EventPipeThreadSessionState *thread_session_state = ep_thread_get_session_state (thread, buffer_manager->session);
   554| 		EP_ASSERT(thread_session_state != NULL);
   555| 		if (ep_thread_session_state_get_write_buffer (thread_session_state) == new_read_buffer) {
   556| 			ep_thread_session_state_set_write_buffer (thread_session_state, NULL);
   557| 			EP_ASSERT (ep_buffer_get_volatile_state (new_read_buffer) == EP_BUFFER_STATE_READ_ONLY);
   558| 			result = true;
   559| 		}
   560| 	EP_SPIN_LOCK_EXIT (ep_thread_get_rt_lock_ref (thread), section1);
   561| 	if (!result)
   562| 		result = (ep_buffer_get_volatile_state (new_read_buffer) == EP_BUFFER_STATE_READ_ONLY);
   563| ep_on_exit:
   564| 	ep_buffer_manager_requires_lock_not_held (buffer_manager);
   565| 	return result;
   566| ep_on_error:
   567| 	EP_ASSERT (!result);
   568| 	ep_exit_error_handler ();
   569| }
   570| EventPipeBufferManager *
   571| ep_buffer_manager_alloc (
   572| 	EventPipeSession *session,
   573| 	size_t max_size_of_all_buffers,
   574| 	size_t sequence_point_allocation_budget)
   575| {
   576| 	EventPipeBufferManager *instance = ep_rt_object_alloc (EventPipeBufferManager);
   577| 	ep_raise_error_if_nok (instance != NULL);
   578| 	ep_rt_thread_session_state_list_alloc (&instance->thread_session_state_list);
   579| 	ep_raise_error_if_nok (ep_rt_thread_session_state_list_is_valid (&instance->thread_session_state_list));
   580| 	ep_rt_sequence_point_list_alloc (&instance->sequence_points);
   581| 	ep_raise_error_if_nok (ep_rt_sequence_point_list_is_valid (&instance->sequence_points));
   582| 	ep_rt_spin_lock_alloc (&instance->rt_lock);
   583| 	ep_raise_error_if_nok (ep_rt_spin_lock_is_valid (&instance->rt_lock));
   584| 	ep_rt_wait_event_alloc (&instance->rt_wait_event, false, true);
   585| 	ep_raise_error_if_nok (ep_rt_wait_event_is_valid (&instance->rt_wait_event));
   586| 	instance->session = session;
   587| 	instance->size_of_all_buffers = 0;
   588| 	instance->num_oversized_events_dropped = 0;
   589| #ifdef EP_CHECKED_BUILD
   590| 	instance->num_buffers_allocated = 0;
   591| 	instance->num_buffers_stolen = 0;
   592| 	instance->num_buffers_leaked = 0;
   593| 	instance->num_events_stored = 0;
   594| 	ep_rt_volatile_store_int64_t (&instance->num_events_dropped, 0);
   595| 	ep_rt_volatile_store_int64_t (&instance->num_events_written, 0);
   596| #endif
   597| 	instance->current_event = NULL;
   598| 	instance->current_buffer = NULL;
   599| 	instance->current_buffer_list = NULL;
   600| 	instance->max_size_of_all_buffers = EP_CLAMP ((size_t)100 * 1024, max_size_of_all_buffers, (size_t)UINT32_MAX);
   601| 	if (sequence_point_allocation_budget == 0) {
   602| 		instance->sequence_point_alloc_budget = 0;
   603| 		instance->remaining_sequence_point_alloc_budget = 0;
   604| 	} else {
   605| 		instance->sequence_point_alloc_budget = EP_CLAMP ((size_t)1024 * 1024, sequence_point_allocation_budget, (size_t)1024 * 1024 * 1024);
   606| 		instance->remaining_sequence_point_alloc_budget = sequence_point_allocation_budget;
   607| 	}
   608| ep_on_exit:
   609| 	return instance;
   610| ep_on_error:
   611| 	ep_buffer_manager_free (instance);
   612| 	instance = NULL;
   613| 	ep_exit_error_handler ();
   614| }
   615| void
   616| ep_buffer_manager_free (EventPipeBufferManager * buffer_manager)
   617| {
   618| 	ep_return_void_if_nok (buffer_manager != NULL);
   619| 	ep_buffer_manager_deallocate_buffers (buffer_manager);
   620| 	ep_rt_wait_event_free (&buffer_manager->rt_wait_event);
   621| 	ep_rt_spin_lock_free (&buffer_manager->rt_lock);
   622| 	ep_rt_object_free (buffer_manager);
   623| }
   624| #ifdef EP_CHECKED_BUILD
   625| void
   626| ep_buffer_manager_requires_lock_held (const EventPipeBufferManager *buffer_manager)
   627| {
   628| 	ep_rt_spin_lock_requires_lock_held (&buffer_manager->rt_lock);
   629| }
   630| void
   631| ep_buffer_manager_requires_lock_not_held (const EventPipeBufferManager *buffer_manager)
   632| {
   633| 	ep_rt_spin_lock_requires_lock_not_held (&buffer_manager->rt_lock);
   634| }
   635| #endif
   636| void
   637| ep_buffer_manager_init_sequence_point_thread_list (
   638| 	EventPipeBufferManager *buffer_manager,
   639| 	EventPipeSequencePoint *sequence_point)
   640| {
   641| 	EP_ASSERT (buffer_manager != NULL);
   642| 	EP_ASSERT (sequence_point != NULL);
   643| 	ep_buffer_manager_requires_lock_not_held (buffer_manager);
   644| 	EP_SPIN_LOCK_ENTER (&buffer_manager->rt_lock, section1)
   645| 		buffer_manager_init_sequence_point_thread_list (buffer_manager, sequence_point);
   646| 	EP_SPIN_LOCK_EXIT (&buffer_manager->rt_lock, section1)
   647| ep_on_exit:
   648| 	ep_buffer_manager_requires_lock_not_held (buffer_manager);
   649| 	return;
   650| ep_on_error:
   651| 	ep_exit_error_handler ();
   652| }
   653| bool
   654| ep_buffer_manager_write_event (
   655| 	EventPipeBufferManager *buffer_manager,
   656| 	ep_rt_thread_handle_t thread,
   657| 	EventPipeSession *session,
   658| 	EventPipeEvent *ep_event,
   659| 	EventPipeEventPayload *payload,
   660| 	const uint8_t *activity_id,
   661| 	const uint8_t *related_activity_id,
   662| 	ep_rt_thread_handle_t event_thread,
   663| 	EventPipeStackContents *stack)
   664| {
   665| 	bool result = false;
   666| 	bool alloc_new_buffer = false;
   667| 	EventPipeBuffer *buffer = NULL;
   668| 	EventPipeThreadSessionState *session_state = NULL;
   669| 	EventPipeStackContents stack_contents;
   670| 	EventPipeStackContents *current_stack_contents = NULL;
   671| 	EP_ASSERT (buffer_manager != NULL);
   672| 	EP_ASSERT (ep_event != NULL);
   673| 	EP_ASSERT (thread == ep_rt_thread_get_handle ());
   674| 	ep_return_false_if_nok (ep_event_is_enabled (ep_event));
   675| 	if (ep_event_payload_get_size (payload) > 64 * 1024)
   676| 	{
   677| 		ep_rt_atomic_inc_int64_t (&buffer_manager->num_oversized_events_dropped);
   678| 		EventPipeThread *current_thread = ep_thread_get();
   679| 		ep_rt_spin_lock_handle_t *thread_lock = ep_thread_get_rt_lock_ref (current_thread);
   680| 		EP_SPIN_LOCK_ENTER (thread_lock, section1)
   681| 			session_state = ep_thread_get_or_create_session_state (current_thread, session);
   682| 			ep_thread_session_state_increment_sequence_number (session_state);
   683| 		EP_SPIN_LOCK_EXIT (thread_lock, section1)
   684| 		return false;
   685| 	}
   686| 	if (event_thread == NULL)
   687| 		event_thread = thread;
   688| 	current_stack_contents = ep_stack_contents_init (&stack_contents);
   689| 	if (stack == NULL && ep_session_get_enable_stackwalk (session) && ep_event_get_need_stack (ep_event) && !ep_session_get_rundown_enabled (session)) {
   690| 		ep_walk_managed_stack_for_current_thread (current_stack_contents);
   691| 		stack = current_stack_contents;
   692| 	}
   693| 	EventPipeThread *current_thread;
   694| 	current_thread = ep_thread_get ();
   695| 	ep_raise_error_if_nok (current_thread != NULL);
   696| 	ep_rt_spin_lock_handle_t *thread_lock;
   697| 	thread_lock = ep_thread_get_rt_lock_ref (current_thread);
   698| 	EP_SPIN_LOCK_ENTER (thread_lock, section2)
   699| 		session_state = ep_thread_get_or_create_session_state (current_thread, session);
   700| 		ep_raise_error_if_nok_holding_spin_lock (session_state != NULL, section2);
   701| 		buffer = ep_thread_session_state_get_write_buffer (session_state);
   702| 		if (!buffer) {
   703| 			alloc_new_buffer = true;
   704| 		} else {
   705| 			if (ep_buffer_write_event (buffer, event_thread, session, ep_event, payload, activity_id, related_activity_id, stack))
   706| 				ep_thread_session_state_increment_sequence_number (session_state);
   707| 			else
   708| 				alloc_new_buffer = true;
   709| 		}
   710| 	EP_SPIN_LOCK_EXIT (thread_lock, section2)
   711| 	bool should_signal_reader_thread;
   712| 	should_signal_reader_thread = alloc_new_buffer;
   713| 	if (alloc_new_buffer) {
   714| 		uint32_t request_size = sizeof (EventPipeEventInstance) + ep_event_payload_get_size (payload);
   715| 		bool write_suspended = false;
   716| 		buffer = buffer_manager_allocate_buffer_for_thread (buffer_manager, session_state, request_size, &write_suspended);
   717| 		if (!buffer) {
   718| 			ep_raise_error_if_nok (!write_suspended);
   719| 			EP_SPIN_LOCK_ENTER (thread_lock, section3)
   720| 				ep_thread_session_state_increment_sequence_number (session_state);
   721| 			EP_SPIN_LOCK_EXIT (thread_lock, section3)
   722| 		} else {
   723| 			current_thread = ep_thread_get ();
   724| 			EP_ASSERT (current_thread != NULL);
   725| 			thread_lock = ep_thread_get_rt_lock_ref (current_thread);
   726| 			EP_SPIN_LOCK_ENTER (thread_lock, section4)
   727| 					ep_thread_session_state_set_write_buffer (session_state, buffer);
   728| 					alloc_new_buffer = !ep_buffer_write_event (buffer, event_thread, session, ep_event, payload, activity_id, related_activity_id, stack);
   729| 					EP_ASSERT(!alloc_new_buffer);
   730| 					ep_thread_session_state_increment_sequence_number (session_state);
   731| 			EP_SPIN_LOCK_EXIT (thread_lock, section4)
   732| 		}
   733| 	}
   734| 	if (should_signal_reader_thread)
   735| 		ep_rt_wait_event_set (&buffer_manager->rt_wait_event);
   736| #ifdef EP_CHECKED_BUILD
   737| 	if (!alloc_new_buffer)
   738| 		ep_rt_atomic_inc_int64_t (&buffer_manager->num_events_stored);
   739| 	else
   740| 		ep_rt_atomic_inc_int64_t (&buffer_manager->num_events_dropped);
   741| #endif
   742| 	result = !alloc_new_buffer;
   743| ep_on_exit:
   744| 	ep_stack_contents_fini (current_stack_contents);
   745| 	return result;
   746| ep_on_error:
   747| 	ep_exit_error_handler ();
   748| }
   749| void
   750| ep_buffer_manager_suspend_write_event (
   751| 	EventPipeBufferManager *buffer_manager,
   752| 	uint32_t session_index)
   753| {
   754| 	EP_ASSERT (buffer_manager != NULL);
   755| 	ep_requires_lock_held ();
   756| 	EP_RT_DECLARE_LOCAL_THREAD_ARRAY (thread_array);
   757| 	ep_rt_thread_array_init (&thread_array);
   758| 	EP_SPIN_LOCK_ENTER (&buffer_manager->rt_lock, section1);
   759| 		EP_ASSERT (ep_buffer_manager_ensure_consistency (buffer_manager));
   760| 		ep_rt_thread_session_state_list_iterator_t thread_session_state_list_iterator = ep_rt_thread_session_state_list_iterator_begin (&buffer_manager->thread_session_state_list);
   761| 		while (!ep_rt_thread_session_state_list_iterator_end (&buffer_manager->thread_session_state_list, &thread_session_state_list_iterator)) {
   762| 			EventPipeThread *thread = ep_thread_session_state_get_thread (ep_rt_thread_session_state_list_iterator_value (&thread_session_state_list_iterator));
   763| 			ep_rt_thread_array_append (&thread_array, thread);
   764| 			ep_rt_thread_session_state_list_iterator_next (&thread_session_state_list_iterator);
   765| 		}
   766| 	EP_SPIN_LOCK_EXIT (&buffer_manager->rt_lock, section1);
   767| 	ep_rt_thread_array_iterator_t thread_array_iterator;
   768| 	thread_array_iterator = ep_rt_thread_array_iterator_begin (&thread_array);
   769| 	while (!ep_rt_thread_array_iterator_end (&thread_array, &thread_array_iterator)) {
   770| 		EventPipeThread *thread = ep_rt_thread_array_iterator_value (&thread_array_iterator);
   771| 		EP_SPIN_LOCK_ENTER (ep_thread_get_rt_lock_ref (thread), section2)
   772| 			EventPipeThreadSessionState *thread_session_state = ep_thread_get_session_state (thread, buffer_manager->session);
   773| 			EP_ASSERT(thread_session_state != NULL);
   774| 			ep_thread_session_state_set_write_buffer (thread_session_state, NULL);
   775| 		EP_SPIN_LOCK_EXIT (ep_thread_get_rt_lock_ref (thread), section2)
   776| 		ep_rt_thread_array_iterator_next (&thread_array_iterator);
   777| 	}
   778| ep_on_exit:
   779| 	ep_requires_lock_held ();
   780| 	ep_rt_thread_array_fini (&thread_array);
   781| 	return;
   782| ep_on_error:
   783| 	ep_exit_error_handler ();
   784| }
   785| void
   786| ep_buffer_manager_write_all_buffers_to_file (
   787| 	EventPipeBufferManager *buffer_manager,
   788| 	EventPipeFile *file,
   789| 	ep_timestamp_t stop_timestamp,
   790| 	bool *events_written)
   791| {
   792| 	EP_ASSERT (buffer_manager != NULL);
   793| 	EP_ASSERT (file != NULL);
   794| 	EP_ASSERT (buffer_manager->current_event == NULL);
   795| 	if (ep_file_get_format (file) >= EP_SERIALIZATION_FORMAT_NETTRACE_V4)
   796| 		ep_buffer_manager_write_all_buffers_to_file_v4 (buffer_manager, file, stop_timestamp, events_written);
   797| 	else
   798| 		ep_buffer_manager_write_all_buffers_to_file_v3 (buffer_manager, file, stop_timestamp, events_written);
   799| }
   800| void
   801| ep_buffer_manager_write_all_buffers_to_file_v3 (
   802| 	EventPipeBufferManager *buffer_manager,
   803| 	EventPipeFile *file,
   804| 	ep_timestamp_t stop_timestamp,
   805| 	bool *events_written)
   806| {
   807| 	EP_ASSERT (buffer_manager != NULL);
   808| 	EP_ASSERT (file != NULL);
   809| 	EP_ASSERT (buffer_manager->current_event == NULL);
   810| 	EP_ASSERT (events_written != NULL);
   811| 	*events_written = false;
   812| 	buffer_manager_move_next_event_any_thread (buffer_manager, stop_timestamp);
   813| 	while (buffer_manager->current_event != NULL) {
   814| 		*events_written = true;
   815| 		ep_file_write_event (file, buffer_manager->current_event, /*CaptureThreadId=*/0, /*sequenceNumber=*/0, /*IsSorted=*/true);
   816| 		buffer_manager_move_next_event_any_thread (buffer_manager, stop_timestamp);
   817| 	}
   818| 	ep_file_flush (file, EP_FILE_FLUSH_FLAGS_ALL_BLOCKS);
   819| }
   820| void
   821| ep_buffer_manager_write_all_buffers_to_file_v4 (
   822| 	EventPipeBufferManager *buffer_manager,
   823| 	EventPipeFile *file,
   824| 	ep_timestamp_t stop_timestamp,
   825| 	bool *events_written)
   826| {
   827| 	EP_ASSERT (buffer_manager != NULL);
   828| 	EP_ASSERT (file != NULL);
   829| 	EP_ASSERT (buffer_manager->current_event == NULL);
   830| 	EP_ASSERT (events_written != NULL);
   831| 	*events_written = false;
   832| 	EP_RT_DECLARE_LOCAL_THREAD_SESSION_STATE_ARRAY(session_states_to_delete);
   833| 	ep_rt_thread_session_state_array_init(&session_states_to_delete);
   834| 	EventPipeSequencePoint *sequence_point = NULL;
   835| 	ep_timestamp_t current_timestamp_boundary = stop_timestamp;
   836| 	EP_SPIN_LOCK_ENTER (&buffer_manager->rt_lock, section1)
   837| 		if (buffer_manager_try_peek_sequence_point (buffer_manager, &sequence_point))
   838| 			current_timestamp_boundary = EP_MIN (current_timestamp_boundary, ep_sequence_point_get_timestamp (sequence_point));
   839| 	EP_SPIN_LOCK_EXIT (&buffer_manager->rt_lock, section1)
   840| 	while(true) {
   841| 		while (true) {
   842| 			buffer_manager_move_next_event_any_thread (buffer_manager, current_timestamp_boundary);
   843| 			if (buffer_manager->current_event == NULL)
   844| 				break;
   845| 			uint64_t capture_thread_id = ep_thread_get_os_thread_id (ep_buffer_get_writer_thread (buffer_manager->current_buffer));
   846| 			EventPipeBufferList *buffer_list = buffer_manager->current_buffer_list;
   847| 			bool events_written_for_thread = false;
   848| 			uint32_t sequence_number = 0;
   849| 			while (buffer_manager->current_event != NULL) {
   850| 				sequence_number = ep_buffer_get_current_sequence_number (buffer_manager->current_buffer);
   851| 				ep_file_write_event (file, buffer_manager->current_event, capture_thread_id, sequence_number, !events_written_for_thread);
   852| 				events_written_for_thread = true;
   853| 				buffer_manager_move_next_event_same_thread (buffer_manager, current_timestamp_boundary);
   854| 			}
   855| 			buffer_list->last_read_sequence_number = sequence_number;
   856| 			*events_written = events_written_for_thread || *events_written;
   857| 		}
   858| 		ep_file_flush (file, EP_FILE_FLUSH_FLAGS_ALL_BLOCKS);
   859| 		if (current_timestamp_boundary == stop_timestamp) {
   860| 			break;
   861| 		} else {
   862| 			EP_SPIN_LOCK_ENTER (&buffer_manager->rt_lock, section2)
   863| 				ep_rt_thread_session_state_list_iterator_t thread_session_state_list_iterator = ep_rt_thread_session_state_list_iterator_begin (&buffer_manager->thread_session_state_list);
   864| 				while (!ep_rt_thread_session_state_list_iterator_end (&buffer_manager->thread_session_state_list, &thread_session_state_list_iterator)) {
   865| 					EventPipeThreadSessionState * session_state = ep_rt_thread_session_state_list_iterator_value (&thread_session_state_list_iterator);
   866| 					uint32_t thread_sequence_number = 0;
   867| 					bool exists = ep_rt_thread_sequence_number_map_lookup (ep_sequence_point_get_thread_sequence_numbers_cref (sequence_point), session_state, &thread_sequence_number);
   868| 					uint32_t last_read_sequence_number = ep_thread_session_state_get_buffer_list (session_state)->last_read_sequence_number;
   869| 					uint32_t last_read_delta = last_read_sequence_number - thread_sequence_number;
   870| 					if (0 < last_read_delta && last_read_delta < 0x80000000) {
   871| 						if (exists) {
   872| 							ep_rt_thread_sequence_number_map_remove (ep_sequence_point_get_thread_sequence_numbers_ref (sequence_point), session_state);
   873| 						} else {
   874| 							ep_thread_addref (ep_thread_holder_get_thread (ep_thread_session_state_get_thread_holder_ref (session_state)));
   875| 						}
   876| 						ep_rt_thread_sequence_number_map_add (ep_sequence_point_get_thread_sequence_numbers_ref (sequence_point), session_state, last_read_sequence_number);
   877| 					}
   878| 					ep_rt_thread_session_state_list_iterator_next (&thread_session_state_list_iterator);
   879| 					if (ep_thread_session_state_get_buffer_list (session_state)->head_buffer == NULL) {
   880| 						if (ep_rt_volatile_load_uint32_t_without_barrier (ep_thread_get_unregistered_ref (ep_thread_session_state_get_thread (session_state))) > 0) {
   881| 							ep_rt_thread_session_state_array_append (&session_states_to_delete, session_state);
   882| 							ep_rt_thread_session_state_list_remove (&buffer_manager->thread_session_state_list, session_state);
   883| 						}
   884| 					}
   885| 				}
   886| 			EP_SPIN_LOCK_EXIT (&buffer_manager->rt_lock, section2)
   887| 			ep_file_write_sequence_point (file, sequence_point);
   888| 			EP_SPIN_LOCK_ENTER (&buffer_manager->rt_lock, section3)
   889| 				buffer_manager_dequeue_sequence_point (buffer_manager);
   890| 				current_timestamp_boundary = stop_timestamp;
   891| 				if (buffer_manager_try_peek_sequence_point (buffer_manager, &sequence_point))
   892| 					current_timestamp_boundary = EP_MIN (current_timestamp_boundary, ep_sequence_point_get_timestamp (sequence_point));
   893| 			EP_SPIN_LOCK_EXIT (&buffer_manager->rt_lock, section3)
   894| 		}
   895| 	}
   896| 	if (ep_rt_thread_session_state_array_size (&session_states_to_delete) > 0) {
   897| 		EP_SPIN_LOCK_ENTER (&buffer_manager->rt_lock, section4)
   898| 			if (buffer_manager_try_peek_sequence_point (buffer_manager, &sequence_point)) {
   899| 				for (ep_rt_sequence_point_list_iterator_t sequence_point_list_iterator = ep_rt_sequence_point_list_iterator_begin (&buffer_manager->sequence_points);
   900| 					!ep_rt_sequence_point_list_iterator_end (&buffer_manager->sequence_points, &sequence_point_list_iterator);
   901| 					ep_rt_sequence_point_list_iterator_next (&sequence_point_list_iterator)) {
   902| 					sequence_point = ep_rt_sequence_point_list_iterator_value (&sequence_point_list_iterator);
   903| 					for (ep_rt_thread_session_state_array_iterator_t thread_session_state_array_iterator = ep_rt_thread_session_state_array_iterator_begin (&session_states_to_delete);
   904| 						!ep_rt_thread_session_state_array_iterator_end (&session_states_to_delete, &thread_session_state_array_iterator);
   905| 						ep_rt_thread_session_state_array_iterator_next (&thread_session_state_array_iterator)) {
   906| 						EventPipeThreadSessionState * thread_session_state = ep_rt_thread_session_state_array_iterator_value (&thread_session_state_array_iterator);
   907| 						uint32_t unused_thread_sequence_number = 0;
   908| 						bool exists = ep_rt_thread_sequence_number_map_lookup (ep_sequence_point_get_thread_sequence_numbers_cref (sequence_point), thread_session_state, &unused_thread_sequence_number);
   909| 						if (exists) {
   910| 							ep_rt_thread_sequence_number_map_remove (ep_sequence_point_get_thread_sequence_numbers_ref (sequence_point), thread_session_state);
   911| 							ep_thread_release (ep_thread_session_state_get_thread (thread_session_state));
   912| 						}
   913| 					}
   914| 				}
   915| 			}
   916| 		EP_SPIN_LOCK_EXIT (&buffer_manager->rt_lock, section4)
   917| 	}
   918| 	for (ep_rt_thread_session_state_array_iterator_t thread_session_state_array_iterator = ep_rt_thread_session_state_array_iterator_begin (&session_states_to_delete);
   919| 		!ep_rt_thread_session_state_array_iterator_end (&session_states_to_delete, &thread_session_state_array_iterator);
   920| 		ep_rt_thread_session_state_array_iterator_next (&thread_session_state_array_iterator)) {
   921| 		EventPipeThreadSessionState * thread_session_state = ep_rt_thread_session_state_array_iterator_value (&thread_session_state_array_iterator);
   922| 		EP_ASSERT (thread_session_state != NULL);
   923| 		EventPipeThreadHolder thread_holder;
   924| 		if (ep_thread_holder_init (&thread_holder, ep_thread_session_state_get_thread (thread_session_state))) {
   925| 			ep_rt_spin_lock_handle_t *thread_lock = ep_thread_get_rt_lock_ref (ep_thread_holder_get_thread (&thread_holder));
   926| 			EP_SPIN_LOCK_ENTER (thread_lock, section5)
   927| 				EP_ASSERT(ep_rt_volatile_load_uint32_t_without_barrier (ep_thread_get_unregistered_ref (ep_thread_session_state_get_thread (thread_session_state))) > 0);
   928| 				ep_thread_delete_session_state (ep_thread_session_state_get_thread (thread_session_state), ep_thread_session_state_get_session (thread_session_state));
   929| 			EP_SPIN_LOCK_EXIT (thread_lock, section5)
   930| 			ep_thread_holder_fini (&thread_holder);
   931| 		}
   932| 	}
   933| ep_on_exit:
   934| 	ep_rt_thread_session_state_array_fini(&session_states_to_delete);
   935| 	return;
   936| ep_on_error:
   937| 	ep_exit_error_handler ();
   938| }
   939| EventPipeEventInstance *
   940| ep_buffer_manager_get_next_event (EventPipeBufferManager *buffer_manager)
   941| {
   942| 	EP_ASSERT (buffer_manager != NULL);
   943| 	ep_requires_lock_not_held ();
   944| 	ep_timestamp_t stop_timestamp = ep_perf_timestamp_get ();
   945| 	buffer_manager_move_next_event_any_thread (buffer_manager, stop_timestamp);
   946| 	return buffer_manager->current_event;
   947| }
   948| void
   949| ep_buffer_manager_deallocate_buffers (EventPipeBufferManager *buffer_manager)
   950| {
   951| 	EP_ASSERT (buffer_manager != NULL);
   952| 	EP_RT_DECLARE_LOCAL_THREAD_SESSION_STATE_ARRAY(thread_session_states_to_remove);
   953| 	ep_rt_thread_session_state_array_init (&thread_session_states_to_remove);
   954| 	EP_SPIN_LOCK_ENTER (&buffer_manager->rt_lock, section1)
   955| 		EP_ASSERT (ep_buffer_manager_ensure_consistency (buffer_manager));
   956| 		ep_rt_thread_session_state_list_iterator_t thread_session_state_list_iterator = ep_rt_thread_session_state_list_iterator_begin (&buffer_manager->thread_session_state_list);
   957| 		while (!ep_rt_thread_session_state_list_iterator_end (&buffer_manager->thread_session_state_list, &thread_session_state_list_iterator)) {
   958| 			EventPipeThreadSessionState *thread_session_state = ep_rt_thread_session_state_list_iterator_value (&thread_session_state_list_iterator);
   959| 			EventPipeBufferList *buffer_list = ep_thread_session_state_get_buffer_list (thread_session_state);
   960| 			ep_thread_session_state_set_buffer_list (thread_session_state, NULL);
   961| 			EventPipeBuffer *buffer = ep_buffer_list_get_and_remove_head (buffer_list);
   962| 			while (buffer) {
   963| 				buffer_manager_deallocate_buffer (buffer_manager, buffer);
   964| 				buffer = ep_buffer_list_get_and_remove_head (buffer_list);
   965| 			}
   966| 			ep_buffer_list_free (buffer_list);
   967| 			buffer_list = NULL;
   968| 			ep_rt_thread_session_state_array_append (&thread_session_states_to_remove, thread_session_state);
   969| 			ep_rt_thread_session_state_list_iterator_next (&thread_session_state_list_iterator);
   970| 		}
   971| 		ep_rt_thread_session_state_list_free (&buffer_manager->thread_session_state_list, NULL);
   972| 	EP_SPIN_LOCK_EXIT (&buffer_manager->rt_lock, section1)
   973| 	ep_rt_thread_session_state_array_iterator_t thread_session_states_to_remove_iterator;
   974| 	thread_session_states_to_remove_iterator = ep_rt_thread_session_state_array_iterator_begin (&thread_session_states_to_remove);
   975| 	while (!ep_rt_thread_session_state_array_iterator_end (&thread_session_states_to_remove, &thread_session_states_to_remove_iterator)) {
   976| 		EventPipeThreadSessionState *thread_session_state = ep_rt_thread_session_state_array_iterator_value (&thread_session_states_to_remove_iterator);
   977| 		EP_ASSERT (thread_session_state != NULL);
   978| 		EventPipeThreadHolder thread_holder;
   979| 		if (ep_thread_holder_init (&thread_holder, ep_thread_session_state_get_thread (thread_session_state))) {
   980| 			ep_rt_spin_lock_handle_t *thread_lock = ep_thread_get_rt_lock_ref (ep_thread_session_state_get_thread (thread_session_state));
   981| 			EP_SPIN_LOCK_ENTER (thread_lock, section2)
   982| 				ep_thread_delete_session_state (ep_thread_session_state_get_thread (thread_session_state), ep_thread_session_state_get_session (thread_session_state));
   983| 			EP_SPIN_LOCK_EXIT (thread_lock, section2)
   984| 			ep_thread_holder_fini (&thread_holder);
   985| 		}
   986| 		ep_rt_thread_session_state_array_iterator_next (&thread_session_states_to_remove_iterator);
   987| 	}
   988| ep_on_exit:
   989| 	ep_rt_thread_session_state_array_fini (&thread_session_states_to_remove);
   990| 	return;
   991| ep_on_error:
   992| 	ep_exit_error_handler ();
   993| }
   994| #ifdef EP_CHECKED_BUILD
   995| bool
   996| ep_buffer_manager_ensure_consistency (EventPipeBufferManager *buffer_manager)
   997| {
   998| 	EP_ASSERT (buffer_manager != NULL);
   999| 	ep_rt_thread_session_state_list_iterator_t iterator = ep_rt_thread_session_state_list_iterator_begin (&buffer_manager->thread_session_state_list);
  1000| 	while (!ep_rt_thread_session_state_list_iterator_end (&buffer_manager->thread_session_state_list, &iterator)) {
  1001| 		EventPipeThreadSessionState *thread_session_state = ep_rt_thread_session_state_list_iterator_value (&iterator);
  1002| 		EP_ASSERT (ep_buffer_list_ensure_consistency (ep_thread_session_state_get_buffer_list (thread_session_state)));
  1003| 		ep_rt_thread_session_state_list_iterator_next (&iterator);
  1004| 	}
  1005| 	return true;
  1006| }
  1007| #endif
  1008| #endif /* !defined(EP_INCLUDE_SOURCE_FILES) || defined(EP_FORCE_INCLUDE_SOURCE_FILES) */
  1009| #endif /* ENABLE_PERFTRACING */
  1010| #if !defined(ENABLE_PERFTRACING) || (defined(EP_INCLUDE_SOURCE_FILES) && !defined(EP_FORCE_INCLUDE_SOURCE_FILES))
  1011| extern const char quiet_linker_empty_file_warning_eventpipe_buffer_manager;
  1012| const char quiet_linker_empty_file_warning_eventpipe_buffer_manager = 0;
  1013| #endif


# ====================================================================
# FILE: src/native/eventpipe/ep-rt.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-792 ---
     1| #ifndef __EVENTPIPE_RT_H__
     2| #define __EVENTPIPE_RT_H__
     3| #include "ep-rt-config.h"
     4| #include <minipal/utils.h>
     5| #ifdef ENABLE_PERFTRACING
     6| #include "ep-types.h"
     7| #define EP_INFINITE_WAIT ep_rt_redefine
     8| #define EP_GCX_PREEMP_ENTER ep_rt_redefine
     9| #define EP_GCX_PREEMP_EXIT ep_rt_redefine
    10| #define EP_YIELD_WHILE(condition) ep_rt_redefine
    11| #define EP_ALWAYS_INLINE ep_rt_redefine
    12| #define EP_NEVER_INLINE ep_rt_redefine
    13| #define EP_ALIGN_UP(val,align) ep_rt_redefine
    14| #ifndef EP_RT_BUILD_TYPE_FUNC_NAME
    15| #define EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, type_name, func_name) \
    16| prefix_name ## _rt_ ## type_name ## _ ## func_name
    17| #endif
    18| #define EP_RT_DECLARE_LIST_PREFIX(prefix_name, list_name, list_type, item_type) \
    19| 	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, alloc) (list_type *list); \
    20| 	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, free) (list_type *list, void (*callback)(void *)); \
    21| 	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, clear) (list_type *list, void (*callback)(void *)); \
    22| 	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, append) (list_type *list, item_type item); \
    23| 	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, remove) (list_type *list, const item_type item); \
    24| 	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, find) (const list_type *list, const item_type item_to_find, item_type *found_item); \
    25| 	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, is_empty) (const list_type *list); \
    26| 	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, is_valid) (const list_type *list);
    27| #define EP_RT_DECLARE_LIST(list_name, list_type, item_type) \
    28| 	EP_RT_DECLARE_LIST_PREFIX(ep, list_name, list_type, item_type)
    29| #define EP_RT_DEFINE_LIST ep_rt_redefine
    30| #define EP_RT_DECLARE_LIST_ITERATOR_PREFIX(prefix_name, list_name, list_type, iterator_type, item_type) \
    31| 	static iterator_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, iterator_begin) (const list_type *list); \
    32| 	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, iterator_end) (const list_type *list, const iterator_type *iterator); \
    33| 	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, iterator_next) (iterator_type *iterator); \
    34| 	static item_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, list_name, iterator_value) (const iterator_type *iterator);
    35| #define EP_RT_DECLARE_LIST_ITERATOR(list_name, list_type, iterator_type, item_type) \
    36| 	EP_RT_DECLARE_LIST_ITERATOR_PREFIX(ep, list_name, list_type, iterator_type, item_type)
    37| #define EP_RT_DEFINE_LIST_ITERATOR ep_rt_redefine
    38| #define EP_RT_DECLARE_QUEUE_PREFIX(prefix_name, queue_name, queue_type, item_type) \
    39| 	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, alloc) (queue_type *queue); \
    40| 	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, free) (queue_type *queue); \
    41| 	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, pop_head) (queue_type *queue, item_type *item); \
    42| 	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, push_head) (queue_type *queue, item_type item); \
    43| 	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, push_tail) (queue_type *queue, item_type item); \
    44| 	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, is_empty) (const queue_type *queue); \
    45| 	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, queue_name, is_valid) (const queue_type *queue);
    46| #define EP_RT_DECLARE_QUEUE(queue_name, queue_type, item_type) \
    47| 	EP_RT_DECLARE_QUEUE_PREFIX(ep, queue_name, queue_type, item_type)
    48| #define EP_RT_DEFINE_QUEUE ep_rt_redefine
    49| #define EP_RT_DECLARE_ARRAY_PREFIX(prefix_name, array_name, array_type, iterator_type, item_type) \
    50| 	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, alloc) (array_type *ep_array); \
    51| 	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, alloc_capacity) (array_type *ep_array, size_t capacity); \
    52| 	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, free) (array_type *ep_array); \
    53| 	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, append) (array_type *ep_array, item_type item); \
    54| 	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, clear) (array_type *ep_array); \
    55| 	static size_t EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, size) (const array_type *ep_array); \
    56| 	static item_type * EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, data) (const array_type *ep_array); \
    57| 	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, is_valid) (const array_type *ep_array);
    58| #define EP_RT_DECLARE_LOCAL_ARRAY_PREFIX(prefix_name, array_name, array_type, iterator_type, item_type) \
    59| 	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, init) (array_type *ep_array); \
    60| 	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, init_capacity) (array_type *ep_array, size_t capacity); \
    61| 	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, fini) (array_type *ep_array);
    62| #define EP_RT_DECLARE_ARRAY(array_name, array_type, iterator_type, item_type) \
    63| 	EP_RT_DECLARE_ARRAY_PREFIX(ep, array_name, array_type, iterator_type, item_type)
    64| #define EP_RT_DEFINE_ARRAY ep_rt_redefine
    65| #define EP_RT_DECLARE_LOCAL_ARRAY(array_name, array_type, iterator_type, item_type) \
    66| 	EP_RT_DECLARE_LOCAL_ARRAY_PREFIX(ep, array_name, array_type, iterator_type, item_type)
    67| #define EP_RT_DEFINE_LOCAL_ARRAY ep_rt_redefine
    68| #define EP_RT_DECLARE_ARRAY_ITERATOR_PREFIX(prefix_name, array_name, array_type, iterator_type, item_type) \
    69| 	static iterator_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, iterator_begin) (const array_type *ep_array); \
    70| 	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, iterator_end) (const array_type *ep_array, const iterator_type *iterator); \
    71| 	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, iterator_next) (iterator_type *iterator); \
    72| 	static item_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, iterator_value) (const iterator_type *iterator);
    73| #define EP_RT_DECLARE_ARRAY_REVERSE_ITERATOR_PREFIX(prefix_name, array_name, array_type, iterator_type, item_type) \
    74| 	static iterator_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, reverse_iterator_begin) (const array_type *ep_array); \
    75| 	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, reverse_iterator_end) (const array_type *ep_array, const iterator_type *iterator); \
    76| 	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, reverse_iterator_next) (iterator_type *iterator); \
    77| 	static item_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, array_name, reverse_iterator_value) (const iterator_type *iterator);
    78| #define EP_RT_DECLARE_ARRAY_ITERATOR(array_name, array_type, iterator_type, item_type) \
    79| 	EP_RT_DECLARE_ARRAY_ITERATOR_PREFIX(ep, array_name, array_type, iterator_type, item_type)
    80| #define EP_RT_DEFINE_ARRAY_ITERATOR ep_rt_redefine
    81| #define EP_RT_DECLARE_ARRAY_REVERSE_ITERATOR(array_name, array_type, iterator_type, item_type) \
    82| 	EP_RT_DECLARE_ARRAY_REVERSE_ITERATOR_PREFIX(ep, array_name, array_type, iterator_type, item_type)
    83| #define EP_RT_DEFINE_ARRAY_REVERSE_ITERATOR ep_rt_redefine
    84| #ifndef EP_RT_USE_CUSTOM_HASH_MAP_CALLBACKS
    85| typedef uint32_t (*ep_rt_hash_map_hash_callback_t)(const void *);
    86| typedef bool (*ep_rt_hash_map_equal_callback_t)(const void *, const void *);
    87| #endif
    88| #define EP_RT_DECLARE_HASH_MAP_BASE_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
    89| 	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, alloc) (hash_map_type *hash_map, ep_rt_hash_map_hash_callback_t hash_callback, ep_rt_hash_map_equal_callback_t eq_callback, void (*key_free_callback)(void *), void (*value_free_callback)(void *)); \
    90| 	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, free) (hash_map_type *hash_map); \
    91| 	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, add) (hash_map_type *hash_map, key_type key, value_type value); \
    92| 	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, remove_all) (hash_map_type *hash_map); \
    93| 	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, lookup) (const hash_map_type *hash_map, const key_type key, value_type *value); \
    94| 	static uint32_t EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, count) (const hash_map_type *hash_map); \
    95| 	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, is_valid) (const hash_map_type *hash_map);
    96| #define EP_RT_DECLARE_HASH_MAP_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
    97| 	EP_RT_DECLARE_HASH_MAP_BASE_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
    98| 	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, add_or_replace) (hash_map_type *hash_map, key_type key, value_type value);
    99| #define EP_RT_DECLARE_HASH_MAP_REMOVE_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
   100| 	EP_RT_DECLARE_HASH_MAP_BASE_PREFIX(prefix_name, hash_map_name, hash_map_type, key_type, value_type) \
   101| 	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, remove) (hash_map_type *hash_map, const key_type key);
   102| #define EP_RT_DECLARE_HASH_MAP(hash_map_name, hash_map_type, key_type, value_type) \
   103| 	EP_RT_DECLARE_HASH_MAP_PREFIX(ep, hash_map_name, hash_map_type, key_type, value_type)
   104| #define EP_RT_DEFINE_HASH_MAP ep_rt_redefine
   105| #define EP_RT_DECLARE_HASH_MAP_REMOVE(hash_map_name, hash_map_type, key_type, value_type) \
   106| 	EP_RT_DECLARE_HASH_MAP_REMOVE_PREFIX(ep, hash_map_name, hash_map_type, key_type, value_type)
   107| #define EP_RT_DEFINE_HASH_MAP_REMOVE ep_rt_redefine
   108| #define EP_RT_DECLARE_HASH_MAP_ITERATOR_PREFIX(prefix_name, hash_map_name, hash_map_type, iterator_type, key_type, value_type) \
   109| 	static iterator_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_begin) (const hash_map_type *hash_map); \
   110| 	static bool EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_end) (const hash_map_type *hash_map, const iterator_type *iterator); \
   111| 	static void EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_next) (iterator_type *iterator); \
   112| 	static key_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_key) (const iterator_type *iterator); \
   113| 	static value_type EP_RT_BUILD_TYPE_FUNC_NAME(prefix_name, hash_map_name, iterator_value) (const iterator_type *iterator);
   114| #define EP_RT_DECLARE_HASH_MAP_ITERATOR(hash_map_name, hash_map_type, iterator_type, key_type, value_type) \
   115| 	EP_RT_DECLARE_HASH_MAP_ITERATOR_PREFIX(ep, hash_map_name, hash_map_type, iterator_type, key_type, value_type)
   116| #define EP_RT_DEFINE_HASH_MAP_ITERATOR ep_rt_redefine
   117| /*
   118|  * Little-Endian Conversion.
   119|  */
   120| static
   121| inline
   122| uint16_t
   123| ep_rt_val_uint16_t (uint16_t value);
   124| static
   125| inline
   126| uint32_t
   127| ep_rt_val_uint32_t (uint32_t value);
   128| static
   129| inline
   130| uint64_t
   131| ep_rt_val_uint64_t (uint64_t value);
   132| static
   133| inline
   134| int16_t
   135| ep_rt_val_int16_t (int16_t value);
   136| static
   137| inline
   138| int32_t
   139| ep_rt_val_int32_t (int32_t value);
   140| static
   141| inline
   142| int64_t
   143| ep_rt_val_int64_t (int64_t value);
   144| static
   145| inline
   146| uintptr_t
   147| ep_rt_val_uintptr_t (uintptr_t value);
   148| /*
   149| * Atomics.
   150| */
   151| static
   152| uint32_t
   153| ep_rt_atomic_inc_uint32_t (volatile uint32_t *value);
   154| static
   155| uint32_t
   156| ep_rt_atomic_dec_uint32_t (volatile uint32_t *value);
   157| static
   158| int32_t
   159| ep_rt_atomic_inc_int32_t (volatile int32_t *value);
   160| static
   161| int32_t
   162| ep_rt_atomic_dec_int32_t (volatile int32_t *value);
   163| static
   164| int64_t
   165| ep_rt_atomic_inc_int64_t (volatile int64_t *value);
   166| static
   167| int64_t
   168| ep_rt_atomic_dec_int64_t (volatile int64_t *value);
   169| static
   170| size_t
   171| ep_rt_atomic_compare_exchange_size_t (volatile size_t *target, size_t expected, size_t value);
   172| static
   173| ep_char8_t *
   174| eo_rt_atomic_compare_exchange_utf8_string (volatile ep_char8_t **target, ep_char8_t *expected, ep_char8_t *value);
   175| /*
   176|  * EventPipe.
   177|  */
   178| EP_RT_DECLARE_ARRAY (session_id_array, ep_rt_session_id_array_t, ep_rt_session_id_array_iterator_t, EventPipeSessionID)
   179| EP_RT_DECLARE_ARRAY_ITERATOR (session_id_array, ep_rt_session_id_array_t, ep_rt_session_id_array_iterator_t, EventPipeSessionID)
   180| EP_RT_DECLARE_ARRAY (execution_checkpoint_array, ep_rt_execution_checkpoint_array_t, ep_rt_execution_checkpoint_array_iterator_t, EventPipeExecutionCheckpoint *)
   181| EP_RT_DECLARE_ARRAY_ITERATOR (execution_checkpoint_array, ep_rt_execution_checkpoint_array_t, ep_rt_execution_checkpoint_array_iterator_t, EventPipeExecutionCheckpoint *)
   182| static
   183| void
   184| ep_rt_init (void);
   185| static
   186| void
   187| ep_rt_init_finish (void);
   188| static
   189| void
   190| ep_rt_shutdown (void);
   191| static
   192| bool
   193| ep_rt_config_acquire (void);
   194| static
   195| bool
   196| ep_rt_config_release (void);
   197| #ifdef EP_CHECKED_BUILD
   198| static
   199| void
   200| ep_rt_config_requires_lock_held (void);
   201| static
   202| void
   203| ep_rt_config_requires_lock_not_held (void);
   204| #else
   205| #define ep_rt_config_requires_lock_held()
   206| #define ep_rt_config_requires_lock_not_held()
   207| #endif
   208| static
   209| bool
   210| ep_rt_walk_managed_stack_for_thread (
   211| 	ep_rt_thread_handle_t thread,
   212| 	EventPipeStackContents *stack_contents);
   213| static
   214| bool
   215| ep_rt_method_get_simple_assembly_name (
   216| 	ep_rt_method_desc_t *method,
   217| 	ep_char8_t *name, size_t name_len);
   218| static
   219| bool
   220| ep_rt_method_get_full_name (
   221| 	ep_rt_method_desc_t *method,
   222| 	ep_char8_t *name, size_t name_len);
   223| static
   224| void
   225| ep_rt_provider_config_init (EventPipeProviderConfiguration *provider_config);
   226| static
   227| void
   228| ep_rt_init_providers_and_events (void);
   229| static
   230| bool
   231| ep_rt_providers_validate_all_disabled (void);
   232| static
   233| void
   234| ep_rt_prepare_provider_invoke_callback (EventPipeProviderCallbackData *provider_callback_data);
   235| static
   236| void
   237| ep_rt_provider_invoke_callback (
   238| 	EventPipeCallback callback_func,
   239| 	const uint8_t *source_id,
   240| 	unsigned long is_enabled,
   241| 	uint8_t level,
   242| 	uint64_t match_any_keywords,
   243| 	uint64_t match_all_keywords,
   244| 	EventFilterDescriptor *filter_data,
   245| 	void *callback_data);
   246| /*
   247|  * EventPipeBuffer.
   248|  */
   249| EP_RT_DECLARE_ARRAY (buffer_array, ep_rt_buffer_array_t, ep_rt_buffer_array_iterator_t, EventPipeBuffer *)
   250| EP_RT_DECLARE_LOCAL_ARRAY (buffer_array, ep_rt_buffer_array_t, ep_rt_buffer_array_iterator_t, EventPipeBuffer *)
   251| EP_RT_DECLARE_ARRAY_ITERATOR (buffer_array, ep_rt_buffer_array_t, ep_rt_buffer_array_iterator_t, EventPipeBuffer *)
   252| #define EP_RT_DECLARE_LOCAL_BUFFER_ARRAY(var_name) ds_rt_redefine
   253| /*
   254|  * EventPipeBufferList.
   255|  */
   256| EP_RT_DECLARE_ARRAY (buffer_list_array, ep_rt_buffer_list_array_t, ep_rt_buffer_list_array_iterator_t, EventPipeBufferList *)
   257| EP_RT_DECLARE_LOCAL_ARRAY (buffer_list_array, ep_rt_buffer_list_array_t, ep_rt_buffer_list_array_iterator_t, EventPipeBufferList *)
   258| EP_RT_DECLARE_ARRAY_ITERATOR (buffer_list_array, ep_rt_buffer_list_array_t, ep_rt_buffer_list_array_iterator_t, EventPipeBufferList *)
   259| #define EP_RT_DECLARE_LOCAL_BUFFER_LIST_ARRAY(var_name) ds_rt_redefine
   260| /*
   261|  * EventPipeEvent.
   262|  */
   263| EP_RT_DECLARE_LIST (event_list, ep_rt_event_list_t, EventPipeEvent *)
   264| EP_RT_DECLARE_LIST_ITERATOR (event_list, ep_rt_event_list_t, ep_rt_event_list_iterator_t, EventPipeEvent *)
   265| /*
   266|  * EventPipeFile.
   267|  */
   268| EP_RT_DECLARE_HASH_MAP_REMOVE(metadata_labels_hash, ep_rt_metadata_labels_hash_map_t, EventPipeEvent *, uint32_t)
   269| EP_RT_DECLARE_HASH_MAP(stack_hash, ep_rt_stack_hash_map_t, StackHashKey *, StackHashEntry *)
   270| EP_RT_DECLARE_HASH_MAP_ITERATOR(stack_hash, ep_rt_stack_hash_map_t, ep_rt_stack_hash_map_iterator_t, StackHashKey *, StackHashEntry *)
   271| #ifndef EP_RT_USE_CUSTOM_HASH_MAP_CALLBACKS
   272| #define ep_rt_stack_hash_key_hash ep_stack_hash_key_hash
   273| #define ep_rt_stack_hash_key_equal ep_stack_hash_key_equal
   274| #endif
   275| /*
   276|  * EventPipeProvider.
   277|  */
   278| EP_RT_DECLARE_LIST (provider_list, ep_rt_provider_list_t, EventPipeProvider *)
   279| EP_RT_DECLARE_LIST_ITERATOR (provider_list, ep_rt_provider_list_t, ep_rt_provider_list_iterator_t, EventPipeProvider *)
   280| EP_RT_DECLARE_QUEUE (provider_callback_data_queue, ep_rt_provider_callback_data_queue_t, EventPipeProviderCallbackData *)
   281| static
   282| EventPipeProvider *
   283| ep_rt_provider_list_find_by_name (
   284| 	const ep_rt_provider_list_t *list,
   285| 	const ep_char8_t *name);
   286| /*
   287|  * EventPipeProviderConfiguration.
   288|  */
   289| EP_RT_DECLARE_ARRAY (provider_config_array, ep_rt_provider_config_array_t, ep_rt_provider_config_array_iterator_t, EventPipeProviderConfiguration)
   290| EP_RT_DECLARE_ARRAY_ITERATOR (provider_config_array, ep_rt_provider_config_array_t, ep_rt_provider_config_array_iterator_t, EventPipeProviderConfiguration)
   291| static
   292| bool
   293| ep_rt_config_value_get_enable (void);
   294| static
   295| ep_char8_t *
   296| ep_rt_config_value_get_config (void);
   297| static
   298| ep_char8_t *
   299| ep_rt_config_value_get_output_path (void);
   300| static
   301| uint32_t
   302| ep_rt_config_value_get_circular_mb (void);
   303| static
   304| inline
   305| bool
   306| ep_rt_config_value_get_output_streaming (void);
   307| static
   308| bool
   309| ep_rt_config_value_get_use_portable_thread_pool (void);
   310| static
   311| inline
   312| bool
   313| ep_rt_config_value_get_enable_stackwalk (void);
   314| /*
   315|  * EventPipeSampleProfiler.
   316|  */
   317| static
   318| void
   319| ep_rt_sample_profiler_write_sampling_event_for_threads (ep_rt_thread_handle_t sampling_thread, EventPipeEvent *sampling_event);
   320| static
   321| void
   322| ep_rt_notify_profiler_provider_created (EventPipeProvider *provider);
   323| /*
   324|  * EventPipeSessionProvider.
   325|  */
   326| EP_RT_DECLARE_LIST (session_provider_list, ep_rt_session_provider_list_t, EventPipeSessionProvider *)
   327| EP_RT_DECLARE_LIST_ITERATOR (session_provider_list, ep_rt_session_provider_list_t, ep_rt_session_provider_list_iterator_t, EventPipeSessionProvider *)
   328| static
   329| EventPipeSessionProvider *
   330| ep_rt_session_provider_list_find_by_name (
   331| 	const ep_rt_session_provider_list_t *list,
   332| 	const ep_char8_t *name);
   333| /*
   334|  * EventPipeSequencePoint.
   335|  */
   336| EP_RT_DECLARE_LIST (sequence_point_list, ep_rt_sequence_point_list_t, EventPipeSequencePoint *)
   337| EP_RT_DECLARE_LIST_ITERATOR (sequence_point_list, ep_rt_sequence_point_list_t, ep_rt_sequence_point_list_iterator_t, EventPipeSequencePoint *)
   338| /*
   339|  * EventPipeThread.
   340|  */
   341| EP_RT_DECLARE_LIST (thread_list, ep_rt_thread_list_t, EventPipeThread *)
   342| EP_RT_DECLARE_LIST_ITERATOR (thread_list, ep_rt_thread_list_t, ep_rt_thread_list_iterator_t, EventPipeThread *)
   343| EP_RT_DECLARE_ARRAY (thread_array, ep_rt_thread_array_t, ep_rt_thread_array_iterator_t, EventPipeThread *)
   344| EP_RT_DECLARE_LOCAL_ARRAY (thread_array, ep_rt_thread_array_t, ep_rt_thread_array_iterator_t, EventPipeThread *)
   345| EP_RT_DECLARE_ARRAY_ITERATOR (thread_array, ep_rt_thread_array_t, ep_rt_thread_array_iterator_t, EventPipeThread *)
   346| #define EP_RT_DECLARE_LOCAL_THREAD_ARRAY(var_name) ds_rt_redefine
   347| /*
   348|  * EventPipeThreadSessionState.
   349|  */
   350| EP_RT_DECLARE_LIST (thread_session_state_list, ep_rt_thread_session_state_list_t, EventPipeThreadSessionState *)
   351| EP_RT_DECLARE_LIST_ITERATOR (thread_session_state_list, ep_rt_thread_session_state_list_t, ep_rt_thread_session_state_list_iterator_t, EventPipeThreadSessionState *)
   352| EP_RT_DECLARE_ARRAY (thread_session_state_array, ep_rt_thread_session_state_array_t, ep_rt_thread_session_state_array_iterator_t, EventPipeThreadSessionState *)
   353| EP_RT_DECLARE_LOCAL_ARRAY (thread_session_state_array, ep_rt_thread_session_state_array_t, ep_rt_thread_session_state_array_iterator_t, EventPipeThreadSessionState *)
   354| EP_RT_DECLARE_ARRAY_ITERATOR (thread_session_state_array, ep_rt_thread_session_state_array_t, ep_rt_thread_session_state_array_iterator_t, EventPipeThreadSessionState *)
   355| #define EP_RT_DECLARE_LOCAL_THREAD_SESSION_STATE_ARRAY(var_name) ds_rt_redefine
   356| /*
   357|  * Arrays.
   358|  */
   359| static
   360| uint8_t *
   361| ep_rt_byte_array_alloc (size_t len);
   362| static
   363| void
   364| ep_rt_byte_array_free (uint8_t *ptr);
   365| /*
   366|  * Event.
   367|  */
   368| static
   369| void
   370| ep_rt_wait_event_alloc (
   371| 	ep_rt_wait_event_handle_t *wait_event,
   372| 	bool manual,
   373| 	bool initial);
   374| static
   375| void
   376| ep_rt_wait_event_free (ep_rt_wait_event_handle_t *wait_event);
   377| static
   378| bool
   379| ep_rt_wait_event_set (ep_rt_wait_event_handle_t *wait_event);
   380| static
   381| int32_t
   382| ep_rt_wait_event_wait (
   383| 	ep_rt_wait_event_handle_t *wait_event,
   384| 	uint32_t timeout,
   385| 	bool alertable);
   386| static
   387| EventPipeWaitHandle
   388| ep_rt_wait_event_get_wait_handle (ep_rt_wait_event_handle_t *wait_event);
   389| static
   390| bool
   391| ep_rt_wait_event_is_valid (ep_rt_wait_event_handle_t *wait_event);
   392| /*
   393|  * Misc.
   394|  */
   395| static
   396| int
   397| ep_rt_get_last_error (void);
   398| static
   399| bool
   400| ep_rt_process_detach (void);
   401| static
   402| bool
   403| ep_rt_process_shutdown (void);
   404| static
   405| void
   406| ep_rt_create_activity_id (
   407| 	uint8_t *activity_id,
   408| 	uint32_t activity_id_len);
   409| static
   410| bool
   411| ep_rt_is_running (void);
   412| static
   413| void
   414| ep_rt_execute_rundown (ep_rt_execution_checkpoint_array_t *execution_checkpoints);
   415| /*
   416|  * Objects.
   417|  */
   418| #define ep_rt_object_alloc(obj_type) ep_rt_redefine
   419| #define ep_rt_object_array_alloc(obj_type,size) ep_rt_redefine
   420| static
   421| void
   422| ep_rt_object_array_free (void *ptr);
   423| static
   424| void
   425| ep_rt_object_free (void *ptr);
   426| /*
   427|  * PAL.
   428|  */
   429| #define EP_RT_DEFINE_THREAD_FUNC ep_rt_redefine
   430| static
   431| bool
   432| ep_rt_thread_create (
   433| 	void *thread_func,
   434| 	void *params,
   435| 	EventPipeThreadType thread_type,
   436| 	void *id);
   437| static
   438| void
   439| ep_rt_thread_sleep (uint64_t ns);
   440| static
   441| uint32_t
   442| ep_rt_current_process_get_id (void);
   443| static
   444| uint32_t
   445| ep_rt_current_processor_get_number (void);
   446| static
   447| uint32_t
   448| ep_rt_processors_get_count (void);
   449| static
   450| ep_rt_thread_id_t
   451| ep_rt_current_thread_get_id (void);
   452| static
   453| int64_t
   454| ep_rt_perf_counter_query (void);
   455| static
   456| int64_t
   457| ep_rt_perf_frequency_query (void);
   458| static
   459| void
   460| ep_rt_system_time_get (EventPipeSystemTime *system_time);
   461| static
   462| int64_t
   463| ep_rt_system_timestamp_get (void);
   464| static
   465| int32_t
   466| ep_rt_system_get_alloc_granularity (void);
   467| static
   468| const ep_char8_t *
   469| ep_rt_os_command_line_get (void);
   470| static
   471| ep_rt_file_handle_t
   472| ep_rt_file_open_write (const ep_char8_t *path);
   473| static
   474| bool
   475| ep_rt_file_close (ep_rt_file_handle_t file_handle);
   476| static
   477| bool
   478| ep_rt_file_write (
   479| 	ep_rt_file_handle_t file_handle,
   480| 	const uint8_t *buffer,
   481| 	uint32_t bytes_to_write,
   482| 	uint32_t *bytes_written);
   483| static
   484| uint8_t *
   485| ep_rt_valloc0 (size_t buffer_size);
   486| static
   487| void
   488| ep_rt_vfree (
   489| 	uint8_t *buffer,
   490| 	size_t buffer_size);
   491| static
   492| uint32_t
   493| ep_rt_temp_path_get (
   494| 	ep_char8_t *buffer,
   495| 	uint32_t buffer_len);
   496| EP_RT_DECLARE_ARRAY (env_array_utf16_, ep_rt_env_array_utf16_t, ep_rt_env_array_utf16_iterator_t, ep_char16_t *)
   497| EP_RT_DECLARE_ARRAY_ITERATOR (env_array_utf16, ep_rt_env_array_utf16_t, ep_rt_env_array_utf16_iterator_t, ep_char16_t *)
   498| static
   499| void
   500| ep_rt_os_environment_get_utf16 (ep_rt_env_array_utf16_t *env_array);
   501| static
   502| const ep_char8_t *
   503| ep_rt_entrypoint_assembly_name_get_utf8 (void);
   504| static
   505| const ep_char8_t *
   506| ep_rt_runtime_version_get_utf8 (void);
   507| /*
   508| * Lock
   509| */
   510| static
   511| bool
   512| ep_rt_lock_acquire (ep_rt_lock_handle_t *lock);
   513| static
   514| bool
   515| ep_rt_lock_release (ep_rt_lock_handle_t *lock);
   516| #ifdef EP_CHECKED_BUILD
   517| static
   518| void
   519| ep_rt_lock_requires_lock_held (const ep_rt_lock_handle_t *lock);
   520| static
   521| void
   522| ep_rt_lock_requires_lock_not_held (const ep_rt_lock_handle_t *lock);
   523| #else
   524| #define ep_rt_lock_requires_lock_held(lock)
   525| #define ep_rt_lock_requires_lock_not_held(lock)
   526| #endif
   527| /*
   528| * SpinLock.
   529| */
   530| static
   531| void
   532| ep_rt_spin_lock_alloc (ep_rt_spin_lock_handle_t *spin_lock);
   533| static
   534| void
   535| ep_rt_spin_lock_free (ep_rt_spin_lock_handle_t *spin_lock);
   536| static
   537| bool
   538| ep_rt_spin_lock_acquire (ep_rt_spin_lock_handle_t *spin_lock);
   539| static
   540| bool
   541| ep_rt_spin_lock_release (ep_rt_spin_lock_handle_t *spin_lock);
   542| #ifdef EP_CHECKED_BUILD
   543| static
   544| void
   545| ep_rt_spin_lock_requires_lock_held (const ep_rt_spin_lock_handle_t *spin_lock);
   546| static
   547| void
   548| ep_rt_spin_lock_requires_lock_not_held (const ep_rt_spin_lock_handle_t *spin_lock);
   549| #else
   550| #define ep_rt_spin_lock_requires_lock_held(spin_lock)
   551| #define ep_rt_spin_lock_requires_lock_not_held(spin_lock)
   552| #endif
   553| static
   554| bool
   555| ep_rt_spin_lock_is_valid (const ep_rt_spin_lock_handle_t *spin_lock);
   556| /*
   557|  * String.
   558|  */
   559| static
   560| int
   561| ep_rt_utf8_string_compare (
   562| 	const ep_char8_t *str1,
   563| 	const ep_char8_t *str2);
   564| static
   565| int
   566| ep_rt_utf8_string_compare_ignore_case (
   567| 	const ep_char8_t *str1,
   568| 	const ep_char8_t *str2);
   569| static
   570| bool
   571| ep_rt_utf8_string_is_null_or_empty (const ep_char8_t *str);
   572| static
   573| ep_char8_t *
   574| ep_rt_utf8_string_dup (const ep_char8_t *str);
   575| static
   576| ep_char8_t *
   577| ep_rt_utf8_string_dup_range (const ep_char8_t *str, const ep_char8_t *strEnd);
   578| static
   579| ep_char8_t *
   580| ep_rt_utf8_string_strtok (
   581| 	ep_char8_t *str,
   582| 	const ep_char8_t *delimiter,
   583| 	ep_char8_t **context);
   584| #define ep_rt_utf8_string_snprintf( \
   585| 	str, \
   586| 	str_len, \
   587| 	format, ...) ep_redefine
   588| static
   589| inline bool
   590| ep_rt_utf8_string_replace (
   591| 	ep_char8_t **str,
   592| 	const ep_char8_t *strSearch,
   593| 	const ep_char8_t *strReplacement
   594| );
   595| static
   596| ep_char16_t *
   597| ep_rt_utf8_to_utf16le_string (
   598| 	const ep_char8_t *str,
   599| 	size_t len);
   600| static
   601| ep_char16_t *
   602| ep_rt_utf16_string_dup (const ep_char16_t *str);
   603| static
   604| void
   605| ep_rt_utf8_string_free (ep_char8_t *str);
   606| static
   607| size_t
   608| ep_rt_utf16_string_len (const ep_char16_t *str);
   609| static
   610| ep_char8_t *
   611| ep_rt_utf16_to_utf8_string (
   612| 	const ep_char16_t *str,
   613| 	size_t len);
   614| static
   615| ep_char8_t *
   616| ep_rt_utf16le_to_utf8_string (
   617| 	const ep_char16_t *str,
   618| 	size_t len);
   619| static
   620| void
   621| ep_rt_utf16_string_free (ep_char16_t *str);
   622| static
   623| const ep_char8_t *
   624| ep_rt_managed_command_line_get (void);
   625| static
   626| const ep_char8_t *
   627| ep_rt_diagnostics_command_line_get (void);
   628| /*
   629|  * Thread.
   630|  */
   631| static
   632| void
   633| ep_rt_thread_setup (void);
   634| static
   635| EventPipeThread *
   636| ep_rt_thread_get (void);
   637| static
   638| EventPipeThread *
   639| ep_rt_thread_get_or_create (void);
   640| static
   641| ep_rt_thread_handle_t
   642| ep_rt_thread_get_handle (void);
   643| static
   644| ep_rt_thread_id_t
   645| ep_rt_thread_get_id (ep_rt_thread_handle_t thread_handle);
   646| static
   647| uint64_t
   648| ep_rt_thread_id_t_to_uint64_t (ep_rt_thread_id_t thread_id);
   649| static
   650| ep_rt_thread_id_t
   651| ep_rt_uint64_t_to_thread_id_t (uint64_t thread_id);
   652| static
   653| bool
   654| ep_rt_thread_has_started (ep_rt_thread_handle_t thread_handle);
   655| static
   656| ep_rt_thread_activity_id_handle_t
   657| ep_rt_thread_get_activity_id_handle (void);
   658| static
   659| const uint8_t *
   660| ep_rt_thread_get_activity_id_cref (ep_rt_thread_activity_id_handle_t activity_id_handle);
   661| static
   662| void
   663| ep_rt_thread_get_activity_id (
   664| 	ep_rt_thread_activity_id_handle_t activity_id_handle,
   665| 	uint8_t *activity_id,
   666| 	uint32_t activity_id_len);
   667| static
   668| void
   669| ep_rt_thread_set_activity_id (
   670| 	ep_rt_thread_activity_id_handle_t activity_id_handle,
   671| 	const uint8_t *activity_id,
   672| 	uint32_t activity_id_len);
   673| /*
   674|  * ThreadSequenceNumberMap.
   675|  */
   676| EP_RT_DECLARE_HASH_MAP_REMOVE(thread_sequence_number_map, ep_rt_thread_sequence_number_hash_map_t, EventPipeThreadSessionState *, uint32_t)
   677| EP_RT_DECLARE_HASH_MAP_ITERATOR(thread_sequence_number_map, ep_rt_thread_sequence_number_hash_map_t, ep_rt_thread_sequence_number_hash_map_iterator_t, EventPipeThreadSessionState *, uint32_t)
   678| /*
   679|  * Volatile.
   680|  */
   681| static
   682| uint32_t
   683| ep_rt_volatile_load_uint32_t (const volatile uint32_t *ptr);
   684| static
   685| uint32_t
   686| ep_rt_volatile_load_uint32_t_without_barrier (const volatile uint32_t *ptr);
   687| static
   688| void
   689| ep_rt_volatile_store_uint32_t (
   690| 	volatile uint32_t *ptr,
   691| 	uint32_t value);
   692| static
   693| void
   694| ep_rt_volatile_store_uint32_t_without_barrier (
   695| 	volatile uint32_t *ptr,
   696| 	uint32_t value);
   697| static
   698| uint64_t
   699| ep_rt_volatile_load_uint64_t (const volatile uint64_t *ptr);
   700| static
   701| uint64_t
   702| ep_rt_volatile_load_uint64_t_without_barrier (const volatile uint64_t *ptr);
   703| static
   704| void
   705| ep_rt_volatile_store_uint64_t (
   706| 	volatile uint64_t *ptr,
   707| 	uint64_t value);
   708| static
   709| void
   710| ep_rt_volatile_store_uint64_t_without_barrier (
   711| 	volatile uint64_t *ptr,
   712| 	uint64_t value);
   713| static
   714| int64_t
   715| ep_rt_volatile_load_int64_t (const volatile int64_t *ptr);
   716| static
   717| int64_t
   718| ep_rt_volatile_load_int64_t_without_barrier (const volatile int64_t *ptr);
   719| static
   720| void
   721| ep_rt_volatile_store_int64_t (
   722| 	volatile int64_t *ptr,
   723| 	int64_t value);
   724| static
   725| void
   726| ep_rt_volatile_store_int64_t_without_barrier (
   727| 	volatile int64_t *ptr,
   728| 	int64_t value);
   729| static
   730| void *
   731| ep_rt_volatile_load_ptr (volatile void **ptr);
   732| static
   733| void *
   734| ep_rt_volatile_load_ptr_without_barrier (volatile void **ptr);
   735| static
   736| void
   737| ep_rt_volatile_store_ptr (
   738| 	volatile void **ptr,
   739| 	void *value);
   740| static
   741| void
   742| ep_rt_volatile_store_ptr_without_barrier (
   743| 	volatile void **ptr,
   744| 	void *value);
   745| /*
   746|  * Enter/Exit spin lock helper used with error handling macros.
   747|  */
   748| #define EP_SPIN_LOCK_ENTER(expr, section_name) \
   749| { \
   750| 	ep_rt_spin_lock_requires_lock_not_held (expr); \
   751| 	ep_rt_spin_lock_acquire (expr); \
   752| 	bool _no_error_ ##section_name = false;
   753| #define EP_SPIN_LOCK_EXIT(expr, section_name) \
   754| 	_no_error_ ##section_name = true; \
   755| 	goto _ep_on_spinlock_exit_ ##section_name; \
   756| _ep_on_spinlock_exit_ ##section_name : \
   757| 	ep_rt_spin_lock_requires_lock_held (expr); \
   758| 	ep_rt_spin_lock_release (expr); \
   759| 	if (EP_UNLIKELY((!_no_error_ ##section_name))) \
   760| 		goto ep_on_error; \
   761| 	ep_rt_spin_lock_requires_lock_not_held (expr); \
   762| }
   763| #define ep_raise_error_if_nok_holding_spin_lock(expr, section_name) do { if (EP_UNLIKELY(!(expr))) { _no_error_ ##section_name = false; goto _ep_on_spinlock_exit_ ##section_name; } } while (0)
   764| #define ep_raise_error_holding_spin_lock(section_name) do { _no_error_ ##section_name = false; goto _ep_on_spinlock_exit_ ##section_name; } while (0)
   765| /*
   766|  * Enter/Exit config lock helper used with error handling macros.
   767|  */
   768| #define EP_LOCK_ENTER(section_name) \
   769| { \
   770| 	ep_requires_lock_not_held (); \
   771| 	bool _owns_config_lock_ ##section_name = ep_rt_config_acquire (); \
   772| 	bool _no_config_error_ ##section_name = false; \
   773| 	if (EP_UNLIKELY((!_owns_config_lock_ ##section_name))) \
   774| 		goto _ep_on_config_lock_exit_ ##section_name;
   775| #define EP_LOCK_EXIT(section_name) \
   776| 	_no_config_error_ ##section_name = true; \
   777| _ep_on_config_lock_exit_ ##section_name: \
   778| 	if (EP_UNLIKELY((!_owns_config_lock_ ##section_name))) \
   779| 		goto ep_on_error; \
   780| 	ep_requires_lock_held (); \
   781| 	ep_rt_config_release (); \
   782| 	if (EP_UNLIKELY((!_no_config_error_ ##section_name))) \
   783| 		goto ep_on_error; \
   784| 	ep_requires_lock_not_held (); \
   785| }
   786| #define ep_raise_error_if_nok_holding_lock(expr, section_name) do { if (EP_UNLIKELY(!(expr))) { _no_config_error_ ##section_name = false; goto _ep_on_config_lock_exit_ ##section_name; } } while (0)
   787| #define ep_raise_error_holding_lock(section_name) do { _no_config_error_ ##section_name = false; goto _ep_on_config_lock_exit_ ##section_name; } while (0)
   788| #ifndef EP_NO_RT_DEPENDENCY
   789| #include EP_RT_H
   790| #endif
   791| #endif /* ENABLE_PERFTRACING */
   792| #endif /* __EVENTPIPE_RT_H__ */


# ====================================================================
# FILE: src/native/eventpipe/ep-session.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-466 ---
     1| #include "ep-rt-config.h"
     2| #ifdef ENABLE_PERFTRACING
     3| #if !defined(EP_INCLUDE_SOURCE_FILES) || defined(EP_FORCE_INCLUDE_SOURCE_FILES)
     4| #define EP_IMPL_SESSION_GETTER_SETTER
     5| #include "ep.h"
     6| #include "ep-buffer-manager.h"
     7| #include "ep-config.h"
     8| #include "ep-event.h"
     9| #include "ep-file.h"
    10| #include "ep-session.h"
    11| #include "ep-event-payload.h"
    12| #include "ep-rt.h"
    13| /*
    14|  * Forward declares of all static functions.
    15|  */
    16| static
    17| void
    18| session_disable_streaming_thread (EventPipeSession *session);
    19| static
    20| void
    21| session_create_streaming_thread (EventPipeSession *session);
    22| static
    23| void
    24| ep_session_remove_dangling_session_states (EventPipeSession *session);
    25| /*
    26|  * EventPipeSession.
    27|  */
    28| EP_RT_DEFINE_THREAD_FUNC (streaming_thread)
    29| {
    30| 	EP_ASSERT (data != NULL);
    31| 	if (data == NULL)
    32| 		return 1;
    33| 	ep_rt_thread_params_t *thread_params = (ep_rt_thread_params_t *)data;
    34| 	EventPipeSession *const session = (EventPipeSession *)thread_params->thread_params;
    35| 	if (session->session_type != EP_SESSION_TYPE_IPCSTREAM && session->session_type != EP_SESSION_TYPE_FILESTREAM)
    36| 		return 1;
    37| 	if (!thread_params->thread || !ep_rt_thread_has_started (thread_params->thread))
    38| 		return 1;
    39| 	session->streaming_thread = thread_params->thread;
    40| 	bool success = true;
    41| 	ep_rt_wait_event_handle_t *wait_event = ep_session_get_wait_event (session);
    42| 	EP_GCX_PREEMP_ENTER
    43| 		while (ep_session_get_streaming_enabled (session)) {
    44| 			bool events_written = false;
    45| 			if (!ep_session_write_all_buffers_to_file (session, &events_written)) {
    46| 				success = false;
    47| 				break;
    48| 			}
    49| 			if (!events_written) {
    50| 				ep_rt_wait_event_wait (wait_event, EP_INFINITE_WAIT, false);
    51| 			}
    52| 			const uint32_t timeout_ns = 100000000; // 100 msec.
    53| 			ep_rt_thread_sleep (timeout_ns);
    54| 		}
    55| 		session->streaming_thread = NULL;
    56| 		ep_rt_wait_event_set (&session->rt_thread_shutdown_event);
    57| 	EP_GCX_PREEMP_EXIT
    58| 	if (!success)
    59| 		ep_disable ((EventPipeSessionID)session);
    60| 	return (ep_rt_thread_start_func_return_t)0;
    61| }
    62| static
    63| void
    64| session_create_streaming_thread (EventPipeSession *session)
    65| {
    66| 	EP_ASSERT (session != NULL);
    67| 	EP_ASSERT (session->session_type == EP_SESSION_TYPE_IPCSTREAM || session->session_type == EP_SESSION_TYPE_FILESTREAM);
    68| 	ep_requires_lock_held ();
    69| 	ep_session_set_streaming_enabled (session, true);
    70| 	ep_rt_wait_event_alloc (&session->rt_thread_shutdown_event, true, false);
    71| 	if (!ep_rt_wait_event_is_valid (&session->rt_thread_shutdown_event))
    72| 		EP_UNREACHABLE ("Unable to create stream flushing thread shutdown event.");
    73| 	ep_rt_thread_id_t thread_id = ep_rt_uint64_t_to_thread_id_t (0);
    74| 	if (!ep_rt_thread_create ((void *)streaming_thread, (void *)session, EP_THREAD_TYPE_SESSION, &thread_id))
    75| 		EP_UNREACHABLE ("Unable to create stream flushing thread.");
    76| }
    77| static
    78| void
    79| session_disable_streaming_thread (EventPipeSession *session)
    80| {
    81| 	EP_ASSERT (session->session_type == EP_SESSION_TYPE_IPCSTREAM || session->session_type == EP_SESSION_TYPE_FILESTREAM);
    82| 	EP_ASSERT (ep_session_get_streaming_enabled (session));
    83| 	EP_ASSERT (!ep_rt_process_detach ());
    84| 	EP_ASSERT (session->buffer_manager != NULL);
    85| 	ep_session_set_streaming_enabled (session, false);
    86| 	ep_rt_wait_event_set (ep_buffer_manager_get_rt_wait_event_ref (session->buffer_manager));
    87| 	ep_rt_wait_event_handle_t *rt_thread_shutdown_event = &session->rt_thread_shutdown_event;
    88| 	ep_rt_wait_event_wait (rt_thread_shutdown_event, EP_INFINITE_WAIT, false /* bAlertable */);
    89| 	ep_rt_wait_event_free (rt_thread_shutdown_event);
    90| }
    91| EventPipeSession *
    92| ep_session_alloc (
    93| 	uint32_t index,
    94| 	const ep_char8_t *output_path,
    95| 	IpcStream *stream,
    96| 	EventPipeSessionType session_type,
    97| 	EventPipeSerializationFormat format,
    98| 	bool rundown_requested,
    99| 	uint32_t circular_buffer_size_in_mb,
   100| 	const EventPipeProviderConfiguration *providers,
   101| 	uint32_t providers_len,
   102| 	EventPipeSessionSynchronousCallback sync_callback,
   103| 	void *callback_additional_data)
   104| {
   105| 	EP_ASSERT (index < EP_MAX_NUMBER_OF_SESSIONS);
   106| 	EP_ASSERT (format < EP_SERIALIZATION_FORMAT_COUNT);
   107| 	EP_ASSERT (session_type == EP_SESSION_TYPE_SYNCHRONOUS || circular_buffer_size_in_mb > 0);
   108| 	EP_ASSERT (providers_len > 0);
   109| 	EP_ASSERT (providers != NULL);
   110| 	EP_ASSERT ((sync_callback != NULL) == (session_type == EP_SESSION_TYPE_SYNCHRONOUS));
   111| 	ep_requires_lock_held ();
   112| 	FileStreamWriter *file_stream_writer = NULL;
   113| 	IpcStreamWriter *ipc_stream_writer = NULL;
   114| 	size_t sequence_point_alloc_budget = 0;
   115| 	EventPipeSession *instance = ep_rt_object_alloc (EventPipeSession);
   116| 	ep_raise_error_if_nok (instance != NULL);
   117| 	instance->providers = ep_session_provider_list_alloc (providers, providers_len);
   118| 	ep_raise_error_if_nok (instance->providers != NULL);
   119| 	instance->index = index;
   120| 	instance->rundown_enabled = 0;
   121| 	instance->session_type = session_type;
   122| 	instance->format = format;
   123| 	instance->rundown_requested = rundown_requested;
   124| 	instance->synchronous_callback = sync_callback;
   125| 	instance->callback_additional_data = callback_additional_data;
   126| 	if (instance->session_type != EP_SESSION_TYPE_LISTENER && instance->format >= EP_SERIALIZATION_FORMAT_NETTRACE_V4) {
   127| 		sequence_point_alloc_budget = 10 * 1024 * 1024;
   128| 	}
   129| 	if (session_type != EP_SESSION_TYPE_SYNCHRONOUS) {
   130| 		instance->buffer_manager = ep_buffer_manager_alloc (instance, ((size_t)circular_buffer_size_in_mb) << 20, sequence_point_alloc_budget);
   131| 		ep_raise_error_if_nok (instance->buffer_manager != NULL);
   132| 	}
   133| 	switch (session_type) {
   134| 	case EP_SESSION_TYPE_FILE :
   135| 	case EP_SESSION_TYPE_FILESTREAM :
   136| 		if (output_path) {
   137| 			file_stream_writer = ep_file_stream_writer_alloc (output_path);
   138| 			ep_raise_error_if_nok (file_stream_writer != NULL);
   139| 			instance->file = ep_file_alloc (ep_file_stream_writer_get_stream_writer_ref (file_stream_writer), format);
   140| 			ep_raise_error_if_nok (instance->file != NULL);
   141| 			file_stream_writer = NULL;
   142| 		}
   143| 		break;
   144| 	case EP_SESSION_TYPE_IPCSTREAM:
   145| 		ipc_stream_writer = ep_ipc_stream_writer_alloc ((uint64_t)instance, stream);
   146| 		ep_raise_error_if_nok (ipc_stream_writer != NULL);
   147| 		instance->file = ep_file_alloc (ep_ipc_stream_writer_get_stream_writer_ref (ipc_stream_writer), format);
   148| 		ep_raise_error_if_nok (instance->file != NULL);
   149| 		ipc_stream_writer = NULL;
   150| 		break;
   151| 	default:
   152| 		break;
   153| 	}
   154| 	instance->session_start_time = ep_system_timestamp_get ();
   155| 	instance->session_start_timestamp = ep_perf_timestamp_get ();
   156| 	instance->paused = false;
   157| 	instance->enable_stackwalk = ep_rt_config_value_get_enable_stackwalk ();
   158| ep_on_exit:
   159| 	ep_requires_lock_held ();
   160| 	return instance;
   161| ep_on_error:
   162| 	ep_file_stream_writer_free (file_stream_writer);
   163| 	ep_ipc_stream_writer_free (ipc_stream_writer);
   164| 	ep_session_free (instance);
   165| 	instance = NULL;
   166| 	ep_exit_error_handler ();
   167| }
   168| void
   169| ep_session_remove_dangling_session_states (EventPipeSession *session)
   170| {
   171| 	ep_return_void_if_nok (session != NULL);
   172| 	EP_RT_DECLARE_LOCAL_THREAD_ARRAY (threads);
   173| 	ep_rt_thread_array_init (&threads);
   174| 	ep_thread_get_threads (&threads);
   175| 	ep_rt_thread_array_iterator_t threads_iterator = ep_rt_thread_array_iterator_begin (&threads);
   176| 	while (!ep_rt_thread_array_iterator_end (&threads, &threads_iterator)) {
   177| 		EventPipeThread *thread = ep_rt_thread_array_iterator_value (&threads_iterator);
   178| 		EP_ASSERT(thread != NULL);
   179| 		EP_SPIN_LOCK_ENTER (ep_thread_get_rt_lock_ref (thread), section1);
   180| 			EventPipeThreadSessionState *session_state = ep_thread_get_session_state(thread, session);
   181| 			if (session_state) {
   182| 				ep_thread_delete_session_state(thread, session);
   183| 			}
   184| 		EP_SPIN_LOCK_EXIT (ep_thread_get_rt_lock_ref (thread), section1);
   185| 		ep_thread_release (thread);
   186| 		ep_rt_thread_array_iterator_next (&threads_iterator);
   187| 	}
   188| 	ep_rt_thread_array_fini (&threads);
   189| ep_on_exit:
   190| 	return;
   191| ep_on_error:
   192| 	ep_exit_error_handler ();
   193| }
   194| void
   195| ep_session_free (EventPipeSession *session)
   196| {
   197| 	ep_return_void_if_nok (session != NULL);
   198| 	EP_ASSERT (!ep_session_get_streaming_enabled (session));
   199| 	ep_rt_wait_event_free (&session->rt_thread_shutdown_event);
   200| 	ep_session_provider_list_free (session->providers);
   201| 	ep_buffer_manager_free (session->buffer_manager);
   202| 	ep_file_free (session->file);
   203| 	ep_session_remove_dangling_session_states (session);
   204| 	ep_rt_object_free (session);
   205| }
   206| EventPipeSessionProvider *
   207| ep_session_get_session_provider (
   208| 	const EventPipeSession *session,
   209| 	const EventPipeProvider *provider)
   210| {
   211| 	EP_ASSERT (session != NULL);
   212| 	EP_ASSERT (provider != NULL);
   213| 	ep_requires_lock_held ();
   214| 	EventPipeSessionProviderList *providers = session->providers;
   215| 	ep_return_null_if_nok (providers != NULL);
   216| 	EventPipeSessionProvider *catch_all = ep_session_provider_list_get_catch_all_provider (providers);
   217| 	if (catch_all)
   218| 		return catch_all;
   219| 	EventPipeSessionProvider *session_provider = ep_rt_session_provider_list_find_by_name (ep_session_provider_list_get_providers_ref (providers), ep_provider_get_provider_name (provider));
   220| 	ep_requires_lock_held ();
   221| 	return session_provider;
   222| }
   223| bool
   224| ep_session_enable_rundown (EventPipeSession *session)
   225| {
   226| 	EP_ASSERT (session != NULL);
   227| 	ep_requires_lock_held ();
   228| 	bool result = false;
   229| 	const uint64_t keywords = 0x80020138;
   230| 	const EventPipeEventLevel verbose_logging_level = EP_EVENT_LEVEL_VERBOSE;
   231| 	EventPipeProviderConfiguration rundown_providers [2];
   232| 	uint32_t rundown_providers_len = (uint32_t)ARRAY_SIZE (rundown_providers);
   233| 	ep_provider_config_init (&rundown_providers [0], ep_config_get_public_provider_name_utf8 (), keywords, verbose_logging_level, NULL); // Public provider.
   234| 	ep_provider_config_init (&rundown_providers [1], ep_config_get_rundown_provider_name_utf8 (), keywords, verbose_logging_level, NULL); // Rundown provider.
   235| 	for (uint32_t i = 0; i < rundown_providers_len; ++i) {
   236| 		const EventPipeProviderConfiguration *config = &rundown_providers [i];
   237| 		EventPipeSessionProvider *session_provider = ep_session_provider_alloc (
   238| 			ep_provider_config_get_provider_name (config),
   239| 			ep_provider_config_get_keywords (config),
   240| 			ep_provider_config_get_logging_level (config),
   241| 			ep_provider_config_get_filter_data (config));
   242| 		ep_raise_error_if_nok (ep_session_add_session_provider (session, session_provider));
   243| 	}
   244| 	ep_session_set_rundown_enabled (session, true);
   245| 	result = true;
   246| ep_on_exit:
   247| 	ep_requires_lock_held ();
   248| 	return result;
   249| ep_on_error:
   250| 	EP_ASSERT (!result);
   251| 	ep_exit_error_handler ();
   252| }
   253| void
   254| ep_session_execute_rundown (
   255| 	EventPipeSession *session,
   256| 	ep_rt_execution_checkpoint_array_t *execution_checkpoints)
   257| {
   258| 	EP_ASSERT (session != NULL);
   259| 	ep_requires_lock_held ();
   260| 	ep_return_void_if_nok (session->file != NULL);
   261| 	ep_rt_execute_rundown (execution_checkpoints);
   262| }
   263| void
   264| ep_session_suspend_write_event (EventPipeSession *session)
   265| {
   266| 	EP_ASSERT (session != NULL);
   267| 	EP_ASSERT (!ep_is_session_enabled ((EventPipeSessionID)session));
   268| 	EP_RT_DECLARE_LOCAL_THREAD_ARRAY (threads);
   269| 	ep_rt_thread_array_init (&threads);
   270| 	ep_thread_get_threads (&threads);
   271| 	ep_rt_thread_array_iterator_t threads_iterator = ep_rt_thread_array_iterator_begin (&threads);
   272| 	while (!ep_rt_thread_array_iterator_end (&threads, &threads_iterator)) {
   273| 		EventPipeThread *thread = ep_rt_thread_array_iterator_value (&threads_iterator);
   274| 		if (thread) {
   275| 			EP_YIELD_WHILE (ep_thread_get_session_write_in_progress (thread) == session->index);
   276| 			ep_thread_release (thread);
   277| 		}
   278| 		ep_rt_thread_array_iterator_next (&threads_iterator);
   279| 	}
   280| 	ep_rt_thread_array_fini (&threads);
   281| 	if (session->buffer_manager)
   282| 		ep_buffer_manager_suspend_write_event (session->buffer_manager, session->index);
   283| }
   284| void
   285| ep_session_write_sequence_point_unbuffered (EventPipeSession *session)
   286| {
   287| 	EP_ASSERT (session != NULL);
   288| 	ep_return_void_if_nok (session->file != NULL && session->buffer_manager != NULL);
   289| 	EventPipeSequencePoint sequence_point;
   290| 	ep_sequence_point_init (&sequence_point);
   291| 	ep_buffer_manager_init_sequence_point_thread_list (session->buffer_manager, &sequence_point);
   292| 	ep_file_write_sequence_point (session->file, &sequence_point);
   293| 	ep_sequence_point_fini (&sequence_point);
   294| }
   295| void
   296| ep_session_start_streaming (EventPipeSession *session)
   297| {
   298| 	EP_ASSERT (session != NULL);
   299| 	ep_requires_lock_held ();
   300| 	if (session->file != NULL)
   301| 		ep_file_initialize_file (session->file);
   302| 	if (session->session_type == EP_SESSION_TYPE_IPCSTREAM || session->session_type == EP_SESSION_TYPE_FILESTREAM)
   303| 		session_create_streaming_thread (session);
   304| 	if (session->session_type == EP_SESSION_TYPE_SYNCHRONOUS) {
   305| 		EP_ASSERT (session->file == NULL);
   306| 		EP_ASSERT (!ep_session_get_streaming_enabled (session));
   307| 	}
   308| 	ep_requires_lock_held ();
   309| 	return;
   310| }
   311| bool
   312| ep_session_is_valid (const EventPipeSession *session)
   313| {
   314| 	EP_ASSERT (session != NULL);
   315| 	ep_requires_lock_held ();
   316| 	return !ep_session_provider_list_is_empty (session->providers);
   317| }
   318| bool
   319| ep_session_add_session_provider (EventPipeSession *session, EventPipeSessionProvider *session_provider)
   320| {
   321| 	EP_ASSERT (session != NULL);
   322| 	ep_requires_lock_held ();
   323| 	return ep_session_provider_list_add_session_provider (session->providers, session_provider);
   324| }
   325| void
   326| ep_session_disable (EventPipeSession *session)
   327| {
   328| 	EP_ASSERT (session != NULL);
   329| 	if ((session->session_type == EP_SESSION_TYPE_IPCSTREAM || session->session_type == EP_SESSION_TYPE_FILESTREAM) && ep_session_get_streaming_enabled (session))
   330| 		session_disable_streaming_thread (session);
   331| 	bool ignored;
   332| 	ep_session_write_all_buffers_to_file (session, &ignored);
   333| 	ep_session_provider_list_clear (session->providers);
   334| }
   335| bool
   336| ep_session_write_all_buffers_to_file (EventPipeSession *session, bool *events_written)
   337| {
   338| 	EP_ASSERT (session != NULL);
   339| 	if (session->file == NULL || session->buffer_manager == NULL)
   340| 		return true;
   341| 	ep_timestamp_t stop_timestamp = ep_perf_timestamp_get ();
   342| 	ep_buffer_manager_write_all_buffers_to_file (session->buffer_manager, session->file, stop_timestamp, events_written);
   343| 	return !ep_file_has_errors (session->file);
   344| }
   345| bool
   346| ep_session_write_event (
   347| 	EventPipeSession *session,
   348| 	ep_rt_thread_handle_t thread,
   349| 	EventPipeEvent *ep_event,
   350| 	EventPipeEventPayload *payload,
   351| 	const uint8_t *activity_id,
   352| 	const uint8_t *related_activity_id,
   353| 	ep_rt_thread_handle_t event_thread,
   354| 	EventPipeStackContents *stack)
   355| {
   356| 	EP_ASSERT (session != NULL);
   357| 	EP_ASSERT (ep_event != NULL);
   358| 	if (session->paused)
   359| 		return true;
   360| 	bool result = false;
   361| 	if (ep_event_is_enabled_by_mask (ep_event, ep_session_get_mask (session))) {
   362| 		if (session->synchronous_callback) {
   363| 			session->synchronous_callback (
   364| 				ep_event_get_provider (ep_event),
   365| 				ep_event_get_event_id (ep_event),
   366| 				ep_event_get_event_version (ep_event),
   367| 				ep_event_get_metadata_len (ep_event),
   368| 				ep_event_get_metadata (ep_event),
   369| 				ep_event_payload_get_size (payload),
   370| 				ep_event_payload_get_flat_data (payload),
   371| 				activity_id,
   372| 				related_activity_id,
   373| 				event_thread,
   374| 				stack == NULL ? 0 : ep_stack_contents_get_size (stack),
   375| 				stack == NULL ? NULL : (uintptr_t *)ep_stack_contents_get_pointer (stack),
   376| 				session->callback_additional_data);
   377| 			result = true;
   378| 		} else {
   379| 			EP_ASSERT (session->buffer_manager != NULL);
   380| 			result = ep_buffer_manager_write_event (
   381| 				session->buffer_manager,
   382| 				thread,
   383| 				session,
   384| 				ep_event,
   385| 				payload,
   386| 				activity_id,
   387| 				related_activity_id,
   388| 				event_thread,
   389| 				stack);
   390| 		}
   391| 	}
   392| 	return result;
   393| }
   394| EventPipeEventInstance *
   395| ep_session_get_next_event (EventPipeSession *session)
   396| {
   397| 	EP_ASSERT (session != NULL);
   398| 	ep_requires_lock_not_held ();
   399| 	if (!session->buffer_manager) {
   400| 		EP_ASSERT (!"Shouldn't call get_next_event on a synchronous session.");
   401| 		return NULL;
   402| 	}
   403| 	return ep_buffer_manager_get_next_event (session->buffer_manager);
   404| }
   405| ep_rt_wait_event_handle_t *
   406| ep_session_get_wait_event (EventPipeSession *session)
   407| {
   408| 	EP_ASSERT (session != NULL);
   409| 	if (!session->buffer_manager) {
   410| 		EP_ASSERT (!"Shouldn't call get_wait_event on a synchronous session.");
   411| 		return NULL;
   412| 	}
   413| 	return ep_buffer_manager_get_rt_wait_event_ref (session->buffer_manager);
   414| }
   415| uint64_t
   416| ep_session_get_mask (const EventPipeSession *session)
   417| {
   418| 	EP_ASSERT (session != NULL);
   419| 	return ((uint64_t)1 << session->index);
   420| }
   421| bool
   422| ep_session_get_rundown_enabled (const EventPipeSession *session)
   423| {
   424| 	EP_ASSERT (session != NULL);
   425| 	return (ep_rt_volatile_load_uint32_t (&session->rundown_enabled) != 0 ? true : false);
   426| }
   427| void
   428| ep_session_set_rundown_enabled (
   429| 	EventPipeSession *session,
   430| 	bool enabled)
   431| {
   432| 	EP_ASSERT (session != NULL);
   433| 	ep_rt_volatile_store_uint32_t (&session->rundown_enabled, (enabled) ? 1 : 0);
   434| }
   435| bool
   436| ep_session_get_streaming_enabled (const EventPipeSession *session)
   437| {
   438| 	EP_ASSERT (session != NULL);
   439| 	return (ep_rt_volatile_load_uint32_t(&session->streaming_enabled) != 0 ? true : false);
   440| }
   441| void
   442| ep_session_set_streaming_enabled (
   443| 	EventPipeSession *session,
   444| 	bool enabled)
   445| {
   446| 	EP_ASSERT (session != NULL);
   447| 	ep_rt_volatile_store_uint32_t (&session->streaming_enabled, (enabled) ? 1 : 0);
   448| }
   449| void
   450| ep_session_pause (EventPipeSession *session)
   451| {
   452| 	EP_ASSERT (session != NULL);
   453| 	session->paused = true;
   454| }
   455| void
   456| ep_session_resume (EventPipeSession *session)
   457| {
   458| 	EP_ASSERT (session != NULL);
   459| 	session->paused = false;
   460| }
   461| #endif /* !defined(EP_INCLUDE_SOURCE_FILES) || defined(EP_FORCE_INCLUDE_SOURCE_FILES) */
   462| #endif /* ENABLE_PERFTRACING */
   463| #if !defined(ENABLE_PERFTRACING) || (defined(EP_INCLUDE_SOURCE_FILES) && !defined(EP_FORCE_INCLUDE_SOURCE_FILES))
   464| extern const char quiet_linker_empty_file_warning_eventpipe_session;
   465| const char quiet_linker_empty_file_warning_eventpipe_session = 0;
   466| #endif


# ====================================================================
# FILE: src/native/eventpipe/ep-session.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-128 ---
     1| #ifndef __EVENTPIPE_SESSION_H__
     2| #define __EVENTPIPE_SESSION_H__
     3| #include "ep-rt-config.h"
     4| #ifdef ENABLE_PERFTRACING
     5| #include "ep-types.h"
     6| #include "ep-thread.h"
     7| #undef EP_IMPL_GETTER_SETTER
     8| #ifdef EP_IMPL_SESSION_GETTER_SETTER
     9| #define EP_IMPL_GETTER_SETTER
    10| #endif
    11| #include "ep-getter-setter.h"
    12| /*
    13|  * EventPipeSession.
    14|  */
    15| #if defined(EP_INLINE_GETTER_SETTER) || defined(EP_IMPL_SESSION_GETTER_SETTER)
    16| struct _EventPipeSession {
    17| #else
    18| struct _EventPipeSession_Internal {
    19| #endif
    20| 	ep_rt_thread_handle_t streaming_thread;
    21| 	ep_rt_wait_event_handle_t rt_thread_shutdown_event;
    22| 	EventPipeSessionProviderList *providers;
    23| 	EventPipeBufferManager *buffer_manager;
    24| 	EventPipeFile *file;
    25| 	EventPipeSessionSynchronousCallback synchronous_callback;
    26| 	void *callback_additional_data;
    27| 	ep_system_timestamp_t session_start_time;
    28| 	ep_timestamp_t session_start_timestamp;
    29| 	uint32_t index;
    30| 	volatile uint32_t rundown_enabled;
    31| 	volatile uint32_t streaming_enabled;
    32| 	EventPipeSessionType session_type;
    33| 	EventPipeSerializationFormat format;
    34| 	bool rundown_requested;
    35| 	bool paused;
    36| 	bool enable_stackwalk;
    37| };
    38| #if !defined(EP_INLINE_GETTER_SETTER) && !defined(EP_IMPL_SESSION_GETTER_SETTER)
    39| struct _EventPipeSession {
    40| 	uint8_t _internal [sizeof (struct _EventPipeSession_Internal)];
    41| };
    42| #endif
    43| EP_DEFINE_GETTER(EventPipeSession *, session, uint32_t, index)
    44| EP_DEFINE_GETTER(EventPipeSession *, session, EventPipeSessionProviderList *, providers)
    45| EP_DEFINE_GETTER(EventPipeSession *, session, EventPipeBufferManager *, buffer_manager)
    46| EP_DEFINE_GETTER_REF(EventPipeSession *, session, volatile uint32_t *, rundown_enabled)
    47| EP_DEFINE_GETTER(EventPipeSession *, session, bool, rundown_requested)
    48| EP_DEFINE_GETTER(EventPipeSession *, session, ep_timestamp_t, session_start_time)
    49| EP_DEFINE_GETTER(EventPipeSession *, session, ep_timestamp_t, session_start_timestamp)
    50| EP_DEFINE_GETTER(EventPipeSession *, session, EventPipeFile *, file)
    51| EP_DEFINE_GETTER(EventPipeSession *, session, bool, enable_stackwalk)
    52| EventPipeSession *
    53| ep_session_alloc (
    54| 	uint32_t index,
    55| 	const ep_char8_t *output_path,
    56| 	IpcStream *stream,
    57| 	EventPipeSessionType session_type,
    58| 	EventPipeSerializationFormat format,
    59| 	bool rundown_requested,
    60| 	uint32_t circular_buffer_size_in_mb,
    61| 	const EventPipeProviderConfiguration *providers,
    62| 	uint32_t providers_len,
    63| 	EventPipeSessionSynchronousCallback sync_callback,
    64| 	void *callback_additional_data);
    65| void
    66| ep_session_free (EventPipeSession *session);
    67| EventPipeSessionProvider *
    68| ep_session_get_session_provider (
    69| 	const EventPipeSession *session,
    70| 	const EventPipeProvider *provider);
    71| bool
    72| ep_session_enable_rundown (EventPipeSession *session);
    73| void
    74| ep_session_execute_rundown (
    75| 	EventPipeSession *session,
    76| 	ep_rt_execution_checkpoint_array_t *execution_checkpoints);
    77| void
    78| ep_session_suspend_write_event (EventPipeSession *session);
    79| void
    80| ep_session_write_sequence_point_unbuffered (EventPipeSession *session);
    81| void
    82| ep_session_start_streaming (EventPipeSession *session);
    83| bool
    84| ep_session_is_valid (const EventPipeSession *session);
    85| bool
    86| ep_session_add_session_provider (
    87| 	EventPipeSession *session,
    88| 	EventPipeSessionProvider *session_provider);
    89| void
    90| ep_session_disable (EventPipeSession *session);
    91| bool
    92| ep_session_write_all_buffers_to_file (
    93| 	EventPipeSession *session,
    94| 	bool *events_written);
    95| bool
    96| ep_session_write_event (
    97| 	EventPipeSession *session,
    98| 	ep_rt_thread_handle_t thread,
    99| 	EventPipeEvent *ep_event,
   100| 	EventPipeEventPayload *payload,
   101| 	const uint8_t *activity_id,
   102| 	const uint8_t *related_activity_id,
   103| 	ep_rt_thread_handle_t event_thread,
   104| 	EventPipeStackContents *stack);
   105| EventPipeEventInstance *
   106| ep_session_get_next_event (EventPipeSession *session);
   107| ep_rt_wait_event_handle_t *
   108| ep_session_get_wait_event (EventPipeSession *session);
   109| uint64_t
   110| ep_session_get_mask (const EventPipeSession *session);
   111| bool
   112| ep_session_get_rundown_enabled (const EventPipeSession *session);
   113| void
   114| ep_session_set_rundown_enabled (
   115| 	EventPipeSession *session,
   116| 	bool enabled);
   117| bool
   118| ep_session_get_streaming_enabled (const EventPipeSession *session);
   119| void
   120| ep_session_set_streaming_enabled (
   121| 	EventPipeSession *session,
   122| 	bool enabled);
   123| void
   124| ep_session_pause (EventPipeSession *session);
   125| void
   126| ep_session_resume (EventPipeSession *session);
   127| #endif /* ENABLE_PERFTRACING */
   128| #endif /* __EVENTPIPE_SESSION_H__ */


# ====================================================================
# FILE: src/tasks/WorkloadBuildTasks/InstallWorkloadFromArtifacts.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-328 ---
     1| using System;
     2| using System.Collections.Generic;
     3| using System.Diagnostics.CodeAnalysis;
     4| using System.Globalization;
     5| using System.IO;
     6| using System.IO.Compression;
     7| using System.Linq;
     8| using System.Text.Json;
     9| using System.Text.Json.Serialization;
    10| using Microsoft.Build.Framework;
    11| using Microsoft.Build.Utilities;
    12| #nullable enable
    13| namespace Microsoft.Workload.Build.Tasks
    14| {
    15|     public class InstallWorkloadFromArtifacts : Task
    16|     {
    17|         [Required, NotNull]
    18|         public ITaskItem[]    WorkloadIds        { get; set; } = Array.Empty<ITaskItem>();
    19|         [Required, NotNull]
    20|         public ITaskItem[]    InstallTargets     { get; set; } = Array.Empty<ITaskItem>();
    21|         [Required, NotNull]
    22|         public string?        VersionBand        { get; set; }
    23|         [Required, NotNull]
    24|         public string?        LocalNuGetsPath    { get; set; }
    25|         [Required, NotNull]
    26|         public string?        TemplateNuGetConfigPath { get; set; }
    27|         [Required, NotNull]
    28|         public string         SdkWithNoWorkloadInstalledPath { get; set; } = string.Empty;
    29|         public bool           OnlyUpdateManifests{ get; set; }
    30|         private const string s_nugetInsertionTag = "<!-- TEST_RESTORE_SOURCES_INSERTION_LINE -->";
    31|         private string AllManifestsStampPath => Path.Combine(SdkWithNoWorkloadInstalledPath, ".all-manifests.stamp");
    32|         public override bool Execute()
    33|         {
    34|             try
    35|             {
    36|                 if (!Directory.Exists(SdkWithNoWorkloadInstalledPath))
    37|                     throw new LogAsErrorException($"Cannot find {nameof(SdkWithNoWorkloadInstalledPath)}={SdkWithNoWorkloadInstalledPath}");
    38|                 if (!Directory.Exists(LocalNuGetsPath))
    39|                     throw new LogAsErrorException($"Cannot find {nameof(LocalNuGetsPath)}={LocalNuGetsPath} . " +
    40|                                                     "Set it to the Shipping packages directory in artifacts.");
    41|                 if (!InstallAllManifests())
    42|                     return false;
    43|                 if (OnlyUpdateManifests)
    44|                     return !Log.HasLoggedErrors;
    45|                 InstallWorkloadRequest[] selectedRequests = InstallTargets
    46|                     .SelectMany(workloadToInstall =>
    47|                     {
    48|                         if (!HasMetadata(workloadToInstall, nameof(workloadToInstall), "Variants", Log))
    49|                             throw new LogAsErrorException($"Missing Variants metadata on item '{workloadToInstall.ItemSpec}'");
    50|                         return workloadToInstall
    51|                                 .GetMetadata("Variants")
    52|                                 .Split(";", StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
    53|                                 .Select(v => (variant: v, target: workloadToInstall));
    54|                     })
    55|                     .SelectMany(w =>
    56|                     {
    57|                         IEnumerable<InstallWorkloadRequest> workloads = WorkloadIds.Where(wi => wi.GetMetadata("Variant") == w.variant)
    58|                                                                                     .Select(wi => new InstallWorkloadRequest(wi, w.target));
    59|                         return workloads.Any()
    60|                                 ? workloads
    61|                                 : throw new LogAsErrorException($"Could not find any workload variant named '{w.variant}'");
    62|                     }).ToArray();
    63|                 foreach (InstallWorkloadRequest req in selectedRequests)
    64|                 {
    65|                     if (Directory.Exists(req.TargetPath))
    66|                     {
    67|                         Log.LogMessage(MessageImportance.Low, $"Deleting directory {req.TargetPath}");
    68|                         Directory.Delete(req.TargetPath, recursive: true);
    69|                     }
    70|                 }
    71|                 string cachePath = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
    72|                 foreach (InstallWorkloadRequest req in selectedRequests)
    73|                 {
    74|                     Log.LogMessage(MessageImportance.High, $"** Installing workload {req.WorkloadId} in {req.TargetPath} **");
    75|                     if (!req.Validate(Log))
    76|                         return false;
    77|                     if (!ExecuteInternal(req) && !req.IgnoreErrors)
    78|                         return false;
    79|                     File.WriteAllText(req.StampPath, string.Empty);
    80|                 }
    81|                 return !Log.HasLoggedErrors;
    82|             }
    83|             catch (LogAsErrorException laee)
    84|             {
    85|                 Log.LogError(laee.Message);
    86|                 return false;
    87|             }
    88|         }
    89|         private bool ExecuteInternal(InstallWorkloadRequest req)
    90|         {
    91|             if (!File.Exists(TemplateNuGetConfigPath))
    92|             {
    93|                 Log.LogError($"Cannot find TemplateNuGetConfigPath={TemplateNuGetConfigPath}");
    94|                 return false;
    95|             }
    96|             Log.LogMessage(MessageImportance.Low, $"Duplicating {SdkWithNoWorkloadInstalledPath} into {req.TargetPath}");
    97|             Utils.DirectoryCopy(SdkWithNoWorkloadInstalledPath, req.TargetPath);
    98|             string nugetConfigContents = GetNuGetConfig();
    99|             if (!InstallPacks(req, nugetConfigContents))
   100|                 return false;
   101|             UpdateAppRef(req.TargetPath, req.Version);
   102|             return !Log.HasLoggedErrors;
   103|         }
   104|         private bool InstallAllManifests()
   105|         {
   106|             var allManifestPkgs = Directory.EnumerateFiles(LocalNuGetsPath, "*Manifest*nupkg");
   107|             if (!AnyInputsNewerThanOutput(AllManifestsStampPath, allManifestPkgs))
   108|             {
   109|                 Log.LogMessage(MessageImportance.Low,
   110|                                     $"Skipping installing manifests because the {AllManifestsStampPath} " +
   111|                                     $"is newer than packages {string.Join(',', allManifestPkgs)}.");
   112|                 return true;
   113|             }
   114|             string nugetConfigContents = GetNuGetConfig();
   115|             HashSet<string> manifestsInstalled = new();
   116|             foreach (ITaskItem workload in WorkloadIds)
   117|             {
   118|                 InstallWorkloadRequest req = new(workload, new TaskItem());
   119|                 if (manifestsInstalled.Contains(req.ManifestName))
   120|                 {
   121|                     Log.LogMessage(MessageImportance.High, $"{Environment.NewLine}** Manifests for workload {req.WorkloadId} are already installed **{Environment.NewLine}");
   122|                     continue;
   123|                 }
   124|                 if (string.IsNullOrEmpty(req.Version))
   125|                 {
   126|                     Log.LogError($"No Version set for workload manifest {req.ManifestName} in workload install requests.");
   127|                     return false;
   128|                 }
   129|                 Log.LogMessage(MessageImportance.High, $"{Environment.NewLine}** Installing manifests for workload {req.WorkloadId} **");
   130|                 if (!InstallWorkloadManifest(workload,
   131|                                              req.ManifestName,
   132|                                              req.Version,
   133|                                              SdkWithNoWorkloadInstalledPath,
   134|                                              nugetConfigContents,
   135|                                              stopOnMissing: true))
   136|                 {
   137|                     return false;
   138|                 }
   139|                 manifestsInstalled.Add(req.ManifestName);
   140|             }
   141|             File.WriteAllText(AllManifestsStampPath, string.Empty);
   142|             return true;
   143|         }
   144|         private bool InstallPacks(InstallWorkloadRequest req, string nugetConfigContents)
   145|         {
   146|             string nugetConfigPath = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
   147|             File.WriteAllText(nugetConfigPath, nugetConfigContents);
   148|             (int exitCode, string output) = Utils.TryRunProcess(
   149|                                                     Log,
   150|                                                     Path.Combine(req.TargetPath, "dotnet"),
   151|                                                     $"workload install --skip-sign-check --skip-manifest-update --no-cache --configfile \"{nugetConfigPath}\" {req.WorkloadId}",
   152|                                                     workingDir: Path.GetTempPath(),
   153|                                                     silent: false,
   154|                                                     logStdErrAsMessage: req.IgnoreErrors,
   155|                                                     debugMessageImportance: MessageImportance.High);
   156|             if (exitCode != 0)
   157|             {
   158|                 if (req.IgnoreErrors)
   159|                 {
   160|                     Log.LogMessage(MessageImportance.High,
   161|                                     $"{Environment.NewLine} ** Ignoring workload installation failure exit code {exitCode}. **{Environment.NewLine}");
   162|                 }
   163|                 else
   164|                 {
   165|                     Log.LogError($"workload install failed with exit code {exitCode}: {output}");
   166|                 }
   167|                 foreach (string dir in Directory.EnumerateDirectories(Path.Combine(req.TargetPath, "sdk-manifests"), "*", SearchOption.AllDirectories))
   168|                     Log.LogMessage(MessageImportance.Low, $"\t{Path.Combine(req.TargetPath, "sdk-manifests", dir)}");
   169|                 foreach (string dir in Directory.EnumerateDirectories(Path.Combine(req.TargetPath, "packs"), "*", SearchOption.AllDirectories))
   170|                     Log.LogMessage(MessageImportance.Low, $"\t{Path.Combine(req.TargetPath, "packs", dir)}");
   171|             }
   172|             return !Log.HasLoggedErrors;
   173|         }
   174|         private void UpdateAppRef(string sdkPath, string version)
   175|         {
   176|             Log.LogMessage(MessageImportance.High, $"{Environment.NewLine}** Updating Targeting pack **{Environment.NewLine}");
   177|             string pkgPath = Path.Combine(LocalNuGetsPath, $"Microsoft.NETCore.App.Ref.{version}.nupkg");
   178|             if (!File.Exists(pkgPath))
   179|                 throw new LogAsErrorException($"Could not find {pkgPath} needed to update the targeting pack to the newly built one." +
   180|                                                 " Make sure to build the subset `packs`, like `./build.sh -os browser -s mono+libs+packs`.");
   181|             string packDir = Path.Combine(sdkPath, "packs", "Microsoft.NETCore.App.Ref");
   182|             string[] dirs = Directory.EnumerateDirectories(packDir).ToArray();
   183|             if (dirs.Length != 1)
   184|                 throw new LogAsErrorException($"Expected to find exactly one versioned directory under {packDir}, but got " +
   185|                                                 string.Join(',', dirs));
   186|             string dstDir = dirs[0];
   187|             Directory.Delete(dstDir, recursive: true);
   188|             Log.LogMessage($"Deleting {dstDir}");
   189|             Directory.CreateDirectory(dstDir);
   190|             ZipFile.ExtractToDirectory(pkgPath, dstDir);
   191|             Log.LogMessage($"Extracting {pkgPath} to {dstDir}");
   192|         }
   193|         private string GetNuGetConfig()
   194|         {
   195|             string contents = File.ReadAllText(TemplateNuGetConfigPath);
   196|             if (contents.IndexOf(s_nugetInsertionTag, StringComparison.InvariantCultureIgnoreCase) < 0)
   197|                 throw new LogAsErrorException($"Could not find {s_nugetInsertionTag} in {TemplateNuGetConfigPath}");
   198|             return contents.Replace(s_nugetInsertionTag, $@"<add key=""nuget-local"" value=""{LocalNuGetsPath}"" />");
   199|         }
   200|         private bool InstallWorkloadManifest(ITaskItem workloadId, string name, string version, string sdkDir, string nugetConfigContents, bool stopOnMissing)
   201|         {
   202|             Log.LogMessage(MessageImportance.High, $"    ** Installing manifest: {name}/{version}");
   203|             string outputDir = FindSubDirIgnoringCase(Path.Combine(sdkDir, "sdk-manifests", VersionBand), name);
   204|             PackageReference pkgRef = new(Name: $"{name}.Manifest-{VersionBand}",
   205|                                           Version: version,
   206|                                           OutputDir: outputDir,
   207|                                           relativeSourceDir: "data");
   208|             if (!PackageInstaller.Install(new[] { pkgRef }, nugetConfigContents, Log, stopOnMissing))
   209|                 return false;
   210|             string manifestDir = pkgRef.OutputDir;
   211|             string jsonPath = Path.Combine(manifestDir, "WorkloadManifest.json");
   212|             if (!File.Exists(jsonPath))
   213|             {
   214|                 Log.LogError($"Could not find WorkloadManifest.json at {jsonPath}");
   215|                 return false;
   216|             }
   217|             ManifestInformation? manifest;
   218|             try
   219|             {
   220|                 manifest = JsonSerializer.Deserialize<ManifestInformation>(
   221|                                                     File.ReadAllBytes(jsonPath),
   222|                                                     new JsonSerializerOptions(JsonSerializerDefaults.Web)
   223|                                                     {
   224|                                                         AllowTrailingCommas = true,
   225|                                                         ReadCommentHandling = JsonCommentHandling.Skip
   226|                                                     });
   227|                 if (manifest == null)
   228|                 {
   229|                     Log.LogError($"Could not parse manifest from {jsonPath}.");
   230|                     return false;
   231|                 }
   232|             }
   233|             catch (JsonException je)
   234|             {
   235|                 Log.LogError($"Failed to read from {jsonPath}: {je.Message}");
   236|                 return false;
   237|             }
   238|             if (manifest.DependsOn != null)
   239|             {
   240|                 foreach ((string depName, string depVersion) in manifest.DependsOn)
   241|                 {
   242|                     if (!InstallWorkloadManifest(workloadId, depName, depVersion, sdkDir, nugetConfigContents, stopOnMissing: false))
   243|                     {
   244|                         Log.LogWarning($"Could not install manifest {depName}/{depVersion}. This can be ignored if the workload {workloadId.ItemSpec} doesn't depend on it.");
   245|                         continue;
   246|                     }
   247|                 }
   248|             }
   249|             return true;
   250|         }
   251|         private static bool HasMetadata(ITaskItem item, string itemName, string metadataName, TaskLoggingHelper log)
   252|         {
   253|             if (!string.IsNullOrEmpty(item.GetMetadata(metadataName)))
   254|                 return true;
   255|             log.LogError($"{itemName} item ({item.ItemSpec}) is missing {metadataName} metadata");
   256|             return false;
   257|         }
   258|         private string FindSubDirIgnoringCase(string parentDir, string dirName)
   259|         {
   260|             string[] matchingDirs = Directory.EnumerateDirectories(parentDir,
   261|                                                             dirName,
   262|                                                             new EnumerationOptions { MatchCasing = MatchCasing.CaseInsensitive })
   263|                                                 .ToArray();
   264|             string? first = matchingDirs.FirstOrDefault();
   265|             if (matchingDirs.Length > 1)
   266|             {
   267|                 Log.LogWarning($"Found multiple directories with names that differ only in case. {string.Join(", ", matchingDirs)}"
   268|                                 + $"{Environment.NewLine}Using the first one: {first}");
   269|             }
   270|             return first ?? Path.Combine(parentDir, dirName.ToLower(CultureInfo.InvariantCulture));
   271|         }
   272|         private static bool AnyInputsNewerThanOutput(string output, IEnumerable<string> inputs)
   273|             => inputs.Any(i => Utils.IsNewerThan(i, output));
   274|         private sealed record ManifestInformation(
   275|             object Version,
   276|             string Description,
   277|             [property: JsonPropertyName("depends-on")]
   278|             IDictionary<string, string> DependsOn,
   279|             IDictionary<string, WorkloadInformation> Workloads,
   280|             IDictionary<string, PackVersionInformation> Packs,
   281|             object Data
   282|         );
   283|         private sealed record WorkloadInformation(
   284|             bool Abstract,
   285|             string Kind,
   286|             string Description,
   287|             List<string> Packs,
   288|             List<string> Extends,
   289|             List<string> Platforms
   290|         );
   291|         private sealed record PackVersionInformation(
   292|             string Kind,
   293|             string Version,
   294|             [property: JsonPropertyName("alias-to")]
   295|             Dictionary<string, string> AliasTo
   296|         );
   297|         internal sealed record InstallWorkloadRequest(
   298|             ITaskItem Workload,
   299|             ITaskItem Target)
   300|         {
   301|             public string ManifestName => Workload.GetMetadata("ManifestName");
   302|             public string Version => Workload.GetMetadata("Version");
   303|             public string TargetPath => Target.GetMetadata("InstallPath");
   304|             public string StampPath => Target.GetMetadata("StampPath");
   305|             public bool IgnoreErrors => Workload.GetMetadata("IgnoreErrors").ToLowerInvariant() == "true";
   306|             public string WorkloadId => Workload.ItemSpec;
   307|             public bool Validate(TaskLoggingHelper log)
   308|             {
   309|                 if (!HasMetadata(Workload, nameof(Workload), "Version", log) ||
   310|                     !HasMetadata(Workload, nameof(Workload), "ManifestName", log) ||
   311|                     !HasMetadata(Target, nameof(Target), "InstallPath", log))
   312|                 {
   313|                     return false;
   314|                 }
   315|                 if (string.IsNullOrEmpty(TargetPath))
   316|                 {
   317|                     log.LogError($"InstallPath is empty for workload {Workload.ItemSpec}");
   318|                     return false;
   319|                 }
   320|                 return true;
   321|             }
   322|         }
   323|     }
   324|     internal sealed record PackageReference(string Name,
   325|                                      string Version,
   326|                                      string OutputDir,
   327|                                      string relativeSourceDir = "");
   328| }

