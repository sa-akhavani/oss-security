# ====================================================================
# FILE: src/coreclr/inc/clrconfigvalues.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-512 ---
     1| CONFIG_DWORD_INFO(INTERNAL_EnableFullDebug, W("EnableFullDebug"), 0, "Heavy-weight checking for AD boundary violations (AD leaks)")
     2| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchEnabled, W("JitPitchEnabled"), (DWORD)0, "Set it to 1 to enable Jit Pitching")
     3| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchMemThreshold, W("JitPitchMemThreshold"), (DWORD)0, "Do Jit Pitching when code heap usage is larger than this (in bytes)")
     4| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchMethodSizeThreshold, W("JitPitchMethodSizeThreshold"), (DWORD)0, "Do Jit Pitching for methods whose native code size larger than this (in bytes)")
     5| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchTimeInterval, W("JitPitchTimeInterval"), (DWORD)0, "Time interval between Jit Pitchings in ms")
     6| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchPrintStat, W("JitPitchPrintStat"), (DWORD)0, "Print statistics about Jit Pitching")
     7| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchMinVal, W("JitPitchMinVal"), (DWORD)0, "Do Jit Pitching if the value of the inner counter greater than this value (for debugging purpose only)")
     8| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchMaxVal, W("JitPitchMaxVal"), (DWORD)0xffffffff, "Do Jit Pitching the value of the inner counter less then this value (for debuggin purpose only)")
     9| CONFIG_DWORD_INFO(INTERNAL_GetAssemblyIfLoadedIgnoreRidMap, W("GetAssemblyIfLoadedIgnoreRidMap"), 0, "Used to force loader to ignore assemblies cached in the rid-map")
    10| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_BreakOnBadExit, W("BreakOnBadExit"), 0, "")
    11| CONFIG_STRING_INFO(INTERNAL_BreakOnClassBuild, W("BreakOnClassBuild"), "Very useful for debugging class layout code.")
    12| CONFIG_STRING_INFO(INTERNAL_BreakOnClassLoad, W("BreakOnClassLoad"), "Very useful for debugging class loading code.")
    13| CONFIG_STRING_INFO(INTERNAL_BreakOnComToClrNativeInfoInit, W("BreakOnComToClrNativeInfoInit"), "Throws an assert when native information about a COM -> CLR call are about to be gathered.")
    14| CONFIG_DWORD_INFO(INTERNAL_BreakOnDebugBreak, W("BreakOnDebugBreak"), 0, "Allows an assert in debug builds when a user break is hit")
    15| CONFIG_DWORD_INFO(INTERNAL_BreakOnDILoad, W("BreakOnDILoad"), 0, "Allows an assert when the DI is loaded")
    16| CONFIG_DWORD_INFO(INTERNAL_BreakOnDumpToken, W("BreakOnDumpToken"), 0xffffffff, "Breaks when using internal logging on a particular token value.")
    17| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_BreakOnEELoad, W("BreakOnEELoad"), 0, "")
    18| CONFIG_DWORD_INFO(INTERNAL_BreakOnEEShutdown, W("BreakOnEEShutdown"), 0, "")
    19| CONFIG_DWORD_INFO(INTERNAL_BreakOnExceptionInGetThrowable, W("BreakOnExceptionInGetThrowable"), 0, "")
    20| CONFIG_DWORD_INFO(INTERNAL_BreakOnFindMethod, W("BreakOnFindMethod"), 0, "Breaks in findMethodInternal when it searches for the specified token.")
    21| CONFIG_DWORD_INFO(INTERNAL_BreakOnFirstPass, W("BreakOnFirstPass"), 0, "")
    22| CONFIG_DWORD_INFO(INTERNAL_BreakOnHR, W("BreakOnHR"), 0, "Debug.cpp, IfFailxxx use this macro to stop if hr matches ")
    23| CONFIG_STRING_INFO(INTERNAL_BreakOnInstantiation, W("BreakOnInstantiation"), "Very useful for debugging generic class instantiation.")
    24| CONFIG_STRING_INFO(INTERNAL_BreakOnInteropStubSetup, W("BreakOnInteropStubSetup"), "Throws an assert when marshaling stub for the given method is about to be built.")
    25| CONFIG_STRING_INFO(INTERNAL_BreakOnInteropVTableBuild, W("BreakOnInteropVTableBuild"), "Specifies a type name for which an assert should be thrown when building interop v-table.")
    26| CONFIG_STRING_INFO(INTERNAL_BreakOnMethodName, W("BreakOnMethodName"), "Very useful for debugging method override placement code.")
    27| CONFIG_DWORD_INFO(INTERNAL_BreakOnNotify, W("BreakOnNotify"), 0, "")
    28| RETAIL_CONFIG_DWORD_INFO(INTERNAL_BreakOnRetailAssert, W("BreakOnRetailAssert"), 0, "Used for debugging \"retail\" asserts (fatal errors)")
    29| CONFIG_DWORD_INFO(INTERNAL_BreakOnSecondPass, W("BreakOnSecondPass"), 0, "")
    30| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_BreakOnSO, W("BreakOnSO"), 0, "")
    31| CONFIG_STRING_INFO(INTERNAL_BreakOnStructMarshalSetup, W("BreakOnStructMarshalSetup"), "Throws an assert when field marshalers for the given type with layout are about to be created.")
    32| CONFIG_DWORD_INFO(INTERNAL_BreakOnUEF, W("BreakOnUEF"), 0, "")
    33| CONFIG_DWORD_INFO(INTERNAL_BreakOnUncaughtException, W("BreakOnUncaughtException"), 0, "")
    34| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableDiagnostics, W("EnableDiagnostics"), 1, "Allows the debugger, profiler, and EventPipe diagnostics to be disabled")
    35| CONFIG_DWORD_INFO(INTERNAL_D__FCE, W("D::FCE"), 0, "Allows an assert when crawling the managed stack for an exception handler")
    36| CONFIG_DWORD_INFO(INTERNAL_DbgBreakIfLocksUnavailable, W("DbgBreakIfLocksUnavailable"), 0, "Allows an assert when the debugger can't take a lock ")
    37| CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnErr, W("DbgBreakOnErr"), 0, "Allows an assert when we get a failing hresult")
    38| CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnMapPatchToDJI, W("DbgBreakOnMapPatchToDJI"), 0, "Allows an assert when mapping a patch to an address")
    39| CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnRawInt3, W("DbgBreakOnRawInt3"), 0, "Allows an assert for test coverage for debug break or other int3 breaks")
    40| CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnSendBreakpoint, W("DbgBreakOnSendBreakpoint"), 0, "Allows an assert when sending a breakpoint to the right side")
    41| CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnSetIP, W("DbgBreakOnSetIP"), 0, "Allows an assert when setting the IP")
    42| CONFIG_DWORD_INFO(INTERNAL_DbgCheckInt3, W("DbgCheckInt3"), 0, "Asserts if the debugger explicitly writes int3 instead of calling SetUnmanagedBreakpoint")
    43| CONFIG_DWORD_INFO(INTERNAL_DbgDACAssertOnMismatch, W("DbgDACAssertOnMismatch"), 0, "Allows an assert when the mscordacwks and mscorwks dll versions don't match")
    44| CONFIG_DWORD_INFO(INTERNAL_DbgDACEnableAssert, W("DbgDACEnableAssert"), 0, "Enables extra validity checking in DAC - assumes target isn't corrupt")
    45| RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgDACSkipVerifyDlls, W("DbgDACSkipVerifyDlls"), 0, "Allows disabling the check to ensure mscordacwks and mscorwks dll versions match")
    46| CONFIG_DWORD_INFO(INTERNAL_DbgDelayHelper, W("DbgDelayHelper"), 0, "Varies the wait in the helper thread startup for testing race between threads")
    47| RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgDisableDynamicSymsCompat, W("DbgDisableDynamicSymsCompat"), 0, "")
    48| CONFIG_DWORD_INFO(INTERNAL_DbgDisableTargetConsistencyAsserts, W("DbgDisableTargetConsistencyAsserts"), 0, "Allows explicitly testing with corrupt targets")
    49| RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgEnableMixedModeDebugging, W("DbgEnableMixedModeDebuggingInternalOnly"), 0, "")
    50| CONFIG_DWORD_INFO(INTERNAL_DbgExtraThreads, W("DbgExtraThreads"), 0, "Allows extra unmanaged threads to run and throw debug events for stress testing")
    51| CONFIG_DWORD_INFO(INTERNAL_DbgExtraThreadsCantStop, W("DbgExtraThreadsCantStop"), 0, "Allows extra unmanaged threads in can't stop region to run and throw debug events for stress testing")
    52| CONFIG_DWORD_INFO(INTERNAL_DbgExtraThreadsIB, W("DbgExtraThreadsIB"), 0, "Allows extra in-band unmanaged threads to run and throw debug events for stress testing")
    53| CONFIG_DWORD_INFO(INTERNAL_DbgExtraThreadsOOB, W("DbgExtraThreadsOOB"), 0, "Allows extra out of band unmanaged threads to run and throw debug events for stress testing")
    54| CONFIG_DWORD_INFO(INTERNAL_DbgFaultInHandleIPCEvent, W("DbgFaultInHandleIPCEvent"), 0, "Allows testing the unhandled event filter")
    55| CONFIG_DWORD_INFO(INTERNAL_DbgInjectFEE, W("DbgInjectFEE"), 0, "Allows injecting a fatal execution error for testing Watson")
    56| CONFIG_DWORD_INFO(INTERNAL_DbgLeakCheck, W("DbgLeakCheck"), 0, "Allows checking for leaked Cordb objects")
    57| CONFIG_DWORD_INFO(INTERNAL_DbgNo2ndChance, W("DbgNo2ndChance"), 0, "Allows breaking on (and catching bogus) 2nd chance exceptions")
    58| CONFIG_DWORD_INFO(INTERNAL_DbgNoDebugger, W("DbgNoDebugger"), 0, "Allows breaking if we don't want to lazily initialize the debugger")
    59| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgNoForceContinue, W("DbgNoForceContinue"), 1, "Used to force a continue on longhorn")
    60| CONFIG_DWORD_INFO(INTERNAL_DbgNoOpenMDByFile, W("DbgNoOpenMDByFile"), 0, "Allows opening MD by memory for perf testing")
    61| CONFIG_DWORD_INFO(INTERNAL_DbgOOBinFEEE, W("DbgOOBinFEEE"), 0, "Allows forcing oob breakpoints when a fatal error occurs")
    62| CONFIG_DWORD_INFO(INTERNAL_DbgPingInterop, W("DbgPingInterop"), 0, "Allows checking for deadlocks in interop debugging")
    63| CONFIG_DWORD_INFO(INTERNAL_DbgRace, W("DbgRace"), 0, "Allows pausing for native debug events to get hijicked")
    64| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgRedirect, W("DbgRedirect"), 0, "Allows for redirecting the event pipeline")
    65| RETAIL_CONFIG_STRING_INFO(EXTERNAL_DbgRedirectApplication, W("DbgRedirectApplication"), "Specifies the auxiliary debugger application to launch.")
    66| RETAIL_CONFIG_STRING_INFO(EXTERNAL_DbgRedirectAttachCmd, W("DbgRedirectAttachCmd"), "Specifies command parameters for attaching the auxiliary debugger.")
    67| RETAIL_CONFIG_STRING_INFO(EXTERNAL_DbgRedirectCommonCmd, W("DbgRedirectCommonCmd"), "Specifies a command line format string for the auxiliary debugger.")
    68| RETAIL_CONFIG_STRING_INFO(EXTERNAL_DbgRedirectCreateCmd, W("DbgRedirectCreateCmd"), "Specifies command parameters when creating the auxiliary debugger.")
    69| CONFIG_DWORD_INFO(INTERNAL_DbgShortcutCanary, W("DbgShortcutCanary"), 0, "Allows a way to force canary to fail to be able to test failure paths")
    70| CONFIG_DWORD_INFO(INTERNAL_DbgSkipMEOnStep, W("DbgSkipMEOnStep"), 0, "Turns off MethodEnter checks")
    71| CONFIG_DWORD_INFO(INTERNAL_DbgSkipVerCheck, W("DbgSkipVerCheck"), 0, "Allows different RS and LS versions (for servicing work)")
    72| CONFIG_DWORD_INFO(INTERNAL_DbgTC, W("DbgTC"), 0, "Allows checking boundary compression for offset mappings")
    73| CONFIG_DWORD_INFO(INTERNAL_DbgTransportFaultInject, W("DbgTransportFaultInject"), 0, "Allows injecting a fault for testing the debug transport")
    74| CONFIG_DWORD_INFO(INTERNAL_DbgTransportLog, W("DbgTransportLog"), 0 /* LE_None */, "Turns on logging for the debug transport")
    75| CONFIG_DWORD_INFO(INTERNAL_DbgTransportLogClass, W("DbgTransportLogClass"), (DWORD)-1 /* LC_All */, "Mask to control what is logged in DbgTransportLog")
    76| RETAIL_CONFIG_STRING_INFO(UNSUPPORTED_DbgTransportProxyAddress, W("DbgTransportProxyAddress"), "Allows specifying the transport proxy address")
    77| CONFIG_DWORD_INFO(INTERNAL_DbgTrapOnSkip, W("DbgTrapOnSkip"), 0, "Allows breaking when we skip a breakpoint")
    78| CONFIG_DWORD_INFO(INTERNAL_DbgWaitTimeout, W("DbgWaitTimeout"), 1, "Specifies the timeout value for waits")
    79| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgWFDETimeout, W("DbgWFDETimeout"), 25, "Specifies the timeout value for wait when waiting for a debug event")
    80| CONFIG_DWORD_INFO(INTERNAL_RaiseExceptionOnAssert, W("RaiseExceptionOnAssert"), 0, "Raise a first chance (if set to 1) or second chance (if set to 2) exception on asserts.")
    81| CONFIG_DWORD_INFO(INTERNAL_DebugBreakOnAssert, W("DebugBreakOnAssert"), 0, "If DACCESS_COMPILE is defined, break on asserts.")
    82| CONFIG_DWORD_INFO(INTERNAL_DebugBreakOnVerificationFailure, W("DebugBreakOnVerificationFailure"), 0, "Halts the jit on verification failure")
    83| CONFIG_STRING_INFO(INTERNAL_DebuggerBreakPoint, W("DebuggerBreakPoint"), "Allows counting various debug events")
    84| CONFIG_STRING_INFO(INTERNAL_DebugVerify, W("DebugVerify"), "Control for tracing in peverify")
    85| CONFIG_DWORD_INFO(INTERNAL_EncApplyChanges, W("EncApplyChanges"), 0, "Allows breaking when ApplyEditAndContinue is called")
    86| CONFIG_DWORD_INFO(INTERNAL_EnCBreakOnRemapComplete, W("EnCBreakOnRemapComplete"), 0, "Allows breaking after N RemapCompletes")
    87| CONFIG_DWORD_INFO(INTERNAL_EnCBreakOnRemapOpportunity, W("EnCBreakOnRemapOpportunity"), 0, "Allows breaking after N RemapOpportunities")
    88| CONFIG_DWORD_INFO(INTERNAL_EncDumpApplyChanges, W("EncDumpApplyChanges"), 0, "Allows dumping edits in delta metadata and il files")
    89| CONFIG_DWORD_INFO(INTERNAL_EncFixupFieldBreak, W("EncFixupFieldBreak"), 0, "Unlikely that this is used anymore.")
    90| CONFIG_DWORD_INFO(INTERNAL_EncJitUpdatedFunction, W("EncJitUpdatedFunction"), 0, "Allows breaking when an updated function is jitted")
    91| CONFIG_DWORD_INFO(INTERNAL_EnCResolveField, W("EnCResolveField"), 0, "Allows breaking when computing the address of an EnC-added field")
    92| CONFIG_DWORD_INFO(INTERNAL_EncResumeInUpdatedFunction, W("EncResumeInUpdatedFunction"), 0, "Allows breaking when execution resumes in a new EnC version of a function")
    93| CONFIG_DWORD_INFO(INTERNAL_DbgAssertOnDebuggeeDebugBreak, W("DbgAssertOnDebuggeeDebugBreak"), 0, "If non-zero causes the managed-only debugger to assert on unhandled breakpoints in the debuggee")
    94| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgDontResumeThreadsOnUnhandledException, W("UNSUPPORTED_DbgDontResumeThreadsOnUnhandledException"), 0, "If non-zero, then don't try to unsuspend threads after continuing a 2nd-chance native exception")
    95| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgSkipStackCheck, W("DbgSkipStackCheck"), 0, "Skip the stack pointer check during stackwalking")
    96| #ifdef DACCESS_COMPILE
    97| CONFIG_DWORD_INFO(INTERNAL_DumpGeneration_IntentionallyCorruptDataFromTarget, W("IntentionallyCorruptDataFromTarget"), 0, "Intentionally fakes bad data retrieved from target to try and break dump generation.")
    98| #endif
    99| CONFIG_DWORD_INFO(UNSUPPORTED_Debugging_RequiredVersion, W("UNSUPPORTED_Debugging_RequiredVersion"), 0, "The lowest ICorDebug version we should attempt to emulate, or 0 for default policy.  Use 2 for CLRv2, 4 for CLRv4, etc.")
   100| #ifdef FEATURE_MINIMETADATA_IN_TRIAGEDUMPS
   101| RETAIL_CONFIG_DWORD_INFO(INTERNAL_MiniMdBufferCapacity, W("MiniMdBufferCapacity"), 64 * 1024, "The max size of the buffer to store mini metadata information for triage- and mini-dumps.")
   102| #endif // FEATURE_MINIMETADATA_IN_TRIAGEDUMPS
   103| CONFIG_DWORD_INFO(INTERNAL_DbgNativeCodeBpBindsAcrossVersions, W("DbgNativeCodeBpBindsAcrossVersions"), 0, "If non-zero causes native breakpoints at offset 0 to bind in all tiered compilation versions of the given method")
   104| CONFIG_DWORD_INFO(INTERNAL_ConditionalContracts, W("ConditionalContracts"), 0, "If ENABLE_CONTRACTS_IMPL is defined, sets whether contracts are conditional. (?)")
   105| CONFIG_DWORD_INFO(INTERNAL_ConsistencyCheck, W("ConsistencyCheck"), 0, "")
   106| CONFIG_DWORD_INFO(INTERNAL_ContinueOnAssert, W("ContinueOnAssert"), 0, "If set, doesn't break on asserts.")
   107| CONFIG_DWORD_INFO(INTERNAL_InjectFatalError, W("InjectFatalError"), 0, "")
   108| CONFIG_DWORD_INFO(INTERNAL_InjectFault, W("InjectFault"), 0, "")
   109| CONFIG_DWORD_INFO(INTERNAL_SuppressChecks, W("SuppressChecks"),0,  "")
   110| #ifdef FEATURE_EH_FUNCLETS
   111| CONFIG_DWORD_INFO(INTERNAL_SuppressLockViolationsOnReentryFromOS, W("SuppressLockViolationsOnReentryFromOS"), 0, "64 bit OOM tests re-enter the CLR via RtlVirtualUnwind.  This indicates whether to suppress resulting locking violations.")
   112| #endif // FEATURE_EH_FUNCLETS
   113| CONFIG_DWORD_INFO(INTERNAL_AssertOnFailFast, W("AssertOnFailFast"), 1, "")
   114| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_legacyCorruptedStateExceptionsPolicy, W("legacyCorruptedStateExceptionsPolicy"), 0, "Enabled Pre-V4 CSE behavior")
   115| CONFIG_DWORD_INFO(INTERNAL_SuppressLostExceptionTypeAssert, W("SuppressLostExceptionTypeAssert"), 0, "")
   116| RETAIL_CONFIG_DWORD_INFO(INTERNAL_UseEntryPointFilter, W("UseEntryPointFilter"), 0, "")
   117| RETAIL_CONFIG_DWORD_INFO(INTERNAL_Corhost_Swallow_Uncaught_Exceptions, W("Corhost_Swallow_Uncaught_Exceptions"), 0, "")
   118| CONFIG_DWORD_INFO(INTERNAL_FastGCCheckStack, W("FastGCCheckStack"), 0, "")
   119| CONFIG_DWORD_INFO(INTERNAL_FastGCStress, W("FastGCStress"), 0, "Reduce the number of GCs done by enabling GCStress")
   120| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_GCBreakOnOOM, W("GCBreakOnOOM"), 0, "Does a DebugBreak at the soonest time we detect an OOM")
   121| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_gcConcurrent, W("gcConcurrent"), (DWORD)-1, "Enables/Disables concurrent GC")
   122| #ifdef FEATURE_CONSERVATIVE_GC
   123| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_gcConservative, W("gcConservative"), 0, "Enables/Disables conservative GC")
   124| #endif
   125| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_gcServer, W("gcServer"), 0, "Enables server GC")
   126| CONFIG_STRING_INFO(INTERNAL_GcCoverage, W("GcCoverage"), "Specify a method or regular expression of method names to run with GCStress")
   127| CONFIG_STRING_INFO(INTERNAL_SkipGCCoverage, W("SkipGcCoverage"), "Specify a list of assembly names to skip with GC Coverage")
   128| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StatsUpdatePeriod, W("StatsUpdatePeriod"), 60, "Specifies the interval, in seconds, at which to update the statistics")
   129| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_GCRetainVM, W("GCRetainVM"), 0, "When set we put the segments that should be deleted on a standby list (instead of releasing them back to the OS) which will be considered to satisfy new segment requests (note that the same thing can be specified via API which is the supported way)")
   130| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCLOHThreshold, W("GCLOHThreshold"), 0, "Specifies the size that will make objects go on LOH")
   131| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_gcAllowVeryLargeObjects, W("gcAllowVeryLargeObjects"), 1, "Allow allocation of 2GB+ objects on GC heap")
   132| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCStress, W("GCStress"), 0, "Trigger GCs at regular intervals")
   133| CONFIG_DWORD_INFO(INTERNAL_GcStressOnDirectCalls, W("GcStressOnDirectCalls"), 0, "Whether to trigger a GC on direct calls")
   134| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_HeapVerify, W("HeapVerify"), 0, "When set verifies the integrity of the managed heap on entry and exit of each GC")
   135| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_GCNumaAware, W("GCNumaAware"), 1, "Specifies if to enable GC NUMA aware")
   136| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCCpuGroup, W("GCCpuGroup"), 0, "Specifies if to enable GC to support CPU groups")
   137| RETAIL_CONFIG_STRING_INFO(EXTERNAL_GCName, W("GCName"), "")
   138| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_ConvertIbcData, W("ConvertIbcData"), 1, "Converts between v1 and v2 IBC data")
   139| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DisableIBC, W("DisableIBC"), 0, "Disables the use of IBC data")
   140| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_UseIBCFile, W("UseIBCFile"), 0, "")
   141| CONFIG_DWORD_INFO(INTERNAL_JitBreakEmit, W("JitBreakEmit"), (DWORD)-1, "")
   142| CONFIG_DWORD_INFO(INTERNAL_JitDebuggable, W("JitDebuggable"), 0, "")
   143| #if !defined(DEBUG) && !defined(_DEBUG)
   144| #define INTERNAL_JitEnableNoWayAssert_Default 0
   145| #else
   146| #define INTERNAL_JitEnableNoWayAssert_Default 1
   147| #endif
   148| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitEnableNoWayAssert, W("JitEnableNoWayAssert"), INTERNAL_JitEnableNoWayAssert_Default, "")
   149| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_JitFramed, W("JitFramed"), 0, "Forces EBP frames")
   150| CONFIG_DWORD_INFO(INTERNAL_JitGCStress, W("JitGCStress"), 0, "GC stress mode for jit")
   151| CONFIG_DWORD_INFO(INTERNAL_JitHeartbeat, W("JitHeartbeat"), 0, "")
   152| CONFIG_DWORD_INFO(INTERNAL_JitHelperLogging, W("JitHelperLogging"), 0, "")
   153| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_JITMinOpts, W("JITMinOpts"), 0, "Forces MinOpts")
   154| RETAIL_CONFIG_STRING_INFO(EXTERNAL_JitName, W("JitName"), "Primary Jit to use")
   155| #if defined(ALLOW_SXS_JIT)
   156| RETAIL_CONFIG_STRING_INFO(EXTERNAL_AltJitName, W("AltJitName"), "Alternative Jit to use, will fall back to primary jit.")
   157| RETAIL_CONFIG_STRING_INFO(EXTERNAL_AltJit, W("AltJit"), "Enables AltJit and selectively limits it to the specified methods.")
   158| RETAIL_CONFIG_STRING_INFO(EXTERNAL_AltJitExcludeAssemblies, W("AltJitExcludeAssemblies"), "Do not use AltJit on this semicolon-delimited list of assemblies.")
   159| #endif // defined(ALLOW_SXS_JIT)
   160| #if defined(FEATURE_STACK_SAMPLING)
   161| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StackSamplingEnabled, W("StackSamplingEnabled"), 0, "Is stack sampling based tracking of evolving hot methods enabled.")
   162| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StackSamplingAfter, W("StackSamplingAfter"), 0, "When to start sampling (for some sort of app steady state), i.e., initial delay for sampling start in milliseconds.")
   163| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StackSamplingEvery, W("StackSamplingEvery"), 100, "How frequent should thread stacks be sampled in milliseconds.")
   164| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StackSamplingNumMethods, W("StackSamplingNumMethods"), 32, "Number of evolving methods to track as hot and JIT them in the background at a given point of execution.")
   165| #endif // defined(FEATURE_JIT_SAMPLING)
   166| #if defined(ALLOW_SXS_JIT_NGEN)
   167| RETAIL_CONFIG_STRING_INFO(INTERNAL_AltJitNgen, W("AltJitNgen"), "Enables AltJit for NGEN and selectively limits it to the specified methods.")
   168| #endif // defined(ALLOW_SXS_JIT_NGEN)
   169| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitHostMaxSlabCache, W("JitHostMaxSlabCache"), 0x1000000, "Sets jit host max slab cache size, 16MB default")
   170| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitOptimizeType, W("JitOptimizeType"), 0 /* OPT_DEFAULT */, "")
   171| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitPrintInlinedMethods, W("JitPrintInlinedMethods"), 0, "")
   172| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitTelemetry, W("JitTelemetry"), 1, "If non-zero, gather JIT telemetry data")
   173| RETAIL_CONFIG_STRING_INFO(INTERNAL_JitTimeLogFile, W("JitTimeLogFile"), "If set, gather JIT throughput data and write to this file.")
   174| RETAIL_CONFIG_STRING_INFO(INTERNAL_JitTimeLogCsv, W("JitTimeLogCsv"), "If set, gather JIT throughput data and write to a CSV file. This mode must be used in internal retail builds.")
   175| RETAIL_CONFIG_STRING_INFO(INTERNAL_JitFuncInfoLogFile, W("JitFuncInfoLogFile"), "If set, gather JIT function info and write to this file.")
   176| CONFIG_DWORD_INFO(INTERNAL_JitVerificationDisable, W("JitVerificationDisable"), 0, "")
   177| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitLockWrite, W("JitLockWrite"), 0, "Force all volatile writes to be 'locked'")
   178| CONFIG_STRING_INFO(INTERNAL_TailCallMax, W("TailCallMax"), "")
   179| RETAIL_CONFIG_STRING_INFO(EXTERNAL_TailCallOpt, W("TailCallOpt"), "")
   180| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TailCallLoopOpt, W("TailCallLoopOpt"), 1, "Convert recursive tail calls to loops")
   181| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_Jit_NetFx40PInvokeStackResilience, W("NetFx40_PInvokeStackResilience"), (DWORD)-1, "Makes P/Invoke resilient against mismatched signature and calling convention (significant perf penalty).")
   182| #if defined(TARGET_X86)
   183| RETAIL_CONFIG_DWORD_INFO(INTERNAL_AltJitAssertOnNYI, W("AltJitAssertOnNYI"), 0, "Controls the AltJit behavior of NYI stuff")
   184| #else
   185| RETAIL_CONFIG_DWORD_INFO(INTERNAL_AltJitAssertOnNYI, W("AltJitAssertOnNYI"), 1, "Controls the AltJit behavior of NYI stuff")
   186| #endif
   187| CONFIG_DWORD_INFO(INTERNAL_JitLargeBranches, W("JitLargeBranches"), 0, "Force using the largest conditional branch format")
   188| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitRegisterFP, W("JitRegisterFP"), 3, "Control FP enregistration")
   189| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitELTHookEnabled, W("JitELTHookEnabled"), 0, "On ARM, setting this will emit Enter/Leave/TailCall callbacks")
   190| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitMemStats, W("JitMemStats"), 0, "Display JIT memory usage statistics")
   191| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitVNMapSelBudget, W("JitVNMapSelBudget"), 100, "Max # of MapSelect's considered for a particular top-level invocation.")
   192| #if defined(TARGET_AMD64) || defined(TARGET_X86) || defined(TARGET_ARM64)
   193| #define EXTERNAL_FeatureSIMD_Default 1
   194| #else // !(defined(TARGET_AMD64) || defined(TARGET_X86) || defined(TARGET_ARM64))
   195| #define EXTERNAL_FeatureSIMD_Default 0
   196| #endif // !(defined(TARGET_AMD64) || defined(TARGET_X86) || defined(TARGET_ARM64))
   197| #if defined(TARGET_AMD64) || defined(TARGET_X86)
   198| #define EXTERNAL_JitEnableAVX_Default 1
   199| #else // !(defined(TARGET_AMD64) || defined(TARGET_X86)
   200| #define EXTERNAL_JitEnableAVX_Default 0
   201| #endif // !(defined(TARGET_AMD64) || defined(TARGET_X86)
   202| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_FeatureSIMD, W("FeatureSIMD"), EXTERNAL_FeatureSIMD_Default, "Enable SIMD intrinsics recognition in System.Numerics.dll and/or System.Numerics.Vectors.dll")
   203| RETAIL_CONFIG_DWORD_INFO(INTERNAL_SIMD16ByteOnly, W("SIMD16ByteOnly"), 0, "Limit maximum SIMD vector length to 16 bytes (used by x64_arm64_altjit)")
   204| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableAVX, W("EnableAVX"), EXTERNAL_JitEnableAVX_Default, "Enable AVX instruction set for wide operations as default")
   205| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TrackDynamicMethodDebugInfo, W("TrackDynamicMethodDebugInfo"), 0, "Specifies whether debug info should be generated and tracked for dynamic methods")
   206| #ifdef FEATURE_MULTICOREJIT
   207| RETAIL_CONFIG_STRING_INFO(INTERNAL_MultiCoreJitProfile, W("MultiCoreJitProfile"), "If set, use the file to store/control multi-core JIT.")
   208| RETAIL_CONFIG_DWORD_INFO(INTERNAL_MultiCoreJitProfileWriteDelay, W("MultiCoreJitProfileWriteDelay"), 12, "Set the delay after which the multi-core JIT profile will be written to disk.")
   209| RETAIL_CONFIG_DWORD_INFO(INTERNAL_MultiCoreJitMinNumCpus, W("MultiCoreJitMinNumCpus"), 2, "Minimum number of cpus that must be present to allow MultiCoreJit usage.")
   210| RETAIL_CONFIG_DWORD_INFO(INTERNAL_MultiCoreJitNoProfileGather, W("MultiCoreJitNoProfileGather"), 0, "Set to 1 to disable profile gathering (but leave possibly enabled profile usage).")
   211| #endif
   212| #ifdef FEATURE_INTERPRETER
   213| RETAIL_CONFIG_STRING_INFO(INTERNAL_Interpret, W("Interpret"), "Selectively uses the interpreter to execute the specified methods")
   214| RETAIL_CONFIG_STRING_INFO(INTERNAL_InterpretExclude, W("InterpretExclude"), "Excludes the specified methods from the set selected by 'Interpret'")
   215| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterMethHashMin, W("InterpreterMethHashMin"), 0, "Only interpret methods selected by 'Interpret' whose hash is at least this value. or after nth")
   216| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterMethHashMax, W("InterpreterMethHashMax"), UINT32_MAX, "If non-zero, only interpret methods selected by 'Interpret' whose hash is at most this value")
   217| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterStubMin, W("InterpreterStubMin"), 0, "Only interpret methods selected by 'Interpret' whose stub num is at least this value.")
   218| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterStubMax, W("InterpreterStubMax"), UINT32_MAX, "If non-zero, only interpret methods selected by 'Interpret' whose stub number is at most this value.")
   219| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterJITThreshold, W("InterpreterJITThreshold"), 10, "The number of times a method should be interpreted before being JITted")
   220| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterDoLoopMethods, W("InterpreterDoLoopMethods"), 0, "If set, don't check for loops, start by interpreting *all* methods")
   221| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterUseCaching, W("InterpreterUseCaching"), 1, "If non-zero, use the caching mechanism.")
   222| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterLooseRules, W("InterpreterLooseRules"), 1, "If non-zero, allow ECMA spec violations required by managed C++.")
   223| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterPrintPostMortem, W("InterpreterPrintPostMortem"), 0, "Prints summary information about the execution to the console")
   224| RETAIL_CONFIG_STRING_INFO(INTERNAL_InterpreterLogFile, W("InterpreterLogFile"), "If non-null, append interpreter logging to this file, else use stdout")
   225| RETAIL_CONFIG_DWORD_INFO(INTERNAL_DumpInterpreterStubs, W("DumpInterpreterStubs"), 0, "Prints all interpreter stubs that are created to the console")
   226| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterEntries, W("TraceInterpreterEntries"), 0, "Logs entries to interpreted methods to the console")
   227| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterIL, W("TraceInterpreterIL"), 0, "Logs individual instructions of interpreted methods to the console")
   228| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterOstack, W("TraceInterpreterOstack"), 0, "Logs operand stack after each IL instruction of interpreted methods to the console")
   229| CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterVerbose, W("TraceInterpreterVerbose"), 0, "Logs interpreter progress with detailed messages to the console")
   230| CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterJITTransition, W("TraceInterpreterJITTransition"), 0, "Logs when the interpreter determines a method should be JITted")
   231| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ForceInterpreter, W("ForceInterpreter"), 0, "If non-zero, force the interpreter to be used")
   232| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterHWIntrinsicsIsSupportedFalse, W("InterpreterHWIntrinsicsIsSupportedFalse"), 0, "If non-zero, force get_IsSupported to return false for hardware intrinsics") // for internal testing purposes
   233| #endif
   234| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterFallback, W("InterpreterFallback"), 0, "Fallback to the interpreter when the JIT compiler fails")
   235| CONFIG_DWORD_INFO(INTERNAL_LoaderHeapCallTracing, W("LoaderHeapCallTracing"), 0, "Loader heap troubleshooting")
   236| RETAIL_CONFIG_DWORD_INFO(INTERNAL_CodeHeapReserveForJumpStubs, W("CodeHeapReserveForJumpStubs"), 1, "Percentage of code heap to reserve for jump stubs")
   237| RETAIL_CONFIG_DWORD_INFO(INTERNAL_NGenReserveForJumpStubs, W("NGenReserveForJumpStubs"), 0, "Percentage of ngen image size to reserve for jump stubs")
   238| RETAIL_CONFIG_DWORD_INFO(INTERNAL_BreakOnOutOfMemoryWithinRange, W("BreakOnOutOfMemoryWithinRange"), 0, "Break before out of memory within range exception is thrown")
   239| RETAIL_CONFIG_DWORD_INFO(INTERNAL_LogEnable, W("LogEnable"), 0, "Turns on the traditional CLR log.")
   240| RETAIL_CONFIG_DWORD_INFO(INTERNAL_LogFacility,  W("LogFacility"), 0, "Specifies a facility mask for CLR log. (See 'loglf.h'; VM interprets string value as hex number.) Also used by stresslog.")
   241| RETAIL_CONFIG_DWORD_INFO(INTERNAL_LogFacility2, W("LogFacility2"), 0, "Specifies a facility mask for CLR log. (See 'loglf.h'; VM interprets string value as hex number.) Also used by stresslog.")
   242| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_logFatalError, W("logFatalError"), 1, "Specifies whether EventReporter logs fatal errors in the Windows event log.")
   243| CONFIG_STRING_INFO(INTERNAL_LogFile, W("LogFile"), "Specifies a file name for the CLR log.")
   244| CONFIG_DWORD_INFO(INTERNAL_LogFileAppend, W("LogFileAppend"), 0 , "Specifies whether to append to or replace the CLR log file.")
   245| CONFIG_DWORD_INFO(INTERNAL_LogFlushFile, W("LogFlushFile"), 0 , "Specifies whether to flush the CLR log file on each write.")
   246| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_LogLevel, W("LogLevel"), 0 , "4=10 msgs, 9=1000000, 10=everything")
   247| RETAIL_CONFIG_DWORD_INFO(INTERNAL_LogToConsole, W("LogToConsole"), 0 , "Writes the CLR log to console.")
   248| CONFIG_DWORD_INFO(INTERNAL_LogToDebugger, W("LogToDebugger"), 0 , "Writes the CLR log to debugger (OutputDebugStringA).")
   249| CONFIG_DWORD_INFO(INTERNAL_LogToFile, W("LogToFile"), 0 , "Writes the CLR log to a file.")
   250| CONFIG_DWORD_INFO(INTERNAL_LogWithPid, W("LogWithPid"), FALSE, "Appends pid to filename for the CLR log.")
   251| CONFIG_DWORD_INFO(INTERNAL_MD_ApplyDeltaBreak, W("MD_ApplyDeltaBreak"), 0, "ASSERT when applying EnC")
   252| RETAIL_CONFIG_DWORD_INFO(INTERNAL_AssertOnBadImageFormat, W("AssertOnBadImageFormat"), 0, "ASSERT when invalid MD read")
   253| RETAIL_CONFIG_DWORD_INFO(INTERNAL_MD_DeltaCheck, W("MD_DeltaCheck"), 1, "Some checks of GUID when applying EnC (?)")
   254| CONFIG_DWORD_INFO(INTERNAL_MD_EncDelta, W("MD_EncDelta"), 0, "Forces EnC Delta format in MD (?)")
   255| RETAIL_CONFIG_DWORD_INFO(INTERNAL_MD_ForceNoColDesSharing, W("MD_ForceNoColDesSharing"), 0, "Don't know - the only usage I could find is #if 0 (?)")
   256| CONFIG_DWORD_INFO(INTERNAL_MD_KeepKnownCA, W("MD_KeepKnownCA"), 0, "Something with known CAs (?)")
   257| CONFIG_DWORD_INFO(INTERNAL_MD_MiniMDBreak, W("MD_MiniMDBreak"), 0, "ASSERT when creating CMiniMdRw class")
   258| CONFIG_DWORD_INFO(INTERNAL_MD_PreSaveBreak, W("MD_PreSaveBreak"), 0, "ASSERT when calling CMiniMdRw::PreSave")
   259| CONFIG_DWORD_INFO(INTERNAL_MD_RegMetaBreak, W("MD_RegMetaBreak"), 0, "ASSERT when creating RegMeta class")
   260| CONFIG_DWORD_INFO(INTERNAL_MD_RegMetaDump, W("MD_RegMetaDump"), 0, "Dump MD in 4 functions (?)")
   261| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_DOTNET_MODIFIABLE_ASSEMBLIES, W("MODIFIABLE_ASSEMBLIES"), "Enables hot reload on debug built assemblies with the 'debug' keyword", CLRConfig::LookupOptions::TrimWhiteSpaceFromStringValue);
   262| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_MD_PreserveDebuggerMetadataMemory, W("MD_PreserveDebuggerMetadataMemory"), 0, "Save all versions of metadata memory in the debugger when debuggee metadata is updated")
   263| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinInitialDuration, W("SpinInitialDuration"), 0x32, "Hex value specifying the first spin duration")
   264| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinBackoffFactor, W("SpinBackoffFactor"), 0x3, "Hex value specifying the growth of each successive spin duration")
   265| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinLimitProcCap, W("SpinLimitProcCap"), 0xFFFFFFFF, "Hex value specifying the largest value of NumProcs to use when calculating the maximum spin duration")
   266| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinLimitProcFactor, W("SpinLimitProcFactor"), 0x4E20, "Hex value specifying the multiplier on NumProcs to use when calculating the maximum spin duration")
   267| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinLimitConstant, W("SpinLimitConstant"), 0x0, "Hex value specifying the constant to add when calculating the maximum spin duration")
   268| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinRetryCount, W("SpinRetryCount"), 0xA, "Hex value specifying the number of times the entire spin process is repeated (when applicable)")
   269| RETAIL_CONFIG_DWORD_INFO(INTERNAL_Monitor_SpinCount, W("Monitor_SpinCount"), 0x1e, "Hex value specifying the maximum number of spin iterations Monitor may perform upon contention on acquiring the lock before waiting.")
   270| CONFIG_DWORD_INFO(INTERNAL_NgenBind_ZapForbid,             W("NgenBind_ZapForbid"), 0, "Assert if an assembly succeeds in binding to a native image")
   271| CONFIG_STRING_INFO(INTERNAL_NgenBind_ZapForbidExcludeList, W("NgenBind_ZapForbidExcludeList"), "")
   272| CONFIG_STRING_INFO(INTERNAL_NgenBind_ZapForbidList,        W("NgenBind_ZapForbidList"), "")
   273| CONFIG_DWORD_INFO(INTERNAL_SymDiffDump, W("SymDiffDump"), 0, "Used to create the map file while binding the assembly. Used by SemanticDiffer")
   274| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_NGenFramed, W("NGenFramed"), (DWORD)-1, "Same as JitFramed, but for ngen")
   275| CONFIG_DWORD_INFO(INTERNAL_NGenOnlyOneMethod, W("NGenOnlyOneMethod"), 0, "")
   276| CONFIG_DWORD_INFO(INTERNAL_NgenOrder, W("NgenOrder"), 0, "")
   277| CONFIG_DWORD_INFO(INTERNAL_partialNGenStress, W("partialNGenStress"), 0, "")
   278| CONFIG_DWORD_INFO(INTERNAL_ZapDoNothing, W("ZapDoNothing"), 0, "")
   279| CONFIG_DWORD_INFO(INTERNAL_NgenForceFailureMask, W("NgenForceFailureMask"), (DWORD)-1, "Bitmask used to control which locations will check and raise the failure (defaults to bits: -1)")
   280| CONFIG_DWORD_INFO(INTERNAL_NgenForceFailureCount, W("NgenForceFailureCount"), 0, "If set to >0 and we have IBC data we will force a failure after we reference an IBC data item <value> times")
   281| CONFIG_DWORD_INFO(INTERNAL_NgenForceFailureKind, W("NgenForceFailureKind"), 1, "If set to 1, We will throw a TypeLoad exception; If set to 2, We will cause an A/V")
   282| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_NGenEnableCreatePdb, W("NGenEnableCreatePdb"), 0, "If set to >0 ngen.exe displays help on, recognizes createpdb in the command line")
   283| RETAIL_CONFIG_DWORD_INFO(INTERNAL_NGenSimulateDiskFull, W("NGenSimulateDiskFull"), 0, "If set to 1, ngen will throw a Disk full exception in ZapWriter.cpp:Save()")
   284| RETAIL_CONFIG_DWORD_INFO(INTERNAL_PartialNGen, W("PartialNGen"), (DWORD)-1, "Generate partial NGen images")
   285| CONFIG_DWORD_INFO(INTERNAL_NoASLRForNgen, W("NoASLRForNgen"), 0, "Turn off IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE bit in generated ngen images. Makes nidump output repeatable from run to run.")
   286| RETAIL_CONFIG_STRING_INFO(INTERNAL_NativeImageSearchPaths, W("NativeImageSearchPaths"), "Extra search paths for native composite R2R images")
   287| #ifdef CROSSGEN_COMPILE
   288| RETAIL_CONFIG_DWORD_INFO(INTERNAL_CrossGenAssumeInputSigned, W("CrossGenAssumeInputSigned"), 1, "CrossGen should assume that its input assemblies will be signed before deployment")
   289| #endif
   290| RETAIL_CONFIG_DWORD_INFO_EX(EXTERNAL_COR_ENABLE_PROFILING, W("COR_ENABLE_PROFILING"), 0, "Flag to indicate whether profiling should be enabled for the currently running process.", CLRConfig::LookupOptions::DontPrependPrefix)
   291| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_COR_PROFILER, W("COR_PROFILER"), "Specifies GUID of profiler to load into currently running process", CLRConfig::LookupOptions::DontPrependPrefix)
   292| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_COR_PROFILER_PATH, W("COR_PROFILER_PATH"), "Specifies the path to the DLL of profiler to load into currently running process", CLRConfig::LookupOptions::DontPrependPrefix)
   293| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_COR_PROFILER_PATH_32, W("COR_PROFILER_PATH_32"), "Specifies the path to the DLL of profiler to load into currently running 32 bits process", CLRConfig::LookupOptions::DontPrependPrefix)
   294| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_COR_PROFILER_PATH_64, W("COR_PROFILER_PATH_64"), "Specifies the path to the DLL of profiler to load into currently running 64 bits process", CLRConfig::LookupOptions::DontPrependPrefix)
   295| RETAIL_CONFIG_DWORD_INFO_EX(EXTERNAL_CORECLR_ENABLE_PROFILING, W("CORECLR_ENABLE_PROFILING"), 0, "CoreCLR only: Flag to indicate whether profiling should be enabled for the currently running process.", CLRConfig::LookupOptions::DontPrependPrefix)
   296| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER, W("CORECLR_PROFILER"), "CoreCLR only: Specifies GUID of profiler to load into currently running process", CLRConfig::LookupOptions::DontPrependPrefix)
   297| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH, W("CORECLR_PROFILER_PATH"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running process", CLRConfig::LookupOptions::DontPrependPrefix)
   298| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH_32, W("CORECLR_PROFILER_PATH_32"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running 32 process", CLRConfig::LookupOptions::DontPrependPrefix)
   299| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH_64, W("CORECLR_PROFILER_PATH_64"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running 64 process", CLRConfig::LookupOptions::DontPrependPrefix)
   300| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH_ARM32, W("CORECLR_PROFILER_PATH_ARM32"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running ARM32 process", CLRConfig::LookupOptions::DontPrependPrefix)
   301| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH_ARM64, W("CORECLR_PROFILER_PATH_ARM64"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running ARM64 process", CLRConfig::LookupOptions::DontPrependPrefix)
   302| RETAIL_CONFIG_DWORD_INFO_EX(EXTERNAL_CORECLR_ENABLE_NOTIFICATION_PROFILERS, W("CORECLR_ENABLE_NOTIFICATION_PROFILERS"), 0, "Set to 0 to disable loading notification profilers.", CLRConfig::LookupOptions::DontPrependPrefix)
   303| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS_64, W("CORECLR_NOTIFICATION_PROFILERS_64"), "A semi-colon separated list of notification profilers to load in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
   304| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS_32, W("CORECLR_NOTIFICATION_PROFILERS_32"), "A semi-colon separated list of notification profilers to load in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
   305| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS, W("CORECLR_NOTIFICATION_PROFILERS"), "A semi-colon separated list of notification profilers to load in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
   306| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_ProfAPI_ProfilerCompatibilitySetting, W("ProfAPI_ProfilerCompatibilitySetting"), "Specifies the profiler loading policy (the default is not to load a V2 profiler in V4)", CLRConfig::LookupOptions::TrimWhiteSpaceFromStringValue)
   307| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ProfAPI_DetachMinSleepMs, W("ProfAPI_DetachMinSleepMs"), 0, "The minimum time, in milliseconds, the CLR will wait before checking whether a profiler that is in the process of detaching is ready to be unloaded.")
   308| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ProfAPI_DetachMaxSleepMs, W("ProfAPI_DetachMaxSleepMs"), 0, "The maximum time, in milliseconds, the CLR will wait before checking whether a profiler that is in the process of detaching is ready to be unloaded.")
   309| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ProfAPI_RejitOnAttach, W("ProfApi_RejitOnAttach"), 1, "Enables the ability for profilers to rejit methods on attach.")
   310| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ProfAPI_InliningTracking, W("ProfApi_InliningTracking"), 1, "Enables the runtime's tracking of inlining for profiler ReJIT.")
   311| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_DebuggerLaunchDisablesCodeVersioning, W("EXTERNAL_DebuggerLaunchDisablesCodeVersioning"), 1, "Attaching a debugger at startup will disable TieredCompilation and RejitOnAttach.")
   312| CONFIG_DWORD_INFO(INTERNAL_ProfAPI_EnableRejitDiagnostics, W("ProfAPI_EnableRejitDiagnostics"), 0, "Enable extra dumping to stdout of rejit structures")
   313| CONFIG_DWORD_INFO(INTERNAL_ProfAPIFault, W("ProfAPIFault"), 0, "Test-only bitmask to inject various types of faults in the profapi code")
   314| CONFIG_DWORD_INFO(INTERNAL_TestOnlyAllowedEventMask, W("TestOnlyAllowedEventMask"), 0, "Test-only bitmask to allow profiler tests to override CLR enforcement of COR_PRF_ALLOWABLE_AFTER_ATTACH and COR_PRF_MONITOR_IMMUTABLE")
   315| CONFIG_DWORD_INFO(INTERNAL_TestOnlyEnableICorProfilerInfo, W("ProfAPI_TestOnlyEnableICorProfilerInfo"), 0, "Test-only flag to allow attaching profiler tests to call ICorProfilerInfo interface, which would otherwise be disallowed for attaching profilers")
   316| CONFIG_DWORD_INFO(INTERNAL_TestOnlyEnableObjectAllocatedHook, W("TestOnlyEnableObjectAllocatedHook"), 0, "Test-only flag that forces CLR to initialize on startup as if ObjectAllocated callback were requested, to enable post-attach ObjectAllocated functionality.")
   317| CONFIG_DWORD_INFO(INTERNAL_TestOnlyEnableSlowELTHooks, W("TestOnlyEnableSlowELTHooks"), 0, "Test-only flag that forces CLR to initialize on startup as if slow-ELT were requested, to enable post-attach ELT functionality.")
   318| RETAIL_CONFIG_STRING_INFO(UNSUPPORTED_ETW_ObjectAllocationEventsPerTypePerSec, W("ETW_ObjectAllocationEventsPerTypePerSec"), "Desired number of GCSampledObjectAllocation ETW events to be logged per type per second.  If 0, then the default built in to the implementation for the enabled event (e.g., High, Low), will be used.")
   319| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_ProfAPI_ValidateNGENInstrumentation, W("ProfAPI_ValidateNGENInstrumentation"), 0, "This flag enables additional validations when using the IMetaDataEmit APIs for NGEN'ed images to ensure only supported edits are made.")
   320| #ifdef FEATURE_PERFMAP
   321| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_PerfMapEnabled, W("PerfMapEnabled"), 0, "This flag is used on Linux to enable writing /tmp/perf-$pid.map. It is disabled by default")
   322| RETAIL_CONFIG_STRING_INFO(EXTERNAL_PerfMapJitDumpPath, W("PerfMapJitDumpPath"), "Specifies a path to write the perf jitdump file. Defaults to /tmp")
   323| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_PerfMapIgnoreSignal, W("PerfMapIgnoreSignal"), 0, "When perf map is enabled, this option will configure the specified signal to be accepted and ignored as a marker in the perf logs.  It is disabled by default")
   324| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_PerfMapShowOptimizationTiers, W("PerfMapShowOptimizationTiers"), 1, "Shows optimization tiers in the perf map for methods, as part of the symbol name. Useful for seeing separate stack frames for different optimization tiers of each method.")
   325| RETAIL_CONFIG_STRING_INFO(EXTERNAL_NativeImagePerfMapFormat, W("NativeImagePerfMapFormat"), "Specifies the format of native image perfmap files generated by crossgen.  Valid options are RVA or OFFSET.")
   326| #endif
   327| RETAIL_CONFIG_STRING_INFO(EXTERNAL_StartupDelayMS, W("StartupDelayMS"), "")
   328| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StressLog, W("StressLog"), 0, "Turns on the stress log.")
   329| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_ForceEnc, W("ForceEnc"), 0, "Forces Edit and Continue to be on for all eligible modules.")
   330| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StressLogSize, W("StressLogSize"), 0, "Stress log size in bytes per thread.")
   331| RETAIL_CONFIG_STRING_INFO(UNSUPPORTED_StressLogFilename, W("StressLogFilename"), "Stress log filename for memory mapped stress log.")
   332| CONFIG_DWORD_INFO(INTERNAL_stressSynchronized, W("stressSynchronized"), 0, "Unknown if or where this is used; unless a test is specifically depending on this, it can be removed.")
   333| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TotalStressLogSize, W("TotalStressLogSize"), 0, "Total stress log size in bytes.")
   334| CONFIG_DWORD_INFO(INTERNAL_DiagnosticSuspend, W("DiagnosticSuspend"), 0, "")
   335| CONFIG_DWORD_INFO(INTERNAL_SuspendDeadlockTimeout, W("SuspendDeadlockTimeout"), 40000, "")
   336| CONFIG_DWORD_INFO(INTERNAL_SuspendThreadDeadlockTimeoutMs, W("SuspendThreadDeadlockTimeoutMs"), 2000, "")
   337| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadSuspendInjection, W("INTERNAL_ThreadSuspendInjection"), 1, "Specifies whether to inject activations for thread suspension on Unix")
   338| RETAIL_CONFIG_DWORD_INFO(INTERNAL_DefaultStackSize, W("DefaultStackSize"), 0, "Stack size to use for new VM threads when thread is created with default stack size (dwStackSize == 0).")
   339| RETAIL_CONFIG_DWORD_INFO(INTERNAL_Thread_DeadThreadCountThresholdForGCTrigger, W("Thread_DeadThreadCountThresholdForGCTrigger"), 75, "In the heuristics to clean up dead threads, this threshold must be reached before triggering a GC will be considered. Set to 0 to disable triggering a GC based on dead threads.")
   340| RETAIL_CONFIG_DWORD_INFO(INTERNAL_Thread_DeadThreadGCTriggerPeriodMilliseconds, W("Thread_DeadThreadGCTriggerPeriodMilliseconds"), 1000 * 60 * 30, "In the heuristics to clean up dead threads, this much time must have elapsed since the previous max-generation GC before triggering another GC will be considered")
   341| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_Thread_UseAllCpuGroups, W("Thread_UseAllCpuGroups"), 0, "Specifies whether to query and use CPU group information for determining the processor count.")
   342| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_Thread_AssignCpuGroups, W("Thread_AssignCpuGroups"), 1, "Specifies whether to automatically distribute threads created by the CLR across CPU Groups. Effective only when Thread_UseAllCpuGroups and GCCpuGroup are enabled.")
   343| RETAIL_CONFIG_DWORD_INFO_EX(EXTERNAL_ProcessorCount, W("PROCESSOR_COUNT"), 0, "Specifies the number of processors available for the process, which is returned by Environment.ProcessorCount", CLRConfig::LookupOptions::ParseIntegerAsBase10)
   344| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_UsePortableThreadPool, W("ThreadPool_UsePortableThreadPool"), 1, "Uses the managed portable thread pool implementation instead of the unmanaged one.")
   345| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_ForceMinWorkerThreads, W("ThreadPool_ForceMinWorkerThreads"), 0, "Overrides the MinThreads setting for the ThreadPool worker pool")
   346| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_ForceMaxWorkerThreads, W("ThreadPool_ForceMaxWorkerThreads"), 0, "Overrides the MaxThreads setting for the ThreadPool worker pool")
   347| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_DisableStarvationDetection, W("ThreadPool_DisableStarvationDetection"), 0, "Disables the ThreadPool feature that forces new threads to be added when workitems run for too long")
   348| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_DebugBreakOnWorkerStarvation, W("ThreadPool_DebugBreakOnWorkerStarvation"), 0, "Breaks into the debugger if the ThreadPool detects work queue starvation")
   349| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_EnableWorkerTracking, W("ThreadPool_EnableWorkerTracking"), 0, "Enables extra expensive tracking of how many workers threads are working simultaneously")
   350| #ifdef TARGET_ARM64
   351| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_UnfairSemaphoreSpinLimit, W("ThreadPool_UnfairSemaphoreSpinLimit"), 0x32, "Maximum number of spins per processor a thread pool worker thread performs before waiting for work")
   352| #else // !TARGET_ARM64
   353| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_UnfairSemaphoreSpinLimit, W("ThreadPool_UnfairSemaphoreSpinLimit"), 0x46, "Maximum number of spins a thread pool worker thread performs before waiting for work")
   354| #endif // TARGET_ARM64
   355| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_Disable,                             W("HillClimbing_Disable"),                            0, "Disables hill climbing for thread adjustments in the thread pool");
   356| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_WavePeriod,                          W("HillClimbing_WavePeriod"),                         4, "");
   357| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_TargetSignalToNoiseRatio,            W("HillClimbing_TargetSignalToNoiseRatio"),           300, "");
   358| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_ErrorSmoothingFactor,                W("HillClimbing_ErrorSmoothingFactor"),               1, "");
   359| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_WaveMagnitudeMultiplier,             W("HillClimbing_WaveMagnitudeMultiplier"),            100, "");
   360| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_MaxWaveMagnitude,                    W("HillClimbing_MaxWaveMagnitude"),                   20, "");
   361| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_WaveHistorySize,                     W("HillClimbing_WaveHistorySize"),                    8, "");
   362| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_Bias,                                W("HillClimbing_Bias"),                               15, "The 'cost' of a thread.  0 means drive for increased throughput regardless of thread count; higher values bias more against higher thread counts.");
   363| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_MaxChangePerSecond,                  W("HillClimbing_MaxChangePerSecond"),                 4, "");
   364| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_MaxChangePerSample,                  W("HillClimbing_MaxChangePerSample"),                 20, "");
   365| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_MaxSampleErrorPercent,               W("HillClimbing_MaxSampleErrorPercent"),              15, "");
   366| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_SampleIntervalLow,                   W("HillClimbing_SampleIntervalLow"),                  10, "");
   367| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_SampleIntervalHigh,                  W("HillClimbing_SampleIntervalHigh"),                 200, "");
   368| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_GainExponent,                        W("HillClimbing_GainExponent"),                       200, "The exponent to apply to the gain, times 100.  100 means to use linear gain, higher values will enhance large moves and damp small ones.");
   369| #ifdef FEATURE_TIERED_COMPILATION
   370| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TieredCompilation, W("TieredCompilation"), 1, "Enables tiered compilation")
   371| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TC_QuickJit, W("TC_QuickJit"), 1, "For methods that would be jitted, enable using quick JIT when appropriate.")
   372| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TC_QuickJitForLoops, W("TC_QuickJitForLoops"), 0, "When quick JIT is enabled, quick JIT may also be used for methods that contain loops.")
   373| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TC_AggressiveTiering, W("TC_AggressiveTiering"), 0, "Transition through tiers aggressively.")
   374| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_BackgroundWorkerTimeoutMs, W("TC_BackgroundWorkerTimeoutMs"), 4000, "How long in milliseconds the background worker thread may remain idle before exiting.")
   375| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_CallCountThreshold, W("TC_CallCountThreshold"), 30, "Number of times a method must be called in tier 0 after which it is promoted to the next tier.")
   376| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_CallCountingDelayMs, W("TC_CallCountingDelayMs"), 100, "A perpetual delay in milliseconds that is applied call counting in tier 0 and jitting at higher tiers, while there is startup-like activity.")
   377| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_DelaySingleProcMultiplier, W("TC_DelaySingleProcMultiplier"), 10, "Multiplier for TC_CallCountingDelayMs that is applied on a single-processor machine or when the process is affinitized to a single processor.")
   378| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_CallCounting, W("TC_CallCounting"), 1, "Enabled by default (only activates when TieredCompilation is also enabled). If disabled immediately backpatches prestub, and likely prevents any promotion to higher tiers")
   379| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_UseCallCountingStubs, W("TC_UseCallCountingStubs"), 1, "Uses call counting stubs for faster call counting.")
   380| #ifdef _DEBUG
   381| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_DeleteCallCountingStubsAfter, W("TC_DeleteCallCountingStubsAfter"), 1, "Deletes call counting stubs after this many have completed. Zero to disable deleting.")
   382| #else
   383| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_DeleteCallCountingStubsAfter, W("TC_DeleteCallCountingStubsAfter"), 4096, "Deletes call counting stubs after this many have completed. Zero to disable deleting.")
   384| #endif
   385| #endif // FEATURE_TIERED_COMPILATION
   386| #ifdef FEATURE_ON_STACK_REPLACEMENT
   387| RETAIL_CONFIG_DWORD_INFO(INTERNAL_OSR_CounterBump, W("OSR_CounterBump"), 1000, "Counter reload value when a patchpoint is hit")
   388| RETAIL_CONFIG_DWORD_INFO(INTERNAL_OSR_HitLimit, W("OSR_HitLimit"), 10, "Number of times a patchpoint must call back to trigger an OSR transition")
   389| CONFIG_DWORD_INFO(INTERNAL_OSR_LowId, W("OSR_LowId"), (DWORD)-1, "Low end of enabled patchpoint range (inclusive)");
   390| CONFIG_DWORD_INFO(INTERNAL_OSR_HighId, W("OSR_HighId"), 10000000, "High end of enabled patchpoint range (inclusive)");
   391| #endif
   392| #ifdef FEATURE_PGO
   393| RETAIL_CONFIG_STRING_INFO(INTERNAL_PGODataPath, W("PGODataPath"), "Read/Write PGO data from/to the indicated file.")
   394| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ReadPGOData, W("ReadPGOData"), 0, "Read PGO data")
   395| RETAIL_CONFIG_DWORD_INFO(INTERNAL_WritePGOData, W("WritePGOData"), 0, "Write PGO data")
   396| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TieredPGO, W("TieredPGO"), 0, "Instrument Tier0 code and make counts available to Tier1")
   397| #endif
   398| #ifndef CROSSGEN_COMPILE
   399| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_BackpatchEntryPointSlots, W("BackpatchEntryPointSlots"), 1, "Indicates whether to enable entry point slot backpatching, for instance to avoid making virtual calls through a precode and instead to patch virtual slots for a method when its entry point changes.")
   400| #endif
   401| CONFIG_DWORD_INFO(INTERNAL_TypeLoader_InjectInterfaceDuplicates, W("INTERNAL_TypeLoader_InjectInterfaceDuplicates"), 0, "Injects duplicates in interface map for all types.")
   402| CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubCollideMonoPct, W("VirtualCallStubCollideMonoPct"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
   403| CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubCollideWritePct, W("VirtualCallStubCollideWritePct"), 100, "Used only when STUB_LOGGING is defined, which by default is not.")
   404| CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubDumpLogCounter, W("VirtualCallStubDumpLogCounter"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
   405| CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubDumpLogIncr, W("VirtualCallStubDumpLogIncr"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
   406| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_VirtualCallStubLogging, W("VirtualCallStubLogging"), 0, "Worth keeping, but should be moved into \"#ifdef STUB_LOGGING\" blocks. This goes for most (or all) of the stub logging infrastructure.")
   407| CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubMissCount, W("VirtualCallStubMissCount"), 100, "Used only when STUB_LOGGING is defined, which by default is not.")
   408| CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubResetCacheCounter, W("VirtualCallStubResetCacheCounter"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
   409| CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubResetCacheIncr, W("VirtualCallStubResetCacheIncr"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
   410| RETAIL_CONFIG_DWORD_INFO(INTERNAL_DisableWatsonForManagedExceptions, W("DisableWatsonForManagedExceptions"), 0, "Disable Watson and debugger launching for managed exceptions")
   411| RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgEnableMiniDump, W("DbgEnableMiniDump"), 0, "Enable unhandled exception crash dump generation")
   412| RETAIL_CONFIG_STRING_INFO(INTERNAL_DbgMiniDumpName, W("DbgMiniDumpName"), "Crash dump name")
   413| RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgMiniDumpType, W("DbgMiniDumpType"), 0, "Crash dump type: 1 normal, 2 withheap, 3 triage, 4 full")
   414| RETAIL_CONFIG_DWORD_INFO(INTERNAL_CreateDumpDiagnostics, W("CreateDumpDiagnostics"), 0, "Enable crash dump generation diagnostic logging")
   415| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EnableDumpOnSigTerm, W("EnableDumpOnSigTerm"), 0, "Enable crash dump generation on SIGTERM")
   416| RETAIL_CONFIG_STRING_INFO(INTERNAL_ZapBBInstr, W("ZapBBInstr"), "")
   417| RETAIL_CONFIG_STRING_INFO(EXTERNAL_ZapBBInstrDir, W("ZapBBInstrDir"), "")
   418| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ZapDisable, W("ZapDisable"), 0, "")
   419| CONFIG_STRING_INFO(INTERNAL_ZapExclude, W("ZapExclude"), "")
   420| CONFIG_STRING_INFO(INTERNAL_ZapOnly, W("ZapOnly"), "")
   421| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ZapRequire, W("ZapRequire"), 0, "")
   422| RETAIL_CONFIG_STRING_INFO(EXTERNAL_ZapRequireExcludeList, W("ZapRequireExcludeList"), "")
   423| RETAIL_CONFIG_STRING_INFO(EXTERNAL_ZapRequireList, W("ZapRequireList"), "")
   424| RETAIL_CONFIG_STRING_INFO(EXTERNAL_ZapSet, W("ZapSet"), "")
   425| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ReadyToRun, W("ReadyToRun"), 1, "Enable/disable use of ReadyToRun native code") // On by default for CoreCLR
   426| RETAIL_CONFIG_STRING_INFO(EXTERNAL_ReadyToRunExcludeList, W("ReadyToRunExcludeList"), "List of assemblies that cannot use Ready to Run images")
   427| RETAIL_CONFIG_STRING_INFO(EXTERNAL_ReadyToRunLogFile, W("ReadyToRunLogFile"), "Name of file to log success/failure of using Ready to Run images")
   428| #if defined(FEATURE_EVENT_TRACE) || defined(FEATURE_EVENTSOURCE_XPLAT)
   429| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableEventLog, W("EnableEventLog"), 0, "Enable/disable use of EnableEventLogging mechanism ") // Off by default
   430| RETAIL_CONFIG_STRING_INFO(INTERNAL_EventSourceFilter, W("EventSourceFilter"), "")
   431| RETAIL_CONFIG_STRING_INFO(INTERNAL_EventNameFilter, W("EventNameFilter"), "")
   432| #endif //defined(FEATURE_EVENT_TRACE) || defined(FEATURE_EVENTSOURCE_XPLAT)
   433| CONFIG_DWORD_INFO(INTERNAL_ExposeExceptionsInCOM, W("ExposeExceptionsInCOM"), 0, "")
   434| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_InteropValidatePinnedObjects, W("InteropValidatePinnedObjects"), 0, "After returning from a managed-to-unmanaged interop call, validate GC heap around objects pinned by IL stubs.")
   435| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_InteropLogArguments, W("InteropLogArguments"), 0, "Log all pinned arguments passed to an interop call")
   436| RETAIL_CONFIG_STRING_INFO(UNSUPPORTED_LogCCWRefCountChange, W("LogCCWRefCountChange"), "Outputs debug information and calls LogCCWRefCountChange_BREAKPOINT when AddRef or Release is called on a CCW.")
   437| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EnableRCWCleanupOnSTAShutdown, W("EnableRCWCleanupOnSTAShutdown"), 0, "Performs RCW cleanup when STA shutdown is detected using IInitializeSpy in classic processes.")
   438| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EnableEventPipe, W("EnableEventPipe"), 0, "Enable/disable event pipe.  Non-zero values enable tracing.")
   439| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeNetTraceFormat, W("EventPipeNetTraceFormat"), 1, "Enable/disable using the newer nettrace file format.")
   440| RETAIL_CONFIG_STRING_INFO(INTERNAL_EventPipeOutputPath, W("EventPipeOutputPath"), "The full path excluding file name for the trace file that will be written when COMPlus_EnableEventPipe=1")
   441| RETAIL_CONFIG_STRING_INFO(INTERNAL_EventPipeConfig, W("EventPipeConfig"), "Configuration for EventPipe.")
   442| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeRundown, W("EventPipeRundown"), 1, "Enable/disable eventpipe rundown.")
   443| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeCircularMB, W("EventPipeCircularMB"), 1024, "The EventPipe circular buffer size in megabytes.")
   444| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeProcNumbers, W("EventPipeProcNumbers"), 0, "Enable/disable capturing processor numbers in EventPipe event headers")
   445| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeOutputStreaming, W("EventPipeOutputStreaming"), 0, "Enable/disable streaming for trace file set in COMPlus_EventPipeOutputPath.  Non-zero values enable streaming.")
   446| RETAIL_CONFIG_DWORD_INFO(INTERNAL_GCGenAnalysisGen, W("GCGenAnalysisGen"), 0, "The generation to trigger generational aware analysis")
   447| RETAIL_CONFIG_DWORD_INFO(INTERNAL_GCGenAnalysisBytes, W("GCGenAnalysisBytes"), 0, "The number of bytes to trigger generational aware analysis")
   448| RETAIL_CONFIG_DWORD_INFO(INTERNAL_GCGenAnalysisIndex, W("GCGenAnalysisIndex"), 0, "The gc index to trigger generational aware analysis")
   449| RETAIL_CONFIG_STRING_INFO(INTERNAL_GCGenAnalysisCmd, W("GCGenAnalysisCmd"), "An optional filter to match with the command line used to spawn the process")
   450| RETAIL_CONFIG_DWORD_INFO(INTERNAL_GCGenAnalysisTrace, W("GCGenAnalysisTrace"), 1, "Enable/Disable capturing a trace")
   451| RETAIL_CONFIG_DWORD_INFO(INTERNAL_GCGenAnalysisDump, W("GCGenAnalysisDump"), 0, "Enable/Disable capturing a dump")
   452| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_DOTNET_DefaultDiagnosticPortSuspend, W("DefaultDiagnosticPortSuspend"), 0, "This sets the deafult diagnostic port to suspend causing the runtime to pause during startup before major subsystems are started.  Resume using the Diagnostics IPC ResumeStartup command on the default diagnostic port.");
   453| RETAIL_CONFIG_STRING_INFO(EXTERNAL_DOTNET_DiagnosticPorts, W("DiagnosticPorts"), "A semicolon delimited list of additional Diagnostic Ports, where a Diagnostic Port is a NamedPipe path without '\\\\.\\pipe\\' on Windows or the full path of Unix Domain Socket on Linux/Unix followed by optional tags, e.g., '<path>,connect,nosuspend;<path>'");
   454| RETAIL_CONFIG_STRING_INFO(INTERNAL_LTTngConfig, W("LTTngConfig"), "Configuration for LTTng.")
   455| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_LTTng, W("LTTng"), 1, "If COMPlus_LTTng is set to 0, this will prevent the LTTng library from being loaded at runtime")
   456| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableWriteXorExecute, W("EnableWriteXorExecute"), 0, "Enable W^X for executable memory.");
   457| #ifdef FEATURE_GDBJIT
   458| CONFIG_STRING_INFO(INTERNAL_GDBJitElfDump, W("GDBJitElfDump"), "Dump ELF for specified method")
   459| #ifdef FEATURE_GDBJIT_FRAME
   460| RETAIL_CONFIG_DWORD_INFO(INTERNAL_GDBJitEmitDebugFrame, W("GDBJitEmitDebugFrame"), TRUE, "Enable .debug_frame generation")
   461| #endif
   462| #endif
   463| CONFIG_DWORD_INFO(INTERNAL_ActivatePatchSkip, W("ActivatePatchSkip"), 0, "Allows an assert when ActivatePatchSkip is called")
   464| CONFIG_DWORD_INFO(INTERNAL_AlwaysUseMetadataInterfaceMapLayout, W("AlwaysUseMetadataInterfaceMapLayout"), 0, "Used for debugging generic interface map layout.")
   465| CONFIG_DWORD_INFO(INTERNAL_AssertOnUnneededThis, W("AssertOnUnneededThis"), 0, "While the ConfigDWORD is unnecessary, the contained ASSERT should be kept. This may result in some work tracking down violating MethodDescCallSites.")
   466| CONFIG_DWORD_INFO(INTERNAL_AssertStacktrace, W("AssertStacktrace"), 1, "")
   467| CONFIG_DWORD_INFO(INTERNAL_clearNativeImageStress, W("clearNativeImageStress"), 0, "")
   468| CONFIG_DWORD_INFO(INTERNAL_CPUFamily, W("CPUFamily"), 0xFFFFFFFF, "")
   469| CONFIG_DWORD_INFO(INTERNAL_CPUFeatures, W("CPUFeatures"), 0xFFFFFFFF, "")
   470| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_DisableConfigCache, W("DisableConfigCache"), 0, "Used to disable the \"probabilistic\" config cache, which walks through the appropriate config registry keys on init and probabilistically keeps track of which exist.")
   471| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_DisableStackwalkCache, W("DisableStackwalkCache"), 0, "")
   472| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DoubleArrayToLargeObjectHeap, W("DoubleArrayToLargeObjectHeap"), 0, "Controls double[] placement")
   473| CONFIG_STRING_INFO(INTERNAL_DumpOnClassLoad, W("DumpOnClassLoad"), "Dumps information about loaded class to log.")
   474| CONFIG_DWORD_INFO(INTERNAL_ExpandAllOnLoad, W("ExpandAllOnLoad"), 0, "")
   475| CONFIG_DWORD_INFO(INTERNAL_ForceRelocs, W("ForceRelocs"), 0, "")
   476| CONFIG_DWORD_INFO(INTERNAL_GenerateLongJumpDispatchStubRatio, W("GenerateLongJumpDispatchStubRatio"), 0, "Useful for testing VSD on AMD64")
   477| CONFIG_DWORD_INFO(INTERNAL_HashStack, W("HashStack"), 0, "")
   478| CONFIG_DWORD_INFO(INTERNAL_HostManagerConfig, W("HostManagerConfig"), (DWORD)-1, "")
   479| CONFIG_DWORD_INFO(INTERNAL_HostTestThreadAbort, W("HostTestThreadAbort"), 0, "")
   480| CONFIG_STRING_INFO(INTERNAL_InvokeHalt, W("InvokeHalt"), "Throws an assert when the given method is invoked through reflection.")
   481| CONFIG_DWORD_INFO(INTERNAL_MaxStubUnwindInfoSegmentSize, W("MaxStubUnwindInfoSegmentSize"), 0, "")
   482| CONFIG_DWORD_INFO(INTERNAL_MessageDebugOut, W("MessageDebugOut"), 0, "")
   483| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_NativeImageRequire, W("NativeImageRequire"), 0, "")
   484| CONFIG_DWORD_INFO(INTERNAL_NestedEhOom, W("NestedEhOom"), 0, "")
   485| #define INTERNAL_NoGuiOnAssert_Default 1
   486| RETAIL_CONFIG_DWORD_INFO(INTERNAL_NoGuiOnAssert, W("NoGuiOnAssert"), INTERNAL_NoGuiOnAssert_Default, "")
   487| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_NoProcedureSplitting, W("NoProcedureSplitting"), 0, "")
   488| CONFIG_DWORD_INFO(INTERNAL_NoStringInterning, W("NoStringInterning"), 1, "Disallows string interning. I see no value in it anymore.")
   489| CONFIG_DWORD_INFO(INTERNAL_PauseOnLoad, W("PauseOnLoad"), 0, "Stops in SystemDomain::init. I think it can be removed.")
   490| CONFIG_DWORD_INFO(INTERNAL_PerfAllocsSizeThreshold, W("PerfAllocsSizeThreshold"), 0x3FFFFFFF, "Log facility LF_GCALLOC logs object allocations. This flag controls which ones also log stacktraces. Predates ClrProfiler.")
   491| CONFIG_DWORD_INFO(INTERNAL_PerfNumAllocsThreshold, W("PerfNumAllocsThreshold"), 0x3FFFFFFF, "Log facility LF_GCALLOC logs object allocations. This flag controls which ones also log stacktraces. Predates ClrProfiler.")
   492| CONFIG_STRING_INFO(INTERNAL_PerfTypesToLog, W("PerfTypesToLog"), "Log facility LF_GCALLOC logs object allocations. This flag controls which ones also log stacktraces. Predates ClrProfiler.")
   493| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_Prepopulate1, W("Prepopulate1"), 1, "")
   494| CONFIG_STRING_INFO(INTERNAL_PrestubGC, W("PrestubGC"), "")
   495| CONFIG_STRING_INFO(INTERNAL_PrestubHalt, W("PrestubHalt"), "")
   496| RETAIL_CONFIG_STRING_INFO(EXTERNAL_RestrictedGCStressExe, W("RestrictedGCStressExe"), "")
   497| CONFIG_DWORD_INFO(INTERNAL_ReturnSourceTypeForTesting, W("ReturnSourceTypeForTesting"), 0, "Allows returning the (internal only) source type of an IL to Native mapping for debugging purposes")
   498| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_RSStressLog, W("RSStressLog"), 0, "Allows turning on logging for RS startup")
   499| CONFIG_DWORD_INFO(INTERNAL_SBDumpOnNewIndex, W("SBDumpOnNewIndex"), 0, "Used for Syncblock debugging. It's been a while since any of those have been used.")
   500| CONFIG_DWORD_INFO(INTERNAL_SBDumpOnResize, W("SBDumpOnResize"), 0, "Used for Syncblock debugging. It's been a while since any of those have been used.")
   501| CONFIG_DWORD_INFO(INTERNAL_SBDumpStyle, W("SBDumpStyle"), 0, "Used for Syncblock debugging. It's been a while since any of those have been used.")
   502| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_SleepOnExit, W("SleepOnExit"), 0, "Used for lrak detection. I'd say deprecated by umdh.")
   503| CONFIG_DWORD_INFO(INTERNAL_StubLinkerUnwindInfoVerificationOn, W("StubLinkerUnwindInfoVerificationOn"), 0, "")
   504| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_SuccessExit, W("SuccessExit"), 0, "")
   505| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TestDataConsistency, W("TestDataConsistency"), FALSE, "Allows ensuring the left side is not holding locks (and may thus be in an inconsistent state) when inspection occurs")
   506| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ThreadGuardPages, W("ThreadGuardPages"), 0, "")
   507| #ifdef _DEBUG
   508| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TraceWrap, W("TraceWrap"), 0, "")
   509| #endif
   510| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_UseMethodDataCache, W("UseMethodDataCache"), FALSE, "Used during feature development; may now be removed.")
   511| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_UseParentMethodData, W("UseParentMethodData"), TRUE, "Used during feature development; may now be removed.")
   512| CONFIG_DWORD_INFO(INTERNAL_VerifierOff, W("VerifierOff"), 0, "")


# ====================================================================
# FILE: src/coreclr/vm/perfinfo.cpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-91 ---
     1| #include "common.h"
     2| #if defined(FEATURE_PERFMAP) && !defined(DACCESS_COMPILE)
     3| #include "perfinfo.h"
     4| #include "pal.h"
     5| PerfInfo::PerfInfo(int pid, const char* basePath)
     6|   : m_Stream(nullptr)
     7| {
     8|     LIMITED_METHOD_CONTRACT;
     9|     SString path;
    10|     path.Printf("%s/perfinfo-%d.map", basePath, pid);
    11|     OpenFile(path);
    12| }
    13| void PerfInfo::LogImage(PEFile* pFile, WCHAR* guid)
    14| {
    15|     CONTRACTL
    16|     {
    17|         THROWS;
    18|         GC_NOTRIGGER;
    19|         MODE_PREEMPTIVE;
    20|         PRECONDITION(pFile != nullptr);
    21|         PRECONDITION(guid != nullptr);
    22|     } CONTRACTL_END;
    23|     SString value;
    24|     const SString& path = pFile->GetPath();
    25|     if (path.IsEmpty())
    26|     {
    27|         return;
    28|     }
    29|     SIZE_T baseAddr = 0;
    30|     if (pFile->IsILImageReadyToRun())
    31|     {
    32|         PEImageLayout *pLoadedLayout = pFile->GetLoaded();
    33|         if (pLoadedLayout)
    34|         {
    35|             baseAddr = (SIZE_T)pLoadedLayout->GetBase();
    36|         }
    37|     }
    38|     value.Printf("%S%c%S%c%p", path.GetUnicode(), sDelimiter, guid, sDelimiter, baseAddr);
    39|     SString command;
    40|     command.Printf("%s", "ImageLoad");
    41|     WriteLine(command, value);
    42| }
    43| void PerfInfo::WriteLine(SString& type, SString& value)
    44| {
    45|     CONTRACTL
    46|     {
    47|         THROWS;
    48|         GC_NOTRIGGER;
    49|         MODE_PREEMPTIVE;
    50|     } CONTRACTL_END;
    51|     if (m_Stream == nullptr)
    52|     {
    53|         return;
    54|     }
    55|     SString line;
    56|     line.Printf("%S%c%S%c\n",
    57|             type.GetUnicode(), sDelimiter, value.GetUnicode(), sDelimiter);
    58|     EX_TRY
    59|     {
    60|         StackScratchBuffer scratch;
    61|         const char* strLine = line.GetANSI(scratch);
    62|         ULONG inCount = line.GetCount();
    63|         ULONG outCount;
    64|         m_Stream->Write(strLine, inCount, &outCount);
    65|         if (inCount != outCount)
    66|         {
    67|         }
    68|     }
    69|     EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
    70| }
    71| void PerfInfo::OpenFile(SString& path)
    72| {
    73|     STANDARD_VM_CONTRACT;
    74|     m_Stream = new (nothrow) CFileStream();
    75|     if (m_Stream != nullptr)
    76|     {
    77|         HRESULT hr = m_Stream->OpenForWrite(path.GetUnicode());
    78|         if (FAILED(hr))
    79|         {
    80|             delete m_Stream;
    81|             m_Stream = nullptr;
    82|         }
    83|     }
    84| }
    85| PerfInfo::~PerfInfo()
    86| {
    87|     LIMITED_METHOD_CONTRACT;
    88|     delete m_Stream;
    89|     m_Stream = nullptr;
    90| }
    91| #endif


# ====================================================================
# FILE: src/coreclr/vm/perfinfo.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-23 ---
     1| #ifndef PERFINFO_H
     2| #define PERFINFO_H
     3| #include "sstring.h"
     4| #include "fstream.h"
     5| /*
     6|    A perfinfo-%d.map is created for every process that is created with manage code, the %d
     7|    being repaced with the process ID.
     8|    Every line in the perfinfo-%d.map is a type and value, separated by sDelimiter character: type;value
     9|    type represents what the user might want to do with its given value. value has a format chosen by
    10|    the user for parsing later on.
    11| */
    12| class PerfInfo {
    13| public:
    14|     PerfInfo(int pid, const char* basePath);
    15|     ~PerfInfo();
    16|     void LogImage(PEFile* pFile, WCHAR* guid);
    17| private:
    18|     CFileStream* m_Stream;
    19|     const char sDelimiter = ';';
    20|     void OpenFile(SString& path);
    21|     void WriteLine(SString& type, SString& value);
    22| };
    23| #endif


# ====================================================================
# FILE: src/coreclr/vm/perfmap.cpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-387 ---
     1| #include "common.h"
     2| #if defined(FEATURE_PERFMAP) && !defined(DACCESS_COMPILE)
     3| #include "perfmap.h"
     4| #include "perfinfo.h"
     5| #include "pal.h"
     6| #ifdef CROSSGEN_COMPILE
     7| #define FMT_CODE_ADDR "%08x"
     8| #else
     9| #define FMT_CODE_ADDR "%p"
    10| #endif
    11| #ifndef __ANDROID__
    12| #define TEMP_DIRECTORY_PATH "/tmp"
    13| #else
    14| #define TEMP_DIRECTORY_PATH "/data/local/tmp"
    15| #endif
    16| Volatile<bool> PerfMap::s_enabled = false;
    17| PerfMap * PerfMap::s_Current = nullptr;
    18| bool PerfMap::s_ShowOptimizationTiers = false;
    19| unsigned PerfMap::s_StubsMapped = 0;
    20| enum 
    21| {
    22|     DISABLED,
    23|     ALL,
    24|     JITDUMP,
    25|     PERFMAP
    26| };
    27| void PerfMap::Initialize()
    28| {
    29|     LIMITED_METHOD_CONTRACT;
    30|     const DWORD perfMapEnabled = CLRConfig::GetConfigValue(CLRConfig::EXTERNAL_PerfMapEnabled);
    31|     if (perfMapEnabled == DISABLED)
    32|     {
    33|         return;
    34|     }
    35|     char tempPathBuffer[MAX_LONGPATH+1];
    36|     const char* tempPath = InternalConstructPath(tempPathBuffer, sizeof(tempPathBuffer));
    37|     if (perfMapEnabled == ALL || perfMapEnabled == PERFMAP)
    38|     {
    39|         int currentPid = GetCurrentProcessId();
    40|         s_Current = new PerfMap(currentPid, tempPath);
    41|         int signalNum = (int) CLRConfig::GetConfigValue(CLRConfig::EXTERNAL_PerfMapIgnoreSignal);
    42|         if (signalNum > 0)
    43|         {
    44|             PAL_IgnoreProfileSignal(signalNum);
    45|         }
    46|     }
    47|     if (perfMapEnabled == ALL || perfMapEnabled == JITDUMP)
    48|     {
    49|         PAL_PerfJitDump_Start(tempPath);
    50|     }
    51|     if (CLRConfig::GetConfigValue(CLRConfig::EXTERNAL_PerfMapShowOptimizationTiers) != 0)
    52|     {
    53|         s_ShowOptimizationTiers = true;
    54|     }
    55|     s_enabled = true;
    56| }
    57| const char * PerfMap::InternalConstructPath(char *tmpBuf, int lenBuf)
    58| {
    59|     DWORD len = GetEnvironmentVariableA("DOTNET_PerfMapJitDumpPath", tmpBuf, lenBuf);
    60|     if (len == 0)
    61|     {
    62|         len = GetEnvironmentVariableA("COMPlus_PerfMapJitDumpPath", tmpBuf, lenBuf);
    63|     }
    64|     if (len == 0 || // GetEnvironmentVariableA returns 0 if the variable is not found, 
    65|         len >= lenBuf) // or the length of the string not including the null terminator on success.
    66|     {
    67|         return TEMP_DIRECTORY_PATH;
    68|     }
    69|     return tmpBuf;
    70| }
    71| void PerfMap::Destroy()
    72| {
    73|     LIMITED_METHOD_CONTRACT;
    74|     if (s_enabled)
    75|     {
    76|         s_enabled = false;
    77|         PAL_PerfJitDump_Finish();
    78|     }
    79| }
    80| PerfMap::PerfMap(int pid, const char* path)
    81| {
    82|     LIMITED_METHOD_CONTRACT;
    83|     m_ErrorEncountered = false;
    84|     SString pathFile;
    85|     pathFile.Printf("%s/perf-%d.map", path, pid);
    86|     OpenFile(pathFile);
    87|     m_PerfInfo = new PerfInfo(pid, path);
    88| }
    89| PerfMap::PerfMap()
    90|   : m_FileStream(nullptr)
    91|   , m_PerfInfo(nullptr)
    92| {
    93|     LIMITED_METHOD_CONTRACT;
    94|     m_ErrorEncountered = false;
    95| }
    96| PerfMap::~PerfMap()
    97| {
    98|     LIMITED_METHOD_CONTRACT;
    99|     delete m_FileStream;
   100|     m_FileStream = nullptr;
   101|     delete m_PerfInfo;
   102|     m_PerfInfo = nullptr;
   103| }
   104| void PerfMap::OpenFile(SString& path)
   105| {
   106|     STANDARD_VM_CONTRACT;
   107|     m_FileStream = new (nothrow) CFileStream();
   108|     if(m_FileStream != nullptr)
   109|     {
   110|         HRESULT hr = m_FileStream->OpenForWrite(path.GetUnicode());
   111|         if(FAILED(hr))
   112|         {
   113|             delete m_FileStream;
   114|             m_FileStream = nullptr;
   115|         }
   116|     }
   117| }
   118| void PerfMap::WriteLine(SString& line)
   119| {
   120|     STANDARD_VM_CONTRACT;
   121|     if (m_FileStream == nullptr || m_ErrorEncountered)
   122|     {
   123|         return;
   124|     }
   125|     EX_TRY
   126|     {
   127|         StackScratchBuffer scratch;
   128|         const char * strLine = line.GetANSI(scratch);
   129|         ULONG inCount = line.GetCount();
   130|         ULONG outCount;
   131|         m_FileStream->Write(strLine, inCount, &outCount);
   132|         if (inCount != outCount)
   133|         {
   134|             m_ErrorEncountered = true;
   135|         }
   136|     }
   137|     EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
   138| }
   139| void PerfMap::LogImageLoad(PEFile *pFile)
   140| {
   141|     if (s_enabled && s_Current != nullptr)
   142|     {
   143|         s_Current->LogImage(pFile);
   144|     }
   145| }
   146| void PerfMap::LogImage(PEFile * pFile)
   147| {
   148|     CONTRACTL{
   149|         THROWS;
   150|         GC_NOTRIGGER;
   151|         MODE_PREEMPTIVE;
   152|         PRECONDITION(pFile != nullptr);
   153|     } CONTRACTL_END;
   154|     if (m_FileStream == nullptr || m_ErrorEncountered)
   155|     {
   156|         return;
   157|     }
   158|     EX_TRY
   159|     {
   160|         WCHAR wszSignature[39];
   161|         GetNativeImageSignature(pFile, wszSignature, lengthof(wszSignature));
   162|         m_PerfInfo->LogImage(pFile, wszSignature);
   163|     }
   164|     EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
   165| }
   166| void PerfMap::LogJITCompiledMethod(MethodDesc * pMethod, PCODE pCode, size_t codeSize, PrepareCodeConfig *pConfig)
   167| {
   168|     LIMITED_METHOD_CONTRACT;
   169|     CONTRACTL{
   170|         THROWS;
   171|         GC_NOTRIGGER;
   172|         MODE_PREEMPTIVE;
   173|         PRECONDITION(pMethod != nullptr);
   174|         PRECONDITION(pCode != nullptr);
   175|         PRECONDITION(codeSize > 0);
   176|     } CONTRACTL_END;
   177|     if (!s_enabled)
   178|     {
   179|         return;
   180|     }
   181|     const char *optimizationTier = nullptr;
   182| #ifndef CROSSGEN_COMPILE
   183|     if (s_ShowOptimizationTiers)
   184|     {
   185|         optimizationTier = PrepareCodeConfig::GetJitOptimizationTierStr(pConfig, pMethod);
   186|     }
   187| #endif // CROSSGEN_COMPILE
   188|     EX_TRY
   189|     {
   190|         SString name;
   191|         pMethod->GetFullMethodInfo(name);
   192|         if (optimizationTier != nullptr && s_ShowOptimizationTiers)
   193|         {
   194|             name.AppendPrintf("[%s]", optimizationTier);
   195|         }
   196|         StackScratchBuffer scratch;
   197|         SString line;
   198|         line.Printf(FMT_CODE_ADDR " %x %s\n", pCode, codeSize, name.GetANSI(scratch));
   199|         if(s_Current != nullptr)
   200|         {
   201|             s_Current->WriteLine(line);
   202|         }
   203|         PAL_PerfJitDump_LogMethod((void*)pCode, codeSize, name.GetANSI(scratch), nullptr, nullptr);
   204|     }
   205|     EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
   206| }
   207| void PerfMap::LogPreCompiledMethod(MethodDesc * pMethod, PCODE pCode)
   208| {
   209|     LIMITED_METHOD_CONTRACT;
   210|     if (!s_enabled)
   211|     {
   212|         return;
   213|     }
   214|     EECodeInfo codeInfo(pCode);
   215|     _ASSERTE(codeInfo.IsValid());
   216|     IJitManager::MethodRegionInfo methodRegionInfo;
   217|     codeInfo.GetMethodRegionInfo(&methodRegionInfo);
   218|     EX_TRY
   219|     {
   220|         SString name;
   221|         pMethod->GetFullMethodInfo(name);
   222|         StackScratchBuffer scratch;
   223|         if (s_ShowOptimizationTiers)
   224|         {
   225|             name.AppendPrintf(W("[PreJIT]"));
   226|         }
   227|         if (methodRegionInfo.hotSize > 0)
   228|         {
   229|             PAL_PerfJitDump_LogMethod((void*)methodRegionInfo.hotStartAddress, methodRegionInfo.hotSize, name.GetANSI(scratch), nullptr, nullptr);
   230|         }
   231|         if (methodRegionInfo.coldSize > 0)
   232|         {
   233|             if (s_ShowOptimizationTiers)
   234|             {
   235|                 pMethod->GetFullMethodInfo(name);
   236|                 name.AppendPrintf(W("[PreJit-cold]"));
   237|             }
   238|             PAL_PerfJitDump_LogMethod((void*)methodRegionInfo.coldStartAddress, methodRegionInfo.coldSize, name.GetANSI(scratch), nullptr, nullptr);
   239|         }
   240|     }
   241|     EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
   242| }
   243| void PerfMap::LogStubs(const char* stubType, const char* stubOwner, PCODE pCode, size_t codeSize)
   244| {
   245|     LIMITED_METHOD_CONTRACT;
   246|     if (!s_enabled)
   247|     {
   248|         return;
   249|     }
   250|     EX_TRY
   251|     {
   252|         if(!stubOwner)
   253|         {
   254|             stubOwner = "?";
   255|         }
   256|         if(!stubType)
   257|         {
   258|             stubType = "?";
   259|         }
   260|         StackScratchBuffer scratch;
   261|         SString name;
   262|         name.Printf("stub<%d> %s<%s>", ++(s_StubsMapped), stubType, stubOwner);
   263|         SString line;
   264|         line.Printf(FMT_CODE_ADDR " %x %s\n", pCode, codeSize, name.GetANSI(scratch));
   265|         if(s_Current != nullptr)
   266|         {
   267|             s_Current->WriteLine(line);
   268|         }
   269|         PAL_PerfJitDump_LogMethod((void*)pCode, codeSize, name.GetANSI(scratch), nullptr, nullptr);
   270|     }
   271|     EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
   272| }
   273| void PerfMap::GetNativeImageSignature(PEFile * pFile, WCHAR * pwszSig, unsigned int nSigSize)
   274| {
   275|     CONTRACTL{
   276|         PRECONDITION(pFile != nullptr);
   277|         PRECONDITION(pwszSig != nullptr);
   278|         PRECONDITION(nSigSize >= 39);
   279|     } CONTRACTL_END;
   280|     GUID mvid;
   281|     pFile->GetMVID(&mvid);
   282|     if(!StringFromGUID2(mvid, pwszSig, nSigSize))
   283|     {
   284|         pwszSig[0] = '\0';
   285|     }
   286| }
   287| NativeImagePerfMap::NativeImagePerfMap(Assembly * pAssembly, BSTR pDestPath)
   288|   : PerfMap()
   289| {
   290|     STANDARD_VM_CONTRACT;
   291|     LPCUTF8 lpcSimpleName = pAssembly->GetSimpleName();
   292|     WCHAR wszSignature[39];
   293|     GetNativeImageSignature(pAssembly->GetManifestFile(), wszSignature, lengthof(wszSignature));
   294|     SString sDestPerfMapPath;
   295|     sDestPerfMapPath.Printf("%S%s.ni.%S.map", pDestPath, lpcSimpleName, wszSignature);
   296|     OpenFile(sDestPerfMapPath);
   297|     m_EmitRVAs = true;
   298|     CLRConfigStringHolder wszFormat(CLRConfig::GetConfigValue(CLRConfig::EXTERNAL_NativeImagePerfMapFormat));
   299|     if(wszFormat != NULL && (wcsncmp(wszFormat, strOFFSET, wcslen(strOFFSET)) == 0))
   300|     {
   301|         m_EmitRVAs = false;
   302|     }
   303| }
   304| void NativeImagePerfMap::LogMethod(MethodDesc * pMethod, PCODE pCode, size_t codeSize, const char *optimizationTier)
   305| {
   306|     CONTRACTL{
   307|         THROWS;
   308|         GC_NOTRIGGER;
   309|         MODE_PREEMPTIVE;
   310|         PRECONDITION(pMethod != nullptr);
   311|         PRECONDITION(pCode != nullptr);
   312|         PRECONDITION(codeSize > 0);
   313|     } CONTRACTL_END;
   314|     EX_TRY
   315|     {
   316|         SString name;
   317|         pMethod->GetFullMethodInfo(name);
   318|         StackScratchBuffer scratch;
   319|         if (optimizationTier != nullptr && s_ShowOptimizationTiers)
   320|         {
   321|             name.AppendPrintf("[%s]", optimizationTier);
   322|         }
   323|         SString line;
   324|         line.Printf(FMT_CODE_ADDR " %x %s\n", pCode, codeSize, name.GetANSI(scratch));
   325|         if (s_Current != nullptr)
   326|         {
   327|             s_Current->WriteLine(line);
   328|         }
   329|         PAL_PerfJitDump_LogMethod((void*)pCode, codeSize, name.GetANSI(scratch), nullptr, nullptr);
   330|     }
   331|     EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
   332| }
   333| void NativeImagePerfMap::LogDataForModule(Module * pModule)
   334| {
   335|     STANDARD_VM_CONTRACT;
   336|     PEImageLayout * pLoadedLayout = pModule->GetFile()->GetLoaded();
   337|     _ASSERTE(pLoadedLayout != nullptr);
   338| #ifdef FEATURE_PREJIT
   339|     if (!pLoadedLayout->HasReadyToRunHeader())
   340|     {
   341|         MethodIterator mi((PTR_Module)pModule);
   342|         while (mi.Next())
   343|         {
   344|             MethodDesc *hotDesc = mi.GetMethodDesc();
   345|             hotDesc->CheckRestore();
   346|             LogPreCompiledMethod(hotDesc, mi.GetMethodStartAddress(), pLoadedLayout, nullptr);
   347|         }
   348|         return;
   349|     }
   350| #endif
   351|     ReadyToRunInfo::MethodIterator mi(pModule->GetReadyToRunInfo());
   352|     while (mi.Next())
   353|     {
   354|         MethodDesc* hotDesc = mi.GetMethodDesc();
   355|         LogPreCompiledMethod(hotDesc, mi.GetMethodStartAddress(), pLoadedLayout, "ReadyToRun");
   356|     }
   357| }
   358| void NativeImagePerfMap::LogPreCompiledMethod(MethodDesc * pMethod, PCODE pCode, PEImageLayout *pLoadedLayout, const char *optimizationTier)
   359| {
   360|     STANDARD_VM_CONTRACT;
   361|     _ASSERTE(pLoadedLayout != nullptr);
   362|     SIZE_T baseAddr = (SIZE_T)pLoadedLayout->GetBase();
   363|     EECodeInfo codeInfo(pCode);
   364|     _ASSERTE(codeInfo.IsValid());
   365|     IJitManager::MethodRegionInfo methodRegionInfo;
   366|     codeInfo.GetMethodRegionInfo(&methodRegionInfo);
   367|     PCODE addr;
   368|     if (methodRegionInfo.hotSize > 0)
   369|     {
   370|         addr = (PCODE)methodRegionInfo.hotStartAddress - baseAddr;
   371|         if (!m_EmitRVAs)
   372|         {
   373|             addr = pLoadedLayout->RvaToOffset(addr);
   374|         }
   375|         LogMethod(pMethod, addr, methodRegionInfo.hotSize, optimizationTier);
   376|     }
   377|     if (methodRegionInfo.coldSize > 0)
   378|     {
   379|         addr = (PCODE)methodRegionInfo.coldStartAddress - baseAddr;
   380|         if (!m_EmitRVAs)
   381|         {
   382|             addr = pLoadedLayout->RvaToOffset(addr);
   383|         }
   384|         LogMethod(pMethod, addr, methodRegionInfo.coldSize, optimizationTier);
   385|     }
   386| }
   387| #endif // FEATURE_PERFMAP && !DACCESS_COMPILE


# ====================================================================
# FILE: src/coreclr/vm/perfmap.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-45 ---
     1| #ifndef PERFPID_H
     2| #define PERFPID_H
     3| #include "sstring.h"
     4| #include "fstream.h"
     5| #include "volatile.h"
     6| class PerfInfo;
     7| class PerfMap
     8| {
     9| private:
    10|     static Volatile<bool> s_enabled;
    11|     static unsigned s_StubsMapped;
    12|     CFileStream * m_FileStream;
    13|     PerfInfo* m_PerfInfo;
    14|     bool m_ErrorEncountered;
    15|     PerfMap(int pid, const char* path);
    16|     static const char* InternalConstructPath(char *tmpBuf, int lenBuf);
    17| protected:
    18|     static bool s_ShowOptimizationTiers;
    19|     static PerfMap * s_Current;
    20|     PerfMap();
    21|     ~PerfMap();
    22|     void OpenFile(SString& path);
    23|     void LogImage(PEFile * pFile);
    24|     static void GetNativeImageSignature(PEFile * pFile, WCHAR * pwszSig, unsigned int nSigSize);
    25| public:
    26|     void WriteLine(SString & line);
    27|     static void Initialize();
    28|     static void LogImageLoad(PEFile * pFile);
    29|     static void LogJITCompiledMethod(MethodDesc * pMethod, PCODE pCode, size_t codeSize, PrepareCodeConfig *pConfig);
    30|     static void LogPreCompiledMethod(MethodDesc * pMethod, PCODE pCode);
    31|     static void LogStubs(const char* stubType, const char* stubOwner, PCODE pCode, size_t codeSize);
    32|     static void Destroy();
    33| };
    34| class NativeImagePerfMap : PerfMap
    35| {
    36| private:
    37|     const WCHAR *strOFFSET = W("OFFSET");
    38|     bool m_EmitRVAs;
    39|     void LogMethod(MethodDesc * pMethod, PCODE pCode, size_t codeSize, const char *optimizationTier);
    40|     void LogPreCompiledMethod(MethodDesc * pMethod, PCODE pCode, PEImageLayout *pLoadedLayout, const char *optimizationTier);
    41| public:
    42|     NativeImagePerfMap(Assembly * pAssembly, BSTR pDestPath);
    43|     void LogDataForModule(Module * pModule);
    44| };
    45| #endif // PERFPID_H


# ====================================================================
# FILE: src/libraries/System.Net.Quic/src/System/Net/Quic/Implementations/MsQuic/Internal/MsQuicApi.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-192 ---
     1| using System.Diagnostics;
     2| using System.Diagnostics.CodeAnalysis;
     3| using System.Runtime.InteropServices;
     4| using static System.Net.Quic.Implementations.MsQuic.Internal.MsQuicNativeMethods;
     5| namespace System.Net.Quic.Implementations.MsQuic.Internal
     6| {
     7|     internal unsafe sealed class MsQuicApi
     8|     {
     9|         private static readonly Version MinWindowsVersion = new Version(10, 0, 20145, 1000);
    10|         public SafeMsQuicRegistrationHandle Registration { get; }
    11|         [DynamicDependency(DynamicallyAccessedMemberTypes.PublicConstructors, typeof(SafeMsQuicRegistrationHandle))]
    12|         [DynamicDependency(DynamicallyAccessedMemberTypes.PublicConstructors, typeof(SafeMsQuicConfigurationHandle))]
    13|         [DynamicDependency(DynamicallyAccessedMemberTypes.PublicConstructors, typeof(SafeMsQuicListenerHandle))]
    14|         [DynamicDependency(DynamicallyAccessedMemberTypes.PublicConstructors, typeof(SafeMsQuicConnectionHandle))]
    15|         [DynamicDependency(DynamicallyAccessedMemberTypes.PublicConstructors, typeof(SafeMsQuicStreamHandle))]
    16|         private MsQuicApi(NativeApi* vtable)
    17|         {
    18|             uint status;
    19|             SetParamDelegate =
    20|                 Marshal.GetDelegateForFunctionPointer<SetParamDelegate>(
    21|                     vtable->SetParam);
    22|             GetParamDelegate =
    23|                 Marshal.GetDelegateForFunctionPointer<GetParamDelegate>(
    24|                     vtable->GetParam);
    25|             SetCallbackHandlerDelegate =
    26|                 Marshal.GetDelegateForFunctionPointer<SetCallbackHandlerDelegate>(
    27|                     vtable->SetCallbackHandler);
    28|             RegistrationOpenDelegate =
    29|                 Marshal.GetDelegateForFunctionPointer<RegistrationOpenDelegate>(
    30|                     vtable->RegistrationOpen);
    31|             RegistrationCloseDelegate =
    32|                 Marshal.GetDelegateForFunctionPointer<RegistrationCloseDelegate>(
    33|                     vtable->RegistrationClose);
    34|             ConfigurationOpenDelegate =
    35|                 Marshal.GetDelegateForFunctionPointer<ConfigurationOpenDelegate>(
    36|                     vtable->ConfigurationOpen);
    37|             ConfigurationCloseDelegate =
    38|                 Marshal.GetDelegateForFunctionPointer<ConfigurationCloseDelegate>(
    39|                     vtable->ConfigurationClose);
    40|             ConfigurationLoadCredentialDelegate =
    41|                 Marshal.GetDelegateForFunctionPointer<ConfigurationLoadCredentialDelegate>(
    42|                     vtable->ConfigurationLoadCredential);
    43|             ListenerOpenDelegate =
    44|                 Marshal.GetDelegateForFunctionPointer<ListenerOpenDelegate>(
    45|                     vtable->ListenerOpen);
    46|             ListenerCloseDelegate =
    47|                 Marshal.GetDelegateForFunctionPointer<ListenerCloseDelegate>(
    48|                     vtable->ListenerClose);
    49|             ListenerStartDelegate =
    50|                 Marshal.GetDelegateForFunctionPointer<ListenerStartDelegate>(
    51|                     vtable->ListenerStart);
    52|             ListenerStopDelegate =
    53|                 Marshal.GetDelegateForFunctionPointer<ListenerStopDelegate>(
    54|                     vtable->ListenerStop);
    55|             ConnectionOpenDelegate =
    56|                 Marshal.GetDelegateForFunctionPointer<ConnectionOpenDelegate>(
    57|                     vtable->ConnectionOpen);
    58|             ConnectionCloseDelegate =
    59|                 Marshal.GetDelegateForFunctionPointer<ConnectionCloseDelegate>(
    60|                     vtable->ConnectionClose);
    61|             ConnectionSetConfigurationDelegate =
    62|                 Marshal.GetDelegateForFunctionPointer<ConnectionSetConfigurationDelegate>(
    63|                     vtable->ConnectionSetConfiguration);
    64|             ConnectionShutdownDelegate =
    65|                 Marshal.GetDelegateForFunctionPointer<ConnectionShutdownDelegate>(
    66|                     vtable->ConnectionShutdown);
    67|             ConnectionStartDelegate =
    68|                 Marshal.GetDelegateForFunctionPointer<ConnectionStartDelegate>(
    69|                     vtable->ConnectionStart);
    70|             StreamOpenDelegate =
    71|                 Marshal.GetDelegateForFunctionPointer<StreamOpenDelegate>(
    72|                     vtable->StreamOpen);
    73|             StreamCloseDelegate =
    74|                 Marshal.GetDelegateForFunctionPointer<StreamCloseDelegate>(
    75|                     vtable->StreamClose);
    76|             StreamStartDelegate =
    77|                 Marshal.GetDelegateForFunctionPointer<StreamStartDelegate>(
    78|                     vtable->StreamStart);
    79|             StreamShutdownDelegate =
    80|                 Marshal.GetDelegateForFunctionPointer<StreamShutdownDelegate>(
    81|                     vtable->StreamShutdown);
    82|             StreamSendDelegate =
    83|                 Marshal.GetDelegateForFunctionPointer<StreamSendDelegate>(
    84|                     vtable->StreamSend);
    85|             StreamReceiveCompleteDelegate =
    86|                 Marshal.GetDelegateForFunctionPointer<StreamReceiveCompleteDelegate>(
    87|                     vtable->StreamReceiveComplete);
    88|             StreamReceiveSetEnabledDelegate =
    89|                 Marshal.GetDelegateForFunctionPointer<StreamReceiveSetEnabledDelegate>(
    90|                     vtable->StreamReceiveSetEnabled);
    91|             var cfg = new RegistrationConfig
    92|             {
    93|                 AppName = ".NET",
    94|                 ExecutionProfile = QUIC_EXECUTION_PROFILE.QUIC_EXECUTION_PROFILE_LOW_LATENCY
    95|             };
    96|             status = RegistrationOpenDelegate(ref cfg, out SafeMsQuicRegistrationHandle handle);
    97|             QuicExceptionHelpers.ThrowIfFailed(status, "RegistrationOpen failed.");
    98|             Registration = handle;
    99|         }
   100|         private static readonly delegate* unmanaged[Cdecl]<uint, NativeApi**, uint> MsQuicOpenVersion;
   101|         private static readonly delegate* unmanaged[Cdecl]<NativeApi*, void> MsQuicClose;
   102|         private static readonly Lazy<MsQuicApi> s_api = new Lazy<MsQuicApi>(AllocateMsQuicApi);
   103|         internal static MsQuicApi Api => s_api.Value;
   104|         internal static bool IsQuicSupported { get; }
   105|         private const int MsQuicVersion = 1;
   106| #pragma warning disable CA1810 // Initialize all static fields in 'MsQuicApi' when those fields are declared and remove the explicit static constructor
   107|         static MsQuicApi()
   108|         {
   109|             IsQuicSupported = false;
   110|             if (NetEventSource.Log.IsEnabled())
   111|             {
   112|                 NetEventSource.Info(null, $"QUIC is completely disabled in .NET 6 due to critical defects fixed in later versions.");
   113|             }
   114|             return;
   115| #pragma warning disable CS0162 // Unreachable code detected -- leaving the original code intact, instead of removing big chunks of code transitively
   116|             if (OperatingSystem.IsWindows() && !IsWindowsVersionSupported())
   117|             {
   118|                 if (NetEventSource.Log.IsEnabled())
   119|                 {
   120|                     NetEventSource.Info(null, $"Current Windows version ({Environment.OSVersion}) is not supported by QUIC. Minimal supported version is {MinWindowsVersion}");
   121|                 }
   122|                 return;
   123|             }
   124|             DllImportSearchPath? searchPath = OperatingSystem.IsWindows() ? DllImportSearchPath.AssemblyDirectory : null;
   125|             if (!NativeLibrary.TryLoad(Interop.Libraries.MsQuic, typeof(MsQuicApi).Assembly, searchPath, out IntPtr msQuicHandle))
   126|             {
   127|                 return;
   128|             }
   129|             MsQuicOpenVersion = (delegate* unmanaged[Cdecl]<uint, NativeApi**, uint>)NativeLibrary.GetExport(msQuicHandle, nameof(MsQuicOpenVersion));
   130|             MsQuicClose = (delegate* unmanaged[Cdecl]<NativeApi*, void>)NativeLibrary.GetExport(msQuicHandle, nameof(MsQuicClose));
   131|             if (!TryOpenMsQuic(out NativeApi* apiTable, out _))
   132|             {
   133|                 return;
   134|             }
   135|             IsQuicSupported = true;
   136|             MsQuicClose(apiTable);
   137|         }
   138| #pragma warning restore CA1810, CS0162
   139|         private static MsQuicApi AllocateMsQuicApi()
   140|         {
   141|             Debug.Assert(IsQuicSupported);
   142|             if (!TryOpenMsQuic(out NativeApi* apiTable, out uint openStatus))
   143|             {
   144|                 QuicExceptionHelpers.ThrowIfFailed(openStatus);
   145|             }
   146|             return new MsQuicApi(apiTable);
   147|         }
   148|         private static bool TryOpenMsQuic(out NativeApi* apiTable, out uint openStatus)
   149|         {
   150|             Debug.Assert(MsQuicOpenVersion != null);
   151|             NativeApi* table = null;
   152|             openStatus = MsQuicOpenVersion((uint)MsQuicVersion, &table);
   153|             if (!MsQuicStatusHelper.SuccessfulStatusCode(openStatus))
   154|             {
   155|                 if (NetEventSource.Log.IsEnabled())
   156|                 {
   157|                     NetEventSource.Info(null, $"MsQuicOpenVersion(version: {MsQuicVersion}) returned {MsQuicStatusCodes.GetError(openStatus)} status code.");
   158|                 }
   159|                 apiTable = null;
   160|                 return false;
   161|             }
   162|             apiTable = table;
   163|             return true;
   164|         }
   165|         private static bool IsWindowsVersionSupported() => OperatingSystem.IsWindowsVersionAtLeast(MinWindowsVersion.Major,
   166|             MinWindowsVersion.Minor, MinWindowsVersion.Build, MinWindowsVersion.Revision);
   167|         internal RegistrationOpenDelegate RegistrationOpenDelegate { get; }
   168|         internal RegistrationCloseDelegate RegistrationCloseDelegate { get; }
   169|         internal ConfigurationOpenDelegate ConfigurationOpenDelegate { get; }
   170|         internal ConfigurationCloseDelegate ConfigurationCloseDelegate { get; }
   171|         internal ConfigurationLoadCredentialDelegate ConfigurationLoadCredentialDelegate { get; }
   172|         internal ListenerOpenDelegate ListenerOpenDelegate { get; }
   173|         internal ListenerCloseDelegate ListenerCloseDelegate { get; }
   174|         internal ListenerStartDelegate ListenerStartDelegate { get; }
   175|         internal ListenerStopDelegate ListenerStopDelegate { get; }
   176|         internal ConnectionOpenDelegate ConnectionOpenDelegate { get; }
   177|         internal ConnectionCloseDelegate ConnectionCloseDelegate { get; }
   178|         internal ConnectionShutdownDelegate ConnectionShutdownDelegate { get; }
   179|         internal ConnectionStartDelegate ConnectionStartDelegate { get; }
   180|         internal ConnectionSetConfigurationDelegate ConnectionSetConfigurationDelegate { get; }
   181|         internal StreamOpenDelegate StreamOpenDelegate { get; }
   182|         internal StreamCloseDelegate StreamCloseDelegate { get; }
   183|         internal StreamStartDelegate StreamStartDelegate { get; }
   184|         internal StreamShutdownDelegate StreamShutdownDelegate { get; }
   185|         internal StreamSendDelegate StreamSendDelegate { get; }
   186|         internal StreamReceiveCompleteDelegate StreamReceiveCompleteDelegate { get; }
   187|         internal StreamReceiveSetEnabledDelegate StreamReceiveSetEnabledDelegate { get; }
   188|         internal SetCallbackHandlerDelegate SetCallbackHandlerDelegate { get; }
   189|         internal SetParamDelegate SetParamDelegate { get; }
   190|         internal GetParamDelegate GetParamDelegate { get; }
   191|     }
   192| }


# ====================================================================
# FILE: src/libraries/System.Security.Cryptography.X509Certificates/src/Internal/Cryptography/Pal.Unix/CertificateAssetDownloader.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-251 ---
     1| using System;
     2| using System.Diagnostics;
     3| using System.Diagnostics.CodeAnalysis;
     4| using System.IO;
     5| using System.Reflection;
     6| using System.Security.Cryptography;
     7| using System.Security.Cryptography.X509Certificates;
     8| using System.Threading;
     9| using Microsoft.Win32.SafeHandles;
    10| namespace Internal.Cryptography.Pal
    11| {
    12|     internal static class CertificateAssetDownloader
    13|     {
    14|         private const long DefaultAiaDownloadLimit = 100 * 1024 * 1024;
    15|         private static long AiaDownloadLimit { get; } = GetValue("System.Security.Cryptography.AiaDownloadLimit", DefaultAiaDownloadLimit);
    16|         private static readonly Func<string, CancellationToken, byte[]?>? s_downloadBytes = CreateDownloadBytesFunc();
    17|         internal static X509Certificate2? DownloadCertificate(string uri, TimeSpan downloadTimeout)
    18|         {
    19|             byte[]? data = DownloadAsset(uri, downloadTimeout);
    20|             if (data == null || data.Length == 0)
    21|             {
    22|                 return null;
    23|             }
    24|             try
    25|             {
    26|                 X509ContentType contentType = X509Certificate2.GetCertContentType(data);
    27|                 switch (contentType)
    28|                 {
    29|                     case X509ContentType.Cert:
    30|                     case X509ContentType.Pkcs7:
    31|                         break;
    32|                     default:
    33|                         return null;
    34|                 }
    35|                 X509Certificate2 certificate = new X509Certificate2(data);
    36|                 certificate.ThrowIfInvalid();
    37|                 return certificate;
    38|             }
    39|             catch (CryptographicException)
    40|             {
    41|                 return null;
    42|             }
    43|         }
    44|         internal static SafeX509CrlHandle? DownloadCrl(string uri, TimeSpan downloadTimeout)
    45|         {
    46|             byte[]? data = DownloadAsset(uri, downloadTimeout);
    47|             if (data == null)
    48|             {
    49|                 return null;
    50|             }
    51|             SafeX509CrlHandle handle = Interop.Crypto.DecodeX509Crl(data, data.Length);
    52|             if (!handle.IsInvalid)
    53|             {
    54|                 return handle;
    55|             }
    56|             using (SafeBioHandle bio = Interop.Crypto.CreateMemoryBio())
    57|             {
    58|                 Interop.Crypto.CheckValidOpenSslHandle(bio);
    59|                 Interop.Crypto.BioWrite(bio, data, data.Length);
    60|                 handle = Interop.Crypto.PemReadBioX509Crl(bio);
    61|                 Interop.Crypto.ErrClearError();
    62|                 if (!handle.IsInvalid)
    63|                 {
    64|                     return handle;
    65|                 }
    66|             }
    67|             return null;
    68|         }
    69|         internal static SafeOcspResponseHandle? DownloadOcspGet(string uri, TimeSpan downloadTimeout)
    70|         {
    71|             byte[]? data = DownloadAsset(uri, downloadTimeout);
    72|             if (data == null)
    73|             {
    74|                 return null;
    75|             }
    76|             SafeOcspResponseHandle resp = Interop.Crypto.DecodeOcspResponse(data);
    77|             if (resp.IsInvalid)
    78|             {
    79|                 Interop.Crypto.ErrClearError();
    80|             }
    81|             return resp;
    82|         }
    83|         private static byte[]? DownloadAsset(string uri, TimeSpan downloadTimeout)
    84|         {
    85|             if (s_downloadBytes != null && downloadTimeout > TimeSpan.Zero)
    86|             {
    87|                 long totalMillis = (long)downloadTimeout.TotalMilliseconds;
    88|                 CancellationTokenSource? cts = totalMillis > int.MaxValue ? null : new CancellationTokenSource((int)totalMillis);
    89|                 try
    90|                 {
    91|                     return s_downloadBytes(uri, cts?.Token ?? default);
    92|                 }
    93|                 catch { }
    94|                 finally
    95|                 {
    96|                     cts?.Dispose();
    97|                 }
    98|             }
    99|             return null;
   100|         }
   101|         private static Func<string, CancellationToken, byte[]?>? CreateDownloadBytesFunc()
   102|         {
   103|             try
   104|             {
   105|                 Type? socketsHttpHandlerType = Type.GetType("System.Net.Http.SocketsHttpHandler, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
   106|                 Type? httpMessageHandlerType = Type.GetType("System.Net.Http.HttpMessageHandler, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
   107|                 Type? httpClientType = Type.GetType("System.Net.Http.HttpClient, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
   108|                 Type? httpRequestMessageType = Type.GetType("System.Net.Http.HttpRequestMessage, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
   109|                 Type? httpResponseMessageType = Type.GetType("System.Net.Http.HttpResponseMessage, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
   110|                 Type? httpResponseHeadersType = Type.GetType("System.Net.Http.Headers.HttpResponseHeaders, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
   111|                 Type? httpContentType = Type.GetType("System.Net.Http.HttpContent, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
   112|                 if (socketsHttpHandlerType == null || httpMessageHandlerType == null || httpClientType == null || httpRequestMessageType == null ||
   113|                     httpResponseMessageType == null || httpResponseHeadersType == null || httpContentType == null)
   114|                 {
   115|                     Debug.Fail("Unable to load required type.");
   116|                     return null;
   117|                 }
   118|                 ConstructorInfo? socketsHttpHandlerCtor = socketsHttpHandlerType.GetConstructor(Type.EmptyTypes);
   119|                 PropertyInfo? pooledConnectionIdleTimeoutProp = socketsHttpHandlerType.GetProperty("PooledConnectionIdleTimeout");
   120|                 PropertyInfo? allowAutoRedirectProp = socketsHttpHandlerType.GetProperty("AllowAutoRedirect");
   121|                 ConstructorInfo? httpClientCtor = httpClientType.GetConstructor(new Type[] { httpMessageHandlerType });
   122|                 PropertyInfo? requestUriProp = httpRequestMessageType.GetProperty("RequestUri");
   123|                 ConstructorInfo? httpRequestMessageCtor = httpRequestMessageType.GetConstructor(Type.EmptyTypes);
   124|                 MethodInfo? sendMethod = httpClientType.GetMethod("Send", new Type[] { httpRequestMessageType, typeof(CancellationToken) });
   125|                 PropertyInfo? maxResponseContentBufferSizeProp = httpClientType.GetProperty("MaxResponseContentBufferSize");
   126|                 PropertyInfo? responseContentProp = httpResponseMessageType.GetProperty("Content");
   127|                 PropertyInfo? responseStatusCodeProp = httpResponseMessageType.GetProperty("StatusCode");
   128|                 PropertyInfo? responseHeadersProp = httpResponseMessageType.GetProperty("Headers");
   129|                 PropertyInfo? responseHeadersLocationProp = httpResponseHeadersType.GetProperty("Location");
   130|                 MethodInfo? readAsStreamMethod = httpContentType.GetMethod("ReadAsStream", Type.EmptyTypes);
   131|                 if (socketsHttpHandlerCtor == null || pooledConnectionIdleTimeoutProp == null || allowAutoRedirectProp == null || httpClientCtor == null ||
   132|                     requestUriProp == null || httpRequestMessageCtor == null || sendMethod == null || responseContentProp == null || responseStatusCodeProp == null ||
   133|                     responseHeadersProp == null || responseHeadersLocationProp == null || readAsStreamMethod == null || maxResponseContentBufferSizeProp == null)
   134|                 {
   135|                     Debug.Fail("Unable to load required member.");
   136|                     return null;
   137|                 }
   138|                 const int PooledConnectionIdleTimeoutSeconds = 15;
   139|                 const int MaxRedirections = 10;
   140|                 object? socketsHttpHandler = socketsHttpHandlerCtor.Invoke(null);
   141|                 pooledConnectionIdleTimeoutProp.SetValue(socketsHttpHandler, TimeSpan.FromSeconds(PooledConnectionIdleTimeoutSeconds));
   142|                 allowAutoRedirectProp.SetValue(socketsHttpHandler, false);
   143|                 object? httpClient = httpClientCtor.Invoke(new object?[] { socketsHttpHandler });
   144|                 maxResponseContentBufferSizeProp.SetValue(httpClient, AiaDownloadLimit);
   145|                 return (string uriString, CancellationToken cancellationToken) =>
   146|                 {
   147|                     Uri uri = new Uri(uriString);
   148|                     if (!IsAllowedScheme(uri.Scheme))
   149|                     {
   150|                         return null;
   151|                     }
   152|                     object requestMessage = httpRequestMessageCtor.Invoke(null);
   153|                     requestUriProp.SetValue(requestMessage, uri);
   154|                     object responseMessage = sendMethod.Invoke(httpClient, new object[] { requestMessage, cancellationToken })!;
   155|                     int redirections = 0;
   156|                     Uri? redirectUri;
   157|                     bool hasRedirect;
   158|                     while (true)
   159|                     {
   160|                         int statusCode = (int)responseStatusCodeProp.GetValue(responseMessage)!;
   161|                         object responseHeaders = responseHeadersProp.GetValue(responseMessage)!;
   162|                         Uri? location = (Uri?)responseHeadersLocationProp.GetValue(responseHeaders);
   163|                         redirectUri = GetUriForRedirect((Uri)requestUriProp.GetValue(requestMessage)!, statusCode, location, out hasRedirect);
   164|                         if (redirectUri == null)
   165|                         {
   166|                             break;
   167|                         }
   168|                         ((IDisposable)responseMessage).Dispose();
   169|                         redirections++;
   170|                         if (redirections > MaxRedirections)
   171|                         {
   172|                             return null;
   173|                         }
   174|                         requestMessage = httpRequestMessageCtor.Invoke(null);
   175|                         requestUriProp.SetValue(requestMessage, redirectUri);
   176|                         responseMessage = sendMethod.Invoke(httpClient, new object[] { requestMessage, cancellationToken })!;
   177|                     }
   178|                     if (hasRedirect && redirectUri == null)
   179|                     {
   180|                         return null;
   181|                     }
   182|                     object content = responseContentProp.GetValue(responseMessage)!;
   183|                     using Stream responseStream = (Stream)readAsStreamMethod.Invoke(content, null)!;
   184|                     var result = new MemoryStream();
   185|                     responseStream.CopyTo(result);
   186|                     ((IDisposable)responseMessage).Dispose();
   187|                     return result.ToArray();
   188|                 };
   189|             }
   190|             catch
   191|             {
   192|                 return null;
   193|             }
   194|         }
   195|         private static Uri? GetUriForRedirect(Uri requestUri, int statusCode, Uri? location, out bool hasRedirect)
   196|         {
   197|             if (!IsRedirectStatusCode(statusCode))
   198|             {
   199|                 hasRedirect = false;
   200|                 return null;
   201|             }
   202|             hasRedirect = true;
   203|             if (location == null)
   204|             {
   205|                 return null;
   206|             }
   207|             if (!location.IsAbsoluteUri)
   208|             {
   209|                 location = new Uri(requestUri, location);
   210|             }
   211|             string requestFragment = requestUri.Fragment;
   212|             if (!string.IsNullOrEmpty(requestFragment))
   213|             {
   214|                 string redirectFragment = location.Fragment;
   215|                 if (string.IsNullOrEmpty(redirectFragment))
   216|                 {
   217|                     location = new UriBuilder(location) { Fragment = requestFragment }.Uri;
   218|                 }
   219|             }
   220|             if (!IsAllowedScheme(location.Scheme))
   221|             {
   222|                 return null;
   223|             }
   224|             return location;
   225|         }
   226|         private static bool IsRedirectStatusCode(int statusCode)
   227|         {
   228|             return (statusCode >= 300 && statusCode <= 303) || statusCode == 307 || statusCode == 308;
   229|         }
   230|         private static bool IsAllowedScheme(string scheme)
   231|         {
   232|             return string.Equals(scheme, "http", StringComparison.OrdinalIgnoreCase);
   233|         }
   234|         private static long GetValue(string name, long defaultValue)
   235|         {
   236|             object? data = AppContext.GetData(name);
   237|             if (data is null)
   238|             {
   239|                 return defaultValue;
   240|             }
   241|             try
   242|             {
   243|                 return Convert.ToInt64(data);
   244|             }
   245|             catch
   246|             {
   247|                 return defaultValue;
   248|             }
   249|         }
   250|     }
   251| }


# ====================================================================
# FILE: src/native/corehost/hostmisc/pal.windows.cpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-684 ---
     1| #include "pal.h"
     2| #include "trace.h"
     3| #include "utils.h"
     4| #include "longfile.h"
     5| #include <cassert>
     6| #include <locale>
     7| #include <ShlObj.h>
     8| #include <ctime>
     9| bool GetModuleFileNameWrapper(HMODULE hModule, pal::string_t* recv)
    10| {
    11|     pal::string_t path;
    12|     size_t dwModuleFileName = MAX_PATH / 2;
    13|     do
    14|     {
    15|         path.resize(dwModuleFileName * 2);
    16|         dwModuleFileName = GetModuleFileNameW(hModule, (LPWSTR)path.data(), static_cast<DWORD>(path.size()));
    17|     } while (dwModuleFileName == path.size());
    18|     if (dwModuleFileName == 0)
    19|         return false;
    20|     path.resize(dwModuleFileName);
    21|     recv->assign(path);
    22|     return true;
    23| }
    24| bool GetModuleHandleFromAddress(void *addr, HMODULE *hModule)
    25| {
    26|     BOOL res = ::GetModuleHandleExW(
    27|         GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
    28|         reinterpret_cast<LPCWSTR>(addr),
    29|         hModule);
    30|     return (res != FALSE);
    31| }
    32| pal::string_t pal::get_timestamp()
    33| {
    34|     std::time_t t = std::time(nullptr);
    35|     const std::size_t elems = 100;
    36|     char_t buf[elems];
    37|     tm tm_l{};
    38|     ::gmtime_s(&tm_l, &t);
    39|     std::wcsftime(buf, elems, _X("%c GMT"), &tm_l);
    40|     return pal::string_t(buf);
    41| }
    42| bool pal::touch_file(const pal::string_t& path)
    43| {
    44|     HANDLE hnd = ::CreateFileW(path.c_str(), 0, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
    45|     if (hnd == INVALID_HANDLE_VALUE)
    46|     {
    47|         trace::verbose(_X("Failed to leave breadcrumb, HRESULT: 0x%X"), HRESULT_FROM_WIN32(GetLastError()));
    48|         return false;
    49|     }
    50|     ::CloseHandle(hnd);
    51|     return true;
    52| }
    53| static void* map_file(const pal::string_t& path, size_t *length, DWORD mapping_protect, DWORD view_desired_access)
    54| {
    55|     HANDLE file = CreateFileW(path.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    56|     if (file == INVALID_HANDLE_VALUE)
    57|     {
    58|         trace::error(_X("Failed to map file. CreateFileW(%s) failed with error %d"), path.c_str(), GetLastError());
    59|         return nullptr;
    60|     }
    61|     if (length != nullptr)
    62|     {
    63|         LARGE_INTEGER fileSize;
    64|         if (GetFileSizeEx(file, &fileSize) == 0)
    65|         {
    66|             trace::error(_X("Failed to map file. GetFileSizeEx(%s) failed with error %d"), path.c_str(), GetLastError());
    67|             CloseHandle(file);
    68|             return nullptr;
    69|         }
    70|         *length = (size_t)fileSize.QuadPart;
    71|     }
    72|     HANDLE map = CreateFileMappingW(file, NULL, mapping_protect, 0, 0, NULL);
    73|     if (map == NULL)
    74|     {
    75|         trace::error(_X("Failed to map file. CreateFileMappingW(%s) failed with error %d"), path.c_str(), GetLastError());
    76|         CloseHandle(file);
    77|         return nullptr;
    78|     }
    79|     void *address = MapViewOfFile(map, view_desired_access, 0, 0, 0);
    80|     if (address == NULL)
    81|     {
    82|         trace::error(_X("Failed to map file. MapViewOfFile(%s) failed with error %d"), path.c_str(), GetLastError());
    83|     }
    84|     CloseHandle(map);
    85|     CloseHandle(file);
    86|     return address;
    87| }
    88| const void* pal::mmap_read(const string_t& path, size_t* length)
    89| {
    90|     return map_file(path, length, PAGE_READONLY, FILE_MAP_READ);
    91| }
    92| void* pal::mmap_copy_on_write(const string_t& path, size_t* length)
    93| {
    94|     return map_file(path, length, PAGE_WRITECOPY, FILE_MAP_READ | FILE_MAP_COPY);
    95| }
    96| bool pal::getcwd(pal::string_t* recv)
    97| {
    98|     recv->clear();
    99|     pal::char_t buf[MAX_PATH];
   100|     DWORD result = GetCurrentDirectoryW(MAX_PATH, buf);
   101|     if (result < MAX_PATH)
   102|     {
   103|         recv->assign(buf);
   104|         return true;
   105|     }
   106|     else if (result != 0)
   107|     {
   108|         std::vector<pal::char_t> str;
   109|         str.resize(result);
   110|         result = GetCurrentDirectoryW(static_cast<uint32_t>(str.size()), str.data());
   111|         assert(result <= str.size());
   112|         if (result != 0)
   113|         {
   114|             recv->assign(str.data());
   115|             return true;
   116|         }
   117|     }
   118|     assert(result == 0);
   119|     trace::error(_X("Failed to obtain working directory, HRESULT: 0x%X"), HRESULT_FROM_WIN32(GetLastError()));
   120|     return false;
   121| }
   122| bool pal::get_loaded_library(
   123|     const char_t *library_name,
   124|     const char *symbol_name,
   125|     /*out*/ dll_t *dll,
   126|     /*out*/ pal::string_t *path)
   127| {
   128|     dll_t dll_maybe = ::GetModuleHandleW(library_name);
   129|     if (dll_maybe == nullptr)
   130|         return false;
   131|     *dll = dll_maybe;
   132|     return pal::get_module_path(*dll, path);
   133| }
   134| bool pal::load_library(const string_t* in_path, dll_t* dll)
   135| {
   136|     string_t path = *in_path;
   137|     if (LongFile::IsPathNotFullyQualified(path))
   138|     {
   139|         if (!pal::realpath(&path))
   140|         {
   141|             trace::error(_X("Failed to load the dll from [%s], HRESULT: 0x%X"), path.c_str(), HRESULT_FROM_WIN32(GetLastError()));
   142|             return false;
   143|         }
   144|     }
   145|     assert(!LongFile::IsPathNotFullyQualified(path) || !LongFile::ContainsDirectorySeparator(path));
   146|     *dll = ::LoadLibraryExW(path.c_str(), NULL, LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR | LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
   147|     if (*dll == nullptr)
   148|     {
   149|         trace::error(_X("Failed to load the dll from [%s], HRESULT: 0x%X"), path.c_str(), HRESULT_FROM_WIN32(GetLastError()));
   150|         return false;
   151|     }
   152|     HMODULE dummy_module;
   153|     if (!::GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_PIN, path.c_str(), &dummy_module))
   154|     {
   155|         trace::error(_X("Failed to pin library [%s] in [%s]"), path.c_str(), _STRINGIFY(__FUNCTION__));
   156|         return false;
   157|     }
   158|     if (trace::is_enabled())
   159|     {
   160|         string_t buf;
   161|         GetModuleFileNameWrapper(*dll, &buf);
   162|         trace::info(_X("Loaded library from %s"), buf.c_str());
   163|     }
   164|     return true;
   165| }
   166| pal::proc_t pal::get_symbol(dll_t library, const char* name)
   167| {
   168|     auto result = ::GetProcAddress(library, name);
   169|     if (result == nullptr)
   170|     {
   171|         trace::info(_X("Probed for and did not resolve library symbol %S"), name);
   172|     }
   173|     return result;
   174| }
   175| void pal::unload_library(dll_t library)
   176| {
   177| }
   178| static
   179| bool get_wow_mode_program_files(pal::string_t* recv)
   180| {
   181| #if defined(TARGET_AMD64)
   182|     const pal::char_t* env_key = _X("ProgramFiles(x86)");
   183| #else
   184|     const pal::char_t* env_key = _X("ProgramFiles");
   185| #endif
   186|     return get_file_path_from_env(env_key,recv);
   187| }
   188| bool pal::get_default_breadcrumb_store(string_t* recv)
   189| {
   190|     recv->clear();
   191|     pal::string_t prog_dat;
   192|     if (!get_file_path_from_env(_X("ProgramData"), &prog_dat))
   193|     {
   194|         trace::verbose(_X("Failed to read default breadcrumb store [%s]"), prog_dat.c_str());
   195|         return false;
   196|     }
   197|     recv->assign(prog_dat);
   198|     append_path(recv, _X("Microsoft"));
   199|     append_path(recv, _X("NetFramework"));
   200|     append_path(recv, _X("BreadcrumbStore"));
   201|     return true;
   202| }
   203| bool pal::get_default_servicing_directory(string_t* recv)
   204| {
   205|     if (!get_wow_mode_program_files(recv))
   206|     {
   207|         return false;
   208|     }
   209|     append_path(recv, _X("coreservicing"));
   210|     return true;
   211| }
   212| bool pal::get_default_installation_dir(pal::string_t* recv)
   213| {
   214|     pal::string_t environmentOverride;
   215|     if (test_only_getenv(_X("_DOTNET_TEST_DEFAULT_INSTALL_PATH"), &environmentOverride))
   216|     {
   217|         recv->assign(environmentOverride);
   218|         return true;
   219|     }
   220|     const pal::char_t* program_files_dir;
   221|     if (pal::is_running_in_wow64())
   222|     {
   223|         program_files_dir = _X("ProgramFiles(x86)");
   224|     }
   225|     else
   226|     {
   227|         program_files_dir = _X("ProgramFiles");
   228|     }
   229|     if (!get_file_path_from_env(program_files_dir, recv))
   230|     {
   231|         return false;
   232|     }
   233|     append_path(recv, _X("dotnet"));
   234|     if (pal::is_emulating_x64())
   235|     {
   236|         append_path(recv, _X("x64"));
   237|     }
   238|     return true;
   239| }
   240| namespace
   241| {
   242|     void get_dotnet_install_location_registry_path(HKEY * key_hive, pal::string_t * sub_key, const pal::char_t ** value)
   243|     {
   244|         *key_hive = HKEY_LOCAL_MACHINE;
   245|         pal::string_t dotnet_key_path = pal::string_t(_X("SOFTWARE\\dotnet"));
   246|         pal::string_t environmentRegistryPathOverride;
   247|         if (test_only_getenv(_X("_DOTNET_TEST_REGISTRY_PATH"), &environmentRegistryPathOverride))
   248|         {
   249|             pal::string_t hkcuPrefix = _X("HKEY_CURRENT_USER\\");
   250|             if (environmentRegistryPathOverride.substr(0, hkcuPrefix.length()) == hkcuPrefix)
   251|             {
   252|                 *key_hive = HKEY_CURRENT_USER;
   253|                 environmentRegistryPathOverride = environmentRegistryPathOverride.substr(hkcuPrefix.length());
   254|             }
   255|             dotnet_key_path = environmentRegistryPathOverride;
   256|         }
   257|         *sub_key = dotnet_key_path + pal::string_t(_X("\\Setup\\InstalledVersions\\")) + get_arch();
   258|         *value = _X("InstallLocation");
   259|     }
   260| }
   261| pal::string_t pal::get_dotnet_self_registered_config_location()
   262| {
   263|     HKEY key_hive;
   264|     pal::string_t sub_key;
   265|     const pal::char_t* value;
   266|     get_dotnet_install_location_registry_path(&key_hive, &sub_key, &value);
   267|     return (key_hive == HKEY_CURRENT_USER ? _X("HKCU\\") : _X("HKLM\\")) + sub_key + _X("\\") + value;
   268| }
   269| bool pal::get_dotnet_self_registered_dir(pal::string_t* recv)
   270| {
   271|     recv->clear();
   272|     pal::string_t environmentOverride;
   273|     if (test_only_getenv(_X("_DOTNET_TEST_GLOBALLY_REGISTERED_PATH"), &environmentOverride))
   274|     {
   275|         recv->assign(environmentOverride);
   276|         return true;
   277|     }
   278|     HKEY hkeyHive;
   279|     pal::string_t sub_key;
   280|     const pal::char_t* value;
   281|     get_dotnet_install_location_registry_path(&hkeyHive, &sub_key, &value);
   282|     HKEY hkey = NULL;
   283|     LSTATUS result = ::RegOpenKeyExW(hkeyHive, sub_key.c_str(), 0, KEY_READ | KEY_WOW64_32KEY, &hkey);
   284|     if (result != ERROR_SUCCESS)
   285|     {
   286|         trace::verbose(_X("Can't open the SDK installed location registry key, result: 0x%X"), result);
   287|         return false;
   288|     }
   289|     DWORD size = 0;
   290|     result = ::RegGetValueW(hkey, nullptr, value, RRF_RT_REG_SZ, nullptr, nullptr, &size);
   291|     if (result != ERROR_SUCCESS || size == 0)
   292|     {
   293|         trace::verbose(_X("Can't get the size of the SDK location registry value or it's empty, result: 0x%X"), result);
   294|         ::RegCloseKey(hkey);
   295|         return false;
   296|     }
   297|     std::vector<pal::char_t> buffer(size/sizeof(pal::char_t));
   298|     result = ::RegGetValueW(hkey, nullptr, value, RRF_RT_REG_SZ, nullptr, &buffer[0], &size);
   299|     if (result != ERROR_SUCCESS)
   300|     {
   301|         trace::verbose(_X("Can't get the value of the SDK location registry value, result: 0x%X"), result);
   302|         ::RegCloseKey(hkey);
   303|         return false;
   304|     }
   305|     recv->assign(buffer.data());
   306|     ::RegCloseKey(hkey);
   307|     return true;
   308| }
   309| bool pal::get_global_dotnet_dirs(std::vector<pal::string_t>* dirs)
   310| {
   311|     pal::string_t default_dir;
   312|     pal::string_t custom_dir;
   313|     bool dir_found = false;
   314|     if (pal::get_dotnet_self_registered_dir(&custom_dir))
   315|     {
   316|         remove_trailing_dir_seperator(&custom_dir);
   317|         dirs->push_back(custom_dir);
   318|         dir_found = true;
   319|     }
   320|     if (get_default_installation_dir(&default_dir))
   321|     {
   322|         remove_trailing_dir_seperator(&default_dir);
   323|         if (!dir_found || !are_paths_equal_with_normalized_casing(custom_dir, default_dir))
   324|         {
   325|             dirs->push_back(default_dir);
   326|             dir_found = true;
   327|         }
   328|     }
   329|     return dir_found;
   330| }
   331| typedef LONG (WINAPI *pFuncRtlGetVersion)(RTL_OSVERSIONINFOW *);
   332| pal::string_t pal::get_current_os_rid_platform()
   333| {
   334|     pal::string_t ridOS;
   335|     RTL_OSVERSIONINFOW osinfo;
   336|     ZeroMemory(&osinfo, sizeof(osinfo));
   337|     osinfo.dwOSVersionInfoSize = sizeof(osinfo);
   338|     HMODULE hmodNtdll = LoadLibraryA("ntdll.dll");
   339|     if (hmodNtdll != NULL)
   340|     {
   341|         pFuncRtlGetVersion pRtlGetVersion = (pFuncRtlGetVersion)GetProcAddress(hmodNtdll, "RtlGetVersion");
   342|         if (pRtlGetVersion)
   343|         {
   344|             if ((*pRtlGetVersion)(&osinfo) == 0)
   345|             {
   346|                 uint32_t majorVer = 6;
   347|                 uint32_t minorVer = 1;
   348|                 if (osinfo.dwMajorVersion > majorVer)
   349|                 {
   350|                     majorVer = osinfo.dwMajorVersion;
   351|                     minorVer = 0;
   352|                 }
   353|                 if (osinfo.dwMinorVersion > minorVer)
   354|                 {
   355|                     minorVer = osinfo.dwMinorVersion;
   356|                 }
   357|                 if (majorVer == 6)
   358|                 {
   359|                     switch(minorVer)
   360|                     {
   361|                         case 1:
   362|                             ridOS.append(_X("win7"));
   363|                             break;
   364|                         case 2:
   365|                             ridOS.append(_X("win8"));
   366|                             break;
   367|                         case 3:
   368|                         default:
   369|                             ridOS.append(_X("win81"));
   370|                             break;
   371|                     }
   372|                 }
   373|                 else if (majorVer >= 10)
   374|                 {
   375|                     ridOS.append(_X("win"));
   376|                     ridOS.append(pal::to_string(majorVer));
   377|                 }
   378|             }
   379|         }
   380|     }
   381|     return ridOS;
   382| }
   383| bool pal::is_path_rooted(const string_t& path)
   384| {
   385|     return path.length() >= 2 && path[1] == L':';
   386| }
   387| bool pal::getenv(const char_t* name, string_t* recv)
   388| {
   389|     recv->clear();
   390|     auto length = ::GetEnvironmentVariableW(name, nullptr, 0);
   391|     if (length == 0)
   392|     {
   393|         auto err = GetLastError();
   394|         if (err != ERROR_ENVVAR_NOT_FOUND)
   395|         {
   396|             trace::warning(_X("Failed to read environment variable [%s], HRESULT: 0x%X"), name, HRESULT_FROM_WIN32(err));
   397|         }
   398|         return false;
   399|     }
   400|     auto buf = new char_t[length];
   401|     if (::GetEnvironmentVariableW(name, buf, length) == 0)
   402|     {
   403|         auto err = GetLastError();
   404|         if (err != ERROR_ENVVAR_NOT_FOUND)
   405|         {
   406|             trace::warning(_X("Failed to read environment variable [%s], HRESULT: 0x%X"), name, HRESULT_FROM_WIN32(err));
   407|         }
   408|         return false;
   409|     }
   410|     recv->assign(buf);
   411|     delete[] buf;
   412|     return true;
   413| }
   414| int pal::xtoi(const char_t* input)
   415| {
   416|     return ::_wtoi(input);
   417| }
   418| bool pal::get_own_executable_path(string_t* recv)
   419| {
   420|     return GetModuleFileNameWrapper(NULL, recv);
   421| }
   422| bool pal::get_current_module(dll_t *mod)
   423| {
   424|     HMODULE hmod = nullptr;
   425|     if (!GetModuleHandleFromAddress(&get_current_module, &hmod))
   426|         return false;
   427|     *mod = (pal::dll_t)hmod;
   428|     return true;
   429| }
   430| bool pal::get_own_module_path(string_t* recv)
   431| {
   432|     HMODULE hmod;
   433|     if (!GetModuleHandleFromAddress(&get_own_module_path, &hmod))
   434|         return false;
   435|     return GetModuleFileNameWrapper(hmod, recv);
   436| }
   437| bool pal::get_method_module_path(string_t* recv, void* method)
   438| {
   439|     HMODULE hmod;
   440|     if (!GetModuleHandleFromAddress(method, &hmod))
   441|         return false;
   442|     return GetModuleFileNameWrapper(hmod, recv);
   443| }
   444| bool pal::get_module_path(dll_t mod, string_t* recv)
   445| {
   446|     return GetModuleFileNameWrapper(mod, recv);
   447| }
   448| bool get_extraction_base_parent_directory(pal::string_t& directory)
   449| {
   450|     const size_t max_len = MAX_PATH + 1;
   451|     pal::char_t temp_path[max_len];
   452|     size_t len = GetTempPathW(max_len, temp_path);
   453|     if (len == 0)
   454|     {
   455|         return false;
   456|     }
   457|     assert(len < max_len);
   458|     directory.assign(temp_path);
   459|     return pal::realpath(&directory);
   460| }
   461| bool pal::get_default_bundle_extraction_base_dir(pal::string_t& extraction_dir)
   462| {
   463|     if (!get_extraction_base_parent_directory(extraction_dir))
   464|     {
   465|         return false;
   466|     }
   467|     append_path(&extraction_dir, _X(".net"));
   468|     if (realpath(&extraction_dir))
   469|     {
   470|         return true;
   471|     }
   472|     if (CreateDirectoryW(extraction_dir.c_str(), NULL) == 0 &&
   473|         GetLastError() != ERROR_ALREADY_EXISTS)
   474|     {
   475|         return false;
   476|     }
   477|     return realpath(&extraction_dir);
   478| }
   479| static bool wchar_convert_helper(DWORD code_page, const char* cstr, size_t len, pal::string_t* out)
   480| {
   481|     out->clear();
   482|     size_t size = ::MultiByteToWideChar(code_page, 0, cstr, static_cast<uint32_t>(len), nullptr, 0);
   483|     if (size == 0)
   484|     {
   485|         return false;
   486|     }
   487|     out->resize(size, '\0');
   488|     return ::MultiByteToWideChar(code_page, 0, cstr, static_cast<uint32_t>(len), &(*out)[0], static_cast<uint32_t>(out->size())) != 0;
   489| }
   490| bool pal::pal_utf8string(const pal::string_t& str, std::vector<char>* out)
   491| {
   492|     out->clear();
   493|     size_t size = ::WideCharToMultiByte(CP_UTF8, 0, str.c_str(), -1, nullptr, 0, nullptr, nullptr);
   494|     if (size == 0)
   495|     {
   496|         return false;
   497|     }
   498|     out->resize(size, '\0');
   499|     return ::WideCharToMultiByte(CP_UTF8, 0, str.c_str(), -1, out->data(), static_cast<uint32_t>(out->size()), nullptr, nullptr) != 0;
   500| }
   501| bool pal::pal_clrstring(const pal::string_t& str, std::vector<char>* out)
   502| {
   503|     return pal_utf8string(str, out);
   504| }
   505| bool pal::clr_palstring(const char* cstr, pal::string_t* out)
   506| {
   507|     return wchar_convert_helper(CP_UTF8, cstr, ::strlen(cstr), out);
   508| }
   509| bool pal::realpath(string_t* path, bool skip_error_logging)
   510| {
   511|     if (path->empty())
   512|     {
   513|         return false;
   514|     }
   515|     if (LongFile::IsNormalized(*path))
   516|     {
   517|         WIN32_FILE_ATTRIBUTE_DATA data;
   518|         if (GetFileAttributesExW(path->c_str(), GetFileExInfoStandard, &data) != 0)
   519|         {
   520|             return true;
   521|         }
   522|     }
   523|     char_t buf[MAX_PATH];
   524|     size_t size = ::GetFullPathNameW(path->c_str(), MAX_PATH, buf, nullptr);
   525|     if (size == 0)
   526|     {
   527|         if (!skip_error_logging)
   528|         {
   529|             trace::error(_X("Error resolving full path [%s]"), path->c_str());
   530|         }
   531|         return false;
   532|     }
   533|     string_t str;
   534|     if (size < MAX_PATH)
   535|     {
   536|         str.assign(buf);
   537|     }
   538|     else
   539|     {
   540|         str.resize(size + LongFile::UNCExtendedPathPrefix.length(), 0);
   541|         size = ::GetFullPathNameW(path->c_str(), static_cast<uint32_t>(size), (LPWSTR)str.data(), nullptr);
   542|         assert(size <= str.size());
   543|         if (size == 0)
   544|         {
   545|             if (!skip_error_logging)
   546|             {
   547|                 trace::error(_X("Error resolving full path [%s]"), path->c_str());
   548|             }
   549|             return false;
   550|         }
   551|         const string_t* prefix = &LongFile::ExtendedPrefix;
   552|         if (str.compare(0, LongFile::UNCPathPrefix.length(), LongFile::UNCPathPrefix) == 0)
   553|         {
   554|             prefix = &LongFile::UNCExtendedPathPrefix;
   555|             str.erase(0, LongFile::UNCPathPrefix.length());
   556|             size = size - LongFile::UNCPathPrefix.length();
   557|         }
   558|         str.insert(0, *prefix);
   559|         str.resize(size + prefix->length());
   560|         str.shrink_to_fit();
   561|     }
   562|     WIN32_FILE_ATTRIBUTE_DATA data;
   563|     if (GetFileAttributesExW(str.c_str(), GetFileExInfoStandard, &data) != 0)
   564|     {
   565|         *path = str;
   566|         return true;
   567|     }
   568|     return false;
   569| }
   570| bool pal::file_exists(const string_t& path)
   571| {
   572|     string_t tmp(path);
   573|     return pal::realpath(&tmp, true);
   574| }
   575| static void readdir(const pal::string_t& path, const pal::string_t& pattern, bool onlydirectories, std::vector<pal::string_t>* list)
   576| {
   577|     assert(list != nullptr);
   578|     std::vector<pal::string_t>& files = *list;
   579|     pal::string_t normalized_path(path);
   580|     if (LongFile::ShouldNormalize(normalized_path))
   581|     {
   582|         if (!pal::realpath(&normalized_path))
   583|         {
   584|             return;
   585|         }
   586|     }
   587|     pal::string_t search_string(normalized_path);
   588|     append_path(&search_string, pattern.c_str());
   589|     WIN32_FIND_DATAW data = { 0 };
   590|     auto handle = ::FindFirstFileExW(search_string.c_str(), FindExInfoStandard, &data, FindExSearchNameMatch, NULL, 0);
   591|     if (handle == INVALID_HANDLE_VALUE)
   592|     {
   593|         return;
   594|     }
   595|     do
   596|     {
   597|         if (!onlydirectories || (data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
   598|         {
   599|             pal::string_t filepath(data.cFileName);
   600|             if (filepath != _X(".") && filepath != _X(".."))
   601|             {
   602|                 files.push_back(filepath);
   603|             }
   604|         }
   605|     } while (::FindNextFileW(handle, &data));
   606|     ::FindClose(handle);
   607| }
   608| void pal::readdir(const string_t& path, const string_t& pattern, std::vector<pal::string_t>* list)
   609| {
   610|     ::readdir(path, pattern, false, list);
   611| }
   612| void pal::readdir(const string_t& path, std::vector<pal::string_t>* list)
   613| {
   614|     ::readdir(path, _X("*"), false, list);
   615| }
   616| void pal::readdir_onlydirectories(const pal::string_t& path, const string_t& pattern, std::vector<pal::string_t>* list)
   617| {
   618|     ::readdir(path, pattern, true, list);
   619| }
   620| void pal::readdir_onlydirectories(const pal::string_t& path, std::vector<pal::string_t>* list)
   621| {
   622|     ::readdir(path, _X("*"), true, list);
   623| }
   624| bool pal::is_running_in_wow64()
   625| {
   626|     BOOL fWow64Process = FALSE;
   627|     if (!IsWow64Process(GetCurrentProcess(), &fWow64Process))
   628|     {
   629|         return false;
   630|     }
   631|     return (fWow64Process != FALSE);
   632| }
   633| typedef BOOL (WINAPI* is_wow64_process2)(
   634|     HANDLE hProcess,
   635|     USHORT *pProcessMachine,
   636|     USHORT *pNativeMachine
   637| );
   638| bool pal::is_emulating_x64()
   639| {
   640| #if defined(TARGET_AMD64)
   641|     auto kernel32 = LoadLibraryExW(L"kernel32.dll", NULL, LOAD_LIBRARY_SEARCH_SYSTEM32);
   642|     if (kernel32 == nullptr)
   643|     {
   644|         trace::info(_X("Could not load 'kernel32.dll': %u"), GetLastError());
   645|         return false;
   646|     }
   647|     is_wow64_process2 is_wow64_process2_func = (is_wow64_process2)::GetProcAddress(kernel32, "IsWow64Process2");
   648|     if (is_wow64_process2_func == nullptr)
   649|     {
   650|         return false;
   651|     }
   652|     USHORT process_machine;
   653|     USHORT native_machine;
   654|     if (!is_wow64_process2_func(GetCurrentProcess(), &process_machine, &native_machine))
   655|     {
   656|         trace::info(_X("Call to IsWow64Process2 failed: %u"), GetLastError());
   657|         return false;
   658|     }
   659|     return native_machine != IMAGE_FILE_MACHINE_AMD64;
   660| #else
   661|     return false;
   662| #endif
   663| }
   664| bool pal::are_paths_equal_with_normalized_casing(const string_t& path1, const string_t& path2)
   665| {
   666|     return (strcasecmp(path1.c_str(), path2.c_str()) == 0);
   667| }
   668| pal::mutex_t::mutex_t()
   669|     : _impl{ }
   670| {
   671|     ::InitializeCriticalSection(&_impl);
   672| }
   673| pal::mutex_t::~mutex_t()
   674| {
   675|     ::DeleteCriticalSection(&_impl);
   676| }
   677| void pal::mutex_t::lock()
   678| {
   679|     ::EnterCriticalSection(&_impl);
   680| }
   681| void pal::mutex_t::unlock()
   682| {
   683|     ::LeaveCriticalSection(&_impl);
   684| }


# ====================================================================
# FILE: src/native/eventpipe/ds-ipc-pal-namedpipe.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-805 ---
     1| #ifdef FEATURE_PERFTRACING_STANDALONE_PAL
     2| #define EP_NO_RT_DEPENDENCY
     3| #endif
     4| #include "ds-rt-config.h"
     5| #ifdef ENABLE_PERFTRACING
     6| #ifdef HOST_WIN32
     7| #define DS_IMPL_IPC_PAL_NAMEDPIPE_GETTER_SETTER
     8| #include "ds-ipc-pal-namedpipe.h"
     9| #include <assert.h>
    10| #include <stdlib.h>
    11| #include <stdio.h>
    12| #ifndef FEATURE_PERFTRACING_STANDALONE_PAL
    13| #include "ds-rt.h"
    14| #else
    15| #ifndef ep_raise_error_if_nok
    16| #define ep_raise_error_if_nok(expr) do { if (!(expr)) goto ep_on_error; } while (0)
    17| #endif
    18| #ifndef ep_raise_error
    19| #define ep_raise_error() do { goto ep_on_error; } while (0)
    20| #endif
    21| #ifndef ep_exit_error_handler
    22| #define ep_exit_error_handler() do { goto ep_on_exit; } while (0)
    23| #endif
    24| #ifndef EP_ASSERT
    25| #define EP_ASSERT assert
    26| #endif
    27| #ifndef DS_ENTER_BLOCKING_PAL_SECTION
    28| #define DS_ENTER_BLOCKING_PAL_SECTION
    29| #endif
    30| #ifndef DS_EXIT_BLOCKING_PAL_SECTION
    31| #define DS_EXIT_BLOCKING_PAL_SECTION
    32| #endif
    33| #undef ep_rt_object_alloc
    34| #define ep_rt_object_alloc(obj_type) ((obj_type *)calloc(1, sizeof(obj_type)))
    35| static
    36| inline
    37| void
    38| ep_rt_object_free (void *ptr)
    39| {
    40| 	if (ptr)
    41| 		free (ptr);
    42| }
    43| #endif /* !FEATURE_PERFTRACING_STANDALONE_PAL */
    44| static HANDLE _ipc_listen_ownership_handle = INVALID_HANDLE_VALUE;
    45| /*
    46|  * Forward declares of all static functions.
    47|  */
    48| static
    49| void
    50| ipc_stream_free_func (void *object);
    51| static
    52| bool
    53| ipc_stream_read_func (
    54| 	void *object,
    55| 	uint8_t *buffer,
    56| 	uint32_t bytes_to_read,
    57| 	uint32_t *bytes_read,
    58| 	uint32_t timeout_ms);
    59| static
    60| bool
    61| ipc_stream_write_func (
    62| 	void *object,
    63| 	const uint8_t *buffer,
    64| 	uint32_t bytes_to_write,
    65| 	uint32_t *bytes_written,
    66| 	uint32_t timeout_ms);
    67| static
    68| bool
    69| ipc_stream_flush_func (void *object);
    70| static
    71| bool
    72| ipc_stream_close_func (void *object);
    73| static
    74| void
    75| ipc_close_ownership_handle (
    76|     ds_ipc_error_callback_func callback);
    77| static
    78| bool
    79| ipc_createpipe_helper (
    80| 	DiagnosticsIpc *ipc,
    81| 	bool ensure_pipe_creation,
    82| 	ds_ipc_error_callback_func callback);
    83| static
    84| DiagnosticsIpcStream *
    85| ipc_stream_alloc (
    86| 	HANDLE pipe,
    87| 	DiagnosticsIpcConnectionMode mode);
    88| /*
    89|  * DiagnosticsIpc.
    90|  */
    91| bool
    92| ds_ipc_pal_init (void)
    93| {
    94| 	return true;
    95| }
    96| bool
    97| ds_ipc_pal_shutdown (ds_ipc_error_callback_func callback)
    98| {
    99|     ipc_close_ownership_handle(callback);
   100| 	return true;
   101| }
   102| DiagnosticsIpc *
   103| ds_ipc_alloc (
   104| 	const ep_char8_t *ipc_name,
   105| 	DiagnosticsIpcConnectionMode mode,
   106| 	ds_ipc_error_callback_func callback)
   107| {
   108| 	int32_t characters_written = -1;
   109| 	DiagnosticsIpc *instance = ep_rt_object_alloc (DiagnosticsIpc);
   110| 	ep_raise_error_if_nok (instance != NULL);
   111| 	instance->mode = mode;
   112| 	instance->is_listening = false;
   113| 	instance->overlap.hEvent = INVALID_HANDLE_VALUE;
   114| 	instance->pipe = INVALID_HANDLE_VALUE;
   115| 	if (ipc_name) {
   116| 		characters_written = sprintf_s (
   117| 			(char *)&instance->pipe_name,
   118| 			(size_t)DS_IPC_WIN32_MAX_NAMED_PIPE_LEN,
   119| 			(const char *)"\\\\.\\pipe\\%s",
   120| 			ipc_name);
   121| 	} else {
   122| 		characters_written = sprintf_s (
   123| 			(char *)&instance->pipe_name,
   124| 			(size_t)DS_IPC_WIN32_MAX_NAMED_PIPE_LEN,
   125| 			(const char *)"\\\\.\\pipe\\dotnet-diagnostic-%d",
   126| 			GetCurrentProcessId ());
   127| 	}
   128| 	if (characters_written <= 0 || characters_written >= DS_IPC_WIN32_MAX_NAMED_PIPE_LEN) {
   129| 		if (callback)
   130| 			callback ("Failed to generate the named pipe name", characters_written);
   131| 		ep_raise_error ();
   132| 	}
   133| ep_on_exit:
   134| 	return instance;
   135| ep_on_error:
   136| 	ds_ipc_free (instance);
   137| 	instance = NULL;
   138| 	ep_exit_error_handler ();
   139| }
   140| void
   141| ds_ipc_free (DiagnosticsIpc *ipc)
   142| {
   143| 	if (!ipc)
   144| 		return;
   145| 	ds_ipc_close (ipc, false, NULL);
   146| 	ep_rt_object_free (ipc);
   147| }
   148| int32_t
   149| ds_ipc_poll (
   150| 	DiagnosticsIpcPollHandle *poll_handles_data,
   151| 	size_t poll_handles_data_len,
   152| 	uint32_t timeout_ms,
   153| 	ds_ipc_error_callback_func callback)
   154| {
   155| 	EP_ASSERT (poll_handles_data != NULL);
   156| 	int32_t result = 1;
   157| 	EP_ASSERT (poll_handles_data_len <= MAXIMUM_WAIT_OBJECTS);
   158| 	HANDLE handles [MAXIMUM_WAIT_OBJECTS];
   159| 	for (size_t i = 0; i < poll_handles_data_len; ++i) {
   160| 		poll_handles_data [i].events = 0; // ignore any input on events.
   161| 		if (poll_handles_data [i].ipc) {
   162| 			EP_ASSERT (poll_handles_data [i].ipc->mode == DS_IPC_CONNECTION_MODE_LISTEN);
   163| 			handles [i] = poll_handles_data [i].ipc->overlap.hEvent;
   164| 		} else {
   165| 			bool success = true;
   166| 			DWORD bytes_read = 1;
   167| 			if (!poll_handles_data [i].stream->is_test_reading) {
   168| 				success = ReadFile (
   169| 					poll_handles_data [i].stream->pipe,                                   // handle
   170| 					NULL,                                                                 // null buffer
   171| 					0,                                                                    // read 0 bytesd
   172| 					&bytes_read,                                                          // dummy variable
   173| 					&poll_handles_data [i].stream->overlap);    // overlap object to use
   174| 				poll_handles_data [i].stream->is_test_reading = true;
   175| 				if (!success) {
   176| 					DWORD error = GetLastError ();
   177| 					switch (error) {
   178| 					case ERROR_IO_PENDING:
   179| 						handles [i] = poll_handles_data [i].stream->overlap.hEvent;
   180| 						break;
   181| 					case ERROR_PIPE_NOT_CONNECTED:
   182| 						poll_handles_data [i].events = (uint8_t)DS_IPC_POLL_EVENTS_HANGUP;
   183| 						result = -1;
   184| 						ep_raise_error ();
   185| 					default:
   186| 						if (callback)
   187| 							callback ("0 byte async read on client connection failed", error);
   188| 						result = -1;
   189| 						ep_raise_error ();
   190| 					}
   191| 				} else {
   192| 					handles [i] = poll_handles_data [i].stream->overlap.hEvent;
   193| 				}
   194| 			} else {
   195| 				handles [i] = poll_handles_data [i].stream->overlap.hEvent;
   196| 			}
   197| 		}
   198| 	}
   199| 	DWORD wait = WAIT_FAILED;
   200| 	DS_ENTER_BLOCKING_PAL_SECTION;
   201| 	wait = WaitForMultipleObjects (
   202| 		(DWORD)poll_handles_data_len,      // count
   203| 		handles,                           // handles
   204| 		false,                             // don't wait all
   205| 		(DWORD)timeout_ms);
   206| 	DS_EXIT_BLOCKING_PAL_SECTION;
   207| 	if (wait == WAIT_TIMEOUT) {
   208| 		result = 0;
   209| 		ep_raise_error ();
   210| 	}
   211| 	if (wait == WAIT_FAILED) {
   212| 		if (callback)
   213| 			callback ("WaitForMultipleObjects failed", GetLastError());
   214| 		result = -1;
   215| 		ep_raise_error ();
   216| 	}
   217| 	DWORD index = wait - WAIT_OBJECT_0;
   218| 	if (index < 0 || index > (poll_handles_data_len - 1)) {
   219| 		DWORD abandonedIndex = wait - WAIT_ABANDONED_0;
   220| 		if (abandonedIndex > 0 || abandonedIndex < (poll_handles_data_len - 1)) {
   221| 			poll_handles_data [abandonedIndex].events = (uint8_t)DS_IPC_POLL_EVENTS_HANGUP;
   222| 			result = -1;
   223| 			ep_raise_error ();
   224| 		} else {
   225| 			if (callback)
   226| 				callback ("WaitForMultipleObjects failed", GetLastError());
   227| 			result = -1;
   228| 			ep_raise_error ();
   229| 		}
   230| 	}
   231| 	if (!poll_handles_data [index].ipc) {
   232| 		DWORD dummy = 0;
   233| 		BOOL success = GetOverlappedResult(
   234| 			poll_handles_data [index].stream->pipe,
   235| 			&poll_handles_data [index].stream->overlap,
   236| 			&dummy,
   237| 			false);
   238| 		if (!success && GetLastError () == ERROR_IO_INCOMPLETE) {
   239| 			dummy = 0;
   240| 			DS_ENTER_BLOCKING_PAL_SECTION;
   241| 			success = GetOverlappedResult(
   242| 				poll_handles_data [index].stream->pipe,
   243| 				&poll_handles_data [index].stream->overlap,
   244| 				&dummy,
   245| 				true);
   246| 			DS_EXIT_BLOCKING_PAL_SECTION;
   247| 		}
   248| 		poll_handles_data [index].stream->is_test_reading = false;
   249| 		if (!success) {
   250| 			DWORD error = GetLastError();
   251| 			if (error == ERROR_PIPE_NOT_CONNECTED || error == ERROR_BROKEN_PIPE) {
   252| 				poll_handles_data [index].events = (uint8_t)DS_IPC_POLL_EVENTS_HANGUP;
   253| 			} else {
   254| 				if (callback)
   255| 					callback ("Client connection error", error);
   256| 				poll_handles_data [index].events = (uint8_t)DS_IPC_POLL_EVENTS_ERR;
   257| 				result = -1;
   258| 				ep_raise_error ();
   259| 			}
   260| 		} else {
   261| 			poll_handles_data [index].events = (uint8_t)DS_IPC_POLL_EVENTS_SIGNALED;
   262| 		}
   263| 	} else {
   264| 		poll_handles_data [index].events = (uint8_t)DS_IPC_POLL_EVENTS_SIGNALED;
   265| 	}
   266| 	result = 1;
   267| ep_on_exit:
   268| 	return result;
   269| ep_on_error:
   270| 	if (result == 1)
   271| 		result = -1;
   272| 	ep_exit_error_handler ();
   273| }
   274| static
   275| bool
   276| ipc_createpipe_helper (
   277| 	DiagnosticsIpc *ipc,
   278| 	bool ensure_pipe_creation,
   279| 	ds_ipc_error_callback_func callback)
   280| {
   281| 	bool result = false;
   282| 	EP_ASSERT (ipc != NULL);
   283| 	EP_ASSERT (ipc->mode == DS_IPC_CONNECTION_MODE_LISTEN);
   284| 	if (ipc->mode != DS_IPC_CONNECTION_MODE_LISTEN) {
   285| 		if (callback)
   286| 			callback ("Cannot call Listen on a client connection", -1);
   287| 		return false;
   288| 	}
   289| 	if (ipc->is_listening)
   290| 		return true;
   291|     if (!ensure_pipe_creation && _ipc_listen_ownership_handle == INVALID_HANDLE_VALUE)
   292|     {
   293|         if (callback)
   294| 			callback ("Can't ensure we have ownership of the pipe. Disallowing creation.", -1);
   295| 		return false;
   296|     }
   297|     if (ensure_pipe_creation && _ipc_listen_ownership_handle != INVALID_HANDLE_VALUE)
   298|     {
   299|         if (callback)
   300| 			callback ("Inconsistent state - pipe sentinel already in use for listen.", -1);
   301| 		return false;
   302|     }
   303|     EP_ASSERT (ipc->pipe == INVALID_HANDLE_VALUE);
   304| 	const uint32_t in_buffer_size = 16 * 1024;
   305| 	const uint32_t out_buffer_size = 16 * 1024;
   306| 	DWORD creationFlags = PIPE_ACCESS_DUPLEX    // read/write access
   307|                 | FILE_FLAG_OVERLAPPED;	        // async listening.
   308| 	if (ensure_pipe_creation)
   309| 	{
   310| 		creationFlags |= FILE_FLAG_FIRST_PIPE_INSTANCE;
   311| 	}
   312| 	DS_ENTER_BLOCKING_PAL_SECTION;
   313| 	ipc->pipe = CreateNamedPipeA (
   314| 		ipc->pipe_name,                                             // pipe name
   315| 		creationFlags,
   316| 		PIPE_TYPE_BYTE | PIPE_WAIT | PIPE_REJECT_REMOTE_CLIENTS,    // message type pipe, message-read and blocking mode
   317| 		PIPE_UNLIMITED_INSTANCES,                                   // max. instances
   318| 		out_buffer_size,                                            // output buffer size
   319| 		in_buffer_size,                                             // input buffer size
   320| 		0,                                                          // default client time-out
   321| 		NULL);                                                      // default security attribute
   322| 	DS_EXIT_BLOCKING_PAL_SECTION;
   323| 	if (ipc->pipe == INVALID_HANDLE_VALUE) {
   324| 		if (callback)
   325| 			callback ("Failed to create an instance of a named pipe.", GetLastError());
   326| 		ep_raise_error ();
   327| 	}
   328|     if (ensure_pipe_creation)
   329| 	{
   330| 	    EP_ASSERT (_ipc_listen_ownership_handle == INVALID_HANDLE_VALUE);
   331|         bool createdSentinel = DuplicateHandle(
   332|                                     GetCurrentProcess(),
   333|                                     ipc->pipe,
   334|                                     GetCurrentProcess(),
   335|                                     &_ipc_listen_ownership_handle,
   336|                                     0,
   337|                                     FALSE,
   338|                                     DUPLICATE_SAME_ACCESS);
   339|         if (!createdSentinel)
   340|         {
   341|             if (callback)
   342| 			    callback ("Failed to ownership sentinel.", GetLastError());
   343|             ep_raise_error();
   344|         }
   345| 	}
   346| 	EP_ASSERT (ipc->overlap.hEvent == INVALID_HANDLE_VALUE);
   347| 	ipc->overlap.hEvent = CreateEventW (NULL, true, false, NULL);
   348| 	if (!ipc->overlap.hEvent) {
   349| 		if (callback)
   350| 			callback ("Failed to create overlap event", GetLastError());
   351| 		ep_raise_error ();
   352| 	}
   353| 	if (ConnectNamedPipe (ipc->pipe, &ipc->overlap) == FALSE) {
   354| 		const DWORD error_code = GetLastError ();
   355| 		switch (error_code) {
   356| 		case ERROR_IO_PENDING:
   357| 		case ERROR_PIPE_CONNECTED:
   358| 			break;
   359| 		default:
   360| 			if (callback)
   361| 				callback ("A client process failed to connect.", error_code);
   362| 			ep_raise_error ();
   363| 		}
   364| 	}
   365| 	ipc->is_listening = true;
   366| 	result = true;
   367| ep_on_exit:
   368| 	return result;
   369| ep_on_error:
   370| 	ds_ipc_close (ipc, false, callback);
   371|     if (ensure_pipe_creation)
   372|         ipc_close_ownership_handle(callback);
   373| 	result = false;
   374| 	ep_exit_error_handler ();
   375| }
   376| bool
   377| ds_ipc_listen (
   378| 	DiagnosticsIpc *ipc,
   379| 	ds_ipc_error_callback_func callback)
   380| {
   381| 	return ipc_createpipe_helper(ipc, true, callback);
   382| }
   383| DiagnosticsIpcStream *
   384| ds_ipc_accept (
   385| 	DiagnosticsIpc *ipc,
   386| 	ds_ipc_error_callback_func callback)
   387| {
   388| 	EP_ASSERT (ipc != NULL);
   389| 	EP_ASSERT (ipc->mode == DS_IPC_CONNECTION_MODE_LISTEN);
   390| 	DiagnosticsIpcStream *stream = NULL;
   391| 	DWORD dummy = 0;
   392| 	BOOL success = GetOverlappedResult (
   393| 		ipc->pipe,      // handle
   394| 		&ipc->overlap,  // overlapped
   395| 		&dummy,         // throw-away dword
   396| 		false);         // wait till event signals
   397| 	if (!success && GetLastError () == ERROR_IO_INCOMPLETE) {
   398| 		dummy = 0;
   399| 		DS_ENTER_BLOCKING_PAL_SECTION;
   400| 		success = GetOverlappedResult (
   401| 			ipc->pipe,      // handle
   402| 			&ipc->overlap,  // overlapped
   403| 			&dummy,         // throw-away dword
   404| 			true);          // wait till event signals
   405| 		DS_EXIT_BLOCKING_PAL_SECTION;
   406| 	}
   407| 	if (!success) {
   408| 		if (callback)
   409| 			callback ("Failed to GetOverlappedResults for NamedPipe server", GetLastError());
   410| 		CloseHandle (ipc->pipe);
   411| 	} else {
   412| 		stream = ipc_stream_alloc (ipc->pipe, DS_IPC_CONNECTION_MODE_LISTEN);
   413| 		ep_raise_error_if_nok (stream != NULL);
   414| 	}
   415| 	ipc->pipe = INVALID_HANDLE_VALUE;
   416| 	ipc->is_listening = false;
   417| 	CloseHandle (ipc->overlap.hEvent);
   418| 	memset(&ipc->overlap, 0, sizeof(OVERLAPPED)); // clear the overlapped objects state
   419| 	ipc->overlap.hEvent = INVALID_HANDLE_VALUE;
   420| 	ep_raise_error_if_nok (ipc_createpipe_helper (ipc, false, callback));
   421| ep_on_exit:
   422| 	return stream;
   423| ep_on_error:
   424| 	ds_ipc_stream_free (stream);
   425| 	stream = NULL;
   426| 	ep_exit_error_handler ();
   427| }
   428| DiagnosticsIpcStream *
   429| ds_ipc_connect (
   430| 	DiagnosticsIpc *ipc,
   431| 	uint32_t timeout_ms,
   432| 	ds_ipc_error_callback_func callback,
   433| 	bool *timed_out)
   434| {
   435| 	EP_ASSERT (ipc != NULL);
   436| 	EP_ASSERT (timed_out != NULL);
   437| 	EP_ASSERT (ipc->mode == DS_IPC_CONNECTION_MODE_CONNECT);
   438| 	DiagnosticsIpcStream *stream = NULL;
   439| 	HANDLE pipe = INVALID_HANDLE_VALUE;
   440| 	if (ipc->mode != DS_IPC_CONNECTION_MODE_CONNECT) {
   441| 		if (callback)
   442| 			callback ("Cannot call connect on a server connection", 0);
   443| 		ep_raise_error ();
   444| 	}
   445| 	DS_ENTER_BLOCKING_PAL_SECTION;
   446| 	pipe = CreateFileA(
   447| 		ipc->pipe_name,         // pipe name
   448| 		PIPE_ACCESS_DUPLEX,     // read/write access
   449| 		0,                      // no sharing
   450| 		NULL,                   // default security attributes
   451| 		OPEN_EXISTING,          // opens existing pipe
   452| 		FILE_FLAG_OVERLAPPED,   // overlapped
   453| 		NULL);                  // no template file
   454| 	DS_EXIT_BLOCKING_PAL_SECTION;
   455| 	if (pipe == INVALID_HANDLE_VALUE) {
   456| 		if (callback)
   457| 			callback ("Failed to connect to named pipe.", GetLastError ());
   458| 		ep_raise_error ();
   459| 	}
   460| 	stream = ipc_stream_alloc (pipe, ipc->mode);
   461| 	ep_raise_error_if_nok (stream);
   462| 	pipe = INVALID_HANDLE_VALUE;
   463| ep_on_exit:
   464| 	return stream;
   465| ep_on_error:
   466| 	ds_ipc_stream_free (stream);
   467| 	stream = NULL;
   468| 	if (pipe != INVALID_HANDLE_VALUE) {
   469| 		CloseHandle (pipe);
   470| 	}
   471| 	ep_exit_error_handler ();
   472| }
   473| void
   474| ipc_close_ownership_handle (
   475|     ds_ipc_error_callback_func callback)
   476| {
   477|     if (_ipc_listen_ownership_handle == INVALID_HANDLE_VALUE)
   478|         return;
   479|     const BOOL success_close_pipe = CloseHandle(_ipc_listen_ownership_handle);
   480|     if (success_close_pipe != TRUE)
   481|     {
   482|         if (callback)
   483|             callback ("Failed to IPC ownership sentinel handle", GetLastError());
   484|         return;
   485|     }
   486|     _ipc_listen_ownership_handle = INVALID_HANDLE_VALUE;
   487| }
   488| void
   489| ds_ipc_close (
   490| 	DiagnosticsIpc *ipc,
   491| 	bool is_shutdown,
   492| 	ds_ipc_error_callback_func callback)
   493| {
   494| 	EP_ASSERT (ipc != NULL);
   495| 	if (is_shutdown) {
   496| 		if (callback)
   497| 			callback ("Closing without cleaning underlying handles", 100);
   498| 		return;
   499| 	}
   500| 	if (ipc->pipe != INVALID_HANDLE_VALUE) {
   501| 		if (ipc->mode == DS_IPC_CONNECTION_MODE_LISTEN) {
   502| 			BOOL success_disconnect = FALSE;
   503| 			DS_ENTER_BLOCKING_PAL_SECTION;
   504| 			success_disconnect = DisconnectNamedPipe (ipc->pipe);
   505| 			DS_EXIT_BLOCKING_PAL_SECTION;
   506| 			if (success_disconnect != TRUE && callback)
   507| 				callback ("Failed to disconnect NamedPipe", GetLastError());
   508| 		}
   509| 		const BOOL success_close_pipe = CloseHandle (ipc->pipe);
   510| 		if (success_close_pipe != TRUE && callback)
   511| 			callback ("Failed to close pipe handle", GetLastError());
   512| 		ipc->pipe = INVALID_HANDLE_VALUE;
   513| 	}
   514| 	if (ipc->overlap.hEvent != INVALID_HANDLE_VALUE) {
   515| 		const BOOL success_close_event = CloseHandle (ipc->overlap.hEvent);
   516| 		if (success_close_event != TRUE && callback)
   517| 			callback ("Failed to close overlap event handle", GetLastError());
   518| 		memset(&ipc->overlap, 0, sizeof(OVERLAPPED)); // clear the overlapped objects state
   519| 		ipc->overlap.hEvent = INVALID_HANDLE_VALUE;
   520| 	}
   521| }
   522| int32_t
   523| ds_ipc_to_string (
   524| 	DiagnosticsIpc *ipc,
   525| 	ep_char8_t *buffer,
   526| 	uint32_t buffer_len)
   527| {
   528| 	EP_ASSERT (ipc != NULL);
   529| 	EP_ASSERT (buffer != NULL);
   530| 	EP_ASSERT (buffer_len <= DS_IPC_MAX_TO_STRING_LEN);
   531| 	int32_t result = sprintf_s (buffer, buffer_len, "{ _hPipe = %d, _oOverlap.hEvent = %d }", (int32_t)(size_t)ipc->pipe, (int32_t)(size_t)ipc->overlap.hEvent);
   532| 	return (result > 0 && result < (int32_t)buffer_len) ? result : 0;
   533| }
   534| /*
   535|  * DiagnosticsIpcStream.
   536|  */
   537| static
   538| void
   539| ipc_stream_free_func (void *object)
   540| {
   541| 	EP_ASSERT (object != NULL);
   542| 	DiagnosticsIpcStream *ipc_stream = (DiagnosticsIpcStream *)object;
   543| 	ds_ipc_stream_free (ipc_stream);
   544| }
   545| static
   546| bool
   547| ipc_stream_read_func (
   548| 	void *object,
   549| 	uint8_t *buffer,
   550| 	uint32_t bytes_to_read,
   551| 	uint32_t *bytes_read,
   552| 	uint32_t timeout_ms)
   553| {
   554| 	EP_ASSERT (object != NULL);
   555| 	EP_ASSERT (buffer != NULL);
   556| 	EP_ASSERT (bytes_read != NULL);
   557| 	DiagnosticsIpcStream *ipc_stream = (DiagnosticsIpcStream *)object;
   558| 	DWORD read = 0;
   559| 	LPOVERLAPPED overlap = &ipc_stream->overlap;
   560| 	bool success = ReadFile (
   561| 		ipc_stream->pipe,   // handle to pipe
   562| 		buffer,             // buffer to receive data
   563| 		bytes_to_read,      // size of buffer
   564| 		&read,              // number of bytes read
   565| 		overlap) != FALSE;  // overlapped I/O
   566| 	if (!success) {
   567| 		DWORD error = GetLastError ();
   568| 		if (error == ERROR_IO_PENDING) {
   569| 			if (timeout_ms == DS_IPC_TIMEOUT_INFINITE) {
   570| 				DS_ENTER_BLOCKING_PAL_SECTION;
   571| 				success = GetOverlappedResult (
   572| 					ipc_stream->pipe,   // pipe
   573| 					overlap,            // overlapped
   574| 					&read,              // out actual number of bytes read
   575| 					true) != FALSE;     // block until async IO completes
   576| 				DS_EXIT_BLOCKING_PAL_SECTION;
   577| 			} else {
   578| 				DS_ENTER_BLOCKING_PAL_SECTION;
   579| 				DWORD wait = WaitForSingleObject (ipc_stream->overlap.hEvent, (DWORD)timeout_ms);
   580| 				if (wait == WAIT_OBJECT_0) {
   581| 					success = GetOverlappedResult (
   582| 						ipc_stream->pipe,   // pipe
   583| 						overlap,            // overlapped
   584| 						&read,              // out actual number of bytes read
   585| 						true) != FALSE;     // block until async IO completes
   586| 				} else {
   587| 					if (CancelIoEx (ipc_stream->pipe, overlap) != FALSE) {
   588| 						success = GetOverlappedResult (
   589| 							ipc_stream->pipe,   // pipe
   590| 							overlap,            // overlapped
   591| 							&read,              // out actual number of bytes read
   592| 							true) != FALSE;     // block until async IO completes
   593| 					}
   594| 				}
   595| 				DS_EXIT_BLOCKING_PAL_SECTION;
   596| 			}
   597| 		}
   598| 	}
   599| 	*bytes_read = (uint32_t)read;
   600| 	return success;
   601| }
   602| static
   603| bool
   604| ipc_stream_write_func (
   605| 	void *object,
   606| 	const uint8_t *buffer,
   607| 	uint32_t bytes_to_write,
   608| 	uint32_t *bytes_written,
   609| 	uint32_t timeout_ms)
   610| {
   611| 	EP_ASSERT (object != NULL);
   612| 	EP_ASSERT (buffer != NULL);
   613| 	EP_ASSERT (bytes_written != NULL);
   614| 	DiagnosticsIpcStream *ipc_stream = (DiagnosticsIpcStream *)object;
   615| 	DWORD written = 0;
   616| 	LPOVERLAPPED overlap = &ipc_stream->overlap;
   617| 	bool success = WriteFile (
   618| 		ipc_stream->pipe,   // handle to pipe
   619| 		buffer,             // buffer to write from
   620| 		bytes_to_write,     // number of bytes to write
   621| 		&written,           // number of bytes written
   622| 		overlap) != FALSE;  // overlapped I/O
   623| 	if (!success) {
   624| 		DWORD error = GetLastError ();
   625| 		if (error == ERROR_IO_PENDING) {
   626| 			if (timeout_ms == DS_IPC_TIMEOUT_INFINITE) {
   627| 				DS_ENTER_BLOCKING_PAL_SECTION;
   628| 				success = GetOverlappedResult (
   629| 					ipc_stream->pipe,   // pipe
   630| 					overlap,            // overlapped
   631| 					&written,           // out actual number of bytes written
   632| 					true) != FALSE;     // block until async IO completes
   633| 				DS_EXIT_BLOCKING_PAL_SECTION;
   634| 			} else {
   635| 				DS_ENTER_BLOCKING_PAL_SECTION;
   636| 				DWORD wait = WaitForSingleObject (ipc_stream->overlap.hEvent, (DWORD)timeout_ms);
   637| 				if (wait == WAIT_OBJECT_0) {
   638| 					success = GetOverlappedResult (
   639| 						ipc_stream->pipe,   // pipe
   640| 						overlap,            // overlapped
   641| 						&written,           // out actual number of bytes written
   642| 						true) != FALSE;     // block until async IO completes
   643| 				} else {
   644| 					if (CancelIoEx (ipc_stream->pipe, overlap) != FALSE) {
   645| 						success = GetOverlappedResult (
   646| 							ipc_stream->pipe,   // pipe
   647| 							overlap,            // overlapped
   648| 							&written,           // out actual number of bytes written
   649| 							true) != FALSE;         // block until async IO completes
   650| 					}
   651| 				}
   652| 				DS_EXIT_BLOCKING_PAL_SECTION;
   653| 			}
   654| 		}
   655| 	}
   656| 	*bytes_written = (uint32_t)written;
   657| 	return success;
   658| }
   659| static
   660| bool
   661| ipc_stream_flush_func (void *object)
   662| {
   663| 	EP_ASSERT (object != NULL);
   664| 	DiagnosticsIpcStream *ipc_stream = (DiagnosticsIpcStream *)object;
   665| 	bool success = false;
   666| 	DS_ENTER_BLOCKING_PAL_SECTION;
   667| 	success = FlushFileBuffers (ipc_stream->pipe) != FALSE;
   668| 	DS_EXIT_BLOCKING_PAL_SECTION;
   669| 	return success;
   670| }
   671| static
   672| bool
   673| ipc_stream_close_func (void *object)
   674| {
   675| 	EP_ASSERT (object != NULL);
   676| 	DiagnosticsIpcStream *ipc_stream = (DiagnosticsIpcStream *)object;
   677| 	return ds_ipc_stream_close (ipc_stream, NULL);
   678| }
   679| static IpcStreamVtable ipc_stream_vtable = {
   680| 	ipc_stream_free_func,
   681| 	ipc_stream_read_func,
   682| 	ipc_stream_write_func,
   683| 	ipc_stream_flush_func,
   684| 	ipc_stream_close_func };
   685| static
   686| DiagnosticsIpcStream *
   687| ipc_stream_alloc (
   688| 	HANDLE pipe,
   689| 	DiagnosticsIpcConnectionMode mode)
   690| {
   691| 	DiagnosticsIpcStream *instance = ep_rt_object_alloc (DiagnosticsIpcStream);
   692| 	ep_raise_error_if_nok (instance != NULL);
   693| 	instance->stream.vtable = &ipc_stream_vtable;
   694| 	instance->pipe = pipe;
   695| 	instance->mode = mode;
   696| 	instance->overlap.hEvent = CreateEventW (NULL, true, false, NULL);
   697| ep_on_exit:
   698| 	return instance;
   699| ep_on_error:
   700| 	ds_ipc_stream_free (instance);
   701| 	instance = NULL;
   702| 	ep_exit_error_handler ();
   703| }
   704| int32_t
   705| ds_ipc_stream_get_handle_int32_t (DiagnosticsIpcStream *ipc_stream)
   706| {
   707| 	return (int32_t)(size_t)ipc_stream->pipe;
   708| }
   709| IpcStream *
   710| ds_ipc_stream_get_stream_ref (DiagnosticsIpcStream *ipc_stream)
   711| {
   712| 	return &ipc_stream->stream;
   713| }
   714| void
   715| ds_ipc_stream_free (DiagnosticsIpcStream *ipc_stream)
   716| {
   717| 	if (!ipc_stream)
   718| 		return;
   719| 	ds_ipc_stream_close (ipc_stream, NULL);
   720| 	ep_rt_object_free (ipc_stream);
   721| }
   722| bool
   723| ds_ipc_stream_read (
   724| 	DiagnosticsIpcStream *ipc_stream,
   725| 	uint8_t *buffer,
   726| 	uint32_t bytes_to_read,
   727| 	uint32_t *bytes_read,
   728| 	uint32_t timeout_ms)
   729| {
   730| 	return ipc_stream_read_func (
   731| 		ipc_stream,
   732| 		buffer,
   733| 		bytes_to_read,
   734| 		bytes_read,
   735| 		timeout_ms);
   736| }
   737| bool
   738| ds_ipc_stream_write (
   739| 	DiagnosticsIpcStream *ipc_stream,
   740| 	const uint8_t *buffer,
   741| 	uint32_t bytes_to_write,
   742| 	uint32_t *bytes_written,
   743| 	uint32_t timeout_ms)
   744| {
   745| 	return ipc_stream_write_func (
   746| 		ipc_stream,
   747| 		buffer,
   748| 		bytes_to_write,
   749| 		bytes_written,
   750| 		timeout_ms);
   751| }
   752| bool
   753| ds_ipc_stream_flush (DiagnosticsIpcStream *ipc_stream)
   754| {
   755| 	return ipc_stream_flush_func (ipc_stream);
   756| }
   757| bool
   758| ds_ipc_stream_close (
   759| 	DiagnosticsIpcStream *ipc_stream,
   760| 	ds_ipc_error_callback_func callback)
   761| {
   762| 	EP_ASSERT (ipc_stream != NULL);
   763| 	if (ipc_stream->pipe != INVALID_HANDLE_VALUE) {
   764| 		ds_ipc_stream_flush (ipc_stream);
   765| 		if (ipc_stream->mode == DS_IPC_CONNECTION_MODE_LISTEN) {
   766| 			BOOL success_disconnect = FALSE;
   767| 			DS_ENTER_BLOCKING_PAL_SECTION;
   768| 			success_disconnect = DisconnectNamedPipe (ipc_stream->pipe);
   769| 			DS_EXIT_BLOCKING_PAL_SECTION;
   770| 			if (success_disconnect != TRUE && callback)
   771| 				callback ("Failed to disconnect NamedPipe", GetLastError());
   772| 		}
   773| 		const BOOL success_close_pipe = CloseHandle (ipc_stream->pipe);
   774| 		if (success_close_pipe != TRUE && callback)
   775| 			callback ("Failed to close pipe handle", GetLastError());
   776| 		ipc_stream->pipe = INVALID_HANDLE_VALUE;
   777| 	}
   778| 	if (ipc_stream->overlap.hEvent != INVALID_HANDLE_VALUE) {
   779| 		const BOOL success_close_event = CloseHandle (ipc_stream->overlap.hEvent);
   780| 		if (success_close_event != TRUE && callback)
   781| 			callback ("Failed to close overlapped event handle", GetLastError());
   782| 		memset(&ipc_stream->overlap, 0, sizeof(OVERLAPPED)); // clear the overlapped objects state
   783| 		ipc_stream->overlap.hEvent = INVALID_HANDLE_VALUE;
   784| 	}
   785| 	ipc_stream->is_test_reading = false;
   786| 	return true;
   787| }
   788| int32_t
   789| ds_ipc_stream_to_string (
   790| 	DiagnosticsIpcStream *ipc_stream,
   791| 	ep_char8_t *buffer,
   792| 	uint32_t buffer_len)
   793| {
   794| 	EP_ASSERT (ipc_stream != NULL);
   795| 	EP_ASSERT (buffer != NULL);
   796| 	EP_ASSERT (buffer_len <= DS_IPC_MAX_TO_STRING_LEN);
   797| 	int32_t result = sprintf_s (buffer, buffer_len, "{ _hPipe = %d, _oOverlap.hEvent = %d }", (int32_t)(size_t)ipc_stream->pipe, (int32_t)(size_t)ipc_stream->overlap.hEvent);
   798| 	return (result > 0 && result < (int32_t)buffer_len) ? result : 0;
   799| }
   800| #endif /* HOST_WIN32 */
   801| #endif /* ENABLE_PERFTRACING */
   802| #ifndef DS_INCLUDE_SOURCE_FILES
   803| extern const char quiet_linker_empty_file_warning_diagnostics_ipc_win32;
   804| const char quiet_linker_empty_file_warning_diagnostics_ipc_win32 = 0;
   805| #endif

