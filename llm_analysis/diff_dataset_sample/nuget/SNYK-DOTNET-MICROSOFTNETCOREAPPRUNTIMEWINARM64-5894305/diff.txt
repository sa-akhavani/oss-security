--- a//dev/null
+++ b/eng/actions/backport/index.js
@@ -0,0 +1,116 @@
+function BackportException(message, postToGitHub = true) {
+  this.message = message;
+  this.postToGitHub = postToGitHub;
+}
+async function run() {
+  const util = require("util");
+  const jsExec = util.promisify(require("child_process").exec);
+  console.log("Installing npm dependencies");
+  const { stdout, stderr } = await jsExec("npm install @actions/core @actions/github @actions/exec");
+  console.log("npm-install stderr:\n\n" + stderr);
+  console.log("npm-install stdout:\n\n" + stdout);
+  console.log("Finished installing npm dependencies");
+  const core = require("@actions/core");
+  const github = require("@actions/github");
+  const exec = require("@actions/exec");
+  const repo_owner = github.context.payload.repository.owner.login;
+  const repo_name = github.context.payload.repository.name;
+  const pr_number = github.context.payload.issue.number;
+  const comment_user = github.context.payload.comment.user.login;
+  let octokit = github.getOctokit(core.getInput("auth_token", { required: true }));
+  let target_branch = core.getInput("target_branch", { required: true });
+  try {
+    try {
+      await octokit.rest.repos.checkCollaborator({
+        owner: repo_owner,
+        repo: repo_name,
+        username: comment_user
+      });
+      console.log(`Verified ${comment_user} is a repo collaborator.`);
+    } catch (error) {
+      console.log(error);
+      throw new BackportException(`Error: @${comment_user} is not a repo collaborator, backporting is not allowed.`);
+    }
+    try { await exec.exec(`git ls-remote --exit-code --heads origin ${target_branch}`) } catch { throw new BackportException(`Error: The specified backport target branch ${target_branch} wasn't found in the repo.`); }
+    console.log(`Backport target branch: ${target_branch}`);
+    console.log("Applying backport patch");
+    await exec.exec(`git checkout ${target_branch}`);
+    await exec.exec(`git clean -xdff`);
+    await exec.exec(`git config user.name "github-actions"`);
+    await exec.exec(`git config user.email "github-actions@github.com"`);
+    const temp_branch = `backport/pr-${pr_number}-to-${target_branch}`;
+    await exec.exec(`git checkout -b ${temp_branch}`);
+    let should_open_pull_request = true;
+    try {
+      await exec.exec(`git ls-remote --exit-code --heads origin ${temp_branch}`);
+      should_open_pull_request = false;
+    } catch { }
+    await exec.exec(`curl -sSL "${github.context.payload.issue.pull_request.patch_url}" --output changes.patch`);
+    const git_am_command = "git am --3way --ignore-whitespace --keep-non-patch changes.patch";
+    let git_am_output = `$ ${git_am_command}\n\n`;
+    let git_am_failed = false;
+    try {
+      await exec.exec(git_am_command, [], {
+        listeners: {
+          stdout: function stdout(data) { git_am_output += data; },
+          stderr: function stderr(data) { git_am_output += data; }
+        }
+      });
+    } catch (error) {
+      git_am_output += error;
+      git_am_failed = true;
+    }
+    if (git_am_failed) {
+      const git_am_failed_body = `@${github.context.payload.comment.user.login} backporting to ${target_branch} failed, the patch most likely resulted in conflicts:\n\n\`\`\`shell\n${git_am_output}\n\`\`\`\n\nPlease backport manually!`;
+      await octokit.rest.issues.createComment({
+        owner: repo_owner,
+        repo: repo_name,
+        issue_number: pr_number,
+        body: git_am_failed_body
+      });
+      throw new BackportException("Error: git am failed, most likely due to a merge conflict.", false);
+    }
+    else {
+      await exec.exec(`git push --force --set-upstream origin HEAD:${temp_branch}`);
+    }
+    if (!should_open_pull_request) {
+      console.log("Backport temp branch already exists, skipping opening a PR.");
+      return;
+    }
+    let backport_pr_title = core.getInput("pr_title_template");
+    let backport_pr_description = core.getInput("pr_description_template");
+    let cc_users = `@${comment_user}`;
+    if (comment_user != github.context.payload.issue.user.login) cc_users += ` @${github.context.payload.issue.user.login}`;
+    backport_pr_title = backport_pr_title
+      .replace(/%target_branch%/g, target_branch)
+      .replace(/%source_pr_title%/g, github.context.payload.issue.title)
+      .replace(/%source_pr_number%/g, github.context.payload.issue.number)
+      .replace(/%cc_users%/g, cc_users);
+    backport_pr_description = backport_pr_description
+      .replace(/%target_branch%/g, target_branch)
+      .replace(/%source_pr_title%/g, github.context.payload.issue.title)
+      .replace(/%source_pr_number%/g, github.context.payload.issue.number)
+      .replace(/%cc_users%/g, cc_users);
+    await octokit.rest.pulls.create({
+      owner: repo_owner,
+      repo: repo_name,
+      title: backport_pr_title,
+      body: backport_pr_description,
+      head: temp_branch,
+      base: target_branch
+    });
+    console.log("Successfully opened the GitHub PR.");
+  } catch (error) {
+    core.setFailed(error);
+    if (error.postToGitHub === undefined || error.postToGitHub == true) {
+      const unknown_error_body = `@${comment_user} an error occurred while backporting to ${target_branch}, please check the run log for details!\n\n${error.message}`;
+      await octokit.rest.issues.createComment({
+        owner: repo_owner,
+        repo: repo_name,
+        issue_number: pr_number,
+        body: unknown_error_body
+      });
+    }
+  }
+}
+run();

--- a//dev/null
+++ b/eng/build.sh
@@ -0,0 +1,419 @@
+set -ue
+source="${BASH_SOURCE[0]}"
+while [[ -h "$source" ]]; do
+  scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+  source="$(readlink "$source")"
+  [[ $source != /* ]] && source="$scriptroot/$source"
+done
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+usage()
+{
+  echo "Common settings:"
+  echo "  --arch (-a)                     Target platform: x86, x64, arm, armel, arm64, s390x or wasm."
+  echo "                                  [Default: Your machine's architecture.]"
+  echo "  --binaryLog (-bl)               Output binary log."
+  echo "  --cross                         Optional argument to signify cross compilation."
+  echo "  --configuration (-c)            Build configuration: Debug, Release or Checked."
+  echo "                                  Checked is exclusive to the CLR subset. It is the same as Debug, except code is"
+  echo "                                  compiled with optimizations enabled."
+  echo "                                  [Default: Debug]"
+  echo "  --help (-h)                     Print help and exit."
+  echo "  --librariesConfiguration (-lc)  Libraries build configuration: Debug or Release."
+  echo "                                  [Default: Debug]"
+  echo "  --os                            Target operating system: windows, Linux, FreeBSD, OSX, MacCatalyst, tvOS,"
+  echo "                                  tvOSSimulator, iOS, iOSSimulator, Android, Browser, NetBSD, illumos or Solaris."
+  echo "                                  [Default: Your machine's OS.]"
+  echo "  --projects <value>              Project or solution file(s) to build."
+  echo "  --runtimeConfiguration (-rc)    Runtime build configuration: Debug, Release or Checked."
+  echo "                                  Checked is exclusive to the CLR runtime. It is the same as Debug, except code is"
+  echo "                                  compiled with optimizations enabled."
+  echo "                                  [Default: Debug]"
+  echo "  -runtimeFlavor (-rf)            Runtime flavor: CoreCLR or Mono."
+  echo "                                  [Default: CoreCLR]"
+  echo "  --subset (-s)                   Build a subset, print available subsets with -subset help."
+  echo "                                 '--subset' can be omitted if the subset is given as the first argument."
+  echo "                                  [Default: Builds the entire repo.]"
+  echo "  --verbosity (-v)                MSBuild verbosity: q[uiet], m[inimal], n[ormal], d[etailed], and diag[nostic]."
+  echo "                                  [Default: Minimal]"
+  echo ""
+  echo "Actions (defaults to --restore --build):"
+  echo "  --build (-b)               Build all source projects."
+  echo "                             This assumes --restore has been run already."
+  echo "  --clean                    Clean the solution."
+  echo "  --pack                     Package build outputs into NuGet packages."
+  echo "  --publish                  Publish artifacts (e.g. symbols)."
+  echo "                             This assumes --build has been run already."
+  echo "  --rebuild                  Rebuild all source projects."
+  echo "  --restore (-r)             Restore dependencies."
+  echo "  --sign                     Sign build outputs."
+  echo "  --test (-t)                Incrementally builds and runs tests."
+  echo "                             Use in conjuction with --testnobuild to only run tests."
+  echo ""
+  echo "Libraries settings:"
+  echo "  --allconfigurations        Build packages for all build configurations."
+  echo "  --coverage                 Collect code coverage when testing."
+  echo "  --framework (-f)           Build framework: net6.0 or net48."
+  echo "                             [Default: net6.0]"
+  echo "  --testnobuild              Skip building tests when invoking -test."
+  echo "  --testscope                Test scope, allowed values: innerloop, outerloop, all."
+  echo ""
+  echo "Native build settings:"
+  echo "  --clang                    Optional argument to build using clang in PATH (default)."
+  echo "  --clangx                   Optional argument to build using clang version x (used for Clang 7 and newer)."
+  echo "  --clangx.y                 Optional argument to build using clang version x.y (used for Clang 6 and older)."
+  echo "  --cmakeargs                User-settable additional arguments passed to CMake."
+  echo "  --gcc                      Optional argument to build using gcc in PATH (default)."
+  echo "  --gccx.y                   Optional argument to build using gcc version x.y."
+  echo "  --portablebuild            Optional argument: set to false to force a non-portable build."
+  echo "  --keepnativesymbols        Optional argument: set to true to keep native symbols/debuginfo in generated binaries."
+  echo "  --ninja                    Optional argument: set to true to use Ninja instead of Make to run the native build."
+  echo "  --pgoinstrument            Optional argument: build PGO-instrumented runtime"
+  echo ""
+  echo "Command line arguments starting with '/p:' are passed through to MSBuild."
+  echo "Arguments can also be passed in with a single hyphen."
+  echo ""
+  echo "Here are some quick examples. These assume you are on a Linux x64 machine:"
+  echo ""
+  echo "* Build CoreCLR for Linux x64 on Release configuration:"
+  echo "./build.sh clr -c release"
+  echo ""
+  echo "* Build Debug libraries with a Release runtime for Linux x64."
+  echo "./build.sh clr+libs -rc release"
+  echo ""
+  echo "* Build Release libraries and their tests with a Checked runtime for Linux x64, and run the tests."
+  echo "./build.sh clr+libs+libs.tests -rc checked -lc release -test"
+  echo ""
+  echo "* Build CoreCLR for Linux x64 on Debug configuration using Clang 9."
+  echo "./build.sh clr -clang9"
+  echo ""
+  echo "* Build CoreCLR for Linux x64 on Debug configuration using GCC 8.4."
+  echo "./build.sh clr -gcc8.4"
+  echo ""
+  echo "* Build CoreCLR for Linux x64 using extra compiler flags (-fstack-clash-protection)."
+  echo "EXTRA_CFLAGS=-fstack-clash-protection EXTRA_CXXFLAGS=-fstack-clash-protection ./build.sh clr"
+  echo ""
+  echo "* Cross-compile CoreCLR runtime for Linux ARM64 on Release configuration."
+  echo "./build.sh clr.runtime -arch arm64 -c release -cross"
+  echo ""
+  echo "However, for this example, you need to already have ROOTFS_DIR set up."
+  echo "Further information on this can be found here:"
+  echo "https://github.com/dotnet/runtime/blob/main/docs/workflow/building/coreclr/linux-instructions.md"
+  echo ""
+  echo "* Build Mono runtime for Linux x64 on Release configuration."
+  echo "./build.sh mono -c release"
+  echo ""
+  echo "* Build Release coreclr corelib, crossgen corelib and update Debug libraries testhost to run test on an updated corelib."
+  echo "./build.sh clr.corelib+clr.nativecorelib+libs.pretest -rc release"
+  echo ""
+  echo "* Build Debug mono corelib and update Release libraries testhost to run test on an updated corelib."
+  echo "./build.sh mono.corelib+libs.pretest -rc debug -c release"
+  echo ""
+  echo ""
+  echo "For more general information, check out https://github.com/dotnet/runtime/blob/main/docs/workflow/README.md"
+}
+initDistroRid()
+{
+    source "$scriptroot"/native/init-distro-rid.sh
+    local passedRootfsDir=""
+    local targetOs="$1"
+    local buildArch="$2"
+    local isCrossBuild="$3"
+    local isPortableBuild="$4"
+    if [[ $isCrossBuild == 1 && "$targetOs" != "OSX" ]]; then
+        passedRootfsDir=${ROOTFS_DIR}
+    fi
+    initDistroRidGlobal ${targetOs} ${buildArch} ${isPortableBuild} ${passedRootfsDir}
+}
+showSubsetHelp()
+{
+  "$scriptroot/common/build.sh" "-restore" "-build" "/p:Subset=help" "/clp:nosummary"
+}
+arguments=''
+cmakeargs=''
+extraargs=''
+crossBuild=0
+portableBuild=1
+source $scriptroot/native/init-os-and-arch.sh
+hostArch=$arch
+declare -a actions=("b" "build" "r" "restore" "rebuild" "testnobuild" "sign" "publish" "clean")
+actInt=($(comm -12 <(printf '%s\n' "${actions[@]/#/-}" | sort) <(printf '%s\n' "${@/#--/-}" | sort)))
+firstArgumentChecked=0
+while [[ $# > 0 ]]; do
+  opt="$(echo "${1/#--/-}" | tr "[:upper:]" "[:lower:]")"
+  if [[ $firstArgumentChecked -eq 0 && $opt =~ ^[a-zA-Z.+]+$ ]]; then
+    if [ $opt == "help" ]; then
+      showSubsetHelp
+      exit 0
+    fi
+    arguments="$arguments /p:Subset=$1"
+    shift 1
+    continue
+  fi
+  firstArgumentChecked=1
+  case "$opt" in
+     -help|-h|-\?|/?)
+      usage
+      exit 0
+      ;;
+     -subset|-s)
+      if [ -z ${2+x} ]; then
+        showSubsetHelp
+        exit 0
+      else
+        passedSubset="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+        if [ $passedSubset == "help" ]; then
+          showSubsetHelp
+          exit 0
+        fi
+        arguments="$arguments /p:Subset=$2"
+        shift 2
+      fi
+      ;;
+     -arch|-a)
+      if [ -z ${2+x} ]; then
+        echo "No architecture supplied. See help (--help) for supported architectures." 1>&2
+        exit 1
+      fi
+      passedArch="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      case "$passedArch" in
+        x64|x86|arm|armel|arm64|s390x|wasm)
+          arch=$passedArch
+          ;;
+        *)
+          echo "Unsupported target architecture '$2'."
+          echo "The allowed values are x86, x64, arm, armel, arm64, s390x, and wasm."
+          exit 1
+          ;;
+      esac
+      shift 2
+      ;;
+     -configuration|-c)
+      if [ -z ${2+x} ]; then
+        echo "No configuration supplied. See help (--help) for supported configurations." 1>&2
+        exit 1
+      fi
+      passedConfig="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      case "$passedConfig" in
+        debug|release|checked)
+          val="$(tr '[:lower:]' '[:upper:]' <<< ${passedConfig:0:1})${passedConfig:1}"
+          ;;
+        *)
+          echo "Unsupported target configuration '$2'."
+          echo "The allowed values are Debug, Release, and Checked."
+          exit 1
+          ;;
+      esac
+      arguments="$arguments -configuration $val"
+      shift 2
+      ;;
+     -framework|-f)
+      if [ -z ${2+x} ]; then
+        echo "No framework supplied. See help (--help) for supported frameworks." 1>&2
+        exit 1
+      fi
+      val="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      arguments="$arguments /p:BuildTargetFramework=$val"
+      shift 2
+      ;;
+     -os)
+      if [ -z ${2+x} ]; then
+        echo "No target operating system supplied. See help (--help) for supported target operating systems." 1>&2
+        exit 1
+      fi
+      passedOS="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      case "$passedOS" in
+        windows)
+          os="windows" ;;
+        linux)
+          os="Linux" ;;
+        freebsd)
+          os="FreeBSD" ;;
+        osx)
+          os="OSX" ;;
+        maccatalyst)
+          os="MacCatalyst" ;;
+        tvos)
+          os="tvOS" ;;
+        tvossimulator)
+          os="tvOSSimulator" ;;
+        ios)
+          os="iOS" ;;
+        iossimulator)
+          os="iOSSimulator" ;;
+        android)
+          os="Android" ;;
+        browser)
+          os="Browser" ;;
+        illumos)
+          os="illumos" ;;
+        solaris)
+          os="Solaris" ;;
+        *)
+          echo "Unsupported target OS '$2'."
+          echo "The allowed values are windows, Linux, FreeBSD, OSX, MacCatalyst, tvOS, tvOSSimulator, iOS, iOSSimulator, Android, Browser, illumos and Solaris."
+          exit 1
+          ;;
+      esac
+      arguments="$arguments /p:TargetOS=$os"
+      shift 2
+      ;;
+     -allconfigurations)
+      arguments="$arguments /p:BuildAllConfigurations=true"
+      shift 1
+      ;;
+     -testscope)
+      if [ -z ${2+x} ]; then
+        echo "No test scope supplied. See help (--help) for supported test scope values." 1>&2
+        exit 1
+      fi
+      arguments="$arguments /p:TestScope=$2"
+      shift 2
+      ;;
+     -testnobuild)
+      arguments="$arguments /p:TestNoBuild=true"
+      shift 1
+      ;;
+     -coverage)
+      arguments="$arguments /p:Coverage=true"
+      shift 1
+      ;;
+     -runtimeconfiguration|-rc)
+      if [ -z ${2+x} ]; then
+        echo "No runtime configuration supplied. See help (--help) for supported runtime configurations." 1>&2
+        exit 1
+      fi
+      passedRuntimeConf="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      case "$passedRuntimeConf" in
+        debug|release|checked)
+          val="$(tr '[:lower:]' '[:upper:]' <<< ${passedRuntimeConf:0:1})${passedRuntimeConf:1}"
+          ;;
+        *)
+          echo "Unsupported runtime configuration '$2'."
+          echo "The allowed values are Debug, Release, and Checked."
+          exit 1
+          ;;
+      esac
+      arguments="$arguments /p:RuntimeConfiguration=$val"
+      shift 2
+      ;;
+     -runtimeflavor|-rf)
+      if [ -z ${2+x} ]; then
+        echo "No runtime flavor supplied. See help (--help) for supported runtime flavors." 1>&2
+        exit 1
+      fi
+      passedRuntimeFlav="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      case "$passedRuntimeFlav" in
+        coreclr|mono)
+          val="$(tr '[:lower:]' '[:upper:]' <<< ${passedRuntimeFlav:0:1})${passedRuntimeFlav:1}"
+          ;;
+        *)
+          echo "Unsupported runtime flavor '$2'."
+          echo "The allowed values are CoreCLR and Mono."
+          exit 1
+          ;;
+      esac
+      arguments="$arguments /p:RuntimeFlavor=$val"
+      shift 2
+      ;;
+     -librariesconfiguration|-lc)
+      if [ -z ${2+x} ]; then
+        echo "No libraries configuration supplied. See help (--help) for supported libraries configurations." 1>&2
+        exit 1
+      fi
+      passedLibConf="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      case "$passedLibConf" in
+        debug|release)
+          val="$(tr '[:lower:]' '[:upper:]' <<< ${passedLibConf:0:1})${passedLibConf:1}"
+          ;;
+        *)
+          echo "Unsupported libraries configuration '$2'."
+          echo "The allowed values are Debug and Release."
+          exit 1
+          ;;
+      esac
+      arguments="$arguments /p:LibrariesConfiguration=$val"
+      shift 2
+      ;;
+     -cross)
+      crossBuild=1
+      arguments="$arguments /p:CrossBuild=True"
+      shift 1
+      ;;
+     -clang*)
+      arguments="$arguments /p:Compiler=$opt"
+      shift 1
+      ;;
+     -cmakeargs)
+      if [ -z ${2+x} ]; then
+        echo "No cmake args supplied." 1>&2
+        exit 1
+      fi
+      cmakeargs="${cmakeargs} ${opt} $2"
+      shift 2
+      ;;
+     -gcc*)
+      arguments="$arguments /p:Compiler=$opt"
+      shift 1
+      ;;
+     -portablebuild)
+      if [ -z ${2+x} ]; then
+        echo "No value for portablebuild is supplied. See help (--help) for supported values." 1>&2
+        exit 1
+      fi
+      passedPortable="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      if [ "$passedPortable" = false ]; then
+        portableBuild=0
+        arguments="$arguments /p:PortableBuild=false"
+      fi
+      shift 2
+      ;;
+     -keepnativesymbols)
+      if [ -z ${2+x} ]; then
+        echo "No value for keepNativeSymbols is supplied. See help (--help) for supported values." 1>&2
+        exit 1
+      fi
+      passedKeepNativeSymbols="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      if [ "$passedKeepNativeSymbols" = true ]; then
+        arguments="$arguments /p:KeepNativeSymbols=true"
+      fi
+      shift 2
+      ;;
+      -ninja)
+      if [ -z ${2+x} ]; then
+        arguments="$arguments /p:Ninja=true"
+        shift 1
+      else
+        ninja="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+        if [ "$ninja" = true ]; then
+          arguments="$arguments /p:Ninja=true"
+          shift 2
+        elif [ "$ninja" = false ]; then
+          arguments="$arguments /p:Ninja=false"
+          shift 2
+        else
+          arguments="$arguments /p:Ninja=true"
+          shift 1
+        fi
+      fi
+      ;;
+      -pgoinstrument)
+      arguments="$arguments /p:PgoInstrument=true"
+      shift 1
+      ;;
+      *)
+      extraargs="$extraargs $1"
+      shift 1
+      ;;
+  esac
+done
+if [ ${#actInt[@]} -eq 0 ]; then
+    arguments="-restore -build $arguments"
+fi
+if [ "$os" = "Browser" ] && [ "$arch" != "wasm" ]; then
+    arch=wasm
+fi
+initDistroRid $os $arch $crossBuild $portableBuild
+cmakeargs="${cmakeargs// /%20}"
+arguments="$arguments /p:TargetArchitecture=$arch /p:BuildArchitecture=$hostArch"
+arguments="$arguments /p:CMakeArgs=\"$cmakeargs\" $extraargs"
+"$scriptroot/common/build.sh" $arguments

--- a//dev/null
+++ b/eng/common/SetupNugetSources.sh
@@ -0,0 +1,125 @@
+ConfigFile=$1
+CredToken=$2
+NL='\n'
+TB='    '
+source="${BASH_SOURCE[0]}"
+while [[ -h "$source" ]]; do
+  scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+  source="$(readlink "$source")"
+  [[ $source != /* ]] && source="$scriptroot/$source"
+done
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+. "$scriptroot/tools.sh"
+if [ ! -f "$ConfigFile" ]; then
+    Write-PipelineTelemetryError -Category 'Build' "Error: Eng/common/SetupNugetSources.sh returned a non-zero exit code. Couldn't find the NuGet config file: $ConfigFile"
+    ExitWithExitCode 1
+fi
+if [ -z "$CredToken" ]; then
+    Write-PipelineTelemetryError -category 'Build' "Error: Eng/common/SetupNugetSources.sh returned a non-zero exit code. Please supply a valid PAT"
+    ExitWithExitCode 1
+fi
+if [[ `uname -s` == "Darwin" ]]; then
+    NL=$'\\\n'
+    TB=''
+fi
+grep -i "<packageSources>" $ConfigFile
+if [ "$?" != "0" ]; then
+    echo "Adding <packageSources>...</packageSources> section."
+    ConfigNodeHeader="<configuration>"
+    PackageSourcesTemplate="${TB}<packageSources>${NL}${TB}</packageSources>"
+    sed -i.bak "s|$ConfigNodeHeader|$ConfigNodeHeader${NL}$PackageSourcesTemplate|" $ConfigFile
+fi
+grep -i "<packageSourceCredentials>" $ConfigFile
+if [ "$?" != "0" ]; then
+    echo "Adding <packageSourceCredentials>...</packageSourceCredentials> section."
+    PackageSourcesNodeFooter="</packageSources>"
+    PackageSourceCredentialsTemplate="${TB}<packageSourceCredentials>${NL}${TB}</packageSourceCredentials>"
+    sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourcesNodeFooter${NL}$PackageSourceCredentialsTemplate|" $ConfigFile
+fi
+PackageSources=()
+grep -i "<add key=\"dotnet3.1\"" $ConfigFile
+if [ "$?" == "0" ]; then
+    grep -i "<add key=\"dotnet3.1-internal\"" $ConfigFile
+    if [ "$?" != "0" ]; then
+        echo "Adding dotnet3.1-internal to the packageSources."
+        PackageSourcesNodeFooter="</packageSources>"
+        PackageSourceTemplate="${TB}<add key=\"dotnet3.1-internal\" value=\"https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal/nuget/v2\" />"
+        sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
+    fi
+    PackageSources+=('dotnet3.1-internal')
+    grep -i "<add key=\"dotnet3.1-internal-transport\">" $ConfigFile
+    if [ "$?" != "0" ]; then
+        echo "Adding dotnet3.1-internal-transport to the packageSources."
+        PackageSourcesNodeFooter="</packageSources>"
+        PackageSourceTemplate="${TB}<add key=\"dotnet3.1-internal-transport\" value=\"https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-transport/nuget/v2\" />"
+        sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
+    fi
+    PackageSources+=('dotnet3.1-internal-transport')
+fi
+grep -i "<add key=\"dotnet5\"" $ConfigFile
+if [ "$?" == "0" ]; then
+    grep -i "<add key=\"dotnet5-internal\"" $ConfigFile
+    if [ "$?" != "0" ]; then
+        echo "Adding dotnet5-internal to the packageSources."
+        PackageSourcesNodeFooter="</packageSources>"
+        PackageSourceTemplate="${TB}<add key=\"dotnet5-internal\" value=\"https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet5-internal/nuget/v2\" />"
+        sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
+    fi
+    PackageSources+=('dotnet5-internal')
+    grep -i "<add key=\"dotnet5-internal-transport\">" $ConfigFile
+    if [ "$?" != "0" ]; then
+        echo "Adding dotnet5-internal-transport to the packageSources."
+        PackageSourcesNodeFooter="</packageSources>"
+        PackageSourceTemplate="${TB}<add key=\"dotnet5-internal-transport\" value=\"https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet5-internal-transport/nuget/v2\" />"
+        sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
+    fi
+    PackageSources+=('dotnet5-internal-transport')
+fi
+grep -i "<add key=\"dotnet6\"" $ConfigFile
+if [ "$?" == "0" ]; then
+    grep -i "<add key=\"dotnet6-internal\"" $ConfigFile
+    if [ "$?" != "0" ]; then
+        echo "Adding dotnet6-internal to the packageSources."
+        PackageSourcesNodeFooter="</packageSources>"
+        PackageSourceTemplate="${TB}<add key=\"dotnet6-internal\" value=\"https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet6-internal/nuget/v2\" />"
+        sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
+    fi
+    PackageSources+=('dotnet6-internal')
+    grep -i "<add key=\"dotnet6-internal-transport\">" $ConfigFile
+    if [ "$?" != "0" ]; then
+        echo "Adding dotnet6-internal-transport to the packageSources."
+        PackageSourcesNodeFooter="</packageSources>"
+        PackageSourceTemplate="${TB}<add key=\"dotnet6-internal-transport\" value=\"https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet6-internal-transport/nuget/v2\" />"
+        sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
+    fi
+    PackageSources+=('dotnet6-internal-transport')
+fi
+PrevIFS=$IFS
+IFS=$'\n'
+PackageSources+="$IFS"
+PackageSources+=$(grep -oh '"darc-int-[^"]*"' $ConfigFile | tr -d '"')
+IFS=$PrevIFS
+for FeedName in ${PackageSources[@]} ; do
+    grep -i "<$FeedName>" $ConfigFile 
+    if [ "$?" != "0" ]; then
+        echo "Adding credentials for $FeedName."
+        PackageSourceCredentialsNodeFooter="</packageSourceCredentials>"
+        NewCredential="${TB}${TB}<$FeedName>${NL}<add key=\"Username\" value=\"dn-bot\" />${NL}<add key=\"ClearTextPassword\" value=\"$CredToken\" />${NL}</$FeedName>"
+        sed -i.bak "s|$PackageSourceCredentialsNodeFooter|$NewCredential${NL}$PackageSourceCredentialsNodeFooter|" $ConfigFile
+    fi
+done
+grep -i "<disabledPackageSources>" $ConfigFile
+if [ "$?" == "0" ]; then
+    DisabledDarcIntSources=()
+    echo "Re-enabling any disabled \"darc-int\" package sources in $ConfigFile"
+    DisabledDarcIntSources+=$(grep -oh '"darc-int-[^"]*" value="true"' $ConfigFile  | tr -d '"')
+    for DisabledSourceName in ${DisabledDarcIntSources[@]} ; do
+        if [[ $DisabledSourceName == darc-int* ]]
+            then
+                OldDisableValue="<add key=\"$DisabledSourceName\" value=\"true\" />"
+                NewDisableValue="<!-- Reenabled for build : $DisabledSourceName -->"
+                sed -i.bak "s|$OldDisableValue|$NewDisableValue|" $ConfigFile
+                echo "Neutralized disablePackageSources entry for '$DisabledSourceName'"
+        fi
+    done
+fi

--- a//dev/null
+++ b/eng/common/build.sh
@@ -0,0 +1,204 @@
+set -u
+set -e
+usage()
+{
+  echo "Common settings:"
+  echo "  --configuration <value>    Build configuration: 'Debug' or 'Release' (short: -c)"
+  echo "  --verbosity <value>        Msbuild verbosity: q[uiet], m[inimal], n[ormal], d[etailed], and diag[nostic] (short: -v)"
+  echo "  --binaryLog                Create MSBuild binary log (short: -bl)"
+  echo "  --help                     Print help and exit (short: -h)"
+  echo ""
+  echo "Actions:"
+  echo "  --restore                  Restore dependencies (short: -r)"
+  echo "  --build                    Build solution (short: -b)"
+  echo "  --rebuild                  Rebuild solution"
+  echo "  --test                     Run all unit tests in the solution (short: -t)"
+  echo "  --integrationTest          Run all integration tests in the solution"
+  echo "  --performanceTest          Run all performance tests in the solution"
+  echo "  --pack                     Package build outputs into NuGet packages and Willow components"
+  echo "  --sign                     Sign build outputs"
+  echo "  --publish                  Publish artifacts (e.g. symbols)"
+  echo "  --clean                    Clean the solution"
+  echo ""
+  echo "Advanced settings:"
+  echo "  --projects <value>       Project or solution file(s) to build"
+  echo "  --ci                     Set when running on CI server"
+  echo "  --excludeCIBinarylog     Don't output binary log (short: -nobl)"
+  echo "  --prepareMachine         Prepare machine for CI run, clean up processes after build"
+  echo "  --nodeReuse <value>      Sets nodereuse msbuild parameter ('true' or 'false')"
+  echo "  --warnAsError <value>    Sets warnaserror msbuild parameter ('true' or 'false')"
+  echo ""
+  echo "Command line arguments not listed above are passed thru to msbuild."
+  echo "Arguments can also be passed in with a single hyphen."
+}
+source="${BASH_SOURCE[0]}"
+while [[ -h "$source" ]]; do
+  scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+  source="$(readlink "$source")"
+  [[ $source != /* ]] && source="$scriptroot/$source"
+done
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+restore=false
+build=false
+rebuild=false
+test=false
+integration_test=false
+performance_test=false
+pack=false
+publish=false
+sign=false
+public=false
+ci=false
+clean=false
+warn_as_error=true
+node_reuse=true
+binary_log=false
+exclude_ci_binary_log=false
+pipelines_log=false
+projects=''
+configuration='Debug'
+prepare_machine=false
+verbosity='minimal'
+runtime_source_feed=''
+runtime_source_feed_key=''
+properties=''
+while [[ $# > 0 ]]; do
+  opt="$(echo "${1/#--/-}" | tr "[:upper:]" "[:lower:]")"
+  case "$opt" in
+    -help|-h)
+      usage
+      exit 0
+      ;;
+    -clean)
+      clean=true
+      ;;
+    -configuration|-c)
+      configuration=$2
+      shift
+      ;;
+    -verbosity|-v)
+      verbosity=$2
+      shift
+      ;;
+    -binarylog|-bl)
+      binary_log=true
+      ;;
+    -excludeCIBinarylog|-nobl)
+      exclude_ci_binary_log=true
+      ;;
+    -pipelineslog|-pl)
+      pipelines_log=true
+      ;;
+    -restore|-r)
+      restore=true
+      ;;
+    -build|-b)
+      build=true
+      ;;
+    -rebuild)
+      rebuild=true
+      ;;
+    -pack)
+      pack=true
+      ;;
+    -test|-t)
+      test=true
+      ;;
+    -integrationtest)
+      integration_test=true
+      ;;
+    -performancetest)
+      performance_test=true
+      ;;
+    -sign)
+      sign=true
+      ;;
+    -publish)
+      publish=true
+      ;;
+    -preparemachine)
+      prepare_machine=true
+      ;;
+    -projects)
+      projects=$2
+      shift
+      ;;
+    -ci)
+      ci=true
+      ;;
+    -warnaserror)
+      warn_as_error=$2
+      shift
+      ;;
+    -nodereuse)
+      node_reuse=$2
+      shift
+      ;;
+    -runtimesourcefeed)
+      runtime_source_feed=$2
+      shift
+      ;;
+     -runtimesourcefeedkey)
+      runtime_source_feed_key=$2
+      shift
+      ;;
+    *)
+      properties="$properties $1"
+      ;;
+  esac
+  shift
+done
+if [[ "$ci" == true ]]; then
+  pipelines_log=true
+  node_reuse=false
+  if [[ "$exclude_ci_binary_log" == false ]]; then
+    binary_log=true
+  fi
+fi
+. "$scriptroot/tools.sh"
+function InitializeCustomToolset {
+  local script="$eng_root/restore-toolset.sh"
+  if [[ -a "$script" ]]; then
+    . "$script"
+  fi
+}
+function Build {
+  if [[ "$ci" == true ]]; then
+    TryLogClientIpAddress
+  fi
+  InitializeToolset
+  InitializeCustomToolset
+  if [[ ! -z "$projects" ]]; then
+    properties="$properties /p:Projects=$projects"
+  fi
+  local bl=""
+  if [[ "$binary_log" == true ]]; then
+    bl="/bl:\"$log_dir/Build.binlog\""
+  fi
+  MSBuild $_InitializeToolset \
+    $bl \
+    /p:Configuration=$configuration \
+    /p:RepoRoot="$repo_root" \
+    /p:Restore=$restore \
+    /p:Build=$build \
+    /p:Rebuild=$rebuild \
+    /p:Test=$test \
+    /p:Pack=$pack \
+    /p:IntegrationTest=$integration_test \
+    /p:PerformanceTest=$performance_test \
+    /p:Sign=$sign \
+    /p:Publish=$publish \
+    $properties
+  ExitWithExitCode 0
+}
+if [[ "$clean" == true ]]; then
+  if [ -d "$artifacts_dir" ]; then
+    rm -rf $artifacts_dir
+    echo "Artifacts directory deleted."
+  fi
+  exit 0
+fi
+if [[ "$restore" == true ]]; then
+  InitializeNativeTools
+fi
+Build

--- a//dev/null
+++ b/eng/common/cross/arm64/tizen-build-rootfs.sh
@@ -0,0 +1,24 @@
+set -e
+__CrossDir=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
+__TIZEN_CROSSDIR="$__CrossDir/tizen"
+if [[ -z "$ROOTFS_DIR" ]]; then
+    echo "ROOTFS_DIR is not defined."
+    exit 1;
+fi
+TIZEN_TMP_DIR=$ROOTFS_DIR/tizen_tmp
+mkdir -p $TIZEN_TMP_DIR
+echo ">>Start downloading files"
+VERBOSE=1 $__CrossDir/tizen-fetch.sh $TIZEN_TMP_DIR
+echo "<<Finish downloading files"
+echo ">>Start constructing Tizen rootfs"
+TIZEN_RPM_FILES=`ls $TIZEN_TMP_DIR/*.rpm`
+cd $ROOTFS_DIR
+for f in $TIZEN_RPM_FILES; do
+    rpm2cpio $f  | cpio -idm --quiet
+done
+echo "<<Finish constructing Tizen rootfs"
+rm -rf $TIZEN_TMP_DIR
+echo ">>Start configuring Tizen rootfs"
+ln -sfn asm-arm64 ./usr/include/asm
+patch -p1 < $__TIZEN_CROSSDIR/tizen.patch
+echo "<<Finish configuring Tizen rootfs"

--- a//dev/null
+++ b/eng/common/cross/arm64/tizen-fetch.sh
@@ -0,0 +1,134 @@
+set -e
+if [[ -z "${VERBOSE// }" ]] || [ "$VERBOSE" -ne "$VERBOSE" ] 2>/dev/null; then
+	VERBOSE=0
+fi
+Log()
+{
+	if [ $VERBOSE -ge $1 ]; then
+		echo ${@:2}
+	fi
+}
+Inform()
+{
+	Log 1 -e "\x1B[0;34m$@\x1B[m"
+}
+Debug()
+{
+	Log 2 -e "\x1B[0;32m$@\x1B[m"
+}
+Error()
+{
+	>&2 Log 0 -e "\x1B[0;31m$@\x1B[m"
+}
+Fetch()
+{
+	URL=$1
+	FILE=$2
+	PROGRESS=$3
+	if [ $VERBOSE -ge 1 ] && [ $PROGRESS ]; then
+		CURL_OPT="--progress-bar"
+	else
+		CURL_OPT="--silent"
+	fi
+	curl $CURL_OPT $URL > $FILE
+}
+hash curl 2> /dev/null || { Error "Require 'curl' Aborting."; exit 1; }
+hash xmllint 2> /dev/null || { Error "Require 'xmllint' Aborting."; exit 1; }
+hash sha256sum 2> /dev/null || { Error "Require 'sha256sum' Aborting."; exit 1; }
+TMPDIR=$1
+if [ ! -d $TMPDIR ]; then
+	TMPDIR=./tizen_tmp
+	Debug "Create temporary directory : $TMPDIR"
+	mkdir -p $TMPDIR
+fi
+TIZEN_URL=http://download.tizen.org/snapshots/tizen/
+BUILD_XML=build.xml
+REPOMD_XML=repomd.xml
+PRIMARY_XML=primary.xml
+TARGET_URL="http://__not_initialized"
+Xpath_get()
+{
+	XPATH_RESULT=''
+	XPATH=$1
+	XML_FILE=$2
+	RESULT=$(xmllint --xpath $XPATH $XML_FILE)
+	if [[ -z ${RESULT// } ]]; then
+		Error "Can not find target from $XML_FILE"
+		Debug "Xpath = $XPATH"
+		exit 1
+	fi
+	XPATH_RESULT=$RESULT
+}
+fetch_tizen_pkgs_init()
+{
+	TARGET=$1
+	PROFILE=$2
+	Debug "Initialize TARGET=$TARGET, PROFILE=$PROFILE"
+	TMP_PKG_DIR=$TMPDIR/tizen_${PROFILE}_pkgs
+	if [ -d $TMP_PKG_DIR ]; then rm -rf $TMP_PKG_DIR; fi
+	mkdir -p $TMP_PKG_DIR
+	PKG_URL=$TIZEN_URL/$PROFILE/latest
+	BUILD_XML_URL=$PKG_URL/$BUILD_XML
+	TMP_BUILD=$TMP_PKG_DIR/$BUILD_XML
+	TMP_REPOMD=$TMP_PKG_DIR/$REPOMD_XML
+	TMP_PRIMARY=$TMP_PKG_DIR/$PRIMARY_XML
+	TMP_PRIMARYGZ=${TMP_PRIMARY}.gz
+	Fetch $BUILD_XML_URL $TMP_BUILD
+	Debug "fetch $BUILD_XML_URL to $TMP_BUILD"
+	TARGET_XPATH="//build/buildtargets/buildtarget[@name=\"$TARGET\"]/repo[@type=\"binary\"]/text()"
+	Xpath_get $TARGET_XPATH $TMP_BUILD
+	TARGET_PATH=$XPATH_RESULT
+	TARGET_URL=$PKG_URL/$TARGET_PATH
+	REPOMD_URL=$TARGET_URL/repodata/repomd.xml
+	PRIMARY_XPATH='string(//*[local-name()="data"][@type="primary"]/*[local-name()="location"]/@href)'
+	Fetch $REPOMD_URL $TMP_REPOMD
+	Debug "fetch $REPOMD_URL to $TMP_REPOMD"
+	Xpath_get $PRIMARY_XPATH $TMP_REPOMD
+	PRIMARY_XML_PATH=$XPATH_RESULT
+	PRIMARY_URL=$TARGET_URL/$PRIMARY_XML_PATH
+	Fetch $PRIMARY_URL $TMP_PRIMARYGZ
+	Debug "fetch $PRIMARY_URL to $TMP_PRIMARYGZ"
+	gunzip $TMP_PRIMARYGZ
+	Debug "unzip $TMP_PRIMARYGZ to $TMP_PRIMARY"
+}
+fetch_tizen_pkgs()
+{
+	ARCH=$1
+	PACKAGE_XPATH_TPL='string(//*[local-name()="metadata"]/*[local-name()="package"][*[local-name()="name"][text()="_PKG_"]][*[local-name()="arch"][text()="_ARCH_"]]/*[local-name()="location"]/@href)'
+	PACKAGE_CHECKSUM_XPATH_TPL='string(//*[local-name()="metadata"]/*[local-name()="package"][*[local-name()="name"][text()="_PKG_"]][*[local-name()="arch"][text()="_ARCH_"]]/*[local-name()="checksum"]/text())'
+	for pkg in ${@:2}
+	do
+		Inform "Fetching... $pkg"
+		XPATH=${PACKAGE_XPATH_TPL/_PKG_/$pkg}
+		XPATH=${XPATH/_ARCH_/$ARCH}
+		Xpath_get $XPATH $TMP_PRIMARY
+		PKG_PATH=$XPATH_RESULT
+		XPATH=${PACKAGE_CHECKSUM_XPATH_TPL/_PKG_/$pkg}
+		XPATH=${XPATH/_ARCH_/$ARCH}
+		Xpath_get $XPATH $TMP_PRIMARY
+		CHECKSUM=$XPATH_RESULT
+		PKG_URL=$TARGET_URL/$PKG_PATH
+		PKG_FILE=$(basename $PKG_PATH)
+		PKG_PATH=$TMPDIR/$PKG_FILE
+		Debug "Download $PKG_URL to $PKG_PATH"
+		Fetch $PKG_URL $PKG_PATH true
+		echo "$CHECKSUM $PKG_PATH" | sha256sum -c - > /dev/null
+		if [ $? -ne 0 ]; then
+			Error "Fail to fetch $PKG_URL to $PKG_PATH"
+			Debug "Checksum = $CHECKSUM"
+			exit 1
+		fi
+	done
+}
+Inform "Initialize arm base"
+fetch_tizen_pkgs_init standard base
+Inform "fetch common packages"
+fetch_tizen_pkgs aarch64 gcc glibc glibc-devel libicu libicu-devel libatomic linux-glibc-devel keyutils keyutils-devel libkeyutils
+Inform "fetch coreclr packages"
+fetch_tizen_pkgs aarch64 lldb lldb-devel libgcc libstdc++ libstdc++-devel libunwind libunwind-devel lttng-ust-devel lttng-ust userspace-rcu-devel userspace-rcu
+Inform "fetch corefx packages"
+fetch_tizen_pkgs aarch64 libcom_err libcom_err-devel zlib zlib-devel libopenssl11 libopenssl1.1-devel krb5 krb5-devel
+Inform "Initialize standard unified"
+fetch_tizen_pkgs_init standard unified
+Inform "fetch corefx packages"
+fetch_tizen_pkgs aarch64 gssdp gssdp-devel tizen-release

--- a//dev/null
+++ b/eng/common/cross/armel/tizen-build-rootfs.sh
@@ -0,0 +1,24 @@
+set -e
+__ARM_SOFTFP_CrossDir=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
+__TIZEN_CROSSDIR="$__ARM_SOFTFP_CrossDir/tizen"
+if [[ -z "$ROOTFS_DIR" ]]; then
+    echo "ROOTFS_DIR is not defined."
+    exit 1;
+fi
+TIZEN_TMP_DIR=$ROOTFS_DIR/tizen_tmp
+mkdir -p $TIZEN_TMP_DIR
+echo ">>Start downloading files"
+VERBOSE=1 $__ARM_SOFTFP_CrossDir/tizen-fetch.sh $TIZEN_TMP_DIR
+echo "<<Finish downloading files"
+echo ">>Start constructing Tizen rootfs"
+TIZEN_RPM_FILES=`ls $TIZEN_TMP_DIR/*.rpm`
+cd $ROOTFS_DIR
+for f in $TIZEN_RPM_FILES; do
+    rpm2cpio $f  | cpio -idm --quiet
+done
+echo "<<Finish constructing Tizen rootfs"
+rm -rf $TIZEN_TMP_DIR
+echo ">>Start configuring Tizen rootfs"
+ln -sfn asm-arm ./usr/include/asm
+patch -p1 < $__TIZEN_CROSSDIR/tizen.patch
+echo "<<Finish configuring Tizen rootfs"

--- a//dev/null
+++ b/eng/common/cross/armel/tizen-fetch.sh
@@ -0,0 +1,134 @@
+set -e
+if [[ -z "${VERBOSE// }" ]] || [ "$VERBOSE" -ne "$VERBOSE" ] 2>/dev/null; then
+	VERBOSE=0
+fi
+Log()
+{
+	if [ $VERBOSE -ge $1 ]; then
+		echo ${@:2}
+	fi
+}
+Inform()
+{
+	Log 1 -e "\x1B[0;34m$@\x1B[m"
+}
+Debug()
+{
+	Log 2 -e "\x1B[0;32m$@\x1B[m"
+}
+Error()
+{
+	>&2 Log 0 -e "\x1B[0;31m$@\x1B[m"
+}
+Fetch()
+{
+	URL=$1
+	FILE=$2
+	PROGRESS=$3
+	if [ $VERBOSE -ge 1 ] && [ $PROGRESS ]; then
+		CURL_OPT="--progress-bar"
+	else
+		CURL_OPT="--silent"
+	fi
+	curl $CURL_OPT $URL > $FILE
+}
+hash curl 2> /dev/null || { Error "Require 'curl' Aborting."; exit 1; }
+hash xmllint 2> /dev/null || { Error "Require 'xmllint' Aborting."; exit 1; }
+hash sha256sum 2> /dev/null || { Error "Require 'sha256sum' Aborting."; exit 1; }
+TMPDIR=$1
+if [ ! -d $TMPDIR ]; then
+	TMPDIR=./tizen_tmp
+	Debug "Create temporary directory : $TMPDIR"
+	mkdir -p $TMPDIR 
+fi
+TIZEN_URL=http://download.tizen.org/snapshots/tizen
+BUILD_XML=build.xml
+REPOMD_XML=repomd.xml
+PRIMARY_XML=primary.xml
+TARGET_URL="http://__not_initialized"
+Xpath_get()
+{
+	XPATH_RESULT=''
+	XPATH=$1
+	XML_FILE=$2
+	RESULT=$(xmllint --xpath $XPATH $XML_FILE)
+	if [[ -z ${RESULT// } ]]; then
+		Error "Can not find target from $XML_FILE"
+		Debug "Xpath = $XPATH"
+		exit 1
+	fi
+	XPATH_RESULT=$RESULT
+}
+fetch_tizen_pkgs_init()
+{
+	TARGET=$1
+	PROFILE=$2
+	Debug "Initialize TARGET=$TARGET, PROFILE=$PROFILE"
+	TMP_PKG_DIR=$TMPDIR/tizen_${PROFILE}_pkgs
+	if [ -d $TMP_PKG_DIR ]; then rm -rf $TMP_PKG_DIR; fi
+	mkdir -p $TMP_PKG_DIR
+	PKG_URL=$TIZEN_URL/$PROFILE/latest
+	BUILD_XML_URL=$PKG_URL/$BUILD_XML
+	TMP_BUILD=$TMP_PKG_DIR/$BUILD_XML
+	TMP_REPOMD=$TMP_PKG_DIR/$REPOMD_XML
+	TMP_PRIMARY=$TMP_PKG_DIR/$PRIMARY_XML
+	TMP_PRIMARYGZ=${TMP_PRIMARY}.gz
+	Fetch $BUILD_XML_URL $TMP_BUILD
+	Debug "fetch $BUILD_XML_URL to $TMP_BUILD"
+	TARGET_XPATH="//build/buildtargets/buildtarget[@name=\"$TARGET\"]/repo[@type=\"binary\"]/text()"
+	Xpath_get $TARGET_XPATH $TMP_BUILD
+	TARGET_PATH=$XPATH_RESULT
+	TARGET_URL=$PKG_URL/$TARGET_PATH
+	REPOMD_URL=$TARGET_URL/repodata/repomd.xml
+	PRIMARY_XPATH='string(//*[local-name()="data"][@type="primary"]/*[local-name()="location"]/@href)'
+	Fetch $REPOMD_URL $TMP_REPOMD
+	Debug "fetch $REPOMD_URL to $TMP_REPOMD"
+	Xpath_get $PRIMARY_XPATH $TMP_REPOMD
+	PRIMARY_XML_PATH=$XPATH_RESULT
+	PRIMARY_URL=$TARGET_URL/$PRIMARY_XML_PATH
+	Fetch $PRIMARY_URL $TMP_PRIMARYGZ
+	Debug "fetch $PRIMARY_URL to $TMP_PRIMARYGZ"
+	gunzip $TMP_PRIMARYGZ 
+	Debug "unzip $TMP_PRIMARYGZ to $TMP_PRIMARY" 
+}
+fetch_tizen_pkgs()
+{
+	ARCH=$1
+	PACKAGE_XPATH_TPL='string(//*[local-name()="metadata"]/*[local-name()="package"][*[local-name()="name"][text()="_PKG_"]][*[local-name()="arch"][text()="_ARCH_"]]/*[local-name()="location"]/@href)'
+	PACKAGE_CHECKSUM_XPATH_TPL='string(//*[local-name()="metadata"]/*[local-name()="package"][*[local-name()="name"][text()="_PKG_"]][*[local-name()="arch"][text()="_ARCH_"]]/*[local-name()="checksum"]/text())'
+	for pkg in ${@:2}
+	do
+		Inform "Fetching... $pkg"
+		XPATH=${PACKAGE_XPATH_TPL/_PKG_/$pkg}
+		XPATH=${XPATH/_ARCH_/$ARCH}
+		Xpath_get $XPATH $TMP_PRIMARY
+		PKG_PATH=$XPATH_RESULT
+		XPATH=${PACKAGE_CHECKSUM_XPATH_TPL/_PKG_/$pkg}
+		XPATH=${XPATH/_ARCH_/$ARCH}
+		Xpath_get $XPATH $TMP_PRIMARY
+		CHECKSUM=$XPATH_RESULT
+		PKG_URL=$TARGET_URL/$PKG_PATH
+		PKG_FILE=$(basename $PKG_PATH)
+		PKG_PATH=$TMPDIR/$PKG_FILE
+		Debug "Download $PKG_URL to $PKG_PATH"
+		Fetch $PKG_URL $PKG_PATH true
+		echo "$CHECKSUM $PKG_PATH" | sha256sum -c - > /dev/null
+		if [ $? -ne 0 ]; then
+			Error "Fail to fetch $PKG_URL to $PKG_PATH"
+			Debug "Checksum = $CHECKSUM"
+			exit 1
+		fi
+	done
+}
+Inform "Initialize arm base"
+fetch_tizen_pkgs_init standard base
+Inform "fetch common packages"
+fetch_tizen_pkgs armv7l gcc gcc-devel-static glibc glibc-devel libicu libicu-devel libatomic linux-glibc-devel keyutils keyutils-devel libkeyutils
+Inform "fetch coreclr packages"
+fetch_tizen_pkgs armv7l lldb lldb-devel libgcc libstdc++ libstdc++-devel libunwind libunwind-devel lttng-ust-devel lttng-ust userspace-rcu-devel userspace-rcu
+Inform "fetch corefx packages"
+fetch_tizen_pkgs armv7l libcom_err libcom_err-devel zlib zlib-devel libopenssl11 libopenssl1.1-devel krb5 krb5-devel
+Inform "Initialize standard unified"
+fetch_tizen_pkgs_init standard unified
+Inform "fetch corefx packages"
+fetch_tizen_pkgs armv7l gssdp gssdp-devel tizen-release

--- a//dev/null
+++ b/eng/common/cross/build-android-rootfs.sh
@@ -0,0 +1,105 @@
+set -e
+__NDK_Version=r21
+usage()
+{
+    echo "Creates a toolchain and sysroot used for cross-compiling for Android."
+    echo.
+    echo "Usage: $0 [BuildArch] [ApiLevel]"
+    echo.
+    echo "BuildArch is the target architecture of Android. Currently only arm64 is supported."
+    echo "ApiLevel is the target Android API level. API levels usually match to Android releases. See https://source.android.com/source/build-numbers.html"
+    echo.
+    echo "By default, the toolchain and sysroot will be generated in cross/android-rootfs/toolchain/[BuildArch]. You can change this behavior"
+    echo "by setting the TOOLCHAIN_DIR environment variable"
+    echo.
+    echo "By default, the NDK will be downloaded into the cross/android-rootfs/android-ndk-$__NDK_Version directory. If you already have an NDK installation,"
+    echo "you can set the NDK_DIR environment variable to have this script use that installation of the NDK."
+    echo "By default, this script will generate a file, android_platform, in the root of the ROOTFS_DIR directory that contains the RID for the supported and tested Android build: android.28-arm64. This file is to replace '/etc/os-release', which is not available for Android."
+    exit 1
+}
+__ApiLevel=28 # The minimum platform for arm64 is API level 21 but the minimum version that support glob(3) is 28. See $ANDROID_NDK/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/glob.h
+__BuildArch=arm64
+__AndroidArch=aarch64
+__AndroidToolchain=aarch64-linux-android
+for i in "$@"
+    do
+        lowerI="$(echo $i | tr "[:upper:]" "[:lower:]")"
+        case $lowerI in
+        -?|-h|--help)
+            usage
+            exit 1
+            ;;
+        arm64)
+            __BuildArch=arm64
+            __AndroidArch=aarch64
+            __AndroidToolchain=aarch64-linux-android
+            ;;
+        arm)
+            __BuildArch=arm
+            __AndroidArch=arm
+            __AndroidToolchain=arm-linux-androideabi
+            ;;
+        *[0-9])
+            __ApiLevel=$i
+            ;;
+        *)
+            __UnprocessedBuildArgs="$__UnprocessedBuildArgs $i"
+            ;;
+    esac
+done
+__ScriptBaseDir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
+__CrossDir="$__ScriptBaseDir/../../../.tools/android-rootfs"
+if [[ ! -f "$__CrossDir" ]]; then
+    mkdir -p "$__CrossDir"
+fi
+__CrossDir="$( cd "$__CrossDir" && pwd )"
+__NDK_Dir="$__CrossDir/android-ndk-$__NDK_Version"
+__lldb_Dir="$__CrossDir/lldb"
+__ToolchainDir="$__CrossDir/android-ndk-$__NDK_Version"
+if [[ -n "$TOOLCHAIN_DIR" ]]; then
+    __ToolchainDir=$TOOLCHAIN_DIR
+fi
+if [[ -n "$NDK_DIR" ]]; then
+    __NDK_Dir=$NDK_DIR
+fi
+echo "Target API level: $__ApiLevel"
+echo "Target architecture: $__BuildArch"
+echo "NDK location: $__NDK_Dir"
+echo "Target Toolchain location: $__ToolchainDir"
+if [ ! -d $__NDK_Dir ]; then
+    echo Downloading the NDK into $__NDK_Dir
+    mkdir -p $__NDK_Dir
+    wget -q --progress=bar:force:noscroll --show-progress https://dl.google.com/android/repository/android-ndk-$__NDK_Version-linux-x86_64.zip -O $__CrossDir/android-ndk-$__NDK_Version-linux-x86_64.zip
+    unzip -q $__CrossDir/android-ndk-$__NDK_Version-linux-x86_64.zip -d $__CrossDir
+fi
+if [ ! -d $__lldb_Dir ]; then
+    mkdir -p $__lldb_Dir
+    echo Downloading LLDB into $__lldb_Dir
+    wget -q --progress=bar:force:noscroll --show-progress https://dl.google.com/android/repository/lldb-2.3.3614996-linux-x86_64.zip -O $__CrossDir/lldb-2.3.3614996-linux-x86_64.zip
+    unzip -q $__CrossDir/lldb-2.3.3614996-linux-x86_64.zip -d $__lldb_Dir
+fi
+echo "Download dependencies..."
+__TmpDir=$__CrossDir/tmp/$__BuildArch/
+mkdir -p "$__TmpDir"
+__AndroidPackages="libicu"
+__AndroidPackages+=" libandroid-glob"
+__AndroidPackages+=" liblzma"
+__AndroidPackages+=" krb5"
+__AndroidPackages+=" openssl"
+for path in $(wget -qO- http://termux.net/dists/stable/main/binary-$__AndroidArch/Packages |\
+    grep -A15 "Package: \(${__AndroidPackages// /\\|}\)" | grep -v "static\|tool" | grep Filename); do
+    if [[ "$path" != "Filename:" ]]; then
+        echo "Working on: $path"
+        wget -qO- http://termux.net/$path | dpkg -x - "$__TmpDir"
+    fi
+done
+cp -R "$__TmpDir/data/data/com.termux/files/usr/"* "$__ToolchainDir/sysroot/usr/"
+echo "Generating platform file..."
+echo "RID=android.${__ApiLevel}-${__BuildArch}" > $__ToolchainDir/sysroot/android_platform
+echo "Now to build coreclr, libraries and installers; run:"
+echo ROOTFS_DIR=\$\(realpath $__ToolchainDir/sysroot\) ./build.sh --cross --arch $__BuildArch \
+    --subsetCategory coreclr
+echo ROOTFS_DIR=\$\(realpath $__ToolchainDir/sysroot\) ./build.sh --cross --arch $__BuildArch \
+    --subsetCategory libraries
+echo ROOTFS_DIR=\$\(realpath $__ToolchainDir/sysroot\) ./build.sh --cross --arch $__BuildArch \
+    --subsetCategory installer

--- a//dev/null
+++ b/eng/common/cross/build-rootfs.sh
@@ -0,0 +1,344 @@
+set -e
+usage()
+{
+    echo "Usage: $0 [BuildArch] [CodeName] [lldbx.y] [--skipunmount] --rootfsdir <directory>]"
+    echo "BuildArch can be: arm(default), armel, arm64, x86"
+    echo "CodeName - optional, Code name for Linux, can be: xenial(default), zesty, bionic, alpine, alpine3.9 or alpine3.13. If BuildArch is armel, LinuxCodeName is jessie(default) or tizen."
+    echo "                              for FreeBSD can be: freebsd11, freebsd12, freebsd13"
+    echo "                              for illumos can be: illumos."
+    echo "lldbx.y - optional, LLDB version, can be: lldb3.9(default), lldb4.0, lldb5.0, lldb6.0 no-lldb. Ignored for alpine and FreeBSD"
+    echo "--skipunmount - optional, will skip the unmount of rootfs folder."
+    echo "--use-mirror - optional, use mirror URL to fetch resources, when available."
+    exit 1
+}
+__CodeName=xenial
+__CrossDir=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
+__InitialDir=$PWD
+__BuildArch=arm
+__AlpineArch=armv7
+__QEMUArch=arm
+__UbuntuArch=armhf
+__UbuntuRepo="http://ports.ubuntu.com/"
+__LLDB_Package="liblldb-3.9-dev"
+__SkipUnmount=0
+__UbuntuPackages="build-essential"
+__AlpinePackages="alpine-base"
+__AlpinePackages+=" build-base"
+__AlpinePackages+=" linux-headers"
+__AlpinePackagesEdgeCommunity=" lldb-dev"
+__AlpinePackagesEdgeMain+=" python3"
+__AlpinePackagesEdgeMain+=" libedit"
+__UbuntuPackages+=" symlinks"
+__UbuntuPackages+=" libicu-dev"
+__UbuntuPackages+=" liblttng-ust-dev"
+__UbuntuPackages+=" libunwind8-dev"
+__AlpinePackages+=" gettext-dev"
+__AlpinePackages+=" icu-dev"
+__AlpinePackages+=" libunwind-dev"
+__AlpinePackages+=" lttng-ust-dev"
+__UbuntuPackages+=" libcurl4-openssl-dev"
+__UbuntuPackages+=" libkrb5-dev"
+__UbuntuPackages+=" libssl-dev"
+__UbuntuPackages+=" zlib1g-dev"
+__AlpinePackages+=" curl-dev"
+__AlpinePackages+=" krb5-dev"
+__AlpinePackages+=" openssl-dev"
+__AlpinePackages+=" zlib-dev"
+__FreeBSDBase="12.2-RELEASE"
+__FreeBSDPkg="1.12.0"
+__FreeBSDABI="12"
+__FreeBSDPackages="libunwind"
+__FreeBSDPackages+=" icu"
+__FreeBSDPackages+=" libinotify"
+__FreeBSDPackages+=" lttng-ust"
+__FreeBSDPackages+=" krb5"
+__FreeBSDPackages+=" terminfo-db"
+__IllumosPackages="icu-64.2nb2"
+__IllumosPackages+=" mit-krb5-1.16.2nb4"
+__IllumosPackages+=" openssl-1.1.1e"
+__IllumosPackages+=" zlib-1.2.11"
+__UbuntuPackages+=" libomp5"
+__UbuntuPackages+=" libomp-dev"
+__UseMirror=0
+__UnprocessedBuildArgs=
+while :; do
+    if [ $# -le 0 ]; then
+        break
+    fi
+    lowerI="$(echo $1 | tr "[:upper:]" "[:lower:]")"
+    case $lowerI in
+        -?|-h|--help)
+            usage
+            exit 1
+            ;;
+        arm)
+            __BuildArch=arm
+            __UbuntuArch=armhf
+            __AlpineArch=armv7
+            __QEMUArch=arm
+            ;;
+        arm64)
+            __BuildArch=arm64
+            __UbuntuArch=arm64
+            __AlpineArch=aarch64
+            __QEMUArch=aarch64
+            ;;
+        armel)
+            __BuildArch=armel
+            __UbuntuArch=armel
+            __UbuntuRepo="http://ftp.debian.org/debian/"
+            __CodeName=jessie
+            ;;
+        s390x)
+            __BuildArch=s390x
+            __UbuntuArch=s390x
+            __UbuntuRepo="http://ports.ubuntu.com/ubuntu-ports/"
+            __UbuntuPackages=$(echo ${__UbuntuPackages} | sed 's/ libunwind8-dev//')
+            __UbuntuPackages=$(echo ${__UbuntuPackages} | sed 's/ libomp-dev//')
+            __UbuntuPackages=$(echo ${__UbuntuPackages} | sed 's/ libomp5//')
+            unset __LLDB_Package
+            ;;
+        x86)
+            __BuildArch=x86
+            __UbuntuArch=i386
+            __UbuntuRepo="http://archive.ubuntu.com/ubuntu/"
+            ;;
+        lldb3.6)
+            __LLDB_Package="lldb-3.6-dev"
+            ;;
+        lldb3.8)
+            __LLDB_Package="lldb-3.8-dev"
+            ;;
+        lldb3.9)
+            __LLDB_Package="liblldb-3.9-dev"
+            ;;
+        lldb4.0)
+            __LLDB_Package="liblldb-4.0-dev"
+            ;;
+        lldb5.0)
+            __LLDB_Package="liblldb-5.0-dev"
+            ;;
+        lldb6.0)
+            __LLDB_Package="liblldb-6.0-dev"
+            ;;
+        no-lldb)
+            unset __LLDB_Package
+            ;;
+        xenial) # Ubuntu 16.04
+            if [ "$__CodeName" != "jessie" ]; then
+                __CodeName=xenial
+            fi
+            ;;
+        zesty) # Ubuntu 17.04
+            if [ "$__CodeName" != "jessie" ]; then
+                __CodeName=zesty
+            fi
+            ;;
+        bionic) # Ubuntu 18.04
+            if [ "$__CodeName" != "jessie" ]; then
+                __CodeName=bionic
+            fi
+            ;;
+        jessie) # Debian 8
+            __CodeName=jessie
+            __UbuntuRepo="http://ftp.debian.org/debian/"
+            ;;
+        stretch) # Debian 9
+            __CodeName=stretch
+            __UbuntuRepo="http://ftp.debian.org/debian/"
+            __LLDB_Package="liblldb-6.0-dev"
+            ;;
+        buster) # Debian 10
+            __CodeName=buster
+            __UbuntuRepo="http://ftp.debian.org/debian/"
+            __LLDB_Package="liblldb-6.0-dev"
+            ;;
+        tizen)
+            if [ "$__BuildArch" != "armel" ] && [ "$__BuildArch" != "arm64" ]; then
+                echo "Tizen is available only for armel and arm64."
+                usage;
+                exit 1;
+            fi
+            __CodeName=
+            __UbuntuRepo=
+            __Tizen=tizen
+            ;;
+        alpine|alpine3.9)
+            __CodeName=alpine
+            __UbuntuRepo=
+            __AlpineVersion=3.9
+            __AlpinePackagesEdgeMain+=" llvm11-libs"
+            __AlpinePackagesEdgeMain+=" clang-libs"
+            ;;
+        alpine3.13)
+            __CodeName=alpine
+            __UbuntuRepo=
+            __AlpineVersion=3.13
+            __AlpinePackages+=$__AlpinePackagesEdgeCommunity
+            __AlpinePackagesEdgeCommunity=
+            __AlpinePackages+=$__AlpinePackagesEdgeMain
+            __AlpinePackagesEdgeMain=
+            __AlpinePackages+=" llvm10-libs"
+            ;;
+        freebsd11)
+            __FreeBSDBase="11.3-RELEASE"
+            __FreeBSDABI="11"
+            ;&
+        freebsd12)
+            __CodeName=freebsd
+            __BuildArch=x64
+            __SkipUnmount=1
+            ;;
+        freebsd13)
+            __CodeName=freebsd
+            __FreeBSDBase="13.0-RELEASE"
+            __FreeBSDABI="13"
+            __BuildArch=x64
+            __SkipUnmount=1
+            ;;
+        illumos)
+            __CodeName=illumos
+            __BuildArch=x64
+            __SkipUnmount=1
+            ;;
+        --skipunmount)
+            __SkipUnmount=1
+            ;;
+        --rootfsdir|-rootfsdir)
+            shift
+            __RootfsDir=$1
+            ;;
+        --use-mirror)
+            __UseMirror=1
+            ;;
+        *)
+            __UnprocessedBuildArgs="$__UnprocessedBuildArgs $1"
+            ;;
+    esac
+    shift
+done
+if [ "$__BuildArch" == "armel" ]; then
+    __LLDB_Package="lldb-3.5-dev"
+fi
+__UbuntuPackages+=" ${__LLDB_Package:-}"
+if [ -z "$__RootfsDir" ] && [ ! -z "$ROOTFS_DIR" ]; then
+    __RootfsDir=$ROOTFS_DIR
+fi
+if [ -z "$__RootfsDir" ]; then
+    __RootfsDir="$__CrossDir/../../../.tools/rootfs/$__BuildArch"
+fi
+if [ -d "$__RootfsDir" ]; then
+    if [ $__SkipUnmount == 0 ]; then
+        umount $__RootfsDir/* || true
+    fi
+    rm -rf $__RootfsDir
+fi
+mkdir -p $__RootfsDir
+__RootfsDir="$( cd "$__RootfsDir" && pwd )"
+if [[ "$__CodeName" == "alpine" ]]; then
+    __ApkToolsVersion=2.9.1
+    __ApkToolsDir=$(mktemp -d)
+    wget https://github.com/alpinelinux/apk-tools/releases/download/v$__ApkToolsVersion/apk-tools-$__ApkToolsVersion-x86_64-linux.tar.gz -P $__ApkToolsDir
+    tar -xf $__ApkToolsDir/apk-tools-$__ApkToolsVersion-x86_64-linux.tar.gz -C $__ApkToolsDir
+    mkdir -p $__RootfsDir/usr/bin
+    cp -v /usr/bin/qemu-$__QEMUArch-static $__RootfsDir/usr/bin
+    $__ApkToolsDir/apk-tools-$__ApkToolsVersion/apk \
+      -X http://dl-cdn.alpinelinux.org/alpine/v$__AlpineVersion/main \
+      -X http://dl-cdn.alpinelinux.org/alpine/v$__AlpineVersion/community \
+      -U --allow-untrusted --root $__RootfsDir --arch $__AlpineArch --initdb \
+      add $__AlpinePackages
+    if [[ -n "$__AlpinePackagesEdgeMain" ]]; then
+      $__ApkToolsDir/apk-tools-$__ApkToolsVersion/apk \
+        -X http://dl-cdn.alpinelinux.org/alpine/edge/main \
+        -U --allow-untrusted --root $__RootfsDir --arch $__AlpineArch --initdb \
+        add $__AlpinePackagesEdgeMain
+    fi
+    if [[ -n "$__AlpinePackagesEdgeCommunity" ]]; then
+      $__ApkToolsDir/apk-tools-$__ApkToolsVersion/apk \
+        -X http://dl-cdn.alpinelinux.org/alpine/edge/community \
+        -U --allow-untrusted --root $__RootfsDir --arch $__AlpineArch --initdb \
+        add $__AlpinePackagesEdgeCommunity
+    fi
+    rm -r $__ApkToolsDir
+elif [[ "$__CodeName" == "freebsd" ]]; then
+    mkdir -p $__RootfsDir/usr/local/etc
+    JOBS="$(getconf _NPROCESSORS_ONLN)"
+    wget -O - https://download.freebsd.org/ftp/releases/amd64/${__FreeBSDBase}/base.txz | tar -C $__RootfsDir -Jxf - ./lib ./usr/lib ./usr/libdata ./usr/include ./usr/share/keys ./etc ./bin/freebsd-version
+    echo "ABI = \"FreeBSD:${__FreeBSDABI}:amd64\"; FINGERPRINTS = \"${__RootfsDir}/usr/share/keys\"; REPOS_DIR = [\"${__RootfsDir}/etc/pkg\"]; REPO_AUTOUPDATE = NO; RUN_SCRIPTS = NO;" > ${__RootfsDir}/usr/local/etc/pkg.conf
+    echo "FreeBSD: { url: "pkg+http://pkg.FreeBSD.org/\${ABI}/quarterly", mirror_type: \"srv\", signature_type: \"fingerprints\", fingerprints: \"${__RootfsDir}/usr/share/keys/pkg\", enabled: yes }" > ${__RootfsDir}/etc/pkg/FreeBSD.conf
+    mkdir -p $__RootfsDir/tmp
+    wget -O -  https://github.com/freebsd/pkg/archive/${__FreeBSDPkg}.tar.gz  |  tar -C $__RootfsDir/tmp -zxf -
+    cd $__RootfsDir/tmp/pkg-${__FreeBSDPkg}
+    mkdir -p $__RootfsDir/host/etc
+    ./autogen.sh && ./configure --prefix=$__RootfsDir/host && make -j "$JOBS" && make install
+    rm -rf $__RootfsDir/tmp/pkg-${__FreeBSDPkg}
+    INSTALL_AS_USER=$(whoami) $__RootfsDir/host/sbin/pkg -r $__RootfsDir -C $__RootfsDir/usr/local/etc/pkg.conf update
+    INSTALL_AS_USER=$(whoami) $__RootfsDir/host/sbin/pkg -r $__RootfsDir -C $__RootfsDir/usr/local/etc/pkg.conf install --yes $__FreeBSDPackages
+elif [[ "$__CodeName" == "illumos" ]]; then
+    mkdir "$__RootfsDir/tmp"
+    pushd "$__RootfsDir/tmp"
+    JOBS="$(getconf _NPROCESSORS_ONLN)"
+    echo "Downloading sysroot."
+    wget -O - https://github.com/illumos/sysroot/releases/download/20181213-de6af22ae73b-v1/illumos-sysroot-i386-20181213-de6af22ae73b-v1.tar.gz | tar -C "$__RootfsDir" -xzf -
+    echo "Building binutils. Please wait.."
+    wget -O - https://ftp.gnu.org/gnu/binutils/binutils-2.33.1.tar.bz2 | tar -xjf -
+    mkdir build-binutils && cd build-binutils
+    ../binutils-2.33.1/configure --prefix="$__RootfsDir" --target="x86_64-sun-solaris2.10" --program-prefix="x86_64-illumos-" --with-sysroot="$__RootfsDir"
+    make -j "$JOBS" && make install && cd ..
+    echo "Building gcc. Please wait.."
+    wget -O - https://ftp.gnu.org/gnu/gcc/gcc-8.4.0/gcc-8.4.0.tar.xz | tar -xJf -
+    CFLAGS="-fPIC"
+    CXXFLAGS="-fPIC"
+    CXXFLAGS_FOR_TARGET="-fPIC"
+    CFLAGS_FOR_TARGET="-fPIC"
+    export CFLAGS CXXFLAGS CXXFLAGS_FOR_TARGET CFLAGS_FOR_TARGET
+    mkdir build-gcc && cd build-gcc
+    ../gcc-8.4.0/configure --prefix="$__RootfsDir" --target="x86_64-sun-solaris2.10" --program-prefix="x86_64-illumos-" --with-sysroot="$__RootfsDir" --with-gnu-as       \
+        --with-gnu-ld --disable-nls --disable-libgomp --disable-libquadmath --disable-libssp --disable-libvtv --disable-libcilkrts --disable-libada --disable-libsanitizer \
+        --disable-libquadmath-support --disable-shared --enable-tls
+    make -j "$JOBS" && make install && cd ..
+    BaseUrl=https://pkgsrc.joyent.com
+    if [[ "$__UseMirror" == 1 ]]; then
+        BaseUrl=http://pkgsrc.smartos.skylime.net
+    fi
+    BaseUrl="$BaseUrl"/packages/SmartOS/2020Q1/x86_64/All
+    echo "Downloading dependencies."
+    read -ra array <<<"$__IllumosPackages"
+    for package in "${array[@]}"; do
+       echo "Installing $package..."
+        wget "$BaseUrl"/"$package".tgz
+        ar -x "$package".tgz
+        tar --skip-old-files -xzf "$package".tmp.tgz -C "$__RootfsDir" 2>/dev/null
+    done
+    echo "Cleaning up temporary files."
+    popd
+    rm -rf "$__RootfsDir"/{tmp,+*}
+    mkdir -p "$__RootfsDir"/usr/include/net
+    mkdir -p "$__RootfsDir"/usr/include/netpacket
+    wget -P "$__RootfsDir"/usr/include/net https://raw.githubusercontent.com/illumos/illumos-gate/master/usr/src/uts/common/io/bpf/net/bpf.h
+    wget -P "$__RootfsDir"/usr/include/net https://raw.githubusercontent.com/illumos/illumos-gate/master/usr/src/uts/common/io/bpf/net/dlt.h
+    wget -P "$__RootfsDir"/usr/include/netpacket https://raw.githubusercontent.com/illumos/illumos-gate/master/usr/src/uts/common/inet/sockmods/netpacket/packet.h
+    wget -P "$__RootfsDir"/usr/include/sys https://raw.githubusercontent.com/illumos/illumos-gate/master/usr/src/uts/common/sys/sdt.h
+elif [[ -n $__CodeName ]]; then
+    qemu-debootstrap --arch $__UbuntuArch $__CodeName $__RootfsDir $__UbuntuRepo
+    cp $__CrossDir/$__BuildArch/sources.list.$__CodeName $__RootfsDir/etc/apt/sources.list
+    chroot $__RootfsDir apt-get update
+    chroot $__RootfsDir apt-get -f -y install
+    chroot $__RootfsDir apt-get -y install $__UbuntuPackages
+    chroot $__RootfsDir symlinks -cr /usr
+    chroot $__RootfsDir apt-get clean
+    if [ $__SkipUnmount == 0 ]; then
+        umount $__RootfsDir/* || true
+    fi
+    if [[ "$__BuildArch" == "armel" && "$__CodeName" == "jessie" ]]; then
+        pushd $__RootfsDir
+        patch -p1 < $__CrossDir/$__BuildArch/armel.jessie.patch
+        popd
+    fi
+elif [[ "$__Tizen" == "tizen" ]]; then
+    ROOTFS_DIR=$__RootfsDir $__CrossDir/$__BuildArch/tizen-build-rootfs.sh
+else
+    echo "Unsupported target platform."
+    usage;
+    exit 1
+fi

--- a//dev/null
+++ b/eng/common/darc-init.sh
@@ -0,0 +1,66 @@
+source="${BASH_SOURCE[0]}"
+darcVersion=''
+versionEndpoint='https://maestro-prod.westus2.cloudapp.azure.com/api/assets/darc-version?api-version=2019-01-16'
+verbosity='minimal'
+while [[ $# > 0 ]]; do
+  opt="$(echo "$1" | tr "[:upper:]" "[:lower:]")"
+  case "$opt" in
+    --darcversion)
+      darcVersion=$2
+      shift
+      ;;
+    --versionendpoint)
+      versionEndpoint=$2
+      shift
+      ;;
+    --verbosity)
+      verbosity=$2
+      shift
+      ;;
+    --toolpath)
+      toolpath=$2
+      shift
+      ;;
+    *)
+      echo "Invalid argument: $1"
+      usage
+      exit 1
+      ;;
+  esac
+  shift
+done
+while [[ -h "$source" ]]; do
+  scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+  source="$(readlink "$source")"
+  [[ $source != /* ]] && source="$scriptroot/$source"
+done
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+. "$scriptroot/tools.sh"
+if [ -z "$darcVersion" ]; then
+  darcVersion=$(curl -X GET "$versionEndpoint" -H "accept: text/plain")
+fi
+function InstallDarcCli {
+  local darc_cli_package_name="microsoft.dotnet.darc"
+  InitializeDotNetCli
+  local dotnet_root=$_InitializeDotNetCli
+  if [ -z "$toolpath" ]; then
+    local tool_list=$($dotnet_root/dotnet tool list -g)
+    if [[ $tool_list = *$darc_cli_package_name* ]]; then
+      echo $($dotnet_root/dotnet tool uninstall $darc_cli_package_name -g)
+    fi
+  else
+    local tool_list=$($dotnet_root/dotnet tool list --tool-path "$toolpath")
+    if [[ $tool_list = *$darc_cli_package_name* ]]; then
+      echo $($dotnet_root/dotnet tool uninstall $darc_cli_package_name --tool-path "$toolpath")
+    fi
+  fi
+  local arcadeServicesSource="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json"
+  echo "Installing Darc CLI version $darcVersion..."
+  echo "You may need to restart your command shell if this is the first dotnet tool you have installed."
+  if [ -z "$toolpath" ]; then
+    echo $($dotnet_root/dotnet tool install $darc_cli_package_name --version $darcVersion --add-source "$arcadeServicesSource" -v $verbosity -g)
+  else
+    echo $($dotnet_root/dotnet tool install $darc_cli_package_name --version $darcVersion --add-source "$arcadeServicesSource" -v $verbosity --tool-path "$toolpath")
+  fi
+}
+InstallDarcCli

--- a//dev/null
+++ b/eng/common/dotnet-install.sh
@@ -0,0 +1,72 @@
+source="${BASH_SOURCE[0]}"
+while [[ -h "$source" ]]; do
+  scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+  source="$(readlink "$source")"
+  [[ $source != /* ]] && source="$scriptroot/$source"
+done
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+. "$scriptroot/tools.sh"
+version='Latest'
+architecture=''
+runtime='dotnet'
+runtimeSourceFeed=''
+runtimeSourceFeedKey=''
+while [[ $# > 0 ]]; do
+  opt="$(echo "$1" | tr "[:upper:]" "[:lower:]")"
+  case "$opt" in
+    -version|-v)
+      shift
+      version="$1"
+      ;;
+    -architecture|-a)
+      shift
+      architecture="$1"
+      ;;
+    -runtime|-r)
+      shift
+      runtime="$1"
+      ;;
+    -runtimesourcefeed)
+      shift
+      runtimeSourceFeed="$1"
+      ;;
+    -runtimesourcefeedkey)
+      shift
+      runtimeSourceFeedKey="$1"
+      ;;
+    *)
+      Write-PipelineTelemetryError -Category 'Build' -Message "Invalid argument: $1"
+      exit 1
+      ;;
+  esac
+  shift
+done
+cpuname=$(uname -m)
+case $cpuname in
+  aarch64)
+    buildarch=arm64
+    ;;
+  amd64|x86_64)
+    buildarch=x64
+    ;;
+  armv*l)
+    buildarch=arm
+    ;;
+  i686)
+    buildarch=x86
+    ;;
+  *)
+    echo "Unknown CPU $cpuname detected, treating it as x64"
+    buildarch=x64
+    ;;
+esac
+dotnetRoot="${repo_root}.dotnet"
+if [[ $architecture != "" ]] && [[ $architecture != $buildarch ]]; then
+  dotnetRoot="$dotnetRoot/$architecture"
+fi
+InstallDotNet $dotnetRoot $version "$architecture" $runtime true $runtimeSourceFeed $runtimeSourceFeedKey || {
+  local exit_code=$?
+  Write-PipelineTelemetryError -Category 'InitializeToolset' -Message "dotnet-install.sh failed (exit code '$exit_code')." >&2
+  ExitWithExitCode $exit_code
+}
+ExitWithExitCode 0

--- a//dev/null
+++ b/eng/common/init-tools-native.sh
@@ -0,0 +1,192 @@
+source="${BASH_SOURCE[0]}"
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+base_uri='https://netcorenativeassets.blob.core.windows.net/resource-packages/external'
+install_directory=''
+clean=false
+force=false
+download_retries=5
+retry_wait_time_seconds=30
+global_json_file="$(dirname "$(dirname "${scriptroot}")")/global.json"
+declare -a native_assets
+. $scriptroot/pipeline-logging-functions.sh
+. $scriptroot/native/common-library.sh
+while (($# > 0)); do
+  lowerI="$(echo $1 | tr "[:upper:]" "[:lower:]")"
+  case $lowerI in
+    --baseuri)
+      base_uri=$2
+      shift 2
+      ;;
+    --installdirectory)
+      install_directory=$2
+      shift 2
+      ;;
+    --clean)
+      clean=true
+      shift 1
+      ;;
+    --force)
+      force=true
+      shift 1
+      ;;
+    --donotabortonfailure)
+      donotabortonfailure=true
+      shift 1
+      ;;
+    --donotdisplaywarnings)
+      donotdisplaywarnings=true
+      shift 1
+      ;;
+    --downloadretries)
+      download_retries=$2
+      shift 2
+      ;;
+    --retrywaittimeseconds)
+      retry_wait_time_seconds=$2
+      shift 2
+      ;;
+    --help)
+      echo "Common settings:"
+      echo "  --installdirectory                  Directory to install native toolset."
+      echo "                                      This is a command-line override for the default"
+      echo "                                      Install directory precedence order:"
+      echo "                                          - InstallDirectory command-line override"
+      echo "                                          - NETCOREENG_INSTALL_DIRECTORY environment variable"
+      echo "                                          - (default) %USERPROFILE%/.netcoreeng/native"
+      echo ""
+      echo "  --clean                             Switch specifying not to install anything, but cleanup native asset folders"
+      echo "  --donotabortonfailure               Switch specifiying whether to abort native tools installation on failure"
+      echo "  --donotdisplaywarnings              Switch specifiying whether to display warnings during native tools installation on failure"
+      echo "  --force                             Clean and then install tools"
+      echo "  --help                              Print help and exit"
+      echo ""
+      echo "Advanced settings:"
+      echo "  --baseuri <value>                   Base URI for where to download native tools from"
+      echo "  --downloadretries <value>           Number of times a download should be attempted"
+      echo "  --retrywaittimeseconds <value>      Wait time between download attempts"
+      echo ""
+      exit 0
+      ;;
+  esac
+done
+function ReadGlobalJsonNativeTools {
+  if command -v jq &> /dev/null; then
+    while IFS= read -rd '' line; do
+      native_assets+=("$line")
+    done < <(jq -r '. |
+        select(has("native-tools")) |
+        ."native-tools" |
+        keys[] as $k |
+        @sh "KEY=\($k) VALUE=\(.[$k])\u0000"' "$global_json_file")
+    return
+  fi
+  if [[ ! "$(cat "$global_json_file")" =~ \"native-tools\"[[:space:]\:\{]*([^\}]+) ]]; then
+    return
+  fi
+  section="${BASH_REMATCH[1]}"
+  parseStarted=0
+  possibleEnd=0
+  escaping=0
+  escaped=0
+  isKey=1
+  for (( i=0; i<${#section}; i++ )); do
+    char="${section:$i:1}"
+    if ! ((parseStarted)) && [[ "$char" =~ [[:space:],:] ]]; then continue; fi
+    if ! ((escaping)) && [[ "$char" == "\\" ]]; then
+      escaping=1
+    elif ((escaping)) && ! ((escaped)); then
+      escaped=1
+    fi
+    if ! ((parseStarted)) && [[ "$char" == "\"" ]]; then
+      parseStarted=1
+      possibleEnd=0
+    elif [[ "$char" == "'" ]]; then
+      token="$token'\\\''"
+      possibleEnd=0
+    elif ((escaping)) || [[ "$char" != "\"" ]]; then
+      token="$token$char"
+      possibleEnd=1
+    fi
+    if ((possibleEnd)) && ! ((escaping)) && [[ "$char" == "\"" ]]; then
+      printf -v token "'$token'"
+      if ((isKey)); then
+        KEY="$token"
+        isKey=0
+      else
+        line="KEY=$KEY VALUE=$token"
+        native_assets+=("$line")
+        isKey=1
+      fi
+      parseStarted=0
+      token=
+    elif ((escaping)) && ((escaped)); then
+      escaping=0
+      escaped=0
+    fi
+  done
+}
+native_base_dir=$install_directory
+if [[ -z $install_directory ]]; then
+  native_base_dir=$(GetNativeInstallDirectory)
+fi
+install_bin="${native_base_dir}/bin"
+installed_any=false
+ReadGlobalJsonNativeTools
+if [[ ${#native_assets[@]} -eq 0 ]]; then
+  echo "No native tools defined in global.json"
+  exit 0;
+else
+  native_installer_dir="$scriptroot/native"
+  for index in "${!native_assets[@]}"; do
+    eval "${native_assets["$index"]}"
+    installer_path="$native_installer_dir/install-$KEY.sh"
+    installer_command="$installer_path"
+    installer_command+=" --baseuri $base_uri"
+    installer_command+=" --installpath $install_bin"
+    installer_command+=" --version $VALUE"
+    echo $installer_command
+    if [[ $force = true ]]; then
+      installer_command+=" --force"
+    fi
+    if [[ $clean = true ]]; then
+      installer_command+=" --clean"
+    fi
+    if [[ -a $installer_path ]]; then
+      $installer_command
+      if [[ $? != 0 ]]; then
+        if [[ $donotabortonfailure = true ]]; then
+          if [[ $donotdisplaywarnings != true ]]; then
+            Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Execution Failed"
+          fi
+        else
+          Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Execution Failed"
+          exit 1
+        fi
+      else
+        $installed_any = true
+      fi
+    else
+      if [[ $donotabortonfailure == true ]]; then
+        if [[ $donotdisplaywarnings != true ]]; then
+          Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Execution Failed: no install script"
+        fi
+      else
+        Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Execution Failed: no install script"
+        exit 1
+      fi
+    fi
+  done
+fi
+if [[ $clean = true ]]; then
+  exit 0
+fi
+if [[ -d $install_bin ]]; then
+  echo "Native tools are available from $install_bin"
+  echo "##vso[task.prependpath]$install_bin"
+else
+  if [[ $installed_any = true ]]; then
+    Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Native tools install directory does not exist, installation failed"
+    exit 1
+  fi
+fi
+exit 0

--- a//dev/null
+++ b/eng/common/internal-feed-operations.sh
@@ -0,0 +1,101 @@
+set -e
+function SetupCredProvider {
+  local authToken=$1
+  echo "Setting up Cred Provider NuGet plugin in the agent..."...
+  echo "Getting 'installcredprovider.ps1' from 'https://github.com/microsoft/artifacts-credprovider'..."
+  local url="https://raw.githubusercontent.com/microsoft/artifacts-credprovider/master/helpers/installcredprovider.sh"  
+  echo "Writing the contents of 'installcredprovider.ps1' locally..."
+  local installcredproviderPath="installcredprovider.sh"
+  if command -v curl > /dev/null; then
+    curl $url > "$installcredproviderPath"
+  else   
+    wget -q -O "$installcredproviderPath" "$url"
+  fi
+  echo "Installing plugin..."
+  . "$installcredproviderPath"
+  echo "Deleting local copy of 'installcredprovider.sh'..."
+  rm installcredprovider.sh
+  if [ ! -d "$HOME/.nuget/plugins" ]; then
+    Write-PipelineTelemetryError -category 'Build' 'CredProvider plugin was not installed correctly!'
+    ExitWithExitCode 1  
+  else 
+    echo "CredProvider plugin was installed correctly!"
+  fi
+  local nugetConfigPath="{$repo_root}NuGet.config"
+  if [ ! "$nugetConfigPath" ]; then
+    Write-PipelineTelemetryError -category 'Build' "NuGet.config file not found in repo's root!"
+    ExitWithExitCode 1  
+  fi
+  local endpoints='['
+  local nugetConfigPackageValues=`cat "$nugetConfigPath" | grep "key=\"darc-int-"`
+  local pattern="value=\"(.*)\""
+  for value in $nugetConfigPackageValues 
+  do
+    if [[ $value =~ $pattern ]]; then
+      local endpoint="${BASH_REMATCH[1]}"  
+      endpoints+="{\"endpoint\": \"$endpoint\", \"password\": \"$authToken\"},"
+    fi
+  done
+  endpoints=${endpoints%?}
+  endpoints+=']'
+  if [ ${#endpoints} -gt 2 ]; then 
+      local endpointCredentials="{\"endpointCredentials\": "$endpoints"}"
+      echo "##vso[task.setvariable variable=VSS_NUGET_EXTERNAL_FEED_ENDPOINTS]$endpointCredentials"
+      echo "##vso[task.setvariable variable=NUGET_CREDENTIALPROVIDER_SESSIONTOKENCACHE_ENABLED]False"
+  else
+    echo "No internal endpoints found in NuGet.config"
+  fi
+} 
+function InstallDotNetSdkAndRestoreArcade {
+  local dotnetTempDir="$repo_root/dotnet"
+  local dotnetSdkVersion="2.1.507" # After experimentation we know this version works when restoring the SDK (compared to 3.0.*)
+  local restoreProjPath="$repo_root/eng/common/restore.proj"
+  echo "Installing dotnet SDK version $dotnetSdkVersion to restore Arcade SDK..."
+  echo "<Project Sdk=\"Microsoft.DotNet.Arcade.Sdk\"/>" > "$restoreProjPath"
+  InstallDotNetSdk "$dotnetTempDir" "$dotnetSdkVersion"
+  local res=`$dotnetTempDir/dotnet restore $restoreProjPath`
+  echo "Arcade SDK restored!"
+  if [ "$restoreProjPath" ]; then
+    rm "$restoreProjPath"
+  fi
+  if [ "$dotnetTempDir" ]; then
+    rm -r $dotnetTempDir
+  fi
+}
+source="${BASH_SOURCE[0]}"
+operation=''
+authToken=''
+repoName=''
+while [[ $# > 0 ]]; do
+  opt="$(echo "$1" | tr "[:upper:]" "[:lower:]")"
+  case "$opt" in
+    --operation)
+      operation=$2
+      shift
+      ;;
+    --authtoken)
+      authToken=$2
+      shift
+      ;;
+    *)
+      echo "Invalid argument: $1"
+      usage
+      exit 1
+      ;;
+  esac
+  shift
+done
+while [[ -h "$source" ]]; do
+  scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+  source="$(readlink "$source")"
+  [[ $source != /* ]] && source="$scriptroot/$source"
+done
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+. "$scriptroot/tools.sh"
+if [ "$operation" = "setup" ]; then
+  SetupCredProvider $authToken
+elif [ "$operation" = "install-restore" ]; then
+  InstallDotNetSdkAndRestoreArcade
+else
+  echo "Unknown operation '$operation'!"
+fi

--- a//dev/null
+++ b/eng/common/msbuild.sh
@@ -0,0 +1,47 @@
+source="${BASH_SOURCE[0]}"
+while [[ -h "$source" ]]; do
+  scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+  source="$(readlink "$source")"
+  [[ $source != /* ]] && source="$scriptroot/$source"
+done
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+verbosity='minimal'
+warn_as_error=true
+node_reuse=true
+prepare_machine=false
+extra_args=''
+while (($# > 0)); do
+  lowerI="$(echo $1 | tr "[:upper:]" "[:lower:]")"
+  case $lowerI in
+    --verbosity)
+      verbosity=$2
+      shift 2
+      ;;
+    --warnaserror)
+      warn_as_error=$2
+      shift 2
+      ;;
+    --nodereuse)
+      node_reuse=$2
+      shift 2
+      ;;
+    --ci)
+      ci=true
+      shift 1
+      ;;
+    --preparemachine)
+      prepare_machine=true
+      shift 1
+      ;;
+      *)
+      extra_args="$extra_args $1"
+      shift 1
+      ;;
+  esac
+done
+. "$scriptroot/tools.sh"
+if [[ "$ci" == true ]]; then
+  node_reuse=false
+fi
+MSBuild $extra_args
+ExitWithExitCode 0

--- a//dev/null
+++ b/eng/common/native/common-library.sh
@@ -0,0 +1,132 @@
+function GetNativeInstallDirectory {
+  local install_dir
+  if [[ -z $NETCOREENG_INSTALL_DIRECTORY ]]; then
+    install_dir=$HOME/.netcoreeng/native/
+  else
+    install_dir=$NETCOREENG_INSTALL_DIRECTORY
+  fi
+  echo $install_dir
+  return 0
+}
+function GetTempDirectory {
+  echo $(GetNativeInstallDirectory)temp/
+  return 0
+}
+function ExpandZip {
+  local zip_path=$1
+  local output_directory=$2
+  local force=${3:-false}
+  echo "Extracting $zip_path to $output_directory"
+  if [[ -d $output_directory ]] && [[ $force = false ]]; then
+    echo "Directory '$output_directory' already exists, skipping extract"
+    return 0
+  fi
+  if [[ -d $output_directory ]]; then
+    echo "'Force flag enabled, but '$output_directory' exists. Removing directory"
+    rm -rf $output_directory
+    if [[ $? != 0 ]]; then
+      Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Unable to remove '$output_directory'"
+      return 1
+    fi
+  fi
+  echo "Creating directory: '$output_directory'"
+  mkdir -p $output_directory
+  echo "Extracting archive"
+  tar -xf $zip_path -C $output_directory
+  if [[ $? != 0 ]]; then
+    Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Unable to extract '$zip_path'"
+    return 1
+  fi
+  return 0
+}
+function GetCurrentOS {
+  local unameOut="$(uname -s)"
+  case $unameOut in
+    Linux*)     echo "Linux";;
+    Darwin*)    echo "MacOS";;
+  esac
+  return 0
+}
+function GetFile {
+  local uri=$1
+  local path=$2
+  local force=${3:-false}
+  local download_retries=${4:-5}
+  local retry_wait_time_seconds=${5:-30}
+  if [[ -f $path ]]; then
+    if [[ $force = false ]]; then
+      echo "File '$path' already exists. Skipping download"
+      return 0
+    else
+      rm -rf $path
+    fi
+  fi
+  if [[ -f $uri ]]; then
+    echo "'$uri' is a file path, copying file to '$path'"
+    cp $uri $path
+    return $?
+  fi
+  echo "Downloading $uri"
+  if command -v curl > /dev/null; then
+    curl "$uri" -sSL --retry $download_retries --retry-delay $retry_wait_time_seconds --create-dirs -o "$path" --fail
+  else
+    wget -q -O "$path" "$uri" --tries="$download_retries"
+  fi
+  return $?
+}
+function GetTempPathFileName {
+  local path=$1
+  local temp_dir=$(GetTempDirectory)
+  local temp_file_name=$(basename $path)
+  echo $temp_dir$temp_file_name
+  return 0
+}
+function DownloadAndExtract {
+  local uri=$1
+  local installDir=$2
+  local force=${3:-false}
+  local download_retries=${4:-5}
+  local retry_wait_time_seconds=${5:-30}
+  local temp_tool_path=$(GetTempPathFileName $uri)
+  echo "downloading to: $temp_tool_path"
+  GetFile "$uri" "$temp_tool_path" $force $download_retries $retry_wait_time_seconds
+  if [[ $? != 0 ]]; then
+    Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Failed to download '$uri' to '$temp_tool_path'."
+    return 1
+  fi
+  echo "extracting from  $temp_tool_path to $installDir"
+  ExpandZip "$temp_tool_path" "$installDir" $force $download_retries $retry_wait_time_seconds
+  if [[ $? != 0 ]]; then
+    Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Failed to extract '$temp_tool_path' to '$installDir'."
+    return 1
+  fi
+  return 0
+}
+function NewScriptShim {
+  local shimpath=$1
+  local tool_file_path=$2
+  local force=${3:-false}
+  echo "Generating '$shimpath' shim"
+  if [[ -f $shimpath ]]; then
+    if [[ $force = false ]]; then
+      echo "File '$shimpath' already exists." >&2
+      return 1
+    else
+      rm -rf $shimpath
+    fi
+  fi
+  if [[ ! -f $tool_file_path ]]; then
+    tool_file_path="$(echo $tool_file_path | tr "[:upper:]" "[:lower:]")" 
+    if [[ ! -f $tool_file_path ]]; then
+      Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Specified tool file path:'$tool_file_path' does not exist"
+      return 1
+    fi
+  fi
+  local shim_contents=$'#!/usr/bin/env bash\n'
+  shim_contents+="SHIMARGS="$'$1\n'
+  shim_contents+="$tool_file_path"$' $SHIMARGS\n'
+  echo "$shim_contents" > $shimpath
+  chmod +x $shimpath
+  echo "Finished generating shim '$shimpath'"
+  return $?
+}

--- a//dev/null
+++ b/eng/common/native/install-cmake.sh
@@ -0,0 +1,97 @@
+source="${BASH_SOURCE[0]}"
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+. $scriptroot/common-library.sh
+base_uri=
+install_path=
+version=
+clean=false
+force=false
+download_retries=5
+retry_wait_time_seconds=30
+while (($# > 0)); do
+  lowerI="$(echo $1 | tr "[:upper:]" "[:lower:]")"
+  case $lowerI in
+    --baseuri)
+      base_uri=$2
+      shift 2
+      ;;
+    --installpath)
+      install_path=$2
+      shift 2
+      ;;
+    --version)
+      version=$2
+      shift 2
+      ;;
+    --clean)
+      clean=true
+      shift 1
+      ;;
+    --force)
+      force=true
+      shift 1
+      ;;
+    --downloadretries)
+      download_retries=$2
+      shift 2
+      ;;
+    --retrywaittimeseconds)
+      retry_wait_time_seconds=$2
+      shift 2
+      ;;
+    --help)
+      echo "Common settings:"
+      echo "  --baseuri <value>        Base file directory or Url wrom which to acquire tool archives"
+      echo "  --installpath <value>    Base directory to install native tool to"
+      echo "  --clean                  Don't install the tool, just clean up the current install of the tool"
+      echo "  --force                  Force install of tools even if they previously exist"
+      echo "  --help                   Print help and exit"
+      echo ""
+      echo "Advanced settings:"
+      echo "  --downloadretries        Total number of retry attempts"
+      echo "  --retrywaittimeseconds   Wait time between retry attempts in seconds"
+      echo ""
+      exit 0
+      ;;
+  esac
+done
+tool_name="cmake"
+tool_os=$(GetCurrentOS)
+tool_folder="$(echo $tool_os | tr "[:upper:]" "[:lower:]")"
+tool_arch="x86_64"
+tool_name_moniker="$tool_name-$version-$tool_os-$tool_arch"
+tool_install_directory="$install_path/$tool_name/$version"
+tool_file_path="$tool_install_directory/$tool_name_moniker/bin/$tool_name"
+shim_path="$install_path/$tool_name.sh"
+uri="${base_uri}/$tool_folder/$tool_name/$tool_name_moniker.tar.gz"
+if [[ $clean = true ]]; then
+  echo "Cleaning $tool_install_directory"
+  if [[ -d $tool_install_directory ]]; then
+    rm -rf $tool_install_directory
+  fi
+  echo "Cleaning $shim_path"
+  if [[ -f $shim_path ]]; then
+    rm -rf $shim_path
+  fi
+  tool_temp_path=$(GetTempPathFileName $uri)
+  echo "Cleaning $tool_temp_path"
+  if [[ -f $tool_temp_path ]]; then
+    rm -rf $tool_temp_path
+  fi
+  exit 0
+fi
+if [[ -f $tool_file_path ]] && [[ $force = false ]]; then
+  echo "$tool_name ($version) already exists, skipping install"
+  exit 0
+fi
+DownloadAndExtract $uri $tool_install_directory $force $download_retries $retry_wait_time_seconds
+if [[ $? != 0 ]]; then
+  Write-PipelineTelemetryError -category 'NativeToolsBootstrap' 'Installation failed'
+  exit 1
+fi
+NewScriptShim $shim_path $tool_file_path true
+if [[ $? != 0 ]]; then
+  Write-PipelineTelemetryError -category 'NativeToolsBootstrap' 'Shim generation failed'
+  exit 1
+fi
+exit 0

--- a//dev/null
+++ b/eng/common/pipeline-logging-functions.sh
@@ -0,0 +1,178 @@
+function Write-PipelineTelemetryError {
+  local telemetry_category=''
+  local force=false
+  local function_args=()
+  local message=''
+  while [[ $# -gt 0 ]]; do
+    opt="$(echo "${1/#--/-}" | tr "[:upper:]" "[:lower:]")"
+    case "$opt" in
+      -category|-c)
+        telemetry_category=$2
+        shift
+        ;;
+      -force|-f)
+        force=true
+        ;;
+      -*)
+        function_args+=("$1 $2")
+        shift
+        ;;
+      *)
+        message=$*
+        ;;
+    esac
+    shift
+  done
+  if [[ $force != true ]] && [[ "$ci" != true ]]; then
+    echo "$message" >&2
+    return
+  fi
+  if [[ $force == true ]]; then
+    function_args+=("-force")
+  fi
+  message="(NETCORE_ENGINEERING_TELEMETRY=$telemetry_category) $message"
+  function_args+=("$message")
+  Write-PipelineTaskError ${function_args[@]}
+}
+function Write-PipelineTaskError {
+  local message_type="error"
+  local sourcepath=''
+  local linenumber=''
+  local columnnumber=''
+  local error_code=''
+  local force=false
+  while [[ $# -gt 0 ]]; do
+    opt="$(echo "${1/#--/-}" | tr "[:upper:]" "[:lower:]")"
+    case "$opt" in
+      -type|-t)
+        message_type=$2
+        shift
+        ;;
+      -sourcepath|-s)
+        sourcepath=$2
+        shift
+        ;;
+      -linenumber|-ln)
+        linenumber=$2
+        shift
+        ;;
+      -columnnumber|-cn)
+        columnnumber=$2
+        shift
+        ;;
+      -errcode|-e)
+        error_code=$2
+        shift
+        ;;
+      -force|-f)
+        force=true
+        ;;
+      *)
+        break
+        ;;
+    esac
+    shift
+  done
+  if [[ $force != true ]] && [[ "$ci" != true ]]; then
+    echo "$@" >&2
+    return
+  fi
+  local message="##vso[task.logissue"
+  message="$message type=$message_type"
+  if [ -n "$sourcepath" ]; then
+    message="$message;sourcepath=$sourcepath"
+  fi
+  if [ -n "$linenumber" ]; then
+    message="$message;linenumber=$linenumber"
+  fi
+  if [ -n "$columnnumber" ]; then
+    message="$message;columnnumber=$columnnumber"
+  fi
+  if [ -n "$error_code" ]; then
+    message="$message;code=$error_code"
+  fi
+  message="$message]$*"
+  echo "$message"
+}
+function Write-PipelineSetVariable {
+  if [[ "$ci" != true ]]; then
+    return
+  fi
+  local name=''
+  local value=''
+  local secret=false
+  local as_output=false
+  local is_multi_job_variable=true
+  while [[ $# -gt 0 ]]; do
+    opt="$(echo "${1/#--/-}" | tr "[:upper:]" "[:lower:]")"
+    case "$opt" in
+      -name|-n)
+        name=$2
+        shift
+        ;;
+      -value|-v)
+        value=$2
+        shift
+        ;;
+      -secret|-s)
+        secret=true
+        ;;
+      -as_output|-a)
+        as_output=true
+        ;;
+      -is_multi_job_variable|-i)
+        is_multi_job_variable=$2
+        shift
+        ;;
+    esac
+    shift
+  done
+  value=${value/;/%3B}
+  value=${value/\\r/%0D}
+  value=${value/\\n/%0A}
+  value=${value/]/%5D}
+  local message="##vso[task.setvariable variable=$name;isSecret=$secret;isOutput=$is_multi_job_variable]$value"
+  if [[ "$as_output" == true ]]; then
+    $message
+  else
+    echo "$message"
+  fi
+}
+function Write-PipelinePrependPath {
+  local prepend_path=''
+  while [[ $# -gt 0 ]]; do
+    opt="$(echo "${1/#--/-}" | tr "[:upper:]" "[:lower:]")"
+    case "$opt" in
+      -path|-p)
+        prepend_path=$2
+        shift
+        ;;
+    esac
+    shift
+  done
+  export PATH="$prepend_path:$PATH"
+  if [[ "$ci" == true ]]; then
+    echo "##vso[task.prependpath]$prepend_path"
+  fi
+}
+function Write-PipelineSetResult {
+  local result=''
+  local message=''
+  while [[ $# -gt 0 ]]; do
+    opt="$(echo "${1/#--/-}" | tr "[:upper:]" "[:lower:]")"
+    case "$opt" in
+      -result|-r)
+        result=$2
+        shift
+        ;;
+      -message|-m)
+        message=$2
+        shift
+        ;;
+    esac
+    shift
+  done
+  if [[ "$ci" == true ]]; then
+    echo "##vso[task.complete result=$result;]$message"
+  fi
+}

--- a/src/coreclr/inc/clrconfigvalues.h
+++ b//dev/null
@@ -1,512 +0,0 @@
-CONFIG_DWORD_INFO(INTERNAL_EnableFullDebug, W("EnableFullDebug"), 0, "Heavy-weight checking for AD boundary violations (AD leaks)")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchEnabled, W("JitPitchEnabled"), (DWORD)0, "Set it to 1 to enable Jit Pitching")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchMemThreshold, W("JitPitchMemThreshold"), (DWORD)0, "Do Jit Pitching when code heap usage is larger than this (in bytes)")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchMethodSizeThreshold, W("JitPitchMethodSizeThreshold"), (DWORD)0, "Do Jit Pitching for methods whose native code size larger than this (in bytes)")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchTimeInterval, W("JitPitchTimeInterval"), (DWORD)0, "Time interval between Jit Pitchings in ms")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchPrintStat, W("JitPitchPrintStat"), (DWORD)0, "Print statistics about Jit Pitching")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchMinVal, W("JitPitchMinVal"), (DWORD)0, "Do Jit Pitching if the value of the inner counter greater than this value (for debugging purpose only)")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchMaxVal, W("JitPitchMaxVal"), (DWORD)0xffffffff, "Do Jit Pitching the value of the inner counter less then this value (for debuggin purpose only)")
-CONFIG_DWORD_INFO(INTERNAL_GetAssemblyIfLoadedIgnoreRidMap, W("GetAssemblyIfLoadedIgnoreRidMap"), 0, "Used to force loader to ignore assemblies cached in the rid-map")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_BreakOnBadExit, W("BreakOnBadExit"), 0, "")
-CONFIG_STRING_INFO(INTERNAL_BreakOnClassBuild, W("BreakOnClassBuild"), "Very useful for debugging class layout code.")
-CONFIG_STRING_INFO(INTERNAL_BreakOnClassLoad, W("BreakOnClassLoad"), "Very useful for debugging class loading code.")
-CONFIG_STRING_INFO(INTERNAL_BreakOnComToClrNativeInfoInit, W("BreakOnComToClrNativeInfoInit"), "Throws an assert when native information about a COM -> CLR call are about to be gathered.")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnDebugBreak, W("BreakOnDebugBreak"), 0, "Allows an assert in debug builds when a user break is hit")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnDILoad, W("BreakOnDILoad"), 0, "Allows an assert when the DI is loaded")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnDumpToken, W("BreakOnDumpToken"), 0xffffffff, "Breaks when using internal logging on a particular token value.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_BreakOnEELoad, W("BreakOnEELoad"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnEEShutdown, W("BreakOnEEShutdown"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnExceptionInGetThrowable, W("BreakOnExceptionInGetThrowable"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnFindMethod, W("BreakOnFindMethod"), 0, "Breaks in findMethodInternal when it searches for the specified token.")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnFirstPass, W("BreakOnFirstPass"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnHR, W("BreakOnHR"), 0, "Debug.cpp, IfFailxxx use this macro to stop if hr matches ")
-CONFIG_STRING_INFO(INTERNAL_BreakOnInstantiation, W("BreakOnInstantiation"), "Very useful for debugging generic class instantiation.")
-CONFIG_STRING_INFO(INTERNAL_BreakOnInteropStubSetup, W("BreakOnInteropStubSetup"), "Throws an assert when marshaling stub for the given method is about to be built.")
-CONFIG_STRING_INFO(INTERNAL_BreakOnInteropVTableBuild, W("BreakOnInteropVTableBuild"), "Specifies a type name for which an assert should be thrown when building interop v-table.")
-CONFIG_STRING_INFO(INTERNAL_BreakOnMethodName, W("BreakOnMethodName"), "Very useful for debugging method override placement code.")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnNotify, W("BreakOnNotify"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_BreakOnRetailAssert, W("BreakOnRetailAssert"), 0, "Used for debugging \"retail\" asserts (fatal errors)")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnSecondPass, W("BreakOnSecondPass"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_BreakOnSO, W("BreakOnSO"), 0, "")
-CONFIG_STRING_INFO(INTERNAL_BreakOnStructMarshalSetup, W("BreakOnStructMarshalSetup"), "Throws an assert when field marshalers for the given type with layout are about to be created.")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnUEF, W("BreakOnUEF"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnUncaughtException, W("BreakOnUncaughtException"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableDiagnostics, W("EnableDiagnostics"), 1, "Allows the debugger, profiler, and EventPipe diagnostics to be disabled")
-CONFIG_DWORD_INFO(INTERNAL_D__FCE, W("D::FCE"), 0, "Allows an assert when crawling the managed stack for an exception handler")
-CONFIG_DWORD_INFO(INTERNAL_DbgBreakIfLocksUnavailable, W("DbgBreakIfLocksUnavailable"), 0, "Allows an assert when the debugger can't take a lock ")
-CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnErr, W("DbgBreakOnErr"), 0, "Allows an assert when we get a failing hresult")
-CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnMapPatchToDJI, W("DbgBreakOnMapPatchToDJI"), 0, "Allows an assert when mapping a patch to an address")
-CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnRawInt3, W("DbgBreakOnRawInt3"), 0, "Allows an assert for test coverage for debug break or other int3 breaks")
-CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnSendBreakpoint, W("DbgBreakOnSendBreakpoint"), 0, "Allows an assert when sending a breakpoint to the right side")
-CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnSetIP, W("DbgBreakOnSetIP"), 0, "Allows an assert when setting the IP")
-CONFIG_DWORD_INFO(INTERNAL_DbgCheckInt3, W("DbgCheckInt3"), 0, "Asserts if the debugger explicitly writes int3 instead of calling SetUnmanagedBreakpoint")
-CONFIG_DWORD_INFO(INTERNAL_DbgDACAssertOnMismatch, W("DbgDACAssertOnMismatch"), 0, "Allows an assert when the mscordacwks and mscorwks dll versions don't match")
-CONFIG_DWORD_INFO(INTERNAL_DbgDACEnableAssert, W("DbgDACEnableAssert"), 0, "Enables extra validity checking in DAC - assumes target isn't corrupt")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgDACSkipVerifyDlls, W("DbgDACSkipVerifyDlls"), 0, "Allows disabling the check to ensure mscordacwks and mscorwks dll versions match")
-CONFIG_DWORD_INFO(INTERNAL_DbgDelayHelper, W("DbgDelayHelper"), 0, "Varies the wait in the helper thread startup for testing race between threads")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgDisableDynamicSymsCompat, W("DbgDisableDynamicSymsCompat"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_DbgDisableTargetConsistencyAsserts, W("DbgDisableTargetConsistencyAsserts"), 0, "Allows explicitly testing with corrupt targets")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgEnableMixedModeDebugging, W("DbgEnableMixedModeDebuggingInternalOnly"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_DbgExtraThreads, W("DbgExtraThreads"), 0, "Allows extra unmanaged threads to run and throw debug events for stress testing")
-CONFIG_DWORD_INFO(INTERNAL_DbgExtraThreadsCantStop, W("DbgExtraThreadsCantStop"), 0, "Allows extra unmanaged threads in can't stop region to run and throw debug events for stress testing")
-CONFIG_DWORD_INFO(INTERNAL_DbgExtraThreadsIB, W("DbgExtraThreadsIB"), 0, "Allows extra in-band unmanaged threads to run and throw debug events for stress testing")
-CONFIG_DWORD_INFO(INTERNAL_DbgExtraThreadsOOB, W("DbgExtraThreadsOOB"), 0, "Allows extra out of band unmanaged threads to run and throw debug events for stress testing")
-CONFIG_DWORD_INFO(INTERNAL_DbgFaultInHandleIPCEvent, W("DbgFaultInHandleIPCEvent"), 0, "Allows testing the unhandled event filter")
-CONFIG_DWORD_INFO(INTERNAL_DbgInjectFEE, W("DbgInjectFEE"), 0, "Allows injecting a fatal execution error for testing Watson")
-CONFIG_DWORD_INFO(INTERNAL_DbgLeakCheck, W("DbgLeakCheck"), 0, "Allows checking for leaked Cordb objects")
-CONFIG_DWORD_INFO(INTERNAL_DbgNo2ndChance, W("DbgNo2ndChance"), 0, "Allows breaking on (and catching bogus) 2nd chance exceptions")
-CONFIG_DWORD_INFO(INTERNAL_DbgNoDebugger, W("DbgNoDebugger"), 0, "Allows breaking if we don't want to lazily initialize the debugger")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgNoForceContinue, W("DbgNoForceContinue"), 1, "Used to force a continue on longhorn")
-CONFIG_DWORD_INFO(INTERNAL_DbgNoOpenMDByFile, W("DbgNoOpenMDByFile"), 0, "Allows opening MD by memory for perf testing")
-CONFIG_DWORD_INFO(INTERNAL_DbgOOBinFEEE, W("DbgOOBinFEEE"), 0, "Allows forcing oob breakpoints when a fatal error occurs")
-CONFIG_DWORD_INFO(INTERNAL_DbgPingInterop, W("DbgPingInterop"), 0, "Allows checking for deadlocks in interop debugging")
-CONFIG_DWORD_INFO(INTERNAL_DbgRace, W("DbgRace"), 0, "Allows pausing for native debug events to get hijicked")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgRedirect, W("DbgRedirect"), 0, "Allows for redirecting the event pipeline")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_DbgRedirectApplication, W("DbgRedirectApplication"), "Specifies the auxiliary debugger application to launch.")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_DbgRedirectAttachCmd, W("DbgRedirectAttachCmd"), "Specifies command parameters for attaching the auxiliary debugger.")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_DbgRedirectCommonCmd, W("DbgRedirectCommonCmd"), "Specifies a command line format string for the auxiliary debugger.")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_DbgRedirectCreateCmd, W("DbgRedirectCreateCmd"), "Specifies command parameters when creating the auxiliary debugger.")
-CONFIG_DWORD_INFO(INTERNAL_DbgShortcutCanary, W("DbgShortcutCanary"), 0, "Allows a way to force canary to fail to be able to test failure paths")
-CONFIG_DWORD_INFO(INTERNAL_DbgSkipMEOnStep, W("DbgSkipMEOnStep"), 0, "Turns off MethodEnter checks")
-CONFIG_DWORD_INFO(INTERNAL_DbgSkipVerCheck, W("DbgSkipVerCheck"), 0, "Allows different RS and LS versions (for servicing work)")
-CONFIG_DWORD_INFO(INTERNAL_DbgTC, W("DbgTC"), 0, "Allows checking boundary compression for offset mappings")
-CONFIG_DWORD_INFO(INTERNAL_DbgTransportFaultInject, W("DbgTransportFaultInject"), 0, "Allows injecting a fault for testing the debug transport")
-CONFIG_DWORD_INFO(INTERNAL_DbgTransportLog, W("DbgTransportLog"), 0 /* LE_None */, "Turns on logging for the debug transport")
-CONFIG_DWORD_INFO(INTERNAL_DbgTransportLogClass, W("DbgTransportLogClass"), (DWORD)-1 /* LC_All */, "Mask to control what is logged in DbgTransportLog")
-RETAIL_CONFIG_STRING_INFO(UNSUPPORTED_DbgTransportProxyAddress, W("DbgTransportProxyAddress"), "Allows specifying the transport proxy address")
-CONFIG_DWORD_INFO(INTERNAL_DbgTrapOnSkip, W("DbgTrapOnSkip"), 0, "Allows breaking when we skip a breakpoint")
-CONFIG_DWORD_INFO(INTERNAL_DbgWaitTimeout, W("DbgWaitTimeout"), 1, "Specifies the timeout value for waits")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgWFDETimeout, W("DbgWFDETimeout"), 25, "Specifies the timeout value for wait when waiting for a debug event")
-CONFIG_DWORD_INFO(INTERNAL_RaiseExceptionOnAssert, W("RaiseExceptionOnAssert"), 0, "Raise a first chance (if set to 1) or second chance (if set to 2) exception on asserts.")
-CONFIG_DWORD_INFO(INTERNAL_DebugBreakOnAssert, W("DebugBreakOnAssert"), 0, "If DACCESS_COMPILE is defined, break on asserts.")
-CONFIG_DWORD_INFO(INTERNAL_DebugBreakOnVerificationFailure, W("DebugBreakOnVerificationFailure"), 0, "Halts the jit on verification failure")
-CONFIG_STRING_INFO(INTERNAL_DebuggerBreakPoint, W("DebuggerBreakPoint"), "Allows counting various debug events")
-CONFIG_STRING_INFO(INTERNAL_DebugVerify, W("DebugVerify"), "Control for tracing in peverify")
-CONFIG_DWORD_INFO(INTERNAL_EncApplyChanges, W("EncApplyChanges"), 0, "Allows breaking when ApplyEditAndContinue is called")
-CONFIG_DWORD_INFO(INTERNAL_EnCBreakOnRemapComplete, W("EnCBreakOnRemapComplete"), 0, "Allows breaking after N RemapCompletes")
-CONFIG_DWORD_INFO(INTERNAL_EnCBreakOnRemapOpportunity, W("EnCBreakOnRemapOpportunity"), 0, "Allows breaking after N RemapOpportunities")
-CONFIG_DWORD_INFO(INTERNAL_EncDumpApplyChanges, W("EncDumpApplyChanges"), 0, "Allows dumping edits in delta metadata and il files")
-CONFIG_DWORD_INFO(INTERNAL_EncFixupFieldBreak, W("EncFixupFieldBreak"), 0, "Unlikely that this is used anymore.")
-CONFIG_DWORD_INFO(INTERNAL_EncJitUpdatedFunction, W("EncJitUpdatedFunction"), 0, "Allows breaking when an updated function is jitted")
-CONFIG_DWORD_INFO(INTERNAL_EnCResolveField, W("EnCResolveField"), 0, "Allows breaking when computing the address of an EnC-added field")
-CONFIG_DWORD_INFO(INTERNAL_EncResumeInUpdatedFunction, W("EncResumeInUpdatedFunction"), 0, "Allows breaking when execution resumes in a new EnC version of a function")
-CONFIG_DWORD_INFO(INTERNAL_DbgAssertOnDebuggeeDebugBreak, W("DbgAssertOnDebuggeeDebugBreak"), 0, "If non-zero causes the managed-only debugger to assert on unhandled breakpoints in the debuggee")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgDontResumeThreadsOnUnhandledException, W("UNSUPPORTED_DbgDontResumeThreadsOnUnhandledException"), 0, "If non-zero, then don't try to unsuspend threads after continuing a 2nd-chance native exception")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgSkipStackCheck, W("DbgSkipStackCheck"), 0, "Skip the stack pointer check during stackwalking")
-#ifdef DACCESS_COMPILE
-CONFIG_DWORD_INFO(INTERNAL_DumpGeneration_IntentionallyCorruptDataFromTarget, W("IntentionallyCorruptDataFromTarget"), 0, "Intentionally fakes bad data retrieved from target to try and break dump generation.")
-#endif
-CONFIG_DWORD_INFO(UNSUPPORTED_Debugging_RequiredVersion, W("UNSUPPORTED_Debugging_RequiredVersion"), 0, "The lowest ICorDebug version we should attempt to emulate, or 0 for default policy.  Use 2 for CLRv2, 4 for CLRv4, etc.")
-#ifdef FEATURE_MINIMETADATA_IN_TRIAGEDUMPS
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_MiniMdBufferCapacity, W("MiniMdBufferCapacity"), 64 * 1024, "The max size of the buffer to store mini metadata information for triage- and mini-dumps.")
-#endif // FEATURE_MINIMETADATA_IN_TRIAGEDUMPS
-CONFIG_DWORD_INFO(INTERNAL_DbgNativeCodeBpBindsAcrossVersions, W("DbgNativeCodeBpBindsAcrossVersions"), 0, "If non-zero causes native breakpoints at offset 0 to bind in all tiered compilation versions of the given method")
-CONFIG_DWORD_INFO(INTERNAL_ConditionalContracts, W("ConditionalContracts"), 0, "If ENABLE_CONTRACTS_IMPL is defined, sets whether contracts are conditional. (?)")
-CONFIG_DWORD_INFO(INTERNAL_ConsistencyCheck, W("ConsistencyCheck"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_ContinueOnAssert, W("ContinueOnAssert"), 0, "If set, doesn't break on asserts.")
-CONFIG_DWORD_INFO(INTERNAL_InjectFatalError, W("InjectFatalError"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_InjectFault, W("InjectFault"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_SuppressChecks, W("SuppressChecks"),0,  "")
-#ifdef FEATURE_EH_FUNCLETS
-CONFIG_DWORD_INFO(INTERNAL_SuppressLockViolationsOnReentryFromOS, W("SuppressLockViolationsOnReentryFromOS"), 0, "64 bit OOM tests re-enter the CLR via RtlVirtualUnwind.  This indicates whether to suppress resulting locking violations.")
-#endif // FEATURE_EH_FUNCLETS
-CONFIG_DWORD_INFO(INTERNAL_AssertOnFailFast, W("AssertOnFailFast"), 1, "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_legacyCorruptedStateExceptionsPolicy, W("legacyCorruptedStateExceptionsPolicy"), 0, "Enabled Pre-V4 CSE behavior")
-CONFIG_DWORD_INFO(INTERNAL_SuppressLostExceptionTypeAssert, W("SuppressLostExceptionTypeAssert"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_UseEntryPointFilter, W("UseEntryPointFilter"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_Corhost_Swallow_Uncaught_Exceptions, W("Corhost_Swallow_Uncaught_Exceptions"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_FastGCCheckStack, W("FastGCCheckStack"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_FastGCStress, W("FastGCStress"), 0, "Reduce the number of GCs done by enabling GCStress")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_GCBreakOnOOM, W("GCBreakOnOOM"), 0, "Does a DebugBreak at the soonest time we detect an OOM")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_gcConcurrent, W("gcConcurrent"), (DWORD)-1, "Enables/Disables concurrent GC")
-#ifdef FEATURE_CONSERVATIVE_GC
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_gcConservative, W("gcConservative"), 0, "Enables/Disables conservative GC")
-#endif
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_gcServer, W("gcServer"), 0, "Enables server GC")
-CONFIG_STRING_INFO(INTERNAL_GcCoverage, W("GcCoverage"), "Specify a method or regular expression of method names to run with GCStress")
-CONFIG_STRING_INFO(INTERNAL_SkipGCCoverage, W("SkipGcCoverage"), "Specify a list of assembly names to skip with GC Coverage")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StatsUpdatePeriod, W("StatsUpdatePeriod"), 60, "Specifies the interval, in seconds, at which to update the statistics")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_GCRetainVM, W("GCRetainVM"), 0, "When set we put the segments that should be deleted on a standby list (instead of releasing them back to the OS) which will be considered to satisfy new segment requests (note that the same thing can be specified via API which is the supported way)")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCLOHThreshold, W("GCLOHThreshold"), 0, "Specifies the size that will make objects go on LOH")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_gcAllowVeryLargeObjects, W("gcAllowVeryLargeObjects"), 1, "Allow allocation of 2GB+ objects on GC heap")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCStress, W("GCStress"), 0, "Trigger GCs at regular intervals")
-CONFIG_DWORD_INFO(INTERNAL_GcStressOnDirectCalls, W("GcStressOnDirectCalls"), 0, "Whether to trigger a GC on direct calls")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_HeapVerify, W("HeapVerify"), 0, "When set verifies the integrity of the managed heap on entry and exit of each GC")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_GCNumaAware, W("GCNumaAware"), 1, "Specifies if to enable GC NUMA aware")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCCpuGroup, W("GCCpuGroup"), 0, "Specifies if to enable GC to support CPU groups")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_GCName, W("GCName"), "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_ConvertIbcData, W("ConvertIbcData"), 1, "Converts between v1 and v2 IBC data")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DisableIBC, W("DisableIBC"), 0, "Disables the use of IBC data")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_UseIBCFile, W("UseIBCFile"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_JitBreakEmit, W("JitBreakEmit"), (DWORD)-1, "")
-CONFIG_DWORD_INFO(INTERNAL_JitDebuggable, W("JitDebuggable"), 0, "")
-#if !defined(DEBUG) && !defined(_DEBUG)
-#define INTERNAL_JitEnableNoWayAssert_Default 0
-#else
-#define INTERNAL_JitEnableNoWayAssert_Default 1
-#endif
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitEnableNoWayAssert, W("JitEnableNoWayAssert"), INTERNAL_JitEnableNoWayAssert_Default, "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_JitFramed, W("JitFramed"), 0, "Forces EBP frames")
-CONFIG_DWORD_INFO(INTERNAL_JitGCStress, W("JitGCStress"), 0, "GC stress mode for jit")
-CONFIG_DWORD_INFO(INTERNAL_JitHeartbeat, W("JitHeartbeat"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_JitHelperLogging, W("JitHelperLogging"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_JITMinOpts, W("JITMinOpts"), 0, "Forces MinOpts")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_JitName, W("JitName"), "Primary Jit to use")
-#if defined(ALLOW_SXS_JIT)
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_AltJitName, W("AltJitName"), "Alternative Jit to use, will fall back to primary jit.")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_AltJit, W("AltJit"), "Enables AltJit and selectively limits it to the specified methods.")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_AltJitExcludeAssemblies, W("AltJitExcludeAssemblies"), "Do not use AltJit on this semicolon-delimited list of assemblies.")
-#endif // defined(ALLOW_SXS_JIT)
-#if defined(FEATURE_STACK_SAMPLING)
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StackSamplingEnabled, W("StackSamplingEnabled"), 0, "Is stack sampling based tracking of evolving hot methods enabled.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StackSamplingAfter, W("StackSamplingAfter"), 0, "When to start sampling (for some sort of app steady state), i.e., initial delay for sampling start in milliseconds.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StackSamplingEvery, W("StackSamplingEvery"), 100, "How frequent should thread stacks be sampled in milliseconds.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StackSamplingNumMethods, W("StackSamplingNumMethods"), 32, "Number of evolving methods to track as hot and JIT them in the background at a given point of execution.")
-#endif // defined(FEATURE_JIT_SAMPLING)
-#if defined(ALLOW_SXS_JIT_NGEN)
-RETAIL_CONFIG_STRING_INFO(INTERNAL_AltJitNgen, W("AltJitNgen"), "Enables AltJit for NGEN and selectively limits it to the specified methods.")
-#endif // defined(ALLOW_SXS_JIT_NGEN)
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitHostMaxSlabCache, W("JitHostMaxSlabCache"), 0x1000000, "Sets jit host max slab cache size, 16MB default")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitOptimizeType, W("JitOptimizeType"), 0 /* OPT_DEFAULT */, "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitPrintInlinedMethods, W("JitPrintInlinedMethods"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitTelemetry, W("JitTelemetry"), 1, "If non-zero, gather JIT telemetry data")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_JitTimeLogFile, W("JitTimeLogFile"), "If set, gather JIT throughput data and write to this file.")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_JitTimeLogCsv, W("JitTimeLogCsv"), "If set, gather JIT throughput data and write to a CSV file. This mode must be used in internal retail builds.")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_JitFuncInfoLogFile, W("JitFuncInfoLogFile"), "If set, gather JIT function info and write to this file.")
-CONFIG_DWORD_INFO(INTERNAL_JitVerificationDisable, W("JitVerificationDisable"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitLockWrite, W("JitLockWrite"), 0, "Force all volatile writes to be 'locked'")
-CONFIG_STRING_INFO(INTERNAL_TailCallMax, W("TailCallMax"), "")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_TailCallOpt, W("TailCallOpt"), "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TailCallLoopOpt, W("TailCallLoopOpt"), 1, "Convert recursive tail calls to loops")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_Jit_NetFx40PInvokeStackResilience, W("NetFx40_PInvokeStackResilience"), (DWORD)-1, "Makes P/Invoke resilient against mismatched signature and calling convention (significant perf penalty).")
-#if defined(TARGET_X86)
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_AltJitAssertOnNYI, W("AltJitAssertOnNYI"), 0, "Controls the AltJit behavior of NYI stuff")
-#else
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_AltJitAssertOnNYI, W("AltJitAssertOnNYI"), 1, "Controls the AltJit behavior of NYI stuff")
-#endif
-CONFIG_DWORD_INFO(INTERNAL_JitLargeBranches, W("JitLargeBranches"), 0, "Force using the largest conditional branch format")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitRegisterFP, W("JitRegisterFP"), 3, "Control FP enregistration")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitELTHookEnabled, W("JitELTHookEnabled"), 0, "On ARM, setting this will emit Enter/Leave/TailCall callbacks")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitMemStats, W("JitMemStats"), 0, "Display JIT memory usage statistics")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitVNMapSelBudget, W("JitVNMapSelBudget"), 100, "Max # of MapSelect's considered for a particular top-level invocation.")
-#if defined(TARGET_AMD64) || defined(TARGET_X86) || defined(TARGET_ARM64)
-#define EXTERNAL_FeatureSIMD_Default 1
-#else // !(defined(TARGET_AMD64) || defined(TARGET_X86) || defined(TARGET_ARM64))
-#define EXTERNAL_FeatureSIMD_Default 0
-#endif // !(defined(TARGET_AMD64) || defined(TARGET_X86) || defined(TARGET_ARM64))
-#if defined(TARGET_AMD64) || defined(TARGET_X86)
-#define EXTERNAL_JitEnableAVX_Default 1
-#else // !(defined(TARGET_AMD64) || defined(TARGET_X86)
-#define EXTERNAL_JitEnableAVX_Default 0
-#endif // !(defined(TARGET_AMD64) || defined(TARGET_X86)
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_FeatureSIMD, W("FeatureSIMD"), EXTERNAL_FeatureSIMD_Default, "Enable SIMD intrinsics recognition in System.Numerics.dll and/or System.Numerics.Vectors.dll")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_SIMD16ByteOnly, W("SIMD16ByteOnly"), 0, "Limit maximum SIMD vector length to 16 bytes (used by x64_arm64_altjit)")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableAVX, W("EnableAVX"), EXTERNAL_JitEnableAVX_Default, "Enable AVX instruction set for wide operations as default")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TrackDynamicMethodDebugInfo, W("TrackDynamicMethodDebugInfo"), 0, "Specifies whether debug info should be generated and tracked for dynamic methods")
-#ifdef FEATURE_MULTICOREJIT
-RETAIL_CONFIG_STRING_INFO(INTERNAL_MultiCoreJitProfile, W("MultiCoreJitProfile"), "If set, use the file to store/control multi-core JIT.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_MultiCoreJitProfileWriteDelay, W("MultiCoreJitProfileWriteDelay"), 12, "Set the delay after which the multi-core JIT profile will be written to disk.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_MultiCoreJitMinNumCpus, W("MultiCoreJitMinNumCpus"), 2, "Minimum number of cpus that must be present to allow MultiCoreJit usage.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_MultiCoreJitNoProfileGather, W("MultiCoreJitNoProfileGather"), 0, "Set to 1 to disable profile gathering (but leave possibly enabled profile usage).")
-#endif
-#ifdef FEATURE_INTERPRETER
-RETAIL_CONFIG_STRING_INFO(INTERNAL_Interpret, W("Interpret"), "Selectively uses the interpreter to execute the specified methods")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_InterpretExclude, W("InterpretExclude"), "Excludes the specified methods from the set selected by 'Interpret'")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterMethHashMin, W("InterpreterMethHashMin"), 0, "Only interpret methods selected by 'Interpret' whose hash is at least this value. or after nth")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterMethHashMax, W("InterpreterMethHashMax"), UINT32_MAX, "If non-zero, only interpret methods selected by 'Interpret' whose hash is at most this value")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterStubMin, W("InterpreterStubMin"), 0, "Only interpret methods selected by 'Interpret' whose stub num is at least this value.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterStubMax, W("InterpreterStubMax"), UINT32_MAX, "If non-zero, only interpret methods selected by 'Interpret' whose stub number is at most this value.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterJITThreshold, W("InterpreterJITThreshold"), 10, "The number of times a method should be interpreted before being JITted")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterDoLoopMethods, W("InterpreterDoLoopMethods"), 0, "If set, don't check for loops, start by interpreting *all* methods")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterUseCaching, W("InterpreterUseCaching"), 1, "If non-zero, use the caching mechanism.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterLooseRules, W("InterpreterLooseRules"), 1, "If non-zero, allow ECMA spec violations required by managed C++.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterPrintPostMortem, W("InterpreterPrintPostMortem"), 0, "Prints summary information about the execution to the console")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_InterpreterLogFile, W("InterpreterLogFile"), "If non-null, append interpreter logging to this file, else use stdout")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_DumpInterpreterStubs, W("DumpInterpreterStubs"), 0, "Prints all interpreter stubs that are created to the console")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterEntries, W("TraceInterpreterEntries"), 0, "Logs entries to interpreted methods to the console")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterIL, W("TraceInterpreterIL"), 0, "Logs individual instructions of interpreted methods to the console")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterOstack, W("TraceInterpreterOstack"), 0, "Logs operand stack after each IL instruction of interpreted methods to the console")
-CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterVerbose, W("TraceInterpreterVerbose"), 0, "Logs interpreter progress with detailed messages to the console")
-CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterJITTransition, W("TraceInterpreterJITTransition"), 0, "Logs when the interpreter determines a method should be JITted")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ForceInterpreter, W("ForceInterpreter"), 0, "If non-zero, force the interpreter to be used")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterHWIntrinsicsIsSupportedFalse, W("InterpreterHWIntrinsicsIsSupportedFalse"), 0, "If non-zero, force get_IsSupported to return false for hardware intrinsics") // for internal testing purposes
-#endif
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterFallback, W("InterpreterFallback"), 0, "Fallback to the interpreter when the JIT compiler fails")
-CONFIG_DWORD_INFO(INTERNAL_LoaderHeapCallTracing, W("LoaderHeapCallTracing"), 0, "Loader heap troubleshooting")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_CodeHeapReserveForJumpStubs, W("CodeHeapReserveForJumpStubs"), 1, "Percentage of code heap to reserve for jump stubs")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_NGenReserveForJumpStubs, W("NGenReserveForJumpStubs"), 0, "Percentage of ngen image size to reserve for jump stubs")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_BreakOnOutOfMemoryWithinRange, W("BreakOnOutOfMemoryWithinRange"), 0, "Break before out of memory within range exception is thrown")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_LogEnable, W("LogEnable"), 0, "Turns on the traditional CLR log.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_LogFacility,  W("LogFacility"), 0, "Specifies a facility mask for CLR log. (See 'loglf.h'; VM interprets string value as hex number.) Also used by stresslog.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_LogFacility2, W("LogFacility2"), 0, "Specifies a facility mask for CLR log. (See 'loglf.h'; VM interprets string value as hex number.) Also used by stresslog.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_logFatalError, W("logFatalError"), 1, "Specifies whether EventReporter logs fatal errors in the Windows event log.")
-CONFIG_STRING_INFO(INTERNAL_LogFile, W("LogFile"), "Specifies a file name for the CLR log.")
-CONFIG_DWORD_INFO(INTERNAL_LogFileAppend, W("LogFileAppend"), 0 , "Specifies whether to append to or replace the CLR log file.")
-CONFIG_DWORD_INFO(INTERNAL_LogFlushFile, W("LogFlushFile"), 0 , "Specifies whether to flush the CLR log file on each write.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_LogLevel, W("LogLevel"), 0 , "4=10 msgs, 9=1000000, 10=everything")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_LogToConsole, W("LogToConsole"), 0 , "Writes the CLR log to console.")
-CONFIG_DWORD_INFO(INTERNAL_LogToDebugger, W("LogToDebugger"), 0 , "Writes the CLR log to debugger (OutputDebugStringA).")
-CONFIG_DWORD_INFO(INTERNAL_LogToFile, W("LogToFile"), 0 , "Writes the CLR log to a file.")
-CONFIG_DWORD_INFO(INTERNAL_LogWithPid, W("LogWithPid"), FALSE, "Appends pid to filename for the CLR log.")
-CONFIG_DWORD_INFO(INTERNAL_MD_ApplyDeltaBreak, W("MD_ApplyDeltaBreak"), 0, "ASSERT when applying EnC")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_AssertOnBadImageFormat, W("AssertOnBadImageFormat"), 0, "ASSERT when invalid MD read")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_MD_DeltaCheck, W("MD_DeltaCheck"), 1, "Some checks of GUID when applying EnC (?)")
-CONFIG_DWORD_INFO(INTERNAL_MD_EncDelta, W("MD_EncDelta"), 0, "Forces EnC Delta format in MD (?)")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_MD_ForceNoColDesSharing, W("MD_ForceNoColDesSharing"), 0, "Don't know - the only usage I could find is #if 0 (?)")
-CONFIG_DWORD_INFO(INTERNAL_MD_KeepKnownCA, W("MD_KeepKnownCA"), 0, "Something with known CAs (?)")
-CONFIG_DWORD_INFO(INTERNAL_MD_MiniMDBreak, W("MD_MiniMDBreak"), 0, "ASSERT when creating CMiniMdRw class")
-CONFIG_DWORD_INFO(INTERNAL_MD_PreSaveBreak, W("MD_PreSaveBreak"), 0, "ASSERT when calling CMiniMdRw::PreSave")
-CONFIG_DWORD_INFO(INTERNAL_MD_RegMetaBreak, W("MD_RegMetaBreak"), 0, "ASSERT when creating RegMeta class")
-CONFIG_DWORD_INFO(INTERNAL_MD_RegMetaDump, W("MD_RegMetaDump"), 0, "Dump MD in 4 functions (?)")
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_DOTNET_MODIFIABLE_ASSEMBLIES, W("MODIFIABLE_ASSEMBLIES"), "Enables hot reload on debug built assemblies with the 'debug' keyword", CLRConfig::LookupOptions::TrimWhiteSpaceFromStringValue);
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_MD_PreserveDebuggerMetadataMemory, W("MD_PreserveDebuggerMetadataMemory"), 0, "Save all versions of metadata memory in the debugger when debuggee metadata is updated")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinInitialDuration, W("SpinInitialDuration"), 0x32, "Hex value specifying the first spin duration")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinBackoffFactor, W("SpinBackoffFactor"), 0x3, "Hex value specifying the growth of each successive spin duration")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinLimitProcCap, W("SpinLimitProcCap"), 0xFFFFFFFF, "Hex value specifying the largest value of NumProcs to use when calculating the maximum spin duration")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinLimitProcFactor, W("SpinLimitProcFactor"), 0x4E20, "Hex value specifying the multiplier on NumProcs to use when calculating the maximum spin duration")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinLimitConstant, W("SpinLimitConstant"), 0x0, "Hex value specifying the constant to add when calculating the maximum spin duration")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinRetryCount, W("SpinRetryCount"), 0xA, "Hex value specifying the number of times the entire spin process is repeated (when applicable)")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_Monitor_SpinCount, W("Monitor_SpinCount"), 0x1e, "Hex value specifying the maximum number of spin iterations Monitor may perform upon contention on acquiring the lock before waiting.")
-CONFIG_DWORD_INFO(INTERNAL_NgenBind_ZapForbid,             W("NgenBind_ZapForbid"), 0, "Assert if an assembly succeeds in binding to a native image")
-CONFIG_STRING_INFO(INTERNAL_NgenBind_ZapForbidExcludeList, W("NgenBind_ZapForbidExcludeList"), "")
-CONFIG_STRING_INFO(INTERNAL_NgenBind_ZapForbidList,        W("NgenBind_ZapForbidList"), "")
-CONFIG_DWORD_INFO(INTERNAL_SymDiffDump, W("SymDiffDump"), 0, "Used to create the map file while binding the assembly. Used by SemanticDiffer")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_NGenFramed, W("NGenFramed"), (DWORD)-1, "Same as JitFramed, but for ngen")
-CONFIG_DWORD_INFO(INTERNAL_NGenOnlyOneMethod, W("NGenOnlyOneMethod"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_NgenOrder, W("NgenOrder"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_partialNGenStress, W("partialNGenStress"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_ZapDoNothing, W("ZapDoNothing"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_NgenForceFailureMask, W("NgenForceFailureMask"), (DWORD)-1, "Bitmask used to control which locations will check and raise the failure (defaults to bits: -1)")
-CONFIG_DWORD_INFO(INTERNAL_NgenForceFailureCount, W("NgenForceFailureCount"), 0, "If set to >0 and we have IBC data we will force a failure after we reference an IBC data item <value> times")
-CONFIG_DWORD_INFO(INTERNAL_NgenForceFailureKind, W("NgenForceFailureKind"), 1, "If set to 1, We will throw a TypeLoad exception; If set to 2, We will cause an A/V")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_NGenEnableCreatePdb, W("NGenEnableCreatePdb"), 0, "If set to >0 ngen.exe displays help on, recognizes createpdb in the command line")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_NGenSimulateDiskFull, W("NGenSimulateDiskFull"), 0, "If set to 1, ngen will throw a Disk full exception in ZapWriter.cpp:Save()")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_PartialNGen, W("PartialNGen"), (DWORD)-1, "Generate partial NGen images")
-CONFIG_DWORD_INFO(INTERNAL_NoASLRForNgen, W("NoASLRForNgen"), 0, "Turn off IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE bit in generated ngen images. Makes nidump output repeatable from run to run.")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_NativeImageSearchPaths, W("NativeImageSearchPaths"), "Extra search paths for native composite R2R images")
-#ifdef CROSSGEN_COMPILE
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_CrossGenAssumeInputSigned, W("CrossGenAssumeInputSigned"), 1, "CrossGen should assume that its input assemblies will be signed before deployment")
-#endif
-RETAIL_CONFIG_DWORD_INFO_EX(EXTERNAL_COR_ENABLE_PROFILING, W("COR_ENABLE_PROFILING"), 0, "Flag to indicate whether profiling should be enabled for the currently running process.", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_COR_PROFILER, W("COR_PROFILER"), "Specifies GUID of profiler to load into currently running process", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_COR_PROFILER_PATH, W("COR_PROFILER_PATH"), "Specifies the path to the DLL of profiler to load into currently running process", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_COR_PROFILER_PATH_32, W("COR_PROFILER_PATH_32"), "Specifies the path to the DLL of profiler to load into currently running 32 bits process", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_COR_PROFILER_PATH_64, W("COR_PROFILER_PATH_64"), "Specifies the path to the DLL of profiler to load into currently running 64 bits process", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_DWORD_INFO_EX(EXTERNAL_CORECLR_ENABLE_PROFILING, W("CORECLR_ENABLE_PROFILING"), 0, "CoreCLR only: Flag to indicate whether profiling should be enabled for the currently running process.", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER, W("CORECLR_PROFILER"), "CoreCLR only: Specifies GUID of profiler to load into currently running process", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH, W("CORECLR_PROFILER_PATH"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running process", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH_32, W("CORECLR_PROFILER_PATH_32"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running 32 process", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH_64, W("CORECLR_PROFILER_PATH_64"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running 64 process", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH_ARM32, W("CORECLR_PROFILER_PATH_ARM32"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running ARM32 process", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH_ARM64, W("CORECLR_PROFILER_PATH_ARM64"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running ARM64 process", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_DWORD_INFO_EX(EXTERNAL_CORECLR_ENABLE_NOTIFICATION_PROFILERS, W("CORECLR_ENABLE_NOTIFICATION_PROFILERS"), 0, "Set to 0 to disable loading notification profilers.", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS_64, W("CORECLR_NOTIFICATION_PROFILERS_64"), "A semi-colon separated list of notification profilers to load in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS_32, W("CORECLR_NOTIFICATION_PROFILERS_32"), "A semi-colon separated list of notification profilers to load in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS, W("CORECLR_NOTIFICATION_PROFILERS"), "A semi-colon separated list of notification profilers to load in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_ProfAPI_ProfilerCompatibilitySetting, W("ProfAPI_ProfilerCompatibilitySetting"), "Specifies the profiler loading policy (the default is not to load a V2 profiler in V4)", CLRConfig::LookupOptions::TrimWhiteSpaceFromStringValue)
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ProfAPI_DetachMinSleepMs, W("ProfAPI_DetachMinSleepMs"), 0, "The minimum time, in milliseconds, the CLR will wait before checking whether a profiler that is in the process of detaching is ready to be unloaded.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ProfAPI_DetachMaxSleepMs, W("ProfAPI_DetachMaxSleepMs"), 0, "The maximum time, in milliseconds, the CLR will wait before checking whether a profiler that is in the process of detaching is ready to be unloaded.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ProfAPI_RejitOnAttach, W("ProfApi_RejitOnAttach"), 1, "Enables the ability for profilers to rejit methods on attach.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ProfAPI_InliningTracking, W("ProfApi_InliningTracking"), 1, "Enables the runtime's tracking of inlining for profiler ReJIT.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_DebuggerLaunchDisablesCodeVersioning, W("EXTERNAL_DebuggerLaunchDisablesCodeVersioning"), 1, "Attaching a debugger at startup will disable TieredCompilation and RejitOnAttach.")
-CONFIG_DWORD_INFO(INTERNAL_ProfAPI_EnableRejitDiagnostics, W("ProfAPI_EnableRejitDiagnostics"), 0, "Enable extra dumping to stdout of rejit structures")
-CONFIG_DWORD_INFO(INTERNAL_ProfAPIFault, W("ProfAPIFault"), 0, "Test-only bitmask to inject various types of faults in the profapi code")
-CONFIG_DWORD_INFO(INTERNAL_TestOnlyAllowedEventMask, W("TestOnlyAllowedEventMask"), 0, "Test-only bitmask to allow profiler tests to override CLR enforcement of COR_PRF_ALLOWABLE_AFTER_ATTACH and COR_PRF_MONITOR_IMMUTABLE")
-CONFIG_DWORD_INFO(INTERNAL_TestOnlyEnableICorProfilerInfo, W("ProfAPI_TestOnlyEnableICorProfilerInfo"), 0, "Test-only flag to allow attaching profiler tests to call ICorProfilerInfo interface, which would otherwise be disallowed for attaching profilers")
-CONFIG_DWORD_INFO(INTERNAL_TestOnlyEnableObjectAllocatedHook, W("TestOnlyEnableObjectAllocatedHook"), 0, "Test-only flag that forces CLR to initialize on startup as if ObjectAllocated callback were requested, to enable post-attach ObjectAllocated functionality.")
-CONFIG_DWORD_INFO(INTERNAL_TestOnlyEnableSlowELTHooks, W("TestOnlyEnableSlowELTHooks"), 0, "Test-only flag that forces CLR to initialize on startup as if slow-ELT were requested, to enable post-attach ELT functionality.")
-RETAIL_CONFIG_STRING_INFO(UNSUPPORTED_ETW_ObjectAllocationEventsPerTypePerSec, W("ETW_ObjectAllocationEventsPerTypePerSec"), "Desired number of GCSampledObjectAllocation ETW events to be logged per type per second.  If 0, then the default built in to the implementation for the enabled event (e.g., High, Low), will be used.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_ProfAPI_ValidateNGENInstrumentation, W("ProfAPI_ValidateNGENInstrumentation"), 0, "This flag enables additional validations when using the IMetaDataEmit APIs for NGEN'ed images to ensure only supported edits are made.")
-#ifdef FEATURE_PERFMAP
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_PerfMapEnabled, W("PerfMapEnabled"), 0, "This flag is used on Linux to enable writing /tmp/perf-$pid.map. It is disabled by default")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_PerfMapJitDumpPath, W("PerfMapJitDumpPath"), "Specifies a path to write the perf jitdump file. Defaults to /tmp")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_PerfMapIgnoreSignal, W("PerfMapIgnoreSignal"), 0, "When perf map is enabled, this option will configure the specified signal to be accepted and ignored as a marker in the perf logs.  It is disabled by default")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_PerfMapShowOptimizationTiers, W("PerfMapShowOptimizationTiers"), 1, "Shows optimization tiers in the perf map for methods, as part of the symbol name. Useful for seeing separate stack frames for different optimization tiers of each method.")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_NativeImagePerfMapFormat, W("NativeImagePerfMapFormat"), "Specifies the format of native image perfmap files generated by crossgen.  Valid options are RVA or OFFSET.")
-#endif
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_StartupDelayMS, W("StartupDelayMS"), "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StressLog, W("StressLog"), 0, "Turns on the stress log.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_ForceEnc, W("ForceEnc"), 0, "Forces Edit and Continue to be on for all eligible modules.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StressLogSize, W("StressLogSize"), 0, "Stress log size in bytes per thread.")
-RETAIL_CONFIG_STRING_INFO(UNSUPPORTED_StressLogFilename, W("StressLogFilename"), "Stress log filename for memory mapped stress log.")
-CONFIG_DWORD_INFO(INTERNAL_stressSynchronized, W("stressSynchronized"), 0, "Unknown if or where this is used; unless a test is specifically depending on this, it can be removed.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TotalStressLogSize, W("TotalStressLogSize"), 0, "Total stress log size in bytes.")
-CONFIG_DWORD_INFO(INTERNAL_DiagnosticSuspend, W("DiagnosticSuspend"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_SuspendDeadlockTimeout, W("SuspendDeadlockTimeout"), 40000, "")
-CONFIG_DWORD_INFO(INTERNAL_SuspendThreadDeadlockTimeoutMs, W("SuspendThreadDeadlockTimeoutMs"), 2000, "")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadSuspendInjection, W("INTERNAL_ThreadSuspendInjection"), 1, "Specifies whether to inject activations for thread suspension on Unix")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_DefaultStackSize, W("DefaultStackSize"), 0, "Stack size to use for new VM threads when thread is created with default stack size (dwStackSize == 0).")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_Thread_DeadThreadCountThresholdForGCTrigger, W("Thread_DeadThreadCountThresholdForGCTrigger"), 75, "In the heuristics to clean up dead threads, this threshold must be reached before triggering a GC will be considered. Set to 0 to disable triggering a GC based on dead threads.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_Thread_DeadThreadGCTriggerPeriodMilliseconds, W("Thread_DeadThreadGCTriggerPeriodMilliseconds"), 1000 * 60 * 30, "In the heuristics to clean up dead threads, this much time must have elapsed since the previous max-generation GC before triggering another GC will be considered")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_Thread_UseAllCpuGroups, W("Thread_UseAllCpuGroups"), 0, "Specifies whether to query and use CPU group information for determining the processor count.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_Thread_AssignCpuGroups, W("Thread_AssignCpuGroups"), 1, "Specifies whether to automatically distribute threads created by the CLR across CPU Groups. Effective only when Thread_UseAllCpuGroups and GCCpuGroup are enabled.")
-RETAIL_CONFIG_DWORD_INFO_EX(EXTERNAL_ProcessorCount, W("PROCESSOR_COUNT"), 0, "Specifies the number of processors available for the process, which is returned by Environment.ProcessorCount", CLRConfig::LookupOptions::ParseIntegerAsBase10)
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_UsePortableThreadPool, W("ThreadPool_UsePortableThreadPool"), 1, "Uses the managed portable thread pool implementation instead of the unmanaged one.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_ForceMinWorkerThreads, W("ThreadPool_ForceMinWorkerThreads"), 0, "Overrides the MinThreads setting for the ThreadPool worker pool")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_ForceMaxWorkerThreads, W("ThreadPool_ForceMaxWorkerThreads"), 0, "Overrides the MaxThreads setting for the ThreadPool worker pool")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_DisableStarvationDetection, W("ThreadPool_DisableStarvationDetection"), 0, "Disables the ThreadPool feature that forces new threads to be added when workitems run for too long")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_DebugBreakOnWorkerStarvation, W("ThreadPool_DebugBreakOnWorkerStarvation"), 0, "Breaks into the debugger if the ThreadPool detects work queue starvation")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_EnableWorkerTracking, W("ThreadPool_EnableWorkerTracking"), 0, "Enables extra expensive tracking of how many workers threads are working simultaneously")
-#ifdef TARGET_ARM64
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_UnfairSemaphoreSpinLimit, W("ThreadPool_UnfairSemaphoreSpinLimit"), 0x32, "Maximum number of spins per processor a thread pool worker thread performs before waiting for work")
-#else // !TARGET_ARM64
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_UnfairSemaphoreSpinLimit, W("ThreadPool_UnfairSemaphoreSpinLimit"), 0x46, "Maximum number of spins a thread pool worker thread performs before waiting for work")
-#endif // TARGET_ARM64
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_Disable,                             W("HillClimbing_Disable"),                            0, "Disables hill climbing for thread adjustments in the thread pool");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_WavePeriod,                          W("HillClimbing_WavePeriod"),                         4, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_TargetSignalToNoiseRatio,            W("HillClimbing_TargetSignalToNoiseRatio"),           300, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_ErrorSmoothingFactor,                W("HillClimbing_ErrorSmoothingFactor"),               1, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_WaveMagnitudeMultiplier,             W("HillClimbing_WaveMagnitudeMultiplier"),            100, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_MaxWaveMagnitude,                    W("HillClimbing_MaxWaveMagnitude"),                   20, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_WaveHistorySize,                     W("HillClimbing_WaveHistorySize"),                    8, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_Bias,                                W("HillClimbing_Bias"),                               15, "The 'cost' of a thread.  0 means drive for increased throughput regardless of thread count; higher values bias more against higher thread counts.");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_MaxChangePerSecond,                  W("HillClimbing_MaxChangePerSecond"),                 4, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_MaxChangePerSample,                  W("HillClimbing_MaxChangePerSample"),                 20, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_MaxSampleErrorPercent,               W("HillClimbing_MaxSampleErrorPercent"),              15, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_SampleIntervalLow,                   W("HillClimbing_SampleIntervalLow"),                  10, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_SampleIntervalHigh,                  W("HillClimbing_SampleIntervalHigh"),                 200, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_GainExponent,                        W("HillClimbing_GainExponent"),                       200, "The exponent to apply to the gain, times 100.  100 means to use linear gain, higher values will enhance large moves and damp small ones.");
-#ifdef FEATURE_TIERED_COMPILATION
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TieredCompilation, W("TieredCompilation"), 1, "Enables tiered compilation")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TC_QuickJit, W("TC_QuickJit"), 1, "For methods that would be jitted, enable using quick JIT when appropriate.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TC_QuickJitForLoops, W("TC_QuickJitForLoops"), 0, "When quick JIT is enabled, quick JIT may also be used for methods that contain loops.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TC_AggressiveTiering, W("TC_AggressiveTiering"), 0, "Transition through tiers aggressively.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_BackgroundWorkerTimeoutMs, W("TC_BackgroundWorkerTimeoutMs"), 4000, "How long in milliseconds the background worker thread may remain idle before exiting.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_CallCountThreshold, W("TC_CallCountThreshold"), 30, "Number of times a method must be called in tier 0 after which it is promoted to the next tier.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_CallCountingDelayMs, W("TC_CallCountingDelayMs"), 100, "A perpetual delay in milliseconds that is applied call counting in tier 0 and jitting at higher tiers, while there is startup-like activity.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_DelaySingleProcMultiplier, W("TC_DelaySingleProcMultiplier"), 10, "Multiplier for TC_CallCountingDelayMs that is applied on a single-processor machine or when the process is affinitized to a single processor.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_CallCounting, W("TC_CallCounting"), 1, "Enabled by default (only activates when TieredCompilation is also enabled). If disabled immediately backpatches prestub, and likely prevents any promotion to higher tiers")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_UseCallCountingStubs, W("TC_UseCallCountingStubs"), 1, "Uses call counting stubs for faster call counting.")
-#ifdef _DEBUG
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_DeleteCallCountingStubsAfter, W("TC_DeleteCallCountingStubsAfter"), 1, "Deletes call counting stubs after this many have completed. Zero to disable deleting.")
-#else
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_DeleteCallCountingStubsAfter, W("TC_DeleteCallCountingStubsAfter"), 4096, "Deletes call counting stubs after this many have completed. Zero to disable deleting.")
-#endif
-#endif // FEATURE_TIERED_COMPILATION
-#ifdef FEATURE_ON_STACK_REPLACEMENT
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_OSR_CounterBump, W("OSR_CounterBump"), 1000, "Counter reload value when a patchpoint is hit")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_OSR_HitLimit, W("OSR_HitLimit"), 10, "Number of times a patchpoint must call back to trigger an OSR transition")
-CONFIG_DWORD_INFO(INTERNAL_OSR_LowId, W("OSR_LowId"), (DWORD)-1, "Low end of enabled patchpoint range (inclusive)");
-CONFIG_DWORD_INFO(INTERNAL_OSR_HighId, W("OSR_HighId"), 10000000, "High end of enabled patchpoint range (inclusive)");
-#endif
-#ifdef FEATURE_PGO
-RETAIL_CONFIG_STRING_INFO(INTERNAL_PGODataPath, W("PGODataPath"), "Read/Write PGO data from/to the indicated file.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ReadPGOData, W("ReadPGOData"), 0, "Read PGO data")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_WritePGOData, W("WritePGOData"), 0, "Write PGO data")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TieredPGO, W("TieredPGO"), 0, "Instrument Tier0 code and make counts available to Tier1")
-#endif
-#ifndef CROSSGEN_COMPILE
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_BackpatchEntryPointSlots, W("BackpatchEntryPointSlots"), 1, "Indicates whether to enable entry point slot backpatching, for instance to avoid making virtual calls through a precode and instead to patch virtual slots for a method when its entry point changes.")
-#endif
-CONFIG_DWORD_INFO(INTERNAL_TypeLoader_InjectInterfaceDuplicates, W("INTERNAL_TypeLoader_InjectInterfaceDuplicates"), 0, "Injects duplicates in interface map for all types.")
-CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubCollideMonoPct, W("VirtualCallStubCollideMonoPct"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
-CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubCollideWritePct, W("VirtualCallStubCollideWritePct"), 100, "Used only when STUB_LOGGING is defined, which by default is not.")
-CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubDumpLogCounter, W("VirtualCallStubDumpLogCounter"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
-CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubDumpLogIncr, W("VirtualCallStubDumpLogIncr"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_VirtualCallStubLogging, W("VirtualCallStubLogging"), 0, "Worth keeping, but should be moved into \"#ifdef STUB_LOGGING\" blocks. This goes for most (or all) of the stub logging infrastructure.")
-CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubMissCount, W("VirtualCallStubMissCount"), 100, "Used only when STUB_LOGGING is defined, which by default is not.")
-CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubResetCacheCounter, W("VirtualCallStubResetCacheCounter"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
-CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubResetCacheIncr, W("VirtualCallStubResetCacheIncr"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_DisableWatsonForManagedExceptions, W("DisableWatsonForManagedExceptions"), 0, "Disable Watson and debugger launching for managed exceptions")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgEnableMiniDump, W("DbgEnableMiniDump"), 0, "Enable unhandled exception crash dump generation")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_DbgMiniDumpName, W("DbgMiniDumpName"), "Crash dump name")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgMiniDumpType, W("DbgMiniDumpType"), 0, "Crash dump type: 1 normal, 2 withheap, 3 triage, 4 full")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_CreateDumpDiagnostics, W("CreateDumpDiagnostics"), 0, "Enable crash dump generation diagnostic logging")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EnableDumpOnSigTerm, W("EnableDumpOnSigTerm"), 0, "Enable crash dump generation on SIGTERM")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_ZapBBInstr, W("ZapBBInstr"), "")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_ZapBBInstrDir, W("ZapBBInstrDir"), "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ZapDisable, W("ZapDisable"), 0, "")
-CONFIG_STRING_INFO(INTERNAL_ZapExclude, W("ZapExclude"), "")
-CONFIG_STRING_INFO(INTERNAL_ZapOnly, W("ZapOnly"), "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ZapRequire, W("ZapRequire"), 0, "")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_ZapRequireExcludeList, W("ZapRequireExcludeList"), "")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_ZapRequireList, W("ZapRequireList"), "")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_ZapSet, W("ZapSet"), "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ReadyToRun, W("ReadyToRun"), 1, "Enable/disable use of ReadyToRun native code") // On by default for CoreCLR
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_ReadyToRunExcludeList, W("ReadyToRunExcludeList"), "List of assemblies that cannot use Ready to Run images")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_ReadyToRunLogFile, W("ReadyToRunLogFile"), "Name of file to log success/failure of using Ready to Run images")
-#if defined(FEATURE_EVENT_TRACE) || defined(FEATURE_EVENTSOURCE_XPLAT)
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableEventLog, W("EnableEventLog"), 0, "Enable/disable use of EnableEventLogging mechanism ") // Off by default
-RETAIL_CONFIG_STRING_INFO(INTERNAL_EventSourceFilter, W("EventSourceFilter"), "")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_EventNameFilter, W("EventNameFilter"), "")
-#endif //defined(FEATURE_EVENT_TRACE) || defined(FEATURE_EVENTSOURCE_XPLAT)
-CONFIG_DWORD_INFO(INTERNAL_ExposeExceptionsInCOM, W("ExposeExceptionsInCOM"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_InteropValidatePinnedObjects, W("InteropValidatePinnedObjects"), 0, "After returning from a managed-to-unmanaged interop call, validate GC heap around objects pinned by IL stubs.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_InteropLogArguments, W("InteropLogArguments"), 0, "Log all pinned arguments passed to an interop call")
-RETAIL_CONFIG_STRING_INFO(UNSUPPORTED_LogCCWRefCountChange, W("LogCCWRefCountChange"), "Outputs debug information and calls LogCCWRefCountChange_BREAKPOINT when AddRef or Release is called on a CCW.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EnableRCWCleanupOnSTAShutdown, W("EnableRCWCleanupOnSTAShutdown"), 0, "Performs RCW cleanup when STA shutdown is detected using IInitializeSpy in classic processes.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EnableEventPipe, W("EnableEventPipe"), 0, "Enable/disable event pipe.  Non-zero values enable tracing.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeNetTraceFormat, W("EventPipeNetTraceFormat"), 1, "Enable/disable using the newer nettrace file format.")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_EventPipeOutputPath, W("EventPipeOutputPath"), "The full path excluding file name for the trace file that will be written when COMPlus_EnableEventPipe=1")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_EventPipeConfig, W("EventPipeConfig"), "Configuration for EventPipe.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeRundown, W("EventPipeRundown"), 1, "Enable/disable eventpipe rundown.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeCircularMB, W("EventPipeCircularMB"), 1024, "The EventPipe circular buffer size in megabytes.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeProcNumbers, W("EventPipeProcNumbers"), 0, "Enable/disable capturing processor numbers in EventPipe event headers")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeOutputStreaming, W("EventPipeOutputStreaming"), 0, "Enable/disable streaming for trace file set in COMPlus_EventPipeOutputPath.  Non-zero values enable streaming.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_GCGenAnalysisGen, W("GCGenAnalysisGen"), 0, "The generation to trigger generational aware analysis")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_GCGenAnalysisBytes, W("GCGenAnalysisBytes"), 0, "The number of bytes to trigger generational aware analysis")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_GCGenAnalysisIndex, W("GCGenAnalysisIndex"), 0, "The gc index to trigger generational aware analysis")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_GCGenAnalysisCmd, W("GCGenAnalysisCmd"), "An optional filter to match with the command line used to spawn the process")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_GCGenAnalysisTrace, W("GCGenAnalysisTrace"), 1, "Enable/Disable capturing a trace")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_GCGenAnalysisDump, W("GCGenAnalysisDump"), 0, "Enable/Disable capturing a dump")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_DOTNET_DefaultDiagnosticPortSuspend, W("DefaultDiagnosticPortSuspend"), 0, "This sets the deafult diagnostic port to suspend causing the runtime to pause during startup before major subsystems are started.  Resume using the Diagnostics IPC ResumeStartup command on the default diagnostic port.");
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_DOTNET_DiagnosticPorts, W("DiagnosticPorts"), "A semicolon delimited list of additional Diagnostic Ports, where a Diagnostic Port is a NamedPipe path without '\\\\.\\pipe\\' on Windows or the full path of Unix Domain Socket on Linux/Unix followed by optional tags, e.g., '<path>,connect,nosuspend;<path>'");
-RETAIL_CONFIG_STRING_INFO(INTERNAL_LTTngConfig, W("LTTngConfig"), "Configuration for LTTng.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_LTTng, W("LTTng"), 1, "If COMPlus_LTTng is set to 0, this will prevent the LTTng library from being loaded at runtime")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableWriteXorExecute, W("EnableWriteXorExecute"), 0, "Enable W^X for executable memory.");
-#ifdef FEATURE_GDBJIT
-CONFIG_STRING_INFO(INTERNAL_GDBJitElfDump, W("GDBJitElfDump"), "Dump ELF for specified method")
-#ifdef FEATURE_GDBJIT_FRAME
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_GDBJitEmitDebugFrame, W("GDBJitEmitDebugFrame"), TRUE, "Enable .debug_frame generation")
-#endif
-#endif
-CONFIG_DWORD_INFO(INTERNAL_ActivatePatchSkip, W("ActivatePatchSkip"), 0, "Allows an assert when ActivatePatchSkip is called")
-CONFIG_DWORD_INFO(INTERNAL_AlwaysUseMetadataInterfaceMapLayout, W("AlwaysUseMetadataInterfaceMapLayout"), 0, "Used for debugging generic interface map layout.")
-CONFIG_DWORD_INFO(INTERNAL_AssertOnUnneededThis, W("AssertOnUnneededThis"), 0, "While the ConfigDWORD is unnecessary, the contained ASSERT should be kept. This may result in some work tracking down violating MethodDescCallSites.")
-CONFIG_DWORD_INFO(INTERNAL_AssertStacktrace, W("AssertStacktrace"), 1, "")
-CONFIG_DWORD_INFO(INTERNAL_clearNativeImageStress, W("clearNativeImageStress"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_CPUFamily, W("CPUFamily"), 0xFFFFFFFF, "")
-CONFIG_DWORD_INFO(INTERNAL_CPUFeatures, W("CPUFeatures"), 0xFFFFFFFF, "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_DisableConfigCache, W("DisableConfigCache"), 0, "Used to disable the \"probabilistic\" config cache, which walks through the appropriate config registry keys on init and probabilistically keeps track of which exist.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_DisableStackwalkCache, W("DisableStackwalkCache"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DoubleArrayToLargeObjectHeap, W("DoubleArrayToLargeObjectHeap"), 0, "Controls double[] placement")
-CONFIG_STRING_INFO(INTERNAL_DumpOnClassLoad, W("DumpOnClassLoad"), "Dumps information about loaded class to log.")
-CONFIG_DWORD_INFO(INTERNAL_ExpandAllOnLoad, W("ExpandAllOnLoad"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_ForceRelocs, W("ForceRelocs"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_GenerateLongJumpDispatchStubRatio, W("GenerateLongJumpDispatchStubRatio"), 0, "Useful for testing VSD on AMD64")
-CONFIG_DWORD_INFO(INTERNAL_HashStack, W("HashStack"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_HostManagerConfig, W("HostManagerConfig"), (DWORD)-1, "")
-CONFIG_DWORD_INFO(INTERNAL_HostTestThreadAbort, W("HostTestThreadAbort"), 0, "")
-CONFIG_STRING_INFO(INTERNAL_InvokeHalt, W("InvokeHalt"), "Throws an assert when the given method is invoked through reflection.")
-CONFIG_DWORD_INFO(INTERNAL_MaxStubUnwindInfoSegmentSize, W("MaxStubUnwindInfoSegmentSize"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_MessageDebugOut, W("MessageDebugOut"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_NativeImageRequire, W("NativeImageRequire"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_NestedEhOom, W("NestedEhOom"), 0, "")
-#define INTERNAL_NoGuiOnAssert_Default 1
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_NoGuiOnAssert, W("NoGuiOnAssert"), INTERNAL_NoGuiOnAssert_Default, "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_NoProcedureSplitting, W("NoProcedureSplitting"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_NoStringInterning, W("NoStringInterning"), 1, "Disallows string interning. I see no value in it anymore.")
-CONFIG_DWORD_INFO(INTERNAL_PauseOnLoad, W("PauseOnLoad"), 0, "Stops in SystemDomain::init. I think it can be removed.")
-CONFIG_DWORD_INFO(INTERNAL_PerfAllocsSizeThreshold, W("PerfAllocsSizeThreshold"), 0x3FFFFFFF, "Log facility LF_GCALLOC logs object allocations. This flag controls which ones also log stacktraces. Predates ClrProfiler.")
-CONFIG_DWORD_INFO(INTERNAL_PerfNumAllocsThreshold, W("PerfNumAllocsThreshold"), 0x3FFFFFFF, "Log facility LF_GCALLOC logs object allocations. This flag controls which ones also log stacktraces. Predates ClrProfiler.")
-CONFIG_STRING_INFO(INTERNAL_PerfTypesToLog, W("PerfTypesToLog"), "Log facility LF_GCALLOC logs object allocations. This flag controls which ones also log stacktraces. Predates ClrProfiler.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_Prepopulate1, W("Prepopulate1"), 1, "")
-CONFIG_STRING_INFO(INTERNAL_PrestubGC, W("PrestubGC"), "")
-CONFIG_STRING_INFO(INTERNAL_PrestubHalt, W("PrestubHalt"), "")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_RestrictedGCStressExe, W("RestrictedGCStressExe"), "")
-CONFIG_DWORD_INFO(INTERNAL_ReturnSourceTypeForTesting, W("ReturnSourceTypeForTesting"), 0, "Allows returning the (internal only) source type of an IL to Native mapping for debugging purposes")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_RSStressLog, W("RSStressLog"), 0, "Allows turning on logging for RS startup")
-CONFIG_DWORD_INFO(INTERNAL_SBDumpOnNewIndex, W("SBDumpOnNewIndex"), 0, "Used for Syncblock debugging. It's been a while since any of those have been used.")
-CONFIG_DWORD_INFO(INTERNAL_SBDumpOnResize, W("SBDumpOnResize"), 0, "Used for Syncblock debugging. It's been a while since any of those have been used.")
-CONFIG_DWORD_INFO(INTERNAL_SBDumpStyle, W("SBDumpStyle"), 0, "Used for Syncblock debugging. It's been a while since any of those have been used.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_SleepOnExit, W("SleepOnExit"), 0, "Used for lrak detection. I'd say deprecated by umdh.")
-CONFIG_DWORD_INFO(INTERNAL_StubLinkerUnwindInfoVerificationOn, W("StubLinkerUnwindInfoVerificationOn"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_SuccessExit, W("SuccessExit"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TestDataConsistency, W("TestDataConsistency"), FALSE, "Allows ensuring the left side is not holding locks (and may thus be in an inconsistent state) when inspection occurs")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ThreadGuardPages, W("ThreadGuardPages"), 0, "")
-#ifdef _DEBUG
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TraceWrap, W("TraceWrap"), 0, "")
-#endif
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_UseMethodDataCache, W("UseMethodDataCache"), FALSE, "Used during feature development; may now be removed.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_UseParentMethodData, W("UseParentMethodData"), TRUE, "Used during feature development; may now be removed.")
-CONFIG_DWORD_INFO(INTERNAL_VerifierOff, W("VerifierOff"), 0, "")

--- a/src/coreclr/vm/perfinfo.cpp
+++ b//dev/null
@@ -1,91 +0,0 @@
-#include "common.h"
-#if defined(FEATURE_PERFMAP) && !defined(DACCESS_COMPILE)
-#include "perfinfo.h"
-#include "pal.h"
-PerfInfo::PerfInfo(int pid, const char* basePath)
-  : m_Stream(nullptr)
-{
-    LIMITED_METHOD_CONTRACT;
-    SString path;
-    path.Printf("%s/perfinfo-%d.map", basePath, pid);
-    OpenFile(path);
-}
-void PerfInfo::LogImage(PEFile* pFile, WCHAR* guid)
-{
-    CONTRACTL
-    {
-        THROWS;
-        GC_NOTRIGGER;
-        MODE_PREEMPTIVE;
-        PRECONDITION(pFile != nullptr);
-        PRECONDITION(guid != nullptr);
-    } CONTRACTL_END;
-    SString value;
-    const SString& path = pFile->GetPath();
-    if (path.IsEmpty())
-    {
-        return;
-    }
-    SIZE_T baseAddr = 0;
-    if (pFile->IsILImageReadyToRun())
-    {
-        PEImageLayout *pLoadedLayout = pFile->GetLoaded();
-        if (pLoadedLayout)
-        {
-            baseAddr = (SIZE_T)pLoadedLayout->GetBase();
-        }
-    }
-    value.Printf("%S%c%S%c%p", path.GetUnicode(), sDelimiter, guid, sDelimiter, baseAddr);
-    SString command;
-    command.Printf("%s", "ImageLoad");
-    WriteLine(command, value);
-}
-void PerfInfo::WriteLine(SString& type, SString& value)
-{
-    CONTRACTL
-    {
-        THROWS;
-        GC_NOTRIGGER;
-        MODE_PREEMPTIVE;
-    } CONTRACTL_END;
-    if (m_Stream == nullptr)
-    {
-        return;
-    }
-    SString line;
-    line.Printf("%S%c%S%c\n",
-            type.GetUnicode(), sDelimiter, value.GetUnicode(), sDelimiter);
-    EX_TRY
-    {
-        StackScratchBuffer scratch;
-        const char* strLine = line.GetANSI(scratch);
-        ULONG inCount = line.GetCount();
-        ULONG outCount;
-        m_Stream->Write(strLine, inCount, &outCount);
-        if (inCount != outCount)
-        {
-        }
-    }
-    EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
-}
-void PerfInfo::OpenFile(SString& path)
-{
-    STANDARD_VM_CONTRACT;
-    m_Stream = new (nothrow) CFileStream();
-    if (m_Stream != nullptr)
-    {
-        HRESULT hr = m_Stream->OpenForWrite(path.GetUnicode());
-        if (FAILED(hr))
-        {
-            delete m_Stream;
-            m_Stream = nullptr;
-        }
-    }
-}
-PerfInfo::~PerfInfo()
-{
-    LIMITED_METHOD_CONTRACT;
-    delete m_Stream;
-    m_Stream = nullptr;
-}
-#endif

--- a/src/coreclr/vm/perfinfo.h
+++ b//dev/null
@@ -1,23 +0,0 @@
-#ifndef PERFINFO_H
-#define PERFINFO_H
-#include "sstring.h"
-#include "fstream.h"
-/*
-   A perfinfo-%d.map is created for every process that is created with manage code, the %d
-   being repaced with the process ID.
-   Every line in the perfinfo-%d.map is a type and value, separated by sDelimiter character: type;value
-   type represents what the user might want to do with its given value. value has a format chosen by
-   the user for parsing later on.
-*/
-class PerfInfo {
-public:
-    PerfInfo(int pid, const char* basePath);
-    ~PerfInfo();
-    void LogImage(PEFile* pFile, WCHAR* guid);
-private:
-    CFileStream* m_Stream;
-    const char sDelimiter = ';';
-    void OpenFile(SString& path);
-    void WriteLine(SString& type, SString& value);
-};
-#endif

--- a/src/coreclr/vm/perfmap.cpp
+++ b//dev/null
@@ -1,387 +0,0 @@
-#include "common.h"
-#if defined(FEATURE_PERFMAP) && !defined(DACCESS_COMPILE)
-#include "perfmap.h"
-#include "perfinfo.h"
-#include "pal.h"
-#ifdef CROSSGEN_COMPILE
-#define FMT_CODE_ADDR "%08x"
-#else
-#define FMT_CODE_ADDR "%p"
-#endif
-#ifndef __ANDROID__
-#define TEMP_DIRECTORY_PATH "/tmp"
-#else
-#define TEMP_DIRECTORY_PATH "/data/local/tmp"
-#endif
-Volatile<bool> PerfMap::s_enabled = false;
-PerfMap * PerfMap::s_Current = nullptr;
-bool PerfMap::s_ShowOptimizationTiers = false;
-unsigned PerfMap::s_StubsMapped = 0;
-enum 
-{
-    DISABLED,
-    ALL,
-    JITDUMP,
-    PERFMAP
-};
-void PerfMap::Initialize()
-{
-    LIMITED_METHOD_CONTRACT;
-    const DWORD perfMapEnabled = CLRConfig::GetConfigValue(CLRConfig::EXTERNAL_PerfMapEnabled);
-    if (perfMapEnabled == DISABLED)
-    {
-        return;
-    }
-    char tempPathBuffer[MAX_LONGPATH+1];
-    const char* tempPath = InternalConstructPath(tempPathBuffer, sizeof(tempPathBuffer));
-    if (perfMapEnabled == ALL || perfMapEnabled == PERFMAP)
-    {
-        int currentPid = GetCurrentProcessId();
-        s_Current = new PerfMap(currentPid, tempPath);
-        int signalNum = (int) CLRConfig::GetConfigValue(CLRConfig::EXTERNAL_PerfMapIgnoreSignal);
-        if (signalNum > 0)
-        {
-            PAL_IgnoreProfileSignal(signalNum);
-        }
-    }
-    if (perfMapEnabled == ALL || perfMapEnabled == JITDUMP)
-    {
-        PAL_PerfJitDump_Start(tempPath);
-    }
-    if (CLRConfig::GetConfigValue(CLRConfig::EXTERNAL_PerfMapShowOptimizationTiers) != 0)
-    {
-        s_ShowOptimizationTiers = true;
-    }
-    s_enabled = true;
-}
-const char * PerfMap::InternalConstructPath(char *tmpBuf, int lenBuf)
-{
-    DWORD len = GetEnvironmentVariableA("DOTNET_PerfMapJitDumpPath", tmpBuf, lenBuf);
-    if (len == 0)
-    {
-        len = GetEnvironmentVariableA("COMPlus_PerfMapJitDumpPath", tmpBuf, lenBuf);
-    }
-    if (len == 0 || // GetEnvironmentVariableA returns 0 if the variable is not found, 
-        len >= lenBuf) // or the length of the string not including the null terminator on success.
-    {
-        return TEMP_DIRECTORY_PATH;
-    }
-    return tmpBuf;
-}
-void PerfMap::Destroy()
-{
-    LIMITED_METHOD_CONTRACT;
-    if (s_enabled)
-    {
-        s_enabled = false;
-        PAL_PerfJitDump_Finish();
-    }
-}
-PerfMap::PerfMap(int pid, const char* path)
-{
-    LIMITED_METHOD_CONTRACT;
-    m_ErrorEncountered = false;
-    SString pathFile;
-    pathFile.Printf("%s/perf-%d.map", path, pid);
-    OpenFile(pathFile);
-    m_PerfInfo = new PerfInfo(pid, path);
-}
-PerfMap::PerfMap()
-  : m_FileStream(nullptr)
-  , m_PerfInfo(nullptr)
-{
-    LIMITED_METHOD_CONTRACT;
-    m_ErrorEncountered = false;
-}
-PerfMap::~PerfMap()
-{
-    LIMITED_METHOD_CONTRACT;
-    delete m_FileStream;
-    m_FileStream = nullptr;
-    delete m_PerfInfo;
-    m_PerfInfo = nullptr;
-}
-void PerfMap::OpenFile(SString& path)
-{
-    STANDARD_VM_CONTRACT;
-    m_FileStream = new (nothrow) CFileStream();
-    if(m_FileStream != nullptr)
-    {
-        HRESULT hr = m_FileStream->OpenForWrite(path.GetUnicode());
-        if(FAILED(hr))
-        {
-            delete m_FileStream;
-            m_FileStream = nullptr;
-        }
-    }
-}
-void PerfMap::WriteLine(SString& line)
-{
-    STANDARD_VM_CONTRACT;
-    if (m_FileStream == nullptr || m_ErrorEncountered)
-    {
-        return;
-    }
-    EX_TRY
-    {
-        StackScratchBuffer scratch;
-        const char * strLine = line.GetANSI(scratch);
-        ULONG inCount = line.GetCount();
-        ULONG outCount;
-        m_FileStream->Write(strLine, inCount, &outCount);
-        if (inCount != outCount)
-        {
-            m_ErrorEncountered = true;
-        }
-    }
-    EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
-}
-void PerfMap::LogImageLoad(PEFile *pFile)
-{
-    if (s_enabled && s_Current != nullptr)
-    {
-        s_Current->LogImage(pFile);
-    }
-}
-void PerfMap::LogImage(PEFile * pFile)
-{
-    CONTRACTL{
-        THROWS;
-        GC_NOTRIGGER;
-        MODE_PREEMPTIVE;
-        PRECONDITION(pFile != nullptr);
-    } CONTRACTL_END;
-    if (m_FileStream == nullptr || m_ErrorEncountered)
-    {
-        return;
-    }
-    EX_TRY
-    {
-        WCHAR wszSignature[39];
-        GetNativeImageSignature(pFile, wszSignature, lengthof(wszSignature));
-        m_PerfInfo->LogImage(pFile, wszSignature);
-    }
-    EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
-}
-void PerfMap::LogJITCompiledMethod(MethodDesc * pMethod, PCODE pCode, size_t codeSize, PrepareCodeConfig *pConfig)
-{
-    LIMITED_METHOD_CONTRACT;
-    CONTRACTL{
-        THROWS;
-        GC_NOTRIGGER;
-        MODE_PREEMPTIVE;
-        PRECONDITION(pMethod != nullptr);
-        PRECONDITION(pCode != nullptr);
-        PRECONDITION(codeSize > 0);
-    } CONTRACTL_END;
-    if (!s_enabled)
-    {
-        return;
-    }
-    const char *optimizationTier = nullptr;
-#ifndef CROSSGEN_COMPILE
-    if (s_ShowOptimizationTiers)
-    {
-        optimizationTier = PrepareCodeConfig::GetJitOptimizationTierStr(pConfig, pMethod);
-    }
-#endif // CROSSGEN_COMPILE
-    EX_TRY
-    {
-        SString name;
-        pMethod->GetFullMethodInfo(name);
-        if (optimizationTier != nullptr && s_ShowOptimizationTiers)
-        {
-            name.AppendPrintf("[%s]", optimizationTier);
-        }
-        StackScratchBuffer scratch;
-        SString line;
-        line.Printf(FMT_CODE_ADDR " %x %s\n", pCode, codeSize, name.GetANSI(scratch));
-        if(s_Current != nullptr)
-        {
-            s_Current->WriteLine(line);
-        }
-        PAL_PerfJitDump_LogMethod((void*)pCode, codeSize, name.GetANSI(scratch), nullptr, nullptr);
-    }
-    EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
-}
-void PerfMap::LogPreCompiledMethod(MethodDesc * pMethod, PCODE pCode)
-{
-    LIMITED_METHOD_CONTRACT;
-    if (!s_enabled)
-    {
-        return;
-    }
-    EECodeInfo codeInfo(pCode);
-    _ASSERTE(codeInfo.IsValid());
-    IJitManager::MethodRegionInfo methodRegionInfo;
-    codeInfo.GetMethodRegionInfo(&methodRegionInfo);
-    EX_TRY
-    {
-        SString name;
-        pMethod->GetFullMethodInfo(name);
-        StackScratchBuffer scratch;
-        if (s_ShowOptimizationTiers)
-        {
-            name.AppendPrintf(W("[PreJIT]"));
-        }
-        if (methodRegionInfo.hotSize > 0)
-        {
-            PAL_PerfJitDump_LogMethod((void*)methodRegionInfo.hotStartAddress, methodRegionInfo.hotSize, name.GetANSI(scratch), nullptr, nullptr);
-        }
-        if (methodRegionInfo.coldSize > 0)
-        {
-            if (s_ShowOptimizationTiers)
-            {
-                pMethod->GetFullMethodInfo(name);
-                name.AppendPrintf(W("[PreJit-cold]"));
-            }
-            PAL_PerfJitDump_LogMethod((void*)methodRegionInfo.coldStartAddress, methodRegionInfo.coldSize, name.GetANSI(scratch), nullptr, nullptr);
-        }
-    }
-    EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
-}
-void PerfMap::LogStubs(const char* stubType, const char* stubOwner, PCODE pCode, size_t codeSize)
-{
-    LIMITED_METHOD_CONTRACT;
-    if (!s_enabled)
-    {
-        return;
-    }
-    EX_TRY
-    {
-        if(!stubOwner)
-        {
-            stubOwner = "?";
-        }
-        if(!stubType)
-        {
-            stubType = "?";
-        }
-        StackScratchBuffer scratch;
-        SString name;
-        name.Printf("stub<%d> %s<%s>", ++(s_StubsMapped), stubType, stubOwner);
-        SString line;
-        line.Printf(FMT_CODE_ADDR " %x %s\n", pCode, codeSize, name.GetANSI(scratch));
-        if(s_Current != nullptr)
-        {
-            s_Current->WriteLine(line);
-        }
-        PAL_PerfJitDump_LogMethod((void*)pCode, codeSize, name.GetANSI(scratch), nullptr, nullptr);
-    }
-    EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
-}
-void PerfMap::GetNativeImageSignature(PEFile * pFile, WCHAR * pwszSig, unsigned int nSigSize)
-{
-    CONTRACTL{
-        PRECONDITION(pFile != nullptr);
-        PRECONDITION(pwszSig != nullptr);
-        PRECONDITION(nSigSize >= 39);
-    } CONTRACTL_END;
-    GUID mvid;
-    pFile->GetMVID(&mvid);
-    if(!StringFromGUID2(mvid, pwszSig, nSigSize))
-    {
-        pwszSig[0] = '\0';
-    }
-}
-NativeImagePerfMap::NativeImagePerfMap(Assembly * pAssembly, BSTR pDestPath)
-  : PerfMap()
-{
-    STANDARD_VM_CONTRACT;
-    LPCUTF8 lpcSimpleName = pAssembly->GetSimpleName();
-    WCHAR wszSignature[39];
-    GetNativeImageSignature(pAssembly->GetManifestFile(), wszSignature, lengthof(wszSignature));
-    SString sDestPerfMapPath;
-    sDestPerfMapPath.Printf("%S%s.ni.%S.map", pDestPath, lpcSimpleName, wszSignature);
-    OpenFile(sDestPerfMapPath);
-    m_EmitRVAs = true;
-    CLRConfigStringHolder wszFormat(CLRConfig::GetConfigValue(CLRConfig::EXTERNAL_NativeImagePerfMapFormat));
-    if(wszFormat != NULL && (wcsncmp(wszFormat, strOFFSET, wcslen(strOFFSET)) == 0))
-    {
-        m_EmitRVAs = false;
-    }
-}
-void NativeImagePerfMap::LogMethod(MethodDesc * pMethod, PCODE pCode, size_t codeSize, const char *optimizationTier)
-{
-    CONTRACTL{
-        THROWS;
-        GC_NOTRIGGER;
-        MODE_PREEMPTIVE;
-        PRECONDITION(pMethod != nullptr);
-        PRECONDITION(pCode != nullptr);
-        PRECONDITION(codeSize > 0);
-    } CONTRACTL_END;
-    EX_TRY
-    {
-        SString name;
-        pMethod->GetFullMethodInfo(name);
-        StackScratchBuffer scratch;
-        if (optimizationTier != nullptr && s_ShowOptimizationTiers)
-        {
-            name.AppendPrintf("[%s]", optimizationTier);
-        }
-        SString line;
-        line.Printf(FMT_CODE_ADDR " %x %s\n", pCode, codeSize, name.GetANSI(scratch));
-        if (s_Current != nullptr)
-        {
-            s_Current->WriteLine(line);
-        }
-        PAL_PerfJitDump_LogMethod((void*)pCode, codeSize, name.GetANSI(scratch), nullptr, nullptr);
-    }
-    EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
-}
-void NativeImagePerfMap::LogDataForModule(Module * pModule)
-{
-    STANDARD_VM_CONTRACT;
-    PEImageLayout * pLoadedLayout = pModule->GetFile()->GetLoaded();
-    _ASSERTE(pLoadedLayout != nullptr);
-#ifdef FEATURE_PREJIT
-    if (!pLoadedLayout->HasReadyToRunHeader())
-    {
-        MethodIterator mi((PTR_Module)pModule);
-        while (mi.Next())
-        {
-            MethodDesc *hotDesc = mi.GetMethodDesc();
-            hotDesc->CheckRestore();
-            LogPreCompiledMethod(hotDesc, mi.GetMethodStartAddress(), pLoadedLayout, nullptr);
-        }
-        return;
-    }
-#endif
-    ReadyToRunInfo::MethodIterator mi(pModule->GetReadyToRunInfo());
-    while (mi.Next())
-    {
-        MethodDesc* hotDesc = mi.GetMethodDesc();
-        LogPreCompiledMethod(hotDesc, mi.GetMethodStartAddress(), pLoadedLayout, "ReadyToRun");
-    }
-}
-void NativeImagePerfMap::LogPreCompiledMethod(MethodDesc * pMethod, PCODE pCode, PEImageLayout *pLoadedLayout, const char *optimizationTier)
-{
-    STANDARD_VM_CONTRACT;
-    _ASSERTE(pLoadedLayout != nullptr);
-    SIZE_T baseAddr = (SIZE_T)pLoadedLayout->GetBase();
-    EECodeInfo codeInfo(pCode);
-    _ASSERTE(codeInfo.IsValid());
-    IJitManager::MethodRegionInfo methodRegionInfo;
-    codeInfo.GetMethodRegionInfo(&methodRegionInfo);
-    PCODE addr;
-    if (methodRegionInfo.hotSize > 0)
-    {
-        addr = (PCODE)methodRegionInfo.hotStartAddress - baseAddr;
-        if (!m_EmitRVAs)
-        {
-            addr = pLoadedLayout->RvaToOffset(addr);
-        }
-        LogMethod(pMethod, addr, methodRegionInfo.hotSize, optimizationTier);
-    }
-    if (methodRegionInfo.coldSize > 0)
-    {
-        addr = (PCODE)methodRegionInfo.coldStartAddress - baseAddr;
-        if (!m_EmitRVAs)
-        {
-            addr = pLoadedLayout->RvaToOffset(addr);
-        }
-        LogMethod(pMethod, addr, methodRegionInfo.coldSize, optimizationTier);
-    }
-}
-#endif // FEATURE_PERFMAP && !DACCESS_COMPILE

--- a/src/coreclr/vm/perfmap.h
+++ b//dev/null
@@ -1,45 +0,0 @@
-#ifndef PERFPID_H
-#define PERFPID_H
-#include "sstring.h"
-#include "fstream.h"
-#include "volatile.h"
-class PerfInfo;
-class PerfMap
-{
-private:
-    static Volatile<bool> s_enabled;
-    static unsigned s_StubsMapped;
-    CFileStream * m_FileStream;
-    PerfInfo* m_PerfInfo;
-    bool m_ErrorEncountered;
-    PerfMap(int pid, const char* path);
-    static const char* InternalConstructPath(char *tmpBuf, int lenBuf);
-protected:
-    static bool s_ShowOptimizationTiers;
-    static PerfMap * s_Current;
-    PerfMap();
-    ~PerfMap();
-    void OpenFile(SString& path);
-    void LogImage(PEFile * pFile);
-    static void GetNativeImageSignature(PEFile * pFile, WCHAR * pwszSig, unsigned int nSigSize);
-public:
-    void WriteLine(SString & line);
-    static void Initialize();
-    static void LogImageLoad(PEFile * pFile);
-    static void LogJITCompiledMethod(MethodDesc * pMethod, PCODE pCode, size_t codeSize, PrepareCodeConfig *pConfig);
-    static void LogPreCompiledMethod(MethodDesc * pMethod, PCODE pCode);
-    static void LogStubs(const char* stubType, const char* stubOwner, PCODE pCode, size_t codeSize);
-    static void Destroy();
-};
-class NativeImagePerfMap : PerfMap
-{
-private:
-    const WCHAR *strOFFSET = W("OFFSET");
-    bool m_EmitRVAs;
-    void LogMethod(MethodDesc * pMethod, PCODE pCode, size_t codeSize, const char *optimizationTier);
-    void LogPreCompiledMethod(MethodDesc * pMethod, PCODE pCode, PEImageLayout *pLoadedLayout, const char *optimizationTier);
-public:
-    NativeImagePerfMap(Assembly * pAssembly, BSTR pDestPath);
-    void LogDataForModule(Module * pModule);
-};
-#endif // PERFPID_H

--- a/src/libraries/System.Net.Quic/src/System/Net/Quic/Implementations/MsQuic/Internal/MsQuicApi.cs
+++ b//dev/null
@@ -1,192 +0,0 @@
-using System.Diagnostics;
-using System.Diagnostics.CodeAnalysis;
-using System.Runtime.InteropServices;
-using static System.Net.Quic.Implementations.MsQuic.Internal.MsQuicNativeMethods;
-namespace System.Net.Quic.Implementations.MsQuic.Internal
-{
-    internal unsafe sealed class MsQuicApi
-    {
-        private static readonly Version MinWindowsVersion = new Version(10, 0, 20145, 1000);
-        public SafeMsQuicRegistrationHandle Registration { get; }
-        [DynamicDependency(DynamicallyAccessedMemberTypes.PublicConstructors, typeof(SafeMsQuicRegistrationHandle))]
-        [DynamicDependency(DynamicallyAccessedMemberTypes.PublicConstructors, typeof(SafeMsQuicConfigurationHandle))]
-        [DynamicDependency(DynamicallyAccessedMemberTypes.PublicConstructors, typeof(SafeMsQuicListenerHandle))]
-        [DynamicDependency(DynamicallyAccessedMemberTypes.PublicConstructors, typeof(SafeMsQuicConnectionHandle))]
-        [DynamicDependency(DynamicallyAccessedMemberTypes.PublicConstructors, typeof(SafeMsQuicStreamHandle))]
-        private MsQuicApi(NativeApi* vtable)
-        {
-            uint status;
-            SetParamDelegate =
-                Marshal.GetDelegateForFunctionPointer<SetParamDelegate>(
-                    vtable->SetParam);
-            GetParamDelegate =
-                Marshal.GetDelegateForFunctionPointer<GetParamDelegate>(
-                    vtable->GetParam);
-            SetCallbackHandlerDelegate =
-                Marshal.GetDelegateForFunctionPointer<SetCallbackHandlerDelegate>(
-                    vtable->SetCallbackHandler);
-            RegistrationOpenDelegate =
-                Marshal.GetDelegateForFunctionPointer<RegistrationOpenDelegate>(
-                    vtable->RegistrationOpen);
-            RegistrationCloseDelegate =
-                Marshal.GetDelegateForFunctionPointer<RegistrationCloseDelegate>(
-                    vtable->RegistrationClose);
-            ConfigurationOpenDelegate =
-                Marshal.GetDelegateForFunctionPointer<ConfigurationOpenDelegate>(
-                    vtable->ConfigurationOpen);
-            ConfigurationCloseDelegate =
-                Marshal.GetDelegateForFunctionPointer<ConfigurationCloseDelegate>(
-                    vtable->ConfigurationClose);
-            ConfigurationLoadCredentialDelegate =
-                Marshal.GetDelegateForFunctionPointer<ConfigurationLoadCredentialDelegate>(
-                    vtable->ConfigurationLoadCredential);
-            ListenerOpenDelegate =
-                Marshal.GetDelegateForFunctionPointer<ListenerOpenDelegate>(
-                    vtable->ListenerOpen);
-            ListenerCloseDelegate =
-                Marshal.GetDelegateForFunctionPointer<ListenerCloseDelegate>(
-                    vtable->ListenerClose);
-            ListenerStartDelegate =
-                Marshal.GetDelegateForFunctionPointer<ListenerStartDelegate>(
-                    vtable->ListenerStart);
-            ListenerStopDelegate =
-                Marshal.GetDelegateForFunctionPointer<ListenerStopDelegate>(
-                    vtable->ListenerStop);
-            ConnectionOpenDelegate =
-                Marshal.GetDelegateForFunctionPointer<ConnectionOpenDelegate>(
-                    vtable->ConnectionOpen);
-            ConnectionCloseDelegate =
-                Marshal.GetDelegateForFunctionPointer<ConnectionCloseDelegate>(
-                    vtable->ConnectionClose);
-            ConnectionSetConfigurationDelegate =
-                Marshal.GetDelegateForFunctionPointer<ConnectionSetConfigurationDelegate>(
-                    vtable->ConnectionSetConfiguration);
-            ConnectionShutdownDelegate =
-                Marshal.GetDelegateForFunctionPointer<ConnectionShutdownDelegate>(
-                    vtable->ConnectionShutdown);
-            ConnectionStartDelegate =
-                Marshal.GetDelegateForFunctionPointer<ConnectionStartDelegate>(
-                    vtable->ConnectionStart);
-            StreamOpenDelegate =
-                Marshal.GetDelegateForFunctionPointer<StreamOpenDelegate>(
-                    vtable->StreamOpen);
-            StreamCloseDelegate =
-                Marshal.GetDelegateForFunctionPointer<StreamCloseDelegate>(
-                    vtable->StreamClose);
-            StreamStartDelegate =
-                Marshal.GetDelegateForFunctionPointer<StreamStartDelegate>(
-                    vtable->StreamStart);
-            StreamShutdownDelegate =
-                Marshal.GetDelegateForFunctionPointer<StreamShutdownDelegate>(
-                    vtable->StreamShutdown);
-            StreamSendDelegate =
-                Marshal.GetDelegateForFunctionPointer<StreamSendDelegate>(
-                    vtable->StreamSend);
-            StreamReceiveCompleteDelegate =
-                Marshal.GetDelegateForFunctionPointer<StreamReceiveCompleteDelegate>(
-                    vtable->StreamReceiveComplete);
-            StreamReceiveSetEnabledDelegate =
-                Marshal.GetDelegateForFunctionPointer<StreamReceiveSetEnabledDelegate>(
-                    vtable->StreamReceiveSetEnabled);
-            var cfg = new RegistrationConfig
-            {
-                AppName = ".NET",
-                ExecutionProfile = QUIC_EXECUTION_PROFILE.QUIC_EXECUTION_PROFILE_LOW_LATENCY
-            };
-            status = RegistrationOpenDelegate(ref cfg, out SafeMsQuicRegistrationHandle handle);
-            QuicExceptionHelpers.ThrowIfFailed(status, "RegistrationOpen failed.");
-            Registration = handle;
-        }
-        private static readonly delegate* unmanaged[Cdecl]<uint, NativeApi**, uint> MsQuicOpenVersion;
-        private static readonly delegate* unmanaged[Cdecl]<NativeApi*, void> MsQuicClose;
-        private static readonly Lazy<MsQuicApi> s_api = new Lazy<MsQuicApi>(AllocateMsQuicApi);
-        internal static MsQuicApi Api => s_api.Value;
-        internal static bool IsQuicSupported { get; }
-        private const int MsQuicVersion = 1;
-#pragma warning disable CA1810 // Initialize all static fields in 'MsQuicApi' when those fields are declared and remove the explicit static constructor
-        static MsQuicApi()
-        {
-            IsQuicSupported = false;
-            if (NetEventSource.Log.IsEnabled())
-            {
-                NetEventSource.Info(null, $"QUIC is completely disabled in .NET 6 due to critical defects fixed in later versions.");
-            }
-            return;
-#pragma warning disable CS0162 // Unreachable code detected -- leaving the original code intact, instead of removing big chunks of code transitively
-            if (OperatingSystem.IsWindows() && !IsWindowsVersionSupported())
-            {
-                if (NetEventSource.Log.IsEnabled())
-                {
-                    NetEventSource.Info(null, $"Current Windows version ({Environment.OSVersion}) is not supported by QUIC. Minimal supported version is {MinWindowsVersion}");
-                }
-                return;
-            }
-            DllImportSearchPath? searchPath = OperatingSystem.IsWindows() ? DllImportSearchPath.AssemblyDirectory : null;
-            if (!NativeLibrary.TryLoad(Interop.Libraries.MsQuic, typeof(MsQuicApi).Assembly, searchPath, out IntPtr msQuicHandle))
-            {
-                return;
-            }
-            MsQuicOpenVersion = (delegate* unmanaged[Cdecl]<uint, NativeApi**, uint>)NativeLibrary.GetExport(msQuicHandle, nameof(MsQuicOpenVersion));
-            MsQuicClose = (delegate* unmanaged[Cdecl]<NativeApi*, void>)NativeLibrary.GetExport(msQuicHandle, nameof(MsQuicClose));
-            if (!TryOpenMsQuic(out NativeApi* apiTable, out _))
-            {
-                return;
-            }
-            IsQuicSupported = true;
-            MsQuicClose(apiTable);
-        }
-#pragma warning restore CA1810, CS0162
-        private static MsQuicApi AllocateMsQuicApi()
-        {
-            Debug.Assert(IsQuicSupported);
-            if (!TryOpenMsQuic(out NativeApi* apiTable, out uint openStatus))
-            {
-                QuicExceptionHelpers.ThrowIfFailed(openStatus);
-            }
-            return new MsQuicApi(apiTable);
-        }
-        private static bool TryOpenMsQuic(out NativeApi* apiTable, out uint openStatus)
-        {
-            Debug.Assert(MsQuicOpenVersion != null);
-            NativeApi* table = null;
-            openStatus = MsQuicOpenVersion((uint)MsQuicVersion, &table);
-            if (!MsQuicStatusHelper.SuccessfulStatusCode(openStatus))
-            {
-                if (NetEventSource.Log.IsEnabled())
-                {
-                    NetEventSource.Info(null, $"MsQuicOpenVersion(version: {MsQuicVersion}) returned {MsQuicStatusCodes.GetError(openStatus)} status code.");
-                }
-                apiTable = null;
-                return false;
-            }
-            apiTable = table;
-            return true;
-        }
-        private static bool IsWindowsVersionSupported() => OperatingSystem.IsWindowsVersionAtLeast(MinWindowsVersion.Major,
-            MinWindowsVersion.Minor, MinWindowsVersion.Build, MinWindowsVersion.Revision);
-        internal RegistrationOpenDelegate RegistrationOpenDelegate { get; }
-        internal RegistrationCloseDelegate RegistrationCloseDelegate { get; }
-        internal ConfigurationOpenDelegate ConfigurationOpenDelegate { get; }
-        internal ConfigurationCloseDelegate ConfigurationCloseDelegate { get; }
-        internal ConfigurationLoadCredentialDelegate ConfigurationLoadCredentialDelegate { get; }
-        internal ListenerOpenDelegate ListenerOpenDelegate { get; }
-        internal ListenerCloseDelegate ListenerCloseDelegate { get; }
-        internal ListenerStartDelegate ListenerStartDelegate { get; }
-        internal ListenerStopDelegate ListenerStopDelegate { get; }
-        internal ConnectionOpenDelegate ConnectionOpenDelegate { get; }
-        internal ConnectionCloseDelegate ConnectionCloseDelegate { get; }
-        internal ConnectionShutdownDelegate ConnectionShutdownDelegate { get; }
-        internal ConnectionStartDelegate ConnectionStartDelegate { get; }
-        internal ConnectionSetConfigurationDelegate ConnectionSetConfigurationDelegate { get; }
-        internal StreamOpenDelegate StreamOpenDelegate { get; }
-        internal StreamCloseDelegate StreamCloseDelegate { get; }
-        internal StreamStartDelegate StreamStartDelegate { get; }
-        internal StreamShutdownDelegate StreamShutdownDelegate { get; }
-        internal StreamSendDelegate StreamSendDelegate { get; }
-        internal StreamReceiveCompleteDelegate StreamReceiveCompleteDelegate { get; }
-        internal StreamReceiveSetEnabledDelegate StreamReceiveSetEnabledDelegate { get; }
-        internal SetCallbackHandlerDelegate SetCallbackHandlerDelegate { get; }
-        internal SetParamDelegate SetParamDelegate { get; }
-        internal GetParamDelegate GetParamDelegate { get; }
-    }
-}

--- a/src/libraries/System.Security.Cryptography.X509Certificates/src/Internal/Cryptography/Pal.Unix/CertificateAssetDownloader.cs
+++ b//dev/null
@@ -1,251 +0,0 @@
-using System;
-using System.Diagnostics;
-using System.Diagnostics.CodeAnalysis;
-using System.IO;
-using System.Reflection;
-using System.Security.Cryptography;
-using System.Security.Cryptography.X509Certificates;
-using System.Threading;
-using Microsoft.Win32.SafeHandles;
-namespace Internal.Cryptography.Pal
-{
-    internal static class CertificateAssetDownloader
-    {
-        private const long DefaultAiaDownloadLimit = 100 * 1024 * 1024;
-        private static long AiaDownloadLimit { get; } = GetValue("System.Security.Cryptography.AiaDownloadLimit", DefaultAiaDownloadLimit);
-        private static readonly Func<string, CancellationToken, byte[]?>? s_downloadBytes = CreateDownloadBytesFunc();
-        internal static X509Certificate2? DownloadCertificate(string uri, TimeSpan downloadTimeout)
-        {
-            byte[]? data = DownloadAsset(uri, downloadTimeout);
-            if (data == null || data.Length == 0)
-            {
-                return null;
-            }
-            try
-            {
-                X509ContentType contentType = X509Certificate2.GetCertContentType(data);
-                switch (contentType)
-                {
-                    case X509ContentType.Cert:
-                    case X509ContentType.Pkcs7:
-                        break;
-                    default:
-                        return null;
-                }
-                X509Certificate2 certificate = new X509Certificate2(data);
-                certificate.ThrowIfInvalid();
-                return certificate;
-            }
-            catch (CryptographicException)
-            {
-                return null;
-            }
-        }
-        internal static SafeX509CrlHandle? DownloadCrl(string uri, TimeSpan downloadTimeout)
-        {
-            byte[]? data = DownloadAsset(uri, downloadTimeout);
-            if (data == null)
-            {
-                return null;
-            }
-            SafeX509CrlHandle handle = Interop.Crypto.DecodeX509Crl(data, data.Length);
-            if (!handle.IsInvalid)
-            {
-                return handle;
-            }
-            using (SafeBioHandle bio = Interop.Crypto.CreateMemoryBio())
-            {
-                Interop.Crypto.CheckValidOpenSslHandle(bio);
-                Interop.Crypto.BioWrite(bio, data, data.Length);
-                handle = Interop.Crypto.PemReadBioX509Crl(bio);
-                Interop.Crypto.ErrClearError();
-                if (!handle.IsInvalid)
-                {
-                    return handle;
-                }
-            }
-            return null;
-        }
-        internal static SafeOcspResponseHandle? DownloadOcspGet(string uri, TimeSpan downloadTimeout)
-        {
-            byte[]? data = DownloadAsset(uri, downloadTimeout);
-            if (data == null)
-            {
-                return null;
-            }
-            SafeOcspResponseHandle resp = Interop.Crypto.DecodeOcspResponse(data);
-            if (resp.IsInvalid)
-            {
-                Interop.Crypto.ErrClearError();
-            }
-            return resp;
-        }
-        private static byte[]? DownloadAsset(string uri, TimeSpan downloadTimeout)
-        {
-            if (s_downloadBytes != null && downloadTimeout > TimeSpan.Zero)
-            {
-                long totalMillis = (long)downloadTimeout.TotalMilliseconds;
-                CancellationTokenSource? cts = totalMillis > int.MaxValue ? null : new CancellationTokenSource((int)totalMillis);
-                try
-                {
-                    return s_downloadBytes(uri, cts?.Token ?? default);
-                }
-                catch { }
-                finally
-                {
-                    cts?.Dispose();
-                }
-            }
-            return null;
-        }
-        private static Func<string, CancellationToken, byte[]?>? CreateDownloadBytesFunc()
-        {
-            try
-            {
-                Type? socketsHttpHandlerType = Type.GetType("System.Net.Http.SocketsHttpHandler, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
-                Type? httpMessageHandlerType = Type.GetType("System.Net.Http.HttpMessageHandler, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
-                Type? httpClientType = Type.GetType("System.Net.Http.HttpClient, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
-                Type? httpRequestMessageType = Type.GetType("System.Net.Http.HttpRequestMessage, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
-                Type? httpResponseMessageType = Type.GetType("System.Net.Http.HttpResponseMessage, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
-                Type? httpResponseHeadersType = Type.GetType("System.Net.Http.Headers.HttpResponseHeaders, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
-                Type? httpContentType = Type.GetType("System.Net.Http.HttpContent, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
-                if (socketsHttpHandlerType == null || httpMessageHandlerType == null || httpClientType == null || httpRequestMessageType == null ||
-                    httpResponseMessageType == null || httpResponseHeadersType == null || httpContentType == null)
-                {
-                    Debug.Fail("Unable to load required type.");
-                    return null;
-                }
-                ConstructorInfo? socketsHttpHandlerCtor = socketsHttpHandlerType.GetConstructor(Type.EmptyTypes);
-                PropertyInfo? pooledConnectionIdleTimeoutProp = socketsHttpHandlerType.GetProperty("PooledConnectionIdleTimeout");
-                PropertyInfo? allowAutoRedirectProp = socketsHttpHandlerType.GetProperty("AllowAutoRedirect");
-                ConstructorInfo? httpClientCtor = httpClientType.GetConstructor(new Type[] { httpMessageHandlerType });
-                PropertyInfo? requestUriProp = httpRequestMessageType.GetProperty("RequestUri");
-                ConstructorInfo? httpRequestMessageCtor = httpRequestMessageType.GetConstructor(Type.EmptyTypes);
-                MethodInfo? sendMethod = httpClientType.GetMethod("Send", new Type[] { httpRequestMessageType, typeof(CancellationToken) });
-                PropertyInfo? maxResponseContentBufferSizeProp = httpClientType.GetProperty("MaxResponseContentBufferSize");
-                PropertyInfo? responseContentProp = httpResponseMessageType.GetProperty("Content");
-                PropertyInfo? responseStatusCodeProp = httpResponseMessageType.GetProperty("StatusCode");
-                PropertyInfo? responseHeadersProp = httpResponseMessageType.GetProperty("Headers");
-                PropertyInfo? responseHeadersLocationProp = httpResponseHeadersType.GetProperty("Location");
-                MethodInfo? readAsStreamMethod = httpContentType.GetMethod("ReadAsStream", Type.EmptyTypes);
-                if (socketsHttpHandlerCtor == null || pooledConnectionIdleTimeoutProp == null || allowAutoRedirectProp == null || httpClientCtor == null ||
-                    requestUriProp == null || httpRequestMessageCtor == null || sendMethod == null || responseContentProp == null || responseStatusCodeProp == null ||
-                    responseHeadersProp == null || responseHeadersLocationProp == null || readAsStreamMethod == null || maxResponseContentBufferSizeProp == null)
-                {
-                    Debug.Fail("Unable to load required member.");
-                    return null;
-                }
-                const int PooledConnectionIdleTimeoutSeconds = 15;
-                const int MaxRedirections = 10;
-                object? socketsHttpHandler = socketsHttpHandlerCtor.Invoke(null);
-                pooledConnectionIdleTimeoutProp.SetValue(socketsHttpHandler, TimeSpan.FromSeconds(PooledConnectionIdleTimeoutSeconds));
-                allowAutoRedirectProp.SetValue(socketsHttpHandler, false);
-                object? httpClient = httpClientCtor.Invoke(new object?[] { socketsHttpHandler });
-                maxResponseContentBufferSizeProp.SetValue(httpClient, AiaDownloadLimit);
-                return (string uriString, CancellationToken cancellationToken) =>
-                {
-                    Uri uri = new Uri(uriString);
-                    if (!IsAllowedScheme(uri.Scheme))
-                    {
-                        return null;
-                    }
-                    object requestMessage = httpRequestMessageCtor.Invoke(null);
-                    requestUriProp.SetValue(requestMessage, uri);
-                    object responseMessage = sendMethod.Invoke(httpClient, new object[] { requestMessage, cancellationToken })!;
-                    int redirections = 0;
-                    Uri? redirectUri;
-                    bool hasRedirect;
-                    while (true)
-                    {
-                        int statusCode = (int)responseStatusCodeProp.GetValue(responseMessage)!;
-                        object responseHeaders = responseHeadersProp.GetValue(responseMessage)!;
-                        Uri? location = (Uri?)responseHeadersLocationProp.GetValue(responseHeaders);
-                        redirectUri = GetUriForRedirect((Uri)requestUriProp.GetValue(requestMessage)!, statusCode, location, out hasRedirect);
-                        if (redirectUri == null)
-                        {
-                            break;
-                        }
-                        ((IDisposable)responseMessage).Dispose();
-                        redirections++;
-                        if (redirections > MaxRedirections)
-                        {
-                            return null;
-                        }
-                        requestMessage = httpRequestMessageCtor.Invoke(null);
-                        requestUriProp.SetValue(requestMessage, redirectUri);
-                        responseMessage = sendMethod.Invoke(httpClient, new object[] { requestMessage, cancellationToken })!;
-                    }
-                    if (hasRedirect && redirectUri == null)
-                    {
-                        return null;
-                    }
-                    object content = responseContentProp.GetValue(responseMessage)!;
-                    using Stream responseStream = (Stream)readAsStreamMethod.Invoke(content, null)!;
-                    var result = new MemoryStream();
-                    responseStream.CopyTo(result);
-                    ((IDisposable)responseMessage).Dispose();
-                    return result.ToArray();
-                };
-            }
-            catch
-            {
-                return null;
-            }
-        }
-        private static Uri? GetUriForRedirect(Uri requestUri, int statusCode, Uri? location, out bool hasRedirect)
-        {
-            if (!IsRedirectStatusCode(statusCode))
-            {
-                hasRedirect = false;
-                return null;
-            }
-            hasRedirect = true;
-            if (location == null)
-            {
-                return null;
-            }
-            if (!location.IsAbsoluteUri)
-            {
-                location = new Uri(requestUri, location);
-            }
-            string requestFragment = requestUri.Fragment;
-            if (!string.IsNullOrEmpty(requestFragment))
-            {
-                string redirectFragment = location.Fragment;
-                if (string.IsNullOrEmpty(redirectFragment))
-                {
-                    location = new UriBuilder(location) { Fragment = requestFragment }.Uri;
-                }
-            }
-            if (!IsAllowedScheme(location.Scheme))
-            {
-                return null;
-            }
-            return location;
-        }
-        private static bool IsRedirectStatusCode(int statusCode)
-        {
-            return (statusCode >= 300 && statusCode <= 303) || statusCode == 307 || statusCode == 308;
-        }
-        private static bool IsAllowedScheme(string scheme)
-        {
-            return string.Equals(scheme, "http", StringComparison.OrdinalIgnoreCase);
-        }
-        private static long GetValue(string name, long defaultValue)
-        {
-            object? data = AppContext.GetData(name);
-            if (data is null)
-            {
-                return defaultValue;
-            }
-            try
-            {
-                return Convert.ToInt64(data);
-            }
-            catch
-            {
-                return defaultValue;
-            }
-        }
-    }
-}

--- a/src/native/corehost/hostmisc/pal.windows.cpp
+++ b//dev/null
@@ -1,684 +0,0 @@
-#include "pal.h"
-#include "trace.h"
-#include "utils.h"
-#include "longfile.h"
-#include <cassert>
-#include <locale>
-#include <ShlObj.h>
-#include <ctime>
-bool GetModuleFileNameWrapper(HMODULE hModule, pal::string_t* recv)
-{
-    pal::string_t path;
-    size_t dwModuleFileName = MAX_PATH / 2;
-    do
-    {
-        path.resize(dwModuleFileName * 2);
-        dwModuleFileName = GetModuleFileNameW(hModule, (LPWSTR)path.data(), static_cast<DWORD>(path.size()));
-    } while (dwModuleFileName == path.size());
-    if (dwModuleFileName == 0)
-        return false;
-    path.resize(dwModuleFileName);
-    recv->assign(path);
-    return true;
-}
-bool GetModuleHandleFromAddress(void *addr, HMODULE *hModule)
-{
-    BOOL res = ::GetModuleHandleExW(
-        GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
-        reinterpret_cast<LPCWSTR>(addr),
-        hModule);
-    return (res != FALSE);
-}
-pal::string_t pal::get_timestamp()
-{
-    std::time_t t = std::time(nullptr);
-    const std::size_t elems = 100;
-    char_t buf[elems];
-    tm tm_l{};
-    ::gmtime_s(&tm_l, &t);
-    std::wcsftime(buf, elems, _X("%c GMT"), &tm_l);
-    return pal::string_t(buf);
-}
-bool pal::touch_file(const pal::string_t& path)
-{
-    HANDLE hnd = ::CreateFileW(path.c_str(), 0, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
-    if (hnd == INVALID_HANDLE_VALUE)
-    {
-        trace::verbose(_X("Failed to leave breadcrumb, HRESULT: 0x%X"), HRESULT_FROM_WIN32(GetLastError()));
-        return false;
-    }
-    ::CloseHandle(hnd);
-    return true;
-}
-static void* map_file(const pal::string_t& path, size_t *length, DWORD mapping_protect, DWORD view_desired_access)
-{
-    HANDLE file = CreateFileW(path.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
-    if (file == INVALID_HANDLE_VALUE)
-    {
-        trace::error(_X("Failed to map file. CreateFileW(%s) failed with error %d"), path.c_str(), GetLastError());
-        return nullptr;
-    }
-    if (length != nullptr)
-    {
-        LARGE_INTEGER fileSize;
-        if (GetFileSizeEx(file, &fileSize) == 0)
-        {
-            trace::error(_X("Failed to map file. GetFileSizeEx(%s) failed with error %d"), path.c_str(), GetLastError());
-            CloseHandle(file);
-            return nullptr;
-        }
-        *length = (size_t)fileSize.QuadPart;
-    }
-    HANDLE map = CreateFileMappingW(file, NULL, mapping_protect, 0, 0, NULL);
-    if (map == NULL)
-    {
-        trace::error(_X("Failed to map file. CreateFileMappingW(%s) failed with error %d"), path.c_str(), GetLastError());
-        CloseHandle(file);
-        return nullptr;
-    }
-    void *address = MapViewOfFile(map, view_desired_access, 0, 0, 0);
-    if (address == NULL)
-    {
-        trace::error(_X("Failed to map file. MapViewOfFile(%s) failed with error %d"), path.c_str(), GetLastError());
-    }
-    CloseHandle(map);
-    CloseHandle(file);
-    return address;
-}
-const void* pal::mmap_read(const string_t& path, size_t* length)
-{
-    return map_file(path, length, PAGE_READONLY, FILE_MAP_READ);
-}
-void* pal::mmap_copy_on_write(const string_t& path, size_t* length)
-{
-    return map_file(path, length, PAGE_WRITECOPY, FILE_MAP_READ | FILE_MAP_COPY);
-}
-bool pal::getcwd(pal::string_t* recv)
-{
-    recv->clear();
-    pal::char_t buf[MAX_PATH];
-    DWORD result = GetCurrentDirectoryW(MAX_PATH, buf);
-    if (result < MAX_PATH)
-    {
-        recv->assign(buf);
-        return true;
-    }
-    else if (result != 0)
-    {
-        std::vector<pal::char_t> str;
-        str.resize(result);
-        result = GetCurrentDirectoryW(static_cast<uint32_t>(str.size()), str.data());
-        assert(result <= str.size());
-        if (result != 0)
-        {
-            recv->assign(str.data());
-            return true;
-        }
-    }
-    assert(result == 0);
-    trace::error(_X("Failed to obtain working directory, HRESULT: 0x%X"), HRESULT_FROM_WIN32(GetLastError()));
-    return false;
-}
-bool pal::get_loaded_library(
-    const char_t *library_name,
-    const char *symbol_name,
-    /*out*/ dll_t *dll,
-    /*out*/ pal::string_t *path)
-{
-    dll_t dll_maybe = ::GetModuleHandleW(library_name);
-    if (dll_maybe == nullptr)
-        return false;
-    *dll = dll_maybe;
-    return pal::get_module_path(*dll, path);
-}
-bool pal::load_library(const string_t* in_path, dll_t* dll)
-{
-    string_t path = *in_path;
-    if (LongFile::IsPathNotFullyQualified(path))
-    {
-        if (!pal::realpath(&path))
-        {
-            trace::error(_X("Failed to load the dll from [%s], HRESULT: 0x%X"), path.c_str(), HRESULT_FROM_WIN32(GetLastError()));
-            return false;
-        }
-    }
-    assert(!LongFile::IsPathNotFullyQualified(path) || !LongFile::ContainsDirectorySeparator(path));
-    *dll = ::LoadLibraryExW(path.c_str(), NULL, LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR | LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
-    if (*dll == nullptr)
-    {
-        trace::error(_X("Failed to load the dll from [%s], HRESULT: 0x%X"), path.c_str(), HRESULT_FROM_WIN32(GetLastError()));
-        return false;
-    }
-    HMODULE dummy_module;
-    if (!::GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_PIN, path.c_str(), &dummy_module))
-    {
-        trace::error(_X("Failed to pin library [%s] in [%s]"), path.c_str(), _STRINGIFY(__FUNCTION__));
-        return false;
-    }
-    if (trace::is_enabled())
-    {
-        string_t buf;
-        GetModuleFileNameWrapper(*dll, &buf);
-        trace::info(_X("Loaded library from %s"), buf.c_str());
-    }
-    return true;
-}
-pal::proc_t pal::get_symbol(dll_t library, const char* name)
-{
-    auto result = ::GetProcAddress(library, name);
-    if (result == nullptr)
-    {
-        trace::info(_X("Probed for and did not resolve library symbol %S"), name);
-    }
-    return result;
-}
-void pal::unload_library(dll_t library)
-{
-}
-static
-bool get_wow_mode_program_files(pal::string_t* recv)
-{
-#if defined(TARGET_AMD64)
-    const pal::char_t* env_key = _X("ProgramFiles(x86)");
-#else
-    const pal::char_t* env_key = _X("ProgramFiles");
-#endif
-    return get_file_path_from_env(env_key,recv);
-}
-bool pal::get_default_breadcrumb_store(string_t* recv)
-{
-    recv->clear();
-    pal::string_t prog_dat;
-    if (!get_file_path_from_env(_X("ProgramData"), &prog_dat))
-    {
-        trace::verbose(_X("Failed to read default breadcrumb store [%s]"), prog_dat.c_str());
-        return false;
-    }
-    recv->assign(prog_dat);
-    append_path(recv, _X("Microsoft"));
-    append_path(recv, _X("NetFramework"));
-    append_path(recv, _X("BreadcrumbStore"));
-    return true;
-}
-bool pal::get_default_servicing_directory(string_t* recv)
-{
-    if (!get_wow_mode_program_files(recv))
-    {
-        return false;
-    }
-    append_path(recv, _X("coreservicing"));
-    return true;
-}
-bool pal::get_default_installation_dir(pal::string_t* recv)
-{
-    pal::string_t environmentOverride;
-    if (test_only_getenv(_X("_DOTNET_TEST_DEFAULT_INSTALL_PATH"), &environmentOverride))
-    {
-        recv->assign(environmentOverride);
-        return true;
-    }
-    const pal::char_t* program_files_dir;
-    if (pal::is_running_in_wow64())
-    {
-        program_files_dir = _X("ProgramFiles(x86)");
-    }
-    else
-    {
-        program_files_dir = _X("ProgramFiles");
-    }
-    if (!get_file_path_from_env(program_files_dir, recv))
-    {
-        return false;
-    }
-    append_path(recv, _X("dotnet"));
-    if (pal::is_emulating_x64())
-    {
-        append_path(recv, _X("x64"));
-    }
-    return true;
-}
-namespace
-{
-    void get_dotnet_install_location_registry_path(HKEY * key_hive, pal::string_t * sub_key, const pal::char_t ** value)
-    {
-        *key_hive = HKEY_LOCAL_MACHINE;
-        pal::string_t dotnet_key_path = pal::string_t(_X("SOFTWARE\\dotnet"));
-        pal::string_t environmentRegistryPathOverride;
-        if (test_only_getenv(_X("_DOTNET_TEST_REGISTRY_PATH"), &environmentRegistryPathOverride))
-        {
-            pal::string_t hkcuPrefix = _X("HKEY_CURRENT_USER\\");
-            if (environmentRegistryPathOverride.substr(0, hkcuPrefix.length()) == hkcuPrefix)
-            {
-                *key_hive = HKEY_CURRENT_USER;
-                environmentRegistryPathOverride = environmentRegistryPathOverride.substr(hkcuPrefix.length());
-            }
-            dotnet_key_path = environmentRegistryPathOverride;
-        }
-        *sub_key = dotnet_key_path + pal::string_t(_X("\\Setup\\InstalledVersions\\")) + get_arch();
-        *value = _X("InstallLocation");
-    }
-}
-pal::string_t pal::get_dotnet_self_registered_config_location()
-{
-    HKEY key_hive;
-    pal::string_t sub_key;
-    const pal::char_t* value;
-    get_dotnet_install_location_registry_path(&key_hive, &sub_key, &value);
-    return (key_hive == HKEY_CURRENT_USER ? _X("HKCU\\") : _X("HKLM\\")) + sub_key + _X("\\") + value;
-}
-bool pal::get_dotnet_self_registered_dir(pal::string_t* recv)
-{
-    recv->clear();
-    pal::string_t environmentOverride;
-    if (test_only_getenv(_X("_DOTNET_TEST_GLOBALLY_REGISTERED_PATH"), &environmentOverride))
-    {
-        recv->assign(environmentOverride);
-        return true;
-    }
-    HKEY hkeyHive;
-    pal::string_t sub_key;
-    const pal::char_t* value;
-    get_dotnet_install_location_registry_path(&hkeyHive, &sub_key, &value);
-    HKEY hkey = NULL;
-    LSTATUS result = ::RegOpenKeyExW(hkeyHive, sub_key.c_str(), 0, KEY_READ | KEY_WOW64_32KEY, &hkey);
-    if (result != ERROR_SUCCESS)
-    {
-        trace::verbose(_X("Can't open the SDK installed location registry key, result: 0x%X"), result);
-        return false;
-    }
-    DWORD size = 0;
-    result = ::RegGetValueW(hkey, nullptr, value, RRF_RT_REG_SZ, nullptr, nullptr, &size);
-    if (result != ERROR_SUCCESS || size == 0)
-    {
-        trace::verbose(_X("Can't get the size of the SDK location registry value or it's empty, result: 0x%X"), result);
-        ::RegCloseKey(hkey);
-        return false;
-    }
-    std::vector<pal::char_t> buffer(size/sizeof(pal::char_t));
-    result = ::RegGetValueW(hkey, nullptr, value, RRF_RT_REG_SZ, nullptr, &buffer[0], &size);
-    if (result != ERROR_SUCCESS)
-    {
-        trace::verbose(_X("Can't get the value of the SDK location registry value, result: 0x%X"), result);
-        ::RegCloseKey(hkey);
-        return false;
-    }
-    recv->assign(buffer.data());
-    ::RegCloseKey(hkey);
-    return true;
-}
-bool pal::get_global_dotnet_dirs(std::vector<pal::string_t>* dirs)
-{
-    pal::string_t default_dir;
-    pal::string_t custom_dir;
-    bool dir_found = false;
-    if (pal::get_dotnet_self_registered_dir(&custom_dir))
-    {
-        remove_trailing_dir_seperator(&custom_dir);
-        dirs->push_back(custom_dir);
-        dir_found = true;
-    }
-    if (get_default_installation_dir(&default_dir))
-    {
-        remove_trailing_dir_seperator(&default_dir);
-        if (!dir_found || !are_paths_equal_with_normalized_casing(custom_dir, default_dir))
-        {
-            dirs->push_back(default_dir);
-            dir_found = true;
-        }
-    }
-    return dir_found;
-}
-typedef LONG (WINAPI *pFuncRtlGetVersion)(RTL_OSVERSIONINFOW *);
-pal::string_t pal::get_current_os_rid_platform()
-{
-    pal::string_t ridOS;
-    RTL_OSVERSIONINFOW osinfo;
-    ZeroMemory(&osinfo, sizeof(osinfo));
-    osinfo.dwOSVersionInfoSize = sizeof(osinfo);
-    HMODULE hmodNtdll = LoadLibraryA("ntdll.dll");
-    if (hmodNtdll != NULL)
-    {
-        pFuncRtlGetVersion pRtlGetVersion = (pFuncRtlGetVersion)GetProcAddress(hmodNtdll, "RtlGetVersion");
-        if (pRtlGetVersion)
-        {
-            if ((*pRtlGetVersion)(&osinfo) == 0)
-            {
-                uint32_t majorVer = 6;
-                uint32_t minorVer = 1;
-                if (osinfo.dwMajorVersion > majorVer)
-                {
-                    majorVer = osinfo.dwMajorVersion;
-                    minorVer = 0;
-                }
-                if (osinfo.dwMinorVersion > minorVer)
-                {
-                    minorVer = osinfo.dwMinorVersion;
-                }
-                if (majorVer == 6)
-                {
-                    switch(minorVer)
-                    {
-                        case 1:
-                            ridOS.append(_X("win7"));
-                            break;
-                        case 2:
-                            ridOS.append(_X("win8"));
-                            break;
-                        case 3:
-                        default:
-                            ridOS.append(_X("win81"));
-                            break;
-                    }
-                }
-                else if (majorVer >= 10)
-                {
-                    ridOS.append(_X("win"));
-                    ridOS.append(pal::to_string(majorVer));
-                }
-            }
-        }
-    }
-    return ridOS;
-}
-bool pal::is_path_rooted(const string_t& path)
-{
-    return path.length() >= 2 && path[1] == L':';
-}
-bool pal::getenv(const char_t* name, string_t* recv)
-{
-    recv->clear();
-    auto length = ::GetEnvironmentVariableW(name, nullptr, 0);
-    if (length == 0)
-    {
-        auto err = GetLastError();
-        if (err != ERROR_ENVVAR_NOT_FOUND)
-        {
-            trace::warning(_X("Failed to read environment variable [%s], HRESULT: 0x%X"), name, HRESULT_FROM_WIN32(err));
-        }
-        return false;
-    }
-    auto buf = new char_t[length];
-    if (::GetEnvironmentVariableW(name, buf, length) == 0)
-    {
-        auto err = GetLastError();
-        if (err != ERROR_ENVVAR_NOT_FOUND)
-        {
-            trace::warning(_X("Failed to read environment variable [%s], HRESULT: 0x%X"), name, HRESULT_FROM_WIN32(err));
-        }
-        return false;
-    }
-    recv->assign(buf);
-    delete[] buf;
-    return true;
-}
-int pal::xtoi(const char_t* input)
-{
-    return ::_wtoi(input);
-}
-bool pal::get_own_executable_path(string_t* recv)
-{
-    return GetModuleFileNameWrapper(NULL, recv);
-}
-bool pal::get_current_module(dll_t *mod)
-{
-    HMODULE hmod = nullptr;
-    if (!GetModuleHandleFromAddress(&get_current_module, &hmod))
-        return false;
-    *mod = (pal::dll_t)hmod;
-    return true;
-}
-bool pal::get_own_module_path(string_t* recv)
-{
-    HMODULE hmod;
-    if (!GetModuleHandleFromAddress(&get_own_module_path, &hmod))
-        return false;
-    return GetModuleFileNameWrapper(hmod, recv);
-}
-bool pal::get_method_module_path(string_t* recv, void* method)
-{
-    HMODULE hmod;
-    if (!GetModuleHandleFromAddress(method, &hmod))
-        return false;
-    return GetModuleFileNameWrapper(hmod, recv);
-}
-bool pal::get_module_path(dll_t mod, string_t* recv)
-{
-    return GetModuleFileNameWrapper(mod, recv);
-}
-bool get_extraction_base_parent_directory(pal::string_t& directory)
-{
-    const size_t max_len = MAX_PATH + 1;
-    pal::char_t temp_path[max_len];
-    size_t len = GetTempPathW(max_len, temp_path);
-    if (len == 0)
-    {
-        return false;
-    }
-    assert(len < max_len);
-    directory.assign(temp_path);
-    return pal::realpath(&directory);
-}
-bool pal::get_default_bundle_extraction_base_dir(pal::string_t& extraction_dir)
-{
-    if (!get_extraction_base_parent_directory(extraction_dir))
-    {
-        return false;
-    }
-    append_path(&extraction_dir, _X(".net"));
-    if (realpath(&extraction_dir))
-    {
-        return true;
-    }
-    if (CreateDirectoryW(extraction_dir.c_str(), NULL) == 0 &&
-        GetLastError() != ERROR_ALREADY_EXISTS)
-    {
-        return false;
-    }
-    return realpath(&extraction_dir);
-}
-static bool wchar_convert_helper(DWORD code_page, const char* cstr, size_t len, pal::string_t* out)
-{
-    out->clear();
-    size_t size = ::MultiByteToWideChar(code_page, 0, cstr, static_cast<uint32_t>(len), nullptr, 0);
-    if (size == 0)
-    {
-        return false;
-    }
-    out->resize(size, '\0');
-    return ::MultiByteToWideChar(code_page, 0, cstr, static_cast<uint32_t>(len), &(*out)[0], static_cast<uint32_t>(out->size())) != 0;
-}
-bool pal::pal_utf8string(const pal::string_t& str, std::vector<char>* out)
-{
-    out->clear();
-    size_t size = ::WideCharToMultiByte(CP_UTF8, 0, str.c_str(), -1, nullptr, 0, nullptr, nullptr);
-    if (size == 0)
-    {
-        return false;
-    }
-    out->resize(size, '\0');
-    return ::WideCharToMultiByte(CP_UTF8, 0, str.c_str(), -1, out->data(), static_cast<uint32_t>(out->size()), nullptr, nullptr) != 0;
-}
-bool pal::pal_clrstring(const pal::string_t& str, std::vector<char>* out)
-{
-    return pal_utf8string(str, out);
-}
-bool pal::clr_palstring(const char* cstr, pal::string_t* out)
-{
-    return wchar_convert_helper(CP_UTF8, cstr, ::strlen(cstr), out);
-}
-bool pal::realpath(string_t* path, bool skip_error_logging)
-{
-    if (path->empty())
-    {
-        return false;
-    }
-    if (LongFile::IsNormalized(*path))
-    {
-        WIN32_FILE_ATTRIBUTE_DATA data;
-        if (GetFileAttributesExW(path->c_str(), GetFileExInfoStandard, &data) != 0)
-        {
-            return true;
-        }
-    }
-    char_t buf[MAX_PATH];
-    size_t size = ::GetFullPathNameW(path->c_str(), MAX_PATH, buf, nullptr);
-    if (size == 0)
-    {
-        if (!skip_error_logging)
-        {
-            trace::error(_X("Error resolving full path [%s]"), path->c_str());
-        }
-        return false;
-    }
-    string_t str;
-    if (size < MAX_PATH)
-    {
-        str.assign(buf);
-    }
-    else
-    {
-        str.resize(size + LongFile::UNCExtendedPathPrefix.length(), 0);
-        size = ::GetFullPathNameW(path->c_str(), static_cast<uint32_t>(size), (LPWSTR)str.data(), nullptr);
-        assert(size <= str.size());
-        if (size == 0)
-        {
-            if (!skip_error_logging)
-            {
-                trace::error(_X("Error resolving full path [%s]"), path->c_str());
-            }
-            return false;
-        }
-        const string_t* prefix = &LongFile::ExtendedPrefix;
-        if (str.compare(0, LongFile::UNCPathPrefix.length(), LongFile::UNCPathPrefix) == 0)
-        {
-            prefix = &LongFile::UNCExtendedPathPrefix;
-            str.erase(0, LongFile::UNCPathPrefix.length());
-            size = size - LongFile::UNCPathPrefix.length();
-        }
-        str.insert(0, *prefix);
-        str.resize(size + prefix->length());
-        str.shrink_to_fit();
-    }
-    WIN32_FILE_ATTRIBUTE_DATA data;
-    if (GetFileAttributesExW(str.c_str(), GetFileExInfoStandard, &data) != 0)
-    {
-        *path = str;
-        return true;
-    }
-    return false;
-}
-bool pal::file_exists(const string_t& path)
-{
-    string_t tmp(path);
-    return pal::realpath(&tmp, true);
-}
-static void readdir(const pal::string_t& path, const pal::string_t& pattern, bool onlydirectories, std::vector<pal::string_t>* list)
-{
-    assert(list != nullptr);
-    std::vector<pal::string_t>& files = *list;
-    pal::string_t normalized_path(path);
-    if (LongFile::ShouldNormalize(normalized_path))
-    {
-        if (!pal::realpath(&normalized_path))
-        {
-            return;
-        }
-    }
-    pal::string_t search_string(normalized_path);
-    append_path(&search_string, pattern.c_str());
-    WIN32_FIND_DATAW data = { 0 };
-    auto handle = ::FindFirstFileExW(search_string.c_str(), FindExInfoStandard, &data, FindExSearchNameMatch, NULL, 0);
-    if (handle == INVALID_HANDLE_VALUE)
-    {
-        return;
-    }
-    do
-    {
-        if (!onlydirectories || (data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
-        {
-            pal::string_t filepath(data.cFileName);
-            if (filepath != _X(".") && filepath != _X(".."))
-            {
-                files.push_back(filepath);
-            }
-        }
-    } while (::FindNextFileW(handle, &data));
-    ::FindClose(handle);
-}
-void pal::readdir(const string_t& path, const string_t& pattern, std::vector<pal::string_t>* list)
-{
-    ::readdir(path, pattern, false, list);
-}
-void pal::readdir(const string_t& path, std::vector<pal::string_t>* list)
-{
-    ::readdir(path, _X("*"), false, list);
-}
-void pal::readdir_onlydirectories(const pal::string_t& path, const string_t& pattern, std::vector<pal::string_t>* list)
-{
-    ::readdir(path, pattern, true, list);
-}
-void pal::readdir_onlydirectories(const pal::string_t& path, std::vector<pal::string_t>* list)
-{
-    ::readdir(path, _X("*"), true, list);
-}
-bool pal::is_running_in_wow64()
-{
-    BOOL fWow64Process = FALSE;
-    if (!IsWow64Process(GetCurrentProcess(), &fWow64Process))
-    {
-        return false;
-    }
-    return (fWow64Process != FALSE);
-}
-typedef BOOL (WINAPI* is_wow64_process2)(
-    HANDLE hProcess,
-    USHORT *pProcessMachine,
-    USHORT *pNativeMachine
-);
-bool pal::is_emulating_x64()
-{
-#if defined(TARGET_AMD64)
-    auto kernel32 = LoadLibraryExW(L"kernel32.dll", NULL, LOAD_LIBRARY_SEARCH_SYSTEM32);
-    if (kernel32 == nullptr)
-    {
-        trace::info(_X("Could not load 'kernel32.dll': %u"), GetLastError());
-        return false;
-    }
-    is_wow64_process2 is_wow64_process2_func = (is_wow64_process2)::GetProcAddress(kernel32, "IsWow64Process2");
-    if (is_wow64_process2_func == nullptr)
-    {
-        return false;
-    }
-    USHORT process_machine;
-    USHORT native_machine;
-    if (!is_wow64_process2_func(GetCurrentProcess(), &process_machine, &native_machine))
-    {
-        trace::info(_X("Call to IsWow64Process2 failed: %u"), GetLastError());
-        return false;
-    }
-    return native_machine != IMAGE_FILE_MACHINE_AMD64;
-#else
-    return false;
-#endif
-}
-bool pal::are_paths_equal_with_normalized_casing(const string_t& path1, const string_t& path2)
-{
-    return (strcasecmp(path1.c_str(), path2.c_str()) == 0);
-}
-pal::mutex_t::mutex_t()
-    : _impl{ }
-{
-    ::InitializeCriticalSection(&_impl);
-}
-pal::mutex_t::~mutex_t()
-{
-    ::DeleteCriticalSection(&_impl);
-}
-void pal::mutex_t::lock()
-{
-    ::EnterCriticalSection(&_impl);
-}
-void pal::mutex_t::unlock()
-{
-    ::LeaveCriticalSection(&_impl);
-}

--- a/src/native/eventpipe/ds-ipc-pal-namedpipe.c
+++ b//dev/null
@@ -1,805 +0,0 @@
-#ifdef FEATURE_PERFTRACING_STANDALONE_PAL
-#define EP_NO_RT_DEPENDENCY
-#endif
-#include "ds-rt-config.h"
-#ifdef ENABLE_PERFTRACING
-#ifdef HOST_WIN32
-#define DS_IMPL_IPC_PAL_NAMEDPIPE_GETTER_SETTER
-#include "ds-ipc-pal-namedpipe.h"
-#include <assert.h>
-#include <stdlib.h>
-#include <stdio.h>
-#ifndef FEATURE_PERFTRACING_STANDALONE_PAL
-#include "ds-rt.h"
-#else
-#ifndef ep_raise_error_if_nok
-#define ep_raise_error_if_nok(expr) do { if (!(expr)) goto ep_on_error; } while (0)
-#endif
-#ifndef ep_raise_error
-#define ep_raise_error() do { goto ep_on_error; } while (0)
-#endif
-#ifndef ep_exit_error_handler
-#define ep_exit_error_handler() do { goto ep_on_exit; } while (0)
-#endif
-#ifndef EP_ASSERT
-#define EP_ASSERT assert
-#endif
-#ifndef DS_ENTER_BLOCKING_PAL_SECTION
-#define DS_ENTER_BLOCKING_PAL_SECTION
-#endif
-#ifndef DS_EXIT_BLOCKING_PAL_SECTION
-#define DS_EXIT_BLOCKING_PAL_SECTION
-#endif
-#undef ep_rt_object_alloc
-#define ep_rt_object_alloc(obj_type) ((obj_type *)calloc(1, sizeof(obj_type)))
-static
-inline
-void
-ep_rt_object_free (void *ptr)
-{
-	if (ptr)
-		free (ptr);
-}
-#endif /* !FEATURE_PERFTRACING_STANDALONE_PAL */
-static HANDLE _ipc_listen_ownership_handle = INVALID_HANDLE_VALUE;
-/*
- * Forward declares of all static functions.
- */
-static
-void
-ipc_stream_free_func (void *object);
-static
-bool
-ipc_stream_read_func (
-	void *object,
-	uint8_t *buffer,
-	uint32_t bytes_to_read,
-	uint32_t *bytes_read,
-	uint32_t timeout_ms);
-static
-bool
-ipc_stream_write_func (
-	void *object,
-	const uint8_t *buffer,
-	uint32_t bytes_to_write,
-	uint32_t *bytes_written,
-	uint32_t timeout_ms);
-static
-bool
-ipc_stream_flush_func (void *object);
-static
-bool
-ipc_stream_close_func (void *object);
-static
-void
-ipc_close_ownership_handle (
-    ds_ipc_error_callback_func callback);
-static
-bool
-ipc_createpipe_helper (
-	DiagnosticsIpc *ipc,
-	bool ensure_pipe_creation,
-	ds_ipc_error_callback_func callback);
-static
-DiagnosticsIpcStream *
-ipc_stream_alloc (
-	HANDLE pipe,
-	DiagnosticsIpcConnectionMode mode);
-/*
- * DiagnosticsIpc.
- */
-bool
-ds_ipc_pal_init (void)
-{
-	return true;
-}
-bool
-ds_ipc_pal_shutdown (ds_ipc_error_callback_func callback)
-{
-    ipc_close_ownership_handle(callback);
-	return true;
-}
-DiagnosticsIpc *
-ds_ipc_alloc (
-	const ep_char8_t *ipc_name,
-	DiagnosticsIpcConnectionMode mode,
-	ds_ipc_error_callback_func callback)
-{
-	int32_t characters_written = -1;
-	DiagnosticsIpc *instance = ep_rt_object_alloc (DiagnosticsIpc);
-	ep_raise_error_if_nok (instance != NULL);
-	instance->mode = mode;
-	instance->is_listening = false;
-	instance->overlap.hEvent = INVALID_HANDLE_VALUE;
-	instance->pipe = INVALID_HANDLE_VALUE;
-	if (ipc_name) {
-		characters_written = sprintf_s (
-			(char *)&instance->pipe_name,
-			(size_t)DS_IPC_WIN32_MAX_NAMED_PIPE_LEN,
-			(const char *)"\\\\.\\pipe\\%s",
-			ipc_name);
-	} else {
-		characters_written = sprintf_s (
-			(char *)&instance->pipe_name,
-			(size_t)DS_IPC_WIN32_MAX_NAMED_PIPE_LEN,
-			(const char *)"\\\\.\\pipe\\dotnet-diagnostic-%d",
-			GetCurrentProcessId ());
-	}
-	if (characters_written <= 0 || characters_written >= DS_IPC_WIN32_MAX_NAMED_PIPE_LEN) {
-		if (callback)
-			callback ("Failed to generate the named pipe name", characters_written);
-		ep_raise_error ();
-	}
-ep_on_exit:
-	return instance;
-ep_on_error:
-	ds_ipc_free (instance);
-	instance = NULL;
-	ep_exit_error_handler ();
-}
-void
-ds_ipc_free (DiagnosticsIpc *ipc)
-{
-	if (!ipc)
-		return;
-	ds_ipc_close (ipc, false, NULL);
-	ep_rt_object_free (ipc);
-}
-int32_t
-ds_ipc_poll (
-	DiagnosticsIpcPollHandle *poll_handles_data,
-	size_t poll_handles_data_len,
-	uint32_t timeout_ms,
-	ds_ipc_error_callback_func callback)
-{
-	EP_ASSERT (poll_handles_data != NULL);
-	int32_t result = 1;
-	EP_ASSERT (poll_handles_data_len <= MAXIMUM_WAIT_OBJECTS);
-	HANDLE handles [MAXIMUM_WAIT_OBJECTS];
-	for (size_t i = 0; i < poll_handles_data_len; ++i) {
-		poll_handles_data [i].events = 0; // ignore any input on events.
-		if (poll_handles_data [i].ipc) {
-			EP_ASSERT (poll_handles_data [i].ipc->mode == DS_IPC_CONNECTION_MODE_LISTEN);
-			handles [i] = poll_handles_data [i].ipc->overlap.hEvent;
-		} else {
-			bool success = true;
-			DWORD bytes_read = 1;
-			if (!poll_handles_data [i].stream->is_test_reading) {
-				success = ReadFile (
-					poll_handles_data [i].stream->pipe,                                   // handle
-					NULL,                                                                 // null buffer
-					0,                                                                    // read 0 bytesd
-					&bytes_read,                                                          // dummy variable
-					&poll_handles_data [i].stream->overlap);    // overlap object to use
-				poll_handles_data [i].stream->is_test_reading = true;
-				if (!success) {
-					DWORD error = GetLastError ();
-					switch (error) {
-					case ERROR_IO_PENDING:
-						handles [i] = poll_handles_data [i].stream->overlap.hEvent;
-						break;
-					case ERROR_PIPE_NOT_CONNECTED:
-						poll_handles_data [i].events = (uint8_t)DS_IPC_POLL_EVENTS_HANGUP;
-						result = -1;
-						ep_raise_error ();
-					default:
-						if (callback)
-							callback ("0 byte async read on client connection failed", error);
-						result = -1;
-						ep_raise_error ();
-					}
-				} else {
-					handles [i] = poll_handles_data [i].stream->overlap.hEvent;
-				}
-			} else {
-				handles [i] = poll_handles_data [i].stream->overlap.hEvent;
-			}
-		}
-	}
-	DWORD wait = WAIT_FAILED;
-	DS_ENTER_BLOCKING_PAL_SECTION;
-	wait = WaitForMultipleObjects (
-		(DWORD)poll_handles_data_len,      // count
-		handles,                           // handles
-		false,                             // don't wait all
-		(DWORD)timeout_ms);
-	DS_EXIT_BLOCKING_PAL_SECTION;
-	if (wait == WAIT_TIMEOUT) {
-		result = 0;
-		ep_raise_error ();
-	}
-	if (wait == WAIT_FAILED) {
-		if (callback)
-			callback ("WaitForMultipleObjects failed", GetLastError());
-		result = -1;
-		ep_raise_error ();
-	}
-	DWORD index = wait - WAIT_OBJECT_0;
-	if (index < 0 || index > (poll_handles_data_len - 1)) {
-		DWORD abandonedIndex = wait - WAIT_ABANDONED_0;
-		if (abandonedIndex > 0 || abandonedIndex < (poll_handles_data_len - 1)) {
-			poll_handles_data [abandonedIndex].events = (uint8_t)DS_IPC_POLL_EVENTS_HANGUP;
-			result = -1;
-			ep_raise_error ();
-		} else {
-			if (callback)
-				callback ("WaitForMultipleObjects failed", GetLastError());
-			result = -1;
-			ep_raise_error ();
-		}
-	}
-	if (!poll_handles_data [index].ipc) {
-		DWORD dummy = 0;
-		BOOL success = GetOverlappedResult(
-			poll_handles_data [index].stream->pipe,
-			&poll_handles_data [index].stream->overlap,
-			&dummy,
-			false);
-		if (!success && GetLastError () == ERROR_IO_INCOMPLETE) {
-			dummy = 0;
-			DS_ENTER_BLOCKING_PAL_SECTION;
-			success = GetOverlappedResult(
-				poll_handles_data [index].stream->pipe,
-				&poll_handles_data [index].stream->overlap,
-				&dummy,
-				true);
-			DS_EXIT_BLOCKING_PAL_SECTION;
-		}
-		poll_handles_data [index].stream->is_test_reading = false;
-		if (!success) {
-			DWORD error = GetLastError();
-			if (error == ERROR_PIPE_NOT_CONNECTED || error == ERROR_BROKEN_PIPE) {
-				poll_handles_data [index].events = (uint8_t)DS_IPC_POLL_EVENTS_HANGUP;
-			} else {
-				if (callback)
-					callback ("Client connection error", error);
-				poll_handles_data [index].events = (uint8_t)DS_IPC_POLL_EVENTS_ERR;
-				result = -1;
-				ep_raise_error ();
-			}
-		} else {
-			poll_handles_data [index].events = (uint8_t)DS_IPC_POLL_EVENTS_SIGNALED;
-		}
-	} else {
-		poll_handles_data [index].events = (uint8_t)DS_IPC_POLL_EVENTS_SIGNALED;
-	}
-	result = 1;
-ep_on_exit:
-	return result;
-ep_on_error:
-	if (result == 1)
-		result = -1;
-	ep_exit_error_handler ();
-}
-static
-bool
-ipc_createpipe_helper (
-	DiagnosticsIpc *ipc,
-	bool ensure_pipe_creation,
-	ds_ipc_error_callback_func callback)
-{
-	bool result = false;
-	EP_ASSERT (ipc != NULL);
-	EP_ASSERT (ipc->mode == DS_IPC_CONNECTION_MODE_LISTEN);
-	if (ipc->mode != DS_IPC_CONNECTION_MODE_LISTEN) {
-		if (callback)
-			callback ("Cannot call Listen on a client connection", -1);
-		return false;
-	}
-	if (ipc->is_listening)
-		return true;
-    if (!ensure_pipe_creation && _ipc_listen_ownership_handle == INVALID_HANDLE_VALUE)
-    {
-        if (callback)
-			callback ("Can't ensure we have ownership of the pipe. Disallowing creation.", -1);
-		return false;
-    }
-    if (ensure_pipe_creation && _ipc_listen_ownership_handle != INVALID_HANDLE_VALUE)
-    {
-        if (callback)
-			callback ("Inconsistent state - pipe sentinel already in use for listen.", -1);
-		return false;
-    }
-    EP_ASSERT (ipc->pipe == INVALID_HANDLE_VALUE);
-	const uint32_t in_buffer_size = 16 * 1024;
-	const uint32_t out_buffer_size = 16 * 1024;
-	DWORD creationFlags = PIPE_ACCESS_DUPLEX    // read/write access
-                | FILE_FLAG_OVERLAPPED;	        // async listening.
-	if (ensure_pipe_creation)
-	{
-		creationFlags |= FILE_FLAG_FIRST_PIPE_INSTANCE;
-	}
-	DS_ENTER_BLOCKING_PAL_SECTION;
-	ipc->pipe = CreateNamedPipeA (
-		ipc->pipe_name,                                             // pipe name
-		creationFlags,
-		PIPE_TYPE_BYTE | PIPE_WAIT | PIPE_REJECT_REMOTE_CLIENTS,    // message type pipe, message-read and blocking mode
-		PIPE_UNLIMITED_INSTANCES,                                   // max. instances
-		out_buffer_size,                                            // output buffer size
-		in_buffer_size,                                             // input buffer size
-		0,                                                          // default client time-out
-		NULL);                                                      // default security attribute
-	DS_EXIT_BLOCKING_PAL_SECTION;
-	if (ipc->pipe == INVALID_HANDLE_VALUE) {
-		if (callback)
-			callback ("Failed to create an instance of a named pipe.", GetLastError());
-		ep_raise_error ();
-	}
-    if (ensure_pipe_creation)
-	{
-	    EP_ASSERT (_ipc_listen_ownership_handle == INVALID_HANDLE_VALUE);
-        bool createdSentinel = DuplicateHandle(
-                                    GetCurrentProcess(),
-                                    ipc->pipe,
-                                    GetCurrentProcess(),
-                                    &_ipc_listen_ownership_handle,
-                                    0,
-                                    FALSE,
-                                    DUPLICATE_SAME_ACCESS);
-        if (!createdSentinel)
-        {
-            if (callback)
-			    callback ("Failed to ownership sentinel.", GetLastError());
-            ep_raise_error();
-        }
-	}
-	EP_ASSERT (ipc->overlap.hEvent == INVALID_HANDLE_VALUE);
-	ipc->overlap.hEvent = CreateEventW (NULL, true, false, NULL);
-	if (!ipc->overlap.hEvent) {
-		if (callback)
-			callback ("Failed to create overlap event", GetLastError());
-		ep_raise_error ();
-	}
-	if (ConnectNamedPipe (ipc->pipe, &ipc->overlap) == FALSE) {
-		const DWORD error_code = GetLastError ();
-		switch (error_code) {
-		case ERROR_IO_PENDING:
-		case ERROR_PIPE_CONNECTED:
-			break;
-		default:
-			if (callback)
-				callback ("A client process failed to connect.", error_code);
-			ep_raise_error ();
-		}
-	}
-	ipc->is_listening = true;
-	result = true;
-ep_on_exit:
-	return result;
-ep_on_error:
-	ds_ipc_close (ipc, false, callback);
-    if (ensure_pipe_creation)
-        ipc_close_ownership_handle(callback);
-	result = false;
-	ep_exit_error_handler ();
-}
-bool
-ds_ipc_listen (
-	DiagnosticsIpc *ipc,
-	ds_ipc_error_callback_func callback)
-{
-	return ipc_createpipe_helper(ipc, true, callback);
-}
-DiagnosticsIpcStream *
-ds_ipc_accept (
-	DiagnosticsIpc *ipc,
-	ds_ipc_error_callback_func callback)
-{
-	EP_ASSERT (ipc != NULL);
-	EP_ASSERT (ipc->mode == DS_IPC_CONNECTION_MODE_LISTEN);
-	DiagnosticsIpcStream *stream = NULL;
-	DWORD dummy = 0;
-	BOOL success = GetOverlappedResult (
-		ipc->pipe,      // handle
-		&ipc->overlap,  // overlapped
-		&dummy,         // throw-away dword
-		false);         // wait till event signals
-	if (!success && GetLastError () == ERROR_IO_INCOMPLETE) {
-		dummy = 0;
-		DS_ENTER_BLOCKING_PAL_SECTION;
-		success = GetOverlappedResult (
-			ipc->pipe,      // handle
-			&ipc->overlap,  // overlapped
-			&dummy,         // throw-away dword
-			true);          // wait till event signals
-		DS_EXIT_BLOCKING_PAL_SECTION;
-	}
-	if (!success) {
-		if (callback)
-			callback ("Failed to GetOverlappedResults for NamedPipe server", GetLastError());
-		CloseHandle (ipc->pipe);
-	} else {
-		stream = ipc_stream_alloc (ipc->pipe, DS_IPC_CONNECTION_MODE_LISTEN);
-		ep_raise_error_if_nok (stream != NULL);
-	}
-	ipc->pipe = INVALID_HANDLE_VALUE;
-	ipc->is_listening = false;
-	CloseHandle (ipc->overlap.hEvent);
-	memset(&ipc->overlap, 0, sizeof(OVERLAPPED)); // clear the overlapped objects state
-	ipc->overlap.hEvent = INVALID_HANDLE_VALUE;
-	ep_raise_error_if_nok (ipc_createpipe_helper (ipc, false, callback));
-ep_on_exit:
-	return stream;
-ep_on_error:
-	ds_ipc_stream_free (stream);
-	stream = NULL;
-	ep_exit_error_handler ();
-}
-DiagnosticsIpcStream *
-ds_ipc_connect (
-	DiagnosticsIpc *ipc,
-	uint32_t timeout_ms,
-	ds_ipc_error_callback_func callback,
-	bool *timed_out)
-{
-	EP_ASSERT (ipc != NULL);
-	EP_ASSERT (timed_out != NULL);
-	EP_ASSERT (ipc->mode == DS_IPC_CONNECTION_MODE_CONNECT);
-	DiagnosticsIpcStream *stream = NULL;
-	HANDLE pipe = INVALID_HANDLE_VALUE;
-	if (ipc->mode != DS_IPC_CONNECTION_MODE_CONNECT) {
-		if (callback)
-			callback ("Cannot call connect on a server connection", 0);
-		ep_raise_error ();
-	}
-	DS_ENTER_BLOCKING_PAL_SECTION;
-	pipe = CreateFileA(
-		ipc->pipe_name,         // pipe name
-		PIPE_ACCESS_DUPLEX,     // read/write access
-		0,                      // no sharing
-		NULL,                   // default security attributes
-		OPEN_EXISTING,          // opens existing pipe
-		FILE_FLAG_OVERLAPPED,   // overlapped
-		NULL);                  // no template file
-	DS_EXIT_BLOCKING_PAL_SECTION;
-	if (pipe == INVALID_HANDLE_VALUE) {
-		if (callback)
-			callback ("Failed to connect to named pipe.", GetLastError ());
-		ep_raise_error ();
-	}
-	stream = ipc_stream_alloc (pipe, ipc->mode);
-	ep_raise_error_if_nok (stream);
-	pipe = INVALID_HANDLE_VALUE;
-ep_on_exit:
-	return stream;
-ep_on_error:
-	ds_ipc_stream_free (stream);
-	stream = NULL;
-	if (pipe != INVALID_HANDLE_VALUE) {
-		CloseHandle (pipe);
-	}
-	ep_exit_error_handler ();
-}
-void
-ipc_close_ownership_handle (
-    ds_ipc_error_callback_func callback)
-{
-    if (_ipc_listen_ownership_handle == INVALID_HANDLE_VALUE)
-        return;
-    const BOOL success_close_pipe = CloseHandle(_ipc_listen_ownership_handle);
-    if (success_close_pipe != TRUE)
-    {
-        if (callback)
-            callback ("Failed to IPC ownership sentinel handle", GetLastError());
-        return;
-    }
-    _ipc_listen_ownership_handle = INVALID_HANDLE_VALUE;
-}
-void
-ds_ipc_close (
-	DiagnosticsIpc *ipc,
-	bool is_shutdown,
-	ds_ipc_error_callback_func callback)
-{
-	EP_ASSERT (ipc != NULL);
-	if (is_shutdown) {
-		if (callback)
-			callback ("Closing without cleaning underlying handles", 100);
-		return;
-	}
-	if (ipc->pipe != INVALID_HANDLE_VALUE) {
-		if (ipc->mode == DS_IPC_CONNECTION_MODE_LISTEN) {
-			BOOL success_disconnect = FALSE;
-			DS_ENTER_BLOCKING_PAL_SECTION;
-			success_disconnect = DisconnectNamedPipe (ipc->pipe);
-			DS_EXIT_BLOCKING_PAL_SECTION;
-			if (success_disconnect != TRUE && callback)
-				callback ("Failed to disconnect NamedPipe", GetLastError());
-		}
-		const BOOL success_close_pipe = CloseHandle (ipc->pipe);
-		if (success_close_pipe != TRUE && callback)
-			callback ("Failed to close pipe handle", GetLastError());
-		ipc->pipe = INVALID_HANDLE_VALUE;
-	}
-	if (ipc->overlap.hEvent != INVALID_HANDLE_VALUE) {
-		const BOOL success_close_event = CloseHandle (ipc->overlap.hEvent);
-		if (success_close_event != TRUE && callback)
-			callback ("Failed to close overlap event handle", GetLastError());
-		memset(&ipc->overlap, 0, sizeof(OVERLAPPED)); // clear the overlapped objects state
-		ipc->overlap.hEvent = INVALID_HANDLE_VALUE;
-	}
-}
-int32_t
-ds_ipc_to_string (
-	DiagnosticsIpc *ipc,
-	ep_char8_t *buffer,
-	uint32_t buffer_len)
-{
-	EP_ASSERT (ipc != NULL);
-	EP_ASSERT (buffer != NULL);
-	EP_ASSERT (buffer_len <= DS_IPC_MAX_TO_STRING_LEN);
-	int32_t result = sprintf_s (buffer, buffer_len, "{ _hPipe = %d, _oOverlap.hEvent = %d }", (int32_t)(size_t)ipc->pipe, (int32_t)(size_t)ipc->overlap.hEvent);
-	return (result > 0 && result < (int32_t)buffer_len) ? result : 0;
-}
-/*
- * DiagnosticsIpcStream.
- */
-static
-void
-ipc_stream_free_func (void *object)
-{
-	EP_ASSERT (object != NULL);
-	DiagnosticsIpcStream *ipc_stream = (DiagnosticsIpcStream *)object;
-	ds_ipc_stream_free (ipc_stream);
-}
-static
-bool
-ipc_stream_read_func (
-	void *object,
-	uint8_t *buffer,
-	uint32_t bytes_to_read,
-	uint32_t *bytes_read,
-	uint32_t timeout_ms)
-{
-	EP_ASSERT (object != NULL);
-	EP_ASSERT (buffer != NULL);
-	EP_ASSERT (bytes_read != NULL);
-	DiagnosticsIpcStream *ipc_stream = (DiagnosticsIpcStream *)object;
-	DWORD read = 0;
-	LPOVERLAPPED overlap = &ipc_stream->overlap;
-	bool success = ReadFile (
-		ipc_stream->pipe,   // handle to pipe
-		buffer,             // buffer to receive data
-		bytes_to_read,      // size of buffer
-		&read,              // number of bytes read
-		overlap) != FALSE;  // overlapped I/O
-	if (!success) {
-		DWORD error = GetLastError ();
-		if (error == ERROR_IO_PENDING) {
-			if (timeout_ms == DS_IPC_TIMEOUT_INFINITE) {
-				DS_ENTER_BLOCKING_PAL_SECTION;
-				success = GetOverlappedResult (
-					ipc_stream->pipe,   // pipe
-					overlap,            // overlapped
-					&read,              // out actual number of bytes read
-					true) != FALSE;     // block until async IO completes
-				DS_EXIT_BLOCKING_PAL_SECTION;
-			} else {
-				DS_ENTER_BLOCKING_PAL_SECTION;
-				DWORD wait = WaitForSingleObject (ipc_stream->overlap.hEvent, (DWORD)timeout_ms);
-				if (wait == WAIT_OBJECT_0) {
-					success = GetOverlappedResult (
-						ipc_stream->pipe,   // pipe
-						overlap,            // overlapped
-						&read,              // out actual number of bytes read
-						true) != FALSE;     // block until async IO completes
-				} else {
-					if (CancelIoEx (ipc_stream->pipe, overlap) != FALSE) {
-						success = GetOverlappedResult (
-							ipc_stream->pipe,   // pipe
-							overlap,            // overlapped
-							&read,              // out actual number of bytes read
-							true) != FALSE;     // block until async IO completes
-					}
-				}
-				DS_EXIT_BLOCKING_PAL_SECTION;
-			}
-		}
-	}
-	*bytes_read = (uint32_t)read;
-	return success;
-}
-static
-bool
-ipc_stream_write_func (
-	void *object,
-	const uint8_t *buffer,
-	uint32_t bytes_to_write,
-	uint32_t *bytes_written,
-	uint32_t timeout_ms)
-{
-	EP_ASSERT (object != NULL);
-	EP_ASSERT (buffer != NULL);
-	EP_ASSERT (bytes_written != NULL);
-	DiagnosticsIpcStream *ipc_stream = (DiagnosticsIpcStream *)object;
-	DWORD written = 0;
-	LPOVERLAPPED overlap = &ipc_stream->overlap;
-	bool success = WriteFile (
-		ipc_stream->pipe,   // handle to pipe
-		buffer,             // buffer to write from
-		bytes_to_write,     // number of bytes to write
-		&written,           // number of bytes written
-		overlap) != FALSE;  // overlapped I/O
-	if (!success) {
-		DWORD error = GetLastError ();
-		if (error == ERROR_IO_PENDING) {
-			if (timeout_ms == DS_IPC_TIMEOUT_INFINITE) {
-				DS_ENTER_BLOCKING_PAL_SECTION;
-				success = GetOverlappedResult (
-					ipc_stream->pipe,   // pipe
-					overlap,            // overlapped
-					&written,           // out actual number of bytes written
-					true) != FALSE;     // block until async IO completes
-				DS_EXIT_BLOCKING_PAL_SECTION;
-			} else {
-				DS_ENTER_BLOCKING_PAL_SECTION;
-				DWORD wait = WaitForSingleObject (ipc_stream->overlap.hEvent, (DWORD)timeout_ms);
-				if (wait == WAIT_OBJECT_0) {
-					success = GetOverlappedResult (
-						ipc_stream->pipe,   // pipe
-						overlap,            // overlapped
-						&written,           // out actual number of bytes written
-						true) != FALSE;     // block until async IO completes
-				} else {
-					if (CancelIoEx (ipc_stream->pipe, overlap) != FALSE) {
-						success = GetOverlappedResult (
-							ipc_stream->pipe,   // pipe
-							overlap,            // overlapped
-							&written,           // out actual number of bytes written
-							true) != FALSE;         // block until async IO completes
-					}
-				}
-				DS_EXIT_BLOCKING_PAL_SECTION;
-			}
-		}
-	}
-	*bytes_written = (uint32_t)written;
-	return success;
-}
-static
-bool
-ipc_stream_flush_func (void *object)
-{
-	EP_ASSERT (object != NULL);
-	DiagnosticsIpcStream *ipc_stream = (DiagnosticsIpcStream *)object;
-	bool success = false;
-	DS_ENTER_BLOCKING_PAL_SECTION;
-	success = FlushFileBuffers (ipc_stream->pipe) != FALSE;
-	DS_EXIT_BLOCKING_PAL_SECTION;
-	return success;
-}
-static
-bool
-ipc_stream_close_func (void *object)
-{
-	EP_ASSERT (object != NULL);
-	DiagnosticsIpcStream *ipc_stream = (DiagnosticsIpcStream *)object;
-	return ds_ipc_stream_close (ipc_stream, NULL);
-}
-static IpcStreamVtable ipc_stream_vtable = {
-	ipc_stream_free_func,
-	ipc_stream_read_func,
-	ipc_stream_write_func,
-	ipc_stream_flush_func,
-	ipc_stream_close_func };
-static
-DiagnosticsIpcStream *
-ipc_stream_alloc (
-	HANDLE pipe,
-	DiagnosticsIpcConnectionMode mode)
-{
-	DiagnosticsIpcStream *instance = ep_rt_object_alloc (DiagnosticsIpcStream);
-	ep_raise_error_if_nok (instance != NULL);
-	instance->stream.vtable = &ipc_stream_vtable;
-	instance->pipe = pipe;
-	instance->mode = mode;
-	instance->overlap.hEvent = CreateEventW (NULL, true, false, NULL);
-ep_on_exit:
-	return instance;
-ep_on_error:
-	ds_ipc_stream_free (instance);
-	instance = NULL;
-	ep_exit_error_handler ();
-}
-int32_t
-ds_ipc_stream_get_handle_int32_t (DiagnosticsIpcStream *ipc_stream)
-{
-	return (int32_t)(size_t)ipc_stream->pipe;
-}
-IpcStream *
-ds_ipc_stream_get_stream_ref (DiagnosticsIpcStream *ipc_stream)
-{
-	return &ipc_stream->stream;
-}
-void
-ds_ipc_stream_free (DiagnosticsIpcStream *ipc_stream)
-{
-	if (!ipc_stream)
-		return;
-	ds_ipc_stream_close (ipc_stream, NULL);
-	ep_rt_object_free (ipc_stream);
-}
-bool
-ds_ipc_stream_read (
-	DiagnosticsIpcStream *ipc_stream,
-	uint8_t *buffer,
-	uint32_t bytes_to_read,
-	uint32_t *bytes_read,
-	uint32_t timeout_ms)
-{
-	return ipc_stream_read_func (
-		ipc_stream,
-		buffer,
-		bytes_to_read,
-		bytes_read,
-		timeout_ms);
-}
-bool
-ds_ipc_stream_write (
-	DiagnosticsIpcStream *ipc_stream,
-	const uint8_t *buffer,
-	uint32_t bytes_to_write,
-	uint32_t *bytes_written,
-	uint32_t timeout_ms)
-{
-	return ipc_stream_write_func (
-		ipc_stream,
-		buffer,
-		bytes_to_write,
-		bytes_written,
-		timeout_ms);
-}
-bool
-ds_ipc_stream_flush (DiagnosticsIpcStream *ipc_stream)
-{
-	return ipc_stream_flush_func (ipc_stream);
-}
-bool
-ds_ipc_stream_close (
-	DiagnosticsIpcStream *ipc_stream,
-	ds_ipc_error_callback_func callback)
-{
-	EP_ASSERT (ipc_stream != NULL);
-	if (ipc_stream->pipe != INVALID_HANDLE_VALUE) {
-		ds_ipc_stream_flush (ipc_stream);
-		if (ipc_stream->mode == DS_IPC_CONNECTION_MODE_LISTEN) {
-			BOOL success_disconnect = FALSE;
-			DS_ENTER_BLOCKING_PAL_SECTION;
-			success_disconnect = DisconnectNamedPipe (ipc_stream->pipe);
-			DS_EXIT_BLOCKING_PAL_SECTION;
-			if (success_disconnect != TRUE && callback)
-				callback ("Failed to disconnect NamedPipe", GetLastError());
-		}
-		const BOOL success_close_pipe = CloseHandle (ipc_stream->pipe);
-		if (success_close_pipe != TRUE && callback)
-			callback ("Failed to close pipe handle", GetLastError());
-		ipc_stream->pipe = INVALID_HANDLE_VALUE;
-	}
-	if (ipc_stream->overlap.hEvent != INVALID_HANDLE_VALUE) {
-		const BOOL success_close_event = CloseHandle (ipc_stream->overlap.hEvent);
-		if (success_close_event != TRUE && callback)
-			callback ("Failed to close overlapped event handle", GetLastError());
-		memset(&ipc_stream->overlap, 0, sizeof(OVERLAPPED)); // clear the overlapped objects state
-		ipc_stream->overlap.hEvent = INVALID_HANDLE_VALUE;
-	}
-	ipc_stream->is_test_reading = false;
-	return true;
-}
-int32_t
-ds_ipc_stream_to_string (
-	DiagnosticsIpcStream *ipc_stream,
-	ep_char8_t *buffer,
-	uint32_t buffer_len)
-{
-	EP_ASSERT (ipc_stream != NULL);
-	EP_ASSERT (buffer != NULL);
-	EP_ASSERT (buffer_len <= DS_IPC_MAX_TO_STRING_LEN);
-	int32_t result = sprintf_s (buffer, buffer_len, "{ _hPipe = %d, _oOverlap.hEvent = %d }", (int32_t)(size_t)ipc_stream->pipe, (int32_t)(size_t)ipc_stream->overlap.hEvent);
-	return (result > 0 && result < (int32_t)buffer_len) ? result : 0;
-}
-#endif /* HOST_WIN32 */
-#endif /* ENABLE_PERFTRACING */
-#ifndef DS_INCLUDE_SOURCE_FILES
-extern const char quiet_linker_empty_file_warning_diagnostics_ipc_win32;
-const char quiet_linker_empty_file_warning_diagnostics_ipc_win32 = 0;
-#endif
